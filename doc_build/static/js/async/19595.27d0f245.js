"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19595"],{251723:function(n,e,i){i.r(e),i.d(e,{default:()=>j});var s=i(552676),r=i(740453);let a=i.p+"static/image/d0c44ef3e0f8c163dc8c577205370aaf.54ebbe79.webp",l=i.p+"static/image/728e4878cf3c5c7d517431e1e3d0a40d.049d2aca.webp",c=i.p+"static/image/0c7ec480f221e55e961f5676d541ba30.d049b9d8.webp",t=i.p+"static/image/7226869eeb1166262a80115b47675723.e35caefd.webp",d=i.p+"static/image/0bb358d5caf7757ce3d84f9070059a10.3df43a04.webp",p=i.p+"static/image/f61fc492673227cffec1df6c64794479.2ac6ca41.webp",h=i.p+"static/image/e3c729ca6f9589f2949cdc41f528a9bc.b5fdfa09.webp",o=i.p+"static/image/b79d501c4af6dc1e22cd7a0b4743f618.ac28710b.webp";function m(n){let e=Object.assign({p:"p",ul:"ul",li:"li",h2:"h2",a:"a",h3:"h3",img:"img",pre:"pre",code:"code"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"前面的章节一直都是在教大家搭建工程。大家一定觉得非常辛苦，一直在跳坑。即使然叔的描述再精确，由于版本和各种不可预知的原因，都会造成各种各样的问题。一个项目中搭建框架的人就好比项目的开路先锋，他跳坑是为了不让别人继续跳坑。"}),"\n",(0,s.jsx)(e.p,{children:"那么怎样让搭建的工程框架复用起来，让大部队享受开路先锋创造的工程成果呢？ 答案就是脚手架工具。比如 Vue 有 vue-cli，React 有 create-react-app 等。这节课我们就学习如何创建脚手架程序。"}),"\n",(0,s.jsx)(e.p,{children:"对于一个组件库来讲，脚手架一般分为两种："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Create-smarty-ui-app  :  创建使用 Smarty-UI 组件库的程序的脚手架；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Create-xxx-ui ： 创建和 Smarty-UI 类似的组件库的脚手架，也就是复用我们上面的架构。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"实际上这两种脚手架原理和功能都非常相似。我们就以第一种为例子给大家介绍如何编写脚手架程序。"}),"\n",(0,s.jsxs)(e.h2,{id:"用户故事userstory",children:["用户故事(UserStory)",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#用户故事userstory",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"编写一个 Create-smarty-ui-app 脚手架程序， 让用户可以轻松搭建使用 Smarty-UI 的应用程序。"}),"\n",(0,s.jsxs)(e.h2,{id:"任务分解task",children:["任务分解(Task)",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#任务分解task",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"创建模版项目；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"初始化 CLI 项目；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"创建命令行界面；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"克隆项目模版；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"模版生成代码；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"上传 Npm 仓库。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"cli-与-脚手架的概念",children:["CLI 与 脚手架的概念",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#cli-与-脚手架的概念",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"用惯了 vue-cli 或者 create-react-app 的前端人可能都会认为，cli 与脚手架是一个概念。其实它们几乎是雷锋和雷峰塔的关系。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:"img"})}),"\n",(0,s.jsx)(e.p,{children:"先讲讲脚手架，脚手架的概念来自于工程。脚手架就是为了工程顺利进行而搭建的工程平台。用在软件开发中，就是帮助开发过程的工具和环境配置的集合。简单来说，目前组件库的状态就是一个脚手架。虽然只有一个组件，但是为组件库的环境配置和工具已经整合完成了。这就好像一个高楼搭建前搭建的脚手架已经完成一样，另外只有一个样板间。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:h,alt:"img"})}),"\n",(0,s.jsx)(e.p,{children:"其次说一下 CLI 工具是什么。 CLI 是英文 command-line interface 的简写，翻译为命令行界面。也就是只在用户提示符下键入可执行命令的界面。通常脚手架程序会通过 CLI 的形式封装，这样做更加符合程序员的习惯，相比开发完整的 UI 开发效率更高。所以目前看到的大多数脚手架都是以 CLI 工具的形式封装的。久而久之，大家也就比较习惯将 CLI 与脚手架混为在一起了。"}),"\n",(0,s.jsx)(e.p,{children:"明白了概念后我们正式开始。"}),"\n",(0,s.jsx)(e.p,{children:"这次我们要开发的脚手架 create-smarty-app ，功能是可以快速创建一个使用 Smarty-UI 开发的项目模版。也就是说，假设你想使用 smarty-ui 开发项目，可以直接使用脚手架创建一个空的项目，里面包含的 vite + vue3 + smarty-ui 组件。直接开发逻辑就好了。"}),"\n",(0,s.jsx)(e.p,{children:"当然这个功能还比较初级，后续还可以不断迭代。但是麻雀虽小五脏俱全，基本上这里面会将脚手架工具所使用的工具都会演示一遍。"}),"\n",(0,s.jsx)(e.p,{children:"一般一个脚手架项目会有两部分组成："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Template 项目： 项目的模版；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"CLI 工具项目： 提供命令行界面用于克隆项目，生成代码、自动配置、运行调试、发布等功能。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"其实有兴趣的同学可以看一下 vue-cli ，它就是这样工作的。甚至你可以分析一下源码，找找 vue-cli 的模版项目放在 Github 的什么位置。"}),"\n",(0,s.jsxs)(e.h3,{id:"创建模版项目",children:["创建模版项目",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#创建模版项目",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"这一步，主要就是创建一个程序的模版。其实就是从零搭建一个Vue3 + Vite 环境并且引入 Smarty-UI。"}),"\n",(0,s.jsx)(e.p,{children:"首先，选择使用 vite-cli 工具直接搭建项目。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vite  启动；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用 Javascript 语言；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"全局引入 Samrty-UI。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"这个过程其实就是使用 Vite 脚手架工具搭建一个 vue3 项目，然后引入 smarty-ui 组件。"}),"\n",(0,s.jsx)(e.p,{children:"详细过程不再赘述，可以参考代码。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://github.com/smarty-team/smarty-ui-app-js-template",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/smarty-team/smarty-ui-app-js-template"})}),"\n",(0,s.jsx)(e.p,{children:"这个模版工程搭建也可以根据喜好加入一下个性化的代码。"}),"\n",(0,s.jsxs)(e.h3,{id:"初始化-cli-项目",children:["初始化 CLI 项目",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化-cli-项目",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"有了模版项目，接下来需要创建脚手架。"}),"\n",(0,s.jsx)(e.p,{children:"脚手架主要的运行过程如下。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"提供命令行界面："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"选择代码模版 ；"}),"\n",(0,s.jsx)(e.li,{children:"填写项目名称。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"克隆模版项目；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"根据项目名称及其他配置生成代码。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"这一步的目的主要是搭建一个基础的 CLI 环境。也就是可以用一个全局命令调用到 CLI 工具的 JS 程序。 CLI 工具是可以在全局执行的程序。也就是说，将 npm 软件包中的一个 JS 文件注册到全局。"}),"\n",(0,s.jsx)(e.p,{children:"下面讲一下基本原理，比如： 全局安装 vue-cli。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:"sudo npm i @vue/cli -g\n"})}),"\n",(0,s.jsx)(e.p,{children:"以 Mac 为例。npm 首先会把软件包下载到 /lib/node_modules/@vue/cli 目录下。然后 npm 会根据 @vue/cli 软件包中 package.json 的 bin 字段中的配置，将 bin/vue.js 文件软连接到 /usr/local/bin 中去。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:"img"})}),"\n",(0,s.jsx)(e.p,{children:"你可以使用 ls -l 查看一下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:"ls -l /usr/local/bin\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:"img"})}),"\n",(0,s.jsx)(e.p,{children:"这个时候你就可以全局执行 vue 这个命令了。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:"img"})}),"\n",(0,s.jsx)(e.p,{children:"其他操作系统原理类似，大家可以自行探索。这个过程实际上是 npm 包管理工具帮你实现的，大家不用过多关心。"}),"\n",(0,s.jsx)(e.p,{children:"弄清楚了基本原理，下面还有一个问题需要解决。这个问题就是需要提供一种调试CLI工具的方法。显然在调试代码时，将代码不断上传到 npm 仓库然后再全局安装太繁琐了。解决的办法就是使用 npm link 来模拟这个软连接过程。也就是说 npm link 就是在模拟全局安装。"}),"\n",(0,s.jsx)(e.p,{children:"下面开始实际操作。"}),"\n",(0,s.jsx)(e.p,{children:"首先创建项目。在 packages 目录下创建 cli 项目。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:"mkdir create-smarty-app-cli\ncd create-smarty-app-cli\npnpm init\n"})}),"\n",(0,s.jsx)(e.p,{children:"在 packages/create-smarty-app-cli/bin 中添加一个 index.js 作为文件的入口。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:"#!/usr/bin/env node\nconsole.log('create-smarty ....')\n"})}),"\n",(0,s.jsx)(e.p,{children:"这里面第一行 #!/usr/bin/env node ，这个要讲一下它的功能。首先这个 index.js 程序不是常规的使用 node xxx 命令执行。而是需要通过 source xxx 或  ./xxx 来执行。也就是像一个 shell 脚本一样执行。这时候就出现了一个问题，一个 JS 代码是不能够直接以这种形式执行的。那么这个时候就需要上述语句来声明解释器类型。也就是说，执行该代码需要使用 node 当做解释器辅助。"}),"\n",(0,s.jsx)(e.p,{children:"在 package.json 中添加一个 bin 属性，声明注册一个叫 create-smarty 的可执行文件。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JSON",children:'{\n  "name": "create-smarty-app",\n  "version": "0.1.0",\n  "description": "",\n  "main": "index.js",\n  "type": "module",\n  "bin": {\n    "create-smarty": "./bin/index.js"\n  },\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"并且将 type 设置为 module 。这么做的目的是在 Node 环境中使用 esm 模块规范。这样就可以使用 import 和 export 导入导出模块了。"}),"\n",(0,s.jsx)(e.p,{children:"脚本编写虽然也可以使用 Typescript 。为了方便，这次我们使用 JS 编写。"}),"\n",(0,s.jsx)(e.p,{children:"编写完成后运行 npm link 模拟全局安装的效果。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:"# 19.架构复用： 创建 CLI 工具提高研发体验\nsudo npm link\n"})}),"\n",(0,s.jsx)(e.p,{children:"这个时候可以在任何一个目录下执行命令。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:"create-smarty\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,s.jsx)(e.p,{children:"日志正确输出，标志着 CLI 工具框架初始化完毕。"}),"\n",(0,s.jsxs)(e.h3,{id:"创建命令行界面",children:["创建命令行界面",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#创建命令行界面",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"下一步，就是打造一个命令行界面。命令行界面的意义在于可以让用户定制自己需要的程序。"}),"\n",(0,s.jsx)(e.p,{children:"比如： vue-cli 可以选择需要的 ts/js 语言、是否需要 router 与 vuex 、是否需要 eslint 等。"}),"\n",(0,s.jsx)(e.p,{children:"具体到这个 CLI 的需求，需要实现选择多种模版功能。"}),"\n",(0,s.jsx)(e.p,{children:"Vue-cli 这样的通用脚手架提供多种可选项。但是它付出的代价，就是实现逻辑复杂且容易出错。而在企业内部的脚手架，更多的是需要更为简单高效的功能，并不需要花里胡哨。比如我很少听说一个团队会在 TS、JS 语言中选择。又或者有些项目使用 eslint，而有些不使用。当然学会了基本操作，你想实现更复杂的功能也是可以的。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:"img"})}),"\n",(0,s.jsx)(e.p,{children:"首先打印一个欢迎界面，这个功能是使用 clear、chalk-animation  与 figlet 合作完成。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Clear 清除屏幕；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Figlet 提供炫酷的文字效果；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Chalk-animation 提供命令行动画与渐变颜色。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:'pnpm i figlet@"1.5.2" clear@"0.1.0" chalk-animation@"2.0.2" \nimport figlet from "figlet";\nimport clear from "clear";\nimport chalkAnimation from "chalk-animation";\n\n// 打印欢迎画面\nclear();\nconst logo = figlet.textSync("Smarty UI!", {\n  // font: "Ghost",\n  horizontalLayout: "default",\n  verticalLayout: "default",\n  width: 80,\n  whitespaceBreak: true,\n});\n\nconst rainbow = chalkAnimation.rainbow(logo);\nsetTimeout(() => {\n  rainbow.stop(); // Animation stops\n}, 500);\n'})}),"\n",(0,s.jsx)(e.p,{children:"然后是命令行选项，这个使用 inquirer 这个库完成。它会根据配置显示界面并把结果返回为 json。"}),"\n",(0,s.jsx)(e.p,{children:"后面通过返回结果动态 import 导入需要的模块，这样就实现了根据选项运行不同的初始化模块。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:'pnpm i chalk@"5.0.1" inquirer@"9.1.0"\n#!/usr/bin/env node\n\nimport { promisify } from "util";\nimport figlet from "figlet";\nimport clear from "clear";\nimport chalk from "chalk";\nimport inquirer from "inquirer";\nimport chalkAnimation from "chalk-animation";\n\nconst log = (content) => console.log(chalk.green(content));\nconst opt = {\n  "SmartyUI应用模版(Vite)": "smarty-ui-vite",\n  SmartyAdmin模版: "admin",\n  组件库脚手架: "uitemplate",\n  组件库文档网站: "uitemplate",\n  退出: "quit",\n};\n\nconst question = [\n  {\n    type: "rawlist" /* 选择框 */,\n    message: "请选择要创建的项目？",\n    name: "operation",\n    choices: Object.keys(opt),\n  },\n];\n\n// 打印欢迎画面\nclear();\nconst logo = figlet.textSync("Smarty UI!", {\n  // font: "Ghost",\n  horizontalLayout: "default",\n  verticalLayout: "default",\n  width: 80,\n  whitespaceBreak: true,\n});\n\nconst rainbow = chalkAnimation.rainbow(logo);\nsetTimeout(() => {\n  rainbow.stop(); // Animation stops\n  query();\n}, 500);\n\n\nasync function query() {\n  const answer = await inquirer.prompt(question);\n\n  if (answer.operation === "退出") return;\n\n  const { default: op } = await import(\n    `../lib/operations/${opt[answer.operation]}.js`\n  );\n  await op();\n}\n'})}),"\n",(0,s.jsxs)(e.h3,{id:"克隆项目模版",children:["克隆项目模版",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#克隆项目模版",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"项目的主体一般都是通过从 Github 直接拉取的形式。只有少部分需要修改的代码使用代码模版生成的方式实现。 你熟悉的 vue-cli、create-react-app 也都是一样的原理。"}),"\n",(0,s.jsx)(e.p,{children:"首先使用 download-git-repo 这个库完成克隆。 克隆是一个漫长的异步执行过程，可能会持续数秒到几分钟。这个时候为了优化用户体验，不要让用户认为程序死掉了，就需要一个进度条表示一直在加载。比如： ora 这库。下面是代码实现。"}),"\n",(0,s.jsx)(e.p,{children:"首先编写一个进度条和 git 下载结合的 clone 函数。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-Bash",children:'pnpm i ora@"6.1.2" download-git-repo@"3.0.2"\n'})}),"\n",(0,s.jsx)(e.p,{children:"lib/utils/clone.js"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:'import { promisify } from "util";\nimport download from "download-git-repo";\nimport ora from "ora";\nexport default async (repo, desc) => {\n  const process = ora(`下载.....${repo}`);\n  process.start();\n  await promisify(download)(repo, desc);\n  process.succeed();\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:"然后编写克隆过程，这个里面还需要一点交互问一下它的项目名称。和上面功能相似我就不讲了。另外为了让日志有颜色，使用了 chalk 包。"}),"\n",(0,s.jsx)(e.p,{children:"operations/smarty-ui-vite.js"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:'import clone from "../utils/clone.js";\nimport inquirer from "inquirer";\nimport { resolve } from "path";\nimport fs from "fs";\n\nimport chalk from "chalk";\nconst log = (...args) => console.log(chalk.green(...args));\n\nimport handlebars from "handlebars";\n\nexport default async () => {\n  const { name } = await inquirer.prompt([\n    {\n      type: "input" /* 选择框 */,\n      message: "请输入项目的名称？",\n      name: "name",\n    },\n  ]);\n\n  log("\uD83D\uDE8C 创建项目:" + name);\n  \n  log(`\n\uD83D\uDC4C 安装完成：\nTo get Start:\n===========================\ncd ${name}\nnpm i\nnpm run dev\n===========================\n            `);\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:"img"})}),"\n",(0,s.jsxs)(e.h3,{id:"模版生成代码",children:["模版生成代码",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模版生成代码",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"除了模版库中的代码，还有一些代码需要自动生成。比如： 你希望项目名显示在页面中，又比如你希望根据配置决定加载什么样的 vue 插件。 这相当于动态的拼装代码，这个过程其实和前端使用一个模版库渲染 html 并没有什么区别。这个时候可以选择一个模版库完成，常用的是 handlebars 这个库。"}),"\n",(0,s.jsx)(e.p,{children:"具体到本程序，只有一个最简单的代码需要模版生成。package.json 中的项目名改写为包名。首先在模版项目 smarty-ui-app-js-template 中创建一个 template 文件夹。然后创建一个 package.json 模版。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:"img"})}),"\n",(0,s.jsx)(e.p,{children:"这个模版和 package.json 几乎一样，只是将 name 属性的值变成了表达式。"}),"\n",(0,s.jsx)(e.p,{children:"template/package.hbs.json"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JSON",children:'{\n  "name": "{{ name }}",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "smarty-ui-vite": "^0.1.4",\n    "vue": "^3.2.37"\n  },\n  "devDependencies": {\n    "@vitejs/plugin-vue": "^3.0.3",\n    "vite": "^3.0.7"\n  }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"下面就在 CLI 工具中编写通过 template 生成 package.json 的代码。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-JavaScript",children:'import clone from "../utils/clone.js";\nimport inquirer from "inquirer";\nimport { resolve } from "path";\nimport fs from "fs";\n\nimport chalk from "chalk";\nconst log = (...args) => console.log(chalk.green(...args));\n\nimport handlebars from "handlebars";\n\nexport default async () => {\n  const { name } = await inquirer.prompt([\n    {\n      type: "input" /* 选择框 */,\n      message: "请输入项目的名称？",\n      name: "name",\n    },\n  ]);\n\n  log("\uD83D\uDE8C 创建项目:" + name);\n\n  // 从github克隆项目到指定文件夹\n  await clone("github:smarty-team/smarty-ui-app-js-template", name);\n\n  // 生成路由定义\n  compile(\n    {\n      name,\n    },\n    `./${name}/package.json`,\n    `./${name}/template/package.hbs.json`\n  );\n\n  log(`\n\uD83D\uDC4C 安装完成：\nTo get Start:\n===========================\ncd ${name}\nnpm i\nnpm run dev\n===========================\n            `);\n};\n\n\n/**\n * 编译模板文件\n * @param meta 数据定义\n * @param filePath 目标文件路径\n * @param templatePath 模板文件路径\n */\nfunction compile(meta, filePath, templatePath) {\n  if (fs.existsSync(templatePath)) {\n    const content = fs.readFileSync(templatePath).toString();\n    const result = handlebars.compile(content)(meta);\n    fs.writeFileSync(filePath, result);\n    log(`\uD83D\uDCDA ${filePath} 修改成功`);\n  } else {\n    log(`❌ ${filePath} 修改失败`);\n  }\n}\n'})}),"\n",(0,s.jsxs)(e.h3,{id:"上传-npm-仓库",children:["上传 Npm 仓库",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#上传-npm-仓库",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"最后一步是上传 npm 仓库。这个步骤还是需要使用 Github Action 完成。这一步前面已经讲过，不再赘述。"}),"\n",(0,s.jsx)(e.p,{children:".github/workflows/publish-smarty-ui-vite.yml"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-YAML",children:'name: Publish Smarty-ui-vite To Npm\n\non:\n  push:\n    branches: [publish-smarty-ui-vite]\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n\n    name: "publish npm"\n\n    environment: npm\n\n    steps:\n      - uses: actions/checkout@master\n      - uses: pnpm/action-setup@v2.1.0\n        with:\n          version: 6.31.0\n      - name: Install modules\n        run: pnpm install\n      - name: Build\n        run: cd packages/smarty-ui-vite && npm run build\n      - name: "Publish to the npm registry"\n        uses: primer/publish@3.0.0\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }} # 跟前面步骤中的 NPM_AUTH_TOKEN 保持一致\n        with:\n          default_branch: "publish-smarty-ui-vite"\n          dir: "packages/smarty-ui-vite/dist"\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"复盘",children:["复盘",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#复盘",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"这节课的主要内容是介绍如何编写一个 CLI 工具。"}),"\n",(0,s.jsx)(e.p,{children:"虽然只是介绍了一个很基本的功能，但是我力争通过这个实践将最核心的 CLI 技术传授给大家。 其实我认为 CLI 工具最重要的功能是自动化生成代码，替代人工劳动，比如自动根据视图文件生成路由。通过这节课的学习大家可以尝试一下这个功能。"}),"\n",(0,s.jsx)(e.p,{children:"我希望这节课可能起到抛砖引玉的作用，有更多的自动化的功能可以涌现出来。"}),"\n",(0,s.jsx)(e.p,{children:"最后留一些扩展任务。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"创造一个自己的 CLI 工具；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"使用自动化生成代码功能解决一个项目的实际问题。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"下节课，我们将给大家讲解如何实现 Vue-CLI 插件让 Smarty-UI 融入vue 生态，下节课见。"})]})}function x(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(m,{...n})}):m(n)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Vite%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E6%88%98%2F19.%E6%9E%B6%E6%9E%84%E5%A4%8D%E7%94%A8%EF%BC%9A%20%E5%88%9B%E5%BB%BA%20CLI%20%E5%B7%A5%E5%85%B7%E6%8F%90%E9%AB%98%E7%A0%94%E5%8F%91%E4%BD%93%E9%AA%8C.md"]={toc:[{text:"用户故事(UserStory)",id:"用户故事userstory",depth:2},{text:"任务分解(Task)",id:"任务分解task",depth:2},{text:"CLI 与 脚手架的概念",id:"cli-与-脚手架的概念",depth:3},{text:"创建模版项目",id:"创建模版项目",depth:3},{text:"初始化 CLI 项目",id:"初始化-cli-项目",depth:3},{text:"创建命令行界面",id:"创建命令行界面",depth:3},{text:"克隆项目模版",id:"克隆项目模版",depth:3},{text:"模版生成代码",id:"模版生成代码",depth:3},{text:"上传 Npm 仓库",id:"上传-npm-仓库",depth:3},{text:"复盘",id:"复盘",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);