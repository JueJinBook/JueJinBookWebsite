"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["70793"],{864989:function(n,e,s){s.r(e),s.d(e,{default:()=>o});var r=s(552676),c=s(740453);function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",h2:"h2",pre:"pre",h3:"h3",ol:"ol",li:"li",blockquote:"blockquote"},(0,c.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"第13章实战篇系统插件的加载和取色插件的开发",children:["第13章—实战篇：系统插件的加载和取色插件的开发",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第13章实战篇系统插件的加载和取色插件的开发",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["\uFEFF## 前言\n在 ",(0,r.jsx)(e.code,{children:"Rubick"})," 插件系统中，插件主要分为两大类，一类是 ",(0,r.jsx)(e.strong,{children:"UI 类插件"}),"，这类插件是通过 ",(0,r.jsx)(e.code,{children:"BrwoserView"})," 进行加载，因为通过 ",(0,r.jsx)(e.code,{children:"BrowserView"})," 加载，所以通常会有视图 UI 界面，插件销毁后，不会驻留在内存中。还有一类是",(0,r.jsx)(e.strong,{children:"系统类插件"}),"，这类插件是会常驻在 ",(0,r.jsx)(e.code,{children:"Rubick"})," 运行时中的，可以是一段 ",(0,r.jsx)(e.code,{children:"JavaScript"})," 代码片段，会伴随着 ",(0,r.jsx)(e.code,{children:"Rubick"})," 特定运行状态钩子而启动运行。"]}),"\n",(0,r.jsxs)(e.p,{children:["在章节",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7302990019642261567/section/7304842330723319818",target:"_blank",rel:"noopener noreferrer",children:"《实战篇：插件的安装、发布、卸载》"}),"中，我们介绍了插件安装的方法；在",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7302990019642261567/section/7304648624179576871",target:"_blank",rel:"noopener noreferrer",children:"《实战篇：如何支持工具插件化》"}),"中，我们介绍了如何加载安装好的 UI 类插件。"]}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们将接着介绍如何加载安装好的系统类插件，然后再教大家编写一个简单的 UI 类插件和系统类插件。"}),"\n",(0,r.jsxs)(e.h2,{id:"系统类插件的目录结构说明",children:["系统类插件的目录结构说明",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#系统类插件的目录结构说明",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["前面我们介绍了 ",(0,r.jsx)(e.code,{children:"UI"})," 类插件的目录结构，接下来，我们再看一下最简单的系统类插件目录结构："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"plugin\n|-- index.js\n└── package.json\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"1-packagejson",children:["1. package.json",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-packagejson",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["和之前 UI 类插件字段是一样的，区别是需要额外提供一个 ",(0,r.jsx)(e.code,{children:"entry"})," 字段来标记入口 ",(0,r.jsx)(e.code,{children:"js"}),"，以及 ",(0,r.jsx)(e.code,{children:"pluginType"})," 字段为 ",(0,r.jsx)(e.code,{children:"system"})," 来标记是一个系统类插件："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-json",children:'{\n  "pluginType": "system",\n  "entry": "index.js"\n}\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"2-indexjs",children:["2. index.js",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-indexjs",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["系统插件的入口 ",(0,r.jsx)(e.code,{children:"js"})," 文件，通过自定义一些系统插件钩子函数，来实现代码片段注入的能力："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// index.js\nmodule.exports = () => {\n  return {\n    // 定义 beforeReady 钩子函数\n    beforeReady() {\n      // ...\n    }\n    // 定义 onReady 钩子函数\n    onReady(ctx) {\n      // ...\n    },\n    // 定义 onRunning 钩子函数\n    onRunning(ctx) {\n      // ...\n    },\n    // 定义 onQuit 钩子函数\n    onQuit() {\n      // ...\n    }\n }\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"加载系统类插件",children:["加载系统类插件",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#加载系统类插件",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们知道，Electron 运行时主要是通过 ",(0,r.jsx)(e.a,{href:"https://www.electronjs.org/zh/docs/latest/api/app",target:"_blank",rel:"noopener noreferrer",children:"app"})," 对象来完成对应用生命周期的监听和处理，我们想要实现系统插件，就是希望可以注入到这些生命周期中运行的代码段。因此，我们可以把 ",(0,r.jsx)(e.code,{children:"app"})," 的启动类比成 ",(0,r.jsx)(e.code,{children:"Vue"})," 的生命周期那样设置几个关键阶段："]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["beforeReady：Electron App 启动前的准备工作，执行在 Electron 钩子函数 ",(0,r.jsx)(e.code,{children:"app.on('ready')"})," 之前。这里会加载执行系统插件的 ",(0,r.jsx)(e.code,{children:"onBeforeReady"})," 钩子函数。"]}),"\n",(0,r.jsxs)(e.li,{children:["onReady：Electron ",(0,r.jsx)(e.code,{children:"app.on('ready')"})," 函数执行期，会做一些更新检测、创建系统菜单、创建主窗口等操作。这里会加载执行系统插件的 ",(0,r.jsx)(e.code,{children:"onReady"})," 钩子函数。"]}),"\n",(0,r.jsxs)(e.li,{children:["onRunning：这里会处理 Electron 的 ",(0,r.jsx)(e.code,{children:"app.on('second-instance')"})," 钩子函数和 ",(0,r.jsx)(e.code,{children:"app.on('activate')"})," 钩子函数。这里会加载执行系统插件的 ",(0,r.jsx)(e.code,{children:"onRuning"})," 钩子函数。"]}),"\n",(0,r.jsxs)(e.li,{children:["onQuit：这里会处理 Electron 的 ",(0,r.jsx)(e.code,{children:"app.on('window-all-closed')"})," 钩子函数和 ",(0,r.jsx)(e.code,{children:"app.on('will-quit')"})," 钩子函数。这里会加载执行系统插件的 ",(0,r.jsx)(e.code,{children:"onQuit"})," 钩子函数。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["所以，我们需要对入口 ",(0,r.jsx)(e.code,{children:"main/index.js"})," 文件做一下改造："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"import electron, { app, protocol } from 'electron';\n\nclass App {\n  constructor() {\n    // 注册协议\n    protocol.registerSchemesAsPrivileged([\n      { scheme: 'app', privileges: { secure: true, standard: true } },\n    ]);\n    // 处理多应用实例\n    const gotTheLock = app.requestSingleInstanceLock();\n    if (!gotTheLock) {\n      app.quit();\n    } else {\n      // 注册系统插件\n      this.systemPlugins = registerSystemPlugin();\n      // 注册生命周期\n      this.beforeReady();\n      this.onReady();\n      this.onRunning();\n      this.onQuit();\n    }\n  }\n  beforeReady() {\n    // ...\n    // 触发 onBeforeReady\n    this.systemPlugins.triggerBeforeReadyHooks()\n  }\n\n  createWindow() {\n    this.windowCreator.init();\n  }\n  \n  onReady() {\n    const readyFunction = async () => {\n      // ...\n      // 触发 onReady\n      this.systemPlugins.triggerReadyHooks();\n    };\n    if (!app.isReady()) {\n      app.on('ready', readyFunction);\n    } else {\n      readyFunction();\n    }\n  }\n\n  onRunning() {\n    app.on('second-instance', (event, commandLine, workingDirectory) => {\n      // ...\n      if (win) {\n        if (win.isMinimized()) {\n          win.restore();\n        }\n        win.focus();\n      }\n    });\n    app.on('activate', () => {\n      // ...\n    });\n    // 触发 onRunning\n    this.systemPlugins.triggerOnRunningHooks();\n  }\n\n  onQuit() {\n    // ...\n    app.on('window-all-closed', () => {\n      if (process.platform !== 'darwin') {\n        app.quit();\n      }\n    });\n\n    app.on('will-quit', () => {\n      // ...\n      // 触发 OnQuit\n      this.systemPlugins.triggerOnQuitHooks();\n    });\n  }\n}\n\nexport default new App();\n"})}),"\n",(0,r.jsx)(e.p,{children:"上面代码也很简单，我们可以详细介绍一下："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["首先通过一个 ",(0,r.jsx)(e.code,{children:"App"})," 类来定义了四个钩子函数，并通过 ",(0,r.jsx)(e.code,{children:"constructor"})," 来实现对钩子函数的注册调用。"]}),"\n",(0,r.jsxs)(e.li,{children:["在 ",(0,r.jsx)(e.code,{children:"constructor"})," 中，通过 ",(0,r.jsx)(e.code,{children:"registerSystemPlugin"})," 函数完成对系统插件的注册，并赋值给了 ",(0,r.jsx)(e.code,{children:"this.systemPlugins"}),"。"]}),"\n",(0,r.jsxs)(e.li,{children:["监听 ",(0,r.jsx)(e.code,{children:"app"})," 阶段性钩子函数，并通过 ",(0,r.jsx)(e.code,{children:"this.systemPlugins.triggerXXXHooks"})," 完成对系统插件钩子函数的触发调用。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["接下来，我们以实现 ",(0,r.jsx)(e.code,{children:"triggerXXXHooks"})," 来作为示例，来说明一个插件入口 ",(0,r.jsx)(e.code,{children:"js"})," 程序中的 ",(0,r.jsx)(e.code,{children:"onReady"})," 钩子是如何被执行的："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// registerSystemPlugin.js\nimport path from 'path';\nimport fs from 'fs';\n// 插件通过 npm 安装下载的路径\nimport { PLUGIN_INSTALL_DIR } from '@/common/constans/main';\n\nconst registerSystemPlugin = () => {\n  // ...\n  // 通过 pluginType 从所有插件 totalPlugins 中过滤出系统插件\n  let systemPlugins = totalPlugins.filter(\n    (plugin) => plugin.pluginType === 'system'\n  );\n  // 处理插件的 entry 路径，由相对路径转为绝对路径 \n  systemPlugins = systemPlugins\n    .map((plugin) => {\n      try {\n        const pluginPath = path.resolve(\n          PLUGIN_INSTALL_DIR,\n          'node_modules',\n          plugin.name\n        );\n        return {\n          ...plugin,\n          indexPath: path.join(pluginPath, './', plugin.entry),\n        };\n      } catch (e) {\n        return false;\n      }\n    })\n    .filter(Boolean);\n  \n  // 定义插件的所有钩子函数\n  const hooks = {\n    onReady: [],\n  };\n\n  // 收集所有系统插件的 onReady 钩子函数\n  systemPlugins.forEach((plugin) => {\n    if (fs.existsSync(plugin.indexPath)) {\n      const pluginModule = __non_webpack_require__(plugin.indexPath)();\n      hooks.onReady.push(pluginModule.onReady);\n    }\n  });\n  \n  // 定义触发所有插件的 onReady 钩子\n  const triggerReadyHooks = (ctx) => {\n    hooks.onReady.forEach((hook: any) => {\n      try {\n        hook && hook(ctx);\n      } catch (e) {\n        console.log(e);\n      }\n    });\n  };\n\n  return {\n    triggerReadyHooks,\n  };\n};\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上述代码中，首先通过 ",(0,r.jsx)(e.code,{children:"pluginType = system"})," 这个条件来过滤出所有的系统插件，因为插件中的 ",(0,r.jsx)(e.code,{children:"package.json"})," 定义的 ",(0,r.jsx)(e.code,{children:"entry"})," 入口文件是一个相对路径，所以我们将其处理成了一个绝对路径 ",(0,r.jsx)(e.code,{children:"indexPath"}),"。接下来就是通过 ",(0,r.jsx)(e.code,{children:"__non_webpack_require__"})," 函数动态引用入口 ",(0,r.jsx)(e.code,{children:"index.js"})," 文件，并把其中注册的 ",(0,r.jsx)(e.code,{children:"onReady"})," 钩子函数派发到 ",(0,r.jsx)(e.code,{children:"hooks"})," 中。然后包装成一个 ",(0,r.jsx)(e.code,{children:"triggerReadyHooks"})," 函数在特定时机触发。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"__non_webpack_require__"})," 是 Node.js 中的一个全局变量，它是为了避免 Webpack 对 ",(0,r.jsx)(e.code,{children:"require"})," 函数的处理而引入的。"]}),"\n",(0,r.jsxs)(e.p,{children:["在 Webpack 打包的过程中，它会把所有的 ",(0,r.jsx)(e.code,{children:"require"})," 函数替换成一些用于模块加载的特殊函数，这可能导致某些情况下无法直接使用原生的 Node.js 模块加载方式。为了绕过这种替换，可以使用 ",(0,r.jsx)(e.code,{children:"__non_webpack_require__"})," 来调用原生的 ",(0,r.jsx)(e.code,{children:"require"})," 函数。"]}),"\n",(0,r.jsxs)(e.p,{children:["当你使用 Webpack 打包的代码中需要引入 Node.js 模块时，可以使用 ",(0,r.jsx)(e.code,{children:"__non_webpack_require__"}),"，这样就可以确保使用原生的 Node.js 的模块加载机制而不受 Webpack 的影响。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"插件的开发",children:["插件的开发",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#插件的开发",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["前面我们已经分别介绍了关于 ",(0,r.jsx)(e.strong,{children:"UI 类插件"}),"和",(0,r.jsx)(e.strong,{children:"系统类插件"}),"的最基础的目录结构。但是开发过程中，使用最基础的目录结构肯定是不行的，为了界面样式的统一和美观我们可能会使用一些组件库，为了提升开发效率，我们也可能会使用一些开发框架，比如 ",(0,r.jsx)(e.code,{children:"Vue"}),"、",(0,r.jsx)(e.code,{children:"React"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["因此，这里我们将以 ",(0,r.jsx)(e.code,{children:"Vue 3 + antdv"})," 作为基础依赖，实现一个桌面取色器插件。"]}),"\n",(0,r.jsxs)(e.h3,{id:"1-初始化工程",children:["1. 初始化工程",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-初始化工程",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们使用 ",(0,r.jsx)(e.code,{children:"vueCli"})," 来创建一个插件应用："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"$ vue create rubick-plugin-colorpicker\n"})}),"\n",(0,r.jsx)(e.p,{children:"得到的目录结构如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:".\n├── README.md\n├── babel.config.js\n├── jsconfig.json\n├── package.json\n├── public\n│\xa0\xa0 ├── favicon.ico\n│\xa0\xa0 └── index.html\n├── src\n│\xa0\xa0 ├── App.vue\n│\xa0\xa0 ├── assets\n│\xa0\xa0 │\xa0\xa0 └── logo.png\n│\xa0\xa0 ├── components\n│\xa0\xa0 │\xa0\xa0 └── HelloWorld.vue\n│\xa0\xa0 └── main.js\n├── vue.config.js\n└── yarn.lock\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"vueCli"})," 在执行 ",(0,r.jsx)(e.code,{children:"npm run build"})," 命令构建后，会把 ",(0,r.jsx)(e.code,{children:"public"})," 目录下的文件拷贝到 ",(0,r.jsx)(e.code,{children:"dist"})," 目录，所以我们可以在 ",(0,r.jsx)(e.code,{children:"public"})," 目录下新建一个 ",(0,r.jsx)(e.code,{children:"preload.js"})," 和一个 ",(0,r.jsx)(e.code,{children:"package.json"}),"，调整后的 ",(0,r.jsx)(e.code,{children:"public"})," 目录结构如下："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"public\n├── favicon.ico\n├── index.html\n├── package.json\n└── preload.js\n"})}),"\n",(0,r.jsxs)(e.p,{children:["然后我们给 ",(0,r.jsx)(e.code,{children:"package.json"})," 文件加入以下内容："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-json",children:'{\n  "name": "rubick-plugin-colorpicker",\n  "pluginName": "取色器",\n  "version": "1.0.0",\n  "description": "取色器",\n  "main": "index.html",\n  "preload": "preload.js",\n  "logo": "https://pic1.zhimg.com/80/v2-5f1810a71af6eefcd77edbbf07ea1cc7_720w.png",\n  "pluginType": "ui",\n  "features": [\n    {\n      "code": "colorpicker",\n      "explain": "取色器",\n      "cmds": [\n        "colorpicker",\n        "qs",\n        "取色"\n      ]\n    }\n  ]\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["因为插件是以文件方式引用资源，所以需要调整一下 ",(0,r.jsx)(e.code,{children:"vue.confg.js"})," 设置 ",(0,r.jsx)(e.code,{children:"publicPath"})," 的路径："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'// vue.config.js\nconst { defineConfig } = require(\'@vue/cli-service\')\nmodule.exports = defineConfig({\n  // ...\n  publicPath: process.env.NODE_ENV === "production" ? "" : "/",\n})\n'})}),"\n",(0,r.jsx)(e.p,{children:"我们开始构建这个项目："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"$ npm run build\n"})}),"\n",(0,r.jsxs)(e.p,{children:["构建完成后，看一下 ",(0,r.jsx)(e.code,{children:"dist"})," 目录结构："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"dist\n├── css\n│\xa0\xa0 └── app.2cf79ad6.css\n├── favicon.ico\n├── index.html\n├── js\n│\xa0\xa0 ├── app.42798930.js\n│\xa0\xa0 ├── app.42798930.js.map\n│\xa0\xa0 ├── chunk-vendors.4114fffc.js\n│\xa0\xa0 └── chunk-vendors.4114fffc.js.map\n├── package.json\n└── preload.js\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这个就是我们后面需要发布的 ",(0,r.jsx)(e.code,{children:"npm"})," 插件包。"]}),"\n",(0,r.jsxs)(e.h3,{id:"2-调试插件",children:["2. 调试插件",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-调试插件",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["因为我们的插件是基于 npm 的，所以可以通过 ",(0,r.jsx)(e.code,{children:"npm link"})," 的方式进行插件调试，在 ",(0,r.jsx)(e.code,{children:"dist"})," 目录下，执行："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"$ npm link\n"})}),"\n",(0,r.jsxs)(e.p,{children:["然后在 ",(0,r.jsx)(e.code,{children:"rubick"})," 中通过路径的方式安装这个插件："]}),"\n",(0,r.jsxs)(e.p,{children:["安装的本质就是 ",(0,r.jsx)(e.code,{children:"npm link rubick-plugin-colorpicker"}),"。安装完成后，我们就可以通过搜索框输入关键词：",(0,r.jsx)(e.code,{children:"colorpicker"}),"、",(0,r.jsx)(e.code,{children:"qs"}),"、",(0,r.jsx)(e.code,{children:"取色"})," 来进行唤起插件。"]}),"\n",(0,r.jsxs)(e.p,{children:["但这样有一个问题就是每次无法热更新，每次修改代码都需要进行 ",(0,r.jsx)(e.code,{children:"npm run build"})," 后才能显示结果，因此，需要在插件的 ",(0,r.jsx)(e.code,{children:"package.json"})," 中添加一个 ",(0,r.jsx)(e.code,{children:"development"})," 字段来标记开发环境的前端入口地址："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-json",children:'// public/package.json\n{\n  "development": "http://localhost:8080",\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"这样，每次更新代码，也会热更新插件页面。"}),"\n",(0,r.jsxs)(e.h3,{id:"3-功能完善",children:["3. 功能完善",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-功能完善",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["插件页面已经搭建好了，接下来要实现的就是屏幕取色的能力，这里我们可以直接使用 ",(0,r.jsx)(e.a,{href:"https://github.com/mockingbot/electron-color-picker",target:"_blank",rel:"noopener noreferrer",children:"electron-color-picker"})," 这个开源库，接下来，需要在 ",(0,r.jsx)(e.code,{children:"public"})," 目录下安装这个依赖库："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"$ npm install electron-color-picker\n"})}),"\n",(0,r.jsxs)(e.p,{children:["然后在 ",(0,r.jsx)(e.code,{children:"preload.js"})," 中使用这个库："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const {\n  getColorHexRGB,\n  darwinGetScreenPermissionGranted,\n  darwinRequestScreenPermissionPopup\n} = require('electron-color-picker');\nconst os = require(\"os\");\n\nconst isDarwin = os.platform === 'darwin';\n\nwindow.colorpicker = async () => {\n  try {\n    window.rubick.hideMainWindow();\n    // 如果是 macOS 需要检测屏幕录制权限\n    if (isDarwin) {\n      const permission = await darwinGetScreenPermissionGranted();\n      if (!permission) {\n        return darwinRequestScreenPermissionPopup();\n      }\n    }\n    \n    // 调用 color picker 来取色\n    const result = await getColorHexRGB();\n    // 取色成功写入剪贴板，然后并展示系统通知\n    if (result) {\n      window.rubick.copyText(result);\n      window.rubick.showNotification(`${result}, 取色成功！已复制剪切板`);\n    }\n  } catch (e) {\n    console.log(e);\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后我们在前端页面中加一个取色按钮，点击后，触发取色功能："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-html",children:'\x3c!-- App.vue --\x3e\n<template>\n  <button @click="window.colorpicker">取色</button>\n</template>\n'})}),"\n",(0,r.jsx)(e.p,{children:"点击按钮后，就会出现取色的功能："}),"\n",(0,r.jsxs)(e.p,{children:["接下来，如果你想发布你的插件，那么只需要在构建完成后，在 ",(0,r.jsx)(e.code,{children:"dist"})," 目录下执行："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"$ npm publish\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样就可以完成对插件的发布能力。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://gitee.com/rubick-center/rubick-system-color-picker",target:"_blank",rel:"noopener noreferrer",children:"取色插件完整代码"})}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本小节，我们详细介绍了关于系统插件的加载实现过程，以及基于 ",(0,r.jsx)(e.code,{children:"vueCli"})," 完成了一个屏幕取色插件的开发。细心的同学可能留意到这是个 ",(0,r.jsx)(e.strong,{children:"UI 类型的插件"}),"。后面，我们将通过 ",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7302990019642261567/section/7304842836837728294",target:"_blank",rel:"noopener noreferrer",children:"《实现超级面板插件》"})," 的实战章节，讲解如何开发一个好用的系统插件。"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(i,{...n})}):i(n)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC13%E7%AB%A0%E2%80%94%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%96%E8%89%B2%E6%8F%92%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91.md"]={toc:[{text:"系统类插件的目录结构说明",id:"系统类插件的目录结构说明",depth:2},{text:"1. package.json",id:"1-packagejson",depth:3},{text:"2. index.js",id:"2-indexjs",depth:3},{text:"加载系统类插件",id:"加载系统类插件",depth:2},{text:"插件的开发",id:"插件的开发",depth:2},{text:"1. 初始化工程",id:"1-初始化工程",depth:3},{text:"2. 调试插件",id:"2-调试插件",depth:3},{text:"3. 功能完善",id:"3-功能完善",depth:3},{text:"总结",id:"总结",depth:2}],title:"第13章—实战篇：系统插件的加载和取色插件的开发",headingTitle:"第13章—实战篇：系统插件的加载和取色插件的开发",frontmatter:{}}}}]);