"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["4371"],{379709:function(e,n,l){l.r(n),l.d(n,{default:()=>j});var r=l(552676),s=l(740453);let d=l.p+"static/image/7cafcd8fee25453a5484d328112a42d3.1049ff9a.webp",c=l.p+"static/image/e4504395bf91977f367adc74a9b2b5d1.23f5a800.webp",i=l.p+"static/image/00aed55feb81312cbcc40ee82a5099d5.8c8c8df4.webp",o=l.p+"static/image/7a2caa2fda80a70c31211ef5de919237.f0364ecf.webp",t=l.p+"static/image/fa6fadc033927f7c2b9747430c0e81eb.35608c7c.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",h2:"h2",pre:"pre",img:"img",h3:"h3",ul:"ul",li:"li",ol:"ol",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"11vite-构建基石下深入理解-rollup-的插件机制",children:["11.Vite 构建基石(下)——深入理解 Rollup 的插件机制",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11vite-构建基石下深入理解-rollup-的插件机制",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上一节我们学会了 Rollup 构建工具的使用，相信你已经对 Rollup 的基础概念和使用有了基本的掌握。同时我们也知道，仅仅使用 Rollup 内置的打包能力很难满足项目日益复杂的构建需求。对于一个真实的项目构建场景来说，我们还需要考虑到",(0,r.jsx)(n.code,{children:"模块打包"}),"之外的问题，比如",(0,r.jsx)(n.strong,{children:"路径别名(alias)"})," 、",(0,r.jsx)(n.strong,{children:"全局变量注入"}),"和",(0,r.jsx)(n.strong,{children:"代码压缩"}),"等等。"]}),"\n",(0,r.jsxs)(n.p,{children:["可要是把这些场景的处理逻辑与核心的打包逻辑都写到一起，一来打包器本身的代码会变得十分臃肿，二来也会对原有的核心代码产生一定的侵入性，混入很多与核心流程无关的代码，不易于后期的维护。因此 ，Rollup 设计出了一套完整的",(0,r.jsx)(n.strong,{children:"插件机制"}),"，将自身的核心逻辑与插件逻辑分离，让你能按需引入插件功能，提高了 Rollup 自身的可扩展性。"]}),"\n",(0,r.jsx)(n.p,{children:"我个人也非常喜欢 Rollup 的插件机制，功能完备又简单易上手，体现了 Rollup 本身小而美的风格。那接下来，我会带你分析 Rollup 的插件机制，熟悉 Rollup 插件的完整构建阶段和工作流程，并且结合案例深入插件开发细节。"}),"\n",(0,r.jsxs)(n.p,{children:["Rollup 的打包过程中，会定义一套完整的构建生命周期，从开始打包到产物输出，中途会经历一些",(0,r.jsx)(n.strong,{children:"标志性的阶段"}),'，并且在不同阶段会自动执行对应的插件钩子函数(Hook)。对 Rollup 插件来讲，最重要的部分是钩子函数，一方面它定义了插件的执行逻辑，也就是"做什么"；另一方面也声明了插件的作用阶段，即"什么时候做"，这与 Rollup 本身的构建生命周期息息相关。']}),"\n",(0,r.jsx)(n.p,{children:"因此，要真正理解插件的作用范围和阶段，首先需要了解 Rollup 整体的构建过程中到底做了些什么。"}),"\n",(0,r.jsxs)(n.h2,{id:"rollup-整体构建阶段",children:["Rollup 整体构建阶段",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rollup-整体构建阶段",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在执行 ",(0,r.jsx)(n.code,{children:"rollup"})," 命令之后，在 cli 内部的主要逻辑简化如下:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// Build 阶段\nconst bundle = await rollup.rollup(inputOptions);\n\n// Output 阶段\nawait Promise.all(outputOptions.map(bundle.write));\n\n// 构建结束\nawait bundle.close();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Rollup 内部主要经历了 ",(0,r.jsx)(n.code,{children:"Build"})," 和 ",(0,r.jsx)(n.code,{children:"Output"})," 两大阶段："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"首先，Build 阶段主要负责创建模块依赖图，初始化各个模块的 AST 以及模块之间的依赖关系。下面我们用一个简单的例子来感受一下:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// src/index.js\nimport { a } from './module-a';\nconsole.log(a);\n\n// src/module-a.js\nexport const a = 1;\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后执行如下的构建脚本:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const rollup = require('rollup');\nconst util = require('util');\nasync function build() {\n  const bundle = await rollup.rollup({\n    input: ['./src/index.js'],\n  });\n  console.log(util.inspect(bundle));\n}\nbuild();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到这样的 ",(0,r.jsx)(n.code,{children:"bundle"})," 对象信息:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"{\n  cache: {\n    modules: [\n      {\n        ast: 'AST 节点信息，具体内容省略',\n        code: 'export const a = 1;',\n        dependencies: [],\n        id: '/Users/code/rollup-demo/src/data.js',\n        // 其它属性省略\n      },\n      {\n        ast: 'AST 节点信息，具体内容省略',\n        code: \"import { a } from './data';\\n\\nconsole.log(a);\",\n        dependencies: [\n          '/Users/code/rollup-demo/src/data.js'\n        ],\n        id: '/Users/code/rollup-demo/src/index.js',\n        // 其它属性省略\n      }\n    ],\n    plugins: {}\n  },\n  closed: false,\n  // 挂载后续阶段会执行的方法\n  close: [AsyncFunction: close],\n  generate: [AsyncFunction: generate],\n  write: [AsyncFunction: write]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["从上面的信息中可以看出，目前经过 Build 阶段的 ",(0,r.jsx)(n.code,{children:"bundle"})," 对象其实并没有进行模块的打包，这个对象的作用在于存储各个模块的内容及依赖关系，同时暴露",(0,r.jsx)(n.code,{children:"generate"}),"和",(0,r.jsx)(n.code,{children:"write"}),"方法，以进入到后续的 ",(0,r.jsx)(n.code,{children:"Output"})," 阶段（",(0,r.jsx)(n.code,{children:"write"}),"和",(0,r.jsx)(n.code,{children:"generate"}),"方法唯一的区别在于前者打包完产物会写入磁盘，而后者不会）。"]}),"\n",(0,r.jsxs)(n.p,{children:["所以，真正进行打包的过程会在 ",(0,r.jsx)(n.code,{children:"Output"})," 阶段进行，即在",(0,r.jsx)(n.code,{children:"bundle"}),"对象的 ",(0,r.jsx)(n.code,{children:"generate"}),"或者",(0,r.jsx)(n.code,{children:"write"}),"方法中进行。还是以上面的 demo 为例，我们稍稍改动一下构建逻辑:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const rollup = require('rollup');\nasync function build() {\n  const bundle = await rollup.rollup({\n    input: ['./src/index.js'],\n  });\n  const result = await bundle.generate({\n    format: 'es',\n  });\n  console.log('result:', result);\n}\n\nbuild();\n"})}),"\n",(0,r.jsx)(n.p,{children:"执行后可以得到如下的输出:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"{\n  output: [\n    {\n      exports: [],\n      facadeModuleId: '/Users/code/rollup-demo/src/index.js',\n      isEntry: true,\n      isImplicitEntry: false,\n      type: 'chunk',\n      code: 'const a = 1;\\n\\nconsole.log(a);\\n',\n      dynamicImports: [],\n      fileName: 'index.js',\n      // 其余属性省略\n    }\n  ]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里可以看到所有的输出信息，生成的",(0,r.jsx)(n.code,{children:"output"}),"数组即为打包完成的结果。当然，如果使用 ",(0,r.jsx)(n.code,{children:"bundle.write"})," 会根据配置将最后的产物写入到指定的磁盘目录中。"]}),"\n",(0,r.jsxs)(n.p,{children:["因此，",(0,r.jsx)(n.strong,{children:"对于一次完整的构建过程而言，"})," ",(0,r.jsx)(n.strong,{children:"Rollup"})," ",(0,r.jsx)(n.strong,{children:"会先进入到 Build 阶段，解析各模块的内容及依赖关系，然后进入"}),(0,r.jsx)(n.code,{children:"Output"}),(0,r.jsx)(n.strong,{children:"阶段，完成打包及输出的过程"}),"。对于不同的阶段，Rollup 插件会有不同的插件工作流程，接下来我们就来拆解一下 Rollup 插件在 ",(0,r.jsx)(n.code,{children:"Build"})," 和 ",(0,r.jsx)(n.code,{children:"Output"})," 两个阶段的详细工作流程。"]}),"\n",(0,r.jsxs)(n.h2,{id:"拆解插件工作流",children:["拆解插件工作流",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#拆解插件工作流",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"谈谈插件-hook-类型",children:["谈谈插件 Hook 类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#谈谈插件-hook-类型",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在具体讲述 Rollup 插件工作流之前，我想先给大家介绍一下不同插件 Hook 的类型，这些类型代表了不同插件的执行特点，是我们理解 Rollup 插件工作流的基础，因此有必要跟大家好好拆解一下。"}),"\n",(0,r.jsxs)(n.p,{children:["通过上文的例子，相信你可以直观地理解 Rollup 两大构建阶段（",(0,r.jsx)(n.code,{children:"Build"}),"和",(0,r.jsx)(n.code,{children:"Output"}),"）各自的原理。可能你会有疑问，这两个阶段到底跟插件机制有什么关系呢？实际上，插件的各种 Hook 可以根据这两个构建阶段分为两类: ",(0,r.jsx)(n.code,{children:"Build Hook"})," 与 ",(0,r.jsx)(n.code,{children:"Output Hook"}),"。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Build Hook"}),"即在",(0,r.jsx)(n.code,{children:"Build"}),"阶段执行的钩子函数，在这个阶段主要进行模块代码的转换、AST 解析以及模块依赖的解析，那么这个阶段的 Hook 对于代码的操作粒度一般为",(0,r.jsx)(n.code,{children:"模块"}),"级别，也就是单文件级别。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Ouput Hook"}),"(官方称为",(0,r.jsx)(n.code,{children:"Output Generation Hook"}),")，则主要进行代码的打包，对于代码而言，操作粒度一般为 ",(0,r.jsx)(n.code,{children:"chunk"}),"级别(一个 chunk 通常指很多文件打包到一起的产物)。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["除了根据构建阶段可以将 Rollup 插件进行分类，根据不同的 Hook 执行方式也会有不同的分类，主要包括",(0,r.jsx)(n.code,{children:"Async"}),"、",(0,r.jsx)(n.code,{children:"Sync"}),"、",(0,r.jsx)(n.code,{children:"Parallel"}),"、",(0,r.jsx)(n.code,{children:"Squential"}),"、",(0,r.jsx)(n.code,{children:"First"}),"这五种。在后文中我们将接触各种各样的插件 Hook，但无论哪个 Hook 都离不开这五种执行方式。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"1. Async & Sync"})}),"\n",(0,r.jsxs)(n.p,{children:["首先是",(0,r.jsx)(n.code,{children:"Async"}),"和",(0,r.jsx)(n.code,{children:"Sync"}),"钩子函数，两者其实是相对的，分别代表",(0,r.jsx)(n.code,{children:"异步"}),"和",(0,r.jsx)(n.code,{children:"同步"}),"的钩子函数，两者最大的区别在于同步钩子里面不能有异步逻辑，而异步钩子可以有。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"2. Parallel"})}),"\n",(0,r.jsxs)(n.p,{children:["这里指并行的钩子函数。如果有多个插件实现了这个钩子的逻辑，一旦有钩子函数是异步逻辑，则并发执行钩子函数，不会等待当前钩子完成(底层使用 ",(0,r.jsx)(n.code,{children:"Promise.all"}),")。"]}),"\n",(0,r.jsxs)(n.p,{children:["比如对于",(0,r.jsx)(n.code,{children:"Build"}),"阶段的",(0,r.jsx)(n.code,{children:"buildStart"}),"钩子，它的执行时机其实是在构建刚开始的时候，各个插件可以在这个钩子当中做一些状态的初始化操作，但其实插件之间的操作并不是相互依赖的，也就是可以并发执行，从而提升构建性能。反之，对于需要",(0,r.jsx)(n.strong,{children:"依赖其他插件处理结果"}),"的情况就不适合用 ",(0,r.jsx)(n.code,{children:"Parallel"})," 钩子了，比如 ",(0,r.jsx)(n.code,{children:"transform"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"3. Sequential"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Sequential"})," 指串行的钩子函数。这种 Hook 往往适用于插件间处理结果相互依赖的情况，前一个插件 Hook 的返回值作为后续插件的入参，这种情况就需要等待前一个插件执行完 Hook，获得其执行结果，然后才能进行下一个插件相应 Hook 的调用，如",(0,r.jsx)(n.code,{children:"transform"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"4. First"})}),"\n",(0,r.jsxs)(n.p,{children:["如果有多个插件实现了这个 Hook，那么 Hook 将依次运行，直到返回一个非 null 或非 undefined 的值为止。比较典型的 Hook 是 ",(0,r.jsx)(n.code,{children:"resolveId"}),"，一旦有插件的 resolveId 返回了一个路径，将停止执行后续插件的 resolveId 逻辑。"]}),"\n",(0,r.jsxs)(n.p,{children:["刚刚我们介绍了 Rollup 当中不同插件 Hook 的类型，实际上不同的类型是可以叠加的，",(0,r.jsx)(n.code,{children:"Async"}),"/",(0,r.jsx)(n.code,{children:"Sync"})," 可以搭配后面三种类型中的任意一种，比如一个 Hook既可以是 ",(0,r.jsx)(n.code,{children:"Async"})," 也可以是 ",(0,r.jsx)(n.code,{children:"First"})," 类型，接着我们将来具体分析 Rollup 当中的插件工作流程，里面会涉及到具体的一些 Hook，大家可以具体地感受一下。"]}),"\n",(0,r.jsxs)(n.h3,{id:"build-阶段工作流",children:["Build 阶段工作流",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#build-阶段工作流",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先，我们来分析 Build 阶段的插件工作流程。对于 Build 阶段，插件 Hook 的调用流程如下图所示。流程图的最上面声明了不同 Hook 的类型，也就是我们在上面总结的 5 种 Hook 分类，每个方块代表了一个 Hook，边框的颜色可以表示",(0,r.jsx)(n.code,{children:"Async"}),"和",(0,r.jsx)(n.code,{children:"Sync"})," 类型，方块的填充颜色可以表示",(0,r.jsx)(n.code,{children:"Parallel"}),"、",(0,r.jsx)(n.code,{children:"Sequential"})," 和",(0,r.jsx)(n.code,{children:"First"})," 类型。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["乍一看是不是感觉这张图非常复杂？没关系，接下来我会和你一步步分析 ",(0,r.jsx)(n.code,{children:"Build Hooks"})," 的工作流程，你可以对照着图一起看。"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["首先经历 ",(0,r.jsx)(n.code,{children:"options"})," 钩子进行配置的转换，得到处理后的配置对象。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["随之 Rollup 会调用",(0,r.jsx)(n.code,{children:"buildStart"}),"钩子，正式开始构建流程。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Rollup 先进入到 ",(0,r.jsx)(n.code,{children:"resolveId"})," 钩子中解析文件路径。(从 ",(0,r.jsx)(n.code,{children:"input"})," 配置指定的入口文件开始)。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Rollup 通过调用",(0,r.jsx)(n.code,{children:"load"}),"钩子加载模块内容。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["紧接着 Rollup 执行所有的 ",(0,r.jsx)(n.code,{children:"transform"})," 钩子来对模块内容进行进行自定义的转换，比如 babel 转译。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"现在 Rollup 拿到最后的模块内容，进行 AST 分析，得到所有的 import 内容，调用 moduleParsed 钩子:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"6.1"})," 如果是普通的 import，则执行 ",(0,r.jsx)(n.code,{children:"resolveId"})," 钩子，继续回到步骤",(0,r.jsx)(n.code,{children:"3"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"6.2"})," 如果是动态 import，则执行 ",(0,r.jsx)(n.code,{children:"resolveDynamicImport"})," 钩子解析路径，如果解析成功，则回到步骤",(0,r.jsx)(n.code,{children:"4"}),"加载模块，否则回到步骤",(0,r.jsx)(n.code,{children:"3"}),"通过 ",(0,r.jsx)(n.code,{children:"resolveId"})," 解析路径。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["直到所有的 import 都解析完毕，Rollup 执行",(0,r.jsx)(n.code,{children:"buildEnd"}),"钩子，Build 阶段结束。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["当然，在 Rollup 解析路径的时候，即执行",(0,r.jsx)(n.code,{children:"resolveId"}),"或者",(0,r.jsx)(n.code,{children:"resolveDynamicImport"}),"的时候，有些路径可能会被标记为",(0,r.jsx)(n.code,{children:"external"}),"(翻译为",(0,r.jsx)(n.code,{children:"排除"}),")，也就是说不参加 Rollup 打包过程，这个时候就不会进行",(0,r.jsx)(n.code,{children:"load"}),"、",(0,r.jsx)(n.code,{children:"transform"}),"等等后续的处理了。"]}),"\n",(0,r.jsxs)(n.p,{children:["在流程图最上面，不知道大家有没有注意到",(0,r.jsx)(n.code,{children:"watchChange"}),"和",(0,r.jsx)(n.code,{children:"closeWatcher"}),"这两个 Hook，这里其实是对应了 rollup 的",(0,r.jsx)(n.code,{children:"watch"}),"模式。当你使用 ",(0,r.jsx)(n.code,{children:"rollup --watch"})," 指令或者在配置文件配有",(0,r.jsx)(n.code,{children:"watch: true"}),"的属性时，代表开启了 Rollup 的",(0,r.jsx)(n.code,{children:"watch"}),"打包模式，这个时候 Rollup 内部会初始化一个 ",(0,r.jsx)(n.code,{children:"watcher"})," 对象，当文件内容发生变化时，watcher 对象会自动触发",(0,r.jsx)(n.code,{children:"watchChange"}),"钩子执行并对项目进行重新构建。在当前",(0,r.jsx)(n.strong,{children:"打包过程结束"}),"时，Rollup 会自动清除 watcher 对象调用",(0,r.jsx)(n.code,{children:"closeWacher"}),"钩子。"]}),"\n",(0,r.jsxs)(n.h3,{id:"output-阶段工作流",children:["Output 阶段工作流",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#output-阶段工作流",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"好，接着我们来看看 Output 阶段的插件到底是如何来进行工作的。这个阶段的 Hook 相比于 Build 阶段稍微多一些，流程上也更加复杂。需要注意的是，其中会涉及的 Hook 函数比较多，可能会给你理解整个流程带来一些困扰，因此我会在 Hook 执行的阶段解释其大致的作用和意义，关于具体的使用大家可以去 Rollup 的官网自行查阅，毕竟这里的主线还是分析插件的执行流程，掺杂太多的使用细节反而不易于理解。下面我结合一张完整的插件流程图和你具体分析一下。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["执行所有插件的 ",(0,r.jsx)(n.code,{children:"outputOptions"})," 钩子函数，对 ",(0,r.jsx)(n.code,{children:"output"})," 配置进行转换。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["执行 ",(0,r.jsx)(n.code,{children:"renderStart"}),"，并发执行 renderStart 钩子，正式开始打包。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["并发执行所有插件的",(0,r.jsx)(n.code,{children:"banner"}),"、",(0,r.jsx)(n.code,{children:"footer"}),"、",(0,r.jsx)(n.code,{children:"intro"}),"、",(0,r.jsx)(n.code,{children:"outro"})," 钩子(底层用 Promise.all 包裹所有的这四种钩子函数)，这四个钩子功能很简单，就是往打包产物的固定位置(比如头部和尾部)插入一些自定义的内容，比如协议声明内容、项目介绍等等。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["从入口模块开始扫描，针对动态 import 语句执行 ",(0,r.jsx)(n.code,{children:"renderDynamicImport"}),"钩子，来自定义动态 import 的内容。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["对每个即将生成的 ",(0,r.jsx)(n.code,{children:"chunk"}),"，执行 ",(0,r.jsx)(n.code,{children:"augmentChunkHash"}),"钩子，来决定是否更改 chunk 的哈希值，在 ",(0,r.jsx)(n.code,{children:"watch"})," 模式下即可能会多次打包的场景下，这个钩子会比较适用。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["如果没有遇到 ",(0,r.jsx)(n.code,{children:"import.meta"})," 语句，则进入下一步，否则:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"6.1"})," 对于 ",(0,r.jsx)(n.code,{children:"import.meta.url"})," 语句调用 ",(0,r.jsx)(n.code,{children:"resolveFileUrl"})," 来自定义 url 解析逻辑"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"6.2"})," 对于其他",(0,r.jsx)(n.code,{children:"import.meta"})," 属性，则调用 ",(0,r.jsx)(n.code,{children:"resolveImportMeta"})," 来进行自定义的解析。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["接着 Rollup 会生成所有 chunk 的内容，针对每个 chunk 会依次调用插件的",(0,r.jsx)(n.code,{children:"renderChunk"}),"方法进行自定义操作，也就是说，在这里时候你可以直接操作打包产物了。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["随后会调用 ",(0,r.jsx)(n.code,{children:"generateBundle"})," 钩子，这个钩子的入参里面会包含所有的打包产物信息，包括 ",(0,r.jsx)(n.code,{children:"chunk"})," (打包后的代码)、",(0,r.jsx)(n.code,{children:"asset"}),"(最终的静态资源文件)。你可以在这里删除一些 chunk 或者 asset，最终这些内容将不会作为产物输出。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["前面提到了",(0,r.jsx)(n.code,{children:"rollup.rollup"}),"方法会返回一个",(0,r.jsx)(n.code,{children:"bundle"}),"对象，这个对象是包含",(0,r.jsx)(n.code,{children:"generate"}),"和",(0,r.jsx)(n.code,{children:"write"}),"两个方法，两个方法唯一的区别在于后者会将代码写入到磁盘中，同时会触发",(0,r.jsx)(n.code,{children:"writeBundle"}),"钩子，传入所有的打包产物信息，包括 chunk 和 asset，和 ",(0,r.jsx)(n.code,{children:"generateBundle"}),"钩子非常相似。不过值得注意的是，这个钩子执行的时候，产物已经输出了，而 generateBundle 执行的时候产物还并没有输出。顺序如下图所示:"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.ol,{start:"10",children:["\n",(0,r.jsxs)(n.li,{children:["当上述的",(0,r.jsx)(n.code,{children:"bundle"}),"的",(0,r.jsx)(n.code,{children:"close"}),"方法被调用时，会触发",(0,r.jsx)(n.code,{children:"closeBundle"}),"钩子，到这里 Output 阶段正式结束。"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意: 当打包过程中任何阶段出现错误，会触发 renderError 钩子，然后执行closeBundle钩子结束打包。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["到这里，我们终于梳理完了 Rollup 当中完整的插件工作流程，从一开始在",(0,r.jsx)(n.strong,{children:"构建生命周期"}),"中对两大构建阶段的感性认识，到现在",(0,r.jsx)(n.strong,{children:"插件工作流"}),"的具体分析，不禁感叹 Rollup 看似简单，实则内部细节繁杂。希望你能对照流程图好好复习几遍，彻底消化这部分的知识点，不仅仅能加深你对 Rollup 插件机制的理解，并且对 Rollup 本身打包原理的掌握也会更上一层楼。"]}),"\n",(0,r.jsxs)(n.h2,{id:"常用-hook-实战",children:["常用 Hook 实战",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常用-hook-实战",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"读到这里你可能会说了：上面讲了那么多 Rollup 插件机制的内容，但真正要去写一个插件，感觉还是很困难啊。"}),"\n",(0,r.jsxs)(n.p,{children:["这里我想要分享两个观点：首先是",(0,r.jsx)(n.strong,{children:"二八定律"}),"，也就是 20% 的 API 应对 80% 的场景，这放在 Rollup 当中仍然是适用的。经常使用到的 Hook 也并不多，况且 Rollup 插件的写法也非常简单，至少比 Webpack 插件要容易的多，因此掌握 Rollup 的插件开发难度并不大，这个大家放心。"]}),"\n",(0,r.jsxs)(n.p,{children:["其次，",(0,r.jsx)(n.strong,{children:"学会模仿"}),"也特别重要。尤其是刚开始什么经验都没有的时候，观察和模仿别人优秀的实现不失为一种高效的学习方法，慢慢地自己也会轻车熟路，成为一个经验丰富的老司机。"]}),"\n",(0,r.jsx)(n.p,{children:"实际上开发 Rollup 插件就是在编写一个个 Hook 函数，你可以理解为一个 Rollup 插件基本就是各种 Hook 函数的组合。因此，接下来我会详细介绍一些常用的 Hook，并以一些官方的插件实现为例，从 Hook 的特性、应用场景、入参和返回值的意义及实现代码示例这几个角度带你掌握各种 Hook 实际的使用，如此一来，开发一个完整的插件对你来说想必也不在话下了。"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"路径解析: resolveId"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["resolveId 钩子一般用来解析模块路径，为",(0,r.jsx)(n.code,{children:"Async + First"}),"类型即",(0,r.jsx)(n.code,{children:"异步优先"}),"的钩子。这里我们拿官方的 ",(0,r.jsx)(n.a,{href:"https://github.com/rollup/plugins/blob/master/packages/alias/src/index.ts",target:"_blank",rel:"noopener noreferrer",children:"alias 插件"})," 来说明，这个插件用法演示如下:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// rollup.config.js\nimport alias from '@rollup/plugin-alias';\nmodule.exports = {\n  input: 'src/index.js',\n  output: {\n    dir: 'output',\n    format: 'cjs'\n  },\n  plugins: [\n    alias({\n      entries: [\n        // 将把 import xxx from 'module-a' \n        // 转换为 import xxx from './module-a'\n        { find: 'module-a', replacement: './module-a.js' },\n      ]\n    })\n  ]\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"插件的代码简化后如下:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default alias(options) {\n  // 获取 entries 配置\n  const entries = getEntries(options);\n  return {\n    // 传入三个参数，当前模块路径、引用当前模块的模块路径、其余参数\n    resolveId(importee, importer, resolveOptions) {\n      // 先检查能不能匹配别名规则\n      const matchedEntry = entries.find((entry) => matches(entry.find, importee));\n      // 如果不能匹配替换规则，或者当前模块是入口模块，则不会继续后面的别名替换流程\n      if (!matchedEntry || !importerId) {\n        // return null 后，当前的模块路径会交给下一个插件处理\n        return null;\n      }\n      // 正式替换路径\n      const updatedId = normalizeId(\n        importee.replace(matchedEntry.find, matchedEntry.replacement)\n      );\n      // 每个插件执行时都会绑定一个上下文对象作为 this\n      // 这里的 this.resolve 会执行所有插件(除当前插件外)的 resolveId 钩子\n      return this.resolve(\n        updatedId,\n        importer,\n        Object.assign({ skipSelf: true }, resolveOptions)\n      ).then((resolved) => {\n        // 替换后的路径即 updateId 会经过别的插件进行处理\n        let finalResult: PartialResolvedId | null = resolved;\n        if (!finalResult) {\n          // 如果其它插件没有处理这个路径，则直接返回 updateId\n          finalResult = { id: updatedId };\n        }\n        return finalResult;\n      });\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["从这里你可以看到 resolveId 钩子函数的一些常用使用方式，它的入参分别是",(0,r.jsx)(n.code,{children:"当前模块路径"}),"、",(0,r.jsx)(n.code,{children:"引用当前模块的模块路径"}),"、",(0,r.jsx)(n.code,{children:"解析参数"}),"，返回值可以是 null、string 或者一个对象，我们分情况讨论。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"返回值为 null 时，会默认交给下一个插件的 resolveId 钩子处理。"}),"\n",(0,r.jsx)(n.li,{children:"返回值为 string 时，则停止后续插件的处理。这里为了让替换后的路径能被其他插件处理，特意调用了 this.resolve 来交给其它插件处理，否则将不会进入到其它插件的处理。"}),"\n",(0,r.jsxs)(n.li,{children:["返回值为一个对象，也会停止后续插件的处理，不过这个对象就可以包含",(0,r.jsx)(n.a,{href:"https://rollupjs.org/guide/en/#resolveid",target:"_blank",rel:"noopener noreferrer",children:"更多的信息"}),"了，包括解析后的路径、是否被 enternal、是否需要 tree-shaking 等等，不过大部分情况下返回一个 string 就够用了。"]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"load"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["load 为",(0,r.jsx)(n.code,{children:"Async + First"}),"类型，即",(0,r.jsx)(n.strong,{children:"异步优先"}),"的钩子，和",(0,r.jsx)(n.code,{children:"resolveId"}),"类似。它的作用是通过 resolveId 解析后的路径来加载模块内容。这里，我们以官方的 ",(0,r.jsx)(n.a,{href:"https://github.com/rollup/plugins/blob/master/packages/image/src/index.js",target:"_blank",rel:"noopener noreferrer",children:"image 插件"})," 为例来介绍一下 load 钩子的使用。源码简化后如下所示:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const mimeTypes = {\n  '.jpg': 'image/jpeg',\n  // 后面图片类型省略\n};\n\nexport default function image(opts = {}) {\n  const options = Object.assign({}, defaults, opts);\n  return {\n    name: 'image',\n    load(id) {\n      const mime = mimeTypes[extname(id)];\n      if (!mime) {\n        // 如果不是图片类型，返回 null，交给下一个插件处理\n        return null;\n      }\n      // 加载图片具体内容\n      const isSvg = mime === mimeTypes['.svg'];\n      const format = isSvg ? 'utf-8' : 'base64';\n      const source = readFileSync(id, format).replace(/[\\r\\n]+/gm, '');\n      const dataUri = getDataUri({ format, isSvg, mime, source });\n      const code = options.dom ? domTemplate({ dataUri }) : constTemplate({ dataUri });\n\n      return code.trim();\n    }\n  };\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"从中可以看到，load 钩子的入参是模块 id，返回值一般是 null、string 或者一个对象："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如果返回值为 null，则交给下一个插件处理；"}),"\n",(0,r.jsxs)(n.li,{children:["如果返回值为 string 或者对象，则终止后续插件的处理，如果是对象可以包含 SourceMap、AST 等",(0,r.jsx)(n.a,{href:"https://rollupjs.org/guide/en/#load",target:"_blank",rel:"noopener noreferrer",children:"更详细的信息"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"代码转换: transform"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"transform"})," 钩子也是非常常见的一个钩子函数，为",(0,r.jsx)(n.code,{children:"Async + Sequential"}),"类型，也就是",(0,r.jsx)(n.code,{children:"异步串行"}),"钩子，作用是对加载后的模块内容进行自定义的转换。我们以官方的 ",(0,r.jsx)(n.code,{children:"replace"})," 插件为例，这个插件的使用方式如下:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// rollup.config.js\nimport replace from '@rollup/plugin-replace';\n\nmodule.exports = {\n  input: 'src/index.js',\n  output: {\n    dir: 'output',\n    format: 'cjs'\n  },\n  plugins: [\n    // 将会把代码中所有的 __TEST__ 替换为 1\n    replace({\n      __TEST__: 1\n    })\n  ]\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"内部实现也并不复杂，主要通过字符串替换来实现，核心逻辑简化如下:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import MagicString from 'magic-string';\n\nexport default function replace(options = {}) {\n  return {\n    name: 'replace',\n    transform(code, id) {\n      // 省略一些边界情况的处理\n      // 执行代码替换的逻辑，并生成最后的代码和 SourceMap\n      return executeReplacement(code, id);\n    }\n  }\n}\n\nfunction executeReplacement(code, id) {\n  const magicString = new MagicString(code);\n  // 通过 magicString.overwrite 方法实现字符串替换\n  if (!codeHasReplacements(code, id, magicString)) {\n    return null;\n  }\n\n  const result = { code: magicString.toString() };\n\n  if (isSourceMapEnabled()) {\n    result.map = magicString.generateMap({ hires: true });\n  }\n\n  // 返回一个带有 code 和 map 属性的对象\n  return result;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://rollupjs.org/guide/en/#transform",target:"_blank",rel:"noopener noreferrer",children:"transform 钩子"}),"的入参分别为",(0,r.jsx)(n.code,{children:"模块代码"}),"、",(0,r.jsx)(n.code,{children:"模块 ID"}),"，返回一个包含 ",(0,r.jsx)(n.code,{children:"code"}),"(代码内容) 和 ",(0,r.jsx)(n.code,{children:"map"}),"(SourceMap 内容) 属性的对象，当然也可以返回 null 来跳过当前插件的 transform 处理。需要注意的是，",(0,r.jsx)(n.strong,{children:"当前插件返回的代码会作为下一个插件 transform 钩子的第一个入参"}),"，实现类似于瀑布流的处理。"]}),"\n",(0,r.jsxs)(n.ol,{start:"4",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Chunk 级代码修改: renderChunk"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["这里我们继续以 ",(0,r.jsx)(n.code,{children:"replace"}),"插件举例，在这个插件中，也同样实现了 renderChunk 钩子函数:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function replace(options = {}) {\n  return {\n    name: 'replace',\n    transform(code, id) {\n      // transform 代码省略\n    },\n    renderChunk(code, chunk) {\n      const id = chunk.fileName;\n      // 省略一些边界情况的处理\n      // 拿到 chunk 的代码及文件名，执行替换逻辑\n      return executeReplacement(code, id);\n    },\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"可以看到这里 replace 插件为了替换结果更加准确，在 renderChunk 钩子中又进行了一次替换，因为后续的插件仍然可能在 transform 中进行模块内容转换，进而可能出现符合替换规则的字符串。"}),"\n",(0,r.jsxs)(n.p,{children:["这里我们把关注点放到 renderChunk 函数本身，可以看到有两个入参，分别为 ",(0,r.jsx)(n.code,{children:"chunk 代码内容"}),"、",(0,r.jsx)(n.a,{href:"https://rollupjs.org/guide/en/#generatebundle",target:"_blank",rel:"noopener noreferrer",children:"chunk 元信息"}),"，返回值跟 ",(0,r.jsx)(n.code,{children:"transform"})," 钩子类似，既可以返回包含 code 和 map 属性的对象，也可以通过返回 null 来跳过当前钩子的处理。"]}),"\n",(0,r.jsxs)(n.ol,{start:"5",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"产物生成最后一步: generateBundle"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["generateBundle 也是",(0,r.jsx)(n.code,{children:"异步串行"}),"的钩子，你可以在这个钩子里面自定义删除一些无用的 chunk 或者静态资源，或者自己添加一些文件。这里我们以 Rollup 官方的",(0,r.jsx)(n.code,{children:"html"}),"插件来具体说明，这个插件的作用是通过拿到 Rollup 打包后的资源来生成包含这些资源的 HTML 文件，源码简化后如下所示:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function html(opts: RollupHtmlOptions = {}): Plugin {\n  // 初始化配置\n  return {\n    name: 'html',\n    async generateBundle(output: NormalizedOutputOptions, bundle: OutputBundle) {\n      // 省略一些边界情况的处理\n      // 1. 获取打包后的文件\n      const files = getFiles(bundle);\n      // 2. 组装 HTML，插入相应 meta、link 和 script 标签\n      const source = await template({ attributes, bundle, files, meta, publicPath, title});\n      // 3. 通过上下文对象的 emitFile 方法，输出 html 文件\n      const htmlFile: EmittedAsset = {\n        type: 'asset',\n        source,\n        name: 'Rollup HTML Asset',\n        fileName\n      };\n      this.emitFile(htmlFile);\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["相信从插件的具体实现中，你也能感受到这个钩子的强大作用了。入参分别为",(0,r.jsx)(n.code,{children:"output 配置"}),"、",(0,r.jsx)(n.a,{href:"https://rollupjs.org/guide/en/#generatebundle",target:"_blank",rel:"noopener noreferrer",children:"所有打包产物的元信息对象"}),"，通过操作元信息对象你可以删除一些不需要的 chunk 或者静态资源，也可以通过 插件上下文对象的",(0,r.jsx)(n.code,{children:"emitFile"}),"方法输出自定义文件。"]}),"\n",(0,r.jsx)(n.p,{children:"好，常用的 Rollup 钩子我们就先介绍到这里，相信这些知识点已经足够你应付大多数的构建场景了。顺便说一句，大家在后面的章节可以了解到，Vite 的插件机制也是基于 Rollup 来实现的，像上面介绍的这些常用钩子在 Vite 当中也随处可见，因此，掌握了这些常用钩子，也相当于给 Vite 插件的学习做下了很好的铺垫。"}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["好，到这里本篇的内容就结束了。在这篇文章中，我们首先认识到 Rollup 为了追求扩展性和可维护性，引入了插件机制，而后给你介绍了 Rollup 的 ",(0,r.jsx)(n.code,{children:"Build"})," 和",(0,r.jsx)(n.code,{children:"Output"})," 两大构建阶段，接着给你详细地分析了两大构建阶段的插件工作流，最后通过几个实际的官方插件带你熟悉了一些常见的 Hook。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"Rollup 的插件开发整体上是非常简洁和灵活的，总结为以下几个方面:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"插件逻辑集中管理"}),"。各个阶段的 Hook 都可以放在一个插件中编写，比如上述两个 Webpack 的 Loader 和 Plugin 功能在 Rollup 只需要用一个插件，分别通过 transform 和 renderChunk 两个 Hook 来实现。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"插件 API 简洁，符合直觉"}),"。Rollup 插件基本上只需要返回一个包含 name 和各种钩子函数的对象即可，也就是声明一个 name 属性，然后写几个钩子函数即可。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"插件间的互相调用"}),"。比如刚刚介绍的",(0,r.jsx)(n.code,{children:"alias"}),"插件，可以通过插件上下文对象的",(0,r.jsx)(n.code,{children:"resolve"}),"方法，继续调用其它插件的 ",(0,r.jsx)(n.code,{children:"resolveId"}),"钩子，类似的还有",(0,r.jsx)(n.code,{children:"load"}),"方法，这就大大增加了插件的灵活性。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"现在，相信你已经从宏观到细节上，已经对 Rollup 插件有了全面的掌握，为接下来的 Vite 学习打下了坚实的基础。如果你还没有完全掌握，不用着急，这部分的内容本身有点难度，希望你能回头复习几遍，相信你一定能彻底拿下这些内容。大家加油吧！"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}let j=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F11.Vite%20%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%9F%B3(%E4%B8%8B)%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Rollup%20%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6.md"]={toc:[{text:"Rollup 整体构建阶段",id:"rollup-整体构建阶段",depth:2},{text:"拆解插件工作流",id:"拆解插件工作流",depth:2},{text:"谈谈插件 Hook 类型",id:"谈谈插件-hook-类型",depth:3},{text:"Build 阶段工作流",id:"build-阶段工作流",depth:3},{text:"Output 阶段工作流",id:"output-阶段工作流",depth:3},{text:"常用 Hook 实战",id:"常用-hook-实战",depth:2},{text:"小结",id:"小结",depth:2}],title:"11.Vite 构建基石(下)——深入理解 Rollup 的插件机制",headingTitle:"11.Vite 构建基石(下)——深入理解 Rollup 的插件机制",frontmatter:{}}}}]);