"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["48850"],{516044:function(e,n,r){e.exports=r.p+"static/image/32f2fb90a25cffbe9572dc43adcb45b3.4d619ac2.webp"},573685:function(e,n,r){r.r(n),r.d(n,{default:()=>J});var t=r(552676),s=r(740453);let o=r.p+"static/image/d0fe51f6a6c8f8d4980c11e80791c134.3df0d63a.gif";var c=r(516044);let a=r.p+"static/image/c4d498f66d9c0bf9b94a6d48f2e4c81f.154bf7d6.webp",l=r.p+"static/image/62c6fd492b64d33b8598e17a3b0d82e6.e2194de9.webp",i=r.p+"static/image/30585afc40d85201b30da3324c91a29f.89a3f512.gif",d=r.p+"static/image/0d72ece75ce9967eba6e9f53860bf28d.323586ee.webp",p=r.p+"static/image/34370f66009b1b70e3e9d2ac2ec51020.6d697f12.gif",f=r.p+"static/image/11906bb8291dec3a4ea783e28bdc2f67.89993dbb.webp",h=r.p+"static/image/a8c2480670765fcd1dc40a5c8de91333.1921af17.webp",g=r.p+"static/image/4570bcf2e8fdfe581a8ed5fb1ce214a2.400b9db4.webp",m=r.p+"static/image/4e157e16937ae7422b1a549ade543b35.0bb92563.webp",x=r.p+"static/image/2588bd62a4275b1721128790a42d7a64.b75f6010.webp",j=r.p+"static/image/96cda0f0a70d2abf59d8d90f645e21fd.ee720b6a.webp",u=r.p+"static/image/1e2d2797f3ac59e27dd6390ad46fbe4b.5fa0b19d.webp",v=r.p+"static/image/9ec69203cc09ce69e22d139006fab3d2.c912dbba.gif",b=r.p+"static/image/c42fdbc8214904c61dfcd4cef8ea572b.3e6a1a25.webp",C=r.p+"static/image/1d77a114ec94470ecb1d8a85c136f656.62288bdd.webp",A=r.p+"static/image/afbf67c07b7e255d3cebd423e82cf9bd.6ae7ceba.gif",P=r.p+"static/image/fa6741c02bb120d77a5f3ed17acbbd81.be9368dc.webp",E=r.p+"static/image/ecf6d7a7c4e8603ebd7d4c6709b546f4.e75d0dd7.webp",H=r.p+"static/image/8afdd07dedc4030a561f7382431762fd.582da3f5.webp",w=r.p+"static/image/da09179ae1b98d093c809748998e3c62.41692056.webp",R=r.p+"static/image/063a772b4408ffb300287f24471f0b76.5fb31387.webp",y=r.p+"static/image/ce60175f31094deb5c14fc9b09bec779.44d36f5a.webp",k=r.p+"static/image/ccd96e8eb1b0997e7954e96747d288d1.5ccd4b87.webp",D=r.p+"static/image/1d8cf4c98fe2657150a5b9516e2c5f26.29ff14ea.webp",O=r.p+"static/image/bf9f4425ce084e7c6a9c330df2a97158.5ae745ce.webp",T=r.p+"static/image/0396e94402d6e59f12100921b53de1f4.b496f8b1.webp",S=r.p+"static/image/aabb71aa02e80c171b1ec6d4237135d7.aed31e5a.webp",X=r.p+"static/image/72d3635e334ecf85ce3fbee221f4a9a9.b4eb1685.webp",L=r.p+"static/image/e52e942cc0a960d1de31e9dcc1c98502.55ea8e94.webp",N=r.p+"static/image/4d8ece3760af4c4a5b427462db917480.72d4882b.webp",B=r.p+"static/image/eb5902661bf599830ee8656099fcd7d4.2c00960c.webp",F=r.p+"static/image/e91ee8301fa7c617672c1115c9e1be8f.ce37ebb7.webp",Y=r.p+"static/image/866966337e1e780fd6cbd3c4e6db039a.d008819a.webp",V=r.p+"static/image/469ec3345de49af2cd69d3619eeb4d69.fd480ad4.webp",I=r.p+"static/image/030ca0539c326021e004fe4d927f4dc9.56a109df.webp",Z=r.p+"static/image/695f1340b9be5ca4a01626e97e1554fa.d93efca5.webp",K=r.p+"static/image/8b643235a79ff6a1e5462e2bbebddac0.ba7ac11e.webp",q=r.p+"static/image/64015f10855b45109b63ac049d9e048d.95c7f834.webp",G=r.p+"static/image/132b8de8badeceaf22de680e12013bae.9b79245e.webp",M=r.p+"static/image/dfb517e9c6b0ce1d212d8dfbb0757352.cfd1a175.webp",W=r.p+"static/image/882b34bab87849278e81d76fe68cad9c.7df73450.webp",U=r.p+"static/image/8967cfdf6bc6ed3b227ac92667889fc5.26c3d463.webp";function Q(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"第35章组件实战colorpicker颜色选择器二",children:["第35章—组件实战：ColorPicker颜色选择器（二）",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第35章组件实战colorpicker颜色选择器二",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"\uFEFF这节我们开始写 ColorPicker 组件。"}),"\n",(0,t.jsxs)(n.p,{children:["看下 antd 的 ",(0,t.jsx)(n.a,{href:"https://ant-design.antgroup.com/components/color-picker-cn#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA",target:"_blank",rel:"noopener noreferrer",children:"ColorPicker 组件"}),"："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:U,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以分成这两部分："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:W,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"上面是一个 ColorPickerPanel，可以通过滑块选择颜色，调整色相、饱和度。"}),"\n",(0,t.jsx)(n.p,{children:"下面是 ColorInput，可以通过输入框修改颜色，可以切换 RGB、HEX 等色彩模式。"}),"\n",(0,t.jsx)(n.p,{children:"我们先写 ColorPickerPanel 的部分："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这部分分为上面的调色板 Palette，下面的 Slider 滑动条。"}),"\n",(0,t.jsx)(n.p,{children:"这样一拆解，是不是思路就清晰了呢？"}),"\n",(0,t.jsx)(n.p,{children:"新建个项目："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx create-react-app --template=typescript color-picker-component\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:M,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"新建 ColorPicker 目录，然后创建 ColorPickerPanel 组件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { CSSProperties } from \"react\";\nimport cs from 'classnames';\nimport './index.scss';\n\nexport interface ColorPickerProps {\n    className?: string;\n    style?: CSSProperties\n}\n\nfunction ColorPickerPanel(props: ColorPickerProps) {\n\n    const {\n        className,\n        style\n    } = props;\n\n    const classNames = cs(\"color-picker\", className);\n\n    return <div className={classNames} style={style}>\n    </div>\n}\n\nexport default ColorPickerPanel;\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"安装用到的 classnames 包："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install --save classnames\n"})}),"\n",(0,t.jsx)(n.p,{children:"style 和 className 这俩 props 就不用解释了。"}),"\n",(0,t.jsx)(n.p,{children:"然后添加 value 和 onChange 的参数："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:G,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"interface ColorPickerProps {\n    className?: string;\n    style?: CSSProperties;\n    value?: string;\n    onChange?: (color: string) => void;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里颜色用 string 类型不大好，最好是有专门的 Color 类，可以用来切换 RGB、HSL、HEX 等颜色格式。"}),"\n",(0,t.jsx)(n.p,{children:"直接用 @ctrl/tinycolor 这个包就行。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install --save @ctrl/tinycolor\n"})}),"\n",(0,t.jsx)(n.p,{children:"先试一下这个包："}),"\n",(0,t.jsx)(n.p,{children:"创建 index.js"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const { TinyColor } = require(\"@ctrl/tinycolor\");\n\nlet color = new TinyColor('red');\n\nconsole.log(color.toHex());\nconsole.log(color.toHsl());\nconsole.log(color.toRgb());\nconsole.log();\n\ncolor = new TinyColor('#00ff00');\n\nconsole.log(color.toHex());\nconsole.log(color.toHsl());\nconsole.log(color.toRgb());\nconsole.log();\n\ncolor = new TinyColor({ r: 0, g: 0, b: 255});\n\nconsole.log(color.toHex());\nconsole.log(color.toHsl());\nconsole.log(color.toRgb());\nconsole.log();\n"})}),"\n",(0,t.jsx)(n.p,{children:"跑一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:q,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，TinyColor 能识别出颜色的格式，并且在 hex、hsl、rgb 之间进行转换。"}),"\n",(0,t.jsx)(n.p,{children:"然后添加 ColorPicker/color.ts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { TinyColor } from '@ctrl/tinycolor';\n\nexport class Color extends TinyColor {\n\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"那 value 直接写 Color 类型么？"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:K,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"也不好，这样用起来得 new 一个 Color 对象才行，不方便。"}),"\n",(0,t.jsx)(n.p,{children:"所以我们类型要这样写："}),"\n",(0,t.jsx)(n.p,{children:"创建 ColorPicker/interface.ts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import type { Color } from './color';\n\nexport interface HSL {\n  h: number | string;\n  s: number | string;\n  l: number | string;\n}\n\nexport interface RGB {\n  r: number | string;\n  g: number | string;\n  b: number | string;\n}\n\nexport interface HSLA extends HSL {\n  a: number;\n}\n\nexport interface RGBA extends RGB {\n  a: number;\n}\n\nexport type ColorType =\n  | string\n  | number\n  | RGB\n  | RGBA\n  | HSL\n  | HSLA\n  | Color;\n"})}),"\n",(0,t.jsx)(n.p,{children:"支持 string 还有 number 还有 rgb、hsl、rgba、hsla 这几种格式，或者直接传一个 Color 对象。"}),"\n",(0,t.jsx)(n.p,{children:"在组件里判断下 value 类型，如果不是 Color，那就创建一个 Color 对象，传入 Palette："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:Z,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { CSSProperties, useState } from "react";\nimport cs from \'classnames\';\nimport { ColorType } from "./interface";\nimport { Color } from "./color";\nimport Palette from "./Palette";\nimport \'./index.scss\';\n\nexport interface ColorPickerProps {\n    className?: string;\n    style?: CSSProperties;\n    value?: ColorType;\n    onChange?: (color: Color) => void;\n}\n\nfunction ColorPickerPanel(props: ColorPickerProps) {\n\n    const {\n        className,\n        style,\n        value,\n        onChange\n    } = props;\n\n    const [colorValue, setColorValue] = useState<Color>(() => {\n        if (value instanceof Color) {\n            return value;\n        }\n        return new Color(value);\n    });\n\n    const classNames = cs("color-picker", className);\n\n    return <div className={classNames} style={style}>\n        <Palette color={colorValue}></Palette>\n    </div>\n}\n\nexport default ColorPickerPanel;\n'})}),"\n",(0,t.jsx)(n.p,{children:"接下来写 Palette 组件："}),"\n",(0,t.jsx)(n.p,{children:"src/Palette.tsx"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import type { FC } from 'react';\nimport { Color } from './color';\n\nconst Palette: FC<{\n  color: Color\n}> = ({ color }) => {\n    return (\n        <div className=\"color-picker-panel-palette\" >\n            <div \n                className=\"color-picker-panel-palette-main\"\n                style={{\n                    backgroundColor: `hsl(${color.toHsl().h},100%, 50%)`,\n                    backgroundImage:\n                        'linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))',\n                }}\n            />\n        </div>\n    );\n};\n\nexport default Palette;\n"})}),"\n",(0,t.jsx)(n.p,{children:"拿到 color 的 hsl 值中的色相，然后加一个横向和纵向的渐变就好了。"}),"\n",(0,t.jsx)(n.p,{children:"我们写下样式 ColorPicker/index.scss："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scss",children:".color-picker {\n    width: 300px;\n\n    &-panel {\n        &-palette {\n            position: relative;\n            min-height: 160px;\n    \n            &-main {\n                position: absolute;\n                top: 0;\n                bottom: 0;\n                left: 0;\n                right: 0;\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"安装用到的包："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install --save-dev sass\n"})}),"\n",(0,t.jsx)(n.p,{children:"跑一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm run start\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:I,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"调色板出来了。"}),"\n",(0,t.jsx)(n.p,{children:"还要实现上面的滑块，这个封装个组件，因为 Slider 也会用到："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:V,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"创建 ColorPicker/Handler.tsx："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import classNames from 'classnames';\nimport type { FC } from 'react';\n\ntype HandlerSize = 'default' | 'small';\n\ninterface HandlerProps {\n    size?: HandlerSize;\n    color?: string;\n};\n\nconst Handler: FC<HandlerProps> = ({ size = 'default', color }) => {\n  return (\n    <div\n      className={classNames(`color-picker-panel-palette-handler`, {\n        [`color-picker-panel-palette-handler-sm`]: size === 'small',\n      })}\n      style={{\n        backgroundColor: color,\n      }}\n    />\n  );\n};\n\nexport default Handler;\n"})}),"\n",(0,t.jsx)(n.p,{children:"有 size 和 color 两个参数。"}),"\n",(0,t.jsx)(n.p,{children:"size 是 default 和 small 两个取值，因为这俩滑块是不一样大的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:Y,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"加一下两种滑块的样式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:F,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scss",children:"&-handler {\n    box-sizing: border-box;\n    width: 16px;\n    height: 16px;\n    border: 2px solid #fff;\n    border-radius: 50%;\n    box-shadow: 0 0 1px 1px rgba(0, 0, 0, 0);\n}\n&-handler-sm {\n    width: 12px;\n    height: 12px;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"在 Palette 引入下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:B,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"<Handler color={color.toRgbString()}/>\n"})}),"\n",(0,t.jsx)(n.p,{children:"刷新下页面，确实是有的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:N,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"只是现在看不到。"}),"\n",(0,t.jsx)(n.p,{children:"加一下 zindex 就好了："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:L,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:X,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"但是不建议写在这里。"}),"\n",(0,t.jsx)(n.p,{children:"为什么呢？"}),"\n",(0,t.jsx)(n.p,{children:"因为这里写了 position: absolute 那是不是 Handler 组件也得加上 x、y 的参数。"}),"\n",(0,t.jsx)(n.p,{children:"这样它就不纯粹了，复用性会变差。"}),"\n",(0,t.jsx)(n.p,{children:"所以可以把定位的样式抽离成一个单独的 Transform 组件："}),"\n",(0,t.jsx)(n.p,{children:"创建 Transform："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import React, { forwardRef } from 'react';\n\nexport interface TransformOffset {\n    x: number;\n    y: number;\n};\n\ninterface TransformProps {\n    offset?: TransformOffset;\n    children?: React.ReactNode;\n}\n\nconst Transform = forwardRef<HTMLDivElement, TransformProps>((props, ref) => {\n  const { children, offset } = props;\n  return (\n    <div\n      ref={ref}\n      style={{\n        position: 'absolute',\n        left: offset?.x ?? 0,\n        top: offset?.y ?? 0,\n        zIndex: 1,\n      }}\n    >\n      {children}\n    </div>\n  );\n});\n\nexport default Transform;\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:S,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useRef, type FC } from 'react';\nimport { Color } from './color';\nimport Handler from './Handler';\nimport Transform from './Transform';\n\nconst Palette: FC<{\n  color: Color\n}> = ({ color }) => {\n    const transformRef = useRef<HTMLDivElement>(null);\n\n    return (\n        <div className=\"color-picker-panel-palette\" >\n            <Transform ref={transformRef} offset={{x: 50, y: 50}}>\n                <Handler color={color.toRgbString()}/>\n            </Transform>\n            <div \n                className={`color-picker-panel-palette-main`}\n                style={{\n                    backgroundColor: `hsl(${color.toHsl().h},100%, 50%)`,\n                    backgroundImage:\n                        'linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))',\n                }}\n            />\n        </div>\n    );\n};\n\nexport default Palette;\n"})}),"\n",(0,t.jsx)(n.p,{children:"看下效果："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:T,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"如果不单独分 Transform 这个组件呢？"}),"\n",(0,t.jsx)(n.p,{children:"那就是把这段样式写在 Hanlder 组件里，然后加上俩参数："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:O,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"功能是一样的，但是不如拆分出来复用性好。"}),"\n",(0,t.jsx)(n.p,{children:"然后我们加上拖拽功能。"}),"\n",(0,t.jsx)(n.p,{children:"拖拽就是给元素绑定 mousedown、mousemove、mouseup 事件，在 mousemove 的时候改变 x、y。"}),"\n",(0,t.jsx)(n.p,{children:"这部分逻辑比较复杂，我们封装一个自定义 hook 来做。"}),"\n",(0,t.jsx)(n.p,{children:"创建 ColorPicker/useColorDrag.ts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef, useState } from 'react';\nimport { TransformOffset } from './Transform';\n\ntype EventType =\n  | MouseEvent\n  | React.MouseEvent<Element, MouseEvent>\n\ntype EventHandle = (e: EventType) => void;\n\ninterface useColorDragProps {\n    offset?: TransformOffset;\n    containerRef: React.RefObject<HTMLDivElement>;\n    targetRef: React.RefObject<HTMLDivElement>;\n    direction?: 'x' | 'y';\n    onDragChange?: (offset: TransformOffset) => void;\n}\n\nfunction useColorDrag(\n  props: useColorDragProps,\n): [TransformOffset, EventHandle] {\n    const {\n        offset,\n        targetRef,\n        containerRef,\n        direction,\n        onDragChange,\n    } = props;\n\n    const [offsetValue, setOffsetValue] = useState(offset || { x: 0, y: 0 });\n    const dragRef = useRef({\n        flag: false\n    });\n\n    useEffect(() => {\n        document.removeEventListener('mousemove', onDragMove);\n        document.removeEventListener('mouseup', onDragStop);\n    }, []);\n\n    const updateOffset: EventHandle = e => {\n        \n    };\n\n\n    const onDragStop: EventHandle = e => {\n        document.removeEventListener('mousemove', onDragMove);\n        document.removeEventListener('mouseup', onDragStop);\n\n        dragRef.current.flag = false;\n    };\n\n    const onDragMove: EventHandle = e => {\n        e.preventDefault();\n        updateOffset(e);\n    };\n\n    const onDragStart: EventHandle = e => {\n        document.addEventListener('mousemove', onDragMove);\n        document.addEventListener('mouseup', onDragStop);\n\n        dragRef.current.flag = true;\n    };\n\n    return [offsetValue, onDragStart];\n}\n\nexport default useColorDrag;\n"})}),"\n",(0,t.jsx)(n.p,{children:"代码比较多，从上到下来看："}),"\n",(0,t.jsx)(n.p,{children:"MouseEvent 是 ts 内置的原生鼠标事件类型，而 React.MouseEvent 是 react 提供鼠标事件类型。"}),"\n",(0,t.jsx)(n.p,{children:"是因为 react 里的事件是被 react 处理过的，和原生事件不一样。"}),"\n",(0,t.jsx)(n.p,{children:"直接给 document 绑定事件，这时候 event 是 MouseEvent 类型："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:D,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"而在 jsx 里绑定事件，这时候 event 是 React.MouseEvent 类型："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:k,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们都要支持："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:y,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这两个一个是保存 offset 的，一个是保存是否在拖动中的标记的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:R,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后先把之前的事件监听器去掉："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:w,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"在 mousedown 的时候绑定 mousemove 和 mouseup 事件："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:H,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"mousemove 的时候根据 event 修改 offset。"}),"\n",(0,t.jsx)(n.p,{children:"mouseup 的时候去掉事件监听器。"}),"\n",(0,t.jsx)(n.p,{children:"这个过程中还要修改记录拖动状态的 flag 的值。"}),"\n",(0,t.jsx)(n.p,{children:"然后实现拖动过程中的 offset 的计算："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const updateOffset: EventHandle = e => {\n    const scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft;\n    const scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop;\n\n    const pageX = e.pageX - scrollXOffset;\n    const pageY = e.pageY - scrollYOffset;\n\n    const { \n        x: rectX,\n        y: rectY,\n        width,\n        height\n    } = containerRef.current!.getBoundingClientRect();\n\n    const { \n        width: targetWidth,\n        height: targetHeight\n    } = targetRef.current!.getBoundingClientRect();\n\n    const centerOffsetX = targetWidth / 2;\n    const centerOffsetY = targetHeight / 2;\n\n    const offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;\n    const offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;\n\n    const calcOffset = {\n        x: offsetX,\n        y: direction === 'x' ? offsetValue.y : offsetY,\n    };\n\n    setOffsetValue(calcOffset);\n    onDragChange?.(calcOffset);\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"首先 e.pageX 和 e.pageY 是距离页面顶部和左边的距离。"}),"\n",(0,t.jsx)(n.p,{children:"减去 scrollLeft 和 scrollTop 之后就是离可视区域顶部和左边的距离了。"}),"\n",(0,t.jsx)(n.p,{children:"然后减去 handler 圆点的半径。"}),"\n",(0,t.jsx)(n.p,{children:"这样算出来的就是按住 handler 圆点的中心拖动的效果。"}),"\n",(0,t.jsx)(n.p,{children:"但是拖动不能超出 container 的区域，所以用 Math.max 来限制在 0 到 width、height 之间拖动。"}),"\n",(0,t.jsx)(n.p,{children:"这里如果传入的 direction 参数是 x，那么就只能横向拖动，是为了下面的 Slider 准备的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:E,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们来试下效果："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:P,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useRef, type FC } from 'react';\nimport { Color } from './color';\nimport Handler from './Handler';\nimport Transform from './Transform';\nimport useColorDrag from './useColorDrag';\n\nconst Palette: FC<{\n  color: Color\n}> = ({ color }) => {\n    const transformRef = useRef<HTMLDivElement>(null);\n    const containerRef = useRef<HTMLDivElement>(null);\n\n    const [offset, dragStartHandle] = useColorDrag({\n        containerRef,\n        targetRef: transformRef,\n        onDragChange: offsetValue => {\n            console.log(offsetValue);\n        }\n    });\n\n    return (\n        <div \n            ref={containerRef}\n            className=\"color-picker-panel-palette\"\n            onMouseDown={dragStartHandle}\n        >\n            <Transform ref={transformRef} offset={{x: offset.x, y: offset.y}}>\n                <Handler color={color.toRgbString()}/>\n            </Transform>\n            <div \n                className={`color-picker-panel-palette-main`}\n                style={{\n                    backgroundColor: `hsl(${color.toHsl().h},100%, 50%)`,\n                    backgroundImage:\n                        'linear-gradient(0deg, #000, transparent),linear-gradient(90deg, #fff, hsla(0, 0%, 100%, 0))',\n                }}\n            />\n        </div>\n    );\n};\n\nexport default Palette;\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:A,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，滑块可以拖动了，并且只能在容器范围内拖动。"}),"\n",(0,t.jsx)(n.p,{children:"只是颜色没有变化，这个需要根据 x、y 的值来算出当前的颜色。"}),"\n",(0,t.jsx)(n.p,{children:"我们封装个工具方法："}),"\n",(0,t.jsx)(n.p,{children:"新建 ColorPicker/utils.ts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { TransformOffset } from "./Transform";\nimport { Color } from "./color";\n\nexport const calculateColor = (props: {\n    offset: TransformOffset;\n    containerRef: React.RefObject<HTMLDivElement>;\n    targetRef: React.RefObject<HTMLDivElement>;\n    color: Color;\n}): Color => {\n    const { offset, targetRef, containerRef, color } = props;\n\n    const { width, height } = containerRef.current!.getBoundingClientRect();\n    const { \n        width: targetWidth,\n        height: targetHeight\n    } = targetRef.current!.getBoundingClientRect();\n\n    const centerOffsetX = targetWidth / 2;\n    const centerOffsetY = targetHeight / 2;\n\n    const saturation = (offset.x + centerOffsetX) / width;\n    const lightness = 1 - (offset.y + centerOffsetY) / height;\n    const hsv = color.toHsv();\n\n    return new Color({\n        h: hsv.h,\n        s: saturation <= 0 ? 0 : saturation,\n        v: lightness >= 1 ? 1 : lightness,\n        a: hsv.a,\n    });\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"这块逻辑就是用 x/width 用 y/height 求出一个比例来。"}),"\n",(0,t.jsx)(n.p,{children:"当然，x、y 还要加上圆点的半径，这样才是中心点位置。"}),"\n",(0,t.jsx)(n.p,{children:"根据比例设置 hsv 的值，这样就算出了拖动位置的颜色。"}),"\n",(0,t.jsx)(n.p,{children:"然后在 onDragChange 里根据 offset 计算当前的颜色，并且通过 onChange 回调返回新颜色。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:C,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"在 ColorPickerPanel 组件里处理下 onChange："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function onPaletteColorChange(color: Color) {\n    setColorValue(color);\n    onChange?.(color);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"修改当前颜色，并且调用它的 onChange 回调函数。"}),"\n",(0,t.jsx)(n.p,{children:"测试下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:v,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,t.jsx)(n.p,{children:"只是现在初始的颜色不对："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"最开始也要计算一次滑块位置："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们给 useColorDrag 添加 color 和 calculate 两个参数。"}),"\n",(0,t.jsx)(n.p,{children:"最开始和 color 改变的时候，调用 calculate 计算位置，重新设置  offsetValue。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef, useState } from 'react';\nimport { TransformOffset } from './Transform';\nimport { Color } from './color';\n\ntype EventType =\n  | MouseEvent\n  | React.MouseEvent<Element, MouseEvent>\n\ntype EventHandle = (e: EventType) => void;\n\ninterface useColorDragProps {\n    offset?: TransformOffset;\n    color: Color;\n    containerRef: React.RefObject<HTMLDivElement>;\n    targetRef: React.RefObject<HTMLDivElement>;\n    direction?: 'x' | 'y';\n    onDragChange?: (offset: TransformOffset) => void;\n    calculate?: () => TransformOffset;\n}\n\nfunction useColorDrag(\n  props: useColorDragProps,\n): [TransformOffset, EventHandle] {\n    const {\n        offset,\n        color,\n        targetRef,\n        containerRef,\n        direction,\n        onDragChange,\n        calculate,\n    } = props;\n\n    const [offsetValue, setOffsetValue] = useState(offset || { x: 0, y: 0 });\n    const dragRef = useRef({\n        flag: false\n    });\n\n    useEffect(() => {\n        if (dragRef.current.flag === false) {\n          const calcOffset = calculate?.();\n          if (calcOffset) {\n            setOffsetValue(calcOffset);\n          }\n        }\n      }, [color]);\n\n    useEffect(() => {\n        document.removeEventListener('mousemove', onDragMove);\n        document.removeEventListener('mouseup', onDragStop);\n    }, []);\n\n    const updateOffset: EventHandle = e => {\n        const scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft;\n        const scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop;\n\n        const pageX = e.pageX - scrollXOffset;\n        const pageY = e.pageY - scrollYOffset;\n\n        const { \n            x: rectX,\n            y: rectY,\n            width,\n            height\n        } = containerRef.current!.getBoundingClientRect();\n\n        const { \n            width: targetWidth,\n            height: targetHeight\n        } = targetRef.current!.getBoundingClientRect();\n\n        const centerOffsetX = targetWidth / 2;\n        const centerOffsetY = targetHeight / 2;\n\n        const offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;\n        const offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;\n\n        const calcOffset = {\n            x: offsetX,\n            y: direction === 'x' ? offsetValue.y : offsetY,\n        };\n\n        setOffsetValue(calcOffset);\n        onDragChange?.(calcOffset);\n    };\n\n\n    const onDragStop: EventHandle = e => {\n        document.removeEventListener('mousemove', onDragMove);\n        document.removeEventListener('mouseup', onDragStop);\n\n        dragRef.current.flag = false;\n    };\n\n    const onDragMove: EventHandle = e => {\n        e.preventDefault();\n        updateOffset(e);\n    };\n\n    const onDragStart: EventHandle = e => {\n        document.addEventListener('mousemove', onDragMove);\n        document.addEventListener('mouseup', onDragStop);\n\n        dragRef.current.flag = true;\n    };\n\n    return [offsetValue, onDragStart];\n}\n\nexport default useColorDrag;\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后在调用的时候传入这两个参数："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const [offset, dragStartHandle] = useColorDrag({\n    containerRef,\n    targetRef: transformRef,\n    color,\n    onDragChange: offsetValue => {\n        const newColor = calculateColor({\n            offset: offsetValue,\n            containerRef,\n            targetRef: transformRef,\n            color\n        });\n        onChange?.(newColor);\n    },\n    calculate: () => {\n        return calculateOffset(containerRef, transformRef, color)\n    }\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里的 calculateOffset 在 utils.ts 里定义："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export const calculateOffset = (\n    containerRef: React.RefObject<HTMLDivElement>,\n    targetRef: React.RefObject<HTMLDivElement>,\n    color: Color\n): TransformOffset => {\n    const { width, height } = containerRef.current!.getBoundingClientRect();\n    const { \n        width: targetWidth,\n        height: targetHeight \n    } = targetRef.current!.getBoundingClientRect();\n\n    const centerOffsetX = targetWidth / 2;\n    const centerOffsetY = targetHeight / 2;\n    const hsv = color.toHsv();\n\n    return {\n        x: hsv.s * width - centerOffsetX,\n        y: (1 - hsv.v) * height - centerOffsetY,\n    };\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"就是根据 hsv 里的 s 和 v 的百分比乘以 width、height，计算出 x、y，然后减去滑块的宽高的一半。"}),"\n",(0,t.jsx)(n.p,{children:"可以看到，现在初始位置就对了："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我在 App.tsx 里设置个不同的颜色："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<ColorPickerPanel value="rgb(166 57 57)"></ColorPickerPanel>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["初始位置也是对的：\n",(0,t.jsx)("img",{src:h,alt:""})]}),"\n",(0,t.jsx)(n.p,{children:"我们在下面加一个颜色块："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<div style={{width: 20, height: 20, background: colorValue.toRgbString()}}></div>\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，随着滑块的移动，返回的颜色是对的。"}),"\n",(0,t.jsx)(n.p,{children:"但有时候会变为选择，而不是拖拽，我们优化下体验："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-css",children:"user-select: none;\ncursor: pointer;\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"2024-08-31 17.55.28.gif"})}),"\n",(0,t.jsx)(n.p,{children:"好多了。"}),"\n",(0,t.jsx)(n.p,{children:"还有一点，我们前面的 value 参数其实是 defaultValue："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"也就是用来作为内部 state 的初始值。"}),"\n",(0,t.jsx)(n.p,{children:"这里我们同时支持受控和非受控，用 ahooks 的 useControllableValue 做。"}),"\n",(0,t.jsx)(n.p,{children:"安装 ahooks："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install --save ahooks\n"})}),"\n",(0,t.jsx)(n.p,{children:"把 useState 换成 ahooks 的 useControllableValue："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export interface ColorPickerProps {\n    className?: string;\n    style?: CSSProperties;\n    value?: ColorType;\n    defaultValue?: ColorType;\n    onChange?: (color: Color) => void;\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const [colorValue, setColorValue] = useControllableValue<Color>(props);\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样就同时支持了 value 和 defaultValue，也就是受控和非受控模式。"}),"\n",(0,t.jsx)(n.p,{children:"然后我们加上调节色相和亮度的滑块："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:"data:image/webp;base64,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",alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"因为我们计算颜色用的是 hsv，这里两个滑块分别改变的就是 h（色相）、v（明度）。"}),"\n",(0,t.jsx)(n.p,{children:"我们简化下，直接用 input range 来做吧："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import React, { ChangeEventHandler, useState } from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport ColorPickerPanel from './ColorPicker/ColorPickerPanel';\nimport { Color } from './ColorPicker/color';\n\nfunction App() {\n  const [color, setColor] = useState<Color>(new Color('rgb(166,57,255)'));\n\n  const handleHueChange: ChangeEventHandler<HTMLInputElement> = (e) => {\n    const hsv = color.toHsv();\n    let val = +e.target.value;\n\n    setColor(new Color({\n        h: val,\n        s: hsv.s,\n        v: hsv.v,\n    }))\n  }\n\n  const handleVChange: ChangeEventHandler<HTMLInputElement> = (e) => {\n    const hsv = color.toHsv();\n    let val = +e.target.value;\n\n    setColor(new Color({\n        h: hsv.h,\n        s: hsv.s,\n        v: val,\n    }))\n  }\n\n  return (\n    <div style={{width: '300px'}}>\n      <ColorPickerPanel value={color} onChange={newColor => setColor(newColor)}></ColorPickerPanel>\n      <div>\n        色相：<input type='range' min={0} max={360} step={0.1} value={color.toHsv().h} onChange={handleHueChange}/>\n      </div>\n      <div>\n        明度：<input type='range' min={0} max={1} step={0.01} value={color.toHsv().v} onChange={handleVChange}/>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"h 的取值范围是 0 到 360"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"而 v 的取值范围是 0 到 100%"}),"\n",(0,t.jsx)(n.p,{children:"试一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"2024-08-31 18.35.50.gif"})}),"\n",(0,t.jsx)(n.p,{children:"这样，ColorPicker 就完成了。"}),"\n",(0,t.jsxs)(n.p,{children:["案例代码上传了",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/color-picker-component",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这节我们实现了 ColorPicker 的调色板。"}),"\n",(0,t.jsx)(n.p,{children:"它的布局不复杂，就是一个渐变的背景，加上一个绝对定位的滑块。"}),"\n",(0,t.jsx)(n.p,{children:"就是根据位置计算颜色、根据颜色计算位置，这两个方向的计算比较复杂。"}),"\n",(0,t.jsx)(n.p,{children:"根据位置计算颜色，以 x 方向为例："}),"\n",(0,t.jsx)(n.p,{children:"需要用 mousemove 时的 e.pageX（距离文档左边的距离） 减去 scrollLeft 计算出滑块距离视口的距离，然后减去容器距离视口的距离，再减去滑块半径就是滑块距离容器的距离 x。"}),"\n",(0,t.jsx)(n.p,{children:"然后用这个 x 除以 width 计算出 hsv 中的 s 的值。"}),"\n",(0,t.jsx)(n.p,{children:"这样就根据拖拽位置计算出了颜色。"}),"\n",(0,t.jsx)(n.p,{children:"根据颜色计算位置比较简单，直接拿到 hsv 的 s 和 v 的值，根据百分比乘以 width、height 就行。"}),"\n",(0,t.jsx)(n.p,{children:"此外，颜色我们用的 @ctrl/tinycolor 这个包的颜色类，antd 也是用的这个。但是参数不用直接传 Color 类的实例，可以传 rgb、string 等我们内部转成 Color 类。"}),"\n",(0,t.jsx)(n.p,{children:"我们还用 ahooks 的 useControllableValue 同时支持了 value 和 defaultValue 也就是受控和非受控模式。"}),"\n",(0,t.jsx)(n.p,{children:"最后，支持了色相和明度的调整。"}),"\n",(0,t.jsx)(n.p,{children:"至此，ColorPicker 组件就完成了。"})]})}function z(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(Q,{...e})}):Q(e)}let J=z;z.__RSPRESS_PAGE_META={},z.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC35%E7%AB%A0%E2%80%94%E7%BB%84%E4%BB%B6%E5%AE%9E%E6%88%98%EF%BC%9AColorPicker%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第35章—组件实战：ColorPicker颜色选择器（二）",headingTitle:"第35章—组件实战：ColorPicker颜色选择器（二）",frontmatter:{}}}}]);