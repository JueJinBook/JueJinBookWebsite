"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["28050"],{341264:function(e,n,t){t.r(n),t.d(n,{default:()=>g});var r=t(552676),i=t(740453);let s=t.p+"static/image/f2cb85ba56f0fdd910c4ed222a1fc522.f098c867.webp",c=t.p+"static/image/2fb7f34cf93ebff688ad83b31d8ffaec.3aa31aff.webp",o=t.p+"static/image/3f22152381d5cac44f41adb3cb98a1cf.2434ba42.webp",d=t.p+"static/image/a623cf4ea97b82314b33d4efa0ced6c7.1e0c26f7.webp",a=t.p+"static/image/82cfb67bc8ba03a2777f9546ad217d0d.cf859ba5.webp",l=t.p+"static/image/454d2112b2d66f251fd8098b4d822318.4dbfa653.webp",m=t.p+"static/image/1c6dbabda7af404dc8cf1eee69f395a0.87bcf370.webp",h=t.p+"static/image/61c7e31ea630c69ebf1c64ee6c452900.337265eb.webp",x=t.p+"static/image/4784f0ba59a3bfa1daf68b6239cf1e2d.eba7512a.webp",p=t.p+"static/image/127456141a05e3864ba5d3b482516730.8259485c.webp",j=t.p+"static/image/654cba529d35051339f89e882a127b54.a9af1861.webp",u=t.p+"static/image/623aee3877c35c92ab77a42a5b405795.5d962ce0.webp";function b(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",img:"img",h2:"h2",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",code:"code",h3:"h3",ul:"ul",li:"li",pre:"pre"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"6dom-断言页面元素的断言",children:["6.DOM 断言：页面元素的断言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6dom-断言页面元素的断言",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["代码仓库：",(0,r.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"在前两节课，我们学习了 DOM 元素的渲染和查询，我们来简单回忆一下，针对页面元素的渲染，React Testing Library 提供了 render API。render API 会把渲染的元素写入页面的 innerHtml，并会返回指定元素的查询，同时在全局也有暴露一个 screen 全局对象，它将会返回针对 document.body，也就是在当前渲染元素的内容加上 body，并返回标签的查询。"}),"\n",(0,r.jsx)(n.p,{children:"通过获得的查询对象，我们就可以对渲染的元素进行更细粒度的获取，查询的方式可以按照行为和参照物两个维度进行拆分，我们使用最多的是通过角色来查询，这是基于 ARIA 语义提供的查询方式，最贴近功能和需求的语义。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"虽然查询 API 数量众多，但是使用上也有对应的优先级，为了书写尽可能稳健的用例，我们需要保证我们的查询贴近用户视角，或是用户可见，所以就有了上面的优先级。"}),"\n",(0,r.jsx)(n.p,{children:"在完成预期对象的查询后，下一步我们需要做的就是对查询出的元素进行预期的断言。除 Jest 提供的断言外，React Testing Library 也提供了一组断言来帮助我们更好地描述自己的预期，这节课我们将结合例子来具体说明怎么对页面元素进行断言。"}),"\n",(0,r.jsxs)(n.h2,{id:"页面元素的断言",children:["页面元素的断言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#页面元素的断言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["页面元素的断言 API 是由 ",(0,r.jsx)(n.a,{href:"https://github.com/testing-library",target:"_blank",rel:"noopener noreferrer",children:"testing-library"}),"/",(0,r.jsx)(n.a,{href:"https://github.com/testing-library/jest-dom",target:"_blank",rel:"noopener noreferrer",children:"jest-dom"})," 来提供的，为了方便大家学习理解，我把常用的一些断言根据使用场景分为了页面可见、表单验证和代码层面验证三类，下面我们就按照这三个类别来展开 DOM 断言的学习。"]}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{children:"断言使用场景"}),"\n",(0,r.jsx)(n.th,{children:"断言 API"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"页面可见"}),"\n",(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"toBeEmptyDOMElement"}),"  ",(0,r.jsx)(n.code,{children:"toBeVisible"}),"  ",(0,r.jsx)(n.code,{children:"toBeInTheDocument"}),"  ",(0,r.jsx)(n.code,{children:"toHaveTextContent"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"表单验证"}),"\n",(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"toBeDisabled"}),"  ",(0,r.jsx)(n.code,{children:"toBeEnabled"}),"  ",(0,r.jsx)(n.code,{children:"toBeRequired"}),"  ",(0,r.jsx)(n.code,{children:"toHaveFocus"}),"  ",(0,r.jsx)(n.code,{children:"toBeChecked"}),"  ",(0,r.jsx)(n.code,{children:"toHaveFormValues"})," ",(0,r.jsx)(n.code,{children:"toHaveValue"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"代码层面验证"}),"\n",(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"toHaveAttribute"}),"  ",(0,r.jsx)(n.code,{children:"toHaveClass"}),"  ",(0,r.jsx)(n.code,{children:"toHaveStyle"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"页面可见",children:["页面可见",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#页面可见",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先我们来介绍一下",(0,r.jsx)(n.code,{children:"toBeEmptyDOMElement"})," | ",(0,r.jsx)(n.code,{children:"toBeVisible"})," | ",(0,r.jsx)(n.code,{children:"toBeInTheDocument"})," 这三个断言，它们的含义很接近，都可以用来表示是否可见，但是之间存在一些微小的差异："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeEmptyDOMElement"}),"：标签之间是否有可见内容， 即使是空格也会失败；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeVisible"}),"：是否可见，从用户直接观察的角度看能否可见；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeInTheDocument"}),"：是否存在在文档中，document.body 是否存在这个元素。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"上面的简图就初步描述了它们之间的差异，我们来举例具体说明一下，为了区分上节课的用例，我们单独创建一个新的组件来存放我们这章节的代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/components/DomExpect/index.tsx\nimport { FC } from "react";\n\ninterface IProps {}\n\n// 《6 | DOM断言：页面元素的断言》\nexport const DomExpect: FC<IProps> = ({}) => {\n  return (\n    <div>\n      <div aria-label="empty_note"></div>\n      <div role="note" style={{ display: "none" }} aria-hidden>\n        1234\n      </div>\n      <div role="note">1234</div>\n    </div>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// ./src/__test__/dom_expect.test.tsx\nimport React from "react";\nimport { render, screen } from "@testing-library/react";\nimport { DomExpect } from "../components/DomExpect/index";\n\ndescribe("tests for 《6 | DOM断言:页面元素的断言》", () => {\n  test("visible validation", () => {\n    render(<DomExpect />);\n    const emptyNote = screen.getByRole("generic", { name: "empty_note" });\n    const [hiddenNote] = screen.getAllByRole("note", { hidden: true });\n    const normalNote = screen.getByRole("note");\n    expect(emptyNote).toBeEmptyDOMElement();\n    expect(hiddenNote).not.toBeVisible();\n    expect(emptyNote).toBeInTheDocument();\n    expect(hiddenNote).toBeInTheDocument();\n    expect(normalNote).toBeInTheDocument();\n  });\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"上面的例子中我们写了几个常见的 DOM，现在我们结合上面三个断言的含义，来解释一下它们分别能命中哪几个 DOM："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeInTheDocument"}),"： 这三个 DOM 都是可以满足",(0,r.jsx)(n.code,{children:"toBeInTheDocument"}),"的，因为这几个元素都在文本文档中；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeVisible"}),"：只有",(0,r.jsx)(n.code,{children:'<div role="note" style={{ display: "none" }} aria-hidden>1234</div>'})," 是不能满足的，因为我们对它加上了",(0,r.jsx)(n.code,{children:"display: none"}),"的样式，所以是不可见于 DOM 树的；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeEmptyDOMElement"}),": 只有",(0,r.jsx)(n.code,{children:'<div aria-label="empty_note"></div>'})," 是匹配 ",(0,r.jsx)(n.code,{children:"toBeEmptyDOMElement"}),"的，因为只有它的标签之间没有包含任何内容。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["值得一提的是，只有 ",(0,r.jsx)(n.code,{children:"aria-hidden"})," 并不会影响 visible 的判断，这是一个语义的属性，并不作为匹配的一个标准。如果只是加了 ",(0,r.jsx)(n.code,{children:"aria-hidden"})," 而实际可见，仍然会匹配 ",(0,r.jsx)(n.code,{children:"toBeVisible"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"除了断言的部分，这个例子中查询的部分我也想和大家具体聊一聊，针对 empty 例子的查询我们为它加上了 label 属性，然后通过了 role 查询的 name 去定位。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<div aria-label="empty_note"></div>\n'})}),"\n",(0,r.jsx)(n.p,{children:"对于隐藏元素查询的部分，大家可能会有两个疑惑的点："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"为什么例子中的 normalNote 可以直接用 get 配合角色来定位，文档中不是有两个这样的角色吗？"}),"\n",(0,r.jsxs)(n.li,{children:["为什么",(0,r.jsx)(n.code,{children:"hidden:true"}),"元素的查询需要用 getAll，它不是只有一个吗？"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"针对这两个问题，我们来具体解释一下。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["针对第一个问题，我们的确定义了两个 note 角色，能够直接用单查的方式定位到 hidden: false 元素的原因在于，对于 getByRole，它的默认筛选值中 hidden = false，也就是说，当直接使用 getByRole 的时候，效果等同于 ",(0,r.jsx)(n.code,{children:"getByRole(role, {hidden:false})"}),"。"]}),"\n",(0,r.jsx)(n.li,{children:"当需要查询 hidden:true 元素的时候，大部分场景需要使用 getAll，为什么呢？因为连带 hidden: false 的元素会被一起查询出来，按照 DOM 顺序返回数组，所以这里的 hidden: true 并不是选取 hidden 属性为 true 的元素，而是是否需要查询 hidden 属性为 true 的元素。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["到这里，",(0,r.jsx)(n.code,{children:"toBeEmptyDOMElement"})," 、 ",(0,r.jsx)(n.code,{children:"toBeVisible"}),"、 ",(0,r.jsx)(n.code,{children:"toBeInTheDocument"}),"这三个断言相信大家就已经有了一个初步的认识了，在页面可见这个方向的断言中，还有一个",(0,r.jsx)(n.code,{children:"toHaveTextContent"}),"没介绍，这个断言和可见其实没有太大的关系，它可以用来匹配对应节点有没有指定的内容，因为也是和页面内容强相关，所以放在了一起，我们来看下面这个例子。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/dom_expect.test.tsx\nimport React from "react";\nimport { render, screen } from "@testing-library/react";\nimport { DomExpect } from "../components/DomExpect/index";\n\ndescribe("tests for 《6 | DOM断言:页面元素的断言》", () => {\n  test("visible validation", () => {\n    // ... \n    expect(normalNote).toHaveTextContent(/1/i);\n  });\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在上文的用例中，我们额外加入了一条断言，断言",(0,r.jsx)(n.code,{children:'<div role="note">1234</div>'}),"的标签文案中包含 1 ，通过这个断言我们可以快速高效地匹配查询的内容是否符合预期。"]}),"\n",(0,r.jsxs)(n.h3,{id:"表单验证",children:["表单验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#表单验证",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"不管是业务需求还是基础组件，我们都会经常接触到表单，可以说表单是前端和服务端 IDL 联系的纽带，不管是多复杂的系统，都是从表单展开对应的功能，所以对表单进行验证和断言是必要且频繁的。针对表单，React Testing Library 提供了下面的断言来协助我们对逻辑进行匹配："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeDisabled"})," ：检查元素是否通过 disable 属性判断，而不是 aria-disabled；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeEnabled"}),": 是否未被禁用，等同于 ",(0,r.jsx)(n.code,{children:".not.toBeDisabled"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeRequired"}),": 元素是否必填；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toHaveFocus"}),": 元素是否聚焦；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toBeChecked"}),": checkbox 或者是 radio 是否被选中；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toHaveFormValues"}),"：验证整体表单的值是否和预期值匹配；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toHaveValue"}),"：与 ",(0,r.jsx)(n.code,{children:"toHaveFormValues"})," 类似，不过不同的是 ",(0,r.jsx)(n.code,{children:"toHaveValue"})," 验证某个单独的表单元素，而不是全部。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们来看下面的这个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// ./src/__test__/dom_expect.test.tsx\nimport { FC } from "react";\n\ninterface IProps {}\n\n// 《6 | DOM断言：页面元素的断言》\nexport const DomExpect: FC<IProps> = ({}) => {\n  return (\n    <div>\n      {/* ... other content */}\n      <form aria-label="form">\n        <input\n          type="text"\n          name="username"\n          disabled\n          aria-disabled\n          defaultValue="zhenmin"\n        />\n        <input type="number" name="age" defaultValue={23} required />\n        <input\n          type="radio"\n          name="sex"\n          value="man"\n          defaultChecked\n          aria-checked\n        />\n        <input type="radio" name="sex" value="woman" />\n      </form>\n    </div>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// ./src/__test__/dom_expect.test.tsx\nimport React from "react";\nimport { render, screen } from "@testing-library/react";\nimport { DomExpect } from "../components/DomExpect/index";\n\ndescribe("tests for 《6 | DOM断言:页面元素的断言》", () => {\n  // ...\n  test("form validation without semi", () => {\n    render(<DomExpect />);\n    const form = screen.getByRole("form");\n    const username = screen.getByRole("textbox");\n    const age = screen.getByRole("spinbutton");\n    const manCheckbox = screen.getByRole("radio", { checked: true });\n    const womanCheckbox = screen.getByRole("radio", { checked: false });\n    expect(username).toBeDisabled();\n    expect(age).toBeEnabled();\n    expect(age).toBeRequired();\n    age.focus();\n    expect(age).toHaveFocus();\n    expect(manCheckbox).toBeChecked();\n    expect(womanCheckbox).not.toBeChecked();\n    expect(form).toHaveFormValues({\n      username: "zhenmin",\n      age: 23,\n      sex: "man",\n    });\n    expect(age).toHaveValue(23);\n  });\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"在上面的例子中，我们定义了一个表单，在这个表单中包含四个元素："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'name 为 username 的文本框，被禁用，拥有一个 "zhenmin" 的默认值；'}),"\n",(0,r.jsx)(n.li,{children:"name 为 age 的数字文本框，必填，拥有 23 的默认值；"}),"\n",(0,r.jsx)(n.li,{children:"两个 radio ，name 为 sex， 值为 man 的那个被默认选中。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们通过它们的默认角色进行了查询，对于两个 radio ，我们使用了 checked 的 aria 属性来区分它们。除 checked 外，如果具备同类元素，可以再加上 aria-label 来筛选。要注意的是，这里的 name 不能用 name 筛选，因为它在表单中并不作为语义属性。"}),"\n",(0,r.jsxs)(n.p,{children:["值得一提的是，对于 form 元素，虽然它包含 form 角色，但是必须要加上 aria-label 才可以使用 ",(0,r.jsx)(n.code,{children:'screen.getByRole("form")'}),"进行筛选，这是一个很特殊的规则，因为 form 元素没有一个可访问的信息，大家可以尝试删掉",(0,r.jsx)(n.code,{children:'<form aria-label="form">'})," 中的 aria-label 属性，应该会出现下面的报错。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"相信这个查询的选用会给大家很大的启发，在实际的业务应用中，我们应该也尽可能采用 role 和 aria 属性混用的方式来匹配我们需要的元素，而不要滥用 test-id，因为这样会导致我们堆砌了大量与语义无关的测试标签，这是没有意义且比较糟糕的做法。"}),"\n",(0,r.jsx)(n.p,{children:"选取完元素后，我们使用了上面介绍的断言来匹配我们想验证的内容："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"name 为 username 的文本框被禁用；"}),"\n",(0,r.jsx)(n.li,{children:"name 为 age 的文本框可正常交互，必填的和聚焦的，且值为 23；"}),"\n",(0,r.jsx)(n.li,{children:"值为 man 的 checkbox 被选中， woman 没被选中；"}),"\n",(0,r.jsxs)(n.li,{children:["form 的 value 为 ",(0,r.jsx)(n.code,{children:'{ username: "zhenmin", age: 23, sex: "man"}'}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["需要特别说明的是 ",(0,r.jsx)(n.code,{children:"age.focus"}),"，这里我们使用 fireEvent 来模拟 focus 聚焦的效果，完成我们",(0,r.jsx)(n.code,{children:"toHaveFocus"}),"的验证，不过准确地说，这是一种可以实现但不好的方式，这个并不是严格意义上的从用户视角来模拟，而是从代码角度去直接模拟事件。"]}),"\n",(0,r.jsxs)(n.p,{children:["与此类似的还有 user-event ，它是一个更贴近用户场景，更准确的方式，它们之间的区别咱们这边不多提及，详细的部分我们会在",(0,r.jsx)(n.a,{href:"https://juejin.cn/editor/book/7174044519350927395/section/7176804373316501556",target:"_blank",rel:"noopener noreferrer",children:"7 | User-event: 怎么对 Dom 组件绑定事件进行模拟触发？"})," 具体学习。"]}),"\n",(0,r.jsxs)(n.h3,{id:"代码层面验证",children:["代码层面验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码层面验证",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"除了从用户交互层面的测试，我们有的时候还是需要从代码层面进行验证的，比如某个类、属性或者样式需要在特定场景下包含，这种情况，我们就需要使用到代码层面验证的断言了。"}),"\n",(0,r.jsx)(n.p,{children:"对于代码层面验证的断言，我们常用的有下面三个："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toHaveAttribute"}),": 匹配元素是否具备某个值的属性；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toHaveClass"}),": 匹配元素在类属性中是否包含某个类；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toHaveStyle"}),": 匹配元素是否具有对应样式，需要注意的是，这个是精准非模糊匹配，例如 ",(0,r.jsx)(n.code,{children:"display: none"})," 无法匹配",(0,r.jsx)(n.code,{children:"  display:none;color:#fff; "}),"。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们来看下面的例子，对于 DOM 的部分，我们复用之前的差不多就够用了，为其中一个元素加一下类："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/dom_expect.test.tsx\nimport { FC } from "react";\n\ninterface IProps {}\n\n// 《6 | DOM断言：页面元素的断言》\nexport const DomExpect: FC<IProps> = ({}) => {\n  return (\n    <div>\n      {/* ... other content */}\n      <div\n        role="note"\n        style={{ display: "none" }}\n        className="test hidden"\n        aria-hidden\n      >\n        1234\n      </div>\n      {/* ... other content */}\n    </div>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/dom_expect.test.tsx\nimport React from "react";\nimport { render, screen } from "@testing-library/react";\nimport { DomExpect } from "../components/DomExpect/index";\n\ndescribe("tests for 《6 | DOM断言:页面元素的断言》", () => {\n  // ...\n  test("code validation", () => {\n    render(<DomExpect />);\n    const [hiddenNote] = screen.getAllByRole("note", { hidden: true });\n    expect(hiddenNote).toHaveAttribute("aria-hidden");\n    expect(hiddenNote).toHaveClass("hidden");\n    expect(hiddenNote).toHaveStyle("display: none");\n  });\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在上面的例子中，选取了我们之前定义的隐藏区域的 DOM，并对它分别验证了属性、类名和样式，对于属性验证的那个断言",(0,r.jsx)(n.code,{children:'expect(hiddenNote).toHaveAttribute("aria-hidden")'}),"，我们只使用了第一个参数，这个会直接验证这个属性是否存在，同时它也还接收第二个参数，用于验证属性的值，如果需要判断属性的值，大家可以采用类似",(0,r.jsx)(n.code,{children:"toHaveAttribute(attr, value)"}),"的写法。"]}),"\n",(0,r.jsxs)(n.h2,{id:"基于组件库的断言",children:["基于组件库的断言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基于组件库的断言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"对于业务代码，我们不可避免会使用到组件库，尤其是针对表单的模块，组件库暴露出来的组件未必是基于原生的标签来魔改的，所以在查询和断言上有些许差异，我们以 Semi 组件库的 Select 组件为例，我们知道原生使用下拉框，我们会使用 select 标签，但是那个的定制性会比较差，Semi 提供了一个功能更强大的 Select 组件，如下图。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"不过，它的实现并不是通过 select 标签来实现的，而是自己重构了一套，我们可以打开控制台选一下 select 的区域。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样在查询上，我们就不能用常规选取 select 角色的方式来选取了，所以针对组件库的场景，我们额外补充一份对应的用例来给大家作为对应场景实践的参考，我们首先来安装一下 semi 的依赖："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm i @douyinfe/semi-ui\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后我们来看下面的例子，除 semi 表单验证外，我们还修改了一下表单验证的部分，避免一些角色的冲突，相应的普通表单的验证我们也做了一些调整："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/dom_expect.test.tsx\nimport { FC } from \'react\';\nimport { Form } from \'@douyinfe/semi-ui\';\n\ninterface IProps {}\n\n// 《6 | DOM断言：页面元素的断言》\nexport const DomExpect: FC<IProps> = ({}) => (\n  <div>\n    {/* ...other content */}\n    {/* 表单验证 */}\n    <form aria-label="form">\n      <input type="text" name="username" disabled aria-disabled defaultValue="zhenmin" aria-label="form_username" />\n      <input type="number" name="age" defaultValue={23} required aria-label="form_age" />\n      <input type="radio" name="sex" value="man" defaultChecked aria-checked aria-label="form_sex" />\n      <input type="radio" name="sex" value="woman" aria-label="form_sex" />\n    </form>\n    {/* semi 表单验证 */}\n    <Form initValues={{ username: \'zhenmin\', age: 23, sex: \'man\', hobby: \'code\' }} aria-label="semi-form">\n      <Form.Input field="username" disabled name="username" />\n      <Form.InputNumber field="age" required name="age" />\n      <Form.RadioGroup field="sex" name="sex">\n        <Form.Radio value="man" />\n        <Form.Radio value="woman" />\n      </Form.RadioGroup>\n      <Form.Select field="hobby" name="hobby">\n        <Form.Select.Option value="code">code</Form.Select.Option>\n        <Form.Select.Option value="read">read</Form.Select.Option>\n      </Form.Select>\n    </Form>\n  </div>\n);\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// ./src/__test__/dom_expect.test.tsx\nimport React from \"react\";\nimport { render, screen } from \"@testing-library/react\";\nimport { DomExpect } from \"../components/DomExpect/index\";\n\ndescribe(\"tests for 《6 | DOM断言:页面元素的断言》\", () => {\n  // ...\n  test('form validation without semi', () => {\n    render(<DomExpect />);\n    const form = screen.getByRole('form', { name: 'form' });\n    const username = screen.getByRole('textbox', { name: 'form_username' });\n    const age = screen.getByRole('spinbutton', { name: 'form_age' });\n    const manCheckbox = screen.getByRole('radio', { checked: true, name: 'form_sex' });\n    const womanCheckbox = screen.getByRole('radio', { checked: false, name: 'form_sex' });\n    expect(username).toBeDisabled();\n    expect(age).toBeEnabled();\n    expect(age).toBeRequired();\n    age.focus();\n    expect(age).toHaveFocus();\n    expect(manCheckbox).toBeChecked();\n    expect(womanCheckbox).not.toBeChecked();\n    expect(form).toHaveFormValues({\n      username: 'zhenmin',\n      age: 23,\n      sex: 'man',\n    });\n    expect(age).toHaveValue(23);\n  });\n  // ...\n  test('visible validation with semi', () => {\n    render(<DomExpect />);\n    const form = screen.getByRole('form', { name: 'semi-form' });\n    const username = screen.getByLabelText('username');\n    const age = screen.getByLabelText('age');\n    const sex = screen.getByLabelText('sex');\n    const hobby = screen.getByLabelText('hobby');\n    expect(username).toBeDisabled();\n    expect(age).toBeEnabled();\n    expect(age).toBeRequired();\n    age.focus();\n    expect(age).toHaveFocus();\n    // expect(username).toHaveValue('zhenmin');\n    // expect(hobby).toHaveValue('code');\n    // expect(form).toHaveFormValues({\n    //   username: 'zhenmin',\n    //   age: 23,\n    //   sex: 'man',\n    //   hobby: 'code',\n    // });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"普通表单验证调整的地方大家自己看一下就好，加了一些 label 来区分，我们来看一下 semi 表单处的用例，首先对于查询，form 处我们需要自己加上 label，原理和之前是一样的，这样 form 才可以作为可访问的信息。对于剩下的表单元素，我们可以直接通过 labeltext 来查询，semi 会将对应的 field 注入到 aria-labelledby 中，例如下图的效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"到这里都还挺顺利的，不过到验证值的时候就会出现问题了。我们之前介绍过 react testing library 提供了针对表单元素和整体表单值的断言，表单元素的断言依赖元素上绑定的 value 属性，而整体表单的断言依赖每个元素的 name 来绑定。"}),"\n",(0,r.jsx)(n.p,{children:"对于表单元素，semi 有些会给我们加上 value，比如 input，像上例中的 username。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但是有一些不会，比如说像 select，那个是基于 div 自己实现的，像上例中的 hobby。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["对于整体表单，",(0,r.jsx)(n.code,{children:"toHaveFormValues"})," 断言会完全失效，因为我们使用了 Form 组件，所有的表单元素name 都会被接管到类名上，而不是透传到对应元素上，从源码上我们也可以看到它的选取方式。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个问题其实是 Semi 最初设计遗留下来的历史包袱，额外增加的 name 字段覆盖了 html 标签提供的 name 属性，加上当时 Semi 使用的单测是基于 enzyme，的确很难暴露出这个问题。因为这个问题从 1.x 就已经开始存在，很多业务方在使用现在考虑到兼容性也没办法去做不兼容修改，后续可能 Semi 会额外加上一个属性用于 html 标签 name 属性的透传，这个 feature 我也会继续跟进 Semi 那边的进度。"}),"\n",(0,r.jsx)(n.p,{children:"在 Semi 还没额外替我们加属性透传前，有什么办法可以解决这个问题呢？对于 Semi 表单值的处理，我这边提供三个方案给大家参考："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["这是最推荐的方案。使用 Semi Form 组件，但是跳过值处理的断言，直接断言 submit 事件，因为 semi 单测已经帮我们测试过组件内的逻辑，从单测的角度来说，依赖的功能我们不进行测试也是合理的，只需要保证 submit 事件可以被触发即可，至于执行的函数本身，我们可以单独加上用例进行测试。事件的模拟我们会在 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7174044519350927395/section/7176804373316501556",target:"_blank",rel:"noopener noreferrer",children:"7 | User-event: 怎么对 Dom 组件绑定事件进行模拟触发？"})," 中介绍。"]}),"\n",(0,r.jsx)(n.li,{children:"换用普通 Semi Input 组件，不用 Semi Form 组件来接管数据，对于普通的 Input 组件是会透传到标签本身的，如下图。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"加一个 hidden 区域来存放表单的值，我们直接验证 hidden 区域，这个其实很 hack ，如果大家评估的确需要测试这部分，可以采取这个方案，我们来看下面的例子："}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/dom_expect.test.tsx\nimport { FC, useState } from \'react\';\nimport { Form } from \'@douyinfe/semi-ui\';\n\ninterface IProps {}\n\n// 《6 | DOM断言：页面元素的断言》\nexport const DomExpect: FC<IProps> = ({}) => {\n  const [semiFormValues, setSemiFormValues] = useState({ username: \'zhenmin\', age: 23, sex: \'man\', hobby: \'code\' });\n\n  return (\n    <div>\n      {/* ... other content */}\n      {/* semi 表单验证 */}\n      <Form\n        initValues={semiFormValues}\n        aria-label="semi-form"\n        onChange={(data: any): void => {\n          setSemiFormValues(data);\n        }}\n      >\n        <Form.Input field="username" disabled name="username" />\n        <Form.InputNumber field="age" required name="age" />\n        <Form.RadioGroup field="sex" name="sex">\n          <Form.Radio value="man" />\n          <Form.Radio value="woman" />\n        </Form.RadioGroup>\n        <Form.Select field="hobby" name="hobby">\n          <Form.Select.Option value="code">code</Form.Select.Option>\n          <Form.Select.Option value="read">read</Form.Select.Option>\n        </Form.Select>\n      </Form>\n      <input type="hidden" role="note" value={JSON.stringify(semiFormValues)} />\n    </div>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// ./src/__test__/dom_expect.test.tsx\nimport React from \"react\";\nimport { render, screen } from \"@testing-library/react\";\nimport { DomExpect } from \"../components/DomExpect/index\";\n\ndescribe(\"tests for 《6 | DOM断言:页面元素的断言》\", () => {\n  // ...\n  test('visible validation with semi', () => {\n    render(<DomExpect />);\n    // ...other content\n    const hiddenNotes = screen.getAllByRole('note', { hidden: true });\n    expect(hiddenNotes[2]).toHaveAttribute(\n      'value',\n      JSON.stringify({\n        username: 'zhenmin',\n        age: 23,\n        sex: 'man',\n        hobby: 'code',\n      })\n    );\n  });\n});\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这一节课我们学习了 React Testing Library 给我们提供的断言，从大方向来说，可以分为页面可见、表单验证和代码层面验证三个维度，其中，表单验证可能在我们的业务场景中有频繁的应用，普通的表单和基于 Semi 的表单表现上是有差异的。"}),"\n",(0,r.jsxs)(n.p,{children:["如果有使用 Semi Form 的表单控件，那么验证表单值的时候就不能直接使用",(0,r.jsx)(n.code,{children:"toHaveFormValues"}),"， 因为表单元素的 name 并不会作为属性直接透传。针对这种场景，我最建议大家跳过对值的直接验证，转而直接验证 submit 的结果能否符合预期，如果需要验证值，我们也可以自己加上一个 hidden 表单，进行值的对应。"]}),"\n",(0,r.jsx)(n.p,{children:"到这节课为止，我们对于 DOM 的渲染、查询和断言都有了较深入的了解，但是在业务场景中，除了静态的部分，我们难免会遇到各种各样的用户操作事件，对于这些场景的断言，我们需要能够模拟用户的事件来进行预期的判定。在下节课，我们就来学习怎么对 Dom 组件绑定事件进行模拟触发？"}),"\n",(0,r.jsxs)(n.h2,{id:"1114-更新",children:["11.14 更新",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1114-更新",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["之前提到的 html 默认 name 属性 Semi form 组件不能透传的问题，已经联系 Semi 同学进行修复了，后续我们就可以正常使用 toHaveFormValues 进行表单的断言了，详细的 pull request diff 大家可以参考  ",(0,r.jsx)(n.a,{href:"https://github.com/DouyinFE/semi-design/pull/1266",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/DouyinFE/semi-design/pull/1266"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"后续这个 pull request 会随 2.24-beta 版本一同发布，大家升级至更高的 Semi 版本即可~"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(b,{...e})}):b(e)}let g=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F6.DOM%20%E6%96%AD%E8%A8%80%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%AD%E8%A8%80.md"]={toc:[{text:"页面元素的断言",id:"页面元素的断言",depth:2},{text:"页面可见",id:"页面可见",depth:3},{text:"表单验证",id:"表单验证",depth:3},{text:"代码层面验证",id:"代码层面验证",depth:3},{text:"基于组件库的断言",id:"基于组件库的断言",depth:2},{text:"小结",id:"小结",depth:2},{text:"11.14 更新",id:"1114-更新",depth:2}],title:"6.DOM 断言：页面元素的断言",headingTitle:"6.DOM 断言：页面元素的断言",frontmatter:{}}}}]);