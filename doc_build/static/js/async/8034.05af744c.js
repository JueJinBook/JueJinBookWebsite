"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["8034"],{883116:function(e,n,d){e.exports=d.p+"static/image/114a2c29f62312cd4f1707642f5ee0c5.08803862.webp"},787172:function(e,n,d){d.r(n),d.d(n,{default:()=>m});var c=d(552676),s=d(740453);let i=d.p+"static/image/d27e1c719bc39f30e34bd8699c381b7d.dd8ab63c.webp",r=d.p+"static/image/f291359ca4ccccd3473605b87983a5b6.42359f66.webp",l=d.p+"static/image/dd7cc11b4b511dd96eec7bcb48d5a0c0.07e4507c.webp",t=d.p+"static/image/e9ae80096396155945c66faa1c21060c.91ec6452.webp",a=d.p+"static/image/b859bd5289561732ef4f0912dc885f31.570b265f.webp",o=d.p+"static/image/c9207b98fb7c4880c884f1061cd366e0.1887898c.webp",h=d.p+"static/image/ba9a8c52e7f6e599914a1d633449cc3a.6f0715db.webp",x=d.p+"static/image/0f49c6279f52793af8cedfc74ea19206.2d4eecd0.webp";var p=d(883116);function j(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",h4:"h4",ul:"ul",li:"li",code:"code",pre:"pre",blockquote:"blockquote",strong:"strong"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"32vue3-实战之管理后台左右栏目布局menu-菜单组件",children:["32.Vue3 实战之管理后台左右栏目布局（Menu 菜单组件）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32vue3-实战之管理后台左右栏目布局menu-菜单组件",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我们终于进入了项目实战部分，首先我们先来把整个项目的布局搭建完善，以便后续的业务需求顺利展开。本项目采用左边栏固定宽度，右边栏上中下结构，自适应宽度的布局。"}),"\n",(0,c.jsx)(n.p,{children:"布局样式如下图所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"如上图所示，“头部”和“底部”的部分，是固定的，中间“内容”部分为可滚动块。这样的布局在生产环境中很常见，掌握这个布局的基础搭建和代码实现，之后融汇贯通、举一反三，可以大大提升你的布局能力。"}),"\n",(0,c.jsxs)(n.h4,{id:"本章节知识点",children:["本章节知识点",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章节知识点",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["需要注册的组件：",(0,c.jsx)(n.code,{children:"ElContainer"}),"、",(0,c.jsx)(n.code,{children:"ElAside"}),"、",(0,c.jsx)(n.code,{children:"ElMenu"}),"、",(0,c.jsx)(n.code,{children:"ElSubMenu"}),"、",(0,c.jsx)(n.code,{children:"ElMenuItemGroup"}),"、",(0,c.jsx)(n.code,{children:"ElMenuItem"}),"。"]}),"\n",(0,c.jsx)(n.li,{children:"Flex 布局的使用。"}),"\n",(0,c.jsx)(n.li,{children:"路由监听事件。"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"入口页布局",children:["入口页布局",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#入口页布局",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["像上图这样的布局，左侧有公共导航栏部分，基本上是逃不开在 ",(0,c.jsx)(n.code,{children:"App.vue"})," 内做文章。"]}),"\n",(0,c.jsxs)(n.p,{children:["之前在搭建环境章节中，我们已经讲过，",(0,c.jsx)(n.code,{children:"<router-view>"})," 标签是用于放置 ",(0,c.jsx)(n.code,{children:"views"})," 文件夹下的页面组件，如果我们想实现公共侧边栏，就必须和 ",(0,c.jsx)(n.code,{children:"<router-view>"})," 同级，否则你就得在每一个 ",(0,c.jsx)(n.code,{children:"views"})," 下的页面级组件内都写上一套侧边栏。这样做的话，代码就非常累赘，且不易维护，一旦想修改侧边栏的样式或结构，你得在每一个页面组件内去修改。提取出来后，便可只修改一个地方，这便是提取公共组件的好处。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们进入 ",(0,c.jsx)(n.code,{children:"App.vue"})," 脚本，添加如下内容："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'<template>\n  <div class="layout">\n    <el-container class="container">\n      <el-aside class="aside">\n        \x3c!--系统名称+logo--\x3e\n        <div class="head">\n          <div>\n            <img src="//s.weituibao.com/1582958061265/mlogo.png" alt="logo">\n            <span>vue3 admin</span>\n          </div>\n        </div>\n        \x3c!--一条为了美观的线条--\x3e\n        <div class="line" />\n        <el-menu\n          background-color="#222832"\n          text-color="#fff"\n        >\n          \x3c!--一级栏目--\x3e\n          <el-sub-menu index="1">\n            <template #title>\n              <span>Dashboard</span>\n            </template>\n            \x3c!--二级栏目--\x3e\n            <el-menu-item-group>\n              <el-menu-item><el-icon><DataLine /></el-icon>系统介绍</el-menu-item>\n            </el-menu-item-group>\n          </el-sub-menu>\n        </el-menu>\n      </el-aside>\n    </el-container>\n  </div>\n  <router-view></router-view>\n</template>\n\n<script>\nexport default {\n  name: \'App\'\n}\n<\/script>\n\n<style scoped>\n.layout {\n  min-height: 100vh;\n  background-color: #ffffff;\n}\n.container {\n  height: 100vh;\n}\n.aside {\n  width: 200px!important;\n  background-color: #222832;\n}\n.head {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 50px;\n}\n.head > div {\n  display: flex;\n  align-items: center;\n}\n\n.head img {\n  width: 50px;\n  height: 50px;\n  margin-right: 10px;\n}\n.head span {\n  font-size: 20px;\n  color: #ffffff;\n}\n.line {\n  border-top: 1px solid hsla(0,0%,100%,.05);\n  border-bottom: 1px solid rgba(0,0,0,.2);\n}\n</style>\n\n<style>\nbody {\n  padding: 0;\n  margin: 0;\n  box-sizing: border-box;\n}\n</style>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["上述代码已添加相应的注释，每段 ",(0,c.jsx)(n.code,{children:"div"})," 的作用都已在代码中体现，接下来我们看看效果如何，如下图所示："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"左侧栏目的样式已经初步形成，除了完成了页面样式之外，点击左边栏需要触发路由的变化，比如点击“系统介绍”，地址栏变化的同时右侧视图也应该随之变化。"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"el-menu"})," 组件有一个 ",(0,c.jsx)(n.code,{children:"router"})," 属性，它的作用是："]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["默认状态下，",(0,c.jsx)(n.code,{children:"router"})," 属性是 ",(0,c.jsx)(n.code,{children:"false"})," 状态，所以我们先开启它，代码修改如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-diff",children:'...\n <el-menu\n  background-color="#222832"\n  text-color="#fff"\n+  :router="true"\n >\n...\n'})}),"\n",(0,c.jsxs)(n.p,{children:["然后我们再添加 ",(0,c.jsx)(n.code,{children:"el-menu-item"})," 的 ",(0,c.jsx)(n.code,{children:"index"})," 属性，代码修改如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-diff",children:'...\n <el-menu-item-group>\n+  <el-menu-item index="/"><el-icon><DataLine /></el-icon>首页</el-menu-item>\n </el-menu-item-group>\n...\n'})}),"\n",(0,c.jsx)(n.p,{children:"重新启动项目，浏览器展示如下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Index.vue"})," 组件内容，变到页面下方去了，原因就是代码中还没有对右侧做布局。"]}),"\n",(0,c.jsxs)(n.p,{children:["继续在 ",(0,c.jsx)(n.code,{children:"App.vue"})," 下添加代码，在 ",(0,c.jsx)(n.code,{children:"el-aside"})," 同级下方，添加 ",(0,c.jsx)(n.code,{children:"el-container"})," 组件，如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'<el-aside>\n</el-aside>\n\x3c!--右边内容布局--\x3e\n<el-container class="content">\n  <div class="main">\n    \x3c!--将 <router-view></router-view> 移到这里，并且用单标签--\x3e\n    <router-view />\n  </div>\n</el-container>\n\n <style scoped>\n  ...\n  .content {\n    display: flex;\n    flex-direction: column;\n    max-height: 100vh;\n    overflow: hidden;\n  }\n  .main {\n    height: 100vh;\n    overflow: auto;\n    padding: 10px;\n  }\n </style>\n'})}),"\n",(0,c.jsx)(n.p,{children:"效果如下图所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["左右栏布局基本成型，这样的布局在大多数后台管理系统的场景下都非常适用。这里要注意灵活的使用 ",(0,c.jsx)(n.code,{children:"Flex"})," 布局。可以这么说，有了它，你基本上可以抛弃 ",(0,c.jsx)(n.code,{children:"float"})," 浮动布局。目前各大浏览器对 ",(0,c.jsx)(n.code,{children:"Flex"})," 布局的兼容已经做得很好了。这里推荐给大家一个练习 ",(0,c.jsx)(n.code,{children:"Flex"})," 布局的小游戏，过完一遍基本上就会了。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"http://flexboxfroggy.com/#zh-cn",target:"_blank",rel:"noopener noreferrer",children:"http://flexboxfroggy.com/#zh-cn"})}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"右边栏上中下布局",children:["右边栏上中下布局",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#右边栏上中下布局",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["回过头来看开头的原型图，在右侧的内容部分，页面中还缺少头部和底部的两个区域没有制作，这里就会涉及到公共组件的编写，我们在 ",(0,c.jsx)(n.code,{children:"components"})," 文件夹新建一个 ",(0,c.jsx)(n.code,{children:"Header.vue"}),"，内容如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'\x3c!--Header.vue--\x3e\n<template>\n  <div class="header">\n    <div class="left">左</div>\n    <div class="right">右</div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'Header\'\n}\n<\/script>\n\n<style scoped>\n  .header {\n    height: 50px;\n    border-bottom: 1px solid #e9e9e9;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0 20px;\n  }\n</style>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["代码中给一个 ",(0,c.jsx)(n.code,{children:"50px"})," 的高度，和左边栏的 logo 高度保持一致，这样更加协调一些，具体大小可自己控制。头部左右布局，上下居中，我们使用如下代码："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-css",children:"display: flex;\njustify-content: space-between;\nalign-items: center;\n"})}),"\n",(0,c.jsx)(n.p,{children:"这样的布局在后续的开发中会大量用到，同学们注意一下，后续就不赘述了。"}),"\n",(0,c.jsxs)(n.p,{children:["同样的，在 ",(0,c.jsx)(n.code,{children:"components"})," 再新建一个底部组件 ",(0,c.jsx)(n.code,{children:"Footer.vue"}),"，内容如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'\x3c!--Footer.vue--\x3e\n<template>\n  <div class="footer">\n    <div class="left">Copyright \xa9 2019-2021 十三. All rights reserved.</div>\n    <div class="right">\n      <a target="_blank" href="https://github.com/newbee-ltd/vue3-admin">vue3-admin Version 3.0.0</a>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: \'Footer\'\n}\n<\/script>\n\n<style scoped>\n  .footer {\n    height: 50px;\n    border-top: 1px solid #e9e9e9;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 0 20px;\n  }\n</style>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["接下来在 ",(0,c.jsx)(n.code,{children:"App.vue"})," 中引入 ",(0,c.jsx)(n.code,{children:"Header.vue"})," 和 ",(0,c.jsx)(n.code,{children:"Footer.vue"})," 组件，如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-diff",children:"\n <el-container class=\"content\">\n+  <Header />\n  <div class=\"main\">\n    <router-view />\n  </div>\n+  <Footer />\n </el-container>\n\n <script>\n+  import Header from '@/components/Header.vue'\n+  import Footer from '@/components/Footer.vue'\n <\/script>\n\nexport default {\n  name: 'App',\n  components: {\n+    Header,\n+    Footer\n  },\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"添加完后，页面如下所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"如此，便基本上实现了页面右侧的上-中-下的布局。"}),"\n",(0,c.jsxs)(n.p,{children:["我们还差一步，就是中间 ",(0,c.jsx)(n.code,{children:"main"})," 的内容高度之前是 ",(0,c.jsx)(n.code,{children:"100vh"}),"，添加 ",(0,c.jsx)(n.code,{children:"Header"})," 和 ",(0,c.jsx)(n.code,{children:"Footer"})," 之后，",(0,c.jsx)(n.code,{children:"main"})," 的高度应该是 ",(0,c.jsx)(n.code,{children:"100vh - 100px"}),"，所以在 ",(0,c.jsx)(n.code,{children:"App.vue"})," 的样式处做如下代码修改："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-diff",children:".main {\n-  height: 100vh;\n+  height: calc(100vh - 100px);\n  overflow: auto;\n  padding: 10px;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"这样的话，页面中的内容撑开后不会有一部分被挡着，如下所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["整个项目的布局部分就基本确定了，后续同学们可以根据自己的需要，在 ",(0,c.jsx)(n.code,{children:"App.vue"})," 上进行结构上的微调。"]}),"\n",(0,c.jsxs)(n.h2,{id:"左边栏切换右侧头部信息联动--路由监听",children:["左边栏切换，右侧头部信息联动 — 路由监听",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#左边栏切换右侧头部信息联动--路由监听",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["现在，我想在 ",(0,c.jsx)(n.code,{children:"Header.vue"})," 的内部，根据路径的变化，来展示相应的页面 ",(0,c.jsx)(n.code,{children:"title"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["比如我点击左边栏的 ",(0,c.jsx)(n.code,{children:"A"})," 菜单，",(0,c.jsx)(n.code,{children:"Header.vue"})," 就显示 ",(0,c.jsx)(n.code,{children:"A"})," 作为 ",(0,c.jsx)(n.code,{children:"title"}),"，原型图如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["想要实现这样的需求，就要涉及到路由监听，在 ",(0,c.jsx)(n.code,{children:"Header.vue"})," 下添加如下代码："]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"template"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-diff",children:' <template>\n  <div class="header">\n    <div class="left">\n+      <span style="font-size: 20px">{{ state.name }}</span>\n    </div>\n    <div class="right">右</div>\n  </div>\n </template>\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"script"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"<script setup>\nimport { reactive, toRefs } from 'vue'\nimport { useRouter } from 'vue-router'\n// 获取路由实例\nconst router = useRouter()\n// 声明路由和 title 对应的键值对\nconst pathMap = {\n  index: '首页',\n  add: '添加商品'\n}\nconst state = reactive({\n  name: '首页'\n})\n// 监听路由变化方法 afterEach\nrouter.afterEach((to) => {\n  console.log('to', to)\n  // to 能获取到路由相关信息。\n  const { id } = to.query\n  state.name = pathMap[to.name]\n})\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["我们来看看 ",(0,c.jsx)(n.code,{children:"to"})," 里面到底有什么内容："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"所有路由相关大属性参数，都在里面，比较有用的参数如下："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["path：路径参数，",(0,c.jsx)(n.code,{children:"#"})," 号后面的路径参数，如首页 ",(0,c.jsx)(n.code,{children:"/"}),"，下面会出现的商品添加页 ",(0,c.jsx)(n.code,{children:"/add"}),"。"]}),"\n",(0,c.jsx)(n.li,{children:"name：这个在定义路由配置的时候，只要你写上，就会是对应的值，下面也会讲到。"}),"\n",(0,c.jsxs)(n.li,{children:["query：浏览器路径上带的查询参数如 ",(0,c.jsx)(n.code,{children:"?id=1"}),"，都会被构建到这里，路径传参的时候会用到它。"]}),"\n",(0,c.jsxs)(n.li,{children:["meta：同样也是在路由配置项里设置，如 ",(0,c.jsx)(n.code,{children:"keepalive"})," 会使用到它。"]}),"\n",(0,c.jsx)(n.li,{children:"params：另一种不在浏览器地址栏上显示的传参形式。"}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"其他参数用到的比较少，等到具体使用到了在做解释。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["之前已经在 ",(0,c.jsx)(n.code,{children:"views"})," 下新建了 ",(0,c.jsx)(n.code,{children:"Index.vue"})," 组件，我们再来新建一个 ",(0,c.jsx)(n.code,{children:"AddGood.vue"})," 组件，用于后续的商品添加功能模块。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--/src/views/AddGood.vue--\x3e\n<template>\n  添加商品\n</template>\n\n<script setup>\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["紧接着我们需要去路由脚本声明一下刚刚添加的组件，打开 ",(0,c.jsx)(n.code,{children:"/src/router/index.js"}),"，如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-diff",children:"+ import AddGood from '@/views/AddGood.vue'\n\nconst router = createRouter({\n  history: createWebHashHistory(), // hash 模式\n  routes: [\n    {\n      path: '/',\n+      name: 'index',\n      component: Index\n    },\n+    {\n+      path: '/add',\n+      name: 'add',\n+      component: AddGood\n+    }\n  ]\n})\n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"注意，每次添加新的页面组件之后，千万不要忘记在 src/router/index.js 路由配置脚本里加上组件的路径配置。刚入行时，我经常会犯这样的低级错误，一头雾水，不知所措。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["我们为上述的路由配置添加一个 ",(0,c.jsx)(n.code,{children:"name"})," 属性，便于获取参数，可以直接进行操作，少写一个 ",(0,c.jsx)(n.code,{children:"/"}),"。这里为什么说少写一个 ",(0,c.jsx)(n.code,{children:"/"})," 呢，我们从 ",(0,c.jsx)(n.code,{children:"router.afterEach"})," 的回调函数中，获取的 ",(0,c.jsx)(n.code,{children:"to"})," 变量，如果是获取 ",(0,c.jsx)(n.code,{children:"path"})," 属性，会带上一个斜杠，如 ",(0,c.jsx)(n.code,{children:"/add"}),"，这样我们在写键值对的时候，也要写成如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"{\n  '/add': '添加商品'\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这里不要小看了多一个 ",(0,c.jsx)(n.code,{children:"/"}),"，哪怕少写一个单词，也是为最后的打包将少体积，在某种程度上，这也是项目优化的一种形式，合抱之木，生于毫末；九层之台，起于垒土。"]}),"\n",(0,c.jsxs)(n.p,{children:["比如 ",(0,c.jsx)(n.code,{children:"CSS"})," 样式的提取，尽量减少重复样式，能公用的尽量公用。写循环的时候尽量使用 ",(0,c.jsx)(n.code,{children:"ES6"})," 的语法，减少代码量，为最后的打包体积作出贡献。"]}),"\n",(0,c.jsxs)(n.p,{children:["组件和路径都配置好了，我们再进入 ",(0,c.jsx)(n.code,{children:"App.vue"})," 页面，进行菜单的配置："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-diff",children:' <el-menu-item-group>\n  <el-menu-item index="/"><el-icon><DataLine /></el-icon>首页</el-menu-item>\n+  <el-menu-item index="/add"><el-icon><DataLine /></el-icon>添加商品</el-menu-item>\n </el-menu-item-group>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["这里解释一下，路径的跳转不一定要通过 ",(0,c.jsx)(n.code,{children:"el-menu-item"})," 的 ",(0,c.jsx)(n.code,{children:"index"})," 属性，我们使用了 ",(0,c.jsx)(n.code,{children:"Element Plus"})," 的菜单组件，顺便就用它内置的路径跳转方法。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们也可以自己实现一个菜单列表，通过 ",(0,c.jsx)(n.code,{children:"Vue-Router"})," 提供的 ",(0,c.jsx)(n.code,{children:"router-link"})," 或者 ",(0,c.jsx)(n.code,{children:"useRouter"})," 返回的实例，进行路由跳转操作。"]}),"\n",(0,c.jsx)(n.p,{children:"我们打开浏览器查看效果如下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"一个项目的布局，非常磨练开发者掌握大局的功底。就像一个房子的地基，房子牢不牢靠，地基是关键。本章节详细的为大家阐述了，如何从 0 开始一个项目布局的搭建，合理地利用组件库的能力，尽量减少模板和样式代码的编写，用尽量少的代码，搭建出一个灵活的布局。"}),"\n",(0,c.jsxs)(n.h4,{id:"本章源码地址",children:["本章源码地址",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章源码地址",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://s.yezgea02.com/1663210179470/admin01.zip",target:"_blank",rel:"noopener noreferrer",children:"点击下载"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"文档最近更新时间：2022 年 9 月 20 日。"}),"\n"]})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(j,{...e})}):j(e)}let m=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F32.Vue3%20%E5%AE%9E%E6%88%98%E4%B9%8B%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%B7%A6%E5%8F%B3%E6%A0%8F%E7%9B%AE%E5%B8%83%E5%B1%80%EF%BC%88Menu%20%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6%EF%BC%89.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"本章节知识点",id:"本章节知识点",depth:4},{text:"入口页布局",id:"入口页布局",depth:2},{text:"右边栏上中下布局",id:"右边栏上中下布局",depth:2},{text:"左边栏切换，右侧头部信息联动 — 路由监听",id:"左边栏切换右侧头部信息联动--路由监听",depth:2},{text:"总结",id:"总结",depth:2},{text:"本章源码地址",id:"本章源码地址",depth:4}],title:"32.Vue3 实战之管理后台左右栏目布局（Menu 菜单组件）",headingTitle:"32.Vue3 实战之管理后台左右栏目布局（Menu 菜单组件）",frontmatter:{}}}}]);