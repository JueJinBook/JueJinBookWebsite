"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["99407"],{152814:function(n,e,i){i.r(e),i.d(e,{default:()=>h});var s=i(552676),r=i(740453);let t=i.p+"static/image/bc24ca59c40c8068ba2a884fa1de1ec5.f402918a.webp",o=i.p+"static/image/0ef81156b167334939a6eb172e94cba3.21b3b8f7.webp",c=i.p+"static/image/f510400f9e5b702e7f11af53665a73cb.ab002d99.webp",l=i.p+"static/image/5f16e524cf4830efdcb1b6414431bf63.0801e9d5.webp",a=i.p+"static/image/20a6d5e2b166f7274ca8dbc3daa77f0c.be72aac2.webp",d=i.p+"static/image/91d76f1009f0af589a134866cab7dba4.999a7f7d.webp";function p(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",pre:"pre",code:"code",img:"img",h4:"h4",ol:"ol",li:"li",blockquote:"blockquote"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"19服务端实战cicd-cli",children:["19.服务端实战：CICD CLI",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#19服务端实战cicd-cli",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在我们初步学习完 ",(0,s.jsx)(e.strong,{children:"NestJS"})," 的相关操作之后，后续将深入低代码的服务端开发，在正式开发服务端之前，本章我们一起学习下如何开发一款服务于 ",(0,s.jsx)(e.strong,{children:"CICD"})," 的 ",(0,s.jsx)(e.strong,{children:"CLI"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["在之前的 ",(0,s.jsx)(e.strong,{children:"CLI"})," 架构设计中，我们需要补充一个新的设定就是流程编排的功能，其次 ",(0,s.jsx)(e.strong,{children:"CLI"})," 将会被分割为两个独立模块 ",(0,s.jsx)(e.strong,{children:"ig-base-cli"})," 与 ",(0,s.jsx)(e.strong,{children:"ig-build-cli"}),"，作为基础 ",(0,s.jsx)(e.strong,{children:"CICD"})," 与构建的 ",(0,s.jsx)(e.strong,{children:"CLI"}),"，实现功能收敛。"]}),"\n",(0,s.jsx)(e.p,{children:"接下来我们将一起看看如何实现设计中的一些功能。"}),"\n",(0,s.jsxs)(e.h2,{id:"开发自定义注册插件功能",children:["开发自定义注册插件功能",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#开发自定义注册插件功能",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"新建批量注册命令行的工具类："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'#!/usr/bin/env node\n\nimport * as path from "path";\nimport alias from "module-alias";\nconst packageConfig = require("../../package.json")\n\nalias(path.resolve(__dirname, "../../"));\n\nimport { Command } from \'commander\';\n\nimport internallyCommand from \'./internally\'\n\nimport { initExtraPack } from \'./extra\'\n\nconst program = new Command(packageConfig.commandName);\n\nexport interface ICommand {\n  description: string\n  command: string\n  action: (value?: any) => void\n}\n\nconst initCommand = (commandConfig: ICommand[]) => {\n  commandConfig.forEach(config => {\n    const { description, command, action } = config\n    program\n      .version(packageConfig.version)\n      .description(description)\n      .command(command)\n      .action((value) => {\n        action(value)\n      })\n  })\n}\n\nconst init = () => {\n  const extraPacks = initExtraPack()\n  initCommand([...internallyCommand, ...extraPacks])\n}\n\ninit()\n\nprogram.parse(process.argv);\n'})}),"\n",(0,s.jsxs)(e.p,{children:["其中 ",(0,s.jsx)(e.strong,{children:"internally"})," 作为内置命令行工具合集，",(0,s.jsx)(e.strong,{children:"extra"})," 则代表拓展命令行合集，此时你的目录结构应该如下所示："]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["内置命令行工具比较简单，首先注册一个 ",(0,s.jsx)(e.code,{children:"Command"}),"："]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"src/bin/register.ts"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"import inquirer from '@/inquirer';\n\nconst { registerPlugin } = inquirer\n\nexport const registerPluginCommand = {\n  description: 'register plugin',\n  command: 'register plugin',\n  action: () => registerPlugin()\n}\n\nexport default [\n  registerPluginCommand\n]\n"})}),"\n",(0,s.jsxs)(e.p,{children:["如何在入口文件：",(0,s.jsx)(e.code,{children:"src/bin/index.ts"})," 引入即可，其他的命令用法类似："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"import build from './build'\nimport tpl from './tpl'\nimport git from './git'\nimport safety from './safety'\nimport register from './register'\nimport utils from './utils'\n\nexport default [\n  ...build,\n  ...safety,\n  ...git,\n  ...tpl,\n  ...register,\n  ...utils\n]\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"所以接下来我们着重讲解拓展命令行工具的模块"}),"。"]}),"\n",(0,s.jsxs)(e.h4,{id:"注册流程",children:["注册流程",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#注册流程",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"简点的注册流程图如下所示："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"输入第三方插件名称"}),"\n",(0,s.jsx)(e.li,{children:"安装依赖"}),"\n",(0,s.jsx)(e.li,{children:"注册完毕等待使用"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["对于主 ",(0,s.jsx)(e.strong,{children:"CLI"})," 来说，不可能接受太个性化、自定义的插件进来，这样会影响 ",(0,s.jsx)(e.strong,{children:"CLI"})," 的结构，所以我们需要对 CLI 插件的模板做一个约束，除了输出的格式与上述内置插件格式保持一致之外，我们还需要对插件名称、依赖等等做一个约束，不过这点可以以提供一个 ",(0,s.jsx)(e.strong,{children:"CLI"})," 插件模板来约定。"]}),"\n",(0,s.jsxs)(e.p,{children:["对于我们的 ",(0,s.jsx)(e.code,{children:"@ignition-space/ig-base-cli"})," 来说，我们将只接受 ",(0,s.jsx)(e.code,{children:"@ignition-space/fe-plugin-***"})," 命名格式的插件进来。这种规则可以根据团队的命名规范来约定，并不是唯一规范。"]}),"\n",(0,s.jsx)(e.p,{children:"所以，添加模板的时候需要做两次校验，第一层校验是通过校验名字，第二层是安装依赖，如果依赖安装失败也不会添加成功。"}),"\n",(0,s.jsxs)(e.p,{children:["插件的命名校验，我们可以通过 ",(0,s.jsx)(e.code,{children:"inquirer"})," 的 ",(0,s.jsx)(e.code,{children:"validate"})," 函数来校验："]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"src/inquirer/registerPlugin.ts"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"import inquirer from 'inquirer';\nimport { existNpm, npmInstall } from '@/util/npm'\nimport { loggerSuccess } from '@/util';\nimport { updatePlugin } from '@/plugin'\n\nconst promptList = [\n  {\n    type: 'input',\n    message: '请输入插件名称:',\n    name: 'pluginName',\n    default: 'ig-plugin-eslint',\n    validate(v: string) {\n      return v.includes('fe-plugin-')\n    },\n    transformer(v: string) {\n      return `@ignition-space/${v}`\n    }\n  }\n];\n\nexport const registerPlugin = () => {\n  inquirer.prompt(promptList).then(async (answers: any) => {\n    const { pluginName } = answers\n    const exist = await existNpm(`@ignition-space/${pluginName}`)\n    if (exist) {\n      npmInstall(`@ignition-space/${pluginName}`)\n      loggerSuccess(`@ignition-space/${pluginName} register successful!`)\n      updatePlugin({ name: `@ignition-space/${pluginName}` })\n    }\n  })\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["在通过组件命令校验之后，可以通过 ",(0,s.jsx)(e.code,{children:"latest-version"})," 来校验是否已经存在发布的包，以免安装失败，注册 ",(0,s.jsx)(e.strong,{children:"command"})," 异常。"]}),"\n",(0,s.jsxs)(e.p,{children:["再校验插件的 ",(0,s.jsx)(e.strong,{children:"npm"})," 包无误之后，继续用 ",(0,s.jsx)(e.strong,{children:"shelljs"})," 来安装插件对应的依赖："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export const npmInstall = async (packageName: string) => {\n  try {\n    shelljs.exec(`yarn add ${packageName}`, { cwd: process.cwd() });\n  } catch (error) {\n    loggerError(error)\n    process.exit(1)\n  }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"同样最后我们需要将注册的插件以文件的形式缓存起来，下一次使用的时候读取配置文件，将插件命令注入，提供给用户使用。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export const updatePlugin = async (params: IPlugin) => {\n  const { name } = params\n  let isExist = false\n  try {\n    const pluginConfig = loadFile<IPlugin[]>(`${cacheTpl}/.plugin.json`)\n    let file = [{ name }]\n    if (pluginConfig) {\n      isExist = pluginConfig.some(tpl => tpl.name === name)\n      if (!isExist) {\n        file = [\n          ...pluginConfig,\n          { name }\n        ]\n      }\n    }\n    writeFile(cacheTpl, '.plugin.json', file)\n    loggerSuccess(`${isExist ? 'Update' : 'Add'} Plugin Successful!`)\n  } catch (error) {\n    loggerError(error)\n  }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"完成上述所有的开发之后，最后我们来执行命令看看效果："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"ig tEslint"})," 是我们从第三方插件注册得来的，可以从上图看到，已经再注册了第三方 ",(0,s.jsx)(e.code,{children:"@ignition-space/ig-plugin-eslint"})," 插件之后，用户已经可以使用通过插件提供的 ",(0,s.jsx)(e.code,{children:"tEslint"})," 命令了。"]}),"\n",(0,s.jsxs)(e.p,{children:["之后就可以让业务同学自行开发想要的插件，丰富 ",(0,s.jsx)(e.strong,{children:"CLI"})," 的插件市场，但是还是需要对插件的模板有一定的规范，随心所欲的结果就是不可控，所以接下来我们进行 ",(0,s.jsx)(e.strong,{children:"CLI"})," 插件模板的开发。"]}),"\n",(0,s.jsxs)(e.h4,{id:"cli-插件模板",children:["CLI 插件模板",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#cli-插件模板",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["插件模板最大的约束只有暴露出与内置命令一样的 ",(0,s.jsx)(e.strong,{children:"command"})," 注册配置，这样可以让开发第三方插件的同学有最大程度功能自定义化。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import { getEslint } from './eslint'\n\nexport const execEslint = async () => {\n  await getEslint()\n}\n\nexport const eslintCommand = {\n  version: '0.1.0',\n  description: 'start eslint and fix code',\n  command: 'tEslint',\n  action: () => execEslint()\n}\n\nexport default [\n  eslintCommand\n]\n\nmodule.exports = eslintCommand\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["这里我是直接迁移了 ",(0,s.jsx)(e.strong,{children:"CLI"})," 的命令，",(0,s.jsx)(e.code,{children:"package.json"})," 里面 ",(0,s.jsx)(e.code,{children:"bin"})," 字段是可以在全局安装完毕之后继续使用 ",(0,s.jsx)(e.code,{children:"eslint"})," 的命令，而在 ",(0,s.jsx)(e.code,{children:"main"})," 的属性中定义了 ",(0,s.jsx)(e.code,{children:"lib/index.js"})," 是为了能在 ",(0,s.jsx)(e.strong,{children:"CLI"})," 命令入口的时候 ",(0,s.jsx)(e.code,{children:"require"})," 对应的注册配置。"]}),"\n",(0,s.jsxs)(e.h4,{id:"版本检测",children:["版本检测",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#版本检测",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在注册插件的时候，我们也是利用了 ",(0,s.jsx)(e.code,{children:"latest-version"})," 检测是否在 ",(0,s.jsx)(e.strong,{children:"npm"})," 上存在版本来判断 ",(0,s.jsx)(e.strong,{children:"npm"})," 包能否正常下载，它本身的功能是检测 ",(0,s.jsx)(e.strong,{children:"npm"})," 包是否是最新的，如果不是最新的话，可以选择更新当前版本。"]}),"\n",(0,s.jsxs)(e.p,{children:["同时也可以选择性在项目启动的时候就检测一遍版本，例如当 ",(0,s.jsx)(e.strong,{children:"npm"})," 包版本出现 ",(0,s.jsx)(e.strong,{children:"break change"}),"，只有强制更新才能继续使用功能，不过这种配置需要看当前业务需求，比如内置命令有重大更新必须 ",(0,s.jsx)(e.strong,{children:"CLI"})," 升级之后才能使用的情况。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import { loggerInfo, loggerWarring } from '@/util';\nconst packageInfo = require('../../package.json');\nimport latestVersion from 'latest-version';\n\nconst parseVersion = (ver: string) => {\n  return ver.split('.').toString()\n}\n\nexport const checkVersion = async () => {\n  const latestVer = await latestVersion('@ignition-space/ig-base-cli');\n  if (parseVersion(latestVer) > parseVersion(packageInfo.version)) {\n    loggerWarring(`The current version is the :  ${latestVer}`)\n  } else {\n    loggerInfo('The current version is the latest:')\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"流程编排",children:["流程编排",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#流程编排",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["与其他的 ",(0,s.jsx)(e.strong,{children:"CLI"})," 不同的是，我们的 ",(0,s.jsx)(e.strong,{children:"base-cli"})," 也提供了类型 ",(0,s.jsx)(e.strong,{children:"GitLab CI yaml"})," 的配置流程模式，只不过我们的组合模式会更加自由。"]}),"\n",(0,s.jsx)(e.p,{children:"首先，我们定义一下流程构建的具体代码："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"src/build/index.ts"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { ConfigExist, loadTsConfig } from "@/util/file"\n\nimport shelljs from \'shelljs\'\n\nimport TaskQueue from "@/util/taskQueue"\nimport { loggerInfo } from "@/util"\n\nconst buildFlow = async () => {\n  const taskQueue = new TaskQueue()\n  const exist = ConfigExist("ig.config.ts")\n\n  let buildConfig: any = {}\n  if (exist) {\n    buildConfig = loadTsConfig("ig.config.ts")\n  }\n\n  // If flow is detected, execute process orchestration\n  if (buildConfig.flow) {\n    const { flow } = buildConfig\n\n    if (flow.preHook) {\n      loggerInfo(`stage.preHook==>${flow.preHook}`)\n      await shelljs.exec(flow.preHook)\n    }\n\n    // Add task into queue\n    flow?.stages.forEach((stage: any) => {\n      if (flow[stage].script) {\n        loggerInfo(`stage.script==>${flow[stage].script}`)\n        taskQueue.enqueue(async () => {\n\n          if (flow[stage].preHook) {\n            await shelljs.exec(flow[stage].preHook)\n          }\n\n          await shelljs.exec(flow[stage].script)\n\n          if (flow[stage].doneHook) {\n            await shelljs.exec(flow[stage].doneHook)\n          }\n        })\n      }\n    })\n\n    if (flow.doneHook) {\n      taskQueue.enqueue(async () => {\n        loggerInfo(`stage.doneHook==>${flow.doneHook}`)\n        await shelljs.exec(flow.doneHook)\n      })\n    }\n\n    // Execute queue\n    taskQueue.start()\n  }\n}\n\nexport {\n  buildFlow\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"其次暴露对应的命令："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"src/bin/internally/build.ts"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import { buildFlow } from \"@/build\"\n\nexport const BuildFlowCommand = {\n  description: 'buildFlow',\n  command: 'buildFlow',\n  action: () => buildFlow()\n}\n\nexport default [\n  BuildFlowCommand\n]\n"})}),"\n",(0,s.jsx)(e.p,{children:"接下来我们要能够读取实际项目中的配置文件："}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"ig.config.ts"})," 此文件将放在所需项目中的根目录下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export default {\n  flow: {\n    preHook: 'echo preHook all',\n    stages: [\"build\", \"publish\"],\n    build: {\n      preHook: 'echo preHook build',\n      script: 'echo build'\n    },\n    publish: {\n      script: 'echo publish',\n      doneHook: 'echo doneHook publish',\n    },\n    doneHook: 'echo doneHook all',\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["由于配置文件格式为 ",(0,s.jsx)(e.strong,{children:"ts"}),"，需要我们在加载的时候需要借助 ",(0,s.jsx)(e.code,{children:"ts-node"})," 来解析它。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"src/util/file.ts"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'/**\n * @description: 解析 ts 配置文件\n * @param {string} path\n * @param {string} fileName\n * @param {string} file\n * @return {*}\n */\nexport const loadTsConfig = (path: string) => {\n  // 读取并解析 TypeScript 配置文件\n  const configPath = getDirPath("../../tsconfig.json");\n\n  // 读取并解析 TypeScript 配置文件\n  // 注册 ts-node\n  register({\n    project: configPath,\n  });\n\n  // 加载并执行你的 TypeScript 配置文件\n  const config = require(getCwdPath(path)).default;\n\n  // 处理配置文件的逻辑\n  return config\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"接下来运行流程编排的命令："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"ig buildFlow\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"流程编排的价值在于，可以让用户使用最擅长的语言来执行脚本，并且可以自由组合每一个步骤，当然目前的代码作为实际生产来使用还欠缺很大的火候，后期在整体开发中会逐步完成这个生态结构。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"写在最后",children:["写在最后",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#写在最后",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"由于篇幅所限，本章的内容摘取了部分主要的功能以及部分关键的代码实现，所以单独看本章的内容可能难以实现所有的功能，此时需要配合项目实际功能来对照学习。"}),"\n",(0,s.jsxs)(e.p,{children:["以下是 ",(0,s.jsx)(e.a,{href:"https://github.com/Ignition-Space/ig-base-cli",target:"_blank",rel:"noopener noreferrer",children:"ig-base-cli"})," 以及 ",(0,s.jsx)(e.a,{href:"https://github.com/Ignition-Space/ig-build-cli",target:"_blank",rel:"noopener noreferrer",children:"ig-build-cli"})," 的仓库，后续也会继续更新，可以关注下。"]}),"\n",(0,s.jsx)(e.p,{children:"如果你有什么疑问，欢迎在评论区提出或者加群沟通。 \uD83D\uDC4F"})]})}function g(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}let h=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F19.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9ACICD%20CLI.md"]={toc:[{text:"开发自定义注册插件功能",id:"开发自定义注册插件功能",depth:2},{text:"注册流程",id:"注册流程",depth:4},{text:"CLI 插件模板",id:"cli-插件模板",depth:4},{text:"版本检测",id:"版本检测",depth:4},{text:"流程编排",id:"流程编排",depth:2},{text:"写在最后",id:"写在最后",depth:2}],title:"19.服务端实战：CICD CLI",headingTitle:"19.服务端实战：CICD CLI",frontmatter:{}}}}]);