"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["63095"],{22271:function(n,e,s){s.r(e),s.d(e,{default:()=>h});var r=s(552676),l=s(740453);let a=s.p+"static/image/e298bac58f0a49adb390bf2d73c690f0~tplv-k3u1fbpfcp-zoom-1.image.e25a2130.png";function i(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",ul:"ul",li:"li",pre:"pre",code:"code",img:"img",h3:"h3"},(0,l.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"22-面向对象-vs-函数式软件复杂度问题的两种解法",children:["22 面向对象 vs 函数式：软件复杂度问题的两种解法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#22-面向对象-vs-函数式软件复杂度问题的两种解法",children:"#"})]}),"\n",(0,r.jsxs)(e.h2,{id:"前言",children:["前言",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["经过 20 多节的学习，此刻的大家已经对函数式编程有了全方位、多角度的理解。这里也是时候收回我在",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175421412176789565",target:"_blank",rel:"noopener noreferrer",children:"第2节"}),"留下的伏笔，和大家聊聊 FP vs OOP 这个话题了。"]}),"\n",(0,r.jsx)(e.p,{children:"面向对象编程（Object Oriented Programming，简称OOP）和函数式编程（Functional Programming，简称 FP）与其说是两种不同的范式，倒不如说是两门不同的“宗派”。“OOP 和 FP 谁更牛x”这样的问题，与其说是技术问题，不如说是品味问题、信仰问题。"}),"\n",(0,r.jsx)(e.p,{children:"在我看来，FP 和 OOP 是两种截然不同的软件世界观。无论是辩证地看待两种世界观，还是单纯地“信仰”其中某一种，都需要建立在充分理解和掌握两者的前提上。"}),"\n",(0,r.jsx)(e.p,{children:"遗憾的是，在我们所生存的现实世界中，OOP 往往主宰了很多开发者的思维。当你手里只有一把锤子的时候，你看什么都像钉子。这就好像一个人一生只见过一种世界观、也只能理解这一种世界观，由于他不听、不看、不思考任何其它的世界观，于是只能被迫地狂热痴迷这唯一的一种世界观，这就谈不上信仰与否，而是被世界观所奴役了。"}),"\n",(0,r.jsxs)(e.h2,{id:"软件复杂度问题的两种解法",children:["软件复杂度问题的两种解法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#软件复杂度问题的两种解法",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["作为两种截然不同的软件世界观，FP 和 OOP 的差异是巨大的，巨大到我一时间不知道如何下笔。但话说回来，两者的效用却又是高度一致的，",(0,r.jsx)(e.strong,{children:"它们都能够帮助我们解决软件复杂度的问题"}),"。顺着“降低软件复杂度”这个方向去思考，我最想和大家探讨的其实是以下两个话题："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"抽象"}),"：OOP 将数据与行为打包抽象为对象，对象是一等公民；而 FP 将行为抽象为函数，数据与行为是分离的，函数是一等公民。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"代码重用"}),"：OOP 的核心在于继承，而 FP 的核心在于组合。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"为了能把这两个话题讲透，我们先上“教具”，一起去看两个业务中的例子。"}),"\n",(0,r.jsxs)(e.h2,{id:"用-fp-解决业务问题",children:["用 FP 解决业务问题",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#用-fp-解决业务问题",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"李雷是网课平台的一个开发，最近他接到了这样一个需求："}),"\n",(0,r.jsx)(e.p,{children:"为网课平台增加一个“一键注册我所喜欢的课程”功能：“注册”意味着用户加入了某个课程，“喜欢”则是一个类似于收藏的功能。用户在“喜欢”了一些课程之后，执行“注册”即可成为这些课程的学员；“注册”执行完毕后，需要及时地从用户的喜欢列表中清除这些课程；在清除完成后，还需要及时检查这个用户的注册课程总数，若总数超过10门课，则标识该用户为 VIP 客户。"}),"\n",(0,r.jsx)(e.p,{children:"我们简单捋一下这个需求的流程，它是这样的："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"用户 -> 喜欢课程 -> 注册课程 -> 清除喜欢列表 -> 检查是否 VIP -> 结束\n"})}),"\n",(0,r.jsx)(e.p,{children:"整个过程并不复杂，我们可以用 FP 求解如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// mock一个测试用户：李雷\nconst user = {\n  // 姓名\n  name: 'Li Lei',\n  // 喜欢列表\n  likedLessons: [],\n  // 注册列表\n  registeredLessons: [],\n  // VIP 标识\n  isVIP: false\n}\n// mock一套测试课程  \nconst myLessons = [\n  {\n    teacher: 'John',\n    title: 'advanced English'\n  }, {\n    teacher: 'John',\n    title: 'advanced Spanish'\n  }\n]\n\n\n// ”喜欢课程“功能函数\nfunction likeLessons(user, lessons) {\n  const updatedLikedLessons = user.likedLessons.concat(lessons)\n  return Object.assign(\n    {}, \n    user, \n    {likedLessons: updatedLikedLessons}\n  );\n}\n\n// “注册课程”功能函数\nfunction registerLessons(user) {\n  return {\n    ...user,\n    registeredLessons: user.likedLessons\n  };\n}\n\n// “清空喜欢列表”功能函数\nfunction emptyUserLiked(user) {\n  return {\n    ...user,\n    likedLessons: []\n  };\n}\n\n// “检查是否 VIP”功能函数\nfunction isVIP(user) {\n  let isVIP = false\n  if(user.registeredLessons.length > 10) {\n    isVIP = true\n  }\n  return  {\n    ...user,\n    isVIP\n  }\n}\n\n// 注意，这个 pipe 函数和 14 节中的有些区别，这也是一种常见的实现思路\nconst pipe  = (...funcs) => funcs.reduce(\n  // 同样是基于 reduce 实现，主要的区别在于对组合链入参的处理不同\n  (f, g) => (...args) => g(f(...args))\n);\n\npipe(\n  likeLessons,\n  registerLessons,\n  emptyUserLiked,\n  isVIP,\n  // 这个 pipe 竟然可以接收多个入参，为什么呢？当然是因为“对组合链入参的处理不同”啦！\n)(user, myLessons)\n"})}),"\n",(0,r.jsx)(e.p,{children:"用 mock 数据测试一下，结果符合预期："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"这个例子用意何在，我们先按下不表。趁着写代码的手感还在，赶紧去看下一个业务场景。"}),"\n",(0,r.jsxs)(e.h2,{id:"用-oop-解决业务问题",children:["用 OOP 解决业务问题",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#用-oop-解决业务问题",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"过了一段时间，李雷的老板发现，网课平台太难做了，打算换个赛道，做游戏。于是，李雷华丽转身，成为了一名游戏开发。"}),"\n",(0,r.jsx)(e.p,{children:"他接手的项目是一款运动游戏。在这款游戏里，玩家可以选择成为任何一种类型的运动选手，包括篮球、足球、网球、羽毛球等等。每一种类型的选手都有他们各自的一些绝技（比如篮球选手可以灌篮，足球选手可以射门）。"}),"\n",(0,r.jsx)(e.p,{children:"当然啦，以上这些都是很常规的运动，没有什么卖点。这个游戏真正的卖点在于它的隐藏款运动员——“疯狂号选手“。这个选手的特别之处在于他可以定制自己皮肤的颜色，并且随时都能飞！更重要的是，想成为疯狂号选手，得充钱！每飞一次，都会扣钱。要想一直飞，就得一直充！"}),"\n",(0,r.jsx)(e.p,{children:"这设定，投资人听了还不喜上眉梢？晚上做梦都得笑醒啊！"}),"\n",(0,r.jsx)(e.p,{children:"这个美妙的游戏，用 OOP 实现如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// Player 是一个最通用的基类\nclass Player {\n    // 每位玩家入场前，都需要给自己起个名字，并且选择游戏的类型\n    constructor(name, sport) {\n        this.name = name;\n        this.sport = sport;\n    }\n\n    // 每位玩家都有运动的能力 \n    doSport() {\n        return 'play' + this.sport\n    }\n}\n\n// 篮球运动员类，是基于 Player 基类拓展出来的\nclass BasketballPlayer extends Player {\n    constructor(name) {\n        super(name, 'basketball')\n    }\n\n    // 这是一个灌篮方法\n    slamDunk() {\n        return `${this.name} just dunked a basketball`\n    }\n    \n    // 这是一个跳跃方法\n    jump() {\n      return `${this.name} is jumping!`\n    }\n}\n\n// 足球运动员类，也基于 Player 基类拓展出来的\nclass FootballPlayer extends Player {\n    constructor(name) {\n        super(name, 'football')\n    }\n\n    // 这是一个射门方法\n    shot() {\n        return `${this.name} just shot the goal`\n    }\n    \n    // 这是一个冲刺跑方法\n    runFast() {\n        return `${this.name} is running fast!`\n    }\n}\n\n// 疯狂号运动员，也是基于 Player 基类拓展出来的\nclass CrazyPlayer extends Player {\n    // 疯狂号运动员可定制的属性多出了 color 和 money\n    constructor(name, sport, color, money) {\n        super(name, sport)\n        this.color = color\n        this.money = money\n    }\n\n    // 这是一个飞翔方法\n    fly() {\n        if(this.money > 0) {\n            // 飞之前，先扣钱\n            this.money--\n            // 飞起来啦，好帅呀！\n            return `${this.name} is flying!So handsome!`\n        }\n        // this.money <= 0，没钱还想飞，你也配？（狗头\n        return 'you need to give me money'\n    }\n}\n\n// 创建一个篮球运动员 Bob\nconst Bob = new BasketballPlayer('Bob')\n// 'Bob just dunked a basketball'\nBob.slamDunk()\n// 创建一个足球运动员 John\nconst John = new FootballPlayer('John')\n// 'John just shot the goal'\nJohn.shot()   \n\n// 创建一个红色皮肤的疯狂号选手xiuyan，并充了1块钱\nconst xiuyan = new CrazyPlayer('xiuyan', 'basketball', 'red', 1)\n// 'xiuyan is flying!So handsome!'\nxiuyan.fly()\n// money 归 0 了\nxiuyan.money\n// 'you need to give me money'\nxiuyan.fly()\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"抽象谁是一等公民",children:["抽象：谁是一等公民",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#抽象谁是一等公民",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"以楼上的两个业务场景为蓝本，我们首先要讨论的是“抽象”这个话题。"}),"\n",(0,r.jsx)(e.p,{children:"我忍不住想问大家：如果楼上的两个案例，我没有限定它们各自的解法，你会用 FP 实现，还是会用 OOP 实现呢？"}),"\n",(0,r.jsxs)(e.p,{children:["在网课的案例中，我之所以倾向于使用 FP 求解，是因为这是一个",(0,r.jsx)(e.strong,{children:"重行为、轻数据结构"}),"的场景；在游戏的案例中，我之所以倾向使用 OOP 求解，是因为这是一个",(0,r.jsx)(e.strong,{children:"重数据结构、轻行为"}),"的场景。"]}),"\n",(0,r.jsxs)(e.h3,{id:"fp函数是一等公民",children:["FP：函数是一等公民",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#fp函数是一等公民",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在 FP 的世界里，函数是绝对的主角。"}),"\n",(0,r.jsxs)(e.p,{children:["以网课需求为例，它是一个典型的",(0,r.jsx)(e.strong,{children:"动词"}),"占据主导的需求：喜欢、注册、清空、检查......全都是对行为的描述，显然，这是一个行为密集型的需求。并且需求中的数据源 ",(0,r.jsx)(e.code,{children:"user"})," 是清晰的、确定的。整个功能流程梳理下来，其实是一个点对点的数据转换过程。这样的场景，用 FP 求解是再舒服不过的。"]}),"\n",(0,r.jsxs)(e.p,{children:["FP 构造出的程序，就像一条长长的管道。管道的这头是源数据，管道的那头是目标数据——数据本身是清晰的、确定的、不可变的。",(0,r.jsx)(e.strong,{children:"数据不是主角，那些围绕数据展开的行为才是主角。“行为”也就是函数"}),"，一个小的行为单元，就仿佛是一根小小的管道。我们关心的，是如何把一节一节简单的小管道组合起来，进而得到一个复杂的、功能强大的大管道。"]}),"\n",(0,r.jsxs)(e.h3,{id:"oop对象是一等公民",children:["OOP：对象是一等公民",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#oop对象是一等公民",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["OOP 思想起源于对自然界的观察和抽象，它是对现实世界的一种隐喻。“类”的概念在我们生活中本来就很常见，图书馆的书籍分类、生物学的“界门纲目科属种”、社会上对不同职业不同身份的人的分类等等......这些都是在",(0,r.jsx)(e.strong,{children:"通过寻找事物之间的共性，来抽象出对一类事物的描述"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["既然描述的是【事物】，那么 OOP 的世界毫无疑问是一个",(0,r.jsx)(e.strong,{children:"名词"}),"占据主导的世界。在 OOP 的语境下，我们关注的不是一个个独立的函数单元，而是一系列有联系的属性和方法。",(0,r.jsx)(e.strong,{children:"我们把相互联系的属性和方法打包，抽象为一个“类”数据结构"}),"。当我们思考问题的时候，",(0,r.jsx)(e.strong,{children:"我们关注的不是行为本身，而是谁做了这个行为，谁和谁之间有着怎样的联系"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["以游戏场景为例：在游戏的过程中，选手这个角色存在着大量可能的变体；不同的选手之间还会有大量的关系逻辑需要考虑；在每个选手的内部，还会维护自己独有的状态信息（比如",(0,r.jsx)(e.code,{children:"CrazyPlayer"}),"的余额信息）。此时，摆在我们面前的不再是一个个平行的数据管道，而是一张复杂交错的实体关系网。这样的业务场景下，用 OOP 建模会更加贴合我们人类的思维习惯——毕竟，OOP 本身也是对现实世界的一种隐喻嘛！"]}),"\n",(0,r.jsxs)(e.h2,{id:"代码重用组合-vs-继承",children:["代码重用：组合 vs 继承",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码重用组合-vs-继承",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422922192846907",target:"_blank",rel:"noopener noreferrer",children:"第14节"}),"我们说过，面向对象（OOP）的核心在于继承，而函数式编程（FP）的核心在于组合。"]}),"\n",(0,r.jsxs)(e.p,{children:["本节的两个编码案例中，FP 案例借助 ",(0,r.jsx)(e.code,{children:"pipe"})," 函数实现了函数组合，OOP 案例借助 ",(0,r.jsx)(e.code,{children:"extends"})," 关键字实现了类的继承。我们可以看到：组合的过程是一个两两结合、聚沙成塔的过程；而继承则意味着子类在父类的基础上重写/增加一些内容，通过创造一个新的数据结构来满足的新的需求。"]}),"\n",(0,r.jsx)(e.p,{children:"组合和继承之间的争论，和 OOP 与 FP 之间的争论一样，是一个相当沉重的话题。相比“技术问题”来说，它更像是一个“宗教问题”。 比起孰是孰非，我更想探讨的，是如何运用两者的优势，写出更加可靠的代码。"}),"\n",(0,r.jsxs)(e.p,{children:["基于此，我想要引导大家去思考这样一个问题：",(0,r.jsx)(e.strong,{children:"继承是不是一个好的代码重用思路"}),"？"]}),"\n",(0,r.jsxs)(e.h3,{id:"继承的问题",children:["继承的问题",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#继承的问题",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在我看来，继承当然可以帮我们达到重用的目的，但它称不上“好”。"}),"\n",(0,r.jsx)(e.p,{children:"我们知道，子类和父类之间的关系，是一种紧耦合的关系——父类的任何变化，都将直接地影响到子类。而当我们定义父类的时候，其实并不能预测到未来的变化，无法预测这个父类未来会变成什么样子。借助继承来实现代码重用时，我们总是需要非常小心——我们修改任何一个类的时候，都要考虑它是否会对其它的类带来意料之外的影响。而当继承层次过深的时候，这份”小心“往往使得我们寸步难行。"}),"\n",(0,r.jsx)(e.p,{children:"在 OOP 的语境下，我们解决“继承滥用”问题的一个重要方法，就是引入“组合”思想。"}),"\n",(0,r.jsxs)(e.h3,{id:"为-oop-引入组合思想",children:["为 OOP 引入“组合”思想",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为-oop-引入组合思想",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"以楼上的游戏案例为蓝本。我们目前已经创造了三个 Class，它们分别是："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["BasketballPlayer：篮球选手，会灌篮（ ",(0,r.jsx)(e.code,{children:"slamdunk()"})," ) ，会跳跃（ ",(0,r.jsx)(e.code,{children:"jump()"})," )"]}),"\n",(0,r.jsxs)(e.li,{children:["FootballPlayer：足球选手，会射门( ",(0,r.jsx)(e.code,{children:"shot()"})," ），会狂奔（ ",(0,r.jsx)(e.code,{children:"runFast()"})," ）"]}),"\n",(0,r.jsxs)(e.li,{children:["CrazyPlayer：疯狂号选手，会飞（ ",(0,r.jsx)(e.code,{children:"fly()"})," ）"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"游戏版本的迭代总是很快的。没过几天，李雷的老板坐不住了，他嫌疯狂号选手赚钱不够快。怎么办呢？升级！升级一个大满贯选手，它既能灌篮、又能射门、还会飞。有这么多神技能，就不怕没人愿意充钱啦！"}),"\n",(0,r.jsxs)(e.p,{children:["但是请注意，这个大满贯选手（",(0,r.jsx)(e.code,{children:"SuperPlayer"}),"）只需要具备那些最酷炫的能力：比如它只需要篮球选手的“灌篮”能力，不需要“跳跃”能力；它只需要足球选手的“射门”能力，不需要“狂奔”能力。这也合理，毕竟，人家都会飞了，也就不需要跑和跳了。"]}),"\n",(0,r.jsxs)(e.p,{children:["此时，如果我们借助继承来解决这个问题，就得让",(0,r.jsx)(e.code,{children:"SuperPlayer"}),"同时继承 3 个 Class，用伪代码示意如下："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"SuperPlayer\n  extends BasketballPlayer \n    extends FootballPlayer\n      extends CrazyPlayer\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这样一来，",(0,r.jsx)(e.code,{children:"SuperPlayer"})," 就被迫拥有了它并不需要也并不想要的的“射门”和“狂奔”能力。"]}),"\n",(0,r.jsxs)(e.p,{children:["但这还不是最糟糕的，最糟糕的是，这个 ",(0,r.jsx)(e.code,{children:"SuperPlayer"})," 它其实既不是篮球选手、也不是足球选手、也不是疯狂号选手——",(0,r.jsx)(e.code,{children:"SuperPlayer"})," 和篮球/足球/疯狂号选手的交集，其实仅限于一个灌篮/射门/奔跑动作而已。今后篮球/足球/疯狂号选手新增的任何属性和方法，都很可能是和我 ",(0,r.jsx)(e.code,{children:"SuperPlayer"})," 没有关系的，"]}),"\n",(0,r.jsx)(e.p,{children:"SuperPlayer 选手想要的明明只有几个特定的函数，我们却不得不曲线救国、把它变成一个既是篮球选手、又是足球选手、同时还是疯狂号选手的缝合怪。这一缝不要紧，以后任何一种选手的 Class 发生变更，都会直接影响到 SuperPlayer 这个最能赚钱、也最特别的选手。风险这么大，谁还敢再动那些父类呢？"}),"\n",(0,r.jsx)(e.p,{children:"这个例子虽然不复杂，但是已经足够把继承带来的问题具象化。此时我们不妨像下面这样，为程序引入组合："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// 这个函数单独处理 slamDunk 能力\nconst getSlamDunk = (player) => ({\n  slamDunk: () => {\n    return `${player.name} just dunked a basketball`\n  }\n})\n\n// 这个函数单独处理 shot 能力\nconst getShot = (player) => ({\n  shot: () => {\n    return `${player.name} just shot the goal`\n  }\n})\n\n// 这个函数单独处理 fly 能力\nconst getFly = (player) => ({\n  fly: () => {\n      if(player.money > 0) {\n          // 飞之前，先扣钱\n          this.money--\n          // 飞起来啦，好帅呀！\n          return `${player.name} is flying!So handsome!`\n      }\n      // this.money <= 0，没钱还想飞，你也配？（狗头\n      return 'you need to give me money'\n    }\n})\n\nconst SuperPlayer = (name, money) => {\n  // 创建 SuperPlayer 对象\n  const player = {\n    name,  \n    sport: 'super',  \n    money\n  }\n\n  // 组合多个函数到 player 中\n  return Object.assign(\n    {},  \n    getSlamDunk(player),\n    getShot(player),  \n    getFly(player)\n  )\n}\n\nconst superPlayer = SuperPlayer('xiuyan', 20)  \n// 'xiuyan just dunked a basketball'\nsuperPlayer.slamDunk()  \n// 'xiuyan just shot the goal'\nsuperPlayer.shot() \n// 'xiuyan is flying!So handsome!'\nsuperPlayer.fly()\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样一来，我们就用组合的方法，改造了原有的继承链，一举端掉了继承所带来的各种问题。"}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在“抽象”这个话题下，我支持大家遵循自己的思维习惯，选择自己最认同的一种思维模式组织自己的程序。但在“代码重用”这个话题下，我的观点会更加鲜明一些——",(0,r.jsx)(e.strong,{children:"组合就是比继承好，能用组合就不要用继承"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"有的同学可能会想：既然你都觉得组合比继承好了，这不就等于说 FP 比 OOP 强了吗？还说什么“遵循各自的思维习惯去抽象”呢？"}),"\n",(0,r.jsxs)(e.p,{children:["其实，组合作为一种代码重用的思路，它固然是 FP 的关键特征，但它却并不是 FP 的专利。很多时候，即便我们用 OOP 去抽象整体的程序框架，也不影响我们在程序的局部使用“组合”来解决代码重用的问题。楼上的 ",(0,r.jsx)(e.code,{children:"SuperPlayer"}),"就是一个很好的例子。在实现 ",(0,r.jsx)(e.code,{children:"SuperPlayer"}),"的过程中，我们并没有改变原有的程序格局，也就是说，整个游戏仍然可以是基于 OOP 来抽象角色和角色关系的。我们仅仅是在需要实现代码重用时，引入了组合这种方法。"]}),"\n",(0,r.jsx)(e.p,{children:"JS 语言非常特别，它的对象和函数之间没有特别清晰的边界，函数和对象都可以视作是一等公民（甚至函数本身就是一种可执行的对象）。在项目中混合使用多种范式开发，对于我们来说是极度正常的一件事情——即使选择了 FP 作为程序的主要范式，仍然免不了要使用对象这种数据结构；即使选择了 OOP 作为程序的主要范式，也避不开函数这种抽象方式。因此我始终认为，OOP 和 FP 之间并不是互斥/对立的关系，而是正交/协作的关系。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(i,{...n})}):i(n)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F22%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%20vs%20%E5%87%BD%E6%95%B0%E5%BC%8F%EF%BC%9A%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%B3%95.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"软件复杂度问题的两种解法",id:"软件复杂度问题的两种解法",depth:2},{text:"用 FP 解决业务问题",id:"用-fp-解决业务问题",depth:2},{text:"用 OOP 解决业务问题",id:"用-oop-解决业务问题",depth:2},{text:"抽象：谁是一等公民",id:"抽象谁是一等公民",depth:2},{text:"FP：函数是一等公民",id:"fp函数是一等公民",depth:3},{text:"OOP：对象是一等公民",id:"oop对象是一等公民",depth:3},{text:"代码重用：组合 vs 继承",id:"代码重用组合-vs-继承",depth:2},{text:"继承的问题",id:"继承的问题",depth:3},{text:"为 OOP 引入“组合”思想",id:"为-oop-引入组合思想",depth:3},{text:"小结",id:"小结",depth:2}],title:"22 面向对象 vs 函数式：软件复杂度问题的两种解法",headingTitle:"22 面向对象 vs 函数式：软件复杂度问题的两种解法",frontmatter:{}}}}]);