"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["52938"],{911730:function(e,n,r){r.r(n),r.d(n,{default:()=>R});var s=r(552676),i=r(740453);let t=r.p+"static/image/717594d4fa2a22440bfcc4deaaf41625.8de461d1.webp",a=r.p+"static/image/6f2d990d5af3f4fbab7d72ef1bfc7d6d.9e4ec1cb.webp",c=r.p+"static/image/f51ec3289eb2480f71a29a660e283041.f77d822c.webp",o=r.p+"static/image/95eec43ddc1d79e6d80f0426c4c98650.46b9f2e6.webp",l=r.p+"static/image/eba15a3894947d679a8ef459783a59ac.457b187a.webp",h=r.p+"static/image/e66aefdd6cdaf6d6e861280fc6712581.028e7144.webp",p=r.p+"static/image/ac49a9894c8248c6309441a8f32e2d80.a5ccf131.webp",d=r.p+"static/image/2c6ac4809ff691a6e6a78324efede524.5dc5983a.webp",m=r.p+"static/image/3142a16c62638a2e87bafa344d79b6e5.4902f142.webp",g=r.p+"static/image/5fb345383c22e93a7f598fbd4ccd78f4.bf21f0d2.webp",u=r.p+"static/image/fe5ed1dbb3d8ba7f1a458c0934274653.b7a172a2.webp",j=r.p+"static/image/5da17e61f7d3d39529d0ba694b9f25ee.87e51de8.webp",x=r.p+"static/image/ba99b29f0e0e3c12cddb464ac5b32b8f.117b82f9.webp",b=r.p+"static/image/3a861dce01ae4ba4e6d3e953fc8d6556.a27f4497.webp",f=r.p+"static/image/cea21167fe7c7cbe95b704ad0cdc59a7.130ee29b.webp",P=r.p+"static/image/c637fc22ce34f38ceca94f78879338d2.e689d716.webp",w=r.p+"static/image/7c797759519dff98b8ac2aeff31e7e06.15718a3b.webp",_=r.p+"static/image/a2581d2fc326f196e986d19da457015d.fbc3e85a.webp",v=r.p+"static/image/6bd2a8b73f89fc0bbc6de99643231d64.5ce7f645.webp",C=r.p+"static/image/7615282e3ec705b4cbab4f59bb800c9e.009047c9.webp";function D(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"49基于-cdp-实现-puppeteer下",children:["49.基于 CDP 实现 Puppeteer（下）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#49基于-cdp-实现-puppeteer下",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上一节我们实现了 Chromium 的自动下载，这节把 Chromium 跑起来，实现远程控制。"}),"\n",(0,s.jsx)(n.p,{children:"你是否好奇过 Puppeteer 的远程控制是怎么实现的呢？"}),"\n",(0,s.jsx)(n.p,{children:"其实也是基于 Chrome DevTools Protocol，它是 chrome devtools 和 chromium 通信的协议，chrome devtools 用它来获取 chromium 的一些信息，并且还可以控制 chromium 来做一些事情。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在 chrome devtools 里打开 Protocol Monitor，就可以看到 CDP 的数据："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"chrome devtools 里展示的数据，控制浏览器执行一些行为，都是通过这个实现的，Puppeteer 也同样是基于这个。"}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.a,{href:"https://chromedevtools.github.io/devtools-protocol/",target:"_blank",rel:"noopener noreferrer",children:"CDP 的文档"}),"可以看到协议的详细描述："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"它是分为不同的域的，比如 Page、Browser、Network 等，分区来管理不同的协议。"}),"\n",(0,s.jsx)(n.p,{children:"比如 Page.navigate 可以让页面导航到某个 url："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Page.close 可以关闭页面"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Browser.close 可以关闭浏览器"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Puppeteer 就是基于这些来远程控制 Chromium 的。"}),"\n",(0,s.jsx)(n.p,{children:"我们来实现一下。"}),"\n",(0,s.jsx)(n.p,{children:"首先，我们手动走下这个流程："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"启动前面下载的 Chromium 浏览器，指定启动参数 --remote-debugging-port 和 --user-data-dir"}),"\n",(0,s.jsx)(n.p,{children:"--remote-debugging-port 就是调试服务的启动端口，--user-data-dir 是保存用户数据的地方"}),"\n",(0,s.jsx)(n.p,{children:"用户数据是指插件、浏览记录、历史、Cookie、网站数据等所有用户使用浏览器时的数据，指定了 userDataDir，chromium 就会把数据保存在那个目录："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但这个参数在低版本的 chromium 不支持，所以如果有报错就用版本高一点的 chromium 来跑，比如我这里用的是 970501"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["以调试模式跑起 Chromium 之后，访问 ",(0,s.jsx)(n.a,{href:"http://localhost:9929/json/list",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:9929/json/list"})," 就可以看到每个页面的 ws 服务的信息，可以连上每个页面进行调试："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"比如我再访问下 baidu 和 juejin，就会多这俩页面的 ws 调试服务的信息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["我们可以用 ",(0,s.jsx)(n.a,{href:"http://localhost:9929/json/list",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:9929/json/list"})," 这个页面是否可以打开来判断浏览器是否以调试模式启动成功了。"]}),"\n",(0,s.jsx)(n.p,{children:"然后你还会发现 /json/new 可以新建一个页面："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Puppeteer 新建页面也是这样实现的。"}),"\n",(0,s.jsx)(n.p,{children:"下面我们把这个流程用代码来实现一下："}),"\n",(0,s.jsx)(n.p,{children:"我们先处理下 chromium 的启动参数，也就是 user-data-dir、remote-debugging-port 等这些："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let browserId = 0;\n\n//用户数据目录\nconst CHROME_PROFILE_PATH = path.resolve(__dirname, '..', '.dev_profile');\n\nclass Browser {\n\n    constructor(options) {\n        options = options || {};\n\n        ++browserId;\n        this._userDataDir = CHROME_PROFILE_PATH + browserId;\n\n        this._remoteDebuggingPort = 9229;\n        if (typeof options.remoteDebuggingPort === 'number') {\n            this._remoteDebuggingPort = options.remoteDebuggingPort;\n        }\n        this._chromeArguments = [ \n            `--user-data-dir=${this._userDataDir}`,\n            `--remote-debugging-port=${this._remoteDebuggingPort}`,\n        ];\n\n        if (options.headless) {\n            this._chromeArguments.push(`--headless`);\n        }\n\n        if (typeof options.executablePath === 'string') {\n            this._chromeExecutable = options.executablePath;\n        } else {\n            const chromiumRevision = require('../package.json').puppeteer.chromium_revision;\n            this._chromeExecutable = Downloader.executablePath(chromiumRevision);\n        }\n\n        if (Array.isArray(options.args))\n            this._chromeArguments.push(...options.args);\n\n        this._chromeProcess = null;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这段逻辑就是 Browser 的启动参数的处理，包括启动路径 _chromeExecutable，启动参数 user-data-dir 的路径、headless、remote-debugging-port。"}),"\n",(0,s.jsx)(n.p,{children:"启动参数有了，接下来就是启动 Chromium 了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const childProcess = require('child_process');\nconst removeRecursive = require('rimraf').sync;\n\nasync launch() {\n    if (this._chromeProcess)\n        return;\n    this._chromeProcess = childProcess.spawn(this._chromeExecutable, this._chromeArguments, {});\n\n    process.on('exit', () => this._chromeProcess.kill());\n    this._chromeProcess.on('exit', () => removeRecursive(this._userDataDir));\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"启动 chromium 就是通过 childProcess 以子进程的方式启动，并且在它退出的时候递归删除下用户数据目录。"}),"\n",(0,s.jsx)(n.p,{children:"这里的 rimraf 是第三方的包，node 只提供了删除单个文件或目录的 api fs.unlink，不支持递归删除。"}),"\n",(0,s.jsx)(n.p,{children:"这样就通过代码的方式把我们手动启动浏览器的步骤给自动化了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["CDP 协议只有以调试模式启动 Chromium 的时候才能生效，所以我们要保证它是启在调试模式的，也就是访问下 ",(0,s.jsx)(n.a,{href:"http://localhost:9929/json/list",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:9929/json/list"})," 是有数据的："]}),"\n",(0,s.jsx)(n.p,{children:"所以要加一段这样的逻辑："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function waitForChromeResponsive(remoteDebuggingPort) {\n    var resolve;\n    const promise = new Promise(x => resolve  = x);\n\n    const options = {\n        method: 'GET',\n        host: 'localhost',\n        port: remoteDebuggingPort,\n        path: '/json/list'\n    };\n    sendRequest();\n    return promise;\n\n    function sendRequest() {\n        const req = http.request(options, res => {\n            resolve ()\n        });\n        req.on('error', e => setTimeout(sendRequest, 100));\n        req.end();\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"就是访问下这个 url，如果成功就 resolve promise，否则定时重试。"}),"\n",(0,s.jsx)(n.p,{children:"经过这个验证之后，之后就可以通过 CDP 来和 chromium 通信了。"}),"\n",(0,s.jsx)(n.p,{children:"这个方法我们可以把它叫做 _ensureChromeIsRunning，确保 chrome 在调试模式运行的方法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async launch() {\n    await this._ensureChromeIsRunning();\n}\n\nasync _ensureChromeIsRunning() {\n    if (this._chromeProcess)\n        return;\n    this._chromeProcess = childProcess.spawn(this._chromeExecutable, this._chromeArguments, {});\n\n    process.on('exit', () => this._chromeProcess.kill());\n    this._chromeProcess.on('exit', () => removeRecursive(this._userDataDir));\n\n    await waitForChromeResponsive(this._remoteDebuggingPort);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"之后就开始通过 CDP 控制浏览器。"}),"\n",(0,s.jsx)(n.p,{children:"这个 CDP 的 WebSocket 通信过程也不用我们自己搞，chrome 提供了一个 chrome-remote-interface 的包。"}),"\n",(0,s.jsx)(n.p,{children:"比如我们可以用它新建一个页面："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const CDP = require('chrome-remote-interface');\n\nasync newPage() {\n    await this._ensureChromeIsRunning();\n\n    if (!this._chromeProcess || this._chromeProcess.killed) {\n        throw new Error('ERROR: this chrome instance is not alive any more!');\n    }\n\n    const tab = await CDP.New({port: this._remoteDebuggingPort});\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"跑起来确实可以看到 chromium 新建了一个页面，这就是我们实现的第一个远程控制效果！（原理就是访问 /json/new）"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"接下来进行更多的 page 的控制，Page 级别的控制我们单独封装一下，放到 Page 的类里："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class Page{\n\n    static async create(browser, client) {\n        await client.send('Page.enable', {});\n\n        const page = new Page(browser, client);\n        return page;\n    }\n\n    constructor(browser, client) {\n        this._browser = browser;\n        this._client = client;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"需要传入浏览器实例和 CDP 客户端。"}),"\n",(0,s.jsx)(n.p,{children:"所以在 Browser 的 newPage 方法里就创建个 page 的对象返回，之后的控制都交给它："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const CDP = require('chrome-remote-interface');\n\nasync newPage() {\n    await this._ensureChromeIsRunning();\n\n    if (!this._chromeProcess || this._chromeProcess.killed) {\n        throw new Error('ERROR: this chrome instance is not alive any more!');\n    }\n    const tab = await CDP.New({port: this._remoteDebuggingPort});\n    \n    const client = await CDP({tab: tab, port: this._remoteDebuggingPort});\n    const page = await Page.create(this, client);\n    page[this._tabSymbol] = tab;\n    return page;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"CDP 传入 port 参数和 tab 参数，那连接的就是这个 tab 页面的 ws 调试服务，也就是我们在 /json/list 里看到的那个："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"之后开始做一些页面级别的控制："}),"\n",(0,s.jsx)(n.p,{children:"CDP 每个域的使用都要先开启下，创建 Page 对象的时候我们已经开启了 Page 域的协议："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后实现个 navigate 方法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async navigate(url) {\n    var loadPromise = new Promise(resolve => this._client.once('Page.loadEventFired', resolve)).then(() => true);\n\n    await this._client.send('Page.navigate', {url});\n    return await loadPromise;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"通过 CDP 协议里的 Page.navigate 来导航到某个 url，在 Page.loadEventFired 的时候 resolve。"}),"\n",(0,s.jsx)(n.p,{children:"然后再实现个 setContent 方法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async setContent(html) {\n    var resourceTree = await this._client.send('Page.getResourceTree', {});\n    await this._client.send('Page.setDocumentContent', {\n        frameId: resourceTree.frameTree.frame.id,\n        html: html\n    });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个是设置 Page 的 html 内容的 CDP 协议，需要传入 frameId，这个可以通过 Page.getResourceTree 拿到。"}),"\n",(0,s.jsx)(n.p,{children:"最后我们再去 Browser 那里实现俩方法，之后再一起测试。"}),"\n",(0,s.jsx)(n.p,{children:"加一个 version 方法，用于获取浏览器版本："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async version() {\n    await this._ensureChromeIsRunning();\n    const version = await CDP.Version({port: this._remoteDebuggingPort});\n    return version.Browser;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"加一个 close 方法用于关闭浏览器："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"close() {\n    if (!this._chromeProcess)\n        return;\n    this._chromeProcess.kill();\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"至此，全部搞定之后，我们整体来调用一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const Browser = require('./lib/Browser');\n\nconst browser = new Browser({\n    remoteDebuggingPort: 9229,\n    headless: false\n});\n\nfunction delay(time) {\n    return new Promise((resolve => setTimeout(resolve, time)))\n}\n\n(async function() {\n    await browser.launch();\n\n    const page = await browser.newPage();\n    await page.navigate('https://www.baidu.com');\n\n    await delay(2000);\n    const version = await browser.version();\n    await page.setContent(`<h1 style=\"font-size:50px\">hello, ${version}</h1>`);\n\n    await delay(2000);\n    await page.close();\n\n    await delay(1000);\n    await browser.close();\n})()\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们创建了一个 Browser，传入启动参数，然后把它跑起来，之后创建了个新页面，导航到 baidu，2s 后修改了内容，再 2s 关闭页面，之后再 1s 关闭浏览器。"}),"\n",(0,s.jsx)(n.p,{children:"我们跑一下试试："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，Chromium 正确执行了我们写的脚本！"}),"\n",(0,s.jsx)(n.p,{children:"puppeteer 还能远程执行 JS，也就是在脚本里写一段 JS，puppeteer 会把它发给浏览器执行，最后返回结果。"}),"\n",(0,s.jsx)(n.p,{children:"这个是怎么实现的呢？"}),"\n",(0,s.jsx)(n.p,{children:"CDP 协议里的 Runtime.evaluate 就是用来执行一段 JS 表达式的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们平时在 console 里写的代码能够计算出结果就是通过这个协议。"}),"\n",(0,s.jsx)(n.p,{children:"我们封装这样一个函数："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function evaluate(client, fun, args) {\n    var argsString = args.map(x => JSON.stringify(x)).join(',');\n    var code = `(${fun.toString()})(${argsString})`;\n\n    return client.send('Runtime.evaluate', {\n        expression: code,\n        returnByValue: true\n    });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"它就是通过 CDP client 给留浏览器发一个 Runtime.evaluate 的协议数据，内容是 stringify 之后的函数。"}),"\n",(0,s.jsx)(n.p,{children:"并在 Page.js 里添加这样一个 evaluate 方法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async evaluate(fun, ...args) {\n    var response = await evaluate(this._client, fun, args, false);\n\n    return response.result.value;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后就可以使用 evaluate 来远程执行 JS 了："}),"\n",(0,s.jsx)(n.p,{children:"我们把 index.js 的测试脚本改成这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"把 baidu 页面的背景改为粉色，并且拿到热榜列表的文本数据。"}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样就能远程执行 JS 了。"}),"\n",(0,s.jsx)(n.p,{children:"至此，我们实现了 Puppeteer 的基本功能。"}),"\n",(0,s.jsxs)(n.p,{children:["代码在",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/fe-debug-exercize",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"里，大家可以下下来跑跑"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这一节我们实现了启动 Chromium 并远程控制，还有远程执行 JS。"}),"\n",(0,s.jsxs)(n.p,{children:["Chromium 指定 remote-debugging-port 的参数的时候就会以调试模式来跑，如果可以通过 ",(0,s.jsx)(n.a,{href:"http://localhost:9229/json/list",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:9229/json/list"})," 拿到调试的数据就证明启动成功了。"]}),"\n",(0,s.jsx)(n.p,{children:"之后可以通过 CDP 协议来进行页面级别的控制，这就是 Puppeteer 的原理。"}),"\n",(0,s.jsx)(n.p,{children:"我们实现了浏览器的打开、关闭、查看版本号，页面的新建、导航、设置内容等功能，还实现了 JS 的远程执行。"}),"\n",(0,s.jsx)(n.p,{children:"这就是一个简易版 puppeteer 了，其他的功能也是基于 CDP 实现的。"}),"\n",(0,s.jsx)(n.p,{children:"通过这个案例，我们也能更深刻的理解 CDP。"})]})}function E(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(D,{...e})}):D(e)}let R=E;E.__RSPRESS_PAGE_META={},E.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F49.%E5%9F%BA%E4%BA%8E%20CDP%20%E5%AE%9E%E7%8E%B0%20Puppeteer%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"49.基于 CDP 实现 Puppeteer（下）",headingTitle:"49.基于 CDP 实现 Puppeteer（下）",frontmatter:{}}}}]);