"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["35754"],{787324:function(n,e,s){s.r(e),s.d(e,{default:()=>i});var r=s(552676),c=s(740453);function l(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",ol:"ol",li:"li",strong:"strong",blockquote:"blockquote"},(0,c.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"12-基础篇从-class-语法视角看类的继承与实例创建",children:["12 基础篇｜从 class 语法视角看类的继承与实例创建",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12-基础篇从-class-语法视角看类的继承与实例创建",children:"#"})]}),"\n",(0,r.jsxs)(e.h2,{id:"class-是什么",children:["class 是什么",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#class-是什么",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["一句话概括，",(0,r.jsx)(e.code,{children:"class 就是构造函数的语法糖"}),"，就像 ",(0,r.jsx)(e.code,{children:"async/await"})," 是 Promise 的语法糖一样。"]}),"\n",(0,r.jsx)(e.p,{children:"不信的话，我们可以这样证明："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'class Foo {\n    baz = 1;\n    constructor(a, b) {}\n    bar() {}\n}\n\ntypeof Foo // "function"\nFoo.name // "Foo"\nFoo.length // 2\n'})}),"\n",(0,r.jsxs)(e.p,{children:["我们最需要关注的是函数的 ",(0,r.jsx)(e.code,{children:"prototype"})," 属性，它关系到 ",(0,r.jsx)(e.code,{children:"instanceof"})," 是否能正常工作，在 Chrome 下打印出来是这样的："]}),"\n",(0,r.jsxs)(e.p,{children:["可以清晰地看到，除了本来就该有的 ",(0,r.jsx)(e.code,{children:"constructor"})," 外，bar 函数也出现在了里面，但是非函数的 baz 却没有。这很容易理解，函数可以在不同的实例之间重用，但是数据却是实例独享的。"]}),"\n",(0,r.jsx)(e.p,{children:"作为一种语法糖，class 能实现的所有能力，我们用普通函数几乎都能实现。虽然如此，class 支持的 super、static 块、static 属性、私有属性、extend 继承等等特性，涉及到原型链查找、闭包等诸多细节，模拟起来并非易事。我以一小段代码为例，大家可以从现有的工具转换结构上窥见一二。"}),"\n",(0,r.jsx)(e.p,{children:"原始代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"class Parent {\n    constructor(a, b) {}\n    say() {}\n}\n\nclass Child extends Parent {\n    #baz = 1;\n    constructor(a, b) {\n        super(a, b);\n    }\n    bar() {}\n    static walk() {}\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"TypeScript"})," 转换后："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'var\xa0__extends\xa0=\xa0(this\xa0&&\xa0this.__extends)\xa0||\xa0(function\xa0()\xa0{\n\xa0\xa0\xa0\xa0var\xa0extendStatics\xa0=\xa0function\xa0(d,\xa0b)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0extendStatics\xa0=\xa0Object.setPrototypeOf\xa0||\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0({\xa0__proto__:\xa0[]\xa0}\xa0instanceof\xa0Array\xa0&&\xa0function\xa0(d,\xa0b)\xa0{\xa0d.__proto__\xa0=\xa0b;\xa0})\xa0||\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0function\xa0(d,\xa0b)\xa0{\xa0for\xa0(var\xa0p\xa0in\xa0b)\xa0if\xa0(Object.prototype.hasOwnProperty.call(b,\xa0p))\xa0d[p]\xa0=\xa0b[p];\xa0};\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0extendStatics(d,\xa0b);\n\xa0\xa0\xa0\xa0};\n\xa0\xa0\xa0\xa0return\xa0function\xa0(d,\xa0b)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0if\xa0(typeof\xa0b\xa0!==\xa0"function"\xa0&&\xa0b\xa0!==\xa0null)\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0throw\xa0new\xa0TypeError("Class\xa0extends\xa0value\xa0"\xa0+\xa0String(b)\xa0+\xa0"\xa0is\xa0not\xa0a\xa0constructor\xa0or\xa0null");\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0extendStatics(d,\xa0b);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0function\xa0__()\xa0{\xa0this.constructor\xa0=\xa0d;\xa0}\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0d.prototype\xa0=\xa0b\xa0===\xa0null\xa0?\xa0Object.create(b)\xa0:\xa0(__.prototype\xa0=\xa0b.prototype,\xa0new\xa0__());\n\xa0\xa0\xa0\xa0};\n})();\nvar\xa0_Child_baz;\nvar\xa0Parent\xa0=\xa0/**\xa0@class\xa0*/\xa0(function\xa0()\xa0{\n\xa0\xa0\xa0\xa0function\xa0Parent(a,\xa0b)\xa0{\n\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0Parent.prototype.say\xa0=\xa0function\xa0()\xa0{\xa0};\n\xa0\xa0\xa0\xa0return\xa0Parent;\n}());\nvar\xa0Child\xa0=\xa0/**\xa0@class\xa0*/\xa0(function\xa0(_super)\xa0{\n\xa0\xa0\xa0\xa0__extends(Child,\xa0_super);\n\xa0\xa0\xa0\xa0function\xa0Child(a,\xa0b)\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0var\xa0_this\xa0=\xa0_super.call(this,\xa0a,\xa0b)\xa0||\xa0this;\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0_Child_baz.set(_this,\xa01);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0return\xa0_this;\n\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0Child.prototype.bar\xa0=\xa0function\xa0()\xa0{\xa0};\n\xa0\xa0\xa0\xa0Child.walk\xa0=\xa0function\xa0()\xa0{\xa0};\n\xa0\xa0\xa0\xa0return\xa0Child;\n}(Parent));\n_Child_baz\xa0=\xa0new\xa0WeakMap();\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Babel"})," 转换后："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'// 省略大量辅助函数\n\nvar Parent = /*#__PURE__*/function () {\n  "use strict";\n\n  function Parent(a, b) {\n    _classCallCheck(this, Parent);\n  }\n  _createClass(Parent, [{\n    key: "say",\n    value: function say() {}\n  }]);\n  return Parent;\n}();\nvar _baz = /*#__PURE__*/new WeakMap();\nvar Child = /*#__PURE__*/function (_Parent) {\n  "use strict";\n\n  _inherits(Child, _Parent);\n  var _super = _createSuper(Child);\n  function Child(a, b) {\n    var _this;\n    _classCallCheck(this, Child);\n    _this = _super.call(this, a, b);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _baz, {\n      writable: true,\n      value: 1\n    });\n    return _this;\n  }\n  _createClass(Child, [{\n    key: "bar",\n    value: function bar() {}\n  }], [{\n    key: "walk",\n    value: function walk() {}\n  }]);\n  return Child;\n}(Parent);\n'})}),"\n",(0,r.jsx)(e.p,{children:"即便舍去辅助函数的部分，实现一个最简单的类继承，竟然需要如此复杂的调用，可见 class 确实减少了很多编码成本，背后隐藏了大量对象的操作细节。"}),"\n",(0,r.jsx)(e.p,{children:"在本小册的基础篇即将结束之前，我想借着这个机会，将 class 作为一个典型案例，通过模拟实现它，在掌握其原理的同时，能够帮助大家进一步消化对象操作的相关知识。"}),"\n",(0,r.jsx)(e.p,{children:"我们观察 class 的基本结构："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"class Parent {\n    name = '';\n    static home = 'beijing';\n    constructor(name) {\n        this.name = name;\n    }\n    \n    say() {\n        console.log(`I am ${this.name}.`);\n    }\n}\n\nclass Child extends Parent {\n    age = 5;\n    static type = 'kid';\n    constructor(name) {\n        super(name);\n    }\n    \n    say() {\n        super.say();\n        console.log(`And I am ${this.age} years old.`);\n    }\n    \n    jump() {\n        console.log(`I like jumping.`);\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这不是 class 语法的全部能力，但已经能涵盖绝大部分场景，我们一步一步来讲。上面的代码体现了下列几个功能："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"构造函数；"}),"\n",(0,r.jsx)(e.li,{children:"类成员；"}),"\n",(0,r.jsx)(e.li,{children:"继承，包括成员属性、成员函数、super；"}),"\n",(0,r.jsxs)(e.li,{children:["类",(0,r.jsx)(e.code,{children:"静态"}),"成员。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["我们接下来就以上面的代码作为案例，尝试",(0,r.jsx)(e.strong,{children:"翻译"}),"成普通 function 语法。"]}),"\n",(0,r.jsxs)(e.h2,{id:"构造函数",children:["构造函数",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#构造函数",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["无论是 function 语法还是 class 语法，最终都是用 ",(0,r.jsx)(e.code,{children:"new"})," 操作符来创建对象实例。那么 ",(0,r.jsx)(e.code,{children:"new"})," 到底做了什么事情呢？我们来模拟一下，实现一个 ",(0,r.jsx)(e.code,{children:"createInstance"})," 函数。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function createInstance(Constructor, ...args) {}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["首先你的构造函数 Constructor 必须确定满足构造函数的定义。我们在前面的函数一章中讲到过，函数对象可能存在一个叫做 ",(0,r.jsx)(e.code,{children:"[[Construct]]"})," 的内部方法，存在则代表它可以作为构造函数。显然异步函数、生成器函数就没有",(0,r.jsx)(e.code,{children:"[[Construct]]"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["一般对象的 ",(0,r.jsx)(e.code,{children:"[[Construct]]"})," 方法的实现大致如下："]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"创建一个对象 P，原型链指向 Constructor.prototype；"}),"\n",(0,r.jsxs)(e.li,{children:["生成一个上下文，有两个变量绑定需要关注，第一是 ",(0,r.jsx)(e.code,{children:"this"}),"，指向刚创建的 P，第二是 ",(0,r.jsx)(e.code,{children:"new.target"}),"，指向 Constructor；"]}),"\n",(0,r.jsxs)(e.li,{children:["执行 Constructor 的代码，如果返回一个对象（即非 ",(0,r.jsx)(e.code,{children:"Primitive"})," 值），那么就作为构造函数的结果，否则将 P 作为构造函数的结果。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"用代码的话，可以近似表述成："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function createInstance(Constructor, ...args) {\n    const p = Object.create(Constructor.prototype);\n    const result = Constructor.apply(p, args);\n\n    if (result && typeof result === 'object') {\n        return result;\n    }\n    \n    return p;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这里无法实现的是 ",(0,r.jsx)(e.code,{children:"new.target"}),"，应该有很多人对此感到陌生。乍一看，似乎很难理解这种写法，",(0,r.jsx)(e.code,{children:"new"})," 怎么会是一个对象呢？"]}),"\n",(0,r.jsxs)(e.p,{children:["其实这里并不能理解成一个对象的属性，它是一种新的语法，",(0,r.jsx)(e.code,{children:"只能在函数中使用"}),"，用来判断当前函数是否是通过 ",(0,r.jsx)(e.code,{children:"new"})," 来调用的。如果你强制要求一个函数必须是构造函数，那么可以这样写："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'function Foo() {\n    if (!new.target) \n        throw Error("Foo 必须作为构造函数使用。");\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"另一个值得关注的是，普通函数作为构造函数的话，返回的不一定是这个函数的实例，取决于它里面 return 的值类型。通常来说，构造函数不需要有返回值，但如果你一定要这么做，就需要明白这里的差异化逻辑："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function Foo() {\n    return [1];\n}\n\nnew Foo(); // [1]\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["\uD83D\uDCA1 即便是 ",(0,r.jsx)(e.code,{children:"class"})," 语法也不能避免，它的 constructor 也可以有 return 语句。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["上面我用 ",(0,r.jsx)(e.code,{children:"Object.create"})," 来创建了对象，并直接关联了原型，这一步可以拆成下面两步："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const p = {};\nconst result = Object.setPrototypeOf(p, Constructor.prototype)\n"})}),"\n",(0,r.jsx)(e.p,{children:"可见所谓的构造函数创建对象，本质上无非也是一个大括号字面量对象的声明，加上一个设置原型的操作而已，没有什么神秘的。"}),"\n",(0,r.jsx)(e.p,{children:"创建完对象，我们来看类的成员该怎么实现。"}),"\n",(0,r.jsxs)(e.h2,{id:"类成员",children:["类成员",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#类成员",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["类成员是不是函数类型，关系到实现的原理上的不同，差异还是很大的。我们可以这样理解，函数通过 ",(0,r.jsx)(e.code,{children:"this/super"})," 来和对象进行交流，属于实例之间可复用的过程；而非函数则属于对象自身的资产，不可以在实例之间共享。"]}),"\n",(0,r.jsxs)(e.p,{children:["这就造成了两种属性被储存位置的不同。函数应当定义在原型中，也就是 ",(0,r.jsx)(e.code,{children:"Constructor.prototype"})," 上，非函数要定义在对象自身上。"]}),"\n",(0,r.jsx)(e.p,{children:"根据这个原理，以上面的 Parent 为例，我们第一印象里其 say 函数可以这样定义："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"Parent.prototype.say = function () {\n    console.log(`I am ${this.name}.`);\n};\n"})}),"\n",(0,r.jsxs)(e.p,{children:["但是我必须提醒大家，这样的写法严格来说是",(0,r.jsx)(e.strong,{children:"不正确的"}),"。因为 say 会被 ",(0,r.jsx)(e.code,{children:"for...in"})," 遍历出来："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"for (const key in parentInstance) {\n    console.log(key); // say...\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这是被规范所不允许的，所以要换一种写法："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"Object.defineProperty(Parent.prototype, 'say', {\n    value: function () {\n        console.log(`I am ${this.name}.`);\n    },\n    // 不可枚举\n    enumerable: false,\n    writable: true,\n    configurable: true,\n});\n"})}),"\n",(0,r.jsxs)(e.p,{children:["非函数属性也有同样的问题。虽然是在当前对象上存储属性，但是也分成 set 和 defineProperty 两种形式。在把代码编译成 ES5 时，TypeScript 和 Babel 都分别提供了 ",(0,r.jsx)(e.code,{children:"useDefineForClassFields"})," 和 ",(0,r.jsx)(e.code,{children:"setPublicClassFields"})," 参数，来控制这一行为。"]}),"\n",(0,r.jsxs)(e.p,{children:["按照 ECMAScript 的标准规范，",(0,r.jsx)(e.code,{children:"class"})," 语法中的属性声明应该就是 defineProperty 的方式。比如上面 Parent 中的 name："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function\xa0Parent(name)\xa0{\n    Object.defineProperty(this,\xa0\"name\",\xa0{\n        enumerable:\xa0true,\n        configurable:\xa0true,\n        writable:\xa0true,\n        value:\xa0''\n    });\n\n    this.name\xa0=\xa0name;\n}\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"\uD83D\uDCA1 注意，不同于函数成员，非函数应该是可枚举的，毕竟它属于对象而非其原型。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["如果 ",(0,r.jsx)(e.code,{children:"useDefineForClassFields"})," 设置成了 false，或者 ",(0,r.jsx)(e.code,{children:"setPublicClassFields"})," 设置成了 true，代码会变成："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function\xa0Parent(name)\xa0{\n    this.name\xa0=\xa0'';\n    this.name\xa0=\xa0name; // ❌\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"对于独立的类没有什么问题，但是一旦这个类继承自另一个类，那么上面这种 set 操作就很有可能修改到原型中的数据，产生副作用。"}),"\n",(0,r.jsx)(e.p,{children:"下面我们就看继承应该怎样实现。"}),"\n",(0,r.jsxs)(e.h2,{id:"类继承",children:["类继承",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#类继承",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"还是以前面的代码为例，在用 function 实现了 Parent 之后，我们现在实现 Child 继承 Parent。大家注意看，这里的逻辑可能会比较绕，可以多看几遍。"}),"\n",(0,r.jsxs)(e.p,{children:["在 Child 的构造函数中，首先必须调用 ",(0,r.jsx)(e.code,{children:"super"})," 并传参数。这里的 ",(0,r.jsx)(e.code,{children:"super"})," 毫无疑问就是父类 Parent，于是第一步："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function Child(name) {\n    Parent.call(this, name);\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["注意，这里我们假设 Child 由 ",(0,r.jsx)(e.code,{children:"new"})," 调用，并没有展开为 ",(0,r.jsx)(e.code,{children:"createInstance"}),"，因此 ",(0,r.jsx)(e.code,{children:"this"})," 首先就被创建了，并且在 Parent 中被定义了一个 name 自有属性。"]}),"\n",(0,r.jsxs)(e.p,{children:["接下来，Child 自己还有一个 age 属性，依然由 ",(0,r.jsx)(e.code,{children:"defineProperty"})," 定义："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'function Child(name) {\n    Parent.call(this, name);\n    \n    Object.defineProperty(this,\xa0"age",\xa0{\n        enumerable:\xa0true,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0configurable:\xa0true,\n        writable:\xa0true,\n        value:\xa05\n\xa0\xa0\xa0\xa0});\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"到这一部分， Child 构造函数的使命已经达成，下面要解决的，是实现继承 Parent 上的函数属性，也就是说必须满足："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"childInstance.__proto__.__proto__... === Parent.prototype // true\n"})}),"\n",(0,r.jsxs)(e.p,{children:["而我们知道，",(0,r.jsx)(e.code,{children:"new"})," 有这样的效果："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"childInstance.__proto__ === Child.prototype // true\n"})}),"\n",(0,r.jsx)(e.p,{children:"于是可推导出："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"Child.prototye.__proto__... === Parent.prototype // true\n\nChild.prototye instanceof Parent === true\n"})}),"\n",(0,r.jsx)(e.p,{children:"在声明 Child 函数的时候，它已经自带一个 Child.prototype 对象了，里面只有一个 constructor 不可枚举属性指向 Child。"}),"\n",(0,r.jsx)(e.p,{children:"那我们不妨实现一个该对象的超集，并满足上述推导式："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"Child.prototype = Object.create(Parent.prototype, {\n    constructor: {\n        value: Child,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    },\n});\n"})}),"\n",(0,r.jsxs)(e.p,{children:["注意，Child 上还有一个自有的 jump 函数和一个调用了父类同名函数（通过 ",(0,r.jsx)(e.code,{children:"super.<func>"}),"）的 say 函数。作为函数，它们都应该出现在 Child.prototype 中，于是 Child.prototype 的最终定义可以写作："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'Child.prototype = Object.create(Parent.prototype, {\n    constructor: {\n        value: Child,\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    },\n    say: {\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0enumerable:\xa0false,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0configurable:\xa0true,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0writable:\xa0true,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0value:\xa0function\xa0()\xa0{\n            // 由 super.say() 翻译而来\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0Parent.prototype.say.call(this);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0console.log(`And\xa0I\xa0am\xa0${this.age} years\xa0old.`);\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n\xa0\xa0\xa0\xa0},\n    jump: {\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0enumerable:\xa0false,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0configurable:\xa0true,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0writable:\xa0true,\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0value:\xa0function\xa0()\xa0{\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0console.log("I\xa0like\xa0jumping.");\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0}\n    },\n});\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"注意 super.say()，可以等价写作 Parent.prototype.say.call(this)。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"以上只是说明了用普通函数实现继承的大概原理，但是在生产环境中，还有很多细节需要考虑，比如："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"如果 Parent 是 null 怎么办？"}),"\n",(0,r.jsx)(e.li,{children:"如果 Parent 有返回值怎们办？"}),"\n",(0,r.jsxs)(e.li,{children:["Child 的 prototype 不应该被 ",(0,r.jsx)(e.code,{children:"for...in"})," 遍历出来，怎么办？"]}),"\n",(0,r.jsx)(e.li,{children:"跨层级调用 super 怎么实现？"}),"\n",(0,r.jsx)(e.li,{children:"……"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["大家可以顺着我上面的代码继续思考，看能不能把提到的这些问题一一解决。如果没有思路，建议大家去看一下 ",(0,r.jsx)(e.code,{children:"Babel"})," 或者 ",(0,r.jsx)(e.code,{children:"TypeScript"})," 的编译产出。不过它们的实现也并不一致，孰优孰劣，留给大家自己去判断了。"]}),"\n",(0,r.jsxs)(e.p,{children:["现在我们回过头来思考一下类的非函数成员，应该用 set 还是 defineProperty 的问题。通过刚刚对继承的实现，我们可以总结出：",(0,r.jsx)(e.strong,{children:"本质上沿着原型链继承的只是函数，其他属性都是定义在当前对象上的，和原型链无关"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"getter/setter"})," 本质上也是函数，也会定义在原型中，比如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"class Parent {\n    set alias() {}\n    get alias() {}\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"等价于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"Object.defineProperty(Parent.prototype, 'alias', {\n    get(){},\n    set(){},\n    enumerable:\xa0false,\n    configurable:\xa0true\n});\n"})}),"\n",(0,r.jsx)(e.p,{children:"那么如果 Child 也有一个同名的属性："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'class Child {\n    alias = ""\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"如果以 set 的方式定义，那么就是："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'function Child() {\n    this.alias = "";\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["显然，",(0,r.jsx)(e.strong,{children:"set alias 会作用到原型链中，而不是当前对象"}),"。我们在前面章节中提到过，赋值操作，也就是 ",(0,r.jsx)(e.code,{children:"PutValue"}),"，如果遇到原型链中有同名的存取器属性，就会写入到原型链上；如果没有，或者是数据属性，那么就会写入到当前对象上。这就是用 set 来定义函数成员的潜在风险。"]}),"\n",(0,r.jsxs)(e.p,{children:["如果你确定没有这样的风险，或者某些特殊的场景（比如 WebComponents），才可以把 ",(0,r.jsx)(e.code,{children:"useDefineForClassFields"})," 设置成了 false、把 ",(0,r.jsx)(e.code,{children:"setPublicClassFields"})," 设置成了 true。"]}),"\n",(0,r.jsx)(e.p,{children:"继承还有最后一步：静态成员。"}),"\n",(0,r.jsxs)(e.h2,{id:"类静态成员",children:["类静态成员",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#类静态成员",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"静态成员是属于类本身的，在实例之间共享，或者说它压根就是一个全局变量。Parent 的 home 直接定义在 Parent 上："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'Parent.home = "beijing";\n'})}),"\n",(0,r.jsx)(e.p,{children:"Child 同样："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'Child.type = "kid";\n'})}),"\n",(0,r.jsx)(e.p,{children:"按照继承的规则，在 Child 也应该可以访问到 home，于是我们用原型链的方式来解决："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"Object.setPrototypeOf(Child, Parent);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["即 ",(0,r.jsx)(e.code,{children:"Child.__proto__ === Parent"}),"。这是函数本身的原型链操作，而非对象实例的。大家千万要区分 ",(0,r.jsx)(e.code,{children:"Child.__proto__"})," 和 ",(0,r.jsx)(e.code,{children:"Child.prototype"}),"。前者等于 ",(0,r.jsx)(e.code,{children:"Function.prototype"}),"，而后者就是在定义函数时生成的一个普通对象，内部有一个 constructor 指向 Child 本身。"]}),"\n",(0,r.jsx)(e.p,{children:"这样的话，上面示例代码中的所有特性，我们都已经实现了。"}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本章节我用大量的代码来演示了如何把 class 语法改写成 function 语法。虽然在现代的前端开发环境中，这已经越来越没有实际的应用价值，但是却能有效地让我们充分理解 class 语法背后的原子逻辑，包括对象创建、属性定义、原型链等等。"}),"\n",(0,r.jsx)(e.p,{children:"然而本文也仅仅是实现了关键逻辑，还有很多细节受限于篇幅，没有详细讨论，大家如果感兴趣的话，可以尝试补上，当作是一个练习题，继续巩固相关知识。"}),"\n",(0,r.jsxs)(e.p,{children:["经过几章的时间，我们关于 ECMAScript 中",(0,r.jsx)(e.strong,{children:"对象"}),"的学习就先告一段落了。高度抽象的话，核心原子操作无非是",(0,r.jsx)(e.code,{children:"属性"}),"、",(0,r.jsx)(e.code,{children:"原型链"}),"和",(0,r.jsx)(e.code,{children:"遍历"}),"。本文的 ",(0,r.jsx)(e.code,{children:"class"})," 只是语法糖，背后仍然是规范化的各种原子操作的组合。"]}),"\n",(0,r.jsx)(e.p,{children:"熟悉了基本对象的各种操作和概念之后，我们就可以展开学习 JavaScript 的各种高级特性了，它们很大程度上都依赖于对象的这些操作。"})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let i=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F12%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E4%BB%8E%20class%20%E8%AF%AD%E6%B3%95%E8%A7%86%E8%A7%92%E7%9C%8B%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA.md"]={toc:[{text:"class 是什么",id:"class-是什么",depth:2},{text:"构造函数",id:"构造函数",depth:2},{text:"类成员",id:"类成员",depth:2},{text:"类继承",id:"类继承",depth:2},{text:"类静态成员",id:"类静态成员",depth:2},{text:"小结",id:"小结",depth:2}],title:"12 基础篇｜从 class 语法视角看类的继承与实例创建",headingTitle:"12 基础篇｜从 class 语法视角看类的继承与实例创建",frontmatter:{}}}}]);