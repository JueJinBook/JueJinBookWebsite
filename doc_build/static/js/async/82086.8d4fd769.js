"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["82086"],{201085:function(e,r,n){e.exports=n.p+"static/image/0f7f1b4c65828cce96894a4e79de9d03.fa2d5996.webp"},271991:function(e,r,n){e.exports=n.p+"static/image/2169cbbe34290da3c62f613b013eac15.44b6ee21.webp"},59484:function(e,r,n){e.exports=n.p+"static/image/88530828498a937a0f2e5474f5da30f8.9cea7520.webp"},766068:function(e,r,n){e.exports=n.p+"static/image/8fb664fe9799d44fbba6d04e50af80ce.fb3a48d5.webp"},39780:function(e,r,n){e.exports=n.p+"static/image/b38ce5e22c83f2062e57c102a961e19b.27dd1346.webp"},501366:function(e,r,n){e.exports=n.p+"static/image/b642cef31e2a2f26c05a42786e35c2c6.1e793423.webp"},458152:function(e,r,n){n.r(r),n.d(r,{default:()=>j});var l=n(552676),s=n(740453),t=n(59484),c=n(39780),i=n(201085),d=n(271991),o=n(501366),f=n(766068);function a(e){let r=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",h2:"h2",h3:"h3",img:"img",strong:"strong",h4:"h4",ol:"ol",li:"li",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(r.h1,{id:"10-按字节存取buffer上",children:["10-按字节存取：Buffer（上）",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#10-按字节存取buffer上",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["Buffer，操作一块内存块里面的内容。这对于一个服务端的应用来说，是必不可缺的功能之一。很多数据的传输，内容并不是明文的，而是经过序列化过的特殊格式的数据，如 Dubbo、Protobuf、MessagePack 等。再比如，与 MySQL 之间的数据传输，也是按某种格式进行序列化的。这个时候，如果需要按字节解析某块数据，",(0,l.jsx)(r.code,{children:"Buffer"})," 就很必须了。"]}),"\n",(0,l.jsxs)(r.p,{children:["在 Node.js 中，",(0,l.jsx)(r.code,{children:"Buffer"})," 存在于 ",(0,l.jsx)(r.code,{children:"buffer"})," 内置模块中。不过现在的 Node.js 也已经",(0,l.jsxs)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/lib/internal/bootstrap/node.js#L432-L458",title:"https://github.com/nodejs/node/blob/v18.14.2/lib/internal/bootstrap/node.js#L432-L458",target:"_blank",rel:"noopener noreferrer",children:["直接把 ",(0,l.jsx)(r.code,{children:"Buffer"})," 挂载在了 ",(0,l.jsx)(r.code,{children:"globalThis"})," 上"]}),"："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"...\nsetupBuffer();\n...\nfunction setupBuffer() {\n  const {\n    Buffer,\n  } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  // Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n\n  // Create global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis, 'Buffer', {\n    __proto__: null,\n    get() {\n      return _Buffer;\n    },\n    set(value) {\n      _Buffer = value;\n    },\n    enumerable: false,\n    configurable: true,\n  });\n}\n"})}),"\n",(0,l.jsxs)(r.h2,{id:"buffer-的本质是什么",children:[(0,l.jsx)(r.code,{children:"Buffer"})," 的本质是什么？",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#buffer-的本质是什么",children:"#"})]}),"\n",(0,l.jsxs)(r.h3,{id:"黑暗时代-v0x",children:["黑暗时代 v0.x",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#黑暗时代-v0x",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:f,alt:""})}),"\n",(0,l.jsxs)(r.p,{children:["在很多个大版本之前（特指 v0.x 阶段），Node.js 的 ",(0,l.jsx)(r.code,{children:"Buffer"})," 内存完全由自己管理，直接在 ",(0,l.jsx)(r.code,{children:"Buffer"})," 的构造函数阶段",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v0.12/src/node_buffer.cc#L155",title:"https://github.com/nodejs/node/blob/v0.12/src/node_buffer.cc#L155",target:"_blank",rel:"noopener noreferrer",children:"通过 malloc 来分配内存"}),"："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"data = static_cast<char*>(malloc(length));\n"})}),"\n",(0,l.jsxs)(r.p,{children:["并通过 ",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v0.12/src/smalloc.cc#L342-L352",title:"https://github.com/nodejs/node/blob/v0.12/src/smalloc.cc#L342-L352",target:"_blank",rel:"noopener noreferrer",children:"V8 对象的 SetIndexedPropertiesToExternalArrayData 方法"}),"来将其绑定给指定 V8 对象做关联："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"void Alloc(Environment* env,\n           Handle<Object> obj,\n           char* data,\n           size_t length,\n           enum ExternalArrayType type) {\n  assert(!obj->HasIndexedPropertiesInExternalArrayData());\n  env->isolate()->AdjustAmountOfExternalAllocatedMemory(length);\n  size_t size = length / ExternalArraySize(type);\n  obj->SetIndexedPropertiesToExternalArrayData(data, type, size);\n  CallbackInfo::New(env->isolate(), obj, CallbackInfo::Free);\n}\n"})}),"\n",(0,l.jsxs)(r.p,{children:["所以，在 N 个版本前，",(0,l.jsx)(r.code,{children:"Buffer"})," 的本质是一个 ",(0,l.jsx)(r.code,{children:"Buffer"})," 对象以及一块与其绑定的由 Node.js 管理的内存的组合。到 Node.js v4.0 之后就不这样了，它基于 ECMAScript 中的 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 来完成内存块的各种活动。内存就不是通过裸的 ",(0,l.jsx)(r.code,{children:"malloc"})," 由 Node.js 直接管理了。"]}),"\n",(0,l.jsxs)(r.h3,{id:"城堡时代",children:["城堡时代",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#城堡时代",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:o,alt:""})}),"\n",(0,l.jsxs)(r.p,{children:["自从 Node.js 与 io.js 合并后，Node.js 就从刀耕火种的阶段进入了耒耜耕种的阶段。把这一块的生命周期交给 V8 的 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 管理，并有了“池化”的概念。我们本章就讲 ",(0,l.jsx)(r.code,{children:"Buffer"}),"，被遗弃的 ",(0,l.jsx)(r.code,{children:"SlowBuffer"})," 这类就不讲了。所以剩下的就是 ",(0,l.jsx)(r.code,{children:"FastBuffer"})," 了。可能有的读者觉得奇怪。诶？明明不是 ",(0,l.jsx)(r.code,{children:"Buffer"})," 吗？让我们来看看 ",(0,l.jsx)(r.code,{children:"Buffer"})," 是怎么写的吧："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"function Buffer(arg, encodingOrOffset, length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string', 'string', arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg, encodingOrOffset, length);\n}\n\nObjectDefineProperty(Buffer, SymbolSpecies, {\n  __proto__: null,\n  enumerable: false,\n  configurable: true,\n  get() { return FastBuffer; }\n});\n"})}),"\n",(0,l.jsxs)(r.p,{children:["这里先剧透 ",(0,l.jsx)(r.code,{children:"Buffer.alloc()"})," 和 ",(0,l.jsx)(r.code,{children:"Buffer.from()"})," 内部都是返回 ",(0,l.jsx)(r.code,{children:"FastBuffer"}),"。那么为什么它的 ",(0,l.jsx)(r.code,{children:"instanceOf"})," 或者 ",(0,l.jsx)(r.code,{children:"constructor"})," 看出来居然是 ",(0,l.jsx)(r.code,{children:"Buffer"})," 呢？就是",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L135-L137",title:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L135-L137",target:"_blank",rel:"noopener noreferrer",children:"它干的"}),"："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"FastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n"})}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:d,alt:""})}),"\n",(0,l.jsxs)(r.p,{children:["除了 ",(0,l.jsx)(r.code,{children:"Buffer"})," 自身的构建函数（这个对于 Node.js 来说，不推荐 ",(0,l.jsx)(r.code,{children:"new Buffer()"})," 这种用法），像 ",(0,l.jsx)(r.code,{children:"Buffer.alloc()"})," 之类的，也是直勾勾地返回了 ",(0,l.jsx)(r.code,{children:"FastBuffer"}),"。"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"Buffer.alloc = function alloc(size, fill, encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf, fill, 0, buf.length, encoding);\n  }\n  return new FastBuffer(size);\n};\n"})}),"\n",(0,l.jsxs)(r.p,{children:["那 ",(0,l.jsx)(r.code,{children:"FastBuffer"})," 又是什么呢？"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"class FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`, which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength, byteOffset, length) {\n    super(bufferOrLength, byteOffset, length);\n  }\n}\n"})}),"\n",(0,l.jsxs)(r.p,{children:["它就是个 ",(0,l.jsx)(r.code,{children:"Uint8Array"}),"！"]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:i,alt:""})}),"\n",(0,l.jsxs)(r.p,{children:["所以说，",(0,l.jsxs)(r.strong,{children:[(0,l.jsx)(r.code,{children:"Buffer"})," 的本质就是一个继承自 ",(0,l.jsx)(r.code,{children:"Uint8Array"})," 的子类"]}),"，里面添加了许多子类的方法，如 ",(0,l.jsx)(r.code,{children:"writeUint8()"}),"："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"function writeU_Int8(buf, value, offset, min, max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset, 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value', `>= ${min} and <= ${max}`, value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset, buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value, offset = 0) {\n  return writeU_Int8(this, value, offset, 0, 0xff);\n}\n"})}),"\n",(0,l.jsx)(r.p,{children:"如果你想进一步证实，可以尝试一下下面的代码："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"const a = Buffer.from('123');\nconsole.log(a instanceof Uint8Array);  // true\nconsole.log(a.byteOffset);  // 16\nconsole.log(a.buffer);      // ArrayBuffer { byteLength: 8192, ... }\n"})}),"\n",(0,l.jsxs)(r.p,{children:["看吧，它就是个 ",(0,l.jsx)(r.code,{children:"Uint8Array"})," 的子类，而且它所对应的 ",(0,l.jsx)(r.code,{children:"buffer"})," 是一个长达 ",(0,l.jsx)(r.code,{children:"8192"})," 的 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"}),"，然后它的 ",(0,l.jsx)(r.code,{children:"byteOffset"})," 是 ",(0,l.jsx)(r.code,{children:"16"}),"。不过这个情况下仅限于刚启动 Node.js 就执行上面的代码，而且不同 Node.js 也不一定一致。"]}),"\n",(0,l.jsxs)(r.p,{children:["这我们就很容易想到 ",(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.code,{children:"Buffer"})})," ",(0,l.jsx)(r.strong,{children:"是一个"})," ",(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.code,{children:"Uint8Array"})})," ",(0,l.jsx)(r.strong,{children:"的子类，拥有很多"})," ",(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.code,{children:"Buffer"})})," ",(0,l.jsx)(r.strong,{children:"特有的方法，其背后有一个大的"})," ",(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.code,{children:"ArrayBuffer"})})," ",(0,l.jsx)(r.strong,{children:"池子，然后每次生成一个"})," ",(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.code,{children:"Buffer"})})," ",(0,l.jsx)(r.strong,{children:"的时候，都用了这个池子的一段作为它的载体"}),"。"]}),"\n",(0,l.jsxs)(r.h2,{id:"arraybuffer-与-fastbuffer",children:[(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 与 ",(0,l.jsx)(r.code,{children:"FastBuffer"}),(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#arraybuffer-与-fastbuffer",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["我们从前面的内容看，既然某些情况下，一个 ",(0,l.jsx)(r.code,{children:"Buffer"})," 背后是一个很大的 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"}),"，那么很容易就可以推导出来该 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 会被不同 ",(0,l.jsx)(r.code,{children:"Buffer"})," 共用，根据 ",(0,l.jsx)(r.code,{children:"byteOffset"})," 和 ",(0,l.jsx)(r.code,{children:"length"})," 不同读不同内存段。而像 ",(0,l.jsx)(r.code,{children:"Buffer.alloc()"})," 这类 API，我们从代码中能看到，它就是一个原原本本的 ",(0,l.jsx)(r.code,{children:"Uint8Array"})," 子类的构造。"]}),"\n",(0,l.jsxs)(r.h3,{id:"bufferalloc",children:[(0,l.jsx)(r.code,{children:"Buffer.alloc()"}),(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#bufferalloc",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["虽说我们提到了池化，但 ",(0,l.jsx)(r.code,{children:"Buffer"})," 也不是处处都池化的。比如还是上面提到的 ",(0,l.jsx)(r.code,{children:"Buffer.alloc()"}),"，",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L367-L378",title:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L367-L378",target:"_blank",rel:"noopener noreferrer",children:"你看看"}),"："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"Buffer.alloc = function alloc(size, fill, encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf, fill, 0, buf.length, encoding);\n  }\n  return new FastBuffer(size);\n};\n"})}),"\n",(0,l.jsxs)(r.p,{children:["如果我们不 ",(0,l.jsx)(r.code,{children:"fill"}),"，那么就直勾勾返回一个 ",(0,l.jsx)(r.code,{children:"new FastBuffer(size)"}),"，它内部相当于跑了 ",(0,l.jsx)(r.code,{children:"super(size)"}),"，即 ",(0,l.jsx)(r.code,{children:"new Uint8Array(size)"}),"，它的效果除了新增了一些 ",(0,l.jsx)(r.code,{children:"Buffer"})," 特有的方法之外，就是一个直勾勾地构建一个 ",(0,l.jsx)(r.code,{children:"Uint8Array"}),"。而如果要 ",(0,l.jsx)(r.code,{children:"fill"}),"，暂且不管现在 Node.js 怎么写的，里面那个 ",(0,l.jsx)(r.code,{children:"if"})," 逻辑大概应该长这样："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"if (fill !== undefined && fill !== 0 && size > 0) {\n  const buf = new FastBuffer(size);\n  size.fill(fill);\n}\n"})}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"Uint8Array"})," 的 ",(0,l.jsx)(r.code,{children:"fill()"})," 其实与 ",(0,l.jsx)(r.code,{children:"Array"})," 的 ",(0,l.jsx)(r.code,{children:"fill()"})," 差不多，逐个去填充；但是，如果 ",(0,l.jsx)(r.code,{children:"fill"})," 是个某种 ",(0,l.jsx)(r.code,{children:"encoding"})," 下的字符串，那是无法正确填充的。所以，这里 Node.js 就自己给其开辟了一个大内存块（池子）给到某个 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"}),"，然后再对其中 ",(0,l.jsx)(r.code,{children:"byteOffset"})," 之后的 ",(0,l.jsx)(r.code,{children:"length"})," 位直接进行内存级别的填充。所以这个 ",(0,l.jsx)(r.code,{children:"if"})," 的内部是分了两块去写，第一块是 ",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/lib/internal/buffer.js#L1056-L1068",title:"https://github.com/nodejs/node/blob/v18.14.2/lib/internal/buffer.js#L1056-L1068",target:"_blank",rel:"noopener noreferrer",children:"createUnsafeBuffer()"}),"，然后再手动去 ",(0,l.jsx)(r.code,{children:"_fill()"}),"。"]}),"\n",(0,l.jsxs)(r.h4,{id:"createunsafebuffer",children:[(0,l.jsx)(r.code,{children:"createUnsafeBuffer()"}),(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#createunsafebuffer",children:"#"})]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"let zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n"})}),"\n",(0,l.jsxs)(r.p,{children:["这里面的 ",(0,l.jsx)(r.code,{children:"zeroFill"})," 与之前 ",(0,l.jsx)(r.code,{children:"Timer"})," 里面的那个 ",(0,l.jsx)(r.code,{children:"timeoutInfo"})," 类似，是为了打破 C++ 侧与 JavaScript 侧性能桎梏的简单标识。如果 ",(0,l.jsx)(r.code,{children:"zeroFill[0]"})," 为 ",(0,l.jsx)(r.code,{children:"0"})," 时，Node.js 内部在创建 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 时，并不会对其对应创建出来的内存块进行初始化置零操作，而读取、操作一块未被初始化的内存，是“不安全”的，所以这个函数名为 ",(0,l.jsx)(r.code,{children:"createUnsafeBuffer()"}),"。既然 ",(0,l.jsx)(r.code,{children:"createUnsafeBuffer()"})," 不安全，也就是说它创建出来的 ",(0,l.jsx)(r.code,{children:"FastBuffer"})," 不能直接用，我们得对这块内存进行初始化，这就是后面紧跟着的 ",(0,l.jsx)(r.code,{children:"_fill()"})," 做的事了。"]}),"\n",(0,l.jsxs)(r.h4,{id:"_fill",children:[(0,l.jsx)(r.code,{children:"_fill()"}),(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#_fill",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"_fill()"})," 做的事情",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L992-L1061",title:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L992-L1061",target:"_blank",rel:"noopener noreferrer",children:"有两步"}),"："]}),"\n",(0,l.jsxs)(r.ol,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"根据不同需要填充的内容类型，最终都标准化为某种格式的数字、字符串等；"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:["到 C++ 侧代码，把填充内容最终填充到对应的 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 中。"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.p,{children:["如果最终是数字，那么调用的是 ",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L1043-L1051",title:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L1043-L1051",target:"_blank",rel:"noopener noreferrer",children:"TypedArray.prototype.fill()"}),"："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArray.prototype.getByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArray.prototype.fill(buf, value, offset, end);\n  }\n"})}),"\n",(0,l.jsxs)(r.p,{children:["而如果是字符串，则",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L1051-L1058",title:"https://github.com/nodejs/node/blob/v18.14.2/lib/buffer.js#L1051-L1058",target:"_blank",rel:"noopener noreferrer",children:"调用 bindingFill()"}),"，这个就是 C++ 侧的填充逻辑了："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"  } else {\n    const res = bindingFill(buf, value, offset, end, encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value', value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n"})}),"\n",(0,l.jsxs)(r.p,{children:["在 C++ 侧，",(0,l.jsx)(r.code,{children:"bindingFill()"})," 的",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/src/node_buffer.cc#L663-L753",title:"https://github.com/nodejs/node/blob/v18.14.2/src/node_buffer.cc#L663-L753",target:"_blank",rel:"noopener noreferrer",children:"逻辑"}),"中，有一个 ",(0,l.jsx)(r.code,{children:"start_fill"})," 的 ",(0,l.jsx)(r.code,{children:"goto"})," 标签："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"start_fill:\n  if (str_length >= fill_length)\n    return;\n\n  // If str_length is zero, then either an empty buffer was provided, or Write()\n  // indicated that no bytes could be written. If no bytes could be written,\n  // then return -1 because the fill value is invalid. This will trigger a throw\n  // in JavaScript. Silently failing should be avoided because it can lead to\n  // buffers with unexpected contents.\n  if (str_length == 0)\n    return args.GetReturnValue().Set(-1);\n\n  size_t in_there = str_length;\n  char* ptr = ts_obj_data + start + str_length;\n\n  while (in_there < fill_length - in_there) {\n    memcpy(ptr, ts_obj_data + start, in_there);\n    ptr += in_there;\n    in_there *= 2;\n  }\n\n  if (in_there < fill_length) {\n    memcpy(ptr, ts_obj_data + start, fill_length - in_there);\n  }\n"})}),"\n",(0,l.jsxs)(r.p,{children:["这个是个兜底的逻辑，在这之前，我们假设已经填充了一波数据了。那么，若填充数据长度（",(0,l.jsx)(r.code,{children:"str_length"}),"）大于等于目标 ",(0,l.jsx)(r.code,{children:"FastBuffer"})," 的长度（",(0,l.jsx)(r.code,{children:"fill_length"}),"），那么说明填充完了，直接返回；如果填充长度为 ",(0,l.jsx)(r.code,{children:"0"}),"，则返回 ",(0,l.jsx)(r.code,{children:"-1"}),"，以通知外部抛错；否则，开始用一个 ",(0,l.jsx)(r.code,{children:"while"})," 去反复往后填充（",(0,l.jsx)(r.code,{children:"memcpy"}),"）",(0,l.jsx)(r.strong,{children:"自身第一波填充进来的数据（即"})," ",(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.code,{children:"ts_obj_data + start"})})," ",(0,l.jsx)(r.strong,{children:"开始到"})," ",(0,l.jsx)(r.strong,{children:(0,l.jsx)(r.code,{children:"in_there"})})," ",(0,l.jsx)(r.strong,{children:"长度）"}),"，直到目标长度全被填充完。因为 ",(0,l.jsx)(r.code,{children:"memcpy"})," 只能复制填充等长的内存块，所以当目标长度更大的时候，就需要自己控制多次填充。",(0,l.jsx)(r.code,{children:"memcpy"})," 来进行填充的效率比在 JavaScript 侧通过 ",(0,l.jsx)(r.code,{children:"for"})," 循环或者 ",(0,l.jsx)(r.code,{children:"while"})," 循环进行填充的效率要高得多。"]}),"\n",(0,l.jsxs)(r.p,{children:["然后我们把逻辑往回看，在 ",(0,l.jsx)(r.code,{children:"bindingFill()"})," 中，如果判断出来的填充数据类型是类 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 的类型，那么就先",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/src/node_buffer.cc#L685-L691",title:"https://github.com/nodejs/node/blob/v18.14.2/src/node_buffer.cc#L685-L691",target:"_blank",rel:"noopener noreferrer",children:"不管三七二十一填充一遍"}),"，然后再到 ",(0,l.jsx)(r.code,{children:"goto"})," 标签中看后续是直接返回，还是通过 ",(0,l.jsx)(r.code,{children:"while"})," 循环去填充剩余内容："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"  if (Buffer::HasInstance(args[1])) {\n    SPREAD_BUFFER_ARG(args[1], fill_obj);\n    str_length = fill_obj_length;\n    memcpy(\n        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));\n    goto start_fill;\n  }\n"})}),"\n",(0,l.jsxs)(r.p,{children:["上面的 ",(0,l.jsx)(r.code,{children:"Buffer::HasInstance()"})," 就是判断填充数据是否是类 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 的类型。",(0,l.jsx)(r.code,{children:"SPREAD_BUFFER_ARG"})," 宏则是把填充数据里面的元信息提取出来，展开给后续逻辑用——比如 ",(0,l.jsx)(r.code,{children:"fill_obj_length"})," 就是填充数据长度，",(0,l.jsx)(r.code,{children:"ts_obj_data"})," 就是目标内存块的地址，",(0,l.jsx)(r.code,{children:"fill_obj_data"})," 就是填充数据的地址。"]}),"\n",(0,l.jsxs)(r.p,{children:["如果填充数据不是字符串，那么 Node.js 都将其",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/src/node_buffer.cc#L693-L700",title:"https://github.com/nodejs/node/blob/v18.14.2/src/node_buffer.cc#L693-L700",target:"_blank",rel:"noopener noreferrer",children:"强行视为是一个 Uint32 类型进行填充"}),"："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"  // Then coerce everything that's not a string.\n  if (!args[1]->IsString()) {\n    uint32_t val;\n    if (!args[1]->Uint32Value(ctx).To(&val)) return;\n    int value = val & 255;\n    memset(ts_obj_data + start, value, fill_length);\n    return;\n  }\n"})}),"\n",(0,l.jsxs)(r.p,{children:["如果是字符串，那么先",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/src/node_buffer.cc#LL705-L726C4",title:"https://github.com/nodejs/node/blob/v18.14.2/src/node_buffer.cc#LL705-L726C4",target:"_blank",rel:"noopener noreferrer",children:"将字符串按照编码类型给解码成裸内存里面的数据"}),"，然后进行第一波填充："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"  // Can't use StringBytes::Write() in all cases. For example if attempting\n  // to write a two byte character into a one byte Buffer.\n  if (enc == UTF8) {\n    str_length = str_obj->Utf8Length(env->isolate());\n    node::Utf8Value str(env->isolate(), args[1]);\n    memcpy(ts_obj_data + start, *str, std::min(str_length, fill_length));\n\n  } else if (enc == UCS2) {\n    str_length = str_obj->Length() * sizeof(uint16_t);\n    node::TwoByteValue str(env->isolate(), args[1]);\n    if (IsBigEndian())\n      SwapBytes16(reinterpret_cast<char*>(&str[0]), str_length);\n\n    memcpy(ts_obj_data + start, *str, std::min(str_length, fill_length));\n\n  } else {\n    // Write initial String to Buffer, then use that memory to copy remainder\n    // of string. Correct the string length for cases like HEX where less than\n    // the total string length is written.\n    str_length = StringBytes::Write(\n        env->isolate(), ts_obj_data + start, fill_length, str_obj, enc);\n  }\n"})}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"解码逻辑不重要，我就复制出来给你看一眼，没必要细究。知道这一段逻辑是按不同编码进行填充就好。"}),"\n"]}),"\n",(0,l.jsxs)(r.p,{children:["上面这些逻辑做完之后，要么填充完成然后返回了，要么就是跑到后面 ",(0,l.jsx)(r.code,{children:"goto"})," 的逻辑，开始不断 ",(0,l.jsx)(r.code,{children:"memcpy"})," 自身第一波数据直到填充完毕。"]}),"\n",(0,l.jsx)(r.p,{children:"用流程图来还原这段逻辑，就是："}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:c,alt:"死月11流程图.png"})}),"\n",(0,l.jsxs)(r.h4,{id:"bufferalloc-是池化的吗",children:[(0,l.jsx)(r.code,{children:"Buffer.alloc()"})," 是池化的吗？",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#bufferalloc-是池化的吗",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["根据 ",(0,l.jsx)(r.code,{children:"Buffer.alloc()"})," 源码，我们可以看出，如果没有 ",(0,l.jsx)(r.code,{children:"fill"}),"，那就直接返回一个 ",(0,l.jsx)(r.code,{children:"new FastBuffer()"}),"；否则以“不安全”的形式去 ",(0,l.jsx)(r.code,{children:"new FastBuffer()"}),"，不初始化里面的内存块，然后以 ",(0,l.jsx)(r.code,{children:"fill"})," 中的内容去快速填充内存块。"]}),"\n",(0,l.jsxs)(r.h3,{id:"arraybufferallocator",children:[(0,l.jsx)(r.code,{children:"ArrayBuffer::Allocator"}),(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#arraybufferallocator",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["无论池化不池化，",(0,l.jsx)(r.code,{children:"FastBuffer"})," 的背后靠的总归还是 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"}),"。而在 V8 中，如果要创建一个 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"}),"，得在引擎初始化之初，就指定一个叫 ",(0,l.jsx)(r.code,{children:"ArrayBuffer::Allocator"})," 的东西，用于在构造 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 的时候，为其分配一块内存给 V8 用，内存里的内容就是 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 里面各字节的内容了。通常情况下，V8 提供了一个默认的 ",(0,l.jsx)(r.code,{children:"ArrayBuffer::Allocator"})," 类给大伙儿用。像这样："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"v8::Isolate::CreateParams create_params;\ncreate_params.snapshot_blob = nullptr;\ncreate_params.array_buffer_allocator = ArrayBuffer::Allocator::NewDefaultAllocator();\nv8::Isolate* isolate = Isolate::Allocate();\nv8::Isolate::Initialize(isolate, create_params);\n"})}),"\n",(0,l.jsxs)(r.p,{children:["但是 Node.js 偏不，它自己继承了这个 ",(0,l.jsx)(r.code,{children:"ArrayBuffer::Allocator"}),"，自己重载了 ",(0,l.jsx)(r.code,{children:"Allocate"})," 方法，当需要分配指定大小内存的时候，它做了些自己的事情。该类的结构中有",(0,l.jsx)(r.a,{href:"https://github.com/nodejs/node/blob/v18.14.2/src/node_internals.h#L120-L127",title:"https://github.com/nodejs/node/blob/v18.14.2/src/node_internals.h#L120-L127",target:"_blank",rel:"noopener noreferrer",children:"这些东西"}),"："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"class NodeArrayBufferAllocator : public ... {\n  ...\n\n private:\n  uint32_t zero_fill_field_ = 1;\n  std::atomic<size_t> total_mem_usage_ {0};\n  std::unique_ptr<v8::ArrayBuffer::Allocator> allocator_{\n      v8::ArrayBuffer::Allocator::NewDefaultAllocator()};\n};\n"})}),"\n",(0,l.jsx)(r.p,{children:"逐个说明一下："}),"\n",(0,l.jsxs)(r.ol,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"zero_fill_field_"}),"：这个就是前面提到的 ",(0,l.jsx)(r.code,{children:"zeroFill"})," 的本体了，在 JavaScript 修改 ",(0,l.jsx)(r.code,{children:"zeroFill"})," 的值，会影响到这个值，继而影响到该 ",(0,l.jsx)(r.code,{children:"NodeArrayBufferAllocator"})," 的行为；"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"total_mem_usage_"}),"：这是一个线程安全的原子数据，你不用在意它的类型在 C++ 里面怎么操作的，不重要，你只要知道它可以加减，以记录 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"})," 已经分配了一共多少内存；"]}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"allocator_"}),"：V8 默认的 ",(0,l.jsx)(r.code,{children:"Allocator"}),"，其实 ",(0,l.jsx)(r.code,{children:"NodeArrayBufferAllocator"})," 底层还是透传调用了 V8 默认 ",(0,l.jsx)(r.code,{children:"Allocator"})," 的对应方法进行分配内存，只是中间做了些小把戏。"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.p,{children:["接下去，我们看看 ",(0,l.jsx)(r.code,{children:"Allocate"})," 分配内存的时候到底做了什么吧："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"void* NodeArrayBufferAllocator::Allocate(size_t size) {\n  void* ret;\n  if (zero_fill_field_ || per_process::cli_options->zero_fill_all_buffers)\n    ret = allocator_->Allocate(size);\n  else\n    ret = allocator_->AllocateUninitialized(size);\n  if (LIKELY(ret != nullptr))\n    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);\n  return ret;\n}\n"})}),"\n",(0,l.jsxs)(r.p,{children:["可以看出，主要的逻辑区别就在于判断 ",(0,l.jsx)(r.code,{children:"zero_fill_field_"}),"，看看需不需要初始化内存块，即是否是“不安全”创建。如果是安全的，那直接透传调用 ",(0,l.jsx)(r.code,{children:"allocator_"})," 的 ",(0,l.jsx)(r.code,{children:"Allocate()"}),"，否则就调用它的 ",(0,l.jsx)(r.code,{children:"AllocateUninitialized()"}),"。在创建完之后，往 ",(0,l.jsx)(r.code,{children:"total_mem_usage_"})," 上加上申请的内存用量即可。"]}),"\n",(0,l.jsxs)(r.p,{children:["这就像是我开饭店，但菜不是端到自己后厨烧的，而是下单给隔壁饭店让它烧，并还给隔壁提了“这个要放辣”、“这个不放辣”的要求，最后上菜的时候把账算到自己头上。然后我再给自己的店定了个规则，看老板心情（",(0,l.jsx)(r.code,{children:"zero_fill_field_"}),"），心情好了就放辣，心情不好就不放。"]}),"\n",(0,l.jsx)(r.p,{children:"主要我还真见过，以前在一家苍蝇馆点菜，然后点了大部分都饭店自己烧，里面有一道菜就直接从隔壁饭店端过来了\uD83E\uDD21。大呼原来还可以这样。"}),"\n",(0,l.jsxs)(r.h2,{id:"小结",children:["小结",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["本章为大家讲解了 ",(0,l.jsx)(r.code,{children:"Buffer"})," 的本质是什么。在 Node.js v0.x 的时代，",(0,l.jsx)(r.code,{children:"Buffer"})," 本质是在 C++ 侧实现了一个 JavaScript 的类，然后自己管理与该类绑定的内存块。而之后，Node.js 就使用 ECMAScript 标准里面的 ",(0,l.jsx)(r.code,{children:"Uint8Array"})," 作为 ",(0,l.jsx)(r.code,{children:"Buffer"})," 的基座，让 ",(0,l.jsx)(r.code,{children:"Buffer"})," 等同于 ",(0,l.jsx)(r.code,{children:"FastBuffer"}),"，并继承自 ",(0,l.jsx)(r.code,{children:"Uint8Array"}),"，背靠的是 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"}),"。"]}),"\n",(0,l.jsxs)(r.p,{children:["在 ",(0,l.jsx)(r.code,{children:"Buffer.alloc()"})," 中，C++ 侧通过 ",(0,l.jsx)(r.code,{children:"memcpy()"})," 等操作为其构造的 ",(0,l.jsx)(r.code,{children:"FastBuffer"})," 进行填充操作。而在底层该块逻辑的内存管理中，自身代理了一个 ",(0,l.jsx)(r.code,{children:"ArrayBuffer::Allocate"}),"，以便其可以方便地创建“安全”或“不安全”的 ",(0,l.jsx)(r.code,{children:"ArrayBuffer"}),"，这样可以尽可能在一些逻辑中减少冗余逻辑。"]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:t,alt:""})})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),e.components);return r?(0,l.jsx)(r,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}let j=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F10-%E6%8C%89%E5%AD%97%E8%8A%82%E5%AD%98%E5%8F%96%EF%BC%9ABuffer%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{text:"`Buffer` 的本质是什么？",id:"buffer-的本质是什么",depth:2},{text:"黑暗时代 v0.x",id:"黑暗时代-v0x",depth:3},{text:"城堡时代",id:"城堡时代",depth:3},{text:"`ArrayBuffer` 与 `FastBuffer`",id:"arraybuffer-与-fastbuffer",depth:2},{text:"`Buffer.alloc()`",id:"bufferalloc",depth:3},{text:"`createUnsafeBuffer()`",id:"createunsafebuffer",depth:4},{text:"`_fill()`",id:"_fill",depth:4},{text:"`Buffer.alloc()` 是池化的吗？",id:"bufferalloc-是池化的吗",depth:4},{text:"`ArrayBuffer::Allocator`",id:"arraybufferallocator",depth:3},{text:"小结",id:"小结",depth:2}],title:"10-按字节存取：Buffer（上）",headingTitle:"10-按字节存取：Buffer（上）",frontmatter:{}}}}]);