"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["9291"],{569171:function(e,n,t){t.r(n),t.d(n,{default:()=>a});var r=t(552676),s=t(740453);let i=t.p+"static/image/1a4b306f9239e7e7479b42ce6c30b1e7.c01725d9.webp",o=t.p+"static/image/c91f1cd9037c24436e11552011639bac.7809f0f1.webp",c=t.p+"static/image/3e6933d4d6683dc70e480aa410cf4d8e.31169ad1.webp";function l(e){let n=Object.assign({p:"p",img:"img",h1:"h1",a:"a",strong:"strong",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",blockquote:"blockquote",ol:"ol"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"上节中，我们了解了为什么学习单元测试，学习单元测试有哪些好处，并且详细地讲解了 useEventListener，之所以说 useEventListener 是 DOM Hooks 的核心，是因为许多 DOM 操作都会用到这个钩子。"}),"\n",(0,r.jsx)(n.p,{children:"本章将会全面讲解 DOM 类相关的 Hooks，全面了解相关 Hooks 的测试方法。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"DOM类Hooks.png"})}),"\n",(0,r.jsxs)(n.h1,{id:"6基础篇自定义-hooks-之-jest二dom-类-hooks",children:["6.基础篇｜自定义 Hooks 之 Jest（二）：DOM 类 Hooks",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6基础篇自定义-hooks-之-jest二dom-类-hooks",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useHover"}),"：监听 DOM 元素是否有鼠标悬停。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"分析："})," 这个 Hooks 相对简单，既然是监听 DOM 元素，那第一个必然是监听那个 DOM 元素，也就是 ",(0,r.jsx)(n.strong,{children:"target（目标元素）"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["那么我们监听到元素要干什么，就是我们的第二个入参，分为：",(0,r.jsx)(n.strong,{children:"鼠标进入"}),"、",(0,r.jsx)(n.strong,{children:"鼠标离开"}),"、",(0,r.jsx)(n.strong,{children:"状态改变"}),"这三个函数即可。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import useEventListener from "../useEventListener";\nimport useSafeState from "../useSafeState";\nimport type { BasicTarget } from "../utils";\n\ninterface Options {\n  onEnter?: () => void;\n  onLeave?: () => void;\n  onChange?: (isHover: boolean) => void;\n}\n\nconst useHover = (target: BasicTarget, options?: Options): boolean => {\n  const { onEnter, onLeave, onChange } = options || {};\n  const [isHover, setIsHover] = useSafeState<boolean>(false);\n\n  useEventListener(\n    "mouseenter",\n    () => {\n      onEnter?.();\n      onChange?.(true);\n      setIsHover(true);\n    },\n    target\n  );\n\n  useEventListener(\n    "mouseleave",\n    () => {\n      onLeave?.();\n      onChange?.(false);\n      setIsHover(false);\n    },\n    target\n  );\n\n  return isHover;\n};\n\nexport default useHover;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这里，我把 target 的类型单独拿出来，",(0,r.jsx)(n.code,{children:"BasicTarget"}),"为："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'import type { MutableRefObject } from "react";\n\ntype TargetValue<T> = T | undefined | null;\n\ntype TargetType = HTMLElement | Element | Window | Document;\n\ntype BasicTarget<T extends TargetType = Element> =\n  | TargetValue<T>\n  | MutableRefObject<TargetValue<T>>;\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsxs)(n.h2,{id:"单元测试",children:["单元测试",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单元测试",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"虽然 useHover 的操作比较简单，但如何进行单元测试呢？如何去模拟鼠标移入、移出事件呢？"}),"\n",(0,r.jsxs)(n.p,{children:["在测试 useEventListener 的时候，我们介绍了如何运用",(0,r.jsx)(n.code,{children:"document.createElement"})," 来创建元素，除了这种方式，再介绍一种：",(0,r.jsx)(n.strong,{children:"@testing-library/react"})," 进行测试"]}),"\n",(0,r.jsxs)(n.p,{children:["可能有许多小伙伴喜欢用 ",(0,r.jsx)(n.code,{children:"enzyme"})," 做单元测试，但 enzyme 测试也有很多问题（如：组件触发后，不能改变组件 useState 的值），所以还是使用官方推荐的 ",(0,r.jsx)(n.code,{children:"'@testing-library/react'"})," 测试比较好。"]}),"\n",(0,r.jsxs)(n.p,{children:["这里我主要介绍下 ",(0,r.jsx)(n.code,{children:"'@testing-library/react'"})," 的 render 和 fireEvent 的方法，掌握这两个，一般的单元测试就 OK 了。"]}),"\n",(0,r.jsxs)(n.h2,{id:"render",children:["render",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#render",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["render 主要返回三类，分别是：",(0,r.jsx)(n.code,{children:"getBy..."}),"、",(0,r.jsx)(n.code,{children:"queryBy..."}),"、",(0,r.jsx)(n.code,{children:"findBy..."}),"。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getBy..."}),"：用于定位页面",(0,r.jsx)(n.strong,{children:"已经存在的 DOM 元素"}),"，如果不存在，则抛出异常。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"queryBy..."}),"：用于定位页面",(0,r.jsx)(n.strong,{children:"不存在的 DOM 元素"}),"，如果不存在，则返回 null，不会抛出异常。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"findBy..."}),"：定位页面中的",(0,r.jsx)(n.code,{children:"异常元素"}),"，如果不存在，则抛出异常。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["三个的方法基本一致，所以这里就以 ",(0,r.jsx)(n.strong,{children:"getBy"})," 为例："]}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{children:"方法"}),"\n",(0,r.jsx)(n.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getByText"}),"\n",(0,r.jsx)(n.td,{children:"按元素查找文本内容"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getByRole"}),"\n",(0,r.jsx)(n.td,{children:"按角色去查找"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getByLabelText"}),"\n",(0,r.jsx)(n.td,{children:"按标签或aria标签文本内容查找"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getByPlaceholderText"}),"\n",(0,r.jsx)(n.td,{children:"按输入placeholder查找"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getByAltText"}),"\n",(0,r.jsx)(n.td,{children:"按img的alt属性查找"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getByTitle"}),"\n",(0,r.jsx)(n.td,{children:"按标题属性或svg标题标记查找"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getByDisplayValue"}),"\n",(0,r.jsx)(n.td,{children:"按表单元素查找当前值"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getByTestId"}),"\n",(0,r.jsx)(n.td,{children:"按数据测试查找属性"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["一般而言，会用到 ",(0,r.jsx)(n.code,{children:"getByText"})," 和 ",(0,r.jsx)(n.code,{children:"getByRole"})," 来获取对应的元素。"]}),"\n",(0,r.jsxs)(n.h2,{id:"fireevent",children:["fireEvent",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#fireevent",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"fireEvent"}),"：用于实际的操作，也就是模拟点击、键盘、表单等操作。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 两种写法\nfireEvent(node: HTMLElement, event: Event) \nfireEvent[eventName](node: HTMLElement, eventProperties: Object)\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"包含的方法："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export type EventType = | 'keyDown' | 'keyPress' | 'keyUp' | 'focus' | 'blur' | 'change' | 'input' ....\n"})}),"\n",(0,r.jsx)(n.p,{children:"可以看出 EventType 将所有的方法都包含在内，我们只需要正常使用即可："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"fireEvent(element, new MouseEvent('click', options?));\nfireEvent.click(element, options?); // 推荐这种写法\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"测试用例",children:["测试用例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试用例",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["经过 render 和 fireEvent 的加持，我们书写 useHover 的测试用例也就简单了很多，首先我们通过 render 创建一个 div，再利用 fireEvent 模拟",(0,r.jsx)(n.strong,{children:"移入和移出"}),"即可。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import { render, fireEvent, renderHook, act } from "@testing-library/react";\nimport useHover from ".";\n\ndescribe("useHover", () => {\n  it("should be defined", () => {\n    expect(useHover).toBeDefined();\n  });\n\n  it("测试Hover", () => {\n    const { getByText } = render(<div>Hover</div>);\n\n    const { result } = renderHook(() => useHover(getByText("Hover")));\n    \n    // void 的目的是告诉fireEvent方法返回的是undefined\n    act(() => void fireEvent.mouseEnter(getByText("Hover")));\n    expect(result.current).toBe(true);\n    \n    act(() => void fireEvent.mouseLeave(getByText("Hover")));\n    expect(result.current).toBe(false);\n  });\n\n  it("测试功能", () => {\n    const { getByText } = render(<div>Hover</div>);\n    let count = 0;\n    let flag = false;\n    const { result } = renderHook(() =>\n      useHover(getByText("Hover"), {\n        onEnter: () => {\n          count++;\n        },\n        onChange: (isFlag) => {\n          flag = isFlag;\n        },\n        onLeave: () => {\n          count++;\n        },\n      })\n    );\n\n    expect(result.current).toBe(false);\n    \n    act(() => void fireEvent.mouseEnter(getByText("Hover")));\n    expect(result.current).toBe(true);\n    expect(count).toBe(1);\n    expect(flag).toBe(true);\n    \n    act(() => void fireEvent.mouseLeave(getByText("Hover")));\n    expect(result.current).toBe(false);\n    expect(count).toBe(2);\n    expect(flag).toBe(false);\n  });\n});\n\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"测试结果："})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"问：useEventListener 和 useHover 的测试方法有什么不同？一定要按这种模式进行测试吗？"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"答：测试 useEventListener 的方式是通过 document.createElement 去模拟对应的 div，而 useHover 是通过 render 模拟 div，从本质上来说两者的方法一样，只是通过 render 更加直观，要说两者最大的区别就是，render 创建 div 的方式是 tsx 文件，document.createElement 创建 div 的方式是 ts文件，这点切记即可。"}),"\n",(0,r.jsx)(n.p,{children:"其次，测试的方式肯定不止于这两种，但我们创建自己的 Hooks，这两种方式就足够了，如果想要彻底学习 Jest，还需要大量的时间单独了解，这里主要是扩展 Hooks 的使用。"}),"\n"]}),"\n",(0,r.jsxs)(n.h1,{id:"usedocumentvisibility",children:["useDocumentVisibility",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usedocumentvisibility",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useDocumentVisibility"}),"：监听页面是否可见，即当前可见元素的上下文环境。由此可以知道当前文档（即为页面）是在背后，或是不可见的隐藏的标签页。"]}),"\n",(0,r.jsx)(n.p,{children:"这个 Hooks 非常的简单，通过 useEventListener 去监听 visibilitychange 即可，但这个钩子却很有趣，问题也比较多，接下来一起看看。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'import { useSafeState, useEventListener } from "..";\nimport { isBrowser } from "../utils";\n\ntype VisibilityProps = "hidden" | "visible" | undefined;\n\nconst getVisibility = () => {\n  if (!isBrowser) {\n    return "visible";\n  }\n  return document.visibilityState;\n};\n\nconst useDocumentVisibility = (): VisibilityProps => {\n  const [visibility, setVisibility] = useSafeState(() => getVisibility());\n\n  useEventListener(\n    "visibilitychange",\n    () => {\n      setVisibility(getVisibility());\n    },\n    document\n  );\n\n  return visibility;\n};\n\nexport default useDocumentVisibility;\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsxs)(n.h2,{id:"visibilitychange-问题",children:["visibilitychange 问题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#visibilitychange-问题",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["判断页面是否可见需要通过 ",(0,r.jsx)(n.code,{children:"document.visibilityState"})," 去判断，但有趣的就在这里，我们分别看下",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/visibilityState",target:"_blank",rel:"noopener noreferrer",children:"中文"}),"和",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilityState",target:"_blank",rel:"noopener noreferrer",children:"英文"}),"的版本："]}),"\n",(0,r.jsx)(n.p,{children:"可以看到，中文和英文关于 visibilityState 缺少了个 prerender 的状态，那么就好奇了，visibilityState 到底有没有 prerender 这个状态呢？"}),"\n",(0,r.jsx)(n.p,{children:"这时我们主要看看 ts 的类型是什么："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"很明显，状态并没有 prerender，可以说是一个漏洞。"}),"\n",(0,r.jsx)(n.p,{children:"那么有小伙伴问了，为什么不直接用 VisibilityState，而是要自己去写呢？"}),"\n",(0,r.jsxs)(n.p,{children:["看看这张图（我同事上的 ",(0,r.jsx)(n.strong,{children:"visibilityState"})," 类型）："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"企业微信截图_b8bfdfa4-102a-4c2d-bb7b-8c1918308524.png"})}),"\n",(0,r.jsx)(n.p,{children:"可以发现 visibilityState 存在两种版本的定义，为了比较稳妥的方式，采用内置属性，这样就不会依赖 ts 中的 lib 了。"}),"\n",(0,r.jsxs)(n.h2,{id:"单元测试jestmock",children:["单元测试：jest.mock",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单元测试jestmock",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们之前讲了两种创建 div 的方式，那么该如何模拟整个网页的状态呢？如何模拟对应的环境又变成了一个有趣的点。"}),"\n",(0,r.jsxs)(n.p,{children:["这时可以通过 Mock 去模拟对应的环境，主要讲解下 ",(0,r.jsx)(n.code,{children:"jest.fn()"}),"、",(0,r.jsx)(n.code,{children:"jest.mock()"}),"、",(0,r.jsx)(n.code,{children:"jest.spyOn()"})," 三个方法。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"jest.fn(implementation)："})," 这种方式是 Mock 函数最简单的方式，如果没有定义函数内部的实现，则会返回 undefined。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"jest.mock(moduleName, factory, options)："})," 用来 mock 一些模块或者文件。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"jest.spyOn(object, methodName)："})," 返回一个 mock function，是 jest.fn 的语法糖，而且能够追踪对应的调用信息。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"然后我们需要通过这三个函数来模拟页面即可，通过 mockReturnValue 控制当前页面的状态。"}),"\n",(0,r.jsxs)(n.h2,{id:"测试用例-1",children:["测试用例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试用例-1",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { renderHook, act } from \"@testing-library/react\";\nimport useDocumentVisibility from \".\";\nconst mockIsBrowser = jest.fn();\nconst mockVisibilityState = jest.spyOn(document, 'visibilityState', 'get');\n\njest.mock('../utils/isBrowser', () => {\n  return {\n    __esModule: true,\n    get default() {\n      return mockIsBrowser();\n    },\n  };\n});\n\nafterAll(() => {\n  jest.clearAllMocks();\n});\n\ndescribe(\"useDocumentVisibility\", () => {\n  it(\"should be defined\", () => {\n    expect(useDocumentVisibility).toBeDefined();\n  });\n\n  it('模拟浏览器更新是否影响', () => {\n    mockVisibilityState.mockReturnValue('hidden');\n    mockIsBrowser.mockReturnValue(false);\n    const { result } = renderHook(() => useDocumentVisibility());\n    expect(result.current).toEqual('visible');\n  });\n\n  it('模拟页面是否隐藏', () => {\n    mockVisibilityState.mockReturnValue('hidden');\n    mockIsBrowser.mockReturnValue(true);\n    const { result } = renderHook(() => useDocumentVisibility());\n    expect(result.current).toEqual('hidden');\n    mockVisibilityState.mockReturnValue('visible');\n    act(() => {\n      document.dispatchEvent(new Event('visibilitychange'));\n    });\n    expect(result.current).toEqual('visible');\n  });\n});\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"无论是 useEventListener 中模拟 useRef，还是 useDocumentVisibility 中的浏览器，都是模拟对应的场景，而不是真正去做 useRef 和浏览器，不要局限于代码的写法与作用，而是应该去模拟对应的场景，这点是我认为单元测试与逻辑代码的主要区别。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"结果："})}),"\n",(0,r.jsxs)(n.h1,{id:"useinviewport",children:["useInViewport",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useinviewport",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useInViewport："})," 用于观察元素是否可见区域，以及元素可见的比例，这里需要 ",(0,r.jsx)(n.strong,{children:"IntersectionObserver"}),"，它可以帮助我们实现这个 Hook，具体可查看：",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API",target:"_blank",rel:"noopener noreferrer",children:"Intersection Observer API"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"我们根据官网来确定 useInViewport 的出入参。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["入参：target（监听目标的元素）、可配置项（threshold、rootMargin、root），其中要注意下 threshold，它的范围必须是 ",(0,r.jsx)(n.strong,{children:"0 ～ 1 的数字"}),"。"]}),"\n",(0,r.jsx)(n.li,{children:"出参：inViewport（元素是否可见）、ratio（出现的比例，但必须配合 threshold 触发）。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"代码演示"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { useEffect } from "react";\nimport useSafeState from "../useSafeState";\nimport { getTarget } from "../utils";\n\ninterface Options {\n  root?: any;\n  rootMargin?: string;\n  threshold?: number | number[];\n}\n\nconst useInViewport = (target: any, options?: Options) => {\n  const [inViewport, setInViewport] = useSafeState<boolean>();\n  const [ratio, setRatio] = useSafeState<number>();\n\n  useEffect(() => {\n    const element = getTarget(target);\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          setInViewport(entry.isIntersecting);\n          setRatio(entry.intersectionRatio);\n        }\n      },\n      {\n        ...options,\n        root: options?.root ? getTarget(options.root) : null,\n      }\n    );\n\n    observer?.observe(element);\n\n    return () => {\n      observer?.disconnect();\n    };\n  }, [target]);\n\n  return [inViewport, ratio] as const;\n};\n\nexport default useInViewport;\n\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsxs)(n.h2,{id:"单元测试模拟-intersectionobserver",children:["单元测试：模拟 IntersectionObserver",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单元测试模拟-intersectionobserver",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 useInViewport 中，核心是使用 ",(0,r.jsx)(n.strong,{children:"IntersectionObserver API"}),"，但在 Jest 中是不存在的，所以我们要根据 mock 去模拟这个 API。"]}),"\n",(0,r.jsx)(n.p,{children:"我们主要使用了 IntersectionObserver 的 observe 和 disconnect，所以我们只需要模拟这两个方法即可，如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"    mockIntersectionObserver = jest.fn();\n    mockIntersectionObserver.mockReturnValue({\n      observe: () => null,\n      disconnect: () => null,\n    });\n    window.IntersectionObserver = mockIntersectionObserver;\n"})}),"\n",(0,r.jsx)(n.p,{children:"要注意，这里并没有去模拟 observe 和 disconnect 具体的方法，那么究竟如何实现浏览器中的 IntersectionObserver API 的方法呢？"}),"\n",(0,r.jsxs)(n.p,{children:["为了解决这一问题，我们可以使用 ",(0,r.jsx)(n.code,{children:"mockFn.mock.calls"})," 方法。它包含对此模拟函数进行的所有调用的调用参数的数组。数组中的每一项都是调用期间传递的参数数组。简单地说，它会将每次执行的方法进行",(0,r.jsx)(n.strong,{children:"截取"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["回过头来再看看 useInViewport 中使用了 isIntersecting 和 intersectionRatio 两个属性，所以我们通过 ",(0,r.jsx)(n.strong,{children:"mock.calls"})," 的配合，直接改变对应的值即可完成模拟，如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"    const [onChange] = calls[calls.length - 1];\n\n    act(() => {\n      onChange([\n        {\n          container,\n          isIntersecting: true,\n          intersectionRatio: 0.5,\n        },\n      ]);\n    });\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"测试用例-2",children:["测试用例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试用例-2",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { renderHook, act } from "@testing-library/react";\nimport useInViewport from ".";\n\ndescribe("useInViewport", () => {\n  it("should be defined", () => {\n    expect(useInViewport).toBeDefined();\n  });\n\n  let container: HTMLDivElement;\n  let mockIntersectionObserver: jest.Mock<any, any>;\n\n  beforeEach(() => {\n    container = document.createElement("div");\n    document.body.appendChild(container);\n\n    mockIntersectionObserver = jest.fn();\n    mockIntersectionObserver.mockReturnValue({\n      observe: () => null,\n      disconnect: () => null,\n    });\n    window.IntersectionObserver = mockIntersectionObserver;\n  });\n\n  afterEach(() => {\n    document.body.removeChild(container);\n  });\n\n  it("测试基础功能", () => {\n    const { result } = renderHook(() => useInViewport(container));\n    const calls = mockIntersectionObserver.mock.calls;\n\n    const [onChange] = calls[calls.length - 1];\n\n    act(() => {\n      onChange([\n        {\n          container,\n          isIntersecting: true,\n          intersectionRatio: 0.5,\n        },\n      ]);\n    });\n    const [inViewport, ratio] = result.current;\n    expect(inViewport).toBeTruthy();\n    expect(ratio).toBe(0.5);\n  });\n\n  it("测试第二参数节点", () => {\n    const { result } = renderHook(() =>\n      useInViewport(container, { root: container })\n    );\n    const calls = mockIntersectionObserver.mock.calls;\n\n    const [onChange] = calls[calls.length - 1];\n    act(() => {\n      onChange([\n        {\n          container,\n          isIntersecting: true,\n        },\n      ]);\n    });\n    const [inViewport] = result.current;\n    expect(inViewport).toBeTruthy();\n  });\n});\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["useInViewport 在进行单元测试的时候并不用具体模拟对应的 API，而是通过 mock 去模拟对应的方法，并且此方法不用管内部实现，只需要模拟值即可，以",(0,r.jsx)(n.strong,{children:"结果"}),"为导向，完成整个测试。"]}),"\n",(0,r.jsx)(n.p,{children:"另外，在模拟 IntersectionObserver、div 节点时，最好通过 beforeEach 去创建，不要直接在函数外部去写，以免造成环境污染。"}),"\n"]}),"\n",(0,r.jsxs)(n.h1,{id:"usenetwork",children:["useNetWork",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usenetwork",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useNetWork："})," 用于查看网络状态的 Hook，具体可查看：",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation",target:"_blank",rel:"noopener noreferrer",children:"NetworkInformation"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["由于每个浏览器的内核不同，在这里就不做兼容，以谷歌浏览器为主，除了官网提供的属性外，多加一个 ",(0,r.jsx)(n.code,{children:"online"}),"：是否连接网络的字段。"]}),"\n",(0,r.jsx)(n.p,{children:"我们只需要通过 useEventListener 监听 online（有网状态下触发）和 offonline（无网状态下触发）即可。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"代码演示"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import { useEventListener, useSafeState } from "..";\n\ninterface NetWorkProps {\n  online?: boolean; // 网络是否为在线\n  rtt?: number; // 当前连接下评估的往返时延\n  type?:\n    | "bluetooth"\n    | "cellular"\n    | "ethernet"\n    | "none"\n    | "wifi"\n    | "wimax"\n    | "other"\n    | "unknown"; // 设备使用与所述网络进行通信的连接的类型\n  saveData?: boolean; // 用户代理是否设置了减少数据使用的选项\n  downlinkMax?: number; // 最大下行速度（单位：兆比特/秒）\n  effectiveType?: "slow-2g" | "2g" | "3g" | "4g"; // 网络连接的类型\n}\n\nconst getConnection = (): NetWorkProps | undefined => {\n  if (navigator && typeof navigator === "object") {\n    const nav = navigator as any;\n    return {\n      rtt: nav.connection?.rtt,\n      type: nav.connection?.type,\n      saveData: nav.connection?.saveData,\n      downlinkMax: nav.connection?.downlinkMax,\n      effectiveType: nav.connection?.effectiveType,\n    };\n  }\n};\n\nconst useNetwork = (): NetWorkProps => {\n  const [net, setNet] = useSafeState(() => ({\n    online: navigator?.onLine,\n    ...getConnection(),\n  }));\n\n  useEventListener("online", () => {\n    setNet((v) => ({\n      ...v,\n      online: true,\n    }));\n  });\n\n  useEventListener("offline", () => {\n    setNet((v) => ({\n      ...v,\n      online: false,\n    }));\n  });\n\n  return net;\n};\n\nexport default useNetwork;\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsxs)(n.h2,{id:"单元测试dispatchevent",children:["单元测试：dispatchEvent",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单元测试dispatchevent",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"那么我们想想这个钩子该如何进行测试呢？首先来想想主要面临的两个问题："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"不同的浏览器对应的字段不同，难道要模拟不同的浏览器？将所有的字段都进行模拟？"}),"\n",(0,r.jsx)(n.li,{children:"如何模拟有网和无网的状态？"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"针对第一个问题，如果模拟对应的浏览器，即模拟内核是很麻烦的，像这种测试就没有必要去模拟，当然也不是所有的字段都要模拟，只要走代码的顺序即可"}),"\n",(0,r.jsx)(n.p,{children:"至于如何去模拟对应的状态，这里就要使用 dispatchEvent 这个方法。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dispatchEvent："})," 自定义触发事件。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"使用方法："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"window.dispatchEvent(event) // event：事件\n"})}),"\n",(0,r.jsx)(n.p,{children:"dispatchEvent 相当于 fireEvent 的超集， fireEvent 只能模拟对应的事件（如：点击），而 dispatchEvent 不但可以模拟 fireEvent 中的事件，还能够模拟 navigator 中的事件，比如：网络、浏览器尺寸等。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"问：那为什么不直接用 dispatchEvent，还推荐使用 fireEvent 呢？"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"答：dispatchEvent 确实可以模拟各种事件，功能要比 fireEvent 强大，之所以推荐 fireEvent，主要因为 dispatchEvent 的使用比较复杂，有些不存在 ts 的提示，并且在日常开发 Hooks 的过程中，很少会用到，所以推荐使用：fireEvent。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"dispatchEvent 的使用："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// 模拟点击事件\nconst ele = document.getElementById("id");\nele.dispatchEvent(new MouseEvent("click", { ... }))\n\n//模拟鼠标移动\ndocument.dispatchEvent(\n  new MouseEvent(\'mousemove\', {\n    clientX: x,\n    clientY: y,\n    screenX: x,\n    screenY: y,\n  })\n)\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"测试用例-3",children:["测试用例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试用例-3",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { renderHook, act } from "@testing-library/react";\nimport useNetwork from "./";\n\ndescribe("useNetwork", () => {\n  it("should be defined", () => {\n    expect(useNetwork).toBeDefined();\n  });\n\n  it("切换网络状态", () => {\n    const { result } = renderHook(() => useNetwork());\n    expect(result.current.online).toBeTruthy();\n    act(() => {\n      window.dispatchEvent(new Event("offline")); //关闭\n    });\n    expect(result.current.online).toBeFalsy();\n    act(() => {\n      window.dispatchEvent(new Event("online"));  //开启\n    });\n    expect(result.current.online).toBeTruthy();\n  }a);\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"结果："})}),"\n",(0,r.jsxs)(n.h1,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["本节介绍了 ",(0,r.jsx)(n.strong,{children:"useHover"}),"、",(0,r.jsx)(n.strong,{children:"useDocumentVisibility"}),"、",(0,r.jsx)(n.strong,{children:"useNetWork"}),"、 ",(0,r.jsx)(n.strong,{children:"useInViewport"})," 四个 Hooks。"]}),"\n",(0,r.jsx)(n.p,{children:"通过本章和上章我们了解到各种测试的方法，简单总结下："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"如何利用 renderHook 和 act 测试自定义 Hooks；"}),"\n",(0,r.jsxs)(n.li,{children:["创建 DOM 进行测试主要有两种方式：",(0,r.jsx)(n.strong,{children:"document.createElement"})," 和 ",(0,r.jsx)(n.strong,{children:"render"})," 方式；"]}),"\n",(0,r.jsxs)(n.li,{children:["测试点击、鼠标移动推荐使用 ",(0,r.jsx)(n.strong,{children:"fireEvent"}),"，如果是测试网络、浏览器等事件可通过 ",(0,r.jsx)(n.strong,{children:"dispatchEvent"}),"；"]}),"\n",(0,r.jsx)(n.li,{children:"比较难的测试需要通过 Jest 中的 mock 进行对应的模拟，注意模拟的是所需的环境；"}),"\n",(0,r.jsx)(n.li,{children:"单元测试的思想与代码实现的思想不太相同，不要拥有固有的逻辑进行测试，如：useEventListener 的 useRef 的测试、useCss 的单元测试。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"学习完本节，我们已经完全掌握有关 DOM 类 Hooks 的开发与测试方法，下章进行场景类 Hooks 的讲解。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F6.%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%20Hooks%20%E4%B9%8B%20Jest%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADOM%20%E7%B1%BB%20Hooks.md"]={toc:[{text:"单元测试",id:"单元测试",depth:2},{text:"render",id:"render",depth:2},{text:"fireEvent",id:"fireevent",depth:2},{text:"测试用例",id:"测试用例",depth:2},{text:"visibilitychange 问题",id:"visibilitychange-问题",depth:2},{text:"单元测试：jest.mock",id:"单元测试jestmock",depth:2},{text:"测试用例",id:"测试用例-1",depth:2},{text:"单元测试：模拟 IntersectionObserver",id:"单元测试模拟-intersectionobserver",depth:2},{text:"测试用例",id:"测试用例-2",depth:2},{text:"单元测试：dispatchEvent",id:"单元测试dispatchevent",depth:2},{text:"测试用例",id:"测试用例-3",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);