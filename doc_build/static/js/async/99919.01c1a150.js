"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["99919"],{50013:function(e,r,s){s.r(r),s.d(r,{default:()=>a});var l=s(552676),n=s(740453);let c=s.p+"static/image/eae3a531799ad33bc397e2022706ec8c.5497aea3.webp",i=s.p+"static/image/5730892d24faea2be469f2afae504eb7.fd60d3ab.webp";function d(e){let r=Object.assign({p:"p",h1:"h1",a:"a",code:"code",h2:"h2",ul:"ul",li:"li",h3:"h3",strong:"strong",pre:"pre",blockquote:"blockquote",img:"img"},(0,n.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(r.p,{children:"在前面两篇文章中，我们分别介绍了 Polyfill 和 Babel，那么本篇文章，我们就将两者结合起来，介绍下 Babel 中 polyfill 的解决方案。在上一篇文章中，我们简单介绍了 babel 转义的过程，先将源码解析为抽象语法树 AST，然后根据配置使用不同的插件对 AST 进行转换，然后再将转换后的 AST 输出为可编译的代码。"}),"\n",(0,l.jsx)(r.p,{children:"Babel 默认在编译时只会转换新的 JavaScript 语法（syntax），但不会转换 API，比如 Set、Maps、Generator、Proxy、Promise 等全局对象，以及一些定义在全局对象上的方法（比如Array.from、Object.assign）都不会被转译。"}),"\n",(0,l.jsxs)(r.h1,{id:"12在-babel-中使用-polyfill",children:["12.在 Babel 中使用 Polyfill",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#12在-babel-中使用-polyfill",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["关于 babel 转换 API 这个问题，Babel 官方的一个解决方案是推出 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"})," 库。其核心依赖是 ",(0,l.jsx)(r.code,{children:"core-js@2"})," 和 ",(0,l.jsx)(r.code,{children:"regenerater-runtime/runtime"}),"。",(0,l.jsx)(r.code,{children:"core-js"})," 是 JS 标准库的 ",(0,l.jsx)(r.code,{children:"polyfill"}),"，为其提供垫片能力，",(0,l.jsx)(r.code,{children:"regenerater-runtime/runtime"})," 用来转译 ",(0,l.jsx)(r.code,{children:"generators"})," 和 ",(0,l.jsx)(r.code,{children:"async"})," 函数。"]}),"\n",(0,l.jsxs)(r.p,{children:["下面我们分别来介绍一下 ",(0,l.jsx)(r.code,{children:"core-js"})," 和 ",(0,l.jsx)(r.code,{children:"regenerator-runtime/runtime"}),"。"]}),"\n",(0,l.jsxs)(r.h2,{id:"core-js",children:["core-js",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#core-js",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"core-js"})," 是一个 JavaScript 标准库，里面包含了 ",(0,l.jsx)(r.code,{children:"ESCAScreipt 2020"})," 在内的多项特性的 ",(0,l.jsx)(r.code,{children:"polyfill"}),"。其作用主要有以下几点"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"支持最新的 ECMAScript 标准；"}),"\n",(0,l.jsx)(r.li,{children:"ECMAScript 标准库提案；"}),"\n",(0,l.jsxs)(r.li,{children:["一些 ",(0,l.jsx)(r.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWHATWG",target:"_blank",rel:"noopener noreferrer",children:"WHATGW"})," / ",(0,l.jsx)(r.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FWorld_Wide_Web_Consortium",target:"_blank",rel:"noopener noreferrer",children:"W3C"})," 标准（跨平台或者 ECMAScript 相关）；"]}),"\n",(0,l.jsx)(r.li,{children:"和 babel 密切集成。"}),"\n"]}),"\n",(0,l.jsxs)(r.p,{children:["在 ",(0,l.jsx)(r.code,{children:"core-js3"})," 出来之前，最常用的版本是 ",(0,l.jsx)(r.code,{children:"core-js@2"}),"，但是 ",(0,l.jsx)(r.code,{children:"core-js@2"})," 的一个最大问题就是包的体积太大(大约有2M)，因为其有很多被重复引用的文件。"]}),"\n",(0,l.jsxs)(r.h3,{id:"core-js3的重要改变",children:["core-js@3的重要改变",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#core-js3的重要改变",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["为了解决上述 ",(0,l.jsx)(r.code,{children:"core-js2"})," 的问题，",(0,l.jsx)(r.code,{children:"core-js@3"})," 使用 ",(0,l.jsx)(r.code,{children:"Monorepo"})," 进行拆包，拆成了 5 个相关的包，分别如下："]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["core-js：是整个 ",(0,l.jsx)(r.code,{children:"core-js"})," 的核心，提供了基础的垫片能力，但是直接使用 ",(0,l.jsx)(r.code,{children:"core-js"})," 会污染全局命名空间和对象原型；"]}),"\n",(0,l.jsxs)(r.li,{children:["core-js-pure：",(0,l.jsx)(r.code,{children:"core-js-pure"})," 提供了独立的命名空间，不污染全局变量；"]}),"\n",(0,l.jsxs)(r.li,{children:["core-js-compact：根据 ",(0,l.jsx)(r.code,{children:"Browserslist"})," 维护了不同宿主环境、不同版本下对应需要支持特性的集合；"]}),"\n",(0,l.jsxs)(r.li,{children:["core-js-builder：结合 ",(0,l.jsx)(r.code,{children:"core-js-compact"})," 以及 ",(0,l.jsx)(r.code,{children:"core-js"}),"，并利用 ",(0,l.jsx)(r.code,{children:"webpack"})," 能力，根据需求打包出 ",(0,l.jsx)(r.code,{children:"core-js"})]}),"\n",(0,l.jsx)(r.li,{children:"core-js-bundle"}),"\n"]}),"\n",(0,l.jsxs)(r.p,{children:["对于 ECMAScript 中已经稳定的功能，",(0,l.jsx)(r.code,{children:"core-js"})," 已经几乎完全支持，并在 ",(0,l.jsx)(r.code,{children:"core-js@3"})," 中引入了一些新的功能"]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["对于一些已经加入到 ",(0,l.jsx)(r.code,{children:"ES2016-ES2019"})," 中的提案，现在已经被标记为稳定功能；"]}),"\n",(0,l.jsxs)(r.li,{children:["增加了 ",(0,l.jsx)(r.code,{children:"proposals"})," 配置项，对处在提案阶段的 api 提供支持，但是因为提案阶段并不稳定，在正式加入标准之前，可能会有大的改动，需要谨慎使用；对于一些改变巨大的提案，也进行了对应的更新；"]}),"\n",(0,l.jsxs)(r.li,{children:["增加了对一些 web 标准的支持，比如 URL 和 ",(0,l.jsx)(r.code,{children:"URLSearchParams"}),"；"]}),"\n",(0,l.jsx)(r.li,{children:"删除了一些过时的特性；"}),"\n"]}),"\n",(0,l.jsxs)(r.p,{children:["但是 ",(0,l.jsx)(r.code,{children:"babel/polyfill"})," 并没有提供从 ",(0,l.jsx)(r.code,{children:"core-js@2"})," 到 ",(0,l.jsx)(r.code,{children:"core-js@3"})," 的平滑升级，所以 ",(0,l.jsx)(r.strong,{children:"当 core-js 升级到3.0的版本后，安装 babel@2 的 @babel/polyfill 将被弃用。"})]}),"\n",(0,l.jsxs)(r.p,{children:["在 ",(0,l.jsx)(r.code,{children:"babel7.4.0"})," 之前，我们可以直接安装 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"})," 来转换 API，但是在 ",(0,l.jsx)(r.code,{children:"7.4.0"})," 之后的 ",(0,l.jsx)(r.code,{children:"Babel"})," 版本，就会提示让我们分开引入 ",(0,l.jsx)(r.code,{children:"core-js/stable"}),"(默认安装3.x)和 ",(0,l.jsx)(r.code,{children:"regenerator-runtime/runtime"})]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:'warning @babel/polyfill@7.4.4: � As of Babel 7.4.0, this\npackage has been deprecated in favor of directly\nincluding core-js/stable (to polyfill ECMAScript\nfeatures) and regenerator-runtime/runtime\n(needed to use transpiled generator functions):\n\n  > import "core-js/stable";\n  > import "regenerator-runtime/runtime";\n'})}),"\n",(0,l.jsxs)(r.h2,{id:"使用姿势",children:["使用姿势",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#使用姿势",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["根据上述的介绍，我们已经知道了，",(0,l.jsx)(r.code,{children:"@babel/polyfill"})," 库已经是时代的产物了。但是我们仍然看下要如何使用 ",(0,l.jsx)(r.code,{children:"babel/polyfill"}),"（如上介绍，现在已经推荐使用 ",(0,l.jsx)(r.code,{children:"core-js/stable"})," 和 ",(0,l.jsx)(r.code,{children:"regenerator-runtime/runtime"}),"，但是我认为，这两个包是 ",(0,l.jsx)(r.code,{children:"babel/polyfill"})," 的子包，可以认为是同一种解决方案）转译 API。"]}),"\n",(0,l.jsxs)(r.h3,{id:"单独使用",children:["单独使用",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#单独使用",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["如果不依赖前端构建工具单独使用的话，使用姿势很简单，只需要安装依赖 ",(0,l.jsx)(r.code,{children:"npm install --save core-js regenerator-runtime"}),"，然后需要在业务代码中需要进行引入："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:'import "core-js/stable";\nimport "regenerator-runtime/runtime";\n'})}),"\n",(0,l.jsxs)(r.p,{children:["但是要注意，这个时候就不能安装 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"})," 这个包了，因为 ",(0,l.jsx)(r.code,{children:"@bable/polyfill"})," 也是依赖 ",(0,l.jsx)(r.code,{children:"core-js"})," 并且会锁死 ",(0,l.jsx)(r.code,{children:"2.x"})," 版本，",(0,l.jsx)(r.code,{children:"core-js 2.x"})," 的版本中是没有 stable 文件目录的，所以 ",(0,l.jsx)(r.code,{children:'import "core-js/stable"'})," 这个引用就会报错。"]}),"\n",(0,l.jsxs)(r.h3,{id:"在-webpack-中使用",children:["在 webpack 中使用",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#在-webpack-中使用",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["那么如果我们依赖前端构建工具，比如 ",(0,l.jsx)(r.code,{children:"webpack"})," 的话，我们需要怎么使用呢？安装依赖的过程不会变，仍然是需要安装 ",(0,l.jsx)(r.code,{children:"npm install --save core-js regenerator-runtime"}),"这两个依赖。"]}),"\n",(0,l.jsxs)(r.p,{children:["安装完依赖之后，我们需要更改 ",(0,l.jsx)(r.code,{children:"webpack"})," 的配置文件中的 ",(0,l.jsx)(r.code,{children:"entry"})," 配置，webpack 配置如下："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"// webpack.config.js\nconst path = require('path');\nmodule.exports = {\n  entry: ['core-js/stable', 'regenerator-runtime/runtime', './main.js'],\n  output: {\n    filename: 'dist.js',\n    path: path.resolve(__dirname, '')\n  },\n  mode: 'development'\n};\n"})}),"\n",(0,l.jsxs)(r.h1,{id:"babelpreset-env",children:["@babel/preset-env",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#babelpreset-env",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["在上述 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"})," 的解决方案中，是将垫片全量进行引入的，完整的 ",(0,l.jsx)(r.code,{children:"polyfills"})," 文件非常大，及其不利于我们打包出来的体积和页面的性能。"]}),"\n",(0,l.jsxs)(r.p,{children:["除了上述的方式，我们还可以使用 ",(0,l.jsx)(r.code,{children:"Babel"})," 的预设或者插件做到按需使用。"]}),"\n",(0,l.jsxs)(r.p,{children:["在上一节中，我们简单介绍了 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 这个预设。",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 预设包含所有标准的最新特性，转换那些已经被正式纳入 TC39 中的语法；该预设在 ",(0,l.jsx)(r.code,{children:"Babel6"})," 的时候的名字是 ",(0,l.jsx)(r.code,{children:"babel-preset-env"})," 在 ",(0,l.jsx)(r.code,{children:"Babel7"})," 后，更名为 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"}),"，该预设不只可以在编译时通过转换 AST 来进行语法转换，还有一个重要功能就是根据设置的参数针对性处理 polyfill。"]}),"\n",(0,l.jsx)(r.p,{children:"例如，在不设置参数的情况下，最基础的配置文件如下："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:'module.exports = {\n  presets: ["@babel/preset-env"],\n  plugins: []\n}\n'})}),"\n",(0,l.jsxs)(r.p,{children:["下面我们介绍几个 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 常用的配置项。"]}),"\n",(0,l.jsxs)(r.h2,{id:"targets",children:["targets",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#targets",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["我们可以设置 targets 配置项，来指定项目的运行环境。",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 会自动根据设置的目标环境来判断需要转译哪些语法和 API。如果没有配置 targets，那么 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 会接着寻找项目中的 ",(0,l.jsx)(r.code,{children:"browserslist"})," 配置，",(0,l.jsx)(r.code,{children:"browserslist"})," 配置只会控制语法的目标环境。如果 ",(0,l.jsx)(r.code,{children:"targets"})," 和 ",(0,l.jsx)(r.code,{children:"browserslist"})," 都没有，那么 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 就会全量处理语法和 API。"]}),"\n",(0,l.jsx)(r.p,{children:"比如我们可以将我们的目标环境设置为最近 3个 版本的浏览器和 安卓4.4 以上的系统以及 iOS 9.0 以上的系统，那么 babel 只会兼容该目标环境的代码。对应的配置如下（貌似这个已经出现了好几次了）："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"module.exports = {\n  presets: [[\"@babel/preset-env\", {\n  	targets: {\n      browsers: [\n        'last 3 versions',\n        'Android >= 4.4',\n        'iOS >= 9.0',\n      ],\n    },\n  ]],\n  plugins: []\n}\n"})}),"\n",(0,l.jsxs)(r.h2,{id:"usebuiltins",children:["useBuiltIns",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#usebuiltins",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"useBuiltIns"})," 配置决定了 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 该如何处理 ",(0,l.jsx)(r.code,{children:"polyfill"}),'。其选项有几个几个值："usage" 、"entry" 、和 false, 默认为 false。下面我们来一一介绍下：']}),"\n",(0,l.jsxs)(r.h3,{id:"false",children:["false",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#false",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["如果使用默认的 false，",(0,l.jsx)(r.code,{children:"polyfill"})," 就不会被按需处理会被全部引入。"]}),"\n",(0,l.jsxs)(r.h3,{id:"entry",children:["entry",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#entry",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["如果 ",(0,l.jsx)(r.code,{children:"useBuiltIn"})," 设置为 ",(0,l.jsx)(r.code,{children:"entry"}),"，需要手动导入 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"}),"，其使用姿势在上一节中已经介绍过了，你可以直接导入 ",(0,l.jsx)(r.code,{children:"core-js"})," 和 ",(0,l.jsx)(r.code,{children:"regenerator-runtime"})," 也可以在 ",(0,l.jsx)(r.code,{children:"webpack"})," 的 ",(0,l.jsx)(r.code,{children:"entry"})," 中设置。",(0,l.jsx)(r.code,{children:"useBuiltIn: entry"})," 的作用就是会自动将",(0,l.jsx)(r.code,{children:'import "core-js/stable"'})," 和 ",(0,l.jsx)(r.code,{children:'import "regenerator-runtime/runtime"'})," 转换为目标环境的按需引入。"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:'module.exports = {\n  presets: [["@babel/preset-env", {\n  	useBuiltIns: "entry",\n  ]],\n  plugins: []\n}\n'})}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"entry"}),"配置只针对目标环境，而不是具体代码，所以 ",(0,l.jsx)(r.code,{children:"Babel"})," 会针对目标环境引入所有的 ",(0,l.jsx)(r.code,{children:"polyfill"})," 扩展包，用不到的polyfill也可能会引入进来。所以，如果不需要考虑打包产物的大小，可以使用该配置。"]}),"\n",(0,l.jsxs)(r.h3,{id:"usage",children:["usage",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#usage",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["如果 ",(0,l.jsx)(r.code,{children:"useBuiltIns"})," 设置为 ",(0,l.jsx)(r.code,{children:"usage"}),"，则不需要手动导入 ",(0,l.jsx)(r.code,{children:"polyfill"}),"，",(0,l.jsx)(r.code,{children:"babel"})," 检测出此配置会自动进行 ",(0,l.jsx)(r.code,{children:"polyfill"})," 的引入。其配置如下："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:'module.exports = {\n  presets: [["@babel/preset-env", {\n  	useBuiltIns: "usage",\n  ]],\n  plugins: []\n}\n'})}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"usage"})," 模式下，Babel 除了会针对目标环境引入 ",(0,l.jsx)(r.code,{children:"polyfill"})," 的同时也会考虑项目代码代码中使用了哪些 ES6+ 的新特性，两者取一个最小的集合作为 polyfill 的导入。"]}),"\n",(0,l.jsxs)(r.p,{children:["所以，如果你希望代码尽可能的精简，那么 ",(0,l.jsx)(r.code,{children:"usage"})," 模式是一个不错的选择，并且这也是官方推荐的使用姿势。"]}),"\n",(0,l.jsxs)(r.h2,{id:"core-js-1",children:["core-js",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#core-js-1",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 预设也可以让你自己选择需要使用 2 还是 3。并且这个参数只有 ",(0,l.jsx)(r.code,{children:"useBuiltIn"})," 设置为 ",(0,l.jsx)(r.code,{children:"usage"})," 或者 ",(0,l.jsx)(r.code,{children:"entry"})," 时才会生效。"]}),"\n",(0,l.jsx)(r.p,{children:"该配置默认值为 2，但是如果我们需要某些最新的 API 时，需要将其设置为 3。"}),"\n",(0,l.jsxs)(r.h1,{id:"babelruntime",children:["@babel/runtime",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#babelruntime",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"@babel/runtime"})," 是含有 babel 编译所需要的一些 ",(0,l.jsx)(r.code,{children:"helpers"})," 函数。同时还提供了 ",(0,l.jsx)(r.code,{children:"regenerator-runtime"}),"，对 ",(0,l.jsx)(r.code,{children:"generator"})," 和 ",(0,l.jsx)(r.code,{children:"async "}),"函数进行编译降级。"]}),"\n",(0,l.jsxs)(r.p,{children:["具体的使用我们在下面的 ",(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 中会介绍。"]}),"\n",(0,l.jsxs)(r.h1,{id:"babelplugin-transform-runtime",children:["@babel/plugin-transform-runtime",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#babelplugin-transform-runtime",children:"#"})]}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"A plugin that enables the re-use of Babel's injected helper code to save on codesize."}),"\n"]}),"\n",(0,l.jsxs)(r.p,{children:["下面我们来介绍 babel 生态的另一个重要的插件：",(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 其作用是可以重复使用 babel 注入的 helpers 函数，以节省代码体积（这句话先记下来，稍后会给大家解释）。"]}),"\n",(0,l.jsxs)(r.p,{children:["Babel 在转译 syntax 时，有时候会使用一些辅助的函数来帮忙，比如我们需要转译 class 类，默认的转译结果如下: ",(0,l.jsx)(r.a,{href:"https://www.babeljs.cn/repl#?browsers=ie%20%3C%3D11&build=&builtIns=usage&corejs=3.6&spec=false&loose=false&code_lz=MYGwhgzhAEAKCmAnCB7AdtA3gKGtCYAngBLwggoAUaYAtvAJRa57SLwAuArohgAalyKaABJMNegF8-LSdjkA3MImgAvABZg0AcwIYAvNDTwA7nCSo0lBtmDpUIeADoK2yhq26tTgiTIVKAHIQAEsIEMCGBgBuIA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=true&timeTravel=false&sourceType=script&lineWrap=true&presets=env%2Creact%2Cstage-0%2Cstage-1%2Cstage-2%2Cstage-3%2Ctypescript%2Cflow&prettier=true&targets=&version=7.17.1&externalPlugins=&assumptions=%7B%7D",target:"_blank",rel:"noopener noreferrer",children:"babel playground"})]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:i,alt:""})}),"\n",(0,l.jsxs)(r.p,{children:["我们可以看到，在 ",(0,l.jsx)(r.code,{children:"class"})," 语法的转换过程中， ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 自定义了 ",(0,l.jsx)(r.code,{children:"_classCallCheck"})," 这个函数来辅助转换。这个函数就是 ",(0,l.jsx)(r.code,{children:"helper"})," 函数。这是 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 在做语法转换的时候，注入了这些 ",(0,l.jsx)(r.code,{children:"helpers"})," 函数声明，以便语法转换后使用。"]}),"\n",(0,l.jsxs)(r.p,{children:["从上图中可以看到，",(0,l.jsx)(r.code,{children:"helper"})," 函数在转译后的文件中被定义了一遍。也就是说，项目中有多少个文件中存在需要转换的 class，那么在打包的产物中就会有多少个 ",(0,l.jsx)(r.code,{children:"_classCallCheck helper"})," 函数，这显然不“程序员”。"]}),"\n",(0,l.jsxs)(r.p,{children:["所以解决思路是将这些 ",(0,l.jsx)(r.code,{children:"helpers"})," 函数都放入到某个依赖包中，在使用的时候直接从该包中引入即可，这样打包出来的产物中，就只有一份 ",(0,l.jsx)(r.code,{children:"helpers"})," 函数。上面提到的 ",(0,l.jsx)(r.code,{children:"@babel/runtime"})," 就是这个依赖包。"]}),"\n",(0,l.jsxs)(r.p,{children:["那么 ",(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 这个插件是干嘛的呢？",(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 是帮我们用工程化的手段解决来解决问题的。我们使用 ",(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 自动将需要引入的 ",(0,l.jsx)(r.code,{children:"helpers"})," 函数替换为 ",(0,l.jsx)(r.code,{children:"@babel/runtime"})," 中的引用。"]}),"\n",(0,l.jsxs)(r.p,{children:["我们在 ",(0,l.jsx)(r.a,{href:"https://www.babeljs.cn/repl#?browsers=ie%20%3C%3D11&build=&builtIns=usage&corejs=3.6&spec=false&loose=false&code_lz=MYGwhgzhAEAKCmAnCB7AdtA3gKGtCYAngBLwggoAUaYAtvAJRa57SLwAuArohgAalyKaABJMNegF8-LSdjkA3MImgAvABZg0AcwIYAvNDTwA7nCSo0lBtmDpUIeADoK2yhq26tTgiTIVKAHIQAEsIEMCGBgBuIA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=true&timeTravel=false&sourceType=script&lineWrap=true&presets=env%2Creact%2Cstage-0%2Cstage-1%2Cstage-2%2Cstage-3%2Ctypescript%2Cflow&prettier=true&targets=&version=7.17.1&externalPlugins=%40babel%2Fplugin-transform-runtime%407.17.0&assumptions=%7B%7D",target:"_blank",rel:"noopener noreferrer",children:"babel-playground"})," 上加入了 ",(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 这个插件之后，可以看到原来在文件中定义的 ",(0,l.jsx)(r.code,{children:"_classCallCheck helper"})," 函数变成了从 ",(0,l.jsx)(r.code,{children:'"@babel/runtime/helpers/classCallCheck"'})," 中引入。"]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:c,alt:""})}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 还有另一个关键的作用就是对 API 进行转换的时候，避免污染全局变量。"]}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.code,{children:"babel/polyfill"})," 的处理机制是，对于例如 ",(0,l.jsx)(r.code,{children:"Array.from"})," 等静态方法，直接在 ",(0,l.jsx)(r.code,{children:"global.Array"})," 上添加；对于例如 ",(0,l.jsx)(r.code,{children:"includes"})," 等实例方法，直接在 ",(0,l.jsx)(r.code,{children:"global.Array.prototype"})," 上添加。"]}),"\n",(0,l.jsx)(r.p,{children:"但是这样直接修改了全局变量的原型，有可能会带来意想不到的问题。这个问题在开发第三方库的时候尤其重要，因为我们开发的第三方库修改了全局变量，有可能和另一个也修改了全局变量的第三方库发生冲突，或者和使用我们的第三方库的使用者发生冲突。公认的较好的编程范式中，也不鼓励直接修改全局变量、"}),"\n",(0,l.jsxs)(r.p,{children:["我们都知道，",(0,l.jsx)(r.code,{children:"polyfill"})," 的作用是对浏览器的全局对象重写其 API，以提供垫片能力。比如 ",(0,l.jsx)(r.code,{children:"promise"}),"，",(0,l.jsx)(r.code,{children:"polyfill"})," 会重写 ",(0,l.jsx)(r.code,{children:"window.promise"}),"，为不支持 ",(0,l.jsx)(r.code,{children:"peomise"})," 的浏览器提供 ",(0,l.jsx)(r.code,{children:"promise"})," 的能力。但是这样做会污染全局变量（这也是 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"})," 的一个缺点）。"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:'var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");\nvar _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));\nvar obj = _promise["default"].resolve();\n'})}),"\n",(0,l.jsxs)(r.p,{children:["从代码可以看出，",(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 将 ",(0,l.jsx)(r.code,{children:"Promise"})," 转换为 ",(0,l.jsx)(r.code,{children:'_promise["default"]'}),"，而 ",(0,l.jsx)(r.code,{children:'_promise["default"]'})," 拥有ES标准里 ",(0,l.jsx)(r.code,{children:"Promise"})," 所有的功能。现在，即使浏览器没有 ",(0,l.jsx)(r.code,{children:"Promise"}),"，我们的代码也能正常运行。"]}),"\n",(0,l.jsxs)(r.p,{children:["我们来总结下，",(0,l.jsx)(r.code,{children:"transform-runtime"})," 插件的两个主要作用："]}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["可以直接将 ",(0,l.jsx)(r.code,{children:"helpers"})," 从文件中定义改为从 ",(0,l.jsx)(r.code,{children:"@babel/runtime"})," 中引入，避免了多次引入 ",(0,l.jsx)(r.code,{children:"helpers"})," 辅助函数。"]}),"\n",(0,l.jsxs)(r.li,{children:["可以将 ",(0,l.jsx)(r.code,{children:"@babel/ployfill"})," 中 ",(0,l.jsx)(r.code,{children:"API"})," 的 ",(0,l.jsx)(r.code,{children:"polyfill"})," 直接修改原型改为从 ",(0,l.jsx)(r.code,{children:"@babel/runtime-corejs3/helpers "}),"中获取，避免对全局变量和原型的污染。"]}),"\n"]}),"\n",(0,l.jsxs)(r.h1,{id:"总结",children:["总结",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["本篇文章我们介绍了 ",(0,l.jsx)(r.code,{children:"polyfill"})," 在 ",(0,l.jsx)(r.code,{children:"Babel"})," 中的实践，并且介绍了 ",(0,l.jsx)(r.code,{children:"Babel"})," 官方推出的 ",(0,l.jsx)(r.code,{children:"polyfill"})," 库 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"}),"，然后分别介绍了 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"})," 的使用姿势以及其两个重要依赖，",(0,l.jsx)(r.code,{children:"core-js"})," 和 ",(0,l.jsx)(r.code,{children:"regenerator-runtime"}),"。如果直接使用 ",(0,l.jsx)(r.code,{children:"@babel/polyfill"})," 有一个弊端就是不能实现按需加载。所以推荐使用 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 预设。将 ",(0,l.jsx)(r.code,{children:"useBuiltIns"})," 设置为 ",(0,l.jsx)(r.code,{children:"usage"})," 就可以根据设置的 ",(0,l.jsx)(r.code,{children:"targets"})," 目标环境和业务代码中实际用到的最新 ES 语法和 API 来进行按需加载。"]}),"\n",(0,l.jsxs)(r.p,{children:["只是使用 ",(0,l.jsx)(r.code,{children:"@babel/preset-env"})," 还存在问题就是会有重复的 ",(0,l.jsx)(r.code,{children:"helpers"})," 辅助函数并且在转换的时候会污染环境变量和原型，使用",(0,l.jsx)(r.code,{children:"@babel/plugin-transform-runtime"})," 可以解决这两个问题。"]}),"\n",(0,l.jsxs)(r.p,{children:["通过本篇以及前几篇有关 ",(0,l.jsx)(r.code,{children:"polyfill"})," 和 ",(0,l.jsx)(r.code,{children:"Babel"})," 的介绍文章之后，你是不是已经了解了 Babel 是怎么将 ES6+ 新功能转换为 ES5 的了？（不了解的再好好看文章呀 (つД｀)･ﾟ･"]}),"\n",(0,l.jsx)(r.p,{children:"那么接下来将继续给大家给介绍如何优化 webpack 配置项 (๑•̀ㅂ•́)و✧"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,n.ah)(),e.components);return r?(0,l.jsx)(r,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}let a=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E5%88%9D%E6%8E%A2%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%2F12.%E5%9C%A8%20Babel%20%E4%B8%AD%E4%BD%BF%E7%94%A8%20Polyfill.md"]={toc:[{text:"core-js",id:"core-js",depth:2},{text:"core-js@3的重要改变",id:"core-js3的重要改变",depth:3},{text:"使用姿势",id:"使用姿势",depth:2},{text:"单独使用",id:"单独使用",depth:3},{text:"在 webpack 中使用",id:"在-webpack-中使用",depth:3},{text:"targets",id:"targets",depth:2},{text:"useBuiltIns",id:"usebuiltins",depth:2},{text:"false",id:"false",depth:3},{text:"entry",id:"entry",depth:3},{text:"usage",id:"usage",depth:3},{text:"core-js",id:"core-js-1",depth:2}],title:"总结",headingTitle:"总结",frontmatter:{}}}}]);