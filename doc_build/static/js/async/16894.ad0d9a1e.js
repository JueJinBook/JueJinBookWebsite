"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16894"],{477462:function(n,e,r){r.r(e),r.d(e,{default:()=>d});var l=r(552676),i=r(740453);function a(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",pre:"pre",code:"code",strong:"strong",blockquote:"blockquote",ol:"ol"},(0,i.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.h1,{id:"第19章接口三灵活安全地运用接口",children:["第19章—接口三｜灵活、安全地运用接口",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第19章接口三灵活安全地运用接口",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"\uFEFF从前两讲起，我们开始了接口专题的学习。关于接口的一般使用方法其实已经讲得差不多了，本讲介绍一些使用接口时的注意事项，尽量帮助大家避开一些弯路。"}),"\n",(0,l.jsx)(e.p,{children:"具体来说，本讲将涉及以下内容："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"接口的嵌套组合"}),"\n",(0,l.jsx)(e.li,{children:"从空接口中取值"}),"\n",(0,l.jsx)(e.li,{children:"空接口的值比较"}),"\n",(0,l.jsx)(e.li,{children:"接口与nil"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"接口的嵌套组合",children:["接口的嵌套组合",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#接口的嵌套组合",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"我们都知道，结构体是允许嵌套使用的。实际上，接口也可以。"}),"\n",(0,l.jsx)(e.p,{children:"举例来说，我们使用浏览器进行下载文件的时候，通常会在保存、另存为和取消之间做出选择。抛开取消不谈，选择保存时，浏览器会自动执行下载和保存两个步骤；选择另存为时，浏览器会先询问文件保存的路径，再开始下载和保存。"}),"\n",(0,l.jsx)(e.p,{children:"如果我们把选择路径、下载、保存看作是待下载文件的3个接口，并用代码来表示，它很可能会是这样的："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"// ChooseDest 选择保存路径\r\ntype ChooseDest interface {\r\n	chooseDest(localFile string)\r\n}\r\n\r\n// Download 执行下载\r\ntype Download interface {\r\n	download()\r\n}\r\n\r\n// Save 保存文件\r\ntype Save interface {\r\n	save()\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"细心的朋友会发现，无论何种方式下载文件，其中的下载和保存都是必需且顺序不变的。所以，我们不妨再创建一个接口，使其包含下载和保存两个接口，代码如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"// DownloadAndSave 下载和保存\r\ntype DownloadAndSave interface {\r\n   Download\r\n   Save\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"在使用时，我们便可直接声明DownloadAndSave类型的变量去执行下载和保存了，示例代码如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   //声明一个file类型的变量，命名为downloadFileExample\r\n   downloadFileExample := new(file)\r\n   //使用ChooseDest接口\r\n   var chooseDest ChooseDest\r\n   chooseDest = downloadFileExample\r\n   chooseDest.chooseDest("")\r\n   //使用DownloadAndSave接口\r\n   var downloadAndSave DownloadAndSave\r\n   downloadAndSave = downloadFileExample\r\n   downloadAndSave.download()\r\n   downloadAndSave.save()\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"如上代码所示，无需单独声明Download和Save接口变量，仅使用DownloadAndSave接口变量便可调用download()和save()两个方法。"}),"\n",(0,l.jsxs)(e.h2,{id:"从空接口取值",children:["从空接口取值",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#从空接口取值",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"在上一讲中，曾经使用过类似下面这样的案例："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   dataOutput("Hello")\r\n}\r\n\r\nfunc dataOutput(data interface{}) {\r\n   fmt.Println(data)\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"为了实现“将传入的参数按原样输出”的需求，我们编写了dataOutput()函数。该函数所需的参数是空接口，能接纳所有类型的数据，然后通过调用fmt.Println()将数据输出，满足了需求。"}),"\n",(0,l.jsx)(e.p,{children:"现在，如果想从data中获取数据，并赋值给某个变量，该如何做呢？显然，可以如下实现："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func dataOutput(data interface{}) {\r\n   fmt.Println(data)\r\n   var stringValue string = data\r\n   fmt.Println(stringValue)\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"暂且将上述方法当作方法A。"}),"\n",(0,l.jsx)(e.p,{children:"再看如下实现："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func dataOutput(data interface{}) {\r\n   fmt.Println(data)\r\n   stringValue := data.(string)\r\n   fmt.Println(stringValue)\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"暂且将该方法当作方法B。"}),"\n",(0,l.jsx)(e.p,{children:"猜一猜，哪种方法可以呢？"}),"\n",(0,l.jsxs)(e.p,{children:["答案是：",(0,l.jsx)(e.strong,{children:"方法B"}),"。"]}),"\n",(0,l.jsx)(e.p,{children:"是不是很奇怪，为什么方法A不行呢？实际上，当我们按照方法A去写时，GoLand会自动识别出问题，提示：Cannot use 'data' (type interface{}) as the type string，意思是无法将类型为interface{}的data变量作为string类型使用。"}),"\n",(0,l.jsx)(e.p,{children:"这是因为在进行类型断言前，谁也不知道data里放的是何类型。举个形象一点的例子，虽然箱子里装了某样货物，但箱子依然还是箱子，是不能将箱子当货使用的。"}),"\n",(0,l.jsx)(e.p,{children:"所以，在从空接口中取值时，切记要使用类型断言。"}),"\n",(0,l.jsxs)(e.h2,{id:"空接口的值比较",children:["空接口的值比较",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#空接口的值比较",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"撸起袖子，我们一起来挑战几道题。"}),"\n",(0,l.jsx)(e.p,{children:"不要用电脑编译和运行下面的代码，先猜猜它们的运行结果。"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   var a interface{} = 10\r\n   var b interface{} = "10"\r\n   fmt.Println(a == b)\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"相信各位都能回答正确，上面这段代码运行结果为："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"false"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"挑战继续，再来试试这个："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   var a interface{} = []int{1, 2, 3, 4, 5}\r\n   var b interface{} = []int{1, 2, 3, 4, 5}\r\n   fmt.Println(a == b)\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"上面这段代码运行后，程序会发生宕机。报错信息如下："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"panic: runtime error: comparing uncomparable type []int"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"从字面上看，错误原因是程序比较了不可比较的类型——[]int。"}),"\n",(0,l.jsxs)(e.p,{children:["在Go语言中，",(0,l.jsx)(e.strong,{children:"有两种数据是无法比较的，它们是：Map和Slice"}),"，强行比较会引发如上宕机错误。"]}),"\n",(0,l.jsx)(e.p,{children:"数组是可以比较的，而且会比较数组中每个元素的值。因此，只需将上述代码改为："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   var a interface{} = [5]int{1, 2, 3, 4, 5}\r\n   var b interface{} = [5]int{1, 2, 3, 4, 5}\r\n   fmt.Println(a == b)\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"程序便会正常运行，输出结果："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"true"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"接口与nil",children:["接口与nil",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#接口与nil",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"在Go语言中，nil是一个特殊的值，它只能赋值给指针类型和接口类型。"}),"\n",(0,l.jsx)(e.p,{children:"让我们来挑战下面这段代码，还是不要用电脑编译运行，猜一猜它的输出结果："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   var a interface{} = nil\r\n   fmt.Println(a == nil)\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"这段代码运行后，控制台将输出："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"true"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"应该没什么疑问吧？继续看下面的代码："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'type Person struct {\r\n   name   string\r\n   age    int\r\n   gender int\r\n}\r\n\r\ntype SayHello interface {\r\n   sayHello()\r\n}\r\n\r\nfunc (p *Person) sayHello() {\r\n   fmt.Println("Hello!")\r\n}\r\n\r\nfunc getSayHello() SayHello {\r\n   var p *Person = nil\r\n   return p\r\n}\r\n\r\nfunc main() {\r\n   var person = new(Person)\r\n   person.name = "David"\r\n   person.age = 18\r\n   person.gender = 0\r\n   var sayHello SayHello\r\n   sayHello = person\r\n   fmt.Println(reflect.TypeOf(sayHello))\r\n   fmt.Println(sayHello == nil)\r\n   fmt.Println(getSayHello())\r\n   fmt.Println(getSayHello() == nil)\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"猜一猜最终控制台将输出什么呢？"}),"\n",(0,l.jsx)(e.p,{children:"答案是："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"*main.Person"}),"\n",(0,l.jsx)(e.p,{children:"false"}),"\n",(0,l.jsx)(e.p,{children:"false"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"是不是也很奇怪？"}),"\n",(0,l.jsx)(e.p,{children:"输出第一个false无可厚非，可输出的第二个false就很耐人寻味了。第二个false来自于main()函数中调用的getSayHello()函数，该函数返回SayHello类型的接口，函数体内返回了nil值的*Person。直接输出getSayHello()函数的结果，是nil，但与nil比较时却不是true。"}),"\n",(0,l.jsxs)(e.p,{children:["这是因为：",(0,l.jsx)(e.strong,{children:"将一个带有类型的nil赋值给接口时，只有值为nil，而类型不为nil。此时，接口与nil判断将不相等。"})]}),"\n",(0,l.jsx)(e.p,{children:"那么，为了规避这类问题，我们不妨在getSayHello()函数值做些特殊处理。当函数体中的p变量为nil时，直接返回nil即可。发生修改部分的代码如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func getSayHello() SayHello {\r\n   var p *Person = nil\r\n   if p == nil {\r\n      return nil\r\n   } else {\r\n      return p\r\n   }\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"再次运行程序，控制台输出如下："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"*main.Person"}),"\n",(0,l.jsx)(e.p,{children:"false"}),"\n",(0,l.jsx)(e.p,{children:"true"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"总结",children:["总结",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,l.jsx)(e.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["使用接口时的注意事项","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"接口的嵌套组合"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"从空接口中取值"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"空接口的值比较"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"接口与nil"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"本讲是接口系列的最后一篇，是整个专题的收官之作。在本讲中，介绍了使用接口时的四个注意事项。"}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"和结构体类似，接口也是可以嵌套的，这种机制可以带来更加灵活的组合方式。"}),"\n",(0,l.jsx)(e.li,{children:"从空接口中取值时，类型断言是非常必要的。不使用类型断言将在编译前被GoLand工具检测出来。"}),"\n",(0,l.jsx)(e.li,{children:"当进行空接口中值的比较时，Map和Slice是无法比较的。相反，数组则可以比较，而且还是每个元素进行比较。"}),"\n",(0,l.jsx)(e.li,{children:"将一个带有类型的nil赋值给接口时，只有值为nil，而类型不为nil。此时，接口与nil判断将不相等。为了规避这个问题，我们应在返回接口类型前进行非nil判定。"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"好了，本讲就到这里。"}),"\n",(0,l.jsx)(e.p,{children:"➡️ 在下次课程中，我们会介绍Go语言中包的知识，具体内容是："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"Go程序源码的组织结构"}),"\n"]})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(a,{...n})}):a(n)}let d=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC19%E7%AB%A0%E2%80%94%E6%8E%A5%E5%8F%A3%E4%B8%89%EF%BD%9C%E7%81%B5%E6%B4%BB%E3%80%81%E5%AE%89%E5%85%A8%E5%9C%B0%E8%BF%90%E7%94%A8%E6%8E%A5%E5%8F%A3.md"]={toc:[{text:"接口的嵌套组合",id:"接口的嵌套组合",depth:2},{text:"从空接口取值",id:"从空接口取值",depth:2},{text:"空接口的值比较",id:"空接口的值比较",depth:2},{text:"接口与nil",id:"接口与nil",depth:2},{text:"总结",id:"总结",depth:2}],title:"第19章—接口三｜灵活、安全地运用接口",headingTitle:"第19章—接口三｜灵活、安全地运用接口",frontmatter:{}}}}]);