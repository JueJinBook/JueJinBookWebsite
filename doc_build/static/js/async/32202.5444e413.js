"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["32202"],{707785:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var c=r(552676),i=r(740453);let l=r.p+"static/image/c53317ecdf73dd85583eb8b4cb7a20d2.fbb089d4.png";function s(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",blockquote:"blockquote",h3:"h3",pre:"pre",ol:"ol",li:"li",strong:"strong",img:"img"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["工欲善其事必先利其器，在进行实战开发的时候，我们最终的步骤是搞好一个舒服的开发环境，目前支持 ",(0,c.jsx)(n.code,{children:"Vue"})," 的 ",(0,c.jsx)(n.code,{children:"Electron"})," 工程化工具主要有 ",(0,c.jsx)(n.a,{href:"https://simulatedgreg.gitbooks.io/electron-vue/content/cn/",target:"_blank",rel:"noopener noreferrer",children:"electron-vue"}),"、",(0,c.jsx)(n.a,{href:"https://nklayman.github.io/vue-cli-plugin-electron-builder/",target:"_blank",rel:"noopener noreferrer",children:"Vue CLI Plugin Electron Builder"}),"、",(0,c.jsx)(n.a,{href:"https://cn.electron-vite.org/",target:"_blank",rel:"noopener noreferrer",children:"electron-vite"}),"。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"electron-vue"})," 已经年久失修了，暂时就不介绍了，有兴趣的小伙伴可以去看看它的官网试着玩玩。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["接下来我们将分别介绍基于 ",(0,c.jsx)(n.code,{children:"Vue CLI Plugin Electron Builder"})," 和 ",(0,c.jsx)(n.code,{children:"electron-vite"})," 的开发环境搭建。"]}),"\n",(0,c.jsxs)(n.h2,{id:"vue-cli-plugin-electron-builder",children:["vue-cli-plugin-electron-builder",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-cli-plugin-electron-builder",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"vue-cli-plugin-electron-builder"})," 是一个基于 ",(0,c.jsx)(n.a,{href:"https://cli.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer",children:"VueCli"})," 的插件工具，它是一个 ",(0,c.jsx)(n.code,{children:"npm"})," 包，能够为 Vue CLI 创建的项目添加 ",(0,c.jsx)(n.code,{children:"Electron"})," 构建的能力。"]}),"\n",(0,c.jsxs)(n.h3,{id:"1-创建一个-vuecli-项目",children:["1. 创建一个 VueCli 项目",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-创建一个-vuecli-项目",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["既然它是一个基于 ",(0,c.jsx)(n.code,{children:"VueCli"})," 的插件工具，所以首先需要确保你的本地环境中已经安装好了 ",(0,c.jsx)(n.code,{children:"VueCli"})," 工具，如果还未安装，可以使用以下命令进行安装："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:"npm install -g @vue/cli\n# 第08章—实战篇：开发环境搭建\nyarn global add @vue/cli\n"})}),"\n",(0,c.jsxs)(n.p,{children:["安装好 ",(0,c.jsx)(n.code,{children:"CLI"})," 工具后，我们需要使用 ",(0,c.jsx)(n.code,{children:"CLI"})," 创建一个 ",(0,c.jsx)(n.code,{children:"Vue"})," 项目："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:"vue create electron-vue\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这里，我们选择 ",(0,c.jsx)(n.code,{children:"Vue 3"})," + ",(0,c.jsx)(n.code,{children:"babel"})," + ",(0,c.jsx)(n.code,{children:"eslint"})," 的模式："]}),"\n",(0,c.jsx)(n.p,{children:"创好了后，一起来看一下我们的大致目录结构："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:".\n├── public\n│\xa0\xa0 ├── favicon.ico\n│\xa0\xa0 └── index.html\n├── src\n│\xa0\xa0 ├── App.vue\n│\xa0\xa0 ├── assets\n│\xa0\xa0 ├── components\n│\xa0\xa0 └── main.js\n├── README.md\n├── babel.config.js\n├── jsconfig.json\n├── package.json\n├── vue.config.js\n└── yarn.lock\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"2-安装-vue-cli-plugin-electron-builder",children:["2. 安装 vue-cli-plugin-electron-builder",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-安装-vue-cli-plugin-electron-builder",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["既然 ",(0,c.jsx)(n.code,{children:"vue-cli-plugin-electron-builder"})," 是个 ",(0,c.jsx)(n.code,{children:"VueCli"})," 插件，那么就可以使用 ",(0,c.jsx)(n.code,{children:"CLI"})," 命令 ",(0,c.jsx)(n.code,{children:"vue add"})," 的方式进行插件安装："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:"# 安装并调用 vue-cli-plugin-electron-builder\nvue add electron-builder\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在安装的时候，只提供了 ",(0,c.jsx)(n.code,{children:"Electron"})," v11、v12、v13 这 3 个版本选择，这里我们先选 ",(0,c.jsx)(n.code,{children:"v13"}),"。后面我们再进行升级。"]}),"\n",(0,c.jsx)(n.p,{children:"安装完成后，我们再看一下我们的目录结构："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:".\n├── public\n│\xa0\xa0 ├── favicon.ico\n│\xa0\xa0 └── index.html\n├── src\n│\xa0\xa0 ├── App.vue\n│\xa0\xa0 ├── assets\n│\xa0\xa0 ├── background.js\n│\xa0\xa0 ├── components\n│\xa0\xa0 └── main.js\n├── README.md\n├── babel.config.js\n├── jsconfig.json\n├── package.json\n├── vue.config.js\n└── yarn.lock\n"})}),"\n",(0,c.jsx)(n.p,{children:"接下来，我们将再详细介绍一下一些核心文件的作用："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"package.json"}),"：这个文件通过 ",(0,c.jsx)(n.code,{children:"main"})," 字段定义了",(0,c.jsx)(n.strong,{children:"编译后"}),"的主入口文件路径，并且通过 ",(0,c.jsx)(n.code,{children:"script"})," 字段定义了应用程序的启动、编译等脚本程序。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"src/background.js"}),"：这个文件就是 ",(0,c.jsx)(n.code,{children:"Electron"})," 的主进程的入口文件，它是应用程序的入口点，负责管理整个应用的生命周期、创建窗口、原生 API 调用等。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"src/main.js"})," 是渲染进程的入口文件，就是我们通常写的 ",(0,c.jsx)(n.code,{children:"Vue"})," 前端代码的入口。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"3-目录结构优化",children:["3. 目录结构优化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-目录结构优化",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"为了更好地开发体验降低心智负担的理解成本，我们需要对整体目录进行一下优化。优化的目标是为了更容易区分主进程和渲染进程："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:".\n├── public\n│\xa0\xa0 ├── favicon.ico\n│\xa0\xa0 └── index.html\n├── src\n│\xa0\xa0 ├── main\n│\xa0\xa0 │\xa0\xa0 └── index.js\n│\xa0\xa0 └── renderer\n│\xa0\xa0     ├── App.vue\n│\xa0\xa0     ├── assets\n│\xa0\xa0     ├── components\n│\xa0\xa0     └── main.js\n├── README.md\n├── babel.config.js\n├── jsconfig.json\n├── package.json\n├── vue.config.js\n└── yarn.lock\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这里，我们新建了 ",(0,c.jsx)(n.code,{children:"main"})," 和 ",(0,c.jsx)(n.code,{children:"renderer"})," 目录，并将之前的 ",(0,c.jsx)(n.code,{children:"src/background.js"})," 迁移到了 ",(0,c.jsx)(n.code,{children:"main"})," 目录下，且重命名为 ",(0,c.jsx)(n.code,{children:"index.js"}),"。然后再把之前和 ",(0,c.jsx)(n.code,{children:"Vue"})," 相关的渲染进程的文件以及文件夹全部迁移到了 ",(0,c.jsx)(n.code,{children:"renderer"})," 目录下。"]}),"\n",(0,c.jsx)(n.p,{children:"这样在开发的时候，就可以一眼看明白哪些属于渲染进程、哪些属于主进程。"}),"\n",(0,c.jsxs)(n.p,{children:["因为我们做了目录的调整，所以我们需要重新修改一下 ",(0,c.jsx)(n.code,{children:"vue.config.js"})," 的编译配置："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// vue.config.js\nconst { defineConfig } = require('@vue/cli-service')\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  pages: {\n    index: {\n      // 修改渲染进程入口文件的位置\n      entry: 'src/renderer/main.js',\n    },\n  },\n  pluginOptions: {\n    electronBuilder: {\n      nodeIntegration: true,\n      // 修改主进程的入口文件位置\n      mainProcessFile: 'src/main/index.js',\n      // 设置主进程的修改监听，当主进程发生变更时，可以及时热更\n      mainProcessWatch: ['src/main'],\n    },\n  },\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:["最后，也要记得修改 ",(0,c.jsx)(n.code,{children:"package.json"})," 里面的 ",(0,c.jsx)(n.code,{children:"main"})," 配置："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n  ...\n  "main": "index.js",\n  ...\n}\n'})}),"\n",(0,c.jsxs)(n.h3,{id:"4-升级-electron",children:["4. 升级 electron",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-升级-electron",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["目前最新 stable 版本的 ",(0,c.jsx)(n.code,{children:"Electron"})," 是 ",(0,c.jsx)(n.code,{children:"v27.1.3"}),"："]}),"\n",(0,c.jsx)(n.p,{children:"那我们可以直接升级到这个版本："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:"yarn add electron@27.1.3 -D\n"})}),"\n",(0,c.jsx)(n.p,{children:"如果在安装过程中遇到了网络错误："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["可以添加一个 ",(0,c.jsx)(n.code,{children:".npmrc"})," 文件代理 ",(0,c.jsx)(n.code,{children:"Electron"})," 的安装源，指向 ",(0,c.jsx)(n.code,{children:"taobao"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"electron_mirror=https://npmmirror.com/mirrors/electron/\n"})}),"\n",(0,c.jsx)(n.p,{children:"修改完成后，我们运行一下启动本地服务："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:"npm run electron:serve\n"})}),"\n",(0,c.jsx)(n.p,{children:"大工告成！\uD83C\uDF89\uD83C\uDF89"}),"\n",(0,c.jsxs)(n.h2,{id:"electron-vite",children:["electron-vite",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#electron-vite",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"electron-vite"})," 是一个新型 Electron 开发构建工具，旨在为 Electron 提供更快、更精简的开发体验，它是基于 ",(0,c.jsx)(n.code,{children:"vite"})," 构建 ",(0,c.jsx)(n.code,{children:"Electron"})," 应用的。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们可以使用 ",(0,c.jsx)(n.code,{children:"@quick-start/electron"})," 工具快速创建一个 ",(0,c.jsx)(n.code,{children:"electron-vite"})," 的应用："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:"npm create @quick-start/electron\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后按照提示进行下一步即可："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"✔ Project name: … <electron-app>\n✔ Select a framework: › vue\n✔ Add TypeScript? … No / Yes\n✔ Add Electron updater plugin? … No / Yes\n✔ Enable Electron download mirror proxy? … No / Yes\n\nScaffolding project in ./<electron-app>...\nDone.\n"})}),"\n",(0,c.jsxs)(n.p,{children:["新建完成后，一起来看一下 ",(0,c.jsx)(n.code,{children:"electron-vite"})," 为我们创建的项目结构："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:".\n├── build\n│\xa0\xa0 ├── entitlements.mac.plist\n│\xa0\xa0 ├── icon.icns\n│\xa0\xa0 ├── icon.ico\n│\xa0\xa0 └── icon.png\n├── resources\n│\xa0\xa0 └── icon.png\n├── src\n│\xa0\xa0 ├── main\n│\xa0\xa0 │\xa0\xa0 └── index.js\n│\xa0\xa0 ├── preload\n│\xa0\xa0 │\xa0\xa0 └── index.js\n│\xa0\xa0 └── renderer\n│\xa0\xa0     ├── index.html\n│\xa0\xa0     └── src\n├── README.md\n├── electron-builder.yml\n├── electron.vite.config.js\n├── package.json\n└── yarn.lock\n"})}),"\n",(0,c.jsx)(n.p,{children:"可以看到整体目录结构还是比较规范和清晰的，我们几乎不需要进行任何调整就可以直接使用了。"}),"\n",(0,c.jsx)(n.p,{children:"接着，在我们安装好相关的依赖后，我们运行："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-sh",children:"npm run dev\n"})}),"\n",(0,c.jsx)(n.p,{children:"就可以直接看到运行结果："}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["不过这里使用的 ",(0,c.jsx)(n.code,{children:"Electron"})," 版本是 ",(0,c.jsx)(n.code,{children:"v25.9.7"}),"，使用的是最新发布 stable 下的较低版本。如果你想要升级到最新版本，可以按照之前的做法一样来进行升级。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"大工告成！\uD83C\uDF89\uD83C\uDF89"}),"\n",(0,c.jsxs)(n.h2,{id:"主进程启动项目",children:["主进程启动项目",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主进程启动项目",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["不管是通过 ",(0,c.jsx)(n.code,{children:"vue-cli-plugin-electron-builder"})," 创建还是通过 ",(0,c.jsx)(n.code,{children:"electron-vite"})," 创建的项目，都需要通过唯一的主进程进行应用程序的启动。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们之前在",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7302990019642261567/section/7303819624217313318",target:"_blank",rel:"noopener noreferrer",children:"《Electron 的基础概念》"}),"中介绍了 Electron 的 app 模块管理者应用程序的生命周期来说，主进程的第一步操作就是监听 app ready 事件，来创建窗口："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// main/index.js\napp.whenReady().then(() => {\n  // 创建窗口。\n  createWindow()\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:["接下来，我们需要通过 ",(0,c.jsx)(n.code,{children:"createWindow"})," 函数构造一个简单的窗口："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// main/index.js\nfunction createWindow() {\n  // 创建窗口\n  const mainWindow = new BrowserWindow({\n    width: 900,\n    height: 670,\n    show: false,\n    autoHideMenuBar: true,\n    webPreferences: {\n      preload: join(__dirname, '../preload/index.js'),\n      sandbox: false\n    }\n  })\n\n  mainWindow.on('ready-to-show', () => {\n    mainWindow.show()\n  })\n\n  if (is.dev && process.env['ELECTRON_RENDERER_URL']) {\n   // 开发环境，通过 loadURL 加载 devServer\n   mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL'])\n  } else {\n    // 生产环境，加载构建后的文件\n    mainWindow.loadFile(join(__dirname, '../renderer/index.html'))\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["需要注意的是，我们在窗口初始化时，指定了 ",(0,c.jsx)(n.code,{children:"show: false"})," 的参数，意味着窗口创建完成后不会立即显示。然后通过监听 ",(0,c.jsx)(n.code,{children:"mainWindow.on('ready-to-show')"})," 的事件触发后再通过 ",(0,c.jsx)(n.code,{children:"mainWindow.show()"})," 方法来显示窗口。"]}),"\n",(0,c.jsxs)(n.p,{children:["这样做是因为 Electron 中的 ",(0,c.jsx)(n.code,{children:"ready-to-show"})," 事件表示窗口内容已经加载完成且应用程序准备好显示给用户。在等待 ",(0,c.jsx)(n.code,{children:"ready-to-show"})," 事件触发后再调用 ",(0,c.jsx)(n.code,{children:"window.show()"}),"，可以确保用户看到的是完全加载并准备好的界面，避免了展示未完成的内容。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后，通过监听 ",(0,c.jsx)(n.code,{children:"app.on('window-all-close')"})," 事件，来处理非 ",(0,c.jsx)(n.code,{children:"macOS"})," 下的所有窗口关闭后的逻辑：退出整个 electron 应用。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// main/index.js\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit()\n  }\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这是因为在 ",(0,c.jsx)(n.code,{children:"windows"})," 平台上，通常我们把应用的窗口都关了之后也就默认把这个应用给退出了。而如果在 macOS 系统上却不是这样。我们把应用的窗口关闭了，但是并非完全退出这个应用。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["我们已经在",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7302990019642261567/section/7304648624460759081",target:"_blank",rel:"noopener noreferrer",children:"《Electron 跨平台兼容性措施》"}),"章节为大家详细介绍了更多的一些跨平台兼容性实现。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["整体看来，使用 ",(0,c.jsx)(n.code,{children:"vue-cli-plugin-electron-builder"})," 来构建 ",(0,c.jsx)(n.code,{children:"Electron"})," 应用的话，需要自己做更多的配置工作；而 ",(0,c.jsx)(n.code,{children:"electron-vite"})," 本身就是一个基于 ",(0,c.jsx)(n.code,{children:"vite + electron"})," 脚手架工具，相对而言已经有一套约定俗称的目录和配置规范，所以对于新手开发者而言会更加友好。"]}),"\n",(0,c.jsxs)(n.p,{children:["其实一个最简单的 ",(0,c.jsx)(n.code,{children:"Electron"})," 应用的目录结构大致如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:".\n├── index.html\n├── main.js\n├── renderer.js\n├── preload.js\n└── package.json\n"})}),"\n",(0,c.jsx)(n.p,{children:"而所谓的构建工具就是为了生成这样的目录内容："})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(s,{...e})}):s(e)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC08%E7%AB%A0%E2%80%94%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%9A%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"vue-cli-plugin-electron-builder",id:"vue-cli-plugin-electron-builder",depth:2},{text:"1. 创建一个 VueCli 项目",id:"1-创建一个-vuecli-项目",depth:3},{text:"2. 安装 vue-cli-plugin-electron-builder",id:"2-安装-vue-cli-plugin-electron-builder",depth:3},{text:"3. 目录结构优化",id:"3-目录结构优化",depth:3},{text:"4. 升级 electron",id:"4-升级-electron",depth:3},{text:"electron-vite",id:"electron-vite",depth:2},{text:"主进程启动项目",id:"主进程启动项目",depth:2},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);