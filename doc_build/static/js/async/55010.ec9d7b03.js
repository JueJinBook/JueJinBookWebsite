"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55010"],{472732:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var t=r(552676),s=r(740453);let c=r.p+"static/image/509acc4e972dc02c5b2a51b19013d49b.dcd15473.webp",i=r.p+"static/image/8800f66bee229ad42868732b1476e9a6.835eff9e.webp",d=r.p+"static/image/236c26da83e4abb0ed95b33bf73b57cb.3ff347e3.webp",l=r.p+"static/image/dd1e6eb80f9f6285212a4af265794a8d.73f5009b.webp",o=r.p+"static/image/c04c9328c624210f8822ce8e25adf41a.b1dc8fb6.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",ul:"ul",li:"li",strong:"strong",em:"em"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"4dom-查询上页面元素的渲染和行为查询",children:["4.DOM 查询（上）：页面元素的渲染和行为查询",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4dom-查询上页面元素的渲染和行为查询",children:"#"})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["代码仓库：",(0,t.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"上节课我们学习了如何告诉程序什么是我们的预期，在单测程序中，每一个预期都通过断言的方式来说明，Jest 提供了很多基础的断言来帮助描述程序中可能存在的不同场景，但是 Jest 的基础断言通常用于纯 JavaScript 逻辑的断言，例如 node 服务的函数。"}),"\n",(0,t.jsx)(n.p,{children:"但是面对业务场景，我们的逻辑中不可避免会涉及 Dom 元素的选取，也就是所谓的 UI 自动化，面对这种场景，我们需要对页面元素进行渲染 、 查询，然后再对结果进行断言，仅通过 Jest 就没办法满足我们的需求了，需要 React Testing Library 的帮助，这节课我们就来学习，如何对 DOM 元素进行渲染、查询。"}),"\n",(0,t.jsxs)(n.h2,{id:"页面元素的渲染",children:["页面元素的渲染",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#页面元素的渲染",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"首先还是回到我们最初的例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'test("renders learn react link", () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["@testing-library/react 这个依赖提供了一些处理 React Component 的 API，其中 render 方法用于元素的渲染，并且在 render 执行过后会把值注入到 screen对象中。像上面这个例子中，使用 screen 来选取我们需要的元素，其中 ",(0,t.jsx)(n.code,{children:"getByText"})," 是 React Testing Library 提供的查询 API，我们一会着重介绍。"]}),"\n",(0,t.jsx)(n.p,{children:"以上面的例子举例，除了通过 screen 选取元素，还可以直接通过 render 来选取。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"const linkElementByScreen = screen.getByText(/learn react/i);\nconst { getByText }  = render(<App />);\nconst linkElementByRender = getByText(/learn react/i);\n"})}),"\n",(0,t.jsx)(n.p,{children:"这两种写法都可以获取到需要的元素，那它们之间有什么区别吗？"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["The benefit of using ",(0,t.jsx)(n.code,{children:"screen"})," is you no longer need to keep the ",(0,t.jsx)(n.code,{children:"render"})," call destructure up-to-date as you add/remove the queries you need. You only need to type ",(0,t.jsx)(n.code,{children:"screen."})," and let your editor's magic autocomplete take care of the rest."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"上面是作者对于这个问题的解释，翻译一下是这样的："}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"使用屏幕的好处是，您不再需要在添加/删除所需查询时，保持渲染调用的解构是最新的。您只需要输入屏幕，让您的编辑器神奇地自动完成功能来处理其余的事情。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["这样直接看大家可能还不是很理解，我们可以结合",(0,t.jsx)(n.a,{href:"https://github1s.com/testing-library/dom-testing-library/blob/HEAD/src/screen.ts#L5",target:"_blank",rel:"noopener noreferrer",children:"源码"}),"来一起理解一下这句话。"]}),"\n",(0,t.jsx)(n.p,{children:"这是 render 方法的定义："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这是 screen 方法的定义："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["它们都有使用",(0,t.jsx)(n.code,{children:"  getQueriesForElement "})," 方法，这个方法是为了获取指定元素下的查询，作者有将 role， text 等类别的查询通过这种方式暴露出来。"]}),"\n",(0,t.jsx)(n.p,{children:"我们再来具体看这两个方法做了什么，render 方法首先会创建一个元素，并写入到 innerHTML 中，然后再去获取我们传入的组件（html 参数）下的查询对象，并暴露出来，而 screen 方法则是在 document.body 存在的时候，获取 document.body 下的查询进行暴露。"}),"\n",(0,t.jsxs)(n.p,{children:["这里的",(0,t.jsx)(n.code,{children:"  document.body "})," 和 html 参数其实是同步的，只不过在基础上包了一层 ",(0,t.jsx)(n.code,{children:"<body></body>"}),"，这么看来好像只是把查询的字段放在全局进行导出了，这么做的意义是什么呢？综合来讲是两个原因："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Render 方法的主要意义其实是渲染，虽然它也会暴露出查询的 API，但这个 API 和 渲染其实是没有关系的，所以把查询作为一个独立的全局对象 screen 暴露出来，可以有效区分渲染和查询的界限，这样从测试项目的结构上来说是更清晰的；"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"另外一个重要的原因是，DOM 相关的查询 API 是比较多的，采用解构的方式很容易就出现下面的写法，我们不得不在每个 test 中重复解构。"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"import {render} from '@testing-library/react'\n\ntest('test 1', () => {\n  const {queryByLabelText, getByText, getByLabelText} = render(<Thing />)\n})\n\ntest('test 2', () => {\n  const {getByLabelText, queryByLabelText} = render(<Thing />)\n})\n\ntest('test 3', () => {\n  const {getByLabelText, queryByLabelText} = render(<Thing />)\n})\n\ntest('test 4', () => {\n  const {getByLabelText, queryByLabelText} = render(<Thing />)\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"\xa0这种解构其实是重复的，且与实际测试的逻辑的确半毛钱关系都没有，相比之下 screen 的写法要清晰舒服很多。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'test("test", () => {\n render(<App />);\n screen[...] // 需要啥用啥\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["所以我们在写 DOM 相关的单测时，更建议大家采用 screen 来获取 DOM 的 container 来查询，额外值得一提的是，render 函数需要放在每个独立的 test 中，因为在每个 test 执行完以后， React Testing Library 会调用 cleanup 方法来清理环境，例如下面的写法，会导致后面的 test 不能读到元素，",(0,t.jsx)(n.strong,{children:"这是一个常见的问题，大家需要注意一下"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'import React from "react";\nimport { render, screen } from "@testing-library/react";\nimport App from "./App";\n\nrender(<App />)\n\ndescribe("tests", () => {\n test("test1", () => {\n   // ...\n });\n\n test("test2", () => {\n   screen.debug(); // ... 会读不到元素，仅剩body\n });\n});\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"页面元素的查询",children:["页面元素的查询",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#页面元素的查询",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"渲染完组件元素后，我们需要对组件进行查询，从而选取到我们需要的区域，React Testing Library 提供的查询 API 很多，但是可以从行为和参照物两个维度进行拆分理解，这节课我们先来学习行为维护的分类。"}),"\n",(0,t.jsx)(n.p,{children:"从行为角度上，查询 API 可以包含三种类别（getBy, queryBy, findBy），它们各自又包含单查和多查，也就是（getBy, queryBy, findBy, getAllBy, queryAllBy, findAllBy)，其中同一种类别的能力类似，区别只在于查询的数量，比如 getBy 和 getAllBy 在 API 的表述上就是近似的，大家可以参照下图来初步理解。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"其中针对三种类别，它们之间的区别在于："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Get：返回查询的匹配节点，如果没元素匹配，则会报错（针对单查如果查到多个也会报错）；"}),"\n",(0,t.jsx)(n.li,{children:"Query：返回查询的匹配节点，如果没有元素匹配会返回 null，但是不会报错（同样针对单查，如果查到多个匹配元素也会报错）"}),"\n",(0,t.jsx)(n.li,{children:"Find：返回一个 Promise，默认超时时间为 1000 ms， 如果没有元素匹配或者查找超时，Promise 状态切为 reject（同样针对单查，如果查到多个元素，也会返回 reject）。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["find 方法我们会在",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7174044519350927395/section/7176612133516345378",target:"_blank",rel:"noopener noreferrer",children:"8 | Async 异步：异步方法如何进行单测？"})," 详细介绍，这节课我们先来学习 get 和 query 的类别。以我们之前使用过的 text 来举例说明，可以创建一个组件作为我们这部分的测试。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/components/DomQuery/index.tsx\nimport { FC } from "react";\n\ninterface IProps {}\n\n// 《4 | DOM查询(上)：页面元素的渲染和行为查询》 & 《5 |DOM查询(下)：页面元素的参照物查询和优先级》\nexport const DomQuery: FC<IProps> = ({}) => {\n  return (\n    <div>\n      <div>test1</div>\n      <div>test2</div>\n    </div>\n  );\n};\n'})}),"\n",(0,t.jsx)(n.p,{children:"然后我们加上这样一条单测："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/__test__/dom_query.test.tsx\nimport React from "react";\nimport { render, screen } from "@testing-library/react";\nimport { DomQuery } from "../components/DomQuery";\n\ndescribe("tests for 《4 | DOM查询(上)：页面元素的渲染和行为查询》 & 《5 | DOM查询(下)：页面元素的参照物查询和优先级》", () => {\n  test("get & query & find", () => {\n    render(<DomQuery />);\n    const element = screen.getByText(/test/i);\n    screen.debug(element);\n  });\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"其中 screen.debug 是暴露出来的一个调试 API，可以帮我们将查询出来的元素在控制台中显示出来，我们可以看看效果，发现会抛出找到多个元素的错误，getBy 是没办法直接查询多个的，我们换用 query 或是 find 也会有相同的效果。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"在这个基础上，再来丰富一下我们的例子，将用例调整为下面的代码，然后在最后一行加上断点，然后用 debugger 终端执行看看。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/__test__/dom_query.test.tsx\nimport React from "react";\nimport { render, screen } from "@testing-library/react";\nimport { DomQuery } from "../components/DomQuery";\n\ndescribe("tests for 《4 | DOM查询(上)：页面元素的渲染和行为查询》 & 《5 | DOM查询(下)：页面元素的参照物查询和优先级》", () => {\n  test("get & query & find", () => {\n    render(<DomQuery />);\n    const getElement = screen.getByText("test1");\n    const getAllElement = screen.getAllByText(/test/i);\n    const queryElement = screen.queryByText("test3");\n    const queryAllElement = screen.queryAllByText("test3");\n    debugger;\n  });\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["大家可以先根据之前学的理论判断一下预期的结果是什么。query 相比 get 不同的是，它在没匹配到对应元素时，并不会抛出错误，而是返回 null 或是 []，那么这个结果其实应该是",(0,t.jsx)(n.code,{children:"  htmlDivElement, [htmlDivElement, htmlDivElement], null, [] "}),"，我们来看看结果是不是和我们想的一样。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"相信到这里大家就已经熟悉 get 和 query 以及单查和多查的区别了，那么什么场景下我们应该用 get， 什么场景下我们用 query 呢？"}),"\n",(0,t.jsx)(n.p,{children:"如果说这个元素的存在与否，并不决定这个用例能不能通过，或者说，这个元素不存在，也并不影响这个用例通过的话，我们应该使用 query。如果说这个元素不存在，那么后续的步骤就没有执行的意义，这个用例就是不通过的，我们应该使用 get，因为 get 会抛出错误，直接中断这个用例。"}),"\n",(0,t.jsx)(n.p,{children:"在上面的例子中，我们后缀使用的是 text，这是一种通过标签文本作为参照物的方式，除了这种以外， React Testing Library 还涉及其余 7 种参照物的查询方式，因为文章篇幅的关系，我们将在下一节课继续学习。"}),"\n",(0,t.jsxs)(n.h2,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这节课我们学习了 DOM 查询的上篇 - 页面元素的渲染和行为查询。对于页面元素的渲染，通常采用 render ，这个函数会返回给我们需要的查询，因为考虑到重复解构的原因，React Testing Library 有在全局暴露一个 screen 对象，当我们调用 render 方法后，它会注入 element 到页面的 innerHtml 中，而 screen 则会针对页面 body 区域获取查询，并暴露给我们 body 区域的查询API。"}),"\n",(0,t.jsx)(n.p,{children:"针对查询的部分，我们按照行为和参照物进行了分类，行为上我们分为了 get、 query 和 find 三种类别，其中 get 获取不到元素会抛出错误，而 query 获取不到则是返空，对于 find 则采取异步返回 reject。"}),"\n",(0,t.jsx)(n.p,{children:"在实际场景的应用中，如果元素获取不到，并不意味着这条用例失败，我们可以使用 query 来进行获取，因为 get 抛出的错误也会中断这条用例的执行。我们还学习了单查和多查两种情况的区别，当使用单查 API 查询到多个匹配元素的时候，也会抛出对应的错误来中断用例。"}),"\n",(0,t.jsxs)(n.p,{children:["同时我们还接触到了第一个参照物 text， 这是一种通过标签文本作为参照物的方式，除此之外，其实还有其余的 7 种参照物，再考虑到查询行为的三种分类，单查和多查的场景，涉及到的实际 API 有8",(0,t.jsx)(n.em,{children:"3"}),"2 = 48 种之多，那么，应该如何有效排列这些查询方式的优先级，并且在合适的场景使用呢？这些我们都将在下节课详细讨论。"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}let x=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F4.DOM%20%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%B8%B2%E6%9F%93%E5%92%8C%E8%A1%8C%E4%B8%BA%E6%9F%A5%E8%AF%A2.md"]={toc:[{text:"页面元素的渲染",id:"页面元素的渲染",depth:2},{text:"页面元素的查询",id:"页面元素的查询",depth:2},{text:"小结",id:"小结",depth:2}],title:"4.DOM 查询（上）：页面元素的渲染和行为查询",headingTitle:"4.DOM 查询（上）：页面元素的渲染和行为查询",frontmatter:{}}}}]);