"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["50048"],{460411:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var s=r(552676),d=r(740453);let c=r.p+"static/image/6489f30aa77f1653f0cb5a8083ce89d2.974318aa.webp";function t(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",code:"code",pre:"pre",h3:"h3"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"8vuex-状态管理的工作原理",children:["8.Vuex 状态管理的工作原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8vuex-状态管理的工作原理",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"为什么要使用-vuex",children:["为什么要使用 Vuex",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么要使用-vuex",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"当我们使用 Vue.js 来开发一个单页应用时，经常会遇到一些组件间共享的数据或状态，或是需要通过 props 深层传递的一些数据。在应用规模较小的时候，我们会使用 props、事件等常用的父子组件的组件间通信方法，或者是通过事件总线来进行任意两个组件的通信。但是当应用逐渐复杂后，问题就开始出现了，这样的通信方式会导致数据流异常地混乱。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个时候，我们就需要用到我们的状态管理工具 Vuex 了。Vuex 是一个专门为 Vue.js 框架设计的、专门用来对于 Vue.js 应用进行状态管理的库。它借鉴了 Flux、redux 的基本思想，将状态抽离到全局，形成一个 Store。因为 Vuex 内部采用了 new Vue 来将 Store 内的数据进行「响应式化」，所以 Vuex 是一款利用 Vue 内部机制的库，与 Vue 高度契合，与 Vue 搭配使用显得更加简单高效，但缺点是不能与其他的框架（如 react）配合使用。"}),"\n",(0,s.jsxs)(n.p,{children:["本节将简单介绍 Vuex 最核心的内部机制，起个抛砖引玉的作用，想了解更多细节可以参考笔者 ",(0,s.jsx)(n.a,{href:"https://github.com/answershuto",target:"_blank",rel:"noopener noreferrer",children:"Github"}),"  上的另一篇文章 ",(0,s.jsx)(n.a,{href:"https://github.com/answershuto/learnVue/blob/master/docs/Vuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.MarkDown",target:"_blank",rel:"noopener noreferrer",children:"《Vuex源码解析》"}),"或者直接阅读 ",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vuex",target:"_blank",rel:"noopener noreferrer",children:"Vuex源码"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"安装",children:["安装",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#安装",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Vue.js 提供了一个 ",(0,s.jsx)(n.code,{children:"Vue.use"})," 的方法来安装插件，内部会调用插件提供的 ",(0,s.jsx)(n.code,{children:"install"})," 方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"Vue.use(Vuex);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["所以我们的插件需要提供一个 ",(0,s.jsx)(n.code,{children:"install"})," 方法来安装。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let Vue;\n\nexport default install (_Vue) {\n    Vue.mixin({ beforeCreate: vuexInit });\n    Vue = _Vue;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们采用 ",(0,s.jsx)(n.code,{children:"Vue.mixin"})," 方法将 ",(0,s.jsx)(n.code,{children:"vuexInit"})," 方法混淆进 ",(0,s.jsx)(n.code,{children:"beforeCreate"})," 钩子中，并用 ",(0,s.jsx)(n.code,{children:"Vue"})," 保存 Vue 对象。那么 ",(0,s.jsx)(n.code,{children:"vuexInit"})," 究竟实现了什么呢？"]}),"\n",(0,s.jsxs)(n.p,{children:["我们知道，在使用 Vuex 的时候，我们需要将 ",(0,s.jsx)(n.code,{children:"store"})," 传入到 Vue 实例中去。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/*将store放入Vue创建时的option中*/\nnew Vue({\n    el: '#app',\n    store\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["但是我们却在每一个 vm 中都可以访问该 ",(0,s.jsx)(n.code,{children:"store"}),"，这个就需要靠 ",(0,s.jsx)(n.code,{children:"vuexInit"})," 了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function vuexInit () {\n    const options = this.$options;\n    if (options.store) {\n        this.$store = options.store;\n    } else {\n        this.$store = options.parent.$store;\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["因为之前已经用",(0,s.jsx)(n.code,{children:"Vue.mixin"})," 方法将 ",(0,s.jsx)(n.code,{children:"vuexInit"})," 方法混淆进 ",(0,s.jsx)(n.code,{children:"beforeCreate"})," 钩子中，所以每一个 vm 实例都会调用 ",(0,s.jsx)(n.code,{children:"vuexInit"})," 方法。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果是根节点（",(0,s.jsx)(n.code,{children:"$options"}),"中存在 ",(0,s.jsx)(n.code,{children:"store"})," 说明是根节点），则直接将 ",(0,s.jsx)(n.code,{children:"options.store"})," 赋值给 ",(0,s.jsx)(n.code,{children:"this.$store"}),"。否则则说明不是根节点，从父节点的 ",(0,s.jsx)(n.code,{children:"$store"})," 中获取。"]}),"\n",(0,s.jsxs)(n.p,{children:["通过这步的操作，我们已经可以在任意一个 vm 中通过 ",(0,s.jsx)(n.code,{children:"this.$store"})," 来访问 ",(0,s.jsx)(n.code,{children:"Store"})," 的实例啦～"]}),"\n",(0,s.jsxs)(n.h2,{id:"store",children:["Store",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#store",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"数据的响应式化",children:["数据的响应式化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数据的响应式化",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先我们需要在 ",(0,s.jsx)(n.code,{children:"Store"})," 的构造函数中对 ",(0,s.jsx)(n.code,{children:"state"})," 进行「响应式化」。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"constructor () {\n    this._vm = new Vue({\n        data: {\n            ?state: this.state\n        }\n    })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["熟悉「响应式」的同学肯定知道，这个步骤以后，",(0,s.jsx)(n.code,{children:"state"})," 会将需要的依赖收集在 ",(0,s.jsx)(n.code,{children:"Dep"})," 中，在被修改时更新对应视图。我们来看一个小例子。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let globalData = {\n    d: 'hello world'\n};\nnew Vue({\n    data () {\n        return {\n            ?state: {\n                globalData\n            }\n        }\n    }\n});\n\n/* modify */\nsetTimeout(() => {\n    globalData.d = 'hi~';\n}, 1000);\n\nVue.prototype.globalData = globalData;\n"})}),"\n",(0,s.jsx)(n.p,{children:"任意模板中"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<div>{{globalData.d}}</div>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述代码在全局有一个 ",(0,s.jsx)(n.code,{children:"globalData"}),"，它被传入一个 ",(0,s.jsx)(n.code,{children:"Vue"})," 对象的 ",(0,s.jsx)(n.code,{children:"data"})," 中，之后在任意 Vue 模板中对该变量进行展示，因为此时 ",(0,s.jsx)(n.code,{children:"globalData"})," 已经在 Vue 的 ",(0,s.jsx)(n.code,{children:"prototype"})," 上了所以直接通过 ",(0,s.jsx)(n.code,{children:"this.prototype"})," 访问，也就是在模板中的 ",(0,s.jsx)(n.code,{children:"{{globalData.d}}"}),"。此时，",(0,s.jsx)(n.code,{children:"setTimeout"})," 在 1s 之后将 ",(0,s.jsx)(n.code,{children:"globalData.d"})," 进行修改，我们发现模板中的 ",(0,s.jsx)(n.code,{children:"globalData.d"})," 发生了变化。其实上述部分就是 Vuex 依赖 Vue 核心实现数据的“响应式化”。"]}),"\n",(0,s.jsxs)(n.p,{children:["讲完了 Vuex 最核心的通过 Vue 进行数据的「响应式化」，接下来我们再来介绍两个 ",(0,s.jsx)(n.code,{children:"Store"})," 的 API。"]}),"\n",(0,s.jsxs)(n.h3,{id:"commit",children:["commit",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commit",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先是 ",(0,s.jsx)(n.code,{children:"commit"})," 方法，我们知道 ",(0,s.jsx)(n.code,{children:"commit"})," 方法是用来触发 ",(0,s.jsx)(n.code,{children:"mutation"})," 的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"commit (type, payload, _options) {\n    const entry = this._mutations[type];\n    entry.forEach(function commitIterator (handler) {\n        handler(payload);\n    });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["从 ",(0,s.jsx)(n.code,{children:"_mutations"})," 中取出对应的 mutation，循环执行其中的每一个 mutation。"]}),"\n",(0,s.jsxs)(n.h3,{id:"dispatch",children:["dispatch",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dispatch",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dispatch"})," 同样道理，用于触发 action，可以包含异步状态。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"dispatch (type, payload) {\n    const entry = this._actions[type];\n\n    return entry.length > 1\n    ? Promise.all(entry.map(handler => handler(payload)))\n    : entry[0](payload);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同样的，取出 ",(0,s.jsx)(n.code,{children:"_actions"})," 中的所有对应 action，将其执行，如果有多个则用 ",(0,s.jsx)(n.code,{children:"Promise.all"})," 进行包装。"]}),"\n",(0,s.jsxs)(n.h2,{id:"最后",children:["最后",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"理解 Vuex 的核心在于理解其如何与 Vue 本身结合，如何利用 Vue 的响应式机制来实现核心 Store 的「响应式化」。"}),"\n",(0,s.jsxs)(n.p,{children:["Vuex 本身代码不多且设计优雅，非常值得一读，想阅读源码的同学请看",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/vuex",target:"_blank",rel:"noopener noreferrer",children:"Vuex源码"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["注：本节代码参考",(0,s.jsx)(n.a,{href:"https://github.com/answershuto/VueDemo/blob/master/%E3%80%8AVuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%8B.js",target:"_blank",rel:"noopener noreferrer",children:"《Vuex状态管理的工作原理》"}),"。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let a=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E5%89%96%E6%9E%90%20Vue.js%20%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F8.Vuex%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.md"]={toc:[{text:"为什么要使用 Vuex",id:"为什么要使用-vuex",depth:2},{text:"安装",id:"安装",depth:2},{text:"Store",id:"store",depth:2},{text:"数据的响应式化",id:"数据的响应式化",depth:3},{text:"commit",id:"commit",depth:3},{text:"dispatch",id:"dispatch",depth:3},{text:"最后",id:"最后",depth:2}],title:"8.Vuex 状态管理的工作原理",headingTitle:"8.Vuex 状态管理的工作原理",frontmatter:{}}}}]);