"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["13186"],{698712:function(n,e,t){t.r(e),t.d(e,{default:()=>l});var r=t(552676),s=t(740453);let o=t.p+"static/image/103a5c8ec797815d082f3c78f138ecb3.20f270c4.webp",a=t.p+"static/image/c9bcfc4a414166f561a879d219e486c8.cd78c416.webp",i=t.p+"static/image/ebf72336acd2437a92c38aab0c6ed3c7.bc0d1a66.webp";function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",code:"code",blockquote:"blockquote",pre:"pre",h3:"h3",ul:"ul",li:"li",ol:"ol",strong:"strong"},(0,s.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"27手写-bundler_-实现代码打包-tree-shaking",children:["27.手写 Bundler_ 实现代码打包、 Tree Shaking",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#27手写-bundler_-实现代码打包-tree-shaking",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在上一小节，我带你实现了一个简单的 JavaScript AST 解析器，你也应该对词法分析和语法分析底层原理有了一定的了解。那么在本小节的内容中，我们将基于 AST 解析器来实现一个模块打包工具(Bundler)，也就是实现一个精简版的 Rollup。通过本节的实战学习，你不仅能对各种 AST 的各种操作信手拈来，还能够对 JavaScript 模块打包工具本身有更加深刻的理解。"}),"\n",(0,r.jsxs)(e.h2,{id:"实现思路梳理",children:["实现思路梳理",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现思路梳理",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"首先我们来梳理一下整体的实现思路，如下图所示:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["第一步我们需要获取模块的内容并解析模块 AST，然后梳理模块间的依赖关系，生成一张模块依赖图(",(0,r.jsx)(e.code,{children:"ModuleGraph"}),")。"]}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们根据模块依赖图生成拓扑排序后的模块列表，以保证最后的产物中各个模块的顺序是正确的，比如模块 A 依赖了模块 B，那么在产物中，模块 B 的代码需要保证在模块 A 的代码之前执行。"}),"\n",(0,r.jsx)(e.p,{children:"当然，Tree Shaking 的实现也是很重要的一环，我会带你实现一个基于 import/export 符号分析的 Tree Shaking 效果，保证只有被 import 的部分被打包进产物。最后，我们便可以输出完整的 Bundle 代码，完成模块打包。"}),"\n",(0,r.jsxs)(e.h2,{id:"开发环境搭建",children:["开发环境搭建",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#开发环境搭建",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们先来搭建一下项目的基本开发环境，首先新建目录",(0,r.jsx)(e.code,{children:"my-bundler"}),"，然后进入目录中执行 ",(0,r.jsx)(e.code,{children:"pnpm init -y"})," 初始化，安装一些必要的依赖:"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["建议 fork 小册的 ",(0,r.jsx)(e.a,{href:"/git@github.com:sanyuan0704/juejin-book-vite.git",children:"Github 仓库"}),"，从项目根目录下创建项目，因为需要使用仓库中的 ast-parser"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"pnpm i magic-string -S\npnpm i @types/node tsup typescript typescript-transform-paths -D\n"})}),"\n",(0,r.jsxs)(e.p,{children:["新建",(0,r.jsx)(e.code,{children:"tsconfig.json"}),"，内容如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'{\n  "compilerOptions": {\n    "target": "es2016",\n    "allowJs": true,\n    "module": "commonjs",\n    "moduleResolution": "node",\n    "outDir": "dist",\n    "esModuleInterop": true,\n    "forceConsistentCasingInFileNames": true,\n    "strict": true,\n    "skipLibCheck": true,\n    "sourceMap": true,\n    "baseUrl": "src",\n    "rootDir": "src",\n    "declaration": true,\n    "plugins": [\n      {\n        "transform": "typescript-transform-paths"/* 支持别名 */ \n      },\n      {\n        "transform": "typescript-transform-paths",\n        "afterDeclarations": true/* 支持类型文件中的别名 */ \n      }\n    ],\n    "paths": {\n      "*": ["./*"],\n      "ast-parser": ["../../ast-parser"]/* AST 解析器的路径*/\n    }\n  },\n  "include": ["src"],\n  "references": [{ "path": "../ast-parser" }]\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"然后在 package.json 中添加如下的构建脚本:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'"scripts": {\n  "dev": "tsup ./src/rollup.ts --format cjs,esm --dts --clean --watch",\n  "build": "tsup ./src/rollup.ts --format cjs,esm --dts --clean --minify"\n},\n'})}),"\n",(0,r.jsxs)(e.p,{children:["接下来，你可以在",(0,r.jsx)(e.code,{children:"src"}),"目录下新建",(0,r.jsx)(e.code,{children:"index.ts"}),"，内容如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/index.ts\nimport { Bundle } from './Bundle';\n\nexport interface BuildOptions {\n  input: string;\n}\n\nexport function build(options: BuildOptions) {\n  const bundle = new Bundle({\n    entry: options.input\n  });\n  return bundle.build().then(() => {\n    return {\n      generate: () => bundle.render()\n    };\n  });\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["由此可见，所有核心的逻辑我们封装在了 Bundle 对象中，接着新建",(0,r.jsx)(e.code,{children:"Bundle.ts"}),"及其依赖的",(0,r.jsx)(e.code,{children:"Graph.ts"}),"， 添加如下的代码骨架:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// Bundle.ts\nexport class Bundle {\n  graph: Graph;\n  constructor(options: BundleOptions) {\n    // 初始化模块依赖图对象\n    this.graph = new Graph({\n      entry: options.entry,\n      bundle: this\n    });\n  }\n\n  async build() {\n    // 模块打包逻辑，完成所有的 AST 相关操作\n    return this.graph.build();\n  }\n  \n  render() {\n    // 代码生成逻辑，拼接模块 AST 节点，产出代码\n  }\n  \n  getModuleById(id: string) {\n    return this.graph.getModuleById(id);\n  }\n\n  addModule(module: Module) {\n    return this.graph.addModule(module);\n  }\n}\n\n// Graph.ts\n// 模块依赖图对象的实现\nimport { dirname, resolve } from 'path';\nexport class Graph {\n  entryPath: string;\n  basedir: string;\n  moduleById: Record<string, Module> = {};\n  modules: Module[] = [];\n\n  constructor(options: GraphOptions) {\n    const { entry, bundle } = options;\n    this.entryPath = resolve(entry);\n    this.basedir = dirname(this.entryPath);\n    this.bundle = bundle;\n  }\n  \n  async build() {\n    // 1. 获取并解析模块信息\n    // 2. 构建依赖关系图\n    // 3. 模块拓扑排序\n    // 4. Tree Shaking, 标记需要包含的语句\n  }\n  \n  getModuleById(id: string) {\n    return this.moduleById[id];\n  }\n\n  addModule(module: Module) {\n    if (!this.moduleById[module.id]) {\n      this.moduleById[module.id] = module;\n      this.modules.push(module);\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们就正式开始实现打包器的模块解析逻辑。"}),"\n",(0,r.jsxs)(e.h3,{id:"模块-ast-解析",children:["模块 AST 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模块-ast-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们基于目前的 ",(0,r.jsx)(e.code,{children:"Graph.ts"})," 继续开发，首先在 Graph 对象中初始化模块加载器(ModuleLoader):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Graph.ts\nimport { dirname, resolve } from 'path';\nexport class Graph {\n  constructor(options: GraphOptions) {\n    // 省略其它代码\n    // 初始化模块加载器对象\n    this.moduleLoader = new ModuleLoader(bundle);\n  }\n  \n  async build() {\n    // 1. 获取并解析模块信息，返回入口模块对象\n    const entryModule = await this.moduleLoader.fetchModule(\n      this.entryPath,\n      null,\n      true\n    );\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["然后添加",(0,r.jsx)(e.code,{children:"ModuleLoader.ts"}),"，代码如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/ModuleLoader.ts\nexport class ModuleLoader {\n  bundle: Bundle;\n  resolveIdsMap: Map<string, string | false> = new Map();\n  constructor(bundle: Bundle) {\n    this.bundle = bundle;\n  }\n \n  // 解析模块逻辑\n  resolveId(id: string, importer: string | null) {\n    const cacheKey = id + importer;\n    if (this.resolveIdsMap.has(cacheKey)) {\n      return this.resolveIdsMap.get(cacheKey)!;\n    }\n    const resolved = defaultResolver(id, importer);\n    this.resolveIdsMap.set(cacheKey, resolved);\n    return resolved;\n  }\n  \n  // 加载模块内容并解析\n  async fetchModule(\n    id: string,\n    importer: null | string,\n    isEntry = false,\n    bundle: Bundle = this.bundle,\n    loader: ModuleLoader = this\n  ): Promise<Module | null> {\n    const path = this.resolveId(id, importer);\n    // 查找缓存\n    const existModule = this.bundle.getModuleById(path);\n    if (existModule) {\n      return existModule;\n    }\n    const code = await readFile(path, { encoding: 'utf-8' });\n    // 初始化模块，解析 AST\n    const module = new Module({\n      path,\n      code,\n      bundle,\n      loader,\n      isEntry\n    });\n    this.bundle.addModule(module);\n    // 拉取所有的依赖模块\n    await this.fetchAllDependencies(module);\n    return module;\n  }\n  \n  async fetchAllDependencies(module: Module) {\n    await Promise.all(\n      module.dependencies.map((dep) => {\n        return this.fetchModule(dep, module.path);\n      })\n    );\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["主要由 ",(0,r.jsx)(e.code,{children:"fetchModule"})," 方法完成模块的加载和解析，流程如下:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"调用 resolveId 方法解析模块路径"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsx)(e.li,{children:"初始化模块实例即 Module 对象，解析模块 AST"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsx)(e.li,{children:"递归初始化模块的所有依赖模块"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"其中，最主要的逻辑在于第二步，即 Module 对象实例的初始化，在这个过程中，模块代码将会被进行 AST 解析及依赖分析。接下来，让我们把目光集中在 Module 对象的实现上。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Module.ts\nexport class Module {\n  isEntry: boolean = false;\n  id: string;\n  path: string;\n  bundle: Bundle;\n  moduleLoader: ModuleLoader;\n  code: string;\n  magicString: MagicString;\n  statements: Statement[];\n  imports: Imports;\n  exports: Exports;\n  reexports: Exports;\n  exportAllSources: string[] = [];\n  exportAllModules: Module[] = [];\n  dependencies: string[] = [];\n  dependencyModules: Module[] = [];\n  referencedModules: Module[] = [];\n  constructor({ path, bundle, code, loader, isEntry = false }: ModuleOptions) {\n    this.id = path;\n    this.bundle = bundle;\n    this.moduleLoader = loader;\n    this.isEntry = isEntry;\n    this.path = path;\n    this.code = code;\n    this.magicString = new MagicString(code);\n    this.imports = {};\n    this.exports = {};\n    this.reexports = {};\n    this.declarations = {};\n    try {\n      const ast = parse(code) as any;\n      const nodes = ast.body as StatementNode[];\n      // 以语句(Statement)的维度来拆分 Module，保存 statement 的集合，供之后分析\n      this.statements = nodes.map((node) => {\n        const magicString = this.magicString.snip(node.start, node.end);\n        // Statement 对象将在后文中介绍具体实现\n        return new Statement(node, magicString, this);\n      });\n    } catch (e) {\n      console.log(e);\n      throw e;\n    }\n    // 分析 AST 节点\n    this.analyseAST();\n  }\n  analyseAST() {\n    // 以语句为最小单元来分析\n    this.statements.forEach((statement) => {\n      // 对 statement 进行分析\n      statement.analyse();\n      // 注册顶层声明\n      if (!statement.scope.parent) {\n        statement.scope.eachDeclaration((name, declaration) => {\n          this.declarations[name] = declaration;\n        });\n      }\n    });\n    // 注册 statement 的 next 属性，用于生成代码使用，next 即下一个 statement 的起始位置\n    const statements = this.statements;\n    let next = this.code.length;\n    for (let i = statements.length - 1; i >= 0; i--) {\n      statements[i].next = next;\n      next = statements[i].start;\n    }\n  }  \n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"OK，我们可以来梳理一下解析 AST 节点主要做了哪些事情:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"调用 ast-parser 将代码字符串解析为 AST 对象。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"遍历 AST 对象中的各个语句，以语句的维度来进行 AST 分析，通过语句的分析结果来构造作用域链和模块依赖关系。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["ast-parser 的解析部分我们已经详细介绍过，这里不再赘述。接下来我们将重点放到 Statement 对象的实现上。你可以新建",(0,r.jsx)(e.code,{children:"src/Statement.ts"}),"，内容如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Statement.ts\n// 以下为三个工具函数\n// 是否为函数节点\nfunction isFunctionDeclaration(node: Declaration): boolean {\n  if (!node) return false;\n  return (\n    // function foo() {}\n    node.type === 'FunctionDeclaration' ||\n    // const foo = function() {}\n    (node.type === NodeType.VariableDeclarator &&\n      node.init &&\n      node.init.type === NodeType.FunctionExpression) ||\n    // export function ...\n    // export default function\n    ((node.type === NodeType.ExportNamedDeclaration ||\n      node.type === NodeType.ExportDefaultDeclaration) &&\n      !!node.declaration &&\n      node.declaration.type === NodeType.FunctionDeclaration)\n  );\n}\n\n// 是否为 export 声明节点\nexport function isExportDeclaration(node: ExportDeclaration): boolean {\n  return /^Export/.test(node.type);\n}\n\n// 是否为 import 声明节点\nexport function isImportDeclaration(node: any) {\n  return node.type === 'ImportDeclaration';\n}\n\nexport class Statement {\n  node: StatementNode;\n  magicString: MagicString;\n  module: Module;\n  scope: Scope;\n  start: number;\n  next: number;\n  isImportDeclaration: boolean;\n  isExportDeclaration: boolean;\n  isReexportDeclaration: boolean;\n  isFunctionDeclaration: boolean;\n  isIncluded: boolean = false;\n  defines: Set<string> = new Set();\n  modifies: Set<string> = new Set();\n  dependsOn: Set<string> = new Set();\n  references: Reference[] = [];\n  constructor(node: StatementNode, magicString: MagicString, module: Module) {\n    this.magicString = magicString;\n    this.node = node;\n    this.module = module;\n    this.scope = new Scope({\n      statement: this\n    });\n    this.start = node.start;\n    this.next = 0;\n    this.isImportDeclaration = isImportDeclaration(node);\n    this.isExportDeclaration = isExportDeclaration(node as ExportDeclaration);\n    this.isReexportDeclaration =\n      this.isExportDeclaration &&\n      !!(node as ExportAllDeclaration | ExportNamedDeclaration).source;\n    this.isFunctionDeclaration = isFunctionDeclaration(\n      node as FunctionDeclaration\n    );\n\n  }\n\n  analyse() {\n    if (this.isImportDeclaration) return;\n    // 1、构建作用域链，记录 Declaration 节点表\n    buildScope(this);\n    // 2. 寻找引用的依赖节点，记录 Reference 节点表\n    findReference(this);\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"在 Statement 节点的分析过程中主要需要做两件事情:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"构建作用域链。这是为了记录当前语句中声明的变量。"}),"\n",(0,r.jsx)(e.li,{children:"记录引用的依赖节点。这是为了记录当前语句引用了哪些变量以及这些变量对应的 AST 节点。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["而无论是构建作用域链还是记录引用节点，我们都离不开一个最基本的操作，那就是对 AST 进行遍历操作。你可以新建",(0,r.jsx)(e.code,{children:"src/utils/walk.ts"}),"，用来存放 AST 节点遍历的逻辑，代码可以去 ",(0,r.jsx)(e.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/blob/main/bundler/src/utils/walk.ts",target:"_blank",rel:"noopener noreferrer",children:"Github 仓库链接"}),"获取，由于这部分内容并不属于本文的重点，就不再详细赘述了，感兴趣的同学可以研究一下实现细节。接下来我们主要通过这个遍历器来完成 Statement 节点的分析。"]}),"\n",(0,r.jsx)(e.p,{children:"对于作用域链的分析，我们先来新建一个 Scope 对象，封装作用域相关的基本信息:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/utils/Scope.ts\nimport { Statement } from 'Statement';\nimport { Declaration } from 'ast/Declaration';\n\ninterface ScopeOptions {\n  parent?: Scope;\n  paramNodes?: any[];\n  block?: boolean;\n  statement: Statement;\n  isTopLevel?: boolean;\n}\n\nexport class Scope {\n  // 父作用域\n  parent?: Scope;\n  // 如果是函数作用域，则需要参数节点\n  paramNodes: any[];\n  // 是否为块级作用域\n  isBlockScope?: boolean;\n  // 作用域对应的语句节点\n  statement: Statement;\n  // 变量/函数 声明节点，为 Scope 的核心数据\n  declarations: Record<string, Declaration> = {};\n  constructor(options: ScopeOptions) {\n    const { parent, paramNodes, block, statement } = options;\n    this.parent = parent;\n    this.paramNodes = paramNodes || [];\n    this.statement = statement;\n    this.isBlockScope = !!block;\n    this.paramNodes.forEach(\n      (node) =>\n        (this.declarations[node.name] = new Declaration(\n          node,\n          true,\n          this.statement\n        ))\n    );\n  }\n\n  addDeclaration(node: any, isBlockDeclaration: boolean) {\n    // block scope & var, 向上追溯，直到顶层作用域\n    if (this.isBlockScope && !isBlockDeclaration && this.parent) {\n      this.parent.addDeclaration(node, isBlockDeclaration);\n    } else {\n      // 否则在当前作用域新建声明节点(Declaration)\n      const key = node.id && node.id.name;\n      this.declarations[key] = new Declaration(node, false, this.statement);\n    }\n  }\n\n  // 遍历声明节点(Declaration)\n  eachDeclaration(fn: (name: string, dec: Declaration) => void) {\n    Object.keys(this.declarations).forEach((key) => {\n      fn(key, this.declarations[key]);\n    });\n  }\n\n  contains(name: string): Declaration {\n    return this.findDeclaration(name);\n  }\n\n  findDeclaration(name: string): Declaration {\n    return (\n      this.declarations[name] ||\n      (this.parent && this.parent.findDeclaration(name))\n    );\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["Scope 的核心在于声明节点(即",(0,r.jsx)(e.code,{children:"Declaration"}),")的收集与存储，而上述的代码中并没有 Declaration 对象的实现，接下来我们来封装一下这个对象:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/ast/Declaration.ts\nimport { Module } from '../Module';\nimport { Statement } from '../Statement';\nimport { Reference } from './Reference';\n\nexport class Declaration {\n  isFunctionDeclaration: boolean = false;\n  functionNode: any;\n  statement: Statement | null;\n  name: string | null = null;\n  isParam: boolean = false;\n  isUsed: boolean = false;\n  isReassigned: boolean = false;\n  constructor(node: any, isParam: boolean, statement: Statement | null) {\n    // 考虑函数和变量声明两种情况\n    if (node) {\n      if (node.type === 'FunctionDeclaration') {\n        this.isFunctionDeclaration = true;\n        this.functionNode = node;\n      } else if (\n        node.type === 'VariableDeclarator' &&\n        node.init &&\n        /FunctionExpression/.test(node.init.type)\n      ) {\n        this.isFunctionDeclaration = true;\n        this.functionNode = node.init;\n      }\n    }\n    this.statement = statement;\n    this.isParam = isParam;\n  }\n  \n  addReference(reference: Reference) {\n    reference.declaration = this;\n    this.name = reference.name;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"既然有了声明节点，那么我们如果感知到哪些地方使用了这些节点呢？这时候就需要 Reference 节点登场了，它的作用就是记录其它节点与 Declaration 节点的引用关系，让我门来简单实现一下:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"import { Scope } from './Scope';\nimport { Statement } from '../Statement';\nimport { Declaration } from './Declaration';\n\nexport class Reference {\n  node: any;\n  scope: Scope;\n  statement: Statement;\n  // declaration 信息在构建依赖图的部分补充\n  declaration: Declaration | null = null;\n  name: string;\n  start: number;\n  end: number;\n  objectPaths: any[] = [];\n  constructor(node: any, scope: Scope, statement: Statement) {\n    this.node = node;\n    this.scope = scope;\n    this.statement = statement;\n    this.start = node.start;\n    this.end = node.end;\n    let root = node;\n    this.objectPaths = [];\n    while (root.type === 'MemberExpression') {\n      this.objectPaths.unshift(root.property);\n      root = root.object;\n    }\n    this.objectPaths.unshift(root);\n    this.name = root.name;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"OK，前面铺垫了这么多基础的数据结构，让大家了解到各个关键对象的作用及其联系，接下来我们正式开始编写构建作用域链的代码。"}),"\n",(0,r.jsxs)(e.p,{children:["你可以新建",(0,r.jsx)(e.code,{children:"src/utils/buildScope.ts"}),"，内容如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"import { walk } from 'utils/walk';\nimport { Scope } from 'ast/Scope';\nimport { Statement } from 'Statement';\nimport {\n  NodeType,\n  Node,\n  VariableDeclaration,\n  VariableDeclarator\n} from 'ast-parser';\nimport { FunctionDeclaration } from 'ast-parser';\n\nexport function buildScope(statement: Statement) {\n  const { node, scope: initialScope } = statement;\n  let scope = initialScope;\n  // 遍历 AST\n  walk(node, {\n    // 遵循深度优先的原则，每进入和离开一个节点会触发 enter 和 leave 钩子\n    // 如 a 的子节点为 b，那么触发顺序为 a-enter、b-enter、b-leave、a-leave\n    enter(node: Node) {\n      // function foo () {...}\n      if (node.type === NodeType.FunctionDeclaration) {\n        scope.addDeclaration(node, false);\n      }\n      // var let const\n      if (node.type === NodeType.VariableDeclaration) {\n        const currentNode = node as VariableDeclaration;\n        const isBlockDeclaration = currentNode.kind !== 'var';\n        currentNode.declarations.forEach((declarator: VariableDeclarator) => {\n          scope.addDeclaration(declarator, isBlockDeclaration);\n        });\n      }\n\n      let newScope;\n\n      // function scope\n      if (node.type === NodeType.FunctionDeclaration) {\n        const currentNode = node as FunctionDeclaration;\n        newScope = new Scope({\n          parent: scope,\n          block: false,\n          paramNodes: currentNode.params,\n          statement\n        });\n      }\n\n      // new block scope\n      if (node.type === NodeType.BlockStatement) {\n        newScope = new Scope({\n          parent: scope,\n          block: true,\n          statement\n        });\n      }\n      // 记录 Scope 父子关系\n      if (newScope) {\n        Object.defineProperty(node, '_scope', {\n          value: newScope,\n          configurable: true\n        });\n\n        scope = newScope;\n      }\n    },\n    leave(node: any) {\n      // 更新当前作用域\n      // 当前 scope 即 node._scope\n      if (node._scope && scope.parent) {\n        scope = scope.parent;\n      }\n    }\n  });\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"从中可以看到，我们会对如下类型的 AST 节点进行处理:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["变量声明节点。包括",(0,r.jsx)(e.code,{children:"var"}),"、",(0,r.jsx)(e.code,{children:"let"}),"和",(0,r.jsx)(e.code,{children:"const"}),"声明对应的节点。对",(0,r.jsx)(e.code,{children:"let"}),"和",(0,r.jsx)(e.code,{children:"const"}),"，我们需要将声明节点绑定到",(0,r.jsx)(e.code,{children:"当前作用域"}),"中，而对于",(0,r.jsx)(e.code,{children:"var"}),"，需要绑定到全局作用域。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"函数声明节点。对于这类节点，我们直接创建一个新的作用域。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["块级节点。即用 ",(0,r.jsx)(e.code,{children:"{ }"})," 包裹的节点，如 if 块、函数体，此时我们也创建新的作用域。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在构建完作用域完成后，我们进入下一个环节: ",(0,r.jsx)(e.strong,{children:"记录引用节点"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["新建",(0,r.jsx)(e.code,{children:"src/utils/findReference.ts"}),"，内容如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"import { Statement } from 'Statement';\nimport { walk } from 'utils/walk';\nimport { Reference } from 'ast/Reference';\n\nfunction isReference(node: any, parent: any): boolean {\n  if (node.type === 'MemberExpression' && parent.type !== 'MemberExpression') {\n    return true;\n  }\n  if (node.type === 'Identifier') {\n    // 如 export { foo as bar }, 忽略 bar\n    if (parent.type === 'ExportSpecifier' && node !== parent.local)\n      return false;\n    // 如 import { foo as bar } from 'xxx', 忽略 bar\n    if (parent.type === 'ImportSpecifier' && node !== parent.imported) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n}\n\nexport function findReference(statement: Statement) {\n  const { references, scope: initialScope, node } = statement;\n  let scope = initialScope;\n  walk(node, {\n    enter(node: any, parent: any) {\n      if (node._scope) scope = node._scope;\n      if (isReference(node, parent)) {\n        // 记录 Reference 节点\n        const reference = new Reference(node, scope, statement);\n        references.push(reference);\n      }\n    },\n    leave(node: any) {\n      if (node._scope && scope.parent) {\n        scope = scope.parent;\n      }\n    }\n  });\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"至此，我们就完成了模块 AST 解析的功能。"}),"\n",(0,r.jsxs)(e.h2,{id:"模块依赖图绑定",children:["模块依赖图绑定",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模块依赖图绑定",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"回到 Graph 对象中，接下来我们需要实现的是模块依赖图的构建:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Graph.ts\nexport class Graph {\n  async build() {\n    //  ✅(完成) 1. 获取并解析模块信息\n    // 2. 构建依赖关系图\n    this.module.forEach(module => module.bind());\n    // 3. 模块拓扑排序\n    // 4. Tree Shaking, 标记需要包含的语句\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"现在我们在 Module 对象的 AnalyzeAST 中新增依赖绑定的代码:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Module.ts\nanalyzeAST() {\n  // 如果语句为 import/export 声明，那么给当前模块记录依赖的标识符\n  this.statements.forEach((statement) => {\n    if (statement.isImportDeclaration) {\n      this.addImports(statement);\n    } else if (statement.isExportDeclaration) {\n      this.addExports(statement);\n    }\n  });\n}\n\n// 处理 import 声明\naddImports(statement: Statement) {\n  const node = statement.node as any;\n  const source = node.source.value;\n  // import\n  node.specifiers.forEach((specifier: Specifier) => {\n    // 为方便理解，本文只处理具名导入\n    const localName = specifier.local.name;\n    const name = specifier.imported.name;\n    this.imports[localName] = { source, name, localName };\n  });\n  this._addDependencySource(source);\n}\n\n// 处理 export 声明\naddExports(statement: Statement) {\n  const node = statement.node as any;\n  const source = node.source && node.source.value;\n  // 为方便立即，本文只处理具名导出\n  if (node.type === 'ExportNamedDeclaration') {\n    // export { a, b } from 'mod'\n    if (node.specifiers.length) {\n      node.specifiers.forEach((specifier: Specifier) => {\n        const localName = specifier.local.name;\n        const exportedName = specifier.exported.name;\n        this.exports[exportedName] = {\n          localName,\n          name: exportedName\n        };\n        if (source) {\n          this.reexports[localName] = {\n            statement,\n            source,\n            localName,\n            name: localName,\n            module: undefined\n          };\n          this.imports[localName] = {\n            source,\n            localName,\n            name: localName\n          };\n          this._addDependencySource(source);\n        }\n      });\n    } else {\n      const declaration = node.declaration;\n      let name;\n      if (declaration.type === 'VariableDeclaration') {\n        // export const foo = 2;\n        name = declaration.declarations[0].id.name;\n      } else {\n        // export function foo() {}\n        name = declaration.id.name;\n      }\n      this.exports[name] = {\n        statement,\n        localName: name,\n        name\n      };\n    }\n  } else if (node.type === 'ExportAllDeclaration') {\n    // export * from 'mod'\n    if (source) {\n      this.exportAllSources.push(source);\n      this.addDependencySource(source);\n    }\n  }\n}\n\nprivate _addDependencySource(source: string) {\n  if (!this.dependencies.includes(source)) {\n    this.dependencies.push(source);\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["在记录完 import 和 export 的标识符之后，我们根据这些标识符绑定到具体的模块对象，新增",(0,r.jsx)(e.code,{children:"bind"}),"方法，实现如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"bind() {\n  // 省略已有代码\n  // 记录标识符对应的模块对象\n  this.bindDependencies();\n  /// 除此之外，根据之前记录的 Reference 节点绑定对应的 Declaration 节点\n  this.bindReferences();\n}\n\nbindDependencies() {\n  [...Object.values(this.imports), ...Object.values(this.reexports)].forEach(\n    (specifier) => {\n      specifier.module = this._getModuleBySource(specifier.source!);\n    }\n  );\n  this.exportAllModules = this.exportAllSources.map(\n    this._getModuleBySource.bind(this)\n  );\n  // 建立模块依赖图\n  this.dependencyModules = this.dependencies.map(\n    this._getModuleBySource.bind(this)\n  );\n  this.dependencyModules.forEach((module) => {\n    module.referencedModules.push(this);\n  });\n}\n\nbindReferences() {\n  this.statements.forEach((statement) => {\n    statement.references.forEach((reference) => {\n      // 根据引用寻找声明的位置\n      // 寻找顺序: 1. statement 2. 当前模块 3. 依赖模块\n      const declaration =\n        reference.scope.findDeclaration(reference.name) ||\n        this.trace(reference.name);\n      if (declaration) {\n        declaration.addReference(reference);\n      }\n    });\n  });\n}\n\nprivate _getModuleBySource(source: string) {\n  const id = this.moduleLoader.resolveId(source!, this.path) as string;\n  return this.bundle.getModuleById(id);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"现在，我们便将各个模块间的依赖关系绑定完成了。"}),"\n",(0,r.jsxs)(e.h2,{id:"模块拓扑排序",children:["模块拓扑排序",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模块拓扑排序",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们将所有的模块根据依赖关系进行拓扑排序:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Graph.ts\nexport class Graph {\n  async build() {\n    //  ✅(完成) 1. 获取并解析模块信息\n    //  ✅(完成) 2. 构建依赖关系图\n    // 3. 模块拓扑排序\n    this.orderedModules = this.sortModules(entryModule!);\n    // 4. Tree Shaking, 标记需要包含的语句\n  }\n  \n  sortModules(entryModule: Module) {\n    // 拓扑排序模块数组\n    const orderedModules: Module[] = [];\n    // 记录已经分析过的模块表\n    const analysedModule: Record<string, boolean> = {};\n    // 记录模块的父模块 id \n    const parent: Record<string, string> = {};\n    // 记录循环依赖\n    const cyclePathList: string[][] = [];\n    \n    // 用来回溯，用来定位循环依赖\n    function getCyclePath(id: string, parentId: string): string[] {\n      const paths = [id];\n      let currrentId = parentId;\n      while (currrentId !== id) {\n        paths.push(currrentId);\n        // 向前回溯\n        currrentId = parent[currrentId];\n      }\n      paths.push(paths[0]);\n      return paths.reverse();\n    }\n    \n    // 拓扑排序核心逻辑，基于依赖图的后序遍历完成\n    function analyseModule(module: Module) {\n      if (analysedModule[module.id]) {\n        return;\n      }\n      for (const dependency of module.dependencyModules) {\n        // 检测循环依赖\n        // 为什么是这个条件，下文会分析\n        if (parent[dependency.id]) {\n          if (!analysedModule[dependency.id]) {\n            cyclePathList.push(getCyclePath(dependency.id, module.id));\n          }\n          continue;\n        }\n        parent[dependency.id] = module.id;\n        analyseModule(dependency);\n      }\n      analysedModule[module.id] = true;\n      orderedModules.push(module);\n    }\n    // 从入口模块开始分析\n    analyseModule(entryModule);\n    // 如果有循环依赖，则打印循环依赖信息\n    if (cyclePathList.length) {\n      cyclePathList.forEach((paths) => {\n        console.log(paths);\n      });\n      process.exit(1);\n    }\n    return orderedModules;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"拓扑排序的核心在于对依赖图进行后续遍历，将被依赖的模块放到前面，如下图所示:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["其中 A 依赖 B 和 C，B 和 C 依赖 D，D 依赖 E，那么最后的拓扑排序即",(0,r.jsx)(e.code,{children:"E、D、B、C、A"}),"。但也有一种特殊情况，就是出现循环的情况，如下面这张图所示:"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["上图中的依赖关系呈现了",(0,r.jsx)(e.code,{children:"B->C->D->B"}),"的循环依赖，这种情况是我们需要避免的。那么如何来检测出循环依赖呢？"]}),"\n",(0,r.jsxs)(e.p,{children:["由于 ",(0,r.jsx)(e.code,{children:"analyseModule"})," 函数中采用后序的方式来遍历依赖，也就是说一旦某个模块被记录到 ",(0,r.jsx)(e.code,{children:"analysedModule"})," 表中，那么也就意味着其所有的依赖模块已经被遍历完成了:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"function analyseModule(module: Module) {\n  if (analysedModule[module.id]) {\n    return;\n  }\n  for (const dependency of module.dependencyModules) {\n    // 检测循环依赖的代码省略\n    parent[dependency.id] = module.id;\n    analyseModule(dependency);\n  }\n  analysedModule[module.id] = true;\n  orderedModules.push(module);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"如果某个模块没有被记录到 analysedModule 中，则表示它的依赖模块并没有分析完，在这个前提下中，如果再次遍历到这个模块，说明已经出现了循环依赖，你可以对照下图理解:"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"因此检测循环依赖的条件应该为下面这样:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"for (const dependency of module.dependencyModules) {\n  // 检测循环依赖\n  // 1. 不为入口模块\n  if (parent[dependency.id]) {\n    // 2. 依赖模块还没有分析结束\n    if (!analysedModule[dependency.id]) {\n      cyclePathList.push(getCyclePath(dependency.id, module.id));\n    }\n    continue;\n  }\n  parent[dependency.id] = module.id;\n  analyseModule(dependency);\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["OK，到目前为止，我们完成了第三步",(0,r.jsx)(e.code,{children:"模块拓扑排序"}),"的步骤，接下来我们进入 Tree Shaking 功能的开发:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Graph.ts\nexport class Graph {\n  async build() {\n    // ✅(完成) 1. 获取并解析模块信息\n    // ✅(完成) 2. 构建依赖关系图\n    // ✅(完成) 3. 模块拓扑排序\n    // 4. Tree Shaking, 标记需要包含的语句\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"实现-tree-shaking",children:["实现 Tree Shaking",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-tree-shaking",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"相信 Tree Shaking 对于大家并不陌生，它主要的作用就是在打包产物中摇掉没有使用的代码，从而优化产物体积。而得益于 ES 模块的静态特性，我们可以基于 import/export 的符号可达性来进行 Tree Shaking 分析，如:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// index.ts\nimport { a } from './utils';\n\nconsole.log(a);\n\n// utils.ts\nexport const a = 1;\n\nexport const b = 2;\n"})}),"\n",(0,r.jsx)(e.p,{children:"由于在如上的代码中我们只使用到了 a，则 a 属于可达符号，b 属于不可达符号，因此最后的代码不会包含 b 相关的实现代码。"}),"\n",(0,r.jsx)(e.p,{children:"接下来我们就来实现这一功能，即基于符号可达性来进行无用代码的删除。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Graph.ts\nexport class Graph {\n  async build() {\n    // ✅(完成) 1. 获取并解析模块信息\n    // ✅(完成) 2. 构建依赖关系图\n    // ✅(完成) 3. 模块拓扑排序\n    // 4. Tree Shaking, 标记需要包含的语句\n    // 从入口处分析\n    entryModule!.getExports().forEach((name) => {\n      const declaration = entryModule!.traceExport(name);\n      declaration!.use();\n    });\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["在 Module 对象中，我们需要增加",(0,r.jsx)(e.code,{children:"getExports"}),"和",(0,r.jsx)(e.code,{children:"traceExport"}),"方法来获取和分析模块的导出:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// 拿到模块所有导出\ngetExports(): string[] {\n  return [\n    ...Object.keys(this.exports),\n    ...Object.keys(this.reexports),\n    ...this.exportAllModules\n      .map(module => module.getExports())\n      .flat()  \n    ];\n}\n\n// 从导出名追溯到 Declaration 声明节点\ntraceExport(name: string): Declaration | null {\n  // 1. reexport\n  // export { foo as bar } from './mod'\n  const reexportDeclaration = this.reexports[name];\n  if (reexportDeclaration) {\n    // 说明是从其它模块 reexport 出来的\n    // 经过 bindDependencies 方法处理，现已绑定 module\n    const declaration = reexportDeclaration.module!.traceExport(\n      reexportDeclaration.localName\n    );\n    if (!declaration) {\n      throw new Error(\n        `${reexportDeclaration.localName} is not exported by module ${\n          reexportDeclaration.module!.path\n        }(imported by ${this.path})`\n      );\n    }\n    return declaration;\n  }\n  // 2. export\n  // export { foo }\n  const exportDeclaration = this.exports[name];\n  if (exportDeclaration) {\n    const declaration = this.trace(name);\n    if (declaration) {\n      return declaration;\n    }\n  }\n  // 3. export all\n  for (let exportAllModule of this.exportAllModules) {\n    const declaration = exportAllModule.trace(name);\n    if (declaration) {\n      return declaration;\n    }\n  }\n  return null;\n}\n\ntrace(name: string) {\n  if (this.declarations[name]) {\n    // 从当前模块找\n    return this.declarations[name];\n  }\n  // 从依赖模块找\n  if (this.imports[name]) {\n    const importSpecifier = this.imports[name];\n    const importModule = importSpecifier.module!;\n    const declaration = importModule.traceExport(importSpecifier.name);\n    if (declaration) {\n      return declaration;\n    }\n  }\n  return null;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"当我们对每个导出找到对应的 Declaration 节点之后，则对这个节点进行标记，从而让其代码能够在代码生成阶段得以保留。那么如何进行标记呢？"}),"\n",(0,r.jsxs)(e.p,{children:["我们不妨回到 Declaration 的实现中，增加 ",(0,r.jsx)(e.code,{children:"use"})," 方法:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"use() {\n  // 标记该节点被使用\n  this.isUsed = true;\n  // 对应的 statement 节点也应该被标记\n  if (this.statement) {\n    this.statement.mark();\n  }\n}\n\n// 另外，你可以加上 render 方法，便于后续代码生成的步骤\nrender() {\n  return this.name;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"接下来我们到 Statement 对象中，继续增加 mark 方法，来追溯被使用过的 Declaration 节点:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// src/Statement.ts\nmark() {\n  if (this.isIncluded) {\n    return;\n  }\n  this.isIncluded = true;\n  this.references.forEach(\n    (ref: Reference) => ref.declaration && ref.declaration.use()\n  );\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这时候，Reference 节点的作用就体现出来了，由于我们之前专门收集到 Statement 的 Reference 节点，通过 Reference 节点我们可以追溯到对应的 Declaration 节点，并调用其 use 方法进行标记。"}),"\n",(0,r.jsxs)(e.h2,{id:"代码生成",children:["代码生成",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码生成",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"如此，我们便完成了 Tree Shaking 的标记过程，接下来我们看看如何来进行代码生成，直观地看到 Tree Shaking 的效果。"}),"\n",(0,r.jsxs)(e.p,{children:["我们在 Module 对象中增加",(0,r.jsx)(e.code,{children:"render"}),"方法，用来将模块渲染为字符串:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"render() {\n  const source = this.magicString.clone().trim();\n  this.statements.forEach((statement) => {\n    // 1. Tree Shaking\n    if (!statement.isIncluded) {\n      source.remove(statement.start, statement.next);\n      return;\n    }\n    // 2. 重写引用位置的变量名 -> 对应的声明位置的变量名\n    statement.references.forEach((reference) => {\n      const { start, end } = reference;\n      const declaration = reference.declaration;\n      if (declaration) {\n        const name = declaration.render();\n        source.overwrite(start, end, name!);\n      }\n    });\n    // 3. 擦除/重写 export 相关的代码\n    if (statement.isExportDeclaration && !this.isEntry) {\n      // export { foo, bar }\n      if (\n        statement.node.type === 'ExportNamedDeclaration' &&\n        statement.node.specifiers.length\n      ) {\n        source.remove(statement.start, statement.next);\n      }\n      // remove `export` from `export const foo = 42`\n      else if (\n        statement.node.type === 'ExportNamedDeclaration' &&\n        (statement.node.declaration!.type === 'VariableDeclaration' ||\n          statement.node.declaration!.type === 'FunctionDeclaration')\n      ) {\n        source.remove(\n          statement.node.start,\n          statement.node.declaration!.start\n        );\n      }\n      // remove `export * from './mod'`\n      else if (statement.node.type === 'ExportAllDeclaration') {\n        source.remove(statement.start, statement.next);\n      }\n    }\n  });\n  return source.trim();\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"接着，我们在 Bundle 对象也实现一下 render 方法，用来生成最后的产物代码:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"render(): { code: string } {\n  let msBundle = new MagicString.Bundle({ separator: '\\n' });\n  // 按照模块拓扑顺序生成代码\n  this.graph.orderedModules.forEach((module) => {\n    msBundle.addSource({\n      content: module.render()\n    });\n  });\n\n  return {\n    code: msBundle.toString(),\n  };\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"OK，现在我们终于可以来测试目前的 Bundler 功能了，测试代码如下:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// test.js\nconst fs = require('fs');\nconst { build } = require('./dist/index');\n\nasync function buildTest() {\n  const bundle = await build({\n    input: './test/index.js'\n  });\n  const res = bundle.generate();\n  fs.writeFileSync('./test/bundle.js', res.code);\n}\n\nbuildTest();\n\n// test/index.js\nimport { a, add } from './utils.js';\n\nexport const c = add(a, 2);\n\n// test/utils.js\nexport const a = 1;\nexport const b = 2;\nexport const add = function (num1, num2) {\n  return num1 + num2;\n};\n"})}),"\n",(0,r.jsxs)(e.p,{children:["在终端执行",(0,r.jsx)(e.code,{children:"node test.js"}),"，即可将产物代码输出到 test 目录下的 ",(0,r.jsx)(e.code,{children:"bundle.js"})," 中:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"// test/bundle.js\nconst a = 1;\nconst add = function (num1, num2) {\n  return num1 + num2;\n};\nexport const c = add(a, 2);\n"})}),"\n",(0,r.jsx)(e.p,{children:"可以看到，最后的产物代码已经成功生成，变量 b 相关的代码已经完全从产出中擦除，实现了基于符号可达性的 Tree Shaking 的效果。"}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"至此，我们便实现了一个简易版的 Bundler，完成了如下几个核心的步骤:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"模块 AST 解析"}),"\n",(0,r.jsx)(e.li,{children:"模块依赖图生成"}),"\n",(0,r.jsx)(e.li,{children:"模块拓扑排序"}),"\n",(0,r.jsx)(e.li,{children:"基于符号可达性的 Tree Shaking"}),"\n",(0,r.jsx)(e.li,{children:"Bundle 代码生成"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["文中所有的代码我也已经放到了 ",(0,r.jsx)(e.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/tree/main/bundler",target:"_blank",rel:"noopener noreferrer",children:"Github 仓库"}),"上，你可以对照着一起学习。"]}),"\n",(0,r.jsx)(e.p,{children:"最后，恭喜你学习完了本小册最后一节的内容，不过我并不希望这一小节作为小册的结束，在未来我还会不定期地更新一些加餐内容，将这本小册打磨得更加系统和完善，和大家一起继续加油！"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F27.%E6%89%8B%E5%86%99%20Bundler_%20%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%89%93%E5%8C%85%E3%80%81%20Tree%20Shaking.md"]={toc:[{text:"实现思路梳理",id:"实现思路梳理",depth:2},{text:"开发环境搭建",id:"开发环境搭建",depth:2},{text:"模块 AST 解析",id:"模块-ast-解析",depth:3},{text:"模块依赖图绑定",id:"模块依赖图绑定",depth:2},{text:"模块拓扑排序",id:"模块拓扑排序",depth:2},{text:"实现 Tree Shaking",id:"实现-tree-shaking",depth:2},{text:"代码生成",id:"代码生成",depth:2},{text:"小结",id:"小结",depth:2}],title:"27.手写 Bundler_ 实现代码打包、 Tree Shaking",headingTitle:"27.手写 Bundler_ 实现代码打包、 Tree Shaking",frontmatter:{}}}}]);