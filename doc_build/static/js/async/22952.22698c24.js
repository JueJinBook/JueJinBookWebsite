"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["22952"],{360857:function(e,n,r){r.r(n),r.d(n,{default:()=>E});var s=r(552676),t=r(740453);let c=r.p+"static/image/994e156b4834ad190464292069e69bab.69bba4f5.webp",i=r.p+"static/image/f9d051a61fa04dbb99020ab345da3ce2.1d2df01e.webp",a=r.p+"static/image/bb05580d782fce50d3057bb3808b8320.5baa0e69.webp",l=r.p+"static/image/f0cfa5398f9cc56fa8a6a300e2348b22.9d002a3f.webp",d=r.p+"static/image/d608f4c6bb292d3c65b23b30b27b5a44.6e456f55.webp",o=r.p+"static/image/460f9aec3a4f1d7509ee87fcdc74ebae.62476205.webp",p=r.p+"static/image/db5900bd6235bfc7c0e00519dcf01e29.e98cdc6a.webp",h=r.p+"static/image/172c86f65f72d7f979add09803afa5e2.4c0bda61.webp",u=r.p+"static/image/b5d0c6e9d23302c633c4b5335c335552.65e82096.webp",j=r.p+"static/image/76d24d3d6803f229319851ff249e2323.b5a4bff4.webp",x=r.p+"static/image/b88fbe925283f8edb956076f3932806f.01c1e282.webp",m=r.p+"static/image/8fd478d3f131810e36997768eb34b155.289ffb93.webp",g=r.p+"static/image/2af26d0153ffbe6180d15ef51452d6e1.f1a8ec9f.webp",b=r.p+"static/image/80a4ecceef6425d377736bf35d5d8b7e.42f048f2.webp",f=r.p+"static/image/d982849da8bdb01110094f57a7c37530.ed22fa17.webp",A=r.p+"static/image/40afbc1c2b97f4aed62692b88e7e3da0.2bde8b01.webp",S=r.p+"static/image/2953120836aae48c5a60304451eb1f70.54ef0821.webp",y=r.p+"static/image/4cee35328fbee09d1f982b9d906800a0.e6a9e632.webp",R=r.p+"static/image/db8b982ab78db5d3d5b1a47ae39abeaf.7dbe1a86.webp",k=r.p+"static/image/fece884bc679f2a55b418389cb8a5ecf.29ac7a86.webp",v=r.p+"static/image/818f582316a5fc7a4f540fe6489e99fd.176da39d.webp",w=r.p+"static/image/98fcca188769dd7b4275f6f0710ed996.b4c35d72.webp",P=r.p+"static/image/c36c07e0636966a11d58c6be0410ae57.0e29280f.webp";function C(e){let n=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",h2:"h2",img:"img",code:"code",pre:"pre",strong:"strong",em:"em"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"30基于-prisma--nestjs-的-node-api-项目开发与基于-heroku-部署",children:["30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#30基于-prisma--nestjs-的-node-api-项目开发与基于-heroku-部署",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上一节我们已经完成了 NestJs 与 Prisma 的基础知识储备，也就是项目的开发阶段所需要的知识。而这一节，我们来了解部署阶段，我们将使用一个面向个人开发者基本免费的平台 Heroku 进行应用的最终部署，这主要是为了让没有服务器与数据库的同学（比如我）也能顺利地完成这一节的内容。"}),"\n",(0,s.jsx)(n.p,{children:"同时，上一节最开始安装的环境应该差不多了，那我们就来接着了解一下 Heroku 的打开方式。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["本节代码见：",(0,s.jsx)(n.a,{href:"https://github.com/linbudu599/tiny-book-blog-api",target:"_blank",rel:"noopener noreferrer",children:"Blog API"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"heroku-初体验",children:["Heroku 初体验",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#heroku-初体验",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前端社区有非常多的免费云服务，它们的作用各不相同，但基本上能找到所有你需要的。比如 Surge 提供了快捷的静态页面部署，Vercel 提供了与 git 服务集成支持的静态页面部署、页面指标统计以及免费的 Serverless 函数（Vercel Functions），Netlify 类似于 Vercel ，但 Serverless 函数是收费的。此外，一些知名框架也提供了自己的云服务（Gatsby Cloud、Nx Cloud 等）来进一步绑定用户。最重要的是，这些服务基本对个人开发者免费，只有需要进行团队协作或者高级功能时才会收费。"}),"\n",(0,s.jsx)(n.p,{children:"而 Heroku 就是一个提供免费服务的云平台，它主要以提供 API 服务部署为主，支持 Node、Java、Go、Python 等几乎所有主流语言。选择它的主要原因有两方面：一是我认为在类似的平台中它使用起来相对方便；二是它面向个人开发者提供了一定免费额度的数据库（PostgreSQL）。唯一存在遗憾的地方是，它需要科学上网才能正常访问。"}),"\n",(0,s.jsx)(n.p,{children:"好了，基本信息介绍完了，接下来我们正式开始体验吧！"}),"\n",(0,s.jsxs)(n.p,{children:["最开始当然是注册环节，访问 ",(0,s.jsx)(n.a,{href:"https://www.heroku.com/",target:"_blank",rel:"noopener noreferrer",children:"Heroku 主页"}),"，按照要求填写信息："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在登录时，如果提示需要 Multi-Factor Auth，可以选择先跳过。完成登录后，它会将你重定向到应用管理页面："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"点击右上角的新建，选择创建一个新应用，应用名需要是独一无二的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"创建成功后，我们会来到应用界面，以我们已经创建完毕的页面为例："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"点击 Deploy，我们需要把应用和 github 仓库关联起来，这样就能在每次提交时自动重新部署了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"首先选择 Connect to GitHub，授权完毕后选择你对应的仓库，配置完毕后你会看到这样的界面："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"点击 Enable Automatic Deploys 后，我们的应用就会随着每次 Git 提交而重新部署。"}),"\n",(0,s.jsx)(n.p,{children:"另外，我们此前的环境配置其实就是安装了 Heroku 的 CLI ，现在我们需要通过 CLI 在终端也登录上："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["这里我们不能直接运行 heroku login，因为你现在大概率是通过代理访问的，会出现 IP 地址不匹配的错误，我们需要使用 auth token 进行登录。来到 ",(0,s.jsx)(n.a,{href:"https://dashboard.heroku.com/account/applications",target:"_blank",rel:"noopener noreferrer",children:"全局设置"})," 页面，找到授权："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["点击创建一个新的 token，复制它，回到终端运行 ",(0,s.jsx)(n.code,{children:"heroku login -i"}),"，账号名输入你的邮箱，密码输入 token，确认登录："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"同时我们仍然可以将 Heroku 的仓库添加为一个单独的远程仓库，这么做的原因是我们可以先 push 到 Heroku 的远程仓库来进行构建与部署的测试，等测试验证完毕了再推送到 GitHub，运行："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"heroku git:remote -a <你的应用名>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["接下来我们需要申请一个可用的数据库，数据库、监控、负载均衡、Redis 等功能在 Heroku 上被称为 add-on ，你可以访问 ",(0,s.jsx)(n.a,{href:"https://elements.heroku.com/addons",target:"_blank",rel:"noopener noreferrer",children:"add-on 市场"})," 查看更多。在这里我们直奔 ",(0,s.jsx)(n.a,{href:"https://elements.heroku.com/addons/heroku-postgresql",target:"_blank",rel:"noopener noreferrer",children:"heroku-postgresql"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.imagehub.cc/image/GfiN6y",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)("img",{src:g,alt:"image380be9c6e463109c.png"})})}),"\n",(0,s.jsx)(n.p,{children:"点击安装，将安装到我们的应用中："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["数据库的链接会被以环境变量 ",(0,s.jsx)(n.code,{children:"process.env.DATABASE_URL "})," 注入进来，来到应用配置页面，点击显示环境变量："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:"imagee38ce6a381dc9b3b.png"})}),"\n",(0,s.jsx)(n.p,{children:"有了数据库地址，接下来我们就可以在本地应用里去连接到数据库了。"}),"\n",(0,s.jsxs)(n.h2,{id:"连接到-heroku-数据库",children:["连接到 Heroku 数据库",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#连接到-heroku-数据库",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先，在你本地的 ",(0,s.jsx)(n.code,{children:".env"})," 文件中修改 ",(0,s.jsx)(n.code,{children:"DATABASE_URL"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ini",children:'DATABASE_URL="postgres://..."\n'})}),"\n",(0,s.jsx)(n.p,{children:"执行命令："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"prisma db push\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这一命令会将我们此前定义的 Prisma Schema 推送到数据库，创建对应的数据表。同时这一命令也会再次执行 ",(0,s.jsx)(n.code,{children:"prisma generate"})," 命令来生成 Prisma Client："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:"imagedb88d65589f9bb99.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"通常来说，数据库也会按照环境分为日常、预发、生产、测试等多个版本，但谁让我们只是在写 demo 呢？"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"上一节我们已经介绍了如何在 NestJs 中使用 Prisma ，也完成了相关配置，现在我们可以真正连接到数据库试用一下了。"}),"\n",(0,s.jsxs)(n.p,{children:["创建 ",(0,s.jsx)(n.code,{children:"seed.controller.ts"})," 文件，在其中添加对 service 的实际调用："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Controller, Get } from '@nestjs/common';\nimport { ArticleService } from '../services/article.service';\n\n@Controller('/seed')\nexport class SeedController {\n  constructor(private readonly articleService: ArticleService) {}\n\n  @Get('/create')\n  async seed() {\n    await this.articleService.create({\n      title: 'Article 1',\n      content: 'Content 1',\n    });\n\n    await this.articleService.create({\n      title: 'Article 2',\n      content: 'Content 2',\n    });\n\n    await this.articleService.create({\n      title: 'Article 3',\n      content: 'Content 3',\n    });\n\n    return await this.articleService.query();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"别忘了把 SeedController 添加到 AppModule 中："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Module } from '@nestjs/common';\nimport PrismaModule from './data/prisma.module';\nimport { SeedController } from './controllers/seed.controller';\n\n@Module({\n  imports: [PrismaModule],\n  controllers: [SeedController],\n  providers: [ArticleService, CategoryService, TagService],\n})\nexport class AppModule {}\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["现在访问 ",(0,s.jsx)(n.a,{href:"http://localhost:3000/seed/create",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.a,{href:"http://localhost:3000/seed/create",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3000/seed/create"})})," ，会发现已经有响应了："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"imagee102f1b42e36a82b.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"初次部署",children:["初次部署",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初次部署",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"万事俱备，我们现在可以把应用部署到 Heroku 上了。但也别太急，我们的应用还需要进行一些额外的配置才能在 Heroku 上正常的工作。"}),"\n",(0,s.jsx)(n.p,{children:"首先是更改应用的端口号，Heroku 在部署这个应用时，会随机分配一个端口号，我们的应用需要使用这个端口号来启动，而这个端口号会通过环境变量的方式提供。"}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"src/main.ts"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async function bootstrap() {\n	// ...\n  const PORT = process.env.PORT ?? 3000;\n  await app.listen(PORT);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Heroku 在启动这个项目时，默认使用的是 ",(0,s.jsx)(n.code,{children:"npm start"})," 命令，而在我们的项目中这一命令其实是开发环境下的启动，",(0,s.jsx)(n.code,{children:"npm run start:prod"})," 才是基于构建后代码的启动。因此，我们需要告诉 Heroku 使用这一 script 启动，通常云平台们都支持了项目内的配置文件，如 ",(0,s.jsx)(n.code,{children:"vercel.json"}),"、",(0,s.jsx)(n.code,{children:"netlify.toml"})," ，而 Heroku 的配置文件则要特殊一些，它的名字叫 ",(0,s.jsx)(n.code,{children:"Procfile"}),"，注意，没有文件扩展名。"]}),"\n",(0,s.jsxs)(n.p,{children:["写入内容到 ",(0,s.jsx)(n.code,{children:"Procfile"})," 中："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ini",children:"web: npm run start:prod\n"})}),"\n",(0,s.jsxs)(n.p,{children:["还有最后一步，由于 Prisma 需要有一步 generate 命令，代码内才能访问到 Prisma Client，而在默认的构建过程中自然是不会有这一步的。因此，我们需要通过 ",(0,s.jsx)(n.code,{children:"postinstall"})," 这个会在安装过程后执行的 npm script ，在其中调用 generate："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n   "scripts": {\n    "postinstall": "npm run prisma:gen"\n  },\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["你也可以在 ",(0,s.jsx)(n.code,{children:"postbuild"})," 或别的步骤进行，只要确保在启动应用前执行了 prisma generate 即可。"]}),"\n",(0,s.jsx)(n.p,{children:"现在才是真正的万事具备，我们可以启动项目了。这一过程我们通常会用到两个命令。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git push heroku main\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果你已经连接到了 GitHub，其实直接推送 GitHub 仓库即可。但这一命令的主要作用是会展示 Heroku 接收到推送以后，拉取代码、安装依赖、构建以及启动过程："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"imagef0c3c4a1ded5150f.png"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"imagea22f61b473e93e2c.png"})}),"\n",(0,s.jsx)(n.p,{children:"你会发现，似乎缺少了应用程序启动的日志？这时候就需要使用另一个命令了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"heroku logs --tail\n"})}),"\n",(0,s.jsxs)(n.p,{children:["logs 命令用于展示这个应用运行过程中的日志，包括 Heroku 的系统日志与我们的应用程序日志。而 ",(0,s.jsx)(n.code,{children:"--tail"})," 参数意为仅展示最新的一部分日志："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image752c0cd8664a87c4.png"})}),"\n",(0,s.jsx)(n.p,{children:"这一命令会占据当前的端口，实时展示最新的日志，因此在开发阶段可以通过它来进行调试应用。"}),"\n",(0,s.jsx)(n.p,{children:"至此，我们的应用就已经部署完毕了，接下来基本上就不需要再在 Heroku 上进行什么配置了。最后需要注意的是，如果你的应用一段时间都没有任何流量，Heroku 会暂时停止掉这个服务，并在下一次有流量访问时再启动，这一过程一般耗时不会太久。而如果你在本地访问数据库出现了连接失败，原因也是因为其关联的应用被暂停，资源被暂时回收了。"}),"\n",(0,s.jsxs)(n.h2,{id:"api-开发",children:["API 开发",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#api-开发",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"终于到了 API 开发环节，但这一部分的内容反倒最简短。我们并不会把每一个实体（文章、标签、分类）的方法都实现完，因为如果你已经有过类似的开发经验，那这些内容对你来说意义不大，而如果你此前并无相关开发经验，更需要自己动手来试一试。"}),"\n",(0,s.jsx)(n.p,{children:"这里就以 Article 相关的操作为例，我们会实现全量查找、基于 ID 的查找、创建、更新这四个接口。在这个过程中，你会了解到 NestJs 最基本的使用，即路由处理与请求参数。"}),"\n",(0,s.jsx)(n.p,{children:"首先你需要确保已经完成了 Prisma Client 的生成与数据库同步，我们最终的 Prisma Schema 如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-text",children:'// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = "prisma-client-js"\n}\n\ndatasource db {\n  provider = "postgresql"\n  url      = env("DATABASE_URL")\n}\n\n// 文章的标签，如 TS / Node / React / SSR 等\nmodel Tag {\n  id          String    @id @default(cuid())\n  name        String\n  description String?\n  Article     Article[]\n}\n\n// 文章的分类，如 技术 / 感想 / 总结 等\nmodel Category {\n  id          String    @id @default(cuid())\n  name        String\n  description String?\n  Article     Article[]\n}\n\nmodel Article {\n  id          Int     @id @default(autoincrement())\n  title       String?\n  description String  @default("这篇文章还没有介绍...")\n  content     String\n\n  // 文章是否可见\n  visible Boolean @default(true)\n\n  tag      Tag[]\n  category Category[]\n\n  createdAt DateTime @default(now())\n  updatedAt DateTime @default(now())\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"首先是 Service 层，我们在这里会从数据库取回数据然后进行返回，但一般我们不会直接丢个数据回去，而是会附带上状态码等信息一起返回。这里我们实现一个简单的版本："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { MaybeNull } from '../types';\n\nexport enum StatusCode {\n  RESOLVED = 10000,\n  REJECTED = 10001,\n}\n\nexport class ResponseWrapper<TData = any> {\n  constructor(\n    public statusCode: StatusCode,\n    public data: TData,\n    public message?: string,\n  ) {\n    this.statusCode = statusCode;\n    this.data = data;\n    this.message =\n      message ?? statusCode === StatusCode.RESOLVED ? 'Success' : 'Failed';\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"从简起见，我们不想每次使用这个类时都标记状态。因为我们总共就两种状态，所以可以提前准备好成功与失败的响应修饰："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export class ResolvedResponse<TData = any> extends ResponseWrapper {\n  constructor(public data: TData, public message?: string) {\n    super(StatusCode.RESOLVED, data, message);\n  }\n}\n\nexport class RejectedResponse<TData = any> extends ResponseWrapper {\n  constructor(public data: TData, public message?: string) {\n    super(StatusCode.REJECTED, data, message);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"成功时使用 ResolvedResponse，数据为空或出现异常时使用 RejectedResponse，你也可以进行更进一步的拆分，如让参数校验失败、数据为空、鉴权失败等等都有专用的 RejectedResponse。"}),"\n",(0,s.jsx)(n.p,{children:"从创建开始，我们直接调用注入好的 Prisma Client 即可："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../data/prisma.service';\nimport {\n  ResolvedResponse,\n  RejectedResponse,\n  ResponseUnion,\n} from '../utils/response-wrapper.provider';\nimport { Article, ArticleCreateInput, ArticleUpdateInput } from '../types';\n\n@Injectable()\nexport class ArticleService {\n  constructor(private prisma: PrismaService) {}\n\n  async create(createInput: ArticleCreateInput){\n    try {\n      const res = await this.prisma.article.create({\n        data: createInput,\n        include: {\n          category: true,\n          tag: true,\n        },\n      });\n\n      return new ResolvedResponse(res);\n    } catch (error) {\n      return new RejectedResponse(null);\n    }\n  }\n}\n\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["这里的 include 配置意为我们希望",(0,s.jsx)(n.strong,{children:"在查询时连带返回所有文章的标签与分类信息"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们直接使用 Prisma 生成的 ArticleCreateInput 作为类型，但这里你会发现出现了一个类型报错：",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:'如果没有引用 "node_modules/.prisma/client"，则无法命名 "create" 的推断类型。这很可能不可移植。需要类型注释。'})})]}),"\n",(0,s.jsx)(n.p,{children:"这是因为我们消费的 ArticleCreateInput 类型来自于 Prisma Client，TS 无法直接使用这个类型为 create 方法完成类型推导，同时我们又多了 ResolvedResponse 这一层。"}),"\n",(0,s.jsx)(n.p,{children:"为了解决这一问题，我们声明一个通用的响应类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export type ResponseUnion<TData> = Promise<\n  ResolvedResponse<MaybeNull<TData>> | RejectedResponse<MaybeNull<TData>>\n>;\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后作为返回值类型使用："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class ArticleService {\n  constructor(private prisma: PrismaService) {}\n\n  async create(createInput: ArticleCreateInput): ResponseUnion<Article> {}\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"而在更新方法中，我们需要先基于 ID 检查这一条记录是否存在，且仅在存在时才进行更新："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class ArticleService {\n  constructor(private prisma: PrismaService) {}\n\n  async update(updateInput: ArticleUpdateInput): ResponseUnion<Article> {\n    const { id } = updateInput;\n    try {\n      const record = await this.prisma.article.findUnique({\n        where: { id },\n        include: {\n          category: true,\n          tag: true,\n        },\n      });\n\n      if (!record) {\n        return new RejectedResponse(null);\n      }\n\n      const res = await this.prisma.article.update({\n        where: { id },\n        data: updateInput,\n        include: {\n          category: true,\n          tag: true,\n        },\n      });\n\n      return new ResolvedResponse(res);\n    } catch (error) {\n      return new RejectedResponse(null);\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"如果你希望在更新记录不存在时创建一条记录，可以使用 prisma 的 upsert 方法。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"查询接口中，我们希望实现全量查询和基于 ID 查询两个版本："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Injectable()\nexport class ArticleService {\n  constructor(private prisma: PrismaService) {}\n\n  async queryRecords(\n    includeInvisible: boolean = false,\n  ): ResponseUnion<Article[]> {\n    try {\n      const res = await this.prisma.article.findMany({\n        where: includeInvisible\n          ? {}\n          : {\n              visible: true,\n            },\n        include: {\n          category: true,\n          tag: true,\n        },\n      });\n\n      return new ResolvedResponse(res);\n    } catch (error) {\n      return new RejectedResponse(null);\n    }\n  }\n\n  async querySingleRecord(id: number): ResponseUnion<Article> {\n    try {\n      const res = await this.prisma.article.findUnique({\n        where: { id },\n        include: {\n          category: true,\n          tag: true,\n        },\n      });\n      return new ResolvedResponse(res);\n    } catch (error) {\n      return new RejectedResponse(null);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在全量查询中，我们支持了通过 includeVisible 选项进行过滤，而在单条查询中则不会进行过滤。"}),"\n",(0,s.jsx)(n.p,{children:"完成了 Service 后，Controller 其实就简单多了，我们通常会在这里进行鉴权、校验参数、限流拦截等操作，但现在我们只需要简单地调用 Service 即可。"}),"\n",(0,s.jsx)(n.p,{children:"创建与更新比较类似，我们放在一起看："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export type MaybeArray<T> = T | T[];\n\n@Controller('/article')\nexport class ArticleController {\n  constructor(private readonly articleService: ArticleService) {}\n\n  @Post('/create')\n  async create(\n    @Body() createInput: ArticleCreateInput,\n  ): ResponseUnion<Article> {\n    return await this.articleService.create(createInput);\n  }\n\n  @Post('/update')\n  async update(\n    @Body() updateInput: ArticleUpdateInput,\n  ): ResponseUnion<Article> {\n    return await this.articleService.update(updateInput);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"@Post"})," 声明了此接口需要通过 POST 方法访问，而通过 ",(0,s.jsx)(n.code,{children:"@Body"})," 装饰器我们将请求携带的 Body 数据注入（",(0,s.jsx)(n.code,{children:"req.body"}),"），然后直接传给对应的 Service 即可。"]}),"\n",(0,s.jsxs)(n.p,{children:["对于查询接口，我们通常使用 GET 方法访问，以及使用 URL 来传参，如 ",(0,s.jsx)(n.code,{children:"/user/599"})," ",(0,s.jsx)(n.code,{children:"/user?id=599"})," 两种常见方式。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Controller('/article')\nexport class ArticleController {\n  constructor(private readonly articleService: ArticleService) {}\n\n  @Get('/')\n  async query(): ResponseUnion<Article[]> {\n    return await this.articleService.queryRecords();\n  }\n\n  @Get('/:id')\n  async queryById(\n    @Param('id', ParseIntPipe) id: number,\n  ): ResponseUnion<MaybeArray<Article>> {\n    return await this.articleService.querySingleRecord(id);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们通过 ",(0,s.jsx)(n.code,{children:"@Param"})," 注入 ",(0,s.jsx)(n.code,{children:"@Get('/:id')"})," 中的 id 参数，由于这一解构出来的值会是字符串，而我们的结构定义中 id 为数字，因此需要使用 ParseIntPipe 来将其转化为数字类型。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后，我们使用 ",(0,s.jsx)(n.a,{href:"https://www.apifox.cn/",target:"_blank",rel:"noopener noreferrer",children:"Apifox"})," 来进行接口的调试，你也可以使用任意习惯的工具："]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"POST /article/create"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"GET /article"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"GET /article?id=20"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"POST /article/update"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"完成了 Article 部分的开发仅仅只是开始，毕竟分类和标签也必不可少。但授人以鱼不如授人以渔，有了这一节的基础，再配合 NestJs 与 Prisma 事无巨细的官方文档，你完全可以独立完成剩下的部分。"}),"\n",(0,s.jsxs)(n.p,{children:["好了，完成了以上代码后，你可以直接运行 ",(0,s.jsx)(n.code,{children:"git push"}),"，Heroku 会自动使用最新的代码进行部署。"]}),"\n",(0,s.jsx)(n.p,{children:"除了业务逻辑开发以外，其实你也可以关注更多的功能部分，在 NestJs 中你可以找到校验、中间件、文件上传、日志、定时任务、缓存、限流等等功能，不妨试着把这些功能都加到这个 API 里！"}),"\n",(0,s.jsxs)(n.h2,{id:"总结与预告",children:["总结与预告",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结与预告",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过这两节的学习，我们从 0 开发并部署了一个 Node API 到 Heroku 平台上。如果你此前未接触过 Nest 和 Prisma ，那最大的收获其实是学习了目前功能最全面的 NodeJs 框架 Nest ，以及下一代 ORM 工具 Prisma 的基本使用。同时，我们也学习了如何使用 Heroku 作为云端应用平台，它其实非常适合个人小项目开发，毕竟它提供了包括 CI 集成、数据库、监控、热更新、负载均衡以及域名服务等等基础设施。"}),"\n",(0,s.jsx)(n.p,{children:"小册到这里已经接近了尾声，下一节也就是最后一节，我们会来了解 TypeScript 中的 Compiler API 使用，我们将换一个方式来“用” TypeScript，其他的就不剧透啦。"})]})}function N(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(C,{...e})}):C(e)}let E=N;N.__RSPRESS_PAGE_META={},N.__RSPRESS_PAGE_META["TypeScript%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F30.%E5%9F%BA%E4%BA%8E%20Prisma%20%2B%20NestJs%20%E7%9A%84%20Node%20API%20%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%8E%E5%9F%BA%E4%BA%8E%20Heroku%20%E9%83%A8%E7%BD%B2.md"]={toc:[{text:"Heroku 初体验",id:"heroku-初体验",depth:2},{text:"连接到 Heroku 数据库",id:"连接到-heroku-数据库",depth:2},{text:"初次部署",id:"初次部署",depth:2},{text:"API 开发",id:"api-开发",depth:2},{text:"总结与预告",id:"总结与预告",depth:2}],title:"30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署",headingTitle:"30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署",frontmatter:{}}}}]);