"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["33432"],{369448:function(e,n,i){i.r(n),i.d(n,{default:()=>t});var r=i(552676),s=i(740453);function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",strong:"strong"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"15原理-5同舟共济--事务",children:["15原理 5：同舟共济 —— 事务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15原理-5同舟共济--事务",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"为了确保连续多个操作的原子性，一个成熟的数据库通常都会有事务支持，Redis 也不例外。Redis 的事务使用非常简单，不同于关系数据库，我们无须理解那么多复杂的事务模型，就可以直接使用。不过也正是因为这种简单性，它的事务模型很不严格，这要求我们不能像使用关系数据库的事务一样来使用 Redis。"}),"\n",(0,r.jsxs)(n.h2,{id:"redis-事务的基本使用",children:["Redis 事务的基本使用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#redis-事务的基本使用",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"每个事务的操作都有 begin、commit 和 rollback，begin 指示事务的开始，commit 指示事务的提交，rollback 指示事务的回滚。它大致的形式如下。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"begin();\ntry {\n    command1();\n    command2();\n    ....\n    commit();\n} catch(Exception e) {\n    rollback();\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Redis 在形式上看起来也差不多，分别是 multi/exec/discard。multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> multi\nOK\n> incr books\nQUEUED\n> incr books\nQUEUED\n> exec\n(integer) 1\n(integer) 2\n"})}),"\n",(0,r.jsx)(n.p,{children:"上面的指令演示了一个完整的事务过程，所有的指令在 exec 之前不执行，而是缓存在服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕后一次性返回所有指令的运行结果。因为 Redis 的单线程特性，它不用担心自己在执行队列的时候被其它指令打搅，可以保证他们能得到的「原子性」执行。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/10/1648203d1d8ec347?w=810&h=386&f=png&s=26366",alt:""}),"\n上图显示了以上事务过程完整的交互效果。QUEUED 是一个简单字符串，同 OK 是一个形式，它表示指令已经被服务器缓存到队列里了。"]}),"\n",(0,r.jsxs)(n.h2,{id:"原子性",children:["原子性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原子性",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"事务的原子性是指要么事务全部成功，要么全部失败，那么 Redis 事务执行是原子性的么？"}),"\n",(0,r.jsx)(n.p,{children:"下面我们来看一个特别的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'> multi\nOK\n> set books iamastring\nQUEUED\n> incr books\nQUEUED\n> set poorman iamdesperate\nQUEUED\n> exec\n1) OK\n2) (error) ERR value is not an integer or out of range\n3) OK\n> get books\n"iamastring"\n>  get poorman\n"iamdesperate\n'})}),"\n",(0,r.jsx)(n.p,{children:"上面的例子是事务执行到中间遇到失败了，因为我们不能对一个字符串进行数学运算，事务在遇到指令执行失败后，后面的指令还继续执行，所以 poorman 的值能继续得到设置。"}),"\n",(0,r.jsx)(n.p,{children:"到这里，你应该明白 Redis 的事务根本不能算「原子性」，而仅仅是满足了事务的「隔离性」，隔离性中的串行化——当前执行的事务有着不被其它事务打断的权利。"}),"\n",(0,r.jsxs)(n.h2,{id:"discard丢弃",children:["discard(丢弃)",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#discard丢弃",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Redis 为事务提供了一个 discard 指令，用于丢弃事务缓存队列中的所有指令，在 exec 执行之前。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> get books\n(nil)\n> multi\nOK\n> incr books\nQUEUED\n> incr books\nQUEUED\n> discard\nOK\n> get books\n(nil)\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们可以看到 discard 之后，队列中的所有指令都没执行，就好像 multi 和 discard 中间的所有指令从未发生过一样。"}),"\n",(0,r.jsxs)(n.h2,{id:"优化",children:["优化",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面的 Redis 事务在发送每个指令到事务缓存队列时都要经过一次网络读写，当一个事务内部的指令较多时，需要的网络 IO 时间也会线性增长。所以通常 Redis 的客户端在执行事务时都会结合 pipeline 一起使用，这样可以将多次 IO 操作压缩为单次 IO 操作。比如我们在使用 Python 的 Redis 客户端时执行事务时是要强制使用 pipeline 的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'pipe = redis.pipeline(transaction=true)\npipe.multi()\npipe.incr("books")\npipe.incr("books")\nvalues = pipe.execute()\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"watch",children:["Watch",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#watch",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"考虑到一个业务场景，Redis 存储了我们的账户余额数据，它是一个整数。现在有两个并发的客户端要对账户余额进行修改操作，这个修改不是一个简单的 incrby 指令，而是要对余额乘以一个倍数。Redis 可没有提供 multiplyby 这样的指令。我们需要先取出余额然后在内存里乘以倍数，再将结果写回 Redis。"}),"\n",(0,r.jsxs)(n.p,{children:["这就会出现并发问题，因为有多个客户端会并发进行操作。我们可以通过 Redis 的分布式锁来避免冲突，这是一个很好的解决方案。",(0,r.jsx)(n.strong,{children:"分布式锁是一种悲观锁，那是不是可以使用乐观锁的方式来解决冲突呢？"})]}),"\n",(0,r.jsx)(n.p,{children:"Redis 提供了这种 watch 的机制，它就是一种乐观锁。有了 watch 我们又多了一种可以用来解决并发修改的方法。\nwatch 的使用方式如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"while True:\n    do_watch()\n    commands()\n    multi()\n    send_commands()\n    try:\n        exec()\n        break\n    except WatchError:\n        continue\n"})}),"\n",(0,r.jsx)(n.p,{children:"watch 会在事务开始之前盯住 1 个或多个关键变量，当事务执行时，也就是服务器收到了 exec 指令要顺序执行缓存的事务队列时，Redis 会检查关键变量自 watch 之后，是否被修改了 (包括当前事务所在的客户端)。如果关键变量被人动过了，exec 指令就会返回 null 回复告知客户端事务执行失败，这个时候客户端一般会选择重试。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> watch books\nOK\n> incr books  # 被修改了\n(integer) 1\n> multi\nOK\n> incr books\nQUEUED\n> exec  # 事务执行失败\n(nil)\n"})}),"\n",(0,r.jsx)(n.p,{children:"当服务器给 exec 指令返回一个 null 回复时，客户端知道了事务执行是失败的，通常客户端 (redis-py) 都会抛出一个 WatchError 这种错误，不过也有些语言 (jedis) 不会抛出异常，而是通过在 exec 方法里返回一个 null，这样客户端需要检查一下返回结果是否为 null 来确定事务是否执行失败。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"注意事项"})}),"\n",(0,r.jsx)(n.p,{children:"Redis 禁止在 multi 和 exec 之间执行 watch 指令，而必须在 multi 之前做好盯住关键变量，否则会出错。"}),"\n",(0,r.jsx)(n.p,{children:"接下来我们使用 Python 语言来实现对余额的加倍操作。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'# -*- coding: utf-8\nimport redis\n\ndef key_for(user_id):\n    return "account_{}".format(user_id)\n\ndef double_account(client, user_id):\n    key = key_for(user_id)\n    while True:\n        client.watch(key)\n        value = int(client.get(key))\n        value *= 2  # 加倍\n        pipe = client.pipeline(transaction=True)\n        pipe.multi()\n        pipe.set(key, value)\n        try:\n            pipe.execute()\n            break  # 总算成功了\n        except redis.WatchError:\n            continue  # 事务被打断了，重试\n    return int(client.get(key))  # 重新获取余额\n\nclient = redis.StrictRedis()\nuser_id = "abc"\nclient.setnx(key_for(user_id), 5)  # setnx 做初始化\nprint double_account(client, user_id)\n'})}),"\n",(0,r.jsx)(n.p,{children:"下面我们再使用 Java 语言实现一遍。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'import java.util.List;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.Transaction;\n\npublic class TransactionDemo {\n\n  public static void main(String[] args) {\n    Jedis jedis = new Jedis();\n    String userId = "abc";\n    String key = keyFor(userId);\n    jedis.setnx(key, String.valueOf(5));  # setnx 做初始化\n    System.out.println(doubleAccount(jedis, userId));\n    jedis.close();\n  }\n\n  public static int doubleAccount(Jedis jedis, String userId) {\n    String key = keyFor(userId);\n    while (true) {\n      jedis.watch(key);\n      int value = Integer.parseInt(jedis.get(key));\n      value *= 2; // 加倍\n      Transaction tx = jedis.multi();\n      tx.set(key, String.valueOf(value));\n      List<Object> res = tx.exec();\n      if (res != null) {\n        break; // 成功了\n      }\n    }\n    return Integer.parseInt(jedis.get(key)); // 重新获取余额\n  }\n\n  public static String keyFor(String userId) {\n    return String.format("account_%s", userId);\n  }\n\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"我们常常听说 Python 的代码要比 Java 简短太多，但是从这个例子中我们看到 Java 的代码比 python 的代码也多不了多少，大约只多出 50%。"}),"\n",(0,r.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"为什么 Redis 的事务不能支持回滚？"})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}let t=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F15%E5%8E%9F%E7%90%86%205%EF%BC%9A%E5%90%8C%E8%88%9F%E5%85%B1%E6%B5%8E%20%E2%80%94%E2%80%94%20%E4%BA%8B%E5%8A%A1.md"]={toc:[{text:"Redis 事务的基本使用",id:"redis-事务的基本使用",depth:2},{text:"原子性",id:"原子性",depth:2},{text:"discard(丢弃)",id:"discard丢弃",depth:2},{text:"优化",id:"优化",depth:2},{text:"Watch",id:"watch",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"15原理 5：同舟共济 —— 事务",headingTitle:"15原理 5：同舟共济 —— 事务",frontmatter:{}}}}]);