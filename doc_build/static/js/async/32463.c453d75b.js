"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["32463"],{65580:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var s=r(552676),l=r(740453);function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",strong:"strong",h2:"h2",pre:"pre",ol:"ol"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"19实现小型打包工具",children:["19.实现小型打包工具",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#19实现小型打包工具",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"原本小册计划中是没有这一章节的，Webpack 工作原理应该是上一章节包含的内容。但是考虑到既然讲到工作原理，必然需要讲解源码，但是 Webpack 的源码很难读，不结合源码干巴巴讲原理又没有什么价值。所以在这一章节中，我将会带大家来实现一个几十行的迷你打包工具，该工具可以实现以下两个功能"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"将 ES6 转换为 ES5"}),"\n",(0,s.jsxs)(n.li,{children:["支持在 JS 文件中 ",(0,s.jsx)(n.code,{children:"import"})," CSS 文件"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["通过这个工具的实现，大家可以理解到打包工具的",(0,s.jsx)(n.strong,{children:"原理"}),"到底是什么。"]}),"\n",(0,s.jsxs)(n.h2,{id:"实现",children:["实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"因为涉及到 ES6 转 ES5，所以我们首先需要安装一些 Babel 相关的工具"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"yarn add babylon babel-traverse babel-core babel-preset-env  \n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来我们将这些工具引入文件中"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const fs = require('fs')\nconst path = require('path')\nconst babylon = require('babylon')\nconst traverse = require('babel-traverse').default\nconst { transformFromAst } = require('babel-core')\n"})}),"\n",(0,s.jsx)(n.p,{children:"首先，我们先来实现如何使用 Babel 转换代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function readCode(filePath) {\n  // 读取文件内容\n  const content = fs.readFileSync(filePath, 'utf-8')\n  // 生成 AST\n  const ast = babylon.parse(content, {\n    sourceType: 'module'\n  })\n  // 寻找当前文件的依赖关系\n  const dependencies = []\n  traverse(ast, {\n    ImportDeclaration: ({ node }) => {\n      dependencies.push(node.source.value)\n    }\n  })\n  // 通过 AST 将代码转为 ES5\n  const { code } = transformFromAst(ast, null, {\n    presets: ['env']\n  })\n  return {\n    filePath,\n    dependencies,\n    code\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["首先我们传入一个文件路径参数，然后通过 ",(0,s.jsx)(n.code,{children:"fs"})," 将文件中的内容读取出来"]}),"\n",(0,s.jsxs)(n.li,{children:["接下来我们通过 ",(0,s.jsx)(n.code,{children:"babylon"})," 解析代码获取 AST，目的是为了分析代码中是否还引入了别的文件"]}),"\n",(0,s.jsxs)(n.li,{children:["通过 ",(0,s.jsx)(n.code,{children:"dependencies"})," 来存储文件中的依赖，然后再将 AST 转换为 ES5 代码"]}),"\n",(0,s.jsx)(n.li,{children:"最后函数返回了一个对象，对象中包含了当前文件路径、当前文件依赖和当前文件转换后的代码"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们需要实现一个函数，这个函数的功能有以下几点"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"readCode"})," 函数，传入入口文件"]}),"\n",(0,s.jsx)(n.li,{children:"分析入口文件的依赖"}),"\n",(0,s.jsx)(n.li,{children:"识别 JS 和 CSS 文件"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function getDependencies(entry) {\n  // 读取入口文件\n  const entryObject = readCode(entry)\n  const dependencies = [entryObject]\n  // 遍历所有文件依赖关系\n  for (const asset of dependencies) {\n    // 获得文件目录\n    const dirname = path.dirname(asset.filePath)\n    // 遍历当前文件依赖关系\n    asset.dependencies.forEach(relativePath => {\n      // 获得绝对路径\n      const absolutePath = path.join(dirname, relativePath)\n      // CSS 文件逻辑就是将代码插入到 `style` 标签中\n      if (/\\.css$/.test(absolutePath)) {\n        const content = fs.readFileSync(absolutePath, 'utf-8')\n        const code = `\n          const style = document.createElement('style')\n          style.innerText = ${JSON.stringify(content).replace(/\\\\r\\\\n/g, '')}\n          document.head.appendChild(style)\n        `\n        dependencies.push({\n          filePath: absolutePath,\n          relativePath,\n          dependencies: [],\n          code\n        })\n      } else {\n        // JS 代码需要继续查找是否有依赖关系\n        const child = readCode(absolutePath)\n        child.relativePath = relativePath\n        dependencies.push(child)\n      }\n    })\n  }\n  return dependencies\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"首先我们读取入口文件，然后创建一个数组，该数组的目的是存储代码中涉及到的所有文件"}),"\n",(0,s.jsxs)(n.li,{children:["接下来我们遍历这个数组，一开始这个数组中只有入口文件，在遍历的过程中，如果入口文件有依赖其他的文件，那么就会被 ",(0,s.jsx)(n.code,{children:"push"})," 到这个数组中"]}),"\n",(0,s.jsx)(n.li,{children:"在遍历的过程中，我们先获得该文件对应的目录，然后遍历当前文件的依赖关系"}),"\n",(0,s.jsxs)(n.li,{children:["在遍历当前文件依赖关系的过程中，首先生成依赖文件的绝对路径，然后判断当前文件是 CSS 文件还是 JS 文件","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["如果是 CSS 文件的话，我们就不能用 Babel 去编译了，只需要读取 CSS 文件中的代码，然后创建一个 ",(0,s.jsx)(n.code,{children:"style"})," 标签，将代码插入进标签并且放入 ",(0,s.jsx)(n.code,{children:"head"})," 中即可"]}),"\n",(0,s.jsx)(n.li,{children:"如果是 JS 文件的话，我们还需要分析 JS 文件是否还有别的依赖关系"}),"\n",(0,s.jsxs)(n.li,{children:["最后将读取文件后的对象 ",(0,s.jsx)(n.code,{children:"push"})," 进数组中"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"现在我们已经获取到了所有的依赖文件，接下来就是实现打包的功能了"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function bundle(dependencies, entry) {\n  let modules = ''\n  // 构建函数参数，生成的结构为\n  // { './entry.js': function(module, exports, require) { 代码 } }\n  dependencies.forEach(dep => {\n    const filePath = dep.relativePath || entry\n    modules += `'${filePath}': (\n      function (module, exports, require) { ${dep.code} }\n    ),`\n  })\n  // 构建 require 函数，目的是为了获取模块暴露出来的内容\n  const result = `\n    (function(modules) {\n      function require(id) {\n        const module = { exports : {} }\n        modules[id](module, module.exports, require)\n        return module.exports\n      }\n      require('${entry}')\n    })({${modules}})\n  `\n  // 当生成的内容写入到文件中\n  fs.writeFileSync('./bundle.js', result)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这段代码需要结合着 Babel 转换后的代码来看，这样大家就能理解为什么需要这样写了"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// entry.js\nvar _a = require('./a.js')\nvar _a2 = _interopRequireDefault(_a)\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj }\n}\nconsole.log(_a2.default)\n// a.js\nObject.defineProperty(exports, '__esModule', {\n    value: true\n})\nvar a = 1\nexports.default = a\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Babel 将我们 ES6 的模块化代码转换为了 CommonJS（如果你不熟悉 CommonJS 的话，可以阅读这一章节中关于 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6844733763675488269/section/6844733763759374344",target:"_blank",rel:"noopener noreferrer",children:"模块化的知识点"}),"） 的代码，但是浏览器是不支持 CommonJS 的，所以如果这段代码需要在浏览器环境下运行的话，我们需要自己实现 CommonJS 相关的代码，这就是 ",(0,s.jsx)(n.code,{children:"bundle"})," 函数做的大部分事情。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来我们再来逐行解析 ",(0,s.jsx)(n.code,{children:"bundle"})," 函数"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"首先遍历所有依赖文件，构建出一个函数参数对象"}),"\n",(0,s.jsxs)(n.li,{children:["对象的属性就是当前文件的相对路径，属性值是一个函数，函数体是当前文件下的代码，函数接受三个参数 ",(0,s.jsx)(n.code,{children:"module"}),"、",(0,s.jsx)(n.code,{children:"exports"}),"、 ",(0,s.jsx)(n.code,{children:"require"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"module"})," 参数对应 CommonJS 中的 ",(0,s.jsx)(n.code,{children:"module"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exports"})," 参数对应 CommonJS 中的 ",(0,s.jsx)(n.code,{children:"module.export"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"require"})," 参数对应我们自己创建的 ",(0,s.jsx)(n.code,{children:"require"})," 函数"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["接下来就是构造一个使用参数的函数了，函数做的事情很简单，就是内部创建一个 ",(0,s.jsx)(n.code,{children:"require"})," 函数，然后调用 ",(0,s.jsx)(n.code,{children:"require(entry)"}),"，也就是 ",(0,s.jsx)(n.code,{children:"require('./entry.js')"}),"，这样就会从函数参数中找到 ",(0,s.jsx)(n.code,{children:"./entry.js"})," 对应的函数并执行，最后将导出的内容通过 ",(0,s.jsx)(n.code,{children:"module.export"})," 的方式让外部获取到"]}),"\n",(0,s.jsx)(n.li,{children:"最后再将打包出来的内容写入到单独的文件中"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"如果你对于上面的实现还有疑惑的话，可以阅读下打包后的部分简化代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:";(function(modules) {\n  function require(id) {\n    // 构造一个 CommonJS 导出代码\n    const module = { exports: {} }\n    // 去参数中获取文件对应的函数并执行\n    modules[id](module, module.exports, require)\n    return module.exports\n  }\n  require('./entry.js')\n})({\n  './entry.js': function(module, exports, require) {\n    // 这里继续通过构造的 require 去找到 a.js 文件对应的函数\n    var _a = require('./a.js')\n    console.log(_a2.default)\n  },\n  './a.js': function(module, exports, require) {\n    var a = 1\n    // 将 require 函数中的变量 module 变成了这样的结构\n    // module.exports = 1\n    // 这样就能在外部取到导出的内容了\n    exports.default = a\n  }\n  // 省略\n})\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"虽然实现这个工具只写了不到 100 行的代码，但是打包工具的核心原理就是这些了"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"找出入口文件所有的依赖关系"}),"\n",(0,s.jsxs)(n.li,{children:["然后通过构建 CommonJS 代码来获取 ",(0,s.jsx)(n.code,{children:"exports"})," 导出的内容"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let c=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F19.%E5%AE%9E%E7%8E%B0%E5%B0%8F%E5%9E%8B%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7.md"]={toc:[{text:"实现",id:"实现",depth:2},{text:"小结",id:"小结",depth:2}],title:"19.实现小型打包工具",headingTitle:"19.实现小型打包工具",frontmatter:{}}}}]);