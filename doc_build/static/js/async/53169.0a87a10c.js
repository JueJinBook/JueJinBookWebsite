"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["53169"],{102669:function(e,n,r){e.exports=r.p+"static/image/09c5c6469a29e60e78a57285e0f87be7.92f17f32.webp"},631750:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var t=r(552676),s=r(740453),d=r(102669);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",img:"img",h3:"h3",pre:"pre",blockquote:"blockquote",h4:"h4",ol:"ol",li:"li",ul:"ul"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"22-nodejs-与-winter-的融合亖events-与-eventtarget",children:["22-Node.js 与 Winter 的融合（亖）：events 与 EventTarget",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-nodejs-与-winter-的融合亖events-与-eventtarget",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"JavaScript 是事件驱动的。不过在 ECMAScript 上并没有很好地体现出来，因为事件循环中的“事件”通常需要结合运行时才能发挥价值。比如浏览器中的各种 DOM 事件，或者 Node.js 中的各种 I/O 事件。"}),"\n",(0,t.jsx)(n.p,{children:"浏览器中的事件接口与 Node.js 中的事件接口是不一样的。"}),"\n",(0,t.jsxs)(n.h2,{id:"events-模块",children:[(0,t.jsx)(n.code,{children:"events"})," 模块",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#events-模块",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["Node.js 的 ",(0,t.jsx)(n.code,{children:"events"})," 模块在 v0.1 的版本中就存在了，毕竟很多 API 离了它就不行。我们来看看有哪些直接面向开发者的类是继承自 ",(0,t.jsx)(n.code,{children:"events.EventEmitter"})," 的，这里给出部分继承关系。大家凡是在 Node.js 文档中看到某个类的大纲中有 ",(0,t.jsx)(n.code,{children:"Event:"})," 字样，那么它就是一个 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 的子类。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"23流程图.png"})}),"\n",(0,t.jsx)(n.p,{children:"这里我们介绍一个事件对象的构造、新增与触发。篇幅问题就不介绍删除（或者说卸载）了。"}),"\n",(0,t.jsxs)(n.h3,{id:"构造函数",children:["构造函数",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#构造函数",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 中，最重要的就是 ",(0,t.jsx)(n.code,{children:"_events"})," 对象了。它是一个二维 JSON，用 TypeScript 表示，",(0,t.jsx)(n.code,{children:"_events"})," 的类型为 ",(0,t.jsx)(n.code,{children:"Record<string | symbol, (...args: any[]) => void | ((...args: any[]) => void)[]>"}),"。键名是个字符串或 ",(0,t.jsx)(n.code,{children:"Symbol"}),"，键值是个函数或函数数组。这个 JSON 对象在 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 构造函数的时候被初始化，而且为了该键值对中的各种 ",(0,t.jsx)(n.code,{children:"key"})," 不与原生对象的 ",(0,t.jsx)(n.code,{children:"key"})," 冲突，特意将 ",(0,t.jsx)(n.code,{children:"__proto__"})," 设为了 ",(0,t.jsx)(n.code,{children:"null"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"function EventEmitter(opts) {\n  EventEmitter.init.call(this, opts);\n}\n\nEventEmitter.init = function(opts) {\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = { __proto__: null };\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections, 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["首先是将 ",(0,t.jsx)(n.code,{children:"_events"})," 设置为 ",(0,t.jsx)(n.code,{children:"{ __proto__: null }"}),"，然后将计数设为 ",(0,t.jsx)(n.code,{children:"0"}),"。然后是 ",(0,t.jsx)(n.code,{children:"_maxListeners"}),"。Node.js 中的 ",(0,t.jsx)(n.code,{children:"_maxListeners"})," 并不会做硬限制卡点，而是在监听数超过后，打印一行“可能泄露”的警告。"]}),"\n",(0,t.jsxs)(n.p,{children:["然后是设置是否要捕获 ",(0,t.jsx)(n.code,{children:"Promise"})," 中的 ",(0,t.jsx)(n.code,{children:"rejection"}),"。默认为 ",(0,t.jsx)(n.code,{children:"false"}),"。下面两个 ",(0,t.jsx)(n.code,{children:"if"})," 的意思是，如果 ",(0,t.jsx)(n.code,{children:"opts"})," 中设置了 ",(0,t.jsx)(n.code,{children:"captureRejections"}),"，那么直接将其 ",(0,t.jsx)(n.code,{children:"this[kCapture]"})," 设为传进来的值；如果 ",(0,t.jsx)(n.code,{children:"opts"})," 中未设置，那么将 ",(0,t.jsx)(n.code,{children:"EventEmitter.prototype"})," 这原型链中的 ",(0,t.jsx)(n.code,{children:"[kCapture]"})," 给赋值到 ",(0,t.jsx)(n.code,{children:"this"})," 上。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里有点奇怪，从原型链上赋不赋值过来，效果都一样啊，为什么要“多此一举”？主要因为后续去访问这个 ",(0,t.jsx)(n.code,{children:"[kCapture]"})," 会比较频繁，在访问的时候可以减少一次原型链寻址的长度也是某种意义上的“性能优化”。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里还有一个比较奇怪的点是，为什么这个初始化不直接在 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 构造函数里面做，而是要放在 ",(0,t.jsx)(n.code,{children:"EventEmitter.init()"})," 里呢？这是因为，有些模块在加载的时候要对 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 构造函数做一个全局的 Hack。如果所有逻辑都放在 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 构造函数本体，那么就无从 Hack；而如果把初始化逻辑放到 ",(0,t.jsx)(n.code,{children:"EventEmitter.init()"})," 中，那么另外的模块只需要去 Hack 这个 ",(0,t.jsx)(n.code,{children:"EventEmitter.init()"})," 函数，就能做到把之后所有的 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 构造函数都进行改动。——",(0,t.jsx)(n.code,{children:"domain"})," 模块就是",(0,t.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.16.0/lib/domain.js#L458-L475",title:"https://github.com/nodejs/node/blob/v18.16.0/lib/domain.js#L458-L475",target:"_blank",rel:"noopener noreferrer",children:"这么做的"}),"。"]}),"\n",(0,t.jsxs)(n.h3,{id:"新增监听",children:["新增监听",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#新增监听",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["新增监听有好几个名字。",(0,t.jsx)(n.code,{children:"on"}),"、",(0,t.jsx)(n.code,{children:"once"}),"、",(0,t.jsx)(n.code,{children:"addListener"}),"、",(0,t.jsx)(n.code,{children:"prependListener"})," 等。其中 ",(0,t.jsx)(n.code,{children:"once"})," 是只监听一次，一旦触发就卸载监听。",(0,t.jsx)(n.code,{children:"addListener"})," 的核心代码是这样的："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"function _addListener(target, type, listener, prepend) {\n  let m;\n  let events;\n  let existing;\n  ...\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = { __proto__: null };\n    target._eventsCount = 0;\n  } else {\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ?? listener);\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      const w = genericNodeError(\n        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners ` +\n        `added to ${inspect(target, { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`,\n        { name: 'MaxListenersExceededWarning', emitter: target, type: type, count: existing.length });\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["有四个参数，",(0,t.jsx)(n.code,{children:"EventEmitter"})," 本体、监听名、监听函数，以及是 ",(0,t.jsx)(n.code,{children:"prepend"})," 还是 ",(0,t.jsx)(n.code,{children:"append"}),"——这影响到调用顺序。"]}),"\n",(0,t.jsxs)(n.p,{children:["由于整个 ",(0,t.jsx)(n.code,{children:"_events"})," 只是在变量名上加了个下划线，并不是真正的私有变量。外部开发者是可以篡改该对象的，自然也可以删除。纵然我们在构造函数里面初始化了这个 ",(0,t.jsx)(n.code,{children:"_events"}),"，但我们仍要在第一个 ",(0,t.jsx)(n.code,{children:"if"})," 中，先判断它是否 ",(0,t.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["然后是判断一下有没有监听 ",(0,t.jsx)(n.code,{children:"newListener"})," 事件。该事件会在一个 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 实例被新增任意一个事件时被调用，告知其监听函数现在多了某个监听。接着判断一下该事件之前有没有被监听过（",(0,t.jsx)(n.code,{children:"_events"})," 对应字段上有没有挂东西）。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["这个 ",(0,t.jsx)(n.code,{children:"newListener"})," 我们在",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7196627546253819916/section/7197302070905405451",title:"https://juejin.cn/book/7196627546253819916/section/7197302070905405451",target:"_blank",rel:"noopener noreferrer",children:"第十四章"}),"中提到过，Node.js 中的 ",(0,t.jsx)(n.code,{children:"process"})," 对于各种 signal 的监听就是通过 ",(0,t.jsx)(n.code,{children:"newListener"})," 这个事件来做到的。具体可以返回地十四章复习一下。"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["如果 ",(0,t.jsx)(n.code,{children:"_events"})," 对应字段上没有挂任何内容，则直接将 ",(0,t.jsx)(n.code,{children:"_events[type]"})," 赋值为监听函数，对 ",(0,t.jsx)(n.code,{children:"_eventsCount"})," 进行累加操作；若 ",(0,t.jsx)(n.code,{children:"_events"})," 字段上挂了内容，则判断其类型。若类型是个函数，那么将该函数与传进来的函数一起组成一个数组，其顺序视第四个参数 ",(0,t.jsx)(n.code,{children:"prepend"})," 或者 ",(0,t.jsx)(n.code,{children:"append"})," 而定；若类型已然是个数组，则视第四个参数而定是要对数组进行 ",(0,t.jsx)(n.code,{children:"unshift()"})," 还是 ",(0,t.jsx)(n.code,{children:"push()"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["最后，判断一下当前监听的类型数 ",(0,t.jsx)(n.code,{children:"_eventsCount"})," 是否超过最大值，若是则打印泄露警告。"]}),"\n",(0,t.jsxs)(n.h4,{id:"on-与-addlistener",children:[(0,t.jsx)(n.code,{children:"on"})," 与 ",(0,t.jsx)(n.code,{children:"addListener"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#on-与-addlistener",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这俩没什么说的，就是简单地调用。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"    EventEmitter.prototype.addListener = function addListener(type, listener) {\n      return _addListener(this, type, listener, false);\n    };\n\n    EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n"})}),"\n",(0,t.jsxs)(n.h4,{id:"once",children:[(0,t.jsx)(n.code,{children:"once"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#once",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["这个函数比 ",(0,t.jsx)(n.code,{children:"on"})," 多了点东西。它传进去的 ",(0,t.jsx)(n.code,{children:"listener"})," 是经过包装的。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"    function onceWrapper() {\n      if (!this.fired) {\n        this.target.removeListener(this.type, this.wrapFn);\n        this.fired = true;\n        if (arguments.length === 0)\n          return this.listener.call(this.target);\n        return this.listener.apply(this.target, arguments);\n      }\n    }\n\n    function _onceWrap(target, type, listener) {\n      const state = { fired: false, wrapFn: undefined, target, type, listener };\n      const wrapped = onceWrapper.bind(state);\n      wrapped.listener = listener;\n      state.wrapFn = wrapped;\n      return wrapped;\n    }\n\n    EventEmitter.prototype.once = function once(type, listener) {\n      checkListener(listener);\n\n      this.on(type, _onceWrap(this, type, listener));\n      return this;\n    };\n"})}),"\n",(0,t.jsxs)(n.p,{children:["它把 ",(0,t.jsx)(n.code,{children:"listener"})," 包装成了一个 ",(0,t.jsx)(n.code,{children:"onceWrapper"})," 函数，并与元数据进行 ",(0,t.jsx)(n.code,{children:"this"})," 绑定。一旦事件触发，响应的是这个 ",(0,t.jsx)(n.code,{children:"onceWrapper"})," 函数，该函数会去 ",(0,t.jsx)(n.code,{children:"this"})," 中 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 中移除事件监听本身，然后调用原传进来的 ",(0,t.jsx)(n.code,{children:"listener"}),"。"]}),"\n",(0,t.jsxs)(n.h3,{id:"事件触发",children:["事件触发",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#事件触发",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["事件是由触发方调用 ",(0,t.jsx)(n.code,{children:"EventEmitter.prototype.emit()"})," 来进行的。比如 ",(0,t.jsx)(n.code,{children:"net"})," 中的 ",(0,t.jsx)(n.code,{children:"Server"}),"，就是给 C++ 侧传入一个 ",(0,t.jsx)(n.code,{children:"onconnection"})," 函数，C++ 在建立连接后会调用这个函数，而这个 ",(0,t.jsx)(n.code,{children:"onconnection"})," 函数中有一行就是调用 ",(0,t.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.16.0/lib/net.js#L2025",title:"https://github.com/nodejs/node/blob/v18.16.0/lib/net.js#L2025",target:"_blank",rel:"noopener noreferrer",children:"self.emit('connection')"})," 来触发事件的。"]}),"\n",(0,t.jsx)(n.p,{children:"事件触发具体做了哪些事呢？如果简单来讲，就是两步："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["通过 ",(0,t.jsx)(n.code,{children:"type"})," 拿到 ",(0,t.jsx)(n.code,{children:"_events"})," 中的相关键值，若不存在则直接忽略；"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"根据键值类型不同，做不同反应："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"若是函数，则直接调用；"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"若是数组，则逐个调用里面的函数。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["说起来简单，但是边边角角还是挺多内容的。比如，",(0,t.jsx)(n.code,{children:"error"})," 是个特殊事件，如果有人触发了 ",(0,t.jsx)(n.code,{children:"error"})," 事件，但没有监听函数，则会抛出异常。下面就是 ",(0,t.jsx)(n.code,{children:"emit"})," 触发事件的",(0,t.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.16.0/lib/events.js#L453-L539",title:"https://github.com/nodejs/node/blob/v18.16.0/lib/events.js#L453-L539",target:"_blank",rel:"noopener noreferrer",children:"代码"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["先是判断是不是 ",(0,t.jsx)(n.code,{children:"error"})," 事件，并标记一下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"    EventEmitter.prototype.emit = function emit(type, ...args) {\n      let doError = (type === 'error');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后看看 ",(0,t.jsx)(n.code,{children:"_events"})," 是不是个 ",(0,t.jsx)(n.code,{children:"undefined"}),"。如果是 ",(0,t.jsx)(n.code,{children:"undefined"}),"，则说明肯定没有监听 ",(0,t.jsx)(n.code,{children:"error"})," 事件，这个时候就看有没有监听 ",(0,t.jsx)(n.code,{children:"kErrorMonitor"})," 事件。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里的 ",(0,t.jsx)(n.code,{children:"kErrorMonitor"})," 就是 ",(0,t.jsx)(n.code,{children:"events.errorMonitor"}),"。一个用于标识“监控错误事件”的 Symbol。因为如果我们直接监听了 ",(0,t.jsx)(n.code,{children:"error"})," 事件，那么通常情况下触发错误时程序不会抛出异常。如果有一些“日志监控”等逻辑想要去“记录错误”，但不想阻止它抛出异常，就无法通过监听 ",(0,t.jsx)(n.code,{children:"error"})," 事件做到了。"]}),"\n",(0,t.jsxs)(n.p,{children:["这个需求最初来自 OpenTelemetry 的 JavaScript SDK（",(0,t.jsx)(n.a,{href:"https://github.com/open-telemetry/opentelemetry-js/issues/225",title:"https://github.com/open-telemetry/opentelemetry-js/issues/225",target:"_blank",rel:"noopener noreferrer",children:"Issue 225"}),"）。它想以“旁观者”的身份去记录错误，但不想阻止程序原有的抛错行为。于是 Node.js 就为此新增了一个 ",(0,t.jsx)(n.code,{children:"events.errorMonitor"})," 的事件。所以一旦有错误事件发生，那么无论如何都触发一下这个 ",(0,t.jsx)(n.code,{children:"errorMonitor"})," 事件，以让“旁观者”记录一下。"]}),"\n",(0,t.jsxs)(n.p,{children:["记录完后，再重置一下 ",(0,t.jsx)(n.code,{children:"doError"})," 的值，即看看 ",(0,t.jsx)(n.code,{children:"events.error"})," 是不是存在——有没有监听过 ",(0,t.jsx)(n.code,{children:"error"})," 事件。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      const events = this._events;\n      if (events !== undefined) {\n        if (doError && events[kErrorMonitor] !== undefined)\n          this.emit(kErrorMonitor, ...args);\n        doError = (doError && events.error === undefined);\n      } else if (!doError)\n        return false;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["处理完“监控错误事件”之后，开始真正处理“错误事件”了。如果重置 ",(0,t.jsx)(n.code,{children:"doError"})," 的值后仍然是 ",(0,t.jsx)(n.code,{children:"true"}),"，也就是说没有监听 ",(0,t.jsx)(n.code,{children:"error"})," 事件，那就要着手抛出异常了。错误为 ",(0,t.jsx)(n.code,{children:"args"})," 的第 ",(0,t.jsx)(n.code,{children:"0"})," 个元素。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      if (doError) {\n        let er;\n        if (args.length > 0)\n          er = args[0];\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后判断一下错误类型，如果它是个 ",(0,t.jsx)(n.code,{children:"Error"})," 类型，那么在抛出异常前，为其装一个 ",(0,t.jsx)(n.code,{children:"kEnhanceStackBeforeInspector"})," 字段的函数，这个函数会在 Node.js 进入 Fatal Error（未捕获异常导致的进程崩溃）时候被调用以输出经过美化后的错误堆栈。如果我们在这里不这么做，那么我们看到的“导致进程崩溃”的异常错误堆栈会是异常根因，即产生异常的地方。而这里增强堆栈后，我们不仅能看到根因，还能多看一层，是因为“没有监听 ",(0,t.jsx)(n.code,{children:"error"})," 事件导致的抛错（Unhandled 'error' event）”。"]}),"\n",(0,t.jsx)(n.p,{children:"代码中的具体逻辑可以不用纠结，里面就是一些错误堆栈字符串的处理等等。只要知道这段代码是增强 Fatal Error 错误堆栈即可。增强完后，仍旧抛出异常。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        if (er instanceof Error) {\n          try {\n            const capture = {};\n            Error.captureStackTrace(capture, EventEmitter.prototype.emit);\n            Object.defineProperty(er, kEnhanceStackBeforeInspector, {\n              __proto__: null,\n              value: enhanceStackTrace.bind(this, er, capture),\n              configurable: true,\n            });\n          } catch {\n            // Continue regardless of error.\n          }\n\n          throw er; // Unhandled 'error' event\n        }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Node.js，或者说 JavaScript 是很随意的。我们可以抛出任何类型的异常。上面的代码讲的是 ",(0,t.jsx)(n.code,{children:"error"})," 事件中的内容是 ",(0,t.jsx)(n.code,{children:"Error"})," 类型的处理。"]}),"\n",(0,t.jsxs)(n.p,{children:["非 ",(0,t.jsx)(n.code,{children:"Error"})," 类型的时候，先通过 ",(0,t.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/util.html#utilinspectobject-options",title:"https://nodejs.org/dist/latest-v18.x/docs/api/util.html#utilinspectobject-options",target:"_blank",rel:"noopener noreferrer",children:"util.inspect()"})," 对异常内容进行格式化。如果格式化失败，还是兜底回异常本身。然后再根据该格式化内容新建一个 Unhandle 错误，最终抛出。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        let stringifiedEr;\n        try {\n          stringifiedEr = inspect(er);\n        } catch {\n          stringifiedEr = er;\n        }\n\n        // At least give some kind of context to the user\n        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n        err.context = er;\n        throw err; // Unhandled 'error' event\n      }\n"})}),"\n",(0,t.jsx)(n.p,{children:"异常处理完之后，开始进入正题了。这个就是我在最开始讲的两步走。如果事件不存在，则忽略。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      const handler = events[type];\n\n      if (handler === undefined)\n        return false;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["否则根据类型不同进行处理。如果是函数，直接通过 ",(0,t.jsx)(n.code,{children:"apply"})," 进行调用。然后如果返回结果不是 ",(0,t.jsx)(n.code,{children:"undefined"})," 和 ",(0,t.jsx)(n.code,{children:"null"}),"，就通过 ",(0,t.jsx)(n.code,{children:"addCatch"})," 去处理可能的 ",(0,t.jsx)(n.code,{children:"Promise"})," 的 ",(0,t.jsx)(n.code,{children:"rejection"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      if (typeof handler === 'function') {\n        const result = handler.apply(this, args);\n\n        // We check if result is undefined first because that\n        // is the most common case so we do not pay any perf\n        // penalty\n        if (result !== undefined && result !== null) {\n          addCatch(this, result, type, args);\n        }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果是数组，那么就逐个处理，逐个 ",(0,t.jsx)(n.code,{children:"addCatch()"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      } else {\n        const len = handler.length;\n        const listeners = arrayClone(handler);\n        for (let i = 0; i < len; ++i) {\n          const result = listeners[i].apply(this, args);\n\n          // We check if result is undefined first because that\n          // is the most common case so we do not pay any perf\n          // penalty.\n          // This code is duplicated because extracting it away\n          // would make it non-inlineable.\n          if (result !== undefined && result !== null) {\n            addCatch(this, result, type, args);\n          }\n        }\n      }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["最终，返回 ",(0,t.jsx)(n.code,{children:"true"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      return true;\n    };\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"EventEmitter"})," 的构造函数中有一个 ",(0,t.jsx)(n.code,{children:"captureRejections"})," 的配置，会被设置到 ",(0,t.jsx)(n.code,{children:"kCapture"})," 中。若设为 ",(0,t.jsx)(n.code,{children:"true"}),"，那么在 ",(0,t.jsx)(n.code,{children:"emit()"})," 时若对应监听函数是个 ",(0,t.jsx)(n.code,{children:"async"})," 函数，或者它的返回值是个类 ",(0,t.jsx)(n.code,{children:"Promise"})," 对象，那么会去捕获它的 ",(0,t.jsx)(n.code,{children:".catch()"}),"，并将捕获的异常嫁接给 ",(0,t.jsx)(n.code,{children:"error"})," 事件。"]}),"\n",(0,t.jsxs)(n.p,{children:["这个逻辑就是 ",(0,t.jsx)(n.code,{children:"addCatch()"})," 里面做的事了。直接调用 ",(0,t.jsx)(n.code,{children:"promise"}),"（也就是外面传进来的 ",(0,t.jsx)(n.code,{children:"result"}),"）的 ",(0,t.jsx)(n.code,{children:".then()"}),"。第一个参数是成功的回调，第二个参数相当于 ",(0,t.jsx)(n.code,{children:".catch()"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"    function addCatch(that, promise, type, args) {\n      if (!that[kCapture]) {\n        return;\n      }\n\n      try {\n        const then = promise.then;\n\n        if (typeof then === 'function') {\n          then.call(promise, undefined, function(err) {\n            process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);\n          });\n        }\n      } catch (err) {\n        that.emit('error', err);\n      }\n    }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在 ",(0,t.jsx)(n.code,{children:".catch()"})," 中，直接通过 ",(0,t.jsx)(n.code,{children:"process.nextTick()"})," 来将错误提交到 ",(0,t.jsx)(n.code,{children:"emitUnhandledRejectionOrErr()"})," 函数中。",(0,t.jsx)(n.code,{children:"kRejection"})," 就是 ",(0,t.jsx)(n.code,{children:"Symbol.for('nodejs.rejection')"}),"，就是 Node.js 官方文档中说的用于接收这类异常的函数，需要",(0,t.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/events.html#emittersymbolfornodejsrejectionerr-eventname-args",title:"https://nodejs.org/dist/latest-v18.x/docs/api/events.html#emittersymbolfornodejsrejectionerr-eventname-args",target:"_blank",rel:"noopener noreferrer",children:"开发者自行设置"}),"。如果没有设置 ",(0,t.jsx)(n.code,{children:"kRejection"}),"，那么就需要触发 ",(0,t.jsx)(n.code,{children:"error"})," 事件。这里触发时需要强行将 ",(0,t.jsx)(n.code,{children:"kCapture"})," 设置为 ",(0,t.jsx)(n.code,{children:"false"}),"，否则如果里面触发的时候又是一个 ",(0,t.jsx)(n.code,{children:"rejection"}),"，那么子子孙孙无穷尽，会变成一个 ",(0,t.jsx)(n.code,{children:"rejection"})," 的套娃，最后爆栈崩溃。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"    function emitUnhandledRejectionOrErr(ee, err, type, args) {\n      if (typeof ee[kRejection] === 'function') {\n        ee[kRejection](err, type, ...args);\n      } else {\n        const prev = ee[kCapture];\n        try {\n          ee[kCapture] = false;\n          ee.emit('error', err);\n        } finally {\n          ee[kCapture] = prev;\n        }\n      }\n    }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["触发完 ",(0,t.jsx)(n.code,{children:"error"})," 事件之后，再把原来的 ",(0,t.jsx)(n.code,{children:"kCapture"})," 恢复回去就好了。"]}),"\n",(0,t.jsxs)(n.h2,{id:"eventtarget",children:[(0,t.jsx)(n.code,{children:"EventTarget"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#eventtarget",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"EventTarget"})," 是 Web API 中可以接受事件的 ",(0,t.jsx)(n.code,{children:"interface"}),"，并且我们可以为其创建监听器。在浏览器环境中，好多对象都实现了这个接口，比如 ",(0,t.jsx)(n.code,{children:"Node"}),"、",(0,t.jsx)(n.code,{children:"XMLHttpRequest"}),"、",(0,t.jsx)(n.code,{children:"Window"})," 等。它提供了一些方法，如："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"addEventListener"}),"；"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"removeEventListener"}),"；"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"dispatchEvent"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["这三个方法分别用于注册、删除和触发事件。对比一下 Node.js 的 ",(0,t.jsx)(n.code,{children:"events"})," 模块，是不是异曲同工？虽然 Node.js 实现了 ",(0,t.jsx)(n.code,{children:"events"})," 这个异曲同工的模块，但为了符合 Web-interoperable Runtime 规范，还是实现了 ",(0,t.jsx)(n.code,{children:"EventTarget"})," 类。毕竟在 Winter 中不止一个类是基于它的。如："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel",title:"https://developer.mozilla.org/zh-CN/docs/Web/API/BroadcastChannel",target:"_blank",rel:"noopener noreferrer",children:"BroadcastChannel"}),"；"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Performance",title:"https://developer.mozilla.org/zh-CN/docs/Web/API/Performance",target:"_blank",rel:"noopener noreferrer",children:"Performance"}),"；"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController",title:"https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController",target:"_blank",rel:"noopener noreferrer",children:"AbortController"}),"；"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/MessagePort",title:"https://developer.mozilla.org/zh-CN/docs/Web/API/MessagePort",target:"_blank",rel:"noopener noreferrer",children:"MessagePort"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["在 ",(0,t.jsx)(n.code,{children:"EventTarget"})," 触发事件的时候，得到的事件对象是一个 ",(0,t.jsx)(n.code,{children:"Event"})," 的接口相关类。"]}),"\n",(0,t.jsxs)(n.h3,{id:"构造函数-1",children:["构造函数",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#构造函数-1",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"构造函数非常简单，主要就是初始化一些内部变量。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"    function initEventTarget(self) {\n      self[kEvents] = new Map();\n      self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n      self[kMaxEventTargetListenersWarned] = false;\n    }\n\n    class EventTarget {\n      static [kIsEventTarget] = true;\n\n      constructor() {\n        initEventTarget(this);\n      }\n      \n      ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["把 ",(0,t.jsx)(n.code,{children:"initEventTarget()"})," 函数抽出来是因为有其它地方要用到这个函数。"]}),"\n",(0,t.jsxs)(n.h3,{id:"新增监听addeventlistener",children:["新增监听——",(0,t.jsx)(n.code,{children:"addEventListener()"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#新增监听addeventlistener",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["这个写起来就比 ",(0,t.jsx)(n.code,{children:"events"})," 模块的 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 规矩多了——毕竟 Spec 也比较冗杂。最开始先按规范判断边界条件，调用的时候的 ",(0,t.jsx)(n.code,{children:"this"})," 是不是对的。然后再判断参数数量。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"    function isEventTarget(obj) {\n      return obj?.constructor?.[kIsEventTarget];\n    }\n\n    class EventTarget {\n      ...\n      addEventListener(type, listener, options = kEmptyObject) {\n        if (!isEventTarget(this))\n          throw new ERR_INVALID_THIS('EventTarget');\n        if (arguments.length < 2)\n          throw new ERR_MISSING_ARGS('type', 'listener');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["紧接着验证一下 ",(0,t.jsx)(n.code,{children:"options"})," 参数，并把内部一些信息解构出来。具体",(0,t.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.16.0/lib/internal/event_target.js#L968-L985",title:"https://github.com/nodejs/node/blob/v18.16.0/lib/internal/event_target.js#L968-L985",target:"_blank",rel:"noopener noreferrer",children:"解构逻辑"}),"就不放出来了，大家可以自行研究。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        const {\n          once,\n          capture,\n          passive,\n          signal,\n          isNodeStyleListener,\n          weak,\n        } = validateEventListenerOptions(options);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后验证传进来的 ",(0,t.jsx)(n.code,{children:"listener"})," 是否合法。合法的 ",(0,t.jsx)(n.code,{children:"listener"})," 指的是下面任意内容："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"null"}),"；"]}),"\n",(0,t.jsx)(n.li,{children:"一个函数；"}),"\n",(0,t.jsxs)(n.li,{children:["一个包含 ",(0,t.jsx)(n.code,{children:"handleEvent()"})," 方法的对象。"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["具体的",(0,t.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.16.0/lib/internal/event_target.js#L951-L966",title:"https://github.com/nodejs/node/blob/v18.16.0/lib/internal/event_target.js#L951-L966",target:"_blank",rel:"noopener noreferrer",children:"验证逻辑"}),"也不放出来了，大家可以自行研究。这里如果是 ",(0,t.jsx)(n.code,{children:"null"}),"，就会返回 ",(0,t.jsx)(n.code,{children:"false"}),"，这个时候 Node.js 会打印出一条下面的 Warning 并退出这个函数；后两者的话会返回 ",(0,t.jsx)(n.code,{children:"true"}),"，会将 ",(0,t.jsx)(n.code,{children:"type"})," 进行字符串化；如果是其它情况，则会在 ",(0,t.jsx)(n.code,{children:"validateEventListener()"})," 内部就抛出异常给上层捕获。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        if (!validateEventListener(listener)) {\n          const w = new Error(`addEventListener called with ${listener}` +\n                              ' which has no effect.');\n          w.name = 'AddEventListenerArgumentTypeWarning';\n          w.target = this;\n          w.type = type;\n          process.emitWarning(w);\n          return;\n        }\n        type = String(type);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["下面是对于 ",(0,t.jsx)(n.code,{children:"options"})," 中 ",(0,t.jsx)(n.code,{children:"signal"})," 这个参数的处理。如果刚监听这会儿已经 ",(0,t.jsx)(n.code,{children:"aborted"})," 了，就直接返回。否则监听 ",(0,t.jsx)(n.code,{children:"signal"})," 的 ",(0,t.jsx)(n.code,{children:"abort"})," 事件，并且在回调函数中将本次 ",(0,t.jsx)(n.code,{children:"EventTarget"})," 的监听函数给移除掉。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里注意，",(0,t.jsx)(n.code,{children:"signal"})," 传进来得是一个 ",(0,t.jsx)(n.code,{children:"AbortController"}),"。我们在上面提过，",(0,t.jsx)(n.code,{children:"AbortController"})," 本身就是一个 ",(0,t.jsx)(n.code,{children:"EventTarget"})," 的子类，可以监听。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        if (signal) {\n          if (signal.aborted) {\n            return;\n          }\n\n          signal.addEventListener('abort', () => {\n            this.removeEventListener(type, listener, options);\n          }, { once: true, [kWeakHandler]: this });\n        }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["后面就是从 ",(0,t.jsx)(n.code,{children:"this[kEvents]"})," 这个 ",(0,t.jsx)(n.code,{children:"Map"})," 中取出名为 ",(0,t.jsx)(n.code,{children:"type"})," 的链表，看看曾经是否有添加过对应的监听。这个逻辑就跟 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 类似了。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里有一个概念，存某一类型监听的容器是一条链表，而不再是数组。所以从 ",(0,t.jsx)(n.code,{children:"Map"})," 中取出的实际上是一个元信息对象，里面有链表长度，以及链表头两个信息。"]}),"\n",(0,t.jsxs)(n.p,{children:["如果没有添加过对应监听，及从 ",(0,t.jsx)(n.code,{children:"Map"})," 中取出的是 ",(0,t.jsx)(n.code,{children:"undefined"}),"，那么新建一个链表元信息，并且新建一个链表节点（",(0,t.jsx)(n.code,{children:"Listener"}),"），并将其塞入链表头（",(0,t.jsx)(n.code,{children:"Listener"})," 构造函数中做的逻辑）。"]}),"\n",(0,t.jsxs)(n.p,{children:["做完这些后，调用 ",(0,t.jsx)(n.code,{children:"this[kNewListener]()"})," 方法来判断一下监听数有没有到达上限，若到达上限就打印一个警告。这个方法内部具体就不讲解了。"]}),"\n",(0,t.jsxs)(n.p,{children:["打印完警告后，再将该链表元信息对象塞回 ",(0,t.jsx)(n.code,{children:"Map"})," 中，就算完成了，退出函数。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        let root = this[kEvents].get(type);\n\n        if (root === undefined) {\n          root = { size: 1, next: undefined };\n          new Listener(root, listener, once, capture, passive,\n                       isNodeStyleListener, weak);\n          this[kNewListener](\n            root.size,\n            type,\n            listener,\n            once,\n            capture,\n            passive,\n            weak);\n          this[kEvents].set(type, root);\n          return;\n        }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果之前有添加过同类监听，那么我们拿到的 ",(0,t.jsx)(n.code,{children:"root"})," 就是一个链表元信息。这个时候我们从中取出链表头，并逐一遍历整条链表，看看存不存在同样的监听对象或者函数，也就是说该监听 ",(0,t.jsx)(n.code,{children:"listener"})," 函数之前有没有已经添加过了——主要对比 ",(0,t.jsx)(n.code,{children:"listener"})," 和 ",(0,t.jsx)(n.code,{children:"capture"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        let handler = root.next;\n        let previous = root;\n\n        while (handler !== undefined && !handler.same(listener, capture)) {\n          previous = handler;\n          handler = handler.next;\n        }\n"})}),"\n",(0,t.jsx)(n.p,{children:"如果一圈下来发现有添加过了，那么直接忽略这次添加，直接退出。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        if (handler !== undefined) { // Duplicate! Ignore\n          return;\n        }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果没有，那么新建一个监听节点，并把它加入链表尾部（",(0,t.jsx)(n.code,{children:"Listener"})," 构造函数中的逻辑），链表元信息加一，打印可能得监听数上限警告。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        new Listener(previous, listener, once, capture, passive,\n                     isNodeStyleListener, weak);\n        root.size++;\n        this[kNewListener](root.size, type, listener, once, capture, passive, weak);\n      }\n"})}),"\n",(0,t.jsx)(n.p,{children:"至此，整个新增监听逻辑结束。"}),"\n",(0,t.jsxs)(n.p,{children:["其实整个逻辑与 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 真的类似，只不过多了一个查重的逻辑，另外监听的函数数组变成了一条链表。"]}),"\n",(0,t.jsxs)(n.h3,{id:"事件触发dispatchevent",children:["事件触发——",(0,t.jsx)(n.code,{children:"dispatchEvent()"}),(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#事件触发dispatchevent",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"EventTarget"})," 的事件触发是 ",(0,t.jsx)(n.code,{children:"dispatchEvent()"})," 方法。最开始的逻辑仍然是判断 ",(0,t.jsx)(n.code,{children:"this"})," 的合法性，以及参数的合法性，得是一个 ",(0,t.jsx)(n.code,{children:"Event"})," 对象。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      dispatchEvent(event) {\n        if (!isEventTarget(this))\n          throw new ERR_INVALID_THIS('EventTarget');\n        if (arguments.length < 1)\n          throw new ERR_MISSING_ARGS('event');\n\n        if (!(event instanceof Event))\n          throw new ERR_INVALID_ARG_TYPE('event', 'Event', event);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后看看这个 ",(0,t.jsx)(n.code,{children:"event"})," 对象是否已经被触发过了。如果被触发过了，会留下 ",(0,t.jsx)(n.code,{children:"kIsBeingDispatched"})," 的痕迹。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        if (event[kIsBeingDispatched])\n          throw new ERR_EVENT_RECURSION(event.type);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["再接下去，交给 ",(0,t.jsx)(n.code,{children:"this[kHybridDispatch]()"})," 处理事件本身，这里面传进去之后，会改变 ",(0,t.jsx)(n.code,{children:"event"})," 的一些相关内容。最终判断 ",(0,t.jsx)(n.code,{children:"event"})," 是否 ",(0,t.jsx)(n.code,{children:"defaultPrevented"}),"，通过这个来决定方法最终返回值。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        this[kHybridDispatch](event, event.type, event);\n\n        return event.defaultPrevented !== true;\n      }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["而 ",(0,t.jsx)(n.code,{children:"this[kHybridDispatch]()"})," 才是核心逻辑。前面就是小打小闹。这里面逻辑比较冗杂，还夹杂了 Node.js 特有的 ",(0,t.jsx)(n.code,{children:"NodeEventTarget"})," 逻辑。下面我就把这个方法分拆一下，删减、修改一些内容，便于理解。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里面的 ",(0,t.jsx)(n.code,{children:"nodeValue"})," 我们不用管，至少这条链路走下来的逻辑用不到。首先是先将 ",(0,t.jsx)(n.code,{children:"kIsBeingDispatched"})," 置为 ",(0,t.jsx)(n.code,{children:"true"}),"，这个标识在前面逻辑中有用到。然后从 ",(0,t.jsx)(n.code,{children:"kEvents"})," 的 ",(0,t.jsx)(n.code,{children:"Map"})," 中取出链表，若链表不存在则说明没有任何监听，那么重置 ",(0,t.jsx)(n.code,{children:"kIsBeingDispatched"})," 为 ",(0,t.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      [kHybridDispatch](nodeValue, type, event) {\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n        \n        const root = this[kEvents].get(type);\n        if (root === undefined || root.next === undefined) {\n          event[kIsBeingDispatched] = false;\n          return true;\n        }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["接着开始遍历链表。",(0,t.jsx)(n.code,{children:"handler"})," 就是之前新建的 ",(0,t.jsx)(n.code,{children:"Listener"})," 对象，里面的各字段在 MDN 上的 ",(0,t.jsx)(n.code,{children:"addEventListener()"})," 文档中都能找到",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#options",title:"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#options",target:"_blank",rel:"noopener noreferrer",children:"对应含义"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        let handler = root.next;\n        let next;\n\n        while (handler !== undefined &&\n               (handler.passive || event?.[kStop] !== true)) {\n          next = handler.next;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在每次遍历中，先看看这个监听是否已被移除，或者是只触发一次。由于每次遍历最后，会将 ",(0,t.jsx)(n.code,{children:"handler"})," 变为 ",(0,t.jsx)(n.code,{children:"next"}),"，而如果当前正在处理的 ",(0,t.jsx)(n.code,{children:"listener"})," 中的逻辑是删除之后的这个 ",(0,t.jsx)(n.code,{children:"listener"}),"，那么下次循环还是会拿到这个 ",(0,t.jsx)(n.code,{children:"next"}),"。所以“删除逻辑”中要给 ",(0,t.jsx)(n.code,{children:"handler"})," 一个 ",(0,t.jsx)(n.code,{children:"removed"})," 的标识，表示它被删除了。一旦发现它被删除了，就跳过当前的 ",(0,t.jsx)(n.code,{children:"handler"}),"，直接处理它的 ",(0,t.jsx)(n.code,{children:"next"}),"。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"想象一下这个逻辑就明白了："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"      const et = new EventTarget();\n      const listener = () => { throw new Error('这里不会被调用。'); };\n      et.addEventListener('foo', (e) => {\n        et.removeEventListener('foo', listener);\n      });\n      et.addEventListener('foo', listener);\n      et.dispatchEvent(new Event('foo'));\n"})}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"          if (handler.removed) {\n            handler = next;\n            continue;\n          }\n          if (handler.once) {\n            handler.remove();\n            root.size--;\n            const { listener, capture } = handler;\n          }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["处理完这些逻辑后，就开始调用 ",(0,t.jsx)(n.code,{children:"listener"})," 本体了。调用完后，把 ",(0,t.jsx)(n.code,{children:"kIsBeingDispatched"})," 给重新赋值为 ",(0,t.jsx)(n.code,{children:"false"}),"。然后同样对可能的 ",(0,t.jsx)(n.code,{children:"Promise"})," 结果进行 ",(0,t.jsx)(n.code,{children:"catch"})," 并触发 Uncaught Exception 处理（",(0,t.jsx)(n.code,{children:"addCatch"}),"，不过这里的 ",(0,t.jsx)(n.code,{children:"addCatch"})," 逻辑与 ",(0,t.jsx)(n.code,{children:"EventEmitter"})," 不是完全相同的，但是类似）。如果在这一段逻辑中有任何异常，那么触发 Uncaught Exception。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"          try {\n            const arg = event;\n            const callback = handler.weak ?\n              handler.callback.deref() : handler.callback;\n            let result;\n            if (callback) {\n              result = Function.prototype.call(callback, this, arg);\n              arg[kIsBeingDispatched] = false;\n            }\n            if (result !== undefined && result !== null)\n              addCatch(result);\n          } catch (err) {\n            emitUncaughtException(err);\n          }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["处理完后，把 ",(0,t.jsx)(n.code,{children:"handler"})," 给改成我们之前讲的 ",(0,t.jsx)(n.code,{children:"next"}),"，开启下一轮循环。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"          handler = next;\n        }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["最后，把 ",(0,t.jsx)(n.code,{children:"event"})," 的 ",(0,t.jsx)(n.code,{children:"kIsBeingDispatched"})," 也设置为 ",(0,t.jsx)(n.code,{children:"false"}),"，就完成了整段逻辑了。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"        event[kIsBeingDispatched] = false;\n      }\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"本章小结",children:["本章小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章小结",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["本章为大家介绍了 Node.js 的重要机制之一 ",(0,t.jsx)(n.code,{children:"events"})," 模块，以及其相关的 Web-interoperable Runtime 的类 ",(0,t.jsx)(n.code,{children:"EventTarget"}),"。二者在行为上类似，都是事件机制，都有新增监听、删除监听，以及触发事件的功能。",(0,t.jsx)(n.code,{children:"events"})," 自 Node.js 问世来，很早就有了这个能力，是 Node.js 各种其它内置模块和生态模块的重要支柱。而 ",(0,t.jsx)(n.code,{children:"EventTarget"})," 主要是支持一些 Web API 而做的，因为有一些 Web API 就是 ",(0,t.jsx)(n.code,{children:"EventTarget"})," 的子类。"]}),"\n",(0,t.jsx)(n.p,{children:"本章为大家解析了事件模块的构造函数、新增监听函数以及触发函数的代码，里面还是可以多回味一下。"})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}let o=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F22-Node.js%20%E4%B8%8E%20Winter%20%E7%9A%84%E8%9E%8D%E5%90%88%EF%BC%88%E4%BA%96%EF%BC%89%EF%BC%9Aevents%20%E4%B8%8E%20EventTarget.md"]={toc:[{text:"`events` 模块",id:"events-模块",depth:2},{text:"构造函数",id:"构造函数",depth:3},{text:"新增监听",id:"新增监听",depth:3},{text:"`on` 与 `addListener`",id:"on-与-addlistener",depth:4},{text:"`once`",id:"once",depth:4},{text:"事件触发",id:"事件触发",depth:3},{text:"`EventTarget`",id:"eventtarget",depth:2},{text:"构造函数",id:"构造函数-1",depth:3},{text:"新增监听——`addEventListener()`",id:"新增监听addeventlistener",depth:3},{text:"事件触发——`dispatchEvent()`",id:"事件触发dispatchevent",depth:3},{text:"本章小结",id:"本章小结",depth:2}],title:"22-Node.js 与 Winter 的融合（亖）：events 与 EventTarget",headingTitle:"22-Node.js 与 Winter 的融合（亖）：events 与 EventTarget",frontmatter:{}}}}]);