"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16739"],{883412:function(e,n,r){r.r(n),r.d(n,{default:()=>z});var s=r(552676),i=r(740453);let d=r.p+"static/image/43a6afa5aa59f8254d65bd2cf8bdc1c6.2a015585.gif",c=r.p+"static/image/d53c67cf926dc54d72c5efd896b7198b.dd4191bc.gif",a=r.p+"static/image/a25bec22447b2dbd94739c96a3be10cd.f6a5e7d2.webp",l=r.p+"static/image/0f356c89b50d666a33e8bc791c7686c8.eeb5914e.webp",t=r.p+"static/image/152d0e2ce38ee5ffae139d95cad25b76.71dafec3.webp",h=r.p+"static/image/158fe6f26e088be389c09ea48b9e04fe.2eb07d00.webp",o=r.p+"static/image/ac1cab998472712f33bb8e0bb73864dd.7989fbb3.gif",x=r.p+"static/image/e1db322e13f887d914bcce01433b7c83.0b4087b9.gif",j=r.p+"static/image/866707c5c2d51b2b1d577fac56e03a8f.9dbbe2c4.webp",p=r.p+"static/image/68dda1cf72672a153c212c1d82d48412.2eb07d00.webp",m=r.p+"static/image/a9ae07c14cc143a460335fb1d8ac387b.922f4d7c.webp",g=r.p+"static/image/c2a8a43764ee5783a9ef62eb59847d01.c4788fab.webp",f=r.p+"static/image/d204417f376757407e35447b15237d39.71478f86.webp",u=r.p+"static/image/f6a028acb989956de5ef4d9c0cbcd0b9.622fe8bf.webp",b=r.p+"static/image/96b9c3719bfcfc5be4c79e147f08b949.c77d309f.webp",v=r.p+"static/image/d471c6dbaa6c322f93e1d15b6996c153.20fa5a19.webp",y=r.p+"static/image/2e73be708f84fff03d6acf92427027a0.ca0436ce.webp",w=r.p+"static/image/a466217a1bcd2cd8b207899d2e5efd5c.ede7f582.webp";function N(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h3:"h3",strong:"strong",img:"img",ol:"ol",li:"li",pre:"pre",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ul:"ul"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"21组件篇-_-images",children:["21.组件篇 _ Images",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21组件篇-_-images",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本篇开始我们进入组件篇，为大家详细介绍 Next.js 内置的四个组件，分别是：",(0,s.jsx)(n.code,{children:"<Image>"}),"、",(0,s.jsx)(n.code,{children:"Font"}),"、",(0,s.jsx)(n.code,{children:"<Link>"}),"、",(0,s.jsx)(n.code,{children:"<Script>"}),"，它们都是 Next.js 基于原生 HTML 标签做了诸多优化而专门抽象的组件，在开发的时候尽可能的使用这些组件。"]}),"\n",(0,s.jsxs)(n.p,{children:["其中 ",(0,s.jsx)(n.code,{children:"<Image>"})," 组件实现了懒加载和根据设备尺寸自动调整图片大小，",(0,s.jsx)(n.code,{children:"<Link> "}),"组件实现了后台预获取资源，从而让页面转换更快更平滑，",(0,s.jsx)(n.code,{children:"<Script>"})," 组件使得你可以控制加载和执行第三方脚本等等……具体的功能和 API 我们会在组件篇中详细介绍。"]}),"\n",(0,s.jsxs)(n.p,{children:["本篇将介绍 ",(0,s.jsx)(n.code,{children:"<Image>"})," 组件，因为图片往往占据了网页大小很大一部分，图片的优化可谓是重中之重。",(0,s.jsx)(n.code,{children:"Image"})," 组件也提供了非常多的 prop 和配置项，了解这些 prop 以及背后的原理有助于我们更加深入的使用 ",(0,s.jsx)(n.code,{children:"Image"})," 组件，带来更好的用户体验。"]}),"\n",(0,s.jsxs)(n.h2,{id:"图片与-lcp",children:["图片与 LCP",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图片与-lcp",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1-图片占比",children:["1. 图片占比",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-图片占比",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["根据 ",(0,s.jsx)(n.a,{href:"https://almanac.httparchive.org/en/2022/media",target:"_blank",rel:"noopener noreferrer",children:"Web Almanac"})," 中的介绍，图片大小占典型网站页面大小的很大一部分。根据统计，2021 年 6 月网站的总大小中位数是 2019 KB（移动端），其中 881 KB 是图像。这比 HTML（30 KB），CSS（72 KB），JavaScript（461 KB）和字体（97 KB）的总和还要多。"]}),"\n",(0,s.jsxs)(n.p,{children:["在绝大多数页面上（70% 移动设备，80% 桌面），最有影响的就是图片。Largest Contentful Paint（最大内容绘制，简写：",(0,s.jsx)(n.a,{href:"https://web.dev/articles/lcp?hl=zh-cn",target:"_blank",rel:"noopener noreferrer",children:"LCP"}),"） 是一种 Web 性能指标，可以标识首屏中最大的内容元素。大部分时候，该元素都有图片。"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-lcp-背景",children:["2. LCP 背景",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-lcp-背景",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"考虑到 LCP 并不算是一个常为大家熟知的概念，所以我们单独介绍下 LCP。"}),"\n",(0,s.jsx)(n.p,{children:"对于 Web 开发者而言，衡量网页主要内容的加载速度一直是一个挑战。"}),"\n",(0,s.jsx)(n.p,{children:"传统我们会使用 load、DOMContentLoaded 等方法，但它们并不表示用户在屏幕上看到的内容的时间。"}),"\n",(0,s.jsx)(n.p,{children:"而像首次内容渲染（FCP），如果页面有 loading 效果，那获取的时间也是不准确的。"}),"\n",(0,s.jsx)(n.p,{children:"当然也有首次有效绘制（FMP）等指标，但是这些指标非常复杂，往往是错误的。所以也不能用来确定主要内容的加载时间。"}),"\n",(0,s.jsx)(n.p,{children:"根据 W3C Web 性能工作组中的讨论和 Google 的研究，要衡量网页主要内容的加载时间，更为准确的方法是查看最大元素的呈现时间。这就是 LCP。"}),"\n",(0,s.jsxs)(n.h3,{id:"3-lcp-概念与标准",children:["3. LCP 概念与标准",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-lcp-概念与标准",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Largest Contentful Paint (LCP) 指标会报告视口内可见的最大图片或文本块的呈现时间（相对于网页首次开始加载的时间）。"}),"\n",(0,s.jsxs)(n.p,{children:["为了提供良好的用户体验，网站应尽力将 Largest Contentful Paint 设置为 ",(0,s.jsx)(n.strong,{children:"2.5 秒"}),"或更短。"]}),"\n",(0,s.jsx)(n.p,{children:"让我们看一些  LCP 的例子："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那么问题来了，页面往往是分阶段加载的，网页中最大元素可能是在不断变化的，LCP 是怎么计算出来的呢？"}),"\n",(0,s.jsxs)(n.p,{children:["首先，浏览器会将 LCP 的元素限定在一些特定的元素类型内，比如",(0,s.jsx)(n.code,{children:"<img>"})," 元素、包含文本节点或其他内嵌级别文本元素的子项的块级元素、为自动播放 ",(0,s.jsx)(n.code,{children:"<video>"})," 元素而绘制的第一帧、动画图片格式（例如 GIF 动画）的第一帧等等（这是为了简化这个问题，如果什么元素都计算一遍大小，就太复杂了而且没必要）。"]}),"\n",(0,s.jsx)(n.p,{children:"然后浏览器在绘制完第一帧后，就会立即分派 largest-contentful-paint 类型的 PerformanceEntry，用于标识最大的内容元素。在渲染后续帧后，只要最大内容元素发生变化，该 API 就会再分派另一个 PerformanceEntry。简单的来说，每一帧绘制的时候，浏览器都会标示出最大内容元素。"}),"\n",(0,s.jsx)(n.p,{children:"当用户与页面发生交互（通过点按、滚动或按键），浏览器就会停止报告新条目。（因为用户交互通常会改变向用户显示的内容，就比如滚动操作）。一般来说，发出的最后一个条目的 startTime 值是 LCP 值。"}),"\n",(0,s.jsxs)(n.h2,{id:"image",children:[(0,s.jsx)(n.code,{children:"<Image>"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#image",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1-功能特性",children:["1. 功能特性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-功能特性",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["讲解 LCP，只是为了帮助大家认识到图片优化的重要性（毕竟最大内容元素往往是图片）。回到 ",(0,s.jsx)(n.code,{children:"<Image>"})," 组件上，Next.js 基于原生的 HTML ",(0,s.jsx)(n.code,{children:"<img>"})," 元素，实现了这些优化功能："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"尺寸优化：自动为每个设备提供正确尺寸的图片，也会使用现代图片格式如 WebP 和 AVIF。"}),"\n",(0,s.jsx)(n.li,{children:"视觉稳定性：防止图片加载时发生布局偏移（Layout Shift）"}),"\n",(0,s.jsx)(n.li,{children:"更快的页面加载：图片只有在进入视口的时候才会加载，使用懒加载功能，并可选使用模糊占位符"}),"\n",(0,s.jsx)(n.li,{children:"灵活配置：按需进行图片调整，远程服务器上的图片也可以"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这些功能我们会在讲解组件 API 的时候一一涉及。"}),"\n",(0,s.jsxs)(n.h3,{id:"2-基础使用",children:["2. 基础使用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-基础使用",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这是 ",(0,s.jsx)(n.code,{children:"<Image>"})," 组件的使用示例，看起来如同使用正常的 img 元素一样："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// app/page.js\nimport Image from \'next/image\'\n \nexport default function Page() {\n  return (\n    <Image\n      src="/profile.png"\n      width={500}\n      height={500}\n      alt="Picture of the author"\n    />\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"3-支持的-props",children:["3. 支持的 props",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-支持的-props",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<Image>"})," 组件支持传入这些 props："]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"Prop"})}),"\n",(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"示例"})}),"\n",(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"类型"})}),"\n",(0,s.jsx)(n.th,{children:(0,s.jsx)(n.strong,{children:"是否必须"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#src",target:"_blank",rel:"noopener noreferrer",children:"src"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'src="/profile.png"'})}),"\n",(0,s.jsx)(n.td,{children:"String"}),"\n",(0,s.jsx)(n.td,{children:"是"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#width",target:"_blank",rel:"noopener noreferrer",children:"width"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"width={500}"})}),"\n",(0,s.jsx)(n.td,{children:"Integer (px)"}),"\n",(0,s.jsx)(n.td,{children:"是"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#height",target:"_blank",rel:"noopener noreferrer",children:"height"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"height={500}"})}),"\n",(0,s.jsx)(n.td,{children:"Integer (px)"}),"\n",(0,s.jsx)(n.td,{children:"是"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#alt",target:"_blank",rel:"noopener noreferrer",children:"alt"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'alt="Picture of the author"'})}),"\n",(0,s.jsx)(n.td,{children:"String"}),"\n",(0,s.jsx)(n.td,{children:"是"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#loader",target:"_blank",rel:"noopener noreferrer",children:"loader"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"loader={imageLoader}"})}),"\n",(0,s.jsx)(n.td,{children:"Function"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#fill",target:"_blank",rel:"noopener noreferrer",children:"fill"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"fill={true}"})}),"\n",(0,s.jsx)(n.td,{children:"Boolean"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#sizes",target:"_blank",rel:"noopener noreferrer",children:"sizes"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'sizes="(max-width: 768px) 100vw"'})}),"\n",(0,s.jsx)(n.td,{children:"String"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#quality",target:"_blank",rel:"noopener noreferrer",children:"quality"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"quality={80}"})}),"\n",(0,s.jsx)(n.td,{children:"Integer (1-100)"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#priority",target:"_blank",rel:"noopener noreferrer",children:"priority"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"priority={true}"})}),"\n",(0,s.jsx)(n.td,{children:"Boolean"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#placeholder",target:"_blank",rel:"noopener noreferrer",children:"placeholder"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'placeholder="blur"'})}),"\n",(0,s.jsx)(n.td,{children:"String"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#style",target:"_blank",rel:"noopener noreferrer",children:"style"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'style={{objectFit: "contain"}}'})}),"\n",(0,s.jsx)(n.td,{children:"Object"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#onloadingcomplete",target:"_blank",rel:"noopener noreferrer",children:"onLoadingComplete"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onLoadingComplete={img => done())}"})}),"\n",(0,s.jsx)(n.td,{children:"Function"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#onload",target:"_blank",rel:"noopener noreferrer",children:"onLoad"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onLoad={event => done())}"})}),"\n",(0,s.jsx)(n.td,{children:"Function"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#onerror",target:"_blank",rel:"noopener noreferrer",children:"onError"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"onError(event => fail()}"})}),"\n",(0,s.jsx)(n.td,{children:"Function"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#loading",target:"_blank",rel:"noopener noreferrer",children:"loading"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'loading="lazy"'})}),"\n",(0,s.jsx)(n.td,{children:"String"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#blurdataurl",target:"_blank",rel:"noopener noreferrer",children:"blurDataURL"})}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'blurDataURL="data:image/jpeg..."'})}),"\n",(0,s.jsx)(n.td,{children:"String"}),"\n",(0,s.jsx)(n.td,{children:"-"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["其中，",(0,s.jsx)(n.code,{children:"src"}),"、",(0,s.jsx)(n.code,{children:"width"})," 、",(0,s.jsx)(n.code,{children:"height"}),"  和 ",(0,s.jsx)(n.code,{children:"alt"})," 是必须的，其他是可选的。让我们逐一讲解。"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-src-必须",children:["4. src-必须",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-src-必须",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"src 支持传入一个静态导入图片文件，也支持传入一个路径字符串。"}),"\n",(0,s.jsxs)(n.p,{children:["使用本地图片的时候，就可以采用静态导入图片文件的方式。通过 ",(0,s.jsx)(n.code,{children:"import"})," 导入 ",(0,s.jsx)(n.code,{children:".jpg"}),"、",(0,s.jsx)(n.code,{children:".png"})," 或者 ",(0,s.jsx)(n.code,{children:".webp"})," 格式的文件。使用示例如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// app/page.js\nimport Image from \'next/image\'\nimport profilePic from \'./me.png\'\n \nexport default function Page() {\n  return (\n    <Image\n      src={profilePic}\n      alt="Picture of the author"\n      // width={500} automatically provided\n      // height={500} automatically provided\n      // blurDataURL="data:..." automatically provided\n      // placeholder="blur" // Optional blur-up while loading\n    />\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["使用静态文件导入的方式，",(0,s.jsx)(n.code,{children:"width"})," 和 ",(0,s.jsx)(n.code,{children:"height"})," 不需要传入，Next.js 会自动提供。"]}),"\n",(0,s.jsxs)(n.p,{children:["注意：动态的 ",(0,s.jsx)(n.code,{children:"await import()"})," 或者 ",(0,s.jsx)(n.code,{children:"require() "}),"是不支持的。",(0,s.jsx)(n.code,{children:"import"})," 必须是静态的，才可以在构建的时候进行分析。"]}),"\n",(0,s.jsx)(n.p,{children:"使用远程图片的时候，src 可以传入一个 URL 字符串。"}),"\n",(0,s.jsxs)(n.p,{children:["由于 Next.js 在构建的时候无法获取远程文件，你需要手动提供 ",(0,s.jsx)(n.code,{children:"width"}),"、",(0,s.jsx)(n.code,{children:"height"})," 和可选的 ",(0,s.jsx)(n.code,{children:"blurDataURL"})," props。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"width"})," 和 ",(0,s.jsx)(n.code,{children:"heigth"})," 属性用于推断图像正确的宽高比（Aspect ratio，也称为纵横比）以及避免图片加载的时候发生布局偏移。但 ",(0,s.jsx)(n.code,{children:"width"})," 和",(0,s.jsx)(n.code,{children:"height"}),"并不决定图片最终的渲染尺寸，这也很好理解，因为你也可能设置拉伸模式等。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// app/page.js\nimport Image from \'next/image\'\n \nexport default function Page() {\n  return (\n    <Image\n      src="https://s3.amazonaws.com/my-bucket/profile.png"\n      alt="Picture of the author"\n      width={500}\n      height={500}\n    />\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["注意使用远程地址的时候，Next.js 要求在 ",(0,s.jsx)(n.code,{children:"next.config.js"}),"文件中定义支持的远程图片地址，这是为了防止一些恶意使用。配置方法如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 's3.amazonaws.com',\n        port: '',\n        pathname: '/my-bucket/**',\n      },\n    ],\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["关于配置文件中的 ",(0,s.jsx)(n.code,{children:"remotePatterns"}),"，本篇后面我们会详细讲解。"]}),"\n",(0,s.jsxs)(n.h3,{id:"5-width-必须",children:["5. width-必须",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-width-必须",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"width"})," 属性表示图片渲染的宽度，它以像素为单位，影响图片的显示大小。"]}),"\n",(0,s.jsxs)(n.p,{children:["该属性必须，除非是静态导入图片或者图片有 ",(0,s.jsx)(n.code,{children:"fill"})," 属性。"]}),"\n",(0,s.jsxs)(n.h3,{id:"6-height-必须",children:["6. height-必须",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-height-必须",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"height"})," 属性表示图片渲染的高度，它以像素为单位，影响图片的显示大小。"]}),"\n",(0,s.jsxs)(n.p,{children:["属性必须，除非是静态导入图片或者图片有 ",(0,s.jsx)(n.code,{children:"fill"})," 属性。"]}),"\n",(0,s.jsxs)(n.h3,{id:"7-alt",children:["7. alt",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-alt",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"alt"})," 属性用于描述图片，提供给屏幕阅读器和搜索引擎使用。如果图片被禁用或者加载图片时出现错误，它会作为降级的文本提示。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"alt"})," 属性应该使用在不改变页面含义的情况下替代图片的文本描述，不应该重复图片上方或下方标题中提供的信息。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果图片纯粹是装饰或者不是给用户使用，那 ",(0,s.jsx)(n.code,{children:"alt"})," 属性应该用一个空字符串表示（",(0,s.jsx)(n.code,{children:'alt=""'}),"）。"]}),"\n",(0,s.jsxs)(n.h3,{id:"8-loader",children:["8. loader",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-loader",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["\xa0",(0,s.jsx)(n.code,{children:"loader"})," 表示解析图片地址的自定义函数。让我们看段示例代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \nimport Image from 'next/image'\n \nconst imageLoader = ({ src, width, quality }) => {\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\n}\n \nexport default function Page() {\n  return (\n    <Image\n      loader={imageLoader}\n      src=\"me.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    />\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["函数接受 ",(0,s.jsx)(n.code,{children:"src"}),"、",(0,s.jsx)(n.code,{children:"width"}),"、",(0,s.jsx)(n.code,{children:"quality"}),"作为参数，返回图片的 URL 字符串。"]}),"\n",(0,s.jsxs)(n.p,{children:["注意：由于 ",(0,s.jsx)(n.code,{children:"loader"})," prop 传入的是一个函数，所以需要使用客户端组件，在这个例子中，顶部也是用的 ",(0,s.jsx)(n.code,{children:"'use client'"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["每一个图片都添加一个 loader 非常麻烦，你也可以使用 ",(0,s.jsx)(n.code,{children:"next.config.js"})," 中的 ",(0,s.jsx)(n.code,{children:"loaderFile"})," 配置项来配置应用里的每个 ",(0,s.jsx)(n.code,{children:"next/image"})," 实例，而无需传递 ",(0,s.jsx)(n.code,{children:"loader"})," prop。这个配置项本篇后面会讲解。"]}),"\n",(0,s.jsxs)(n.h3,{id:"9-fill",children:["9. fill",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-fill",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fill={true} // {true} | {false}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"fill"}),"表示是否将图片填充父元素。默认值为 ",(0,s.jsx)(n.code,{children:"false"}),"。当图片的 ",(0,s.jsx)(n.code,{children:"width"})," 和 ",(0,s.jsx)(n.code,{children:"height"})," 未知的时候很有用。"]}),"\n",(0,s.jsxs)(n.p,{children:["但是要注意：使用 ",(0,s.jsx)(n.code,{children:"fill"}),"，父元素必须指定为 ",(0,s.jsx)(n.code,{children:'position: "relative"'}),"或",(0,s.jsx)(n.code,{children:'position: "fixed"'}),"或",(0,s.jsx)(n.code,{children:'position: "absolute"'}),"。而 img 元素会默认自动指定为 ",(0,s.jsx)(n.code,{children:'position: "absolute"'}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"如果图片没有应用其他样式，图片会被拉伸以填充容器。"}),"\n",(0,s.jsxs)(n.p,{children:["当然填充容器有很多方式，CSS 属性里的 ",(0,s.jsx)(n.code,{children:'object-fit: "container"'})," 和 ",(0,s.jsx)(n.code,{children:'object-fit: "cover"'})," 也都可以用来填充图像。"]}),"\n",(0,s.jsx)(n.p,{children:"让我们简单看下区别："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nimport Image from 'next/image'\nimport profilePic from './image.png'\n \nexport default function Page() {\n  return (\n    <div style={{\n      width: '200px',\n      height: '200px',\n      backgroundColor: \"#ccc\",\n      position: 'relative'\n    }}>\n     <Image\n        src={profilePic}\n        alt=\"Picture of the author\"\n      />\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"正常显示如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果添加 fill 属性后："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'<Image\n  src={profilePic}\n  alt="Picture of the author"\n  fill={true}\n/>\n'})}),"\n",(0,s.jsx)(n.p,{children:"效果如下，图片会被拉伸以适应容器："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["如果使用 ",(0,s.jsx)(n.code,{children:'object-fit: "contain"'}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'<Image\n  src={profilePic}\n  alt="Picture of the author"\n  fill={true}\n  style={{objectFit: "contain"}}\n/>\n'})}),"\n",(0,s.jsx)(n.p,{children:"效果如下，图片在保持其宽高比的同时填充元素的整个内容框："}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("img",{src:u,alt:""}),"\n如果使用 ",(0,s.jsx)(n.code,{children:'object-fit: "cover"'}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'<Image\n  src={profilePic}\n  alt="Picture of the author"\n  fill={true}\n  style={{objectFit: "cover"}}\n/>\n'})}),"\n",(0,s.jsx)(n.p,{children:"效果如下，图片在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"10-sizes",children:["10. sizes",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-sizes",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["HTML 5.1 新增加了 img 元素的 ",(0,s.jsx)(n.code,{children:"srcset"}),"、",(0,s.jsx)(n.code,{children:"sizes"})," 属性，用于设置响应式图像。"]}),"\n",(0,s.jsxs)(n.p,{children:["当我们需要不同的设备展示不同的图片的时候，就需要用到 ",(0,s.jsx)(n.code,{children:"srcset"}),"。这里具体又分为两种情况，一种是图片是相同的尺寸，但是不同的分辨率对应不同的图片，即高分辨率下对应高倍图。一种是相同的图片内容，但依据设备显示的更大或者更小。这分别对应着 srcset 的两种语法。"]}),"\n",(0,s.jsx)(n.p,{children:"先说第一种，根据分辨率不同展示不同的图片，使用示例如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'<img\n  srcset="elva-fairy-320w.jpg, elva-fairy-480w.jpg 1.5x, elva-fairy-640w.jpg 2x"\n  src="elva-fairy-640w.jpg"\n  alt="Elva dressed as a fairy" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"srcset 是由逗号分隔的一个或多个字符串组成，每段字符串由以下组成："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"指向图像的 URL"}),"\n",(0,s.jsx)(n.li,{children:"一个空格（可选）"}),"\n",(0,s.jsx)(n.li,{children:"一个像素密度描述符（一个正浮点数，后面紧跟 x 符号）"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"如果我们给图片应用一个 CSS 样式："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"img {\n  width: 320px;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["它的宽度在屏幕上就是 320 像素（CSS 像素）。浏览器会计算出正在显示的显示器的分辨率，然后显示 srcset 引用的最适合的图片。如果是普通的分辨率，一个设备像素表示一个 CSS 像素，那就会加载 ",(0,s.jsx)(n.code,{children:"elva-fairy-320w.jpg"}),"，它的大小是 39KB，如果设备是高像素，用两个或者更多的设备像素表示一个 CSS 像素，那就会加载 ",(0,s.jsx)(n.code,{children:"elva-fairy-640w.jpg"}),"，它的大小是 93KB。"]}),"\n",(0,s.jsx)(n.p,{children:"再说第二种情况，相同的图片内容，但依据设备显示的更大或者更小。使用示例代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'<img\n  srcset="elva-fairy-small.jpg 480w, elva-fairy-large.jpg 800w"\n  src="elva-fairy-large.jpg"\n  alt="Elva dressed as a fairy" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"srcset 的语法与刚才略有不同，它定义了浏览器可选择的图片设置以及每个图片的大小。分析它的语法，依然是由逗号分隔的一个或多个字符串组成，每段字符串由以下部分组成："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"指向图像的 URL"}),"\n",(0,s.jsx)(n.li,{children:"一个空格"}),"\n",(0,s.jsx)(n.li,{children:"图片的固有宽度（以像素为单位）。注意，这里使用宽度描述符 w，而非 px。但一个 w 对应 1 个像素。图片的固有宽度是指它的真实大小。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["此时我们就告诉了浏览器，这张图片有两种备选图片可以显示，一张是 ",(0,s.jsx)(n.code,{children:"elva-fairy-small.jpg"}),"，这张图片的宽度是 480px，一张是 ",(0,s.jsx)(n.code,{children:"elva-fairy-large.jpg"}),"，它的宽度是 800px。"]}),"\n",(0,s.jsx)(n.p,{children:"那浏览器怎么知道用哪张图片呢？比如当前设备视口宽度是 640px，是选择 480px 的图片还是选择 800px 的图片呢？"}),"\n",(0,s.jsx)(n.p,{children:"为了帮助浏览器判断，你就需要写 sizes 属性。sizes 属性就是一组媒体查询条件，告诉浏览器，什么样的条件使用什么样的图片。一个使用示例如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'<img\n  srcset="elva-fairy-small.jpg 480w, elva-fairy-large.jpg 800w"\n  sizes="(max-width: 600px) 480px,\n         800px"\n  src="elva-fairy-large.jpg"\n  alt="Elva dressed as a fairy" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"sizes 也是由逗号分隔的一个或多个字符串组成，每段字符串由以下组成："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["一个媒体条件，例子中为 ",(0,s.jsx)(n.code,{children:"(max-width:600px)"}),"，它表示当视口的宽度小于等于 600px 时"]}),"\n",(0,s.jsx)(n.li,{children:"一个空格"}),"\n",(0,s.jsx)(n.li,{children:"当媒体条件为真时，图片将填充的宽度，这个宽度可以是固定值，比如这个例子中的 480px，也可以是一个相对于视口的宽度（如 50vw），但不能是百分比。如果没有媒体条件，表示是默认生效。当浏览器成功匹配第一个媒体条件的时候，剩下所有的条件都会被忽略。所以顺序很重要。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"有了这些属性后，浏览器会："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"检查设备宽度"}),"\n",(0,s.jsx)(n.li,{children:"检查 sizes 列表中哪个媒体条件是第一个为真"}),"\n",(0,s.jsx)(n.li,{children:"查看给予该媒体查询的槽大小"}),"\n",(0,s.jsx)(n.li,{children:"加载 srcset 列表中引用的最接近所选的槽大小的图像"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"比如在这个例子中，如果浏览器的视口是 480px，那么 sizes 中的第一个条件 (max-width: 600px) 就为真，所以选择 480px 大小，因为 480px 与固有宽度 480w 最接近，所以加载 elva-fairy-small.jpg。通过这种方式就可以实现移动端加载小图片，从而加快移动端的加载速度。"}),"\n",(0,s.jsxs)(n.p,{children:["讲完 img 元素的 ",(0,s.jsx)(n.code,{children:"srcset"})," 和 ",(0,s.jsx)(n.code,{children:"sizes"})," 属性，回到 ",(0,s.jsx)(n.code,{children:"<Image>"})," 组件上，使用 Next.js，你并不需要设置 ",(0,s.jsx)(n.code,{children:"srcset"}),"，Next.js 会自动为你生成。设置 sizes 属性会影响生成的 ",(0,s.jsx)(n.code,{children:"srcset"})," 的值。"]}),"\n",(0,s.jsx)(n.p,{children:"如果你不设置组件的 sizes 属性，Next.js 会用 1x、2x 这种像素密度描述符，而如果你设置了 sizes 属性，Next.js 会用 640w、750w 这种固有宽度描述符。"}),"\n",(0,s.jsx)(n.p,{children:"设置前："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"设置后："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"11-quality",children:["11. quality",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-quality",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"表示优化图片的质量，值为 1 到 100 之间的整数，100 表示最好的品质，也是最大的文件大小。默认是 75。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"quality={75} // {number 1-100}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"12-priority",children:["12. priority",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-priority",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["表示图片加载优先级，布尔类型，默认值为 false。当值为 true 时表示高优先级并预加载。使用 ",(0,s.jsx)(n.code,{children:"priority"})," 的图片会自动禁用懒加载。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"priority={false} // {false} | {true}\n"})}),"\n",(0,s.jsx)(n.p,{children:"使用该属性有两个建议："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"在首屏可见的图片上使用"}),"\n",(0,s.jsx)(n.li,{children:"在 LCP 图片元素上使用，考虑到不同的视口宽度可能有不同的 LCP 图片，可以设置多个"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["运行 ",(0,s.jsx)(n.code,{children:"next dev"})," 的时候，如果 LCP 元素是一个图片，但没有设置 priority 属性，控制台里会有警告："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"使用示例代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nimport Image from 'next/image'\nimport profilePic from '../public/me.png'\n \nexport default function Page() {\n  return <Image src={profilePic} alt=\"Picture of the author\" priority />\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"13-placeholder",children:["13. placeholder",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-placeholder",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["表示加载图片时的占位符。可选值为 ",(0,s.jsx)(n.code,{children:"blur"}),"、",(0,s.jsx)(n.code,{children:"empty"}),"、 ",(0,s.jsx)(n.code,{children:"data:image/... "}),"，默认值是 ",(0,s.jsx)(n.code,{children:"empty"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'placeholder = \'empty\' // "empty" | "blur" | "data:image/..."\n'})}),"\n",(0,s.jsxs)(n.p,{children:["当值为 ",(0,s.jsx)(n.code,{children:"empty"})," 的时候，加载不会有占位符，只有空白区域。"]}),"\n",(0,s.jsxs)(n.p,{children:["当值为 ",(0,s.jsx)(n.code,{children:"data:image/..."}),"的时候，使用 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URLs",target:"_blank",rel:"noopener noreferrer",children:"Data URL"})," 作为图片加载时的占位图片。Data URL，即前缀为 ",(0,s.jsx)(n.code,{children:"data:"})," 协议的 URL，允许内容创建者向文档中嵌入小文件。比如  base64 图片就是 Data URL。"]}),"\n",(0,s.jsxs)(n.p,{children:["当值为",(0,s.jsx)(n.code,{children:"blur"}),"的时候，",(0,s.jsx)(n.code,{children:"blurDataURL"}),"属性的值会被用于作为占位符图片。如果图片是静态导入的，并且导入的图片为 ",(0,s.jsx)(n.code,{children:".jpg"}),"、",(0,s.jsx)(n.code,{children:".png"}),"、",(0,s.jsx)(n.code,{children:".webp"}),"或 ",(0,s.jsx)(n.code,{children:".avif"})," ，blurDataURL 会自动生成，但动态图片除外。如果是动态图片，必须提供 ",(0,s.jsx)(n.code,{children:"blurDataURL"}),"属性。"]}),"\n",(0,s.jsxs)(n.p,{children:["这是一个默认的 ",(0,s.jsx)(n.a,{href:"https://image-component.nextjs.gallery/placeholder",target:"_blank",rel:"noopener noreferrer",children:"blur 效果演示"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"14-blurdataurl",children:["14. blurDataURL",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14-blurdataurl",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["只有当你设置了 ",(0,s.jsx)(n.code,{children:'placeholder="blur"'}),"，该属性值才会生效。"]}),"\n",(0,s.jsx)(n.p,{children:"必须是 base64 编码的图片。图片会被放大并模糊，建议使用一个非常小的图片（10px 或者更小）。"}),"\n",(0,s.jsxs)(n.p,{children:["可以借助 blurDataURI 实现这种",(0,s.jsx)(n.a,{href:"https://image-component.nextjs.gallery/placeholder",target:"_blank",rel:"noopener noreferrer",children:"色彩效果"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["可以借助 ",(0,s.jsx)(n.a,{href:"https://png-pixel.com/",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.a,{href:"https://png-pixel.com/",target:"_blank",rel:"noopener noreferrer",children:"https://png-pixel.com/"})})," 快速获得一个纯色图片的 Data URL。"]}),"\n",(0,s.jsxs)(n.h3,{id:"15-style",children:["15. style",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15-style",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"设置图片的样式"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// components/ProfileImage.js\nconst imageStyle = {\n  borderRadius: '50%',\n  border: '1px solid #fff',\n}\n \nexport default function ProfileImage() {\n  return <Image src=\"...\" style={imageStyle} />\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当你使用 style 修改了图片宽度的时候，注意设置 ",(0,s.jsx)(n.code,{children:"height"})," 为 ",(0,s.jsx)(n.code,{children:"auto"})," 以保持宽高比，否则图片会被扭曲。这是因为 Next.js 会自动为图片添加 ",(0,s.jsx)(n.code,{children:"width"})," 和 ",(0,s.jsx)(n.code,{children:"height"})," 属性，通过 style 样式只修改宽度，加上原本添加的 ",(0,s.jsx)(n.code,{children:"height"})," 属性，就会导致图片变形。"]}),"\n",(0,s.jsxs)(n.h3,{id:"16-onloadingcomplete",children:["16. onLoadingComplete",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16-onloadingcomplete",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \n<Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当图片加载完毕的时候，会执行该回调函数，同时占位符图片会被删除。回调函数调用的时候会传入一个参数，该参数是对底层 "," 元素的引用。"]}),"\n",(0,s.jsx)(n.p,{children:"注意：因为组件接收一个函数作为参数，需要使用客户端组件。"}),"\n",(0,s.jsxs)(n.h3,{id:"17-onload",children:["17. onLoad",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17-onload",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n  \n<Image onLoad={(e) => console.log(e.target.naturalWidth)} />\n"})}),"\n",(0,s.jsx)(n.p,{children:"同样是图片加载完的时候执行，该回调函数可能会在占位符被删除以及图片被完全解码前执行。所以如果你想等到图片完全加载完毕，使用 onLoadingComplete。"}),"\n",(0,s.jsx)(n.p,{children:"注意：因为组件接收一个函数作为参数，需要使用客户端组件。"}),"\n",(0,s.jsxs)(n.h3,{id:"18-onerror",children:["18. onError",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18-onerror",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n  \n<Image onError={(e) => console.error(e.target.id)} />\n"})}),"\n",(0,s.jsx)(n.p,{children:"图片加载失败时执行的回调函数。"}),"\n",(0,s.jsx)(n.p,{children:"注意：因为组件接收一个函数作为参数，需要使用客户端组件。"}),"\n",(0,s.jsxs)(n.h3,{id:"19-loading",children:["19. loading",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#19-loading",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"loading = 'lazy' // {lazy} | {eager}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["设置图片的加载行为，默认值为 ",(0,s.jsx)(n.code,{children:"lazy"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["当值为 ",(0,s.jsx)(n.code,{children:"lazy"})," 的时候，图片会延迟加载，直到图片接近视口。"]}),"\n",(0,s.jsxs)(n.p,{children:["当值为 ",(0,s.jsx)(n.code,{children:"eager"})," 的时候，图片会被立即加载。"]}),"\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"eager"})," 通常会损害性能。Next.js 推荐使用 ",(0,s.jsx)(n.code,{children:"priority"})," 属性代替。"]}),"\n",(0,s.jsxs)(n.h3,{id:"20-unoptimized",children:["20. unoptimized",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#20-unoptimized",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["取消优化。当值为 ",(0,s.jsx)(n.code,{children:"true"})," 的时候，使用源图片，不会更改质量、大小、格式。默认值是 ",(0,s.jsx)(n.code,{children:"false"}),"。示例如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import Image from 'next/image'\n \nconst UnoptimizedImage = (props) => {\n  return <Image {...props} unoptimized />\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["从 Next.js 12.3.0 起，可以通过 ",(0,s.jsx)(n.code,{children:"next.config.js"})," 设置所有的图片取消优化："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    unoptimized: true,\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"21-其他-props",children:["21. 其他 props",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-其他-props",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["其他传给 ",(0,s.jsx)(n.code,{children:"<Image />"})," 组件的属性都会传给底层的 img 元素。但以下属性除外："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"srcSet"}),"，Next.js 会自动生成，如果你想更改，使用配置项里的 deviceSizes，下一节会讲到。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"decoding"}),"，它的值总是 ",(0,s.jsx)(n.code,{children:'"async"'})]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"配置选项",children:["配置选项",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置选项",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["除了通过 props，你也可以在 ",(0,s.jsx)(n.code,{children:"next.config.js"})," 中配置图片组件。"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-remotepatterns",children:["1. remotePatterns",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-remotepatterns",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["为保护应用远离恶意用户，当使用外部图片的时候需要配置 ",(0,s.jsx)(n.code,{children:"remotePatterns"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/account123/**',\n      },\n    ],\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个示例的意思是，",(0,s.jsx)(n.code,{children:"next/image"})," 的 ",(0,s.jsx)(n.code,{children:"src"})," 属性的值必须是以 ",(0,s.jsx)(n.code,{children:"https://example.com/account123/"})," 为开头。其他的协议、主机名、端口或者不匹配的路径都会返回 400 错误。"]}),"\n",(0,s.jsx)(n.p,{children:"这是另外一个例子，在此例子中使用了通配符："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: '**.example.com',\n      },\n    ],\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个示例的意思是，",(0,s.jsx)(n.code,{children:"next/image"})," 的 ",(0,s.jsx)(n.code,{children:"src"})," 属性的值必须是以 ",(0,s.jsx)(n.code,{children:"https://xxx.example.com"}),"、",(0,s.jsx)(n.code,{children:"https://xxx.xxx.example.com"}),"、",(0,s.jsx)(n.code,{children:"https://xxx.xxx.xxx.example.com"}),"……开头。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"pathname"})," 和 ",(0,s.jsx)(n.code,{children:"hostname"})," 都可以使用通配符，其中："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*"})," 表示匹配单个路由段或者子域"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"**"})," 表示匹配任意数量的路由段或者子域。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["注意 ",(0,s.jsx)(n.code,{children:"**"})," 语法在模式的中间是不起作用的。"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-domains",children:["2. domains",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-domains",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["自 Next.js 14 起因为使用了更为严格的 ",(0,s.jsx)(n.code,{children:"remotePatterns"})," 而废弃。仅当所有的内容都来自你所能控制的域的时候你再使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["与 ",(0,s.jsx)(n.code,{children:"remotePatterns"})," 类似，",(0,s.jsx)(n.code,{children:"domains"})," 配置项提供了一个用于外部图片的 hostname 列表："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    domains: ['assets.acme.com'],\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["但是注意 ",(0,s.jsx)(n.code,{children:"domains"})," 不支持通配符，并且无法限制协议、端口或者路径名。所以更建议使用 ",(0,s.jsx)(n.code,{children:"remotePatterns"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-loaderfile",children:["3. loaderFile",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-loaderfile",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果你不希望使用 Next.js 内置的图片优化 API，那你可以自己配置，使用 ",(0,s.jsx)(n.code,{children:"next.config.js"})," 的 ",(0,s.jsx)(n.code,{children:"loaderFile"})," 配置项："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    loader: 'custom',\n    loaderFile: './my/image/loader.js',\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"loaderFile"})," 必须指向相对于 Next.js 应用根目录的文件。该文件必须导出一个默认函数，该函数返回一个字符串。举个例子："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \nexport default function myImageLoader({ src, width, quality }) {\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这会应用到所有的 ",(0,s.jsx)(n.code,{children:"next/image"})," 的实例，如果你要修改个别图片，使用 ",(0,s.jsx)(n.code,{children:"loader"})," prop。"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-devicesizes",children:["4. deviceSizes",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-devicesizes",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果你知道用户的设备宽度，那你可以使用 ",(0,s.jsx)(n.code,{children:"next.config.js"}),"的 ",(0,s.jsx)(n.code,{children:"deviceSizes"}),"来声明一系列的设备宽度断点。当 ",(0,s.jsx)(n.code,{children:"next/image"})," 组件使用 ",(0,s.jsx)(n.code,{children:"sizes"})," prop 的时候，这些宽度会被用来推断正确加载的图片。"]}),"\n",(0,s.jsx)(n.p,{children:"如果没有配置，默认值是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"5-imagesizes",children:["5. imageSizes",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-imagesizes",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["你可以使用 ",(0,s.jsx)(n.code,{children:"next.config.js"})," 的 ",(0,s.jsx)(n.code,{children:"imageSize"})," 属性声明一系列的图片宽度。"]}),"\n",(0,s.jsx)(n.p,{children:"如果没有配置，默认值是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"imageSize"})," 和 ",(0,s.jsx)(n.code,{children:"deviceSizes"})," 会影响图片生成最终的 ",(0,s.jsx)(n.code,{children:"srcset"})," 尺寸："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["那么问题来了，都是用来生成最终的 ",(0,s.jsx)(n.code,{children:"srcset"}),"，直接用一个数组不就好了吗？为什么非要用两个数组？"]}),"\n",(0,s.jsxs)(n.p,{children:["你可以这样理解，",(0,s.jsx)(n.code,{children:"deviceSizes"})," 用来处理大图片，",(0,s.jsx)(n.code,{children:"imageSizes"})," 用来处理小图片，而且 ",(0,s.jsx)(n.code,{children:"imageSizes"})," 只会在图片使用了 ",(0,s.jsx)(n.code,{children:"sizes"})," prop 的时候生效，比如当你这样写："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import Image from 'next/image'\nimport profilePic from './image.png'\n \nexport default function Page() {\n  return (\n    <Image\n      src={profilePic}\n      sizes=\"(max-width: 600px) 160px,\n      320px\"\n      alt=\"Picture of the author\"\n    />\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["对应生成的 ",(0,s.jsx)(n.code,{children:"srcset"})," 就包含了deviceSizes 和 imageSizes 的所有尺寸："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["当你使用了 ",(0,s.jsx)(n.code,{children:"sizes"})," prop 的时候，说明图片的宽度是小于全屏宽度的。",(0,s.jsx)(n.code,{children:"imagesSizes"})," 的中的所有值应该都小于 ",(0,s.jsx)(n.code,{children:"deviceSizes"})," 中的最小值。"]}),"\n",(0,s.jsxs)(n.h3,{id:"6-formats",children:["6. formats",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-formats",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Next.js 默认的图片优化 API 会自动通过请求中的 Accept 请求头检测浏览器支持的图片格式。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["如果 ",(0,s.jsx)(n.code,{children:"Accept"})," 匹配多个配置的格式，数组中的第一个会被首先使用。因此，数组的顺序很重要，如果没有匹配到，或者源图片为动图，图片优化 API 会自动回退到原本的图片格式。"]}),"\n",(0,s.jsx)(n.p,{children:"如果没有配置，默认值是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    formats: ['image/webp'],\n  },\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"你可以使用下面的配置开启 AVIF 格式支持："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    formats: ['image/avif', 'image/webp'],\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"7-minimumcachettl",children:["7. minimumCacheTTL",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-minimumcachettl",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["图片会根据请求动态优化并存储在 ",(0,s.jsx)(n.code,{children:"<distDir>/cache/images"}),"目录。优化后的图像文件会被用于后续请求，直到缓存过期。当匹配到过期的文件时，过期图片会立刻失效，同时图片会在后台重新优化并使用新的失效日期储存在缓存中。"]}),"\n",(0,s.jsxs)(n.p,{children:["通过读取响应头中的 ",(0,s.jsx)(n.code,{children:"x-nextjs-cache"}),"标头确定图片的缓存状态："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MISS"}),"：路径不在缓存中"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"STALE"})," ：路径缓存了但是超出了重新验证时间，它会在后台被更新"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"HIT"})," ：路径在缓存中，且未超过重新验证时间"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"过期时间可以通过两种方式定义："}),"\n",(0,s.jsxs)(n.p,{children:["一种是通过 ",(0,s.jsx)(n.code,{children:"minimumCacheTTL"}),"配置项，一种通过 ",(0,s.jsx)(n.code,{children:"Cache-Control"}),"标头，具体而言，使用",(0,s.jsx)(n.code,{children:"Cache-Control"}),"标头的 ",(0,s.jsx)(n.code,{children:"max-age"})," 字段。如果 ",(0,s.jsx)(n.code,{children:"s-maxage"}),"和 ",(0,s.jsx)(n.code,{children:"max-age"}),"都有，",(0,s.jsx)(n.code,{children:"s-maxage"}),"优先。"]}),"\n",(0,s.jsx)(n.p,{children:"两种方法如果同时设置，以较大者为准。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"minimumCacheTTL"})," 配置项用来设置缓存优化图片的过期时间，它以秒为单位。使用示例如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    minimumCacheTTL: 60,\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果你需要更改每张图片的缓存行为，你可以通过 ",(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/next-config-js/headers",target:"_blank",rel:"noopener noreferrer",children:"headers"})," 配置图片资源的 ",(0,s.jsx)(n.code,{children:"Cache-Control"}),"标头。"]}),"\n",(0,s.jsxs)(n.p,{children:["大部分时候，建议使用静态图片导入，它会自动对文件内容进行哈希处理，并使用 ",(0,s.jsx)(n.code,{children:"immutable"})," 的 ",(0,s.jsx)(n.code,{children:"Cache-Control"})," 标头。"]}),"\n",(0,s.jsxs)(n.p,{children:["目前还没有重新验证缓存的机制，所以最好将 ",(0,s.jsx)(n.code,{children:"minimumCacheTTL"})," 的值设低一点、否则你可能需要手动修改 ",(0,s.jsx)(n.code,{children:"src"})," prop 或者删除 ",(0,s.jsx)(n.code,{children:"<distDir>/cache/images"}),"以更新缓存。"]}),"\n",(0,s.jsxs)(n.h3,{id:"8-disablestaticimages",children:["8. disableStaticImages",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-disablestaticimages",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"如果图片静态导入功能跟其他插件发生冲突，你希望禁用此功能："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js \nmodule.exports = {\n  images: {\n    disableStaticImages: true,\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"9-dangerouslyallowsvg",children:["9. dangerouslyAllowSVG",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-dangerouslyallowsvg",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"默认 loader 不会优化 SVG 图片。首先，SVG 是一种矢量格式，这意味着它可以无损地调整大小。其次，SVG 具有许多与 HTML/CSS 相同的功能，如果没有适当的内容安全策略，这些功能可能会导致漏洞。"}),"\n",(0,s.jsxs)(n.p,{children:["如果你需要使用默认的图像优化 API 来提供 SVG 图像，设置 ",(0,s.jsx)(n.code,{children:"next.config.js"}),"的 ",(0,s.jsx)(n.code,{children:"dangerouslyAllowSVG"}),"值："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  images: {\n    dangerouslyAllowSVG: true,\n    contentDispositionType: 'attachment',\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next.js 强烈推荐设置 ",(0,s.jsx)(n.code,{children:"contentDispositionType"})," 强制浏览器下载图片，以及 ",(0,s.jsx)(n.code,{children:"contentSecurityPolicy"}),"阻止执行图片中嵌入的脚本。"]}),"\n",(0,s.jsxs)(n.h2,{id:"动画图像",children:["动画图像",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#动画图像",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"默认 loader 将自动跳过动态图片的优化并按原样展示。"}),"\n",(0,s.jsxs)(n.p,{children:["Next.js 会自动检测动态图片，支持 GIF、APNG 和 WebP 格式。对于特定的动态图片，如果你想显式声明跳过，使用 ",(0,s.jsx)(n.code,{children:"unoptimized"})," 属性（这样就省得 Next.js 检测判断了）。"]}),"\n",(0,s.jsxs)(n.h2,{id:"响应式图片",children:["响应式图片",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#响应式图片",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["图片默认生成的 ",(0,s.jsx)(n.code,{children:"srcset"})," 包括 ",(0,s.jsx)(n.code,{children:"1x"}),"、",(0,s.jsx)(n.code,{children:"2x"})," 图片，这是为了支持不同的设备像素比。不过有的时候，你希望渲染响应式图片，自动适配视口，这个时候，你就需要设置 ",(0,s.jsx)(n.code,{children:"sizes"})," 以及 ",(0,s.jsx)(n.code,{children:"style"}),"（或者 ",(0,s.jsx)(n.code,{children:"className"}),"）。下面这些方式都可以用来渲染响应式图片："]}),"\n",(0,s.jsxs)(n.h3,{id:"1-使用静态导入的响应式图片",children:["1. 使用静态导入的响应式图片",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-使用静态导入的响应式图片",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"如果源图片不是动态的，你可以通过静态导入创建一个响应式图片："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// components/author.js\nimport Image from 'next/image'\nimport me from '../photos/me.jpg'\n \nexport default function Author() {\n  return (\n    <Image\n      src={me}\n      alt=\"Picture of the author\"\n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }}\n    />\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-保持宽高比的响应式图片",children:["2. 保持宽高比的响应式图片",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-保持宽高比的响应式图片",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果源图片是动态或者远程 URL，你需要提供 ",(0,s.jsx)(n.code,{children:"width"})," 和 ",(0,s.jsx)(n.code,{children:"height"})," 来设置正确的响应式图片宽高比。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// components/page.js\nimport Image from 'next/image'\n \nexport default function Page({ photoUrl }) {\n  return (\n    <Image\n      src={photoUrl}\n      alt=\"Picture of the author\"\n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }}\n      width={500}\n      height={300}\n    />\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-使用-fill-属性的响应式图片",children:["3. 使用 fill 属性的响应式图片",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-使用-fill-属性的响应式图片",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果你不知道图片宽高比，那可以考虑使用 ",(0,s.jsx)(n.code,{children:"fill"})," 属性，注意设置父元素为 ",(0,s.jsx)(n.code,{children:"postion:relative"})," 当然不用这种方式。也可以使用 ",(0,s.jsx)(n.code,{children:"object-fit"})," ，具体看你想要什么样的效果："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nimport Image from 'next/image'\n \nexport default function Page({ photoUrl }) {\n  return (\n    <div style={{ position: 'relative', width: '500px', height: '300px' }}>\n      <Image\n        src={photoUrl}\n        alt=\"Picture of the author\"\n        sizes=\"500px\"\n        fill\n        style={{\n          objectFit: 'contain',\n        }}\n      />\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"4-搭配-grid-实现",children:["4. 搭配 grid 实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-搭配-grid-实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import Image from 'next/image'\nimport mountains from '../public/mountains.jpg'\n \nexport default function Fill() {\n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridGap: '8px',\n        gridTemplateColumns: 'repeat(auto-fit, minmax(400px, auto))',\n      }}\n    >\n      <div style={{ position: 'relative', height: '400px' }}>\n        <Image\n          alt=\"Mountains\"\n          src={mountains}\n          fill\n          sizes=\"(min-width: 808px) 50vw, 100vw\"\n          style={{\n            objectFit: 'cover', // cover, contain, none\n          }}\n        />\n      </div>\n      {/* And more images in the grid... */}\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"主题判断",children:["主题判断",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主题判断",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果你希望实现浅色和深色模式下显示不同的图片，你可以创建一个新组件包含两个 ",(0,s.jsx)(n.code,{children:"<Image>"})," 组件，然后通过 CSS 媒体查询显示正确的那一个："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"// omponents/theme-image.module.css\n.imgDark {\n  display: none;\n}\n \n@media (prefers-color-scheme: dark) {\n  .imgLight {\n    display: none;\n  }\n  .imgDark {\n    display: unset;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// components/theme-image.tsx\nimport styles from './theme-image.module.css'\nimport Image from 'next/image'\n \nconst ThemeImage = (props) => {\n  const { srcLight, srcDark, ...rest } = props\n \n  return (\n    <>\n      <Image {...rest} src={srcLight} className={styles.imgLight} />\n      <Image {...rest} src={srcDark} className={styles.imgDark} />\n    </>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"累计布局偏移",children:["累计布局偏移",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#累计布局偏移",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在使用 Next.js 图片组件的时候，你会发现，Next.js 要求必须有 width 和 height 属性，哪怕使用静态导入图片的方式，也只是不用自己手写这两个属性而已，Next.js 依然会为你自动添加 width 和 height，之所以这样做，就是为了防止发生布局偏移。所谓布局偏移，顾名思义，原本内容的位置突然发生偏移，多出现在加载的时候。导致布局偏移的原因有很多，图片没有尺寸是常见的一个原因，让我们看个演示视频："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"10TEOBGBqZm1SEXE7KiC.gif"})}),"\n",(0,s.jsx)(n.p,{children:"这就是没有设置图片尺寸导致的布局偏移，如果设置尺寸呢："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"38UiHViz44OWqlKFe1VC.gif"})}),"\n",(0,s.jsx)(n.p,{children:"你会发现图片在加载的时候，浏览器为图片预留了位置。"}),"\n",(0,s.jsxs)(n.p,{children:["不要小瞧布局偏移，为此专门有累计布局偏移（Cumulative Layout Shift，简称 CLS）这个 Web 性能衡量指标。这可是 Google 三大",(0,s.jsx)(n.a,{href:"https://web.dev/articles/vitals?hl=zh-cn#core_web_vitals",target:"_blank",rel:"noopener noreferrer",children:"核心网页指标"}),"之一。累计布局偏移会统计视口中可见内容的移动量以及移动的距离，综合算出一个得分。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"next/image"})," 的设计就是为了防止发生布局偏移，所以如果要调整图片大小，应该使用下面三种方式之一："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"自动静态导入"}),"\n",(0,s.jsxs)(n.li,{children:["显示声明 ",(0,s.jsx)(n.code,{children:"width"})," 和 ",(0,s.jsx)(n.code,{children:"height"})," 属性"]}),"\n",(0,s.jsx)(n.li,{children:"隐式声明，通过使用 fill 让图片填充父元素"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=IU_qq_c_lKA&feature=youtu.be",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=IU_qq_c_lKA&feature=youtu.be",target:"_blank",rel:"noopener noreferrer",children:"https://www.youtube.com/watch?v=IU_qq_c_lKA&feature=youtu.be"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://web.dev/articles/lcp?hl=zh-cn",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.a,{href:"https://web.dev/articles/lcp?hl=zh-cn",target:"_blank",rel:"noopener noreferrer",children:"https://web.dev/articles/lcp?hl=zh-cn"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://almanac.httparchive.org/en/2022/media",target:"_blank",rel:"noopener noreferrer",children:"Media | 2022 | The Web Almanac by HTTP Archive"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.zachgollwitzer.com/posts/nextjs-image-component-tutorial#option-3-probe-your-remote-images-for-their-size",target:"_blank",rel:"noopener noreferrer",children:"How to use the Next.js Image Component Effectively"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://web.dev/articles/optimize-cls#images-without-dimensions",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.a,{href:"https://web.dev/articles/optimize-cls#images-without-dimensions",target:"_blank",rel:"noopener noreferrer",children:"https://web.dev/articles/optimize-cls#images-without-dimensions"})})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/optimizing/images#image-sizing",target:"_blank",rel:"noopener noreferrer",children:"Optimizing: Images"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/components/image#minimumcachettl",target:"_blank",rel:"noopener noreferrer",children:"Components: "})}),"\n"]})]})}function P(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(N,{...e})}):N(e)}let z=P;P.__RSPRESS_PAGE_META={},P.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F21.%E7%BB%84%E4%BB%B6%E7%AF%87%20_%20Images.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"图片与 LCP",id:"图片与-lcp",depth:2},{text:"1. 图片占比",id:"1-图片占比",depth:3},{text:"2. LCP 背景",id:"2-lcp-背景",depth:3},{text:"3. LCP 概念与标准",id:"3-lcp-概念与标准",depth:3},{text:"`<Image>`",id:"image",depth:2},{text:"1. 功能特性",id:"1-功能特性",depth:3},{text:"2. 基础使用",id:"2-基础使用",depth:3},{text:"3. 支持的 props",id:"3-支持的-props",depth:3},{text:"4. src-必须",id:"4-src-必须",depth:3},{text:"5. width-必须",id:"5-width-必须",depth:3},{text:"6. height-必须",id:"6-height-必须",depth:3},{text:"7. alt",id:"7-alt",depth:3},{text:"8. loader",id:"8-loader",depth:3},{text:"9. fill",id:"9-fill",depth:3},{text:"10. sizes",id:"10-sizes",depth:3},{text:"11. quality",id:"11-quality",depth:3},{text:"12. priority",id:"12-priority",depth:3},{text:"13. placeholder",id:"13-placeholder",depth:3},{text:"14. blurDataURL",id:"14-blurdataurl",depth:3},{text:"15. style",id:"15-style",depth:3},{text:"16. onLoadingComplete",id:"16-onloadingcomplete",depth:3},{text:"17. onLoad",id:"17-onload",depth:3},{text:"18. onError",id:"18-onerror",depth:3},{text:"19. loading",id:"19-loading",depth:3},{text:"20. unoptimized",id:"20-unoptimized",depth:3},{text:"21. 其他 props",id:"21-其他-props",depth:3},{text:"配置选项",id:"配置选项",depth:2},{text:"1. remotePatterns",id:"1-remotepatterns",depth:3},{text:"2. domains",id:"2-domains",depth:3},{text:"3. loaderFile",id:"3-loaderfile",depth:3},{text:"4. deviceSizes",id:"4-devicesizes",depth:3},{text:"5. imageSizes",id:"5-imagesizes",depth:3},{text:"6. formats",id:"6-formats",depth:3},{text:"7. minimumCacheTTL",id:"7-minimumcachettl",depth:3},{text:"8. disableStaticImages",id:"8-disablestaticimages",depth:3},{text:"9. dangerouslyAllowSVG",id:"9-dangerouslyallowsvg",depth:3},{text:"动画图像",id:"动画图像",depth:2},{text:"响应式图片",id:"响应式图片",depth:2},{text:"1. 使用静态导入的响应式图片",id:"1-使用静态导入的响应式图片",depth:3},{text:"2. 保持宽高比的响应式图片",id:"2-保持宽高比的响应式图片",depth:3},{text:"3. 使用 fill 属性的响应式图片",id:"3-使用-fill-属性的响应式图片",depth:3},{text:"4. 搭配 grid 实现",id:"4-搭配-grid-实现",depth:3},{text:"主题判断",id:"主题判断",depth:2},{text:"累计布局偏移",id:"累计布局偏移",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"21.组件篇 _ Images",headingTitle:"21.组件篇 _ Images",frontmatter:{}}}}]);