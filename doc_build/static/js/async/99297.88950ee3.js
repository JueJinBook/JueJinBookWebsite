"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["99297"],{229806:function(e,n,s){s.r(n),s.d(n,{default:()=>o});var t=s(552676),r=s(740453);let i=s.p+"static/image/67c1c10cf9b9aa8a477e57748a675878.ed1f052a.webp",d=s.p+"static/image/c29d006d7c552c264530b4069d084f1a.441d7de2.webp",l=s.p+"static/image/b0294ff7738ef276a91312b63e8fc6b1.d5561825.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",h3:"h3",pre:"pre",img:"img",strong:"strong",ol:"ol",li:"li",blockquote:"blockquote",ul:"ul"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"21依赖预构建esbuild-打包功能如何被-vite-玩出花来",children:["21.依赖预构建：Esbuild 打包功能如何被 Vite 玩出花来？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21依赖预构建esbuild-打包功能如何被-vite-玩出花来",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在第七节的内容中，我们已经分析过 ",(0,t.jsx)(n.code,{children:"依赖预构建"}),"的意义以及使用，对于其底层的实现并没有作过多的介绍。而在 Vite 依赖预构建的底层实现中，大量地使用到了 Esbuild 这款构建工具，实现了比较复杂的 Esbuild 插件，同时也应用了诸多 Esbuild 使用技巧。相信在理解这部分的源码之后，你将会对 Vite 预构建以及 Esbuild 本身有更加深入的认识。"]}),"\n",(0,t.jsxs)(n.p,{children:["接下来，我就来带你揭开 ",(0,t.jsx)(n.code,{children:"Vite 预构建"}),"神秘的面纱，从核心流程到依赖扫描、依赖打包的具体实现，带你彻底理解预构建背后的技术，学习 Vite 是如何灵活运用 Esbuild，将 Esbuild 这个打包工具",(0,t.jsx)(n.code,{children:"玩出花来"}),"的。"]}),"\n",(0,t.jsxs)(n.h2,{id:"预构建核心流程",children:["预构建核心流程",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#预构建核心流程",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["关于预构建所有的实现代码都在",(0,t.jsx)(n.code,{children:"optimizeDeps"}),"函数当中，也就是在仓库源码的 ",(0,t.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/optimizer/index.ts",target:"_blank",rel:"noopener noreferrer",children:"packages/vite/src/node/optimizer/index.ts"})," 文件中，你可以对照着来学习。"]}),"\n",(0,t.jsxs)(n.h3,{id:"缓存判断",children:["缓存判断",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存判断",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["首先是预构建缓存的判断。Vite 在每次预构建之后都将一些关键信息写入到了",(0,t.jsx)(n.code,{children:"_metadata.json"}),"文件中，第二次启动项目时会通过这个文件中的 hash 值来进行缓存的判断，如果命中缓存则不会进行后续的预构建流程，代码如下所示:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// _metadata.json 文件所在的路径\nconst dataPath = path.join(cacheDir, "_metadata.json");\n// 根据当前的配置计算出哈希值\nconst mainHash = getDepHash(root, config);\nconst data: DepOptimizationMetadata = {\n  hash: mainHash,\n  browserHash: mainHash,\n  optimized: {},\n};\n// 默认走到里面的逻辑\nif (!force) {\n  let prevData: DepOptimizationMetadata | undefined;\n  try {\n    // 读取元数据\n    prevData = JSON.parse(fs.readFileSync(dataPath, "utf-8"));\n  } catch (e) {}\n  // 当前计算出的哈希值与 _metadata.json 中记录的哈希值一致，表示命中缓存，不用预构建\n  if (prevData && prevData.hash === data.hash) {\n    log("Hash is consistent. Skipping. Use --force to override.");\n    return prevData;\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["值得注意的是哈希计算的策略，即决定哪些配置和文件有可能影响预构建的结果，然后根据这些信息来生成哈希值。这部分逻辑集中在",(0,t.jsx)(n.code,{children:"getHash"}),"函数中，我把关键信息放到了注释中:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const lockfileFormats = ["package-lock.json", "yarn.lock", "pnpm-lock.yaml"];\nfunction getDepHash(root: string, config: ResolvedConfig): string {\n  // 获取 lock 文件内容\n  let content = lookupFile(root, lockfileFormats) || "";\n  // 除了 lock 文件外，还需要考虑下面的一些配置信息\n  content += JSON.stringify(\n    {\n      // 开发/生产环境\n      mode: config.mode,\n      // 项目根路径\n      root: config.root,\n      // 路径解析配置\n      resolve: config.resolve,\n      // 自定义资源类型\n      assetsInclude: config.assetsInclude,\n      // 插件\n      plugins: config.plugins.map((p) => p.name),\n      // 预构建配置\n      optimizeDeps: {\n        include: config.optimizeDeps?.include,\n        exclude: config.optimizeDeps?.exclude,\n      },\n    },\n    // 特殊处理函数和正则类型\n    (_, value) => {\n      if (typeof value === "function" || value instanceof RegExp) {\n        return value.toString();\n      }\n      return value;\n    }\n  );\n  // 最后调用 crypto 库中的 createHash 方法生成哈希\n  return createHash("sha256").update(content).digest("hex").substring(0, 8);\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"依赖扫描",children:["依赖扫描",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖扫描",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["如果没有命中缓存，则会正式地进入依赖预构建阶段。不过 Vite 不会直接进行依赖的预构建，而是在之前探测一下项目中存在哪些依赖，收集依赖列表，也就是进行",(0,t.jsx)(n.code,{children:"依赖扫描"}),"的过程。这个过程是必须的，因为 Esbuild 需要知道我们到底要打包哪些第三方依赖。关键代码如下:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"({ deps, missing } = await scanImports(config));\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在",(0,t.jsx)(n.code,{children:"scanImports"}),"方法内部主要会调用 Esbuild 提供的 ",(0,t.jsx)(n.code,{children:"build"})," 方法:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const deps: Record<string, string> = {};\n// 扫描用到的 Esbuild 插件\nconst plugin = esbuildScanPlugin(config, container, deps, missing, entries);\nawait Promise.all(\n  // 应用项目入口\n  entries.map((entry) =>\n    build({\n      absWorkingDir: process.cwd(),\n      // 注意这个参数\n      write: false,\n      entryPoints: [entry],\n      bundle: true,\n      format: "esm",\n      logLevel: "error",\n      plugins: [...plugins, plugin],\n      ...esbuildOptions,\n    })\n  )\n);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["值得注意的是，其中传入的",(0,t.jsx)(n.code,{children:"write"}),"参数被设为 false，表示产物不用写入磁盘，这就大大节省了磁盘 I/O 的时间了，也是",(0,t.jsx)(n.code,{children:"依赖扫描"}),"为什么往往比",(0,t.jsx)(n.code,{children:"依赖打包"}),"快很多的原因之一。"]}),"\n",(0,t.jsx)(n.p,{children:"接下来会输出预打包信息:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"if (!asCommand) {\n  if (!newDeps) {\n    logger.info(\n      chalk.greenBright(`Pre-bundling dependencies:\\n  ${depsString}`)\n    );\n    logger.info(\n      `(this will be run only when your dependencies or config have changed)`\n    );\n  }\n} else {\n  logger.info(chalk.greenBright(`Optimizing dependencies:\\n  ${depsString}`));\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这时候你可以明白，为什么第一次启动时会输出预构建相关的 log 信息了，其实这些信息都是通过",(0,t.jsx)(n.code,{children:"依赖扫描"}),"阶段来搜集的，而此时还并未开始真正的依赖打包过程。"]}),"\n",(0,t.jsxs)(n.p,{children:["可能你会有疑问，为什么对项目入口打包一次就收集到所有依赖信息了呢？大家可以注意到",(0,t.jsx)(n.code,{children:"esbuildScanPlugin"}),"这个函数创建 ",(0,t.jsx)(n.code,{children:"scan 插件"}),"的时候就接收到了",(0,t.jsx)(n.code,{children:"deps"}),"对象作为入参，这个对象的作用不可小觑，在 ",(0,t.jsx)(n.code,{children:"scan 插件"}),"里面就是解析各种 import 语句，最终通过它来记录依赖信息。由于解析的过程比较复杂，我们放到下一个部分具体讲解，这里你只需要知道核心的流程即可。"]}),"\n",(0,t.jsxs)(n.h3,{id:"依赖打包",children:["依赖打包",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖打包",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["收集完依赖之后，就正式地进入到",(0,t.jsx)(n.code,{children:"依赖打包"}),"的阶段了。这里也调用 Esbuild 进行打包并写入产物到磁盘中，关键代码如下:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const result = await build({\n  absWorkingDir: process.cwd(),\n  // 所有依赖的 id 数组，在插件中会转换为真实的路径\n  entryPoints: Object.keys(flatIdDeps),\n  bundle: true,\n  format: "esm",\n  target: config.build.target || undefined,\n  external: config.optimizeDeps?.exclude,\n  logLevel: "error",\n  splitting: true,\n  sourcemap: true,\n  outdir: cacheDir,\n  ignoreAnnotations: true,\n  metafile: true,\n  define,\n  plugins: [\n    ...plugins,\n    // 预构建专用的插件\n    esbuildDepPlugin(flatIdDeps, flatIdToExports, config, ssr),\n  ],\n  ...esbuildOptions,\n});\n// 打包元信息，后续会根据这份信息生成 _metadata.json\nconst meta = result.metafile!;\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"元信息写入磁盘",children:["元信息写入磁盘",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#元信息写入磁盘",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在打包过程完成之后，Vite 会拿到 Esbuild 构建的元信息，也就是上面代码中的",(0,t.jsx)(n.code,{children:"meta"}),"对象，然后将元信息保存到",(0,t.jsx)(n.code,{children:"_metadata.json"}),"文件中:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const data: DepOptimizationMetadata = {\n  hash: mainHash,\n  browserHash: mainHash,\n  optimized: {},\n};\n// 省略中间的代码\nfor (const id in deps) {\n  const entry = deps[id];\n  data.optimized[id] = {\n    file: normalizePath(path.resolve(cacheDir, flattenId(id) + ".js")),\n    src: entry,\n    // 判断是否需要转换成 ESM 格式，后面会介绍\n    needsInterop: needsInterop(\n      id,\n      idToExports[id],\n      meta.outputs,\n      cacheDirOutputPath\n    ),\n  };\n}\n// 元信息写磁盘\nwriteFile(dataPath, JSON.stringify(data, null, 2));\n'})}),"\n",(0,t.jsxs)(n.p,{children:["到这里，预构建的核心流程就梳理完了，可以看到总体的流程上面并不复杂，但实际上为了方便你理解，在",(0,t.jsx)(n.code,{children:"依赖扫描"}),"和",(0,t.jsx)(n.code,{children:"依赖打包"}),"这两个部分中，我省略了很多的细节，每个细节代表了各种复杂的处理场景，因此，在下面的篇幅中，我们就来好好地剖析一下这两部分的应用场景和实现细节。"]}),"\n",(0,t.jsxs)(n.h2,{id:"依赖扫描详细分析",children:["依赖扫描详细分析",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖扫描详细分析",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-如何获取入口",children:["1. 如何获取入口",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-如何获取入口",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["现在让我们把目光聚焦在",(0,t.jsx)(n.code,{children:"scanImports"}),"的实现上。大家可以先想一想，在进行依赖扫描之前，需要做的第一件事是什么？很显然，是找到入口文件。但入口文件可能存在于多个配置当中，比如",(0,t.jsx)(n.code,{children:"optimizeDeps.entries"}),"和",(0,t.jsx)(n.code,{children:"build.rollupOptions.input"}),"，同时需要考虑数组和对象的情况；也可能用户没有配置，需要自动探测入口文件。那么，在",(0,t.jsx)(n.code,{children:"scanImports"}),"是如何做到的呢？"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const explicitEntryPatterns = config.optimizeDeps.entries;\nconst buildInput = config.build.rollupOptions?.input;\nif (explicitEntryPatterns) {\n  // 先从 optimizeDeps.entries 寻找入口，支持 glob 语法\n  entries = await globEntries(explicitEntryPatterns, config);\n} else if (buildInput) {\n  // 其次从 build.rollupOptions.input 配置中寻找，注意需要考虑数组和对象的情况\n  const resolvePath = (p: string) => path.resolve(config.root, p);\n  if (typeof buildInput === "string") {\n    entries = [resolvePath(buildInput)];\n  } else if (Array.isArray(buildInput)) {\n    entries = buildInput.map(resolvePath);\n  } else if (isObject(buildInput)) {\n    entries = Object.values(buildInput).map(resolvePath);\n  } else {\n    throw new Error("invalid rollupOptions.input value.");\n  }\n} else {\n  // 兜底逻辑，如果用户没有进行上述配置，则自动从根目录开始寻找\n  entries = await globEntries("**/*.html", config);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["其中 ",(0,t.jsx)(n.code,{children:"globEntries"})," 方法即通过 ",(0,t.jsx)(n.code,{children:"fast-glob"})," 库来从项目根目录扫描文件。"]}),"\n",(0,t.jsxs)(n.p,{children:["接下来我们还需要考虑入口文件的类型，一般情况下入口需要是",(0,t.jsx)(n.code,{children:"js/ts"}),"文件，但实际上像 html、vue 单文件组件这种类型我们也是需要支持的，因为在这些文件中仍然可以包含 script 标签的内容，从而让我们搜集到依赖信息。"]}),"\n",(0,t.jsxs)(n.p,{children:["在源码当中，同时对 ",(0,t.jsx)(n.code,{children:"html"}),"、",(0,t.jsx)(n.code,{children:"vue"}),"、",(0,t.jsx)(n.code,{children:"svelte"}),"、",(0,t.jsx)(n.code,{children:"astro"}),"(一种新兴的类 html 语法)四种后缀的入口文件进行了解析，当然，具体的解析过程在",(0,t.jsx)(n.code,{children:"依赖扫描"}),"阶段的 Esbuild 插件中得以实现，接着就让我们在插件的实现中一探究竟。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const htmlTypesRE = /.(html|vue|svelte|astro)$/;\nfunction esbuildScanPlugin(/* 一些入参 */): Plugin {\n  // 初始化一些变量\n  // 返回一个 Esbuild 插件\n  return {\n    name: "vite:dep-scan",\n    setup(build) {\n      // 标记「类 HTML」文件的 namespace\n      build.onResolve({ filter: htmlTypesRE }, async ({ path, importer }) => {\n        return {\n          path: await resolve(path, importer),\n          namespace: "html",\n        };\n      });\n\n      build.onLoad(\n        { filter: htmlTypesRE, namespace: "html" },\n        async ({ path }) => {\n          // 解析「类 HTML」文件\n        }\n      );\n    },\n  };\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["这里来我们以",(0,t.jsx)(n.code,{children:"html"}),"文件的解析为例来讲解，原理如下图所示:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["在插件中会扫描出所有带有 ",(0,t.jsx)(n.code,{children:"type=module"})," 的 script 标签，对于含有 src 的 ",(0,t.jsx)(n.code,{children:"script"})," 改写为一个 import 语句，对于含有具体内容的 script，则抽离出其中的脚本内容，最后将所有的 script 内容拼接成一段 js 代码。接下来我们来看具体的代码，其中会以上图中的",(0,t.jsx)(n.code,{children:"html"}),"为示例来拆解中间过程:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const scriptModuleRE =\n  /(<script\\b[^>]*type\\s*=\\s*(?: module |'module')[^>]*>)(.*?)<\/script>/gims\nexport const scriptRE = /(<script\\b(?:\\s[^>]*>|>))(.*?)<\/script>/gims\nexport const commentRE = /\x3c!--(.|[\\r\\n])*?--\x3e/\nconst srcRE = /\\bsrc\\s*=\\s*(?: ([^ ]+) |'([^']+)'|([^\\s' >]+))/im\nconst typeRE = /\\btype\\s*=\\s*(?: ([^ ]+) |'([^']+)'|([^\\s' >]+))/im\nconst langRE = /\\blang\\s*=\\s*(?: ([^ ]+) |'([^']+)'|([^\\s' >]+))/im\n// scan 插件 setup 方法内部实现\nbuild.onLoad(\n  { filter: htmlTypesRE, namespace: 'html' },\n  async ({ path }) => {\n    let raw = fs.readFileSync(path, 'utf-8')\n    // 去掉注释内容，防止干扰解析过程\n    raw = raw.replace(commentRE, '\x3c!----\x3e')\n    const isHtml = path.endsWith('.html')\n    // HTML 情况下会寻找 type 为 module 的 script\n    // 正则：/(<script\\b[^>]*type\\s*=\\s*(?: module |'module')[^>]*>)(.*?)<\/script>/gims\n    const regex = isHtml ? scriptModuleRE : scriptRE\n    regex.lastIndex = 0\n    let js = ''\n    let loader: Loader = 'js'\n    let match: RegExpExecArray | null\n    // 正式开始解析\n    while ((match = regex.exec(raw))) {\n      // 第一次: openTag 为 <script type= module  src= /src/main.ts >, 无 content\n      // 第二次: openTag 为 <script type= module >，有 content\n      const [, openTag, content] = match\n      const typeMatch = openTag.match(typeRE)\n      const type =\n        typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3])\n      const langMatch = openTag.match(langRE)\n      const lang =\n        langMatch && (langMatch[1] || langMatch[2] || langMatch[3])\n      if (lang === 'ts' || lang === 'tsx' || lang === 'jsx') {\n        // 指定 esbuild 的 loader\n        loader = lang\n      }\n      const srcMatch = openTag.match(srcRE)\n      // 根据有无 src 属性来进行不同的处理\n      if (srcMatch) {\n        const src = srcMatch[1] || srcMatch[2] || srcMatch[3]\n        js += `import ${JSON.stringify(src)}\\n`\n      } else if (content.trim()) {\n        js += content + '\\n'\n      }\n  }\n  return {\n    loader,\n    contents: js\n  }\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里对源码做了一定的精简，省略了 ",(0,t.jsx)(n.code,{children:"vue"}),"/",(0,t.jsx)(n.code,{children:"svelte"})," 以及 ",(0,t.jsx)(n.code,{children:"import.meta.glob"})," 语法的处理，但不影响整体的实现思路，这里主要是让你了解即使是",(0,t.jsx)(n.code,{children:"html"}),"或者类似这种类型的文件，也是能作为 Esbuild 的预构建入口来进行解析的。"]}),"\n",(0,t.jsxs)(n.h3,{id:"2-如何记录依赖",children:["2. 如何记录依赖？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-如何记录依赖",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"入口的问题解决了，接下来还有一个问题: 如何在 Esbuild 编译的时候记录依赖呢？"}),"\n",(0,t.jsxs)(n.p,{children:["Vite 中会把 ",(0,t.jsx)(n.code,{children:"bare import"}),"的路径当做依赖路径，关于",(0,t.jsx)(n.code,{children:"bare import"}),"，你可以理解为直接引入一个包名，比如下面这样:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import React from "react";\n'})}),"\n",(0,t.jsxs)(n.p,{children:["而以",(0,t.jsx)(n.code,{children:"."}),"开头的相对路径或者以",(0,t.jsx)(n.code,{children:"/"}),"开头的绝对路径都不能算",(0,t.jsx)(n.code,{children:"bare import"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// 以下都不是 bare import\nimport React from "../node_modules/react/index.js";\nimport React from "/User/sanyuan/vite-project/node_modules/react/index.js";\n'})}),"\n",(0,t.jsxs)(n.p,{children:["对于解析 ",(0,t.jsx)(n.code,{children:"bare import"}),"、记录依赖的逻辑依然实现在 scan 插件当中:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'build.onResolve(\n  {\n    // avoid matching windows volume\n    filter: /^[\\w@][^:]/,\n  },\n  async ({ path: id, importer }) => {\n    // 如果在 optimizeDeps.exclude 列表或者已经记录过了，则将其 externalize (排除)，直接 return\n\n    // 接下来解析路径，内部调用各个插件的 resolveId 方法进行解析\n    const resolved = await resolve(id, importer);\n    if (resolved) {\n      // 判断是否应该 externalize，下个部分详细拆解\n      if (shouldExternalizeDep(resolved, id)) {\n        return externalUnlessEntry({ path: id });\n      }\n\n      if (resolved.includes("node_modules") || include?.includes(id)) {\n        // 如果 resolved 为 js 或 ts 文件\n        if (OPTIMIZABLE_ENTRY_RE.test(resolved)) {\n          // 注意了! 现在将其正式地记录在依赖表中\n          depImports[id] = resolved;\n        }\n        // 进行 externalize，因为这里只用扫描出依赖即可，不需要进行打包，具体实现后面的部分会讲到\n        return externalUnlessEntry({ path: id });\n      } else {\n        // resolved 为 「类 html」 文件，则标记上 \'html\' 的 namespace\n        const namespace = htmlTypesRE.test(resolved) ? "html" : undefined;\n        // linked package, keep crawling\n        return {\n          path: path.resolve(resolved),\n          namespace,\n        };\n      }\n    } else {\n      // 没有解析到路径，记录到 missing 表中，后续会检测这张表，显示相关路径未找到的报错\n      missing[id] = normalizePath(importer);\n    }\n  }\n);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["顺便说一句，其中调用到了",(0,t.jsx)(n.code,{children:"resolve"}),"，也就是路径解析的逻辑，这里面实际上会调用各个插件的 resolveId 方法来进行路径的解析，代码如下所示:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const resolve = async (id: string, importer?: string) => {\n  // 通过 seen 对象进行路径缓存\n  const key = id + (importer && path.dirname(importer));\n  if (seen.has(key)) {\n    return seen.get(key);\n  }\n  // 调用插件容器的 resolveId\n  // 关于插件容器下一节会详细介绍，这里你直接理解为调用各个插件的 resolveId 方法解析路径即可\n  const resolved = await container.resolveId(\n    id,\n    importer && normalizePath(importer)\n  );\n  const res = resolved?.id;\n  seen.set(key, res);\n  return res;\n};\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"3-external-的规则如何制定",children:["3. external 的规则如何制定？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-external-的规则如何制定",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["上面我们分析了在 Esbuild 插件中如何针对 ",(0,t.jsx)(n.code,{children:"bare import"})," 记录依赖，那么在记录的过程中还有一件非常重要的事情，就是决定哪些路径应该被排除，不应该被记录或者不应该被 Esbuild 来解析。这就是 ",(0,t.jsx)(n.code,{children:"external 规则"}),"的概念。"]}),"\n",(0,t.jsxs)(n.p,{children:["在这里，我把需要 external 的路径分为两类: ",(0,t.jsx)(n.strong,{children:"资源型"}),"和",(0,t.jsx)(n.strong,{children:"模块型"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"首先，对于资源型的路径，一般是直接排除，在插件中的处理方式如下:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// data url，直接标记 external: true，不让 esbuild 继续处理\nbuild.onResolve({ filter: dataUrlRE }, ({ path }) => ({\n  path,\n  external: true,\n}));\n// 加了 ?worker 或者 ?raw 这种 query 的资源路径，直接 external\nbuild.onResolve({ filter: SPECIAL_QUERY_RE }, ({ path }) => ({\n  path,\n  external: true,\n}));\n// css & json\nbuild.onResolve(\n  {\n    filter: /.(css|less|sass|scss|styl|stylus|pcss|postcss|json)$/,\n  },\n  // 非 entry 则直接标记 external\n  externalUnlessEntry\n);\n// Vite 内置的一些资源类型，比如 .png、.wasm 等等\nbuild.onResolve(\n  {\n    filter: new RegExp(`\\.(${KNOWN_ASSET_TYPES.join("|")})$`),\n  },\n  // 非 entry 则直接标记 external\n  externalUnlessEntry\n);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["其中",(0,t.jsx)(n.code,{children:"externalUnlessEntry"}),"的实现也很简单:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const externalUnlessEntry = ({ path }: { path: string }) => ({\n  path,\n  // 非 entry 则标记 external\n  external: !entries.includes(path),\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["其次，对于模块型的路径，也就是当我们通过 resolve 函数解析出了一个 JS 模块的路径，如何判断是否应该被 externalize 呢？这部分实现主要在",(0,t.jsx)(n.code,{children:"shouldExternalizeDep"})," 函数中，之前在分析",(0,t.jsx)(n.code,{children:"bare import"}),"埋了个伏笔，现在让我们看看具体的实现规则:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'export function shouldExternalizeDep(\n  resolvedId: string,\n  rawId: string\n): boolean {\n  // 解析之后不是一个绝对路径，不在 esbuild 中进行加载\n  if (!path.isAbsolute(resolvedId)) {\n    return true;\n  }\n  // 1. import 路径本身就是一个绝对路径\n  // 2. 虚拟模块(Rollup 插件中约定虚拟模块以`\\0`开头)\n  // 都不在 esbuild 中进行加载\n  if (resolvedId === rawId || resolvedId.includes("\\0")) {\n    return true;\n  }\n  // 不是 JS 或者 类 HTML 文件，不在 esbuild 中进行加载\n  if (!JS_TYPES_RE.test(resolvedId) && !htmlTypesRE.test(resolvedId)) {\n    return true;\n  }\n  return false;\n}\n'})}),"\n",(0,t.jsxs)(n.h2,{id:"依赖打包详细分析",children:["依赖打包详细分析",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖打包详细分析",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-如何达到扁平化的产物文件结构",children:["1. 如何达到扁平化的产物文件结构",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-如何达到扁平化的产物文件结构",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["一般情况下，esbuild 会输出嵌套的产物目录结构，比如对 vue 来说，其产物在",(0,t.jsx)(n.code,{children:"dist/vue.runtime.esm-bundler.js"}),"中，那么经过 esbuild 正常打包之后，预构建的产物目录如下:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"node_modules/.vite\n├── _metadata.json\n├── vue\n│   └── dist\n│       └── vue.runtime.esm-bundler.js\n"})}),"\n",(0,t.jsx)(n.p,{children:"由于各个第三方包的产物目录结构不一致，这种深层次的嵌套目录对于 Vite 路径解析来说，其实是增加了不少的麻烦的，带来了一些不可控的因素。为了解决嵌套目录带来的问题，Vite 做了两件事情来达到扁平化的预构建产物输出:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["嵌套路径扁平化，",(0,t.jsx)(n.code,{children:"/"}),"被换成下划线，如 ",(0,t.jsx)(n.code,{children:"react/jsx-dev-runtime"}),"，被重写为",(0,t.jsx)(n.code,{children:"react_jsx-dev-runtime"}),"；"]}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:"用虚拟模块来代替真实模块，作为预打包的入口，具体的实现后面会详细介绍。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["回到",(0,t.jsx)(n.code,{children:"optimizeDeps"}),"函数中，其中在进行完依赖扫描的步骤后，就会执行路径的扁平化操作:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'const flatIdDeps: Record<string, string> = {};\nconst idToExports: Record<string, ExportsData> = {};\nconst flatIdToExports: Record<string, ExportsData> = {};\n// deps 即为扫描后的依赖表\n// 形如: {\n//    react :  /Users/sanyuan/vite-project/react/index.js  }\n//    react/jsx-dev-runtime :  /Users/sanyuan/vite-project/react/jsx-dev-runtime.js\n// }\nfor (const id in deps) {\n  // 扁平化路径，`react/jsx-dev-runtime`，被重写为`react_jsx-dev-runtime`；\n  const flatId = flattenId(id);\n  // 填入 flatIdDeps 表，记录 flatId -> 真实路径的映射关系\n  const filePath = (flatIdDeps[flatId] = deps[id]);\n  const entryContent = fs.readFileSync(filePath, "utf-8");\n  // 后续代码省略\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["对于虚拟模块的处理，大家可以把目光放到 ",(0,t.jsx)(n.code,{children:"esbuildDepPlugin"})," 函数上面，它的逻辑大致如下:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"export function esbuildDepPlugin(/* 一些传参 */) {\n  // 定义路径解析的方法\n\n  // 返回 Esbuild 插件\n  return {\n    name: 'vite:dep-pre-bundle',\n    set(build) {\n      // bare import 的路径\n      build.onResolve(\n        { filter: /^[\\w@][^:]/ },\n        async ({ path: id, importer, kind }) => {\n          // 判断是否为入口模块，如果是，则标记上`dep`的 namespace，成为一个虚拟模块\n        }\n    }\n\n    build.onLoad({ filter: /.*/, namespace: 'dep' }, ({ path: id }) => {\n      // 加载虚拟模块\n    }\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"如此一来，Esbuild 会将虚拟模块作为入口来进行打包，最后的产物目录会变成下面的扁平结构:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"node_modules/.vite\n├── _metadata.json\n├── vue.js\n├── react.js\n├── react_jsx-dev-runtime.js\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["注：",(0,t.jsx)(n.strong,{children:"虚拟模块加载部分的代码"}),"在 Vite 3.0 中已被移除，原因是 Esbuild 输出扁平化产物路径已不再需要使用虚拟模块，PR 地址: ",(0,t.jsx)(n.a,{href:"https://github.com/vitejs/vite/pull/10427",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/vitejs/vite/pull/10427"})," 如下部分的小册内容你可以进行选读。"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"2-代理模块加载",children:["2. 代理模块加载",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-代理模块加载",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["虚拟模块代替了真实模块作为打包入口，因此也可以理解为",(0,t.jsx)(n.code,{children:"代理模块"}),"，后面也统一称之为",(0,t.jsx)(n.code,{children:"代理模块"}),"。我们首先来分析一下代理模块究竟是如何被加载出来的，换句话说，它到底了包含了哪些内容。"]}),"\n",(0,t.jsxs)(n.p,{children:["拿",(0,t.jsx)(n.code,{children:' import React from "react" '}),"来举例，Vite 会把",(0,t.jsx)(n.code,{children:"react"}),"标记为 ",(0,t.jsx)(n.code,{children:"namespace"})," 为 ",(0,t.jsx)(n.code,{children:"dep"})," 的虚拟模块，然后控制 Esbuild 的加载流程，对于真实模块的内容进行重新导出。"]}),"\n",(0,t.jsx)(n.p,{children:"那么第一步就是确定真实模块的路径:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// 真实模块所在的路径，拿 react 来说，即`node_modules/react/index.js`\nconst entryFile = qualified[id];\n// 确定相对路径\nlet relativePath = normalizePath(path.relative(root, entryFile));\nif (\n  !relativePath.startsWith("./") &&\n  !relativePath.startsWith("../") &&\n  relativePath !== "."\n) {\n  relativePath = `./${relativePath}`;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"确定了路径之后，接下来就是对模块的内容进行重新导出。这里会分为几种情况:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"CommonJS 模块"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"ES 模块"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"那么，如何来识别这两种模块规范呢？"}),"\n",(0,t.jsxs)(n.p,{children:["我们可以暂时把目光转移到",(0,t.jsx)(n.code,{children:"optimizeDeps"}),"中，实际上在进行真正的依赖打包之前，Vite 会读取各个依赖的入口文件，通过",(0,t.jsx)(n.code,{children:"es-module-lexer"}),"这种工具来解析入口文件的内容。这里稍微解释一下",(0,t.jsx)(n.code,{children:"es-module-lexer"}),"，这是一个在 Vite 被经常使用到的工具库，主要是为了解析 ES 导入导出的语法，大致用法如下:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import { init, parse } from \"es-module-lexer\";\n// 等待`es-module-lexer`初始化完成\nawait init;\nconst sourceStr = `\n  import moduleA from './a';\n  export * from 'b';\n  export const count = 1;\n  export default count;\n`;\n// 开始解析\nconst exportsData = parse(sourceStr);\n// 结果为一个数组，分别保存 import 和 export 的信息\nconst [imports, exports] = exportsData;\n// 返回 `import module from './a'`\nsourceStr.substring(imports[0].ss, imports[0].se);\n// 返回 ['count', 'default']\nconsole.log(exports);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["值得注意的是, ",(0,t.jsx)(n.code,{children:"export * from"})," 导出语法会被记录在 ",(0,t.jsx)(n.code,{children:"import"})," 信息中。"]}),"\n",(0,t.jsxs)(n.p,{children:["接下来我们来看看 ",(0,t.jsx)(n.code,{children:"optimizeDeps"})," 中如何利用 ",(0,t.jsx)(n.code,{children:"es-module-lexer"}),"来解析入口文件的，实现代码如下:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { init, parse } from "es-module-lexer";\n// 省略中间的代码\nawait init;\nfor (const id in deps) {\n  // 省略前面的路径扁平化逻辑\n  // 读取入口内容\n  const entryContent = fs.readFileSync(filePath, "utf-8");\n  try {\n    exportsData = parse(entryContent) as ExportsData;\n  } catch {\n    // 省略对 jsx 的处理\n  }\n  for (const { ss, se } of exportsData[0]) {\n    const exp = entryContent.slice(ss, se);\n    // 标记存在 `export * from` 语法\n    if (/export\\s+*\\s+from/.test(exp)) {\n      exportsData.hasReExports = true;\n    }\n  }\n  // 将 import 和 export 信息记录下来\n  idToExports[id] = exportsData;\n  flatIdToExports[flatId] = exportsData;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["OK，由于最后会有两张表记录下 ES 模块导入和导出的相关信息，而",(0,t.jsx)(n.code,{children:"flatIdToExports"}),"表会作为入参传给 Esbuild 插件:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// 第二个入参\nesbuildDepPlugin(flatIdDeps, flatIdToExports, config, ssr);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如此，我们就能根据真实模块的路径获取到导入和导出的信息，通过这份信息来甄别 CommonJS 和 ES 两种模块规范。现在可以回到 Esbuild 打包插件中",(0,t.jsx)(n.strong,{children:"加载代理模块"}),"的代码:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'let contents = "";\n// 下面的 exportsData 即外部传入的模块导入导出相关的信息表\n// 根据模块 id 拿到对应的导入导出信息\nconst data = exportsData[id];\nconst [imports, exports] = data;\nif (!imports.length && !exports.length) {\n  // 处理 CommonJS 模块\n} else {\n  // 处理 ES  模块\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"如果是 CommonJS 模块，则导出语句写成这种形式:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'let contents = "";\ncontents += `export default require( ${relativePath} );`;\n'})}),"\n",(0,t.jsxs)(n.p,{children:["如果是 ES 模块，则分",(0,t.jsx)(n.strong,{children:"默认导出"}),"和",(0,t.jsx)(n.strong,{children:"非默认导出"}),"这两种情况来处理:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// 默认导出，即存在 export default 语法\nif (exports.includes("default")) {\n  contents += `import d from  ${relativePath} ;export default d;`;\n}\n// 非默认导出\nif (\n  // 1. 存在 `export * from` 语法，前文分析过\n  data.hasReExports ||\n  // 2. 多个导出内容\n  exports.length > 1 ||\n  // 3. 只有一个导出内容，但这个导出不是 export default\n  exports[0] !== "default"\n) {\n  // 凡是命中上述三种情况中的一种，则添加下面的重导出语句\n  contents += `\\nexport * from  ${relativePath} `;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["现在，我们组装好了 ",(0,t.jsx)(n.code,{children:"代理模块"})," 的内容，接下来就可以放心地交给 Esbuild 加载了:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'let ext = path.extname(entryFile).slice(1);\nif (ext === "mjs") ext = "js";\nreturn {\n  loader: ext as Loader,\n  // 虚拟模块内容\n  contents,\n  resolveDir: root,\n};\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"3-代理模块为什么要和真实模块分离",children:["3. 代理模块为什么要和真实模块分离？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-代理模块为什么要和真实模块分离",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["现在，相信你已经清楚了 Vite 是如何组装代理模块，以此作为 Esbuild 打包入口的，整体的思路就是先分析一遍模块真实入口文件的",(0,t.jsx)(n.code,{children:"import"}),"和",(0,t.jsx)(n.code,{children:"export"}),"语法，然后在代理模块中进行重导出。这里不妨回过头来思考一下: 为什么要对真实文件先做语法分析，然后重导出内容呢？"]}),"\n",(0,t.jsx)(n.p,{children:"对此，大家不妨注意一下代码中的这段注释:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// It is necessary to do the re-exporting to separate the virtual proxy\n// module from the actual module since the actual module may get\n// referenced via relative imports - if we don't separate the proxy and\n// the actual module, esbuild will create duplicated copies of the same\n// module!\n"})}),"\n",(0,t.jsx)(n.p,{children:"翻译过来即:"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"这种重导出的做法是必要的，它可以分离虚拟模块和真实模块，因为真实模块可以通过相对地址来引入。如果不这么做，Esbuild 将会对打包输出两个一样的模块。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"刚开始看的确不太容易理解，接下来我会通过对比的方式来告诉你这种设计到底解决了什么问题。"}),"\n",(0,t.jsxs)(n.p,{children:["假设我不像源码中这么做，在虚拟模块中直接将",(0,t.jsx)(n.strong,{children:"真实入口的内容"}),"作为传给 Esbuild 可不可以呢？也就是像这样:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"build.onLoad({ filter: /.*/, namespace: 'dep' }, ({ path: id }) => {\n  // 拿到查表拿到真实入口模块路径\n  const entryFile = qualified[id];\n  return {\n    loader: 'js',\n    contents: fs.readFileSync(entryFile, 'utf8');\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"那么，这么实现会产生什么问题呢？我们可以先看看正常的预打包流程（以 React 为例）:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["Vite 会使用 ",(0,t.jsx)(n.code,{children:" dep:react "}),"这个代理模块来作为入口内容在 Esbuild 中进行加载，与此同时，其他库的预打包也有可能会引入 React，比如",(0,t.jsx)(n.code,{children:"@emotion/react"}),"这个库里面会有",(0,t.jsx)(n.code,{children:"require('react')"}),"的行为。那么在 Esbuild 打包之后，",(0,t.jsx)(n.code,{children:"react.js"}),"与",(0,t.jsx)(n.code,{children:"@emotion_react.js"}),"的代码中会引用同一份 Chunk 的内容，这份 Chunk 也就对应 React 入口文件(",(0,t.jsx)(n.code,{children:"node_modules/react/index.js"}),")。"]}),"\n",(0,t.jsx)(n.p,{children:"这是理想情况下的打包结果，接下来我们来看看上述有问题的版本是如何工作的:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["现在如果代理模块通过文件系统直接读取真实模块的内容，而不是进行重导出，因此由于此时代理模块跟真实模块并没有任何的引用关系，这就导致最后的",(0,t.jsx)(n.code,{children:"react.js"}),"和",(0,t.jsx)(n.code,{children:"@emotion/react.js"}),"两份产物并不会引用同一份 Chunk，Esbuild 最后打包出了内容完全相同的两个 Chunk！"]}),"\n",(0,t.jsx)(n.p,{children:"这也就能解释为什么 Vite 中要在代理模块中对真实模块的内容进行重导出了，主要是为了避免 Esbuild 产生重复的打包内容。此时，你是不是也恍然大悟了呢？"}),"\n",(0,t.jsxs)(n.h2,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["本文的正文内容到此就接近尾声了，我们终于学习完了 Esbuild 预构建的底层实现，在这一节中，我首先带你熟悉一遍预构建的核心流程，包括",(0,t.jsx)(n.strong,{children:"缓存判断"}),"、",(0,t.jsx)(n.strong,{children:"依赖扫描"}),"、",(0,t.jsx)(n.strong,{children:"依赖打包"}),"和",(0,t.jsx)(n.strong,{children:"元信息写入磁盘"}),"这四个主要的步骤，让你从宏观上对 Vite 预构建流程有了初步的认识。"]}),"\n",(0,t.jsxs)(n.p,{children:["从微观的实现层面，我带你深入分析了",(0,t.jsx)(n.code,{children:"依赖扫描"}),"的具体实现，从三个角度梳理了依赖扫描要解决的三个问题，分别是",(0,t.jsx)(n.code,{children:"如何获取入口"}),"、",(0,t.jsx)(n.code,{children:"如何记录依赖"})," 以及 ",(0,t.jsx)(n.code,{children:"如何制定 external 的规则"}),"，并且与你重点分析",(0,t.jsx)(n.code,{children:"scanImports"}),"函数的实现。接着我们继续深入到",(0,t.jsx)(n.code,{children:"依赖打包"}),"的源码实现，带你了解到 Vite 是如何通过",(0,t.jsx)(n.code,{children:"嵌套路径扁平化"})," 和",(0,t.jsx)(n.code,{children:"代理模块"}),"最终达到了扁平化的预构建产物结构，然后重点带你剖析了",(0,t.jsx)(n.code,{children:"代理模块"}),"背后的设计原因，如果不这么做会产生什么问题，让你不仅知其然，同时也知其所以然。"]}),"\n",(0,t.jsx)(n.p,{children:"相信经历过这一节的内容，你已经对 Vite 的预构建有了更加深刻的理解，也恭喜你，拿下了这一块困难而又深度的内容，我们下节再见。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}let o=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F21.%E4%BE%9D%E8%B5%96%E9%A2%84%E6%9E%84%E5%BB%BA%EF%BC%9AEsbuild%20%E6%89%93%E5%8C%85%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E8%A2%AB%20Vite%20%E7%8E%A9%E5%87%BA%E8%8A%B1%E6%9D%A5%EF%BC%9F.md"]={toc:[{text:"预构建核心流程",id:"预构建核心流程",depth:2},{text:"缓存判断",id:"缓存判断",depth:3},{text:"依赖扫描",id:"依赖扫描",depth:3},{text:"依赖打包",id:"依赖打包",depth:3},{text:"元信息写入磁盘",id:"元信息写入磁盘",depth:3},{text:"依赖扫描详细分析",id:"依赖扫描详细分析",depth:2},{text:"1. 如何获取入口",id:"1-如何获取入口",depth:3},{text:"2. 如何记录依赖？",id:"2-如何记录依赖",depth:3},{text:"3. external 的规则如何制定？",id:"3-external-的规则如何制定",depth:3},{text:"依赖打包详细分析",id:"依赖打包详细分析",depth:2},{text:"1. 如何达到扁平化的产物文件结构",id:"1-如何达到扁平化的产物文件结构",depth:3},{text:"2. 代理模块加载",id:"2-代理模块加载",depth:3},{text:"3. 代理模块为什么要和真实模块分离？",id:"3-代理模块为什么要和真实模块分离",depth:3},{text:"小结",id:"小结",depth:2}],title:"21.依赖预构建：Esbuild 打包功能如何被 Vite 玩出花来？",headingTitle:"21.依赖预构建：Esbuild 打包功能如何被 Vite 玩出花来？",frontmatter:{}}}}]);