"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["37415"],{713969:function(e,n,a){a.r(n),a.d(n,{default:()=>_});var s=a(552676),c=a(740453);let t=a.p+"static/image/a463c936eb879bc6835574215b172513.a79288fa.webp",r=a.p+"static/image/c204955a47fb40053a678108a8fe8b13.7f0b7529.webp",d=a.p+"static/image/f559c8d72eb912db0bb7fd498e552b80.57ccb551.webp",i=a.p+"static/image/c28462e198b910319522f5226da79465.c5d1920f.webp",l=a.p+"static/image/ace2d9c99231db8842f96c3e00dfc44d.841a0e2b.webp",o=a.p+"static/image/6762e0ee0985efd2e99ed794764ace47.112bf236.webp",p=a.p+"static/image/9f5db0e1319026d12a3a7af54d0fb483.ecd142f7.webp",h=a.p+"static/image/7de1113cf3afc93b4b2d849b58d76a1a.0fcd57a3.webp",j=a.p+"static/image/d5f97400cef6a7e484753f778b7df728.77188a17.webp",x=a.p+"static/image/07476538f8be165ed77c86aab2f044ca.e208e6f7.webp",b=a.p+"static/image/61a3ee89c4bb9012b9fd51ae790edcc0.b0005f3b.webp",f=a.p+"static/image/8071a101524d952b19bdffb76ac027e5.39a7cd04.webp",g=a.p+"static/image/e41f65c4839a5deb26c1550a983e8e49.c841beee.webp",u=a.p+"static/image/08855d06621840f07274a19f812b2a63.a27b48aa.webp",m=a.p+"static/image/33e81036d5670ae2388bf6eda9e21e1e.3dbe27c8.webp",y=a.p+"static/image/33a0690be008da318b1fe9cfc81d0387.3d945175.webp",k=a.p+"static/image/d27e798459075c02f21e60986fd480a2.84134073.webp",w=a.p+"static/image/17f62c383e5e85fede53e4031969755f.c9ee24bb.webp",S=a.p+"static/image/a9a6c45ef3e8b94073f89d731b2d669c.cf240b41.webp",D=a.p+"static/image/29c644573ced074e392e82056a021453.2c21ff48.webp",B=a.p+"static/image/9353e3bfa8f1069d318febd1b15d94ae.67a741aa.webp",E=a.p+"static/image/3b753f9d708b6e02f15a1aa3d6cbcc2b.115981d4.webp",I=a.p+"static/image/76a8475961f47883613cc9921f489104.cbf1be35.webp",A=a.p+"static/image/d64de943aea11fdc282fd6fc67718040.aaa5a14f.webp",v=a.p+"static/image/c4ee37470fca7525eb664caae07029e9.c3090e95.webp",N=a.p+"static/image/62d74f393365396614d7ff49be6cea21.2e4e0787.webp",C=a.p+"static/image/c12721098cebf0777f91970425bb1da3.459b2e44.webp",T=a.p+"static/image/f0b43ec61d7e4682a332921365c31744.78f342dd.webp",W=a.p+"static/image/4b1d303999e7b3d487758da7709cc51f.15015322.webp",P=a.p+"static/image/022b08d749d2695c4b5bc79752daf13e.adfa4566.webp",O=a.p+"static/image/52f5a8806359518c35ba4c999ad66fba.cffad469.webp",M=a.p+"static/image/1d9287e545f5283199cad9bb3e981435.4c55f82d.webp",U=a.p+"static/image/cf5aea12981352caf587b198e2f5b8b1.11a41f38.webp",K=a.p+"static/image/00399dc1fed63aa655d9e7fc2014f515.ac3878a7.webp";function L(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"172-用-nodejs-手写-websocket-协议",children:["172. 用 Node.js 手写 WebSocket 协议",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#172-用-nodejs-手写-websocket-协议",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"实时的双向数据通信，我们一般会用 WebSocket 来做。"}),"\n",(0,s.jsx)(n.p,{children:"HTTP 的协议格式我们很清楚，就是 header、body 这些。"}),"\n",(0,s.jsx)(n.p,{children:"那 WebSocket 的协议格式是什么样的呢？"}),"\n",(0,s.jsx)(n.p,{children:"这节我们就用 Node 来实现下 WebSocket 协议的解析。"}),"\n",(0,s.jsx)(n.p,{children:"WebSocket 严格来说和 HTTP 没什么关系，是另外一种协议格式。但是需要一次从 HTTP 到 WebSocket 的切换过程。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:K,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"切换过程详细来说是这样的："}),"\n",(0,s.jsx)(n.p,{children:"请求的时候带上这几个 header："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Connection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Key: Ia3dQjfWrAug/6qm7mTZOg==\n"})}),"\n",(0,s.jsx)(n.p,{children:"前两个很容易理解，就是升级到 websocket 协议的意思。"}),"\n",(0,s.jsx)(n.p,{children:"第三个 header 是保证安全用的一个 key。"}),"\n",(0,s.jsx)(n.p,{children:"服务端返回这样的 header："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"HTTP/1.1 101 Switching Protocols\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Accept: JkE58n3uIigYDMvC+KsBbGZsp1A=\n"})}),"\n",(0,s.jsx)(n.p,{children:"和请求 header 类似，Sec-WebSocket-Accept 是对请求带过来的 Sec-WebSocket-Key 处理之后的结果。"}),"\n",(0,s.jsx)(n.p,{children:"加入这个 header 的校验是为了确定对方一定是有 WebSocket 能力的，不然万一建立了连接对方却一直没消息，那不就白等了么。"}),"\n",(0,s.jsx)(n.p,{children:"那 Sec-WebSocket-Key 经过什么处理能得到 Sec-WebSocket-Accept 呢？"}),"\n",(0,s.jsx)(n.p,{children:"我用 node 实现了一下，是这样的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const crypto = require('crypto');\n\nfunction hashKey(key) {\n  const sha1 = crypto.createHash('sha1');\n  sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  return sha1.digest('base64');\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"也就是用客户端传过来的 key，加上一个固定的字符串，经过 sha1 加密之后，转成 base64 的结果。"}),"\n",(0,s.jsx)(n.p,{children:"这个字符串 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 是固定的，不信你搜搜看："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:U,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"随便找个有 websocket 的网站，比如知乎就有："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"过滤出 ws 类型的请求，看看这几个 header，是不是就是前面说的那些。"}),"\n",(0,s.jsx)(n.p,{children:"这个 Sec-WebSocket-Key 是 wk60yiym2FEwCAMVZE3FgQ=="}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而响应的 Sec-WebSocket-Accept 是 XRfPnS+8xl11QWZherej/dkHPHM="}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们算算看："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:W,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"是不是一毛一样！"}),"\n",(0,s.jsx)(n.p,{children:"这就是 websocket 升级协议时候的 Sec-WebSocket-Key 对应的 Sec-WebSocket-Accept 的计算过程。"}),"\n",(0,s.jsx)(n.p,{children:"这一步之后就换到 websocket 的协议了，那是一个全新的协议："}),"\n",(0,s.jsx)(n.p,{children:"勾选 message 这一栏可以看到传输的消息，可以是文本、可以是二进制："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"全新的协议？那具体是什么样的协议呢？"}),"\n",(0,s.jsx)(n.p,{children:"这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"大家习惯的 http 协议是 key:value 的 header 带个 body 的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"它是文本协议，每个 header 都是容易理解的字符。"}),"\n",(0,s.jsx)(n.p,{children:"这样好懂是好懂，但是传输占的空间太大了。"}),"\n",(0,s.jsx)(n.p,{children:"而 websocket 是二进制协议，一个字节可以用来存储很多信息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"比如协议的第一个字节，就存储了 FIN（结束标志）、opcode（内容类型是 binary 还是 text） 等信息。"}),"\n",(0,s.jsx)(n.p,{children:"第二个字节存储了 mask（是否有加密），payload（数据长度）。"}),"\n",(0,s.jsx)(n.p,{children:"仅仅两个字节，存储了多少信息呀！"}),"\n",(0,s.jsx)(n.p,{children:"这就是二进制协议比文本协议好的地方。"}),"\n",(0,s.jsx)(n.p,{children:"我们看到的 weboscket 的 message 的收发，其实底层都是拼成这样的格式。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"只是浏览器帮我们解析了这种格式的协议数据。"}),"\n",(0,s.jsx)(n.p,{children:"这就是 weboscket 的全部流程了。"}),"\n",(0,s.jsx)(n.p,{children:"其实还是挺清晰的，一个切换协议的过程，然后是二进制的 weboscket 协议的收发。"}),"\n",(0,s.jsx)(n.p,{children:"那我们就用 Node.js 自己实现一个 websocket 服务器吧！"}),"\n",(0,s.jsx)(n.p,{children:"新建个项目："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"mkdir my-websocket\n\ncd my-websocket\n\nnpm init -y\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 src/ws.js 定义个 MyWebSocket 的 class："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const { EventEmitter } = require('events');\nconst http = require('http');\n\nclass MyWebsocket extends EventEmitter {\n  constructor(options) {\n    super(options);\n\n    const server = http.createServer();\n    server.listen(options.port || 8080);\n\n    server.on('upgrade', (req, socket) => {\n      \n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"继承 EventEmitter 是为了可以用 emit 发送一些事件，外界可以通过 on 监听这个事件来处理。"}),"\n",(0,s.jsx)(n.p,{children:"我们在构造函数里创建了一个 http 服务，当 ungrade 事件发生，也就是收到了 Connection: upgrade 的 header 的时候，返回切换协议的 header。"}),"\n",(0,s.jsx)(n.p,{children:"返回的 header 前面已经见过了，就是要对 sec-websocket-key 做下处理。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:I,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"server.on('upgrade', (req, socket) => {\n  this.socket = socket;\n  socket.setKeepAlive(true);\n\n  const resHeaders = [\n    'HTTP/1.1 101 Switching Protocols',\n    'Upgrade: websocket',\n    'Connection: Upgrade',\n    'Sec-WebSocket-Accept: ' + hashKey(req.headers['sec-websocket-key']),\n    '',\n    ''\n  ].join('\\r\\n');\n  socket.write(resHeaders);\n\n  socket.on('data', (data) => {\n    console.log(data)\n  });\n  socket.on('close', (error) => {\n      this.emit('close');\n  });\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们拿到 socket，返回上面的 header，其中 key 做的处理就是前面聊过的算法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function hashKey(key) {\n  const sha1 = crypto.createHash('sha1');\n  sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  return sha1.digest('base64');\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"就这么简单，就已经完成协议切换了。"}),"\n",(0,s.jsx)(n.p,{children:"不信我们试试看。"}),"\n",(0,s.jsx)(n.p,{children:"新建 src/index.js，引入我们实现的 ws 服务器，跑起来："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const MyWebSocket = require('./ws');\nconst ws = new MyWebSocket({ port: 8080 });\n\nws.on('data', (data) => {\n  console.log('receive data:' + data);\n});\n\nws.on('close', (code, reason) => {\n  console.log('close:', code, reason);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后新建这样一个 index.html："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE HTML>\n<html>\n<body>\n    <script>\n        const ws = new WebSocket("ws://localhost:8080");\n\n        ws.onopen = function () {\n            ws.send("发送数据");\n            setTimeout(() => {\n                ws.send("发送数据2");\n            }, 3000)\n        };\n\n        ws.onmessage = function (evt) {\n            console.log(evt)\n        };\n\n        ws.onclose = function () {\n        };\n    <\/script>\n</body>\n\n</html>\n'})}),"\n",(0,s.jsx)(n.p,{children:"用浏览器的 WebSocket api 建立连接，发送消息。"}),"\n",(0,s.jsx)(n.p,{children:"起个静态服务:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx http-server . \n"})}),"\n",(0,s.jsx)(n.p,{children:"然后浏览器访问这个 html："}),"\n",(0,s.jsx)(n.p,{children:"这时打开 devtools 你就会发现协议切换成功了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这 3 个 header 还有 101 状态码都是我们返回的。"}),"\n",(0,s.jsx)(n.p,{children:"message 里也可以看到发送的消息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"再去服务端看看，也收到了这个消息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"只不过是 Buffer 的，也就是二进制的。"}),"\n",(0,s.jsx)(n.p,{children:"接下来只要按照协议格式解析这个 Buffer，并且生成响应格式的协议数据 Buffer 返回就可以收发 websocket 数据了。"}),"\n",(0,s.jsx)(n.p,{children:"这一部分还是比较麻烦的，我们一点点来看。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们需要第一个字节的后四位，也就是 opcode。"}),"\n",(0,s.jsx)(n.p,{children:"这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const byte1 = bufferData.readUInt8(0);\nlet opcode = byte1 & 0x0f; \n"})}),"\n",(0,s.jsx)(n.p,{children:"读取 8 位无符号整数的内容，也就是一个字节的内容。参数是偏移的字节，这里是 0。"}),"\n",(0,s.jsx)(n.p,{children:"通过位运算取出后四位，这就是 opcode 了。"}),"\n",(0,s.jsx)(n.p,{children:"然后再处理第二个字节："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"第一位是 mask 标志位，后 7 位是 payload 长度。"}),"\n",(0,s.jsx)(n.p,{children:"可以这样取："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const byte2 = bufferData.readUInt8(1);\nconst str2 = byte2.toString(2);\nconst MASK = str2[0];\nlet payloadLength = parseInt(str2.substring(1), 2);\n"})}),"\n",(0,s.jsx)(n.p,{children:"还是用 buffer.readUInt8 读取一个字节的内容。"}),"\n",(0,s.jsx)(n.p,{children:"先转成二进制字符串，这时第一位就是 mask，然后再截取后 7 位的子串，parseInt 成数字，这就是 payload 长度了。"}),"\n",(0,s.jsx)(n.p,{children:"这样前两个字节的协议内容就解析完了。"}),"\n",(0,s.jsx)(n.p,{children:"有同学可能问了，后面咋还有俩 payload 长度呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这是因为数据不一定有多长，可能需要 16 位存长度，可能需要 32 位。"}),"\n",(0,s.jsx)(n.p,{children:"于是 websocket 协议就规定了如果那个 7 位的内容不超过 125，那它就是 payload 长度。"}),"\n",(0,s.jsx)(n.p,{children:"如果 7 位的内容是 126，那就不用它了，用后面的 16 位的内容作为 payload 长度。"}),"\n",(0,s.jsx)(n.p,{children:"如果 7 位的内容是 127，也不用它了，用后面那个 64 位的内容作为 payload 长度。"}),"\n",(0,s.jsx)(n.p,{children:"其实还是容易理解的，就是 3 个 if else。"}),"\n",(0,s.jsx)(n.p,{children:"用代码写出来就是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let payloadLength = parseInt(str2.substring(1), 2);\n\nlet curByteIndex = 2;\n\nif (payloadLength === 126) {\n  payloadLength = bufferData.readUInt16BE(2);\n  curByteIndex += 2;\n} else if (payloadLength === 127) {\n  payloadLength = bufferData.readBigUInt64BE(2);\n  curByteIndex += 8;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里的 curByteIndex 是存储当前处理到第几个字节的。"}),"\n",(0,s.jsx)(n.p,{children:"如果是 126，那就从第 3 个字节开始，读取 2 个字节也就是 16 位的长度，用 buffer.readUInt16BE 方法。"}),"\n",(0,s.jsx)(n.p,{children:"如果是 127，那就从第 3 个字节开始，读取 8 个字节也就是 64 位的长度，用 buffer.readBigUInt64BE 方法。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样就拿到了 payload 的长度，然后再用这个长度去截取内容就好了。"}),"\n",(0,s.jsx)(n.p,{children:"但在读取数据之前，还有个 mask 要处理，这个是用来给内容解密的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"读 4 个字节，就是 mask key。"}),"\n",(0,s.jsx)(n.p,{children:"再后面的就可以根据 payload 长度读出来。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let realData = null;\n\nif (MASK) {\n  const maskKey = bufferData.slice(curByteIndex, curByteIndex + 4);  \n  curByteIndex += 4;\n  const payloadData = bufferData.slice(curByteIndex, curByteIndex + payloadLength);\n  realData = handleMask(maskKey, payloadData);\n} else {\n  realData = bufferData.slice(curByteIndex, curByteIndex + payloadLength);;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后用 mask key 来解密数据。"}),"\n",(0,s.jsx)(n.p,{children:"这个算法也是固定的，用每个字节的 mask key 和数据的每一位做按位异或就好了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function handleMask(maskBytes, data) {\n  const payload = Buffer.alloc(data.length);\n  for (let i = 0; i < data.length; i++) {\n    payload[i] = maskBytes[i % 4] ^ data[i];\n  }\n  return payload;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样，我们就拿到了最终的数据！"}),"\n",(0,s.jsx)(n.p,{children:"但是传给处理程序之前，还要根据类型来处理下，因为内容分几种类型，也就是 opcode 有几种值："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const OPCODES = {\n  CONTINUE: 0,\n  TEXT: 1, // 文本\n  BINARY: 2, // 二进制\n  CLOSE: 8,\n  PING: 9,\n  PONG: 10,\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们只处理文本和二进制就好了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"handleRealData(opcode, realDataBuffer) {\n    switch (opcode) {\n      case OPCODES.TEXT:\n        this.emit('data', realDataBuffer.toString('utf8'));\n        break;\n      case OPCODES.BINARY:\n        this.emit('data', realDataBuffer);\n        break;\n      default:\n        this.emit('close');\n        break;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"文本就转成 utf-8 的字符串，二进制数据就直接用 buffer 的数据。"}),"\n",(0,s.jsx)(n.p,{children:"这样，处理程序里就能拿到解析后的数据。"}),"\n",(0,s.jsx)(n.p,{children:"我们来试一下："}),"\n",(0,s.jsx)(n.p,{children:"之前我们已经能拿到 weboscket 协议内容的 buffer 了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而现在我们能正确解析出其中的数据："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"至此，我们 websocket 协议的解析成功了！"}),"\n",(0,s.jsx)(n.p,{children:"这样的协议格式的数据叫做 frame，也就是帧："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"解析可以了，接下来我们再实现数据的发送。"}),"\n",(0,s.jsx)(n.p,{children:"发送也是构造一样的 frame 格式。"}),"\n",(0,s.jsx)(n.p,{children:"定义这样一个 send 方法："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"send(data) {\n    let opcode;\n    let buffer;\n    if (Buffer.isBuffer(data)) {\n      opcode = OPCODES.BINARY;\n      buffer = data;\n    } else if (typeof data === 'string') {\n      opcode = OPCODES.TEXT;\n      buffer = Buffer.from(data, 'utf8');\n    } else {\n      console.error('暂不支持发送的数据类型')\n    }\n    this.doSend(opcode, buffer);\n}\n\ndoSend(opcode, bufferDatafer) {\n   this.socket.write(encodeMessage(opcode, bufferDatafer));\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"根据发送的是文本还是二进制数据来对内容作处理。"}),"\n",(0,s.jsx)(n.p,{children:"然后构造 websocket 的 frame："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function encodeMessage(opcode, payload) {\n  //payload.length < 126\n  let bufferData = Buffer.alloc(payload.length + 2 + 0);;\n  \n  let byte1 = parseInt('10000000', 2) | opcode; // 设置 FIN 为 1\n  let byte2 = payload.length;\n\n  bufferData.writeUInt8(byte1, 0);\n  bufferData.writeUInt8(byte2, 1);\n\n  payload.copy(bufferData, 2);\n  \n  return bufferData;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们只处理数据长度小于 125 的情况。"}),"\n",(0,s.jsx)(n.p,{children:"第一个字节是 opcode，我们把第一位置 1 ，通过按位或的方式。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"服务端给客户端回消息不需要 mask，所以第二个字节就是 payload 长度。"}),"\n",(0,s.jsx)(n.p,{children:"分别把这前两个字节的数据写到 buffer 里，指定不同的 offset："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"bufferData.writeUInt8(byte1, 0);\nbufferData.writeUInt8(byte2, 1);\n"})}),"\n",(0,s.jsx)(n.p,{children:"之后把 payload 数据放在后面："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:" payload.copy(bufferData, 2);\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样一个 websocket 的 frame 就构造完了。"}),"\n",(0,s.jsx)(n.p,{children:"我们试一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"收到客户端消息后，每两秒回一个消息。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"收发消息都成功了！"}),"\n",(0,s.jsx)(n.p,{children:"就这样，我们自己实现了一个 websocket 服务器，实现了 websocket 协议的解析和生成！"}),"\n",(0,s.jsx)(n.p,{children:"完整代码如下："}),"\n",(0,s.jsx)(n.p,{children:"MyWebSocket:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"//ws.js\nconst { EventEmitter } = require('events');\nconst http = require('http');\nconst crypto = require('crypto');\n\nfunction hashKey(key) {\n  const sha1 = crypto.createHash('sha1');\n  sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  return sha1.digest('base64');\n}\n\nfunction handleMask(maskBytes, data) {\n  const payload = Buffer.alloc(data.length);\n  for (let i = 0; i < data.length; i++) {\n    payload[i] = maskBytes[i % 4] ^ data[i];\n  }\n  return payload;\n}\n\nconst OPCODES = {\n  CONTINUE: 0,\n  TEXT: 1,\n  BINARY: 2,\n  CLOSE: 8,\n  PING: 9,\n  PONG: 10,\n};\n\nfunction encodeMessage(opcode, payload) {\n  //payload.length < 126\n  let bufferData = Buffer.alloc(payload.length + 2 + 0);;\n  \n  let byte1 = parseInt('10000000', 2) | opcode; // 设置 FIN 为 1\n  let byte2 = payload.length;\n\n  bufferData.writeUInt8(byte1, 0);\n  bufferData.writeUInt8(byte2, 1);\n\n  payload.copy(bufferData, 2);\n  \n  return bufferData;\n}\n\nclass MyWebsocket extends EventEmitter {\n  constructor(options) {\n    super(options);\n\n    const server = http.createServer();\n    server.listen(options.port || 8080);\n\n    server.on('upgrade', (req, socket) => {\n      this.socket = socket;\n      socket.setKeepAlive(true);\n\n      const resHeaders = [\n        'HTTP/1.1 101 Switching Protocols',\n        'Upgrade: websocket',\n        'Connection: Upgrade',\n        'Sec-WebSocket-Accept: ' + hashKey(req.headers['sec-websocket-key']),\n        '',\n        ''\n      ].join('\\r\\n');\n      socket.write(resHeaders);\n\n      socket.on('data', (data) => {\n        this.processData(data);\n        // console.log(data);\n      });\n      socket.on('close', (error) => {\n          this.emit('close');\n      });\n    });\n  }\n\n  handleRealData(opcode, realDataBuffer) {\n    switch (opcode) {\n      case OPCODES.TEXT:\n        this.emit('data', realDataBuffer.toString('utf8'));\n        break;\n      case OPCODES.BINARY:\n        this.emit('data', realDataBuffer);\n        break;\n      default:\n        this.emit('close');\n        break;\n    }\n  }\n\n  processData(bufferData) {\n    const byte1 = bufferData.readUInt8(0);\n    let opcode = byte1 & 0x0f; \n    \n    const byte2 = bufferData.readUInt8(1);\n    const str2 = byte2.toString(2);\n    const MASK = str2[0];\n\n    let curByteIndex = 2;\n    \n    let payloadLength = parseInt(str2.substring(1), 2);\n    if (payloadLength === 126) {\n      payloadLength = bufferData.readUInt16BE(2);\n      curByteIndex += 2;\n    } else if (payloadLength === 127) {\n      payloadLength = bufferData.readBigUInt64BE(2);\n      curByteIndex += 8;\n    }\n\n    let realData = null;\n    \n    if (MASK) {\n      const maskKey = bufferData.slice(curByteIndex, curByteIndex + 4);  \n      curByteIndex += 4;\n      const payloadData = bufferData.slice(curByteIndex, curByteIndex + payloadLength);\n      realData = handleMask(maskKey, payloadData);\n    } \n    \n    this.handleRealData(opcode, realData);\n  }\n\n  send(data) {\n    let opcode;\n    let buffer;\n    if (Buffer.isBuffer(data)) {\n      opcode = OPCODES.BINARY;\n      buffer = data;\n    } else if (typeof data === 'string') {\n      opcode = OPCODES.TEXT;\n      buffer = Buffer.from(data, 'utf8');\n    } else {\n      console.error('暂不支持发送的数据类型')\n    }\n    this.doSend(opcode, buffer);\n  }\n\n  doSend(opcode, bufferDatafer) {\n    this.socket.write(encodeMessage(opcode, bufferDatafer));\n  }\n}\n\nmodule.exports = MyWebsocket;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Index："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const MyWebSocket = require('./ws');\nconst ws = new MyWebSocket({ port: 8080 });\n\nws.on('data', (data) => {\n  console.log('receive data:' + data);\n  setInterval(() => {\n    ws.send(data + ' ' + Date.now());\n  }, 2000)\n});\n\nws.on('close', (code, reason) => {\n  console.log('close:', code, reason);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"html:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE HTML>\n<html>\n<body>\n    <script>\n        const ws = new WebSocket("ws://localhost:8080");\n\n        ws.onopen = function () {\n            ws.send("发送数据");\n            setTimeout(() => {\n                ws.send("发送数据2");\n            }, 3000)\n        };\n\n        ws.onmessage = function (evt) {\n            console.log(evt)\n        };\n\n        ws.onclose = function () {\n        };\n    <\/script>\n</body>\n\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["案例代码在",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/my-websocket",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"实时性较高的需求，我们会用 websocket 实现，比如即时通讯、游戏等场景。"}),"\n",(0,s.jsx)(n.p,{children:"websocket 和 http 没什么关系，但从 http 到 websocket 需要一次切换的过程。"}),"\n",(0,s.jsx)(n.p,{children:"这个切换过程除了要带 upgrade 的 header 外，还要带 sec-websocket-key，服务端根据这个 key 算出结果，通过 sec-websocket-accept 返回。响应是 101 Switching Protocols 的状态码。"}),"\n",(0,s.jsx)(n.p,{children:"这个计算过程比较固定，就是 key + 固定的字符串 通过 sha1 加密后再 base64 的结果。"}),"\n",(0,s.jsx)(n.p,{children:"加这个机制是为了确保对方一定是 websocket 服务器，而不是随意返回了个 101 状态码。"}),"\n",(0,s.jsx)(n.p,{children:"之后就是 websocket 协议了，这是个二进制协议，我们根据格式完成了 websocket 帧的解析和生成。"}),"\n",(0,s.jsx)(n.p,{children:"这样就是一个完整的 websocket 协议的实现了。"}),"\n",(0,s.jsx)(n.p,{children:"我们自己手写了一个 websocket 服务，有没有感觉对 websocket 的理解更深了呢？"})]})}function H(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(L,{...e})}):L(e)}let _=H;H.__RSPRESS_PAGE_META={},H.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F172.%20%E7%94%A8%20Node.js%20%E6%89%8B%E5%86%99%20WebSocket%20%E5%8D%8F%E8%AE%AE.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"172. 用 Node.js 手写 WebSocket 协议",headingTitle:"172. 用 Node.js 手写 WebSocket 协议",frontmatter:{}}}}]);