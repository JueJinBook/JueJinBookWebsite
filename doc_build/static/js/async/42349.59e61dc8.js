"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["42349"],{98328:function(e,n,r){r.r(n),r.d(n,{default:()=>b});var s=r(552676),i=r(740453);let t=r.p+"static/image/3ed298ce1369c192aadd788263c7fab5.22158261.webp",d=r.p+"static/image/1285c63acc7ba7f8269440c50a322812.c153c539.webp",c=r.p+"static/image/d6cbed8706ed7aee42c304bbe060e78d.75c38675.webp",a=r.p+"static/image/f0e92abfc9c483dd3f55a6b0a66c82e7.f1dca01c.webp",l=r.p+"static/image/8547bfb4a9e3f45ff1d1a8316bddaa02.3a5bb0c8.webp",p=r.p+"static/image/7ef5f0173e05c3f8c40861f553270683.1ace751a.webp",h=r.p+"static/image/ddbe1fbe41519de30d6e667bcba06de0.560398a7.webp",x=r.p+"static/image/5f7be68df8ca4962f143dabb59828c40.d16e679e.webp",j=r.p+"static/image/13e87d7b8b54eb1265ddce620672808d.58f1299e.webp",m=r.p+"static/image/f405191d3060348056649aee3945bc75.e0d019b5.webp",o=r.p+"static/image/8728e28048630d63c649215980138176.a10d29fb.webp",u=r.p+"static/image/a73f9339b07cf1510c77c55c72b8d244.18b640a2.webp",y=r.p+"static/image/9d10a470ff305ee245c1fc5926e80200.ecbe131f.webp";function g(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",h3:"h3",pre:"pre",code:"code",ul:"ul",li:"li",strong:"strong"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"21加餐1类型系统导出组件库的类型定义",children:["21.加餐1：类型系统：导出组件库的类型定义",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21加餐1类型系统导出组件库的类型定义",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"随着前端技术日趋复杂化，越来越多的项目都会选择使用TypeScript语言。TypeScript语言最显著的特点是提供了类型系统的支持。 类型系统有助于增加大型项目的可维护性。利用类型检查机制在编译期阶段可以发现更多的错误。从开发理论上讲，越早发现错误，解决错误的成本就会越低。这样的话就会使编写效率明显提高。这样的话也就可以更早下班，陪家人。"}),"\n",(0,s.jsx)(n.p,{children:"当然使用Typescript也不是只有好处。最大的问题是需要付出相应的学习成本，和多余的工作量用于定义类型系统。，因为对于使用Typescript 多了一套类型定义的心智负担。简单的类型还没什么也许只是给变量设置 string 或 number。其实也不跟你没什么卵用。"}),"\n",(0,s.jsx)(n.p,{children:"复杂的类型系统包含复杂的类型推导，泛型等内容，以下是 Vue 源码中 ractive 的返回对象。给大家一个截图大家可以感受一下。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"很多小伙伴都在过度迷恋强类型语言，其实大可不必。弱类型语言晚于强类型语言出现的。也就是说弱类型语言是强类型语言的进化版。就是为了增加开发效率才会引入弱类型。我的观点是，对于业务逻辑型开发并不太适合使用Typescript。"}),"\n",(0,s.jsx)(n.p,{children:"实际上，未必使用Typescript编写逻辑才能体现类型检查机制的好处。即使你使用 Javascript 语言开发，使用可 Typescript 编写的库也可以同样享受类型的收益。连接两者的的桥梁就是类型定义文件 d.ts。好了下面就到我们这节课的主题了为组件库添加类型定义。"}),"\n",(0,s.jsxs)(n.h2,{id:"前置知识",children:["前置知识",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前置知识",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"类型定义文件的作用",children:["类型定义文件的作用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型定义文件的作用",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"下面我们用一个简单的例子来演示类型定义的作用。"}),"\n",(0,s.jsx)(n.p,{children:"创建一个文件 utils.ts"}),"\n",(0,s.jsx)(n.p,{children:"首先使用 Typescript 创建一个函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function add(a: number, b: number): number {\n \xa0 \xa0return a + b\n}\n​\ninterface Person {\n \xa0 \xa0name: string,\n \xa0 \xa0age?: number\n}\n​\nexport { add, Person }\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果在 index.ts 引用这个库，可以得到明确的类型提示。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"import { Person, add } from './utils'\n​\nconst a: Person = {\n \xa0 \xa0name: 'abc'\n}\n​\nadd(1, 2)\n"})}),"\n",(0,s.jsx)(n.p,{children:"并且可以正常的进行类型检查的。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"但是如果将 utils.ts 编译为 utils.js 文件。这个时候类型定义就会丢失。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"那调用的时候自然也不会有类型检查。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"可以看到调用 add 方法的时候，类型是 any。"}),"\n",(0,s.jsx)(n.p,{children:"如果想要保留类型定义，就需要生成类型定义文件，将类型保留到类型定义文件中 d.ts。这个时候编辑器就可以依据类型定义文件进行类型检查了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"utils.ts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"declare function add(a: number, b: number): number;\ninterface Person {\n \xa0 \xa0name: string;\n \xa0 \xa0age?: number;\n}\nexport { add, Person };\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个时候，在使用index.js的时候就可以看到类型定义了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"最后的结论，就是想得到类型定义的恩惠，未必一定要使用Typescript作为开发语言。比如： 使用 Javascript 语言开发，只要使用了Typescript 开发的库，一样可以享受到类型系统提示和检查。"}),"\n",(0,s.jsxs)(n.h3,{id:"typescript导出类型定义",children:["Typescript导出类型定义",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#typescript导出类型定义",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"一个标准的 Typescript 项目导出类型定义，只需要在 tsconfig.json 中添加declaration 选项就可以实现。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"这个时候使用 tsc 编译的时候就可以导出类型定义。"}),"\n",(0,s.jsxs)(n.h2,{id:"用户故事userstory",children:["用户故事(UserStory)",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用户故事userstory",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"为组件库添加类型定义，使组件具备类型提示功能"}),"\n",(0,s.jsxs)(n.h2,{id:"任务分解task",children:["任务分解(Task)",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#任务分解task",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"配置 vite-plugin-dts 插件"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"生成软件包的类型定义入口"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"注册全局组件"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"编写模版脚本"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"测试类型系统"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"配置vite-plugin-dts插件",children:["配置vite-plugin-dts插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置vite-plugin-dts插件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"想让组件库具有类型定义，第一步必须要将组件库源码中的类型定义导出。虽然可以使用 tsc 导出类型定义。但是组件涉及 .vue 文件。所以需要 vite-plugin-dts 插件来完成。"}),"\n",(0,s.jsx)(n.p,{children:"在 vite.config.ts 中增加插件"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'pnpm i vite-plugin-dts\nimport dts from "vite-plugin-dts";\nexport const config = {\n  plugins: [\n \xa0  // ...\n \xa0  dts({\n \xa0 \xa0  outputDir: "./dist/types",\n \xa0 \xa0  insertTypesEntry: false, // 插入TS 入口\n \xa0 \xa0  copyDtsFiles: true, // 是否将源码里的 .d.ts 文件复制到 outputDir\n \xa0  }),\n  ],\n  }\n'})}),"\n",(0,s.jsx)(n.p,{children:"这里面有三个配置"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"outputDir： 是为了设置类型定义的位置"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"insertTypesEntry： 这个选项是为了生成入口，由于默认入口还不能完全满足要求所以选择 false。不接受导出。 后续会通过自定义脚本生成。"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"copyDtsFiles： 目的是可以自动复制源码中的类型定义，这个需要有。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"增加插件定义后，重新执行build后的效果"}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"pnpm build\n"})}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)("img",{src:h,alt:"img"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"定义类型定义入口",children:["定义类型定义入口",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定义类型定义入口",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"类型定义入口文件是靠编写编译脚本实现的。如何编写这个脚本在后面介绍。现在大家先弄清生成后的样子。对于一个软件包来讲，类型定义文件的位置通过 package.json 的 types 属性确定。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"入口文件 smarty-ui.d.ts 其实就是引用了 entry.d.ts 。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"export * from './types/entry'\nimport SmartyUI from './types/entry'\nexport default SmartyUI\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"注册全局组件",children:["注册全局组件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#注册全局组件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"什么是注册全局组件呢。举一个例子，在 Typescript 中一切变量都不能凭空捏造。比如在 node 全局作用域中需要某个全局变量的存在，也需要在全局作用域中注册。这样 Typescript 才认为他是合法的。对于组件库的组件，本来在全局进行注册，依然需要一个类型定义的声明。这样才可以，在 vue 文件中使用的时候可以找到对应的类型定义。这个声明的意思大概就是在所有的 vue 文件中存在某些全局组件。"}),"\n",(0,s.jsx)(n.p,{children:"以组件库为例，其中的 SButton 需要在 vue 文件中使用， 就需要注册为全局组件。实际上组件库中的所有组件都需要注册为全局组件。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"具体写法为"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"这段描述，需要增加到类型定义中。"}),"\n",(0,s.jsx)(n.p,{children:"综合考虑前面需要生成类型入口，从实现上考虑这段代码比较适合写在入口文件中。这样便于脚本的编写。"}),"\n",(0,s.jsxs)(n.h3,{id:"编写模版脚本",children:["编写模版脚本",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编写模版脚本",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上面搞清了类型定义的格式，就需要编写一个脚本自动生成这部分代码。这部分代码主要围绕着入口文件的生成展开，其实就是利用模版来生成代码，方法和 CLI 工具章节中的模版生成代码方法一致这里就不赘述。"}),"\n",(0,s.jsx)(n.p,{children:"第一步，要实现声明全局组件。"}),"\n",(0,s.jsx)(n.p,{children:"首先需要获取全局组件的列表。这个功能可以通过对 entry.ts 的反射遍历完成。"}),"\n",(0,s.jsx)(n.p,{children:"type.ts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"/**\n * 获取组件列表\n * 通过解析entry.ts模块获取组件数据\n */\nasync function getComponents(input) {\n \xa0 \xa0const entry = await import(input)\n \xa0 \xa0return Object.keys(entry)\n \xa0 \xa0 \xa0  .filter(k => k !== 'default')\n \xa0 \xa0 \xa0  .map(k => ({\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0name: entry[k].name,\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0component: k\n \xa0 \xa0 \xa0  }))\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后是编写一个入口代码模板，这个模版主要是需要遍历组件列表生成全局组件接口。"}),"\n",(0,s.jsx)(n.p,{children:"entry.d.ts.hbs"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"export * from './types/entry'\nimport SmartyUI from './types/entry'\nexport default SmartyUI\n​\ndeclare module 'vue' {\n \xa0  export interface GlobalComponents {\n \xa0 \xa0 \xa0  {{#each components}}\n \xa0 \xa0 \xa0 \xa0 \xa0  {{name}}: typeof import(\"./types/entry\").{{component}},\n \xa0 \xa0 \xa0  {{/each}}\n \xa0  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"下一步是编写脚本生成类型定义文件。"}),"\n",(0,s.jsx)(n.p,{children:"type.ts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"/**\n * 生成类型定义文件 d.ts\n * @param components \n */\nexport async function generateDTS(entryPath) {\n​\n \xa0 \xa0const template = resolve(__dirname, './entry.d.ts.hbs')\n \xa0 \xa0const dts = resolve(__dirname, entryPath.replace('.esm.js', '.d.ts'))\n​\n \xa0 \xa0// 组件库数据\n \xa0 \xa0const components = await getComponents(entryPath)\n \xa0 \xa0// console.log('list', list)\n​\n \xa0 \xa0// 生成模版\n \xa0 \xa0generateCode({\n \xa0 \xa0 \xa0 \xa0components\n \xa0  }, dts, template)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后把完成的入口生成函数加入到 build.ts 文件中。顺便增加入口的位置定义。"}),"\n",(0,s.jsx)(n.p,{children:"build.ts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// ...\n packageJson.types = "smarty-ui.d.ts";\n// ...\n \xa0// 生成配置DTS配置文件入口\n \xa0generateDTS(path.resolve(config.build.outDir, `smarty-ui.esm.js`),)\n'})}),"\n",(0,s.jsx)(n.p,{children:"最后的效果"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"img"})}),"\n",(0,s.jsxs)(n.h2,{id:"测试类型提示",children:["测试类型提示",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试类型提示",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Typescript的类型提示支持VsCode原生。但是如果让 Vue 单文件也得到类型提示，就需要安装相应的插件。比如使用的 Volar 插件。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"这个插件目前我测试的结果仅支持 TS版本的Vue项目。这个大家一定要注意。"})," 这是插件的限制并不是 Typescript 类型系统的限制。实际上是完全有可能实现 JS 项目中也具备 Vue 文件的类型提示。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"img"})}),"\n",(0,s.jsx)(n.p,{children:"首先需要把新版本发布上线。"}),"\n",(0,s.jsx)(n.p,{children:"然后可以使用前面章节创建的 create-smarty 创建一个模版项目。当然这里面还需要升级模版项目引用最新版的 smary-ui-vite。这些过程就不再赘述。"}),"\n",(0,s.jsx)(n.p,{children:"这时候在新创建的项目中就可以看到类型提示了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"img"})}),"\n",(0,s.jsxs)(n.h2,{id:"复盘",children:["复盘",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#复盘",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节课我们主要讲了如何给组件库添加类型定义。类型定义可以在使用组件库的时候获得类型提示。提高使用者的开发体验。从而充分的享受 Typescript 类型系统带来的恩惠。"}),"\n",(0,s.jsx)(n.p,{children:"当然这个章节还有遗憾，就是现有版本只能支持对全量组件引入的类型提示。并不支持在分包下的类型提示。这个地方然叔就留给读者去考虑一下如何去实现。实际上原理是一致的，难点在于如何合理用脚本实现。也欢迎同学们将这个答案 PR 到咱们的项目中。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/smarty-team/smarty-admin",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/smarty-team/smarty-admin"})}),"\n",(0,s.jsx)(n.p,{children:"最后留一些思考题帮助大家复习，也欢迎在留言区讨论。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"类型定义文件的作用 ？"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如何确定软件包 package 中的类型定义入口？"}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}let b=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Vite%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E6%88%98%2F21.%E5%8A%A0%E9%A4%901%EF%BC%9A%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%AF%BC%E5%87%BA%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89.md"]={toc:[{text:"前置知识",id:"前置知识",depth:2},{text:"类型定义文件的作用",id:"类型定义文件的作用",depth:3},{text:"Typescript导出类型定义",id:"typescript导出类型定义",depth:3},{text:"用户故事(UserStory)",id:"用户故事userstory",depth:2},{text:"任务分解(Task)",id:"任务分解task",depth:2},{text:"配置vite-plugin-dts插件",id:"配置vite-plugin-dts插件",depth:3},{text:"定义类型定义入口",id:"定义类型定义入口",depth:3},{text:"注册全局组件",id:"注册全局组件",depth:3},{text:"编写模版脚本",id:"编写模版脚本",depth:3},{text:"测试类型提示",id:"测试类型提示",depth:2},{text:"复盘",id:"复盘",depth:2}],title:"21.加餐1：类型系统：导出组件库的类型定义",headingTitle:"21.加餐1：类型系统：导出组件库的类型定义",frontmatter:{}}}}]);