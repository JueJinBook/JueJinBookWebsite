"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["31172"],{515963:function(n,e,s){s.r(e),s.d(e,{default:()=>l});var r=s(552676),i=s(740453);function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",blockquote:"blockquote",h3:"h3",pre:"pre",code:"code",ul:"ul",li:"li",ol:"ol"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"第14章贪心的后果并发及解决方案",children:["第14章—贪心的后果：并发及解决方案",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第14章贪心的后果并发及解决方案",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["\uFEFF在上一章中，我们提到",(0,r.jsx)(e.strong,{children:"资源冲突的充要条件是同一时刻、同一目标"}),"。资源冲突是并发引起的问题，要破坏资源冲突，就要干掉同一时刻、同一目标这两个条件之一即可。那么我们就来看看到底怎么破坏这对儿活宝。"]}),"\n",(0,r.jsxs)(e.h2,{id:"解决并发的基本操作",children:["解决并发的基本操作",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解决并发的基本操作",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"要解决并发引起的资源冲突，核心就是破坏同一时刻或同一目标。"}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"破坏同一时间",children:["破坏同一时间",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#破坏同一时间",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["破坏同一时间的核心就是",(0,r.jsx)(e.strong,{children:"排队"}),"。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"假设我们有如下代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"class A {\n    int a = 0;\n    // 开启一个线程不断增加a的值\n    Thread t1 = new Thread() {\n        void run(){\n            for(int i =0; i< 1000_000_000; i++) a++;\n        }\n    };\n    t1.start();\n    \n    // 开启另一个线程不断增加a的值\n    Thread t2 = new Thread() {\n        void run() {\n            for(int i =0; i< 1000_000_000; i++) a++;\n        }\n    };\n    t2.start();\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"简单，执行完之后 a 等于 2000_000_000。"}),"\n",(0,r.jsx)(e.p,{children:"错！你可以试试，大概率不是 2000_000_000。"}),"\n",(0,r.jsxs)(e.p,{children:["这是为啥呢？因为这是两条执行流在同时跑，假设我们只执行了",(0,r.jsx)(e.code,{children:"a++"}),"，那么流程如下："]}),"\n",(0,r.jsx)(e.p,{children:"我们看到，两个线程几乎同时把 a 读如自己的缓存中，然后去执行加法，如下："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Thread1 把 a 读入自己的缓存中，此时 a=0。"}),"\n",(0,r.jsx)(e.li,{children:"Thread2 把 a 读如自己的缓存中，此时 a=0。"}),"\n",(0,r.jsx)(e.li,{children:"Thread1 执行 a++，此时 a=1。"}),"\n",(0,r.jsx)(e.li,{children:"Thread2 执行 a++，此时 a=1。"}),"\n",(0,r.jsx)(e.li,{children:"Thread1 把 a 写回主内存，此时 a=1。"}),"\n",(0,r.jsx)(e.li,{children:"Thread2 把 a 写回主内存，此时 a=1。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["于是就会导致两个线程都执行了一轮",(0,r.jsx)(e.code,{children:"a++"}),"之后，a 从 0 变成了 1，而不是 2。"]}),"\n",(0,r.jsx)(e.p,{children:"这怎么办呢？"}),"\n",(0,r.jsxs)(e.p,{children:["我们可以给 a ",(0,r.jsx)(e.code,{children:"加锁"}),"，也就是说：在 a 被一个线程读取后，就加个锁，如果被写回来，就释放锁，其他线程过来了之后发现有锁，就等着，这就会导致",(0,r.jsx)(e.strong,{children:"同时只能有一个线程使用 a"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["就像酒店的宾馆，有人住的话就得到钥匙，并且锁门，这样别人就进不来了；离开再交还钥匙，这样下一个人就能住了。这就是",(0,r.jsx)(e.strong,{children:"排队"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"我们也给线程安排上这个逻辑，排队后的流程如下："}),"\n",(0,r.jsx)(e.p,{children:"我们看到，排队之后，线程是按照顺序来操作 a 了。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Thread1 把 a 读入自己的内存中，并获取锁，此时 a=0。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Thread2 去读 a，发现被锁了，就等着。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Thread1 对 a 进行自增，此时 a=1。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Thread1 用完 a 了，把它写回主内存，并释放锁，然后通知其他线程你们可以用了，此时 a=1。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"Thread2 知道自己可以用了，赶紧上号，就从内存中读入 a，并获取锁，此时 a=1。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"后续的使用流程就跟 Thread1 一样了。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["可以看到，加了锁之后，我们原来的",(0,r.jsx)(e.strong,{children:"并行（多个线程一起执行）"}),"，变成了",(0,r.jsx)(e.strong,{children:"串行（线程排队执行）了"}),"。串行就破坏了同一时间这个条件。"]}),"\n",(0,r.jsx)(e.p,{children:"那么，怎么破坏同一目标的呢？"}),"\n",(0,r.jsxs)(e.h3,{id:"破坏同一目标",children:["破坏同一目标",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#破坏同一目标",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["破坏同一目标的核心就是",(0,r.jsx)(e.strong,{children:"分散目标"}),"，但前提是目标能被拆分。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"那么，上述的例子能破坏同一目标吗？不能，因为 a 已经是一个数字了，没法再拆分了。"}),"\n",(0,r.jsx)(e.p,{children:"我们看个例子："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'List list = new List();\n\nThread t1 = new Thread() {\n    void run() {\n        // 我读读读\n        list.forEach {it->\n            println(it);        \n        }\n    }\n\n}\n\nThread t2 = new Thread() {\n    void run() {\n        // 我写写写\n        for(int i = 0; i< 1000_000;i++) {\n            println(list.add("yyds"));\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"俩线程同时操作一个顺序表，t1 不断地读，t2 不断地写，这就会导致问题了，可能本来集合是空。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"t1：哦空的啊，哈哈哈，那我就做做样子，美滋滋。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"t2：与此同时我要开始搞事情，我开始写。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"t1：？？？咋一下这么多数据了。要加钱！"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"这就出现问题了，因为 t1 看到的跟预期不符。"}),"\n",(0,r.jsx)(e.p,{children:"那怎么办呢？嗯，集合啊，可以分离啊，那就分离目标，我们可以这样：t2 每次在写数据的时候，都不直接对 list 写，而是把 list 复制一份，写到复印件里去，写完了再把它同步到 list。如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'Thread t2 = new Thread() {\n    void run() {\n        // 我写写写\n        \n        // 创建个复印件\n        List newList = new List();\n        newList.addAll(list);\n        \n        // 对复印件操作\n        for(int i = 0; i< 1000_000;i++) {\n            println(newList.add("yyds"));\n        }\n        \n        // 同步到list\n        list.clear;\n        list.addAll(newList);\n    }\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"都看懂了吧？看不懂的话仔细看注释。"}),"\n",(0,r.jsxs)(e.p,{children:["为啥要这么干呢？这样可以把目标分离，写的时候针对的是 newList，而不是原来的 list，这样别的线程在读的时候还是原来的 list，也就是",(0,r.jsx)(e.strong,{children:"读和写的不是同一个目标，这就是目标分离"}),"。这样读写操作即使同时执行，也不会互相影响。"]}),"\n",(0,r.jsxs)(e.p,{children:["这种做法叫做：",(0,r.jsx)(e.strong,{children:"写时拷贝（copy on write）"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"有人说，为啥不读时拷贝呢？劳资就要读时拷贝。"}),"\n",(0,r.jsx)(e.p,{children:"不行，你忘了我们上一章说的吗：竞争冲突发生的前提是对冲突资源发生了操作，操作就是：增删改。而读，它不是操作，它是访问。"}),"\n",(0,r.jsx)(e.p,{children:"假如你对读操作加了，那么两个线程一起写呢？不是照样出问题吗？"}),"\n",(0,r.jsxs)(e.p,{children:["所以，我们要理解核心：同时操作！操作！操作！针对引起问题的动作进行处理，也就是针对",(0,r.jsx)(e.strong,{children:"操作这个动作"}),"进行处理。"]}),"\n",(0,r.jsxs)(e.p,{children:["再比如：哈希表，经过",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196590693987385384",target:"_blank",rel:"noopener noreferrer",children:"第 12 章节"}),"，我们知道哈希表是",(0,r.jsx)(e.strong,{children:"链表数组"}),"。存储的元素要先找下标。"]}),"\n",(0,r.jsx)(e.p,{children:"如果两个线程同时 put 元素的时候，下标不同，是不是就能同时 put 呢？"}),"\n",(0,r.jsxs)(e.p,{children:["对！所以，我们可以给哈希表",(0,r.jsx)(e.strong,{children:"分段"}),"，每次 put 元素的时候，如果是同一段，就等待；如果是不同的段，就可以直接 put。"]}),"\n",(0,r.jsx)(e.p,{children:"比如，线程 1 来 put，计算到下标是 4，那就直接 put。同时线程 2 也来 put，计算到下标是 5，也直接 put。同时线程 3 也来 put，计算到下标是 4，就看线程 1 是否 put 完了，没完就等着，完了自己再 put，依此类推。"}),"\n",(0,r.jsxs)(e.p,{children:["其实，分段思想，也是分离目标，将一个大段分为不同的小段，就等于把一个大目标拆分，我们上面的写时复制是复制了一份，而分段则是把自己拆分为几份，不过，核心思想都是：",(0,r.jsx)(e.strong,{children:"目标分离"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsxs)(e.strong,{children:["目标分离是一种思想，而",(0,r.jsx)(e.code,{children:"写时拷贝"}),"和",(0,r.jsx)(e.code,{children:"分段"}),"都是实现这个思想的手段，我们要掌握本质，也就是要理解目标分离这个思想"]}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"我们来看下，基于这个思想衍生出来的工具。"}),"\n",(0,r.jsxs)(e.h2,{id:"处理并发冲突的工具",children:["处理并发冲突的工具",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#处理并发冲突的工具",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"并发的处理免不了要等待操作，那么，就有两种情况："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"我等着，你好了叫我；"}),"\n",(0,r.jsx)(e.li,{children:"我等着，每隔一段时间再来看看你搞完了吗。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["第一种情况：你好了叫我，明显就是可能你要很久，劳资不等了，所以就是",(0,r.jsx)(e.strong,{children:"假设你要等很长时间"}),"，这是带有悲观色彩的，我们就叫它 ",(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"悲观处理"})}),"；第二种情况：我等一会儿再来看看，明显就是可能你很快就完了，也就是",(0,r.jsx)(e.strong,{children:"只等很短时间"}),"，这就是带有乐观色彩的，我们就叫它 ",(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"乐观处理"})}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"嗯，听口气也大概猜到是这个意思了。"}),"\n",(0,r.jsxs)(e.h3,{id:"悲观处理",children:["悲观处理",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#悲观处理",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["凡是可能要等很久的都是悲观处理，我们以此可以发明一个",(0,r.jsx)(e.strong,{children:"悲观锁"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"悲观锁的核心就是等待，被唤醒"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"也就是说，我可能要等很久，那就算了，我不等了，你完事了跟我说下吧。"}),"\n",(0,r.jsxs)(e.p,{children:["那么，我们以此发明的悲观锁就叫 ",(0,r.jsx)(e.strong,{children:"synchronized"}),"，大部分语言都有这个关键字，前缀",(0,r.jsx)(e.code,{children:"sync"}),"也表示同步的意思，相反的，",(0,r.jsx)(e.code,{children:"async"}),"就表示异步。"]}),"\n",(0,r.jsxs)(e.p,{children:["比如，上面的",(0,r.jsx)(e.code,{children:"a++"}),"例子，第二种排队的图示我们都看懂了，那么对应的代码呢？"]}),"\n",(0,r.jsx)(e.p,{children:"就如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"class A {\n    int a = 0;\n    // 开启一个线程不断增加a的值\n    Thread t1 = new Thread() {\n        // 加了synchronized关键字\n        synchronized void run(){\n            for(int i =0; i< 1000_000_000; i++) a++;\n        }\n    };\n    t1.start();\n    \n    // 开启另一个线程不断增加a的值\n    Thread t2 = new Thread() {\n        // 加了synchronized关键字\n        synchronized void run() {\n            for(int i =0; i< 1000_000_000; i++) a++;\n        }\n    };\n    t2.start();\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["很简单，直接在函数上加上",(0,r.jsx)(e.code,{children:"synchronized"}),"关键字就行了，就默认等于对当前对象（this）进行加锁。线程每次调用方法都要获取 this 这个锁，获取到就执行，获取不到就等着；函数执行完了就会默认释放 this 这个锁。"]}),"\n",(0,r.jsxs)(e.p,{children:["那么，集合呢？比如上面的",(0,r.jsx)(e.code,{children:"list"}),"，是不是也这样就行了？"]}),"\n",(0,r.jsxs)(e.p,{children:["对！不过，有的语言已经自己对集合做了特殊处理了，比如",(0,r.jsx)(e.code,{children:"Java"}),"的",(0,r.jsx)(e.code,{children:"SynchronizedList"}),"，自己在内部已经对",(0,r.jsx)(e.code,{children:"add()"}),"、",(0,r.jsx)(e.code,{children:"remove()"}),"等函数进行了加锁操作，大概如下："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"class SynchronizedList {\n    // 我自己加了，外面就别费事了\n    synchronized void add(int num) {\n    }\n    \n    // 我自己加了，外面别费事了\n    synchronized void remove() {\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这就是简单粗暴的设计思路。"}),"\n",(0,r.jsx)(e.p,{children:"有人说，我都懂了，这个是需要排队，然后等别人执行完，来叫我一声就行。"}),"\n",(0,r.jsx)(e.p,{children:"对，正是这样！"}),"\n",(0,r.jsx)(e.p,{children:"那么，它先叫我吗？还是说谁排在前面就叫谁？"}),"\n",(0,r.jsxs)(e.p,{children:["随机的！完全随机！不是排在前面的就先叫，所以也叫：",(0,r.jsx)(e.strong,{children:"非公平锁"}),"！"]}),"\n",(0,r.jsx)(e.p,{children:"啥！不公平？不干了！"}),"\n",(0,r.jsx)(e.p,{children:"别激动别激动，这是有道理的。这样随机唤醒，就等价于后面的每个线程的机会都是均等的，不会出现那种黄牛线程，自己往死里排队，结果后面的都得不到执行。"}),"\n",(0,r.jsx)(e.p,{children:"没问题的话，我们就接着来看下乐观处理的方式。"}),"\n",(0,r.jsxs)(e.h3,{id:"乐观处理",children:["乐观处理",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#乐观处理",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["凡是可能等很少时间的都是乐观处理，我们可以以此发明一个",(0,r.jsx)(e.strong,{children:"乐观锁"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"乐观锁的核心就是自旋"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["大家都知道大名顶顶的 ",(0,r.jsx)(e.strong,{children:"CAS"}),"，这就是个乐观锁。"]}),"\n",(0,r.jsx)(e.p,{children:"乐观锁因为只要等很少时间，所以，与其我回家等着，倒不如我在这看着，过一段时间就来问问，反正也没多久。"}),"\n",(0,r.jsxs)(e.p,{children:["这种过一段时间就来看看的叫做",(0,r.jsx)(e.strong,{children:"轮询"}),"，过一段时间来问问中的“一段时间”我干啥呢？我原地转圈玩，反正不闲着，这就叫做",(0,r.jsx)(e.strong,{children:"自旋"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["所以，我们可以发明一种",(0,r.jsx)(e.strong,{children:"自旋锁"}),"，自旋锁就是乐观锁的一种。"]}),"\n",(0,r.jsxs)(e.p,{children:["比如，还是上面的",(0,r.jsx)(e.code,{children:"a++"}),"的例子，我们改成自旋的："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"class A {\n    int a = 0;\n    \n    boolean lock = false;\n    \n    // 开启一个线程不断增加a的值\n    Thread t1 = new Thread() {\n        // 加了synchronized关键字\n        void run() {\n            // 发现被锁了，就死循环自己转圈玩\n            while(lock) {\n                // 大风车吱呀吱哟哟地转\n            }\n            // 哦，终于拿到锁了，搞起!\n            lock = true; // 自己拿到锁了，标记一下\n            for(int i =0; i< 1000_000_000; i++) a++;\n            lock = false; // 自己执行完了，释放锁\n        }\n    };\n    t1.start();\n    \n    // 开启另一个线程不断增加a的值\n    Thread t2 = new Thread() {\n        // 加了synchronized关键字\n        void run() {\n            // 发现被锁了，就死循环自己转圈玩\n            while(lock) {\n                // 大风车吱呀吱哟哟地转\n            }\n            // 哦，终于拿到锁了，搞起!\n            lock = true;\n            for(int i =0; i< 1000_000_000; i++) a++;\n            lock = false;\n        }\n    };\n    t2.start();\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"很简单，就开个死循环，不断检测着玩，一旦死循环结束，说明拿到锁了，就干自己该干的。"}),"\n",(0,r.jsxs)(e.p,{children:["有人说，这好费劲啊，一直在",(0,r.jsx)(e.code,{children:"while(true)"}),"，CPU 就得一直工作，费电啊。"]}),"\n",(0,r.jsxs)(e.p,{children:["对！确实费电，所以它的使用条件是",(0,r.jsx)(e.strong,{children:"等的时间短"}),"，如果等的时间很长，那么就是悲观的，就不要用乐观锁了。"]}),"\n",(0,r.jsxs)(e.p,{children:["还有，我们可以改造我们的锁，每次都间隔一段时间再去访问，换句话说就是：在",(0,r.jsx)(e.code,{children:"while(true)"}),"里面让线程休眠一段时间，如果好几次都获取不到锁，那就增加时间，比如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"int len = 0\nwhile(true) {\n    sleep((len++)*200);\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这样就会依次休眠 200ms、400ms、600ms……这就叫做",(0,r.jsx)(e.strong,{children:"自适应自旋"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["当然，很多语言中都给我们提供了现成的工具，比如很多语言中都有",(0,r.jsx)(e.code,{children:"CAS"}),"这个关键字，代码中敲一下就提示出来了，我们可以选择性使用。"]}),"\n",(0,r.jsx)(e.p,{children:"总之，大家要根据具体的场合去选择合适的锁。"}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本章给大家讲解了并发中冲突的处理方式：",(0,r.jsx)(e.strong,{children:"破坏同时性或破坏同一目标"}),"。只需要破坏一个条件即可。我们可以概括为",(0,r.jsx)(e.code,{children:"一个思想、两个策略"}),"。"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"一个思想：在遇到问题时，列出问题发生的充分必要条件，只要破坏一个条件就能解决问题。比如，本章的并发。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["策略 1：当我等待一个资源的时候，如果资源迟迟不到位，那么我就告诉资源持有者，等资源到位的时候，通知我一下，这样可以不浪费我的时间，但是可能不及时，我们可以称之为：",(0,r.jsx)(e.strong,{children:"被动型通知"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["策略 2：当我等待一个资源的时候，如果资源迟迟不到位，那么我就在这等着，这样可能比较浪费时间，但是比较及时，我们称之为：",(0,r.jsx)(e.strong,{children:"主动型获取"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"大思想是我们必须掌握的，小策略则各有优缺点，需要我们根据具体情况去选择。"}),"\n",(0,r.jsx)(e.p,{children:"好，那么，下一章，我们就来看下：计算机是怎么使用这种策略来调度我们的线程的。"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}let l=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC14%E7%AB%A0%E2%80%94%E8%B4%AA%E5%BF%83%E7%9A%84%E5%90%8E%E6%9E%9C%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.md"]={toc:[{text:"解决并发的基本操作",id:"解决并发的基本操作",depth:2},{text:"破坏同一时间",id:"破坏同一时间",depth:3},{text:"破坏同一目标",id:"破坏同一目标",depth:3},{text:"处理并发冲突的工具",id:"处理并发冲突的工具",depth:2},{text:"悲观处理",id:"悲观处理",depth:3},{text:"乐观处理",id:"乐观处理",depth:3},{text:"总结",id:"总结",depth:2}],title:"第14章—贪心的后果：并发及解决方案",headingTitle:"第14章—贪心的后果：并发及解决方案",frontmatter:{}}}}]);