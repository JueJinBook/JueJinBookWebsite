"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["97913"],{918953:function(e,n,i){i.r(n),i.d(n,{default:()=>h});var s=i(552676),r=i(740453);let c=i.p+"static/image/4f400f4639d591e05abde5b86cc6bcd4.80170bee.webp",l=i.p+"static/image/2e249a637691e1ea446b9655aa09f9d0.db326573.webp",o=i.p+"static/image/48c5bd11ab05049c32e420e63c334767.ebf635f7.webp",d=i.p+"static/image/d2ada76496ea8cce1c129b82a5156e3c.da1a05dd.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",blockquote:"blockquote",strong:"strong",ol:"ol",li:"li",ul:"ul",img:"img"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"21插件开发基础实例剖析插件基本形态与架构逻辑",children:["21.插件开发基础：实例剖析插件基本形态与架构逻辑",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21插件开发基础实例剖析插件基本形态与架构逻辑",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Webpack 对外提供了 Loader 与 Plugin 两种扩展方式，其中 Loader 职责比较单一，开发方法比较简单容易理解；Plugin 则功能强大，借助 Webpack 数量庞大的 Hook，我们几乎能改写 Webpack 所有特性，但也伴随着巨大的开发复杂度。"}),"\n",(0,s.jsx)(n.p,{children:"学习如何开发 Webpack 插件并不是一件简单的事情，所以我打算用 3 个连续的章节，力求足够全面地剖析如何开发一款成熟、稳定的插件。本文将聚焦在插件代码形态、插件架构、Hook 与上下文参数等内容，同时深入剖析若干常用插件的实现原理，帮你构建起关于 Webpack 插件开发的基本认知。"}),"\n",(0,s.jsxs)(n.h2,{id:"插件简介",children:["插件简介",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插件简介",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["从形态上看，插件通常是一个带有 ",(0,s.jsx)(n.code,{children:"apply"})," 函数的类，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class SomePlugin {\n    apply(compiler) {\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 在启动时会调用插件对象的 ",(0,s.jsx)(n.code,{children:"apply"})," 函数，并以参数方式传递核心对象 ",(0,s.jsx)(n.code,{children:"compiler"})," ，以此为起点，插件内可以注册 ",(0,s.jsx)(n.code,{children:"compiler"})," 对象及其子对象的钩子(",(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/plugins/",target:"_blank",rel:"noopener noreferrer",children:"Hook"}),")回调，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'class SomePlugin {\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap("SomePlugin", (compilation) => {\n      compilation.addModule(/* ... */);\n    });\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["示例中的 ",(0,s.jsx)(n.code,{children:"compiler"})," 为 Hook 挂载的对象；",(0,s.jsx)(n.code,{children:"thisCompilation"})," 为 Hook 名称；后面调用的 ",(0,s.jsx)(n.code,{children:"tap"})," 为调用方式，支持 ",(0,s.jsx)(n.code,{children:"tap/tapAsync/tapPromise"})," 等，后面章节会展开细讲。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 Webpack 运行过程中，随着构建流程的推进会触发各个钩子回调，并传入上下文参数(例如上例回调函数中的 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象)，插件可以通过调用上下文接口、修改上下文状态等方式「篡改」构建逻辑，从而将扩展代码「勾入」到 Webpack 构建流程中。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：网上不少资料将 Webpack 的插件架构归类为“事件/订阅”模式，我认为这种归纳有失偏颇。订阅模式是一种",(0,s.jsx)(n.strong,{children:"松散耦合结构"}),"，发布器只是在特定时机发布事件消息，订阅者并不或者很少与事件源直接发生交互。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"基于 Hook 这一设计，开发插件时我们需要重点关注两个问题："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"针对插件需求，我们应该使用什么钩子？"}),"\n",(0,s.jsx)(n.li,{children:"选定钩子后，我怎么跟上下文参数交互？"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"什么时候会触发什么钩子："}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Webpack5 暴露了多达 200+ 个 Hook，基本上覆盖了整个构建流程的所有环节 —— 这也就意味着通过编写插件，我们几乎可以改写 Webpack 的所有执行逻辑。问题是，我们在什么情况下该用什么钩子？这就需要了解 Webpack 内部几个核心对象，以及各对象下 Hook 的触发时机，例如："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/compiler-hooks/",target:"_blank",rel:"noopener noreferrer",children:"Compiler"}),"：全局构建管理器，Webpack 启动后会首先创建 ",(0,s.jsx)(n.code,{children:"compiler"})," 对象，负责管理配置信息、Loader、Plugin 等。从启动构建到结束，",(0,s.jsx)(n.code,{children:"compiler"})," 大致上会触发如下钩子："]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/compilation-hooks/",target:"_blank",rel:"noopener noreferrer",children:"Compilation"}),"：单次构建过程的管理器，负责遍历模块，执行编译操作；当 ",(0,s.jsx)(n.code,{children:"watch = true"})," 时，每次文件变更触发重新编译，都会创建一个新的 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象；",(0,s.jsx)(n.code,{children:"compilation"})," 生命周期中主要触发如下钩子："]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["此外，还有 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/normalmodulefactory-hooks/",target:"_blank",rel:"noopener noreferrer",children:"Module"}),"、Resolver、",(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/parser/",target:"_blank",rel:"noopener noreferrer",children:"Parser"}),"、Generator 等关键类型，也都相应暴露了许多 Hook。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"由此可见，Webpack Hook 与构建流程强相关，使用时你结合上面流程图分析 Hook 对应的流程环节，以及这个环节主要完成了什么工作，可以借助 Hook 做出哪些修改，等等。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"使用 Hook 上下文接口："}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Webpack Hook 有两个重点，一是上面介绍的触发时机；二是触发时传递的上下文参数。例如："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compiler.hooks.compilation"})," ：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["时机：Webpack 刚启动完，创建出 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象后触发；"]}),"\n",(0,s.jsxs)(n.li,{children:["参数：当前编译的 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compiler.hooks.make"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"时机：正式开始构建时触发；"}),"\n",(0,s.jsxs)(n.li,{children:["参数：同样是当前编译的 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compilation.hooks.optimizeChunks"})," ：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["时机： ",(0,s.jsx)(n.code,{children:"seal"})," 函数中，",(0,s.jsx)(n.code,{children:"chunk"})," 集合构建完毕后触发；"]}),"\n",(0,s.jsxs)(n.li,{children:["参数：",(0,s.jsx)(n.code,{children:"chunks"})," 集合与 ",(0,s.jsx)(n.code,{children:"chunkGroups"})," 集合。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compiler.hooks.done"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"时机：编译完成后触发；"}),"\n",(0,s.jsxs)(n.li,{children:["参数： ",(0,s.jsx)(n.code,{children:"stats"})," 对象，包含编译过程中的各类统计信息。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"每个钩子传递的上下文参数不同，但主要包含如下几种类型(以 Webpack5 为例)："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js",target:"_blank",rel:"noopener noreferrer",children:"complation"})," 对象：构建管理器，使用率非常高，主要提供了一系列与单次构建相关的接口，包括：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"addModule"}),"：用于添加模块，例如 Module 遍历出依赖之后，就会调用该接口将新模块添加到构建需求中；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"addEntry"}),"：添加新的入口模块，效果与直接定义 ",(0,s.jsx)(n.code,{children:"entry"})," 配置相似；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"emitAsset"}),"：用于添加产物文件，效果与 Loader Context 的 ",(0,s.jsx)(n.code,{children:"emitAsset"})," 相同；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getDependencyReference"}),"：从给定模块返回对依赖项的引用，常用于计算模块引用关系；"]}),"\n",(0,s.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compiler.js",target:"_blank",rel:"noopener noreferrer",children:"compiler"})," 对象：全局构建管理器，提供如下接口：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"createChildCompiler"}),"：创建子 ",(0,s.jsx)(n.code,{children:"compiler"})," 对象，子对象将继承原始 Compiler 对象的所有配置数据；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"createCompilation"}),"：创建 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象，可以借此实现并行编译；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"close"}),"：结束编译；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getCache"}),"：获取缓存接口，可借此复用 Webpack5 的缓存功能；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getInfrastructureLogger"}),"：获取",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/other-options/#infrastructurelogging",target:"_blank",rel:"noopener noreferrer",children:"日志对象"}),"；"]}),"\n",(0,s.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/NormalModule.js",target:"_blank",rel:"noopener noreferrer",children:"module"})," 对象：资源模块，有诸如 ",(0,s.jsx)(n.code,{children:"NormalModule/RawModule/ContextModule"})," 等子类型，其中 ",(0,s.jsx)(n.code,{children:"NormalModule"})," 使用频率较高，提供如下接口：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"identifier"}),"：读取模块的唯一标识符；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getCurrentLoader"}),"：获取当前正在执行的 Loader 对象；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"originalSource"}),"：读取模块原始内容；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"serialize/deserialize"}),"：模块序列化与反序列化函数，用于实现持久化缓存，一般不需要调用；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"issuer"}),"：模块的引用者；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isEntryModule"}),"：用于判断该模块是否为入口文件；"]}),"\n",(0,s.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Chunk.js",target:"_blank",rel:"noopener noreferrer",children:"chunk"})," 对象：模块封装容器，提供如下接口：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"addModule"}),"：添加模块，之后该模块会与 Chunk 中其它模块一起打包，生成最终产物；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"removeModule"}),"：删除模块；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"containsModule"}),"：判断是否包含某个特定模块；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"size"}),"：推断最终构建出的产物大小；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hasRuntime"}),"：判断 Chunk 中是否包含运行时代码；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"updateHash"}),"：计算 Hash 值。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/stats/",target:"_blank",rel:"noopener noreferrer",children:"stats"})," 对象：构建过程收集到的统计信息，包括模块构建耗时、模块依赖关系、产物文件列表等。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"提示：无论官网还是社区，我都没有找到完整介绍这些对象的，足够好、足够完备的文档，且 Webpack 本身还在不断升级迭代，许多内部对象的接口并不稳定，建议读者使用时直接翻阅相关版本源码。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"篇幅关系，我们只对部分重要接口做了简单介绍，后面我还会讲解各种常用插件源码，展开介绍部分常见接口的使用方法。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"小结"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["总结一下，Webpack 的插件体系与平常所见的 ",(0,s.jsx)(n.code,{children:"订阅/发布"})," 模式差别很大，是一种非常强耦合的设计，Hook 回调由 Webpack 决定何时，以何种方式执行；而在 Hook 回调内部可以通过调用上下文 API 、修改上下文状态等方式，对 Webpack 原定流程产生 Side Effect。"]}),"\n",(0,s.jsx)(n.p,{children:"所以想熟练编写插件，需要深入理解常见 Hook 调用时机，以及各类上下文参数的用法，这方面没有太多学习资料，我建议直接翻阅相关开源插件源码，下面我会抽几个比较经典、逻辑简单、容易理解的插件，剖析如何灵活使用 Hook。"}),"\n",(0,s.jsxs)(n.h2,{id:"实例剖析imagemin-webpack-plugin",children:["实例剖析：",(0,s.jsx)(n.code,{children:"imagemin-webpack-plugin"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例剖析imagemin-webpack-plugin",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"学习如何遍历、修改最终产物文件"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github1s.com/Klathmon/imagemin-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"imagemin-webpack-plugin"})," 是一个用于实现图像压缩的插件，它会在 Webpack 完成前置的代码分析构建，提交(",(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/compiler-hooks/#emit",target:"_blank",rel:"noopener noreferrer",children:"emit"}),")产物时，找出所有图片资源并调用 ",(0,s.jsx)(n.a,{href:"https://github.com/imagemin/imagemin",target:"_blank",rel:"noopener noreferrer",children:"imagemin"})," 压缩图像。核心逻辑："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default class ImageminPlugin {\n  constructor(options = {}) {\n    // init options\n  }\n\n  apply(compiler) {\n    // ...\n    const onEmit = async (compilation, callback) => {\n      // ...\n      await Promise.all([\n        ...this.optimizeWebpackImages(throttle, compilation),\n        ...this.optimizeExternalImages(throttle),\n      ]);\n    };\n\n    compiler.hooks.emit.tapAsync(this.constructor.name, onEmit);\n  }\n\n  optimizeWebpackImages(throttle, compilation) {}\n\n  optimizeExternalImages(throttle) {}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述代码主要用到 ",(0,s.jsx)(n.code,{children:"compiler.hooks.emit"})," 钩子，该钩子在 Webpack 完成代码构建与打包操作，准备将产物发送到输出目录之前执行，我们可以在此修改产物内容，如上例 ",(0,s.jsx)(n.code,{children:"optimizeWebpackImages"})," 函数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default class ImageminPlugin {\n  optimizeWebpackImages(throttle, compilation) {\n    const {\n        // 用于判断是否对特定文件做图像压缩操作\n        testFunction,\n        // 缓存目录\n        cacheFolder\n      } = this.options\n  \n    // 遍历 `assets` 产物数组\n      return map(compilation.assets, (asset, filename) => throttle(async () => {\n        // 读取产物内容\n        const assetSource = asset.source()\n        if (testFunction(filename, assetSource)) {\n          // 尝试从缓存中读取\n          let optimizedImageBuffer = await getFromCacheIfPossible(cacheFolder, assetSource, () => {\n            // 调用 `imagemin` 压缩图片\n            return optimizeImage(assetSource, this.options)\n          })\n  \n          // 之后，使用优化版本替换原始文件\n          compilation.assets[filename] = new RawSource(optimizedImageBuffer)\n        }\n      }))\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里面的关键逻辑是："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["遍历 ",(0,s.jsx)(n.code,{children:"compilation.assets"})," 产物列表，调用 ",(0,s.jsx)(n.code,{children:"asset.source()"})," 方法读取产物内容；"]}),"\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"imagemin"})," 压缩图片；"]}),"\n",(0,s.jsxs)(n.li,{children:["修改 ",(0,s.jsx)(n.code,{children:"compilation.assets"}),"，使用优化后的图片 ",(0,s.jsx)(n.code,{children:"RawSource"})," 对象替换原始 ",(0,s.jsx)(n.code,{children:"asset"})," 对象。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"至此完成文件压缩操作。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：",(0,s.jsx)(n.code,{children:"Source"})," 是 Webpack 内代表资源内容的类，由 ",(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack-sources/blob/HEAD/lib/index.js",target:"_blank",rel:"noopener noreferrer",children:"webpack-source"})," 库实现，支持 ",(0,s.jsx)(n.code,{children:"RawSource/ConcatSource"})," 等子类型，用于实现文件读写、合并、修改、Sourcemap 等操作。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"实例剖析eslint-webpack-plugin",children:["实例剖析：",(0,s.jsx)(n.code,{children:"eslint-webpack-plugin"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例剖析eslint-webpack-plugin",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"学习如何提交错误日志"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github1s.com/webpack-contrib/eslint-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"eslint-webpack-plugin"})," 是一个基于 ESLint 实现的代码风格检查插件，它的实现比较巧妙，一是使用多个 Hook，在不同时间点执行 Lint 检查；二是复用 Webpack 内置的 ",(0,s.jsx)(n.code,{children:"error/warn"})," 方法提交代码风格问题。核心逻辑："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class ESLintWebpackPlugin {\n  constructor(options = {}) {\n    // ...\n  }\n\n  apply(compiler) {\n    compiler.hooks.run.tapPromise(this.key, (c) =>\n      this.run(c, options, wanted, exclude)\n    );\n  }\n\n  async run(compiler, options, wanted, exclude) {\n    compiler.hooks.compilation.tap(this.key, (compilation) => {\n      ({ lint, report, threads } = linter(this.key, options, compilation));\n\n      const files = [];\n\n      // 单个模块成功编译后触发\n      compilation.hooks.succeedModule.tap(this.key, ({ resource }) => {\n        // 判断是否需要检查该文件\n        if (\n          isMatch(file, wanted, { dot: true }) &&\n          !isMatch(file, exclude, { dot: true })\n        ) {\n          lint(file);\n        }\n      });\n\n      // 所有模块构建完毕后触发\n      compilation.hooks.finishModules.tap(this.key, () => {\n        if (files.length > 0 && threads <= 1) {\n          lint(files);\n        }\n      });\n\n      // 等待检查结果\n      compilation.hooks.additionalAssets.tapPromise(this.key, processResults);\n\n      async function processResults() {}\n    });\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"代码用到如下 Hook："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compiler.hooks.compilation"}),"：Compiler 环境初始化完毕，创建出 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象，准备开始执行构建前触发；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compilation.hooks.succeedModule"}),"：Webpack 完成单个「模块」的读入、运行 Loader、AST 分析、依赖分析等操作后触发；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compilation.hooks.finishModules"}),"：Webpack 完成「所有」模块的读入、运行 Loader、依赖分析等操作后触发；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"compilation.hooks.additionalAssets"}),"：构建、打包完毕后触发，通常用于为编译创建附加资产。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["其中，比较重要的是借助 ",(0,s.jsx)(n.code,{children:"compilation.hooks.succeedModule"})," 钩子，在每个模块处理完毕之后立即通过 ",(0,s.jsx)(n.code,{children:"lint"})," 函数添加非阻塞代码检查任务，相比于过去的 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/eslint-loader",target:"_blank",rel:"noopener noreferrer",children:"eslint-loader"})," 的阻塞式执行，这种方式能够提高 ESLint 的并发度，效率更高。"]}),"\n",(0,s.jsxs)(n.p,{children:["其次，借助 ",(0,s.jsx)(n.code,{children:"compilation.hooks.additionalAssets"})," 钩子，在所有模块处理完毕后读取检查结果 —— 即 ",(0,s.jsx)(n.code,{children:"processResults"})," 函数，核心代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"async function processResults() {\n  const { errors, warnings } = await report();\n\n  if (warnings && !options.failOnWarning) {\n    compilation.warnings.push(warnings);\n  } else if (warnings && options.failOnWarning) {\n    compilation.errors.push(warnings);\n  }\n\n  if (errors && options.failOnError) {\n    compilation.errors.push(errors);\n  } else if (errors && !options.failOnError) {\n    compilation.warnings.push(errors);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["代码读取 ESLint 执行结果(",(0,s.jsx)(n.code,{children:"report"})," 函数)，并使用 ",(0,s.jsx)(n.code,{children:"compilation"})," 的 ",(0,s.jsx)(n.code,{children:"errors"})," 与 ",(0,s.jsx)(n.code,{children:"warnings"})," 数组提交错误/警告信息，这种方式只会输出错误信息，不会中断编译流程，运行效果如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"实例剖析defineplugin",children:["实例剖析：",(0,s.jsx)(n.code,{children:"DefinePlugin"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例剖析defineplugin",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"学习在插件中如何与 AST 结构交互"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack",target:"_blank",rel:"noopener noreferrer",children:"DefinePlugin"})," 是 Webpack 官方实现的，用于构建时注入预定义常量的插件，先简单回顾一下",(0,s.jsx)(n.a,{href:"https://webpack.js.org/plugins/define-plugin/",target:"_blank",rel:"noopener noreferrer",children:"用法"}),"，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const { DefinePlugin } = require("webpack");\n\nconst baseConfig = {\n  // ...\n  plugins: [\n    new DefinePlugin({\n      PROD: true,\n      VERSION: JSON.stringify("12.13.0"),\n    }),\n  ],\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["之后，Webpack 会帮我们替换掉代码中所有 ",(0,s.jsx)(n.code,{children:"DefinePlugin"})," 声明的属性值，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// 源码：\nconsole.log(PROD, VERSION);\n\n// 构建结果：\nconsole.log(true, "5fa3b9");\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"DefinePlugin"})," 的 ",(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/DefinePlugin.js",target:"_blank",rel:"noopener noreferrer",children:"底层实现"})," 比较复杂，需要遍历 AST 找出变量名对应的代码位置之后再做替换，插件核心结构："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'class DefinePlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\n      "DefinePlugin",\n      (compilation, { normalModuleFactory }) => {\n        const handler = (parser) => {\n          // 递归处理 `DefinePlugin` 参数\n          const walkDefinitions = (definitions, prefix) => {\n            Object.keys(definitions).forEach((key) => {\n              const code = definitions[key];\n              if (isObject /*...*/) {\n                // 递归处理对象属性\n                walkDefinitions(code, prefix + key + ".");\n                applyObjectDefine(prefix + key, code);\n                return;\n              }\n              applyDefineKey(prefix, key);\n              applyDefine(prefix + key, code);\n            });\n          };\n\n          // 替换基本类型的表达式值\n          const applyDefine = (key, code) => {\n            if (!isTypeof) {\n              // 借助 expression 钩子替换内容\n              parser.hooks.expression.for(key).tap("DefinePlugin", (expr) => {\n                /*...*/\n              });\n            }\n            // 处理 `\'typeof window\': JSON.stringify(\'object\'),` 场景\n            parser.hooks.typeof.for(key).tap("DefinePlugin", (expr) => {\n              /*...*/\n            });\n          };\n\n          // 替换引用类型的表达式值\n          const applyObjectDefine = (key, obj) => {\n            // ...\n            parser.hooks.expression.for(key).tap("DefinePlugin", (expr) => {\n              /*...*/\n            });\n          };\n\n          walkDefinitions(definitions, "");\n        };\n\n        // 监听 `parser` 钩子\n        normalModuleFactory.hooks.parser\n          .for("javascript/auto")\n          .tap("DefinePlugin", handler);\n        normalModuleFactory.hooks.parser\n          .for("javascript/dynamic")\n          .tap("DefinePlugin", handler);\n        normalModuleFactory.hooks.parser\n          .for("javascript/esm")\n          .tap("DefinePlugin", handler);\n      }\n    );\n  }\n}\nmodule.exports = DefinePlugin;\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：可能有同学注意到，上例代码中出现 ",(0,s.jsx)(n.code,{children:"xxx.hooks.xxx.for(condition).tap"})," 形式的调用，这里的 ",(0,s.jsx)(n.code,{children:"for"})," 函数可以理解为 Hook 的过滤条件，仅在满足 ",(0,s.jsx)(n.code,{children:"condition"})," 时触发，后面章节会详细讲解。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"核心逻辑："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"normalModuleFactory.hooks.parser"})," 钩子(上例 48 行)，在 Webpack 创建出代码解析器 ",(0,s.jsx)(n.code,{children:"Parser"})," 对象后执行 ",(0,s.jsx)(n.code,{children:"handler"})," 函数。注意，此时还没有执行代码转 AST 操作；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"walkDefinitions"})," 函数中递归遍历 ",(0,s.jsx)(n.code,{children:"DefinePlugin"})," 参数对象，为每一个属性注册 ",(0,s.jsx)(n.code,{children:"parser.hooks.expression"})," 钩子回调，该钩子会在 Webpack 遍历 AST 过程遇到表达式语句时触发；"]}),"\n",(0,s.jsxs)(n.li,{children:["在 ",(0,s.jsx)(n.code,{children:"parser.hooks.expression"})," 回调中创建新的 ",(0,s.jsx)(n.code,{children:"Dependency"})," 对象，调用 ",(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Module.js#L494",target:"_blank",rel:"noopener noreferrer",children:"addPresentationalDependency"})," 添加为模块依赖："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const toConstantDependency = (parser, value, runtimeRequirements) => {\n  return function constDependency(expr) {\n    const dep = new ConstDependency(value, expr.range, runtimeRequirements);\n    dep.loc = expr.loc;\n    // 创建静态依赖对象，替换 loc 指定位置内容\n    parser.state.module.addPresentationalDependency(dep);\n    return true;\n  };\n};\n\nconst applyDefine = (key, code) => {\n  parser.hooks.expression.for(key).tap("DefinePlugin", (expr) => {\n    const strCode = toCode(/*...*/);\n    if (/*...*/) {\n      /*...*/\n    } else {\n      return toConstantDependency(parser, strCode)(expr);\n    }\n  });\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["之后，Webpack 会借助 Template 接口将上述 ",(0,s.jsx)(n.code,{children:"Dependency"})," 打包进 Chunk 中，替换对应位置(",(0,s.jsx)(n.code,{children:"loc"}),")代码："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["这是一个功能效果看起来简单，但实现特别复杂的例子，底层需要使用 ",(0,s.jsx)(n.code,{children:"Parser"})," 钩子遍历 AST 结构，之后借助 ",(0,s.jsx)(n.code,{children:"Dependency"})," 声明代码依赖，最后借助 Template 替换代码内容，过程中已经涉及到许多 Webpack 底层对象。"]}),"\n",(0,s.jsx)(n.p,{children:"这正是学习开发 Webpack 插件的难点，有时候你不仅仅需要了解每一个 Hook 的时机与作用、如何与上下文参数交互，还需要了解 Webpack 底层许多类型的实现、作用、接口等等，才能写出符合预期的功能，而 Webpack 是一个极度复杂、庞大的工具，这些具体知识点太多太碎，几乎不可能一一枚举。不过，我们可以换一种方式，从更高更抽象的视角审视 Webpack 插件架构，从“道”的角度加深理解。"}),"\n",(0,s.jsxs)(n.h2,{id:"插件架构综述",children:["插件架构综述",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插件架构综述",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前端社区里很多有名的框架都各自有一套插件架构，例如 axios、quill、vscode、webpack、vue、rollup 等等。插件架构灵活性高，扩展性强，但通常架构复杂度更高，学习曲线更陡峭。插件架构至少需要解决三个方面的问题："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"接口"}),"：需要提供一套逻辑接入方法，让开发者能够将代码插入特定环节，变更原始逻辑；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"输入"}),"：如何将上下文信息高效传导给插件；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"输出"}),"：插件内部通过何种方式影响整套运行体系。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["针对这些问题，webpack 基于 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack/tapable",target:"_blank",rel:"noopener noreferrer",children:"tapable"})," 实现了："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"编译过程的特定节点以钩子形式，通知插件此刻正在发生什么事情；"}),"\n",(0,s.jsx)(n.li,{children:"通过 tapable 提供的回调机制，以参数方式传递上下文信息；"}),"\n",(0,s.jsx)(n.li,{children:"在上下文参数对象中附带了很多存在 Side Effect 的交互接口，插件可以通过这些接口改变。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这一切都离不开 tapable，举例来说："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'class Compiler {\n  // 在构造函数中，先初始化钩子对象\n  constructor() {\n    this.hooks = {\n      thisCompilation: new SyncHook(["compilation", "params"]),\n    };\n  }\n\n  compile() {\n    // 特定时机触发特定钩子\n    const compilation = new Compilation();\n    this.hooks.thisCompilation.call(compilation);\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Compiler"})," 类型内部定义了 ",(0,s.jsx)(n.code,{children:"thisCompilation"})," 钩子，并在 ",(0,s.jsx)(n.code,{children:"compilation"})," 创建完毕后发布事件消息，插件开发者就可以基于这个钩子获取到最新创建出的 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'class SomePlugin {\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap("SomePlugin", (compilation, params) => {\n        // 上下文信息： compilation、params\n    });\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["钩子回调传递的 ",(0,s.jsx)(n.code,{children:"compilation/params"})," 参数，就是 Webpack 希望传递给插件的上下文信息，也是插件能拿到的输入。不同钩子会传递不同的上下文对象，这一点在钩子被创建的时候就定下来了，比如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'class Compiler {\n    constructor() {\n        this.hooks = {\n            /** @type {SyncBailHook<Compilation>} */\n            shouldEmit: new SyncBailHook(["compilation"]),\n            /** @type {AsyncSeriesHook<Stats>} */\n            done: new AsyncSeriesHook(["stats"]),\n            /** @type {AsyncSeriesHook<>} */\n            additionalPass: new AsyncSeriesHook([]),\n            /** @type {AsyncSeriesHook<Compiler>} */\n            beforeRun: new AsyncSeriesHook(["compiler"]),\n            /** @type {AsyncSeriesHook<Compiler>} */\n            run: new AsyncSeriesHook(["compiler"]),\n            /** @type {AsyncSeriesHook<Compilation>} */\n            emit: new AsyncSeriesHook(["compilation"]),\n            /** @type {AsyncSeriesHook<string, Buffer>} */\n            assetEmitted: new AsyncSeriesHook(["file", "content"]),\n            /** @type {AsyncSeriesHook<Compilation>} */\n            afterEmit: new AsyncSeriesHook(["compilation"]),\n        };\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"shouldEmit"})," 会被传入 ",(0,s.jsx)(n.code,{children:"compilation"})," 参数；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"done"})," 会被传入 ",(0,s.jsx)(n.code,{children:"stats"})," 参数；"]}),"\n",(0,s.jsx)(n.li,{children:"……"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这一设计贯穿 Webpack 整个执行过程，几乎无处不在，我们可以借此介入 Webpack 的运行逻辑。"}),"\n",(0,s.jsxs)(n.p,{children:["插件架构的灵魂就在于，框架自身只负责实现最关键的核心流程，其它具体功能都尽量交给具体插件实现，包括 Webpack 仓库内也会内置非常多插件(如 ",(0,s.jsx)(n.code,{children:"DefinePlugin/EntryPlugin"})," 等)，这就为我们提供了非常充分的学习素材。因此，我的建议是："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"先透彻理解上述 Webpack 插件架构的设计逻辑，捋清楚 Webpack 主流程与 Hook 之间的关系；"}),"\n",(0,s.jsx)(n.li,{children:"尝试用本文第一节提及的若干常见 Hook 与上下文参数对象编写一些示例，对这些钩子有一个感性认知；"}),"\n",(0,s.jsxs)(n.li,{children:["尝试分析一些常用但不是很复杂的插件源码，例如文中提到的 ",(0,s.jsx)(n.code,{children:"eslint-webpack-plugin"})," 等，或者：",(0,s.jsx)(n.code,{children:"terser-webpack-plugin"}),"、",(0,s.jsx)(n.code,{children:"stylelint-webpack-plugin"})," 等，从中学习一些编写插件的常见方法；"]}),"\n",(0,s.jsx)(n.li,{children:"最后，在实际开发时参考相关插件源码实现，带着问题与明确目标，逐行分析插件实现逻辑。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["综上，Webpack 插件在代码形态上是一个带 ",(0,s.jsx)(n.code,{children:"apply"})," 方法的对象，我们可以在 ",(0,s.jsx)(n.code,{children:"apply"})," 函数中注册各式各样的 Hook 回调，监听对应事件，之后在回调中修改上下文状态，达到干预 Webpack 构建逻辑的效果。"]}),"\n",(0,s.jsx)(n.p,{children:"由此可见，编写插件时大部分工作都围绕 Hook 展开，因此我们需要理解构建过程中的不同环节会触发什么 Hook、对应传递什么上下文参数、如何与上下文参数对象交互等，而学习这些知识最高效的方式，我认为是阅读、分析各种开源插件源码。例如文章中提及的："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["从 ",(0,s.jsx)(n.code,{children:"imagemin-webpack-plugin"})," 学习：如何借助 ",(0,s.jsx)(n.code,{children:"assets"})," 数组修改最终产物内容；"]}),"\n",(0,s.jsxs)(n.li,{children:["从 ",(0,s.jsx)(n.code,{children:"eslint-webpack-plugin"})," 学习：如何提交错误信息；"]}),"\n",(0,s.jsxs)(n.li,{children:["从 ",(0,s.jsx)(n.code,{children:"DefinePlugin"})," 学习：如何与 AST 结构交互。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"相信通过阅读这些内容，你已经对 Webpack 插件的形态与开发方式有了一个基本理解，下一章节我会继续抽象一些常见的开发用例，包括：校验插件参数、提交日志、搭建自动化测试环境等，帮助你进一步掌握插件的开发方法。"}),"\n",(0,s.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"插件架构设计算是许多优秀软件工程项目的标配，那么作为对比，Rollup 又是怎么实现插件扩展能力的呢？感兴趣的同学可以参考相关源码，交叉学习。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let h=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F21.%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%89%96%E6%9E%90%E6%8F%92%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81%E4%B8%8E%E6%9E%B6%E6%9E%84%E9%80%BB%E8%BE%91.md"]={toc:[{text:"插件简介",id:"插件简介",depth:2},{text:"实例剖析：`imagemin-webpack-plugin`",id:"实例剖析imagemin-webpack-plugin",depth:2},{text:"实例剖析：`eslint-webpack-plugin`",id:"实例剖析eslint-webpack-plugin",depth:2},{text:"实例剖析：`DefinePlugin`",id:"实例剖析defineplugin",depth:2},{text:"插件架构综述",id:"插件架构综述",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"21.插件开发基础：实例剖析插件基本形态与架构逻辑",headingTitle:"21.插件开发基础：实例剖析插件基本形态与架构逻辑",frontmatter:{}}}}]);