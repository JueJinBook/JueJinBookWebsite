"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["62466"],{614831:function(e,n,s){s.r(n),s.d(n,{default:()=>p});var r=s(552676),t=s(740453);let c=s.p+"static/image/fef6f65b7a0de0fe1114b3aa5839be8a.2842c874.webp",h=s.p+"static/image/6cef89a0f609426d4a3d30c4219944dd.3a402df5.webp",d=s.p+"static/image/8c4bb4db020dd519bd6903f9941948ac.3d2a49ec.webp",a=s.p+"static/image/2e1a0e1dcc6df72082456567e151d08a.d85b09bb.webp";function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",strong:"strong",img:"img",ul:"ul",li:"li"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"13-理解-http用-http-模块实现-http-内容协商",children:["13 理解 HTTP：用 http 模块实现 HTTP 内容协商",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-理解-http用-http-模块实现-http-内容协商",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上一节课，我们介绍了用 net 模块实现 TCP 服务。用 TCP 服务来处理 HTTP 请求需要使用字符串模板，组织 HTTP 请求和响应的报文，这是一个比较麻烦的过程。幸好，Node.js 提供了更简单的方式：直接使用 http 模块。"}),"\n",(0,r.jsxs)(n.h2,{id:"用-http-模块创建-http-服务",children:["用 http 模块创建 HTTP 服务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用-http-模块创建-http-服务",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["接下来，我们用 http 模块创建一个和上一节课一样的 HTTP 服务。当我们请求的 pathname 为",(0,r.jsx)(n.code,{children:"/"}),"的时候，返回 200 状态和",(0,r.jsx)(n.code,{children:"<h1>Hello World</h1>"}),"，请求其他 URL 的时候返回 404 状态和",(0,r.jsx)(n.code,{children:"<h1>Not Found</h1>"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们新建一个模块",(0,r.jsx)(n.code,{children:"http-simple.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// http-simple.js\n\nconst http = require('http');\nconst url = require('url');\n\nconst server = http.createServer((req, res) => {\n  const {pathname} = url.parse(`http://${req.headers.host}${req.url}`);\n  if(pathname === '/') {\n    res.writeHead(200, {'Content-Type': 'text/html'});\n    res.end('<h1>Hello world</h1>');\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/html'});\n    res.end('<h1>Not Found</h1>');\n  }\n});\n\nserver.on('clientError', (err, socket) => {\n  socket.end('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');\n});\n\nserver.listen(8080, () => {\n  console.log('opened server on', server.address());\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"相比使用 TCP 服务来处理 HTTP 请求，使用 http 服务处理 HTTP 请求更加简单，因为我们不需要手动解析 HTTP 请求的报文，以及用字符串模板组织 HTTP 响应报文。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"http.createServer"}),"创建一个 HTTP 服务，它的回调有两个参数：req 表示 HTTP 请求对象，res 表示 HTTP 响应对象。我们可以从 req 对象中获取请求相关的信息，比如 req.headers 中是 HTTP 请求头（Request Headers）的内容，req.url 是当前请求的 URL 路径，我们通过",(0,r.jsx)(n.code,{children:"req.headers.host"}),"获取请求的服务器名，然后将它和",(0,r.jsx)(n.code,{children:"req.url"}),"拼接起来，再用 url 模块解析，然后从中获取",(0,r.jsx)(n.code,{children:"pathname"}),"，拿到我们要的请求路径，判断它是否是",(0,r.jsx)(n.code,{children:"/"}),"，根据情况返回 200 或 404。"]}),"\n",(0,r.jsxs)(n.p,{children:["在返回 HTTP 响应内容时，我们不再需要自己拼接模板字符串和计算",(0,r.jsx)(n.code,{children:"Content-length"}),"。http 模块会自动完成这个工作并将",(0,r.jsx)(n.code,{children:"Content-length"}),"写入响应头。我们还可以直接用",(0,r.jsx)(n.code,{children:"res.writeHead"}),"来写入其他 HTTP 响应头，用",(0,r.jsx)(n.code,{children:"res.end"}),"来写入 HTTP 的 Body 部分。"]}),"\n",(0,r.jsxs)(n.p,{children:["当",(0,r.jsx)(n.code,{children:"res.end"}),"被执行时，HTTP 请求的响应就会被发回给浏览器。"]}),"\n",(0,r.jsxs)(n.h2,{id:"http-内容协商",children:["HTTP 内容协商",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http-内容协商",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["你可能觉得奇怪，为什么 HTTP 协议要分为 Header 和 Body，实际上 HTTP 请求的这种设计提供了一种",(0,r.jsx)(n.strong,{children:"内容协商机制"}),"。内容协商是 HTTP 协议的基本原则，服务器根据不同的请求头，对指向同一 URL 的请求提供不同格式的响应内容。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们看一个例子，假设我们访问",(0,r.jsx)(n.code,{children:"http://localhost:8080/account.html"}),"，服务器返回的信息如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"账号: zhangsan\n昵称: 张三\n注册时间: 2020年3月1日\n"})}),"\n",(0,r.jsx)(n.p,{children:"服务器可以根据不同的请求方式，返回不同的格式的数据内容。如果我们是用浏览器直接访问，那么返回 HTML 格式："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<ul>\n  <li><span>账号：</span><span>zhangsan</span></li>\n  <li><span>昵称：</span><span>张三</span></li>\n  <li><span>注册时间：</span><span>2020年3月1日</span></li>\n</ul>\n"})}),"\n",(0,r.jsx)(n.p,{children:"如果我们用支持 JSON 格式的程序或设备访问，那么返回如下 JSON 格式："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "ID": "zhangshan",\n  "Name": "张三",\n  "RegisterDate": "2020年3月1日"\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"像这样的场景，一般在智能物联网 IoT 的应用场景中比较常见，一些智能设备的管理端没有浏览器，不支持 HTML 展现，需要用 JSON 格式的数据。"}),"\n",(0,r.jsx)(n.p,{children:"这种情况，我们可以在服务器根据 HTTP 请求头做出处理。标准的方式是判断 HTTP 请求头的 Accept 字段（Accept 字段是浏览器发送请求时，自动生成的字段）。"}),"\n",(0,r.jsx)(n.p,{children:"修改我们的代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// http-consult.js \n\nconst responseData = {\n  ID: 'zhangsan',\n  Name: '张三',\n  RegisterDate: '2020年3月1日',\n};\n\nfunction toHTML(data) {\n  return `\n    <ul>\n      <li><span>账号：</span><span>${data.ID}</span></li>\n      <li><span>昵称：</span><span>${data.Name}</span></li>\n      <li><span>注册时间：</span><span>${data.RegisterDate}</span></li>\n    </ul>\n  `;\n}\n\nconst server = http.createServer((req, res) => {\n  const {pathname} = url.parse(`http://${req.headers.host}${req.url}`);\n  if(pathname === '/') {\n    const accept = req.headers.accept; // 获取Accept信息\n    if(accept.indexOf('application/json') >= 0) {\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(JSON.stringify(responseData));\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});\n      res.end(toHTML(responseData));\n    }\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/html'});\n    res.end('<h1>Not Found</h1>');\n  }\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如上面代码所示，我们通过",(0,r.jsx)(n.code,{children:"req.headers.accept"}),"读取请求头",(0,r.jsx)(n.code,{children:"accept"}),"字段的信息，如果这个信息中包含有",(0,r.jsx)(n.code,{children:"application/json"}),"，表示发起这个请求的客户端支持 JSON 格式的内容，服务器就返回 JSON 格式的结果，否则返回 HTML 的结果。"]}),"\n",(0,r.jsxs)(n.p,{children:["这样一来，我们如果用浏览器直接访问",(0,r.jsx)(n.code,{children:"localhost:8080"}),"，得到的就是 HTML 的结果："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["这是因为浏览器默认发送的 HTTP 请求中，accept 字段的值是",(0,r.jsx)(n.code,{children:"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9"}),"，不包括",(0,r.jsx)(n.code,{children:"appliaction/json"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们要发送",(0,r.jsx)(n.code,{children:"application/json"}),"请求头给服务器，可以通过 curl 命令或者其他工具，这里推荐一个比较好用的工具 PostMan。"]}),"\n",(0,r.jsxs)(n.p,{children:["你可以在 ",(0,r.jsx)(n.a,{href:"https://www.postman.com/",target:"_blank",rel:"noopener noreferrer",children:"PostMan 官网"}),"下载安装它。"]}),"\n",(0,r.jsxs)(n.p,{children:["通过 PostMan 发送请求，设置 accept 请求头为",(0,r.jsx)(n.code,{children:"application/json"}),"，得到的结果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"对于 HTTP 协议来说，内容协商是一个比较广泛的概念，并不仅仅指根据  Accept 属性值返回对应的内容，还可以根据 HTTP 动作（Verb）实现内容协商。"}),"\n",(0,r.jsx)(n.p,{children:"比如，我们修改上面的代码，除了 Accept 请求头之外，如果请求的动作为 POST，也返回 JSON 内容："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const server = http.createServer((req, res) => {\n  const {pathname} = url.parse(`http://${req.headers.host}${req.url}`);\n  if(pathname === '/') {\n    const accept = req.headers.accept;\n    if(req.method === 'POST' || accept.indexOf('application/json') >= 0) {\n      res.writeHead(200, {'Content-Type': 'application/json'});\n      res.end(JSON.stringify(responseData));\n    } else {\n      res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});\n      res.end(toHTML(responseData));\n    }\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/html'});\n    res.end('<h1>Not Found</h1>');\n  }\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"req.method"}),"可以获取请求的动作信息，如果是 POST 请求，",(0,r.jsx)(n.code,{children:"req.method"}),"的值是",(0,r.jsx)(n.code,{children:"POST"}),"。修改了代码之后，如果请求是 POST，那么不管 Accept 值是不是",(0,r.jsx)(n.code,{children:"application/json"}),"，都返回 JSON 格式。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"http-请求的动作和状态码",children:["HTTP 请求的动作和状态码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http-请求的动作和状态码",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面的例子，我们实现了一个简单的内容协商 HTTP 服务。在这里，我们顺便介绍一下 HTTP 协议的动作和状态码。"}),"\n",(0,r.jsxs)(n.p,{children:["你应该知道，HTTP 请求分为 GET、POST 请求。实际上，根据标准的 HTTP/1.1 协议，HTTP 请求的动作分为",(0,r.jsx)(n.code,{children:"GET、HEAD、OPTIONS、POST、PUT、PATCH、DELETE"}),"。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"GET 表示从服务器获取 URL 指定的资源。"}),"\n",(0,r.jsx)(n.li,{children:"HEAD 表示只获取该 URL 指定资源的 HTTP 响应头部分（忽略 Body）。"}),"\n",(0,r.jsx)(n.li,{children:"OPTIONS 是一个特殊的请求，用来预检服务器是否支持某个请求动作。比如客户端可以先发起一个请求询问服务器是否支持 PUT 请求。若支持，则发起后续的 PUT 请求。"}),"\n",(0,r.jsx)(n.li,{children:"POST 表示将数据资源从客户端提交给服务器。"}),"\n",(0,r.jsx)(n.li,{children:"PUT 表示更新服务器上某个已有资源。"}),"\n",(0,r.jsx)(n.li,{children:"PATCH 也表示更新服务器上某个已有资源，但以增量更新的方式，客户端只传输修改部分。"}),"\n",(0,r.jsx)(n.li,{children:"DELETE 表示从服务器上删除某个资源。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"GET、HEAD、POST 请求是 HTTP/1.0 就支持的请求动作，OPTIONS、PUT、PATCH、DELETE 是 HTTP/1.1 增加的请求动作。"}),"\n",(0,r.jsx)(n.p,{children:"按照规范，GET、HEAD 和 OPTIONS 请求是不会改变 HTTP 服务器上的数据的，因此是安全（Safe）的。"}),"\n",(0,r.jsx)(n.p,{children:"按照规范，除了 POST、PATCH 之外，其他的请求以同样的方式调用一次和多次，对系统产生的副作用是相同的，因此是幂等的。"}),"\n",(0,r.jsx)(n.p,{children:"按照规范，POST 方法调用多次，可能会创建多次数据，所以是非幂等，PATCH 方法可能会增量添加多次数据内容，因此也是非幂等的。"}),"\n",(0,r.jsx)(n.p,{children:"按照规范，GET、OPTIONS 请求允许被缓存，其他请求不允许被缓存。关于缓存，在后续的课程中会有详细描述。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"HTTP 的状态码表示 HTTP 请求的结果，它是一个三位数字，首位可能是 1、2、3、4、5。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"首位是 1 表示中间状态，按照规范 POST 请求会先提交HEAD信息，如果服务器返回 100，才将数据信息提交。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"首位是 2 表示请求结束，最常用的就是 200，表示正常返回。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"首位是 3 表示被请求的资源被重定向，最常用的是 301、302、304。301 表示资源已经被永久移动到新的位置，302 表示资源被暂时移动到新的位置，304 表示资源被缓存，这是浏览器的缓存策略，在后续的课程中会有详细描述。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"首位是 4 表示请求错误，最常用的是 400、403、404。400 是服务器无法理解和处理该请求；403 表示服务器理解请求，但客户端不具有获取该请求的权限，因此服务器拒绝响应；404 表示请求的资源不存在。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"首位是 5 表示服务器自身存在问题，导致不能响应请求，常见的有 500、502、504。一般 500 表示服务器当前状态异常；502 表示作为网关的服务器无法从上游获取到有效数据（在后续课程中我们会解释这种状况）；504 表示请求的数据超时。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们需要明白的是，上述这些动作、状态码以及内容协商，都是 HTTP 规范的一部分，并不是强制的。也就是说，虽然 HTTP 协议规定了 GET 请求不能向服务器提交数据，服务器不应该在处理 GET 请求时将数据写入文件或数据库，但是如果我们一定要这么做，并没有任何强的约束阻止我们这么做。很多早期的不规范的 Web 服务器确实也可以通过 GET 请求的 URL 来提交一些数据。"}),"\n",(0,r.jsx)(n.p,{children:"同样，虽然规定了错误应当返回 4 开头的状态码，但是也有很多 Web 应用将错误用 200 返回，然后在返回的内容中提供错误信息。内容协商也不完全通过对应的 HEADER，比如可以通过 URL 中的 Query 或者其他的信息（比如 URL 的 Path 的一部分）。"}),"\n",(0,r.jsxs)(n.p,{children:["上述这些方式是不规范的实现，但并不是错误，在很多 HTTP 服务器上是存在这样的情况的。不过，既然有 HTTP 规范，那么我们在实现 HTTP 服务的时候还是尽量遵循规范，因为",(0,r.jsx)(n.strong,{children:"遵循了这些约定和规范，可以让我们的系统有更好的适应性，而且这些规范原则本身对我们的系统和代码的可维护性也有帮助"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"http 模块比 net 模块用起来更简单，不需要自己解析 HTTP 请求的内容，或者自己拼接响应的内容，直接使用回调函数中的 req、res 对象来处理请求或响应即可。"}),"\n",(0,r.jsx)(n.p,{children:"内容协商是 HTTP 协议的基本原则，我们可以根据内容协商机制针对不同终端的请求提供不同的响应内容。"}),"\n",(0,r.jsx)(n.p,{children:"最后我们了解了 HTTP 请求的动作和状态码。"}),"\n",(0,r.jsx)(n.p,{children:"在下一节课，我们将扩展这个简单的 HTTP 服务，用它实现一个静态文件服务器。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let p=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F13%20%E7%90%86%E8%A7%A3%20HTTP%EF%BC%9A%E7%94%A8%20http%20%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%20HTTP%20%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86.md"]={toc:[{text:"用 http 模块创建 HTTP 服务",id:"用-http-模块创建-http-服务",depth:2},{text:"HTTP 内容协商",id:"http-内容协商",depth:2},{text:"HTTP 请求的动作和状态码",id:"http-请求的动作和状态码",depth:2},{text:"总结",id:"总结",depth:2}],title:"13 理解 HTTP：用 http 模块实现 HTTP 内容协商",headingTitle:"13 理解 HTTP：用 http 模块实现 HTTP 内容协商",frontmatter:{}}}}]);