"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12770"],{98357:function(e,n,t){t.r(n),t.d(n,{default:()=>L});var r=t(552676),a=t(740453);let c=t.p+"static/image/fe9e76f8a0f78d51a70106aa9611f287.cb2c277a.gif",s=t.p+"static/image/b872f447bc104b9d3c96b59ed1b57792.0ff74e3e.webp",i=t.p+"static/image/fdb4b35b5a903b995d57ff5c998d4dd3.bc5edc40.webp",o=t.p+"static/image/c32a6079e549f96296e387ceea9556f0.74760edd.webp",d=t.p+"static/image/4545db3507290510d12c6d58c94d5fbe.885be26c.gif",l=t.p+"static/image/ff8c09081c2030f0f94dc3247148014f.fc05e810.gif",p=t.p+"static/image/ecab6207d1dc3ce5202cb0ddca237500.88861472.gif",h=t.p+"static/image/59e9d77a4802160a258aedf80cb2957b.1a8145a9.webp",b=t.p+"static/image/6c617b7ca2c1f0b63265efc1e620c5bd.6b8b5427.webp",f=t.p+"static/image/255603dcd09af7f4d6a4314429d7803d.a2f44fc3.webp",u=t.p+"static/image/cf1f88c6a43989e3fbd55da099820d4c.1a626357.webp",m=t.p+"static/image/e850b9a63f5214f99bfe8b8f36cc758a.9c9ae84c.webp",x=t.p+"static/image/b9b15085774cfb5fedf5d0f5ff6b4c6d.b360774b.webp",j=t.p+"static/image/5cd82372ee8adb08c13a8540549b1796.24d1f447.webp",g=t.p+"static/image/3c571ab86116f026c5c6dce17b0f71a2.e50aef92.webp",v=t.p+"static/image/f95ce491fb7315b2187b6954566b46f1.e00f51f9.webp",C=t.p+"static/image/10bd63c18dc830c021260c9a6c9adcfd.75be9561.webp",E=t.p+"static/image/9d030bd160e7f52636a41ed9d873ebfa.0a91fd1e.webp",M=t.p+"static/image/401c1b32478aad19361f9984d7f46704.13d88b6f.webp",y=t.p+"static/image/343ea26fdc1d6ce954bbdf95ea0232b0.a7cd3840.webp",O=t.p+"static/image/05ba7cd6fcb714d46c1a9eba15fdd150.fc00526c.webp",R=t.p+"static/image/e957de94f7f374da40ebd4ba3c0647be.18af448e.webp",N=t.p+"static/image/a967894acf3d1eb0697c040cf73ba581.1d7e4d64.webp",P=t.p+"static/image/86cb090b2196050c88e08a86b3035c33.2243b0c1.webp",k=t.p+"static/image/0256e413a5fe417aa7ae613d314b4fa2.2570c879.webp",w=t.p+"static/image/16df76e7e1053c13fa50ad4d408e87bb.f50fb70b.webp";function A(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",pre:"pre",code:"code",strong:"strong"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"第16章三个简单组件的封装",children:["第16章—三个简单组件的封装",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第16章三个简单组件的封装",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"\uFEFF最近遇到一些组件，它们只是对 api 的一层简易封装，用起来也和直接用 api 差不多。"}),"\n",(0,r.jsx)(n.p,{children:"但是这种组件的下载量还是挺多的。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"今天我们一起来写三个这样的组件，大家来感受下和直接用 api 的区别。"}),"\n",(0,r.jsxs)(n.h2,{id:"portal",children:["Portal",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#portal",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"react 提供了 createPortal 的 api，可以把组件渲染到某个 dom 下。"}),"\n",(0,r.jsx)(n.p,{children:"用起来也很简单："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { createPortal } from 'react-dom'\n\nfunction App() {\n  const content = <div className=\"btn\">\n    <button>按钮</button>\n  </div>;\n\n  return createPortal(content, document.body);\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但我们也可以把它封装成 Portal 组件来用。"}),"\n",(0,r.jsx)(n.p,{children:"接收 attach、children 参数，attach 就是挂载到的 dom 节点，默认是 document.body"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后提供一个 getAttach 方法，如果传入的是 string，就作为选择器来找到对应的 dom，如果是 HTMLElement，则直接作为挂载节点，否则，返回 document.body："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后在 attach 的元素下添加一个 dom 节点作为容器："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当组件销毁时，删除这个容器 dom。"}),"\n",(0,r.jsx)(n.p,{children:"最后，用 createPortal 把 children 渲染到 container 节点下。"}),"\n",(0,r.jsx)(n.p,{children:"此外，通过 forwardRef + useImperativeHandle 把容器 dom 返回："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:O,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { forwardRef, useEffect, useMemo, useImperativeHandle } from 'react';\nimport { createPortal } from 'react-dom';\n\nexport interface PortalProps {\n    attach?: HTMLElement | string;\n    children: React.ReactNode;\n}\n\nconst Portal = forwardRef((props: PortalProps, ref) => {\n  const { \n    attach = document.body, \n    children \n  } = props;\n\n  const container = useMemo(() => {\n    const el = document.createElement('div');\n    el.className = `portal-wrapper`;\n    return el;\n  }, []);\n\n  useEffect(() => {\n    const parentElement = getAttach(attach);\n    parentElement?.appendChild?.(container);\n\n    return () => {\n      parentElement?.removeChild?.(container);\n    };\n  }, [container, attach]);\n\n  useImperativeHandle(ref, () => container);\n\n  return createPortal(children, container);\n});\n\nexport default Portal;\n\nexport function getAttach(attach: PortalProps['attach']) {\n    if (typeof attach === 'string') {\n        return document.querySelector(attach);\n    }\n    if (typeof attach === 'object' && attach instanceof window.HTMLElement) {\n        return attach;\n    }\n\n    return document.body;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"这个 Portal 组件用起来是这样的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import Portal from './portal';\n\nfunction App() {\n  const content = <div className=\"btn\">\n    <button>按钮</button>\n  </div>;\n\n  return <Portal attach={document.body}>\n    {content}\n  </Portal>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(n.p,{children:"还可以通过 ref 获取内部的容器 dom："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef } from 'react';\nimport Portal from './portal';\n\nfunction App() {\n  const containerRef = useRef<HTMLElement>(null);\n\n  const content = <div className=\"btn\">\n    <button>按钮</button>\n  </div>;\n\n  useEffect(()=> {\n    console.log(containerRef);\n  }, []);\n\n  return <Portal attach={document.body} ref={containerRef}>\n    {content}\n  </Portal>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(n.p,{children:"看下效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:M,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个 Portal 组件是对 createPortal 的简单封装。"}),"\n",(0,r.jsx)(n.p,{children:"内部封装了选择 attach 节点的逻辑，还会创建容器 dom 并通过 ref 返回。"}),"\n",(0,r.jsx)(n.p,{children:"还是有一些封装的价值。"}),"\n",(0,r.jsx)(n.p,{children:"再来看一个："}),"\n",(0,r.jsxs)(n.h2,{id:"mutateobserver",children:["MutateObserver",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mutateobserver",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"浏览器提供了 MutationObserver 的 api，可以监听 dom 的变化，包括子节点的变化、属性的变化。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef, useState } from 'react';\n\nexport default function App() {\n  const [ className, setClassName] = useState('aaa');\n\n  useEffect(() => {\n    setTimeout(() => setClassName('bbb'), 2000);\n  }, []);\n\n  const containerRef = useRef(null);\n\n  useEffect(() => {\n    const targetNode = containerRef.current!;\n  \n    const callback = function (mutationsList: MutationRecord[]) {\n      console.log(mutationsList);\n    };\n    \n    const observer = new MutationObserver(callback);\n    \n    observer.observe(targetNode, { \n      attributes: true, \n      childList: true, \n      subtree: true \n    });\n\n  }, []);\n\n  return (\n    <div>\n        <div id=\"container\" ref={containerRef}>\n          <div className={className}>\n            {\n              className === 'aaa' ? <div>aaa</div> : <div>\n                <p>bbb</p>\n              </div>\n            }\n          </div>\n        </div>\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"声明一个 className 的状态，从 aaa 切换到 bbb，渲染的内容也会改变。"}),"\n",(0,r.jsx)(n.p,{children:"用 useRef 获取到 container 的 dom 节点，然后用 MutationObserver 监听它的变化。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，2s 后 dom 发生改变，MutationObserver 监听到了它子节点的变化，属性的变化。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"observe 的时候可以指定 options。"}),"\n",(0,r.jsx)(n.p,{children:"attributes 是监听属性变化，childList 是监听 children 变化，subtree 是连带子节点的属性、children 变化也监听。"}),"\n",(0,r.jsx)(n.p,{children:"attributeFilter 可以指定监听哪些属性的变化。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个 api 用起来也不麻烦，但可以封装成自定义 hooks 或者组件。"}),"\n",(0,r.jsx)(n.p,{children:"ahooks 里就有这个 hook："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而 antd 里更是把它封装成了组件："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样用："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们也来写一下："}),"\n",(0,r.jsx)(n.p,{children:"首先封装 useMutateObserver 的 hook："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useEffect } from \"react\";\n\nconst defaultOptions: MutationObserverInit = {\n  subtree: true,\n  childList: true,\n  attributeFilter: ['style', 'class'],\n};\n\nexport default function useMutateObserver(\n  nodeOrList: HTMLElement | HTMLElement[],\n  callback: MutationCallback,\n  options: MutationObserverInit = defaultOptions,\n) {\n  useEffect(() => {\n    if (!nodeOrList) {\n      return;\n    }\n\n    let instance: MutationObserver;\n\n    const nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];\n\n    if ('MutationObserver' in window) {\n      instance = new MutationObserver(callback);\n\n      nodeList.forEach(element => {\n        instance.observe(element, options);\n      });\n    }\n    return () => {\n      instance?.takeRecords();\n      instance?.disconnect();\n    };\n  }, [options, nodeOrList]);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"支持单个节点，多个节点的 observe。"}),"\n",(0,r.jsx)(n.p,{children:"设置了默认的 options。"}),"\n",(0,r.jsx)(n.p,{children:"在销毁的时候，调用 takeRecords 删掉所有剩余通知，调用 disconnect 停止接收新的通知："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后封装 MutateObserver 组件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React, { useLayoutEffect } from 'react';\nimport useMutateObserver from './useMutateObserver';\n\ninterface MutationObserverProps{\n  options?: MutationObserverInit;\n  onMutate?: (mutations: MutationRecord[], observer: MutationObserver) => void;\n  children: React.ReactElement;\n}\n\nconst MutateObserver: React.FC<MutationObserverProps> = props => {\n  const { \n    options, \n    onMutate = () => {},\n    children, \n  } = props;\n\n  const elementRef = React.useRef<HTMLElement>(null);\n\n  const [target, setTarget] = React.useState<HTMLElement>();\n\n  useMutateObserver(target!, onMutate, options);\n\n  useLayoutEffect(() => {\n    setTarget(elementRef.current!);\n  }, []);\n\n  if (!children) {\n    return null;\n  }\n\n  return React.cloneElement(children, { ref: elementRef });\n}\n\nexport default MutateObserver;\n"})}),"\n",(0,r.jsx)(n.p,{children:"useMutateObserver 的 hook 封装了 MutationObserver 的调用。"}),"\n",(0,r.jsx)(n.p,{children:"而 MutateObserver 组件封装了 ref 的获取。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"通过 React.cloneElement 给 children 加上 ref 来获取 dom 节点。"}),"\n",(0,r.jsx)(n.p,{children:"然后在 useLayoutEffect 里拿到 ref 通过 setState 触发更新。"}),"\n",(0,r.jsx)(n.p,{children:"再次渲染的时候，调用 useMutateObserver 就有 dom 了，可以用 MutationObserver 来监听 dom 变化。"}),"\n",(0,r.jsx)(n.p,{children:"用一下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react';\nimport MutateObserver from './MutateObserver';\n\nexport default function App() {\n  const [ className, setClassName] = useState('aaa');\n\n  useEffect(() => {\n    setTimeout(() => setClassName('bbb'), 2000);\n  }, []);\n\n  const callback = function (mutationsList: MutationRecord[]) {\n    console.log(mutationsList);\n  };\n\n  return (\n    <div>\n        <MutateObserver onMutate={callback}>\n          <div id=\"container\">\n            <div className={className}>\n              {\n                className === 'aaa' ? <div>aaa</div> : <div>\n                  <p>bbb</p>\n                </div>\n              }\n            </div>\n          </div>\n        </MutateObserver>\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"效果一样："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但是现在不用再 useRef 获取 ref 了，MutateObserver 里会做 ref 的获取，然后用 useMutateObserver 来监听。"}),"\n",(0,r.jsx)(n.p,{children:"这个组件和 hook 的封装都算是有用的。"}),"\n",(0,r.jsx)(n.p,{children:"再来看一个"}),"\n",(0,r.jsxs)(n.h2,{id:"copytoclipboard",children:["CopyToClipboard",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#copytoclipboard",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"有这样一个周下载量百万级的组件："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"它是做复制的。"}),"\n",(0,r.jsx)(n.p,{children:"基于 copy-to-clipboard 这个包。"}),"\n",(0,r.jsx)(n.p,{children:"我们也来写写看。"}),"\n",(0,r.jsx)(n.p,{children:"直接用 copy-to-clipboard 是这样的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import copy from 'copy-to-clipboard';\n\nexport default function App() {\n\n  function onClick() {\n    const res = copy('神说要有光666')\n    console.log('done', res);\n  }\n\n  return <div onClick={onClick}>复制</div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"用 react-copy-to-clipboard 是这样的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import {CopyToClipboard} from 'react-copy-to-clipboard';\n\nexport default function App() {\n\n  return <CopyToClipboard text={'神说要有光2'} onCopy={() => {\n    console.log('done')\n  }}>\n    <div>复制</div>\n  </CopyToClipboard>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果元素本来有 onClick 的处理："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import {CopyToClipboard} from 'react-copy-to-clipboard';\n\nexport default function App() {\n\n  return <CopyToClipboard text={'神说要有光2'} onCopy={() => {\n    console.log('done')\n  }}>\n    <div onClick={() => alert(1)}>复制</div>\n  </CopyToClipboard>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"只会在原来的基础上添加复制的功能："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们也来实现下这个组件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React, { EventHandler, FC, PropsWithChildren, ReactElement } from 'react';\nimport copy from 'copy-to-clipboard';\n\ninterface CopyToClipboardProps {\n    text: string;\n    onCopy?: (text: string, result: boolean) => void;\n    children: ReactElement;\n    options?: {\n        debug?: boolean;\n        message?: string;\n        format?: string;\n    }\n}\n\nconst CopyToClipboard: FC<CopyToClipboardProps> = (props) => {\n    const {\n        text,\n        onCopy,\n        children,\n        options\n    } = props;\n\n    const elem = React.Children.only(children);\n\n    function onClick(event: MouseEvent) {    \n        const elem = React.Children.only(children);\n        \n        const result = copy(text, options);\n        \n        if (onCopy) {\n            onCopy(text, result);\n        }\n        \n        if (typeof elem?.props?.onClick === 'function') {\n            elem.props.onClick(event);\n        }\n    }\n\n    return React.cloneElement(elem, { onClick });\n}\n\nexport default CopyToClipboard;\n"})}),"\n",(0,r.jsx)(n.p,{children:"React.Children.only 是用来断言 children 只有一个元素，如果不是就报错："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后用 cloneElement 给元素加上 onClick 事件，执行复制，并且还会调用元素原来的 onClick 事件："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"换成我们自己的组件："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"效果一样："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个组件也挺简单的，作用就是被包装的元素，在原来的 click  事件处理函数的基础上，多了复制文本的功能。"}),"\n",(0,r.jsx)(n.p,{children:"也算是有用的，不用把 copy 写的 onClick 函数里了。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"今天我们实现了三个 react 组件，它们是对 api 的简单封装。"}),"\n",(0,r.jsx)(n.p,{children:"直接用这些 api 也挺简单，但是封装一下会多一些额外的好处。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Portal 组件"}),"：对 createPortal 的封装，多了根据 string 选择 attach 节点，自动创建 container 的 dom 的功能"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"MutateObserver 组件"}),"：对 MutationObserver 的封装，通过 cloneElement 实现了内部自动获取 ref 然后监听的功能，省去了调用方获取 ref 的麻烦。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CopyToClipboard 组件"}),"：对 copy-to-clipboard 包的封装，不用侵入元素的 onClick 处理函数，只是额外多了复制的功能"]}),"\n",(0,r.jsx)(n.p,{children:"这三个 api，直接用也是很简单的，可封装也可不封装。"}),"\n",(0,r.jsx)(n.p,{children:"你会选择直接用，还是封装成组件呢？"})]})}function T(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(A,{...e})}):A(e)}let L=T;T.__RSPRESS_PAGE_META={},T.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC16%E7%AB%A0%E2%80%94%E4%B8%89%E4%B8%AA%E7%AE%80%E5%8D%95%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85.md"]={toc:[{text:"Portal",id:"portal",depth:2},{text:"MutateObserver",id:"mutateobserver",depth:2},{text:"CopyToClipboard",id:"copytoclipboard",depth:2},{text:"总结",id:"总结",depth:2}],title:"第16章—三个简单组件的封装",headingTitle:"第16章—三个简单组件的封装",frontmatter:{}}}}]);