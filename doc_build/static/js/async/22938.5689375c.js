"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["22938"],{438735:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var c=r(552676),t=r(740453);let d=r.p+"static/image/ed35358f6e989d354004be339b616380.af892d30.webp",i=r.p+"static/image/bf115849b12603f19dd6e644fa5db5f4.d50276b6.webp",s=r.p+"static/image/eeeba81b7e79ba3f6313b153f93a9bea.42ac0f72.webp",o=r.p+"static/image/86e2f4744c4e1ebef6b4c44a0e6c2e40.4946b83b.webp",l=r.p+"static/image/b907f1e46b03ee3dbdd497798677b92a.b73d3f00.webp",x=r.p+"static/image/8c4b999864143294636ed77296054d78.13c6762f.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",ul:"ul",li:"li",h3:"h3",h4:"h4",pre:"pre",blockquote:"blockquote",img:"img"},(0,t.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"31原理篇-context原理",children:["31.原理篇-Context原理",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31原理篇-context原理",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["接下来将介绍 ",(0,c.jsx)(n.code,{children:"context"})," 原理。重点流程放在 context 的",(0,c.jsx)(n.strong,{children:"传递"}),"和",(0,c.jsx)(n.strong,{children:"更新"}),"两个方面。对于原理部分，我在这里只介绍了新版本 Context 的原理。感兴趣的同学可以看一下源码。"]}),"\n",(0,c.jsxs)(n.p,{children:["以 ",(0,c.jsx)(n.code,{children:"React 16.8"})," 为例子\uD83C\uDF30："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["新版本 Context 位置：",(0,c.jsx)(n.code,{children:"react-reconciler/src/ReactFiberNewContext.js"})]}),"\n",(0,c.jsxs)(n.li,{children:["老版本 Context 位置：",(0,c.jsx)(n.code,{children:"react-reconciler/src/ReactFiberContext.js"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"希望大家带着这些问题去阅读"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"1 Provder 如何传递 context？"}),"\n",(0,c.jsxs)(n.li,{children:["2 三种获取 context 原理 （ ",(0,c.jsx)(n.code,{children:"Consumer"}),"， ",(0,c.jsx)(n.code,{children:"useContext"}),"，",(0,c.jsx)(n.code,{children:"contextType"})," ）？"]}),"\n",(0,c.jsxs)(n.li,{children:["3 消费 ",(0,c.jsx)(n.code,{children:"context"})," 的组件，context 改变，为什么会订阅更新 （如何实现） 。"]}),"\n",(0,c.jsxs)(n.li,{children:["4 context 更新，如何避免 ",(0,c.jsx)(n.code,{children:"pureComponent"})," ， ",(0,c.jsx)(n.code,{children:"shouldComponentUpdate"})," 渲染控制策略的影响。"]}),"\n",(0,c.jsx)(n.li,{children:"5 如何实现的 context 嵌套传递 （ 多个 Povider ）?"}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"1-context-对象",children:["1 context 对象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-context-对象",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["上述所说的老版本 context 就是 Legacy Context 模式下的 context ，老版本的 context 是采用约定式的使用规则，于是有了 ",(0,c.jsx)(n.code,{children:"getChildContext"})," 和 ",(0,c.jsx)(n.code,{children:"childContextTypes"})," 协商的属性和方法，这种方式不仅不够灵活，而且对于函数组件也存在局限性，所以在 ",(0,c.jsx)(n.code,{children:"v16.3"})," 推出了新版本的 ",(0,c.jsx)(n.code,{children:"context"}),"，开发者能够更加灵活的运用 Context。新版本引入 context 对象的概念，而且 context 对象上除了保留了传递的信息 ",(0,c.jsx)(n.code,{children:"value"})," 外 ， 还有提供者 ",(0,c.jsx)(n.code,{children:"Provder"})," 和消费者 ",(0,c.jsx)(n.code,{children:"Consumer"}),"。"]}),"\n",(0,c.jsxs)(n.h4,{id:"context-对象",children:["context 对象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#context-对象",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["要想吃透 context ，首先要研究一下 Context 对象是什么。上述讲到可以通过 ",(0,c.jsx)(n.code,{children:"createContext"})," 创建一个 context 。那么万物之源就是这个 API ，接下来一起揭开 context 对象面纱。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export function createContext(defaultValue,calculateChangedBits){\n   /* context 对象本质  */ \n  const context  = {\n        $$typeof: REACT_CONTEXT_TYPE, /* 本质上就是 Consumer element 类型 */\n        _calculateChangedBits: calculateChangedBits,\n        _currentValue: defaultValue,\n        _threadCount: 0,\n        Provider: null,\n        Consumer: null,\n  };\n  /* 本质上就是 Provider element 类型。  */\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context,\n  };\n  context.Consumer = context \n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"如上可以很容易的看清楚 context 对象的本质，这里重点介绍三个属性"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"Provider"})})," 本质上是一个 element 对象 $$typeof -> ",(0,c.jsx)(n.code,{children:"REACT_PROVIDER_TYPE"})]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"Consumer"})})," 本质上也是一个 element 对象 $$typeof -> ",(0,c.jsx)(n.code,{children:"REACT_CONTEXT_TYPE"})]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"_currentValue"})})," 这个用来保存传递给  Provider 的 value 。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"provider-提供者",children:["Provider 提供者",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#provider-提供者",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"上述明白了 Provider 本质上是一个特殊的 React Element 对象，那么接下来重点看一下 Provider 的实现原理，研究 Provider 重点围绕这两个点。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Provider 如何传递 context 状态的。"}),"\n",(0,c.jsx)(n.li,{children:"Provider 中 value 改变，如何通知订阅 context。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["之前的章节讲述了 ",(0,c.jsx)(n.strong,{children:"jsx -> element -> fiber"})," 的流程，按照这个逻辑，接下来看一下 Provdier 的处理。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["首先标签形式的 ",(0,c.jsx)(n.code,{children:"<Provider>"})," 本质上就是 ",(0,c.jsx)(n.code,{children:"REACT_PROVIDER_TYPE"})," 的 React Element 。",(0,c.jsx)(n.code,{children:"<Provider>"})," -> ",(0,c.jsx)(n.code,{children:"REACT_PROVIDER_TYPE"})," React element 。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["接下来 element 会转化成 fiber ，fiber 类型为 ",(0,c.jsx)(n.strong,{children:"ContextProvider"})," ， React element ->  ",(0,c.jsx)(n.code,{children:"ContextProvide fiber"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["ContextProvider 类型的 fiber ，在 fiber 调和阶段会进入到 ",(0,c.jsx)(n.code,{children:"beginWork"})," 流程，这个阶段会发生两件事。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["如果当前类型的 fiber 不需要更新，那么会 ",(0,c.jsx)(n.code,{children:"FinishedWork"})," 中止当前节点和子节点的更新。"]}),"\n",(0,c.jsxs)(n.li,{children:["如果当前类型 fiber 需要更新，那么会调用不同类型 fiber 的处理方法。当然 ",(0,c.jsx)(n.code,{children:"ContextProvider"})," 也有特有的 fiber 更新方法 —— ",(0,c.jsx)(n.code,{children:"updateContextProvider"}),"，那么如果想要深入 ",(0,c.jsx)(n.code,{children:"Provder"})," 的奥秘，有必要看一下这个方法做了些什么？"]}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"react-reconciler/src/ReactFiberBeginWork.js"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function updateContextProvider(current ,workInProgress,renderExpirationTime,) {\n  /*  获取 Provder 上的 value  */\n  pushProvider(workInProgress, newProps.value;);\n  /* 更新 context  */\n  if (oldProps !== null) {\n    const changedBits = calculateChangedBits(context, newProps.value;, oldProps.value);\n    if (changedBits === 0) {\n      //context 没有变化。如果孩子们都是一样的话。那么不需要更新\n      if (\n        oldProps.children === newProps.children &&\n        !hasLegacyContextChanged() \n      ) {\n         return ...  // 停止调合子节点,收尾工作\n      }\n    } else { /* context 改变，更新 context */\n      propagateContextChange( workInProgress,context, changedBits, renderExpirationTime,);\n    }\n  }\n  /* 继续向下调和子代 fiber  */\n  ...\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如上保留了 ",(0,c.jsx)(n.code,{children:"updateContextProvider"})," 的核心流程如下："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["第一步： 首先会调用 ",(0,c.jsx)(n.code,{children:"pushProvider"}),"，",(0,c.jsx)(n.code,{children:"pushProvider"})," \b会获取 type 属性上的 _context 对象，就是上述通过 ",(0,c.jsx)(n.code,{children:"createContext"})," 创建的 context 对象。然后将 Provider 的 value 属性，赋值给 context 的 _currentValue 属性上。",(0,c.jsx)(n.strong,{children:"这里解释了 Provder 通过什么手段传递 context value，即通过挂载 context 的 _currentValue 属性。"})]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["第二步： 通过 ",(0,c.jsx)(n.code,{children:"calculateChangedBits"})," 计算出 changedBits ，",(0,c.jsx)(n.code,{children:"calculateChangedBits"})," 内部触发 context 对象上的 ",(0,c.jsx)(n.code,{children:"_calculateChangedBits"})," ，细心的同学可以发现，在调用 ",(0,c.jsx)(n.code,{children:"createContext"})," 的时候，实际上是有第二个参数的 ",(0,c.jsx)(n.code,{children:"calculateChangedBits"}),"，在更新 Provider 的时候这个参数就派上用场了，当它返回的 ",(0,c.jsx)(n.code,{children:"changedBits === 0"})," 的时候，那么还会浅比较 children 是否发生变化，还有就是有没有 ",(0,c.jsx)(n.code,{children:"legacy context"}),"，如果这三点都满足的话，那么会判断当前 Provider 和子节点不需要更新，那么会 return 停止向下调和子节点。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["第三步（",(0,c.jsx)(n.strong,{children:"重点"}),"）：在实际开发中，绝大多数当 value 发生变化，会走 ",(0,c.jsx)(n.code,{children:"propagateContextChange"})," 这个流程，也是 Provider 更新的特点。那么这个方法到底做了些什么呢？接下来重点看一下这个函数做了些什么？"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"propagateContextChange"})," 函数流程很繁琐，这里简化了流程，保留了最核心的部分。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function propagateContextChange(workInProgress,context){\n    let fiber = workInProgress.child;\n    if (fiber !== null) {\n        fiber.return = workInProgress;\n    }\n    while(fiber !== null){\n        const list = fiber.dependencies;\n         while (dependency !== null) {\n              if (dependency.context === context){\n                   /* 类组件：不受 PureComponent 和 shouldComponentUpdate 影响 */\n                   if (fiber.tag === ClassComponent) {\n                         /* 会走 forceUpdate 逻辑 */\n                        const update = createUpdate(renderExpirationTime, null);\n                        update.tag = ForceUpdate;\n                        enqueueUpdate(fiber, update);\n                   }\n                   /* 重要：TODO: 提高 fiber 的优先级，让当前 fiber 可以 beginWork ，并且向上更新父级 fiber 链上的优先级 */\n                   ...\n              } \n         }\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"propagateContextChange"})," 非常重要，它的职责就是深度遍历所有的子代 fiber ，然后找到里面具有 ",(0,c.jsx)(n.code,{children:"dependencies"})," 的属性，对比 dependencies 中的 context 和当前 Provider 的 context 是否是同一个，如果是同一个，那么如果当前 fiber 是类组件，那么会给绑定一个 forceUpdate 标识 。然后会提高  fiber 的更新优先级，让 fiber 在接下来的调和过程中，处于一个高优先级待更新的状态。接下来的代码比较长，我这里没有全部罗列出来，大致逻辑就是，找到当前 fiber 向上的父级链上的 fiber ，统一更新他们的优先级，使之变成高优先级待更新状态。"]}),"\n",(0,c.jsx)(n.p,{children:"那么上述流程中暴露出几个问题："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["1 什么情况下 fiber 会存在 dependencies ，首先 dependencies 在第十七章中会讲到，它保存的是 context 的依赖项，那么什么情况下会存在 ",(0,c.jsx)(n.strong,{children:"context 依赖项"}),"。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["2 为什么对于 class 类组件会创建一个 ForceUpdate 类型的 update 对象呢？ "," 知其然，知其所以然，首先看一下它是什么？"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"｜--------问与答--------｜"})}),"\n",(0,c.jsxs)(n.p,{children:["问： ",(0,c.jsx)(n.strong,{children:"ForceUpdate 类型 update"}),"： 什么是 forceUpdate 类型的 update 呢？"]}),"\n",(0,c.jsxs)(n.p,{children:["答：在类组件中，通过调用 ",(0,c.jsx)(n.code,{children:"this.forceUpdate()"})," 带来的更新就会被打上 ForceUpdate 类型的 update tag，这里可以理解为强制更新。 生命周期章节讲过， 在类组件更新流程中，强制更新会跳过 ",(0,c.jsx)(n.code,{children:"PureComponent"})," 和 ",(0,c.jsx)(n.code,{children:"shouldComponentUpdate"})," 等优化策略。\n",(0,c.jsx)(n.strong,{children:"｜---------end---------｜"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"3 存在 dependency 的 fiber ，为什么要向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"对于上面这三个问题，跟上我的思路逐一突破。"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"第一个问题："}),"\n首先就是 dependencies 属性，这个属性可以把当前的 fiber 和 context 建立起关联，那么可以理解成，使用了当前 context 的 fiber 会把 context 放在 dependencies 中，dependencies 属性本身是一个链表结构，一个 fiber 可以有多个 context 与之对应。反过来推测一下，什么情况下会使用 context 呢。那么有以下几种可能："]}),"\n",(0,c.jsxs)(n.p,{children:["1 有 ",(0,c.jsx)(n.code,{children:"contextType"})," 静态属性指向的类组件。","\n2 使用 ",(0,c.jsx)(n.code,{children:"useContext"})," hooks 的函数组件。 ","\n3 context 提供的 ",(0,c.jsx)(n.code,{children:"Consumer"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["那么可以大胆的推测一下，",(0,c.jsx)(n.strong,{children:"使用过 contextType useContext 的组件对应 fiber,和 Consumer 类型 fiber，会和 dependencies 建立起联系，会把当前消费的 context 放入 dependencies 中。这个下面会给详细解释"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"第二个问题："}),"\n为什么对于 class 组件会创建一个 ForceUpdate 的 update 呢？"]}),"\n",(0,c.jsxs)(n.p,{children:["在",(0,c.jsx)(n.strong,{children:"生命周期章节"}),"和",(0,c.jsx)(n.strong,{children:"渲染控制章节"}),"，讲到过如果想要让类组件调用 render，得到新的 children，那么就要通过 ",(0,c.jsx)(n.code,{children:"PureComponent"})," 和 ",(0,c.jsx)(n.code,{children:"shouldComponentUpdate"})," 等层层阻碍，那么 context 要突破这些控制，就要做到当 value 改变，消费 context 的类组件更新，则需要通过 forceUpdate 强制更新。这样就解决了类组件更新限制。"]}),"\n",(0,c.jsxs)(n.p,{children:["那么总结一下流程，当 Provider 的 value 更新之后，Provider 下面的只要有消费了 context 的类组件，就会触发强制更新。这也就解释了最开始的问题——",(0,c.jsxs)(n.strong,{children:["context 更新，如何避免 ",(0,c.jsx)(n.code,{children:"pureComponent"})," ， ",(0,c.jsx)(n.code,{children:"shouldComponentUpdate"})," 渲染控制策略的影响。"]})," 用一幅流程图表示："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:"context7.jpg"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"第三个问题："})," 这个问题就要从 Provider 类型的 fiber 调和开始讲。"]}),"\n",(0,c.jsxs)(n.h4,{id:"provider-和-beiginwork-调和更新机制",children:["Provider 和 beiginWork 调和更新机制",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#provider-和-beiginwork-调和更新机制",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"接下来重点介绍 Provider 和 beiginWork 调和更新机制。首先引出两个思考点："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"第一个类组件执行 render ，函数组件执行就是渲染么？"}),"\n",(0,c.jsx)(n.li,{children:"第二个 Context 改变如何做到消费 context 的组件更新的？（更新原理）"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["先来看一下第一个思考点，关于渲染的思考，实际上在 React 整个 ",(0,c.jsx)(n.code,{children:"Reconciler"})," 调和流程中，从更新调度任务的发起，再到在 commit 和 render 两大阶段，再到真实的 dom 元素绘制，每一个环节都属于渲染的一部分。而开发者能够控制的 render ，只是其中的一小部分——类组件执行 render ，函数组件执行。而且这些本质上都发生在 FunctionComponent fiber 和 ClassComponent fiber 上。但是整个 fiber 树在调和阶段都需要更新的。更新调和 fiber 的方法在 React 底层叫做 ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"beginWork"})}),"。有一个问题需要注意，就是 ",(0,c.jsx)(n.code,{children:"beginWork"})," 非 render。先来看看两者的区别。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"beginWork"})," ： 在一次更新中，只要需要更新的 fiber 或者受到牵连的 fiber，都会执行 beginWork 。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"render"}),"   ： 在一次更新中，只有组件类型的 fiber 会执行 render ，得到新的 children 。如果组件触发 render 那么它一定经历过 ",(0,c.jsx)(n.code,{children:"beginWork"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"这里如果有同学不明白不要紧，接着往下看。"}),"\n",(0,c.jsxs)(n.p,{children:["比如发生一次更新任务，此次更新可能发生整个 fiber 树的任意枝叶上，但是因为 context props 穿透影响，React 不知道此次更新的波及范围，那么如何处理呢？ React 会从 rootFiber 开始更新，每一个更新 fiber 都会走 ",(0,c.jsx)(n.code,{children:"beginWork"})," 流程，开始找不同，找到有没有需要更新的地方，那么指标是什么呢，其中一个重要的指标就是",(0,c.jsx)(n.strong,{children:"更新的优先级"}),"，老版本用的是 ",(0,c.jsx)(n.code,{children:"expirationTime"})," ，新版本用的是 ",(0,c.jsx)(n.code,{children:"lane"}),"，那么就要保证一个问题，就是如果更新发生在一个子代节点，那么只有父节点 ",(0,c.jsx)(n.code,{children:"beginWork"})," 才能让子代节点 ",(0,c.jsx)(n.code,{children:"beginWork"}),"。这样就形成了一条 root fiber -> 父 fiber -> 子 fiber 的 ",(0,c.jsx)(n.code,{children:"beginWork"})," 链。在 beginwork 过程中，有几种情况："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"第一种： 如果遇到组件，而且更新不涉及当前组件，也不在当前组件的父子递归链上，那么就不会 render，也不会向下 beginWork 。"}),"\n",(0,c.jsx)(n.li,{children:"第二种： 如果遇到组件，而且更新不涉及当前组件，但是更新组件属于当前组件的子孙后代，那么不会 render，但是会向下 beginWork ，目的很明确，找到对应的更新组件。"}),"\n",(0,c.jsxs)(n.li,{children:["第三种： 如果遇到其他类型的 fiber 比如 hostComponent  ",(0,c.jsx)(n.code,{children:"<div>"})," ，那么会对比当前的更新优先级，如果低优先级，那么不需要向下 beginWork 。反之向下 beginWork。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"这么说可能大家不是很理解，我举一个例子："}),"\n",(0,c.jsx)(n.p,{children:"如下当点击 componentB 下面的 span 触发 setState 更新 ，如下可以清晰看见 beginWork 和 render 流程。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:"context8.jpg"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["从 root 开始第一次调和， 三个 fiber 都会经历 beginWork ，通过对比优先级， ",(0,c.jsx)(n.code,{children:"componentA"})," 和 ",(0,c.jsx)(n.code,{children:"div"})," 停止向下 beginwork。"]}),"\n",(0,c.jsxs)(n.li,{children:["更新发生在 componentB ，所以 componentB 渲染，触发 ",(0,c.jsx)(n.code,{children:"render"})," ，得到新的 element，通过对比， ",(0,c.jsx)(n.code,{children:"div"})," ",(0,c.jsx)(n.code,{children:"span"})," 都会 beginwork。"]}),"\n",(0,c.jsxs)(n.li,{children:["componentC 由于父组件更新，没有任何优化策略的情况，那么也会跟着 ",(0,c.jsx)(n.code,{children:"render"}),"，接着 div 也会跟着 beginwork。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["那么如上，如果 componentC 通过 ",(0,c.jsx)(n.code,{children:"PureComponent"})," 或者 ",(0,c.jsx)(n.code,{children:"shouldComponentUpdate"})," 限制更新之后。那么会变成如下的样子："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:"context9.jpg"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["如上 componentC 通过 ",(0,c.jsx)(n.code,{children:"PureComponent"})," 处理后，不再 render ，当然也不会再向下 beginwork。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"接下来，如果点击 componentC 下的 div，触发 setState 更新，那么又会发生什么呢？"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["此时更新发生在 ",(0,c.jsx)(n.code,{children:"componentC"})," 上，所以 componentB 只会发生 beginwork ，不会发生 render。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"componentB"})," 下面的 ",(0,c.jsx)(n.code,{children:"div"})," 会停止向下的 beiginwork 。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:"context10.jpg"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"我们总结流程如下："})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"1 如果一个组件发生更新，那么当前组件到 fiber root 上的父级链上的所有 fiber ，更新优先级都会升高，都会触发 beginwork 。"}),"\n",(0,c.jsx)(n.li,{children:"2 render 不等于 beginWork，但是 render 发生，一定触发了 beginwork 。"}),"\n",(0,c.jsx)(n.li,{children:"3 一次 beginwork ，一个 fiber 下的同级兄弟 fiber 会发生对比，找到任务优先级高的 fiber 。向下 beginwork 。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"对于 beginwork 的流程，接下来会有专门的章节维护。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"Context 原理"})}),"\n",(0,c.jsxs)(n.p,{children:["接下来言归正传，我们来研究一下 context 的更新原理，上面说到 ",(0,c.jsx)(n.code,{children:"Provider"})," 更新，会递归所有的子组件，只要消费了 context 的子代 fiber ，都会给一个高优先级。而且向上更新父级 fiber 链上的优先级，让所有父级 fiber 都处于一个高优先级。那么接下来高优先级的 fiber 都会 beginWork 。"]}),"\n",(0,c.jsxs)(n.p,{children:["那么将上述例子进行修改，",(0,c.jsx)(n.code,{children:"propagateContextChange"})," 的流程会下如下一样，把父级 fiber 的优先级提高。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:"context11.jpg"})}),"\n",(0,c.jsx)(n.p,{children:"那么整个 fiber 更新流程会像如下一样"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:"context12.jpg"})}),"\n",(0,c.jsxs)(n.h3,{id:"2-consumer",children:["2 Consumer",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-consumer",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我们已经讲了 Provider 核心原理，还有另外一部分就是 Consumer ，研究一下其原理。"}),"\n",(0,c.jsxs)(n.h4,{id:"consumer-流程",children:["Consumer 流程",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#consumer-流程",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["上文说道，Consumer 本质上是类型为 ",(0,c.jsx)(n.code,{children:"REACT_CONTEXT_TYPE"})," 的 element 对象。在调和阶段，会转化成 ",(0,c.jsx)(n.code,{children:"ContextConsumer"})," 类型的 fiber 对象。在 beginwork 中，会调用 ",(0,c.jsx)(n.code,{children:"updateContextConsumer"})," 方法。那么这个方法做了些什么呢？"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"react/react-reconcider/src/ReactFiberBeginWork.js"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function updateContextConsumer(current,workInProgress,renderExpirationTime,) {\n  let context  = workInProgress.type;\n  const newProps = workInProgress.pendingProps;\n  /* 得到 render props children */\n  const render = newProps.children;\n  /* 读取 context */ \n  prepareToReadContext(workInProgress, renderExpirationTime);\n  /* 得到最新的新的 context value */\n  const newValue = readContext(context, newProps.unstable_observedBits);\n  let newChildren;\n  /* 得到最新的 children element */\n  newChildren = render(newValue);\n  workInProgress.effectTag |= PerformedWork;\n  /* 调和 children */\n  reconcileChildren(current, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"updateContextConsumer"}),"的核心流程："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["首先调用 ",(0,c.jsx)(n.code,{children:"readContext"})," 获取最新的 value 。"]}),"\n",(0,c.jsxs)(n.li,{children:["然后通过 ",(0,c.jsx)(n.code,{children:"render props"})," 函数，传入最新的 value，得到最新的 ",(0,c.jsx)(n.code,{children:"children"})," 。"]}),"\n",(0,c.jsx)(n.li,{children:"接下来调和 children 。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["那么有一个问题",(0,c.jsx)(n.strong,{children:"就是 fiber 上的 dependencies 如何和 context 建立起关联。"})," 那么就是 ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"readContext"})})," 这个函数做的事，可以提前透露一下，useContext 和 contextType 本质上也是"]}),"\n",(0,c.jsxs)(n.h4,{id:"readcontext",children:["readContext",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#readcontext",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["readContext 是除了 ",(0,c.jsx)(n.code,{children:"Provider"})," 之外，第二个核心知识点。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"react/react-reconcider/src/ReactFiberNewContext.js"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export function readContext( context,observedBits ){\n    /* 创建一个 contextItem */\n    const contextItem = {\n      context,\n      observedBits: resolvedObservedBits,\n      next: null,\n    };\n    /* 不存在最后一个 context Dependency  */\n    if (lastContextDependency === null) {\n      lastContextDependency = contextItem;\n      currentlyRenderingFiber.dependencies = {\n        expirationTime: NoWork,\n        firstContext: contextItem,\n        responders: null,\n      };\n    } else {\n      /* 存在的情况 */\n      lastContextDependency = lastContextDependency.next = contextItem;\n    }\n   \n  return isPrimaryRenderer ? context._currentValue : context._currentValue2;\n}\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["readContext 主要做的事情是这样的，首先会创建一个 contextItem ，上述说到过 fiber 上会存在多个 ",(0,c.jsx)(n.code,{children:"dependencies"})," ，它们以链表的形式联系到一起，如果不存在最后一个 ",(0,c.jsx)(n.code,{children:"context dependency"})," ，那证明 context dependencies 为空 ，那么会创建第一个 dependency ，如果存在最后一个 dependency ，那么 contextItem 会以链表形式保存，并变成最后一个 lastContextDependency 。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"多个-provider-嵌套",children:["多个 Provider 嵌套",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#多个-provider-嵌套",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果有多个 Provider 的情况，那么后一个 contextValue 会覆盖前一个 contextValue，在开发者脑海中，要有一个定律就是：",(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.code,{children:"Provider"})," 是用来传递 value，而非保存 value 。"]})]}),"\n",(0,c.jsxs)(n.h3,{id:"3-contexttype-和-usecontext",children:["3 contextType 和 useContext",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-contexttype-和-usecontext",children:"#"})]}),"\n",(0,c.jsxs)(n.h4,{id:"usecontext-原理",children:["useContext 原理",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecontext-原理",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"useContext"})," 原理，调用 useContext 本质上调用 ",(0,c.jsx)(n.code,{children:"readContext"})," 方法。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"react/react-reconcider/src/ReactFiberHooks.js"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const HooksDispatcherOnMount ={\n    useContext: readContext\n}\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["函数组件通过 readContext ，将函数组件的 ",(0,c.jsx)(n.code,{children:"dependencies"}),"和当前 context 建立起关联，context 改变，将当前函数组件设置高优先级，促使其渲染。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"contexttype-原理",children:["contextType 原理",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#contexttype-原理",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["类组件的静态属性 ",(0,c.jsx)(n.code,{children:"contextType"})," 和 useContext 一样，本质上就是调用 readContext 方法。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"react/react-reconcider/src/ReactFiberClassComponent.js"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function constructClassInstance(workInProgress,ctor,props){\n     if (typeof contextType === 'object' && contextType !== null) {\n         /* 读取 context  */\n        context = readContext(contextType);\n    } \n\n    const instance = new ctor(props, context);\n}\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["静态属性 contextType ，在类组件实例化的时候被使用，本质上也是调用 ",(0,c.jsx)(n.code,{children:"readContext"}),"将 context 和 fiber 上的  ",(0,c.jsx)(n.code,{children:"dependencies"})," 建立起关联。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"4-context-流程总结",children:["4 Context 流程总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-context-流程总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"下面对整个 context 原理部分做总结。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"Provider 传递流程：Provider 的更新，会深度遍历子代 fiber，消费 context 的 fiber 和父级链都会提升更新优先级。 对于类组件的 fiber ，会 forceUpdate 处理。接下来所有消费的 fiber，都会 beginWork 。"}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["context 订阅流程： ",(0,c.jsx)(n.code,{children:"contextType"})," ， ",(0,c.jsx)(n.code,{children:"useContext"}),"， ",(0,c.jsx)(n.code,{children:"Consumer"})," 会内部调用 ",(0,c.jsx)(n.code,{children:"readContext"})," ，readContext 会把 fiber 上的 ",(0,c.jsx)(n.code,{children:"dependencies"})," 属性和 context 对象建立起关联。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"5-总结",children:["5 总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"本章节知识点总结:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"context 原理，Provider 做了些什么。"}),"\n",(0,c.jsx)(n.li,{children:"beginWork 和 render 的更新原则和区别。"}),"\n",(0,c.jsx)(n.li,{children:"三种 context 传递模式原理。"}),"\n",(0,c.jsx)(n.li,{children:"context 订阅消费原理。"}),"\n",(0,c.jsx)(n.li,{children:"Provider 嵌套传递原理。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"透漏一下，接下来会更新另外一个新的章节 fiber 初始化和调和流程。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}let j=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F31.%E5%8E%9F%E7%90%86%E7%AF%87-Context%E5%8E%9F%E7%90%86.md"]={toc:[{text:"1 context 对象",id:"1-context-对象",depth:3},{text:"context 对象",id:"context-对象",depth:4},{text:"Provider 提供者",id:"provider-提供者",depth:4},{text:"Provider 和 beiginWork 调和更新机制",id:"provider-和-beiginwork-调和更新机制",depth:4},{text:"2 Consumer",id:"2-consumer",depth:3},{text:"Consumer 流程",id:"consumer-流程",depth:4},{text:"readContext",id:"readcontext",depth:4},{text:"多个 Provider 嵌套",id:"多个-provider-嵌套",depth:4},{text:"3 contextType 和 useContext",id:"3-contexttype-和-usecontext",depth:3},{text:"useContext 原理",id:"usecontext-原理",depth:4},{text:"contextType 原理",id:"contexttype-原理",depth:4},{text:"4 Context 流程总结",id:"4-context-流程总结",depth:3},{text:"5 总结",id:"5-总结",depth:3}],title:"31.原理篇-Context原理",headingTitle:"31.原理篇-Context原理",frontmatter:{}}}}]);