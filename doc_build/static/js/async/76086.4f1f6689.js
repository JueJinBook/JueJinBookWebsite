"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["76086"],{663813:function(n,e,i){i.r(e),i.d(e,{default:()=>a});var s=i(552676),r=i(740453);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"30手写-babel-traverse----scope篇",children:["30.手写 Babel： traverse -- scope篇",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#30手写-babel-traverse----scope篇",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"path.scope 中记录着作用域相关的数据，通过 scope 可以拿到整条作用域链，包括声明的变量和对该声明的引用。"}),"\n",(0,s.jsx)(e.p,{children:"这节我们实现下 scope。"}),"\n",(0,s.jsxs)(e.h2,{id:"思路分析",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"前面我们实现了 traverse 和 path，能够遍历 AST 和对 AST 增删改了，而 scope 和 path 一样也是遍历过程中记录的信息。"}),"\n",(0,s.jsx)(e.p,{children:"能生成 scope 的 AST 叫做 block，比如 FunctionDeclaration 就是 block，因为它会生成一个新的 scope。"}),"\n",(0,s.jsx)(e.p,{children:"我们把这类节点记录下来，遍历的时候遇到 block 节点会生成新的 scope，否则拿之前的 scope。"}),"\n",(0,s.jsx)(e.p,{children:"scope 中记录着 bindings，也就是声明，每个声明会记录在哪里声明的，被哪里引用的。"}),"\n",(0,s.jsx)(e.p,{children:"遇到 block 节点，创建 scope 的时候，要遍历作用域中的所有声明（VariableDeclaraion、FunctionDeclaration），记录该 binding 到 scope 中。"}),"\n",(0,s.jsx)(e.p,{children:"记录完 bindings 之后还要再遍历一次记录引用这些 binding 的 reference。"}),"\n",(0,s.jsx)(e.p,{children:"基于这种思路我们就能实现 scope 的功能。"}),"\n",(0,s.jsxs)(e.h2,{id:"代码实现",children:["代码实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"首先，创建 Binding 类和 Scope 类："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class Binding {\n    constructor(id, path, scope, kind) {\n        this.id = id;\n        this.path = path;\n        this.referenced = false;\n        this.referencePaths = [];\n    }\n}\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class Scope {\n    constructor(parentScope, path) {\n        this.parent = parentScope;\n        this.bindings = {};\n        this.path = path;\n    }\n\n    registerBinding(id, path) {\n        this.bindings[id] = new Binding(id, path);\n    }\n\n    getOwnBinding(id) {\n        return this.bindings[id];\n    }\n\n    getBinding(id) {\n        let res = this.getOwnBinding(id);\n        if (res === undefined && this.parent) {\n            res = this.parent.getOwnBinding(id);\n        }\n        return res;\n    }\n\n    hasBinding(id) {\n        return !!this.getBinding(id);\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"bindings 是记录作用域中的每一个声明，同时我们还可以实现 添加声明 registerBinding、查找声明 getBinding、getOwnBinding、hasBidning 的方法。"}),"\n",(0,s.jsx)(e.p,{children:"getOwnBing 是只从当前 scope 查找，而 getBinding 则是顺着作用域链向上查找。"}),"\n",(0,s.jsx)(e.p,{children:"之后我们在 path 里面定义一个  scope 的 get 的方法，当需要用到 scope 的时候才会创建，因为 scope 创建之后还要遍历查找 bindings，是比较耗时的，实现 get 可以做到用到的时候才创建。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"get scope() {\n    if (this.__scope) {\n        return this.__scope;\n    }\n    const isBlock = this.isBlock();\n    const parentScope = this.parentPath && this.parentPath.scope;\n    return this.__scope = isBlock ? new Scope(parentScope, this) : parentScope;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这里的 isBlock 方法的实现就是从我们记录的数据中查找该节点是否是 block，也就是是否是函数声明这种能生成作用域的节点。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"isBlock() {\n    return types.visitorKeys.get(this.node.type).isBlock;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"我们在记录节点的遍历的属性的时候，也记录了该节点是否是 block："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"astDefinationsMap.set('Program', {\n    visitor: ['body'],\n    isBlock: true\n});\nastDefinationsMap.set('FunctionDeclaration', {\n    visitor: ['id', 'params', 'body'],\n    isBlock: true\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样，当遍历到 block 节点的时候，就会创建 Scope 对象，然后和当前 Scope 关联起来，形成作用域链。"}),"\n",(0,s.jsx)(e.p,{children:"scope 创建完成之后我们要扫描作用域中所有的声明，记录到 scope。这里要注意的是，因为遇到函数作用域要跳过遍历，因为它有自己独立的作用域。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"path.traverse({\n    VariableDeclarator: (childPath) => {\n        this.registerBinding(childPath.node.id.name, childPath);\n    },\n    FunctionDeclaration: (childPath) => {\n        childPath.skip();\n        this.registerBinding(childPath.node.id.name, childPath);\n    }\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"记录完 binding 之后，再扫描所有引用该 binding 的地方，也就是扫描所有的 identifier。"}),"\n",(0,s.jsx)(e.p,{children:"这里要排除声明语句里面的 identifier，那个是定义变量不是引用变量。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"path.traverse({\n    Identifier: childPath =>  {\n        if (!childPath.findParent(p => p.isVariableDeclarator() || p.isFunctionDeclaration())) {\n            const id = childPath.node.name;\n            const binding = this.getBinding(id);\n            if (binding) {\n                binding.referenced = true;\n                binding.referencePaths.push(childPath);\n            }\n        }\n    }\n});\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样，我们就实现了作用域链 path.scope，可以在 visitor 中分析作用域了。"}),"\n",(0,s.jsx)(e.p,{children:"比如删除掉未被引用的变量："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"traverse(ast, {\n    Program(path) {\n        Object.entries(path.scope.bindings).forEach(([id, binding]) => {\n            if (!binding.referenced) {\n                binding.path.remove();\n            }\n        });\n    },\n    FunctionDeclaration(path) {\n        Object.entries(path.scope.bindings).forEach(([id, binding]) => {\n            if (!binding.referenced) {\n                binding.path.remove();\n            }\n        });\n    }\n});\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"scope 是作用域相关的信息，记录着每一个声明（binding）和对该声明的引用（reference）。"}),"\n",(0,s.jsx)(e.p,{children:"只有 block 节点需要生成 scope，所以我们会记录什么节点是 block 节点，遇到 block 节点会生成 scope，否则拿之前的。"}),"\n",(0,s.jsx)(e.p,{children:"因为 scope 会遍历 AST 来注册 binding，还是比较耗时的。我们在 path 中定义了 scope 的 get 方法，用到的时候才会创建 scope。"}),"\n",(0,s.jsx)(e.p,{children:"创建 scope 时会扫描作用域中的函数声明、变量声明，记录到 bindings 中，并且提供了 getBinding、getOwnBinding、hasBinding、registerBinding 等方法。"}),"\n",(0,s.jsx)(e.p,{children:"之后再次扫描作用域，找到所有引用这些 binding 的 identifier，记录到 reference 中。"}),"\n",(0,s.jsx)(e.p,{children:"之后我们就可以在 visitor 中分析 scope 来实现类似死代码删除等功能了。"}),"\n",(0,s.jsxs)(e.p,{children:["（代码在",(0,s.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F30.%E6%89%8B%E5%86%99%20Babel%EF%BC%9A%20traverse%20--%20scope%E7%AF%87.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"总结",id:"总结",depth:2}],title:"30.手写 Babel： traverse -- scope篇",headingTitle:"30.手写 Babel： traverse -- scope篇",frontmatter:{}}}}]);