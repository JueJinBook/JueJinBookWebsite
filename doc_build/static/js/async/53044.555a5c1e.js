"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["53044"],{758289:function(e,n,r){e.exports=r.p+"static/image/4c83722f36df31afd109bcd4f73382ae.d8ebe1d2.webp"},29627:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r(552676),c=r(740453),d=r(758289);function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",code:"code",pre:"pre",ul:"ul",li:"li",img:"img"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"2响应式系统的基本原理",children:["2.响应式系统的基本原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2响应式系统的基本原理",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"响应式系统",children:["响应式系统",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#响应式系统",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「",(0,s.jsx)(n.strong,{children:"响应式系统"}),"」。尽管我们在使用 Vue.js 进行开发时不会直接修改「",(0,s.jsx)(n.strong,{children:"响应式系统"}),"」，但是理解它的实现有助于避开一些常见的「",(0,s.jsx)(n.strong,{children:"坑"}),"」，也有助于在遇见一些琢磨不透的问题时可以深入其原理来解决它。"]}),"\n",(0,s.jsxs)(n.h2,{id:"objectdefineproperty",children:[(0,s.jsx)(n.code,{children:"Object.defineProperty"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectdefineproperty",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先我们来介绍一下 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"Object.defineProperty"})}),"，Vue.js就是基于它实现「",(0,s.jsx)(n.strong,{children:"响应式系统"}),"」的。"]}),"\n",(0,s.jsx)(n.p,{children:"首先是使用方法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/*\n    obj: 目标对象\n    prop: 需要操作的目标对象的属性名\n    descriptor: 描述符\n    \n    return value 传入对象\n*/\nObject.defineProperty(obj, prop, descriptor)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["descriptor的一些属性，简单介绍几个属性，具体可以参考 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",target:"_blank",rel:"noopener noreferrer",children:"MDN 文档"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enumerable"}),"，属性是否可枚举，默认 false。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"configurable"}),"，属性是否可以被修改或者删除，默认 false。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"get"}),"，获取属性的方法。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"set"}),"，设置属性的方法。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"实现-observer可观察的",children:["实现 ",(0,s.jsx)(n.code,{children:"observer"}),"（可观察的）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-observer可观察的",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["知道了 ",(0,s.jsx)(n.code,{children:"Object.defineProperty"})," 以后，我们来用它使对象变成可观察的。"]}),"\n",(0,s.jsxs)(n.p,{children:["这一部分的内容我们在第二小节中已经初步介绍过，在 ",(0,s.jsx)(n.code,{children:"init"})," 的阶段会进行初始化，对数据进行「",(0,s.jsx)(n.strong,{children:"响应式化"}),"」。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"为了便于理解，我们不考虑数组等复杂的情况，只对对象进行处理。"}),"\n",(0,s.jsxs)(n.p,{children:["首先我们定义一个 ",(0,s.jsx)(n.code,{children:"cb"})," 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function cb (val) {\n    /* 渲染视图 */\n    console.log("视图更新啦～");\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["然后我们定义一个 ",(0,s.jsx)(n.code,{children:"defineReactive"})," ，这个方法通过 ",(0,s.jsx)(n.code,{children:"Object.defineProperty"})," 来实现对对象的「",(0,s.jsx)(n.strong,{children:"响应式"}),"」化，入参是一个 obj（需要绑定的对象）、key（obj的某一个属性），val（具体的值）。经过 ",(0,s.jsx)(n.code,{children:"defineReactive"})," 处理以后，我们的 obj 的 key 属性在「读」的时候会触发 ",(0,s.jsx)(n.code,{children:"reactiveGetter"})," 方法，而在该属性被「写」的时候则会触发 ",(0,s.jsx)(n.code,{children:"reactiveSetter"})," 方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function defineReactive (obj, key, val) {\n    Object.defineProperty(obj, key, {\n        enumerable: true,       /* 属性可枚举 */\n        configurable: true,     /* 属性可被修改或删除 */\n        get: function reactiveGetter () {\n            return val;         /* 实际上会依赖收集，下一小节会讲 */\n        },\n        set: function reactiveSetter (newVal) {\n            if (newVal === val) return;\n            cb(newVal);\n        }\n    });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当然这是不够的，我们需要在上面再封装一层 ",(0,s.jsx)(n.code,{children:"observer"})," 。这个函数传入一个 value（需要「",(0,s.jsx)(n.strong,{children:"响应式"}),"」化的对象），通过遍历所有属性的方式对该对象的每一个属性都通过 ",(0,s.jsx)(n.code,{children:"defineReactive"})," 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function observer (value) {\n    if (!value || (typeof value !== 'object')) {\n        return;\n    }\n    \n    Object.keys(value).forEach((key) => {\n        defineReactive(value, key, value[key]);\n    });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最后，让我们用 ",(0,s.jsx)(n.code,{children:"observer"})," 来封装一个 Vue 吧！"]}),"\n",(0,s.jsxs)(n.p,{children:["在 Vue 的构造函数中，对 ",(0,s.jsx)(n.code,{children:"options"})," 的 ",(0,s.jsx)(n.code,{children:"data"})," 进行处理，这里的 ",(0,s.jsx)(n.code,{children:"data"})," 想必大家很熟悉，就是平时我们在写 Vue 项目时组件中的 ",(0,s.jsx)(n.code,{children:"data"})," 属性（实际上是一个函数，这里当作一个对象来简单处理）。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class Vue {\n    /* Vue构造类 */\n    constructor(options) {\n        this._data = options.data;\n        observer(this._data);\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这样我们只要 new 一个 Vue 对象，就会将 ",(0,s.jsx)(n.code,{children:"data"})," 中的数据进行「",(0,s.jsx)(n.strong,{children:"响应式"}),"」化。如果我们对 ",(0,s.jsx)(n.code,{children:"data"})," 的属性进行下面的操作，就会触发 ",(0,s.jsx)(n.code,{children:"cb"})," 方法更新视图。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let o = new Vue({\n    data: {\n        test: "I am test."\n    }\n});\no._data.test = "hello,world.";  /* 视图更新啦～ */\n'})}),"\n",(0,s.jsxs)(n.p,{children:["至此，响应式原理已经介绍完了，接下来让我们学习「",(0,s.jsx)(n.strong,{children:"响应式系统"}),"」的另一部分 ——「",(0,s.jsx)(n.strong,{children:"依赖收集"}),"」。"]}),"\n",(0,s.jsxs)(n.p,{children:["注：本节代码参考",(0,s.jsx)(n.a,{href:"https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E3%80%8B.js",target:"_blank",rel:"noopener noreferrer",children:"《响应式系统的基本原理》"}),"。"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let l=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["%E5%89%96%E6%9E%90%20Vue.js%20%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F2.%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md"]={toc:[{text:"响应式系统",id:"响应式系统",depth:2},{text:"`Object.defineProperty`",id:"objectdefineproperty",depth:2},{text:"实现 `observer`（可观察的）",id:"实现-observer可观察的",depth:2}],title:"2.响应式系统的基本原理",headingTitle:"2.响应式系统的基本原理",frontmatter:{}}}}]);