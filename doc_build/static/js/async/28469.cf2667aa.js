"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["28469"],{567755:function(e,n,i){e.exports=i.p+"static/image/ad576f2b5d1f43e8cbf04f10dfac6d21.cc6ba228.webp"},234684:function(e,n,i){e.exports=i.p+"static/image/be23631286693935a179bad5468db147.6f57c6a4.webp"},700665:function(e,n,i){i.r(n),i.d(n,{default:()=>Z});var t=i(552676),r=i(740453);let c=i.p+"static/image/c2a4679c37fbaddded25aaeb49b9f956.0a9edad8.gif",s=i.p+"static/image/4882f69ab1bcb4a40af7a05c9a6f0469.7a91b7a8.gif",a=i.p+"static/image/c6c2e12912c4bd30295b25fc58e15627.9cc63011.gif",l=i.p+"static/image/e5c7f9268ecce3ed370057e9b5f3b945.44a2d011.webp",o=i.p+"static/image/8391294c8b4fc4424565b15b604a6c8f.a413766a.webp",d=i.p+"static/image/4b147233ebd041442d758215a29f9920.7f3c8ff3.webp",p=i.p+"static/image/550dfee404412718c8d83dd6390522ec.1b334f33.webp",f=i.p+"static/image/fcb18a8f454ec4889a2d3dfd0ff8538a.55364c5e.webp",b=i.p+"static/image/30c824a0509210d2b3405b07246deed8.486b3b00.webp",h=i.p+"static/image/0d370a1a55580f6761380df3ebdd2568.28868265.webp",x=i.p+"static/image/a78bfcdcf680aacdd8bc55aa81c0dc81.2b591865.webp",m=i.p+"static/image/2dca10d0ef63bbf631a48fb42bc63d8a.1df13f0d.webp",j=i.p+"static/image/ee76f9a4fe22f51d7bc12782b7b9a267.30f8432a.webp",u=i.p+"static/image/b861d7aa39d1759deb4b66e8140bc57d.912a0c23.webp",g=i.p+"static/image/986c9721de5272fd689dd1109bdfa9f3.cf90dfe8.webp",k=i.p+"static/image/7208f9e5dacf1ed00d76dbdb88e7e2ec.b4898b42.webp",w=i.p+"static/image/f5ec1fb5346c6c3c159c95ac059337b6.ac9ecab3.webp",E=i.p+"static/image/6b804d32ac85b6d8022fba11b552b026.a4cd77a2.webp",v=i.p+"static/image/344cc5f57c88e6480b8a3e709a57b749.2093ca52.webp",F=i.p+"static/image/165089878c484912e5cede1b624b2d7c.9409c661.webp",y=i.p+"static/image/a5c1d97ab489c187f589e79427fefa63.75233101.webp",R=i.p+"static/image/b70af7f3aec4f0be579f0a7ce842991f.11b847f8.webp",C=i.p+"static/image/dd9bc6352054b3e581947edd554db2fa.e6a54f4d.webp",H=i.p+"static/image/138d3eb13daac4b5724ba0e8468b9e54.cd939239.webp",S=i.p+"static/image/8f1451a69a5057798a4206a5b9c7abcb.58d75c11.webp",N=i.p+"static/image/bba334b92dfdb525876601e48aaac5cb.67bdac1b.webp",T=i.p+"static/image/4c0992f7456394143884be018d8dfad4.51eebd3e.webp",P=i.p+"static/image/11ebf4bcbf1808924b81df7b2e2b5a09.874dd927.webp",O=i.p+"static/image/02d9cce310fe74eeaced19ba8cf65f2c.3799991e.webp",W=i.p+"static/image/524db1cf16351d0223f177fa6346dca5.c3ce7a35.webp",A=i.p+"static/image/d329bf6f2953b8adaef46b9cf50c9f7d.0624ad67.webp",U=i.p+"static/image/55148d8bf40f05f3c33826476b55873c.bb24649c.webp",D=i.p+"static/image/b7dd500fde90148bc6c9816dd5fe2aff.02b21098.webp";var I=i(567755);let _=i.p+"static/image/592ab915e4e022fba0e95af219f827ae.138da565.webp",M=i.p+"static/image/288caba7bf5d93593188d26eed0470e5.b26cef4c.webp",q=i.p+"static/image/ce2fc577770e049e97765e7f1248c9c3.d9b7d96d.webp",B=i.p+"static/image/82c1010f948b5a897e72a95477a8af59.fa3bec55.webp",L=i.p+"static/image/46ee6408e3e544db4ad62c78dcc72c89.d7ffeef2.webp",J=i.p+"static/image/e74a316f21bc8da77b349842a4e6c483.c80c6bf5.webp",X=i.p+"static/image/d0f480f8f2bde425a7907675c4e17e88.382b47ee.webp",G=i.p+"static/image/6830479d6b20a397c08696fb6ff9dca0.08e5739c.webp",Y=i.p+"static/image/e268b06bad3b1d0c2f3a99be906e2754.56921ab1.webp",V=i.p+"static/image/df6dbbf021d2a7d619f2ac43cba18fd5.f5fefa51.webp";var z=i(234684);function Q(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"第63章手写minireact代码实现",children:["第63章—手写MiniReact：代码实现",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第63章手写minireact代码实现",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"\uFEFF上节我们梳理了 React 渲染流程，这节来具体实现下。"}),"\n",(0,t.jsx)(n.p,{children:"首先先完成从 JSX 到 React Element 的转换："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:z,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"从 JSX 到 render function 这步是 babel 或者 tsc 帮我们做的。"}),"\n",(0,t.jsx)(n.p,{children:"新建个项目："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"mkdir mini-react\ncd mini-react\nnpm init -y\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:V,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"安装 typescript："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install --save-dev typescript\n"})}),"\n",(0,t.jsx)(n.p,{children:"创建 tsconfig.json 配置文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx tsc --init\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:Y,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"改一下生成的 tsconfig.json"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    "outDir": "dist",\n    "target": "es2016",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    "jsx": "react",                                /* Specify what JSX code is generated. */\n    "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. \'React.createElement\' or \'h\'. */\n    "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the \'checkJS\' option to get errors from these files. */\n    "strict": true,                                      /* Enable all strict type-checking options. */\n    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"添加 src/index.jsx"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const content = <div>\n    <Guang>guang</Guang>\n    <a href="xxx">link</a>\n</div>\n'})}),"\n",(0,t.jsx)(n.p,{children:"执行编译："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx tsc\n"})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，生成的代码是这样的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:G,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"React.createElement 第一个参数是类型，第二个参数是 props，第三个参数是 children。"}),"\n",(0,t.jsx)(n.p,{children:"具体的 render function 的名字也可以指定："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:X,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"再次执行编译，生成的就是这样的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:J,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这就是从 jsx 到 render function 这一步，由 babel、tsc 等编译器来做："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:L,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们只要实现这些 render function，然后返回对应的 React Element 即可。"}),"\n",(0,t.jsx)(n.p,{children:"创建 src/mini-react.js"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function createElement(type, props, ...children) {\n    return {\n        type,\n        props: {\n            ...props,\n            children: children.map((child) => {\n                const isTextNode = typeof child === "string" || typeof child === "number";\n                return isTextNode ? createTextNode(child) : child;\n            }),\n        },\n    };\n}\n\nfunction createTextNode(nodeValue) {\n    return {\n        type: "TEXT_ELEMENT",\n        props: {\n        nodeValue,\n            children: []\n        },\n    };\n}\n\nconst MiniReact = {\n    createElement\n};\n\nwindow.MiniReact = MiniReact;\n'})}),"\n",(0,t.jsx)(n.p,{children:"MiniReact.createElement 就是我们实现的 render function。"}),"\n",(0,t.jsx)(n.p,{children:"为什么文本节点要单独处理呢？"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:B,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"因为 div 的话，它的 type 是 div，可以有 props 和 children。"}),"\n",(0,t.jsx)(n.p,{children:"而文本节点是没有 type、children、props 的。"}),"\n",(0,t.jsx)(n.p,{children:"我们需要给它加个固定的 type TEXT_ELEMENT，并且设置 nodeValue 的 props。"}),"\n",(0,t.jsx)(n.p,{children:"这样结构统一，方便后面处理。"}),"\n",(0,t.jsx)(n.p,{children:"改下 index.jsx"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const content = <div>\n    <a href="xxx">link</a>\n</div>\n\nconsole.log(JSON.stringify(content, null, 2));\n'})}),"\n",(0,t.jsx)(n.p,{children:"编译一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx tsc -w\n"})}),"\n",(0,t.jsx)(n.p,{children:"在 dist 下生成了目标代码："}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)("img",{src:q,alt:""}),"\n加一个 index.html 引入下 dist 的代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<body>\n    <div id="root"></div>\n    <script src="./dist/mini-react.js"><\/script>\n    <script src="./dist/index.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,t.jsx)(n.p,{children:"然后跑个静态服务："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx http-server .\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:M,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"浏览器访问下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:_,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这个就是 React Element 的树，也就是我们常说的 vdom。"}),"\n",(0,t.jsx)(n.p,{children:"接下来要把它转成 fiber 结构。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:I,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这个过程叫做 reconcile。"}),"\n",(0,t.jsx)(n.p,{children:"它并不是一次性完成的，而是通过调度器调度，根据时间分片放到多个任务里完成，这里我们用 requestIdleCallback 来调度。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"let nextUnitOfWork = null\nlet wipRoot = null\nlet currentRoot = null\n\nfunction render(element, container) {\n    wipRoot = {\n        dom: container,\n        props: {\n            children: [element],\n        },\n        alternate: currentRoot,\n    }\n    nextUnitOfWork = wipRoot\n}\n\nfunction workLoop(deadline) {\n    let shouldYield = false\n    while (nextUnitOfWork && !shouldYield) {\n        nextUnitOfWork = performUnitOfWork(\n            nextUnitOfWork\n        )\n        shouldYield = deadline.timeRemaining() < 1\n    }\n    requestIdleCallback(workLoop)\n}\n\nrequestIdleCallback(workLoop)\n\nfunction performUnitOfWork(fiber) {\n\n    if (fiber.child) {\n        return fiber.child\n    }\n    let nextFiber = fiber\n    while (nextFiber) {\n        if (nextFiber.sibling) {\n            return nextFiber.sibling\n        }\n        nextFiber = nextFiber.return\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们用 reqeustIdleCallback 来代替 React 的时间分片，把 React Element 树转 fiber 的 reconcile 过程放到不同的任务里跑。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:D,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"用 nextUnitOfWork 指向下一个要处理的 fiber 节点。"}),"\n",(0,t.jsx)(n.p,{children:"每次跑的时候判断下 timeRemaing 是否接近 0，是的话就中断循环，等下次 requestIdleCallback 的回调再继续处理 nextUnitOfWork 指向的 fiber 节点。"}),"\n",(0,t.jsxs)(n.p,{children:["这里的 deadline.timeRemaing 是 requestIdleCallback 提供的，详细了解可以看下 ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Background_Tasks_API#%E7%A4%BA%E4%BE%8B",target:"_blank",rel:"noopener noreferrer",children:"MDN 的文档"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"render 方法里设置初始 nextUnitOfWork。"}),"\n",(0,t.jsx)(n.p,{children:"这里有两个 root，一个是当前正在处理的 fiber 链表的根 wipRoot，一个是之前的历史 fiber 链表的根 currentRoot。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:U,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"为什么有两个 root 呢？"}),"\n",(0,t.jsx)(n.p,{children:"因为初始渲染会生成一个 fiber 链表，然后后面 setState 更新会再生成一个新的 fiber 链表，两个 fiber 链表要做一些对比里决定对 dom 节点的增删改，所以都要保存。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:A,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"而 performUnitOfWork 处理每个 fiber 节点之后，会按照 child、sibling、return 的顺序返回下一个要处理的 fiber 节点："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:W,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"就是通过这种顺序来把 fiber 树变为链表的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:O,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:P,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"处理每个 fiber 节点的时候，要根据类型做不同的处理："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function performUnitOfWork(fiber) {\n    const isFunctionComponent = fiber.type instanceof Function\n    if (isFunctionComponent) {\n        updateFunctionComponent(fiber)\n    } else {\n        updateHostComponent(fiber)\n    }\n    if (fiber.child) {\n        return fiber.child\n    }\n    let nextFiber = fiber\n    while (nextFiber) {\n        if (nextFiber.sibling) {\n            return nextFiber.sibling\n        }\n        nextFiber = nextFiber.parent\n    }\n}\n\nlet wipFiber = null\nlet stateHookIndex = null\n\nfunction updateFunctionComponent(fiber) {\n  wipFiber = fiber\n  stateHookIndex = 0\n  wipFiber.stateHooks = []\n  wipFiber.effectHooks = []\n\n  const children = [fiber.type(fiber.props)]\n  reconcileChildren(fiber, children)\n}\n\nfunction updateHostComponent(fiber) {\n    if (!fiber.dom) {\n        fiber.dom = createDom(fiber)\n    }\n    reconcileChildren(fiber, fiber.props.children)\n}\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"判断下是函数组件（FunctionComponent），还是原生标签（HostComponent），分别做处理。"}),"\n",(0,t.jsx)(n.p,{children:"函数组件就是传入 props 调用它，并且函数组件的返回值就是要继续 reconcile 的节点。"}),"\n",(0,t.jsx)(n.p,{children:"这里用 wipFiber 指向当前处理的 fiber（之前的 nextUnitOfWork 是指向下一个要处理的 fiber 节点）"}),"\n",(0,t.jsx)(n.p,{children:"然后用一个 stateHooks 数组来存储 useState 的 hook 的值，用 effectHooks 数组存储 useEffect 的 hook 的值。"}),"\n",(0,t.jsx)(n.p,{children:"对于原生标签（HostComponent），就是创建它对应的 dom 节点。"}),"\n",(0,t.jsx)(n.p,{children:"具体创建 dom 的过程如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function createDom(fiber) {\n    const dom =\n      fiber.type == "TEXT_ELEMENT"\n        ? document.createTextNode("")\n        : document.createElement(fiber.type)\n  \n    updateDom(dom, {}, fiber.props)\n  \n    return dom\n}\n\nconst isEvent = key => key.startsWith("on")\nconst isProperty = key => key !== "children" && !isEvent(key)\nconst isNew = (prev, next) => key => prev[key] !== next[key]\nconst isGone = (prev, next) => key => !(key in next)\n\nfunction updateDom(dom, prevProps, nextProps) {\n  //Remove old or changed event listeners\n  Object.keys(prevProps)\n    .filter(isEvent)\n    .filter(\n      key => !(key in nextProps) || isNew(prevProps, nextProps)(key)\n    )\n    .forEach(name => {\n      const eventType = name.toLowerCase().substring(2)\n      dom.removeEventListener(eventType, prevProps[name])\n    })\n\n  // Remove old properties\n  Object.keys(prevProps)\n    .filter(isProperty)\n    .filter(isGone(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = ""\n    })\n\n  // Set new or changed properties\n  Object.keys(nextProps)\n    .filter(isProperty)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      dom[name] = nextProps[name]\n    })\n\n  // Add event listeners\n  Object.keys(nextProps)\n    .filter(isEvent)\n    .filter(isNew(prevProps, nextProps))\n    .forEach(name => {\n      const eventType = name.toLowerCase().substring(2)\n      dom.addEventListener(eventType, nextProps[name])\n    })\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"首先，根据是文本节点还是元素节点用 document.createElement 或 document.createTextNode 来创建。"}),"\n",(0,t.jsx)(n.p,{children:"然后更新 props。"}),"\n",(0,t.jsx)(n.p,{children:"首先删除旧的事件监听器，旧的属性，然后添加新的属性、新的事件监听器。"}),"\n",(0,t.jsx)(n.p,{children:"这样函数组件和原生标签的 reconcile 就处理完了。"}),"\n",(0,t.jsx)(n.p,{children:"继续处理它们的子节点："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function reconcileChildren(wipFiber, elements) {\n    let index = 0\n    let oldFiber = wipFiber.alternate?.child\n    let prevSibling = null\n\n    while ( index < elements.length || oldFiber != null) {\n        const element = elements[index]\n        let newFiber = null\n\n        const sameType = element?.type == oldFiber?.type\n\n        if (sameType) {\n            newFiber = {\n                type: oldFiber.type,\n                props: element.props,\n                dom: oldFiber.dom,\n                return: wipFiber,\n                alternate: oldFiber,\n                effectTag: "UPDATE",\n            }\n        }\n        if (element && !sameType) {\n            newFiber = {\n                type: element.type,\n                props: element.props,\n                dom: null,\n                return: wipFiber,\n                alternate: null,\n                effectTag: "PLACEMENT",\n            }\n        }\n        if (oldFiber && !sameType) {\n            oldFiber.effectTag = "DELETION"\n            deletions.push(oldFiber)\n        }\n\n        if (oldFiber) {\n            oldFiber = oldFiber.sibling\n        }\n\n        if (index === 0) {\n            wipFiber.child = newFiber\n        } else if (element) {\n            prevSibling.sibling = newFiber\n        }\n\n        prevSibling = newFiber\n        index++\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"当时 wipRoot 我们就制定了 alternate，也就是之前的 fiber 树，这样当 reconcile 创建新的 fiber 树的时候，就可以和之前的做 diff，判断是新增、修改、删除，打上对应的标记。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:T,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"首先，拿到 alternate 的 child，依次取 sibling，逐一和新的 fiber 节点对比。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:N,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后根据对比结果来创建新的 fiber 节点，也是先 child 后 sibling 的方式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:S,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这样遍历之前的 fiber 链表和生成新的 fiber 链表的原因，看图很容易搞懂："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:H,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:C,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后 diff 两个 fiber 链表，就是判断节点 type 是不是一样。"}),"\n",(0,t.jsx)(n.p,{children:"如果一样，就是修改，不一样，那就是删除或者新增，搭上对应的标记："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:R,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"fiber 节点的 type、props 就是类型和参数。"}),"\n",(0,t.jsx)(n.p,{children:"dom 是对应的 dom 节点，"}),"\n",(0,t.jsx)(n.p,{children:"alternate 是对应的旧的 fiber 节点。"}),"\n",(0,t.jsx)(n.p,{children:"effectTag 是增删改的标记。"}),"\n",(0,t.jsx)(n.p,{children:"这里的 delections 数组，也就是要删除的节点，在 render 的时候初始化："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:y,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"let nextUnitOfWork = null\nlet wipRoot = null\nlet currentRoot = null\nlet deletions = null\n\nfunction render(element, container) {\n    wipRoot = {\n        dom: container,\n        props: {\n            children: [element],\n        },\n        alternate: currentRoot,\n    }\n    \n    deletions = []\n\n    nextUnitOfWork = wipRoot\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样，从 wipRoot 开始，逐渐 reconcile 构建新的 fiber 节点，根据 FunctionComponent 还是原生标签（HostComponent）来分别执行函数和创建 dom，并且还对新旧的 fiber 节点做了 diff，搭上增删改标记。"}),"\n",(0,t.jsx)(n.p,{children:"reconcile 结束，新的 fiber 链表就创建好了。"}),"\n",(0,t.jsx)(n.p,{children:"其中，函数组件可能会调用 useState 或者 useEffect 的 api，我们也要实现一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:F,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"首先，useState 的 state 和 useEffect 的 effect 存在哪里呢？"}),"\n",(0,t.jsx)(n.p,{children:"肯定是在 fiber 上。"}),"\n",(0,t.jsx)(n.p,{children:"比如用两个数组 stateHooks 和 effectHooks 分别来存储："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:v,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"先实现 useState："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function useState(initialState) {\n    const currentFiber = wipFiber;\n\n    const oldHook = wipFiber.alternate?.stateHooks[stateHookIndex];\n\n    const stateHook = {\n      state: oldHook ? oldHook.state : initialState,\n      queue: oldHook ? oldHook.queue : [],\n    };\n\n    stateHook.queue.forEach((action) => {\n      stateHook.state = action(stateHook.state);\n    });\n\n    stateHook.queue = [];\n\n    stateHookIndex++;\n    wipFiber.stateHooks.push(stateHook);\n\n    function setState(action) {\n      const isFunction = typeof action === "function";\n\n      stateHook.queue.push(isFunction ? action : () => action);\n\n      wipRoot = {\n        ...currentFiber,\n        alternate: currentFiber,\n      };\n      nextUnitOfWork = wipRoot;\n    }\n\n    return [stateHook.state, setState];\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"我们在 fiber 节点上用 stateHooks 数组来存储 state，还有多次调用 setState 的回调函数。"}),"\n",(0,t.jsx)(n.p,{children:"比如这样："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:E,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"那 state 就是 0，然后 queue 里存了三个修改 state 的函数。"}),"\n",(0,t.jsx)(n.p,{children:"每次调用 useState 时会在 stateHooks 添加一个元素来保存 state："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:w,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"state 的初始值是前面一次渲染的 state 值，也就是取 alternate 的同一位置的 state："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:k,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这样对初始 state 执行多个 action（也就是 setState） 之后，就拿到了最终的 state 值。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"修改完 state 之后清空 queue。"}),"\n",(0,t.jsx)(n.p,{children:"比如这里初始 state 是 0，调用三次 action 之后，state 变为 3："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后 setState 就是在 action 数组里添加新的 action，并且让 nextUnitOfWork 指向新的 wipRoot，从而开始新的一轮渲染："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后是 useEffect："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function useEffect(callback, deps) {\n  const effectHook = {\n    callback,\n    deps,\n    cleanup: undefined,\n  };\n  wipFiber.effectHooks.push(effectHook);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"它就是在 fiber.effectHooks 上添加一个元素。"}),"\n",(0,t.jsx)(n.p,{children:"这样，等 reconcile 结束，fiber 链表就构建好了，在 fiber 上打上了增删改的标记，并且也保存了要执行的 effect。"}),"\n",(0,t.jsx)(n.p,{children:"接下来只要遍历这个构建好的 fiber 链表，执行增删改和 effect 函数就好了。"}),"\n",(0,t.jsx)(n.p,{children:"这个阶段是 commit。"}),"\n",(0,t.jsx)(n.p,{children:"前面讲过，requestIdleCallback 在不断进行，每次处理一部分 fiber 的 reconcile。"}),"\n",(0,t.jsx)(n.p,{children:"我们只要在 reconcile 结束，也就是没有 nextUnitOfWork 的时候执行 commit 就行了："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"if (!nextUnitOfWork && wipRoot) {\n    commitRoot()\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"在 commitRoot 里，我们先把需要删除的节点都删掉，然后遍历 fiber 链表，处理其它节点："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function commitRoot() {\n    deletions.forEach(commitWork)\n    commitWork(wipRoot.child)\n    currentRoot = wipRoot\n    wipRoot = null\n    deletions = []\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里要把当前 wipRoot 设置为 currentRoot，然后把它置空，这就代表这次 reconcile 结束了。"}),"\n",(0,t.jsx)(n.p,{children:"处理完之后还要把 deletions 数组里保存的要删除的节点置空，这时候已经删除了。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function commitWork(fiber) {\n    if (!fiber) {\n        return\n    }\n\n\n    commitWork(fiber.child)\n    commitWork(fiber.sibling)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"commitWork 按照 child、sibling 的顺序来递归遍历 fiber 链表。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function commitWork(fiber) {\n    if (!fiber) {\n        return\n    }\n\n    let domParentFiber = fiber.return\n    while (!domParentFiber.dom) {\n        domParentFiber = domParentFiber.return\n    }\n    const domParent = domParentFiber.dom\n\n    if (fiber.effectTag === "PLACEMENT" && fiber.dom != null) {\n        domParent.appendChild(fiber.dom)\n    } else if (fiber.effectTag === "UPDATE" && fiber.dom != null) {\n        updateDom(fiber.dom, fiber.alternate.props, fiber.props)\n    } else if (fiber.effectTag === "DELETION") {\n        commitDeletion(fiber, domParent)\n    }\n\n    commitWork(fiber.child)\n    commitWork(fiber.sibling)\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"首先，不断向上找，找到可以挂载的 dom 节点。"}),"\n",(0,t.jsx)(n.p,{children:"然后按照增增删改的 effectTag 来分别做处理。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function commitDeletion(fiber, domParent) {\n    if (fiber.dom) {\n        domParent.removeChild(fiber.dom)\n    } else {\n        commitDeletion(fiber.child, domParent)\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"删除的时候，如果当前 fiber 节点没有对应的 dom，就不断 child 向下找。"}),"\n",(0,t.jsx)(n.p,{children:"这样遍历完一遍之后，dom 的增删改就完成了。"}),"\n",(0,t.jsx)(n.p,{children:"此外，我们还需要处理 effect。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"它同样要遍历 fiber 链表："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"先遍历一遍执行所有的 cleanup 函数，然后再次遍历执行 effect 函数。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function commitEffectHooks() {\n    function runCleanup(fiber){\n        if (!fiber) return;\n\n        fiber.alternate?.effectHooks?.forEach((hook, index)=>{\n            const deps = fiber.effectHooks[index].deps;\n\n            if (!hook.deps || !isDepsEqual(hook.deps, deps)) {\n                hook.cleanup?.();\n            }\n        })\n\n        runCleanup(fiber.child);\n        runCleanup(fiber.sibling);\n    }\n\n    function run(fiber) {\n        if (!fiber) return;\n  \n        fiber.effectHooks?.forEach((newHook, index) => {\n            if(!fiber.alternate) {\n                hook.cleanup = hook.callback();\n                return;\n            }\n\n            if(!newHook.deps) {\n                hook.cleanup = hook.callback();\n            }\n\n            if (newHook.deps.length > 0) {\n                const oldHook = fiber.alternate?.effectHooks[index];\n\n                if(!isDepsEqual(oldHook.deps, newHook.deps)) {\n                    newHook.cleanup = newHook.callback()\n                }\n            }\n        });\n\n        run(fiber.child);\n        run(fiber.sibling);\n    }\n  \n    runCleanup(wipRoot);\n    run(wipRoot);\n}\n\nfunction isDepsEqual(deps, newDeps) {\n    if(deps.length !== newDeps.length) {\n        return false;\n    }\n\n    for(let i = 0; i < deps.length; i++) {\n        if(deps[i] !== newDeps[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里遍历 fiber 链表也是递归处理每个节点，每个节点递归处理 child、sibling。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"当没有传入 deps 数组，或者 deps 数组和上次不一致时，就执行 cleanup 函数。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"比如这样："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"useEffect(() => {\n    const timer = setTimeout(() => {\n    \n    }, 1000);\n    return () => clearTimeout(timer);\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"当没有传入 deps 或者 deps 数组变化的时候，会执行上次的 clearTimeout。"}),"\n",(0,t.jsx)(n.p,{children:"之后才会重新执行 effect："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"当没有 alternate 的时候，就是首次渲染，直接执行所有的 effect。"}),"\n",(0,t.jsx)(n.p,{children:"否则，如果没传入 deps 或者 deps 数组变化的时候再执行 effect 函数："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这样，commit 阶段，我们遍历 fiber 链表做的 dom 的增删改，执行了 effect 函数。"}),"\n",(0,t.jsx)(n.p,{children:"至此，react 的渲染流程的两大阶段 render 和 commit 就完成了。"}),"\n",(0,t.jsx)(n.p,{children:"导出 render、useState、useEffect 的 api："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后外面包一层函数，避免污染全局变量："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们整体测试下："}),"\n",(0,t.jsx)(n.p,{children:"改下 index.jsx"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const { render, useState, useEffect } = window.MiniReact;\n\nfunction App() {\n  const [count,setCount] = useState(0)\n \n  function handleClick(){\n    setCount((count)=> count + 1)\n  }\n\n  return <div>\n    <p>{count}</p>\n    <button onClick={handleClick}>加一</button>\n  </div>;\n}\n\nrender(<App/>, document.getElementById('root'));\n"})}),"\n",(0,t.jsx)(n.p,{children:"测试下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,t.jsx)(n.p,{children:"再测试下 useEffect："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const { render, useState, useEffect } = window.MiniReact;\n\nfunction App() {\n  const [count,setCount] = useState(0)\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n        setCount((count)=> count + 1)\n    }, 1000);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return <div>\n    <p>{count}</p>\n  </div>;\n}\n\nrender(<App/>, document.getElementById('root'));\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"也没啥问题。"}),"\n",(0,t.jsx)(n.p,{children:"然后我们抽离一个组件，传入初始值和定时器的时间间隔："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const { render, useState, useEffect } = window.MiniReact;\n\nfunction Counter(props) {\n  const {\n    initialNum,\n    interval\n  } = props;\n\n  const [count, setCount] = useState(initialNum)\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n        setCount((count)=> count + 1)\n    }, interval);\n    return () => clearTimeout(timer);\n  }, []);\n\n  return <div>\n    <p>{count}</p>\n  </div>;\n}\n\nfunction App() {\n  return <Counter interval={1000} initialNum={10}></Counter>\n}\n\nrender(<App/>, document.getElementById('root'));\n"})}),"\n",(0,t.jsx)(n.p,{children:"Counter 组件有 interval 和 initialNum 两个参数。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"也没问题。"}),"\n",(0,t.jsx)(n.p,{children:"这样，我们的 mini react 就完成了。"}),"\n",(0,t.jsxs)(n.p,{children:["案例代码上传了",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/mini-react",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们 React 的渲染流程来实现了下 mini react。"}),"\n",(0,t.jsx)(n.p,{children:"JSX 转 render function 这步是 babel 或 tsc 等编译器做的。"}),"\n",(0,t.jsx)(n.p,{children:"我们实现 React.createElement 函数，那执行后返回的就是 React Element 树，也就是 vdom。"}),"\n",(0,t.jsx)(n.p,{children:"通过 requestIdleCallback 在空闲时执行 React Element 转 fiber 的 reconcile 流程。"}),"\n",(0,t.jsx)(n.p,{children:"按照函数组件 FunctionComponent 或者原生标签 HostComponent 分别执行函数或者创建 dom。"}),"\n",(0,t.jsx)(n.p,{children:"reconcile 到子节点的时候要和 alternate 对比，判断是新增、修改还是删除，打上标记。"}),"\n",(0,t.jsx)(n.p,{children:"这个过程中如果调用了 useState 或者 useEffect 会在对应 fiber 节点的 hooks 数组上添加一些元素。"}),"\n",(0,t.jsx)(n.p,{children:"之后进入 commit 阶段，从根节点开始遍历 fiber 链表，根据标记来执行 dom 的增删改，以及执行 effect 函数。"}),"\n",(0,t.jsx)(n.p,{children:"然后 useState 的 setState 会设置新的 nextUnitOfWork，从而触发新的一轮渲染流程。"}),"\n",(0,t.jsx)(n.p,{children:"这样，和 React 的真实渲染流程类似的 mini react 就完成了。"})]})}function K(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(Q,{...e})}):Q(e)}let Z=K;K.__RSPRESS_PAGE_META={},K.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC63%E7%AB%A0%E2%80%94%E6%89%8B%E5%86%99MiniReact%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第63章—手写MiniReact：代码实现",headingTitle:"第63章—手写MiniReact：代码实现",frontmatter:{}}}}]);