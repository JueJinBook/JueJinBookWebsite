"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["7534"],{672625:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var r=s(552676),c=s(740453);let t=s.p+"static/image/0919e1710cea524c7d204a7d9aaf68e2.0d1b0f89.webp",a=s.p+"static/image/2575c9e2f71ba8e1ea3262d24b1ee6c1.2b6724ff.webp",l=s.p+"static/image/9d0656c96d627a313bb08691b1ef4267.ccd9a4b1.webp",o=s.p+"static/image/c3ce75734d908d57fc43e8ffd76d8886.3daa61a0.webp";function u(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",blockquote:"blockquote",ul:"ul",li:"li",img:"img",pre:"pre",strong:"strong",h3:"h3"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"33v18特性篇-usemutablesource已被取缔",children:["33.V18特性篇-useMutableSource（已被取缔）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33v18特性篇-usemutablesource已被取缔",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useMutableSource"})," 最早的 ",(0,r.jsx)(n.a,{href:"https://github.com/reactjs/rfcs/blob/main/text/0147-use-mutable-source.md",target:"_blank",rel:"noopener noreferrer",children:"RFC"})," 提案在 2020年 2 月份就开始了。在 React 18 中它将作为新特性出现。用一段提案中的描述来概括 ",(0,r.jsx)(n.code,{children:"useMutableSource"}),"。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"useMutableSource 能够让 React 组件在 Concurrent Mode 模式下安全地有效地读取外接数据源，在组件渲染过程中能够检测到变化，并且在数据源发生变化的时候，能够调度更新。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"说起外部数据源就要从 state 和更新说起 ，无论是 React 还是 Vue 这种传统 UI 框架中，虽然它们都采用虚拟 DOM 方式，但是还是不能够把更新单元委托到虚拟 DOM 身上来，所以更新的最小粒度还是在组件层面上，由组件统一管理数据 state，并参与调度更新。"}),"\n",(0,r.jsx)(n.p,{children:"回到我们的主角 React 上，既然由组件 component 管控着状态 state。那么在 v17 和之前的版本，React 想要视图上的更新，那么只能通过更改内部数据 state 。纵览 React 的几种更新方式，无一离不开自身 state 。先来看一下 React 的几种更新模式。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["组件本身改变 state 。函数 ",(0,r.jsx)(n.code,{children:"useState"})," | ",(0,r.jsx)(n.code,{children:"useReducer"})," ，类组件 ",(0,r.jsx)(n.code,{children:"setState"})," | ",(0,r.jsx)(n.code,{children:"forceUpdate"})," 。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"props"})," 改变，由组件更新带来的子组件的更新。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"context"})," 更新，并且该组件消费了当前 ",(0,r.jsx)(n.code,{children:"context"})," 。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"无论是上面哪种方式，本质上都是 state 的变化。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"props"})," 改变来源于父级组件的 ",(0,r.jsx)(n.code,{children:"state"})," 变化。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"context"})," 变化来源于 Provider 中 value 变化，而 value 一般情况下也是 state 或者是 state 衍生产物。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["从上面可以概括出：state和视图更新的关系 ",(0,r.jsx)(n.code,{children:"Model"})," => ",(0,r.jsx)(n.code,{children:"View"})," 。但是 state 仅限于组件内部的数据，如果 state 来源于外部（脱离组件层面）。那么如何完成外部数据源转换成内部状态， 并且数据源变化，组件重新 render 呢？"]}),"\n",(0,r.jsx)(n.p,{children:"常规模式下，先把外部数据 external Data 通过 selector 选择器把组件需要的数据映射到 state | props 上。这算是完成了一步，接下来还需要 subscribe 订阅外部数据源的变化，如果发生变化，那么还需要自身去强制更新 forceUpdate 。下面两幅图表示数据注入和数据订阅更新。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"1.jpg"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"2.jpg"})}),"\n",(0,r.jsx)(n.p,{children:"典型的外部数据源就是 redux 中的 store ，redux 是如何把 Store 中的 state ，安全的变成组件的 state 的。"}),"\n",(0,r.jsx)(n.p,{children:"或许我可以用一段代码来表示从 react-redux 中 state 改变到视图更新的流程。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const store = createStore(reducer,initState)\n\nfunction App({ selector }){\n    const [ state , setReduxState ] = React.useState({})\n    const contextValue = useMemo(()=>{\n        /* 订阅 store 变化 */\n        store.subscribe(()=>{\n             /* 用选择器选择订阅 state */\n             const value = selector(data.getState())\n             /* 如果发生变化  */\n             if(ifHasChange(state,value)){\n                 setReduxState(value)\n             }\n        })\n    },[ store ])    \n    return <div>...</div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"但是例子中代码，没有实际意义，也不是源代码，我这里就是让大家清晰地了解流程。redux 和 react 本质上是这样工作的。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["通过 store.subscribe 来订阅 state 变化，但是本质上要比代码片段中复杂的多，通过 selector （选择器）找到组件需要的 state。 我在这里先解释一下",(0,r.jsx)(n.strong,{children:"selector"}),"，因为在业务组件往往不需要整个 store 中的 state 全部数据，而是仅仅需要下面的部分状态，这个时候就需要从 state 中选择‘有用的’，并且和 props 合并，细心的同学应该发现，选择器需要和 ",(0,r.jsx)(n.code,{children:"react-redux"})," 中 connect 第一参数 mapStateToProps 联动。对于细节，无关紧要，因为今天重点是 ",(0,r.jsx)(n.code,{children:"useMutableSource"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["如上是没有 ",(0,r.jsx)(n.code,{children:"useMutableSource"})," 的情况，现在用 useMutableSource 不在需要把订阅到更新流程交给组件处理。如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/* 创建 store */\nconst store = createStore(reducer,initState)\n/* 创建外部数据源\xa0*/\nconst externalDataSource = createMutableSource( store ,store.getState() )\n/* 订阅更新 */\nconst subscribe = (store, callback) => store.subscribe(callback);\nfunction App({ selector }){\n    /* 订阅的 state 发生变化，那么组件会更新 */\n    const state = useMutableSource(externalDataSource,selector,subscribe)\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"通过 createMutableSource 创建外部数据源，通过 useMutableSource 来使用外部数据源。外部数据源变化，组件自动渲染。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"如上是通过 useMutableSource 实现的订阅更新，这样减少了 APP 内部组件代码，代码健壮性提升，一定程度上也降低了耦合。接下来让我们全方面认识一下这个 V18 的新特性。"}),"\n",(0,r.jsxs)(n.h2,{id:"二-功能介绍",children:["二 功能介绍",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-功能介绍",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["具体功能介绍流程还是参考最新的 RFC， createMutableSource 和 useMutableSource 在一定的程度上，有点像 ",(0,r.jsx)(n.code,{children:"createContext"})," 和 ",(0,r.jsx)(n.code,{children:"useContext"})," ，见名知意，就是",(0,r.jsx)(n.strong,{children:"创建"}),"与",(0,r.jsx)(n.strong,{children:"使用"}),"。不同的是 context 需要 ",(0,r.jsx)(n.code,{children:"Provider"})," 去注入内部状态，而今天的主角是注入外部状态。那么首先应该看一下两者如何使用。"]}),"\n",(0,r.jsxs)(n.h3,{id:"创建",children:["创建",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#创建",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"createMutableSource 创建一个数据源。它有两个参数："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const externalDataSource = createMutableSource( store ,store.getState() ) \n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"第一个参数：就是外部的数据源，比如 redux 中的 store,"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["第二个参数：一个函数，函数的返回值作为数据源的版本号，这里需要注意⚠️的是，要保持数据源和数据版本号的一致性，就是数据源变化了，那么数据版本号就要变化，一定程度上遵循 ",(0,r.jsx)(n.code,{children:"immutable"})," 原则（不可变性）。可以理解为数据版本号是证明数据源唯一性的标示。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"api介绍",children:["api介绍",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#api介绍",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["useMutableSource 可以使用非传统的数据源。它的功能和 Context API  还有 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/use-subscription",target:"_blank",rel:"noopener noreferrer",children:"useSubscription"})," 类似。（没有使用过 useSubscription 的同学，可以了解一下 ）。"]}),"\n",(0,r.jsx)(n.p,{children:"先来看一下 useMutableSource 的基本使用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const value = useMutableSource(source,getSnapShot,subscribe)\n"})}),"\n",(0,r.jsx)(n.p,{children:"useMutableSource 是一个 hooks ，它有三个参数："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"source：MutableSource < Source >"})," 可以理解为带记忆的数据源对象。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"getSnapshot：( source : Source ) => Snapshot"})," ：一个函数，数据源作为函数的参数，获取快照信息，可以理解为 ",(0,r.jsx)(n.code,{children:"selector"})," ，把外部的数据源的数据过滤，找出想要的数据源。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"subscribe: (source: Source, callback: () => void) => () => void"}),"：订阅函数，有两个参数，Source 可以理解为 useMutableSource 第一个参数，callback 可以理解为 useMutableSource 第二个参数，当数据源变化的时候，执行快照，获取新的数据。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"useMutableSource 特点"})}),"\n",(0,r.jsx)(n.p,{children:"useMutableSource 和 useSubscription 功能类似："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"两者都需要带有记忆化的‘配置化对象’，从而从外部取值。"}),"\n",(0,r.jsxs)(n.li,{children:["两者都需要一种订阅和取消订阅源的方法 ",(0,r.jsx)(n.code,{children:"subscribe"}),"。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"除此之外 useMutableSource 还有一些特点："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"useMutableSource 需要源作为显式参数。也就是需要把数据源对象作为第一个参数传入。"}),"\n",(0,r.jsx)(n.li,{children:"useMutableSource 用 getSnapshot 读取的数据，是不可变的。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"关于 MutableSource 版本号"})," ","\n",(0,r.jsx)(n.code,{children:"useMutableSource"})," 会追踪 MutableSource 的版本号，然后读取数据，所以如果两者不一致，可能会造成读取异常的情况。useMutableSource 会检查版本号："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"在第一次组件挂载的时候，读取版本号。"}),"\n",(0,r.jsx)(n.li,{children:"在组件 rerender 的时候，确保版本号一致，然后在读取数据。不然会造成错误发生。"}),"\n",(0,r.jsx)(n.li,{children:"确保数据源和版本号的一致性。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"设计规范"})}),"\n",(0,r.jsx)(n.p,{children:"当通过 getSnapshot 读取外部数据源的时候，返回的 value 应该是不可变的。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"✅ 正确写法：getSnapshot: source => Array.from(source.friendIDs)"}),"\n",(0,r.jsx)(n.li,{children:"❌ 错误写法：getSnapshot: source => source.friendIDs"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"数据源必须有一个全局的版本号，这个版本号代表整个数据源："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"✅ 正确写法：getVersion: () => source.version"}),"\n",(0,r.jsx)(n.li,{children:"❌ 错误写法：getVersion: () => source.user.version"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"接下来参考 github 上的例子，我讲一下具体怎么使用："}),"\n",(0,r.jsxs)(n.h3,{id:"例子一",children:["例子一",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#例子一",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"例子一：订阅 history 模式下路由变化"})}),"\n",(0,r.jsxs)(n.p,{children:["比如有一个场景就是在非人为情况下，订阅路由变化，展示对应的 ",(0,r.jsx)(n.code,{children:"location.pathname"}),"，看一下是如何使用 useMutableSource 处理的。在这种场景下，外部数据源就是 location 信息。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// 通过 createMutableSource 创建一个外部数据源。\n// 数据源对象为 window。\n// 用 location.href 作为数据源的版本号，href 发生变化，那么说明数据源发生变化。\nconst locationSource = createMutableSource(\n  window,\n  () => window.location.href\n);\n\n// 获取快照信息，这里获取的是 location.pathname 字段，这个是可以复用的，当路由发生变化的时候，那么会调用快照函数，来形成新的快照信息。\nconst getSnapshot = window => window.location.pathname\n\n// 订阅函数。\nconst subscribe = (window, callback) => {\n   //通过 popstate 监听 history 模式下的路由变化，路由变化的时候，执行快照函数，得到新的快照信息。\n  window.addEventListener("popstate", callback);\n   //取消监听\n  return () => window.removeEventListener("popstate", callback);\n};\n\nfunction Example() {\n  // 通过 useMutableSource，把数据源对象，快照函数，订阅函数传入，形成 pathName。  \n  const pathName = useMutableSource(locationSource, getSnapshot, subscribe);\n\n  // ...\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"来描绘一下流程："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["首先通过 ",(0,r.jsx)(n.code,{children:"createMutableSource"})," 创建一个数据源对象，该数据源对象为 window。 用 location.href 作为数据源的版本号，href 发生变化，那么说明数据源发生变化。"]}),"\n",(0,r.jsx)(n.li,{children:"获取快照信息，这里获取的是 location.pathname 字段，这个是可以复用的，当路由发生变化的时候，那么会调用快照函数，来形成新的快照信息。"}),"\n",(0,r.jsxs)(n.li,{children:["通过 ",(0,r.jsx)(n.code,{children:"popstate"})," 监听 ",(0,r.jsx)(n.code,{children:"history"})," 模式下的路由变化，路由变化的时候，执行快照函数，得到新的快照信息。"]}),"\n",(0,r.jsxs)(n.li,{children:["通过 ",(0,r.jsx)(n.code,{children:"useMutableSource"})," ，把数据源对象，快照函数，订阅函数传入，形成 ",(0,r.jsx)(n.code,{children:"pathName"})," 。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"可能这个例子\uD83C\uDF30，不足以让你清楚 useMutableSource 的作用，我们再举一个例子看一下 useMutableSource 如何和 redux 契合使用的。"}),"\n",(0,r.jsxs)(n.h3,{id:"例子二",children:["例子二",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#例子二",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["例子二：redux 中 ",(0,r.jsx)(n.code,{children:"useMutableSource"})," 使用"]})}),"\n",(0,r.jsxs)(n.p,{children:["redux 可以通过 useMutableSource 编写自定义 hooks —— ",(0,r.jsx)(n.code,{children:"useSelector"}),"，useSelector 可以读取数据源的状态，当数据源改变的时候，重新执行快照获取状态，做到订阅更新。我们看一下 useSelector 是如何实现的。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const mutableSource = createMutableSource(\n  reduxStore, // 将 redux 的 store 作为数据源。\n  // state 是不可变的，可以作为数据源的版本号\n  () => reduxStore.getState()\n);\n\n// 通过创建 context 保存数据源 mutableSource。\nconst MutableSourceContext = createContext(mutableSource);\n\n// 订阅 store 变化。store 变化，执行 getSnapshot\nconst subscribe = (store, callback) => store.subscribe(callback);\n\n// 自定义 hooks useSelector 可以在每一个 connect 内部使用，通过 useContext 获取 数据源对象。 \nfunction useSelector(selector) {\n  const mutableSource = useContext(MutableSourceContext);\n   // 用 useCallback 让 getSnapshot 变成有记忆的。 \n  const getSnapshot = useCallback(store => selector(store.getState()), [\n    selector\n  ]);\n   // 最后本质上用的是 useMutableSource 订阅 state 变化。  \n  return useMutableSource(mutableSource, getSnapshot, subscribe);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"大致流程是这样的："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["将 redux 的 store 作为数据源对象 ",(0,r.jsx)(n.code,{children:"mutableSource"})," 。 state 是不可变的，可以作为数据源的版本号。"]}),"\n",(0,r.jsxs)(n.li,{children:["通过创建 context 保存数据源对象 ",(0,r.jsx)(n.code,{children:"mutableSource"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:["声明订阅函数，订阅 store 变化。store 变化，执行 ",(0,r.jsx)(n.code,{children:"getSnapshot"})," 。"]}),"\n",(0,r.jsxs)(n.li,{children:["自定义 hooks ",(0,r.jsx)(n.code,{children:"useSelector"})," 可以在每一个 connect 内部使用，通过 useContext 获取 数据源对象。 用 ",(0,r.jsx)(n.code,{children:"useCallback"})," 让 getSnapshot 变成有记忆的。"]}),"\n",(0,r.jsx)(n.li,{children:"最后本质上用的是 useMutableSource 订阅外部 state 变化。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"注意问题"})," "]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"在创建 getSnapshot 的时候，需要将 getSnapshot 记忆化处理，就像上述流程中的 useCallback 处理 getSnapshot 一样，如果不记忆处理，那么会让组件频繁渲染。"}),"\n",(0,r.jsxs)(n.li,{children:["在最新的 react-redux 源码中，已经使用新的 api，订阅外部数据源，不过不是 ",(0,r.jsx)(n.code,{children:"useMutableSource"})," 而是 ",(0,r.jsx)(n.code,{children:"useSyncExternalStore"}),"，具体因为 ",(0,r.jsx)(n.code,{children:"useMutableSource"})," 没有提供内置的 selectorAPI，需要每一次当选择器变化时候重新订阅 store，如果没有 useCallback 等 api 记忆化处理，那么将重新订阅。具体内容请参考 ",(0,r.jsx)(n.a,{href:"https://github.com/reactwg/react-18/discussions/86",target:"_blank",rel:"noopener noreferrer",children:"useMutableSource → useSyncExternalStore"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"三-实践",children:["三 实践",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-实践",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["接下来我用一个例子来具体实践一下 ",(0,r.jsx)(n.code,{children:"createMutableSource"}),"，让大家更清晰流程。"]}),"\n",(0,r.jsxs)(n.p,{children:["这里还是采用 redux 和 createMutableSource 实现外部数据源的引用。这里使用的是 ",(0,r.jsx)(n.code,{children:"18.0.0-alpha"})," 版本的 ",(0,r.jsx)(n.code,{children:"react"})," 和 ",(0,r.jsx)(n.code,{children:"react-dom"})," 。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"3.jpg"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import  React , {\n    unstable_useMutableSource as useMutableSource,\n    unstable_createMutableSource as createMutableSource\n} from 'react'\n\nimport { combineReducers , createStore  } from 'redux'\n\n/* number Reducer */\nfunction numberReducer(state=1,action){\n    switch (action.type){\n      case 'ADD':\n        return state + 1\n      case 'DEL':\n        return state - 1\n      default:\n        return state\n    }\n}\n/* 注册reducer */\nconst rootReducer = combineReducers({ number:numberReducer  })\n/* 合成Store */\nconst Store = createStore(rootReducer,{ number: 1  })\n/* 注册外部数据源 */\nconst dataSource = createMutableSource( Store ,() => 1 )\n\n/* 订阅外部数据源 */\nconst subscribe = (dataSource,callback)=>{\n    const unSubScribe = dataSource.subscribe(callback)\n    return () => unSubScribe()\n}\n\n/* TODO: 情况一 */\nexport default function Index(){\n    /* 获取数据快照 */\n     const shotSnop = React.useCallback((data) => ({...data.getState()}),[])\n    /*  hooks:使用 */\n    const data = useMutableSource(dataSource,shotSnop,subscribe)\n    return <div>\n        <p> 拥抱 React 18 \uD83C\uDF89\uD83C\uDF89\uD83C\uDF89 </p>\n        赞：{data.number} <br/>\n        <button onClick={()=>Store.dispatch({ type:'ADD' })} >点赞</button>\n    </div>\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["第一部分用 ",(0,r.jsx)(n.code,{children:"combineReducers"})," 和 ",(0,r.jsx)(n.code,{children:"createStore"})," 创建 redux Store 的过程。","\n重点是第二部分："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["首先通过 createMutableSource 创建数据源，Store 为数据源，",(0,r.jsx)(n.code,{children:"data.getState()"})," 作为版本号。"]}),"\n",(0,r.jsxs)(n.li,{children:["第二点就是快照信息，这里的快照就是 store 中的 state。所以在 ",(0,r.jsx)(n.code,{children:"shotSnop"})," 还是通过 getState 获取状态，正常情况下 shotSnop 应该作为 ",(0,r.jsx)(n.code,{children:"Selector"}),"，这里把所有的 state 都映射出来了。"]}),"\n",(0,r.jsxs)(n.li,{children:["第三就是通过 ",(0,r.jsx)(n.code,{children:"useMutableSource"})," 把数据源，快照，订阅函数传入，得到的 data 就是引用的外部数据源了。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"接下来让我们看一下效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"4.gif"})}),"\n",(0,r.jsxs)(n.h2,{id:"四-原理分析",children:["四 原理分析",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-原理分析",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"useMutableSource 已经在 React v18 的规划之中了，那么它的实现原理以及细节，在 V18 正式推出之前可以还会有调整，"}),"\n",(0,r.jsxs)(n.h3,{id:"1-createmutablesource",children:["1 createMutableSource",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-createmutablesource",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react/src/ReactMutableSource.js -> createMutableSource"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function createMutableSource(source,getVersion){\n    const mutableSource = {\n        _getVersion: getVersion,\n        _source: source,\n        _workInProgressVersionPrimary: null,\n        _workInProgressVersionSecondary: null,\n    };\n    return mutableSource\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["createMutableSource 的原理非常简单，和 ",(0,r.jsx)(n.code,{children:"createContext"})," ， ",(0,r.jsx)(n.code,{children:"createRef"})," 类似， 就是创建一个 ",(0,r.jsx)(n.code,{children:"createMutableSource"})," 对象，"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-usemutablesource",children:["2 useMutableSource",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-usemutablesource",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["对于 useMutableSource 原理也没有那么玄乎，原来是由开发者自己把外部数据源注入到 state 中，然后写订阅函数。 useMutableSource 的原理就是把开发者该做的事，自己做了\uD83D\uDE02\uD83D\uDE02\uD83D\uDE02，这样省着开发者去写相关的代码了。本质上就是 ",(0,r.jsx)(n.strong,{children:"useState + useEffect"})," ："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"useState 负责更新。"}),"\n",(0,r.jsx)(n.li,{children:"useEffect 负责订阅。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"然后来看一下原理。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberHooks.new.js -> useMutableSource"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useMutableSource(hook,source,getSnapshot){\n    /* 获取版本号 */\n    const getVersion = source._getVersion;\n    const version = getVersion(source._source);\n    /* 用 useState 保存当前 Snapshot，触发更新。 */\n    let [currentSnapshot, setSnapshot] = dispatcher.useState(() =>\n       readFromUnsubscribedMutableSource(root, source, getSnapshot),\n    );\n    dispatcher.useEffect(() => {\n        /* 包装函数  */\n        const handleChange = () => {\n            /* 触发更新 */\n            setSnapshot()\n        }\n        /* 订阅更新 */\n        const unsubscribe = subscribe(source._source, handleChange);\n        /* 取消订阅 */\n        return unsubscribe;\n    },[source, subscribe])\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"上述代码中保留了最核心的逻辑："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["首先通过 ",(0,r.jsx)(n.code,{children:"getVersion"})," 获取数据源版本号，用 ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"useState"})})," 保存当前 Snapshot，setSnapshot 用于触发更新。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"useEffect"})})," 中，进行订阅，绑定的是包装好的 handleChange 函数，里面调用 setSnapshot 真正的更新组件。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"所以 useMutableSource 本质上还是 useState 。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"五-总结",children:["五 总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"今天讲了 useMutableSource 的背景，用法，以及原理。希望阅读的同学可以克隆一下 React v18 的新版本，尝试一下新特性，将对理解 useMutableSource 很有帮助。下一章我们将继续围绕 React v18 展开。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}let d=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F33.V18%E7%89%B9%E6%80%A7%E7%AF%87-useMutableSource%EF%BC%88%E5%B7%B2%E8%A2%AB%E5%8F%96%E7%BC%94%EF%BC%89.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 功能介绍",id:"二-功能介绍",depth:2},{text:"创建",id:"创建",depth:3},{text:"api介绍",id:"api介绍",depth:3},{text:"例子一",id:"例子一",depth:3},{text:"例子二",id:"例子二",depth:3},{text:"三 实践",id:"三-实践",depth:2},{text:"四 原理分析",id:"四-原理分析",depth:2},{text:"1 createMutableSource",id:"1-createmutablesource",depth:3},{text:"2 useMutableSource",id:"2-usemutablesource",depth:3},{text:"五 总结",id:"五-总结",depth:2}],title:"33.V18特性篇-useMutableSource（已被取缔）",headingTitle:"33.V18特性篇-useMutableSource（已被取缔）",frontmatter:{}}}}]);