"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["32220"],{119035:function(n,e,i){i.r(e),i.d(e,{default:()=>T});var r=i(552676),c=i(740453);let a=i.p+"static/image/21e9e2d7f29b03b55515e91e17d0f12b.69a30c47.webp",s=i.p+"static/image/1cf920a945547f9ef142129496b1239a.52477ece.webp",d=i.p+"static/image/7b81fa12e2fd254f3fe1a3333893ebf5.68dbdcfc.webp",t=i.p+"static/image/269f8d550a84f585741186e31318798c.0de7c4bf.webp",l=i.p+"static/image/15deea2488a0de537d0da1b1e538e6e2.33ae7496.webp",p=i.p+"static/image/2a76061ec22247e943b801a1ee2c8312.94d46dbc.webp",h=i.p+"static/image/51a528c795118ab1308d094f08a80175.943514db.webp",o=i.p+"static/image/9cbc5baf67e2d699a442fb78f2a59282.030f7b26.webp",x=i.p+"static/image/c50a7f3d5a17c0d6bcb570b3aff912d2.924a97a0.webp",j=i.p+"static/image/f5c59131d30bd9d712c1d13fb10fd14e.d18f049b.webp",m=i.p+"static/image/34f897b94b15a39914f29293eb6639e9.992096c9.webp",f=i.p+"static/image/4a971e87ab5df35774e2d19126bad26a.772df203.webp",b=i.p+"static/image/63890d1978c98d0c41e53de3a1cae52d.6f92f8fe.webp",g=i.p+"static/image/ba114e53ac645499e9a060888f2a77f7.e4f44a07.webp",R=i.p+"static/image/672718ee2f8327e80e58865ca11df463.ebea422c.webp",u=i.p+"static/image/a694a861b1f1d81a3202623f090308f7.63d5353c.webp",w=i.p+"static/image/825314493ebb3788f46199d795a3b1db.245f2d54.webp",v=i.p+"static/image/5b38daae6639f853baab1057bd1db251.f9d1fe77.webp",C=i.p+"static/image/2efbcf2b977556eb77b0805324c93f5d.93337ffb.webp",A=i.p+"static/image/b91f4b14b9515a6ad862511b010b42e3.9ccb45a9.webp",N=i.p+"static/image/73882e364ffa267d927a29abe24eff44.a5444bc3.webp",P=i.p+"static/image/0d3d1a007eee39ffb723a41f8765d409.1f84dbc8.webp",E=i.p+"static/image/b36a55b37c1c77a4d667ae386392c5bb.a60b0733.webp",F=i.p+"static/image/5bdab58c029701e8114784ee2a7199b7.b9bf43ba.webp",L=i.p+"static/image/b8750d007d63dd756e9eaf583325cf14.7841f323.webp",y=i.p+"static/image/24ba4054b37927d63e66cfc67dabdc76.4cee0532.webp",_=i.p+"static/image/da5c0a93491a2a8cea83f21f900a5655.6213c391.webp",k=i.p+"static/image/f0247a6dec1108b5176c31f098e09bfd.03d31cdc.webp",B=i.p+"static/image/032c095f3cb0ee9fab0b20705bcce413.5b4a9e4d.webp",S=i.p+"static/image/df15408490cc164788969020b8677912.635ed5a4.webp",I=i.p+"static/image/4ca8c412ec1239f8d46950a9f1ad0bc1.bec2aac3.webp",W=i.p+"static/image/d23705131196f3ba9441884bb062ccbe.27e34559.webp",M=i.p+"static/image/93f66beb771966016de36ca37039596e.222ad2be.webp";function D(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",ul:"ul",li:"li",pre:"pre",code:"code",h2:"h2"},(0,c.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"第15章reactchildren和它的两种替代方案",children:["第15章—React.Children和它的两种替代方案",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第15章reactchildren和它的两种替代方案",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"\uFEFFJSX 的标签体部分会通过 children 的 props 传给组件："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:W,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"在组件里取出 props.children 渲染："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:M,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"但有的时候，我们要对 children 做一些修改。"}),"\n",(0,r.jsx)(e.p,{children:"比如 Space 组件，传入的是 3 个 .box 的 div："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:W,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"但渲染出来的 .box 外面包了一层："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:I,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"这种就需要用 React.Children 的 api 实现。"}),"\n",(0,r.jsx)(e.p,{children:"有这些 api："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Children.count(children)"}),"\n",(0,r.jsx)(e.li,{children:"Children.forEach(children, fn, thisArg?)"}),"\n",(0,r.jsx)(e.li,{children:"Children.map(children, fn, thisArg?)"}),"\n",(0,r.jsx)(e.li,{children:"Children.only(children)"}),"\n",(0,r.jsx)(e.li,{children:"Children.toArray(children)"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"我们来试一下。"}),"\n",(0,r.jsx)(e.p,{children:"用 cra 创建个 react 项目："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"npx create-react-app --template=typescript children-test\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"进入项目，改下 index.tsx"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import ReactDOM from 'react-dom/client';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(<App />);\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后在 App.tsx 里测试下 Children 的 api："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import React, { FC } from 'react';\n\ninterface AaaProps {\n  children: React.ReactNode\n}\n\nconst Aaa: FC<AaaProps> = (props) => {\n  const { children } = props;\n\n  return <div className='container'>\n    {\n      React.Children.map(children, (item) => {\n        return <div className='item'>{item}</div>\n      })\n    }\n  </div>\n}\n\nfunction App() {\n  return <Aaa>\n    <a href=\"#\">111</a>\n    <a href=\"#\">222</a>\n    <a href=\"#\">333</a>\n  </Aaa>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(e.p,{children:"在传入的 children 外包了一层 .item 的 div。"}),"\n",(0,r.jsx)(e.p,{children:"跑一下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"npm run start\n"})}),"\n",(0,r.jsx)(e.p,{children:"可以看到，渲染出的 children 是修改后的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:B,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"有的同学说，直接用数组的 api 可以么？"}),"\n",(0,r.jsx)(e.p,{children:"我们试试："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"interface AaaProps {\n  children: React.ReactNode[]\n}\n\nconst Aaa: FC<AaaProps> = (props) => {\n  const { children } = props;\n\n  return <div className='container'>\n    {\n      // React.Children.map(children, (item) => {\n      children.map(item => {\n        return <div className='item'>{item}</div>\n      })\n    }\n  </div>\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"要用数组的 api 需要把 children 类型声明为 ReactNode[]，然后再用数组的 map 方法："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:_,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"看起来结果貌似一样？"}),"\n",(0,r.jsx)(e.p,{children:"其实并不是。"}),"\n",(0,r.jsx)(e.p,{children:"首先，因为要用数组方法，所以声明了 children 为 ReactNode[]，这就导致了如果 children 只有一个元素会报错："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"更重要的是当 children 传数组的时候："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:L,alt:""})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function App() {\n  return <Aaa>\n    {\n        [\n            <span>111</span>,\n            <span>333</span>,\n            [<span>444</span>, <span>222</span>]\n        ]\n    }\n  </Aaa>\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"数组的 map 处理后是这样的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:F,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"换成 React.Children.map 是这样的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"React.Children.map 会把 children 拍平，而数组的方法不会。"}),"\n",(0,r.jsx)(e.p,{children:"还有一点，有时候直接调用数组的 sort 方法会报错："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import React, { FC } from 'react';\n\ninterface AaaProps {\n  children: React.ReactNode[]\n}\n\nconst Aaa: FC<AaaProps> = (props) => {\n  const { children } = props;\n\n  console.log(children.sort());\n\n  return <div className='container'>\n  </div>\n}\n\nfunction App() {\n  return <Aaa>\n    {33}\n    <span>hello world</span>\n    {22}\n    {11}\n  </Aaa>\n}\n\nexport default App;\n\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"因为 props.children 的元素是只读的，不能重新赋值，所以也就不能排序。"}),"\n",(0,r.jsx)(e.p,{children:"这时候只要用 React.Children.toArray 转成数组就好了："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"（这里不用 children 数组方法了，就直接声明为 ReactNode 类型了）"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"interface AaaProps {\n  children: React.ReactNode\n}\n\nconst Aaa: FC<AaaProps> = (props) => {\n  const { children } = props;\n\n  const arr = React.Children.toArray(children);\n  \n  console.log(arr.sort());\n\n  return <div className='container'>\n  </div>\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"综上，直接用数组方法操作 children 有 3 个问题："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"用数组的方法需要声明 children 为 ReactNode[] 类型，这样就必须传入多个元素才行，而 React.Children 不用"}),"\n",(0,r.jsx)(e.li,{children:"用数组的方法不会对 children 做拍平，而 React.Children 会"}),"\n",(0,r.jsx)(e.li,{children:"用数组的方法不能做排序，因为 children 的元素是只读的，而用 React.Children.toArray 转成数组就可以了"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"当然，不用记这些区别，只要操作 children，就用 React.Children 的 api 就行了。"}),"\n",(0,r.jsx)(e.p,{children:"然后再试下其它 React.Children 的 api："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import React, { FC, useEffect } from 'react';\n\ninterface AaaProps {\n  children: React.ReactNode\n}\n\nconst Aaa: FC<AaaProps> = (props) => {\n  const { children } = props;\n\n  useEffect(() => {\n    const count = React.Children.count(children);\n  \n    console.log('count', count);\n    \n    React.Children.forEach(children, (item, index) => {\n      console.log('item' + index, item);\n    });\n  \n    const first = React.Children.only(children);\n    console.log('first', first);\n  }, []);\n\n  return <div className='container'>\n  </div>\n}\n\nfunction App() {\n  return <Aaa>\n    {33}\n    <span>hello world</span>\n    {22}\n    {11}\n  </Aaa>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"React.Children.count 是计数，forEach 是遍历、only 是如果 children 不是一个元素就报错。"}),"\n",(0,r.jsx)(e.p,{children:"这些 api 都挺简单的。"}),"\n",(0,r.jsx)(e.p,{children:"有的同学可能会注意到，Children 的 api 也被放到了 Legacy 目录下，并提示用 Children 的 api 会导致代码脆弱，建议用别的方式替代："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"我们先看看这些替代方式："}),"\n",(0,r.jsx)(e.p,{children:"首先，我们用 React.Children 来实现这样的功能："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import React, { FC } from 'react';\n\ninterface RowListProps {\n  children?: React.ReactNode\n}\n\nconst RowList: FC<RowListProps> = (props) => {\n  const { children } = props;\n\n  return <div className='row-list'>\n    {\n      React.Children.map(children, item => {\n        return <div className='row'>\n          {item}\n        </div>\n      })\n    }\n  </div>\n}\n\nfunction App() {\n  return <RowList>\n    <div>111</div>\n    <div>222</div>\n    <div>333</div>\n  </RowList>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(e.p,{children:"对传入的 children 做了一些修改之后渲染。"}),"\n",(0,r.jsx)(e.p,{children:"结果如下："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"第一种替代方案是这样的："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import React, { FC } from 'react';\n\ninterface RowProps{\n  children?: React.ReactNode\n}\n\nconst Row: FC<RowProps> = (props) => {\n  const { children } = props;\n  return <div className='row'>\n    {children}\n  </div>\n}\n\ninterface RowListProps{\n  children?: React.ReactNode\n}\n\nconst RowList: FC<RowListProps> = (props) => {\n  const { children } = props;\n\n  return <div className='row-list'>\n    {children}\n  </div>\n}\n\nfunction App() {\n  return <RowList>\n    <Row>\n      <div>111</div>\n    </Row>\n    <Row>\n      <div>222</div>\n    </Row>\n    <Row>\n      <div>333</div>\n    </Row>\n  </RowList>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(e.p,{children:"就是把对 children 包装的那一层封装个组件，然后外面自己来包装。"}),"\n",(0,r.jsx)(e.p,{children:"跑一下："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"这样是可以的。"}),"\n",(0,r.jsx)(e.p,{children:"当然，这里的 RowListProps 和 RowProps 都是只有 children，我们直接用内置类型 PropsWithChildren 来简化下："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import React, { FC, PropsWithChildren } from 'react';\n\nconst Row: FC<PropsWithChildren> = (props) => {\n  const { children } = props;\n  return <div className='row'>\n    {children}\n  </div>\n}\n\nconst RowList: FC<PropsWithChildren> = (props) => {\n  const { children } = props;\n\n  return <div className='row-list'>\n    {children}\n  </div>\n}\n\nfunction App() {\n  return <RowList>\n    <Row>\n      <div>111</div>\n    </Row>\n    <Row>\n      <div>222</div>\n    </Row>\n    <Row>\n      <div>333</div>\n    </Row>\n  </RowList>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(e.p,{children:"第二种方案不使用 chilren 传入具体内容，而是自己定义一个 prop："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { FC, PropsWithChildren, ReactNode } from 'react';\n\ninterface RowListProps extends PropsWithChildren {\n  items: Array<{\n    id: number,\n    content: ReactNode\n  }>\n}\n\nconst RowList: FC<RowListProps> = (props) => {\n  const { items } = props;\n\n  return <div className='row-list'>\n      {\n        items.map(item => {\n          return  <div className='row' key={item.id}>{item.content}</div>\n        })\n      }\n  </div>\n}\n\nfunction App() {\n  return <RowList items={[\n    {\n      id: 1,\n      content: <div>111</div>\n    },\n    {\n      id: 2,\n      content: <div>222</div>\n    },\n    {\n      id: 3,\n      content: <div>333</div>\n    }\n  ]}>\n  </RowList>\n}\n\nexport default App;\n\n"})}),"\n",(0,r.jsx)(e.p,{children:"我们声明了 items 的 props，通过其中的 content 来传入内容。"}),"\n",(0,r.jsx)(e.p,{children:"效果是一样的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"而且还可以通过 render props 来定制渲染逻辑："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { FC, PropsWithChildren, ReactNode } from 'react';\n\ninterface Item {\n  id: number,\n  content: ReactNode\n}\n\ninterface RowListProps extends PropsWithChildren {\n  items: Array<Item>,\n  renderItem: (item: Item) => ReactNode\n}\n\nconst RowList: FC<RowListProps> = (props) => {\n  const { items, renderItem } = props;\n\n  return <div className='row-list'>\n      {\n        items.map(item => {\n          return renderItem(item);\n        })\n      }\n  </div>\n}\n\nfunction App() {\n  return <RowList items={[\n    {\n      id: 1,\n      content: <div>111</div>\n    },\n    {\n      id: 2,\n      content: <div>222</div>\n    },\n    {\n      id: 3,\n      content: <div>333</div>\n    }\n  ]}\n  renderItem={(item) => {\n    return <div className='row' key={item.id}>\n      <div className='box'>\n          {item.content}\n      </div>\n    </div>\n  }}\n  >\n  </RowList>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"综上，替代 props.children 有两种方案："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"把对 children 的修改封装成一个组件，使用者用它来手动包装"}),"\n",(0,r.jsx)(e.li,{children:"声明一个 props 来接受数据，内部基于它来渲染，而且还可以传入 render props 让使用者定制渲染逻辑"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"但是这些替代方案使用起来和 React.Children 还是不同的。"}),"\n",(0,r.jsx)(e.p,{children:"React.Children 使用起来是无感的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"而这两种替代方案使用起来是这样的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"虽然能达到同样的效果，但是还是用 React.Children 内部修改 children 的方式更易用一些。"}),"\n",(0,r.jsx)(e.p,{children:"而且现在各大组件库依然都在大量用 React.Children"}),"\n",(0,r.jsx)(e.p,{children:"比如 semi design 的代码："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"arco design 的代码："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"ant design 的代码："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"比如我们上节写过的 Space 组件："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"所以 React.Children 还是可以继续用的，因为这些替代方案和 React.Children 还是有差距。"}),"\n",(0,r.jsxs)(e.p,{children:["案例代码上传了",(0,r.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/children-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们学了用 React.Children 来修改 children，它有 map、forEach、toArray、only、count 等方法。"}),"\n",(0,r.jsx)(e.p,{children:"不建议直接用数组方法来操作，而是用 React.Children 的 api。"}),"\n",(0,r.jsx)(e.p,{children:"原因有三个："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"当然，Children 的 api 被放到了 legacy 目录，可以用这两种方案来替代："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"不过，这两种替代方案易用性都不如 React.Children，各大组件库也依然大量使用 React.Children 的 api。"}),"\n",(0,r.jsx)(e.p,{children:"所以，遇到需要修改渲染的 children 的情况，用 React.Children  的 api，或是两种替代方案（抽离渲染逻辑为单独组件、传入数据 + render props）都可以。"})]})}function O(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(D,{...n})}):D(n)}let T=O;O.__RSPRESS_PAGE_META={},O.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC15%E7%AB%A0%E2%80%94React.Children%E5%92%8C%E5%AE%83%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第15章—React.Children和它的两种替代方案",headingTitle:"第15章—React.Children和它的两种替代方案",frontmatter:{}}}}]);