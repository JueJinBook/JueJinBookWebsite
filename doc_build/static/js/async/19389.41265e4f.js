"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19389"],{93696:function(e,n,c){e.exports=c.p+"static/image/665849c1cb28dc61387a2f9636c05691.fe811354.webp"},142657:function(e,n,c){c.r(n),c.d(n,{default:()=>B});var r=c(552676),i=c(740453);let s=c.p+"static/image/abd6bcf646fc899c6f4b666ab7c5e26a.de610db1.webp",t=c.p+"static/image/1355d53aa19b3b33c3cd19ef038182ba.47241867.webp",a=c.p+"static/image/6405cc9071028f2e31f87d2bdabef117.9b41c6c7.webp",d=c.p+"static/image/9383d2f83be545edabd25ac39aae4640.9c214808.webp",l=c.p+"static/image/4ec98ebb124cd943d0e4e193d71fb48e.a13d4d5d.webp",p=c.p+"static/image/ac5c6657d80d206871ca5fc854445202.c43dbc9f.webp",h=c.p+"static/image/f88af6b79037148d14e57448007f9a44.6d4604e6.webp",x=c.p+"static/image/45f4fc4154466459ba15918cb31e2c56.f4b167ae.webp",j=c.p+"static/image/50d24ac473e2801f3fe20c11de5d873f.0942a3ea.webp",o=c.p+"static/image/d2fe4e8863a652686ea06e58940c9ff5.cb4d7a75.webp",u=c.p+"static/image/7db6f3a374f137686dccd7f57dcb1e8e.2f8dd8cf.webp",f=c.p+"static/image/4b680cbdd46ed559000bc4ba7f950e1b.a6f33db3.webp",b=c.p+"static/image/f9105af12eb4e27366a49940a057c2f6.1ae636f1.webp",m=c.p+"static/image/3e06abaf61002d47ae2d366f91510710.af211398.webp",g=c.p+"static/image/a70f0ba0aab654c6f76a714c75b49f22.66ca0172.webp",S=c.p+"static/image/abf1c85e261b17771389845c354c7971.571d7165.webp",w=c.p+"static/image/beb68bc4e16ead2d70306355c73eabff.e2a92ca5.webp",v=c.p+"static/image/6f11510086f0066d6f25b3d708105cef.6cacbc66.webp",E=c.p+"static/image/e517139c413ecf6a050316f9746b7931.a3c936c0.webp",L=c.p+"static/image/8b5d2af409c17c56475d5632a5e33d56.8c3426eb.webp",R=c.p+"static/image/e23a70ebb2c0a189b5a9fc490cc74a46.76a59393.webp",T=c.p+"static/image/671fcc5a32b9c6516531945027a4a6ce.d3f7dc16.webp",k=c.p+"static/image/0e2c48e87f8a0befc1200352461b6abd.386efa28.webp";var C=c(93696);let A=c.p+"static/image/9bcb2b512c4a7eecf54b9b11a43b35be.fa2737db.webp",D=c.p+"static/image/ca15cd711c1f305204f0bafbc85dddd2.4bfe1630.webp",P=c.p+"static/image/bbfeba2866048fdc343c1af542ea899f.8d9d020e.webp";function _(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",strong:"strong",ul:"ul",li:"li",pre:"pre",code:"code"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"第65章react18的并发机制是怎么实现的",children:["第65章—React18的并发机制是怎么实现的",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第65章react18的并发机制是怎么实现的",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"\uFEFFReact 18 最主要的特性就是并发了，很多 api 都是基于并发特性实现的。"}),"\n",(0,r.jsx)(n.p,{children:"那为什么 React 要实现并发？什么是并发？又是怎么实现的呢？"}),"\n",(0,r.jsx)(n.p,{children:"这节我们就一起来探究一下。"}),"\n",(0,r.jsx)(n.p,{children:"首先，我们过一遍 React 渲染的流程："}),"\n",(0,r.jsxs)(n.h2,{id:"react-渲染流程",children:["React 渲染流程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-渲染流程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"React 是通过 JSX 描述页面的，JSX 编译成 render function（也就是 React.createElement 等），执行之后产生 vdom。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"vdom 是指 React Element 的对象树："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"之后这个 vdom 会转换为 fiber 结构："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"vdom 是通过 children 关联子节点，而 fiber 通过 child、sibling、return 关联了父节点、子节点、兄弟节点。"}),"\n",(0,r.jsx)(n.p,{children:"从 vdom 转 fiber 的过程叫做 reconcile，这个过程还会创建用到的 dom 节点，并且打上增删改的标记。"}),"\n",(0,r.jsx)(n.p,{children:"这个 reconcile 的过程叫做 render 阶段。"}),"\n",(0,r.jsx)(n.p,{children:"之后 commit 阶段会根据标记来增删改 dom。"}),"\n",(0,r.jsx)(n.p,{children:"commit 阶段也分为了 3 个小阶段，before mutation、mutation、layout。"}),"\n",(0,r.jsx)(n.p,{children:"mutation 阶段会增删改 dom，before mutation 是在 dom 操作之前，layout 是在 dom 操作之后。"}),"\n",(0,r.jsx)(n.p,{children:"综上，React 整体的渲染流程就是 render（reconcile 的过程） + commit（执行增删改 dom 和 effect、生命周期函数的执行、ref 的更新等）。"}),"\n",(0,r.jsx)(n.p,{children:"当你 setState 之后，就会触发一次渲染的流程，也就是上面的 render + commit。"}),"\n",(0,r.jsx)(n.p,{children:"当然，除了 setState 之外，入口处的 ReactDOM.render 还有函数组件里的 useState 也都能触发渲染。"}),"\n",(0,r.jsx)(n.p,{children:"那么问题来了，如果同时有多个 setState 触发的渲染，怎么处理呢？"}),"\n",(0,r.jsxs)(n.h2,{id:"同步-vs-并发",children:["同步 vs 并发",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#同步-vs-并发",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"每次 setState 都会进行上面的那个 render + commit 的渲染流程，多次那就顺序处理不就行了？"}),"\n",(0,r.jsx)(n.p,{children:"这样是能满足功能的，也就是同步模式。"}),"\n",(0,r.jsx)(n.p,{children:"但是有个问题，比如用户在 input 输入内容的时候，会通过 setState 设置到状态里，会触发重新渲染。"}),"\n",(0,r.jsx)(n.p,{children:"这时候如果还有一个列表也会根据 input 输入的值来处理显示的数据，也会 setState 修改自己的状态。"}),"\n",(0,r.jsx)(n.p,{children:"这两个 setState 会一起发生，那么同步模式下也就会按照顺序依次执行。"}),"\n",(0,r.jsx)(n.p,{children:"但如果这个渲染流程中处理的 fiber 节点比较多，渲染一次就比较慢，这时候用户输入的内容可能就不能及时的渲染出来，用户就会感觉卡，体验不好。"}),"\n",(0,r.jsx)(n.p,{children:"怎么解决这个问题呢？"}),"\n",(0,r.jsx)(n.p,{children:"能不能指定这俩 setState 的重要程度不一样，用户输入的 setState 的更新重要程度更高，如果有这种更新就把别的先暂停，执行这次更新，执行完之后再继续处理。"}),"\n",(0,r.jsx)(n.p,{children:"React 18 里确实实现了这样一套并发的机制，这里的重要程度就是优先级，也就是基于优先级的可打断的渲染流程。"}),"\n",(0,r.jsx)(n.p,{children:"React 会把 vdom 树转成 fiber 链表，因为 vdom 里只有 children，没有 parent、sibling 信息，而 fiber 节点里有，这样就算打断了也可以找到下一个节点继续处理。fiber 结构就是为实现并发而准备的。"}),"\n",(0,r.jsx)(n.p,{children:"按照 child、sibling、sibling、return、sibling、return 之类的遍历顺序，可以把整个 vdom 树变成线性的链表结构，一个循环就可以处理完。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"循环处理每个 fiber 节点的时候，有个指针记录着当前的 fiber 节点，叫做 workInProgress。"}),"\n",(0,r.jsx)(n.p,{children:"这个循环叫做 workLoop："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当然，上面这个是同步模式下的循环。"}),"\n",(0,r.jsx)(n.p,{children:"那并发模式下呢？"}),"\n",(0,r.jsx)(n.p,{children:"首先，并发和并行不一样，并行是同一时刻多件事情同时进行，而并发是只要一段时间内同时发生多件事情就行。"}),"\n",(0,r.jsx)(n.p,{children:"并发是通过交替执行来实现的，也就是这样："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"上面是两个 setState 引起的两个渲染流程，先处理上面那次渲染的 1、2、3 的 fiber 节点，然后处理下面那次渲染的 1、2、3、4、5、6 的 fiber 节点，之后继续处理上面那次渲染的 4、5、6 的 fiber 节点。"}),"\n",(0,r.jsx)(n.p,{children:"这就是并发。"}),"\n",(0,r.jsx)(n.p,{children:"也就是在循环里多了个打断和恢复的机制，所以代码是这样的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"每处理一个 fiber 节点，都判断下是否打断，shouldYield 返回 true 的时候就终止这次循环。"}),"\n",(0,r.jsx)(n.p,{children:"那怎么恢复呢？"}),"\n",(0,r.jsx)(n.p,{children:"每次 setState 引起的渲染都是由 Scheduler 调度执行的，它维护了一个任务队列，上个任务执行完执行下个。"}),"\n",(0,r.jsx)(n.p,{children:"没渲染完的话，再加一个新任务进去不就行了？"}),"\n",(0,r.jsx)(n.p,{children:"判断是否是被中断的还是已经渲染完了，这个也很简单，当全部 fiber 节点都渲染完，那 workInProgress 的指针就是 null 了。"}),"\n",(0,r.jsx)(n.p,{children:"而如果是渲染到一半 yield 的，那 wip 就不是 null。"}),"\n",(0,r.jsx)(n.p,{children:"所以可以这样根据 wip 是否是 null 判断是否是中断了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:L,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后把剩下的节点 schdule 就好了。当再次 schedule 到这个任务，就会继续渲染。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这就是并发模式的实现，也就是在 workLoop 里通过 shouldYield 的判断来打断渲染，之后把剩下的节点加入 Schedule 调度，来恢复渲染。"}),"\n",(0,r.jsx)(n.p,{children:"那 shouldYield 是根据什么来打断的呢？"}),"\n",(0,r.jsx)(n.p,{children:"根据过期时间，每次开始处理时记录个时间，如果处理完这个 fiber 节点，时间超了，那就打断。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那优先级呢？不会根据任务优先级打断么？"}),"\n",(0,r.jsx)(n.p,{children:"并不会，优先级高低会影响 Scheduler 里的 taskQueue 的排序结果，但打断只会根据过期时间。"}),"\n",(0,r.jsx)(n.p,{children:"也就是时间分片的含义。"}),"\n",(0,r.jsx)(n.p,{children:"那这样就算并发了，不还是高优先级任务得不到即使执行？"}),"\n",(0,r.jsx)(n.p,{children:"那不会，因为一个时间分片是 5ms，所以按照按优先级排序好的任务顺序来执行，就能让高优先级任务得到及时处理。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["这个地方也是很多同学的误区，",(0,r.jsx)(n.strong,{children:"react 的并发模式的打断只会根据时间片，也就是每 5ms 就打断一次，并不会根据优先级来打断，优先级只会影响任务队列的任务排序。"})]}),"\n",(0,r.jsx)(n.p,{children:"那具体都有哪些优先级呢？"}),"\n",(0,r.jsxs)(n.h2,{id:"react-里的优先级",children:["react 里的优先级",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-里的优先级",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先，上面谈到的优先级是调度任务的优先级，有这 5 种："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"Immediate 是离散的一些事件，比如 click、keydown、input 这种。"}),"\n",(0,r.jsx)(n.p,{children:"UserBlocking 是连续的一些事件，比如 scroll、drag、mouseover 这种。"}),"\n",(0,r.jsx)(n.p,{children:"react 是这么划分的，离散的事件比连续事件优先级更高，这个倒是很容易理解。"}),"\n",(0,r.jsx)(n.p,{children:"然后是默认的优先级 NormalPriority、再就是低优先级 LowPriority，空闲优先级 IdlePriority。"}),"\n",(0,r.jsx)(n.p,{children:"Scheduler 会根据任务的优先级对任务排序来调度。"}),"\n",(0,r.jsx)(n.p,{children:"并发模式下不同的 setState 的优先级不同，就是通过指定 Scheduler 的优先级实现的。"}),"\n",(0,r.jsx)(n.p,{children:"但在 React 里优先级不是直接用这个。"}),"\n",(0,r.jsx)(n.p,{children:"因为 Schduler 是分离的一个包了，它的优先级机制也是独立的。"}),"\n",(0,r.jsx)(n.p,{children:"而且 React 有自己的一套优先级机制，那个分类可不止上面这 5 种，足足有 31 种，React 的那套优先级机制叫做 Lane。"}),"\n",(0,r.jsx)(n.p,{children:"31 种？那就是从 0 到 31 的数字呗 ？"}),"\n",(0,r.jsx)(n.p,{children:"并不是，react 是通过二机制的方式来保存不同优先级的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样设计的好处，自然是可以用二进制运算快速得到是哪种优先级了："}),"\n",(0,r.jsx)(n.p,{children:"比如按位与、按位或等："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样性能会更好一点，位运算的性能肯定是最高的。"}),"\n",(0,r.jsx)(n.p,{children:"不过不好的地方是看这样的代码会绕一点。"}),"\n",(0,r.jsx)(n.p,{children:"那为啥就 Lane 呢？"}),"\n",(0,r.jsx)(n.p,{children:"Lane 是赛道的意思，看二进制的这种表示方式："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"是不是就很像赛道："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这就是为啥 react 的优先级机制叫 Lane，就是形象地表示了这种二进制的优先级存储方式。"}),"\n",(0,r.jsx)(n.p,{children:"除了 react 的 lane 的优先级机制外，react 还给事件也区分了优先级："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"DiscreteEventPriority 离散事件优先级"}),"\n",(0,r.jsx)(n.li,{children:"ContinuousEventPriority 连续事件优先级"}),"\n",(0,r.jsx)(n.li,{children:"DefaultEventPriority 默认事件优先级"}),"\n",(0,r.jsx)(n.li,{children:"IdleEventPriority 空闲事件优先级"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"事件的优先级会转化为 react 的 Lane 优先级，Lane 的优先级也可以转化为事件优先级。"}),"\n",(0,r.jsx)(n.p,{children:"那 react 通过 Scheduler 调度任务的时候，优先级是怎么转呢？"}),"\n",(0,r.jsx)(n.p,{children:"先把 Lane 转换为事件优先级，然后再转为 Scheduler 优先级。"}),"\n",(0,r.jsx)(n.p,{children:"为什么呢？"}),"\n",(0,r.jsx)(n.p,{children:"因为 Lane 的优先级有 31 个啊，而事件优先级那 4 个刚好和 Scheduler 的优先级对上。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"怎么实现的 Lane 优先级转 Event 优先级，那就是有几个分界点了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"也就是说，react 内部有 31 种 Lane 优先级，但是调度 Scheduler 任务的时候，会先转成事件优先级，然后再转成 Scheduler 的 5 种优先级。"}),"\n",(0,r.jsx)(n.p,{children:"知道了时间分片和优先级机制，那我们对 react 的并发模式的实现原理也就算比较了解了。"}),"\n",(0,r.jsx)(n.p,{children:"接下来看一些基于并发模式实现的 api："}),"\n",(0,r.jsxs)(n.h2,{id:"usetransitionusedeferredvalue",children:["useTransition、useDeferredValue",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usetransitionusedeferredvalue",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面介绍了两种 workLoop 的执行方式："}),"\n",(0,r.jsx)(n.p,{children:"同步执行："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"并发执行："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"所谓的并发执行就是加了个 5ms 一次的时间分片。"}),"\n",(0,r.jsx)(n.p,{children:"react18 里同时存在着这两种循环方式，普通的循环和带时间分片的循环。"}),"\n",(0,r.jsx)(n.p,{children:"也不是所有的特性都要时间分片，只有部分需要。"}),"\n",(0,r.jsx)(n.p,{children:"那就如果这次 setState 更新里包含了并发特性，就是用 workLoopConcurrent，否则走 workLooSync 就好了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如上，react 会根据 lane 来判断是否要开启时间分片。"}),"\n",(0,r.jsx)(n.p,{children:"看到这其实就能理解什么是并发特性的 api 了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"所有能设置开启时间分片的 lane 的 api 都是基于并发的 api。"})}),"\n",(0,r.jsx)(n.p,{children:"比如 startTransition、useTransition、useDeferredValue 这些。"}),"\n",(0,r.jsx)(n.p,{children:"我们知道并发特性是可以给不同的 setState 标上不同的优先级的，怎么标呢？"}),"\n",(0,r.jsx)(n.p,{children:"就通过 trasition 的 api："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React, { useTransition, useState } from \"react\";\n\nexport default function App() {\n  const [text, setText] = useState('guang');\n  const [text2, setText2] = useState('guang2');\n\n  const [isPending, startTransition] = useTransition()\n\n  const handleClick = () => {\n    startTransition(() => {\n      setText('dong');\n    });\n\n    setText2('dong2');\n  }\n\n  return (\n    <button onClick={handleClick}>{text}{text2}</button>\n  );\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"比如上面有两个 setState，其中一个优先级高，另一个优先级低，那就把低的那个用 startTransition 包裹起来。"}),"\n",(0,r.jsx)(n.p,{children:"就可以实现高优先级的那个优先渲染。"}),"\n",(0,r.jsx)(n.p,{children:"怎么实现的呢？"}),"\n",(0,r.jsx)(n.p,{children:"我们来看下源码："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"源码里是在调用回调函数之前设置了更新的优先级为 ContinuousEvent 的优先级，也就是连续事件优先级，比 DiscreteEvent 离散事件优先级更低，所以会比另一个 setState 触发的渲染的优先级低，在调度的时候排在后面。"}),"\n",(0,r.jsx)(n.p,{children:"这里设置的其实就是 Lane 的优先级："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那渲染的时候就会走 workLoopConcurrent 的带时间分片的循环，然后通过 Scheduler 对任务按照优先级排序，就实现了高优先级的渲染先执行的效果。"}),"\n",(0,r.jsx)(n.p,{children:"这就是 startTransition、useTransition 的用法和原理。"}),"\n",(0,r.jsx)(n.p,{children:"再就是 useDeferredValue 的 api，它的应用场景是这样的："}),"\n",(0,r.jsx)(n.p,{children:"比如这样一段代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function App() {\n  const [text, setText] = useState("");\n\n  const handleChange = (e) => {\n    setText(e.target.value);\n  };\n\n  return (\n    <div>\n      <input value={text} onChange={handleChange}/>\n      <List text={text}/>\n    </div>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"List 里是根据输入的 text 来过滤结果展示的，现在每次输入都会触发渲染。"}),"\n",(0,r.jsx)(n.p,{children:"我们希望在内容输入完了再处理通知 List 渲染，就可以这样："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function App() {\n  const [text, setText] = useState("");\n  const deferredText = useDeferredValue(text);\n\n  const handleChange = (e) => {\n    setText(e.target.value);\n  };\n\n  return (\n    <div>\n      <input value={text} onChange={handleChange}/>\n      <List text={deferredText}/>\n    </div>\n  );\n};\nfunction \n'})}),"\n",(0,r.jsx)(n.p,{children:"对 state 用 useDeferredValue 包裹之后，新的 state 就会放到下一次更新。"}),"\n",(0,r.jsx)(n.p,{children:"这部分的源码看 react17 的比较容易理解："}),"\n",(0,r.jsx)(n.p,{children:"react 17 里就是通过 useEffect 把这个值的更新时机延后了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"也就是其他的 setState 触发的 render 处理完了之后，在 commit 阶段去 setState，这就是 DeferedValue 的意思。"}),"\n",(0,r.jsx)(n.p,{children:"react 18 里也有这个 api，虽然功能一样，但实现变了，现在是基于并发模式的，通过 Lane 的优先级实现的延后更新。"}),"\n",(0,r.jsx)(n.p,{children:"这俩都是基于并发机制，也就是基于 Lane 的优先级实现的 api。当用到这些 api 的时候，react 才会启用 workLoopConcurrent 带时间分片的循环。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"react 的渲染流程是 render + commit。render 阶段实现 vdom 转 fiber 的 reconcile，之后 commit 阶段执行增删改 dom，更新 ref、调用 effect 回调和生命周期函数等。"}),"\n",(0,r.jsx)(n.p,{children:"多次 setState 会引起多个渲染流程，这之间可能有重要程度的不同，也就是优先级的不同。"}),"\n",(0,r.jsx)(n.p,{children:"为了让高优先级的更新能先渲染，react 实现了并发模式。"}),"\n",(0,r.jsx)(n.p,{children:"同步模式是循环处理 fiber 节点，并发模式多了个 shouldYield 的判断，每 5ms 打断一次，也就是时间分片。并且之后会重新调度渲染。"}),"\n",(0,r.jsx)(n.p,{children:"通过这种打断和恢复的方式实现了并发。"}),"\n",(0,r.jsx)(n.p,{children:"然后 Scheduler 可以根据优先级来对任务排序，这样就可以实现高优先级的更新先执行。"}),"\n",(0,r.jsx)(n.p,{children:"react 里有 Lane 的优先级机制，基于二进制设计的。它和事件的优先级机制、Scheduler 的优先级机制能够对应上。调度任务的时候先把 Lane 转事件优先级，然后转 Scheduler 的优先级。"}),"\n",(0,r.jsx)(n.p,{children:"react18 的 useTransition、useDeferredValue 都是基于并发特性实现的，useTransition 是把回调函数里的更新设置为连续事件的优先级，比离散事件的优先级低。useDeferredValue 则是延后更新 state 的值。"}),"\n",(0,r.jsx)(n.p,{children:"这些并发特性的 api 都是通过设置 Lane 实现的，react 检测到对应的 Lane 就会开启带有时间分片的 workLoopConcurrent 循环。"}),"\n",(0,r.jsx)(n.p,{children:"时间分片的 workLoop + 优先级调度，这就是 React 并发机制的实现原理。这就是 React 并发机制的实现原理。"})]})}function y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_,{...e})}):_(e)}let B=y;y.__RSPRESS_PAGE_META={},y.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC65%E7%AB%A0%E2%80%94React18%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.md"]={toc:[{text:"React 渲染流程",id:"react-渲染流程",depth:2},{text:"同步 vs 并发",id:"同步-vs-并发",depth:2},{text:"react 里的优先级",id:"react-里的优先级",depth:2},{text:"useTransition、useDeferredValue",id:"usetransitionusedeferredvalue",depth:2},{text:"总结",id:"总结",depth:2}],title:"第65章—React18的并发机制是怎么实现的",headingTitle:"第65章—React18的并发机制是怎么实现的",frontmatter:{}}}}]);