"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["66024"],{208464:function(n,e,t){t.r(e),t.d(e,{default:()=>o});var s=t(552676),r=t(740453);let c=t.p+"static/image/221910a2827d8fe88616594015cea89c.d0c61b72.webp";function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",blockquote:"blockquote",img:"img",h2:"h2",strong:"strong",pre:"pre",ul:"ul",li:"li"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"2基础篇10-种-react-hooks-api-的介绍和使用v16-篇",children:["2.基础篇｜10 种 React Hooks API 的介绍和使用（v16 篇）",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2基础篇10-种-react-hooks-api-的介绍和使用v16-篇",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["俗话说得好：工欲善其事必先利其器，就是说，我们想要去玩转",(0,s.jsx)(e.code,{children:"React Hooks"}),"，就必须知道 React 官方提供了哪些 Hooks，如何去使用这些 Hooks。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["问：工作中只用到",(0,s.jsx)(e.code,{children:"useState"}),"、",(0,s.jsx)(e.code,{children:"useEffect"}),"等 Hooks，有必要学习不常见的 Hooks 吗？"]}),"\n",(0,s.jsx)(e.p,{children:"答：作为一名前端，应该有属于自己的技术体系，由浅入深，从广度到深度，一步一步地逐渐将架子搭起来，就算在工作中不常使用，但至少要有个概念。知识广度的提升可以让解决方法多一种，所以我们应该熟练掌握这些 API。"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["通过本节的阅读，你将学会 ",(0,s.jsx)(e.code,{children:"React v16.8"})," 中提供的 ",(0,s.jsx)(e.code,{children:"useState"}),"、",(0,s.jsx)(e.code,{children:"useEffect"}),"、",(0,s.jsx)(e.code,{children:"useContext"}),"、",(0,s.jsx)(e.code,{children:"useReducer"}),"、",(0,s.jsx)(e.code,{children:"useMemo"}),"、",(0,s.jsx)(e.code,{children:"useCallback"}),"、",(0,s.jsx)(e.code,{children:"useRef"}),"、",(0,s.jsx)(e.code,{children:"useImperativeHandle"}),"、",(0,s.jsx)(e.code,{children:"useLayoutEffect"}),"、",(0,s.jsx)(e.code,{children:"useDebugValue"})," 10 个 API 的使用方法。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(e.h2,{id:"1-usestate",children:["1. useState",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-usestate",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useState："})," 定义变量，使其具备类组件的 ",(0,s.jsx)(e.code,{children:"state"}),"，让函数式组件拥有更新视图的能力。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const [state, setState] = useState(initData)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"initData：默认初始值，有两种情况：函数和非函数，如果是函数，则函数的返回值作为初始值。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Result："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["state：数据源，用于渲染",(0,s.jsx)(e.code,{children:"UI 层"}),"的数据源；"]}),"\n",(0,s.jsxs)(e.li,{children:["setState：改变数据源的函数，可以理解为类组件的 ",(0,s.jsx)(e.code,{children:"this.setState"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"基本用法："})," 主要介绍两种",(0,s.jsx)(e.code,{children:"setState"}),"的使用方法。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState } from "react";\nimport { Button } from "antd";\n\nconst Index: React.FC<any> = () => {\n  const [count, setCount] = useState<number>(0);\n\n  return (\n    <>\n      <div>数字：{count}</div>\n      <Button type="primary" onClick={() => setCount(count + 1)}>\n        第一种方式+1\n      </Button>\n      <Button\n        type="primary"\n        style={{ marginLeft: 10 }}\n        onClick={() => setCount((v) => v + 1)}\n      >\n        第二种方式+1\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"注意："})," ",(0,s.jsx)(e.code,{children:"useState"})," 有点类似于 ",(0,s.jsx)(e.code,{children:"PureComponent"}),"，它会进行一个比较浅的比较，这就导致了一个问题，如果是对象直接传入的时候，并不会实时更新，这点一定要切记。"]}),"\n",(0,s.jsx)(e.p,{children:"我们做个简单的对比，比如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState } from "react";\nimport { Button } from "antd";\n\nconst Index: React.FC<any> = () => {\n  const [state, setState] = useState({ number: 0 });\n  let [count, setCount] = useState(0);\n\n  return (\n    <>\n      <div>数字形式：{count}</div>\n      <Button\n        type="primary"\n        onClick={() => {\n          count++;\n          setCount(count);\n        }}\n      >\n        点击+1\n      </Button>\n      <div>对象形式：{state.number}</div>\n      <Button\n        type="primary"\n        onClick={() => {\n          state.number++;\n          setState(state);\n        }}\n      >\n        点击+1\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"2--useeffect",children:["2.  useEffect",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2--useeffect",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useEffect："})," 副作用，这个钩子成功弥补了函数式组件没有生命周期的缺陷，是我们最常用的钩子之一。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"useEffect(()=>{ \n    return destory\n}, deps)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["callback：useEffect 的第一个入参，最终返回 ",(0,s.jsx)(e.code,{children:"destory"}),"，它会在下一次 callback 执行之前调用，其作用是清除上次的 callback 产生的副作用；"]}),"\n",(0,s.jsx)(e.li,{children:"deps：依赖项，可选参数，是一个数组，可以有多个依赖项，通过依赖去改变，执行上一次的 callback 返回的 destory 和新的 effect 第一个参数 callback。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"是不是听介绍感觉有点懵，别着急，我们依此来看看。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"模拟挂载和卸载阶段"})," ",(0,s.jsx)(e.strong,{children:"："})]}),"\n",(0,s.jsxs)(e.p,{children:["事实上，destory 会用在组件卸载阶段上，把它当作组件卸载时执行的方法就 ok，通常用于监听 ",(0,s.jsx)(e.code,{children:"addEventListener"})," 和 ",(0,s.jsx)(e.code,{children:"removeEventListener"})," 上，如："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useEffect } from "react";\nimport { Button } from "antd";\n\nconst Child = () => {\n  useEffect(() => {\n    console.log("挂载");\n\n    return () => {\n      console.log("卸载");\n    };\n  }, []);\n\n  return <div>大家好，我是小杜杜，一起学习hooks吧！</div>;\n};\n\nconst Index: React.FC<any> = () => {\n  const [flag, setFlag] = useState(false);\n\n  return (\n    <>\n      <Button\n        type="primary"\n        onClick={() => {\n          setFlag((v) => !v);\n        }}\n      >\n        {flag ? "卸载" : "挂载"}\n      </Button>\n      {flag && <Child />}\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"依赖变化："})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"dep"}),"的个数决定",(0,s.jsx)(e.code,{children:"callback"}),"什么时候执行，如："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useEffect } from "react";\nimport { Button } from "antd";\n\nconst Index: React.FC<any> = () => {\n  const [number, setNumber] = useState(0);\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log("count改变才会执行");\n  }, [count]);\n\n  return (\n    <>\n      <div>\n        number: {number} count: {count}\n      </div>\n      <Button type="primary" onClick={() => setNumber((v) => v + 1)}>\n        number + 1\n      </Button>\n      <Button\n        type="primary"\n        style={{ marginLeft: 10 }}\n        onClick={() => setCount((v) => v + 1)}\n      >\n        count + 1\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"无限执行："})}),"\n",(0,s.jsx)(e.p,{children:"当 useEffect 的第二个参数 deps 不存在时，会无限执行。更加准确地说，只要数据源发生变化（不限于自身中），该函数都会执行，所以请不要这么做，否则会出现不可控的现象。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useEffect } from "react";\nimport { Button } from "antd";\n\nconst Index: React.FC<any> = () => {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n\n  useEffect(() => {\n    console.log("大家好，我是小杜杜，一起学习hooks吧！");\n  });\n\n  return (\n    <>\n      <Button type="primary" onClick={() => setCount((v) => v + 1)}>\n        数字加一：{count}\n      </Button>\n      <Button\n        type="primary"\n        style={{ marginLeft: 10 }}\n        onClick={() => setFlag((v) => !v)}\n      >\n        状态切换：{JSON.stringify(flag)}\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"3-usecontext",children:["3. useContext",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-usecontext",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useContext："})," 上下文，类似于 ",(0,s.jsx)(e.code,{children:"Context"}),"，其本意就是设置全局共享数据，使所有组件可跨层级实现共享。"]}),"\n",(0,s.jsxs)(e.p,{children:["useContext 的参数一般是由 ",(0,s.jsx)(e.code,{children:"createContext"})," 创建，或者是父级上下文 ",(0,s.jsx)(e.code,{children:"context"}),"传递的，通过 ",(0,s.jsx)(e.code,{children:"CountContext.Provider"})," 包裹的组件，才能通过 ",(0,s.jsx)(e.code,{children:"useContext"})," 获取对应的值。我们可以简单理解为 ",(0,s.jsx)(e.code,{children:"useContext"})," 代替 ",(0,s.jsx)(e.code,{children:"context.Consumer"})," 来获取 ",(0,s.jsx)(e.code,{children:"Provider"})," 中保存的 ",(0,s.jsx)(e.code,{children:"value"})," 值。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const contextValue = useContext(context)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"context：一般而言保存的是 context 对象。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Result："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["contextValue：返回的数据，也就是",(0,s.jsx)(e.code,{children:"context"}),"对象内保存的",(0,s.jsx)(e.code,{children:"value"}),"值。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"基本用法："})," 子组件 Child 和孙组件 Son，共享父组件 Index 的数据 count。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, createContext, useContext } from "react";\nimport { Button } from "antd";\n\nconst CountContext = createContext(-1);\n\nconst Child = () => {\n  const count = useContext(CountContext);\n\n  return (\n    <div style={{ marginTop: 10 }}>\n      子组件获取到的count: {count}\n      <Son />\n    </div>\n  );\n};\n\nconst Son = () => {\n  const count = useContext(CountContext);\n\n  return <div style={{ marginTop: 10 }}>孙组件获取到的count: {count}</div>;\n};\n\nconst Index: React.FC<any> = () => {\n  let [count, setCount] = useState(0);\n\n  return (\n    <>\n      <div>父组件中的count：{count}</div>\n      <Button type="primary" onClick={() => setCount((v) => v + 1)}>\n        点击+1\n      </Button>\n      <CountContext.Provider value={count}>\n        <Child />\n      </CountContext.Provider>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"4--usereducer",children:["4.  useReducer",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4--usereducer",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["useReducer： 功能类似于 ",(0,s.jsx)(e.code,{children:"redux"}),"，与 redux 最大的不同点在于它是单个组件的状态管理，组件通讯还是要通过 props。简单地说，useReducer 相当于是 useState 的升级版，用来处理复杂的 state 变化。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const [state, dispatch] = useReducer(\n    (state, action) => {}, \n    initialArg,\n    init\n);\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"reducer：函数，可以理解为 redux 中的 reducer，最终返回的值就是新的数据源 state；"}),"\n",(0,s.jsx)(e.li,{children:"initialArg：初始默认值；"}),"\n",(0,s.jsx)(e.li,{children:"init：惰性初始化，可选值。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Result："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"state：更新之后的数据源；"}),"\n",(0,s.jsxs)(e.li,{children:["dispatch：用于派发更新的",(0,s.jsx)(e.code,{children:"dispatchAction"}),"，可以认为是",(0,s.jsx)(e.code,{children:"useState"}),"中的",(0,s.jsx)(e.code,{children:"setState"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：什么是惰性初始化？"}),"\n",(0,s.jsxs)(e.p,{children:["答：惰性初始化是一种延迟创建对象的手段，直到被需要的第一时间才去创建，这样做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利。换句话说，如果有 ",(0,s.jsx)(e.code,{children:"init"}),"，就会取代 ",(0,s.jsx)(e.code,{children:"initialArg"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本用法："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useReducer } from "react";\nimport { Button } from "antd";\n\nconst Index: React.FC<any> = () => {\n  const [count, dispatch] = useReducer((state: number, action: any) => {\n    switch (action?.type) {\n      case "add":\n        return state + action?.payload;\n      case "sub":\n        return state - action?.payload;\n      default:\n        return state;\n    }\n  }, 0);\n\n  return (\n    <>\n      <div>count：{count}</div>\n      <Button\n        type="primary"\n        onClick={() => dispatch({ type: "add", payload: 1 })}\n      >\n        加1\n      </Button>\n      <Button\n        type="primary"\n        style={{ marginLeft: 10 }}\n        onClick={() => dispatch({ type: "sub", payload: 1 })}\n      >\n        减1\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"特别注意："})," 在 reducer 中，如果返回的 state 和之前的 state 值相同，那么组件将不会更新。"]}),"\n",(0,s.jsx)(e.p,{children:"比如这个组件是子组件，并不是组件本身，然后我们对上面的例子稍加更改，看看这个问题："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'const Index: React.FC<any> = () => {\n  console.log("父组件发生更新");\n  ...\n  return (\n    <>\n        ...\n      <Button\n        type="primary"\n        style={{ marginLeft: 10 }}\n        onClick={() => dispatch({ type: "no", payload: 1 })}\n      >\n        无关按钮\n      </Button>\n      <Child count={count} />\n    </>\n  )\n};\n\nconst Child: React.FC<any> = ({ count }) => {\n  console.log("子组件发生更新");\n  return <div>在子组件的count：{count}</div>;\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsx)(e.p,{children:"可以看到，当 count 无变化时，子组件并不会更新，这点还希望大家铭记。"}),"\n",(0,s.jsxs)(e.h2,{id:"5-usememo",children:["5. useMemo",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5-usememo",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"场景："})," 在每一次的状态更新中，都会让组件重新绘制，而重新绘制必然会带来不必要的性能开销，为了防止没有意义的性能开销，React Hooks 提供了 useMemo 函数。"]}),"\n",(0,s.jsxs)(e.p,{children:["useMemo：理念与 ",(0,s.jsx)(e.code,{children:"memo"})," 相同，都是判断是否满足当前的限定条件来决定是否执行",(0,s.jsx)(e.code,{children:"callback"})," 函数。它之所以能带来提升，是因为在依赖不变的情况下，会返回相同的引用，避免子组件进行无意义的重复渲染。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const cacheData = useMemo(fn, deps)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"fn：函数，函数的返回值会作为缓存值；"}),"\n",(0,s.jsx)(e.li,{children:"deps：依赖项，数组，会通过数组里的值来判断是否进行 fn 的调用，如果发生了改变，则会得到新的缓存值。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Result："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"cacheData：更新之后的数据源，即 fn 函数的返回值，如果 deps 中的依赖值发生改变，将重新执行 fn，否则取上一次的缓存值。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"问题源泉："})}),"\n",(0,s.jsx)(e.p,{children:"可能光听概念，各位小伙伴觉得太过于枯燥，也不是很明白，我们举个小案例来看看："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState } from "react";\nimport { Button } from "antd";\n\nconst usePow = (list: number[]) => {\n  return list.map((item: number) => {\n    console.log("我是usePow");\n    return Math.pow(item, 2);\n  });\n};\n\nconst Index: React.FC<any> = () => {\n  let [flag, setFlag] = useState(true);\n\n  const data = usePow([1, 2, 3]);\n\n  return (\n    <>\n      <div>数字集合：{JSON.stringify(data)}</div>\n      <Button type="primary" onClick={() => setFlag((v) => !v)}>\n        状态切换{JSON.stringify(flag)}\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsxs)(e.p,{children:["从例子中来看， 按钮切换的 flag 应该与 usePow 的数据毫无关系，那么可以猜一猜，当我们切换按钮的时候，usePow 中是否会打印 ",(0,s.jsx)(e.code,{children:"我是usePow"})," ？"]}),"\n",(0,s.jsx)(e.p,{children:"我们直接看看运行后的效果："}),"\n",(0,s.jsxs)(e.p,{children:["可以看到，当我们点击按钮后，会打印",(0,s.jsx)(e.code,{children:"我是usePow"}),"，这样就会产生开销。毫无疑问，这种开销并不是我们想要见到的结果，所以有了 ",(0,s.jsx)(e.code,{children:"useMemo"}),"。 并用它进行如下改造："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const usePow = (list: number[]) => {\n  return useMemo(\n    () =>\n      list.map((item: number) => {\n        console.log(1);\n        return Math.pow(item, 2);\n      }),\n    []\n  );\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"优化后的效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"6-usecallback",children:["6. useCallback",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#6-usecallback",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"useCallback：与 useMemo 极其类似，甚至可以说一模一样，唯一不同的点在于，useMemo 返回的是值，而 useCallback 返回的是函数。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const resfn = useCallback(fn, deps)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"fn：函数，函数的返回值会作为缓存值；"}),"\n",(0,s.jsx)(e.li,{children:"deps：依赖项，数组，会通过数组里的值来判断是否进行 fn 的调用，如果依赖项发生改变，则会得到新的缓存值。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Result："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"resfn：更新之后的数据源，即 fn 函数，如果 deps 中的依赖值发生改变，将重新执行 fn，否则取上一次的函数。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基础用法："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useCallback, memo } from "react";\nimport { Button } from "antd";\n\nconst Index: React.FC<any> = () => {\n  let [count, setCount] = useState(0);\n  let [flag, setFlag] = useState(true);\n\n  const add = useCallback(() => {\n    setCount(count + 1);\n  }, [count]);\n\n  return (\n    <>\n      <TestButton onClick={() => setCount((v) => v + 1)}>普通点击</TestButton>\n      <TestButton onClick={add}>useCallback点击</TestButton>\n      <div>数字：{count}</div>\n      <Button type="primary" onClick={() => setFlag((v) => !v)}>\n        切换{JSON.stringify(flag)}\n      </Button>\n    </>\n  );\n};\n\nconst TestButton = memo(({ children, onClick = () => {} }: any) => {\n  console.log(children);\n  return (\n    <Button\n      type="primary"\n      onClick={onClick}\n      style={children === "useCallback点击" ? { marginLeft: 10 } : undefined}\n    >\n      {children}\n    </Button>\n  );\n});\n\nexport default Index;\n'})}),"\n",(0,s.jsxs)(e.p,{children:["简要说明下，",(0,s.jsx)(e.code,{children:"TestButton"})," 里是个按钮，分别存放着有无 useCallback 包裹的函数，在父组件 Index 中有一个 flag 变量，这个变量同样与 count 无关，那么，我们切换按钮的时候，",(0,s.jsx)(e.code,{children:"TestButton"})," 会怎样执行呢？效果如下："]}),"\n",(0,s.jsx)(e.p,{children:"可以看到，我们切换 flag 的时候，没有经过 useCallback 的函数会再次执行，而包裹的函数并没有执行（点击“普通点击”按钮的时候，useCallbak 的依赖项 count 发生了改变，所以会打印出 useCallback 点击）。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：为什么在 TestButton 中使用了 React.memo，不使用会怎样？"}),"\n",(0,s.jsx)(e.p,{children:"答：useCallback 必须配合 React.memo 进行优化，如果不配合使用，性能不但不会提升，还有可能降低。至于为什么，容我在这里先卖个关子，在后面讲解 useCallback 源码中详细说明，这节我们只要学会使用即可。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"7-useref",children:["7. useRef",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#7-useref",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useRef："})," 用于获取当前元素的所有属性，除此之外，还有一个高级用法：缓存数据（后面介绍",(0,s.jsx)(e.code,{children:"自定义Hooks"}),"的时候会详细介绍）。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const ref = useRef(initialValue);\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"initialValue：初始值，默认值。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Result："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"ref：返回的一个 current 对象，这个 current 属性就是 ref 对象需要获取的内容。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本用法："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useRef } from "react";\n\nconst Index: React.FC<any> = () => {\n  const scrollRef = useRef<any>(null);\n  const [clientHeight, setClientHeight] = useState<number>(0);\n  const [scrollTop, setScrollTop] = useState<number>(0);\n  const [scrollHeight, setScrollHeight] = useState<number>(0);\n\n  const onScroll = () => {\n    if (scrollRef?.current) {\n      let clientHeight = scrollRef?.current.clientHeight; //可视区域高度\n      let scrollTop = scrollRef?.current.scrollTop; //滚动条滚动高度\n      let scrollHeight = scrollRef?.current.scrollHeight; //滚动内容高度\n      setClientHeight(clientHeight);\n      setScrollTop(scrollTop);\n      setScrollHeight(scrollHeight);\n    }\n  };\n\n  return (\n    <>\n      <div>\n        <p>可视区域高度：{clientHeight}</p>\n        <p>滚动条滚动高度：{scrollTop}</p>\n        <p>滚动内容高度：{scrollHeight}</p>\n      </div>\n      <div\n        style={{ height: 200, border: "1px solid #000", overflowY: "auto" }}\n        ref={scrollRef}\n        onScroll={onScroll}\n      >\n        <div style={{ height: 2000 }}></div>\n      </div>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"8-useimperativehandle",children:["8. useImperativeHandle",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#8-useimperativehandle",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"useImperativeHandle：可以通过 ref 或 forwardRef 暴露给父组件的实例值，所谓的实例值是指值和函数。"}),"\n",(0,s.jsx)(e.p,{children:"实际上这个钩子非常有用，简单来讲，这个钩子可以让不同的模块关联起来，让父组件调用子组件的方法。"}),"\n",(0,s.jsxs)(e.p,{children:["举个例子，在一个页面很复杂的时候，我们会将这个页面进行模块化，这样会分成很多个模块，有的时候我们需要在",(0,s.jsx)(e.code,{children:"最外层的组件上"}),"控制其他组件的方法，希望最外层的点击事件同时执行",(0,s.jsx)(e.code,{children:"子组件的事件"}),"，这时就需要 useImperativeHandle 的帮助（在不用",(0,s.jsx)(e.code,{children:"redux"}),"等状态管理的情况下）。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"useImperativeHandle(ref, createHandle, deps)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"ref：接受 useRef 或 forwardRef 传递过来的 ref；"}),"\n",(0,s.jsx)(e.li,{children:"createHandle：处理函数，返回值作为暴露给父组件的 ref 对象；"}),"\n",(0,s.jsx)(e.li,{children:"deps：依赖项，依赖项如果更改，会形成新的 ref 对象。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"父组件是函数式组件："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useRef, useImperativeHandle } from "react";\nimport { Button } from "antd";\n\nconst Child = ({cRef}:any) => {\n\n  const [count, setCount] = useState(0)\n\n  useImperativeHandle(cRef, () => ({\n    add\n  }))\n\n  const add = () => {\n    setCount((v) => v + 1)\n  }\n\n  return <div>\n    <p>点击次数：{count}</p>\n    <Button onClick={() => add()}> 子组件的按钮，点击+1</Button>\n  </div>\n}\n\nconst Index: React.FC<any> = () => {\n  const ref = useRef<any>(null)\n\n  return (\n    <>\n      <div>大家好，我是小杜杜，一起学习hooks吧！</div>\n      <div></div>\n      <Button\n        type="primary"\n        onClick={() =>  ref.current.add()}\n      >\n        父组件上的按钮，点击+1\n      </Button>\n      <Child cRef={ref} />\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"当父组件是类组件时："})}),"\n",(0,s.jsx)(e.p,{children:"如果当前的父组件是 Class 组件，此时不能使用 useRef，而是需要用 forwardRef 来协助我们处理。"}),"\n",(0,s.jsx)(e.p,{children:"forwardRef：引用传递，是一种通过组件向子组件自动传递引用 ref 的技术。对于应用者的大多数组件来说没什么作用，但对于一些重复使用的组件，可能有用。"}),"\n",(0,s.jsx)(e.p,{children:"听完 forwardRef 的概念是不是有点云里雾里的感觉，什么是引用传递呢？是不是感觉很陌生，官方中，也对 forwardRef 的介绍很少，别纠结，先来思考下。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：在上述的例子中，我们通过 cRef 传递 ref，为什么不能直接用 ref 传递 ref 呢（毕竟我们平常传递的参数都会尽可能保持一致）？"}),"\n",(0,s.jsx)(e.p,{children:"简化一下问题：函数式组件中允许 ref 通过 props 传参吗？"}),"\n",(0,s.jsx)(e.p,{children:"答：在函数式组件中不允许 ref 作为参数，除了 ref，key 也不允许作为参数，原因是在 React 内部中，ref 和 key 会形成单独的 key 名。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"回过头来看 forwardRef，所谓引用传递就是为了解决无法传递 ref 的问题。"}),"\n",(0,s.jsx)(e.p,{children:"经过 forwardRef 包裹后，会将 props（其余参数）和 ref 拆分出来，ref 会作为第二个参数进行传递。如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useRef, useImperativeHandle, Component, forwardRef } from "react";\nimport { Button } from "antd";\n\nconst Child = (props:any, ref:any) => {\n\n  const [count, setCount] = useState(0)\n\n  useImperativeHandle(ref, () => ({\n    add\n  }))\n\n  const add = () => {\n    setCount((v) => v + 1)\n  }\n\n  return <div>\n    <p>点击次数：{count}</p>\n    <Button onClick={() => add()}> 子组件的按钮，点击+1</Button>\n  </div>\n}\n\nconst ForwardChild = forwardRef(Child)\n\nclass Index extends Component{\n  countRef:any = null\n  render(){\n    return   <>\n      <div>大家好，我是小杜杜，一起学习hooks吧！</div>\n      <div></div>\n      <Button\n        type="primary"\n        onClick={() => this.countRef.add()}\n      >\n        父组件上的按钮，点击+1\n      </Button>\n      <ForwardChild ref={node => this.countRef = node} />\n    </>\n  }\n}\n\nexport default Index;\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"9-uselayouteffect",children:["9. useLayoutEffect",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#9-uselayouteffect",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useLayoutEffect："})," 与 useEffect 基本一致，不同点在于它是同步执行的。简要说明："]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"执行顺序：useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前的操作，这样可以更加方便地修改 DOM，获取 DOM 信息，这样浏览器只会绘制一次，所以 useLayoutEffect 的执行顺序在 useEffect 之前；"}),"\n",(0,s.jsx)(e.li,{children:"useLayoutEffect 相当于有一层防抖效果；"}),"\n",(0,s.jsx)(e.li,{children:"useLayoutEffect 的 callback 中会阻塞浏览器绘制。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"useLayoutEffect(callback,deps)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"防抖效果："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useState, useEffect, useLayoutEffect } from "react";\n\nconst Index: React.FC<any> = () => {\n  let [count, setCount] = useState(0);\n  let [count1, setCount1] = useState(0);\n\n  useEffect(() => {\n    if(count === 0){\n      setCount(10 + Math.random() * 100)\n    }\n  }, [count])\n\n  useLayoutEffect(() => {\n    if(count1 === 0){\n      setCount1(10 + Math.random() * 100)\n    }\n  }, [count1])\n\n  return (\n    <>\n      <div>大家好，我是小杜杜，一起玩转Hooks吧！</div>\n      <div>useEffect的count:{count}</div>\n      <div>useLayoutEffect的count:{count1}</div>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:"在这个例子中，我们分别设置 count 和 count1 两个变量，初始值都为 0，然后分别通过 useEffect 和 useLayout 控制，通过随机值来变更两个变量的值。也就是说，count 和 count1 连续变更了两次。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsx)(e.p,{children:"从效果上来看，count 要比 count1 更加抖动（效果可能感觉不到，建议自己试试，刷新的快点就能看到效果）。"}),"\n",(0,s.jsx)(e.p,{children:"这是因为两者的执行顺序，简要分析下："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"useEffect 执行顺序：setCount 设置 => 在 DOM 上渲染 => useEffect 回调 => setCount 设置 => 在 DOM 上渲染。"}),"\n",(0,s.jsx)(e.li,{children:"useLayoutEffect 执行顺序：setCount 设置 => useLayoutEffect 回调 => setCount 设置 => 在 DOM 上渲染。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"可以看出，useEffect 实际进行了两次渲染，这样就可能导致浏览器再次回流和重绘，增加了性能上的损耗，从而会有闪烁突兀的感觉。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：既然 useEffect 会执行两次渲染，导致回流和重绘，相比之下， useLayoutEffect 的效果要更好，那么为什么都用 useEffect 而不用 useLayoutEffect 呢？"}),"\n",(0,s.jsx)(e.p,{children:"答：根本原因还是同步和异步，虽然 useLayoutEffect 只会渲染一次，但切记，它是同步，类比于 Class 组件中，它更像 componentDidMount，因为它们都是同步执行。既然是同步，就有可能阻塞浏览器的渲染，而 useEffect 是异步的，并不会阻塞渲染。"}),"\n",(0,s.jsx)(e.p,{children:"其次，给用户的感觉不同，对比两者的执行顺序，useLayoutEffect 要经过本身的回调才设置到 DOM 上，也就是说， useEffect 呈现的速度要快于 useLayoutEffect，让用户有更快的感知。"}),"\n",(0,s.jsx)(e.p,{children:"最后，即使 useEffect 要渲染两次，但从效果上来看，变换的时间非常短，这样情况下，也无所谓，除非闪烁、突兀的感觉非常明显，才会去考虑使用 useLayoutEffect 去解决。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"10-usedebugvalue",children:["10. useDebugValue",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10-usedebugvalue",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"useDebugValue："})," 可用于在 React 开发者工具中显示自定义 Hook 的标签。这个 Hooks 目的就是检查自定义 Hooks。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"注意："})," 这个标签并不推荐向每个 hook 都添加 debug 值。当它作为共享库的一部分时才最有价值。（也就是自定义 Hooks 被复用的值）。因为在一些情况下，格式化值可能是一项开销很大的操作，除非你需要检查 Hook，否则没有必要这么做。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本使用："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"useDebugValue(value, (status) => {})\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Params："})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"value：判断的值；"}),"\n",(0,s.jsx)(e.li,{children:"callback：可选，这个函数只有在 Hook 被检查时才会调用，它接受 debug 值作为参数，并且会返回一个格式化的显示值。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"基本用法："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"function useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  // ...\n\n  // 在开发者工具中的这个 Hook 旁边显示标签  \n  // e.g. \"FriendStatus: Online\"  useDebugValue(isOnline ? 'Online' : 'Offline');\n  return isOnline;\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["本节主要讲 ",(0,s.jsx)(e.code,{children:"React v16"})," 中的 Hooks，共有 useState、useEffect 等 10 个 Hooks API。"]}),"\n",(0,s.jsx)(e.p,{children:"相信大家已经完全清楚这些钩子的用法，至于源码方面，我们留到后面去介绍，还是先以使用为目的，之后再一步一步进行探索。"}),"\n",(0,s.jsxs)(e.p,{children:["下节讲解 ",(0,s.jsx)(e.code,{children:"React v18"})," 中的 Hooks，带你全面了解 React v18 的官方 Hooks API 的使用方式。"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F2.%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C10%20%E7%A7%8D%20React%20Hooks%20API%20%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88v16%20%E7%AF%87%EF%BC%89.md"]={toc:[{text:"1. useState",id:"1-usestate",depth:2},{text:"2.  useEffect",id:"2--useeffect",depth:2},{text:"3. useContext",id:"3-usecontext",depth:2},{text:"4.  useReducer",id:"4--usereducer",depth:2},{text:"5. useMemo",id:"5-usememo",depth:2},{text:"6. useCallback",id:"6-usecallback",depth:2},{text:"7. useRef",id:"7-useref",depth:2},{text:"8. useImperativeHandle",id:"8-useimperativehandle",depth:2},{text:"9. useLayoutEffect",id:"9-uselayouteffect",depth:2},{text:"10. useDebugValue",id:"10-usedebugvalue",depth:2},{text:"小结",id:"小结",depth:2}],title:"2.基础篇｜10 种 React Hooks API 的介绍和使用（v16 篇）",headingTitle:"2.基础篇｜10 种 React Hooks API 的介绍和使用（v16 篇）",frontmatter:{}}}}]);