"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["22468"],{900588:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var s=r(552676),a=r(740453);let c=r.p+"static/image/97caf4c2608e117588efd17b829e1f37.74627d34.webp",l=r.p+"static/image/84f658dd6c586ed913d289170acec612.123718d5.webp",t=r.p+"static/image/ab7993a0de9ea40f6bb0a4b07806eb23.d7a1ac46.webp",i=r.p+"static/image/4bf125f8717d9f2e9a7f863b2b4c400b.8c3a0b6d.webp",d=r.p+"static/image/69745429360cea8fa47a91eb7e623f03.a70823b2.webp";function p(e){let n=Object.assign({p:"p",a:"a",pre:"pre",code:"code",ul:"ul",li:"li",h2:"h2",ol:"ol",img:"img",blockquote:"blockquote",strong:"strong"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["传统 Web 开发强调样式、结构、逻辑分离，以此降低技术复杂度。但 React 认为渲染逻辑本质上与其它 UI 逻辑存在内在耦合关系，所以提倡将结构、逻辑与样式共同存放在同一文件中，以“组件”这种松散耦合结构实现关注点分离，并为此设计实现了一套 ",(0,s.jsx)(n.a,{href:"https://zh-hans.reactjs.org/docs/introducing-jsx.html",target:"_blank",rel:"noopener noreferrer",children:"JavaScript-XML"}),"(JSX) 技术，以支持在 JavaScript 中编写 Template 代码，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"import React from 'react';\n\nconst Component = () => {\n  return <div className=\"hello\">hello world</div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"为支持这一特性，我们需要搭建一套使用的工程化环境，将 JSX 及 React 组件转换为能够在浏览器上运行的 JavaScript 代码。本文将递进介绍使用 Webpack 搭建 React 应用开发环境的主要方法，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["如何使用 ",(0,s.jsx)(n.code,{children:"Babel"})," 处理JSX文件？"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["如何使用 ",(0,s.jsx)(n.code,{children:"html-webpack-plugin"}),"、",(0,s.jsx)(n.code,{children:"webpack-dev-server"})," 运行 React 应用？"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"如何在 React 中复用 TypeScript、Less 等编译工具？"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"如何搭建 React SSR 环境？"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"如何使用 Create React App？"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-babel-加载-jsx-文件",children:["使用 Babel 加载 JSX 文件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-babel-加载-jsx-文件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"绝大多数情况下，我们都会使用 JSX 方式编写 React 组件，但问题在于浏览器并不支持这种代码，为此我们首先需要借助构建工具将 JSX 等价转化为标准 JavaScript 代码。"}),"\n",(0,s.jsxs)(n.p,{children:["在 Webpack 中可以借助 ",(0,s.jsx)(n.code,{children:"babel-loader"}),"，并使用 React 预设规则集 ",(0,s.jsx)(n.code,{children:"@babel/preset-react"})," ，完成 JSX 到 JavaScript 的转换，具体步骤："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装依赖："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Bash",children:"yarn add -D webpack webpack-cli babel-loader @babel/core @babel/preset-react\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["修改 Webpack 配置，加入 ",(0,s.jsx)(n.code,{children:"babel-loader"})," 相关声明："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'module.exports = {\n  mode: \'none\',\n  module: {\n    rules: [\n      {\n        test: /\\.jsx$/,\n        loader: "babel-loader",\n        options: {\n          presets: ["@babel/preset-react"],\n        }\n      },\n    ],\n  },\n};\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["执行构建命令，如 ",(0,s.jsx)(n.code,{children:"npx webpack"})," 。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["经过 ",(0,s.jsx)(n.code,{children:"babel-loader"})," 处理后，JSX 将被编译为 JavaScript 格式的 ",(0,s.jsx)(n.code,{children:"React.createElement"})," 函数调用，如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["此外，JSX 支持新旧两种转换模式，一是上图这种 ",(0,s.jsx)(n.code,{children:"React.createElement"})," 函数，这种模式要求我们在代码中引入 React，如上图的 ",(0,s.jsx)(n.code,{children:'import React from "react"'}),"；二是自动帮我们注入运行时代码，此时需要设置 ",(0,s.jsx)(n.code,{children:"runtime:automatic"}),"，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'{\n  test: /\\.jsx$/,\n  loader: \'babel-loader\',\n  options: {\n    "presets": [\n      ["@babel/preset-react", {\n        "runtime": "automatic"\n      }]\n    ]\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["这种模式会自动导入 ",(0,s.jsx)(n.code,{children:"react/jsx-runtime"}),"，不必开发者手动管理 React 依赖。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"加载 CSS 文件"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"注意，上例 Webpack 配置还无法处理 CSS 代码："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["为此需要添加 CSS 加载器，如 ",(0,s.jsx)(n.code,{children:"css-loader/style-loader"}),"，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'module.exports = {\n  mode: \'none\',\n  module: {\n    rules: [\n      {\n        test: /\\.jsx$/,\n        loader: \'babel-loader\',\n        options: {\n          \'presets\': [["@babel/preset-react", {\n            "runtime": "automatic"\n          }]]\n        }\n      },\n      {\n        test: /\\.css$/,\n        use: ["style-loader", "css-loader"],\n      }\n    ],\n  },\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"相关用法已在其它章节有详细介绍，此处不再赘述。"}),"\n",(0,s.jsxs)(n.h2,{id:"运行页面",children:["运行页面",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#运行页面",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上例接入的 ",(0,s.jsx)(n.code,{children:"babel-loader"})," 使得 Webpack 能够正确理解、翻译 JSX 文件的内容，接下来我们还需要用 ",(0,s.jsx)(n.code,{children:"html-webpack-plugin"})," 和 ",(0,s.jsx)(n.code,{children:"webpack-dev-server"})," 让页面真正运行起来，配置如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'const HtmlWebpackPlugin = require(\'html-webpack-plugin\')\n\nmodule.exports = {\n  module: {/*...*/},\n  devServer: {\n    hot: true,\n    open: true\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      templateContent: `\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="utf-8">\n    <title>Webpack App</title>\n  </head>\n  <body>\n    <div id="app" />\n  </body>\n</html>\n    `\n    })\n  ]\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["之后，运行 ",(0,s.jsx)(n.code,{children:"npx webpack serve"})," 命令，即可自动打开带热更功能的页面："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"c100d66f-156d-4600-96c2-2838e70ac59b.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"复用其它编译工具",children:["复用其它编译工具",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#复用其它编译工具",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"与 Vue 类似，在 React 开发环境中我们也可以搭配其它工程化工具提升开发效率、质量，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"babel-loader"}),"、",(0,s.jsx)(n.code,{children:"ts-loader"})," 加载 TSX 代码；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"less-loader"}),"、",(0,s.jsx)(n.code,{children:"sass-loader"})," 预处理样式代码。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"使用 TSX"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["社区有两种主流的 TSX 加载方案，一是使用 Babel 的 ",(0,s.jsx)(n.code,{children:"@babel/preset-typescript"})," 规则集；二是直接使用 ",(0,s.jsx)(n.code,{children:"ts-loader"}),"。先从 Babel 规则集方案说起："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装依赖，核心有："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"yarn add -D typescript @babel/preset-typescript\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"修改 Webpack 配置，添加用于处理 TypeScript 代码的规则："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.tsx$/,\n        loader: 'babel-loader',\n        options: {\n          'presets': [[\"@babel/preset-react\", {\n            \"runtime\": \"automatic\"\n          }],\n          '@babel/preset-typescript']\n        }\n      },\n    ],\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["之后，将组件文件后缀修改 ",(0,s.jsx)(n.code,{children:".tsx"}),"，Babel 就会帮我们完成 TypeScript 代码编译。",(0,s.jsx)(n.code,{children:"ts-loader"})," 用法也很相似："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装依赖："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Bash",children:"yarn add -D typescript ts-loader\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["修改 Webpack 配置，添加 ",(0,s.jsx)(n.code,{children:"ts-loader"})," 规则："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = {\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.tsx$/,\n        use: 'ts-loader',\n      },\n    ],\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["修改 ",(0,s.jsx)(n.code,{children:"tsconfig.json"})," 文件，添加 ",(0,s.jsx)(n.code,{children:"jsx"})," 配置属性："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'{\n  "compilerOptions": {\n    //...\n    "jsx": "react-jsx"\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["完毕。两种方式功能效果相似，相对而言我个人更倾向于 ",(0,s.jsx)(n.code,{children:"babel-loader"}),"，因为 Babel 是一种通用的代码编译工具，配置适当 Preset 后能做的事情更多，相关经验更容易复用到其它场景。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"使用 CSS 预处理器"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"类似的，我们还可以使用 Less/Sass/Stylus 等语言开发 CSS 代码，接入过程与上述 TypeScript 相似，以 Less 为例，首先安装依赖："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Bash",children:"yarn add -D less less-loader css-loader style-loader\n"})}),"\n",(0,s.jsx)(n.p,{children:"其次，修改 Webpack 配置，添加 Less 文件相关处理规则："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = {\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.tsx$/,\n        use: 'ts-loader',\n      },\n      {\n        test: /\\.less$/,\n        use: [\"style-loader\", \"css-loader\", \"less-loader\"],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["之后，引入相关样式文件",(0,s.jsx)(n.code,{children:".less"}),"，然后，Webpack 就会使用 ",(0,s.jsx)(n.code,{children:"less-loader"})," 加载这一模块内容。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"提示：其它 CSS 相关工具，如 Sass、Stylus、PostCSS 均遵循同样规则。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"实现-server-side-render",children:["实现 Server Side Render",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-server-side-render",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在上一章节介绍如何搭建 Vue 开发环境时，已经就 SSR 的基本概念与各项优缺点做了详细阐述，这里我们就直接进入主题吧。React 有许多实现 SSR 的方案，例如：",(0,s.jsx)(n.a,{href:"https://github.com/vercel/next.js",target:"_blank",rel:"noopener noreferrer",children:"Next.js"}),"、",(0,s.jsx)(n.a,{href:"https://github.com/zhangyuang/egg-react-ssr",target:"_blank",rel:"noopener noreferrer",children:"egg-react-ssr"}),"、",(0,s.jsx)(n.a,{href:"https://github.com/zhangyuang/ssr",target:"_blank",rel:"noopener noreferrer",children:"ssr（基于egg-react-ssr）"})," 等，接下来我们尝试使用 Webpack、React、Express 搭建一套 React SSR 应用环境，一步步剖析关键技术点。示例代码目录结构(示例代码已上传到小册",(0,s.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/blob/main/react-ssr/package.json",target:"_blank",rel:"noopener noreferrer",children:"仓库"}),")："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Bash",children:"├─ react-ssr-example\n│  ├─ package.json\n│  ├─ server.js\n│  ├─ src\n│  │  ├─ App.css\n│  │  ├─ App.jsx\n│  │  ├─ entry-client.jsx\n│  │  ├─ entry-server.jsx\n│  ├─ webpack.base.js\n│  ├─ webpack.client.js\n│  └─ webpack.server.js\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["首先，需要为客户端环境准备项目入口文件 —— ",(0,s.jsx)(n.code,{children:"entry-client.js"}),"，内容："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"import { createRoot } from 'react-dom/client';\nimport App from './App';\n\nconst container = document.getElementById('app');\nconst root = createRoot(container);\nroot.render(<App />);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["为服务端环境准备入口文件 —— ",(0,s.jsx)(n.code,{children:"server-client.js"}),"，内容："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'import React from \'react\'\nimport express from \'express\';\nimport App from \'./App\'\nimport { renderToString } from \'react-dom/server\';\n\n// 通过 manifest 文件，找到正确的产物路径\nconst clientManifest = require("../dist/manifest-client.json");\n\nconst server = express();\n\nserver.get("/", (req, res) => {\n\n  const html = renderToString(<App/>);\n\n  const clientCss = clientManifest["client.css"];\n  const clientBundle = clientManifest["client.js"];\n\n  res.send(`\n<!DOCTYPE html>\n<html>\n    <head>\n      <title>React SSR Example</title>\n      <link rel="stylesheet" href="${clientCss}"></link>\n    </head>\n    <body>\n      \x3c!-- 注入组件运行结果 --\x3e\n      <div id="app">${html}</div>\n      \x3c!-- 注入客户端代码产物路径 --\x3e\n      \x3c!-- 实现 Hydrate 效果 --\x3e\n      <script src="${clientBundle}"><\/script>\n    </body>\n</html>\n    `);\n});\n\nserver.use(express.static("./dist"));\n\nserver.listen(3000, () => {\n  console.log("ready");\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"上例代码核心逻辑："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["引入客户端 React 根组件，调用 ",(0,s.jsx)(n.code,{children:"renderToString"})," 将其渲染为 HTML 字符串；"]}),"\n",(0,s.jsxs)(n.li,{children:["获取客户端打包产物映射文件 ",(0,s.jsx)(n.code,{children:"manifest"})," 文件，然后将组件 HTML 字符串与 ",(0,s.jsx)(n.code,{children:"entry-client.js"})," 产物路径注入到 HTML 中，并返回给客户端。"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["分别为客户端、服务端版本编写 Webpack 配置文件，即上述目录中的三个 ",(0,s.jsx)(n.code,{children:"webpack.*.js"})," 文件。其中："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"base"})," 用于设定基本规则；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"webpack.client.js"})," 用于定义构建客户端资源的配置："]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'const Merge = require("webpack-merge");\nconst path = require("path");\nconst HtmlWebpackPlugin = require("html-webpack-plugin");\nconst MiniCssExtractPlugin = require("mini-css-extract-plugin");\nconst { WebpackManifestPlugin } = require("webpack-manifest-plugin");\nconst base = require("./webpack.base");\n\n// 继承自 `webpack.base.js`\nmodule.exports = Merge.merge(base, {\n  entry: {\n    // 入口指向 `entry-client.js` 文件\n    client: path.join(__dirname, "./src/entry-client.jsx"),\n  },\n  output: {\n    filename: \'index.js\',\n    publicPath: "/",\n  },\n  module: {\n    rules: [{ test: /\\.css$/, use: [MiniCssExtractPlugin.loader, "css-loader"] }],\n  },\n  plugins: [\n    // 这里使用 webpack-manifest-plugin 记录产物分布情况\n    // 方面后续在 `server.js` 中使用\n    new WebpackManifestPlugin({ fileName: "manifest-client.json" }),\n    // 生成CSS文件\n    new MiniCssExtractPlugin({\n      filename: \'index.[contenthash].css\'\n    }),\n    // 自动生成 HTML 文件内容\n    new HtmlWebpackPlugin({\n      templateContent: `\n    <!DOCTYPE html>\n    <html>\n    <head>\n  <meta charset="utf-8">\n  <title>Webpack App</title>\n    </head>\n    <body>\n  <div id="app" />\n    </body>\n    </html>\n  `,\n    }),\n  ],\n});\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注意："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["这里我们需要使用 ",(0,s.jsx)(n.code,{children:"webpack-manifest-plugin"})," 插件记录产物构建路径，之后才能在 ",(0,s.jsx)(n.code,{children:"server.js"})," 中动态注入 HTML 代码中；"]}),"\n",(0,s.jsxs)(n.li,{children:["示例代码还用到 ",(0,s.jsx)(n.code,{children:"mini-css-extract-plugin"})," ，将 CSS 从 JS 文件中抽离出来，成为一个单独的文件。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsxs)(n.li,{children:["在 ",(0,s.jsx)(n.code,{children:"webpack.server.js"})," 定义构建服务端资源的配置："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'const Merge = require("webpack-merge");\nconst path = require("path");\nconst { WebpackManifestPlugin } = require("webpack-manifest-plugin");\nconst base = require("./webpack.base");\n\nmodule.exports = Merge.merge(base, {\n  entry: {\n    server: path.join(__dirname, "./src/entry-server.jsx"),\n  },\n  target: "node",\n  output: {\n    // 打包后的结果会在 node 环境使用\n    // 因此此处将模块化语句转译为 commonjs 形式\n    libraryTarget: "commonjs2",\n    filename: \'server.js\'\n  },\n  module: {\n    rules: [{\n      test: /.css$/,\n      loader: \'./loader/removeCssLoader\'\n    }]\n  },\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"大部分配置与普通 Node 应用相似，唯一需要注意的是：在 SSR 中，通常由客户端代码提前做好 CSS 资源编译，对服务端而言只需要支持输出构建后的 CSS 文件路径即可，不需要关注 CSS 具体内容，因此通常会用一个简单的自定义 Loader 跳过 CSS 资源，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = () => {\n  return 'module.exports = null';\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们只需要调用适当命令即可分别生成客户端、服务端版本代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Bash",children:"# 6.如何搭建 React 全栈开发环境？\nnpx webpack --config ./webpack.client.js\n# 服务端版本：\nnpx webpack --config ./webpack.server.js \n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"至此，SSR 的工程化框架搭建完毕，接下来可以开始编写任何 React 代码，例如："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:"import React, { useState } from 'react';\nimport './App.css';\n\nconst App = () => {\n  const [isActivity, setIsActivity] = useState(false);\n\n  const handleClick = () => {\n    setIsActivity(!isActivity);\n  };\n\n  return (\n    <div>\n      <h3 className={`main ${isActivity ? 'activate' : 'deactivate'}`}>Hello World</h3>\n      <button onClick={handleClick}>Toggle</button>\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["之后，编译并执行 ",(0,s.jsx)(n.code,{children:"node ./dist/server.js"})," 启动 Node 应用，访问页面时服务端将首先返回如下 HTML 内容："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["页面也能正常运行 ",(0,s.jsx)(n.code,{children:"App.jsx"})," 交互效果："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:"840a136d-fe81-42fc-93e0-3d7063c43949.gif"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"提示："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"实际项目中建议使用更成熟、完备的技术方案，如 Next.js；"}),"\n",(0,s.jsxs)(n.li,{children:["建议大家拉取",(0,s.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/blob/main/react-ssr/package.json",target:"_blank",rel:"noopener noreferrer",children:"示例代码"}),"，阅读学习。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["总的来说，React 的 SSR 实现逻辑与 Vue 极为相似，都需要搭建对应的 Client、Server 端构建环境，之后在 Server 端引入组件代码并将其渲染为 HTML 字符串，配合 ",(0,s.jsx)(n.code,{children:"manifest"})," 记录的产物信息组装出完整的 Web 页面代码，从而实现服务端渲染能力。"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-create-react-app",children:["使用 Create React App",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-create-react-app",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"综上，手动配置 React 开发环境的过程复杂且繁琐的，如果每次构建项目都需要从零开始使用 Webpack、Babel、TypeScript、Less、Mocha 等工具搭建项目环境，那对新手、老手来说都是极高的门槛和心智负担。"}),"\n",(0,s.jsx)(n.p,{children:"好在社区已经将大量重复、被验证有效的模式封装成开箱即用的脚手架工具，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://create-react-app.dev/",target:"_blank",rel:"noopener noreferrer",children:"Create React App"}),"：是官方支持的创建 React 应用程序的方式，提供免配置的现代构建开发环境；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://modernjs.dev/",target:"_blank",rel:"noopener noreferrer",children:"Modern JS"}),"：字节跳动开源的现代 Web 工程体系。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这些工具能够快速生成一套健壮的 React 开发环境，以 ",(0,s.jsx)(n.a,{href:"https://create-react-app.dev/",target:"_blank",rel:"noopener noreferrer",children:"Create React App"})," 为例，只需执行一条简单命令："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Bash",children:"npx create-react-app my-app\n"})}),"\n",(0,s.jsxs)(n.p,{children:["之后，",(0,s.jsx)(n.a,{href:"https://create-react-app.dev/",target:"_blank",rel:"noopener noreferrer",children:"Create React App"})," 会自动安装项目依赖，项目环境就算是搭建完毕了。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://create-react-app.dev/",target:"_blank",rel:"noopener noreferrer",children:"Create React App"})," 提供的默认配置已经能够满足许多场景下的开发需求，必要时开发者还可以通过",(0,s.jsx)(n.a,{href:"https://github.com/arackaf/customize-cra",target:"_blank",rel:"noopener noreferrer",children:"customize-cra"})," 和 ",(0,s.jsx)(n.a,{href:"https://github.com/timarney/react-app-rewired",target:"_blank",rel:"noopener noreferrer",children:"react-app-rewired"})," 修改工程化配置，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JavaScript",children:'const { override, addLessLoader } = require("customize-cra");\n\nmodule.exports = override(\n  addLessLoader({\n    strictMath: true,\n    noIeCompat: true,\n    cssLoaderOptions: {}, \n    cssModules: {\n      localIdentName: "[path][name]__[local]--[hash:base64:5]", \n    },\n  }) \n));\n'})}),"\n",(0,s.jsx)(n.p,{children:"然后修改 Script 运行脚本："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-JSON",children:'"scripts": {\n-   "start": "react-scripts start",\n+   "start": "react-app-rewired start",\n-   "build": "react-scripts build",\n+   "build": "react-app-rewired build",\n-   "test": "react-scripts test",\n+   "test": "react-app-rewired test",\n    "eject": "react-scripts eject"\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：更多信息可参考 Create React App 官网 ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://cli.vuejs.org/guide/webpack.html#simple-configuration",target:"_blank",rel:"noopener noreferrer",children:"Working with Webpack"})})," 一节。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本文介绍如何使用 Webpack 开发 React 应用，从最基础的 JSX 代码编译；到如何使用 TypeScript、Less 等基础编译工具；再到如何搭建 React SSR 应用；最后介绍如何使用 ",(0,s.jsx)(n.a,{href:"https://create-react-app.dev/",target:"_blank",rel:"noopener noreferrer",children:"Create React App"})," 迅速搭建开发环境。"]}),"\n",(0,s.jsxs)(n.p,{children:["就我个人而言，多数情况下我都会选择使用 Create React App 或其它脚手架工具快速搭建开发框架，但多数时候又必须 ",(0,s.jsx)(n.a,{href:"https://create-react-app.dev/docs/available-scripts/#npm-run-eject",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"eject"})})," 出具体配置信息之后手动修改，实现一些定制化需求，此时就需要用上上面介绍的这些知识点。"]}),"\n",(0,s.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["React JSX 经过 Webpack 转换后的结果与 Vue SFC 转换结果极为相似，为何 Vue 不能复用 Babel 而选择开发一个独立的 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 插件？"]})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}let h=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F6.%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%20React%20%E5%85%A8%E6%A0%88%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%9F.md"]={toc:[{text:"使用 Babel 加载 JSX 文件",id:"使用-babel-加载-jsx-文件",depth:2},{text:"运行页面",id:"运行页面",depth:2},{text:"复用其它编译工具",id:"复用其它编译工具",depth:2},{text:"实现 Server Side Render",id:"实现-server-side-render",depth:2},{text:"使用 Create React App",id:"使用-create-react-app",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);