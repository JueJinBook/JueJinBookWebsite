"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["52174"],{305092:function(n,e,t){t.r(e),t.d(e,{default:()=>p});var i=t(552676),s=t(740453);let l=t.p+"static/image/2e0e7314f76f161d149e67c8d3f4a142.2d629025.png",a=t.p+"static/image/bdf65ec8716469c96ba09a46a9017ad0.e2d682ee.png";function r(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li",blockquote:"blockquote",img:"img"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"17实战案例_-自动国际化",children:["17.实战案例_ 自动国际化",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17实战案例_-自动国际化",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"互联网产品开发完以后可能会为不同地区的人提供服务，不同地区的语言不同，这就对软件提出了支持国际化的需求。"}),"\n",(0,i.jsx)(e.p,{children:"国际化要把软件中的文字、货币符号、数字等转成当地所支持的格式，对前端代码来说，需要把所有界面上的字符串字面量转成根据 locale 动态获取的。如果代码中有很多需要改动的代码，那工作量还是很大的。"}),"\n",(0,i.jsx)(e.p,{children:"我们知道 babel 可以用于分析代码和转换代码，那么基于 babel 自然可以做到自动的国际化。"}),"\n",(0,i.jsxs)(e.h2,{id:"思路分析",children:["思路分析",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"要转换的是字符串，主要是 StringLiteral 和 TemplateLiteral 节点，把它们替换成从资源包取值的形式。"}),"\n",(0,i.jsx)(e.p,{children:"比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const a = '中文';\n"})}),"\n",(0,i.jsx)(e.p,{children:"替换为："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"import intl from 'intl';\n\nconst a = intl.t('intl1');\n"})}),"\n",(0,i.jsx)(e.p,{children:"而模版字符串也要做替换"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const name = 'babel';\nconst str = `你好 ${name}`;\n"})}),"\n",(0,i.jsx)(e.p,{children:"替换为："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const name = 'babel';\nconst str = intl.t('intl2', name);\n"})}),"\n",(0,i.jsx)(e.p,{children:"intl.t 是根据 key 从 bundle 中取值的，语言包 bundle 里存储了各种语言环境下 key 对应的文案："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// zh_CN.js\nmodule.exports = {\n    intl1: '中文',\n    intl2: 'hello {placeholder}'\n}\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// en_US.js\nmodule.exports = {\n    intl1: 'English',\n    intl2: 'hello {placeholder}'\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"intl.t 是从资源 bundle 中取值，并且用传入的参数替换其中的占位符。"}),"\n",(0,i.jsx)(e.p,{children:"也就是把 {0} {1} {2} 替换为传入的参数。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const locale = 'zh-CN';\nintl.t = function(key, ...args) {\n   let index = 0;\n   return bundle[locale][key].replace(/\\{placeholder\\}/, () => args[index++]);\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"要实现这种转换，需要做三件事情："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"如果没有引入 intl 模块，就自动引入，并且生成唯一的标识符，不和作用域的其他声明冲突"}),"\n",(0,i.jsx)(e.li,{children:"把字符串和模版字符串替换为 intl.t 的函数调用的形式"}),"\n",(0,i.jsx)(e.li,{children:"把收集到的值收集起来，输出到一个资源文件中"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"有一点需要注意的是在 jsx 中，必须带 {}"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'const a = <component content="content"></component>;\n'})}),"\n",(0,i.jsx)(e.p,{children:"要替换为 {} 包裹的表达式"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"import intl from 'intl';\n\nconst a  = <component content={ intl.t('intl2') }></component>;\n"})}),"\n",(0,i.jsx)(e.p,{children:"{} 节点叫做 JSXExpressionContainer，顾名思义，就是 jsx 中的表达式容器，用于实现插值语法。"}),"\n",(0,i.jsx)(e.p,{children:"再就是对于模版字符串中的表达式 ${} 要单独处理下。"}),"\n",(0,i.jsx)(e.p,{children:"有的时候，确实不需要转换，我们可以支持通过注释来配置："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const a = /*i18n-disable*/'content';\n"})}),"\n",(0,i.jsx)(e.p,{children:"带有 /*i18n-disable*/ 注释的字符串就忽略掉。"}),"\n",(0,i.jsxs)(e.h2,{id:"代码实现",children:["代码实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"首先，我们搭好插件的基本结构："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"const { declare } = require('@babel/helper-plugin-utils');\n\nconst autoTrackPlugin = declare((api, options, dirname) => {\n    api.assertVersion(7);\n\n    return {\n        pre(file) {\n        },\n        visitor: {\n        },\n        post(file) {\n        }\n    }\n});\nmodule.exports = autoTrackPlugin;\n"})}),"\n",(0,i.jsx)(e.p,{children:"然后，我们实现 intl 的 import，这个可以在 Program 的 enter 阶段判断： 如果没引入 intl 模块，则引入，并且生成唯一 id 记录到 state 中："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"visitor: {\n    Program: {\n        enter(path, state) {\n            let imported;\n            path.traverse({\n                ImportDeclaration(p) {\n                    const source = p.node.source.value;\n                    if(source === 'intl') {\n                        imported = true;\n                    }\n                }\n            });\n            if (!imported) {\n                const uid = path.scope.generateUid('intl');\n                const importAst = api.template.ast(`import ${uid} from 'intl'`);\n                path.node.body.unshift(importAst);\n                state.intlUid = uid;\n            }\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"然后，还要对所有的有 /*i18n-disable*/ 注释的字符串和模版字符串节点打个标记，用于之后跳过处理。然后把这个注释节点从 ast 中去掉。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"visitor: {\n    Program: {\n        enter(path, state) {\n            path.traverse({\n                'StringLiteral|TemplateLiteral'(path) {\n                    if(path.node.leadingComments) {\n                        path.node.leadingComments = path.node.leadingComments.filter((comment, index) => {\n                            if (comment.value.includes('i18n-disable')) {\n                                path.node.skipTransform = true;\n                                return false;\n                            }\n                            return true;\n                        })\n                    }\n                    if(path.findParent(p => p.isImportDeclaration())) {\n                        path.node.skipTransform = true;\n                    }\n                }\n            });\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"之后处理 StringLiteral 和 TemplateLiteral 节点，用 state.intlUid + '.t' 的函数调用语句来替换原节点。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"注意：替换完以后要用 path.skip 跳过新生成节点的处理，不然就会进入无限循环"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"比较麻烦的是模版字符串需要吧 ${} 表达式的部分替换为 {placeholder} 的占位字符串。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"\nStringLiteral(path, state) {\n    if (path.node.skipTransform) {\n        return;\n    }\n    let key = nextIntlKey();\n    save(state.file, key, path.node.value);\n\n    const replaceExpression = getReplaceExpression(path, key, state.intlUid);\n    path.replaceWith(replaceExpression);\n    path.skip();\n},\nTemplateLiteral(path, state) {\n   if (path.node.skipTransform) {\n        return;\n   }\n    const value = path.get('quasis').map(item => item.node.value.raw).join('{placeholder}');\n    if(value) {\n        let key = nextIntlKey();\n        save(state.file, key, value);\n\n        const replaceExpression = getReplaceExpression(path, key, state.intlUid);\n        path.replaceWith(replaceExpression);\n        path.skip();\n    }\n},\n\n"})}),"\n",(0,i.jsx)(e.p,{children:"上面用到的 getReplaceExpression 是生成替换节点的一个方法："}),"\n",(0,i.jsx)(e.p,{children:"要判断是否在 JSXAttribute 下，如果是，则必须要包裹在 JSXExpressionContainer 节点中（也就是{}）"}),"\n",(0,i.jsx)(e.p,{children:"如果是模版字符串字面量(TemplateLiteral)，还要把 expressions 作为参数传入。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function getReplaceExpression(path, value, intlUid) {\n    const expressionParams = path.isTemplateLiteral() ? path.node.expressions.map(item => generate(item).code) : null\n    let replaceExpression = api.template.ast(`${intlUid}.t('${value}'${expressionParams ? ',' + expressionParams.join(',') : ''})`).expression;\n    if (path.findParent(p => p.isJSXAttribute()) && !path.findParent(p=> p.isJSXExpressionContainer())) {\n        replaceExpression = api.types.JSXExpressionContainer(replaceExpression);\n    }\n    return replaceExpression;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"intal 的 key 也需要生成唯一的。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"let intlIndex = 0;\nfunction nextIntlKey() {\n    ++intlIndex;\n    return `intl${intlIndex}`;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"save 方法则是收集替换的 key 和 value，保存到 file 中"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"function save(file, key, value) {\n    const allText = file.get('allText');\n    allText.push({\n        key, value\n    });\n    file.set('allText', allText);\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"这个是在 pre 初始化的，并且在 post 阶段取出来用于生成 resource 文件，生成位置也是通过插件的 outputDir 参数传入的。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"pre(file) {\n    file.set('allText', []);\n},\npost(file) {\n    const allText = file.get('allText');\n    const intlData = allText.reduce((obj, item) => {\n        obj[item.key] = item.value;\n        return obj;\n    }, {});\n\n    const content = `const resource = ${JSON.stringify(intlData, null, 4)};\\nexport default resource;`;\n    fse.ensureDirSync(options.outputDir);\n    fse.writeFileSync(path.join(options.outputDir, 'zh_CN.js'), content);\n    fse.writeFileSync(path.join(options.outputDir, 'en_US.js'), content);\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"我们来测试一下效果："}),"\n",(0,i.jsx)(e.p,{children:"当输入为："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"import intl from 'intl2';\n/**\n * App\n */\nfunction App() {\n    const title = 'title';\n    const desc = `desc`;\n    const desc2 = /*i18n-disable*/`desc`;\n    const desc3 = `aaa ${ title + desc} bbb ${ desc2 } ccc`;\n\n    return (\n      <div className=\"app\" title={\"测试\"}>\n        <img src={Logo} />\n        <h1>${title}</h1>\n        <p>${desc}</p>  \n        <div>\n        {\n            /*i18n-disable*/'中文'\n        }\n        </div>\n      </div>\n    );\n  }\n"})}),"\n",(0,i.jsx)(e.p,{children:"输出为："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"import _intl from 'intl';\nimport intl from 'intl2';\n/**\n * App\n */\n\nfunction App() {\n  const title = _intl.t('intl1');\n\n  const desc = _intl.t('intl2');\n\n  const desc2 = `desc`;\n\n  const desc3 = _intl.t('intl3', title + desc, desc2);\n\n  return <div className={_intl.t('intl4')} title={_intl.t('intl5')}>\n        <img src={Logo} />\n        <h1>${title}</h1>\n        <p>${desc}</p>  \n        <div>\n        {'中文'}\n        </div>\n      </div>;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"并且生成了相应的资源文件："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'const resource = {\n    "intl1": "title",\n    "intl2": "desc",\n    "intl3": "aaa {placeholder} bbb {placeholder} ccc",\n    "intl4": "app",\n    "intl5": "测试"\n};\nexport default resource;\n'})}),"\n",(0,i.jsx)(e.p,{children:"其实我们可以更进一步，比如自动对接翻译 api，来生成翻译后的资源文件等，这个案例只是提供思路，大家如果工作中用到了，可以继续扩展和完善。"}),"\n",(0,i.jsxs)(e.p,{children:["滴滴、字节等公司都有类似的方案，比如滴滴的 ",(0,i.jsx)(e.a,{href:"https://github.com/didi/di18n",target:"_blank",rel:"noopener noreferrer",children:"di18n"})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"或者做成 VSCode 插件："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsxs)(e.h2,{id:"总结",children:["总结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"这一节我们实现了自动国际化的案例，主要是要替换字符串和模版字符串为对应的函数调用语句，要做模块的自动引入。引入的 id 要生成全局唯一的，注意 jsx 中如果是属性的替换要用 {} 包裹。"}),"\n",(0,i.jsx)(e.p,{children:"自动国际化的方案也是大厂都在用的，原理就是通过 AST 分析出要转换的代码，然后自动转换。"}),"\n",(0,i.jsxs)(e.p,{children:["（代码在",(0,i.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(r,{...n})}):r(n)}let p=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F17.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B_%20%E8%87%AA%E5%8A%A8%E5%9B%BD%E9%99%85%E5%8C%96.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"总结",id:"总结",depth:2}],title:"17.实战案例_ 自动国际化",headingTitle:"17.实战案例_ 自动国际化",frontmatter:{}}}}]);