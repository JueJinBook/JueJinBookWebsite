"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["49779"],{35475:function(e,n,c){c.r(n),c.d(n,{default:()=>h});var d=c(552676),s=c(740453);let l=c.p+"static/image/930f1520d7a2956714a937a9bf1a677c.43dded17.webp";function r(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",pre:"pre",code:"code",strong:"strong",img:"img"},(0,s.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"36-原理篇--位掩码",children:["36-原理篇 ❘ 位掩码",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36-原理篇--位掩码",children:"#"})]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"推荐学习指数：⭐️️⭐️️"}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"上篇我们讲到 Svelte 的运行时源码中有这样一句代码："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n"})}),"\n",(0,d.jsxs)(n.p,{children:["它的作用是将 ",(0,d.jsx)(n.code,{children:"i"}),"值存储下来，从而知道上下文（ctx）中哪些下标值对应的变量发生了变化。"]}),"\n",(0,d.jsx)(n.p,{children:"其实在更早的版本中，并没有这么“复杂”，不就是存储哪些值发生了变化吗？那就直接存储好了！举个例子："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-xml",children:"<script>\n  let name = 'World';\n  function update() {\n    name = 'Svelte';\n  }\n<\/script>\n\n<h1 on:click={update}>Hello {name}</h1>\n"})}),"\n",(0,d.jsxs)(n.p,{children:["点击 ",(0,d.jsx)(n.code,{children:"<h1>"}),"的时候，",(0,d.jsx)(n.code,{children:"name"})," 值发生变化，那就将 ",(0,d.jsx)(n.code,{children:"$$.dirty"}),"存成："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"{\n  name: true;\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"name"}),"变量发生了变化，然后异步更新，最后执行 ",(0,d.jsx)(n.code,{children:"p()"}),"函数："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"p($$.dirty, ctx) {\n  if ($$.dirty.name) set_data(t1, ctx.name);\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"这样的代码看起来就直观很多。"}),"\n",(0,d.jsxs)(n.p,{children:["但在 v3.16.0 后，Svelte 改成了现在的这种方式。这本质是一种叫做“",(0,d.jsx)(n.strong,{children:"位掩码（bitmask）"}),"”的技术。让我们举个简单的例子，来说明下“位掩码”："]}),"\n",(0,d.jsxs)(n.p,{children:["假设现在有",(0,d.jsx)(n.code,{children:"[name1，name2，name3]"})," 三个值，我们需要知道哪些值发生了变化，为了节约存储空间，我们使用二进制来记录变化，其中 ",(0,d.jsx)(n.code,{children:"0"})," 表示未发生变化，",(0,d.jsx)(n.code,{children:"1"})," 表示发生了变化。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"name1"})," 是数组的第 1 个值，我们用 ",(0,d.jsx)(n.code,{children:"001"}),"表示其发生了变化。",(0,d.jsx)(n.code,{children:"name2"}),"是数组的第 2 个值，我们用 ",(0,d.jsx)(n.code,{children:"010"})," 表示其发生了变化，",(0,d.jsx)(n.code,{children:"name3"}),"是数组的第 3 个值，我们用 ",(0,d.jsx)(n.code,{children:"100"}),"表示其发生了变化。"]}),"\n",(0,d.jsxs)(n.p,{children:["如果",(0,d.jsx)(n.code,{children:"name1"})," 和 ",(0,d.jsx)(n.code,{children:"name3"})," 都发生了变化呢？那就是 ",(0,d.jsx)(n.code,{children:"101"}),"，如果全发生了变化，那就是 ",(0,d.jsx)(n.code,{children:"111"}),"，如果都没发生变化，那就是 ",(0,d.jsx)(n.code,{children:"000"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["最后我们将二进制转为十进制，比如二进制的 ",(0,d.jsx)(n.code,{children:"111"}),"就是 ",(0,d.jsx)(n.code,{children:"7"}),"，我们只用存储一个 ",(0,d.jsx)(n.code,{children:"7"}),"，就知道 ",(0,d.jsx)(n.code,{children:"name1"}),"、",(0,d.jsx)(n.code,{children:"name2"}),"、",(0,d.jsx)(n.code,{children:"name3"})," 都发生了变化。"]}),"\n",(0,d.jsxs)(n.p,{children:["接下来我们讲解 ",(0,d.jsx)(n.code,{children:"component.$$.dirty[(i / 31) | 0] |= 1 << i % 31"}),"到底做了什么？但因为这其中涉及到一些位运算的知识，考虑到大家可能接触不多，我们先从最基本的位运算开始讲起。不过不用担心，我们倒不是要完整复习一遍位运算，我们只会讲到本篇用到的位运算知识。"]}),"\n",(0,d.jsxs)(n.h2,{id:"2-按位或",children:["2. 按位或（|）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-按位或",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"按位或（|）运算符在其中一个或两个操作数对应的二进制位为 1 时，该位的结果值为 1。举个例子："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"const a = 5; // 00000000000000000000000000000101\nconst b = 3; // 00000000000000000000000000000011\n\nconsole.log(a | b); // 00000000000000000000000000000111\n// 输出: 7\n"})}),"\n",(0,d.jsx)(n.p,{children:"所以将任何整数 x 与 0 进行按位或运算得到 x，举个例子："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"const a = 5; // 00000000000000000000000000000101\nconst b = 0; // 00000000000000000000000000000000\n\nconsole.log(a | b); // 00000000000000000000000000000101\n// 输出: 5\n"})}),"\n",(0,d.jsxs)(n.p,{children:["那么问题来了，",(0,d.jsx)(n.code,{children:"(i / 31) | 0"}),"的作用是啥呢？"]}),"\n",(0,d.jsx)(n.p,{children:"答案是取整，我们可以在浏览器中试一下："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"// 0\n(1 / 31) | 0\n// 1\n(33 / 31) | 0\n// 2\n( 63 / 31) | 0\n"})}),"\n",(0,d.jsxs)(n.p,{children:["那么问题来了，为什么要 ",(0,d.jsx)(n.code,{children:"component.$$.dirty[(i / 31) | 0]"}),"呢？"]}),"\n",(0,d.jsx)(n.p,{children:"这是因为 JavaScript 进行二进制运算时，使用 32 位二进制整数，但还有一位要存放符号用于表示正负，所以只有 31 位可用于存储。这样最多就只能存储 31 个变量下标的变化。"}),"\n",(0,d.jsxs)(n.p,{children:["那假设上下文返回了一个包含 100 个变量的数组呢？所以才需要使用数组形式，",(0,d.jsx)(n.code,{children:"component.$$.dirty[(i / 31) | 0] = xxx"}),"，这样前 31 个变量下标（即数组的索引 0 到 30 的值）的变化存放到 ",(0,d.jsx)(n.code,{children:"$$.dirty[0]"}),"中，第 32 个 到 62 个的下标（即数组的索引 31 到 61）存放到 ",(0,d.jsx)(n.code,{children:"$$.dirty[1]"}),"中，依此类推。这样哪怕有 100 个变量，也只用存放 4 个整数就可以了。"]}),"\n",(0,d.jsxs)(n.h2,{id:"3-取余",children:["3. 取余（%）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-取余",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"取余（%）运算符返回左侧操作数除以右侧操作数的余数。它总是与被除数的符号保持一致。"}),"\n",(0,d.jsx)(n.p,{children:"这个符号想必大家已经很熟悉了，举个例子："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"console.log(13 % 5);\n// 输出: 3\n\nconsole.log(-13 % 5);\n// 输出: -3\n\nconsole.log(4 % 2);\n// 输出: 0\n\nconsole.log(-4 % 2);\n// 输出: -0\n"})}),"\n",(0,d.jsxs)(n.h2,{id:"4-左移-",children:["4. 左移 (<<)",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-左移-",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"左移操作符 (<<) 将第一个操作数向左移动指定位数，左边超出的位数将会被清除，右边将会补零。举个例子："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"const a = 5; // 00000000000000000000000000000101\nconst b = 2;\n\nconsole.log(a << b); // 00000000000000000000000000010100\n// 输出: 20\n"})}),"\n",(0,d.jsxs)(n.p,{children:["如果是 ",(0,d.jsx)(n.code,{children:"1 << n"}),"，假设 n 为 3，相当于："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"const a = 1; // 00000000000000000000000000000001\nconst b = 3;\n\nconsole.log(a << b); // 00000000000000000000000000001000\n// 输出: 8\n"})}),"\n",(0,d.jsxs)(n.p,{children:["前言中我们讲到，",(0,d.jsx)(n.code,{children:"[name1，name2，name3]"})," 三个值，",(0,d.jsx)(n.code,{children:"name1"})," 是数组的第 1 个值， 索引值为 ",(0,d.jsx)(n.code,{children:"0"}),"，我们用 ",(0,d.jsx)(n.code,{children:"001"}),"表示其发生了变化。",(0,d.jsx)(n.code,{children:"name2"}),"是数组的第 2 个值，索引值为 ",(0,d.jsx)(n.code,{children:"1"}),"，我们用 ",(0,d.jsx)(n.code,{children:"010"})," 表示其发生了变化，",(0,d.jsx)(n.code,{children:"name3"}),"是数组的第 3 个值，索引值为 ",(0,d.jsx)(n.code,{children:"2"}),"，我们用 ",(0,d.jsx)(n.code,{children:"100"}),"表示其发生了变化。"]}),"\n",(0,d.jsxs)(n.p,{children:["那么问题来了，我们怎么从数组的下标值，换算成对应的二进制值呢？即如何从索引 ",(0,d.jsx)(n.code,{children:"0"})," 转成 ",(0,d.jsx)(n.code,{children:"001"}),"，索引",(0,d.jsx)(n.code,{children:"1"}),"转成 ",(0,d.jsx)(n.code,{children:"010"}),"，索引",(0,d.jsx)(n.code,{children:"2"}),"转成 ",(0,d.jsx)(n.code,{children:"100"}),"呢？"]}),"\n",(0,d.jsxs)(n.p,{children:["这就是 ",(0,d.jsx)(n.code,{children:"1 << n"}),"实现的效果，",(0,d.jsx)(n.code,{children:"1 << 0"}),"，结果为 ",(0,d.jsx)(n.code,{children:"00000000000000000000000000000001"}),"。",(0,d.jsx)(n.code,{children:"1 << 1"}),"，结果为 ",(0,d.jsx)(n.code,{children:"00000000000000000000000000000010"}),"，",(0,d.jsx)(n.code,{children:"1 << 2"}),"结果为 ",(0,d.jsx)(n.code,{children:"00000000000000000000000000000100"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["而 ",(0,d.jsx)(n.code,{children:"1 << i % 31"}),"，相当于 ",(0,d.jsx)(n.code,{children:"1 << (i % 31)"}),"，也是相同的效果。之所以要 ",(0,d.jsx)(n.code,{children:"i % 31"})," 是每次最多存储 31 个下标值，所以要通过取余获取当前的存放位置。"]}),"\n",(0,d.jsxs)(n.h2,{id:"5-按位或赋值",children:["5. 按位或赋值（|=）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-按位或赋值",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"按位或赋值（|=) 运算符使用两个操作数的二进制表示，对它们执行按位或运算并将结果分配给变量："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"x |= y; // x = x | y\n"})}),"\n",(0,d.jsx)(n.p,{children:"所以："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n\n// 相当于\n\ncomponent.$$.dirty[(i / 31) | 0] = component.$$.dirty[(i / 31) | 0] | (1 << i % 31);\n"})}),"\n",(0,d.jsx)(n.p,{children:"而按位或（|）运算符在其中一个或两个操作数对应的二进制位为 1 时，该位的结果值为 1。"}),"\n",(0,d.jsxs)(n.p,{children:["这样做是因为每次更新可能会有多个下标值需要记录，我们需要在之前记录的基础上再添加新的记录，而 ",(0,d.jsx)(n.code,{children:"|"}),"正好满足要求，因为 ",(0,d.jsx)(n.code,{children:"1"})," 表示发生了变化，所以原本已经标记为 ",(0,d.jsx)(n.code,{children:"1"})," ，",(0,d.jsx)(n.code,{children:"|"})," 之后结果依然为 1。原本为 ",(0,d.jsx)(n.code,{children:"0"}),"，遇到新的 ",(0,d.jsx)(n.code,{children:"1"}),"，则会记录下来。"]}),"\n",(0,d.jsxs)(n.p,{children:["所以最后让我们重新看下 ",(0,d.jsx)(n.code,{children:"component.$$.dirty[(i / 31) | 0] |= 1 << i % 31"}),"，它其实就是借助 JavaScript 的二进制计算，使用一个整数一次最多记录 31 个下标值是否发生了变化。"]}),"\n",(0,d.jsxs)(n.h2,{id:"6-按位与",children:["6. 按位与（&）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-按位与",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"按位与（&）运算符在两个操作数对应的二进位都为 1 时，该位的结果值才为 1。举个例子："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"const a = 5; // 00000000000000000000000000000101\nconst b = 3; // 00000000000000000000000000000011\n\nconsole.log(a & b); // 00000000000000000000000000000001\n// 输出: 1\n"})}),"\n",(0,d.jsx)(n.p,{children:"简单来说，就是先将数字转为二进位，然后按位构造结果。"}),"\n",(0,d.jsx)(n.p,{children:"那你可能会想，这个有什么用呢？"}),"\n",(0,d.jsx)(n.p,{children:"我们可以用来判断当前值是否发生了变化。"}),"\n",(0,d.jsxs)(n.p,{children:["依然以 ",(0,d.jsx)(n.code,{children:"[name1, name2, name3]"}),"这个数组为例，假设记录的结果为 ",(0,d.jsx)(n.code,{children:"6"}),"，转为二进制为 ",(0,d.jsx)(n.code,{children:"110"}),"，表示 ",(0,d.jsx)(n.code,{children:"name2"})," 和 ",(0,d.jsx)(n.code,{children:"name3"})," 发生了变化。现在我们要判断索引值为 ",(0,d.jsx)(n.code,{children:"n"}),"的值是否发生了变化，该怎么判断呢？"]}),"\n",(0,d.jsxs)(n.p,{children:["这个时候就需要 ",(0,d.jsx)(n.code,{children:"&"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们以 ",(0,d.jsx)(n.code,{children:"name1"}),"为例，name1 的索引值为 ",(0,d.jsx)(n.code,{children:"0"}),"，",(0,d.jsx)(n.code,{children:"1 << 0"})," 对应的二进制为 ",(0,d.jsx)(n.code,{children:"001"}),"，对应十进制为 ",(0,d.jsx)(n.code,{children:"1"}),"，记录变化的结果为 ",(0,d.jsx)(n.code,{children:"6"}),"，也就是 ",(0,d.jsx)(n.code,{children:"110"}),"，我们就可以通过 ",(0,d.jsx)(n.code,{children:"6 & 1"}),"即 ",(0,d.jsx)(n.code,{children:"110 & 001"}),"来判断，此时结果为 ",(0,d.jsx)(n.code,{children:"0"}),"，表示没有变化。"]}),"\n",(0,d.jsxs)(n.p,{children:["假设记录变化的结果为 ",(0,d.jsx)(n.code,{children:"7"}),"，也就是 ",(0,d.jsx)(n.code,{children:"111"}),"，通过 ",(0,d.jsx)(n.code,{children:"7 & 1"}),"即 ",(0,d.jsx)(n.code,{children:"111 & 001"}),"来判断，此时结果为 ",(0,d.jsx)(n.code,{children:"1"}),"，表示发生了变化。"]}),"\n",(0,d.jsxs)(n.p,{children:["对于其他值也是类似的结果，只要结果不为 ",(0,d.jsx)(n.code,{children:"0"}),"，就表示发生了变化。"]}),"\n",(0,d.jsx)(n.p,{children:"现在让我们看个例子："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"<script>\n  let name1 = 'World';\n  let name2 = 'World';\n  let name3 = 'World';\n  let name4 = 'World';\n  let name5 = 'World';\n  let name6 = 'World';\n  let name7 = 'World';\n  let name8 = 'World';\n<\/script>\n\n<button on:click={() => name1 = 'Svelte'}>Hello {name1}</button>\n<button on:click={() => name2 = 'Svelte'}>Hello {name2}</button>\n<button on:click={() => name3 = 'Svelte'}>Hello {name3}</button>\n<button on:click={() => name4 = 'Svelte'}>Hello {name4}</button>\n<button on:click={() => name5 = 'Svelte'}>Hello {name5}</button>\n<button on:click={() => name6 = 'Svelte'}>Hello {name6}</button>\n<button on:click={() => name7 = 'Svelte'}>Hello {name7}</button>\n<button on:click={() => name8 = 'Svelte'}>Hello {name8}</button>\n"})}),"\n",(0,d.jsxs)(n.p,{children:["对应 ",(0,d.jsx)(n.a,{href:"https://svelte.dev/repl/a5d6a2196da64993968e71f4791439a6?version=4.2.19",title:"https://svelte.dev/repl/a5d6a2196da64993968e71f4791439a6?version=4.2.19",target:"_blank",rel:"noopener noreferrer",children:"REPL 的输出结果"}),"为："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:l,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["注意 ",(0,d.jsx)(n.code,{children:"p(ctx, [dirty])"}),"中的变化，",(0,d.jsx)(n.code,{children:"name1"})," 比较是 ",(0,d.jsx)(n.code,{children:"dirty & 1"}),"，",(0,d.jsx)(n.code,{children:"name4"})," 比较的是 ",(0,d.jsx)(n.code,{children:"dirty & 8"}),"，",(0,d.jsx)(n.code,{children:"name4"})," 为什么对应 8 呢？正是因为 ",(0,d.jsx)(n.code,{children:"name4"}),"在 ",(0,d.jsx)(n.code,{children:"instance"})," 函数返回的数组中的索引值为 ",(0,d.jsx)(n.code,{children:"3"}),"，也就是数组的第 4 个元素，",(0,d.jsx)(n.code,{children:"1 << 3"}),"，对应二进制 ",(0,d.jsx)(n.code,{children:"1000"}),"，转为十进制就是 ",(0,d.jsx)(n.code,{children:"8"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"name5"})," 对应 ",(0,d.jsx)(n.code,{children:"16"}),"，",(0,d.jsx)(n.code,{children:"name6"})," 对应 ",(0,d.jsx)(n.code,{children:"32"}),"……都是同样的计算逻辑。"]}),"\n",(0,d.jsxs)(n.p,{children:["而 ",(0,d.jsx)(n.code,{children:"dirty"})," 正是计算的结果，通过 ",(0,d.jsx)(n.code,{children:"dirty && n"}),"，我们就可以算出当前索引值对应的变量是否发生了变化，如果发生了变化，则调用 ",(0,d.jsx)(n.code,{children:"set_data"}),"更新数据。"]}),"\n",(0,d.jsxs)(n.p,{children:["所以可以看出，Svelte 其实在 ",(0,d.jsx)(n.code,{children:"p"})," 函数中就计算出了数据和 DOM 之间的映射关系，通过简单的位运算就可以算出当前数据是否发生了变化，然后直接更新 DOM，算是一个十分巧妙的实现。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(r,{...e})}):r(e)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F36-%E5%8E%9F%E7%90%86%E7%AF%87%20%E2%9D%98%20%E4%BD%8D%E6%8E%A9%E7%A0%81.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. 按位或（|）",id:"2-按位或",depth:2},{text:"3. 取余（%）",id:"3-取余",depth:2},{text:"4. 左移 (<<)",id:"4-左移-",depth:2},{text:"5. 按位或赋值（|=）",id:"5-按位或赋值",depth:2},{text:"6. 按位与（&）",id:"6-按位与",depth:2}],title:"36-原理篇 ❘ 位掩码",headingTitle:"36-原理篇 ❘ 位掩码",frontmatter:{}}}}]);