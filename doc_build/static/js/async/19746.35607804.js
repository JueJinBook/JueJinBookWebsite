"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19746"],{270845:function(e,n,s){s.r(n),s.d(n,{default:()=>m});var t=s(552676),r=s(740453);let i=s.p+"static/image/ac20fbef794765ce279c93b85123313b.694c43fc.webp",o=s.p+"static/image/ee98e436965ae0e179070604e3220eb9.0a7a2fa7.webp",c=s.p+"static/image/dc77855d0da4c32df45f8caa64d71faf.867f3229.webp",a=s.p+"static/image/23246fd2f5916a43a0fe27f320be4b01.719a6eab.webp",p=s.p+"static/image/f8875063b5f67359c19db862cbb81d49.8eaded71.webp",d=s.p+"static/image/7a72e3b99577168503ed5209a83125da.70a2f329.webp",l=s.p+"static/image/a8ee1e65efa92265ea534bdd23e2b37d.855e489f.webp",h=s.p+"static/image/d675d5fccdd84cfa9fae8f8a0a2b9f1b.f1433ce2.webp",j=s.p+"static/image/892c09da5e57fa83f994918e7ffab5e2.e2b648e4.webp",x=s.p+"static/image/d8b246a905e93d996d62e460b3692984.1185ece1.webp",u=s.p+"static/image/99c9bfea553186997b6b858cf333efe1.18dfa4b4.webp";function w(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",strong:"strong",h2:"h2"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"67-nest-里实现-session-和-jwt",children:["67. Nest 里实现 Session 和 JWT",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#67-nest-里实现-session-和-jwt",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"上节我们知道了保存登录状态的两种方式，session + cookie、jwt，这节我们用 Nest 来实现下吧。"}),"\n",(0,t.jsx)(n.p,{children:"首先用 @nest/cli 快速创建一个 Nest.js 项目"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"nest new jwt-and-session -p npm\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们先实现 session  + cookie 的方式："}),"\n",(0,t.jsx)(n.p,{children:"Nest 里实现 session 实现还是用的 express 的中间件 express-session。"}),"\n",(0,t.jsx)(n.p,{children:"安装 express-session 和它的 ts 类型定义："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install express-session @types/express-session\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后在入口模块里启用它："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport * as session from 'express-session';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  app.use(session({\n    secret: 'guang',\n    resave: false,\n    saveUninitialized: false\n  }));\n  await app.listen(3000);\n}\nbootstrap();\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"使用 express-session 中间件，指定加密的密钥 secret。"}),"\n",(0,t.jsx)(n.p,{children:"resave 为 true 是每次访问都会更新 session，不管有没有修改 session 的内容，而 false 是只有 session 内容变了才会去更新 session。"}),"\n",(0,t.jsx)(n.p,{children:"saveUninitalized 设置为 true 是不管是否设置 session，都会初始化一个空的 session 对象。比如你没有登录的时候，也会初始化一个 session 对象，这个设置为 false 就好。"}),"\n",(0,t.jsx)(n.p,{children:"然后在 controller 里就可以注入 session 对象："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"@Get('sss')\nsss(@Session() session) {\n    console.log(session)\n    session.count = session.count ? session.count + 1 : 1;\n    return session.count;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"我在 session 里放了个 count 的变量，每次访问加一，然后返回这个 count。"}),"\n",(0,t.jsx)(n.p,{children:"这样就可以判断 http 请求是否有了状态。"}),"\n",(0,t.jsx)(n.p,{children:"把它跑起来："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"nest start --watch\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后用 postman 测试下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到每次请求返回的数据都不同，而且返回了一个 cookie 是 connect.sid，这个就是对应 session 的 id。"}),"\n",(0,t.jsx)(n.p,{children:"因为 cookie 在请求的时候会自动带上，就可以实现请求的标识，给 http 请求加上状态。"}),"\n",(0,t.jsx)(n.p,{children:"session + cookie 的方式用起来还是很简单的，我们再来看下 jwt 的方式："}),"\n",(0,t.jsx)(n.p,{children:"jwt 需要引入 @nestjs/jwt 这个包"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install @nestjs/jwt\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后在 AppModule 里引入 JwtModule："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Module } from '@nestjs/common';\nimport { JwtModule } from '@nestjs/jwt';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [\n    JwtModule.register({\n      secret: 'guang',\n      signOptions: {\n        expiresIn: '7d'\n      }\n    })\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"JwtModule 是一个动态模块，通过 register 传入 option。"}),"\n",(0,t.jsx)(n.p,{children:"或者是 registerAsync，然后通过 useFactory 异步拿到 option 传入："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这部分是动态模块的知识，忘了的同学可以看看动态模块那节。"}),"\n",(0,t.jsx)(n.p,{children:"指定 secret，也就是加密 jwt 的密钥，还有 token 过期时间 expiresIn，设置 7 天。"}),"\n",(0,t.jsx)(n.p,{children:"然后在 controller 里注入 JwtModule 里的 JwtService："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后添加一个 handler："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"@Get('ttt')\nttt(@Res({ passthrough: true}) response: Response) {\n    const newToken = this.jwtService.sign({\n      count: 1\n    });\n\n    response.setHeader('token', newToken);\n    return 'hello';\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里使用 jwtService.sign 来生成一个 jwt token，放到 response header 里。"}),"\n",(0,t.jsx)(n.p,{children:"因为注入 response 对象之后，默认不会把返回值作为 body 了，需要设置 passthrough 为 true 才可以。"}),"\n",(0,t.jsx)(n.p,{children:"然后访问下试试看："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，返回的响应确实带上了这个 header。"}),"\n",(0,t.jsx)(n.p,{children:"后面的请求需要带上这个 token，在服务端取出来，然后 +1 之后再放回去："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"@Get('ttt')\nttt(@Headers('authorization') authorization: string, @Res({ passthrough: true}) response: Response) {\n    if(authorization) {\n      try {\n        const token = authorization.split(' ')[1];\n        const data = this.jwtService.verify(token);\n\n        const newToken = this.jwtService.sign({\n          count: data.count + 1\n        });\n        response.setHeader('token', newToken);\n        return data.count + 1\n      } catch(e) {\n        console.log(e);\n        throw new UnauthorizedException();\n      }\n    } else {\n      const newToken = this.jwtService.sign({\n        count: 1\n      });\n\n      response.setHeader('token', newToken);\n      return 1;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"通过 @Headers 装饰器取出 autorization 的 header，然后通过 jwtService.verify 对它做验证。"}),"\n",(0,t.jsx)(n.p,{children:"如果验证失败，那就抛出 UnauthorizedException 异常，让 Nest 内置的 Exception Filter 来处理。"}),"\n",(0,t.jsx)(n.p,{children:"验证成功就重新生成 jwt 放到 header 里返回。"}),"\n",(0,t.jsx)(n.p,{children:"如果没有 autorization 的 header，那就生成一个 jwt 放到 header 里返回。"}),"\n",(0,t.jsx)(n.p,{children:"然后我们测试下。"}),"\n",(0,t.jsx)(n.p,{children:"第一次访问，会返回 jwt token，把它复制下来："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"放到请求的 header 里："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这时候响应为 2，并且返回一个新的 token："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"把它复制下来放到 header 里再次请求："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这时候返回的就是 3 了。"}),"\n",(0,t.jsx)(n.p,{children:"这就是通过 jwt 保存状态的方式。"}),"\n",(0,t.jsx)(n.p,{children:"那我们带一个错误的 token 呢？"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这时候 jwtService.verify 方法就会抛异常，然后我们返回了 401 错误。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这样，我们就分别用 Nest 分别实现了 session + cookie 和 jwt 两种保存 http 状态的方式。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"携带 jwt 需要加载 authorization 的 header 里，以 Bearer xxx 的格式，但是返回 jwt 可以放在任何地方，header、cookie 或者 body 里都可以。"})}),"\n",(0,t.jsxs)(n.p,{children:["案例代码在",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/jwt-and-session",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们分别在 nest 里实现了 session、jwt 两种给 http 添加状态的方式。"}),"\n",(0,t.jsx)(n.p,{children:"session 使用的是 express 的 express-session 中间件，通过 @Session 装饰器取出来传入 controller 里。"}),"\n",(0,t.jsx)(n.p,{children:"jwt 需要引入 @nestjs/jwt 包的 JwtModule，注入其中的 JwtService，然后通过 jwtService.sign 生成 token，通过 jwtService.verify 验证 token。"}),"\n",(0,t.jsx)(n.p,{children:"token 放在 authorization 的 header 里。"}),"\n",(0,t.jsx)(n.p,{children:"session 或者 jwt 都是非常常用的给 http 添加状态的方式，下节我们用这两种方式实现下登录注册功能。"})]})}function g(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(w,{...e})}):w(e)}let m=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F67.%20Nest%20%E9%87%8C%E5%AE%9E%E7%8E%B0%20Session%20%E5%92%8C%20JWT.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"67. Nest 里实现 Session 和 JWT",headingTitle:"67. Nest 里实现 Session 和 JWT",frontmatter:{}}}}]);