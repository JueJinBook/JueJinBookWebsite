"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75178"],{293322:function(e,n,t){t.r(n),t.d(n,{default:()=>_});var s=t(552676),r=t(740453);let c=t.p+"static/image/8b685e6b45a8ad8297b2994b33c9c3e4.48369f41.webp",a=t.p+"static/image/dede7ac41b5f372f49b32316e6087e25.81e4a18c.webp",i=t.p+"static/image/eea71f61fa978485476f2f5dd3d766cf.fd836676.webp",o=t.p+"static/image/2cd8b4c330455fb429e1a3e78f11d232.e4fc7dd7.webp",l=t.p+"static/image/9abc4ed0fafa2d73e9d7cd1fe10e2f75.4c29bcf8.webp",p=t.p+"static/image/06c8ee7ae1fb51c1ae4a0139d5b51884.92b1ad10.webp",d=t.p+"static/image/5e73bb06aa0b574c259e900b2dcc8485.91a9a9f8.webp",j=t.p+"static/image/53c54f7a5de32a449a27bbc7af426e49.51454b6f.webp",h=t.p+"static/image/fe283511a36c2730ff332589541444a4.193a7e5c.webp",x=t.p+"static/image/92671be24c4e8cecd3416e73fef82225.6a1d9df8.webp",m=t.p+"static/image/5edb0b8c11969d5d38041305de167995.0c0890a5.webp",g=t.p+"static/image/44508f2c0489565806e3e75ecdf92914.d42c7bf3.gif",u=t.p+"static/image/97c7452b6bcf6191b63d206a41f9b923.3bf9223e.webp",b=t.p+"static/image/ef61cf1366f8b4112813e60a7f84f0fd.333ed156.webp",f=t.p+"static/image/b16097a167b866434d3603f1ee1caafd.3981dea7.webp",w=t.p+"static/image/f93371f0905fec118c2c35873322ecba.aeac08ae.webp",k=t.p+"static/image/c50775a4a843b44f8f14fbdc13ed9737.dcb0f20f.webp",v=t.p+"static/image/173819a2a84e099a7f0f54a761b0dfa1.caba3e85.webp",E=t.p+"static/image/40ec770b2c9f973b6f570280ebf5e13b.3494ebdb.webp",S=t.p+"static/image/30978e571c3a2ac8c49ca3beb4732108.8352a840.webp",A=t.p+"static/image/7f4b6ab416188edebf5dc52edd9f6769.f8373750.webp",C=t.p+"static/image/8ef1d396f1e75df4b2dc4faca5c779b1.b7230b62.webp",y=t.p+"static/image/00bc9a5a09d79aab29f5abf3cd5b48ca.b3c06c95.webp",B=t.p+"static/image/3a17bac666148ae97c5e47f54baa3d59.bb42da69.webp",U=t.p+"static/image/2612537908a490c67e7204500ac8839a.56da8643.webp";function z(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",pre:"pre",code:"code",img:"img",h2:"h2"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"72-单-token-无限续期实现登录状态无感刷新",children:["72. 单 token 无限续期，实现登录状态无感刷新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#72-单-token-无限续期实现登录状态无感刷新",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上节我们基于双 token 实现了登录状态的无感刷新。"}),"\n",(0,s.jsx)(n.p,{children:"这当然是能实现功能的，很多公司也这样用。"}),"\n",(0,s.jsx)(n.p,{children:"但是双 token 实现起来还是挺麻烦的。"}),"\n",(0,s.jsx)(n.p,{children:"所以实际上单 token 自动续期的方式用的也非常多。"}),"\n",(0,s.jsxs)(n.p,{children:["单 token 的原理也很简单，就是登录后返回 jwt，每次请求接口带上这个 jwt，然后",(0,s.jsx)(n.strong,{children:"每次访问接口返回新的 jwt，然后前端更新下本地的 jwt token"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"比如这个 token 是 7 天过期，那只要 7 天内访问一次系统，就会刷新 token。"}),"\n",(0,s.jsx)(n.p,{children:"7 天内不访问系统，token 过期，就需要重新登录了。"}),"\n",(0,s.jsx)(n.p,{children:"这种方案也能实现无感刷新，而且代码简单的多。"}),"\n",(0,s.jsx)(n.p,{children:"我们来写一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest new single-token-refresh\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:U,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"进入项目，添加一个 user 模块："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest g resource user --no-spec\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"加一个 login 的路由："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Body, Controller, Post } from '@nestjs/common';\nimport { UserService } from './user.service';\nimport { LoginUserDto } from './dto/login-user.dto';\n\n@Controller('user')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Post('login')\n  async login(@Body() loginDto: LoginUserDto) {\n    console.log(loginDto)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"对应的 user/dto/login-user.dto.ts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export class LoginUserDto {\n    username: string;\n    password: string;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"把服务跑起来："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm run start:dev\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"postman 访问下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"登录成功返回 jwt，安装下用到的包："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save @nestjs/jwt\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 AppModule 引入："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { UserModule } from './user/user.module';\nimport { JwtModule } from '@nestjs/jwt';\n\n@Module({\n  imports: [UserModule, \n    JwtModule.register({\n      global: true,\n      secret: 'guang'\n    })\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后 login 的时候返回 jwt"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { BadRequestException, Body, Controller, Inject, Post } from '@nestjs/common';\nimport { UserService } from './user.service';\nimport { LoginUserDto } from './dto/login-user.dto';\nimport { JwtService } from '@nestjs/jwt';\n\n@Controller('user')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Inject(JwtService)\n  jwtService: JwtService;\n\n  @Post('login')\n  async login(@Body() loginDto: LoginUserDto) {\n    if(loginDto.username !== 'guang' || loginDto.password !== '123456') {\n      throw new BadRequestException('用户名或密码错误');\n    }\n    const jwt = this.jwtService.sign({\n      username: loginDto.username\n    }, {\n      secret: 'guang',\n      expiresIn: '7d'\n    });\n    return jwt;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"登录后返回 jwt，过期时间是 7 天。"}),"\n",(0,s.jsx)(n.p,{children:"访问下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，登录后返回了 jwt。"}),"\n",(0,s.jsx)(n.p,{children:"然后加一个 Guard 来解析 jwt："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest g guard login --flat --no-spec\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"登录鉴权逻辑和之前一样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { JwtService } from '@nestjs/jwt';\nimport { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';\nimport { Request } from 'express';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class LoginGuard implements CanActivate {\n\n  @Inject(JwtService)\n  private jwtService: JwtService;\n\n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n\n    const request: Request = context.switchToHttp().getRequest();\n\n    const authorization = request.headers.authorization;\n\n    if(!authorization) {\n      throw new UnauthorizedException('用户未登录');\n    }\n\n    try{\n      const token = authorization.split(' ')[1];\n      const data = this.jwtService.verify(token);\n\n      return true;\n    } catch(e) {\n      throw new UnauthorizedException('token 失效，请重新登录');\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"取出 authorization header 中的 jwt token"}),"\n",(0,s.jsx)(n.p,{children:"jwt 有效就可以继续访问，否则返回 token 失效，请重新登录。"}),"\n",(0,s.jsx)(n.p,{children:"然后在 AppController 添加个接口加上登录鉴权："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"@Get('aaa')\naaa() {\n    return 'aaa';\n}\n\n@Get('bbb')\n@UseGuards(LoginGuard)\nbbb() {\n    return 'bbb';\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"aaa 接口可以直接访问，bbb 接口需要登录后才能访问。"}),"\n",(0,s.jsxs)(n.p,{children:["访问 aaa\n",(0,s.jsx)("img",{src:k,alt:""}),"\n访问 bbb"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"登录拿到 token："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"带上 token 访问 bbb："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"带上 token 就可以访问需要登录的接口了。"}),"\n",(0,s.jsx)(n.p,{children:"这样就完成了登录和鉴权。"}),"\n",(0,s.jsx)(n.p,{children:"但这个 token 是有过期时间的，过期了就要重新登录了，所以要刷新 token。"}),"\n",(0,s.jsx)(n.p,{children:"上节实现了双 token 的无感刷新，今天实现单 token 刷新。"}),"\n",(0,s.jsx)(n.p,{children:"方式很简单，就是访问接口后返回新 token："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { JwtService } from '@nestjs/jwt';\nimport { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';\nimport { Request, Response } from 'express';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class LoginGuard implements CanActivate {\n\n  @Inject(JwtService)\n  private jwtService: JwtService;\n\n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n\n    const request: Request = context.switchToHttp().getRequest();\n    const response: Response = context.switchToHttp().getResponse();\n\n    const authorization = request.headers.authorization;\n\n    if(!authorization) {\n      throw new UnauthorizedException('用户未登录');\n    }\n\n    try{\n      const token = authorization.split(' ')[1];\n      const data = this.jwtService.verify(token);\n\n      response.setHeader('token', this.jwtService.sign({\n        username: data.username\n      }, {\n        expiresIn: '7d'\n      }));\n\n      return true;\n    } catch(e) {\n      throw new UnauthorizedException('token 失效，请重新登录');\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"试一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样每次返回新 token，不就永不过期了？"}),"\n",(0,s.jsx)(n.p,{children:"而且实现还特别简单。"}),"\n",(0,s.jsx)(n.p,{children:"所以单 token 自动续期的方案用的挺多的。"}),"\n",(0,s.jsx)(n.p,{children:"我们写下前端代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx create-vite single-token-refresh-frontend\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"进入项目，把服务跑起来："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install\nnpm run dev\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"浏览器访问下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"项目跑起来后，我们调用下后端接口。"}),"\n",(0,s.jsx)(n.p,{children:"首先后端要开启跨域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后前端页面调用下："}),"\n",(0,s.jsx)(n.p,{children:"改下 App.tsx"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react'\nimport './App.css'\nimport axios from 'axios';\n\nfunction App() {\n  const [content, setContent] = useState('')\n\n  async function query() {\n    try {\n      const res = await axios.get('http://localhost:3000/bbb');\n      setContent(res.data);\n    } catch(e: any) {\n      console.log(e.response.data.message);\n    }\n  }\n\n  useEffect(() => {\n    query();\n  }, []);\n\n  return (\n    <div style={{fontSize: '100px'}}>{content}</div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsx)(n.p,{children:"在页面调用 bbb 接口，把结果显示到页面。"}),"\n",(0,s.jsx)(n.p,{children:"安装 axios："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save axios\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"提示未登录（打印两次是 main.tsx 里的 StrictMode 导致的，去掉就好了）"}),"\n",(0,s.jsx)(n.p,{children:"我们登录下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react'\nimport './App.css'\nimport axios from 'axios';\n\nfunction App() {\n  const [content, setContent] = useState('')\n\n  async function query() {\n    try {\n      const res = await axios.post('http://localhost:3000/user/login', {\n        username: 'guang',\n        password: '123456'\n      });\n      console.log(res.data);\n\n      const res2 = await axios.get('http://localhost:3000/bbb', {\n        headers: {\n          Authorization: `Bearer ${res.data}`\n        }\n      });\n      setContent(res2.data);\n    } catch(e: any) {\n      console.log(e.response.data.message);\n    }\n  }\n\n  useEffect(() => {\n    query();\n  }, []);\n\n  return (\n    <div style={{fontSize: '100px'}}>{content}</div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsx)(n.p,{children:"现在接口就请求成功了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个 token 我们一般都放到 localstorage 里，每次请求都带上。"}),"\n",(0,s.jsx)(n.p,{children:"这段逻辑我们上节写过："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"axios.interceptors.request.use(function (config) {\n  const accessToken = localStorage.getItem('access_token');\n\n  if(accessToken) {\n    config.headers.authorization = 'Bearer ' + accessToken;\n  }\n  return config;\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"那单 token 如何刷新呢？"}),"\n",(0,s.jsx)(n.p,{children:"很简单，拦截器里把 header 里的新 token 更新到 localStorage 就好了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"axios.interceptors.response.use(\n  (response) => {\n    const newToken = response.headers['token'];\n    if(newToken) {\n      localStorage.setItem('token ', newToken);\n    }\n    return response;\n  }\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"但这样有个问题："}),"\n",(0,s.jsx)(n.p,{children:"打印下 header"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没有 token"}),"\n",(0,s.jsx)(n.p,{children:"但我们明明返回了啊："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这也是跨域的问题，默认你能访问的 header 是有限的。"}),"\n",(0,s.jsx)(n.p,{children:"如果想在代码访问别的 header，需要在后端支持下，在 Access-Controll-Expose-Headers 里加上这个 header"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"现在就可以访问这个 header 了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样更新完 localStorage 里的 token，不就实现无感刷新了么？"}),"\n",(0,s.jsx)(n.p,{children:"案例代码在小册仓库："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/single-token-refresh",target:"_blank",rel:"noopener noreferrer",children:"后端代码"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/single-token-refresh-frontend",target:"_blank",rel:"noopener noreferrer",children:"前端代码"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节我们实现了单 token 的无感刷新，它也是在公司里用的非常多的一种方案。"}),"\n",(0,s.jsx)(n.p,{children:"好处就是简单，只要每次请求接口的时候返回新的 token，然后刷新下本地 token 就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"我们在 axios 的 response 拦截器里可以轻松做到这个，比双 token 的无感刷新可简单太多了。"}),"\n",(0,s.jsx)(n.p,{children:"要注意的是在代码里访问其他 header，需要后端配置下 expose headers 才可以。"}),"\n",(0,s.jsx)(n.p,{children:"你们公司里是用双 token 还是单 token 实现登录状态无感刷新呢？"}),"\n",(0,s.jsx)(n.p,{children:"（这节写的有点问题，单 token 应该在快过期的时候返回新 token，后面优化下）"})]})}function q(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(z,{...e})}):z(e)}let _=q;q.__RSPRESS_PAGE_META={},q.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F72.%20%E5%8D%95%20token%20%E6%97%A0%E9%99%90%E7%BB%AD%E6%9C%9F%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"72. 单 token 无限续期，实现登录状态无感刷新",headingTitle:"72. 单 token 无限续期，实现登录状态无感刷新",frontmatter:{}}}}]);