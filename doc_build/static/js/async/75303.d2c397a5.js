"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75303"],{960544:function(e,n,s){s.r(n),s.d(n,{default:()=>x});var r=s(552676),t=s(740453);let a=s.p+"static/image/d70b9f95ae062a8061c8678aeb2e40dc.3cab3786.webp",i=s.p+"static/image/5e5b83961cf2b645875a125f809e1e08.417e8e2d.webp",d=s.p+"static/image/e9fee3889aca9163635496696523f2fa.1a03e640.webp",c=s.p+"static/image/0b979431b903f461397b06db79824d1e.43ea5046.webp",o=s.p+"static/image/beacd3e95d6e76a6a3de7d603d8e2c51.1ac4a604.webp",h=s.p+"static/image/12ff7778096392a7c807f7b9623c0aad.0175a793.webp",l=s.p+"static/image/cff55f827f5fe25c067085fdbbf1f7c8.913c00ec.webp",p=s.p+"static/image/ae314169422f3037dec4792dc5730b56.e2e9714a.webp",m=s.p+"static/image/7d84052b6666e69dffd51dcf77b5d4c6.760d3d8d.webp",u=s.p+"static/image/d9163243b56f253a27ae52a5613b6d8d.d5fd5525.webp";function g(e){let n=Object.assign({p:"p",img:"img",strong:"strong",h2:"h2",a:"a",ul:"ul",li:"li",h3:"h3",pre:"pre",code:"code",blockquote:"blockquote"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"通过上述组件的开发，我们已经能够基本完成编辑器的基础模块的核心部分，此时我们已经具备了一整套物料组件开发到画布界面的过程。"}),"\n",(0,r.jsxs)(n.p,{children:["如下图所示：\n基于现有的组件，我们可以很快速的进行容器的布局和大纲树的展示，这些都得益于之前编辑器的章节实现。\n",(0,r.jsx)("img",{src:u,alt:"image.png"})]}),"\n",(0,r.jsxs)(n.p,{children:["在本章节就要开始将自己的本地工程与服务端相结合，来完成整个",(0,r.jsx)(n.strong,{children:"lowcode"}),"的搭建流程。"]}),"\n",(0,r.jsx)(n.p,{children:"在此之前，我们所有的工作都是基于本地数据存储完成的，不管是本地的历史记录，还是基于本地的预览。在本章节将会让他们与服务端进行交互，从而存储我们编辑好的内容。"}),"\n",(0,r.jsxs)(n.h2,{id:"实现原理",children:["实现原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现原理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"整体的思路如下图所示，通过编辑器的操作将useSchema内的内容存储到对应的服务端存储与本地存储。"}),"\n",(0,r.jsx)(n.p,{children:"整体相当于需要实现服务端的通信接口，"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"POST /create:"}),"  创建一个路由页面接口"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PUT /save/[pageId]："})," 保存页面的接口设计"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GET /findById?id=[pageId]:"})," 通过id查找当前页面的数据"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"目前Demo示例而言是最简单的curd，后续的扩展会往集成化的后端服务上面去靠。具体的可以参考服务端的相关设计。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"实现过程",children:["实现过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现过程",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["基本了解了需求的背景和实现的设计思路后，接下来就来完成",(0,r.jsx)(n.strong,{children:"lowCode"}),"平台的基础流程搭建吧。"]}),"\n",(0,r.jsxs)(n.h3,{id:"useschema",children:["useSchema",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useschema",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们整个页面都是通过",(0,r.jsx)(n.strong,{children:"schema驱动"}),"的，所以",(0,r.jsx)(n.strong,{children:"schema"}),"的存储必然需要一个存储和解析的过程。在之前我们是通过",(0,r.jsx)(n.strong,{children:"localStorage"}),"的方式进行存储，在这一截就会通过远程接口的交互，从而来实现整个协议存储和返回的操作。"]}),"\n",(0,r.jsxs)(n.p,{children:["在此之前，已经在 ",(0,r.jsx)(n.strong,{children:"@huos/editor"}),"  项目下的",(0,r.jsx)(n.strong,{children:"stores"}),"目录下已经创建好了",(0,r.jsx)(n.strong,{children:"useSchema.tsx"}),"的状态管理hook。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["如下代码所示，在之前已经完成了locales的创建，在这里主要需要关注",(0,r.jsx)(n.strong,{children:"serializeNodes"}),"和",(0,r.jsx)(n.strong,{children:"schema"}),"。",(0,r.jsx)(n.strong,{children:"serializeNodes"}),"是当前页面的协议解析，",(0,r.jsx)(n.strong,{children:"schema"}),"是当前的的页面协议，两者数据是一样，区别店在于",(0,r.jsx)(n.strong,{children:"schema"}),"是需要保存在本地存储和数据库当中的。其他的属性，比如",(0,r.jsx)(n.strong,{children:"jsMoudleCode,depsMap"}),"等都是一些功能指定的字段，在之前协议涉及篇中其实也有提到过，本质上大差不差。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'/apps/editor/src/framework/stores/useSchema.tsx\nimport { create } from "zustand";\nimport { immer } from "zustand/middleware/immer";\nimport { devtools } from \'zustand/middleware\'\nimport { SerializedNodes } from "@craftjs/core";\nimport dayjs from "dayjs";\n\nexport interface LocaleDataRecordType {\n  key?: string;\n  cn?: string;\n  en?: string;\n  jp?: string;\n  kr?: string;\n  fe?: string;\n};\n\nexport interface DependencieRowType {\n  url: string;\n  version: string;\n}\n\nexport interface SchemaInfo {\n  opertionDate: number;\n  jsMoudleCode: string;\n  schema: string;\n  serializeNodes?: SerializedNodes;\n  locales: LocaleDataRecordType[];\n  depsMap: Record<string, DependencieRowType>\n}\n\nexport interface ISchemaState extends SchemaInfo {\n  setJsModuleCode: (code: string) => void;\n  onChange: (key: keyof SchemaInfo, value: any) => void;\n}\n\nexport const useSchema = create<ISchemaState>()(\n  devtools(immer((set) => ({\n    jsMoudleCode: "",\n    opertionDate: dayjs().valueOf(),\n    schema: "",\n    locales: [\n    ],\n    depsMap: {},\n    setJsModuleCode: (code) => {\n      set((state) => {\n        state.jsMoudleCode = code;\n      });\n    },\n    onChange: (key, value: any) => {\n      set((state) => {\n        // @ts-ignore\n        state[key] = value;\n      }, false, "onChange");\n    },\n  })), {\n    name: \'useSchema\'\n  })\n);\n\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"保存",children:["保存",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#保存",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如下代码所示, 在编辑器节点发生变化的时候，通过",(0,r.jsx)(n.strong,{children:"onNodesChange"}),"将当前的节点进行保存到状态当中进行存储。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// apps/editor/src/framework/provider.tsx\nconst { jsMoudleCode, onChange, locales } = useSchema();\n\n  // 初始化js模块\n  React.useEffect(() => {\n    jsRuntime.mountJsMoudle(jsMoudleCode);\n  }, [jsMoudleCode]);\n\n  /**\n   * 处理编辑器画布修改\n   * @param query 查询参数\n   */\n  const handleEditorChange: Options["onNodesChange"] = (query) => {\n    const serNodes = query.getSerializedNodes();\n    onChange("serializeNodes", serNodes);\n  };\n  \n  \n  // DOM\n  <RootEditor\n        resolver={{ ...DefaultMaterials, EmptySetter, ...AntDMaterials }}\n        onRender={CustomNodeRender}\n        onNodesChange={handleEditorChange}\n      >\n        <I18nextProvider i18n={i18n}>{props.children}</I18nextProvider>\n      </RootEditor>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useEditorKeyPress"}),"是一个",(0,r.jsx)(n.strong,{children:"键盘事件的hook"}),"，在内部主要实现了",(0,r.jsx)(n.strong,{children:"ctrl+s保存代码"}),"的逻辑，他首先会将当前",(0,r.jsx)(n.strong,{children:"schema"}),"数据进行lz的算法压缩，这个在之前做历史记录的时候提到过，压缩结束后就会通过",(0,r.jsx)(n.strong,{children:"onChangeSchema"}),"进行状态的设置，将其存储到",(0,r.jsx)(n.strong,{children:"useSchema"}),"当中，后面需要用到。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { useEditor } from '@craftjs/core';\nimport { useKeyPress } from 'ahooks';\nimport { stringifyLzUtfData } from '@/framework/utils/json'\nimport lf from 'localforage'\nimport { App } from 'antd';\nimport { useSchema } from '../stores/useSchema';\n\nexport const useEditorKeyPress = () => {\n\n  const { message } = App.useApp()\n  const { query } = useEditor()\n  const onChangeSchema = useSchema(selector => selector.onChange)\n\n  useKeyPress(['ctrl.s'], () => {\n    const lzData = stringifyLzUtfData(query.serialize())\n    lf.setItem('history', [{\n      [Date.now()]: lzData\n    }])\n    onChangeSchema('schema', lzData)\n    message.success(\"保存成功～\")\n  });\n\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"如下图所示"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"接口服务的设计",children:["接口服务的设计",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#接口服务的设计",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先，通过",(0,r.jsx)(n.strong,{children:"create"}),"接口来创建一页面。如下curl所示，传入对应的参数即可创建好基础的页面。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"name"}),"：页面的标题"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"route"}),": 路由的地址"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"state"}),"：页面的EditorState状态，也就是useSchema的内容"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"status"}),": 页面状态，是否上线和下线"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"webSiteId"}),"：页面站点id"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'# 42.项目进阶：Low Code 搭建\nmodel PageTable {\n  id        String          @id @default(auto()) @map("_id") @db.ObjectId\n  name      String          @default("Blank")\n  state     String          @default("")\n  route     String\n  status    PageTableStatus\n  createdAt DateTime        @default(now())\n  updatedAt DateTime        @updatedAt()\n\n  webSiteId String  @db.ObjectId\n  webSite   WebSite @relation(fields: [webSiteId], references: [id])\n\n  user      User        @relation(fields: [userId], references: [id])\n  userId    String      @db.ObjectId\n}\n\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"目前的表结构设计后续还会更新，总体的设计并不会改变，会在当前的表中新增相关的字段设计。"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-curl",children:'curl -X \'POST\' \\\n  \'http://127.0.0.1:10018/page-table/create\' \\\n  -H \'accept: application/json\' \\\n  -H \'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY1YzQ3ZTQzZTVlMmViZDkxYjU1Mzc2MSIsImlhdCI6MTcwNzM3NjM4Mn0.A8yDKCOmYdFyDvnkM29ppuHH8S_HIYP3jLB5d8007hs\' \\\n  -H \'Content-Type: application/json\' \\\n  -d \'{\n  "name": "首页",\n  "route": "/",\n  "state": "",\n  "status": "ONLINE",\n  "webSiteId": "6384be941de07d5f72a57758"\n}\'\n'})}),"\n",(0,r.jsx)(n.p,{children:"此时响应的数据中会返回对应的页面id，后续通过页面的id可以修改与查询当前的页面信息。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "statusCode": "200",\n  "data": {\n    "id": "65c4854be5e2ebd91b553763"\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"如下图所示就是相关的修改的查询接口。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"通过id查询页面信息"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"通过id修改相关的信息"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"接口开发",children:["接口开发",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#接口开发",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本接口基于fastify进行开发，也有对应nest的相关版本。"}),"\n",(0,r.jsxs)(n.h3,{id:"创建接口",children:["创建接口",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#创建接口",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"通过fastify.route创建一个POST接口，开始的时候需要验证站点，所有的页面都是挂载载一个站点下的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { FastifyPluginAsync } from "fastify";\nimport { Static, Type } from "@sinclair/typebox";\nimport { PageTableDBSchema } from "./schema";\n\nconst route: FastifyPluginAsync = async (fastify, opts): Promise<void> => {\n  const requestSchema = {\n    description: "创建站点页面",\n    tags: ["pageTable"],\n    summary: "创建页面",\n    body: Type.Omit(PageTableDBSchema, [\'updatedAt\', \'createdAt\', "id", "userId"]),\n    response: {\n      200: fastify.handleResponseSchema(\n        Type.Object({\n          id: Type.String()\n        })\n      ),\n    },\n    security: fastify.SECURITY\n  };\n  fastify.post<{\n    Body: Static<typeof requestSchema.body>;\n    User: {\n      id: string;\n    }\n  }>(\n    "/create",\n    {\n      schema: requestSchema,\n      onRequest: [fastify.authenticate],\n    },\n    async function (request, reply) {\n      const { id: userId }: any = request.user\n      const webSite = await fastify.prisma.webSite.findUnique({\n        where: {\n          id: request?.body.webSiteId\n        }\n      })\n      if (!webSite) {\n        reply.notFound(`当前站点${request?.body.webSiteId}未找到，请检查或者新建后重试。`)\n      }\n      \n      const pageRow = await fastify.prisma.pageTable.create({\n        data: {\n          ...request.body,\n          userId,\n        }\n      })\n\n      return {\n        id: pageRow.id\n      }\n    }\n  );\n};\n\nexport default route;\n\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"更新接口",children:["更新接口",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新接口",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["通过",(0,r.jsx)(n.strong,{children:"fastify.route"}),"创建一个",(0,r.jsx)(n.strong,{children:"PUT接口"}),"，通过id区分来区分不同的页面，可以对内部的字段进行修改。"]}),"\n",(0,r.jsxs)(n.p,{children:["需要注意的是，如下图所示，在数据模型中，有一个",(0,r.jsx)(n.strong,{children:"status"}),"的字段枚举分别为",(0,r.jsx)(n.strong,{children:"ONLINE"}),"和",(0,r.jsx)(n.strong,{children:"OFFLINE"}),"，主要是用于后续区分页面的可见程度，在面向用户时，往往需要经历不同环境的更迭和A/B/灰度的测试才会可见，因此增加一个状态用于区分现实。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import { FastifyPluginAsync } from "fastify";\nimport { Static, Type } from "@sinclair/typebox";\nimport { PageTableDBSchema } from "./schema";\n\nconst route: FastifyPluginAsync = async (fastify, opts): Promise<void> => {\n  const requestSchema = {\n    description: "通过页面id来更新页面信息",\n    tags: ["pageTable"],\n    summary: "更新页面信息",\n    params: Type.Pick(PageTableDBSchema, ["id"]),\n    body: Type.Partial(Type.Omit(PageTableDBSchema, [\'id\',\'updatedAt\', \'createdAt\', "userId", "webSiteId"])),\n    response: {\n      200: fastify.handleResponseSchema(PageTableDBSchema),\n    },\n    security: fastify.SECURITY,\n  };\n  fastify.put<{\n    Params: Static<typeof requestSchema.params>;\n    Body: Static<typeof requestSchema.body>;\n  }>(\n    "/save/:id",\n    {\n      schema: requestSchema,\n      onRequest: [fastify.authenticate],\n    },\n    async function (request, reply) {\n      try {\n        const pageId = request.params?.id;\n        const row = await fastify.prisma.pageTable.update({\n          where: {\n            id: pageId,\n          },\n          data: request.body\n        })\n        return row\n      } catch (error: any) {\n        throw error\n      }\n    }\n  );\n};\n\nexport default route;\n\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"查询接口",children:["查询接口",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#查询接口",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["通过",(0,r.jsx)(n.strong,{children:"fastify.route"}),"创建一个GET接口，用于",(0,r.jsx)(n.strong,{children:"查询页面id"}),"当前存储的数据，当首次进入页面时需要加载对应的远程数据进行填充。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import { FastifyPluginAsync } from "fastify";\nimport { Static, Type } from "@sinclair/typebox";\nimport { PageTableDBSchema } from "./schema";\n\nconst route: FastifyPluginAsync = async (fastify): Promise<void> => {\n  const requestSchema = {\n    description: "根据id查询当前页面",\n    tags: ["pageTable"],\n    summary: "查询页面",\n    querystring: Type.Object({\n      id: Type.String()\n    }),\n    response: {\n      200: fastify.handleResponseSchema(PageTableDBSchema),\n    },\n    security: fastify.SECURITY,\n  };\n  fastify.get<{\n    Querystring: Static<typeof requestSchema.querystring>;\n  }>(\n    "/findById",\n    {\n      schema: requestSchema,\n      onRequest: [fastify.authenticate],\n    },\n    async function (request, reply) {\n      try {\n        const pageId = request.query?.id;\n        const row = fastify.prisma.pageTable.findUnique({\n          where: {\n            id: pageId\n          },\n          include: {\n            webSite: true\n          }\n        })\n        return row\n      } catch (error: any) {\n        throw error\n      }\n    }\n  );\n};\n\nexport default route;\n\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"接口实现完成后，就是客户端进行对接。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"客户端实现",children:["客户端实现",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#客户端实现",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["实现完页面的",(0,r.jsx)(n.strong,{children:"curd的接口"}),"后，接下来就是客户端在保存发布的时候需要进行相关的接口调用。"]}),"\n",(0,r.jsx)(n.p,{children:"如下代码所示："}),"\n",(0,r.jsxs)(n.p,{children:["当点击发布按钮的时候，会执行",(0,r.jsx)(n.strong,{children:"handlePublishSchame"}),"方法，在内部会通过",(0,r.jsx)(n.strong,{children:"query.serialize"}),"方法获取当前最新的页面数据。"]}),"\n",(0,r.jsxs)(n.p,{children:["将整个",(0,r.jsx)(n.strong,{children:"useSchema"}),"的数据内容进行lz算法使用，在这里封装了一个",(0,r.jsx)(n.strong,{children:"stringifyLzUtfData"}),"方法来完成，压缩完成后即可得到一串压缩后的协议内容，然后将状态设置为ONLINE状态进行发布。"]}),"\n",(0,r.jsx)(n.p,{children:"如下图所示："}),"\n",(0,r.jsxs)(n.p,{children:["挣个",(0,r.jsx)(n.strong,{children:"PUT请求"}),"传递了",(0,r.jsx)(n.strong,{children:"pageId"}),"，且当前最新的",(0,r.jsx)(n.strong,{children:"state数据"}),"与",(0,r.jsx)(n.strong,{children:"status状态"}),"的变更，最终会返回更新后的结果相关数据。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import { useSchema } from "@/framework/stores/useSchema";\nimport { stringifyLzUtfData } from "@/framework/utils/json";\nimport { useEditor } from "@craftjs/core";\nimport { App, Button } from "antd";\nimport _ from "lodash";\nimport request from \'@/framework/utils/request\'\nimport { useParams } from \'react-router-dom\'\n\nexport const Publish = () => {\n\n  const { query } = useEditor()\n  const params = useParams()\n  const {  message } = App.useApp()\n  \n  const pageSchema = useSchema((selector) =>\n    _.omit(selector, ["setJsModuleCode", "onChange"])\n  );\n  const onChangeSchema = useSchema((selector) => selector.onChange\n  );\n\n  const handlePublishSchame = async () => {\n    const serialize = query.serialize()\n    onChangeSchema(\'schema\', serialize)\n\n    const newSchema: typeof pageSchema = {\n      ...pageSchema,\n      schema: serialize\n    }\n\n    const josnState = stringifyLzUtfData(JSON.stringify(newSchema))\n\n    const data = await request({\n      url: `/save/${params?.id}`,\n      method: \'PUT\',\n      data: {\n        state: josnState,\n        status: \'ONLINE\'\n      }\n    })\n\n    if (data) {\n      message.success("保存并且发布成功")\n    }\n  };\n\n  return (\n    <Button type="primary" onClick={handlePublishSchame}>\n      发布\n    </Button>\n  );\n};\n\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"到此，页面发布流程完成，后续就是根据当前页面的pageId来查询相关的状态信息并且将其重新恢复至useSchema当中。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"到此整个编辑器的前端部分就完成了初步的最小化的闭环，通过编辑器操作搭建组件、编排属性样式、定义事件面板和撰写js模式的方式可以初步的驱动当前页面组件的更新和JS表达式的执行。"}),"\n",(0,r.jsx)(n.p,{children:"在后续的章节中，将会在这基础之上增加新的页面交互和组件属性面板的补充，目前仅实现了保存协议状态的部分。"}),"\n",(0,r.jsxs)(n.p,{children:["整体项目如下所示：\n",(0,r.jsx)("img",{src:a,alt:"image.png"})]}),"\n",(0,r.jsxs)(n.h2,{id:"资源",children:["资源",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#资源",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.fastify.cn/",target:"_blank",rel:"noopener noreferrer",children:"https://www.fastify.cn/"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/220384402",target:"_blank",rel:"noopener noreferrer",children:"https://zhuanlan.zhihu.com/p/220384402"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://craft.js.org/docs/api/useEditor",target:"_blank",rel:"noopener noreferrer",children:"https://craft.js.org/docs/api/useEditor"})}),"\n"]})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F42.%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6%EF%BC%9ALow%20Code%20%E6%90%AD%E5%BB%BA.md"]={toc:[{text:"实现原理",id:"实现原理",depth:2},{text:"实现过程",id:"实现过程",depth:2},{text:"useSchema",id:"useschema",depth:3},{text:"保存",id:"保存",depth:3},{text:"接口服务的设计",id:"接口服务的设计",depth:2},{text:"接口开发",id:"接口开发",depth:2},{text:"创建接口",id:"创建接口",depth:3},{text:"更新接口",id:"更新接口",depth:3},{text:"查询接口",id:"查询接口",depth:3},{text:"客户端实现",id:"客户端实现",depth:3},{text:"总结",id:"总结",depth:2},{text:"资源",id:"资源",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);