"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["23386"],{218742:function(e,n,i){i.r(n),i.d(n,{default:()=>c});var r=i(552676),s=i(740453);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",h3:"h3",img:"img"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"7应用-6断尾求生--简单限流",children:["7应用 6：断尾求生 —— 简单限流",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7应用-6断尾求生--简单限流",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"限流算法在分布式领域是一个经常被提起的话题，当系统的处理能力有限时，如何阻止计划外的请求继续对系统施压，这是一个需要重视的问题。老钱在这里用 “断尾求生” 形容限流背后的思想，当然还有很多成语也表达了类似的意思，如弃卒保车、壮士断腕等等。"}),"\n",(0,r.jsx)(n.p,{children:"除了控制流量，限流还有一个应用目的是用于控制用户行为，避免垃圾请求。比如在 UGC 社区，用户的发帖、回复、点赞等行为都要严格受控，一般要严格限定某行为在规定时间内允许的次数，超过了次数那就是非法行为。对非法行为，业务必须规定适当的惩处策略。"}),"\n",(0,r.jsxs)(n.h2,{id:"如何使用-redis-来实现简单限流策略",children:["如何使用 Redis 来实现简单限流策略？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何使用-redis-来实现简单限流策略",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先我们来看一个常见 的简单的限流策略。系统要限定用户的某个行为在指定的时间里只能允许发生 N 次，如何使用 Redis 的数据结构来实现这个限流的功能？"}),"\n",(0,r.jsx)(n.p,{children:"我们先定义这个接口，理解了这个接口的定义，读者就应该能明白我们期望达到的功能。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'# 指定用户 user_id 的某个行为 action_key 在特定的时间内 period 只允许发生一定的次数 max_count\ndef is_action_allowed(user_id, action_key, period, max_count):\n    return True\n# 调用这个接口 , 一分钟内只允许最多回复 5 个帖子\ncan_reply = is_action_allowed("laoqian", "reply", 60, 5)\nif can_reply:\n    do_reply()\nelse:\n    raise ActionThresholdOverflow()\n'})}),"\n",(0,r.jsx)(n.p,{children:"先不要继续往后看，想想如果让你来实现，你该怎么做？"}),"\n",(0,r.jsxs)(n.h3,{id:"解决方案",children:["解决方案",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解决方案",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这个限流需求中存在一个滑动时间窗口，想想 zset 数据结构的 score 值，是不是可以通过 score 来圈出这个时间窗口来。而且我们只需要保留这个时间窗口，窗口之外的数据都可以砍掉。那这个 zset 的 value 填什么比较合适呢？它只需要保证唯一性即可，用 uuid 会比较浪费空间，那就改用毫秒时间戳吧。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/10/16483c2609601098?w=711&h=463&f=png&s=21910",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如图所示，用一个 zset 结构记录用户的行为历史，每一个行为都会作为 zset 中的一个 key 保存下来。同一个用户同一种行为用一个 zset 记录。"}),"\n",(0,r.jsx)(n.p,{children:"为节省内存，我们只需要保留时间窗口内的行为记录，同时如果用户是冷用户，滑动时间窗口内的行为是空记录，那么这个 zset 就可以从内存中移除，不再占用空间。"}),"\n",(0,r.jsx)(n.p,{children:"通过统计滑动窗口内的行为数量与阈值 max_count 进行比较就可以得出当前的行为是否允许。用代码表示如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'# coding: utf8\n\nimport time\nimport redis\n\nclient = redis.StrictRedis()\n\ndef is_action_allowed(user_id, action_key, period, max_count):\n    key = \'hist:%s:%s\' % (user_id, action_key)\n    now_ts = int(time.time() * 1000)  # 毫秒时间戳\n    with client.pipeline() as pipe:  # client 是 StrictRedis 实例\n        # 记录行为\n        pipe.zadd(key, now_ts, now_ts)  # value 和 score 都使用毫秒时间戳\n        # 移除时间窗口之前的行为记录，剩下的都是时间窗口内的\n        pipe.zremrangebyscore(key, 0, now_ts - period * 1000)\n        # 获取窗口内的行为数量\n        pipe.zcard(key)\n        # 设置 zset 过期时间，避免冷用户持续占用内存\n        # 过期时间应该等于时间窗口的长度，再多宽限 1s\n        pipe.expire(key, period + 1)\n        # 批量执行\n        _, _, current_count, _ = pipe.execute()\n    # 比较数量是否超标\n    return current_count <= max_count\n\n\nfor i in range(20):\n    print is_action_allowed("laoqian", "reply", 60, 5)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Java 版："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class SimpleRateLimiter {\n\n  private Jedis jedis;\n\n  public SimpleRateLimiter(Jedis jedis) {\n    this.jedis = jedis;\n  }\n\n  public boolean isActionAllowed(String userId, String actionKey, int period, int maxCount) {\n    String key = String.format("hist:%s:%s", userId, actionKey);\n    long nowTs = System.currentTimeMillis();\n    Pipeline pipe = jedis.pipelined();\n    pipe.multi();\n    pipe.zadd(key, nowTs, "" + nowTs);\n    pipe.zremrangeByScore(key, 0, nowTs - period * 1000);\n    Response<Long> count = pipe.zcard(key);\n    pipe.expire(key, period + 1);\n    pipe.exec();\n    pipe.close();\n    return count.get() <= maxCount;\n  }\n\n  public static void main(String[] args) {\n    Jedis jedis = new Jedis();\n    SimpleRateLimiter limiter = new SimpleRateLimiter(jedis);\n    for(int i=0;i<20;i++) {\n      System.out.println(limiter.isActionAllowed("laoqian", "reply", 60, 5));\n    }\n  }\n\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"这段代码还是略显复杂，需要读者花一定的时间好好啃。它的整体思路就是：每一个行为到来时，都维护一次时间窗口。将时间窗口外的记录全部清理掉，只保留窗口内的记录。zset 集合中只有 score 值非常重要，value 值没有特别的意义，只需要保证它是唯一的就可以了。"}),"\n",(0,r.jsx)(n.p,{children:"因为这几个连续的 Redis 操作都是针对同一个 key 的，使用 pipeline 可以显著提升 Redis 存取效率。但这种方案也有缺点，因为它要记录时间窗口内所有的行为记录，如果这个量很大，比如限定 60s 内操作不得超过 100w 次这样的参数，它是不适合做这样的限流的，因为会消耗大量的存储空间。"}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本节介绍的是限流策略的简单应用，它仍然有较大的提升空间，适用的场景也有限。为了解决简单限流的缺点，下一节我们将引入高级限流算法——漏斗限流。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F7%E5%BA%94%E7%94%A8%206%EF%BC%9A%E6%96%AD%E5%B0%BE%E6%B1%82%E7%94%9F%20%E2%80%94%E2%80%94%20%E7%AE%80%E5%8D%95%E9%99%90%E6%B5%81.md"]={toc:[{text:"如何使用 Redis 来实现简单限流策略？",id:"如何使用-redis-来实现简单限流策略",depth:2},{text:"解决方案",id:"解决方案",depth:3},{text:"小结",id:"小结",depth:2}],title:"7应用 6：断尾求生 —— 简单限流",headingTitle:"7应用 6：断尾求生 —— 简单限流",frontmatter:{}}}}]);