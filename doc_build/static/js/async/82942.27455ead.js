"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["82942"],{341992:function(e,n,t){t.r(n),t.d(n,{default:()=>a});var r=t(552676),s=t(740453);let c=t.p+"static/image/9c3993d95dc42b8bfa362f5acd197c46.70668f3d.gif";function o(e){let n=Object.assign({h2:"h2",a:"a",p:"p",pre:"pre",code:"code",strong:"strong",img:"img",blockquote:"blockquote",ol:"ol",li:"li"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["本来我想在 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309116644436115482",target:"_blank",rel:"noopener noreferrer",children:"《源码篇 | 实现 Server Actions》"}),"的基础上，完整实现客户端组件，但奈何实现之路太过坎坷，遇到太多莫名奇妙的问题，所以本篇只能浅浅实现一下，尽管如此，却也能帮助大家理解其背后实现。"]}),"\n",(0,r.jsxs)(n.p,{children:["现在就让我们开始吧。这次我们基于的是",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309115864737611827#heading-7",target:"_blank",rel:"noopener noreferrer",children:"《源码篇 | RSC 实现原理》"}),"的实现，此时刚实现 RSC Server 和 SSR Server 的拆分。如果没有实现之前的代码，可以运行："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"# 70.源码篇 _ 实现客户端组件\ngit clone -b react-rsc-9 git@github.com:mqyqingfeng/next-app-demo.git\n# 进入目录并安装依赖项\ncd next-app-demo && npm i\n# 启动\nnpm start\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"实现思路",children:["实现思路",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现思路",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"该怎么实现客户端组件呢？其实实现思路是比较简单的："}),"\n",(0,r.jsxs)(n.p,{children:["编译代码的时候，如果遇到以 ",(0,r.jsx)(n.code,{children:"'use client'"}),"为开头的组件，说明是客户端组件，使用特殊的占位符替代。比如以目前的 JSX 对象实现方式为例的话，可以替换为 "," 这样的节点。表明该位置是客户端组件占位，指向的客户端组件是 ",(0,r.jsx)(n.code,{children:"<Like>"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"然后将客户端组件编译为单独的 JS 代码。在客户端加载的时候，遍历所有的客户端组件占位，加载对应的 JS 代码，为每个组件单独进行渲染水合。"}),"\n",(0,r.jsxs)(n.h2,{id:"step1客户端组件编译",children:["Step1：客户端组件编译",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step1客户端组件编译",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"client.js"}),"，添加代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React from \'react\'\nimport { readFile, writeFile } from "fs/promises"\nimport path from "path"\n\nexport async function renderJSXToClientJSX(jsx) {\n  if (\n    typeof jsx === "string" ||\n    typeof jsx === "number" ||\n    typeof jsx === "boolean" ||\n    jsx == null\n  ) {\n    return jsx;\n  } else if (Array.isArray(jsx)) {\n    return Promise.all(jsx.map((child) => renderJSXToClientJSX(child)));\n  } else if (jsx != null && typeof jsx === "object") {\n    if (jsx.$$typeof === Symbol.for("react.element")) {\n      if (typeof jsx.type === "string") {\n        return {\n          ...jsx,\n          props: await renderJSXToClientJSX(jsx.props),\n        };\n      } else if (typeof jsx.type === "function") {\n        const Component = jsx.type;\n        const props = jsx.props;\n        const isClientComponent = Component.toString().includes("use client")\n        if (isClientComponent) {\n          return await transformClientComponent(Component, props)\n        } else {\n          const returnedJsx = await Component(props)\n          return renderJSXToClientJSX(returnedJsx)\n        }\n      } else throw new Error("Not implemented.");\n    } else {\n      return Object.fromEntries(\n        await Promise.all(\n          Object.entries(jsx).map(async ([propName, value]) => [\n            propName,\n            await renderJSXToClientJSX(value),\n          ])\n        )\n      );\n    }\n  } else throw new Error("Not implemented");\n}\n\nasync function transformClientComponent(Component, props) {\n\n  const raw = Component.toString()\n  const children = await renderJSXToClientJSX(props.children)\n\n  const clientComponent = {\n    value: raw,\n    props: {\n      ...props,\n      "data-client": true,\n      "data-component": Component.name,\n      children,\n    },\n  }\n\n  await createClientComponentJS(clientComponent)\n\n  return React.createElement(\n    "div",\n    {\n      "data-client": true,\n      "data-component": Component.name\n    }\n  )\n}\n\nasync function createClientComponentJS(Component) {\n  const { props, value } = Component\n  const name = props["data-component"]\n  const filenameRaw = path.join(process.cwd(), "public", "client", name + ".js")\n  const filename = path.normalize(filenameRaw)\n  const fileContents = `import React from "react"\n      export const props = ${JSON.stringify(props)}\n      export const jsx = ${value.replaceAll(\'import_react.default\', \'React\')}`\n  try {\n    await writeFile(filename, fileContents)\n  } catch (err) {\n    console.log("error in writeComponentToDisk", err)\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，我们修改了 ",(0,r.jsx)(n.code,{children:"renderJSXToClientJSX"}),"函数，当函数组件代码包含 ",(0,r.jsx)(n.code,{children:'"use client"'})," 时，视为客户端组件，调用 ",(0,r.jsx)(n.code,{children:"transformClientComponent"})," 函数进行处理"]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"transformClientComponent"})," 中，我们首先会构建一个名为 ",(0,r.jsx)(n.code,{children:"clientComponent"})," 的客户端组件对象，然后将其传给 ",(0,r.jsx)(n.code,{children:"createClientComponentJS"})," 函数用于生成对应的客户端 JS。"]}),"\n",(0,r.jsx)(n.p,{children:"以这样一段客户端组件代码为例的话："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'  "use client";\n\nimport React from "react";\nfunction Like() {\n  const [likes, setLikes] = React.useState(100)\n  return <button onClick={() => {setLikes(likes + 1)}}>❤️ {likes}</button>;\n}\nexport default Like\n'})}),"\n",(0,r.jsx)(n.p,{children:"最终生成的 JS 代码大致如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React from "react"\nexport const props = {"data-client":true,"data-component":"Like"}\nexport const jsx = function Like(){const[likes,setLikes]=React.useState(100);return React.createElement("button",{onClick:()=>{setLikes(likes+1)}},"\\u2764\\uFE0F ",likes)}\n'})}),"\n",(0,r.jsx)(n.p,{children:"其中 jsx 对应组件的代码，props 对应组件的 props。"}),"\n",(0,r.jsxs)(n.p,{children:["因为我们将编译的 JS 代码放在了 ",(0,r.jsx)(n.code,{children:"public/client"}),"目录下，**所以别忘了新建 **",(0,r.jsx)(n.code,{children:"**public/client**"}),(0,r.jsx)(n.strong,{children:"目录"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"transformClientComponent"})," 中，最后我们会返回一个 ",(0,r.jsx)(n.code,{children:'React.createElement( "div", { "data-client": true, "data-component": Component.name})'}),"的 JSX 对象，它会被渲染为 ",(0,r.jsx)(n.code,{children:'<div data-client="client" data-component="Like">'}),"，用于客户端组件占位。"]}),"\n",(0,r.jsxs)(n.h2,{id:"step2添加客户端组件",children:["Step2：添加客户端组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step2添加客户端组件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在让我们添加一个客户端组件试试吧。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"components.tsx"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'import Like from "./Like";\n\nasync function Post({ slug }) {\n  let content = await readFile("./posts/" + slug + ".txt", "utf8");\n  return (\n    <section>\n      <a className="text-blue-600" href={"/" + slug}>{slug}</a>\n      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{content}</article>\n      <Like />\n    </section>\n  )\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"Like.tsx"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React from "react";\n\nfunction Like() {\n  "use client";\n\n  const [likes, setLikes] = React.useState(100)\n  \n  return <button onClick={() => {setLikes(likes + 1)}}>❤️ {likes}</button>;\n}\n\nexport default Like\n'})}),"\n",(0,r.jsx)(n.p,{children:"代码看起来有些奇怪，其实也是迫不得已才这样写的。"}),"\n",(0,r.jsxs)(n.p,{children:["因为我们用的是 tsx 进行的编译，当调用 renderJSXToClientJSX 的时候，获取不到顶部的 ",(0,r.jsx)(n.code,{children:"use client"}),"指令，所以为了区分客户端组件，我们就“委曲求全”的写在了组件内部。"]}),"\n",(0,r.jsxs)(n.h2,{id:"step3客户端处理",children:["Step3：客户端处理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step3客户端处理",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"client.js"}),"，添加代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React from "react"\nimport { hydrateRoot, createRoot } from \'react-dom/client\';\n\nconst clientComponents = document.querySelectorAll("[data-client=true]")\n\nfor (const clientComponent of clientComponents) {\n  const componentName = clientComponent.getAttribute("data-component")\n  const ClientComponent = await import("./client/" + `${componentName}.js`)\n  const { jsx, props } = ClientComponent\n\n  const clientComponentJSX = React.createElement(jsx, props)\n  clientComponent.setAttribute("data-loading", false)\n\n  const clientComponentRoot = createRoot(clientComponent)\n  clientComponentRoot.render(clientComponentJSX)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"实现的效果就是遍历所有的客户端组件占位，根据其 data-component 属性，加载对应的 JS 文件，然后在客户端进行渲染水合。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"server/ssr.ts"}),"，将 publick 设为静态目录，顺便修正 2 处细节问题："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// 1. 添加 public 静态目录\napp.use(express.static(\'public\'))\n\napp.get("/:route(*)", async (req, res) => {\n\n  // 2. 处理 favicon.ico 文件，防止报错\n  if (url.pathname === \'/favicon.ico\') {\n    return\n  }\n\n  // 3. 拼接 HTML 这里修改了 react 导入的地址，加了一个 dev 参数\n    html += `\n      <script type="importmap">\n        {\n          "imports": {\n            "react": "https://esm.sh/react@18.2.0?dev",\n            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"\n          }\n        }\n      <\/script>\n      <script type="module" src="/client.js"><\/script>\n    `;\n  }\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["此时运行 ",(0,r.jsx)(n.code,{children:"npm start"}),"，刷新页面，",(0,r.jsx)(n.code,{children:"public/client"}),"下会导出 ",(0,r.jsx)(n.code,{children:"Like.js"}),"，浏览器交互效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"react-rsc-18.gif"})}),"\n",(0,r.jsx)(n.p,{children:"此时我们就实现了客户端组件。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"功能实现：客户端组件"}),"\n",(0,r.jsxs)(n.li,{children:["源码地址：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-12",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-12"})]}),"\n",(0,r.jsxs)(n.li,{children:["下载代码：",(0,r.jsx)(n.code,{children:"git clone -b react-rsc-12 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"其实我们实现的客户端组件非常“脆弱”，页面刷新的时候会有，导航的时候就没有了……所以还有很多要处理的地方，但个人能力有限，只能借这个简单的实现帮助大家理解客户端组件的实现。"}),"\n",(0,r.jsxs)(n.p,{children:["在 Next.js 中的实现，客户端组件其实是会被预渲染的，而我们是直接替换为一个 ",(0,r.jsx)(n.code,{children:'<div data-client="client" data-component="Like">'}),"DOM 节点。因为 DOM 节点无内容，所以我们直接用了 createRoot，更贴合的实现应该用 hyrateRoot。"]}),"\n",(0,r.jsx)(n.p,{children:"此外，Next.js 是在 RSC Payload 中显示要加载的客户端 JS，客户端收到 RSC Payload 后，加载对应的 JS 代码再进行水合，而我们是简单粗暴的遍历节点加载对应的 JS。"}),"\n",(0,r.jsx)(n.p,{children:"Next.js 的客户端组件，你可以简单粗暴的理解为“SSR + 水合 + CSR”，在服务端进行预渲染即 SSR，在客户端进行水合，添加事件，最后在客户端进行更新即 CSR。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}let a=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F70.%E6%BA%90%E7%A0%81%E7%AF%87%20_%20%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%84%E4%BB%B6.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"实现思路",id:"实现思路",depth:2},{text:"Step1：客户端组件编译",id:"step1客户端组件编译",depth:2},{text:"Step2：添加客户端组件",id:"step2添加客户端组件",depth:2},{text:"Step3：客户端处理",id:"step3客户端处理",depth:2},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);