"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["43209"],{35019:function(e,n,s){s.r(n),s.d(n,{default:()=>h});var r=s(552676),l=s(740453);let d=s.p+"static/image/fa31bd81c0b65c22130acefa5390d0b6.ee0da389.webp",i=s.p+"static/image/15a726a92aa85f682f73825950f302c4.3a4ac873.webp",t=s.p+"static/image/01ba65fa83cca03c518ff59e49326929.b0ba4230.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",code:"code",strong:"strong",pre:"pre",h3:"h3",img:"img",h4:"h4",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,l.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"26实践篇-表单验证上",children:["26.实践篇-表单验证上",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26实践篇-表单验证上",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"验证表单的设计，一直是比较复杂棘手的问题，难点在于对表单数据层的管理，以及把状态分配给每一个表单单元项。本章节来实现一套表单验证系统，通过本章节的学习，读者能够掌握以下知识点："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"表单控件组件设计。"}),"\n",(0,r.jsx)(n.li,{children:"建立表单状态管理，状态分发，表单验证。"}),"\n",(0,r.jsxs)(n.li,{children:["自定义 hooks —— ",(0,r.jsx)(n.code,{children:"useForm"})," 编写。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Form"})," ，",(0,r.jsx)(n.code,{children:"FormItem"})," 如何建立关联，协调\b管理表单状态。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"由于表单验证章节内容过多，分为上下两个章节来介绍。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["本章节主要介绍表单系统的设计思路和表单状态管理 ",(0,r.jsx)(n.code,{children:"FormStore"})," 的实现。"]}),"\n",(0,r.jsx)(n.li,{children:"下章节将介绍 Form 和 FormItem 的编写，以及功能验证。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"二-设计思路",children:["二 设计思路",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-设计思路",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["可能开发者平时使用验证表单控件感觉挺便携方便的，那是因为在整个表单内部，已经为开发者做了大部分的‘脏活’，‘累活’，一个完整验证表单体系实际是很复杂的，整个流程可以分为，",(0,r.jsx)(n.strong,{children:"状态收集"})," ，",(0,r.jsx)(n.strong,{children:"状态管理"})," ，",(0,r.jsx)(n.strong,{children:"状态验证"})," ， ",(0,r.jsx)(n.strong,{children:"状态下发"})," ，等诸多环节，所以在开发一套受宠于大众的表单控件，首先每一个环节设计是蛮重要的。接下来首先介绍一下，如何设计一套表单系统。"]}),"\n",(0,r.jsxs)(n.p,{children:["在设计之前，拿 antd 为例子，看一下一个基本的表单长什么样子 （ 可以称之为 ",(0,r.jsx)(n.code,{children:"Demo1"})," ） ："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'<Form  onFinish={onFinish} >\n   <FormItem name="name"  label="小册名称" >\n       <Input />\n   </FormItem>\n    <FormItem name="author"  label="小册作者" >\n       <Input />\n   </FormItem>\n   <Button htmlType="submit" >确定</Button>\n</Form>\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"1-表单组件层模型设计",children:["1 表单组件层模型设计",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-表单组件层模型设计",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如上，一套表单系统分为 Form ，FormItem ，表单控件三部分构成，下面一一介绍三个部分作用以及应该如何设计。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Form"})," 组件定位以及设计原则："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"状态保存"}),"： ",(0,r.jsx)(n.code,{children:"Form"})," 的作用，管理整个表单的状态，这个状态包括具体表单控件的 value，以及获取表单，提交表单，重置表单，验证表单等方法。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"状态下发"}),"： ",(0,r.jsx)(n.code,{children:"Form"})," 不仅仅要管理状态，而且还要下发传递这些状态。把这些状态下发给每一个 FormItem ，由于考虑到 Form 和 FormItem 有可能深层次的嵌套，所以选择通过 React context 保存下发状态最佳。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"保存原生 form 功能"})," ： ",(0,r.jsx)(n.code,{children:"Form"})," 满足上述两点功能之外，还要和原生的 form 的功能保持一致性。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"FormItem"}),"组件定位以及设计原则："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"状态收集"}),"： 首先很重要的一点，就是收集表单的状态，传递给 Form 组件，比如属性名，属性值，校验规则等。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"控制表单组件"}),"：还有一个功能就是，将 ",(0,r.jsx)(n.code,{children:"FormItem"})," 包裹的组件，变成受控的，一方面能够自由传递值 value 给表单控件，另一方面，能够劫持表单控件的 change 事件，得到最新的 value ，上传状态。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"提供Label和验证结果的 UI 层"})," ： ",(0,r.jsx)(n.code,{children:"FormItem"})," 还有一个作用就是要提供表单单元项的标签 label ，如果校验不通过的情况下，需要展示错误信息 UI 样式。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"表单控件设计（比如 Input ，Select 等）："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"首先表单控件一定是与上述整个表单验证系统零耦合的，也就是说 Input 等控件脱离整个表单验证系统，可以独立使用。"}),"\n",(0,r.jsxs)(n.li,{children:["在表单验证系统中，表单控件，不需要自己绑定事件，统一托管于 ",(0,r.jsx)(n.code,{children:"FormItem"})," 处理。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"三者关系如下图所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"1.jpg"})}),"\n",(0,r.jsxs)(n.h3,{id:"2-状态管理层设计",children:["2 状态管理层设计",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-状态管理层设计",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"如何设计表单的状态层",children:["如何设计表单的状态层？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何设计表单的状态层",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"保存信息："})," 首先最直接的是，需要保存表单的属性名 ",(0,r.jsx)(n.code,{children:"name"})," ，和当前的属性值 ",(0,r.jsx)(n.code,{children:"value"})," ，除此之外还要保存当前表单的验证规则 ",(0,r.jsx)(n.code,{children:"rule"})," ，验证的提示文案 ",(0,r.jsx)(n.code,{children:"message"})," ，以及验证状态 ",(0,r.jsx)(n.code,{children:"status"}),"。\n我这里收到 ",(0,r.jsx)(n.code,{children:"Promise"})," 的启发，引用了三种状态："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"resolve -> 成功状态，当表单验证成功之后，就会给 resolve 成功状态标签。"}),"\n",(0,r.jsx)(n.li,{children:"reject -> 失败状态，表单验证失败，就会给  reject 失败状态标签。"}),"\n",(0,r.jsx)(n.li,{children:"pendding -> 待验证状态，初始化，或者重新赋予表单新的值，就会给 pendding 待验证标签。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"数据结构："})}),"\n",(0,r.jsx)(n.p,{children:"上面介绍了表单状态层保存的信息。接下来用什么数据结构保留这些信息。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/*  \n    TODO: 数据结构\n    model = {\n       [name] ->  validate  = {\n           value     -> 表单值    (可以重新设定)\n           rule      -> 验证规则  ( 可以重新设定)\n           required  -> 是否必添 -> 在含有 rule 的情况下默认为 true\n           message   -> 提示消息\n           status    -> 验证状态  resolve -> 成功状态 ｜reject -> 失败状态 ｜ pending -> 待验证状态 |\n       }\n   }\n*/\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"model"})," 为整个 Form 表单的数据层结构。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"name"})," 为键，对应 FormItem 的每一个 name 属性，"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"validate"})," 为 name 属性对应的值，保存当前的表单信息，包括上面说到那几个重要信息。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["打个比方：上述 ",(0,r.jsx)(n.code,{children:"Demo1"})," 中，最后存在 form 的数据结构如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"model = {\n    name :{ /* 小册名称 formItem */\n        value: ...\n        rule:...\n        required:...\n        message:...\n        status:...\n    },\n    author:{ /* 小册作者 formItem */\n        value: ...\n        rule:...\n        required:...\n        message:...\n        status:...\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"表单状态层保存在哪里",children:["表单状态层保存在哪里？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#表单状态层保存在哪里",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面说到了整个表单的状态层，那么状态层保存在哪里呢 ？"}),"\n",(0,r.jsxs)(n.p,{children:["状态层最佳选择就是保存在 Form 内部，可以通过 ",(0,r.jsx)(n.code,{children:"useForm"})," 一个自定义 hooks 来维护和管理表单状态实例 ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"FormStore"})})," 。"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-数据通信层设计",children:["3 数据通信层设计",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-数据通信层设计",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["整个表单系统数据通信，还是从",(0,r.jsx)(n.strong,{children:"改变状态"}),"，",(0,r.jsx)(n.strong,{children:"触发校验"}),"两个方向入手。"]}),"\n",(0,r.jsxs)(n.h4,{id:"改变状态",children:["改变状态",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#改变状态",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["当系统中一个控件比如 ",(0,r.jsx)(n.code,{children:"Input"})," 值改变的时候，①可以是触发了 ",(0,r.jsx)(n.code,{children:"onChange"})," 方法，首先由于 ",(0,r.jsx)(n.code,{children:"FormItem"})," 控制表单控件，所以 FormItem 会最先感知到最新的 value ，②并通知给 Form 中的表单管理 ",(0,r.jsx)(n.code,{children:"FormStore"})," ， ③ ",(0,r.jsx)(n.code,{children:"FormStore"})," 会更新状态，④ 然后把最新状态下发到对应的 ",(0,r.jsx)(n.code,{children:"FormItem"})," ，⑤",(0,r.jsx)(n.code,{children:"FormItem"})," 接收到任务，再让  Input 更新最新的值，视觉感受 Input 框会发生变化 ，完成受控组件状态改变流程。"]}),"\n",(0,r.jsxs)(n.p,{children:["比如触发上述 ",(0,r.jsx)(n.code,{children:"Demo1"})," 中 name 对应的 Input，内部流程图如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"2.jpg"})}),"\n",(0,r.jsxs)(n.h4,{id:"表单校验",children:["表单校验",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#表单校验",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"表单校验有两种情况："}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第一种："})," 可能是给 FormItem 绑定的校验事件触发，比如 onBlur 事件触发 ，而引起的对单一表单的校验。流程和上述改变状态相同类似。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第二种："})," 有可能是提交事件触发，或者手动触发校验事件，引起的整个表单的校验。流程首先触发 submit 事件，①然后通知给 Form 中 ",(0,r.jsx)(n.code,{children:"FormStore"}),"，② ",(0,r.jsx)(n.code,{children:"FormStore"})," 会对整个表单进行校验，③然后把每个表单的状态，异步并批量下发到每一个 FormItem ，④ FormItem 就可以展示验证结果。"]}),"\n",(0,r.jsxs)(n.p,{children:["比如触发 ",(0,r.jsx)(n.code,{children:"Demo1"})," 中的提交按钮，流程图："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"3.jpg"})}),"\n",(0,r.jsx)(n.p,{children:"整个表单验证系统的设计阶段，从几个角度介绍了系统设计，当然其中还有很多没有提及细节，会在实现环节详细讲解，接下来就是具体功能的实现环节。"}),"\n",(0,r.jsxs)(n.h2,{id:"三-formstore-表单状态管理",children:["三 FormStore 表单状态管理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-formstore-表单状态管理",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"FormStore"})," 是整个表单验证系统最核心的功能了，里面包括保存的表单状态 model， 以及管理这些状态的方法，这些方法有的是对外暴露的，开发者可以通过调用这些对外的 api 实现",(0,r.jsx)(n.strong,{children:"提交表单"}),"，",(0,r.jsx)(n.strong,{children:"校验表单"})," ， ",(0,r.jsx)(n.strong,{children:"重置表单"})," 等功能。 参考和对标 ",(0,r.jsx)(n.code,{children:"antd"})," 本质上是 ",(0,r.jsx)(n.code,{children:"rc-form"}),"， 罗列的方法如下。"]}),"\n",(0,r.jsxs)(n.h3,{id:"formstore-实例对外接口",children:["FormStore 实例对外接口",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#formstore-实例对外接口",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"以下接口提供给开发者使用。"})}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{children:"对外接口名称"}),"\n",(0,r.jsx)(n.th,{children:"作用"}),"\n",(0,r.jsx)(n.th,{children:"参数说明"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"submit"}),"\n",(0,r.jsx)(n.td,{children:"提交表单"}),"\n",(0,r.jsxs)(n.td,{children:["一个参数 cb，校验完表单执行，通过校验 cb 的参数为表单数据层，未通过校验 cb 参数为 ",(0,r.jsx)(n.code,{children:"false"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"resetFields"}),"\n",(0,r.jsx)(n.td,{children:"重置表单"}),"\n",(0,r.jsx)(n.td,{children:"无参数"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"setFields"}),"\n",(0,r.jsx)(n.td,{children:"设置一组表单值"}),"\n",(0,r.jsxs)(n.td,{children:["一个参数为 object， key ——为表单名称，value ——表单项，可以是值，校验规则，校验文案 ，例如 ",(0,r.jsx)(n.code,{children:" setFields({ name: { value : '《React进阶实践指南》' , author:'我不是外星人' } ,  })"}),"  或者  ",(0,r.jsx)(n.code,{children:"setFields({ name:'《React进阶实践指南》', author:'我不是外星人'  })"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"setFieldsValue"}),"\n",(0,r.jsx)(n.td,{children:"设置单一表单值"}),"\n",(0,r.jsxs)(n.td,{children:["二个参数，第一个参数为 name 表单项名称，第二个参数 value ，设置表单的值 ， 例如 ",(0,r.jsx)(n.code,{children:"setFieldsValue('author','我不是外星人')"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getFieldValue"}),"\n",(0,r.jsx)(n.td,{children:"获取对应字段名的值"}),"\n",(0,r.jsxs)(n.td,{children:["一个参数，对应的表单项名称，例如 ",(0,r.jsx)(n.code,{children:"getFieldValue('name')"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"getFieldsValue"}),"\n",(0,r.jsx)(n.td,{children:"获取整个表单的value"}),"\n",(0,r.jsx)(n.td,{children:"无参数"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"validateFields"}),"\n",(0,r.jsx)(n.td,{children:"验证整个表单层"}),"\n",(0,r.jsx)(n.td,{children:"一个参数，回调函数，回调函数，参数为验证结果，"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"以下接口提供给 Form 和 FormItem 使用。"})}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{children:"接口名称"}),"\n",(0,r.jsx)(n.th,{children:"作用"}),"\n",(0,r.jsx)(n.th,{children:"参数说明"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"setCallback"}),"\n",(0,r.jsxs)(n.td,{children:["注册绑定在 Form 上的事件 ， 比如 ",(0,r.jsx)(n.code,{children:"onFinish"})," ｜ ",(0,r.jsx)(n.code,{children:"onFinishFailed"})]}),"\n",(0,r.jsx)(n.td,{children:"一个参数，为一个对象，存放需要注册的事件。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"dispatch"}),"\n",(0,r.jsx)(n.td,{children:"可以通过 dispatch 调用 FormStore 内部的方法"}),"\n",(0,r.jsx)(n.td,{children:"第一个参数是一个对象，里面 type 为调用的方法，其余参数依次为调用方法的参数。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"registerValidateFields"}),"\n",(0,r.jsx)(n.td,{children:"FormItem 注册表单单元项"}),"\n",(0,r.jsx)(n.td,{children:"三个参数，第一个参数单元项名称，第二个参数为，FormItem 的控制器，可以让 FormItem 触发更新，第三个参数，为注册的内容，比如 rule，message 等"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"unRegisterValidate"}),"\n",(0,r.jsx)(n.td,{children:"解绑注册的表单单元项"}),"\n",(0,r.jsx)(n.td,{children:"一个参数，表单单元项名称"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"重要属性",children:["重要属性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重要属性",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上述介绍了需要完成的对外接口，接下来介绍一下 FormStore 保存的重要属性。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"model"})," ： 首先 model 为整个表单状态层的核心，绑定单元项的内容都存在 model 中，上述已经介绍了。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"control"})," ：control 存放了每一个 FormItem 的更新函数，因为表单状态改变，Form 需要把状态下发到每一个需要更新的 FormItem 上。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"callback"}),"： callback 存放表单状态改变的监听函数。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"penddingValidateQueue"}),"：由于表单验证状态的下发是采用异步的，显示验证状态的更新，"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"代码实现",children:["代码实现",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来就是具体的代码实现和流程分析。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/* 对外接口  */\nconst formInstanceApi = [\n    'setCallback',\n    'dispatch',\n    'registerValidateFields',\n    'resetFields',\n    'setFields',\n    'setFieldsValue',\n    'getFieldsValue',\n    'getFieldValue',\n    'validateFields',\n    'submit',\n    'unRegisterValidate'\n]\n\n/* 判断是否是正则表达式 */\nconst isReg = (value) => value instanceof RegExp\nclass FormStore{\n    constructor(forceUpdate,defaultFormValue={}){\n        this.FormUpdate = forceUpdate     /* 为 Form 的更新函数，目前没有用到 */\n        this.model = {}                   /* 表单状态层 */\n        this.control = {}                 /* 控制每个 formItem 的控制器  */\n        this.isSchedule = false           /* 开启调度 */\n        this.callback = {}                /* 存放监听函数 callback */\n        this.penddingValidateQueue = []   /* 批量更新队列 */\n        this.defaultFormValue = defaultFormValue /* 表单初始化的值 */\n    }\n    /* 提供操作form的方法 */\n    getForm(){\n        return formInstanceApi.reduce((map,item) => {\n            map[item] = this[item].bind(this)\n            return map\n        } ,{})\n    }\n    /* 创建一个验证模块 */\n    static createValidate(validate){\n        const { value, rule, required, message } = validate\n        return {\n            value,\n            rule: rule || (() => true),\n            required: required || false,\n            message: message || '',\n            status:'pending'\n        }\n\n    }\n    /* 处理回调函数 */\n    setCallback(callback){\n        if(callback) this.callback = callback\n    }\n    /* 触发事件 */\n    dispatch(action,...arg){\n        if(!action && typeof action !== 'object') return null\n       const { type } = action\n       if(~formInstanceApi.indexOf(type)){\n           return this[type](...arg)\n       }else if(typeof this[type] === 'function'   ){\n        return this[type](...arg)\n       }\n    }\n    /* 注册表单单元项 */\n    registerValidateFields(name,control,model){\n       if(this.defaultFormValue[name]) model.value = this.defaultFormValue[name] /* 如果存在默认值的情况 */\n       const validate = FormStore.createValidate(model)\n       this.model[name] = validate\n       this.control[name] = control\n    }\n    /* 卸载注册表单单元项 */\n    unRegisterValidate(name){\n       delete this.model[name]\n       delete this.control[name]\n    }\n    /* 通知对应FormItem更新 */\n    notifyChange(name){\n        const controller = this.control[name]\n        if(controller) controller?.changeValue()\n    }\n    /* 重置表单 */\n    resetFields(){\n        Object.keys(this.model).forEach(modelName => {\n             this.setValueClearStatus(this.model[modelName],modelName,null)\n        })\n    }\n    /* 设置一组字段状态	  */\n    setFields(object){\n        if( typeof object !== 'object' ) return\n        Object.keys(object).forEach(modelName=>{\n            this.setFieldsValue(modelName,object[modelName])\n        })\n    }\n    /* 设置表单值 */\n    setFieldsValue(name,modelValue){\n      const model = this.model[name]\n       if(!model) return false\n       if(typeof modelValue === 'object' ){ /* 设置表单项 */\n           const { message ,rule , value  } = modelValue\n           if(message) model.message = message\n           if(rule)    model.rule = rule\n           if(value)   model.value = value\n           model.status = 'pending'              /* 设置待验证状态 */\n           this.validateFieldValue(name,true)     /* 如果重新设置了验证规则，那么重新验证一次 */\n       }else {\n           this.setValueClearStatus(model,name,modelValue)\n       }\n    }\n    /* 复制并清空状态 */\n    setValueClearStatus(model,name,value){\n        model.value = value\n        model.status = 'pending'\n        this.notifyChange(name)\n    }\n  \n    /* 获取表单数据层的值 */\n    getFieldsValue(){\n       const formData = {}\n       Object.keys(this.model).forEach(modelName=>{\n           formData[modelName] = this.model[modelName].value\n       })\n       return formData\n    }\n    /* 获取表单模型 */\n    getFieldModel(name){\n        const model =  this.model[name]\n        return model ? model : {}\n    }\n    /* 获取对应字段名的值 */\n    getFieldValue(name){\n        const model =  this.model[name]\n        if(!model && this.defaultFormValue[name]) return this.defaultFormValue[name] /* 没有注册，但是存在默认值的情况 */\n        return model ? model.value : null\n    }\n    /* 单一表单单元项验证 */\n    validateFieldValue(name,forceUpdate = false){\n        const model = this.model[name]\n        /* 记录上次状态 */\n        const lastStatus =  model.status\n        if(!model) return null\n        const { required, rule , value } = model\n        let status = 'resolve'\n        if(required && !value ){\n            status = 'reject'\n        }\n        else if(isReg(rule)){     /* 正则校验规则 */\n            status = rule.test(value) ? 'resolve' : 'reject'\n        }else if(typeof rule === 'function'){ /* 自定义校验规则 */\n            status = rule(value) ? 'resolve' : 'reject'\n        }\n        model.status = status\n        if(lastStatus !==  status || forceUpdate ){\n           const notify = this.notifyChange.bind(this,name)\n           this.penddingValidateQueue.push( notify )\n        }\n        this.scheduleValidate()\n        return status\n    }\n    /* 批量调度验证更新任务 */\n    scheduleValidate(){\n       if(this.isSchedule) return\n       this.isSchedule = true\n       Promise.resolve().then(()=>{\n           /* 批量更新验证任务 */\n          unstable_batchedUpdates(()=>{\n              do{\n                let notify = this.penddingValidateQueue.shift()\n                notify && notify()  /* 触发更新 */\n              }while(this.penddingValidateQueue.length > 0)\n              this.isSchedule = false\n          })\n       })\n    }\n    /* 表单整体验证 */\n    validateFields(callback){\n       let status = true\n       Object.keys(this.model).forEach(modelName=>{\n           const modelStates = this.validateFieldValue(modelName,true)\n           if(modelStates==='reject') status = false\n       })\n       callback(status)\n    }\n    /* 提交表单 */\n    submit(cb){\n        this.validateFields((res)=>{\n            const { onFinish, onFinishFailed} = this.callback\n            cb && cb(res)\n            if(!res) onFinishFailed && typeof onFinishFailed === 'function' && onFinishFailed() /* 验证失败 */\n            onFinish && typeof onFinish === 'function' && onFinish( this.getFieldsValue() )     /* 验证成功 */\n        })\n    }\n\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"流程分析："})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"初始化流程"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"constructor"})," ，FormStore 通过 new 方式实例化。实例化过程中会绑定 ",(0,r.jsx)(n.code,{children:"model"})," ， ",(0,r.jsx)(n.code,{children:"control"})," 等属性。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"getForm"}),"： 这里思考一下问题，就是需不需要把整个 FormStore 全部向 Form 组件暴露出去，答案是肯定不能这么做，因为如果 FormStore 整个实例暴露出去，就可以获取内部的状态 model 和 control 等重要模块，如果篡改模块下的内容，那么后果无法想象的，所以对外提供的只是改变表单状态的接口。通过 getForm 把重要的 API 暴露出去就好。getForm 通过数组 reduce 把对外注册的接口数组 formInstanceApi 一一绑定 this 然后形成一个对象，传递给 form 组件。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"setCallback"})," ： 这个函数做的事情很简单，就是注册 callback 事件。在表单的一些重要阶段，比如提交成功，提交失败的时候，执行这些回调函数。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"表单注册流程"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"static createValidate"}),"： 静态方法——创建一个验证 Validate ，也就是 model 下的每一个模块，主要在注册表单单元项的时候使用。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"registerValidateFields"})," ：注册表单单元项，这个在 FormItem 初始化时候调用，把验证信息，验证文案，等信息，通过 \xb7",(0,r.jsx)(n.code,{children:"createValidate"})," 注册到 model 中， 把 FormItem 的更新函数注册到 control 中。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"unRegisterValidate"}),"：在 FormItem 的生命周期销毁阶段执行，解绑上面 ",(0,r.jsx)(n.code,{children:"registerValidateFields"})," 注册的内容。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"表单状态设置，获取，重置"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"notifyChange"}),"：每当给表单单元项 FormItem 重新赋值的时候，就会执行当前 FormItem 的更新函数，派发视图更新。（这里可以提前透露一下，control 存放的就是每个 FormItem 组件的 ",(0,r.jsx)(n.code,{children:"useState"})," 方法 ）"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"setValueClearStatus"}),"： 重新设置表单值，并重置待验证状态 ",(0,r.jsx)(n.code,{children:"pendding"}),"，然后触发 notifyChange 促使 FormItem 更新。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"setFieldsValue"}),"：设置一个表单值， 如果重新设置了验证规则，那么重新验证一次，如果只是设置了表单项的值，调用 setValueClearStatus 更新。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"setFields"}),"： 设置一组表单值，本质上对每一个单元项触发 setFieldsValue。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"getFieldValue"}),"：获取表单值，本质上就是获取 model 下每一个模块的 value 值。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"getFieldsValue"}),"：获取整个表单的数据层（分别获取每一个模块下的 value ）。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"getFieldModel"}),"：获取表单的模型，这个 api 设计为了让 UI 显示验证成功或者失败的状态，以及提示的文案。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"resetFields"}),"：本质上就是调用 ",(0,r.jsx)(n.code,{children:"setValueClearStatus"})," 重新设置每一个表单单元项的状态。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"表单验证"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"validateFieldValue"}),"：验证表单的单元项，通过判断规则，如果规则是正则表达式那么触发正则 test 方法，如果是自定义规则，那么执行函数，返回值布尔值判断是否通过校验。如果状态改变，把当前更新任务放在 ",(0,r.jsx)(n.code,{children:"penddingValidateQueue"})," 待验证队列中。",(0,r.jsx)(n.strong,{children:"为什么采用异步校验更新呢？"})," 首先验证状态改变，带来的视图更新，不是那么重要，可以先执行更高优先级的任务，还有一点就是整个验证功能，有可能在异步情况下，表单会有多个表单单元项，如果直接执行更新任务，可能会让表单更新多次，所以放入",(0,r.jsx)(n.code,{children:"penddingValidateQueue"})," 在配合 ",(0,r.jsx)(n.code,{children:"unstable_batchedUpdates"}),"批量更新，统一更新这些状态。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"scheduleValidate"}),"：scheduleValidate 执行会开启 ",(0,r.jsx)(n.code,{children:"isSchedule = true"}),"开关，如果有多个验证任务，都会放入 ",(0,r.jsx)(n.code,{children:"penddingValidateQueue"})," ，最后统一执行一次任务处理逻辑。调用 ",(0,r.jsx)(n.code,{children:"Promise.resolve()"}),"和 ",(0,r.jsx)(n.code,{children:"unstable_batchedUpdates"})," 异步批量更新 ，批量更新完毕，关闭开关 ",(0,r.jsx)(n.code,{children:"this.isSchedule = false"})," 。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"validateFields"}),"： validateFields 会对每一个表单单元项触发 validateFieldValue ，然后执行回调函数，回调函数参数，代表验证是否通过，如果有一个验证不通过，那么整体就不通过验证。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"submit"}),"：submit 本质就是调用 ",(0,r.jsx)(n.code,{children:"validateFields"})," 验证这个表单，然后在 validateFields 回调函数中，触发对应的监听方法 ",(0,r.jsx)(n.code,{children:"callback"})," ， 成功触发 ",(0,r.jsx)(n.code,{children:"onFinish"}),"， 失败调用 ",(0,r.jsx)(n.code,{children:"onFinishFailed"})," ，这些方法都是绑定在 Form 的回调函数。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"四-useform-表单状态管理-hooks-设计",children:["四 useForm 表单状态管理 hooks 设计",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-useform-表单状态管理-hooks-设计",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上面的 ",(0,r.jsx)(n.code,{children:"FormStore"})," 就是通过自定义 hooks —— ",(0,r.jsx)(n.code,{children:"useForm"})," 创建出来的。useForm 可以独立使用，创建一个 ",(0,r.jsx)(n.code,{children:"formInstance"})," ，然后作为 form 属性赋值给 Form 表单。 如果没有传递  默认会在 Form 里通过 ",(0,r.jsx)(n.code,{children:"useForm"})," 自动创建一个。（参考 antd，用法一致 ）。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"代码实现："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useForm(form,defaultFormValue = {}){\n   const formRef = React.useRef(null)\n   const [, forceUpdate] = React.useState({})\n   if(!formRef.current){\n      if(form){\n          formRef.current = form  /* 如果已经有 form，那么复用当前 form  */\n      }else { /* 没有 form 创建一个 form */\n        const formStoreCurrent = new FormStore(forceUpdate,defaultFormValue)\n        /* 获取实例方法 */\n        formRef.current = formStoreCurrent.getForm()\n      }\n   }\n   return formRef.current\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"useForm 的逻辑实际很简单："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"通过一个 useRef 来保存 FormStore 的重要 api。"}),"\n",(0,r.jsxs)(n.li,{children:["首先会判断有没有 form ，如果没有，会实例化 FormStore ，上面讲的 FormStore 终于用到了，然后会调用 ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"getForm"})})," ，把重要的 api 暴露出去。"]}),"\n",(0,r.jsx)(n.li,{children:"什么情况下有 form ，当开发者用 useForm 单独创建一个 FormStore 再赋值给 Form 组件的 form 属性，这个时候就会存在 form 了。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"五-总结",children:["五 总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章节主要学习内容如下："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"表单的设计思路与细节。"}),"\n",(0,r.jsx)(n.li,{children:"编写一个表单状态管理工具—— FormStore 。"}),"\n",(0,r.jsx)(n.li,{children:"编写一个自定义 hooks —— useForm 。"}),"\n",(0,r.jsx)(n.li,{children:"异步批量处理表单验证更新任务。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"下一章节，将继续完成表单的 Form 和 FormItem 组件。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let h=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F26.%E5%AE%9E%E8%B7%B5%E7%AF%87-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E4%B8%8A.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 设计思路",id:"二-设计思路",depth:2},{text:"1 表单组件层模型设计",id:"1-表单组件层模型设计",depth:3},{text:"2 状态管理层设计",id:"2-状态管理层设计",depth:3},{text:"如何设计表单的状态层？",id:"如何设计表单的状态层",depth:4},{text:"表单状态层保存在哪里？",id:"表单状态层保存在哪里",depth:4},{text:"3 数据通信层设计",id:"3-数据通信层设计",depth:3},{text:"改变状态",id:"改变状态",depth:4},{text:"表单校验",id:"表单校验",depth:4},{text:"三 FormStore 表单状态管理",id:"三-formstore-表单状态管理",depth:2},{text:"FormStore 实例对外接口",id:"formstore-实例对外接口",depth:3},{text:"重要属性",id:"重要属性",depth:3},{text:"代码实现",id:"代码实现",depth:3},{text:"四 useForm 表单状态管理 hooks 设计",id:"四-useform-表单状态管理-hooks-设计",depth:2},{text:"五 总结",id:"五-总结",depth:2}],title:"26.实践篇-表单验证上",headingTitle:"26.实践篇-表单验证上",frontmatter:{}}}}]);