"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19380"],{727502:function(e,s,n){n.r(s),n.d(s,{default:()=>m});var a=n(552676),i=n(740453);let r=n.p+"static/image/8a02ea7f9e4e58a413db68a84a57b963.7f91b5ce.webp",c=n.p+"static/image/4c4b78372b7a1db2a5049002d0bfae95.1cb7f2ec.webp",d=n.p+"static/image/e7b991f49e403b905fd13787ad2e7955.9cac407b.webp",h=n.p+"static/image/171eda9fa5847bba3c63492209ba75a4.84bdd04c.webp",x=n.p+"static/image/d2751453319f31eeef2af5bc5bc22f6a.4f03dd65.webp",l=n.p+"static/image/3ae7ced92239213df529c4c9bb1b6605.c65c9f20.webp",t=n.p+"static/image/ca13f68a585a826344a7c7debb0da6ec.3a535b25.webp",j=n.p+"static/image/0727fd6a5d2f626e6dfd1d86119cb27e.d0d50297.webp";function p(e){let s=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",img:"img",code:"code",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.h1,{id:"3http-缓存2卧虎藏龙网页由慢到快背后的强缓存",children:["3.HTTP 缓存2：卧虎藏龙——网页由慢到快背后的强缓存",(0,a.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#3http-缓存2卧虎藏龙网页由慢到快背后的强缓存",children:"#"})]}),"\n",(0,a.jsxs)(s.p,{children:["前面章节部分提到了很多次",(0,a.jsx)(s.strong,{children:"强缓存"}),"，但都从未真正意义上详细地介绍过它。这里笔者将花费一整节的内容来对强缓存进行一次单独的“采访”，继续加深读者对于强缓存的理解。"]}),"\n",(0,a.jsx)(s.p,{children:"还记得小册开篇提到的“第一次访问网站打开速度会有点慢，再次访问的时候就快了很多”这一现象吗？其背后主要还是强缓存在起作用。"}),"\n",(0,a.jsx)(s.p,{children:"接下来我们不妨通过现象看本质，从第一次访问某一网站开始。"}),"\n",(0,a.jsxs)(s.h2,{id:"由慢到快的过程",children:["由慢到快的过程",(0,a.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#由慢到快的过程",children:"#"})]}),"\n",(0,a.jsx)(s.p,{children:"这里，我们模拟第一次打开某宝首页（浏览器未有缓存资源），打开开发者工具我们可以看到资源的加载情况。"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)("img",{src:j,alt:"20210824215429.jpg"})}),"\n",(0,a.jsxs)(s.p,{children:["我们重点关注下 ",(0,a.jsx)(s.code,{children:"Size"})," 和 ",(0,a.jsx)(s.code,{children:"Time"})," 列的数据，Size 列表示浏览器从服务器获取资源的大小，Time 列表示资源加载耗时。因为几乎每一个资源都需要从服务器获取并加载，所以网页打开速度会受到影响，这里浏览器用了 ",(0,a.jsx)(s.strong,{children:"1.76s"})," 加载完了页面的所有资源（图片、脚本、样式等），1.1 MB 的数据被传输到了本地。"]}),"\n",(0,a.jsx)(s.p,{children:"那么从强缓存的角度来看，其实第一次访问网页时浏览器已经开始在背后进行强缓存的判断和处理，我们可以通过下方流程图一探究竟。"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)("img",{src:t,alt:"首次访问流程.png"})}),"\n",(0,a.jsxs)(s.p,{children:["图中，当浏览器发起 HTTP 请求时，会向浏览器缓存进行一次询问，若浏览器缓存没有该资源的缓存数据，那么浏览器便会向服务器发起请求，服务器接收请求后将资源返回给浏览器，浏览器会将资源的响应数据存储到浏览器缓存中，这便是",(0,a.jsx)(s.strong,{children:"强缓存的生成过程"}),"。"]}),"\n",(0,a.jsx)(s.p,{children:"接下来，聪明的读者应该已经猜到下面我们将第二次访问某宝，继续观察开发者工具中原来的几项指标。"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)("img",{src:l,alt:"20210825212127.jpg"})}),"\n",(0,a.jsxs)(s.p,{children:["我们发现 Size 一列大部分由原先的资源加载大小变成了 ",(0,a.jsx)(s.code,{children:"disk cache"}),"（",(0,a.jsx)(s.strong,{children:"磁盘缓存"}),"），而变成这一数据对应的 Time 列资源加载速度异常之快，加载总耗时由原来的 1.76s 变成了 ",(0,a.jsx)(s.strong,{children:"1.10s"}),"，而传输到本地的数据降到了 44.3 KB，",(0,a.jsx)(s.strong,{children:"加载速度提升了 37.5%"}),"（受网速影响该数据每次都不一样，只用做对比参考）。这便是强缓存生效导致的现象。"]}),"\n",(0,a.jsx)(s.p,{children:"强缓存的生效流程如下图所示："}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)("img",{src:x,alt:"强缓存生效流程.png"})}),"\n",(0,a.jsxs)(s.p,{children:["图中我们可以看到",(0,a.jsx)(s.strong,{children:"浏览器并没有和服务器进行交互"}),"，而是在发起请求时浏览器缓存告诉浏览器它那有该资源的缓存数据并且还没有过期，于是浏览器直接加载了缓存中的数据资源。就好比你要买牛奶，原本需要跑去生产厂商买，但是发现楼下的超市就有该厂商生产的牛奶并且没有过期，那你只需要花费跑一趟楼下的功夫就可以喝到新鲜的牛奶，大大缩短了你买牛奶的时间。"]}),"\n",(0,a.jsxs)(s.p,{children:["写到这里，大家是否会认为只有开发者工具中的 Size 值变成了 disk cache 才代表强缓存生效，也称为",(0,a.jsx)(s.strong,{children:"命中强缓存"}),"。其实不然，别忘了开篇提到除了 Disk cache，还有 ",(0,a.jsx)(s.code,{children:"Memory Cache"}),"（",(0,a.jsx)(s.strong,{children:"内存缓存"}),"）。这时候我们不关闭 Tab 页，重新刷新下某宝页面，再观察下 Network 面板中的变化。"]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)("img",{src:h,alt:"20210825225010.jpg"})}),"\n",(0,a.jsxs)(s.p,{children:["此时，开发者工具中的 Size 列大部分变成了 memory Cache，其对应的 Time 列变成了 ",(0,a.jsx)(s.strong,{children:"0ms"}),"。可见，",(0,a.jsx)(s.strong,{children:"memory Cache 比 disk cache 更快"}),"，快到不需要时间。加载总耗时缩短到了 766ms。"]}),"\n",(0,a.jsx)(s.p,{children:"按照缓存位置的读取顺序，相比 disk cache，浏览器会优先读取 memory Cache。通过对以上开发者工具图例的对比不难得出，读取磁盘缓存会存在稍许的耗时，而读取内存缓存是及时性的，不存在耗时。"}),"\n",(0,a.jsx)(s.p,{children:"由于 Disk cache 和 Memory Cache 这两者属于浏览器缓存的一部分，本章节不做详细的介绍，大家会在小册浏览器缓存部分与它们见面。"}),"\n",(0,a.jsxs)(s.h2,{id:"max-age-与-s-maxage",children:["max-age 与 s-maxage",(0,a.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#max-age-与-s-maxage",children:"#"})]}),"\n",(0,a.jsx)(s.p,{children:"我们继续来看一下那些被浏览器缓存的资源的特点，响应报头中都包含了与强缓存有关的首部字段：Expires 或 Cache-Control。"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)("img",{src:d,alt:"20210826212213.jpg"})}),"\n",(0,a.jsx)(s.p,{children:"按照上图所示报头的 Cache-Control 首部，根据上一章节介绍的知识点，此资源将被浏览器缓存 2592000 秒（即 30 天），30 天之内我们再次访问，该资源都将从浏览器缓存中读取，这不难理解。但是需要注意图中首部值还包括了 s-maxage=3600 秒，下面便到了划重点的时候："}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.strong,{children:"s-maxage 仅在代理服务器中生效"})}),"\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.strong,{children:"在代理服务器中 s-maxage 优先级高于 max-age，同时出现时 max-age 会被覆盖"})}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"理解完以上两点，我们再来看一下该资源其实是一个 CDN 资源，属于代理服务器资源，在其服务器中的缓存时间并不是 30 天，而是 3600 秒（1 个小时），所以当浏览器缓存 30 天之后重新向 CDN 服务器获取资源时，此时 CDN 缓存的资源也已经过期，会触发回源机制，即向源服务器发起请求更新缓存数据。"}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)("img",{src:c,alt:"客户端.png"})}),"\n",(0,a.jsx)(s.p,{children:"以上例子直接描述了 max-age 与 s-maxage 的联系和区别，相信大家多思考下便会轻车熟路。"}),"\n",(0,a.jsxs)(s.h2,{id:"expires-与-max-age",children:["expires 与 max-age",(0,a.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#expires-与-max-age",children:"#"})]}),"\n",(0,a.jsxs)(s.p,{children:["上篇介绍到 ",(0,a.jsx)(s.strong,{children:"Expires 设置的缓存过期时间是一个绝对时间，所以会受客户端时间的影响而变得不精准"}),"，这句话怎么理解？我们以下图为例来讲解："]}),"\n",(0,a.jsx)(s.p,{children:(0,a.jsx)("img",{src:r,alt:"20210827212431.jpg"})}),"\n",(0,a.jsx)(s.p,{children:"该资源是掘金首页加载的一张图片，已经被笔者浏览器缓存，其首部 expires 字段值表示浏览器可以将该资源缓存至 2022 年 8 月 27 日的上述时间点，那么在我们把图中 max-age 首部当做不存在的情况下（因为 max-age 会覆盖 expires 值），把电脑客户端时间修改为 2022 年 8 月 28 日，此时再次访问网页你会发现浏览器重新向服务器获取了该资源，原来的缓存失效了。这便解释了 expires “不精准”的概念。"}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"expires “不精准” 是因为它的值是一个绝对时间，而 max-age 与其相反却是一个相对时间"}),"，还是拿上图举例，由于 max-age 优先级更高，表示浏览器可以将该资源缓存 3153600 秒（365天），起始时间是从浏览器获取并缓存该资源的时间开始算起。那么此时我们修改电脑客户端时间为 1 年后，该缓存是否就不会失效了？"]}),"\n",(0,a.jsxs)(s.p,{children:["在此笔者先给出答案：",(0,a.jsx)(s.strong,{children:"缓存还是会失效"}),"。"]}),"\n",(0,a.jsx)(s.p,{children:"对于以上回答大家必然会产生不解，比如浏览器到底依据什么来判断缓存的有效期限？笔者会在下一章给出答案。"}),"\n",(0,a.jsxs)(s.h2,{id:"结语",children:["结语",(0,a.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#结语",children:"#"})]}),"\n",(0,a.jsxs)(s.p,{children:["本文从访问网页由慢到快的现象出发，从现象到本质揭示了网页背后的浏览器强缓存生成和生效的过程，至于针对强缓存关键首部字段的介绍，本文通过对比方式让大家产生思考并提升知识点的理解程度，最后通过",(0,a.jsx)(s.strong,{children:"不精准导致的资源失效问题"}),"为下文埋下伏笔。"]}),"\n",(0,a.jsx)(s.p,{children:"下文我们将继续探索强缓存背后的秘密，揭秘影响强缓存有效性的公式和原理。"})]})}function g(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,i.ah)(),e.components);return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}let m=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90%2F3.HTTP%20%E7%BC%93%E5%AD%982%EF%BC%9A%E5%8D%A7%E8%99%8E%E8%97%8F%E9%BE%99%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E7%94%B1%E6%85%A2%E5%88%B0%E5%BF%AB%E8%83%8C%E5%90%8E%E7%9A%84%E5%BC%BA%E7%BC%93%E5%AD%98.md"]={toc:[{text:"由慢到快的过程",id:"由慢到快的过程",depth:2},{text:"max-age 与 s-maxage",id:"max-age-与-s-maxage",depth:2},{text:"expires 与 max-age",id:"expires-与-max-age",depth:2},{text:"结语",id:"结语",depth:2}],title:"3.HTTP 缓存2：卧虎藏龙——网页由慢到快背后的强缓存",headingTitle:"3.HTTP 缓存2：卧虎藏龙——网页由慢到快背后的强缓存",frontmatter:{}}}}]);