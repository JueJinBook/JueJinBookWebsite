"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["1232"],{8056:function(e,n,r){e.exports=r.p+"static/image/0c9abc5e01e04297a74b822b61552b2f.9caa2f95.webp"},758289:function(e,n,r){e.exports=r.p+"static/image/4c83722f36df31afd109bcd4f73382ae.d8ebe1d2.webp"},439636:function(e,n,r){e.exports=r.p+"static/image/cacf208fd6fc8155c4478b5901230b79.71344aca.webp"},673830:function(e,n,r){e.exports=r.p+"static/image/d988498b2d7b1726243a3b1c25ea611a.46ea6461.webp"},797406:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var d=r(552676),i=r(740453),s=r(439636);let c=r.p+"static/image/92a571367cd4dba83a420df04121578a.9453b6b8.webp";var t=r(673830),a=r(8056),h=r(758289);function l(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",code:"code",strong:"strong",h3:"h3",pre:"pre"},(0,i.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"1vuejs-运行机制全局概览",children:["1.Vue.js 运行机制全局概览",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1vuejs-运行机制全局概览",children:"#"})]}),"\n",(0,d.jsxs)(n.h2,{id:"全局概览",children:["全局概览",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局概览",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"这一节笔者将为大家介绍一下 Vue.js 内部的整个流程，希望能让大家对全局有一个整体的印象，然后我们再来逐个模块进行讲解。从来没有了解过 Vue.js 实现的同学可能会对一些内容感到疑惑，这是很正常的，这一节的目的主要是为了让大家对整个流程有一个大概的认识，算是一个概览预备的过程，当把整本小册认真读完以后，再来阅读这一节，相信会有收获的。"}),"\n",(0,d.jsx)(n.p,{children:"首先我们来看一下笔者画的内部流程图。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:s,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"大家第一次看到这个图一定是一头雾水的，没有关系，我们来逐个讲一下这些模块的作用以及调用关系。相信讲完之后大家对Vue.js内部运行机制会有一个大概的认识。"}),"\n",(0,d.jsxs)(n.h2,{id:"初始化及挂载",children:["初始化及挂载",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化及挂载",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:h,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["在 ",(0,d.jsx)(n.code,{children:"new Vue()"})," 之后。 Vue 会调用 ",(0,d.jsx)(n.code,{children:"_init"})," 函数进行初始化，也就是这里的 ",(0,d.jsx)(n.code,{children:"init"})," 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 ",(0,d.jsx)(n.code,{children:"Object.defineProperty"})," 设置 ",(0,d.jsx)(n.code,{children:"setter"})," 与 ",(0,d.jsx)(n.code,{children:"getter"})," 函数，用来实现「",(0,d.jsx)(n.strong,{children:"响应式"}),"」以及「",(0,d.jsx)(n.strong,{children:"依赖收集"}),"」，后面会详细讲到，这里只要有一个印象即可。"]}),"\n",(0,d.jsxs)(n.p,{children:["初始化之后调用 ",(0,d.jsx)(n.code,{children:"$mount"})," 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「",(0,d.jsx)(n.strong,{children:"编译"}),"」步骤。"]}),"\n",(0,d.jsxs)(n.h2,{id:"编译",children:["编译",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["compile编译可以分成 ",(0,d.jsx)(n.code,{children:"parse"}),"、",(0,d.jsx)(n.code,{children:"optimize"})," 与 ",(0,d.jsx)(n.code,{children:"generate"})," 三个阶段，最终需要得到 render function。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:a,alt:""})}),"\n",(0,d.jsxs)(n.h3,{id:"parse",children:["parse",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#parse",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"parse"})," 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。"]}),"\n",(0,d.jsxs)(n.h3,{id:"optimize",children:["optimize",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#optimize",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"optimize"})," 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 ",(0,d.jsx)(n.code,{children:"update"})," 更新界面时，会有一个 ",(0,d.jsx)(n.code,{children:"patch"})," 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 ",(0,d.jsx)(n.code,{children:"patch"})," 的性能。"]}),"\n",(0,d.jsxs)(n.h3,{id:"generate",children:["generate",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#generate",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"generate"})," 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。"]}),"\n",(0,d.jsxs)(n.p,{children:["在经历过 ",(0,d.jsx)(n.code,{children:"parse"}),"、",(0,d.jsx)(n.code,{children:"optimize"})," 与 ",(0,d.jsx)(n.code,{children:"generate"})," 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。"]}),"\n",(0,d.jsxs)(n.h2,{id:"响应式",children:["响应式",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#响应式",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"接下来也就是 Vue.js 响应式核心部分。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:t,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["这里的 ",(0,d.jsx)(n.code,{children:"getter"})," 跟 ",(0,d.jsx)(n.code,{children:"setter"})," 已经在之前介绍过了，在 ",(0,d.jsx)(n.code,{children:"init"})," 的时候通过 ",(0,d.jsx)(n.code,{children:"Object.defineProperty"})," 进行了绑定，它使得当被设置的对象被读取的时候会执行 ",(0,d.jsx)(n.code,{children:"getter"})," 函数，而在当被赋值的时候会执行 ",(0,d.jsx)(n.code,{children:"setter"})," 函数。"]}),"\n",(0,d.jsxs)(n.p,{children:["当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 ",(0,d.jsx)(n.code,{children:"getter"})," 函数进行「",(0,d.jsx)(n.strong,{children:"依赖收集"}),"」，「",(0,d.jsx)(n.strong,{children:"依赖收集"}),"」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["在修改对象的值的时候，会触发对应的 ",(0,d.jsx)(n.code,{children:"setter"}),"， ",(0,d.jsx)(n.code,{children:"setter"})," 通知之前「",(0,d.jsx)(n.strong,{children:"依赖收集"}),"」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 ",(0,d.jsx)(n.code,{children:"update"})," 来更新视图，当然这中间还有一个 ",(0,d.jsx)(n.code,{children:"patch"})," 的过程以及使用队列来异步更新的策略，这个我们后面再讲。"]}),"\n",(0,d.jsxs)(n.h2,{id:"virtual-dom",children:["Virtual DOM",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#virtual-dom",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。"}),"\n",(0,d.jsx)(n.p,{children:"比如说下面这样一个例子："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"{\n    tag: 'div',                 /*说明这是一个div标签*/\n    children: [                 /*存放该标签的子节点*/\n        {\n            tag: 'a',           /*说明这是一个a标签*/\n            text: 'click me'    /*标签的内容*/\n        }\n    ]\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"渲染后可以得到"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-html",children:"<div>\n    <a>click me</a>\n</div>\n"})}),"\n",(0,d.jsx)(n.p,{children:"这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。"}),"\n",(0,d.jsxs)(n.h2,{id:"更新视图",children:["更新视图",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新视图",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:c,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["前面我们说到，在修改一个对象值的时候，会通过 ",(0,d.jsx)(n.code,{children:"setter -> Watcher -> update"})," 的流程来修改对应的视图，那么最终是如何更新视图的呢？"]}),"\n",(0,d.jsxs)(n.p,{children:["当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 ",(0,d.jsx)(n.code,{children:"innerHTML"})," 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「",(0,d.jsx)(n.strong,{children:"浪费"}),"」。"]}),"\n",(0,d.jsxs)(n.p,{children:["那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"patch"})}),"」了。我们会将新的 VNode 与旧的 VNode 一起传入 ",(0,d.jsx)(n.code,{children:"patch"})," 进行比较，经过 diff 算法得出它们的「",(0,d.jsx)(n.strong,{children:"差异"}),"」。最后我们只需要将这些「",(0,d.jsx)(n.strong,{children:"差异"}),"」的对应 DOM 进行修改即可。"]}),"\n",(0,d.jsxs)(n.h2,{id:"再看全局",children:["再看全局",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#再看全局",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:s,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"回过头再来看看这张图，是不是大脑中已经有一个大概的脉络了呢？"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"那么，让我们继续学习每一个模块吧!"})})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}let o=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E5%89%96%E6%9E%90%20Vue.js%20%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F1.Vue.js%20%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%85%A8%E5%B1%80%E6%A6%82%E8%A7%88.md"]={toc:[{text:"全局概览",id:"全局概览",depth:2},{text:"初始化及挂载",id:"初始化及挂载",depth:2},{text:"编译",id:"编译",depth:2},{text:"parse",id:"parse",depth:3},{text:"optimize",id:"optimize",depth:3},{text:"generate",id:"generate",depth:3},{text:"响应式",id:"响应式",depth:2},{text:"Virtual DOM",id:"virtual-dom",depth:2},{text:"更新视图",id:"更新视图",depth:2},{text:"再看全局",id:"再看全局",depth:2}],title:"1.Vue.js 运行机制全局概览",headingTitle:"1.Vue.js 运行机制全局概览",frontmatter:{}}}}]);