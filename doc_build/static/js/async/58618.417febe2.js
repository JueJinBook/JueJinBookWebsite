"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58618"],{717724:function(e,n,s){s.r(n),s.d(n,{default:()=>x});var c=s(552676),d=s(740453);let r=s.p+"static/image/c8934b547804ba15412859844bf3ce6a.923c7e74.webp",i=s.p+"static/image/e7048e4e4aca398946cd554a5fec58c3.fe0d7942.webp",l=s.p+"static/image/0008d74fc001f2a7dcff158ff0670e6e.277d6d98.webp",h=s.p+"static/image/9a0c7829b16dea4683880aac98853a2e.33e05127.webp",a=s.p+"static/image/ce8341c9a29dc9c7fb1b208fe7330818.fb1ccf77.webp",t=s.p+"static/image/1b620d4a6765f999b953dedf9aae4975.77c78b14.webp",o=s.p+"static/image/4a76310dead6645074aedde2a29775bf.f58d86ef.webp";function p(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",pre:"pre",code:"code",img:"img",ul:"ul",li:"li"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"2如何从-0-到-1-搭建一个现代前端项目",children:["2.如何从 0 到 1 搭建一个现代前端项目？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2如何从-0-到-1-搭建一个现代前端项目",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"记得在大学的《网页开发》这门课上，老师对我们说：“网页开发的入门很简单的，用记事本就可以开发！”然后他就开始在记事本上写了几行 HTML 文件，再直接打开，然后我们就在网页上看到 “Hello World” 了！紧接着又加了几行 style 标签，网页上的 “Hello World” 由黑色变成了红色！最后又写了几行 script 脚本文件，浏览器出现了弹出框！"}),"\n",(0,c.jsx)(n.p,{children:"看到这一系列操作，同学们都直呼 “好简单呀！！”，于是就开始了《网页开发》的第一课。这也是我首次开始接触前端开发，与我同学们的感受一样，当时我对于前端开发的第一印象也是：入门简单。"}),"\n",(0,c.jsx)(n.p,{children:"那么数年过去后，在 2021 年，如果我们要用现代前端技术开发一个 Hello World，又需要怎么做呢？下面我们就来一步一步剖析。"}),"\n",(0,c.jsxs)(n.h2,{id:"第一步从-0-到-hello-world",children:["第一步：从 0 到 Hello World",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一步从-0-到-hello-world",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这里需要提前说明一下：在创建项目前，我默认屏幕前的各位",(0,c.jsx)(n.strong,{children:"已经有了一定的前端基础"}),"，如果是毫无基础的同学，可能对有些概念需要再辛苦勤劳一些，比如经常打开 Google 或掘金去搜索下相关的概念和用法。当然，这里我也默认你已经安装了 ",(0,c.jsx)(n.a,{href:"https://nodejs.org/zh-cn/",target:"_blank",rel:"noopener noreferrer",children:"node "}),"环境和 npm。"]}),"\n",(0,c.jsx)(n.p,{children:"首先，创建一个以你项目命名的文件夹\uD83D\uDCC2，比如我的就叫“0-1webpack”，创建完之后通过命令行打开当前目录，然后执行以下命令："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm init\n// 或\nnpm init -y\n"})}),"\n",(0,c.jsx)(n.p,{children:"紧接着，命令行就会有交互提示，让我们输入一些项目的配置，你可以认真输入或是一路回车跳过稍后再填。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'package name: (0-1webpack) \nversion: (1.0.0) \ndescription: \nentry point: (index.js) \ntest command: \ngit repository: \nkeywords: \nauthor: \nlicense: (ISC) \nAbout to write to /Users/workspace/self/0-1webpack/package.json:\n{\n  "name": "0-1webpack",\n  "version": "1.0.0",\n  "description": "",\n  "main": "index.js",\n  "scripts": {\n    "test": "echo "Error: no test specified" && exit 1"\n  },\n  "author": "",\n  "license": "ISC"\n}\n\nIs this OK? (yes) \n'})}),"\n",(0,c.jsxs)(n.p,{children:["在 “Is this OK” 之后，你会发现我们的项目多了一个 ",(0,c.jsx)(n.code,{children:"package.json"})," 配置文件，文件的内容就是刚刚我们通过命令行输入的内容。当然，除了使用 ",(0,c.jsx)(n.code,{children:"npm init"}),"之外，你也可以手动创建该 ",(0,c.jsx)(n.code,{children:"package.json"})," 文件并添加配置字段。"]}),"\n",(0,c.jsxs)(n.p,{children:["因为我们要创建一个前端项目，前端就必然离不开 HTML、CSS、JS 三大模块。那么，接下来，我们在项目中创建 ",(0,c.jsx)(n.code,{children:"index.html"}),"和",(0,c.jsx)(n.code,{children:"src"})," 文件夹，并且在 ",(0,c.jsx)(n.code,{children:"src"})," 文件夹中创建 ",(0,c.jsx)(n.code,{children:"index.js"})," 。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"touch index.html\nmkdir src\ntouch src/index.js\ntouch src/style.css\n"})}),"\n",(0,c.jsxs)(n.p,{children:["至此，我们的目录已经搭建完毕了。然后我们在 ",(0,c.jsx)(n.code,{children:"index.html"}),"中填入基本 ",(0,c.jsx)(n.code,{children:"HTML5"})," 标签结构，并引入脚本文件和样式文件。在 ",(0,c.jsx)(n.code,{children:"index.js"})," 文件中简单操作下 DOM，方便直观地看出来该 JS 文件已经生效。同时在 css 中设置 ",(0,c.jsx)(n.code,{children:"#app"})," 的字体颜色为 ",(0,c.jsx)(n.code,{children:"red"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'// src/index.html\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <link rel="stylesheet" type="text/css" href="./src/style.css"/>\n  <title>Document</title>\n</head>\n<body>\n  <div id="app" />\n  <script src="src/index.js"><\/script>\n</body\n</html>\n\n// src/index.js\nconst app = document.querySelector(\'#app\')\napp.innerHTML = \'Hello World\'\n\n\n// src/style.css\n#app{\n  color: red\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["然后，我们直接双击 ",(0,c.jsx)(n.code,{children:"index.html"}),"，就可以直接在浏览器上看到红色的 Hello World 了！好了，阶段性胜利了✌\uD83C\uDFFB。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"同时，我们打开 Network 可以看到，同时加载了三个文件。那么猜想一下，如果我们再多增加几个文件呢？结论你应该也知道，无论我们有多少个文件，在请求页面的时候，都是需要通过网络请求下载到本地的。"}),"\n",(0,c.jsx)(n.p,{children:"那么你可以想一下我们平时开发的项目，一个组件就有 HTML、JS、CSS 三个文件，复杂一点的项目可能会有几十个、上百个组件。那么可想而知，如果我们就这样直接在浏览器中加载我们的项目的话，Network 下会有很长一串文件列表，用户的使用体验会严重下降。"}),"\n",(0,c.jsxs)(n.p,{children:["所以，这个时候就需要用到我们平时习以为常的",(0,c.jsx)(n.strong,{children:"打包神器——webpack"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"第二步从-0-到-localhost8080",children:["第二步：从 0 到 localhost:8080",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第二步从-0-到-localhost8080",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["首先我们先要在我们的项目下安装 webpack（关于 webpack 的介绍，也不是本文的重点，你可以直接移步官网 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/concepts/",target:"_blank",rel:"noopener noreferrer",children:"webpack"}),"）："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install webpack\n"})}),"\n",(0,c.jsxs)(n.p,{children:["完成了安装之后，我们就可以开始进行打包操作了，我们的",(0,c.jsx)(n.strong,{children:"目的就是将多个文件打包为一个文件"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"我们创建一个入口文件 main.js 在其中引入了 index.js 和 a.js，并完善一下 HTML 和 js 中的内容，具体如下所示："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'// src/index.html\n\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <link rel="stylesheet" type="text/css" href="./src/style.css"/>\n  <title>Document</title>\n</head>\n\n<body>\n  <div>\n    <div id="app" ></div>\n    <div id="app2" ></div>\n  </div>\n  <script src="src/main.js" type="module"><\/script>\n</body>\n</html>\n\n\n// src/main.js\nimport \'./a.js\';\nimport \'./index.js\'\n\n// src/index.js\nconst app = document.querySelector(\'#app\')\napp.innerHTML = \'Hello World\'\n\n// src/a.js\nconst app2 = document.querySelector(\'#app2\')\napp2.innerHTML = \'js\'\n'})}),"\n",(0,c.jsxs)(n.p,{children:["同时我们也需要设置 webpack 的配置，在根目录下创建 ",(0,c.jsx)(n.code,{children:"webpack.config.js"})," 配置文件，设置入口文件和输出文件名。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"// webpack.config.js\nmodule.exports = {\n  entry: {\n    index: './src/main.js',\n  },\n  output: {\n    filename: 'bundle.js',\n  },\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后就可以进行打包了，使用 webpack 打包只需要在终端执行。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"webpack\n"})}),"\n",(0,c.jsxs)(n.p,{children:["那我们执行一下试试。在这里，新同学可能会有报错 ",(0,c.jsx)(n.code,{children:"command not found: webpack"}),"，这是因为直接执行 ",(0,c.jsx)(n.code,{children:"webpack"})," 的话，",(0,c.jsx)(n.code,{children:"PATH"})," 的值还是全局路径，",(0,c.jsx)(n.strong,{children:"如果在本地全局没有安装 webpack 就会报错"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"解决的方案有四种，选取任意一种即可。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["全局安装 ",(0,c.jsx)(n.code,{children:"webpack"})," ：",(0,c.jsx)(n.code,{children:"npm install webpack -g"})," 。"]}),"\n",(0,c.jsxs)(n.li,{children:["执行命令换成 ",(0,c.jsx)(n.code,{children:"./node_modules/.bin/webpack"})," 。"]}),"\n",(0,c.jsxs)(n.li,{children:["在 ",(0,c.jsx)(n.code,{children:"npm scripts"}),' 中添加指令："build": "webpack" 。']}),"\n",(0,c.jsx)(n.li,{children:"npx webpack。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["在 webpack 打包完成之后，我们可以看到我们的项目中多了一个 ",(0,c.jsx)(n.code,{children:"dist"})," 文件夹，里面有一个 ",(0,c.jsx)(n.code,{children:"bundle.js"})," 文件，就是 ",(0,c.jsx)(n.code,{children:"index.js"})," 和 ",(0,c.jsx)(n.code,{children:"a.js"}),"中的内容，那么我们就完成了打包的操作。"]}),"\n",(0,c.jsxs)(n.p,{children:["慢着，这个时候，我们再直接打开 ",(0,c.jsx)(n.code,{children:".html"})," 文件看一下，emmmm，页面白屏并且报错："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["根据错误信息大概可以看出来原因在于使用了 File 协议，应该使用提示的“http, data, chrome, chrome-extension, chrome-untrusted, https”这些协议。要解决这个问题，我们可以",(0,c.jsx)(n.strong,{children:"使用 DevServer 创建一个支持 http 的本地服务"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["webpack 也提供了 ",(0,c.jsx)(n.a,{href:"https://webpack.docschina.org/configuration/dev-server/#root",target:"_blank",rel:"noopener noreferrer",children:"webpack-dev-server "}),"，支持快速开发应用程序。那么我们来使用一下，万年不变的第一步，先安装依赖："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install webpack-dev-server --save-dev\n"})}),"\n",(0,c.jsxs)(n.p,{children:["然后在配置文件中新增 ",(0,c.jsx)(n.code,{children:"devServer"})," 配置："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"// webpack.config.js\n\nmodule.exports = {\n  // ...\n  devServer: {\n    static: {\n      directory: './',\n    },\n    port: 8080\n  }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"同时在 package.json 中新增 dev 指令："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'// package.json\n{\n  // ...\n  "scripts": {\n    "test": "echo "Error: no test specified" && exit 1",\n    "build": "webpack",\n    "dev": "webpack-dev-server",  },\n\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["紧接着，再运行 ",(0,c.jsx)(n.code,{children:"npm run dev"}),"，不出意外的话，是会报错缺少 ",(0,c.jsx)(n.code,{children:"webpack-cli"})," 的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"The CLI moved into a separate package: webpack-cli\nPlease install 'webpack-cli' in addition to webpack itself to use the CLI\n-> When using npm: npm i -D webpack-cli\n-> When using yarn: yarn add -D webpack-cli\n#... \n"})}),"\n",(0,c.jsx)(n.p,{children:"根据提示我们还需要再次安装依赖："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install webpack-cli\n"})}),"\n",(0,c.jsxs)(n.p,{children:["然后再次尝试 ",(0,c.jsx)(n.code,{children:"npm run dev"})," ，✿✿ヽ(\xb0▽\xb0)ノ✿ 终于成功了！"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"> 0-1webpack@1.0.0 dev /Users/workspace/self/0-1webpack\n\n> webpack-dev-server\n<i> [webpack-dev-server] Project is running at:\n<i> [webpack-dev-server] Loopback: http://localhost:8080/\n<i> [webpack-dev-server] On Your Network (IPv4): http://30.209.164.16:8080/\n<i> [webpack-dev-server] On Your Network (IPv6): http://[fe80::1]:8080/\n<i> [webpack-dev-server] Content not from webpack is served from './src' directory\n<i> [webpack-dev-middleware] wait until bundle finished: /\nasset bundle.js 125 KiB [emitted] [minimized] (name: index) 1 related asset\n\nwebpack 5.52.0 compiled successfully in 780 ms\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以简单看下 ",(0,c.jsx)(n.code,{children:"webpack-dev-server"})," 的提示信息，包括服务运行的地址、编译的大小、时间等信息。那么接下来，就可以在 ",(0,c.jsx)(n.code,{children:"http://localhost:8080/"})," 看到我们刚刚的项目了。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["至此，我们已经",(0,c.jsx)(n.strong,{children:"完成了将两个"})," ",(0,c.jsx)(n.strong,{children:"JS"})," ",(0,c.jsx)(n.strong,{children:"打包为 1 个"})," ",(0,c.jsx)(n.strong,{children:"JS"})," ",(0,c.jsx)(n.strong,{children:"文件的功能，也成功走通了开发环境，可以在本地环境进行开发"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"第三步处理-css",children:["第三步：处理 CSS",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第三步处理-css",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"webpack 是运行在 node 环境中的，所以在打包的时候只能处理 JS 之间的依赖。像 .css 这样的文件不是一个 JavaScript 模块，所以我们就必须要配置对应的 loader 进行处理。那么我们就来看下怎么使用 webpack 处理 CSS。"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsxs)(n.strong,{children:["CSS 模块的打包需要使用 ",(0,c.jsx)(n.code,{children:"css-loader"})," 和 ",(0,c.jsx)(n.code,{children:"style-loader"})," 这两个 loader，它们可以在 JavaScript 模块中 ",(0,c.jsx)(n.code,{children:"import"})," CSS 文件"]}),"。其中，",(0,c.jsx)(n.code,{children:"css-loader"})," 可以帮助我们解析 JS 文件中的 CSS，而 ",(0,c.jsx)(n.code,{children:"style-loader"})," 则是将 CSS 代码以 ",(0,c.jsx)(n.code,{children:"<style>"})," 标签的形式添加到页面头部。下面我们来看下怎么操作的~"]}),"\n",(0,c.jsx)(n.p,{children:"又是万年不变的第一步，先安装依赖："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install css-loader style-loader --save-dev\n"})}),"\n",(0,c.jsx)(n.p,{children:"紧接着在配置文件中配置 loader："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"// webpack.config.js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [  \n      {\n        test: /.css$/,   // 正则表达式，表示.css后缀的文件\n        use: ['style-loader','css-loader']   // 针对css文件使用的loader，注意有先后顺序，数组项越靠后越先执行\n      }\n    ]\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这里我们需要改变一下引入的方式，因为我们 webpack 配置的入口文件是 ",(0,c.jsx)(n.code,{children:"main.js"})," ，所以需要在 ",(0,c.jsx)(n.code,{children:"main.js"})," 中引入我们的样式文件 ",(0,c.jsx)(n.code,{children:"style.css"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["然后再次执行打包操作，就可以看到 CSS 的部分也被打包到 ",(0,c.jsx)(n.code,{children:"bundle.js"})," 中了。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"第四步处理-html",children:["第四步：处理 HTML",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第四步处理-html",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"前面我们已经处理了网页开发的三大技术中的两个：JS 和 CSS，那么还剩最后一个：HTML。"}),"\n",(0,c.jsxs)(n.p,{children:["你可以回忆一下我们平时的线上代码，是不是在打包后的文件后面都会有一个 hash 值？这是因为我们想",(0,c.jsx)(n.strong,{children:"最大程度地利用浏览器的缓存能力"}),"，那么如果文件内容有更改，我们就直接更换文件后面的 hash 值，这样对浏览器来说就是新文件，不会命中缓存策略加载旧文件。对于内容没有变的文件，hash 也不改变，这样就使用缓存中的文件。"]}),"\n",(0,c.jsx)(n.p,{children:"webpack 也给我们提供了几种不同的 hash 配置。在配置文件的 output 字段中，我们设置导出的 filename 可以指定 hash，有三个值可以选择。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"[hash]：整个项目共用同一个 hash 值，只要项目里有文件更改，整个项目构建的 hash 值都会更改。"}),"\n",(0,c.jsx)(n.li,{children:"[chunkhash]：同一个模块共用一个 hash 值，就算将 JS 和 CSS 分离，其 hash 值也是相同的，修改一处，JS 和 CSS 的 hash 值都会变。"}),"\n",(0,c.jsx)(n.li,{children:"[contenthash]：单个文件单独的 hash 值，只要文件内容不一样，产生的 hash 值就不一样。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["可以看出来，",(0,c.jsxs)(n.strong,{children:["选择 ",(0,c.jsx)(n.code,{children:"contenthash"})," 更有利于缓存效果，所以我们就选择 ",(0,c.jsx)(n.code,{children:"contenthash"})]}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"// webpack.config.js\nmodule.exports = {\n  // ...\n  output: {\n    filename: 'bundle_[contenthash:8].js',\n  },\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["再次执行 webpack 打包之后，我们可以看到，在项目 ",(0,c.jsx)(n.code,{children:"/dist"})," 文件夹下，多出 ",(0,c.jsx)(n.code,{children:"bundle_9397f40b.js"})," 文件。"]}),"\n",(0,c.jsxs)(n.p,{children:["那么问题来了，每次的文件内容更新，hash 的值都会变，那我们在 HTML 中引入文件的地方每次都要去改文件名吗？答案是否定的，webpack 有插件可以处理这些问题 —— ",(0,c.jsx)(n.code,{children:"html-webpack-plugin"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"万年第一步，安装依赖："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install html-webpack-plugin --save-dev\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后在配置文件新增配置："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"// webpack.config.js\nmodule.exports = {\n  // ...\n  plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'index.html', // 输出的文件名, 默认为 index.html\n      template: './src/index.html', // 需处理的文件, 我们的 index.html\n    })\n  ]\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["然后重新 ",(0,c.jsx)(n.code,{children:"npm run dev"})," ，打开控制台看下这个时候的 HTML，好像有哪里不对的样子！"]}),"\n",(0,c.jsxs)(n.p,{children:["是的，浏览器展示的页面并不是我们的 ",(0,c.jsx)(n.code,{children:"index.html"}),"，这个是 ",(0,c.jsx)(n.code,{children:"HtmlWebpackPlugin"})," 插件以我们自己写的 ",(0,c.jsx)(n.code,{children:"index.html"})," 为模板生成的 ",(0,c.jsx)(n.code,{children:"HTML5"}),"文件。但是值得注意的是：插件会自动将编译后的 JS 文件引入。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"第五步处理兼容性问题",children:["第五步：处理兼容性问题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第五步处理兼容性问题",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["你屁颠屁颠地给老大说开发完了，坐等上线，然而 QA 拿着祖传的 iPhone5 来找你，说在这个手机上打不开，白屏。你又一顿排查之后，发现是 iOS 9 不支持 ",(0,c.jsx)(n.code,{children:"const"})," 关键字。你虽然心里默默抱怨：“现在谁还在用 iPhone5？！” 但是又不得不去解决这个问题。"]}),"\n",(0,c.jsx)(n.p,{children:"那怎么来解决呢？相信你肯定听说过大名鼎鼎的 Babel！关于 Bable 详细的知识点，我会在后续的章节中为你介绍，这里先简单地从 API 层面上说明下怎么用。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:["Babel 主要用于将采用 ",(0,c.jsx)(n.code,{children:"ECMAScript 2015+"})," 语法编写的代码转化为向后兼容的 JavaScript 代码，以便能够运行在旧版本的浏览器或其他环境中。"]})}),"\n",(0,c.jsx)(n.p,{children:"首先我们安装依赖："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install --save-dev @babel/core @babel/cli @babel/preset-env\n"})}),"\n",(0,c.jsxs)(n.p,{children:["然后在根目录下创建一个名为 ",(0,c.jsx)(n.code,{children:"babel.config.json"})," 的配置文件："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'// babel.config.json\n// 上述浏览器列表仅用于示例。请根据你所需要支持的浏览器进行调整。\n\n{\n  "presets": [\n    [\n      "@babel/env",\n      {\n        "targets": {\n          "edge": "17",\n          "firefox": "60",\n          "chrome": "67",\n          "safari": "11.1"\n        },\n        "useBuiltIns": "usage",\n        "corejs": "3.6.5"\n      }\n    ]\n  ]\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["我们使用的是 ",(0,c.jsx)(n.code,{children:"webpack"})," 对文件进行打包，那么我们还需要增加 ",(0,c.jsx)(n.code,{children:"webpack"})," 的 ",(0,c.jsx)(n.code,{children:"babel-loader"})," 对我们的 JS 文件进行处理。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install  --save-dev babel-loader\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后在 webpack 的配置文件中新增配置："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"// webpack.config.js\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [  \n      // ...\n      {\n        test: /.(js|jsx|ts|tsx)$/,\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: 'babel-loader',\n            options: {\n              presets: ['@babel/preset-env'],\n            },\n          },\n        ],\n      },\n    ]\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["接下来我们再次进行打包，就可以看到之前我们代码里面的 ",(0,c.jsx)(n.code,{children:"const"})," 都被降级为了 ",(0,c.jsx)(n.code,{children:"var"})," 。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"收工",children:["收工",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#收工",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["经过以上一系列操作后，我们再执行 ",(0,c.jsx)(n.code,{children:"npm run build"})," ，看下我们能够打包出来什么东西。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["通过上图能够看出，打包之后的内容都在 ",(0,c.jsx)(n.code,{children:"dist"})," 文件夹中，里面有打包后的 ",(0,c.jsx)(n.code,{children:"index.html"})," 和 ",(0,c.jsx)(n.code,{children:"bundle_8098bd66.js"}),"，并且在 html 文件中自动将打包生成的 js 文件引入。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"就这样我们从 0 到 1 搭建了一个现代前端项目，这整个过程中涉及的前端工程化的相关知识有以下这些。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"JS 运行环境：node"}),"\n",(0,c.jsx)(n.li,{children:"包管理工具：npm"}),"\n",(0,c.jsx)(n.li,{children:"静态模块打包器：webpack"}),"\n",(0,c.jsx)(n.li,{children:"JavaScript 编译器：babel"}),"\n",(0,c.jsx)(n.li,{children:"本地快速开发工具：dev-server"}),"\n",(0,c.jsx)(n.li,{children:"……"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"有些同学可能会有疑惑：我为什么要从 0 到 1 自己去搭建项目呢？我可以使用脚手架自动创建项目，或者还可以将其他项目的代码 copy 过来呀！"}),"\n",(0,c.jsxs)(n.p,{children:["首先，我认为",(0,c.jsx)(n.strong,{children:"作为一名合格的前端工程师，必须要有能不依赖工具进行开发的能力。"})," 工具只是作为辅助以提高我们的开发效率，我们需要了解其底层的基本原理，而不是只会使用某些框架、工具的 API。当然，你可以直接使用脚手架来生成，但是对于自动生成的项目的配置你一定要有足够的了解！如果有定制化的需求，知道怎么修改吗？知道怎么针对你的项目进行优化吗？"]}),"\n",(0,c.jsxs)(n.p,{children:["其次，",(0,c.jsx)(n.strong,{children:"自己从 0 到 1 搭建项目可以让我们更加清楚使用某些工具的目的"}),"。比如，为什么要使用 loader？在什么情况下需要使用 ",(0,c.jsx)(n.code,{children:"css-loader"})," ？什么情况下需要使用 ",(0,c.jsx)(n.code,{children:"style-loader"}),"？",(0,c.jsx)(n.code,{children:"css-loader"})," 和",(0,c.jsx)(n.code,{children:"style-loader"})," 有什么区别？这几个问题有没有很熟悉？！是不是在面试过程中经常会被问到？根据我面试候选人的经验来看，确实还有一些人只知其然而不知其所以然。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后，为什么在小册的开头我会选择要你了解如何从 0 到 1 去搭建一个现代化前端项目呢？就是为了让你了解从 0 到 1 自己创建项目这个过程，知道现代化的前端开发并不是和“刀耕火种时代”一样，只用一个记事本就可以写网页了；",(0,c.jsx)(n.strong,{children:"前端开发越来越走上工程化的道路了，我们需要用工程化的思想和方式来为我们降本提效。"})," 所以，在接下来的章节中，我们就会具体介绍前端工程化的相关内容，敬请期待。"]}),"\n",(0,c.jsx)(n.p,{children:"那就让我们来一起探索前端工程相关的内容吧。在学习过程中，如果你有什么不理解地方，或者有好的经验要分享，欢迎你留言，我们一起交流和进步。"})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(p,{...e})}):p(e)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E5%88%9D%E6%8E%A2%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%2F2.%E5%A6%82%E4%BD%95%E4%BB%8E%200%20%E5%88%B0%201%20%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%EF%BC%9F.md"]={toc:[{text:"第一步：从 0 到 Hello World",id:"第一步从-0-到-hello-world",depth:2},{text:"第二步：从 0 到 localhost:8080",id:"第二步从-0-到-localhost8080",depth:2},{text:"第三步：处理 CSS",id:"第三步处理-css",depth:2},{text:"第四步：处理 HTML",id:"第四步处理-html",depth:2},{text:"第五步：处理兼容性问题",id:"第五步处理兼容性问题",depth:2},{text:"收工",id:"收工",depth:2},{text:"总结",id:"总结",depth:2}],title:"2.如何从 0 到 1 搭建一个现代前端项目？",headingTitle:"2.如何从 0 到 1 搭建一个现代前端项目？",frontmatter:{}}}}]);