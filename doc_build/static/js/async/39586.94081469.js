"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["39586"],{161005:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var i=r(552676),s=r(740453);let t=r.p+"static/image/a8ab342b722dcfc4a06358b7e908950b.ae45b05d.gif",a=r.p+"static/image/da8cf90195946aa069bbd055dfc962d9.8a3efa72.webp",c=r.p+"static/image/c8b2f0ec98c766725969b55af1e57f32.61c130be.webp",d=r.p+"static/image/3f5b66319c2e4f86e80e2575f71e3fcc.2a33931d.webp",l=r.p+"static/image/2c8ef834a3a9b69cd748f204e73c05dd.88bc9902.webp",o=r.p+"static/image/9c1f7c45beced47c6546d94f3fe9d870.fabb221b.gif",h=r.p+"static/image/b475ed8e80d6468f090de86d0b736150.26c56280.webp";function p(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",pre:"pre",img:"img",h3:"h3",ul:"ul",li:"li",ol:"ol"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h2,{id:"前言",children:["前言",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"我们正常部署 Next.js 应用都是需要在服务器上起一个 server 来实现，但其实也可以不这样做。Next.js 也支持类似于静态网站或者单页应用（SPA）的形式。这就是本章要讲解的静态导出（Static Exports）功能。"}),"\n",(0,i.jsxs)(n.p,{children:["它的效果是这样的：当你执行构建（",(0,i.jsx)(n.code,{children:"npm run build"}),"）后，Next.js 会为每一个路由生成一个单独的 HTML 文件，以及相关使用的 CSS、JavaScript、图片等资源，这些内容会放到你指定的文件夹下，你可以将这个文件夹下的内容直接部署使用。"]}),"\n",(0,i.jsx)(n.p,{children:"但效果跟传统的静态网站不一样的是，Next.js 生成的网站效果类似于 SPA，即路由虽然发生变化，但页面不会加载刷新。"}),"\n",(0,i.jsx)(n.p,{children:"让我们看看怎么实现静态导出吧！"}),"\n",(0,i.jsxs)(n.h2,{id:"1-配置",children:["1. 配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-配置",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["要启用静态导出，修改 ",(0,i.jsx)(n.code,{children:"next.config.js"})," 的导出模式："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\n/**\n * @type {import('next').NextConfig}\n */\nconst nextConfig = {\n  output: 'export',\n  // 可选: 默认导出目录为 out，distDir 可以更改这个目录名 `out` -> `dist`\n  // distDir: 'dist',\n}\n \nmodule.exports = nextConfig\n"})}),"\n",(0,i.jsxs)(n.p,{children:["运行 ",(0,i.jsx)(n.code,{children:"next build"})," 后，Next.js 会创建一个名为 ",(0,i.jsx)(n.code,{children:"out"})," 的文件夹包含该应用所需的 HTML、CSS、JS 等资源。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"2-行为",children:["2. 行为",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-行为",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"为了支持静态导出，Next.js 的核心部分都进行了改造，让我们了解一下这些核心部分在静态导出的时候的行为和特性吧："}),"\n",(0,i.jsxs)(n.h3,{id:"21-服务端组件",children:["2.1. 服务端组件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-服务端组件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["当配置静态导出运行 ",(0,i.jsx)(n.code,{children:"next build"})," 的时候，",(0,i.jsx)(n.code,{children:"app"})," 目录下的服务端组件会在构建期间运行，这个过程类似于传统的静态站点生成。"]}),"\n",(0,i.jsx)(n.p,{children:"这些组件会渲染成静态的 HTML 文件（用于初始化页面加载）和客户端路由导航之间的静态 payload。当使用静态导出时，服务端组件不需要进行任何更改，除非它们使用了动态服务端函数，下文会讲到在静态导出中不支持的功能。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"// app/page.jsx\nexport default async function Page() {\n  // 在 `next build` 的时候 fetch 请求会执行\n  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1')\n  const data = await res.json()\n \n  return <main>{data.title}</main>\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"编译变成 HTML 文件后："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charSet="utf-8" />\n  <meta name="viewport" content="width=device-width, initial-scale=1" />\n	///...\n</head>\n\n<body>\n  <main>sunt aut facere repellat provident occaecati excepturi optio reprehenderit</main>\n  //...\n</body>\n\n</html>\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"22-客户端组件",children:["2.2. 客户端组件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-客户端组件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["页面不一定总是静态资源，有点时候，也需要在页面打开或者发生交互的时候获取数据，此时就需要使用客户端组件。如果要在客户端获取数据，可以使用带有 ",(0,i.jsx)(n.a,{href:"https://github.com/vercel/swr",target:"_blank",rel:"noopener noreferrer",children:"SWR"})," 的客户端组件记忆化请求："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"'use client'\n// app/other/page.js\nimport useSWR from 'swr'\n \nconst fetcher = (url) => fetch(url).then((r) => r.json())\n \nexport default function Page() {\n  const { data, error } = useSWR(\n    `https://jsonplaceholder.typicode.com/posts/1`,\n    fetcher\n  )\n  if (error) return 'Failed to load'\n  if (!data) return 'Loading...'\n \n  return data.title\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"因为路由导航发生在客户端，其行为类似于传统的 SPA。举个例子："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nimport Link from 'next/link'\n \nexport default function Page() {\n  return (\n    <>\n      <h1>Index Page</h1>\n      <p>\n        <Link href=\"/other\">Other Page</Link>\n      </p>\n    </>\n  )\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["现在我们运行 ",(0,i.jsx)(n.code,{children:"npm run build"})," 执行构建，然后对导出的 ",(0,i.jsx)(n.code,{children:"out"})," 文件夹起一个服务（VSCode 可以用 Live Server 这个插件），你会发现它的表现类似于 SPA："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:"1111.gif"})}),"\n",(0,i.jsx)(n.p,{children:"这是为了避免在客户端加载不必要的 JavaScript 代码，从而减小 bundle 的大小，实现更快的页面加载。"}),"\n",(0,i.jsx)(n.p,{children:"但它跟传统的 SPA 还不一样。因为传统 SPA 的 HTML 是一个“空的”，只有一个可以挂载的根节点比如这样："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"<div id='root'></div>\n<script src=\"app.js\" />\n"})}),"\n",(0,i.jsx)(n.p,{children:"但 Next.js 构建出来的无论是服务端组件还是客户端组件，都是有 HTML 内容的。"}),"\n",(0,i.jsxs)(n.h3,{id:"23-图片优化",children:["2.3. 图片优化",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-图片优化",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在使用静态导出的时候，并不能使用带有默认 loader 的 ",(0,i.jsx)(n.code,{children:"next/image"})," 组件，举个例子："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nimport Image from 'next/image'\nimport profilePic from './me.png'\n \nexport default function Page() {\n  return (\n    <Image\n      src={profilePic}\n      alt=\"Picture of the author\"\n    />\n  )\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"开发模式下会出现错误提示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"你可以自定义配置一个 loader，比如使用 Cloudinary（提供基于云的图像和视频管理服务。用户能够上载，存储，管理，操纵和交付用于网站和应用程序的图像和视频）。"}),"\n",(0,i.jsxs)(n.p,{children:["首先配置 ",(0,i.jsx)(n.code,{children:"next.config.js"}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  output: 'export',\n  images: {\n    loader: 'custom',\n    loaderFile: './my-loader.js',\n  },\n}\n \nmodule.exports = nextConfig\n"})}),"\n",(0,i.jsx)(n.p,{children:"其次，添加自定义 loader 的代码："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// my-loader.js\nexport default function cloudinaryLoader({ src, width, quality }) {\n  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]\n  return `https://res.cloudinary.com/demo/image/upload/${params.join(\n    ','\n  )}${src}`\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["现在，你就可以使用 ",(0,i.jsx)(n.code,{children:"next/image"})," 组件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// app/page.js\nimport Image from \'next/image\'\n \nexport default function Page() {\n  return <Image alt="turtles" src="/turtles.jpg" width={300} height={300} />\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"此时图片能够正确展示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["你可能会想：“好麻烦！我就想简单展示个图片，还要去找个图片服务吗？”，其实你也可以直接使用 ",(0,i.jsx)(n.code,{children:"<img>"})," 标签，但对应会失去 ",(0,i.jsx)(n.code,{children:"next/image"})," 组件带来的优化。比如把图片放在 ",(0,i.jsx)(n.code,{children:"/public"})," 下后使用 img 标签读取也可以正常展示："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// app/page.js\nexport default function Page() {\n  return <img width="300" src="/image.png" />\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h3,{id:"24-路由处理程序",children:["2.4. 路由处理程序",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-路由处理程序",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["路由处理程序在运行 ",(0,i.jsx)(n.code,{children:"next build"})," 的时候会渲染一个静态的响应。只有在 ",(0,i.jsx)(n.code,{children:"GET"})," 请求被支持。这可以用于生成静态的 HTML、JSON、TXT 或者其他文件。举个例子："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// app/data.json/route.js\nexport async function GET() {\n  return Response.json({ name: 'Lee' })\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"app/data.json/rout.js"})," 会在 ",(0,i.jsx)(n.code,{children:"next build"})," 的时候渲染成一个静态的名为 ",(0,i.jsx)(n.code,{children:"data.json"}),"的文件："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"如果你需要从传入的请求中读取动态值，那就不能使用静态导出了。"}),"\n",(0,i.jsxs)(n.h3,{id:"25-浏览器-api",children:["2.5. 浏览器 API",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-浏览器-api",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在运行 ",(0,i.jsx)(n.code,{children:"next build"})," 的时候，客户端组件会被预渲染成  HTML。因为 Web APIs 像 ",(0,i.jsx)(n.code,{children:"window"}),"、",(0,i.jsx)(n.code,{children:"localStorage"})," 和 ",(0,i.jsx)(n.code,{children:"navigator"})," 在服务端是不可用的，所以你需要保证仅在浏览器中运行的时候才访问这些 API，举个例子："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"'use client';\n \nimport { useEffect } from 'react';\n \nexport default function ClientComponent() {\n  useEffect(() => {\n    // 现在可以访问 `window`\n    console.log(window.innerHeight);\n  }, [])\n \n  return ...;\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"3-不支持的功能",children:["3. 不支持的功能",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-不支持的功能",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"需要 Nodejs server 的功能或者在构建过程中需要计算的动态逻辑都是不支持的，具体有："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes",target:"_blank",rel:"noopener noreferrer",children:"Dynamic Routes"})," 中 ",(0,i.jsx)(n.code,{children:"dynamicParams: true"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes",target:"_blank",rel:"noopener noreferrer",children:"Dynamic Routes"})," 没有使用",(0,i.jsx)(n.code,{children:"generateStaticParams()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/routing/route-handlers",target:"_blank",rel:"noopener noreferrer",children:"Route Handlers"})," 依赖传入的请求"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/functions/cookies",target:"_blank",rel:"noopener noreferrer",children:"Cookies"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/next-config-js/rewrites",target:"_blank",rel:"noopener noreferrer",children:"Rewrites"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/next-config-js/redirects",target:"_blank",rel:"noopener noreferrer",children:"Redirects"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/next-config-js/headers",target:"_blank",rel:"noopener noreferrer",children:"Headers"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/routing/middleware",target:"_blank",rel:"noopener noreferrer",children:"Middleware"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating",target:"_blank",rel:"noopener noreferrer",children:"Incremental Static Regeneration"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/optimizing/images",target:"_blank",rel:"noopener noreferrer",children:"Image Optimization"})," 使用默认 loader"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/configuring/draft-mode",target:"_blank",rel:"noopener noreferrer",children:"Draft Mode"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"next dev"})," 的时候尝试使用这些功能都会导致错误。"]}),"\n",(0,i.jsxs)(n.h2,{id:"4-部署",children:["4. 部署",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-部署",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"使用静态导出，Next.js 可以部署和托管在任何能处理 HTML、CSS 、JS 静态资源的 Web 服务器上。"}),"\n",(0,i.jsxs)(n.p,{children:["运行 ",(0,i.jsx)(n.code,{children:"next build"})," 的时候，Next.js 会生成静态文件到 ",(0,i.jsx)(n.code,{children:"out"})," 文件夹下，举个例子，假如你有这些路由："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"/"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"/blog/[id]"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["运行 ",(0,i.jsx)(n.code,{children:"next build"}),"后，Next.js 会生成以下文件："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"/out/index.html"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"/out/404.html"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"/out/blog/post-1.html"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"/out/blog/post-2.html"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["有 ",(0,i.jsx)(n.code,{children:"post-1.html、post-2.html"})," 这些文件是因为定义了 ",(0,i.jsx)(n.code,{children:"generateStaticParams"}),"，不使用该函数也无法静态导出。"]}),"\n",(0,i.jsxs)(n.p,{children:["但此时路由跳转的时候会有一个问题，就比如从 ",(0,i.jsx)(n.code,{children:"/"}),"跳转到 ",(0,i.jsx)(n.code,{children:"/other"}),"，第一次没有问题，因为页面类似于 SPA，但是刷新 ",(0,i.jsx)(n.code,{children:"/other"}),"就会导致错误，原本的 ",(0,i.jsx)(n.code,{children:"/other"})," 被编译成了 ",(0,i.jsx)(n.code,{children:"other.html"}),"，访问 ",(0,i.jsx)(n.code,{children:"/other.html"})," 才会正常访问。让我们看下演示："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:"1112.gif"})}),"\n",(0,i.jsx)(n.p,{children:"为了解决这个问题，如果你使用了比如 Nginx，那你可以配置一个从传入请求到正确文件的重写："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"# 32.部署篇 _ 静态导出\nserver {\n  listen 80;\n  server_name acme.com;\n \n  root /var/www/out;\n \n  location / {\n      try_files $uri $uri.html $uri/ =404;\n  }\n \n  # 当配置 `trailingSlash: false`，这是必要的\n  # 当配置 `trailingSlash: true`，可以省略\n  location /blog/ {\n      rewrite ^/blog/(.*)$ /blog/$1.html break;\n  }\n \n  error_page 404 /404.html;\n  location = /404.html {\n      internal;\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/deploying/static-exports",target:"_blank",rel:"noopener noreferrer",children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/deploying/static-exports",target:"_blank",rel:"noopener noreferrer",children:"https://nextjs.org/docs/app/building-your-application/deploying/static-exports"})})}),"\n"]})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F32.%E9%83%A8%E7%BD%B2%E7%AF%87%20_%20%E9%9D%99%E6%80%81%E5%AF%BC%E5%87%BA.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. 配置",id:"1-配置",depth:2},{text:"2. 行为",id:"2-行为",depth:2},{text:"2.1. 服务端组件",id:"21-服务端组件",depth:3},{text:"2.2. 客户端组件",id:"22-客户端组件",depth:3},{text:"2.3. 图片优化",id:"23-图片优化",depth:3},{text:"2.4. 路由处理程序",id:"24-路由处理程序",depth:3},{text:"2.5. 浏览器 API",id:"25-浏览器-api",depth:3},{text:"3. 不支持的功能",id:"3-不支持的功能",depth:2},{text:"4. 部署",id:"4-部署",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);