"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["25678"],{137153:function(e,n,r){r.r(n),r.d(n,{default:()=>i});var s=r(552676),c=r(740453);function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",h2:"h2",h3:"h3",pre:"pre",h4:"h4",ul:"ul",li:"li",blockquote:"blockquote",ol:"ol"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"第02章基础篇electron的基础概念",children:["第02章—基础篇：Electron的基础概念",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第02章基础篇electron的基础概念",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"\uFEFF## 前言"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Electron"})," 由 ",(0,s.jsx)(n.code,{children:"Node.js + Chromium + Native API"})," 构成。你可以理解成，它是",(0,s.jsxs)(n.strong,{children:["一个得到了 ",(0,s.jsx)(n.code,{children:"Node.js"})," 和基于不同平台的 ",(0,s.jsx)(n.code,{children:"Native API"})," 加强的 ",(0,s.jsx)(n.code,{children:"Chromium"})," 浏览器"]}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了让你对 ",(0,s.jsx)(n.code,{children:"Electron"})," 有更加深刻的理解和认识，接下来我将详细地为你介绍学习 ",(0,s.jsx)(n.code,{children:"Electron"})," 所必须要知道的基础概念。"]}),"\n",(0,s.jsxs)(n.h2,{id:"主进程main-和-渲染进程renderer",children:["主进程（main） 和 渲染进程（renderer）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主进程main-和-渲染进程renderer",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Electron 继承了来自 Chromium 的多进程架构，Chromium 始于其主进程。从主进程可以派生出渲染进程。渲染进程与浏览器窗口是一个意思。主进程保存着对渲染进程的引用，并且可以根据需要创建/删除渲染器进程。"}),"\n",(0,s.jsxs)(n.p,{children:["每个 Electron 的应用程序都有一个主入口文件，它所在的进程被称为 ",(0,s.jsx)(n.code,{children:"主进程（Main Process）"}),"。而主进程中创建的窗体都有自己运行的进程，称为 ",(0,s.jsx)(n.code,{children:"渲染进程（ Renderer Process）"}),"。",(0,s.jsx)(n.strong,{children:"每个 Electron 的应用程序有且仅有一个主进程，但可以有多个渲染进程"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"简单理解下，主进程就相当于浏览器，而渲染进程就相当于在浏览器上打开的一个个网页。"}),"\n",(0,s.jsxs)(n.h3,{id:"主进程",children:["主进程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主进程",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["主进程是 Electron 应用程序的核心，通常由一个主要的 JavaScript 文件（如 ",(0,s.jsx)(n.code,{children:"main.js"})," ）定义，你可以在 ",(0,s.jsx)(n.code,{children:"package.json"})," 中指定它："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// package.json\n{  \n    "name": "my-electron-app",  \n    "version": "1.0.0",\n    "description": "Hello World!",  \n    // 主进程入口文件\n    "main": "main.js",   \n    "author": "muwoo",  \n    "devDependencies": {  \n       // ...\n    }  \n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"它是应用程序的入口点，负责管理整个应用的生命周期、创建窗口、原生 API 调用等。主进程可以访问底层的系统资源，如文件系统、操作系统 API 等，这些功能通常是通过 Node.js 提供的模块实现的。它是 Electron 应用的主要控制中心。"}),"\n",(0,s.jsxs)(n.h4,{id:"1-管理应用程序生命周期",children:["1. 管理应用程序生命周期",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-管理应用程序生命周期",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"Electron"})," 的主进程中，你可以使用 ",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/app",target:"_blank",rel:"noopener noreferrer",children:"app"})," 模块来管理应用程序的生命周期，该模块提供了一整套的事件和方法，可以让你用来添加自定义的应用程序行为。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { app } = require('electron')\n// 当 Electron 完成初始化时触发\napp.on('ready', () => {  \n  app.quit()  \n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"app 的常用生命周期钩子如下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"will-finish-launching"}),"\xa0在应用完成基本启动进程之后触发。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ready"}),"\xa0当 electron 完成初始化后触发。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"window-all-closed"}),"\xa0所有窗口都关闭的时候触发，在 windows 和 linux 里，所有窗口都退出的时候",(0,s.jsx)(n.strong,{children:"通常"}),"是应用退出的时候。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"before-quit"}),"\xa0退出应用之前的时候触发。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"will-quit"}),"\xa0即将退出应用的时候触发。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"quit"}),"\xa0应用退出的时候触发。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["而我们通常会在 ",(0,s.jsx)(n.code,{children:"ready"})," 的时候执行创建应用窗口、创建应用菜单、创建应用快捷键等初始化操作。而在 ",(0,s.jsx)(n.code,{children:"will-quit"})," 或者 ",(0,s.jsx)(n.code,{children:"quit"})," 的时候执行一些清空操作，比如解绑应用快捷键。"]}),"\n",(0,s.jsxs)(n.p,{children:["特别的，在非 ",(0,s.jsx)(n.code,{children:"macOS"})," 的系统下，通常一个应用的所有窗口都退出的时候，也是这个应用退出之时。所以，可以配合 ",(0,s.jsx)(n.code,{children:"window-all-closed"})," 这个钩子来实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"app.on('window-all-closed', () => {\n  // 当操作系统不是darwin（macOS）的话\n  if (process.platform !== 'darwin') { \n    // 退出应用\n    app.quit()\n  }\n})\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"2-创建窗口",children:["2. 创建窗口",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-创建窗口",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["主进程的主要目的之一是使用\xa0",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/browser-window",target:"_blank",rel:"noopener noreferrer",children:"BrowserWindow"}),"\xa0模块创建和管理应用程序窗口。窗口管理是指创建、控制和管理应用程序中的窗口。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { BrowserWindow } = require('electron')  \n\n// 创建窗口\nconst win = new BrowserWindow({ width: 800, height: 1500 })  \nwin.loadURL('https://juejin.cn')  \n  \n// 窗口事件管理\nwin.on('closed', () => {\n  win = undefined;\n});\n\nwin.once('ready-to-show', () => {\n  win.show();\n});\n\n// 窗口的尺寸控制\nwin.minimize();\nwin.setSize({width: xxx, height: xxx});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["跟",(0,s.jsx)(n.code,{children:"app"}),"模块一样，",(0,s.jsx)(n.code,{children:"BrowserWindow"}),"也有很多常用的事件钩子，比如："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"closed"}),"\xa0当窗口被关闭的时候。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"focus"}),"\xa0当窗口被激活的时候。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"show"}),"\xa0当窗口展示的时候。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"hide"}),"\xa0当窗口被隐藏的时候。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"maxmize"}),"\xa0当窗口最大化时。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"minimize"}),"\xa0当窗口最小化时。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"3-调用原生-api",children:["3. 调用原生 API",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-调用原生-api",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["为了使 Electron 的功能不仅仅限于对网页内容的封装，主进程也添加了自定义的 API 来与用户的操作系统进行交互。比如，和 ",(0,s.jsx)(n.code,{children:"客户端 GUI"})," 相关的 ",(0,s.jsx)(n.code,{children:"右键菜单、窗⼝定制、系统托盘、Dock……"}),"，和 ",(0,s.jsx)(n.code,{children:"桌⾯环境集成"})," 相关的",(0,s.jsx)(n.code,{children:"系统通知、剪切板、系统快捷键、⽂件拖放……"}),"，和 ",(0,s.jsx)(n.code,{children:"设备"})," 相关的",(0,s.jsx)(n.code,{children:"电源监视、内存、CPU、屏幕"})," 等等。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { clipboard, globalShortcut, Menu } = require('electron')  \n\n// 向剪切板中写入文本\nclipboard.writeText('hello world', 'selection')  \nconsole.log(clipboard.readText('selection'))\n\n// 注册全局快捷键\nglobalShortcut.register('CommandOrControl+X', () => {  \n  console.log('CommandOrControl+X is pressed')  \n})\n\n// Dock\nconst dockMenu = Menu.buildFromTemplate([  \n  {  \n    label: '菜单一',  \n    click () { console.log('菜单一') }  \n  }, {  \n    label: '菜单二',  \n    submenu: [  \n      { label: '子菜单' },  \n    ]  \n  },  \n  { label: '菜单三' }  \n])\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"渲染进程",children:["渲染进程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染进程",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"渲染进程是 Electron 应用程序中负责展示用户界面的部分。每个渲染进程对应一个窗口（BrowserWindow）或者一个网页。通常由 HTML、CSS 和 JavaScript 构建用户界面。"}),"\n",(0,s.jsx)(n.p,{children:"渲染进程与主进程是分开的，它们之间通过 IPC（进程间通信）来进行通信。渲染进程可以通过一些特定的 Electron API 来与主进程进行交互，以实现诸如向主进程发送消息、接收主进程的指令等功能。"}),"\n",(0,s.jsxs)(n.p,{children:["其实在 ",(0,s.jsx)(n.code,{children:"Electron"})," 中，因为安全性等问题的考量，提供给 ",(0,s.jsx)(n.code,{children:"Renderer"})," 可用的 ",(0,s.jsx)(n.code,{children:"API"})," 是比较少的，我们可以简单看一下主进程和渲染进程可使用的 API 图："]}),"\n",(0,s.jsxs)(n.p,{children:["可以看到，能够在渲染进程中使用的 API 一共有 7 个。那么如果需要在渲染进程中使用主进程的 API 要怎么操作呢？",(0,s.jsx)(n.code,{children:"Electron"})," 本身额外提供了一个库 ",(0,s.jsx)(n.code,{children:"@electron/remote"}),"，使用这个库可以用来调用主进程的一些 API 能力："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 渲染进程\nconst { BrowserWindow } = require('@electron/remote')\nlet win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('https://juejin.cn')\n\n// 主进程\nrequire('@electron/remote/main').initialize()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["更多关于 ",(0,s.jsx)(n.code,{children:"@electron/remote"})," 的使用方式可以阅读它的文档：",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@electron/remote",target:"_blank",rel:"noopener noreferrer",children:"https://www.npmjs.com/package/@electron/remote"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["electron v14 版本后开始去掉了内置的 ",(0,s.jsx)(n.code,{children:"remote"})," 模块，",(0,s.jsx)(n.code,{children:"@electron/remote"})," 是 Electron 中内置 remote 模块的替代品。之所以移除 ",(0,s.jsx)(n.code,{children:"remote"})," 模块，其主要考量是："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"性能问题："})," 通过 ",(0,s.jsx)(n.code,{children:"remote"})," 模块可以访问主进程的对象、类型、方法，但这些操作都是跨进程的，跨进程操作性能上的损耗可能是进程内操作的几百倍甚至上千倍。假设你在渲染进程通过 ",(0,s.jsx)(n.code,{children:"remote"})," 模块创建了一个 ",(0,s.jsx)(n.code,{children:"BrowserWindow"})," 对象，不但你创建这个对象的过程很慢，后面你使用这个对象的过程也很慢。小到更新这个对象的属性，大到使用这个对象的方法，都是跨进程的。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"安全性问题："})," 使用 ",(0,s.jsx)(n.code,{children:"remote"})," 模块可以让渲染进程直接访问主进程的模块和对象，这可能导致一些潜在的安全风险。因为这种方式打破了主进程和渲染进程之间的隔离，可能存在恶意代码利用这一特性进行攻击或者不当操作。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"影子对象问题："})," 我们在渲染进程中通过 ",(0,s.jsx)(n.code,{children:"remote"})," 模块使用了主进程的某个对象，得到的是这个对象的影子（代理），是一个影子对象，它看起来像是真正的对象，但实际上不是。首先，这个对象原型链上的属性不会被映射到渲染进程的代理对象上。其次，类似 ",(0,s.jsx)(n.code,{children:"NaN"}),"、",(0,s.jsx)(n.code,{children:"Infinity"})," 这样的值不会被正确地映射给渲染进程，如果一个主进程方法返回一个 ",(0,s.jsx)(n.code,{children:"NaN"})," 值，那么渲染进程通过 ",(0,s.jsx)(n.code,{children:"remote"})," 模块访问这个方法将会得到 ",(0,s.jsx)(n.code,{children:"undefined"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"预加载脚本-preloadjs",children:["预加载脚本 preload.js",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#预加载脚本-preloadjs",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["预加载（preload）脚本包含了那些执行于渲染器进程中，且先于网页内容开始加载的代码。 在 ",(0,s.jsx)(n.code,{children:"preload.js"})," 中，我们不仅可以使用 Node API，还可以直接使用 Electron 渲染进程的 API 以及 DOM API，另外可以通过 ",(0,s.jsx)(n.code,{children:"IPC"})," 和主进程进行通信达成调用主进程模块的目的。",(0,s.jsx)(n.code,{children:"preload.js"})," 脚本虽运行于渲染器的环境中，却因此而拥有了更多的权限。"]}),"\n",(0,s.jsxs)(n.p,{children:["预加载脚本可以在\xa0",(0,s.jsx)(n.code,{children:"BrowserWindow"}),"\xa0构造方法中的\xa0",(0,s.jsx)(n.code,{children:"webPreferences"}),"\xa0选项里被附加到主进程。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { BrowserWindow } = require('electron')  \n// ...  \nconst win = new BrowserWindow({  \n  webPreferences: {  \n    preload: 'preload.js'  \n  }  \n})  \n// ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["因为预加载脚本与浏览器共享同一个全局\xa0",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Window",target:"_blank",rel:"noopener noreferrer",children:"Window"}),"\xa0接口，并且可以访问 Node.js API。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// preload.js\nconst fs = require('fs')\n\nwindow.myAPI = {  \n  exists: fs.exists\n}\n\nconsole.log(window.myAPI)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["注意：自从 ",(0,s.jsx)(n.code,{children:"Electron v12"})," 版本以后，添加了 ",(0,s.jsx)(n.code,{children:"webPreferences.contextIsolation = true"})," 的默认设置，这就意味着你通过 ",(0,s.jsx)(n.code,{children:"preload"})," 修改 ",(0,s.jsx)(n.code,{children:"window"})," 上的内容后，在渲染进程中并不能访问到。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// renderer.js\nconsole.log(window.myAPI)  // => undefined\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"关于-contextisolation-的介绍",children:["关于 contextIsolation 的介绍",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于-contextisolation-的介绍",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"contextIsolation"})," 是 Electron 中一个重要的安全特性，用于提高渲染进程的安全性。它的作用在于将渲染进程的 JavaScript 上下文（代码执行环境）与主进程隔离开来，以减少安全风险并加强安全性。"]}),"\n",(0,s.jsx)(n.p,{children:"举个\uD83C\uDF30："}),"\n",(0,s.jsxs)(n.p,{children:["假设有一个 ",(0,s.jsx)(n.code,{children:"Electron"})," 应用程序，其中有一个渲染进程需要执行一些文件系统操作，比如读取本地文件并在界面中显示。在未启用 ",(0,s.jsx)(n.code,{children:"contextIsolation"})," 的情况下，渲染进程可以直接访问 Node.js 的 ",(0,s.jsx)(n.code,{children:"fs"})," 模块来进行文件操作。但这样会存在安全风险，因为渲染进程可以执行任意的文件系统操作，",(0,s.jsx)(n.strong,{children:"比如文件删除"}),"，可能导致安全漏洞或恶意代码执行。"]}),"\n",(0,s.jsxs)(n.p,{children:["现在，启用了 ",(0,s.jsx)(n.code,{children:"contextIsolation"}),"，渲染进程无法直接访问 Node.js 的 ",(0,s.jsx)(n.code,{children:"fs"})," 模块。相反，你可以使用 ",(0,s.jsx)(n.code,{children:"preload"})," 选项来为渲染进程加载一个预加载的脚本，在这个脚本中可以安全地访问 Node.js 的 ",(0,s.jsx)(n.code,{children:"fs"})," 模块，并将需要的操作通过 ",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/context-bridge",target:"_blank",rel:"noopener noreferrer",children:"contextBridge"})," 模块封装成 API 提供给渲染进程。这样，渲染进程只能通过预加载的 API 来请求文件操作，而无法直接执行文件系统操作。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// preload.js\nconst { contextBridge } = require('electron')  \nconst fs = require('fs')\n  \ncontextBridge.exposeInMainWorld('myAPI', {  \n  exists: fs.exists  \n})\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// renderer.js\nconsole.log(window.myAPI)  \n// => { exists: Function }\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["更多关于 Electron 安全性的问题，我们将会在 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7302990019642261567/section/7304842580359905334",target:"_blank",rel:"noopener noreferrer",children:"《通用篇：Electron 应用安全性指南》"})," 章节详细介绍。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本小节主要介绍了关于 ",(0,s.jsx)(n.code,{children:"Electron"})," 的一些基础知识，包括 ",(0,s.jsx)(n.code,{children:"主进程"})," 、",(0,s.jsx)(n.code,{children:"渲染进程"}),"、",(0,s.jsx)(n.code,{children:"preload"})," 的一些用法和介绍。这些基础知识是我们后续开启实战篇的理论前提。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们文中也提了一嘴关于渲染进程如何使用主进程的模块，其实除了使用 ",(0,s.jsx)(n.code,{children:"@electron/remote"})," 模块外，我们还可以使用进程间的通信来解决，下面的章节将继续介绍如何实现 ",(0,s.jsx)(n.code,{children:"electron"})," 进程间的通信。"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC02%E7%AB%A0%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9AElectron%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.md"]={toc:[{text:"主进程（main） 和 渲染进程（renderer）",id:"主进程main-和-渲染进程renderer",depth:2},{text:"主进程",id:"主进程",depth:3},{text:"1. 管理应用程序生命周期",id:"1-管理应用程序生命周期",depth:4},{text:"2. 创建窗口",id:"2-创建窗口",depth:4},{text:"3. 调用原生 API",id:"3-调用原生-api",depth:4},{text:"渲染进程",id:"渲染进程",depth:3},{text:"预加载脚本 preload.js",id:"预加载脚本-preloadjs",depth:2},{text:"关于 contextIsolation 的介绍",id:"关于-contextisolation-的介绍",depth:3},{text:"总结",id:"总结",depth:2}],title:"第02章—基础篇：Electron的基础概念",headingTitle:"第02章—基础篇：Electron的基础概念",frontmatter:{}}}}]);