"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["48081"],{594769:function(e,n,t){t.r(n),t.d(n,{default:()=>m});var r=t(552676),s=t(740453);let o=t.p+"static/image/99097c600845e8ea0ddbf05584e1685b.4fec8b53.gif",a=t.p+"static/image/800650cb88bf1afc217ec79ebf8cfdd4.1b36457a.gif",c=t.p+"static/image/d2c62bd5692434a46236010bb6735270.22734daa.webp",l=t.p+"static/image/389a735ed81e46d4e14618f882198c8e.9923e44f.webp",i=t.p+"static/image/6fb887aaccce8872d0f419a171acd145.22734daa.webp",p=t.p+"static/image/9728ebc2cab912c0d0091b695f58c8e3.22734daa.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",img:"img",blockquote:"blockquote",ol:"ol",li:"li"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"65源码篇-_-手写-rsc上",children:["65.源码篇 _ 手写 RSC（上）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#65源码篇-_-手写-rsc上",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本篇我们从零开始，手写一个 React Server Component 实现。为了帮助大家理解 React Server Component 的出现背景，我们会从最原始的页面实现方式开始讲起，跟随着 React 的发展历史不断完善代码，最终实现 React Server Component。"}),"\n",(0,r.jsx)(n.p,{children:"现在就让我们开始吧。"}),"\n",(0,r.jsxs)(n.h2,{id:"步骤-1实现一个博客页面",children:["步骤 1：实现一个博客页面",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤-1实现一个博客页面",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先创建项目，运行以下命令，完成项目初始化："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"mkdir react-rsc && cd react-rsc\n\nnpm init\n\nnpm i tsx --save-dev\n\nnpm i express escape-html react react-dom --save\n"})}),"\n",(0,r.jsxs)(n.p,{children:["注：在",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309116396511133705",target:"_blank",rel:"noopener noreferrer",children:"《源码篇 | 手写 React SSR》"}),"，我们通过 webpack 和自定义配置实现了 JSX 语法的编译。本篇为了更加方便，我们将直接使用 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/tsx",target:"_blank",rel:"noopener noreferrer",children:"tsx"})," 进行处理，虽然文件会命名为 ",(0,r.jsx)(n.code,{children:".ts"}),"或 ",(0,r.jsx)(n.code,{children:".tsx"}),"，但我们并不会使用 TypeScript 语法，只是借助其对 JSX 语法的编译功能。"]}),"\n",(0,r.jsxs)(n.p,{children:["新建文件 ",(0,r.jsx)(n.code,{children:"index.ts"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import express from "express";\nimport { readFile } from "fs/promises";\nimport escapeHtml from \'escape-html\'\n\nconst app = express();\n\napp.get("/:route(*)", async (req, res) => {\n  const html = await htmlGenerator();\n  res.setHeader("Content-Type", "text/html");\n  res.end(html);\n});\n\nasync function htmlGenerator() {\n  const author = "YaYu";\n  const postContent = await readFile("./posts/hello.txt", "utf8");\n\n  return `<html>\n  <head>\n    <title>My blog</title>\n    <script src="https://cdn.tailwindcss.com"><\/script>\n  </head>\n  <body class="p-5">\n    <nav class="flex items-center justify-center gap-10 text-blue-600">\n      <a href="/">Home</a>\n    </nav>\n    <article class="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">\n      ${escapeHtml(postContent)}\n    </article>\n    <footer class="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">\n      (c) ${escapeHtml(author)}, ${new Date().getFullYear()}\n    </footer>\n  </body>\n</html>`;\n}\n\napp.listen(3000, (err) => {\n  if (err) return console.error(err);\n  return console.log(`Server is listening on 3000`);\n});\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["博客的具体内容我们会读取 ",(0,r.jsx)(n.code,{children:"/posts/hello.txt"}),"文件，所以新建 ",(0,r.jsx)(n.code,{children:"/posts/hello.txt"}),"，随便写入一些内容，比如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"<h1>Hello World!</h1>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"package.json"}),"文件中的脚本命令，添加代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'{\n  "scripts": {\n    "start": "tsx watch ./index.ts"\n  }\n}\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm start"}),"，此时效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"功能实现：React RSC 实现"}),"\n",(0,r.jsxs)(n.li,{children:["源码地址：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-1",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-1"})]}),"\n",(0,r.jsxs)(n.li,{children:["下载代码：",(0,r.jsx)(n.code,{children:"git clone -b react-rsc-1 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"效果上，我们实现的是一个博客页面的简化版，顶部是导航栏，底部是页脚，中间是具体的文章内容。"}),"\n",(0,r.jsx)(n.p,{children:"技术实现上，我们使用 express 起了一个服务器，在读取了 txt 文件的内容后，通过模板字符串的形式，直接返回了页面 HTML 内容。"}),"\n",(0,r.jsx)(n.p,{children:"值得注意的是，当我们读取完 txt 的内容后，使用了 escape-html 对内容进行了转义。这是一种常见的内容安全处理。麻烦的地方在于，所有写入内容的地方，都需要自己添加逻辑处理，难道就没有更加简单、便捷、安全的使用方式呢？"}),"\n",(0,r.jsxs)(n.h2,{id:"步骤-2发明-jsx",children:["步骤 2：发明 JSX",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤-2发明-jsx",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"为了解决这个问题，React 发明了 JSX。你可以把它理解成一种特殊的模板语言。使用 JSX，你可以在 JavaScript 中直接使用 HTML 标签，比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'const res = <html>\n  <head>\n    <title>My blog</title>\n  </head>\n  <body>\n    <nav>\n      <a href="/">Home</a>\n      <hr />\n    </nav>\n    <article>\n      {postContent}\n    </article>\n    <footer>\n      <hr />\n      <p><i>(c) {author}, {new Date().getFullYear()}</i></p>\n    </footer>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["其中变量使用 ",(0,r.jsx)(n.code,{children:"{}"}),"进行包裹。这种语法，无论是 JavaScript 还是 HTML 其实都不能直接识别，所以使用 JSX 语法还需要搭配编译器（比如 Babel）使用，Babel 会将代码编译成如下形式："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { jsx } from "react/jsx-runtime";\n\nconst res = jsx("html", {\n  children: [\n    jsx("head", {\n      children: jsx("title", {\n        children: "My blog"\n      })\n    }), \n  jsx("body", {\n    children: [...]\n  })]\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"之所以编译成这种函数执行的形式，是因为我们还需要在函数运行的时候读取外边的变量（就比如上图中的 postContent 和 author）。最终该函数会返回一个描述 HTML 的 JSON 对象（为了方便，我们就简称为 JSX 对象了），类似于如下这种形式："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// Slightly simplified\n{\n  $$typeof: Symbol.for(\"react.element\"), // Tells React it's a JSX element (e.g. <html>)\n  type: 'html',\n  props: {\n    children: [\n      {\n        $$typeof: Symbol.for(\"react.element\"),\n        type: 'head',\n        props: {\n          children: {\n            $$typeof: Symbol.for(\"react.element\"),\n            type: 'title',\n            props: { children: 'My blog' }\n          }\n        }\n      },\n      {\n        $$typeof: Symbol.for(\"react.element\"),\n        type: 'body',\n        props: {\n          children: [\n            {\n              $$typeof: Symbol.for(\"react.element\"),\n              type: 'nav',\n              props: {\n                children: [{\n                  $$typeof: Symbol.for(\"react.element\"),\n                  type: 'a',\n                  props: { href: '/', children: 'Home' }\n                }, {\n                  $$typeof: Symbol.for(\"react.element\"),\n                  type: 'hr',\n                  props: null\n                }]\n              }\n            },\n            {\n              $$typeof: Symbol.for(\"react.element\"),\n              type: 'article',\n              props: {\n                children: postContent\n              }\n            },\n            {\n              $$typeof: Symbol.for(\"react.element\"),\n              type: 'footer',\n              props: {\n                /* ...And so on... */\n              }              \n            }\n          ]\n        }\n      }\n    ]\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"所以我们写代码的时候，写的是："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const res = <html>...</html>\n"})}),"\n",(0,r.jsx)(n.p,{children:"到 JavaScript 具体执行的时候，其实是一个对象："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const res = {\n  $$typeof: Symbol.for(\"react.element\"),\n  type: 'html',\n  props: {\n    children: [ ... ]\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"但有了描述 HTML 的 JSX 对象还不够，我们还需要一个 render 函数，将 JSX 对象渲染为具体的 HTML，返回给客户端的应该是这个具体的 HTML。"}),"\n",(0,r.jsxs)(n.p,{children:["我们修改 ",(0,r.jsx)(n.code,{children:"index.ts"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import express from "express";\nimport { htmlGenerator } from "./generator";\nconst app = express();\n\napp.get("/:route(*)", async (req, res) => {\n  const html = await htmlGenerator();\n  res.setHeader("Content-Type", "text/html");\n  res.end(html);\n});\n\napp.listen(3000, (err) => {\n  if (err) return console.error(err);\n  return console.log(`Server is listening on 3000`);\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"generator.tsx"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { readFile } from "fs/promises";\nimport React from \'react\';\nimport { renderJSXToHTML } from \'./utils\'\n\nexport async function htmlGenerator() {\n  const author = "YaYu";\n  const postContent = await readFile("./posts/hello.txt", "utf8");\n\n  let jsx = <html>\n  <head>\n    <title>My blog</title>\n    <script src="https://cdn.tailwindcss.com"><\/script>\n  </head>\n  <body className="p-5">\n    <nav className="flex items-center justify-center gap-10 text-blue-600">\n      <a href="/">Home</a>\n    </nav>\n    <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">\n      { postContent }\n    </article>\n    <footer className="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">\n      (c) { author }, {new Date().getFullYear()}\n    </footer>\n  </body>\n</html>\n\n  return renderJSXToHTML(jsx);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"这里我们直接使用了 JSX 语法，tsx 会帮助我们进行编译，我们就不需要引入 Webpack 和 Babel 来处理了。"}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"utils.ts"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import escapeHtml from \'escape-html\'\n\nexport function renderJSXToHTML(jsx) {\n  if (typeof jsx === "string" || typeof jsx === "number") {\n    return escapeHtml(jsx);\n  } else if (jsx == null || typeof jsx === "boolean") {\n    return "";\n  } else if (Array.isArray(jsx)) {\n    return jsx.map((child) => renderJSXToHTML(child)).join("");\n  } else if (typeof jsx === "object") {\n    if (jsx.$$typeof === Symbol.for("react.element")) {\n      let html = "<" + jsx.type;\n      for (const propName in jsx.props) {\n        if (jsx.props.hasOwnProperty(propName) && propName !== "children") {\n          html += " ";\n          html += propName;\n          html += "=";\n          html += `"${escapeHtml(jsx.props[propName])}"`;\n        }\n      }\n      html += ">";\n      html += renderJSXToHTML(jsx.props.children);\n      html += "</" + jsx.type + ">";\n      html = html.replace(/className/g, "class")\n      return html;\n    } else throw new Error("Cannot render an object.");\n  } else throw new Error("Not implemented.");\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"renderJSXToHTML 的代码并不复杂，简单的来说，就是不断判断 jsx 对象节点的类型，递归处理，最终拼接得到一个 HTML 字符串。"}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm start"}),"，此时效果不变："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"功能实现：React RSC 实现"}),"\n",(0,r.jsxs)(n.li,{children:["源码地址：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-2",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-2"})]}),"\n",(0,r.jsxs)(n.li,{children:["下载代码：",(0,r.jsx)(n.code,{children:"git clone -b react-rsc-2 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"步骤-3发明组件",children:["步骤 3：发明组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤-3发明组件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这里我们写的是一篇博客页面，但其实每个博客页面内容都是相似的，有着相同的顶部导航和页脚，为了代码能够复用，React 引入了组件的概念，将重复的内容抽离成一个组件，用到的地方直接引入使用即可。"}),"\n",(0,r.jsxs)(n.p,{children:["我们来实现一下，新建 ",(0,r.jsx)(n.code,{children:"components.tsx"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React from \'react\';\n\nexport function BlogPostPage({ postContent, author }) {\n  return (\n    <html>\n    <head>\n      <title>My blog</title>\n      <script src="https://cdn.tailwindcss.com"><\/script>\n    </head>\n    <body className="p-5">\n      <nav className="flex items-center justify-center gap-10 text-blue-600">\n        <a href="/">Home</a>\n      </nav>\n      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">\n        { postContent }\n      </article>\n      <Footer author={author} />\n    </body>\n  </html>\n  );\n}\n\nexport function Footer({ author }) {\n  return (\n    <footer className="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">\n      (c) { author }, {new Date().getFullYear()}\n    </footer>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"这里我们将页脚抽离成 Footer 组件，然后在 BlogPostPage 组件中引入使用。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"generator.tsx"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { readFile } from "fs/promises";\nimport React from \'react\';\nimport { renderJSXToHTML } from \'./utils\'\nimport { BlogPostPage } from \'./components\'\n\nexport async function htmlGenerator() {\n  const author = "YaYu";\n  const postContent = await readFile("./posts/hello.txt", "utf8");\n  return renderJSXToHTML(<BlogPostPage postContent={postContent} author={author}/>);\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"此时页面会空白，查看其 HTML 如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["这是因为我们的 renderJSXToHTML 函数目前还只能识别普通的 HTML 标签，对于像 ",(0,r.jsx)(n.code,{children:"<BlogPostPage>"})," 这样的组件类型并不能处理。"]}),"\n",(0,r.jsx)(n.p,{children:"我们在写组件的时候，写的是一个函数，函数执行后才返回具体的 JSX 对象。所以我们在 render 的时候，需要判断节点是否是函数，如果是函数，就执行函数，渲染函数返回的 JSX 对象。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"utils.js"}),"中的 renderJSXToHTML 函数，完整代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import escapeHtml from \'escape-html\'\n\nexport function renderJSXToHTML(jsx) {\n  if (typeof jsx === "string" || typeof jsx === "number") {\n    return escapeHtml(jsx);\n  } else if (jsx == null || typeof jsx === "boolean") {\n    return "";\n  } else if (Array.isArray(jsx)) {\n    return jsx.map((child) => renderJSXToHTML(child)).join("");\n  } else if (typeof jsx === "object") {\n    if (jsx.$$typeof === Symbol.for("react.element")) {\n      // 普通 HTML 标签\n      if (typeof jsx.type === "string") {\n        let html = "<" + jsx.type;\n        for (const propName in jsx.props) {\n          if (jsx.props.hasOwnProperty(propName) && propName !== "children") {\n            html += " ";\n            html += propName;\n            html += "=";\n            html += `"${escapeHtml(jsx.props[propName])}"`;\n          }\n        }\n        html += ">";\n        html += renderJSXToHTML(jsx.props.children);\n        html += "</" + jsx.type + ">";\n        html = html.replace(/className/g, "class")\n        return html;\n      }\n      // 组件类型如 <BlogPostPage> \n      else if (typeof jsx.type === "function") {\n        const Component = jsx.type;\n        const props = jsx.props;\n        const returnedJsx = Component(props);\n        return renderJSXToHTML(returnedJsx); \n      } else throw new Error("Not implemented.");\n    } else throw new Error("Cannot render an object.");\n  } else throw new Error("Not implemented.");\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm start"}),"，此时效果不变："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"JSX 和组件不就是 React 的基础吗？从某种角度来讲，我们已经手写了一个 React 雏形。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"功能实现：React RSC 实现"}),"\n",(0,r.jsxs)(n.li,{children:["源码地址：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-3",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-3"})]}),"\n",(0,r.jsxs)(n.li,{children:["下载代码：",(0,r.jsx)(n.code,{children:"git clone -b react-rsc-3 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"步骤-4添加路由",children:["步骤 4：添加路由",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤-4添加路由",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["现在我们实现了一个博客内容页面，但我想实现的效果是，当访问 ",(0,r.jsx)(n.code,{children:"/"})," 的时候，展示博客文章列表，访问 ",(0,r.jsx)(n.code,{children:"/hello"})," 的时候，才展示 hello.txt 这篇文章的具体内容。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们再添加一篇文章，新建 ",(0,r.jsx)(n.code,{children:"/posts/earth.txt"}),"，内容随意，比如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"<h1>Hello Earth!</h1>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"components.tsx"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'import React from \'react\';\n\nexport function Layout({ children }) {\n  const author = "YaYu";\n  return (\n    <html>\n    <head>\n      <title>My blog</title>\n      <script src="https://cdn.tailwindcss.com"><\/script>\n    </head>\n    <body className="p-5">\n      <nav className="flex items-center justify-center gap-10 text-blue-600">\n        <a href="/">Home</a>\n      </nav>\n      <main>{children}</main>\n      <Footer author={author} />\n    </body>\n  </html>\n  );\n}\n\nexport function IndexPage({ slugs, contents }) {\n  return (\n    <section>\n      <h1>Blog List:</h1>\n      <div>\n        {slugs.map((slug, index) => (\n          <section key={slug} className="mt-4">\n            <a className="text-blue-600" href={"/" + slug}>{slug}</a>\n            <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{contents[index]}</article>\n          </section>\n        ))}\n      </div>\n    </section>\n  );\n}\n\nexport function PostPage({ slug, content }) {\n  return (\n    <section>\n      <a className="text-blue-600" href={"/" + slug}>{slug}</a>\n      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{content}</article>\n    </section>\n  );\n}\n\nexport function Footer({ author }) {\n  return (\n    <footer className="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">\n      (c) { author }, {new Date().getFullYear()}\n    </footer>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"这里我们新建了 4 个组件，其中 Layout 负责基础的 HTML 样式，包含顶部的导航栏和页脚，Footer 负责页脚。IndexPage 负责首页的文章样式，PostPage 负责具体文章页面的样式。"}),"\n",(0,r.jsxs)(n.p,{children:["当访问 ",(0,r.jsx)(n.code,{children:"/"})," 的时候，应该导航至 ",(0,r.jsx)(n.code,{children:"IndexPage"}),"，当访问 ",(0,r.jsx)(n.code,{children:"/xxx"})," 的时候，应该导航至 ",(0,r.jsx)(n.code,{children:"PostPage"}),"，这个功能就叫做路由（Router），不过现在我们先用一个 matchRouter 函数实现。"]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"index.ts"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import express from "express";\nimport { htmlGenerator } from "./generator";\nconst app = express();\n\napp.get("/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const html = await htmlGenerator(url);\n  res.setHeader("Content-Type", "text/html");\n  res.end(html);\n});\n\napp.listen(3000, (err) => {\n  if (err) return console.error(err);\n  return console.log(`Server is listening on 3000`);\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"我们获取了当前的页面地址，并将其传入 htmlGenerator 函数。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"generator.tsx"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { readFile, readdir } from "fs/promises";\nimport React from \'react\';\nimport { renderJSXToHTML } from \'./utils\'\nimport { Layout, IndexPage, PostPage } from \'./components\'\n\nexport async function htmlGenerator(url) {\n  const content = await readFile("./posts/hello.txt", "utf8");\n  const page = await matchRoute(url);\n  return renderJSXToHTML(<Layout>{page}</Layout>);\n}\n\nasync function matchRoute(url) {\n  if (url.pathname === "/") {\n    const files = await readdir("./posts");\n    const slugs = files.map((file) => file.slice(0, file.lastIndexOf(".")));\n    const contents = await Promise.all(\n      slugs.map((slug) =>\n        readFile("./posts/" + slug + ".txt", "utf8")\n      )\n    );\n    return <IndexPage slugs={slugs} contents={contents} />;\n  } else {\n    const slug = url.pathname.slice(1);\n    const content = await readFile("./posts/" + slug + ".txt", "utf8");\n    return <PostPage slug={slug} content={content} />;\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"我们写了一个 matchRoute 函数，根据 URL 返回不同的组件（IndexPage 或 PostPage），然后将组件作为 children 传入 Layout 组件中，得到最终的 JSX 对象。"}),"\n",(0,r.jsx)(n.p,{children:"此时交互效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"react-rsc.gif"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"功能实现：React RSC 实现"}),"\n",(0,r.jsxs)(n.li,{children:["源码地址：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-4",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-4"})]}),"\n",(0,r.jsxs)(n.li,{children:["下载代码：",(0,r.jsx)(n.code,{children:"git clone -b react-rsc-4 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"步骤-5异步组件与-router",children:["步骤 5：异步组件与 Router",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤-5异步组件与-router",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"其实目前的组件抽象还是有点问题的，IndexPage 和 PostPage 的文章样式（图中紫色部分）其实是重复的，我们应该抽离一个 Post 组件，然后 IndexPage 和 PostPage 引用 Post 组件。"}),"\n",(0,r.jsx)(n.p,{children:"不仅如此，现在我们在 matchRoute 这个函数中实现了路由匹配和获取数据（readdir、readFile），但其实没有必要，因为反正都是在服务端运行，获取数据完全可以放在具体的 Post 组件中运行，这样我们就可以将获取数据的代码从 matchRoute 中分离出来，让 matchRoute 如它的函数名一样，专注于路由匹配，而非掺杂数据获取的代码。"}),"\n",(0,r.jsx)(n.p,{children:"直接说似乎有点抽象，让我们写代码吧。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"components.tsx"}),"，完整代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'import React from \'react\';\nimport { readFile, readdir } from "fs/promises";\n\nexport function Layout({ children }) {\n  const author = "YaYu";\n  return (\n    <html>\n    <head>\n      <title>My blog</title>\n      <script src="https://cdn.tailwindcss.com"><\/script>\n    </head>\n    <body className="p-5">\n      <nav className="flex items-center justify-center gap-10 text-blue-600">\n        <a href="/">Home</a>\n      </nav>\n      <main>{children}</main>\n      <Footer author={author} />\n    </body>\n  </html>\n  );\n}\n\nexport async function IndexPage() {\n  const files = await readdir("./posts");\n  const slugs = files.map((file) =>\n    file.slice(0, file.lastIndexOf("."))\n  );\n\n  return (\n    <section>\n      <h1>Blog List:</h1>\n      <div>\n        {slugs.map((slug, index) => <Post key={index} slug={slug} />)}\n      </div>\n    </section>\n  );\n}\n\nexport function PostPage({ slug }) {\n  return <Post slug={slug} />;\n}\n\nasync function Post({ slug }) {\n  let content = await readFile("./posts/" + slug + ".txt", "utf8");\n  return (\n    <section>\n      <a className="text-blue-600" href={"/" + slug}>{slug}</a>\n      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{content}</article>\n    </section>\n  )\n}\n\nexport function Footer({ author }) {\n  return (\n    <footer className="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">\n      (c) { author }, {new Date().getFullYear()}\n    </footer>\n  );\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，我们抽离了一个 Post 组件，并将数据读取放在了 IndexPage 和 Post 组件中实现。因此我们的 matchRouter 函数得以简化，我们将函数替换为 Router 组件，修改 ",(0,r.jsx)(n.code,{children:"generator.tsx"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { readFile, readdir } from \"fs/promises\";\nimport React from 'react';\nimport { renderJSXToHTML } from './utils'\nimport { Layout, IndexPage, PostPage } from './components'\n\nexport async function htmlGenerator(url) {\n  return renderJSXToHTML(<Router url={url} />);\n}\n\nfunction Router({ url }) {\n  let page;\n  if (url.pathname === \"/\") {\n    page = <IndexPage />;\n  } else {\n    const slug = url.pathname.slice(1);\n    page = <PostPage slug={slug} />;\n  }\n  return <Layout>{page}</Layout>;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时页面渲染失败，是因为我们的组件函数使用了 async，所以渲染的时候，也要对应进行处理，修改 ",(0,r.jsx)(n.code,{children:"utils.ts"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import escapeHtml from \'escape-html\'\n\nexport async function renderJSXToHTML(jsx) {\n  if (typeof jsx === "string" || typeof jsx === "number") {\n    return escapeHtml(jsx);\n  } else if (jsx == null || typeof jsx === "boolean") {\n    return "";\n  } else if (Array.isArray(jsx)) {\n    // 这里添加了 await 和 Promise.all\n    const childHtmls = await Promise.all(\n      jsx.map((child) => renderJSXToHTML(child))\n    );\n    return childHtmls.join("");\n  } else if (typeof jsx === "object") {\n    if (jsx.$$typeof === Symbol.for("react.element")) {\n      if (typeof jsx.type === "string") {\n        let html = "<" + jsx.type;\n        for (const propName in jsx.props) {\n          if (jsx.props.hasOwnProperty(propName) && propName !== "children") {\n            html += " ";\n            html += propName;\n            html += "=";\n            html += `"${escapeHtml(jsx.props[propName])}"`;\n          }\n        }\n        html += ">";\n        // 这里添加了 await\n        html += await renderJSXToHTML(jsx.props.children);\n        html += "</" + jsx.type + ">";\n        html = html.replace(/className/g, "class")\n        return html;\n      }\n      else if (typeof jsx.type === "function") {\n        const Component = jsx.type;\n        const props = jsx.props;\n        // 这里添加了 await\n        const returnedJsx = await Component(props);\n        return renderJSXToHTML(returnedJsx); \n      } else throw new Error("Not implemented.");\n    } else throw new Error("Cannot render an object.");\n  } else throw new Error("Not implemented.");\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"此时页面正常渲染："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"react-rsc.gif"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"功能实现：React RSC 实现"}),"\n",(0,r.jsxs)(n.li,{children:["源码地址：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-5",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-5"})]}),"\n",(0,r.jsxs)(n.li,{children:["下载代码：",(0,r.jsx)(n.code,{children:"git clone -b react-rsc-5 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"回过头来看我们的 Router 组件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function Router({ url }) {\n  let page;\n  if (url.pathname === "/") {\n    page = <IndexPage />;\n  } else {\n    const slug = url.pathname.slice(1);\n    page = <PostPage slug={slug} />;\n  }\n  return <Layout>{page}</Layout>;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"它接收当前 URL，然后返回对应的组件。用过 React-Router 的同学可能知道，React-Rouer 有一个 StaticRouter，用于处理 node 环境下的路由，基本用法如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import * as React from "react";\nimport * as ReactDOMServer from "react-dom/server";\nimport { StaticRouter } from "react-router-dom/server";\nimport http from "http";\n\nfunction requestHandler(req, res) {\n  let html = ReactDOMServer.renderToString(\n    <StaticRouter location={req.url}>\n      {/* The rest of your app goes here */}\n    </StaticRouter>\n  );\n\n  res.write(html);\n  res.end();\n}\n\nhttp.createServer(requestHandler).listen(3000);\n'})}),"\n",(0,r.jsx)(n.p,{children:"你可以发现非常相似，也是接收当前 URL，返回对应的组件。从某种角度来说，我们实现了一个 React-Router 的雏形。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["本篇我们从最原始的页面开发方式开始，讲述了 React 和 React-Router 的起源背景，手写了 React 和 React-Router 最基础的实现方式。因为这个例子的所有代码都运行在服务端，所以这其实也是 React SSR 的基础实现，甚至比 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309116396511133705",target:"_blank",rel:"noopener noreferrer",children:"《源码篇 | 手写 React SSR》"})," 实现的还要基础，就比如我们手写的 renderJSXToHTML 对应的其实就是 root.render 函数。"]}),"\n",(0,r.jsx)(n.p,{children:"不过至此，其实还没有涉及到任何 RSC 相关的内容，因为我们的进度相当于在追溯 React 的发展历史，目前才刚发展到 React SSR，下个阶段才开始进入 React Server Components 呢，快开始进入下一篇吧！"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}let m=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F65.%E6%BA%90%E7%A0%81%E7%AF%87%20_%20%E6%89%8B%E5%86%99%20RSC%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"步骤 1：实现一个博客页面",id:"步骤-1实现一个博客页面",depth:2},{text:"步骤 2：发明 JSX",id:"步骤-2发明-jsx",depth:2},{text:"步骤 3：发明组件",id:"步骤-3发明组件",depth:2},{text:"步骤 4：添加路由",id:"步骤-4添加路由",depth:2},{text:"步骤 5：异步组件与 Router",id:"步骤-5异步组件与-router",depth:2},{text:"总结",id:"总结",depth:2}],title:"65.源码篇 _ 手写 RSC（上）",headingTitle:"65.源码篇 _ 手写 RSC（上）",frontmatter:{}}}}]);