"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["26529"],{198330:function(n,e,r){r.r(e),r.d(e,{default:()=>h});var s=r(552676),t=r(740453);let i=r.p+"static/image/bde3ae0555ef70a6786d31dc3c1b9a8d.2f1ec354.webp",l=r.p+"static/image/094a38c2b64302badbfbadb34f93ca7e.9e0dd2e8.webp",a=r.p+"static/image/fe29153540525deb1383ceb060ac3d75.f0108f7a.webp",o=r.p+"static/image/67442c6503b7be440f1933eebb743e96.a2d3b814.webp";function d(n){let e=Object.assign({p:"p",strong:"strong",ol:"ol",li:"li",h1:"h1",a:"a",pre:"pre",code:"code",img:"img",h2:"h2",blockquote:"blockquote",ul:"ul",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,t.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"Ant Design 的 Form 表单组件是我们最常用的组件之一，它可以帮助我们数据录入、校验等功能。"}),"\n",(0,s.jsxs)(e.p,{children:["大多数开发者认为 Form 表单使用起来非常方便，那是因为组件的内部承担了许多功能，比如",(0,s.jsx)(e.strong,{children:"状态管理"}),"、",(0,s.jsx)(e.strong,{children:"状态分配"}),"、",(0,s.jsx)(e.strong,{children:"表单验证"}),"等诸多环节。接下来我们一起看看具体如何实现一个表单功能。"]}),"\n",(0,s.jsx)(e.p,{children:"在正式开始前，请大家带着以下 2 个小问题阅读："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Form 组件是如何管理整体的数据流，为什么能从 Form 中获取表单控件的值？"}),"\n",(0,s.jsx)(e.li,{children:"Form.Item 的 name 属性如何替代表单控件（如：Input、Select）的 value、onChange 属性，使其受控？"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"先附上一张知识图谱，正式进入 Form 组件的学习："}),"\n",(0,s.jsxs)(e.h1,{id:"17实践篇表单组件设计上整体设计与流程",children:["17.实践篇｜表单组件设计（上）：整体设计与流程",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17实践篇表单组件设计上整体设计与流程",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在设计之前，我们以 Ant Design 中的 Form 为例，来看看一个基本的表单长什么样，又具备什么样的功能（文件位置：example/AntDForm）："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'  <Form\n    initialValues={{ book: "玩转 React Hooks" }}\n    onFinish={(data: any) => {\n      console.log("表单数据:", data);\n    }}\n    onReset={() => {\n      console.log("重制表单成功");\n    }}\n  >\n    <Form.Item label="小册名称" name="book">\n      <Input placeholder="请输入小册名称" />\n    </Form.Item>\n\n    <Form.Item label="作者" name="name">\n      <Input placeholder="请输入作者" />\n    </Form.Item>\n\n    <Form.Item wrapperCol={{ offset: 8, span: 16 }}>\n      <Button type="primary" htmlType="submit">\n        提交\n      </Button>\n      <Button style={{ marginLeft: 4 }} htmlType="reset">\n        重制\n      </Button>\n    </Form.Item>\n  </Form>\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:"img.gif"})}),"\n",(0,s.jsxs)(e.p,{children:["在这个基础表单案例中，可以大体将表单分为 ",(0,s.jsx)(e.code,{children:"Form => Form.Item => 表单控件"})," 三层结构，分别承担不同的作用，如："]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Form 组件：满足原生 form 表单功能，具备提交、重置、初始化、管理表单整体的数据结构等。"}),"\n",(0,s.jsx)(e.li,{children:"Form.Item 组件：具备 label 功能（表单左侧的展示）、name 功能（对应整体数据的传递）、校验等功能属性。"}),"\n",(0,s.jsxs)(e.li,{children:["表单控件：可以是各种数据录入组件（如：Input、Select），在不影响原本功能的前提下，需要将数据内容通过 Form.Item 绑定，由 Form.Item 控制 value、onChange 等属性，而",(0,s.jsx)(e.strong,{children:"不是自身绑定触发事件"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"将示例转化成关系图，如下所示："}),"\n",(0,s.jsx)(e.p,{children:"接下来，我们就一步一步实现出自己的 Form 组件。"}),"\n",(0,s.jsxs)(e.h1,{id:"整体布局",children:["整体布局",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#整体布局",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"经过上面的示例，我们需要创建 Form 和 Form.Item 组件作为容器，表单控件需要通过包裹的形式（children 属性）进行展示。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"大体结构为："})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// Form\n<form> // 满足原生的 form 表单\n  {children} // 包裹 Form.Item\n</form>\n\n// Form.Item\n<Layout>   // 布局组件\n  {children}  // 包裹表单控件\n</Layout>\n"})}),"\n",(0,s.jsx)(e.p,{children:"其中，Layout 组件属于布局组件，可控制表单的样式。为了让后续的效果更加好看，我们在这里简单处理下，可通过 Col 和 Row 进行宽度的设置，如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// Layout\nimport { Col, Row } from "antd";\n\nconst Index = ({ children, label }: any) => {\n  return (\n    <>\n      <Row gutter={8}>\n        <Col\n          span={4}\n          style={{ textAlign: "right", lineHeight: "32px", fontSize: 14 }}\n        >\n          {label ? label + "：" : ""}\n        </Col>\n        <Col span={9}> {children}</Col>\n      </Row>\n      <div style={{ height: 12 }}></div>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果："})}),"\n",(0,s.jsxs)(e.h2,{id:"提示语",children:["提示语",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#提示语",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"提示语也是表单常见的功能之一，也相对简单，只需要通过 tooltip 字段控制配合即可，如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'// Layout\nimport { Col, Row } from "antd";\n\nconst Index = ({ children, label }: any) => {\n  return (\n    <>\n      <Row gutter={8}>\n         <Col\n          span={4}\n          style={{ textAlign: "right", lineHeight: "32px", fontSize: 14 }}\n        >\n          {label || ""}\n          {tooltip && (\n            <Tooltip title={tooltip}>\n              <QuestionCircleOutlined style={{ margin: "0 3px" }} />\n            </Tooltip>\n          )}\n          {label && "："}\n        </Col>\n        <Col span={9}> {children}</Col>\n      </Row>\n      <div style={{ height: 12 }}></div>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:"效果："}),"\n",(0,s.jsxs)(e.h1,{id:"数据管理与通信",children:["数据管理与通信",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据管理与通信",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在整个的表单的设计中，最核心点莫过于",(0,s.jsx)(e.strong,{children:"数据的状态管理"}),"。数据源如同整个表单的大脑，因此掌握好数据源是我们首要解决的问题。"]}),"\n",(0,s.jsx)(e.p,{children:"其中，Form 组件需要承担表单的数据流向，当表单控件的值发生变化时，Form 管理的数据流也应该发生对应的改变。"}),"\n",(0,s.jsxs)(e.p,{children:["除此之外，Form 组件还需要承担",(0,s.jsx)(e.strong,{children:"状态下发"}),"的作用，不仅可以管理这些数据，也要让这些数据通过 Form.Item 的 name 属性控制对应的表单控件，使其成为",(0,s.jsx)(e.strong,{children:"受控"}),"，这样做的目的是：可以自由传递 value，也能得到最新的 value，向上传递。"]}),"\n",(0,s.jsx)(e.p,{children:"因此，我们通过 useForm （自定义 Hooks）来集中管理表单的数据，通过对应的实例，暴露对应的方法，在 Form、FormItem 组件中传递数据，更好地帮助管理表单。 如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import { useRef } from "react";\nimport { FormInstance, DataProps } from "./interface.d";\nimport FormStore from "./FormStore";\n\nconst useForm = () => {\n  const formRef = useRef<FormInstance | null>();\n\n  if (!formRef.current) {\n    // 创建一个实例，帮我们获取对应的方法\n    formRef.current = new FormStore().getDetail();\n  }\n\n  return [formRef.current];\n};\n\nexport default useForm;\n'})}),"\n",(0,s.jsx)(e.p,{children:"其中 FormStore 是 useForm 的核心，而 getDetail 用于暴露 FormStore 的方法，防止将多余的方法暴露出来。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"此外，Form 和 Form.Item 组件可能存在深层的嵌套关系，所以我们可以通过 context（ createContext + useContext ）跨层级方式传递数据。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"数据如何通信",children:["数据如何通信？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据如何通信",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["通过上面的分析，我们需要将整个表单的数据源通过 useForm 来保存，但数据是通过表单控件而来，换言之我们需要将表单控件",(0,s.jsx)(e.strong,{children:"受控"}),"，使 Form 组件进行状态下发，精确控制对应的表单控件。"]}),"\n",(0,s.jsx)(e.p,{children:"那么，如何在不改变结构的情况下，还能使组件受控，就变成了一个有趣的点，我们先来看看通常情况下如何让组件受控："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"  <Input value={value} onChange={(e) => setValue(e.target.value)} />\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在通常情况下，Input 受控，需要 ",(0,s.jsx)(e.code,{children:"value"})," 和 ",(0,s.jsx)(e.code,{children:"onChange"})," 属性的帮助，但在表单的场景中，并不需要通过 value 和 onChange 进行控制，主要原因有以下两点："]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"操作麻烦，不能确定具体表单控件的个数，如果每个控件都需要配置，比较麻烦。"}),"\n",(0,s.jsx)(e.li,{children:"破坏结构，相当于增加的两个属性是必须存在的，这样做会破坏表单控件的原有结构。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"所以，我们并不希望通过 value、onChange 直接控制，而是通过 Form.Item 中的 name 属性来代替 value 和 onChange。为达到这一目的，就需要 React.cloneElement 的帮助，将这两个属性强行剥离出来，使组件受控。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"问：React.cloneElement 是什么？"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"答：cloneElement 可以克隆并返回一个新的 React 元素。其结构为："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"React.createElement(element, [props], [...children])"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"element："})," 一个",(0,s.jsx)(e.strong,{children:"有效的 React 元素"}),"，大部分情况下是 JSX 节点；"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"props："})," 对象或者为 null，如果存在，则会赋值给 element，如果不存在，则保留原来的 props；"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"children："})," 零个或多个子节点，可以是任何 React 节点。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"举个小例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'import React from "react";\n\nconst Index: React.FC = () => {\n  const children = React.cloneElement(\n    <div>大家好，我是小杜杜，一起玩转Hooks吧！</div>,\n    {\n      book: "玩转 React Hooks",\n    }\n  );\n\n  console.log(children);\n  return <>{children}</>;\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(e.p,{children:"打印下 children 的结果："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"可以看出，React.cloneElement 将 book 这个属性赋值给了 div，而  children 实际上等价于："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'  const children = (\n    <div book="玩转 React Hooks">大家好，我是小杜杜，一起玩转Hooks吧！</div>\n  );\n'})}),"\n",(0,s.jsx)(e.p,{children:"所以，我们可以通过 React.cloneElement 给表单控件加入 value、onChange 事件，使其受控。"}),"\n",(0,s.jsxs)(e.h2,{id:"检查-children-元素",children:["检查 children 元素",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#检查-children-元素",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在 React.cloneElement 要注意一个点，就是它的第一个参数 ",(0,s.jsx)(e.code,{children:"element"}),"，这个参数代表为：",(0,s.jsx)(e.strong,{children:"有效的 React 元素"}),"，换言之，Form.Item 所包裹的表单控件必须要符合这个条件。"]}),"\n",(0,s.jsx)(e.p,{children:"而对于 Form.Item 来说，表单控件就是 children 属性，但 children 属性可能具备多种情况，比如字符串、单节点、多节点等情况，不同的情况，children 的形式不同，如："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"很明显，只有单节点的情况才符合 React.cloneElement 的条件，至于其他情况，我们均不处理，只需正常展示即可。"}),"\n",(0,s.jsx)(e.p,{children:"单节点的本质是 React 元素，所以我们可以借助 React.isValidElement 来帮助我们判别下是否属于有效的 React 元素，如果是，则对其受控，如果不是，则不处理。如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'const FormItem = (props: any) => {\n  const { name, children } = props;\n  const update = useUpdate();\n  \n  const contextValue = useContext(FormContext);\n  const { getFieldValue, dispatch, registerField, unRegisterField } = contextValue;\n  \n  let childrenPro;\n\n  // 利用 isValidElement 来判断传递的数据是否是 React.ReactElement. 注意他可以判断多节点的情况，和无值的情况\n  if (isValidElement(children) && name) {\n    \n    // 利用 cloneElement 给传递的组件加入 value 和 onChange 属性，剥离出对应的方法\n    childrenPro = cloneElement(children as React.ReactElement, {\n      value: getFieldValue(name),\n      onChange: (v: any) => {\n        let payload: any = {};\n        payload[name] = v.target.value;\n\n        // 更新 store 中的值\n        dispatch({\n          type: "updateValue",\n          name\n          ,\n          value: v.target?.value,\n        });\n\n        update(); // 触发更新\n      },\n    });\n  } else {\n    childrenPro = children;\n  }\n\n  return <Layout {...props}>{childrenPro}</Layout>;\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:"在 cloneElement 中，共涉及三个部分，分别是："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"getFieldValue："})," 获取对应表单的 value；"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"dispatch："})," 触发更新，用于更新 useForm 中的 store；"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"update："})," 强制刷新表单控件（有缺陷，后续会讲到）。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"值的获取和更新",children:["值的获取和更新",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#值的获取和更新",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"当学习完 cloneElement 和 isValidElement 后，值的获取和更新就变得非常简单，只要简单处理下 useForm 的核心：FormStore 即可。如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'class FormStore {\n  store: DataProps = {}; // 管理表单的整体数据\n\n  // 用于暴露方法\n  public getDetail = (): FormInstance => ({\n    getFieldValue: this.getFieldValue,\n    dispatch: this.dispatch,\n  });\n\n  // 获取对应的值\n  getFieldValue = (name: NameProps) => {\n    return this.store[name];\n  };\n\n  // 触发更新\n  dispatch = (action: ReducerAction) => {\n    switch (action.type) {\n      case "updateValue": {\n        const { name, value } = action;\n        this.updateValue(name, value);\n        break;\n      }\n      default:\n    }\n  };\n\n  // 更新\n  updateValue = (name: NameProps, value: any) => {\n    this.store = {\n      ...this.store,\n      [name]: value\n    };\n  };\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"只需要一个 store 变量去整体维护表单的值即可。"}),"\n",(0,s.jsxs)(e.h2,{id:"强制更新表单",children:["强制更新表单",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#强制更新表单",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"当我们使用 dispatch 后，可以通过 useUpdate 实现对应控件的更新，但这么做存在一个缺陷：更新表单的操作，并不在 useForm 中，如果之后的操作涉及到更新（如：重置），是不是还要单独处理一套新的逻辑？"}),"\n",(0,s.jsx)(e.p,{children:"很明显，这样做多此一举，所以我们将更新的逻辑单独存储在 FormStore 中（update_store），有需要的话直接调用即可。"}),"\n",(0,s.jsx)(e.p,{children:"所以，我们需要记录当前的表单控件，一个 name 对应一个表单控件，同时在 Form.Item 进行注册和卸载，将更新方法进行保存。"}),"\n",(0,s.jsx)(e.p,{children:"然后，当值发生改变后，判断对应的表单控件进行控制，执行更新方法，使视图发生改变。如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// Form.Item\nconst FormItem = (props: any) => {\n  const contextValue = useContext(FormContext);\n  const { getFieldValue, dispatch, registerField, unRegisterField } =\n    contextValue;\n\n  // 优化\n  const updateChange = useCreation(() => {\n    return {\n      updateValue: () => update(),\n    };\n  }, [contextValue]);\n\n  useEffect(() => {\n    // 注册\n    name && registerField(name, updateChange);\n    return () => {\n      //卸载\n      name && unRegisterField(name);\n    };\n  }, [updateChange]);\n  \n  ...\n}\n\n// FormStore\nclass FormStore {\n  update_store: DataProps = {}; // 保存更新的对象\n  \n  // 用于暴露方法\n  public getDetail = (): FormInstance => ({\n    unRegisterField: this.unRegisterField,\n    registerField: this.registerField,\n    ...\n  });\n  \n    // 注册表单方法\n  registerField = (name: NameProps, updateChange: DataProps) => {\n    this.update_store[name] = updateChange;\n  };\n\n  // 卸载表单方法\n  unRegisterField = (name: NameProps) => {\n    delete this.update_store[name];\n  };\n  \n    // 更新\n  updateValue = (name: NameProps, value: any) => {\n    this.store = {\n      ...this.store,\n      [name]: value,\n    };\n\n    this.updateStoreField(name);\n  };\n\n  // 更新对应的表单\n  updateStoreField = (name: NameProps) => {\n    const update = this.update_store[name];\n    if (update) update?.updateValue();\n  };\n}\n"})}),"\n",(0,s.jsxs)(e.h1,{id:"表单的基本操作",children:["表单的基本操作",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#表单的基本操作",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"表单的基本操作有：初始化、提交、重置三个功能，简单分析下对应的功能点，来帮助我们更好地掌握表单。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"initialValues："})," 初始化，如果存在，则赋值给 FormStore 中的 store，并将值进行保留，用于重置；"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"onFinish："})," 提交，将 store 的数据传递给 onFinish；"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"onReset："})," 重置，进行表单重置，如果存在 initialValues，则设为初始化值。"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"初始化",children:["初始化",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在初始化的过程中，我们将 initialValues（初始值）传入给 useForm，并将其赋到 FormStore 中的 store 和 initialValues 中。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// Form\nconst [formRef] = useForm(initialValues);\n\n// useForm\nconst useForm = (initialValues: DataProps) => {\n  ...\n  if (!formRef.current) {\n    formRef.current = new FormStore(initialValues).getDetail();\n  }\n  ...\n};\n\n// FormStore\nclass FormStore {\n  ...\n  initialValues: DataProps = {}; // 保存初始值\n\n  constructor(initialValues: DataProps) {\n    this.store = initialValues;\n    this.initialValues = initialValues;\n  }\n  ...\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"提交重置",children:["提交、重置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#提交重置",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"跟刷新的逻辑一样，我们希望 useForm 去统一管理表单的提交和重置，将 onFinish 和 onReset 通过 setConfigWays 保留到 FormStore 的 configWays 中，然后再提交和重置的时候进行调用即可。如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// Form\nconst Index = (props: FormProps) => {\n  ...\n  formRef.setConfigWays({\n    onFinish,\n    onReset,\n  });\n\n  return (\n    <form\n      {...payload}\n      onSubmit={(e) => {\n        // 阻止默认事件\n        e.preventDefault();\n        e.stopPropagation();\n        formRef.submit();\n      }}\n      onReset={(e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        formRef.resetFields(); /* 重置表单 */\n      }}\n    >\n      <FormContext.Provider value={formRef}>{children}</FormContext.Provider>\n    </form>\n  );\n};\n\n// FormStore\nclass FormStore {\n   ...\n   configWays: ConfigWayProps = {}; // 收录对应的方法集合\n   ...\n    \n  // 设置方法区间\n  setConfigWays = (configWays: ConfigWayProps) => {\n    this.configWays = configWays;\n  };\n\n  // 用于表单提交\n  submit = () => {\n    const { onFinish } = this.configWays;\n\n    onFinish && onFinish(this.store);\n  };\n\n  // 重置表单\n  resetFields = () => {\n    const { onReset } = this.configWays;\n    Object.keys(this.store).forEach((key) => {\n      // 重置表单的时候，如果有初始值，就用初始值，没有就删除\n      this.initialValues[key]\n        ? (this.store[key] = this.initialValues[key])\n        : delete this.store[key];\n      this.updateStoreField(key);\n    });\n    onReset && onReset();\n  };\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样，一个基本的表单组件就完成了，来看看整体效果："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:i,alt:"img3.gif"})}),"\n",(0,s.jsxs)(e.h1,{id:"表单核心formstore",children:["表单核心：FormStore",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#表单核心formstore",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在整个表单系统中，我们通过 useForm 中的 FormStore 去管理整个表单，所以，FormStore 是 Form 组件的核心。"}),"\n",(0,s.jsxs)(e.p,{children:["FormStore 不但承担表单的数据流向，还通过 ",(0,s.jsx)(e.code,{children:"getDetail()"})," 提供各种相关的状态方法，通过这些 API 实现",(0,s.jsx)(e.strong,{children:"表单的提交、重置、验证"}),"等功能，但要注意，这些 API 并不是完全给开发者使用，也有给 Form、FormItem 使用的实例，整理如下："]}),"\n",(0,s.jsxs)(e.table,{children:["\n",(0,s.jsxs)(e.thead,{children:["\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.th,{children:"FormStore 提供的方法名"}),"\n",(0,s.jsx)(e.th,{children:"作用"}),"\n",(0,s.jsx)(e.th,{children:"说明"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.tbody,{children:["\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"registerField"}),"\n",(0,s.jsx)(e.td,{children:"注册表单控件"}),"\n",(0,s.jsx)(e.td,{children:"提供两个参数，第一个参数 name，用于区分具体的表单控件，第二参数 updateChange，存放具体的内容，如：触发更新的函数、校验规则等。用来注册 store 等信息。"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"unRegisterField"}),"\n",(0,s.jsx)(e.td,{children:"卸载表单控件"}),"\n",(0,s.jsx)(e.td,{children:"提供一个参数 name，用于卸载表单控件，清除 store 等信息。"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"dispatch"}),"\n",(0,s.jsx)(e.td,{children:"用于调取 FormStore 中的内部方法"}),"\n",(0,s.jsx)(e.td,{children:"提供一个参数 action，类似于 redux 中的 dispatch，其中 type 为必填，通过 type 调用具体的内部方法。"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"setConfigWays"}),"\n",(0,s.jsx)(e.td,{children:"绑定外部方法"}),"\n",(0,s.jsx)(e.td,{children:"提供一个参数：callbacks，对象，存储外部的方法，如提交、重置等。"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"submit"}),"\n",(0,s.jsx)(e.td,{children:"表单提交"}),"\n",(0,s.jsx)(e.td,{children:"提供一个参数：cb（回调方法），首先执行表单校验，如果校验失败，则返回校验失败的表单控价和此时 store 的数据；如果校验成功，则直接返回 store 的数据。"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"resetFields"}),"\n",(0,s.jsx)(e.td,{children:"重置表单"}),"\n",(0,s.jsx)(e.td,{children:"提供一个参数：cb（回调方法），分为两个部分，第一个部分，有初始值的表单控件，进行还原，第二个部分，还原表单控件的校验项。"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"getFieldValue"}),"\n",(0,s.jsx)(e.td,{children:"获取对应表单控件的值"}),"\n",(0,s.jsx)(e.td,{children:"提供一个可选参数：name，如果有 name，则返回对应控件的值，如果无，则返回全部的 store 数据。"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"getFieldValidate"}),"\n",(0,s.jsx)(e.td,{children:"获取表单的验证"}),"\n",(0,s.jsx)(e.td,{children:"用于检测表单控件的值成功还是失败。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"其中，registerField、unRegisterField、dispatch、setConfigWays 提供给 From、Form 组件中使用，submit、resetFields、getFieldValue、getFieldValidate 可提供开发者使用。"}),"\n"]}),"\n",(0,s.jsxs)(e.h1,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在所有的组件中，Form 组件是非常重要且有必要学习的组件之一，其中是 Ant design v3 和 v4 的版本，分别以",(0,s.jsx)(e.strong,{children:"高阶组件"}),"和 ",(0,s.jsx)(e.strong,{children:"Hooks"})," 的方式实现，其思想十分重要，建议大家都去看看，亲自实现一番，肯定会受益良多。"]}),"\n",(0,s.jsx)(e.p,{children:"本小节对应 rc-form（Antd form） 的实现，主要介绍 Form 组件的数据管理与通信。和一些表单的基础操作，下一节我们继续学习表单的校验功能。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}let h=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F17.%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BD%9C%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%B5%81%E7%A8%8B.md"]={toc:[{text:"提示语",id:"提示语",depth:2},{text:"数据如何通信？",id:"数据如何通信",depth:2},{text:"检查 children 元素",id:"检查-children-元素",depth:2},{text:"值的获取和更新",id:"值的获取和更新",depth:2},{text:"强制更新表单",id:"强制更新表单",depth:2},{text:"初始化",id:"初始化",depth:2},{text:"提交、重置",id:"提交重置",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);