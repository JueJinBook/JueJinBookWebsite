"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["72398"],{812671:function(e,n,c){e.exports=c.p+"static/image/323c05c21b68202b32a71703aae35ba5.1a07284a.webp"},858415:function(e,n,c){e.exports=c.p+"static/image/5ad06db242a5da2fcea1361241dc92eb.890ffd38.gif"},353364:function(e,n,c){e.exports=c.p+"static/image/61a7c3a2df96d44d810f9d445699f019.5e62f610.gif"},321975:function(e,n,c){e.exports=c.p+"static/image/c3e6be6296babbfe1da14072337a4e3f.c2a3c703.webp"},468094:function(e,n,c){c.r(n),c.d(n,{default:()=>h});var s=c(552676),i=c(740453),r=c(353364),t=c(812671),d=c(858415),o=c(321975);function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",ol:"ol",li:"li",strong:"strong",img:"img",blockquote:"blockquote",h3:"h3",ul:"ul",h4:"h4"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"9-时序相关的异步-apitimersetimmediateprocessnexttick-与-queuemicrotask下---副本",children:["9-时序相关的异步 API：Timer、setImmediate、process.nextTick() 与 queueMicrotask()（下） - 副本",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-时序相关的异步-apitimersetimmediateprocessnexttick-与-queuemicrotask下---副本",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["前面两章，我们讲述了 Node.js 中 ",(0,s.jsx)(n.code,{children:"setTimeout"})," 原理是什么。是由单个定时器不断地去定最近超时时间以达到效果。接下去，我们用一章的量讲完 ",(0,s.jsx)(n.code,{children:"setImmediate()"}),"、",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 与 ",(0,s.jsx)(n.code,{children:"queueMicrotask()"})," 吧。"]}),"\n",(0,s.jsxs)(n.h2,{id:"setimmediate",children:[(0,s.jsx)(n.code,{children:"setImmediate()"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#setimmediate",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/timers.js#LL279-L303C2",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/timers.js#LL279-L303C2",target:"_blank",rel:"noopener noreferrer",children:"setImmediate() 的源码"}),"与 ",(0,s.jsx)(n.code,{children:"setTimeout()"}),"、",(0,s.jsx)(n.code,{children:"setInterval()"})," 近似，只不过没有 ",(0,s.jsx)(n.code,{children:"insert()"})," 操作，实例也不再是 ",(0,s.jsx)(n.code,{children:"Timeout"}),"，而是 ",(0,s.jsx)(n.code,{children:"Immediate"}),"。眼熟吧。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function setImmediate(callback, arg1, arg2, arg3) {\n  validateFunction(callback, 'callback');\n\n  let i, args;\n  switch (arguments.length) {\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 4; i < arguments.length; i++) {\n        args[i - 1] = arguments[i];\n      }\n      break;\n  }\n\n  return new Immediate(callback, args);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Immediate"})," 类也与 ",(0,s.jsx)(n.code,{children:"Timeout"})," 类似，有着一堆元信息，也有着 ",(0,s.jsx)(n.code,{children:"ref()"})," 与 ",(0,s.jsx)(n.code,{children:"unref()"}),"。不过，它会在自己构造函数内部将自己推入一个 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L267-L304",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L267-L304",target:"_blank",rel:"noopener noreferrer",children:"Immediate 的链表"}),"中。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const immediateQueue = new ImmediateList();\n\n...\n\nclass Immediate {\n  constructor(...) {\n    ...\n    immediateQueue.append(this);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这就是一条非常普通的链表，只有 ",(0,s.jsx)(n.code,{children:"append()"}),"（推入到最后元素）以及 ",(0,s.jsx)(n.code,{children:"remove()"}),"（移除某个元素）两个操作。还记得我们在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7196627546253819916/section/7197301858296135684",title:"https://juejin.cn/book/7196627546253819916/section/7197301858296135684",target:"_blank",rel:"noopener noreferrer",children:"第八章"}),"中提到的，Node.js 会在启动的时候",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/bootstrap/node.js#L349-L360",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/bootstrap/node.js#L349-L360",target:"_blank",rel:"noopener noreferrer",children:"注册两个时序相关的 Dispatcher 进去吗"}),"？"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"processTimers()"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"processImmediate()"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"processTimers()"})," 这个函数我们在第八章的时候介绍过了，是在 libuv 侧关于 ",(0,s.jsx)(n.code,{children:"Timer"})," 的定时器到期之后会执行的 Dispatcher 回调函数。而 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L431-L494",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L431-L494",target:"_blank",rel:"noopener noreferrer",children:"processImmediate()"})," 就是用于处理 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 的回调了。"]}),"\n",(0,s.jsxs)(n.p,{children:["它的流程可以用一句话概括，遍历这条 ",(0,s.jsx)(n.code,{children:"Immediate"})," 链表，并逐个执行其回调函数。这里做了一个防重入的措施。在遍历前，将 ",(0,s.jsx)(n.code,{children:"Immediate"})," 链表给到另一条链表，然后清空 ",(0,s.jsx)(n.code,{children:"immediateQueue"}),"。思考一下，这么做的意义在哪？"]}),"\n",(0,s.jsx)(n.p,{children:"想象一下，如果有这么一段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function set() {\n  console.log('hello');\n  setImmediate(set);\n}\nset();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我要是在 ",(0,s.jsx)(n.code,{children:"processImmediate()"})," 遍历过程中，始终用同一条链表会怎么样？我刚从链表内拿出一个 ",(0,s.jsx)(n.code,{children:"Immediate"}),"，紧接着在它的回调函数中又插入一个新的（",(0,s.jsx)(n.code,{children:"immediateQueue.append(this)"}),"）。它就一直在遍历这个链表，其他事都不用做了。所以才需要另一条链表做防重入："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const outstandingQueue = new ImmediateList();\n...\n\nfunction processImmediate() {\n  const queue = outstandingQueue.head !== null ?\n    outstandingQueue : immediateQueue;\n  let immediate = queue.head;\n\n  if (queue !== outstandingQueue) {\n    queue.head = queue.tail = null;\n    immediateInfo[kHasOutstanding] = 1;\n  }\n  \n  ...遍历\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里另一条链表就是 ",(0,s.jsx)(n.code,{children:"immediate"}),"。在最开始的时候，先判断 ",(0,s.jsx)(n.code,{children:"outstandingQueue"})," 是不是为空，若为空，则将 ",(0,s.jsx)(n.code,{children:"queue"})," 赋值为 ",(0,s.jsx)(n.code,{children:"immediateQueue"}),"，否则赋值为 ",(0,s.jsx)(n.code,{children:"outstandingQueue"}),"，这个是后话。然后让 ",(0,s.jsx)(n.code,{children:"immediate"})," 为这个 ",(0,s.jsx)(n.code,{children:"queue"})," 的首元素，后面的遍历就是遍历这个 ",(0,s.jsx)(n.code,{children:"immediate"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["下面这个 ",(0,s.jsx)(n.code,{children:"if"})," 就是防重入的核心了。如果 ",(0,s.jsx)(n.code,{children:"queue"})," 不等于 ",(0,s.jsx)(n.code,{children:"outstandingQueue"}),"，也就意味着它就是 ",(0,s.jsx)(n.code,{children:"immediateQueue"}),"。如果当前遍历的是 ",(0,s.jsx)(n.code,{children:"immediateQueue"}),"，那么我们就清空这个 ",(0,s.jsx)(n.code,{children:"immediateQueue"}),"，也就是将其首尾都赋空。这么一来，我遍历是遍历着已经拿过来的 ",(0,s.jsx)(n.code,{children:"immediate"}),"，在这之间新插入的 ",(0,s.jsx)(n.code,{children:"Immediate"})," 是插入到已被赋空的 ",(0,s.jsx)(n.code,{children:"immediateQueue"})," 链表了，两条链表毫无关系，不会再出现死循环。"]}),"\n",(0,s.jsx)(n.p,{children:"这就像跟熊孩子排队一样。轮到熊孩子玩，玩好之后又马上跑队尾去排，再玩一轮，再继续排。假设游乐场只要有客就接，不休息，那么它永远也别打烊了，熊孩子会一直排下去玩下去。但如果一条队伍开始进场后，我们就决定这条队伍今天不接客了，玩完就关门，你要排可以，排明天去。那么游乐场就能正常打烊了。"}),"\n",(0,s.jsxs)(n.p,{children:["那么，这个 ",(0,s.jsx)(n.code,{children:"outstandingQueue"})," 又是什么呢？首先，执行 ",(0,s.jsx)(n.code,{children:"Immediate.prototype._onImmediate()"})," 函数的时候，Node.js 用的是 ",(0,s.jsx)(n.code,{children:"try-finally"}),"，并没有 ",(0,s.jsx)(n.code,{children:"catch"}),"。也就是说，一旦 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 中的回调函数抛错了，是会触发 ",(0,s.jsx)(n.code,{children:"uncaughtException"})," 的。这个时候，如果用户监听了该错误事件并处理了，那么 Node.js 会继续执行，但是这个 ",(0,s.jsx)(n.code,{children:"Immediate"})," 链表的遍历过程就被中断了，我们甚至接下去再执行的话，要从哪开始。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"outstandingQueue"})," 就起到了",(0,s.jsx)(n.strong,{children:"保留现场"}),"的作用。每次遍历执行一次 ",(0,s.jsx)(n.code,{children:"Immediate.prototype._onImmediate()"})," 后的 ",(0,s.jsx)(n.code,{children:"finally"})," 中，都记录一下 ",(0,s.jsx)(n.code,{children:"outstandingQueue"})," 的首元素为当前执行完的 ",(0,s.jsx)(n.code,{children:"Immediate"})," 的下一个元素。这样，哪怕抛错了，也记录下来了现场。所以我们在 ",(0,s.jsx)(n.code,{children:"processImmediate()"})," 函数的头部逻辑中能看到，",(0,s.jsx)(n.code,{children:"queue"})," 的赋值时，",(0,s.jsx)(n.code,{children:"outstandingQueue"})," 是否为空。若不为空则说明是记录下现场后，有抛错，那么理应从现场继续开始——相当于去商场停车后，拍照记下来车位号，以便到时候事情太多，忘了的时候快速找到自己的车子在哪。"]}),"\n",(0,s.jsxs)(n.p,{children:["这块遍历逻辑讲完后，接下去就是 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 回调函数的执行时机了。",(0,s.jsx)(n.code,{children:"setTimeout()"})," 时机为 libuv 里唯一 ",(0,s.jsx)(n.code,{children:"Timer"})," 定时器在事件循环中最近一次超时事件。那 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 呢？这里我脱口秀高级技巧——Callback 一下。请大家返回",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7196627546253819916/section/7196992628036993028",title:"https://juejin.cn/book/7196627546253819916/section/7196992628036993028",target:"_blank",rel:"noopener noreferrer",children:"第三章"}),"，里面有提到 libuv 的一个事件——空转事件。"]}),"\n",(0,s.jsx)(n.p,{children:"我们再祭出 libuv 的事件循环内部顺序图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"一次事件循环的逻辑顺序依次为：定时器事件、Pending 态 I/O 事件、空转事件、准备事件、Poll I/O 事件、复查事件及扫尾。"}),"\n",(0,s.jsxs)(n.p,{children:["空转事件是在定时器事件后执行的。但这并不重要，",(0,s.jsx)(n.code,{children:"Immediate"})," 并不在该阶段执行。空转事件只是为了让 Poll for I/O 阶段不阻塞而已。它的事件回调是一个空的 Lambda 函数。当有至少一个 ",(0,s.jsx)(n.code,{children:"Immediate"})," 被 ",(0,s.jsx)(n.code,{children:"ref"})," 了，Node.js 就会激活这个空转句柄，让 I/O 不阻塞等待定时器事件；如果没有被 ",(0,s.jsx)(n.code,{children:"ref"})," 了，则停止该句柄。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void Environment::ToggleImmediateRef(bool ref) {\n  if (started_cleanup_) return;\n\n  if (ref) {\n    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });\n  } else {\n    uv_idle_stop(immediate_idle_handle());\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["代码比较好理解，也是通过 ",(0,s.jsx)(n.code,{children:"ref"})," 和 ",(0,s.jsx)(n.code,{children:"unref"})," 来搞的。你如果理解了 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 的话，应该会对这个逻辑感到亲切。 至于它是如何不阻塞事件循环的，大家可以回过头去精读一下第三章的空转事件。复习一下，其实原理很简单，就是 Poll for I/O 阶段的时候，最大等待时间为 ",(0,s.jsx)(n.code,{children:"uv_backend_timeout()"}),"。若无空转事件，则该值为下一个定时器的时间，若有，则直接是 ",(0,s.jsx)(n.code,{children:"0"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["看一下 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 官方文档："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:['Schedules the "immediate" execution of the ',(0,s.jsx)(n.code,{children:"callback"})," after I/O events' callbacks."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，它回调函数执行时机是在 Poll for I/O 阶段之后。实际上，Node.js 用",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/src/env.cc#LL864C15-L864C71",title:"https://github.com/nodejs/node/blob/v18.14.1/src/env.cc#LL864C15-L864C71",target:"_blank",rel:"noopener noreferrer",children:"复查事件阶段"}),"来执行 ",(0,s.jsx)(n.code,{children:"Immediate"}),"——的确是在 Poll for I/O 阶段之后："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"uv_check_start(immediate_check_handle(), CheckImmediate);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个 ",(0,s.jsx)(n.code,{children:"CheckImmediate()"})," 回调就是执行的关键了，其作用类似于 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 中的 ",(0,s.jsx)(n.code,{children:"RunTimers()"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void Environment::CheckImmediate(uv_check_t* handle) {\n  ...\n  do {\n    MakeCallback(env->isolate(),\n                 env->process_object(),\n                 env->immediate_callback_function(),\n                 0,\n                 nullptr,\n                 {0, 0}).ToLocalChecked();\n  } while (env->immediate_info()->has_outstanding() && env->can_call_into_js());\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里我们看到，它会不断去执行之前注册好的回调函数 ",(0,s.jsx)(n.code,{children:"processImmediate()"}),"，直到现场（",(0,s.jsx)(n.code,{children:"outstandingQueue"}),"）空了。"]}),"\n",(0,s.jsxs)(n.h3,{id:"时机究竟如何",children:["时机究竟如何？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#时机究竟如何",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["按 Node.js 官方文档来看，",(0,s.jsx)(n.code,{children:"setImmediate()"})," 执行时机是在复查事件阶段，在定时器事件、Poll for I/O 事件之后。我们做了内部原理剖析和讲解后，发现也的确是这样的。但事实上呢？我们来看一段代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"setImmediate(() => {\n  console.log('setImmediate');\n});\n\nsetTimeout(() => {\n  console.log('setTimeout');\n}, 0);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["用 Node.js 跑几次看看？我们会发现结果是随机的，有时先 ",(0,s.jsx)(n.code,{children:"setImmediate"}),"，而有时则先执行 ",(0,s.jsx)(n.code,{children:"setTimeout"}),"。说好的定时器事件先执行呢？"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["这里其实被偷换概念了。libuv 设计的确是定时器先于复查的——但那仅限于同一个 Tick 呀。抛开一个 Tick 讲执行顺序的都是耍流氓。就 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 原理那个不精确的劲儿，它指不定是哪个 Tick 执行呢，而 ",(0,s.jsx)(n.code,{children:"setImmediate"})," 的执行顺序则恰恰在该 Tick 末尾。"]}),"\n",(0,s.jsxs)(n.p,{children:["在上面代码中，执行了这两句代码后，才进入事件循环。在第一个 Tick 中，先判断 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 有没有到期。超时时间为 ",(0,s.jsx)(n.code,{children:"0"}),"，在 ",(0,s.jsx)(n.code,{children:"Timeout"})," 构造函数中会被自动设为 ",(0,s.jsx)(n.code,{children:"1"}),"。通常情况下，第一个 Tick 还超不了时，所以略过定时器，走到了复查阶段；而有时候计算机稍微脑抽卡一下，第一个 Tick 的时候就已经超时了，这个时候自然是先执行这个 ",(0,s.jsx)(n.code,{children:"Timeout"}),"。如果已经在事件循环中，再跑这两行句代码，那肯定是先执行 ",(0,s.jsx)(n.code,{children:"Immediate"}),"，毕竟定时器阶段未检查到超时 ",(0,s.jsx)(n.code,{children:"Timeout"}),"。如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"setTimeout(() => {\n  setImmediate(() => {\n    console.log('setImmediate');\n  });\n\n  setTimeout(() => {\n    console.log('setTimeout');\n  }, 0);\n}, 0);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这就铁定先执行 ",(0,s.jsx)(n.code,{children:"setImmediate"})," 再执行 ",(0,s.jsx)(n.code,{children:"setTimeout"})," 了，因为跑完外层 ",(0,s.jsx)(n.code,{children:"Timeout"})," 后，直接就到后续阶段了，一路过去肯定是先执行复查阶段，然后再是下个 Tick 才能执行后续的 ",(0,s.jsx)(n.code,{children:"Timeout"}),"。但如果这样呢："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"setImmediate(() => {\n  setImmediate(() => {\n    console.log('setImmediate');\n  });\n\n  setTimeout(() => {\n    console.log('setTimeout');\n  }, 0);\n}, 0);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个时候，里面的两个 ",(0,s.jsx)(n.code,{children:"setImmediate"})," 与 ",(0,s.jsx)(n.code,{children:"setTimeout"})," 肯定都是要在下个 Tick 进行了，因为当前已经处于复查阶段，而且防重入机制让里面的 ",(0,s.jsx)(n.code,{children:"Immediate"})," 肯定不会再在当前 Tick 进行。那这个时候还是要看电脑有没有脑抽，所以它的结果是跟最开始那两句代码一样，顺序是随机的。"]}),"\n",(0,s.jsxs)(n.p,{children:["那如果是 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 与 ",(0,s.jsx)(n.code,{children:"fs"})," 呢？比如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// temp.js\nsetImmediate(() => {\n  console.log('setImmediate');\n});\nrequire('fs').readFile('temp.js', () => {\n  console.log('readFile');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个执行顺序又是怎么样的？首先，在这个 Tick 中的执行顺序肯定是先 Poll for I/O 然后再复查。但问题在于，Poll for I/O 阶段，它等待文件系统事件的时间为 ",(0,s.jsx)(n.code,{children:"0"}),"，",(0,s.jsx)(n.code,{children:"0"})," 时间内等不到事件，那么会继续执行后续逻辑。而对一个这种可读事件来说，通常不会在 ",(0,s.jsx)(n.code,{children:"0"})," 的时间内完成触发，所以第一个 Tick 基本上都是直接在 Poll for I/O 阶段假模假式等你 ",(0,s.jsx)(n.code,{children:"0"})," 毫秒，然后就直奔复查阶段去了。第一个 Tick 没读出来，那 ",(0,s.jsx)(n.code,{children:"fs"})," 自然是在后续 Tick 中读出来了。所以如果没有一些特殊情况，上面的代码 ",(0,s.jsx)(n.code,{children:"setImmediate"})," 总会先于 ",(0,s.jsx)(n.code,{children:"readFile"})," 被输出。"]}),"\n",(0,s.jsx)(n.p,{children:"改一下上面的代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function imm() {\n  setImmediate(() => {\n    console.log('setImmediate');\n    imm();\n  });\n}\nimm();\n\nrequire('fs').readFile('temp.js', () => {\n  console.log('readFile');\n  process.exit(0);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["执行几次，会发现，输出了几行 ",(0,s.jsx)(n.code,{children:"setImmediate"})," 后，终于读取成功了，然后输出 ",(0,s.jsx)(n.code,{children:"readFile"})," 并退出了。这又是什么科学道理呢？虽然我们执行等待的时候等待时间为 ",(0,s.jsx)(n.code,{children:"0"}),"，但是整段 JavaScript 在每个 Tick 执行时间还是有纳秒、微妙、毫秒级别的耗时，所以到下几个 Tick 的时候，事件已经到了，不用等就能直接拿到。这个时候哪怕等待 ",(0,s.jsx)(n.code,{children:"0"})," 也能直接拿到事件，于是终于等到了 ",(0,s.jsx)(n.code,{children:"readFile()"})," 的回调函数出场了。"]}),"\n",(0,s.jsxs)(n.p,{children:["上面抛砖引玉一下。大家可以自己再想想各种情况下 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 的时序问题。"]}),"\n",(0,s.jsxs)(n.h2,{id:"queuemicrotask",children:[(0,s.jsx)(n.code,{children:"queueMicrotask()"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#queuemicrotask",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"微任务的理论执行时机",children:["微任务的理论执行时机",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#微任务的理论执行时机",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 Web API 中，有一个 ",(0,s.jsx)(n.code,{children:"queueMicrotask()"})," 函数。这个就是大家经常听到的“微任务”。我们不说网上八股那些有的没的宏任务微任务，反正我没看懂。微任务在 ",(0,s.jsx)(n.a,{href:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#microtask-queuing",title:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#microtask-queuing",target:"_blank",rel:"noopener noreferrer",children:"WHATWG 规范"}),"里是有定义的："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask",title:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask",target:"_blank",rel:"noopener noreferrer",children:"queueMicrotask()"})," method allows authors to schedule a callback on the ",(0,s.jsx)(n.a,{href:"https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue",title:"https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue",target:"_blank",rel:"noopener noreferrer",children:"microtask queue"}),". This allows their code to run once the ",(0,s.jsx)(n.a,{href:"https://tc39.es/ecma262/#execution-context-stack",title:"https://tc39.es/ecma262/#execution-context-stack",target:"_blank",rel:"noopener noreferrer",children:"JavaScript execution context stack"})," is next empty, which happens once all currently executing synchronous JavaScript has run to completion."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"什么意思呢？微任务是在“当前 JavaScript 执行上下文堆栈”完毕之后，要开始执行下一坨 JavaScript 之前，在这个空档之间执行的任务。这与事件循环可没有必然联系。在 libuv 里面事件循环同一个阶段，也会出现这种情况。"}),"\n",(0,s.jsxs)(n.p,{children:["比如我们监听了很多文件系统 I/O 事件，并且在某一个事件循环中同时拿到事件并触发，它们处于同个阶段，但它们的 JavaScript 执行上下文堆栈则不同。我们拿之前的 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 举例，理论上，在复查阶段执行 ",(0,s.jsx)(n.code,{children:"CheckImmediate()"})," 函数，触发这个事件的时候，没有任何 V8 引擎介入的。在该函数内部，Node.js 为其创建了一个 ",(0,s.jsx)(n.code,{children:"HandleScope"})," 和一个 ",(0,s.jsx)(n.code,{children:"Context::Scope"}),"，这才有了一个执行 JavaScript 的上下文环境："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void Environment::CheckImmediate(uv_check_t* handle) {\n  ...\n\n  HandleScope scope(env->isolate());\n  Context::Scope context_scope(env->context());\n  \n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这才是所谓的“一次 JavaScript 上下文堆栈”。所以理论上执行完这个 ",(0,s.jsx)(n.code,{children:"CheckImmediate()"})," 的 JavaScript 侧代码后，就会执行一次微任务。定时器 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 最终回调执行机制同理——理论上的确如此。"]}),"\n",(0,s.jsxs)(n.p,{children:["首先，内置的跑在微任务阶段的那些内容的确如网上说的，比如 ",(0,s.jsx)(n.code,{children:"Promise"})," 的一些东西。我们也可通过 ",(0,s.jsx)(n.code,{children:"queueMicroTask()"})," 往微任务队列里面插入我们自己所需要跑的微任务。这些任务",(0,s.jsx)(n.strong,{children:"理论上"}),"会在上面提到的这些时机去执行。"]}),"\n",(0,s.jsxs)(n.h3,{id:"nodejs-中的微任务执行时机",children:["Node.js 中的微任务执行时机",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中的微任务执行时机",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 V8 中，微任务的执行时机是由策略决定的，该策略是 ",(0,s.jsx)(n.code,{children:"MicrotasksPolicy"})," 的枚举值，通过 ",(0,s.jsx)(n.code,{children:"v8::Isolate::SetMicrotasksPolicy"})," 设置给 V8 引擎的。该枚举值有："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"kExplicit"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"kScoped"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"kAuto"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们不管其他几种枚举值是何种策略，Node.js 自身的",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/src/node.h#L447",title:"https://github.com/nodejs/node/blob/v18.14.1/src/node.h#L447",target:"_blank",rel:"noopener noreferrer",children:"策略用的是 kExplicit"}),"。该策略在 V8 文档中的解释是：微任务只会在显式调用 ",(0,s.jsx)(n.code,{children:"Isolate::PerformMicrotaskCheckpoint()"}),"（或 ",(0,s.jsx)(n.code,{children:"MicrotaskQueue::PerformCheckpoint()"}),"）时被执行。换句话说，我前面解释一大堆只是“理论”，",(0,s.jsx)(n.strong,{children:"最终解释权归 Node.js 所有"}),"。我们看看目前 Node.js v18.14.1 中哪里调用的 ",(0,s.jsx)(n.code,{children:"PerformMicrotaskCheckpoint()"})," 吧。"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["ECMAScript modules 的 ",(0,s.jsx)(n.code,{children:"Evaluate()"})," 阶段；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/src/node_contextify.cc#L1009-L1014",title:"https://github.com/nodejs/node/blob/v18.14.1/src/node_contextify.cc#L1009-L1014",target:"_blank",rel:"noopener noreferrer",children:"vm 沙箱执行完一次之后"}),"，并且用的不是主 Context，而是通过 ",(0,s.jsx)(n.code,{children:"vm.createContext()"})," 创建新的 Context；"]}),"\n",(0,s.jsxs)(n.li,{children:["内部一些 ",(0,s.jsx)(n.code,{children:"callback"})," 函数执行之后（具体在 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/src/api/callback.cc#L193",title:"https://github.com/nodejs/node/blob/v18.14.1/src/api/callback.cc#L193",target:"_blank",rel:"noopener noreferrer",children:"InternalMakeCallback"})," 中的 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/src/api/callback.cc#L132-L136",title:"https://github.com/nodejs/node/blob/v18.14.1/src/api/callback.cc#L132-L136",target:"_blank",rel:"noopener noreferrer",children:"InternalCallbackScope"}),"）；"]}),"\n",(0,s.jsxs)(n.li,{children:["前面讲的 ",(0,s.jsx)(n.code,{children:"setTimeout()"}),"、",(0,s.jsx)(n.code,{children:"setInterval()"}),"、",(0,s.jsx)(n.code,{children:"setImmediate()"})," 等薅羊毛时，每次执行 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 的时候，以及其他与 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 回调函数触发的相同时机（稍后于它，这个在 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 会详解）；"]}),"\n",(0,s.jsxs)(n.li,{children:["手动执行一个被遗弃的 API ",(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/deprecations.html#DEP0134",title:"https://nodejs.org/dist/latest-v18.x/docs/api/deprecations.html#DEP0134",target:"_blank",rel:"noopener noreferrer",children:"process._tickCallback()"})," 的时候——这个 ",(0,s.jsx)(n.code,{children:"_tickCallback()"})," 其实就是前面的 ",(0,s.jsx)(n.code,{children:"runNextTicks()"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"五种执行时机埋点",children:["五种执行时机埋点",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五种执行时机埋点",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 ECMAScript modules 加载后，会手动去执行一次微任务："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void ModuleWrap::Evaluate(...) {\n  ...\n  auto run = [&]() {\n    MaybeLocal<Value> result = module->Evaluate(context);\n    if (!result.IsEmpty() && microtask_queue)\n      microtask_queue->PerformCheckpoint(isolate);\n    return result;\n  };\n  \n  ...\n  result = run();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["而 ",(0,s.jsx)(n.code,{children:"vm"})," 沙箱在非主 Context 执行的时候，一样也会有类似上面的逻辑："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"bool ContextifyScript::EvalMachine(...) {\n  ...\n  auto run = [&]() {\n    MaybeLocal<Value> result = script->Run(context);\n    if (!result.IsEmpty() && mtask_queue)\n      mtask_queue->PerformCheckpoint(env->isolate());\n    return result;\n  };\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["上面的 ",(0,s.jsx)(n.code,{children:"mtask_queue"})," 只有在非主 Context 的时候才会被设值。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["至于 ",(0,s.jsx)(n.code,{children:"InternalMakeCallback()"}),"，它会在里面创建一个 ",(0,s.jsx)(n.code,{children:"InternalCallbackScope"})," 实例，该实例在结束的时候，会手动执行微任务："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void InternalCallbackScope::Close() {\n  ...\n  if (!tick_info->has_tick_scheduled()) {\n    context->GetMicrotaskQueue()->PerformCheckpoint(isolate);\n\n    perform_stopping_check();\n  }\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["而 ",(0,s.jsx)(n.code,{children:"InternalMakeCallback()"})," 则通常用于唤起一些内置的回调函数，比如文件系统、网络 I/O 等等。"]}),"\n",(0,s.jsxs)(n.p,{children:["关于第四点，我们先看看 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 里面究竟是什么："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["抛开不重要的内容不说，这里面调用了 ",(0,s.jsx)(n.code,{children:"runMicrotasks()"}),"，而其对应的是 C++ 侧的 ",(0,s.jsx)(n.code,{children:"RunMicrotasks()"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"static void RunMicrotasks(const FunctionCallbackInfo<Value>& args) {\n  Environment* env = Environment::GetCurrent(args);\n  env->context()->GetMicrotaskQueue()->PerformCheckpoint(env->isolate());\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最后一个，API 都未被公开过，直接就躺在了弃用列表，我们无需关心。其实上面这个 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 与 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 耦合挺深的，后面还会细讲。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们老听宏任务微任务。看了 WHATWG 规范对其的定义，直到它会在什么时候执行了吧？而看了上面的解析，以前脑中不理解死记硬背的抽象概念是不是更具象化了？不过这仅代表 Node.js，不代表浏览器。每个浏览器的实现也不一样，甚至有些有可能直接用的 ",(0,s.jsx)(n.code,{children:"kAuto"})," 策略。",(0,s.jsx)(n.strong,{children:"Node.js 的微任务是自己一个个埋点找时机进去执行的"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"processnexttick",children:[(0,s.jsx)(n.code,{children:"process.nextTick()"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#processnexttick",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"process.nextTick()"})," 并不属于事件循环内的概念。这里的 Tick 也与我们之前讲的事件循环的 Tick 不是一回事。它是 Node.js 中的 Tick 概念。在 ",(0,s.jsx)(n.code,{children:"queueMicrotask()"})," 一节中，我们看见了像 ",(0,s.jsx)(n.code,{children:"Timeout"}),"、",(0,s.jsx)(n.code,{children:"Immediate"})," 这些时序相关 API 会在不同定时实例执行的间隔处模拟出一个 Tick，就是通过 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 来执行的。而 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 中的回调函数其中一种可能就是会在该处触发。"]}),"\n",(0,s.jsxs)(n.h3,{id:"processnexttick-做了什么",children:[(0,s.jsx)(n.code,{children:"process.nextTick()"})," 做了什么？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#processnexttick-做了什么",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们先看看 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/process/task_queues.js#L103-L134",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/process/task_queues.js#L103-L134",target:"_blank",rel:"noopener noreferrer",children:"process.nextTick()"})," 具体做了什么吧。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const queue = new FixedQueue();\n...\n\nfunction nextTick(callback) {\n  validateFunction(callback, 'callback');\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1], arguments[2]]; break;\n    case 4: args = [arguments[1], arguments[2], arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  ...\n  const tickObject = {\n    ...\n    callback,\n    args\n  };\n  ...\n  queue.push(tickObject);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["前面参数相关逻辑与 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 类似，不细讲了。这里用了一个 ",(0,s.jsx)(n.code,{children:"queue"})," 去存储 Node.js 的当前 Tick 中需要执行的 ",(0,s.jsx)(n.code,{children:"nextTick()"})," 回调们。",(0,s.jsx)(n.code,{children:"queue"})," 是一个由一个或多个环形队列拼接而成的链表，你就当它是一个大链表用就好了，或者当作是一个不定长的大环形队列。由于这不是一本《趣学算法、数据结构》，关于环形队列的内容可自行上网查找，或者关于 Node.js ",(0,s.jsx)(n.code,{children:"FixedQueue"})," 的内容可自行翻看其",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/fixed_queue.js",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/fixed_queue.js",target:"_blank",rel:"noopener noreferrer",children:"源码"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["总之就是用一个大链表存当前 Tick 的回调们。若该 ",(0,s.jsx)(n.code,{children:"queue"})," 为空，则设置“Tick 中有回调”（",(0,s.jsx)(n.code,{children:"setHasTickScheduled(true)"}),"）。该设置原理与之前的 ",(0,s.jsx)(n.code,{children:"timeoutInfo[0]"})," 类似，都是一个可直通 JavaScript 侧与 C++ 侧的 ",(0,s.jsx)(n.code,{children:"Int32Array"}),"，然后此处以 ",(0,s.jsx)(n.code,{children:"0"})," 作“无”，以 ",(0,s.jsx)(n.code,{children:"1"})," 作有，也是存在 ",(0,s.jsx)(n.code,{children:"Environment"})," 的对应成员变量中。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const kHasTickScheduled = 0;\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["设置完该标识位后，构建一个 Tick 的回调函数相关对象，将其推入大链表即可。这么看来，虽然写法不同，不过这一段逻辑的流程与 ",(0,s.jsx)(n.code,{children:"setImmediate()"})," 类似，只不过目标队列（链表）不同而已。"]}),"\n",(0,s.jsxs)(n.h3,{id:"执行时机",children:["执行时机",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行时机",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["那执行时机呢？其中一个就是刚才提到的 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 中，即各 ",(0,s.jsx)(n.code,{children:"Timeout"})," 之类的执行间隙。回到这个 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 函数看一下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果大链表中没有 Tick 回调函数，那么直接只跑微任务。那难道如果有 Tick 回调函数，就不跑了吗？非也，",(0,s.jsx)(n.code,{children:"processTicksAndRejections()"})," 里面一样会去跑微任务，别急。"]}),"\n",(0,s.jsxs)(n.p,{children:["然后下一个 ",(0,s.jsx)(n.code,{children:"if"}),"，同样的条件再判断一遍，若符合则直接返回。既然条件相同，这个 ",(0,s.jsx)(n.code,{children:"return"})," 可以并入上面那个条件语句吗？如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if (!hasTickScheduled() && !hasRejectionToWarn()) {\n  runMicrotasks();\n  return;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["也不行，因为可能微任务里面有执行 ",(0,s.jsx)(n.code,{children:"process.nextTick()"}),"，这个时候跑完微任务后，",(0,s.jsx)(n.code,{children:"hasTickScheduled()"})," 可不再是 ",(0,s.jsx)(n.code,{children:"false"})," 了。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下去我们就可以看看 ",(0,s.jsx)(n.code,{children:"processTicksAndRejections()"})," 到底做了什么吧。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function processTicksAndRejections() {\n  let tock;\n  do {\n    while ((tock = queue.shift()) !== null) {\n      ...\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0], args[1]); break;\n            case 3: callback(args[0], args[1], args[2]); break;\n            case 4: callback(args[0], args[1], args[2], args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        ...\n      }\n\n      ...\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["每个 Tick 里面，都逐个从大链表中拿 Tick 回调函数相关对象，直到拿完。每拿一个，都去跑一遍它的 ",(0,s.jsx)(n.code,{children:"callback"}),"，即 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 中传入的函数。",(0,s.jsx)(n.strong,{children:"所以这个"})," ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"callback"})})," ",(0,s.jsx)(n.strong,{children:"的执行时机就是在那些时序"})," ",(0,s.jsx)(n.strong,{children:"API"})," ",(0,s.jsx)(n.strong,{children:"触发的间隙逐个执行的"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["取完跑完后，就是执行微任务的时机了，",(0,s.jsx)(n.code,{children:"runMicrotasks()"}),"。执行完后，可能 ",(0,s.jsx)(n.code,{children:"queue"})," 中又被插入了，或者 ",(0,s.jsx)(n.code,{children:"Promise"})," 有 Rejection，这个时候需要再过一遍 Tick 链表，然后再执行一遍微任务。所以这里是有可能出现死循环的。比如下面这段代码就永远跑不到 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 的回调："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function next() {\n  process.nextTick(() => {\n    queueMicrotask(next);\n  });\n}\n\nnext();\nsetTimeout(() => {\n  console.log('timeout');\n  process.exit(0);\n}, 100);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["至于原因，看明白上面的流程、",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 与微任务的关系自然就明白了。"]}),"\n",(0,s.jsxs)(n.p,{children:["当外层大循环也结束后，开始扫尾，比如将 ",(0,s.jsx)(n.code,{children:"hasTickScheduled"})," 等设为 ",(0,s.jsx)(n.code,{children:"false"}),"——毕竟 ",(0,s.jsx)(n.code,{children:"queue"})," 真被榨干了。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么，除了这个间隙时机会执行 Tick 回调，还有什么时机会呢？Node.js 会在启动的时候，将前面的 ",(0,s.jsx)(n.code,{children:"processTicksAndRejections()"})," 函数",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/process/task_queues.js#L166",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/process/task_queues.js#L166",target:"_blank",rel:"noopener noreferrer",children:"注册为 Tick Callback"}),"，该 Callback 同样被存在 ",(0,s.jsx)(n.code,{children:"Environment"})," 中。这个 Callback 函数的执行时机与微任务在 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/src/api/callback.cc#L96-L164",title:"https://github.com/nodejs/node/blob/v18.14.1/src/api/callback.cc#L96-L164",target:"_blank",rel:"noopener noreferrer",children:"MakeCallback() 里面的时机一样"}),"，并且它们的执行条件也与上面的 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 类似——都是如果没有 Tick 任务，那就光执行微任务，否则就执行这个 ",(0,s.jsx)(n.code,{children:"processTicksAndRejections()"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void InternalCallbackScope::Close() {\n  ...\n  if (!tick_info->has_tick_scheduled()) {\n    context->GetMicrotaskQueue()->PerformCheckpoint(isolate);\n\n    perform_stopping_check();\n  }\n  ...\n  \n  if (!tick_info->has_tick_scheduled() && !tick_info->has_rejection_to_warn()) {\n    return;\n  }\n  \n  ...\n  \n  Local<Function> tick_callback = env_->tick_callback_function();\n\n  ...\n\n  if (tick_callback->Call(context, process, 0, nullptr).IsEmpty()) {\n    failed_ = true;\n  }\n  \n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面这段代码的逻辑翻译一下，基本上等同于 JavaScript 侧的 ",(0,s.jsx)(n.code,{children:"runNextTicks()"}),"。所以，",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 回调执行时机究竟是什么呢？是 ",(0,s.jsx)(n.code,{children:"queueMicrotask()"})," 那一节中提到的 3、4 两个时机："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Node.js 内部一些 ",(0,s.jsx)(n.code,{children:"callback"})," 执行完毕后；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Timeout"}),"、",(0,s.jsx)(n.code,{children:"Immediate"})," 触发执行的间隙。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"processnexttick-与微任务的关系",children:[(0,s.jsx)(n.code,{children:"process.nextTick()"})," 与微任务的关系",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#processnexttick-与微任务的关系",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"而且它与微任务的关系是，上面两种情况发生后，若无 Tick 回调，也必定会执行微任务；若有 Tick 回调，则先执行 Tick 回调，然后执行微任务，若期间有新的 Tick 回调插入，那么就继续执行，循环往复，不会跳出该 Tick。"}),"\n",(0,s.jsxs)(n.p,{children:["现在知道为什么我一开始说 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 跟事件循环无关吧，它更像是一批微任务，而 Node.js 在之前是没有微任务的概念的。"]}),"\n",(0,s.jsxs)(n.p,{children:["Node.js 自身也在文档中说过 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 以及 ",(0,s.jsx)(n.code,{children:"queueMicrotask()"})," 的关系，以及在什么情况下选用哪个的说明。在小册中就不展开了，官方有的东西直接看官方就好了，经我嘴一说说不定词不达意了。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/process.html#when-to-use-queuemicrotask-vs-processnexttick",title:"https://nodejs.org/dist/latest-v18.x/docs/api/process.html#when-to-use-queuemicrotask-vs-processnexttick",target:"_blank",rel:"noopener noreferrer",children:"When to use queueMicrotask() vs. process.nextTick()"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"而关于上面那个死循环的代码，我们可以出来几个变种，大家可以看看分别的运行结果是什么，再想想看为什么："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// 1\nfunction next() {\n  process.nextTick(() => {\n    Promise.reject().catch(next);\n  });\n}\n\nnext();\nsetTimeout(() => {\n  console.log('timeout');\n  process.exit(0);\n}, 100);\n\n// 2\nfunction next() {\n  process.nextTick(next);\n}\n\nnext();\nsetTimeout(() => {\n  console.log('timeout');\n  process.exit(0);\n}, 100);\n\n// 3\nfunction next() {\n  process.nextTick(() => {\n    setImmediate(next);\n  });\n}\n\nnext();\nsetTimeout(() => {\n  console.log('timeout');\n  process.exit(0);\n}, 100);\n\n// 4\nfunction next() {\n  queueMicrotask(() => {\n    process.nextTick(next);\n  });\n}\n\nnext();\nsetTimeout(() => {\n  console.log('timeout');\n  process.exit(0);\n}, 100);\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"时序-api-小结",children:["时序 API 小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#时序-api-小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["时序类的 API 是 Node.js 中异步相关非常重要的组成部分。我们从上中下三章为大家剖析了 ",(0,s.jsx)(n.code,{children:"setTimeout()"}),"、",(0,s.jsx)(n.code,{children:"setInterval()"}),"、",(0,s.jsx)(n.code,{children:"setImmediate()"}),"、",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 以及微任务在 Node.js 中是如何执行的。"]}),"\n",(0,s.jsxs)(n.p,{children:["这其中，前面三项是通过 libuv 事件循环的机制达成的时序目的。",(0,s.jsx)(n.code,{children:"setTimeout()"})," 与 ",(0,s.jsx)(n.code,{children:"setInterval()"})," 可归为一类，其实体都是 ",(0,s.jsx)(n.code,{children:"Timeout"}),"，只是构造函数参数不同，而其执行顺序是根据",(0,s.jsx)(n.strong,{children:"薅羊毛算法"}),"进行的；",(0,s.jsx)(n.code,{children:"setImmediate()"})," 则是 ",(0,s.jsx)(n.code,{children:"Immediate"})," 实体，并在事件循环中通过空转事件来保证其即时性，它的逻辑就平平无奇，要注意的是它的",(0,s.jsx)(n.strong,{children:"防重入逻辑"}),"。而微任务与 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 则是另一类，它们虽然是异步时序相关，但",(0,s.jsx)(n.strong,{children:"并非事件循环里的内容，而是通过特定位置"})," ",(0,s.jsx)(n.strong,{children:"埋点"})," ",(0,s.jsx)(n.strong,{children:"的方式，将其执行时机一个个埋在对应的地方"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["微任务与 ",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 的执行阶段几乎一致，都是在一大段逻辑里面分别先后一次性执行 Tick 任务以及微任务。",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"process.nextTick()"})})," ",(0,s.jsx)(n.strong,{children:"任务"})," ",(0,s.jsx)(n.strong,{children:"队列"})," ",(0,s.jsx)(n.strong,{children:"是由"})," ",(0,s.jsx)(n.strong,{children:"Node.js"})," ",(0,s.jsx)(n.strong,{children:"管理的，而微任务的任务队列则直接由"})," ",(0,s.jsx)(n.strong,{children:"V8"})," ",(0,s.jsx)(n.strong,{children:"提供"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["在这三章里面，还给大家提供了个小插曲，拓宽思路，看了看如何将",(0,s.jsx)(n.strong,{children:"薅羊毛"}),"的过程变成",(0,s.jsx)(n.strong,{children:"反复横跳"}),"的过程，以此来修复 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的时序问题。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:"9150e4e5gy1g63ilh1p83g203c03naa2.gif"})})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}let h=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F9-%E6%97%B6%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BC%82%E6%AD%A5%20API%EF%BC%9ATimer%E3%80%81setImmediate%E3%80%81process.nextTick()%20%E4%B8%8E%20queueMicrotask()%EF%BC%88%E4%B8%8B%EF%BC%89%20-%20%E5%89%AF%E6%9C%AC.md"]={toc:[{text:"`setImmediate()`",id:"setimmediate",depth:2},{text:"时机究竟如何？",id:"时机究竟如何",depth:3},{text:"`queueMicrotask()`",id:"queuemicrotask",depth:2},{text:"微任务的理论执行时机",id:"微任务的理论执行时机",depth:3},{text:"Node.js 中的微任务执行时机",id:"nodejs-中的微任务执行时机",depth:3},{text:"五种执行时机埋点",id:"五种执行时机埋点",depth:4},{text:"`process.nextTick()`",id:"processnexttick",depth:2},{text:"`process.nextTick()` 做了什么？",id:"processnexttick-做了什么",depth:3},{text:"执行时机",id:"执行时机",depth:3},{text:"`process.nextTick()` 与微任务的关系",id:"processnexttick-与微任务的关系",depth:3},{text:"时序 API 小结",id:"时序-api-小结",depth:2}],title:"9-时序相关的异步 API：Timer、setImmediate、process.nextTick() 与 queueMicrotask()（下） - 副本",headingTitle:"9-时序相关的异步 API：Timer、setImmediate、process.nextTick() 与 queueMicrotask()（下） - 副本",frontmatter:{}}}}]);