"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["242"],{266699:function(e,n,d){d.r(n),d.d(n,{default:()=>x});var i=d(552676),r=d(740453);let c=d.p+"static/image/af6ad41ed4934974880841150040888c.87d3a33b.webp",s=d.p+"static/image/24cec1ee4200265e5c4be96c056772fd.821b4383.webp",h=d.p+"static/image/0f7639eb246856cb5c592708045ff241.e94e2a03.webp",a=d.p+"static/image/71d16e99161120a6d6b6e68a6d264e8e.bf897a07.webp",t=d.p+"static/image/ecf849906696b349bfa00757568abfca.eb765cbb.webp",l=d.p+"static/image/7789ad4d1d531da62543c798aa47d03b.c8992ff1.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h4:"h4",ul:"ul",li:"li",blockquote:"blockquote",img:"img",pre:"pre",strong:"strong"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"10前端预备现代前端框架单页面概念",children:["10.前端预备：现代前端框架单页面概念",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10前端预备现代前端框架单页面概念",children:"#"})]}),"\n",(0,i.jsxs)(n.h2,{id:"前言",children:["前言",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["服务端的内容基本上已经结束，从本章节开始，带大家进入前端部分的实战环节。本项目前端部分使用 ",(0,i.jsx)(n.code,{children:"React"})," 作为前端框架，所以先带大家理解什么是单页面，它是怎样实现页面组件之间的切换，路由的原理等知识点。"]}),"\n",(0,i.jsxs)(n.h4,{id:"知识点",children:["知识点",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"传统页面 DOM 直出"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"单页面原理"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"前端路由实现"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"单页面",children:["单页面",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单页面",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"前端自从进入三大框架时代以来，传统的多页面开发已渐渐淡出人们的视线。为了更好的了解现在，我们先要去知道它的过去。"}),"\n",(0,i.jsxs)(n.h4,{id:"传统页面",children:["传统页面",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#传统页面",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["这里不纠结叫法，凡是整个项目都是 ",(0,i.jsx)(n.code,{children:"DOM"})," 直出的页面，我们都称它为“传统页面”（SSR 属于首屏直出，这里我不认为是传统页面的范畴）。那么什么是 ",(0,i.jsx)(n.code,{children:"DOM"}),"\xa0直出呢？简单说就是在浏览器输入网址后发起请求，返回来的 ",(0,i.jsx)(n.code,{children:"HTML"}),"\xa0页面是最终呈现的效果，那就是 ",(0,i.jsx)(n.code,{children:"DOM"}),"\xa0直出。并且每次点击页面跳转，都会重新请求 ",(0,i.jsx)(n.code,{children:"HTML"}),"\xa0资源。耳听为虚，眼见为实。我们以这个地址为例，验证以下上述说法。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.cnblogs.com/han-1034683568/p/14126727.html#4773138",target:"_blank",rel:"noopener noreferrer",children:"https://www.cnblogs.com/han-1034683568/p/14126727.html#4773138"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["腚眼一看，就能明白上图在描述什么。没错，博客园就是一个传统页面搭建而成的网站，每次加载页面，都会返回 ",(0,i.jsx)(n.code,{children:"HTML"}),"\xa0资源以及里面的 ",(0,i.jsx)(n.code,{children:"CSS"}),"\xa0等静态资源，组合成一个新的页面。\n还没明白的同学，我再教一个方法，就是在浏览器页面右键，点击“显示网页源代码”，打开后如下所示："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["网页上能看到什么图片或文字，你能在上述图片中找到相应的 ",(0,i.jsx)(n.code,{children:"HTML"})," 结构，那也属于传统页面，也就是 ",(0,i.jsx)(n.code,{children:"DOM"})," 直出。"]}),"\n",(0,i.jsxs)(n.h4,{id:"单页面-1",children:["单页面",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单页面-1",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["时代在进步，科技在发展，面对日益增长的网页需求，网页开始走向模块化、组件化的道路。随之而来的是代码的难以维护、不可控、迭代艰难等现象。面临这种情况，催生出不少优秀的现代前端框架，首当其冲的便是 ",(0,i.jsx)(n.code,{children:"React"}),"\xa0、 ",(0,i.jsx)(n.code,{children:"Vue"}),"\xa0、 ",(0,i.jsx)(n.code,{children:"Angular"}),"\xa0等著名单页面应用框架。而这些框架有一个共同的特点，便是“通过 ",(0,i.jsx)(n.code,{children:"JS"})," 渲染页面”。\n举个例子，以前我们直出 ",(0,i.jsx)(n.code,{children:"DOM"}),"\xa0，而现在运用这些单页面框架之后， ",(0,i.jsx)(n.code,{children:"HTML"}),"\xa0页面基本上只有一个 ",(0,i.jsx)(n.code,{children:"DOM"}),"\xa0入口，大致如下所示："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["所有的页面组件，都是通过运行上图底部的 ",(0,i.jsx)(n.code,{children:"app.js"})," 脚本，挂载到 ",(0,i.jsx)(n.code,{children:'<div id="root"></div>'})," 这个节点下面。用一个极其简单的 ",(0,i.jsx)(n.code,{children:"JS"})," 展示挂载这一个步骤："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"<body>\n  <div id=\"root\"></div>\n  <script>\n    const root = document.getElementById('root') // 获取根节点\n    const divNode = document.createElement('div') // 创建 div 节点\n    divNode.innerText = '你妈贵姓？' // 插入内容\n    root.appendChild(divNode) // 插入根节点\n  <\/script>\n</body>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["所有的节点都通过 ",(0,i.jsx)(n.code,{children:"createElement"})," 方法创建，最终通过 ",(0,i.jsx)(n.code,{children:"appendChild"})," 的形式插入到 ",(0,i.jsx)(n.code,{children:"root"})," 根节点。"]}),"\n",(0,i.jsx)(n.p,{children:"那么问题来了，我如果有十几个页面需要这样的操作咋整？"}),"\n",(0,i.jsx)(n.p,{children:"这时候「前端路由」应运而生，它的出现就是为了解决单页面网站多个页面组件切换。通过切换浏览器地址路径，来匹配相对应的页面组件。我们通过一张丑陋的图片来理解这个过程："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["「前端路由」会根据浏览器地址栏 ",(0,i.jsx)(n.code,{children:"pathname"}),"\xa0的变化，去匹配相应的页面组件。然后将其通过创建 ",(0,i.jsx)(n.code,{children:"DOM"}),"\xa0节点的形式，塞入根节点 ","\xa0。这就达到了无刷新页面切换的效果，从侧面也能说明正因为无刷新，所以 ",(0,i.jsx)(n.code,{children:"React"}),"\xa0、 ",(0,i.jsx)(n.code,{children:"Vue"}),"\xa0、 ",(0,i.jsx)(n.code,{children:"Angular"}),"\xa0等现代框架在创建页面组件的时候，每个组件都有自己的「生命周期」。"]}),"\n",(0,i.jsxs)(n.h4,{id:"路由实现原理",children:["路由实现原理",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由实现原理",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["「前端路由」插件比较火的俩框架对应的就是 ",(0,i.jsx)(n.code,{children:"Vue-Router"})," 和 ",(0,i.jsx)(n.code,{children:"React-Router"})," ,但是它们的逻辑，归根结底还是一样的，用殊途同归四个字，再合适不过。"]}),"\n",(0,i.jsx)(n.p,{children:"通过分析「哈希模式」和「历史模式」的实现原理，让大家对前端路由的原理有一个更深刻的理解。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"哈希模式(hash)"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"a"})," 标签锚点大家应该不陌生，而浏览器地址上 ",(0,i.jsx)(n.code,{children:"#"})," 后面的变化，是可以被监听的，浏览器为我们提供了原生监听事件 ",(0,i.jsx)(n.code,{children:"hashchange"}),"，它可以监听到如下的变化："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["点击 ",(0,i.jsx)(n.code,{children:"a"})," 标签，改变了浏览器地址。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"浏览器的前进后退行为。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["通过 ",(0,i.jsx)(n.code,{children:"window.location"})," 方法，改变浏览器地址。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们利用这些特点，去实现一个 hash 模式的简易路由： ",(0,i.jsx)(n.a,{href:"https://codepen.io/nick930826/pen/BaLGprx",target:"_blank",rel:"noopener noreferrer",children:"在线运行"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Hash 模式</title>\n</head>\n  <body>\n    <div>\n      <ul>\n        <li><a href=\"#/page1\">page1</a></li>\n        <li><a href=\"#/page2\">page2</a></li>\n      </ul>\n      \x3c!--渲染对应组件的地方--\x3e\n      <div id=\"route-view\"></div>\n    </div>\n  <script type=\"text/javascript\">\n    // 第一次加载的时候，不会执行 hashchange 监听事件，默认执行一次\n    // DOMContentLoaded 为浏览器 DOM 加载完成时触发\n    window.addEventListener('DOMContentLoaded', Load)\n    window.addEventListener('hashchange', HashChange)\n    // 展示页面组件的节点\n    var routeView = null\n    function Load() {\n      routeView = document.getElementById('route-view')\n      HashChange()\n    }\n    function HashChange() {\n      // 每次触发 hashchange 事件，通过 location.hash 拿到当前浏览器地址的 hash 值\n      // 根据不同的路径展示不同的内容\n      switch(location.hash) {\n      case '#/page1':\n        routeView.innerHTML = 'page1'\n        return\n      case '#/page2':\n        routeView.innerHTML = 'page2'\n        return\n      default:\n        routeView.innerHTML = 'page1'\n        return\n      }\n    }\n  <\/script>\n  </body>\n</html>\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"当然，这是很简单的实现，真正的 hash 模式，还要考虑到很多复杂的情况，大家有兴趣就去看看源码。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:s,alt:""})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"历史模式(history)"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"history"})," 模式会比 ",(0,i.jsx)(n.code,{children:"hash"})," 模式稍麻烦一些，因为 ",(0,i.jsx)(n.code,{children:"history"})," 模式依赖的是原生事件 ",(0,i.jsx)(n.code,{children:"popstate"}),"，下面是来自 MDN 的解释："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:""})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"小知识：pushState 和 replaceState 都是 HTML5 的新 API，他们的作用很强大，可以做到改变浏览器地址却不刷新页面。这是实现改变地址栏却不刷新页面的重要方法。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["包括 ",(0,i.jsx)(n.code,{children:"a"})," 标签的点击事件也是不会被 ",(0,i.jsx)(n.code,{children:"popstate"})," 监听。我们需要想个办法解决这个问题，才能实现 ",(0,i.jsx)(n.code,{children:"history"})," 模式。"]}),"\n",(0,i.jsxs)(n.p,{children:["解决思路：我们可以通过遍历页面上的所有 ",(0,i.jsx)(n.code,{children:"a"})," 标签，阻止 ",(0,i.jsx)(n.code,{children:"a"}),"\xa0标签的默认事件的同时，加上点击事件的回调函数，在回调函数内获取 ",(0,i.jsx)(n.code,{children:"a"})," 标签的 ",(0,i.jsx)(n.code,{children:"href"}),"\xa0属性值，再通过 ",(0,i.jsx)(n.code,{children:"pushState"})," 去改变浏览器的 ",(0,i.jsx)(n.code,{children:"location.pathname"})," 属性值。然后手动执行 ",(0,i.jsx)(n.code,{children:"popstate"})," 事件的回调函数，去匹配相应的路由。逻辑上可能有些饶，我们用代码来解释一下：",(0,i.jsx)(n.a,{href:"https://codepen.io/nick930826/pen/BaLGprx",target:"_blank",rel:"noopener noreferrer",children:"在线地址"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>History 模式</title>\n</head>\n<body>\n  <div>\n    <ul>\n      <li><a href=\"/page1\">page1</a></li>\n      <li><a href=\"/page2\">page2</a></li>\n    </ul>\n    <div id=\"route-view\"></div>\n  </div>\n  <script type=\"text/javascript\">\n    window.addEventListener('DOMContentLoaded', Load)\n    window.addEventListener('popstate', PopChange)\n    var routeView = null\n    function Load() {\n      routeView = document.getElementById('route-view')\n      // 默认执行一次 popstate 的回调函数，匹配一次页面组件\n      PopChange()\n      // 获取所有带 href 属性的 a 标签节点\n      var aList = document.querySelectorAll('a[href]')\n      // 遍历 a 标签节点数组，阻止默认事件，添加点击事件回调函数\n      aList.forEach(aNode => aNode.addEventListener('click', function(e) {\n        e.preventDefault() //阻止a标签的默认事件\n        var href = aNode.getAttribute('href')\n        //  手动修改浏览器的地址栏\n        history.pushState(null, '', href)\n        // 通过 history.pushState 手动修改地址栏，\n        // popstate 是监听不到地址栏的变化，所以此处需要手动执行回调函数 PopChange\n        PopChange()\n      }))\n    }\n    function PopChange() {\n      console.log('location', location)\n      switch(location.pathname) {\n      case '/page1':\n        routeView.innerHTML = 'page1'\n        return\n      case '/page2':\n        routeView.innerHTML = 'page2'\n        return\n      default:\n        routeView.innerHTML = 'page1'\n        return\n      }\n    }\n  <\/script>\n</body>\n</html>\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["这里注意，不能在浏览器直接打开静态文件，需要通过 web 服务，启动端口去浏览网址。默认打开的协议是 file 协议，它是不会被 ",(0,i.jsx)(n.code,{children:"popstate"})," 监听的。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"总结",children:["总结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"认真阅读完上述内容，基本上对前端单页面的实现原理有了一个大概的雏形，更深入的学习还是需要再对框架的源码进行分析。"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}let x=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F10.%E5%89%8D%E7%AB%AF%E9%A2%84%E5%A4%87%EF%BC%9A%E7%8E%B0%E4%BB%A3%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E5%8D%95%E9%A1%B5%E9%9D%A2%E6%A6%82%E5%BF%B5.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"知识点",id:"知识点",depth:4},{text:"单页面",id:"单页面",depth:2},{text:"传统页面",id:"传统页面",depth:4},{text:"单页面",id:"单页面-1",depth:4},{text:"路由实现原理",id:"路由实现原理",depth:4},{text:"总结",id:"总结",depth:2}],title:"10.前端预备：现代前端框架单页面概念",headingTitle:"10.前端预备：现代前端框架单页面概念",frontmatter:{}}}}]);