"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["46848"],{518533:function(n,e,d){d.r(e),d.d(e,{default:()=>h});var r=d(552676),i=d(740453);function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",h3:"h3",blockquote:"blockquote",strong:"strong",pre:"pre",ul:"ul",li:"li"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"第05章代码优化挑选合适的数据类型",children:["第05章—代码优化：挑选合适的数据类型",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第05章代码优化挑选合适的数据类型",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"\uFEFF上一章我们讲了值类型和引用类型两大类型的数据，本章我们就来讲它们的使用。"}),"\n",(0,r.jsxs)(e.p,{children:["众所周知，算法的执行效率就两个考量因素：",(0,r.jsx)(e.code,{children:"空间"}),"和",(0,r.jsx)(e.code,{children:"时间"}),"。而代码是算法的结合体，需要考量的也是这两个因素。看具体需求选择合适的数据类型就成了必备技能。"]}),"\n",(0,r.jsxs)(e.h2,{id:"空间筛选",children:["空间筛选",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#空间筛选",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["首先，我们在了解了数据类型大小以及范围的时候，",(0,r.jsx)(e.code,{children:"优先考虑空间筛选"}),"，因为空间筛选决定的是对错问题，这是最重要的，比如，为了省内存，选了个小的，结果线上出了 bug，这就不是优化时间性能可以改变的了。"]}),"\n",(0,r.jsxs)(e.h3,{id:"优先选择小的",children:["优先选择小的",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#优先选择小的",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"在满足需求的情况下，优先选择更小的数据类型。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"比如，我们知道 boolean 单独使用时其实是用 int 表示的，那么我们就用更小的 byte 来表示，0 表示女，1 表示男，也很形象。"}),"\n",(0,r.jsx)(e.p,{children:"而当我们使用 boolean 数组时候，再用 boolean 来表示。"}),"\n",(0,r.jsx)(e.p,{children:"但是，有时候我们也不能光顾着省内存，而忽略了程序本身的正确性。"}),"\n",(0,r.jsx)(e.p,{children:"比如，我现在要创建一个所有用户的历史消息表，那么它的 id 用什么来表示呢？"}),"\n",(0,r.jsx)(e.p,{children:"我想想啊，一个 int 就足够了，因为不可能有十亿多条数据，这是不对的，因为你这是历史数据，历史的积累是很可怕的，比如微信 APP，动不动几个 G 的数据，而且卸载了之后，历史聊天记录也没了，为啥呢？因为历史数据太多了，历史的积累太可怕了。"}),"\n",(0,r.jsx)(e.p,{children:"所以，你应该选择 long 类型的 id，并且做好数据扩充。"}),"\n",(0,r.jsxs)(e.h3,{id:"优先选择容易改变的",children:["优先选择容易改变的",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#优先选择容易改变的",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"在满足条件的情况下，优先选择容易改变的数据类型。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"上一章我们讲到，利用数组可以快速访问每一个元素，但是数组有个缺点就是扩容很费劲，需要连续的内存空间，如果扩容失败，就会造成很严重的影响。"}),"\n",(0,r.jsx)(e.p,{children:"那么，作为一个大工程项目，我们在选择容器类数据类型时，就要优先选择容易改变的，比如后面要讲到的链表。"}),"\n",(0,r.jsx)(e.p,{children:"因为我们的需求不是一成不变的，如果你们产品发了毒誓、立了字据说不会改，那你也不能信！产品的嘴，骗人的鬼。"}),"\n",(0,r.jsx)(e.p,{children:"一定要选易变的，一定要选易变的。"}),"\n",(0,r.jsx)(e.p,{children:"如果是你们自己内定的需求，比如你给服务器传递参数，或者 SDK 层给 API 层传递数据，那你就可以用数组这类不可变长的数据结构。"}),"\n",(0,r.jsxs)(e.p,{children:["总之，对于空间这方面的要求就两个：",(0,r.jsxs)(e.strong,{children:[(0,r.jsx)(e.code,{children:"大小"}),"和",(0,r.jsx)(e.code,{children:"易变性"}),"，优先选小的，优先选易变的"]}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"接下来我们看时间筛选。"}),"\n",(0,r.jsxs)(e.h2,{id:"时间筛选",children:["时间筛选",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#时间筛选",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"选择合适的数据结构能提高程序运行的性能，这是大部分程序员拉开水平的另一个纬度，也是最容易被忽略的维度。"}),"\n",(0,r.jsx)(e.p,{children:"很多程序员觉得：写对就成，能跑就行。你放心，你 35 岁绝对能跑。"}),"\n",(0,r.jsxs)(e.h3,{id:"优先选数字类型的",children:["优先选数字类型的",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#优先选数字类型的",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["首先，我们在选择类型时候，要优先选择数字类型的，比如",(0,r.jsx)(e.code,{children:"int"}),"、",(0,r.jsx)(e.code,{children:"long"}),"等，而不是",(0,r.jsx)(e.code,{children:"String"}),"或对象类型的，为啥呢？"]}),"\n",(0,r.jsx)(e.p,{children:"因为数字类型的效率更高，不管是做算术运算、逻辑运算、还是比较运算，数字类型的效率都比引用类型的高，这就等价于提高了程序运行的速度，进而提高了性能。"}),"\n",(0,r.jsxs)(e.p,{children:["我们可以看一下 Long 类型和 String 类型的",(0,r.jsx)(e.code,{children:"equals()"}),"方法，就会发现，Long 类型简单得多，直接比较数值大小就行；而 String 类型呢，先比较长度，再逐个比较每个字符。这一对比，效率就出来了啊。"]}),"\n",(0,r.jsx)(e.p,{children:"凡是带有去重功能的集合，比如 Set、Map 等，都是使用 equals 比较两个元素是否相同，相同就删除一个，这样的操作的，就导致 equals 函数被频繁调用；如果集合过大，那么 Long 类型的效率和 String 类型的效率差距就很大，就造成了量变引起质变的效果，所以我们一定要优先使用数字类型的变量。"}),"\n",(0,r.jsxs)(e.p,{children:["再比如，我们经常用的 switch 语句，它的实现也很简单，就是将 case 语句排队，然后使用传入的元素，去逐个比较，也是调用了",(0,r.jsx)(e.code,{children:"equals()"}),"函数，如果相同，那么就执行对应的",(0,r.jsx)(e.code,{children:"case"}),"分支。"]}),"\n",(0,r.jsxs)(e.p,{children:["这里有个技巧：",(0,r.jsxs)(e.strong,{children:["使用 switch 语句时，尽量选择连续的值作为",(0,r.jsx)(e.code,{children:"case"}),"的",(0,r.jsx)(e.code,{children:"code"})]}),"。因为编译器对",(0,r.jsx)(e.code,{children:"switch"}),"有个优化过程，如果 code 是连续的，就会优化为一个类似于升序的数组，而我们又知道，数组的存取效率很高，所以我们要尽量选择连续的数字类型作为",(0,r.jsx)(e.code,{children:"switch"}),"的 code。"]}),"\n",(0,r.jsx)(e.p,{children:"类似的用法我们也可以用在基数排序和桶排序上。"}),"\n",(0,r.jsxs)(e.h3,{id:"多使用移位操作",children:["多使用移位操作",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#多使用移位操作",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196588237925580835",target:"_blank",rel:"noopener noreferrer",children:"前面第三章"}),"中，我们提到了位运算，我们知道，移位运算效率很高，所以我们平常的乘除法就可以用移位运算。"]}),"\n",(0,r.jsx)(e.p,{children:"比如，现在有个商品，单价是 16，买了 15 份，那简单啊，直接："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"int price = 16;\nint count = 15;\nint sum = price * count; //结果是240\n"})}),"\n",(0,r.jsx)(e.p,{children:"直接就得到总价了，确实不错，写得好，写得妙，写得呱呱叫。但是，我们是可以优化的，因为单价是 16，也就是 2 的 4 次方，我们直接让买的数量左移 4 位不就行了吗？"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"int price = 16; // 单价是2的4次方\nint count = 15;\nint sum = count<<4; // 单价也是240\n"})}),"\n",(0,r.jsx)(e.p,{children:"15 是 1111，左移 4 位是 1111 0000，也就是 $$2^7+2^6+2^5+2^4$$，也是 240。但是计算效率高了很多。"}),"\n",(0,r.jsx)(e.p,{children:"有人说，你这单价是 16，正好是 2 的 4 次放，我要是单价是 15 呢，你怎么算？"}),"\n",(0,r.jsx)(e.p,{children:"好，假如单价是 15，我买 20 份，那么我就可以这么算：因为 15 是 16-1，也就是 2 的 4 次方 -1，那么我让它左移 4 位，然后再减去自身不就行了吗？也就如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"int price = 15;\nint count = 20;\nint sum = (count<<4) - count;\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样一来，不用做乘除法，只需要做移位和加减法，就可以了。"}),"\n",(0,r.jsx)(e.p,{children:"那人又说了，你这属于取巧，15 距离 16 就差一，我要是单价是 13 呢？"}),"\n",(0,r.jsx)(e.p,{children:"13 等于 8+4+1，也就是 $$2^3+2^2+1$$，那就是："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"int price = 13;\nint count = 20;\nint sum = (count<<3) + (count<<2)+count;\n"})}),"\n",(0,r.jsx)(e.p,{children:"直接移位相加就可以了，连减法都不用了。"}),"\n",(0,r.jsx)(e.p,{children:"其实，电脑做乘除法用的就是加法的原则，比如：$$25\\times11$$，电脑就是将 25 累加 11 次得出的结果，你要是没有背乘法表的情况下，让你来加，你能急炸了。但是人家是电脑，电脑计算的速度非常快，很快就得出结果了。"}),"\n",(0,r.jsx)(e.p,{children:"但是我还是比较善良的，完全站在电脑的角度替它着想了，所以就优化成移位运算了，这样也可以避免量变引起质变的后果。"}),"\n",(0,r.jsxs)(e.h3,{id:"大数据的使用",children:["大数据的使用",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#大数据的使用",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"上一章我们提到浮点类型的时候说到，二进制存在精度问题，那么在我们对数据的精度要求高的情况下，要怎么办呢？"}),"\n",(0,r.jsxs)(e.p,{children:["我们可以采用 API 中提供的大数据类型，直接在编辑器中敲 Big 关键词应该都有的，比如 Java 中的",(0,r.jsx)(e.code,{children:"BigDecimal"}),"这个类。它就可以保证我们的精度问题，其实这类 API 内部采用的都是字符串，然后将数据分段表示。"]}),"\n",(0,r.jsx)(e.p,{children:"比如，Long 最大能表示 64 位数，如果我要表示 100 位呢？"}),"\n",(0,r.jsxs)(e.p,{children:["嗯，我用",(0,r.jsx)(e.code,{children:"BigInteger"}),"，它内部其实是个字符串，然后按照正常的加减运算执行，然后将结果用字符串表示出来，没办法，因为 Long 表示不下啊。这就是字符串的强大之处，正如前面我们说的，",(0,r.jsx)(e.strong,{children:"如果所有的数据类型只能保留一个，那么这个类型肯定是字符串"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"我们来模拟一个加法，来了解下大数据的实现原理。"}),"\n",(0,r.jsx)(e.p,{children:"题目：将两个字符串相加，并将结果以字符串方式放回。比如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'num1 = "11";\nnum2 = "123";\nnum1+num2 = "134";\n'})}),"\n",(0,r.jsx)(e.p,{children:"这里我就不秀代码了，直接贴官方答案："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"public String addStrings(String num1, String num2) {\n    // add表示进位 \n    int i = num1.length() - 1, j = num2.length() - 1, add = 0;\n    StringBuffer ans = new StringBuffer();\n    while (i >= 0 || j >= 0 || add != 0) {\n        // 如果还有数据，就取这个数据，否则就是0\n        int x = i >= 0 ? num1.charAt(i) - '0' : 0;\n        int y = j >= 0 ? num2.charAt(j) - '0' : 0;\n        // 本次相加的结果，需要加上上一次的进位\n        int result = x + y + add;\n        // 缀上相结果的个位数，比如相加得到15，就缀上5\n        ans.append(result % 10);\n        // 结果大于10就是有进位\n        add = result / 10;\n        i--;\n        j--;\n    }\n    // 计算完以后的答案需要翻转过来\n    ans.reverse();\n    return ans.toString();\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"核心思路说白了就是，将每一位相加，相加后的进位算到下一次里面去，结果用字符串保存下来，这样不管数据有多大，都不会越界，都能得到正确的结果。"}),"\n",(0,r.jsxs)(e.h2,{id:"自定义数据类型",children:["自定义数据类型",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义数据类型",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["有人说，这些数据类型都不满足我啊，怎么办呢？这时候你就可以使用自定义数据类型了，也就是",(0,r.jsx)(e.strong,{children:"类"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"比如，现在我有辆车，车又不是 int 类型的，也不是 String 类型的，嗯，那我就定义一个类型，这个类型就叫做“车”。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Car {}\n"})}),"\n",(0,r.jsx)(e.p,{children:"那么，怎么使用呢？跟一般的类型一样，比如你用 int 的时候就是："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"int a;\n"})}),"\n",(0,r.jsx)(e.p,{children:"那么你用自定义的“车”的时候，就是："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Car car;\n"})}),"\n",(0,r.jsx)(e.p,{children:"没啥区别，其实对于电脑来说就是：一个类型，一个变量，劳资不管你是啥，你只要是这个原则，我照单全收。"}),"\n",(0,r.jsx)(e.p,{children:"等等，等等，刚刚我们说到，数组的缺点是扩容难，那么既然我们都可以自定义数据类型了，我们能不能定义一个扩容简单的呢？"}),"\n",(0,r.jsx)(e.p,{children:"当然可以！"}),"\n",(0,r.jsx)(e.p,{children:"我们这就可以定义一个链表，我们知道，数组扩容难，是因为它需要元素连续，我们只要让元素不连续不就行了吗？\n那不连续怎么找下一个元素呢？我们可以让上一个元素持有下一个元素的地址啊。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"class Node {\n    int value;\n    Node next;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"嗯，好了。"}),"\n",(0,r.jsx)(e.p,{children:"啥？就这么点代码就是链表了？"}),"\n",(0,r.jsx)(e.p,{children:"对啊，就这么简单。"}),"\n",(0,r.jsx)(e.p,{children:"比如，现在有元素 1、2、3，我要存放进去，那么就如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Node node3 = new Node();\nnode3.value = 3;\nnode3.next = null;\n\nNode node2 = new Node();\nnode2.value = 2;\nnode2.next = node3;\n\nNode node1 = new Node();\nnode1.value = 1;\nnode1.next = node2;\n"})}),"\n",(0,r.jsx)(e.p,{children:"就可以了，我们只需要知道链表的第一个元素，也就是 node1 就行了，我们要获取到 node3 的话，就先用 node1 获取到 node2，然后再用 node2 获取到 node3 ；也就是："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"node2 = node1.next;\nnode3 = node2.next;\n"})}),"\n",(0,r.jsx)(e.p,{children:"那这也太费劲了，得挨个去问一遍，但是这样不需要占用连续的内存啊，就算 node1 在地球，node2 在月球，node3 在木叶忍者村，只要根据 next 就能获取到啊。"}),"\n",(0,r.jsx)(e.p,{children:"那这确实挺不错的，有时候还挺有用的。"}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本章我们讲了怎么选择合适的数据类型，以及使用大数据类型和自定义数据类型。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"优先选择小的"}),"，因为小的更省内存。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"优先选择容易扩容的"}),"，项目是多变的，要面向改变编程。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"优先选择数字类型的"}),"，数字类型的效率更高。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"多使用移位操作"}),"，移位操作可以提高程序的运行速度。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"遇到越界或精度问题可以使用大数据"}),"，大数据的核心是使用字符串实现的。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"自定义数据类型"}),"，当现有数据类型不能满足时，就用自定义数据类型。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"那么下一章，我们就来看这些数据是怎么被读入内存并执行的。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(s,{...n})}):s(n)}let h=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC05%E7%AB%A0%E2%80%94%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%EF%BC%9A%E6%8C%91%E9%80%89%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md"]={toc:[{text:"空间筛选",id:"空间筛选",depth:2},{text:"优先选择小的",id:"优先选择小的",depth:3},{text:"优先选择容易改变的",id:"优先选择容易改变的",depth:3},{text:"时间筛选",id:"时间筛选",depth:2},{text:"优先选数字类型的",id:"优先选数字类型的",depth:3},{text:"多使用移位操作",id:"多使用移位操作",depth:3},{text:"大数据的使用",id:"大数据的使用",depth:3},{text:"自定义数据类型",id:"自定义数据类型",depth:2},{text:"总结",id:"总结",depth:2}],title:"第05章—代码优化：挑选合适的数据类型",headingTitle:"第05章—代码优化：挑选合适的数据类型",frontmatter:{}}}}]);