"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["29483"],{952228:function(n,e,s){s.r(e),s.d(e,{default:()=>C});var r=s(552676),t=s(740453);let i=s.p+"static/image/f0e9664537ef4a4f40e0c4571fa86535.337f4028.webp",l=s.p+"static/image/36b3a97f2a2d4e80e57d3eb99413b5f0.399fa7e3.webp",d=s.p+"static/image/eb3ea8d8a049a10eb6f067809f49c4a6.7aa32afd.webp",a=s.p+"static/image/93495dcd74a54a5df9dc93699eea4460.efd499cf.webp",c=s.p+"static/image/47def386bead30355d1ef9d09761fb11.6c2cdadc.webp",g=s.p+"static/image/6007d2d5023341735481b883e06179dd.0eb8d6d0.webp",o=s.p+"static/image/739bfed01a536554a92ead6578432fb3.68253c47.webp",h=s.p+"static/image/80b60c4e779a0e77839d9237eb657ea7.173c50d9.webp",j=s.p+"static/image/fb261f4f3d06721dc87638636777d00d.c08a5014.webp",p=s.p+"static/image/fa66c278f2a60f3e7a95a3a345cb7a16.617fa9a7.webp",u=s.p+"static/image/f1c1b1136bc18b232afc017d300dde30.b300a8a3.webp",x=s.p+"static/image/ea5c163245c756b9b6db1da853355f35.5a7f091d.webp";function m(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",img:"img",h2:"h2",ul:"ul",li:"li",h4:"h4",pre:"pre",code:"code"},(0,t.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"24服务端实战搭建服务开发",children:["24.服务端实战：搭建服务开发",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#24服务端实战搭建服务开发",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本章开始将进入 ",(0,r.jsx)(e.strong,{children:"搭建服务端"})," 的开发章节，对应的小册目录 ",(0,r.jsx)(e.strong,{children:"ignitionServer"})," 如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"由于篇幅有限我们依然将仅仅将选择主要的工程架构来讲解，但更多的细节内容会放在直播（录播）中介绍。"}),"\n",(0,r.jsxs)(e.h2,{id:"项目搭建",children:["项目搭建",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#项目搭建",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["与 ",(0,r.jsx)(e.strong,{children:"Devops"}),"、",(0,r.jsx)(e.strong,{children:"Materials"})," 以及 ",(0,r.jsx)(e.strong,{children:"User"})," 三个系统不同的是，搭建服务选用的数据库为 ",(0,r.jsx)(e.strong,{children:"Mongodb"}),"，因为搭建服务端比较重前端的 ",(0,r.jsx)(e.strong,{children:"Schema"})," 组合，如果选择 ",(0,r.jsx)(e.strong,{children:"Mysql"})," 作为数据库的话，在组建 ",(0,r.jsx)(e.strong,{children:"Schema"})," 方面并没有那么灵活。"]}),"\n",(0,r.jsx)(e.p,{children:"两者的对比在技术方案选型终已经介绍过了，这里也就不再继续追加描述，接下来我们开始对照项目的代码学习。"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"搭建服务对比之前所有的系统"}),"，在架构层面反而是最为简单，如下图所示，只有两大模块："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"page"})," 页面"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"site"})," 站点"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"接下来我们按照模块来逐步介绍代码的细节。"}),"\n",(0,r.jsxs)(e.h4,{id:"site",children:["Site",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#site",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"一个公司大概率会有多个域名、多个项目，所以站点模块就是为了解决各个业务线之前的上层隔离，同时对应的"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"\n@Entity()\nexport class Site {\n  @ObjectIdColumn({ name: '_id' })\n  id: ObjectId;\n\n  @Column()\n  name: string;\n\n  @Column({ default: null })\n  description: string;\n\n  @Column({ default: null })\n  url: string;\n\n  @Column({ default: null })\n  domain: string;\n\n  @Column({ default: null })\n  apiType: API_TYPE;\n\n  @Column({ default: null })\n  currentVersion: string;\n\n  @Column({ default: null })\n  deployVersion: string;\n\n  // 设备类型\n  @Column()\n  type: PAGE_TYPE;\n\n  // site 状态\n  @Column({ default: STATUS_TYPE.activated })\n  status: number = STATUS_TYPE.activated;\n\n  @CreateDateColumn()\n  createDate: string;\n\n  @UpdateDateColumn()\n  updateDate: string;\n\n  @UpdateDateColumn({ default: null })\n  appointmentUp: string;\n\n  @UpdateDateColumn({ default: null })\n  appointmentDown: string;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["所以对应的实体类如上所示，但其中 ",(0,r.jsx)(e.strong,{children:"url"})," 字段并非是站点发布的链接，而是待解析的 ",(0,r.jsx)(e.strong,{children:"Swagger"})," 的链接，真实的域名字段为 ",(0,r.jsx)(e.strong,{children:"domain"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们拿一个标准的 ",(0,r.jsx)(e.strong,{children:"Swagger"})," 的项目来看："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["标准的 ",(0,r.jsx)(e.strong,{children:"Swagger"})," 的界面如上所示，遵循的是 ",(0,r.jsx)(e.strong,{children:"openapi 3.0"})," 的格式，所以我们其实可以拿到对应的 ",(0,r.jsx)(e.strong,{children:"json"})," 格式的版本，只需要在 ",(0,r.jsx)(e.strong,{children:"url"})," 后缀上加上 ",(0,r.jsx)(e.strong,{children:"-json"})," 即可："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["除了 ",(0,r.jsx)(e.strong,{children:"Site"})," 的增删改查之外，在里面还多有一个 ",(0,r.jsx)(e.strong,{children:"Interface"})," 的模块："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["首先正常的低代码项目是不需要这一个模块，但由于我们之前的 ",(0,r.jsx)(e.strong,{children:"MFF"})," 设计，目标是通过接口规则可以直接反转为低代码的 ",(0,r.jsx)(e.strong,{children:"Schema"})," ，所以在我们低代码的 ",(0,r.jsx)(e.strong,{children:"Site"})," 需要增加这个模块来保存解析出来的 ",(0,r.jsx)(e.strong,{children:"Schema"})," 结构。"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["如上图所示，基本上只要 ",(0,r.jsx)(e.strong,{children:"Swagger"})," 的注释写得好，那么对应的字段解析也会更加精准，我们的目标是从源头就将数据规范定义好，减少二次校正的机会，也提高了快速生成中台页面的效率。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"@Entity()\nexport class Interface {\n  @ObjectIdColumn()\n  id: ObjectId;\n\n  @Column()\n  siteId: string;\n\n  @Column({ default: null })\n  url: string;\n\n  @Column({ default: null })\n  summary: string;\n\n  @Column({ default: null })\n  tags: string;\n\n  @Column({ default: null })\n  schema: string;\n\n  @Column({ default: null })\n  apiType: API_TYPE;\n\n  @Column({ default: null })\n  parameterType: string;\n\n  @Column({ default: null })\n  methodType: Method;\n\n  @CreateDateColumn()\n  createDate: string;\n\n  @UpdateDateColumn()\n  updateDate: string;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Interface"})," 的实体类如上所示，其实主要解析了 ",(0,r.jsx)(e.strong,{children:"json"})," 的数据保存了一次，具体的解析代码在下图所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["因为我们有出码的打算，所以在项目中也引入了 ",(0,r.jsx)(e.strong,{children:"Nunjuck"}),"，作为一个独立的工具模块，后期我们会额外拓展讲解。"]}),"\n",(0,r.jsxs)(e.h4,{id:"page",children:["Page",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#page",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Page"})," 模块作为直接的产物模型，我们每一个页面都会有一个对应的 ",(0,r.jsx)(e.strong,{children:"Page"})," 数据，同时每一个 ",(0,r.jsx)(e.strong,{children:"Page"})," 又会有多份配置数据，所以 ",(0,r.jsx)(e.strong,{children:"Page"})," 模块下会有 ",(0,r.jsx)(e.strong,{children:"Config"})," 与 ",(0,r.jsx)(e.strong,{children:"Deploy"})," 两个模块。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"@Entity()\nexport class Page {\n  @ObjectIdColumn()\n  id: ObjectId;\n\n  @Column()\n  siteId: string;\n\n  @Column({ default: null })\n  path: string;\n\n  @Column()\n  name: string;\n\n  @Column({ default: null })\n  currentConfigId: string;\n\n  @Column({ default: null })\n  deployConfigId: string;\n\n  @Column({ default: null })\n  currentVersion: string;\n\n  @Column({ default: null })\n  deployVersion: string;\n\n  @Column()\n  templateId: string;\n\n  // 页面渲染类型\n  @Column()\n  type: PAGE_TYPE;\n\n  // 设备类型\n  @Column()\n  device: DEVICE_TYPE;\n\n  // site 状态\n  @Column({ default: STATUS_TYPE.inactive })\n  status: STATUS_TYPE;\n\n  @CreateDateColumn()\n  createDate: string;\n\n  @UpdateDateColumn()\n  updateDate: string;\n\n  @UpdateDateColumn({ default: null })\n  appointmentUp: string;\n\n  @UpdateDateColumn({ default: null })\n  appointmentDown: string;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["其中页面的 ",(0,r.jsx)(e.strong,{children:"path"})," 是对应真实 ",(0,r.jsx)(e.strong,{children:"url"})," 的后缀，所以是 ",(0,r.jsx)(e.strong,{children:"Site"})," 中的 ",(0,r.jsx)(e.strong,{children:"domain + path"})," 等于完整的页面全路径。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"currentConfigId"})," 对应的是配置表中的字段，",(0,r.jsx)(e.strong,{children:"currentVersion"})," 是冗余字段，部分情况下减少查询次数。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"@Entity()\nexport class PageConfig {\n  @ObjectIdColumn()\n  id: ObjectId;\n\n  @Column()\n  pageId: string;\n\n  @Column()\n  version: string;\n\n  @Column({ type: 'simple-json' })\n  config?: string;\n\n  @Column({ default: STATUS_TYPE.inactive })\n  status: STATUS_TYPE;\n\n  @Column()\n  creator: string;\n  @Column()\n  creatorId: number;\n\n  @CreateDateColumn()\n  createDate: string;\n\n  @UpdateDateColumn()\n  updateDate: string;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"PageConfig"})," 与 ",(0,r.jsx)(e.strong,{children:"DeployConfig"})," 基本保持一致，但 ",(0,r.jsx)(e.strong,{children:"DeployConfig"})," 里面保存的都是正式发布的产物，方便后期线上回滚数据。"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["剩下的其他内容大部分都是常规的 ",(0,r.jsx)(e.strong,{children:"CURD"}),"，就不再过度介绍，重复介绍的价值不大，后期可以直接看源码或者直播里面介绍会更加记忆深刻。"]}),"\n",(0,r.jsxs)(e.h4,{id:"额外注意",children:["额外注意",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#额外注意",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在之前数据库的章节介绍了 ",(0,r.jsx)(e.strong,{children:"MongoDB"})," ，在这里补充一下可能会出现的问题。"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"找不到 ObjectId"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"ObjectId"})," 可以从 ",(0,r.jsx)(e.strong,{children:"mongodb"})," 库引进来，而从 ",(0,r.jsx)(e.strong,{children:"mongodb"})," 库引入的 ",(0,r.jsx)(e.strong,{children:"ObjectId"})," 可以使用 ",(0,r.jsx)(e.code,{children:"new ObjectId(id)"})," 来查询对应的数据，同时虽然实体类的主键命是 ",(0,r.jsx)(e.code,{children:"id"}),"，但插入数据库的实际字段是 ",(0,r.jsx)(e.code,{children:"_id"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"之前是只有修改的时候需要明确指定，目前看来查询也是需要明确指定，没有做隐式转换，这样有利有弊，有兴趣的同学可以深入了解下，但对于写业务来说知道方法能跑即可。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:"1705588624317.png"})}),"\n",(0,r.jsxs)(e.h2,{id:"写在最后",children:["写在最后",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#写在最后",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["目前的搭建服务是主要用于 ",(0,r.jsx)(e.strong,{children:"MFF"})," 的架构，其实还有很多的内容需要补充完善，比如需要 ",(0,r.jsx)(e.strong,{children:"Nunjuck"})," 配合出码结果、模型转换、基础数据格式解析以及加入 ",(0,r.jsx)(e.strong,{children:"mock"})," 功能等。"]}),"\n",(0,r.jsx)(e.p,{children:"但低代码大部分的内容都是在前端组建，所以未来会在设计器这块多花点时间调试。"}),"\n",(0,r.jsx)(e.p,{children:"目前这个服务目前还并不是一个通用性的搭建服务，所以后期接入老王的项目，这块的代码需要进行少量的改造，可以兼容通用性的场景。"}),"\n",(0,r.jsx)(e.p,{children:"预计年底我跟老王数据联调完毕，各位可以关注一下新的表结构设计，接入完之后也会单开一章讲如何接入通用性的低代码产品。"})]})}function f(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(m,{...n})}):m(n)}let C=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F24.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91.md"]={toc:[{text:"项目搭建",id:"项目搭建",depth:2},{text:"Site",id:"site",depth:4},{text:"Page",id:"page",depth:4},{text:"额外注意",id:"额外注意",depth:4},{text:"写在最后",id:"写在最后",depth:2}],title:"24.服务端实战：搭建服务开发",headingTitle:"24.服务端实战：搭建服务开发",frontmatter:{}}}}]);