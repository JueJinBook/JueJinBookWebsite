"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["89698"],{258744:function(n,e,r){r.r(e),r.d(e,{default:()=>h});var s=r(552676),d=r(740453);let i=r.p+"static/image/f510b674b5536c1657e8dd31300d90f5.6488385d.webp";function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",br:"br",h2:"h2",blockquote:"blockquote",strong:"strong",h3:"h3",code:"code",ol:"ol",li:"li",pre:"pre",h4:"h4",img:"img"},(0,d.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"25大厂真题训练与解读google-真题",children:["25.大厂真题训练与解读——Google 真题",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#25大厂真题训练与解读google-真题",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在这一小节，大家需要关注到的是“从具体问题中抽象算法模型”这个能力。",(0,s.jsx)(e.br,{}),"\n","直白点说，有一类题目，它们（看上去）来者不善：题干不仅天马行空，有时候还又臭又长，导致你读了五分钟很可能也只读出了一个屁——这类题目其实就是在考察你把具体问题抽象为算法模型的能力。",(0,s.jsx)(e.br,{}),"\n","遇到它，你除了不要慌、不要怕之外，最重要的是不要被题目牵着鼻子走。你得拉拢它，收买它，把它往你已经掌握的那些知识点上靠——很多时候，同学们缺少的并不是知识储备，而是【建立题目与知识点之间的关联】的能力。"]}),"\n",(0,s.jsxs)(e.h2,{id:"岛屿数量问题",children:["岛屿数量问题",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#岛屿数量问题",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["题目描述：给你一个由\xa0'1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。",(0,s.jsx)(e.br,{}),"\n","岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。",(0,s.jsx)(e.br,{}),"\n","此外，你可以假设该网格的四条边均被水包围。"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["示例 1:",(0,s.jsx)(e.br,{}),"\n","输入:",(0,s.jsx)(e.br,{}),"\n","11110",(0,s.jsx)(e.br,{}),"\n","11010",(0,s.jsx)(e.br,{}),"\n","11000",(0,s.jsx)(e.br,{}),"\n","00000",(0,s.jsx)(e.br,{}),"\n","输出: 1"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["示例 2:",(0,s.jsx)(e.br,{}),"\n","输入:",(0,s.jsx)(e.br,{}),"\n","11000",(0,s.jsx)(e.br,{}),"\n","11000",(0,s.jsx)(e.br,{}),"\n","00100",(0,s.jsx)(e.br,{}),"\n","00011",(0,s.jsx)(e.br,{}),"\n","输出: 3",(0,s.jsx)(e.br,{}),"\n","解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"命题关键字：模拟、DFS"})}),"\n",(0,s.jsxs)(e.h3,{id:"思路分析",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"这道题好就好在它题目不长，但是题干这通描述有可能会让一部分同学直接失去耐心——岛屿？水？“网格”？？？"}),"\n",(0,s.jsx)(e.p,{children:"啥啥啥？这都是啥？"}),"\n",(0,s.jsx)(e.p,{children:"其实，只要同学能够耐住性子读下去，就会发现所谓“网格”不过是二维数组，而“岛屿”和“水”这样的具体概念，题目也已经贴心地帮我们抽象为了“1”和“0”这样简单的数字。因此，我们拿到这道题，首先要做的就是把题目中这些干扰性的概念“翻译”成简单直接的算法语言："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"已知一个二维数组，定义“相互连接的1”为一个块（这里的相互连接，意思就是1和1之间可以不经过0就相互抵达），求符合条件的块的数量。"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["翻译到这个程度之后，我们不难找出“相互连接”这个关键词作为我们做题的抓手，进而去形成一个初步的思路——若当前所在位置是1，从1出发，可以抵达的",(0,s.jsx)(e.strong,{children:"所有"}),"1都和它算作同一个岛屿。注意这里我把“所有”这个词标了粗体，已经读了25节算法小册的你，请和我一起大声喊出下面这句话："]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["看到“所有”，必须想到“枚举”！看到“枚举”，必须回忆起",(0,s.jsx)(e.code,{children:"DFS"}),"和",(0,s.jsx)(e.code,{children:"BFS"}),"！"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["喜欢递归的我，选择用 ",(0,s.jsx)(e.code,{children:"DFS"})," 来做~~~"]}),"\n",(0,s.jsxs)(e.p,{children:["在明确了 ",(0,s.jsx)(e.code,{children:"DFS"})," 的大方向之后，结合题意，我们可以提取出以下关键问题："]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"如何实现对不同岛屿的统计？"}),"\n",(0,s.jsx)(e.li,{children:"已经计算过的岛屿如何排除？"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"下面我一一回答这两个问题："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["岛屿的统计思路：从起点出发，遵循“不撞水面（也就是0）不回头”的原则，枚举当前可以触及的所有1。当枚举无法继续进行时，说明当前这座岛屿被遍历完毕，记为一个。",(0,s.jsxs)(e.strong,{children:["也就是说每完成一次 ",(0,s.jsx)(e.code,{children:"DFS"}),"，就累加一个岛屿"]}),"。"]}),"\n",(0,s.jsx)(e.li,{children:"避免重复计算的方法：每遍历过一个1，就把它置为0，后续再次路过时就会自动忽略它啦~~"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"回答完这俩问题，代码也算基本写完了（如果以上描述仍然无法帮你建立清晰的思路，不妨去代码注释里找一下答案~）："}),"\n",(0,s.jsxs)(e.h3,{id:"编码实现",children:["编码实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"/**\n * @param {character[][]} grid\n * @return {number}\n */\n// 入参是二维数组\nconst numIslands = function(grid) {\n  const moveX = [0, 1, 0, -1]  \n  const moveY = [1, 0, -1, 0]   \n  // 处理二维数组的边界情况\n  if(!grid || grid.length === 0 || grid[0].length === 0) {\n      return 0\n  }  \n  // 初始化岛屿数量\n  let count = 0  \n  // 缓存二维数组的行数和列数\n  let row = grid.length, column = grid[0].length  \n  // 以行和列为线索，尝试“逐个”遍历二位数组中的坑位\n  for(let i=0; i<row; i++) {\n      for(let j=0; j<column; j++) {\n          if(grid[i][j] === '1') {\n              // 每遇到1，就进入dfs，探索岛屿边界\n              dfs(grid, i, j)  \n              // 每完成一个 dfs，就累加一个岛屿\n              count++\n          }\n      }\n  }\n  return count\n\n  // 编写探索岛屿边界的逻辑\n  function dfs(grid, i, j) {  \n      // 如果试图探索的范围已经越界，则return\n      if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j] === '0'){\n          return  \n      }   \n      // 遍历过的坑位都置0，防止反复遍历\n      grid[i][j] = '0'   \n      // 遍历完当前的1，继续去寻找下一个1\n      for(let k=0; k<4; k++) {\n          dfs(grid, i+moveX[k], j+moveY[k])\n      }\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"编码复盘",children:["编码复盘",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码复盘",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["对初学此类问题的同学来说，这道题里有一个值得关注的做题技巧，就是对 ",(0,s.jsx)(e.code,{children:"moveX"})," 和 ",(0,s.jsx)(e.code,{children:"moveY"})," 两个数组的设定："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"const moveX = [0, 1, 0, -1]  \nconst moveY = [1, 0, -1, 0]   \n"})}),"\n",(0,s.jsx)(e.p,{children:"结合代码的上下文可以看出，我们借助这两个数组，可以完成对当前格子的“垂直”和“水平”两个方向上的相邻格子的检查："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"for(let k=0; k<4; k++) {\n  dfs(grid, i+moveX[k], j+moveY[k])\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"后续我们遇到的一些题目，一旦和这道题一样，强调了“水平”、“垂直”方向上的相邻关系，我们就可以无脑复用这个套路啦~"}),"\n",(0,s.jsxs)(e.h2,{id:"扫地机器人问题",children:["“扫地机器人”问题",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#扫地机器人问题",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["题目描述：房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。",(0,s.jsx)(e.br,{}),"\n","扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。",(0,s.jsx)(e.br,{}),"\n","当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。",(0,s.jsx)(e.br,{}),"\n","请利用提供的4个API编写让机器人清理整个房间的算法。"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"interface Robot {\n\xa0 // 若下一个方格为空，则返回true，并移动至该方格\n\xa0 // 若下一个方格为障碍物，则返回false，并停留在原地\n\xa0 boolean move();\n\n  // 在调用turnLeft/turnRight后机器人会停留在原位置\n\xa0 // 每次转弯90度\n\xa0 void turnLeft();\n\xa0 void turnRight();\n\n  // 清理所在方格\n  void clean();\n}\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["示例:",(0,s.jsx)(e.br,{}),"\n","输入:",(0,s.jsx)(e.br,{}),"\n","room = [",(0,s.jsx)(e.br,{}),"\n","[1,1,1,1,1,0,1,1],",(0,s.jsx)(e.br,{}),"\n","[1,1,1,1,1,0,1,1],",(0,s.jsx)(e.br,{}),"\n","[1,0,1,1,1,1,1,1],",(0,s.jsx)(e.br,{}),"\n","[0,0,0,1,0,0,0,0],",(0,s.jsx)(e.br,{}),"\n","[1,1,1,1,1,1,1,1]",(0,s.jsx)(e.br,{}),"\n","],",(0,s.jsx)(e.br,{}),"\n","row = 1,",(0,s.jsx)(e.br,{}),"\n","col = 3",(0,s.jsx)(e.br,{}),"\n","解析:\n房间格栅用0或1填充。0表示障碍物，1表示可以通过。\n机器人从row=1，col=3的初始位置出发。在左上角的一行以下，三列以右。"]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["注意:",(0,s.jsx)(e.br,{}),"\n","输入只用于初始化房间和机器人的位置。你需要“盲解”这个问题。换而言之，你必须在对房间和机器人位置一无所知的情况下，只使用4个给出的API解决问题。\xa0",(0,s.jsx)(e.br,{}),"\n","扫地机器人的初始位置一定是空地。",(0,s.jsx)(e.br,{}),"\n","扫地机器人的初始方向向上。",(0,s.jsx)(e.br,{}),"\n","所有可抵达的格子都是相连的，亦即所有标记为1的格子机器人都可以抵达。",(0,s.jsx)(e.br,{}),"\n","可以假定格栅的四周都被墙包围。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"命题关键字：模拟、DFS"})}),"\n",(0,s.jsxs)(e.h3,{id:"思路分析-1",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-1",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"这道题很明显属于我们开篇提到过的“又臭又长”系列。但笔者相信，每一个做过“岛屿数量”的同学，在面对这道题的时候，至少心里是不会怂的。  毕竟，它们也长得太像了："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"room = [   \n  [1,1,1,1,1,0,1,1],   \n  [1,1,1,1,1,0,1,1],   \n  [1,0,1,1,1,1,1,1],   \n  [0,0,0,1,0,0,0,0],   \n  [1,1,1,1,1,1,1,1]   \n]\n"})}),"\n",(0,s.jsx)(e.p,{children:"变化的题干，不变的1&0二维数组，嘿嘿嘿。"}),"\n",(0,s.jsxs)(e.p,{children:["现在我们回头研究一下题干。",(0,s.jsx)(e.br,{}),"\n","前面咱们说过，对于这种场景感比较强的具体问题，最要紧的是从冗长的描述中去提取出确切的算法问题。因此大家最好先尝试自己先翻译一下题干，想想它到底想让你干嘛。",(0,s.jsx)(e.br,{}),"\n","这里我先给出自己做这道题时的脑回路，大家不妨观察一下这个思考的过程，",(0,s.jsx)(e.strong,{children:"你会发现这些思路其实都不是从天而降的，而是来源于对已经做过的题目的吸收和反思"}),"："]}),"\n",(0,s.jsxs)(e.h4,{id:"整体思路",children:["整体思路",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#整体思路",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["这道题涉及到对二维数组网格的枚举，可能与岛屿数量问题的基本思路一致（将",(0,s.jsx)(e.code,{children:"DFS"}),"作为优先方法来考虑）。虽然我不知道对不对，但是沿着这个思路往下多分析几步总是好的："]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"机器人从初始位置出发，检查上下左右四个方向是否有障碍物，进而决定是否进入对应方向的格子完成清扫。"}),"\n",(0,s.jsxs)(e.li,{children:["因为题目强调了“所有可抵达的格子都是相连的，亦即所有标记为1的格子机器人都可以抵达”，所以我们借助",(0,s.jsx)(e.code,{children:"DFS"}),"尝试枚举所有可抵达的格子是完全没有问题的。",(0,s.jsx)(e.code,{children:"DFS"}),"的主要递归逻辑其实就是步骤1。"]}),"\n",(0,s.jsx)(e.li,{children:"当某一个方向已经“撞到南墙”后，机器人应该逐渐回溯到上一个位置，尝试新的方向。"}),"\n",(0,s.jsx)(e.li,{children:"最后，由于递归边界其实就是障碍物/已经清扫过的格子。所以别忘了对已经清扫过的格子做个标记。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"整个思路捋下来，没有逻辑上的硬伤。下面我试着对具体问题进行分析，看看实现起来有没有什么困难。"}),"\n",(0,s.jsxs)(e.h4,{id:"机器人的前进规则分析",children:["机器人的前进规则分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#机器人的前进规则分析",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["题目的复杂之处在于强调了“上下左右”的概念，它要求我们先旋转、再判断、最后根据判断结果决定是否需要前进。也就是说，我们不仅需要考虑机器人的前进坐标，还需要考虑机器人的旋转角度。其实无论旋转也好、前进也罢，本质上都是让它“自己动”。大家记住，“自己动”往往和循环有关。比如说上一道题里，我们就是用一个固定 ",(0,s.jsx)(e.code,{children:"k=4"})," 的循环来完成了上下左右四个方向的前进："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"for(let k=0; k<4; k++) {\n  dfs(grid, i+moveX[k], j+moveY[k])\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在这道题里，我们同样可以用类似的循环来实现四个方向的旋转+前进。",(0,s.jsx)(e.br,{}),"\n","明确了循环结构的设计，现在继续来分析循环体。",(0,s.jsx)(e.br,{}),"\n","既然题目已经把步骤拆成了旋转和前进两步，那么我们就有必要把旋转角度和前进坐标之间的关系对应起来。假设机器人现在所在的格子坐标是 ",(0,s.jsx)(e.code,{children:"(i, j)"}),"，它的旋转角度以及对应的前进坐标之间就有以下关系（结合题意我们把“上”这个初始方向记为0度）："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"（定义逻辑）  \n// 初始化角度为 0 度  \nlet dir = 0   \n...   \n\n（判断逻辑）\n// 将角度和前进坐标对应起来\nswitch(dir) {\n    // 0度的前进坐标，是当前坐标向上走一步\n    case 0:   \n        x = i - 1  \n        break\n    // 90度（顺时针）的前进坐标，是当前坐标向右走一步\n    case 90: \n        y = j + 1   \n        break\n    // 180度（顺时针）的前进坐标，是当前坐标向下走一步\n    case 180: \n        x = i + 1  \n        break\n    // 270度（顺时针）的前进坐标，是当前坐标向左走一步\n    case 270: \n        y = j - 1\n        break\n    default:\n        break\n}\n...\n（叠加逻辑）\n// 注意这里我给机器人的规则就是每次顺时针转一个方向，所以是 turnRight\nrobot.turnRight() \n// turnRight的同时，dir需要跟着旋转90度  \ndir += 90  \n// 这里取模是为了保证dir在[0, 360]的范围内变化\ndir %= 360 \n"})}),"\n",(0,s.jsxs)(e.h4,{id:"如何优雅地对已处理过的格子做标记",children:["如何优雅地对已处理过的格子做标记",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#如何优雅地对已处理过的格子做标记",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["请思考一下，在这道题里，是否还可以沿用“岛屿数量”问题中直接修改二维数组的思路？说实话，没试过，也不建议——就这道题来说，题给的四个",(0,s.jsx)(e.code,{children:"API"}),"都不是我们自己实现的，一旦改了全局的 ",(0,s.jsx)(e.code,{children:"room"})," 变量，谁知道会影响哪个",(0,s.jsx)(e.code,{children:"API"}),"呢。保险起见，我们应该优先考虑不污染",(0,s.jsx)(e.code,{children:"room"}),"变量的实现方法，这里我借助的是 ",(0,s.jsx)(e.code,{children:"Set"})," 数据结构："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"（以下是定义逻辑）\n//初始化一个 set 结构来存储清扫过的坐标\nconst boxSet =  new Set()  \n...\n\n（以下是判断逻辑）\n// 标识当前格子的坐标\nlet box = i + '+' + j  \n// 如果已经打扫过，那么跳过\nif(boxSet.has(box)) return \n// 打扫当前这个格子\nrobot.clean()  \n// 记住这个格子\nboxSet.add(box)\n"})}),"\n",(0,s.jsx)(e.p,{children:"OK，分析完这三个大问题，我们的代码也基本写完了："}),"\n",(0,s.jsxs)(e.h3,{id:"编码实现-1",children:["编码实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-1",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"/**\n * @param {Robot} robot\n * @return {void}\n */\nconst cleanRoom = function(robot) {\n    // 初始化一个 set 结构来存储清扫过的坐标\n    const boxSet =  new Set()  \n    // 初始化机器人的朝向\n    let dir = 0  \n    // 进入 dfs\n    dfs(robot, boxSet, 0, 0, 0)\n\n    // 定义 dfs  \n    function dfs(robot, boxSet, i, j, dir) {\n        // 记录当前格子的坐标\n        let box = i + '+' + j  \n        // 如果已经打扫过，那么跳过\n        if(boxSet.has(box)) return \n        // 打扫当前这个格子\n        robot.clean()  \n        // 记住这个格子\n        boxSet.add(box)\n\n        // 四个方向试探\n        for(let k=0;k<4;k++) {\n            // 如果接下来前进的目标方向不是障碍物（也就意味着可以打扫）\n            if(robot.move()) {\n                // 从当前格子出发，试探上右左下\n                let x = i, y = j\n                // 处理角度和坐标的对应关系\n                switch(dir) {\n                    case 0:   \n                        x = i - 1  \n                        break\n                    case 90: \n                        y = j + 1   \n                        break  \n                    case 180: \n                        x = i + 1  \n                        break  \n                    case 270: \n                        y = j - 1\n                        break   \n                    default:\n                        break\n                }\n                dfs(robot, boxSet, x, y, dir)\n                // 一个方向的dfs结束了，意味着撞到了南墙，此时我们需要回溯到上一个格子 \n                robot.turnLeft()\n                robot.turnLeft()\n                robot.move()\n                robot.turnRight()\n                robot.turnRight()\n            }\n            // 转向 \n            robot.turnRight() \n            dir += 90  \n            dir %= 360 \n\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"编码复盘-1",children:["编码复盘",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码复盘-1",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"这里有一段逻辑可能会让初学题目的同学蒙圈："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"dfs(robot, boxSet, x, y, dir)\nrobot.turnLeft()\nrobot.turnLeft()\nrobot.move()\nrobot.turnRight()\nrobot.turnRight()\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这是在干啥？",(0,s.jsx)(e.br,{}),"\n","结合一下代码的上下文，这里我给机器人的设定是："]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"你在进入每一个格子后，都需要基于当前方向顺时针旋转四次"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["在这个前提下，机器人在 ",(0,s.jsx)(e.code,{children:"(x,y)"})," 这个格子工作完之后，它的朝向一定是和刚进入 ",(0,s.jsx)(e.code,{children:"(x,y)"}),"时的朝向是一样的，区别在于在原来的基础上多走了一个格子："]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(e.p,{children:["此时后一个网格的机器人要想退回“事前”的状态，它必须先旋转 180 度，然后前进一步，再旋转 180 度。而“旋转 180 度”这个动作，可以通过连续两次 ",(0,s.jsx)(e.code,{children:"turnLeft"}),"或者",(0,s.jsx)(e.code,{children:"turnRight"}),"来完成。这里我为了写代码好看，各用了一次（羞）。"]}),"\n",(0,s.jsxs)(e.h2,{id:"合并区间问题",children:["“合并区间”问题",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#合并区间问题",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"题目描述：给出一个区间的集合，请合并所有重叠的区间。"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["示例 1:",(0,s.jsx)(e.br,{}),"\n","输入: [[1,3],[2,6],[8,10],[15,18]]",(0,s.jsx)(e.br,{}),"\n","输出: [[1,6],[8,10],[15,18]]",(0,s.jsx)(e.br,{}),"\n","解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]."]}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["示例\xa02:",(0,s.jsx)(e.br,{}),"\n","输入: [[1,4],[4,5]]",(0,s.jsx)(e.br,{}),"\n","输出: [[1,5]]",(0,s.jsx)(e.br,{}),"\n","解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"命题关键字：数学问题、数组"})}),"\n",(0,s.jsxs)(e.h3,{id:"思路分析-2",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-2",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["做完两道应用题，大家放松一下，换换口味，现在我们来一起解决一个并没有许多套路的数学问题。",(0,s.jsx)(e.br,{}),"\n","这个题里，你什么都可以忽略，但是请一定抓住“区间”二字，并记住下面这样一个规律："]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"对于区间类问题，尝试以区间内的第一个元素为索引进行排序，往往可以帮助我们找到问题的突破点"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"不信我们来看看这道题，题中给了我们这样一个例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"[[1,3],[2,6],[8,10],[15,18]] \n"})}),"\n",(0,s.jsx)(e.p,{children:"这个例子就是一个排序过的区间，当区间排序后，区间与区间之间的重叠关系会变得非常有迹可循:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"[1, 3]\n  [2, 6]\n            [8, 10]\n                        [15, 18]\n"})}),"\n",(0,s.jsxs)(e.p,{children:["可以看出，对于有序区间，我们其实可以从头开始，",(0,s.jsx)(e.strong,{children:"逐个合并首尾有交集的区间"}),"——比如上面区间关系图中的 ",(0,s.jsx)(e.code,{children:"[1, 3]"})," 和 ",(0,s.jsx)(e.code,{children:"[2, 6]"}),"，由于前一个区间的尾部（3）和下一个区间的头部（2）是有交错关系的（这个交错关系用数学语言表达出来就是",(0,s.jsx)(e.code,{children:"前一个的尾部 >= 下一个的头部"}),"），因此我们可以毫不犹豫地把它们合并为一个区间："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"[1, 3] + [2, 6] ==> [1, 6]\n"})}),"\n",(0,s.jsx)(e.p,{children:"遵循这个合并规则，我们可以编码如下："}),"\n",(0,s.jsxs)(e.h3,{id:"编码实现-2",children:["编码实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-2",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nconst merge = function(intervals) {\n    // 定义结果数组\n    const res = []  \n    // 缓存区间个数\n    const len = intervals.length\n    // 将所有区间按照第一个元素大小排序\n    intervals.sort(function(a, b) {\n        return a[0] - b[0]\n    }) \n    // 处理区间的边界情况\n    if(!intervals || !intervals.length) {\n        return []\n    }\n    // 将第一个区间（起始元素最小的区间）推入结果数组（初始化）\n    res.push(intervals[0])\n    // 按照顺序，逐个遍历所有区间\n    for(let i=1; i<len; i++) {\n        // 取结果数组中的最后一个元素，作为当前对比的参考\n        prev = res[res.length-1]  \n        // 若满足交错关系（前一个的尾部 >= 下一个的头部）\n        if(prev[1] >= intervals[i][0]) {\n            prev[1] = Math.max(prev[1], intervals[i][1])\n        } else {\n            res.push(intervals[i])\n        }\n    }\n    return res\n}\n"})})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}let h=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%2F25.%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%E4%B8%8E%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94Google%20%E7%9C%9F%E9%A2%98.md"]={toc:[{text:"岛屿数量问题",id:"岛屿数量问题",depth:2},{text:"思路分析",id:"思路分析",depth:3},{text:"编码实现",id:"编码实现",depth:3},{text:"编码复盘",id:"编码复盘",depth:3},{text:"“扫地机器人”问题",id:"扫地机器人问题",depth:2},{text:"思路分析",id:"思路分析-1",depth:3},{text:"整体思路",id:"整体思路",depth:4},{text:"机器人的前进规则分析",id:"机器人的前进规则分析",depth:4},{text:"如何优雅地对已处理过的格子做标记",id:"如何优雅地对已处理过的格子做标记",depth:4},{text:"编码实现",id:"编码实现-1",depth:3},{text:"编码复盘",id:"编码复盘-1",depth:3},{text:"“合并区间”问题",id:"合并区间问题",depth:2},{text:"思路分析",id:"思路分析-2",depth:3},{text:"编码实现",id:"编码实现-2",depth:3}],title:"25.大厂真题训练与解读——Google 真题",headingTitle:"25.大厂真题训练与解读——Google 真题",frontmatter:{}}}}]);