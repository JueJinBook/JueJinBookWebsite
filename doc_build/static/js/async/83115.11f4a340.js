"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["83115"],{89337:function(e,n,r){r.r(n),r.d(n,{default:()=>f});var i=r(552676),t=r(740453);let s=r.p+"static/image/626a5e4aa94ab38e296b834993296252.c5b4ac5f.webp",a=r.p+"static/image/32cffa167dc2753257ebe720f8406f98.295b0b32.webp",o=r.p+"static/image/ed3982af9b94c5bd5880b81267ba1deb.84a57472.webp",d=r.p+"static/image/3f4b8bf82195a27b669a2f0ea78597f3.00ad9e3d.webp",l=r.p+"static/image/2597a8fe6be035d04eef4144d68ee4c4.c617d4be.webp",c=r.p+"static/image/78fd07ac7ed9797fa59677eed8750410.b436ef66.webp",m=r.p+"static/image/9ac19df2b0ab49d2844bac7c9c7b41d5.49331046.webp",p=r.p+"static/image/b971720b6a5abb8b2af7fcb74ae6f0ec.b0074b2e.webp",u=r.p+"static/image/387175028a11269863cb7b43fea642b4.4ab4ea58.webp",h=r.p+"static/image/4a67b366d8d3915afdb4634b9f8d8cf5.d9e1be32.webp",g=r.p+"static/image/d55da48f0f4ab6427904a25db9d7b172.7ac418b9.webp",x=r.p+"static/image/57b61b8c6e6733c8e9398b6b37e991ef.7ed580e6.webp",j=r.p+"static/image/462e3720db38ae18b2b305caf6328092.4fc60f17.webp";function k(e){let n=Object.assign({h1:"h1",a:"a",pre:"pre",code:"code",p:"p",h2:"h2",img:"img",h4:"h4",ul:"ul",li:"li",ol:"ol",strong:"strong"},(0,t.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"24api-接口开发实战之用户身份认证详解",children:["24.API 接口开发实战之用户身份认证详解",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24api-接口开发实战之用户身份认证详解",children:"#"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tip",children:"本篇文章中所涉及的源码已经整理好并上传到百度云，地址和提取密码如下：\n链接: https://pan.baidu.com/s/1t6UQyzcYa9rhnqY5wVt1Vg \n提取码: b65z\n"})}),"\n",(0,i.jsx)(n.p,{children:"在前一个实验中我们实现了用户的登陆接口，该功能已经完成，但是身份认证的整个流程并没有完善，该流程中应该包括登陆功能、身份认证、访问拦截、退出功能，我们仅仅完成了第一步，因此本实验将会对该流程进行完善，将接下来的功能点完成。"}),"\n",(0,i.jsxs)(n.p,{children:["新蜂商城第一个版本后台管理系统中，身份验证使用的方式是 ",(0,i.jsx)(n.code,{children:"session"})," +拦截器实现，目的是为了验证是否登录，也就是简单的权限认证。现在这个版本是前后端分离的版本，我们用了一种新的方式，前文中我们也介绍到，登录成功后会有一个 ",(0,i.jsx)(n.code,{children:"token"})," 值，那么我们该怎样使用这个 ",(0,i.jsx)(n.code,{children:"token"})," 字符串呢？"]}),"\n",(0,i.jsxs)(n.h2,{id:"身份认证",children:["身份认证",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#身份认证",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"我们继续结合登录验证流程来讲一下："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"//p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/860c814708d4471abad72f6ef70b6caf~tplv-k3u1fbpfcp-zoom-1.image",alt:"login-check-detail"})}),"\n",(0,i.jsx)(n.p,{children:"前文中处理的流程分支是 token 不存在之后的登录处理流程，如果 token 存在我们该怎样进行身份认证？"}),"\n",(0,i.jsxs)(n.h4,{id:"前端存储和使用-token",children:["前端存储和使用 token",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前端存储和使用-token",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["后端生成 token，前端存储和使用 token，在请求登录接口成功后，前端的处理方式首先会将 token 字符串存储到 ",(0,i.jsx)(n.code,{children:"localStorage"})," 中，实现代码在 vue3-admin 项目的 ",(0,i.jsx)(n.code,{children:"Login.vue"})," 文件中："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"    const submitForm = async () => {\n      loginForm.value.validate((valid) => {\n        if (valid) {\n          axios.post('/adminUser/login', {\n            userName: state.ruleForm.username || '',\n            passwordMd5: md5(state.ruleForm.password)\n          }).then(res => {\n            localSet('token', res)\n            window.location.href = '/'\n          })\n        } else {\n          console.log('error submit!!')\n          return false;\n        }\n      })\n    }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这是 web 端实现时的方案，将登录成功后的 token 值存储到 ",(0,i.jsx)(n.code,{children:"localStorage"})," 对象中，如果是 iOS 开发或者安卓开发可能又有其对应的存储方式，不过存储的目的就是在后续请求中带上 token 值，使得后端在处理请求时可能进行身份认证。"]}),"\n",(0,i.jsx)(n.p,{children:"有了 token 值，在过期时间内我们都可以使用它来进行资源请求，新蜂商城 Vue 版本是如何将 token 值放到请求中的呢？"}),"\n",(0,i.jsxs)(n.p,{children:["具体实现代码在 ",(0,i.jsx)(n.code,{children:"axios.js"})," 中："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// 请求头，headers 信息\naxios.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'\naxios.defaults.headers['token'] = localGet('token') || ''\n// 默认 post 请求，使用 application/json 形式\naxios.defaults.headers.post['Content-Type'] = 'application/json'\n"})}),"\n",(0,i.jsxs)(n.p,{children:["如果存在 token 值则将其放入到请求 header 对象中，此 header 参数的名称即为 ",(0,i.jsx)(n.code,{children:"token"}),"，打开控制台可以看到具体的请求样例："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:j,alt:"image-20210407120005916"})}),"\n",(0,i.jsxs)(n.p,{children:["这是 vue3-admin 项目中几个具体的请求案例，在 Request Headers 中就有 token 参数，该值就是之前登陆成功后存储到 ",(0,i.jsx)(n.code,{children:"localStorage"}),"中的值。"]}),"\n",(0,i.jsx)(n.p,{children:"以上就是前端处理 token 值需要注意的点，接下来我们来讲解后端代码中是如何处理 token 的。"}),"\n",(0,i.jsxs)(n.h4,{id:"后端处理-token-及身份验证",children:["后端处理 token 及身份验证",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#后端处理-token-及身份验证",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"第一步是生成 token，这个在前一个章节中已经介绍。"}),"\n",(0,i.jsx)(n.li,{children:"第二步是获取到前端请求中的 token 值。"}),"\n",(0,i.jsx)(n.li,{children:"第三步是验证 token 值，是否存在、是否过期等等。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"完成登录功能后，则需要对管理员的登录状态进行验证，这里所说的登录状态保持即 “ Token 值是否存在及 Token 值是否有效 ” 。"}),"\n",(0,i.jsx)(n.p,{children:"而 Token 值是否有效则通过后端代码实现，由于大部分接口都需要进行登录验证，如果每个方法都添加查询用户数据的语句则有些多余，因此对方法做了抽取，通过注解切面的形式来返回用户信息。"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"自定义参数注解"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["我们自定义 ",(0,i.jsx)(n.code,{children:"@TokenToAdminUser"})," 注解，使用注解和 AOP 方式将管理员登录对象注入到方法中："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'package ltd.newbee.mall.config.annotation;\n\nimport java.lang.annotation.*;\n\n@Target({ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface TokenToAdminUser {\n\n    /**\n     * 当前用户在request中的名字\n     *\n     * @return\n     */\n    String value() default "adminUser";\n\n}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"自定义方法参数解析器"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["在需要用户身份信息的方法中加上 ",(0,i.jsx)(n.code,{children:"@TokenToAdminUser"})," 注解，之后通过方法参数解析器来获得当前登录的对象信息。"]}),"\n",(0,i.jsxs)(n.p,{children:["自定义方法参数解析器 ",(0,i.jsx)(n.code,{children:"TokenToAdminUserMethodArgumentResolver"}),"，需实现",(0,i.jsx)(n.code,{children:"HandlerMethodArgumentResolver"})," 类，代码如下："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'package ltd.newbee.mall.config.handler;\n\nimport ltd.newbee.mall.common.Constants;\nimport ltd.newbee.mall.common.NewBeeMallException;\nimport ltd.newbee.mall.common.ServiceResultEnum;\nimport ltd.newbee.mall.config.annotation.TokenToAdminUser;\nimport ltd.newbee.mall.dao.NewBeeAdminUserTokenMapper;\nimport ltd.newbee.mall.entity.AdminUserToken;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.support.WebDataBinderFactory;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.method.support.ModelAndViewContainer;\n\n@Component\npublic class TokenToAdminUserMethodArgumentResolver implements HandlerMethodArgumentResolver {\n\n    @Autowired\n    private NewBeeAdminUserTokenMapper newBeeAdminUserTokenMapper;\n\n    public TokenToAdminUserMethodArgumentResolver() {\n    }\n\n    public boolean supportsParameter(MethodParameter parameter) {\n        if (parameter.hasParameterAnnotation(TokenToAdminUser.class)) {\n            return true;\n        }\n        return false;\n    }\n\n    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) {\n        if (parameter.getParameterAnnotation(TokenToAdminUser.class) instanceof TokenToAdminUser) {\n            String token = webRequest.getHeader("token");\n            if (null != token && !"".equals(token) && token.length() == Constants.TOKEN_LENGTH) {\n                AdminUserToken adminUserToken = newBeeAdminUserTokenMapper.selectByToken(token);\n                if (adminUserToken == null) {\n                    NewBeeMallException.fail(ServiceResultEnum.ADMIN_NOT_LOGIN_ERROR.getResult());\n                } else if (adminUserToken.getExpireTime().getTime() <= System.currentTimeMillis()) {\n                    NewBeeMallException.fail(ServiceResultEnum.ADMIN_TOKEN_EXPIRE_ERROR.getResult());\n                }\n                return adminUserToken;\n            } else {\n                NewBeeMallException.fail(ServiceResultEnum.ADMIN_NOT_LOGIN_ERROR.getResult());\n            }\n        }\n        return null;\n    }\n\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"该方法的执行逻辑如下："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"首先获取请求头中的 token 值，不存在则返回错误信息给前端，存在则继续后续流程。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"通过 token 值来查询 AdminUserToken 对象，是否存在或者是否过期，不存在或者已过期则返回错误信息给前端，正常则继续后续流程。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"配置方法参数解析器"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["最后在 ",(0,i.jsx)(n.code,{children:"WebMvcConfigurer"})," 中配置 ",(0,i.jsx)(n.code,{children:"TokenToAdminUserMethodArgumentResolver"})," 使其生效，代码如下："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"package ltd.newbee.mall.config;\n\nimport ltd.newbee.mall.common.Constants;\nimport ltd.newbee.mall.config.handler.TokenToAdminUserMethodArgumentResolver;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.method.support.HandlerMethodArgumentResolver;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\n\nimport java.util.List;\n\n@Configuration\npublic class NeeBeeMallWebMvcConfigurer implements WebMvcConfigurer {\n\n    @Autowired\n    private TokenToAdminUserMethodArgumentResolver tokenToAdminUserMethodArgumentResolver;\n\n    /**\n     * @param argumentResolvers\n     * @tip @TokenToAdminUser 注解处理方法\n     */\n    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {\n        argumentResolvers.add(tokenToAdminUserMethodArgumentResolver);\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"身份验证测试",children:["身份验证测试",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#身份验证测试",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这样，需要进行登录判断的接口加上 @TokenToAdminUser 注解即可，之后再进行相应的逻辑判断，十三也增加了两个接口进行状态保持的测试，请看下面代码："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@GetMapping(value = "/test1")\n@ApiOperation(value = "测试接口", notes = "方法中含有@TokenToAdminUser注解")\npublic Result<String> test1(@TokenToAdminUser AdminUserToken userToken) {\n  //此接口含有@TokenToAdminUser注解，即需要登陆验证的接口。\n  Result result = null;\n  if (userToken == null) {\n    //如果通过请求header中的token未查询到用户的话即token无效，登陆验证失败，返回未登录错误码。\n    result = ResultGenerator.genErrorResult(419, "未登录！");\n    return result;\n  } else {\n    //登陆验证通过。\n    result = ResultGenerator.genSuccessResult("登陆验证通过");\n  }\n  return result;\n}\n\n@GetMapping(value = "/test2")\n@ApiOperation(value = "测试接口", notes = "方法中无@TokenToAdminUser注解")\npublic Result<String> test2() {\n  //此接口不含@TokenToAdminUser注解，即访问此接口无需登陆验证，此类接口在实际开发中应该很少，为了安全起见应该所有接口都会做登陆验证。\n  Result result = ResultGenerator.genSuccessResult("此接口无需登陆验证，请求成功");\n  //直接返回业务逻辑返回的数据即可。\n  return result;\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"启动项目并访问 Swagger 接口页面，首先测试无需身份验证的接口，可以看到，由于不需要登录验证，接口直接返回了数据。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:x,alt:"image-20210407121303973"})}),"\n",(0,i.jsxs)(n.p,{children:["之后是测试需要身份验证的接口，如下图所示，由于是直接发起请求，并没有在请求头中放入 token 参数，在 ",(0,i.jsx)(n.code,{children:"Curl"})," 那一栏中也可以看到，并没有 token 传输到后端，所以直接返回 419 错误码，提示未登录。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:g,alt:"image-20210407121401229"})}),"\n",(0,i.jsx)(n.p,{children:"因为 token 参数是我们自定义的，如果没有在编码层面做修改，Swagger 肯定不会在页面中生成 token 参数，这里我们需要修改 Swagger 的配置，使得可以在 swagger-ui 页面可以传输 token 参数，Swagger 配置类修改如下："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'package ltd.newbee.mall.config;\n\nimport ltd.newbee.mall.entity.AdminUserToken;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport springfox.documentation.builders.ApiInfoBuilder;\nimport springfox.documentation.builders.ParameterBuilder;\nimport springfox.documentation.builders.PathSelectors;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.schema.ModelRef;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.service.Parameter;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Configuration\n@EnableSwagger2\npublic class Swagger2Config {\n\n    @Bean\n    public Docket api() {\n\n        ParameterBuilder tokenParam = new ParameterBuilder();\n        List<Parameter> swaggerParams = new ArrayList<Parameter>();\n        tokenParam.name("token").description("用户认证信息")\n                .modelRef(new ModelRef("string")).parameterType("header")\n                .required(false).build(); //header中的ticket参数非必填，传空也可以\n        swaggerParams.add(tokenParam.build());    //根据每个方法名也知道当前方法在设置什么参数\n\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .ignoredParameterTypes(AdminUserToken.class)\n                .select()\n                .apis(RequestHandlerSelectors.basePackage("ltd.newbee.mall.api"))// 修改为自己的 controller 包路径\n                .paths(PathSelectors.any())\n                .build()\n                .globalOperationParameters(swaggerParams);\n    }\n\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title("接口文档")\n                .description("swagger接口文档")\n                .version("3.0")\n                .build();\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["使用 ParameterBuilder 来定义 tokenParam，token 是一个字符串，且发送请求时是放在 Request Header 中，所以做了如下配置： ",(0,i.jsx)(n.code,{children:'modelRef(new ModelRef("string")).parameterType("header")'}),"，最后将该参数放入 ",(0,i.jsx)(n.code,{children:"globalOperationParameters"})," 中，这里我们只配置了一个 token 参数，如果有其他全局参数也可以通过这种方式来配置。"]}),"\n",(0,i.jsxs)(n.p,{children:["重启项目并打开 Swagger 页面，可以看到在参数栏已经有 token 参数，且类型为请求头中的 string 字符串。执行登录接口获取一个 token 值并填入 input 框中，可以看到此时的返回码是 200，且 message 为”登录验证通过“，在 ",(0,i.jsx)(n.code,{children:"Curl"})," 那一栏中也可以看到此时的传参中增加了 token 请求头，验证通过。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:"image-20210407121702346"})}),"\n",(0,i.jsx)(n.p,{children:"如果请求中不存在 Token 或者 Token 值是错误的，则验证身份失败，返回错误码 419，而如果填入正确的 Token 值，则返回登录验证成功，这样我们的身份验证编码就完成了。"}),"\n",(0,i.jsxs)(n.h2,{id:"管理员模块接口完善",children:["管理员模块接口完善",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#管理员模块接口完善",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"讲完注册登录和身份认证流程，我们继续来完善管理员模块。"}),"\n",(0,i.jsx)(n.p,{children:"如下图所示，分别是”修改密码“页面和页面右上角的管理员信息展示区域："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:u,alt:"image-20210407163404666"})}),"\n",(0,i.jsx)(n.p,{children:"”管理员信息展示区域“会展示管理员的部分信息，退出登录的按钮也在这里。修改账户页面则是更改管理员信息，这些功能点都需要后端提供接口来进行处理，所以需要增加四个接口："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"获取管理员信息接口"}),"\n",(0,i.jsx)(n.li,{children:"修改密码接口"}),"\n",(0,i.jsx)(n.li,{children:"修改基本信息接口"}),"\n",(0,i.jsx)(n.li,{children:"退出登录接口"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"新增代码如下："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@RequestMapping(value = "/adminUser/profile", method = RequestMethod.GET)\npublic Result profile(@TokenToAdminUser AdminUserToken adminUser) {\n  logger.info("adminUser:{}", adminUser.toString());\n  AdminUser adminUserEntity = adminUserService.getUserDetailById(adminUser.getAdminUserId());\n  if (adminUserEntity != null) {\n    adminUserEntity.setLoginPassword("******");\n    Result result = ResultGenerator.genSuccessResult();\n    result.setData(adminUserEntity);\n    return result;\n  }\n  return ResultGenerator.genFailResult(ServiceResultEnum.DATA_NOT_EXIST.getResult());\n}\n\n@RequestMapping(value = "/adminUser/password", method = RequestMethod.PUT)\npublic Result passwordUpdate(@RequestBody UpdateAdminPasswordParam adminPasswordParam, @TokenToAdminUser AdminUserToken adminUser) {\n  logger.info("adminUser:{}", adminUser.toString());\n  if (StringUtils.isEmpty(adminPasswordParam.getNewPassword()) || StringUtils.isEmpty(adminPasswordParam.getOriginalPassword())) {\n    return ResultGenerator.genFailResult(ServiceResultEnum.PARAM_ERROR.getResult());\n  }\n  if (adminUserService.updatePassword(adminUser.getAdminUserId(), adminPasswordParam.getOriginalPassword(), adminPasswordParam.getNewPassword())) {\n    return ResultGenerator.genSuccessResult();\n  } else {\n    return ResultGenerator.genFailResult(ServiceResultEnum.DB_ERROR.getResult());\n  }\n}\n\n@RequestMapping(value = "/adminUser/name", method = RequestMethod.PUT)\npublic Result nameUpdate(@RequestBody UpdateAdminNameParam adminNameParam, @TokenToAdminUser AdminUserToken adminUser) {\n  logger.info("adminUser:{}", adminUser.toString());\n  if (StringUtils.isEmpty(adminNameParam.getLoginUserName()) || StringUtils.isEmpty(adminNameParam.getNickName())) {\n    return ResultGenerator.genFailResult(ServiceResultEnum.PARAM_ERROR.getResult());\n  }\n  if (adminUserService.updateName(adminUser.getAdminUserId(), adminNameParam.getLoginUserName(), adminNameParam.getNickName())) {\n    return ResultGenerator.genSuccessResult();\n  } else {\n    return ResultGenerator.genFailResult(ServiceResultEnum.DB_ERROR.getResult());\n  }\n}\n\n@RequestMapping(value = "/logout", method = RequestMethod.DELETE)\npublic Result logout(@TokenToAdminUser AdminUserToken adminUser) {\n  logger.info("adminUser:{}", adminUser.toString());\n  adminUserService.logout(adminUser.getAdminUserId());\n  return ResultGenerator.genSuccessResult();\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"由于这四个接口都需要管理员状态下才能正常的请求，所以方法定义时都使用了 @TokenToAdminUser 注解。"}),"\n",(0,i.jsx)(n.p,{children:"接下来是这几个接口的实现逻辑。"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"获取管理员信息接口"})}),"\n",(0,i.jsx)(n.p,{children:"使用 @TokenToAdminUser 注解 已经得到了当前登录管理员的 Token 信息对象 AdminUserToken，根据管理员 id 查询完整的管理员数据，处理完数据并返回管理员信息给前端。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"修改管理员信息接口"})}),"\n",(0,i.jsx)(n.p,{children:"分别定义了 UpdateAdminNameParam 对象、UpdateAdminPasswordParam 来接收管理员修改的信息字段，需要修改的字段主要有昵称、密码，并使用 @RequestBody 注解来接收，之后调用业务层的 updatePassword() 方法、updateName()  方法来进行入库操作，将这些字段修改掉。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"退出登录接口"})}),"\n",(0,i.jsx)(n.p,{children:"这个接口的逻辑比较简单，只需要将该管理员在 token 表中的记录删除掉即可，也就是将当前的 token 值设置为无效的，既然退出登录了肯定不能让当前的 token 值可以继续进行身份验证。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"管理员模块接口测试",children:["管理员模块接口测试",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#管理员模块接口测试",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"最后，我们通过 Swagger 页面来测试一下这些接口。"}),"\n",(0,i.jsx)(n.p,{children:"重启项目，打开 swagger-ui 页面："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:p,alt:"image-20210407171554536"})}),"\n",(0,i.jsxs)(n.h4,{id:"登录",children:["登录",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#登录",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"首先我们访问登录接口，拿到一个可以正常进行身份认证的 token 字符串，如下图所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:m,alt:"image-20210407170852871"})}),"\n",(0,i.jsx)(n.p,{children:"最终获取到一个 token 字符串，值为“ce01a7e885e55a38fdfd09c902c551a3”。"}),"\n",(0,i.jsx)(n.p,{children:"由于在 Swagger 配置中，将 token 设置成全局的 header 参数，所以每个请求上都会有 token 参数，不过不填写也依然可以正常调用，有些接口不需要身份认证的。"}),"\n",(0,i.jsxs)(n.h4,{id:"获取管理员信息",children:["获取管理员信息",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#获取管理员信息",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"点开“管理员信息接口”，在 token 输入框中填入登录接口返回的 token 值，之后点击”Execute“按钮，即可得到管理员信息数据，如下图所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"image-20210407170956070"})}),"\n",(0,i.jsx)(n.p,{children:"后端需要处理的内容就是这些，根据前端传入的参数返回相应的结果，至于前端怎么处理这些数据、怎么显示，都是前端开发人员所考虑的，我们后端保证接口参数和响应结果正常即可。"}),"\n",(0,i.jsxs)(n.h4,{id:"修改管理员信息",children:["修改管理员信息",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#修改管理员信息",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这里以修改管理员昵称为测试案例，在 token 输入框中填入登录接口返回的 token 值，并且将需要修改的字段内容放入请求体 body 中，如下图所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"image-20210407171137773"})}),"\n",(0,i.jsx)(n.p,{children:"之后点击”Execute“按钮，即可完成修改操作，如下图所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"image-20210407171200754"})}),"\n",(0,i.jsx)(n.p,{children:"此时后端响应结果为修改成功，我们再次请求guan管理员信息接口，得到了如下结果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:"image-20210407171231271"})}),"\n",(0,i.jsx)(n.p,{children:"昵称、介绍字段都已经是修改后的内容了，修改接口测试成功。"}),"\n",(0,i.jsxs)(n.h4,{id:"退出登录",children:["退出登录",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#退出登录",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"点开“退出登录接口”，在 token 输入框中填入登录接口返回的 token 值，之后点击”Execute“按钮，即可完成修改操作，如下图所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:"image-20210407171712951"})}),"\n",(0,i.jsx)(n.p,{children:"后端返回的是接口处理成功的响应，此时我们再用这个 token 进行接口请求，会得到如下结果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:s,alt:"image-20210407171748685"})}),"\n",(0,i.jsx)(n.p,{children:"因为执行了退出登录的逻辑，将 token 信息删除，所以原来的 token 已经失效了，再次使用失效的 token 值来进行接口请求，后端响应的肯定是”管理员未登录！“。"}),"\n",(0,i.jsx)(n.p,{children:"接口测试完成。"})]})}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(k,{...e})}):k(e)}let f=b;b.__RSPRESS_PAGE_META={},b.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F24.API%20%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E4%B9%8B%E7%94%A8%E6%88%B7%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E8%AF%A6%E8%A7%A3.md"]={toc:[{text:"身份认证",id:"身份认证",depth:2},{text:"前端存储和使用 token",id:"前端存储和使用-token",depth:4},{text:"后端处理 token 及身份验证",id:"后端处理-token-及身份验证",depth:4},{text:"身份验证测试",id:"身份验证测试",depth:2},{text:"管理员模块接口完善",id:"管理员模块接口完善",depth:2},{text:"管理员模块接口测试",id:"管理员模块接口测试",depth:2},{text:"登录",id:"登录",depth:4},{text:"获取管理员信息",id:"获取管理员信息",depth:4},{text:"修改管理员信息",id:"修改管理员信息",depth:4},{text:"退出登录",id:"退出登录",depth:4}],title:"24.API 接口开发实战之用户身份认证详解",headingTitle:"24.API 接口开发实战之用户身份认证详解",frontmatter:{}}}}]);