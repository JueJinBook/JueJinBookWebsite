"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["42181"],{564934:function(e,n,r){r.r(n),r.d(n,{default:()=>J});var s=r(552676),t=r(740453);let c=r.p+"static/image/89c9a794bf57e582669ee22c78af057d.22f67529.webp",i=r.p+"static/image/709d8e007b0772660e81271c40c0fb63.d1521e5c.webp",a=r.p+"static/image/2faab3ad5022910946d7a738f71ae81b.5633624a.webp",d=r.p+"static/image/05b33d213a1265a9819767d9cb3fe619.4e8307e1.webp",l=r.p+"static/image/a164beac5a566c18f83a092cce736ca0.465ca7e8.webp",p=r.p+"static/image/d13bb8425bf6a11737c10f365c393c33.a287257b.webp",o=r.p+"static/image/266209e9aebdc897b2deaf7a8a7235d2.599f20b7.webp",j=r.p+"static/image/e8c607047156d76e084ba18e9211bf6a.fdc001e0.webp",h=r.p+"static/image/0e448a9279be54ccf49565ef38ead222.2dac36d4.webp",x=r.p+"static/image/c6c8e6b8e2d2e4c9ee8a903a14f3efa1.0ff9a36a.webp",m=r.p+"static/image/435bbdfef314a89dd5a9393783e49304.b7b77bcb.webp",b=r.p+"static/image/c5d8f4c35ee5aea5248602ad548f440e.4b818413.webp",g=r.p+"static/image/483691b1ea6e81555d8e75319e10ba6c.6a4224c6.webp",f=r.p+"static/image/4b12ec355749df2c13c5a7b14d2cce3c.439cf722.webp",y=r.p+"static/image/69f97e0895b2d6b63de53caa559b0ff0.485eaef0.webp",u=r.p+"static/image/6653714e2d4f667662d5e92def79f9f3.c100618b.webp",E=r.p+"static/image/46a23f4d29e75fc63fca8c64454e89c1.e1263553.webp",z=r.p+"static/image/b37f711a7a3c297deac9fd4253e8c0ae.80cec40c.webp",A=r.p+"static/image/1f9cfed65f33a497d55ba67bfd336896.bfa65dbd.webp",R=r.p+"static/image/54341a36c0fe09b76adb3ed3a9f38d11.f168ec01.webp",v=r.p+"static/image/91c896fcdc8210f3ed50f4628aff02e2.efce4f5d.webp",w=r.p+"static/image/b3a64c37d5e3eeb374c315dfc9cdf3af.2ebf3b06.webp",k=r.p+"static/image/89f672a92bd52dff90156ee4b07a66a3.bb5e4856.webp";function T(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",strong:"strong",h2:"h2",h3:"h3",pre:"pre",code:"code",img:"img",ul:"ul",li:"li"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"2技术选型react-testing-library-or-enzyme",children:["2.技术选型：React Testing Library Or Enzyme？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2技术选型react-testing-library-or-enzyme",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["代码仓库(后续学习都在这个仓库，CRA创建）：",(0,s.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n",(0,s.jsxs)(n.p,{children:["配置示例仓库：",(0,s.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo_for_config",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo_for_config"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"上一节，我们站在研发的角度大体分析了怎么写前端的自动化测试，不可否认的是，在特定的场景下，合适的自动化测试对项目的维稳和日后的迭代都有深远的意义。"}),"\n",(0,s.jsx)(n.p,{children:"通常，根据自动化测试的维度，可以分为单元测试和端对端测试。单元测试是更细粒度的、从代码组件层次进行的功能测试，而端对端测试是从用户视角，从项目整体展开的测试。从这节课开始，我们先学习单元测试。"}),"\n",(0,s.jsxs)(n.p,{children:["针对单元测试，JavaScript 技术栈通常会选用 Jest 作为基础测试框架，它是 Facebook 开发的 JavaScript 测试框架，用于创建、运行和编写测试的 JavaScript 库。但是，",(0,s.jsx)(n.strong,{children:"仅通过 Jest"})," ",(0,s.jsx)(n.strong,{children:"，"})," ",(0,s.jsx)(n.strong,{children:"没办法完成前端的所有单元测试"}),"，因为与常规的接口逻辑测试不同，前端的单元测试涉及到 Dom 和事件的模拟，我们还需要选用一个辅助库来协助我们模拟相关的场景。"]}),"\n",(0,s.jsx)(n.p,{children:"有两个主流的辅助库选择，Enzyme 和 React Testing Library，这两个库都是非常优秀的辅助库，它们都提供了测试应用程序所需的所有工具，都能够满足我们的单测需求，但从配置以及测试思路的角度上看，我更推荐大家使用 React Testing Library，下面我们将具体说明。"}),"\n",(0,s.jsxs)(n.h2,{id:"配置",children:["配置",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"jest",children:["Jest",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#jest",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"配置可参考配置示例仓库 test_demo_for_config master 分支。"}),"\n",(0,s.jsx)(n.p,{children:"Node 版本 14 +"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Jest 是基础的测试库，是安装 Enzyme 和 React Testing Library 的前置条件，在 create-react-app 脚手架中，会一并自动打包进来，我们这里以非 CRA 场景的例子，来示范一下怎么进行 Jest 的配置。仓库可以使用尤大的 @vitejs/app 来帮助我们初始化一个空白的项目（只是便于创建一个空项目，后续流程与 Vite 无关，Webpack 同样适用）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:" npm init vite test_demo\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"配置上我们选择 React + TS 就可，然后我们打开项目看看，可以看到，一个没有单测能力的项目创建好了, 我们可以打开项目看看。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"首先我们来安装一下 Jest 相关的依赖。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save-dev jest @types/jest @jest/types\n"})}),"\n",(0,s.jsx)(n.p,{children:"安装好了以后，我们初始化一下 Jest 的 配置。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx jest --init\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以参照下面进行选择。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这里简单解释一下我们为什么这么选："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"前两个配置选项是字面意思，不赘述了。"}),"\n",(0,s.jsx)(n.li,{children:"单测环境（jsdom)：因为我们会涉及到 dom 的单测，不仅仅是纯逻辑，如果是纯逻辑的选 node。"}),"\n",(0,s.jsx)(n.li,{children:"是否需要覆盖率报告（no)：暂时用不上，后面覆盖率章节会着重介绍。"}),"\n",(0,s.jsx)(n.li,{children:"编译代码（babel)： 可以转 ES5，避免一些兼容性问题。"}),"\n",(0,s.jsx)(n.li,{children:"每次测试完是否清理 mock、实例等结果（yes): 每次测试完成后会清理 mock 等上次测试的结果，可以避免用例之间的互相影响"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["到这里我们 Jest 的基本配置就已经完成了，可以看到根目录已经生成了对应的 jest.config.ts 文件，大家也可以根据自己的需要增加额外的自定义配置，具体可以参考",(0,s.jsx)(n.a,{href:"https://jestjs.io/docs/configuration",target:"_blank",rel:"noopener noreferrer",children:" Configuring"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"因为我们选用了 babel 作为单测的编译，所以这边还需要增加一下对应的配置。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save-dev babel-jest @babel/core @babel/preset-env @babel/preset-react @babel/preset-typescript\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这边除 babel 基础的配置集（presets)，我们还安装了 React 和 TypeScript 的配置集，来帮助我们的单测可以支持使用 ts 来书写，安装完成后，我们在根目录创建一个 babel.config.js 文件用于 babel 的配置，其中@babel/preset-react ，我们为它加上 ",(0,s.jsx)(n.code,{children:'runtime: "automatic"'}),"的配置，这是为了帮助我们可以自动导入 React，不然后续单测的开发会要求对 React 进行 import。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// ./babel.config.js\nmodule.exports = {\n  presets: [\n    ["@babel/preset-env", { targets: { node: "current" } }],\n    ["@babel/preset-react",{ runtime: "automatic" }], // 自动导入react\n    "@babel/preset-typescript",\n  ],\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这时候我们新增一个单测实验一下，执行一下",(0,s.jsx)(n.code,{children:"npm run test"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// App.test.ts\nimport React from "react";\n\ntest("test", () => {\n  expect(1 + 1).toBe(2);\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"这时候发现会有 ts-node 需要安装的报错提醒。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们先来看一下 jest-config 的依赖配置，因为配置文件是 ts，所以需要依赖 ts-node 进行编译，如果子依赖中没直接包含的话，的确会有这样的问题。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:z,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"的确和我们想的一样，那我们自己安装一下 ts-node 就好了。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install ts-node --save-dev\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们再试试看，可能会遇到下面的报错。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"和之前的原因类似，jest-environment-jsdom 也不会作为子依赖自动安装，我们自己安装一下就好。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install jest-environment-jsdom --save-dev\n"})}),"\n",(0,s.jsx)(n.p,{children:"再试试看，发现还有一个问题。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["这个是因为尤大的 vitejs 脚手架中，在 package.json 中设置了 ",(0,s.jsx)(n.code,{children:"type: module"}),"，这将指明这个包是采用何种方式进行导入的，针对",(0,s.jsx)(n.code,{children:"type: module"}),"，babel.config 的后缀类型应该使用 cjs，改成如下图。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,UklGRkADAABXRUJQVlA4IDQDAACwEQCdASrSABsAPp1CnEklpCMhMBN6SLATiUAZRDjvscBTbP893pqvRf+rnfgEWoZAu6RMGSn7xzUC7k6wNHb+oHsW53HqD0awV7Wle9E+zIkVJRKNuqgg2LBTPTHqocElJADbBEp0ChBiu4x/5uTnNmgQU8mX4cTID8mZ5ALI666NAVXoPR3HwfGt8prd1bRvjkbU1kAA/n7h6bwv/bN/Ms+CnV43v+W5NhBZl7IEn6tfIRpFhC22uj975b3RgJFs32PfZYgacr0Ow9yrV2XZATnDdSQ+NgxFSKzhv2amy+GE0mrCxv/J83a/44mBEztXDKH+xl/Y7xuJbUwC0anIZjmetT61tGPvIAK/h3FQwtTjLyCqhhf15ZKsZfynix3z3QM6uyD3ENE9pWiXHn9WFgWAqBlos46sz8yvdOS75N8//Q3Bk8PGLA9uRX1f0ovQTUPn+B85DCQJ8/dgfROoaTTfCLvybYmc/byotfoGnyp06Q+y7ArTpvNgV3qQSvl5d2LwzsBL00sNCR/A4p9wBy52IvuMiIz9lhqopePVQzempgwKMQegHqmYtwRbjdPFeN4cvvfO0W76OcgPSQK9K70xOXx2Czn7oJZpacvqTACOP1Ncu8+dzRtZxcGH0a8G3rESNDS2DebUtuxDEDjVd43AE9r85lfP9rB11lvVAHivZ2T7zg8DPJielW6Fl/b19Mvgk4SCmCFE+kPid3sfZhzRLbgFGUmQYzPtWHuk79AzhWHmjZB27uV61EUxHM0J904MBp3LNNNXB6Kr4ZdALyJAbAun9JWVza6ikKoKkGrb38NBcB6Cn5++4sGXIaTGnO8751uRjiF3W9lkVF95Rg2sB0ghb8MTzgqa2PKu/NjaelAm4YDoV1P0Nuco0K7rtL1IOmt2u5mofnCaCFGzA5qoE64w7ZXX8cbjeA1uQqZUviF23dVEjUs5QLGC+OaIRGMH1qR6RVLhoR/FPsVpFGs9+o7dQCo1HK3wLazXuOvNizvK8hlBmkDrXfyrmKfspZqwSmhnQ/GfhFD6LEZBfY7dzspcZbAgAfucnwP687CWG2K7QtrXf+xQV0OD+eGhegAA",alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["如果没有这项的同学应该是正常的，就可以忽略了，如果大家这时候尝试一下 ",(0,s.jsx)(n.code,{children:"npm run test"}),"，会发现应该已经可以了，这些是基于 babel 的配置，",(0,s.jsx)(n.a,{href:"https://jestjs.io/zh-Hans/docs/getting-started",target:"_blank",rel:"noopener noreferrer",children:"Jest 官网"}),"也提供了 ts-jest 的配置方案，大家可以下来试试看。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"到这里，Jest 的基础配置就已经完成了，但是还有一些特殊情况，我们需要额外进行一些配置。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"额外的扩展名识别：因为Jest 不使用 Webpack 等打包工具，因此它不知道如何加载除 js/jsx 之外的其他文件扩展名，所以我们需要为它加一个转换器。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// jest.config.ts\nexport default {\n  // ... other config\n  transform: {\n    // ...\n    "^.+\\.(js|ts|tsx)$": "<rootDir>/node_modules/babel-jest",\n  },\n};\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Svg mock 转换：我们项目中可能会有用到 svg 等图片，这个对于 Jest 同样也是无法识别的，我们需要对它进行 mock，返回相同的输出结果。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// jest.config.ts\nexport default {\n  // ... other config\n  transform: {\n    // ...\n    "^.+\\.svg$": "<rootDir>/svg-transform.js",\n  },\n};\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// ./svg-transform.js\nexport default {\n  process() {\n    return { code: "module.exports = {};" };\n  },\n  getCacheKey() {\n    return "svgTransform"; // SVG固定返回这个字符串\n  },\n};\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CSS 代理：Jest 本身不知道如何处理不同扩展的文件，我们可以通过配置代理的方式，告诉 Jest 将此对象模拟为导入的 CSS 模块。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save-dev identity-obj-proxy\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// jest.config.ts\nexport default {\n  // ... other config\n  moduleNameMapper: {\n    "\\.(css|less)$": "identity-obj-proxy" // 有使用 sass 需求的同学可以把正则换成 ^\\.(css|less|sass|scss)$\n  }\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["大家做到这一步，可以",(0,s.jsx)(n.code,{children:"git init"}),"一下，提交一个 commit 进行保存，下面我们将来配置辅助库。 因为 Jest 的配置都是相同的，后续大家在配置辅助库时，stash 一下之前的配置就可以重新开始了，会方便清晰很多。"]}),"\n",(0,s.jsxs)(n.h3,{id:"react-testing-library",children:["React Testing Library",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-testing-library",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"配置可参考配置示例仓库 test_demo_for_config feat/react_testing_library 分支。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们来配置 React Testing Library，我们先来安装一下依赖，这几个库我们会在后面的课程中着重学习："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"@testing-library/jest-dom：用于 dom、样式类型等元素的选取。"}),"\n",(0,s.jsx)(n.li,{children:"@testing-library/react：提供针对 React 的单测渲染能力。"}),"\n",(0,s.jsx)(n.li,{children:"@testing-library/user-event：用于单测场景下事件的模拟。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install @testing-library/jest-dom @testing-library/react @testing-library/user-event --save-dev\n"})}),"\n",(0,s.jsx)(n.p,{children:"针对 @testing-library/jest-dom 我们全局导入一下，使得 expect 可以适配 React testing library 提供的相关断言，我们在根目录创建一个 jest-dom-setup.js (名字可自取)，用于全局导入 @testing-library/jest-dom。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"//  jest_dom_setup.js\nimport '@testing-library/jest-dom'\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后我们将这个文件配置到 jest.config.ts 的 setupFilesAfterEnv 属性中，这个字段的作用是，将指定的配置文件，在安装测试框架之后，执行测试代码本身之前运行，这样我们就不需要每个单测文件都单独导入一次 @testing-library/jest-dom 了。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// jest.config.ts\nexport default {\n  // ... other config\n  setupFilesAfterEnv: ["<rootDir>/jest-dom-setup.js"],\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"到这里 React Testing Library 的配置就已经完成了，我们可以修改我们的单测来试验一下效果，可以看到已经可以了。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// ./src/App.test.tsx\n// 这里文件后缀修改为 tsx，因为需要测试 dom\nimport { render, screen } from "@testing-library/react";\nimport "@testing-library/jest-dom";\nimport App from "./App";\n\ndescribe("test", () => {\n  test("first unit test", () => {\n    render(<App />);\n    expect(screen.getByText("Vite + React")).toBeInTheDocument();\n  });\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果大家是使用 create-react-app 创建一个新项目的话，React Testing Library 的配置相比手工配置会方便很多，脚手架帮我们完成了 Jest 到 React Testing Library 所有的配置，我们打开终端执行下面的命令。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm i create-react-app -g \nnpx create-react-app test_demo --template typescript\n"})}),"\n",(0,s.jsx)(n.p,{children:"执行完成后，会在对应目录下生成如下的项目结构。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["其中包含",(0,s.jsx)(n.code,{children:"test"}),"即为单测的文件，我们先来看下 package.json。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到我们上面自己手动配置的依赖都有安装，比较奇怪的是，Jest 去哪里了，我们知道 React Testing Library 只是辅助库，单测基础库还是要使用到 Jest 的，我们到 package.json 中搜一下 ",(0,s.jsx)(n.code,{children:'"jest"'})," 看看。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到 create-react-app 将 Jest 作为 react-scripts 这个依赖的子依赖单独打包进来了。现在我们来看看脚手架自动生成的单测，这个单测的效果是测试 App 组件下是否包含 learn react 的文案。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// ./src/App.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们可以尝试执行 script 中的 test 命令看下效果，可以看到用例通过的信息， create-react-app 其实还是很方便的，不需要我们再配置啥，可以很方便地开始单测地学习，后面的课程我们也会基于这个项目进一步展开。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"enzyme",children:["Enzyme",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#enzyme",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"配置可参考配置示例仓库 test_demo_for_config feat/enzyme 分支。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"现在我们来配置 Enzyme， 首先我们来安装一下依赖，对于 Enzyme 我们需要安装三个依赖："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"enzyme：基础库。"}),"\n",(0,s.jsx)(n.li,{children:"enzyme-adapter-react：对 React 的适配器，需要安装对应 React 版本的适配器。"}),"\n",(0,s.jsx)(n.li,{children:"jest-enzyme：用于 enzyme 对 Jest 的环境适配。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Enzyme 的使用是依赖于适配器（enzyme-adapter-react）的，大家如果到 npm 等",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/search?q=enzyme-adapter-react-17",target:"_blank",rel:"noopener noreferrer",children:"包管理平台"}),"去搜索，会发现 Enzyme 适配的速度其实是要远慢于 React 的迭代速度的，从 React 17 开始，提供的适配器就已经是开发者自行实现的了，这是 Enzyme目前最大的问题。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"这种稳定性可能没有办法得到有效的保证，对于新项目如果想体验 React 高版本所提供的一些优化（例如流式渲染），可能会遇到一些因没有完全适配而导致的问题"}),"，并且更糟糕的是，目前 Enzyme 只剩一名开发者 ",(0,s.jsx)(n.a,{href:"https://twitter.com/ljharb",target:"_blank",rel:"noopener noreferrer",children:"Jordan Harband"}),"来提供基础的维护，对于一些 issue 的解决可能没办法那么及时。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["因为 vitejs 脚手架初始的项目用的是 React 18，所以我们到包管理里搜一下",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@cfaester/enzyme-adapter-react-18",target:"_blank",rel:"noopener noreferrer",children:" star 最多的项目"})," 进行下载，可以看到 readme 里作者也直接说了这不是官方的，可能会有一些问题 =。="]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们现在来安装一下依赖。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install enzyme @types/enzyme jest-enzyme @cfaester/enzyme-adapter-react-18 --save-dev\n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们来创建 Enzyme 的实例，并通过 Jest 的 setupFiles 进行安装时的全局注入。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// ./enzyme_setup.ts\nimport Adapter from "@cfaester/enzyme-adapter-react-18";\nimport Enzyme from "enzyme";\n\nEnzyme.configure({ adapter: new Adapter() });\n\nexport default Enzyme;\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// ./jest.config.ts\nexport default {\n  // ... other config\n  setupFiles: ["<rootDir>/enzyme_setup.ts"],\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"Jest 环境适配的依赖，我们也需要同样配置到 config 中，把对应的入口文件导入就行。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// ./jest.config.ts\nexport default {\n  // ... other config\n  setupFilesAfterEnv: ["<rootDir>/node_modules/jest-enzyme/lib/index.js"],\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"到这里 Enzyme 的配置就完成了，我们写一条单测来试试。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'// ./App.test.tsx\nimport { mount } from "enzyme";\nimport App from "./App";\n\ndescribe("test", () => {\n  it("first unit test", () => {\n    const app = mount(<App />);\n    expect(app.find(".read-the-docs").getDOMNode().textContent).toEqual(\n      "Click on the Vite and React logos to learn more"\n    );\n  });\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"看错误栈可以看到，这个非官方的 React 18 适配器报错了，看样子是没有导入对应的全局依赖，我们切到对应的错误栈，帮它加一下试试。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们再试试看，看看有没有别的问题。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个是因为从 React 15.5.0 开始，PropTypes 已作为单独的依赖项从核心 React 包中删除，依赖包本身并没有去安装这个依赖，我们替它装一下。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save-dev prop-types\n"})}),"\n",(0,s.jsx)(n.p,{children:"再试试看，发现已经可以了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果大家要使用 18 版本的话，我建议 fork 这个依赖的仓库，然后按照我们上述进行微调后发包使用，或者给这个仓库提一个 mr 修复一下上述的问题都可。"}),"\n",(0,s.jsxs)(n.p,{children:["如果是 React 17 版本应该就不会遇到上面的问题了，换用这个 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@wojtekmaj/enzyme-adapter-react-17",target:"_blank",rel:"noopener noreferrer",children:"@wojtekmaj/enzyme-adapter-react-17"})," 适配器即可，目前还没有发现什么问题，至于到 React16 版本及以前，就都是官方提供的适配器了，稳定性有保障，可以放心使用。"]}),"\n",(0,s.jsxs)(n.h2,{id:"测试思路",children:["测试思路",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试思路",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"不得不说我在进行小册技术选型的时候纠结了很久，因为历史原因，包括 Semi 在内的使用的其实都是 Enzyme，不可否认它是一个很优秀的辅助库，对于项目性能的维稳和日后迭代都提供了很大的助力和信心，如果说官方适配器没办法跟上 React 版本，非官方适配器稳定性又没有保障是导火索，那么测试思路就是使我最后决定的那根稻草。"}),"\n",(0,s.jsx)(n.p,{children:"Enzyme 允许访问组件的内部工作原理。我们可以读取和设置状态，并且可以模拟子项，以使测试运行得更快。所以Enzyme 的单元测试是基于 component 的 props 展开的，是从代码逻辑的层面验证组件，例如下面的例子。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"it('input with custom className & style', () => {\n    const wrapper = shallow(<Input className='test' style={{color: 'red'}}/>);\n    expect(wrapper.exists('.test')).toEqual(true);\n    expect(wrapper.find('div.test')).toHaveStyle('color', 'red');\n });\n"})}),"\n",(0,s.jsx)(n.p,{children:"而 React Testing Library 采取完全不同的单测思路，它并不在意组件实现的细节，它的测试将基于组件能力本身，从用户视角去进行测试，例如脚手架生成的单测例子。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"test('renders learn react link', () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"就我看来，这两种方案其实各有优劣，Enzyme 所推崇的单测思路虽然在编写上会更麻烦，但是可以有效帮助开发审视自己的类名、结构等封装是否合理，尤其如果作为多业务线复用的组件，这个效果会更加明显，因为作为通用组件，类名等设计的是否合理，会决定到这个组件的复用程度（比如复用过程中 global 样式是否容易编写）。"}),"\n",(0,s.jsxs)(n.p,{children:["但是从业务项目长久维护上看，Enzyme 的单测其实是一种",(0,s.jsx)(n.strong,{children:"脆弱且不可靠的单测"}),"，我们知道在业务代码中，产品需求可能是会频繁变动的，有些需求 pm 当时拍脑袋决定后，可能过段时间发现并不合理，进行调整或者推倒重来，这种情况是很常见的。"]}),"\n",(0,s.jsx)(n.p,{children:"针对这种情况，从业务角度上，更需要关注的其实是历史功能是否可以得到完整保留，而不是组件本身的逻辑保持不变，对于业务项目，Enzyme 的单测注定会需要随需求频繁变动，这些时间成本其实都是研发人员难以接受的，我们更需要一个稳定可靠不经常变动的单测来协助我们。所以出于这方面的考虑，这本小册将使用 React Testing Library 来给大家展开单元测试的学习。"}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这节课是我们单元测试章节的启蒙课，在这节课，我们了解到，",(0,s.jsx)(n.strong,{children:"单元测试是从组件层面更细粒度展开的测试"}),"，我们通常使用 Jest 作为我们展开单元测试的基础测试库，Jest 的配置相对还是比较繁琐的，大家可以参考下面的思维导图再整理一下思路。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"因为前端需要模拟浏览器 DOM、事件的原因，所以我们还需要使用一个辅助库来协助我们进行浏览器环境的模拟。主流的库有 Enzyme 和 React Testing Library ，虽然它们都是优秀的单测辅助库，但是它们的思路不尽相同。"}),"\n",(0,s.jsx)(n.p,{children:"Enzyme 提供的能力让我们从组件逻辑细节来展开单测，对于需求频繁变动的场景，这是一种脆弱的单测，可能会需要开发人员频繁修改单元测试。而React Testing Library 并不在意组件实现的细节，是从组件能力本身去展开测试，这样对于代码组件层面的重构和优化，只要最后功能相同，单测将都可以复用，更适合业务场景。"}),"\n",(0,s.jsx)(n.p,{children:"同时考虑到 Enzyme 目前官方适配器更新缓慢，依赖社区非官方适配的原因，所以小册后面的学习，我们将使用 React Testing Library 来进行环境的模拟。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"下一节课，我们将来学习 Jest 的断言，通过它，能够告诉我们的单测程序什么是我们的预期。"})]})}function _(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(T,{...e})}):T(e)}let J=_;_.__RSPRESS_PAGE_META={},_.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F2.%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%9AReact%20Testing%20Library%20Or%20Enzyme%EF%BC%9F.md"]={toc:[{text:"配置",id:"配置",depth:2},{text:"Jest",id:"jest",depth:3},{text:"React Testing Library",id:"react-testing-library",depth:3},{text:"Enzyme",id:"enzyme",depth:3},{text:"测试思路",id:"测试思路",depth:2},{text:"小结",id:"小结",depth:2}],title:"2.技术选型：React Testing Library Or Enzyme？",headingTitle:"2.技术选型：React Testing Library Or Enzyme？",frontmatter:{}}}}]);