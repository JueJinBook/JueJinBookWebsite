"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57399"],{277992:function(e,n,d){d.r(n),d.d(n,{default:()=>j});var c=d(552676),s=d(740453);let i=d.p+"static/image/dd7accf16bdebe1d2b07e5ffb3795bf5.3b4e259a.webp",r=d.p+"static/image/8e8a56e8192527845d42dd33b191b7a1.c23b0d56.webp",l=d.p+"static/image/8af7640a9e44e973c82c43c509bfbf85.efd3aa4e.webp",h=d.p+"static/image/58b38ae8e4a374feb73d361d3777c403.a380420c.webp",o=d.p+"static/image/f0fc7dc177afd72e9ebae947fa503c61.00b698f2.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",ol:"ol",h3:"h3",code:"code",img:"img",pre:"pre",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"3js-基础知识点及常考面试题一",children:["3.JS 基础知识点及常考面试题（一）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3js-基础知识点及常考面试题一",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"JS 对于每位前端开发都是必备技能，在小册中我们也会有多个章节去讲述这部分的知识。首先我们先来熟悉下 JS 的一些常考和容易混乱的基础知识点。"}),"\n",(0,c.jsxs)(n.h2,{id:"更新日志",children:["更新日志",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新日志",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"类型章节新增内容"}),"\n",(0,c.jsx)(n.li,{children:"类型判断章节新增内容"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"类型",children:["类型",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"JS 数据类型分为两大类："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"原始类型"}),"\n",(0,c.jsx)(n.li,{children:"对象类型"}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"原始primitive类型",children:["原始（Primitive）类型",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原始primitive类型",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在 JS 中，存在着 7 种原始值，分别是："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"boolean"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"null"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"undefined"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"number"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"string"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"symbol"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"bigint"})}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["首先原始类型存储的都是值，是没有函数可以调用的，比如 ",(0,c.jsx)(n.code,{children:"undefined.toString()"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["此时你肯定会有疑问，这不对呀，明明 ",(0,c.jsx)(n.code,{children:"'1'.toString()"})," 是可以使用的。其实在这种情况下，",(0,c.jsx)(n.code,{children:"'1'"})," 已经不是原始类型了，而是被强制转换成了 ",(0,c.jsx)(n.code,{children:"String"})," 类型也就是对象类型，所以可以调用 ",(0,c.jsx)(n.code,{children:"toString"})," 函数。"]}),"\n",(0,c.jsx)(n.p,{children:"除了会在必要的情况下强转类型以外，原始类型还有一些坑。"}),"\n",(0,c.jsxs)(n.p,{children:["其中 JS 的 ",(0,c.jsx)(n.code,{children:"number"})," 类型是浮点类型的，在使用中会遇到某些 Bug，比如 ",(0,c.jsx)(n.code,{children:"0.1 + 0.2 !== 0.3"}),"，这块具体原因会在后续章节讲解。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外 ",(0,c.jsx)(n.code,{children:"string"})," 类型的值是不可变的，无论你在 ",(0,c.jsx)(n.code,{children:"string"})," 类型上调用何种方法，都不会对值有改变。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后对于 ",(0,c.jsx)(n.code,{children:"null"})," 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 ",(0,c.jsx)(n.code,{children:"typeof null"})," 会输出 ",(0,c.jsx)(n.code,{children:"object"}),"，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，",(0,c.jsx)(n.code,{children:"000"})," 开头代表是对象，然而 ",(0,c.jsx)(n.code,{children:"null"})," 表示为全零，所以将它错误的判断为 ",(0,c.jsx)(n.code,{children:"object"})," 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。"]}),"\n",(0,c.jsxs)(n.h3,{id:"对象object类型",children:["对象（Object）类型",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象object类型",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"对象类型和原始类型不同的是，原始类型存储的是值，一般存储在栈上，对象类型存储的是地址（指针），数据存储在堆上，这部分的内容具体会在「闭包」小节讲解。"}),"\n",(0,c.jsx)(n.p,{children:"当创建了一个对象类型的时候，计算机会在堆内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const a = []\n"})}),"\n",(0,c.jsxs)(n.p,{children:["对于常量 ",(0,c.jsx)(n.code,{children:"a"})," 来说，假设内存地址（指针）为 ",(0,c.jsx)(n.code,{children:"#001"}),"，那么在地址 ",(0,c.jsx)(n.code,{children:"#001"})," 的位置存放了值 ",(0,c.jsx)(n.code,{children:"[]"}),"，常量 ",(0,c.jsx)(n.code,{children:"a"})," 存放了地址（指针） ",(0,c.jsx)(n.code,{children:"#001"}),"，再看以下代码："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const a = []\nconst b = a\nb.push(1)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 ",(0,c.jsx)(n.code,{children:"b"})," 存放的地址（指针）也是 ",(0,c.jsx)(n.code,{children:"#001"}),"。因此当我们对任一变量进行数据修改的时候，等同于修改存放在地址（指针） ",(0,c.jsx)(n.code,{children:"#001"})," 上的值，所以就导致了两个变量的值都发生了改变。"]}),"\n",(0,c.jsx)(n.p,{children:"接下来我们来看函数参数是对象的情况："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function test(person) {\n  person.age = 26\n  person = {\n    name: 'yyy',\n    age: 30\n  }\n\n  return person\n}\nconst p1 = {\n  name: 'yck',\n  age: 25\n}\nconst p2 = test(p1)\nconsole.log(p1) // -> ?\nconsole.log(p2) // -> ?\n"})}),"\n",(0,c.jsx)(n.p,{children:"对于以上代码，你是否能正确的写出结果呢？"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"首先，函数传参是传递对象指针的副本"}),"\n",(0,c.jsxs)(n.li,{children:["到函数内部修改参数的属性这步，我相信大家都知道，当前 ",(0,c.jsx)(n.code,{children:"p1"})," 的值也被修改了，也就是说 ",(0,c.jsx)(n.code,{children:"age"})," 从 25 变成了 26"]}),"\n",(0,c.jsxs)(n.li,{children:["但是当我们重新为 ",(0,c.jsx)(n.code,{children:"person"})," 分配了一个对象时就出现了分歧，请看下图"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["所以最后 ",(0,c.jsx)(n.code,{children:"person"})," 拥有了一个新的地址（指针），也就和 ",(0,c.jsx)(n.code,{children:"p1"})," 没有任何关系了，导致了最终两个变量的值是不相同的。"]}),"\n",(0,c.jsxs)(n.h3,{id:"涉及面试题",children:["涉及面试题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#涉及面试题",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"0.1 + 0.2 !== 0.3"})}),"\n",(0,c.jsx)(n.li,{children:"JS 类型有哪些？"}),"\n",(0,c.jsx)(n.li,{children:"大数相加、相乘算法题"}),"\n",(0,c.jsx)(n.li,{children:"修改对象得出结果笔试题"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"类型判断",children:["类型判断",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型判断",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"类型判断有多种方式。"}),"\n",(0,c.jsxs)(n.h2,{id:"typeof",children:["typeof",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#typeof",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"typeof"})," 对于原始类型来说，除了 ",(0,c.jsx)(n.code,{children:"null"})," 都可以显示正确的类型，如果你想判断 ",(0,c.jsx)(n.code,{children:"null"})," 的话可以使用 ",(0,c.jsx)(n.code,{children:"variable === null"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"typeof 1 // 'number'\ntypeof '1' // 'string'\ntypeof undefined // 'undefined'\ntypeof true // 'boolean'\ntypeof Symbol() // 'symbol'\ntypeof 1n // bigint\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"typeof"})," 对于对象来说，除了函数都会显示 ",(0,c.jsx)(n.code,{children:"object"}),"，所以说 ",(0,c.jsx)(n.code,{children:"typeof"})," 并不能准确判断变量到底是什么类型。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"typeof [] // 'object'\ntypeof {} // 'object'\ntypeof console.log // 'function'\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"instanceof",children:["instanceof",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#instanceof",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"instanceof"}),"\xa0通过原型链的方式来判断是否为构建函数的实例，常用于判断具体的对象类型，在后面的章节中我们也会自己去实现一个 ",(0,c.jsx)(n.code,{children:"instanceof"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const Person = function() {}\nconst p1 = new Person()\np1 instanceof Person // true\n\nvar str = 'hello world'\nstr instanceof String // false\n\nvar str1 = new String('hello world')\nstr1 instanceof String // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["对于原始类型来说，你想直接通过 ",(0,c.jsx)(n.code,{children:"instanceof"})," 来判断类型是不行的，但是我们还是有办法实现的。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class PrimitiveString {\n  static [Symbol.hasInstance](x) {\n    return typeof x === 'string'\n  }\n}\nconsole.log('hello world' instanceof PrimitiveString) // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["你可能不知道 ",(0,c.jsx)(n.code,{children:"Symbol.hasInstance"})," 是什么东西，其实就是一个能让我们自定义 ",(0,c.jsx)(n.code,{children:"instanceof"})," 行为的东西，以上代码等同于 ",(0,c.jsx)(n.code,{children:"typeof 'hello world' === 'string'"}),"，所以结果自然是 ",(0,c.jsx)(n.code,{children:"true"})," 了。"]}),"\n",(0,c.jsxs)(n.p,{children:["这其实也侧面反映了一个问题：",(0,c.jsx)(n.code,{children:"instanceof"})," 并不是百分之百可信的。"]}),"\n",(0,c.jsx)(n.p,{children:"另外其实我们还可以直接通过构建函数来判断类型："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// true\n[].constructor === Array\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"objectprototypetostringcall",children:["Object.prototype.toString.call",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectprototypetostringcall",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["前几种方式或多或少都存在一些缺陷，",(0,c.jsx)(n.code,{children:"Object.prototype.toString.call"})," 综合来看是最佳选择，能判断的类型最完整，基本上是开源库选择最多的方式。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.h3,{id:"isxxx-api",children:["isXXX API",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#isxxx-api",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"同时还存在一些判断特定类型的 API，选了两个常见的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,c.jsxs)(n.h3,{id:"常见面试题",children:["常见面试题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见面试题",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"JS 类型如何判断，有哪几种方式可用"}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"instanceof"})," 原理"]}),"\n",(0,c.jsxs)(n.li,{children:["手写 ",(0,c.jsx)(n.code,{children:"instanceof"})]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"类型转换",children:["类型转换",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型转换",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"首先我们要知道，在 JS 中类型转换只有三种情况，分别是："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"转换为布尔值"}),"\n",(0,c.jsx)(n.li,{children:"转换为数字"}),"\n",(0,c.jsx)(n.li,{children:"转换为字符串"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"我们先来看一个类型转换表格，然后再进入正题"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["注意图中有一个错误，Boolean 转字符串这行结果我指的是 true 转字符串的例子，不是说 Boolean、函数、Symblo 转字符串都是 ",(0,c.jsx)(n.code,{children:"true"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsxs)(n.h3,{id:"转boolean",children:["转Boolean",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#转boolean",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在条件判断时，除了 ",(0,c.jsx)(n.code,{children:"undefined"}),"， ",(0,c.jsx)(n.code,{children:"null"}),"， ",(0,c.jsx)(n.code,{children:"false"}),"， ",(0,c.jsx)(n.code,{children:"NaN"}),"， ",(0,c.jsx)(n.code,{children:"''"}),"， ",(0,c.jsx)(n.code,{children:"0"}),"， ",(0,c.jsx)(n.code,{children:"-0"}),"，其他所有值都转为 ",(0,c.jsx)(n.code,{children:"true"}),"，包括所有对象。"]}),"\n",(0,c.jsxs)(n.h3,{id:"对象转原始类型",children:["对象转原始类型",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象转原始类型",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["对象在转换类型的时候，会调用内置的 ",(0,c.jsx)(n.code,{children:"[[ToPrimitive]]"})," 函数，对于该函数来说，算法逻辑一般来说如下："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"如果已经是原始类型了，那就不需要转换了"}),"\n",(0,c.jsxs)(n.li,{children:["如果需要转字符串类型就调用 ",(0,c.jsx)(n.code,{children:"x.toString()"}),"，转换为基础类型的话就返回转换的值。不是字符串类型的话就先调用 ",(0,c.jsx)(n.code,{children:"valueOf"}),"，结果不是基础类型的话再调用 ",(0,c.jsx)(n.code,{children:"toString"})]}),"\n",(0,c.jsxs)(n.li,{children:["调用 ",(0,c.jsx)(n.code,{children:"x.valueOf()"}),"，如果转换为基础类型，就返回转换的值"]}),"\n",(0,c.jsx)(n.li,{children:"如果都没有返回原始类型，就会报错"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["当然你也可以重写 ",(0,c.jsx)(n.code,{children:"Symbol.toPrimitive"})," ，该方法在转原始类型时调用优先级最高。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return '1'\n  },\n  [Symbol.toPrimitive]() {\n    return 2\n  }\n}\n1 + a // => 3\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"四则运算符",children:["四则运算符",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四则运算符",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"加法运算符不同于其他几个运算符，它有以下几个特点："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"运算中其中一方为字符串，那么就会把另一方也转换为字符串"}),"\n",(0,c.jsx)(n.li,{children:"如果一方不是字符串或者数字，那么会将它转换为数字或者字符串"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"1 + '1' // '11'\ntrue + true // 2\n4 + [1,2,3] // \"41,2,3\"\n"})}),"\n",(0,c.jsx)(n.p,{children:"如果你对于答案有疑问的话，请看解析："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["对于第一行代码来说，触发特点一，所以将数字 ",(0,c.jsx)(n.code,{children:"1"})," 转换为字符串，得到结果 ",(0,c.jsx)(n.code,{children:"'11'"})]}),"\n",(0,c.jsxs)(n.li,{children:["对于第二行代码来说，触发特点二，所以将 ",(0,c.jsx)(n.code,{children:"true"})," 转为数字 ",(0,c.jsx)(n.code,{children:"1"})]}),"\n",(0,c.jsxs)(n.li,{children:["对于第三行代码来说，触发特点二，所以将数组通过 ",(0,c.jsx)(n.code,{children:"toString"})," 转为字符串 ",(0,c.jsx)(n.code,{children:"1,2,3"}),"，得到结果 ",(0,c.jsx)(n.code,{children:"41,2,3"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["另外对于加法还需要注意这个表达式 ",(0,c.jsx)(n.code,{children:"'a' + + 'b'"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"'a' + + 'b' // -> \"aNaN\"\n"})}),"\n",(0,c.jsxs)(n.p,{children:["因为 ",(0,c.jsx)(n.code,{children:"+ 'b'"})," 等于 ",(0,c.jsx)(n.code,{children:"NaN"}),"，所以结果为 ",(0,c.jsx)(n.code,{children:'"aNaN"'}),"，你可能也会在一些代码中看到过 ",(0,c.jsx)(n.code,{children:"+ '1'"})," 的形式来快速获取 ",(0,c.jsx)(n.code,{children:"number"})," 类型。"]}),"\n",(0,c.jsx)(n.p,{children:"那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"4 * '3' // 12\n4 * [] // 0\n4 * [1, 2] // NaN\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"比较运算符",children:["比较运算符",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#比较运算符",children:"#"})]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["如果是对象，就通过 ",(0,c.jsx)(n.code,{children:"toPrimitive"})," 转换对象"]}),"\n",(0,c.jsxs)(n.li,{children:["如果是字符串，就通过 ",(0,c.jsx)(n.code,{children:"unicode"})," 字符索引来比较"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = {\n  valueOf() {\n    return 0\n  },\n  toString() {\n    return '1'\n  }\n}\na > -1 // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在以上代码中，因为 ",(0,c.jsx)(n.code,{children:"a"})," 是对象，所以会通过 ",(0,c.jsx)(n.code,{children:"valueOf"})," 转换为原始类型再比较值。"]}),"\n",(0,c.jsxs)(n.h3,{id:"常见面试题-1",children:["常见面试题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见面试题-1",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"其实类型转换的题目基本只会出现在笔试题中，比较多变，只能硬背规则。"}),"\n",(0,c.jsxs)(n.h2,{id:"this",children:["this",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#this",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"this"})," 是很多人会混淆的概念，但是其实它一点都不难，只是网上很多文章把简单的东西说复杂了。在这一小节中，你一定会彻底明白 ",(0,c.jsx)(n.code,{children:"this"})," 这个概念的。"]}),"\n",(0,c.jsx)(n.p,{children:"我们先来看几个函数调用的场景"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo\n}\nobj.foo()\n\nconst c = new foo()\n"})}),"\n",(0,c.jsx)(n.p,{children:"接下来我们一个个分析上面几个场景："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["对于直接调用 ",(0,c.jsx)(n.code,{children:"foo"})," 来说，不管 ",(0,c.jsx)(n.code,{children:"foo"})," 函数被放在了什么地方，",(0,c.jsx)(n.code,{children:"this"})," 一定是 ",(0,c.jsx)(n.code,{children:"window"})]}),"\n",(0,c.jsxs)(n.li,{children:["对于 ",(0,c.jsx)(n.code,{children:"obj.foo()"})," 来说，我们只需要记住，谁调用了函数，谁就是 ",(0,c.jsx)(n.code,{children:"this"}),"，所以在这个场景下 ",(0,c.jsx)(n.code,{children:"foo"})," 函数中的 ",(0,c.jsx)(n.code,{children:"this"})," 就是 ",(0,c.jsx)(n.code,{children:"obj"})," 对象"]}),"\n",(0,c.jsxs)(n.li,{children:["对于 ",(0,c.jsx)(n.code,{children:"new"})," 的方式来说，",(0,c.jsx)(n.code,{children:"this"})," 被永远绑定在了 ",(0,c.jsx)(n.code,{children:"c"})," 上面，不会被任何方式改变 ",(0,c.jsx)(n.code,{children:"this"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["以上三种规则基本覆盖大部分情况了，很多代码中的 ",(0,c.jsx)(n.code,{children:"this"})," 应该都能理解指向，下面让我们看看箭头函数中的 ",(0,c.jsx)(n.code,{children:"this"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function a() {\n  return () => {\n    return () => {\n      console.log(this)\n    }\n  }\n}\nconsole.log(a()()())\n"})}),"\n",(0,c.jsxs)(n.p,{children:["首先箭头函数其实是没有 ",(0,c.jsx)(n.code,{children:"this"})," 的，箭头函数中的 ",(0,c.jsx)(n.code,{children:"this"})," 只取决包裹箭头函数的第一个普通函数的 ",(0,c.jsx)(n.code,{children:"this"}),"。在这个例子中，因为包裹箭头函数的第一个普通函数是 ",(0,c.jsx)(n.code,{children:"a"}),"，所以此时的 ",(0,c.jsx)(n.code,{children:"this"})," 是 ",(0,c.jsx)(n.code,{children:"window"}),"。另外对箭头函数使用 ",(0,c.jsx)(n.code,{children:"bind"})," 这类函数是无效的。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后种情况也就是 ",(0,c.jsx)(n.code,{children:"bind"})," 这些改变上下文的 API 了，对于这些函数来说，",(0,c.jsx)(n.code,{children:"this"})," 取决于第一个参数，如果第一个参数为空，那么就是 ",(0,c.jsx)(n.code,{children:"window"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["那么说到 ",(0,c.jsx)(n.code,{children:"bind"}),"，不知道大家是否考虑过，如果对一个函数进行多次 ",(0,c.jsx)(n.code,{children:"bind"}),"，那么上下文会是什么呢？"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = {}\nlet fn = function () { console.log(this) }\nfn.bind().bind(a)() // => ?\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果你认为输出结果是 ",(0,c.jsx)(n.code,{children:"a"}),"，那么你就错了，其实我们可以把上述代码转换成另一种形式："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// fn.bind().bind(a) 等于\nlet fn2 = function fn1() {\n  return function() {\n    return fn.apply()\n  }.apply(a)\n}\nfn2()\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以从上述代码中发现，不管我们给函数 ",(0,c.jsx)(n.code,{children:"bind"})," 几次，",(0,c.jsx)(n.code,{children:"fn"})," 中的 ",(0,c.jsx)(n.code,{children:"this"})," 永远由第一次 ",(0,c.jsx)(n.code,{children:"bind"})," 决定，所以结果永远是 ",(0,c.jsx)(n.code,{children:"window"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = { name: 'yck' }\nfunction foo() {\n  console.log(this.name)\n}\nfoo.bind(a)() // => 'yck'\n"})}),"\n",(0,c.jsxs)(n.p,{children:["以上就是 ",(0,c.jsx)(n.code,{children:"this"})," 的所有规则了。实际中可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 ",(0,c.jsx)(n.code,{children:"this"})," 最终指向哪里。"]}),"\n",(0,c.jsxs)(n.p,{children:["首先，",(0,c.jsx)(n.code,{children:"new"})," 的方式优先级最高，接下来是 ",(0,c.jsx)(n.code,{children:"bind"})," 这些函数，然后是 ",(0,c.jsx)(n.code,{children:"obj.foo()"})," 这种调用方式，最后是 ",(0,c.jsx)(n.code,{children:"foo"})," 这种调用方式，同时，箭头函数的 ",(0,c.jsx)(n.code,{children:"this"})," 一旦被绑定，就不会再被任何方式所改变。"]}),"\n",(0,c.jsx)(n.p,{children:"如果你还是觉得有点绕，那么就看以下的这张流程图吧，图中的流程只针对于单个规则。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.h3,{id:"常见面试题-2",children:["常见面试题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见面试题-2",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这里一般都是考 ",(0,c.jsx)(n.code,{children:"this"})," 的指向问题，牢记上述的几个规则就够用了，比如下面这道题："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const a = {\n  b: 2,\n  foo: function () { console.log(this.b) }\n}\n\nfunction b(foo) {\n  // 输出什么？\n  foo()\n}\n\nb(a.foo)\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"以上就是我们 JS 基础知识点的第一部分内容了。这一小节中涉及到的知识点在我们日常的开发中经常可以看到，并且很多容易出现的坑 也出自于这些知识点，相信认真读完的你一定会在日后的开发中少踩很多坑。如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(x,{...e})}):x(e)}let j=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F3.JS%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89.md"]={toc:[{text:"更新日志",id:"更新日志",depth:2},{text:"类型",id:"类型",depth:2},{text:"原始（Primitive）类型",id:"原始primitive类型",depth:3},{text:"对象（Object）类型",id:"对象object类型",depth:3},{text:"涉及面试题",id:"涉及面试题",depth:3},{text:"类型判断",id:"类型判断",depth:2},{text:"typeof",id:"typeof",depth:2},{text:"instanceof",id:"instanceof",depth:3},{text:"Object.prototype.toString.call",id:"objectprototypetostringcall",depth:3},{text:"isXXX API",id:"isxxx-api",depth:3},{text:"常见面试题",id:"常见面试题",depth:3},{text:"类型转换",id:"类型转换",depth:2},{text:"转Boolean",id:"转boolean",depth:3},{text:"对象转原始类型",id:"对象转原始类型",depth:3},{text:"四则运算符",id:"四则运算符",depth:3},{text:"比较运算符",id:"比较运算符",depth:3},{text:"常见面试题",id:"常见面试题-1",depth:3},{text:"this",id:"this",depth:2},{text:"常见面试题",id:"常见面试题-2",depth:3},{text:"小结",id:"小结",depth:2}],title:"3.JS 基础知识点及常考面试题（一）",headingTitle:"3.JS 基础知识点及常考面试题（一）",frontmatter:{}}}}]);