"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["54129"],{491280:function(n,e,s){s.r(e),s.d(e,{default:()=>h});var c=s(552676),r=s(740453);let l="data:image/webp;base64,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";function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",blockquote:"blockquote",img:"img",br:"br",strong:"strong",h3:"h3",ol:"ol",li:"li",h4:"h4"},(0,r.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"26大厂真题训练与解读腾讯真题",children:["26.大厂真题训练与解读——腾讯真题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#26大厂真题训练与解读腾讯真题",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"本节的命题风格是“大杂烩”：文中涉及到的题目本身并不难，但题目与题目之间的知识点跨度会比较大，目的是考验大家对知识点的熟练度和整合知识点的能力。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-!",children:"注：此处的“命题风格”仅出于笔者个人对课程设计的考虑，并非对腾讯公司命题思路的预测/总结。准备背题目的同学都醒醒。\n"})}),"\n",(0,c.jsxs)(e.h2,{id:"寻找二叉树的最近公共祖先",children:["寻找二叉树的最近公共祖先",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#寻找二叉树的最近公共祖先",children:"#"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目描述： 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”"}),"\n",(0,c.jsx)(e.p,{children:"例如，给定如下二叉树:\xa0 root =\xa0[3,5,1,6,2,0,8,null,null,7,4]"}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["示例 1:",(0,c.jsx)(e.br,{}),"\n","输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",(0,c.jsx)(e.br,{}),"\n","输出: 3",(0,c.jsx)(e.br,{}),"\n","解释: 节点 5 和节点 1 的最近公共祖先是节点 3。"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["示例\xa02:",(0,c.jsx)(e.br,{}),"\n","输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4",(0,c.jsx)(e.br,{}),"\n","输出: 5",(0,c.jsx)(e.br,{}),"\n","解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"命题关键字：二叉树、递归"})}),"\n",(0,c.jsxs)(e.h3,{id:"思路分析",children:["思路分析",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["这道题非常经典。很多人（包括我）第一次读完题目的时候，脑子里都是一片空白——确实，这道题的题干并不能够给我们提供什么有效的启发性信息。不过不要慌，当题干都是屁话时，我们不妨试试从“示例”中寻找答案：",(0,c.jsx)(e.br,{}),"\n",(0,c.jsx)("img",{src:l,alt:""})]}),"\n",(0,c.jsx)(e.p,{children:"题干中一直在强调“祖先结点”、“树的深度”等概念，这可能会误导一部分同学情不自禁地代入“爹找儿子”这种思维模式，然后陷入僵局。如果你不幸中招，别忘了："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-!",children:"虽然编码的时候我们实现的确实是“爹找儿子”，但是在规则摸索阶段，“儿子找爹”这种思维模式会更加人性化。\n"})}),"\n",(0,c.jsxs)(e.p,{children:["不管是爹找儿子，还是儿子找爹，我们都必须首先明确儿子和爹之间的关系有哪些，从而尝试去将不同的关系和“公共祖先”这个概念建立关联。这些信息，我们都可以从题目的示例中挖掘出来。",(0,c.jsx)(e.br,{}),"\n","现在我按照“儿子向爹汇报”这个思路，一层层往上溯源，尝试枚举不同的父子关系形式。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-!",children:"注：下文所提及的“有效汇报”指的就是“爸爸我这里有p或者q”这样式儿的汇报哈\n"})}),"\n",(0,c.jsxs)(e.p,{children:["假如说我要寻找的是 ",(0,c.jsx)(e.code,{children:"6"}),"和",(0,c.jsx)(e.code,{children:"2"}),"的最近公共祖先，那么这中间出现的儿子和爹之间的关系就有以下几种："]}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["对于 ",(0,c.jsx)(e.code,{children:"5"})," 这个结点来说，它的左边和右边各有一个目标儿子给他作有效汇报，",(0,c.jsx)(e.code,{children:"5"}),"也确实就是这俩目标儿子的最近公共祖先。"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["对于 ",(0,c.jsx)(e.code,{children:"3"})," 这个结点来说，由于 ",(0,c.jsx)(e.code,{children:"6"}),"和",(0,c.jsx)(e.code,{children:"2"}),"只存在于它的左孩子上，所以它得到的有效汇报只有1个。同时",(0,c.jsx)(e.code,{children:"3"}),"本身又并不等同于 ",(0,c.jsx)(e.code,{children:"6"})," 或者",(0,c.jsx)(e.code,{children:"2"}),"，因此",(0,c.jsx)(e.code,{children:"3"}),"不是最近公共祖先。",(0,c.jsx)(e.br,{}),"\n","这里我强调了“不等同”，那么相应地一定会有“等同”的情况——假如我们要寻找的目标结点是 ",(0,c.jsx)(e.code,{children:"5"}),"和",(0,c.jsx)(e.code,{children:"6"}),"，那么对于",(0,c.jsx)(e.code,{children:"5"}),"来说，即使只有一侧的孩子结点给它作了有效的汇报，也不影响它作为两个结点的最近公共祖先而存在（因为它自己既是儿子也是爸爸）。"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["对于 ",(0,c.jsx)(e.code,{children:"1"}),"这个结点来说，它的左孩子和右孩子上都没有目标结点，这意味着它拿到的所有“汇报”就都是无效的，因此",(0,c.jsx)(e.code,{children:"1"}),"不是最近公共祖先。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["分析至此，我们发现了一个明显的规律：最近公共祖先和有效汇报个数之间，有着非常强烈的关联。",(0,c.jsx)(e.br,{}),"\n","那么“有效汇报个数”就成了我们做题的抓手。由于一个结点最多有两个孩子，它拿到的有效汇报个数也无非只有0、1、2这三种可能性，我们逐个来看："]}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["若有效汇报个数为0，则",(0,c.jsx)(e.code,{children:"p"}),"和",(0,c.jsx)(e.code,{children:"q"}),"完全不存在与当前结点的后代中，当前结点一定不是最近公共祖先（对应示例二叉树中",(0,c.jsx)(e.code,{children:"p=6, q=2"}),"时，",(0,c.jsx)(e.code,{children:"6、2、1"}),"之间的关系）。"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["若有效汇报个数为2，则意味着 ",(0,c.jsx)(e.code,{children:"p"}),"和",(0,c.jsx)(e.code,{children:"q"})," 所在的两个分支刚好在当前结点交错了，当前结点就是",(0,c.jsx)(e.code,{children:"p"}),"和",(0,c.jsx)(e.code,{children:"q"}),"的最近公共祖先（对应示例二叉树中",(0,c.jsx)(e.code,{children:"p=6, q=2"}),"时，",(0,c.jsx)(e.code,{children:"6、2、5"}),"之间的关系）。"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["若有效汇报个数为1，这里面蕴含着三种情况：",(0,c.jsx)(e.br,{}),"\n","a. 当前结点的左子树/右子树中，",(0,c.jsxs)(e.strong,{children:["包含了",(0,c.jsx)(e.code,{children:"p"}),"或者",(0,c.jsx)(e.code,{children:"q"}),"中的一个"]}),"。此时我们需要将",(0,c.jsx)(e.code,{children:"p"}),"或者",(0,c.jsx)(e.code,{children:"q"}),"所在的那棵子树的根结点作为有效结点上报，继续向上去寻找",(0,c.jsx)(e.code,{children:"p"}),"和",(0,c.jsx)(e.code,{children:"q"}),"所在分支的交错点。"]}),"\n",(0,c.jsxs)(e.p,{children:["b. 当前结点的左子树/右子树中，",(0,c.jsxs)(e.strong,{children:["同时包含了 ",(0,c.jsx)(e.code,{children:"p"})," 和 ",(0,c.jsx)(e.code,{children:"q"})]}),"。在有效汇报数为1的前提下，这种假设只可能对应一种情况，",(0,c.jsxs)(e.strong,{children:["那就是",(0,c.jsx)(e.code,{children:"p"}),"和",(0,c.jsx)(e.code,{children:"q"}),"之间互为父子关系"]}),"。此时我们仍然是需要将",(0,c.jsx)(e.code,{children:"p"}),"和",(0,c.jsx)(e.code,{children:"q"}),"所在的那个子树的根结点（其实就是",(0,c.jsx)(e.code,{children:"p"}),"或者",(0,c.jsx)(e.code,{children:"q"}),"中作为爸爸存在那个）作为有效结点给上报上去。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"结合上面三种情况，我们可以进一步分析出以下结论："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsx)(e.li,{children:"若有效汇报个数为2，直接返回当前结点"}),"\n",(0,c.jsx)(e.li,{children:"若有效汇报个数为1，返回1所在的子树的根结点"}),"\n",(0,c.jsx)(e.li,{children:"若有效汇报个数为0，则返回空（空就是无效汇报）"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"我们把这个判定规则，揉进二叉树递归的层层上报的逻辑里去，就得到了这道题的答案："}),"\n",(0,c.jsxs)(e.h3,{id:"编码实现",children:["编码实现",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"/**\n * 二叉树结点的结构定义如下\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nconst lowestCommonAncestor = function(root, p, q) {\n    // 编写 dfs 逻辑\n    function dfs(root) {\n        // 若当前结点不存在（意味着无效）或者等于p/q（意味着找到目标），则直接返回\n        if(!root || root === p || root === q) {\n            return root \n        }\n        // 向左子树去寻找p和q\n        const leftNode = dfs(root.left)  \n        // 向右子树去寻找p和q\n        const rightNode = dfs(root.right)  \n        // 如果左子树和右子树同时包含了p和q，那么这个结点一定是最近公共祖先\n        if(leftNode && rightNode) {\n            return root \n        } \n        // 如果左子树和右子树其中一个包含了p或者q，则把对应的有效子树汇报上去，等待进一步的判断；否则返回空\n        return leftNode || rightNode\n    } \n    \n    // 调用 dfs 方法 \n    return dfs(root)  \n};\n"})}),"\n",(0,c.jsxs)(e.h2,{id:"寻找两个正序数组的中位数",children:["寻找两个正序数组的中位数",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#寻找两个正序数组的中位数",children:"#"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["题目描述：给定两个大小为 m 和 n 的正序（从小到大）数组\xa0nums1 和\xa0nums2。",(0,c.jsx)(e.br,{}),"\n","请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为\xa0O(log(m + n))。",(0,c.jsx)(e.br,{}),"\n","你可以假设\xa0nums1\xa0和\xa0nums2\xa0不会同时为空。"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["示例 1:\nnums1 = [1, 3]",(0,c.jsx)(e.br,{}),"\n","nums2 = [2]",(0,c.jsx)(e.br,{}),"\n","则中位数是 2.0"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["示例 2:",(0,c.jsx)(e.br,{}),"\n","nums1 = [1, 2]",(0,c.jsx)(e.br,{}),"\n","nums2 = [3, 4]",(0,c.jsx)(e.br,{}),"\n","则中位数是 (2 + 3)/2 = 2.5"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"命题关键字：二分思想、数学问题"})}),"\n",(0,c.jsxs)(e.h3,{id:"思路分析-1",children:["思路分析",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-1",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"在做这道题之前，大家先记住一个规律："}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["题目中若要求",(0,c.jsx)(e.code,{children:"log"}),"级别的时间复杂度，则优先使用二分法解题"]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["回到这道题上来，既然题目要求",(0,c.jsx)(e.code,{children:"log"}),"级别的时间复杂度，我们首要的解题思路就不应该再是“遍历”，而应该是“切割”。"]}),"\n",(0,c.jsxs)(e.h4,{id:"理解中位数的取值思路",children:["理解中位数的取值思路",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#理解中位数的取值思路",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["接下来就需要思考切割的手法了。大家想想，如果只允许你用切割的方式来定位两个正序数组的中位数，你会怎么办？是不是应该首先想到从",(0,c.jsx)(e.strong,{children:"元素的数量"}),"上入手？"]}),"\n",(0,c.jsx)(e.p,{children:"具体来说，假如我这里需要求解的是这样两个数组："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"nums1 = [1, 3, 5, 7, 9]  \nnums2 = [2, 4, 6, 8, 10]\n"})}),"\n",(0,c.jsxs)(e.p,{children:["我要求解的中位数的范围是10个数，那么假如我在某个合适的位置分别切割了",(0,c.jsx)(e.code,{children:"nums1"}),"和",(0,c.jsx)(e.code,{children:"nums2"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"[1, 3, 5,| 7, 9]  \n|<- s1 ->|  \n\n[2, 4, |6, 8, 10]\n|<-s2->|  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["使得 ",(0,c.jsx)(e.code,{children:"s1+s2"}),"，刚好就是10个数里面按正序排布的前5个数。这样我其实只需要关心切割边界的这些值就可以了："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"       L1  R1    \n[1, 3, 5,| 7, 9]  \n|<- s1 ->|  \n    \n    L2  R2\n[2, 4, |6, 8, 10]\n|<-s2->|  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["这个例子中，数组总长度是10，10是偶数。偶数个数字的中位数，按照定义需要取中间两个元素的平均值。而“中间两个元素”，一定分别是 ",(0,c.jsx)(e.code,{children:"L1"}),"和",(0,c.jsx)(e.code,{children:"L2"}),"中的较大值，以及",(0,c.jsx)(e.code,{children:"R1"}),"和",(0,c.jsx)(e.code,{children:"R2"}),"中的最小值（这个结论无需多言，你品品就出来了）："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 取 L1 和 L2 中的较大值\nconst L = L1 > L2 ? L1 : L2   \n// 取 R1 和 R2 中的较小值\nconst R = R1 < R2 ? R1 : R2  \n// 计算平均值\nreturn  (L + R)/2\n"})}),"\n",(0,c.jsx)(e.p,{children:"此时假如给其中一个数组增加一个元素，让两个数组的长度和变为奇数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"       L1  R1    \n[1, 3, 5,| 7, 9, 11]  \n|<- s1 ->|    \n\n    L2  R2\n[2, 4, |6, 8, 10]\n|<-s2->|  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["那么中位数的取值就更简单了，我们只需要取 ",(0,c.jsx)(e.code,{children:"R1"})," 和 ",(0,c.jsx)(e.code,{children:"R2"})," 中的较小值即可："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const median = (R1 < R2) ? R1 : R2  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["到此为止，大家就对“切割法”下的中位数取值思路有了基本的了解。",(0,c.jsx)(e.br,{}),"\n","以上我们所有的讨论，都是建立在 ",(0,c.jsx)(e.code,{children:"nums1"})," 和 ",(0,c.jsx)(e.code,{children:"nums2"})," 的分割点已知的前提下。实际上，对这道题来说，分割点的计算才是它真正的难点。"]}),"\n",(0,c.jsx)(e.p,{children:"要解决这个问题，就需要请出二分思想了。"}),"\n",(0,c.jsxs)(e.h4,{id:"二分思想确定分割点",children:["二分思想确定分割点",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二分思想确定分割点",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"我们回头看这个数组"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"nums1 = [1, 3, 5, 7, 9]  \nnums2 = [2, 4, 6, 8, 10]\n"})}),"\n",(0,c.jsxs)(e.p,{children:["在不口算的情况下，没有人会知道 ",(0,c.jsx)(e.code,{children:"R1"}),"、",(0,c.jsx)(e.code,{children:"R2"}),"到底取在哪个位置是比较合理的，你只知道一件事——我需要让",(0,c.jsx)(e.code,{children:"nums1切割后左侧的元素个数+nums2切割后左侧元素的个数===两个数组长度和的一半"}),"。",(0,c.jsx)(e.br,{}),"\n","我们先用编码语言来表达一下这个关系："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// slice1和slice2分别表示R1的索引和R2的索引\nslice1 + slice2 === Math.floor((nums1.length + nums2.length)/2)\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"nums1、nums2"}),"的长度是已知的，这也就意味着只要求出 ",(0,c.jsx)(e.code,{children:"slice1"})," 和 ",(0,c.jsx)(e.code,{children:"slice2"})," 中的一个，另一个值就能求出来了。"]}),"\n",(0,c.jsx)(e.p,{children:"因此我们的大方向先明确如下："}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"用二分法定位出其中一个数组的slice1，然后通过做减法求出另一个数组的slice2"}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["“其中一个数组”到底以",(0,c.jsx)(e.code,{children:"nums1"}),"为准还是以",(0,c.jsx)(e.code,{children:"nums2"}),"为准？答案是以长度较短的数组为准，这样做可以减小二分计算的范围，从而提高我们算法的效率，所以我们代码开局就是要校验两个数组的长度大小关系："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const findMedianSortedArrays = function(nums1, nums2) {  \n    const len1 = nums1.length  \n    const len2 = nums2.length    \n    // 确保直接处理的数组（第一个数组）总是较短的数组\n    if(len1 > len2) {\n        return findMedianSortedArrays(nums2, nums1)\n    }\n    ...\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["从而确保较短的数组始终占据",(0,c.jsx)(e.code,{children:"nums1"}),"的位置，后续我们就拿",(0,c.jsx)(e.code,{children:"nums1"}),"开刀做二分。"]}),"\n",(0,c.jsxs)(e.p,{children:["这里我们假设 ",(0,c.jsx)(e.code,{children:"nums1"})," 和 ",(0,c.jsx)(e.code,{children:"nums2"})," 分别是以下两个数组："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"nums1 = [5, 6, 7] \nnums2 = [1, 2, 4, 12]\n"})}),"\n",(0,c.jsxs)(e.p,{children:["用二分法做题，首先需要明确二分的两个端点。在没有任何多余线索的情况下，我们只能把二分的端点定义为 ",(0,c.jsx)(e.code,{children:"nums1"})," 的起点和终点:"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 初始化第一个数组二分范围的左端点\nlet slice1L = 0  \n// 初始化第一个数组二分范围的右端点\nlet slice1R = len1  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["基于此去计算 ",(0,c.jsx)(e.code,{children:"slice1"})," 的值："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"slice1 = Math.floor((slice1R - slice1L)/2) + slice1L  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["然后通过做减法求出 ",(0,c.jsx)(e.code,{children:"slice2"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"slice2 = Math.floor(len/2) - slice1\n"})}),"\n",(0,c.jsx)(e.p,{children:"第一次二分，两个数组分别被分割为如下形状："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"        L1   R1\nnums1 = [5, |6, 7]   \n\n            L2  R2\nnums2 = [1, 2, |4, 12]\n"})}),"\n",(0,c.jsxs)(e.p,{children:["如何确认你的二分是否合理？标准只有一个——",(0,c.jsx)(e.strong,{children:"分割后，需要确保左侧的元素都比右侧的元素小"}),"，也就是说你的两个分割线要间接地把两个数组按照正序分为两半。这个标准用变量关系可以表示如下："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"L1 <= R1  \nL1 <= R2  \nL2 <= R1 \nL2 <= R2  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["由于数组本身是正序的，所以",(0,c.jsx)(e.code,{children:"L1 <= R1"}),"、",(0,c.jsx)(e.code,{children:"L2 <= R2"}),"是必然的，我们需要判断的是剩下两个不等关系："]}),"\n",(0,c.jsxs)(e.p,{children:["若发现 ",(0,c.jsx)(e.code,{children:"L1 > R2"}),"，则说明",(0,c.jsx)(e.code,{children:"slice1"}),"取大了，需要用二分法将",(0,c.jsx)(e.code,{children:"slice1"}),"适当左移；若发现",(0,c.jsx)(e.code,{children:"L2 > R1"}),"，则说明",(0,c.jsx)(e.code,{children:"slice1"}),"取小了，需要用二分法将",(0,c.jsx)(e.code,{children:"slice1"}),"适当右移："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 处理L1>R2的错误情况\n if(L1 > R2) {\n    // 将slice1R左移，进而使slice1对应的值变小\n    slice1R = slice1 - 1\n} else if(L2 > R1) {\n    // 反之将slice1L右移，进而使slice1对应的值变大\n    slice1L = slice1 + 1\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"只有当以上两种偏差情况都不发生时，我们的分割线才算定位得恰到好处，此时就可以执行取中位数的逻辑了："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// len表示两个数组的总长度\nif(len % 2 === 0) {\n    // 偶数长度对应逻辑（取平均值）\n    const L = L1 > L2 ? L1 : L2  \n    const R = R1 < R2 ? R1 : R2\n    return  (L + R)/2\n} else {\n    // 奇数长度对应逻辑（取中间值）\n    const median = (R1 < R2) ? R1 : R2  \n    return median\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"我们把以上的整个分析用代码串起来，就有了这道题的答案："}),"\n",(0,c.jsxs)(e.h3,{id:"编码实现-1",children:["编码实现",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-1",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nconst findMedianSortedArrays = function(nums1, nums2) {  \n    const len1 = nums1.length  \n    const len2 = nums2.length    \n    // 确保直接处理的数组（第一个数组）总是较短的数组\n    if(len1 > len2) {\n        return findMedianSortedArrays(nums2, nums1)\n    }\n    // 计算两个数组的总长度\n    const len = len1 + len2 \n    // 初始化第一个数组“下刀”的位置\n    let slice1 = 0  \n    // 初始化第二个数组“下刀”的位置\n    let slice2 = 0  \n    // 初始化第一个数组二分范围的左端点\n    let slice1L = 0  \n    // 初始化第一个数组二分范围的右端点\n    let slice1R = len1  \n    let L1, L2, R1, R2\n    // 当slice1没有越界时\n    while(slice1 <= len1) {\n        // 以二分原则更新slice1\n        slice1 = Math.floor((slice1R - slice1L)/2) + slice1L  \n        // 用总长度的1/2减去slice1，确定slice2\n        slice2 = Math.floor(len/2) - slice1 // 计算L1、L2、R1、R2\n        const L1 = (slice1===0)? -Infinity : nums1[slice1-1]\n        const L2 = (slice2===0)? -Infinity : nums2[slice2-1]  \n        const R1 = (slice1===len1)? Infinity : nums1[slice1]  \n        const R2 = (slice2===len2)? Infinity: nums2[slice2]\n        \n        // 处理L1>R2的错误情况\n        if(L1 > R2) {\n            // 将slice1R左移，进而使slice1对应的值变小\n            slice1R = slice1 - 1\n        } else if(L2 > R1) {\n            // 反之将slice1L右移，进而使slice1对应的值变大\n            slice1L = slice1 + 1\n        } else {\n            // 如果已经符合取中位数的条件（L1<R2&&L2<R1)，则直接取中位数\n            if(len % 2 === 0) {\n                const L = L1 > L2 ? L1 : L2  \n                const R = R1 < R2 ? R1 : R2\n                return  (L + R)/2\n            } else {\n                const median = (R1 < R2) ? R1 : R2  \n                return median\n            }\n        }\n\n    }\n    return -1\n};\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"拓展",children:["拓展",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#拓展",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["假如把题目中的 ",(0,c.jsx)(e.code,{children:"O(log(m+n))"})," 改为 ",(0,c.jsx)(e.code,{children:"O(m+n)"}),"，你会怎样做？"]}),"\n",(0,c.jsxs)(e.h2,{id:"粉刷房子问题",children:["“粉刷房子”问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#粉刷房子问题",children:"#"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["题目描述: 假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。",(0,c.jsx)(e.br,{}),"\n","当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。",(0,c.jsx)(e.br,{}),"\n","例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"注意：\n所有花费均为正整数。"}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["示例：\n输入: [[17,2,17],[16,16,5],[14,3,19]]",(0,c.jsx)(e.br,{}),"\n","输出: 10",(0,c.jsx)(e.br,{}),"\n","解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。",(0,c.jsx)(e.br,{}),"\n","最少花费: 2 + 5 + 3 = 10。"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"命题关键字：动态规划、滚动数组"})}),"\n",(0,c.jsxs)(e.h3,{id:"思路分析-2",children:["思路分析",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-2",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"这道题的特征非常肤浅，从概念的角度来说，动态规划的两个特征全部命中（如果你不知道我在说啥，建议复习小册第22、23节）；从技巧的角度来说，“求最值”这个信号也在疯狂暗示你用动态规划来解决它。"}),"\n",(0,c.jsx)(e.p,{children:"对于最值型动态规划，我们最常用的思路仍然是动态规划专题中首推的“倒推”法。由于这个方法笔者已经重复地讲过太多次了，我们就不再在真题训练环节予以过多的表述（这道题的重点也不在这里）。结合“倒推”法，我们可以得出题目对应的状态转移方程是："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"f[i][x] = Math.min(f[i-1][x以外的索引1号], f[i-1][x以外的索引2号]) + costs[i][x]\n"})}),"\n",(0,c.jsxs)(e.p,{children:["其中",(0,c.jsx)(e.code,{children:"f[i][x]"}),"对应的是当粉刷到第",(0,c.jsx)(e.code,{children:"i"}),"个房子时，使用第",(0,c.jsx)(e.code,{children:"x"}),"（x=0、1、2）号油漆对应的总花费成本的最小值。"]}),"\n",(0,c.jsxs)(e.p,{children:["状态的初始值，就是当 ",(0,c.jsx)(e.code,{children:"i=0"})," 时对应的三个值："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"f[0][0] = costs[0][0]\nf[0][1] = costs[0][1]\nf[0][2] = costs[0][2]   \n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"f[0][0]"}),"、",(0,c.jsx)(e.code,{children:"f[0][1]"}),"、",(0,c.jsx)(e.code,{children:"f[0][2]"}),"分别表示当粉刷到第0个房子时，对它使用0号、1号、2号油漆对应的总花费成本。此时由于只粉刷了一个房子，所以总花费成本就等于房子本身的花费成本。",(0,c.jsx)(e.br,{}),"\n","基于以上两个结论，我们可以有如下的初步编码："]}),"\n",(0,c.jsxs)(e.h3,{id:"编码实现-基础版",children:["编码实现-基础版",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-基础版",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[][]} costs\n * @return {number}\n */\nconst minCost = function(costs) {\n    // 处理边界情况\n    if(!costs || !costs.length) return 0 \n    // 缓存房子的个数\n    const len = costs.length  \n    // 初始化状态数组（二维）\n    const f = new Array(len)\n    for(let i=0;i<len;i++) {\n        f[i] = new Array(3)\n    }\n    // 初始化状态值\n    f[0][0] = costs[0][0]\n    f[0][1] = costs[0][1]\n    f[0][2] = costs[0][2]   \n    // 开始更新刷到每一个房子时的状态值\n    for(let i=1;i<len;i++) {\n      // 更新刷到当前房子时，给当前房子选用第0种油漆对应的最小总价\n      f[i][0] = Math.min(f[i-1][1], f[i-1][2]) + costs[i][0]\n      // 更新刷到当前房子时，给当前房子选用第1种油漆对应的最小总价\n      f[i][1] = Math.min(f[i-1][2], f[i-1][0]) + costs[i][1]\n      // 更新刷到当前房子时，给当前房子选用第2种油漆对应的最小总价\n      f[i][2] = Math.min(f[i-1][1], f[i-1][0]) + costs[i][2]\n    }\n    // 返回刷到最后一个房子时，所有可能出现的总价中的最小值\n    return Math.min(f[len-1][0], f[len-1][1], f[len-1][2])\n};\n"})}),"\n",(0,c.jsxs)(e.p,{children:["如果你写出了以上答案，而你的面试官又是一个在算法方面稍有见识的人，他就会问你：这道题的空间复杂度能否进一步优化？",(0,c.jsx)(e.br,{}),"\n","此时，没有读过算法小册的同学，他以为自己做完了整道题，其实好戏才刚刚开始。",(0,c.jsx)(e.br,{}),"\n","而认真研读过小册第23节的同学，他认为这样的追问合情合理，甚至在一开始准备好了思路，就等面试官把舞台交给自己。只见他三下五除二，就变出了一个叫“滚动数组”的东西，把这道题的空间复杂度碾了个稀碎："]}),"\n",(0,c.jsxs)(e.h3,{id:"编码实现-优化版",children:["编码实现-优化版",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-优化版",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[][]} costs\n * @return {number}\n */\nconst minCost = function(costs) {\n    // 处理边界情况\n    if(!costs || !costs.length) return 0 \n    // 缓存房子的个数\n    const len = costs.length\n    // 开始更新状态\n    for(let i=1;i<len;i++) {  \n        // now表示粉刷到当前房子时对应的价格状态\n        const now = costs[i]  \n        // prev表示粉刷到上一个房子时的价格状态\n        const prev = costs[i-1]  \n        // 更新当前状态下，刷三种油漆对应的三种最优价格\n        now[0] += Math.min(prev[1], prev[2])  \n        now[1] += Math.min(prev[0], prev[2])  \n        now[2] += Math.min(prev[1], prev[0])\n    }\n    // 返回粉刷到最后一个房子时，总价格的最小值\n    return Math.min(costs[len-1][0], costs[len-1][1], costs[len-1][2])\n};\n"})}),"\n",(0,c.jsxs)(e.p,{children:["倘若对“基础版”代码稍作分析，你就会发现，其实我们每次更新",(0,c.jsx)(e.code,{children:"f[i]"}),"时，需要的仅仅是 ",(0,c.jsx)(e.code,{children:"f[i-1]"}),"对应的状态而已，因此我们只需要确保一个数组中总是能保持着有效的",(0,c.jsx)(e.code,{children:"f[i-1]"}),"即可。",(0,c.jsx)(e.br,{}),"\n","这样的特征，符合“滚动数组”的使用场景。在这道题中，我们直接滚动了题目中原有的",(0,c.jsx)(e.code,{children:"costs"}),"变量，将空间复杂度缩减了一个量级。"]}),"\n",(0,c.jsx)(e.p,{children:"“滚动数组”是什么、怎么用？如果你对此心怀疑惑，请耐下心来，复习一下小册的第23节吧~^_^"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(i,{...n})}):i(n)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%2F26.%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%E4%B8%8E%E8%A7%A3%E8%AF%BB%E2%80%94%E2%80%94%E8%85%BE%E8%AE%AF%E7%9C%9F%E9%A2%98.md"]={toc:[{text:"寻找二叉树的最近公共祖先",id:"寻找二叉树的最近公共祖先",depth:2},{text:"思路分析",id:"思路分析",depth:3},{text:"编码实现",id:"编码实现",depth:3},{text:"寻找两个正序数组的中位数",id:"寻找两个正序数组的中位数",depth:2},{text:"思路分析",id:"思路分析-1",depth:3},{text:"理解中位数的取值思路",id:"理解中位数的取值思路",depth:4},{text:"二分思想确定分割点",id:"二分思想确定分割点",depth:4},{text:"编码实现",id:"编码实现-1",depth:3},{text:"拓展",id:"拓展",depth:3},{text:"“粉刷房子”问题",id:"粉刷房子问题",depth:2},{text:"思路分析",id:"思路分析-2",depth:3},{text:"编码实现-基础版",id:"编码实现-基础版",depth:3},{text:"编码实现-优化版",id:"编码实现-优化版",depth:3}],title:"26.大厂真题训练与解读——腾讯真题",headingTitle:"26.大厂真题训练与解读——腾讯真题",frontmatter:{}}}}]);