"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["84790"],{370133:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var r=t(552676),a=t(740453);let s=t.p+"static/image/2-2.d054a3bd.png",c=t.p+"static/image/2-1.ad8e2c83.png";function i(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",p:"p",img:"img",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"",children:(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,r.jsxs)(n.h1,{id:"2案例一-龟兔赛跑-node-的语言基础---jses5678",children:["2案例一： [龟兔赛跑] Node 的语言基础 - JS（ES5、6、7、8）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2案例一-龟兔赛跑-node-的语言基础---jses5678",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png | left | 826x102"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-!",children:"本节目标：【实现一个龟兔赛跑小动画】 - 没有金刚钻，不揽瓷器活，必要的 JS 知识是学习 Node 的第一板斧。\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"名词概念解释",children:["名词概念解释",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#名词概念解释",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"JS 对 JavaScript 的简称，实际意义与 JavaScript 相同"}),"\n",(0,r.jsxs)(n.li,{children:["JavasScript 通用叫法，代指实现了 ","ECMAScript 标准的任何语言版本"]}),"\n",(0,r.jsx)(n.li,{children:"ES 对 ECMAScript 的简称，实际意义与 ECMAScript 相同"}),"\n",(0,r.jsxs)(n.li,{children:["ECMAScript \xa0",(0,r.jsx)(n.a,{href:"http://www.ecma-international.org/",target:"_blank",rel:"noopener noreferrer",children:"欧洲计算机制造商协会"})," 对 Javascript 语言制定的工业标准，随着时间推移版本不断更新，如 ES3/4/5"]}),"\n",(0,r.jsx)(n.li,{children:"ES2/3/4/5 是语言标准的版本，ES2015/ES2016 是发布标准的年份称谓，如 ES2015/ES6 意义等同"}),"\n",(0,r.jsx)(n.li,{children:"ES.Next 代指下一个要推出的语言标准，它永远指向下一个，是动态的"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"1995 年网景浏览器发布 LiveScript，后来改名 JavaScript，再后来提交 JavaScript 到 ECMA 进行标准化，也就有了官方学名 ECMAScript，只是 ECMAScript 这个名字不怎么讨人喜爱，大家仍然习惯叫 JavaScript。"}),"\n",(0,r.jsx)(n.p,{children:"到如今已过去 20 多年了，按道理说，根据 JavaScript 语言进化的速度，到现在应该有至少十几个 ES 版本出来，然后并没有，原因是标准协会负责定标准，但实际执行标准实现（落地）的是浏览器厂商，每个厂商都夹带私货，对标准也不是全部认同，标准协会自己干活也不怎么接地气，甚至在 1999 年 ES3 ~ 2009 年 ES5 这个黄金十年是停滞不前的，并没有多少群众呼声大的特性加入标准，人生有多少个十年，也不能说它没干活，1999 年还是推出了 ES4，但太过激进这个版本就报废了，没有在厂商落地，直到 2009 年语言标准才有步入正轨，这个停滞的 10 年中标准协会以及厂商的撕逼内幕非常精彩，大家有兴趣可以去扒一扒。"}),"\n",(0,r.jsxs)(n.h2,{id:"webpack-中用到的部分语法特性",children:["Webpack 中用到的部分语法特性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-中用到的部分语法特性",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 Node 里面自 v6.14.4 之后，",(0,r.jsx)(n.a,{href:"https://node.green/",target:"_blank",rel:"noopener noreferrer",children:"就支持了 99% 以上的 ES6 语法特性"}),"，在 v10.x 之后，也支持了几乎全部的 ES7/ES2016、ES8/ES2017、ES9/ES2018 的可用语法特性，我们主要关注 ES6/ES2015 中新增的语法特性和部分 ES7/8/9 的语法特性，在小册子我们会使用 Node v10.11.x 的版本来运行一些示例代码。"]}),"\n",(0,r.jsx)(n.p,{children:"首先，给大家列一些 Webpack 中用到的语法特性，源码也都是从 Webpack 或者它依赖的模块中扒出来的，如果大家对这里面大部分特性看不懂的，建议参考如下资料系统学习荡平一下 Javascript 的入门门槛，再往下进入到我们的编码环节。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla",target:"_blank",rel:"noopener noreferrer",children:"Mozilla 文档"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"http://es6.ruanyifeng.com/#docs/intro",target:"_blank",rel:"noopener noreferrer",children:"阮老师的 ES6 入门"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"除了上面这些，还有 Class/Async Function/Generator Function 等等许许多多的特性，不再一一列举。"}),"\n",(0,r.jsxs)(n.h3,{id:"编程练习---实现一个命令行龟兔赛跑动画",children:["编程练习 - 实现一个命令行龟兔赛跑动画",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编程练习---实现一个命令行龟兔赛跑动画",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们来基于上面的知识结果，可以借助 chalk-animation 模块，来实现一个在命令行的进度条动画 - 龟兔赛跑，先看下效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:"QQ20181007-185354.gif | center | 807x55"})}),"\n",(0,r.jsx)(n.p,{children:"要实现这样一个效果，思路是很简单的，就是不断的去刷新当前的终端日志就可以了，所以本质上是把字符串按照我们计算的规则，每隔比如 1 秒钟，就刷新一下进度，至于龟兔，控制好它俩在的几个状态就行。"}),"\n",(0,r.jsx)(n.p,{children:"首先是起始状态："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"兔子乌龟|..............................》\n"})}),"\n",(0,r.jsx)(n.p,{children:"其次是兔子超越乌龟，并且兔子停下的状态："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"|......乌龟...................兔子.....》\n"})}),"\n",(0,r.jsx)(n.p,{children:"再次是乌龟超越兔子时的状态："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"|.........................兔子乌龟.....》\n"})}),"\n",(0,r.jsx)(n.p,{children:"最后是乌龟越过终点的状态："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"|.........................兔子.....》乌龟\n"})}),"\n",(0,r.jsx)(n.p,{children:"那我们首先可以用很简陋的代码来实现这个逻辑，让兔子速度是乌龟的 3 倍，等待 2 秒后，它俩开始离开起点，每隔 150 毫秒，就计算下它俩走多远了，也就是速度 x 轮询的次数，比如 450 毫秒后，乌龟走过去了三米，兔子走过去了九米距离，那么第一次写的代码可能就是这样的比较挫的代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 声明 2 个比赛队员\nconst rabbit = '兔子'\nconst turtle = '乌龟'\n// 声明一坨变量，作为赛道起点终点字符串\nconst start = '|'\nconst end = '》'\n// 赛道上一米一米的距离，用 . 表示\nconst pad = '.'\n// 速度是 1 米/150 毫秒\nconst speed = 1\n// 赛道一共有 50 米\nconst steps = 50\n// 约定兔子在 42 米的时候停下\nconst stopAt = 42\n// 判断兔子是否停下\nlet stoped = false\n// 默认从 0 开始轮询\nlet t = 0\n// 一个定时器的句柄而已\nlet timer\n\n// 计算兔子距离终点\nconst getRabbitLastSteps = () => {\n  return steps - t * speed - t * speed * 3\n}\n\n// 计算乌龟距离终点\nconst getTurtleLastSteps = () => {\n  return steps - t * speed\n}\n\n// 计算龟兔间距\nconst getGapSteps = () => {\n  return stopAt - t * speed\n}\n\n// 初始赛道状态\nconst checkRaceInitState = () => {\n  return `${rabbit}${turtle}${start}${pad.repeat(steps)}${end}`\n}\n\n// 兔子领先时的赛道状态\nconst checkRaceState = () => {\n  return `${start}${pad.repeat(t * speed)}${turtle}${pad.repeat(t * speed * 3)}${rabbit}${pad.repeat(getRabbitLastSteps())}${end}`\n}\n\n// 分情况计算赛道的实时状态\nconst checkBackRaceState = () => {\n  if (getGapSteps() <= 0) {\n    if (getTurtleLastSteps() === 0) {\n      return `${start}${pad.repeat(stopAt)}${rabbit}${pad.repeat(steps - stopAt)}${end}${turtle}`\n    } else {\n      return `${start}${pad.repeat(stopAt)}${rabbit}${pad.repeat(t * speed - stopAt)}${turtle}${pad.repeat(getTurtleLastSteps())}${end}`\n    }\n  } else {\n    return `${start}${pad.repeat(t * speed)}${turtle}${pad.repeat(getGapSteps())}${rabbit}${pad.repeat(steps - stopAt)}${end}`\n  }\n}\n\n// 等待时间，把定时器包装秤一个 Promise\nconst wait = (sec) => new Promise(resolve => setTimeout(() => resolve(), sec))\n\n// 可以支持特效刷新的命令行日志模块\nconst chalkWorker = require('chalk-animation')\nconst initState = checkRaceInitState()\nconst racing = chalkWorker.rainbow(initState)\n\nconst updateRaceTrack = (state) => {\n  racing.replace(state)\n}\n\nconst race = () => {\n  timer = setInterval(() => {\n    // 判断是否兔子停下\n    if (!stoped) {\n      if (getRabbitLastSteps() <= (steps - stopAt)) {\n        stoped = true\n      }\n    }\n\n    if (stoped) {\n      let state = checkBackRaceState()\n      updateRaceTrack(state)\n\n      if (getTurtleLastSteps() === 0) {\n        // 乌龟过线后就停止定时器\n        clearInterval(timer)\n        return\n      }\n    } else {\n      let state = checkRaceState()\n      updateRaceTrack(state)\n    }\n    \n    t++\n  }, 150); \n}\n\n// 等待 20 秒再开始启动比赛\nwait(2000).then(() => {\n  race()\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"在这一坨代码里面，我们用到了箭头函数/Promise/const/let/模板字符串，可以让代码变得清爽一些，并且有了 Promise，可以避免过度的 callback 嵌套，通过这个代码是为了让大家了解到，Nodejs 首先是 JS，其次是 Node，而 JS 里面又有不同时代的 ES 标准，所以大家在学习 Node 之前，是需要花一些时间来了解下 JS 尤其是 ES 最新标准带来的新语法的，比如我们可以增加 class 来把上面的 race function 再抽象下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const chalkWorker = require('chalk-animation')\n\nclass Race extends Object {\n  constructor(props = {}) {\n    super(props)\n    ;[\n      ['rabbit', '兔子'],\n      ['turtle', '乌龟'],\n      ['turtleStep', 0],\n      ['rabbitStep', 0],\n      ['start', '|'],\n      ['end', '》'],\n      ['pad', '.'],\n      ['speed', 1],\n      ['steps', 50],\n      ['stopAt', 42]\n    ].forEach(elem => {\n      const [key, value] = elem\n      if (!(key in props)) {\n        this[key] = value\n      }\n    })\n  }\n\n  getRaceTrack () {\n    const {\n      start,\n      pad,\n      turtle,\n      turtleStep,\n      rabbit,\n      rabbitStep,\n      steps,\n      end\n    } = this\n\n    if (!turtleStep && !rabbitStep) {\n      return `${turtle}${rabbit}${start}${pad.repeat(steps)}${end}`\n    }\n\n    const [\n      [minStr, min],\n      [maxStr, max]\n    ] = [\n      [turtle, turtleStep],\n      [rabbit, rabbitStep]\n    ].sort((a, b) => a[1] - b[1])\n\n    const prefix = `${pad.repeat((min || 1) - 1)}`\n    const middle = `${pad.repeat(max - min)}`\n    const suffix = `${pad.repeat(steps - max)}`\n\n    const _start = `${start}${prefix}${minStr}`\n    const _end = suffix ? `${maxStr}${suffix}${end}` : `${end}${maxStr}`\n    return `${_start}${middle}${_end}`\n  }\n\n  updateRaceTrack (state, racing) {\n    racing.replace(state)\n  }\n\n  updateSteps () {\n    if (this.turtleStep >= this.steps) return\n    if (this.rabbitStep <= this.stopAt) {\n      this.rabbitStep += 3 * this.speed\n    }\n    this.turtleStep += 1 * this.speed\n  }\n\n  race () {\n    const initState = this.getRaceTrack()\n    const racing = chalkWorker.rainbow(initState)\n    let t = 0\n    let timer = setInterval(() => {\n      if (t <= 6) {\n        t += 1\n        return\n      }\n      const state = this.getRaceTrack()\n      this.updateRaceTrack(state, racing)\n      this.updateSteps()\n    }, 150)\n  }\n}\n\nconst proxy = new Proxy(Race, {\n  apply (target, ctx, args) {\n    const race = new target(...args)\n    return race.race()\n  }\n})\n\nproxy()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["除了 class，还增加了一些 rest 参数，解构赋值等，但依然实现过程比较猥琐且过度设计，大家能 Get 到 ",(0,r.jsx)(n.code,{children:"语法特性能带来一些编程实现方式的差异性"})," 这一点，这一章节的目的就达到了。"]}),"\n",(0,r.jsxs)(n.h2,{id:"思考",children:["思考",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"基于上面的代码，给大家布置一个作业，如果要实现龟兔赛跑，但可以让兔子停留的位置随机应该怎么实现？"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let d=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F2%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%20%5B%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%5D%20Node%20%E7%9A%84%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%20-%20JS%EF%BC%88ES5%E3%80%816%E3%80%817%E3%80%818%EF%BC%89.md"]={toc:[{text:"",id:"",depth:3},{text:"名词概念解释",id:"名词概念解释",depth:2},{text:"Webpack 中用到的部分语法特性",id:"webpack-中用到的部分语法特性",depth:2},{text:"编程练习 - 实现一个命令行龟兔赛跑动画",id:"编程练习---实现一个命令行龟兔赛跑动画",depth:3},{text:"思考",id:"思考",depth:2}],title:"2案例一： [龟兔赛跑] Node 的语言基础 - JS（ES5、6、7、8）",headingTitle:"2案例一： [龟兔赛跑] Node 的语言基础 - JS（ES5、6、7、8）",frontmatter:{}}}}]);