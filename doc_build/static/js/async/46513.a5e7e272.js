"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["46513"],{79180:function(e,n,i){e.exports=i.p+"static/image/061d1dfb5a71613a600761a0351eb34e.5cce980a.webp"},233794:function(e,n,i){e.exports=i.p+"static/image/1731f116d1e56331372a0c8b6bda7c69.b3daa199.webp"},79063:function(e,n,i){e.exports=i.p+"static/image/202bc1e89e3de4230ad4e5bf947bf07d.5e62f610.gif"},64171:function(e,n,i){e.exports=i.p+"static/image/3a6c96b7889b6af23a3ab55292e73af2.9cea7520.webp"},430337:function(e,n,i){e.exports=i.p+"static/image/4ac5af4dd7c5654665753f02f01e3345.c0c5be47.webp"},78444:function(e){e.exports="data:image/webp;base64,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"},191961:function(e,n,i){e.exports=i.p+"static/image/929276c66c97677b2d806c0faeb3dd56.634ed6e0.webp"},236095:function(e,n,i){e.exports=i.p+"static/image/9a0b777e27a8aa14d4072ec59dec58d7.072cfd29.webp"},327506:function(e,n,i){e.exports=i.p+"static/image/9d5cef933e8c3367a28145ebd8d7efb4.e48aedc6.webp"},856623:function(e,n,i){e.exports=i.p+"static/image/ac666485a5eb3e76a0c3bb603df022d0.7f74db4a.webp"},713255:function(e,n,i){e.exports=i.p+"static/image/b168eb89ca3abaf18d41d3d90da6217a.5f276282.webp"},929920:function(e,n,i){i.r(n),i.d(n,{default:()=>T});var s=i(552676),c=i(740453),r=i(64171),d=i(856623),o=i(191961),t=i(233794),l=i(236095),h=i(78444),x=i(79063),j=i(713255),a=i(327506),u=i(430337),m=i(79180);function p(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",code:"code",p:"p",h3:"h3",pre:"pre",blockquote:"blockquote",h4:"h4",strong:"strong",img:"img",em:"em",ol:"ol",li:"li"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"8-时序相关的异步-apitimersetimmediateprocessnexttick-与-queuemicrotask中",children:["8-时序相关的异步 API：Timer、setImmediate()、process.nextTick() 与 queueMicrotask()（中）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-时序相关的异步-apitimersetimmediateprocessnexttick-与-queuemicrotask中",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"nodejs-中的-settimeout",children:["Node.js 中的 ",(0,s.jsx)(n.code,{children:"setTimeout()"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中的-settimeout",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上一章中，我们讲了在 Node.js 中，",(0,s.jsx)(n.code,{children:"setTimeout()"})," 函数本质是创建一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例，并将其搞成链表推入一个 ",(0,s.jsx)(n.code,{children:"Map"})," 和一个优先队列中。在背后有且仅有一个定时器来推动 libuv 定期消费这些链表。"]}),"\n",(0,s.jsxs)(n.p,{children:["但是讲到最后，也就讲了这个流程，那么所谓的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例到底是什么呢？在消费链表的时候，实际上发生了什么事呢？我们上一章讲到了所谓的薅羊毛算法，或是珠宝店算法，那么进到某个羊圈或者珠宝店后，到底发生了什么呢？进入羊圈的逻辑就是在上一章中未详解的 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"})," 函数中。"]}),"\n",(0,s.jsxs)(n.h3,{id:"listontimeout",children:[(0,s.jsx)(n.code,{children:"listOnTimeout()"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#listontimeout",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我从",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L517-L588",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L517-L588",target:"_blank",rel:"noopener noreferrer",children:"该函数的源码"}),"中提取逻辑，保留主要逻辑以便分析。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  function listOnTimeout(list, now) {\n    const msecs = list.msecs;\n\n    let ranAtLeastOneTimer = false;\n    let timer;\n    while ((timer = L.peek(list)) != null) {\n      const diff = now - timer._idleStart;\n\n      // Check if this loop iteration is too early for the next timer.\n      // This happens if there are more timers scheduled for later in the list.\n      if (diff < msecs) {\n        list.expiry = MathMax(timer._idleStart + msecs, now + 1);\n        list.id = timerListId++;\n        timerListQueue.percolateDown(1);\n        debug('%d list wait because diff is %d', msecs, diff);\n        return;\n      }\n\n      if (ranAtLeastOneTimer)\n        runNextTicks();\n      else\n        ranAtLeastOneTimer = true;\n\n      // The actual logic for when a timeout happens.\n      L.remove(timer);\n\n      ...\n\n      let start;\n      if (timer._repeat)\n        start = getLibuvNow();\n\n      try {\n        const args = timer._timerArgs;\n        if (args === undefined)\n          timer._onTimeout();\n        else\n          ReflectApply(timer._onTimeout, timer, args);\n      } finally {\n        if (timer._repeat && timer._idleTimeout !== -1) {\n          timer._idleTimeout = timer._repeat;\n          insert(timer, timer._idleTimeout, start);\n        } else if (...) {\n          ...\n        }\n      }\n    }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面就是所谓的“进入一个羊圈，把能薅的羊全薅一遍”的过程。",(0,s.jsx)(n.code,{children:"list"})," 就是羊圈，",(0,s.jsx)(n.code,{children:"now"})," 就是当前 Tick 的时间。首先就是一个 ",(0,s.jsx)(n.code,{children:"while"})," 去不断从 ",(0,s.jsx)(n.code,{children:"list"})," 中获取首个元素。上一章我们也思考过了，由于时间一往无前的特性，任意一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的链表元素都是按时序插入的，所以肯定是越前面的元素越早过期——即这是一个有序链表。所以“不断从 ",(0,s.jsx)(n.code,{children:"list"})," 中获取首个元素”意味着按时间早晚顺序从链表中拿到对应的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"L.peek()"})," 就是从一个 ",(0,s.jsx)(n.code,{children:"list"})," 中获取首个元素。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"while"})," 每次循环中，先判断一下拿到的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例是否应被触发，即是否过期。如果没有过期，则进入 ",(0,s.jsx)(n.code,{children:"if"})," 分支。将该 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例对应的过期时间作为当前链表整体的过期时间，并重排优先队列。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.h4,{children:"IEEE754 的坑"}),"\n",(0,s.jsxs)(n.p,{children:["我们上一章中讲过，链表的 ",(0,s.jsx)(n.code,{children:"expiry"})," 为这条链表 ",(0,s.jsx)(n.code,{children:"Timeout"})," 最早过期时间。所以当下一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 没过期的时候，自然就会更新该值为对应 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的值，即："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"list.expiry = MathMax(timer._idleStart + msecs, now + 1);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可能大家会好奇，为什么 ",(0,s.jsx)(n.code,{children:"list.expiry"})," 不直接是 ",(0,s.jsx)(n.code,{children:"timer._idleStart + msecs"}),"，而是还要跟 ",(0,s.jsx)(n.code,{children:"now + 1"})," 进行一次最大值比较。",(0,s.jsx)(n.strong,{children:"其实之前的"})," ",(0,s.jsx)(n.strong,{children:"Node.js"})," ",(0,s.jsx)(n.strong,{children:"的确是直接这么写的，但这么写有问题。"})]}),"\n",(0,s.jsxs)(n.p,{children:["不知道大家有没有注意到，我之前给大家介绍这整段逻辑的时候，全程没有提过对 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 的第二个时间参数做过处理。也就是说，它可以是个浮点数。举个例子，",(0,s.jsx)(n.code,{children:"1.1 * 100"})," 在 JavaScript 并不是 ",(0,s.jsx)(n.code,{children:"110"}),"，而是 ",(0,s.jsx)(n.code,{children:"110.00000000000001"}),"。就是这么点细微的差别，有可能导致问题。"]}),"\n",(0,s.jsx)(n.p,{children:"比如下面这段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const time = 1.1 * 100;\nfunction exec(i) {\n  console.log(i);\n  setTimeout(exec, time, ++i);\n}\nexec(0);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们能看到这是一个一直 ",(0,s.jsx)(n.code,{children:"setTimeout(110.00000000000001)"})," 的例子。如果当前时间是 ",(0,s.jsx)(n.code,{children:"18"}),"，那么超时时间理论上是 ",(0,s.jsx)(n.code,{children:"18 + 110.00000000000001"})," ，即 ",(0,s.jsx)(n.code,{children:"128.00000000000001"}),"。实际上呢？大家不妨可以打开 Chrome 的控制台或者 Node.js 测试一下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["看吧！变成整数了！显然 JavaScript 的 IEEE754 浮点数并不靠谱。但是作为 Node.js 运行时，显然不能被这种不靠谱坑了。我们继续往下看，如果还是 Node.js 之前的逻辑，那么 ",(0,s.jsx)(n.code,{children:"list.expiry"})," 会被设置为 ",(0,s.jsx)(n.code,{children:"128"}),"。如果当前时间恰好是 ",(0,s.jsx)(n.code,{children:"128"}),"，在 ",(0,s.jsx)(n.code,{children:"processTimer()"})," 的时候会循环进该链表认为它“过期”了。但是进了链表 ",(0,s.jsx)(n.code,{children:"listOnTimer()"})," 后，",(0,s.jsx)(n.code,{children:"diff = now - timer._idleStart"})," 为 ",(0,s.jsx)(n.code,{children:"128 - 18"}),"，即 ",(0,s.jsx)(n.code,{children:"diff"})," 为 ",(0,s.jsx)(n.code,{children:"110"}),"。那这个时候 ",(0,s.jsx)(n.code,{children:"diff < mses"})," 显然是成立的（毕竟 ",(0,s.jsx)(n.code,{children:"110 < 110.00000000000001"}),"），会被认为“没过期”。"]}),"\n",(0,s.jsxs)(n.p,{children:["外层认为“过期了”，内层认为“没过期”。那么将 ",(0,s.jsx)(n.code,{children:"list.expiry"})," 原封不动地设置为该 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的过期时间的话会发生什么呢？退出该层 ",(0,s.jsx)(n.code,{children:"listOnTimer"})," 后，在 ",(0,s.jsx)(n.code,{children:"processTimer"})," 的下一次循环仍然会拿到这个 ",(0,s.jsx)(n.code,{children:"list"}),"，拿到后再判断仍然会认为其“过期了”。然后再进去，然后……\uD83E\uDD21 死循环了！"]}),"\n",(0,s.jsx)(n.p,{children:"这就相当于薅羊毛时候，在外面看羊毛长好了，进去一看发现是脏东西。再出去看，好像羊毛长好了，进去一看又是脏东西……"}),"\n",(0,s.jsxs)(n.p,{children:["于是，为了避免这种情况，Node.js 就手动往这个超时时间上加个一，反正一毫秒左右的误差很正常。即使是 Node.js 正常在跑，",(0,s.jsx)(n.code,{children:"setTimeout()"})," 本身也就没有那个精确度。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中 ",(0,s.jsx)(n.code,{children:"timerListQueue.percolateDown(1)"})," 的意思是，对优先队列第一个元素进行下滤操作。毕竟这个时候它的 ",(0,s.jsx)(n.code,{children:"expiry"})," 被修改了，不一定是最早过期的链表了，需要下滤以得到新的最早链表。下滤过后，退出该函数，回到之前的 ",(0,s.jsx)(n.code,{children:"processTimers()"}),"，进入下一个循环，即再拿出新的最早过期链表，并判断有没有过期，然后做后续逻辑……这就是薅羊毛薅到没有可薅之后的流程。"]}),"\n",(0,s.jsxs)(n.p,{children:["但若链表中当前 ",(0,s.jsx)(n.code,{children:"Timeout"})," 已过期，则是后面的逻辑了。先还是模拟一次 Tick，就如 ",(0,s.jsx)(n.code,{children:"processTimers()"})," 里面那样："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if (ranAtLeastOneTimer)\n  runNextTicks();\nelse\n  ranAtLeastOneTimer = true;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后将该 ",(0,s.jsx)(n.code,{children:"Timeout"})," 从链表中移除。接下去的整体逻辑就是去执行 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的 ",(0,s.jsx)(n.code,{children:"_onTimeout()"})," 方法，里面就是去执行用户侧传入 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 的第一个参数 ",(0,s.jsx)(n.code,{children:"callback"}),"，这就是 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 逻辑的最终归宿了，毕竟它的用处就是在多少时间后去执行第一个参数 ",(0,s.jsx)(n.code,{children:"callback"}),"。再之后就是 ",(0,s.jsx)(n.code,{children:"setInterval()"})," 逻辑（",(0,s.jsx)(n.code,{children:"timer._repeat"}),"）了，如果是 Repeat 的，则将 ",(0,s.jsx)(n.code,{children:"Timeout"})," 改期并通过 ",(0,s.jsx)(n.code,{children:"insert()"})," 重新插入链表、更新 ",(0,s.jsx)(n.code,{children:"Map"})," 和优先队列。"]}),"\n",(0,s.jsxs)(n.p,{children:["将 ",(0,s.jsx)(n.code,{children:"processTimers()"})," 和 ",(0,s.jsx)(n.code,{children:"listOnTimeout"})," 联立起来，去掉一些边角料逻辑，它的流程如下所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h3,{id:"timeout",children:[(0,s.jsx)(n.code,{children:"Timeout"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#timeout",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上一章，以及本章前文中，我们提了太多次的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 了。凡流程中，必出现 ",(0,s.jsx)(n.code,{children:"Timeout"}),"。这到底是个什么东西？它是 ",(0,s.jsx)(n.code,{children:"setTimeout()"}),"、",(0,s.jsx)(n.code,{children:"setInterval()"})," 的最终归宿，存储了定时器的一些元数据，如起始时间、过期间隔、过期回调函数等。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"class Timeout {\n  constructor(callback, after, args, isRepeat, isRefed) {\n    after *= 1; // Coalesce to number or NaN\n    if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n      if (after > TIMEOUT_MAX) {\n        process.emitWarning(`${after} does not fit into` +\n                            ' a 32-bit signed integer.' +\n                            '\\nTimeout duration was set to 1.',\n                            'TimeoutOverflowWarning');\n      }\n      after = 1; // Schedule on next tick, follows browser behavior\n    }\n\n    this._idleTimeout = after;\n    this._idlePrev = this;\n    this._idleNext = this;\n    this._idleStart = null;\n    // This must be set to null first to avoid function tracking\n    // on the hidden class, revisit in V8 versions after 6.2\n    this._onTimeout = null;\n    this._onTimeout = callback;\n    this._timerArgs = args;\n    this._repeat = isRepeat ? after : null;\n    this._destroyed = false;\n\n    if (isRefed)\n      incRefCount();\n    this[kRefed] = isRefed;\n\n    ...\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最开始是判断过期间隔的合法性，如果时间不合法，则强行将时间改为 ",(0,s.jsx)(n.code,{children:"1"}),"。然后就是将各种元数据信息放到成员变量中。这个 ",(0,s.jsx)(n.code,{children:"_onTimeout"}),"，我们可以看到，就是 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 时候传进来的回调函数。是不是就能跟上面的 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"})," 串联起来了？"]}),"\n",(0,s.jsxs)(n.p,{children:["上面的 ",(0,s.jsx)(n.code,{children:"isRepeat"})," 即该 ",(0,s.jsx)(n.code,{children:"Timeout"})," 是否重复执行。在上一章中，我们可以看到 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 将该值设置为 ",(0,s.jsx)(n.code,{children:"false"}),"，即不重复。而 ",(0,s.jsx)(n.code,{children:"setInterval()"})," 的代码与 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 几乎一样，唯一的区别就是该参数位传的是 ",(0,s.jsx)(n.code,{children:"true"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"timeoutref-与-timeoutunref",children:[(0,s.jsx)(n.code,{children:"timeout.ref()"})," 与 ",(0,s.jsx)(n.code,{children:"timeout.unref()"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#timeoutref-与-timeoutunref",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["还记得我们在上一章留了一手没有解释的内容吗？",(0,s.jsx)(n.code,{children:"uv_ref"})," 和 ",(0,s.jsx)(n.code,{children:"uv_unref"}),"。有兴趣的读者可返回去搜一下这个关键字，以及 ",(0,s.jsx)(n.code,{children:"timeoutInfo[0]"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"先来看文档："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["When called, requests that the Node.js event loop ",(0,s.jsx)(n.em,{children:"not"})," exit so long as the ",(0,s.jsx)(n.code,{children:"Timeout"})," is active. Calling ",(0,s.jsx)(n.code,{children:"timeout.ref()"})," multiple times will have no effect."]}),"\n",(0,s.jsxs)(n.p,{children:["By default, all ",(0,s.jsx)(n.code,{children:"Timeout"}),' objects are "ref\'ed", making it normally unnecessary to call ',(0,s.jsx)(n.code,{children:"timeout.ref()"})," unless ",(0,s.jsx)(n.code,{children:"timeout.unref()"})," had been called previously."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["就是说，如果 ",(0,s.jsx)(n.code,{children:"Timeout"})," 有被“引用”，则在没有其他让事件循环“长存”的条件下（如文件 I/O 等待、网络事件等待等），Node.js 的执行生命周期会被 ",(0,s.jsx)(n.code,{children:"Timeout"})," 撑着。否则，若没有其他“长存”条件，Node.js 会执行完当前 Tick 后，马上退出，并不会等 ",(0,s.jsx)(n.code,{children:"Timeout"})," 执行。"]}),"\n",(0,s.jsx)(n.p,{children:"举个最简单例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"console.log('start');\nconst timer = setTimeout(() => {\n  console.log('done');\n}, 100);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这段代码用 Node.js 跑，会先输出 ",(0,s.jsx)(n.code,{children:"start"}),"，然后在 100 毫秒之后，输出 ",(0,s.jsx)(n.code,{children:"done"}),"，然后 Node.js 退出。如果在第四行插入：",(0,s.jsx)(n.code,{children:"timer.unref()"}),"，则 Node.js 会在输出 ",(0,s.jsx)(n.code,{children:"start"})," 后，创建 ",(0,s.jsx)(n.code,{children:"Timeout"}),"，然后直接退出。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 libuv 中，就有 ",(0,s.jsx)(n.code,{children:"uv_ref()"})," 和 ",(0,s.jsx)(n.code,{children:"uv_unref()"})," 的概念。如果 libuv 中，不存在任何被 Reference 的句柄，就会退出事件循环。所以 ",(0,s.jsx)(n.code,{children:"uv_ref()"})," 是为了撑起其生命周期用的。"]}),"\n",(0,s.jsxs)(n.p,{children:["Node.js 中，用了一种非常规的方式，来做那个唯一的 C++ 侧定时器的 Reference 与 Unreference。首先，在 Node.js 的 ",(0,s.jsx)(n.code,{children:"Environment"})," 中，有一个 ",(0,s.jsx)(n.code,{children:"timeout_info_"})," 的 ",(0,s.jsx)(n.code,{children:"Int32Array"})," 的 JavaScript ",(0,s.jsx)(n.code,{children:"TypedArray"}),"。说是数组，实际上它就一个元素，",(0,s.jsx)(n.code,{children:"timeout_info_[0]"}),"。如果我们直接用一个 ",(0,s.jsx)(n.code,{children:"Number"})," 类型，那么在获取它、更改它的时候，要在 JavaScript 与 C++ 侧反复横跳，这是有开销的。而根据 V8 的特性，C++ 侧是可以直接访问 ",(0,s.jsx)(n.code,{children:"Int32Array"})," 指定下标的内容，获取的是原生 4 字节的整型内存，而 JavaScript 侧也可以直接操作该数组。这么一来，双方对其第 ",(0,s.jsx)(n.code,{children:"0"})," 个元素读取和操作都可直接进行，而不用切换上下文，少了些开销。"]}),"\n",(0,s.jsxs)(n.p,{children:["所以，虽然它是个 ",(0,s.jsx)(n.code,{children:"Int32Array"}),"，但 Node.js 却 Trick 地将其当作横跳 C++ 侧与 JavaScript 侧的一个 ",(0,s.jsx)(n.code,{children:"Number"})," 值。简而言之，你就简单粗暴地当 ",(0,s.jsx)(n.code,{children:"timeoutInfo[0]"})," 是一个 ",(0,s.jsx)(n.code,{children:"Number"})," 值用就好了。"]}),"\n",(0,s.jsxs)(n.p,{children:["这个值的用处是，记录所有 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例的 Reference 与 Unreference 累加的值。当该值为 ",(0,s.jsx)(n.code,{children:"0"})," 的时候，说明不再有 JavaScript 侧的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 需要被 Reference，那么 ",(0,s.jsx)(n.code,{children:"Environment"})," 中那个唯一的定时器可被 ",(0,s.jsx)(n.code,{children:"uv_unref()"}),"；否则就说明还有至少一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 被 Reference，生命周期需继续苦撑着。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的构造函数中，最后一个参数是 ",(0,s.jsx)(n.code,{children:"isRefed"}),"。",(0,s.jsx)(n.code,{children:"setTimeout()"})," 与 ",(0,s.jsx)(n.code,{children:"setInterval()"})," 中传的都是 ",(0,s.jsx)(n.code,{children:"true"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们看上面的构造函数代码，如果 ",(0,s.jsx)(n.code,{children:"isRefed"})," 为 ",(0,s.jsx)(n.code,{children:"true"}),"，会增加 Reference 的值（",(0,s.jsx)(n.code,{children:"incRefCount"}),"）。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function incRefCount() {\n  if (timeoutInfo[0]++ === 0)\n    toggleTimerRef(true);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里面做的事情就是，将 ",(0,s.jsx)(n.code,{children:"timeoutInfo[0]"})," 加一。若加一前其值为 ",(0,s.jsx)(n.code,{children:"0"}),"，意味着之前没有一个被 Reference 的 ",(0,s.jsx)(n.code,{children:"Timeout"}),"，所以从无到有，我们需要去 C++ 侧将唯一的定时器给 Reference（",(0,s.jsx)(n.code,{children:"toggleTimerRef(true)"}),"）。"]}),"\n",(0,s.jsxs)(n.p,{children:["根据上面的代码，易得 ",(0,s.jsx)(n.code,{children:"decRefCount()"})," 的代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function decRefCount() {\n  if (--timeoutInfo[0] === 0)\n    toggleTimerRef(false);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["对于一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的 ",(0,s.jsx)(n.code,{children:"ref"})," 和 ",(0,s.jsx)(n.code,{children:"unref"})," 函数，实际上就是",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L221-L237",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L221-L237",target:"_blank",rel:"noopener noreferrer",children:"调用上面这两个函数"}),"，只不过多了一些额外的判断和逻辑而已。"]}),"\n",(0,s.jsxs)(n.p,{children:["而在 C++ 侧的 ",(0,s.jsx)(n.code,{children:"toggleTimerRef()"})," 函数，它是调用 ",(0,s.jsx)(n.code,{children:"uv_ref()"})," 和 ",(0,s.jsx)(n.code,{children:"uv_unref()"})," 来达到最终目的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void Environment::ToggleTimerRef(bool ref) {\n  if (started_cleanup_) return;\n\n  if (ref) {\n    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));\n  } else {\n    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这是对于新建 ",(0,s.jsx)(n.code,{children:"Timeout"}),"、对 ",(0,s.jsx)(n.code,{children:"Timeout"})," 进行 ",(0,s.jsx)(n.code,{children:"ref()"})," 和 ",(0,s.jsx)(n.code,{children:"unref()"})," 操作的流程，这都是自然增删过程。而在定时器自然消耗（逐个过期）的过程来说，一样也是需要对其进行一定的 ",(0,s.jsx)(n.code,{children:"unref()"})," 操作的。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们回到上一章讲的 ",(0,s.jsx)(n.code,{children:"processTimers()"})," 函数，我们曾经讲过 ",(0,s.jsx)(n.code,{children:"nextExpiry"})," 的正负问题：",(0,s.jsx)(n.strong,{children:"这个事情不在主干上，不重要，暂且不提"}),"。不过也还是提了一嘴，实际上在 C++ 侧的 ",(0,s.jsx)(n.code,{children:"RunTimers()"})," 中始终用的是该值的绝对值，所以正负只是一个简易的判断标识，用于判断是否需要对 libuv 进行 Reference 或者 Unreference 操作。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if (list.expiry > now) {\n  nextExpiry = list.expiry;\n  return timeoutInfo[0] > 0 ? nextExpiry : -nextExpiry;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["什么意思呢？当我们链表跑完了，剩下的都是没过期的 ",(0,s.jsx)(n.code,{children:"Timeout"}),"，那么我们要告知 C++ 侧下一次的过期时间，以便其重设定时器。由于我们跑完了一堆的 ",(0,s.jsx)(n.code,{children:"Timeout"}),"，跑完的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 自然将 ",(0,s.jsx)(n.code,{children:"timeoutInfo[0]"})," 的值排除自身，这个时候要看剩下的 ",(0,s.jsx)(n.code,{children:"timeoutInfo[0]"})," 的值是否还存在至少一个被 Reference 的 ",(0,s.jsx)(n.code,{children:"Timeout"}),"。若存在，则返回正的 ",(0,s.jsx)(n.code,{children:"nextExpiry"}),"；否则返回负值。"]}),"\n",(0,s.jsx)(n.p,{children:"看看 C++ 侧怎么用这个返回值吧。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  if (expiry_ms != 0) {\n    int64_t duration_ms =\n        llabs(expiry_ms) - (uv_now(env->event_loop()) - env->timer_base());\n\n    env->ScheduleTimer(duration_ms > 0 ? duration_ms : 1);\n\n    if (expiry_ms > 0)\n      uv_ref(h);\n    else\n      uv_unref(h);\n  } else {\n    uv_unref(h);\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在用的时候，通过 ",(0,s.jsx)(n.code,{children:"llabs()"})," 对这个返回值取绝对值。也就是说用过期值的时候，总用其绝对值（即真实过期时间）。而正负符号则用于判断是否需要 ",(0,s.jsx)(n.code,{children:"uv_ref()"})," 或 ",(0,s.jsx)(n.code,{children:"uv_unref()"}),"。如果返回值是 ",(0,s.jsx)(n.code,{children:"0"}),"，则意味着没有更多 ",(0,s.jsx)(n.code,{children:"Timeout"})," 了，那么直接 ",(0,s.jsx)(n.code,{children:"uv_unref()"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["在前面的 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"})," 函数中，我省略了执行 ",(0,s.jsx)(n.code,{children:"timer._onTimeout()"})," 之后，判断其是否被 Reference 的逻辑。若其被 Reference，则执行完后，",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L579-L580",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/timers.js#L579-L580",target:"_blank",rel:"noopener noreferrer",children:"会将 timeoutInfo[0] 减一"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"小插曲时序问题可以怎么解",children:["小插曲：时序问题可以怎么解？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小插曲时序问题可以怎么解",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们在上一章中还留了个问题代码。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"'use strict';\n\nsetTimeout(() => {\n  console.log(1);\n}, 10);\nsetTimeout(() => {\n  console.log(2);\n}, 15);\nlet now = Date.now();\nwhile (Date.now() - now < 100) {\n  //\n}\nsetTimeout(() => {\n  console.log(3);\n}, 10);\nnow = Date.now();\nwhile (Date.now() - now < 100) {\n  //\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在当前 Node.js 版本（如 v18.14.1）中，上面这个问题代码的结果是 ",(0,s.jsx)(n.code,{children:"1"}),"、",(0,s.jsx)(n.code,{children:"3"}),"、",(0,s.jsx)(n.code,{children:"2"}),"。原因也解释过了，薅羊毛薅到秃噜皮。用顺序箭头图展示，如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，过期时刻为 ",(0,s.jsx)(n.code,{children:"205"})," 的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 居然比 ",(0,s.jsx)(n.code,{children:"35"})," 的早执行。这显然不合理。合理的顺序箭头图应该如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["前者是",(0,s.jsx)(n.strong,{children:"薅羊毛薅到死"}),"，后者是",(0,s.jsx)(n.strong,{children:"反复横跳"}),"。假设你是一个 Node.js 的贡献者，想想我们之前讲解的 ",(0,s.jsx)(n.code,{children:"processTimers()"})," 和 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"}),"，先不论性能如何，我们可以怎么改让其恢复逻辑正常？"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:"9150e4e5gy1g63ilh1p83g203c03naa2.gif"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"毕竟由薅到死变成反复横跳，切换和性能肯定是有额外开销的，性能肯定会劣化。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"其实做这个改造，在逻辑上的方案很简单："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["在每次 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"})," 最开始，都先获取第二超时的链表；"]}),"\n",(0,s.jsxs)(n.li,{children:["在 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"})," 循环中，每次 ",(0,s.jsx)(n.code,{children:"Timeout"})," 除了判断是否没过期，再额外判断一下与第二超时链表谁会先到期，若是第二链表先到期，则重排优先队列后退出 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["就这两步，就可以将上面第一张图变成第二张图了。比如第二张图中，",(0,s.jsx)(n.code,{children:"10ms"})," 的 ",(0,s.jsx)(n.code,{children:"21"})," 执行完了，接下去是 ",(0,s.jsx)(n.code,{children:"205"}),"，这个时候 ",(0,s.jsx)(n.code,{children:"205"})," 与第二链表过期时间 ",(0,s.jsx)(n.code,{children:"35"})," 比较。发现比不过，就更新链表过期时间为 ",(0,s.jsx)(n.code,{children:"205"}),"，重排优先队列，这个时候 ",(0,s.jsx)(n.code,{children:"20ms"})," 就跑第一位来了，接下去就执行 ",(0,s.jsx)(n.code,{children:"20ms"})," 的第一个元素 ",(0,s.jsx)(n.code,{children:"35"}),"，然后 ",(0,s.jsx)(n.code,{children:"67"})," 时候发现比不过 ",(0,s.jsx)(n.code,{children:"30ms"})," 的 ",(0,s.jsx)(n.code,{children:"36"}),"，以此类推……最终达成了 ",(0,s.jsx)(n.code,{children:"10ms"}),"→",(0,s.jsx)(n.code,{children:"20ms"}),"→",(0,s.jsx)(n.code,{children:"30ms"}),"→",(0,s.jsx)(n.code,{children:"20ms"}),"→",(0,s.jsx)(n.code,{children:"10ms"})," 的反复横跳。"]}),"\n",(0,s.jsx)(n.p,{children:"现在的问题在于，如何获取第二超时的链表呢？优先队列的本质是一个二叉堆，我们只能保证堆顶元素是最小的。那第二小的怎么获取？"}),"\n",(0,s.jsx)(n.p,{children:"我们看看以最小值为优先的优先队列的二叉堆是按什么规则排列的：父元素总比子元素小。比如这就是一个优先队列可能的内部结构："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["堆顶是 ",(0,s.jsx)(n.code,{children:"3"}),"，子节点 ",(0,s.jsx)(n.code,{children:"4"}),"、",(0,s.jsx)(n.code,{children:"5"})," 均比 ",(0,s.jsx)(n.code,{children:"3"})," 小；",(0,s.jsx)(n.code,{children:"4"})," 的子节点 ",(0,s.jsx)(n.code,{children:"6"}),"、",(0,s.jsx)(n.code,{children:"8"})," 也比 ",(0,s.jsx)(n.code,{children:"4"})," 小。当然，把 ",(0,s.jsx)(n.code,{children:"6"})," 挪到 ",(0,s.jsx)(n.code,{children:"5"})," 的子节点，也是一个合法的优先队列。只要满足上面那个条件，怎么排列无所谓。如果我们在堆尾插入一个 ",(0,s.jsx)(n.code,{children:"2"}),"，就会是这样的："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["然后对堆尾进行滤上操作，",(0,s.jsx)(n.code,{children:"2"})," 比 ",(0,s.jsx)(n.code,{children:"5"})," 小，要把 ",(0,s.jsx)(n.code,{children:"5"})," 换下来。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["然后 ",(0,s.jsx)(n.code,{children:"2"})," 比 ",(0,s.jsx)(n.code,{children:"3"})," 小，再换。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["这个时候，",(0,s.jsx)(n.code,{children:"2"})," 就处于堆顶了。",(0,s.jsx)(n.code,{children:"3"})," 变成了这个优先队列的第二小元素。由于这是一本《趣学 Node.js》小册，而非《趣学算法》《趣学数据结构》，更多关于优先队列的信息，大家可自行去网上学习，这里点到为止。"]}),"\n",(0,s.jsxs)(n.p,{children:["根据优先队列的二叉堆性质，我们很容易判断出堆顶元素是最小元素，即优先队列每次都是从这儿取。而其两个子节点都是比堆顶元素大的，但是它们各自又比各自的子节点们小。虽然可能会有右子节点比左子节点大，也有可能比左子节点的所有子节点都大，但至少它比自己的子节点小。所以光判断第二小元素还是很容易的，只要判断堆顶节点的两个子节点谁小，谁就是第二小了。",(0,s.jsx)(n.strong,{children:"它们俩其中一个肯定是第二小的，但是另一个则不一定第三小。"})]}),"\n",(0,s.jsx)(n.p,{children:"这就相当于，堆顶肯定是龙头。然后左右子节点中肯定是有一个凤头，带着一帮凤小弟。另一个虽然也带了一帮比它菜的小弟，但它不一定比凤小弟厉害——人才梯队问题，他们只是各自人才梯队里面顶尖的，但是有可能只是个鸡头，比不上凤尾。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["解决了第二超时链表问题，一切就简单了。先打开 Node.js 的",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/priority_queue.js",title:"https://github.com/nodejs/node/blob/v18.14.1/lib/internal/priority_queue.js",target:"_blank",rel:"noopener noreferrer",children:"优先队列源码"}),"。可以看到它内部用一个数组模拟了堆。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"class PriorityQueue {\n  #compare = (a, b) => a - b;\n  #heap = new Array(64);\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["堆初始大小为 ",(0,s.jsx)(n.code,{children:"64"}),"。与平常使用数组不一样，优先队列通常用堆的 ",(0,s.jsx)(n.code,{children:"1"})," 下标作为根节点，在此处即为 ",(0,s.jsx)(n.code,{children:"#heap[1]"}),"。然后每个节点左右子节点下标分别为父节点乘二，以及乘二加一。也就是说，根节点子节点的下标分别为 ",(0,s.jsx)(n.code,{children:"2"}),"、",(0,s.jsx)(n.code,{children:"3"}),"。要取第二元素的值，相当于判断 ",(0,s.jsx)(n.code,{children:"2"}),"、",(0,s.jsx)(n.code,{children:"3"})," 下标元素哪个小。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以为其补一个 ",(0,s.jsx)(n.code,{children:"secondary()"})," 方法："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  secondary() {\n    // As the priority queue is a binary heap, the secondary element is\n    // always the second or third element in the heap.\n    switch (this.#size) {\n      case 0:\n      case 1:\n        return undefined;\n\n      case 2:\n        return this.#heap[2] === undefined ? this.#heap[3] : this.#heap[2];\n\n      default:\n        return this.#compare(this.#heap[2], this.#heap[3]) < 0 ?\n          this.#heap[2] :\n          this.#heap[3];\n    }\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里 ",(0,s.jsx)(n.code,{children:"#compare"})," 函数为比较两个元素大小的函数，默认情况下为直接判断数值大小。然而在 ",(0,s.jsx)(n.code,{children:"Timeout"})," 中，是不能直接这么判断的。所以针对 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的 ",(0,s.jsx)(n.code,{children:"#compare"})," 函数是判断其过期时间这些的。"]}),"\n",(0,s.jsxs)(n.p,{children:["可以看到，上面这个 ",(0,s.jsx)(n.code,{children:"secondary()"})," 函数做了一些边界判断，如没有任何元素、只有一个元素以及只有两个元素的时候，应该如何返回。然后剩下的情况就按我之前讲的这种方式判断。"]}),"\n",(0,s.jsxs)(n.p,{children:["有了 ",(0,s.jsx)(n.code,{children:"secondary()"})," 函数后，我们只需要在 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"})," 中做点手脚就好了。假设你是 Node.js 贡献者，可以在 ",(0,s.jsx)(n.code,{children:"diff < msecs"})," 的判断上做手脚，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"...\nconst secondaryList = timerListQueue.secondary();\nwhile ((timer = L.peek(list)) != null) {\n  ...\n  if (diff < msecs || secondaryList?.expiry < timer._idleStart + msecs) {\n    ...原逻辑\n  }\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上，我们只需要在判断 ",(0,s.jsx)(n.code,{children:"diff < msecs"})," 这里多加一个或的条件判断即可，判断它是否大于第二链表的超时时间，如果大于了，就重排优先队列并开始横跳。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.h4,{children:(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/pull/46644",title:"https://github.com/nodejs/node/pull/46644",target:"_blank",rel:"noopener noreferrer",children:"PR #46644"})}),"\n",(0,s.jsx)(n.p,{children:"实际上，自我在上一章发现了这个问题后，就提交了这个小插曲的 PR 了。的确性能有些许劣化，在我的 MacBook M1 上，Benchmark 粗略跑了一下如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// 原逻辑\ntimers/timers-timeout-unpooled.js n=1000000: 19,307,131.535027202\n\n// PR 逻辑\ntimers/timers-timeout-unpooled.js n=1000000: 19,102,850.664916743\n"})}),"\n",(0,s.jsx)(n.p,{children:"不过，对于正确性来说，我个人认为这个劣化在可接受范围。 最终 PR 合并不合并还得看其他 TSC 或者 Collaborator 的 Review。若没通过也无所谓，为你们讲解的目的也达到了；若最终通过了，那么上一章关于这一块的薅羊毛算法就会成为历史，从而变成新的反复横跳法。但是大家多了解了解历史问题也挺好的。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上一章中，我们讲了 ",(0,s.jsx)(n.code,{children:"Timeout"})," 优先队列是如何访问并触发的，并提出薅羊毛算法和珠宝店算法。而本章中，我们介绍了真进到羊圈后，里面发生的逻辑，如何逐一将羊毛薅秃噜皮的。在这里面为大家避开了一个 IEEE754 的坑。很多人总以为这是 JavaScript 的数字体系不好，实际上这要怪 IEEE754，并非 ECMAScript。更多关于这块浮点数的内容，大家也可以去看看网上的资料，或者阅读一下《",(0,s.jsx)(n.a,{href:"https://book.douban.com/subject/35469273/",title:"https://book.douban.com/subject/35469273/",target:"_blank",rel:"noopener noreferrer",children:"JavaScript 悟道"}),"》。"]}),"\n",(0,s.jsxs)(n.p,{children:["在上一章，还遗留了一个“不重要、暂且不提”的 ",(0,s.jsx)(n.code,{children:"uv_ref()"})," 与 ",(0,s.jsx)(n.code,{children:"uv_unref()"}),"，在本章中也为大家描述清楚了其用途，以及它与 ",(0,s.jsx)(n.code,{children:"timer"})," 中的 ",(0,s.jsx)(n.code,{children:"timer.ref()"}),"、",(0,s.jsx)(n.code,{children:"timer.unref()"})," 的关系。"]}),"\n",(0,s.jsx)(n.p,{children:"最后，来了一个小插曲，以身试法，以贡献者的思路，一步步解析我们可以如何分析问题，并且通过怎么样的修改，能解决上一章中遗留的时序问题。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}let T=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F8-%E6%97%B6%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BC%82%E6%AD%A5%20API%EF%BC%9ATimer%E3%80%81setImmediate()%E3%80%81process.nextTick()%20%E4%B8%8E%20queueMicrotask()%EF%BC%88%E4%B8%AD%EF%BC%89.md"]={toc:[{text:"Node.js 中的 `setTimeout()`",id:"nodejs-中的-settimeout",depth:2},{text:"`listOnTimeout()`",id:"listontimeout",depth:3},{text:"`Timeout`",id:"timeout",depth:3},{text:"`timeout.ref()` 与 `timeout.unref()`",id:"timeoutref-与-timeoutunref",depth:3},{text:"小插曲：时序问题可以怎么解？",id:"小插曲时序问题可以怎么解",depth:3},{text:"小结",id:"小结",depth:2}],title:"8-时序相关的异步 API：Timer、setImmediate()、process.nextTick() 与 queueMicrotask()（中）",headingTitle:"8-时序相关的异步 API：Timer、setImmediate()、process.nextTick() 与 queueMicrotask()（中）",frontmatter:{}}}}]);