"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["94736"],{581682:function(e,n,t){t.r(n),t.d(n,{default:()=>j});var r=t(552676),s=t(740453);let d=t.p+"static/image/5d66ded8c3714a72b74437442182f545.67f287be.webp",c=t.p+"static/image/f9330b0708192097da92cb26574742f1.225902b5.webp",i=t.p+"static/image/9cf5b46573f930f75fe02129e4d8314c.d10ba0e8.webp",l=t.p+"static/image/1c6bff85fd2294ecd6a483005e921a84.0ba52803.webp",a=t.p+"static/image/6efec05e1bb84a86c25d856ac99e3f7c.38e80efa.webp",h=t.p+"static/image/44d8de0d55772b89351d6e69d1c3597f.efd9c23d.webp",p=t.p+"static/image/516db5a9d455d055575def30ef00195f.311e4431.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",img:"img",pre:"pre",strong:"strong",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"12-语法篇--客户端-api-与服务端-api",children:["12-语法篇 ❘ 客户端 API 与服务端 API",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-语法篇--客户端-api-与服务端-api",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"本篇推荐学习指数：⭐️️"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"通常 Svelte 项目我们会使用官方脚手架 SvelteKit 进行开发，所以不会用到这些内容，本篇简单看一下了解即可。"}),"\n",(0,r.jsxs)(n.h2,{id:"2-客户端-api",children:["2. 客户端 API",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-客户端-api",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["当我们导入一个 ",(0,r.jsx)(n.code,{children:".svelte"})," 模块的时候，导入的其实是一个组件类："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们该如何使用这个组件类呢？这就是 Svelte 客户端 API 要介绍的内容。"}),"\n",(0,r.jsx)(n.p,{children:"如果我们使用的是 SvelteKit，基本不需要使用客户端 API。但如果是借助其他构建工具从头构建 Svelte 项目脚手架，则有可能会用到，比如使用 vite 创建一个 Svelte 的项目："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"npm create vite@latest\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们选择 Svelte 框架和 JavaScript 语法："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注：Svelte 项目并不建议使用 Vite 创建，因为这个模板的很多东西比如路由都需要自己从头实现，最好还是使用 SvelteKit，这里是为了方便客户端 API 的演示"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"创建的项目目录结构如下（做了部分精简）："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"vite-svelte\n├─ src\n│  ├─ lib\n│  │  └─ Counter.svelte\n│  ├─ App.svelte\n│  ├─ app.css\n│  └─ main.js\n├─ index.html\n├─ jsconfig.json\n├─ package.json\n├─ svelte.config.js\n└─ vite.config.js\n"})}),"\n",(0,r.jsx)(n.p,{children:"这个项目是如何运行起来的呢？"}),"\n",(0,r.jsxs)(n.p,{children:["首先 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 引入了 ",(0,r.jsx)(n.code,{children:"svelte"})," 插件，负责编译 ",(0,r.jsx)(n.code,{children:".svelte"})," 模块："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { defineConfig } from "vite";\nimport { svelte } from "@sveltejs/vite-plugin-svelte";\n\nexport default defineConfig({\n  plugins: [svelte()],\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["然后查看",(0,r.jsx)(n.code,{children:"main.js"})," 的代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { mount } from 'svelte'\nimport './app.css'\nimport App from './App.svelte'\n\nconst app = mount(App, {\n  target: document.getElementById('app'),\n})\n\nexport default app\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"main.js"})," 中引入主要的 ",(0,r.jsx)(n.code,{children:"App.svelte"})," 模块，调用 Svelte 提供的 ",(0,r.jsx)(n.code,{children:"mount"})," 函数，通过 ",(0,r.jsx)(n.code,{children:"target"})," 属性指定挂载的位置，然后导出该组件实例。"]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"index.html"}),"中引入打包后的 ",(0,r.jsx)(n.code,{children:"main.js"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + Svelte</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script type="module" src="/src/main.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsx)(n.p,{children:"简而言之：vite 负责打包编译 svelte 模块，main.js 引入 svelte 模块并进行实例化，index.html 引入 main.js"}),"\n",(0,r.jsxs)(n.p,{children:["当然我们并不是要讲解如何从头构建一个 Svelte 项目，而是借这个例子说明 ",(0,r.jsx)(n.strong,{children:"Svelte 客户端 API 要解决的问题是如何在正常的 JavaScript 文件中使用 Svelte 模块"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"21-mount创建组件",children:["2.1. mount：创建组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-mount创建组件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果创建并挂载一个组件呢？在 Svelte 4 中 ，是通过 new 的方式"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import App from './App.svelte'; \nconst app = new App({ target: document.body });\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 Svelte 5 中，统一改成了函数的形式："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { mount } from 'svelte'; \nimport App from './App.svelte'; \nconst app = mount(App, { target: document.querySelector('#app'), props: { some: 'property' } });\n"})}),"\n",(0,r.jsx)(n.p,{children:"除了 target，还有以下选项："}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{align:"center",children:"选项"}),"\n",(0,r.jsx)(n.th,{align:"center",children:"默认"}),"\n",(0,r.jsx)(n.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"target"})}),"\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"none"})}),"\n",(0,r.jsx)(n.td,{children:"必须，组件要挂载的位置"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"anchor"})}),"\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"null"})}),"\n",(0,r.jsx)(n.td,{children:"该元素必须是 target 的子级，组件会挂载在该元素之前"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"props"})}),"\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"{}"})}),"\n",(0,r.jsx)(n.td,{children:"传递给组件的属性"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"context"})}),"\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"new Map()"})}),"\n",(0,r.jsx)(n.td,{children:"传递给组件的上下文"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"intro"})}),"\n",(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.code,{children:"false"})}),"\n",(0,r.jsx)(n.td,{children:"当为 true 的时候，会在组件初始化的时候播放过渡动画"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"与 React 不同，当进行挂载的时候，target 的现有子级会保留在原处。"}),"\n",(0,r.jsx)(n.p,{children:"为了体会这些选项的作用，我们可以写一个简单的例子。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"index.html"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + Svelte</title>\n  </head>\n  <body>\n    <div id="app">\n      <div id="header">Header</div>\n      <div id="footer">\n        <button id="destroy">destroy</button>\n      </div>\n    </div>\n    <script type="module" src="/src/main.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"src/main.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { mount } from "svelte";\nimport "./app.css";\nimport App from "./App.svelte";\n\nconst app = mount(App, {\n  target: document.getElementById("app"),\n  anchor: document.getElementById("footer"),\n  props: {\n    counter: 10,\n  },\n  context: new Map([["theme", "dark"]]),\n  intro: true,\n});\n\nexport default app;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"src/App.svelte"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<script>\n  import { getContext } from "svelte";\n  import { fade } from "svelte/transition";\n  export let counter;\n\n  const theme = getContext("theme");\n<\/script>\n\n当前主题：{theme}\n\n<div transition:fade|global={{ delay: 250, duration: 1000 }}>\n  <button\n    on:click={() => {\n      counter += 1;\n    }}>+</button\n  >\n  {counter}\n  <button\n    on:click={() => {\n      counter -= 1;\n    }}>-</button\n  >\n</div>\n'})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个例子演示了除 hydrate 之外所有属性的用法。因为设置了 anchor，所以组件挂载在 Footer 之前。因为设置了 context，所以能在组件中通过 getContext 获取主题的值。因为设置了 props，所以组件能够获取该值并设置 计数器的初始值。因为设置了 intro，所以组件初始化的时候也有过渡动画。"}),"\n",(0,r.jsxs)(n.h3,{id:"22-unmount卸载组件",children:["2.2. unmount：卸载组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-unmount卸载组件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"从 DOM 中删除组件，并触发 onDestroy 监听器。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"main.js"}),"，添加如下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { mount, unmount } from "svelte";\n\ndocument.getElementById("destroy").addEventListener("click", () => {\n  unmount(app);\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"3-服务端-api",children:["3. 服务端 API",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-服务端-api",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Svelte 服务端 API 也有 2 个：render 和 hydrate"}),"\n",(0,r.jsxs)(n.h3,{id:"31-render渲染组件",children:["3.1. render：渲染组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-render渲染组件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"render 的用法如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"import { render } from 'svelte/server'; import App from './App.svelte'; const result = render(App, { props: { some: 'property' } }); result.body; // HTML for somewhere in this\n<body>\n  tag result.head; // HTML for somewhere in this\n  <head>\n    tag\n  </head>\n</body>\n"})}),"\n",(0,r.jsx)(n.p,{children:"服务端组件的主要工作就是渲染对应的 HTML 和 CSS。它会返回一个带有 head、html 和 css 属性的对象。"}),"\n",(0,r.jsx)(n.p,{children:"比如 Svelte 模块的代码为："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<script>\n  export let counter = 10;\n<\/script>\n\n<svelte:head>\n  <title>Hello Counter!</title>\n  <meta name="description" content="This is a Counter Example" />\n</svelte:head>\n\n<div>\n  <button on:click={()=> { counter += 1}}>+</button>\n  {counter}\n  <button on:click={()=> { counter -= 1}}>-</button>\n</div>\n\n<style>\n  button {\n    color: red\n  }\n</style>\n'})}),"\n",(0,r.jsx)(n.p,{children:"它会返回这样一个对象："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"render 方法也支持参数，目前有 2 个，一个是 props 一个是 options。options 中目前只有 context。示例用法如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"const { head, html, css } = App.render(\n  // props\n  { answer: 42 },\n  // options\n  {\n    context: new Map([['context-key', 'context-value']])\n  }\n);\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"32-hydrate水合组件",children:["3.2. hydrate：水合组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-hydrate水合组件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"hydrate 的用法如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"import { hydrate } from 'svelte'; \nimport App from './App.svelte'; \nconst app = hydrate(App, { target: document.querySelector('#app'), props: { some: 'property' } });\n"})}),"\n",(0,r.jsx)(n.p,{children:"所谓水合就是为 DOM 元素添加事件的过程。hydrate 通常搭配服务端渲染一起使用，Svelte 会对现有 DOM 进行水合，而非重新创建 DOM 元素。"}),"\n",(0,r.jsx)(n.p,{children:"为了直观的感受服务端 API 的作用。我们再用 Vite 创建一个 SSR Svelte 项目。运行："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm create vite@latest\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但是这次不直接选择 ",(0,r.jsx)(n.code,{children:"Svelte"}),"，而是选择 ",(0,r.jsx)(n.code,{children:"Others"}),"，然后再选择 ",(0,r.jsx)(n.code,{children:"create-vite-extra"}),"，最后选择 ",(0,r.jsx)(n.code,{children:"ssr-svelte"})," 创建项目。"]}),"\n",(0,r.jsx)(n.p,{children:"创建后的项目目录如下（做了部分精简）："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"vite-svelte-ssr\n├─ src\n│  ├─ lib\n│  │  └─ Counter.svelte\n│  ├─ App.svelte\n│  ├─ entry-client.js\n│  ├─ entry-server.js\n├─ index.html\n├─ server.js\n├─ svelte.config.js\n└─ vite.config.js\n"})}),"\n",(0,r.jsx)(n.p,{children:"那这个项目又是如何运行起来的呢？"}),"\n",(0,r.jsxs)(n.p,{children:["为了方便理解，首先修改 ",(0,r.jsx)(n.code,{children:"src/App.svelte"}),"的代码为："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { getContext } from 'svelte';\n  export let counter;\n  const theme = getContext('theme');\n<\/script>\n\n<svelte:head>\n  <title>Hello Counter!</title>\n  <meta name=\"description\" content=\"This is a Counter Example\" />\n</svelte:head>\n\n当前主题：{theme}\n\n<div>\n  <button on:click={()=> { counter += 1}}>+</button>\n  {counter}\n  <button on:click={()=> { counter -= 1}}>-</button>\n</div>\n\n<style>\n  button {\n    color: red\n  }\n</style>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后查看 ",(0,r.jsx)(n.code,{children:"src/entry-server.js"})," 的代码并修改为："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'import { render as _render } from "svelte/server";\nimport App from "./App.svelte";\n\nexport function render() {\n  return _render(App, {\n    props: { counter: 10 },\n    context: new Map([["theme", "dark"]]),\n  });\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["再然后查看 ",(0,r.jsx)(n.code,{children:"server.js"}),"的代码，为了方便理解，代码做了精简："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'app.use("*", async (req, res) => {\n\n  let template = await fs.readFile(\'./dist/client/index.html\', \'utf-8\');\n  let render = (await import("./dist/server/entry-server.js")).render;\n\n  const rendered = await render();\n\n  const html = template\n    .replace(`\x3c!--app-head--\x3e`, rendered.head ?? "")\n    .replace(`\x3c!--app-html--\x3e`, rendered.html ?? "");\n\n  res.status(200).set({ "Content-Type": "text/html" }).send(html);\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，我们导入了",(0,r.jsx)(n.code,{children:"entry-server.js"}),"导出的 render 函数，",(0,r.jsx)(n.code,{children:"await render()"}),"返回一个具有 html、head、css 属性的对象，然后通过 ",(0,r.jsx)(n.code,{children:"template.replace"})," 简单粗暴的得到最终渲染的 HTML 内容。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们可以打印看下 ",(0,r.jsx)(n.code,{children:"rendered"})," 变量的内容："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["再然后查看 ",(0,r.jsx)(n.code,{children:"src/entry-client.js"}),"的代码并修改为："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'import "./app.css";\nimport { hydrate } from "svelte";\nimport App from "./App.svelte";\n\nhydrate(App, {\n  target: document.querySelector("#app"),\n  props: {\n    counter: 10,\n  },\n  context: new Map([["theme", "dark"]]),\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"注意在这里我们的 hydrate 要设置为 true，这是因为之前我们已经通过服务端渲染出了最终的 DOM，无须再重新创建 DOM，直接进行水合即可。"}),"\n",(0,r.jsxs)(n.p,{children:["最后查看 ",(0,r.jsx)(n.code,{children:"vite-svelte-ssr/index.html"}),"的代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + Svelte</title>\n    \x3c!--app-head--\x3e\n  </head>\n  <body>\n    <div id="app">\x3c!--app-html--\x3e</div>\n    <script type="module" src="/src/entry-client.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这只是最一开始的 HTML 模板，server.js 会将组件进行服务端渲染，并将该 HTML 替换为最终的 HTML。然后访问该 HTML 的时候，因为引入了 ",(0,r.jsx)(n.code,{children:"entry-client.js"}),"，在 ",(0,r.jsx)(n.code,{children:"entry-client.js"}),"中，我们对 DOM 进行了水合，因此 Svelte 模块正常运行。"]}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"4-最后",children:["4. 最后",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-最后",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"看到这里，那么恭喜你完成了第一阶段 —— Svelte 5 的语法学习 \uD83C\uDF89 接下来我们进入 Svelte 官方脚手架 SvelteKit 的学习。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F12-%E8%AF%AD%E6%B3%95%E7%AF%87%20%E2%9D%98%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20API%20%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%20API.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. 客户端 API",id:"2-客户端-api",depth:2},{text:"2.1. mount：创建组件",id:"21-mount创建组件",depth:3},{text:"2.2. unmount：卸载组件",id:"22-unmount卸载组件",depth:3},{text:"3. 服务端 API",id:"3-服务端-api",depth:2},{text:"3.1. render：渲染组件",id:"31-render渲染组件",depth:3},{text:"3.2. hydrate：水合组件",id:"32-hydrate水合组件",depth:3},{text:"4. 最后",id:"4-最后",depth:2}],title:"12-语法篇 ❘ 客户端 API 与服务端 API",headingTitle:"12-语法篇 ❘ 客户端 API 与服务端 API",frontmatter:{}}}}]);