"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["72871"],{77310:function(e,n,d){d.r(n),d.d(n,{default:()=>j});var c=d(552676),r=d(740453);let s=d.p+"static/image/7da0a5637a25581c300882b18203f4c9.0cb9e90f.webp",o=d.p+"static/image/cb01ec0fb12595581e83b0f69737bfc8.d7d199be.webp",i=d.p+"static/image/fbc35115b092fe090636a02b288a0c63.039019a5.webp",l=d.p+"static/image/d6e7d9dca5c2097543b6bb1b3f46da31.1eb69452.webp",t=d.p+"static/image/db51b077dfe556a1067d01da1c399c6a.d8394727.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",img:"img",blockquote:"blockquote",pre:"pre",ul:"ul",li:"li",del:"del",h4:"h4"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"8vue3-之生命周期钩子函数提供注入",children:["8.Vue3 之生命周期钩子函数、提供注入",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8vue3-之生命周期钩子函数提供注入",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["世间万物都有生死轮回，",(0,c.jsx)(n.code,{children:"Vue"})," 同样也有属于自己的生命周期。"]}),"\n",(0,c.jsxs)(n.p,{children:["本章节通过对比 ",(0,c.jsx)(n.code,{children:"Vue2"})," 和 ",(0,c.jsx)(n.code,{children:"Vue3"})," 的生命周期，来更好的理解 ",(0,c.jsx)(n.code,{children:"Vue 3"})," 的生命周期，以便日后写业务代码时，不会犯一些低级错误。"]}),"\n",(0,c.jsxs)(n.h2,{id:"vue-2-生命周期解读",children:["Vue 2 生命周期解读",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-2-生命周期解读",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们首先来看一张 ",(0,c.jsx)(n.code,{children:"Vue 2"})," 时期的生命周期示意图。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["图片来自 Vue ",(0,c.jsx)(n.a,{href:"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA",target:"_blank",rel:"noopener noreferrer",children:"官方文档"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["我将上述生命周期标点，以便接下来的讲解，首先我们看标记 1，",(0,c.jsx)(n.code,{children:"new Vue()"})," 初始化实例，想必学过 ",(0,c.jsx)(n.code,{children:"Vue"})," 的同学都有所了解，来到标记 2 是初始化事件和组件生命周期，此时会执行 ",(0,c.jsx)(n.code,{children:"beforeCreate"})," 钩子函数，这是在组件创建之前执行的。接下来，来到标记 3，初始化注入和响应式，也就是说在这个时候，",(0,c.jsx)(n.code,{children:"data"})," 数据就已经创建了。接下来执行 ",(0,c.jsx)(n.code,{children:"created"})," 钩子函数，它会判断你是否有 ",(0,c.jsx)(n.code,{children:"el"})," 选项，",(0,c.jsx)(n.code,{children:"el"})," 就是在项目入口页初始化的选项，代码如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"new Vue({\n  el: '#app'\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果你没有，通过 ",(0,c.jsx)(n.code,{children:"vm.$mount(el)"})," 的形式去手动挂载，其实和 ",(0,c.jsx)(n.code,{children:"el"})," 的本质没有区别。然后我们来到标记 5，判断是否有 ",(0,c.jsx)(n.code,{children:"template"})," 模板。用代码解释的话如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"new Vue({\n  el: '#app',\n  template: '<p>十三</p>'\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:["大致如上述代码，如果有 ",(0,c.jsx)(n.code,{children:"template"})," 选项，会进入标记 6 进行模板编译。如果没有，会获取 ",(0,c.jsx)(n.code,{children:"el"})," 的 ",(0,c.jsx)(n.code,{children:"outerHTML"})," 作为模板进行编译。"]}),"\n",(0,c.jsxs)(n.p,{children:["走到这一步，",(0,c.jsx)(n.code,{children:"beforeMount"})," 钩子函数被触发，标记 8 内将模板转化为 ",(0,c.jsx)(n.code,{children:"AST"})," 树，再将 ",(0,c.jsx)(n.code,{children:"AST"})," 树转成 ",(0,c.jsx)(n.code,{children:"render"})," 函数，最后转化为虚拟 ",(0,c.jsx)(n.code,{children:"DOM"})," 挂在到真实 ",(0,c.jsx)(n.code,{children:"DOM"})," 节点上。"]}),"\n",(0,c.jsx)(n.p,{children:"标记 9 代表组件已经加载完了，在组件内部更新数据时候的生命周期，更新前和更新后各自触发的钩子函数。"}),"\n",(0,c.jsx)(n.p,{children:"标记 10 代表组件被卸载，包括监听器也会被卸载，你可以在这里做一些组件销毁后的事情。"}),"\n",(0,c.jsxs)(n.h2,{id:"vue-3-生命周期解读",children:["Vue 3 生命周期解读",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-3-生命周期解读",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["上文我们对 ",(0,c.jsx)(n.code,{children:"Vue 2"})," 的生命周期知识点进行了一个简单的回顾，也让大家的脑海里有一个初步的印象，和接下来的 ",(0,c.jsx)(n.code,{children:"Vue 3"})," 生命周期能形成一个对比。"]}),"\n",(0,c.jsxs)(n.p,{children:["生命周期钩子函数，",(0,c.jsx)(n.code,{children:"Vue 2"})," 对应 ",(0,c.jsx)(n.code,{children:"Vue 3"})," 的写法如下："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.del,{children:(0,c.jsx)(n.code,{children:"beforeCreate"})})," -> ",(0,c.jsx)(n.code,{children:"setup"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.del,{children:(0,c.jsx)(n.code,{children:"created"})})," -> ",(0,c.jsx)(n.code,{children:"setup"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"beforeMount"})," -> ",(0,c.jsx)(n.code,{children:"onBeforeMount"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"mounted"})," -> ",(0,c.jsx)(n.code,{children:"onMounted"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"beforeUpdate"})," -> ",(0,c.jsx)(n.code,{children:"onBeforeUpdate"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"updated"})," -> ",(0,c.jsx)(n.code,{children:"onUpdated"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"beforeDestroy"})," -> ",(0,c.jsx)(n.code,{children:"onBeforeUnmount"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"destroyed"})," -> ",(0,c.jsx)(n.code,{children:"onUnmounted"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"errorCaptured"})," -> ",(0,c.jsx)(n.code,{children:"onErrorCaptured"}),"。"]}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"Composition API 里没有 beforeCreate 和 created 对应的生命周期，统一改成 setup 函数。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["我们来看看在 ",(0,c.jsx)(n.code,{children:"Vue 3"})," 中生命周期运行顺序和使用情况，通过 ",(0,c.jsx)(n.code,{children:"Vite"})," 新建文件，修改 ",(0,c.jsx)(n.code,{children:"App.vue"})," 文件："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--App.vue--\x3e\n<template>\n  <div>\n    <h1>生命周期{{ state.count }}</h1>\n    <div v-if=\"state.show\">\n      <Test />\n    </div>\n  </div>\n\n</template>\n\n<script setup>\nimport Test from './components/Test.vue'\nimport { onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onErrorCaptured, reactive } from 'vue'\n\nconst state = reactive({\n  count: 0,\n  show: true\n})\nsetTimeout(() => {\n  state.count = 2\n  state.show = false\n}, 2000)\n\nonBeforeMount(() => {\n  console.log('onBeforeMount')\n})\n\nonMounted(() => {\n  console.log('onMounted')\n})\n\nonBeforeUpdate(() => {\n  console.log('onBeforeUpdate')\n})\n\nonUpdated(() => {\n  console.log('onUpdated')\n})\n\nonBeforeUnmount(() => {\n  console.log('onBeforeUnmount')\n})\n\nonUnmounted(() => {\n  console.log('onUnmounted')\n})\n\nonErrorCaptured(() => {\n  console.log('onErrorCaptured')\n})\n<\/script>\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--src/components/Test.vue--\x3e\n<template>\n  <div>我是子组件</div>\n</template>\n\n<script setup>\nimport { onBeforeUnmount, onUnmounted } from 'vue'\nonBeforeUnmount(() => {\n  console.log('子组件-onBeforeUnmount')\n})\n\nonUnmounted(() => {\n  console.log('子组件-onUnmounted')\n})\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"执行页面，我们观察控制台的打印："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["首先是页面渲染前执行 ",(0,c.jsx)(n.code,{children:"onBeforeMount"}),"，紧接着是 ",(0,c.jsx)(n.code,{children:"onMounted"}),"。当组件有变量更新导致页面变化的时候，先执行 ",(0,c.jsx)(n.code,{children:"onBeforeUpdate"}),"，但是没有马上执行 ",(0,c.jsx)(n.code,{children:"onUpdated"}),"，而是先执行了子组件的销毁生命周期钩子 ",(0,c.jsx)(n.code,{children:"onBeforeUnmount"})," 和 ",(0,c.jsx)(n.code,{children:"onUnmounted"}),"，这是因为子组件在父组件中渲染，在页面变化没有完全结束前，是不会执行父组件的 ",(0,c.jsx)(n.code,{children:"onUpdated"})," 生命周期钩子函数。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们请求数据还是写在 ",(0,c.jsx)(n.code,{children:"onMounted"})," 钩子函数内，它支持 ",(0,c.jsx)(n.code,{children:"async await"})," 写法，如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"onMounted(async () => {\n  const data = await serviceApi(params)\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:["从这可以看出，写过 ",(0,c.jsx)(n.code,{children:"Vue 2"})," 的同学，只要对照着生命周期，就能很轻松的将 ",(0,c.jsx)(n.code,{children:"Vue 2"})," 的项目升级至 ",(0,c.jsx)(n.code,{children:"Vue 3"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"提供注入provideinject",children:["提供/注入（provide/inject）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#提供注入provideinject",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"provide/inject"})," 字面翻译的话，其实是叫“提供/注入”，但是网上都说是“依赖/注入”，我们姑且就叫它“提供/注入”，翻译不纠结，重要的是知识点。"]}),"\n",(0,c.jsxs)(n.p,{children:["这是一个很重要的特性，可以说在很多业务场景下有了它的存在，你就能更加如鱼得水。我们假设一个业务场景，你有一个 ",(0,c.jsx)(n.code,{children:"祖先组件"}),"，在组件中你引入了一个 ",(0,c.jsx)(n.code,{children:"父亲组件"}),"，",(0,c.jsx)(n.code,{children:"父亲组件"})," 内又引入了一个 ",(0,c.jsx)(n.code,{children:"儿子组件"}),"，此时你想给 ",(0,c.jsx)(n.code,{children:"儿子组件"})," 传递一个数据，但是你的数据源必须在 ",(0,c.jsx)(n.code,{children:"祖先组件"})," 获取，看下面的示意图："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"祖先"})," 想要传递数据给 ",(0,c.jsx)(n.code,{children:"儿子"})," 的的话，正常情况下，需要先传递给 ",(0,c.jsx)(n.code,{children:"父亲"})," 组件，然后 ",(0,c.jsx)(n.code,{children:"父亲"})," 组件再将数据传给 ",(0,c.jsx)(n.code,{children:"儿子"})," 组件。"]}),"\n",(0,c.jsxs)(n.p,{children:["现在我们有了 ",(0,c.jsx)(n.code,{children:"provide/inject"}),"，便可以在 ",(0,c.jsx)(n.code,{children:"祖先组件"})," 声明 ",(0,c.jsx)(n.code,{children:"provide"}),"，然后在 ",(0,c.jsx)(n.code,{children:"儿子组件"})," 通过 ",(0,c.jsx)(n.code,{children:"inject"})," 拿到数据。下面我们用代码来诠释上面的分析。"]}),"\n",(0,c.jsxs)(n.h4,{id:"vue-2写法",children:["Vue 2写法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-2写法",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["清空上述 ",(0,c.jsx)(n.code,{children:"App.vue"})," 的代码，将其作为 ",(0,c.jsx)(n.code,{children:"祖先组件"}),"，代码如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>\n    <h1>提供/注入</h1>\n    <Father />\n  </div>\n\n</template>\n\n<script>\nimport Father from './components/Father.vue'\n\nexport default {\n  components: {\n    Father\n  },\n  provide: {\n    name: '陈尼克'\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"src/components"})," 文件夹新建两个文件 ",(0,c.jsx)(n.code,{children:"Father.vue"})," 和 ",(0,c.jsx)(n.code,{children:"Son.vue"})," 如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--Father.vue--\x3e\n<template>\n  <div>我是父亲</div>\n  <Son />\n</template>\n\n<script>\nimport Son from './Son.vue'\nexport default {\n  name: 'Father',\n  components: {\n    Son\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--Son.vue--\x3e\n<template>\n  <div>我是儿子，{{ name }}</div>\n</template>\n\n<script>\nexport default {\n  name: 'Son',\n  inject: ['name']\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"浏览器表现如下所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.h4,{id:"vue-3-写法",children:["Vue 3 写法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-3-写法",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["之前说过 ",(0,c.jsx)(n.code,{children:"Vue 3"})," 作出最大的改动就是将 ",(0,c.jsx)(n.code,{children:"options"})," 的书写形式改成了 ",(0,c.jsx)(n.code,{children:"hooks"})," 的钩子函数形式。",(0,c.jsx)(n.code,{children:"privide/inject"})," 也不例外，我们使用它们需要通过 ",(0,c.jsx)(n.code,{children:"vue"})," 去解构出来，下面我们修改上述代码如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--App.vue--\x3e\n<template>\n  <div>\n    <h1>提供/注入</h1>\n    <Father />\n  </div>\n\n</template>\n\n<script setup>\nimport { provide } from 'vue'\nimport Father from './components/Father.vue'\n\nprovide('name', '陈尼克') // 单个声明形式\nprovide('info', {\n  work: '前端开发',\n  age: '18'\n}) // 多个声明形式\n<\/script>\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--Son.vue--\x3e\n<template>\n  <div>我是儿子，{{ name }}</div>\n  <div>职业：{{ info.work }}</div>\n  <div>年龄：{{ info.age }}</div>\n</template>\n\n<script setup>\nimport { inject } from 'vue'\nconst name = inject('name', '嘻嘻') // 第二个参数为默认值，可选\nconst info = inject('info')\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"浏览器展示如下所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["当我们需要修改传入的数据时，",(0,c.jsx)(n.code,{children:"Vue"})," 不建议我们直接在接收数据的页面修改数据源，用上述的例子就是不建议在 ",(0,c.jsx)(n.code,{children:"Son.vue"})," 组件内去修改数据源，我们可以在 ",(0,c.jsx)(n.code,{children:"App.vue"})," 组件内通过 ",(0,c.jsx)(n.code,{children:"provide"})," 传递一个修改数据的方法给 ",(0,c.jsx)(n.code,{children:"Son.vue"}),"，通过在 ",(0,c.jsx)(n.code,{children:"Son.vue"})," 内调用该方法去改变值。我们将代码做如下修改："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--App.vue--\x3e\n<template>\n  <div>\n    <h1>提供/注入</h1>\n    <Father />\n  </div>\n\n</template>\n\n<script setup>\nimport { provide, ref } from 'vue'\nimport Father from './components/Father.vue'\n\nconst name = ref('陈尼克')\nprovide('name', name) // 单个声明形式\nprovide('info', {\n  work: '前端开发',\n  age: '18'\n}) // 多个声明形式\n\nconst changeName = () => {\n  name.value = '李尼克'\n}\n\nprovide('changeName', changeName)\n<\/script>\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--Son.vue--\x3e\n<template>\n  <div>我是儿子，{{ name }}</div>\n  <div>职业：{{ info.work }}</div>\n  <div>年龄：{{ info.age }}</div>\n  <button @click=\"changeName\">修改名字</button>\n</template>\n\n<script setup>\nimport { inject } from 'vue'\nconst name = inject('name', '嘻嘻') // 第二个参数为默认值，可选\nconst info = inject('info')\nconst changeName = inject('changeName')\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"浏览器表现如下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["这里解释一下，在 ",(0,c.jsx)(n.code,{children:"Son.vue"})," 组件中，你可以直接修改 ",(0,c.jsx)(n.code,{children:"inject"})," 传进来的 ",(0,c.jsx)(n.code,{children:"name"})," 值。但是你细想，数据源存在于 ",(0,c.jsx)(n.code,{children:"App.vue"})," 中，你在 ",(0,c.jsx)(n.code,{children:"Son.vue"})," 中私自修改了数据源传进来的值，那两边的值就会产生紊乱，上述业务逻辑属于简单的，当你在公司正式项目中这样做的时候，数据源就会变得杂乱无章，页面组件变得难以维护。综上所述，一定要控制好数据源，保持单一数据流。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["本实验带大家了解了一遍 ",(0,c.jsx)(n.code,{children:"Vue 3"})," 的生命周期，以及对业务逻辑很重要的 ",(0,c.jsx)(n.code,{children:"provide/inject"}),"，细节方面还需同学们去文档里好好的研究，一定要读英文文档，中文直译很难把作者的用意解释清楚。"]}),"\n",(0,c.jsx)(n.p,{children:"本章节完整代码下载地址："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://s.yezgea02.com/1663038168735/vue3-demo3.zip",target:"_blank",rel:"noopener noreferrer",children:"https://s.yezgea02.com/1663038168735/vue3-demo3.zip"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"文档最近更新时间：2022 年 9 月 20 日。"}),"\n"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}let j=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F8.Vue3%20%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E3%80%81%E6%8F%90%E4%BE%9B%E6%B3%A8%E5%85%A5.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"Vue 2 生命周期解读",id:"vue-2-生命周期解读",depth:2},{text:"Vue 3 生命周期解读",id:"vue-3-生命周期解读",depth:2},{text:"提供/注入（provide/inject）",id:"提供注入provideinject",depth:2},{text:"Vue 2写法",id:"vue-2写法",depth:4},{text:"Vue 3 写法",id:"vue-3-写法",depth:4},{text:"总结",id:"总结",depth:2}],title:"8.Vue3 之生命周期钩子函数、提供注入",headingTitle:"8.Vue3 之生命周期钩子函数、提供注入",frontmatter:{}}}}]);