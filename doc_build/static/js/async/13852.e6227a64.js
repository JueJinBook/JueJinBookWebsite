"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["13852"],{181812:function(e,c,a){e.exports=a.p+"static/image/be3aa52666c1c9d5aacecd028771533d.9fa14ea2.webp"},352698:function(e,c,a){a.r(c),a.d(c,{default:()=>$});var r=a(552676),n=a(740453);let s=a.p+"static/image/3798644391a4e6384fc3e86d9af6c7e3.62991b04.webp";var d=a(181812);let p=a.p+"static/image/a249d5b198225bf4b3275cc352bc11b3.7ff6c3a0.webp",i=a.p+"static/image/ec5b5dd4e3447daaa8b81f86cfbd0704.f7d2e219.webp",t=a.p+"static/image/0805c96db6ff1d93fa19e9ea97e534d2.59bcc634.webp",l=a.p+"static/image/396d5a3b749fa823115d18aeb299dee4.aaadde76.webp",m=a.p+"static/image/4e6af6f65fe77fcfc89bb7d96895bc49.2a03d48a.webp",o=a.p+"static/image/c61484fda4d89a669afd6b3a7052d2d6.0c50b894.webp",h=a.p+"static/image/6d87cb8ed893c25079642e3c5e57e14c.7f43a426.webp",j=a.p+"static/image/4b8e5f0c46f1b9ed9910dc6c8cfc987c.7efb4331.webp",x=a.p+"static/image/374b1b47f9dc6e1672200c8d03191a0b.eed199df.webp",b=a.p+"static/image/bc5412ef87ee25bdc9136eb0c2b46706.67af2cba.webp",u=a.p+"static/image/48c7f2c9625285dea4f235e50e81c5e3.206a0220.webp",g=a.p+"static/image/c5c7dcaa1bff4116c865f381ee250569.e38cc49a.webp",f=a.p+"static/image/89be46144446806e245b7d3a4cd9d55c.f33260cb.webp",w=a.p+"static/image/aa9aad18fd306672d3e74c937b1eaa99.d849e534.webp",k=a.p+"static/image/d3e78707db7121a735c1cfc08d1e67f1.62391ddd.webp",R=a.p+"static/image/58734a35a867e3eff6ac8d1cd86d9fc8.426c0958.webp",v=a.p+"static/image/7f41fae262d2464d9a8a79b0465cb49f.fd780256.webp",E=a.p+"static/image/b3cfdf6fed80a2cfd0777817027b6c12.6cfc7360.webp",_=a.p+"static/image/63e800ea5a781029fc00f2f6c2ae2d1b.df336551.webp",A=a.p+"static/image/37d936726b2b8ca2efe4c3b2ad667202.a2020242.webp",C=a.p+"static/image/5c3151d8b0aa7caee29cfb6db2b60397.d2928707.webp",S=a.p+"static/image/3e69b970cc4aad82871b88f42bac625e.4e6518b8.webp",N=a.p+"static/image/047a40f2cd5b927e70ba219584be53c7.2b6f873f.webp",B=a.p+"static/image/72b2e95521d38ab7d8e8f0ac6d54ca84.f549bdcb.webp",V=a.p+"static/image/bc2b3c43b4bbc827a1c37e1e24911efb.0eaffb45.webp",D=a.p+"static/image/ab88377fe5cd94722a4bd0a40bfe8bd5.5ed670b6.webp",F=a.p+"static/image/523c143f44a7015eb436e4df44401b40.8bb9ecea.webp",P=a.p+"static/image/0e0a91a72caccdb12bc313ac1a905912.223172e4.webp",T=a.p+"static/image/25be41a00377c3cce46125d8253daff2.b094d125.webp",y=a.p+"static/image/f98c52c0c55e3b920f3710b127242564.e6b23030.webp",O=a.p+"static/image/33fe7f15dca27c6c6a511f9ba9dccb6f.671a1cc8.webp",M=a.p+"static/image/ebcffbd1685f1eaad4c3b14c24ff27a6.24721bf9.webp",G=a.p+"static/image/3b3e64938db0bdc7d176f58691c6fde0.ef33210b.webp",q=a.p+"static/image/1f94e40530990004a9d7d9035ef44242.0531b293.webp",z=a.p+"static/image/5f0d682ae44e2cfd182f21f8f841524e.d9c75aeb.webp",I=a.p+"static/image/6523ab6c0660dab80762d117c459f57a.3e9109d0.webp",L=a.p+"static/image/bb40952ef32e42772298547c3730d26c.02b65d10.webp",Q=a.p+"static/image/bc61eab0beaca1fdf8f0a6d5bc9144cb.f691709c.webp";function U(e){let c=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",pre:"pre",code:"code",strong:"strong"},(0,n.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(c.h1,{id:"10实战案例调试-react-源码",children:["10.实战案例：调试 React 源码",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#10实战案例调试-react-源码",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"Vue、React 的项目怎么调试我们都知道了，这节我们来调试下 React 的源码。"}),"\n",(0,r.jsx)(c.p,{children:"把 react 和 react-dom 包下载了下来，在项目里引入，开发服务跑起来后，打开 Chrome Devtools 打断点调试。"}),"\n",(0,r.jsx)(c.p,{children:"你会发现调试的是 react-dom.development.js"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:Q,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这是因为 react-dom 包下就是编译后的 react-dom.development.js 文件："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:L,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"而源码里这些逻辑是分散在不同的包里的，所以就算搞懂了逻辑，也不知道这些逻辑在哪些包里，只能靠搜索来定位。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:I,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"那怎么能够调试 React 最初的源码呢？"}),"\n",(0,r.jsx)(c.p,{children:"也就是这样的效果："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:z,alt:""})}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这就需要用到我们刚学的 sourcemap 的知识了："}),"\n",(0,r.jsxs)(c.h2,{id:"用-vscode-调试-react-项目",children:["用 VSCode 调试 React 项目",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#用-vscode-调试-react-项目",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"我们用 create-react-app 创建一个 react 项目，然后 npm run start 跑起来。"}),"\n",(0,r.jsx)(c.p,{children:"这时候浏览器访问就可以用 Chrome DevTools 调试了："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:q,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"但我们的目标是在 VSCode 里调试，所以要添加一个 VSCode 的 debugger 配置："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:G,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"然后点击 debug 启动："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:M,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这时候就可以在 VSCode 里直接打断点调试了："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:O,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"用 VSCode 调试比 Chrome DevTools 方便一些，但现在调试的依然是 react-dom.development.js："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"那怎么调试 react 最初的源码呢？"}),"\n",(0,r.jsx)(c.p,{children:"这就涉及到 sourcemap 的作用了。但是现在下载的 react、react-dom 包里都不带 sourcemap，我们得把 React 源码下载下来自己 build："}),"\n",(0,r.jsxs)(c.h2,{id:"build-出带有-sourcemap-的-react-包",children:["build 出带有 sourcemap 的 react 包",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#build-出带有-sourcemap-的-react-包",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"用 npm 下载的 react 包是这样的："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"而我们需要的是带有 sourcemap 的代码，也就是这样的："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这就要下载 react 源码自己 build 了："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{children:"git clone https://github.com/facebook/react\n"})}),"\n",(0,r.jsx)(c.p,{children:"下载之后 reset 到这个 commit："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{children:"git reset --hard 80f3d88190c07c2da11b5cac58a44c3b90fbc296\n"})}),"\n",(0,r.jsx)(c.p,{children:"我当时调试的时候 react 是 18.2，用的上面这个 commit。不确定后续会不会有构建脚本的变化，为了保证一定能正常生成 sourcemap，建议 reset 到和我同一个 commit。"}),"\n",(0,r.jsx)(c.p,{children:"下载下来的代码执行 npm run build 就能看到 build 的产物（先不用跑这一步）："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:F,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这里的 build/node_modules 下的 react 和 react-dom 包就是我们需要的。"}),"\n",(0,r.jsx)(c.p,{children:"但是现在 build 出的代码并没有带 sourcemap，需要改造下 build 流程。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"build 命令执行的是 ./scripts/rollup/build.js，打开这个文件做一些修改。"}),"\n",(0,r.jsx)(c.p,{children:"找到 rollup 的配置，添加一行 sourcemap: true，这个很容易理解，就是让 rollup 在构建时产生 sourcemap："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:V,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"再跑 npm run build，会报这样的错误："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:B,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"某个转换的插件没有生成 sourcemap。"}),"\n",(0,r.jsx)(c.p,{children:"这个是因为构建的过程中会进行多次转换，会生成多次 sourcemap，然后把 sourcemap 串联起来就是最终的 sourcemap。如果中间有一步转换没有生成 sourcemap，那就断掉了，也就没法把 sourcemap 串联起来了。"}),"\n",(0,r.jsx)(c.p,{children:"这个问题的解决只要找出没有生成 sourcemap 的那几个插件注释掉就可以了："}),"\n",(0,r.jsx)(c.p,{children:"在 getPlugins 方法里，把这样 5 个插件给注释掉："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这个是删除 use strict 用的，可以去掉。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这个是生产环境压缩代码的，也可以去掉。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这个是用 prettier 格式化代码的，也可以去掉。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这个是添加一些头部的代码的，比如 Lisence 等，也没啥用，可以去掉。"}),"\n",(0,r.jsx)(c.p,{children:"还有这个："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:_,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"去掉这 5 个插件之后，再运行 npm run build，这时候就能正常进行构建了，然后产生的代码就是带有 sourcemap 的："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这样我们就成功的 build 出了带有 sourcemap 的 react 包！"}),"\n",(0,r.jsx)(c.p,{children:"接下来只剩最后一步，用上 sourcemap，实现直接调试 React 最初的源码，"}),"\n",(0,r.jsxs)(c.h2,{id:"应用-sourcemap调试-react-最初的源码",children:["应用 sourcemap，调试 React 最初的源码",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#应用-sourcemap调试-react-最初的源码",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"我们已经 build 除了带有 sourcemap 的 react 和 react-dom 包，那把这俩包复制到测试项目的 node_modules 下，就可以直接调试最初的源码了么？"}),"\n",(0,r.jsx)(c.p,{children:"还是不行。"}),"\n",(0,r.jsx)(c.p,{children:"为什么呢？"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"因为我们虽然 build React 源码生成了 sourcemap，但是 webpack 打包的时候没有关联它啊，这样 webpack 的 sourcemap 就只能映射到 react-dom.development.js 不能进一步映射到源码了。"}),"\n",(0,r.jsx)(c.p,{children:"那怎么办呢？"}),"\n",(0,r.jsx)(c.p,{children:"这个问题有两种解决方式："}),"\n",(0,r.jsx)(c.p,{children:"很容易想到的就是改下 sourcemap 的配置，这个我们上节刚学过，加上 module 的配置就能读取和关联 loader 的 sourcemap，然后一层层关联到源码了。"}),"\n",(0,r.jsx)(c.p,{children:"但是用 create-react-app 创建的项目，webpack 配置改起来比较麻烦，这种方式放后面讲。"}),"\n",(0,r.jsx)(c.p,{children:"还有一种方式就是不打包 react 和 react-dom 这俩包。用 script 标签单独引入，这样浏览器就会解析这俩文件各自的 sourcemap，进而映射到源码。"}),"\n",(0,r.jsx)(c.p,{children:"那怎么不打包这俩模块呢？"}),"\n",(0,r.jsx)(c.p,{children:"webpack 支持 externals 来配置一些模块使用全局变量而不进行打包，这样我们就可以单独加载 react、react-dom，然后把他们导出的全局变量配置到 externals 就行了。"}),"\n",(0,r.jsx)(c.p,{children:"要改动 webpack 配置的话，在 create-react-app 创建的项目下要执行 npm run eject。"}),"\n",(0,r.jsx)(c.p,{children:"然后项目下会多出 config 目录和 public 目录，这俩分别放着 webpack 配置和一些公共文件。"}),"\n",(0,r.jsx)(c.p,{children:"修改 webpack 配置，在 externals 下添加 react 和 react-dom 包对应的全局变量："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"然后把 react.development.js 和 react-dom.development.js  放到 public 下，并在 index.html 里面加载这俩文件："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这样再重新 debug，你就会发现 sourcemap 映射到 React 最初的源码了："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"不再是 react-dom.development.js 下的代码，而是具体 react-xxx 包下的。"}),"\n",(0,r.jsx)(c.p,{children:"这就达到了最开始的目的，能直接调试 React 最初的源码！"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"还记得我们这样做的意义么？"}),"\n",(0,r.jsx)(c.p,{children:"能调试最初的源码才能知道哪段逻辑是在哪个包里的，不然要自己去搜索。"}),"\n",(0,r.jsx)(c.p,{children:"这样已经能够达到我们的目的了，但是要想点击调用栈直接定位到 git clone 下来的 react 项目的文件，还需要再做一步。"}),"\n",(0,r.jsxs)(c.h2,{id:"关联-react-源码项目",children:["关联 react 源码项目",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#关联-react-源码项目",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"看我最初演示的效果，点击调用栈是能直接定位到 react 源码项目的文件的："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这是怎么做到的呢？"}),"\n",(0,r.jsx)(c.p,{children:"其实只要 sourcemap 生效，并且 map 到的文件是在当前 workspace 下，VSCode 就会打开对应的文件。"}),"\n",(0,r.jsx)(c.p,{children:"现在 sourcemap 已经生效了，只不过 react 项目没有在 workspace 下。所以，如果想直接定位 react 源码项目的话，可以这样做："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"创建一个新的目录，把 react 源码项目和测试的项目放到一个 workspace 下，这样再调试的时候，map 到的文件就能在 workspace 找到了，也就会打开相应的文件。"}),"\n",(0,r.jsx)(c.p,{children:"只不过现在 sourcemap 下都是这样的相对路径，会导致映射到的文件路径不对："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"所以再去修改下 react build 流程，在 ./script/rollup/build.js 下，添加一个 sourcemap 的路径映射，把 ../../../packages 映射到 react 项目的绝对路径/packages ："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这时候再重新 build，生成的 sourcemap 就是绝对路径了："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"把 build 出的带有 sourcemap 的代码复制到项目的 node_modules 下，覆盖一下。这四个文件 react.development.js、react.development.js.map、react-dom.development.js、react-dom.development.js.map"}),"\n",(0,r.jsx)(c.p,{children:"在新的 workspace 里 debug，你就会发现，路径映射对了："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"点击调用栈能直接打开 react 源码项目的对应文件了！"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"因为只要 sourcemap 映射到的文件在 workspace 下能找到，VSCode 就会把它打开并定位到对应行列号。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)(c.strong,{children:"更重要的是，现在就可以直接在 react 的 src 下打断点了，代码执行到那里就会断住，这是把 react 源码也放到 workspace 下的最大的好处。"})}),"\n",(0,r.jsx)(c.p,{children:"至此，我们就能优雅的调试 React 最初的源码了。"}),"\n",(0,r.jsxs)(c.h2,{id:"让-webpack-的-sourcemap-映射回-react-源码",children:["让 webpack 的 sourcemap 映射回 React 源码",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#让-webpack-的-sourcemap-映射回-react-源码",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"前面我们通过 external 的方式走通了调试 React 源码的流程，这样是可以的，就是不算很优雅。"}),"\n",(0,r.jsx)(c.p,{children:"我们回过头来再来看一下，怎么能让 webpack 生成的 sourcemap 能一次性映射回 React 源码呢？"}),"\n",(0,r.jsx)(c.p,{children:"记得上节讲 webpack 配置的时候，讲到了 module 相关的配置么？"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"module 配置的作用就是让 webpack 在生成模块的 sourcemap 的时候，读取下每个 loader 的 sourcemap，关联起来。"}),"\n",(0,r.jsx)(c.p,{children:"但是只有这样还不够，我们现在是 react 和 react-dom 包的代码本身有了 sourcemap，而且这些代码也不用经过 babel 的编译，所以还需要一个 source-map-loader 来把这些 sourcemap 读取出来，传递给后续的 loader："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这样，webpack 的 sourcemap 就是直接映射到 React 源码的了。"}),"\n",(0,r.jsx)(c.p,{children:"我们不在 create-react-app 创建的项目里改，而是自己创建一个项目。"}),"\n",(0,r.jsx)(c.p,{children:"添加这样一个 webpack 配置文件："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{className:"language-javascript",children:"const path = require('path');\n\nmodule.exports = {\n    entry: './src/index.js',\n    devtool: 'cheap-module-source-map',\n    mode: 'development',\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n    },\n    module: {\n        rules: [\n            {\n                test: /node_modules/,\n                loader: 'source-map-loader'\n            },\n            {\n                test:/\\.jsx?$/,\n                include: path.resolve(__dirname,'./src'),\n                loader:'babel-loader'\n            }\n        ]\n    }\n};\n"})}),"\n",(0,r.jsx)(c.p,{children:"devtool 配置加上 module，这样会关联 loader 的 sourcemap。"}),"\n",(0,r.jsx)(c.p,{children:"source-map-loader 用来读取 node_modules 下代码的 sourcemap 传递给 webpack 的。"}),"\n",(0,r.jsx)(c.p,{children:"babel loader 是用来编译 jsx 代码的，添加这样一个 .babelrc 的配置文件："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{className:"language-javascript",children:"module.exports = {\n    presets:['@babel/preset-react']\n}\n"})}),"\n",(0,r.jsx)(c.p,{children:"源码是这样："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{className:"language-javascript",children:"import React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction Aaa() {\n    debugger;\n    return <div>dongdongdong</div>\n}\n\nconst container = document.getElementById('root');\n\nconst root = ReactDOM.createRoot(container);\nroot.render(React.createElement(Aaa));\n"})}),"\n",(0,r.jsx)(c.p,{children:"在 html 里引入产物 bundle："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n</head>\n<body>\n    <div id="root"></div>\n    <script src="./dist/bundle.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,r.jsx)(c.p,{children:"执行 webpack -c webpack.config.js 编译。"}),"\n",(0,r.jsx)(c.p,{children:"然后添加一个调试配置："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"把生成的 react、react-dom 的产物复制到 node_modules 下："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"点击 Debug 启动："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这时候调用栈中的就是 React 的源码。"}),"\n",(0,r.jsxs)(c.p,{children:["这个项目我放到了",(0,r.jsx)(c.a,{href:"https://github.com/QuarkGluonPlasma/fe-debug-exercize/",target:"_blank",rel:"noopener noreferrer",children:"小册的仓库"}),"里。"]}),"\n",(0,r.jsx)(c.p,{children:"只不过因为现在 workspace 中没有对应的文件，可以用同样的方式把 react 源码项目和 demo 项目放到一个 workspace，然后再调试："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这样就能调试 React 源码，并且直接在编辑器里打开对应的文件了。"}),"\n",(0,r.jsx)(c.p,{children:"有的同学可能会说，这样直接修改了 node_modules 下的文件感觉不太好，下次安装就没了。"}),"\n",(0,r.jsx)(c.p,{children:"这个问题可以用 patch-package 解决："}),"\n",(0,r.jsx)(c.p,{children:"执行 npx patch-package react-dom，就会生成这样的目录："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"patches 目录下的就是每个包的 diff，在哪个文件添加了删除了什么代码。"}),"\n",(0,r.jsx)(c.p,{children:"执行 npm install 之后，执行一下 npx patch-packages 就会应用这些 patch 来修改 node_modules 下的包。"}),"\n",(0,r.jsx)(c.p,{children:"不过 patch-package 不支持 pnpm，所以只有你用 yarn 或 npm 安装的依赖才能用 patch-package。"}),"\n",(0,r.jsxs)(c.h2,{id:"总结",children:["总结",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"这节我们调试了下 React 源码，常规的调试方式只能调试 react-dom.development.js，虽然能理清逻辑，但是对应不到源码里的哪些包哪些文件，和最初的源码还有一段距离。"}),"\n",(0,r.jsx)(c.p,{children:"这个问题是有解决方案的，就是通过 sourcemap："}),"\n",(0,r.jsx)(c.p,{children:"首先要把 react 源码项目下载下来，修改 build 流程来生成带有 sourcemap 的 react 和 react-dom 包，并且修改 sourcemap 映射的路径为绝对路径。"}),"\n",(0,r.jsx)(c.p,{children:"然后把 react 和 react-dom 配置到 webpack 的 externals 里，不进行打包，而是单独在 index.html 里引入。"}),"\n",(0,r.jsx)(c.p,{children:"这样调试的时候这俩模块的 sourcemap 就可以生效，直接映射回 React 源码。"}),"\n",(0,r.jsx)(c.p,{children:"当然，也可以自己建一个 React 项目，配置 webpack 的 devtool 为 module 相关的，这样会读取 loader 的 sourcemap，然后加上 source-map-loader 来读取源码的 sourcemap。"}),"\n",(0,r.jsx)(c.p,{children:"这样生成的 webpack 的 sourcemap 是直接可以映射到 React 源码的。"}),"\n",(0,r.jsx)(c.p,{children:"如果想点击调用栈直接打开对应 React 源码项目的文件，那就新建一个 workspace，把测试项目和 React 源码项目包含就行了。因为 VSCode 如果在 workspace 下找到了 source map 到的文件，就会直接打开对应的文件。这样就可以直接在源码打断点了。"}),"\n",(0,r.jsx)(c.p,{children:"这个流程是有点复杂，但其实都是围绕 sourcemap 来的，怎么生成 sourcemap，怎么让 sourcemap 生效，怎么找到 sourcemap 对应的文件等，理解了 sourcemap，也就很容易理解这个流程了。"})]})}function Y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,n.ah)(),e.components);return c?(0,r.jsx)(c,{...e,children:(0,r.jsx)(U,{...e})}):U(e)}let $=Y;Y.__RSPRESS_PAGE_META={},Y.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F10.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%B0%83%E8%AF%95%20React%20%E6%BA%90%E7%A0%81.md"]={toc:[{text:"用 VSCode 调试 React 项目",id:"用-vscode-调试-react-项目",depth:2},{text:"build 出带有 sourcemap 的 react 包",id:"build-出带有-sourcemap-的-react-包",depth:2},{text:"应用 sourcemap，调试 React 最初的源码",id:"应用-sourcemap调试-react-最初的源码",depth:2},{text:"关联 react 源码项目",id:"关联-react-源码项目",depth:2},{text:"让 webpack 的 sourcemap 映射回 React 源码",id:"让-webpack-的-sourcemap-映射回-react-源码",depth:2},{text:"总结",id:"总结",depth:2}],title:"10.实战案例：调试 React 源码",headingTitle:"10.实战案例：调试 React 源码",frontmatter:{}}}}]);