"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["50782"],{920374:function(n,e,r){r.r(e),r.d(e,{default:()=>l});var s=r(552676),i=r(740453);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",blockquote:"blockquote",code:"code",ol:"ol",li:"li",pre:"pre",ul:"ul"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"第27章并发三并发中的channel上",children:["第27章—并发三｜并发中的Channel（上）",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第27章并发三并发中的channel上",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\uFEFF本讲我们继续深入 Go 语言的并发。"}),"\n",(0,s.jsx)(e.p,{children:"在前面的示例中，对待协程任务的态度是“放任自流”的。也就是说，一个协程被开启后，我们便不再管它，让它自生自灭，最多是为其它任务让行或终止运行。但在实际开发中，协程任务之间常常会发生通信。"}),"\n",(0,s.jsxs)(e.p,{children:["举例来说，现有协程 A 和协程 B，二者都处于运行状态。协程 B 中的某些逻辑需要协程 A 的执行结果作为输入条件，此时就急需将这些结果数据从协程 A 传递给协程 B 了。由此便引出一个问题：如何在并发任务之间进行",(0,s.jsx)(e.strong,{children:"数据共享"}),"。"]}),"\n",(0,s.jsxs)(e.h2,{id:"csp并发模型",children:["CSP并发模型",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#csp并发模型",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"纵观编程领域，在多任务之间共享数据的方式主要分为两种。"}),"\n",(0,s.jsxs)(e.p,{children:["一种是",(0,s.jsx)(e.strong,{children:"多线程任务之间的内存共享"}),"，这种方式的代表是 Java、C++、Python 等语言中的多线程开发，这种方式普遍要通过“锁”来确保数据安全。"]}),"\n",(0,s.jsxs)(e.p,{children:["另一种便是 Go 语言提倡的 ",(0,s.jsx)(e.strong,{children:"CSP 模型"}),"方式，这种方式的核心思想在于",(0,s.jsx)(e.strong,{children:"以通信的方式共享内存数据"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"这两种数据共享的区别主要在于前者是共享内存实现通信，后者是通过通信共享内存。在 Effective Go 中，谈及并发时有这样一句原文："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"Do not communicate by sharing memory; instead, share memory by communicating."}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"说的就是这个意思。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"\uD83D\uDCA1 提示：Go语言并非只允许CSP方式并发，它同样支持传统的多线程任务调度方式。"})}),"\n",(0,s.jsx)(e.p,{children:"随着对 Go 并发领会的逐渐深入，使用得越来越频繁，便会遇到使用 Goroutine 的三个“陷阱”："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Goroutine Leaks（协程任务泄露）"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Data Race（数据竞争）"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"Incomplete Work（未完成的任务）"})}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["针对上述 1 和 3，规避的方式就是",(0,s.jsx)(e.strong,{children:"确保每一个协程任务可以正常结束"}),"。如果一个协程运行失控，便会长期驻留在内存中，导致系统资源的浪费，出现陷阱 1。或者该执行的任务没有完全完成，导致陷阱 3。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"\uD83D\uDCA1 提示：想想如何终止协程任务，想想协程中的 defer 的使用。"})}),"\n",(0,s.jsxs)(e.p,{children:["针对上述 2，规避的方式便是",(0,s.jsx)(e.strong,{children:"通过传递数据的方式共享数据，而非直接操作某个公共变量"}),"，从而规避数据竞争。"]}),"\n",(0,s.jsx)(e.p,{children:"协程任务之间传递数据需要借助通道（Channel）来完成。"}),"\n",(0,s.jsxs)(e.h2,{id:"通道channel类型",children:["通道（Channel）类型",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#通道channel类型",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["从本质上说，",(0,s.jsx)(e.strong,{children:"Go 语言中的通道（Channel）也是一种类型"}),"，只不过在使用时有些特殊，稍后会详述。从分类上看，可将其分为两种。",(0,s.jsx)(e.strong,{children:"一种是同步通道，另一种是缓冲通道"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"同步通道有点类似于送外卖的过程。若外卖小哥和点餐顾客分别为协程 A 和协程 B，只有当协程 A 把数据（即外卖）送给协程 B（即顾客），协程 B 才能开始执行后续的操作（即吃外卖）。否则，协程 B 只能一直等待数据（即外卖）的到来。"}),"\n",(0,s.jsx)(e.p,{children:"缓冲通道则有点类似于送快递的过程。若快递员和收件人分别为协程 A 和协程 B，协程 A 可以把数据（即快递）放到缓冲区（即菜鸟驿站）。当协程 B 需要时，只要去缓冲区（即菜鸟驿站）中取数据（即快递）即可。"}),"\n",(0,s.jsx)(e.p,{children:"值得一提的是，缓冲区和菜鸟驿站真的很像，它们都有最大容量限制。一旦协程 A 发现缓冲区（即菜鸟驿站）满了，就不得不等待数据（即快递）被取走，才能将数据（即快递）放到空余的位置中。"}),"\n",(0,s.jsx)(e.p,{children:"同步和缓冲，这两种方式孰优孰劣呢？其实并没有特别明确的定论，我们只要根据实际情况，选择合适的方式就是最优的。"}),"\n",(0,s.jsx)(e.p,{children:"篇幅所限，本讲先介绍较为简单的同步通道，下一讲再介绍缓冲通道以及更多内容。"}),"\n",(0,s.jsxs)(e.h2,{id:"同步通道",children:["同步通道",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#同步通道",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"理论部分到此为止，接下来实际演练。我们一起实现如下编程需求："}),"\n",(0,s.jsx)(e.p,{children:"假设我们正在饲养一只母鸡，等待其下蛋。每下一个蛋，我们就拿来做荷包蛋吃。"}),"\n",(0,s.jsx)(e.p,{children:"为了使用同步通道，我们使用两个协程来实现上述需求。协程 A 代表母鸡，它的作用是产蛋，并将产蛋的数量传给协程 B，我们将协程 A 的代码逻辑封装成名为 layEggs() 函数。协程 B 表示吃荷包蛋，等待传入可用的鸡蛋数量，然后输出文字：“吃 x 个荷包蛋”（x 表示鸡蛋数量）。我们将协程B的代码逻辑封装成名为 eatEggs() 函数。"}),"\n",(0,s.jsx)(e.p,{children:"如前文所述，通道（Channel）也是一种数据类型。因此，为了让 layEggs() 和 eatEggs() 都能使用通道类型变量，将通道声明为全局公共变量。该通道将传送鸡蛋的数量，其传送的数据类型是 int，所以我们把它命名为 intChan。具体代码实现如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"var intChan = make(chan int)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这句代码中，",(0,s.jsx)(e.strong,{children:"chan 即表明通道类型，紧接着的 int 表示通道上传送的数据的类型。make() 的目的则是创建通道"}),"。最终的 intChan 变量就是通道类型的变量了。如果使用下面的代码输出 intChan 及其类型："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   fmt.Println(intChan)\r\n   fmt.Println(reflect.TypeOf(intChan))\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"可以得到如下结果："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"0xc00001a0c0"}),"\n",(0,s.jsx)(e.p,{children:"chan int"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["接下来实现 layEggs()函数，该函数需要向通道中传出数据，方法是",(0,s.jsx)(e.strong,{children:"使用箭头操作符"}),"。在传送结束后，",(0,s.jsx)(e.strong,{children:"别忘了调用 close()函数关闭通道，关闭通道时需要指定通道"}),"。具体实现代码如下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"func layEggs() {\r\n   intChan <- 1\r\n   close(intChan)\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"如此，便可将 1 通过 intChan 传出。"}),"\n",(0,s.jsxs)(e.p,{children:["接着，再来实现 eatEggs() 函数。该函数需要从通道中取数据，方法依然是",(0,s.jsx)(e.strong,{children:"使用箭头操作符"}),"，只不过方向上刚好和传出数据相反。具体实现代码如下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:'func eatEggs(intChan chan int) {\r\n   eggCounts := <-intChan\r\n   fmt.Printf("吃%d个荷包蛋", eggCounts)\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"这里的 eggCounts 便是 int 型数据了。请注意这里的箭头操作符，虽然看上去和传出数据的方向相同，但由于主体角色发生了转变，实际上是相反的。但不能将 “<-” 改为 “->” 。"}),"\n",(0,s.jsx)(e.p,{children:"最后，整合这两个函数，完善 main() 函数，并使用 sync.WaitGroup 类型变量确保协程任务能够完全执行。整体代码如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:'var syncWait sync.WaitGroup\r\n// 创建通道类型变量，该通道将传送int类型数据\r\nvar intChan = make(chan int)\r\nfunc main() {\r\n   // 执行2个协程任务\r\n   syncWait.Add(2)\r\n   // 开启下蛋任务\r\n   go layEggs()\r\n   // 开启吃荷包蛋任务\r\n   go eatEggs(intChan)\r\n   // 等待协程任务完成\r\n   syncWait.Wait()\r\n}\r\nfunc layEggs() {\r\n   // 使用断言确保协程任务正常结束\r\n   defer syncWait.Done()\r\n   // 向通道传送int类型值\r\n   intChan <- 1\r\n   // 关闭通道\r\n   close(intChan)\r\n}\r\nfunc eatEggs(intChan chan int) {\r\n   // 使用断言确保协程任务正常结束\r\n   defer syncWait.Done()\r\n   // 从通道获取int类型值\r\n   eggCounts := <-intChan\r\n   // 输出结果\r\n   fmt.Printf("吃%d个荷包蛋", eggCounts)\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"运行这段代码，程序输出："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"吃1个荷包蛋"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"❗️ 注意：使用同步通道时，要确保传出数据和获取数据必须成对出现。另外，一旦通道被关闭，便不能再向其中传出数据了。"})}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,s.jsx)(e.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Go 并发的 CSP 并发模型；"}),"\n",(0,s.jsx)(e.li,{children:"通道（Channel）类型；"}),"\n",(0,s.jsx)(e.li,{children:"同步通道的使用。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"本讲首先快速回顾了多任务调度的两种类型，并详细阐述了 Go 语言推荐的 CSP 并发模型的机制。它们最大的区别在于：使用多线程本质上是通过共享内存实现通信，CSP 模型则是通过通信共享内存。此外还介绍了在 Go 中使用并发的“正确姿势”，规避三种编码“陷阱”。从而构建强壮的代码。"}),"\n",(0,s.jsx)(e.p,{children:"接着介绍了 Go 语言中的通道类型，它就像“传送带”一样，将数据从一个协程带到另一个协程中，实现数据共享。"}),"\n",(0,s.jsx)(e.p,{children:"通道分为两种：同步通道和缓冲通道。使用同步通道要求数据的发送者和接收者必须成对出现，传送时使用箭头操作符（“<-”）。传送结束后，别忘了调用 Go SDK 内置的 close 函数关闭通道，结束整个数据传送流程。"}),"\n",(0,s.jsx)(e.p,{children:"➡️ 在下次课程中，我们会继续介绍 Go 语言中的并发，涉及并发任务间的通信方式，内容如下："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"并发中的 Channel 下部"}),"\n"]})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}let l=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC27%E7%AB%A0%E2%80%94%E5%B9%B6%E5%8F%91%E4%B8%89%EF%BD%9C%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84Channel%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{text:"CSP并发模型",id:"csp并发模型",depth:2},{text:"通道（Channel）类型",id:"通道channel类型",depth:2},{text:"同步通道",id:"同步通道",depth:2},{text:"小结",id:"小结",depth:2}],title:"第27章—并发三｜并发中的Channel（上）",headingTitle:"第27章—并发三｜并发中的Channel（上）",frontmatter:{}}}}]);