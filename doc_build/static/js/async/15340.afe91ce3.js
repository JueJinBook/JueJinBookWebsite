"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["15340"],{994412:function(e,n,i){i.r(n),i.d(n,{default:()=>d});var r=i(552676),s=i(740453);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"mixin",children:["Mixin",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["JavaScript 语言的设计是单一继承，即子类只能继承一个父类，不允许继承多个父类。这种设计保证了对象继承的层次结构是树状的，而不是复杂的",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem",target:"_blank",rel:"noopener noreferrer",children:"网状结构"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"但是，这大大降低了编程的灵活性。因为实际开发中，有时不可避免，子类需要继承多个父类。举例来说，“猫”可以继承“哺乳类动物”，也可以继承“宠物”。"}),"\n",(0,r.jsx)(n.p,{children:"各种单一继承的编程语言，有不同的多重继承解决方案。比如，Java 语言也是子类只能继承一个父类，但是还允许继承多个界面（interface），这样就间接实现了多重继承。Interface 与父类一样，也是一个类，只不过它只定义接口（method signature），不定义实现，因此又被称为“抽象类”。凡是继承于 Interface 的方法，都必须自己定义实现，否则就会报错。这样就避免了多重继承的最大问题：多个父类的同名方法的碰撞（naming collision）。"}),"\n",(0,r.jsx)(n.p,{children:"JavaScript 语言没有采用 Interface 的方案，而是通过代理（delegation）实现了从其他类引入方法。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'var Enumerable_first = function () {\n  this.first = function () {\n    return this[0];\n  };\n};\n\nvar list = ["foo", "bar", "baz"];\nEnumerable_first.call(list); // explicit delegation\nlist.first() // "foo"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"list"}),"是一个数组，本身并没有",(0,r.jsx)(n.code,{children:"first"}),"方法。通过",(0,r.jsx)(n.code,{children:"call"}),"方法，可以把",(0,r.jsx)(n.code,{children:"Enumerable_first"}),"里面的方法，绑定到",(0,r.jsx)(n.code,{children:"list"}),"，从而",(0,r.jsx)(n.code,{children:"list"}),"就具有",(0,r.jsx)(n.code,{children:"first"}),"方法。这就叫做“代理”（delegation），",(0,r.jsx)(n.code,{children:"list"}),"对象代理了",(0,r.jsx)(n.code,{children:"Enumerable_first"}),"的",(0,r.jsx)(n.code,{children:"first"}),"方法。"]}),"\n",(0,r.jsxs)(n.h2,{id:"含义",children:["含义",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#含义",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Mixin 这个名字来自于冰淇淋，在基本口味的冰淇淋上面混入其他口味，这就叫做 Mix-in。"}),"\n",(0,r.jsx)(n.p,{children:"它允许向一个类里面注入一些代码，使得一个类的功能能够“混入”另一个类。实质上是多重继承的一种解决方案，但是避免了多重继承的复杂性，而且有利于代码复用。"}),"\n",(0,r.jsx)(n.p,{children:"Mixin 就是一个正常的类，不仅定义了接口，还定义了接口的实现。"}),"\n",(0,r.jsxs)(n.p,{children:["子类通过在",(0,r.jsx)(n.code,{children:"this"}),"对象上面绑定方法，达到多重继承的目的。"]}),"\n",(0,r.jsx)(n.p,{children:"很多库提供了 Mixin 功能。下面以 Lodash 为例。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function vowels(string) {\n  return /[aeiou]/i.test(this.value);\n}\n\nvar obj = { value: 'hello' };\n_.mixin(obj, {vowels: vowels})\nobj.vowels() // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码通过 Lodash 库的",(0,r.jsx)(n.code,{children:"_.mixin"}),"方法，让",(0,r.jsx)(n.code,{children:"obj"}),"对象继承了",(0,r.jsx)(n.code,{children:"vowels"}),"方法。"]}),"\n",(0,r.jsxs)(n.p,{children:["Underscore 的类似方法是",(0,r.jsx)(n.code,{children:"_.extend"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"var Person = function (fName, lName) {\n  this.firstName = fName;\n  this.lastName = lName;\n}\n\nvar sam = new Person('Sam', 'Lowry');\n\nvar NameMixin = {\n  fullName: function () {\n    return this.firstName + ' ' + this.lastName;\n  },\n  rename: function(first, last) {\n    this.firstName = first;\n    this.lastName = last;\n    return this;\n  }\n};\n_.extend(Person.prototype, NameMixin);\nsam.rename('Samwise', 'Gamgee');\nsam.fullName() // \"Samwise Gamgee\"\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码通过",(0,r.jsx)(n.code,{children:"_.extend"}),"方法，在",(0,r.jsx)(n.code,{children:"sam"}),"对象上面（准确说是它的原型对象",(0,r.jsx)(n.code,{children:"Person.prototype"}),"上面），混入了",(0,r.jsx)(n.code,{children:"NameMixin"}),"类。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"extend"}),"方法的实现非常简单。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function extend(destination, source) {\n  for (var k in source) {\n    if (source.hasOwnProperty(k)) {\n      destination[k] = source[k];\n    }\n  }\n  return destination;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码将",(0,r.jsx)(n.code,{children:"source"}),"对象的所有方法，添加到",(0,r.jsx)(n.code,{children:"destination"}),"对象。"]}),"\n",(0,r.jsxs)(n.h2,{id:"trait",children:["Trait",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#trait",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Trait 是另外一种多重继承的解决方案。它与 Mixin 很相似，但是有一些细微的差别。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Mixin 可以包含状态（state），Trait 不包含，即 Trait 里面的方法都是互不相干，可以线性包含的。比如，",(0,r.jsx)(n.code,{children:"Trait1"}),"包含方法",(0,r.jsx)(n.code,{children:"A"}),"和",(0,r.jsx)(n.code,{children:"B"}),"，",(0,r.jsx)(n.code,{children:"Trait2"}),"继承了",(0,r.jsx)(n.code,{children:"Trait1"}),"，同时还包含一个自己的方法",(0,r.jsx)(n.code,{children:"C"}),"，实际上就等同于直接包含方法",(0,r.jsx)(n.code,{children:"A"}),"、",(0,r.jsx)(n.code,{children:"B"}),"、",(0,r.jsx)(n.code,{children:"C"}),"。"]}),"\n",(0,r.jsx)(n.li,{children:"对于同名方法的碰撞，Mixin 包含了解决规则，Trait 则是报错。"}),"\n"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2FMixin.md"]={toc:[{text:"含义",id:"含义",depth:2},{text:"Trait",id:"trait",depth:2}],title:"Mixin",headingTitle:"Mixin",frontmatter:{}}}}]);