"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["4647"],{905994:function(e,n,r){r.r(n),r.d(n,{default:()=>u});var s=r(552676),a=r(740453);let t=r.p+"static/image/13fee0951298ee8c4e696e77c0717b54.3b55f391.webp",i=r.p+"static/image/4368325d1b3e9d2fa5c54eeb050c0df9.36aefa1f.webp",o=r.p+"static/image/449e9a25fabc9f927d7626d0fe4f3d2f.a6610182.webp",c=r.p+"static/image/a537cd35746cdca5aa7d6ab200f6c6d9.384010b3.webp",l=r.p+"static/image/0b40c1de0c382fb7183a9477ba25736f.958e484f.webp",d=r.p+"static/image/dbf59e5532faf8e0c93b9cb759e5fc09.20defb26.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",img:"img",blockquote:"blockquote",ul:"ul",li:"li",h3:"h3"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"23打包篇-生产环境疑难杂症的解决",children:["23.打包篇-生产环境疑难杂症的解决",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23打包篇-生产环境疑难杂症的解决",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上一章节，我们将应用程序打包构建整完了，好像看起来没啥问题了，并非如此，还是存在许多的问题，接下来我们需要继续填坑了。如果你对本章节内容兴趣不大，可以快速阅读或跳过。"}),"\n",(0,s.jsxs)(n.h2,{id:"-坑一开发环境凉了",children:["\uD83D\uDD28 坑一：开发环境凉了",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-坑一开发环境凉了",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们以 ",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/chapter-22-build",target:"_blank",rel:"noopener noreferrer",children:"chapter-22-build"})," 分支代码，继续往下开发，让我们先去开发环境试试吧"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// \uD83D\uDC47 记住，在进入开发环境时，先将 dist 目录删除\n// 因为我们常规开发时，是不会去 build dist 目录的\nrm -rf dist\nnpm run start:main\nnpm run start:render\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时看看会有什么问题"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["直接报错了，这是为什么呢？在本地开发时，我们通过 ",(0,s.jsx)(n.code,{children:"webpack-dev-server"})," 起了一个本地服务"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"devServer: {\n  contentBase: path.join(__dirname, '../dist'),\n  compress: true,\n  host: '127.0.0.1',\n  port: 7001, // 启动端口为 7001 的服务\n  hot: true,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在终端中我们也能看到输出的一些相关信息"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"webpack-dev-server"})," 主要是启动了一个 express 的 HTTP 服务器，当原始文件发生改变之后，",(0,s.jsx)(n.code,{children:"webpack-dev-server"})," 会实时编译，但请注意，⚠️ 启动了 webpack-dev-server 后，dist 目录是看不到编译后的文件,实时编译后的文件都保存到了内存当中。所以你跑去 dist 目录下找，是找不到编译后的文件的。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["按道理来讲，我们访问 ",(0,s.jsx)(n.code,{children:"dist"})," 目录下的 ",(0,s.jsx)(n.code,{children:"assets/template"}),"、",(0,s.jsx)(n.code,{children:"appConfig"})," 都应该能读到数据的。那为什么会说找不到文件夹呢？"]}),"\n",(0,s.jsxs)(n.p,{children:["第一时间想到的就是文件夹拷贝问题，我们检查一下 ",(0,s.jsx)(n.code,{children:"webpack/webpack.render.base.js"}),"，该配置下，生产是没问题的，但在开发环境 ",(0,s.jsx)(n.code,{children:"dev-server"})," 中存在问题。有没有可能是该插件，不支持 ",(0,s.jsx)(n.code,{children:"dev-server"}),"，我们前往官网找一下有没有相关 issues，还真找到一个 \uD83D\uDC49 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/copy-webpack-plugin/issues/29",target:"_blank",rel:"noopener noreferrer",children:"Does not copy files to actual output folder when webpack-dev-server is used"})]}),"\n",(0,s.jsx)(n.p,{children:"一圈扫荡下来，大部分的回答是 2016 年、2017 年，还有说需要降版本的。这方案肯定不得行，回想一下，好像没打包构建之前，都能正常，这是为什么？因为获取应用路径被我们修改。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 原来开发环境能正常的应用路径\nconst ROOT_PATH = path.join(app.getAppPath(), '../');\nipcMain.on('get-root-path', (event, arg) => {\n  event.reply('reply-root-path', ROOT_PATH);\n});\n\n// 打包构建时，我们将应用路径改成这样\nipcMain.on('get-root-path', (event, arg) => {\n  event.reply('reply-root-path', __dirname);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面的路径我们能在开发环境下正常，生产环境出现问题。下面的路径在开发环境上出现问题，生产环境下正常。"}),"\n",(0,s.jsxs)(n.p,{children:["那就两者结合，各负责各的，我们将代码改造一下，前往 ",(0,s.jsx)(n.code,{children:"app/main/electron.ts"})," 进行修改"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/main/electron.ts\n\nconst ROOT_PATH = path.join(app.getAppPath(), '../');\nipcMain.on('get-root-path', (event, arg) => {\n  event.reply('reply-root-path', isDev() ? ROOT_PATH : __dirname);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"让我们重新跑一下开发环境的命令吧"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"rm -rf dist\nnpm run start:main\nnpm run start:render\n"})}),"\n",(0,s.jsx)(n.p,{children:"这时候是正常无问题的。那生产环境打包构建会不会有问题呢？走一个完整的打包构建命令"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 1. 删除上一轮打包的 dist 目录和 package 目录\nrm -rf dist package\n// 2. 构建打包Elctron\nnpm run build:main\n// 3. 构建打包 React\nnpm run build:render\n// 4. 通过 electron-builder 构建安装包\nnpm run dist\n"})}),"\n",(0,s.jsx)(n.p,{children:"安装一下，经过验证，开发环境和生产环境均无问题！"}),"\n",(0,s.jsxs)(n.h2,{id:"-坑二切换主题数据无法写入-themeconfigjson",children:["\uD83D\uDD28 坑二：切换主题，数据无法写入 theme.config.json",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-坑二切换主题数据无法写入-themeconfigjson",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["继上述打包构建之后，安装应用，此时选择切换主题，按道理来讲，应当存入 ",(0,s.jsx)(n.code,{children:"theme.config.json"})," 文件，却得到异常报错，如下图"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["大家猜一猜，是什么原因？很简单，electron 不允许你对打包之后的代码进行修改，仔细想想，这也正常，你说像微信、QQ 这种应用安装包，它会允许你修改源代码文件？同样的，我们对打包构建之后的 ",(0,s.jsx)(n.code,{children:"dist/appConfig"})," 目录进行增删改查操作，那肯定是无权限、不被允许的。"]}),"\n",(0,s.jsxs)(n.p,{children:["这里我给大家挖了一个坑，解铃还须系铃人，接下来让我们来填填坑～ 既然对于打包构建之后的文件都不能做增删改查操作，但我们确实有此需求，该如何实现？在 Electron 中，可以通过 ",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/docs/api/app#appgetpathname",target:"_blank",rel:"noopener noreferrer",children:"app.getPath"})," 去存储数据，我们来看看文档如何说的"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，通过 ",(0,s.jsx)(n.code,{children:"app.getPath()"})," API，我们可以得到用户在本设备上的一些路径，比如 ",(0,s.jsx)(n.code,{children:"userData"})," 应用程序设置文件的文件夹路径，从而进行数据的存储，这是一次大改动，鉴于此次改动量有点大，一定要认真看"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第一步：在 ",(0,s.jsx)(n.code,{children:"app/main"})," 目录下添加 ",(0,s.jsx)(n.code,{children:"userData"}),"，下面看代码注释"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { app, ipcMain } from 'electron';\nimport path from 'path';\nimport fileAction from '@common/utils/file';\n\n// \uD83D\uDC47 1. 得到应用程序设置文件的文件夹，然后查看 appConfig 目录\nconst appConfigPath = path.resolve(app.getPath('userData'), 'appConfig');\n\n// \uD83D\uDC47 2 appConfig 文件夹是否可读\nfileAction\n  .canRead(appConfigPath)\n  .then(() => {\n    // \uD83D\uDC47 2.1 appConfig 可读情况下，判断是否存在 theme.config.json\n    fileAction.hasFile(`${appConfigPath}/theme.config.json`).catch(() => {\n      // 2.1.1 不存在则默认创建\n      createThemeConfigJson();\n    });\n    // \uD83D\uDC47 2.2  appConfig 可读情况下，判断是否存在 global.config.json\n    fileAction.hasFile(`${appConfigPath}/global.config.json`).catch(() => {\n      // 2.2.1 不存在则默认创建\n      createGlobalConfigJson();\n    });\n  })\n  .catch(() => {\n    // \uD83D\uDC47 2.3 appConfig 文件夹不可读，说明不存在此文件夹，则新增文件夹\n    fileAction.mkdirDir(appConfigPath).then(() => {\n      // 2.3.1 并默认创建文件\n      createThemeConfigJson();\n      createGlobalConfigJson();\n    });\n  });\n\n// 创建默认 theme.config.json\nconst createThemeConfigJson = () => {\n  fileAction?.write(\n    `${appConfigPath}/theme.config.json`,\n    {\n      name: '主题配置表',\n      currentTheme: {\n        id: 'green',\n        fontColor: '#ffffff',\n        backgroundColor: '#416f5b',\n      },\n      themeList: [\n        { id: 'dark', fontColor: '#ffffff', backgroundColor: '#27292c' },\n        { id: 'blue', fontColor: '#ffffff', backgroundColor: '#35495e' },\n        { id: 'green', fontColor: '#ffffff', backgroundColor: '#416f5b' },\n        { id: 'purple', fontColor: '#ffffff', backgroundColor: '#54546c' },\n        { id: 'princess', fontColor: '#ffffff', backgroundColor: '#945454' },\n      ],\n    },\n    'utf8'\n  );\n};\n\n// 创建默认 global.config.json\nconst createGlobalConfigJson = () => {\n  fileAction?.write(\n    `${appConfigPath}/global.config.json`,\n    { name: '全局配置表', resumeSavePath: '' },\n    'utf8'\n  );\n};\n\n// \uD83D\uDC47 响应渲染进程想得到的 userData 路径，因为 app 模块只能在主进程中使用\nipcMain.on('Electron:get-userData-path', (event, arg) => {\n  event.reply('Electron:reply-userData-path', app.getPath('userData'));\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["由于此文件中我们用到了 ",(0,s.jsx)(n.code,{children:"@common/utils/file"})," 别名路径，所有需要在主进程的 webpack 做一些别名配置，我们修改 ",(0,s.jsx)(n.code,{children:"webpack/webpack.main.base.js"}),"，部分代码省略"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  resolve: {\n    alias: {\n      '@common': path.join(__dirname, '../', 'app/renderer/common'),\n    },\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第二步：引入 ",(0,s.jsx)(n.code,{children:"userData"})," 文件"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们在主进程中引入此文件，修改 ",(0,s.jsx)(n.code,{children:"app/main/electron.ts"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 将此文件引入\nimport './userData';\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第三步：前往 ",(0,s.jsx)(n.code,{children:"app/renderer/common/utils/appPath.ts"})," 下，添加新的方法"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"添加新的获取 userData 路径方法"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * @description 获取应用 useData 路径\n * @returns {Promise<string>}\n */\nexport function getUserStoreDataPath(): Promise<string> {\n  return new Promise(\n    (resolve: (value: string) => void, reject: (value: Error) => void) => {\n      ipcRenderer.send('Electron:get-userData-path', '');\n      ipcRenderer.on('Electron:reply-userData-path', (event, arg: string) => {\n        if (arg) {\n          resolve(arg);\n        } else {\n          reject(new Error('项目路径错误'));\n        }\n      });\n    }\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第四步：将涉及到 appConfig 的文件都进行修改"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们去 ",(0,s.jsx)(n.code,{children:"app/renderer/hooks"})," 下，找到 ",(0,s.jsx)(n.code,{children:"useThemeActionHooks.ts"})," 文件修改，下边为伪代码"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/renderer/hooks/useThemeActionHooks.ts\n\n// \uD83D\uDC47 修改成获取 userData 路径的方法\nimport { getUserStoreDataPath } from '@common/utils/appPath';\n\n/**\n * @description 读取配置文件的内容\n */\nfunction useReadAppConfigThemeFile() {\n  return () => {\n    return new Promise((resolve: (values: { [key: string]: any }) => void, reject: (value: Error) => void) => {\n      // \uD83D\uDC47 这里改一下方法名\n      getUserStoreDataPath().then((appPath: string) => {\n        // ...\n      });\n    });\n  };\n}\n\n/**\n * @description 更新配置表中的用户设置信息\n * @param {string} updateKey 键\n * @param {any} updateValues 值\n * @param {function} callback 回调函数\n */\nfunction useUpdateAppConfigThemeFile() {\n  const readAppConfigThemeFile = useReadAppConfigThemeFile();\n  return (updateKey: string, updateValues: any, callback?: () => void) => {\n    // \uD83D\uDC47 这里改一下方法名\n    getUserStoreDataPath().then((appPath: string) => {\n      // ...\n    });\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们再去 ",(0,s.jsx)(n.code,{children:"app/renderer/hooks"})," 下，找到 ",(0,s.jsx)(n.code,{children:"useGlobalConfigActionHooks.ts"})," 文件修改，下边为伪代码"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/renderer/hooks/useGlobalConfigActionHooks.ts\n\n// \uD83D\uDC47 修改成获取 userData 路径的方法\nimport { getUserStoreDataPath } from '@common/utils/appPath';\n\n/**\n * @description 读取全局配置文件的内容\n */\nexport function useReadGlobalConfigFile() {\n  return () => {\n    return new Promise((resolve: (values: { [key: string]: any }) => void, reject: (value: Error) => void) => {\n      // \uD83D\uDC47 这里改一下方法名\n      getUserStoreDataPath().then((appPath: string) => {\n        // ...\n      });\n    });\n  };\n}\n\n/**\n * @description 读取配置文件的内容\n * @param {string} updateKey 键\n * @param {any} updateValues 值\n * @param {function} callback 回调函数\n */\nexport function useUpdateGlobalConfigFile() {\n  const readGlobalConfigFile = useReadGlobalConfigFile();\n  return (updateKey: string, updateValues: any, callback?: () => void) => {\n    // \uD83D\uDC47 这里改一下方法名\n    getUserStoreDataPath().then((appPath: string) => {\n      // ...\n    });\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这边还需要对应用设置窗口初始化存储路径做一下修改，前往 ",(0,s.jsx)(n.code,{children:"renderer/windowPages/setting"}),"，修改一下 index.tsx 代码，部分代码省略"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/renderer/windowPages/setting/index.tsx\n\n// \uD83D\uDC47 修改成获取 userData 路径的方法\nimport { getUserStoreDataPath } from '@common/utils/appPath';\n\nfunction Setting() {\n  useEffect(() => {\n    // \uD83D\uDC47 读取配置文件内容\n    readGlobalConfigFile().then((value: { [key: string]: any }) => {\n      // 如果存在应用存储路径，则采用\n      if (value?.resumeSavePath) {\n        setResumeSavePath(value?.resumeSavePath);\n      } else {\n        // 否则获取 userData 路径，以 userData 路径为准\n        // 更新 global.config.json 中的应用存储路径字段\n        getUserStoreDataPath().then((appPath: string) => {\n          setResumeSavePath(`${appPath}/resumeCache`);\n          updateGlobalConfigFile('resumeSavePath', `${appPath}/resumeCache`);\n        });\n      }\n    });\n  }, []);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们前面讲到，在导出 PDF 时，是通过读取 ",(0,s.jsx)(n.code,{children:"global.config.json"})," 中的 ",(0,s.jsx)(n.code,{children:"resumeSavePath"})," 字段，以此路径，将我们的简历数据文件写入该路径下的文件夹。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么我们也需要对应做下修改，前往 ",(0,s.jsx)(n.code,{children:"renderer/container/resume/ResumeAction"}),"，修改一下 index.tsx 代码，部分代码省略"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/renderer/container/resume/ResumeAction/index.tsx\n\n// \uD83D\uDC47 修改成获取 userData 路径的方法\nimport { getUserStoreDataPath } from '@common/utils/appPath';\n\n// 导出PDF\nconst exportPdf = () => {\n  toPrintPdf(`${base?.username}+${base?.school}+${work?.job}`);\n  setComponentVisible(false);\n  readGlobalConfigFile().then((value: { [key: string]: any }) => {\n    // 如果存在，以此路径进行简历数据文件的写入\n    if (value?.resumeSavePath) {\n      saveResumeJson(value?.resumeSavePath);\n    } else {\n      // 不存在默认路径（可能都没打开过应用设置窗口）\n      // 则设置默认路径并更新文件内容\n      getUserStoreDataPath().then((appPath: string) => {\n        updateGlobalConfigFile('resumeSavePath', `${appPath}/resumeCache`);\n        saveResumeJson(`${appPath}/resumeCache`);\n      });\n    }\n  });\n};\n\n// 存储数据json\nconst saveResumeJson = (resumeSavePath: string) => {\n  const date = intToDateString(new Date().valueOf(), '_');\n  const prefix = `${date}_${base?.username}_${base?.school}_${work?.job}_${createUID()}.json`;\n  // 如果路径中不存在 resumeCache 文件夹，则默认创建此文件夹\n  if (resumeSavePath && resumeSavePath.search('resumeCache') > -1) {\n    fileAction\n      .canRead(resumeSavePath)\n      .then(() => {\n        fileAction?.write(`${resumeSavePath}/${prefix}`, resume, 'utf8');\n      })\n      .catch(() => {\n        fileAction\n          .mkdirDir(resumeSavePath)\n          .then(() => {\n            fileAction?.write(`${resumeSavePath}/${prefix}`, resume, 'utf8');\n          })\n          .catch(() => {\n            console.log('创建文件夹失败');\n          });\n      });\n  } else {\n    fileAction\n      .mkdirDir(`${resumeSavePath}/resumeCache`)\n      .then(() => {\n        fileAction?.write(\n          `${resumeSavePath}/resumeCache/${prefix}`,\n          resume,\n          'utf8'\n        );\n      })\n      .catch(() => {\n        console.log('创建文件夹失败');\n      });\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第五步：删除 ",(0,s.jsx)(n.code,{children:"appConfig"})," 文件夹"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"因为我们现在的 appConfig 文件夹是存储在应用程序设置文件中，我们可以将其删除。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第六步：修改拷贝文件夹的代码"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["因为本地没有了 appConfig 文件夹，所以 ",(0,s.jsx)(n.code,{children:"copy-webpack-plugin"})," 配置也需要做下修改。我们前往 ",(0,s.jsx)(n.code,{children:"webpack/webpack.render.base.js"})," 做下更改"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\nconst path = require('path');\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: path.resolve(__dirname, '../assets'),\n          to: path.resolve(__dirname, '../dist/assets'),\n        },\n        // \uD83D\uDC47 文件夹都不存在了，还拷贝啥啊\n        // {\n        //   from: path.resolve(__dirname, '../appConfig'),\n        //   to: path.resolve(__dirname, '../dist/appConfig'),\n        // },\n      ],\n    }),\n  ],\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们重新跑一下开发环境的命令，然后进行到制定的 userData 文件夹下，找到 ",(0,s.jsx)(n.code,{children:"Electron"})," 文件夹，看看应用启动之后，会不会生成对应的 ",(0,s.jsx)(n.code,{children:"appConfig"}),"，并携带 ",(0,s.jsx)(n.code,{children:"theme.config.json"})," 和 ",(0,s.jsx)(n.code,{children:"global.config.json"})," 文件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"rm -rf dist\nnpm run start:main\nnpm run start:render\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"经过验证，是没问题的，小伙伴们记住了，这是 userData 的路径，根据你的平台设备，进入对应的路径"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"appData"}),"\xa0 每个用户的应用程序数据目录，默认情况下指向：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"%APPDATA%"}),"\xa0Windows 中"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"$XDG_CONFIG_HOME"}),"\xa0or\xa0",(0,s.jsx)(n.code,{children:"~/.config"}),"\xa0Linux 中"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"~/Library/Application Support"}),"\xa0macOS 中"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"生产环境打包构建会不会有问题呢？走一个完整的打包构建命令"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 1. 删除上一轮打包的 dist 目录和 package 目录\nrm -rf dist package\n// 2. 构建打包Elctron\nnpm run build:main\n// 3. 构建打包 React\nnpm run build:render\n// 4. 通过 electron-builder 构建安装包\nnpm run dist\n"})}),"\n",(0,s.jsxs)(n.p,{children:["打包之后，安装一下，打开应用，在应用启动之后，我们进入到 userData 路径，请注意，此时打包后的应用程序名称是 ",(0,s.jsx)(n.code,{children:"visResumeMook"}),"，我们进去看看"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"开发环境和生产环境均无问题！"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["这时候坑一自然而然也就没了，项目中的 ",(0,s.jsx)(n.code,{children:"appConfig"})," 都删了，哪还会有拷贝失败的问题呢？"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"-坑三切换主题下次进入居然不是上一轮的",children:["\uD83D\uDD28 坑三：切换主题，下次进入居然不是上一轮的",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-坑三切换主题下次进入居然不是上一轮的",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["每次打开应用，你会发现主题色都是黑色，并不是我所期望的上一轮配色。那为什么会是这样呢？我们来看看 ",(0,s.jsx)(n.code,{children:"app/renderer/hooks"})," 下的 ",(0,s.jsx)(n.code,{children:"/useThemeActionHooks.ts"})," 文件代码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function useSelectTheme() {\n  const dispatch = useDispatch();\n  return (themeConfigValues: any) => {\n    // \uD83D\uDC47 在 theme.config.json 存储到是 currentTheme 对象，而不是一个 id，需要改成这样\n    // const prevTheme: string = themeConfigValues?.currentTheme || '';\n    const prevTheme: TSTheme.Item = themeConfigValues?.currentTheme;\n\n    let nextTheme: TSTheme.Item;\n\n    if (themeConfigValues?.themeList.length > 0) {\n      // \uD83D\uDC47 并不是通过 id 去找，而是直接使用当前主题，需要改成这样\n      // if (prevTheme) nextTheme = _.find(themeConfigValues?.themeList, { id: prevTheme }) || initTheme;\n      if (prevTheme) nextTheme = prevTheme || initTheme;\n    } else {\n      nextTheme = initTheme;\n    }\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在开发环境下验证一波，确实无误，打个包看看，走一个构建流程"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 1. 删除上一轮打包的 dist 目录和 package 目录\nrm -rf dist package\n// 2. 构建打包Elctron\nnpm run build:main\n// 3. 构建打包 React\nnpm run build:render\n// 4. 通过 electron-builder 构建安装包\nnpm run dist\n"})}),"\n",(0,s.jsx)(n.p,{children:"\uD83C\uDF08 无问题，稳妥"}),"\n",(0,s.jsxs)(n.h2,{id:"优化-4生产环境下禁止拉伸窗口与进入开发者模式",children:["优化 4：生产环境下禁止拉伸窗口与进入开发者模式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化-4生产环境下禁止拉伸窗口与进入开发者模式",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们进入到主进程 ",(0,s.jsx)(n.code,{children:"app/main/electron.ts"})," 中，修改一下代码"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// \uD83D\uDC47 将这个方法导出，因为我们在 customMenu 用到\nexport function isDev() {\n  return process.env.NODE_ENV === 'development';\n}\n\nconst mainWindow: MyBrowserWindow = new BrowserWindow({\n  width: 1200,\n  height: 800,\n  resizable: isDev(), // 根据环境进行判断\n  webPreferences: {\n    devTools: isDev(), // 根据环境进行判断\n    nodeIntegration: true,\n  },\n});\n\n// 创建应用设置窗口\nconst settingWindow: MyBrowserWindow = new BrowserWindow({\n  width: 720,\n  height: 240,\n  resizable: isDev(), // 根据环境进行判断\n  show: false,\n  frame: false,\n  webPreferences: {\n    devTools: isDev(), // 根据环境进行判断\n    nodeIntegration: true,\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"对应的，我们需要将菜单栏中的功能根据环境不同进行处理。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import _ from 'lodash';\nimport { MyBrowserWindow, isDev } from './electron';\nimport { MenuItemConstructorOptions, shell, app, MenuItem, BrowserWindow } from 'electron';\n\nconst customMenu: (MenuItemConstructorOptions | MenuItem)[] = [\n  // ...\n  // ...\n  {\n    label: '视图',\n    submenu: [\n      // ...\n      // 这里把 `切换开发者工具` 一栏，通过环境动态配置\n    ],\n  },\n];\n\nif (isDev()) {\n  (customMenu[2]?.submenu as any).push({\n    label: '切换开发者工具',\n    role: 'toggleDevTools',\n    accelerator: (() => {\n      if (process.platform === 'darwin') {\n        return 'Alt+Command+I';\n      } else {\n        return 'Ctrl+Shift+I';\n      }\n    })(),\n    click: (item: any, focusedWindow: MyBrowserWindow) => {\n      if (focusedWindow) {\n        focusedWindow.webContents.openDevTools();\n      }\n    },\n  });\n}\n\nexport default customMenu;\n"})}),"\n",(0,s.jsx)(n.p,{children:"这时候在开发环境和生产环境，效果截然不同～"}),"\n",(0,s.jsxs)(n.h2,{id:"最后",children:["最后",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["构建打包属实不易，这过程出现很多问题，但要感谢问题的出现，通过解决问题，我们才有进步。至此我们的打包构建告一段落， ",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commits/chapter-23",target:"_blank",rel:"noopener noreferrer",children:"\uD83D\uDC49 此章节的相关代码在此"}),"，建议配合线上代码，结合小册内容，动手实践。"]})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}let u=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F23.%E6%89%93%E5%8C%85%E7%AF%87-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E7%9A%84%E8%A7%A3%E5%86%B3.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"\uD83D\uDD28 坑一：开发环境凉了",id:"-坑一开发环境凉了",depth:2},{text:"\uD83D\uDD28 坑二：切换主题，数据无法写入 theme.config.json",id:"-坑二切换主题数据无法写入-themeconfigjson",depth:2},{text:"\uD83D\uDD28 坑三：切换主题，下次进入居然不是上一轮的",id:"-坑三切换主题下次进入居然不是上一轮的",depth:3},{text:"优化 4：生产环境下禁止拉伸窗口与进入开发者模式",id:"优化-4生产环境下禁止拉伸窗口与进入开发者模式",depth:2},{text:"最后",id:"最后",depth:2}],title:"23.打包篇-生产环境疑难杂症的解决",headingTitle:"23.打包篇-生产环境疑难杂症的解决",frontmatter:{}}}}]);