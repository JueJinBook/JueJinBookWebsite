"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["84240"],{274477:function(e,n,a){a.r(n),a.d(n,{default:()=>c});var s=a(552676),r=a(740453);function i(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",pre:"pre",code:"code",p:"p",h2:"h2",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"",children:(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,s.jsxs)(n.h1,{id:"5案例四中英文-json-合并工具-node-的文件操作能力---fs",children:["5案例四：[中英文 JSON 合并工具] Node 的文件操作能力 - fs",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5案例四中英文-json-合并工具-node-的文件操作能力---fs",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-!",children:"本节目标：【实现一个中英文 JSON 合并工具】 - 一切皆文件，文件即数据，服务器作为数据的批发市场，文件读写能力成就了调度奇迹。\n"})}),"\n",(0,s.jsx)(n.p,{children:"使用 File System 的时候，就像其他的模块一样，我们把它导进来即可："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const fs = require('fs)\n"})}),"\n",(0,s.jsx)(n.p,{children:"下文的示例代码均省略此句，以节省小册字数。"}),"\n",(0,s.jsxs)(n.h2,{id:"node-的搬砖专业户",children:["Node 的搬砖专业户",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#node-的搬砖专业户",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["工程师经常自嘲是个搬砖的，在我的印象里面，Node 里面的搬砖伙计就是 ",(0,s.jsx)(n.code,{children:"fs"}),"，也就是 File System 这货，一切跟文件相关的操作，都跟它脱不了关系，比如拷贝一个文件，在 Node 里面非常简单："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.copyFileSync('./1.txt', './2.txt')\n"})}),"\n",(0,s.jsx)(n.p,{children:"无论是 Windows 还是 Linux 系统，它里面的视频、语音、图片、JSON 文件、二进制的程序压缩包...，都是文件，文件散布在各个我们称之为文件夹的地方，而文件夹在本质上也是一种文件，所以一切皆文件，而文件本质上是带特殊属性的数据，所以我们往往提到跟操作系统交互，跟系统底层交互，这里面有相当一部分其实是在跟文件交互，跟数据交互，本质上是在操作系统里面，对于数据的阅读能力、输入输出能力，跟数据库的增删改查行为差不了太多。我们人作为一种物种，不也是如此么，被创建，被销毁，每天都在更新，还能被打上身份标签拎出来识别，只不过多了所谓灵魂、思想和情感这些很难量化的数据而已。"}),"\n",(0,s.jsxs)(n.p,{children:["在 Node 里面有很多核心的能力，但最原始最基础最通用的能力，其实就是文件系统交互能力 - ",(0,s.jsx)(n.code,{children:"fs"}),"，以及网络请求的处理能力 - ",(0,s.jsx)(n.code,{children:"http"}),"，正是这两块能力彻底打破了前后端的边界，从前用 JS 是没办法操纵磁盘文件的，通过 JS 也没办法处理网络请求与返回，现在有了 Node 这个混搭各种底层的运行框架，搬砖就变得可能了。"]}),"\n",(0,s.jsxs)(n.p,{children:["那我们就进入这个能力里面一窥究竟吧，首先看看它的 ",(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v11.x/docs/api/fs.html",target:"_blank",rel:"noopener noreferrer",children:"File System API"}),"，扳扳指头算，密密麻麻百来个方法挂在 fs 上面，大部分都分为同步的和异步两个版本，比如创建文件夹有这样的写法："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.mkdir(path[, options], callback)\nfs.mkdirSync(path[, options])\n"})}),"\n",(0,s.jsx)(n.p,{children:"其实不光 mkdir，其他大部分的文件方法，都有 Sync 的版本，所以这百十个方法除去一半，其实也就剩下了几十个而已，无非一个是 callback 回调函数来异步获取结果，一个则是同步执行，阻滞它后面的代码执行，大家不用怕他们太多记不住，用的时候来查 API 就行，那到底同步和异步在底层执行上有什么区别呢，我们先挑选几个常用的 API，熟悉下它们的用法后，自然就有答案了。"}),"\n",(0,s.jsxs)(n.h2,{id:"读文件能力",children:["读文件能力",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#读文件能力",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"把数据从文件里面读出来，是一个刚需，比如一个项目在启动时候，需要把配置文件读进来，可以这样做："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.readFile('./config.json', function (err, data) {\n  if (err) throw err\n  loadServer(data)\n})\n\n// 或者换同步的方式\nconst data = fs.readFileSync('./config.json')\nloadServer(data)\n"})}),"\n",(0,s.jsx)(n.p,{children:"既然活都一样干，那什么时候该用同步什么时候该用异步呢，我的建议是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"对于一次性加载进来，不会二次加载的，比如项目启动之初，或者过程中只读取一次配置文件的，可以用 Sync/同步的方法"}),"\n",(0,s.jsx)(n.li,{children:"对于体积较大的，可能需要多次读写的，有可能影响到业务流程的响应速度的，改用异步的方式做"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"特殊情况就特殊处理，如果实在不知道选哪种，那就保险起见选异步的方式做。如果采用同步的方式做，需要注意捕获错误，避免程序崩溃，比如这样写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let data\ntry {\n  data = fs.readFileSync('./config.json')\n} catch (err) {\n  console.log('配置文件读取出错，及时检查服务')\n  // 其他的一些通知 log(err) 处理等等\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们后面的示例代码都选用异步的方式来写，同步的不再赘述。"}),"\n",(0,s.jsx)(n.p,{children:"一旦我们用异步的方式来写代码，就会面临 Node 社区早些年一直头疼的问题，就是 callback hell - 回调地狱，表现就是这样的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.readFile('./cfg1.json', function (err, data1) {\n  fs.readFile(data1.cfgPath, function (err, data2) {\n    fs.readFile(data2.cfgPath, function (err, data3) {\n      fs.readFile(data3.cfgPath, function (err, data4) {\n        fs.readFile(data4.cfgPath, function (err, data5) {\n          // ...\n        })\n      })\n    })\n  })\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"当然现实中不会这么变态（其实也不排除比这还要变态），这些异步操作有先后依赖关系，按照顺序执行，这种代码写起来维护起来都很恶心，除了用同步（Sync）的方式做，社区也衍生了很多解决方案，甚至直接推动了整个 Javascript 语言特性的发展，比如 GeneratorFunction 迭代执行的函数，比如 Async 异步函数，比如 Promise 规范以及实现了 Promise 规范的一系列库等等，而 Node 里面，新版里面 Promise 已经挂载到了 Global 下面可以直接使用。"}),"\n",(0,s.jsx)(n.p,{children:"那我们用 Promise 改写一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 先把 readFile 封装到一个 Prmoise 里面\nconst readFile = filePath => new Promise((resolve, reject) => {\n  fs.readFile(filePath, (err, data) => resolve(data))\n}\n\n// 然后通过 Promise..then 链式调用\nreadFile('./cfg1.json')\n  .then(data => readFile(data.cfgPath))\n  .then(data => readFile(data.cfgPath))\n  .then(data => readFile(data.cfgPath))\n  .then(data => {\n    console.log('data4.cfgPath:', data)\n  })\n"})}),"\n",(0,s.jsx)(n.p,{children:"改成了 Promise 的链式调用后，代码嵌套好多了，但是一个冗长的链条，依然看着不太舒服，想要获取链路头部的一些数据也需要额外的包装，不是很方便。干脆通过 Async function 再来重构下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const readFile = filePath => new Promise((resolve, reject) => {\n  fs.readFile(filePath, (err, data) => resolve(data))\n}\n\n// 放到 async function 里面逐个调用\nasync function readCfg () {\n  const data1 = await readFile('./cfg1.json)\n  const data2 = await readFile(data1.cfgPath)\n  const data3 = await readFile(data2.cfgPath)\n  const data4 = await readFile(data3.cfgPath)\n  console.log(data4)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样写，就看着自然多了，所有的异步 callback 都可以用同步的方式来写，不光 readFile，fs 里面任何的异步方法，都可以用这种方式包装。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.readFile(path[, options], callback)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这是 readFile 的 API，其实我最早最早接触 ",(0,s.jsx)(n.code,{children:"path[, options], callback"})," 这种参数形式的时候，我是真心看不懂的，不明觉厉，直到后来才意识到，原来这里的 ",(0,s.jsx)(n.code,{children:"[, options]"})," 意思是这个参数可以省略不写，所以 readFile 接收三个参数，文件路径，配置和回调，在 options 这里，可以直接用 ",(0,s.jsx)(n.code,{children:"utf8"})," 来替代，通过指定编码，就可以拿到的 指定编码解析后的字符串，也就是："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.readFile('./a.txt', 'utf8', function(err, data) {})\n"})}),"\n",(0,s.jsx)(n.p,{children:"那如果是第二个参数留空，也不指定 encoding，那么返回的 data 就是一个 Buffer 形式表示的二进制数据了，如果指定的话，就是这样来写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.readFile('./a.txt', {\n  flag: 'r+',\n  encoding: 'utf8'\n}, function(err, data) {})\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个 options 可以是一个对象，除了 encoding，还可以配置 flag 的值，flag 按我的理解就是标志位，表示文件的打开模式，标识是否具有某个权限。"}),"\n",(0,s.jsx)(n.p,{children:"熟悉 UNIX 系统的童鞋就会知道，UNIX 的文件权限标志位用 9 个码位标识，3 个码位一组，共 3 组。3 个码位依次标识可读，可写，可执行，1 表示有权限，0 表示没权限。3 组依次表示登录用户，同组用户，其他用户的权限。比如 r 是对打开的文件进行只读, 带上加号表示的是对打开的文件进行读写，如果该文件不存在，会抛出错误，如果是 w+ 的话，同样是表示读写，但是文件不存在的话，会创建一个，并不会抛出错误，这些标志位可以参考如下列表："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"r 打开文本文件进行读取，数据流位置在文件起始处"}),"\n",(0,s.jsx)(n.li,{children:"r+ 打开文本文件进行读写，数据流位置在文件起始处"}),"\n",(0,s.jsx)(n.li,{children:"w 如果文件存在，将其清零，不存在创建写入文件。数据流位置在文件起始处"}),"\n",(0,s.jsx)(n.li,{children:"w+ 打开文件进行读写，如果文件存在，将其清零，不存在创建写入文件。数据流位置在文件起始处"}),"\n",(0,s.jsx)(n.li,{children:"a 打开文件写入数据，如果文件存在，将其清零，不存在创建写入文件。数据流位置在文件结尾处，此后的写操作都将数据追加到文件后面"}),"\n",(0,s.jsx)(n.li,{children:"a+ 打开文件进行文件读写，如果文件存在，将其清零，不存在创建写入文件。数据流位置在文件结尾处，此后的写操作都将数据追加到文件后面"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这些在官方的文档里都有介绍，其实大家只要理解了 read write add 这些模式的意义，等到具体使用的时候，根据场景来设置这个 flag 就可以了。"}),"\n",(0,s.jsxs)(n.h3,{id:"打开文件",children:["打开文件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#打开文件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"读文件的时候，文件并不一定存在，我们有时候会直接来打开这个文件，可以通过 fs 的 open 方法对文件进行打开操作："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.open('./a.txt', 'w', function(err, fd) {\n  console.log(fd)\n  // fs.open 打开了文件，当然使用后应该关闭文件，通过 fs.close 方法可以关闭打开的文件\n  fs.close(fd, callback)\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"打开文件后，就可以通过文件描述符对文件进行读写操作了，那么 open 接收的参数，第一个是文件名，第二个是标志位，最后一个参数就是回调函数，回调函数中第二个参数，fd 表示打开文件的文件描述符，我们要的就是这货。"}),"\n",(0,s.jsx)(n.p,{children:"等到文件打开后，就可以使用 fs.read() 方法进行更加精细的读取，所谓精细的控制，就是说 read 可以传入一大堆参数："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.read(fd, buffer, offset, length, position, callback)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["fd 参数，文件描述符，通过 fs.open 拿到，buffer 参数，是把读取的数据写入这个对象，是个 Buffer 对象，offset 参数，写入 buffer 的起始位置，length 参数，写入 buffer 的长度，position 参数，从文件的什么位置开始读。然后 ",(0,s.jsx)(n.code,{children:"callback(err, bytesRead, buffer)"})," 回调方法传入三个参数，第一个参数是出现异常抛出的 err，第二个参数是读取了多少 bytes，最后一个是 buffer 读取到的数据。"]}),"\n",(0,s.jsx)(n.p,{children:"在读取前需要创建一个用于保存文件数据的缓冲区，缓冲区数据最终会被传递到回调函数中："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.open('./a.txt', 'r', function (err, fd) {\n  var buf = new Buffer(1024)\n  var offset = 0\n  var len = buf.length\n  // var pos = 2000\n  var pos = 101\n  // 这里我定义了参数，文件打开后，会从第 100 个字节开始，读取其后的 1024 个字节的数据。读取完成后，回调方法中可以处理读取到的的缓冲的数据了\n  fs.read(fd, buf, offset, len, pos, function(err, bytes, buffer) {\n    console.log('读取了' + bytes + ' bytes')\n    //数据已被填充到 buf 中\n    console.log(buf.slice(0, bytes).toString())\n  })\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"写文件",children:["写文件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#写文件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"对应读文件，就是写文件，第一个参数是文件名，第二个是要写入的 buffer 数据，第三个是可省略的参数，跟 readFile 方法一样，配置读写权限和编码格式，设置 flag 为 w, 如果文件不存在会创建一个文件，这种写入方式会全部删除旧有的数据，然后再写入数据,最后一个是回调方法"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"var data = new Buffer('Hi Juejin!')\nfs.writeFile('./b.txt', data, {\n  flag: 'w',\n  encoding: 'utf8'\n}, function(err) {})\n"})}),"\n",(0,s.jsx)(n.p,{children:"写文件还可以更加精细控制，通过 write 方法，类似 read 方法，write 方法也接受许多参数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.write(fd, buffer, offset, length, position, callback)\n"})}),"\n",(0,s.jsx)(n.p,{children:"首先第一个参数是 fd，通过 fs.open 可以拿到文件描述符， write 方法通过这个找到文件的所在位置， 第二个参数是 buffer 缓冲区，也就是即将被写入到这个文件的二进制数据，buffer 尺寸的大小设置最好是 8 的倍数，这样效率比较高， 第三个参数是 offset，也就是 buffer 写入的偏移量，一般默认从 0 开始写，每写一次，就修改一下这个偏移量，从而保证数据的连续和完整性，第四个参数是 length，也就是要写入的 buffer 的字节数长度，通过 offset 和 length 的结合，来指定哪些数据应该被写入到文件中，第五个参数是 position，用来指定写入到文件的什么位置，如果是 null，将会从当前文件指针的位置开始写入，最后跟着的参数就是一个 回调函数 callback，里面传递了三个参数，第一个毫无疑问是错误对象 err，第二个是写入了多少 bytes，第三个是缓冲区写入的数据。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.open('./c.txt', 'a', function (err, fd) {\n  var buf = new Buffer('I Love Juejin')\n  var offset = 0\n  var len = buf.length\n  var pos = 100\n\n  fs.write(fd, buf, offset, len, pos, function(err, bytes, buffer) {\n    console.log('写入了 ' + bytes + ' bytes')\n    //数据已被填充到 buf 中\n    console.log(buf.slice(0, bytes).toString())\n    fs.close(fd, function(err) {})\n  })\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样竟然可以把 buffer 数据给存储到了文件中，read 还有第二种用法，就是不直接写入 buffer 数据，而是写入字符串，怎么做呢？"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.open('./c.txt', 'a', function (err, fd) {\n  var data = 'I Love Juejin'\n\n  // 第一个参数依然是文件描述符，第二个是写入的字符串，第三个是写入文件的位置，第四个是编码格式，最后一个是回调函数，回调函数第一个参数是异常，第二个是 指定多少字符数将被写入到文件，最后一个是返回的字符串\n  fs.write(fd, data, 0, 'utf-8', function(err, written, string) {\n    console.log(written)\n    console.log(string)\n\n    fs.close(fd, function(err) {})\n  })\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"学会了读写的这些方法，我们就可以来实现一个小工具了，来检查一张图片是不是 PNG 格式，因为 PNG 头部 8 bytes是固定的，所以拿到文件前 8 bytes就可以作为判断的条件。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// png.js\nfs.open('11.png', 'r', function(err, fd) {\n  var header = new Buffer([137, 80, 78, 71, 13, 10, 26, 10])\n  var buf = new Buffer(8)\n\n  fs.read(fd, buf, 0, buf.length, 0, function(err, bytes, buffer) {\n    if (header.toString() === buffer.toString()){\n      console.log('是 PNG 图片')\n    }\n    else {\n      console.log('不是 PNG 图片')\n    }\n  })\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"先是用 fs.open 打开 png 文件，然后 header 数据是 PNG 图片标识数据，位于 PNG 图片前 8 个 bytes，只要读取文件前 8 bytes 数据，然后对比一下数据是否一致就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"那么关于写，有时候我们就想在文件结尾追加一些内容，比如每次服务器访问，我们就对日志文件增加一行记录，这时候，fs 的 appendFile 方法就非常顺手："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"fs.appendFile('./c.txt', 'Hello Juejin', {\n  encoding: 'utf8'\n}, function(err) {\n  console.log('done!')\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"目录读写能力",children:["目录读写能力",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#目录读写能力",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"除了文件，文件夹也可以读写，也即目录可以创建，删除，支持遍历，创建非常简单，命令行里面我们通过是 makeDir 来创建，fs 模块也有一个 makedir 方法，传入目录的完整路径和路径名，就可以了，默认的权限是 0777，这个就不演示了，我们直接看如何读取目录，也是直接上一个代码，实现一个小功能，把某个目录下的 js 文件都给遍历出来，然后放到一个数组里。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 使用 fs.readdir 读取目录，重点其回调函数中files对象\n// fs.readdir(path, callback);\n\n/**\n * path, 要读取目录的完整路径及目录名；\n * [callback(err, files)], 读完目录回调函数；err错误对象，files数组，存放读取到的目录中的所有文件名\n */\n\nconst walk = function(path) {\n  fs\n    .readdirSync(path)\n    .forEach(function(file) {\n      const newPath = path + '/' + file\n      const stat = fs.statSync(newPath)\n\n      if (stat.isFile()) {\n        if (/\\.js/.test(file)) {\n          files.push(file)\n        }\n      } else if (stat.isDirectory()) {\n        walk(newPath)\n      }\n    })\n}\nwalk(filesPath)\nconsole.log(files.join('\\r\\n'))\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"编程练习---中英文-json-合并工具",children:["编程练习 - 中英文 JSON 合并工具",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编程练习---中英文-json-合并工具",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"当我们开发一个国际网站时候，有时候需要处理 i18n 的内容，而页面比较多的时候，我们不方便用一个大而全的 JSON 文件来囊括所有的翻译内容，我们可能会把文案按照页面区分后，最终再把它们拼成一份，比如有一个 pagea.json:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n  "signup": "注册"    \n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"有一个 pageb.json："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n  "menu": "菜单"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"希望把它们合并成 data.json:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n  "signup": "注册",\n  "menu": "菜单"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"代码可以这样写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const fs = require('fs')\nconst path = require('path')\n\n// 判断目标路径的文件存在与否\nconst exists = filePath => fs.existsSync(filePath)\nconst jsonPath = process.argv[2]\n\nif (!jsonPath) {\n  console.log('没有传 JSON 目录参数哦！')\n  process.exit(1)\n}\n\nconst rootPath = path.join(process.cwd(), jsonPath)\n// 遍历所有文件\nconst walk = (path) => fs\n  .readdirSync(path)\n  .reduce((files, file) => {\n    const filePath = path + '/' + file\n    const stat = fs.statSync(filePath)\n\n    if (stat.isFile()) {\n      if (/(.*)\\.(json)/.test(file)) {\n        return files.concat(filePath)\n      }\n    }\n    return files\n  }, [])\n\n// 合并文件内容\nconst mergeFileData = () => {\n  const files = walk(rootPath)\n\n  if (!files.length) process.exit(2)\n\n  const data = files\n    .filter(exists)\n    .reduce((total, file) => {\n      const fileData = fs.readFileSync(file)\n      const basename = path.basename(file, '.json')\n      let fileJson\n\n      try {\n        fileJson = JSON.parse(fileData)\n      } catch (err) {\n        console.log('读出出错', file)\n        console.log(err)\n      }\n\n      total[basename] = fileJson\n      return total\n    }, {})\n\n  fs.writeFileSync('./data.json', JSON.stringify(data, null, 2))\n}\n\nmergeFileData()\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这一节的内容略显枯燥，我们对读写总结一下，无论读写，都有两种方式，一种粗矿的，一种精细化的，精细化的控制，需要先 open 一个文件，然后操作读写，但需要手工调用 close 方法关闭文件，这种方式适合于多次写入或读取。粗狂的读写是一次性服务的，直接调用 writeFile/appendFile/readFile 方法，只会写入或读取一次，在它的内部自动调用了 close 方法，另外呢，对于 write 方法，因为多次对同一文件进行 write 并不安全，必须等到 callback 调用才可以，官方推荐是使用 stream 方式替代，也就是 createWriteStream，关于 Stream 我们就放到后面的小节中学习。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F5%E6%A1%88%E4%BE%8B%E5%9B%9B%EF%BC%9A%5B%E4%B8%AD%E8%8B%B1%E6%96%87%20JSON%20%E5%90%88%E5%B9%B6%E5%B7%A5%E5%85%B7%5D%20Node%20%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%83%BD%E5%8A%9B%20-%20fs.md"]={toc:[{text:"",id:"",depth:3},{text:"Node 的搬砖专业户",id:"node-的搬砖专业户",depth:2},{text:"读文件能力",id:"读文件能力",depth:2},{text:"打开文件",id:"打开文件",depth:3},{text:"写文件",id:"写文件",depth:3},{text:"目录读写能力",id:"目录读写能力",depth:3},{text:"编程练习 - 中英文 JSON 合并工具",id:"编程练习---中英文-json-合并工具",depth:3},{text:"总结",id:"总结",depth:3}],title:"5案例四：[中英文 JSON 合并工具] Node 的文件操作能力 - fs",headingTitle:"5案例四：[中英文 JSON 合并工具] Node 的文件操作能力 - fs",frontmatter:{}}}}]);