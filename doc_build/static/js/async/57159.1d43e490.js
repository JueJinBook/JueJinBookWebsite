"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57159"],{955074:function(e,n,l){l.r(n),l.d(n,{default:()=>g});var t=l(552676),s=l(740453);let r=l.p+"static/image/1aec0aedb60ea575890faec1259c9098.e3e4b3ff.webp",a=l.p+"static/image/5a7c0dd3bb0e7c38285091dfd99e1ef1.9d669925.webp",i=l.p+"static/image/b57ea10e08494d46e1988ed4893511e8.b4e31d70.webp",o=l.p+"static/image/4f2d260ef1cf98fc5bfce90f8760602c.2ba556ce.webp",c=l.p+"static/image/88a0e16292a634c4b4859cce40ee3113.c151993d.webp",d=l.p+"static/image/fea75b332c5337ccd0e91eda054a08cc.46d69b8b.webp",p=l.p+"static/image/254750d188aa6d471d0dcf78a7407dae.e28399bc.webp",u=l.p+"static/image/d1cff782f47a29638c961c67cc36b8db.d11f8b72.webp",h=l.p+"static/image/fef24737fff2f4cab7ab8229d89a83fa.64509ff4.webp";function m(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h4:"h4",ul:"ul",li:"li",strong:"strong",pre:"pre",blockquote:"blockquote",img:"img"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"35vue3-实战之首页配置",children:["35.Vue3 实战之首页配置",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#35vue3-实战之首页配置",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["上一小节，我们开始了内容页部分的开发，分别使用了 ",(0,t.jsx)(n.code,{children:"ElCard"}),"、",(0,t.jsx)(n.code,{children:"ElPopover"})," 等常用该组件。这两个组件在很多业务场景都非常的实用，同学们在开发后台管理系统的时候，尽量合理的利用好组件库给我提供的组件，减少自己编写组件，提高工作效率。"]}),"\n",(0,t.jsxs)(n.p,{children:["本小节将为同学们带来后台管理系统的重头戏，",(0,t.jsx)(n.code,{children:"Table"}),"、",(0,t.jsx)(n.code,{children:"Upload"}),"、",(0,t.jsx)(n.code,{children:"Dialog"})," 组件的使用，以及遇到多个类似页面的时候，如何通用一个组件。"]}),"\n",(0,t.jsxs)(n.h4,{id:"本章节知识点",children:["本章节知识点",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章节知识点",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["需要注册的组件：",(0,t.jsx)(n.code,{children:"ElTable"}),"、",(0,t.jsx)(n.code,{children:"ElUpload"}),"、",(0,t.jsx)(n.code,{children:"ElDialog"}),"、",(0,t.jsx)(n.code,{children:"ElPagination"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"弹窗组件的封装。"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"多页面公用同一个组件。"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"首页轮播图配置",children:["首页轮播图配置",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#首页轮播图配置",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["首先打开 ",(0,t.jsx)(n.code,{children:"App.vue"})," 添加轮播图的 ",(0,t.jsx)(n.code,{children:"Menu"}),"，顺便把图表都更换为符合语义的图表："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"template"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'...\n<el-menu\n  background-color="#222832"\n  text-color="#fff"\n  :router="true"\n    :default-openeds="defaultOpen"\n    :default-active=\'currentPath\'\n>\n  <el-sub-menu index="1">\n    <template #title>\n      <span>Dashboard</span>\n    </template>\n    <el-menu-item-group>\n      <el-menu-item index="/"><el-icon><Odometer /></el-icon>首页</el-menu-item>\n      <el-menu-item index="/add"><el-icon><Plus /></el-icon>添加商品</el-menu-item>\n    </el-menu-item-group>\n  </el-sub-menu>\n    <el-sub-menu index="2">\n    <template #title>\n      <span>首页配置</span>\n    </template>\n    <el-menu-item-group>\n      <el-menu-item index="/swiper"><el-icon><Picture /></el-icon>轮播图配置</el-menu-item>\n    </el-menu-item-group>\n  </el-sub-menu>\n</el-menu>\n...\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"script"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script setup>\n  ...\n  const state = reactive({\n    showMenu: true,\n    defaultOpen: ['1', '2'],\n    currentPath: '/',\n  })\n  router.beforeEach((to, from, next) => {\n    if (to.path == '/login') {\n      // 如果路径是 /login 则正常执行\n      next()\n    } else {\n      // 如果不是 /login，判断是否有 token\n      if (!localGet('token')) {\n        // 如果没有，则跳至登录页面\n        next({ path: '/login' })\n      } else {\n        // 否则继续执行\n        next()\n      }\n    }\n    state.showMenu = !noMenu.includes(to.path)\n    state.currentPath = to.path\n    document.title = pathMap[to.name]\n  })\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["首先，上述 ",(0,t.jsx)(n.code,{children:"template"})," 模板中，将 ",(0,t.jsx)(n.code,{children:"icon"})," 都替换为符合标签语义的字符。"]}),"\n",(0,t.jsxs)(n.p,{children:["其次，给 ",(0,t.jsx)(n.code,{children:"el-menu"})," 组件添加了两个属性，分别是 ",(0,t.jsx)(n.code,{children:"default-openeds"})," 和 ",(0,t.jsx)(n.code,{children:"default-active"}),"，前者代表默认打开的 ",(0,t.jsx)(n.code,{children:"el-sub-menu"})," 索引（代码中默认赋值为全部打开），后者代表当前选中菜单项的高亮。"]}),"\n",(0,t.jsxs)(n.p,{children:["最后，在 ",(0,t.jsx)(n.code,{children:"script"})," 逻辑中，通过路由监听函数的回调，设置当前选项高亮："]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"state.currentPath = to.path"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["上述所做的事情，只是让左侧的栏目显示出“轮播图配置”，而点击它之后，右侧的内容并没有发生变化。那是因为浏览器路径 ",(0,t.jsx)(n.code,{children:"/swiper"})," 下，没能找到匹配的页面组件。"]}),"\n",(0,t.jsxs)(n.p,{children:["所以需要在 ",(0,t.jsx)(n.code,{children:"views"})," 文件夹下新建页面组件 ",(0,t.jsx)(n.code,{children:"Swiper.vue"}),"，如下所示："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"\x3c!--Swiper.vue--\x3e\n<template>\n  swiper\n</template>\n\n<script setup>\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["其次，在 ",(0,t.jsx)(n.code,{children:"router/index.js"})," 下，新增路由配置项："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import Swiper from '@/views/Swiper.vue'\n\n...\n{\n  path: '/swiper',\n  name: 'swiper',\n  component: Swiper\n}\n...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["最后，不要忘记每次新增页面需要增加一个头部的显示，打开 ",(0,t.jsx)(n.code,{children:"utils/index.js"}),"，添加头部 ",(0,t.jsx)(n.code,{children:"pathMap"})," 配置："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const pathMap = {\n  index: '首页',\n  login: '登录',\n  add: '添加商品',\n  swiper: '轮播图配置',\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"此时重新启动项目，如下所示表示页面已经成功创建："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["接下来准备在 ",(0,t.jsx)(n.code,{children:"Swiper.vue"})," 文件内，制作页面，首先做如下修改："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"template"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<template>\n  <el-card class="swiper-container">\n    <el-table\n      :load="state.loading"\n      :data="state.tableData"\n      tooltip-effect="dark"\n      style="width: 100%"\n     >\n      <el-table-column\n        type="selection"\n        width="55">\n      </el-table-column>\n      <el-table-column\n        label="轮播图"\n        width="200">\n        <template #default="scope">\n          <img style="width: 150px;height: 150px" :src="scope.row.carouselUrl" alt="轮播图">\n        </template>\n      </el-table-column>\n      <el-table-column\n        label="跳转链接"\n        >\n        <template #default="scope">\n          <a target="_blank" :href="scope.row.redirectUrl">{{ scope.row.redirectUrl }}</a>\n        </template>\n      </el-table-column>\n      <el-table-column\n        prop="carouselRank"\n        label="排序值"\n        width="120"\n      >\n      </el-table-column>\n      <el-table-column\n        prop="createTime"\n        label="添加时间"\n        width="200"\n      >\n      </el-table-column>\n    </el-table>\n  </el-card>\n</template>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["引入 ",(0,t.jsx)(n.code,{children:"el-card"})," 作为外层包裹，在内部直接引入 ",(0,t.jsx)(n.code,{children:"el-table"}),"。这里注意",(0,t.jsx)(n.code,{children:":load"})," 属性用于数据加载之前的等待动画，但是我在之前的版本是使用的 ",(0,t.jsx)(n.code,{children:"v-loading"}),"，后面官方好像是替换了这个属性的名称，导致我一直报错。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"el-table-column"})," 提供具名插槽，并且可以通过 ",(0,t.jsx)(n.code,{children:'#default="scope"'}),"，拿到每一项的单独数据对象，可以在模板中进行使用，如 ",(0,t.jsx)(n.code,{children:"scope.row.carouselUrl"}),"。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["从这件事情可以看出，目前还处于 ",(0,t.jsx)(n.code,{children:"beta"})," 版本的 ",(0,t.jsx)(n.code,{children:"element-plus"})," 还存在一些不稳定因素，代码随时会有优化的可能性。大家在使用的时候，遇到问题，及时查看文档。"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"script"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script setup>\nimport { onMounted, reactive, ref } from 'vue'\nimport axios from '@/utils/axios'\n\nconst state = reactive({\nloading: false, // 控制加载动画\ntableData: [], // 数据列表\ncurrentPage: 1, // 当前页数\npageSize: 10, // 每页请求数\n})\n\nonMounted(() => {\ngetCarousels()\n})\n// 获取轮播图列表\nconst getCarousels = () => {\nstate.loading = true\naxios.get('/carousels', {\n  params: {\n    pageNumber: state.currentPage,\n    pageSize: state.pageSize\n  }\n}).then(res => {\n  state.tableData = res.list\n  state.loading = false\n})\n}\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"script"})," 的逻辑也很直观，就是通过 ",(0,t.jsx)(n.code,{children:"axios.get"})," 获取表格数据，赋值给 ",(0,t.jsx)(n.code,{children:"tableData"})," 进行数据渲染。"]}),"\n",(0,t.jsx)(n.p,{children:"显示效果如下图所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"此时，需要在头部添加两个操作按钮：「增加」和「批量删除」，「增加」按钮的功能是点击后弹出表单，填写完之后调用生成轮播图配置接口，随后刷新列表。"}),"\n",(0,t.jsxs)(n.p,{children:["接下来在 ",(0,t.jsx)(n.code,{children:"components"})," 下新建 ",(0,t.jsx)(n.code,{children:"DialogAddSwiper.vue"})," 组件，代码如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"template"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'\x3c!--DialogAddSwiper.vue--\x3e\n<template>\n  <el-dialog\n    :title="type == \'add\' ? \'添加轮播图\' : \'修改轮播图\'"\n    v-model="state.visible"\n    width="400px"\n  >\n    <el-form :model="state.ruleForm" :rules="state.rules" ref="formRef" label-width="100px" class="good-form">\n      <el-form-item label="图片" prop="url">\n        <el-upload\n          class="avatar-uploader"\n          :action="state.uploadImgServer"\n          accept="jpg,jpeg,png"\n          :headers="{\n            token: state.token\n          }"\n          :show-file-list="false"\n          :before-upload="handleBeforeUpload"\n          :on-success="handleUrlSuccess"\n        >\n          <img style="width: 200px; height: 100px; border: 1px solid #e9e9e9;" v-if="state.ruleForm.url" :src="state.ruleForm.url" class="avatar">\n          <i v-else class="el-icon-plus avatar-uploader-icon"></i>\n        </el-upload>\n      </el-form-item>\n      <el-form-item label="跳转链接" prop="link">\n        <el-input type="text" v-model="state.ruleForm.link"></el-input>\n      </el-form-item>\n      <el-form-item label="排序值" prop="sort">\n        <el-input type="number" v-model="state.ruleForm.sort"></el-input>\n      </el-form-item>\n    </el-form>\n    <template #footer>\n      <span class="dialog-footer">\n        <el-button @click="state.visible = false">取 消</el-button>\n        <el-button type="primary" @click="submitForm">确 定</el-button>\n      </span>\n    </template>\n  </el-dialog>\n</template>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["从头分析一下代码，首先通过 ",(0,t.jsx)(n.code,{children:"type"})," 变量控制是新增或是编辑，之后通过 ",(0,t.jsx)(n.code,{children:"visible"})," 变量控制弹窗的显示隐藏，通过 ",(0,t.jsx)(n.code,{children:"ruleForm"})," 和 ",(0,t.jsx)(n.code,{children:"rules"})," 控制表单的数据和验证规则，",(0,t.jsx)(n.code,{children:"el-upload"})," 用于控制图片上传，",(0,t.jsx)(n.code,{children:"el-upload"})," 接受几个参数，参数释义如下："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"action：上传接口，这边需要服务端提供。"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["accept：控制上传的文件后缀，目前这个参数并不生效，后面是通过 ",(0,t.jsx)(n.code,{children:"before-upload"})," 来控制上传的文件。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"headers：上传接口调用时，携带的请求头数据，项目中需要串 token 数据，因为这样才有权限调用上传接口，否则会报错。"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"on-success：成功回调方法，通常会在这里给变量赋值。"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"form"})," 表单的使用和之前登录注册章节讲过的类似，这里不作赘述。"]}),"\n",(0,t.jsx)(n.p,{children:"接下来是逻辑部分，代码如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"script"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script setup>\nimport { reactive, ref } from 'vue'\nimport axios from '@/utils/axios'\n// uploadImgServer 公用图片上传接口，我将其统一封装在 /utils/index.js 文件中\nimport { localGet, uploadImgServer } from '@/utils'\nimport { ElMessage } from 'element-plus'\n\nconst props = defineProps({\n  type: String, // add 为新增；edit 为编辑\n  reload: Function // table 刷新的方法\n})\n// formRef 用于表单验证控制\nconst formRef = ref(null)\nconst state = reactive({\n  uploadImgServer,\n  token: localGet('token') || '', // 用于调用上传图片接口是，放在请求头上的 token\n  visible: false, // 控制弹窗的显示隐藏\n  ruleForm: {\n    url: '',\n    link: '',\n    sort: ''\n  },\n  rules: {\n    url: [\n      { required: 'true', message: '图片不能为空', trigger: ['change'] }\n    ],\n    sort: [\n      { required: 'true', message: '排序不能为空', trigger: ['change'] }\n    ]\n  },\n  id: ''\n})\n// 获取详情\nconst getDetail = (id) => {\n  axios.get(`/carousels/${id}`).then(res => {\n    state.ruleForm = {\n      url: res.carouselUrl,\n      link: res.redirectUrl,\n      sort: res.carouselRank\n    }\n  })\n}\n// 上传之前，控制上传的文件。\nconst handleBeforeUpload = (file) => {\n  const sufix = file.name.split('.')[1] || ''\n  if (!['jpg', 'jpeg', 'png'].includes(sufix)) {\n    ElMessage.error('请上传 jpg、jpeg、png 格式的图片')\n    return false\n  }\n}\n// 上传图片\nconst handleUrlSuccess = (val) => {\n  state.ruleForm.url = val.data || ''\n}\n// 开启弹窗，此方法将在父组件，通过 ref 直接调用。\nconst open = (id) => {\n  state.visible = true\n  // 如果带着 id，则是编辑，否则为新增\n  if (id) {\n    state.id = id\n    getDetail(id)\n  } else {\n    state.ruleForm = {\n      url: '',\n      link: '',\n      sort: ''\n    }\n  }\n}\n// 关闭弹窗\nconst close = () => {\n  state.visible = false\n}\n// 提交表单方法\nconst submitForm = () => {\n  console.log(formRef.value.validate)\n  formRef.value.validate((valid) => {\n    // valid 为是否通过表单验证的变量\n    if (valid) {\n      if (props.type == 'add') {\n        // 增加用 axios.post\n        axios.post('/carousels', {\n          carouselUrl: state.ruleForm.url,\n          redirectUrl: state.ruleForm.link,\n          carouselRank: state.ruleForm.sort\n        }).then(() => {\n          ElMessage.success('添加成功')\n          state.visible = false\n          if (props.reload) props.reload()\n        })\n      } else {\n        // 编辑用 axios.put\n        axios.put('/carousels', {\n          carouselId: state.id,\n          carouselUrl: state.ruleForm.url,\n          redirectUrl: state.ruleForm.link,\n          carouselRank: state.ruleForm.sort\n        }).then(() => {\n          ElMessage.success('修改成功')\n          state.visible = false\n          if (props.reload) props.reload()\n        })\n      }\n    }\n  })\n}\n// 后续我们会在外面使用该组件内部的方法属性，通过 <script setup> 形式编写的组件，需通过 defineExpose 方法，将属性暴露出去。\ndefineExpose({ open, close })\n<\/script>\n"})}),"\n",(0,t.jsx)(n.p,{children:"详细的代码注释，都已经写在了上述代码中。"}),"\n",(0,t.jsxs)(n.p,{children:["打开 ",(0,t.jsx)(n.code,{children:"utils/index.js"}),"，添加 ",(0,t.jsx)(n.code,{children:"uploadImgServer"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 单张图片上传\nexport const uploadImgServer = 'http://backend-api-02.newbee.ltd/manage-api/v1/upload/file'\n"})}),"\n",(0,t.jsx)(n.p,{children:"简单书写一下样式部分。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"style"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-css",children:"<style scoped>\n  .avatar-uploader {\n    width: 100px;\n    height: 100px;\n    color: #ddd;\n    font-size: 30px;\n  }\n  .avatar-uploader >>> .el-upload {\n    width: 100%;\n    text-align: center;\n  }\n  .avatar-uploader-icon {\n    display: block;\n    width: 100%;\n    height: 100%;\n    border: 1px solid #e9e9e9;\n    padding: 32px 17px;\n  }\n</style>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["弹窗组件的代码已经编写完成，接下来在 ",(0,t.jsx)(n.code,{children:"Swiper.vue"})," 文件中引入并使用。"]}),"\n",(0,t.jsx)(n.p,{children:"首先，在头部添加两个按钮，并且引入弹窗组件，代码如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'\x3c!--Swiper.vue--\x3e\n<template #header>\n  <el-card class="swiper-container">\n    <div class="header">\n      <el-button type="primary" size="small" icon="el-icon-plus" @click="handleAdd">增加</el-button>\n      <el-popconfirm\n        title="确定删除吗？"\n        confirmButtonText=\'确定\'\n        cancelButtonText=\'取消\'\n        @confirm="handleDelete"\n      >\n        <template #reference>\n          <el-button type="danger" size="small" icon="el-icon-delete">批量删除</el-button>\n        </template>\n      </el-popconfirm>\n    </div>\n  </el-card>\n  <DialogAddSwiper ref=\'addSwiper\' :reload="getCarousels" :type="type" />\n</template>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["然后引入 ",(0,t.jsx)(n.code,{children:"DialogAddSwiper"})," 组件，添加 ",(0,t.jsx)(n.code,{children:"handleAdd"})," 方法，代码如下所示："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script setup>\nimport DialogAddSwiper from '@/components/DialogAddSwiper.vue'\n...\nconst addSwiper = ref(null)\nconst state = reactive({\n  ...\n  type: 'add', // 操作类型\n}) \n// 添加轮播项\nconst handleAdd = () => {\n  state.type = 'add'\n  addSwiper.value.open()\n}\n// 修改轮播图\nconst handleEdit = (id) => {\n  state.type = 'edit'\n  addSwiper.value.open(id)\n}\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上述模板中 ",(0,t.jsx)(n.code,{children:"ref='addSwiper'"}),"、",(0,t.jsx)(n.code,{children:"const addSwiper = ref(null)"})," 的写法为 ",(0,t.jsx)(n.code,{children:"Vue3"})," 对 ",(0,t.jsx)(n.code,{children:"red"})," 的写法，一定要在 ",(0,t.jsx)(n.code,{children:"setup"})," 函数中 ",(0,t.jsx)(n.code,{children:"return"})," 给 ",(0,t.jsx)(n.code,{children:"template"}),"。这样就可以通过 ",(0,t.jsx)(n.code,{children:"addSwiper"})," 拿到 ",(0,t.jsx)(n.code,{children:"DialogAddSwiper"})," 组件内部的方法，比如 ",(0,t.jsx)(n.code,{children:"addSwiper.value.open()"}),"，通过获取弹窗组件内的 ",(0,t.jsx)(n.code,{children:"open"})," 方法拿到内部的各个属性。"]}),"\n",(0,t.jsxs)(n.p,{children:["尝试在控制台打印一下 ",(0,t.jsx)(n.code,{children:"addSwiper"}),"，便知道其中的原因，结果如下"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"如果想在 addSwiper 内得到上述图中的属性，需要在 DialogAddSwiper 组件中的 defineExpose 方法中传入上图中的各个属性。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["上图中的变量都是\b在 ",(0,t.jsx)(n.code,{children:"DialogAddSwiper"})," 组件内部声明的变量，可以轻易地在父组件中拿到，这样就可以控制弹窗内部的属性来控制弹窗的显示隐藏。"]}),"\n",(0,t.jsxs)(n.p,{children:["最后，外面需要通过如下指令，将 ",(0,t.jsx)(n.code,{children:"@vitejs/plugin-vue"})," 升级到 ",(0,t.jsx)(n.code,{children:"2.3.3"})," 版本，注意不要升级为最新版本，因为本教程使用的是 ",(0,t.jsx)(n.code,{children:"Vite 2"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install @vitejs/plugin-vue@2.3.3 -D\n"})}),"\n",(0,t.jsx)(n.p,{children:"重启项目后，效果如下所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["温馨提示，上述代码中出现的 ",(0,t.jsx)(n.code,{children:"..."})," 为之前写过的代码，这里省略掉，避免代码冗余。"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["接下来是「批量删除」的实现，",(0,t.jsx)(n.code,{children:"el-table"})," 组件为开发者们提供了原生选择属性，给 ",(0,t.jsx)(n.code,{children:"el-table"})," 添加如下代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'\x3c!--Swiper.vue--\x3e\n...\n<el-table\n  :load="state.loading"\n  ref="multipleTable"\n  :data="state.tableData"\n  tooltip-effect="dark"\n  style="width: 100%"\n  @selection-change="handleSelectionChange"\n>\n  <el-table-column\n    type="selection"\n    width="55">\n  </el-table-column>\n  ...\n</el-table>\n\n<script>\nimport { ElMessage } from \'element-plus\'\n...\nconst state = reactive({\n  ...\n  multipleSelection: [], // 选中项\n})\n// 选中之后的change方法，一旦选项有变化，就会触发该方法。\nconst handleSelectionChange = (val) => {\n  state.multipleSelection = val\n}\n// 批量删除\nconst handleDelete = () => {\n  if (!state.multipleSelection.length) {\n    ElMessage.error(\'请选择项\')\n    return\n  }\n  axios.delete(\'/carousels\', {\n    data: {\n      ids: state.multipleSelection.map(i => i.carouselId)\n    }\n  }).then(() => {\n    ElMessage.success(\'删除成功\')\n    getCarousels()\n  })\n}\n<\/script>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["最后，添加分页组件 ",(0,t.jsx)(n.code,{children:"el-pagination"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'...\n  </el-table>\n  <el-pagination\n    background\n    layout="prev, pager, next"\n    :total="state.total"\n    :page-size="state.pageSize"\n    :current-page="state.currentPage"\n    @current-change="changePage"\n  />\n</el-card>\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script setup>\n  const state = reactive({\n    ...\n    total: 0, // 总条数\n  })\n  // 获取轮播图列表\n  const getCarousels = () => {\n    state.loading = true\n    axios.get('/carousels', {\n      params: {\n        pageNumber: state.currentPage,\n        pageSize: state.pageSize\n      }\n    }).then(res => {\n      state.tableData = res.list\n      state.total = res.totalCount\n      state.currentPage = res.currPage\n      state.loading = false\n    })\n  }\nconst changePage = (val) => {\n  state.currentPage = val\n  getCarousels()\n}\n<\/script>\n"})}),"\n",(0,t.jsx)(n.p,{children:"效果如下所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsxs)(n.h2,{id:"热销新品推荐页面制作",children:["热销、新品、推荐页面制作",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#热销新品推荐页面制作",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这三个页面的布局都是一样的，只不过请求接口的数据不一样罢了。实现这种需求的形式有两种。"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["通过 ",(0,t.jsx)(n.code,{children:"Tab"})," 在统一组件内，切换不同的选项，从而替换展示的内容。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"三个页面公用一个组件，通过路由监听变化，来判断不同的路径，对应不同的接口参数配置。"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"本项目中采用的是第二种方法，有兴趣的读者可以尝试改造成第一种方法。"}),"\n",(0,t.jsxs)(n.p,{children:["新增页面的话，需要去 ",(0,t.jsx)(n.code,{children:"App.vue"})," 添加菜单栏目，再去 ",(0,t.jsx)(n.code,{children:"router/index.js"})," 添加组件路由配置，然后在 ",(0,t.jsx)(n.code,{children:"views"})," 下新建组件。"]}),"\n",(0,t.jsx)(n.p,{children:"这里，直接添加代码："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'\x3c!--App.vue--\x3e\n<el-submenu index="2">\n  <template #title>\n    <span>首页配置</span>\n  </template>\n  <el-menu-item-group>\n    <el-menu-item index="/swiper"><el-icon><Picture /></el-icon>轮播图配置</el-menu-item>\n    <el-menu-item index="/hot"><el-icon><StarFilled /></el-icon>热销商品配置</el-menu-item>\n    <el-menu-item index="/new"><el-icon><Sell /></el-icon>新品上线配置</el-menu-item>\n    <el-menu-item index="/recommend"><el-icon><ShoppingCart /></el-icon>为你推荐配置</el-menu-item>\n  </el-menu-item-group>\n</el-submenu>\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// router/index.js\n{\n  path: '/hot',\n  name: 'hot',\n  component: IndexConfig\n},\n{\n  path: '/new',\n  name: 'new',\n  component: IndexConfig\n},\n{\n  path: '/recommend',\n  name: 'recommend',\n  component: IndexConfig\n},\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'\x3c!--IndexConfig.vue--\x3e\n<template>\n  <el-card class="index-container">\n  </el-card>\n</template>\n'})}),"\n",(0,t.jsx)(n.p,{children:"给模板添加一个路由监听方法："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"\x3c!--IndexConfig.vue--\x3e\n<script setup>\nimport { useRoute, useRouter } from 'vue-router'\nconst router = useRouter()\n  // 监听路由变化\nrouter.beforeEach((to) => {\n  console.log('to', to.name)\n})\n<\/script>\n"})}),"\n",(0,t.jsx)(n.p,{children:"之后，打开浏览器，最终的显示效果如下图所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["反复点击会发现一个问题：当你点击轮播图，再切回轮播图下的三个按钮的时候，会发生“上一次的 ",(0,t.jsx)(n.code,{children:"router"})," 没有被销毁”的情况，然后又创建了一次 ",(0,t.jsx)(n.code,{children:"router"}),"，导致执行了好几次 ",(0,t.jsx)(n.code,{children:"router.beforeEach"})," 的回调方法，也直接导致我们若是在回调方法内直接根据路径的变化，请求不同的接口，一次性会有多个请求发出。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里，直接查看源码，探索一下 ",(0,t.jsx)(n.code,{children:"beforeEach"})," 的源码是怎么解释的，如下所示："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"红框内的翻译大致是：返回一个函数，去消除注册的路由守卫。"}),"\n",(0,t.jsx)(n.p,{children:"很明显，代码需要修改："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"\x3c!--IndexConfig.vue--\x3e\n<script setup>\nimport { onUnmounted } from 'vue'\nimport { useRoute, useRouter } from 'vue-router'\nconst router = useRouter()\n  // 监听路由变化\nconst unWatch = router.beforeEach((to) => {\n  console.log('to', to.name)\n})\n\nonUnmounted(() => {\n  unWatch()\n})\n<\/script>\n"})}),"\n",(0,t.jsx)(n.p,{children:"当组件销毁的时候，路由守卫就会被销毁。"}),"\n",(0,t.jsxs)(n.p,{children:["首先，实现「热销商品配置」的列表展示，在 ",(0,t.jsx)(n.code,{children:"IndexConfig.vue"})," 文件下添加如下代码："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"template"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<template>\n  <el-card class="index-container">\n    <el-table\n      :load="state.loading"\n      :data="state.tableData"\n      tooltip-effect="dark"\n      style="width: 100%"\n    >\n      <el-table-column\n        prop="configName"\n        label="商品名称"\n      >\n      </el-table-column>\n      <el-table-column\n        label="跳转链接"\n        >\n        <template #default="scope">\n          <a target="_blank" :href="scope.row.redirectUrl">{{ scope.row.redirectUrl }}</a>\n        </template>\n      </el-table-column>\n      <el-table-column\n        prop="configRank"\n        label="排序值"\n        width="120"\n      >\n      </el-table-column>\n      <el-table-column\n        prop="goodsId"\n        label="商品编号"\n        width="200"\n      >\n      </el-table-column>\n      <el-table-column\n        prop="createTime"\n        label="添加时间"\n        width="200"\n      >\n      </el-table-column>\n      <el-table-column\n        label="操作"\n        width="100"\n      >\n        <template #default="scope">\n          <a style="cursor: pointer; margin-right: 10px" @click="handleEdit(scope.row.configId)">修改</a>\n          <el-popconfirm\n            title="确定删除吗？"\n            confirmButtonText=\'确定\'\n            cancelButtonText=\'取消\'\n            @confirm="handleDeleteOne(scope.row.configId)"\n          >\n            <template #reference>\n              <a style="cursor: pointer">删除</a>\n            </template>\n          </el-popconfirm>\n        </template>\n      </el-table-column>\n    </el-table>\n    \x3c!--总数超过一页，再展示分页器--\x3e\n    <el-pagination\n      background\n      layout="prev, pager, next"\n      :total="state.total"\n      :page-size="state.pageSize"\n      :current-page="state.currentPage"\n      @current-change="changePage"\n    />\n  </el-card>\n</template>\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"script"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script setup>\nimport { onMounted, reactive, ref } from 'vue'\nimport { useRoute, useRouter } from 'vue-router'\nimport axios from '@/utils/axios'\n\n// 首页配置类型参数\nconst configTypeMap = {\n  hot: 3,\n  new: 4,\n  recommend: 5\n}\n\nconst router = useRouter()\nconst route = useRoute()\nconst state = reactive({\n  loading: false,\n  tableData: [], // 数据列表\n  total: 0, // 总条数\n  currentPage: 1, // 当前页\n  pageSize: 10, // 分页大小\n  type: 'add', // 操作类型\n  configType: 3 // 3-(首页)热销商品 4-(首页)新品上线 5-(首页)为你推荐\n})\n// 监听路由变化\nrouter.beforeEach((to) => {\n  if (['hot', 'new', 'recommend'].includes(to.name)) {\n    // 通过 to.name 去匹配不同路径下，configType 参数也随之变化。\n    state.configType = configTypeMap[to.name]\n    state.currentPage = 1\n    getIndexConfig()\n  }\n})\n// 初始化\nonMounted(() => {\n  state.configType = configTypeMap[route.name]\n  getIndexConfig()\n})\n// 首页热销商品列表\nconst getIndexConfig = () => {\n  state.loading = true\n  axios.get('/indexConfigs', {\n    params: {\n      pageNumber: state.currentPage,\n      pageSize: state.pageSize,\n      configType: state.configType\n    }\n  }).then(res => {\n    state.tableData = res.list\n    state.total = res.totalCount\n    state.currentPage = res.currPage\n    state.loading = false\n  })\n}\nconst changePage = (val) => {\n  state.currentPage = val\n  getIndexConfig()\n}\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["由于三个页面都是同一个接口 ",(0,t.jsx)(n.code,{children:"/indexConfigs"}),"，只是根据 ",(0,t.jsx)(n.code,{children:"configType"})," 参数的不同，返回相对应的值，下面是对应的值："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 首页配置类型参数\nconst configTypeMap = {\n  hot: 3, // 热销\n  new: 4, // 新品\n  recommend: 5, // 推荐\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["之后去 ",(0,t.jsx)(n.code,{children:"src/utils/index.js"})," 文件中，配置面包屑文字，代码如下所示："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const pathMap = {\n  index: '首页',\n  login: '登录',\n  add: '添加商品',\n  swiper: '轮播图配置',\n  hot: '热销商品配置',\n  new: '新品上线配置',\n  recommend: '为你推荐配置',\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"展示效果如下图所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["接下来为列表添加新增、修改弹窗组件 ",(0,t.jsx)(n.code,{children:"/components/DialogAddGood.vue"}),"，"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"template"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'\x3c!--DialogAddGood.vue--\x3e\n<template>\n  <el-dialog\n    :title="type == \'add\' ? \'添加商品\' : \'修改商品\'"\n    v-model="state.visible"\n    width="400px"\n  >\n    <el-form :model="state.ruleForm" :rules="state.rules" ref="formRef" label-width="100px" class="good-form">\n      <el-form-item label="商品名称" prop="name">\n        <el-input type="text" v-model="state.ruleForm.name"></el-input>\n      </el-form-item>\n      <el-form-item label="跳转链接" prop="link">\n        <el-input type="text" v-model="state.ruleForm.link"></el-input>\n      </el-form-item>\n      <el-form-item label="商品编号" prop="id">\n        <el-input type="number" min="0" v-model="state.ruleForm.id"></el-input>\n      </el-form-item>\n      <el-form-item label="排序值" prop="sort">\n        <el-input type="number" v-model="state.ruleForm.sort"></el-input>\n      </el-form-item>\n    </el-form>\n    <template #footer>\n      <span class="dialog-footer">\n        <el-button @click="state.visible = false">取 消</el-button>\n        <el-button type="primary" @click="submitForm">确 定</el-button>\n      </span>\n    </template>\n  </el-dialog>\n</template>\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"script"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script setup>\nimport { reactive, ref } from 'vue'\nimport axios from '@/utils/axios'\nimport { ElMessage } from 'element-plus'\n\nconst props = defineProps({\n  type: String,\n  configType: Number,\n  reload: Function\n})\n\nconst formRef = ref(null)\nconst state = reactive({\n  visible: false,\n  ruleForm: {\n    name: '',\n    link: '',\n    id: '',\n    sort: ''\n  },\n  rules: {\n    name: [\n      { required: 'true', message: '名称不能为空', trigger: ['change'] }\n    ],\n    id: [\n      { required: 'true', message: '编号不能为空', trigger: ['change'] }\n    ],\n    sort: [\n      { required: 'true', message: '排序不能为空', trigger: ['change'] }\n    ]\n  },\n  id: ''\n})\n// 获取详情\nconst getDetail = (id) => {\n  axios.get(`/indexConfigs/${id}`).then(res => {\n    state.ruleForm = {\n      name: res.configName,\n      id: res.goodsId,\n      link: res.redirectUrl,\n      sort: res.configRank\n    }\n  })\n}\n// 开启弹窗\nconst open = (id) => {\n  state.visible = true\n  if (id) {\n    state.id = id\n    getDetail(id)\n  } else {\n    state.ruleForm = {\n      name: '',\n      id: '',\n      link: '',\n      sort: ''\n    }\n  }\n}\n// 关闭弹窗\nconst close = () => {\n  state.visible = false\n}\nconst submitForm = () => {\n  formRef.value.validate((valid) => {\n    if (valid) {\n      if (state.ruleForm.id < 0 || state.ruleForm.id > 200) {\n        ElMessage.error('商品编号不能小于 0 或大于 200')\n        return\n      }\n      if (props.type == 'add') {\n        axios.post('/indexConfigs', {\n          configType: props.configType || 3,\n          configName: state.ruleForm.name,\n          redirectUrl: state.ruleForm.link,\n          goodsId: state.ruleForm.id,\n          configRank: state.ruleForm.sort\n        }).then(() => {\n          ElMessage.success('添加成功')\n          state.visible = false\n          if (props.reload) props.reload()\n        })\n      } else {\n        axios.put('/indexConfigs', {\n          configId: state.id,\n          configType: props.configType || 3,\n          configName: state.ruleForm.name,\n          redirectUrl: state.ruleForm.link,\n          goodsId: state.ruleForm.id,\n          configRank: state.ruleForm.sort\n        }).then(() => {\n          ElMessage.success('修改成功')\n          state.visible = false\n          if (props.reload) props.reload()\n        })\n      }\n    }\n  })\n}\n// 后续我们会在外面使用该组件内部的方法属性，通过 <script setup> 形式编写的组件，需通过 defineExpose 方法，将属性暴露出去。\ndefineExpose({ open, close })\n<\/script>\n"})}),"\n",(0,t.jsx)(n.p,{children:"这一步操作和轮播图的操作是一样的，不作赘述。"}),"\n",(0,t.jsxs)(n.p,{children:["回到 ",(0,t.jsx)(n.code,{children:"IndexConfig.vue"}),"，在头部添加新增、批量删除按钮，在底部引入 ",(0,t.jsx)(n.code,{children:"DialogAddGood.vue"})," 弹窗组件，如下所示："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<template>\n  <el-card class="index-container">\n    <template #header>\n      <div class="header">\n        <el-button type="primary" size="small" icon="el-icon-plus" @click="handleAdd">增加</el-button>\n        <el-popconfirm\n          title="确定删除吗？"\n          confirmButtonText=\'确定\'\n          cancelButtonText=\'取消\'\n          @confirm="handleDelete"\n        >\n          <template #reference>\n            <el-button type="danger" size="small" icon="el-icon-delete">批量删除</el-button>\n          </template>\n        </el-popconfirm>\n      </div>\n    </template>\n    ...\n  </el-card>\n  <DialogAddGood ref=\'addGood\' :reload="getIndexConfig" :type="type" :configType="configType" />\n</template>\n'})}),"\n",(0,t.jsx)(n.p,{children:"添加逻辑部分："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script setup>\n...\nimport { ElMessage } from 'element-plus'\nimport DialogAddGood from '@/components/DialogAddGood.vue'\n\nconst state = reactive({\n  ...\n  multipleSelection: [], // 选中项\n})\n...\n// 添加商品\nconst handleAdd = () => {\n  state.type = 'add'\n  addGood.value.open()\n}\n// 修改商品\nconst handleEdit = (id) => {\n  state.type = 'edit'\n  addGood.value.open(id)\n}\n// 选择项\nconst handleSelectionChange = (val) => {\n  state.multipleSelection = val\n}\n// 删除\nconst handleDelete = () => {\n  if (!state.multipleSelection.length) {\n    ElMessage.error('请选择项')\n    return\n  }\n  axios.post('/indexConfigs/delete', {\n    ids: state.multipleSelection.map(i => i.configId)\n  }).then(() => {\n    ElMessage.success('删除成功')\n    getIndexConfig()\n  })\n}\n// 单个删除\nconst handleDeleteOne = (id) => {\n  axios.post('/indexConfigs/delete', {\n    ids: [id]\n  }).then(() => {\n    ElMessage.success('删除成功')\n    getIndexConfig()\n  })\n}\n<\/script>\n"})}),"\n",(0,t.jsx)(n.p,{children:"最后重启项目，显示效果如下图所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["本章节篇幅较长，主要分析了轮播图 ",(0,t.jsx)(n.code,{children:"Table"})," 制作，以及在数据相同的情况下，三个首页栏目的配置。主要知识点集中在弹窗组件的封装，路由监听事件的合理运用，以及页面销毁是，路由监听事件的销毁。这里需要注意，页面销毁时，一定要把当前页面的一些监听事件销毁，否则事件会一直存在执行栈内执行，后续会出现一些不可预知的 bug。"]}),"\n",(0,t.jsxs)(n.h4,{id:"本章源码地址",children:["本章源码地址",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章源码地址",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://s.yezgea02.com/1663318617293/admin04.zip",target:"_blank",rel:"noopener noreferrer",children:"点击下载"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"文档最近更新时间：2022 年 9 月 20 日。"}),"\n"]})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}let g=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F35.Vue3%20%E5%AE%9E%E6%88%98%E4%B9%8B%E9%A6%96%E9%A1%B5%E9%85%8D%E7%BD%AE.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"本章节知识点",id:"本章节知识点",depth:4},{text:"首页轮播图配置",id:"首页轮播图配置",depth:2},{text:"热销、新品、推荐页面制作",id:"热销新品推荐页面制作",depth:2},{text:"总结",id:"总结",depth:2},{text:"本章源码地址",id:"本章源码地址",depth:4}],title:"35.Vue3 实战之首页配置",headingTitle:"35.Vue3 实战之首页配置",frontmatter:{}}}}]);