"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18216"],{704544:function(e,n,c){c.r(n),c.d(n,{default:()=>eA});var s=c(552676),r=c(740453);let t=c.p+"static/image/035d16ed9cbd37dd893422383ab1fa7c.ebcd99a7.webp",a=c.p+"static/image/dbe998563fe1950de437e772fc215fb5.d0c202d1.webp",i=c.p+"static/image/bd5e5ca38684b4029c1b302315f1660e.fcca4516.webp",d=c.p+"static/image/aa1f3ed00cfcf6e6340663a6ed4dd4f9.19405b20.webp",p=c.p+"static/image/2388b8ae2f9516e9941a0c54c399129a.f57d0005.webp",l=c.p+"static/image/06e0f24c8daaf868863dbee42a4c50b6.ebf65baa.webp",f=c.p+"static/image/a6e9488497c0ffa0d17183b3899be64f.17f38b57.webp",o=c.p+"static/image/e78c5406b0075a1f2cb5c2fd352a3838.c76d79f6.webp",u=c.p+"static/image/98943247788388612cee012d46a13655.60fd4f0e.webp",x=c.p+"static/image/e74d0a5c3d1dead68514ddff5cb82a96.00c65fd2.webp",h=c.p+"static/image/1f6c21b7803646aee34dd73645d60c15.51c20218.webp",j=c.p+"static/image/caf717203681320c9fc81d2e3457b2ce.7cc7f0a1.webp",m=c.p+"static/image/e5f819330b2c08678dff021d6038c4c3.f0ac4c60.webp",b=c.p+"static/image/e25a618af11550ca3e0026b579bf3f23.7c69f815.webp",g=c.p+"static/image/bf7f29bf3d97123f365ea7ae329db71a.a1d75bdd.webp",A=c.p+"static/image/b7fe98251d74bff62fad39002900e963.c0f12b65.webp",v=c.p+"static/image/90ce9be263a6dc1076cea70f98230e04.790629a1.webp",R=c.p+"static/image/3722d203e4f5865d49c70dac431e1c4a.c5f05362.webp",w=c.p+"static/image/d1890a1e35231c30a4cc72b946db3788.8491baf5.webp",C=c.p+"static/image/013d31e25a70287a5fb807b472d860f4.9f7f6dc0.webp",E=c.p+"static/image/29c14ddbd2ca24a9d998427cc36a8525.afbae39a.webp",k=c.p+"static/image/c24201fee3fcc2c6e6292ad67c4a5a0e.4ea0ec5e.gif",N=c.p+"static/image/3f9edbd39d684524ea0c3c73a0a51ded.446e3579.webp",M=c.p+"static/image/c862f646f6856af7e9f69835ee07958f.f233c3c9.gif",B=c.p+"static/image/185e88efc3a244dfcfef24717b2c3d87.6357fc2a.gif",H=c.p+"static/image/ad97811fc4d5ab1e725c7d5972ad456a.45f9918d.webp",S=c.p+"static/image/7189b376d9436556367fffe0f4fa5d89.2333547e.gif",P=c.p+"static/image/f47a600c0d6bc992119d37aa09ddcd7a.8da223d2.webp",L=c.p+"static/image/f179341c61d5ad1e51c56b135e0182b4.ffb5461a.gif",y=c.p+"static/image/79a77bbf24188baf8a81e04fd0cbad97.f6ef4eb0.gif",O=c.p+"static/image/254cd954471d825df75e408be4b733d7.cdda8fee.webp",z=c.p+"static/image/e95c6dfedfbf3fe7be9d8c2bfbc27a4c.96768cde.gif",I=c.p+"static/image/226cfb3e81404ff57ae3b59a33be6673.235a2544.gif",T=c.p+"static/image/d8b51f0528c0faab86ffebc0ee59d8b4.62be3ce7.webp",D=c.p+"static/image/ccdcfee5257a0884dcb5ffcabc6548d6.8568e835.gif",Y=c.p+"static/image/812253c3850bce29efd4f5e2c1795909.7066abcb.webp",F=c.p+"static/image/5f73da7d2ce73e741cbb5eacd759042f.e090d76b.webp",J=c.p+"static/image/85f67822d6a16eed22cf847bbf2f799f.2cb5c0a1.webp",U=c.p+"static/image/b0474e5a9fdd34c12f706b5450e583a3.058e0bf0.webp",G=c.p+"static/image/1d762158295e1190dc343892cb469b13.235917d9.webp",Q=c.p+"static/image/7b21b30edda9c8da5b112894fbc23a48.0acf4528.webp",K=c.p+"static/image/744fc6983986dbc555b68603169fabb8.451c2e6c.webp",q=c.p+"static/image/7b00104ae8af5274a8af123e3f5626f7.b86a4f32.webp",W=c.p+"static/image/708a69b2fba75b8b9898d22d52a41c91.991e9d46.webp",Z=c.p+"static/image/f6603d56c0a97b2225ec5d00747ad701.f94f677a.webp",V=c.p+"static/image/0d89ec26e77cb631cdd508d9071b363c.11aa6f37.gif",X=c.p+"static/image/55f032444ee20aeee95de9b54364135a.0ccd8c6c.webp",_=c.p+"static/image/2d577b9b561bbec483c370113f9f6a34.eb61e627.webp",$=c.p+"static/image/2f5e8e6a8042ed0d79066adcd8e0290a.9f509c2d.webp",ee=c.p+"static/image/2a2c03ede5719a8093ec9a281916f8fd.b75dd93c.webp",en=c.p+"static/image/6abeedfebf9b8e6ce2f5787b29498c66.2f6b378c.webp",ec=c.p+"static/image/b2244dd49dcd12ad8aaf4df9555a99ce.08fed59c.webp",es=c.p+"static/image/1dcac7ecb693e6ef0cb17c20946439f7.b1bdb5a1.webp",er=c.p+"static/image/8febade757ce433f0f02c231527d821b.5ad68602.webp",et=c.p+"static/image/00d0140b067cc1992ca4410248a84e01.5b0300ae.webp",ea=c.p+"static/image/2b38155c774b3350b53bee5bf859ad82.c750ff73.webp",ei=c.p+"static/image/49511f98213c2eac9c6318b21381fc5f.ad589de5.gif",ed=c.p+"static/image/a9df2991015911f15f034e03cd54ef72.00a53880.webp",ep=c.p+"static/image/c68d0e2dd936437c9904c42caa490044.14f32ccb.webp",el=c.p+"static/image/9296575665fe5d2c34b981001883bee4.abcb88b8.gif",ef=c.p+"static/image/677b5465e68df31b1ecbd4d38a4aaf58.943c8e0d.webp",eo=c.p+"static/image/8011df21caaf697c689e25484296a255.3a44f045.webp",eu=c.p+"static/image/4f1954c62fd6a13a47156f0bd6f96bf2.38733c24.gif",ex=c.p+"static/image/8f6cf75e9a97d7917060af0a46bc4701.63b8b1f0.webp",eh=c.p+"static/image/0f67edc713fa13269a96578591373b94.1f3fa95b.webp",ej=c.p+"static/image/3a0da90daa7860c0f114314d20f2d202.75fbc47e.webp",em=c.p+"static/image/b970a70246213999c2a708d71cf21e72.e40f0afd.webp";function eb(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2",strong:"strong",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"第02章一网打尽组件常用hook",children:["第02章—一网打尽组件常用Hook",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第02章一网打尽组件常用hook",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"\uFEFFReact 组件支持 class、function 两种形式，但现在绝大多数情况下我们都是写 function 组件了。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://react.dev/reference/react/Component",target:"_blank",rel:"noopener noreferrer",children:"官方文档"}),"也已经把 class 组件的语法划到了 legacy（遗产）的目录下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:em,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"所以说，除非你维护的代码里有历史代码用了 class 组件，否则就没必要看那些用法了。"}),"\n",(0,s.jsx)(n.p,{children:"而 function 组件主要是学习各种 hook 的使用。"}),"\n",(0,s.jsx)(n.p,{children:"这节我们就来过一遍常用 hook。"}),"\n",(0,s.jsx)(n.p,{children:"首先用 create-react-app 创建个项目："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx create-react-app --template typescript hook-test\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ej,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在 index.tsx 里把这三行代码注释掉："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:eh,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"React.StrictMode 会导致额外的渲染，下面那个上报性能数据的，cra 自带的，我们也用不到。"}),"\n",(0,s.jsx)(n.p,{children:"然后改下 App.tsx"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useState } from "react";\n\nfunction App() {\n  const [num, setNum] = useState(1);\n\n  return (\n    <div onClick={() => setNum(num + 1)}>{num}</div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(n.p,{children:"这里用到了第一个 hook：useState。"}),"\n",(0,s.jsxs)(n.h2,{id:"usestate",children:["useState",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usestate",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"什么是 state 呢？"}),"\n",(0,s.jsx)(n.p,{children:"像 111、'xxx'、{ a: 1 } 这种叫做数据，它们可以是各种数据类型，但都是固定不变的。"}),"\n",(0,s.jsx)(n.p,{children:"从一种数据变成另一种数据，这种就是状态（state）了。"}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，",(0,s.jsx)(n.strong,{children:"状态是变化的数据。"})]}),"\n",(0,s.jsx)(n.p,{children:"其实细想一下，组件的核心就是状态。"}),"\n",(0,s.jsx)(n.p,{children:"点击、拖拽等交互事件会改变状态，而状态改变会触发重新渲染。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ex,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"组件内的状态是 useState 创建的，整个应用还可以加一个全局状态管理的库来管理 state。"}),"\n",(0,s.jsx)(n.p,{children:"所以说，state 虽然是基础，但它却是前端应用的核心。"}),"\n",(0,s.jsx)(n.p,{children:"回过头来跑一下上面的代码："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:eu,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"state 初始值是 1，点击改变状态，这个很简单。"}),"\n",(0,s.jsx)(n.p,{children:"如果初始状态需要经过复杂计算得到，可以传个函数来计算初始值："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:eo,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const [num, setNum] = useState(() => {\n    const num1 = 1 + 2;\n    const num2 = 2 + 3;\n    return num1 + num2\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个函数只能写一些同步的计算逻辑，不支持异步。"}),"\n",(0,s.jsx)(n.p,{children:"useState 返回一个数组，包含 state 和 setXxx 的 api，一般我们都是用解构语法取。"}),"\n",(0,s.jsx)(n.p,{children:"这个 setXxx 的 api 也有两种参数："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ef,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以直接传新的值，或者传一个函数，返回新的值，这个函数的参数是上一次的 state。"}),"\n",(0,s.jsx)(n.p,{children:"跑一下，功能正常："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:el,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"除了在 click 事件处理函数里 setState，如果想在初次渲染的时候请求数据然后 setState 呢？"}),"\n",(0,s.jsx)(n.p,{children:"这时候就要用到 useEffect 了。"}),"\n",(0,s.jsxs)(n.h2,{id:"useeffect",children:["useEffect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useeffect",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"effect 被翻译为副作用。"}),"\n",(0,s.jsx)(n.p,{children:"为啥叫副作用呢？"}),"\n",(0,s.jsx)(n.p,{children:"之前的函数组件是纯函数，传入 props，返回对应的结果，再次调用，传入 props，依然返回同样的结果。"}),"\n",(0,s.jsx)(n.p,{children:"但现在有了 effect 之后，每次执行函数，额外执行了一些逻辑，这些逻辑不就是副作用么？"}),"\n",(0,s.jsx)(n.p,{children:"我们写个 App2.tsx："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ep,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useEffect, useState } from "react";\n\nasync function queryData() {\n  const data = await new Promise<number>((resolve) => {\n    setTimeout(() => {\n      resolve(666);\n    }, 2000);\n  })\n  return data;\n}\n\nfunction App() {\n  const [num, setNum] = useState(0);\n\n  useEffect(() => {\n    queryData().then(data => {\n      setNum(data);\n    })\n  }, []);\n\n  return (\n    <div onClick={() => setNum((prevNum) => prevNum + 1)}>{num}</div>\n  );\n}\n\nexport default App;\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"注意，想用 async await 语法需要单独写一个函数，因为 useEffect 参数的那个函数不支持 async。"}),"\n",(0,s.jsx)(n.p,{children:"把 index.tsx 渲染的组件改为 App2"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ed,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"浏览器访问下，可以看到 2s 后，state 变为了 666:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ei,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"请求数据、定时器等这些异步逻辑，我们都会放在 useEffect 里。"}),"\n",(0,s.jsx)(n.p,{children:"回过头来看下 useEffect："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ea,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"第二个参数为什么传空数组呢？"}),"\n",(0,s.jsx)(n.p,{children:"这个数组叫做依赖数组，react 是根据它有没有变来决定是否执行 effect 函数的，如果没传则每次都执行。"}),"\n",(0,s.jsx)(n.p,{children:"我们加个打印："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:et,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"现在这个组件会渲染两次，初始渲染和 2s 后 setNum 触发的渲染，也就是 function 会执行 2 次。"}),"\n",(0,s.jsx)(n.p,{children:"打开 devtools 看一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:er,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"xxx 只执行了一次，因为 [] 每次都不变。"}),"\n",(0,s.jsx)(n.p,{children:"我也可以写任意的常量，因为它们都不变，所以不会触发 effect 的重新执行："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:es,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ec,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但如果其中有个变化的值，那就会触发重新执行了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:en,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，现在每次渲染，effect 都会执行："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:ee,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个数组我们一般写依赖的 state，这样在 state 变了之后就会触发重新执行了。"}),"\n",(0,s.jsx)(n.p,{children:"不传 deps 数组的时候也是每次都会重新执行 effect 函数："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:$,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那 useEffect 里如果跑了一个定时器，依赖变了之后，再次执行 useEffect，又跑了一个，怎么清理上一个定时器呢？"}),"\n",(0,s.jsx)(n.p,{children:"这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:X,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from \"react\";\n\nfunction App() {\n  const [num, setNum] = useState(0);\n\n  useEffect(() => {\n    console.log('effect')\n    const timer = setInterval(() => {\n      console.log(num);\n    }, 1000);\n\n    return () => {\n      console.log('clean up')\n      clearInterval(timer);\n    }\n  }, [num]);\n\n  return (\n    <div onClick={() => setNum((prevNum) => prevNum + 1)}>{num}</div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,s.jsx)(n.p,{children:"跑一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:V,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，当 deps 数组变了，重新执行 effect 之前，会先执行清理函数，打印了 clean up。"}),"\n",(0,s.jsx)(n.p,{children:"此外，组件销毁时也会调用 cleanup 函数来进行清理。"}),"\n",(0,s.jsxs)(n.h2,{id:"uselayouteffect",children:["useLayoutEffect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#uselayouteffect",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"和 useEffect 类似的还有一个 useLayoutEffect。"}),"\n",(0,s.jsx)(n.p,{children:"绝大多数情况下，你把 useEffect 换成 useLayoutEffect 也一样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:Z,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:W,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那为啥还要有这两个 hook 呢？"}),"\n",(0,s.jsx)(n.p,{children:"我们知道，js 执行和渲染是阻塞的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,s.jsx)(n.p,{children:"useEffect 的 effect 函数会在操作 dom 之后异步执行："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:q,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"异步执行就是用 setTimeout、Promise.then 等 api 包裹执行的逻辑。"}),"\n",(0,s.jsx)(n.p,{children:"这些逻辑会以单独的宏任务或者微任务的形式存在，然后进入 Event Loop 调度执行。"}),"\n",(0,s.jsx)(n.p,{children:"打开 Permormance 工具，可以看到 Event Loop 的详情："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:K,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，渲染的间隔是固定的，而 js 的任务在这些渲染的间隔中执行。"}),"\n",(0,s.jsx)(n.p,{children:"所以异步执行的 effect 逻辑就有两种可能："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:Q,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:G,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"灰色的部分是单独的任务。"}),"\n",(0,s.jsx)(n.p,{children:"有可能在下次渲染之前，就能执行完这个 effect。"}),"\n",(0,s.jsx)(n.p,{children:"也有可能下次渲染前，没时间执行这个 effect，所以就在渲染之后执行了。"}),"\n",(0,s.jsx)(n.p,{children:"这样就导致有的时候页面会出现闪动，因为第一次渲染的时候的 state 是之前的值，渲染完之后执行 effect 改了 state，再次渲染就是新的值了。"}),"\n",(0,s.jsx)(n.p,{children:"一般这样也没啥问题，但如果你遇到这种情况，不想闪动那一下，就用 useLayoutEffect。"}),"\n",(0,s.jsx)(n.p,{children:"它和 useEffect 的区别是它的 effect 执行是同步的，也就是在同一个任务里："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:U,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样浏览器会等 effect 逻辑执行完再渲染。"}),"\n",(0,s.jsx)(n.p,{children:"好处自然就是不会闪动了。"}),"\n",(0,s.jsx)(n.p,{children:"但坏处也很明显，如果你的 effect 逻辑要执行很久呢？"}),"\n",(0,s.jsx)(n.p,{children:"不就阻塞渲染了？"}),"\n",(0,s.jsx)(n.p,{children:"超过 50ms 的任务就被称作长任务，会阻塞渲染，导致掉帧："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:J,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"所以说，一般情况下，还是让 effect 逻辑异步执行的好。"}),"\n",(0,s.jsx)(n.p,{children:"也就是说，绝大多数情况下，用 useEffect，它能避免因为 effect 逻辑执行时间长导致页面卡顿（掉帧）。\n但如果你遇到闪动的问题比较严重，那可以用 useLayoutEffect，但要注意 effect 逻辑不要执行时间太长。"}),"\n",(0,s.jsx)(n.p,{children:"同步、异步执行 effect 都各有各的问题和好处，所以 React 暴露了 useEffect 和 useLayoutEffect 这两个 hook 出来，让开发者自己决定。"}),"\n",(0,s.jsxs)(n.h2,{id:"usereducer",children:["useReducer",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usereducer",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前面用的 setState 都是直接修改值，那如果在修改值之前需要执行一些固定的逻辑呢？"}),"\n",(0,s.jsx)(n.p,{children:"这时候就要用 useReducer 了："}),"\n",(0,s.jsx)(n.p,{children:"添加一个 App3.tsx："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Reducer, useReducer } from \"react\";\n\ninterface Data {\n    result: number;\n}\n\ninterface Action {\n    type: 'add' | 'minus',\n    num: number\n}\nfunction reducer(state: Data, action: Action) {\n\n    switch(action.type) {\n        case 'add':\n            return {\n                result: state.result + action.num\n            }\n        case 'minus': \n            return {\n                result: state.result - action.num\n            }\n    }\n    return state;\n}\n\nfunction App() {\n  const [res, dispatch] = useReducer<Reducer<Data, Action>>(reducer, { result: 0});\n\n  return (\n    <div>\n        <div onClick={() => dispatch({ type: 'add', num: 2 })}>加</div>\n        <div onClick={() => dispatch({ type: 'minus', num: 1 })}>减</div>\n        <div>{res.result}</div>\n    </div>\n  );\n}\n\nexport default App;\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"useReducer 的类型参数传入 Reducer<数据的类型，action 的类型>"}),"\n",(0,s.jsx)(n.p,{children:"然后第一个参数是 reducer，第二个参数是初始数据。"}),"\n",(0,s.jsx)(n.p,{children:"点击加的时候，触发 add 的 action，点击减的时候，触发 minus 的 action。"}),"\n",(0,s.jsx)(n.p,{children:"在 index.tsx 里引入："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:F,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"当然，你直接 setState 也可以："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useState } from "react";\n\nfunction App() {\n  const [res, setRes] = useState({ result: 0});\n\n  return (\n    <div>\n        <div onClick={() => setRes({ result: res.result + 2 })}>加</div>\n        <div onClick={() => setRes({ result: res.result - 1 })}>减</div>\n        <div>{res.result}</div>\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(n.p,{children:"有同学可能会说，用 useState 比 useReducer 简洁多了。"}),"\n",(0,s.jsx)(n.p,{children:"确实，这个例子不复杂，没必要用 useReducer。"}),"\n",(0,s.jsx)(n.p,{children:"但如果要执行比较复杂的逻辑呢？"}),"\n",(0,s.jsx)(n.p,{children:"用 useState 需要在每个地方都写一遍这个逻辑，而用 useReducer 则是把它封装到 reducer 里，通过 action 触发就好了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"当修改 state 的逻辑比较复杂，用 useReducer。"})}),"\n",(0,s.jsx)(n.p,{children:"回过头来继续看 useReducer："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:Y,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const [res, dispatch] = useReducer<Reducer<Data, Action>, string>(reducer, 'zero', (param) => {\n    return {\n        result: param === 'zero' ? 0 : 1\n    }\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"它还有另一种重载，通过函数来创建初始数据，这时候 useReducer 第二个参数就是传给这个函数的参数。"}),"\n",(0,s.jsx)(n.p,{children:"并且在类型参数里也需要传入它的类型。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"usereducer--immer",children:["useReducer + immer",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usereducer--immer",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"此外，使用 reducer 有一个特别要注意的地方："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果你直接修改原始的 state 返回，是触发不了重新渲染的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:I,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"必须返回一个新的对象才行。"}),"\n",(0,s.jsx)(n.p,{children:"但这也有个问题，如果对象结构很复杂，每次都创建一个新的对象会比较繁琐，而且性能也不好。"}),"\n",(0,s.jsx)(n.p,{children:"比如这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Reducer, useReducer } from \"react\";\n\ninterface Data {\n    a: {\n        c: {\n            e: number,\n            f: number\n        },\n        d: number\n    },\n    b: number\n}\n\ninterface Action {\n    type: 'add',\n    num: number\n}\n\nfunction reducer(state: Data, action: Action) {\n\n    switch(action.type) {\n        case 'add':\n            return {\n                ...state,\n                a: {\n                    ...state.a,\n                    c: {\n                        ...state.a.c,\n                        e: state.a.c.e + action.num,\n                    },\n                },\n            }\n    }\n    return state;\n}\n\nfunction App() {\n  const [res, dispatch] = useReducer<Reducer<Data, Action>, string>(reducer, 'zero', (param) => {\n    return {\n        a: {\n            c: {\n                e: 0,\n                f: 0\n            },\n            d: 0\n        },\n        b: 0\n    }\n  });\n\n  return (\n    <div>\n        <div onClick={() => dispatch({ type: 'add', num: 2 })}>加</div>\n        <div>{JSON.stringify(res)}</div>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里的 data 是一个复杂的对象结构，我们需要改的是其中的一个属性，但是为了创建新对象，要把其余属性依次复制一遍。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:z,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样能完成功能，但是写起来很麻烦，也不好维护。"}),"\n",(0,s.jsx)(n.p,{children:"有没有什么更好的方式呢？"}),"\n",(0,s.jsx)(n.p,{children:"有，复杂对象的修改就要用 immutable 相关的库了。"}),"\n",(0,s.jsx)(n.p,{children:"最常用的是 immer："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save immer\n"})}),"\n",(0,s.jsx)(n.p,{children:"用法相当简单，只有一个 produce 的 api："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"return produce(state, (state) => {\n    state.a.c.e += action.num\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"第一个参数是要修改的对象，第二个参数的函数里直接修改这个对象的属性，返回的结果就是一个新的对象。"}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"功能正常。"}),"\n",(0,s.jsx)(n.p,{children:"用起来超级简单。"}),"\n",(0,s.jsx)(n.p,{children:"immer 是依赖 Proxy 实现的，它会监听你在函数里对属性的修改，然后帮你创建一个新对象。"}),"\n",(0,s.jsx)(n.p,{children:"刚才只说了 reducer 需要返回一个新的对象，才会触发渲染，其实 useState 也是。"}),"\n",(0,s.jsx)(n.p,{children:"比如这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useState } from "react";\n\nfunction App() {\n    const [obj, setObj] = useState({\n        a: {\n            c: {\n                e: 0,\n                f: 0\n            },\n            d: 0\n        },\n        b: 0\n    });\n\n    return (\n        <div>\n            <div onClick={() => {\n                obj.a.c.e ++;\n                setObj(obj);\n            }}>加</div>\n            <div>{JSON.stringify(obj)}</div>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(n.p,{children:"因为对象引用没变，同样不会重新渲染："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:L,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"也可以用 immer："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"setObj(produce(obj, (obj) => {\n    obj.a.c.e ++;\n}))\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["综上，",(0,s.jsx)(n.strong,{children:"在 react 里，只要涉及到 state 的修改，就必须返回新的对象，不管是 useState 还是 useReducer。"})]}),"\n",(0,s.jsx)(n.p,{children:"如果是复杂的深层对象的修改，可以用 immer 来优化。"}),"\n",(0,s.jsx)(n.p,{children:"为什么大家会说 React 推崇的是数据不可变？"}),"\n",(0,s.jsx)(n.p,{children:"就是因为这个。"}),"\n",(0,s.jsxs)(n.h2,{id:"useref",children:["useRef",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useref",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"state 的保存和修改我们会了，那如何保存 dom 引用呢？"}),"\n",(0,s.jsx)(n.p,{children:"这时候就需要用 useRef 了。"}),"\n",(0,s.jsx)(n.p,{children:"创建 App4.tsx："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useEffect, useRef } from "react";\n\nfunction App() {\n    const inputRef = useRef<HTMLInputElement>(null);\n\n    useEffect(() => {\n        inputRef.current?.focus();\n    });\n\n    return (\n        <div>\n            <input ref={inputRef}></input>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(n.p,{children:"useRef 的类型参数是保存的内容的类型。"}),"\n",(0,s.jsx)(n.p,{children:"这里通过 ref 保存 input 元素的引用，然后在 useEffect 里调用它的 focus 方法。"}),"\n",(0,s.jsx)(n.p,{children:"ref 的内容是保存在 current 属性上的。"}),"\n",(0,s.jsx)(n.p,{children:"在 index.tsx 引入："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:H,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，focus 生效了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"ref 其实就是一个有 current 属性的对象，除了可以保存 dom 引用，也可以放别的内容："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useRef } from "react";\n\nfunction App() {\n    const numRef = useRef<number>(0);\n\n    return (\n        <div>\n            <div onClick={() => {\n                numRef.current += 1\n            }}>{numRef.current}</div>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(n.p,{children:"但它不会触发重新渲染："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"想触发渲染，还是得配合 state："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useRef, useState } from "react";\n\nfunction App() {\n    const numRef = useRef<number>(0);\n    const [, forceRender] = useState(0);\n\n    return (\n        <div>\n            <div onClick={() => {\n                numRef.current += 1;\n                forceRender(Math.random());\n            }}>{numRef.current}</div>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"不过一般不这么用，如果想改变内容会触发重新渲染，直接用 useState 或者 useReducer 就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"useRef 一般是用来存一些不是用于渲染的内容的。"}),"\n",(0,s.jsx)(n.p,{children:"单个组件内如何拿到 ref 我们知道了，那如果是想把 ref 从子组件传递到父组件呢？"}),"\n",(0,s.jsx)(n.p,{children:"这种有专门的 api： forwardRef。"}),"\n",(0,s.jsxs)(n.h2,{id:"forwardref--useimperativehandle",children:["forwardRef + useImperativeHandle",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#forwardref--useimperativehandle",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"之前拿到标签的 dom 元素是这样写的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"通过 useRef 创建个 ref 对象，然后把 input 标签设置到 ref。"}),"\n",(0,s.jsx)(n.p,{children:"如果是想从子组件传递 ref 到父组件，就需要 forwardRef 了，也就是把组件内的 ref 转发一下。"}),"\n",(0,s.jsx)(n.p,{children:"比如这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { useRef } from 'react';\nimport { useEffect } from 'react';\nimport React from 'react';\n\nconst Guang: React.ForwardRefRenderFunction<HTMLInputElement> = (props, ref) => {\n  return <div>\n    <input ref={ref}></input>\n  </div>\n}\n\nconst WrapedGuang = React.forwardRef(Guang);\n\nfunction App() {\n  const ref = useRef<HTMLInputElement>(null);\n \n  useEffect(()=> {\n    console.log('ref', ref.current)\n    ref.current?.focus()\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <WrapedGuang ref={ref}/>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,s.jsx)(n.p,{children:"其实 forwardRef 这个 api 做的事情也很容易懂。"}),"\n",(0,s.jsx)(n.p,{children:"就是把 ref 转发到组件内部来设置："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样就把子组件的 input 的 ref 传递到了父组件。"}),"\n",(0,s.jsx)(n.p,{children:"效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"不过被 forwardRef 包裹的组件的类型就要用 React.forwardRefRenderFunction 了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"第一个类型参数是 ref 的 content 的类型，第二个类型参数是 props 的类型。"}),"\n",(0,s.jsx)(n.p,{children:"但有的时候，我不是想把原生标签暴露出去，而是暴露一些自定义内容。"}),"\n",(0,s.jsx)(n.p,{children:"这时候就需要 useImperativeHandle 的 hook 了。"}),"\n",(0,s.jsx)(n.p,{children:"它有 3 个参数，第一个是传入的 ref，第二个是是返回新的 ref 值的函数，第三个是依赖数组。"}),"\n",(0,s.jsx)(n.p,{children:"这样写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { useRef } from 'react';\nimport { useEffect } from 'react';\nimport React from 'react';\nimport { useImperativeHandle } from 'react';\n\ninterface RefProps {\n  aaa: () => void;\n}\n\nconst Guang: React.ForwardRefRenderFunction<RefProps> = (props, ref) => {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useImperativeHandle(ref, () => {\n    return {\n      aaa() {\n        inputRef.current?.focus();\n      }\n    }\n  }, [inputRef]);\n\n  return <div>\n    <input ref={inputRef}></input>\n  </div>\n}\n\nconst WrapedGuang = React.forwardRef(Guang);\n\nfunction App() {\n  const ref = useRef<RefProps>(null);\n \n  useEffect(()=> {\n    console.log('ref', ref.current)\n    ref.current?.aaa();\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <WrapedGuang ref={ref}/>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,s.jsx)(n.p,{children:"也就是用 useImperativeHanlde 自定义了 ref 对象："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样，父组件里拿到的 ref 就是 useImperativeHandle 第二个参数的返回值了。"}),"\n",(0,s.jsx)(n.p,{children:"效果是一样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"usecontext",children:["useContext",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecontext",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"跨任意层组件传递数据，我们一般用 Context。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"创建 App5.tsx"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { createContext, useContext } from 'react';\n\nconst countContext = createContext(111);\n\nfunction Aaa() {\n  return <div>\n      <countContext.Provider value={222}>\n        <Bbb></Bbb>\n      </countContext.Provider>\n  </div>\n} \n\nfunction Bbb() {\n  return <div><Ccc></Ccc></div>\n}\n\nfunction Ccc() {\n  const count = useContext(countContext);\n  return <h2>context 的值为：{count}</h2>\n}\n\nexport default Aaa;\n"})}),"\n",(0,s.jsx)(n.p,{children:"用 createContext 创建 context，在 Aaa 里面使用 xxxContext.Provider 修改它的值，然后在 Ccc 里面用 useContext 取出来。"}),"\n",(0,s.jsx)(n.p,{children:"在 index.tsx 里引入："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"访问下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，拿到的值是被 Provider 修改过的 222。"}),"\n",(0,s.jsx)(n.p,{children:"有的同学可能会问，有 Provider，那有 Consumer 么？"}),"\n",(0,s.jsx)(n.p,{children:"有，class 组件是通过 Consumer 来取 context 的值："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { createContext, Component } from 'react';\n\nconst countContext = createContext(111);\n\nclass Ccc extends Component {\n  render() {\n    return <h2>context 的 值为：{this.props.count}</h2>\n  }\n}\n\nfunction Bbb() {\n  return <div>\n    <countContext.Consumer>{\n        (count) => <Ccc count={count}></Ccc>\n      }\n    </countContext.Consumer>\n  </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"不过现在很少写 class 组件了。"}),"\n",(0,s.jsxs)(n.p,{children:["总结一下就是，",(0,s.jsx)(n.strong,{children:"用 createContext 创建 context 对象，用 Provider 修改其中的值， function 组件使用 useContext 的 hook 来取值，class 组件使用 Consumer 来取值。"})]}),"\n",(0,s.jsx)(n.p,{children:"组件库里用 Context 很多，比如 antd 里就有大量 Context 的使用："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"配置数据基本都是用 Context 传递。"}),"\n",(0,s.jsxs)(n.h2,{id:"memo--usememo--usecallback",children:["memo + useMemo + useCallback",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#memo--usememo--usecallback",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"有两个组件 Aaa、Bbb，Aaa 是 Bbb 的父组件："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { memo, useEffect, useState } from \"react\";\n\nfunction Aaa() {\n    const [,setNum] = useState(1);\n\n    useEffect(() => {\n        setInterval(()=> {\n            setNum(Math.random());\n        }, 2000)\n    },[]);\n\n    return <div>\n        <Bbb count={2}></Bbb>\n    </div>\n} \n\ninterface BbbProps {\n    count: number;\n}\n\nfunction Bbb(props: BbbProps) {\n    console.log('bbb render');\n\n    return <h2>{props.count}</h2>\n}\n\nexport default Aaa;\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 Aaa 里面不断 setState 触发重新渲染，问："}),"\n",(0,s.jsx)(n.p,{children:"bbb render 打印几次？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"答案是每 2s 都会打印。"}),"\n",(0,s.jsx)(n.p,{children:"也就是说，每次都会触发 Bbb 组件的重新渲染。"}),"\n",(0,s.jsx)(n.p,{children:"但很明显，这里 Bbb 并不需要再次渲染。"}),"\n",(0,s.jsx)(n.p,{children:"这时可以加上 memo："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { memo, useEffect, useState } from \"react\";\n\nfunction Aaa() {\n    const [,setNum] = useState(1);\n\n    useEffect(() => {\n        setInterval(()=> {\n            setNum(Math.random());\n        }, 2000)\n    },[]);\n\n    return <div>\n        <MemoBbb count={2}></MemoBbb>\n    </div>\n} \n\ninterface BbbProps {\n    count: number;\n}\n\nfunction Bbb(props: BbbProps) {\n    console.log('bbb render');\n\n    return <h2>{props.count}</h2>\n}\n\nconst MemoBbb = memo(Bbb);\n\nexport default Aaa;\n"})}),"\n",(0,s.jsx)(n.p,{children:"memo 的作用是只有 props 变的时候，才会重新渲染被包裹的组件。"}),"\n",(0,s.jsx)(n.p,{children:"这样就只会打印一次了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们让 2s 后 props 变了呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { memo, useEffect, useState } from \"react\";\n\nfunction Aaa() {\n    const [,setNum] = useState(1);\n\n    const [count, setCount] = useState(2);\n\n\n    useEffect(() => {\n        setInterval(()=> {\n            setNum(Math.random());\n        }, 2000)\n    },[]);\n\n    useEffect(() => {\n        setTimeout(()=> {\n            setCount(Math.random());\n        }, 2000)\n    },[]);\n\n    return <div>\n        <MemoBbb count={count}></MemoBbb>\n    </div>\n} \n\ninterface BbbProps {\n    count: number;\n}\n\nfunction Bbb(props: BbbProps) {\n    console.log('bbb render');\n\n    return <h2>{props.count}</h2>\n}\n\nconst MemoBbb = memo(Bbb);\n\nexport default Aaa;\n"})}),"\n",(0,s.jsx)(n.p,{children:"props 变了会触发 memo 的重新渲染："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"用 memo 的话，一般还会结合两个 hook：useMemo 和 useCallback。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"memo 是防止 props 没变时的重新渲染，useMemo 和 useCallback 是防止 props 的不必要变化。"})}),"\n",(0,s.jsx)(n.p,{children:"给 Bbb 加一个 callback 的参数："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"参数传了一个 function，你会发现 memo 失效了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"因为每次 function 都是新创建的，也就是每次 props 都会变，这样 memo 就没用了。"}),"\n",(0,s.jsx)(n.p,{children:"这时候就需要 useCallback："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const bbbCallback = useCallback(function () {\n    // xxx\n}, []);\n"})}),"\n",(0,s.jsx)(n.p,{children:"它的作用就是当 deps 数组不变的时候，始终返回同一个 function，当 deps 变的时候，才把 function 改为新传入的。"}),"\n",(0,s.jsx)(n.p,{children:"这时候你会发现，memo 又生效了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"同理，useMemo 也是和 memo 打配合的，只不过它保存的不是函数，而是值："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const count2 = useMemo(() => {\n    return count * 10;\n}, [count]);\n"})}),"\n",(0,s.jsx)(n.p,{children:"它是在 deps 数组变化的时候，计算新的值返回。"}),"\n",(0,s.jsxs)(n.p,{children:["所以说，",(0,s.jsx)(n.strong,{children:"如果子组件用了 memo，那给它传递的对象、函数类的 props 就需要用 useMemo、useCallback 包裹，否则，每次 props 都会变，memo 就没用了。"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"反之，如果 props 使用 useMemo、useCallback，但是子组件没有被 memo 包裹，那也没意义，因为不管 props 变没变都会重新渲染，只是做了无用功。"})}),"\n",(0,s.jsx)(n.p,{children:"memo + useCallback、useMemo 是搭配着来的，少了任何一方，都会使优化失效。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"但 useMemo 和 useCallback 也不只是配合 memo 用的："})}),"\n",(0,s.jsx)(n.p,{children:"比如有个值的计算，需要很大的计算量，你不想每次都算，这时候也可以用 useMemo 来缓存。"}),"\n",(0,s.jsxs)(n.p,{children:["案例代码上传了",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/hook-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节我们过了一遍 React 常用的 hook："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"useState"}),"：状态是变化的数据，是组件甚至前端应用的核心。useState 有传入值和函数两种参数，返回的 setState 也有传入值和传入函数两种参数。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"useEffect"}),"：副作用 effect 函数是在渲染之外额外执行的一些逻辑。它是根据第二个参数的依赖数组是否变化来决定是否执行 effect，可以返回一个清理函数，会在下次 effect 执行前执行。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"useLayoutEffect"}),"：和 useEffect 差不多，但是 useEffect 的 effect 函数是异步执行的，所以可能中间有次渲染，会闪屏，而 useLayoutEffect 则是同步执行的，所以不会闪屏，但如果计算量大可能会导致掉帧。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"useReducer"}),"：封装一些修改状态的逻辑到 reducer，通过 action 触发，当修改深层对象的时候，创建新对象比较麻烦，可以结合 immer"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"useRef"}),"：可以保存 dom 引用或者其他内容，通过 xxRef.current 来取，改变它的内容不会触发重新渲染"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"forwardRef + useImperativeHandle"}),"：通过 forwardRef 可以从子组件转发 ref 到父组件，如果想自定义 ref 内容可以使用 useImperativeHandle"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"useContext"}),"：跨层组件之间传递数据可以用 Context。用 createContext 创建 context 对象，用 Provider 修改其中的值， function 组件使用 useContext 的 hook 来取值，class 组件使用 Consumer 来取值"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"memo + useMemo + useCallback"}),"：memo 包裹的组件只有在 props 变的时候才会重新渲染，useMemo、useCallback 可以防止 props 不必要的变化，两者一般是结合用。不过当用来缓存计算结果等场景的时候，也可以单独用 useMemo、useCallback"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"当然，react 的 hook 还有一些，那些不大常用的，等用到的时候再说。"}),"\n",(0,s.jsx)(n.p,{children:"class 组件被标记为 lagency 了，现在写 React 组件主要是 function 组件。"}),"\n",(0,s.jsx)(n.p,{children:"函数组件主要是学习 hook，所以把这节的内容掌握了，react 基础就算差不多了。"})]})}function eg(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(eb,{...e})}):eb(e)}let eA=eg;eg.__RSPRESS_PAGE_META={},eg.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC02%E7%AB%A0%E2%80%94%E4%B8%80%E7%BD%91%E6%89%93%E5%B0%BD%E7%BB%84%E4%BB%B6%E5%B8%B8%E7%94%A8Hook.md"]={toc:[{text:"useState",id:"usestate",depth:2},{text:"useEffect",id:"useeffect",depth:2},{text:"useLayoutEffect",id:"uselayouteffect",depth:2},{text:"useReducer",id:"usereducer",depth:2},{text:"useReducer + immer",id:"usereducer--immer",depth:2},{text:"useRef",id:"useref",depth:2},{text:"forwardRef + useImperativeHandle",id:"forwardref--useimperativehandle",depth:2},{text:"useContext",id:"usecontext",depth:2},{text:"memo + useMemo + useCallback",id:"memo--usememo--usecallback",depth:2},{text:"总结",id:"总结",depth:2}],title:"第02章—一网打尽组件常用Hook",headingTitle:"第02章—一网打尽组件常用Hook",frontmatter:{}}}}]);