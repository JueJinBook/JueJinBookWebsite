"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["41014"],{299565:function(e,n,t){t.r(n),t.d(n,{default:()=>o});var s=t(552676),i=t(740453);let r=t.p+"static/image/90d858ab41b39ecd42cd4240ac5ef1e8.739ab073.webp",c=t.p+"static/image/ec0fa6928c8e2d57175ea3cac4929a69.ca83f311.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",img:"img",pre:"pre",h2:"h2"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"16-理解-http使用文件压缩节约带宽",children:["16 理解 HTTP：使用文件压缩节约带宽",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16-理解-http使用文件压缩节约带宽",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上一节课，我们介绍了 HTTP 服务的缓存策略，能够将请求的内容通过浏览器缓存起来。一般来说，Web 应用开发者通常会将资源文件包括静态的 HTML、图片、JS、CSS 以及视频音频等多媒体资源尽可能地缓存起来，这样能大大减少带宽消耗，节约成本，也能让浏览器打开网页的速度有显著提升。因此，缓存策略是重要的 Web 服务优化手段。"}),"\n",(0,s.jsx)(n.p,{children:"而这一节课，我们将介绍另一个重要的 Web 服务优化手段：文件压缩。浏览器除了支持原始的 HTTP 协议文本外，还支持以压缩的方式发送的内容。"}),"\n",(0,s.jsxs)(n.p,{children:["HTTP 协议规定，客户端支持的编码格式由",(0,s.jsx)(n.code,{children:"Accept-Encoding"}),"指定。下图是最新的 Chrome 浏览器下访问网页的请求头中的",(0,s.jsx)(n.code,{children:"Accept-Encoding"}),"字段，有三个值，表示支持三种格式，分别是 gzip、deflate 和 br。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"gzip、deflate 和 br 是三种不同的压缩算法，其中 gzip 和 deflate 是同一种格式（gzip）的两种不同算法实现，而 br 则是使用 Brotli 算法的压缩格式。Node.js 的内置模块 zlib 对这三种算法都能支持。"}),"\n",(0,s.jsx)(n.p,{children:"zlib 库是 Node 内置的强大的压缩/解压库，用它来压缩或解压数据都很方便。因为 Node.js 基于 v8，而 v8 也是 Chrome 浏览器的 JS 引擎，所以我们只需要在服务器对数据进行压缩即可，解压会由浏览器自动完成。当然，其它浏览器也会自动解压文件，只是算法不同而已。"}),"\n",(0,s.jsx)(n.p,{children:"我们修改一下上一节课的 HTTP 服务器："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"... \n// http-compression.js\n\nconst zlib = require('zlib');\n\nconst server = http.createServer((req, res) => {\n  let filePath = path.resolve(__dirname, path.join('www', url.fileURLToPath(`file:///${req.url}`)));\n\n  if(fs.existsSync(filePath)) {\n    const stats = fs.statSync(filePath);\n    if(stats.isDirectory()) {\n      filePath = path.join(filePath, 'index.html');\n    }\n    if(fs.existsSync(filePath)) {\n      const {ext} = path.parse(filePath);\n      const stats = fs.statSync(filePath);\n      const timeStamp = req.headers['if-modified-since'];\n      let status = 200;\n      if(timeStamp && Number(timeStamp) === stats.mtimeMs) {\n        status = 304;\n      }\n      res.writeHead(status, {\n        'Content-Type': mime.getType(ext),\n        'Cache-Control': 'max-age=86400', // 缓存一天\n        'Last-Modified': stats.mtimeMs,\n        'Content-Encoding': 'deflate', // 告诉浏览器该文件是用deflate算法压缩的\n      });\n      if(status === 200) {\n        const fileStream = fs.createReadStream(filePath);\n        fileStream.pipe(zlib.createDeflate()).pipe(res);\n      } else {\n        res.end();\n      }\n    }\n  } else {\n    res.writeHead(404, {'Content-Type': 'text/html'});\n    res.end('<h1>Not Found</h1>');\n  }\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这段代码显示了给资源文件添加压缩是非常简单的。zlib 提供了",(0,s.jsx)(n.code,{children:"createDeflate()"}),"、",(0,s.jsx)(n.code,{children:"createGZip()"}),"以及",(0,s.jsx)(n.code,{children:"createBrotliCompress()"}),"等方法，这些方法返回流对象，所以只需要用 pipe 方法 将这个对象和 fileStream 以及 res 连接起来即可："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"fileStream.pipe(zlib.createDeflate()).pipe(res);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这样，我们请求的时候，返回的内容就是经过压缩的了。不过我们还要记得设置一个",(0,s.jsx)(n.code,{children:"Content-Encoding"}),"响应头，告诉浏览器这个数据内容是经过压缩的。",(0,s.jsx)(n.code,{children:"Content-Encoding"}),"响应头的值是对应的压缩算法名，那么浏览器就会调用相应的解压算法来对资源进行解压了。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了对比明显一些，我在 index.html 中加入了一个比较大的脚本库",(0,s.jsx)(n.code,{children:"spritejs"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Index</title>\n</head>\n<body>\n  <h1>君喻教育2</h1>\n  <img src="assets/image/logo.png">\n  <script src="assets/js/spritejs.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这个",(0,s.jsx)(n.code,{children:"spritejs.js"}),"文件内容有 1.3MB，但是我们启用了 deflate 压缩之后，传输的内容就只有 247KB 了。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"一般来说，我们对 HTML、JS、CSS 这样的资源文件启用压缩，而图片、音频、视频等格式因为通常已经经过了压缩，再启用压缩意义不大，还可能还会适得其反，所以我们可以根据 MIME type 判断一下，只对 text、appliaction 类型启用压缩："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"...\n\nconst mimeType = mime.getType(ext);\nconst responseHeaders = {\n  'Content-Type': mimeType,\n  'Cache-Control': 'max-age=86400', // 缓存一天\n  'Last-Modified': stats.mtimeMs,\n};\nconst compress = /^(text|application)\\//.test(mimeType);\nif(compress) {\n  responseHeaders['Content-Encoding'] = 'deflate';\n}\nres.writeHead(status, responseHeaders);\n\n...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上面代码所示，我们通过正则表达式",(0,s.jsx)(n.code,{children:"/^(text|application)\\//"}),"判断 mimeType 的主类型是否是 text 或 application，只对这两种类型启用压缩。"]}),"\n",(0,s.jsxs)(n.p,{children:["上面的例子我们只实现了 deflate 一种压缩算法，因为我们的网页除了运行在浏览器外，还可以在不同的客户端运行，不同的客户端所支持的压缩算法不同，所以，我们需要根据客户端的",(0,s.jsx)(n.code,{children:"Accept-Encoding"}),"请求头字段实现多种压缩算法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"...\n\nconst mimeType = mime.getType(ext);\nconst responseHeaders = {\n  'Content-Type': mimeType,\n  'Cache-Control': 'max-age=86400', // 缓存一天\n  'Last-Modified': stats.mtimeMs,\n};\nconst acceptEncoding = req.headers['accept-encoding'];\nconst compress = acceptEncoding && /^(text|application)\\//.test(mimeType);\nif(compress) {\n  // 返回客户端支持的一种压缩方式\n  acceptEncoding.split(/\\s*,\\s*/).some((encoding) => {\n    if(encoding === 'gzip') {\n      responseHeaders['Content-Encoding'] = 'gzip';\n      return true;\n    }\n    if(encoding === 'deflate') {\n      responseHeaders['Content-Encoding'] = 'deflate';\n      return true;\n    }\n    if(encoding === 'br') {\n      responseHeaders['Content-Encoding'] = 'br';\n      return true;\n    }\n    return false;\n  });\n}\nconst compressionEncoding = responseHeaders['Content-Encoding']; // 获取选中的压缩方式\nres.writeHead(status, responseHeaders);\nif(status === 200) {\n  const fileStream = fs.createReadStream(filePath);\n  if(compress && compressionEncoding) {\n    let comp;\n    \n    // 使用指定的压缩方式压缩文件\n    if(compressionEncoding === 'gzip') {\n      comp = zlib.createGzip();\n    } else if(compressionEncoding === 'deflate') {\n      comp = zlib.createDeflate();\n    } else {\n      comp = zlib.createBrotliCompress();\n    }\n    fileStream.pipe(comp).pipe(res);\n  } else {\n    fileStream.pipe(res);\n  }\n} else {\n  res.end();\n}\n...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上代码所示，根据客户端请求头中的",(0,s.jsx)(n.code,{children:"req.headers['accept-encoding']"}),"信息，通过数组的 some 方法，判断客户端是否支持 gzip、deflate、或者 br 中的一种压缩算法。如果结果为 true，我们就是用对应的压缩算法压缩我们的文件。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这一节课我们学习了如何用 zlib 模块提供的压缩算法对 HTTP 内容进行压缩。"}),"\n",(0,s.jsx)(n.p,{children:"浏览器支持 gzip、deflate 和 br 这三种压缩算法，使用它们压缩文件，能够大大节省传输带宽，提升请求的响应速度，减少页面访问的延迟。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F16%20%E7%90%86%E8%A7%A3%20HTTP%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E8%8A%82%E7%BA%A6%E5%B8%A6%E5%AE%BD.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"16 理解 HTTP：使用文件压缩节约带宽",headingTitle:"16 理解 HTTP：使用文件压缩节约带宽",frontmatter:{}}}}]);