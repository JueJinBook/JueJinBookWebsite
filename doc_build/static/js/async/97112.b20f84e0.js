"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["97112"],{263105:function(e,n,s){s.r(n),s.d(n,{default:()=>_});var r=s(552676),t=s(740453);let i=s.p+"static/image/819b3c9583b871aeee027e925545f9e9.0fd04685.webp",c=s.p+"static/image/09daf9dc859f75669af2fc3fcaed0ca5.6ecc6197.webp",a=s.p+"static/image/33ee28620764861dc02acd41fdec8dba.5e49ec89.webp",o=s.p+"static/image/ad9e70b60f1ca9d8588212a6f1e807a7.f14c1684.webp",l=s.p+"static/image/b09c38ac5f4114342185c3a79c47d33d.593ca827.webp",d=s.p+"static/image/9c61cf690f6b1dcb11cdbfc82347d1f5.3f66e2c9.webp",m=s.p+"static/image/bcdcd6aab6ce5e76d23a8924e0a41da5.3d0201df.webp",p=s.p+"static/image/95010b5c7d7646126014ef018880c48b.b6b16fb0.webp",h=s.p+"static/image/fbae114ff0470f3c4ef6b665908df6d0.cbd00343.webp",j=s.p+"static/image/ad8bdc4f64ddb66feafc8653d803755f.3ea9f94a.webp",x=s.p+"static/image/23aa17397fa108e2374902276e36f7c4.af36a5ed.webp",f=s.p+"static/image/e755749c86ce4c5ecefa7c9b801365eb.64449864.webp",u=s.p+"static/image/447242f80e74a0edfda54f6ef7fbf30f.7f35765d.webp",b=s.p+"static/image/65e821f54f72e4c0e509e47544845257.1400eb50.webp",T=s.p+"static/image/691be7eb91d896d4876909c1ec842b8c.ca802ddf.webp",k=s.p+"static/image/91178f0b72eebd030548067c01235101.95bcb086.webp",g=s.p+"static/image/64b095a78ed854fffe4fef8c5f3e160a.8bba50d1.webp";function F(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",img:"img",pre:"pre",code:"code"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"9faketimer如何-快进-测试定时任务",children:["9.FakeTimer：如何 快进 测试定时任务？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9faketimer如何-快进-测试定时任务",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["代码仓库：",(0,r.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"在上节课中，我们学习了怎么对异步逻辑书写测试用例，针对特殊的异步逻辑，我们通常会使用 waitfor 来重复执行需要验证的回调函数，来完成异步逻辑的测试。在我们的需求当中，难免会遇到像轮询、定时任务的场景，对于这类场景我们会使用 setTimeout、 setInterval 等定时器来实现。"}),"\n",(0,r.jsx)(n.p,{children:"针对这类异步的方法，上节课我们有介绍可以使用 waitfor 来覆盖对应的用例，但是存在一个问题是，如果定时的时长短那可能还行，但是如果定时器多且定时时间不短，我们每则用例都将需要等待那么长的时间，这个其实是不合理的。"}),"\n",(0,r.jsx)(n.p,{children:"针对这种场景，Jest 有提供给我们一组叫 Fake Timer(假定时器）的 API，这节课我们就来学习怎么通过 Fake Timer 来快进我们的任务，以及 Fake Timer 是怎么做到快进效果的。"}),"\n",(0,r.jsxs)(n.h2,{id:"一个小插曲",children:["一个小插曲",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一个小插曲",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在开始这节课的学习前，我们插入一个小插曲。在之前的用例执行中，我们发现控制台会输出每次查询的 DOM 结果，这个可以方便我们追溯问题的源头或者快速调试我们的用例，但是当测试用例堆积多了以后，这个 log 栈是比较长的，很难定位到我们需要的位置，也可能很容易丢失。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["对于这个问题，我们其实可以利用 jest 提供给我们的 mock 函数去覆盖全局的 log，那么在哪里加呢？之前在 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7174044519350927395/section/7176612133294063668",target:"_blank",rel:"noopener noreferrer",children:"2 | 技术选型：React Testing Library Or Enzyme？"})," 介绍 React testing library 的时候，我们提到在配置中，我们会在一个全局的文件中导入 React testing library 所提供的相关断言类型，我们只需要在下面继续补充就好，这样就只会针对测试环境生效，而不会干扰到我们正常的 DOM。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/setupTests.ts\nimport "@testing-library/jest-dom";\n\n// 移除 jest 的 log 输出\nglobal.console = {\n  log: jest.fn(),\n  debug: console.debug,\n  trace: console.trace,\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"针对 debug 和 trace 我们还是注入原来的函数，调试和日志我们还是需要查看的，来试试效果，可以看到就已经没有额外的 log 输出了，看上去清爽多了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"定时快进",children:["定时快进",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定时快进",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在我们回到正题中来，如果我们的组件涉及到定时的逻辑，定时的时间很长，即使用例本身不超时，执行所需要的时间也是我们不能接受的，所以为了解决这个场景的问题，Jest 提供了一组 Fake Timers API 来跳过定时的等待时长。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们可以先看下面的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// ./src/components/FakeTimer/index.ts\nconst sleep = async (time: number, result: string): Promise<string> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(result);\n    }, time);\n  });\n};\n\nexport { sleep };\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/fakeTimer.test.ts\nimport React from "react";\nimport { sleep } from "../components/FakeTimer";\n\n// 9 | FakeTimer：如何"快进"测试定时任务？\ndescribe("examples for fakeTimers", () => {\n  beforeAll(() => {\n    jest.useFakeTimers();\n  });\n\n  test("a test for a simple setTimeout", async () => {\n    const res = sleep(6000, "this is a simple setTimeout test");\n    jest.runAllTimers();\n    await expect(res).resolves.toBe("this is a simple setTimeout test");\n  });\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在上面的例子中，如果我们定义了一个 sleep 函数，这个函数很简单，它接受两个入参，time 和 result，会在经过 time 时间后将 result 返回，那么如果这个 time 超过了 5000 ms，用例将会执行失败（因为 jest 用例的默认超时时间为 5000ms），所以我们注释掉",(0,r.jsx)(n.code,{children:"jest.runAllTimers()"}),"会得到下面的错误栈信息。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果我们直接执行上面用例是可以通过的，大家会发现用例可以快速通过，而不需要等待 6 秒以上。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["这个用例与常规用例不同的是，我们在 beforeAll 中加入",(0,r.jsx)(n.code,{children:"jest.useFakeTimers()"}),"，用例本身中启用了",(0,r.jsx)(n.code,{children:"jest.runAllTimers()"}),"，其中",(0,r.jsx)(n.code,{children:"jest.useFakeTimers()"}),"的作用是将定时器替换为假定时器，而",(0,r.jsx)(n.code,{children:"jest.runAllTimers()"}),"的作用是运行所有的定时器，我们可以结合 ",(0,r.jsx)(n.a,{href:"https://github1s.com/facebook/jest/blob/HEAD/packages/jest-fake-timers/src/legacyFakeTimers.ts#L264",target:"_blank",rel:"noopener noreferrer",children:"源码"})," 看看 jest 是怎么实现这样一个假定时器的，简单但是很精妙。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["大家可以直接关注 ",(0,r.jsx)(n.code,{children:"_createMocks"}),"，下面的逻辑只是将 _fakeTimerApis 中的方法覆盖给 global 全局，所以我们调用的 setTimeout 等方法其实是 ",(0,r.jsx)(n.code,{children:"_fakeTimerApis"})," 提供的，在没有执行",(0,r.jsx)(n.code,{children:"  _createMocks "})," 前， ",(0,r.jsx)(n.code,{children:"_fakeTimerApis"})," 中的方法其实就是原生对应方法的写入。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["在",(0,r.jsx)(n.code,{children:"  _createMocks "}),"中，它会覆写 ",(0,r.jsx)(n.code,{children:"_fakeTimerApis"})," 中提供的方法，以 setTimeout 的覆写方法为例。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["_timers 中存放了所有定时器的定时时长，是一个 key - value 的结构，在覆写的方法中，如果没有 delay 的传参，timers 存入的定时器时长就会是 0 ，也就是说我们在执行 ",(0,r.jsx)(n.code,{children:"jest.useFakeTimers()"}),"后，执行的 setTimeout 等方法会被 jest 全部覆写，不再是原来的原生方法。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们再来看看，执行",(0,r.jsx)(n.code,{children:"jest.runAllTimers()"}),"后是怎么立即执行的呢？很多同学已经猜到了，只需要把对应 _timers 下的定时时长删了就可以了，这样找不到对应的定时时长，就可以立即执行了。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["实际的逻辑中还包含了别的定时方法的清除，这边我们以 setTimeout 为例，对应的方法是 ",(0,r.jsx)(n.code,{children:"_runTimerHandle"}),"，可以看到和我们想的一样。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"除了立即执行所有的定时器外，我们其实还可以控制定时器的执行时间，我们来看下面的例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/components/FakeTimer/index.ts\nimport React from "react";\nimport { sleep } from "../components/FakeTimer";\n\n// 9 | FakeTimer：如何"快进"测试定时任务？\ndescribe("examples for fakeTimers", () => {\n  beforeAll(() => {\n    jest.useFakeTimers();\n  });\n\n  // ... other content\n  test("a test for a controllable setTimeout", async () => {\n    const res = sleep(6000, "this is a controllable setTimeout");\n    jest.advanceTimersByTime(6000);\n    await expect(res).resolves.toBe("this is a controllable setTimeout");\n  });\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["我们使用 ",(0,r.jsx)(n.code,{children:"jest.advanceTimersByTime"})," 就可以将所有的定时器提前指定时间。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"递归场景的定时快进",children:["递归场景的定时快进",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#递归场景的定时快进",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["当然除了常规的定时外，轮询也是我们业务中常常遇到的一个场景，通过轮询，可以使我们应用获得实时的效果，但是轮询需要使用到递归，如果还是使用 ",(0,r.jsx)(n.code,{children:"runAllTimers"}),"，将会遇到栈溢出的问题，我们来看下面例子："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// ./src/components/FakeTimer/index.ts\n// ... other function\nconst loopSleep = async (time: number, result: string): Promise<string> => {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(result);\n      setTimeout(() => {\n        loopSleep(time, result);\n      }, time);\n    }, time);\n  });\n};\n\n// ...export \n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/components/FakeTimer/index.ts\nimport React from "react";\nimport { sleep } from "../components/FakeTimer";\n\n// 9 | FakeTimer：如何"快进"测试定时任务？\ndescribe("examples for fakeTimers", () => {\n  beforeAll(() => {\n    jest.useFakeTimers();\n  });\n\n  // ... other content\n  test("a test for a recursion setTimeout", async () => {\n    const res = loopSleep(6000, "this is a recursion setTimeout test");\n    jest.runAllTimers();\n    await expect(res).resolves.toBe("this is a recursion setTimeout test");\n  });\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"如果运行这个用例，我们将得到下面的错误栈："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["因为 ",(0,r.jsx)(n.code,{children:"jest.runAllTimers()"}),"会运行所有的定时器，不论这个定时器是否在等待中，而因为递归的关系，我们的定时完成后，始终会有一次新的定时，所以会导致我们栈溢出，针对这种场景我们可以使用",(0,r.jsx)(n.code,{children:"runOnlyPendingTimers"}),"，它只会运行目前挂起的定时器，我们修改一下用例："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/components/FakeTimer/index.ts\nimport React from "react";\nimport { sleep, loopSleep } from "../components/FakeTimer";\n\n// 9 | FakeTimer：如何"快进"测试定时任务？\ndescribe("examples for fakeTimers", () => {\n  beforeAll(() => {\n    jest.useFakeTimers();\n  });\n\n  // ... other content\n  test("a test for a recursion setTimeout", async () => {\n    const res = loopSleep(6000, "this is a recursion setTimeout test");\n    // jest.runAllTimers();\n    jest.runOnlyPendingTimers();\n    await expect(res).resolves.toBe("this is a recursion setTimeout test");\n  });\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"我们运行一下用例，可以看到现在已经可以通过了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["到这里我们常用的 FakeTimer 就都介绍过了，除了 ",(0,r.jsx)(n.code,{children:"useRealTimers"}),"，这个和 ",(0,r.jsx)(n.code,{children:"useFakeTimers"}),"作用相反，可以把 setTimeout 接管回真实的定时器原生方法，比较简单就不额外举例说明了。"]}),"\n",(0,r.jsxs)(n.h2,{id:"包含异步函数的定时器快进",children:["包含异步函数的定时器快进",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#包含异步函数的定时器快进",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"除了上面的基础用法外，其实还有一个很容易犯错的场景（我当时也忽略很多次=.=），我们直接看下面的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// ./src/components/FakeTimer/index.ts\n// ... other function\nconst asyncSleep = async (time: number, fn: () => void): Promise<void> => {\n  setTimeout(() => {\n    Promise.resolve().then(() => {\n      fn();\n    });\n  }, time);\n};\n\n// ...export \n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'import React from "react";\nimport { sleep, loopSleep, asyncSleep } from "../components/FakeTimer";\n\n// 9 | FakeTimer：如何"快进"测试定时任务？\ndescribe("examples for fakeTimers", () => {\n  beforeAll(() => {\n    jest.useFakeTimers();\n  });\n\n  // ... other content\n  test("a test for a setTimeout with async function", async () => {\n    const fn = jest.fn();\n    asyncSleep(6000, fn);\n    jest.runOnlyPendingTimers();\n    expect(fn).toBeCalled();\n  });\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在上面的例子中，我们写了一个定时函数，当时间到的时候，会异步执行我们传入的回调函数，在用例中，我们使用了 jest 提供的 mock 函数",(0,r.jsx)(n.code,{children:"jest.fn()"}),"，同学们这里不懂不要紧，我们会在 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7174044519350927395/section/7176804272833724416",target:"_blank",rel:"noopener noreferrer",children:"10 | Mock: 怎么用模拟数据替代较复杂逻辑？"})," 详细介绍，这个 fn 就是我们的一个没有返回值的回调函数，可以理解成一个空函数。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们定时了 6 秒执行，并通过",(0,r.jsx)(n.code,{children:"jest.runOnlyPendingTimers"}),"快进了这个过程，然后给出了一个断言，我们认为快进完成后，传入的回调函数 fn 应该被调用了，可是用例的结果却差强人意。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["为什么会出现这样的情况呢？在 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7174044519350927395/section/7176612133516345378",target:"_blank",rel:"noopener noreferrer",children:"8 | Async 异步：异步方法如何进行单测？"})," 中我们其实有详细介绍异步的原理，JS 本身是没有异步的能力的，在执行引擎的帮助下，我们通过额外的一个线程，任务队列来存放异步的任务，在主线程任务完成后，才会去任务队列中取任务执行，不仅是浏览器引擎，Nodejs 环境下的 V8 引擎也采用类似的策略（蹭一下上节课画的图，同学们可以结合理解）。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["我们回到这个例子，我们知道",(0,r.jsx)(n.code,{children:"jest.runOnlyPendingTimers()"})," 内部实现其实只是把 time 给清空了，立即执行了其中的内容，但是在这个例子中，",(0,r.jsx)(n.code,{children:"setTimeout"})," 我们存放的是一个异步的任务，上面说过，异步任务是不会被立即执行的，而是存放到任务队列中，所以对于这个例子，我们并不是立即执行函数，而是立即将它放到任务队列，在主线程任务完成后，才能轮到它。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"所以当我们断言执行的时候，我们加入的异步逻辑还在任务队列里待着呢，自然我们感知不到它被调用，那应该怎么解决这个问题呢？我们加一个 await 来阻塞断言的执行，期待等待异步逻辑完成后，我们再执行下面的断言，我们来看修改后的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'import React from "react";\nimport { sleep, loopSleep, asyncSleep } from "../components/FakeTimer";\n\n// 9 | FakeTimer：如何"快进"测试定时任务？\ndescribe("examples for fakeTimers", () => {\n  beforeAll(() => {\n    jest.useFakeTimers();\n  });\n\n  // ... other content\n  test("a test for a setTimeout with async function", async () => {\n    const fn = jest.fn();\n    asyncSleep(6000, fn);\n    jest.runOnlyPendingTimers();\n    await Promise.resolve();\n    expect(fn).toBeCalled();\n  });\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["因为",(0,r.jsx)(n.code,{children:"Promise.resolve"}),"是在 fn 之后放入任务队列的，对它执行 await 就可以保证之前放进任务队列的任务可以得到执行，我们现在再来看看结果："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节课我们学习了怎么“快进”我们的测试定时任务，使用了 Jest 的 FakeTimer API 分别解决了定时快进，递归场景快进和异步函数的定时快进，并且我们还结合了源码解释了 FakeTimer API，究竟是怎么实现“快进”的，现在大家可以说出来其中的细节了吗？"}),"\n",(0,r.jsx)(n.p,{children:"严格意义上来说，这个其实并不是一个快进的行为，而是将我们的定时原生方法进行了拦截，修改了相关的 time，当我们在进行 “快进” 行为时，已经不再是运行原生 global 下的函数了，这种思想大家也可以学习一下，在平时需求中，全局日志或是钩子等地方都有这种思想的影子。"}),"\n",(0,r.jsx)(n.p,{children:"在课程的结尾，我们的例子中还用到了 Jest 的 Mock。 在我们的业务逻辑中，有些逻辑可能我们并不在意它的执行，我们只需要保证它的结果继续进行单测，这种场景下我们常常就会使用 Mock 来替代，是我们单测过程中一个很重要的手段。"}),"\n",(0,r.jsx)(n.p,{children:"下节课我们就来着重学习，怎么使用 Mock 来替代我们不需要关注的逻辑。"})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(F,{...e})}):F(e)}let _=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F9.FakeTimer%EF%BC%9A%E5%A6%82%E4%BD%95%20%E5%BF%AB%E8%BF%9B%20%E6%B5%8B%E8%AF%95%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9F.md"]={toc:[{text:"一个小插曲",id:"一个小插曲",depth:2},{text:"定时快进",id:"定时快进",depth:2},{text:"递归场景的定时快进",id:"递归场景的定时快进",depth:2},{text:"包含异步函数的定时器快进",id:"包含异步函数的定时器快进",depth:2},{text:"小结",id:"小结",depth:2}],title:"9.FakeTimer：如何 快进 测试定时任务？",headingTitle:"9.FakeTimer：如何 快进 测试定时任务？",frontmatter:{}}}}]);