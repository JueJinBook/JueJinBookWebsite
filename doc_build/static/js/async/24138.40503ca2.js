"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["24138"],{617452:function(e,n,r){r.r(n),r.d(n,{default:()=>k});var d=r(552676),c=r(740453);let s=r.p+"static/image/b0b64c3816bd47d348628fa3383cb6bb.4fee78f5.webp",i=r.p+"static/image/b83ef0b0a5fe1009396f70d91c4c3b03.f7abdee9.webp",t=r.p+"static/image/e49980b2c484c5234610785a8895697e.0a176435.webp",l=r.p+"static/image/79997f521ed85c20b2bca875c393dc57.f92389c7.webp",a=r.p+"static/image/f9cb03390c4ace0f1159595de5d0c326.e8bf5d9e.webp",o=r.p+"static/image/91a5c9b630ea92a117182a41e9b20ef3.b4c7820c.webp",h=r.p+"static/image/09fa0cc1949ae6abbbfc62931c26cedc.65f33c57.webp",x=r.p+"static/image/acf777fad762fb50215c80a19baaeedf.6e88b47c.webp",p=r.p+"static/image/33ca0d5cb8d91efb8a7654ac21ed40dc.7195987b.webp",j=r.p+"static/image/7c14c342df4dc2a1afd2ffadee65d795.d765ea54.webp",u=r.p+"static/image/93ae70cf295c935e292d4b7bdd6bddd8.3b358edf.webp",m=r.p+"static/image/90749abc3e4bc7d4aa41c8f292df5e72.f92ac517.webp",b=r.p+"static/image/90ad2a3cdb94a1e50f7589411f6f27dd.a56ee9d7.webp",g=r.p+"static/image/82a25767ccd671eae098709ba8574895.2da442e2.webp",_=r.p+"static/image/d5e5975a2ceea58dafa41fe3b356cb10.f85c430a.webp",y=r.p+"static/image/29dafc616412970e2b80859bdc607b4f.c65af1e7.webp",f=r.p+"static/image/7177fe6c0c812ab777bdfa0ee6e1b6dc.c8b9c6e1.webp",w=r.p+"static/image/8ee41601c7df501543658fcfdbd6df9a.872d0222.webp",N=r.p+"static/image/55a5665b87a8a19212f2ed9115bfbd52.3ade652d.webp";function E(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h4:"h4",ul:"ul",li:"li",code:"code",img:"img",pre:"pre",blockquote:"blockquote",strong:"strong"},(0,c.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"8后端实战账单及其相关接口实现",children:["8.后端实战：账单及其相关接口实现",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8后端实战账单及其相关接口实现",children:"#"})]}),"\n",(0,d.jsxs)(n.h2,{id:"前言",children:["前言",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"账单接口是我们本次实战项目的核心模块，用户可以通过账单模块记录自己日常消费和收入情况。本章节我们需要编写五个接口："}),"\n",(0,d.jsx)(n.p,{children:"1、账单列表\n2、添加账单\n3、修改账单\n4、删除账单\n5、账单详情"}),"\n",(0,d.jsx)(n.p,{children:"这样一套增删改查操作下来，基本上可以用这套模式复制出另一套增删改查，所以业务基本上都是互通的，不同之处在于表与表之间能建立什么样的联系，同时也取决于需求方对业务的要求。"}),"\n",(0,d.jsxs)(n.h4,{id:"知识点",children:["知识点",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点",children:"#"})]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["一套 ",(0,d.jsx)(n.code,{children:"CRUD"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"多层级复杂数据结构的处理。"}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"egg-mysql"})," 的使用。"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"新增账单接口",children:["新增账单接口",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#新增账单接口",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["我们需要先实现新增一个账单，才能比较方便的制作后续的其他接口。我们先来回顾一下前面设计好的账单表 ",(0,d.jsx)(n.code,{children:"bill"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:N,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["根据上述表的属性，我们可以轻松的知道新增账单接口需要哪些字段，于是我们打开 ",(0,d.jsx)(n.code,{children:"/controller"}),"，在目录下新增 ",(0,d.jsx)(n.code,{children:"bill.js"})," 脚本文件，添加一个 ",(0,d.jsx)(n.code,{children:"add"})," 方法，代码如下:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"'use strict';\n\nconst moment = require('moment')\n\nconst Controller = require('egg').Controller;\n\nclass BillController extends Controller {\n  async add() {\n    const { ctx, app } = this;\n    // 获取请求中携带的参数\n    const { amount, type_id, type_name, date, pay_type, remark = '' } = ctx.request.body;\n\n    // 判空处理，这里前端也可以做，但是后端也需要做一层判断。\n    if (!amount || !type_id || !type_name || !date || !pay_type) {\n      ctx.body = {\n        code: 400,\n        msg: '参数错误',\n        data: null\n      }\n    }\n\n    try {\n      let user_id\n      const token = ctx.request.header.authorization;\n      // 拿到 token 获取用户信息\n      const decode = await app.jwt.verify(token, app.config.jwt.secret);\n      if (!decode) return\n      user_id = decode.id\n      // user_id 默认添加到每个账单项，作为后续获取指定用户账单的标示。\n      // 可以理解为，我登录 A 账户，那么所做的操作都得加上 A 账户的 id，后续获取的时候，就过滤出 A 账户 id 的账单信息。\n      const result = await ctx.service.bill.add({\n        amount,\n        type_id,\n        type_name,\n        date,\n        pay_type,\n        remark,\n        user_id\n      });\n      ctx.body = {\n        code: 200,\n        msg: '请求成功',\n        data: null\n      }\n    } catch (error) {\n      ctx.body = {\n        code: 500,\n        msg: '系统错误',\n        data: null\n      }\n    }\n  }\n}\n\nmodule.exports = BillController;\n"})}),"\n",(0,d.jsxs)(n.p,{children:["新增账单接口唯一需要注意的是，往数据库里写数据的时候，需要带上用户 ",(0,d.jsx)(n.code,{children:"id"}),"，这样便于后续查找、修改、删除，能找到对应用户的账单信息。所以本章节的所有接口，都是需要经过鉴权中间件过滤的。必须要拿到当前用户的 ",(0,d.jsx)(n.code,{children:"token"}),"，才能拿到用户的 ",(0,d.jsx)(n.code,{children:"id"})," 信息。"]}),"\n",(0,d.jsxs)(n.p,{children:["处理逻辑已经写完，我们需要把 ",(0,d.jsx)(n.code,{children:"service"})," 服务也安排上，打开 ",(0,d.jsx)(n.code,{children:"service"}),"，在目录下新建 ",(0,d.jsx)(n.code,{children:"bill.js"}),"，添加代码如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"'use strict';\n\nconst Service = require('egg').Service;\n\nclass BillService extends Service {\n  async add(params) {\n    const { ctx, app } = this;\n    try {\n      // 往 bill 表中，插入一条账单数据\n      const result = await app.mysql.insert('bill', params);\n      return result;\n    } catch (error) {\n      console.log(error);\n      return null;\n    }\n  }\n}\n\nmodule.exports = BillService;\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"app.mysql.insert"})," 是数据库插件 ",(0,d.jsx)(n.code,{children:"egg-mysql"})," 封装好的插入数据库操作。它是一个异步方法，所以我们很多地方都是需要异步操作的。"]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"不要忘记将接口抛出，很多时候写完了逻辑，忘记抛出接口，就报 404 错误。"}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// router.js\nrouter.post('/api/bill/add', _jwt, controller.bill.add); // 添加账单\n"})}),"\n",(0,d.jsxs)(n.p,{children:["打开我们的调试接口好伙伴 ",(0,d.jsx)(n.code,{children:"Postman"}),"，验证它："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:w,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["要注意的是 ",(0,d.jsx)(n.code,{children:"Headers"})," 中要带上 ",(0,d.jsx)(n.code,{children:"token"})," 信息如下："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:f,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"此时我们查看数据库内是否已经添加了数据，如下所示："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:y,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"id"})," 是自增属性，所以添加一条数据，默认就是 1 ，再添加一条，",(0,d.jsx)(n.code,{children:"id"})," 则为 2。"]}),"\n",(0,d.jsxs)(n.p,{children:["有同学会有疑问，这里的 ",(0,d.jsx)(n.code,{children:"type_id"})," 和 ",(0,d.jsx)(n.code,{children:"type_name"})," 属性从哪里来？"]}),"\n",(0,d.jsxs)(n.p,{children:["我们在添加账单列表的时候，会选择该笔账单的类型，如餐饮、购物、学习、奖金等等，这个账单类型就是我们我们之前定义的 ",(0,d.jsx)(n.code,{children:"type"})," 表里获取的。于是我们在这里实现手动定义好这张表的初始数据，如下所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:_,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["每个属性代表的意义我们可以返回第 5 章《数据库表的设计》查看详情。这里的 ",(0,d.jsx)(n.code,{children:"user_id"})," 属性为 0 ，代表的是通用的账单类型，所有用户都可以使用。如果后续有需要添加自定义属性，那么 ",(0,d.jsx)(n.code,{children:"user_id"})," 则需要指定某个用户的 ",(0,d.jsx)(n.code,{children:"id"}),"。"]}),"\n",(0,d.jsxs)(n.h2,{id:"账单列表获取",children:["账单列表获取",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#账单列表获取",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"账单列表的获取，我们可以先查看前端需要做成怎样的展示形式："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:g,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"分析上图，账单是以时间作为维度，比如我在 2021 年 1 月 1 日记录了 2 条账单，在 2021 年 1 月 2 日记录了 1 条账，单我们返回的数据就是这样的："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"[\n  {\n    date: '2020-1-1',\n    bills: [\n      {\n        // bill 数据表中的每一项账单\n      },\n      {\n        // bill 数据表中的每一项账单\n      }\n    ]\n  },\n  {\n    date: '2020-1-2',\n    bills: [\n      {\n        // bill 数据表中的每一项账单\n      },\n    ]\n  }\n]\n"})}),"\n",(0,d.jsxs)(n.p,{children:["并且我们前端还需要做滚动加载更多，所以服务端是需要给分页的。于是就需要在获取 ",(0,d.jsx)(n.code,{children:"bill"})," 表里的数据之后，进行一系列的操作，将数据整合成上述格式。"]}),"\n",(0,d.jsx)(n.p,{children:"当然，获取的时间维度以月为单位，并且可以根据账单类型进行筛选。上图左上角有当月的总支出和总收入情况，我们也在列表数据中给出，因为它和账单数据是强相关的。"}),"\n",(0,d.jsxs)(n.p,{children:["于是，我们打开 ",(0,d.jsx)(n.code,{children:"/controller/bill.js"})," 添加一个 ",(0,d.jsx)(n.code,{children:"list"})," 方法，来处理账单数据列表："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"async list() {\n  const { ctx, app } = this;\n  // 获取，日期 date，分页数据，类型 type_id，这些都是我们在前端传给后端的数据\n  const { date, page = 1, page_size = 5, type_id = 'all' } = ctx.query\n\n  try {\n     let user_id\n      // 通过 token 解析，拿到 user_id\n      const token = ctx.request.header.authorization;\n      const decode = await app.jwt.verify(token, app.config.jwt.secret);\n      if (!decode) return\n      user_id = decode.id\n      // 拿到当前用户的账单列表\n      const list = await ctx.service.bill.list(user_id)\n      // 过滤出月份和类型所对应的账单列表\n      const _list = list.filter(item => {\n        if (type_id != 'all') {\n          return moment(Number(item.date)).format('YYYY-MM') == date && type_id == item.type_id\n        }\n        return moment(Number(item.date)).format('YYYY-MM') == date\n      })\n      // 格式化数据，将其变成我们之前设置好的对象格式\n      let listMap = _list.reduce((curr, item) => {\n        // curr 默认初始值是一个空数组 []\n        // 把第一个账单项的时间格式化为 YYYY-MM-DD\n        const date = moment(Number(item.date)).format('YYYY-MM-DD')\n        // 如果能在累加的数组中找到当前项日期 date，那么在数组中的加入当前项到 bills 数组。\n        if (curr && curr.length && curr.findIndex(item => item.date == date) > -1) {\n          const index = curr.findIndex(item => item.date == date)\n          curr[index].bills.push(item)\n        }\n        // 如果在累加的数组中找不到当前项日期的，那么再新建一项。\n        if (curr && curr.length && curr.findIndex(item => item.date == date) == -1) {\n          curr.push({\n            date,\n            bills: [item]\n          })\n        }\n        // 如果 curr 为空数组，则默认添加第一个账单项 item ，格式化为下列模式\n        if (!curr.length) {\n          curr.push({\n            date,\n            bills: [item]\n          })\n        }\n        return curr\n      }, []).sort((a, b) => moment(b.date) - moment(a.date)) // 时间顺序为倒叙，时间约新的，在越上面\n\n      // 分页处理，listMap 为我们格式化后的全部数据，还未分页。\n      const filterListMap = listMap.slice((page - 1) * page_size, page * page_size)\n\n      // 计算当月总收入和支出\n      // 首先获取当月所有账单列表\n      let __list = list.filter(item => moment(Number(item.date)).format('YYYY-MM') == date)\n      // 累加计算支出\n      let totalExpense = __list.reduce((curr, item) => {\n        if (item.pay_type == 1) {\n          curr += Number(item.amount)\n          return curr\n        }\n        return curr\n      }, 0)\n      // 累加计算收入\n      let totalIncome = __list.reduce((curr, item) => {\n        if (item.pay_type == 2) {\n          curr += Number(item.amount)\n          return curr\n        }\n        return curr\n      }, 0)\n\n      // 返回数据\n      ctx.body = {\n        code: 200,\n        msg: '请求成功',\n        data: {\n          totalExpense, // 当月支出\n          totalIncome, // 当月收入\n          totalPage: Math.ceil(listMap.length / page_size), // 总分页\n          list: filterListMap || [] // 格式化后，并且经过分页处理的数据\n        }\n      }\n  } catch {\n    ctx.body = {\n      code: 500,\n      msg: '系统错误',\n      data: null\n    }\n  }\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"代码逻辑的分析，全部以注释的形式编写，这样方便同学们边看代码，边分析逻辑，上述代码逻辑较长，希望大家能好好分析，实现逻辑越复杂，越能体现你作为程序员的价值。"}),"\n",(0,d.jsxs)(n.p,{children:["上述代码使用到了 ",(0,d.jsx)(n.code,{children:"service"})," 服务 ",(0,d.jsx)(n.code,{children:"ctx.service.bill.list"}),"，所以后续我们需要在 ",(0,d.jsx)(n.code,{children:"/service/bill.js"})," 下新建 ",(0,d.jsx)(n.code,{children:"list"})," 方法，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 获取账单列表\n  async list(id) {\n    const { ctx, app } = this;\n    const QUERY_STR = 'id, pay_type, amount, date, type_id, type_name, remark';\n    let sql = `select ${QUERY_STR} from bill where user_id = ${id}`;\n    try {\n      const result = await app.mysql.query(sql);\n      return result;\n    } catch (error) {\n      console.log(error);\n      return null;\n    }\n  }\n"})}),"\n",(0,d.jsxs)(n.p,{children:["这次我们利用执行 ",(0,d.jsx)(n.code,{children:"sql"})," 语句的形式，从数据库中获取需要的数据，",(0,d.jsx)(n.code,{children:"app.mysql.query"})," 方法负责执行你的 ",(0,d.jsx)(n.code,{children:"sql"})," 语句，上述 ",(0,d.jsx)(n.code,{children:"sql"})," 语句，解释成中文就是，“从 bill 表中查询 user_id 等于当前用户 id 的账单数据，并且返回的属性是 id, pay_type, amount, date, type_id, type_name, remark”。"]}),"\n",(0,d.jsx)(n.p,{children:"将接口抛出："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// router.js\nrouter.get('/api/bill/list', _jwt, controller.bill.list); // 获取账单列表\n"})}),"\n",(0,d.jsxs)(n.p,{children:["前往 ",(0,d.jsx)(n.code,{children:"Postman"})," 验证一下是否生效："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:b,alt:""})}),"\n",(0,d.jsxs)(n.h2,{id:"账单修改接口",children:["账单修改接口",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#账单修改接口",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["我们继续制作账单修改接口，修改接口和新增接口的区别在于，新增是在没有的情况下，编辑好参数，添加进数据库内部。而修改接口则是编辑现有的数据，根据当前账单的 ",(0,d.jsx)(n.code,{children:"id"}),"，更新数据。"]}),"\n",(0,d.jsx)(n.p,{children:"所以这里我们需要实现两个接口："}),"\n",(0,d.jsx)(n.p,{children:"1、获取账单详情接口"}),"\n",(0,d.jsx)(n.p,{children:"2、更新数据接口"}),"\n",(0,d.jsxs)(n.p,{children:["我们先来完成获取账单详情接口，在 ",(0,d.jsx)(n.code,{children:"/controller/bill.js"})," 添加 ",(0,d.jsx)(n.code,{children:"detail"})," 方法，代码如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 获取账单详情\nasync detail() {\n  const { ctx, app } = this;\n  // 获取账单 id 参数\n  const { id = '' } = ctx.query\n  // 获取用户 user_id\n  let user_id\n  const token = ctx.request.header.authorization;\n  // 获取当前用户信息\n  const decode = await app.jwt.verify(token, app.config.jwt.secret);\n  if (!decode) return\n  user_id = decode.id\n  // 判断是否传入账单 id\n  if (!id) {\n    ctx.body = {\n      code: 500,\n      msg: '订单id不能为空',\n      data: null\n    }\n    return\n  }\n\n  try {\n    // 从数据库获取账单详情\n    const detail = await ctx.service.bill.detail(id, user_id)\n    ctx.body = {\n      code: 200,\n      msg: '请求成功',\n      data: detail\n    }\n  } catch (error) {\n    ctx.body = {\n      code: 500,\n      msg: '系统错误',\n      data: null\n    }\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["编写完上述逻辑之后，我们还需要前往 ",(0,d.jsx)(n.code,{children:"/service/bill.js"})," 添加 ",(0,d.jsx)(n.code,{children:"ctx.service.bill.detail"})," 方法，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"async detail(id, user_id) {\n  const { ctx, app } = this;\n  try {\n    const result = await app.mysql.get('bill', { id, user_id })\n    return result;\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"抛出接口："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"router.get('/api/bill/detail', _jwt, controller.bill.detail); // 获取详情\n"})}),"\n",(0,d.jsxs)(n.p,{children:["打开 ",(0,d.jsx)(n.code,{children:"Postman"})," 查看是否能根据 ",(0,d.jsx)(n.code,{children:"id"})," 获取到账单："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:m,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"此时我们已经可以通过点击账单列表，前往账单详情页面，进行当前账单的编辑修改工作。"}),"\n",(0,d.jsxs)(n.p,{children:["于是乎，就引出了编辑账单接口，我们在 ",(0,d.jsx)(n.code,{children:"/controller/bill.js"})," 添加 ",(0,d.jsx)(n.code,{children:"update"})," 方法，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 编辑账单\nasync update() {\n  const { ctx, app } = this;\n  // 账单的相关参数，这里注意要把账单的 id 也传进来\n  const { id, amount, type_id, type_name, date, pay_type, remark = '' } = ctx.request.body;\n  // 判空处理\n  if (!amount || !type_id || !type_name || !date || !pay_type) {\n    ctx.body = {\n      code: 400,\n      msg: '参数错误',\n      data: null\n    }\n  }\n\n  try {\n    let user_id\n    const token = ctx.request.header.authorization;\n    const decode = await app.jwt.verify(token, app.config.jwt.secret);\n    if (!decode) return\n    user_id = decode.id\n    // 根据账单 id 和 user_id，修改账单数据\n    const result = await ctx.service.bill.update({\n      id, // 账单 id\n      amount, // 金额\n      type_id, // 消费类型 id\n      type_name, // 消费类型名称\n      date, // 日期\n      pay_type, // 消费类型\n      remark, // 备注\n      user_id // 用户 id\n    });\n    ctx.body = {\n      code: 200,\n      msg: '请求成功',\n      data: null\n    }\n  } catch (error) {\n    ctx.body = {\n      code: 500,\n      msg: '系统错误',\n      data: null\n    }\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ctx.service.bill.update"})," 便是操作数据库修改当前账单 ",(0,d.jsx)(n.code,{children:"id"})," 的方法，我们需要在 ",(0,d.jsx)(n.code,{children:"/service/bill.js"})," 添加相应的方法，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"async update(params) {\n  const { ctx, app } = this;\n  try {\n    let result = await app.mysql.update('bill', {\n        ...params\n    }, {\n        id: params.id,\n        user_id: params.user_id\n    });\n    return result;\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"app.mysql.update"})," 方法，我们在第 2 章基础入门篇已经有所解释，这边我们再能加深一下印象。"]}),"\n",(0,d.jsxs)(n.p,{children:["第一个参数为需要操作的数据库表名称 ",(0,d.jsx)(n.code,{children:"bill"}),"；第二个参数为需要更新的数据内容，这里直接将参数展开；第三个为查询参数，指定 ",(0,d.jsx)(n.code,{children:"id"})," 和 ",(0,d.jsx)(n.code,{children:"user_id"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"完事之后，将接口抛出："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"router.post('/api/bill/update', _jwt, controller.bill.update); // 账单更新\n"})}),"\n",(0,d.jsxs)(n.p,{children:["通过 ",(0,d.jsx)(n.code,{children:"Postman"})," 验证接口是否可行："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:u,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"通过详情接口，请求是否修改成功："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:j,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"不负所望，修改生效了。"}),"\n",(0,d.jsxs)(n.h2,{id:"账单删除接口",children:["账单删除接口",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#账单删除接口",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["删除接口可能是这几个接口中，最容易实现的一个。我们只需要获取到单笔账单的 ",(0,d.jsx)(n.code,{children:"id"}),"，通过 ",(0,d.jsx)(n.code,{children:"id"})," 去删除数据库中对应的账单数据。我们打开 ",(0,d.jsx)(n.code,{children:"/controller/bill.js"})," 添加 ",(0,d.jsx)(n.code,{children:"delete"})," 方法，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"async delete() {\n  const { ctx, app } = this;\n  const { id } = ctx.request.body;\n\n  if (!id) {\n    ctx.body = {\n      code: 400,\n      msg: '参数错误',\n      data: null\n    }\n  }\n\n  try {\n    let user_id\n    const token = ctx.request.header.authorization;\n    const decode = await app.jwt.verify(token, app.config.jwt.secret);\n    if (!decode) return\n    user_id = decode.id\n    const result = await ctx.service.bill.delete(id, user_id);\n    ctx.body = {\n      code: 200,\n      msg: '请求成功',\n      data: null\n    }\n  } catch (error) {\n    ctx.body = {\n      code: 500,\n      msg: '系统错误',\n      data: null\n    }\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["并且前往 ",(0,d.jsx)(n.code,{children:"/service/bill.js"})," 添加 ",(0,d.jsx)(n.code,{children:"delete"})," 服务，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"async delete(id, user_id) {\n  const { ctx, app } = this;\n  try {\n    let result = await app.mysql.delete('bill', {\n      id: id,\n      user_id: user_id\n  });\n    return result;\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"app.mysql.delete"})," 方法接收两个参数，第一个是数据库表名称，第二个是查询条件。这里我们给的查询条件是账单 ",(0,d.jsx)(n.code,{children:"id"})," 和用户 ",(0,d.jsx)(n.code,{children:"user_id"}),"。其实我们可以不传用户 ",(0,d.jsx)(n.code,{children:"user_id"}),"，因为我们的账单 ",(0,d.jsx)(n.code,{children:"id"})," 都是自增的，不会有重复值出现，不过安全起见，带上 ",(0,d.jsx)(n.code,{children:"user_id"})," 起到双保险的作用。"]}),"\n",(0,d.jsx)(n.p,{children:"我们将接口抛出："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// router.js\nrouter.post('/api/bill/delete', _jwt, controller.bill.delete); // 删除账单\n"})}),"\n",(0,d.jsxs)(n.p,{children:["我们打开老朋友 ",(0,d.jsx)(n.code,{children:"Postman"}),"，验证接口是否可行："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:p,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["报错信息为 “token 已过期，请重新登录”。这说明我们之前生成 ",(0,d.jsx)(n.code,{children:"token"})," 时，配置的时效生效了。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:x,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"当然，你可以将有效期设置成 1 分钟，这样方便测试有效期是否生效。"}),"\n",(0,d.jsxs)(n.p,{children:["我们重新通过登录接口获取新的 ",(0,d.jsx)(n.code,{children:"token"}),"，如下所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:h,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["通过新的 ",(0,d.jsx)(n.code,{children:"token"})," 再次发起删除接口请求："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:o,alt:""})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:a,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["请求成功，数据库 ",(0,d.jsx)(n.code,{children:"bill"})," 表里已经空空如也。"]}),"\n",(0,d.jsxs)(n.h2,{id:"数据图表模块",children:["数据图表模块",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数据图表模块",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["完成上述账单模块的一套 ",(0,d.jsx)(n.code,{children:"CRUD"})," 之后，同学们基本上对一张表的 ",(0,d.jsx)(n.code,{children:"增上改差"})," 处理，已经轻车熟路了。学习这件事情，很多时候就是靠不断地练习，甚至同一件事情，你不可能做一次就熟练，熟才能生巧。所以我们接下来再对数据模块进行处理和分析，制作出数据图表接口，我们在实现接口之前，先看看需要实现的需求："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:l,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["首先是头部的汇总数据，并且接口支持事件筛选，以 ",(0,d.jsx)(n.code,{children:"月"})," 为单位。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:t,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["其次是收支的构成图，对每一个类型的支出和收入进行累加，最后通过计算占比以此从大到小排布。如上图所示，当前月份的所有学习支出是 ",(0,d.jsx)(n.code,{children:"2553"}),"，这个累加计算，我们在服务端完成。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:i,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["最后我们引入 ",(0,d.jsx)(n.code,{children:"echarts"})," ，完成一个饼图的简单排布，其实也就是上图收支比例图的一个变种。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"我们最终要返回的数据机构如下："})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:'{\n  total_data: [\n    {\n      number: 137.84, // 支出或收入数量\n      pay_type: 1, // 支出或消费类型值\n      type_id: 1, // 消费类型id\n      type_name: "餐饮" // 消费类型名称\n    }\n  ],\n  total_expense: 3123.54, // 总消费\n  total_income: 6555.80 // 总收入\n}\n'})}),"\n",(0,d.jsxs)(n.h4,{id:"数据接口实现",children:["数据接口实现",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数据接口实现",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["经过上述分析，想必同学们已是胸有成竹。既然数据是和账单强相关，我们将方法写在 ",(0,d.jsx)(n.code,{children:"/controller/bill.js"})," 中，添加 ",(0,d.jsx)(n.code,{children:"data"})," 方法，首先根据用户信息，获取到账单表的相关数据，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"async data() {\n  const { ctx, app } = this;\n  const { date = '' } = ctx.query\n  // 获取用户 user_id\n  // 。。。\n  // 省略鉴权获取用户信息的代码\n  try {\n    // 获取账单表中的账单数据\n    const result = await ctx.service.bill.list(user_id);\n    // 根据时间参数，筛选出当月所有的账单数据\n    const start = moment(date).startOf('month').unix() * 1000; // 选择月份，月初时间\n    const end = moment(date).endOf('month').unix() * 1000; // 选择月份，月末时间\n    const _data = result.filter(item => (Number(item.date) > start && Number(item.date) < end))\n  } catch {\n    \n  }\n}\n"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"代码源码请看底部为大家提供的本章节源码 demo。"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["上述 ",(0,d.jsx)(n.code,{children:"_data"})," 便是我们经过筛选过滤出来的当月账单基础数据，每一条数据都是之前用户手动添加的，所以会有很多同类项。接下来，我们的工作就是将这些同类项进行合并。"]}),"\n",(0,d.jsx)(n.p,{children:"我们先计算总支出，在上述代码追加如下："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"...\n// 总支出\nconst total_expense = _data.reduce((arr, cur) => {\n  if (cur.pay_type == 1) {\n    arr += Number(cur.amount)\n  }\n  return arr\n}, 0)\n"})}),"\n",(0,d.jsxs)(n.p,{children:["数组方法 ",(0,d.jsx)(n.code,{children:"reduce"})," 的用处，超出你的想象。在一些累加操作上，它的优势展露无疑。就比如上述需求，我们需要在一串数组中，将每一项的支出 ",(0,d.jsx)(n.code,{children:"amount"})," 值，累加起来最后返回给 ",(0,d.jsx)(n.code,{children:"total_expense"}),"。你当然可以通过 ",(0,d.jsx)(n.code,{children:"forEach"})," 方法，在外面声明一个变量，循环的累加它，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"let total_expense = 0\n\n_data.forEach(item => {\n  if (item.pay_type == 1) {\n    total_expense += Number(item.amount)\n  }\n})\n"})}),"\n",(0,d.jsxs)(n.p,{children:["但是，在外面声明一个变量，这样看起来显得不是那么的美观。很多时候，你不想到处声明变量，此时 ",(0,d.jsx)(n.code,{children:"reduce"})," 便能很好地解决这个问题，因为它第二个参数，可以声明一个值，作为循环的初始值，并在每一次的「回调函数」当作第一个参数 ",(0,d.jsx)(n.code,{children:"arr"})," 被传入。"]}),"\n",(0,d.jsx)(n.p,{children:"于是我们继续追加总收入的逻辑，如下所示："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 总收入\nconst total_income = _data.reduce((arr, cur) => {\n  if (cur.pay_type == 2) {\n    arr += Number(cur.amount)\n  }\n  return arr\n}, 0)\n"})}),"\n",(0,d.jsx)(n.p,{children:"到这里，我们已经将汇总数据完成。接下来完成收支构成部分："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 获取收支构成\nlet total_data = _data.reduce((arr, cur) => {\n  const index = arr.findIndex(item => item.type_id == cur.type_id)\n  if (index == -1) {\n    arr.push({\n      type_id: cur.type_id,\n      type_name: cur.type_name,\n      pay_type: cur.pay_type,\n      number: Number(cur.amount)\n    })\n  }\n  if (index > -1) {\n    arr[index].number += Number(cur.amount)\n  }\n  return arr\n}, [])\n\ntotal_data = total_data.map(item => {\n  item.number = Number(Number(item.number).toFixed(2))\n  return item\n})\n\nctx.body = {\n  code: 200,\n  msg: '请求成功',\n  data: {\n    total_expense: Number(total_expense).toFixed(2),\n    total_income: Number(total_income).toFixed(2),\n    total_data: total_data || [],\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["我们分析上述 ",(0,d.jsx)(n.code,{children:"reduce"})," 的回调函数，",(0,d.jsx)(n.code,{children:"arr"})," 初始值为一个空数组，进入回调函数逻辑，首先我们通过 ",(0,d.jsx)(n.code,{children:"findIndex"})," 方法，查找 ",(0,d.jsx)(n.code,{children:"arr"})," 内，有无和当前项 ",(0,d.jsx)(n.code,{children:"cur"})," 相同类型的账单，比如学习、餐饮、交通等等。"]}),"\n",(0,d.jsxs)(n.p,{children:["如果 ",(0,d.jsx)(n.code,{children:"index"})," 没有找到，则会返回 -1，此时说明当前 ",(0,d.jsx)(n.code,{children:"cur"})," 的消费类型，在 ",(0,d.jsx)(n.code,{children:"arr"})," 中是没有的，所以我们通过 ",(0,d.jsx)(n.code,{children:"arr.push"})," 新增一个类型的数据，数据结构如上所示。"]}),"\n",(0,d.jsxs)(n.p,{children:["如果找到相同的消费类型，index 值则为大于 -1 的值，所以我们找到 ",(0,d.jsx)(n.code,{children:"arr[index]"}),"，让它的 ",(0,d.jsx)(n.code,{children:"number"})," 属性加上当前项的 ",(0,d.jsx)(n.code,{children:"amount"}),"，以此实现相同消费类型的累加。"]}),"\n",(0,d.jsxs)(n.p,{children:["最后，将所有的 ",(0,d.jsx)(n.code,{children:"number"})," 数据保留两位小数，并且将数据返回。"]}),"\n",(0,d.jsx)(n.p,{children:"不要忘记将接口抛出："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"router.get('/api/bill/data', _jwt, controller.bill.data); // 获取数据\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Postman"})," 调试结果如下所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:s,alt:""})}),"\n",(0,d.jsxs)(n.h2,{id:"总结",children:["总结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["本章节带同学们学习了一个完整的增删改查套件，这可以作为你的种子套件，后续如果有新的需求思路，要添加新的表和方法，可以按照这样一套作为基础进行临摹。比如我想做一个笔记本需求，那我就可以新建一张 ",(0,d.jsx)(n.code,{children:"note"})," 表，再实现一套类似朋友圈的需求，有文字有图片，可删除可添加。"]}),"\n",(0,d.jsx)(n.p,{children:"并且对通过数据图表的接口，对数据库表的数据进行二次处理进行了复习，巩固之前的知识点。"}),"\n",(0,d.jsxs)(n.h4,{id:"本章节源代码",children:["本章节源代码",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章节源代码",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.a,{href:"https://s.yezgea02.com/1626659372012/juejue-server.zip",target:"_blank",rel:"noopener noreferrer",children:"点击下载"})})]})}function q(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(E,{...e})}):E(e)}let k=q;q.__RSPRESS_PAGE_META={},q.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F8.%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E8%B4%A6%E5%8D%95%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"知识点",id:"知识点",depth:4},{text:"新增账单接口",id:"新增账单接口",depth:2},{text:"账单列表获取",id:"账单列表获取",depth:2},{text:"账单修改接口",id:"账单修改接口",depth:2},{text:"账单删除接口",id:"账单删除接口",depth:2},{text:"数据图表模块",id:"数据图表模块",depth:2},{text:"数据接口实现",id:"数据接口实现",depth:4},{text:"总结",id:"总结",depth:2},{text:"本章节源代码",id:"本章节源代码",depth:4}],title:"8.后端实战：账单及其相关接口实现",headingTitle:"8.后端实战：账单及其相关接口实现",frontmatter:{}}}}]);