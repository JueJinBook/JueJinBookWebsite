"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["41912"],{305562:function(e,n,s){s.r(n),s.d(n,{default:()=>o});var t=s(552676),l=s(740453);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",img:"img"},(0,l.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"28-工程化使用打包器打包模块",children:["28 工程化：使用打包器打包模块",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#28-工程化使用打包器打包模块",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"前面我们介绍了 Babel，它可以将采用新语言特性或新规范的 JS 文件编译成旧版本的文件，以便这些文件在旧版本浏览器中运行。但是，如果我们的项目很复杂，有多个模块，仅有 Babel 编译还不够，因为旧版本浏览器不支持模块化语法，我们不能很方便地引入多个模块。这时，我们需要使用打包器（bundler）将多个模块打包成一个文件，以便在旧版本浏览器中运行。"}),"\n",(0,t.jsx)(n.p,{children:"打包器不仅可以将模块化的项目编译成一个文件，还能够减少浏览器加载 JS 文件的数量，节省 http 请求数量，从而能够提高 Web 应用的性能。"}),"\n",(0,t.jsx)(n.p,{children:"在 JavaScript 社区，有很多打包器，比如 Webpack、Rollup、Parcel、ESbuild、Vite 等等。这些打包器都有自己的特点，比如 Webpack 支持模块化、打包、压缩、热更新等功能，而 Rollup 只支持模块化和打包，而且打包后的文件体积更小，至于 ESBuild、Vite 等新一代的打包器，则采用性能更高的编程语言（如Golang）编写，打包速度更快。"}),"\n",(0,t.jsx)(n.p,{children:"这一节课，我们就介绍 ESBuild，这款新一代的打包器。在大型项目的打包中，相比于 Webpack、Rollup 等打包器，ESBuild 的打包速度要快上将近 100 倍！"}),"\n",(0,t.jsxs)(n.h2,{id:"使用-esbuild-打包",children:["使用 ESBuild 打包",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-esbuild-打包",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在这里，我们以",(0,t.jsx)(n.a,{href:"https://code.juejin.cn/",target:"_blank",rel:"noopener noreferrer",children:"码上掘金"}),"的工具库为例，介绍如何使用 ESBuild 打包。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/xitu/jcode-tools",target:"_blank",rel:"noopener noreferrer",children:"jcode-tools"}),"是码上掘金的工具库，它包含一系列的工具类和工具函数，主要用来处理自定义语言、记录 log，运行服务端程序等等。"]}),"\n",(0,t.jsx)(n.p,{children:"这些工具模块我已经提前写好了，都是采用 ES Modules 编写的，内容如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"src\n|____codex-client.js    // 运行服务端语言\n|____logger.js          // 输出log到页面元素\n|____styles.css         // logger的CSS样式\n|____get-custom-code.js // 获取script[type=custom]标签下的自定义语言\n|____storage.js         // 简单的服务端KV存储\n"})}),"\n",(0,t.jsx)(n.p,{children:"这些文件分别都是 ES 模块，我们希望将它打包在一起，以便在浏览器中运行。我们先安装 ESBuild 依赖："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install esbuild --save-dev\n"})}),"\n",(0,t.jsx)(n.p,{children:"安装之后，在项目的根目录下创建一个 build.js 文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const esbuild = require('esbuild');\n\nconst options = {\n  entryPoints: ['src/index.js'],\n  outfile: 'dist/jcode-tools.js',\n  bundle: true,\n};\n\nesbuild.buildSync(options);\n"})}),"\n",(0,t.jsx)(n.p,{children:"上面是最简单的配置，我们首先指定一个入口文件，这里我们指定的是 src/index.js，然后指定输出文件，这里我们指定的是 dist/jcode-tools.js，最后指定 bundle为true，表示我们希望将所有的模块打包在一起。"}),"\n",(0,t.jsx)(n.p,{children:"接下来，我们在 package.json 中添加一个打包命令："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "build": "node build.js"\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"然后创建 src/index.js 文件，作为入口文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import { getCustomCode } from './get-custom-code.js';\nimport { CodeXClient } from './codex-client.js';\nimport { logger } from './logger.js';\nimport { Storage } from './storage.js';\n\nexport {\n  getCustomCode,\n  CodeXClient,\n  logger,\n  Storage,\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["接着我们运行 ",(0,t.jsx)(n.code,{children:"npm run build"}),"，就可以看到打包成功了，现在我们的 dist 目录下有一个 jcode-tools.js 文件，它就是我们打包好的文件。"]}),"\n",(0,t.jsxs)(n.h2,{id:"测试我们的文件",children:["测试我们的文件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试我们的文件",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们在浏览器中打开 dist/jcode-tools.js，可以看到它已经被打包成一个文件了，我们可以在浏览器中运行它。"}),"\n",(0,t.jsx)(n.p,{children:"首先在项目中创建 example 文件夹，然后在 example 文件夹中创建 test.html 文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  <script src="dist/jcode-tools.js"><\/script>\n</body>\n</html>\n'})}),"\n",(0,t.jsx)(n.p,{children:"然后我们修改 build.js，内容如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const esbuild = require('esbuild');\n\nconst options = {\n  entryPoints: ['src/index.js'],\n  outfile: 'dist/jcode-tools.js',\n  bundle: true,\n};\n\nif(process.env.mode === 'production') {\n  esbuild.buildSync(options);\n} else {\n  require('esbuild').serve({\n    servedir: './example',\n  }, {\n    ...options,\n    outfile: 'example/dist/jcode-tools.js',\n  }).then((server) => {\n    console.log(`Server is running at ${server.host}:${server.port}`);\n  });\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"ESBuild 提供了一个 serve 方法，可以启动一个服务，这里我们增加了一个 mode 参数，如果 mode 为 production，就执行打包操作，否则就启动一个服务，这样我们就可以在浏览器中访问 example/test.html 文件了。"}),"\n",(0,t.jsx)(n.p,{children:"对应，我们修改一下 package.json 中的 build 命令："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "dev": "node build.js",\n    "build": "node build.js --mode=production"\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["然后我们运行",(0,t.jsx)(n.code,{children:"npm run dev"}),"，打开浏览器，访问",(0,t.jsx)(n.code,{children:"http://localhost:8000/test.html"}),"，就可以看到我们打包好的文件已经被加载到浏览器中了。"]}),"\n",(0,t.jsx)(n.p,{children:"不过，我们现在虽然成功加载了模块，但是我们无法使用模块提供的 API，这是因为我们默认打包的文件是一个 IIFE 模块，我们需要指定要暴露的 API 对象名称。"}),"\n",(0,t.jsxs)(n.p,{children:["我们修改 build.js，将 options 选项添加",(0,t.jsx)(n.code,{children:"globalName:JCode"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const options = {\n  entryPoints: ['src/index.js'],\n  outfile: 'dist/jcode-tools.js',\n  bundle: true,\n  globalName: 'JCode',\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后我们修改 test.html 文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  <script src="dist/jcode-tools.js"><\/script>\n  <script>\n    const container = document.createElement(\'div\');\n    const log = JCode.logger(container);\n    document.body.appendChild(container);\n    log.info(\'hello world\');\n  <\/script>\n</body>\n</html>\n'})}),"\n",(0,t.jsx)(n.p,{children:"这样我们就可以通过 JCode 对象来访问模块提供的 API 了。"}),"\n",(0,t.jsxs)(n.h2,{id:"打包为-esmodule",children:["打包为 ESModule",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#打包为-esmodule",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"如果我们想要使用 ESModule 加载，我们需要将打包格式指定为 ESM 模块。"}),"\n",(0,t.jsxs)(n.p,{children:["我们修改 build.js，将 options 选项添加",(0,t.jsx)(n.code,{children:"format:esm"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const options = {\n  entryPoints: ['src/index.js'],\n  outfile: 'dist/jcode-tools.js',\n  format: 'esm',\n  bundle: true,\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后我们修改 test.html 文件，给 script 标签添加",(0,t.jsx)(n.code,{children:'type="module"'}),"属性："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  <script type="module">\n    import {logger} from \'./dist/jcode-tools.js\';\n    const container = document.createElement(\'div\');\n    const log = logger(container);\n    document.body.appendChild(container);\n    log.info(\'hello world\', red);\n  <\/script>\n</body>\n</html>\n'})}),"\n",(0,t.jsx)(n.p,{children:"如上面代码所示，这样我们就可以 ESModule 的方式来加载模块了。"}),"\n",(0,t.jsx)(n.p,{children:"一般来说，我们发布的时候会同时打包 iife 和 esm 两种格式，这样我们可以根据不同的使用场景来选择不同的加载方式，而测试的时候，我们直接使用 esm 模块更加方便，那我们的 build.js 文件可以这样写："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const esbuild = require('esbuild');\n\nconst options = {\n  entryPoints: ['src/index.js'],\n  outfile: 'dist/jcode-tools.js',\n  format: 'esm',\n  bundle: true,\n};\n\nif(process.env.mode === 'production') {\n  esbuild.buildSync({\n    ...options,\n    format: 'iife',\n    globalName: 'JCode',\n    minify: true,\n  });\n  esbuild.buildSync({\n    ...options,\n    outfile: 'dist/jcode-tools.esm.js',\n  });\n} else {\n  esbuild.serve({\n    servedir: './example',\n  }, {\n    ...options,\n    outfile: 'example/dist/jcode-tools.esm.js',\n  }).then((server) => {\n    console.log(`Server is running at ${server.host}:${server.port}`);\n  });\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"打包-css-文件",children:["打包 CSS 文件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#打包-css-文件",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"如果项目中有使用的 CSS 文件，我们可以直接通过 import 将文件引入。"}),"\n",(0,t.jsx)(n.p,{children:"我们修改 index.js 文件，添加一个 CSS 文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import './styles.css';\nimport { getCustomCode } from './get-custom-code.js';\nimport { CodeXClient } from './codex-client.js';\nimport { logger } from './logger.js';\nimport { Storage } from './storage.js';\n\nexport {\n  getCustomCode,\n  CodeXClient,\n  logger,\n  Storage,\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后修改 test.html 文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n  <link rel="stylesheet" href="./dist/jcode-tools.esm.css">\n</head>\n<body>\n  <script type="module">\n    import {logger} from \'./dist/jcode-tools.esm.js\';\n    const container = document.createElement(\'div\');\n    const log = logger(container);\n    document.body.appendChild(container);\n    log.warn(\'warning: something is wrong\');\n  <\/script>\n</body>\n</html>\n'})}),"\n",(0,t.jsx)(n.p,{children:"运行效果如图："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:"data:image/webp;base64,UklGRgYNAABXRUJQVlA4IPoMAAAwYgCdASq8BJIAPp1Ook2lpCMiIPpoaLATiWlu/HyZ5eiBSXlLsADkF+M3a//ZfDf8R+dfvP5S7oD/d+g/8q+t35v+n/ud/avYb+nfkR+W/s/wAvxj+bf5n8wuCD1P/N+gF3Y/3/hifynoJ9fvYA/lH8z/2XHXUAvzv6rv8T/x/ud9sv0F/3fcM/V3fnQahBv03h+g2s+R1bL9sHmFSucNEu/bB5hUrnDRLv2weYVK5w0S79sHmFSucNEu4MEmLBU8853y8WVa/9mwt//1XLLteFoFm+XMXwlKammgBX2IlKB0pajFz9AAC4LLccxDiIDxduNmgGva1arUjmd2tWcz0s9V9SqjYO15Z7tV2cYtJXmLDG4lxQ+PMOSO01BvkBTdNdXZiP3pwBHaO4gMCu5jsPvrl+cmy9ELRXb/jnJsvRC0V2/45ybL0QtFdv+Ocmy9ELRXb/S6ZgOIOs2Od8fH+yzhgqaiWMwA0eNLwRAZaXiCqCPuZqIbDRcvCFrD8o8/HoeC3ivvWAPeJLnY8CcZqpIvzxJMpU6FhC7uQjc75cHh7qmbZzPDOfXjEZUZXdYJvy8FGPcEEeXJ7eqCEs6ftdLtiDiuz6UCEXjieqz00vt+nJa6BNCvaQ5F6QlIPUuJPjwe0YJqG3/eF3kFVoe4Sb2w3HtZK/YlyvmNK2+DGWyRPFnl4vZBs8vF7INnl4vZBs8vGPJRk/SopXz/4hAXc5SCRdDOIQRJsSLqVBWb/jnJsvRC0V2/45ybL0QtFdv+Ocmy9ELRXb/jnJsvRCqusGaUZBjzLxeyDZ8BdYM0oyDHmXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8Xsg2eXi9kGzy8W4AD+6rAZWF9U+B/kAAABlEYw+U8z01tyyYKvUf6IaGd3pe94YCy36QcMHNoFr08jA8RTRxC9lb4sSdCuhgEbh7s0ILE2fG842f1Ufr3I83xxyrOBRWqir84/NRZgifs2iJED+AtJFiazlhsBU+FPbntg6d3S3TuNKSYW3fl1OL2/z6R9ricDcqVSSo2fcS5CiOvRkne4OlxGK+2/RMREmktN2HRV7oxHWJiYQ5S5pZagnp+CUrVtRVH+aX9eaMucfuARferyaSgCObRIX5Aqxuf8FB6BrH987YqnY8L8PwAEN1I2dpz81bi2HgNTpqYFBfFyOOZ8/Mrcn66Zj6HHrjeIXxNdem4y46e8PgNbvSiP7trFxqieRdXxWO//zY5dbBLK8HIfAi23NMLosFDfGDEq5bDeMKpRj5o2o7gUmrVNQujurNuDqf/xR91tw85/V1ibmi54sQd16ZdzB6yBhES8dzrniZq50tHmSf9KLVESmjvuegyHZwQi4DgWtE3a7rcb3/p+K5o04n2l3dw29HonzDX+XSoD3XM7v1lil7AX9DuDELiz1zxVJpg+9zu8LJKjVTfHr9+VrHqxsrLHs7LHDHU+xSBA2CfqVhjpym8wK2z72BINsbJmIyhuGrDXnG/txDL/SidB+kY7F2anFVvRwCHbCZ4HbxmCNWtrX/znf7TOm75/jHi+b9oqCJmBG7CzH11BtQzAZjkiGsBlUg8o4Z/6hLRd0ALTwa0uPhAjCy93l3CiEwbEI13FUIjLfn1wAjvOPoRbh5qo+f+G2Ykw1ZY3j/QCcyWnicQYaE7+++SOh/fQCGVgbmaog7RZzsbJJhNLz0FzTqeKjnrtRE5orWDpviYWe//PMgM23owfINdAvS861RduPcaAZ37f5gx2DdGHlgj3884geeN99IQM8nN9Zs+GVyxMFVZK19wqUyptKAWXq3hlgH8teYvxtmEf5WQ02bYbGru5wLYoAnagjYYD+yqrj8QqmngLdS8DrBvlfd8noDXuC57l/z705ED65OjgjyhT9mJVB/hBZbVD1IG+xFGWtEOzWFAur6GolO61F8LYsOilpX9Eds44haB81ufGO630xJqMjxSKnwGKUoip8BilKIqfAYpSiKnwmZRrShms/TB+vr992tXc3cAMECJ41sE5gSqa8DcvI4NaRdtZJkp024Sz5fOuw8Vy88wyhX6HLqZqGkOanNd55Z43QnVh8nj2fgq9RcH08wcf8cN2xtt0zwM67vOhGvYeIccbok5UJLYouPBRqG1zbMBG7ljvp6ELE6wKoCP5Ja4VfSNuPIaKQEbiSK/u1lqwt3Hz55pA6o+uW0vufZVOQ3MSYaP6/ysH96LG+OzFcor77guADCHrHI5ccWBJRzjdGZVdHVyYQnTIFOoZr1dZ39x1cQw28xcwh+yIbiF5XKURMNui91qLXaZ8VAf1P6ZnzIsaMB4i9kH5aw1On/sHEAW1Mn1S3SzLcED0HU0P/0JDPFQMxF3nK+DDc1LOffw8Ct8XEFiIgg4PScor5DPL4qUTb0Ws9yC+ZxptrmOck0Rdv+E1/Bj4HgehAI1z4LMG5Zzr+w2NuWGaOSqtWMuPiacDlF4NdyAXYPTymZlyZVnPjJ1B8GXloVn/9Fv6gUEefUpj7WIiEFflDzymkcO35aEB1n2h7BHb8rYj3Nj1NBdl5QCW38rZX8XncWjT2TBuf4TS/x1tLL3V5F/U6gnHuWpgSn/y8+0ac707WXDk8vnkMe9j5+QWauCaYqanV8+UsYivvOMeb0v4qn8YLgqL6GWrdQSAxvfy2210NBX0e1lCXOShxs8//1nPt5A9Dk6lBVNlqQ8VLClq40TT9IK1j0i6jqBMhYfGl308LyzC6cXYqQ4v2MP0g7ywK2FNgXUWL867i9QUNqm5SdyvDSM7BT4EF8RlTysqalCslVdVZgROPP2IhV5BtWD9UVaBI7z3slRxj29Sbjx6ihzEkWkpKMZ2gVOd4S48sOCOFs105RLCRnDXt+Qt1svXPbko+E/H3dLGhX4on9IVyZbBg01CixOF38fgs9WSzvF/y1XkC7bMwor7MP1NQ9ZjwxZKvrfYNJwMi4SurNuUYOk3XESwoa/onBsS6lV662SrpnJhQyIGFbm13xKAib5uF6/TKQ4HWfTr8U1279MfxW5VwHXB3ebW4ryQLU+Emn6DOr/QPgrxA8XUZP97ZD7rH7NGfiZLJBjq/PH3FUIE59VbqymltkaigOY18eeJiGmzcU5cjOusteiSjDbSwYhaIqhw2AxsKaJvKqGu5nI/7qbrFhvbQZk+APSELKiXnPtpPdRS4kxjYtXmyIGYp8thjzdaO/R17w58pmPG9C51ZRafR6TCRoVuip7sqEz1w90U1qOfheLd0cwezRk82HYqPxrhpWaZdJjmQvo+fgnZKEnIaYri1up+GzQx3hRLRGiNCpith1UabzoGOV6CERwcP4uVmcFd+fDqiRF/XLMH2akhQDvlEgFgWdshBiutFW5QFssw5TeQp07IJPbbFk6rNt4ofqzxHGHpGTkIxSG/ftZ5gIgGcTt0KifjWM0t+XGY/pLT/pAcaLHgX7ICz+7HRijlZiy3LYu7XnJXhNxHDO6o2I+HmsIRp1MbZRQECOSqjNJUA35KhdaVh9jqrP9YgUn+ab+ckow2gBX3K5mjKZ7+17t3uaM/P8E9EoUV44GB8ek1Yyf1uFUCyCB9zrFMYnlM5WUEYDDJZKoZlZXvRqoBiOEsZuGmHYA4CwmP+p/tmg5rvGB+rVcd4yuiejY5UaQy+gIXrfGJrxi03KbJD/BbX/pNDhoXnaCDzd1Uo4CVpcCxkZI01LVuKAaG5It9o/Etz76mm0kfjSOgXhFUmk6pwx550vlXHJcvGZzIlSRK/RSGL6kXawsDvc79eulQHSOL/9ij1+zRySUTwY7hTe7INHydj8FqJKeRDcE+dDiXtgBC302RqMb50Ie6KL9YFrnBVUh/cK9i0Gz12XN0ugkvf6QxMfxbIXK/PxbDeZCIdu4bP08GXWhqKUrw+BPFt3S/lv10ESxY62eMBhjeRUy+19H8YL3v/ElAI4lvOGrvkZwGbGQGzOW5LLwxX6Attec/WvpFl/4AC/Pvl56f6/YdD9USyuTbmWbQw2A9MCZbUuM2c4CmVkqT9o1L5EYdig1vtbw+n767PFhrs2awKPWksk+v/gUVc/Nl86D6YlmfoGtLM/QNaWZ+ga0sz9A1pZn6D3bfxrYgXzRrZiAT65pkEGFQADo8746uC5xTbVlZWVj2FNu9ltbW1sU2z2FP+tra2KbZ7Cn/W1tbFNs9hT/ra2tim2ewp/rfuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["我们会看到，ESBuild 会直接将 CSS 文件打包到 dist 目录下，并且生成一个对应的",(0,t.jsx)(n.code,{children:"./dist/jcode-tools.esm.css"}),"文件。"]}),"\n",(0,t.jsx)(n.p,{children:"不过这么做有一个缺点，就是我们仍然需要手工引入 CSS 文件。如果我们想要自动引入 CSS 文件，可以使用 ESCuild 提供的 loader 机制。我们修改 build.js："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"...\n  esbuild.serve({\n    servedir: './example',\n  }, {\n    ...options,\n    outfile: 'example/dist/jcode-tools.esm.js',\n    loader: {\n      '.css': 'text',\n    },\n  }).then((server) => {\n    console.log(`Server is running at ${server.host}:${server.port}`);\n  });\n...\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后将 index.js 的加载 css 方式修改为："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import style from './styles.css';\n\nconst headEl = document.head || document.getElementsByTagName('head')[0];\nconst styleEl = document.createElement('style');\nif(styleEl.styleSheet) {\n  styleEl.styleSheet.cssText = style;\n} else {\n  styleEl.appendChild(document.createTextNode(style));\n}\nheadEl.appendChild(styleEl);\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样我们就可以自动引入 CSS 文件了。"}),"\n",(0,t.jsx)(n.p,{children:"这是因为，我们告诉 ESBuild，加载 CSS 文件的时候使用 text loader，这样 ESBuild 就会将 CSS 文件的内容直接返回给我们，然后我们再自己创建 style 标签，把内容 append 到 html 的 head 中，这样就实现了简单的 JS 自动加载 CSS。"}),"\n",(0,t.jsx)(n.p,{children:"ESBuild 的 loader 还有很多功能，我们可以用 dataURL 加载图片、使用 base64 编码加载字体、使用 TypeScript 编译等等..."}),"\n",(0,t.jsxs)(n.h2,{id:"根据不同格式打包-css",children:["根据不同格式打包 CSS",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#根据不同格式打包-css",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"如果我们只想要将 CSS 打包进 ESM 的文件中，而在 IIFE 的文件中不打包 CSS，我们可以为两种模式指定不同的方式，这个可以通过 ESBuild 的 inject 选项来实现。"}),"\n",(0,t.jsx)(n.p,{children:"我们在 src 目录下新建两个文件："}),"\n",(0,t.jsx)(n.p,{children:"inject-iife.js"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import './styles.css';\n"})}),"\n",(0,t.jsx)(n.p,{children:"inject-esm.js"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import style from './styles.css';\n\nconst headEl = document.head || document.getElementsByTagName('head')[0];\nconst styleEl = document.createElement('style');\nif(styleEl.styleSheet) {\n  styleEl.styleSheet.cssText = style;\n} else {\n  styleEl.appendChild(document.createTextNode(style));\n}\nheadEl.appendChild(styleEl);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后将",(0,t.jsx)(n.code,{children:"import './styles.css';"}),"从 index.js 中删除。"]}),"\n",(0,t.jsx)(n.p,{children:"然后修改 build.js："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const esbuild = require('esbuild');\n\nconst options = {\n  entryPoints: ['src/index.js'],\n  outfile: 'dist/jcode-tools.js',\n  format: 'esm',\n  bundle: true,\n};\n\nif(process.env.mode === 'production') {\n  esbuild.buildSync({\n    ...options,\n    format: 'iife',\n    globalName: 'JCode',\n    minify: true,\n    inject: ['./src/inject-iife.js'],\n  });\n  esbuild.buildSync({\n    ...options,\n    outfile: 'dist/jcode-tools.esm.js',\n    inject: ['./src/inject-esm.js'],\n    loader: {\n      '.css': 'text',\n    },\n  });\n} else {\n  esbuild.serve({\n    servedir: './example',\n  }, {\n    ...options,\n    outfile: 'example/dist/jcode-tools.esm.js',\n    inject: ['./src/inject-esm.js'],\n    loader: {\n      '.css': 'text',\n    },\n  }).then((server) => {\n    console.log(`Server is running at ${server.host}:${server.port}`);\n  });\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样我们根据不同的 format 加载不同的 inject 文件和对应的 loader，这样就可以实现不同的打包模式了。"}),"\n",(0,t.jsx)(n.p,{children:"通过上面的例子，我们可以看到，ESBuild 的 loade 和 inject 机制非常强大，可以让我们在打包的时候，对不同的文件做不同的处理，这样就可以实现很多功能。"}),"\n",(0,t.jsxs)(n.h2,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这一节课，我们介绍了 ESBuild 的使用。可以看到，它非常灵活，不仅定制性很强，性能也很好。也许它的生态没有老牌打包器 Webpack 和 Rollup 那么完善，在更加复杂的工程中还需要配合其他工具使用，但是对于一些简单的工程来说，它已经足够了。"}),"\n",(0,t.jsx)(n.p,{children:"在后续的课程里，我们有机会继续深入使用它，来实现更加复杂的打包和生产环境构建。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(i,{...e})}):i(e)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F28%20%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%89%93%E5%8C%85%E5%99%A8%E6%89%93%E5%8C%85%E6%A8%A1%E5%9D%97.md"]={toc:[{text:"使用 ESBuild 打包",id:"使用-esbuild-打包",depth:2},{text:"测试我们的文件",id:"测试我们的文件",depth:2},{text:"打包为 ESModule",id:"打包为-esmodule",depth:2},{text:"打包 CSS 文件",id:"打包-css-文件",depth:2},{text:"根据不同格式打包 CSS",id:"根据不同格式打包-css",depth:2},{text:"小结",id:"小结",depth:2}],title:"28 工程化：使用打包器打包模块",headingTitle:"28 工程化：使用打包器打包模块",frontmatter:{}}}}]);