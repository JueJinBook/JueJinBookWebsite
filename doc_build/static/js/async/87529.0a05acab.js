"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["87529"],{52050:function(n,e,s){s.r(e),s.d(e,{default:()=>p});var r=s(552676),i=s(740453);let l=s.p+"static/image/735d36ff233d4e9f87405e9e280ebb40~tplv-k3u1fbpfcp-zoom-1.image.bca74cee.png",c=s.p+"static/image/4275ed8ed75e493090b739a16a7f095e~tplv-k3u1fbpfcp-zoom-1.image.63f91081.png",d=s.p+"static/image/b6625bce5f774b088ef71cc6e41f5ecd~tplv-k3u1fbpfcp-zoom-1.image.116f63c0.png",h=s.p+"static/image/102ac7e08c014456821b14e79a2a1a07~tplv-k3u1fbpfcp-zoom-1.image.fb874611.png";function x(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",br:"br",strong:"strong",h3:"h3",ol:"ol",img:"img",code:"code",pre:"pre"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"2-前端视角看编程范式代码组织の魔法",children:["2 前端视角看编程范式：代码组织の魔法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-前端视角看编程范式代码组织の魔法",children:"#"})]}),"\n",(0,r.jsxs)(e.h2,{id:"前端视角看编程范式",children:["前端视角看编程范式",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前端视角看编程范式",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在 JS 世界中，以下三种编程范式是大家一定要了解的："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"命令式编程"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"面向对象编程"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"函数式编程"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"对于许多前端同学来说，入门前端的第一步，接触到的基本都是命令式编程。"}),"\n",(0,r.jsx)(e.p,{children:"紧接着，随着 JS 知识的精进，你会渐渐地进入面向对象的世界，“模拟继承”、“原型与原型链”是许多同学学习 JS 遇到的第一个系统性难点知识。"}),"\n",(0,r.jsxs)(e.p,{children:["然后，你可能会接触到一些基于 Class 来构建自己组件系统的热门框架（比如旧版本的 React），这将强化你对面向对象风格的熟悉和认同。",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.strong,{children:"于是，左手命令式、右手面向对象，偶尔（或从不）引入函数式编程的某些特性，这成为了许多同学的前端入行起手式。"})]}),"\n",(0,r.jsx)(e.p,{children:"这也解释了为什么对于不少已经上手业务开发的前端同学来说，函数式编程仍然是个神秘而未知的东西。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"对于未知事物，如果我们单纯凭借干巴巴的概念定义去认识它，这需要极强的悟性和心性。"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"但如果能够借助对已知事物的理解，一步一步类比推理出对未知事物的认知，我们的学习曲线就将平滑得多，吸收知识的效率也将大大提升。"})}),"\n",(0,r.jsx)(e.p,{children:"在我们已知的编程范式中，面向对象固然经典，但在没有系统学习过函数式编程的情况下，我们很难对这两者进行深入、透彻的对比。因此我将把 OOP VS FP 的辨析放在小册的后半程。"}),"\n",(0,r.jsxs)(e.p,{children:["本节，在整本小册的开篇，我们首先从大家最为熟悉的命令式编程入手，将命令式的思维模式与函数式进行类比，帮助大家",(0,r.jsx)(e.strong,{children:"借助已知去认识未知"}),"、从感性上建立对函数式编程的宏观理解。"]}),"\n",(0,r.jsxs)(e.h2,{id:"命令式-vs-函数式过程思维-vs-结果思维",children:["命令式 vs 函数式：“过程思维” vs “结果思维”",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#命令式-vs-函数式过程思维-vs-结果思维",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"命令式编程关注的是一系列具体的执行步骤，当你想要使用一段命令式的代码来达到某个目的，你需要一步一步地告诉计算机应该“怎样做”。"}),"\n",(0,r.jsx)(e.p,{children:"与命令式编程严格对立的其实是“声明式编程”：不关心“怎样做”，只关心“得到什么”。"}),"\n",(0,r.jsx)(e.p,{children:"函数式编程是声明式编程的一种。"}),"\n",(0,r.jsx)(e.p,{children:"具体到范式表达上，函数式编程总是需要我们去思考这样两个问题："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"我想要什么样的输出？"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.strong,{children:"我应该提供什么样的输入？"})}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"对于这两套思维模式的差异，我们不妨借助生活中的吃饭场景来理解。"}),"\n",(0,r.jsxs)(e.h2,{id:"举个生活例子番茄炒蛋的故事",children:["举个生活例子\uD83C\uDF30：番茄\uD83C\uDF45炒蛋\uD83E\uDD5A的故事",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#举个生活例子番茄炒蛋的故事",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"有一天韩梅梅突然很想吃番茄炒蛋，为了吃到这口番茄炒蛋，她想到了命令式做菜和函数式做菜两种思路："}),"\n",(0,r.jsxs)(e.h3,{id:"命令式做菜让我来告诉你如何炒出番茄炒蛋",children:["命令式做菜：让我来告诉你如何炒出番茄炒蛋",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#命令式做菜让我来告诉你如何炒出番茄炒蛋",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"如果韩梅梅选择了命令式做菜，那么她这时会喊来打游戏打到一半的李雷，把他推进厨房，并按顺序发出如下命令："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"你要把鸡蛋敲开打散，番茄切块备用"}),"\n",(0,r.jsx)(e.li,{children:"锅里倒油，油热后倒入蛋液"}),"\n",(0,r.jsx)(e.li,{children:"鸡蛋凝固后，放入西红柿开炒"}),"\n",(0,r.jsx)(e.li,{children:"加调味，再炒"}),"\n",(0,r.jsx)(e.li,{children:"大火收汁"}),"\n",(0,r.jsx)(e.li,{children:"关火"}),"\n",(0,r.jsx)(e.li,{children:"装盘"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"......"}),"\n",(0,r.jsx)(e.p,{children:"命令式做菜要求韩梅梅必须对做菜的过程了如指掌，每一个步骤她都需要事无巨细地关注到。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"这些具体步骤组成的命令序列，就是一段命令式程序。"})}),"\n",(0,r.jsxs)(e.h3,{id:"函数式做菜不关心菜谱只关心输入与输出",children:["函数式做菜：不关心菜谱，只关心输入与输出",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#函数式做菜不关心菜谱只关心输入与输出",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"如果韩梅梅选择了函数式做菜，那么她的体验就会轻松得多。"}),"\n",(0,r.jsx)(e.p,{children:"同样是喊来打游戏打到一半的李雷，她可以考虑："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"从冰箱摸3个番茄和2个鸡蛋，交给李雷，让李雷去厨房想办法弄出这道菜"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"给李雷20块钱，让他去楼下买一份番茄炒蛋上来"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"当然，她也可以打开自己手机里的丑团外卖下一个订单，这样李雷的游戏血条就保住了"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"此时，对于韩梅梅来说，生产番茄炒蛋的过程就像一个黑盒："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"无论是李雷冒着炸厨房的风险试验出这道菜，还是李雷拿着20块钱到楼下买这道菜，亦或是厨师做好菜交给丑团小哥、丑团小哥送上门的这些具体细节，对于韩梅梅来说都是不需要感知的。"}),"\n",(0,r.jsx)(e.p,{children:"在函数式做菜的过程中，韩梅梅只需要关注两件事情："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"我想要什么样的输出？"})," （一盘番茄炒蛋）"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"我应该提供什么样的输入？"})," （食材或者钱\uD83D\uDCB0）"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"举个-coding-例子员工信息筛选工作流",children:["举个 Coding 例子\uD83C\uDF30：员工信息筛选工作流",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#举个-coding-例子员工信息筛选工作流",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"接下来我们用一个编码案例，来对两者的差异做更进一步的阐述。"}),"\n",(0,r.jsx)(e.p,{children:"考虑这样一个场景："}),"\n",(0,r.jsx)(e.p,{children:"我们有一个员工信息数据库。现在为了对年龄大于等于 24 岁的员工做生涯指导，需要拉出一张满足条件的员工信息清单，要求清单中每一条信息中间用逗号分隔，并按照年龄升序展示。"}),"\n",(0,r.jsx)(e.p,{children:"把这个需求简单梳理一下，分三步走："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"对列表进行排序"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["筛选出 ",(0,r.jsx)(e.code,{children:">= 24"})," 岁这个区间内的员工列表"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["针对该列表中的每一条员工数据历史，保存到 ",(0,r.jsx)(e.code,{children:"logText"})," 中"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"当然，你也可以交换步骤1和步骤2的顺序，这样可以缩小排序范围，提高排序效率。"}),"\n",(0,r.jsx)(e.p,{children:"但就编码内容来说，不管是以什么样的顺序来执行这三个步骤，该写的代码是一点也少不了。"}),"\n",(0,r.jsxs)(e.p,{children:["接下来我就按照 ",(0,r.jsx)(e.code,{children:"1->2->3"})," 这个顺序来给大家写写看。"]}),"\n",(0,r.jsx)(e.p,{children:"按照命令式编程的脑回路来实现，我们不难想到用循环来做。命令式编程的代码如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// 这里我mock了一组员工信息作为原始数据，实际处理的数据信息量应该比这个大很多\nconst peopleList = [\n  {\n    name: 'John Lee',\n    age: 24,\n    career: 'engineer'\n  },\n  {\n    name: 'Bob Chen',\n    age: 22,\n    career: 'engineer'\n  },\n  {\n    name: 'Lucy Liu',\n    age: 28,\n    career: 'PM'\n  },\n  {\n    name: 'Jack Zhang',\n    age: 26,\n    career: 'PM'\n  },\n  {\n    name: 'Yan Xiu',\n    age: 30,\n    career: 'engineer'\n  }\n]\n\nconst len = peopleList.length\n\n// 对员工列表按照年龄【排序】\nfor(let i=0;i<len;i++) {\n  // 内层循环用于完成每一轮遍历过程中的重复比较+交换\n  for(let j=0;j<len-1;j++) {\n    // 若相邻元素前面的数比后面的大\n    if(peopleList[j].age > peopleList[j+1].age) {\n      // 交换两者\n      [peopleList[j], peopleList[j+1]] = [peopleList[j+1], peopleList[j]]\n    }\n  }\n}\n\nlet logText = ''\nfor(let i=0; i<len; i++) {\n  const person = peopleList[i]\n  // 【筛选】出年龄符合条件的\n  if( person.age >= 24 ) {\n    // 从数组中【提取】目标信息到 logText\n    const perLogText = `${person.name}'s age is ${person.age}`\n    if(i!==len-1) {\n      logText += `${perLogText},`\n    } else {\n      logText += perLogText\n    }\n  }\n}\n\nconsole.log(logText)\n"})}),"\n",(0,r.jsx)(e.p,{children:"在这段代码中，我们逐个实现了排序、筛选、信息提取这三大块逻辑。"}),"\n",(0,r.jsx)(e.p,{children:"下面再来看看函数式的解法："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// 定义筛选逻辑\nconst ageBiggerThan24 = (person)=> person.age >= 24\n\n// 定义排序逻辑\nconst smallAgeFirst = (a, b) => {\n  return a.age - b.age\n}\n\n// 定义信息提取逻辑\nconst generateLogText = (person)=>{\n  const perLogText = `${person.name}'s age is ${person.age}`\n  return perLogText\n}\n\nconst logText = peopleList.filter(ageBiggerThan24)\n                      .sort(smallAgeFirst)\n                      .map(generateLogText)\n                      .join(',')\n\nconsole.log(logText)\n"})}),"\n",(0,r.jsx)(e.p,{children:"这段代码在执行结果上和命令式代码是一样的，但内容却非常简洁，也具有更强的可读性。"}),"\n",(0,r.jsx)(e.p,{children:"作为用户，我不需要了解每个函数内部都执行了哪些语句，仅仅通过函数名就可以推断出来这个调用链做了哪些事情。"}),"\n",(0,r.jsxs)(e.p,{children:["此外，声明式代码定义的 ",(0,r.jsx)(e.code,{children:"ageBiggerThan24"}),"、 ",(0,r.jsx)(e.code,{children:"sortByAge"}),"、",(0,r.jsx)(e.code,{children:"getLogText"}),"等方法，是可以被复用的。"]}),"\n",(0,r.jsx)(e.p,{children:"而命令式代码中的比大小、排序、字符串处理等逻辑，更像是“一锤子买卖”，执行完也就过去了，日后想要实现相同的逻辑，只能靠复制粘贴。"}),"\n",(0,r.jsxs)(e.h2,{id:"思考函数式编程是怎样解决问题的",children:["思考：函数式编程是怎样解决问题的",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思考函数式编程是怎样解决问题的",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"有同学这时候可能会纳闷儿了：这段代码不就是几个简单的数组方法调用么？这也叫函数式编程？就这？"}),"\n",(0,r.jsx)(e.p,{children:"首先，尽管对于一些“原教旨主义者”来说，数组方法的函数式确实不够彻底——因为这些函数仍然是作为数组对象的实例方法存在的，尚存一些 OOP 的”余孽“。"}),"\n",(0,r.jsxs)(e.p,{children:["但 JS 本身就是多范式的语言，对 JS 来说，",(0,r.jsx)(e.strong,{children:"数组方法确实是非常重要的函数式编程工具"}),"。这一点我们在后续的章节里还会反复验证。"]}),"\n",(0,r.jsx)(e.p,{children:"接下来我们看回楼上的示例代码，它的背后表达了一种与命令式编程截然相反的脑回路："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"以“输入”和“输出”为轴心，来组织程序。"})}),"\n",(0,r.jsx)(e.p,{children:"具体到代码里来说，我们首先可以根据需求明确输入输出："}),"\n",(0,r.jsxs)(e.p,{children:["输入是一个 ",(0,r.jsx)(e.code,{children:"peopleList"}),"（员工列表），而输出是一个 ",(0,r.jsx)(e.code,{children:"logText"}),"（逗号分隔的字符串）。"]}),"\n",(0,r.jsx)(e.p,{children:"以输入为起点，输出为终点，我们就可以拉起来这样一条数据转换的“流水线”："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"此时中间的 Operation 对我们来说还是一个黑盒，但我们可以通过进一步分析数据的变换来明确出黑盒中的函数组合："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:["对于流水线中的每一个步骤、每一个函数调用，我们",(0,r.jsx)(e.strong,{children:"仍然不必去关注其内部的执行细节，只需要关注函数的输入与输出"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"每一个函数都是一个逻辑块，每一个逻辑块都代表着一次变换。"}),"\n",(0,r.jsxs)(e.p,{children:["在函数式编程的代码组织模式下，我们关注的不再是具体逻辑的实现，而是",(0,r.jsx)(e.strong,{children:"对“变换”的组合"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"这个过程其实和工厂生产果汁的过程很相似。"}),"\n",(0,r.jsx)(e.p,{children:"我们放几个橙子\uD83C\uDF4A到流水线的入口，它会经历去皮、压榨、滤渣等几个环节。"}),"\n",(0,r.jsx)(e.p,{children:"函数式编程中的“函数”就像流水线上的一个个工序，这些工序吃进去原材料，吐出目标产物。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"作为一个流水线工人，我不需要知道每一个工序的执行细节，我只要能把不同工序的机器组装到一起就可以了。"}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"命令式编程对许多同学来说，是真正意义上的“入行起手式”。"}),"\n",(0,r.jsxs)(e.p,{children:["本节我们以命令式编程为引子，意在帮助大家认识函数式编程“",(0,r.jsx)(e.strong,{children:"结果导向"}),"”的思维方式、以及【",(0,r.jsx)(e.strong,{children:"抽象+组合】"})," 的行为方法论。"]}),"\n",(0,r.jsx)(e.p,{children:"在小册的调研阶段，我注意到不少同学对于范式的认识和思考比较欠缺——不仅仅对于函数式编程缺乏了解，甚至对于自己每天都在使用的命令式、面向对象等范式也无法给出系统的理解，最终导致在实践和面试中都吃了很多亏。"}),"\n",(0,r.jsx)(e.p,{children:"因此，对于范式相关的基础知识，我会讲得比较详细。也希望大家在理解这些内容之后，能够去主动思考一些平时没空去思考、但是对自己真正有益的问题。"}),"\n",(0,r.jsx)(e.p,{children:"通过本节的学习，相信你不仅能够建立对函数式编程的初步认识，更能够深化自己对命令式编程的理解。"}),"\n",(0,r.jsxs)(e.p,{children:["最重要的是，",(0,r.jsx)(e.strong,{children:"你将开始主动去思考一些略高于编码本身的问题"}),"。而这样的思考，将会贯穿我们整本小册。"]}),"\n",(0,r.jsx)(e.p,{children:"下一节，我们将进入正题，从函数式编程的基本功开始，一窥它的全貌。"}),"\n",(0,r.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function j(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(x,{...n})}):x(n)}let p=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F2%20%E5%89%8D%E7%AB%AF%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E3%81%AE%E9%AD%94%E6%B3%95.md"]={toc:[{text:"前端视角看编程范式",id:"前端视角看编程范式",depth:2},{text:"命令式 vs 函数式：“过程思维” vs “结果思维”",id:"命令式-vs-函数式过程思维-vs-结果思维",depth:2},{text:"举个生活例子\uD83C\uDF30：番茄\uD83C\uDF45炒蛋\uD83E\uDD5A的故事",id:"举个生活例子番茄炒蛋的故事",depth:2},{text:"命令式做菜：让我来告诉你如何炒出番茄炒蛋",id:"命令式做菜让我来告诉你如何炒出番茄炒蛋",depth:3},{text:"函数式做菜：不关心菜谱，只关心输入与输出",id:"函数式做菜不关心菜谱只关心输入与输出",depth:3},{text:"举个 Coding 例子\uD83C\uDF30：员工信息筛选工作流",id:"举个-coding-例子员工信息筛选工作流",depth:2},{text:"思考：函数式编程是怎样解决问题的",id:"思考函数式编程是怎样解决问题的",depth:2},{text:"小结",id:"小结",depth:2}],title:"2 前端视角看编程范式：代码组织の魔法",headingTitle:"2 前端视角看编程范式：代码组织の魔法",frontmatter:{}}}}]);