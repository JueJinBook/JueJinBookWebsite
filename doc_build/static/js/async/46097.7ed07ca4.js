"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["46097"],{826639:function(e,r,n){n.r(r),n.d(r,{default:()=>i});var s=n(552676),d=n(740453);function c(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",ul:"ul",li:"li",blockquote:"blockquote",p:"p",strong:"strong",code:"code",pre:"pre",img:"img",ol:"ol"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"10基础-7读取和返回-http-请求",children:["10基础 7：读取和返回 HTTP 请求",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#10基础-7读取和返回-http-请求",children:"#"})]}),"\n",(0,s.jsxs)(r.h2,{id:"本节核心内容",children:["本节核心内容",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#本节核心内容",children:"#"})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"如何读取 HTTP 请求数据"}),"\n",(0,s.jsx)(r.li,{children:"如何返回数据"}),"\n",(0,s.jsx)(r.li,{children:"如何定制业务的返回格式"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["本小节源码下载路径：",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo06",target:"_blank",rel:"noopener noreferrer",children:"demo06"})]}),"\n",(0,s.jsx)(r.p,{children:"可先下载源码到本地，结合源码理解后续内容，边学边练。"}),"\n",(0,s.jsxs)(r.p,{children:["本小节的代码是基于 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo05",target:"_blank",rel:"noopener noreferrer",children:"demo05"})," 来开发的。"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"读取和返回参数",children:["读取和返回参数",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#读取和返回参数",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"在业务开发过程中，需要读取请求参数（消息体和 HTTP Header），经过业务处理后返回指定格式的消息。apiserver 也展示了如何进行参数的读取和返回，下面展示了如何读取和返回参数："}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"读取 HTTP 信息："})," 在 API 开发中需要读取的参数通常为：HTTP Header、路径参数、URL参数、消息体，读取这些参数可以直接使用 ",(0,s.jsx)(r.code,{children:"gin"})," 框架自带的函数："]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Param()"}),"：返回 URL 的参数值，例如"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:' router.GET("/user/:id", func(c *gin.Context) {\r\n     // a GET request to /user/john\r\n     id := c.Param("id") // id == "john"\r\n })\n'})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"Query()"}),"：读取 URL 中的地址参数，例如"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'   // GET /path?id=1234&name=Manu&value=\r\n   c.Query("id") == "1234"\r\n   c.Query("name") == "Manu"\r\n   c.Query("value") == ""\r\n   c.Query("wtf") == ""  \n'})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"DefaultQuery()"}),"：类似 ",(0,s.jsx)(r.code,{children:"Query()"}),"，但是如果 key 不存在，会返回默认值，例如"]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:' //GET /?name=Manu&lastname=\r\n c.DefaultQuery("name", "unknown") == "Manu"\r\n c.DefaultQuery("id", "none") == "none"\r\n c.DefaultQuery("lastname", "none") == ""\n'})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Bind()"}),"：检查 ",(0,s.jsx)(r.code,{children:"Content-Type"})," 类型，将消息体作为指定的格式解析到 Go struct 变量中。apiserver 采用的媒体类型是 JSON，所以 ",(0,s.jsx)(r.code,{children:"Bind()"})," 是按 JSON 格式解析的。"]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"GetHeader()"}),"：获取 HTTP 头。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"返回HTTP消息："})," 因为要返回指定的格式，apiserver 封装了自己的返回函数，通过统一的返回函数 ",(0,s.jsx)(r.code,{children:"SendResponse"})," 来格式化返回，小节后续部分有详细介绍。"]}),"\n",(0,s.jsxs)(r.h2,{id:"增加返回函数",children:["增加返回函数",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#增加返回函数",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["API 返回入口函数，供所有的服务模块返回时调用，所以这里将入口函数添加在 ",(0,s.jsx)(r.code,{children:"handler"})," 目录下，",(0,s.jsx)(r.code,{children:"handler/handler.go"})," 的源码为："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'package handler\r\n\r\nimport (\r\n	"net/http"\r\n\r\n	"apiserver/pkg/errno"\r\n\r\n	"github.com/gin-gonic/gin"\r\n)\r\n\r\ntype Response struct {\r\n	Code    int         `json:"code"`\r\n	Message string      `json:"message"`\r\n	Data    interface{} `json:"data"`\r\n}\r\n\r\nfunc SendResponse(c *gin.Context, err error, data interface{}) {\r\n	code, message := errno.DecodeErr(err)\r\n\r\n	// always return http.StatusOK\r\n	c.JSON(http.StatusOK, Response{\r\n		Code:    code,\r\n		Message: message,\r\n		Data:    data,\r\n	})\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"可以看到返回格式固定为："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'type Response struct {\r\n	Code    int         `json:"code"`\r\n	Message string      `json:"message"`\r\n	Data    interface{} `json:"data"`\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["在返回结构体中，固定有 ",(0,s.jsx)(r.code,{children:"Code"})," 和 ",(0,s.jsx)(r.code,{children:"Message"})," 参数，这两个参数通过函数 ",(0,s.jsx)(r.code,{children:"DecodeErr()"})," 解析 error 类型的变量而来（",(0,s.jsx)(r.code,{children:"DecodeErr()"})," 在上一节介绍过）。",(0,s.jsx)(r.code,{children:"Data"})," 域为 ",(0,s.jsx)(r.code,{children:"interface{}"})," 类型，可以根据业务自己的需求来返回，可以是 map、int、string、struct、array 等 Go 语言变量类型。",(0,s.jsx)(r.code,{children:"SendResponse()"})," 函数通过 ",(0,s.jsx)(r.code,{children:"errno.DecodeErr(err)"})," 来解析出 code 和 message，并填充在 ",(0,s.jsx)(r.code,{children:"Response"})," 结构体中。"]}),"\n",(0,s.jsxs)(r.h2,{id:"在业务处理函数中读取和返回数据",children:["在业务处理函数中读取和返回数据",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#在业务处理函数中读取和返回数据",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["通过改写上一节 ",(0,s.jsx)(r.code,{children:"handler/user/create.go"})," 源文件中的 ",(0,s.jsx)(r.code,{children:"Create()"})," 函数，来演示如何读取和返回数据，改写后的源码为："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'package user\r\n\r\nimport (\r\n	"fmt"\r\n\r\n	. "apiserver/handler"\r\n	"apiserver/pkg/errno"\r\n\r\n	"github.com/gin-gonic/gin"\r\n	"github.com/lexkong/log"\r\n)\r\n\r\n// Create creates a new user account.\r\nfunc Create(c *gin.Context) {\r\n	var r CreateRequest\r\n	if err := c.Bind(&r); err != nil {\r\n		SendResponse(c, errno.ErrBind, nil)\r\n		return\r\n	}\r\n\r\n	admin2 := c.Param("username")\r\n	log.Infof("URL username: %s", admin2)\r\n\r\n	desc := c.Query("desc")\r\n	log.Infof("URL key param desc: %s", desc)\r\n\r\n	contentType := c.GetHeader("Content-Type")\r\n	log.Infof("Header Content-Type: %s", contentType)\r\n\r\n	log.Debugf("username is: [%s], password is [%s]", r.Username, r.Password)\r\n	if r.Username == "" {\r\n		SendResponse(c, errno.New(errno.ErrUserNotFound, fmt.Errorf("username can not found in db: xx.xx.xx.xx")), nil)\r\n		return\r\n	}\r\n\r\n	if r.Password == "" {\r\n		SendResponse(c, fmt.Errorf("password is empty"), nil)\r\n	}\r\n\r\n	rsp := CreateResponse{\r\n		Username: r.Username,\r\n	}\r\n\r\n	// Show the user information.\r\n	SendResponse(c, nil, rsp)\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["这里也需要更新下路由，",(0,s.jsx)(r.code,{children:"router/router.go"}),"（详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo06/router/router.go",target:"_blank",rel:"noopener noreferrer",children:"demo06/router/router.go"}),"）："]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{src:"https://user-gold-cdn.xitu.io/2018/6/1/163ba4612fd06a34?w=1426&h=123&f=png&s=8879",alt:""})}),"\n",(0,s.jsxs)(r.p,{children:["上例展示了如何通过 ",(0,s.jsx)(r.code,{children:"Bind()"}),"、",(0,s.jsx)(r.code,{children:"Param()"}),"、",(0,s.jsx)(r.code,{children:"Query()"})," 和 ",(0,s.jsx)(r.code,{children:"GetHeader()"})," 来获取相应的参数。"]}),"\n",(0,s.jsxs)(r.p,{children:["根据笔者的研发经验，建议：如果消息体有 JSON 参数需要传递，针对每一个 API 接口定义独立的 go struct 来接收，比如 ",(0,s.jsx)(r.code,{children:"CreateRequest"})," 和 ",(0,s.jsx)(r.code,{children:"CreateResponse"}),"，并将这些结构体统一放在一个 Go 文件中，以方便后期维护和修改。这样做可以使代码结构更加规整和清晰，本例统一放在 ",(0,s.jsx)(r.code,{children:"handler/user/user.go"})," 中，源码为："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'package user\r\n\r\ntype CreateRequest struct {\r\n	Username string `json:"username"`\r\n	Password string `json:"password"`\r\n}\r\n\r\ntype CreateResponse struct {\r\n	Username string `json:"username"`\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"编译并运行",children:["编译并运行",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#编译并运行",children:"#"})]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"下载 apiserver_demos 源码包（如前面已经下载过，请忽略此步骤）"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"$ git clone https://github.com/lexkong/apiserver_demos\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"2",children:["\n",(0,s.jsxs)(r.li,{children:["将 ",(0,s.jsx)(r.code,{children:"apiserver_demos/demo06"})," 复制为 ",(0,s.jsx)(r.code,{children:"$GOPATH/src/apiserver"})]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"$ cp -a apiserver_demos/demo06/ $GOPATH/src/apiserver\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"3",children:["\n",(0,s.jsx)(r.li,{children:"在 apiserver 目录下编译源码"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"$ cd $GOPATH/src/apiserver\r\n$ gofmt -w .\r\n$ go tool vet .\r\n$ go build -v .\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"测试",children:["测试",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#测试",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["启动apiserver：",(0,s.jsx)(r.code,{children:"./apiserver"}),"，发送 HTTP 请求："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'$ curl -XPOST -H "Content-Type: application/json" http://127.0.0.1:8080/v1/user/admin2?desc=test -d\'{"username":"admin","password":"admin"}\'\r\n\r\n{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": {\r\n    "username": "admin"\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"查看 apiserver 日志："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.img,{src:"https://user-gold-cdn.xitu.io/2018/6/1/163ba431f72ac9fd?w=1900&h=625&f=png&s=105750",alt:""})}),"\n",(0,s.jsxs)(r.p,{children:["可以看到成功读取了请求中的各类参数。并且 ",(0,s.jsx)(r.code,{children:"curl"})," 命令返回的结果格式为指定的格式："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-json",children:'{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": {\r\n    "username": "admin"\r\n  }\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"小结",children:["小结",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["本小节介绍了如何进行 HTTP 请求的读取和返回，读取主要用 ",(0,s.jsx)(r.code,{children:"gin"})," 框架自带的函数，返回要统一用函数 ",(0,s.jsx)(r.code,{children:"SendResponse"}),"。"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,d.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let i=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Go%20%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84%20RESTful%20API%20%E6%9C%8D%E5%8A%A1%2F10%E5%9F%BA%E7%A1%80%207%EF%BC%9A%E8%AF%BB%E5%8F%96%E5%92%8C%E8%BF%94%E5%9B%9E%20HTTP%20%E8%AF%B7%E6%B1%82.md"]={toc:[{text:"本节核心内容",id:"本节核心内容",depth:2},{text:"读取和返回参数",id:"读取和返回参数",depth:2},{text:"增加返回函数",id:"增加返回函数",depth:2},{text:"在业务处理函数中读取和返回数据",id:"在业务处理函数中读取和返回数据",depth:2},{text:"编译并运行",id:"编译并运行",depth:2},{text:"测试",id:"测试",depth:2},{text:"小结",id:"小结",depth:2}],title:"10基础 7：读取和返回 HTTP 请求",headingTitle:"10基础 7：读取和返回 HTTP 请求",frontmatter:{}}}}]);