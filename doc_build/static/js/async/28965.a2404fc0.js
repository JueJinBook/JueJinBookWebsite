"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["28965"],{93423:function(n,e,r){r.r(e),r.d(e,{default:()=>S});var t=r(552676),i=r(740453);let d=r.p+"static/image/91226f33c6e4383a85f3c532878058d0.9f0fe14e.png",a=r.p+"static/image/eb9d6a2cc68818767e1dc73c96988479.ef7485f5.png",c=r.p+"static/image/cc8ec26eaa2f1665d17de80876eb41ad.0c60ee35.png",o=r.p+"static/image/67140dcc3ad6b2d220285fc0d74159ed.67b7dc8e.png",s=r.p+"static/image/f5655d46a84445f1925a6a9da98fe7f5.0b927eff.png",l=r.p+"static/image/2ef4ebb5b06bddee98b2ee0fe8c0c3cd.b03f2082.png",p=r.p+"static/image/0a30a82a014283b75a36993cded22829.52dfe2ee.png",x=r.p+"static/image/722171c8b1291144d431a78cc07590da.c178c238.png",h=r.p+"static/image/05b341bb169a9013d701c6facb86fa50.b4382786.png",f=r.p+"static/image/a6c89ae3a1c4641fd65002f56cdc4577.2a836803.png",u=r.p+"static/image/13f1a409fec9c53bb8f53d21fe59f323.c28b3013.png",b=r.p+"static/image/966e7439b157548cdf3a584986d2eb6b.a9feb2f0.png",j=r.p+"static/image/de2d4b676a5bd5a5966560979de2c5ee.95893b14.png";function g(n){let e=Object.assign({p:"p",strong:"strong",ul:"ul",li:"li",h2:"h2",a:"a",h3:"h3",img:"img",blockquote:"blockquote",h4:"h4",pre:"pre",code:"code"},(0,i.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:["在",(0,t.jsx)(e.strong,{children:"原理进阶：浏览器的线程和任务"}),"中，讲解了 Web 应用中的 JavaScript 是通过 Renderer 进程主线程中的任务进行处理，这些任务包括："]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"V8.DeserializeContext"}),"\n",(0,t.jsx)(e.li,{children:"V8.CompileCode"}),"\n",(0,t.jsx)(e.li,{children:"V8.Compile"}),"\n",(0,t.jsx)(e.li,{children:"V8.CompileIgnition"}),"\n",(0,t.jsx)(e.li,{children:"V8.CompileIgnitionFinalization"}),"\n",(0,t.jsx)(e.li,{children:"..."}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"本课程主要讲解 V8 如何解释执行 JavaScript，并通过 D8 调试工具来实践编译过程。"}),"\n",(0,t.jsxs)(e.h2,{id:"编译器和解释器",children:["编译器和解释器",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编译器和解释器",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"大家可能一直疑惑的问题：JavaScript 是一门解释型语言吗？要了解这个问题，首先需要了解什么是解释器和编译器，以及它们的特点是什么。"}),"\n",(0,t.jsxs)(e.h3,{id:"解释器",children:["解释器",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解释器",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"解释器的作用是将某种语言编写的源程序作为输入，将该源程序执行的结果作为输出，例如 Perl、Scheme、APL 等都是使用解释器进行逐行解释执行。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsxs)(e.h3,{id:"编译器",children:["编译器",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编译器",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"编译器的设计是一个非常庞大和复杂的软件系统设计，在真正设计的时候需要解决两个相对重要的问题："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"如何分析不同高级程序语言设计的源程序"}),"\n",(0,t.jsx)(e.li,{children:"如何将源程序的功能等价映射到不同指令系统的目标机器（例如 Mac、Windows & Linux）"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsx)(e.p,{children:"温馨提示：这里的前端是编译器的前端部分，不是 Web 前端的意思。"}),"\n"]}),"\n",(0,t.jsxs)(e.h4,{id:"中间表示",children:["中间表示",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#中间表示",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"中间表示（Intermediate Representation，IR）是程序结构的一种表现方式，它会比抽象语法树（Abstract Syntax Tree，AST）更加接近汇编语言或者指令集，同时也会保留源程序中的一些高级信息，具体作用包括："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"易于编译器的错误调试，容易识别是前端还是后端的问题"}),"\n",(0,t.jsx)(e.li,{children:"更加接近指令集，相对于源码可以更加节省内存空间"}),"\n",(0,t.jsx)(e.li,{children:"可以进行编译的迭代优化，用于输出更高质量的目标程序"}),"\n",(0,t.jsx)(e.li,{children:"可以使得编译器的职责更加分离，前端编译器更多关注如何转换成 IR，而不是去适配不同的系统指令集"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsxs)(e.h4,{id:"优化编译器",children:["优化编译器",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#优化编译器",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"IR 本身可以做程序编译的迭代优化，在每一趟迭代的过程中记录编译优化的细节，方便为后续的迭代查找并利用这些优化信息，最终输出更优的目标程序："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"优化器可以对 IR 进行一趟或者多趟迭代处理，从而生成更快执行速度或更小体积的目标程序（例如找到循环中不变的计算并对其进行优化从而减少运算次数），也可能用于产生更少异常或者更低功耗的目标程序。除此之外，前端和后端编译器内部还可以细分为多个处理步骤，如下所示："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsxs)(e.h3,{id:"解释器和编译器比较",children:["解释器和编译器比较",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解释器和编译器比较",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"解释器和编译器的具体特性如下所示："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"需要注意早期的 Web 前端要求页面的启动速度快，因此采用解释执行的方式运行，但是运行时性能相对较低。为了解决 JavaScript 运行时性能问题，V8 引入了 JIT 编译技术。"}),"\n",(0,t.jsxs)(e.h3,{id:"jit-编译器",children:["JIT 编译器",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#jit-编译器",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"JIT （Just In Time）编译器是一种在代码运行时就可以进行编译的技术，属于后端编译器，主要作用是将 IR 转换成目标程序（机器码）。"}),"\n",(0,t.jsx)(e.p,{children:"解释器是在运行时逐行对 IR 进行解释执行，虽然启动速度快，但是运行时性能较低，而传统编译器则做不到在代码运行时对代码进行编译优化，编译时和运行时必须分离。JIT 编译器不仅仅具备了解释器的运行时编译特性，还具备了传统编译器的编译优化特性："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"因为 JIT 编译器和解释器在编译时和运行时都不需要分离，因此两者可以在运行时进行混合使用，从而结合各自的优点，加快代码启动速度的同时还可以提升代码的运行性能，从而解决单个解释器或者单个传统编译器的缺陷问题。"}),"\n",(0,t.jsxs)(e.h3,{id:"解释器和-jit-编译器混合技术",children:["解释器和 JIT 编译器混合技术",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解释器和-jit-编译器混合技术",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"为了解决 JavaScript 在运行时性能较慢的问题，通过引入 JIT 技术，并采用混合动态编译的方式来提升 JavaScript 的运行性能，具体思路如下所示："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"为了提升 JavaScript 的启动速度，首次启动代码时会采用解释执行的方式运行。如果代码每次执行都采用逐行解释执行的方式，那么运行时性能较低。为了解决运行时性能的问题，同时会引入 JIT 编译技术，通过监听热点代码（经常会被调用的代码或者循环体），提前将代码通过运行时的 JIT 编译器转换成机器码，再适当的时机通过执行机器码来代替逐行解释执行，可以提升 JavaScript 的运行时性能。"}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["温馨提示：解释器和 JIT 编译器混合使用可以相互取长补短。在 Java 中也是采用同样的混合编译方式，具体查看 ",(0,t.jsx)(e.a,{href:"https://www.ibm.com/docs/zh/sdk-java-technology/8?topic=reference-jit-compiler",target:"_blank",rel:"noopener noreferrer",children:"JIT 编译器"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"javascript-编译原理",children:["JavaScript 编译原理",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-编译原理",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://v8.js.cn/",target:"_blank",rel:"noopener noreferrer",children:"V8"})," 是一个开源的 JavaScript 虚拟机，目前主要用在 Chrome 浏览器以及 Node.js 中，核心功能是用于解释和执行 JavaScript 语言。V8 致力于追求极致的 JavaScript 运行性能，在经历多个编译流程的演变之后，最终采用解释器和 JIT 编译器混合的编译技术，如下所示："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["温馨提示：在 Chrome 91 中新增了一个 ",(0,t.jsx)(e.a,{href:"https://v8.js.cn/blog/sparkplug/",target:"_blank",rel:"noopener noreferrer",children:"Sparkplug"})," 非优化编译器，位于 Ignition 解释器和 TurboFan 优化编译器之间，旨在快速编译，提升编译机器码的性能。"]}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"ignition-解释器",children:["Ignition 解释器",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#ignition-解释器",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["Ignition 的主要作用是将 AST 转换成 ",(0,t.jsx)(e.a,{href:"https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775",target:"_blank",rel:"noopener noreferrer",children:"Bytecode"}),"（字节码）。在运行的过程中，会使用类型反馈技术并计算热点代码，最终交给 TurboFan 进行动态运行时的编译优化。Ignition 的解释执行流程如下所示："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsxs)(e.p,{children:["在字节码解释执行的过程中，会将需要进行性能优化的运行时信息指向对应的",(0,t.jsx)(e.a,{href:"https://www.youtube.com/watch?v=u7zRSm8jzvA",target:"_blank",rel:"noopener noreferrer",children:" Feedback Vector"}),"（反馈向量），Feeback Vector 中会包含根据内联缓存（Inline Cache，IC）来存储的多种类型的插槽（Feedback Vector Slot）信息，例如 BinaryOp 插槽（二进制操作结果的数据类型）、Invocation Count（函数的调用次数）以及 Optimized Code 信息等。"]}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsx)(e.p,{children:"温馨提示：这里不会过多讲解每个执行流程的细节问题。上述透出的反馈向量信息（Feedback Vector）会在接下来的 V8 运行时演示中进行信息打印。"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"turbofan-编译器",children:["TurboFan 编译器",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#turbofan-编译器",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"TurboFan 利用了 JIT 编译技术，主要作用是对 JavaScript 代码进行运行时编译优化，具体的工作流程如下所示："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["温馨提示：图片来源于 ",(0,t.jsx)(e.a,{href:"https://benediktmeurer.de/2017/12/13/an-introduction-to-speculative-optimization-in-v8/",target:"_blank",rel:"noopener noreferrer",children:"An Introduction to Speculative Optimization in V8"}),"。"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"需要注意 Profiling Feedback 部分，这里主要提供 Ignition 解释执行过程中生成的运行时反馈向量信息 Feedback Vector ，Turbofan 会结合字节码以及反馈向量信息生成图示（数据结构中的图结构），之后会根据该信息对代码进行优化和去优化。"}),"\n",(0,t.jsx)(e.p,{children:"去优化是指让代码回退到 Ignition 进行解释执行，去优化本质是因为机器码已经不能满足运行诉求，例如一个变量从 string 类型转变成 number 类型，机器码编译的是 string 类型，此时已经无法再满足运行诉求，因此 V8 会执行去优化动作，将代码回退到 Ignition 进行解释执行。"}),"\n",(0,t.jsxs)(e.h2,{id:"javascript-编译实践",children:["JavaScript 编译实践",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-编译实践",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"在了解 V8 的编译原理之后，可以使用 V8 的调试工具来查看 JavaScript 的编译信息，从而验证对 V8 的编译原理认知。"}),"\n",(0,t.jsxs)(e.h3,{id:"d8-调试工具",children:["D8 调试工具",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#d8-调试工具",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"如果想了解 JavaScript 在 V8 中的编译时和运行时信息，可以使用调试工具 D8。 D8 是 V8 引擎的命令行 Shell，可以查看 AST 生成、中间代码 ByteCode、优化代码、反优化代码、优化编译器的统计数据、代码的 GC 等信息。D8 的安装方式有很多，如下所示："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["方法一：根据 V8 官方文档 ",(0,t.jsx)(e.a,{href:"https://v8.dev/docs/d8",target:"_blank",rel:"noopener noreferrer",children:"Using d8"})," 以及 ",(0,t.jsx)(e.a,{href:"https://v8.dev/docs/build-gn",target:"_blank",rel:"noopener noreferrer",children:"Building V8 with GN"})," 进行工具链的下载和编译"]}),"\n",(0,t.jsxs)(e.li,{children:["方法二：使用别人已经编译好的 D8 工具，可能版本会有滞后性，例如 ",(0,t.jsx)(e.a,{href:"https://storage.googleapis.com/chromium-v8/official/canary/v8-mac64-dbg-8.4.109.zip",target:"_blank",rel:"noopener noreferrer",children:"Mac 版"})]}),"\n",(0,t.jsxs)(e.li,{children:["方法三：使用 JavaScript 引擎版本管理工具，例如 ",(0,t.jsx)(e.a,{href:"https://github.com/GoogleChromeLabs/jsvu",target:"_blank",rel:"noopener noreferrer",children:"jsvu"}),"，可以下载到最新编译好的 JavaScript 引擎"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"本文使用方法三安装 v8-debug 工具，安装完成后执行 v8-debug --help 可以查看有哪些命令："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"# 49.原理进阶：V8 的编译原理\nv8-debug --help\n\nSynopsis:\nshell [options] [--shell] [<file>...]\nd8 [options] [-e <string>] [--shell] [[--module|--web-snapshot] <file>...]\n\n-e        execute a string in V8\n--shell   run an interactive JavaScript shell\n--module  execute a file as a JavaScript module\n--web-snapshot  execute a file as a web snapshot\n\nSSE3=1 SSSE3=1 SSE4_1=1 SSE4_2=1 SAHF=1 AVX=1 AVX2=1 FMA3=1 BMI1=1 BMI2=1 LZCNT=1 POPCNT=1 ATOM=0\nThe following syntax for options is accepted (both '-' and '--' are ok):\n--flag        (bool flags only)\n--no-flag     (bool flags only)\n--flag=value  (non-bool flags only, no spaces around '=')\n--flag value  (non-bool flags only)\n--            (captures all remaining args in JavaScript)\n\nOptions:\n# 打印生成的字节码\n--print-bytecode (print bytecode generated by ignition interpreter)\ntype: bool  default: --noprint-bytecode\n\n\n# 跟踪被优化的信息\n--trace-opt (trace optimized compilation)\ntype: bool  default: --notrace-opt\n--trace-opt-verbose (extra verbose optimized compilation tracing)\ntype: bool  default: --notrace-opt-verbose\n--trace-opt-stats (trace optimized compilation statistics)\ntype: bool  default: --notrace-opt-stats\n\n# 跟踪去优化的信息\n--trace-deopt (trace deoptimization)\ntype: bool  default: --notrace-deopt\n--log-deopt (log deoptimization)\ntype: bool  default: --nolog-deopt\n--trace-deopt-verbose (extra verbose deoptimization tracing)\ntype: bool  default: --notrace-deopt-verbose\n--print-deopt-stress (print number of possible deopt points)\n\n\n# 查看编译生成的 AST\n--print-ast (print source AST)\ntype: bool  default: --noprint-ast\n\n# 查看编译生成的代码\n--print-code (print generated code)\ntype: bool  default: --noprint-code\n\n# 查看优化后的代码\n--print-opt-code (print optimized code)\ntype: bool  default: --noprint-opt-code\n\n# 允许在源代码中使用 V8 提供的原生 API 语法\n--allow-natives-syntax (allow natives syntax)\ntype: bool  default: --noallow-natives-syntax\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"编译生成-ast",children:["编译生成 AST",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编译生成-ast",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["编写一个 ",(0,t.jsx)(e.code,{children:"index.js"})," 文件，在文件中写入 JavaScript 代码，执行一个简单的 ",(0,t.jsx)(e.code,{children:"add"})," 函数："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"function add(x, y) {\n  return x + y\n}\n\nconsole.log(add(1, 2));\n"})}),"\n",(0,t.jsxs)(e.p,{children:["使用 ",(0,t.jsx)(e.code,{children:"--print-ast"})," 参数可以打印 ",(0,t.jsx)(e.code,{children:"add"})," 函数的 AST 信息，执行如下命令："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"v8-debug --print-ast ./index.js\n"})}),"\n",(0,t.jsx)(e.p,{children:"执行后的打印信息如下所示："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'[generating bytecode for function: ]\n--- AST ---\nFUNC at 0\n. KIND 0\n. LITERAL ID 0\n. SUSPEND COUNT 0\n. NAME ""\n. INFERRED NAME ""\n. DECLS\n. . FUNCTION "add" = function add\n. EXPRESSION STATEMENT at 41\n. . ASSIGN at -1\n. . . VAR PROXY local[0] (0x7fb8c080e630) (mode = TEMPORARY, assigned = true) ".result"\n. . . CALL\n. . . . PROPERTY at 49\n. . . . . VAR PROXY unallocated (0x7fb8c080e6f0) (mode = DYNAMIC_GLOBAL, assigned = false) "console"\n. . . . . NAME log\n. . . . CALL\n. . . . . VAR PROXY unallocated (0x7fb8c080e470) (mode = VAR, assigned = true) "add"\n. . . . . LITERAL 1\n. . . . . LITERAL 2\n. RETURN at -1\n. . VAR PROXY local[0] (0x7fb8c080e630) (mode = TEMPORARY, assigned = true) ".result"\n\n# 重点关注 add 函数的 AST 信息\n[generating bytecode for function: add]\n--- AST ---\nFUNC at 12\n. KIND 0\n. LITERAL ID 1\n. SUSPEND COUNT 0\n. NAME "add"\n. PARAMS\n. . VAR (0x7fb8c080e4d8) (mode = VAR, assigned = false) "x"\n. . VAR (0x7fb8c080e580) (mode = VAR, assigned = false) "y"\n. DECLS\n. . VARIABLE (0x7fb8c080e4d8) (mode = VAR, assigned = false) "x"\n. . VARIABLE (0x7fb8c080e580) (mode = VAR, assigned = false) "y"\n. RETURN at 25\n. . ADD at 34\n. . . VAR PROXY parameter[0] (0x7fb8c080e4d8) (mode = VAR, assigned = false) "x"\n. . . VAR PROXY parameter[1] (0x7fb8c080e580) (mode = VAR, assigned = false) "y"\n'})}),"\n",(0,t.jsxs)(e.p,{children:["重点关注一下 ",(0,t.jsx)(e.code,{children:"add"})," 函数的 AST 信息，如下所示："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"VAR PROXY 节点在真正的分析阶段会连接到对应地址的 VAR 节点。"}),"\n",(0,t.jsxs)(e.h3,{id:"编译生成字节码",children:["编译生成字节码",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编译生成字节码",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["AST 会经过 Ignition 解释器的 ",(0,t.jsx)(e.code,{children:"BytecodeGenerator"})," 函数生成字节码，可以通过 ",(0,t.jsx)(e.code,{children:"--print-bytecode"})," 参数进行打印，执行如下操作："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"v8-debug --print-bytecode ./index.js\n"})}),"\n",(0,t.jsx)(e.p,{children:"执行后的打印信息如下所示："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"[generated bytecode for function:  (0x3ab2082933f5 <SharedFunctionInfo>)]\nBytecode length: 43\nParameter count 1\nRegister count 6\nFrame size 48\nOSR nesting level: 0\nBytecode Age: 0\n         0x3ab2082934be @    0 : 13 00             LdaConstant [0]\n         0x3ab2082934c0 @    2 : c3                Star1 \n         0x3ab2082934c1 @    3 : 19 fe f8          Mov <closure>, r2\n         0x3ab2082934c4 @    6 : 65 52 01 f9 02    CallRuntime [DeclareGlobals], r1-r2\n         0x3ab2082934c9 @   11 : 21 01 00          LdaGlobal [1], [0]\n         0x3ab2082934cc @   14 : c2                Star2 \n         0x3ab2082934cd @   15 : 2d f8 02 02       LdaNamedProperty r2, [2], [2]\n         0x3ab2082934d1 @   19 : c3                Star1 \n         0x3ab2082934d2 @   20 : 21 03 04          LdaGlobal [3], [4]\n         0x3ab2082934d5 @   23 : c1                Star3 \n         0x3ab2082934d6 @   24 : 0d 01             LdaSmi [1]\n         0x3ab2082934d8 @   26 : c0                Star4 \n         0x3ab2082934d9 @   27 : 0d 02             LdaSmi [2]\n         0x3ab2082934db @   29 : bf                Star5 \n         0x3ab2082934dc @   30 : 63 f7 f6 f5 06    CallUndefinedReceiver2 r3, r4, r5, [6]\n         0x3ab2082934e1 @   35 : c1                Star3 \n         0x3ab2082934e2 @   36 : 5e f9 f8 f7 08    CallProperty1 r1, r2, r3, [8]\n         0x3ab2082934e7 @   41 : c4                Star0 \n         0x3ab2082934e8 @   42 : a9                Return \nConstant pool (size = 4)\n0x3ab208293485: [FixedArray] in OldSpace\n - map: 0x3ab208002205 <Map>\n - length: 4\n           0: 0x3ab20829343d <FixedArray[2]>\n           1: 0x3ab208202741 <String[7]: #console>\n           2: 0x3ab20820278d <String[3]: #log>\n           3: 0x3ab208003f09 <String[3]: #add>\nHandler Table (size = 0)\nSource Position Table (size = 0)\n\n# 重点关注 add 函数的字节码信息\n[generated bytecode for function: add (0x3ab20829344d <SharedFunctionInfo add>)]\nBytecode length: 6\n# 接受 3 个参数， 1 个隐式的 this，以及 2 个显式的 x 和 y\nParameter count 3\nRegister count 0\n# 不需要局部变量，因此帧大小为 0 \nFrame size 0\nOSR nesting level: 0\nBytecode Age: 0\n         0x3ab2082935f6 @    0 : 0b 04             Ldar a1\n         0x3ab2082935f8 @    2 : 39 03 00          Add a0, [0]\n         0x3ab2082935fb @    5 : a9                Return \nConstant pool (size = 0)\nHandler Table (size = 0)\nSource Position Table (size = 0)\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"add"})," 函数主要包含以下 3 个字节码序列："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"# 加载寄存器 a1 的值到累加器中\nLdar a1\n# 读取寄存器 a0 的值并累加到累加器中，相加之后的结果继续放在累加器中\n# [0] 指向 Feedback Vector Slot\n# [0] 用于 Ignition 收集值的分析信息，为后续的 TurboFan 优化做准备\nAdd a0, [0]\n# 转交控制权给调用者，并返回累加器中的值\nReturn \n"})}),"\n",(0,t.jsx)(e.p,{children:"从上述字节码可以看出， Ignition 解释执行采用的是一地址指令结构的寄存器架构。"}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["温馨提示：关于一地址和多地址的指令结构（二地址、三地址）设计，请自行查阅。更多关于字节码的信息可查看 ",(0,t.jsx)(e.a,{href:"https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775",target:"_blank",rel:"noopener noreferrer",children:"Understanding V8’s Bytecode"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"优化和去优化",children:["优化和去优化",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#优化和去优化",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"JavaScript 是一门弱类型语言，不会像强类型语言那样需要限定函数调用的形参数据类型，可以非常灵活的传入各种类型的参数进行处理，如下所示："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"function add(x, y) { \n  // + 操作符是 JavaScript 中非常复杂的一个操作\n  return x + y\n}\n\nadd(1, 2);\nadd('1', 2);\nadd(null, 2);\nadd(undefined, 2);\nadd([], 2);\nadd({}, 2);\nadd([], {});\n"})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsx)(e.p,{children:"温馨提示：JavaScript 是一门动态类型语言还是静态类型语言？注意强弱类型和动态静态类型是两种不同的概念，不要混淆。"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["为了可以进行 ",(0,t.jsx)(e.code,{children:"+"})," 操作符运算，V8 在底层执行的时候往往需要调用很多 API，比如 ",(0,t.jsx)(e.code,{children:"ToPrimitive"}),"（判断是否是对象）、",(0,t.jsx)(e.code,{children:"ToString"}),"、",(0,t.jsx)(e.code,{children:"ToNumber"})," 等，将传入的参数进行符合 ",(0,t.jsx)(e.code,{children:"+"})," 操作符的数据转换处理。在代码运行时 V8 会对 JavaScript 语言像强类型语言那样对 ",(0,t.jsx)(e.code,{children:"add"}),"函数的形参 x 和 y 进行推测，这样就可以在运行的过程中进行编译优化。在 Ignition 解释器中通过字节码来收集反馈信息，从而为编译优化做准备，如下所示："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsxs)(e.p,{children:["为了查看 ",(0,t.jsx)(e.code,{children:"add"})," 函数的运行时反馈信息，可以在 ",(0,t.jsx)(e.code,{children:"index.js"})," 中通过调用 V8 提供的 Native API 来打印 ",(0,t.jsx)(e.code,{children:"add"})," 函数的运行信息，具体如下所示："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"function add(x, y) {\n  return x + y\n}\n\n// 注意默认采用 ClosureFeedbackCellArray\n// 为了查看效果，强制开启 FeedbackVector\n// 更多信息查看： A lighter V8：https://v8.dev/blog/v8-lite\n%EnsureFeedbackVectorForFunction(add);\n\nadd(1, 2);\n\n// 打印 add 详细的运行时信息\n%DebugPrint(add);\n"})}),"\n",(0,t.jsxs)(e.p,{children:["通过 ",(0,t.jsx)(e.code,{children:"--allow-natives-syntax"})," 参数可以在 JavaScript 中调用 ",(0,t.jsx)(e.code,{children:"%EnsureFeedbackVectorForFunction"})," 和 ",(0,t.jsx)(e.code,{children:"%DebugPrint"})," 这两个底层 Native API，执行如下命令："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"v8-debug --allow-natives-syntax  ./index.js\n"})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["温馨提示：更多 Native API 可以查看 V8 的",(0,t.jsx)(e.a,{href:"https://github.com/v8/v8/blob/main/src/runtime/runtime.h",target:"_blank",rel:"noopener noreferrer",children:" runtime.h "}),"头文件。"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"执行后的打印信息如下所示："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"DebugPrint: 0x340d00293e5d: [Function] in OldSpace\n - map: 0x340d002c22a1 <Map[32](HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x340d00284019 <JSFunction (sfi = 0x340d0020aaa1)>\n - elements: 0x340d00002251 <FixedArray[0]> [HOLEY_ELEMENTS]\n - function prototype: \n - initial_map: \n # SharedFunctionInfo（SFI）\n - shared_info: 0x340d00293d71 <SharedFunctionInfo add>\n - name: 0x340d00005609 <String[3]: #add>\n # 包含 Ignition 解释器的 trampoline 指针，用于记录解释器的执行位置，去优化时用于回退该位置\n - builtin: InterpreterEntryTrampoline\n - formal_parameter_count: 2\n - kind: NormalFunction\n - context: 0x340d00283ac9 <NativeContext[271]>\n - code: 0x340d0020b379 <Other heap object (CODE_DATA_CONTAINER_TYPE)>\n - interpreted\n - bytecode: 0x340d00293eed <BytecodeArray[6]>\n - source code: (x, y) {\n    return x + y\n}\n - properties: 0x340d00002251 <FixedArray[0]>\n - All own properties (excluding elements): {\n    0x340d00006325: [String] in ReadOnlySpace: #length: 0x340d00204361 <AccessorInfo name= 0x340d00006325 <String[6]: #length>, data= 0x340d000023d9 <undefined>> (const accessor descriptor), location: descriptor\n    0x340d0000656d: [String] in ReadOnlySpace: #name: 0x340d00204339 <AccessorInfo name= 0x340d0000656d <String[4]: #name>, data= 0x340d000023d9 <undefined>> (const accessor descriptor), location: descriptor\n    0x340d000056ad: [String] in ReadOnlySpace: #arguments: 0x340d002042e9 <AccessorInfo name= 0x340d000056ad <String[9]: #arguments>, data= 0x340d000023d9 <undefined>> (const accessor descriptor), location: descriptor\n    0x340d000058f1: [String] in ReadOnlySpace: #caller: 0x340d00204311 <AccessorInfo name= 0x340d000058f1 <String[6]: #caller>, data= 0x340d000023d9 <undefined>> (const accessor descriptor), location: descriptor\n    0x340d00006831: [String] in ReadOnlySpace: #prototype: 0x340d00204389 <AccessorInfo name= 0x340d00006831 <String[9]: #prototype>, data= 0x340d000023d9 <undefined>> (const accessor descriptor), location: descriptor\n }\n # 反馈向量\n - feedback vector: 0x340d00293f25: [FeedbackVector] in OldSpace\n - map: 0x340d00002735 <Map(FEEDBACK_VECTOR_TYPE)>\n - length: 1\n - shared function info: 0x340d00293d71 <SharedFunctionInfo add>\n # 没有优化代码信息\n - no optimized code\n - tiering state: TieringState::kNone\n - maybe has optimized code: 0\n # 函数调用 1 次\n - invocation count: 1\n - profiler ticks: 0\n - closure feedback cell array: 0x340d00003469: [ClosureFeedbackCellArray] in ReadOnlySpace\n - map: 0x340d00002979 <Map(CLOSURE_FEEDBACK_CELL_ARRAY_TYPE)>\n - length: 0\n\n # 二进制操作结果的数据类型：SignedSmall\n # SignedSmall：有符号的小整数类型\n # V8 自己声明的一种用于优化策略的数据类型，不是 JavaScript 的数据类型\n - slot #0 BinaryOp BinaryOp:SignedSmall {\n     [0]: 1\n  }\n0x340d002c22a1: [Map]\n - type: JS_FUNCTION_TYPE\n - instance size: 32\n - inobject properties: 0\n - elements kind: HOLEY_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - stable_map\n - callable\n - constructor\n - has_prototype_slot\n - back pointer: 0x340d000023d9 <undefined>\n - prototype_validity cell: 0x340d00204479 <Cell value= 1>\n - instance descriptors (own) #5: 0x340d002840c9 <DescriptorArray[5]>\n - prototype: 0x340d00284019 <JSFunction (sfi = 0x340d0020aaa1)>\n - constructor: 0x340d00284095 <JSFunction Function (sfi = 0x340d0021b321)>\n - dependent code: 0x340d000021d9 <Other heap object (WEAK_ARRAY_LIST_TYPE)>\n - construction counter: 0\n"})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["温馨提示：这里的 SharedFunctionInfo（SFI）中保留了一个 InterpreterEntryTrampoline 指针信息，每个函数都会有一个指向 Ignition 解释器的 trampoline 指针，每当 V8 需要进去",(0,t.jsx)(e.strong,{children:"去优化"}),"时，就会使用此指针使代码回退到解释器相应的函数执行位置。"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["为了使得 ",(0,t.jsx)(e.code,{children:"add"})," 函数可以像热点代码一样被优化，在这里强制模拟一次函数优化："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"function add(x, y) {\n  return x + y\n}\n\n// 强制开启 FeedbackVector\n%EnsureFeedbackVectorForFunction(add);\n\nadd(1, 2);\n\n// 强制开启函数优化\n%OptimizeFunctionOnNextCall(add);\n\n// 本次调用因为强制优化不会计入 Invocation Count\nadd(1, 2);\n\n// 打印 add 详细的运行时信息        \n%DebugPrint(add);\n"})}),"\n",(0,t.jsxs)(e.p,{children:["通过 ",(0,t.jsx)(e.code,{children:"--trace-opt"})," 参数可以跟踪 ",(0,t.jsx)(e.code,{children:"add"})," 函数的编译优化信息，执行如下命令："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"v8-debug --allow-natives-syntax --trace-opt  ./index.js\n"})}),"\n",(0,t.jsx)(e.p,{children:"执行后的打印信息如下所示："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"[manually marking 0x3872082935bd <JSFunction add (sfi = 0x3872082934b9)> for non-concurrent optimization]\n# 这里说明使用 TurboFan 优化编译器对 add 函数进行编译优化\n[compiling method 0x3872082935bd <JSFunction add (sfi = 0x3872082934b9)> (target TURBOFAN) using TurboFan]\n[optimizing 0x3872082935bd <JSFunction add (sfi = 0x3872082934b9)> (target TURBOFAN) - took 0.097, 2.003, 0.273 ms]\nDebugPrint: 0x3872082935bd: [Function] in OldSpace\n - map: 0x3872082c2281 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x387208283b79 <JSFunction (sfi = 0x38720820abbd)>\n - elements: 0x38720800222d <FixedArray[0]> [HOLEY_ELEMENTS]\n - function prototype: \n - initial_map: \n - shared_info: 0x3872082934b9 <SharedFunctionInfo add>\n - name: 0x387208003f09 <String[3]: #add>\n - formal_parameter_count: 2\n - kind: NormalFunction\n - context: 0x387208283649 <NativeContext[263]>\n - code: 0x387200044001 <Code TURBOFAN>\n - source code: (x, y) {\n    return x + y\n}\n - properties: 0x38720800222d <FixedArray[0]>\n - All own properties (excluding elements): {\n    0x387208004bb5: [String] in ReadOnlySpace: #length: 0x387208204431 <AccessorInfo> (const accessor descriptor), location: descriptor\n    0x387208004dfd: [String] in ReadOnlySpace: #name: 0x3872082043ed <AccessorInfo> (const accessor descriptor), location: descriptor\n    0x387208003fad: [String] in ReadOnlySpace: #arguments: 0x387208204365 <AccessorInfo> (const accessor descriptor), location: descriptor\n    0x3872080041f1: [String] in ReadOnlySpace: #caller: 0x3872082043a9 <AccessorInfo> (const accessor descriptor), location: descriptor\n    0x3872080050b1: [String] in ReadOnlySpace: #prototype: 0x387208204475 <AccessorInfo> (const accessor descriptor), location: descriptor\n }\n - feedback vector: 0x387208293685: [FeedbackVector] in OldSpace\n - map: 0x387208002711 <Map>\n - length: 1\n - shared function info: 0x3872082934b9 <SharedFunctionInfo add>\n # 注意这里的信息是第一次 add 函数调用的信息，因此没有优化代码\n - no optimized code\n - optimization marker: OptimizationMarker::kNone\n - optimization tier: OptimizationTier::kNone\n # 函数调用 1 次（不包含强制优化的 add 调用）\n - invocation count: 1\n - profiler ticks: 0\n - closure feedback cell array: 0x3872080032b5: [ClosureFeedbackCellArray] in ReadOnlySpace\n - map: 0x387208002955 <Map>\n - length: 0\n\n # 二进制操作结果的数据类型：SignedSmall\n # SignedSmall：有符号的小整数类型\n # V8 自己声明的一种用于优化策略的数据类型，不是 JavaScript 的数据类型\n - slot #0 BinaryOp BinaryOp:SignedSmall {\n     [0]: 1\n  }\n0x3872082c2281: [Map]\n - type: JS_FUNCTION_TYPE\n - instance size: 32\n - inobject properties: 0\n - elements kind: HOLEY_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - stable_map\n - callable\n - constructor\n - has_prototype_slot\n - back pointer: 0x3872080023b5 <undefined>\n - prototype_validity cell: 0x3872082044fd <Cell value= 1>\n - instance descriptors (own) #5: 0x387208283c29 <DescriptorArray[5]>\n - prototype: 0x387208283b79 <JSFunction (sfi = 0x38720820abbd)>\n - constructor: 0x387208283bf5 <JSFunction Function (sfi = 0x38720820acb9)>\n - dependent code: 0x3872080021b9 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>\n - construction counter: 0\n"})}),"\n",(0,t.jsxs)(e.p,{children:["如果不强制开启优化，那么可以通过循环体的方式让 ",(0,t.jsx)(e.code,{children:"add"})," 函数的调用变成热点代码，例如："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"function add(x, y) {\n    return x + y\n}\n\n// 循环体\nfor(let i =0; i<1000000; i++) {\n  // 多次被调用，成为热点代码\n  add(1, 2); \n}\n\n\n%DebugPrint(add);\n"})}),"\n",(0,t.jsxs)(e.p,{children:["仍然通过 ",(0,t.jsx)(e.code,{children:"--trace-opt"})," 参数可以跟踪 ",(0,t.jsx)(e.code,{children:"add"})," 函数的编译优化信息，执行后的打印信息如下所示："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"# 这里说明使用 TurboFan 优化编译器对 add 函数进行编译优化\n[marking 0x239800293e59 <JSFunction (sfi = 0x239800293ced)> for optimization to TURBOFAN, ConcurrencyMode::kConcurrent, reason: small function]\n[compiling method 0x239800293e59 <JSFunction (sfi = 0x239800293ced)> (target TURBOFAN) OSR, mode: ConcurrencyMode::kConcurrent]\n[optimizing 0x239800293e59 <JSFunction (sfi = 0x239800293ced)> (target TURBOFAN) - took 0.143, 5.668, 0.523 ms]\n[completed optimizing 0x239800293e59 <JSFunction (sfi = 0x239800293ced)> (target TURBOFAN)]\nDebugPrint: 0x239800293e9d: [Function] in OldSpace\n - map: 0x2398002c22a1 <Map[32](HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x239800284019 <JSFunction (sfi = 0x23980020aaa1)>\n - elements: 0x239800002251 <FixedArray[0]> [HOLEY_ELEMENTS]\n - function prototype: \n - initial_map: \n - shared_info: 0x239800293d45 <SharedFunctionInfo add>\n - name: 0x239800005609 <String[3]: #add>\n - builtin: InterpreterEntryTrampoline\n - formal_parameter_count: 2\n - kind: NormalFunction\n - context: 0x239800283ac9 <NativeContext[271]>\n - code: 0x23980020b379 <Other heap object (CODE_DATA_CONTAINER_TYPE)>\n - interpreted\n - bytecode: 0x239800293f2d <BytecodeArray[6]>\n - source code: (x, y) {\n    return x + y\n}\n - properties: 0x239800002251 <FixedArray[0]>\n - All own properties (excluding elements): {\n    0x239800006325: [String] in ReadOnlySpace: #length: 0x239800204361 <AccessorInfo name= 0x239800006325 <String[6]: #length>, data= 0x2398000023d9 <undefined>> (const accessor descriptor), location: descriptor\n    0x23980000656d: [String] in ReadOnlySpace: #name: 0x239800204339 <AccessorInfo name= 0x23980000656d <String[4]: #name>, data= 0x2398000023d9 <undefined>> (const accessor descriptor), location: descriptor\n    0x2398000056ad: [String] in ReadOnlySpace: #arguments: 0x2398002042e9 <AccessorInfo name= 0x2398000056ad <String[9]: #arguments>, data= 0x2398000023d9 <undefined>> (const accessor descriptor), location: descriptor\n    0x2398000058f1: [String] in ReadOnlySpace: #caller: 0x239800204311 <AccessorInfo name= 0x2398000058f1 <String[6]: #caller>, data= 0x2398000023d9 <undefined>> (const accessor descriptor), location: descriptor\n    0x239800006831: [String] in ReadOnlySpace: #prototype: 0x239800204389 <AccessorInfo name= 0x239800006831 <String[9]: #prototype>, data= 0x2398000023d9 <undefined>> (const accessor descriptor), location: descriptor\n }\n - feedback vector: 0x239800293f75: [FeedbackVector] in OldSpace\n - map: 0x239800002735 <Map(FEEDBACK_VECTOR_TYPE)>\n - length: 1\n - shared function info: 0x239800293d45 <SharedFunctionInfo add>\n - no optimized code\n - tiering state: TieringState::kNone\n - maybe has optimized code: 0\n # 函数调用 5763 次（不包含优化的 add 调用）\n # 需要注意每次执行该调用次数会有差异，可以知晓优化是一个动态策略\n - invocation count: 5763\n - profiler ticks: 0\n - closure feedback cell array: 0x239800003469: [ClosureFeedbackCellArray] in ReadOnlySpace\n - map: 0x239800002979 <Map(CLOSURE_FEEDBACK_CELL_ARRAY_TYPE)>\n - length: 0\n\n - slot #0 BinaryOp BinaryOp:SignedSmall {\n     [0]: 1\n  }\n0x2398002c22a1: [Map]\n - type: JS_FUNCTION_TYPE\n - instance size: 32\n - inobject properties: 0\n - elements kind: HOLEY_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - stable_map\n - callable\n - constructor\n - has_prototype_slot\n - back pointer: 0x2398000023d9 <undefined>\n - prototype_validity cell: 0x239800204479 <Cell value= 1>\n - instance descriptors (own) #5: 0x2398002840c9 <DescriptorArray[5]>\n - prototype: 0x239800284019 <JSFunction (sfi = 0x23980020aaa1)>\n - constructor: 0x239800284095 <JSFunction Function (sfi = 0x23980021b321)>\n - dependent code: 0x2398000021d9 <Other heap object (WEAK_ARRAY_LIST_TYPE)>\n - construction counter: 0\n"})}),"\n",(0,t.jsxs)(e.p,{children:["从上述的 ",(0,t.jsx)(e.code,{children:"invocation count"}),"可以看出， ",(0,t.jsx)(e.code,{children:"add"}),"函数在被调用了 5763 次后进行了优化处理，因此猜测剩下的 ",(0,t.jsx)(e.code,{children:"1000000 - 5763"})," 次调用应该都执行了优化后的机器码执行。"]}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["温馨提示：通过 ",(0,t.jsx)(e.code,{children:"v8-debug --help"}),"可以查看更多可用于验证认知的参数，例如 ",(0,t.jsx)(e.code,{children:"--print-opt-code"})," 打印优化代码、",(0,t.jsx)(e.code,{children:"--turbofan"})," 使用优化编译器、",(0,t.jsx)(e.code,{children:"--concurrent-recompilation"})," 使用异步的方式新开线程执行热点代码优化..."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"需要注意 V8 会自动监测代码的数据类型变化，从而执行去优化，例如："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"function add(x, y) {\n  return x + y\n}\n\n// 循环体\nfor(let i =0; i<1000000; i++) {\n  // 多次被调用，成为热点代码\n  add(1, 2); \n}\n\n// 将第二个参数的 number 类型更改为 string 类型，V8 将执行去优化\nadd(1, '2'); \n\n%DebugPrint(add);\n"})}),"\n",(0,t.jsxs)(e.p,{children:["通过 ",(0,t.jsx)(e.code,{children:"--trace-deopt"})," 参数可以跟踪 ",(0,t.jsx)(e.code,{children:"add"})," 函数的编译去优化信息，执行如下命令："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"v8-debug --allow-natives-syntax --trace-deopt  ./index.js\n"})}),"\n",(0,t.jsx)(e.p,{children:"执行后的打印信息如下所示："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"# 执行去优化，reason: not a Smi\n# 这里说明传入的不是一个小整数类型\n[bailout (kind: deopt-eager, reason: not a Smi: begin. deoptimizing 0x08f70829363d <JSFunction add (sfi = 0x8f7082934c9)>, opt id 0, node id 58, bytecode offset 2, deopt exit 1, FP to SP delta 32, caller SP 0x7ffee9ce7d70, pc 0x08f700044162]\nDebugPrint: 0x8f70829363d: [Function] in OldSpace\n - map: 0x08f7082c2281 <Map(HOLEY_ELEMENTS)> [FastProperties]\n - prototype: 0x08f708283b79 <JSFunction (sfi = 0x8f70820abbd)>\n - elements: 0x08f70800222d <FixedArray[0]> [HOLEY_ELEMENTS]\n - function prototype: \n - initial_map: \n - shared_info: 0x08f7082934c9 <SharedFunctionInfo add>\n - name: 0x08f708003f09 <String[3]: #add>\n - formal_parameter_count: 2\n - kind: NormalFunction\n - context: 0x08f708283649 <NativeContext[263]>\n - code: 0x08f700044001 <Code TURBOFAN>\n - interpreted\n - bytecode: 0x08f7082936cd <BytecodeArray[6]>\n - source code: (x, y) {\n    return x + y\n}\n - properties: 0x08f70800222d <FixedArray[0]>\n - All own properties (excluding elements): {\n    0x8f708004bb5: [String] in ReadOnlySpace: #length: 0x08f708204431 <AccessorInfo> (const accessor descriptor), location: descriptor\n    0x8f708004dfd: [String] in ReadOnlySpace: #name: 0x08f7082043ed <AccessorInfo> (const accessor descriptor), location: descriptor\n    0x8f708003fad: [String] in ReadOnlySpace: #arguments: 0x08f708204365 <AccessorInfo> (const accessor descriptor), location: descriptor\n    0x8f7080041f1: [String] in ReadOnlySpace: #caller: 0x08f7082043a9 <AccessorInfo> (const accessor descriptor), location: descriptor\n    0x8f7080050b1: [String] in ReadOnlySpace: #prototype: 0x08f708204475 <AccessorInfo> (const accessor descriptor), location: descriptor\n }\n - feedback vector: 0x8f708293715: [FeedbackVector] in OldSpace\n - map: 0x08f708002711 <Map>\n - length: 1\n - shared function info: 0x08f7082934c9 <SharedFunctionInfo add>\n - no optimized code\n - optimization marker: OptimizationMarker::kNone\n - optimization tier: OptimizationTier::kNone\n - invocation count: 1\n - profiler ticks: 0\n - closure feedback cell array: 0x8f7080032b5: [ClosureFeedbackCellArray] in ReadOnlySpace\n - map: 0x08f708002955 <Map>\n - length: 0\n\n - slot #0 BinaryOp BinaryOp:Any {\n     [0]: 127\n  }\n0x8f7082c2281: [Map]\n - type: JS_FUNCTION_TYPE\n - instance size: 32\n - inobject properties: 0\n - elements kind: HOLEY_ELEMENTS\n - unused property fields: 0\n - enum length: invalid\n - stable_map\n - callable\n - constructor\n - has_prototype_slot\n - back pointer: 0x08f7080023b5 <undefined>\n - prototype_validity cell: 0x08f7082044fd <Cell value= 1>\n - instance descriptors (own) #5: 0x08f708283c29 <DescriptorArray[5]>\n - prototype: 0x08f708283b79 <JSFunction (sfi = 0x8f70820abbd)>\n - constructor: 0x08f708283bf5 <JSFunction Function (sfi = 0x8f70820acb9)>\n - dependent code: 0x08f7080021b9 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>\n - construction counter: 0\n"})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["温馨提示：可以将 ",(0,t.jsx)(e.code,{children:"--trace-deopt"})," 和 ",(0,t.jsx)(e.code,{children:"--trace-opt"})," 组合使用。"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"代码在执行去优化的过程中会产生性能损耗（需要将代码执行切回到解释器解释执行的指针位置），因此在日常的开发中，建议使用 TypeScript 对代码进行类型声明，这样可以一定程度提升代码的不可变性能。"})]})}function m(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(g,{...n})}):g(n)}let S=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F49.%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%EF%BC%9AV8%20%E7%9A%84%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.md"]={toc:[{text:"编译器和解释器",id:"编译器和解释器",depth:2},{text:"解释器",id:"解释器",depth:3},{text:"编译器",id:"编译器",depth:3},{text:"中间表示",id:"中间表示",depth:4},{text:"优化编译器",id:"优化编译器",depth:4},{text:"解释器和编译器比较",id:"解释器和编译器比较",depth:3},{text:"JIT 编译器",id:"jit-编译器",depth:3},{text:"解释器和 JIT 编译器混合技术",id:"解释器和-jit-编译器混合技术",depth:3},{text:"JavaScript 编译原理",id:"javascript-编译原理",depth:2},{text:"Ignition 解释器",id:"ignition-解释器",depth:3},{text:"TurboFan 编译器",id:"turbofan-编译器",depth:3},{text:"JavaScript 编译实践",id:"javascript-编译实践",depth:2},{text:"D8 调试工具",id:"d8-调试工具",depth:3},{text:"编译生成 AST",id:"编译生成-ast",depth:3},{text:"编译生成字节码",id:"编译生成字节码",depth:3},{text:"优化和去优化",id:"优化和去优化",depth:3}],title:"",headingTitle:"",frontmatter:{}}}}]);