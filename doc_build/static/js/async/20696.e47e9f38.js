"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["20696"],{608018:function(e,r,n){n.r(r),n.d(r,{default:()=>q});var s=n(552676),t=n(740453);let p=n.p+"static/image/a2e752515c23c00bae7e9144283d146e.1f12b3f3.png",i=n.p+"static/image/a5c22fb9343b4d7c59cdffcda3a209a7.04138db1.png",a=n.p+"static/image/b50aec0b3ea2e5eeba58cdcba2641d20.ff723b58.png",c=n.p+"static/image/cc5c52f293c68754601b3ce39bdc962e.c94c6c9e.png",d=n.p+"static/image/94f9520e0dc06118fd8a634d04542e53.79539b32.png",l=n.p+"static/image/945d098d2ab6f69f88917119f6085a42.507bd49e.png",o=n.p+"static/image/02fddc488918fd09c1602565329d3a3e.60f8e74b.png",j=n.p+"static/image/bc12946dd0469d30f852619cb1d22ca8.1e347617.png",h=n.p+"static/image/a089533ad550b9d8368b1150f6365df4.c7c3f9bf.png",x=n.p+"static/image/0833b173580459378fc4150a9ef5f80b.a51d309e.png",g=n.p+"static/image/58326f90fdd4ca0f59e6b8319c0ead32.679e9429.png",b=n.p+"static/image/5e500363d3bc7a7d3194fd3f80483d3d.038e7d2a.png",m=n.p+"static/image/dfbf6a889f00a661023e6276d20f8548.434b7eef.png",f=n.p+"static/image/cb1be6956c438ce33804582ea879def4.0585bfeb.png",u=n.p+"static/image/5a7d7b7a6f9127df9b93efba9b46f6a5.e649463a.png",y=n.p+"static/image/921e8dd412dd80e970ac8f057f6b0347.5e870cce.png",A=n.p+"static/image/799c01cb8c14369a605071841d74fbf6.d3cf4140.png",v=n.p+"static/image/4278b95a6c9b55b6f88d1edaf0f38e0d.d224d7d7.png",E=n.p+"static/image/33edaa6356d7bdb382f67bbad8147aaf.39fcbbff.png",S=n.p+"static/image/ae76972e7ba655905334fa2e4578692f.34270a51.png",P=n.p+"static/image/b22f085c4be94e40ef684c95903f681d.172de47b.png",T=n.p+"static/image/1befc5862510dff5728dd0ca2fc3e908.627f491b.png",_=n.p+"static/image/6b3a0a05d820e020721fe656e6a4709c.6e8557e6.png",B=n.p+"static/image/c124555f68d6f9c9fdc4d0e55c1cd0df.e26c4f22.png";function N(e){let r=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",pre:"pre",code:"code",strong:"strong",ul:"ul",li:"li"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"36加餐会了-babel-插件就会写-prettier-插件",children:["36.加餐：会了 babel 插件，就会写 prettier 插件",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#36加餐会了-babel-插件就会写-prettier-插件",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"最近写了一个 Prettier 插件，可以达到这样的效果："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"同事每次保存代码的时候，import 语句的顺序都会随机变。"}),"\n",(0,s.jsx)(r.p,{children:"但是他去 prettier 配置文件里还啥也发现不了。"}),"\n",(0,s.jsx)(r.p,{children:"于是就会一脸懵逼。"}),"\n",(0,s.jsx)(r.p,{children:"那么这个同事发现了会打你的 prettier 插件是怎么实现的呢？"}),"\n",(0,s.jsx)(r.p,{children:"其实底层还是 babel 插件的东西。"}),"\n",(0,s.jsxs)(r.h2,{id:"prettier-的原理",children:["Prettier 的原理",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#prettier-的原理",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"前端的编译工具都是从源码到源码的转换，所以都是 parse、transform、generate 这三步："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"parse 是把源码字符串转换成 AST 的对象树，transform 是对 AST 做增删改，而 generate （或者叫 printer）是把转换后的 AST 递归打印成目标代码。"}),"\n",(0,s.jsx)(r.p,{children:"prettier 其实也基于编译实现的，只不过不做中间的转换，只是 parse 和 print（也可以叫 generate），所以分为两步："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"它主要的格式化功能都是在 print 阶段做的。"}),"\n",(0,s.jsx)(r.p,{children:"整个流程还是比较简单的，那它是怎么支持那么多语言的呢？"}),"\n",(0,s.jsx)(r.p,{children:"当然是每种语言有各自的 parser 和 printer 呀！"}),"\n",(0,s.jsx)(r.p,{children:"比如它内置了这些 parser："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"ts、js、css、scss、html 等都支持，就是因为不同的后缀名会启用不同的 parser 和 printer。"}),"\n",(0,s.jsx)(r.p,{children:"而且，它是支持插件的，你完全可以通过 prettier 插件来实现任何一种语言的格式化。"}),"\n",(0,s.jsx)(r.p,{children:"很容易想到，插件自然也是指定什么后缀名的文件，用什么 parser 和 printer，所以是这样的格式："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"我们看一个真实的插件，格式化 nginx 配置文件的 prettier 插件 prettier-plugin-nginx："}),"\n",(0,s.jsx)(r.p,{children:"languages 部分就是指定这个语言的名字，什么后缀名的文件，用什么 parser。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"然后 parser 部分就是实现字符串到 AST 的 parse："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"printer 部分就是把 AST 打印成代码："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"当然，prettier 插件里的 printer 不是直接打印成字符串，而是打印成一种 Doc 的格式，便于 prettier 再做一层格式控制。"}),"\n",(0,s.jsx)(r.p,{children:"总之，想扩展一种新的语言的格式化，只要实现 parser 和 printer 就好了。"}),"\n",(0,s.jsx)(r.p,{children:"但前面那个修改 imports 的插件也不是新语言呀，不是 js/ts 代码么？这种怎么写 prettier 插件？"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"其实 parser 还可以指定一个预处理器："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"在 parse 之前对内容做一些修改："}),"\n",(0,s.jsx)(r.p,{children:"所以完整的 prettier 流程应该是这样的："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"那我们写一个 prettier 插件，对 js/ts/vue/flow 的代码都做下同样的预处理，不就能实现随机打乱 imports 的效果么～"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"我们来写一下："}),"\n",(0,s.jsx)(r.p,{children:"只需要对 prettier 默认的 babel 和 typescript 的 parser 做修改就可以了。"}),"\n",(0,s.jsx)(r.p,{children:"其他配置保持不变，只是修改下 preprocess 部分："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'const babelParsers = require("prettier/parser-babel").parsers;\nconst typescriptParsers = require("prettier/parser-typescript").parsers;\n\nfunction myPreprocessor(code, options) {\n  return code + \'guangguangguang\';\n}\n\nmodule.exports = {\n  parsers: {\n    babel: {\n      ...babelParsers.babel,\n      preprocess: myPreprocessor,\n    },\n    typescript: {\n      ...typescriptParsers.typescript,\n      preprocess: myPreprocessor,\n    },\n  },\n};\n'})}),"\n",(0,s.jsx)(r.p,{children:"我在代码后加了一个 guangguangguang。"}),"\n",(0,s.jsx)(r.p,{children:"在 prettier 配置文件里引入这个插件："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"然后我们跑下 prettier："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"我们写的第一个 prettier 插件生效了！"}),"\n",(0,s.jsx)(r.p,{children:"而且除了 js、ts，在 vue 文件里也会生效："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"这是因为在 parse vue 的 sfc 的时候，script 的部分还是用 babel 或者 tsc 的。"}),"\n",(0,s.jsx)(r.p,{children:"当然，一般我们会配置 vscode 在保存的时候自动调用 prettier 来格式化。"}),"\n",(0,s.jsx)(r.p,{children:"这需要安装 prettier 插件："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"然后按照它的文档来配置 settings："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"直接这样配就行："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-json",children:'{\n  "editor.defaultFormatter": "esbenp.prettier-vscode",\n  "editor.formatOnSave": true\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"然后就每次保存自动用 prettier 格式化了："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"然后我们开始实现打乱 imports 的功能。"}),"\n",(0,s.jsx)(r.p,{children:"要找到 imports 的代码，然后做一些修改，自然会想到通过 babel 的 api。"}),"\n",(0,s.jsx)(r.p,{children:"所以我们可以这样写："}),"\n",(0,s.jsx)(r.p,{children:"先引入这几个包："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'const parser = require("@babel/parser");\nconst traverse = require("@babel/traverse").default;\nconst generate = require("@babel/generator").default;\nconst types = require("@babel/types");\n\nconst _ = require("lodash");\n'})}),"\n",(0,s.jsx)(r.p,{children:"parser、traverse、generate 这几个包都很好懂，就是对应 babel 编译的 3 个步骤的。"}),"\n",(0,s.jsx)(r.p,{children:"types 包是用于创建 AST 的。"}),"\n",(0,s.jsx)(r.p,{children:"因为有的包是 esm 导出的，所以用 commonjs 的方式导入需要取 .default 属性。"}),"\n",(0,s.jsx)(r.p,{children:"然后引入 lodash，一些工具函数。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"第一步，调用 parser.parse 把代码转成 AST。"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'function myPreprocessor(code, options) {\n  const ast = parser.parse(code, {\n    plugins: ["typescript", "jsx"],\n    sourceType: "module",\n  });\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"如果 parse ts 和 jsx 代码，需要分别指定 typescript 和 jsx 插件。"}),"\n",(0,s.jsx)(r.p,{children:"sourceType 为 module 代表是有 import 或者 export 的模块代码。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"第二步，把 imports 节点找出来。"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"const importNodes = [];\n\ntraverse(ast, {\n    ImportDeclaration(path) {\n      importNodes.push(_.clone(path.node));\n\n      path.remove();\n    }\n});\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"遍历 AST，声明对 import 语句的处理。"}),"\n",(0,s.jsxs)(r.p,{children:["具体什么代码是什么 AST 可以在 ",(0,s.jsx)(r.a,{href:"http://astexplorer.net",target:"_blank",rel:"noopener noreferrer",children:"http://astexplorer.net"})," 可视化查看："]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"把 AST 节点用 lodash的 clone 函数复制一份，放到数组里。"}),"\n",(0,s.jsx)(r.p,{children:"然后把原 AST 的 import 节点删掉。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"第三步，对 imports 节点排序。"})}),"\n",(0,s.jsx)(r.p,{children:"这一步就用 lodash 的 shuffle 函数就行："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"const newImports = _.shuffle(importNodes);\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"第四步，打印成目标代码。"})}),"\n",(0,s.jsx)(r.p,{children:"修改完 AST，把它打印成目标代码就好了，只不过现在是两部分代码，分别 generate，然后拼接起来："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'const newAST = types.file({\n    type: "Program",\n    body: newImports,\n});\n\nconst newCode =  generate(newAST).code +\n    "\\n" +\n    generate(ast, {\n      retainLines: true,\n    }).code;\n\n'})}),"\n",(0,s.jsx)(r.p,{children:"import 语句需要包裹一层 file 的根结点，用 @babel/types 包的 api 创建："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"generate 的时候可以加一个 retainLines 为 true，也就是打印的时候保留在源码中的行数，这样打印完了行数不会变。"}),"\n",(0,s.jsx)(r.p,{children:"至此，这个随机打乱 imports 顺序的 prettier 插件我们就完成了。"}),"\n",(0,s.jsx)(r.p,{children:"完整代码如下："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'const babelParsers = require("prettier/parser-babel").parsers;\nconst typescriptParsers = require("prettier/parser-typescript").parsers;\n\nconst parser = require("@babel/parser");\nconst traverse = require("@babel/traverse").default;\nconst generate = require("@babel/generator").default;\nconst types = require("@babel/types");\n\nconst _ = require("lodash");\n\nfunction myPreprocessor(code, options) {\n  const ast = parser.parse(code, {\n    plugins: ["typescript", "jsx"],\n    sourceType: "module",\n  });\n\n  const importNodes = [];\n\n  traverse(ast, {\n    ImportDeclaration(path) {\n      importNodes.push(_.clone(path.node));\n\n      path.remove();\n    },\n  });\n\n  const newImports = _.shuffle(importNodes);\n\n  const newAST = types.file({\n    type: "Program",\n    body: newImports,\n  });\n\n  const newCode =  generate(newAST).code +\n    "\\n" +\n    generate(ast, {\n      retainLines: true,\n    }).code;\n\n  return newCode;\n}\n\nmodule.exports = {\n  parsers: {\n    babel: {\n      ...babelParsers.babel,\n      preprocess: myPreprocessor,\n    },\n    typescript: {\n      ...typescriptParsers.typescript,\n      preprocess: myPreprocessor,\n    },\n  },\n};\n'})}),"\n",(0,s.jsx)(r.p,{children:"我们来试一下。"}),"\n",(0,s.jsx)(r.p,{children:"在 js/ts 文件中："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"在 vue 文件中："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"都生效了！（因为 prettier 插件有缓存，不生效的话关掉再打开编辑器就好了）"}),"\n",(0,s.jsx)(r.p,{children:"至此，我们这个同事发现了会打你的插件完成了！"}),"\n",(0,s.jsx)(r.p,{children:"有的同学说，但是在配置文件里会引入呀，这个也太明显了吧。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"其实不是的。默认 prettier 会加载 node_modules 下的所有 prettier-plugin-xx 的或者 @xxx/prettier-plugin-yy 的插件，不需要手动指定 plugins，这个只有我们本地开发的时候需要这样指定。"}),"\n",(0,s.jsx)(r.p,{children:"比如社区有 prettier-plugin-sort-import 这个插件，用于 import 排序的："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"就不需要自己引入就可以直接做配置了："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"所以，只要安装这个打乱 imports 的 prettier 插件的依赖，prettier 就会自动应用，同事不看 package.json 就很难发现。"}),"\n",(0,s.jsxs)(r.h2,{id:"总结",children:["总结",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"prettier 是基于编译技术实现的，前端的编译都是 parse、transform、generate 这三个步骤，prettier 也是，只不过不需要中间的 transform。"}),"\n",(0,s.jsx)(r.p,{children:"它只包含 parser 和 printer 这两部分，但是支持很多 language。每种 language 都有自己的 parser 和 printer。"}),"\n",(0,s.jsx)(r.p,{children:"写一个支持新的语言的格式化的 prettier 插件，只需要一个导出 languages、parsers、pritners 配置的文件："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"languages 部分指定语言的名字，文件后缀名，用什么 parser 等。"}),"\n",(0,s.jsx)(r.li,{children:"parsers 部分实现字符串到 AST 的 parse，还可以指定预处理函数 preprocess。"}),"\n",(0,s.jsx)(r.li,{children:"printers 部分实现 AST 到 doc 的打印，doc 是 prettier 的一种中间格式，便于 prettier 再做一层统一的格式控制，之后再打印为字符串"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"今天我们写的 prettier 插件并不是实现新语言的支持，所以只用到了 preprocess 对代码做了预处理，通过 babel 的 api 来对代码做了 imports 的处理。"}),"\n",(0,s.jsxs)(r.p,{children:["所以，会了 babel 插件就会写 prettier 插件对 js/ts 做预处理，同理，会了 postcss、posthtml 等也可以用来对 css、scss、less、html 等做预处理，",(0,s.jsx)(r.strong,{children:"在格式化代码时加入一些自定义逻辑"}),"。"]}),"\n",(0,s.jsx)(r.p,{children:"最后，文中的 prettier 插件的案例只是学习用，不建议大家把这种插件引入项目，否则后果自负[旺柴]。"})]})}function w(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,t.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(N,{...e})}):N(e)}let q=w;w.__RSPRESS_PAGE_META={},w.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F36.%E5%8A%A0%E9%A4%90%EF%BC%9A%E4%BC%9A%E4%BA%86%20babel%20%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%86%99%20prettier%20%E6%8F%92%E4%BB%B6.md"]={toc:[{text:"Prettier 的原理",id:"prettier-的原理",depth:2},{text:"总结",id:"总结",depth:2}],title:"36.加餐：会了 babel 插件，就会写 prettier 插件",headingTitle:"36.加餐：会了 babel 插件，就会写 prettier 插件",frontmatter:{}}}}]);