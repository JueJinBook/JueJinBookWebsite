"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["44549"],{925232:function(e,n,s){s.r(n),s.d(n,{default:()=>V});var i=s(552676),r=s(740453);let c=s.p+"static/image/fd7c82e7839bfd6c7579d8f5f8d33dbe.8c9d341b.webp",d=s.p+"static/image/57af8e95af16295f840185f1b69ed24a.09357058.webp",l=s.p+"static/image/2ed346d72da1bbfd8d80b5817dd97387.57361b75.webp",a=s.p+"static/image/12deaeaeabc3314d9afbd2bcea6ec6a0.11c497a4.webp",t=s.p+"static/image/3c2be30d6d52e8dff3922aa0b81e696a.32f77b09.webp",o=s.p+"static/image/0a43acf76f65a80d11961ea3cd04d901.cc69886e.webp",h=s.p+"static/image/1849458dc0f34031e903337641051df5.375052f5.webp",x=s.p+"static/image/3a47fa54f48c8b93856d30f43ef7d45d.4c536401.webp",p=s.p+"static/image/5424e829916db5c43ad058d14a9de8bf.8eaf9619.webp",g=s.p+"static/image/3513a6a11a40143039851aa72cc8dc75.c1abf305.webp",j=s.p+"static/image/b8951dee8fc9cc7fa83a682b028bfdbd.16979cc7.webp",m=s.p+"static/image/5b20ff4cf4e2674ba234b0dd878ed89b.16b93cbc.webp",u=s.p+"static/image/229a9ea6ff043a9abfe2286ea6f69351.ac8e6560.webp",v=s.p+"static/image/fc93c1dbfea5686013c107550eb88637.b915cabf.webp",f=s.p+"static/image/f6b77bfa370c88466192e1042ed49e38.5b862fad.webp",b=s.p+"static/image/e66f92bbd4396746d02930815598d054.bfbf0084.webp",N=s.p+"static/image/da297ad3ee1de6f2a38ffac47a3f9e31.c8a0874a.webp";function E(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",h2:"h2",h3:"h3",ol:"ol",li:"li",pre:"pre",img:"img",ul:"ul",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"6静态资源_-如何在-vite-中处理各种静态资源",children:["6.静态资源_ 如何在 Vite 中处理各种静态资源？",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6静态资源_-如何在-vite-中处理各种静态资源",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["静态资源处理是前端工程经常遇到的问题，在真实的工程中不仅仅包含了动态执行的代码，也不可避免地要引入各种静态资源，如",(0,i.jsx)(n.code,{children:"图片"}),"、",(0,i.jsx)(n.code,{children:"JSON"}),"、",(0,i.jsx)(n.code,{children:"Worker 文件"}),"、",(0,i.jsx)(n.code,{children:"Web Assembly 文件"}),"等等。"]}),"\n",(0,i.jsxs)(n.p,{children:["而静态资源本身并不是标准意义上的模块，因此对它们的处理和普通的代码是需要区别对待的。一方面我们需要解决",(0,i.jsx)(n.strong,{children:"资源加载"}),"的问题，对 Vite 来说就是如何将静态资源解析并加载为一个 ES 模块的问题；另一方面在",(0,i.jsx)(n.strong,{children:"生产环境"}),"下我们还需要考虑静态资源的部署问题、体积问题、网络性能问题，并采取相应的方案来进行优化。"]}),"\n",(0,i.jsx)(n.p,{children:"在本小节，我将与你就这两方面的问题展开探讨，结合 Vite 自身的能力及其生态，来解决项目中静态资源处理的各个疑难点，同时也能继续完善目前的 Vite 脚手架工程。"}),"\n",(0,i.jsxs)(n.h2,{id:"图片加载",children:["图片加载",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图片加载",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["图片是项目中最常用的静态资源之一，本身包括了非常多的格式，诸如 png、jpeg、webp、avif、gif，当然，也包括经常用作图标的 svg 格式。这一部分我们主要讨论的是如何加载图片，也就是说怎么让图片在页面中",(0,i.jsx)(n.strong,{children:"正常显示"}),"。"]}),"\n",(0,i.jsxs)(n.h3,{id:"1-使用场景",children:["1. 使用场景",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-使用场景",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在日常的项目开发过程中，我们一般会遇到三种加载图片的场景:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"在 HTML 或者 JSX 中，通过 img 标签来加载图片，如:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<img src="../../assets/a.png"></img>\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"在 CSS 中通过 background 属性加载图片，如:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",children:"background: url('../../assets/b.png') norepeat;\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsxs)(n.li,{children:["在 JavaScript 中，通过脚本的方式动态指定图片的",(0,i.jsx)(n.code,{children:"src"}),"属性，如:"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"document.getElementById('hero-img').src = '../../assets/c.png'\n"})}),"\n",(0,i.jsxs)(n.p,{children:["当然，大家一般还会有别名路径的需求，比如地址前缀直接换成",(0,i.jsx)(n.code,{children:"@assets"}),"，这样就不用开发人员手动寻址，降低开发时的心智负担。"]}),"\n",(0,i.jsxs)(n.h3,{id:"2-在-vite-中使用",children:["2. 在 Vite 中使用",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-在-vite-中使用",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"接下来让我们在目前的脚手架项目来进行实际的编码，你可以在 Vite 的配置文件中配置一下别名，方便后续的图片引入:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\nimport path from 'path';\n\n{\n  resolve: {\n    // 别名配置\n    alias: {\n      '@assets': path.join(__dirname, 'src/assets')\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这样 Vite 在遇到",(0,i.jsx)(n.code,{children:"@assets"}),"路径的时候，会自动帮我们定位至根目录下的",(0,i.jsx)(n.code,{children:"src/assets"}),"目录。值得注意的是，alias 别名配置不仅在 JavaScript 的 import 语句中生效，在 CSS 代码的 ",(0,i.jsx)(n.code,{children:"@import"})," 和 ",(0,i.jsx)(n.code,{children:"url"}),"导入语句中也同样生效。"]}),"\n",(0,i.jsxs)(n.p,{children:["现在 ",(0,i.jsx)(n.code,{children:"src/assets"})," 目录的内容如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:".\n├── icons\n│   ├── favicon.svg\n│   ├── logo-1.svg\n│   ├── logo-2.svg\n│   ├── logo-3.svg\n│   ├── logo-4.svg\n│   ├── logo-5.svg\n│   └── logo.svg\n└── imgs\n    ├── background.png\n    └── vite.png\n"})}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们在 Header 组件中引入 ",(0,i.jsx)(n.code,{children:"vite.png"}),"这张图片:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Header/index.tsx\nimport React, { useEffect } from 'react';\nimport { devDependencies } from '../../../package.json';\nimport styles from './index.module.scss';\n// 1. 导入图片\nimport logoSrc from '@assets/imgs/vite.png';\n\n// 方式一\nexport function Header() {\n  return (\n    <div className={`p-20px text-center ${styles.header}`}>\n      \x3c!-- 省略前面的组件内容 --\x3e\n      \x3c!-- 使用图片 --\x3e\n      <img className=\"m-auto mb-4\" src={logoSrc} alt=\"\" />\n    </div>\n  );\n}\n\n// 方式二\nexport function Header() {\n  useEffect(() => {\n    const img = document.getElementById('logo') as HTMLImageElement;\n    img.src = logoSrc;\n  }, []);\n  return (\n    <div className={`p-20px text-center ${styles.header}`}>\n      \x3c!-- 省略前面的组件内容 --\x3e\n      \x3c!-- 使用图片 --\x3e\n      <img id=\"logo\" className=\"m-auto mb-4\" alt=\"\" />\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"可以发现图片能够正常显示:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:N,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["而图片路径也被解析为了正确的格式(",(0,i.jsx)(n.code,{children:"/"}),"表示项目根路径):"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["OK，现在让我们进入 Header 组件的样式文件中添加",(0,i.jsx)(n.code,{children:"background"}),"属性:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-scss",children:".header {\n  // 前面的样式代码省略\n  background: url('@assets/imgs/background.png') no-repeat;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"再次回到浏览器，可以看到生效后的背景如下:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-svg-组件方式加载",children:["3. SVG 组件方式加载",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-svg-组件方式加载",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"刚才我们成功地在 Vite 中实现了图片的加载，上述这些加载的方式对于 svg 格式来说依然是适用的。不过，我们通常也希望能将 svg 当做一个组件来引入，这样我们可以很方便地修改 svg 的各种属性，而且比 img 标签的引入方式更加优雅。"}),"\n",(0,i.jsx)(n.p,{children:"SVG 组件加载在不同的前端框架中的实现不太相同，社区中也已经了有了对应的插件支持:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Vue2 项目中可以使用 ",(0,i.jsx)(n.a,{href:"https://github.com/pakholeung37/vite-plugin-vue2-svg",target:"_blank",rel:"noopener noreferrer",children:"vite-plugin-vue2-svg"}),"插件。"]}),"\n",(0,i.jsxs)(n.li,{children:["Vue3 项目中可以引入 ",(0,i.jsx)(n.a,{href:"https://github.com/jpkleemans/vite-svg-loader",target:"_blank",rel:"noopener noreferrer",children:"vite-svg-loader"}),"。"]}),"\n",(0,i.jsxs)(n.li,{children:["React 项目使用 ",(0,i.jsx)(n.a,{href:"https://github.com/pd4d10/vite-plugin-svgr",target:"_blank",rel:"noopener noreferrer",children:"vite-plugin-svgr"}),"插件。"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"现在让我们在 React 脚手架项目中安装对应的依赖:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm i vite-plugin-svgr -D\n"})}),"\n",(0,i.jsx)(n.p,{children:"然后需要在 vite 配置文件添加这个插件:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\nimport svgr from 'vite-plugin-svgr';\n\n{\n  plugins: [\n    // 其它插件省略\n    svgr()\n  ]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["随后注意要在 ",(0,i.jsx)(n.code,{children:"tsconfig.json"})," 添加如下配置，否则会有类型错误:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "compilerOptions": {\n    // 省略其它配置\n    "types": ["vite-plugin-svgr/client"]\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"接下来让我们在项目中使用 svg 组件:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { ReactComponent as ReactLogo } from '@assets/icons/logo.svg';\n\nexport function Header() {\n  return (\n    // 其他组件内容省略\n     <ReactLogo />\n  )\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"回到浏览器中，你可以看到 svg 已经成功渲染:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:v,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h2,{id:"json-加载",children:["JSON 加载",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#json-加载",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Vite 中已经内置了对于 JSON 文件的解析，底层使用",(0,i.jsx)(n.code,{children:"@rollup/pluginutils"})," 的 ",(0,i.jsx)(n.code,{children:"dataToEsm"}),"  方法将 JSON 对象转换为一个包含各种具名导出的 ES 模块，使用姿势如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { version } from '../../../package.json';\n"})}),"\n",(0,i.jsx)(n.p,{children:"不过你也可以在配置文件禁用按名导入的方式:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\n\n{\n  json: {\n    stringify: true\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这样会将 JSON 的内容解析为",(0,i.jsx)(n.code,{children:'export default JSON.parse("xxx")'}),"，这样会失去",(0,i.jsx)(n.code,{children:"按名导出"}),"的能力，不过在 JSON 数据量比较大的时候，可以优化解析性能。"]}),"\n",(0,i.jsxs)(n.h2,{id:"web-worker-脚本",children:["Web Worker 脚本",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#web-worker-脚本",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Vite 中使用 Web Worker 也非常简单，我们可以在新建",(0,i.jsx)(n.code,{children:"Header/example.js"}),"文件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const start = () => {\n  let count = 0;\n  setInterval(() => {\n    // 给主线程传值\n    postMessage(++count);\n  }, 2000);\n};\n\nstart();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后在 Header 组件中引入，引入的时候注意加上",(0,i.jsx)(n.code,{children:"?worker"}),"后缀，相当于告诉 Vite 这是一个 Web Worker 脚本文件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import Worker from './example.js?worker';\n// 1. 初始化 Worker 实例\nconst worker = new Worker();\n// 2. 主线程监听 worker 的信息\nworker.addEventListener('message', (e) => {\n  console.log(e);\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"打开浏览器的控制面板，你可以看到 Worker 传给主线程的信息已经成功打印:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"说明 Web Worker 脚本已经成功执行，也能与主线程正常通信。"}),"\n",(0,i.jsxs)(n.h3,{id:"web-assembly-文件",children:["Web Assembly 文件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#web-assembly-文件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Vite 对于 ",(0,i.jsx)(n.code,{children:".wasm"})," 文件也提供了开箱即用的支持，我们拿一个斐波拉契的 ",(0,i.jsx)(n.code,{children:".wasm"})," 文件(原文件已经放到",(0,i.jsx)(n.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/tree/main/4~7-vite-project-framework/src/components/Header",target:"_blank",rel:"noopener noreferrer",children:"Github 仓库"}),"中)来进行一下实际操作，对应的 JavaScript 原文件如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export function fib(n) {\n  var a = 0,\n    b = 1;\n  if (n > 0) {\n    while (--n) {\n      let t = a + b;\n      a = b;\n      b = t;\n    }\n    return b;\n  }\n  return a;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["让我们在组件中导入",(0,i.jsx)(n.code,{children:"fib.wasm"}),"文件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Header/index.tsx\nimport init from './fib.wasm?init';\n\ntype FibFunc = (num: number) => number;\n\ninit({}).then((instance) => {\n  const fibFunc = instance.exports.fib as FibFunc;\n  console.log('Fib result:', fibFunc(10));\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Vite 会对",(0,i.jsx)(n.code,{children:".wasm"}),"文件的内容进行封装，默认导出为 init 函数，这个函数返回一个 Promise，因此我们可以在其 then 方法中拿到其导出的成员——",(0,i.jsx)(n.code,{children:"fib"}),"方法。"]}),"\n",(0,i.jsx)(n.p,{children:"回到浏览器，我们可以查看到计算结果，说明 .wasm 文件已经被成功执行:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h3,{id:"其它静态资源",children:["其它静态资源",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其它静态资源",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"除了上述的一些资源格式，Vite 也对下面几类格式提供了内置的支持:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["媒体类文件，包括",(0,i.jsx)(n.code,{children:"mp4"}),"、",(0,i.jsx)(n.code,{children:"webm"}),"、",(0,i.jsx)(n.code,{children:"ogg"}),"、",(0,i.jsx)(n.code,{children:"mp3"}),"、",(0,i.jsx)(n.code,{children:"wav"}),"、",(0,i.jsx)(n.code,{children:"flac"}),"和",(0,i.jsx)(n.code,{children:"aac"}),"。"]}),"\n",(0,i.jsxs)(n.li,{children:["字体类文件。包括",(0,i.jsx)(n.code,{children:"woff"}),"、",(0,i.jsx)(n.code,{children:"woff2"}),"、",(0,i.jsx)(n.code,{children:"eot"}),"、",(0,i.jsx)(n.code,{children:"ttf"})," 和 ",(0,i.jsx)(n.code,{children:"otf"}),"。"]}),"\n",(0,i.jsxs)(n.li,{children:["文本类。包括",(0,i.jsx)(n.code,{children:"webmanifest"}),"、",(0,i.jsx)(n.code,{children:"pdf"}),"和",(0,i.jsx)(n.code,{children:"txt"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["也就是说，你可以在 Vite 将这些类型的文件当做一个 ES 模块来导入使用。如果你的项目中还存在其它格式的静态资源，你可以通过",(0,i.jsx)(n.code,{children:"assetsInclude"}),"配置让 Vite 来支持加载:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\n\n{\n  assetsInclude: ['.gltf']\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"特殊资源后缀",children:["特殊资源后缀",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#特殊资源后缀",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"Vite 中引入静态资源时，也支持在路径最后加上一些特殊的 query 后缀，包括:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"?url"}),": 表示获取资源的路径，这在只想获取文件路径而不是内容的场景将会很有用。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"?raw"}),": 表示获取资源的字符串内容，如果你只想拿到资源的原始内容，可以使用这个后缀。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"?inline"}),": 表示资源强制内联，而不是打包成单独的文件。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"生产环境处理",children:["生产环境处理",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#生产环境处理",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在前面的内容中，我们围绕着如何加载静态资源这个问题，在 Vite 中进行具体的编码实践，相信对于 Vite 中各种静态资源的使用你已经比较熟悉了。但另一方面，在生产环境下，我们又面临着一些新的问题。"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"部署域名怎么配置？"}),"\n",(0,i.jsx)(n.li,{children:"资源打包成单文件还是作为 Base64 格式内联?"}),"\n",(0,i.jsx)(n.li,{children:"图片太大了怎么压缩？"}),"\n",(0,i.jsx)(n.li,{children:"svg 请求数量太多了怎么优化？"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"1-自定义部署域名",children:["1. 自定义部署域名",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-自定义部署域名",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"一般在我们访问线上的站点时，站点里面一些静态资源的地址都包含了相应域名的前缀，如:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'<img src="https://sanyuan.cos.ap-beijing.myqcloud.com/logo.png" />\n'})}),"\n",(0,i.jsxs)(n.p,{children:["以上面这个地址例子，",(0,i.jsx)(n.code,{children:"https://sanyuan.cos.ap-beijing.myqcloud.com"}),"是 CDN 地址前缀，",(0,i.jsx)(n.code,{children:"/logo.png"}),"则是我们开发阶段使用的路径。那么，我们是不是需要在上线前把图片先上传到 CDN，然后将代码中的地址手动替换成线上地址呢？这样就太麻烦了！"]}),"\n",(0,i.jsxs)(n.p,{children:["在 Vite 中我们可以有更加自动化的方式来实现地址的替换，只需要在配置文件中指定",(0,i.jsx)(n.code,{children:"base"}),"参数即可:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\n// 是否为生产环境，在生产环境一般会注入 NODE_ENV 这个环境变量，见下面的环境变量文件配置\nconst isProduction = process.env.NODE_ENV === 'production';\n// 填入项目的 CDN 域名地址\nconst CDN_URL = 'xxxxxx';\n\n// 具体配置\n{\n  base: isProduction ? CDN_URL: '/'\n}\n\n// .env.development\nNODE_ENV=development\n\n// .env.production\nNODE_ENV=production\n"})}),"\n",(0,i.jsxs)(n.p,{children:["注意在项目根目录新增的两个环境变量文件",(0,i.jsx)(n.code,{children:".env.development"}),"和",(0,i.jsx)(n.code,{children:".env.production"}),"，顾名思义，即分别在开发环境和生产环境注入一些环境变量，这里为了区分不同环境我们加上了",(0,i.jsx)(n.code,{children:"NODE_ENV"}),"，你也可以根据需要添加别的环境变量。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"打包的时候 Vite 会自动将这些环境变量替换为相应的字符串。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["接着执行",(0,i.jsx)(n.code,{children:"pnpm run build"}),"，可以发现产物中的静态资源地址已经自动加上了 CDN 地址前缀:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"当然，HTML 中的一些 JS、CSS 资源链接也一起加上了 CDN 地址前缀:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"当然，有时候可能项目中的某些图片需要存放到另外的存储服务，一种直接的方案是将完整地址写死到 src 属性中，如:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'<img src="https://my-image-cdn.com/logo.png">\n'})}),"\n",(0,i.jsxs)(n.p,{children:["这样做显然是不太优雅的，我们可以通过定义环境变量的方式来解决这个问题，在项目根目录新增",(0,i.jsx)(n.code,{children:".env"}),"文件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// 开发环境优先级: .env.development > .env\n// 生产环境优先级: .env.production > .env\n// .env 文件\nVITE_IMG_BASE_URL=https://my-image-cdn.com\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后进入 ",(0,i.jsx)(n.code,{children:"src/vite-env.d.ts"}),"增加类型声明:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'/// <reference types="vite/client" />\n\ninterface ImportMetaEnv {\n  readonly VITE_APP_TITLE: string;\n  // 自定义的环境变量\n  readonly VITE_IMG_BASE_URL: string;\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["值得注意的是，如果某个环境变量要在 Vite 中通过 ",(0,i.jsx)(n.code,{children:"import.meta.env"})," 访问，那么它必须以",(0,i.jsx)(n.code,{children:"VITE_"}),"开头，如",(0,i.jsx)(n.code,{children:"VITE_IMG_BASE_URL"}),"。接下来我们在组件中来使用这个环境变量:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"<img src={new URL('./logo.png', import.meta.env.VITE_IMG_BASE_URL).href} />\n"})}),"\n",(0,i.jsxs)(n.p,{children:["接下来在",(0,i.jsx)(n.code,{children:"开发环境"}),"启动项目或者",(0,i.jsx)(n.code,{children:"生产环境"}),"打包后可以看到环境变量已经被替换，地址能够正常显示:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"至此，我们就彻底解决了图片资源生产环境域名替换的问题。"}),"\n",(0,i.jsxs)(n.h3,{id:"2-单文件-or-内联",children:["2. 单文件 or 内联？",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-单文件-or-内联",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在 Vite 中，所有的静态资源都有两种构建方式，一种是打包成一个单文件，另一种是通过 base64 编码的格式内嵌到代码中。"}),"\n",(0,i.jsx)(n.p,{children:"这两种方案到底应该如何来选择呢？"}),"\n",(0,i.jsxs)(n.p,{children:["对于比较小的资源，适合内联到代码中，一方面对",(0,i.jsx)(n.code,{children:"代码体积"}),"的影响很小，另一方面可以减少不必要的网络请求，",(0,i.jsx)(n.code,{children:"优化网络性能"}),"。而对于比较大的资源，就推荐单独打包成一个文件，而不是内联了，否则可能导致上 MB 的 base64 字符串内嵌到代码中，导致代码体积瞬间庞大，页面加载性能直线下降。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"Vite 中内置的优化方案是下面这样的:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"如果静态资源体积 >= 4KB，则提取成单独的文件"}),"\n",(0,i.jsx)(n.li,{children:"如果静态资源体积 < 4KB，则作为 base64 格式的字符串内联"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["上述的",(0,i.jsx)(n.code,{children:"4 KB"}),"即为提取成单文件的临界值，当然，这个临界值你可以通过",(0,i.jsx)(n.code,{children:"build.assetsInlineLimit"}),"自行配置，如下代码所示:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\n{\n  build: {\n    // 8 KB\n    assetsInlineLimit: 8 * 1024\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"svg 格式的文件不受这个临时值的影响，始终会打包成单独的文件，因为它和普通格式的图片不一样，需要动态设置一些属性"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"3-图片压缩",children:["3. 图片压缩",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-图片压缩",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["图片资源的体积往往是项目产物体积的大头，如果能尽可能精简图片的体积，那么对项目整体打包产物体积的优化将会是非常明显的。在 JavaScript 领域有一个非常知名的图片压缩库",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/imagemin",target:"_blank",rel:"noopener noreferrer",children:"imagemin"}),"，作为一个底层的压缩工具，前端的项目中经常基于它来进行图片压缩，比如 Webpack 中大名鼎鼎的",(0,i.jsx)(n.code,{children:"image-webpack-loader"}),"。社区当中也已经有了开箱即用的 Vite 插件——",(0,i.jsx)(n.code,{children:"vite-plugin-imagemin"}),"，首先让我们来安装它:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm i vite-plugin-imagemin -D\n"})}),"\n",(0,i.jsx)(n.p,{children:"随后在 Vite 配置文件中引入:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"//vite.config.ts\nimport viteImagemin from 'vite-plugin-imagemin';\n\n{\n  plugins: [\n    // 忽略前面的插件\n    viteImagemin({\n      // 无损压缩配置，无损压缩下图片质量不会变差\n      optipng: {\n        optimizationLevel: 7\n      },\n      // 有损压缩配置，有损压缩下图片质量可能会变差\n      pngquant: {\n        quality: [0.8, 0.9],\n      },\n      // svg 优化\n      svgo: {\n        plugins: [\n          {\n            name: 'removeViewBox'\n          },\n          {\n            name: 'removeEmptyAttrs',\n            active: false\n          }\n        ]\n      }\n    })\n  ]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们可以尝试执行",(0,i.jsx)(n.code,{children:"pnpm run build"}),"进行打包:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["Vite 插件已经自动帮助我们调用 ",(0,i.jsx)(n.code,{children:"imagemin"})," 进行项目图片的压缩，可以看到压缩的效果非常明显，强烈推荐大家在项目中使用。"]}),"\n",(0,i.jsxs)(n.h3,{id:"4-雪碧图优化",children:["4. 雪碧图优化",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-雪碧图优化",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在实际的项目中我们还会经常用到各种各样的 svg 图标，虽然 svg 文件一般体积不大，但 Vite 中对于 svg 文件会始终打包成单文件，大量的图标引入之后会导致网络请求增加，大量的 HTTP 请求会导致网络解析耗时变长，页面加载性能直接受到影响。这个问题怎么解决呢？"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"HTTP2 的多路复用设计可以解决大量 HTTP 的请求导致的网络加载性能问题，因此雪碧图技术在 HTTP2 并没有明显的优化效果，这个技术更适合在传统的 HTTP 1.1 场景下使用(比如本地的 Dev Server)。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"比如在 Header 中分别引入 5 个 svg 文件:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import Logo1 from '@assets/icons/logo-1.svg';\nimport Logo2 from '@assets/icons/logo-2.svg';\nimport Logo3 from '@assets/icons/logo-3.svg';\nimport Logo4 from '@assets/icons/logo-4.svg';\nimport Logo5 from '@assets/icons/logo-5.svg';\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这里顺便说一句，Vite 中提供了",(0,i.jsx)(n.code,{children:"import.meta.glob"}),"的语法糖来解决这种",(0,i.jsx)(n.strong,{children:"批量导入"}),"的问题，如上述的 import 语句可以写成下面这样:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const icons = import.meta.glob('../../assets/icons/logo-*.svg');\n"})}),"\n",(0,i.jsx)(n.p,{children:"结果如下:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["可以看到对象的 value 都是动态 import，适合按需加载的场景。在这里我们只需要同步加载即可，可以使用 ",(0,i.jsx)(n.code,{children:"import.meta.globEager"}),"来完成:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const icons = import.meta.globEager('../../assets/icons/logo-*.svg');\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"icons"}),"的结果打印如下:\n",(0,i.jsx)("img",{src:a,alt:"image.png"})]}),"\n",(0,i.jsx)(n.p,{children:"接下来我们稍作解析，然后将 svg 应用到组件当中:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Header/index.tsx\nconst iconUrls = Object.values(icons).map(mod => mod.default);\n\n// 组件返回内容添加如下\n{iconUrls.map((item) => (\n  <img src={item} key={item} width="50" alt="" />\n))}\n'})}),"\n",(0,i.jsx)(n.p,{children:"回到页面中，我们发现浏览器分别发出了 5 个 svg 的请求:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"假设页面有 100 个 svg 图标，将会多出 100 个 HTTP 请求，依此类推。我们能不能把这些 svg 合并到一起，从而大幅减少网络请求呢？"}),"\n",(0,i.jsxs)(n.p,{children:["答案是可以的。这种合并图标的方案也叫",(0,i.jsx)(n.code,{children:"雪碧图"}),"，我们可以通过",(0,i.jsx)(n.code,{children:"vite-plugin-svg-icons"}),"来实现这个方案，首先安装一下这个插件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"pnpm i vite-plugin-svg-icons -D\n"})}),"\n",(0,i.jsx)(n.p,{children:"接着在 Vite 配置文件中增加如下内容:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\nimport { createSvgIconsPlugin } from 'vite-plugin-svg-icons';\n\n{\n  plugins: [\n    // 省略其它插件\n    createSvgIconsPlugin({\n      iconDirs: [path.join(__dirname, 'src/assets/icons')]\n    })\n  ]\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"src/components"}),"目录下新建",(0,i.jsx)(n.code,{children:"SvgIcon"}),"组件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// SvgIcon/index.tsx\nexport interface SvgIconProps {\n  name?: string;\n  prefix: string;\n  color: string;\n  [key: string]: string;\n}\n\nexport default function SvgIcon({\n  name,\n  prefix = 'icon',\n  color = '#333',\n  ...props\n}: SvgIconProps) {\n  const symbolId = `#${prefix}-${name}`;\n\n  return (\n    <svg {...props} aria-hidden=\"true\">\n      <use href={symbolId} fill={color} />\n    </svg>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"现在我们回到 Header 组件中，稍作修改:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// index.tsx\nconst icons = import.meta.globEager('../../assets/icons/logo-*.svg');\nconst iconUrls = Object.values(icons).map((mod) => {\n  // 如 ../../assets/icons/logo-1.svg -> logo-1\n  const fileName = mod.default.split('/').pop();\n  const [svgName] = fileName.split('.');\n  return svgName;\n});\n\n// 渲染 svg 组件\n{iconUrls.map((item) => (\n  <SvgIcon name={item} key={item} width=\"50\" height=\"50\" />\n))}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["最后在",(0,i.jsx)(n.code,{children:"src/main.tsx"}),"文件中添加一行代码:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import 'virtual:svg-icons-register';\n"})}),"\n",(0,i.jsx)(n.p,{children:"现在回到浏览器的页面中，发现雪碧图已经生成:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["雪碧图包含了所有图标的具体内容，而对于页面每个具体的图标，则通过 ",(0,i.jsx)(n.code,{children:"use"})," 属性来引用雪碧图的对应内容:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"如此一来，我们就能将所有的 svg 内容都内联到 HTML 中，省去了大量 svg 的网络请求。"}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["恭喜你，学习完了本节的内容。在这一节，你需要重点掌握在",(0,i.jsx)(n.strong,{children:"Vite 如何加载静态资源"}),"和",(0,i.jsx)(n.strong,{children:"如何在生产环境中对静态资源进行优化"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"首先是如何加载各种静态资源，如图片、svg(组件形式)、JSON、Web Worker 脚本、Web Asssembly 文件等等格式，并通过一些示例带大家进行实际的操作。"}),"\n",(0,i.jsxs)(n.p,{children:["其次，我们会把关注点放到",(0,i.jsx)(n.strong,{children:"生产环境"}),"，对",(0,i.jsx)(n.code,{children:"自定义部署域名"}),"、",(0,i.jsx)(n.code,{children:"是否应该内联"}),"、",(0,i.jsx)(n.code,{children:"图片压缩"}),"、",(0,i.jsx)(n.code,{children:"svg 雪碧图"}),"等问题进行了详细的探讨和实践，对于如何解决这些问题，相信你也有了自己的答案。"]}),"\n",(0,i.jsxs)(n.p,{children:["当然，在编码实操的过程当中，我也给你穿插了一些 Vite 其他的知识点，比如如何",(0,i.jsx)(n.code,{children:"定义环境变量文件"}),"、",(0,i.jsx)(n.code,{children:"如何使用 Glob 导入"}),"的语法糖。相信在学习本节的过程中你能更加体会到 Vite 给项目开发带来的便利，同时也对 Vite 的掌握更深入了一步。"]}),"\n",(0,i.jsx)(n.p,{children:"本节的内容就到这里了，感谢你的阅读，我们下一节再见\uD83D\uDC4B\uD83C\uDFFB！"})]})}function w(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(E,{...e})}):E(e)}let V=w;w.__RSPRESS_PAGE_META={},w.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F6.%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90_%20%E5%A6%82%E4%BD%95%E5%9C%A8%20Vite%20%E4%B8%AD%E5%A4%84%E7%90%86%E5%90%84%E7%A7%8D%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%EF%BC%9F.md"]={toc:[{text:"图片加载",id:"图片加载",depth:2},{text:"1. 使用场景",id:"1-使用场景",depth:3},{text:"2. 在 Vite 中使用",id:"2-在-vite-中使用",depth:3},{text:"3. SVG 组件方式加载",id:"3-svg-组件方式加载",depth:3},{text:"JSON 加载",id:"json-加载",depth:2},{text:"Web Worker 脚本",id:"web-worker-脚本",depth:2},{text:"Web Assembly 文件",id:"web-assembly-文件",depth:3},{text:"其它静态资源",id:"其它静态资源",depth:3},{text:"特殊资源后缀",id:"特殊资源后缀",depth:3},{text:"生产环境处理",id:"生产环境处理",depth:2},{text:"1. 自定义部署域名",id:"1-自定义部署域名",depth:3},{text:"2. 单文件 or 内联？",id:"2-单文件-or-内联",depth:3},{text:"3. 图片压缩",id:"3-图片压缩",depth:3},{text:"4. 雪碧图优化",id:"4-雪碧图优化",depth:3},{text:"小结",id:"小结",depth:2}],title:"6.静态资源_ 如何在 Vite 中处理各种静态资源？",headingTitle:"6.静态资源_ 如何在 Vite 中处理各种静态资源？",frontmatter:{}}}}]);