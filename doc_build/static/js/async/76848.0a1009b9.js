"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["76848"],{550803:function(e,n,s){s.r(n),s.d(n,{default:()=>o});var r=s(552676),t=s(740453);let l=s.p+"static/image/8de476306e47076b03fa8d3d55740541.d2945332.webp",c=s.p+"static/image/0fba39ab29389f932d97c5a3c1356256.3e290c1d.webp";function i(e){let n=Object.assign({p:"p",img:"img",h1:"h1",a:"a",strong:"strong",ol:"ol",li:"li",code:"code",ul:"ul",pre:"pre",blockquote:"blockquote",h2:"h2"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"顾名思义，场景类的 Hooks 需要根据具体的场景去优化封装，这类 Hooks 可能更具有特殊性，所以它们更加贴近我们的业务。"}),"\n",(0,r.jsx)(n.p,{children:"下面着重介绍三个 Hooks 帮助我们去更好地了解。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"场景类Hooks.png"})}),"\n",(0,r.jsxs)(n.h1,{id:"7基础篇自定义-hooks-之-jest三场景类-hooks",children:["7.基础篇｜自定义 Hooks 之 Jest（三）：场景类 Hooks",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7基础篇自定义-hooks-之-jest三场景类-hooks",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useSelections："})," 封装常见的 Checkbox（多选框）逻辑封装。支持多选、全选等操作。"]}),"\n",(0,r.jsx)(n.p,{children:"我们先来看看 Checkbox 常用的场景，如下场景："}),"\n",(0,r.jsx)(n.p,{children:"简要分析下场景："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"所有的按钮可单独点击，第一次点击为选中状态，再次点击为未选中状态；"}),"\n",(0,r.jsx)(n.li,{children:"1 ～ 9，有一个选中，全选按钮为半选状态，全部选中为全选状态；"}),"\n",(0,r.jsx)(n.li,{children:"点击全选按钮，控制所有 1～9 按钮为全选状态，再次点击，全部为未选中状态。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"首先核心点是全选的按钮与 1～9 按钮的关联，1 ～ 9 的状态要在 useSelections 中，所以 useSelections 的第一个参数是 1～9 的数据。"}),"\n",(0,r.jsxs)(n.p,{children:["其次，我们分析下 Checkbox 这个组件，选中通过 ",(0,r.jsx)(n.code,{children:"checked"})," 属性、半选通过",(0,r.jsx)(n.code,{children:"indeterminate"}),"、点击通过 ",(0,r.jsx)(n.code,{children:"onClick"})," 属性。"]}),"\n",(0,r.jsx)(n.p,{children:"那么对应的 useSelections 的反参为："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"selected"}),"：选中的数据列表；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"toggle"}),"：1 ～ 9 单个切换的方法，如果 selected 中存在对应的数据，则剔除，如果不存在，则增加；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"isSelected"}),"：判断数据是在 selected 中，可以判断 Checkbox 是否选中状态；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"allSelected"}),"：全选的状态；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"toggleAll"}),"：切换全选的方法；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"partiallySelected"}),"：是否在半选状态。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["我们可以发现 useSelections 实际上是对 1～9 状态的一个维护，这里通过 new Set 去处理，原因是 Set 处理数据可以方便点，但要注意的是我们拿数据的时候要通过 ",(0,r.jsx)(n.strong,{children:"Array.from"})," 来处理。"]}),"\n",(0,r.jsx)(n.p,{children:"此外，我们可以将增加、删除、设置的方法单独拿出来，同时可以直接赋给 useSelections 的第二个参数：initValues，用来设置初始默认值。这里就不过多赘述，我们直接就上代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { useSafeState, useCreation } from "..";\nconst useSelections = <T,>(lists: T[], initValues: T[] = []) => {\n  const [selected, setSelected] = useSafeState<T[]>(initValues);\n\n  // 通过new Set去处理选中的数据,转化为数组需要使用Array.from\n  const selectedSet = useCreation(() => new Set(selected), [selected]);\n\n  const isSelected = (data: T) => selectedSet.has(data);\n\n  // 增加\n  const selectAdd = (data: T | T[]) => {\n    if (Array.isArray(data)) {\n      data.map((item) => selectedSet.add(item));\n    } else {\n      selectedSet.add(data);\n    }\n    return setSelected(Array.from(selectedSet));\n  };\n\n  // 删除\n  const selectDel = (data: T | T[]) => {\n    if (Array.isArray(data)) {\n      data.map((item) => selectedSet.delete(item));\n    } else {\n      selectedSet.delete(data);\n    }\n    return setSelected(Array.from(selectedSet));\n  };\n\n  // 设置\n  const setSelect = (data: T | T[]) => {\n    selectedSet.clear();\n    if (Array.isArray(data)) {\n      data.map((item) => selectedSet.add(item));\n    } else {\n      selectedSet.add(data);\n    }\n    return setSelected(Array.from(selectedSet));\n  };\n\n  // 状态切换\n  const toggle = (data: T) =>\n    isSelected(data) ? selectDel(data) : selectAdd(data);\n\n  // 全部未选中\n  const noneSelected = useCreation(\n    () => lists.every((ele) => !selectedSet.has(ele)),\n    [lists, selectedSet]\n  );\n\n  // 全部选中\n  const allSelected = useCreation(() => {\n    return lists.every((ele) => selectedSet.has(ele));\n  }, [lists, selectedSet]);\n\n  // 是否半选\n  const partiallySelected = useCreation(\n    () => !noneSelected && !allSelected,\n    [noneSelected, allSelected]\n  );\n\n  // 全选\n  const selectAll = () => {\n    lists.map((item) => selectedSet.add(item));\n    setSelected(Array.from(selectedSet));\n  };\n\n  const unSelectAll = () => {\n    lists.map((item) => selectedSet.delete(item));\n    setSelected(Array.from(selectedSet));\n  };\n\n  const toggleAll = () => (allSelected ? unSelectAll() : selectAll());\n\n  return {\n    selected, // 以选择的元素组\n    isSelected, // 是否被选中\n    selectAdd,\n    selectDel,\n    toggle,\n    setSelect,\n    noneSelected,\n    allSelected,\n    partiallySelected,\n    selectAll,\n    unSelectAll,\n    toggleAll,\n  } as const;\n};\n\nexport default useSelections;\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"useSelections 的单元测试："})}),"\n",(0,r.jsx)(n.p,{children:"关于 useSelections 的单元测试实际非常简单，只需要简单地对其方法进行测试就行了，这里就没有必要讲述，感兴趣的小伙伴可以直接看代码，"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["实际上，useSelection 的实现并不难，只是它跟之前的 Hooks 略有不同，它是以实际场景为条件所创建的，依赖度相对较高。但这里有一个提醒：",(0,r.jsx)(n.strong,{children:"Hooks 是基于逻辑的，而非 View 层面"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h1,{id:"usecountdown",children:["useCountDown",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecountdown",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useCountDown："})," 用于管理倒计时的 Hooks。在日常工作中我们时常需要倒计时的帮助，但处理时间总是比较麻烦的事，而 useCountDown 可以帮助我们解决这类困难。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们先思考一下实际的场景，假设我们要两天后的倒计时，那么我们要知道两天后距离现在的时间戳，然后通过对应的时间戳转换为对应的 ",(0,r.jsx)(n.strong,{children:"天、时、分、秒"}),"，完成倒计时。"]}),"\n",(0,r.jsx)(n.p,{children:"可看出，要想计算倒计时，就得具备两个条件："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"targetDate"}),"：目标时间，如：上述示例的两天后；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"interval"}),"：变化的时间，通常为 1s === 1000 ms。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["返参只要返回目标时间距离当前时间的时间戳（",(0,r.jsx)(n.code,{children:"remainTime"}),"），和转化后的天、时、分等（",(0,r.jsx)(n.code,{children:"formattedTime"}),"）即可。"]}),"\n",(0,r.jsxs)(n.p,{children:["useCountDown 的 targetDate 可能存在多种形式，比如字符串、数字、日期等格式，转化起来相对麻烦，所以我们这里直接用 ",(0,r.jsx)(n.a,{href:"https://dayjs.fenxianglu.cn/category/",target:"_blank",rel:"noopener noreferrer",children:"dayjs 库"}),"，来帮助我们解决这个问题。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"目标时间与当前时间的时间差："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const calcRemain = (target?: TDate) => {\n  if (!target) return 0;\n  const remain = dayjs(target).valueOf() - Date.now();\n  return remain < 0 ? 0 : remain;\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"时间戳进行转化："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const calcFormat = (milliseconds: number): FormattedRes => {\n  return {\n    days: Math.floor(milliseconds / 86400000),\n    hours: Math.floor(milliseconds / 3600000) % 24,\n    minutes: Math.floor(milliseconds / 60000) % 60,\n    seconds: Math.floor(milliseconds / 1000) % 60,\n    milliseconds: Math.floor(milliseconds) % 1000,\n  };\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"时间变化的条件：targetDate、interval。"})," 每秒都会变化，所以这里我们依靠 ",(0,r.jsx)(n.strong,{children:"setInterval"})," 的即可。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  useEffect(() => {\n    if (!targetDate) return setRemainTime(0);\n    setRemainTime(calcRemain(targetDate));\n\n    const timer = setInterval(() => {\n      const remain = calcRemain(targetDate);\n      setRemainTime(remain);\n      if (remain === 0) {\n        clearInterval(timer);\n      }\n    }, interval);\n\n    return () => clearInterval(timer);\n  }, [targetDate, interval]);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"看看效果："})}),"\n",(0,r.jsxs)(n.p,{children:["在效果图中，我们发现时间戳在无规律地变化，尽管设置 interval 为 1000 ms 也不管用，这是因为每次变化的时间并不一定是 1000ms，而是 1000ms 左右，加之程序本身有一定的延迟 ，所以会有无规律变化的感觉。我可以通过 ",(0,r.jsx)(n.code,{children:"Math.round()"})," （四舍五入）来辅助我们完成转化。"]}),"\n",(0,r.jsxs)(n.h2,{id:"targettime-和-onend",children:["targetTime 和 onEnd",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#targettime-和-onend",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"useCountDown 除了上述功能外，我们可以扩展些额外的功能，让 useCountDown 更加完美，如："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"targetTime："})," 剩余时间，当前时间 + 剩余时间 = 目标时间；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"onEnd："})," 当倒计时结束后，触发回调函数。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"可以看出 targetTime 相当于 targetDate 是个简化的版本，所以我们只需要做个兼容即可："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  const target = useCreation(() => {\n    if (targetTime) {\n      return targetTime > 0 ? Date.now() + targetTime : undefined;\n    } else {\n      return targetDate;\n    }\n  }, [targetTime, targetDate]);\n"})}),"\n",(0,r.jsx)(n.p,{children:"而 onEnd 触发的时机为 remain === 0 时即可，效果如下："}),"\n",(0,r.jsxs)(n.h2,{id:"单元测试日期测试",children:["单元测试：日期测试",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单元测试日期测试",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 useCountDown 的单元测试中，涉及到了时间的测试，在这里，我们需要 ",(0,r.jsx)(n.strong,{children:"jest.useFakeTimers"})," 的帮助。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"jest.useFakeTimers"}),"：模拟假计时器，当我们需要",(0,r.jsx)(n.strong,{children:"日期、性能、时间、计时器"}),"的功能，如：Date、setTimeout()、clearTimeout()、setInterval()、clearInterval() 等，都可以通过它来实现。"]}),"\n",(0,r.jsxs)(n.p,{children:["但在 Jest 之前的版本中，jest.useFakeTimers 的使用比较麻烦，但在 Jest 26 中，加入 modern 方式来激活定时器的配置（",(0,r.jsx)(n.a,{href:"https://jestjs.io/blog/2020/05/05/jest-26#new-fake-timers",target:"_blank",rel:"noopener noreferrer",children:"参考文档"}),"），如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'   jest.useFakeTimers("modern")\n'})}),"\n",(0,r.jsxs)(n.p,{children:["但调用 jest.useFakeTimers 会对文件中的所有测试使用假计时器，这种行为是一个",(0,r.jsx)(n.strong,{children:"全局操作"}),"，会影响同一文件的其他测试。"]}),"\n",(0,r.jsxs)(n.p,{children:["所以，在使用 jest.useFakeTimers 的时候必须配合使用 ",(0,r.jsx)(n.strong,{children:"jest.useRealTimers"}),"，它的作用是",(0,r.jsx)(n.strong,{children:"恢复全局日期、性能、时间和计时器 API 的原始实现。"})]}),"\n",(0,r.jsx)(n.p,{children:"比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  beforeAll(() => {\n    jest.useFakeTimers("modern");\n  });\n\n  afterAll(() => {\n    jest.useRealTimers();\n  });\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"定时器测试",children:["定时器测试",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定时器测试",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["当我们设置好环境后，还需要掌握 Jest 中测试定时器的方法：",(0,r.jsx)(n.strong,{children:"jest.advanceTimersByTime(msToRun)"}),"，它可以执行宏任务队列。"]}),"\n",(0,r.jsx)(n.p,{children:"换句话说，我们在开发中使用的 setTimeout() 、setInterval()、setImmediate() 都可通过 jest.advanceTimersByTime 进行对应的模拟操作。"}),"\n",(0,r.jsx)(n.p,{children:"测试用例："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  it("测试 targetTime", () => {\n    const { result } = renderHook(\n      (\n        props: any = {\n          targetTime: 3000,\n        }\n      ) => useCountDown(props)\n    );\n    expect(result.current[0]).toBe(3000);\n    expect(result.current[1].seconds).toBe(3);\n\n    act(() => {\n      jest.advanceTimersByTime(1000);\n    });\n    expect(result.current[0]).toBe(2000);\n    expect(result.current[1].seconds).toBe(2);\n  });\n'})}),"\n",(0,r.jsxs)(n.p,{children:["简要地说明下：首先我们通过 renderHook 设置 useCountDowen 的剩余时间还剩 3s，然后执行 ",(0,r.jsx)(n.code,{children:"jest.advanceTimersByTime(1000)"})," 模拟定时器执行一秒，所以此时剩余的时间还剩 2s。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意：jest.advanceTimersByTime 模拟是定时器的操作，所以它依然要放入 act 中才会有效果。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"设置系统时间",children:["设置系统时间",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设置系统时间",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 useCountDown 的设计中，有可能目标的时间小于当前时间，此时返回的应该为 0，但对应的测试中，我们想要自由地去设置当前的时间，这种情况下就可以使用 ",(0,r.jsx)(n.code,{children:"jest.setSystemTime"})," 的帮助。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"jest.setSystemTime(now?: number | Date)："})," 模拟程序中运行时的系统时钟，会影响当前时间，但它本身不会触发定时器等。"]}),"\n",(0,r.jsx)(n.p,{children:"举个小例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  beforeAll(() => {\n    jest.useFakeTimers("modern");\n    jest.setSystemTime(new Date("2020-01-01").getTime());\n  });\n  \n    it("测试 targetDate 小于当前时间", () => {\n    const { result } = renderHook(() =>\n      useCountDown({\n        targetDate: new Date("2021-01-01").getTime(),\n      })\n    );\n    expect(result.current[0]).toBe(0);\n  });\n'})}),"\n",(0,r.jsx)(n.p,{children:"在测试  targetDate 小于当前时间时，我们给的目标时间是 2021-01-01，是小于 2023 年的，但我们通过 jest.setSystemTime 更改后变为了 2020-01-01，此时测试的时间就会大于当前时间，也就是时间戳并不为 0。如："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"所以我们要想测试这个用例，比 2020-01-01 小就 OK 了，当然，如果不设置 jest.setSystemTime 会默认为当前时间。"}),"\n",(0,r.jsxs)(n.h1,{id:"usecss",children:["useCss",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecss",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useCss"}),"：用于动态地修改 CSS，是一种具备 ",(0,r.jsx)(n.strong,{children:"Css-in-JS"}),"（在 JSX/TSX 中书写 CSS）的 Hook。"]}),"\n",(0,r.jsx)(n.p,{children:"在实际开放中，我们的 css 通常是与 ts 分开的，并且每个组件的样式并不好复用，如果把 css 也弄成 js，那么在一定程度上也能帮助我们快速开发。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"问：在 JSX 中通过行内样式不也一样可以修改 CSS 吗？那么 useCss 的优势在哪？"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["答：首先 useCss 最终产出的是一个字符串，通过 ",(0,r.jsx)(n.code,{children:"className"})," 来设定 CSS，而非",(0,r.jsx)(n.code,{children:"style"}),"，优先级仍是 ",(0,r.jsx)(n.strong,{children:"style > useCSS"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["抛开区别而言，我们知道行内样式只能控制自身颜色，当我们需要",(0,r.jsx)(n.strong,{children:"媒体查询、伪选择器、控制子节点的 CSS"})," 等的操作都没有办法实现，而 useCss 可以帮助我们完美地实现。"]}),"\n",(0,r.jsx)(n.p,{children:"除此之外，还有以下几点比较重要的原因。"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"减少项目编译依赖"}),"：当我们的样式全部通过 ",(0,r.jsx)(n.strong,{children:"ts/js"})," 书写，那么就不需要",(0,r.jsx)(n.code,{children:"css/less/sass"})," 等文件的介入，从而减少项目的依赖、编译，这样我们的项目就变成了纯 js/ts 项目。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"组件化思想"}),"：useCss 的入参是一个对象，也就是说，我们可以将 css 也当成组件，模块化抽离出，这样无疑带来了莫大的好处。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"代码共享"}),"：可以非常轻松地在 JS 和 CSS 间共享常量、函数等。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"动态的设置前缀"}),"：可以有效避免臃肿的 CSS 代码。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"功能实现"}),"：动态变化的",(0,r.jsx)(n.strong,{children:"主题"}),"等。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"……"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"总而言之，引入 useCSS 是非常有必要的。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["在这里，通过 ",(0,r.jsx)(n.a,{href:"https://github.com/streamich/nano-css",target:"_blank",rel:"noopener noreferrer",children:"nano-css"})," 去实现 useCss 的功能，通过 useCreation 去优化，",(0,r.jsx)(n.code,{children:"cssToTree"})," 方法去生产对应的样式即可。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"代码演示："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { useEffect } from "react";\nimport { create, NanoRenderer } from "nano-css";\nimport { addon as addonCSSOM, CSSOMAddon } from "nano-css/addon/cssom";\nimport { addon as addonVCSSOM, VCSSOMAddon } from "nano-css/addon/vcssom";\nimport { cssToTree } from "nano-css/addon/vcssom/cssToTree";\nimport { useCreation } from "..";\n\ntype NoneType = NanoRenderer & CSSOMAddon & VCSSOMAddon;\nconst nano = create() as NoneType;\naddonCSSOM(nano);\naddonVCSSOM(nano);\n\nlet counter = 0;\n// CSSProps 在下方介绍\nconst useCss = (css: CSSProps): string => {\n  const className = useCreation(\n    () => "domesy-hooks-css-" + (counter++).toString(36),\n    []\n  );\n  const sheet = useCreation(() => new nano.VSheet(), []);\n\n  useEffect(() => {\n    const tree = {};\n    cssToTree(tree, css, "." + className, "");\n    sheet.diff(tree);\n\n    return () => {\n      sheet.diff({});\n    };\n  }, []);\n\n  return className;\n};\n\nexport default useCss;\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"ts-类型",children:["TS 类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ts-类型",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 useCss 中，需要特别注意一点，就是 TS 的类型问题。因为它接收的参数是一个 css 对象，但它支持多层嵌套，换句话说，不管 css 这个下面有多少个对象，其类型都应该是 React.CSSProperties。"}),"\n",(0,r.jsx)(n.p,{children:"所以，CSSProps 的类型应该为："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"type CSSKey = keyof React.CSSProperties;\n\ntype CSSProps =\n  | React.CSSProperties\n  | {\n      [key: Exclude<string, CSSKey>]: CSSProps;\n    };\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"keyof 关键字："})," 可以获取一个对象接口的所有 ",(0,r.jsx)(n.code,{children:"key"})," 值，用于检查对象上的键是否存在。如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface Props { \n    name: string;\n    age: number;\n}\n\ntype PropsKey = keyof Props; //包含 name， age\n\nconst res:PropsKey = 'name' // ok\nconst res1:PropsKey = 'tel' // error\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exclude<T, U> :"})," 将 T 类型中的 U 类型剔除。如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'type info = "name" | "age" | "sex";\ntype info1 = "name" | "age";\ntype infoProps = Exclude<info, info1> // "sex"\n'})}),"\n",(0,r.jsx)(n.p,{children:"了解完 keyof 和 Exclude 后，回过头来看 CSSProps 的类型就会明了很多，如此一来就能解决 css 的类型问题。"}),"\n",(0,r.jsxs)(n.h2,{id:"使用示例",children:["使用示例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用示例",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'import { useCss } from "../../hooks";\n\nconst Index = () => {\n  const classDiv = useCss({\n    color: "red",\n    "&:hover": {\n      color: "blue",\n    },\n  });\n\n  const classP = useCss({\n    p: {\n      color: "green",\n      "&:nth-of-type(2)": {\n        color: "rebeccapurple",\n      },\n    },\n  });\n\n  return (\n    <>\n      <div className={classDiv}>\n        鼠标放上来： 大家好，我是小杜杜，一起玩转Hooks吧！\n      </div>\n      <div className={classP}>\n        <p>CSS-in-JS</p>\n        <p>控制div下p标签的字体颜色</p>\n        <p style={{ color: "pink" }}>我是行内样式</p>\n      </div>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"useCss 的单元测试："})}),"\n",(0,r.jsx)(n.p,{children:"针对 CSS 的这种 Hooks 该如何测试，是不是需要设置一个 div，设置完后，再去验证 div 的字体颜色呢？"}),"\n",(0,r.jsx)(n.p,{children:"不，测试是代码的逻辑，我们只需要传入 useCss 对应的参数，测试返回的类名即可，无需太过麻烦。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { renderHook } from "@testing-library/react";\nimport useCss from ".";\n\ndescribe("useCss", () => {\n  it("should be defined", () => {\n    expect(useCss).toBeDefined();\n  });\n\n  it("测试css", () => {\n    const { result } = renderHook(() => useCss({ color: "red" }));\n    expect(result.current).toBe("domesy-hooks-css-0");\n  });\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"结果："})}),"\n",(0,r.jsxs)(n.h1,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本小节介绍 useSelections、useCountDown、useCss 三个自定义 Hooks。首先通过单选、全选的实际场景封装出 useSelections，之后了解如何测试时间、定时器、修改系统时间等操作，最后将 CSS 与 JS 结合，以 css-in-js 的方式去书写项目中样式。"}),"\n",(0,r.jsx)(n.p,{children:"通过三节的内容，相信 90% Hooks 的单元测试都能轻松解决，总体来说，单元测试的逻辑与自定义 Hooks 的逻辑不同，单元测试更趋向于“步骤”，需要去模拟各种场景，从而达到预期的效果。"}),"\n",(0,r.jsx)(n.p,{children:"下一节，我们进行常用的 Hooks 开发。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F7.%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%20Hooks%20%E4%B9%8B%20Jest%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9C%BA%E6%99%AF%E7%B1%BB%20Hooks.md"]={toc:[{text:"targetTime 和 onEnd",id:"targettime-和-onend",depth:2},{text:"单元测试：日期测试",id:"单元测试日期测试",depth:2},{text:"定时器测试",id:"定时器测试",depth:2},{text:"设置系统时间",id:"设置系统时间",depth:2},{text:"TS 类型",id:"ts-类型",depth:2},{text:"使用示例",id:"使用示例",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);