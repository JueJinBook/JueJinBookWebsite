"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["73318"],{144040:function(n,e,o){o.r(e),o.d(e,{default:()=>x});var s=o(552676),r=o(740453);let i=o.p+"static/image/22c79df2376f82c5c6f2f351755fb5da.aa6b81c9.png",t=o.p+"static/image/dc60de5e0973f2188e26438bffd6c4b3.1d8e0b04.png",c=o.p+"static/image/a588c69ef9058e8d1779dc9a246a98cc.6dcfc61f.png",a=o.p+"static/image/ec0c3939b6b22335f88b63e6a1c05174.11ee0a34.png",l=o.p+"static/image/a2b233abbb8e22dbbb18f1f1296cb5b0.d52c6ea9.png",p=o.p+"static/image/40fdc7359fd03ac47dc956c8d1acf07a.2f1dcabd.png",m=o.p+"static/image/f18b26a258a055b20cf0693423e805b5.0d9ebd94.png";function h(n){let e=Object.assign({p:"p",img:"img",blockquote:"blockquote",pre:"pre",code:"code",a:"a",ul:"ul",li:"li",h2:"h2"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"上一节课我们讲解了 iframe 中的 Cookie 携带情况，本课程以 Web Componets 为例讲解 Ajax 请求中的 Cookie 处理。在 Web Componets 方案中，虽然主子应用处于同一个 Host 地址，但是子应用的服务端此时可能有自己的服务端，因此可以重点查看一下 Ajax 请求在跨域时的 Cookie 携带情况："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"温馨提示：上述情况是否有方法可以使微应用 A 和 B 不产生跨域请求？"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"回顾一下 Web Componets 的微前端示例，目录结构如下所示："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"├── public                  # 托管的静态资源目录\n│   ├── main/               # 主应用资源目录                        \n│   │   └── index.html                                        \n│   └── micro/              # 微应用资源目录\n│        ├── micro1.css   \n│        ├── micro1.js    \n│        ├── micro2.css         \n│        └── micro2.js      \n├── config.js               # 公共配置\n├── main-server.js          # 主应用服务\n└── micro-server.js         # 微应用服务\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,s.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/web-components-cookie",target:"_blank",rel:"noopener noreferrer",children:"demo/web-components-cookie"})," 分支获取。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"为了模拟跨域的 Ajax 请求情况，可以使用 iHosts 进行域名映射，我们希望实现如下功能："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["在主应用中使用 iHosts 进行域名映射，将 ",(0,s.jsx)(e.code,{children:"ziyi.com"})," 映射到本地 IP 地址"]}),"\n",(0,s.jsx)(e.li,{children:"子应用仍然保留原来的 IP 地址访问，从而和主应用形成跨域和跨站"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["iHosts 的配置保持不变，",(0,s.jsx)(e.code,{children:"ziyi.com"})," 可以映射到本地的 IP 地址："]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"在之前方案的基础上，使微应用新增跨站的 Ajax 请求："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// micro1.js\n// micro2.js 同理\nclass MicroApp1Element extends HTMLElement {\n  constructor() {\n    super();\n  }\n  \n  connectedCallback() {\n    console.log(`[micro-app-1]：执行 connectedCallback 生命周期回调函数`);\n    this.mount();\n  }\n\n  disconnectedCallback() {\n    console.log(`[micro-app-1]：执行 disconnectedCallback 生命周期回调函数`);\n    this.unmount();\n  }\n\n  mount() {\n    const $micro = document.createElement("h1");\n    $micro.textContent = "微应用1";\n    this.appendChild($micro);\n\n    // 新增 Ajax 请求，用于请求子应用服务\n    // 需要注意 micro1.js 动态加载在主应用 ziyi.com:4000 下，因此是跨站请求\n    \n    // 如果先发起 micro1.js 的 Ajax 请求，希望可以响应子应用服务端的 Cookie\n    // 再次发起 micro2.js 的同地址的 Ajax 请求，此时希望请求头中可以携带 Cookie\n    // 这种情况可用于登录态的免登 Cookie 设计\n    window\n      .fetch("http://30.120.112.54:3000/cors", {\n        method: "post",\n        // 允许在请求时携带 Cookie\n        // https://developer.mozilla.org/zh-CN/docs/Web/API/Request/credentials\n        credentials: "include"\n      })\n      .then((res) => res.json())\n      .then(() => {})\n      .catch((err) => {\n        console.error(err);\n      });\n  }\n\n  unmount() {}\n}\n\nwindow.customElements.define("micro-app-1", MicroApp1Element);\n'})}),"\n",(0,s.jsx)(e.p,{children:"为了使得微应用可以支持跨站请求，需要在服务端进行额外的跨域配置，如下所示："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// main-server.js\nimport express from "express";\nimport path from "path";\nimport morgan from "morgan";\nimport config from "./config.js";\nimport cookieParser from "cookie-parser";\nconst app = express();\nconst { port, host } = config;\n\n// 打印请求日志\napp.use(morgan("dev"));\n\n// cookie 中间件\napp.use(cookieParser());\n\napp.use(express.static(path.join("public", "main")));\n\napp.post("/microapps", function (req, res) {\n\n  console.log("main cookies: ", req.cookies);\n\n  // 设置一个响应的 Cookie 数据\n  res.cookie("main-app", true);\n\n  res.json([\n    {\n      name: "micro1",\n      id: "micro1",\n      customElement: "micro-app-1",\n      script: `http://${host}:${port.micro}/micro1.js`,\n      style: `http://${host}:${port.micro}/micro1.css`,\n      prefetch: true,\n    },\n    {\n      name: "micro2",\n      id: "micro2",\n      customElement: "micro-app-2",\n      script: `http://${host}:${port.micro}/micro2.js`,\n      style: `http://${host}:${port.micro}/micro2.css`,\n      prefetch: true,\n    },\n  ]);\n});\n\napp.listen(port.main, host);\nconsole.log(`server start at http://${host}:${port.main}/`);\n\n\n// micro-server.js\nimport express from "express";\nimport morgan from "morgan";\nimport path from "path";\nimport cookieParser from "cookie-parser";\nimport config from "./config.js";\nconst app = express();\nconst { port, host } = config;\n\napp.use(morgan("dev"));\n\n// cookie 中间件\napp.use(cookieParser());\n\n// 设置支持跨域请求头\n// 示例设置了所有请求的跨域配置，也可以对单个请求进行跨域设置\napp.use((req, res, next) => {\n  // 跨域请求中涉及到 Cookie 信息传递时值不能为 *，必须是具体的主应用地址\n  // 这里的 ziyi.com 使用 iHosts 映射到本地 IP 地址\n  res.header("Access-Control-Allow-Origin", `http://ziyi.com:${port.main}`);\n  res.header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");\n  res.header("Allow", "GET, POST, OPTIONS");\n  // 允许跨域请求时携带 Cookie\n  // https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials\n  res.header("Access-Control-Allow-Credentials", true);\n  next();\n});\n\napp.use(\n  express.static(path.join("public", "micro"), {\n    etag: true,\n    lastModified: true,\n  })\n);\n\napp.post("/cors", function (req, res) {\n\n  // 打印子应用的 Cookie 携带情况\n  console.log("micro cookies: ", req.cookies);\n\n  // 设置一个响应的 Cookie 数据\n  res.cookie("micro-app", true);\n  res.json({\n    hello: "true",\n  });\n});\n\napp.listen(port.micro, host);\nconsole.log(`server start at http://${host}:${port.micro}/`);\n'})}),"\n",(0,s.jsx)(e.p,{children:"启动主应用和子应用的服务进行 Ajax 请求用于观察是否携带 Cookie ，如下所示："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"在上述示例中，我们得到如下结果："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"主应用服务端成功设置 Cookie，再次刷新页面时前端的请求会自动携带上 Cookie 信息（观察服务端的 Cookie 打印信息）"}),"\n",(0,s.jsx)(e.li,{children:"子应用进行跨域请求时无法成功设置 Cookie"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:'在上述示例中，我们希望两个微应用的第一次 Ajax 请求可以响应服务端的 Cookie 信息，而第二次的 Ajax 请求可以携带第一次 Ajax 请求响应的 Cookie 信息，但是通过测试发现第二次 Ajax 请求并没有携带 Cookie 信息，设置 Cookie 的警告信息基本上和 iframe 中的跨站相同：This Set-Cookie didn\'t specify a "SameSite" attribute and was default to "SameSite=Lax"， and was blocked because it came from a cross-site response which was not the response to a top-level navigation. The Set-Cookie had to have been set with "SameSite=None" to enable cross-site usage. This Set-Cookie was blocked because it had the "Secure" attribute but was not received over a secure connection. This Set-Cookie was blocked because it was not sent over a secure-connection and would have overwritten a cookie with Secure attribute.'}),"\n",(0,s.jsx)(e.p,{children:"这里和 iframe 方案中的跨站情况类似，需要设置 Cookie 的 SameSite 和 Secure 属性并修改成 HTTPS 协议。为了支持 HTTPS 协议，除了使用 iframe 示例中的 Ngrok，最基本的方式是提供 Nginx 反向代理，在这里可以设置一个反向代理的方案，如下所示："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["在主应用中使用 iHosts 进行域名映射，将 ",(0,s.jsx)(e.code,{children:"ziyi.com"})," 映射到本地 IP 地址，映射完成后进行 Nginx 反向代理，使其支持 HTTPS 协议"]}),"\n",(0,s.jsx)(e.li,{children:"子应用和主应用跨站，为了支持 HTTPS 协议，也需要进行 Nginx 反向代理"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"为了使用 Nginx 进行反向代理，首先需要使用 Homebrew 进行安装："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# 9.方案了解：Ajax Cookie\nbrew install nginx\n\n# 安装信息省略\n# ...\n# 打印\nDocroot is: /opt/homebrew/var/www\n\n# 打印信息告知 nginx 的配置文件地址，注意修改该配置后需要重启 nginx 服务\nThe default port has been set in /opt/homebrew/etc/nginx/nginx.conf to 8080 so that\nnginx can run without sudo.\n\nnginx will load all files in /opt/homebrew/etc/nginx/servers/.\n\nTo restart nginx after an upgrade:\n  # 打印信息告知在后台重启 Nginx 服务的执行命令\n  brew services restart nginx\nOr, if you don't want/need a background service you can just run:\n  /opt/homebrew/opt/nginx/bin/nginx -g daemon off;\n==> Summary\n\uD83C\uDF7A  /opt/homebrew/Cellar/nginx/1.23.4: 26 files, 2.2MB\n==> Running `brew cleanup nginx`...\nDisable this behaviour by setting HOMEBREW_NO_INSTALL_CLEANUP.\nHide these hints with HOMEBREW_NO_ENV_HINTS (see `man brew`).\n==> Caveats\n==> nginx\nDocroot is: /opt/homebrew/var/www\n\nThe default port has been set in /opt/homebrew/etc/nginx/nginx.conf to 8080 so that\nnginx can run without sudo.\n\nnginx will load all files in /opt/homebrew/etc/nginx/servers/.\n\nTo restart nginx after an upgrade:\n  brew services restart nginx\nOr, if you don't want/need a background service you can just run:\n  /opt/homebrew/opt/nginx/bin/nginx -g daemon off;\n"})}),"\n",(0,s.jsxs)(e.p,{children:["安装后可以简单进行 Nginx 反向代理的测试，这里尝试使用 4001 端口代理主应用的 4000 端口，需要修改 Nginx 的配置并重新启动 Nginx 服务。从打印信息知道配置文件在 ",(0,s.jsx)(e.code,{children:"/opt/homebrew/etc/nginx/nginx.conf"})," 中，打开配置文件进行简单的代理配置："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"#user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        # 设置主应用的代理端口为 4001\n        listen       4001;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            # root   html;\n            # index  index.html index.htm;\n            # 代理到主应用的 Node 地址\n            proxy_pass 'http://30.120.112.54:4000'\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ .php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ .php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache's document root\n        # concurs with nginx's one\n        #\n        #location ~ /.ht {\n        #    deny  all;\n        #}\n    }\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n    # HTTPS server\n    #\n    #server {\n    #    listen       443 ssl;\n    #    server_name  localhost;\n\n    #    ssl_certificate      cert.pem;\n    #    ssl_certificate_key  cert.key;\n\n    #    ssl_session_cache    shared:SSL:1m;\n    #    ssl_session_timeout  5m;\n\n    #    ssl_ciphers  HIGH:!aNULL:!MD5;\n    #    ssl_prefer_server_ciphers  on;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n    include servers/*;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"需要注意在重新启动 Nginx 服务之前，可以先进行配置检查，如下所示："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# 执行检查\nsudo nginx -t\n# 打印信息\nnginx: [emerg] unexpected "}" in /opt/homebrew/etc/nginx/nginx.conf:56\nnginx: configuration file /opt/homebrew/etc/nginx/nginx.conf test failed\n'})}),"\n",(0,s.jsxs)(e.p,{children:["一般遇到上述情况主要是 ",(0,s.jsx)(e.code,{children:"}"})," 的上一行出现问题 ，仔细观察发现上一行没有以 ",(0,s.jsx)(e.code,{children:";"})," 结尾："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"location / {\n    # root   html;\n    # index  index.html index.htm;\n    # 代理到主应用的地址，结尾处增加分号 ；\n    proxy_pass 'http://30.120.112.54:4000';\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"重新进行 Nginx 配置的检测："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# 执行\nsudo nginx -t\n# 打印\nnginx: the configuration file /opt/homebrew/etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /opt/homebrew/etc/nginx/nginx.conf test is successful\n"})}),"\n",(0,s.jsx)(e.p,{children:"此时可以使用 brew 提供的命令在后台重新启动 Nginx 服务："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"# 使用 brew 推荐的 nginx 重启命令\n# 建议使用 Nginx 自带的命令，如果遇到代理失败，建议杀掉 Nginx 进程重新尝试\nbrew services restart nginx\n\n# 打印\nStopping `nginx`... (might take a while)\n==> Successfully stopped `nginx` (label: homebrew.mxcl.nginx)\n==> Successfully started `nginx` (label: homebrew.mxcl.nginx)\n"})}),"\n",(0,s.jsx)(e.p,{children:"启动成功后可以通过 4001 端口进行访问，发现代理成功："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(e.p,{children:["接下来我们需要将 HTTP 协议改成 HTTPS 协议进行访问，为了在开发态支持 HTTPS 协议，可以使用 ",(0,s.jsx)(e.a,{href:"https://github.com/FiloSottile/mkcert",target:"_blank",rel:"noopener noreferrer",children:"mkcert"})," 生成本地 CA 证书："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:'# 安装 mkcert\nbrew install mkcert\n\n# 执行以下命令，生成本地 CA 证书\n# 进入项目目录\n# mkcert example.com "*.example.com" example.test localhost 127.0.0.1 ::1\nmkcert ziyi.com 30.120.112.54 localhost 127.0.0.1 ::1\n\n# 打印信息\n# ziyi.com 会在 iHosts 中进行 IP 映射\nCreated a new certificate valid for the following names \uD83D\uDCDC\n - "ziyi.com"\n - "30.120.112.54"\n - "localhost"\n - "127.0.0.1"\n - "::1"\n\nThe certificate is at "./ziyi.com+4.pem" and the key at "./ziyi.com+4-key.pem" ✅\n\nIt will expire on 19 July 2025 \uD83D\uDDD3\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"温馨提示：可以额外了解一下本地 CA 证书和自签名证书的区别？"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"生成本地的 CA 证书后将 Niginx 的配置进行 HTTPS 更改（Nginx 配置文件提供了示例，打开注释进行配置即可）："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"#user  nobody;\nworker_processes  1;\n\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#pid        logs/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    # server {\n    #     # 设置主应用的代理端口为 4001\n    #     listen       4001;\n    #     server_name  localhost;\n\n    #     #charset koi8-r;\n\n    #     #access_log  logs/host.access.log  main;\n\n    #     location / {\n    #         # root   html;\n    #         # index  index.html index.htm;\n    #         # 代理到主应用的地址\n    #         proxy_pass 'http://30.120.112.54:4000';\n    #     }\n\n    #     #error_page  404              /404.html;\n\n    #     # redirect server error pages to the static page /50x.html\n    #     #\n    #     error_page   500 502 503 504  /50x.html;\n    #     location = /50x.html {\n    #         root   html;\n    #     }\n\n    #     # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #     #\n    #     #location ~ .php$ {\n    #     #    proxy_pass   http://127.0.0.1;\n    #     #}\n\n    #     # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #     #\n    #     #location ~ .php$ {\n    #     #    root           html;\n    #     #    fastcgi_pass   127.0.0.1:9000;\n    #     #    fastcgi_index  index.php;\n    #     #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n    #     #    include        fastcgi_params;\n    #     #}\n\n    #     # deny access to .htaccess files, if Apache's document root\n    #     # concurs with nginx's one\n    #     #\n    #     #location ~ /.ht {\n    #     #    deny  all;\n    #     #}\n    # }\n\n    # another virtual host using mix of IP-, name-, and port-based configuration\n    #\n    #server {\n    #    listen       8000;\n    #    listen       somename:8080;\n    #    server_name  somename  alias  another.alias;\n\n    #    location / {\n    #        root   html;\n    #        index  index.html index.htm;\n    #    }\n    #}\n\n    # HTTPS server\n    # 使用 HTTPS 协议，代理到主应用\n    server {\n       listen       4001 ssl;\n       server_name  localhost;\n\n       ssl_certificate      /Users/zhuxiankang/Desktop/Github/micro-framework/ziyi.com+4.pem;\n       ssl_certificate_key  /Users/zhuxiankang/Desktop/Github/micro-framework/ziyi.com+4-key.pem;\n       \n       ssl_session_cache    shared:SSL:1m;\n       ssl_session_timeout  5m;\n\n       ssl_ciphers  HIGH:!aNULL:!MD5;\n       ssl_prefer_server_ciphers  on;\n\n       location / {\n        #    root   html;\n        #    index  index.html index.htm;\n        proxy_pass 'http://30.120.112.54:4000';\n       }\n    }\n\n    # HTTPS server\n    # 使用 HTTPS 协议，代理到微应用\n    server {\n       listen       3001 ssl;\n       server_name  localhost;\n       \n       ssl_certificate      /Users/zhuxiankang/Desktop/Github/micro-framework/ziyi.com+4.pem;\n       ssl_certificate_key  /Users/zhuxiankang/Desktop/Github/micro-framework/ziyi.com+4-key.pem;\n\n       ssl_session_cache    shared:SSL:1m;\n       ssl_session_timeout  5m;\n\n       ssl_ciphers  HIGH:!aNULL:!MD5;\n       ssl_prefer_server_ciphers  on;\n\n       location / {\n        #    root   html;\n        #    index  index.html index.htm;\n        proxy_pass 'http://30.120.112.54:3000';\n       }\n    }\n    include servers/*;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"更改服务端代码和前端代码（前端代码不再展示，只需要更改请求的地址即可）："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// main-server.js\nimport express from "express";\nimport path from "path";\nimport morgan from "morgan";\nimport config from "./config.js";\nimport cookieParser from "cookie-parser";\nconst app = express();\nconst { port, host } = config;\n\napp.use(morgan("dev"));\n\n// cookie 中间件\napp.use(cookieParser());\n\napp.use(express.static(path.join("public", "main")));\n\napp.post("/microapps", function (req, res) {\n    \n  // 再次刷新页面时观察 Cookie 的携带情况\n  console.log("main cookies: ", req.cookies);\n\n  // 设置一个响应的 Cookie 数据\n  res.cookie("main-app", true);\n\n  res.json([\n    {\n      name: "micro1",\n      id: "micro1",\n      customElement: "micro-app-1",\n      // 更改微应用资源的加载地址，使用 Nginx 的代理地址\n      script: `https://${host}:3001/micro1.js`,\n      style: `https://${host}:3001/micro1.css`,\n      prefetch: true,\n    },\n    {\n      name: "micro2",\n      id: "micro2",\n      customElement: "micro-app-2",\n      script: `https://${host}:3001/micro2.js`,\n      style: `https://${host}:3001/micro2.css`,\n      prefetch: true,\n    },\n  ]);\n});\n\n// 启动 Node 服务\napp.listen(port.main, host);\nconsole.log(`server start at http://${host}:${port.main}/`);\n\n\n// micro-server.js\nimport express from "express";\nimport morgan from "morgan";\nimport path from "path";\nimport cookieParser from "cookie-parser";\nimport config from "./config.js";\nconst app = express();\nconst { port, host } = config;\n\napp.use(morgan("dev"));\n\n// cookie 中间件\napp.use(cookieParser());\n\napp.use((req, res, next) => {\n  // 跨域请求中涉及到 Cookie 信息传递，值不能为 *，必须是具体的地址信息\n  // 跨域白名单配置为主应用的 Nginx 代理地址\n  res.header("Access-Control-Allow-Origin", `https://ziyi.com:4001`);\n  res.header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");\n  res.header("Allow", "GET, POST, OPTIONS");\n  // 允许客户端发送跨域请求时携带 Cookie\n  res.header("Access-Control-Allow-Credentials", true);\n  next();\n});\n\napp.use(\n  express.static(path.join("public", "micro"), {\n    etag: true,\n    lastModified: true,\n  })\n);\n\napp.post("/cors", function (req, res) {\n    \n  // 用于观察二次请求时的 Cookie 的携带情况\n  console.log(\'micro cookies: \', req.cookies);\n\n  // 增加 SameSite 和 Secure 属性，从而使浏览器支持 iframe 子应用的跨站携带 Cookie\n  // 注意 Secure 需要 HTTPS 协议的支持\n  const cookieOptions = { sameSite: "none", secure: true };\n  // 设置一个响应的 Cookie 数据\n  res.cookie("micro-app", true, cookieOptions);\n  res.json({\n    hello: "true",\n  });\n});\n\napp.listen(port.micro, host);\nconsole.log(`server start at http://${host}:${port.micro}/`);\n'})}),"\n",(0,s.jsx)(e.p,{children:"启动主应用和子应用的服务后可以重点观察 Cookie 的携带情况，如下所示："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"在上述示例中，我们得到如下结果："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"主应用服务端成功设置 Cookie，再次刷新页面时前端的请求会自动携带上 Cookie 信息（观察服务端的 Cookie 打印信息）"}),"\n",(0,s.jsx)(e.li,{children:"Chrome 浏览器采用跨域 Ajax 请求进行设计时，默认无法携带 Cookie，需要使用 HTTPS 协议和服务端 Cookie 属性（SameSite 和 Secure）设置才行"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在 Web Components 的 Ajax 请求示例中，我们发现跨站的情况下和 iframe 方案情况相似，需要服务端进行 Cookie 配置和跨域支持，除此之外，在前端的 Ajax 请求中还要配置允许携带 Cookie 的属性 ",(0,s.jsx)(e.code,{children:"credentials"}),"。"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}let x=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F9.%E6%96%B9%E6%A1%88%E4%BA%86%E8%A7%A3%EF%BC%9AAjax%20Cookie.md"]={toc:[{text:"小结",id:"小结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);