"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["97445"],{516310:function(e,n,s){e.exports=s.p+"static/image/050e604b7f4adbf9d5456cf9a7ec638e.8597a095.webp"},729769:function(e,n,s){e.exports=s.p+"static/image/30115dccc4d28c70ea6fd3dceca02b53.9fea1d72.webp"},444203:function(e,n,s){e.exports=s.p+"static/image/569abfc2882c0e9a08d60b02874a8073.3649b37b.webp"},113430:function(e){e.exports="data:image/webp;base64,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"},816077:function(e,n,s){e.exports=s.p+"static/image/932581210f473121ed32e8a3a17cb465.ca3a4075.webp"},39590:function(e,n,s){e.exports=s.p+"static/image/a9e4e547f782b5be7ea0f10c64d82a1f.dd46c0dd.webp"},579620:function(e,n,s){s.r(n),s.d(n,{default:()=>p});var r=s(552676),t=s(740453),c=s(39590),l=s(444203),a=s(816077),d=s(113430),i=s(516310),o=s(729769);function h(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",strong:"strong",pre:"pre",code:"code",ul:"ul",li:"li",img:"img",h4:"h4"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"14优化篇-细节处理持续",children:["14.优化篇-细节处理（持续）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14优化篇-细节处理持续",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章节，我将继续补充一些 React 开发中细节问题的解决方案。"}),"\n",(0,r.jsxs)(n.h2,{id:"二-细节",children:["二 细节",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-细节",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"1-react中防抖和节流",children:["1 React中防抖和节流",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-react中防抖和节流",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"防抖"})}),"\n",(0,r.jsx)(n.p,{children:"防抖和节流在 React 应用中是很常用的，防抖很适合 React 表单的场景，比如点击按钮防抖，search 输入框。举一个简单的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default class Index extends React.Component{\n    constructor(props){\n        super(props)\n    }\n    handleClick= () => {\n        console.log('点击事件-表单提交-调用接口')\n    }\n    handleChange= (e) => {\n        console.log('搜索框-请求数据')\n    }\n    render(){\n        return <div>\n            <input  placeholder=\"搜索表单\" onChange={this.handleChange}  /><br/>\n            <button onClick={ this.handleClick } > 点击 </button>\n        </div>\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如上，当点击按钮的时候，向服务端发起数据交互；输入 input 时候，同样会向服务端进行数据交互，请求搜索的数据。对于如上的情况如果不做任何优化处理的话，连续点击按钮，或者 input 输入内容的时候，就会出现这种情况。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"1.gif"})}),"\n",(0,r.jsx)(n.p,{children:"如上，会频繁和服务端交互，很显然这种情况是不符合常理的。所以需要防抖处理。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"constructor(props){\n    super(props)\n    this.handleClick = debounce(this.handleClick,500)  /* 防抖 500 毫秒  */\n    this.handleChange = debounce(this.handleChange,300) /* 防抖 300 毫秒 */\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"2.gif"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"节流"})}),"\n",(0,r.jsx)(n.p,{children:"节流函数一般也用于频繁触发的事件中，比如监听滚动条滚动。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'export default function Index(){\n    /* useCallback 防止每次组件更新都重新绑定节流函数  */\n    const handleScroll = React.useCallback(throttle(function(){\n        /* 可以做一些操作，比如曝光上报等 */\n    },300))\n    return <div className="scrollIndex"  onScroll={handleScroll} >\n        <div className="scrollContent" >hello,world</div>\n   </div>\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如上将监听滚动函数做节流处理，300 毫秒触发一次。用 useCallback 防止每一次组件更新重新绑定节流函数。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"防抖节流总结："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"防抖函数一般用于表单搜索，点击事件等场景，目的就是为了防止短时间内多次触发事件。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"节流函数一般为了降低函数执行的频率，比如滚动条滚动。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-按需引入",children:["2 按需引入",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-按需引入",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["按需引入本质上是为项目瘦身，开发者在做 React 项目的时候，会用到 antd 之类的 UI 库，值得思考的一件事是，开发者如果只是用到了 antd 中的个别组件，比如 Button，就要把整个样式库引进来，打包就会发现，体积因为引入了整个样式文件大了很多。所以可以通过 ",(0,r.jsx)(n.code,{children:".babelrc"})," 实现按需引入。"]}),"\n",(0,r.jsx)(n.p,{children:"瘦身前体积："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"pre"})}),"\n",(0,r.jsx)(n.p,{children:".babelrc 增加对 antd 样式按需引入。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'["import", {\n    "libraryName":\n    "antd",\n    "libraryDirectory": "es",\n    "style": true\n}]\n'})}),"\n",(0,r.jsx)(n.p,{children:"瘦身后体积："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"after"})}),"\n",(0,r.jsxs)(n.h3,{id:"3-react动画",children:["3 React动画",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-react动画",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"React 写动画也是一个比较棘手的问题。高频率的 setState 会给应用性能带来挑战，这种情况在 M 端更加明显，因为 M 端的渲染能力受到手机性能的影响较大。所以对 React 动画的处理要格外注意。我这里总结了三种 React 使用动画的方式，以及它们的权重。"}),"\n",(0,r.jsxs)(n.h4,{id:"-首选动态添加类名",children:["① 首选：动态添加类名",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-首选动态添加类名",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"第一种方式是通过 transition，animation 实现动画然后写在 class 类名里面，通过动态切换类名，达到动画的目的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n    const [ isAnimation , setAnimation ] = useState(false)\n    return <div>\n        <button onClick={ ()=> setAnimation(true)  } >改变颜色</button>\n        <div className={ isAnimation ? 'current animation' : 'current'  } ></div>\n    </div>\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:".current{\n    width: 50px;\n    height: 50px;\n    border-radius: 50%;\n    background: #fff;\n    border: 1px solid #ccc;\n}\n.animation{\n    animation: 1s changeColor;\n    background:yellowgreen;\n}\n@keyframes changeColor {\n    0%{background:#c00;}\n    50%{background:orange;}\n    100%{background:yellowgreen;}\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"效果"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"3.gif"})}),"\n",(0,r.jsx)(n.p,{children:"这种方式是我最优先推荐的方式，这种方式既不需要频繁 setState ，也不需要改变 DOM 。"}),"\n",(0,r.jsxs)(n.h4,{id:"-其次操纵原生-dom",children:["② 其次：操纵原生 DOM",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-其次操纵原生-dom",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果第一种方式不能满足要求的话，或者必须做一些 js 实现复杂的动画效果，那么可以获取原生 DOM ，然后单独操作 DOM 实现动画功能，这样就避免了 setState  改变带来 React Fiber 深度调和渲染的影响。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n    const dom = useRef(null)\n    const changeColor = ()=>{\n        const target =  dom.current\n        target.style.background = '#c00'\n        setTimeout(()=>{\n            target.style.background = 'orange'\n            setTimeout(()=>{\n                target.style.background = 'yellowgreen'\n            },500)\n        },500)\n    }\n    return <div>\n        <button onClick={ changeColor } >改变颜色</button>\n        <div className='current' ref={ dom }  ></div>\n    </div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"同样达到如上的效果"}),"\n",(0,r.jsxs)(n.h4,{id:"-再者setstate--css3",children:["③ 再者：setState + css3",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-再者setstate--css3",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果 ① 和 ② 都不能满足要求，一定要使用 setState 实时改变DOM元素状态的话，那么尽量采用 css3 ， css3 开启硬件加速，使 GPU (Graphics Processing Unit) 发挥功能，从而提升性能。"}),"\n",(0,r.jsx)(n.p,{children:"比如想要改变元素位置 left ，top 值，可以换一种思路通过改变 transform: translate，transform 是由 GPU 直接控制渲染的，所以不会造成浏览器的重排。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n    const [ position , setPosition ] = useState({ left:0,top:0 })\n    const changePosition = ()=>{\n        let time = 0\n        let timer = setInterval(()=>{\n            if(time === 30) clearInterval(timer)\n            setPosition({ left:time * 10 , top:time * 10 })\n            time++ \n        },30)\n    }\n    const { left , top } = position\n    return <div>\n         <button onClick={ changePosition } >改变位置</button>\n         <div className='current' style={{ transform:`translate(${ left }px,${ top }px )` }}  ></div>\n    </div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"4.gif"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-及时清除定时器延时器监听器",children:["4 及时清除定时器/延时器/监听器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-及时清除定时器延时器监听器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果在 React 项目中，用到了定时器，延时器和事件监听器，注意要在对应的生命周期，清除它们，不然可能会造成内部泄露的情况。"}),"\n",(0,r.jsx)(n.p,{children:"类组件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default class Index extends React.Component{\n    current = null\n    poll=()=>{} /* 轮训 */\n    handleScroll=()=>{} /* 处理滚动事件 */\n    componentDidMount(){\n       this.timer = setInterval(()=>{\n           this.poll() /* 2 秒进行一次轮训事件 */\n       },2000)\n       this.current.addEventListener('scroll',this.handleScroll)\n    }\n    componentWillUnmount(){\n       clearInterval(this.timer) /* 清除定时器 */\n       this.current.removeEventListener('scroll',this.handleScroll)\n    }\n    render(){\n        return <div ref={(node)=>this.current = node  }  >hello,let us learn React!</div>\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"在 componentWillUnmount 生命周期及时清除延时器和事件监听器。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"函数组件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n    const dom = React.useRef(null)\n    const poll = ()=>{}\n    const handleScroll = ()=>{}\n    useEffect(()=>{\n        let timer = setInterval(()=>{\n            poll() /* 2 秒进行一次轮训事件 */\n        },2000)\n        dom.current.addEventListener('scroll',handleScroll)\n        return function(){\n            clearInterval(timer)\n            dom.current.removeEventListener('scroll',handleScroll)\n        } \n    },[])\n    return <div ref={ dom }  >hello,let us learn React!</div>\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"在 useEffect 或者 useLayoutEffect 第一个参数 create 的返回函数 destory 中，做一些清除定时器/延时器的操作。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"5-合理使用state",children:["5 合理使用state",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-合理使用state",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["React 并不像 vue 那样响应式数据流。 在 vue 中有专门的 dep 做依赖收集，可以自动收集字符串模版的依赖项，只要没有引用的 data 数据， 通过 ",(0,r.jsx)(n.code,{children:"this.aaa = bbb"})," ，在 vue 中是不会更新渲染的。但是在 React 中只要触发 setState 或 useState ，如果没有渲染控制的情况下，组件就会渲染，暴露一个问题就是，如果视图更新不依赖于当前 state ，那么这次渲染也就没有意义。所以对于视图不依赖的状态，就可以考虑不放在 state 中。"]}),"\n",(0,r.jsx)(n.p,{children:"打个比方，比如想在滚动条滚动事件中，记录一个 scrollTop 位置，那么在这种情况下，用 state 保存 scrollTop 就没有任何意义而且浪费性能。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default class Index extends React.Component{\n    node = null\n    scrollTop = 0\n    handleScroll=()=>{\n        const {  scrollTop } = this.node \n        this.scrollTop = scrollTop\n    }\n    render(){\n        return <div ref={(node)=> this.node = node } onScroll={this.handleScroll} ></div>\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"上述把 scrollTop 直接绑定在 this 上，而不是通过 state 管理，这样好处是滚动条滚动不需要触发 setState ，从而避免了无用的更新。"}),"\n",(0,r.jsx)(n.p,{children:"对于函数组件，因为不存在组件实例，但是函数组件有 hooks ，所以可以通过一个 useRef 实现同样的效果。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n    const dom = useRef(null)\n    const scrollTop = useRef(0)\n    const handleScroll = ()=> {\n        scrollTop.current = dom.current.scrollTop\n    }\n    return   <div ref={ dom } onScroll={handleScroll} ></div>\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如上用 useRef ，来记录滚动条滚动时 scrollTop 的值。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"6-建议不要在-hooks-的参数中执行函数或者-new-实例",children:["6 建议不要在 hooks 的参数中执行函数或者 new 实例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-建议不要在-hooks-的参数中执行函数或者-new-实例",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["有一种场景是平时比较容易忽略的，就是在 ",(0,r.jsx)(n.code,{children:"hooks"})," 的参数中执行函数或者 new 实例，比如如下这样："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const hook1 = useRef(fn())\nconst hook2 = useRef(new Fn())\n"})}),"\n",(0,r.jsx)(n.p,{children:"不建议这么写。为什么呢？"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["首先函数每次 ",(0,r.jsx)(n.code,{children:"rerender"})," 都会执行 hooks ，那么在执行 hooks 函数的同时，也会执行函数的参数，比如上面的代码片段中的 ",(0,r.jsx)(n.code,{children:"fn()"})," 和 ",(0,r.jsx)(n.code,{children:"new Fn()"}),"，也就是每一次 rerender 都会执行 fn 或者是 new 一个实例。这可能不是开发者期望的，而执行函数，或创建实例也成了一种性能浪费，在一些极端情况下，可能会造成内存泄漏，比如在创建新的 dom 元素，但是没有进行有效的回收。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["在 hooks 原理章节讲到过，函数组件在",(0,r.jsx)(n.strong,{children:"初始化"}),"和",(0,r.jsx)(n.strong,{children:"更新"}),"流程中，会使用不同的 hooks 对象，还是以 ",(0,r.jsx)(n.code,{children:"useRef"})," 为例子，在初始化阶段用的是 ",(0,r.jsx)(n.code,{children:"mountRef"}),"函数，在更新阶段用的是 ",(0,r.jsx)(n.code,{children:"updateRef"}),"函数，开发者眼睛看见的是 ",(0,r.jsx)(n.code,{children:"useRef"}),"，在 React 底层却悄悄的替换成了不同的函数。 更重要的是大部分的 hooks 参数都作为",(0,r.jsx)(n.strong,{children:"初始化"}),"的参数，在更新阶段压根没有用到，那么传入的参数也就没有了意义，回到上述代码片段，",(0,r.jsx)(n.code,{children:"fn()"})," 和 ",(0,r.jsx)(n.code,{children:"new Fn()"}),"在更新阶段根本就没有被 ",(0,r.jsx)(n.code,{children:"useRef"}),"接收， 无辜的成了流浪者。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["还是以 ",(0,r.jsx)(n.code,{children:"useRef"})," 为例子，看一下它在不同阶段的真正面目。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"初始化"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function mountRef(initialValue) {\n  const hook = mountWorkInProgressHook();\n  const ref = {current: initialValue};\n  hook.memoizedState = ref;\n  return ref;\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"初始化的时候用到了 initialValue ，也就是第一个参数。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"更新阶段"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function updateRef(initialValue) {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"在更新阶段根本没有用到 initialValue。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"那么回到最初的目的上来，如果开发者真的想在 hooks 中，以函数组件执行结果或者是实例对象作为参数的话，那么应该怎么处理呢。这个很简单。比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const hook = useRef(null)\nif(!hook.current){\n  hook.current = new Fn()\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"三-总结",children:["三 总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章补充了前几章没有提到的优化点，实际开发中，还有很多细节，欢迎大家在留言区域补充，然后我统一添加到本章内容里。下一章将开始进入 React 原理篇。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}let p=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F14.%E4%BC%98%E5%8C%96%E7%AF%87-%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86%EF%BC%88%E6%8C%81%E7%BB%AD%EF%BC%89.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 细节",id:"二-细节",depth:2},{text:"1 React中防抖和节流",id:"1-react中防抖和节流",depth:3},{text:"2 按需引入",id:"2-按需引入",depth:3},{text:"3 React动画",id:"3-react动画",depth:3},{text:"① 首选：动态添加类名",id:"-首选动态添加类名",depth:4},{text:"② 其次：操纵原生 DOM",id:"-其次操纵原生-dom",depth:4},{text:"③ 再者：setState + css3",id:"-再者setstate--css3",depth:4},{text:"4 及时清除定时器/延时器/监听器",id:"4-及时清除定时器延时器监听器",depth:3},{text:"5 合理使用state",id:"5-合理使用state",depth:3},{text:"6 建议不要在 hooks 的参数中执行函数或者 new 实例",id:"6-建议不要在-hooks-的参数中执行函数或者-new-实例",depth:3},{text:"三 总结",id:"三-总结",depth:2}],title:"14.优化篇-细节处理（持续）",headingTitle:"14.优化篇-细节处理（持续）",frontmatter:{}}}}]);