"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["98935"],{992718:function(n,e,l){l.r(e),l.d(e,{default:()=>h});var d=l(552676),s=l(740453);let o=l.p+"static/image/951a1e644eb37152150affa0447fa6f5.16455195.webp",i=l.p+"static/image/ac5630ca40be1bde0ad9b43639a484c3.b04b6b8c.webp",r=l.p+"static/image/a6c8826ae352beddec46f5f12ce8f627.c3f0e1e2.webp",t=l.p+"static/image/33511f51e74b43ec677333cdb87a9411.0f502575.webp";function c(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",h3:"h3",strong:"strong",pre:"pre",code:"code",h4:"h4",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",img:"img"},(0,s.ah)(),n.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.h1,{id:"28实践篇-自定义弹窗",children:["28.实践篇-自定义弹窗",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#28实践篇-自定义弹窗",children:"#"})]}),"\n",(0,d.jsxs)(e.h2,{id:"一-前言",children:["一 前言",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"本章节，我们一起来设计一个自定义的弹窗组件，会包含如下知识点："}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"弹窗组件设计；"}),"\n",(0,d.jsx)(e.li,{children:"ReactDOM.createPortal 使用；"}),"\n",(0,d.jsx)(e.li,{children:"组件静态方法使用；"}),"\n",(0,d.jsx)(e.li,{children:"不依赖父组件实现挂载/卸载组件。"}),"\n"]}),"\n",(0,d.jsxs)(e.h2,{id:"二-设计思路",children:["二 设计思路",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二-设计思路",children:"#"})]}),"\n",(0,d.jsxs)(e.h3,{id:"1-建立目标",children:["1 建立目标",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-建立目标",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"要实现的具体功能下："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"编写的自定义 Modal 可以通过两种方式调用："})}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"第一种通过挂载组件方式，动态设置 visible 属性。"}),"\n"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"<Modal  title={'《React进阶实践指南》'}  visible={visible}  >\n    <div> hello,world </div>\n</Modal>\n"})}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"第二种通过 Modal 静态属性方法，控制 Modal 的显示/隐藏。"}),"\n"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:" Modal.show({ /* 自定义弹窗的显示 */\n    content:<p>确定购买《React进阶指南小册》吗</p>,\n    title:'《React进阶实践指南》',\n    onOk:()=>console.log('点击确定'),\n    onCancel:()=>console.log('点击取消'),\n    onClose:()=> Modal.hidden() /* 自定义弹窗的隐藏 */\n})\n"})}),"\n",(0,d.jsx)(e.p,{children:"如上，Modal.show 控制自定义弹窗的显示，可以通过 Modal.hidden 控制弹窗的隐藏，业务层不需要挂载组件。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"其他要求："})}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"自定义弹窗要有渐变的动画效果。"}),"\n"]}),"\n",(0,d.jsxs)(e.h3,{id:"2-设计思路",children:["2 设计思路",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-设计思路",children:"#"})]}),"\n",(0,d.jsxs)(e.h4,{id:"1-props的设定",children:["1 props的设定",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-props的设定",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"实现的 Modal 组件需要 props 配置项如下。"}),"\n",(0,d.jsxs)(e.table,{children:["\n",(0,d.jsxs)(e.thead,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsxs)(e.th,{children:[(0,d.jsx)(e.code,{children:"props"})," 属性"]}),"\n",(0,d.jsx)(e.th,{children:"属性描述"}),"\n",(0,d.jsx)(e.th,{children:"属性类型"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.tbody,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"visible"}),"\n",(0,d.jsx)(e.td,{children:"当前 modal 是否显示"}),"\n",(0,d.jsx)(e.td,{children:"boolean"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"onOk 回调函数"}),"\n",(0,d.jsx)(e.td,{children:"当点击确定按钮触发"}),"\n",(0,d.jsx)(e.td,{children:"function"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"onCancel 回调函数"}),"\n",(0,d.jsx)(e.td,{children:"当点击取消按钮触发"}),"\n",(0,d.jsx)(e.td,{children:"function"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"closeCb 回调函数"}),"\n",(0,d.jsx)(e.td,{children:"当弹窗完全关闭后触发"}),"\n",(0,d.jsx)(e.td,{children:"function"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"width"}),"\n",(0,d.jsx)(e.td,{children:"弹窗宽度"}),"\n",(0,d.jsx)(e.td,{children:"number"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"okTest"}),"\n",(0,d.jsx)(e.td,{children:"确定按钮文案"}),"\n",(0,d.jsx)(e.td,{children:"string"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"cancelText"}),"\n",(0,d.jsx)(e.td,{children:"取消按钮文案"}),"\n",(0,d.jsx)(e.td,{children:"string"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"title"}),"\n",(0,d.jsx)(e.td,{children:"Modal标题"}),"\n",(0,d.jsx)(e.td,{children:"string"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"footer"}),"\n",(0,d.jsx)(e.td,{children:"自定义底部内容"}),"\n",(0,d.jsx)(e.td,{children:"React Element"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"children"}),"\n",(0,d.jsx)(e.td,{children:"Modal 内容（插槽模式）"}),"\n",(0,d.jsx)(e.td,{children:"React Element"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"content"}),"\n",(0,d.jsx)(e.td,{children:"Modal 内容（ props 属性模式）"}),"\n",(0,d.jsx)(e.td,{children:"React Element"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h4,{id:"2-组件之外渲染",children:["2 组件之外渲染",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-组件之外渲染",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["需要把弹窗组件渲染到挂载的容器之外，这样不受到父组件的影响。这里可以通过 ",(0,d.jsx)(e.code,{children:"ReactDOM.createPortal"})," API解决这个问题。"]}),"\n",(0,d.jsx)(e.p,{children:"Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。createPortal 可以把当前组件或 element 元素的子节点，渲染到组件之外的其他地方。"}),"\n",(0,d.jsx)(e.p,{children:"createPortal 接受两个参数："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"ReactDOM.createPortal(child, container)\n"})}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"第一个： child 是任何可渲染的 React Element元素。"}),"\n",(0,d.jsx)(e.li,{children:"第二个： container 是一个 DOM 元素。"}),"\n"]}),"\n",(0,d.jsxs)(e.h4,{id:"3-不依赖父组件实现挂载卸载组件",children:["3 不依赖父组件实现挂载/卸载组件",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-不依赖父组件实现挂载卸载组件",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"挂载组件"})}),"\n",(0,d.jsxs)(e.p,{children:["一个 React 应用，可以有多个 root Fiber， 所以可以通过 ",(0,d.jsx)(e.code,{children:" ReactDOM.render"})," 来实现组件的自由挂载。"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"卸载组件"})}),"\n",(0,d.jsxs)(e.p,{children:["上面既然完成了挂载组件，下面需要在隐藏 Modal 的时候去卸载组件。 可以通过 ",(0,d.jsx)(e.code,{children:"ReactDOM.unmountComponentAtNode"})," 来实现这个功能。"]}),"\n",(0,d.jsx)(e.p,{children:"unmountComponentAtNode 从 DOM 中卸载组件，会将其事件处理器和 state 一并清除。 如果指定容器上没有对应已挂载的组件，这个函数什么也不会做。如果组件被移除将会返回 true ，如果没有组件可被移除将会返回 false 。"}),"\n",(0,d.jsxs)(e.h2,{id:"三-代码实现",children:["三 代码实现",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#三-代码实现",children:"#"})]}),"\n",(0,d.jsxs)(e.h3,{id:"1-组件层面",children:["1 组件层面",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-组件层面",children:"#"})]}),"\n",(0,d.jsxs)(e.h4,{id:"modal分配-props-渲染视图",children:["Modal——分配 props ，渲染视图",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#modal分配-props-渲染视图",children:"#"})]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:'import Dialog from \'./dialog\'\n\nclass Modal extends React.PureComponent{\n    /* 渲染底部按钮 */\n    renderFooter=()=>{\n        const { onOk , onCancel , cancelText , okText, footer  } = this.props\n        /* 触发 onOk / onCancel 回调  */\n        if(footer && React.isValidElement(footer)) return footer\n        return <div className="model_bottom" >\n            <div className="model_btn_box" >\n                <button className="searchbtn"  onClick={(e)=>{ onOk && onOk(e) }} >{okText || \'确定\'}</button>\n                <button className="concellbtn" onClick={(e)=>{ onCancel && onCancel(e) }} >{cancelText || \'取消\'}</button>\n            </div>\n        </div>\n    }\n\n    /* 渲染顶部 */\n    renderTop=()=>{\n        const { title , onClose  } = this.props\n        return <div className="model_top" >\n            <p>{title}</p>\n            <span className="model_top_close"  onClick={()=> onClose && onClose()} >x</span>\n        </div>\n    }\n\n    /* 渲染弹窗内容 */\n    renderContent=()=>{\n        const { content , children } = this.props\n        return  React.isValidElement(content) ? content\n                : children ? children : null\n    }\n    render(){\n        const { visible, width = 500 ,closeCb , onClose  } = this.props\n        return <Dialog\n            closeCb={closeCb}\n            onClose={onClose}\n            visible={visible}\n            width={width}\n               >\n           {this.renderTop()}\n           {this.renderContent()}\n           {this.renderFooter()}\n     </Dialog>\n    }\n}\n'})}),"\n",(0,d.jsx)(e.p,{children:"设计思路："}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"Modal 组件的设计实际很简单，就是接收上述的 props 配置，然后分配给 Top， Foot， Content 等每个部分。"}),"\n",(0,d.jsx)(e.li,{children:"这里通过 Dialog 组件，来实现 Modal 的动态显示/隐藏，增加动画效果。"}),"\n",(0,d.jsx)(e.li,{children:"绑定确定 onOk ，取消 onCancel ，关闭 onClose 等回调函数。"}),"\n",(0,d.jsx)(e.li,{children:"通过 PureComponent 做性能优化。"}),"\n"]}),"\n",(0,d.jsxs)(e.h4,{id:"dialog控制显示隐藏",children:["Dialog——控制显示隐藏",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#dialog控制显示隐藏",children:"#"})]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"import React , { useMemo , useEffect ,useState  } from 'react'\nimport ReactDOM from 'react-dom'\n\n /* 控制弹窗隐藏以及动画效果 */\n const controlShow = (f1,f2,value,timer)=> {\n    f1(value)\n    return  setTimeout(()=>{\n        f2(value)\n    },timer)\n}\nexport default function Dialog(props){\n    const { width , visible , closeCb , onClose  } = props\n    /* 控制 modelShow 动画效果 */\n    const [ modelShow , setModelShow ] = useState(visible)\n    const [ modelShowAync , setModelShowAync ] = useState(visible)\n    const renderChildren = useMemo(()=>{\n        /* 把元素渲染到组件之外的 document.body 上  */\n        return ReactDOM.createPortal(\n          <div style={{ display:modelShow ? 'block' : 'none'  }} >\n              <div className=\"model_container\" style={{ opacity:modelShowAync ? 1 : 0  }}  >\n                <div className=\"model_wrap\" >\n                    <div  style={{ width:width + 'px'}}  > {props.children} </div>\n                </div>\n              </div>\n              <div  className=\"model_container mast\"  onClick={()=> onClose && onClose()} style={{ opacity:modelShowAync ? 0.6 : 0  }}  />\n          </div>,\n          document.body\n         )\n    },[ modelShowAync, modelShow ])\n    useEffect(()=>{\n        let timer\n        if(visible){\n            /* 打开弹窗，需要先让 */\n           timer = controlShow(setModelShow,setModelShowAync,visible,30)\n        }else{\n           timer = controlShow(setModelShowAync,setModelShow,visible,1000)\n        }\n        return function (){\n            timer && clearTimeout(timer)\n        }\n    },[ visible ])\n    /* 执行关闭弹窗后的回调函数 closeCb */\n    useEffect(()=>{\n        !modelShow && typeof closeCb  === 'function' && closeCb()\n    },[ modelShow ])\n    return renderChildren\n"})}),"\n",(0,d.jsx)(e.p,{children:"设计思路："}),"\n",(0,d.jsxs)(e.p,{children:["需要把元素渲染到组件之外，用 createPortal 把元素直接渲染到 ",(0,d.jsx)(e.code,{children:"document.body"})," 下，为了防止函数组件每一次执行都触发 ",(0,d.jsx)(e.code,{children:"createPortal"}),"， 所以通过 useMemo 做性能优化。"]}),"\n",(0,d.jsxs)(e.p,{children:["因为需要渐变的动画效果，所以需要两个变量 modelShow / modelShowAync 来控制",(0,d.jsx)(e.strong,{children:"显示/隐藏"}),"，modelShow 让元素显示/隐藏，modelShowAync 控制动画执行。"]}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"当弹窗要显示的时候，要先设置 modelShow 让组件显示，然后用 setTimeout 调度让 modelShowAync 触发执行动画。"}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"当弹窗要隐藏的时候，需要先让动画执行，所以先控制 modelShowAync ，然后通过控制 modelShow 元素隐藏，和上述流程相反。"}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"用一个控制器 controlShow 来流畅执行更新任务。"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h3,{id:"2-静态属性方法",children:["2 静态属性方法",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-静态属性方法",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"对于通过组件的静态方法来实现弹窗的显示与隐藏，流程在上述基础上，要更复杂有一些。"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"let ModalContainer = null\nconst modelSysbol = Symbol('$$__model__Container_hidden')\n\n/* 静态属性show——控制 */\nModal.show = function(config){\n    /* 如果modal已经存在了，那么就不需要第二次show */\n   if(ModalContainer) return\n   const props = { ...config , visible: true }\n   const container = ModalContainer =  document.createElement('div')\n   /* 创建一个管理者，管理moal状态 */\n   const manager =  container[modelSysbol] = {\n       setShow:null,\n       mounted:false,\n       hidden(){\n          const { setShow } = manager\n          setShow && setShow(false)\n       },\n       destory(){\n           /* 卸载组件 */\n           ReactDOM.unmountComponentAtNode(container)\n          /* 移除节点 */\n          document.body.removeChild(container)\n          /* 置空元素 */\n          ModalContainer = null\n       }\n   }\n   const ModelApp = (props) => {\n       const [ show , setShow ] = useState(false)\n       manager.setShow = setShow\n       const { visible,...trueProps } = props\n       useEffect(()=>{\n           /* 加载完成，设置状态 */\n           manager.mounted = true\n           setShow(visible)\n        },[])\n       return <Modal  {...trueProps} closeCb={() => manager.mounted &&  manager.destory()}  visible={show}  />\n   }\n   /* 插入到body中 */\n   document.body.appendChild(container)\n   /* 渲染React元素 */\n   ReactDOM.render(<ModelApp  {...props}  />,container)\n   return manager\n}\n\n/* 静态属性——hidden控制隐藏 */\nModal.hidden = function(){\n   if(!ModalContainer) return\n   /* 如果存在 ModalContainer 那么隐藏 ModalContainer  */\n   ModalContainer[modelSysbol] && ModalContainer[modelSysbol].hidden()\n}\n\nexport default Modal\n"})}),"\n",(0,d.jsx)(e.p,{children:"接下来，描述一下流程和细节："}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:["第一点：因为要通过调用 Modal 的静态属性来实现组件的显示与隐藏。所以用 ",(0,d.jsx)(e.code,{children:"Modal.show"})," 来控制显示，",(0,d.jsx)(e.code,{children:"Modal.hidden"}),"来控制隐藏。但是两者要建立起关联，所以通过全局",(0,d.jsx)(e.code,{children:"ModalContainer"}),"属性，能够隐藏掉",(0,d.jsx)(e.code,{children:"Modal.show"})," 产生的元素与组件。"]}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:["第二点：如果调用 ",(0,d.jsx)(e.code,{children:"Modal.show"}),"，首先会创建一个元素容器 container ，用来挂载 Modal 组件，通过 ReactDOM.render 挂载，这里需要把 contianer 插入到 document.body 上。"]}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"第三点：因为 Modal 组件要动态混入 visible 属性，并且做一些初始化的工作，比如提供隐藏弹窗的方法，所以创建一个 ModelApp 容器组件包裹 Modal。"}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:["第四点：因为要在弹窗消失的动画执行后，再统一卸载组件和元素，所以到了本模块难点，就是创建一个 modal manager 管理者，通过 ",(0,d.jsx)(e.code,{children:"Symbol('$$__model__Container_hidden')"})," 把管理者和容器之间建立起关联。容器下有 hidden 只是隐藏组件，并没有销毁组件，当组件隐藏动画执行完毕，会执行 closeCb 回调函数，在回调函数中再统一卸载元素和组件。"]}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:["第五点：调用",(0,d.jsx)(e.code,{children:"Modal.hidden"})," 本质上调用的是 manager 上的 hidden 方法 ，然后执行动画，执行隐藏元素。然后再触发 destory ，用 unmountComponentAtNode 和 removeChild 做一些收尾工作。完成整个流程。"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"创建弹窗流程图："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:t,alt:"3.jpg"})}),"\n",(0,d.jsx)(e.p,{children:"关闭弹窗流程图："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:r,alt:"4.jpg"})}),"\n",(0,d.jsxs)(e.h2,{id:"四-验证环节",children:["四 验证环节",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#四-验证环节",children:"#"})]}),"\n",(0,d.jsxs)(e.h3,{id:"验证第一种通过挂载组件方式",children:["验证第一种——通过挂载组件方式",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#验证第一种通过挂载组件方式",children:"#"})]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"/* 挂载方式调用modal */\nexport default function Index() {\n    const [ visible , setVisible ] = useState(false)\n    const [ nameShow , setNameShow ] = useState(false)\n    const handleClick = () => {\n        console.log('点击')\n        setVisible(!visible)\n        setNameShow(!nameShow)\n    }\n    /* 防止 Model 的 PureComponent 失去作用 */\n    const [ handleClose ,handleOk, handleCancel ] = useMemo(()=>{\n        const Ok = () =>  console.log('点击确定按钮')\n        const Close = () => setVisible(false)\n        const Cancel = () => console.log('点击取消按钮')\n        return [ Close , Ok , Cancel  ]\n    },[])\n\n    return <div>\n        <Modal\n            onCancel={handleCancel}\n            onClose={handleClose}\n            onOk={handleOk}\n            title={'《React进阶实践指南》'}\n            visible={visible}\n            width={700}\n        >\n           <div className=\"feel\" >\n              小册阅读感受： <input placeholder=\"写下你的感受\" />\n              {nameShow && <p>作者： 我不是外星人</p>}\n           </div>\n        </Modal>\n        <button onClick={() => {\n            setVisible(!visible)\n            setNameShow(false)\n        }}\n        > model show </button>\n        <button onClick={handleClick} > model show ( 显示作者 ) </button>\n    </div>\n}\n"})}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"如上就是挂载的方式使用 Modal，注意 Modal 用的是 PureComponent ，父组件是函数组件在给 PureComponent 绑定方法的时候 ，要用 useMemo 或 useCallback 处理。"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"效果："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:i,alt:"1.gif"})}),"\n",(0,d.jsxs)(e.h3,{id:"验证第二种通过静态属性方式",children:["验证第二种——通过静态属性方式",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#验证第二种通过静态属性方式",children:"#"})]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"export default function Index(){\n    const handleClick =() => {\n        Modal.show({\n            content:<p>确定购买《React进阶指南小册》吗</p>,\n            title:'《React进阶实践指南》',\n            onOk:()=>console.log('点击确定'),\n            onCancel:()=>console.log('点击取消'),\n            onClose:()=> Modal.hidden()\n        })\n    }\n    return <div>\n        <button onClick={() => handleClick()} >静态方式调用，显示modal</button>\n    </div>\n}\n"})}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"这种方式用起来比上一种要简单。流程我就不细说了。"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"效果："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:o,alt:"2.gif"})}),"\n",(0,d.jsxs)(e.h2,{id:"五-总结",children:["五 总结",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"本章节的知识点总结："}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"自定义弹窗组件的编写——挂载组件/调用静态属性两种方式。"}),"\n",(0,d.jsx)(e.li,{children:"ReactDOM.createPortal 使用。"}),"\n",(0,d.jsx)(e.li,{children:"ReactDOM.unmountComponentAtNode 和 ReactDOM.render 实现自由挂载/卸载组件。"}),"\n",(0,d.jsx)(e.li,{children:"hooks 的使用与性能优化。"}),"\n"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(c,{...n})}):c(n)}let h=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F28.%E5%AE%9E%E8%B7%B5%E7%AF%87-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%B9%E7%AA%97.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 设计思路",id:"二-设计思路",depth:2},{text:"1 建立目标",id:"1-建立目标",depth:3},{text:"2 设计思路",id:"2-设计思路",depth:3},{text:"1 props的设定",id:"1-props的设定",depth:4},{text:"2 组件之外渲染",id:"2-组件之外渲染",depth:4},{text:"3 不依赖父组件实现挂载/卸载组件",id:"3-不依赖父组件实现挂载卸载组件",depth:4},{text:"三 代码实现",id:"三-代码实现",depth:2},{text:"1 组件层面",id:"1-组件层面",depth:3},{text:"Modal——分配 props ，渲染视图",id:"modal分配-props-渲染视图",depth:4},{text:"Dialog——控制显示隐藏",id:"dialog控制显示隐藏",depth:4},{text:"2 静态属性方法",id:"2-静态属性方法",depth:3},{text:"四 验证环节",id:"四-验证环节",depth:2},{text:"验证第一种——通过挂载组件方式",id:"验证第一种通过挂载组件方式",depth:3},{text:"验证第二种——通过静态属性方式",id:"验证第二种通过静态属性方式",depth:3},{text:"五 总结",id:"五-总结",depth:2}],title:"28.实践篇-自定义弹窗",headingTitle:"28.实践篇-自定义弹窗",frontmatter:{}}}}]);