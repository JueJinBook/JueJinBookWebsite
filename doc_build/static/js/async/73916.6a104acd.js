"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["73916"],{780275:function(e,n,t){t.r(n),t.d(n,{default:()=>x});var r=t(552676),s=t(740453);let i=t.p+"static/image/c3c605d54dd9abfea49f4a40b85b1d2a.ea462f10.webp",o=t.p+"static/image/97c4a8fc58d9aed7d118cc9954274ee4.578c180d.webp",a=t.p+"static/image/140afbf69ede986b6181ae2c584b30c4.5928ac11.webp",l=t.p+"static/image/26609599d869f5ef130751c654d0eaad.268ee1db.webp",c=t.p+"static/image/144109c25b21dc29812c9964eec4e024.63750bdf.webp",p=t.p+"static/image/ae8de2f9b630363881dce1f051ca8e7d.a411a71d.webp";function d(e){let n=Object.assign({blockquote:"blockquote",p:"p",a:"a",img:"img",ul:"ul",li:"li",code:"code",h1:"h1",ol:"ol",h2:"h2",pre:"pre"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"本节课程涉及 CMS 和 Demo 两个仓库地址"}),"\n",(0,r.jsxs)(n.p,{children:["CMS 仓库地址：",(0,r.jsx)(n.a,{href:"https://github.com/czm1290433700/nextjs-cms",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/nextjs-cms"})]}),"\n",(0,r.jsxs)(n.p,{children:["Demo 仓库地址： ",(0,r.jsx)(n.a,{href:"https://github.com/czm1290433700/nextjs-demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/nextjs-demo"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["上一节课我们对需要的 layout 数据进行相关的可视化配置，通过访问 ",(0,r.jsx)(n.a,{href:"http://localhost:1337/api/layouts?populate=deep",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:1337/api/layouts?populate=deep"})," 可以拿到我们需要的数据。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"不过这样的数据是有一些乱的，有几个可以优化的点："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["请求参数",(0,r.jsx)(n.code,{children:"populate=deep"}),"是每次请求都需要带上的，我们需要所有深度的数据；"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"我们需要的是 data 中的数据，layout 只有一个，不需要分页相关的部分（meta）；"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"针对每个结构体，Strapi 为它们套上了 attributes 和 id，这个是不利于我们调用的，因为没有覆盖对应 ts 类型，会增加很多不必要的调试成本；"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"每个结构体都加上了 createdAt、 publishedAt、updatedAt 三个字段，实际上针对这个需求，我们是不需要这些字段的，随着接口层级的增加，过多不被使用的字段会增加我们接口的复杂度和可维护性"}),"\n"]}),"\n",(0,r.jsxs)(n.h1,{id:"9bff数据流转nextjs-中的页面数据流转开发实战",children:["9.BFF数据流转：Nextjs 中的页面数据流转开发实战",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9bff数据流转nextjs-中的页面数据流转开发实战",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["现在，根据上面说的几个问题，我们来优化一下我们定义的 CMS 接口，下面的内容基于",(0,r.jsx)(n.a,{href:"https://github.com/czm1290433700/nextjs-cms",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/nextjs-cms"})," 仓库，同学们可以对着仓库一步步来实践。"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.h2,{children:"自定义返回 & 移除非必要属性"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"同学们应该还记得，上一节课我们在介绍项目结构的时候，有提到 src/api/* 的目录下，存放着我们结构体接口的定义，其中 controllers 存放着接口的控制器，每当客户端请求路由时，操作都会执行业务逻辑代码并发回响应，我们可以在其中重写 api 的相关方法（find、findOne、 update 等）。"}),"\n",(0,r.jsxs)(n.p,{children:["以 layout 为例，我们首先为 layout 接口加上默认的",(0,r.jsx)(n.code,{children:"populate=deep"}),"参数，这样我们每次请求的时候就不用再加了。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/api/layout/controllers/layout.js\n"use strict";\n\n/**\n *  layout controller\n */\n\nconst { createCoreController } = require("@strapi/strapi").factories;\n\nmodule.exports = createCoreController("api::layout.layout", ({ strapi }) => ({\n  async find(ctx) {\n    ctx.query = {\n      ...ctx.query,\n      populate: "deep",\n    };\n    const { data } = await super.find(ctx);\n    return data;\n  },\n}));\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这时候我们再尝试直接访问 ",(0,r.jsx)(n.a,{href:"http://localhost:1337/api/layouts%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%B7%B2%E7%BB%8F%E4%B8%8D%E9%9C%80%E8%A6%81%E5%8A%A0",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:1337/api/layouts，可以看到已经不需要加"})," populate 参数就可以拿到联表的数据了。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"然后咱们针对上面提到的 attributes、id 和时间相关的字段定义两个深度遍历的函数来对应去除。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/utils/index.js\n/**\n * 移除对象中自动创建的时间字段\n * @param obj\n * @returns\n */\nconst removeTime = (obj) => {\n  const { createdAt, publishedAt, updatedAt, ...params } = obj || {};\n  Object.getOwnPropertyNames(params).forEach((item) => {\n    if (typeof params[item] === "object") {\n      if (Array.isArray(params[item])) {\n        params[item] = params[item].map((item) => {\n          return removeTime(item);\n        });\n      } else {\n        params[item] = removeTime(params[item]);\n      }\n    }\n  });\n  return params;\n};\n\n/**\n * 移除属性和id\n * @param {*} obj\n * @returns\n */\nconst removeAttrsAndId = (obj) => {\n  const { attributes, id, ...params } = obj || {};\n  const newObj = { ...attributes, ...params };\n  Object.getOwnPropertyNames(newObj).forEach((item) => {\n    if (typeof newObj[item] === "object") {\n      if (Array.isArray(newObj[item])) {\n        newObj[item] = newObj[item].map((item) => {\n          return removeAttrsAndId(item);\n        });\n      } else {\n        newObj[item] = removeAttrsAndId(newObj[item]);\n      }\n    }\n  });\n  return newObj;\n};\n\nmodule.exports = {\n  removeTime,\n  removeAttrsAndId,\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"然后我们对 layout 的 find 函数返回的数据调用进行处理。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/api/layout/controllers/layout.js\n"use strict";\nconst { removeTime, removeAttrsAndId } = require("../../../utils/index.js");\n\n/**\n *  layout controller\n */\n\nconst { createCoreController } = require("@strapi/strapi").factories;\n\nmodule.exports = createCoreController("api::layout.layout", ({ strapi }) => ({\n  async find(ctx) {\n    ctx.query = {\n      ...ctx.query,\n      populate: "deep",\n    };\n    const { data } = await super.find(ctx);\n    return removeAttrsAndId(removeTime(data[0]));\n  },\n}));\n'})}),"\n",(0,r.jsxs)(n.p,{children:["再访问 ",(0,r.jsx)(n.a,{href:"http://localhost:1337/api/layouts",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:1337/api/layouts"})," 试试，可以看到已经精简很多了，只包含了我们需要的元信息。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.h2,{children:"接口增加跨域限制"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Strapi 的接口默认不做跨域限制的，这样所有的域名都可以调用我们的接口，安全性是存在问题的，我们可以在掘金下调用试试。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["没有跨域的报错，我们预期允许访问的域名只有 ",(0,r.jsx)(n.a,{href:"http://localhost:3000",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3000"})," 和 ",(0,r.jsx)(n.a,{href:"http://localhost:1337%E3%80%82%E6%88%91%E4%BB%AC%E4%B8%8A%E8%8A%82%E8%AF%BE%E6%9C%89%E6%8F%90%E5%88%B0",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:1337。我们上节课有提到"})," config 中有相关的中间件配置，我们可以在 config/middlewares.js 中加上跨域的限制。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./config/middlewares.js\nmodule.exports = [\n  "strapi::errors",\n  "strapi::security",\n  {\n    name: "strapi::cors",\n    config: {\n      enabled: true,\n      headers: "*",\n      origin: ["http://localhost:3000", "http://localhost:1337"],\n    },\n  },\n  "strapi::poweredBy",\n  "strapi::logger",\n  "strapi::query",\n  "strapi::body",\n  "strapi::session",\n  "strapi::favicon",\n  "strapi::public",\n];\n'})}),"\n",(0,r.jsx)(n.p,{children:"然后我们再到掘金中试一下，发现已经会有跨域的警告了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h1,{id:"bff-接口定义",children:["BFF 接口定义",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#bff-接口定义",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"CMS 接口配置好了以后还不能直接在页面中调用，我们需要配置一层 BFF 层，即服务于前端的数据层。因为我们通常配置的数据是站在结构体的角度的，并不一定可以由前端调用，往往还需要复杂的数据处理，为了提高数据层的复用程度，我们增加 BFF 层，将 CMS 接口包一层，进行相关处理后，前端页面只调用我们定义的 BFF 层接口，不直接与 CMS 配置的接口产生交互。"}),"\n",(0,r.jsx)(n.p,{children:"在定义接口前，我们得先来了解一下 Nextjs 接口的路由是怎么配置的?"}),"\n",(0,r.jsx)(n.p,{children:"与静态页面类似，Nextjs 接口也采用文件约定式路由的方式进行配置，可以分为预定义路由、动态路由和全捕获路由，如下面的例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// ./pages/api/home/test.js => api/home/test 预定义路由\n// ./pages/api/home/[testId].js => api/home/test, api/home/1, api/home/23 动态路由\n// ./pages/api/home/[...testId].js => api/home/test, api/home/test/12 全捕获路由\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如果一个相同的路由，比如",(0,r.jsx)(n.code,{children:"api/home/test"}),"，按照优先级来匹配三者，会按照预定义路由 > 动态路由 > 全捕获路由的顺序来匹配。"]}),"\n",(0,r.jsx)(n.p,{children:"这也很好理解，因为三者匹配的精准度是逐渐下降的，如果说预定义路由是精准匹配，后两者只是模糊匹配，虽然也满足匹配场景，但是只是作为兜底，优先会以预定义路由为准。"}),"\n",(0,r.jsxs)(n.p,{children:["知道了 Api 路由的原理，下面来开发我们的 BFF 层，首先定义一个接口层 ",(0,r.jsx)(n.code,{children:"./pages/api/layout.ts"}),"， 因为后续我们会经常用到本地域名 和 CMS 域名，所以我们拿一个变量来存储它们，后续根据环境区分也很方便。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./utils/index.ts\nexport const LOCALDOMAIN = "http://127.0.0.1:3000";\nexport const CMSDOMAIN = "http://127.0.0.1:1337";\n'})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./pages/api/layout.ts\nimport type { NextApiRequest, NextApiResponse } from "next";\nimport axios from "axios";\nimport { ILayoutProps } from "../../components/layout";\nimport { CMSDOMAIN } from "@/utils";\nimport { isEmpty } from "lodash";\n\nconst getLayoutData = (\n  req: NextApiRequest,\n  res: NextApiResponse<ILayoutProps>\n) => {\n  axios.get(`${CMSDOMAIN}/api/layouts`).then((result) => {\n    const {\n      copy_right,\n      link_lists,\n      public_number,\n      qr_code,\n      qr_code_image,\n      site_number,\n      title,\n    } = result.data || {};\n\n    res.status(200).json({\n      navbarData: {},\n      footerData: {\n        title,\n        linkList: link_lists?.data?.map((item: any) => {\n          return {\n            title: item.title,\n            list: item?.links?.data?.map((_item: any) => {\n              return {\n                label: _item.label,\n                link: isEmpty(_item.link) ? "" : _item.link,\n              };\n            }),\n          };\n        }),\n        qrCode: {\n          image: `${CMSDOMAIN}${qr_code_image.data.url}`,\n          text: qr_code,\n        },\n        copyRight: copy_right,\n        siteNumber: site_number,\n        publicNumber: public_number,\n      },\n    });\n  });\n};\n\nexport default getLayoutData;\n'})}),"\n",(0,r.jsx)(n.p,{children:"这部分代码有两个需要稍微提一下的地方："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"NextApiResponse 类型是 Nextjs 提供的 response 类型，它提供了一个泛型，来作为整个接口和后续请求的返回，我们可以把需要的数据类型作为泛型传进去，保证整体代码有 ts 的 lint。"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"这里我们返回数据用的是 json，针对数据的响应，Nextjs 有提供下面的响应 Api， 大家可以根据自己的需求选用不同的响应 Api。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"res.status(code)"}),"- 设置状态码的功能。",(0,r.jsx)(n.code,{children:"code"}),"必须是有效的HTTP 状态码。"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"res.json(body)"}),"- 发送 JSON 响应。",(0,r.jsx)(n.code,{children:"body"}),"必须是可序列化的对象。"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"res.send(body)"}),"- 发送 HTTP 响应。",(0,r.jsx)(n.code,{children:"body"}),"可以是 a ",(0,r.jsx)(n.code,{children:"string"}),"，an",(0,r.jsx)(n.code,{children:"object"}),"或 a",(0,r.jsx)(n.code,{children:"Buffer"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"res.redirect([status,] path)"}),"- 重定向到指定的路径或 URL。",(0,r.jsx)(n.code,{children:"status"}),"必须是有效的HTTP 状态码。如果未指定，",(0,r.jsx)(n.code,{children:"status"}),"默认为“307”“临时重定向”。"]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"res.revalidate(urlPath)"}),"-使用.按需重新验证页面",(0,r.jsx)(n.code,{children:"getStaticProps"}),"。",(0,r.jsx)(n.code,{children:"urlPath"}),"必须是一个",(0,r.jsx)(n.code,{children:"string"}),"。"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"到这里我们 BFF 接口就定义好了，我们改造一下 layout 部分的数据注入，换用接口数据。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./pages/_app.tsx\nimport "../styles/globals.css";\nimport type { AppProps, AppContext } from "next/app";\nimport App from "next/app";\nimport { Layout, ILayoutProps } from "@/components/layout";\nimport Head from "next/head";\nimport axios from "axios";\nimport { LOCALDOMAIN } from "@/utils";\n\nconst MyApp = (data: AppProps & ILayoutProps) => {\n  const { Component, pageProps, navbarData, footerData } = data;\n\n  return (\n    <div>\n      <Head>\n        <title>A Demo for 《深入浅出SSR官网开发指南》</title>\n        <meta\n          name="description"\n          content="A Demo for 《深入浅出SSR官网开发指南》"\n        />\n        <link rel="icon" href="/favicon.ico" />\n      </Head>\n      <Layout navbarData={navbarData} footerData={footerData}>\n        <Component {...pageProps} />\n      </Layout>\n    </div>\n  );\n};\n\nMyApp.getInitialProps = async (context: AppContext) => {\n  const pageProps = await App.getInitialProps(context);\n  const { data = {} } = await axios.get(`${LOCALDOMAIN}/api/layout`);\n\n  return {\n    ...pageProps,\n    ...data,\n  };\n};\n\nexport default MyApp;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["启动一下页面访问 ",(0,r.jsx)(n.a,{href:"http://localhost:3000",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3000"})," 看一下效果，可以看到已经可以了。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h1,{id:"中间件小彩蛋",children:["中间件小彩蛋",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#中间件小彩蛋",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"使用过 Express 的同学应该知道中间件的概念，Express 是基于路由和中间件的框架，通过链式调用的方式来对接口进行一些统一的处理，不过 Nextjs 中没有这样的概念，因为约定式路由的关系， Nextjs 中更多是模块的调用思想，针对接口的请求类型只是一个判断搞定。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"export default (req, res) => {\n  if (req.method === 'GET') {\n    // do something for the get scene\n  } else if (req.method === 'POST') {\n    // do something for the post scene\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"对于相关中间件的调用，也只需要引入模块执行即可， 例如下面 Nextjs 官网调用跨域中间件的例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'import Cors from "cors";\n\n// Initializing the cors middleware\nconst cors = Cors({\n  methods: ["GET", "HEAD"],\n});\n\n// Helper method to wait for a middleware to execute before continuing\n// And to throw an error when an error happens in a middleware\nfunction runMiddleware(req, res, fn) {\n  return new Promise((resolve, reject) => {\n    fn(req, res, (result) => {\n      if (result instanceof Error) {\n        return reject(result);\n      }\n      return resolve(result);\n    });\n  });\n}\n\nasync function handler(req, res) {\n  // Run the middlewareawait runMiddleware(req, res, cors)\n  // Rest of the API logic\n  res.json({ message: "Hello Everyone!" });\n}\n\nexport default handler;\n'})}),"\n",(0,r.jsx)(n.p,{children:"我个人也是更推荐这种写法的，模块化的写法使得代码结构更为清晰，复用性上也更舒服，符合平常客户端的开发方式，不过习惯 Express 开发模式的同学也可以按照下面的方式来适配一下对应的能力，开源社区有开发提供了 next-connect 的依赖来补全这部分的能力，我们先来安装一下依赖。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install next-connect -save\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后上面的 layout 接口按照下面改造一下即可。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'import type { NextApiRequest, NextApiResponse } from "next";\nimport axios from "axios";\nimport { ILayoutProps } from "../../components/layout";\nimport { CMSDOMAIN } from "@/utils";\nimport { isEmpty } from "lodash";\nimport nextConnect from "next-connect";\n\nconst getLayoutData = nextConnect()\n  // .use(any middleware)\n  .get((req: NextApiRequest, res: NextApiResponse<ILayoutProps>) => {\n    axios.get(`${CMSDOMAIN}/api/layouts`).then((result) => {\n      const {\n        copy_right,\n        link_lists,\n        public_number,\n        qr_code,\n        qr_code_image,\n        site_number,\n        title,\n      } = result.data || {};\n\n      res.status(200).json({\n        navbarData: {},\n        footerData: {\n          title,\n          linkList: link_lists?.data?.map((item: any) => {\n            return {\n              title: item.title,\n              list: item?.links?.data?.map((_item: any) => {\n                return {\n                  label: _item.label,\n                  link: isEmpty(_item.link) ? "" : _item.link,\n                };\n              }),\n            };\n          }),\n          qrCode: {\n            image: `${CMSDOMAIN}${qr_code_image.data.url}`,\n            text: qr_code,\n          },\n          copyRight: copy_right,\n          siteNumber: site_number,\n          publicNumber: public_number,\n        },\n      });\n    });\n  });\n\nexport default getLayoutData;\n'})}),"\n",(0,r.jsx)(n.p,{children:"需要引入中间件，只需要类似 Express 的方式就行了，用 use 来链式调用即可。我更推荐 Nextjs 官网模块调用的写法，相对是更为清晰的，大家可以按照自己的开发习惯自行选用。"}),"\n",(0,r.jsxs)(n.h1,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这两节课我们学习怎么通过 Strapi 搭建一个符合我们自己业务场景的 CMS，并定义了对应的 find 接口用于后续的查询，然后自定义移除了一些不必要的属性，便于接口交互。然后我们定义了自己的 BFF 层，用于我们官网页面数据的注入，整个数据链路我们都已经走完了，后面遇到类似的数据流转，大家也可以举一反三进行开发。"}),"\n",(0,r.jsxs)(n.p,{children:["值得一提的是，Strapi 的能力还远不及此，它包含 Api 鉴权，审批配置等更多的能力可以帮助我们进行官网的规范维护，同时它提供了很多 openApi 来支持相关不同的业务场景，是一个非常优秀值得尝试的开源项目。感兴趣和有更多需求的同学可以阅读 ",(0,r.jsx)(n.a,{href:"https://docs.strapi.io/developer-docs/latest/getting-started/introduction.html",target:"_blank",rel:"noopener noreferrer",children:"Strapi 官方文档"})," 做更多的尝试~"]}),"\n",(0,r.jsx)(n.p,{children:"到这节课我们实战篇的内容就全部完成了，学到这里，大家应该对官网项目的静态页面到数据流转都有了较深刻的了解了。从下一节课开始，我们将就一些常见的官网需求展开，就 case 来讲解这些需求场景我们应该怎么去开发实现。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}let x=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["SSR%20%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%98%E7%BD%91%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F9.BFF%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC%EF%BC%9ANextjs%20%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98.md"]={toc:[],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);