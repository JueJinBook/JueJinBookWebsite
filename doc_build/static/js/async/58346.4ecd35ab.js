"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58346"],{358979:function(e,n,t){t.r(n),t.d(n,{default:()=>i});var s=t(552676),r=t(740453);let o=t.p+"static/image/12-1.69dd326a.png";function c(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",pre:"pre",code:"code",p:"p",ul:"ul",li:"li",img:"img"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"",children:(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,s.jsxs)(n.h1,{id:"12案例十一埋点搜集服务器---总结-koa-服务端框架用到了哪些能力",children:["12案例十一：[埋点搜集服务器] - 总结： Koa 服务端框架用到了哪些能力",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12案例十一埋点搜集服务器---总结-koa-服务端框架用到了哪些能力",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-!",children:"本节目标: 「实现一个简单的埋点服务器」 站在巨人的肩膀上，不仅登高望远，可以低头俯瞰，Node 有很多优秀框架，赋予我们极大的工程效率，那么前面章节学习到的 Node 基础能力在 Koa 这个框架里到底用到了哪些呢？我们拨开云雾看一看。\n"})}),"\n",(0,s.jsxs)(n.p,{children:["对于 Node 的框架部分，我们本册只针对 Koa 简单学习一下，因为它的源码更精简，结构更清晰，学习的难度相对较小，Koa 的历史就不多说了，也是 TJ 开创，从 GeneratorFunction 时代到现在的 Async/Await 异步时代，经历了一个较大的版本变化，大家可以翻开 ",(0,s.jsx)(n.a,{href:"https://github.com/koajs/koa/tree/8ee8abcc3268189c3f44abfb64d42903a87c4d5e/",target:"_blank",rel:"noopener noreferrer",children:"Koa 5 年前的代码"})," 看一看，早期的 Koa 就分离了 Application 和 Context，代码风格和流程的设计就比较精简，对于进化到今天的 Koa ，在它里面像  cookies koa-compose delegates 都尽量抽象出去了，所以剩下的部分，特别的纯粹，只有："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"application 整个 Koa 应用服务类"}),"\n",(0,s.jsx)(n.li,{children:"context Koa 的应用服务上下文"}),"\n",(0,s.jsx)(n.li,{children:"request Koa 的请求对象"}),"\n",(0,s.jsx)(n.li,{children:"response Koa 的响应对象"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这四个也分别对应到 Koa 的四个模块文件： ",(0,s.jsx)(n.a,{href:"https://github.com/koajs/koa/blob/master/lib/application.js",target:"_blank",rel:"noopener noreferrer",children:"application.js"}),"、",(0,s.jsx)(n.a,{href:"https://github.com/koajs/koa/blob/master/lib/context.js",target:"_blank",rel:"noopener noreferrer",children:"context.js"}),"、",(0,s.jsx)(n.a,{href:"https://github.com/koajs/koa/blob/master/lib/request.js",target:"_blank",rel:"noopener noreferrer",children:"request.js"}),"、",(0,s.jsx)(n.a,{href:"https://github.com/koajs/koa/blob/master/lib/response.js",target:"_blank",rel:"noopener noreferrer",children:"response.js"}),"，整个 HTTP 的门面就是靠它们扛起来的，代码量加一起也就一两千行，简约而强大，整个 Koa 的设计哲学就是小而美的，比如 Koa 启动一个 HTTP Server 也非常简单："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const Koa = require('koa')\nconst app = new Koa()\n\napp.use(ctx => {\n  ctx.body = 'Hello Koa'\n}).listen(3000)\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 new 这个 Koa 实例的时候，实际上是基于这个 Application 类创建的实例，而这个类集成了 Emitter 也就是我们前文学习到的事件类，一旦继承了事件，就可以非常方便基于各种条件来监听和触发事件了。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"module.exports = class Application extends Emitter {\n  constructor() {\n    super()\n    this.proxy = false\n    this.middleware = []\n    this.subdomainOffset = 2\n    this.env = process.env.NODE_ENV || 'development'\n    this.context = Object.create(context)\n    this.request = Object.create(request)\n    this.response = Object.create(response)\n"})}),"\n",(0,s.jsx)(n.p,{children:"在创建这个实例的时候，对实例上面也挂载了通过 Object.create 所创建出来的上下文对象 context、请求对象 request 和 响应对象 response，所以一开始，这几个核心的对象都有了，后面无非就是基于这些对象做更多的扩展和封装罢了。"}),"\n",(0,s.jsx)(n.p,{children:"为帮助大家读源码，我把 application.js 删减到了 100 行代码，单独拎出来给大家看一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const onFinished = require('on-finished')\nconst response = require('./response')\nconst compose = require('koa-compose')\nconst context = require('./context')\nconst request = require('./request')\nconst Emitter = require('events')\nconst util = require('util')\nconst Stream = require('stream')\nconst http = require('http')\nconst only = require('only')\n\n// 继承 Emitter，暴露一个 Application 类\nmodule.exports = class Application extends Emitter {\n  constructor() {\n    super()\n    this.proxy = false\n    this.middleware = []\n    this.subdomainOffset = 2\n    this.env = process.env.NODE_ENV || 'development'\n    this.context = Object.create(context)\n    this.request = Object.create(request)\n    this.response = Object.create(response)\n    if (util.inspect.custom) {\n      this[util.inspect.custom] = this.inspect\n    }\n  }\n\n  // 等同于 http.createServer(app.callback()).listen(...)\n  listen(...args) {\n    const server = http.createServer(this.callback())\n    return server.listen(...args)\n  }\n\n  // 返回 JSON 格式数据\n  toJSON() {\n    return only(this, ['subdomainOffset', 'proxy', 'env'])\n  }\n\n  // 把当前实例 JSON 格式化返回\n  inspect() { return this.toJSON() }\n\n  // 把中间件压入数组\n  use(fn) {\n    this.middleware.push(fn)\n    return this\n  }\n\n  // 返回 Node 原生的 Server request 回调\n  callback() {\n    const fn = compose(this.middleware)\n    const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res)\n      return this.handleRequest(ctx, fn)\n    }\n\n    return handleRequest\n  }\n\n  // 在回调中处理 request 请求对象\n  handleRequest(ctx, fnMiddleware) {\n    const res = ctx.res\n    // 先设置一个 404 的响应码，等后面来覆盖它\n    res.statusCode = 404\n    const onerror = err => ctx.onerror(err)\n    const handleResponse = () => respond(ctx)\n    onFinished(res, onerror)\n    return fnMiddleware(ctx).then(handleResponse).catch(onerror)\n  }\n\n  // 初始化一个上下文，为 req/res 建立各种引用关系，方便使用\n  createContext(req, res) {\n    const context = Object.create(this.context)\n    const request = context.request = Object.create(this.request)\n    const response = context.response = Object.create(this.response)\n    context.app = request.app = response.app = this\n    context.req = request.req = response.req = req\n    context.res = request.res = response.res = res\n    request.ctx = response.ctx = context\n    request.response = response\n    response.request = request\n    context.originalUrl = request.originalUrl = req.url\n    context.state = {}\n    return context\n  }\n}\n\n// 响应处理的辅助函数\nfunction respond(ctx) {\n  const res = ctx.res\n  let body = ctx.body\n  // 此处删减了代码，如 head/空 body 等问题的处理策略等\n  // 基于 Buffer/string 和 流，分别给予响应\n  if (Buffer.isBuffer(body)) return res.end(body)\n  if ('string' == typeof body) return res.end(body)\n  if (body instanceof Stream) return body.pipe(res)\n\n  // 最后则是以 JSON 的格式返回\n  body = JSON.stringify(body)\n  res.end(body)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个里面，我们关注到这几个点就可以了："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"new Koa() 的 app 只有在 listen 的时候才创建 HTTP Server"}),"\n",(0,s.jsx)(n.li,{children:"use fn 的时候，传入的一个函数会被压入到中间件队列，像洋葱的一层层皮一样逐级进入逐级穿出"}),"\n",(0,s.jsx)(n.li,{children:"Koa 支持对 Buffer/String/JSON/Stream 数据类型的响应"}),"\n",(0,s.jsx)(n.li,{children:"上下文 context 是在 Node 原生的 request 进入也就是异步回调执行的时候才创建，不是一开始创建好的，所以每个请求都有独立的上下文，自然不会互相污染"}),"\n",(0,s.jsx)(n.li,{children:"创建好的上下文，Koa 会把它们跟原生，以及请求和响应之间，建立各种引用关系，方便在业务代码和中间件中使用，也就是 createContext 里面所干的事情"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"看到这里，Koa 这个服务框架对我们就没那么神秘了，索性再把 context.js 代码删减到 50 行，大家再浏览下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const util = require('util')\nconst delegate = require('delegates')\nconst Cookies = require('cookies')\n\n// 上下文 prototype 的原型\nconst proto = module.exports = {\n  // 挑选上下文的内容，JSON 格式化处理后返回\n  toJSON() {\n    return {\n      request: this.request.toJSON(),\n      response: this.response.toJSON(),\n      app: this.app.toJSON(),\n      originalUrl: this.originalUrl,\n      req: '<original node req>',\n      res: '<original node res>',\n      socket: '<original node socket>'\n    }\n  },\n\n  // 错误捕获处理\n  onerror(err) {},\n  // 拿到 cookies\n  get cookies() {},\n  // 设置 cookies\n  set cookies(_cookies) { }\n}\n\n// 对新版 Node 增加自定义 inspect 的支持\nif (util.inspect.custom) {\n  module.exports[util.inspect.custom] = module.exports.inspect\n}\n\n// 为响应对象绑定原型方法\ndelegate(proto, 'response')\n  .method('attachment').method('redirect').method('remove').method('vary')\n  .method('set').method('append').method('flushHeaders')\n  .access('status').access('message').access('body').access('length').access('type')\n  .access('lastModified').access('etag')\n  .getter('headerSent').getter('writable')\n\n\n// 为请求对象绑定原型方法\ndelegate(proto, 'request')\n  .method('acceptsLanguages').method('acceptsEncodings').method('acceptsCharsets')\n  .method('accepts').method('get').method('is')\n  .access('querystring').access('idempotent').access('socket').access('search')\n  .access('method').access('query').access('path').access('url').access('accept')\n  .getter('origin').getter('href').getter('subdomains').getter('protocol').getter('host')\n  .getter('hostname').getter('URL').getter('header').getter('headers').getter('secure')\n  .getter('stale').getter('fresh').getter('ips').getter('ip')\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以发现，之所以 Koa 的请求/响应上下文上有那么多方法和属性可以用，或者可以设置，其实就是这里的 delegate 搞的鬼，它对 context 施加了许多能力，剩下的 request.js 和 response.js 就留给大家自行消化了，都是一些属性方法的特定封装，没有太多的门槛，或者大家可以参考这张图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"其中本册子所讲的几个知识点，在 Koa 中也有大量的使用，比如 path/util/stream/fs/http 等等，不过建议大家学习 Koa 时候重点关注它的网络进出模型，不需要过多关注底层细节。"}),"\n",(0,s.jsxs)(n.h3,{id:"编程练习---开发一个埋点服务器",children:["编程练习 - 开发一个埋点服务器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编程练习---开发一个埋点服务器",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们可以用 Koa 开发一个简易的埋点收集服务器，客户端每请求一次，就把埋点的数据往数据库里更新一下，为了演示，我们使用 JSON 结构存储的 lowdb 来模拟数据库，大家可以在本地自行替换为 MongoDB 或者 MySQL，同时我们会用到 Koa 的一个路由中间件，首先我们把依赖的模块安装一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm i koa koa-router lowdb -S\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后创建一个 server.js，代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const Koa = require('koa')\nconst path = require('path')\nconst Router = require('koa-router')\nconst low = require('lowdb')\nconst FileSync = require('lowdb/adapters/FileSync')\n\n// 创建一个 Koa 服务实例\nconst app = new Koa()\n// 创建一个路由的实例\nconst router = new Router()\n// 创建一个数据库实例，这里用 lowdb 的 JSON 存储来模拟数据库而已\nconst adapter = new FileSync(path.resolve(__dirname, './db.json'))\nconst db = low(adapter)\n\n// 初始化数据库，可以看做是数据库的字段定义\ndb.defaults({visits: [], count: 0}).write()\n\n// 当有请求进来，路由中间件的异步回调会被执行\nrouter.get('/', async (ctx, next) => {\n  const ip = ctx.header['x-real-ip'] || ''\n  const { user, page, action } = ctx.query\n\n  // 更新数据库\n  db.get('visits').push({ip, user, page, action}).write()\n  db.update('count', n => n + 1).write()\n\n  // 返回更新后的数据库字段\n  ctx.body = {success: 1, visits: db.get('count')}\n})\n\n// 把中间件压入队列，等待执行\napp\n  .use(router.routes())\n  .use(router.allowedMethods())\n  .listen(7000)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在命令行 ",(0,s.jsx)(n.code,{children:"node server.js"})," 把服务开起来后，可以从浏览器通过： ",(0,s.jsx)(n.code,{children:"[http://localhost:7000/?user=a&page=1&action=click](http://localhost:7000/?user=a&page=1&action=click)"})," 来访问，或者从命令里面 ",(0,s.jsx)(n.code,{children:"curl [http://localhost:7000/?user=a&page=1&action=click](http://localhost:7000/?user=a&page=1&action=click)"}),"，多请求几次，就会发现数据都存进去了，在 server.js 的同目录，有一个 db.json，里面的数据大概如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "visits": [\n    {\n      "ip": "",\n      "user": "a",\n      "page": "1",\n      "action": "click"\n    },\n    {\n      "ip": "",\n      "user": "a",\n      "page": "1",\n      "action": "click"\n    }\n  ],\n  "count": 2\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"那么本节给大家布置一个小作业，如果把上一节的 cluster 跟这一节的埋点服务器做结合，来提升服务器的负载能力，代码可以怎么写呢？"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let i=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F12%E6%A1%88%E4%BE%8B%E5%8D%81%E4%B8%80%EF%BC%9A%5B%E5%9F%8B%E7%82%B9%E6%90%9C%E9%9B%86%E6%9C%8D%E5%8A%A1%E5%99%A8%5D%20-%20%E6%80%BB%E7%BB%93%EF%BC%9A%20Koa%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%83%BD%E5%8A%9B.md"]={toc:[{text:"",id:"",depth:3},{text:"编程练习 - 开发一个埋点服务器",id:"编程练习---开发一个埋点服务器",depth:3}],title:"12案例十一：[埋点搜集服务器] - 总结： Koa 服务端框架用到了哪些能力",headingTitle:"12案例十一：[埋点搜集服务器] - 总结： Koa 服务端框架用到了哪些能力",frontmatter:{}}}}]);