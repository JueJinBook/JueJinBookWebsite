"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["90199"],{491041:function(n,e,t){t.r(e),t.d(e,{default:()=>g});var i=t(552676),r=t(740453);let s=t.p+"static/image/51500a0c8c7d35d924581a6cc4a2c458.62143dd2.webp",h=t.p+"static/image/d585af0c8ed9fcc521f2bc4dd0bc76cf.2477cc4b.webp",d=t.p+"static/image/131fe756a0afc4e1ef363aeb6c08eead.6bc43fdb.webp",l=t.p+"static/image/b477900fbd862ced480893b79460b02c.e4d4ae4e.webp",a=t.p+"static/image/0fd1ca218e963d57a0480985727cfc8a.6f11cc5e.webp",o=t.p+"static/image/f1610670c9a4fc24c0beda3b8bd44617.4b0f9915.webp",c=t.p+"static/image/22aecc3b9e0e562ffb426591b6999645.c74a2de2.webp",x=t.p+"static/image/602092b70eb9d6f45a808d2e3a4b4bd4.1c371595.webp",u=t.p+"static/image/1f57badbb8ddf018c4d48b836ce31833.82ff401c.webp";function j(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",pre:"pre",code:"code",h2:"h2",h3:"h3",img:"img",h4:"h4",strong:"strong",ul:"ul"},(0,r.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"32常见数据结构",children:["32.常见数据结构",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#32常见数据结构",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"这一章节我们将来学习数据结构的内容。经常会有人提问说：学习数据结构或者算法对于前端工程师有用么？"}),"\n",(0,i.jsx)(e.p,{children:"总的来说，这些基础学科在短期内收效确实甚微，但是我们首先不要将自己局限在前端工程师这点上。笔者之前是做 iOS 开发的，转做前端以后，只有两个技能还对我有用："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"基础学科内容，比如：网络知识、数据结构算法"}),"\n",(0,i.jsx)(e.li,{children:"编程思想"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"其他 iOS 上积累的经验，转行以后基本就没多大用处了。所以说，当我们把视野放到编程这个角度去说，数据结构算法一定是有用的，并且也是你未来的一个天花板。可以不花费集中的时间去学习这些内容，但是一定需要时常去学习一点，因为这些技能可以实实在在提升你写代码的能力。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-!",children:"这一章节的内容信息量会很大，不适合在非电脑环境下阅读，请各位打开代码编辑器，一行行的敲代码，单纯阅读是学习不了数据结构的。\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"时间复杂度",children:["时间复杂度",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#时间复杂度",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"在进入正题之前，我们先来了解下什么是时间复杂度。"}),"\n",(0,i.jsx)(e.p,{children:"通常使用最差的时间复杂度来衡量一个算法的好坏。"}),"\n",(0,i.jsx)(e.p,{children:"常数时间 O(1) 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。"}),"\n",(0,i.jsx)(e.p,{children:"对于一个算法来说，可能会计算出操作次数为 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。"}),"\n",(0,i.jsx)(e.p,{children:"当然可能会出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了。"}),"\n",(0,i.jsxs)(e.h2,{id:"栈",children:["栈",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#栈",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"概念",children:["概念",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#概念",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"栈是一个线性结构，在计算机中是一个相当常见的数据结构。"}),"\n",(0,i.jsx)(e.p,{children:"栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:u,alt:""})}),"\n",(0,i.jsxs)(e.h3,{id:"实现",children:["实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class Stack {\n  constructor() {\n    this.stack = []\n  }\n  push(item) {\n    this.stack.push(item)\n  }\n  pop() {\n    this.stack.pop()\n  }\n  peek() {\n    return this.stack[this.getCount() - 1]\n  }\n  getCount() {\n    return this.stack.length\n  }\n  isEmpty() {\n    return this.getCount() === 0\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"应用",children:["应用",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#应用",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["选取了 ",(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/valid-parentheses/submissions/1",target:"_blank",rel:"noopener noreferrer",children:"LeetCode 上序号为 20 的题目"})]}),"\n",(0,i.jsx)(e.p,{children:"题意是匹配括号，可以通过栈的特性来完成这道题目"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"var isValid = function (s) {\n  let map = {\n    '(': -1,\n    ')': 1,\n    '[': -2,\n    ']': 2,\n    '{': -3,\n    '}': 3\n  }\n  let stack = []\n  for (let i = 0; i < s.length; i++) {\n    if (map[s[i]] < 0) {\n      stack.push(s[i])\n    } else {\n      let last = stack.pop()\n      if (map[last] + map[s[i]] != 0) return false\n    }\n  }\n  if (stack.length > 0) return false\n  return true\n};\n"})}),"\n",(0,i.jsx)(e.p,{children:"其实在 Vue 中关于模板解析的代码，就有应用到匹配尖括号的内容。"}),"\n",(0,i.jsxs)(e.h2,{id:"队列",children:["队列",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#队列",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"概念-1",children:["概念",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#概念-1",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:x,alt:""})}),"\n",(0,i.jsxs)(e.h3,{id:"实现-1",children:["实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-1",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"这里会讲解两种实现队列的方式，分别是单链队列和循环队列。"}),"\n",(0,i.jsxs)(e.h4,{id:"单链队列",children:["单链队列",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#单链队列",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class Queue {\n  constructor() {\n    this.queue = []\n  }\n  enQueue(item) {\n    this.queue.push(item)\n  }\n  deQueue() {\n    return this.queue.shift()\n  }\n  getHeader() {\n    return this.queue[0]\n  }\n  getLength() {\n    return this.queue.length\n  }\n  isEmpty() {\n    return this.getLength() === 0\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度。"}),"\n",(0,i.jsxs)(e.h4,{id:"循环队列",children:["循环队列",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#循环队列",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class SqQueue {\n  constructor(length) {\n    this.queue = new Array(length + 1)\n    // 队头\n    this.first = 0\n    // 队尾\n    this.last = 0\n    // 当前队列大小\n    this.size = 0\n  }\n  enQueue(item) {\n    // 判断队尾 + 1 是否为队头\n    // 如果是就代表需要扩容数组\n    // % this.queue.length 是为了防止数组越界\n    if (this.first === (this.last + 1) % this.queue.length) {\n      this.resize(this.getLength() * 2 + 1)\n    }\n    this.queue[this.last] = item\n    this.size++\n    this.last = (this.last + 1) % this.queue.length\n  }\n  deQueue() {\n    if (this.isEmpty()) {\n      throw Error('Queue is empty')\n    }\n    let r = this.queue[this.first]\n    this.queue[this.first] = null\n    this.first = (this.first + 1) % this.queue.length\n    this.size--\n    // 判断当前队列大小是否过小\n    // 为了保证不浪费空间，在队列空间等于总长度四分之一时\n    // 且不为 2 时缩小总长度为当前的一半\n    if (this.size === this.getLength() / 4 && this.getLength() / 2 !== 0) {\n      this.resize(this.getLength() / 2)\n    }\n    return r\n  }\n  getHeader() {\n    if (this.isEmpty()) {\n      throw Error('Queue is empty')\n    }\n    return this.queue[this.first]\n  }\n  getLength() {\n    return this.queue.length - 1\n  }\n  isEmpty() {\n    return this.first === this.last\n  }\n  resize(length) {\n    let q = new Array(length)\n    for (let i = 0; i < length; i++) {\n      q[i] = this.queue[(i + this.first) % this.queue.length]\n    }\n    this.queue = q\n    this.first = 0\n    this.last = this.size\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"链表",children:["链表",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#链表",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"概念-2",children:["概念",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#概念-2",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:c,alt:""})}),"\n",(0,i.jsxs)(e.h3,{id:"实现-2",children:["实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-2",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"单向链表"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class Node {\n  constructor(v, next) {\n    this.value = v\n    this.next = next\n  }\n}\nclass LinkList {\n  constructor() {\n    // 链表长度\n    this.size = 0\n    // 虚拟头部\n    this.dummyNode = new Node(null, null)\n  }\n  find(header, index, currentIndex) {\n    if (index === currentIndex) return header\n    return this.find(header.next, index, currentIndex + 1)\n  }\n  addNode(v, index) {\n    this.checkIndex(index)\n    // 当往链表末尾插入时，prev.next 为空\n    // 其他情况时，因为要插入节点，所以插入的节点\n    // 的 next 应该是 prev.next\n    // 然后设置 prev.next 为插入的节点\n    let prev = this.find(this.dummyNode, index, 0)\n    prev.next = new Node(v, prev.next)\n    this.size++\n    return prev.next\n  }\n  insertNode(v, index) {\n    return this.addNode(v, index)\n  }\n  addToFirst(v) {\n    return this.addNode(v, 0)\n  }\n  addToLast(v) {\n    return this.addNode(v, this.size)\n  }\n  removeNode(index, isLast) {\n    this.checkIndex(index)\n    index = isLast ? index - 1 : index\n    let prev = this.find(this.dummyNode, index, 0)\n    let node = prev.next\n    prev.next = node.next\n    node.next = null\n    this.size--\n    return node\n  }\n  removeFirstNode() {\n    return this.removeNode(0)\n  }\n  removeLastNode() {\n    return this.removeNode(this.size, true)\n  }\n  checkIndex(index) {\n    if (index < 0 || index > this.size) throw Error('Index error')\n  }\n  getNode(index) {\n    this.checkIndex(index)\n    if (this.isEmpty()) return\n    return this.find(this.dummyNode, index, 0).next\n  }\n  isEmpty() {\n    return this.size === 0\n  }\n  getSize() {\n    return this.size\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"树",children:["树",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#树",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"二叉树",children:["二叉树",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二叉树",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。"}),"\n",(0,i.jsx)(e.p,{children:"二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:o,alt:""})}),"\n",(0,i.jsxs)(e.h3,{id:"二分搜索树",children:["二分搜索树",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二分搜索树",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。"}),"\n",(0,i.jsx)(e.p,{children:"这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsxs)(e.h3,{id:"实现-3",children:["实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-3",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class Node {\n  constructor(value) {\n    this.value = value\n    this.left = null\n    this.right = null\n  }\n}\nclass BST {\n  constructor() {\n    this.root = null\n    this.size = 0\n  }\n  getSize() {\n    return this.size\n  }\n  isEmpty() {\n    return this.size === 0\n  }\n  addNode(v) {\n    this.root = this._addChild(this.root, v)\n  }\n  // 添加节点时，需要比较添加的节点值和当前\n  // 节点值的大小\n  _addChild(node, v) {\n    if (!node) {\n      this.size++\n      return new Node(v)\n    }\n    if (node.value > v) {\n      node.left = this._addChild(node.left, v)\n    } else if (node.value < v) {\n      node.right = this._addChild(node.right, v)\n    }\n    return node\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"以上是最基本的二分搜索树实现，接下来实现树的遍历。"}),"\n",(0,i.jsx)(e.p,{children:"对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"// 先序遍历可用于打印树的结构\n// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。\npreTraversal() {\n  this._pre(this.root)\n}\n_pre(node) {\n  if (node) {\n    console.log(node.value)\n    this._pre(node.left)\n    this._pre(node.right)\n  }\n}\n// 中序遍历可用于排序\n// 对于 BST 来说，中序遍历可以实现一次遍历就\n// 得到有序的值\n// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。\nmidTraversal() {\n  this._mid(this.root)\n}\n_mid(node) {\n  if (node) {\n    this._mid(node.left)\n    console.log(node.value)\n    this._mid(node.right)\n  }\n}\n// 后序遍历可用于先操作子节点\n// 再操作父节点的场景\n// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。\nbackTraversal() {\n  this._back(this.root)\n}\n_back(node) {\n  if (node) {\n    this._back(node.left)\n    this._back(node.right)\n    console.log(node.value)\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"breadthTraversal() {\n  if (!this.root) return null\n  let q = new Queue()\n  // 将根节点入队\n  q.enQueue(this.root)\n  // 循环判断队列是否为空，为空\n  // 代表树遍历完毕\n  while (!q.isEmpty()) {\n    // 将队首出队，判断是否有左右子树\n    // 有的话，就先左后右入队\n    let n = q.deQueue()\n    console.log(n.value)\n    if (n.left) q.enQueue(n.left)\n    if (n.right) q.enQueue(n.right)\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"getMin() {\n  return this._getMin(this.root).value\n}\n_getMin(node) {\n  if (!node.left) return node\n  return this._getMin(node.left)\n}\ngetMax() {\n  return this._getMax(this.root).value\n}\n_getMax(node) {\n  if (!node.right) return node\n  return this._getMin(node.right)\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"向上取整和向下取整"}),"，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"floor(v) {\n  let node = this._floor(this.root, v)\n  return node ? node.value : null\n}\n_floor(node, v) {\n  if (!node) return null\n  if (node.value === v) return v\n  // 如果当前节点值还比需要的值大，就继续递归\n  if (node.value > v) {\n    return this._floor(node.left, v)\n  }\n  // 判断当前节点是否拥有右子树\n  let right = this._floor(node.right, v)\n  if (right) return right\n  return node\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"排名"}),"，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 ",(0,i.jsx)(e.code,{children:"size"})," 属性。该属性表示该节点下有多少子节点（包含自身）。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class Node {\n  constructor(value) {\n    this.value = value\n    this.left = null\n    this.right = null\n    // 修改代码\n    this.size = 1\n  }\n}\n// 新增代码\n_getSize(node) {\n  return node ? node.size : 0\n}\n_addChild(node, v) {\n  if (!node) {\n    return new Node(v)\n  }\n  if (node.value > v) {\n    // 修改代码\n    node.size++\n    node.left = this._addChild(node.left, v)\n  } else if (node.value < v) {\n    // 修改代码\n    node.size++\n    node.right = this._addChild(node.right, v)\n  }\n  return node\n}\nselect(k) {\n  let node = this._select(this.root, k)\n  return node ? node.value : null\n}\n_select(node, k) {\n  if (!node) return null\n  // 先获取左子树下有几个节点\n  let size = node.left ? node.left.size : 0\n  // 判断 size 是否大于 k\n  // 如果大于 k，代表所需要的节点在左节点\n  if (size > k) return this._select(node.left, k)\n  // 如果小于 k，代表所需要的节点在右节点\n  // 注意这里需要重新计算 k，减去根节点除了右子树的节点数量\n  if (size < k) return this._select(node.right, k - size - 1)\n  return node\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"需要删除的节点没有子树"}),"\n",(0,i.jsx)(e.li,{children:"需要删除的节点只有一条子树"}),"\n",(0,i.jsx)(e.li,{children:"需要删除的节点有左右两条树"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"delectMin() {\n  this.root = this._delectMin(this.root)\n  console.log(this.root)\n}\n_delectMin(node) {\n  // 一直递归左子树\n  // 如果左子树为空，就判断节点是否拥有右子树\n  // 有右子树的话就把需要删除的节点替换为右子树\n  if ((node != null) & !node.left) return node.right\n  node.left = this._delectMin(node.left)\n  // 最后需要重新维护下节点的 `size`\n  node.size = this._getSize(node.left) + this._getSize(node.right) + 1\n  return node\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。"}),"\n",(0,i.jsx)(e.p,{children:"当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。"}),"\n",(0,i.jsx)(e.p,{children:"你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"delect(v) {\n  this.root = this._delect(this.root, v)\n}\n_delect(node, v) {\n  if (!node) return null\n  // 寻找的节点比当前节点小，去左子树找\n  if (node.value < v) {\n    node.right = this._delect(node.right, v)\n  } else if (node.value > v) {\n    // 寻找的节点比当前节点大，去右子树找\n    node.left = this._delect(node.left, v)\n  } else {\n    // 进入这个条件说明已经找到节点\n    // 先判断节点是否拥有拥有左右子树中的一个\n    // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样\n    if (!node.left) return node.right\n    if (!node.right) return node.left\n    // 进入这里，代表节点拥有左右子树\n    // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值\n    let min = this._getMin(node.right)\n    // 取出最小值后，删除最小值\n    // 然后把删除节点后的子树赋值给最小值节点\n    min.right = this._delectMin(node.right)\n    // 左子树不动\n    min.left = node.left\n    node = min\n  }\n  // 维护 size\n  node.size = this._getSize(node.left) + this._getSize(node.right) + 1\n  return node\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"avl-树",children:["AVL 树",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#avl-树",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"概念-3",children:["概念",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#概念-3",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。"}),"\n",(0,i.jsx)(e.p,{children:"AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。"}),"\n",(0,i.jsxs)(e.h3,{id:"实现-4",children:["实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-4",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"因为 AVL 树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不作再次解析。"}),"\n",(0,i.jsx)(e.p,{children:"对于 AVL 树来说，添加节点会有四种情况"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"对于左左情况来说，新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。"}),"\n",(0,i.jsx)(e.p,{children:"旋转之前：new < 2 < C < 3 < B < 5 < A，右旋之后节点 3 为根节点，这时候需要将节点 3 的右节点加到节点 5 的左边，最后还需要更新节点的高度。"}),"\n",(0,i.jsx)(e.p,{children:"对于右右情况来说，相反于左左情况，所以不再赘述。"}),"\n",(0,i.jsx)(e.p,{children:"对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来达到目的。"}),"\n",(0,i.jsx)(e.p,{children:"首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class Node {\n  constructor(value) {\n    this.value = value\n    this.left = null\n    this.right = null\n    this.height = 1\n  }\n}\n\nclass AVL {\n  constructor() {\n    this.root = null\n  }\n  addNode(v) {\n    this.root = this._addChild(this.root, v)\n  }\n  _addChild(node, v) {\n    if (!node) {\n      return new Node(v)\n    }\n    if (node.value > v) {\n      node.left = this._addChild(node.left, v)\n    } else if (node.value < v) {\n      node.right = this._addChild(node.right, v)\n    } else {\n      node.value = v\n    }\n    node.height =\n      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))\n    let factor = this._getBalanceFactor(node)\n    // 当需要右旋时，根节点的左树一定比右树高度高\n    if (factor > 1 && this._getBalanceFactor(node.left) >= 0) {\n      return this._rightRotate(node)\n    }\n    // 当需要左旋时，根节点的左树一定比右树高度矮\n    if (factor < -1 && this._getBalanceFactor(node.right) <= 0) {\n      return this._leftRotate(node)\n    }\n    // 左右情况\n    // 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高\n    if (factor > 1 && this._getBalanceFactor(node.left) < 0) {\n      node.left = this._leftRotate(node.left)\n      return this._rightRotate(node)\n    }\n    // 右左情况\n    // 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮\n    if (factor < -1 && this._getBalanceFactor(node.right) > 0) {\n      node.right = this._rightRotate(node.right)\n      return this._leftRotate(node)\n    }\n\n    return node\n  }\n  _getHeight(node) {\n    if (!node) return 0\n    return node.height\n  }\n  _getBalanceFactor(node) {\n    return this._getHeight(node.left) - this._getHeight(node.right)\n  }\n  // 节点右旋\n  //           5                    2\n  //         /   \\                /   \\\n  //        2     6   ==>       1      5\n  //       /  \\               /       /  \\\n  //      1    3             new     3    6\n  //     /\n  //    new\n  _rightRotate(node) {\n    // 旋转后新根节点\n    let newRoot = node.left\n    // 需要移动的节点\n    let moveNode = newRoot.right\n    // 节点 2 的右节点改为节点 5\n    newRoot.right = node\n    // 节点 5 左节点改为节点 3\n    node.left = moveNode\n    // 更新树的高度\n    node.height =\n      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))\n    newRoot.height =\n      1 +\n      Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right))\n\n    return newRoot\n  }\n  // 节点左旋\n  //           4                    6\n  //         /   \\                /   \\\n  //        2     6   ==>       4      7\n  //             /  \\         /   \\      \\\n  //            5     7      2     5      new\n  //                   \\\n  //                    new\n  _leftRotate(node) {\n    // 旋转后新根节点\n    let newRoot = node.right\n    // 需要移动的节点\n    let moveNode = newRoot.left\n    // 节点 6 的左节点改为节点 4\n    newRoot.left = node\n    // 节点 4 右节点改为节点 5\n    node.right = moveNode\n    // 更新树的高度\n    node.height =\n      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))\n    newRoot.height =\n      1 +\n      Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right))\n\n    return newRoot\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"trie",children:["Trie",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#trie",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"概念-4",children:["概念",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#概念-4",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["在计算机科学，",(0,i.jsx)(e.strong,{children:"trie"}),"，又称",(0,i.jsx)(e.strong,{children:"前缀树"}),"或",(0,i.jsx)(e.strong,{children:"字典树"}),"，是一种有序树，用于保存关联数组，其中的键通常是字符串。"]}),"\n",(0,i.jsx)(e.p,{children:"简单点来说，这个结构的作用大多是为了方便搜索字符串，该树有以下几个特点"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"根节点代表空字符串，每个节点都有 N（假如搜索英文字符，就有 26 条） 条链接，每条链接代表一个字符"}),"\n",(0,i.jsx)(e.li,{children:"节点不存储字符，只有路径才存储，这点和其他的树结构不同"}),"\n",(0,i.jsx)(e.li,{children:"从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)("img",{src:d,alt:""}),"、"]}),"\n",(0,i.jsxs)(e.h3,{id:"实现-5",children:["实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-5",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"总得来说 Trie 的实现相比别的树结构来说简单的很多，实现就以搜索英文字符为例。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class TrieNode {\n  constructor() {\n    // 代表每个字符经过节点的次数\n    this.path = 0\n    // 代表到该节点的字符串有几个\n    this.end = 0\n    // 链接\n    this.next = new Array(26).fill(null)\n  }\n}\nclass Trie {\n  constructor() {\n    // 根节点，代表空字符\n    this.root = new TrieNode()\n  }\n  // 插入字符串\n  insert(str) {\n    if (!str) return\n    let node = this.root\n    for (let i = 0; i < str.length; i++) {\n      // 获得字符先对应的索引\n      let index = str[i].charCodeAt() - 'a'.charCodeAt()\n      // 如果索引对应没有值，就创建\n      if (!node.next[index]) {\n        node.next[index] = new TrieNode()\n      }\n      node.path += 1\n      node = node.next[index]\n    }\n    node.end += 1\n  }\n  // 搜索字符串出现的次数\n  search(str) {\n    if (!str) return\n    let node = this.root\n    for (let i = 0; i < str.length; i++) {\n      let index = str[i].charCodeAt() - 'a'.charCodeAt()\n      // 如果索引对应没有值，代表没有需要搜素的字符串\n      if (!node.next[index]) {\n        return 0\n      }\n      node = node.next[index]\n    }\n    return node.end\n  }\n  // 删除字符串\n  delete(str) {\n    if (!this.search(str)) return\n    let node = this.root\n    for (let i = 0; i < str.length; i++) {\n      let index = str[i].charCodeAt() - 'a'.charCodeAt()\n      // 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串\n      // 已经一个，直接删除即可\n      if (--node.next[index].path == 0) {\n        node.next[index] = null\n        return\n      }\n      node = node.next[index]\n    }\n    node.end -= 1\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"并查集",children:["并查集",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#并查集",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"概念-5",children:["概念",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#概念-5",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"并查集是一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。"}),"\n",(0,i.jsx)(e.p,{children:"这个结构中有两个重要的操作，分别是："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。"}),"\n",(0,i.jsx)(e.li,{children:"Union：将两个子集合并成同一个集合。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:h,alt:""})}),"\n",(0,i.jsxs)(e.h3,{id:"实现-6",children:["实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-6",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class DisjointSet {\n  // 初始化样本\n  constructor(count) {\n    // 初始化时，每个节点的父节点都是自己\n    this.parent = new Array(count)\n    // 用于记录树的深度，优化搜索复杂度\n    this.rank = new Array(count)\n    for (let i = 0; i < count; i++) {\n      this.parent[i] = i\n      this.rank[i] = 1\n    }\n  }\n  find(p) {\n    // 寻找当前节点的父节点是否为自己，不是的话表示还没找到\n    // 开始进行路径压缩优化\n    // 假设当前节点父节点为 A\n    // 将当前节点挂载到 A 节点的父节点上，达到压缩深度的目的\n    while (p != this.parent[p]) {\n      this.parent[p] = this.parent[this.parent[p]]\n      p = this.parent[p]\n    }\n    return p\n  }\n  isConnected(p, q) {\n    return this.find(p) === this.find(q)\n  }\n  // 合并\n  union(p, q) {\n    // 找到两个数字的父节点\n    let i = this.find(p)\n    let j = this.find(q)\n    if (i === j) return\n    // 判断两棵树的深度，深度小的加到深度大的树下面\n    // 如果两棵树深度相等，那就无所谓怎么加\n    if (this.rank[i] < this.rank[j]) {\n      this.parent[i] = j\n    } else if (this.rank[i] > this.rank[j]) {\n      this.parent[j] = i\n    } else {\n      this.parent[i] = j\n      this.rank[j] += 1\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"堆",children:["堆",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#堆",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"概念-6",children:["概念",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#概念-6",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"堆通常是一个可以被看做一棵树的数组对象。"}),"\n",(0,i.jsxs)(e.p,{children:["堆的实现通过构造",(0,i.jsx)(e.strong,{children:"二叉堆"}),"，实为二叉树的一种。这种数据结构具有以下性质。"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"任意节点小于（或大于）它的所有子节点"}),"\n",(0,i.jsx)(e.li,{children:"堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["将根节点最大的堆叫做",(0,i.jsx)(e.strong,{children:"最大堆"}),"或",(0,i.jsx)(e.strong,{children:"大根堆"}),"，根节点最小的堆叫做",(0,i.jsx)(e.strong,{children:"最小堆"}),"或",(0,i.jsx)(e.strong,{children:"小根堆"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"优先队列也完全可以用堆来实现，操作是一模一样的。"}),"\n",(0,i.jsxs)(e.h3,{id:"实现大根堆",children:["实现大根堆",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现大根堆",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["堆的每个节点的左边子节点索引是 ",(0,i.jsx)(e.code,{children:"i * 2 + 1"}),"，右边是 ",(0,i.jsx)(e.code,{children:"i * 2 + 2"}),"，父节点是 ",(0,i.jsx)(e.code,{children:"(i - 1) /2"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:["堆有两个核心的操作，分别是 ",(0,i.jsx)(e.code,{children:"shiftUp"})," 和 ",(0,i.jsx)(e.code,{children:"shiftDown"})," 。前者用于添加元素，后者用于删除根节点。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"shiftUp"})," 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"shiftDown"})," 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:s,alt:""})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"class MaxHeap {\n  constructor() {\n    this.heap = []\n  }\n  size() {\n    return this.heap.length\n  }\n  empty() {\n    return this.size() == 0\n  }\n  add(item) {\n    this.heap.push(item)\n    this._shiftUp(this.size() - 1)\n  }\n  removeMax() {\n    this._shiftDown(0)\n  }\n  getParentIndex(k) {\n    return parseInt((k - 1) / 2)\n  }\n  getLeftIndex(k) {\n    return k * 2 + 1\n  }\n  _shiftUp(k) {\n    // 如果当前节点比父节点大，就交换\n    while (this.heap[k] > this.heap[this.getParentIndex(k)]) {\n      this._swap(k, this.getParentIndex(k))\n      // 将索引变成父节点\n      k = this.getParentIndex(k)\n    }\n  }\n  _shiftDown(k) {\n    // 交换首位并删除末尾\n    this._swap(k, this.size() - 1)\n    this.heap.splice(this.size() - 1, 1)\n    // 判断节点是否有左孩子，因为二叉堆的特性，有右必有左\n    while (this.getLeftIndex(k) < this.size()) {\n      let j = this.getLeftIndex(k)\n      // 判断是否有右孩子，并且右孩子是否大于左孩子\n      if (j + 1 < this.size() && this.heap[j + 1] > this.heap[j]) j++\n      // 判断父节点是否已经比子节点都大\n      if (this.heap[k] >= this.heap[j]) break\n      this._swap(k, j)\n      k = j\n    }\n  }\n  _swap(left, right) {\n    let rightValue = this.heap[right]\n    this.heap[right] = this.heap[left]\n    this.heap[left] = rightValue\n  }\n}\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"小结",children:["小结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["这一章节我们学习了一些常见的数据结构，当然我没有将其他更难的数据结构也放进来，能够掌握这些常见的内容已经足够解决大部分的问题了。当然你如果还想继续深入学习数据结构，可以阅读 ",(0,i.jsx)(e.a,{href:"https://book.douban.com/subject/19952400/",target:"_blank",rel:"noopener noreferrer",children:"算法第四版"})," 以及在 ",(0,i.jsx)(e.a,{href:"https://leetcode-cn.com/problemset/all/",target:"_blank",rel:"noopener noreferrer",children:"leetcode"})," 中实践。"]})]})}function p(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(j,{...n})}):j(n)}let g=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F32.%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md"]={toc:[{text:"时间复杂度",id:"时间复杂度",depth:2},{text:"栈",id:"栈",depth:2},{text:"概念",id:"概念",depth:3},{text:"实现",id:"实现",depth:3},{text:"应用",id:"应用",depth:2},{text:"队列",id:"队列",depth:2},{text:"概念",id:"概念-1",depth:3},{text:"实现",id:"实现-1",depth:3},{text:"单链队列",id:"单链队列",depth:4},{text:"循环队列",id:"循环队列",depth:4},{text:"链表",id:"链表",depth:2},{text:"概念",id:"概念-2",depth:3},{text:"实现",id:"实现-2",depth:3},{text:"树",id:"树",depth:2},{text:"二叉树",id:"二叉树",depth:3},{text:"二分搜索树",id:"二分搜索树",depth:3},{text:"实现",id:"实现-3",depth:3},{text:"AVL 树",id:"avl-树",depth:2},{text:"概念",id:"概念-3",depth:3},{text:"实现",id:"实现-4",depth:3},{text:"Trie",id:"trie",depth:2},{text:"概念",id:"概念-4",depth:3},{text:"实现",id:"实现-5",depth:3},{text:"并查集",id:"并查集",depth:2},{text:"概念",id:"概念-5",depth:3},{text:"实现",id:"实现-6",depth:3},{text:"堆",id:"堆",depth:2},{text:"概念",id:"概念-6",depth:3},{text:"实现大根堆",id:"实现大根堆",depth:3},{text:"小结",id:"小结",depth:2}],title:"32.常见数据结构",headingTitle:"32.常见数据结构",frontmatter:{}}}}]);