"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57463"],{571884:function(n,e,r){r.r(e),r.d(e,{default:()=>x});var d=r(552676),i=r(740453);function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li"},(0,i.ah)(),n.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.h1,{id:"第11章数据结构进阶实现原理和设计思路",children:["第11章—数据结构进阶：实现原理和设计思路",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第11章数据结构进阶实现原理和设计思路",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"\uFEFF在上一章，我们居高临下地俯瞰了数据结构的基本特性，不过都是一些概念性的东西，我们并没有涉及到具体的编码，那么，这一章我们就从根儿上来拆解下数据结构的设计原理。"}),"\n",(0,d.jsxs)(e.p,{children:["在上一章中，我们讲到：",(0,d.jsx)(e.strong,{children:"线性数据结构之间的元素是一对一的"}),"。并且我们知道它分为顺序表和链表，",(0,d.jsx)(e.strong,{children:"而顺序表要求元素之间要互相挨着"}),"，这好像是",(0,d.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196589257459236904",target:"_blank",rel:"noopener noreferrer",children:"第 4 章"}),"中我们讲过的数组啊，数组不正是这个特性吗？"]}),"\n",(0,d.jsx)(e.p,{children:"那岂不是直接拿着数组就能当顺序表用吗？"}),"\n",(0,d.jsx)(e.p,{children:"嗯，差不多了，那顺序表肯定就是用数组实现的，我们就来设计下。"}),"\n",(0,d.jsxs)(e.h2,{id:"顺序表",children:["顺序表",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#顺序表",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"数组是具体的数据类型，顺序表只是个抽象的概念，那我们就用数组这个具体的类型来实现顺序表这个抽象概念。"}),"\n",(0,d.jsx)(e.p,{children:"我们知道，对于数组来说，访问、修改元素，都是通过下标实现的，比如："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"int[] arr;\n// 访问\nint a = arr[i];\n// 修改\narr[i] = 10;\n"})}),"\n",(0,d.jsx)(e.p,{children:"这极其不方便，寡人不关心你的下标是多少，我只想往里放，从里取，然后传个下标就给我返回对应的元素，这样行吗？"}),"\n",(0,d.jsx)(e.p,{children:"可以！那么，怎么实现呢？"}),"\n",(0,d.jsxs)(e.p,{children:["很简单，我们就用数组，然后根据下标",(0,d.jsx)(e.code,{children:"index"}),"去操作元素，存放元素的时候就让",(0,d.jsx)(e.code,{children:"index+1"}),"，取元素的时候就让",(0,d.jsx)(e.code,{children:"index-1"}),"，访问指定下标元素的时候，直接返回",(0,d.jsx)(e.code,{children:"index"}),"对应的元素就行。"]}),"\n",(0,d.jsx)(e.p,{children:"上代码："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"// 名字就先这么委屈地叫着吧\nclass XianxingBiao {\n    // 初始化一个大小为10的数组 \n    private int[] arr = new int[10]();\n    // 当前元素的下标，默认是没有的，所以就是-1\n    privage int curIndex = -1;\n    \n    // 存放元素\n    public void put(int num) {\n        // 下标+1，然后再存放元素\n        arr[++curIndex] = a;\n    }\n    \n    // 获取元素，可能会下标越界，直接返回，效率好高\n    public int get(int index) {\n        return arr[index];\n    }\n    \n    // 在指定位置插入元素，效率好低啊\n    public int add(int num, int index) {\n        // 我们前面讲过了，需要将index以及后面的元素全部往后挪一步\n        \n        // 第一步，先把index以及后面的元素挪一步，我们要从后往前开始，因为前面的移动会覆盖后面的\n        for(int i = arr.length-1; i > index; i--) {\n            arr[i] = arr[i-1];\n        }\n        \n        // 第二步，上面已经把arr[index]空出来了，那就直接放新值就行\n        arr[index] = num;\n    }\n    \n    // 删除指定位置的元素，效率好低啊\n    public void remove(int index){\n        // 我们前面讲过了，需要将index后面的元素全部往前挪一步\n        \n        // 这里的需要从index开始，因为后面的移动会覆盖前面的\n        for(int i = index; i <= arr.length-2;i++) {\n            arr[i] = arr[i+1];\n        }\n    }\n\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"有人说，添加元素是两步，删除元素为啥是一步呢？不应该先把那个位置空出来，然后再把后面元素往前挪移吗？"}),"\n",(0,d.jsxs)(e.p,{children:["不用！你直接挪移元素，后面的就会把",(0,d.jsx)(e.code,{children:"index"}),"位置的覆盖了，那不就等于删除了吗？何必多此一举呢。"]}),"\n",(0,d.jsx)(e.p,{children:"还有问题啊，上面的数组，创建的时候大小是 10，添加元素或者插入元素的时候，如果放不下，怎么办呢？"}),"\n",(0,d.jsxs)(e.p,{children:["扩容！我们在",(0,d.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196588835345465384",target:"_blank",rel:"noopener noreferrer",children:"第 5 章"}),"也讲过，要",(0,d.jsx)(e.strong,{children:"尽量选择易变的数据结构"}),"，那么我们设计的也肯定要这样。",(0,d.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196589257459236904",target:"_blank",rel:"noopener noreferrer",children:"第 4 章"}),"我们也说了，数组的扩容很费劲，究竟有多费劲呢？就是只能新建一个大的，把老的挨个复制进去，这性能确实酸爽。"]}),"\n",(0,d.jsx)(e.p,{children:"我们来看扩容的代码："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"class XianxingBiao {\n    // 初始化一个大小为10的数组 \n    private int[] arr = new int[10]();\n    // 当前元素的下标，默认是没有的，所以就是-1\n    privage int curIndex = -1;\n    \n    // 扩容\n    private void resize() {\n        // 还记得左移吗，就是乘以2，也就是新的数组大小是老的2倍，就是20\n        int newSize = arr.length << 1;\n        int[] newArray = new int[newSize];\n        \n        // 把老数组元素挨个拷贝到新数组中\n        for(int i = 0; i < arr.length; i++) {\n            newArray[i] = arr[i];\n        }\n        \n        // 还记得吗？数组是个对象，对象是个引用，改变引用的值就是改变指向的对象\n        arr = newArray();\n    }\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"上述我们创建一个新数组，将老数组元素按顺序拷贝过去，然后将新数组赋值给老数组，这样，老数组就完成了扩容，简单粗暴。"}),"\n",(0,d.jsxs)(e.p,{children:["那么，我们在 ",(0,d.jsx)(e.code,{children:"put()"}),"和",(0,d.jsx)(e.code,{children:"add()"}),"之前，就要先检查下是否能存放下，如果存放不下，那么就先扩容。如下："]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"class XianxingBiao {\n     // 存放元素\n    public void put(int num) {\n        // 如果当前元素已经到头了，就是没位置了，就要扩容\n        if(curIndex == arr.length-1) {\n            resize();\n        }\n        ...其他代码\n    }\n    \n    // 在指定位置插入元素\n    public int add(int num, int index) {\n        // 如果当前元素已经到头了，就是没位置了，就要扩容\n        if(curIndex == arr.length-1) {\n            resize();\n        }\n        ...其他代码\n    }\n}\n"})}),"\n",(0,d.jsxs)(e.p,{children:["好，这样我们就解决了“",(0,d.jsx)(e.strong,{children:"我们的顺序表不是易变的数据结构"}),"”这个问题。"]}),"\n",(0,d.jsxs)(e.p,{children:["这实现是实现了，不过这拷贝一份儿，这效率也太低了。嗯，你可以将数组的初始容量变大一些，但是这样就可能浪费空间；所以，你要考虑你的需求场景，如果是数据量很大的，就不妨将数组初始容量改大一些，避免频繁扩容带来的开销；如果数据量不大，那么就小一些，达到节省内存的效果。如果你真的是插入/删除得频繁，那就可以考虑下下面的",(0,d.jsx)(e.strong,{children:"链式表"}),"。"]}),"\n",(0,d.jsx)(e.p,{children:"行，不过这名字也太难听了，这汉语拼音英语吗，受不了。"}),"\n",(0,d.jsx)(e.p,{children:"那就改名字。"}),"\n",(0,d.jsxs)(e.p,{children:["我们是使用数组实现的顺序表，数组就是 Array，表就是 List，那就取爹的姓妈的名，就叫 ",(0,d.jsx)(e.strong,{children:"ArrayList"})," 吧。这正是 Java 中的顺序表的名字。"]}),"\n",(0,d.jsx)(e.p,{children:"好，名字也改了，我们就来看看链式表吧。"}),"\n",(0,d.jsxs)(e.h2,{id:"链表",children:["链表",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#链表",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["其实我们在",(0,d.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196588835345465384",target:"_blank",rel:"noopener noreferrer",children:"第 5 章"}),"末尾就自定义过一个链表，只不过有点糙，这里我们就加以完善下。"]}),"\n",(0,d.jsxs)(e.p,{children:["我们需要提供跟上述",(0,d.jsx)(e.code,{children:"ArrayList"}),"一样的 API 来供程序员使用，公平起见，我们就起名为",(0,d.jsx)(e.code,{children:"LinkedList"}),"。我们直接上代码："]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"// 定义元素Node\nclass Node {\n    // 存放数值 \n    int value;\n    // 存放下一个元素的值\n    Node next;\n    // 构造函数\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n    \n    Node(int value) {\n        this.value = value;\n    }\n}\n"})}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"class LinkedList {\n    // 第一个元素\n    private Node first;\n    \n    // 添加元素\n    public void put(int num) {\n        // 创建新节点，新节点是在后面的，所以next就是null\n        Node node = new Node(num, null);\n        \n        // 如果链表为空，这就是第一个节点，否则就加到链表后边\n        if(first == null) {\n            first = node;\n        } else {\n            first.next = node;\n        }\n    }\n    \n    // 访问第index个元素，效率好低啊\n    public int get(int index) {\n        // 只能硬着头皮从前往后数index个元素\n        int i = index;\n        Node curNode = first;\n        while(i > 0) {\n            // 这里可能有空指针，我们暂不考虑\n            curNode = curNode.next;\n            i--;\n        }\n        return curNode.value;\n    }\n    \n    // 插入元素，效率好高啊\n    public void add(int num, int index) {\n        // 第一步，找到要插入的节点位置\n        Node node = first;\n        // 这里要先做减法，比如要插在3号位，就要找到2号位置即可。\n        while(--index > 0) node = node.next; \n        \n        // 第二步，插入元素，现在假设我们找到了2号位置\n        Node newNode = new Node(num);\n        newNode.next = node.next;\n        node.next = newNode;\n    }\n    \n    // 删除元素，效率好高啊\n    public void remove(int num, int index) {\n        // 第一步，找到要删除的点\n        Node node = first;\n        // 这里要先做减法，比如要插在3号位，就要找到2号位置即可。\n        while(--index > 0) node = node.next;\n        \n        // 第二步，删除元素，直接让前面的next指向要删除的next就行\n        node.next = node.next.next;\n    }\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"猛一看可能有点懵，我们来具体分析，假如链表如下（不懵的可以跳过哈）："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"A -> B -> D -> E"})}),"\n",(0,d.jsxs)(e.p,{children:["我们要在 D 位置插入 C，也就是要变成：",(0,d.jsx)(e.strong,{children:"A -> B -> C -> D -> E"}),"。"]}),"\n",(0,d.jsxs)(e.p,{children:["那我们首先就找到 B，然后创建出 C 节点。然后就让： ",(0,d.jsx)(e.code,{children:"C.next = D"}),"；但是我们没法直接拿到 D，我们就通过 B 来拿到 D，也就是：",(0,d.jsx)(e.code,{children:"C.next = B.next"}),"，此时，C 的 next 就是 D 了。这一步之后，我们的链表就变成了："]}),"\n",(0,d.jsxs)(e.p,{children:["没错，那接下来，就需要让 B 指向 C 就行了，也就是： ",(0,d.jsx)(e.code,{children:"B.next = C"}),"。修改过后，我们的链表就变成了："]}),"\n",(0,d.jsx)(e.p,{children:"可以看到，C 已经正确地插入了链表中。"}),"\n",(0,d.jsx)(e.p,{children:"我们的执行步骤是："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"C.next = B.next;\nB.next = C;\n"})}),"\n",(0,d.jsxs)(e.p,{children:["其中，B 就是",(0,d.jsx)(e.code,{children:"add()"}),"方法中的 node，C 就是",(0,d.jsx)(e.code,{children:"add()"}),"方法中的 newNode。"]}),"\n",(0,d.jsx)(e.p,{children:"有人说，我先让 B 指向 C，再让 C 指向 D 不行吗，也就是："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"B.next = C;\nC.next = B.next;\n"})}),"\n",(0,d.jsxs)(e.p,{children:["不行，因为你一旦执行",(0,d.jsx)(e.code,{children:"B.next = C"}),"；那么",(0,d.jsx)(e.code,{children:"B.next"}),"就变了，后面的",(0,d.jsx)(e.code,{children:"C.next = B.next"}),"就等于",(0,d.jsx)(e.code,{children:"C.next = C"}),"了，明显不对。"]}),"\n",(0,d.jsxs)(e.p,{children:["我们可以概括一点：",(0,d.jsx)(e.strong,{children:"你先把执行的步骤写下来，然后看有哪些是最后用到的，然后就将最后用到的放在后面即可"}),"。比如上面的",(0,d.jsx)(e.code,{children:"B.next"}),"是最后用到的，就把用到它的语句放在最后。"]}),"\n",(0,d.jsx)(e.p,{children:"至于链表的删除，就简单了，直接让 B 指向 C 即可，因为 B 指向 C 的操作隐含了断开 B 和 D 的连接。"}),"\n",(0,d.jsx)(e.p,{children:"有人说，你这效率高个毛啊，插入和删除还要遍历着找吗？这也好意思说效率高？"}),"\n",(0,d.jsxs)(e.p,{children:["大哥喝冰阔罗消消火，你看我们的效率是相对而言的不是。你看隔壁",(0,d.jsx)(e.code,{children:"ArrayList"}),"，它是没遍历，但是它要让后面所有人都挪挪位置，你说是报个数快呢，还是挨个挪一步快呢？"]}),"\n",(0,d.jsxs)(e.h2,{id:"栈和队列",children:["栈和队列",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#栈和队列",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"其实栈和队列的设计很相似，如果出入都是同一头，那么就是栈，比如吃了 yue 出来；如果是一头入一头出，那就是队列，比如吃了拉出来。"}),"\n",(0,d.jsxs)(e.p,{children:["那这个实现起来就丰富了，我们可以用一个数组，每次添加元素都放在后面，每次删除元素也删除后面，这样就是",(0,d.jsx)(e.strong,{children:"栈"}),"。"]}),"\n",(0,d.jsxs)(e.p,{children:["我们每次",(0,d.jsx)(e.code,{children:"push()"}),"（存放元素）的时候，就让",(0,d.jsx)(e.code,{children:"curIndex+1"}),"，也就是往右移，每次",(0,d.jsx)(e.code,{children:"pop()"}),"（删除元素）的时候，就让",(0,d.jsx)(e.code,{children:"curIndex-1"}),"，也就是往左移，这样就等于封死了左边的口，也就达到了",(0,d.jsx)(e.code,{children:"先入后出"}),"的效果。"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"int[] arr = new int[10]();\nint curIndex = -1;\n\n// 入栈，加在后面\nfun push(int num) {\n    arr[++curIndex] = num;\n}\n\n// 出栈，返回后面元素\nfun pop() {\n    return arr[curIndex--];\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"猛一看，没问题，仔细一看，有很多问题。比如：栈空了怎么办？栈满了怎么办？"}),"\n",(0,d.jsxs)(e.p,{children:["这个其实很简单，我们使用下标即可判断，如果",(0,d.jsx)(e.code,{children:"curIndex == arr.length"}),"，那么就表示栈满了；如果",(0,d.jsx)(e.code,{children:"curIndex < 0"}),"，那就表示栈空了。如果栈满了，我们就需要扩容，扩容的方式跟",(0,d.jsx)(e.code,{children:"ArrayList"}),"中的方式一模一样；如果栈空了，我们就要抛出异常或者返回空，以此来告诉调用者。"]}),"\n",(0,d.jsxs)(e.p,{children:["如果我们每次添加元素都放在后面，每次删除元素都删除前面，那么就是",(0,d.jsx)(e.strong,{children:"队列"}),"。"]}),"\n",(0,d.jsxs)(e.p,{children:["如果，我们每次让元素入队之后，都让",(0,d.jsx)(e.code,{children:"pushIndex+1"}),"，也就是右移，这样就指向下一个要入队的位置；每次让元素出队之后，都让",(0,d.jsx)(e.code,{children:"popIndex+1"}),"，这样就指向下一个要出队的元素。"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"int[] arr;\n// 记录入队伍位置\nint pushIndex;\n// 记录出队位置\nint popIndex;\n\n// 入队\nfun inQueue(int num) {\n    arr[pushIndex++] = num;\n}\n\n// 出队\nfun outQueue(int num) {\n    return arr[popIndex++];\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"这个代码也有问题：这样出出入入来几次，马上就到头了，这样数组前面的元素空间不就浪费了吗？"}),"\n",(0,d.jsx)(e.p,{children:"这可咋整，我们可以这样？每次操作之后，就将所有元素都挪到左边，这样就可以让右边空出来了。"}),"\n",(0,d.jsx)(e.p,{children:"这也太费劲了，劳资不干！而且这种基操大大降低我代码的段位。有没有什么高级点的方法呢？"}),"\n",(0,d.jsxs)(e.p,{children:["有！",(0,d.jsx)(e.strong,{children:"环形数组！"})]}),"\n",(0,d.jsx)(e.p,{children:"假如，我是说假如，我们把数组头尾相连，也就是 0 和 10 连起来，这样形成一个环，是不是永远都不会到头啊。这样就爽多了。"}),"\n",(0,d.jsx)(e.p,{children:"但是这是不可能的啊，内存条，内存条，都说是条了，怎么会有环呢？嗯，我们物理上实现不了，我们就在逻辑上实现，我们怎么做呢？"}),"\n",(0,d.jsxs)(e.p,{children:["我们每次计算的时候，不用",(0,d.jsx)(e.code,{children:"pushIndex"}),"和",(0,d.jsx)(e.code,{children:"popIndex"}),"了，我们用它们的模，也就是使用",(0,d.jsx)(e.code,{children:"pushIndex % arrayLength"}),"和",(0,d.jsx)(e.code,{children:"popIndex % arrayLength"}),"，其中",(0,d.jsx)(e.code,{children:"arrayLength"}),"是数组的长度。那就变成了："]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"// 假设数组长度是10\nint length = 10;\nint[] arr = new int[length]();\n// 记录入队伍位置\nint pushIndex;\n// 记录出队位置\nint popIndex;\n\n// 入队\nfun inQueue(int num) {\n    arr[pushIndex%length] = num;\n    pushIndex++;\n}\n\n// 出队\nfun outQueue(int num) {\n    return arr[popIndex%length];\n    popIndex++;\n}\n"})}),"\n",(0,d.jsxs)(e.p,{children:["我们假设数组长度为 10，来验证下。如上图，我们存放到下标 9 的时候，",(0,d.jsx)(e.code,{children:"pushIndex++"}),"就变成了 10，对 10 求余就变成了 0，也就是回到了下标为 0 的地方开始存放数据，这是对的。同样，",(0,d.jsx)(e.code,{children:"popIndex"}),"也是对的。"]}),"\n",(0,d.jsx)(e.p,{children:"那么又有问题了，这样怎么判断队列已满，又怎么判断队列为空呢？"}),"\n",(0,d.jsxs)(e.p,{children:["很简单，我们看图，当",(0,d.jsx)(e.code,{children:"pushIndex"}),"不断地存放数据，直到下标 1，也就是",(0,d.jsx)(e.code,{children:"popIndex"}),"的前面，那么队列就放满了，此时： ",(0,d.jsx)(e.strong,{children:"pushIndex+1==popIndex"}),"。"]}),"\n",(0,d.jsxs)(e.p,{children:["同理，如果",(0,d.jsx)(e.code,{children:"popIndex"}),"不断取数据，直到下标为 6，也就是指向",(0,d.jsx)(e.code,{children:"pushIndex"}),"，那么此时队列就空了，此时：",(0,d.jsx)(e.strong,{children:"pushIndex==popIndex"}),"。"]}),"\n",(0,d.jsx)(e.p,{children:"由于我们的数组是环形的，我们的数字需要对长度求余，也就是："}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"队列满：(pushIndex+1)%length == popIndex%10。"}),"\n",(0,d.jsx)(e.li,{children:"队列空：pushIndex%length == popIndex%10。"}),"\n"]}),"\n",(0,d.jsxs)(e.p,{children:["当然，你也可以定义一个 count 值，来记录元素的个数，每次入队就加 1，每次出队就减 1，当",(0,d.jsx)(e.code,{children:"count==length"}),"就是满了，当",(0,d.jsx)(e.code,{children:"count==0"}),"就是空了。"]}),"\n",(0,d.jsxs)(e.p,{children:["我们也可以使用链表来实现栈和队列，这里就不再废话，原理其实就是一个：",(0,d.jsx)(e.strong,{children:"栈就是对一端进行左右挪移，存放就往外挪，删除就往内挪；队列就是对两头进行挪移，出入都往存放那一头挪"}),"。"]}),"\n",(0,d.jsx)(e.p,{children:"大家可以对照示例图仔细体会下这句话。"}),"\n",(0,d.jsxs)(e.h2,{id:"总结",children:["总结",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"本章我们讲了常见数据结构的实现原理，我们没有讲任何 API，就单纯从它们的特点来设计这些数据结构，我们不必拘泥于它们的源码是怎么写的，只要明白其中的道理，写出工程性源码不过是时间问题。我们再来回顾下。"}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:["对于",(0,d.jsx)(e.code,{children:"顺序表"}),"，因为是顺序的，我们就可以用数组来模拟实现，这样就可以通过下标快速定位元素。"]}),"\n",(0,d.jsxs)(e.li,{children:["对于",(0,d.jsx)(e.code,{children:"链表"}),"，因为是分散的，我们就可以用一个一个的节点来实现，然后通过持有下一个节点的引用把它串联起来。"]}),"\n",(0,d.jsxs)(e.li,{children:["对于",(0,d.jsx)(e.code,{children:"栈"}),"和",(0,d.jsx)(e.code,{children:"队列"}),"，实现方案有多种，我们只要理解挪移的方向即可。",(0,d.jsx)(e.strong,{children:"单端存外删内，双端都向存"}),"。"]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"那么下一章，我们就来了解下在开发中如何选择合适的数据结构，以及怎么由一级数据结构构造二级数据结构。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(s,{...n})}):s(n)}let x=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC11%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF.md"]={toc:[{text:"顺序表",id:"顺序表",depth:2},{text:"链表",id:"链表",depth:2},{text:"栈和队列",id:"栈和队列",depth:2},{text:"总结",id:"总结",depth:2}],title:"第11章—数据结构进阶：实现原理和设计思路",headingTitle:"第11章—数据结构进阶：实现原理和设计思路",frontmatter:{}}}}]);