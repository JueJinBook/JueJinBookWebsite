"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["36246"],{139167:function(e,c,n){n.r(c),n.d(c,{default:()=>A});var r=n(552676),d=n(740453);let s=n.p+"static/image/8e36d25169c20ff7527110bec14bf303.a3ea3af5.webp",i=n.p+"static/image/80367d9dd5aa7f3a09a58a5d1973fc51.c31a0bc5.webp",a=n.p+"static/image/6445bb98e59c7ee92e7da41aeebd1923.8b1ee9e5.webp",t=n.p+"static/image/a8d4190517f3b1e98a2bbacf4f4c25f2.a774a89e.webp",l=n.p+"static/image/a2ab82bf725adb05d06e9651820ae2f9.1395d863.webp",p=n.p+"static/image/88492d7c529b119e11e2745042f2caab.bcf04e44.webp",j=n.p+"static/image/cedd5288fa61447593331de4f2f11658.b1b3b432.webp",h=n.p+"static/image/b50bd38c62bde9781a4ada78041a3db2.22e0db58.webp",o=n.p+"static/image/fb50647441ddf6dcd9b952f9fc5306e0.28f4d5c0.webp",x=n.p+"static/image/f11527f16ee586ea541105da478e4089.f8469d01.webp",f=n.p+"static/image/0c291b9463c2ce582195049d70e88214.486ece79.webp",m=n.p+"static/image/afd498b549322f525905ac35dd9284ed.dc4caab3.webp",b=n.p+"static/image/1eaf9cb488b153a9fede3f658655465d.45df5973.webp",g=n.p+"static/image/53e989c40d5858dd4b8a2f23bc27a6c3.f4aa94f4.webp",u=n.p+"static/image/23e8cd8b2ab849a45c6122b18dcfa249.2c718a01.webp",v=n.p+"static/image/716c3ca8ca888bca61b07e7640a6fd32.b3dfaa14.webp",w=n.p+"static/image/ee985ede9dc98c7f8a9fcc9535329af0.170bf806.webp",S=n.p+"static/image/12623a3b2048ef17ff21abf035cd4c02.89850e64.webp";function E(e){let c=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(c.h1,{id:"15-module-和-provider-的循环依赖怎么处理",children:["15. Module 和 Provider 的循环依赖怎么处理？",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#15-module-和-provider-的循环依赖怎么处理",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"Nest 实现了一套模块系统，模块可以通过 imports 声明对其他模块的引用。"}),"\n",(0,r.jsx)(c.p,{children:"那 Module 和 Module 如果相互引用、形成循环依赖了怎么办？"}),"\n",(0,r.jsx)(c.p,{children:"这节我们就来学习下循环依赖的处理方式。"}),"\n",(0,r.jsx)(c.p,{children:"执行"}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{children:"nest new module-test -p npm\n"})}),"\n",(0,r.jsx)(c.p,{children:"创建一个 nest 项目。"}),"\n",(0,r.jsx)(c.p,{children:"然后执行"}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{children:"nest g module aaa\nnest g module bbb\n"})}),"\n",(0,r.jsx)(c.p,{children:"创建两个 Module。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"然后这两个 Module 相互引用。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这时候你执行"}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{children:"nest start -w\n"})}),"\n",(0,r.jsx)(c.p,{children:"把服务跑起来，会报这样的错误："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"意思是在解析 BbbModule 的时候，它的第一个 imports 是 undefined。"}),"\n",(0,r.jsx)(c.p,{children:"这有两个原因，一个是这个值本来就是 undefined，第二个就是形成了循环依赖。"}),"\n",(0,r.jsx)(c.p,{children:"因为 Nest 创建 Module 的时候会递归创建它的依赖，而它的依赖又依赖了这个 Module，所以没法创建成功，拿到的就是 undefined。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"那怎么办呢？"}),"\n",(0,r.jsx)(c.p,{children:"其实我们可以先单独创建这两个 Module，然后再让两者关联起来。"}),"\n",(0,r.jsx)(c.p,{children:"也就是用 forwardRef 的方式："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"因为我们用了 nest start --watch 的方式启动的，nest 会自动重启，这时候就没有错误了："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"nest 会单独创建两个 Module，之后再把 Module 的引用转发过去，也就是 forwardRef 的含义。"}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"除了 Module 和 Module 之间会循环依赖以外，provider 之间也会。"}),"\n",(0,r.jsx)(c.p,{children:"比如 Service 里可以注入别的 Service，自身也可以用来注入。"}),"\n",(0,r.jsx)(c.p,{children:"所以也会有循环引用。"}),"\n",(0,r.jsx)(c.p,{children:"我们来测试下："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{children:"nest g service ccc --no-spec --flat\nnest g service ddd --no-spec --flat\n"})}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"分别创建 ccc 和 ddd 两个 service，--no-spec 是不生成测试文件，--flat 是平铺。"}),"\n",(0,r.jsx)(c.p,{children:"就会创建这两个 service，并在 AppModule 引入了："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"然后我们让两者相互注入："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{className:"language-javascript",children:"import { Injectable } from '@nestjs/common';\nimport { CccService } from './ccc.service';\n\n@Injectable()\nexport class DddService {\n    constructor(private cccService: CccService) {}\n\n    ddd() {\n        return this.cccService.ccc()  + 'ddd';\n    }\n}\n"})}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{className:"language-javascript",children:"import { Injectable } from '@nestjs/common';\nimport { DddService } from './ddd.service';\n\n@Injectable()\nexport class CccService {\n    constructor(private dddService: DddService) {}\n\n    ccc() {\n        return 'ccc';\n    }\n\n    eee() {\n        return this.dddService.ddd() + 'eee';\n    }\n}\n"})}),"\n",(0,r.jsx)(c.p,{children:"两个 service 分别依赖了对方的方法。"}),"\n",(0,r.jsx)(c.p,{children:"在 AppService 里调用下："}),"\n",(0,r.jsx)(c.pre,{children:(0,r.jsx)(c.code,{className:"language-javascript",children:"import { Injectable } from '@nestjs/common';\nimport { CccService } from './ccc.service';\nimport { DddService } from './ddd.service';\n\n@Injectable()\nexport class AppService {\n  constructor(private cccService: CccService, private dddService: DddService){}\n\n  getHello(): string {\n    return this.dddService.ddd() + this.cccService.eee();\n  }\n}\n"})}),"\n",(0,r.jsx)(c.p,{children:"这时候 nest start --watch 会报错："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"说是没法解析 DddService 的依赖，也是因为循环依赖导致的。"}),"\n",(0,r.jsx)(c.p,{children:"这时候也是通过 forwardRef 解决："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"这时候就不能用默认的注入方式了，通过 @Inject 手动指定注入的 token，这里是 forwardRef 的方式注入。"}),"\n",(0,r.jsx)(c.p,{children:"这样报错就没了："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"浏览器访问下："}),"\n",(0,r.jsx)(c.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(c.p,{children:"两个 service 的相互调用也成功了。"}),"\n",(0,r.jsx)(c.p,{children:"这样我们就解决了循环依赖的问题。"}),"\n",(0,r.jsxs)(c.p,{children:["案例代码在",(0,r.jsx)(c.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/circular-dependency",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,r.jsxs)(c.h2,{id:"总结",children:["总结",(0,r.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(c.p,{children:"Module 之间可以相互 imports，Provider 之间可以相互注入，这两者都会形成循环依赖。"}),"\n",(0,r.jsx)(c.p,{children:"解决方式就是两边都用 forwardRef 来包裹下。"}),"\n",(0,r.jsx)(c.p,{children:"它的原理就是 nest 会先创建 Module、Provider，之后再把引用转发到对方，也就是 forward ref。"})]})}function M(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,d.ah)(),e.components);return c?(0,r.jsx)(c,{...e,children:(0,r.jsx)(E,{...e})}):E(e)}let A=M;M.__RSPRESS_PAGE_META={},M.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F15.%20Module%20%E5%92%8C%20Provider%20%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"15. Module 和 Provider 的循环依赖怎么处理？",headingTitle:"15. Module 和 Provider 的循环依赖怎么处理？",frontmatter:{}}}}]);