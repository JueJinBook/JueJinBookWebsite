"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["64704"],{317357:function(e,n,a){a.r(n),a.d(n,{default:()=>H});var r=a(552676),s=a(740453);let c=a.p+"static/image/c896d76ad11a41a67926f0e7e268a547.b2cb7287.webp",i=a.p+"static/image/6b0e160837a7144588d5a6278d45bb1b.cd26ce47.webp",d=a.p+"static/image/150418edf2e692eaa614e840074ea132.6503b266.webp",t=a.p+"static/image/a8795e68dddc8d04a5683ae92c8b769e.df927fdd.webp",p=a.p+"static/image/8e34c373f0bc181b174d76238b63d647.5d5ad41d.webp",l=a.p+"static/image/db145abe3080fe2125e36878dac54e94.69fe0dcc.webp",j=a.p+"static/image/8aab85d9cb86d368f3bf0b5bfc5e6643.06280ffe.webp",x=a.p+"static/image/9d6fb60eaa553cde46bb1719b995abd2.454578b8.webp",h=a.p+"static/image/b60fe9b8a4784e46ae0e802215e68913.eaa17787.webp",m=a.p+"static/image/e5b6f1969baa3220e173b811dda20d43.d9789e44.webp",o=a.p+"static/image/34498aa22f9e3349650c4dc1778031df.c0d95aec.webp",g=a.p+"static/image/0eee23ca818fd31190f93a5af8da1ad6.c8cad3d4.webp",b=a.p+"static/image/aa40731ba39654804fa3ad87a95fd0cd.0db19e1e.webp",u=a.p+"static/image/21dc6b16a0e8a4247d666afe2b0f3164.751b1cab.webp",f=a.p+"static/image/13c3c49f3c2c4c17bec0f774ae78971d.4ca3573b.webp",w=a.p+"static/image/1d22a81220ef9b03fbe074c8186075c0.f8515463.webp",y=a.p+"static/image/1be607e9704c33bb4705df21b32354d0.58b5ad7c.webp",C=a.p+"static/image/98f613a0651162903a6ec9b5cc55c6d9.c7ae78cd.webp",E=a.p+"static/image/f1052da7d870e8e75921e598598afe71.bfd2b230.webp",A=a.p+"static/image/08d200ab74c2ff2ecad45f922eeebe9e.7403048c.webp",S=a.p+"static/image/0fa8703757918f51175a0c9d049dff31.a5c76064.webp",D=a.p+"static/image/6304edacbbd505bea33728ce3286aa0e.b51e8b5f.webp",N=a.p+"static/image/34e16931ff6dae622122dc6bfeaa83c0.276a6d77.webp",_=a.p+"static/image/56146a1fcf6c0e9ae043a0bde2bb6fcf.0292bd2e.webp",q=a.p+"static/image/4270129ca425ac3382a03d185d07e6a6.41005d5f.webp",v=a.p+"static/image/77bd46bcf477867f6f7484e99515e96d.a685df1a.webp",O=a.p+"static/image/a2bff3b347bac070c368ff7109b8d0a3.b192e3cf.webp",R=a.p+"static/image/73b468d6e0f6f8657a2abbe3e54eea74.235c9532.webp",I=a.p+"static/image/746ffe9530dbc78a5baf6e45c0635437.718a2abc.webp",T=a.p+"static/image/2eff6b4df004b1ea218d2540aed431bb.86ae98e4.webp",U=a.p+"static/image/36a54e73fce3dc6b557d0d3c10e64273.2674b6bc.webp",B=a.p+"static/image/c9f1c20adf815a0510e5286cabe4f9ec.17486ea0.webp",k=a.p+"static/image/891dc4cd0131f25e785445fe0fd2cd8c.593dd82c.webp",M=a.p+"static/image/2f5d82352bc221639b8de33c57d2cdc7.9bf4daab.webp",P=a.p+"static/image/639df18069bc5dcb1fbea2c403b85be4.5c47af9e.webp",G=a.p+"static/image/10a52af3c656bcd465e578fb527afef8.c73eda9f.webp",J=a.p+"static/image/f0b53082a2c166e3a2ca25cdd9c1d85a.3bf469d1.webp",z=a.p+"static/image/30efeb21da4468321ddeb981722e2d2d.bfdb4ce4.webp",F=a.p+"static/image/5c701df5ac90302660a3b943068d8e19.c0dd56af.webp";function Q(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"55-typeorm-一对一的映射和关联-crud",children:["55. TypeORM 一对一的映射和关联 CRUD",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#55-typeorm-一对一的映射和关联-crud",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在数据库里，表和表之间是存在关系的。"}),"\n",(0,r.jsx)(n.p,{children:"比如用户和身份证是一对一的关系，部门和员工是一对多的关系，文章和标签是多对多的关系。"}),"\n",(0,r.jsx)(n.p,{children:"我们是通过外键来存储这种关系的，多对多的话还要建立中间表。"}),"\n",(0,r.jsx)(n.p,{children:"TypeORM 是把表、字段、表和表的关系映射成 Entity 的 class、属性、Entity 之间的关系，那如何映射这种一对一、一对多、多对多的关系呢？"}),"\n",(0,r.jsx)(n.p,{children:"我们来试一下。"}),"\n",(0,r.jsx)(n.p,{children:"这次创建个新的 database 来用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"create database typeorm_test;\n"})}),"\n",(0,r.jsx)(n.p,{children:"执行它："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:F,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"点击刷新，就可以看到这个新的 database 了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:z,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们用 typeorm 连上它来自动创建表。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"npx typeorm@latest init --name typeorm-relation-mapping --database mysql\n"})}),"\n",(0,r.jsx)(n.p,{children:"创建个 typeorm 项目。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:J,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"修改 DataSource 的配置："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import "reflect-metadata"\nimport { DataSource } from "typeorm"\nimport { User } from "./entity/User"\n\nexport const AppDataSource = new DataSource({\n    type: "mysql",\n    host: "localhost",\n    port: 3306,\n    username: "root",\n    password: "guang",\n    database: "typeorm_test",\n    synchronize: true,\n    logging: true,\n    entities: [User],\n    migrations: [],\n    subscribers: [],\n    poolSize: 10,\n    connectorPackage: \'mysql2\',\n    extra: {\n        authPlugin: \'sha256_password\',\n    }\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"安装驱动包  mysql2"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save mysql2\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后跑起来："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run start\n"})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，它生成了建表 sql 和插入数据的 sql："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:G,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"点击刷新，在 workbench 里也可以看到这个新建的表："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"点击新建 sql，执行 select，也是可以看到插入的数据的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:M,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后我们再创建个身份证表。"}),"\n",(0,r.jsx)(n.p,{children:"通过 typeorm entity:create 命令创建："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"npx typeorm entity:create src/entity/IdCard\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:B,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"填入属性和映射信息："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Column, Entity, PrimaryGeneratedColumn } from \"typeorm\"\n\n@Entity({\n    name: 'id_card'\n})\nexport class IdCard {\n    @PrimaryGeneratedColumn()\n    id: number\n\n    @Column({\n        length: 50,\n        comment: '身份证号'\n    })\n    cardName: string\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 DataSource 的 entities 里引入下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:U,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"重新 npm run start："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到生成了这条建表 sql。"}),"\n",(0,r.jsx)(n.p,{children:"workbench 里也可以看到这个表："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:I,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"现在 user 和 id_card 表都有了，怎么让它们建立一对一的关联呢？"}),"\n",(0,r.jsx)(n.p,{children:"先把这两个表删除："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"drop table id_card,user;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在 IdCard 的 Entity 添加一个 user 列，指定它和 User 是 @OneToTone 一对一的关系。"}),"\n",(0,r.jsx)(n.p,{children:"还要指定 @JoinColum 也就是外键列在 IdCard 对应的表里维护："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:O,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"重新 npm run start："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"仔细看生成的这 3 条 sql 语句。"}),"\n",(0,r.jsx)(n.p,{children:"前两个是建表 sql，创建 id_card 和 user 表。"}),"\n",(0,r.jsx)(n.p,{children:"最后一个是给修改 id_card 表，给 user_id 列添加一个外建约束，引用 user 表的 id 列。"}),"\n",(0,r.jsx)(n.p,{children:"在 workbench 里看下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:q,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:_,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"生成的表都是对的。"}),"\n",(0,r.jsx)(n.p,{children:"但是这个级联关系还是默认的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果我们想设置 CASCADE 应该怎么做呢？"}),"\n",(0,r.jsx)(n.p,{children:"在第二个参数指定："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"删除这两个表："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"drop table id_card,user;\n"})}),"\n",(0,r.jsx)(n.p,{children:"重新 npm run start："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样就设置了级联删除和级联更新。"}),"\n",(0,r.jsx)(n.p,{children:"我们再来试下增删改查："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { AppDataSource } from \"./data-source\"\nimport { IdCard } from \"./entity/IdCard\"\nimport { User } from \"./entity/User\"\n\nAppDataSource.initialize().then(async () => {\n\n    const user = new User();\n    user.firstName = 'guang';\n    user.lastName = 'guang';\n    user.age = 20;\n    \n    const idCard = new IdCard();\n    idCard.cardName = '1111111';\n    idCard.user = user;\n    \n    await AppDataSource.manager.save(user);\n    await AppDataSource.manager.save(idCard);\n\n}).catch(error => console.log(error))\n"})}),"\n",(0,r.jsx)(n.p,{children:"创建 user 和 idCard 对象，设置 idCard.user 为 user，也就是建立关联。"}),"\n",(0,r.jsx)(n.p,{children:"然后先保存 user，再保存 idCard。"}),"\n",(0,r.jsx)(n.p,{children:"跑 npm run start，生成的 sql 如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到后面插入 id_card 的时候，已经有 userId 可以填入了。"}),"\n",(0,r.jsx)(n.p,{children:"数据都插入成功了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但是我还要分别保存 user 和 idCard，能不能自动按照关联关系来保存呢？"}),"\n",(0,r.jsx)(n.p,{children:"可以的，在 @OneToOne 那里指定 cascade 为 true："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个 cascade 不是数据库的那个级联，而是告诉 typeorm 当你增删改一个 Entity 的时候，是否级联增删改它关联的 Entity。"}),"\n",(0,r.jsx)(n.p,{children:"这样我们就不用自己保存 user 了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"重新 npm run start："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到它同样是先插入了 user，再插入了 id_card，并且设置了正确的 userId。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"保存了之后，怎么查出来呢？"}),"\n",(0,r.jsx)(n.p,{children:"我们用 find 来试下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const ics = await AppDataSource.manager.find(IdCard);\nconsole.log(ics);\n"})}),"\n",(0,r.jsx)(n.p,{children:"跑下 npm run start："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到 idCard 查出来了，但是关联的 user 没查出来。"}),"\n",(0,r.jsx)(n.p,{children:"只需要声明下 relations 关联查询就好了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const ics = await AppDataSource.manager.find(IdCard, {\n    relations: {\n        user: true\n    }\n});\nconsole.log(ics);\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"再跑一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"现在 idCard 关联的 user 就被查出来了。"}),"\n",(0,r.jsx)(n.p,{children:"当然，你也可以用 query builder 的方式来查询："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const ics = await AppDataSource.manager.getRepository(IdCard)\n    .createQueryBuilder("ic")\n    .leftJoinAndSelect("ic.user", "u")\n    .getMany();\n\nconsole.log(ics);\n'})}),"\n",(0,r.jsx)(n.p,{children:"先 getRepository 拿到操作 IdCard 的 Repository 对象。"}),"\n",(0,r.jsx)(n.p,{children:"再创建 queryBuilder 来连接查询，给 idCard 起个别名 ic，然后连接的是 ic.user，起个别名为 u："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"或者也可以直接用 EntityManager 创建 queryBuilder 来连接查询："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const ics = await AppDataSource.manager.createQueryBuilder(IdCard, "ic")\n    .leftJoinAndSelect("ic.user", "u")\n    .getMany();\nconsole.log(ics);\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"再来试下修改："}),"\n",(0,r.jsx)(n.p,{children:"现在数据是这样的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们给它加上 id 再 save："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const user = new User();\nuser.id = 1;\nuser.firstName = 'guang1111';\nuser.lastName = 'guang1111';\nuser.age = 20;\n\nconst idCard = new IdCard();\nidCard.id = 1;\nidCard.cardName = '22222';\nidCard.user = user;\n\nawait AppDataSource.manager.save(idCard);\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样数据就被修改了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"看下生成的 sql："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在一个事务内，执行了两条 update 的 sql。"}),"\n",(0,r.jsx)(n.p,{children:"最后再试试删除。"}),"\n",(0,r.jsx)(n.p,{children:"因为设置了外键的 onDelete 是 cascade，所以只要删除了 user，那关联的 idCard 就会跟着被删除。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"await AppDataSource.manager.delete(User, 1)\n"})}),"\n",(0,r.jsx)(n.p,{children:"如果不是没有这种级联删除，就需要手动删了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const idCard = await AppDataSource.manager.findOne(IdCard, {\n    where: {\n        id: 1\n    },\n    relations: {\n        user: true\n    }\n})\nawait AppDataSource.manager.delete(User, idCard.user.id)\nawait AppDataSource.manager.delete(IdCard, idCard.id)\n"})}),"\n",(0,r.jsx)(n.p,{children:"不过现在我们只是在 idCard 里访问 user，如果想在 user 里访问 idCard 呢？"}),"\n",(0,r.jsx)(n.p,{children:"同样需要加一个 @OneToOne 的装饰器："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"不过需要有第二个参数。"}),"\n",(0,r.jsx)(n.p,{children:"因为如果是维持外键的那个表，也就是有 @JoinColumn 的那个 Entity，它是可以根据外键关联查到另一方的。"}),"\n",(0,r.jsx)(n.p,{children:"但是没有外键的表怎么查到另一方呢？"}),"\n",(0,r.jsx)(n.p,{children:"所以这里通过第二个参数告诉 typeorm，外键是另一个 Entity 的哪个属性。"}),"\n",(0,r.jsx)(n.p,{children:"我们查一下试试："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const user = await AppDataSource.manager.find(User, {\n    relations: {\n        idCard: true\n    }\n});\nconsole.log(user);\n"})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，同样关联查询成功了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这就是一对一关系的映射和增删改查。"}),"\n",(0,r.jsxs)(n.p,{children:["案例代码在",(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-relation-mapping",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"TypeORM 里一对一关系的映射通过 @OneToOne 装饰器来声明，维持外键列的 Entity 添加 @JoinColumn 装饰器。"}),"\n",(0,r.jsx)(n.p,{children:"如果是非外键列的 Entity，想要关联查询另一个 Entity，则需要通过第二个参数指定外键列是另一个 Entity 的哪个属性。"}),"\n",(0,r.jsx)(n.p,{children:"可以通过 @OneToOne 装饰器的 onDelete、onUpdate 参数设置级联删除和更新的方式，比如 CASCADE、SET NULL 等。"}),"\n",(0,r.jsx)(n.p,{children:"还可以设置 cascade，也就是 save 的时候会自动级联相关 Entity 的 save。"}),"\n",(0,r.jsx)(n.p,{children:"增删改分别通过 save 和 delete 方法，查询可以通过 find 也可以通过 queryBuilder，不过要 find 的时候要指定 relations 才会关联查询。"}),"\n",(0,r.jsx)(n.p,{children:"这就是 TypeORM 里一对一的映射和增删改查，下节我们继续学习一对多的映射。"})]})}function L(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(Q,{...e})}):Q(e)}let H=L;L.__RSPRESS_PAGE_META={},L.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F55.%20TypeORM%20%E4%B8%80%E5%AF%B9%E4%B8%80%E7%9A%84%E6%98%A0%E5%B0%84%E5%92%8C%E5%85%B3%E8%81%94%20CRUD.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"55. TypeORM 一对一的映射和关联 CRUD",headingTitle:"55. TypeORM 一对一的映射和关联 CRUD",frontmatter:{}}}}]);