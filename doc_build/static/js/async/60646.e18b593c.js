"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["60646"],{108323:function(e,c,n){n.r(c),n.d(c,{default:()=>G});var s=n(552676),i=n(740453);let d=n.p+"static/image/21a5199547e8c78dad11513ddcc80f6c.54221d4b.webp",a=n.p+"static/image/7b2eed2fff467ab206be002e6cb287dc.c6a0b6de.webp",p=n.p+"static/image/1b4e6103b2ed4a161ee8ca39d3bbe30e.cbdc4921.webp",r=n.p+"static/image/752ec46dd17340c279ea5c60bcbd2544.8bd2221e.webp",l=n.p+"static/image/a046aced35e5f20c4d08a3607950d5db.68118d44.webp",t=n.p+"static/image/a856a2c2b49a5673f16b87b69f160080.029b2cb6.webp",j=n.p+"static/image/b5d589675c4333e0773b9bf3bc348763.24bd8c80.webp",b=n.p+"static/image/721a94579ab63c8cb8dbd9dfdb46f062.11069913.webp",h=n.p+"static/image/a9be088f34a93cb75c8ceb3c147688da.383dda23.webp",x=n.p+"static/image/e6669d60d9597e2c37641bf33964ebc0.f74a6655.webp",m=n.p+"static/image/0a89244ba9b41a06de2b964d54f3987f.6e7180d7.webp",o=n.p+"static/image/d690e50ad4f4b025a00fdbf3e52318ce.911650ea.webp",g=n.p+"static/image/177c6221e0ba44d2c0b578d1de7e1538.6a60a9bd.webp",u=n.p+"static/image/12f9eea00636ad4493b7488e29d20a36.b110d57d.webp",f=n.p+"static/image/615d3603f1cb470e98e0f118476c1b79.7d46cf02.webp",E=n.p+"static/image/a3c0134db84fca33868c4620da3b5036.0269a50b.webp",w=n.p+"static/image/6b137785077e6c91ea716a066c283c6d.c7233963.webp",v=n.p+"static/image/c30436e0dd7a496bee16958612282b43.c8b4da4b.webp",_=n.p+"static/image/2611900fc0d5ed23819d74ef0fc0bce6.f63dacd1.webp",A=n.p+"static/image/d52bf9da8fcab8171f806695feaaccc7.b1d426aa.webp",k=n.p+"static/image/22ee8d13205a515a42d98d782e6badbf.0b0458cc.webp",B=n.p+"static/image/ae45a2717a9b1e802b8c380c01170524.e2ce7bf2.webp",I=n.p+"static/image/ace47d42f49a50c5b8072b74998ef224.41d864ce.webp",U=n.p+"static/image/95643f924ecc14244166a6d8ba79b106.a2a53a00.webp",C=n.p+"static/image/f1ae27cf02a64e6444d076caa9222119.3642c7e0.webp",D=n.p+"static/image/4e7a2a5e80ec82b9b83ca4a10de41de6.06ff844d.webp",S=n.p+"static/image/02c578f5cb5c1b729eb591c171b0ed8c.bc649c1e.webp",T=n.p+"static/image/1c84539ea79bf2ecee370a9887b1afd6.555e50c6.webp",F=n.p+"static/image/245243d6e275363326af17c907cb7bec.f10287e8.webp",V=n.p+"static/image/4c5fef19f167dbcb8c660ff22fbb63d4.2082b177.webp",M=n.p+"static/image/89f39d38f307dd0ac15a35f46b4b70a4.842dd5bd.webp",P=n.p+"static/image/c83bf03756e812b8a1c286f8e387735c.58fd4848.webp",R=n.p+"static/image/9d45932e97316814b58ad7d8cbe9990a.740b8002.webp",y=n.p+"static/image/e9a2c831765e4d10d6dfeccb811dae02.86c0758d.webp";function L(e){let c=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(c.h1,{id:"27实战案例调试-elementui-组件源码",children:["27.实战案例：调试 ElementUI 组件源码",(0,s.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#27实战案例调试-elementui-组件源码",children:"#"})]}),"\n",(0,s.jsx)(c.p,{children:"上节写了怎么调试 antd 的源码，但很多小伙伴是写 Vue 的，可能平时用的是 Element UI 的组件库，所以这节就来讲下怎么调试 Element UI 的源码。"}),"\n",(0,s.jsx)(c.p,{children:"首先，我们用 Vue CLI（用 vue cli5） 创建一个 vue2 的项目："}),"\n",(0,s.jsx)(c.pre,{children:(0,s.jsx)(c.code,{children:"yarn global add @vue/cli\n\nvue create element-vue-test\n"})}),"\n",(0,s.jsx)(c.p,{children:"创建成功后，进入到项目目录"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"安装 element ui 的库，并在入口引入："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"然后在 App.vue 里用一下 button 组件"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"之后 yarn run serve 把开发服务跑起来，就可以看到这样的页面："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"Element UI 的组件正确的显示了。"}),"\n",(0,s.jsx)(c.p,{children:"接下来调试 button 组件的源码，那问题来了，我怎么知道在哪里打断点呢？"}),"\n",(0,s.jsx)(c.p,{children:"我们可以知道的是，这个 button 会处理点击事件，但是却不知道事件处理函数的代码在什么地方。"}),"\n",(0,s.jsx)(c.p,{children:"这种情况可以加一个事件断点："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:V,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"在 sources 面板的 Event Listener Breakponts 里勾选 Mouse 的 click 事件，也就是在所有 click 事件的处理函数处断住。"}),"\n",(0,s.jsx)(c.p,{children:"然后你再点下那个按钮试试看："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:F,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"你会发现它在事件处理函数处断住了。"}),"\n",(0,s.jsx)(c.p,{children:"当你知道这个组件处理了什么事件，但却不知道事件处理函数在哪的时候就可以用事件断点。"}),"\n",(0,s.jsx)(c.p,{children:"当然，这个事件处理函数并不是组件里的，因为 Vue 内部会先做一些处理，然后再交给组件处理。"}),"\n",(0,s.jsx)(c.p,{children:"所以，我们要先走到组件的事件处理函数："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"单步执行、再进入函数内部，再单步执行、再进入函数内部，代码就会走到组件的事件处理函数："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"methods、computed、props，这明显是源码里的了。但你再往上走两步，会发现又不是最初的源码："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"template 变成了 render 函数，而且还有其他组件的代码，这明显是被编译打包之后的代码。"}),"\n",(0,s.jsx)(c.p,{children:"从文件名也可以看出来："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这是一个把所有组件代码编译后打包到一起的文件。"}),"\n",(0,s.jsx)(c.p,{children:"这样虽然也能调试，但肯定是不爽的，能不能直接调试组件最初的源码呢？就是带 template 的单文件组件那种？"}),"\n",(0,s.jsx)(c.p,{children:"是可以的，这就要用到 sourcemap 了。"}),"\n",(0,s.jsx)(c.p,{children:"sourcemap 是在编译过程中产生的："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:U,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"里面记录了目标代码和源代码的映射关系，调试的时候可以通过它映射回源码："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:I,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"但是你去 node_modules 下看看，会发现没有这个文件的 sourcemap："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"那怎么生成它的 sourcemap 呢？"}),"\n",(0,s.jsx)(c.p,{children:"这就要从源码重新编译了。"}),"\n",(0,s.jsx)(c.p,{children:"我们从 github 把它的源码下载下来："}),"\n",(0,s.jsx)(c.pre,{children:(0,s.jsx)(c.code,{children:"git clone --depth=1 --single-branch git@github.com:ElemeFE/element.git\n"})}),"\n",(0,s.jsx)(c.p,{children:"--depth=1 是只下载单个 commit，--single-branch 是下载单个 branch，这样下载速度能快几十倍，是一个加速小技巧。"}),"\n",(0,s.jsx)(c.p,{children:"进入 element 目录，安装依赖，你会遇到一个前端经常头疼的问题，node-sass 安装报错了："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这个问题的解决方案就是把 node 版本切换到 node-sass 版本对应的那个。"}),"\n",(0,s.jsx)(c.p,{children:"package.json 中可以看到 node-sass 是 4.11.0"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"打开 node-sass 的 github 首页："}),"\n",(0,s.jsx)(c.p,{children:"你会看到这样一个版本对应关系表："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"4.11 对应 node11，那就把 node 切换到 11 就可以了。"}),"\n",(0,s.jsx)(c.p,{children:"然后再次 yarn 安装依赖就能成功了。"}),"\n",(0,s.jsx)(c.p,{children:"之后开始编译，在 npm scripts 中可以找到 dist 命令，这就是构建源码用的："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"但是我们只需要 element-ui.common.js 这个文件："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"其实只需要执行其中的一部分脚本，也就是这个："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"所以在项目下执行 npx webpack --config build/webpack.common.js 即可："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"然后在 lib 下就可以看到构建产物："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"但我们的目标是生成带有 source-map 的代码，所以要改下配置："}),"\n",(0,s.jsx)(c.p,{children:"修改 build/webpack.common.js，配置 devtool 为 cheap-module-source-map："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"source-map 是生成 sourcemap 并关联，也就是这样："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"module 是把中间 loader 产生的 sourcemap 也给合并到最终的 sourcemap 里，这样才能直接映射到源码。"}),"\n",(0,s.jsx)(c.p,{children:"cheap 是加快编译速度用的，只保留行的映射信息。"}),"\n",(0,s.jsx)(c.p,{children:"改完配置后再次 npx webpack --config build/webpack.common.js，就可以看到带有 sourcemap 的产物了："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"把这俩文件复制到测试项目的 node_modules/element-ui 下覆盖下之前的："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"devtool 设置为 source-map:"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"之后清掉 node_modules/.cache 下的缓存，重新跑 dev server："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这时会报错提示你 node 版本太低了，你需要再把 node 版本换回来："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"跑起开发服务之后，再次用之前的方式调试 button 组件的源码："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"你会发现现在的组件代码是带 template 语法的单文件组件的代码了！"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这就是 sourcemap 的作用。"}),"\n",(0,s.jsx)(c.p,{children:"之后你会可以在这个组件里打断点然后调试。"}),"\n",(0,s.jsx)(c.p,{children:"有的同学可能会问，通过事件断点进入组件内部，这样有点麻烦，有没有更简单的方式？而且 button 组件有点击事件，但有的组件没有呀，这些组件该怎么调试呢？"}),"\n",(0,s.jsx)(c.p,{children:"确实，有了 sourcemap 之后就有更简单的调试方式了。"}),"\n",(0,s.jsx)(c.p,{children:"你可以在 sources 左边看到 ELEMENT 目录下有很多 vue 文件，这其实就是 Chrome DevTools 解析 sourcemap 之后列在这里的："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"你可以直接在里面打断点调试。"}),"\n",(0,s.jsx)(c.p,{children:"比如我们加一个 tabs 组件："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"把前面添加的那个事件断点去掉，在代码里手动打一个断点："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"然后你就会发现，这样就可以调试 Element UI 组件源码了！"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"当然，有的组件找不到的时候，还是可以通过事件断点的方式来进入组件内部。"}),"\n",(0,s.jsx)(c.p,{children:"我们是通过 Chrome DevTools 调试的，其实用 VSCode Debugger 来调试它也是一样的，在 Chrome DevTools 里打的断点，在 VSCode Debugger 里同样会断住。"}),"\n",(0,s.jsxs)(c.h2,{id:"总结",children:["总结",(0,s.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(c.p,{children:"这节我们调试了 Element UI 的源码。"}),"\n",(0,s.jsx)(c.p,{children:"定位到组件的代码，是通过事件断点的方式，因为我们知道它触发了什么事件，但却不知道事件处理函数在哪。"}),"\n",(0,s.jsx)(c.p,{children:"但是组件的代码是被编译打包过的，不是最初的源码。"}),"\n",(0,s.jsx)(c.p,{children:"为了调试最初的源码，我们下载了 Element UI 的代码，build 出了一份带有 sourcemap 的代码。"}),"\n",(0,s.jsx)(c.p,{children:"覆盖项目 node_modules 下的代码，重新跑 dev server，这时候就可以直接调试组件源码了。"}),"\n",(0,s.jsx)(c.p,{children:"有了 sourcemap 之后，Chrome DevTools 会直接把 vue 文件列在 sources 里，我们可以找到对应的 vue 文件来打断点，就不用通过事件断点来找了。"}),"\n",(0,s.jsx)(c.p,{children:"能够调试 Element UI 源码之后，想知道组件内部都有哪些逻辑的话，就可以直接在源码断点调试了，就很香。"})]})}function N(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,i.ah)(),e.components);return c?(0,s.jsx)(c,{...e,children:(0,s.jsx)(L,{...e})}):L(e)}let G=N;N.__RSPRESS_PAGE_META={},N.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F27.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%B0%83%E8%AF%95%20ElementUI%20%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"27.实战案例：调试 ElementUI 组件源码",headingTitle:"27.实战案例：调试 ElementUI 组件源码",frontmatter:{}}}}]);