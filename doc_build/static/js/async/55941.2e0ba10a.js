"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55941"],{792318:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var s=r(552676),i=r(740453);let d=r.p+"static/image/4e8bb1c9b39bbb8e42d5694f4bd1de04.b8486b78.webp",l=r.p+"static/image/9e271d7fd73a056db0e8cab34745a14e.4f12da2e.webp",c=r.p+"static/image/457bfeaff239ecc7516946cbf5cbc6f9.9c803bdb.webp",t=r.p+"static/image/483fd48969603819d33a44642cd240d0.e7b1e1fb.webp",a=r.p+"static/image/df9ed32f632dfd3bb0c03f5206f3d0a5.de95cb13.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",strong:"strong",pre:"pre",code:"code",ul:"ul",li:"li",img:"img",blockquote:"blockquote"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"12优化篇-渲染调优",children:["12.优化篇-渲染调优",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12优化篇-渲染调优",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"一前言",children:["一前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上节主要讲了 React 对组件渲染的控制方法以及原理，本章节将继续围绕 React 渲染话题，谈一谈整个 React 渲染过程中细节问题怎么解决。"}),"\n",(0,s.jsx)(n.p,{children:"通过本章节，你将学会 Suspense 用法和原理，React.lazy 用法和配合 Suspense 实现代码分割，渲染错误边界、渲染异常的处理手段， 以及 diff 流程以及 key 的合理使用。"}),"\n",(0,s.jsxs)(n.h2,{id:"二懒加载和异步渲染",children:["二懒加载和异步渲染",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二懒加载和异步渲染",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"异步渲染",children:["异步渲染",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步渲染",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Suspense 是 React 提出的一种同步的代码来实现异步操作的方案。Suspense 让组件‘等待’异步操作，异步请求结束后在进行组件的渲染，也就是所谓的异步渲染，但是这个功能目前还在实验阶段，相信不久这种异步渲染的方式就能和大家见面了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Suspense 用法"})}),"\n",(0,s.jsx)(n.p,{children:"Suspense 是组件，有一个 fallback 属性，用来代替当 Suspense 处于 loading 状态下渲染的内容，Suspense 的 children 就是异步组件。多个异步组件可以用 Suspense 嵌套使用。"}),"\n",(0,s.jsx)(n.p,{children:"我写了一个异步渲染的例子如下。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 子组件\nfunction UserInfo() {\n  // 获取用户数据信息，然后再渲染组件。\n  const user = getUserInfo();\n  return <h1>{user.name}</h1>;\n}\n// 父组件\nexport default function Index(){\n    return <Suspense fallback={<h1>Loading...</h1>}>\n        <UserInfo/>\n    </Suspense>\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Suspense 包裹异步渲染组件 UserInfo ，当 UserInfo 处于数据加载状态下，展示 Suspense 中 fallback 的内容。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"如上所示，异步渲染的 UserInfo 组件可以直接通过 getUserInfo 请求数据，直接用数据 user 进行渲染，很显然现在是做不到的。现在的异步请求方式比较繁琐，主要是是通过类组件 componentDidMount 或者函数组件 useEffect 进行数据交互，获得数据后通过调用 setState 或 useState 改变 state 触发视图的更新。"}),"\n",(0,s.jsxs)(n.p,{children:["传统模式：挂载组件-> 请求数据 -> 再渲染组件。","\n异步模式：请求数据-> 渲染组件。"]}),"\n",(0,s.jsx)(n.p,{children:"那么异步渲染相比传统数据交互相比好处就是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"不再需要 componentDidMount 或 useEffect 配合做数据交互，也不会因为数据交互后，改变 state 而产生的二次更新作用。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"代码逻辑更简单，清晰。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"动态加载懒加载",children:["动态加载（懒加载）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#动态加载懒加载",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"现在的 Suspense 配合 React.lazy 可以实现动态加载功能。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"React.lazy"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const LazyComponent = React.lazy(()=>import('./text'))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["React.lazy 接受一个函数，这个函数需要动态调用 ",(0,s.jsx)(n.code,{children:"import()"})," 。它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 React 组件。"]}),"\n",(0,s.jsx)(n.p,{children:"先来看一下基本使用："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const LazyComponent = React.lazy(() => import('./test.js'))\n\nexport default function Index(){\n   return <Suspense fallback={<div>loading...</div>} >\n       <LazyComponent />\n   </Suspense>\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["用 React.lazy 动态引入 test.js 里面的组件，配合 Suspense 实现动态加载组件效果。",(0,s.jsx)(n.strong,{children:"这样很利于代码分割，不会让初始化的时候加载大量的文件。"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["原理揭秘： ",(0,s.jsx)(n.strong,{children:"React.lazy和Suspense实现动态加载原理"})]}),"\n",(0,s.jsxs)(n.p,{children:["整个 render 过程都是同步执行一气呵成的，但是在 Suspense 异步组件情况下允许",(0,s.jsx)(n.strong,{children:"调用 Render => 发现异步请求 => 悬停，等待异步请求完毕 => 再次渲染展示数据"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"那么整个流程是如何实现的，逐步分析一下："}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Suspense原理："})," "]}),"\n",(0,s.jsxs)(n.p,{children:["Suspense 在执行内部可以通过 ",(0,s.jsx)(n.code,{children:"try{}catch{}"})," 方式捕获异常，这个异常通常是一个 ",(0,s.jsx)(n.code,{children:"Promise"})," ，可以在这个 Promise 中进行数据请求工作，Suspense 内部会处理这个 Promise ，Promise 结束后，Suspense 会再一次重新 render 把数据渲染出来，达到异步渲染的效果。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"5.jpg"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"React.lazy原理："})}),"\n",(0,s.jsxs)(n.p,{children:["再看一下 React.lazy，lazy 内部模拟一个 promiseA 规范场景。完全可以理解 React.lazy 用 Promise 模拟了一个请求数据的过程，但是请求的结果不是数据，而是一个动态的组件。下一次渲染就直接渲染这个组件，所以是 React.lazy 利用 Suspense ",(0,s.jsx)(n.strong,{children:"接收 Promise ，执行 Promise ，然后再渲染"}),"这个特性做到动态加载的。说到这可能有很多同学不明白什么意思，不要紧，接下来通过以下代码加深一下对 lazy + susponse 的理解。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react/src/ReactLazy.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function lazy(ctor){\n    return {\n         $$typeof: REACT_LAZY_TYPE,\n         _payload:{\n            _status: -1,  //初始化状态\n            _result: ctor,\n         },\n         _init:function(payload){\n             if(payload._status===-1){ /* 第一次执行会走这里  */\n                const ctor = payload._result;\n                const thenable = ctor();\n                payload._status = Pending;\n                payload._result = thenable;\n                thenable.then((moduleObject)=>{\n                    const defaultExport = moduleObject.default;\n                    resolved._status = Resolved; // 1 成功状态\n                    resolved._result = defaultExport;/* defaultExport 为我们动态加载的组件本身  */ \n                })\n             }\n            if(payload._status === Resolved){ // 成功状态\n                return payload._result;\n            }\n            else {  //第一次会抛出Promise异常给Suspense\n                throw payload._result; \n            }\n         }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["整个流程是这样的，React.lazy 包裹的组件会标记 ",(0,s.jsx)(n.code,{children:"REACT_LAZY_TYPE"})," 类型的 element，在调和阶段会变成 LazyComponent 类型的 fiber ，React 对 LazyComponent 会有单独的处理逻辑："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["第一次渲染首先会执行 init 方法，里面会执行 lazy 的第一个函数，得到一个Promise，绑定 Promise.then 成功回调，回调里得到将要渲染组件 ",(0,s.jsx)(n.code,{children:"defaultExport"})," ，这里要注意的是，如上面的函数当第二个 if 判断的时候，因为此时状态不是 Resolved ，所以会走 else ，抛出异常 Promise，抛出异常会让当前渲染终止。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"这个异常 Promise 会被 Suspense 捕获到，Suspense 会处理 Promise ，Promise 执行成功回调得到 defaultExport（将想要渲染组件），然后 Susponse 发起第二次渲染，第二次 init 方法已经是 Resolved 成功状态，那么直接返回 result 也就是真正渲染的组件。这时候就可以正常渲染组件了。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"4.jpg"})}),"\n",(0,s.jsxs)(n.h2,{id:"三-渲染错误边界",children:["三 渲染错误边界",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-渲染错误边界",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"React 组件渲染过程如果有一个环节出现问题，就会导致整个组件渲染失败，那么整个组件的 UI 层都会显示不出来，这样造成的危害是巨大的，如果越靠近 APP 应用的根组件，渲染过程中出现问题造成的影响就越大，有可能直接造成白屏的情况。"}),"\n",(0,s.jsx)(n.p,{children:"比如如下例子"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function ErrorTest(){\n    return \n}\nfunction Test(){\n    return <div>let us learn React!</div>\n}\n\n class Index extends React.Component{ \n    componentDidCatch(...arg){\n       console.log(arg)\n    }\n   render(){  \n      return <div>\n          <ErrorTest />\n          <div> hello, my name is alien! </div>\n          <Test />\n      </div>\n   }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"造成错误，由于 ErrorTest 不是一个真正的组件但是却用来渲染，结果会造成整个 Index 组件渲染异常，Test 也会受到牵连，UI 都不能正常显示。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["为了防止如上的渲染异常情况 React 增加了 ",(0,s.jsx)(n.code,{children:"componentDidCatch"})," 和 ",(0,s.jsx)(n.code,{children:"static getDerivedStateFromError()"})," 两个额外的生命周期，去挽救由于渲染阶段出现问题造成 UI 界面无法显示的情况。"]}),"\n",(0,s.jsxs)(n.h3,{id:"componentdidcatch",children:["componentDidCatch",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#componentdidcatch",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"componentDidCatch 可以捕获异常，它接受两个参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"1 error —— 抛出的错误。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"2 info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。\n先来打印一下，生命周期 componentDidCatch 参数长什么样子？"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"2.jpg"})}),"\n",(0,s.jsx)(n.p,{children:"那么 componentDidCatch 中可以再次触发 setState，来降级UI渲染，componentDidCatch() 会在commit阶段被调用，因此允许执行副作用。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:" class Index extends React.Component{\n   state={\n       hasError:false\n   }  \n   componentDidCatch(...arg){\n       uploadErrorLog(arg)  /* 上传错误日志 */\n       this.setState({  /* 降级UI */\n           hasError:true\n       })\n   }\n   render(){  \n      const { hasError } =this.state\n      return <div>\n          {  hasError ? <div>组件出现错误</div> : <ErrorTest />  }\n          <div> hello, my name is alien! </div>\n          <Test />\n      </div>\n   }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"效果："}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("img",{src:l,alt:"3.jpg"}),"\ncomponentDidCatch 作用："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"可以调用 setState 促使组件渲染，并做一些错误拦截功能。"}),"\n",(0,s.jsx)(n.li,{children:"监控组件，发生错误，上报错误日志。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"static-getderivedstatefromerror",children:["static getDerivedStateFromError",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#static-getderivedstatefromerror",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"React更期望用 getDerivedStateFromError 代替 componentDidCatch 用于处理渲染异常的情况。getDerivedStateFromError 是静态方法，内部不能调用 setState。getDerivedStateFromError 返回的值可以合并到 state，作为渲染使用。用 getDerivedStateFromError 解决如上的情况。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:" class Index extends React.Component{\n   state={\n       hasError:false\n   }  \n   static getDerivedStateFromError(){\n       return { hasError:true }\n   }\n   render(){  \n      /* 如上 */\n   }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如上完美解决了 ErrorTest 错误的问题。注意事项： 如果存在 getDerivedStateFromError 生命周期钩子，那么将不需要 componentDidCatch 生命周期再降级 ui。"}),"\n",(0,s.jsxs)(n.h2,{id:"四-从diff-children看key的合理使用",children:["四 从diff children看key的合理使用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-从diff-children看key的合理使用",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上述内容讲了异步渲染和渲染错误边界，都是对一些特殊情况下渲染的处理。上章节讲到，大部分优化环节 React 都自己在内部处理了。但是有一种情况也值得开发者注意，那就是列表中 key 的使用。合理的使用 key 有助于能精准的找到用于新节点复用的老节点。 React 是如何 diff children 的呢。"}),"\n",(0,s.jsx)(n.p,{children:"我这里为了方便大家了解流程，就不放过多源码了，我用如下几个案例来描述 React diffChild 核心流程。之前做过一期 vue3.0 diff算法的文章，实际在处理手法上还是有一些相似之处的。首先 React 在一次更新中当发现通过 render 得到的 children 如果是一个数组的话。就会调用 reconcileChildrenArray 来调和子代 fiber ，整个对比的流程就是在这个函数中进行的。"}),"\n",(0,s.jsxs)(n.h3,{id:"diff-children流程",children:["diff children流程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#diff-children流程",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第一步：遍历新 children ，复用 oldFiber"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactChildFiber.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function reconcileChildrenArray(){\n    /* 第一步  */\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {  \n        if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n        } else {\n            nextOldFiber = oldFiber.sibling;\n        }\n        const newFiber = updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime,);\n        if (newFiber === null) { break }\n        // ..一些其他逻辑\n        }  \n        if (shouldTrackSideEffects) {  // shouldTrackSideEffects 为更新流程。\n            if (oldFiber && newFiber.alternate === null) { /* 找到了与新节点对应的fiber，但是不能复用，那么直接删除老节点 */\n                deleteChild(returnFiber, oldFiber);\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第一步对于 React.createElement 产生新的 child 组成的数组，首先会遍历数组，因为 fiber 对于同一级兄弟节点是用 sibling 指针指向，所以在遍历children 遍历，sibling 指针同时移动，找到与 child 对应的 oldFiber 。"}),"\n",(0,s.jsx)(n.li,{children:"然后通过调用 updateSlot ，updateSlot 内部会判断当前的 tag 和 key 是否匹配，如果匹配复用老 fiber 形成新的 fiber ，如果不匹配，返回 null ，此时 newFiber 等于 null 。"}),"\n",(0,s.jsxs)(n.li,{children:["如果是处于更新流程，找到与新节点对应的老 fiber ，但是不能复用 ",(0,s.jsx)(n.code,{children:"alternate === null "}),"，那么会删除老 fiber 。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第二步：统一删除oldfiber"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (newIdx === newChildren.length) {\n    deleteRemainingChildren(returnFiber, oldFiber);\n    return resultingFirstChild;\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第二步适用于以下情况，当第一步结束完 ",(0,s.jsx)(n.code,{children:"newIdx === newChildren.length"})," 此时证明所有 newChild 已经全部被遍历完，那么剩下没有遍历 oldFiber 也就没有用了，那么调用 deleteRemainingChildren 统一删除剩余 oldFiber 。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"情况一：节点删除"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"oldChild: A B C D"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"newChild: A B"}),"\nA , B 经过第一步遍历复制完成，那么 newChild 遍历完成，此时 C D 已经没有用了，那么统一删除 C D。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第三步：统一创建newFiber"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if(oldFiber === null){\n   for (; newIdx < newChildren.length; newIdx++) {\n       const newFiber = createChild(returnFiber,newChildren[newIdx],expirationTime,)\n       // ...\n   }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第三步适合如下的情况，当经历过第一步，oldFiber 为 null ， 证明 oldFiber 复用完毕，那么如果还有新的 children ，说明都是新的元素，只需要调用 createChild 创建新的 fiber 。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"情况二：节点增加"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"oldChild: A B"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"newChild: A B C D"}),"\nA B 经过第一步遍历复制完，oldFiber 没有可以复用的了，那么直接创建 C D。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第四步：针对发生移动和更复杂的情况"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\nfor (; newIdx < newChildren.length; newIdx++) {\n    const newFiber = updateFromMap(existingChildren,returnFiber)\n    /* 从mapRemainingChildren删掉已经复用oldFiber */\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"mapRemainingChildren 返回一个 map ，map 里存放剩余的老的 fiber 和对应的 key (或 index )的映射关系。"}),"\n",(0,s.jsx)(n.li,{children:"接下来遍历剩下没有处理的 Children ，通过 updateFromMap ，判断 mapRemainingChildren 中有没有可以复用 oldFiber ，如果有，那么复用，如果没有，新创建一个 newFiber 。"}),"\n",(0,s.jsx)(n.li,{children:"复用的 oldFiber 会从 mapRemainingChildren 删掉。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"情况三：节点位置改变"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"oldChild: A B C D"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"newChild: A B D C"}),"\n如上 A B 在第一步被有效复用，第二步和第三步不符合，直接进行第四步，C D 被完全复用，existingChildren 为空。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第五步：删除剩余没有复用的oldFiber"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (shouldTrackSideEffects) {\n    /* 移除没有复用到的oldFiber */\n    existingChildren.forEach(child => deleteChild(returnFiber, child));\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"最后一步，对于没有复用的 oldFiber ，统一删除处理。"}),"\n",(0,s.jsx)(n.p,{children:"情况四：复杂情况(删除 + 新增 + 移动)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"oldChild: A B C D"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"newChild: A E D B"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"首先 A 节点，在第一步被复用，接下来直接到第四步，遍历 newChild ，E被创建，D B 从 existingChildren 中被复用，existingChildren 还剩一个 C 在第五步会删除 C ，完成整个流程。"}),"\n",(0,s.jsxs)(n.h3,{id:"关于diffchild思考和key的使用",children:["关于diffChild思考和key的使用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于diffchild思考和key的使用",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1  React diffChild 时间复杂度 O(n^3) 优化到 O(n)。"}),"\n",(0,s.jsx)(n.li,{children:"2  React key 最好选择唯一性的id，如上述流程，如果选择 Index 作为 key ，如果元素发生移动，那么从移动节点开始，接下来的 fiber 都不能做得到合理的复用。 index 拼接其他字段也会造成相同的效果。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"五实践---reactlazy--susponse模拟异步组件功能",children:["五实践 - React.lazy + Susponse模拟异步组件功能",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五实践---reactlazy--susponse模拟异步组件功能",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来 React.lazy + Susponse 来完全模拟实现一个异步组件。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"实现效果："})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"异步组件要实现的功能，异步请求数据，请求完数据再挂载组件。没有加载完数据显示 loading 效果。"}),"\n",(0,s.jsx)(n.li,{children:"可量化生产。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"主要思路："})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"可以使用 React.lazy 实现动态加载，那么可以先请求数据，然后再加载组件，这时候以 props 形式将数据传递给目标组件，实现异步效果。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"编写："})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * \n * @param {*} Component  需要异步数据的component \n * @param {*} api        请求数据接口,返回Promise，可以再then中获取与后端交互的数据\n * @returns \n */\nfunction AysncComponent(Component,api){\n    const AysncComponentPromise = () => new Promise(async (resolve)=>{\n          const data = await api()\n          resolve({\n              default: (props) => <Component rdata={data} { ...props}  />\n          })\n    })\n    return React.lazy(AysncComponentPromise)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"思路："})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"用 AysncComponent 作为一个 HOC 包装组件，接受两个参数，第一个参数为当前组件，第二个参数为请求数据的 api 。"}),"\n",(0,s.jsx)(n.li,{children:"声明一个函数给 React.lazy 作为回调函数，React.lazy 要求这个函数必须是返回一个 Promise 。在 Promise 里面通过调用 api 请求数据，然后根据返回来的数据 rdata 渲染组件，别忘了接受并传递 props 。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"使用："})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/* 数据模拟 */\nconst getData=()=>{\n    return new Promise((resolve)=>{\n        //模拟异步\n        setTimeout(() => {\n             resolve({\n                 name:'alien',\n                 say:'let us learn React!'\n             })\n        }, 1000)\n    })\n}\n/* 测试异步组件 */\nfunction Test({ rdata  , age}){\n    const { name , say } = rdata\n    console.log('组件渲染')\n    return <div>\n        <div> hello , my name is { name } </div>\n        <div>age : { age } </div>\n        <div> i want to say { say } </div>\n    </div>\n}\n/* 父组件 */\nexport default class Index extends React.Component{\n    LazyTest = AysncComponent(Test,getData) /* 需要每一次在组件内部声明，保证每次父组件挂载，都会重新请求数据 ，防止内存泄漏。 */\n    render(){\n        const { LazyTest } = this\n        return <div>\n           <Suspense fallback={<div>loading...</div>} >\n              <LazyTest age={18}  />\n          </Suspense>\n        </div>\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"1.gif"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如上 name 和 say 都是数据交互获取的数据。"}),"\n",(0,s.jsx)(n.li,{children:"组件只渲染了一次，实现了异步渲染的效果。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"总结："})}),"\n",(0,s.jsx)(n.p,{children:"这个demo仅供大家参考，加深以下对异步组件和 HOC 的理解，但是这种在真实的开发场景也会遇到一些问题。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1 需要约定好接受数据格式rdata和数据交互形式api。"}),"\n",(0,s.jsx)(n.li,{children:"2 因为数据本质是用闭包缓存的，所以绑定需要在在组件内部，这样才能保证每次父组件挂载，都会重新请求数据，另外也防止内存泄漏情况发生。"}),"\n",(0,s.jsx)(n.li,{children:"3 数据源更新维护困难。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"六总结",children:["六总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#六总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节主要讲了 React 未来版本的异步组件，React.lazy + Susponse 动态加载原理，渲染的错误边界及其处理，diff 性能调优，以及用一个实践 demo ，lazy + susponse 模拟实现了异步组件。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}let x=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F12.%E4%BC%98%E5%8C%96%E7%AF%87-%E6%B8%B2%E6%9F%93%E8%B0%83%E4%BC%98.md"]={toc:[{text:"一前言",id:"一前言",depth:2},{text:"二懒加载和异步渲染",id:"二懒加载和异步渲染",depth:2},{text:"异步渲染",id:"异步渲染",depth:3},{text:"动态加载（懒加载）",id:"动态加载懒加载",depth:3},{text:"三 渲染错误边界",id:"三-渲染错误边界",depth:2},{text:"componentDidCatch",id:"componentdidcatch",depth:3},{text:"static getDerivedStateFromError",id:"static-getderivedstatefromerror",depth:3},{text:"四 从diff children看key的合理使用",id:"四-从diff-children看key的合理使用",depth:2},{text:"diff children流程",id:"diff-children流程",depth:3},{text:"关于diffChild思考和key的使用",id:"关于diffchild思考和key的使用",depth:3},{text:"五实践 - React.lazy + Susponse模拟异步组件功能",id:"五实践---reactlazy--susponse模拟异步组件功能",depth:2},{text:"六总结",id:"六总结",depth:2}],title:"12.优化篇-渲染调优",headingTitle:"12.优化篇-渲染调优",frontmatter:{}}}}]);