"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["4894"],{749454:function(e,n,c){c.r(n),c.d(n,{default:()=>P});var s=c(552676),i=c(740453);let a=c.p+"static/image/5cb77bbb4504ff88565e3de0bab667a5.02e2ae3f.webp",d=c.p+"static/image/7e9737189ba16bd120d113cbbb9dbd60.f7608a9e.webp",l=c.p+"static/image/91414831e0b7bb532e7dace8806063c9.b0a7c60a.webp",r=c.p+"static/image/f88a3a4ccbb7326118fac6226faed356.c07633da.webp",h=c.p+"static/image/08c95e38fd43b7950273d629b11bb940.64f16744.webp",t=c.p+"static/image/1aa15b16a0e48488de8858dbd136441a.87ad38b2.webp",x=c.p+"static/image/33c6e83c003d5ba217d6b37b13c2357e.85ec2ed4.webp",p=c.p+"static/image/f9da92d3a8ef5100804ff9336b6e200e.58de097a.webp",j=c.p+"static/image/03dbb5076f24ffedce94c3738cd113c1.950ce068.webp",o=c.p+"static/image/eb19f7744c81774c15ef81d4065a9ef5.0dec156c.webp",b=c.p+"static/image/b9585abeb6e45871001bdf1a3f3f95a8.c9e47475.webp",f=c.p+"static/image/068f0332903327a43bfacf39f634a729.878a685b.webp",g=c.p+"static/image/5820476a8e442ef80e25576875ace000.9d94a7d5.webp",m=c.p+"static/image/42e98fd6dbc9568ea22b794c8104114d.b72378f4.webp",u=c.p+"static/image/93c951be5d8f6d341594bc201a499925.2f93de3a.webp",w=c.p+"static/image/0819f2bd80370f17a63e35b3bf6f7732.ebe39525.webp",k=c.p+"static/image/77311de10ede7f465571d9c067a0880a.aeb06fa9.webp",E=c.p+"static/image/7d43c1a22cb9660cdf60d88ccc01b9e5.933feec9.webp",v=c.p+"static/image/c2dbba64a8807dd7959896150fb37984.259a9ee4.webp",B=c.p+"static/image/8fe19aeed127b5c813a55eb62ffd57a7.f639c9d8.webp",C=c.p+"static/image/d070307f32e0e193007d9783d5941557.2b010f90.webp",S=c.p+"static/image/fc2c76d0a9aa486f70a75683d2d53df1.9d4d6fb3.webp",N=c.p+"static/image/b805294d73fc86714a945299f79a2f31.ef824c8d.webp",_=c.p+"static/image/1043ae10adcf6613af94a5b5943d38d4.38dcb22a.webp",A=c.p+"static/image/03aca77e084dd01f37c9e3ca75d472ac.5caa6f3e.webp",J=c.p+"static/image/bf8c449a702cdb40fb7f2bc1779734e8.c32cf47b.webp",F=c.p+"static/image/44c6bea9e63ab19afa0deaf8b247a4eb.876902a8.webp",G=c.p+"static/image/6bf4c75722180cb981ddfa53bdebc887.bfc71002.webp",L=c.p+"static/image/5b7b60c51a2e16d4cb45446a31411ce0.f12182aa.webp",M=c.p+"static/image/5a0431a2f2f1a671b0398070283f764e.552d94ed.webp",W=c.p+"static/image/a2c77c75a3d24add525a060dc266d4b6.e14d9f9c.webp";function q(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",strong:"strong",pre:"pre",code:"code",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"16调试代码会遇到的-9-种-js-作用域",children:["16.调试代码会遇到的 9 种 JS 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16调试代码会遇到的-9-种-js-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"作用域想必大家都知道，就是变量生效的范围，比如函数就会生成一个作用域，声明的变量只在函数内生效。"}),"\n",(0,s.jsx)(n.p,{children:"调试的时候，可以看到作用域的信息，这样的作用域一共有 9 种。"}),"\n",(0,s.jsx)(n.p,{children:"下面我们就一起过一遍这 9 种作用域吧："}),"\n",(0,s.jsxs)(n.h2,{id:"global-作用域",children:["Global 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#global-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过 var 声明一个变量，打个断点，可以看到 Scope 里有 Global 类型的作用域，也就是全局作用域，里面保存了变量 a："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:W,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在浏览器环境下，可以通过 a 访问全局变量，也可以通过 window.a 访问。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"local-作用域",children:["Local 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#local-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"声明个函数，在函数内声明一个变量，调用这个函数的时候，可以看到 Scope 里有 Local 类型的作用域，也就是本地作用域，里面保存了变量 b："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:L,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这两种作用域都很常见，没啥好说的。"}),"\n",(0,s.jsxs)(n.h2,{id:"block-作用域",children:["Block 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#block-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"es6 加入了块语句，它也同样会生成作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:G,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如图，会把里面声明的变量 a 放到 Block 作用域内，也就是块级作用域。"}),"\n",(0,s.jsx)(n.p,{children:"if、while、for 等语句都会生成 Block 作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:F,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:J,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"前几种作用域很常规，但下面这种作用域绝大部分前端就不知道了："}),"\n",(0,s.jsxs)(n.h2,{id:"script-作用域",children:["Script 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#script-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这段代码大家觉得会生成什么作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"很多同学都会说，不是全局作用域么？"}),"\n",(0,s.jsx)(n.p,{children:"那这个现象你能解释么："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"a、b、c 如果都是全局变量，那在浏览器里就可以通过 window.xx 来访问，但结果 window.a 和 window.b 都是 undefined，而直接访问 a、b 能拿到值。"}),"\n",(0,s.jsx)(n.p,{children:"看下现在的作用域就知道了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你会发现 let、const 声明的全局变量被放到了 script 作用域，而 var 声明的变量被放到了 global 作用域。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"这就是浏览器环境下用 let const 声明全局变量时的特殊作用域，script 作用域。可以直接访问这个全局变量，但是却不能通过 window.xx 访问。"})}),"\n",(0,s.jsx)(n.p,{children:"所以你再看到这样的代码，就不奇怪了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"window.xxx = xxx；\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个 xxx 肯定是通过 let、const 声明的全局变量，需要手动挂到 window 上。"}),"\n",(0,s.jsx)(n.p,{children:"那上面这个 script 作用域在 node 环境里有么？"}),"\n",(0,s.jsx)(n.p,{children:"我们用 node 调试下："}),"\n",(0,s.jsxs)(n.h2,{id:"模块作用域",children:["模块作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"同样的代码，在 node 环境下就没有了 Script 作用域，但是多了一个 Local 作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个 Local 作用域还有 module、exports、require 等变量，这个叫做模块作用域。"}),"\n",(0,s.jsx)(n.p,{children:"这个作用域有些特殊，其实它也是函数作用域。为什么呢？后面会有解释。"}),"\n",(0,s.jsx)(n.p,{children:"说到特殊的作用域，其实还有一些："}),"\n",(0,s.jsxs)(n.h2,{id:"catch-block-作用域",children:["Catch Block 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#catch-block-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Catch 语句也会生成一个特殊的作用域，Catch Block 作用域，特点是能访问错误对象："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在 node 里也是一样，只不过还有一层模块作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"有同学会问，那 finally 语句呢？"}),"\n",(0,s.jsx)(n.p,{children:"这个就没啥特殊的了，就是 Block 作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"类似的还有 With Block："}),"\n",(0,s.jsxs)(n.h2,{id:"with-block-作用域",children:["With Block 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#with-block-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"大家猜下这个 with 语句里的作用域是是啥："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"想必你猜到了，with 语句里的作用域就是这个对象："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"换成普通的对象更明显一些："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以直接访问 witch 对象的值，就是因为形成了一个 With Block 作用域，当然，里面再声明的变量还是在 Block 作用域里。"}),"\n",(0,s.jsxs)(n.h2,{id:"closure-作用域",children:["Closure 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#closure-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"闭包是 JS 的常见概念，它是一个函数返回另一个函数的形式，返回的函数引用了外层函数的变量，就会以闭包的形式保存下来。"}),"\n",(0,s.jsx)(n.p,{children:"比如这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function fun() {\n    const a = 1;\n    const b = 2;\n    return function () {\n        const c = 2;\n\n        console.log(a, c);\n        debugger;\n    };\n}\n\nconst f = fun();\nf();\n"})}),"\n",(0,s.jsx)(n.p,{children:"那闭包的变量怎么保存的呢？"}),"\n",(0,s.jsx)(n.p,{children:"通过 node 可以看到："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"通过 Closure 作用域保存了变量 a 的值，这个 Closure 作用域就是闭包的核心。"}),"\n",(0,s.jsx)(n.p,{children:"那为啥只保存了 a 没保存 b、c 呢？"}),"\n",(0,s.jsx)(n.p,{children:"c 是返回的函数的作用域里的，不是外部作用域，而 b 则是没用到，所以 Closure 作用域里只保存了 a。"}),"\n",(0,s.jsx)(n.p,{children:"然后执行的时候就会恢复这个 Closure 作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样函数需要的外部变量都在 Closure 作用域里，啥也没丢，可以正常执行。"}),"\n",(0,s.jsx)(n.p,{children:"是不是很巧妙！"}),"\n",(0,s.jsx)(n.p,{children:"这就是闭包的核心。"}),"\n",(0,s.jsx)(n.p,{children:"当然，Closure 作用域也可以多层，比如这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function fun() {\n    const a = 1;\n    const b = 2;\n    return function () {\n        const c = 2;\n        const d = 4;\n\n        return function () {\n            const e = 5;\n\n            console.log(a, c, e);\n        };\n    };\n}\n\nconst f = fun()();\nf();\n"})}),"\n",(0,s.jsx)(n.p,{children:"用到的外部变量分别在两个作用域里，那就会生成两个 Closure 作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"只留下用到的作用域的变量 a、c。"}),"\n",(0,s.jsx)(n.p,{children:"执行的时候就会恢复这两层闭包作用域："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样函数需要的外部环境一点都不少。"}),"\n",(0,s.jsx)(n.p,{children:"理解了 Closure 作用域，就真正理解了闭包。"}),"\n",(0,s.jsx)(n.p,{children:"闭包里还有一种特殊情况，就是 eval："}),"\n",(0,s.jsx)(n.p,{children:"上面的代码如果我改动一下，把打印语句变成 eval，会发生什么呢？"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function fun() {\n    const a = 1;\n    const b = 2;\n    return function () {\n        const c = 2;\n        const d = 4;\n\n        return function () {\n            const e = 5;\n\n            eval("console.log(a, c, e);");\n        };\n    };\n}\n\nconst f = fun()();\nf();\n'})}),"\n",(0,s.jsx)(n.p,{children:"有的同学会说，这不是一样么，都会形成闭包。"}),"\n",(0,s.jsx)(n.p,{children:"没错，都会形成闭包，但是保存的变量不一样了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你会发现它把所有外部的作用域的变量都保存到了 Closure 作用域，包括模块作用域的变量。"}),"\n",(0,s.jsx)(n.p,{children:"为什么呢？"}),"\n",(0,s.jsx)(n.p,{children:"因为它根本不会去分析字符串呀，也没法分析，万一你这段 JS 是动态从服务端获取再 eval 的呢？"}),"\n",(0,s.jsx)(n.p,{children:"没法分析！"}),"\n",(0,s.jsx)(n.p,{children:"没法分析怎么保证代码执行不出错呢？"}),"\n",(0,s.jsx)(n.p,{children:"全部保存不就行了？"}),"\n",(0,s.jsx)(n.p,{children:"所以当返回的函数有 eval 的时候，JS 引擎就会形成特别大的 Closure，会把所有的变量都放到里面。"}),"\n",(0,s.jsx)(n.p,{children:"这样再执行 eval 的时候就不会出错了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"所有的变量都给你了，怎么可能出错呢？"}),"\n",(0,s.jsx)(n.p,{children:"但是这样明显性能不好，会占用更多的内存，所以闭包里尽量不要用 eval。"}),"\n",(0,s.jsx)(n.p,{children:"前面说模块作用域是特殊的函数作用域，为什么这么说呢？"}),"\n",(0,s.jsx)(n.p,{children:"这就与 node 模块的执行机制有关系了。"}),"\n",(0,s.jsx)(n.p,{children:"比如这样一段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function func() {\n    require;\n    debugger;\n}\nfunc();\n"})}),"\n",(0,s.jsx)(n.p,{children:"执行后发现形成了闭包："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而如果不访问模块作用域的变量，就没有这一层了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我这明明没有闭包的代码呀！"}),"\n",(0,s.jsx)(n.p,{children:"这就与 node 模块的执行机制有关系了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"node 会把模块变为一个函数，它有 exports、require、module、__dirname、__filename 这五个参数，然后传入这五个参数来执行："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["所以",(0,s.jsx)(n.strong,{children:"模块作用域就是个函数作用域而已！"})]}),"\n",(0,s.jsx)(n.p,{children:"模块里的函数引用模块作用域的变量，再执行，自然就形成了闭包。"}),"\n",(0,s.jsxs)(n.h2,{id:"module-作用域",children:["Module 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#module-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前面那个 commonjs 的模块作用域本质上还是函数作用域。"}),"\n",(0,s.jsx)(n.p,{children:"而直接跑 es module 代码是能看到真正的模块作用域的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但这需要在 package.json 里指定 type 为 module"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"就是指定所有的模块都是 es module 模块："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样就可以用 import、export 语法了，也可以使用顶层 await 等特性。"}),"\n",(0,s.jsx)(n.p,{children:"这才是真正的模块作用域。"}),"\n",(0,s.jsxs)(n.h2,{id:"eval-作用域",children:["Eval 作用域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#eval-作用域",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"最后一种特殊的作用域就是 eval 作用域了。"}),"\n",(0,s.jsx)(n.p,{children:"比如这样一段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"eval(`\n    const a = 1;\n    const b = 2;\n    const c = 3;\n\n    console.log(a,b,c);\n    debugger;\n`);\n"})}),"\n",(0,s.jsx)(n.p,{children:"执行之后是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到有单独的 Eval 作用域，eval 的代码里声明的变量都在这个作用域里："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"JS 总共有 9 种作用域，我们通过调试的方式来分析了下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Global 作用域"}),"： 全局作用域，在浏览器环境下就是 window，在 node 环境下是 global"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local 作用域"}),"：本地作用域，或者叫函数作用域"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Block 作用域"}),"：块级作用域"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Script 作用域"}),"：let、const 声明的全局变量会保存在 Script 作用域，这些变量可以直接访问，但却不能通过 window.xx 访问"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Module 作用域"}),"：es module 模块运行的时候会生成 Module 作用域，而 commonjs 模块运行时严格来说也是函数作用域，因为 node 执行它的时候会包一层函数，算是比较特殊的函数作用域，有 module、exports、require 等变量"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Catch Block 作用域"}),"： catch 语句的作用域可以访问错误对象"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"With Block 作用域"}),"：with 语句会把传入的对象的值放到单独的作用域里，这样 with 语句里就可以直接访问了"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Closure 作用域"}),"：函数返回函数的时候，会把用到的外部变量保存在 Closure 作用域里，这样再执行的时候该有的变量都有，这就是闭包。eval 的闭包比较特殊，会把所有变量都保存到 Closure 作用域"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Eval 作用域"}),"：eval 代码声明的变量会保存在 Eval 作用域"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"上面这些都是调试得出的，是 JS 引擎执行代码时的真实作用域。后面调试代码的时候就会遇到这些作用域。"})]})}function D(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(q,{...e})}):q(e)}let P=D;D.__RSPRESS_PAGE_META={},D.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F16.%E8%B0%83%E8%AF%95%E4%BB%A3%E7%A0%81%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%209%20%E7%A7%8D%20JS%20%E4%BD%9C%E7%94%A8%E5%9F%9F.md"]={toc:[{text:"Global 作用域",id:"global-作用域",depth:2},{text:"Local 作用域",id:"local-作用域",depth:2},{text:"Block 作用域",id:"block-作用域",depth:2},{text:"Script 作用域",id:"script-作用域",depth:2},{text:"模块作用域",id:"模块作用域",depth:2},{text:"Catch Block 作用域",id:"catch-block-作用域",depth:2},{text:"With Block 作用域",id:"with-block-作用域",depth:2},{text:"Closure 作用域",id:"closure-作用域",depth:2},{text:"Module 作用域",id:"module-作用域",depth:2},{text:"Eval 作用域",id:"eval-作用域",depth:2},{text:"总结",id:"总结",depth:2}],title:"16.调试代码会遇到的 9 种 JS 作用域",headingTitle:"16.调试代码会遇到的 9 种 JS 作用域",frontmatter:{}}}}]);