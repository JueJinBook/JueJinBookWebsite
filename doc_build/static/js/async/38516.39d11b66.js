"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["38516"],{518100:function(n,e,l){l.r(e),l.d(e,{default:()=>a});var s=l(552676),r=l(740453);let i=l.p+"static/image/15e4904093daab5cfac7086b70ace34a.87d7b480.webp",o=l.p+"static/image/a40a8a25f9630ab1aa764502976d676e.54b500e2.webp",c=l.p+"static/image/23d42322ba8fdeaba22eec030cf028bc.e05408aa.webp",d=l.p+"static/image/5799726976f2a153408a645f57bef7bc.f1b73e82.webp";function t(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",img:"img",h3:"h3",strong:"strong",ul:"ul",li:"li",blockquote:"blockquote",ol:"ol"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"10vite-构建基石上rollup-打包基本概念及使用",children:["10.Vite 构建基石(上)——Rollup 打包基本概念及使用",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10vite-构建基石上rollup-打包基本概念及使用",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Rollup 是一款基于 ES Module 模块规范实现的 JavaScript 打包工具，在前端社区中赫赫有名，同时也在 Vite 的架构体系中发挥着重要作用。不仅是 Vite 生产环境下的打包工具，其插件机制也被 Vite 所兼容，可以说是 Vite 的构建基石。因此，掌握 Rollup 也是深入学习 Vite 的必经之路。"}),"\n",(0,s.jsx)(e.p,{children:"接下来，我们将通过两小节系统学习 Rollup。本节主要围绕 Rollup 的基本概念和核心特性展开，你不仅能知道 Rollup 是如何打包项目的，还能学会 Rollup 更高阶的使用方式，甚至能够通过 JavaScript API 二次开发 Rollup。"}),"\n",(0,s.jsxs)(e.h2,{id:"快速上手",children:["快速上手",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#快速上手",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["首先让我们用",(0,s.jsx)(e.code,{children:"npm init -y"}),"新建一个项目，然后安装 ",(0,s.jsx)(e.code,{children:"rollup"})," 依赖:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"pnpm i rollup\n"})}),"\n",(0,s.jsxs)(e.p,{children:["接着新增 ",(0,s.jsx)(e.code,{children:"src/index.js"})," 和 ",(0,s.jsx)(e.code,{children:"src/util.js"})," 和",(0,s.jsx)(e.code,{children:"rollup.config.js"})," 三个文件，目录结构如下所示:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:".\n├── package.json\n├── pnpm-lock.yaml\n├── rollup.config.js\n└── src\n    ├── index.js\n    └── util.js\n"})}),"\n",(0,s.jsx)(e.p,{children:"文件的内容分别如下:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'// src/index.js\nimport { add } from "./util";\nconsole.log(add(1, 2));\n\n// src/util.js\nexport const add = (a, b) => a + b;\n\nexport const multi = (a, b) => a * b;\n// rollup.config.js\n// 以下注释是为了能使用 VSCode 的类型提示\n/**\n * @type { import(\'rollup\').RollupOptions }\n */\nconst buildOptions = {\n  input: ["src/index.js"],\n  output: {\n    // 产物输出目录\n    dir: "dist/es",\n    // 产物格式\n    format: "esm",\n  },\n};\n\nexport default buildOptions;\n'})}),"\n",(0,s.jsxs)(e.p,{children:["你可以在",(0,s.jsx)(e.code,{children:"package.json"}),"中加入如下的构建脚本:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'{\n  // rollup 打包命令，`-c` 表示使用配置文件中的配置\n  "build": "rollup -c"\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["接着在终端执行一下",(0,s.jsx)(e.code,{children:"npm run build"}),"，可以看到如下的命令行信息:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["OK，现在你已经成功使用 Rollup 打出了第一份产物! 我们可以去 ",(0,s.jsx)(e.code,{children:"dist/es"})," 目录查看一下产物的内容:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// dist/es/index.js\n// 代码已经打包到一起\nconst add = (a, b) => a + b;\n\nconsole.log(add(1, 2));\n"})}),"\n",(0,s.jsxs)(e.p,{children:["同时你也可以发现，",(0,s.jsx)(e.code,{children:"util.js"}),"中的",(0,s.jsx)(e.code,{children:"multi"}),"方法并没有被打包到产物中，这是因为 Rollup 具有天然的 ",(0,s.jsx)(e.code,{children:"Tree Shaking"})," 功能，可以分析出未使用到的模块并自动擦除。"]}),"\n",(0,s.jsxs)(e.p,{children:["所谓 ",(0,s.jsx)(e.code,{children:"Tree Shaking"}),"(摇树)，也是计算机编译原理中",(0,s.jsx)(e.code,{children:"DCE"}),"(Dead Code Elimination，即消除无用代码) 技术的一种实现。由于 ES 模块依赖关系是确定的，和运行时状态无关。因此 Rollup 可以在编译阶段分析出依赖关系，对 AST 语法树中没有使用到的节点进行删除，从而实现 Tree Shaking。"]}),"\n",(0,s.jsxs)(e.h2,{id:"常用配置解读",children:["常用配置解读",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#常用配置解读",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"1-多产物配置",children:["1. 多产物配置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-多产物配置",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在打包 JavaScript 类库的场景中，我们通常需要对外暴露出不同格式的产物供他人使用，不仅包括 ",(0,s.jsx)(e.code,{children:"ESM"}),"，也需要包括诸如",(0,s.jsx)(e.code,{children:"CommonJS"}),"、",(0,s.jsx)(e.code,{children:"UMD"}),"等格式，保证良好的兼容性。那么，同一份入口文件，如何让 Rollup 给我们打包出不一样格式的产物呢？我们基于上述的配置文件来进行修改:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'// rollup.config.js\n/**\n * @type { import(\'rollup\').RollupOptions }\n */\nconst buildOptions = {\n  input: ["src/index.js"],\n  // 将 output 改造成一个数组\n  output: [\n    {\n      dir: "dist/es",\n      format: "esm",\n    },\n    {\n      dir: "dist/cjs",\n      format: "cjs",\n    },\n  ],\n};\n\nexport default buildOptions;\n'})}),"\n",(0,s.jsxs)(e.p,{children:["从代码中可以看到，我们将",(0,s.jsx)(e.code,{children:"output"}),"属性配置成一个数组，数组中每个元素都是一个描述对象，决定了不同产物的输出行为。"]}),"\n",(0,s.jsxs)(e.h3,{id:"2-多入口配置",children:["2. 多入口配置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-多入口配置",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["除了多产物配置，Rollup 中也支持多入口配置，而且通常情况下两者会被结合起来使用。接下来，就让我们继续改造之前的配置文件，将 ",(0,s.jsx)(e.code,{children:"input"})," 设置为一个数组或者一个对象，如下所示:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'{\n  input: ["src/index.js", "src/util.js"]\n}\n// 或者\n{\n  input: {\n    index: "src/index.js",\n    util: "src/util.js",\n  },\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["通过执行",(0,s.jsx)(e.code,{children:"npm run build"}),"可以发现，所有入口的不同格式产物已经成功输出:\n",(0,s.jsx)("img",{src:c,alt:"image.png"})]}),"\n",(0,s.jsxs)(e.p,{children:["如果不同入口对应的打包配置不一样，我们也可以默认导出一个",(0,s.jsx)(e.code,{children:"配置数组"}),"，如下所示:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// rollup.config.js\n/**\n * @type { import('rollup').RollupOptions }\n */\nconst buildIndexOptions = {\n  input: [\"src/index.js\"],\n  output: [\n    // 省略 output 配置\n  ],\n};\n\n/**\n * @type { import('rollup').RollupOptions }\n */\nconst buildUtilOptions = {\n  input: [\"src/util.js\"],\n  output: [\n    // 省略 output 配置\n  ],\n};\n\nexport default [buildIndexOptions, buildUtilOptions];\n"})}),"\n",(0,s.jsxs)(e.p,{children:["如果是比较复杂的打包场景(如 ",(0,s.jsx)(e.a,{href:"https://github.com/vitejs/vite/blob/main/packages/vite/rollup.config.js",target:"_blank",rel:"noopener noreferrer",children:"Vite 源码本身的打包"}),")，我们需要将项目的代码分成几个部分，用不同的 Rollup 配置分别打包，这种配置就很有用了。"]}),"\n",(0,s.jsxs)(e.h3,{id:"3-自定义output配置",children:["3. 自定义",(0,s.jsx)(e.code,{children:"output"}),"配置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-自定义output配置",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["刚才我们提到了",(0,s.jsx)(e.code,{children:"input"}),"的使用，主要用来声明入口，可以配置成字符串、数组或者对象，使用比较简单。而",(0,s.jsx)(e.code,{children:"output"}),"与之相对，用来配置输出的相关信息，常用的配置项如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"output: {\n  // 产物输出目录\n  dir: path.resolve(__dirname, 'dist'),\n  // 以下三个配置项都可以使用这些占位符:\n  // 1. [name]: 去除文件后缀后的文件名\n  // 2. [hash]: 根据文件名和文件内容生成的 hash 值\n  // 3. [format]: 产物模块格式，如 es、cjs\n  // 4. [extname]: 产物后缀名(带`.`)\n  // 入口模块的输出文件名\n  entryFileNames: `[name].js`,\n  // 非入口模块(如动态 import)的输出文件名\n  chunkFileNames: 'chunk-[hash].js',\n  // 静态资源文件输出文件名\n  assetFileNames: 'assets/[name]-[hash][extname]',\n  // 产物输出格式，包括`amd`、`cjs`、`es`、`iife`、`umd`、`system`\n  format: 'cjs',\n  // 是否生成 sourcemap 文件\n  sourcemap: true,\n  // 如果是打包出 iife/umd 格式，需要对外暴露出一个全局变量，通过 name 配置变量名\n  name: 'MyBundle',\n  // 全局变量声明\n  globals: {\n    // 项目中可以直接用`$`代替`jquery`\n    jquery: '$'\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"4-依赖-external",children:["4. 依赖 external",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-依赖-external",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"对于某些第三方包，有时候我们不想让 Rollup 进行打包，也可以通过 external 进行外部化:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"{\n  external: ['react', 'react-dom']\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在 SSR 构建或者使用 ESM CDN 的场景中，这个配置将非常有用，具体细节我们会在",(0,s.jsx)(e.strong,{children:"高级应用"}),"这一章展开。"]}),"\n",(0,s.jsxs)(e.h3,{id:"5-接入插件能力",children:["5. 接入插件能力",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5-接入插件能力",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在 Rollup 的日常使用中，我们难免会遇到一些 Rollup 本身不支持的场景，比如",(0,s.jsx)(e.code,{children:"兼容 CommonJS 打包"}),"、",(0,s.jsx)(e.code,{children:"注入环境变量"}),"、",(0,s.jsx)(e.code,{children:"配置路径别名"}),"、",(0,s.jsx)(e.code,{children:"压缩产物代码"})," 等等。这个时候就需要我们引入相应的 Rollup 插件了。接下来以一个具体的场景为例带大家熟悉一下 Rollup 插件的使用。"]}),"\n",(0,s.jsxs)(e.p,{children:["虽然 Rollup 能够打包",(0,s.jsx)(e.code,{children:"输出"}),"出 ",(0,s.jsx)(e.code,{children:"CommonJS"})," 格式的产物，但对于",(0,s.jsx)(e.code,{children:"输入"}),"给 Rollup 的代码并不支持 CommonJS，仅仅支持 ESM。你可能会说，那我们直接在项目中统一使用 ESM 规范就可以了啊，这有什么问题呢？需要注意的是，我们不光要考虑项目本身的代码，还要考虑第三方依赖。目前为止，还是有不少第三方依赖只有 CommonJS 格式产物而并未提供 ESM 产物，比如项目中用到 ",(0,s.jsx)(e.code,{children:"lodash"})," 时，打包项目会出现这样的报错："]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)("img",{src:o,alt:"image.png"}),"\n因此，我们需要引入额外的插件去解决这个问题。"]}),"\n",(0,s.jsx)(e.p,{children:"首先需要安装两个核心的插件包:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"pnpm i @rollup/plugin-node-resolve @rollup/plugin-commonjs \n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"@rollup/plugin-node-resolve"}),"是为了允许我们加载第三方依赖，否则像",(0,s.jsx)(e.code,{children:"import React from 'react'"})," 的依赖导入语句将不会被 Rollup 识别。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"@rollup/plugin-commonjs"})," 的作用是将 CommonJS 格式的代码转换为 ESM 格式"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"然后让我们在配置文件中导入这些插件:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'// rollup.config.js\nimport resolve from "@rollup/plugin-node-resolve";\nimport commonjs from "@rollup/plugin-commonjs";\n\n/**\n * @type { import(\'rollup\').RollupOptions }\n */\nexport default {\n  input: ["src/index.js"],\n  output: [\n    {\n      dir: "dist/es",\n      format: "esm",\n    },\n    {\n      dir: "dist/cjs",\n      format: "cjs",\n    },\n  ],\n  // 通过 plugins 参数添加插件\n  plugins: [resolve(), commonjs()],\n};\n'})}),"\n",(0,s.jsxs)(e.p,{children:["现在我们以",(0,s.jsx)(e.code,{children:"lodash"}),"这个只有 CommonJS 产物的第三方包为例测试一下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"pnpm i lodash\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在 ",(0,s.jsx)(e.code,{children:"src/index.js"})," 加入如下的代码:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'import { merge } from "lodash";\nconsole.log(merge);\n'})}),"\n",(0,s.jsxs)(e.p,{children:["然后执行 ",(0,s.jsx)(e.code,{children:"npm run build"}),"，你可以发现产物已经正常生成了:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["在 Rollup 配置文件中，",(0,s.jsx)(e.code,{children:"plugins"}),"除了可以与 ",(0,s.jsx)(e.code,{children:"output"})," 配置在同一级，也可以配置在 output 参数里面，如:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'// rollup.config.js\nimport { terser } from \'rollup-plugin-terser\'\nimport resolve from "@rollup/plugin-node-resolve";\nimport commonjs from "@rollup/plugin-commonjs";\n\nexport default {\n  output: {\n    // 加入 terser 插件，用来压缩代码\n    plugins: [terser()]\n  },\n  plugins: [resolve(), commonjs()]\n}\n'})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["当然，你可以将上述的 terser 插件放到最外层的 ",(0,s.jsx)(e.code,{children:"plugins"})," 配置中。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["需要注意的是，",(0,s.jsx)(e.code,{children:"output.plugins"}),"中配置的插件是有一定限制的，只有使用",(0,s.jsx)(e.code,{children:"Output 阶段"}),"相关钩子(具体内容将在下一节展开)的插件才能够放到这个配置中，大家可以去",(0,s.jsx)(e.a,{href:"https://github.com/rollup/awesome#output",target:"_blank",rel:"noopener noreferrer",children:"这个站点"}),"查看 Rollup 的 Output 插件列表。"]}),"\n",(0,s.jsx)(e.p,{children:"另外，这里也给大家分享其它一些比较常用的 Rollup 插件库:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/rollup/plugins/tree/master/packages/json",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-json"}),"： 支持",(0,s.jsx)(e.code,{children:".json"}),"的加载，并配合",(0,s.jsx)(e.code,{children:"rollup"}),"的",(0,s.jsx)(e.code,{children:"Tree Shaking"}),"机制去掉未使用的部分，进行按需打包。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/rollup/plugins/tree/master/packages/babel",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-babel"}),"：在 Rollup 中使用 Babel 进行 JS 代码的语法转译。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/rollup/plugins/tree/master/packages/typescript",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-typescript"}),": 支持使用 TypeScript 开发。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/rollup/plugins/tree/master/packages/alias",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-alias"}),"：支持别名配置。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/rollup/plugins/tree/master/packages/replace",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-replace"}),"：在 Rollup 进行变量字符串的替换。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/btd/rollup-plugin-visualizer",target:"_blank",rel:"noopener noreferrer",children:"rollup-plugin-visualizer"}),": 对 Rollup 打包产物进行分析，自动生成产物体积可视化分析图。"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"javascript-api-方式调用",children:["JavaScript API 方式调用",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-api-方式调用",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["以上我们通过",(0,s.jsx)(e.code,{children:"Rollup"}),"的配置文件结合",(0,s.jsx)(e.code,{children:"rollup -c"}),"完成了 Rollup 的打包过程，但有些场景下我们需要基于 Rollup 定制一些打包过程，配置文件就不够灵活了，这时候我们需要用到对应 JavaScript API 来调用 Rollup，主要分为",(0,s.jsx)(e.code,{children:"rollup.rollup"}),"和",(0,s.jsx)(e.code,{children:"rollup.watch"}),"两个 API，接下来我们以具体的例子来学习一下。"]}),"\n",(0,s.jsxs)(e.p,{children:["首先是 ",(0,s.jsx)(e.code,{children:"rollup.rollup"}),"，用来一次性地进行 Rollup 打包，你可以新建",(0,s.jsx)(e.code,{children:"build.js"}),"，内容如下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// build.js\nconst rollup = require(\"rollup\");\n\n// 常用 inputOptions 配置\nconst inputOptions = {\n  input: \"./src/index.js\",\n  external: [],\n  plugins:[]\n};\n\nconst outputOptionsList = [\n  // 常用 outputOptions 配置\n  {\n    dir: 'dist/es',\n    entryFileNames: `[name].[hash].js`,\n    chunkFileNames: 'chunk-[hash].js',\n    assetFileNames: 'assets/[name]-[hash][extname]',\n    format: 'es',\n    sourcemap: true,\n    globals: {\n      lodash: '_'\n    }\n  }\n  // 省略其它的输出配置\n];\n\nasync function build() {\n  let bundle;\n  let buildFailed = false;\n  try {\n    // 1. 调用 rollup.rollup 生成 bundle 对象\n    bundle = await rollup.rollup(inputOptions);\n    for (const outputOptions of outputOptionsList) {\n      // 2. 拿到 bundle 对象，根据每一份输出配置，调用 generate 和 write 方法分别生成和写入产物\n      const { output } = await bundle.generate(outputOptions);\n      await bundle.write(outputOptions);\n    }\n  } catch (error) {\n    buildFailed = true;\n    console.error(error);\n  }\n  if (bundle) {\n    // 最后调用 bundle.close 方法结束打包\n    await bundle.close();\n  }\n  process.exit(buildFailed ? 1 : 0);\n}\n\nbuild();\n"})}),"\n",(0,s.jsx)(e.p,{children:"主要的执行步骤如下:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["通过 ",(0,s.jsx)(e.code,{children:"rollup.rollup"}),"方法，传入 ",(0,s.jsx)(e.code,{children:"inputOptions"}),"，生成 bundle 对象；"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsxs)(e.li,{children:["调用 bundle 对象的 generate 和 write 方法，传入",(0,s.jsx)(e.code,{children:"outputOptions"}),"，分别完成产物和生成和磁盘写入。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.ol,{start:"3",children:["\n",(0,s.jsx)(e.li,{children:"调用 bundle 对象的 close 方法来结束打包。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["接着你可以执行",(0,s.jsx)(e.code,{children:"node build.js"}),"，这样，我们就可以完成了以编程的方式来调用 Rollup 打包的过程。"]}),"\n",(0,s.jsxs)(e.p,{children:["除了通过",(0,s.jsx)(e.code,{children:"rollup.rollup"}),"完成一次性打包，我们也可以通过",(0,s.jsx)(e.code,{children:"rollup.watch"}),"来完成",(0,s.jsx)(e.code,{children:"watch"}),"模式下的打包，即每次源文件变动后自动进行重新打包。你可以新建",(0,s.jsx)(e.code,{children:"watch.js"}),"文件，内容入下:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'// watch.js\nconst rollup = require("rollup");\n\nconst watcher = rollup.watch({\n  // 和 rollup 配置文件中的属性基本一致，只不过多了`watch`配置\n  input: "./src/index.js",\n  output: [\n    {\n      dir: "dist/es",\n      format: "esm",\n    },\n    {\n      dir: "dist/cjs",\n      format: "cjs",\n    },\n  ],\n  watch: {\n    exclude: ["node_modules/**"],\n    include: ["src/**"],\n  },\n});\n\n// 监听 watch 各种事件\nwatcher.on("restart", () => {\n  console.log("重新构建...");\n});\n\nwatcher.on("change", (id) => {\n  console.log("发生变动的模块id: ", id);\n});\n\nwatcher.on("event", (e) => {\n  if (e.code === "BUNDLE_END") {\n    console.log("打包信息:", e);\n  }\n});\n'})}),"\n",(0,s.jsxs)(e.p,{children:["现在你可以通过执行",(0,s.jsx)(e.code,{children:"node watch.js"}),"开启 Rollup 的 watch 打包模式，当你改动一个文件后可以看到如下的日志，说明 Rollup 自动进行了重新打包，并触发相应的事件回调函数:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"\n发生生变动的模块id: /xxx/src/index.js\n重新构建...\n打包信息: {\n  code: 'BUNDLE_END',\n  duration: 10,\n  input: './src/index.js',\n  output: [\n    // 输出产物路径\n  ],\n  result: {\n    cache: { /* 产物具体信息 */ },\n    close: [AsyncFunction: close],\n    closed: false,\n    generate: [AsyncFunction: generate],\n    watchFiles: [\n      // 监听文件列表\n    ],\n    write: [AsyncFunction: write]\n  }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"基于如上的两个 JavaScript API 我们可以很方便地在代码中调用 Rollup 的打包流程，相比于配置文件有了更多的操作空间，你可以在代码中通过这些 API 对 Rollup 打包过程进行定制，甚至是二次开发。"}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["好，本文的内容就到这里了。恭喜你，学习了完了 Rollup 基础使用篇的内容，在本小节中，你需要重点掌握 ",(0,s.jsx)(e.strong,{children:"Rollup 基本配置项的含义"}),"和 ",(0,s.jsx)(e.strong,{children:"JavaScript API 的使用"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["首先，我们通过一个简单的示例学习了 Rollup 一般的使用方法，用 Rollup 打包出了第一份产物，然后我们针对 Rollup 中常用的配置项进行介绍，包括",(0,s.jsx)(e.code,{children:"input"}),"、",(0,s.jsx)(e.code,{children:"output"}),"、",(0,s.jsx)(e.code,{children:"external"}),"、",(0,s.jsx)(e.code,{children:"plugins"}),"等核心配置，并以一个实际的打包场景为例带你在 Rollup 中接入插件功能。接着，我给你介绍了 Rollup 更高级的使用姿势——通过 JavaScript API 使用，分别介绍了两个经典的 API: ",(0,s.jsx)(e.code,{children:"rollup.rollup"}),"和",(0,s.jsx)(e.code,{children:"rollup.watch"}),"，并带你在实战中使用这些 API，完成了更为复杂的打包操作。"]}),"\n",(0,s.jsx)(e.p,{children:"在下一小节中，我们将继续深入 Rollup 的学习，一起剖析 Rollup 优秀的插件机制并进行代码实战，大家加油！"})]})}function p(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(t,{...n})}):t(n)}let a=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F10.Vite%20%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%9F%B3(%E4%B8%8A)%E2%80%94%E2%80%94Rollup%20%E6%89%93%E5%8C%85%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8.md"]={toc:[{text:"快速上手",id:"快速上手",depth:2},{text:"常用配置解读",id:"常用配置解读",depth:2},{text:"1. 多产物配置",id:"1-多产物配置",depth:3},{text:"2. 多入口配置",id:"2-多入口配置",depth:3},{text:"3. 自定义`output`配置",id:"3-自定义output配置",depth:3},{text:"4. 依赖 external",id:"4-依赖-external",depth:3},{text:"5. 接入插件能力",id:"5-接入插件能力",depth:3},{text:"JavaScript API 方式调用",id:"javascript-api-方式调用",depth:2},{text:"小结",id:"小结",depth:2}],title:"10.Vite 构建基石(上)——Rollup 打包基本概念及使用",headingTitle:"10.Vite 构建基石(上)——Rollup 打包基本概念及使用",frontmatter:{}}}}]);