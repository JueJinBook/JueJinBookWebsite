"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["62339"],{962207:function(n,e,r){r.r(e),r.d(e,{default:()=>R});var t=r(552676),s=r(740453);let a=r.p+"static/image/8a0996aa172263e02cee70df2c82ad79.9e258f07.gif",i=r.p+"static/image/8ec812b557fd73ba9e213f82f90a6e0f.b4139718.gif",o=r.p+"static/image/684adc48e247604dd376a99d7e8d6509.d46f775e.gif",c=r.p+"static/image/18a13ea8c1993ea53828489445928aa3.29e31282.gif",d=r.p+"static/image/cb4bc774b485fd4bd8796e1bff24680b.a1cc93d8.gif",l=r.p+"static/image/7d940fcd2eb57af48684deef75741dc1.c718dc5a.gif",h=r.p+"static/image/a731fc366e7056762767435d3d901faf.d33e508b.gif",p=r.p+"static/image/582c90598951e305b4f9945044fd0701.be419594.gif",x=r.p+"static/image/cc8c6bcf118b84cd5cd9ea5e3ba4792a.ab989dd8.gif",j=r.p+"static/image/7f4246ca4cdd4f8ec2d6bfe1785fc70d.c5a9c8e0.webp",m=r.p+"static/image/3c7a2c47e7f1e17fd6093455c0709cc2.69b73616.webp",g=r.p+"static/image/76d9cf39d7267af0783c582c664f71c6.d5695e31.webp",u=r.p+"static/image/523527e86492a79c463c971b61c0906b.057050ae.webp",f=r.p+"static/image/c78f26352903a588f3c955f5a0166663.04078ed3.webp",S=r.p+"static/image/adbbcec2dcb1273c0691b3af498891ec.bbac211d.gif",b=r.p+"static/image/e74de73f64e50ad9f52972f1caf6518d.005235e1.gif",G=r.p+"static/image/f8684ab924510dc325cbeed653d0ea0b.05952ff0.webp",v=r.p+"static/image/c1025bf43aec8cae48364914bb082a8a.cd24627b.gif",V=r.p+"static/image/79e2d02b39b8b3c1a5147cc828fc0c6d.cf18834e.webp",y=r.p+"static/image/aca65f7afeaaa6d85f661faebe3baadd.a4909a0e.webp",L=r.p+"static/image/8a3a0f5e5730935984e3ad499e94a7ff.e1ee518a.gif",E=r.p+"static/image/f33282e2207491560932c912522cda9e.5dcf2ef6.webp",w=r.p+"static/image/c5f1f9001adf8f3711145a15a7f299cb.67357fdc.gif",P=r.p+"static/image/d81cb0db3342219923aa47d9c8102b57.c718dc5a.gif",T=r.p+"static/image/2d368f1f4f16d1b93964ab2fe13a721d.be419594.gif",M=r.p+"static/image/9f39d3fde87beab0b65688ba325a5965.d05c4b0f.gif";function W(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",blockquote:"blockquote",pre:"pre",code:"code",ul:"ul",li:"li",strong:"strong",h3:"h3"},(0,s.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"30-实战篇svg-与-web-开发之利用-webgl-创建更高级的图形效果",children:["30-实战篇：SVG 与 Web 开发之利用 WebGL 创建更高级的图形效果",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#30-实战篇svg-与-web-开发之利用-webgl-创建更高级的图形效果",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"SVG 是一种独特的图像格式，其特殊之处在于它不是由像素构成，而是由数学函数定义的。一旦解释了这些数学函数，SVG 图像便可以在屏幕上精确呈现。这种矢量图形格式的特性使得 SVG 在 Web 开发中广泛应用，并且能够与其他 Web 技术如 CSS 和 JavaScript 无缝结合，以创建复杂的图形效果和交互动画。在此基础上，结合 WebGL 技术，我们可以进一步提升图形效果的复杂度和视觉吸引力。"}),"\n",(0,t.jsx)(e.p,{children:"利用 SVG 和 WebGL 技术，我们可以实现令人惊叹的图形效果和交互动画。本课程将重点介绍如何结合 SVG 和 WebGL，在 Web 开发中创建更高级的图形效果。我们将探索如何以 SVG 为基础，通过 WebGL 技术实现更复杂的图形渲染和动画效果，从而为用户带来更加丰富的视觉体验。"}),"\n",(0,t.jsx)(e.p,{children:"在本课程中，我们将学习如何利用 SVG 的可缩放性和数学函数表示来创建基本的图形结构，然后通过引入 WebGL 技术增强这些图形结构，实现更高级的图形效果，如光影效果、粒子动画、3D 变换等。我们还将学习如何利用 JavaScript 将 SVG 和 WebGL 技术结合，实现交互动画和用户控制。"}),"\n",(0,t.jsx)(e.p,{children:"通过本课程的学习，你将掌握结合 SVG 和 WebGL 技术创建高级图形效果的核心概念和技能。这些技能不仅能够提升你在 Web 开发项目中的创造力和魅力，还能帮助你应对复杂的工程化问题，为你的 Web 开发项目增添更多的创新和价值。"}),"\n",(0,t.jsxs)(e.h2,{id:"今天的小目标",children:["今天的小目标",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#今天的小目标",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"SVG 和 WebGL 的结合为 Web 开发开辟了新的可能性，带来了许多经典和创建的图形效果。这些效果不仅提升了视觉吸引力，还增强了用户的互动和参与感。在实际应用中，Web 开发者可以根据具体需求选择合适的技术组合，创造出高效、动态且令人印象深刻的 Web 体验。无论是数据可视化、交互式地图、游戏开发、产品展示、电子商务、教育培训、互动艺术还是虚拟现实以及增强现实，SVG 和 WebGL 都为 Web 开发者提供了强大的工具和无限的创意空间。"}),"\n",(0,t.jsx)(e.p,{children:"通过掌握这些技术，Web 开发者可以为 Web 项目增添更多的创意和魅力，创造出令人难忘的用户体验。接下来，我们将利用 SVG 和 WebGL 技术，实现引人注目的 Web 效果。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:M,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/Mamboleoo/full/zYEJVWy",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/Mamboleoo/full/zYEJVWy"})," （来源于 ",(0,t.jsx)(e.a,{href:"https://codepen.io/Mamboleoo",target:"_blank",rel:"noopener noreferrer",children:"@Louis Hoebregts"}),"）"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:T,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codrops-svg.surge.sh/",target:"_blank",rel:"noopener noreferrer",children:"https://codrops-svg.surge.sh/"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:P,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/NWVrVPR",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/NWVrVPR"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:w,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/wvbGXwg",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/wvbGXwg"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"以上仅展示了 SVG 与 WebGL 技术结合实现的部分案例，而在 Web 上类似的效果数不胜数，无法一一列举。我更期待的是，在接下来的内容中，大家能够发挥自己的创意，创造出更具吸引力的效果。"}),"\n",(0,t.jsxs)(e.h2,{id:"webgl-简介",children:["WebGL 简介",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#webgl-简介",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:E,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"WebGL 是一项前沿技术，为我们带来了在 Web 上展示丰富多彩的 3D 和 2D 图形的可能。它就像是一台魔法画笔，让我们能够在网页上绘制出各种形状、色彩和动态。"}),"\n",(0,t.jsx)(e.p,{children:"将 WebGL 比作一种创意的“画笔”，它赋予了我们以代码为媒介创造出惊艳视觉效果的能力，就像在白纸上随心所欲地作画一样。只需简单的代码，我们就能在 Web 上呈现流动的水面、绚丽的星空、以及栩栩如生的生物形象。"}),"\n",(0,t.jsx)(e.p,{children:"不同于传统的绘图工具，WebGL 基于 Web 技术，这意味着无需额外的插件或软件，便能在任何支持 WebGL 的现代浏览器上运行。这一点使得 WebGL 极其便利，让用户能够轻松体验到 Web 上的绚丽图形和动态效果。"}),"\n",(0,t.jsx)(e.p,{children:"除了在 Web 上呈现静态图形外，WebGL 还能实现高度交互的体验。比如，你可以打造一个交互式的 3D 地图，让用户自由探索各个角落；或者制作一个动态的游戏场景，让玩家沉浸其中。"}),"\n",(0,t.jsxs)(e.p,{children:["不过，要想更高效地利用 WebGL，我们通常会借助一些主流的 WebGL 框架，让开发变得更加简洁、快速和灵活。其中，",(0,t.jsx)(e.a,{href:"https://threejs.org/",target:"_blank",rel:"noopener noreferrer",children:"Three.js"})," 是最受欢迎的 WebGL 框架之一。它是一个基于 JavaScript 的 3D 库，提供了丰富的功能和易用的 API，使得创建 3D 场景变得轻而易举。Three.js 支持渲染器、相机、灯光等元素，同时提供了丰富的几何体和材质，让开发者能够快速创建出令人惊艳的 3D 效果。"]}),"\n",(0,t.jsxs)(e.p,{children:["另一个重要的 WebGL 框架是 ",(0,t.jsx)(e.a,{href:"https://www.babylonjs.com/",target:"_blank",rel:"noopener noreferrer",children:"Babylon.js"}),"。与 Three.js 类似，Babylon.js 同样提供了强大的功能和易用的 API，同时注重性能和可扩展性。Babylon.js 具有丰富的特性，包括物理引擎、粒子系统、后处理效果等，让开发者能够轻松创建出各种各样的 3D 场景和效果。"]}),"\n",(0,t.jsxs)(e.p,{children:["除了这两个主流框架外，还有一些其他的 WebGL 框架，如 ",(0,t.jsx)(e.a,{href:"https://aframe.io/",target:"_blank",rel:"noopener noreferrer",children:"A-Frame"}),"、",(0,t.jsx)(e.a,{href:"https://playcanvas.com/",target:"_blank",rel:"noopener noreferrer",children:"PlayCanvas"})," 和 ",(0,t.jsx)(e.a,{href:"https://pixijs.com/",target:"_blank",rel:"noopener noreferrer",children:"PixiJS"})," 等，它们针对特定的应用场景或需求提供了不同的解决方案。"]}),"\n",(0,t.jsx)(e.p,{children:"例如下面这个示例，就是使用 WebGL 创建的一个粒子动画效果："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:L,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/XWwdwGL",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/XWwdwGL"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"上面示例对应的代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-HTML",children:'<canvas id="canvas" width="640" height="480"></canvas>\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// 获取 WebGL 上下文\nconst canvas = document.getElementById("canvas");\nconst gl = canvas.getContext("webgl");\n\n// 检查浏览器是否支持 WebGL\nif (!gl) {\n    console.error("WebGL not supported");\n}\n\nconst vertexShaderSource = `\n            attribute vec2 position;\n            void main() {\n                float radius = 0.1 + abs(sin(position.x * position.y * 50.0)); // randomize point size\n                gl_PointSize = min(radius * 10.0, 2.0); // limit radius\n                gl_Position = vec4(position * 2.0, 0.0, 1.0); // scale position to [-1, 1] range\n            }\n        `;\n\nconst fragmentShaderSource = `\n            precision mediump float;\n            uniform vec4 color;\n            void main() {\n                float dist = length(gl_PointCoord - vec2(0.5));\n                if (dist > 0.5) {\n                    discard; // discard pixels outside the circle\n                }\n                float alpha = 1.0 - dist * 2.0; // transparency based on distance from center\n                alpha = max(alpha, 0.1); // make sure alpha is not too transparent\n                gl_FragColor = vec4(color.rgb, color.a * alpha);\n            }\n        `;\n\n// 创建顶点着色器\nconst vertexShader = gl.createShader(gl.VERTEX_SHADER);\ngl.shaderSource(vertexShader, vertexShaderSource);\ngl.compileShader(vertexShader);\n\n// 创建片元着色器\nconst fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\ngl.shaderSource(fragmentShader, fragmentShaderSource);\ngl.compileShader(fragmentShader);\n\n// 创建着色器程序\nconst program = gl.createProgram();\ngl.attachShader(program, vertexShader);\ngl.attachShader(program, fragmentShader);\ngl.linkProgram(program);\ngl.useProgram(program);\n\n// 获取着色器中定义的变量位置\nconst positionAttributeLocation = gl.getAttribLocation(program, "position");\nconst colorUniformLocation = gl.getUniformLocation(program, "color");\n\nconst numParticles = 1000;\nlet vertices = [];\nlet velocities = [];\nlet colors = [];\n\n\nfunction initializeParticles() {\n    vertices = [];\n    velocities = [];\n    colors = [];\n\n    for (let i = 0; i < numParticles; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const radius = Math.random(); // reduce radius\n        const x = Math.cos(angle) * radius;\n        const y = Math.sin(angle) * radius;\n        vertices.push(x, y);\n        velocities.push((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02);\n        colors.push(\n            Math.random() * 0.5 + 0.5,\n            Math.random() * 0.5 + 0.5,\n            Math.random() * 0.5 + 0.5,\n            0.2 + Math.random() * 0.6\n        ); // randomize alpha\n    }\n}\n\n// 初始化粒子属性\ninitializeParticles();\n\n// 创建并绑定缓冲区\nconst positionBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\ngl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\ngl.enableVertexAttribArray(positionAttributeLocation);\n\n// 渲染函数\nfunction render() {\n    gl.clearColor(0, 0, 0, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    for (let i = 0; i < numParticles; i++) {\n        vertices[i * 2] += velocities[i * 2];\n        vertices[i * 2 + 1] += velocities[i * 2 + 1];\n    \n        if (Math.abs(vertices[i * 2]) >= 1 || Math.abs(vertices[i * 2 + 1]) >= 1) {\n            const angle = Math.random() * Math.PI * 2;\n            const radius = Math.random(); // reduce radius\n            vertices[i * 2] = Math.cos(angle) * radius;\n            vertices[i * 2 + 1] = Math.sin(angle) * radius;\n            velocities[i * 2] = (Math.random() - 0.5) * 0.02;\n            velocities[i * 2 + 1] = (Math.random() - 0.5) * 0.02;\n            colors[i * 4] = Math.random() * 0.5 + 0.5;\n            colors[i * 4 + 1] = Math.random() * 0.5 + 0.5;\n            colors[i * 4 + 2] = Math.random() * 0.5 + 0.5;\n            colors[i * 4 + 3] = 0.2 + Math.random() * 0.6;\n        }\n    }\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(positionAttributeLocation);\n\n    for (let i = 0; i < colors.length; i += 4) {\n        gl.uniform4fv(colorUniformLocation, colors.slice(i, i + 4));\n        gl.drawArrays(gl.POINTS, i / 2, 1);\n    }\n\n    requestAnimationFrame(render);\n}\n\nrender();\n'})}),"\n",(0,t.jsx)(e.p,{children:"这个粒子系统在画布上绘制了一组随机移动的点，每个点的大小和颜色都是随机的，而且点的移动会在画布边界处产生反弹效果。"}),"\n",(0,t.jsx)(e.p,{children:"正如你所看到的，WebGL 是一项强大的技术，让我们能够在 Web 上创造出令人惊叹的视觉效果，为用户带来更加丰富和有趣的网络体验。但在这节课中，我们不会过多涉及 WebGL 的内容，而是将重点放在如何将 SVG 与 WebGL 结合起来创作，为自己的 Web 项目增添亮点。"}),"\n",(0,t.jsxs)(e.h2,{id:"使用-svgloader-将-svg-引入-webgl",children:["使用 SVGLoader 将 SVG 引入 WebGL",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-svgloader-将-svg-引入-webgl",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"正如之前提到的，本节课的重点不在于介绍 WebGL 的基本用法，而是探讨如何将 SVG 与 WebGL 技术相结合，以实现更加高级的图形效果。因此，我们将从最基础的部分开始，即如何将 SVG 整合到 WebGL 中。"}),"\n",(0,t.jsxs)(e.p,{children:["我们以 SVGLoader 和 WebGL 的 Three.js 为例，向大家展示如何使用 ",(0,t.jsx)(e.a,{href:"https://threejs.org/docs/#examples/en/loaders/SVGLoader",target:"_blank",rel:"noopener noreferrer",children:"Three.js 的 SVGLoader "}),"将你的 SVG 引入到 WebGL 中，并借助 Three.js 相关特性实现一个 3D 效果。"]}),"\n",(0,t.jsx)(e.p,{children:"在开始之前，首先简单的对 Three.js 和 SVGLoader 做一个简单的介绍。"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.a,{href:"https://threejs.org/",target:"_blank",rel:"noopener noreferrer",children:"Three.js"})}),"：它是最流行的 3D WebGL 库，为无数 3D 体验提供支持，如落地页、VR 房间、游戏，甚至整个 3D 编辑器！"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.a,{href:"https://threejs.org/docs/#examples/en/loaders/SVGLoader",target:"_blank",rel:"noopener noreferrer",children:"SVGLoader"})}),"：它是 Three.js 中的一个加载器，用于加载 SVG 文件并将其转换为 Three.js 中的对象。Three.js 的 SVGLoader 可以帮助 Web 开发者将 SVG 文件导入到 Three.js 场景中，使得可以利用 Three.js 的强大功能对 SVG 文件进行渲染、处理和交互。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"我们以 Vite 构建工具为例。首先使用 Vite 构建一个原生的 JavaScript 项目："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"pnpm create vite \n"})}),"\n",(0,t.jsx)(e.p,{children:"并根据 Vite 相关的提示，完成 项目的初始化工作："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:y,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"项目初始化完成之后，需要先安装 Three.js："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"pnpm install -D three  \n"})}),"\n",(0,t.jsx)(e.p,{children:"然后执行："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"pnpm run dev\n"})}),"\n",(0,t.jsx)(e.p,{children:"通过这几行代码，开发环境就设置好了。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:V,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"接下来，我们将对默认的 HTML 和 CSS 文件做一些调整："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-HTML",children:'\x3c!-- index.html --\x3e\n<!doctype html>\n<html lang="en">\n    <head>\n        <meta charset="UTF-8" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>SVG in WebGL</title>\n    </head>\n    <body>\n        <div id="app"></div>\n        <div class="controls">\n          <label for="focus">Focus:</label>\n          <input type="range" min="1" max="50" id="focus" name="focus" />\n          </div>\n        <script type="module" src="/main.js"><\/script>\n    </body>\n</html>\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-CSS",children:'/* style.css */\n*, *::before, *::after {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nhtml, body {\n    width: 100vw;\n    min-height: 100vh;\n    display: grid;\n    gap: 1rem;\n    place-content: center;\n}\n\nbody {\n    grid-template-rows: minmax(0, 1fr) min-content;\n    gap: 1rem;\n    padding: 1rem;\n}\n\n#app {\n    display: grid;\n    place-content: center;\n    width: 100vw;\n}\n\n.controls {\n    position: fixed;\n    bottom: 1rem;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 10px;\n    border-radius: 0.25em;\n    padding: 1vh 3vh;\n    color: #fff;\n    border: 1px solid rgba(0, 0, 0, 0.2);\n    background: rgb(125 155 125 / 0.5);\n    place-self: center;\n}\n\ninput[type="range"] {\n    -webkit-appearance: none;\n    width: 100%;\n    height: 2px;\n    border-radius: 5px;\n    background: rgb(0 0 0);\n    outline: none;\n    padding: 0;\n    margin: 0;\n    cursor: pointer;\n}\n\ninput[type="range"]::-webkit-slider-thumb {\n    -webkit-appearance: none;\n    width: 20px;\n    height: 20px;\n    border-radius: 50%;\n    background: #000;\n    cursor: pointer;\n    transition: all 0.15s ease-in-out;\n}\n\ninput[type="range"]::-webkit-slider-thumb:hover {\n    background: #333;\n    transform: scale(1.2);\n}\n\ninput[type="range"]::-moz-range-thumb {\n    width: 20px;\n    height: 20px;\n    border: 0;\n    border-radius: 50%;\n    background: white;\n    cursor: pointer;\n    transition: background 0.15s ease-in-out;\n}\n\ninput[type="range"]::-moz-range-thumb:hover {\n    background: #d4d4d4;\n}\n\nlabel {\n    white-space: nowrap;\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["在 HTML 中，添加了一个 ",(0,t.jsx)(e.code,{children:"type"})," 为 ",(0,t.jsx)(e.code,{children:"range"})," 的 ",(0,t.jsx)(e.code,{children:"<input>"})," 元素，用来控制 SVG 挤出的程度。然后，使用 CSS 美化控制件的样式，并且调整整个页面的布局。"]}),"\n",(0,t.jsx)(e.p,{children:"这样做之后，就可以使用 JavaScript 开始构建 Three.js 场景。"}),"\n",(0,t.jsxs)(e.p,{children:["首先从 ",(0,t.jsx)(e.code,{children:"main.js"})," 着手，在项目的 ",(0,t.jsx)(e.code,{children:"main.js"})," 文件中添加以下代码："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// main.js\nimport \'./style.css\'\n\nimport { setupScene } from "./scene";\nimport { renderSVG } from "./svg";\nimport { svg } from "./example";\n\nconst defaultExtrusion = 1;\nconst app = document.querySelector("#app");\nconst extrusionInput = document.querySelector("#focus");\nconst scene = setupScene(app);\nconst { object, update } = renderSVG(defaultExtrusion, svg);\n\nscene.add(object);\n\nextrusionInput.addEventListener("input", () => {\n    update(Number(extrusionInput.value));\n});\nextrusionInput.value = defaultExtrusion;\n'})}),"\n",(0,t.jsx)(e.p,{children:"这段代码展示了如何将 SVG 图形加载到 WebGL 场景中，并根据用户输入动态调整其挤出深度。以下是代码的详细解释："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// main.js\nimport { setupScene } from "./scene";\nimport { renderSVG } from "./svg";\nimport { svg } from "./example";\n'})}),"\n",(0,t.jsxs)(e.p,{children:["从其他模块导入了 ",(0,t.jsx)(e.code,{children:"setupScene"}),"、",(0,t.jsx)(e.code,{children:"renderSVG"})," 和 ",(0,t.jsx)(e.code,{children:"svg"}),"。这些模块分别用于设置 WebGL 场景、渲染 SVG 图形和提供 SVG 数据。"]}),"\n",(0,t.jsx)(e.p,{children:"紧接着初始化常量和变量："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// 默认的挤出深度\nconst defaultExtrusion = 1;\n\n// DOM 中的一个容器元素，用于显示 WebGL 场景\nconst app = document.querySelector("#app");\n\n// input 元素，用户可以通过它调整挤出深度\nconst extrusionInput = document.querySelector("#focus");\n\n// 通过 setupScene 函数设置的 WebGL 场景\nconst scene = setupScene(app);\n\n// 通过 renderSVG 函数渲染的 SVG 对象和用于更新挤出深度的函数\nconst { object, update } = renderSVG(defaultExtrusion, svg);\n'})}),"\n",(0,t.jsx)(e.p,{children:"然后再将渲染的 SVG 对象添加到 WebGL 场景中："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"scene.add(object);\n"})}),"\n",(0,t.jsxs)(e.p,{children:["最后给 ",(0,t.jsx)(e.code,{children:"input"})," 添加一个 ",(0,t.jsx)(e.code,{children:"input"})," 监听事件，当用户更改输入值时，调用 ",(0,t.jsx)(e.code,{children:"update"})," 函数，传递新的挤出深度。并且初始化 ",(0,t.jsx)(e.code,{children:"extrusionInput"})," 的值为 ",(0,t.jsx)(e.code,{children:"defaultExtrusion"}),"。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'extrusionInput.addEventListener("input", () => {\n    update(Number(extrusionInput.value));\n});\nextrusionInput.value = defaultExtrusion;\n'})}),"\n",(0,t.jsx)(e.p,{children:"此时，你在浏览器中将看不到任何效果，甚至在浏览器控制台上会有相关的报错信息。这是因为整个程序还没有完善。"}),"\n",(0,t.jsx)(e.p,{children:"在继续编码之前，请在项目中创建三个新的 JavaScript 文件："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"scene.js"})," ：创建一个 ",(0,t.jsx)(e.code,{children:"setupScene"})," 函数，这个函数可能初始化一个 Three.js 场景，包括摄像机、渲染器和其他必要的设置。通过传入的 ",(0,t.jsx)(e.code,{children:"app"})," 元素，将渲染器的输出附加到该元素中。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"svg.js"})," ：创建一个 ",(0,t.jsx)(e.code,{children:"renderSVG"})," 函数，这个函数可能使用 ",(0,t.jsx)(e.code,{children:"SVGLoader"})," 将 SVG 数据转换为 Three.js 对象，然后将这些对象挤出一定深度（由 ",(0,t.jsx)(e.code,{children:"defaultExtrusion"})," 指定）。返回的 ",(0,t.jsx)(e.code,{children:"object"})," 是一个包含 SVG 形状的 Three.js 对象，而 ",(0,t.jsx)(e.code,{children:"update"})," 是一个函数，用于更新挤出深度。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"example.js"})," ：提供 SVG 数据。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["我们从最简单的 ",(0,t.jsx)(e.code,{children:"example.js"})," 开始。首先使用诸如 Figma 之类的图形设计软件，设计一个符合你需求的 SVG 矢量图，并导出相应的 SVG 代码："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:v,alt:""})}),"\n",(0,t.jsxs)(e.p,{children:["然后使用 ",(0,t.jsx)(e.a,{href:"https://jakearchibald.github.io/svgomg/",target:"_blank",rel:"noopener noreferrer",children:"SVGOMG"})," 对导出的 SVG 代码进行优化："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:G,alt:""})}),"\n",(0,t.jsxs)(e.p,{children:["将优化后的 SVG 代码放在 ",(0,t.jsx)(e.code,{children:"example.js"})," 文件中："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// example.js\nconst svg = `<svg xmlns="http://www.w3.org/2000/svg" width="340" height="219" fill="none"><path fill="#050505" fill-rule="evenodd" d="M189.448 12.738 169.706 0l-19.743 12.738-24.179-9.007-13.961 15.602-26.969-4.663-7.227 17.402H49.706v18.016l-26.97 4.662 7.227 17.4L5.78 81.16l13.961 15.602L0 109.5l19.744 12.739-13.96 15.601 24.18 9.008-7.226 17.402 26.968 4.662v18.016h27.921l7.226 17.402 26.969-4.662 13.959 15.601 24.181-9.008L169.706 219l19.743-12.739 24.181 9.008 13.96-15.602 26.97 4.663 7.226-17.402h27.92v-18.015l26.97-4.663-7.227-17.402 24.178-9.008-13.959-15.601 19.743-12.739-19.742-12.738 13.961-15.603-24.18-9.008 7.226-17.401-26.97-4.663V32.072h-27.921l-7.226-17.401-26.97 4.663L213.627 3.73l-24.179 9.007Z" clip-rule="evenodd"/><path fill="#fff" d="M34.8 126.65c-1.633 0-3.15-.233-4.55-.7-1.367-.5-2.467-1.183-3.3-2.05-.833-.867-1.25-1.883-1.25-3.05 0-.767.183-1.433.55-2 .367-.6.867-.9 1.5-.9.4 0 .817.15 1.25.45.833.733 1.9 1.383 3.2 1.95 1.333.533 2.75.8 4.25.8 1.967 0 3.567-.383 4.8-1.15 1.267-.8 1.9-1.867 1.9-3.2 0-1.267-.583-2.183-1.75-2.75-1.167-.567-2.783-1.1-4.85-1.6a32.896 32.896 0 0 1-4.45-1.4c-1.4-.567-2.567-1.35-3.5-2.35-.9-1.033-1.35-2.4-1.35-4.1 0-1.3.283-2.583.85-3.85.567-1.3 1.4-2.483 2.5-3.55 1.1-1.067 2.433-1.917 4-2.55 1.567-.667 3.333-1 5.3-1 1.467 0 2.8.167 4 .5 1.233.333 2.2.8 2.9 1.4.733.6 1.1 1.333 1.1 2.2 0 .667-.183 1.25-.55 1.75-.367.5-.8.9-1.3 1.2-.5.267-.933.4-1.3.4-.333 0-.783-.15-1.35-.45-.933-.5-1.983-.883-3.15-1.15-1.133-.3-2.133-.45-3-.45-1.633 0-2.967.367-4 1.1-1 .7-1.5 1.533-1.5 2.5 0 1.067.633 1.967 1.9 2.7 1.3.7 3.617 1.45 6.95 2.25 2.267.6 4.033 1.433 5.3 2.5 1.267 1.033 1.9 2.683 1.9 4.95 0 2.033-.55 3.933-1.65 5.7-1.067 1.767-2.583 3.2-4.55 4.3-1.933 1.067-4.2 1.6-6.8 1.6Zm26.907.15c-1.133 0-2.017-.367-2.65-1.1-.6-.767-.95-2.083-1.05-3.95a56.847 56.847 0 0 0-.5-5.85 42.587 42.587 0 0 0-1-5.5c-.567-2.467-1.333-4.733-2.3-6.8-.933-2.1-2.233-3.817-3.9-5.15a5.955 5.955 0 0 1-.65-.65 1.424 1.424 0 0 1-.25-.85c0-.733.367-1.433 1.1-2.1.767-.667 1.65-1 2.65-1 1.167 0 2.167.483 3 1.45.833.967 1.583 2.317 2.25 4.05 1.133 2.733 1.95 5.8 2.45 9.2.533 3.367.833 6.617.9 9.75.033.933.167 1.567.4 1.9.233.3.633.45 1.2.45 1.2 0 2.367-.467 3.5-1.4 1.167-.933 2.217-2.2 3.15-3.8.967-1.6 1.733-3.417 2.3-5.45.567-2.033.85-4.167.85-6.4 0-1.367-.1-2.467-.3-3.3-.167-.867-.367-1.55-.6-2.05-.3-.667-.45-1.2-.45-1.6 0-.5.233-.967.7-1.4.467-.433 1-.783 1.6-1.05.633-.3 1.2-.45 1.7-.45.667 0 1.15.25 1.45.75.3.467.5 1.067.6 1.8.1.733.15 1.483.15 2.25 0 2.3-.267 4.733-.8 7.3s-1.3 5.1-2.3 7.6c-.967 2.467-2.133 4.717-3.5 6.75-1.333 2-2.817 3.6-4.45 4.8-1.633 1.2-3.383 1.8-5.25 1.8Zm32.332-.15c-2.3 0-4.367-.517-6.2-1.55-1.834-1.033-3.284-2.533-4.35-4.5-1.067-1.967-1.6-4.35-1.6-7.15 0-2.533.416-4.967 1.25-7.3a21.045 21.045 0 0 1 3.65-6.35c1.566-1.9 3.466-3.4 5.7-4.5 2.233-1.1 4.716-1.65 7.45-1.65 2 0 3.666.317 5 .95 1.333.633 2 1.567 2 2.8 0 .6-.167 1.2-.5 1.8-.3.567-.7 1.05-1.2 1.45-.5.4-1.017.6-1.55.6-.334 0-.6-.083-.8-.25-1.734-1.167-3.7-1.75-5.9-1.75-2.334 0-4.3.55-5.9 1.65-1.6 1.067-2.817 2.483-3.65 4.25-.8 1.767-1.2 3.683-1.2 5.75 0 3.1.866 5.567 2.6 7.4 1.766 1.833 4.116 2.75 7.05 2.75 1.266 0 2.45-.183 3.55-.55 1.1-.367 2-.9 2.7-1.6.7-.7 1.05-1.55 1.05-2.55 0-1-.3-1.767-.9-2.3-.6-.533-1.384-.917-2.35-1.15a15.189 15.189 0 0 0-3.15-.5c-.8-.067-1.4-.167-1.8-.3-.367-.133-.55-.533-.55-1.2 0-.8.25-1.467.75-2a2.805 2.805 0 0 1 1.85-.9c1-.1 2.2-.167 3.6-.2 1.4-.067 2.85-.1 4.35-.1 1.533-.033 2.966-.05 4.3-.05.433 0 .766.083 1 .25.233.133.35.433.35.9 0 .567-.134 1.183-.4 1.85a4.799 4.799 0 0 1-1 1.7c-.434.467-.934.7-1.5.7h-.8c.1.333.183.717.25 1.15.1.4.15.867.15 1.4 0 1.467-.35 2.867-1.05 4.2-.7 1.3-1.667 2.467-2.9 3.5-1.234 1.033-2.65 1.85-4.25 2.45-1.6.6-3.3.9-5.1.9Zm42.307 0c-2.9 0-5.25-.767-7.05-2.3-1.766-1.567-2.65-3.683-2.65-6.35 0-2.5.734-4.633 2.2-6.4 1.5-1.767 3.467-3.2 5.9-4.3-.366-1-.683-1.983-.95-2.95a12.338 12.338 0 0 1-.35-2.9c0-1.667.367-3.067 1.1-4.2.734-1.167 1.684-2.05 2.85-2.65 1.167-.6 2.4-.9 3.7-.9 1.234 0 2.35.25 3.35.75a6.253 6.253 0 0 1 2.5 2.15c.634.933.95 2.05.95 3.35 0 1.367-.366 2.6-1.1 3.7-.7 1.067-1.666 2.033-2.9 2.9-1.2.833-2.55 1.583-4.05 2.25.867 1.5 1.884 3.05 3.05 4.65 1.167 1.567 2.35 2.933 3.55 4.1.9-.8 1.634-1.633 2.2-2.5.567-.867.85-1.75.85-2.65 0-.667-.166-1.1-.5-1.3a2.9 2.9 0 0 0-.95-.5 5.442 5.442 0 0 1-.95-.4c-.2-.167-.3-.433-.3-.8 0-.6.2-1.233.6-1.9.4-.7.917-1.3 1.55-1.8.634-.5 1.317-.75 2.05-.75.667 0 1.267.317 1.8.95.534.6.8 1.75.8 3.45 0 1.7-.35 3.417-1.05 5.15-.666 1.733-1.75 3.45-3.25 5.15.867.567 1.7.85 2.5.85.6 0 1.05-.1 1.35-.3.3-.2.567-.417.8-.65.167-.167.334-.3.5-.4.167-.1.367-.15.6-.15.9 0 1.35.683 1.35 2.05 0 .767-.2 1.583-.6 2.45-.366.833-.95 1.533-1.75 2.1-.8.567-1.85.85-3.15.85-1.166 0-2.216-.25-3.15-.75-.9-.5-1.783-1.183-2.65-2.05a17.363 17.363 0 0 1-4.15 2.25c-1.4.5-2.933.75-4.6.75Zm2-20.8c1.4-.667 2.534-1.383 3.4-2.15.9-.767 1.35-1.6 1.35-2.5 0-.667-.233-1.217-.7-1.65-.466-.467-1.133-.7-2-.7-.9 0-1.616.3-2.15.9-.533.567-.8 1.35-.8 2.35 0 .467.067 1.033.2 1.7.167.667.4 1.35.7 2.05Zm-1.25 15.5c.767 0 1.584-.083 2.45-.25.9-.167 1.734-.417 2.5-.75a51.933 51.933 0 0 1-2.15-3.1 85.01 85.01 0 0 1-2.2-3.75 71.566 71.566 0 0 1-1.6-3.2c-1.566.733-2.8 1.65-3.7 2.75-.866 1.067-1.3 2.233-1.3 3.5 0 1.433.55 2.6 1.65 3.5 1.1.867 2.55 1.3 4.35 1.3Zm43.886 5.35c-1.133 0-2.016-.317-2.65-.95-.6-.667-.933-1.917-1-3.75a84.393 84.393 0 0 0-.3-5.85 45.24 45.24 0 0 0-.8-5.5c-.5-2.533-1.183-4.817-2.05-6.85-.866-2.033-2.083-3.783-3.65-5.25a6.183 6.183 0 0 1-.65-.75c-.166-.233-.25-.5-.25-.8 0-.7.367-1.367 1.1-2 .734-.667 1.6-1 2.6-1 1.167 0 2.167.5 3 1.5.834 1 1.55 2.4 2.15 4.2.7 1.833 1.25 3.833 1.65 6 .4 2.167.667 4.383.8 6.65.167 2.233.25 4.4.25 6.5 0 .733.1 1.217.3 1.45.2.233.55.35 1.05.35 1.1 0 2.184-.333 3.25-1 1.1-.667 2.084-1.567 2.95-2.7.9-1.167 1.617-2.45 2.15-3.85.534-1.4.817-2.817.85-4.25.034-1.5-.233-2.95-.8-4.35-.533-1.433-1.233-2.65-2.1-3.65a7.187 7.187 0 0 1-.55-.7c-.1-.233-.15-.467-.15-.7 0-.533.217-1.05.65-1.55.434-.5.934-.917 1.5-1.25.567-.333 1.05-.5 1.45-.5.834 0 1.534.617 2.1 1.85.6 1.2 1.1 2.667 1.5 4.4.567 2.2.967 4.667 1.2 7.4.234 2.733.35 5.617.35 8.65 0 .833.084 1.4.25 1.7.167.3.534.45 1.1.45 1.2 0 2.367-.433 3.5-1.3 1.134-.867 2.134-2.05 3-3.55.9-1.533 1.6-3.267 2.1-5.2.534-1.967.8-4.033.8-6.2 0-1.633-.133-2.95-.4-3.95-.233-1.033-.466-1.767-.7-2.2-.333-.633-.5-1.167-.5-1.6 0-.5.217-.967.65-1.4a5.862 5.862 0 0 1 1.65-1.15c.634-.3 1.184-.45 1.65-.45.734 0 1.25.317 1.55.95.334.6.534 1.35.6 2.25.1.9.15 1.75.15 2.55 0 2.3-.25 4.717-.75 7.25-.466 2.5-1.15 4.95-2.05 7.35-.9 2.367-1.983 4.517-3.25 6.45-1.233 1.9-2.633 3.433-4.2 4.6-1.566 1.133-3.25 1.7-5.05 1.7-1.2 0-2.083-.267-2.65-.8-.566-.533-.933-1.283-1.1-2.25-.166-.967-.25-2.1-.25-3.4v-2.15c.034-.7.05-1.333.05-1.9-1.533 3.433-3.383 6.05-5.55 7.85-2.166 1.767-4.333 2.65-6.5 2.65Zm40.145-.05c-2.533 0-4.517-.717-5.95-2.15-1.4-1.467-2.1-3.5-2.1-6.1 0-2.367.517-4.517 1.55-6.45 1.033-1.933 2.417-3.467 4.15-4.6 1.767-1.167 3.7-1.75 5.8-1.75 2 0 3.6.5 4.8 1.5 1.2.967 1.8 2.267 1.8 3.9 0 1.3-.4 2.5-1.2 3.6-.8 1.1-1.867 1.983-3.2 2.65-1.333.633-2.817.95-4.45.95-2 0-3.633-.45-4.9-1.35.033 1.533.55 2.767 1.55 3.7 1.033.933 2.35 1.4 3.95 1.4a9.3 9.3 0 0 0 2.95-.5c1.033-.367 1.917-.85 2.65-1.45.467-.4.9-.6 1.3-.6.333 0 .6.117.8.35.233.2.35.467.35.8 0 .733-.633 1.7-1.9 2.9-2.233 2.133-4.883 3.2-7.95 3.2Zm.75-11.75c1.2 0 2.2-.25 3-.75.8-.5 1.2-1.133 1.2-1.9 0-.633-.267-1.117-.8-1.45-.533-.367-1.267-.55-2.2-.55-1.233 0-2.317.333-3.25 1-.9.633-1.55 1.533-1.95 2.7.467.3 1.067.533 1.8.7a9.88 9.88 0 0 0 2.2.25Zm22.838 11.75c-1.233 0-2.3-.217-3.2-.65a8.765 8.765 0 0 1-2.3-1.65 7.693 7.693 0 0 1-1.2 1.55c-.433.433-.933.65-1.5.65-.367 0-.717-.117-1.05-.35-.333-.2-.467-.483-.4-.85.5-2.667.917-5.367 1.25-8.1.367-2.733.55-5.517.55-8.35 0-2.367-.083-4.583-.25-6.65-.167-2.067-.683-3.967-1.55-5.7-.167-.333-.317-.65-.45-.95-.1-.3-.15-.583-.15-.85 0-.633.367-1.25 1.1-1.85.733-.6 1.517-.9 2.35-.9 1.2 0 2.017.733 2.45 2.2.433 1.467.65 3.633.65 6.5 0 2.433-.117 4.667-.35 6.7-.2 2-.433 3.717-.7 5.15.933-1.967 2.2-3.617 3.8-4.95 1.633-1.367 3.467-2.05 5.5-2.05s3.617.683 4.75 2.05c1.167 1.333 1.75 3.15 1.75 5.45 0 1.7-.267 3.367-.8 5a15.374 15.374 0 0 1-2.25 4.35 11.094 11.094 0 0 1-3.5 3.1c-1.333.767-2.833 1.15-4.5 1.15Zm1.15-5.4c1.9 0 3.367-.6 4.4-1.8 1.033-1.2 1.55-2.583 1.55-4.15 0-1.367-.383-2.417-1.15-3.15-.733-.767-1.717-1.15-2.95-1.15a5.167 5.167 0 0 0-3.3 1.15c-.967.733-1.783 1.717-2.45 2.95a16.71 16.71 0 0 0-1.55 3.9 8.55 8.55 0 0 0 2.55 1.7 8.12 8.12 0 0 0 2.9.55Zm26.25 5.4c-2.3 0-4.367-.517-6.2-1.55-1.833-1.033-3.283-2.533-4.35-4.5-1.067-1.967-1.6-4.35-1.6-7.15 0-2.533.417-4.967 1.25-7.3.867-2.367 2.083-4.483 3.65-6.35a17.09 17.09 0 0 1 5.7-4.5c2.233-1.1 4.717-1.65 7.45-1.65 2 0 3.667.317 5 .95 1.333.633 2 1.567 2 2.8 0 .6-.167 1.2-.5 1.8-.3.567-.7 1.05-1.2 1.45-.5.4-1.017.6-1.55.6-.333 0-.6-.083-.8-.25-1.733-1.167-3.7-1.75-5.9-1.75-2.333 0-4.3.55-5.9 1.65a10.274 10.274 0 0 0-3.65 4.25c-.8 1.767-1.2 3.683-1.2 5.75 0 3.1.867 5.567 2.6 7.4 1.767 1.833 4.117 2.75 7.05 2.75 1.267 0 2.45-.183 3.55-.55 1.1-.367 2-.9 2.7-1.6.7-.7 1.05-1.55 1.05-2.55 0-1-.3-1.767-.9-2.3-.6-.533-1.383-.917-2.35-1.15a15.195 15.195 0 0 0-3.15-.5c-.8-.067-1.4-.167-1.8-.3-.367-.133-.55-.533-.55-1.2 0-.8.25-1.467.75-2a2.806 2.806 0 0 1 1.85-.9c1-.1 2.2-.167 3.6-.2 1.4-.067 2.85-.1 4.35-.1 1.533-.033 2.967-.05 4.3-.05.433 0 .767.083 1 .25.233.133.35.433.35.9 0 .567-.133 1.183-.4 1.85a4.784 4.784 0 0 1-1 1.7c-.433.467-.933.7-1.5.7h-.8c.1.333.183.717.25 1.15.1.4.15.867.15 1.4 0 1.467-.35 2.867-1.05 4.2-.7 1.3-1.667 2.467-2.9 3.5-1.233 1.033-2.65 1.85-4.25 2.45-1.6.6-3.3.9-5.1.9Zm29.231 0c-2.267 0-4.017-.25-5.25-.75-1.233-.5-2.083-1.2-2.55-2.1-.467-.9-.7-1.967-.7-3.2 0-.6.05-1.267.15-2 .1-.767.217-1.633.35-2.6.6-3.667.9-6.917.9-9.75 0-1.867-.083-3.45-.25-4.75-.133-1.333-.567-2.6-1.3-3.8-.133-.2-.25-.4-.35-.6-.1-.233-.15-.417-.15-.55 0-.4.233-.817.7-1.25a6.23 6.23 0 0 1 1.7-1.1c.667-.3 1.3-.45 1.9-.45 1.133 0 1.833.45 2.1 1.35.3.9.45 2.183.45 3.85 0 .633-.067 1.65-.2 3.05a199.211 199.211 0 0 1-.6 5.25c-.267 2.067-.467 3.85-.6 5.35-.133 1.5-.2 2.7-.2 3.6 0 1.333.15 2.35.45 3.05.333.667.867 1.133 1.6 1.4.733.267 1.767.4 3.1.4 1.433 0 2.8-.117 4.1-.35 1.3-.267 2.567-.667 3.8-1.2.167-.067.317-.117.45-.15.133-.033.25-.05.35-.05.3 0 .583.183.85.55.267.367.4.883.4 1.55 0 1.467-.8 2.617-2.4 3.45-2.133 1.2-5.067 1.8-8.8 1.8Z"/></svg>`;\nexport { svg };\n'})}),"\n",(0,t.jsxs)(e.p,{children:["这样，你就得到了 ",(0,t.jsx)(e.code,{children:"svg"})," 模块。"]}),"\n",(0,t.jsxs)(e.p,{children:["在这之后，将重点放到 ",(0,t.jsx)(e.code,{children:"svg.js"})," 上，使用 ",(0,t.jsx)(e.code,{children:"SVGLoader"})," 将 SVG 数据解析为 WebGL 对象，并根据用户输入的挤出深度动态更新这些对象："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// svg.js\n\n// 导入模块\n// 导入 Three.js 库的所有功能\nimport * as THREE from "three"; \n// 导入 SVG 加载器，用于解析 SVG 文件\nimport { SVGLoader } from "three/examples/jsm/loaders/SVGLoader";\n\n// 材质定义\n// 用于填充 SVG 图形的材质\nconst fillMaterial = new THREE.MeshBasicMaterial({ color: "#F3FBFB" });\n// 用于绘制 SVG 图形边缘的材质\nconst stokeMaterial = new THREE.LineBasicMaterial({\n    color: "#00A5E6",\n});\n\n// renderSVG 函数,用于解析 SVG 数据并创建相应的 Three.js 对象\nconst renderSVG = (extrusion, svg) => {\n    // SVGLoader 实例，用于解析 SVG 数据\n    const loader = new SVGLoader();\n    \n    // 解析后的 SVG 数据\n    const svgData = loader.parse(svg);\n    \n    // 一个 Three.js 组对象，用于包含所有生成的 Three.js 对象\n    const svgGroup = new THREE.Group();\n    \n    // 存储更新挤出深度时所需的对象信息\n    const updateMap = [];\n\n    // 解析 SVG 路径并创建对象\n    // 将 SVG 组对象的 Y 轴缩放反转，适应 Three.js 坐标系\n    svgGroup.scale.y *= -1;\n    \n    // 遍历每个 SVG 路径\n    svgData.paths.forEach((path) => {\n        // 将路径转换为形状数组\n        const shapes = SVGLoader.createShapes(path);\n    \n        shapes.forEach((shape) => {\n            // 使用挤出几何体创建形状\n            const meshGeometry = new THREE.ExtrudeGeometry(shape, {\n                depth: extrusion,\n                bevelEnabled: false,\n            });\n            \n            // 创建几何体边缘\n            const linesGeometry = new THREE.EdgesGeometry(meshGeometry);\n            \n            // 创建填充网格\n            const mesh = new THREE.Mesh(meshGeometry, fillMaterial);\n            \n            // 创建边缘线段\n            const lines = new THREE.LineSegments(linesGeometry, stokeMaterial);\n    \n            // 将形状、网格和线段信息添加到更新映射中\n            updateMap.push({ shape, mesh, lines });\n            \n            // 将网格和线段添加到 SVG 组对象中\n            svgGroup.add(mesh, lines);\n        });\n    });\n\n    // 调整和居中对象\n    // 计算 SVG 组对象的包围盒\n    const box = new THREE.Box3().setFromObject(svgGroup);\n    \n    // 获取包围盒的尺寸\n    const size = box.getSize(new THREE.Vector3());\n    \n    // 计算偏移量以居中对象\n    const yOffset = size.y / -2;\n    const xOffset = size.x / -2;\n\n    // 调整组中每个对象的位置\n    svgGroup.children.forEach((item) => {\n        item.position.x = xOffset;\n        item.position.y = yOffset;\n    });\n    \n    // 将整个组对象绕 X 轴旋转，使其平铺在地面上\n    svgGroup.rotateX(-Math.PI / 2);\n\n    // 返回对象和更新函数\n    return {\n        // 返回一个包含 SVG 组对象\n        object: svgGroup,\n        \n        // 更新挤出深度函数\n        update(extrusion) {\n            // 遍历 updateMap 数组，重新创建挤出几何体和边缘几何体\n            updateMap.forEach((updateDetails) => {\n                const meshGeometry = new THREE.ExtrudeGeometry(updateDetails.shape, {\n                    depth: extrusion,\n                    bevelEnabled: false,\n                });\n                const linesGeometry = new THREE.EdgesGeometry(meshGeometry);\n                \n                // 释放旧的几何体资源 (dispose)，并将新的几何体赋值给网格和线段对象\n                updateDetails.mesh.geometry.dispose();\n                updateDetails.lines.geometry.dispose();\n                updateDetails.mesh.geometry = meshGeometry;\n                updateDetails.lines.geometry = linesGeometry;\n            });\n        },\n    };\n};\n\n// 将 renderSVG 函数导出，以便在其他模块中使用\nexport { renderSVG };\n'})}),"\n",(0,t.jsxs)(e.p,{children:["这里简单解释一下 ",(0,t.jsx)(e.code,{children:"SVGLoader"})," ，它是 Three.js 的一个 ",(0,t.jsx)(e.code,{children:"Loader"})," 类实例，继承并扩展了其方法和属性，最显著的是 ",(0,t.jsx)(e.code,{children:"load()"})," 、",(0,t.jsx)(e.code,{children:"loadAsync()"})," 和 ",(0,t.jsx)(e.code,{children:"parse()"})," 。这三个方法负责 ",(0,t.jsx)(e.code,{children:"SVGLoader"})," 的大部分功能。它们都以不同的方式产生 ",(0,t.jsx)(e.code,{children:"ShapePath"})," 实例的数组。"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"使用回调函数同步加载 SVG。"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"使用 Promise 异步加载 SVG。"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"直接解析已有的 SVG 数据字符串。"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// 导入和初始化 SVGLoader,\n// 创建一个 SVGLoader 实例，用于加载和解析 SVG 数据\nconst loader = new SVGLoader();\nconst svgUrl = "..."; //SVG URL\nconst svg = "..."; // SVG data\n\n// 使用回调函数加载 SVG\nloader.load(svgUrl, (data) => {\n  const shapePaths = data.paths;\n  // ...\n});\n\n\n// 使用 Promise 进行异步加载\nloader.loadAsync(svgUrl).then((data) => {\n  const shapePaths = data.paths;\n  // ...\n});\n\n// 解析现有的 SVG 数据字符串\nconst data = loader.parse(svg);\nconst shapePaths = data.paths;\n'})}),"\n",(0,t.jsxs)(e.p,{children:["所有方法的最终结果是一个包含路径数组的 ",(0,t.jsx)(e.code,{children:"data"})," 对象，这些路径可以进一步处理或转换为 Three.js 的几何体，以在 WebGL 场景中使用。要点在于，当使用 ",(0,t.jsx)(e.code,{children:"SVGLoader"})," 时，你始终会使用这些方法中的至少一个，具体取决于你希望如何访问 SVG 数据。有关更详细的信息，",(0,t.jsx)(e.a,{href:"https://threejs.org/docs/#examples/en/loaders/SVGLoader",target:"_blank",rel:"noopener noreferrer",children:"你可以参考官方文档"}),"。"]}),"\n",(0,t.jsxs)(e.p,{children:["一旦获得了 ",(0,t.jsx)(e.code,{children:"ShapePaths"}),"，你就需要将它们转换为一组 ",(0,t.jsx)(e.code,{children:"Shapes"}),"。为此，你应该使用 ",(0,t.jsx)(e.code,{children:"SVGLoader.createShapes()"})," 静态方法，如下所示："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"shapePaths.forEach((path) => {\n    const shapes = SVGLoader.createShapes(path);\n    // ...\n});\n"})}),"\n",(0,t.jsx)(e.p,{children:"其他相关的就不在这里解释了，具体的可以参阅示例代码中的注释。"}),"\n",(0,t.jsxs)(e.p,{children:["现在万事俱备，只需在 ",(0,t.jsx)(e.code,{children:"scene.js"})," 中创建 Three.js 场景。在这里将定义了一个函数 ",(0,t.jsx)(e.code,{children:"setupScene"}),"，用于设置和初始化一个 Three.js 场景，并导出了该函数。它包括创建场景、渲染器、摄像机、光源、控制器以及一个动画循环。下面是对代码的详细解释："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// scene.js \n\n// 导入模块\n// 从 three 包中导入所有的 Three.js 模块\nimport * as THREE from "three";\n\n// 从 three/examples/jsm/controls/OrbitControls 导入 OrbitControls，用于控制摄像机的交互\nimport { OrbitControls } from "three/examples/jsm/controls/OrbitControls";\n\n// 定义一个名为 setupScene 的函数，接受一个 DOM 元素 container 作为参数，用于将 Three.js 渲染器附加到该元素上。\nconst setupScene = (container) => {\n    // 创建一个新的 Three.js 场景对象\n    const scene = new THREE.Scene();\n    \n    // 创建一个 WebGL 渲染器，启用抗锯齿（antialias: true）和透明背景（alpha: true）\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    \n    // 创建摄像机:创建一个透视摄像机\n    const camera = new THREE.PerspectiveCamera(\n        50, // 视角为 50 度\n        window.innerWidth / window.innerHeight, // 纵横比为窗口的宽高比\n        0.01, // 近剪裁面为 0.01\n        1e5   // 远剪裁面为 100,000\n    );\n    \n    // 添加光源\n    // 创建一个环境光源，颜色为 #888888，用于为整个场景提供基本的全局照明\n    const ambientLight = new THREE.AmbientLight("#888888");\n    \n    // 创建一个点光源，颜色为 #ffffff，强度为 2，距离为 800\n    const pointLight = new THREE.PointLight("#ffffff", 2, 800);\n    \n    // 设置轨道控制器\n    // 创建一个轨道控制器，允许用户通过鼠标交互来旋转、缩放和平移摄像机。控制器绑定到摄像机和渲染器的 DOM 元素\n    const controls = new OrbitControls(camera, renderer.domElement);\n    \n    // 定义一个动画函数 animate，在每一帧中渲染场景并更新控制器\n    // 使用 requestAnimationFrame 实现循环动画\n    const animate = () => {\n        renderer.render(scene, camera);\n        controls.update();\n    \n        requestAnimationFrame(animate);\n    };\n\n    // 初始化渲染器和摄像机位置\n    // 设置渲染器的尺寸为窗口的宽度和高度\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    \n    // 将光源添加到场景中\n    scene.add(ambientLight, pointLight);\n    \n    // 设置摄像机的位置，使其位于 (50, 50, 50)\n    camera.position.z = 50;\n    camera.position.x = 50;\n    camera.position.y = 50;\n    \n    // 禁用平移控制（即摄像机只能旋转和缩放，不能平移）\n    controls.enablePan = false;\n\n    // 将渲染器附加到 DOM 并处理窗口调整\n    // 将渲染器的 DOM 元素附加到传入的容器元素上\n    container.append(renderer.domElement);\n    \n    // 添加一个事件监听器，在窗口调整大小时更新摄像机的纵横比和渲染器的尺寸\n    window.addEventListener("resize", () => {\n        camera.aspect = window.innerWidth / window.innerHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(window.innerWidth, window.innerHeight);\n    });\n    \n    // 启动动画循环\n    animate();\n    \n    // 返回场景对象\n    return scene;\n};\n\n// 导出 setupScene 函数，以便在其他模块中使用\nexport { setupScene };\n'})}),"\n",(0,t.jsx)(e.p,{children:"这个时候，你在浏览器中能看到一个类似下图的效果："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/GRaqKyN",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/GRaqKyN"})]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["当然，如果你对 WebGL 熟悉的话，那么可以通过增加额外的功能来增强其效果。例如，我们可以在 ",(0,t.jsx)(e.code,{children:"scene.js"})," 中增加一个名为 ",(0,t.jsx)(e.code,{children:"fitCameraToObject"})," 的函数，用于调整 Three.js 场景中的摄像机，使其适合查看给定的 3D 对象。该函数接受三个参数：",(0,t.jsx)(e.code,{children:"camera"}),"（Three.js 摄像机对象）、",(0,t.jsx)(e.code,{children:"object"}),"（要适应的 3D 对象）和 ",(0,t.jsx)(e.code,{children:"controls"}),"（轨道控制器对象）。"]}),"\n",(0,t.jsx)(e.p,{children:"具体代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// scene.js\nimport * as THREE from "three";\nimport { OrbitControls } from "three/examples/jsm/controls/OrbitControls";\n\nconst setupScene = (container) => {\n    // 查看前面的 scene.js\n    \n    // camera:场景中的摄像机\n    // controls: 用于在 Three.js 场景中平移、缩放和旋转摄像机，使用户可以通过鼠标交互查看场景中的对象\n    // scene: Three.js 场景\n    return { camera, controls, scene };\n}\n\n// 用于调整 Three.js 场景中的摄像机，使其适合查看给定的 3D 对象\n// camera（Three.js 摄像机对象）\n// object（要适应的 3D 对象） \n// controls（轨道控制器对象）\nconst fitCameraToObject = (camera, object, controls) => {\n    // 获取对象的边界框\n    const boundingBox = new THREE.Box3().setFromObject(object);\n    \n    // 计算边界框的中心和大小\n    // 获取边界框的中心点，并存储在 center 向量中\n    const center = boundingBox.getCenter(new THREE.Vector3());\n    \n    // 取边界框的尺寸（宽、高、深），并存储在 size 向量中\n    const size = boundingBox.getSize(new THREE.Vector3());\n    \n    // 计算摄像机的位置和距离\n    // 定义一个偏移量 offset，用于在对象边缘外添加一些空间\n    const offset = 1.25;\n    \n    // 计算对象的最大尺寸 maxDim，即对象的宽、高、深中的最大值\n    const maxDim = Math.max(size.x, size.y, size.z);\n    \n    // 计算摄像机的视场角 fov（从度转换为弧度）\n    const fov = camera.fov * (Math.PI / 180);\n    \n    // 根据最大尺寸和视场角计算摄像机的 Z 轴位置 cameraZ，使用偏移量来增加一些额外的空间\n    const cameraZ = Math.abs((maxDim / 4) * Math.tan(fov * 2)) * offset;\n    \n    // 获取边界框的最小 Z 值 minZ\n    const minZ = boundingBox.min.z;\n    \n    // 计算摄像机到对象最远边缘的距离 cameraToFarEdge，如果最小 Z 值小于 0，需要调整距离以确保对象完全在视野内\n    const cameraToFarEdge = minZ < 0 ? -minZ + cameraZ : cameraZ - minZ;\n  \n    // 调整轨道控制器\n    // 将轨道控制器的目标设置为对象的中心点 center\n    controls.target = center;\n    \n    // 设置控制器的最大和最小距离，确保用户在缩放时不会把摄像机移动得离对象太远或太近\n    controls.maxDistance = cameraToFarEdge * 2;\n    controls.minDistance = cameraToFarEdge * 0.5;\n    \n    // 调用 saveState 方法保存当前的控制器状态\n    controls.saveState();\n    \n    // 调整摄像机参数\n    // 设置摄像机的 Z 轴位置，使其适合查看对象\n    camera.position.z = cameraZ; \n    // 设置摄像机的远剪裁面 camera.far，确保摄像机能够渲染到对象的最远边缘\n    camera.far = cameraToFarEdge * 3;\n    // 调用 updateProjectionMatrix 方法更新摄像机的投影矩阵，以应用新的参数\n    camera.updateProjectionMatrix();\n};\n\n// 导出 fitCameraToObject 和 setupScene 函数，以便在其他模块中使用\nexport { fitCameraToObject, setupScene };\n'})}),"\n",(0,t.jsxs)(e.p,{children:["新增的 ",(0,t.jsx)(e.code,{children:"fitCameraToObject"})," 函数，通过计算 3D 对象的边界框，然后调整摄像机的位置、视距和轨道控制器的参数，确保摄像机能够适当地看到整个对象。这样，摄像机将位于适当的位置，并且用户可以通过轨道控制器平滑地缩放和旋转查看对象。"]}),"\n",(0,t.jsxs)(e.p,{children:["注意，",(0,t.jsx)(e.code,{children:"setupScene()"})," 函数也需要进行调整，以便轻松访问相机和控件实例。然后只需在 ",(0,t.jsx)(e.code,{children:"index.html"})," 调整HTML 结构，即添加一个 ",(0,t.jsx)(e.code,{children:"#focusButton"})," 按钮："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-HTML",children:'\x3c!-- index.html --\x3e\n<div id="app"></div>\n<div class="forms">\n    <button id="focusButton" class="button">Focus</button>\n    <div class="controls">\n        <input type="range" min="1" max="50" id="focus" name="focus" />\n    </div>\n</div>\n'})}),"\n",(0,t.jsx)(e.p,{children:"重新调整布局相关的 CSS，使其符合你需要的效果。这里就不展示 CSS 代码了。"}),"\n",(0,t.jsxs)(e.p,{children:["最后，还需要调整 ",(0,t.jsx)(e.code,{children:"main.js"})," ，将新增的 ",(0,t.jsx)(e.code,{children:"fitCameraToObject"})," 功能绑定到 ",(0,t.jsx)(e.code,{children:"#focusButton"})," 按钮之上："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'import {fitCameraToObject, setupScene } from "./scene";\nimport { renderSVG } from "./svg";\nimport { svg } from "./example";\n\nconst defaultExtrusion = 1;\nconst app = document.querySelector("#app");\nconst extrusionInput = document.querySelector("#focus");\nconst focusButton = document.querySelector("#focusButton");\nconst { scene, camera, controls } = setupScene(app);\nconst { object, update } = renderSVG(defaultExtrusion, svg);\n\nscene.add(object);\n\nextrusionInput.addEventListener("input", () => {\n    update(Number(extrusionInput.value));\n});\n\nfocusButton.addEventListener("click", () => {\n    fitCameraToObject(camera, object, controls);\n});\n\nextrusionInput.value = defaultExtrusion;\n'})}),"\n",(0,t.jsx)(e.p,{children:"这就是我们如何向我们的 3D 应用程序添加焦点功能！"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:S,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/QWREWWZ",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/QWREWWZ"})]}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"使用-react-three-fiber-拆分-svg-并重用-webgl-组件",children:["使用 React-three-fiber 拆分 SVG 并重用 WebGL 组件",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-react-three-fiber-拆分-svg-并重用-webgl-组件",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"接着，我们来看一个 SVG 和 WebGL 在 React 应用中的案例。在这个案例中，我们将学习如何使用 Three.js 和 React 将 SVG 在 3D 空间中拆分，并使用抽像方法将场景图分解为可复用的组件。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsxs)(e.p,{children:["在这个案例中，我们会依赖 ",(0,t.jsx)(e.code,{children:"recat-three-fiber"})," 库，它是一个基于 React 的库，用于在 React 应用中使用 Three.js 创建和管理 3D 场景。它将 Three.js 的 API 映射到 React 组件，使得在 React 应用中可以更直观和组件化地处理 3D 图形。其主要特点是："]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"组件化"}),"：将 3D 对象、灯光、相机等封装成 React 组件，使得代码更易于管理和重用。"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"声明式"}),"：通过 JSX 语法声明 3D 场景和对象，而不是通过 Imperative（命令式）代码创建和修改场景。"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"与 React 生态系统集成"}),"：可以利用 React 的状态管理、生命周期方法、上下文等特性来控制和管理 3D 场景。"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["不过，在我们这个示例中，将向大家演示如何使用 ",(0,t.jsx)(e.code,{children:"react-three-fiber"})," 提供的 ",(0,t.jsx)(e.code,{children:"declarative"})," 方式来管理 Three.js 场景和对象，使得代码更具可读性和可维护性。通过创建可复用的组件，我们可以更加灵活地构建复杂的 3D 应用。"]}),"\n",(0,t.jsx)(e.p,{children:"和前面的示例一样，我们通过 Vite 来初始化一个 React 应用，并且安装相关的依赖项："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"pnpm create vite\npnpm three @react-three/fiber @react-three/drei -D\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsxs)(e.p,{children:["安装完成相关依赖，执行 ",(0,t.jsx)(e.code,{children:"pnpm run dev"})," ，你在浏览器会看到像下图这样的一个界面："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"这表示 React 项目初始化已完成。项目初始化完成之后，需要安装相关的依赖项："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"pnpm install -D three @react-three/fiber @react-three/drei @react-three/fiber @react-three/flex @types/three\n"})}),"\n",(0,t.jsxs)(e.p,{children:["现在，我们就可以在 Vite React 应用上开始使用 ",(0,t.jsx)(e.code,{children:"react-three-fiber"})," 。首先，我们调整项目的 ",(0,t.jsx)(e.code,{children:"App.tsx"})," 文件，删除默认的内容："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'import "./App.css";\n\nexport default function App() {\n    return (\n        <div className="app">\n            \n        </div>\n    );\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-CSS",children:".app {\n    width: 100vw;\n    height: 100vh;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"现在，页面一片空白，什么都没有！"}),"\n",(0,t.jsxs)(e.p,{children:["接下来，我们从创建一个简单的 Three.js 场景开始，并设置基础的照明和相机。整个场景是通过 ",(0,t.jsx)(e.code,{children:"react-three-fiber"})," 创建的，并且将创建 Three.js 场景所需要的代码放置在一个名为 ",(0,t.jsx)(e.code,{children:"Scene.tsx"})," 文件中："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// Scene.tsx\nimport { Suspense } from "react";\nimport { Canvas } from "@react-three/fiber";\nimport { OrbitControls, PerspectiveCamera } from "@react-three/drei";\n\nexport default function Scene() {\n    return (\n        <Canvas>\n            <PerspectiveCamera makeDefault position={[0, 0, 10]} />\n            <OrbitControls />\n            <ambientLight intensity={Math.PI / 2} />\n            <spotLight\n                position={[10, 10, 10]}\n                angle={0.15}\n                penumbra={1}\n                decay={0}\n                intensity={Math.PI}\n            />\n            <pointLight position={[-10, -10, -10]} decay={0} intensity={Math.PI} />\n            <directionalLight position={[10, 10, 10]} />\n          \n        </Canvas>\n    );\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"我们从导入模块开始，简单解释一下上面的代码："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// 从 react-three-fiber 中导入 Canvas 组件，用于在 React 中创建 Three.js 场景\nimport { Canvas } from "@react-three/fiber";\n\n// OrbitControls 用于添加轨道控制（例如，旋转、缩放和平移）\n// PerspectiveCamera 用于设置透视摄像机\nimport { OrbitControls, PerspectiveCamera } from "@react-three/drei";\n'})}),"\n",(0,t.jsxs)(e.p,{children:["整个 3D 场景功能都放置在 ",(0,t.jsx)(e.code,{children:"Scene"})," 组件中，它包含了不同类型的灯光源。",(0,t.jsx)(e.code,{children:"PerspectiveCamera"})," 和 ",(0,t.jsx)(e.code,{children:"OrbitControls"})," 用于控制视角和摄像机移动。所有的灯光设置和摄像机配置使得场景中的物体（如 SVG 图形）可以被清晰地看到和交互。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"export default function Scene() {\n    return (\n        // 创建 Three.js 场景的根组件\n        <Canvas>\n            //  设置一个默认的透视摄像机，位置为 (0, 0, 10)\n            <PerspectiveCamera makeDefault position={[0, 0, 10]} />\n            \n            // 为摄像机添加轨道控制 \n            <OrbitControls />\n            \n            // 添加一个环境光源，强度为 Math.PI / 2\n            <ambientLight intensity={Math.PI / 2} />\n            \n            // 添加一个聚光灯，设置了位置、角度、半影、衰减和强度\n            <spotLight\n                position={[10, 10, 10]}\n                angle={0.15}\n                penumbra={1}\n                decay={0}\n                intensity={Math.PI}\n            />\n            \n            // 添加一个点光源，设置了位置、衰减和强度\n            <pointLight position={[-10, -10, -10]} decay={0} intensity={Math.PI} />\n            \n            // 添加一个方向光，设置了位置\n            <directionalLight position={[10, 10, 10]} />\n        </Canvas>\n    );\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["然后，可以在 ",(0,t.jsx)(e.code,{children:"App.tsx"})," 中引入这个新创建的 3D 场景，即 ",(0,t.jsx)(e.code,{children:"Scene"})," 组件："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// App.tsx\nimport "./App.css";\nimport Scene from "./Scene";\n\nexport default function App() {\n    return (\n        <div className="app">\n            <Scene />\n        </div>\n    );\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["到目前为止，整个 3D 场景只有不同类型的灯光源和摄像机，页面依然还是空白。我们需要往场景中添加实物，这个实物就是 SVG 图形。因此，我们创建一个 ",(0,t.jsx)(e.code,{children:"SVGMesh.tsx"})," 文件，主要用于处理 ",(0,t.jsx)(e.code,{children:"SVGMesh"})," 组件相关的事情。"]}),"\n",(0,t.jsxs)(e.p,{children:["假设，在你的项目的 ",(0,t.jsx)(e.code,{children:"public"})," 文件夹下有一个名为 ",(0,t.jsx)(e.code,{children:"lvup_icon.svg"})," 的 SVG 文件，它是一只老虎的图形："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsxs)(e.p,{children:["在用于项目时，请记得使用",(0,t.jsx)(e.a,{href:"https://jakearchibald.github.io/svgomg/",target:"_blank",rel:"noopener noreferrer",children:" SVGOMG 工具"}),"做一些优化，使 SVG 变得干净一些："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["SVGOMG：",(0,t.jsx)(e.a,{href:"https://jakearchibald.github.io/svgomg/",target:"_blank",rel:"noopener noreferrer",children:"https://jakearchibald.github.io/svgomg/"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"为了能体验 3D 场景的灯光效果，请尽可能使用一张颜色多样的 SVG 文件。"}),"\n",(0,t.jsx)(e.p,{children:"我们这节课的目标是将 SVG 图形融入到 WebGL 中，通过 WebGL 创建更高级的图形。与上一个示例一样，我们需要使用 SVGLoader 来提取 SVG 路径，因为有了这些路径，就可以以各种有趣的方式显示它们。"}),"\n",(0,t.jsxs)(e.p,{children:["在这里，我们将使用 Three.js 的 SVGLoader 和 ",(0,t.jsx)(e.code,{children:"@react-three/fiber"})," 库来加载和显示一个 SVG 图像，并将其转换为 3D 形状。"]}),"\n",(0,t.jsxs)(e.p,{children:["在 ",(0,t.jsx)(e.code,{children:"SVGMesh.tsx"})," 中导入所需要的功能模块："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// SVGMesh.tsx\n\n// 这是一个将 Three.js 集成到 React 中的库。useLoader 是一个钩子，用于加载资源\nimport { useLoader } from "@react-three/fiber";\n\n// React 的一个钩子，用于性能优化，通过记住计算结果来避免不必要的重新计算\nimport { useMemo } from "react";\n\n// Three.js 的核心库，用于创建和显示 3D 图形\nimport * as T from "three";\n\n// Three.js 的一个加载器，用于加载和解析 SVG 文件\nimport { SVGLoader } from "three/examples/jsm/loaders/SVGLoader.js";\n'})}),"\n",(0,t.jsxs)(e.p,{children:["接着在 ",(0,t.jsx)(e.code,{children:"SVGMesh"})," 组件中使用 SVGLoader 加载 SVG 文件，并提取其路径："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// SVGMesh.tsx\n\n// 创建 SVGMesh 组件\nconst SVGMesh = (props) => {\n    // 使用 SVGLoader 加载指定路径的 SVG 文件，返回 svgData\n    const svgData = useLoader(SVGLoader, "/lvup_icon.svg");\n    \n    // 将 svgData.paths 转换为形状数组，并记住这些形状，避免每次渲染时都重新计算\n    const shapes = useMemo(() => {\n        return svgData.paths.map((p) => p.toShapes(true));\n    }, [svgData]);\n    \n    reture(\n        {/* ... */}\n    )\n}    \n'})}),"\n",(0,t.jsx)(e.p,{children:"然后，使用 Three.js 来渲染从 SVG 文件的路径中提取到的数据，将其转换为 3D 形状："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// SVGMesh.tsx \n \n const SVGMesh = (props) => {\n     // 加载 SVG 和提取路径数据\n    return (\n        // Three.js 的网格对象，用于包含和渲染几何体和材料\n        <mesh\n            // 将网格缩小到原始尺寸的 1%\n            scale={0.01} \n            \n            // 随机旋转网格的 y 轴，使每个实例的旋转角度不同\n            rotation={[Math.PI, Math.random() * Math.PI, 0]}\n            \n            // 随机设置网格的位置\n            position={[Math.random() * 2 - 1.7, 2.5, Math.random() * 2 - 1]}\n            \n            // 将接收到的 props 传递给 mesh，允许自定义属性\n            {...props}\n        >\n            // 遍历形状数组，为每个形状创建一个 mesh \n            {shapes.map((s, i) => (\n                // key={i}：为每个 mesh 组件设置唯一的键\n                // position={[0, 0, 0]}：将子网格的位置设置为原点\n                <mesh key={i} position={[0, 0, 0]} {...props}>\n                    // 用于将 2D 形状转换为 3D 几何体 \n                    <extrudeGeometry\n                        // 配置参数，定义挤出的深度和其他属性\n                        args={[\n                            s,\n                            {\n                                depth: 0.1,\n                                bevelEnabled: false,\n                                steps: 30,\n                            },\n                        ]}\n                    />\n                    // 使用 Phong 材质渲染网格，设置材质颜色和双面渲染\n                    <meshPhongMaterial\n                        attach="material"\n                        color={svgData.paths[i].color}\n                        side={T.DoubleSide}\n                    />\n                </mesh>\n            ))}\n        </mesh>\n    );\n};\n\n// 导出组件\nexport default SVGMesh;\n'})}),"\n",(0,t.jsx)(e.p,{children:"所有代码如下所示："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// SVGMesh.tsx\nimport { useLoader } from "@react-three/fiber";\nimport { useMemo } from "react";\nimport * as T from "three";\nimport { SVGLoader } from "three/examples/jsm/loaders/SVGLoader.js";\n\nconst SVGMesh = (props) => {\n    const svgData = useLoader(SVGLoader, "/lvup_icon.svg");\n    const shapes = useMemo(() => {\n        return svgData.paths.map((p) => p.toShapes(true));\n    }, [svgData]);\n\n    return (\n        <mesh\n            scale={0.01}\n            rotation={[Math.PI, Math.random() * Math.PI, 0]}\n            position={[Math.random() * 2 - 1.7, 2.5, Math.random() * 2 - 1]}\n            {...props}\n        >\n            {shapes.map((s, i) => (\n                <mesh key={i} position={[0, 0, 0]} {...props}>\n                    <extrudeGeometry\n                        args={[\n                            s,\n                            {\n                                depth: 0.1,\n                                bevelEnabled: false,\n                                steps: 30,\n                            },\n                        ]}\n                    />\n                    <meshPhongMaterial\n                        attach="material"\n                        color={svgData.paths[i].color}\n                        side={T.DoubleSide}\n                    />\n                </mesh>\n            ))}\n        </mesh>\n    );\n};\n\nexport default SVGMesh;\n'})}),"\n",(0,t.jsxs)(e.p,{children:["现在，可以将上面创建的 ",(0,t.jsx)(e.code,{children:"SVGMesh"})," 组件添加到我们的场景中。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// Scene.tsx\n// React 的 Suspense 组件，用于处理异步加载的组件\nimport { Suspense } from "react";\nimport { Canvas } from "@react-three/fiber";\nimport { OrbitControls, PerspectiveCamera } from "@react-three/drei";\n// 导入 SVGMesh 组件\nimport SVGMesh from "./SVGMesh";\n\nexport default function Scene() {\n    return (\n        <Canvas>\n            <PerspectiveCamera makeDefault position={[0, 0, 10]} />\n            <OrbitControls />\n            <ambientLight intensity={Math.PI / 2} />\n            <spotLight\n                position={[10, 10, 10]}\n                angle={0.15}\n                penumbra={1}\n                decay={0}\n                intensity={Math.PI}\n            />\n            <pointLight position={[-10, -10, -10]} decay={0} intensity={Math.PI} />\n            <directionalLight position={[10, 10, 10]} />\n            \n            // 使用 Suspense 组件来异步加载 SVGMesh 组件。在 SVGMesh 加载完成之前不会渲染任何东西 \n            <Suspense fallback={null}>\n                // 自定义组件，用于加载和渲染 SVG 图形\n                <SVGMesh />\n            </Suspense>\n        </Canvas>\n    );\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["我们使用 React 的 ",(0,t.jsx)(e.code,{children:"Suspense"})," 组件，用于处理异步加载的组件。即使用 ",(0,t.jsx)(e.code,{children:"Suspense"})," 组件来异步加载 ",(0,t.jsx)(e.code,{children:"SVGMesh"})," 组件。在 ",(0,t.jsx)(e.code,{children:"SVGMesh"})," 加载完成之前不会渲染任何东西。"]}),"\n",(0,t.jsx)(e.p,{children:"这个时候，你在浏览器中能看到像下面这样的一个效果："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"在这个示例中，每个形状都会被随机分配一个位置和旋转，使得 SVG 被分解到 3D 空间中。"}),"\n",(0,t.jsx)(e.p,{children:"我们再来看一个更复杂一点的效果："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["特别声明，这个效果是复制 ",(0,t.jsx)(e.a,{href:"https://x.com/0xca0a",target:"_blank",rel:"noopener noreferrer",children:"@Paul Henschel 写的一个效果"}),"：",(0,t.jsx)(e.a,{href:"https://codrops-svg.surge.sh/",target:"_blank",rel:"noopener noreferrer",children:"https://codrops-svg.surge.sh/"})]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["这个效果的原理和上面的“老虎”示例是一样的。通过 React 和 ",(0,t.jsx)(e.code,{children:"react-three-fiber"})," 库来获取 SVG 文件的 ",(0,t.jsx)(e.code,{children:"<path>"})," 数据，并将其重新分解，放入 Three.js 中，使其具有一个 3D 场景。"]}),"\n",(0,t.jsx)(e.p,{children:"关于项目初始化依旧是基于 Vite 和 React 的，这里就不做重复性的阐述了。我们直接进入创建这个效果所需要的代码中。"}),"\n",(0,t.jsxs)(e.p,{children:["首先在项目中创建一个名为 ",(0,t.jsx)(e.code,{children:"helpers.jsx"})," 文件，它的主要任务是使用 SVGLoader 将 SVG 中引入到 WebGL 中，并将它们转换为可以在 Three.js 场景中的形状数组，以便在 Three.js 中进行渲染："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// helpers.jsx\n\n// 导入 Three.js 库\nimport * as THREE from "three";\n\n// 导入 SVGLoader 类\nimport { SVGLoader } from "three/examples/jsm/loaders/SVGLoader.js";\n\n// 存储了 Three.js 中的双面材质常量，用于指定渲染的材质是双面的\nconst doubleSide = THREE.DoubleSide;\n\n// 存储了一组颜色值，用于给每个加载的 SVG 设置不同的颜色\nconst colors = [\n    "#21242d",\n    "#ea5158",\n    "#0d4663",\n    "#ffbcb7",\n    "#2d4a3e",\n    "#8bd8d2",\n];\n\n// 存储了需要加载的 SVG 文件的路径，通过 map() 方法生成\nconst svgUrls = ["night", "city", "morning", "tubes", "woods", "beach"].map((name) => `/${name}.svg`);\n\n// 定义异步函数 loadSvgs\nconst loadSvgs = async () => {\n    // 创建 SVGLoader 实例\n    const loader = new SVGLoader();\n  \n    // 创建用于存储加载的 SVG 数据的 Promise 数组\n    const svgPromises = svgUrls.map(\n        (url) =>\n            new Promise((resolve, reject) => {\n                // 使用 SVGLoader 加载 SVG 文件\n                loader.load(url, (data) => {\n                    try {\n                        // 将 SVG 数据处理为形状数组，并使用 resolve 返回\n                        const shapesArray = data.paths.flatMap((group, index) =>\n                            group\n                                .toShapes(true)\n                                .map((shape) => ({ shape, color: group.color, index }))\n                        );\n                        resolve(shapesArray);\n                    } catch (error) {\n                        // 处理加载或处理过程中的错误，并使用 reject 或 throw 抛出\n                        reject(error);\n                    }\n                });\n            })\n    );\n\n    try {\n        // 使用 Promise.all() 并行加载所有 SVG 文件\n        const svgs = await Promise.all(svgPromises);\n        return svgs;\n    } catch (error) {\n        // 处理加载过程中的错误\n        console.error("Error loading SVGs:", error);\n        throw error;\n    }\n};\n\n// 将 loadSvgs 函数、颜色数组和双面材质常量导出，以便其他模块可以使用它们\nexport { loadSvgs, colors, doubleSide };\n'})}),"\n",(0,t.jsxs)(e.p,{children:["接下来，我们定义一个 ",(0,t.jsx)(e.code,{children:"Shape"})," 组件，它的作用是将传递给它的形状数据渲染成一个带有动画效果的 Three.js 元素，并且可以控制其旋转、位置、颜色和透明度等属性。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// Shape.jsx\n\n// animated 是从 @react-spring/three 库中导入的一个高阶组件，用于创建动画效果的 Three.js 元素\nimport { animated } from "@react-spring/three";\n\n// 从 ./helpers 模块中导入的双面材质常量，用于指定渲染的材质是双面的。\nimport { doubleSide } from "./helpers";\n\n// 定义 Shape 组件\n// shape: 形状\n// rotation: 旋转\n// position: 位置\n// color: 颜色\n// opacity: 不透明度\n// index: 索引\nconst Shape = ({ shape, rotation, position, color, opacity, index }) => {\n    // 返回了一个带有动画效果的 Three.js <mesh> 元素，用于渲染形状  \n    return (\n        // 创建一个动画的网格模型，其中 rotation 和 position 属性被传递给动画组件，以便可以通过动画进行更改\n        <animated.mesh\n            rotation={rotation}\n            position={position.to((x, y, z) => [x, y, z + -index * 50])}\n        >\n            // 定义材质\n            <animated.meshPhongMaterial\n                attach="material"  // 将材质附加到 Three.js 中的网格元素上，以便在渲染时使用该材质来呈现网格\n                color={color}      // 指定材质的颜色\n                opacity={opacity}  // 指定材质的透明度\n                side={doubleSide}  // 指定材质为双面\n                depthWrite={false} // 材质为深度写入\n                transparent        // 材质是否透明\n            />\n            // 用于定义几何形状\n            <animated.extrudeGeometry \n                attach="geometry" \n                args={[shape]} \n            />\n        </animated.mesh>\n    );\n};\n\nexport default Shape;\n'})}),"\n",(0,t.jsxs)(e.p,{children:["然后，我们需要创建 ",(0,t.jsx)(e.code,{children:"Scene"})," 组件负责渲染整个场景，其中涉及到了使用 ",(0,t.jsx)(e.a,{href:"https://www.react-spring.dev/",target:"_blank",rel:"noopener noreferrer",children:"React Spring"})," 库的动画组件来实现形状的过渡效果。通过 ",(0,t.jsx)(e.code,{children:"useEffect"})," 钩子来实现页面切换和加载 SVG 数据，通过 ",(0,t.jsx)(e.code,{children:"useSpring"})," 创建背景颜色的动画，通过 ",(0,t.jsx)(e.code,{children:"useTransition"})," 创建形状的过渡动画。最后通过 ",(0,t.jsx)(e.code,{children:"transitions"})," 函数将过渡动画应用到形状组件中进行渲染。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// Scene.jsx\nimport { useState, useEffect } from "react";\n\n// 引入 React Spring 库中的动画组件\nimport { useTransition, useSpring, animated } from "@react-spring/three";\n\n// 从 helpers 文件中导入加载 SVG 和颜色数据的函数\nimport { loadSvgs, colors } from "./helpers";\n\n// 导入自定义的 Shape 组件，用于渲染形状\nimport Shape from \'./Shape\'\n\nconst Scene = () => {\n    // 定义状态：当前页数和形状数据\n    const [page, setPage] = useState(0);\n    const [shapes, setShapes] = useState([]);\n\n    // 每隔 3 秒切换页面\n    useEffect(() => {\n        const interval = setInterval(() => {\n            setPage((i) => (i + 1) % 6); // 假设有 6 页\n        }, 3000);\n        return () => clearInterval(interval);\n    }, []);\n\n    // 加载 SVG 并设置形状数据\n    useEffect(() => {\n        const fetchSvgs = async () => {\n            try {\n                const allSvgs = await loadSvgs(); // 调用 loadSvgs 函数加载 SVG 数据\n                setShapes(allSvgs[page]);         // 根据当前页面设置形状数据\n            } catch (error) {\n                console.error("Error loading shapes:", error);\n            }\n        };\n        fetchSvgs();\n    }, [page]);\n\n    // 创建 Spring 动画，控制背景颜色的变化\n    const { color } = useSpring({ color: colors[page] });\n\n    // 使用过渡动画来处理形状的进入和离开效果\n    const transitions = useTransition(shapes, {\n        // 初始状态\n        from: { \n            rotation: [-0.2, 0.9, 0], \n            position: [0, 50, -200], opacity: 0 \n        }, \n        // 进入状态\n        enter: { \n            rotation: [0, 0, 0], \n            position: [0, 0, 0], opacity: 1 \n        },\n        // 离开状态\n        leave: {\n            rotation: [0.2, -0.9, 0],\n            position: [0, -400, 200],\n            opacity: 0,\n        },\n        // 动画配置\n        config: { \n            mass: 30, \n            tension: 800, \n            friction: 190, \n            precision: 0.0001 \n        },\n        ...{\n            order: ["leave", "enter", "update"], // 动画执行顺序\n            trail: 15,                           // 动画延迟\n            lazy: true,                          // 延迟加载\n            unique: true,                        // 唯一标识\n            reset: true,                         // 重置 \n        },\n    });\n\n    // 渲染场景组件\n    return (\n        <>\n            <mesh scale={[20000, 20000, 1]} rotation={[0, (-20 * Math.PI) / 180, 0]}>\n                {/* 定义平面几何 */}\n                <planeGeometry attach="geometry" args={[1, 1]} />\n                {/* 应用动画材质 */}\n                <animated.meshPhongMaterial\n                    attach="material"\n                    color={color}\n                    depthTest={false}\n                />\n            </mesh>\n            {/* 形状组 */}\n            <group\n                position={[1600, -700, page]}\n                rotation={[0, (180 * Math.PI) / 180, 0]}\n            >\n                {/* 形状组 */}\n                {transitions((...item) => {\n                    const props = {\n                        ...item[0], // 过渡动画属性\n                        ...item[1], // 动画配置\n                    };\n                  return <Shape {...props} />; // 返回 Shape 组件，并传入属性\n                })}\n            </group>\n        </>\n    );\n};\n\nexport default Scene;\n'})}),"\n",(0,t.jsxs)(e.p,{children:["最后，我们在 ",(0,t.jsx)(e.code,{children:"App"})," 组件（",(0,t.jsx)(e.code,{children:"App.jsx"}),"）中，导入已经创建好的场景（",(0,t.jsx)(e.code,{children:"Scene"}),"），并将其放置在 ",(0,t.jsx)(e.code,{children:"<Canvas>"})," 组件中。",(0,t.jsx)(e.code,{children:"<Canvas>"})," 组件主要用于创建 WebGL 渲染环境，并在其中渲染已定义好的场景（",(0,t.jsx)(e.code,{children:"Scene"}),"）。在 ",(0,t.jsx)(e.code,{children:"<Canvas>"})," 组件中，设置了相机的参数，包括视场角度、位置、旋转角度等。除了渲染 3D 场景外，还添加了环境和聚光灯以提供光照效果。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// App.jsx\nimport "./App.css";\n\n// 导入 React Three Fiber 库中的 Canvas 组件，用于创建 WebGL 渲染环境\nimport { Canvas } from "@react-three/fiber";\n\n// 导入自定义的 Scene 组件，用于渲染场景\nimport Scene from "./Scene";\n\nconst App = () => {\n    return (\n        <div className="app">\n            {/*  创建 WebGL 渲染环境 */}\n            <Canvas\n                // 设置为 true，使渲染循环受到 React 更新的影响 \n                invalidateframeloop="true"  \n                // 相机参数设置\n                camera={{\n                    // 视场角度\n                    fov: 90,\n                    // 相机位置\n                    position: [0, 0, 1800],\n                    // 相机旋转角度\n                    rotation: [0, (-20 * Math.PI) / 180, (180 * Math.PI) / 180],\n                    // 近截面\n                    near: 0.1,\n                    // 远截面\n                    far: 20000,\n                }}\n            >\n                {/* 添加环境光 */}\n                <ambientLight intensity={0.5} />\n                {/* 添加聚光灯 */}\n                <spotLight intensity={0.5} position={[300, 300, 4000]} />\n                {/* 渲染 Scene 组件 */}\n                <Scene />\n            </Canvas>\n            <span className="header">REACT THREE FIBER</span>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,t.jsx)(e.p,{children:"上面就是实现整个效果的全部代码。感兴趣的同学可以挑战一下。"}),"\n",(0,t.jsxs)(e.h2,{id:"svg-与-webgl创作无限可能",children:["SVG 与 WebGL：创作无限可能",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#svg-与-webgl创作无限可能",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"前文展示了如何通过 SVG 构建工具，在 Vite 构建的 React 应用中，将 SVG 引入 WebGL，从而创建更加高级和复杂的图形效果。接下来，我们将一步步探讨如何在不依赖任何构建工具的情况下，将 SVG 引入 WebGL，并为其增添动画效果。"}),"\n",(0,t.jsx)(e.p,{children:"SVG 的一个显著特性是其图形由数学函数构成，可以通过 JavaScript 获取和解析这些图形数据，从而进行动画处理，使图形更加生动。这意味着，在许多场景中，我们不仅可以将 SVG 用于视觉展示，还可以将其作为数据源来利用。接下来，我将通过一个实际案例来详细解释这一点。"}),"\n",(0,t.jsxs)(e.p,{children:["通过学习小册子中的《",(0,t.jsx)(e.a,{href:"https://juejin.cn/book/7341630791099383835/section/7349188496181887017#heading-5",target:"_blank",rel:"noopener noreferrer",children:"初级篇：SVG 描边和填充"}),"》一节课，我们了解到可以使用 CSS 控制 ",(0,t.jsx)(e.code,{children:"<path>"})," 元素的 ",(0,t.jsx)(e.code,{children:"stroke-dasharray"})," 属性，为 SVG 路径添加线条动画。例如："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-XML",children:'<svg viewBox="-2 -2 524 524" class="codepen">\n    <path d="m502.3 159.7-234-156c-8-4.9-16.5-5-24.6 0l-234 156c-6 4-9.7 11.1-9.7 18.3v156c0 7.1 3.7 14.3 9.7 18.3l234 156c8 4.9 16.5 5 24.6 0l234-156c6-4 9.7-11.1 9.7-18.3V178c0-7.1-3.7-14.3-9.7-18.3zM278 63.1 450.3 178l-76.9 51.4-95.4-63.7V63.1zm-44 0v102.6l-95.4 63.7L61.7 178 234 63.1zm-190 156L99.1 256 44 292.8v-73.7zm190 229.7L61.7 334l76.9-51.4 95.4 63.7v102.6zm22-140.9-77.7-52 77.7-52 77.7 52-77.7 52zm22 140.9V346.3l95.4-63.7 76.9 51.4L278 448.8zm190-156-55.1-36.9 55.1-36.8v73.7z" />\n</svg>\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-CSS",children:"@layer demo {\n    .codepen {\n        display: block;\n        width: 80vh;\n        aspect-ratio: 1;\n        fill: none;\n        stroke-width: 4;\n        stroke: #fff;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        \n        path {\n            stroke-dashoffset: 40 20;\n            animation: strokedasharray 2s ease-in-out infinite alternate;\n        }\n    }\n\n    @keyframes strokedasharray {\n        from {\n            stroke-dasharray: 0 4429;\n        }\n        to {\n            stroke-dasharray: 4429 4429;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/JjqKVav",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/JjqKVav"})]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["你可能会好奇，为什么 ",(0,t.jsx)(e.code,{children:"stroke-dasharray"})," 的值是 ",(0,t.jsx)(e.code,{children:"4429"})," 呢？其实很简单，这个数值表示示例中 ",(0,t.jsx)(e.code,{children:"<path>"})," 元素总长度的计算值。这个值我们可以通过 ",(0,t.jsx)(e.code,{children:"SVGPathElement.getTotalLength()"})," 来获取，与此同时，它还有一个 ",(0,t.jsx)(e.code,{children:"SVGGeometryElement.getPointAtLength()"})," 方法。这是两个非常有用的 SVG DOM API，它允许 Web 开发者操作和计算 SVG 路径（",(0,t.jsx)(e.code,{children:"<path>"}),"）的几何特性："]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"SVGPathElement.getTotalLength()"})," 方法返回一个浮点数，表示路径的总长度（以用户单位为单位）；"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"SVGGeometryElement.getPointAtLength()"})," 方法返回一个 ",(0,t.jsx)(e.code,{children:"DOMPoint"})," 对象，表示路径上距离起点为指定长度的点的坐标。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["注意， ",(0,t.jsx)(e.code,{children:"SVGGeometryElement"})," 变量指的是 SVG 的几何图形元素，如 ",(0,t.jsx)(e.code,{children:"path"}),"、",(0,t.jsx)(e.code,{children:"circle"}),"、",(0,t.jsx)(e.code,{children:"ellipse"}),"、",(0,t.jsx)(e.code,{children:"line"}),"、",(0,t.jsx)(e.code,{children:"polygon"})," 和 ",(0,t.jsx)(e.code,{children:"polyline"})," 元素，因此不包括 ",(0,t.jsx)(e.code,{children:"image"}),"、",(0,t.jsx)(e.code,{children:"filter"}),"、",(0,t.jsx)(e.code,{children:"clip-path"})," 等元素。"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"假设我们有一个简单的 SVG 路径："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-XML",children:'<svg width="100" height="100">\n    <path id="myPath" d="M10 10 H 90 V 90 H 10 Z" stroke="black" fill="transparent"/>\n</svg>\n'})}),"\n",(0,t.jsx)(e.p,{children:"我们可以用 JavaScript 获取该路径的总长度："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"const pathElement = document.getElementById('myPath');\nconst pathLength = pathElement.getTotalLength();\nconsole.log(`Path length: ${pathLength}`);\n"})}),"\n",(0,t.jsx)(e.p,{children:"使用之前的示例路径，我们可以获取路径上某一特定长度的点的坐标："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"const pathElement = document.getElementById('myPath');\nconst point = pathElement.getPointAtLength(50);\nconsole.log(`Point at length 50: (${point.x}, ${point.y})`);\n"})}),"\n",(0,t.jsxs)(e.p,{children:["结合使用 ",(0,t.jsx)(e.code,{children:"SVGPathElement.getTotalLength()"})," 和 ",(0,t.jsx)(e.code,{children:"SVGGeometryElement.getPointAtLength()"})," 方法，为 Web 开发者提供了强大的工具，使他们能够在 SVG 动画和交互设计中进行富有创造性的工作："]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"路径动画"}),"：通过获取路径的总长度并计算路径上各点的位置，开发者可以精确控制动画对象的运动轨迹。这使得创建沿着路径移动的动画，如图标或文字沿着预定路径运动，变得非常容易，从而实现复杂的视觉效果。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"交互式绘图应用"}),"：这些方法允许开发者获取路径的总长度和特定位置的点，从而支持用户通过拖拽或点击来编辑路径。在交互式绘图工具中，这非常有用。用户可以在路径上绘制或选择特定点进行编辑，例如在地图应用中沿着路线绘制或移动标记点。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"数据可视化"}),"：开发者可以利用路径的总长度和路径上特定点的数据，在路径上动态显示数据点或信息。这在数据可视化应用中尤为重要，可以用来展示趋势或分布图，例如股票走势或路径图。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"动态绘图和涂鸦应用"}),"：通过获取路径的总长度和路径上特定位置的点，开发者可以允许用户实时绘制和编辑图形。用户可以在路径上动态绘图或添加涂鸦效果，适用于创意应用和艺术创作。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"总之，这些方法为 SVG 提供了强大的几何计算能力，使得在 Web 上实现复杂的图形效果变得更加容易和高效。"}),"\n",(0,t.jsxs)(e.p,{children:["接下来，我们通过实际的案例向大家展示这两个函数的强大之处。我们使用 ",(0,t.jsx)(e.a,{href:"https://gsap.com/",target:"_blank",rel:"noopener noreferrer",children:"GreenSock 库"}),"为 SVG 图形添加随机的粒子动画效果。"]}),"\n",(0,t.jsx)(e.p,{children:"以 Codpen 的 Logo 图标为例，该图标对应的 SVG 代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-XML",children:'<svg viewBox="-2 -2 524 524" class="codepen">\n    <path d="m502.3 159.7-234-156c-8-4.9-16.5-5-24.6 0l-234 156c-6 4-9.7 11.1-9.7 18.3v156c0 7.1 3.7 14.3 9.7 18.3l234 156c8 4.9 16.5 5 24.6 0l234-156c6-4 9.7-11.1 9.7-18.3V178c0-7.1-3.7-14.3-9.7-18.3zM278 63.1 450.3 178l-76.9 51.4-95.4-63.7V63.1zm-44 0v102.6l-95.4 63.7L61.7 178 234 63.1zm-190 156L99.1 256 44 292.8v-73.7zm190 229.7L61.7 334l76.9-51.4 95.4 63.7v102.6zm22-140.9-77.7-52 77.7-52 77.7 52-77.7 52zm22 140.9V346.3l95.4-63.7 76.9 51.4L278 448.8zm190-156-55.1-36.9 55.1-36.8v73.7z" />\n    \x3c!-- 用来放置圆形粒子的容器 --\x3e\n    <g id="group"></g>\n</svg>\n'})}),"\n",(0,t.jsxs)(e.p,{children:["使用 JavaScript 和 GASP 来对上面示例中的 ",(0,t.jsx)(e.code,{children:"<path>"})," 做一些有趣的操作："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// 获取类名为 "codepen" 的元素下的 path 元素\nconst path = document.querySelector(".codepen path");\n\n// 获取 id 为 "group" 的元素，用于容纳生成的圆形元素\nconst group = document.querySelector("#group");\n\n// 定义颜色比例尺数组\nconst colours = [\n    chroma.scale([\n        "#FF7900",\n        "#F94E5D",\n        "#CA4B8C",\n        "#835698",\n        "#445582",\n        "#2F4858"\n    ]),\n    chroma.scale([\n        "#845EC2",\n        "#D65DB1",\n        "#FF6F91",\n        "#FF9671",\n        "#FFC75F",\n        "#F9F871"\n    ]),\n    chroma.scale([\n        "#F24B8E",\n        "#F6ACC2",\n        "#FFE3F1",\n        "#59BAB7",\n        "#BA59B7",\n        "#F3596A"\n    ]),\n    chroma.scale([\n        "#1FAAFE",\n        "#00C6FF",\n        "#00DCE4",\n        "#10ECB8",\n        "#A0F68B",\n        "#F9F871"\n    ])\n];\n\n// 初始化当前使用的颜色比例尺索引\nlet currentGradient = 1;\n\n// 创建 gsap 时间轴动画：使用 gsap 库创建时间线对象，用于管理动画序列\nconst tl = gsap.timeline({\n    // 当动画反向播放完成时的回调函数\n    onReverseComplete: () => {\n        // 当动画反向播放完成后，将动画的时间比例设置为 1，以确保时间流逝正常\n        tl.timeScale(1);\n        // 立即开始播放动画\n        tl.play(0);\n    },\n    // 当动画播放完成时的回调函数\n    onComplete: () => {\n        // 当动画播放完成后，将动画的时间比例设置为 1.5，加快动画播放速度\n        tl.timeScale(1.5);\n        // 反向播放动画，即将动画倒放回到起始状态\n        tl.reverse(0);\n    }\n});\n\n// 生成动画效果的函数\nconst generatePoints = () => {\n    // 清除时间轴动画和元素容器的内容\n    tl.clear();\n    group.innerHTML = "";\n\n    // 初始化延迟值\n    let delay = 0;\n\n    // 获取路径的总长度\n    const length = path.getTotalLength();\n\n    // 循环生成圆形元素\n    for (let i = 0; i < length; i += 1) {\n        // 随机获取路径上的点的位置\n        const pointLength = Math.random() * length;\n        const point = path.getPointAtLength(pointLength);\n    \n        // 创建圆形元素\n        const circle = document.createElementNS(\n            "http://www.w3.org/2000/svg",\n            "circle"\n        );\n        // 设置圆形粒子的中心点的 x 坐标为路径上随机点的 x 坐标\n        circle.setAttribute("cx", point.x);\n    \n        // 设置圆形粒子的中心点的 y 坐标为路径上随机点的 y 坐标\n        circle.setAttribute("cy", point.y);\n    \n        // 设置圆形粒子的半径为一个随机值，范围在 1 到 4 之间\n        circle.setAttribute("r", Math.random() * 3 + 1);\n    \n        // 将创建的圆形粒子添加到指定的容器中\n        group.appendChild(circle);\n    \n        // 计算颜色值\n        const coloursX = point.x / 476.5 + (Math.random() - 0.5) * 0.2;\n    \n        // 使用 gsap 库的 to() 方法对圆形粒子进行动画处理：添加到时间轴动画中\n        tl.to(\n            circle, // 要应用动画的对象，这里是圆形粒子\n            {\n                autoRound: false, // 指定是否应该将属性值四舍五入为整数\n                fill: colours[currentGradient % colours.length](coloursX).hex(), // 设置圆形粒子的填充颜色\n                cx: point.x + (Math.random() - 0.5) * 60, // 设置圆形粒子在 x 轴上的动画终点位置\n                cy: point.y + (Math.random() - 0.5) * 60, // 设置圆形粒子在 y 轴上的动画终点位置\n                duration: "random(0.5, 2)", // 设置动画的持续时间范围为随机值，范围在 0.5 到 2 之间\n                delay: (delay + pointLength) * 0.002, // 设置动画延迟的时间，根据路径长度进行计算\n                ease: "power2.out" // 设置动画的缓动函数，这里使用 power2.out\n            },\n            0 // 设置动画的起始时间，这里是立即开始\n        );\n    }\n    // 更新延迟值\n    delay += length;\n\n    // 播放时间轴动画\n    tl.reversed(false).play(0);\n\n    // 更新颜色比例尺索引\n    currentGradient++;\n};\n\n// 调用生成动画效果的函数\ngeneratePoints();\n'})}),"\n",(0,t.jsx)(e.p,{children:"上面的代码主要完成了以下几件事情："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"获取 SVG 路径信息"}),"：通过 ",(0,t.jsx)(e.code,{children:'document.querySelector(".codepen path")'})," 获取了 ",(0,t.jsx)(e.code,{children:".codepen"})," 的路径元素，这些路径元素定义了要绘制的形状。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"创建圆形粒子"}),"：通过 ",(0,t.jsx)(e.code,{children:"path.getPointAtLength()"})," 方法获取路径上的随机点，并将其作为圆形粒子的位置。然后创建圆形粒子元素，并将其添加到指定的容器中。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"应用动画效果"}),"：通过 GSAP 库创建了时间轴动画 ",(0,t.jsx)(e.code,{children:"tl"}),"，在动画中为每个圆形粒子设置了位置、填充颜色等属性，并且设置了延迟时间，以实现粒子的动态效果。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"循环播放动画"}),"：通过 ",(0,t.jsx)(e.code,{children:"tl.reversed(false).play(0)"})," 循环播放动画，不断生成圆形粒子，从而实现动态的视觉效果。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"你将在浏览器看到像下图这样的效果："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/NWVrVPR",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/NWVrVPR"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"在上面的示例基础上，我们只需要稍微调整，就可以将粒子动画效果用于 Web UI 上，例如下面这个按钮效果："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-HTML",children:'<button class="button">\n    <span>Click Me!</span>\n    <svg width="100%" height="100%"  fill="none" >\n        <rect x="0" y="0" width="100%" height="100%" rx="10" stroke="black"/>\n        <g id="group"></g>\n    </svg>\n</button>\n'})}),"\n",(0,t.jsx)(e.p,{children:"使用 CSS 给按钮设置基本样式："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-CSS",children:"@layer demo {\n    .button {\n        position: relative;\n        display: grid;\n        min-width: 240px;\n        height: 66px;\n        cursor: pointer;\n        text-decoration: none;\n        white-space: nowrap;\n        background-image: linear-gradient(to right, #f05a28, #ec008c, #f05a28);\n        background-size: 300% 100%;\n        transition: all 0.5s ease-in-out;\n        border: none;\n        border-radius: 10px;\n        font-size: 18px;\n        font-weight: 700;\n        \n        &:hover {\n            background-position: -50% 0;\n        }\n    \n        svg {\n            display: block;\n            width: 100%;\n            height: 100%;\n            overflow: visible; /* 这个很重要 */\n            position: absolute;\n            inset: 0;\n        }\n    \n        rect {\n            rx: 10;\n            stroke: transparent;\n            stroke-width: 1;\n        }\n    \n        > * {\n            grid-area: 1 / 1 / -1 / -1;\n        }\n    \n        span {\n            display: block;\n            place-self: center;\n        }\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["通过 JavaScript 获取 SVG 的 ",(0,t.jsx)(e.code,{children:"<rect>"})," 的数据，并转换为相关的粒子，然后使用 GSAP 给粒子设置动画效果："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'const buttonHandler = document.querySelector(".button");\n// 选择 SVG 中的矩形元素，作为路径动画的参考\nconst rectPath = document.querySelector(".button rect");\n// 选择 SVG 中的特定元素，用于添加创建的粒子\nconst particleContainer = document.querySelector("#group");\n\n// 标志变量，用于跟踪动画状态\nlet isAnimating = false;\n\nconst animateParticles = (aniPath) => {\n    if (!isAnimating) {\n        isAnimating = true;\n        // 创建一个对象，以便 gsap 可以对其属性进行动画\n        const val = { distance: 0 };\n        // 创建一个 tween 动画，控制粒子沿着路径运动\n        gsap.to(val, {\n            // 从 distance 0 到总路径长度的动画\n            distance: aniPath.getTotalLength(),\n            // 动画持续时间为 5 秒\n            duration: 5,\n            // 每帧动画更新时调用的函数\n            onUpdate: () => {\n                // 根据新的 distance 值获取路径上的点\n                const point = aniPath.getPointAtLength(val.distance);\n                // 创建粒子\n                createParticle(point, particleContainer);\n            },\n            // 动画完成时执行的回调\n            onComplete: () => {\n                isAnimating = false; // 标志动画已经完成\n            }\n        });\n    \n        /* 控制路径描绘动画 */\n        // 设置路径的 stroke-dasharray 属性为总路径长度\n        aniPath.setAttribute("stroke-dasharray", aniPath.getTotalLength());\n        // 设置路径的 stroke-dashoffset 属性为两倍总路径长度\n        aniPath.setAttribute("stroke-dashoffset", aniPath.getTotalLength() * 2);\n        // 创建路径描绘动画\n        gsap.to(aniPath, {\n            // 从两倍总路径长度到 0 的动画\n            strokeDashoffset: aniPath.getTotalLength(),\n            // 动画持续时间为 5 秒\n            duration: 5\n        });\n    }\n};\n\n// 创建粒子的函数\nconst createParticle = (point, container) => {\n    // 定义颜色比例尺数组\n    const colours = [\n        chroma.scale([\n            "#FF7900",\n            "#F94E5D",\n            "#CA4B8C",\n            "#835698",\n            "#445582",\n            "#2F4858"\n        ]),\n        chroma.scale([\n            "#845EC2",\n            "#D65DB1",\n            "#FF6F91",\n            "#FF9671",\n            "#FFC75F",\n            "#F9F871"\n        ]),\n        chroma.scale([\n            "#F24B8E",\n            "#F6ACC2",\n            "#FFE3F1",\n            "#59BAB7",\n            "#BA59B7",\n            "#F3596A"\n        ]),\n        chroma.scale([\n            "#1FAAFE",\n            "#00C6FF",\n            "#00DCE4",\n            "#10ECB8",\n            "#A0F68B",\n            "#F9F871"\n        ])\n    ];\n    // 初始化当前使用的颜色比例尺索引\n    let currentGradient = 1;\n    // 创建一个新的圆圈元素\n    const circle = document.createElementNS(\n        "http://www.w3.org/2000/svg",\n        "circle"\n    );\n    // 将元素添加到 SVG 中\n    container.appendChild(circle);\n    // 设置圆圈的坐标\n    circle.setAttribute("cx", point.x);\n    circle.setAttribute("cy", point.y);\n    // 为每个圆圈定义随机半径\n    circle.setAttribute("r", Math.random() * 4 + 0.2);\n    // 为每个圆圈定义随机颜色\n    // 计算颜色值\n    const coloursX = point.x / 476.5 + (Math.random() - 0.5) * 0.25;\n    circle.setAttribute(\n        "fill",\n        colours[currentGradient % colours.length](coloursX).hex()\n    );\n\n    // 对圆圈进行动画\n    gsap.to(circle, {\n        // 根据当前位置随机调整 cx 值\n        cx: "+=random(-50,50)",\n        // 根据当前位置随机调整 cy 值\n        cy: "+=random(-50,50)",\n        // 逐渐消失\n        opacity: 0,\n        // 随机持续时间\n        duration: "random(.5, 1)",\n        // 不要对 cx 和 cy 值进行四舍五入\n        autoRound: false,\n        // 动画完成后执行\n        onComplete: () => {\n            // 从父元素中移除圆圈元素\n            container.removeChild(circle);\n        }\n    });\n};\n\nbuttonHandler.addEventListener("click", () => animateParticles(rectPath));\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/yLWJWjj",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/yLWJWjj"})]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["到目前为止，我们只是在路径旁边动画化了 SVG 元素，即使用 JavaScript 动态创建了很多个 ",(0,t.jsx)(e.code,{children:"<circle>"})," 元素，而且动态改变这些圆的圆心位置、大小和颜色。"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://juejin.cn/book/7341630791099383835/section/7368317759962218534#heading-9",target:"_blank",rel:"noopener noreferrer",children:"在讨论 SVG 和 Canvas 两种技术时"}),"，我曾提出，SVG 其实并不太适合动画化处理很多小的图形元素，例如上面示例中的 ",(0,t.jsx)(e.code,{children:"<circle>"})," ，这对于 Web 性能来说，可能会是致命的。这意味着，在这种情景之下，使用 Canvas 会更适合一些。"]}),"\n",(0,t.jsx)(e.p,{children:"还有，在很多时候，我们只需要 SVG 路径的数据（原始坐标），例如，我们想在 2D 画布或 WebGL 中要一个像下面这样的粒子动画："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/xxNOoRG",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/xxNOoRG"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"我们来看一个简单的示例，以“心”形为例："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-XML",children:'<svg viewBox="0 0 600 552" class="sr-only" >\n    <path id="heart" d="M300,107.77C284.68,55.67,239.76,0,162.31,0,64.83,0,0,82.08,0,171.71c0,.48,0,.95,0,1.43-.52,19.5,0,217.94,299.87,379.69v0l0,0,.05,0,0,0,0,0v0C600,391.08,600.48,192.64,600,173.14c0-.48,0-.95,0-1.43C600,82.08,535.17,0,437.69,0,360.24,0,315.32,55.67,300,107.77" fill="#ee5282"/>\n</svg>\n'})}),"\n",(0,t.jsx)(e.p,{children:"然后使用 Three.js 创建一个 3D 场景，并使用 GSAP 为场景中的粒子添加动画效果："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'// 创建一个场景，这里是Three.js的核心场景对象\nconst scene = new THREE.Scene();\n\n// 创建一个透视相机，用于场景的视图\nconst camera = new THREE.PerspectiveCamera(\n    75, // 视角广度\n    window.innerWidth / window.innerHeight, // 纵横比\n    0.1, // 近截面\n    5000 // 远截面\n);\n\n// 设置相机位置，使其稍微远离场景\ncamera.position.z = 600;\n\n// 创建一个WebGL渲染器\nconst renderer = new THREE.WebGLRenderer();\n\n// 设置渲染器的像素比率以适应不同的设备\nrenderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);\n\n// 设置渲染器的尺寸为窗口的宽和高\nrenderer.setSize(window.innerWidth, window.innerHeight);\n\n// 将渲染器的DOM元素（画布）添加到文档中\ndocument.body.appendChild(renderer.domElement);\n\n// 创建轨道控制器，使得可以用鼠标控制相机\nconst controlsWebGL = new THREE.OrbitControls(camera, renderer.domElement);\n\n/* 根据 SVG 路径元素提供的数据创建粒子 */\n\n// 选择SVG路径元素\nconst path = document.querySelector("#heart");\n\n// 获取路径的总长度\nconst length = path.getTotalLength();\n\n// 初始化存储顶点的数组\nconst vertices = [];\n\n// 遍历路径的每个点，间隔为0.2\nfor (let i = 0; i < length; i += 0.2) {\n    // 获取路径上每个点的坐标\n    const point = path.getPointAtLength(i);\n\n    // 创建一个Three.js的向量对象表示这个点\n    const vector = new THREE.Vector3(point.x, -point.y, 0);\n\n    // 随机扰动这个点的位置，使得点看起来更分散\n    vector.x += (Math.random() - 0.5) * 30;\n    vector.y += (Math.random() - 0.5) * 30;\n    vector.z += (Math.random() - 0.5) * 70;\n\n    // 将这个点添加到顶点数组中\n    vertices.push(vector);\n}\n\n// 使用顶点数组创建一个BufferGeometry对象\nconst geometry = new THREE.BufferGeometry().setFromPoints(vertices);\n\n// 创建一个粒子材质对象，设置颜色和大小\nconst material = new THREE.PointsMaterial({ color: 0xee5282, blending: THREE.AdditiveBlending, size: 3 });\n\n// 使用几何体和材质创建一个点云对象\nconst particles = new THREE.Points(geometry, material);\n\n// 调整点的位置，使其居中\nparticles.position.x -= 600 / 2;\nparticles.position.y += 552 / 2;\n\n// 将点添加到场景中\nscene.add(particles);\n\n/* 给粒子添加动画效果 */\n\n// 动画持续时间\nconst duration = 5;\n\n// 动画延迟时间\nconst delay = 2;\n\n// 遍历每个粒子\nfor (let i = 0; i < particles.geometry.attributes.position.count; i++) {\n    // 获取粒子的初始位置\n    const startPosition = new THREE.Vector3().copy(particles.geometry.attributes.position.array.slice(i * 3, i * 3 + 3));\n\n    // 获取粒子的结束位置\n    const endPosition = new THREE.Vector3().copy(vertices[i]);\n\n    // 使用GSAP创建从初始位置到结束位置的动画\n    gsap.fromTo(\n        startPosition, \n        { \n            x: startPosition.x, \n            y: startPosition.y, \n            z: startPosition.z }, \n        {\n            x: endPosition.x,\n            y: endPosition.y,\n            z: endPosition.z,\n            duration: duration,\n            delay: delay * i / particles.geometry.attributes.position.count,\n            onUpdate: function () {\n                // 在每一帧更新时，更新粒子的实际位置\n                particles.geometry.attributes.position.setXYZ(i, startPosition.x, startPosition.y, startPosition.z);\n                particles.geometry.attributes.position.needsUpdate = true;\n            },\n            onComplete: function () {\n                // 动画完成后，反向播放回到初始位置的动画\n                gsap.to(startPosition, { x: startPosition.x, y: startPosition.y, z: startPosition.z, duration: duration, delay: duration, onUpdate: function () {\n                    particles.geometry.attributes.position.setXYZ(i, startPosition.x, startPosition.y, startPosition.z);\n                    particles.geometry.attributes.position.needsUpdate = true;\n                } \n            });\n        }\n    });\n}\n\n// 为场景添加旋转动画，使整个场景旋转\ngsap.fromTo(scene.rotation, { y: -0.3 }, {\n    y: 0.3,\n    repeat: -1, // 无限重复\n    yoyo: true, // 在每次重复时反向播放\n    ease: \'power2.inOut\', // 缓动函数\n    duration: 3 // 持续时间\n});\n\n/* 渲染效果 */\n\n// 渲染函数\nfunction render() {\n    // 请求下一帧\n    requestAnimationFrame(render);\n\n    // 渲染场景\n    renderer.render(scene, camera);\n}\n\n// 当窗口大小改变时调整相机和渲染器的尺寸\nfunction onWindowResize() {\n    // 更新相机的纵横比\n    camera.aspect = window.innerWidth / window.innerHeight;\n\n    // 更新相机的投影矩阵\n    camera.updateProjectionMatrix();\n\n    // 更新渲染器的尺寸\n    renderer.setSize(window.innerWidth, window.innerHeight);\n}\n\n// 监听窗口大小改变事件\nwindow.addEventListener("resize", onWindowResize, false);\n\n// 开始渲染\nrequestAnimationFrame(render);\n'})}),"\n",(0,t.jsx)(e.p,{children:"整个效果如下："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/oNRLrpB",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/oNRLrpB"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"上面这个示例展示了如何从一个 SVG 路径创建粒子动画的过程。以下是关键步骤的解释："}),"\n",(0,t.jsxs)(e.h3,{id:"step01获取路径及其总长度",children:["Step01：",(0,t.jsx)(e.strong,{children:"获取路径及其总长度"}),(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#step01获取路径及其总长度",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["首先，通过 JavaScript API （例如 ",(0,t.jsx)(e.code,{children:"document.querySelector"}),"）从 HTML 文档中选择你要使用的 SVG 路径元素；接着使用 SVG DOM API 的 ",(0,t.jsx)(e.code,{children:"path.getTotalLength()"})," 方法获取路径的总长度，这个长度表示路径从起点到终点的距离总和。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'const path = document.querySelector("#heart");\nconst length = path.getTotalLength();\n'})}),"\n",(0,t.jsxs)(e.h3,{id:"step02沿着路径循环直到达到其总长度",children:["Step02：",(0,t.jsx)(e.strong,{children:"沿着路径循环直到达到其总长度"}),(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#step02沿着路径循环直到达到其总长度",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["接下来，使用一个 ",(0,t.jsx)(e.code,{children:"for"})," 循环，从路径的起点到终点，按固定间隔遍历路径上的每个点。每次迭代的间隔可以根据需要调整。在这段代码中，间隔设为 ",(0,t.jsx)(e.code,{children:"0.2"}),"。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"for (let i = 0; i < length; i += 0.2) {\n    // 在每个迭代中执行代码\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"step03获取路径上每个点的坐标",children:["Step03：",(0,t.jsx)(e.strong,{children:"获取路径上每个点的坐标"}),(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#step03获取路径上每个点的坐标",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["在每次迭代中，使用 ",(0,t.jsx)(e.code,{children:"path.getPointAtLength(i)"})," 方法获取路径上距离起点 ",(0,t.jsx)(e.code,{children:"i"})," 距离处的点的坐标。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"const point = path.getPointAtLength(i);\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"step04在每次迭代中创建一个在该点坐标处的-vector3-对象",children:["Step04：",(0,t.jsx)(e.strong,{children:"在每次迭代中，创建一个在该点坐标处的 Vector3 对象"}),(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#step04在每次迭代中创建一个在该点坐标处的-vector3-对象",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["使用 Three.js 的 ",(0,t.jsx)(e.code,{children:"THREE.Vector3"})," 类创建一个向量对象，表示该点的坐标。注意需要将 SVG 坐标转换为 Three.js 坐标系（例如，",(0,t.jsx)(e.code,{children:"Y"})," 轴翻转）。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"const vector = new THREE.Vector3(point.x, -point.y, 0);\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"step05将向量推入顶点数组",children:["Step05：",(0,t.jsx)(e.strong,{children:"将向量推入顶点数组"}),(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#step05将向量推入顶点数组",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"将创建的向量添加到顶点数组中，以便稍后用于创建几何体。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"vertices.push(vector);\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"step06从顶点数组创建几何体",children:["Step06：",(0,t.jsx)(e.strong,{children:"从顶点数组创建几何体"}),(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#step06从顶点数组创建几何体",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["使用顶点数组创建一个 Three.js 的 ",(0,t.jsx)(e.code,{children:"BufferGeometry"})," 对象。这可以通过 ",(0,t.jsx)(e.code,{children:"new THREE.BufferGeometry().setFromPoints(vertices)"})," 方法完成，其中 ",(0,t.jsx)(e.code,{children:"vertices"})," 是前面生成的顶点数组。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"const geometry = new THREE.BufferGeometry().setFromPoints(vertices);\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"step07创建一个点云对象并将其添加到场景中",children:["Step07：",(0,t.jsx)(e.strong,{children:"创建一个点云对象并将其添加到场景中"}),(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#step07创建一个点云对象并将其添加到场景中",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["使用创建的几何体和一个粒子材质对象创建一个",(0,t.jsx)(e.code,{children:"THREE.Points"}),"对象（点云对象）。粒子材质设置了粒子的颜色和大小。然后，将点云对象添加到 Three.js 场景中，以便它能够被渲染。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"const material = new THREE.PointsMaterial({ color: 0xee5282, blending: THREE.AdditiveBlending, size: 3 });\nconst particles = new THREE.Points(geometry, material);\nscene.add(particles);\n"})}),"\n",(0,t.jsx)(e.p,{children:"通过上述步骤，你将 SVG 路径转换为一个三维空间中的粒子效果。这个时候，整个效果具备 3D 场景的效果，具有摄像机、不同类型灯光源等。"}),"\n",(0,t.jsxs)(e.h3,{id:"step08使用-gsap-给粒子添加动画效果",children:["Step08：使用 GSAP 给粒子添加动画效果",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#step08使用-gsap-给粒子添加动画效果",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"如果希望给粒子添加动画效果，还需要做一些额外的事情。例如，使用 GSAP 库给粒子添加动画效果。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"// 使用GSAP创建从初始位置到结束位置的动画\ngsap.fromTo(\n    startPosition, \n    { \n        x: startPosition.x, \n        y: startPosition.y, \n        z: startPosition.z }, \n    {\n        x: endPosition.x,\n        y: endPosition.y,\n        z: endPosition.z,\n        duration: duration,\n        delay: delay * i / particles.geometry.attributes.position.count,\n        onUpdate: function () {\n            // 在每一帧更新时，更新粒子的实际位置\n            particles.geometry.attributes.position.setXYZ(i, startPosition.x, startPosition.y, startPosition.z);\n            particles.geometry.attributes.position.needsUpdate = true;\n        },\n        onComplete: function () {\n            // 动画完成后，反向播放回到初始位置的动画\n            gsap.to(startPosition, { x: startPosition.x, y: startPosition.y, z: startPosition.z, duration: duration, delay: duration, onUpdate: function () {\n                particles.geometry.attributes.position.setXYZ(i, startPosition.x, startPosition.y, startPosition.z);\n                particles.geometry.attributes.position.needsUpdate = true;\n            } \n        });\n    }\n});\n"})}),"\n",(0,t.jsx)(e.p,{children:"上面是粒子出现时的动画效果，除此之外，还有个场景的旋转动效："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:"// 为场景添加旋转动画，使整个场景旋转\ngsap.fromTo(scene.rotation, { y: -0.3 }, {\n    y: 0.3,\n    repeat: -1, // 无限重复\n    yoyo: true, // 在每次重复时反向播放\n    ease: 'power2.inOut', // 缓动函数\n    duration: 3 // 持续时间\n});\n"})}),"\n",(0,t.jsx)(e.p,{children:"当然，要是你对 GSAP 和 WebGL 熟悉的话，你还可以给粒子添加更复杂的动画效果："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-JavaScript",children:'/* 初始化和设置场景 */\nfunction initScene() {\n    // 创建一个新的Three.js场景\n    const scene = new THREE.Scene();\n\n    // 创建一个透视相机，设置视角、纵横比、近截面和远截面\n    const camera = new THREE.PerspectiveCamera(\n        75, // 视角广度\n        window.innerWidth / window.innerHeight, // 纵横比\n        0.1, // 近截面\n        5000 // 远截面\n    );\n    // 设置相机的位置，使其远离场景中心\n    camera.position.z = 500;\n\n    // 创建一个WebGL渲染器\n    const renderer = new THREE.WebGLRenderer();\n    // 设置渲染器的像素比率以适应不同的设备\n    renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);\n    // 设置渲染器的尺寸为窗口的宽和高\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    // 将渲染器的DOM元素（画布）添加到文档中\n    document.body.appendChild(renderer.domElement);\n\n    // 创建轨道控制器，使得可以用鼠标控制相机\n    const controlsWebGL = new THREE.OrbitControls(camera, renderer.domElement);\n\n    // 返回场景、相机和渲染器对象\n    return { scene, camera, renderer };\n}\n\n/* 基于 SVG 路径创建粒子 */\nfunction createParticles(scene, pathSelector) {\n    // 选择SVG路径元素\n    const path = document.querySelector(pathSelector);\n    // 获取路径的总长度\n    const length = path.getTotalLength();\n    // 初始化存储顶点的数组\n    const vertices = [];\n    // 创建一个全局的GSAP时间轴，用于包含所有动画\n    const tl = gsap.timeline({ repeat: -1, yoyo: true });\n\n    // 遍历路径的每个点，间隔为0.1\n    for (let i = 0; i < length; i += 0.1) {\n        // 获取路径上每个点的坐标\n        const point = path.getPointAtLength(i);\n        // 创建一个Three.js的向量对象表示这个点\n        const vector = new THREE.Vector3(point.x, -point.y, 0);\n        // 随机扰动这个点的位置，使得点看起来更分散\n        vector.x += (Math.random() - 0.5) * 30;\n        vector.y += (Math.random() - 0.5) * 30;\n        vector.z += (Math.random() - 0.5) * 70;\n        // 将这个点添加到顶点数组中\n        vertices.push(vector);\n    \n        // 为这个点创建一个动画\n        tl.from(vector, {\n          x: 600 / 2, // 心形的中心X坐标\n          y: -552 / 2, // 心形的中心Y坐标\n          z: 0, // 场景的中心\n          ease: "power2.inOut", // 缓动函数\n          duration: "random(.5, 1)" // 随机持续时间\n        }, i * 0.002); // 根据路径长度计算延迟\n    }\n\n    // 使用顶点数组创建一个BufferGeometry对象\n    const geometry = new THREE.BufferGeometry().setFromPoints(vertices);\n    // 创建一个粒子材质对象，设置颜色和大小\n    const material = new THREE.PointsMaterial({ color: 0xee5282, blending: THREE.AdditiveBlending, size: 3 });\n    // 使用几何体和材质创建一个点云对象\n    const particles = new THREE.Points(geometry, material);\n\n    // 调整点云的位置，使其居中\n    particles.position.x -= 600 / 2;\n    particles.position.y += 552 / 2;\n    // 将点云添加到场景中\n    scene.add(particles);\n\n    // 返回点云对象、顶点数组、几何体和GSAP时间轴\n    return { particles, vertices, geometry, tl };\n}\n\n/* 为场景添加旋转动画 */\nfunction addSceneRotation(scene) {\n    // 使用GSAP为整个场景添加旋转动画\n    gsap.fromTo(scene.rotation, { y: -0.2 }, {\n        y: 0.2,\n        repeat: -1, // 无限重复\n        yoyo: true, // 在每次重复时反向播放\n        ease: \'power2.inOut\', // 缓动函数\n        duration: 3 // 持续时间\n    });\n}\n\n/* Render the scene */\nfunction render(renderer, scene, camera, geometry, vertices) {\n    // 定义一个渲染循环函数\n    function animate() {\n        requestAnimationFrame(animate);\n        // 更新几何体中的顶点\n        geometry.setFromPoints(vertices);\n        // 渲染场景\n        renderer.render(scene, camera);\n    }\n    // 启动渲染循环\n    animate();\n}\n\n/* Handle window resize events */\nfunction onWindowResize(camera, renderer) {\n    // 定义一个窗口大小改变的处理函数\n    function handleResize() {\n        // 更新相机的纵横比\n        camera.aspect = window.innerWidth / window.innerHeight;\n        // 更新相机的投影矩阵\n        camera.updateProjectionMatrix();\n        // 更新渲染器的尺寸\n        renderer.setSize(window.innerWidth, window.innerHeight);\n    }\n    // 监听窗口大小改变事件\n    window.addEventListener("resize", handleResize, false);\n}\n\n/* 初始化并运行动画 */\nfunction runAnimation() {\n    // 初始化场景、相机和渲染器\n    const { scene, camera, renderer } = initScene();\n    // 创建粒子并添加到场景中\n    const { particles, vertices, geometry } = createParticles(scene, "#heart");\n    // 为场景添加旋转动画\n    addSceneRotation(scene);\n    // 启动渲染循环\n    render(renderer, scene, camera, geometry, vertices);\n    // 处理窗口大小改变事件\n    onWindowResize(camera, renderer);\n}\n\n/* 开始播放动画 */\nrunAnimation();\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["Demo 地址：",(0,t.jsx)(e.a,{href:"https://codepen.io/airen/full/OJYXKwK",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/OJYXKwK"})]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"现在你已经可以提取沿着 SVG 路径的点的坐标了，请尝试着将这些数据应用到其他地方。我相信你能创作出更具吸引力的交互动画效果。"}),"\n",(0,t.jsxs)(e.h2,{id:"小结",children:["小结",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"来到这里，表示我们这节课已经接近尾声。最后再稍微对今天课程的内容做一个小结。"}),"\n",(0,t.jsx)(e.p,{children:"正如你所看到的，SVG 提供数据给 WebGL，然后 WebGL 凭借其直接访问硬件加速图形的能力，以及其 3D 空间的能力，使 SVG 具备了更强的能力。换句话说，两者的结合，开拓了 Web 三维视觉表达的新天地，并且开创了一系列前所未有的创新效果，极大的丰富了 Web 内容的表面力。"}),"\n",(0,t.jsx)(e.p,{children:"除了课程中展示的效果之外，它们的结合，还可以创建更多的效果，并且这些效果是可以用于实际应用场景中。例如："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"高清不失真的信息图表技术融合"}),"：SVG 确保图标和文字无论放大多少倍都能保持清晰，WebGL 则通过光影处理为这些图形添加深度，使信息图表更加吸引眼球。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"沉浸式的 3D 交互体验技术融合"}),"：将 SVG 的二维图形作为纹理贴图应用于 WebGL 创建的 3D 模型上，再配以流畅的动画效果，打造出既细腻又立体的视觉景观。例如，在线博物馆和数字展览馆，参观者仿佛置身其间，能够 360 度旋转展品，近距离观察每一个细节。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"动态响应的用户界面技术融合"}),"：SVG 和 WebGL 通过 JavaScript 紧密协作，响应用户的每一次点击、滑动，实现即时的图形变化和动画反馈。例如，交互式新闻报道中，读者可以通过拖动时间轴来观看事件的发展，感受信息的流动和时间的变迁。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"真实感光照的视觉强化技术融合"}),"：WebGL 的着色器语言为 SVG 图形添加光照模型，模拟自然界的光影效果，提升视觉逼真度。例如，汽车官网展示，车身在不同的光线环境下展现出真实的金属光泽和色彩渐变，提升潜在买家的购买欲望。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"粒子系统带来的震撼视觉技术融合"}),"：WebGL 驱动的粒子系统在 SVG 背景上创造出火焰、爆炸、雨雪等动态效果，增强视觉冲击力。例如，电影预告网站，使用粒子效果模拟爆炸场景，吸引观众的眼球，营造紧张刺激的氛围。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"超现实的材质贴图体验技术融合"}),"：通过 WebGL 的纹理映射技术，SVG 图形可被赋予木纹、金属质感等材质，提升虚拟物品的真实性。例如，家具电商平台上，顾客可以旋转并近距离观察家具表面的纹理，如同亲临实体店一般。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"互动式 3D 地图导航技术融合"}),"：SVG 定义地图的基本结构，WebGL 则负责地形的 3D 渲染和实时阴影，用户可自由缩放和平移。例如，户外探险应用中，用户能够在三维地图上规划路线，预览沿途风景，享受沉浸式的探索体验。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"教育领域的互动模型技术融合"}),"：SVG 和 WebGL 联手打造可交互的生物解剖模型、机械构造演示，使抽象知识具象化。例如，在线医学课程，学生可以通过旋转、拆解 3D 人体模型，深入了解人体结构，提高学习效率。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"SVG 与 WebGL 的结合，不仅限于上述列举的场景，其潜力随着技术的演进和创意的碰撞不断被挖掘。未来，我们可以期待更多结合了这两项技术的创新应用，如 AR/VR 内容的无缝集成、实时数据驱动的动态场景、以及更加智能化的用户界面设计。开发者和设计师们正站在一个充满无限可能的交叉路口，他们手中的 SVG 与 WebGL，将是塑造下一代互联网体验的关键画笔。随着技术的成熟和工具链的完善，这一技术组合无疑将引领 Web 开发进入一个更为绚丽多彩的新纪元。"})]})}function A(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(W,{...n})}):W(n)}let R=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20SVG%2F30-%E5%AE%9E%E6%88%98%E7%AF%87%EF%BC%9ASVG%20%E4%B8%8E%20Web%20%E5%BC%80%E5%8F%91%E4%B9%8B%E5%88%A9%E7%94%A8%20WebGL%20%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%95%88%E6%9E%9C.md"]={toc:[{text:"今天的小目标",id:"今天的小目标",depth:2},{text:"WebGL 简介",id:"webgl-简介",depth:2},{text:"使用 SVGLoader 将 SVG 引入 WebGL",id:"使用-svgloader-将-svg-引入-webgl",depth:2},{text:"使用 React-three-fiber 拆分 SVG 并重用 WebGL 组件",id:"使用-react-three-fiber-拆分-svg-并重用-webgl-组件",depth:2},{text:"SVG 与 WebGL：创作无限可能",id:"svg-与-webgl创作无限可能",depth:2},{text:"Step01：**获取路径及其总长度**",id:"step01获取路径及其总长度",depth:3},{text:"Step02：**沿着路径循环直到达到其总长度**",id:"step02沿着路径循环直到达到其总长度",depth:3},{text:"Step03：**获取路径上每个点的坐标**",id:"step03获取路径上每个点的坐标",depth:3},{text:"Step04：**在每次迭代中，创建一个在该点坐标处的 Vector3 对象**",id:"step04在每次迭代中创建一个在该点坐标处的-vector3-对象",depth:3},{text:"Step05：**将向量推入顶点数组**",id:"step05将向量推入顶点数组",depth:3},{text:"Step06：**从顶点数组创建几何体**",id:"step06从顶点数组创建几何体",depth:3},{text:"Step07：**创建一个点云对象并将其添加到场景中**",id:"step07创建一个点云对象并将其添加到场景中",depth:3},{text:"Step08：使用 GSAP 给粒子添加动画效果",id:"step08使用-gsap-给粒子添加动画效果",depth:3},{text:"小结",id:"小结",depth:2}],title:"30-实战篇：SVG 与 Web 开发之利用 WebGL 创建更高级的图形效果",headingTitle:"30-实战篇：SVG 与 Web 开发之利用 WebGL 创建更高级的图形效果",frontmatter:{}}}}]);