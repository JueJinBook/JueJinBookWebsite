"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["14902"],{139085:function(e,n,s){s.r(n),s.d(n,{default:()=>c});var i=s(552676),l=s(740453);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",h3:"h3",strong:"strong",pre:"pre",ul:"ul",li:"li",blockquote:"blockquote",ol:"ol",h4:"h4"},(0,l.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"20配置解析服务配置文件在-vite-内部被转换成什么样子了",children:["20.配置解析服务：配置文件在 Vite 内部被转换成什么样子了？",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#20配置解析服务配置文件在-vite-内部被转换成什么样子了",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"我们前面学习了 Vite 的各种高级应用场景，接下来的几个小节，我们再把目光放到 Vite 的实现本身，来深度剖析 Vite 的内部源码实现。"}),"\n",(0,i.jsx)(n.p,{children:"可能你会有一个疑问，我们为什么要去读源码？原因主要有两个：一是加深对框架本身的理解，在面对一些项目的疑难杂症时，排查问题效率会更高；二是在遇到类似的开发场景时，可以举一反三，借鉴某个框架源码的实现思路，将技巧应用到其它的项目中。"}),"\n",(0,i.jsxs)(n.p,{children:["本小节我们要介绍 Vite 配置解析服务的源码部分。我们知道，Vite 构建环境分为",(0,i.jsx)(n.code,{children:"开发环境"}),"和",(0,i.jsx)(n.code,{children:"生产环境"}),"，不同环境会有不同的构建策略，但不管是哪种环境，Vite 都会首先解析用户配置。那接下来，我就与你分析配置解析过程中 Vite 到底做了什么。"]}),"\n",(0,i.jsxs)(n.p,{children:["首先，我会带你梳理整体的实现流程，然后拆解其中的重点细节，即",(0,i.jsx)(n.code,{children:"如何加载配置文件"}),"，让你不仅对 Vite 的配置解析服务有系统且完整的认识，还能写一个自己的",(0,i.jsx)(n.code,{children:"配置文件加载器"}),"。"]}),"\n",(0,i.jsxs)(n.h2,{id:"流程梳理",children:["流程梳理",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#流程梳理",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["我们先来梳理整体的流程，Vite 中的配置解析由 ",(0,i.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/config.ts#L255",target:"_blank",rel:"noopener noreferrer",children:"resolveConfig"})," 函数来实现，你可以对照源码一起学习。"]}),"\n",(0,i.jsxs)(n.h3,{id:"1-加载配置文件",children:["1. 加载配置文件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-加载配置文件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["进行一些必要的变量声明后，我们进入到",(0,i.jsx)(n.strong,{children:"解析配置"}),"逻辑中:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// 这里的 config 是命令行指定的配置，如 vite --configFile=xxx\nlet { configFile } = config\nif (configFile !== false) {\n  // 默认都会走到下面加载配置文件的逻辑，除非你手动指定 configFile 为 false\n  const loadResult = await loadConfigFromFile(\n    configEnv,\n    configFile,\n    config.root,\n    config.logLevel\n  )\n  if (loadResult) {\n    // 解析配置文件的内容后，和命令行配置合并\n    config = mergeConfig(loadResult.config, config)\n    configFile = loadResult.path\n    configFileDependencies = loadResult.dependencies\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["第一步是解析配置文件的内容(这部分比较复杂，本文后续单独分析)，然后与命令行配置合并。值得注意的是，后面有一个记录",(0,i.jsx)(n.code,{children:"configFileDependencies"}),"的操作。因为配置文件代码可能会有第三方库的依赖，所以当第三方库依赖的代码更改时，Vite 可以通过 HMR 处理逻辑中记录的",(0,i.jsx)(n.code,{children:"configFileDependencies"}),"检测到更改，再重启 DevServer ，来保证当前生效的配置永远是最新的。"]}),"\n",(0,i.jsxs)(n.h3,{id:"2-解析用户插件",children:["2. 解析用户插件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-解析用户插件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["第二个重点环节是 ",(0,i.jsx)(n.strong,{children:"解析用户插件"}),"。首先，我们通过 ",(0,i.jsx)(n.code,{children:"apply 参数"})," 过滤出需要生效的用户插件。为什么这么做呢？因为有些插件只在开发阶段生效，或者说只在生产环境生效，我们可以通过 ",(0,i.jsx)(n.code,{children:"apply: 'serve' 或 'build'"})," 来指定它们，同时也可以将",(0,i.jsx)(n.code,{children:"apply"}),"配置为一个函数，来自定义插件生效的条件。解析代码如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// resolve plugins\nconst rawUserPlugins = (config.plugins || []).flat().filter((p) => {\n  if (!p) {\n    return false\n  } else if (!p.apply) {\n    return true\n  } else if (typeof p.apply === 'function') {\n     // apply 为一个函数的情况\n    return p.apply({ ...config, mode }, configEnv)\n  } else {\n    return p.apply === command\n  }\n}) as Plugin[]\n// 对用户插件进行排序\nconst [prePlugins, normalPlugins, postPlugins] =\n  sortUserPlugins(rawUserPlugins)\n"})}),"\n",(0,i.jsx)(n.p,{children:"接着，Vite 会拿到这些过滤且排序完成的插件，依次调用插件 config 钩子，进行配置合并:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// run config hooks\nconst userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins]\nfor (const p of userPlugins) {\n  if (p.config) {\n    const res = await p.config(config, configEnv)\n    if (res) {\n      // mergeConfig 为具体的配置合并函数，大家有兴趣可以阅读一下实现\n      config = mergeConfig(config, res)\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后解析项目的根目录即 ",(0,i.jsx)(n.code,{children:"root"})," 参数，默认取 ",(0,i.jsx)(n.code,{children:"process.cwd()"}),"的结果:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// resolve root\nconst resolvedRoot = normalizePath(\n  config.root ? path.resolve(config.root) : process.cwd()\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["紧接着处理 ",(0,i.jsx)(n.code,{children:"alias"})," ，这里需要加上一些内置的 alias 规则，如",(0,i.jsx)(n.code,{children:"@vite/env"}),"、",(0,i.jsx)(n.code,{children:"@vite/client"}),"这种直接重定向到 Vite 内部的模块:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// resolve alias with internal client alias\nconst resolvedAlias = mergeAlias(\n  clientAlias,\n  config.resolve?.alias || config.alias || []\n)\n\nconst resolveOptions: ResolvedConfig['resolve'] = {\n  dedupe: config.dedupe,\n  ...config.resolve,\n  alias: resolvedAlias\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-加载环境变量",children:["3. 加载环境变量",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-加载环境变量",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["现在，我们进入第三个核心环节: ",(0,i.jsx)(n.strong,{children:"加载环境变量"}),"，它的实现代码如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// load .env files\nconst envDir = config.envDir\n  ? normalizePath(path.resolve(resolvedRoot, config.envDir))\n  : resolvedRoot\nconst userEnv =\n  inlineConfig.envFile !== false &&\n  loadEnv(mode, envDir, resolveEnvPrefix(config))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["loadEnv 其实就是扫描 ",(0,i.jsx)(n.code,{children:"process.env"})," 与 ",(0,i.jsx)(n.code,{children:".env"}),"文件，解析出 env 对象，值得注意的是，这个对象的属性最终会被挂载到",(0,i.jsx)(n.code,{children:"import.meta.env"})," 这个全局对象上。"]}),"\n",(0,i.jsx)(n.p,{children:"解析 env 对象的实现思路如下:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["遍历 process.env 的属性，拿到",(0,i.jsx)(n.strong,{children:"指定前缀"}),"开头的属性（默认指定为",(0,i.jsx)(n.code,{children:"VITE_"}),"），并挂载 env 对象上"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["遍历 .env 文件，解析文件，然后往 env 对象挂载那些以",(0,i.jsx)(n.strong,{children:"指定前缀"}),"开头的属性。遍历的文件先后顺序如下(下面的 ",(0,i.jsx)(n.code,{children:"mode"})," 开发阶段为 ",(0,i.jsx)(n.code,{children:"development"}),"，生产环境为",(0,i.jsx)(n.code,{children:"production"}),"):"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:".env.${mode}.local"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:".env.${mode}"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:".env.local"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:".env"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["特殊情况: 如果中途遇到 NODE_ENV 属性，则挂到 ",(0,i.jsx)(n.code,{children:"process.env.VITE_USER_NODE_ENV"}),"，Vite 会优先通过这个属性来决定是否走",(0,i.jsx)(n.code,{children:"生产环境"}),"的构建。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["接下来是对资源公共路径即",(0,i.jsx)(n.code,{children:"base URL"}),"的处理，逻辑集中在 resolveBaseUrl 函数当中:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// 解析 base url\nconst BASE_URL = resolveBaseUrl(config.base, command === 'build', logger)\n// 解析生产环境构建配置\nconst resolvedBuildOptions = resolveBuildOptions(config.build)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"resolveBaseUrl"}),"里面有这些处理规则需要注意:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["空字符或者 ",(0,i.jsx)(n.code,{children:"./"})," 在开发阶段特殊处理，全部重写为",(0,i.jsx)(n.code,{children:"/"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"."}),"开头的路径，自动重写为 ",(0,i.jsx)(n.code,{children:"/"})]}),"\n",(0,i.jsxs)(n.li,{children:["以",(0,i.jsx)(n.code,{children:"http(s)://"}),"开头的路径，在开发环境下重写为对应的 pathname"]}),"\n",(0,i.jsxs)(n.li,{children:["确保路径开头和结尾都是",(0,i.jsx)(n.code,{children:"/"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["当然，还有对",(0,i.jsx)(n.code,{children:"cacheDir"}),"的解析，这个路径相对于在 Vite 预编译时写入依赖产物的路径:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// resolve cache directory\nconst pkgPath = lookupFile(resolvedRoot, [`package.json`], true /* pathOnly */)\n// 默认为 node_module/.vite\nconst cacheDir = config.cacheDir\n  ? path.resolve(resolvedRoot, config.cacheDir)\n  : pkgPath && path.join(path.dirname(pkgPath), `node_modules/.vite`)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["紧接着处理用户配置的",(0,i.jsx)(n.code,{children:"assetsInclude"}),"，将其转换为一个过滤器函数:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const assetsFilter = config.assetsInclude\n  ? createFilter(config.assetsInclude)\n  : () => false\n"})}),"\n",(0,i.jsx)(n.p,{children:"Vite 后面会将用户传入的 assetsInclude 和内置的规则合并:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"assetsInclude(file: string) {\n  return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这个配置决定是否让 Vite 将对应的后缀名视为",(0,i.jsx)(n.code,{children:"静态资源文件"}),"（asset）来处理。"]}),"\n",(0,i.jsxs)(n.h3,{id:"4-路径解析器工厂",children:["4. 路径解析器工厂",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-路径解析器工厂",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["接下来，进入到第四个核心环节: ",(0,i.jsx)(n.strong,{children:"定义路径解析器工厂"}),"。这里所说的",(0,i.jsx)(n.code,{children:"路径解析器"}),"，是指调用插件容器进行",(0,i.jsx)(n.code,{children:"路径解析"}),"的函数。代码结构是这个样子的:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const createResolver: ResolvedConfig['createResolver'] = (options) => {\n  let aliasContainer: PluginContainer | undefined\n  let resolverContainer: PluginContainer | undefined\n  // 返回的函数可以理解为一个解析器\n  return async (id, importer, aliasOnly, ssr) => {\n    let container: PluginContainer\n    if (aliasOnly) {\n      container =\n        aliasContainer ||\n        // 新建 aliasContainer\n    } else {\n      container =\n        resolverContainer ||\n        // 新建 resolveContainer\n    }\n    return (await container.resolveId(id, importer, undefined, ssr))?.id\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这个解析器未来会在",(0,i.jsx)(n.strong,{children:"依赖预构建"}),"的时候用上，具体用法如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const resolve = config.createResolver()\n// 调用以拿到 react 路径\nrseolve('react', undefined, undefined, false)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这里有",(0,i.jsx)(n.code,{children:"aliasContainer"}),"和",(0,i.jsx)(n.code,{children:"resolverContainer"}),"两个工具对象，它们都含有",(0,i.jsx)(n.code,{children:"resolveId"}),"这个专门解析路径的方法，可以被 Vite 调用来获取解析结果。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["两个工具对象的本质是",(0,i.jsx)(n.code,{children:"PluginContainer"}),"，我们将在「编译流水线」小节详细介绍",(0,i.jsx)(n.code,{children:"PluginContainer"})," 的特点和实现。"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"接着会顺便处理一个 public 目录，也就是 Vite 作为静态资源服务的目录:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const { publicDir } = config\nconst resolvedPublicDir =\n  publicDir !== false && publicDir !== ''\n    ? path.resolve(\n        resolvedRoot,\n        typeof publicDir === 'string' ? publicDir : 'public'\n      )\n    : ''\n"})}),"\n",(0,i.jsx)(n.p,{children:"至此，配置已经基本上解析完成，最后通过 resolved 对象来整理一下:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const resolved: ResolvedConfig = {\n  ...config,\n  configFile: configFile ? normalizePath(configFile) : undefined,\n  configFileDependencies,\n  inlineConfig,\n  root: resolvedRoot,\n  base: BASE_URL\n  // 其余配置不再一一列举\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"5-生成插件流水线",children:["5. 生成插件流水线",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-生成插件流水线",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["最后，我们进入第五个环节: ",(0,i.jsx)(n.strong,{children:"生成插件流水线"}),"。代码如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:";(resolved.plugins as Plugin[]) = await resolvePlugins(\n  resolved,\n  prePlugins,\n  normalPlugins,\n  postPlugins\n)\n\n// call configResolved hooks\nawait Promise.all(userPlugins.map((p) => p.configResolved?.(resolved)))\n"})}),"\n",(0,i.jsxs)(n.p,{children:["先生成完整插件列表传给",(0,i.jsx)(n.code,{children:"resolve.plugins"}),"，而后调用每个插件的 ",(0,i.jsx)(n.code,{children:"configResolved"})," 钩子函数。其中 ",(0,i.jsx)(n.code,{children:"resolvePlugins"})," 内部细节比较多，插件数量比较庞大，我们暂时不去深究具体实现，编译流水线这一小节再来详细介绍。"]}),"\n",(0,i.jsxs)(n.p,{children:["至此，所有核心配置都生成完毕。不过，后面 Vite 还会处理一些边界情况，在用户配置不合理的时候，给用户对应的提示。比如：用户直接使用",(0,i.jsx)(n.code,{children:"alias"}),"时，Vite 会提示使用",(0,i.jsx)(n.code,{children:"resolve.alias"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["最后，",(0,i.jsx)(n.code,{children:"resolveConfig"})," 函数会返回 resolved 对象，也就是最后的配置集合，那么配置解析服务到底也就结束了。"]}),"\n",(0,i.jsxs)(n.h2,{id:"加载配置文件详解",children:["加载配置文件详解",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载配置文件详解",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["配置解析服务的流程梳理完，但刚开始",(0,i.jsx)(n.code,{children:"加载配置文件(loadConfigFromFile)"}),"的实现我们还没有具体分析，先来回顾下代码。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const loadResult = await loadConfigFromFile(/*省略传参*/)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这里的逻辑稍微有点复杂，很难梳理清楚，所以我们不妨借助刚才梳理的配置解析流程，深入",(0,i.jsx)(n.code,{children:"loadConfigFromFile"})," 的细节中，研究下 Vite 对于配置文件加载的实现思路。"]}),"\n",(0,i.jsxs)(n.p,{children:["首先，我们来分析下需要处理的配置文件类型，根据",(0,i.jsx)(n.code,{children:"文件后缀"}),"和",(0,i.jsx)(n.code,{children:"模块格式"}),"可以分为下面这几类:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"TS + ESM 格式"}),"\n",(0,i.jsx)(n.li,{children:"TS + CommonJS 格式"}),"\n",(0,i.jsx)(n.li,{children:"JS + ESM 格式"}),"\n",(0,i.jsx)(n.li,{children:"JS + CommonJS 格式"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"那么，Vite 是如何加载配置文件的？一共分两个步骤:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"识别出配置文件的类别"}),"\n",(0,i.jsx)(n.li,{children:"根据不同的类别分别解析出配置内容"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"1-识别配置文件的类别",children:["1. 识别配置文件的类别",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-识别配置文件的类别",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["首先 Vite 会检查项目的 package.json ，如果有",(0,i.jsx)(n.code,{children:'type: "module"'}),"则打上 ",(0,i.jsx)(n.code,{children:"isESM"})," 的标识:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"try {\n  const pkg = lookupFile(configRoot, ['package.json'])\n  if (pkg && JSON.parse(pkg).type === 'module') {\n    isMjs = true\n  }\n} catch (e) {}\n"})}),"\n",(0,i.jsx)(n.p,{children:"然后，Vite 会寻找配置文件路径，代码简化后如下:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let isTS = false\nlet isESM = false\nlet dependencies: string[] = []\n// 如果命令行有指定配置文件路径\nif (configFile) {\n  resolvedPath = path.resolve(configFile)\n  // 根据后缀判断是否为 ts 或者 esm，打上 flag\n  isTS = configFile.endsWith('.ts')\n  if (configFile.endsWith('.mjs')) {\n      isESM = true\n    }\n} else {\n  // 从项目根目录寻找配置文件路径，寻找顺序:\n  // - vite.config.js\n  // - vite.config.mjs\n  // - vite.config.ts\n  // - vite.config.cjs\n  const jsconfigFile = path.resolve(configRoot, 'vite.config.js')\n  if (fs.existsSync(jsconfigFile)) {\n    resolvedPath = jsconfigFile\n  }\n\n  if (!resolvedPath) {\n    const mjsconfigFile = path.resolve(configRoot, 'vite.config.mjs')\n    if (fs.existsSync(mjsconfigFile)) {\n      resolvedPath = mjsconfigFile\n      isESM = true\n    }\n  }\n\n  if (!resolvedPath) {\n    const tsconfigFile = path.resolve(configRoot, 'vite.config.ts')\n    if (fs.existsSync(tsconfigFile)) {\n      resolvedPath = tsconfigFile\n      isTS = true\n    }\n  }\n  \n  if (!resolvedPath) {\n    const cjsConfigFile = path.resolve(configRoot, 'vite.config.cjs')\n    if (fs.existsSync(cjsConfigFile)) {\n      resolvedPath = cjsConfigFile\n      isESM = false\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在寻找路径的同时， Vite 也会给当前配置文件打上",(0,i.jsx)(n.code,{children:"isESM"}),"和",(0,i.jsx)(n.code,{children:"isTS"}),"的标识，方便后续的解析。"]}),"\n",(0,i.jsxs)(n.h3,{id:"2-根据类别解析配置",children:["2. 根据类别解析配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-根据类别解析配置",children:"#"})]}),"\n",(0,i.jsxs)(n.h4,{id:"esm-格式",children:["ESM 格式",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#esm-格式",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"对于 ESM 格式配置的处理代码如下："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let userConfig: UserConfigExport | undefined\n\nif (isESM) {\n  const fileUrl = require('url').pathToFileURL(resolvedPath)\n  // 首先对代码进行打包\n  const bundled = await bundleConfigFile(resolvedPath, true)\n  dependencies = bundled.dependencies\n  // TS + ESM\n  if (isTS) {\n    fs.writeFileSync(resolvedPath + '.js', bundled.code)\n    userConfig = (await dynamicImport(`${fileUrl}.js?t=${Date.now()}`))\n      .default\n    fs.unlinkSync(resolvedPath + '.js')\n    debug(`TS + native esm config loaded in ${getTime()}`, fileUrl)\n  } \n  //  JS + ESM\n  else {\n    userConfig = (await dynamicImport(`${fileUrl}?t=${Date.now()}`)).default\n    debug(`native esm config loaded in ${getTime()}`, fileUrl)\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"首先通过 Esbuild 将配置文件编译打包成 js 代码:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const bundled = await bundleConfigFile(resolvedPath, true)\n// 记录依赖\ndependencies = bundled.dependencies\n"})}),"\n",(0,i.jsxs)(n.p,{children:["对于 TS 配置文件来说，Vite 会将编译后的 js 代码写入",(0,i.jsx)(n.code,{children:"临时文件"}),"，通过 Node 原生 ESM Import 来读取这个临时的内容，以获取到配置内容，再直接删掉临时文件:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"fs.writeFileSync(resolvedPath + '.js', bundled.code)\nuserConfig = (await dynamicImport(`${fileUrl}.js?t=${Date.now()}`)).default\nfs.unlinkSync(resolvedPath + '.js')\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"以上这种先编译配置文件，再将产物写入临时目录，最后加载临时目录产物的做法，也是 AOT (Ahead Of Time)编译技术的一种具体实现。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["而对于 JS 配置文件来说，Vite 会直接通过 Node 原生 ESM Import 来读取，也是使用 dynamicImport 函数的逻辑。",(0,i.jsx)(n.code,{children:"dynamicImport"})," 的实现如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export const dynamicImport = new Function('file', 'return import(file)')\n"})}),"\n",(0,i.jsxs)(n.p,{children:["你可能会问，为什么要用 new Function 包裹？这是为了避免打包工具处理这段代码，比如 ",(0,i.jsx)(n.code,{children:"Rollup"})," 和 ",(0,i.jsx)(n.code,{children:"TSC"}),"，类似的手段还有 ",(0,i.jsx)(n.code,{children:"eval"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"你可能还会问，为什么 import 路径结果要加上时间戳 query？这其实是为了让 dev server 重启后仍然读取最新的配置，避免缓存。"}),"\n",(0,i.jsxs)(n.h3,{id:"commonjs-格式",children:["CommonJS 格式",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs-格式",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"对于 CommonJS 格式的配置文件，Vite 集中进行了解析:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// 对于 js/ts 均生效\n// 使用 esbuild 将配置文件编译成 commonjs 格式的 bundle 文件\nconst bundled = await bundleConfigFile(resolvedPath)\ndependencies = bundled.dependencies\n// 加载编译后的 bundle 代码\nuserConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"bundleConfigFile"})," 的逻辑上文中已经说了，主要是通过 Esbuild 将配置文件打包，拿到打包后的 bundle 代码以及配置文件的依赖(dependencies)。"]}),"\n",(0,i.jsxs)(n.p,{children:["而接下来的事情就是考虑如何加载 bundle 代码了，这也是",(0,i.jsx)(n.code,{children:"loadConfigFromBundledFile"})," 要做的事情。我们来看一下这个函数具体的实现:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"async function loadConfigFromBundledFile(\n  fileName: string,\n  bundledCode: string\n): Promise<UserConfig> {\n  const extension = path.extname(fileName)\n  const defaultLoader = require.extensions[extension]!\n  require.extensions[extension] = (module: NodeModule, filename: string) => {\n    if (filename === fileName) {\n      ;(module as NodeModuleWithCompile)._compile(bundledCode, filename)\n    } else {\n      defaultLoader(module, filename)\n    }\n  }\n  // 清除 require 缓存\n  delete require.cache[require.resolve(fileName)]\n  const raw = require(fileName)\n  const config = raw.__esModule ? raw.default : raw\n  require.extensions[extension] = defaultLoader\n  return config\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"大体的思路是通过拦截原生 require.extensions 的加载函数来实现对 bundle 后配置代码的加载。代码如下:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// 默认加载器\nconst defaultLoader = require.extensions[extension]!\n// 拦截原生 require 对于`.js`或者`.ts`的加载\nrequire.extensions[extension] = (module: NodeModule, filename: string) => {\n  // 针对 vite 配置文件的加载特殊处理\n  if (filename === fileName) {\n    ;(module as NodeModuleWithCompile)._compile(bundledCode, filename)\n  } else {\n    defaultLoader(module, filename)\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"而原生 require 对于 js 文件的加载代码是这样的:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"Module._extensions['.js'] = function (module, filename) {\n  var content = fs.readFileSync(filename, 'utf8')\n  module._compile(stripBOM(content), filename)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Node.js 内部也是先读取文件内容，然后编译该模块。当代码中调用 ",(0,i.jsx)(n.code,{children:"module._compile"})," 相当于手动编译一个模块，该方法在 Node 内部的实现如下:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"Module.prototype._compile = function (content, filename) {\n  var self = this\n  var args = [self.exports, require, self, filename, dirname]\n  return compiledWrapper.apply(self.exports, args)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"等同于下面的形式:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:";(function (exports, require, module, __filename, __dirname) {\n  // 执行 module._compile 方法中传入的代码\n  // 返回 exports 对象\n})\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在调用完 ",(0,i.jsx)(n.code,{children:"module._compile"})," 编译完配置代码后，进行一次手动的 require，即可拿到配置对象:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const raw = require(fileName)\nconst config = raw.__esModule ? raw.default : raw\n// 恢复原生的加载方法\nrequire.extensions[extension] = defaultLoader\n// 返回配置\nreturn config\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["这种运行时加载 TS 配置的方式，也叫做 ",(0,i.jsx)(n.code,{children:"JIT"}),"(即时编译)，这种方式和 ",(0,i.jsx)(n.code,{children:"AOT"})," 最大的区别在于不会将内存中计算出来的 js 代码写入磁盘再加载，而是通过拦截 Node.js 原生 require.extension 方法实现即时加载。"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"至此，配置文件的内容已经读取完成，等后处理完成再返回即可:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// 处理是函数的情况\nconst config = await (typeof userConfig === 'function'\n  ? userConfig(configEnv)\n  : userConfig)\n\nif (!isObject(config)) {\n  throw new Error(`config must export or return an object.`)\n}\n// 接下来返回最终的配置信息\nreturn {\n  path: normalizePath(resolvedPath),\n  config,\n  // esbuild 打包过程中搜集的依赖\n  dependencies\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"总结",children:["总结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["配置解析的源码精读部分到这里就结束了，再次恭喜你，学习完了本小节的内容。本小节中，你需要重点掌握",(0,i.jsx)(n.code,{children:"Vite 配置解析的整体流程"}),"和",(0,i.jsx)(n.code,{children:"加载配置文件的方法"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["首先，Vite 配置文件解析的逻辑由 ",(0,i.jsx)(n.code,{children:"resolveConfig"})," 函数统一实现，其中经历了加载配置文件、解析用户插件、加载环境变量、创建路径解析器工厂和生成插件流水线这几个主要的流程。"]}),"\n",(0,i.jsxs)(n.p,{children:["其次，在",(0,i.jsx)(n.code,{children:"加载配置文件"}),"的过程中，Vite 需要处理四种类型的配置文件，其中对于 ESM 和 CommonJS 两种格式的 TS 文件，分别采用了",(0,i.jsx)(n.code,{children:"AOT"}),"和",(0,i.jsx)(n.code,{children:"JIT"}),"两种编译技术实现了配置加载。"]}),"\n",(0,i.jsx)(n.p,{children:"最后，我想留一个问题: 如果现在让你设计一个 cli 工具，用来支持 TS 的配置文件，你会如何进行配置解析呢？"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F20.%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9C%A8%20Vite%20%E5%86%85%E9%83%A8%E8%A2%AB%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E4%BA%86%EF%BC%9F.md"]={toc:[{text:"流程梳理",id:"流程梳理",depth:2},{text:"1. 加载配置文件",id:"1-加载配置文件",depth:3},{text:"2. 解析用户插件",id:"2-解析用户插件",depth:3},{text:"3. 加载环境变量",id:"3-加载环境变量",depth:3},{text:"4. 路径解析器工厂",id:"4-路径解析器工厂",depth:3},{text:"5. 生成插件流水线",id:"5-生成插件流水线",depth:3},{text:"加载配置文件详解",id:"加载配置文件详解",depth:2},{text:"1. 识别配置文件的类别",id:"1-识别配置文件的类别",depth:3},{text:"2. 根据类别解析配置",id:"2-根据类别解析配置",depth:3},{text:"ESM 格式",id:"esm-格式",depth:4},{text:"CommonJS 格式",id:"commonjs-格式",depth:3},{text:"总结",id:"总结",depth:2}],title:"20.配置解析服务：配置文件在 Vite 内部被转换成什么样子了？",headingTitle:"20.配置解析服务：配置文件在 Vite 内部被转换成什么样子了？",frontmatter:{}}}}]);