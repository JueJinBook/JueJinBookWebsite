"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["61905"],{540122:function(e,s,r){r.r(s),r.d(s,{default:()=>P});var n=r(552676),c=r(740453);let d=r.p+"static/image/64c5f50ce3af260a8c32ccf1398db238.91110a31.webp",l=r.p+"static/image/82edb1e704b9426c0bdb30a622e06fe2.1ad8c6ae.webp",t=r.p+"static/image/000ec60e8ec13f9b8df0a3f447e99e9a.a62e4361.webp",a=r.p+"static/image/24c27c63b884d4d5ebb14137412fed3e.5084c70b.webp",i=r.p+"static/image/234434b77a65645b19b4a6d7fcfd3e05.3da70642.webp",h=r.p+"static/image/a33515eb2e9baa8eae17d921a7e5944f.30487def.webp",o=r.p+"static/image/7f2e6e710ddbe4456799df04a92f1f83.75f20d47.webp",j=r.p+"static/image/b3e273deedb3bc994c0370955dd2989d.a0e21ed4.webp",x=r.p+"static/image/2205ed2fcdbb2cc91b58029bf29a44c3.3d386bc1.webp",p=r.p+"static/image/8644652fc885fcd2c77b14e26b4c3e28.b5398d5a.webp",u=r.p+"static/image/7401230d3b859b9b211e4dd4668330ad.68f45251.webp",g=r.p+"static/image/6eb91ca76da972971fac4d0bad04403d.8fc176a4.webp",f=r.p+"static/image/c45ed1812d85c8d9c4203a036e481f7c.5a844f13.webp",m=r.p+"static/image/b96db53d44513f058cbfe6270a23ddfb.24a616a5.webp",b=r.p+"static/image/3eb3b5a789e47c289a9843e90260bf8a.e40c236a.webp",v=r.p+"static/image/2fc8fa9921514e04147d9eb33a336073.2fbf508c.webp",y=r.p+"static/image/a87ef68eff79ca82633c5279b46913ac.13151ff2.webp";function A(e){let s=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",img:"img",pre:"pre",code:"code",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h3:"h3",ol:"ol",li:"li"},(0,c.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(s.h1,{id:"14-sveltekit--路由",children:["14-SvelteKit ❘ 路由",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#14-sveltekit--路由",children:"#"})]}),"\n",(0,n.jsxs)(s.blockquote,{children:["\n",(0,n.jsx)(s.p,{children:"推荐学习指数：⭐️⭐⭐️，必学内容️"}),"\n"]}),"\n",(0,n.jsxs)(s.h2,{id:"1-前言",children:["1. 前言",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,n.jsx)(s.p,{children:"本篇我们介绍 SvelteKit 的重要组成部分 —— 路由。所谓路由，指的是根据 URL 匹配对应处理程序的过程。"}),"\n",(0,n.jsx)(s.p,{children:"在开始之前，先分享一个小技巧，因为我发现有的同学新建文件是一个文件夹一个文件夹建立的……"}),"\n",(0,n.jsx)(s.p,{children:"在 VSCode 中，其实可以一次性建立目录和文件："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,n.jsx)(s.p,{children:"这本小册讲到需要修改代码的时候，我会写出明确的操作和具体目录，比如："}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-bash",children:"新建 src/routes/posts/+page.js，代码如下：\n\n修改 src/routes/posts/+page.js，代码如下：\n"})}),"\n",(0,n.jsx)(s.p,{children:"当是“新建”的时候，你可以拷贝地址，然后在项目根目录新建文件，输入地址，VSCode 就会自动新建文件。"}),"\n",(0,n.jsx)(s.p,{children:"当是“修改”的时候，你可以拷贝地址，然后 Command + P，输入地址，VSCode 应该会正确打开文件。"}),"\n",(0,n.jsxs)(s.blockquote,{children:["\n",(0,n.jsx)(s.p,{children:"注：小册《Next.js 开发指南》也是这样的"}),"\n"]}),"\n",(0,n.jsxs)(s.h2,{id:"2-文件即路由",children:["2. 文件即路由",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#2-文件即路由",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["跟 Next.js 一样，Svelte 采用的是基于文件系统的路由。也就是说，",(0,n.jsx)(s.strong,{children:"应用的路由地址由代码库中的目录决定"}),"，比如："]}),"\n",(0,n.jsxs)(s.table,{children:["\n",(0,n.jsxs)(s.thead,{children:["\n",(0,n.jsxs)(s.tr,{children:["\n",(0,n.jsx)(s.th,{children:"文件地址"}),"\n",(0,n.jsx)(s.th,{children:"对应路由地址"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.tbody,{children:["\n",(0,n.jsxs)(s.tr,{children:["\n",(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"src/routes/+page.svelte"})}),"\n",(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"/"})}),"\n"]}),"\n",(0,n.jsxs)(s.tr,{children:["\n",(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"src/routes/about/+page.svelte"})}),"\n",(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"/about"})}),"\n"]}),"\n",(0,n.jsxs)(s.tr,{children:["\n",(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"src/routes/sverdle/how-to-play/+page.svelte"})}),"\n",(0,n.jsx)(s.td,{children:(0,n.jsx)(s.code,{children:"/sverdle/how-to-play"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["Svelte 约定了多个路由相关的文件，它们的文件名都会添加 ",(0,n.jsx)(s.code,{children:"+"}),"前缀用于识别，比如 ",(0,n.jsx)(s.code,{children:"+page.svelte"}),"。本篇我们会一一介绍。"]}),"\n",(0,n.jsxs)(s.h2,{id:"3-page",children:["3. +page",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#3-page",children:"#"})]}),"\n",(0,n.jsxs)(s.h3,{id:"31-pagesvelte",children:["3.1. +page.svelte",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#31-pagesvelte",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"+page.svelte"}),"用于定义路由对应的页面。",(0,n.jsx)(s.strong,{children:"默认情况下，页面会在初始请求的时候采用服务端渲染，然后在后续导航的时候使用客户端渲染。"})]}),"\n",(0,n.jsx)(s.p,{children:"这句话是什么意思呢？我们写个简单的 Demo 就知道了。"}),"\n",(0,n.jsxs)(s.p,{children:["新建 ",(0,n.jsx)(s.code,{children:"src/routes/authors/+page.svelte"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:'<a href="/authors">Auther List</a>\n<a href="/posts">Post List</a>\n\n<h1>Hello Auther List!</h1>\n'})}),"\n",(0,n.jsxs)(s.p,{children:["新建 ",(0,n.jsx)(s.code,{children:"src/routes/posts/+page.svelte"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:'<a href="/authors">Auther List</a>\n<a href="/posts">Post List</a>\n\n<h1>Hello Post List!</h1>\n'})}),"\n",(0,n.jsxs)(s.p,{children:["浏览器打开 ",(0,n.jsx)(s.a,{href:"http://localhost:5173/authors",title:"http://localhost:5173/authors",target:"_blank",rel:"noopener noreferrer",children:(0,n.jsx)(s.a,{href:"http://localhost:5173/authors",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:5173/authors"})}),"，效果如下："]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:y,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["效果描述：首次打开 ",(0,n.jsx)(s.a,{href:"http://localhost:5173/authors",title:"http://localhost:5173/authors",target:"_blank",rel:"noopener noreferrer",children:(0,n.jsx)(s.a,{href:"http://localhost:5173/authors",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:5173/authors"})})," 的时候，",(0,n.jsx)(s.code,{children:"/authors"}),"页面采用服务端渲染，查看 ",(0,n.jsx)(s.code,{children:"/authors"})," HTML 文件即可看出："]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:v,alt:""})}),"\n",(0,n.jsx)(s.p,{children:"当点击跳转其他路由地址的时候，你会发现路由地址虽然发生了改变，但页面并没有发生刷新行为，而是直接渲染了对应路由的内容。这就是客户端导航。通过 JavaScript 拦截默认的跳转行为，然后加载对应路由的内容进行渲染，因为在客户端完成渲染，所以是 CSR。整个应用的表现类似于 SPA。"}),"\n",(0,n.jsxs)(s.blockquote,{children:["\n",(0,n.jsxs)(s.p,{children:["注意：不同于 Next.js 使用特定的 ",(0,n.jsx)(s.code,{children:"<Link>"}),"组件，SvelteKit 可以直接使用 ",(0,n.jsx)(s.code,{children:"<a>"}),"元素在路由间导航"]}),"\n"]}),"\n",(0,n.jsxs)(s.h3,{id:"32-pagejs",children:["3.2. +page.js",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#32-pagejs",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["通常，页面需要先加载一些数据再进行渲染。为此我们可以创建一个导出 ",(0,n.jsx)(s.code,{children:"load"}),"函数的 ",(0,n.jsx)(s.code,{children:"+page.js"}),"。"]}),"\n",(0,n.jsxs)(s.p,{children:["新建 ",(0,n.jsx)(s.code,{children:"src/routes/posts/+page.js"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:"export async function load({ fetch }) {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts');\n  const posts = await response.json();\n  console.log(posts.length)\n  return {\n    posts\n  };\n}\n"})}),"\n",(0,n.jsxs)(s.p,{children:["此函数会和 ",(0,n.jsx)(s.code,{children:"+page.svelte"})," 一起运行，也就是说，它也会在初始请求的时候在服务端运行，然后在后续导航的时候在客户端运行。"]}),"\n",(0,n.jsx)(s.p,{children:"不过这样说并不完全准确，实际上，此函数在初始请求的时候也会在客户端运行一次。不信我们补全一下 Demo。"}),"\n",(0,n.jsxs)(s.p,{children:["修改 ",(0,n.jsx)(s.code,{children:"src/routes/posts/+page.svelte"}),"，完整代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:'<script>\n  let { data } = $props();\n<\/script>\n\n<a href="/authors">Auther List</a>\n<a href="/posts">Post List</a>\n\n<h1>Posts list</h1>\n<ul>\n  {#each data.posts as {id, title}}\n    <li><a href={`/posts/${id}`}>{title}</li>\n  {/each}\n</ul>\n'})}),"\n",(0,n.jsx)(s.p,{children:"浏览器效果如下："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:b,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["你会发现，",(0,n.jsx)(s.code,{children:"+page.js"}),"中的 ",(0,n.jsx)(s.code,{children:"console.log(posts.length)"}),"在初始请求的时候，会在浏览器和命令行各自打印一次。但如果你查看页面请求，你会发现并没有 ",(0,n.jsx)(s.code,{children:"https://jsonplaceholder.typicode.com/posts"})," 这个 HTTP 请求。"]}),"\n",(0,n.jsxs)(s.p,{children:["如果从其他页面导航至 ",(0,n.jsx)(s.code,{children:"/posts"}),"，则只有浏览器会打印一次，页面中会有 ",(0,n.jsx)(s.code,{children:"https://jsonplaceholder.typicode.com/posts"})," 这个请求。"]}),"\n",(0,n.jsx)(s.p,{children:"这是为什么呢？"}),"\n",(0,n.jsxs)(s.p,{children:["原因在于我们使用了 Svelte 提供的 ",(0,n.jsx)(s.code,{children:"fetch"})," 函数，而非原生的 ",(0,n.jsx)(s.code,{children:"fetch"}),"："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:"export async function load({ fetch }) {\n  fetch(...)\n}\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Svelte 提供的 ",(0,n.jsx)(s.code,{children:"fetch"})," 函数与原生 ",(0,n.jsx)(s.code,{children:"fetch"})," 一致，但会有一些额外的功能，就比如在服务端渲染的时候，会将获取的数据内联到 HTML 中，然后在水合的时候，从 HTML 读取响应数据，从而防止重复的网络请求。这也就是为什么初始请求中 ",(0,n.jsx)(s.code,{children:"console.log"})," 执行了两次，但客户端并没有发起网络请求。"]}),"\n",(0,n.jsxs)(s.p,{children:["开发的时候，应该尽可能使用 ",(0,n.jsx)(s.code,{children:"load"})," 函数提供的 ",(0,n.jsx)(s.code,{children:"fetch"}),"，否则浏览器会有 warning 提示："]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:m,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["除了导出 ",(0,n.jsx)(s.code,{children:"load"})," 函数，",(0,n.jsx)(s.code,{children:"+page.js"}),"也可以导出一些用于配置页面行为的变量："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:"// 配置页面是否使用 SSR 渲染，默认为 true，如果设置为 false，页面在初始请求的时候使用客户端渲染\nexport const ssr = true | false;\n\n// 配置页面是否使用 CSR 渲染。默认为 true，如果设置为 false，表示不需要客户端渲染，则只走服务端渲染，适用于只有 HTML 和 CSS 的静态页面\nexport const csr = true | false;\n\n// 除此之外还有一些其他的配置项，《SvelteKit | 页面选项》篇会介绍\n"})}),"\n",(0,n.jsxs)(s.h3,{id:"33-pageserverjs",children:["3.3. +page.server.js",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#33-pageserverjs",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["有的时候，",(0,n.jsx)(s.code,{children:"load"})," 函数只能运行在服务端，比如需要从数据库中查找数据或者用到一些涉及安全的私钥。此时可以将 ",(0,n.jsx)(s.code,{children:"+page.js"})," 重命名为 ",(0,n.jsx)(s.code,{children:"+page.server.js"}),"，函数将只在服务端运行："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:'// +page.js => +page.server.js\nexport async function load({ fetch }) {\n  const response = await fetch("https://jsonplaceholder.typicode.com/posts");\n  const posts = await response.json();\n  console.log(posts.length);\n  return {\n    posts,\n  };\n}\n'})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"load"})," 函数将只在服务端运行。在初始请求的时候，load 返回的数据将内联在 HTML 中，然后水合的时候从 HTML 中获取。在客户端导航的时候，SvelteKit 将从服务端加载这些数据，为了能够让客户端成功获取这些数据，数据必须是可序列化的，SvelteKit 背后使用 ",(0,n.jsx)(s.a,{href:"https://github.com/rich-harris/devalue",title:"https://github.com/rich-harris/devalue",target:"_blank",rel:"noopener noreferrer",children:"devalue"})," 这个库实现数据序列化。"]}),"\n",(0,n.jsxs)(s.blockquote,{children:["\n",(0,n.jsx)(s.p,{children:"注：devalue 类似于 JSON.stringify，但是能处理如循环引用等特殊情况，相当于加强版的 JSON.stringify"}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"+page.server.js"})," 也可以导出页面配置选项如 ",(0,n.jsx)(s.code,{children:"prerender"}),"、",(0,n.jsx)(s.code,{children:"ssr"}),"、",(0,n.jsx)(s.code,{children:"csr"})," 等。"]}),"\n",(0,n.jsxs)(s.h2,{id:"4-errorsvelte",children:["4. +error.svelte",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#4-errorsvelte",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["如果 ",(0,n.jsx)(s.code,{children:"load"})," 函数发生错误，SvelteKit 将渲染默认错误页面。我们可以在 ",(0,n.jsx)(s.code,{children:"load"}),"函数中手动抛出一个错误模拟效果："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-diff",children:"export async function load({ fetch }) {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts');\n  const posts = await response.json();\n+ throw new Error('custom error')\n  console.log(posts.length);\n  return {\n    posts\n  };\n}\n"})}),"\n",(0,n.jsx)(s.p,{children:"浏览器效果如下："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:f,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["你可以添加一个 ",(0,n.jsx)(s.code,{children:"+error.svelte"}),"为路由自定义错误页面。"]}),"\n",(0,n.jsxs)(s.p,{children:["新建 ",(0,n.jsx)(s.code,{children:"src/routes/posts/+error.svelte"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:"<script>\n  import { page } from '$app/stores';\n<\/script>\n\n<h1>{$page.status}: {$page.error.message}</h1>\n\n<style>\n  h1 {\n    color: red\n  }\n</style>\n"})}),"\n",(0,n.jsx)(s.p,{children:"此时浏览器效果如下："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:g,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["当出现错误时，SvelteKit 会向上查找最近的 ",(0,n.jsx)(s.code,{children:"+error.svelte"}),"。假设 ",(0,n.jsx)(s.code,{children:"src/routes/posts/+page.server.js"}),"出错，它的查找顺序是："]}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.code,{children:"src/routes/posts/+error.svelte"})}),"\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.code,{children:"src/routes/+error.svelte"})}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"如果都没有，则渲染默认的错误界面。"}),"\n",(0,n.jsxs)(s.blockquote,{children:["\n",(0,n.jsxs)(s.p,{children:["注意：下节会讲到 ",(0,n.jsx)(s.code,{children:"+layout(.server).js"}),"，因为布局会包裹页面，所以如果是布局中的 load 函数出错，最近的 +error.svelte 不是相同目录下的，而是父级目录下的。"]}),"\n",(0,n.jsxs)(s.p,{children:["如果错误从根布局 ",(0,n.jsx)(s.code,{children:"src/routes/+layout(.server).js"}),"抛出，则会渲染静态的 fallback 错误页面，样式同默认错误页面，但可以通过创建 ",(0,n.jsx)(s.code,{children:"src/error.html"}),"自定义该页面"]}),"\n"]}),"\n",(0,n.jsxs)(s.h2,{id:"5-layout",children:["5. +layout",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#5-layout",children:"#"})]}),"\n",(0,n.jsxs)(s.h3,{id:"51-layoutsvelte",children:["5.1. +layout.svelte",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#51-layoutsvelte",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["客户端导航的时候，原有的 ",(0,n.jsx)(s.code,{children:"+page.svelte"})," 组件将被销毁，取而代之使用新的 ",(0,n.jsx)(s.code,{children:"+page.svelte"}),"，但有的时候，有些元素应该保持状态不变，比如导航栏、页脚等。此时就可以将这些元素放到布局中。"]}),"\n",(0,n.jsxs)(s.p,{children:["新建 ",(0,n.jsx)(s.code,{children:"src/routes/+layout.svelte"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:'<script>\n  let { children } = $props();\n<\/script>\n\n<a href="/authors">Auther List</a>\n<a href="/posts">Post List</a>\n\n{@render children()}\n'})}),"\n",(0,n.jsxs)(s.p,{children:["其中 ",(0,n.jsx)(s.code,{children:"{@render children()}"}),"表示页面和子页面内容。此时就可以删除 ",(0,n.jsx)(s.code,{children:"svelte-app/src/routes/authors/+page.svelte"}),"和 ",(0,n.jsx)(s.code,{children:"svelte-app/src/routes/posts/+page.svelte"}),"中的导航链接。"]}),"\n",(0,n.jsx)(s.p,{children:"浏览器效果不变："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:u,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"布局支持嵌套。默认情况下，每个布局都会继承其上方的布局。"})," 比如这样一个文件目录："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:"routes\n├─ auth\n│  ├─ signin\n│  │  └─ +layout.svelte\n│  │  └─ +page.svelte\n│  └─ +layout.svelte\n├─ posts\n│  ├─ +page.server.js\n│  └─ +page.svelte\n├─ +layout.svelte\n└─ +page.svelte\n"})}),"\n",(0,n.jsxs)(s.p,{children:["其中 ",(0,n.jsx)(s.code,{children:"routes/auth/signin/+page.svelte"})," 会继承",(0,n.jsx)(s.code,{children:"routes/auth/signin/+layout.svelte"}),"、",(0,n.jsx)(s.code,{children:"routes/auth/+layout.svelte"})," 和 ",(0,n.jsx)(s.code,{children:"routes/+layout.svelte"}),"的内容。"]}),"\n",(0,n.jsxs)(s.p,{children:["当同一目录有 ",(0,n.jsx)(s.code,{children:"+page.svelte"}),"、",(0,n.jsx)(s.code,{children:"+layout.svelte"}),"、",(0,n.jsx)(s.code,{children:"+error.svelte"})," 时，三者的层级关系为："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:"<Layout>\n  <Error>\n    <Page />\n  </Error>\n</Layout>\n"})}),"\n",(0,n.jsxs)(s.h3,{id:"52-layoutjs",children:["5.2. +layout.js",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#52-layoutjs",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["就像 ",(0,n.jsx)(s.code,{children:"+page.svelte"})," 可以从 ",(0,n.jsx)(s.code,{children:"+page.js"})," 获取数据一样，",(0,n.jsx)(s.code,{children:"+layout.svelte"})," 也可以从 ",(0,n.jsx)(s.code,{children:"+layout.js"})," 中的 ",(0,n.jsx)(s.code,{children:"load"})," 函数获取数据。"]}),"\n",(0,n.jsxs)(s.p,{children:["新建 ",(0,n.jsx)(s.code,{children:"src/routes/+layout.js"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:'export function load() {\n  return {\n    navs: [\n      { slug: "authors", title: "Auther List" },\n      { slug: "posts", title: "Post List" },\n    ],\n  };\n}\n'})}),"\n",(0,n.jsxs)(s.p,{children:["修改 ",(0,n.jsx)(s.code,{children:"src/routes/+layout.svelte"}),"，完整代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:"<script>\n  let { data, children } = $props();\n<\/script>\n\n<ul>\n  {#each data.navs as {slug, title}}\n    <li><a href={`/${slug}`}>{title}</a></li>\n  {/each}\n</ul>\n\n{@render children()}\n"})}),"\n",(0,n.jsx)(s.p,{children:"此时浏览器效果如下："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:p,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["需要注意的是，布局 ",(0,n.jsx)(s.code,{children:"load"})," 函数返回的数据，所有子页面也都可以使用。修改 ",(0,n.jsx)(s.code,{children:"src/routes/authors/+page.svelte"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:"<script>\n  let { data } = $props();\n  console.log(data.navs)\n<\/script>\n\n<h1>Hello Auther List!</h1>\n"})}),"\n",(0,n.jsx)(s.p,{children:"浏览器效果如下："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:x,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["你肯定会想到冲突的情况，比如布局 load 函数返回 ",(0,n.jsx)(s.code,{children:"{ a: 1, b: 2 }"}),"，页面 load 函数返回 ",(0,n.jsx)(s.code,{children:"{ b: 3, c: 4 }"}),"，最后的结果会是 ",(0,n.jsx)(s.code,{children:"{ a: 1, b: 3, c: 4 }"}),"。"]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"+layout.js"})," 也可以导出页面配置项如 ",(0,n.jsx)(s.code,{children:"prerender"}),"、",(0,n.jsx)(s.code,{children:"ssr"}),"、",(0,n.jsx)(s.code,{children:"csr"}),"，它们会作为子页面配置项的默认值。"]}),"\n",(0,n.jsxs)(s.h3,{id:"53-layoutserverjs",children:["5.3. +layout.server.js",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#53-layoutserverjs",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["如果只能在服务器上运行 ",(0,n.jsx)(s.code,{children:"load"})," 函数，将 ",(0,n.jsx)(s.code,{children:"+layout.js"}),"重命名为 ",(0,n.jsx)(s.code,{children:"+layout.server.js"}),"。"]}),"\n",(0,n.jsxs)(s.p,{children:["与 ",(0,n.jsx)(s.code,{children:"+layout.js"})," 一样，",(0,n.jsx)(s.code,{children:"+layout.server.js"})," 可以导出页面配置项如 ",(0,n.jsx)(s.code,{children:"prerender"}),"、",(0,n.jsx)(s.code,{children:"ssr"}),"、",(0,n.jsx)(s.code,{children:"csr"}),"。"]}),"\n",(0,n.jsxs)(s.h2,{id:"6-serverjs",children:["6. +server.js",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#6-serverjs",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"+server.js"})," 用于创建 API，也就是我们常说的 “Web 接口”，有时也被称为 “API 路由（API route）”、“端点（endpoint）”等，对应 Next.js 中的路由处理程序。"]}),"\n",(0,n.jsxs)(s.h3,{id:"61-基础使用",children:["6.1. 基础使用",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#61-基础使用",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"+server.js"})," 导出对应 HTTP 请求方法的函数即可创建对应的请求类型，我们以创建 GET 请求为例。新建 ",(0,n.jsx)(s.code,{children:"src/routes/api/post/+server.js"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:'export async function GET({ url }) {\n  const id = url.searchParams.get("id");\n  return new Response(id);\n}\n'})}),"\n",(0,n.jsx)(s.p,{children:"浏览器效果如下："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:j,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["函数接收一个 ",(0,n.jsx)(s.a,{href:"https://kit.svelte.dev/docs/types#public-types-requestevent",title:"https://kit.svelte.dev/docs/types#public-types-requestevent",target:"_blank",rel:"noopener noreferrer",children:"RequestEvent"}),"（从中可以解构获取 url、fetch 等）对象作为参数。该函数需要返回一个 Response 对象。"]}),"\n",(0,n.jsxs)(s.blockquote,{children:["\n",(0,n.jsx)(s.p,{children:"记住这个 RequestEvent 类型，+server.js 的 API 路由、form actions 的 +page.server.js 和 +page.server.js 和 +layout.server.js 的 load 函数传入的都是这个类型"}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["让我们看个更复杂的例子，修改 ",(0,n.jsx)(s.code,{children:"src/routes/api/post/+server.js"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:'import { error, json } from "@sveltejs/kit";\n\nexport async function GET({ url, fetch }) {\n  const id = url.searchParams.get("id");\n\n  if (!id) {\n    error(400, "没有 id 参数");\n  }\n\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/posts/${id}`\n  );\n  const post = await response.json();\n  return json(post);\n}\n'})}),"\n",(0,n.jsxs)(s.p,{children:["为了方便，",(0,n.jsx)(s.code,{children:"@sveltejs/kit"}),"提供了 ",(0,n.jsx)(s.code,{children:"error"}),"、",(0,n.jsx)(s.code,{children:"redirect"}),"、",(0,n.jsx)(s.code,{children:"json"})," 等方法。浏览器效果如下："]}),"\n",(0,n.jsxs)(s.p,{children:["当没有 ",(0,n.jsx)(s.code,{children:"id"})," 参数时："]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:o,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["当有 ",(0,n.jsx)(s.code,{children:"id"}),"参数时："]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:h,alt:""})}),"\n",(0,n.jsxs)(s.h3,{id:"62-错误处理",children:["6.2. 错误处理",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#62-错误处理",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["如果 ",(0,n.jsx)(s.code,{children:"+server.js"}),"抛出错误，无论是通过 error 函数抛出，还是意外错误，响应将会是错误的 JSON 形式或者是错误页面。具体取决于获取的形式。比如你通过 fetch 获取则返回："]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:i,alt:""})}),"\n",(0,n.jsx)(s.p,{children:"如果是浏览器直接访问："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:a,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["SvelteKit 本质是使用 ",(0,n.jsx)(s.code,{children:"Accept"})," header 进行的判断。"]}),"\n",(0,n.jsxs)(s.p,{children:["注意：当 ",(0,n.jsx)(s.code,{children:"+server.js"}),"出现错误的时候，",(0,n.jsx)(s.code,{children:"+error.svelte"})," 并不会被渲染，只会触发 fallback 错误页面，可以通过创建 ",(0,n.jsx)(s.code,{children:"src/error.html"}),"文件进行自定义："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <title>%sveltekit.error.message%</title>\n  </head>\n  <body>\n    <h1>My custom error page</h1>\n    <p>Status: %sveltekit.status%</p>\n    <p>Message: %sveltekit.error.message%</p>\n  </body>\n</html>\n'})}),"\n",(0,n.jsxs)(s.h3,{id:"63-前后端交互",children:["6.3. 前后端交互",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#63-前后端交互",children:"#"})]}),"\n",(0,n.jsx)(s.p,{children:"让我们再看个前后端交互的例子。"}),"\n",(0,n.jsxs)(s.p,{children:["新建 ",(0,n.jsx)(s.code,{children:"src/routes/add/+page.svelte"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-xml",children:"<script>\n  let a = 0;\n  let b = 0;\n  let total = 0;\n\n  async function add() {\n    const response = await fetch('/api/add', {\n      method: 'POST',\n      body: JSON.stringify({ a, b }),\n      headers: {\n        'content-type': 'application/json'\n      }\n    });\n\n    total = await response.json();\n  }\n<\/script>\n\n<input type=\"number\" bind:value={a}> +\n<input type=\"number\" bind:value={b}> =\n{total}\n\n<button on:click={add}>Calculate</button>\n"})}),"\n",(0,n.jsxs)(s.p,{children:["新建 ",(0,n.jsx)(s.code,{children:"src/routes/api/add/+server.js"}),"，代码如下："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:'import { json } from "@sveltejs/kit";\n\nexport async function POST({ request }) {\n  const { a, b } = await request.json();\n  return json(a + b);\n}\n'})}),"\n",(0,n.jsxs)(s.p,{children:["访问 ",(0,n.jsx)(s.a,{href:"http://localhost:5173/add",title:"http://localhost:5173/add",target:"_blank",rel:"noopener noreferrer",children:(0,n.jsx)(s.a,{href:"http://localhost:5173/add",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:5173/add"})}),"，浏览器效果如下："]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:t,alt:""})}),"\n",(0,n.jsxs)(s.h3,{id:"64-fallback-http-方法",children:["6.4. fallback HTTP 方法",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#64-fallback-http-方法",children:"#"})]}),"\n",(0,n.jsx)(s.p,{children:"对于未定义的 HTTP 请求方法，比如你只定义了 GET 请求，但有人以 POST 方法请求该路由，此时会报错："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:l,alt:""})}),"\n",(0,n.jsxs)(s.p,{children:["如果你想自定义这个错误，你可以导出一个名为 ",(0,n.jsx)(s.code,{children:"fallback"}),"的函数。修改 ",(0,n.jsx)(s.code,{children:"src/routes/api/post/+server.js"}),"，添加如下代码："]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-javascript",children:'import { error, json, text } from "@sveltejs/kit";\n\nexport async function fallback({ request }) {\n  return text(`I caught your ${request.method} request!`);\n}\n'})}),"\n",(0,n.jsx)(s.p,{children:"此时效果为："}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)("img",{src:d,alt:""})}),"\n",(0,n.jsxs)(s.h3,{id:"65-优先级",children:["6.5. 优先级",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#65-优先级",children:"#"})]}),"\n",(0,n.jsxs)(s.p,{children:["与 Next.js 不同，",(0,n.jsx)(s.code,{children:"+server.js"})," 可以与 ",(0,n.jsx)(s.code,{children:"+page.svelte"})," 放在同一目录下，所以同一路由既可以是页面也可以是 API 接口。为了判断是页面还是接口，SvelteKit 的规则如下："]}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"PUT"}),"、",(0,n.jsx)(s.code,{children:"PATCH"}),"、",(0,n.jsx)(s.code,{children:"DELETE"}),"、",(0,n.jsx)(s.code,{children:"OPTIONS"})," 请求方法由 ",(0,n.jsx)(s.code,{children:"+server.js"})," 处理"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"GET"}),"、",(0,n.jsx)(s.code,{children:"POST"}),"、",(0,n.jsx)(s.code,{children:"HEAD"})," 请求方法根据 ",(0,n.jsx)(s.code,{children:"accept"})," 标头是否以 ",(0,n.jsx)(s.code,{children:"text/html"}),"优先"]}),"\n"]}),"\n",(0,n.jsxs)(s.h2,{id:"7-总结",children:["7. 总结",(0,n.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#7-总结",children:"#"})]}),"\n",(0,n.jsx)(s.p,{children:"SvelteKit 采用基于文件系统的路由，有 4 大类路由约定文件："}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"+page"}),"：负责渲染页面"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"+error"}),"：负责渲染错误界面"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"+layout"}),"：负责处理布局"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"+server.js"}),"：负责处理 API 接口"]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["其中，",(0,n.jsx)(s.code,{children:"+layout"})," 和 ",(0,n.jsx)(s.code,{children:"+error"})," 文件可用于子目录及其当前所在目录。"]})]})}function N(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,c.ah)(),e.components);return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(A,{...e})}):A(e)}let P=N;N.__RSPRESS_PAGE_META={},N.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F14-SvelteKit%20%E2%9D%98%20%E8%B7%AF%E7%94%B1.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. 文件即路由",id:"2-文件即路由",depth:2},{text:"3. +page",id:"3-page",depth:2},{text:"3.1. +page.svelte",id:"31-pagesvelte",depth:3},{text:"3.2. +page.js",id:"32-pagejs",depth:3},{text:"3.3. +page.server.js",id:"33-pageserverjs",depth:3},{text:"4. +error.svelte",id:"4-errorsvelte",depth:2},{text:"5. +layout",id:"5-layout",depth:2},{text:"5.1. +layout.svelte",id:"51-layoutsvelte",depth:3},{text:"5.2. +layout.js",id:"52-layoutjs",depth:3},{text:"5.3. +layout.server.js",id:"53-layoutserverjs",depth:3},{text:"6. +server.js",id:"6-serverjs",depth:2},{text:"6.1. 基础使用",id:"61-基础使用",depth:3},{text:"6.2. 错误处理",id:"62-错误处理",depth:3},{text:"6.3. 前后端交互",id:"63-前后端交互",depth:3},{text:"6.4. fallback HTTP 方法",id:"64-fallback-http-方法",depth:3},{text:"6.5. 优先级",id:"65-优先级",depth:3},{text:"7. 总结",id:"7-总结",depth:2}],title:"14-SvelteKit ❘ 路由",headingTitle:"14-SvelteKit ❘ 路由",frontmatter:{}}}}]);