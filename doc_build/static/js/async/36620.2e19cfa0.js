"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["36620"],{8879:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var c=r(552676),s=r(740453);let l=r.p+"static/image/5f6a3f53713e7002b6ff67bfae8b5f88.8c73678d.webp",d=r.p+"static/image/4fcbd2a1d109fb691266f1a5ca753330.88339186.webp",o=r.p+"static/image/e8f968a94cbe092d05d7b7855d6a86a3.69976b26.webp";function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",pre:"pre",h2:"h2",ol:"ol",li:"li",ul:"ul",blockquote:"blockquote",img:"img",em:"em"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"9-基础篇js-对象的基本结构是什么",children:["9 基础篇｜JS 对象的基本结构是什么？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-基础篇js-对象的基本结构是什么",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 ECMAScript 规范的定义中，",(0,c.jsx)(n.code,{children:"对象代表属性的集合"}),"，可以理解为 ",(0,c.jsx)(n.code,{children:"key-value"})," 结构的数据容器。"]}),"\n",(0,c.jsxs)(n.p,{children:["从这一点上来看，其实 JavaScript 中的所有数据，除了 ",(0,c.jsx)(n.strong,{children:"null"})," 和 ",(0,c.jsx)(n.strong,{children:"undefined"})," 之外，都是对象，即使像布尔、字符串、数字和符号这类 ",(0,c.jsx)(n.code,{children:"Primitive"})," 类型，也能够直接进行属性成员读取和函数成员调用："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'true.toString() // "true"\n"Hello".length // 5\n5.03 .toFixed(1) // "5.0"\nSymbol.matchAll.toString() // "Symbol(Symbol.matchAll)"\n'})}),"\n",(0,c.jsx)(n.p,{children:"由此，关于对象结构的讨论大体上就演变成了对属性结构的讨论。"}),"\n",(0,c.jsxs)(n.h2,{id:"属性结构",children:["属性结构",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#属性结构",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"属性成员是如何在对象中存储的呢？其实并非是简单的一个 key 和 一个 value 就够了。因为属性本身还有属性，比如是否只读，是否可删除，是否可遍历。"}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"ES3"})," 时代，规范规定，一个对象属性（",(0,c.jsx)(n.code,{children:"Property"}),"）可以包含下列 3 个属性（",(0,c.jsx)(n.code,{children:"Attribute"}),"）："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"ReadOnly"}),"\n",(0,c.jsx)(n.li,{children:"DontEnum"}),"\n",(0,c.jsx)(n.li,{children:"DontDelete"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["从 ES5 开始，重新定义了属性的结构，现在它可能包含下面这 6 种属性，为了避免歧义，后面我称之为",(0,c.jsx)(n.code,{children:"属性参数"}),"："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"[[Value]]"}),"\n",(0,c.jsx)(n.li,{children:"[[Writable]]"}),"\n",(0,c.jsx)(n.li,{children:"[[Get]]"}),"\n",(0,c.jsx)(n.li,{children:"[[Set]]"}),"\n",(0,c.jsx)(n.li,{children:"[[Enumerable]]"}),"\n",(0,c.jsx)(n.li,{children:"[[Configurable]]"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这几种参数并非允许同时存在，其中 [[Enumerable]] 和 [[Configurable]] 可以一直在，而 [[Value]]+[[Writable]] 与 [[Get]]+ [[Set]] 这两对之间是互斥的。这里事实上代表了 ECMAScript 对属性成员的两种格式定义：",(0,c.jsx)(n.code,{children:"数据属性（Data Property）"}),"和",(0,c.jsx)(n.code,{children:"存取器属性（Accessor Property）"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"它们的属性差异如下："}),"\n",(0,c.jsxs)(n.p,{children:["从功能上来讲，",(0,c.jsx)(n.code,{children:"存取器属性是数据属性的超集"}),"，数据属性能实现的，存取器属性也都能实现，比如存取器属性中不定义 ",(0,c.jsx)(n.code,{children:"[[Set]]"})," 就相当于数据属性中 ",(0,c.jsx)(n.code,{children:"[[Writable]]"})," 设为 false，即只读。"]}),"\n",(0,c.jsxs)(n.p,{children:["那我们在编程过程中如何与这两种属性打交道呢？这里就涉及到属性结构的 API 表示，也就是",(0,c.jsx)(n.code,{children:"属性描述符（Property Descriptor）"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"在 TypeScript 中，属性描述符是这样定义的："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:"interface PropertyDescriptor {\n    configurable?: boolean;\n    enumerable?: boolean;\n    value?: any;\n    writable?: boolean;\n    get?(): any;\n    set?(v: any): void;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["但这并不严格，因为 ",(0,c.jsx)(n.code,{children:"value/writable"})," 与 ",(0,c.jsx)(n.code,{children:"get/set"})," 之间的互斥关系并没有表现出来。将它们混淆在一起是不被允许的。现在我们尝试取出对象中的属性描述符。"]}),"\n",(0,c.jsxs)(n.p,{children:["定义一个简单 key-value 对象：",(0,c.jsx)(n.code,{children:"{ name: 'js' }"}),"，但实际上对象存储的是 key-descriptor，我们可以用 ",(0,c.jsx)(n.code,{children:"Object.getOwnPropertyDescriptor()"})," 来取出属性描述符："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"Object.getOwnPropertyDescriptor({ name: 'js' }, 'name')\n"})}),"\n",(0,c.jsx)(n.p,{children:"在 Chrome 下打印出来的是："}),"\n",(0,c.jsxs)(n.p,{children:["说明这是一个",(0,c.jsx)(n.code,{children:"数据属性"}),"。以大括号声明的对象，其属性都是数据形式的，如果想定义成",(0,c.jsx)(n.code,{children:"存取器属性"}),"，那么就需要使用到 ",(0,c.jsx)(n.code,{children:"Object.defineProperty()"})," 或者 ",(0,c.jsx)(n.code,{children:"Object.defineProperties()"})," 了："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var obj = {};\n\nlet _internal_name = null;\n\nObject.defineProperty(obj, 'name', {\n    set(n) {\n        _internal_name = n;\n    },\n    get() {\n        return _internal_name;\n    },\n    configurable: true,\n    enumerable: true,\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果在 ",(0,c.jsx)(n.code,{children:"class"})," 环境下，也可以使用 ",(0,c.jsx)(n.code,{children:"setter/getter"})," 函数："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class Foo {\n    #name = null;\n    get name() {\n        return this.#name;\n    }\n    set name(n) {\n        this.#name = n;\n    }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"我们知道了如何把属性定义成哪种类型，那么，日常开发中我们应该如何选择呢？另外属性描述符中的参数都应该如何取值呢？"}),"\n",(0,c.jsxs)(n.h2,{id:"如何使用属性描述符",children:["如何使用属性描述符？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何使用属性描述符",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"如果你的属性希望在被访问的时候，动态输出取值，那么毫无疑问，存取器属性是唯一选项。除此之外，两者几乎一致，包括在其余参数的定义上。"}),"\n",(0,c.jsxs)(n.p,{children:["我们先来看看两者共用的参数 ",(0,c.jsx)(n.code,{children:"enumerable"})," 和 ",(0,c.jsx)(n.code,{children:"configurable"})," 都是做什么的吧。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"enumerable"})," 顾名思义，代表是否可枚举，也就是在 ",(0,c.jsx)(n.code,{children:"for...in"})," 的时候能否被遍历到。在上一章节，我们讲过 ",(0,c.jsx)(n.strong,{children:"constructor"})," 在构造函数的 ",(0,c.jsx)(n.code,{children:"prototype"})," 中就定义为 ",(0,c.jsx)(n.code,{children:"enumerable=false"}),"，因而不可遍历出来。"]}),"\n",(0,c.jsx)(n.p,{children:"还有哪些耳熟能详的属性是不可遍历的呢？我举几个例子："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["数组的所有方法，比如 concat、filter、map、reduce，在 ",(0,c.jsx)(n.code,{children:"for...in"})," 时都不可见，这个我们在数组那一章提到过；"]}),"\n",(0,c.jsxs)(n.li,{children:["字符串的 length 属性，在 ",(0,c.jsx)(n.code,{children:"for...in"})," 时也不可见；"]}),"\n",(0,c.jsx)(n.li,{children:"数字对象的所有方法，比如 toPrecision、toFixed、toExponential 等。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"直接赋值定义给对象的属性，或者类的非函数成员，默认都是可枚举的，比如下面中的 foo、bar 和 baz："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const obj = { foo: 1 };\nobj.bar = 2;\n\nclass Foo {\n    baz = 2\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果使用 ",(0,c.jsx)(n.code,{children:"Object.defineProperty()"})," 或者 ",(0,c.jsx)(n.code,{children:"Object.defineProperties()"}),"，那么需要确保明确设置 ",(0,c.jsx)(n.code,{children:"enumerable=true"})," 才能开启可枚举性，否则默认是 false："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const obj = {};\n\nObject.defineProperty(obj, 'name', {\n    value: 'foo'\n});\n\nObject.getOwnPropertyDescriptor(obj, 'name').enumerable; // false\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"configurable"})," 参数代表是否",(0,c.jsx)(n.code,{children:"可配置"}),"，这背后代表的行为要更复杂，按照 ECMAScript 定义，如果其为 false，那么："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"不允许删除此属性；"}),"\n",(0,c.jsx)(n.li,{children:"不允许在数据属性和存取器属性之间变换；"}),"\n",(0,c.jsxs)(n.li,{children:["不允许修改描述符的其他参数（但不包括修改 ",(0,c.jsx)(n.code,{children:"value"}),"，以及把 ",(0,c.jsx)(n.code,{children:"writable"})," 设为 false）：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"不允许修改 enumerable 的值；"}),"\n",(0,c.jsx)(n.li,{children:"不允许修改 set/get 的值；"}),"\n",(0,c.jsx)(n.li,{children:"不允许将 writable 从 false 改为 true。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["其他都还容易记得住，也能理解允许对 ",(0,c.jsx)(n.code,{children:"value"})," 的修改，但为什么还能允许把 ",(0,c.jsx)(n.code,{children:"writable"})," 从 true 改成 false 呢？很遗憾，我没有在 ECMAScript 的规范中找到对这个策略的解释。我们不妨粗浅地这样理解：",(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.code,{children:"configurable"})," 并不是为了完全锁定对象，要不然也不会允许对 ",(0,c.jsx)(n.code,{children:"value"})," 的修改，它只是想保证对象结构和表达的稳定性，那么把一个对象从可写改成只读，似乎并不会影响这种稳定性"]}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们验证一下违反 ",(0,c.jsx)(n.code,{children:"configurable"})," 规则的案例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'const obj = {};\n\nObject.defineProperties(obj, {\n  // name 为数据属性\n  name: {\n    value: "foo",\n    writable: false,\n    enumerable: true,\n    configurable: false,\n  },\n  // age 为存取器属性\n  age: {\n    get() {},\n    set() {},\n    enumerable: true,\n    configurable: false,\n  },\n});\n\n// 删除属性\ndelete obj.name; // ❌ Uncaught TypeError: Cannot delete property \'name\' of #<Object>\n\n// 变换属性结构\nObject.defineProperty(obj, "name", { // ❌ Uncaught TypeError: Cannot redefine property: name\n  get() {\n    return "foo";\n  },\n  enumerable: true,\n  configurable: false,\n});\n\n// 修改 enumerable\nObject.defineProperty(obj, "name", { // ❌ Uncaught TypeError: Cannot redefine property: name\n  enumerable: false,\n});\n\n// 修改 set/set\nObject.defineProperty(obj, "age", { // ❌ Uncaught TypeError: Cannot redefine property: age\n  set() {},\n  get() {},\n});\n\n// 修改 writable=true\nObject.defineProperty(obj, "name", { // ❌ Uncaught TypeError: Cannot redefine property: name\n  writable: true,\n});\n'})}),"\n",(0,c.jsxs)(n.p,{children:["以上这些错误，都会导致程序中断。因此严格来讲，我们如果想保证程序的绝对健壮，在操作陌生对象时，一是用 ",(0,c.jsx)(n.code,{children:"try...catch"})," 来包裹代码块，二是在修改属性之前探测它的属性描述符，即便是 ",(0,c.jsx)(n.code,{children:'obj.name = "bar"'})," 这样简单的赋值语句也是如此。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["\uD83D\uDCA1 大家应该能看到，修改一个现有的属性，",(0,c.jsx)(n.code,{children:"defineProperty/defineProperties"})," 并不需要列举属性描述符的全部参数，而只需要被修改的那几个就可以了。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["定义新的属性时，如果不指定，",(0,c.jsx)(n.code,{children:"configurable"})," 默认也是 false。"]}),"\n",(0,c.jsxs)(n.p,{children:["以上我们熟悉了属性描述符的两个公共参数，也是最关键的两个，",(0,c.jsx)(n.code,{children:"enumerable"})," 和 ",(0,c.jsx)(n.code,{children:"configurable"}),"。对于两种不同的属性类型来说，它们都还各有两个额外的参数。"]}),"\n",(0,c.jsxs)(n.p,{children:["数据属性的 ",(0,c.jsx)(n.code,{children:"writable"})," 会阻止对 ",(0,c.jsx)(n.code,{children:"value"})," 的修改，注意，即便是修改前后值一样也不行，",(0,c.jsx)(n.code,{children:"writable"})," 阻止的是行为，而不管结果。但是 ",(0,c.jsx)(n.code,{children:"value"})," 依然有可能通过 ",(0,c.jsx)(n.code,{children:"defineProperty/defineProperties"})," 来改变取值，这超出了 ",(0,c.jsx)(n.code,{children:"writable"})," 的控制范围："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const obj = {};\n\nObject.defineProperty(obj, 'name', {\n    value: 'foo',\n    writable: false,\n    enumerable: true,\n    configurable: true,\n});\n\n// 重新定义 value\nObject.defineProperty(obj, 'name', {\n    value: 'bar',\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果不声明，新属性的 ",(0,c.jsx)(n.code,{children:"writable"})," 默认也是 false。"]}),"\n",(0,c.jsxs)(n.p,{children:["存取器属性中的 ",(0,c.jsx)(n.code,{children:"set/get"})," 与 ",(0,c.jsx)(n.strong,{children:"Java Bean"})," 的思想是一致的。这个能力允许我们能拦截对属性的赋值和读取操作，熟悉的同学应该知道，Vue 2 正是利用这一特性来监视数据的变更，进而驱动视图的。"]}),"\n",(0,c.jsxs)(n.p,{children:["set 和 get 可以不成对出现，如果缺失了 set，那么该属性就是只读的；如果缺失了 get，那么该属性就是只写的；如果都不存在，那么该属性会被当作一个 ",(0,c.jsx)(n.code,{children:"value=undefined"})," 的数据属性。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["\uD83D\uDCA1 ",(0,c.jsx)(n.code,{children:"set/get"})," 必须是函数类型，即便是异步函数、生成器函数也可以，否则会抛出错误。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["两种属性结构我们就讨论到这。但是对于一个对象来说，除了这些后期定义的属性之外，还有很多内部属性发挥着至关重要的作用，比如前面我们在函数那一讲当中提到 ",(0,c.jsx)(n.code,{children:"[[Call]]"})," 和 ",(0,c.jsx)(n.code,{children:"[[Construct]]"})," 都属于对象内部可能存在的属性。除此之外， ECMAScript 还定义了如下这些内部属性："]}),"\n",(0,c.jsxs)(n.p,{children:["有经验的同学可能已经发现了，里面的函数都有对应的 API 可用，比如其中的 ",(0,c.jsx)(n.code,{children:"[[DefineOwnProperty]]"})," 其实就对应着 ",(0,c.jsx)(n.code,{children:"Object.defineProperty"}),"。确实如此，当我们调用静态函数 ",(0,c.jsx)(n.code,{children:"Object.defineProperty"})," 的时候，本质上是在对象身上调用其 ",(0,c.jsx)(n.code,{children:"[[DefineOwnProperty]]"})," 内部函数，其他函数大体也是如此。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们要特别关注的是最后那个叫做 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"})," 的属性，这不是一个函数，在规范上是叫做 ",(0,c.jsx)(n.code,{children:"slot"}),"，它是实现原型链、进而实现继承的根本。"]}),"\n",(0,c.jsxs)(n.h2,{id:"原型链与对象继承",children:["原型链与对象继承",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链与对象继承",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["当我们在 Chrome 的控制台上打印一个空对象时，就能看到 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"}),"，展开的话，可见很多现成的属性："]}),"\n",(0,c.jsxs)(n.p,{children:["因此，这个 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"})," 属性一定是指向某个对象的，那么是哪个对象呢？"]}),"\n",(0,c.jsxs)(n.p,{children:["是 ",(0,c.jsx)(n.code,{children:"Object.prototype"}),"。我们在前面函数那一讲中提到过，作为构造函数，都会有一个 ",(0,c.jsx)(n.code,{children:"prototype"})," 属性。 ",(0,c.jsx)(n.code,{children:"Object"})," 也是构造函数，那么它有一个 ",(0,c.jsx)(n.code,{children:"prototype"})," 就合情合理了。这是一个由 JavaScript 引擎初始化的一个预置对象。"]}),"\n",(0,c.jsxs)(n.p,{children:["要获取 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"})," 属性，可以使用 ",(0,c.jsx)(n.code,{children:"Object.getPrototypeOf()"})," 函数："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"Object.getPrototypeOf({}) === Object.prototype // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面这一行代码就能说明了这个属性的指向关系。除了 ",(0,c.jsx)(n.code,{children:"Object.getPrototypeOf()"})," 外，还能看到一个遗留的属性 ",(0,c.jsx)(n.code,{children:"__proto__"})," 也能达到同样的效果："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"({}).__proto__ === Object.prototype // true\n"})}),"\n",(0,c.jsx)(n.p,{children:"不过不建议用在线上的生产代码中，日常用来测试/调试还是非常方便的。"}),"\n",(0,c.jsxs)(n.p,{children:["言归正传，",(0,c.jsx)(n.code,{children:"[[Prototype]]"})," 有什么用呢？关键知识来了，",(0,c.jsxs)(n.strong,{children:["当我们在一个对象上访问属性的时候，如果本身没有这个属性，那么就会尝试在其 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"})," 对象上寻找，如果还是没找到，就继续向上查找 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"}),"，一直会找到 ",(0,c.jsx)(n.code,{children:"Object.prototype"})," 为止，因为它的 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"})," 等于 null"]}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["一个对象的 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"})," 属性称之为它的原型对象，因此，这种向上遍历查找关系就形成了原型链："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["我们来验证一下，首先有一个对象 ",(0,c.jsx)(n.code,{children:"{}"}),"，没有定义任何属性，但是依然可以调用 ",(0,c.jsx)(n.code,{children:"toString()"})," 函数："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'({}).toString() // "[object Object]"\n'})}),"\n",(0,c.jsxs)(n.p,{children:["这个 ",(0,c.jsx)(n.code,{children:"toString()"})," 哪里来的呢？虽然对象本身没有，但是它的原型，也就是 ",(0,c.jsx)(n.code,{children:"Object.prototype"})," 却有，因此几乎任意对象都可以调用 ",(0,c.jsx)(n.code,{children:"toString()"}),"，而不必单独定义它。"]}),"\n",(0,c.jsx)(n.p,{children:"我们再尝试一个更复杂的例子："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'var a = { name: "a", age: 10, gender: "female" };\nvar b = {\n  name: "b",\n  age: 15,\n  gender: "male",\n  getGender() {\n    return this.gender;\n  },\n};\nvar c = {\n  name: "c",\n  age: 20,\n  getAge() {\n    return this.age;\n  },\n};\nvar d = {\n  getName() {\n    return this.name;\n  },\n};\n\n// a => b => c => d => null\na.__proto__ = b;\nb.__proto__ = c;\nc.__proto__ = d;\nd.__proto__ = null;\n\nconsole.log(a.getName(), a.getAge(), a.getGender()); // a 10 female\nconsole.log(b.getName(), b.getAge(), b.getGender()); // b 15 male\nconsole.log(c.getName(), c.getAge()); // c 20\n'})}),"\n",(0,c.jsxs)(n.p,{children:["我们手动实现了一个原型链，a 的原型是 b， b 的原型是 c， c 的原型是 d，而 d 的原型是 null。根据原型链的原理，上游的属性可以被下游访问得到，因此在 d 中定义的 ",(0,c.jsx)(n.strong,{children:"getName"})," 可以被 a、b、c 访问到，c 中定义的 ",(0,c.jsx)(n.strong,{children:"getAge"})," 可以被 a、b 访问到，b 中定义的 ",(0,c.jsx)(n.strong,{children:"getGender"})," 可以被 a 访问到。而由于 d 的原型是 null，没有链接到 ",(0,c.jsx)(n.code,{children:"Object.prototype"}),"，因此所有对象都访问不到 ",(0,c.jsx)(n.code,{children:"toString()"}),"，原理图示如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["\uD83D\uDCA1 上面代码中的 ",(0,c.jsx)(n.code,{children:"__proto__"})," 仅为测试代码方便之用，你应该用 ",(0,c.jsx)(n.code,{children:"Object.setPrototypeOf"}),"，它映射了内部属性中的 ",(0,c.jsx)(n.code,{children:"[[SetPrototypeOf]]"}),"。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["一般来说，当我们用构造函数来创建对象的时候，对象的原型就会自动指向构造函数的 ",(0,c.jsx)(n.code,{children:"prototype"})," 属性，即："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function Dog() {}\n\nnew Dog().__proto__ === Dog.prototype // true\n"})}),"\n",(0,c.jsx)(n.p,{children:"这个类比较具象，大家应该容易理解，我换一个绕一点的："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function foo() {}\nfoo.__proto__ // ?\n"})}),"\n",(0,c.jsxs)(n.p,{children:["foo 的原型是谁呢？我们知道，函数也是对象，它是由 ",(0,c.jsx)(n.code,{children:"Function"})," 隐式构造的，因此 ",(0,c.jsx)(n.em,{children:"foo.__proto__"})," 自然等于 ",(0,c.jsx)(n.code,{children:"Function.prototype"}),"。这也是预定义的一个对象，如果我们把它打印出来，发现它也是一个函数："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'typeof Function.prototype // "function"\n'})}),"\n",(0,c.jsxs)(n.p,{children:["根据 ECMAScript 的定义，这个特殊函数不能作为构造函数（因此没有 ",(0,c.jsx)(n.code,{children:"prototype"})," 属性），始终返回 undefined，并且其原型是 ",(0,c.jsx)(n.code,{children:"Object.prototype"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"Function.prototype.__proto__ === Object.prototype // true\n"})}),"\n",(0,c.jsx)(n.p,{children:"现在再来看这张业界比较有名的图，是不是就会更容易理解了呢？"}),"\n",(0,c.jsxs)(n.p,{children:["对象除了用构造函数创建以外，还可以用大括号以字面量的方式创建，并且能同时设置原型、定义属性，这需要用到 ",(0,c.jsx)(n.code,{children:"Object.create()"})," 函数："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var proto = {\n    getName() {\n        return this.name;\n    }\n};\n\nvar k = Object.create(proto, {\n    name: {\n        value: 'foo',\n        writable: true,\n        configurable: true,\n        enumerable: true,\n    }\n});\n\nk.getName(); // 'foo'\nk.__proto__ === proto; // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果只传入 null，那么就是在创建一个真正的空对象，连原型都不存在，这时候用 ",(0,c.jsx)(n.code,{children:"for...in"})," 遍历的话， 什么都遍历不到，比较适合用于对遍历敏感的场合："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"for (let key in Object.create(null)) {\n    console.log(key);\n}\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"对象的结构看着比较复杂，但实际上说起来也比较简单，它可以分成两个部分。"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["一部分是自定义的属性，这部分属性以",(0,c.jsx)(n.code,{children:"属性描述符"}),"的形式存在，可以是",(0,c.jsx)(n.code,{children:"数据属性"}),"也可以是",(0,c.jsx)(n.code,{children:"存取器属性"}),"。无论哪种，最终行为都会受到公共参数 ",(0,c.jsx)(n.code,{children:"enumerable"})," 和 ",(0,c.jsx)(n.code,{children:"configurable"})," 的控制。"]}),"\n",(0,c.jsxs)(n.li,{children:["另一部分是内部的属性，特别需要关注是 ",(0,c.jsx)(n.code,{children:"[[Prototype]]"}),"，通过它，不同对象可以组成了一个单向的",(0,c.jsx)(n.code,{children:"原型链"}),"，属性的访问顺着原型链向上查找，一直到 ",(0,c.jsx)(n.code,{children:"Object.prototype"})," 为止。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["创建指定的原型链关系，测试/调试环境可以用 ",(0,c.jsx)(n.code,{children:"__proto__"}),"，生产环境应该用 ",(0,c.jsx)(n.code,{children:"Object.setPrototypeOf"})," 和 ",(0,c.jsx)(n.code,{children:"Object.create"}),"。但注意",(0,c.jsx)(n.code,{children:"原型链不可以形成一个环"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["建议大家配合着我们之前学习过的函数知识，把 ",(0,c.jsx)(n.code,{children:"Object"}),"、",(0,c.jsx)(n.code,{children:"Function"})," 和自定义构造函数以及它的实例之间的原型关系搞清楚，谁的原型是谁，谁的 ",(0,c.jsx)(n.code,{children:"constructor"})," 又是谁。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后留一个小作业给大家：试想，不使用 class 语法，如何定义一个",(0,c.jsx)(n.code,{children:"类数组"}),"对象，可以共享所有数组的函数？"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(i,{...e})}):i(e)}let j=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F9%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9CJS%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F.md"]={toc:[{text:"属性结构",id:"属性结构",depth:2},{text:"如何使用属性描述符？",id:"如何使用属性描述符",depth:2},{text:"原型链与对象继承",id:"原型链与对象继承",depth:2},{text:"小结",id:"小结",depth:2}],title:"9 基础篇｜JS 对象的基本结构是什么？",headingTitle:"9 基础篇｜JS 对象的基本结构是什么？",frontmatter:{}}}}]);