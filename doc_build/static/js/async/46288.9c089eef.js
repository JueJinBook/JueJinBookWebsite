"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["46288"],{675943:function(e,n,r){r.r(n),r.d(n,{default:()=>f});var s=r(552676),t=r(740453);let c=r.p+"static/image/990590f6a534ed789b652edc39145ac3.07a7b881.webp",i=r.p+"static/image/95923fcd740a371d8bf514a586aed380.6d6a5d33.webp",d=r.p+"static/image/40270eb85791ff8b11fd03eb713dd2e8.1212a5df.webp",o=r.p+"static/image/aa97efd04bc363852576a99a199bd498.2433d8c0.webp",a=r.p+"static/image/73465794939392bbc2beb0745b165407.76268348.webp";function l(e){let n=Object.assign({p:"p",strong:"strong",img:"img",h1:"h1",a:"a",pre:"pre",code:"code",blockquote:"blockquote",h2:"h2",ol:"ol",li:"li"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Ref 是我们工作中常用的 API，我们通常用它获取真实 DOM 元素和获取类组件实例层面上，但 Ref 本身还存在",(0,s.jsx)(n.strong,{children:"进阶的用法"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"通过本章的阅读，你将获得 ref 相关的操作，彻底搞懂 useRef。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"解刨Ref.png"})}),"\n",(0,s.jsxs)(n.h1,{id:"13源码篇全方面剖析-ref",children:["13.源码篇｜全方面剖析 Ref",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13源码篇全方面剖析-ref",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["关于 Ref，React 主要提供 ",(0,s.jsx)(n.strong,{children:"React.createRef（类组件）"})," 和 ",(0,s.jsx)(n.strong,{children:"React.useRef（函数组件）"})," 两种方式进行创建，会生成一个 ref 对象，结构为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n    current: null; \n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"current 为 ref 对象获取的实际内容，可以是 DOM 元素、组件实例、其他元素。"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"具体使用："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { Component, createRef, useEffect, useRef } from "react";\n\n// createRef: 类组件\nclass Index extends Component<any, any> {\n  currentRef: any;\n  constructor(props: any) {\n    super(props);\n    this.currentRef = createRef();\n  }\n\n  componentDidMount() {\n    console.log(this.currentRef);\n  }\n\n  render() {\n    return <div ref={this.currentRef}>class 中获取 Ref 的实例</div>;\n  }\n}\n\n// useRef：函数组件\nconst Index = () => {\n  const currentRef = useRef<any>();\n\n  useEffect(() => {\n    console.log(currentRef);\n  }, []);\n\n  return <div ref={currentRef}>函数中获取 Ref 的实例</div>;\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"打印结果"}),"："]}),"\n",(0,s.jsx)(n.p,{children:"我们发现类组件中的 createRef 和函数组件中的 useRef 用法基本相同。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"问：DOM 元素的获取一定要通过 ref 对象获取吗？"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["答：不一定，React 本身就提供多种方法去获取，从 ts 的类型去看看：\n",(0,s.jsx)("img",{src:o,alt:"image.png"})]}),"\n",(0,s.jsxs)(n.p,{children:["可以看到除了 ",(0,s.jsx)(n.strong,{children:"ref 对象"}),"的方式，还提供",(0,s.jsxs)(n.strong,{children:["字符串（只能用在 Class 中）",(0,s.jsx)(n.strong,{children:"和"}),"回调函数"]}),"的情况。但随着时间的发展，字符串的方式逐渐被淘汰。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"了解 createRef 和 useRef 的用法后，再来看看两者在源码中的逻辑是怎样的。"}),"\n",(0,s.jsxs)(n.h2,{id:"createref-源码",children:["createRef 源码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#createref-源码",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["文件位置：",(0,s.jsx)(n.code,{children:"packages/react/src/ReactCreateRef.js"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export function createRef(): RefObject {\n  const refObject = {\n    current: null,\n  };\n  return refObject;\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"useref-源码",children:["useRef 源码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useref-源码",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["useRef 的源码分为 ",(0,s.jsx)(n.code,{children:"mountRef（初始化）"})," 和 ",(0,s.jsx)(n.code,{children:"updateRef(更新）"}),"阶段。"]}),"\n",(0,s.jsxs)(n.p,{children:["文件位置：",(0,s.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberHooks"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 初始化\nfunction mountRef<T>(initialValue: T): {current: T} {\n  const hook = mountWorkInProgressHook();\n  const ref = {current: initialValue};\n  hook.memoizedState = ref;\n  return ref;\n}\n\n// 更新\nfunction updateRef<T>(initialValue: T): {current: T} {\n  const hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["从源码的角度来看，createRef 和 useRef 的逻辑非常简单，两者都是创建了一个对象，对象上的 ",(0,s.jsx)(n.code,{children:"currrent"})," 属性，用来保存",(0,s.jsx)(n.strong,{children:"通过 ref 属性获取的 DOM 元素、组件实例、数据等"}),"，以便后续使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["但两者的",(0,s.jsx)(n.strong,{children:"保存位置不同"}),"，createRef 保存的数据通过实例 ",(0,s.jsx)(n.code,{children:"instance"})," 维护，而 useRef 通过 ",(0,s.jsx)(n.code,{children:"memoizedState"})," 维护。"]}),"\n",(0,s.jsx)(n.p,{children:"接下来着重看看 useRef 诞生的原因，探寻其中的奥秘。"}),"\n",(0,s.jsxs)(n.h1,{id:"useref-的诞生",children:["useRef 的诞生",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useref-的诞生",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在上文中，我们发现 ，createRef 和 useRef 的底层逻辑实际上是相差无几的。那么就产生了这样一个疑问：为什么不能直接在函数组件中使用 createRef 呢？而是会多出一个新的 API 呢？"}),"\n",(0,s.jsx)(n.p,{children:"假设我们在函数组件中使用 createRef，来看看它与 useRef 具体有什么不同："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { useState, useRef, createRef } from "react";\nimport { Button } from "antd";\n\nconst Index = () => {\n  const [count, useCount] = useState(0);\n\n  const ref = useRef(0);\n  const cRef = createRef(0);\n\n  if (!ref.current) {\n    ref.current = count;\n  }\n\n  if (!cRef.current) {\n    cRef.current = count;\n  }\n\n  return (\n    <>\n      <div>数字：{count}</div>\n      <div>useRef 包裹的数字： {ref.current}</div>\n      <div>createRef 包裹的数字： {cRef.current}</div>\n      <Button type="primary" onClick={() => useCount((v) => v + 1)}>\n        点击加1\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(n.p,{children:"效果："}),"\n",(0,s.jsxs)(n.p,{children:["从案例来看，useRef 和 createRef 创建的 ref 对象只有在没有值的情况下，才会被 count 的赋值，但在实际效果中，每次点击按钮，createRef 创建的 ",(0,s.jsx)(n.code,{children:"cRef"})," 仍然在变化，这就说明每次渲染时，cRef 的值始终",(0,s.jsx)(n.strong,{children:"不存在"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["这是因为类组件和函数组件的",(0,s.jsx)(n.strong,{children:"机制不同"}),"，通俗来讲就是",(0,s.jsx)(n.strong,{children:"生命周期"}),"的问题。"]}),"\n",(0,s.jsxs)(n.p,{children:["在类组件中是将生命周期分离出来的，有明确的 ",(0,s.jsx)(n.code,{children:"componentDidMount"}),"、",(0,s.jsx)(n.code,{children:"componentDidUpdate"})," 等 API，createRef 在初始化的过程中被初始化，在更新过程中并不会初始化类组件的实例，所以在非手动更改的情况下，createRef 的值并不会改变。"]}),"\n",(0,s.jsxs)(n.p,{children:["但函数组件则不同，虽然被说是组件，但其行为仍是函数，在",(0,s.jsx)(n.strong,{children:"渲染和更新时，仍然会重新执行、重新创建、对所有的变量和表达式进行初始化"}),"。因此，createRef 每次都会被执行，对应的值也为 null，每次都会被重新赋值。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了解决这个问题，useRef 诞生了。通过与函数组件对应的 ",(0,s.jsx)(n.code,{children:"Fiber"})," 建立关联，将 useRef 创建的 ref 对象挂载到对应的 ",(0,s.jsx)(n.code,{children:"Fiber"}),"上，",(0,s.jsx)(n.strong,{children:"只要组件不被销毁，对应 Fiber 上的对象就一直存在"}),"，无论函数组件如何重新执行，都能拿到对应的 ref 值，这也是函数组件能拥有自己状态的根本原因。"]}),"\n",(0,s.jsxs)(n.p,{children:["经过上面的总结，我们得出 ",(0,s.jsx)(n.strong,{children:"createRef 只能运用在类组件，useRef 只能运用在函数组件上"}),"。"]}),"\n",(0,s.jsxs)(n.h1,{id:"useref-高阶用法",children:["useRef 高阶用法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useref-高阶用法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过上面介绍了 ref 的基本用法，createRef 在函数组件中出现的问题，所衍生出 useRef。除此之外，在一些特定的场合中需要 useRef 配合完成，使项目中写的组件更加灵活多变。"}),"\n",(0,s.jsxs)(n.h2,{id:"缓存数据对比-usestate",children:["缓存数据：对比 useState",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存数据对比-usestate",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["useRef 除了获取 DOM 元素之外，还可以接受一些其他元素，用来保存数据，比如之前讲解的 ",(0,s.jsx)(n.code,{children:"useLatest"})," 就是活用了这一特性。"]}),"\n",(0,s.jsx)(n.p,{children:"既然 useRef 可以缓存数据，而 useState 的作用也是缓存数据，那么可以用 useRef 来替换 useState 吗？两者都可以缓存数据，那么又有何区别呢？"}),"\n",(0,s.jsx)(n.p,{children:"先做一个计数器的功能，来对比下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { useState, useRef } from "react";\nimport { Button } from "antd";\n\nconst Index: React.FC<any> = () => {\n  const [count, setCount] = useState(0);\n  const countRef = useRef<number>(0);\n\n  return (\n    <>\n      <div>大家好，我是小杜杜，一起玩转Hooks吧！</div>\n      <div>useState的count：{count}</div>\n      <Button type="primary" onClick={() => setCount((v) => v + 1)}>\n        useState点击\n      </Button>\n      <div>ref的count：{countRef.current}</div>\n      <Button\n        type="primary"\n        onClick={() => (countRef.current = countRef.current + 1)}\n      >\n        useRef点击\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(n.p,{children:"效果："}),"\n",(0,s.jsx)(n.p,{children:"我们发现，useState 的 count 会随着点击按钮的变化而变化，useRef 的 count 并不会变化，但再次点击 useState 时，useRef 的 count 产生了变化。"}),"\n",(0,s.jsxs)(n.p,{children:["这说明 useRef 点击时，",(0,s.jsx)(n.strong,{children:"值发生了改变，但视图未发生改变"}),"，换句话说 ",(0,s.jsx)(n.strong,{children:"useRef 并没有能力去触发 render，而 useState 能触发 render"}),"，这是两者最主要的区别。"]}),"\n",(0,s.jsxs)(n.p,{children:["其次，在更改值的时候，useState 是通过 ",(0,s.jsx)(n.code,{children:"setCount"})," 去改变的，这也就说明 ",(0,s.jsx)(n.code,{children:"count"})," 本身是",(0,s.jsx)(n.strong,{children:"不可改变的"}),"，而 ",(0,s.jsx)(n.code,{children:"useRef"})," 是直接更改值，属于",(0,s.jsx)(n.strong,{children:"可变值"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么是否可变，是否影响 React 的渲染呢？答案是肯定的，因为在渲染阶段时，React 并没有办法发现 ",(0,s.jsx)(n.code,{children:"ref.current"})," 是何时发生改变的，这样在读取值的时候就会变得难以预测，所以在渲染阶段时，尽量使用 state。"]}),"\n",(0,s.jsxs)(n.p,{children:["总的来说，useState 适用于",(0,s.jsx)(n.strong,{children:"自身组件的状态值"}),"，而 useRef 更适合存储",(0,s.jsx)(n.strong,{children:"外部通信的值"}),"，并且这些值不会影响 ",(0,s.jsx)(n.code,{children:"render"})," 的逻辑。比如在 ",(0,s.jsx)(n.code,{children:"setTimeout"}),"、",(0,s.jsx)(n.code,{children:"setInterval"})," 用到的值。"]}),"\n",(0,s.jsxs)(n.h2,{id:"跨层级获取实例与通信",children:["跨层级获取实例与通信",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#跨层级获取实例与通信",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以通过 ",(0,s.jsx)(n.code,{children:"forwardRef"})," 转发 ref 来获取子组件的实例，获取一些方法、值，并且可以自定义设置 ref 的值。如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { useRef, useEffect, Component, forwardRef } from "react";\nclass Son extends Component {\n  render() {\n    return <div>我是孙组件</div>;\n  }\n}\n\nclass Child extends Component<any, any> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      count: 0,\n    };\n  }\n\n  div: any = null;\n  son: any = null;\n  componentDidMount() {\n    this.props.forwardRef.current = {\n      div: this.div, // 子组件的div\n      child: this, // 子组件的实例\n      son: this.son, // 孙组件的实例\n    };\n  }\n\n  render() {\n    return (\n      <>\n        <div ref={(node) => (this.div = node)}>我是子组件</div>\n        <Son ref={(node) => (this.son = node)} />\n      </>\n    );\n  }\n}\n\nconst ForwardChild = forwardRef((props, ref) => (\n  <Child {...props} forwardRef={ref} />\n));\n\nconst Index = () => {\n  const ref = useRef(null);\n\n  useEffect(() => {\n    console.log(ref.current);\n  }, []);\n\n  return (\n    <>\n      <div>大家好，我是小杜杜，一起玩转Hooks吧！</div>\n      <ForwardChild ref={ref} />\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(n.p,{children:"打印下 Index 中的 ref.current："}),"\n",(0,s.jsxs)(n.p,{children:["在此场景中，在 Index 中获取到子组件 Child 的信息，包括 ",(0,s.jsx)(n.code,{children:"props"}),"、",(0,s.jsx)(n.code,{children:"state"})," 等信息，同时也可以获取到孙组件 Son 的信息。当我们拿到对应的实例后，就可以做一些特定的事情，比如",(0,s.jsx)(n.strong,{children:"跨层级通信"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注意：这里使用的 Child 和 Son 是 Class 组件，不能为函数式组件，原因是函数式组件并没有",(0,s.jsx)(n.strong,{children:"实例"}),"，如果想要获取函数式组件的方法，可使用 ",(0,s.jsx)(n.code,{children:"useImperativeHandle"}),"，具体的使用在第三章中介绍过，就不做过多的赘述。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h1,{id:"探索-ref-的奥秘",children:["探索 Ref 的奥秘",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#探索-ref-的奥秘",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先，我们要特别明确一点：",(0,s.jsx)(n.strong,{children:"createRef 和 useRef 属于对 Ref 属性的创建和使用，而非是 Ref 属性。"})," 换言之，ref 属性和 ",(0,s.jsx)(n.strong,{children:"useRef"})," 是两个完全不同的东西，我们不能混为一谈。"]}),"\n",(0,s.jsx)(n.p,{children:"当然，为了更好地掌握 useRef，我们应该探索 Ref 属性，在 React 中是如何处理 ref 的，以此彻底掌握相关的 Ref 问题。"}),"\n",(0,s.jsxs)(n.p,{children:["关于 ref 属性，大体分为四段操作，分别是：",(0,s.jsx)(n.strong,{children:"置空操作"}),"、",(0,s.jsx)(n.strong,{children:"标记操作"}),"、",(0,s.jsx)(n.strong,{children:"更新操作"}),"、",(0,s.jsx)(n.strong,{children:"卸载操作"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"在上文中提及到 ref 共用三种方式来获取，其中通过回调函数的情况有一个特殊的现象，我们先来看看："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { Button } from "antd";\nimport { useState } from "react";\n\nconst Index = () => {\n  const [_, setCount] = useState<number>(0);\n\n  return (\n    <>\n      <div\n        ref={(node) => {\n          console.log(node);\n        }}\n      >\n        大家好，我是小杜杜，一起玩转Hooks吧！\n      </div>\n      <Button type="primary" onClick={() => setCount((v) => v + 1)}>\n        点击\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsx)(n.p,{children:"我们发现点击按钮，刷新实图的时候，node 会获取两次，且第一次为 null，这是为什么呢？"}),"\n",(0,s.jsx)(n.p,{children:"从函数式组件的时机来看，其根本还是因为生命周期的问题，我们看下 Hooks 的生命周期图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到，在 ",(0,s.jsx)(n.strong,{children:"Render phase（渲染阶段）"})," 是不允许做副作用，原因是在此阶段可能会被 React 引擎随时取消或重新渲染。"]}),"\n",(0,s.jsxs)(n.p,{children:["而修改 Ref 属于副作用操作，因此不能在 ",(0,s.jsx)(n.code,{children:"Render"})," 阶段，而是在 ",(0,s.jsx)(n.code,{children:"Commit"})," 阶段处理，或者在 ",(0,s.jsx)(n.code,{children:"setTimeout"})," 中处理（脱离 React 的机制）。"]}),"\n",(0,s.jsxs)(n.p,{children:["换言之，",(0,s.jsx)(n.strong,{children:"所有关于 Ref 的操作，处理的方式都在 Commit 阶段"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"但特别要注意，函数式组件是不允许 ref 属性的，也就是说，处理 Ref 的逻辑在 Class 组件和原生组件上。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"浅谈-commitrootimpl",children:["浅谈 commitRootImpl",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浅谈-commitrootimpl",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 useEffect 源码的时候涉及过 ",(0,s.jsx)(n.code,{children:"commitRootImpl"}),"，从 commit 阶段的入口 ",(0,s.jsx)(n.code,{children:"commitRoot"})," 到达 ",(0,s.jsx)(n.code,{children:"commitRootImpl"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["源码位置：",(0,s.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberWorkLoop.js"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"commitRootImpl 包含很多东西，主要包含三个阶段（这里只是提及下，感兴趣的可自行研究，在这里主要看 Ref 的处理逻辑）："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function commitRootImpl(){\n    ...\n    // BeforeMutation 阶段\n    commitBeforeMutationEffects(root, finishedWork);\n    \n    // Mutation 阶段\n    commitMutationEffects(root, finishedWork, lanes);\n    \n    // Layout 阶段\n    commitLayoutEffects(finishedWork, root, lanes);\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"BeforeMutation 阶段："})," 进行",(0,s.jsx)(n.strong,{children:"深度优先遍历，找到最后一个带有标识的 Fiber"})," 作为起点（子 => 父 查找），然后会调用一个实例 instance 的 getSnapshotBeforeUpdate 方法，并生成快照对象，之后作为 ",(0,s.jsx)(n.code,{children:"componentDidUpdate"})," 的第三个参数，这里主要针对的是 Class 组件的操作，对其他类型的组件并不做处理。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mutation 阶段："})," 此阶段为核心阶段，",(0,s.jsx)(n.strong,{children:"是真正进行更新 DOM 树的阶段。"})," 是真正处理 Class 组件、函数式组件以及原生组件的地方，同时也是增加、删除、更新的处理阶段。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Layout 阶段："})," 它与 BeforeMutation 阶段一样，也是先进行深度优先遍历，找到最后一个带有标识的 Fiber 作为起点。之后会根据不同的组件处理不同的逻辑，比如函数式组件处理 useLayoutEffect 的回调函数。经历过此步骤后就会",(0,s.jsx)(n.strong,{children:"更新 ref"}),"，最终处理 useEfect，也就是在 useEffect 章节中的 Scheduler（异步） 调度器了。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"画个简易版的图，来帮助我们理解："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"未命名文件.png"})}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们继续探索 React 对 ref 的处理方式。"}),"\n",(0,s.jsxs)(n.h2,{id:"safelydetachref-置空卸载操作",children:["safelyDetachRef 置空/卸载操作",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#safelydetachref-置空卸载操作",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在更新的过程中，首先在 conmmit 的 Mutation 阶段，会将 ref 重置为 null，最终在 ",(0,s.jsx)(n.code,{children:"safelyDetachRef"})," 函数中处理，如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["同时，safelyDetachRef 也是卸载操作，有关 Ref 的卸载也是在此函数中完成。在 v16 的版本中，置空操作是 ",(0,s.jsx)(n.code,{children:"commitDetachRef"})," 函数，这点有所不同。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"问：ref 的获取有字符串、函数、 ref 对象三种情况，但在 safelyDetachRef 函数中，只判断了是函数和 ref 对象的情况，那么字符串的形式，是如何走的？"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"答：当 ref 是字符串的情况时，实际上会走函数的方式，这是因为之前有统一处理 ref 的地方。"}),"\n",(0,s.jsxs)(n.p,{children:["文件位置：",(0,s.jsx)(n.code,{children:"packages/react-reconciler/src/ReactChildFiber.js"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"  const ref = function(value: mixed) {\n    const refs = resolvedInst.refs;\n    if (value === null) {\n      delete refs[stringRef];\n    } else {\n      refs[stringRef] = value;\n    }\n  };\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"也就是说，当 ref 是字符串类型时，会自动转化为函数，绑定在组件的实例的 refs 属性下。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"markref-标记操作",children:["markRef 标记操作",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#markref-标记操作",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们要知道 Ref 的更新是有条件的，",(0,s.jsx)(n.strong,{children:"并不是每一次 Fiber 更新都会让 ref 进行更新，只有具备 Ref tag 的时候才会更新。"})]}),"\n",(0,s.jsxs)(n.p,{children:["所以，我们首先要明白 React 是如何打上 Ref tag 的。主要是在 ",(0,s.jsx)(n.code,{children:"markRef"}),"函数中。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function markRef(current: Fiber | null, workInProgress: Fiber) {\n  const ref = workInProgress.ref;\n  if (\n    (current === null && ref !== null) || // 初始化\n    (current !== null && current.ref !== ref) // 更新时\n  ) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n    workInProgress.flags |= RefStatic;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"当然，markRef 是在 Class 组件或原生组件的更新过程中进行调用，同时分为两种情况，一种是初始化，另一种是更新中发生变化，"}),"\n",(0,s.jsxs)(n.h2,{id:"commitattachref-更新操作",children:["commitAttachRef 更新操作",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commitattachref-更新操作",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"阅读完标记操作后，再来看看 Ref 具体的更新逻辑。"}),"\n",(0,s.jsx)(n.p,{children:"Ref 的更新操作在 Layout 阶段，在更新真实元素节点之后，会进行有关 Ref 的更新。我们先来看下源码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"    // 更新条件\n    if (flags & Ref) {\n      safelyAttachRef(finishedWork, finishedWork.return);\n    }\n    \n    // safelyAttachRef\n    function safelyAttachRef(current: Fiber, nearestMountedAncestor: Fiber | null) {\n      try {\n        commitAttachRef(current);\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n    }\n    \n    // commitAttachRef 更新操作\n    function commitAttachRef(finishedWork: Fiber) {\n      const ref = finishedWork.ref;\n      if (ref !== null) {\n        const instance = finishedWork.stateNode;\n        let instanceToUse;\n        switch (finishedWork.tag) {\n          case HostResource:\n          case HostSingleton:\n          case HostComponent: // 原生元素\n            instanceToUse = getPublicInstance(instance);\n            break;\n          default: // 类组件\n            instanceToUse = instance;\n        }\n        if (enableScopeAPI && finishedWork.tag === ScopeComponent) {\n          instanceToUse = instance;\n        }\n        if (typeof ref === 'function') {\n          if (shouldProfile(finishedWork)) {\n            try {\n              startLayoutEffectTimer();\n              finishedWork.refCleanup = ref(instanceToUse);\n            } finally {\n              recordLayoutEffectDuration(finishedWork);\n            }\n          } else {\n            finishedWork.refCleanup = ref(instanceToUse);\n          }\n        } else {\n          ref.current = instanceToUse;\n        }\n      }\n    }\n"})}),"\n",(0,s.jsx)(n.p,{children:"当具备更新条件后会走到 safelyAttachRef 中，而 safelyAttachRef 中的主体是 commitAttachRef 函数。"}),"\n",(0,s.jsxs)(n.p,{children:["commitAttachRef 函数主要判断是类组件还是原生组件，通过 tag 去判断，其中 ",(0,s.jsx)(n.code,{children:"HostComponent"}),"是原生组件（在之前的 Fiber 中介绍过），Class 组件是直接使用的实例 instance，剩余的步骤与 safelyDetachRef 类似。"]}),"\n",(0,s.jsxs)(n.h2,{id:"出现的原因",children:["出现的原因",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#出现的原因",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"了解完 Ref 的相关操作后，我们再来看看一开始的问题。"}),"\n",(0,s.jsxs)(n.p,{children:["之所以会打印两次，",(0,s.jsx)(n.strong,{children:"是因为一次在 DOM 更新之前（即置空操作），另一次是 DOM 更新之后（即更新操作）"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["说白了，在每次更新的时候，",(0,s.jsx)(n.code,{children:"markRef"})," 认为 ",(0,s.jsx)(n.code,{children:"current.ref !== ref"}),"，就会打上新的标签，导致在 commit 阶段会更新 ref，从而会打印两次。"]}),"\n",(0,s.jsxs)(n.h1,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本章我们通过 createRef 和 useRef 的对比引出两者的底层逻辑相差无几，两者区别点在于",(0,s.jsx)(n.strong,{children:"存储的位置不同"}),"，通过 createRef 是否能在函数组件中使用的案例，总结出 useRef 诞生的原因。"]}),"\n",(0,s.jsx)(n.p,{children:"之后我们学习 useRef 的高阶用法，对比 useState，明确两者的区别，以及为何不能用 useRef 替换 useState。"}),"\n",(0,s.jsxs)(n.p,{children:["最后我们探索 ref 属性的奥秘，掌握 React 是如何处理 ref，其大体分为四段操作：",(0,s.jsx)(n.strong,{children:"置空操作"}),"、",(0,s.jsx)(n.strong,{children:"标记操作"}),"、",(0,s.jsx)(n.strong,{children:"更新操作"}),"、",(0,s.jsx)(n.strong,{children:"卸载操作"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"有关 React v16 的核心 Hooks 的源码就到此为止了，接下来我们继续进行 React v18 核心 Hooks 的源码学习。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}let f=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F13.%E6%BA%90%E7%A0%81%E7%AF%87%EF%BD%9C%E5%85%A8%E6%96%B9%E9%9D%A2%E5%89%96%E6%9E%90%20Ref.md"]={toc:[{text:"createRef 源码",id:"createref-源码",depth:2},{text:"useRef 源码",id:"useref-源码",depth:2},{text:"缓存数据：对比 useState",id:"缓存数据对比-usestate",depth:2},{text:"跨层级获取实例与通信",id:"跨层级获取实例与通信",depth:2},{text:"浅谈 commitRootImpl",id:"浅谈-commitrootimpl",depth:2},{text:"safelyDetachRef 置空/卸载操作",id:"safelydetachref-置空卸载操作",depth:2},{text:"markRef 标记操作",id:"markref-标记操作",depth:2},{text:"commitAttachRef 更新操作",id:"commitattachref-更新操作",depth:2},{text:"出现的原因",id:"出现的原因",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);