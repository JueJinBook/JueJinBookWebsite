"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["25000"],{541777:function(n,e,s){s.r(e),s.d(e,{default:()=>o});var r=s(552676),a=s(740453);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",ul:"ul",li:"li",pre:"pre",ol:"ol",strong:"strong"},(0,a.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"31装饰器",children:["31.装饰器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#31装饰器",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"[说明] Decorator 提案经历了重大的语法变化，目前处于第三阶段，定案之前不知道是否还有变化。本章现在属于草稿阶段，凡是标注“新语法”的章节，都是基于当前的语法，不过没有详细整理，只是一些原始材料；未标注“新语法”的章节基于以前的语法，是过去遗留的稿子。之所以保留以前的内容，有两个原因，一是 TypeScript 装饰器会用到这些语法，二是里面包含不少有价值的内容。等到标准完全定案，本章将彻底重写：删去过时内容，补充材料，增加解释。（2022年6月）"}),"\n",(0,r.jsxs)(e.h2,{id:"简介新语法",children:["简介（新语法）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#简介新语法",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["装饰器（Decorator）用来增强 JavaScript 类（class）的功能，许多面向对象的语言都有这种语法，目前有一个",(0,r.jsx)(e.a,{href:"https://github.com/tc39/proposal-decorators",target:"_blank",rel:"noopener noreferrer",children:"提案"}),"将其引入了 ECMAScript。"]}),"\n",(0,r.jsxs)(e.p,{children:["装饰器是一种函数，写成",(0,r.jsx)(e.code,{children:"@ + 函数名"}),"，可以用来装饰四种类型的值。"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"类"}),"\n",(0,r.jsx)(e.li,{children:"类的属性"}),"\n",(0,r.jsx)(e.li,{children:"类的方法"}),"\n",(0,r.jsx)(e.li,{children:"属性存取器（accessor）"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"下面的例子是装饰器放在类名和类方法名之前，大家可以感受一下写法。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"@frozen class Foo {\n  @configurable(false)\n  @enumerable(true)\n  method() {}\n\n  @throttle(500)\n  expensiveMethod() {}\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"上面代码一共使用了四个装饰器，一个用在类本身（@frozen），另外三个用在类方法（@configurable()、@enumerable()、@throttle()）。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。"}),"\n",(0,r.jsxs)(e.h2,{id:"装饰器-api新语法",children:["装饰器 API（新语法）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#装饰器-api新语法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"装饰器是一个函数，API 的类型描述如下（TypeScript 写法）。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:"type Decorator = (value: Input, context: {\n  kind: string;\n  name: string | symbol;\n  access: {\n    get?(): unknown;\n    set?(value: unknown): void;\n  };\n  private?: boolean;\n  static?: boolean;\n  addInitializer?(initializer: () => void): void;\n}) => Output | void;\n"})}),"\n",(0,r.jsx)(e.p,{children:"装饰器函数有两个参数。运行时，JavaScript 引擎会提供这两个参数。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"value"}),"：所要装饰的值，某些情况下可能是",(0,r.jsx)(e.code,{children:"undefined"}),"（装饰属性时）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"context"}),"：上下文信息对象。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"装饰器函数的返回值，是一个新版本的装饰对象，但也可以不返回任何值（void）。"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"context"}),"对象有很多属性，其中",(0,r.jsx)(e.code,{children:"kind"}),"属性表示属于哪一种装饰，其他属性的含义如下。"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"kind"}),"：字符串，表示装饰类型，可能的取值有",(0,r.jsx)(e.code,{children:"class"}),"、",(0,r.jsx)(e.code,{children:"method"}),"、",(0,r.jsx)(e.code,{children:"getter"}),"、",(0,r.jsx)(e.code,{children:"setter"}),"、",(0,r.jsx)(e.code,{children:"field"}),"、",(0,r.jsx)(e.code,{children:"accessor"}),"。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"name"}),"：被装饰的值的名称: The name of the value, or in the case of private elements the description of it (e.g. the readable name)."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"access"}),"：对象，包含访问这个值的方法，即存值器和取值器。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"static"}),": 布尔值，该值是否为静态元素。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"private"}),"：布尔值，该值是否为私有元素。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"addInitializer"}),"：函数，允许用户增加初始化逻辑。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"装饰器的执行步骤如下。"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"计算各个装饰器的值，按照从左到右，从上到下的顺序。"}),"\n",(0,r.jsx)(e.li,{children:"调用方法装饰器。"}),"\n",(0,r.jsx)(e.li,{children:"调用类装饰器。"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"类的装饰",children:["类的装饰",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#类的装饰",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"装饰器可以用来装饰整个类。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"@testable\nclass MyTestableClass {\n  // ...\n}\n\nfunction testable(target) {\n  target.isTestable = true;\n}\n\nMyTestableClass.isTestable // true\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，",(0,r.jsx)(e.code,{children:"@testable"}),"就是一个装饰器。它修改了",(0,r.jsx)(e.code,{children:"MyTestableClass"}),"这个类的行为，为它加上了静态属性",(0,r.jsx)(e.code,{children:"isTestable"}),"。",(0,r.jsx)(e.code,{children:"testable"}),"函数的参数",(0,r.jsx)(e.code,{children:"target"}),"是",(0,r.jsx)(e.code,{children:"MyTestableClass"}),"类本身。"]}),"\n",(0,r.jsx)(e.p,{children:"基本上，装饰器的行为就是下面这样。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"@decorator\nclass A {}\n\n// 等同于\n\nclass A {}\nA = decorator(A) || A;\n"})}),"\n",(0,r.jsx)(e.p,{children:"也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function testable(target) {\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，",(0,r.jsx)(e.code,{children:"testable"}),"函数的参数",(0,r.jsx)(e.code,{children:"target"}),"，就是会被装饰的类。"]}),"\n",(0,r.jsx)(e.p,{children:"如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function testable(isTestable) {\n  return function(target) {\n    target.isTestable = isTestable;\n  }\n}\n\n@testable(true)\nclass MyTestableClass {}\nMyTestableClass.isTestable // true\n\n@testable(false)\nclass MyClass {}\nMyClass.isTestable // false\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，装饰器",(0,r.jsx)(e.code,{children:"testable"}),"可以接受参数，这就等于可以修改装饰器的行为。"]}),"\n",(0,r.jsxs)(e.p,{children:["前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的",(0,r.jsx)(e.code,{children:"prototype"}),"对象操作。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function testable(target) {\n  target.prototype.isTestable = true;\n}\n\n@testable\nclass MyTestableClass {}\n\nlet obj = new MyTestableClass();\nobj.isTestable // true\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，装饰器函数",(0,r.jsx)(e.code,{children:"testable"}),"是在目标类的",(0,r.jsx)(e.code,{children:"prototype"}),"对象上添加属性，因此就可以在实例上调用。"]}),"\n",(0,r.jsx)(e.p,{children:"下面是另外一个例子。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// mixins.js\nexport function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list)\n  }\n}\n\n// main.js\nimport { mixins } from './mixins.js'\n\nconst Foo = {\n  foo() { console.log('foo') }\n};\n\n@mixins(Foo)\nclass MyClass {}\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码通过装饰器",(0,r.jsx)(e.code,{children:"mixins"}),"，把",(0,r.jsx)(e.code,{children:"Foo"}),"对象的方法添加到了",(0,r.jsx)(e.code,{children:"MyClass"}),"的实例上面。可以用",(0,r.jsx)(e.code,{children:"Object.assign()"}),"模拟这个功能。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const Foo = {\n  foo() { console.log('foo') }\n};\n\nclass MyClass {}\n\nObject.assign(MyClass.prototype, Foo);\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n"})}),"\n",(0,r.jsx)(e.p,{children:"实际开发中，React 与 Redux 库结合使用时，常常需要写成下面这样。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class MyReactComponent extends React.Component {}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);\n"})}),"\n",(0,r.jsx)(e.p,{children:"有了装饰器，就可以改写上面的代码。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"@connect(mapStateToProps, mapDispatchToProps)\nexport default class MyReactComponent extends React.Component {}\n"})}),"\n",(0,r.jsx)(e.p,{children:"相对来说，后一种写法看上去更容易理解。"}),"\n",(0,r.jsxs)(e.h2,{id:"类装饰器新语法",children:["类装饰器（新语法）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#类装饰器新语法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"类装饰器的类型描述如下。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'type ClassDecorator = (value: Function, context: {\n  kind: "class";\n  name: string | undefined;\n  addInitializer(initializer: () => void): void;\n}) => Function | void;\n'})}),"\n",(0,r.jsxs)(e.p,{children:["类装饰器的第一个参数，就是被装饰的类。第二个参数是上下文对象，如果被装饰的类是一个匿名类，",(0,r.jsx)(e.code,{children:"name"}),"属性就为",(0,r.jsx)(e.code,{children:"undefined"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"类装饰器可以返回一个新的类，取代原来的类，也可以不返回任何值。如果返回的不是构造函数，就会报错。"}),"\n",(0,r.jsx)(e.p,{children:"下面是一个例子。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'function logged(value, { kind, name }) {\n  if (kind === "class") {\n    return class extends value {\n      constructor(...args) {\n        super(...args);\n        console.log(`constructing an instance of ${name} with arguments ${args.join(", ")}`);\n      }\n    }\n  }\n\n  // ...\n}\n\n@logged\nclass C {}\n\nnew C(1);\n// constructing an instance of C with arguments 1\n'})}),"\n",(0,r.jsx)(e.p,{children:"如果不使用装饰器，类装饰器实际上执行的是下面的语法。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class C {}\n\nC = logged(C, {\n  kind: "class",\n  name: "C",\n}) ?? C;\n\nnew C(1);\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"方法装饰器新语法",children:["方法装饰器（新语法）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#方法装饰器新语法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"方法装饰器会修改类的方法。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class C {\n  @trace\n  toString() {\n    return 'C';\n  }\n}\n\n// 相当于\nC.prototype.toString = trace(C.prototype.toString);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面示例中，",(0,r.jsx)(e.code,{children:"@trace"}),"装饰",(0,r.jsx)(e.code,{children:"toString()"}),"方法，就相当于修改了该方法。"]}),"\n",(0,r.jsx)(e.p,{children:"方法装饰器使用 TypeScript 描述类型如下。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'type ClassMethodDecorator = (value: Function, context: {\n  kind: "method";\n  name: string | symbol;\n  access: { get(): unknown };\n  static: boolean;\n  private: boolean;\n  addInitializer(initializer: () => void): void;\n}) => Function | void;\n'})}),"\n",(0,r.jsxs)(e.p,{children:["方法装饰器的第一个参数",(0,r.jsx)(e.code,{children:"value"}),"，就是所要装饰的方法。"]}),"\n",(0,r.jsx)(e.p,{children:"方法装饰器可以返回一个新函数，取代原来的方法，也可以不返回值，表示依然使用原来的方法。如果返回其他类型的值，就会报错。下面是一个例子。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function replaceMethod() {\n  return function () {\n    return `How are you, ${this.name}?`;\n  }\n}\n\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  @replaceMethod\n  hello() {\n    return `Hi ${this.name}!`;\n  }\n}\n\nconst robin = new Person('Robin');\n\nrobin.hello(), 'How are you, Robin?'\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面示例中，",(0,r.jsx)(e.code,{children:"@replaceMethod"}),"返回了一个新函数，取代了原来的",(0,r.jsx)(e.code,{children:"hello()"}),"方法。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'function logged(value, { kind, name }) {\n  if (kind === "method") {\n    return function (...args) {\n      console.log(`starting ${name} with arguments ${args.join(", ")}`);\n      const ret = value.call(this, ...args);\n      console.log(`ending ${name}`);\n      return ret;\n    };\n  }\n}\n\nclass C {\n  @logged\n  m(arg) {}\n}\n\nnew C().m(1);\n// starting m with arguments 1\n// ending m\n'})}),"\n",(0,r.jsxs)(e.p,{children:["上面示例中，装饰器",(0,r.jsx)(e.code,{children:"@logged"}),"返回一个函数，代替原来的",(0,r.jsx)(e.code,{children:"m()"}),"方法。"]}),"\n",(0,r.jsxs)(e.p,{children:["这里的装饰器实际上是一个语法糖，真正的操作是像下面这样，改掉原型链上面",(0,r.jsx)(e.code,{children:"m()"}),"方法。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class C {\n  m(arg) {}\n}\n\nC.prototype.m = logged(C.prototype.m, {\n  kind: "method",\n  name: "m",\n  static: false,\n  private: false,\n}) ?? C.prototype.m;\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"方法的装饰",children:["方法的装饰",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#方法的装饰",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"装饰器不仅可以装饰类，还可以装饰类的属性。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class Person {\n  @readonly\n  name() { return `${this.first} ${this.last}` }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，装饰器",(0,r.jsx)(e.code,{children:"readonly"}),"用来装饰“类”的",(0,r.jsx)(e.code,{children:"name"}),"方法。"]}),"\n",(0,r.jsxs)(e.p,{children:["装饰器函数",(0,r.jsx)(e.code,{children:"readonly"}),"一共可以接受三个参数。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function readonly(target, name, descriptor){\n  // descriptor对象原来的值如下\n  // {\n  //   value: specifiedFunction,\n  //   enumerable: false,\n  //   configurable: true,\n  //   writable: true\n  // };\n  descriptor.writable = false;\n  return descriptor;\n}\n\nreadonly(Person.prototype, 'name', descriptor);\n// 类似于\nObject.defineProperty(Person.prototype, 'name', descriptor);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["装饰器第一个参数是类的原型对象，上例是",(0,r.jsx)(e.code,{children:"Person.prototype"}),"，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时",(0,r.jsx)(e.code,{children:"target"}),"参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。"]}),"\n",(0,r.jsx)(e.p,{children:"另外，上面代码说明，装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。"}),"\n",(0,r.jsxs)(e.p,{children:["下面是另一个例子，修改属性描述对象的",(0,r.jsx)(e.code,{children:"enumerable"}),"属性，使得该属性不可遍历。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class Person {\n  @nonenumerable\n  get kidCount() { return this.children.length; }\n}\n\nfunction nonenumerable(target, name, descriptor) {\n  descriptor.enumerable = false;\n  return descriptor;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["下面的",(0,r.jsx)(e.code,{children:"@log"}),"装饰器，可以起到输出日志的作用。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class Math {\n  @log\n  add(a, b) {\n    return a + b;\n  }\n}\n\nfunction log(target, name, descriptor) {\n  var oldValue = descriptor.value;\n\n  descriptor.value = function() {\n    console.log(`Calling ${name} with`, arguments);\n    return oldValue.apply(this, arguments);\n  };\n\n  return descriptor;\n}\n\nconst math = new Math();\n\n// passed parameters should get logged now\nmath.add(2, 4);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，",(0,r.jsx)(e.code,{children:"@log"}),"装饰器的作用就是在执行原始的操作之前，执行一次",(0,r.jsx)(e.code,{children:"console.log"}),"，从而达到输出日志的目的。"]}),"\n",(0,r.jsx)(e.p,{children:"装饰器有注释的作用。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"@testable\nclass Person {\n  @readonly\n  @nonenumerable\n  name() { return `${this.first} ${this.last}` }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["从上面代码中，我们一眼就能看出，",(0,r.jsx)(e.code,{children:"Person"}),"类是可测试的，而",(0,r.jsx)(e.code,{children:"name"}),"方法是只读和不可枚举的。"]}),"\n",(0,r.jsxs)(e.p,{children:["下面是使用 Decorator 写法的",(0,r.jsx)(e.a,{href:"https://github.com/ionic-team/stencil",target:"_blank",rel:"noopener noreferrer",children:"组件"}),"，看上去一目了然。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"@Component({\n  tag: 'my-component',\n  styleUrl: 'my-component.scss'\n})\nexport class MyComponent {\n  @Prop() first: string;\n  @Prop() last: string;\n  @State() isVisible: boolean = true;\n\n  render() {\n    return (\n      <p>Hello, my name is {this.first} {this.last}</p>\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function dec(id){\n  console.log('evaluated', id);\n  return (target, property, descriptor) => console.log('executed', id);\n}\n\nclass Example {\n    @dec(1)\n    @dec(2)\n    method(){}\n}\n// evaluated 1\n// evaluated 2\n// executed 2\n// executed 1\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，外层装饰器",(0,r.jsx)(e.code,{children:"@dec(1)"}),"先进入，但是内层装饰器",(0,r.jsx)(e.code,{children:"@dec(2)"}),"先执行。"]}),"\n",(0,r.jsx)(e.p,{children:"除了注释，装饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。"}),"\n",(0,r.jsxs)(e.h2,{id:"为什么装饰器不能用于函数",children:["为什么装饰器不能用于函数？",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么装饰器不能用于函数",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"var counter = 0;\n\nvar add = function () {\n  counter++;\n};\n\n@add\nfunction foo() {\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面的代码，意图是执行后",(0,r.jsx)(e.code,{children:"counter"}),"等于 1，但是实际上结果是",(0,r.jsx)(e.code,{children:"counter"}),"等于 0。因为函数提升，使得实际执行的代码是下面这样。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"var counter;\nvar add;\n\n@add\nfunction foo() {\n}\n\ncounter = 0;\n\nadd = function () {\n  counter++;\n};\n"})}),"\n",(0,r.jsx)(e.p,{children:"下面是另一个例子。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'var readOnly = require("some-decorator");\n\n@readOnly\nfunction foo() {\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"上面代码也有问题，因为实际执行是下面这样。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'var readOnly;\n\n@readOnly\nfunction foo() {\n}\n\nreadOnly = require("some-decorator");\n'})}),"\n",(0,r.jsx)(e.p,{children:"总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。"}),"\n",(0,r.jsx)(e.p,{children:"另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function doSomething(name) {\n  console.log('Hello, ' + name);\n}\n\nfunction loggingDecorator(wrapped) {\n  return function() {\n    console.log('Starting');\n    const result = wrapped.apply(this, arguments);\n    console.log('Finished');\n    return result;\n  }\n}\n\nconst wrapped = loggingDecorator(doSomething);\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"存取器装饰器新语法",children:["存取器装饰器（新语法）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#存取器装饰器新语法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"存取器装饰器使用 TypeScript 描述的类型如下。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'type ClassGetterDecorator = (value: Function, context: {\n  kind: "getter";\n  name: string | symbol;\n  access: { get(): unknown };\n  static: boolean;\n  private: boolean;\n  addInitializer(initializer: () => void): void;\n}) => Function | void;\n\ntype ClassSetterDecorator = (value: Function, context: {\n  kind: "setter";\n  name: string | symbol;\n  access: { set(value: unknown): void };\n  static: boolean;\n  private: boolean;\n  addInitializer(initializer: () => void): void;\n}) => Function | void;\n'})}),"\n",(0,r.jsx)(e.p,{children:"存取器装饰器的第一个参数就是原始的存值器（setter）和取值器（getter）。"}),"\n",(0,r.jsx)(e.p,{children:"存取器装饰器的返回值如果是一个函数，就会取代原来的存取器。本质上，就像方法装饰器一样，修改发生在类的原型对象上。它也可以不返回任何值，继续使用原来的存取器。如果返回其他类型的值，就会报错。"}),"\n",(0,r.jsxs)(e.p,{children:["存取器装饰器对存值器（setter）和取值器（getter）是分开作用的。下面的例子里面，",(0,r.jsx)(e.code,{children:"@foo"}),"只装饰",(0,r.jsx)(e.code,{children:"get x()"}),"，不装饰",(0,r.jsx)(e.code,{children:"set x()"}),"。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class C {\n  @foo\n  get x() {\n    // ...\n  }\n\n  set x(val) {\n    // ...\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上一节的",(0,r.jsx)(e.code,{children:"@logged"}),"装饰器稍加修改，就可以用在存取装饰器。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'function logged(value, { kind, name }) {\n  if (kind === "method" || kind === "getter" || kind === "setter") {\n    return function (...args) {\n      console.log(`starting ${name} with arguments ${args.join(", ")}`);\n      const ret = value.call(this, ...args);\n      console.log(`ending ${name}`);\n      return ret;\n    };\n  }\n}\n\nclass C {\n  @logged\n  set x(arg) {}\n}\n\nnew C().x = 1\n// starting x with arguments 1\n// ending x\n'})}),"\n",(0,r.jsx)(e.p,{children:"如果去掉语法糖，使用传统语法来写，就是改掉了类的原型链。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class C {\n  set x(arg) {}\n}\n\nlet { set } = Object.getOwnPropertyDescriptor(C.prototype, "x");\nset = logged(set, {\n  kind: "setter",\n  name: "x",\n  static: false,\n  private: false,\n}) ?? set;\n\nObject.defineProperty(C.prototype, "x", { set });\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"属性装饰器新语法",children:["属性装饰器（新语法）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#属性装饰器新语法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"属性装饰器的类型描述如下。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'type ClassFieldDecorator = (value: undefined, context: {\n  kind: "field";\n  name: string | symbol;\n  access: { get(): unknown, set(value: unknown): void };\n  static: boolean;\n  private: boolean;\n}) => (initialValue: unknown) => unknown | void;\n'})}),"\n",(0,r.jsxs)(e.p,{children:["属性装饰器的第一个参数是",(0,r.jsx)(e.code,{children:"undefined"}),"，即不输入值。用户可以选择让装饰器返回一个初始化函数，当该属性被赋值时，这个初始化函数会自动运行，它会收到属性的初始值，然后返回一个新的初始值。属性装饰器也可以不返回任何值。除了这两种情况，返回其他类型的值都会报错。"]}),"\n",(0,r.jsx)(e.p,{children:"下面是一个例子。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'function logged(value, { kind, name }) {\n  if (kind === "field") {\n    return function (initialValue) {\n      console.log(`initializing ${name} with value ${initialValue}`);\n      return initialValue;\n    };\n  }\n\n  // ...\n}\n\nclass C {\n  @logged x = 1;\n}\n\nnew C();\n// initializing x with value 1\n'})}),"\n",(0,r.jsx)(e.p,{children:"如果不使用装饰器语法，属性装饰器的实际作用如下。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'let initializeX = logged(undefined, {\n  kind: "field",\n  name: "x",\n  static: false,\n  private: false,\n}) ?? (initialValue) => initialValue;\n\nclass C {\n  x = initializeX.call(this, 1);\n}\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"accessor-命令新语法",children:["accessor 命令（新语法）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#accessor-命令新语法",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["类装饰器引入了一个新命令",(0,r.jsx)(e.code,{children:"accessor"}),"，用来属性的前缀。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class C {\n  accessor x = 1;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["它是一种简写形式，相当于声明属性",(0,r.jsx)(e.code,{children:"x"}),"是私有属性",(0,r.jsx)(e.code,{children:"#x"}),"的存取接口。上面的代码等同于下面的代码。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class C {\n  #x = 1;\n\n  get x() {\n    return this.#x;\n  }\n\n  set x(val) {\n    this.#x = val;\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"accessor"}),"命令前面，还可以加上",(0,r.jsx)(e.code,{children:"static"}),"命令和",(0,r.jsx)(e.code,{children:"private"}),"命令。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class C {\n  static accessor x = 1;\n  accessor #y = 2;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"accessor"}),"命令前面还可以接受属性装饰器。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'function logged(value, { kind, name }) {\n  if (kind === "accessor") {\n    let { get, set } = value;\n\n    return {\n      get() {\n        console.log(`getting ${name}`);\n\n        return get.call(this);\n      },\n\n      set(val) {\n        console.log(`setting ${name} to ${val}`);\n\n        return set.call(this, val);\n      },\n\n      init(initialValue) {\n        console.log(`initializing ${name} with value ${initialValue}`);\n        return initialValue;\n      }\n    };\n  }\n\n  // ...\n}\n\nclass C {\n  @logged accessor x = 1;\n}\n\nlet c = new C();\n// initializing x with value 1\nc.x;\n// getting x\nc.x = 123;\n// setting x to 123\n'})}),"\n",(0,r.jsxs)(e.p,{children:["上面的示例等同于使用",(0,r.jsx)(e.code,{children:"@logged"}),"装饰器，改写",(0,r.jsx)(e.code,{children:"accessor"}),"属性的 getter 和 setter 方法。"]}),"\n",(0,r.jsxs)(e.p,{children:["用于",(0,r.jsx)(e.code,{children:"accessor"}),"的属性装饰器的类型描述如下。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'type ClassAutoAccessorDecorator = (\n  value: {\n    get: () => unknown;\n    set(value: unknown) => void;\n  },\n  context: {\n    kind: "accessor";\n    name: string | symbol;\n    access: { get(): unknown, set(value: unknown): void };\n    static: boolean;\n    private: boolean;\n    addInitializer(initializer: () => void): void;\n  }\n) => {\n  get?: () => unknown;\n  set?: (value: unknown) => void;\n  initialize?: (initialValue: unknown) => unknown;\n} | void;\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"accessor"}),"命令的第一个参数接收到的是一个对象，包含了",(0,r.jsx)(e.code,{children:"accessor"}),"命令定义的属性的存取器 get 和 set。属性装饰器可以返回一个新对象，其中包含了新的存取器，用来取代原来的，即相当于拦截了原来的存取器。此外，返回的对象还可以包括一个",(0,r.jsx)(e.code,{children:"initialize"}),"函数，用来改变私有属性的初始值。装饰器也可以不返回值，如果返回的是其他类型的值，或者包含其他属性的对象，就会报错。"]}),"\n",(0,r.jsxs)(e.h2,{id:"addinitializer-方法新语法",children:["addInitializer() 方法（新语法）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#addinitializer-方法新语法",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["除了属性装饰器，其他装饰器的上下文对象还包括一个",(0,r.jsx)(e.code,{children:"addInitializer()"}),"方法，用来完成初始化操作。"]}),"\n",(0,r.jsx)(e.p,{children:"它的运行时间如下。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"类装饰器：在类被完全定义之后。"}),"\n",(0,r.jsx)(e.li,{children:"方法装饰器：在类构造期间运行，在属性初始化之前。"}),"\n",(0,r.jsx)(e.li,{children:"静态方法装饰器：在类定义期间运行，早于静态属性定义，但晚于类方法的定义。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"下面是一个例子。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function customElement(name) {\n  return (value, { addInitializer }) => {\n    addInitializer(function() {\n      customElements.define(name, this);\n    });\n  }\n}\n\n@customElement('my-element')\nclass MyElement extends HTMLElement {\n  static get observedAttributes() {\n    return ['some', 'attrs'];\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"上面的代码等同于下面不使用装饰器的代码。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class MyElement {\n  static get observedAttributes() {\n    return ['some', 'attrs'];\n  }\n}\n\nlet initializersForMyElement = [];\n\nMyElement = customElement('my-element')(MyElement, {\n  kind: \"class\",\n  name: \"MyElement\",\n  addInitializer(fn) {\n    initializersForMyElement.push(fn);\n  },\n}) ?? MyElement;\n\nfor (let initializer of initializersForMyElement) {\n  initializer.call(MyElement);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"下面是方法装饰器的例子。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'function bound(value, { name, addInitializer }) {\n  addInitializer(function () {\n    this[name] = this[name].bind(this);\n  });\n}\n\nclass C {\n  message = "hello!";\n\n  @bound\n  m() {\n    console.log(this.message);\n  }\n}\n\nlet { m } = new C();\n\nm(); // hello!\n'})}),"\n",(0,r.jsx)(e.p,{children:"上面的代码等同于下面不使用装饰器的代码。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class C {\n  constructor() {\n    for (let initializer of initializersForM) {\n      initializer.call(this);\n    }\n\n    this.message = "hello!";\n  }\n\n  m() {}\n}\n\nlet initializersForM = []\n\nC.prototype.m = bound(\n  C.prototype.m,\n  {\n    kind: "method",\n    name: "m",\n    static: false,\n    private: false,\n    addInitializer(fn) {\n      initializersForM.push(fn);\n    },\n  }\n) ?? C.prototype.m;\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"core-decoratorsjs",children:["core-decorators.js",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#core-decoratorsjs",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.a,{href:"https://github.com/jayphelps/core-decorators.js",target:"_blank",rel:"noopener noreferrer",children:"core-decorators.js"}),"是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"（1）@autobind"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"autobind"}),"装饰器使得方法中的",(0,r.jsx)(e.code,{children:"this"}),"对象，绑定原始对象。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { autobind } from 'core-decorators';\n\nclass Person {\n  @autobind\n  getPerson() {\n    return this;\n  }\n}\n\nlet person = new Person();\nlet getPerson = person.getPerson;\n\ngetPerson() === person;\n// true\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"（2）@readonly"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"readonly"}),"装饰器使得属性或方法不可写。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { readonly } from 'core-decorators';\n\nclass Meal {\n  @readonly\n  entree = 'steak';\n}\n\nvar dinner = new Meal();\ndinner.entree = 'salmon';\n// Cannot assign to read only property 'entree' of [object Object]\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"（3）@override"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"override"}),"装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { override } from 'core-decorators';\n\nclass Parent {\n  speak(first, second) {}\n}\n\nclass Child extends Parent {\n  @override\n  speak() {}\n  // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)\n}\n\n// or\n\nclass Child extends Parent {\n  @override\n  speaks() {}\n  // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.\n  //\n  //   Did you mean \"speak\"?\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"（4）@deprecate (别名@deprecated)"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"deprecate"}),"或",(0,r.jsx)(e.code,{children:"deprecated"}),"装饰器在控制台显示一条警告，表示该方法将废除。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { deprecate } from 'core-decorators';\n\nclass Person {\n  @deprecate\n  facepalm() {}\n\n  @deprecate('We stopped facepalming')\n  facepalmHard() {}\n\n  @deprecate('We stopped facepalming', { url: 'http://knowyourmeme.com/memes/facepalm' })\n  facepalmHarder() {}\n}\n\nlet person = new Person();\n\nperson.facepalm();\n// DEPRECATION Person#facepalm: This function will be removed in future versions.\n\nperson.facepalmHard();\n// DEPRECATION Person#facepalmHard: We stopped facepalming\n\nperson.facepalmHarder();\n// DEPRECATION Person#facepalmHarder: We stopped facepalming\n//\n//     See http://knowyourmeme.com/memes/facepalm for more details.\n//\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"（5）@suppressWarnings"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"suppressWarnings"}),"装饰器抑制",(0,r.jsx)(e.code,{children:"deprecated"}),"装饰器导致的",(0,r.jsx)(e.code,{children:"console.warn()"}),"调用。但是，异步代码发出的调用除外。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { suppressWarnings } from 'core-decorators';\n\nclass Person {\n  @deprecated\n  facepalm() {}\n\n  @suppressWarnings\n  facepalmWithoutWarning() {\n    this.facepalm();\n  }\n}\n\nlet person = new Person();\n\nperson.facepalmWithoutWarning();\n// no warning is logged\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"使用装饰器实现自动发布事件",children:["使用装饰器实现自动发布事件",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用装饰器实现自动发布事件",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们可以使用装饰器，使得对象的方法被调用时，自动发出一个事件。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const postal = require(\"postal/lib/postal.lodash\");\n\nexport default function publish(topic, channel) {\n  const channelName = channel || '/';\n  const msgChannel = postal.channel(channelName);\n  msgChannel.subscribe(topic, v => {\n    console.log('频道: ', channelName);\n    console.log('事件: ', topic);\n    console.log('数据: ', v);\n  });\n\n  return function(target, name, descriptor) {\n    const fn = descriptor.value;\n\n    descriptor.value = function() {\n      let value = fn.apply(this, arguments);\n      msgChannel.publish(topic, value);\n    };\n  };\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码定义了一个名为",(0,r.jsx)(e.code,{children:"publish"}),"的装饰器，它通过改写",(0,r.jsx)(e.code,{children:"descriptor.value"}),"，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是",(0,r.jsx)(e.a,{href:"https://github.com/postaljs/postal.js",target:"_blank",rel:"noopener noreferrer",children:"Postal.js"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"它的用法如下。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// index.js\nimport publish from './publish';\n\nclass FooComponent {\n  @publish('foo.some.message', 'component')\n  someMethod() {\n    return { my: 'data' };\n  }\n  @publish('foo.some.other')\n  anotherMethod() {\n    // ...\n  }\n}\n\nlet foo = new FooComponent();\n\nfoo.someMethod();\nfoo.anotherMethod();\n"})}),"\n",(0,r.jsxs)(e.p,{children:["以后，只要调用",(0,r.jsx)(e.code,{children:"someMethod"}),"或者",(0,r.jsx)(e.code,{children:"anotherMethod"}),"，就会自动发出一个事件。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"$ bash-node index.js\n频道:  component\n事件:  foo.some.message\n数据:  { my: 'data' }\n\n频道:  /\n事件:  foo.some.other\n数据:  undefined\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"mixin",children:["Mixin",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在装饰器的基础上，可以实现",(0,r.jsx)(e.code,{children:"Mixin"}),"模式。所谓",(0,r.jsx)(e.code,{children:"Mixin"}),"模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。"]}),"\n",(0,r.jsx)(e.p,{children:"请看下面的例子。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const Foo = {\n  foo() { console.log('foo') }\n};\n\nclass MyClass {}\n\nObject.assign(MyClass.prototype, Foo);\n\nlet obj = new MyClass();\nobj.foo() // 'foo'\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码之中，对象",(0,r.jsx)(e.code,{children:"Foo"}),"有一个",(0,r.jsx)(e.code,{children:"foo"}),"方法，通过",(0,r.jsx)(e.code,{children:"Object.assign"}),"方法，可以将",(0,r.jsx)(e.code,{children:"foo"}),"方法“混入”",(0,r.jsx)(e.code,{children:"MyClass"}),"类，导致",(0,r.jsx)(e.code,{children:"MyClass"}),"的实例",(0,r.jsx)(e.code,{children:"obj"}),"对象都具有",(0,r.jsx)(e.code,{children:"foo"}),"方法。这就是“混入”模式的一个简单实现。"]}),"\n",(0,r.jsxs)(e.p,{children:["下面，我们部署一个通用脚本",(0,r.jsx)(e.code,{children:"mixins.js"}),"，将 Mixin 写成一个装饰器。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"export function mixins(...list) {\n  return function (target) {\n    Object.assign(target.prototype, ...list);\n  };\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后，就可以使用上面这个装饰器，为类“混入”各种方法。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { mixins } from './mixins.js';\n\nconst Foo = {\n  foo() { console.log('foo') }\n};\n\n@mixins(Foo)\nclass MyClass {}\n\nlet obj = new MyClass();\nobj.foo() // \"foo\"\n"})}),"\n",(0,r.jsxs)(e.p,{children:["通过",(0,r.jsx)(e.code,{children:"mixins"}),"这个装饰器，实现了在",(0,r.jsx)(e.code,{children:"MyClass"}),"类上面“混入”",(0,r.jsx)(e.code,{children:"Foo"}),"对象的",(0,r.jsx)(e.code,{children:"foo"}),"方法。"]}),"\n",(0,r.jsxs)(e.p,{children:["不过，上面的方法会改写",(0,r.jsx)(e.code,{children:"MyClass"}),"类的",(0,r.jsx)(e.code,{children:"prototype"}),"对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class MyClass extends MyBaseClass {\n  /* ... */\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，",(0,r.jsx)(e.code,{children:"MyClass"}),"继承了",(0,r.jsx)(e.code,{children:"MyBaseClass"}),"。如果我们想在",(0,r.jsx)(e.code,{children:"MyClass"}),"里面“混入”一个",(0,r.jsx)(e.code,{children:"foo"}),"方法，一个办法是在",(0,r.jsx)(e.code,{children:"MyClass"}),"和",(0,r.jsx)(e.code,{children:"MyBaseClass"}),"之间插入一个混入类，这个类具有",(0,r.jsx)(e.code,{children:"foo"}),"方法，并且继承了",(0,r.jsx)(e.code,{children:"MyBaseClass"}),"的所有方法，然后",(0,r.jsx)(e.code,{children:"MyClass"}),"再继承这个类。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"let MyMixin = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from MyMixin');\n  }\n};\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，",(0,r.jsx)(e.code,{children:"MyMixin"}),"是一个混入类生成器，接受",(0,r.jsx)(e.code,{children:"superclass"}),"作为参数，然后返回一个继承",(0,r.jsx)(e.code,{children:"superclass"}),"的子类，该子类包含一个",(0,r.jsx)(e.code,{children:"foo"}),"方法。"]}),"\n",(0,r.jsxs)(e.p,{children:["接着，目标类再去继承这个混入类，就达到了“混入”",(0,r.jsx)(e.code,{children:"foo"}),"方法的目的。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class MyClass extends MyMixin(MyBaseClass) {\n  /* ... */\n}\n\nlet c = new MyClass();\nc.foo(); // "foo from MyMixin"\n'})}),"\n",(0,r.jsx)(e.p,{children:"如果需要“混入”多个方法，就生成多个混入类。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class MyClass extends Mixin1(Mixin2(MyBaseClass)) {\n  /* ... */\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这种写法的一个好处，是可以调用",(0,r.jsx)(e.code,{children:"super"}),"，因此可以避免在“混入”过程中覆盖父类的同名方法。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"let Mixin1 = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from Mixin1');\n    if (super.foo) super.foo();\n  }\n};\n\nlet Mixin2 = (superclass) => class extends superclass {\n  foo() {\n    console.log('foo from Mixin2');\n    if (super.foo) super.foo();\n  }\n};\n\nclass S {\n  foo() {\n    console.log('foo from S');\n  }\n}\n\nclass C extends Mixin1(Mixin2(S)) {\n  foo() {\n    console.log('foo from C');\n    super.foo();\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，每一次",(0,r.jsx)(e.code,{children:"混入"}),"发生时，都调用了父类的",(0,r.jsx)(e.code,{children:"super.foo"}),"方法，导致父类的同名方法没有被覆盖，行为被保留了下来。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"new C().foo()\n// foo from C\n// foo from Mixin1\n// foo from Mixin2\n// foo from S\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"trait",children:["Trait",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#trait",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"Trait 也是一种装饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。"}),"\n",(0,r.jsxs)(e.p,{children:["下面采用",(0,r.jsx)(e.a,{href:"https://github.com/CocktailJS/traits-decorator",target:"_blank",rel:"noopener noreferrer",children:"traits-decorator"}),"这个第三方模块作为例子。这个模块提供的",(0,r.jsx)(e.code,{children:"traits"}),"装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { traits } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') }\n};\n\n@traits(TFoo, TBar)\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.bar() // bar\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，通过",(0,r.jsx)(e.code,{children:"traits"}),"装饰器，在",(0,r.jsx)(e.code,{children:"MyClass"}),"类上面“混入”了",(0,r.jsx)(e.code,{children:"TFoo"}),"类的",(0,r.jsx)(e.code,{children:"foo"}),"方法和",(0,r.jsx)(e.code,{children:"TBar"}),"对象的",(0,r.jsx)(e.code,{children:"bar"}),"方法。"]}),"\n",(0,r.jsx)(e.p,{children:"Trait 不允许“混入”同名方法。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { traits } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar)\nclass MyClass { }\n// 报错\n// throw new Error('Method named: ' + methodName + ' is defined twice.');\n//        ^\n// Error: Method named: foo is defined twice.\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，",(0,r.jsx)(e.code,{children:"TFoo"}),"和",(0,r.jsx)(e.code,{children:"TBar"}),"都有",(0,r.jsx)(e.code,{children:"foo"}),"方法，结果",(0,r.jsx)(e.code,{children:"traits"}),"装饰器报错。"]}),"\n",(0,r.jsxs)(e.p,{children:["一种解决方法是排除",(0,r.jsx)(e.code,{children:"TBar"}),"的",(0,r.jsx)(e.code,{children:"foo"}),"方法。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { traits, excludes } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar::excludes('foo'))\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.bar() // bar\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码使用绑定运算符（::）在",(0,r.jsx)(e.code,{children:"TBar"}),"上排除",(0,r.jsx)(e.code,{children:"foo"}),"方法，混入时就不会报错了。"]}),"\n",(0,r.jsxs)(e.p,{children:["另一种方法是为",(0,r.jsx)(e.code,{children:"TBar"}),"的",(0,r.jsx)(e.code,{children:"foo"}),"方法起一个别名。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { traits, alias } from 'traits-decorator';\n\nclass TFoo {\n  foo() { console.log('foo') }\n}\n\nconst TBar = {\n  bar() { console.log('bar') },\n  foo() { console.log('foo') }\n};\n\n@traits(TFoo, TBar::alias({foo: 'aliasFoo'}))\nclass MyClass { }\n\nlet obj = new MyClass();\nobj.foo() // foo\nobj.aliasFoo() // foo\nobj.bar() // bar\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码为",(0,r.jsx)(e.code,{children:"TBar"}),"的",(0,r.jsx)(e.code,{children:"foo"}),"方法起了别名",(0,r.jsx)(e.code,{children:"aliasFoo"}),"，于是",(0,r.jsx)(e.code,{children:"MyClass"}),"也可以混入",(0,r.jsx)(e.code,{children:"TBar"}),"的",(0,r.jsx)(e.code,{children:"foo"}),"方法了。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"alias"}),"和",(0,r.jsx)(e.code,{children:"excludes"}),"方法，可以结合起来使用。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"@traits(TExample::excludes('foo','bar')::alias({baz:'exampleBaz'}))\nclass MyClass {}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码排除了",(0,r.jsx)(e.code,{children:"TExample"}),"的",(0,r.jsx)(e.code,{children:"foo"}),"方法和",(0,r.jsx)(e.code,{children:"bar"}),"方法，为",(0,r.jsx)(e.code,{children:"baz"}),"方法起了别名",(0,r.jsx)(e.code,{children:"exampleBaz"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"as"}),"方法则为上面的代码提供了另一种写法。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"@traits(TExample::as({excludes:['foo', 'bar'], alias: {baz: 'exampleBaz'}}))\nclass MyClass {}\n"})})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F31.%E8%A3%85%E9%A5%B0%E5%99%A8.md"]={toc:[{text:"简介（新语法）",id:"简介新语法",depth:2},{text:"装饰器 API（新语法）",id:"装饰器-api新语法",depth:2},{text:"类的装饰",id:"类的装饰",depth:2},{text:"类装饰器（新语法）",id:"类装饰器新语法",depth:2},{text:"方法装饰器（新语法）",id:"方法装饰器新语法",depth:2},{text:"方法的装饰",id:"方法的装饰",depth:2},{text:"为什么装饰器不能用于函数？",id:"为什么装饰器不能用于函数",depth:2},{text:"存取器装饰器（新语法）",id:"存取器装饰器新语法",depth:2},{text:"属性装饰器（新语法）",id:"属性装饰器新语法",depth:2},{text:"accessor 命令（新语法）",id:"accessor-命令新语法",depth:2},{text:"addInitializer() 方法（新语法）",id:"addinitializer-方法新语法",depth:2},{text:"core-decorators.js",id:"core-decoratorsjs",depth:2},{text:"使用装饰器实现自动发布事件",id:"使用装饰器实现自动发布事件",depth:2},{text:"Mixin",id:"mixin",depth:2},{text:"Trait",id:"trait",depth:2}],title:"31.装饰器",headingTitle:"31.装饰器",frontmatter:{}}}}]);