"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["85955"],{700386:function(e,n,s){e.exports=s.p+"static/image/0b0cfa31940265649e860c440c9e4aee.5a40e344.webp"},447641:function(e,n,s){e.exports=s.p+"static/image/0bff5922d89aeed96aac188f24e35eeb.f99aab9c.webp"},961185:function(e,n,s){e.exports=s.p+"static/image/5c38cd8c851863afb959913b3b7c2639.8292cbd4.webp"},844079:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var r=s(552676),c=s(740453),t=s(700386),a=s(961185),l=s(447641);function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",code:"code",h3:"h3",pre:"pre",h4:"h4",strong:"strong",img:"img"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"29实践篇-自定义-hooks-设计持续",children:["29.实践篇-自定义 Hooks 设计（持续）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#29实践篇-自定义-hooks-设计持续",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章节将围绕自定义 hooks 展开，本章节含的知识点如下："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"自定义 hooks 的设计和编写。"}),"\n",(0,r.jsx)(n.li,{children:"几个自定义 hooks 实战。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"二-全面理解自定义-hooks",children:["二 全面理解自定义 hooks",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-全面理解自定义-hooks",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 hooks 原理章节，详细介绍了 ",(0,r.jsx)(n.code,{children:"React Hooks"})," 原理，在其他的章节，也陆续讲解了所有常用的 hooks 用法。接下来针对 hooks 进行功能性拓展，来研究一下在 React 中一种逻辑复用，组件强化方式——自定义 hooks 。"]}),"\n",(0,r.jsxs)(n.h3,{id:"1-概念",children:["1 概念",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-概念",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 是在 React Hooks 基础上的一个拓展，可以根据业务需求制定满足业务需要的组合 hooks ，更注重的是逻辑单元。通过业务场景不同，到底需要React Hooks 做什么，怎么样把一段逻辑封装起来，做到复用，这是自定义 hooks 产生的初衷。"}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 也可以说是 React Hooks 聚合产物，其内部有一个或者多个 React Hooks 组成，用于解决一些复杂逻辑。"}),"\n",(0,r.jsx)(n.p,{children:"一个传统自定义 hooks 长如下的样子："}),"\n",(0,r.jsx)(n.p,{children:"编写："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useXXX(参数A,参数B){\n    /*  \n     ...自定义 hooks 逻辑\n     内部应用了其他 React Hooks —— useState | useEffect | useRef ...\n    */\n    return [xxx,...]\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"使用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const [ xxx , ... ] = useXXX(参数A,参数B...)\n"})}),"\n",(0,r.jsx)(n.p,{children:"实际上自定义 hooks 的编写很简单，开发者只需要关心，传入什么参数（也可以没有参数），和返回什么内容就可以了，当然有一些监听和执行副作用的自定义 hooks ，根本无需返回值。"}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 参数可能是以下内容："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"hooks 初始化值。"}),"\n",(0,r.jsx)(n.li,{children:"一些副作用或事件的回调函数。"}),"\n",(0,r.jsx)(n.li,{children:"可以是 useRef 获取的 DOM 元素或者组件实例。"}),"\n",(0,r.jsx)(n.li,{children:"不需要参数"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 返回值可能是以下内容："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"负责渲染视图获取的状态。"}),"\n",(0,r.jsx)(n.li,{children:"更新函数组件方法，本质上是 useState 或者 useReducer。"}),"\n",(0,r.jsx)(n.li,{children:"一些传递给子孙组件的状态。"}),"\n",(0,r.jsx)(n.li,{children:"没有返回值。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-特性",children:["2 特性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-特性",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上述讲到了自定义 hooks 基本概念，接下来分析一下它的特性。"}),"\n",(0,r.jsxs)(n.h4,{id:"-驱动条件",children:["① 驱动条件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-驱动条件",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先要明白一点，开发者写的自定义 hooks 本质上就是一个函数，而且函数在函数组件中被执行。那么",(0,r.jsx)(n.strong,{children:"自定义 hooks 驱动本质上就是函数组件的执行"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 驱动条件："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"props 改变带来的函数组件执行。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"useState | useReducer 改变 state 引起函数组件的更新。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"1.jpg"})}),"\n",(0,r.jsxs)(n.h4,{id:"-顺序原则",children:["② 顺序原则",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-顺序原则",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["自定义 hooks 内部至少有一个 React Hooks ，那么自定义 hooks 也要遵循 hooks 的规则，",(0,r.jsx)(n.strong,{children:"不能放在条件语句中，而且要保持执行顺序的一致性。"})," 至于为什么？ 在 hooks 原理章节已经讲过了。"]}),"\n",(0,r.jsxs)(n.h4,{id:"-条件限定",children:["③ 条件限定",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-条件限定",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在自定义 hooks 中，条件限定",(0,r.jsx)(n.strong,{children:"特别重要"}),"。为什么这么说呢，因为考虑 hooks 的限定条件，是一个出色的自定义 hooks 重要因素。举个例子："]}),"\n",(0,r.jsx)(n.p,{children:"一些同学容易滥用自定义 hooks 导致一些问题的发生 ，比如在一个自定义这里写："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useXXX(){\n    const value = React.useContext(defaultContext)\n    /* .....用上下文中 value 一段初始化逻辑  */\n    const newValue = initValueFunction(value) /* 初始化 value 得到新的 newValue  */\n    /* ...... */\n    return newValue\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["比如上述一个非常简单自定义 hooks ，从 ",(0,r.jsx)(n.code,{children:"context"})," 取出状态 value ，通过 ",(0,r.jsx)(n.code,{children:"initValueFunction"})," 加工 value ，得到并返回最新的 newValue 。如果直接按照上述这么写，会导致什么发生呢？"]}),"\n",(0,r.jsxs)(n.p,{children:["首先每一次函数组件更新，就会执行此自定义 hooks ，那么就会重复执行初始化逻辑，重复执行",(0,r.jsx)(n.code,{children:"initValueFunction"})," ，每一次都会得到一个最新的 newValue 。 如果 newValue 作为 ",(0,r.jsx)(n.code,{children:"useMemo"})," 和 ",(0,r.jsx)(n.code,{children:"useEffect"})," 的 deps ，或者作为子组件的 props ，那么子组件的浅比较 props 将失去作用，那么会带来一串麻烦。"]}),"\n",(0,r.jsx)(n.p,{children:"那么如何解决这个问题呢？答案很简单，可以通过 useRef 对 newValue 缓存，然后每次执行自定义 hooks 判断有无缓存值。如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useXXX(){\n    const newValue =  React.useRef(null)  /* 创建一个 value 保存状态。  */\n    const value = React.useContext(defaultContext)\n    if(!newValue.current){  /* 如果 newValue 不存在 */\n          newValue.current = initValueFunction(value)\n    }\n    return newValue.current\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"用一个 useRef 保存初始化过程中产生的 value 值 。"}),"\n",(0,r.jsx)(n.li,{children:"判断如果 value 不存在，那么通过 initValueFunction 创建，如果存在直接返回 newValue.current 。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"如上加了条件判断之后，会让自定义 hooks 内部按照期望的方向发展。条件限定是编写出色的 hooks 重要的因素。"}),"\n",(0,r.jsxs)(n.h4,{id:"-考虑可变性",children:["④ 考虑可变性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-考虑可变性",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在编写自定义 hooks 的时候，可变性也是一个非常重要的 hooks 特性。什么叫做可变性，",(0,r.jsx)(n.strong,{children:"就是考虑一些状态值发生变化，是否有依赖于当前值变化的执行逻辑或执行副作用。"})]}),"\n",(0,r.jsx)(n.p,{children:"比如上面的例子\uD83C\uDF30中，如果 defaultContext 中的 value 是可变的，那么如果还像上述用 useRef 这么写，就会造成 context 变化，得不到最新的 value 值的情况发生。"}),"\n",(0,r.jsx)(n.p,{children:"所以为了解决上述可变性的问题："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["对于依赖于可变性状态的执行逻辑，可以用 ",(0,r.jsx)(n.code,{children:"useMemo"})," 来处理。"]}),"\n",(0,r.jsxs)(n.li,{children:["对于可变性状态的执行副作用，可以用 ",(0,r.jsx)(n.code,{children:"useEffect"})," 来处理。"]}),"\n",(0,r.jsxs)(n.li,{children:["对于依赖可变性状态的函数或者属性，可以用",(0,r.jsx)(n.code,{children:"useCallback"}),"来处理。\n于是需要把上述自定义 hooks 改版。"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useXXX(){\n    const value = React.useContext(defaultContext)\n    const newValue = React.useMemo(()=> initValueFunction(value) ,[  value  ] )  \n    return  newValue\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"用 React.useMemo 来对 initValueFunction 初始化逻辑做缓存，当上下文 value 改变的时候，重新生成新的 newValue 。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"这只是一个简单例子，在实际开发中，要比这种情况复杂。开发者应该注意在自定义 hooks 中，哪些状态是可变的，状态改变，又会紧跟着哪些影响。"}),"\n",(0,r.jsxs)(n.h4,{id:"-闭包效应",children:["⑤ 闭包效应",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-闭包效应",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["闭包也是自定义 hooks 应该注意的问题。这个问题和 ④ 本质一样。首先函数组件更新就是函数本身执行，一次更新所有含有状态的 hooks （ ",(0,r.jsx)(n.code,{children:"useState"})," 和 ",(0,r.jsx)(n.code,{children:"useReducer"})," ）产生的状态 state 是重新声明的。但是如果像 ",(0,r.jsx)(n.code,{children:"useEffect"})," ， ",(0,r.jsx)(n.code,{children:"useMemo"})," ，",(0,r.jsx)(n.code,{children:"useCallback"})," 等，它们内部如果引用了 state 或 props 的值，而且这些状态最后保存在了函数组件对应的 fiber 上，那么此次函数组件执行完毕后，这些状态就不会被垃圾回收机制回收释放。这样造成的影响是，上述 hooks 如果没有把内部使用的 state 或 props 作为依赖项，那么内部就一直无法使用最新的 props 或者 state 。"]}),"\n",(0,r.jsx)(n.p,{children:"比如我举个简单的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useTest(){\n    const [ number ] = React.useState(0)\n    const value = React.useMemo(()=>{\n         // 内部引用了 number 进行计算\n    },[])\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如上 useMemo 内部使用了 state 中的 number 进行计算，当 number 改变但是无法得到最新的 value 。这就是上面我说到的闭包问题。解决方法就是 useMemo 的 deps 中加入 number。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"但是有的时候这种依赖关系往往是更复杂的。我将如上 demo 修改。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useTest(){\n    const [ number ] = React.useState(0)\n    const value = React.useMemo(()=>{\n         // 内部引用了 number 进行计算\n    },[ number ])\n    const callback = React.useCallback(function(){\n         // 内部引用了 useEffect\n    },[ value ])\n    \n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如上，在之前的基础上，又加了 useCallback 而且内部引用了 useMemo 生成的 value。 这个时候如果 useCallback 执行，内部想要获取新的状态值 value，那么就需要把 value 放在 useCallback 的 deps 中。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"\uD83E\uDD14思考：如何分清楚依赖关系呢？"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"第一步"}),"：找到 hooks 内部可能发生变化的状态 ， 这个状态可以是 state 或者 props。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"第二步"}),"：分析 useMemo 或者 useCallback 内部是否使用上述状态，或者是否",(0,r.jsx)(n.strong,{children:"关联使用"})," useMemo 或者 useCallback 派生出来的状态（ 比如上述的 value ，就是 useMemo 派生的状态 ） ，如果有使用，那么加入到 deps 。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"第三步"}),"：分析 useEffect ，useLayoutEffect ，useImperativeHandle 内部是否使用上述两个步骤产生的值，而且还要这些值做一些副作用，如果有，那么加入到 deps 。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"三-自定义-hooks-设计",children:["三 自定义 hooks 设计",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-自定义-hooks-设计",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上述介绍了自定义 hooks 的概念和特性，接下来重点分析一下，如何去设计一个自定义 hooks 。"}),"\n",(0,r.jsx)(n.p,{children:"首先明确的一点是，自定义 hooks 解决逻辑复用的问题，那么在正常的业务开发过程中，要明白哪些逻辑是重复性强的逻辑，这段逻辑主要功能是什么。"}),"\n",(0,r.jsx)(n.p,{children:"下面我把自定义 hooks 能实现的功能化整为零，在实际开发中，可能是下面一种或者几种的结合。"}),"\n",(0,r.jsxs)(n.h3,{id:"1-接收状态",children:["1 接收状态",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-接收状态",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks ，可以通过函数参数来直接接收组件传递过来的状态，也可以通过 useContext ，来隐式获取上下文中的状态。比如 React Router 中最简单的一个自定义 hooks —— useHistory ，用于获取 history 对象。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function useHistory() {\n    return useContext(RouterContext).history\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["注意⚠️：",(0,r.jsx)(n.strong,{children:"如果使用了内部含有 useContext 的自定义 hooks ，那么当 context 上下文改变，会让使用自定义 hooks 的组件自动渲染。"})]}),"\n",(0,r.jsxs)(n.h3,{id:"2-存储管理状态",children:["2 存储｜管理状态",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-存储管理状态",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"储存状态"})}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 也可以用来储存和管理状态。本质上应用 useRef 保存原始对象的特性。"}),"\n",(0,r.jsxs)(n.p,{children:["比如 ",(0,r.jsx)(n.code,{children:"rc-form"})," 中的 ",(0,r.jsx)(n.code,{children:"useForm"})," 里面就是用 useRef 来保存表单状态管理 Store 的。简化流程如下"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useForm(){\n    const formCurrent = React.useRef(null)\n    if(!formCurrent.current){\n        formCurrent.current = new FormStore()\n    }\n    return formCurrent.current\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"记录状态"})}),"\n",(0,r.jsx)(n.p,{children:"当然 useRef 和 useEffect 可以配合记录函数组件的内部的状态。举个例子，我编写一个自定义 hooks 用于记录函数组件执行次数，和是否第一次渲染。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useRenderCount(){\n    const isFirstRender = React.useRef(true) /* 记录是否是第一次渲染 */\n    const renderCount = React.useRef(1)      /* 记录渲染次数 */\n    useEffect(()=>{\n        isFirstRender.current = false        /* 第一次渲染完成，改变状态 */\n    },[])\n    useEffect(()=>{\n        if(!isFirstRender.current) renderCount.current++ /* 如果不是第一次渲染，那么添加渲染次数  */\n    })  \n    return [ renderCount.current , isFirstRender.current ]\n} \n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如上用 isFirstRender  记录是否是第一次渲染 ，用 renderCount 记录渲染次数，第一个 useEffect 依赖项为空，只执行一次，第二个 useEffect 没有依赖项，每一次函数组件执行，都会执行，统计渲染次数。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"上述只是举了一个例子，当然在具体开发中，可以用自定义 hooks 去记录一些其他的东西。比如元素的信息，因为可以在 useEffect 中获取到最新的 DOM 元素信息的。"}),"\n",(0,r.jsxs)(n.h3,{id:"3-更新状态",children:["3 更新状态",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-更新状态",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"改变状态"})}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 内部可以保存状态，可以把更新状态的方法暴露出去，来改变 hooks 内部状态。而更新状态的方法可以是组合多态的。"}),"\n",(0,r.jsx)(n.p,{children:"比如实现一个防抖节流的自定义 hooks ："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function debounce(fn, time) {\n    let timer = null;\n    return function(...arg) {\n      if (timer) clearTimeout(timer);\n      timer = setTimeout(() => {\n        fn.apply(this, arg);\n      }, time);\n    };\n}\n\nfunction useDebounceState(defauleValue,time){\n    const [ value , changeValue ] = useState(defauleValue)\n    /* 对 changeValue 做防抖处理   */\n    const newChange = React.useMemo(()=> debounce(changeValue,time) ,[ time ])\n    return [ value , newChange ]\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"使用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n    const [ value , setValue ] = useDebounceState('',300)\n    console.log(value)\n    return <div style={{ marginTop:'50px' }} >\n        《React 进阶实践指南》\n        <input placeholder=\"\" onChange={(e)=>setValue(e.target.value)}  />\n    </div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"3.gif"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"组合state"})}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 可以维护多个 state ，然后可以组合更新函数。我这么说可能很多同学不理解，下面我来举一个例子，比如控制数据加载和loading效果，"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useControlData(){\n    const [ isLoading , setLoading ] = React.useState(false)\n    const [ data,  setData ] = React.useState([])\n    const getData = (data)=> { /* 获取到数据，清空 loading 效果  */\n        setLoading(false)\n        setData(data)\n    }  \n    // ... 其他逻辑\n    const resetData = () =>{  /* 请求数据之前，添加 loading 效果 */\n        setLoading(true)\n        setData([])\n    }\n    return [ getData , resetData , ...  ] \n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"合理state"})}),"\n",(0,r.jsx)(n.p,{children:"useState 和 useRef 都可以保存状态："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"useRef 只要组件不销毁，一直存在，而且可以随时访问最新状态值。"}),"\n",(0,r.jsx)(n.li,{children:"useState 可以让组件更新，但是 state 需要在下一次函数组件执行的时候才更新，而且如果想让 useEffect 或者 useMemo 访问最新的 state 值，需要将 state 添加到 deps 依赖项中。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["自定义 hooks 可以通过 useState + useRef 的特性，取其精华，更合理的管理 state。比如如下实现一个",(0,r.jsx)(n.strong,{children:"同步的state"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useSyncState(defaultValue){\n   const value = React.useRef(defaultValue)        /* useRef 用于保存状态 */\n   const [ ,forceUpdate ] = React.useState(null)   /* useState 用于更新组件 */\n   const dispatch = (fn) => {                      /* 模拟一个更新函数 */\n       let newValue\n       if( typeof fn === 'function' ){\n            newValue = fn(value.current)           /* 当参数为函数的情况 */\n       }else{\n           newValue = fn                           /* 当参数为其他的情况 */\n       }\n       value.current = newValue\n       forceUpdate({})                             /* 强制更新 */\n   } \n   return [  value , dispatch  ]                   /* 返回和 useState 一样的格式 */\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"useRef 用于保存状态 ，useState 用于更新组件。"}),"\n",(0,r.jsxs)(n.li,{children:["做一个 ",(0,r.jsx)(n.code,{children:"dispatch"})," 处理参数为函数的情况。在 dispatch 内部用 forceUpdate 触发真正的更新。"]}),"\n",(0,r.jsx)(n.li,{children:"返回的结构和 useState 结构相同。不过注意的是使用的时候要用 value.current 。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"使用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n    const [ data , setData  ] = useSyncState(0)\n    return <div style={{ marginTop:'50px' }} >\n        《React 进阶实践指南》 点赞 \uD83D\uDC4D { data.current }\n       <button onClick={ ()=> {\n           setData(num => num + 1)\n           console.log(data.current) //打印到最新的值\n       } } >点击</button>\n    </div>\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-操纵-dom--组件实例",children:["4 操纵 DOM / 组件实例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-操纵-dom--组件实例",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"自定义 hooks 也可以设计成对原生 DOM 的操纵控制。究其原理用 useRef 获取元素， 在 useEffect 中做元素的监听。"}),"\n",(0,r.jsx)(n.p,{children:"比如如下场景，用一个自定义 hooks 做一些基于 DOM 的操作 。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/* TODO: 操纵原生dom  */\nfunction useGetDOM(){\n    const dom = React.useRef()\n    React.useEffect(()=>{\n       /* 做一些基于 dom 的操作 */\n       console.log(dom.current)\n    },[])\n    return dom\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"自定义 useGetDOM ，用 useRef 获取 DOM 元素，在 useEffect 中做一些基于 DOM 的操作。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"使用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n    const dom = useGetDOM()\n    return <div ref={ dom } >\n        《React进阶实践指南》\n        <button >点赞</button>\n    </div>\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"5-执行副作用",children:["5 执行副作用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-执行副作用",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["自定义 hooks 也可以执行一些副作用，比如说监听一些 props 或 state 变化而带来的副作用。比如如下监听，当 ",(0,r.jsx)(n.code,{children:"value"})," 改变的时候，执行 ",(0,r.jsx)(n.code,{children:"cb"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function useEffectProps(value,cb){\n    const isMounted = React.useRef(false)\n    React.useEffect(()=>{\n         /* 防止第一次执行 */\n        isMounted.current && cb && cb()\n    },[ value ])\n    React.useEffect(()=>{\n          /* 第一次挂载 */\n         isMounted.current = true\n    },[])\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"用 useRef 保存是否第一次的状态。然后在一个 useEffect 改变加载完成状态。"}),"\n",(0,r.jsx)(n.li,{children:"只有当不是第一次加载且 value 改变的时候，执行回调函数 cb 。"}),"\n",(0,r.jsx)(n.li,{children:"当使用这个自定义 hooks 就可以监听，props 或者 state 变化。接下来尝试一下。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"使用组件和父组件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function Index(props){\n    useEffectProps( props.a ,()=>{/* 监听 a 变化 */\n        console.log('props a 变化:', props.a  )\n    } )\n    return <div>子组件</div>\n}\nexport default function Home(){\n    const [ a , setA ] = React.useState(0)\n    const [ b , setB ] = React.useState(0)\n    return <div>\n        <Index a={a}  b={b} />\n        <button onClick={()=> setA(a+1)} >改变 props a  </button>\n        <button onClick={()=> setB(b+1)} >改变 props b  </button>\n    </div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"2.gif"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"当动态监听 props.a ，props.a 变化，监听函数执行。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"6-持续维护中",children:["6 持续维护中～",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-持续维护中",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章节，第二十七章节，第十四章节为持续维护章节，会有更多精彩的自定义 hooks 设计场景。"}),"\n",(0,r.jsxs)(n.h2,{id:"四-总结",children:["四 总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章节学习的内容如下："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"自定义 hooks 的概念与特性。"}),"\n",(0,r.jsx)(n.li,{children:"自定义 hooks 设计方式。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"下一章将介绍自定义 hooks 实践。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let d=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F29.%E5%AE%9E%E8%B7%B5%E7%AF%87-%E8%87%AA%E5%AE%9A%E4%B9%89%20Hooks%20%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%8C%81%E7%BB%AD%EF%BC%89.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 全面理解自定义 hooks",id:"二-全面理解自定义-hooks",depth:2},{text:"1 概念",id:"1-概念",depth:3},{text:"2 特性",id:"2-特性",depth:3},{text:"① 驱动条件",id:"-驱动条件",depth:4},{text:"② 顺序原则",id:"-顺序原则",depth:4},{text:"③ 条件限定",id:"-条件限定",depth:4},{text:"④ 考虑可变性",id:"-考虑可变性",depth:4},{text:"⑤ 闭包效应",id:"-闭包效应",depth:4},{text:"三 自定义 hooks 设计",id:"三-自定义-hooks-设计",depth:2},{text:"1 接收状态",id:"1-接收状态",depth:3},{text:"2 存储｜管理状态",id:"2-存储管理状态",depth:3},{text:"3 更新状态",id:"3-更新状态",depth:3},{text:"4 操纵 DOM / 组件实例",id:"4-操纵-dom--组件实例",depth:3},{text:"5 执行副作用",id:"5-执行副作用",depth:3},{text:"6 持续维护中～",id:"6-持续维护中",depth:3},{text:"四 总结",id:"四-总结",depth:2}],title:"29.实践篇-自定义 Hooks 设计（持续）",headingTitle:"29.实践篇-自定义 Hooks 设计（持续）",frontmatter:{}}}}]);