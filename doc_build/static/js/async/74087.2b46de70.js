"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["74087"],{718613:function(e,n,s){s.r(n),s.d(n,{default:()=>y});var r=s(552676),c=s(740453);let l=s.p+"static/image/c75a16de7f4c1046f94676950515dad4.8ac68e06.webp",d=s.p+"static/image/2e53a8233f68422d3e9b23cc40722fcd.95b15c38.webp",a=s.p+"static/image/a22882164bcbc0b5406b9dff49d31f45.f7a7bfce.webp",i=s.p+"static/image/efa567099ab7b9db9e93b053f16e0677.3cab2767.webp",p=s.p+"static/image/47e0ddb5d966003afe5cc669a4cff25c.8e62e4d1.webp",o=s.p+"static/image/97988943266fb0dc4759bd799382f0a8.8785b245.webp",h=s.p+"static/image/45d1e47c9f5cbd71384314ba53ffa0ea.5e9a4093.webp",t=s.p+"static/image/f7638c56a36cc6e17dfc12cb09c5d117.0e875455.webp",j=s.p+"static/image/9d406cbd6cd6d00b95f9e2242fab79fc.ab4276bc.webp",x=s.p+"static/image/37c6482a5ca881309aa1cb75b2177009.913ce2c1.webp",b=s.p+"static/image/2b3b70a2234891fb4dab6c77f10b451c.eeede61b.webp",u=s.p+"static/image/9345e13a76ba222987efda4e642e2be0.8a1d7bbe.webp",g=s.p+"static/image/a0de977b3fbe5d02bf85224db0710487.08853612.webp",m=s.p+"static/image/03099368e5c0ba1959921c5c8054cd35.6aba13b5.webp",k=s.p+"static/image/34d1818107fe021f58042116034c0ab9.a7681e4c.webp",w=s.p+"static/image/7b7b8193482e16994e6a9f9d3f79d9b7.82c6382d.webp",f=s.p+"static/image/7f3a882d8b8bf3e3a6d64a531f45cc42.3ee15dcb.webp",v=s.p+"static/image/2f6b4b5e10ad9f88d270112c52453249.b8c01574.webp";function _(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",code:"code",h3:"h3",pre:"pre",blockquote:"blockquote",strong:"strong",ul:"ul",li:"li"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"24打包篇-webpack打包优化",children:["24.打包篇-Webpack打包优化",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24打包篇-webpack打包优化",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们来看看生产构建打包时，花费了多长时间？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["以上是其中一次的截图，经过我多次的验证（也就三五次），总结出平均生产环境下，打包时长为：",(0,r.jsx)(n.code,{children:"18s ~ 23s"}),"，这时间很长了，你想想，你打包构建一次 ",(0,r.jsx)(n.code,{children:"npm run build:render"}),"，要等 20s，这谁顶得住啊。为此，本章节将会做一些 ",(0,r.jsx)(n.code,{children:"webpack"})," 打包方面的优化。如果你对本章节内容兴趣不大，可以快速阅读或跳过。"]}),"\n",(0,r.jsxs)(n.h2,{id:"优化方案",children:["优化方案",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化方案",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"-优化一开发生产区分开",children:["\uD83D\uDD28 优化一：开发/生产区分开",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-优化一开发生产区分开",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们要区分出两套不同配置，因为一些配置在开发阶段是不需要去做的，你需要分辨好哪些工作仅在开发时要做，哪些工作是生产时要做。比如开发环境下，代码压缩、 提取 CSS 等工作就没必要了。"}),"\n",(0,r.jsxs)(n.p,{children:["很庆幸，我们一开始就区分了环境，如 ",(0,r.jsx)(n.code,{children:"webpack.xxx.dev.js"}),"、",(0,r.jsx)(n.code,{children:"webpack.xxx.prod.js"})," 等，不同环境做不同的事情。所以小伙伴们记住了，之后在你写代码做需求时，要有区分不同环境的意识。"]}),"\n",(0,r.jsxs)(n.h3,{id:"-优化二适当配置-loader降低-loader-的使用频率",children:["\uD83D\uDD28 优化二：适当配置 loader（降低 loader 的使用频率）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-优化二适当配置-loader降低-loader-的使用频率",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们摘一小段 ",(0,r.jsx)(n.code,{children:"webpack.render.base.js"})," 的代码出来看看"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx|ts|tsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n    ],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这段配置是合理的，因为我们配置了 ",(0,r.jsx)(n.code,{children:"exclude"}),"，它表示我们对于 ",(0,r.jsx)(n.code,{children:"js|jsx|ts|tsx"})," 类型文件的处理，是排除掉 ",(0,r.jsx)(n.code,{children:"node_modules"})," 目录文件夹的。"]}),"\n",(0,r.jsxs)(n.p,{children:["可能小伙伴不太明白，我换种说法，在 ",(0,r.jsx)(n.code,{children:"node_modules"})," 中肯定会存在许多 ",(0,r.jsx)(n.code,{children:"js、jsx、ts、tsx"})," 文件，假设我们这时候不配置 ",(0,r.jsx)(n.code,{children:"exclude"})," 属性，不将 ",(0,r.jsx)(n.code,{children:"node_modules"})," 排除出去，那么下面这段代码，你猜在开发时，webpack 会不会将其再次编译呢？"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import RcReduxModel from '../node_module/dist/index.js';\n// 又或者是\nimport lodash from 'lodash/index.js';\n"})}),"\n",(0,r.jsxs)(n.p,{children:["答案是会的！虽然说不会报错，但没必要，要知道 ",(0,r.jsx)(n.code,{children:"node_modules"})," 中的包都已经过打包编译，此时再进行一次编译，没任何意义，反而会降低速度。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果你不信，你可以将 ",(0,r.jsx)(n.code,{children:"webpack.render.base.js"})," 中带有 ",(0,r.jsx)(n.code,{children:"exclude"})," 的 loader 都注释掉，然后跑一下 ",(0,r.jsx)(n.code,{children:"npm run start:render"}),"，你会发现速度变慢！"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["与 ",(0,r.jsx)(n.code,{children:"exclude"})," 相反的是 ",(0,r.jsx)(n.code,{children:"include"}),"，你可通过这两个属性 ",(0,r.jsx)(n.code,{children:"exclude + include"})," 的完美结合，从而降低 loader 执行的频率，毕竟 loader 做转换也需要消耗一定时间。通过这种方式在一定程度上能提高 js 模块的打包速度。"]}),"\n",(0,r.jsxs)(n.p,{children:["这时候小伙伴就说了，我看 ",(0,r.jsx)(n.code,{children:"webpack.render.base.js"})," 中，这个 ",(0,r.jsx)(n.code,{children:"file-loader"})," 没有添加这个 ",(0,r.jsx)(n.code,{children:"exclude"})," 属性，我要不也添加一下吧？"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|jpeg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {\n              name: '[name]_[hash].[ext]',\n              outputPath: 'images/',\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这个就不需要添加了，为什么呢？首先它不像 js 那样有事先打包编译过的文件（可以不用做二次编译），实际上，你所有的图片资源文件，在打包过程中，都需要经过 ",(0,r.jsx)(n.code,{children:"file-loader"})," 去进行转换，将其打包到 dist 目录下，不然就会报错。这时候你加不加意义不大。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["这时就会有小伙伴提问了，那我如果用了一张第三方包内部的图片文件呢？比如我就是 ",(0,r.jsx)(n.code,{children:"import Avatar from 'node_module/a/dist/images/avatar.[hash].png'"}),"，那这时候会有问题吗？对于此问题，我想，你动手实践后，方可自己解答。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["总之，并不是每一个 loader 都需要添加 ",(0,r.jsx)(n.code,{children:"exclude/include"}),"，具体要看场景和哪种资源类型，记住一点，合理使用 loader，确实能降低 webpack 编译的速度。"]})}),"\n",(0,r.jsxs)(n.h3,{id:"-优化三寻找平衡以-url-loader-替代-file-loader",children:["\uD83D\uDD28 优化三：寻找平衡，以 url-loader 替代 file-loader",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-优化三寻找平衡以-url-loader-替代-file-loader",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["通过官方文档得知，我们能通过 ",(0,r.jsx)(n.a,{href:"https://www.webpackjs.com/loaders/file-loader/",target:"_blank",rel:"noopener noreferrer",children:"file-loader"})," 与 ",(0,r.jsx)(n.a,{href:"https://www.webpackjs.com/loaders/url-loader/",target:"_blank",rel:"noopener noreferrer",children:"url-loader"})," 完成对 Webpack 编译图片资源的配置。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Webpack 官网明确说明：",(0,r.jsx)(n.code,{children:"url-loader"}),"\xa0 功能类似于 \xa0",(0,r.jsx)(n.a,{href:"https://github.com/webpack-contrib/file-loader",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(n.code,{children:"file-loader"})}),"，但是在文件大小（单位 byte）低于指定的限制时，可以返回一个 DataURL。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["你可以这么理解，",(0,r.jsx)(n.code,{children:"url-loader"})," 功能是基于 ",(0,r.jsx)(n.code,{children:"file-loader"})," 之上，只是在 options 配置处，多了一个 ",(0,r.jsx)(n.code,{children:"limit"})," 属性，这就很有意思了，下面我们通过动手实践，改写一下我们的小册配置。"]}),"\n",(0,r.jsxs)(n.p,{children:["先去安装 ",(0,r.jsx)(n.code,{children:"url-loader"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install --save-dev url-loader\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后将 ",(0,r.jsx)(n.code,{children:"webpack/webpack.render.base.js"})," 改成下面这样"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(jpg|png|jpeg|gif)$/,\n        use: [\n          {\n            // \uD83D\uDC47 换成 url-loader\n            loader: 'url-loader',\n            options: {\n              limit: 2048,\n              name: '[name]_[hash].[ext]',\n              outputPath: 'images/',\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里我们设置 ",(0,r.jsx)(n.code,{children:"limit = 2048"}),"，意味着当图片小于 2kb 时，图片会自动转成 base64 格式，以字符串形式一起打包到 js 文件中，从而减少图片请求的数量，进而提升性能。而大于 2kb 的图片，",(0,r.jsx)(n.code,{children:"url-loader"})," 处理不了，转手甩给 ",(0,r.jsx)(n.code,{children:"file-loader"})," 去处理。（所以说 url-loader 是基于 file-loader 之上）"]}),"\n",(0,r.jsxs)(n.p,{children:["我们来对比一下，将 ",(0,r.jsx)(n.code,{children:"file-loader"})," 改成 ",(0,r.jsx)(n.code,{children:"url-loader"})," 之后的一些变化，由于我们本地是采用 ",(0,r.jsx)(n.code,{children:"webpack-dev-server"})," 起的服务，所以在开发环境下的 dist 目录是看不到编译后的文件，因为编译后的文件都保存到了内存当中。所以我们跑 ",(0,r.jsx)(n.code,{children:"npm run build:render"})," 来看看对比"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"采用 file-loader"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["此时会有很多图片资源被打包到 ",(0,r.jsx)(n.code,{children:"dist/images"})," 文件夹下，共 12 张图片"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["我们去 ",(0,r.jsx)(n.code,{children:"index.[hash].js"})," 文件中，查找一下 ",(0,r.jsx)(n.code,{children:"base64"})," 关键字，只能找到 20 条记录"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"url-loader"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["很明显，dist 目录下的 ",(0,r.jsx)(n.code,{children:"dist/images"})," 文件夹，一下子少了好多图片，现在只有 4 张图片"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["我们去 ",(0,r.jsx)(n.code,{children:"index.[hash].js"})," 文件中，查找一下 ",(0,r.jsx)(n.code,{children:"base64"})," 关键字，找到 28 条记录"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["当然也不是一定说 ",(0,r.jsx)(n.code,{children:"url-loader"})," 牛逼过 ",(0,r.jsx)(n.code,{children:"file-loader"}),"，这更是一个取舍过程。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"比如你设置 limit 过大，就会导致图片转成 base64 后，加入到打包好到 js 文件中，这无异增大 js 的体积。"}),"\n",(0,r.jsx)(n.li,{children:"比如你通过 url-loader 一次性将图片都转成 base64 打包进 js 文件，这些图片无法做到按需加载"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"总之，决定权在你手中，你需要找到资源大小与请求数量之间的一个平衡。"})}),"\n",(0,r.jsxs)(n.h3,{id:"-优化四resolve-查找文件后缀的配置",children:["\uD83D\uDD28 优化四：resolve 查找文件后缀的配置",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-优化四resolve-查找文件后缀的配置",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["以 ",(0,r.jsx)(n.code,{children:"webpack/webpack.render.base.js"})," 为例，我们摘抄一下 resolve 的代码片段"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\nmodule.exports = {\n  resolve: {\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["解读一下这段代码，",(0,r.jsx)(n.code,{children:"resolve"})," 配置 Webpack 如何寻找模块所对应的文件。我们配置了 ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/resolve/#resolveextensions",target:"_blank",rel:"noopener noreferrer",children:"extensions"}),"，表示在导入语句中没带文件后缀时，Webpack 会自动带上后缀去尝试访问文件是否存在。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们配置中，配置了 ",(0,r.jsx)(n.code,{children:"extensions: ['.js', '.jsx', '.ts', '.tsx']"}),"，意味着当遇到 ",(0,r.jsx)(n.code,{children:"import A from './A'"})," 时，会先寻找 ",(0,r.jsx)(n.code,{children:"A.js"}),"、找不到就去找 ",(0,r.jsx)(n.code,{children:"A.jsx"}),"，之后依次找 ",(0,r.jsx)(n.code,{children:"A.ts"}),"、再到 ",(0,r.jsx)(n.code,{children:"A.tsx"}),"，最后还是找不到，就会报错。"]}),"\n",(0,r.jsx)(n.p,{children:"这是合理的，但是总会有一些小伙伴心生歹念，看到可以这么写，然后就想，我能不能这么配呢？"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\nmodule.exports = {\n  resolve: {\n    extensions: ['.less', '.png', '.jpg', '.gif', '.js', '.jsx', '.ts', '.tsx'],\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这样在引入文件时，我都不用写后缀了，多爽啊，但你想想，你要写成这鬼样，每次你引入文件时，你都需要通过 fs 文件系统去一次次的查找匹配，查找 ",(0,r.jsx)(n.code,{children:".less"})," 时，调用 Node 底层的能力，查找也耗时，发现找不到 ",(0,r.jsx)(n.code,{children:".less"})," 后缀的文件，再去找 ",(0,r.jsx)(n.code,{children:".png"})," 后缀的文件，以此类推，写的越多，调用底层次数越多，查找更耗时，导致 Webpack 的编译速度更慢。"]}),"\n",(0,r.jsxs)(n.p,{children:["这里就不贴图演示了，小伙伴们可以私下修改 ",(0,r.jsx)(n.code,{children:"extensions"})," 的配置，对比一下时长。"]}),"\n",(0,r.jsxs)(n.h3,{id:"-优化五合理利用-plugins-进行代码压缩",children:["\uD83D\uDD28 优化五：合理利用 Plugins 进行代码压缩",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-优化五合理利用-plugins-进行代码压缩",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"可以这么理解，Plugins 相当于 Webpack 的生命周期函数，通过 Plugins ，我们能在 Webpack 执行到某个周期的时候，去做一些事情。在构建生成线上代码时，为了保证文件体积小，用户加载速度能快一些，我们需要对代码进行压缩。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"CSS 部分的代码压缩"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来我们通过 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/optimize-css-assets-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"optimize-css-assets-webpack-plugin"})," 插件对 CSS 代码进行压缩。让我们先来安装，记住了，这里需要安装 4.0.0 版本"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["⚠ 来自官方说明：For webpack v3 or below please use\xa0",(0,r.jsx)(n.code,{children:"optimize-css-assets-webpack-plugin@3.2.0"}),". The\xa0",(0,r.jsx)(n.code,{children:"optimize-css-assets-webpack-plugin@4.0.0"}),"\xa0version and above supports webpack v4."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install optimize-css-assets-webpack-plugin@4.0.0 --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["根据官方提供的文档，我们来修改一下 ",(0,r.jsx)(n.code,{children:"webpack/webpack.render.prod.js"})," 配置"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.prod.js\n\nconst webpackMerge = require('webpack-merge');\nconst renderBaseConfig = require('./webpack.render.base.js');\nconst OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');\n\nconst prodConfig = {\n  mode: 'production',\n  plugins: [new OptimizeCssAssetsPlugin({})],\n};\n\nmodule.exports = webpackMerge.merge(renderBaseConfig, prodConfig);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["同时我们还能采用 ",(0,r.jsx)(n.a,{href:"https://v4.webpack.docschina.org/plugins/mini-css-extract-plugin/",target:"_blank",rel:"noopener noreferrer",children:"mini-css-extract-plugin"})," 插件将 CSS 提取到单独的文件中。它为每个包含 CSS 的 JS 文件创建一个 CSS 文件。让我们来安装它"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install mini-css-extract-plugin@^1.0.0 --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["请注意啊，这里不要成 @2.x 版本，不然就会报这个问题: ",(0,r.jsx)(n.a,{href:"https://github.com/webpack-contrib/mini-css-extract-plugin/issues/779",target:"_blank",rel:"noopener noreferrer",children:"TypeError: Invalid value used in weak set"})]}),"\n",(0,r.jsxs)(n.p,{children:["然后根据官方文档配置，来修改一下 ",(0,r.jsx)(n.code,{children:"webpack/webpack.render.prod.js"})," 配置"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.prod.js\n\nconst webpackMerge = require('webpack-merge');\nconst renderBaseConfig = require('./webpack.render.base.js');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\nconst OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin');\n\nconst prodConfig = {\n  mode: 'production',\n  plugins: [\n    new MiniCssExtractPlugin({\n      filename: '[name].[contenthash].css',\n      chunkFilename: '[id].[contenthash].css',\n    }),\n    new OptimizeCssAssetsPlugin({}),\n  ],\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [MiniCssExtractPlugin.loader, 'css-loader'],\n      },\n    ],\n  },\n};\n\nmodule.exports = webpackMerge.merge(renderBaseConfig, prodConfig);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"JS 部分的代码压缩"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"webpack.UglifyjsWebpackPlugin"})," 是官方维护的插件，但它是单线程压缩代码，意味着每个 js 文件需要排队，依次进行压缩。但压缩代码的时候它又很耗时，它得先将代码转成 AST 抽象语法树，再用一些规则去分析处理 AST，巴拉巴拉一顿操作之后再进行压缩。"]}),"\n",(0,r.jsx)(n.p,{children:"每个文件都需要这么整，这谁顶得住，所以我们需要探寻一条新的道路，通过查询，有两个新的插件能去实现"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/terser-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:" ✨ terser-webpack-plugin"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/webpack-parallel-uglify-plugin",target:"_blank",rel:"noopener noreferrer",children:"webpack-parallel-uglify-plugin"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["到底用哪个呢？通过对比下载量，并且看官方说明，",(0,r.jsx)(n.code,{children:"terser-webpack-plugin"})," 为 Webpack 明媒正娶，专门维护的插件，那么我们就用此插件进行优化，先来安装下"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install terser-webpack-plugin --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["老规矩，看文档，修改 ",(0,r.jsx)(n.code,{children:"webpack/webpack.render.prod.js"}),"，部分代码省略"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/* eslint-disable @typescript-eslint/no-require-imports */\nconst webpackMerge = require('webpack-merge');\nconst renderBaseConfig = require('./webpack.render.base.js');\nconst TerserPlugin = require('terser-webpack-plugin');\n\nconst prodConfig = {\n  optimization: {\n    minimizer: [\n      new TerserPlugin({\n        cache: true,\n        parallel: true,\n        sourceMap: false,\n      }),\n    ],\n  },\n};\n\nmodule.exports = webpackMerge.merge(renderBaseConfig, prodConfig);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["让我们来对不对比，下面这张图是为使用自带的 ",(0,r.jsx)(n.code,{children:"UglifyJsPlugin"}),"，打包时长在 16s 左右"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["通过 ",(0,r.jsx)(n.code,{children:"terser-webpack-plugin"})," 之后，在第一次构建打包相对较久，但之后的构建打包，由于我们设置了 ",(0,r.jsx)(n.code,{children:"cache"})," 以及 ",(0,r.jsx)(n.code,{children:"parallel"})," 属性，时间变得更快，经过三次构建，时长均在 10s 左右"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["那么就会有小伙伴疑惑了，为啥你不在 ",(0,r.jsx)(n.code,{children:"webpack.render.dev.js"})," 中也做代码压缩呢？你要知道，",(0,r.jsx)(n.strong,{children:"做任何事都需要成本的"}),"，你压缩代码也需要耗费时间，我们之所以在生产环境做代码压缩是因为我们期望用户加载速度能快一些，",(0,r.jsx)(n.code,{children:"有舍才有的"}),"，我们开发人员忍住构建时压缩代码的等待时间，就能让用于加载资源速度能更快一些。"]}),"\n",(0,r.jsxs)(n.h3,{id:"-优化六happypack-加速构建",children:["\uD83D\uDD28 优化六：HappyPack 加速构建",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-优化六happypack-加速构建",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"运行在 NodeJS 上的 Webpack 是单线程模型，对于单线程来说，每一件事情都需要挨个处理，要知道 Webpack 构建可是对大量文件做解析处理的，一个一个的来，岂不是要把人逼疯？"}),"\n",(0,r.jsxs)(n.p,{children:["那么能否让 Webpack 同一时刻处理多个任务，发挥多核 CPU 电脑优势，从而提高我们的构建速度？肯定有人研究过这个问题，并且找到了解决方案，该方案就是：",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/happypack",target:"_blank",rel:"noopener noreferrer",children:"happypack"})]}),"\n",(0,r.jsx)(n.p,{children:"先来安装一下"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install happypack --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后我们修改一下 ",(0,r.jsx)(n.code,{children:"webpack/webpack.render.base.js"})," 文件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\nconst path = require('path');\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n// \uD83D\uDC47 引入 happypack\nconst HappyPack = require('happypack');\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx|ts|tsx)$/,\n        exclude: /node_modules/,\n        // use: {\n        //   loader: 'babel-loader',\n        // },\n        loader: 'HappyPack/loader?id=visResumeMookHappyPack',\n      },\n    ],\n  },\n  plugins: [\n    new HappyPack({\n      id: 'visResumeMookHappyPack',\n      threads: 8,\n      loaders: [\n        {\n          loader: 'babel-loader',\n        },\n      ],\n    }),\n  ],\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后我们来试试，看看打包的时长"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"giao ！ 反倒是时间被拉长了？这...于是我就去搜索，看看网上有没有什么方案，无意中发现有人遇到过着累问题，我丢，这坑爹了，开启多线程，CPU 上升，如果此时 CPU 满了的话，整体速度会变慢。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["我们可以通过 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/speed-measure-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"speed-measure-webpack-plugin"})," 插件来看看 Webpack 处理的时长，先来安装一下"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save-dev speed-measure-webpack-plugin\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后修改一下配置"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\nconst path = require('path');\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n// \uD83D\uDC47 引入 happypack\nconst HappyPack = require('happypack');\n// \uD83D\uDC47 引入速度分析插件\nconst SpeedMeasurePlugin = require('speed-measure-webpack-plugin');\nconst smp = new SpeedMeasurePlugin();\n\nmodule.exports = smp.wrap({\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx|ts|tsx)$/,\n        exclude: /node_modules/,\n        // use: {\n        //   loader: 'babel-loader',\n        // },\n        loader: 'HappyPack/loader?id=visResumeMookHappyPack',\n      },\n    ],\n  },\n  plugins: [\n    new HappyPack({\n      id: 'visResumeMookHappyPack',\n      threads: 8,\n      loaders: [\n        {\n          loader: 'babel-loader',\n        },\n      ],\n    }),\n  ],\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"此时我们可以在终端中看到相关的一些信息"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"天啊，这就很蛋疼了，用了 happypack 之后反而变慢了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"总之，这个插件大家自行衡量，这边小册就不采用此方案进行处理，深入去了解为什么，是一件很有意思的事，包括你可以顺道扩宽一下单线程/多线程、进程与线程的相关知识。"})}),"\n",(0,r.jsxs)(n.h3,{id:"-优化七第三方包打成-dlljs-文件",children:["\uD83D\uDD28 优化七：第三方包打成 dll.js 文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-优化七第三方包打成-dlljs-文件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们在项目中，会引用一些第三方包。比如"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport logger from 'redux-logger';\nimport { Provider } from 'react-redux';\nimport { createStore, applyMiddleware, combineReducers } from 'redux';\n"})}),"\n",(0,r.jsx)(n.p,{children:"还有很多第三方库没列举出来，那么对于这种第三方包，不需要每一次打包都重新构建，可以将它作为一个稳定的版本，在第一次时将第三方打包即可，之后每次打包都用上一次的即可。"}),"\n",(0,r.jsx)(n.p,{children:"接下来，我们需要分两步执行"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"将第三方包打成一个文件，只生成一次"}),"\n",(0,r.jsx)(n.li,{children:"使用第三方模块时，是从 dll 文件，而非从 node_modules"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["先来实现第一步，在 webpack 文件夹下，新增 ",(0,r.jsx)(n.code,{children:"dll"})," 相关的配置，新增 ",(0,r.jsx)(n.code,{children:"webpack.dll.base.js"}),"、",(0,r.jsx)(n.code,{children:"webpack.dll.prod.js"}),"，然后编写一下相关代码"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["小伙伴不要奇怪怎么没有 dev 环境下，因为开发环境下从 ",(0,r.jsx)(n.code,{children:"node_module"})," 取，并没啥毛病"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"我们之所以把第三方包打成一个文件，是因为每次打包构建，这些第三方包又要打一次，比较耗时而已，如果你能接受，其实不用 dll 也是可行的。"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.dll.base.js\n\nconst path = require('path');\nmodule.exports = {\n  entry: {\n    // \uD83D\uDC47 我这里将 lodash 也放在 reacts 中了，实际上是可以拆分的\n    reacts: ['react', 'react-dom', 'redux', 'react-redux', 'lodash'],\n  },\n  output: {\n    library: '[name]',\n    filename: '[name].dll.js',\n    path: path.resolve(__dirname, '../dist/dll'),\n  },\n};\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.dll.prod.js\n\nconst webpackMerge = require('webpack-merge');\nconst dllBaseConfig = require('./webpack.dll.base.js');\n\nmodule.exports = webpackMerge.merge(dllBaseConfig, {\n  mode: 'production',\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时我们去 ",(0,r.jsx)(n.code,{children:"package.json"})," 中添加一下打包成 dll 的脚本命令"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "build:dll": "webpack --config ./webpack/webpack.dll.prod.js"\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["然后我们在终端中执行一下 ",(0,r.jsx)(n.code,{children:"npm run build:dll"}),"，可以看到在 dist 目录下，存在此文件夹"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["我们点进去看看，可以看到有 ",(0,r.jsx)(n.code,{children:"react"})," 源码、",(0,r.jsx)(n.code,{children:"react-dom"})," 源码等，这时候我们将第三方打到一个文件 ",(0,r.jsx)(n.code,{children:"reacts.dll.js"}),"，但我们还没使用它，该如何使用？往 HTML 上加文件。"]}),"\n",(0,r.jsxs)(n.p,{children:["如何在静态模版 HTML 中添加静态资源？可以通过 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/add-asset-html-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"add-asset-html-webpack-plugin"})," 插件进行处理，让我们来安装一下"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"npm install add-asset-html-webpack-plugin --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后前往 ",(0,r.jsx)(n.code,{children:"webpack/webpack.render.base.js"})," 中添加一下代码，部分代码省略"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');\n\nmodule.exports = {\n  plugins: [\n    new AddAssetHtmlWebpackPlugin({\n      // \uD83D\uDC47 引入刚才的 reacts.dll.js 文件\n      filepath: path.resolve(__dirname, '../dist/dll/reacts.dll.js'),\n    }),\n  ],\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们启动一下项目，看看有没有添加 ",(0,r.jsx)(n.code,{children:"reacts.dll.js"})," 文件进来。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run start:main\nnpm run start:render\n"})}),"\n",(0,r.jsx)(n.p,{children:"打开控制台，看看有没有引入呢？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["第一步我们实现了，已经生成好了 dll 文件，但好像并没什么用，我们的第三方仍然还是从 ",(0,r.jsx)(n.code,{children:"node_modules"})," 取的，所以接下来我们要借助 ",(0,r.jsx)(n.code,{children:"webpack.DLLPlugin"})," 进行实现。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们先来修改 ",(0,r.jsx)(n.code,{children:"webpack/webpack.dll.base.js"})," 文件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.dll.base.js\n\nconst path = require('path');\nconst webpack = require('webpack');\n\nmodule.exports = {\n  entry: {\n    reacts: ['react', 'react-dom', 'redux', 'react-redux', 'lodash'],\n  },\n  output: {\n    library: '[name]',\n    filename: '[name].dll.js',\n    path: path.resolve(__dirname, '../dist/dll'),\n  },\n  plugins: [\n    // \uD83D\uDC47 新增变量\n    new webpack.DllPlugin({\n      name: '[name]',\n      path: path.resolve(__dirname, '../dist/dll/[name].manifest.json'),\n    }),\n  ],\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后我们再到 ",(0,r.jsx)(n.code,{children:"webpack/webpack.render.base.js"})," 中，修改一下代码，部分代码省略"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const webpack = require('webpack');\n\nmodule.exports = {\n  plugins: [\n    new webpack.DllReferencePlugin({\n      manifest: path.resolve(__dirname, '../dist/dll/reacts.manifest.json'),\n    }),\n  ],\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["当我们使用第三方包时，会先在 ",(0,r.jsx)(n.code,{children:"reacts.manifest.json"})," 找第三方模块的映射关系，如果存在映射关系，就不需要打包进来，它直接从全局变量拿，因为我们通过 ",(0,r.jsx)(n.code,{children:"webpack.DllPlugin"})," 定义了全局变量，拿的是 ",(0,r.jsx)(n.code,{children:"reacts.dll.js"}),"，那如果没有映射关系，就会从 ",(0,r.jsx)(n.code,{children:"node_modules"})," 中拿过来打包。"]}),"\n",(0,r.jsx)(n.p,{children:"此时我们来完整打包一下"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"// 删除dist目录\nrm -rf dist\n// 第三方包生成一个文件\nnpm run build:dll\n// 构建 Electron\nnpm run build:main\n// 构建 React\nnpm run build:render\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们可以看到，在 ",(0,r.jsx)(n.code,{children:"dist/dll"})," 目录下，存在着 ",(0,r.jsx)(n.code,{children:"reacts.dll.js"})," 和 ",(0,r.jsx)(n.code,{children:"reacts.manifest.json"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["感兴趣的可以点进去看看 ",(0,r.jsx)(n.code,{children:"reacts.manifest.json"})," 到底是个啥东西"]}),"\n",(0,r.jsx)(n.p,{children:"最后我们来看看通过 dll 之后的打包时长有多少"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"最后",children:["最后",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"其实提高 Webpack 的打包速度还有很多，上面只是常见的几种方式，更多优化技巧小伙伴们可以私下翻阅一些资料进行知识的补充。好记性不如烂笔头，看完一定要动手实战，才能进步。"})]})}function P(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(_,{...e})}):_(e)}let y=P;P.__RSPRESS_PAGE_META={},P.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F24.%E6%89%93%E5%8C%85%E7%AF%87-Webpack%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"优化方案",id:"优化方案",depth:2},{text:"\uD83D\uDD28 优化一：开发/生产区分开",id:"-优化一开发生产区分开",depth:3},{text:"\uD83D\uDD28 优化二：适当配置 loader（降低 loader 的使用频率）",id:"-优化二适当配置-loader降低-loader-的使用频率",depth:3},{text:"\uD83D\uDD28 优化三：寻找平衡，以 url-loader 替代 file-loader",id:"-优化三寻找平衡以-url-loader-替代-file-loader",depth:3},{text:"\uD83D\uDD28 优化四：resolve 查找文件后缀的配置",id:"-优化四resolve-查找文件后缀的配置",depth:3},{text:"\uD83D\uDD28 优化五：合理利用 Plugins 进行代码压缩",id:"-优化五合理利用-plugins-进行代码压缩",depth:3},{text:"\uD83D\uDD28 优化六：HappyPack 加速构建",id:"-优化六happypack-加速构建",depth:3},{text:"\uD83D\uDD28 优化七：第三方包打成 dll.js 文件",id:"-优化七第三方包打成-dlljs-文件",depth:3},{text:"最后",id:"最后",depth:2}],title:"24.打包篇-Webpack打包优化",headingTitle:"24.打包篇-Webpack打包优化",frontmatter:{}}}}]);