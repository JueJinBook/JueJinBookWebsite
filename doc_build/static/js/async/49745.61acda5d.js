"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["49745"],{410659:function(e,n,s){s.r(n),s.d(n,{default:()=>i});var t=s(552676),r=s(740453);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",pre:"pre",code:"code",strong:"strong",ol:"ol"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"29-工程化使用-jest-进行单元测试",children:["29 工程化：使用 Jest 进行单元测试",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#29-工程化使用-jest-进行单元测试",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"保证代码的稳定性和可靠性，是软件工程的一个重要目标。其中，软件测试的作用毫无疑问，是非常大的。"}),"\n",(0,t.jsx)(n.p,{children:"软件测试又分为单元测试、集成测试和功能测试，这三者分别对应软件开发的不同阶段。其中，集成测试和功能测试往往由专门的质量部门（QA）工程师来负责，而单元测试则属于模块开发者需要关注的范畴。这一节课，我们就来谈谈单元测试。"}),"\n",(0,t.jsx)(n.p,{children:"所谓单元测试，就是对系统模块的每个功能单元进行的测试，一般针对的是函数、类或单个组件，不涉及系统和集成。"}),"\n",(0,t.jsx)(n.p,{children:"单元测试的好处很明显，完善的单元测试用例能够极大地保证系统模块的稳定和可靠。尤其当我们对系统模块进行升级或重构的时候，运行单元测试能够确保我们的修改不会对原有的功能造成影响，产生预料不到的 Bug。一般来说，一个比较优质的模块都会有配套的单元测试用例。"}),"\n",(0,t.jsxs)(n.h2,{id:"为-babel-插件项目添加单元测试",children:["为 Babel 插件项目添加单元测试",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为-babel-插件项目添加单元测试",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["还记得前面的章节中，我们实现过一个 Babel 插件，用来支持向量和矩阵的运算。这个插件的完整代码我放在了 ",(0,t.jsx)(n.a,{href:"https://github.com/akira-cn/babel-plugin-transform-gl-matrix",target:"_blank",rel:"noopener noreferrer",children:"GitHub 仓库"})," 中，你可以直接 clone 下来。"]}),"\n",(0,t.jsx)(n.p,{children:"接下来，我要讲一讲如何给这个插件添加单元测试。"}),"\n",(0,t.jsxs)(n.h2,{id:"选择并安装单元测试框架",children:["选择并安装单元测试框架",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#选择并安装单元测试框架",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["可以选择的 JavaScript 单元测试框架非常多，比较有名的有 Mocha、Jasmine、AVA、Jest 等等。在这里，选择 ",(0,t.jsx)(n.a,{href:"https://jestjs.io/",target:"_blank",rel:"noopener noreferrer",children:"Jest"})," 作为我们的单元测试框架。"]}),"\n",(0,t.jsx)(n.p,{children:"Jest 框架的特点有："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"由 Facebook 开发和维护"}),"\n",(0,t.jsx)(n.li,{children:"开箱即用配置少，API 简单"}),"\n",(0,t.jsx)(n.li,{children:"支持断言（Assertion）和仿真（Mock）"}),"\n",(0,t.jsx)(n.li,{children:"支持快照（Snap）测试"}),"\n",(0,t.jsx)(n.li,{children:"基于 Istanbul 的测试覆盖度报告"}),"\n",(0,t.jsx)(n.li,{children:"智能并行测试，执行速度快"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Jest 安装非常简单，几乎不用安装其他的依赖，只需要安装 jest 一个模块。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install --save-dev jest\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后，我们在 package.json 中的 scripts 字段进行相应的配置:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n \xa0...\n \xa0"scripts": {\n \xa0 \xa0... 省略 ...\n \xa0 \xa0"test": "jest",\n  },\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:['如上配置所示，我们将 test 命令设置为 "jest"。jest 默认执行的是项目目录下所有 ',(0,t.jsx)(n.code,{children:"*.test.js"})," 文件。然后，在 test 目录下，创建",(0,t.jsx)(n.code,{children:"index.test.js"}),"文件，暂时让它的内容为空，运行",(0,t.jsx)(n.code,{children:"npm test"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"这时候，命令行终端将输出了一些错误信息："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:" FAIL  test/index.test.js\n  ● Test suite failed to run\n​\n \xa0  [BABEL]: You appear to be using a native ECMAScript module plugin, which is only supported when running Babel asynchronously. (While processing: /.../babel-plugin-transform-gl-matrix/src/index.js)\n"})}),"\n",(0,t.jsx)(n.p,{children:"报错是因为，我们的模块采用了 ESModule 的方式导出，而 Jest 默认是采用 CommonJS 的方式导入的。"}),"\n",(0,t.jsxs)(n.p,{children:["那在这里，我们可以使用最新的 Jest 原生支持 ESM 的特性，不过需要安装",(0,t.jsx)(n.code,{children:"cross-env"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install --save-dev cross-env\n"})}),"\n",(0,t.jsx)(n.p,{children:"安装之后，我们修改 package.json 中的 scripts 字段："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n \xa0...\n \xa0"scripts": {\n \xa0 \xa0... 省略 ...\n \xa0 \xa0"test": "cross-env NODE_OPTIONS=--experimental-vm-modules jest",\n  },\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["这样，我们再次运行",(0,t.jsx)(n.code,{children:"npm test"}),"，就可以看到以下输出："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:" FAIL  src/vector2d.test.js\n  ● Test suite failed to run\n​\n \xa0  Your test suite must contain at least one test.\n​\n \xa0 \xa0  at onResult (node_modules/@jest/core/build/TestScheduler.js:173:18)\n​\nTest Suites: 1 failed, 1 total\nTests: \xa0 \xa0 \xa0 0 total\nSnapshots: \xa0 0 total\nTime: \xa0 \xa0 \xa0 \xa01.696 s\nRan all test suites.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["因为这时候我们的",(0,t.jsx)(n.code,{children:"vector2d.test.js"}),"文件为空文件，并没有添加任何的测试用例，所以报了上面这个错。"]}),"\n",(0,t.jsx)(n.p,{children:"现在我们可以添加测试用例："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"import {\n \xa0vec2,\n \xa0vec3,\n \xa0mat2,\n \xa0mat2d,\n \xa0mat3,\n \xa0mat4,\n \xa0quat,\n \xa0quat2,\n \xa0glMatrix,\n} from 'gl-matrix';\n​\nglMatrix.setMatrixArrayType(Array);\n​\ntest('mat2d expand', () => {\n \xa0const arr = [1, 2, 3, 4, 5, 6];\n \xa0const m1 = mat2d(...arr);\n \xa0const m2 = mat2d.fromValues(...arr);\n \xa0expect(m1).toEqual(m2);\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这时候，如果我们运行上面这段测试用例，ESLint 就会报告错误。因为 test 和 expect 未定义，所以我们需要修改一下配置文件",(0,t.jsx)(n.code,{children:".eslintrc.js"}),"，添加 env 配置项",(0,t.jsx)(n.code,{children:"jest: true"}),"，这样 eslint 就可以识别 jest 框架定义的方法了。"]}),"\n",(0,t.jsxs)(n.p,{children:["Jest 框架以 test 方法定义测试用例，它的第一个参数是用例名，第二个参数是一个回调函数，表示一个测试用例。框架会自动执行这个测试用例中的代码。Jest 支语义化的断言，可以用非常语义化的方式书写测试规则，比如上面代码中的",(0,t.jsx)(n.code,{children:"expect(m1).toBe(m2)"})," ，它的含义是期望 m1 等于 m2。这里 Jest 会深度比较两个对象的每个属性，所以相当于 deepEquals。关于 Jest 支持的各种断言，可以查看",(0,t.jsx)(n.a,{href:"https://jestjs.io/docs/en/expec",target:"_blank",rel:"noopener noreferrer",children:"官方文档"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["有了测试用例，我们可以执行",(0,t.jsx)(n.code,{children:"npm test"}),"，测试用例运行通过，控制台上的输出结果如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"> jest\n​\n PASS  test/index.test.js\n  ✓ mat2d expand (2 ms)\n​\nTest Suites: 1 passed, 1 total\nTests: \xa0 \xa0 \xa0 1 passed, 1 total\nSnapshots: \xa0 0 total\nTime: \xa0 \xa0 \xa0 \xa00.795 s, estimated 6 s\nRan all test suites.\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"异步测试",children:["异步测试",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步测试",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"Jest 框架中，test 的回调函数不仅可以支持普通函数，也可以支持异步函数。所以，如果要测试异步方法，可以如下面代码这么用（async/await），非常方便。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"test('some case', async () => {\n  const result = await foo.bar();\n  expect(result).toBe('something');\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"另外，如果异步函数不是 Promise 规范的，而是回调函数，Jest 也能支持，比如："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"test('fetch data', (done) => {\n  function callback(data) {\n    expect(data).toBe('something');\n    done()\n  }\n  fetchData(url, callback);\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"上面的代码，我们给 test 的回调函数指定参数 done，那么只有当 done 被调用时，测试用例才会运行结束。"}),"\n",(0,t.jsxs)(n.h2,{id:"测试覆盖率",children:["测试覆盖率",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试覆盖率",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"除了运行测试用例，Jest 内置了测试覆盖率检查。所谓测试覆盖率，是指所有的测试用例执行后，究竟覆盖了多少代码。"}),"\n",(0,t.jsxs)(n.p,{children:["例如，假设模块",(0,t.jsx)(n.code,{children:"foo.js"}),"有一个函数如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"function foo(a, b) {\n  if(a > 0 && b > 0) {\n    return 10;\n  } else if(b > 0) {\n    return 0;\n  } else {\n    return -10;\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"foo.test.js"}),"单元测试用例如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"test('foo', () => {\n  expect(foo(1, 2)).toBe(10);\n  expect(foo(-1, -2)).toBe(-10);\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["那么单元测试代码覆盖到了",(0,t.jsx)(n.code,{children:"if(a > 0 && b > 0)"}),"的这个逻辑分支，以及最后的",(0,t.jsx)(n.code,{children:"else"}),"这个逻辑分支，但是没有覆盖到",(0,t.jsx)(n.code,{children:"if(b > 0)"}),"这个逻辑分支。单元测试代码覆盖检查，会把未能覆盖到的代码逻辑给检测出来。"]}),"\n",(0,t.jsx)(n.p,{children:"测试覆盖度是评判一个库代码可靠性和质量的一个重要衡量标准，一般来说，测试覆盖度越高，库的可靠性和质量越高。"}),"\n",(0,t.jsxs)(n.p,{children:["要用 Jest 检查测试覆盖率也非常简单，我们只需在",(0,t.jsx)(n.code,{children:"package.json"}),"文件中添加一个脚本命令",(0,t.jsx)(n.code,{children:"test:coverage"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{\n  ...\n  "scripts": {\n    ...省略...\n\n    "test": "cross-env NODE_OPTIONS=--experimental-vm-modules jest",\n    "test:coverage": "cross-env NODE_OPTIONS=--experimental-vm-modules jest --coverage",\n  },\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["那么我们运行",(0,t.jsx)(n.code,{children:"npm run test:coverage"}),"，就能运行单元测试并报告测试覆盖率结果了，最终命令行终端输出如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"> jest --coverage\n\n PASS  test/foo.test.js\n PASS  test/index.test.js\n----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |      80 |    83.33 |     100 |      80 |                   \n foo.js   |      80 |    83.33 |     100 |      80 | 5                 \n----------|---------|----------|---------|---------|-------------------\n\nTest Suites: 2 passed, 2 total\nTests:       22 passed, 22 total\nSnapshots:   0 total\nTime:        0.903 s, estimated 1 s\nRan all test suites.\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这个结果中显示，目前的代码覆盖率是 80%，没有覆盖到的代码是",(0,t.jsx)(n.code,{children:"foo.js"}),"第 5 行，我们看一下",(0,t.jsx)(n.code,{children:"foo.js"}),"文件，第 5 行对应的代码是："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"  else if(b > 0) {\n    return 0;\n  }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["那么我们在",(0,t.jsx)(n.code,{children:"foo.test.js"}),"再添加一个断言："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"import foo from './foo.js'\n\ntest('foo', () => {\n  expect(foo(1, 2)).toBe(10);\n  expect(foo(-1, -2)).toBe(-10);\n  expect(foo(-1, 2)).toBe(0);\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后重新运行",(0,t.jsx)(n.code,{children:"npm run test:coverage"}),"，这次的结果如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"> jest --coverage\n\n PASS  test/foo.test.js\n PASS  test/index.test.js\n----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |                   \n foo.js   |     100 |      100 |     100 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\n\nTest Suites: 2 passed, 2 total\nTests:       22 passed, 22 total\nSnapshots:   0 total\nTime:        0.818 s, estimated 1 s\nRan all test suites.\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样，我们的单元测试覆盖度达到了完全的 100%。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"注意"}),"，因为我们对",(0,t.jsx)(n.code,{children:"index.test.js"}),"测试的是 Babel 插件转换的",(0,t.jsx)(n.code,{children:"gl-matrix"})," API，而这个是通过第三方库方式载入的，所以这部分代码是不会被测试覆盖率检查的。如果要保证 case 覆盖",(0,t.jsx)(n.code,{children:"gl-matrix"}),"库的所有 API，我们可以将",(0,t.jsx)(n.code,{children:"gl-matrix"}),"拉取到项目本地进行测试，而不是直接通过 NPM 安装。"]}),"\n",(0,t.jsxs)(n.h2,{id:"测试驱动开发tdd",children:["测试驱动开发（TDD）",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试驱动开发tdd",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在软件工程领域，有一种开发模式叫做测试驱动开发，英文全称 Test-Driven Development，简称 TDD。"}),"\n",(0,t.jsxs)(n.p,{children:["TDD 的开发流程是，先编写测试用例代码，然后再编写实际的逻辑代码，也就是说，我们在开发插件的时候，可以先写",(0,t.jsx)(n.code,{children:"index.test.js"}),"，完善其中的测试用例，然后再实现插件逻辑，最终让所有的测试用例都成功通过。"]}),"\n",(0,t.jsx)(n.p,{children:"如果我们使用测试驱动开发，会让我们的库更加稳定可靠，我们所有的代码都有对应的测试用例，尽可能达成测试覆盖度 100%，这是一种值得去实践的良好的开发模式，而且特别适合于开发通用的 JS 库和基础模块。"}),"\n",(0,t.jsx)(n.p,{children:"在本课程中，由于篇幅所限，就不详细展开介绍测试驱动开发了，但是有兴趣的同学，可以在项目中实践。关于前端测试和 TDD，我们以后会在前端测试的专门课程中再深入介绍。"}),"\n",(0,t.jsxs)(n.h2,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"Jest 是一种 JavaScript 单元测试框架。它的安装和使用非常简单："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["安装 jest 包： ",(0,t.jsx)(n.code,{children:"npm install --save-dev jest"})]}),"\n",(0,t.jsxs)(n.li,{children:["如果要支持 ESM，还要安装 cross-env 包： ",(0,t.jsx)(n.code,{children:"npm install --save-dev cross-env"})]}),"\n",(0,t.jsx)(n.li,{children:"在 package.json 文件中配置 Jest 脚本命令："}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'"scripts": {\n  "test": "cross-env NODE_OPTIONS=--experimental-vm-modules jest",\n  "test:coverage": "cross-env NODE_OPTIONS=--experimental-vm-modules jest --coverage",\n}\n'})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsx)(n.li,{children:"运行测试命令行：npm test，默认执行项目目录下所有 *.test.js 文件"}),"\n",(0,t.jsx)(n.li,{children:"运行 npm run test:coverage 命令可以查看该项目的测试覆盖率"}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}let i=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F29%20%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9A%E4%BD%BF%E7%94%A8%20Jest%20%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.md"]={toc:[{text:"为 Babel 插件项目添加单元测试",id:"为-babel-插件项目添加单元测试",depth:2},{text:"选择并安装单元测试框架",id:"选择并安装单元测试框架",depth:2},{text:"异步测试",id:"异步测试",depth:2},{text:"测试覆盖率",id:"测试覆盖率",depth:2},{text:"测试驱动开发（TDD）",id:"测试驱动开发tdd",depth:2},{text:"小结",id:"小结",depth:2}],title:"29 工程化：使用 Jest 进行单元测试",headingTitle:"29 工程化：使用 Jest 进行单元测试",frontmatter:{}}}}]);