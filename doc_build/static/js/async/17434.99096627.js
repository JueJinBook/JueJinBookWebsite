"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["17434"],{578977:function(n,e,t){t.r(e),t.d(e,{default:()=>A});var o=t(552676),r=t(740453);let s=t.p+"static/image/ba2b9d026f6aa460cb6cc7d691d2c9c3.fce6ebb3.webp",i=t.p+"static/image/24e03f740d5615ce12cb17d84a8d2a30.7b7689ea.webp",d=t.p+"static/image/edfc87a61f76dd6cab4420972553ad99.2277cc31.webp",c=t.p+"static/image/3b7702ee968534cc13037378387398f1.2fac0520.webp",l=t.p+"static/image/c31b77cc620d388e86d4f15f649596fd.c5ebaa0e.webp",a=t.p+"static/image/a169c3af0e11fc49341bdd5f2cb580ea.6bb0d19e.webp",p=t.p+"static/image/c6bd07a4e859ac2562bf1bcc679c7c42.a3e428b1.webp",h=t.p+"static/image/5d619a268fc7770858a6b59f71371eea.1b5e1689.webp",m=t.p+"static/image/e09141487ce443880fca2b20206bb506.4e4f5f2f.webp",x=t.p+"static/image/7f281bc5c0bdafaa2e47b3f374d4ab81.6bb0d19e.webp";function u(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",strong:"strong",img:"img",blockquote:"blockquote",ul:"ul",li:"li",pre:"pre",ol:"ol",h3:"h3"},(0,r.ah)(),n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.h1,{id:"30期望篇-可视化自定义独特的简历模版",children:["30.期望篇-可视化自定义独特的简历模版",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#30期望篇-可视化自定义独特的简历模版",children:"#"})]}),"\n",(0,o.jsxs)(e.h2,{id:"前言",children:["前言",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["本章节并不会教你去实现一份可视化自定义的简历模版，",(0,o.jsx)(e.code,{children:"授人以鱼不如授人以渔"}),"，阿宽希望你阅读完此章节之后，能散发思维，自己动手实现，",(0,o.jsx)(e.strong,{children:"举一隅不以三隅反，则不复也"}),"。"]}),"\n",(0,o.jsxs)(e.p,{children:["我们要做一个什么样的东西呢？看下图你大致也能猜到，没错，好听点叫做可视化低代码平台，但实际上，",(0,o.jsx)(e.strong,{children:"懂得都懂"}),"。抛开所有东西不说，我们仅为了学习，来了解一下其中某些功能是如何实现。"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsxs)(e.p,{children:["⚠️ ",(0,o.jsxs)(e.strong,{children:["本章节不会手把手再带大家去实现这个平台了，工作量与阅读量较多，但如果你相信阿宽，你可以结合文章的核心内容，再去 ",(0,o.jsx)(e.a,{href:"https://github.com/PDKSophia/dom-ui-toolbar",target:"_blank",rel:"noopener noreferrer",children:"dom-ui-toolbar"})," 结合代码阅读，最后动手实操。纸上得来终觉浅，绝知此事要躬行！"]})]}),"\n"]}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsxs)(e.p,{children:["本项目代码在：✨ ",(0,o.jsx)(e.a,{href:"https://github.com/PDKSophia/dom-ui-toolbar",target:"_blank",rel:"noopener noreferrer",children:"dom-ui-toolbar"}),"，感兴趣的小伙伴可以前往阅读源码"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"期望你看完本章节之后，能结合线上代码，动手实操，甚至于能完成可视化自定义独特的简历模版～"})}),"\n",(0,o.jsxs)(e.h2,{id:"00-前期准备",children:["00. 前期准备",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#00-前期准备",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"如上图所示，我们的页面布局共分为三处："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"左侧：物料市场"}),"\n",(0,o.jsx)(e.li,{children:"中间：内容画布"}),"\n",(0,o.jsx)(e.li,{children:"右侧：操作区"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"一个操作流程分为：从左侧物料市场拖拽一个组件至画布，激活当前选中的组件，可通过右侧修改数值以达到组件样式的实时更新。"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"初始状态"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"组件拖拽进画布"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"组件自由移动、层级覆盖"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"组件内容更新，样式修改"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,o.jsxs)(e.h2,{id:"01-布局实现",children:["01. 布局实现",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#01-布局实现",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["接下来均是实现过程的一些思考，具体动手实操请结合",(0,o.jsx)(e.a,{href:"https://github.com/PDKSophia/dom-ui-toolbar",target:"_blank",rel:"noopener noreferrer",children:"github 仓库"}),"。接下来都不需要小伙伴们写代码，小伙伴们只需要理解即可～"]}),"\n",(0,o.jsxs)(e.p,{children:["我们先在 ",(0,o.jsx)(e.a,{href:"https://github.com/PDKSophia/dom-ui-toolbar",target:"_blank",rel:"noopener noreferrer",children:"dom-ui-toolbar"})," 项目的 ",(0,o.jsx)(e.code,{children:"src/container"})," 文件夹下，建好三个文件夹，对外导出相应组件。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'// 左侧物料市场\nexport default function Material() {\n  return (\n    <div styleName="material">\n      <div styleName="logo">物料市场</div>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'// 中间组件画布\nexport default function WinCenter() {\n  return <div styleName="content">中间画布</div>;\n}\n'})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'// 右侧操作区\nexport default function Toolbar() {\n  return <div styleName="toolbar">操作区</div>;\n}\n'})}),"\n",(0,o.jsxs)(e.p,{children:["现在共有 ",(0,o.jsx)(e.code,{children:"Material 物料市场"}),"、",(0,o.jsx)(e.code,{children:"Toolbar 操作区"}),"、",(0,o.jsx)(e.code,{children:"WinCenter 中心画布"})," 三大组件，那么我们的布局组件是这样的。",(0,o.jsx)(e.a,{href:"https://github.com/PDKSophia/dom-ui-toolbar/blob/master/example/src/index.tsx",target:"_blank",rel:"noopener noreferrer",children:"源代码点击这里"})]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"// https://github.com/PDKSophia/dom-ui-toolbar/blob/master/example/src/index.tsx\n\nimport Material from './container/Material';\nimport Toolbar from './container/Toolbar';\nimport WinCenter from './container/WinCenter';\n\nfunction Main() {\n  const toolbarRef = useRef(null);\n  const materialRef = useRef(null);\n  return (\n    <React.Fragment>\n      <div ref={materialRef} styleName=\"material\">\n        <Material />\n      </div>\n      <div styleName=\"content\">\n        <WinCenter />\n      </div>\n      <div ref={toolbarRef} styleName=\"action\">\n        <Toolbar />\n      </div>\n    </React.Fragment>\n  );\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:"现在我们完成了布局，左侧物料市场，中间画布，右侧操作区，闭上眼睛，脑补一下，此时页面上分三大块，但都还是空白，接下来我们一步步讲解其中的功能点。"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"在这之前，请允许我给大家看一个大致的流程图"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,o.jsxs)(e.h2,{id:"02-物料市场的设计",children:["02. 物料市场的设计",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#02-物料市场的设计",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"搞清楚了流程之后，接下来的开发就比较简单了。"}),"\n",(0,o.jsxs)(e.p,{children:["我们在 Material 文件夹下，新增了两个物料组件：",(0,o.jsx)(e.code,{children:"Button"})," 与 ",(0,o.jsx)(e.code,{children:"Text"}),"，"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,o.jsxs)(e.p,{children:["大家思考一下，在 ",(0,o.jsx)(e.code,{children:"Material/index.tsx"})," 中，我们该如何写这段代码呢？第一时间撸下了这段代码"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:'import Button from \'./components/Button\';\nimport Text from \'./components/Text\';\n\nfunction Material() {\n  return (\n    <div styleName="material">\n      <div styleName="logo">物料市场</div>\n      <div styleName="flex">\n        <Button />\n        <Text />\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsxs)(e.p,{children:["但这样写会有什么问题？第一，如果你想做拖拽组件效果，那么你需要在每一个组件的代码实现中，写一段重复的代码，如下，以 ",(0,o.jsx)(e.code,{children:"Button"})," 组件为例"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"function Button() {\n  return (\n    <div\n      styleName=\"btn\"\n      draggable={true}\n      onDragStart={(e) => e.dataTransfer.setData('componentName', 'Button')}\n    >\n      基础按钮\n    </div>\n  );\n}\n\nexport default Button;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["第二，当你往 ",(0,o.jsx)(e.code,{children:"Material/components"})," 新增物料组件时，你还需要到根组件将新增的组件引入。意味着，新增/删除一个物料，你都需要修改 ",(0,o.jsx)(e.code,{children:"Material/index.tsx"})," 入口文件。有没有什么办法解决？"]}),"\n",(0,o.jsxs)(e.p,{children:["我们可以这样写，将所有物料统一经过 ",(0,o.jsx)(e.code,{children:"index.ts"})," 管理，对外导出"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"export { default as Button } from './Button';\nexport { default as Text } from './Text';\n"})}),"\n",(0,o.jsxs)(e.p,{children:["然后我们在物料市场的",(0,o.jsx)(e.code,{children:"Material/index.tsx"}),"入口文件稍微修改"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"import React from 'react';\nimport './index.less';\nimport * as ComponentsList from './components';\nimport MyScrollBox from '@components/Base/MyScrollBox';\n\nfunction Material() {\n  const height = document.body.clientHeight;\n\n  return (\n    <div styleName=\"material\">\n      <MyScrollBox maxHeight={height}>\n        <div styleName=\"logo\">物料市场</div>\n        <div styleName=\"flex\">\n          {Object.keys(ComponentsList).map(\n            (componentName: string, index: number) => {\n              // \uD83D\uDC47 这个是需要渲染的组件实例\n              const RenderComponent = ComponentsList[componentName];\n              return (\n                <div styleName=\"item\" key={`${componentName}_${index}`}>\n                  <RenderComponent\n                    key={`${componentName}_${index}`}\n                    draggable={true}\n                    onDragStart={(e: React.DragEvent<HTMLDivElement>, componentRefs?: HTMLDivElement) => {}}\n                  />\n                </div>\n              );\n            }\n          )}\n        </div>\n      </MyScrollBox>\n    </div>\n  );\n}\n\nexport default Material;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["以上是物料市场的实现（还没有实现 ",(0,o.jsx)(e.code,{children:"onDragStart()"})," 方法），接下来我们来实现一下中间画布。"]}),"\n",(0,o.jsxs)(e.h2,{id:"03-组件画布设计实现",children:["03. 组件画布设计实现",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#03-组件画布设计实现",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["中间区域就是一个“画布”，它并不是我们所理解的 ",(0,o.jsx)(e.code,{children:"canvas"}),(0,o.jsxs)(e.strong,{children:["，它是一个大的 ",(0,o.jsx)(e.code,{children:"div"})," 元素，相对定位，所有拖拽进来的组件在该画布上，都是绝对定位"]}),"。"]}),"\n",(0,o.jsxs)(e.p,{children:["画布维护一套 ",(0,o.jsx)(e.code,{children:"editorComponentList"})," 数组，每次从物料市场拖拽组件过来，都会 push 进该数组。画布进行数组遍历，从而展示。下面看一下基本代码"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'function WinCenter() {\n  const { editorComponentList, dispatchAddComponentAction } = useEditorStoreModel();\n\n  return (\n    <div styleName="winCenter">\n      <div\n        styleName="editor-canvas"\n        onDrop={(e: React.DragEvent<HTMLDivElement>) => {}}\n        onDragOver={(e: React.DragEvent<HTMLDivElement>) => {\n          e.preventDefault();\n        }}\n      >\n        <Editor />\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsxs)(e.p,{children:["我们来看看 ",(0,o.jsx)(e.code,{children:"<Editor />"})," 组件主要做了什么事情"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"function Editor() {\n  const { editorComponentList } = useEditorStoreModel();\n\n  // 组件随便移动\n  function handleOnMouseDown(e: React.MouseEvent, componentIndex: number) {}\n\n  // 点击选中一个组件\n  function handleOnComponentClick(e: React.MouseEvent, componentIndex: number) {}\n\n  // 点击画布空白区域\n  function handleUnComponentAreaClick(e: React.MouseEvent) {}\n  \n  return (\n    <div styleName=\"editor\" onMouseDown={handleUnComponentAreaClick}>\n      // step1. 遍历所有加入的组件数组\n      {editorComponentList.length > 0 &&\n        editorComponentList.map((EditComponent: Types.IStoreComponentProps, componentIndex: number) => {\n          return (\n            <div\n              styleName=\"wrapper-component\"\n              key={EditComponent.componentId}\n              style={pickStyle(EditComponent.style, ['left', 'top', 'zIndex', 'cursor'])}\n\n              // step2. 元素拖拽，鼠标按下之后的回调事件\n              onMouseDown={(e: React.MouseEvent) => {\n                handleOnMouseDown(e, componentIndex);\n              }}\n\n              // step3. 点击选中当前需要操作的组件\n              onClick={(e: React.MouseEvent) => {\n                handleOnComponentClick(e, componentIndex);\n              }}\n            >\n              {EditComponent.componentInstance && (\n                <EditComponent.componentInstance\n                  componentKey={EditComponent.componentId}\n                  componentInnerText={EditComponent.componentInnerText}\n                  componentStyles={omitStyle(EditComponent.style, ['left', 'top', 'zIndex', 'cursor'])}\n                />\n              )}\n            </div>\n          );\n        })}\n    </div>\n  );\n}\n\nexport default Editor;\n"})}),"\n",(0,o.jsxs)(e.p,{children:["可能小伙伴们还是有些懵，我们来捋一捋。首先，我们在 Redux 中存储着一个组件数组，取名为 ",(0,o.jsx)(e.code,{children:"editorComponentList"}),"，数组的每一项均符合 ",(0,o.jsx)(e.code,{children:"IStoreComponentProps"})," 类型声明"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"export interface IStoreComponentProps {\n  componentId: string; // 组件id\n  componentInstance: any; // 组件实例\n  style: React.CSSProperties; // 组件样式\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["然后我们在物料市场拖拽至画布时，我们执行 ",(0,o.jsx)(e.code,{children:"onDragStart()"})," 中，写下了这段代码"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"onDragStart={(e: React.DragEvent<HTMLDivElement>, componentRefs?: HTMLDivElement) => {\n  // \uD83D\uDC49 step1. 传递拖拽组件名\n  e.dataTransfer.setData('componentName', componentName);\n  if (componentRefs) {\n    const componentStore = {\n      ...initComponentStyleStore.Base,\n      ...initComponentStyleStore[componentName]\n    };\n    // \uD83D\uDC49 step2. 得到拖拽组件的 style\n    const styles = getDomStyle(componentRefs, componentStore);\n\n    // \uD83D\uDC49 step3. 传递拖拽组件的文本内容\n    e.dataTransfer.setData('componentInnerText', componentRefs.innerText);\n\n    // \uD83D\uDC49 step4. 传递拖拽组件的样式\n    e.dataTransfer.setData('componentDomStyle', JSON.stringify(styles));\n  }\n}}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["当组件进入到画布，鼠标松开的那一瞬间，我们执行了 ",(0,o.jsx)(e.code,{children:"onDrop()"})," 方法，来看看做了什么"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"onDrop={(e: React.DragEvent<HTMLDivElement>) => {\n  // \uD83D\uDC49 step1. 阻止冒泡\n  e.preventDefault();\n  e.stopPropagation();\n\n  // \uD83D\uDC49 step2. 得到拖拽组件名\n  const componentName = e.dataTransfer.getData('componentName');\n\n  // \uD83D\uDC49 step3. 得到拖拽组件的文本内容\n  const componentInnerText = e.dataTransfer.getData('componentInnerText');\n\n  // \uD83D\uDC49 step4. 得到拖拽组件的样式\n  let componentDomStyle: React.CSSProperties = {};\n  try {\n    componentDomStyle = JSON.parse(e.dataTransfer.getData('componentDomStyle'));\n  } catch (err) {\n    componentDomStyle = {};\n  }\n\n  // \uD83D\uDCA5 \uD83D\uDC49 step5. 通过 dispatch action 的方式，将拖拽组件存到 redux 中\n  dispatchAddComponentAction(componentName, componentInnerText, {\n    ...componentDomStyle,\n    left: e.nativeEvent.offsetX,\n    top: e.nativeEvent.offsetY,\n    // \uD83D\uDC47 注意这里，因为组件都是绝对定位，所以组件间的层级关系\n    // \uD83D\uDC47 通过z-index进行修改，先加入的 z-index 低，后加入的 z-index 高\n    zIndex: editorComponentList.length\n  });\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["上面注释写的非常清楚，这时候我们通过 dispatch 了一个 action，将拖拽组件追加到 redux 的 ",(0,o.jsx)(e.code,{children:"editorComponentList"}),"，来看看这个 ",(0,o.jsx)(e.code,{children:"dispatchAddComponentAction()"})," 做了什么。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"// \uD83D\uDC49 step1.导入所有的物料，目的是拿到实例\nimport * as ComponentsList from '@container/Material/components';\n\n/**\n * 添加一个组件\n * @param componentName 组件名\n * @param componentInnerText 组件文本内容\n * @param componentStyles 组件自定义样式\n */\nconst dispatchAddComponentAction = (\n  componentName: string,\n  componentInnerText?: string,\n  componentStyles?: React.CSSProperties\n) => {\n  // \uD83D\uDC49 step2. 得到组件实例，目的是为了渲染\n  const componentInstance = ComponentsList[componentName];\n\n  // \uD83D\uDC49 step3. 拷贝一份之前的 editorComponentList\n  let nextStore = cloneDeep(editorComponentList);\n\n  // \uD83D\uDC49 step4. 追加一条数据\n  nextStore.push({\n    componentId: createUUid(),\n    componentName,\n    componentInstance,\n    componentInnerText,\n    style: componentStyles,\n  });\n  setEditorComponentList(nextStore);\n};\n"})}),"\n",(0,o.jsxs)(e.p,{children:["此时我们只需要在画布中将 ",(0,o.jsx)(e.code,{children:"editorComponentList"})," 取出来渲染即可。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"{\n  editorComponentList.length > 0 &&\n    editorComponentList.map(\n      (EditComponent: Types.IStoreComponentProps, componentIndex: number) => {\n        return (\n          <div\n            styleName=\"wrapper-component\"\n            key={EditComponent.componentId}\n            style={pickStyle(EditComponent.style, ['left', 'top', 'zIndex', 'cursor'])}\n            onMouseDown={(e: React.MouseEvent) => {\n              handleOnMouseDown(e, componentIndex);\n            }}\n            onClick={(e: React.MouseEvent) => {\n              handleOnComponentClick(e, componentIndex);\n            }}\n          >\n            {EditComponent.componentInstance && (\n              <EditComponent.componentInstance\n                componentKey={EditComponent.componentId}\n                componentInnerText={EditComponent.componentInnerText}\n                componentStyles={omitStyle(EditComponent.style, ['left', 'top', 'zIndex', 'cursor'])}\n              />\n            )}\n          </div>\n        );\n      }\n    );\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["以上我们就完成了从物料市场拖拽组件到画布渲染的主流程之一。请注意，因为我们的画布定位是 ",(0,o.jsx)(e.code,{children:"relative"}),"，组件在画布下的定位是 ",(0,o.jsx)(e.code,{children:"absolute"}),"，通过 ",(0,o.jsx)(e.code,{children:"left、top"})," 进行位置的偏移，通过 ",(0,o.jsx)(e.code,{children:"z-index"})," 实现后拖拽的组件能覆盖在之前拖拽的组件。"]}),"\n",(0,o.jsxs)(e.h2,{id:"04-操作区的实现",children:["04. 操作区的实现",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#04-操作区的实现",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["上面是完成了 ",(0,o.jsx)(e.code,{children:"物料市场 -> 画布"})," 的实现，接下来我们继续完成一下操作区的实现。操作区我们可以看看共分为五大块。"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"布局"}),"\n",(0,o.jsx)(e.li,{children:"填充"}),"\n",(0,o.jsx)(e.li,{children:"文字"}),"\n",(0,o.jsx)(e.li,{children:"内容"}),"\n",(0,o.jsx)(e.li,{children:"代码"}),"\n"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"const ToolbarMemo = useMemo(() => {\n  if (currentEditorComponent) {\n    return (\n      <MyScrollBox maxHeight={height}>\n        <Layout styles={currentEditorComponent?.style || {}} onUpdateStyles={onUpdateStyles} />\n        <Fill styles={currentEditorComponent?.style || {}} onUpdateStyles={onUpdateStyles} />\n        {ResourceContentList.includes(currentEditorComponent.componentName) && (\n          <Font styles={currentEditorComponent?.style || {}} onUpdateStyles={onUpdateStyles} />\n        )}\n        {ResourceContentList.includes(currentEditorComponent.componentName) && (\n          <Content\n            componentInnerText={currentEditorComponent?.componentInnerText || ''}\n            onUpdateInnerText={onUpdateInnerText}\n          />\n        )}\n        {currentEditorComponent?.style && (\n          <Code styles={currentEditorComponent?.style} />\n        )}\n      </MyScrollBox>\n    );\n  } else {\n    return <MyEmpty full={false} description=\"暂无选中组件\" />;\n  }\n}, [currentEditorComponent]);\n"})}),"\n",(0,o.jsxs)(e.p,{children:["上面的代码想必小伙伴们都能理解，那么 ",(0,o.jsx)(e.code,{children:"currentEditorComponent"})," 是什么呢？这里指的是我们在画布中鼠标点击选中的组件。我们前面说了，画布中的组件渲染是遍历 ",(0,o.jsx)(e.code,{children:"editorComponentList"}),"，而 ",(0,o.jsx)(e.code,{children:"editorComponentList"})," 数组是在我们从物料市场拖拽进画布时，push 到数组中的。"]}),"\n",(0,o.jsxs)(e.p,{children:["当我们选中一个组件 ",(0,o.jsx)(e.code,{children:"currentEditorComponent"})," 后，将其数据存至 redux 中，然后 ",(0,o.jsx)(e.code,{children:"<Toolbar />"})," 组件直接从 redux 中取数据，做对应的渲染。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"/**\n * editorComponentList 在遍历时，注册 onClick 事件\n * 触发点击事件，表示选中当前组件，记录当前组件\n */\nconst dispatchSetCurrentEditorComponentAction = (componentIndex: number) => {\n  setCurrentEditorComponentIndex(componentIndex);\n  setCurrentEditorComponent(editorComponentList[componentIndex]);\n};\n"})}),"\n",(0,o.jsxs)(e.h2,{id:"05-选中组件动态修改-style",children:["05. 选中组件动态修改 style",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#05-选中组件动态修改-style",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["如果你仔细看代码，上面的代码你会发现一个叫做 ",(0,o.jsx)(e.code,{children:"onUpdateStyles()"})," 的方法。让我们再来捋一捋。"]}),"\n",(0,o.jsxs)(e.p,{children:["首先我们在画布众多组件中，点击选中了一个组件，将其存到 redux，此时此刻的 ",(0,o.jsx)(e.code,{children:"currentEditorComponent"})," 是存在数据的。在操作组件里，我们从 redux 中取出 ",(0,o.jsx)(e.code,{children:"currentEditorComponent"})," 数据，进行展示。"]}),"\n",(0,o.jsxs)(e.p,{children:["由于我们的操作区均是由 ",(0,o.jsx)(e.code,{children:"Input"})," 输入框组成，当输入框内容 ",(0,o.jsx)(e.code,{children:"onChange"})," 之后，我们将修改后的数据覆盖原有的数值，从而达到动态修改 style 的功能。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"const dispatchUpdateComponentStylesAction = (componentStyles: React.CSSProperties) => {\n  const nextStore = cloneDeep(editorComponentList);\n  const updateComponent = {\n    ...nextStore[currentEditorComponentIndex],\n    style: { ...componentStyles },\n  };\n  nextStore[currentEditorComponentIndex] = updateComponent;\n  setEditorComponentList(nextStore);\n  setCurrentEditorComponent(updateComponent);\n};\n"})}),"\n",(0,o.jsxs)(e.h2,{id:"06-组件在画布中随意移动",children:["06. 组件在画布中随意移动",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#06-组件在画布中随意移动",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["上边我们实现了 ",(0,o.jsx)(e.code,{children:"物料市场 -> 拖拽组件 -> 画布 -> 选中组件 -> 操作区修改"})," 的主逻辑，接下来我们来实现组件的随意移动。"]}),"\n",(0,o.jsx)(e.p,{children:"试想一哈，你拖拽组件时，手一抖，心一慌，不小心松开了鼠标，组件在画布上出现了位置偏差，本来你想拖到右边的，不小心拖到了左边。咋整？"}),"\n",(0,o.jsx)(e.p,{children:"所以支持组件在画布中随意移动是重中之重，接下来我们来实现一下此功能。为了更好的直观表达，阿宽花了一张图"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,o.jsx)(e.p,{children:"如上图所示，组件从位置 A 移动到 A'"}),"\n",(0,o.jsxs)(e.p,{children:["我们只需要知道移动之后， ",(0,o.jsx)(e.code,{children:"left'"})," 和 ",(0,o.jsx)(e.code,{children:"top'"})," 的值，然后修改该组件的 style 即可"]}),"\n",(0,o.jsx)(e.p,{children:"这是一道数学题，已知 A 的 clientX 和 clientY，以及 left 和 top，并且现在我们还能知道 A' 的 clientX' 与 clientY'，求 A' 的 left' 和 top'，思考一下，该如何计算？"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:'// 组件\n<div styleName="editor" onMouseDown={handleUnComponentAreaClick}>\n  {editorComponentList.length > 0 &&\n    editorComponentList.map(\n      (EditComponent: Types.IStoreComponentProps, componentIndex: number) => {\n        return (\n          <div\n            styleName="wrapper-component"\n            key={EditComponent.componentId}\n            onMouseDown={(e: React.MouseEvent) => {\n              handleOnMouseDown(e, componentIndex);\n            }}\n          >\n            // ...\n          </div>\n        );\n      }\n    )}\n</div>\n'})}),"\n",(0,o.jsxs)(e.p,{children:["上面的伪代码应该看得懂，重点在于 ",(0,o.jsx)(e.code,{children:"onMouseDown"})," 做了什么事，来看看 ",(0,o.jsx)(e.code,{children:"handleOnMouseDown"})," 具体干了啥？"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"export default function () {\n  const { editorComponentList, dispatchUpdateComponentPositionAction } = useEditorStoreModel();\n\n  return (componentIndex: number, e: React.MouseEvent) => {\n    const currentEditComponent: Types.IStoreComponentProps = editorComponentList[componentIndex];\n\n    if (e.button != 0) {\n      // 屏蔽左键以外的按键\n      return;\n    }\n\n    // 获得最开始，鼠标按下时的客户端区域的坐标\n    const x = e.clientX;\n    const y = e.clientY;\n\n    // 获得元素之前的定位偏移量\n    const top = Number(currentEditComponent?.style?.top) || 0;\n    const left = Number(currentEditComponent?.style?.left) || 0;\n\n    // 是否鼠标按下\n    let isMouseDown = false;\n\n    // 设置手势\n    const cursor = 'move';\n\n    const mouseMove = (moveEvent: MouseEvent) => {\n      isMouseDown = true;\n\n      // 获得元素移动过程中的客户端区域坐标\n      const currentX = moveEvent.clientX;\n      const currentY = moveEvent.clientY;\n\n      const repaintStyle = {\n        ...currentEditComponent.style,\n        top: currentY - y + top,\n        left: currentX - x + left,\n        cursor,\n      };\n\n      dispatchUpdateComponentPositionAction(componentIndex, repaintStyle);\n    };\n\n    const mouseUp = () => {\n      isMouseDown = false;\n      document.removeEventListener('mousemove', mouseMove);\n      document.removeEventListener('mouseup', mouseUp);\n    };\n    document.addEventListener('mousemove', mouseMove);\n    document.addEventListener('mouseup', mouseUp);\n  };\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:"代码几乎都有注释，我就不过多赘述了。"}),"\n",(0,o.jsxs)(e.h2,{id:"07-清除画布",children:["07. 清除画布",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#07-清除画布",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["这很简单，点个按钮，将 redux 中的 ",(0,o.jsx)(e.code,{children:"editorComponentList"})," 数据清空即可。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"/**\n * 清空画布，清除所有组件\n */\nconst dispatchClearTotalComponentAction = () => {\n  setEditorComponentList([]);\n  setCurrentEditorComponentIndex(-1);\n  setCurrentEditorComponent(null);\n};\n"})}),"\n",(0,o.jsxs)(e.h2,{id:"08-删除某一组件",children:["08. 删除某一组件",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#08-删除某一组件",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"目前只支持选中一个组件，点击删除按钮进行删除。"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"/**\n * 从数组中删除组件\n */\nconst dispatchDeleteComponentAction = (componentIndex: number) => {\n  let nextStore = cloneDeep(editorComponentList);\n  nextStore.splice(componentIndex, 1);\n  setEditorComponentList(nextStore);\n};\n"})}),"\n",(0,o.jsxs)(e.p,{children:["如果你有兴趣，你可以做多个组件的删除，比如当我摁住 ",(0,o.jsx)(e.code,{children:"commandOrControl"})," 键，再点击鼠标，这时候可以选中多个进行删除。"]}),"\n",(0,o.jsx)(e.p,{children:"再或者你可以鼠标右键进行快捷删除。没有做不到的，只有想不到的。"}),"\n",(0,o.jsxs)(e.h2,{id:"09-撤销",children:["09. 撤销",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#09-撤销",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"撤销是什么呢？说白了你反悔了。那如何实现呢？不好意思，阿宽还没实现此功能，但有过一些方案的对比。有两种方式实现："}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"快照方式"}),"\n",(0,o.jsx)(e.li,{children:"动作记录方式"}),"\n"]}),"\n",(0,o.jsxs)(e.h3,{id:"快照方式",children:["快照方式",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#快照方式",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,o.jsx)(e.p,{children:"以快照方式，存储当前画布的完整信息，记录每次操作后的快照，撤销则以上一次快照为准进行恢复，特点是："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"数据存储的是所有画布数据"}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"在乎的是最终的结果"}),"，以结果进行的快照存储"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["那有什么问题？举个例子，存储的快照只有 ABC 三个数据，期间我做了添加 DEF 数据的操作，此时撤销，恢复快照，则只会恢复 ABC，但我的预期是恢复到 ABCDE。可能小伙伴会觉得，为什么只能恢复到 ABC 呢？因为我们需要考虑快照的存储时长。究竟是 ",(0,o.jsx)(e.code,{children:"n/ms"})," 还是 ",(0,o.jsx)(e.code,{children:"n/s"})," 都需要经过考虑。"]}),"\n",(0,o.jsx)(e.p,{children:"它的优点是什么呢？相对简单，适用本地，不适用于多人协作（虽然这里我们不考虑多人协同）"}),"\n",(0,o.jsxs)(e.h3,{id:"动作记录方式",children:["动作记录方式",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#动作记录方式",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,o.jsx)(e.p,{children:"以动作记录方式，存储的是当前的每一次动作，定义一个栈，每次的动作均入栈。在我们执行撤销操作时，出栈，执行对应的撤销事件响应，如："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"我们删除了一个组件，对应的，在撤销时，我们执行添加组件事件，把删除的加回来，以达到恢复原状态"}),"\n",(0,o.jsx)(e.li,{children:"再比如我们把组件宽度变大，对应的，在撤销时，我们执行缩小组件宽度，把宽度改回原来的大小，以达到恢复原状态"}),"\n",(0,o.jsx)(e.li,{children:"......"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"这种方式的特点主要是:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["存储的是动作，可以细化到你做了什么，",(0,o.jsx)(e.strong,{children:"在乎的是过程"}),"，相对快照方式更加颗粒化"]}),"\n",(0,o.jsx)(e.li,{children:"比较复杂，但可以做到协同编辑，可以多人协作(但还需要考虑更多，比较是否会冲突等)"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"以上就是撤销实现的两种方式，虽然我还没实现，但这两种思路，希望能给小伙伴们带来一些帮助，感兴趣的可以延伸一波，扩宽一下思路，比如额外查阅资料看看如何实现协同编辑，多人协作。"}),"\n",(0,o.jsxs)(e.h2,{id:"10-调整组件层级",children:["10. 调整组件层级",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10-调整组件层级",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["我们的画布是 ",(0,o.jsx)(e.code,{children:"position: relative"}),"，而组件是 ",(0,o.jsx)(e.code,{children:"position: absolute"}),"，所以我们的组件可以在画布中任何布局定位，但组件之间的层级关系是通过 ",(0,o.jsx)(e.code,{children:"z-index"})," 来实现的。"]}),"\n",(0,o.jsxs)(e.p,{children:["第一个组件被拖入画布，此时 ",(0,o.jsx)(e.code,{children:"editorComponentList"})," 长度为 1，该组件的 ",(0,o.jsx)(e.code,{children:"z-index"})," 为 1；第二个组件被拖入，",(0,o.jsx)(e.code,{children:"editorComponentList"})," 长度为 2，该组件的 ",(0,o.jsx)(e.code,{children:"z-index"})," 为 2；以此类推，但",(0,o.jsx)(e.strong,{children:"人总是不满足于现状"}),"。说白了就是 jian，我就想把第一个组件的 ",(0,o.jsx)(e.code,{children:"z-index"})," 层级提升，该如何处理？"]}),"\n",(0,o.jsxs)(e.p,{children:["很简单，只需要处理 ",(0,o.jsx)(e.code,{children:"z-index"})," 即可，那么如何提升？这就得你自己实现了。"]}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"比如 editorComponentList = [a, b, c]，对应的层级关系就是 zIndex = [a, b, c]，你想把 a 的层级提升，你可以把数组顺序改变一下，变成 [b, c, a]，当然这只是其中的一种方案。"}),"\n"]}),"\n",(0,o.jsxs)(e.h2,{id:"11-标线",children:["11. 标线",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11-标线",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:"data:image/webp;base64,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",alt:"image.png"})}),"\n",(0,o.jsx)(e.p,{children:"类似上述效果，就是 A 组件不动，我们拖拽 B 组件，当 B 组件跟 A 组件左对齐、右对齐、上对齐、下对齐等，我们就会出现一条辅助线。"}),"\n",(0,o.jsx)(e.p,{children:"那么如何实现呢？"}),"\n",(0,o.jsx)(e.p,{children:"很简单，当 A 组件固定，B 组件拖拽过程中，我们其实都能知道每个组件的 x、y，我们只需要添加一个判断。判断它们是否存在对齐。"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// 左对齐\nA.x = B.x\n\n// 右对齐\nA.x + A.width = B.x + B.width\n\n// 上对齐\nA.y = B.Y\n\n// 下对齐\nA.y + A.height = B.y + B.height\n"})}),"\n",(0,o.jsx)(e.p,{children:"如果复合条件，那么就现实一条辅助线在该 (x, y) 上即可。"}),"\n",(0,o.jsx)(e.p,{children:"如果你还有疑问，那么再看看，再想想，捋一捋是不是这么个意思。"}),"\n",(0,o.jsxs)(e.h2,{id:"12-吸附",children:["12. 吸附",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12-吸附",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:"data:image/webp;base64,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",alt:"image.png"})}),"\n",(0,o.jsx)(e.p,{children:"如图，此时我 B 组件继续往左边拖（图一），那么会出现 B 组件紧吸附在 A 组件上（图二），那这是如何实现的呢？"}),"\n",(0,o.jsxs)(e.p,{children:["我们预先定好一个值 ",(0,o.jsx)(e.code,{children:"distance = 5"}),"，表示这两个组件在距离小于 ",(0,o.jsx)(e.code,{children:"distance"})," 时，就需要自动吸附。"]}),"\n",(0,o.jsx)(e.p,{children:"假设我们现在 A 和 B 的 x、y 均为 0，宽度均为 50，此时它们重叠在了一块。"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"// A 组件\nA = (0, 0);\n\n// B 组件\nB = (0, 0);\n"})}),"\n",(0,o.jsxs)(e.p,{children:["当我们拖拽组件 B 时，B 的坐标变为 ",(0,o.jsx)(e.code,{children:"(54, 0)"}),"。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-ts",children:"// A 组件\nA = (0, 0);\n\n// B 组件\nB = (54, 0);\n"})}),"\n",(0,o.jsxs)(e.p,{children:["这时候按道理来讲，A 和 B 的位置应该如上图的左边图一所示，中间留有 4 像素的距离，但此时，由于 ",(0,o.jsx)(e.code,{children:"B.x - A.width <= distance"}),"，也就是 ",(0,o.jsx)(e.code,{children:"54 - 50 <= 5"}),"，我们就能认为这两个组件靠的很近了，应当实现吸附效果。所以我们手动将 B 组件的坐标改为 ",(0,o.jsx)(e.code,{children:"B = (50, 0)"}),"，这样就将 AB 组件吸附在一块，不分离了。"]}),"\n",(0,o.jsxs)(e.h2,{id:"最后",children:["最后",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["还有很多功能点值得去讲，比如 ",(0,o.jsx)(e.code,{children:"组件拉伸放大缩小"}),"、",(0,o.jsx)(e.code,{children:"组件旋转"})," 等，再更多的可以扩展，去做离线缓存，协同编辑。"]}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"离线缓存：比如你做的是一个知识图谱（或者是一些笔记等），那么如何设计将数据存储在本地设备中，你可能采用本地文件读写存储、FIleSystem API、IndexDB 等方案，如何择选如何设计？数据结构如何定义？连入网络之后的本地数据同步到云端？云储存同步方案如何实现？同步过程出现冲突，如何解决？"}),"\n"]}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsx)(e.p,{children:"协同编辑：两个人同时操作如何处理，比如 A 在处理图谱时，B 的整个画布被禁止不允许操作还是说 B 也能同时处理图谱？如果禁止 B 操作则体验不佳，允许 B 操作那么该如何处理操作范围？比如图谱两个同级节点，A 处理 Node1，那么 B 是也能处理 Node1 还是 Node1 被锁置灰，只能处理 Node2？同步远端数据出现冲突如何处理？"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"我认为这些都是值得去探索去研究的，即使最后我们没能做出来，或者做了一个 bug 很多半成品，但在过程中我们学到了很多东西。"}),"\n",(0,o.jsx)(e.p,{children:"最后，我没有讲解如何去实现一份可视化自定义的简历模版，我认为最核心重要的是如何实现最基础的流程，万变不离其宗。"}),"\n",(0,o.jsxs)(e.p,{children:["希望小伙伴们看完这章节之后，能结合 ✨ ",(0,o.jsx)(e.a,{href:"https://github.com/PDKSophia/dom-ui-toolbar",target:"_blank",rel:"noopener noreferrer",children:"dom-ui-toolbar"})," 搭一个简单的小平台，去折腾，去玩一下。"]})]})}function j(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(u,{...n})}):u(n)}let A=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F30.%E6%9C%9F%E6%9C%9B%E7%AF%87-%E5%8F%AF%E8%A7%86%E5%8C%96%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8B%AC%E7%89%B9%E7%9A%84%E7%AE%80%E5%8E%86%E6%A8%A1%E7%89%88.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"00. 前期准备",id:"00-前期准备",depth:2},{text:"01. 布局实现",id:"01-布局实现",depth:2},{text:"02. 物料市场的设计",id:"02-物料市场的设计",depth:2},{text:"03. 组件画布设计实现",id:"03-组件画布设计实现",depth:2},{text:"04. 操作区的实现",id:"04-操作区的实现",depth:2},{text:"05. 选中组件动态修改 style",id:"05-选中组件动态修改-style",depth:2},{text:"06. 组件在画布中随意移动",id:"06-组件在画布中随意移动",depth:2},{text:"07. 清除画布",id:"07-清除画布",depth:2},{text:"08. 删除某一组件",id:"08-删除某一组件",depth:2},{text:"09. 撤销",id:"09-撤销",depth:2},{text:"快照方式",id:"快照方式",depth:3},{text:"动作记录方式",id:"动作记录方式",depth:3},{text:"10. 调整组件层级",id:"10-调整组件层级",depth:2},{text:"11. 标线",id:"11-标线",depth:2},{text:"12. 吸附",id:"12-吸附",depth:2},{text:"最后",id:"最后",depth:2}],title:"30.期望篇-可视化自定义独特的简历模版",headingTitle:"30.期望篇-可视化自定义独特的简历模版",frontmatter:{}}}}]);