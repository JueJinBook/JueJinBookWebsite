"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["43156"],{673815:function(e,n,s){s.r(n),s.d(n,{default:()=>j});var c=s(552676),r=s(740453);let i=s.p+"static/image/b38da27140a46c6e9f8dc2bdf97a8799.fb73ac83.webp",d=s.p+"static/image/4026beb264c5da8aa0bb43453329ab62.c2f5b2c5.webp",l=s.p+"static/image/bffe6289a7a41efe262fd6614d11befb.f09ac4df.webp",h=s.p+"static/image/57241670aa30b327ba2e5e299a45f2f0.5bd05946.webp",o=s.p+"static/image/f4592f4f395769e59c28d27430c56d31.c9537bdb.webp",a=s.p+"static/image/ab73e5f90ca530d81c9e60680208691e.fd0f99fa.webp";function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ul:"ul",li:"li",strong:"strong",h3:"h3",img:"img",pre:"pre"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"8event-loop",children:["8.Event Loop",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8event-loop",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在前两章节中我们了解了 JS 异步相关的知识。在实践的过程中，你是否遇到过以下场景，为什么 ",(0,c.jsx)(n.code,{children:"setTimeout"})," 会比 ",(0,c.jsx)(n.code,{children:"Promise"})," 后执行，明明代码写在 ",(0,c.jsx)(n.code,{children:"Promise"})," 之前。这其实涉及到了 Event Loop  相关的知识，这一章节我们会来详细地了解 Event Loop  相关知识，学习 JS 异步运行代码的原理，并且这一章节也是面试常考知识点。"]}),"\n",(0,c.jsxs)(n.h2,{id:"更新日志",children:["更新日志",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新日志",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"各小节内容优化"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"进程与线程",children:["进程与线程",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#进程与线程",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["相信大家经常会听到 JS 是",(0,c.jsx)(n.strong,{children:"单线程"}),"执行的，但是你是否疑惑过什么是线程？"]}),"\n",(0,c.jsxs)(n.p,{children:["讲到线程，那么肯定也得说一下进程。本质上来说，这两个名词都是 CPU ",(0,c.jsx)(n.strong,{children:"工作时间片"}),"的一个描述。"]}),"\n",(0,c.jsxs)(n.p,{children:["进程描述了 CPU 在",(0,c.jsx)(n.strong,{children:"运行指令及加载和保存上下文所需的时间"}),"，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。"]}),"\n",(0,c.jsx)(n.p,{children:"把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。"}),"\n",(0,c.jsxs)(n.h3,{id:"常见考点",children:["常见考点",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"进程线程区别"}),"\n",(0,c.jsx)(n.li,{children:"JS 单线程执行带来的优缺点"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"执行栈",children:["执行栈",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行栈",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["可以把执行栈认为是一个存储函数调用的",(0,c.jsx)(n.strong,{children:"栈结构"}),"，遵循先进后出的原则。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["当开始执行 JS 代码时，首先会执行一个 ",(0,c.jsx)(n.code,{children:"main"})," 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，",(0,c.jsx)(n.code,{children:"foo"})," 函数后执行，当执行完毕后就先从栈中弹出了。"]}),"\n",(0,c.jsx)(n.p,{children:"另外在平时开发过程中，大家也可以在报错中找到执行栈的痕迹："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function foo() {\n  throw new Error('error')\n}\nfunction bar() {\n  foo()\n}\nbar()\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["大家可以在上图清晰的看到报错在 ",(0,c.jsx)(n.code,{children:"foo"})," 函数，",(0,c.jsx)(n.code,{children:"foo"})," 函数又是在 ",(0,c.jsx)(n.code,{children:"bar"})," 函数中调用的。"]}),"\n",(0,c.jsx)(n.p,{children:"当我们使用递归的时候，因为执行栈的内存空间是有限的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function bar() {\n  bar()\n}\nbar()\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.h3,{id:"常见考点-1",children:["常见考点",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点-1",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"什么是执行栈"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"浏览器中的-event-loop",children:["浏览器中的 Event Loop",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器中的-event-loop",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"上一小节中我们讲到了什么是执行栈，大家也知道了当我们执行 JS 代码的时候其实就是往执行栈中放入函数，那么当遇到异步代码的时候该怎么办？"}),"\n",(0,c.jsxs)(n.p,{children:["其实当遇到异步代码时，会被",(0,c.jsx)(n.strong,{children:"挂起"}),"并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 ",(0,c.jsx)(n.strong,{children:"微任务"}),"（microtask） 和 ",(0,c.jsx)(n.strong,{children:"宏任务"}),"（macrotask）。在 ES6 规范中，microtask 称为 ",(0,c.jsx)(n.code,{children:"jobs"}),"，macrotask 称为 ",(0,c.jsx)(n.code,{children:"task"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["微任务包括 ",(0,c.jsx)(n.code,{children:"process.nextTick"})," 、",(0,c.jsx)(n.code,{children:"queueMicrotask"}),"、",(0,c.jsx)(n.code,{children:"promise.then"})," 、",(0,c.jsx)(n.code,{children:"MutationObserver"}),"，其中 ",(0,c.jsx)(n.code,{children:"process.nextTick"})," 为 Node 独有。"]}),"\n",(0,c.jsxs)(n.p,{children:["宏任务包括 ",(0,c.jsx)(n.code,{children:"script"})," 、 ",(0,c.jsx)(n.code,{children:"setTimeout"})," 、",(0,c.jsx)(n.code,{children:"setInterval"})," 、",(0,c.jsx)(n.code,{children:"setImmediate"})," 、",(0,c.jsx)(n.code,{children:"I/O"})," 及 ",(0,c.jsx)(n.code,{children:"UI rendering"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"讲了这么多，想必大家肯定对于这个 Loop 是怎么样执行的很感兴趣吧。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"首先执行同步代码，这属于宏任务"}),"\n",(0,c.jsx)(n.li,{children:"当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行"}),"\n",(0,c.jsx)(n.li,{children:"执行所有微任务"}),"\n",(0,c.jsx)(n.li,{children:"当执行完所有微任务后，如有必要会渲染页面"}),"\n",(0,c.jsxs)(n.li,{children:["然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 ",(0,c.jsx)(n.code,{children:"setTimeout"})," 中的回调函数"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这里很多人会有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 ",(0,c.jsx)(n.code,{children:"script"})," ，浏览器一定会",(0,c.jsxs)(n.strong,{children:["先执行一个 ",(0,c.jsx)(n.code,{children:"script"})]}),"，接下来才会执行微任务。"]}),"\n",(0,c.jsx)(n.p,{children:"了解完以上内容，我们通过一段代码来看看掌握情况："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"console.log('script start')\n\nasync function async1() {\n  await async2()\n  console.log('async1 end')\n}\nasync function async2() {\n  console.log('async2 end')\n}\nasync1()\n\nsetTimeout(function() {\n  console.log('setTimeout')\n}, 0)\n\nnew Promise(resolve => {\n  console.log('Promise')\n  resolve()\n})\n  .then(function() {\n    console.log('promise1')\n  })\n\nconsole.log('script end')\n// script start => async2 end => Promise => script end \n// => async1 end  => promise1 => setTimeout\n"})}),"\n",(0,c.jsx)(n.p,{children:"以上代码能很好地帮助我们理解宏任务及微任务的执行顺序，务必搞懂。"}),"\n",(0,c.jsxs)(n.p,{children:["如果你对执行顺序有迷惑的话，可以再结合 Event Loop 的执行顺利再思考下。我们首先根据代码执行顺序分离出同步代码，也就是注释第一行的 ",(0,c.jsx)(n.code,{children:"log"})," 顺序。另外在这些同步代码执行过程中，微任务及宏任务也被推入了相应的队列中等待执行。"]}),"\n",(0,c.jsxs)(n.p,{children:["接下来我们再根据微任务进入队列的顺序得出打印结果为 ",(0,c.jsx)(n.code,{children:"async1 end"})," 及 ",(0,c.jsx)(n.code,{children:"promise1"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后当微任务执行完毕后需要执行宏任务，此时打印 ",(0,c.jsx)(n.code,{children:"setTimeout"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"常见考点-2",children:["常见考点",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点-2",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["笔试题，类似于上面的代码，让你写出 ",(0,c.jsx)(n.code,{children:"log"})," 顺序"]}),"\n",(0,c.jsx)(n.li,{children:"如何理解 Event loop"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"node-中的-event-loop",children:["Node 中的 Event Loop",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#node-中的-event-loop",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Node 中的 Event Loop 和浏览器中的区别很大。"}),"\n",(0,c.jsxs)(n.p,{children:["Node 的 Event Loop 分为 6 个阶段，它们会按照",(0,c.jsx)(n.strong,{children:"顺序"}),"反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsxs)(n.h3,{id:"timer",children:["timer",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#timer",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["timers 阶段会执行 ",(0,c.jsx)(n.code,{children:"setTimeout"})," 和 ",(0,c.jsx)(n.code,{children:"setInterval"})," 回调，并且是由 poll 阶段控制的。"]}),"\n",(0,c.jsxs)(n.p,{children:["同样，在 Node 中定时器指定的时间也不是准确时间，只能是",(0,c.jsx)(n.strong,{children:"尽快"}),"执行。"]}),"\n",(0,c.jsxs)(n.h3,{id:"pending-callbacks",children:["pending callbacks",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pending-callbacks",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这个阶段会执行上一轮循环中的",(0,c.jsx)(n.strong,{children:"poll 阶段被延迟执行"}),"的 I/O 回调。"]}),"\n",(0,c.jsxs)(n.h3,{id:"idle-prepare",children:["idle, prepare",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#idle-prepare",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这个阶段内部使用，略过。"}),"\n",(0,c.jsxs)(n.h3,{id:"poll",children:["poll",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#poll",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这个阶段略复杂，做的事情会比较多。"}),"\n",(0,c.jsx)(n.p,{children:"首先如果队列不为空，会遍历回调队列并执行，直到队列为空或者达到系统限制。"}),"\n",(0,c.jsxs)(n.p,{children:["接下来检查是否有 ",(0,c.jsx)(n.code,{children:"setImmediate"})," 回调需要执行。有的话就直接结束 poll 阶段并且进入到 check 阶段执行回调。"]}),"\n",(0,c.jsxs)(n.p,{children:["如果没有 ",(0,c.jsx)(n.code,{children:"setImmediate"})," 回调需要执行。会 block 线程并等待一会，看是否有新的事件进入队列，有的话就去执行。"]}),"\n",(0,c.jsx)(n.p,{children:"在此过程中如果有 timer 需要执行，会回到 timer 阶段执行回调。"}),"\n",(0,c.jsxs)(n.h3,{id:"check",children:["check",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#check",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这个阶段执行 ",(0,c.jsx)(n.code,{children:"setImmediate"})," 回调。"]}),"\n",(0,c.jsxs)(n.h3,{id:"close-callbacks",children:["close callbacks",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#close-callbacks",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这个阶段执行关闭操作，比如关闭 ",(0,c.jsx)(n.code,{children:"socket"})," 等。"]}),"\n",(0,c.jsxs)(n.p,{children:["上述阶段都为宏任务的执行阶段，对于 microtask 来说，它会在以上每个阶段完成前",(0,c.jsx)(n.strong,{children:"清空"})," microtask 队列，下图中的 Tick 就代表了 microtask。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["最后我们来讲讲 Node 中的 ",(0,c.jsx)(n.code,{children:"process.nextTick"}),"，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会",(0,c.jsx)(n.strong,{children:"清空队列中的所有回调函数"}),"，并且优先于其他 microtask 执行。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"setTimeout(() => {\n console.log('timer1')\n\n Promise.resolve().then(function() {\n   console.log('promise1')\n })\n}, 0)\n\nprocess.nextTick(() => {\n console.log('nextTick')\n process.nextTick(() => {\n   console.log('nextTick')\n   process.nextTick(() => {\n     console.log('nextTick')\n     process.nextTick(() => {\n       console.log('nextTick')\n     })\n   })\n })\n})\n"})}),"\n",(0,c.jsxs)(n.p,{children:["对于以上代码，大家可以发现无论如何都是先把 ",(0,c.jsx)(n.code,{children:"nextTick"})," 全部打印出来。"]}),"\n",(0,c.jsxs)(n.h3,{id:"常见考点-3",children:["常见考点",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点-3",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Node 中的 Event Loop 和浏览器中的有什么区别？"}),"\n",(0,c.jsx)(n.li,{children:"process.nexttick 执行顺序？"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这一章节我们学习了 JS 实现异步的原理，并且了解了在浏览器和 Node 中 Event Loop 其实是不相同的。Event Loop 这个知识点对于我们理解 JS 是如何执行的至关重要，同时也是常考题。如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(t,{...e})}):t(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F8.Event%20Loop.md"]={toc:[{text:"更新日志",id:"更新日志",depth:2},{text:"进程与线程",id:"进程与线程",depth:2},{text:"常见考点",id:"常见考点",depth:3},{text:"执行栈",id:"执行栈",depth:2},{text:"常见考点",id:"常见考点-1",depth:3},{text:"浏览器中的 Event Loop",id:"浏览器中的-event-loop",depth:2},{text:"常见考点",id:"常见考点-2",depth:3},{text:"Node 中的 Event Loop",id:"node-中的-event-loop",depth:2},{text:"timer",id:"timer",depth:3},{text:"pending callbacks",id:"pending-callbacks",depth:3},{text:"idle, prepare",id:"idle-prepare",depth:3},{text:"poll",id:"poll",depth:3},{text:"check",id:"check",depth:3},{text:"close callbacks",id:"close-callbacks",depth:3},{text:"常见考点",id:"常见考点-3",depth:3},{text:"小结",id:"小结",depth:2}],title:"8.Event Loop",headingTitle:"8.Event Loop",frontmatter:{}}}}]);