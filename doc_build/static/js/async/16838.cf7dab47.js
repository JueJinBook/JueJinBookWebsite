"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16838"],{588243:function(e,n,r){r.r(n),r.d(n,{default:()=>u});var t=r(552676),s=r(740453);let a=r.p+"static/image/26df496f5032089f96df2bb46d9e6ea1.dd9a1c5f.webp",i=r.p+"static/image/f7e90c208757fe7abc514c565129ff19.4a2da9d0.webp",l=r.p+"static/image/99fb30044e079a2cdb4fabab7ddf4f18.f9e2534b.webp",d=r.p+"static/image/ece3edace99d42dfb4335b2cad0cd16a.9f5d53aa.webp",c=r.p+"static/image/88484318383b9e6491de7c11fa300998.c754054a.webp",o=r.p+"static/image/dedf6f39796d693d8c6206ace1ed198e.0578df88.webp",h=r.p+"static/image/d75c926601ff2861c8e94d530c07de2f.b59a001d.webp",p=r.p+"static/image/277fe03a1ff6a11f2f2d8b7f2523acaf.3925dc45.webp",x=r.p+"static/image/06dd0ab9bbd99ba114af9147f440ed96.68721a13.webp",m=r.p+"static/image/ebb34c06db1af68aa7be898d3d984688.31d2f01a.webp",j=r.p+"static/image/a284980583bf08935b3de053c79a16c6.37fca12f.webp";function g(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",img:"img",pre:"pre",h3:"h3",ol:"ol",li:"li",h4:"h4",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"本篇开始，我们使用 Next.js 官方脚手架从零实现一个博客项目。那就让我们直接开始吧！"}),"\n",(0,t.jsxs)(n.h2,{id:"初始化项目",children:["初始化项目",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化项目",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["运行 ",(0,t.jsx)(n.code,{children:"npx create-next-app@latest"}),"新建项目，效果如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"运行以下命令安装依赖项并开启开发模式："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"cd next-blog && npm i && npm run dev\n"})}),"\n",(0,t.jsxs)(n.p,{children:["打开 ",(0,t.jsx)(n.a,{href:"http://localhost:3000/",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3000/"}),"，检查页面是否正常运行："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h2,{id:"如何处理-mdx",children:["如何处理 MDX",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何处理-mdx",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"博客的一大组成部分是文章，技术同学写文章大多使用 Markdown。哪怕像我写在语雀，也会导出成 Markdown 格式，然后发在掘金……"}),"\n",(0,t.jsxs)(n.h3,{id:"本地-mdx",children:["本地 mdx",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本地-mdx",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["我们在 ",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309078575934930994",target:"_blank",rel:"noopener noreferrer",children:"《配置篇 | MDX》"}),"讲了如何借助 ",(0,t.jsx)(n.code,{children:"@next/mdx"})," 处理 Markdown 的超集 MDX。当配置完毕后，将原本的 page.js 替换为 page.mdx："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  your-project\n  ├── app\n  │   └── my-mdx-page\n  │       └── page.mdx\n  └── package.json\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这样当你访问 ",(0,t.jsx)(n.code,{children:"/my-mdx-page"}),"路由的时候，就会打开渲染后的 mdx 内容。"]}),"\n",(0,t.jsx)(n.p,{children:"但是这样做的问题在于：如果我要上传一篇文章，我还需要手动新建一个文件夹用于它的路由地址，这属实有点麻烦。"}),"\n",(0,t.jsxs)(n.h3,{id:"远程-mdx",children:["远程 mdx",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#远程-mdx",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"为了简化这个步骤，我们通常会新建一个存放所有文章的文件夹，然后使用动态路由，动态读取对应的文章。"}),"\n",(0,t.jsx)(n.p,{children:"我们试着写一下。先安装一个处理 MDX 的库："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"npm i next-mdx-remote\n"})}),"\n",(0,t.jsx)(n.p,{children:"涉及的文件和目录如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"next-blog              \n├─ app                 \n│  ├─ posts            \n│  │  └─ [id]          \n│  │     └─ page.js         \n└─ posts               \n   └─ first.mdx        \n"})}),"\n",(0,t.jsxs)(n.p,{children:["新建 ",(0,t.jsx)(n.code,{children:"app/posts/[id]/page.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { compileMDX } from 'next-mdx-remote/rsc'\nimport { readFile } from 'node:fs/promises';\nimport path from 'path';\n\nasync function getMDXContent(name) {\n  try {\n    const filePath = path.join(process.cwd(), '/posts/', `${name}.mdx`)\n    const contents = await readFile(filePath, { encoding: 'utf8' });\n    return await compileMDX({ source: contents, options: { parseFrontmatter: true }})\n  } catch (err) {\n    return null\n  }\n}\n\nexport async function generateMetadata({ params, searchParams }, parent) {\n  const res = await getMDXContent(params.id);\n  if (!res) return { title: ''}\n  const { frontmatter } = res;\n  return { title: frontmatter.title }\n}\n\nexport default async function Home({ params }) {\n  const res = await getMDXContent(params.id);\n  if (!res) return <h1>Page not Found!</h1>\n  const {content, frontmatter} = res;\n\n  return (\n    <>\n      {content}\n    </>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["新建 ",(0,t.jsx)(n.code,{children:"/posts/first.mdx"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"---\ntitle: Hello World Article\n---\n\n# 52.实战篇 _ 博客 _ Contentlayer\n\nthis is content\n"})}),"\n",(0,t.jsxs)(n.p,{children:["此时打开 ",(0,t.jsx)(n.a,{href:"http://localhost:3000/posts/first",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3000/posts/first"}),"，效果如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"可以看到：MDX 内容成功渲染，且使用 Frontmatter 实现了页面的元数据设置。"}),"\n",(0,t.jsx)(n.p,{children:"但是这样做还是有些问题："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"没有构建优化。页面请求的时候才读取对应的 MDX 内容进行渲染，过程并没有做优化，比如提前进行编译"}),"\n",(0,t.jsx)(n.li,{children:"没有类型定义。比如 Frontmatter，代码中用的是 title，但在 MDX 中写作了 tilte，但并不会出现构建错误或提示（相信这种拼写错误大家一般不会犯，更多出现的是 tags 和 tag 这种）"}),"\n",(0,t.jsxs)(n.li,{children:["没有实时刷新。比如修改 ",(0,t.jsx)(n.code,{children:"first.mdx"}),"，页面内容并不会自动刷新"]}),"\n",(0,t.jsx)(n.li,{children:"内容没有被缓存。每次都是重新读取页面内容并渲染。"}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"contentlayer",children:["Contentlayer",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#contentlayer",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这就是为什么我们需要 Contentlayer。"}),"\n",(0,t.jsx)(n.p,{children:"Contentlayer，顾名思义，内容层。它会将内容转为数据，这样我们就可以在任意组件导入内容，就像我们导入其他库一样。"}),"\n",(0,t.jsxs)(n.p,{children:["“将内容转为数据”听起来有些抽象，其实很简单，其本质是监听文件改变，将原本的 md、mdx 等文档内容转为 js、json 等格式，其中包含文档的各种信息，就比如将这样一个名为 ",(0,t.jsx)(n.code,{children:"first.mdx"})," 的文档："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-markdown",children:"---\ntitle: Hello World Article\ndate: 2014-05-01\n---\n\n# Hello, World!\n"})}),"\n",(0,t.jsx)(n.p,{children:"转为这样一个 js 文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"{\n    title: 'Hello World Article',\n    date: '2014-05-01T00:00:00.000Z',\n    body: {\n      raw: \"...\",\n      code: \"var Component=(()=>{var m=Object.create ...\"\n    },\n    _id: 'first.mdx',\n    _raw: {\n      sourceFilePath: 'first.mdx',\n      sourceFileName: 'first.mdx',\n      sourceFileDir: '.',\n      contentType: 'mdx',\n      flattenedPath: 'first'\n    }\n  }\n"})}),"\n",(0,t.jsx)(n.p,{children:"当在组件中使用的时候，不需要再读取原本的 mdx 文件内容，而是导入这个编译后的 js 文件即可。"}),"\n",(0,t.jsx)(n.p,{children:"可能听起来还是有些抽象，还是让我们在实战中体会它的作用吧。"}),"\n",(0,t.jsxs)(n.h4,{id:"安装设置",children:["安装设置",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#安装设置",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"尝试安装 next-contentlayer："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"npm i next-contentlayer\n"})}),"\n",(0,t.jsx)(n.p,{children:"如果出现版本不兼容错误："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"修改 package.json，添加以下代码再进行安装："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'{\n  // ...\n  "overrides": {\n    "next-contentlayer": {\n      "next": "$next"\n    }\n  }\n}\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"顺便再安装一些后续会用到的库："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"npm i dayjs rehype-prism-plus remark-gfm@3.0.1\n"})}),"\n",(0,t.jsx)(n.p,{children:"其中："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://day.js.org/zh-CN/",target:"_blank",rel:"noopener noreferrer",children:"dayjs"})," 用于处理时间展示"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/rehype-prism-plus",target:"_blank",rel:"noopener noreferrer",children:"rehype-prism-plus"})," 用于处理语法高亮"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/remarkjs/remark-gfm",target:"_blank",rel:"noopener noreferrer",children:"remark-gfm"})," 用于扩展 Markdown 语法"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"next.config.mjs"}),"，完整代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { withContentlayer } from 'next-contentlayer'\nexport default withContentlayer({})\n"})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"jsconfig.json"}),"，完整代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'{\n  "compilerOptions": {\n    "baseUrl": ".",\n    "paths": {\n      "contentlayer/generated": ["./.contentlayer/generated"],\n      "@/*": ["./*"]\n    }\n  },\n  "include": [\n    "next-env.d.js",\n    "**/*.js",\n    "**/*.jsx",\n    ".next/types/**/*.js",\n    ".contentlayer/generated"\n  ]\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:".gitignore"})," 文件，添加如下代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# contentlayer\n.contentlayer\n"})}),"\n",(0,t.jsx)(n.p,{children:".contentlayer 存放的正是 md、mdx 编译后的文件，这些并不需要提交到远程仓库。"}),"\n",(0,t.jsxs)(n.h4,{id:"定义内容-schema",children:["定义内容 Schema",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定义内容-schema",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["根目录新建 ",(0,t.jsx)(n.code,{children:"contentlayer.config.ts"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { defineDocumentType, makeSource } from 'contentlayer/source-files'\nimport remarkGfm from 'remark-gfm'\nimport rehypePrismPlus from 'rehype-prism-plus'\n\nexport const Post = defineDocumentType(() => ({\n  name: 'Post',\n  filePathPattern: `**/*.mdx`,\n  contentType: 'mdx',\n  fields: {\n    title: { type: 'string', required: true },\n    date: { type: 'date', required: true },\n  },\n  computedFields: {\n    url: { type: 'string', resolve: (post) => `/posts/${post._raw.flattenedPath}` },\n  },\n}))\n\nexport default makeSource({ \n  contentDirPath: 'posts', \n  documentTypes: [Post],\n  mdx: {\n    remarkPlugins: [remarkGfm],\n    rehypePlugins: [[rehypePrismPlus, { defaultLanguage: 'js', ignoreMissing: true }],],\n  }\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"在这段代码中，makeSource 定义了 markdown 文档所在的位置和用到的插件，defineDocumentType 定义了 Frontmatter 的字段类型，比如我们的文档需要定义 title 和 date 两个字段，两个字段都是必须的，如果缺失某些字段，会有错误提示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"如果使用了未定义的字段，也会出现错误提示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h4,{id:"添加站点代码",children:["添加站点代码",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加站点代码",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"/posts/first.mdx"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"---\ntitle: Hello World Article\ndate: 2014-05-01\n---\n\n# Hello, World!\n\n**这是一段加粗文字**\n\n~~这是一段删除文字~~\n\n```js {1,3-4} showLineNumbers\nfunction fancyAlert(arg) {\n  if (arg) {\n    $.facebox({ div: '#foo' })\n  }\n}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'\n新建 `/app/posts/page.js`，代码如下：\n\n```jsx\nimport Link from \'next/link\'\nimport { allPosts } from \'contentlayer/generated\'\nimport dayjs from "dayjs";\n\nfunction PostCard(post) {\n  return (\n    <div className="mb-8">\n      <h2 className="mb-1 text-xl">\n        <Link href={post.url} className="text-blue-700 hover:text-blue-900 dark:text-blue-400">\n          {post.title}\n        </Link>\n      </h2>\n      <time dateTime={post.date} className="mb-2 block text-xs text-gray-600">\n        {dayjs(post.date).format(\'DD/MM/YYYY\')}\n      </time>\n    </div>\n  )\n}\n\nexport default function Home() {\n  return (\n    <div className="mx-auto max-w-xl py-8">\n      <h1 className="mb-8 text-center text-2xl font-black">My Blog List</h1>\n      {allPosts.map((post, idx) => (\n      <PostCard key={idx} {...post} />\n    ))}\n    </div>\n  )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["在这段代码中，我们从 ",(0,t.jsx)(n.code,{children:"'contentlayer/generated'"}),"中导出了 allPosts 变量，这有点让人奇怪，allPosts 到底是哪里定义的呢？"]}),"\n",(0,t.jsxs)(n.p,{children:["前面我们说过 contentlayer 的本质是实时编译，将 md 文档编译成普通的 js 文件，编译后的内容存放在项目根目录下的 ",(0,t.jsx)(n.code,{children:".contentlayer"}),"文件夹中。"]}),"\n",(0,t.jsxs)(n.p,{children:["我们在 ",(0,t.jsx)(n.code,{children:"contentlayer.config.ts"})," 中定义了一个名为 Post 的文档类型，对应的所有数据就是 all + 它的复数形式，也就是 allPosts。"]}),"\n",(0,t.jsx)(n.p,{children:"再举个例子，如果定义的文档类型名称为 Page，对应的所有文档数据则为 allPages，它本质上一个包含所有导入 JSON 文档的数组。让我们打印下 allPosts 看一下具体的结构："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"[\n  {\n    title: 'Hello World Article',\n    date: '2014-05-01T00:00:00.000Z',\n    body: {\n      raw: \"...\",\n      code: \"var Component=(()=>{var m=Object.create ...\"\n    },\n    _id: 'first.mdx',\n    _raw: {\n      sourceFilePath: 'first.mdx',\n      sourceFileName: 'first.mdx',\n      sourceFileDir: '.',\n      contentType: 'mdx',\n      flattenedPath: 'first'\n    },\n    type: 'Post',\n    url: '/posts/first'\n  },\n  {\n    title: 'Hello Earth Article',\n    date: '2014-05-02T00:00:00.000Z',\n    body: {\n      raw: \"...\",\n      code: \"...\"\n    },\n    _id: 'second.mdx',\n    _raw: {\n      sourceFilePath: 'second.mdx',\n      sourceFileName: 'second.mdx',\n      sourceFileDir: '.',\n      contentType: 'mdx',\n      flattenedPath: 'second'\n    },\n    type: 'Post',\n    url: '/posts/second'\n  }\n]\n"})}),"\n",(0,t.jsx)(n.p,{children:"allPosts 是一个数组，每一个元素包含了该文档的所有 FontMatter 字段以及文档的原内容（body.raw）和编译后的内容（body.code）。"}),"\n",(0,t.jsx)(n.p,{children:"此时浏览器效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"app/posts/[id]/page.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'import { allPosts } from \'contentlayer/generated\'\nimport { useMDXComponent } from \'next-contentlayer/hooks\'\nimport { notFound } from \'next/navigation\'\nimport dayjs from "dayjs";\n\nexport async function generateStaticParams() {\n  return allPosts.map((post) => ({\n    id: post._raw.flattenedPath,\n  }))\n}\nexport const generateMetadata = ({ params }) => {\n  const post = allPosts.find((post) => post._raw.flattenedPath === params.id)\n  if (!post) throw new Error(`Post not found for id: ${params.id}`)\n  return { title: post.title }\n}\n\nconst Page = ({ params }) => {\n  const post = allPosts.find((post) => post._raw.flattenedPath === params.id)\n  if (!post) notFound()\n  const MDXContent = useMDXComponent(post.body.code)\n\n  return (\n    <article className="mx-auto max-w-xl py-8">\n      <div className="mb-8 text-center">\n        <time dateTime={post.date} className="mb-1 text-xs text-gray-600">\n          {dayjs(post.date).format(\'DD/MM/YYYY\')}\n        </time>\n        <h1 className="text-3xl font-bold">{post.title}</h1>\n      </div>\n      <MDXContent />\n    </article>\n  )\n}\n\nexport default Page\n'})}),"\n",(0,t.jsx)(n.p,{children:"因为我们使用了 rehypePrismPlus 作为代码的样式插件，它会将代码编译成带类名的 html："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"截屏2024-05-06 17.42.36.png"})}),"\n",(0,t.jsx)(n.p,{children:"但因为我们的代码并没有定义这些类名的样式，所以我们还需要添加下样式。"}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"app/global.css"}),"，添加代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"pre {\n  overflow-x: auto;\n}\n\n/**\n * Inspired by gatsby remark prism - https://www.gatsbyjs.com/plugins/gatsby-remark-prismjs/\n * 1. Make the element just wide enough to fit its content.\n * 2. Always fill the visible space in .code-highlight.\n */\n.code-highlight {\n  float: left; /* 1 */\n  min-width: 100%; /* 2 */\n}\n\n.code-line {\n  display: block;\n  padding-left: 16px;\n  padding-right: 16px;\n  margin-left: -16px;\n  margin-right: -16px;\n  border-left: 4px solid rgba(0, 0, 0, 0); /* Set placeholder for highlight accent border color to transparent */\n}\n\n.code-line.inserted {\n  background-color: rgba(16, 185, 129, 0.2); /* Set inserted line (+) color */\n}\n\n.code-line.deleted {\n  background-color: rgba(239, 68, 68, 0.2); /* Set deleted line (-) color */\n}\n\n.highlight-line {\n  margin-left: -16px;\n  margin-right: -16px;\n  background-color: rgba(55, 65, 81, 0.5); /* Set highlight bg color */\n  border-left: 4px solid rgb(59, 130, 246); /* Set highlight accent border color */\n}\n\n.line-number::before {\n  display: inline-block;\n  width: 1rem;\n  text-align: right;\n  margin-right: 16px;\n  margin-left: -8px;\n  color: rgb(156, 163, 175); /* Line number color */\n  content: attr(line);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这些样式是为了代码块显示行号等信息。"}),"\n",(0,t.jsxs)(n.p,{children:["至于代码的样式，到 ",(0,t.jsx)(n.a,{href:"https://github.com/PrismJS/prism-themes",target:"_blank",rel:"noopener noreferrer",children:"Prism themes"})," 选择一个你喜欢的样式，然后拷贝其 CSS 文件。比如我选择的是普通的 VSCode Dark 样式，地址为：",(0,t.jsx)(n.a,{href:"https://github.com/PrismJS/prism-themes/blob/master/themes/prism-vsc-dark-plus.css",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/PrismJS/prism-themes/blob/master/themes/prism-vsc-dark-plus.css"})]}),"\n",(0,t.jsxs)(n.p,{children:["将这段代码也拷贝到 ",(0,t.jsx)(n.code,{children:"app/global.css"}),"中，最后的效果如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h2,{id:"tailwind-css",children:["Tailwind CSS",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tailwind-css",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"让我们真的写一篇文章试试，实际渲染后的效果为："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"虽然对应的 HTML 标签渲染都是正确的，但因为 Tailwind CSS 默认会将所有元素的样式重置，所以最后的效果并不算“好看”。"}),"\n",(0,t.jsxs)(n.p,{children:["不过 Tailwind.css 官方提供了 ",(0,t.jsx)(n.a,{href:"https://github.com/tailwindlabs/tailwindcss-typography",target:"_blank",rel:"noopener noreferrer",children:"Tailwind CSS Typography"})," 插件用于设置样式的默认值。安装："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"npm install -D @tailwindcss/typography @tailwindcss/forms\n"})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"tailwind.config.js"}),"，完整代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\n    \"./pages/**/*.{js,ts,jsx,tsx,mdx}\",\n    \"./components/**/*.{js,ts,jsx,tsx,mdx}\",\n    \"./app/**/*.{js,ts,jsx,tsx,mdx}\",\n    './data/**/*.mdx',\n  ],\n  darkMode: 'class',\n  theme: {\n    extend: {\n      lineHeight: {\n        11: '2.75rem',\n        12: '3rem',\n        13: '3.25rem',\n        14: '3.5rem',\n      },\n      typography: ({ theme }) => ({\n        DEFAULT: {\n          css: {\n            a: {\n              color: theme('colors.primary.500'),\n              '&:hover': {\n                color: `${theme('colors.primary.600')}`,\n              },\n              code: { color: theme('colors.primary.400') },\n            },\n            'h1,h2': {\n              fontWeight: '700',\n              letterSpacing: theme('letterSpacing.tight'),\n            },\n            h3: {\n              fontWeight: '600',\n            },\n            code: {\n              color: theme('colors.indigo.500'),\n            },\n          },\n        },\n        invert: {\n          css: {\n            a: {\n              color: theme('colors.primary.500'),\n              '&:hover': {\n                color: `${theme('colors.primary.400')}`,\n              },\n              code: { color: theme('colors.primary.400') },\n            },\n            'h1,h2,h3,h4,h5,h6': {\n              color: theme('colors.gray.100'),\n            },\n          },\n        },\n      }),\n    },\n  },\n  plugins: [require('@tailwindcss/forms'), require('@tailwindcss/typography')],\n};\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"app/posts/[id]/page.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// ...\n\nconst Page = ({ params }) => {\n  // ...\n\n  return (\n    <article className="mx-auto max-w-xl py-8 prose prose-slate">\n      // ...\n    </article>\n  )\n}\n\nexport default Page\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Tailwind CSS Typography 通过在外层添加一个 prose 和 prose-xxx 类来控制其中元素的样式，有五种预定义的颜色和比例选项可用（这里我们用的是 prose-slate），此外还支持深色模式，具体参考其",(0,t.jsx)(n.a,{href:"https://github.com/tailwindlabs/tailwindcss-typography",target:"_blank",rel:"noopener noreferrer",children:"官方说明"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"最后的效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"是不是看起来就正常多了？"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"功能实现：博客 Contentlayer"}),"\n",(0,t.jsxs)(n.li,{children:["源码地址：",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/next-blog-1",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/next-blog-1"})]}),"\n",(0,t.jsxs)(n.li,{children:["下载代码：",(0,t.jsx)(n.code,{children:"git clone -b next-blog-1 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"本篇我们介绍了 Contentlayer 的出现背景和使用方法，它是处理 MD 和 MDX 等内容的利器，但是 Contentlayer 这一两年近乎没有更新，使用的时候可能会遇到一些版本问题，不过目前尚未看到更好的替代方案。"}),"\n",(0,t.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.youtube.com/watch?v=58Pj4a4Us7A&ab_channel=Contentlayer",target:"_blank",rel:"noopener noreferrer",children:"https://www.youtube.com/watch?v=58Pj4a4Us7A&ab_channel=Contentlayer"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://contentlayer.dev/docs/getting-started-cddd76b7",target:"_blank",rel:"noopener noreferrer",children:"https://contentlayer.dev/docs/getting-started-cddd76b7"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/tailwindlabs/tailwindcss-typography",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/tailwindlabs/tailwindcss-typography"})}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}let u=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F52.%E5%AE%9E%E6%88%98%E7%AF%87%20_%20%E5%8D%9A%E5%AE%A2%20_%20Contentlayer.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"初始化项目",id:"初始化项目",depth:2},{text:"如何处理 MDX",id:"如何处理-mdx",depth:2},{text:"本地 mdx",id:"本地-mdx",depth:3},{text:"远程 mdx",id:"远程-mdx",depth:3},{text:"Contentlayer",id:"contentlayer",depth:3},{text:"安装设置",id:"安装设置",depth:4},{text:"定义内容 Schema",id:"定义内容-schema",depth:4},{text:"添加站点代码",id:"添加站点代码",depth:4},{text:"Tailwind CSS",id:"tailwind-css",depth:2},{text:"总结",id:"总结",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);