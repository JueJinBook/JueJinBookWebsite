"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["47607"],{208445:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var s=r(552676),d=r(740453);function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",strong:"strong",h3:"h3",ul:"ul",li:"li",blockquote:"blockquote"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"4http-缓存3刨根问底缓存新鲜度与使用期算法",children:["4.HTTP 缓存3：刨根问底——缓存新鲜度与使用期算法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4http-缓存3刨根问底缓存新鲜度与使用期算法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在我们的日常生活中，每一样食品都有保质期限，在保质期内食用不会对我们的身体健康产生影响，但是一旦存储了过长的时间以致超过了保质期，我们便不能再进行食用，需要丢弃并重新购买，而强缓存亦是如此。"}),"\n",(0,s.jsxs)(n.h2,{id:"从食品是否新鲜到强缓存是否新鲜",children:["从“食品是否新鲜”到“强缓存是否新鲜”",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从食品是否新鲜到强缓存是否新鲜",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"正如与食品保质期一样，强缓存也有着它的“保质期”，我们这里一般称其为“新鲜度”。为了让读者便于理解，笔者这里拿生活中的牛奶来进行举例。"}),"\n",(0,s.jsx)(n.p,{children:"假如你的冰箱里有一瓶牛奶，那么它是否新鲜取决于哪些因素？这里相信大家面对这样的生活常识都能够清楚的知道主要取决于牛奶的保质期和生产日期。比如牛奶的保质期为 6 个月，生产日期为 2021 年 1 月 1日，那么牛奶是否新鲜的计算公式应该是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"牛奶是否新鲜 = 保质期 > (当前日期 - 生产日期) \n"})}),"\n",(0,s.jsx)(n.p,{children:"也就是说，当当前日期减去生产日期超过 6 个月时牛奶便不新鲜了（过期了），不难得出牛奶应该在 2021 年 7 月 1 日前饮用完毕。"}),"\n",(0,s.jsxs)(n.p,{children:["我们统一并简化下上述公式，使得所有食品都能公用，上述",(0,s.jsx)(n.code,{children:"当前日期 - 生产日期"}),"其实就是 ",(0,s.jsx)(n.code,{children:"使用期"}),"，简化后的公式如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"食品是否新鲜 = 食品保质期 > 食品使用期\n"})}),"\n",(0,s.jsx)(n.p,{children:"那么回归强缓存，上述计算食品是否新鲜的公式同样也适用于强缓存。我们只需要把食品改为强缓存，把食品保质期修改为缓存新鲜度："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"强缓存是否新鲜 = 缓存新鲜度 > 缓存使用期\n"})}),"\n",(0,s.jsxs)(n.p,{children:["按如上公式所示，",(0,s.jsx)(n.strong,{children:"强缓存是否新鲜取决于两个关键词：缓存新鲜度和缓存使用期"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"缓存新鲜度",children:["缓存新鲜度",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存新鲜度",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们先来认识下什么是缓存新鲜度，其和食品保质期概念大体相同，单位是时间长度。那么在浏览器中强缓存的保质期限怎么计算？"}),"\n",(0,s.jsx)(n.p,{children:"小册前面部分章节介绍强缓存时涉及时间单位的首部字段主要有两个：max-age 和 expires。而缓存的新鲜度公式如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"缓存新鲜度 = max-age || (expires - date)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述公式不难理解：当 max-age 存在时缓存新鲜度等于 max-age 的秒数，是一个时间单位，就像保质期为 6 个月一样。当 max-age 不存在时，缓存新鲜度等于 ",(0,s.jsx)(n.code,{children:"expires - date"})," 的值，expires 我们应该已经熟悉，它是一个绝对时间，表示缓存过期的时间，那么下面主要介绍下首部字段 ",(0,s.jsx)(n.strong,{children:"date"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Date 表示创建报文的日期时间"}),"，可以理解为服务器（包含源服务器和代理服务器）返回新资源的时间，和 expires 一样是一个绝对时间，比如"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"date：Wed, 25 Aug 2021 13:52:55 GMT\n"})}),"\n",(0,s.jsx)(n.p,{children:"那么过期时间（expires）减去创建时间（date）就可以计算出浏览器真实可以缓存的时间（默认已经转化为秒数），即缓存的保质期限（缓存新鲜度）。"}),"\n",(0,s.jsx)(n.p,{children:"至此，以上关于缓存新鲜度的计算公式便介绍完了，大家可以把缓存新鲜度看作是缓存的保质期（即浏览器可以缓存该资源的时间）后其公式便不难理解。"}),"\n",(0,s.jsxs)(n.h2,{id:"缓存使用期",children:["缓存使用期",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存使用期",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["相对于缓存新鲜度，缓存使用期的计算就比较复杂了，涉及到的公式和知识点也会相对较多，根据字面意思，",(0,s.jsx)(n.strong,{children:"缓存使用期可以理解为浏览器已经使用该资源的时间"}),"。相比食品的使用期与当前日期和生产日期有关，",(0,s.jsx)(n.strong,{children:"缓存使用期主要与响应使用期、传输延迟时间和停留缓存时间有关"}),"，计算公式如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"缓存使用期 = 响应使用期 + 传输延迟时间 + 停留缓存时间\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"响应使用期",children:["响应使用期",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#响应使用期",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们先来介绍下响应使用期，响应使用期可以通过以下两种方式进行计算："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"max(0, response_time - date_value)"}),"\n",(0,s.jsx)(n.li,{children:"age_value"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["第一种方式中的 ",(0,s.jsx)(n.code,{children:"response_time"}),"（浏览器缓存收到响应的本地时间）是电脑客户端缓存获取到响应的本地时间，而 date_value（响应首部 date 值） 上面已经介绍过是服务器创建报文的时间，两者相减与 0 取最大值。"]}),"\n",(0,s.jsxs)(n.p,{children:["第二种方式直接获取 ",(0,s.jsx)(n.code,{children:"age_value"})," （响应首部 age 值），",(0,s.jsx)(n.strong,{children:"Age 表示推算资源创建经过时间，可以理解为源服务器在多久前创建了响应或在代理服务器中存贮的时长"}),"，单位为秒。如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"age：600\n"})}),"\n",(0,s.jsxs)(n.p,{children:["以下是 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Age",target:"_blank",rel:"noopener noreferrer",children:"MDN"})," 中的介绍"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Age 的值通常接近于 0。表示此对象刚刚从原始服务器获取不久；其他的值则是表示代理服务器当前的系统时间与此应答中的通用头\xa0",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"Date"})}),"\xa0的值之差。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"最终我们可以将以上两种方式进行组合，组合后的计算公式为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"apparent_age = max(0, response_time - date_value) \n响应使用期 = max(apparent_age, age_value)\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"传输延迟时间",children:["传输延迟时间",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#传输延迟时间",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["因为 HTTP 的传输是耗时的，所以传输延迟时间是存在的，",(0,s.jsx)(n.strong,{children:"传输延迟时间可以理解为浏览器缓存发起请求到收到响应的时间差"}),"，其计算公式为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"传输延迟时间 = response_time - request_time\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"response_time"})," 代表浏览器缓存收到响应的本地时间，",(0,s.jsx)(n.code,{children:"request_time"})," 代表浏览器缓存发起请求的本地时间，两者相减便得到了传输延迟时间。"]}),"\n",(0,s.jsxs)(n.h3,{id:"停留缓存时间",children:["停留缓存时间",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#停留缓存时间",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"停留缓存时间表示资源在浏览器上已经缓存的时间，其计算公式为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"停留缓存时间 = now - response_time\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"now"})," 代表电脑客户端的当前时间，",(0,s.jsx)(n.code,{children:"response_time"})," 代表浏览器缓存收到响应的本地时间，两者相减便得到了停留缓存时间。"]}),"\n",(0,s.jsxs)(n.h3,{id:"max-age-仍然受到本地时间影响揭秘",children:["max-age 仍然受到本地时间影响揭秘",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#max-age-仍然受到本地时间影响揭秘",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过上述字段及公式的介绍，最终我们总结出影响强缓存使用期的因素有以下几个："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"age_value：响应首部 age 值\ndate_value：响应首部 date 值\nrequest_time：浏览器缓存发起请求的本地时间\nresponse_time：浏览器缓存收到响应的本地时间\nnow：客户端当前时间\n"})}),"\n",(0,s.jsx)(n.p,{children:"需要注意的是以上 request_time、response_time 和 now 取的都是客户端本地时间，而 now 则是修改客户端本地时间直接导致强缓存失效的“罪魁祸首”。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"因此一旦修改了电脑客户端本地时间为未来时间，缓存使用期的计算便会受到影响，主要是停留缓存时间会变大，从而导致缓存使用期超出缓存新鲜度范围（强缓存失效）。"})," 这便是 max-age 仍然受到本地时间影响的原因所在。"]}),"\n",(0,s.jsxs)(n.h2,{id:"结语",children:["结语",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结语",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"读完本章内容，相信大家对于强缓存已经有了非常深刻的了解，至此对于强缓存的介绍也便告一段落。希望各位读者不要仅局限于文章中所介绍的内容，针对强缓存的探索还需亲自分析与实践，跳出书本的牢笼，寻找更广阔的天地。"}),"\n",(0,s.jsx)(n.p,{children:"关于 HTTP 缓存的介绍，我们也只到了半山腰，后半部分还有很多知识点等待大家汲取与思考，笔者我也会继续带领大家探索 HTTP 缓存中的奥秘。下一章节我们即将开启协商缓存的关卡大门。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}let c=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90%2F4.HTTP%20%E7%BC%93%E5%AD%983%EF%BC%9A%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%E6%96%B0%E9%B2%9C%E5%BA%A6%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%9F%E7%AE%97%E6%B3%95.md"]={toc:[{text:"从“食品是否新鲜”到“强缓存是否新鲜”",id:"从食品是否新鲜到强缓存是否新鲜",depth:2},{text:"缓存新鲜度",id:"缓存新鲜度",depth:2},{text:"缓存使用期",id:"缓存使用期",depth:2},{text:"响应使用期",id:"响应使用期",depth:3},{text:"传输延迟时间",id:"传输延迟时间",depth:3},{text:"停留缓存时间",id:"停留缓存时间",depth:3},{text:"max-age 仍然受到本地时间影响揭秘",id:"max-age-仍然受到本地时间影响揭秘",depth:3},{text:"结语",id:"结语",depth:2}],title:"4.HTTP 缓存3：刨根问底——缓存新鲜度与使用期算法",headingTitle:"4.HTTP 缓存3：刨根问底——缓存新鲜度与使用期算法",frontmatter:{}}}}]);