"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["24156"],{1982:function(n,e,s){s.r(e),s.d(e,{default:()=>x});var r=s(552676),i=s(740453);let h=s.p+"static/image/85c0904cc53a7b45377fc4f3c14b502b.8ed1ec99.webp",c=s.p+"static/image/538ff21f657a8346dfc4f8a2df76729b.b3db41ce.webp",a=s.p+"static/image/5fe425d302e7d06ad8c4e9d72fee8123.2f4dd4d2.webp",d=s.p+"static/image/ae2052116a4ce0fbbc2ea913a3899dea.439d7364.webp";function j(n){let e=Object.assign({h1:"h1",a:"a",p:"p",br:"br",h2:"h2",blockquote:"blockquote",h3:"h3",h4:"h4",code:"code",strong:"strong",img:"img",pre:"pre",ol:"ol",li:"li",ul:"ul"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"7数组的应用真题归纳与解读",children:["7.数组的应用——真题归纳与解读",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#7数组的应用真题归纳与解读",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们现在要开始做题啦！"}),"\n",(0,r.jsxs)(e.p,{children:["万里长征第一步，仍然是数组。",(0,r.jsx)(e.br,{}),"\n","单纯针对数组来考察的题目，总体来说，都不算太难——数组题目要想往难了出，基本都要结合排序、二分和动态规划这些相对复杂的算法思想才行。"]}),"\n",(0,r.jsxs)(e.p,{children:["咱们本节要解决的正是这一类“不算太难”的数组题目——并不是只有难题才拥有成为真题的入场券，一道好题不一定会难，它只要能够反映问题就可以了。",(0,r.jsx)(e.br,{}),"\n","本节所涉及的题目在面试中普遍具有较高的出镜率、同时兼具一定的综合性，对培养大家的通用解题能力大有裨益 。",(0,r.jsx)(e.br,{}),"\n","相信这节你会学得很开心，在轻松中收获自己的第一份算法解题锦囊。"]}),"\n",(0,r.jsxs)(e.h2,{id:"map-的妙用两数求和问题",children:["Map 的妙用——两数求和问题",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#map-的妙用两数求和问题",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["真题描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。",(0,r.jsx)(e.br,{}),"\n","你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。"]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["示例:\n给定 nums = [2, 7, 11, 15], target = 9",(0,r.jsx)(e.br,{}),"\n","因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"思路分析",children:["思路分析：",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,r.jsxs)(e.h4,{id:"一个淳朴的解法",children:["一个“淳朴”的解法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一个淳朴的解法",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["这道题相信很多同学看一眼就很快能得出一个最基本的思路：两层循环来遍历同一个数组；第一层循环遍历的值记为 a，第二层循环时遍历的值记为 b；若 ",(0,r.jsx)(e.code,{children:"a+b = 目标值"}),"，那么 a 和 b 对应的数组下标就是我们想要的答案。"]}),"\n",(0,r.jsxs)(e.h4,{id:"对淳朴解法的反思",children:["对“淳朴”解法的反思",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#对淳朴解法的反思",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"大家以后做算法题的时候，要有这样的一种本能：当发现自己的代码里有两层循环时，先反思一下，能不能用空间换时间，把它优化成一层循环。"}),"\n",(0,r.jsx)(e.p,{children:"因为两层循环很多情况下都意味着 O(n^2) 的复杂度，这个复杂度非常容易导致你的算法超时。即便没有超时，在明明有一层遍历解法的情况下，你写了两层遍历，面试官对你的印象分会大打折扣。"}),"\n",(0,r.jsxs)(e.h4,{id:"空间换时间map-来帮忙",children:["空间换时间，Map 来帮忙",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#空间换时间map-来帮忙",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["拿我们这道题来说，其实二层遍历是完全不必要的。",(0,r.jsx)(e.br,{}),"\n","大家记住一个结论：几乎所有的求和问题，都可以转化为",(0,r.jsx)(e.strong,{children:"求差问题"}),"。\n这道题就是一个典型的例子，通过把求和问题转化为求差问题，事情会变得更加简单。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们可以在遍历数组的过程中，增加一个 Map 来记录已经遍历过的数字及其对应的索引值。然后每遍历到一个新数字的时候，都回到 Map 里去查询 targetNum 与该数的",(0,r.jsx)(e.strong,{children:"差值"}),"是否已经在前面的数字中出现过了。若出现过，那么答案已然显现，我们就不必再往下走了。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们以 ",(0,r.jsx)(e.code,{children:"nums = [2, 7, 11, 15]"})," 这个数组为例，来模拟一下这个思路：",(0,r.jsx)(e.br,{}),"\n","第一次遍历到 2，此时 Map 为空："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"以 2 为 key，索引 0 为 value 作存储，继续往下走；遇到了 7："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"计算 targetNum 和 7 的差值为2，去 Map 中检索 2 这个 key，发现是之前出现过的值："}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)("img",{src:d,alt:""}),"\n那么 2 和 7 的索引组合就是这道题的答案啦。",(0,r.jsx)(e.br,{}),"\n","键值对存储我们可以用 ES6 里的 Map 来做，如果图省事，直接用对象字面量来定义也没什么问题。"]}),"\n",(0,r.jsxs)(e.h4,{id:"编码实现",children:["编码实现",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nconst twoSum = function(nums, target) {\n    // 这里我用对象来模拟 map 的能力\n    const diffs = {}\n    // 缓存数组长度\n    const len = nums.length\n    // 遍历数组\n    for(let i=0;i<len;i++) {\n        // 判断当前值对应的 target 差值是否存在（是否已遍历过）\n        if(diffs[target-nums[i]]!==undefined) {\n            // 若有对应差值，那么答案get！\n            return [diffs[target - nums[i]], i]\n        }\n        // 若没有对应差值，则记录当前值\n        diffs[nums[i]]=i\n    }\n};\n"})}),"\n",(0,r.jsx)(e.p,{children:"tips：这道题也可以用 ES6 中的 Map 来做，你试试呢？"}),"\n",(0,r.jsxs)(e.h2,{id:"强大的双指针法",children:["强大的双指针法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#强大的双指针法",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"合并两个有序数组",children:["合并两个有序数组",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#合并两个有序数组",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["真题描述：给你两个有序整数数组\xa0nums1 和 nums2，请你将 nums2 合并到\xa0nums1\xa0中，使 nums1 成为一个有序数组。",(0,r.jsx)(e.br,{}),"\n","说明: 初始化\xa0nums1 和 nums2 的元素数量分别为\xa0m 和 n 。\n你可以假设\xa0nums1\xa0有足够的空间（空间大小大于或等于\xa0m + n）来保存 nums2 中的元素。"]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["示例:\n输入:",(0,r.jsx)(e.br,{}),"\n","nums1 = [1,2,3,0,0,0], m = 3",(0,r.jsx)(e.br,{}),"\n","nums2 = [2,5,6],       n = 3",(0,r.jsx)(e.br,{}),"\n","输出:\xa0[1,2,2,3,5,6]"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"思路分析-1",children:["思路分析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-1",children:"#"})]}),"\n",(0,r.jsxs)(e.h4,{id:"标准解法",children:["标准解法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#标准解法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"这道题没有太多的弯弯绕绕，标准解法就是双指针法。首先我们定义两个指针，各指向两个数组生效部分的尾部："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"每次只对指针所指的元素进行比较"}),"。取其中较大的元素，把它从 nums1 的末尾往前面填补："]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)("img",{src:c,alt:""}),"\n这里有一点需要解释一下：",(0,r.jsx)(e.br,{}),"\n","为什么是从后往前填补？因为是要把所有的值合并到 nums1 里，所以说我们这里可以把 nums1 看做是一个“容器”。但是这个容器，它不是空的，而是前面几个坑有内容的。如果我们从前往后填补，就没法直接往对应的坑位赋值了（会产生值覆盖）。",(0,r.jsx)(e.br,{}),"\n","从后往前填补，我们填的都是没有内容的坑，这样会省掉很多麻烦。"]}),"\n",(0,r.jsx)(e.p,{children:"由于 nums1 的有效部分和 nums2 并不一定是一样长的。我们还需要考虑其中一个提前到头的这种情况："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"如果提前遍历完的是 nums1 的有效部分，剩下的是 nums2。那么这时意味着 nums1 的头部空出来了，直接把 nums2 整个补到 nums1 前面去即可。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"如果提前遍历完的是 nums2，剩下的是 nums1。由于容器本身就是  nums1，所以此时不必做任何额外的操作。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"编码实现-1",children:["编码实现：",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-1",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nconst merge = function(nums1, m, nums2, n) {\n    // 初始化两个指针的指向，初始化 nums1 尾部索引k\n    let i = m - 1, j = n - 1, k = m + n - 1\n    // 当两个数组都没遍历完时，指针同步移动\n    while(i >= 0 && j >= 0) {\n        // 取较大的值，从末尾往前填补\n        if(nums1[i] >= nums2[j]) {\n            nums1[k] = nums1[i] \n            i-- \n            k--\n        } else {\n            nums1[k] = nums2[j] \n            j-- \n            k--\n        }\n    }\n    \n    // nums2 留下的情况，特殊处理一下 \n    while(j>=0) {\n        nums1[k] = nums2[j]  \n        k-- \n        j--\n    }\n};\n"})}),"\n",(0,r.jsxs)(e.p,{children:["找点乐子：",(0,r.jsx)(e.br,{}),"\n","上面我们给出的，是面试官最喜欢看到的一种解法，这种解法适用于各种语言。",(0,r.jsx)(e.br,{}),"\n","但是就 JS 而言，我们还可以“另辟蹊径”，仔细想想，你有什么妙招？"]}),"\n",(0,r.jsxs)(e.h3,{id:"三数求和问题",children:["三数求和问题",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#三数求和问题",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["双指针法能处理的问题多到你想不到。不信来瞅瞅两数求和它儿子——三数求和问题！",(0,r.jsx)(e.br,{}),"\n","俗话说，青出于蓝而胜于蓝，三数求和虽然和两数求和只差了一个字，但是思路却完全不同。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["真题描述：给你一个包含 n 个整数的数组\xa0nums，判断\xa0nums\xa0中是否存在三个元素 a，b，c ，使得\xa0a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。",(0,r.jsx)(e.br,{}),"\n","注意：答案中不可以包含重复的三元组。"]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"示例：\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，\n满足要求的三元组集合为：\n[\n[-1, 0, 1],\n[-1, -1, 2]\n]"}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"思路分析-2",children:["思路分析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-2",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["三数之和延续两数之和的思路，我们可以",(0,r.jsx)(e.strong,{children:"把求和问题变成求差问题"}),"——固定其中一个数，在剩下的数中寻找是否有两个数和这个固定数相加是等于0的。"]}),"\n",(0,r.jsx)(e.p,{children:"虽然乍一看似乎还是需要三层循环才能解决的样子，不过现在我们有了双指针法，定位效率将会被大大提升，从此告别过度循环~"}),"\n",(0,r.jsx)(e.p,{children:"（这里大家相信已经能察觉出来双指针法的使用场景了，一方面，它可以做到空间换时间；另一方面，它也可以帮我们降低问题的复杂度。）"}),"\n",(0,r.jsx)(e.p,{children:"双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。因此这道题的第一步是将数组排序："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:" nums = nums.sort((a,b)=>{\n    return a-b\n})\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后，对数组进行遍历，每次遍历到哪个数字，就固定哪个数字。然后把左指针指向该数字后面一个坑里的数字，把右指针指向数组末尾，让左右指针从起点开始，向中间前进："}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)("img",{src:h,alt:""}),"\n每次指针移动一次位置，就计算一下两个指针指向数字之和加上固定的那个数之后，是否等于0。如果是，那么我们就得到了一个目标组合；否则，分两种情况来看："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"相加之和大于0，说明右侧的数偏大了，右指针左移"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"相加之和小于0，说明左侧的数偏小了，左指针右移"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"tips：这个数组在题目中要求了“不重复的三元组”，因此我们还需要做一个重复元素的跳过处理。这一点在编码实现环节大家会注意到。"}),"\n",(0,r.jsxs)(e.h4,{id:"编码实现-2",children:["编码实现",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-2",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nconst threeSum = function(nums) {\n    // 用于存放结果数组\n    let res = [] \n    // 给 nums 排序\n    nums = nums.sort((a,b)=>{\n        return a-b\n    })\n    // 缓存数组长度\n    const len = nums.length\n    // 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数\n    for(let i=0;i<len-2;i++) {\n        // 左指针 j\n        let j=i+1 \n        // 右指针k\n        let k=len-1   \n        // 如果遇到重复的数字，则跳过\n        if(i>0&&nums[i]===nums[i-1]) {\n            continue\n        }\n        while(j<k) {\n            // 三数之和小于0，左指针前进\n            if(nums[i]+nums[j]+nums[k]<0){\n                j++\n               // 处理左指针元素重复的情况\n               while(j<k&&nums[j]===nums[j-1]) {\n                    j++\n                }\n            } else if(nums[i]+nums[j]+nums[k]>0){\n                // 三数之和大于0，右指针后退\n                k--\n               \n               // 处理右指针元素重复的情况\n               while(j<k&&nums[k]===nums[k+1]) {\n                    k--\n                }\n            } else {\n                // 得到目标数字组合，推入结果数组\n                res.push([nums[i],nums[j],nums[k]])\n                \n                // 左右指针一起前进\n                j++  \n                k--\n               \n                // 若左指针元素重复，跳过\n                while(j<k&&nums[j]===nums[j-1]) {\n                    j++\n                }  \n               \n               // 若右指针元素重复，跳过\n               while(j<k&&nums[k]===nums[k+1]) {\n                    k--\n                }\n            }\n        }\n    }\n    \n    // 返回结果数组\n    return res\n};\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"双指针法中的对撞指针法",children:["双指针法中的“对撞指针”法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#双指针法中的对撞指针法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在上面这道题中，左右指针一起从两边往中间位置相互迫近，这样的特殊双指针形态，被称为“对撞指针”。"}),"\n",(0,r.jsxs)(e.p,{children:["什么时候你需要联想到对撞指针？",(0,r.jsx)(e.br,{}),"\n","这里我给大家两个关键字——“有序”和“数组”。",(0,r.jsx)(e.br,{}),"\n","没错，见到这两个关键字，立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！"]}),"\n",(0,r.jsx)(e.p,{children:"即便数组题目中并没有直接给出“有序”这个关键条件，我们在发觉普通思路走不下去的时候，也应该及时地尝试手动对其进行排序试试看有没有新的切入点——没有条件，创造条件也要上。"}),"\n",(0,r.jsx)(e.p,{children:"对撞指针可以帮助我们缩小问题的范围，这一点在“三数求和”问题中体现得淋漓尽致：因为数组有序，所以我们可以用两个指针“画地为牢”圈出一个范围，这个范围以外的值不是太大就是太小、直接被排除在我们的判断逻辑之外，这样我们就可以把时间花在真正有意义的计算和对比上。如此一来，不仅节省了计算的时间，更降低了问题本身的复杂度，我们做题的速度也会大大加快。"}),"\n",(0,r.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(j,{...n})}):j(n)}let x=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%2F7.%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%9C%9F%E9%A2%98%E5%BD%92%E7%BA%B3%E4%B8%8E%E8%A7%A3%E8%AF%BB.md"]={toc:[{text:"Map 的妙用——两数求和问题",id:"map-的妙用两数求和问题",depth:2},{text:"思路分析：",id:"思路分析",depth:3},{text:"一个“淳朴”的解法",id:"一个淳朴的解法",depth:4},{text:"对“淳朴”解法的反思",id:"对淳朴解法的反思",depth:4},{text:"空间换时间，Map 来帮忙",id:"空间换时间map-来帮忙",depth:4},{text:"编码实现",id:"编码实现",depth:4},{text:"强大的双指针法",id:"强大的双指针法",depth:2},{text:"合并两个有序数组",id:"合并两个有序数组",depth:3},{text:"思路分析",id:"思路分析-1",depth:3},{text:"标准解法",id:"标准解法",depth:4},{text:"编码实现：",id:"编码实现-1",depth:4},{text:"三数求和问题",id:"三数求和问题",depth:3},{text:"思路分析",id:"思路分析-2",depth:4},{text:"编码实现",id:"编码实现-2",depth:4},{text:"双指针法中的“对撞指针”法",id:"双指针法中的对撞指针法",depth:3}],title:"7.数组的应用——真题归纳与解读",headingTitle:"7.数组的应用——真题归纳与解读",frontmatter:{}}}}]);