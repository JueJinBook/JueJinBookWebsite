"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["8107"],{379867:function(n,e,s){s.r(e),s.d(e,{default:()=>l});var a=s(552676),i=s(740453);function t(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",strong:"strong",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li"},(0,i.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"23-探索模型优势使用-llm-来-算命-的-chatbot",children:["23-探索模型优势：使用 LLM 来 “算命” 的 chatbot",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#23-探索模型优势使用-llm-来-算命-的-chatbot",children:"#"})]}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsxs)(e.p,{children:["本章对应源代码：",(0,a.jsx)(e.a,{href:"https://github.com/RealKai42/langchainjs-juejin/tree/main/node/gua",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/RealKai42/langchainjs-juejin/tree/main/node/gua"})]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"这一章节我们换一个思路去思考 llm 的应用和实战。 llm 本质上是一个语言模型，其基于预训练的模型，根据用户输入的 prompt 去生成最大概率的下一个字符（token）。换句话说，其最擅长的是“把话说圆”。 在前面的章节中，我们讲解了 llm 展现出来的是涌现的智能，他并不理解输出内容的意义，而是一个根据概率吐出 token 的机器。"}),"\n",(0,a.jsx)(e.p,{children:"我们在 agents 章节，尝试了用 llm 作为推理引擎去制作 agents，也就是让 llm 有逻辑的去处理事情。在 ReAct 框架中，我们会强制让 llm 将自己的思考过程（Thought）和 Action 记录下来，是为了在生成下一个步骤的时候，模型会根据此信息去计算概率生成，让涌现的智能可控。即，虽然 agents 中，模型展示出了足够的逻辑能力，但这并不是模型天然具有的，是我们通过各种方式在模型基于概率的基础上，更好的激发其涌现的智能。"}),"\n",(0,a.jsxs)(e.p,{children:["回到模型目前非常棘手的问题，幻觉问题。RAG 是解决幻觉问题非常好用的手段，因为它可以把 ground truth（事实）作为上下文嵌入到模型输入中，来减少模型输出错误信息的 ",(0,a.jsx)(e.strong,{children:"概率"}),"。即，我们依旧在跟模型没有逻辑这件事作斗争，依靠各种提高概率的方式去让模型更大程度的输出正确信息。回到幻觉的本质，就是因为模型没有逻辑，他只是根据你的上下文去做完形填空的任务，所以容易出现语意上合理，但偏离事实的情况。就像你让它写代码，它经常会出现不存在的 API，但它介绍 API 的时候一本正经，API 也很合理，就像真实存在一样。"]}),"\n",(0,a.jsx)(e.p,{children:"而，目前 LLM 的基础模型已经非常强大了，并且对普通的工程师也很难参与到底层模型的构建和训练上，我们能做的就是展开在应用层深入使用的想象力。对我们来说，缺的不是强大的模型，而是有趣且有意义的应用场景，和快速落地 llm app 的能力，后者在 langchain 的帮助下，已经不是问题了。"}),"\n",(0,a.jsx)(e.p,{children:"所以，这一章，我带大家去写一些不一样的工具。既然 llm 逻辑能力不强，更强的是 “把话说圆”，也就是“见人说人话，见鬼说鬼话”，我第一时间想到的就是算命，无论是 塔罗牌、八卦、六爻等等传统算命，都有根据卦象和来者的具体问题，去解析和把话说圆的成分。"}),"\n",(0,a.jsx)(e.p,{children:"我相信 llm 展现出来的能力会让你震惊，那就让我们开始吧！"}),"\n",(0,a.jsxs)(e.h2,{id:"算卦流程",children:["算卦流程",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#算卦流程",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"我们这次实现的是六爻算卦的流程。首先，我并不是算法的专家，这个也是我现学的，不能保证流程的正确性，仅仅是用来练习和测试玩具。"}),"\n",(0,a.jsx)(e.p,{children:"通俗来讲，进行六爻占卜需要的三枚硬币，每次丢三枚硬币叫生成卦象的一部分，一共丢六次，称为六爻。"}),"\n",(0,a.jsx)(e.p,{children:"每次丢硬币的时候，如果正面数量比背面多，那就是阳；背面比正面多，就是阴。每三个阴阳就能组成八卦中的一卦，两个卦就能对应八八六十四卦中的一个卦象，也就有对应的解读。"}),"\n",(0,a.jsx)(e.p,{children:"举例："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"初爻 为 背字背 为 阴\n二爻 为 字背字 为 阳\n三爻 为 背背背 为 阴\n您的首卦为 坎\n四爻 为 字字字 为 阳\n五爻 为 背背背 为 阴\n六爻 为 字字背 为 阳\n您的次卦为 震\n\n六爻结果: 震坎  \n卦名为：屯卦   \n水雷屯（屯卦）起始维艰   \n卦辞为：风刮乱丝不见头，颠三倒四犯忧愁，慢从款来左顺遂，急促反惹不自由   \n"})}),"\n",(0,a.jsxs)(e.h2,{id:"算卦流程实现",children:["算卦流程实现",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#算卦流程实现",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"八卦和八卦对应的信息属于是有真实答案的类别，一般这种类别不要让 llm 自己生成，大家可以测试一下，一般会输出一些不存在的卦象和解读。"}),"\n",(0,a.jsx)(e.p,{children:"所以，类似于 RAG 的思路，我们把标准的算卦流程和真实的八卦信息，由我们代码生成，并在后续 chat 中，直接嵌入到 llm 上下文中。"}),"\n",(0,a.jsx)(e.p,{children:"具体的实现过程就是把算卦流程编码化，写起来比较繁琐，但逻辑很简单。"}),"\n",(0,a.jsx)(e.p,{children:"首先，我们定义一个生成 “一次爻” 的函数"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'  const yaoName = ["初爻", "二爻", "三爻", "四爻", "五爻", "六爻"];\n  \n  const genYao = () => {\n    const coinRes = Array.from({ length: 3 }, () => (Math.random() > 0.5 ? 1 : 0));\n    const yinYang = coinRes.reduce((a, b) => a + b, 0) > 1.5 ? "阳" : "阴";\n    const message = `${yaoName[yaoCount]} 为 ${coinRes\n      .map((i) => (i > 0.5 ? "字" : "背"))\n      .join("")} 为 ${yinYang}`;\n\n    return {\n      yinYang,\n      message,\n    };\n  };\n'})}),"\n",(0,a.jsx)(e.p,{children:"然后，我们就模拟算卦的流程："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'  let yaoCount = 0;\n  const messageList = [];\n\n  const firstGuaYinYang = Array.from({ length: 3 }, () => {\n    const { yinYang, message } = genYao();\n    yaoCount++;\n\n    messageList.push(message);\n    return yinYang;\n  });\n  const firstGua = guaDict[firstGuaYinYang.join("")];\n  messageList.push(`您的首卦为 ${firstGua}`);\n\n  const secondGuaYinYang = Array.from({ length: 3 }, () => {\n    const { yinYang, message } = genYao();\n    yaoCount++;\n\n    messageList.push(message);\n    return yinYang;\n  });\n  const secondGua = guaDict[secondGuaYinYang.join("")];\n  messageList.push(`您的次卦为 ${secondGua}`);\n\n  const gua = secondGua + firstGua;\n  const guaDesc = guaInfo[gua];\n\n  const guaRes = `\n六爻结果: ${gua}  \n卦名为：${guaDesc.name}   \n${guaDesc.des}   \n卦辞为：${guaDesc.sentence}   \n  `;\n\n  messageList.push(guaRes);\n'})}),"\n",(0,a.jsx)(e.p,{children:"其中，guaDict 就是我们穷举了八卦的所有情况："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'const guaDict = {\n  阳阳阳: "乾",\n  阴阴阴: "坤",\n  阴阳阳: "兑",\n  阳阴阳: "震",\n  阳阳阴: "巽",\n  阴阳阴: "坎",\n  阳阴阴: "艮",\n  阴阴阳: "离",\n};\n'})}),"\n",(0,a.jsx)(e.p,{children:"具体完整的源码，大家可以看 github 中的源代码进行参考。"}),"\n",(0,a.jsxs)(e.h2,{id:"chat-bot-实现",children:["Chat bot 实现",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#chat-bot-实现",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"然后我们就可以来实现 chatbot，首先在 app 运行的时候，我们就直接去拿到所有六爻生成的信息："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"const messageList = generateGua();\n"})}),"\n",(0,a.jsxs)(e.p,{children:["其中 ",(0,a.jsx)(e.code,{children:"generateGua"})," 就是上一小节中写的函数。然后，我们把代码生成的算卦信息，作为 ai 输出的内容，嵌入到 prompt 中："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'  const guaMessage = messageList.map((message): ["ai", string] => ["ai", message]);\n\n  const prompt = await ChatPromptTemplate.fromMessages([\n    [\n      "system",\n      `你是一位出自中华六爻世家的卜卦专家，你的任务是根据卜卦者的问题和得到的卦象，为他们提供有益的建议。\n你的解答应基于卦象的理解，同时也要尽可能地展现出乐观和积极的态度，引导卜卦者朝着积极的方向发展。\n你的语言应该具有仙风道骨、雅致高贵的气质，以此来展现你的卜卦专家身份。`,\n    ],\n    ...guaMessage,\n    new MessagesPlaceholder("history_message"),\n    ["human", "{input}"],\n  ]);\n'})}),"\n",(0,a.jsxs)(e.p,{children:["这里，我们也留出了 ",(0,a.jsx)(e.code,{children:"history_message"})," 的 place holder，方便后续插入历史聊天记录。"]}),"\n",(0,a.jsxs)(e.p,{children:["然后，我们创建一个简单的 chat chain。这里我们使用了 ",(0,a.jsx)(e.code,{children:"RunnableWithMessageHistory"})," 去给 chain 添加历史聊天记录的能力："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'  const llm = new ChatOpenAI();\n  const chain = prompt.pipe(llm).pipe(new StringOutputParser());\n  const chainWithHistory = new RunnableWithMessageHistory({\n    runnable: chain,\n    getMessageHistory: (_sessionId) => history,\n    inputMessagesKey: "input",\n    historyMessagesKey: "history_message",\n  });\n'})}),"\n",(0,a.jsx)(e.p,{children:"像之前一样，我们使用 node 内置的 readline 模块去实现在 cli 的交互："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  const question = util.promisify(rl.question).bind(rl);\n\n  const input = await question("告诉我你的疑问: ");\n  \n  let index = 0;\n  const printMessagesPromise = new Promise<void>((resolve) => {\n    const intervalId = setInterval(() => {\n      if (index < messageList.length) {\n        console.log(messageList[index]);\n        index++;\n      } else {\n        clearInterval(intervalId);\n        resolve();\n      }\n    }, 1000);\n  });\n\n  const llmResPromise = chainWithHistory.invoke(\n    { input: "用户的问题是：" + input },\n    { configurable: { sessionId: "no-used" } }\n  );\n\n  const [_, firstRes] = await Promise.all([printMessagesPromise, llmResPromise]);\n'})}),"\n",(0,a.jsx)(e.p,{children:"这里，我们使用一些小技巧。"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["我们使用 ",(0,a.jsx)(e.code,{children:"util.promisify"})," 去生成了一个 promise 化的 question，方面我们使用 async await 的风格进行异步的编程。"]}),"\n",(0,a.jsxs)(e.li,{children:["因为 llm 的返回比较耗时，所以我们用已经生成的算法流程的 messageList，去创建了一个 ",(0,a.jsx)(e.code,{children:"printMessagesPromise"}),"，会以 1s 的间隔去打印算卦的流程，让用户无形中等待 llm 请求的返回。"]}),"\n",(0,a.jsx)(e.li,{children:"然后使用 Promise.all 等待这两个 promise 返回。"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"最后效果就是，当用户输入自己问题后，第一时间就会发送 llm 请求，然后开始以 1s 的间隔输入算卦的过程，让用户觉得正在有一个赛博大师正在现场算卦。"}),"\n",(0,a.jsx)(e.p,{children:"然后，当 llm 请求返回后，就将返回的内容输出出来。并且我们用 realine 去创建了能在 cli 中聊天的流程："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'  const [_, firstRes] = await Promise.all([printMessagesPromise, llmResPromise]);\n\n  console.log(firstRes);\n\n  async function chat() {\n    const input = await question("User: ");\n\n    if (input.toLowerCase() === "exit") {\n      rl.close();\n      return;\n    }\n\n    const response = await chainWithHistory.invoke(\n      { input },\n      { configurable: { sessionId: "no-used" } }\n    );\n\n    console.log("AI: ", response);\n    chat();\n  }\n\n  chat();\n'})}),"\n",(0,a.jsx)(e.p,{children:"然后我们来测试一下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"告诉我你的疑问: 今晚吃不吃火锅\n初爻 为 背字字 为 阳\n二爻 为 字背背 为 阴\n三爻 为 背背背 为 阴\n您的首卦为 艮\n四爻 为 字背背 为 阴\n五爻 为 字背字 为 阳\n六爻 为 字背背 为 阴\n您的次卦为 坎\n\n六爻结果: 坎艮  \n卦名为：蒙卦   \n山水蒙（蒙卦）启蒙奋发   \n卦辞为：卦中爻象犯小耗，君子占之运不高，婚姻合伙有琐碎，做事必然受苦劳   \n  \n蒙卦是启蒙奋发的象征，卦中爻象犯小耗，君子占之运不高。以此卦象来看，吃火锅可谓是一种“小耗”，而且可能会带\n来一些琐碎的麻烦，如消化不良、辛辣刺激等。因此建议您今晚内省养生，以清淡饮食为主，待身心调整良好，再考虑\n享受火锅之乐也未迟。犹如卦中所示，启蒙奋发，需先立足于身体的康健。俗话说，身体是革命的本钱，希望您能够以\n健康为重，更能够在未来的日子里，拥有更好的精神状态去面对生活。\nUser: 我的首卦意味着什么\nAI:  您的首卦是艮卦，艮为山，足艮其德，心行其义，佛道之士能居其位无非也。\n\n艮卦代表了停止和立定，是一种稳重、安静、内向的状态。艮卦需要人们保持清晰的头脑，以稳定的决心去实现目标。\n在处事方面，艮卦建议我们要有耐心，要克制冲动，遵循一种稳步向前的道路。\n\n艮卦也提醒我们，任何事情都不能一味地求快，要懂得适时的停止，稳重、安静的考虑对策，不急躁、不冲动，这样才\n能获得最终的成功。尤其是在面临困难、疑惑的时候，更应静下心来细细思考，以艮卦的智慧指引前行之路。\nUser: 那我的 五爻 是什么解读\nAI:  咱们的五爻为阳爻，卦象上仍属于艮坎之蒙卦。在六爻中，五爻常常被视为君位，具有决策和引领的作用。阳爻\n象征着刚劲有力、主动进取的态势。\n\n五爻在这里，即提示您在面对选择时，要采取主动和积极的态度，走出自己的舒适区，创新和尝试新的可能性。同时也\n建议您以稳健之心来面对生活中各种挑战，坚持自己的信念，积极应对，勇往直前。\n\n即使可能面临困境，也有成就的机会。如咱们所卜之蒙卦，虽为困境困顿，但启蒙奋发的情景却逐渐浮现，这是一种因\n困境中求新生的勇敢。因此在您面临选择时，也许正需坚韧之心与创新之意，走出困境，在疑云中寻找属于自己的明星。\nUser: exit\n"})}),"\n",(0,a.jsx)(e.p,{children:"这是完整的流程，你可以看到因为我们加入了 chat history，llm 可以根据用户问题持续解读卦象。"}),"\n",(0,a.jsx)(e.p,{children:"得益于 llm zero shot 的能力，我们在其上下文中输入了整个的算卦流程，他就可以根据算卦流程中的信息去回答用户的问题。"}),"\n",(0,a.jsx)(e.p,{children:"从输出结果来看，llm 把话说圆的能力非常适合算卦的场景，他能有效的把用户的问题和随机生成的卦象挂钩，进行解读。并且我们在 prompt 指定其语言风格是 “仙风道骨、雅致高贵的气质”，只使用这简单的指令，就能控制 llm 的语言风格。"}),"\n",(0,a.jsx)(e.p,{children:"大家可以用不同的去把玩一下，也可以尝试去问一下离谱的问题，感受 llm 把话说圆的优势。并尝试调整 system prompt，去试试这个高权重的 prompt 能在多大程度上影响 llm 的输出风格和质量。"}),"\n",(0,a.jsxs)(e.h2,{id:"小结",children:["小结",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"本实战在使用的知识上是我们写过非常多次的基础 llm chain，从代码量上大家也能感受到跟 llm 相关的代码只占很小部分。"}),"\n",(0,a.jsx)(e.p,{children:"所以，llm 的应用的核心不是 llm，而是合适的用户场景和 idea，也就是我们常说的对业务的理解。所以，我们应该通过学习去掌握 llm 的特点和优势，去思考现在的场景和业务有哪些可以很好的利用 llm 的优势，有哪些在 llm 的帮助下可以解决之前解决不了的问题。"})]})}function r(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(t,{...n})}):t(n)}let l=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%20AI%EF%BC%9ALangChain.js%20%E5%85%A5%E9%97%A8%E5%92%8C%E5%AE%9E%E6%88%98_online%2F23-%E6%8E%A2%E7%B4%A2%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8A%BF%EF%BC%9A%E4%BD%BF%E7%94%A8%20LLM%20%E6%9D%A5%20%E2%80%9C%E7%AE%97%E5%91%BD%E2%80%9D%20%E7%9A%84%20chatbot.md"]={toc:[{text:"算卦流程",id:"算卦流程",depth:2},{text:"算卦流程实现",id:"算卦流程实现",depth:2},{text:"Chat bot 实现",id:"chat-bot-实现",depth:2},{text:"小结",id:"小结",depth:2}],title:"23-探索模型优势：使用 LLM 来 “算命” 的 chatbot",headingTitle:"23-探索模型优势：使用 LLM 来 “算命” 的 chatbot",frontmatter:{}}}}]);