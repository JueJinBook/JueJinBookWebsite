"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["28248"],{741932:function(n,e,r){r.r(e),r.d(e,{default:()=>c});var d=r(552676),i=r(740453);function s(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",h3:"h3",pre:"pre",code:"code",del:"del",ol:"ol",li:"li",br:"br",strong:"strong",h4:"h4"},(0,i.ah)(),n.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.h1,{id:"11-因为-dry所以-hof",children:["11 因为 DRY，所以 HOF",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11-因为-dry所以-hof",children:"#"})]}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"标题注解：DRY(Don't Repeat Yourself) 是一种软件设计原则，HOF(High Order Function)指高阶函数。"}),"\n"]}),"\n",(0,d.jsxs)(e.h2,{id:"李雷的前端生涯第一课",children:["李雷的前端生涯第一课",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#李雷的前端生涯第一课",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"在展开 DRY 和 HOF 这两个话题之前，我们不妨先来看一个发生在实际研发过程中的案例。"}),"\n",(0,d.jsx)(e.p,{children:"（以下案例基于作者在现实生活中的工作经历，如有雷同，纯属缘分~）"}),"\n",(0,d.jsxs)(e.h3,{id:"李雷很累我很困惑",children:["李雷很累，我很困惑",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#李雷很累我很困惑",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"两年前，我所在的团队启动了一个性能监控的技术专项。"}),"\n",(0,d.jsx)(e.p,{children:"其中涉及到一个和函数计算相关的监控指标，期望可以拿到业务中每个函数的执行时间，以此来估算整体的前端计算效率。"}),"\n",(0,d.jsx)(e.p,{children:"我把这个活交给了团队刚来的实习生小伙子李雷。"}),"\n",(0,d.jsx)(e.p,{children:"我说：小兄弟，这个不着急，接下来一周可以慢慢做，慢工才能出细活嘛。"}),"\n",(0,d.jsx)(e.p,{children:"李雷：没问题，请好吧您。"}),"\n",(0,d.jsx)(e.p,{children:"就这样，一周过去了。"}),"\n",(0,d.jsx)(e.p,{children:"这天我写完周报，转悠到李雷的工位，想看看功能实现得咋样了。"}),"\n",(0,d.jsx)(e.p,{children:"我问李雷：这周感觉怎么样？你这边没有啥业务需求，应该挺轻松的吧？"}),"\n",(0,d.jsx)(e.p,{children:"李雷：轻松个锤子，我快累死了！怪不得外面都说你们团队卷，这么繁重的工作只给我一周，我都想离职了！"}),"\n",(0,d.jsx)(e.p,{children:"这，一周写一个函数，繁。重。。。？"}),"\n",(0,d.jsx)(e.p,{children:"我大受震撼。"}),"\n",(0,d.jsx)(e.p,{children:"说话间，我立刻拉取了李雷的 remote dev 分支，开始帮他做 code review。"}),"\n",(0,d.jsxs)(e.h3,{id:"李雷的代码我很头大",children:["李雷的代码，我很头大",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#李雷的代码我很头大",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"我随手点开了一个已经被李雷改造过的业务函数，它差不多长这样（解析在注释里）："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"// monitor 指代我们团队自研的性能上报sdk（虽然它实际不叫这个名字），大家意会一下即可\nimport monitor from 'monitor'  \n\nexport function computeOrderAmount(xxx, xxx) {\n  // 开始时间打点\n  const startTime = Date.now()  \n  // 中间是一段超级长的业务逻辑，此处以...省略\n  ... \n  ...  \n\n  // 结束时间打点\n  const endTime = Date.now()  \n\n  // 调用 monitor，第一个入参标识上报类型，第二个入参是需要上报的时间信息\n  monitor.report(\n    'function-compute-time',\n    // 结束时间 - 开始时间，就得到了函数执行需要的时间\n    endTime - startTime  \n  )\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"上面是一个脱敏了 N 次之后的极简版本，在实际上报过程中，我们不仅会收集函数的执行时间，还会上报函数的业务归属、函数的执行上下文、以及一些更加细致琐碎的信息。"}),"\n",(0,d.jsx)(e.p,{children:"也就是说，虽然这里大家只看到了 3 行有意义的上报代码，但实际情况下，每个函数里和监控上报有关的代码增量估计在 10-20 行之间。"}),"\n",(0,d.jsx)(e.p,{children:"李雷是怎么做的呢？"}),"\n",(0,d.jsx)(e.p,{children:"他给业务里的每一个函数，都增加了 10-20 的监控代码。"}),"\n",(0,d.jsx)(e.p,{children:"那么我们的业务里一共有多少个函数呢？"}),"\n",(0,d.jsx)(e.p,{children:"保守估计，应该有 1000+。"}),"\n",(0,d.jsx)(e.p,{children:"我问李雷：你是打算用一周的时间徒手写两万行代码吗？"}),"\n",(0,d.jsx)(e.p,{children:"李雷义愤填膺：啊？那不然嘞？"}),"\n",(0,d.jsx)(e.p,{children:"我叹了一口气：朋友，你听说过安利DRY吗？"}),"\n",(0,d.jsx)(e.p,{children:"李雷一脸错愕：啥？搁这儿背单词了？ Dry 我知道，形容词，adj，干燥的！"}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.del,{children:"我直接好家伙"}),"我直接放弃挣扎， 打开 VSCode 给他出了一道题。"]}),"\n",(0,d.jsxs)(e.h3,{id:"小试牛刀对一个数组进行自定义迭代计算",children:["小试牛刀：对一个数组进行自定义迭代计算",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小试牛刀对一个数组进行自定义迭代计算",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"题目——使用原生 JS，实现如下三个函数："}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsxs)(e.li,{children:["迭代做加法：函数入参为一个数字数组，对数组中每个元素做 +1 操作，并把计算结果输出到一个新数组 ",(0,d.jsx)(e.code,{children:"newArr"}),"。",(0,d.jsx)(e.br,{}),"\n","fe：输入",(0,d.jsx)(e.code,{children:"  [1,2,3] "}),"，输出",(0,d.jsx)(e.code,{children:"  [2,3,4] "})]}),"\n",(0,d.jsxs)(e.li,{children:["迭代做乘法：函数入参为一个数字数组，对数组中每个元素做 *3 操作，并把计算结果输出到一个新数组 ",(0,d.jsx)(e.code,{children:"newArr"}),"。",(0,d.jsx)(e.br,{}),"\n","fe：输入",(0,d.jsx)(e.code,{children:"  [1,2,3] "}),"，输出 ",(0,d.jsx)(e.code,{children:"[3,6,9]"})]}),"\n",(0,d.jsxs)(e.li,{children:["迭代做除法：函数入参为一个数字数组，对数组中每个元素做 /2 操作，并把计算结果输出到一个新数组 ",(0,d.jsx)(e.code,{children:"newArr"}),"。",(0,d.jsx)(e.br,{}),"\n","fe：输入 ",(0,d.jsx)(e.code,{children:"[2,4,6]"}),"，输出 ",(0,d.jsx)(e.code,{children:"[1,2,3]"})]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"这题不难，李雷刷刷两下就做完了，他交出的代码如下："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"// 迭代做加法\nfunction arrAdd1(arr) {\n  const newArr = []  \n  for(let i=0; i<arr.length; i++) {\n    newArr.push(arr[i]+1)\n  }\n  return newArr\n}  \n\n// 迭代做乘法 \nfunction arrMult3(arr) {\n  const newArr = []  \n  for(let i=0; i<arr.length; i++) {\n    newArr.push(arr[i]*3)\n  }\n  return newArr\n} \n\n// 迭代做除法\nfunction arrDivide2(arr) {\n  const newArr = []  \n  for(let i=0; i<arr.length; i++) {\n    newArr.push(arr[i]/2)\n  }\n  return newArr\n} \n\n// 输出 [2, 3, 4]\nconsole.log(arrAdd1([1,2,3]))   \n// 输出 [3, 6, 9]\nconsole.log(arrMult3([1,2,3])) \n// 输出 [1, 2, 3]\nconsole.log(arrDivide2([2,4,6]))  \n"})}),"\n",(0,d.jsx)(e.p,{children:"我们可以看到，这三个函数的输出都是符合预期的，代码逻辑也没有毛病。"}),"\n",(0,d.jsx)(e.p,{children:"问题出在代码的设计上，李雷忘记了 DRY 原则。"}),"\n",(0,d.jsxs)(e.h2,{id:"什么是-dry-原则",children:["什么是 DRY 原则？",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是-dry-原则",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"DRY 是一个缩写，全拼是 Don't Repeat Yourself。"}),"\n",(0,d.jsx)(e.p,{children:"直译过来，就是“不要重复你自己”"}),"\n",(0,d.jsx)(e.p,{children:"这是一个重要的设计原则，也是程序员的基本行事准则。"}),"\n",(0,d.jsx)(e.p,{children:"具体到编码上来，就是提醒我们，不要做重复的工作，不要把同一段代码写N次。"}),"\n",(0,d.jsx)(e.p,{children:"当我们多次遇到同一个问题，多次用到重复的解法时，我们就应该把重复的这部分提取出来，而不是 ctrl-c + ctrl-v 四处复制粘贴。"}),"\n",(0,d.jsxs)(e.h2,{id:"dry-原则的-js-实践hof高阶函数",children:["DRY 原则的 JS 实践：HOF(高阶函数）",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#dry-原则的-js-实践hof高阶函数",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"现在我们本着 DRY 的原则，对李雷的答案做一波改造。"}),"\n",(0,d.jsx)(e.p,{children:"实践 DRY 原则最重要的一点，就是将“变与不变”分离。这也是我在设计模式小册中反复跟大家强调的一个核心的设计原则。"}),"\n",(0,d.jsx)(e.p,{children:"就李雷的代码来说，“变与不变”分别对应哪些逻辑？"}),"\n",(0,d.jsx)(e.p,{children:"很明显，对于这三个函数来说，迭代loop、数组push动作都是一毛一样的，变化的仅仅是循环体里的数学算式而已。"}),"\n",(0,d.jsx)(e.p,{children:"数学算式是“变”，其余逻辑是“不变”。"}),"\n",(0,d.jsx)(e.p,{children:"我们把不变的逻辑提取出来，代码如下："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"function arrCompute(arr) {\n  const newArr = []  \n  for(let i=0; i<arr.length; i++) {\n    // xxx 指的是变化的算式\n    newArr.push(xxx)\n  }\n  return newArr\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"不变的代码，我们应该把它提取为一个通用的函数。"}),"\n",(0,d.jsx)(e.p,{children:"变化的部分怎么处理呢？"}),"\n",(0,d.jsx)(e.p,{children:"大家可以思考一下，对于一个函数来说，它的三个要素（入参、函数体、出参）里，哪些要素是动态的？"}),"\n",(0,d.jsx)(e.p,{children:"这时不妨回顾一下，什么是函数？函数就是下面这个东西："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{children:"y = f(x)\n"})}),"\n",(0,d.jsxs)(e.p,{children:["出参 ",(0,d.jsx)(e.code,{children:"y"})," 是因变量，函数体 ",(0,d.jsx)(e.code,{children:"f"})," 是计算逻辑，函数入参 ",(0,d.jsx)(e.code,{children:"x"})," 就是自变量。"]}),"\n",(0,d.jsx)(e.p,{children:"函数体一旦被定义了就无法再修改，所以，我们使用函数体来承接“不变”。"}),"\n",(0,d.jsx)(e.p,{children:"因变量和自变量都是动态可变的，但因变量变化的前提是自变量的变化。"}),"\n",(0,d.jsx)(e.p,{children:"自变量确定的情况下，因变量也是不变的。"}),"\n",(0,d.jsx)(e.p,{children:"因此，唯一可以用来承接“变”的要素，只有自变量。也就是函数的入参。"}),"\n",(0,d.jsxs)(e.p,{children:["我们要想办法把变化的算式，作为一个入参传递给 ",(0,d.jsx)(e.code,{children:"arrCompute()"}),"。"]}),"\n",(0,d.jsx)(e.p,{children:"在一些语言中，你或许可以直接把一坨计算逻辑作为入参传递给函数。但在 JS 的世界里，这是行不通的，要想把逻辑作为入参传递，我们必须把它包装成函数。"}),"\n",(0,d.jsx)(e.p,{children:"于是，本着“不变”构造成通用函数体，“变”包装成函数作为入参传递的原则，我们可以把李雷的代码改写成下面这样："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"// +1 函数 \nfunction add1(num) {\n  return num + 1  \n}  \n\n// *3函数\nfunction mult3(num) {\n  return num * 3 \n}  \n\n// /2函数\nfunction divide2(num) {\n  return num / 2\n}\n\nfunction arrCompute(arr, compute) {\n  const newArr = []  \n  for(let i=0; i<arr.length; i++) {\n    // 变化的算式以函数的形式传入\n    newArr.push(compute(arr[i]))\n  }\n  return newArr\n}\n\n// 输出 [2, 3, 4]\nconsole.log(arrCompute([1,2,3], add1))\n// 输出 [3, 6, 9]\nconsole.log(arrCompute([1,2,3], mult3)) \n// 输出 [1, 2, 3]\nconsole.log(arrCompute([2,4,6], divide2))  \n"})}),"\n",(0,d.jsx)(e.p,{children:"这样一来，我们就用一种更简洁、更优美的姿势，实现了同样的功能。"}),"\n",(0,d.jsxs)(e.p,{children:["其中的 ",(0,d.jsx)(e.code,{children:"arrCompute()"})," 函数，就是一个高阶函数。"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"高阶函数，指的就是接收函数作为入参，或者将函数作为出参返回的函数。"})}),"\n",(0,d.jsxs)(e.h2,{id:"why-hof高阶函数改造前后对比",children:["WHY HOF——高阶函数改造前后对比",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#why-hof高阶函数改造前后对比",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"既然实现的都是同样的功能，为什么我们程序员一定要 DRY、为什么用高阶函数来做就比复制粘贴梭哈更好呢？"}),"\n",(0,d.jsx)(e.p,{children:"我们从几个不同的角度来聊聊这个话题。"}),"\n",(0,d.jsxs)(e.h3,{id:"更简洁的代码方便读写",children:["更简洁的代码，方便读写",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#更简洁的代码方便读写",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"别的不说，咱就直接先看楼上的这个例子。"}),"\n",(0,d.jsx)(e.p,{children:"对比数组计算这几个函数，改造后的代码，给人最直接的感受，就是比改造前的代码要简洁许多。"}),"\n",(0,d.jsx)(e.p,{children:"这个 case 里我们提取的公共逻辑不算很复杂，实际上越复杂的公共逻辑，提取前后的代码行数对比越明显。"}),"\n",(0,d.jsx)(e.p,{children:"通过抽取重复的逻辑到高阶函数里，我们可以减少大量复制粘贴带来的冗余代码。"}),"\n",(0,d.jsx)(e.p,{children:"更少的代码，意味着更小的编码负担，更好的可读性。"}),"\n",(0,d.jsxs)(e.h4,{id:"更小的编码负担",children:["更小的编码负担",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#更小的编码负担",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"对于李雷的性能上报任务来说，1000个函数，每个函数里人肉增加 20-30 行重复代码，也要写上几万行。"}),"\n",(0,d.jsx)(e.p,{children:"若能提取一个高阶函数出来，那么他最多只需要给 1000 多个函数逐个包装一层高阶函数的调用。"}),"\n",(0,d.jsx)(e.p,{children:"几万行 vs 1000多行，四舍五入等于不用写代码（狂笑）。"}),"\n",(0,d.jsxs)(e.h4,{id:"更好的可读性",children:["更好的可读性",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#更好的可读性",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"这里我并不是说只有高阶函数能够改善代码的可读性，而是说你提取任意逻辑到一个函数里、然后给它起一个恰当的名字，都能够改善代码的可读性。"}),"\n",(0,d.jsx)(e.p,{children:"仍然是性能上报这个 case，如果我们不提取代码到高阶函数里，那么同事读到李雷改造过的业务代码，他的反应估计是这样的："}),"\n",(0,d.jsx)(e.p,{children:"这里看上去好像被新来的那个小伙子改过了，我来看看具体改了啥。额，1-10行，好像是打了一些时间戳、记录了一些业务上下文；额，倒数后 20 行，好像是在调用性能 sdk，上报一些参数......喔，这原来是在做性能上报啊！"}),"\n",(0,d.jsxs)(e.p,{children:["同事不得不逐行阅读李雷写的每一行代码，才能够推测出他的意图，",(0,d.jsx)(e.strong,{children:"因为这段逻辑没有一个名字"}),"。"]}),"\n",(0,d.jsx)(e.p,{children:"而定义函数的过程，恰恰就是给一段逻辑起名字的过程啊，家人们！"}),"\n",(0,d.jsx)(e.p,{children:"我给这段性能上报的逻辑起名叫 performanceReport，然后在任何一个业务函数调用时，都用 performanceReport 这样包裹它一下："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"performanceReport(anyFunction)\n"})}),"\n",(0,d.jsx)(e.p,{children:"这样一来，是不是地球人都能一眼看出来，我这里要做性能上报了？"}),"\n",(0,d.jsx)(e.p,{children:"这，就是可读性。"}),"\n",(0,d.jsxs)(e.h3,{id:"代码可复用利人利己",children:["代码可复用，利人利己",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码可复用利人利己",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"用高阶函数，最直接的目的就是为了能够复用代码，减少重复，避免复制粘贴。"}),"\n",(0,d.jsx)(e.p,{children:"对于李雷来说， 他自己写的代码，自己自然是熟悉的，复制粘贴顶多算是一个体力活。"}),"\n",(0,d.jsx)(e.p,{children:"但如果明天韩梅梅想写一个类似的功能，她就不得不自己重新实现一遍李雷写过的逻辑。"}),"\n",(0,d.jsx)(e.p,{children:"对于性能上报这个场景来说，这是我分配给李雷的一个技术专项，如何完成上报、如何调用app底层的性能sdk，按道理其它同事不需要去关注这其中的实现细节。"}),"\n",(0,d.jsx)(e.p,{children:"但由于李雷没有去做逻辑的提取，导致韩梅梅不得不深入到李雷改造的每一个函数中，去看实现的细节，然后再把这些实现的细节搬运到自己的函数里。"}),"\n",(0,d.jsx)(e.p,{children:"实践 DRY 原则，不仅仅是为了方便自己的工作，也是为了提升整个团队的研发效率。"}),"\n",(0,d.jsxs)(e.h3,{id:"清晰的逻辑边界更少的测试工作",children:["清晰的逻辑边界，更少的测试工作",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#清晰的逻辑边界更少的测试工作",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"咱们说了，对于李雷来说， 他自己写的代码，自己自然是熟悉的，复制粘贴顶多算是一个体力活。"}),"\n",(0,d.jsx)(e.p,{children:"但，谁能保证复制粘贴的过程，不会出错呢？"}),"\n",(0,d.jsx)(e.p,{children:"有没有可能，李雷在某个业务函数 A 里多贴了一行，在另一个业务函数 B 里少贴了一行，甚至在业务函数 C 里不小心把性能上报代码揉进业务代码里去了，干扰了业务层面的输出。"}),"\n",(0,d.jsx)(e.p,{children:"这些都是很有可能的，因为李雷是人，人远没有计算机可靠。"}),"\n",(0,d.jsx)(e.p,{children:"因为不可靠的人类无法保证每一个函数的质量，测试就不得不对 1000 多个函数做全面的回归。"}),"\n",(0,d.jsx)(e.p,{children:"但实际上，业务函数本身是不变的，我们的本意仅仅是在原有的基础上做一个性能上报的增量而已。"}),"\n",(0,d.jsx)(e.p,{children:"也就是说，讲道理，如果我们研发能够提前把变与不变通过函数的形式划分清楚，那么测试根本不需要做那么多重复的工作，他只需要对增量部分的函数（也就是高阶函数 performanceReport）做测试就可以了。"}),"\n",(0,d.jsxs)(e.h2,{id:"总结",children:["总结",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"本节，我们从一个实习生小兄弟的乌龙事件讲起，从解法、原则、动机等几个方面，全面认识了高阶函数这个东西。"}),"\n",(0,d.jsx)(e.p,{children:"事实上，高阶函数带来的利好，并不完全是高阶函数所特有的。"}),"\n",(0,d.jsx)(e.p,{children:"确切来说，这些利好是 DRY 原则带来的，是将“变与不变”明确分离的思维习惯带来的。"}),"\n",(0,d.jsx)(e.p,{children:"无论是设计模式，还是函数式编程，我总在反复强调“变与不变分离”这回事。在我看来，这一点，可以说是“如何写出好代码”这个问题的终极要义。"}),"\n",(0,d.jsx)(e.p,{children:"在接下来的几个小节中，我们还会接触到更多的函数式编程之“术”。彼时，相信大家会对这一点有更深刻的感悟。"}),"\n",(0,d.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(s,{...n})}):s(n)}let c=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F11%20%E5%9B%A0%E4%B8%BA%20DRY%EF%BC%8C%E6%89%80%E4%BB%A5%20HOF.md"]={toc:[{text:"李雷的前端生涯第一课",id:"李雷的前端生涯第一课",depth:2},{text:"李雷很累，我很困惑",id:"李雷很累我很困惑",depth:3},{text:"李雷的代码，我很头大",id:"李雷的代码我很头大",depth:3},{text:"小试牛刀：对一个数组进行自定义迭代计算",id:"小试牛刀对一个数组进行自定义迭代计算",depth:3},{text:"什么是 DRY 原则？",id:"什么是-dry-原则",depth:2},{text:"DRY 原则的 JS 实践：HOF(高阶函数）",id:"dry-原则的-js-实践hof高阶函数",depth:2},{text:"WHY HOF——高阶函数改造前后对比",id:"why-hof高阶函数改造前后对比",depth:2},{text:"更简洁的代码，方便读写",id:"更简洁的代码方便读写",depth:3},{text:"更小的编码负担",id:"更小的编码负担",depth:4},{text:"更好的可读性",id:"更好的可读性",depth:4},{text:"代码可复用，利人利己",id:"代码可复用利人利己",depth:3},{text:"清晰的逻辑边界，更少的测试工作",id:"清晰的逻辑边界更少的测试工作",depth:3},{text:"总结",id:"总结",depth:2}],title:"11 因为 DRY，所以 HOF",headingTitle:"11 因为 DRY，所以 HOF",frontmatter:{}}}}]);