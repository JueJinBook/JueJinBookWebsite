"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75132"],{11161:function(e,c,n){n.r(c),n.d(c,{default:()=>u});var s=n(552676),r=n(740453);let a=n.p+"static/image/93e41d6948fcb7bf2ded674b895a9a4c.fb15af6e.webp",i=n.p+"static/image/6da813d042d7d49e4282c7ea11b69b07.0395b80d.webp",t=n.p+"static/image/2ef8b21bd61529c90c361f7683c16b6c.15a96735.webp",d=n.p+"static/image/5691786f96fedaeb57f9987bd4b0af74.fab73b1a.webp",p=n.p+"static/image/1ecc9c5360552a04c9549760a2aac190.b6da67df.webp",j=n.p+"static/image/b41889dcc22aa5377e313db0da30e88f.53d5f4ca.webp",h=n.p+"static/image/854ac508ff31dc4cec10a482f9531fcf.d8492f23.webp",b=n.p+"static/image/79eab41e44db8d83d1a39ff735ea03f6.9881b3ce.webp",l=n.p+"static/image/a79f22111bd0a4f0aa219223505207ee.c0a5c7df.webp",f=n.p+"static/image/93e6c94c5799e5d75777a556cbdbc35c.cd4c28d2.webp",o=n.p+"static/image/a4414c7ed59dbab1963bc3b4dfd29a97.cf84536b.webp",x=n.p+"static/image/c9692ed27abb319d0041533622d7b94c.8ef2ca6b.webp";function g(e){let c=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(c.h1,{id:"24加餐用-project-reference-优化-tsc-编译性能",children:["24.加餐：用 Project Reference 优化 tsc 编译性能",(0,s.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#24加餐用-project-reference-优化-tsc-编译性能",children:"#"})]}),"\n",(0,s.jsx)(c.p,{children:"TypeScript 给 JavaScript 添加了一套类型系统，可以在编译期间检查出类型错误，这增加了代码的健壮性，但也多了一个编译的过程。"}),"\n",(0,s.jsx)(c.p,{children:"ts 编译速度与项目规模有关，如果项目比较大，代码很多，那就需要编译很长一段时间。"}),"\n",(0,s.jsx)(c.p,{children:"有没有什么办法可以提升 tsc 编译的性能呢？"}),"\n",(0,s.jsx)(c.p,{children:"还真有，TypeScript 3.0 的时候实现了 Project Reference 的特性，就是用于优化编译和类型检查的性能的。"}),"\n",(0,s.jsx)(c.p,{children:"那 Project Reference 是干什么的呢？"}),"\n",(0,s.jsxs)(c.h2,{id:"project-reference",children:["Project Reference",(0,s.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#project-reference",children:"#"})]}),"\n",(0,s.jsx)(c.p,{children:"想象这样一个场景。项目目录下有两个相对独立的模块 aaa 和 bbb"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"它们是用同一个 tsconfig.json 来配置编译方式的："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"执行 tsc 就会编译所有 include 的文件到 dist 目录下："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"假设 aaa 和 bbb 都很大，编译要很久，但是两者的关联还不是特别大。"}),"\n",(0,s.jsx)(c.p,{children:"aaa 模块下的变动基本和 bbb 模块下的没啥关系，但是 aaa 变了，bbb 也要重新编译一遍，bbb 变了 aaa 也要重新编译一遍，这就很没必要。"}),"\n",(0,s.jsx)(c.p,{children:"有的同学说，那在 aaa 和 bbb 下分别放一个 tsconfig.json，各自编译各自的不就行了？"}),"\n",(0,s.jsx)(c.p,{children:"这样是可以，但是这样就是多次编译了，比较麻烦。"}),"\n",(0,s.jsx)(c.p,{children:"能不能还是一次编译，但是对一些相对独立的模块做下缓存，不要跟随别的模块一起编译呢？"}),"\n",(0,s.jsx)(c.p,{children:"可以的，这就是 Project Reference 做的事情了。"}),"\n",(0,s.jsx)(c.p,{children:"在 aaa 和 bbb 下各自创建一个 tsconfig.json，放各自的编译配置。注意这里要加一个 composite: true，这是 Project Reference 需要的："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"然后在根目录的 tsconfig.json 里加上一个 references 的配置，引入 aaa 和 bbb："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这样再执行 tsc --build 进行编译，你会发现编译结果多了 .d.ts 的声明，还多了 tsconfig.tsbuildinfo 的文件："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"打开 tsconfig.tsbuildinfo 看一下，会发现它记录了编译了哪些文件，还记录了这些文件的 hash 值："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"看到这里，你是不是就知道为啥它能实现缓存了？"}),"\n",(0,s.jsx)(c.p,{children:"没错，就是对比文件的 hash，当编译到这个 project 的时候，会对比下 hash 有没有变化，变了才去编译。没变的就直接跳过了。"}),"\n",(0,s.jsx)(c.p,{children:"而且，别的地方可能用到这个 project 的类型，所以需要生成 d.ts 声明文件，这就是为啥我们没有指定 declaration: true 的配置，但是编译产物里还是有 d.ts。其实这是 composite 选项做的，它设置了 Project Reference 需要的一些编译选项："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"现在当你修改了 aaa 下某个模块的代码，重新编译的时候就不会编译 bbb 了，只会编译 aaa 下的那个模块。"}),"\n",(0,s.jsx)(c.p,{children:"这就是 Project Reference 的作用。"}),"\n",(0,s.jsx)(c.p,{children:"当然，这种编译模式和常规的编译模式不同，所以不是直接用 tsc 来编译，而是用 tsc --build 或者 tsc -b。"}),"\n",(0,s.jsx)(c.p,{children:"此外，Project Reference 还支持通过 prepend 指定编译顺序，比如给 bbb 添加 prepend: true，那么就会先编译 bbb，再编译当前项目，然后编译 aaa："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"其实很容易想到，monorepo 里就可以用 Project Reference 来提升 tsc 的编译性能。因为 monorepo 下的多个 project 相互之间都比较独立，一个模块的改动一般不会影响另一个模块，所以编译的时候也应该各自做缓存。"}),"\n",(0,s.jsx)(c.p,{children:"举个真实项目的例子吧："}),"\n",(0,s.jsx)(c.p,{children:"nest 之前是 gulp + tsc 的方式来编译的："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"之后为了优化编译性能，换成 tsc 的 project reference 的方式了："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(c.h2,{id:"总结",children:["总结",(0,s.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(c.p,{children:"TypeScript 3.0 时实现了 Project Reference 来优化性能。"}),"\n",(0,s.jsx)(c.p,{children:"如果项目下有一些相对独立的模块，别的模块的变动不影响它，但是它却要跟着重新编译一次，这时就可以用 Project Reference 来优化了。"}),"\n",(0,s.jsx)(c.p,{children:"在独立的模块下添加 tsconfig.json，加上 composite 的编译选项，在入口的 tsconfig.json 里配置 references 引用这些独立的模块。然后执行 tsc --build 或者 tsc -b 来编译。"}),"\n",(0,s.jsx)(c.p,{children:"这时候就实现了编译和类型检查的性能优化。"}),"\n",(0,s.jsx)(c.p,{children:"原理是编译时会生成 tsconfig.tsbuildinfo 的文件，记录着编译的文件和它们的 hash，当再次编译的时候，如果文件 hash 没变，那就直接跳过，从而提升了编译速度。"}),"\n",(0,s.jsx)(c.p,{children:"这是 TypeScript 提供的编译性能优化机制，当项目比较大，tsc 执行的速度比较慢的时候，不妨尝试一下。"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,r.ah)(),e.components);return c?(0,s.jsx)(c,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}let u=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F24.%E5%8A%A0%E9%A4%90%EF%BC%9A%E7%94%A8%20Project%20Reference%20%E4%BC%98%E5%8C%96%20tsc%20%E7%BC%96%E8%AF%91%E6%80%A7%E8%83%BD.md"]={toc:[{text:"Project Reference",id:"project-reference",depth:2},{text:"总结",id:"总结",depth:2}],title:"24.加餐：用 Project Reference 优化 tsc 编译性能",headingTitle:"24.加餐：用 Project Reference 优化 tsc 编译性能",frontmatter:{}}}}]);