"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["36093"],{148007:function(e,n,i){e.exports=i.p+"static/image/0e97abeda4c6f5e186b1905bfd95a06c.1a07284a.webp"},283365:function(e,n,i){e.exports=i.p+"static/image/2636ea360a7cb385e089b569054145ab.42009dfc.webp"},291548:function(e,n,i){e.exports=i.p+"static/image/4b1a437af5cc728cf2077b23181dc1ed.1b9916ad.webp"},4619:function(e,n,i){e.exports=i.p+"static/image/7e29e9ff26fbfe33b7a4738b111d4ec7.c2a3c703.webp"},494327:function(e,n,i){e.exports=i.p+"static/image/986d69c1353aa8d78dda2030db8441e6.3b4f7777.webp"},309234:function(e,n,i){e.exports=i.p+"static/image/c5854b09228cee723a4368f4237caac8.e22912d1.webp"},434846:function(e,n,i){e.exports=i.p+"static/image/e257ae6fed9fa9f328be0e3a5d2dbf79.9f53f5ce.gif"},162342:function(e,n,i){e.exports=i.p+"static/image/e66738a1f6bb483aa298d89472c695d8.9cea7520.webp"},316632:function(e,n,i){i.r(n),i.d(n,{default:()=>u});var s=i(552676),r=i(740453),c=i(162342),d=i(148007),t=i(309234),o=i(283365),l=i(291548),h=i(494327),x=i(434846),j=i(4619);function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",img:"img",h2:"h2",strong:"strong",pre:"pre",h3:"h3",ol:"ol",li:"li",blockquote:"blockquote",h4:"h4"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"7-时序相关的异步-apitimersetimmediateprocessnexttick-与-queuemicrotask上",children:["7-时序相关的异步 API：Timer、setImmediate()、process.nextTick() 与 queueMicrotask()（上）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-时序相关的异步-apitimersetimmediateprocessnexttick-与-queuemicrotask上",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 Node.js 中，异步体现在方方面面。不一定所有异步都与 I/O 有关。",(0,s.jsx)(n.code,{children:"Timer"})," 相关的 API 就是与 I/O 无关的异步 API。"]}),"\n",(0,s.jsxs)(n.p,{children:["还记得之前在事件循环相关章节中提到的 ",(0,s.jsx)(n.code,{children:"libuv"})," 设计概览吗？"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["一个事件循环除了 ",(0,s.jsx)(n.code,{children:"Poll for I/O"})," 之外，前前后后还包了好几层。所谓的 ",(0,s.jsx)(n.code,{children:"Timer"})," 就在 ",(0,s.jsx)(n.code,{children:"Run due timers"})," 这层。而 ",(0,s.jsx)(n.code,{children:"setImmediate()"}),"、",(0,s.jsx)(n.code,{children:"process.nextTick()"})," 这些则分别在其他几层。"]}),"\n",(0,s.jsxs)(n.h2,{id:"settimeout-到底是哪的函数怎么实现的",children:[(0,s.jsx)(n.code,{children:"setTimeout"})," 到底是哪的函数？怎么实现的？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#settimeout-到底是哪的函数怎么实现的",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["很多人可能都有一种误解，一个 JavaScript 运行时天生就应该有 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 这些函数。因为它实在是太常用了，在 Web 应用中真的是无处不在，在各种跨端场景中，也是最基础的 API 之一。Node.js、Deno 这些运行时都有。",(0,s.jsx)(n.strong,{children:"它就是引擎中提供的 API！"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"你要这么想就错了。"})," ",(0,s.jsx)(n.code,{children:"setTimeout"})," 并非 ECMAScript 规范，而是 ",(0,s.jsx)(n.a,{href:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout-dev",title:"https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout-dev",target:"_blank",rel:"noopener noreferrer",children:"Web API"}),"。之所以 Node.js、Deno 这些都有，是因为这个 API 太深入人心了，不实现不舒服斯基。我们可以粗暴地理解为，ECMAScript 不定义穿插于事件循环不同 Tick 间的 API。"]}),"\n",(0,s.jsxs)(n.p,{children:["而问 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 怎么实现的，这个问题也很泛。这个问题在知乎上有：",(0,s.jsx)(n.a,{href:"https://www.zhihu.com/question/463446982",title:"https://www.zhihu.com/question/463446982",target:"_blank",rel:"noopener noreferrer",children:"JS 中 setTimeout 的实现机理是什么？"})]}),"\n",(0,s.jsx)(n.p,{children:"其实，抛开运行时问实现的都是耍流氓。下面的回答也都提了类似的这点，不同运行时实现机制不一样。各种答案里也给出了各种不同运行时的实现方式。"}),"\n",(0,s.jsxs)(n.p,{children:["比如貘大给出了 ",(0,s.jsx)(n.a,{href:"https://www.zhihu.com/question/463446982/answer/1927924014",title:"https://www.zhihu.com/question/463446982/answer/1927924014",target:"_blank",rel:"noopener noreferrer",children:"Chromium 里面怎么实现的"}),"；Justjavac 介绍了 ",(0,s.jsx)(n.a,{href:"https://www.zhihu.com/question/463446982/answer/1927307187",title:"https://www.zhihu.com/question/463446982/answer/1927307187",target:"_blank",rel:"noopener noreferrer",children:"Deno 是基于红黑树搞的定时器"}),"；还有大佬披露了 ",(0,s.jsx)(n.a,{href:"https://www.zhihu.com/question/463446982/answer/1927781623",title:"https://www.zhihu.com/question/463446982/answer/1927781623",target:"_blank",rel:"noopener noreferrer",children:"React Native 的定时器"}),"是基于优先队列的。而我",(0,s.jsx)(n.a,{href:"https://www.zhihu.com/question/463446982/answer/1927686503",title:"https://www.zhihu.com/question/463446982/answer/1927686503",target:"_blank",rel:"noopener noreferrer",children:"在当时开发的运行时里"}),"，也是用 C 写了个优先队列在事件循环里搞定计时器的。"]}),"\n",(0,s.jsx)(n.p,{children:"一千个读者有一千个哈姆雷特，一千个厨师炒一千碗粉的味道也各自不同。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"nodejs-中的-settimeout",children:["Node.js 中的 ",(0,s.jsx)(n.code,{children:"setTimeout()"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中的-settimeout",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Node.js 的 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 并不完全按规范来实现。比如 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 的返回值 ",(0,s.jsx)(n.code,{children:"id"})," 在规范中，是一个整数（",(0,s.jsx)(n.code,{children:"integer"}),"），而 Node.js 实际上返回的是一个对象。还有一个就是网上常有的八股问题，如果嵌套层级大于 5，超时时间小于 4，则定义超时时间最小为 4——这个八股问题对 Node.js 同样不生效。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 Node.js 中，",(0,s.jsx)(n.code,{children:"setTimeout()"})," 实际上是生成一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 类的实例，在其内部控制定时器并触发回调，并且这个函数返回的也是该实例，并不是整数。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function setTimeout(callback, after, arg1, arg2, arg3) {\n  // ...\n\n  const timeout = new Timeout(callback, after, args, false, true);\n  insert(timeout, timeout._idleTimeout);\n\n  return timeout;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里有几个点好提。第一个是 ",(0,s.jsx)(n.code,{children:"args"})," 的生成。我们看到 Node.js 声明 ",(0,s.jsx)(n.code,{children:"setTimeout"})," 的时候，其参数除了前两个外，后面还额外附加了 ",(0,s.jsx)(n.code,{children:"arg1"}),"、",(0,s.jsx)(n.code,{children:"arg2"})," 和 ",(0,s.jsx)(n.code,{children:"arg3"}),"。这个是根据经验定的 3 个调用参数，基本上的情况下，调用 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 回调函数的参数不会超过 3 个，于是这里显示声明 3 个，为生成 ",(0,s.jsx)(n.code,{children:"args"})," 用。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  let i, args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1, arg2];\n      break;\n    default:\n      args = [arg1, arg2, arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically, makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果刚好是 3 个参数以内的，在生成 ",(0,s.jsx)(n.code,{children:"args"})," 的时候会直接声明一个定长数组，这比后续不断去扩展数组来得快。如果再超长了，那再去动态扩展 ",(0,s.jsx)(n.code,{children:"args"})," 数组长度。"]}),"\n",(0,s.jsxs)(n.h3,{id:"两个关键对象map-与优先队列",children:["两个关键对象：",(0,s.jsx)(n.code,{children:"Map"})," 与优先队列",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#两个关键对象map-与优先队列",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["后面那个 ",(0,s.jsx)(n.code,{children:"insert()"})," 函数，是把新生成的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例插入两个对象中："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["一个 ",(0,s.jsx)(n.code,{children:"Map"}),"，其键名为 ",(0,s.jsx)(n.code,{children:"timeout"})," 的值，键值为一条存储同 ",(0,s.jsx)(n.code,{children:"timeout"})," 值的所有 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例的链表，链表中额外存了一个最近的最终超时时间，用于做一些判断；"]}),"\n",(0,s.jsxs)(n.li,{children:["一个",(0,s.jsx)(n.a,{href:"https://zh.wikipedia.org/zh-hans/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97",title:"https://zh.wikipedia.org/zh-hans/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97",target:"_blank",rel:"noopener noreferrer",children:"优先队列"}),"，以链表的最终超时时间点为优先队列的权重。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这两个对象看起来像这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"图中的时间为为方便表示而随机拟的时间，所以有瑕疵。事实上通常来说，一个"})," ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"10ms"})})," ",(0,s.jsx)(n.strong,{children:"的链表中是不可能存在头尾节点差距超过"})," ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"10ms"})})," ",(0,s.jsx)(n.strong,{children:"的情况。除非是一个同步的大循环（比如该同步大循环会耗时 100ms）中不断插入"})," ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Timeout"})})," ",(0,s.jsx)(n.strong,{children:"。如："})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const timer1 = setTimeout(() => {\n  console.log(1);\n  const timer3 = setTimeout(() => {\n    console.log(3);\n  }, 10);\n  console.log(timer3);\n}, 10);\nconsole.log(timer1)\nconst now = Date.now();\nwhile (Date.now() - now < 200) {\n  //\n}\nconst timer2 = setTimeout(() => {\n  console.log(2);\n}, 10);\nconsole.log(timer2);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["从图中看，这是一个拥有 10 个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的场景的两个对象表示图。10ms 定时器的最近过期时间为 1676275438020，64ms 的为 1676275438027，而 100ms 的则为 1676275438011。这个时候，优先队列中，以最近超时为权重，自然就是 100ms 的链表、10ms 链表、64ms 链表这个顺序了。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"上方优先队列的图只是为了简易展示数据便于理解，真实优先队列内部的数据结构并不是这样的。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Node.js 这么管理 ",(0,s.jsx)(n.code,{children:"Timeout"})," 对象是为了在使用的时候方便些。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function insert(item, msecs, start = getLibuvNow()) {\n  // Truncate so that accuracy of sub-millisecond timers is not assumed.\n  msecs = MathTrunc(msecs);\n  item._idleStart = start;\n\n  // Use an existing list if there is one, otherwise we need to make a new one.\n  let list = timerListMap[msecs];\n  if (list === undefined) {\n    debug('no %d list was found in insert, creating a new one', msecs);\n    const expiry = start + msecs;\n    timerListMap[msecs] = list = new TimersList(expiry, msecs);\n    timerListQueue.insert(list);\n\n    if (nextExpiry > expiry) {\n      scheduleTimer(msecs);\n      nextExpiry = expiry;\n    }\n  }\n\n  L.append(list, item);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面这段代码就是 ",(0,s.jsx)(n.code,{children:"insert()"})," 逻辑了。我们忽略前面几行代码，无关紧要。",(0,s.jsx)(n.code,{children:"let list = ..."})," 这句就是从上面图中那个 ",(0,s.jsx)(n.code,{children:"Map"})," 对象中拿到对应 ",(0,s.jsx)(n.code,{children:"timeout"})," 的链表。若链表不存在，我给你现充一个，并为其赋值过期时间（",(0,s.jsx)(n.code,{children:"const expiry = start + msecs"}),"），这个过期时间就是最近超时时间了。生成链表后，将该链表往 ",(0,s.jsx)(n.code,{children:"Map"})," 中一插，并同时往优先队列中一插，就完成了。我们先略过 ",(0,s.jsx)(n.code,{children:"scheduleTimer()"}),"，直接到最后，如果事情都做完了，我再把传进来的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 对象往刚才拿到或者生成出来的链表中插到最后一位即可。"]}),"\n",(0,s.jsxs)(n.p,{children:["比如，若现在时间是 1676275438008，我现在往其中插入一个 1ms 的 ",(0,s.jsx)(n.code,{children:"Timeout"}),"，其对象的变化如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"思考："})," 为什么在 ",(0,s.jsx)(n.code,{children:"Map"})," 中，用链表就可以了，不用优先队列或其他一些有序列表？"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"提示："})," 时间是一往无前不能回头的，同个 ",(0,s.jsx)(n.code,{children:"timeout"})," 值的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 在不同时刻创建时，其超时顺序是怎么样的？"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这两个关键对象对 ",(0,s.jsx)(n.code,{children:"Timeout"})," 起着比较重要的管理作用。"]}),"\n",(0,s.jsxs)(n.h3,{id:"就一个定时器",children:["就“一个”定时器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#就一个定时器",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们前面提到了，一次 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 就生成一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例，实际上 ",(0,s.jsx)(n.code,{children:"setInterval()"})," 同理，只是 ",(0,s.jsx)(n.code,{children:"Timeout"})," 里面的“是否循环”字段不一样而已。这样看起来，一次 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 我们就多了一个定时器，至少表面上看起来是这样的。"]}),"\n",(0,s.jsxs)(n.p,{children:["你要说 JavaScript 层，的确看起来如此，而且被 ",(0,s.jsx)(n.code,{children:"Map"})," 和优先队列管理起来。实际上，这只是 JavaScript 侧的类，并不实际参与调度，只是在真正 libuv 定时器调度的时候，被引用一下而已。真正在 libuv 层，定时器就一个。"]}),"\n",(0,s.jsxs)(n.h4,{id:"uv_timer_t",children:[(0,s.jsx)(n.code,{children:"uv_timer_t"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#uv_timer_t",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["libuv 中，定时器是以定时器句柄（",(0,s.jsx)(n.code,{children:"uv_timer_t"}),"）的形式进行操作的。而在事件循环中激活一个定时器，它是靠",(0,s.jsx)(n.a,{href:"http://docs.libuv.org/en/v1.x/timer.html#c.uv_timer_start",title:"http://docs.libuv.org/en/v1.x/timer.html#c.uv_timer_start",target:"_blank",rel:"noopener noreferrer",children:"这个 API 的"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"int uv_timer_start(uv_timer_t *handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们通过 ",(0,s.jsx)(n.code,{children:"uv_timer_start"})," 对一个已初始化的定时器进行激活。事件循环运行过程中，它会在 ",(0,s.jsx)(n.code,{children:"timeout"})," 时间到之后触发传入的 ",(0,s.jsx)(n.code,{children:"cb"})," 回调函数。最后一个参数代表“是否循环”，即触发一次之后，是否等 ",(0,s.jsx)(n.code,{children:"timeout"})," 时间到会再次出发。"]}),"\n",(0,s.jsxs)(n.p,{children:["你很聪明，这个 ",(0,s.jsx)(n.code,{children:"repeat"})," 参数看起来的确可以用于区分 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 和 ",(0,s.jsx)(n.code,{children:"setInterval()"}),"。不过 Node.js 中的 ",(0,s.jsx)(n.code,{children:"Timer"})," 机制并非如此，通过 ",(0,s.jsx)(n.code,{children:"uv_timer_start()"})," 中的 ",(0,s.jsx)(n.code,{children:"repeat"})," 参数指定并不适用。"]}),"\n",(0,s.jsxs)(n.h4,{id:"nodejs-中针对-timer-的定时器",children:["Node.js 中针对 ",(0,s.jsx)(n.code,{children:"Timer"})," 的定时器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中针对-timer-的定时器",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Node.js 中，针对 ",(0,s.jsx)(n.code,{children:"Timer"})," 的单个定时器被存在 ",(0,s.jsx)(n.code,{children:"Environment"})," 类中。",(0,s.jsx)(n.code,{children:"Environment"})," 是针对 Node.js 中每个 V8 的 ",(0,s.jsx)(n.code,{children:"Isolate"})," 都存在一份的环境相关类，里面有很多相关的工具、数据等等。因为 ",(0,s.jsx)(n.code,{children:"Timer"})," 只需要一份，所以作为执行数据存在 ",(0,s.jsx)(n.code,{children:"Environment"})," 中也是自然的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"class Environment : public ... {\n  ...\n  inline uv_timer_t* timer_handle() { return &timer_handle_; }\n  uv_timer_t timer_handle_;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个 ",(0,s.jsx)(n.code,{children:"timer_handle_"})," 怎么初始化就不提了，不重要。重要的是，还记得之前那段 ",(0,s.jsx)(n.code,{children:"insert()"})," 代码吗？里面有这段我故意跳过没讲的条件判断："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if (nextExpiry > expiry) {\n  scheduleTimer(msecs);\n  nextExpiry = expiry;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里就是做这个定时器调度的代码了。首先有个 ",(0,s.jsx)(n.code,{children:"nextExpiry"})," 变量，存的是所有 ",(0,s.jsx)(n.code,{children:"Timeout"})," 中，最近要过期的时间。也就是说，如果回到上面那个图，中间应该还有一步，就是用 ",(0,s.jsx)(n.code,{children:"expiry"})," 替换掉这个 ",(0,s.jsx)(n.code,{children:"nextExpiry"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"思考："})," 为什么这个替换只出现在“",(0,s.jsx)(n.code,{children:"Map"})," 中不存在该链表”的情况下做判断？"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"提示："})," 还是跟之前一样，时序相关。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["上面的代码中，我们除了替换 ",(0,s.jsx)(n.code,{children:"nextExpiry"}),"，还要更新那个 ",(0,s.jsx)(n.code,{children:"timer_handle_"})," 的触发事件，也将其更新为最新的 ",(0,s.jsx)(n.code,{children:"nextExpiry"}),"。这样，定时器就会在更近的这个新时间点触发了。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"scheduleTimer()"})," 中，最终调用到的是 ",(0,s.jsx)(n.code,{children:"Environment::ScheduleTimer()"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void Environment::ScheduleTimer(int64_t duration_ms) {\n  if (started_cleanup_) return;\n  uv_timer_start(timer_handle(), RunTimers, duration_ms, 0);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["不管第一行，是边界条件。所以里面实际上最终是执行我们刚才提到的 ",(0,s.jsx)(n.code,{children:"uv_timer_start()"}),"。如果这个定时器处于未激活状态，则将该定时器触发事件改为传进来的最新时间并激活；如果定时器已经处于激活状态，则直接通过 ",(0,s.jsx)(n.code,{children:"uv_timer_start()"})," 将定时器的触发事件更新为最新时间。逻辑很简单：",(0,s.jsx)(n.strong,{children:"我只需要一个定时器触发最近一次"})," ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"Timeout"})})," ",(0,s.jsx)(n.strong,{children:"，触发后我再取一个最近的时间开始定时。"})]}),"\n",(0,s.jsxs)(n.h4,{id:"定时器回调",children:["定时器回调",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定时器回调",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"timer_handle_"})," 这个定时器中，一旦定时器被触发，执行的始终是传进去的 ",(0,s.jsx)(n.code,{children:"RunTimers()"})," 回调函数。这个函数也是写在 ",(0,s.jsx)(n.code,{children:"Environment"})," 中的。它的作用是经过一系列逻辑后，调用到 JavaScript 侧的定时回调函数，在那个函数中才会去找对应的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 并触发对应的真实回调函数，即该 ",(0,s.jsx)(n.code,{children:"RunTimers()"})," 最终达到的是一个 Dispatcher 的效果。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"RunTimers()"})," 中，参数规定是当前触发当前定时的 ",(0,s.jsx)(n.code,{children:"uv_timer_t"})," 句柄。并且，该函数是可以以简单函数指针的形式传给 ",(0,s.jsx)(n.code,{children:"uv_timer_start()"}),"，它得是一个 ",(0,s.jsx)(n.code,{children:"static"})," 静态方法。所以在这个内部是无法通过 ",(0,s.jsx)(n.code,{children:"this"})," 来代表对应的 ",(0,s.jsx)(n.code,{children:"Environment"})," 实例的，Node.js 就用了一个 ",(0,s.jsx)(n.code,{children:"Environment::from_timer_handle()"})," 静态方法来让我们可以通过对应 ",(0,s.jsx)(n.code,{children:"uv_timer_t"})," 获取其所属的 ",(0,s.jsx)(n.code,{children:"Environment"})," 实例。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"void Environment::RunTimers(uv_timer_t* handle) {\n  Environment* env = Environment::from_timer_handle(handle);\n  ...\n\n  Local<Object> process = env->process_object();\n  ...\n\n  Local<Function> cb = env->timers_callback_function();\n  MaybeLocal<Value> ret;\n  Local<Value> arg = env->GetNow();\n  do {\n    TryCatchScope try_catch(env);\n    try_catch.SetVerbose(true);\n    ret = cb->Call(env->context(), process, 1, &arg);\n  } while (ret.IsEmpty() && ...);\n\n  ...\n\n  int64_t expiry_ms =\n      ret.ToLocalChecked()->IntegerValue(env->context()).FromJust();\n\n  uv_handle_t* h = reinterpret_cast<uv_handle_t*>(handle);\n  if (expiry_ms != 0) {\n    int64_t duration_ms =\n        llabs(expiry_ms) - (uv_now(env->event_loop()) - env->timer_base());\n\n    env->ScheduleTimer(duration_ms > 0 ? duration_ms : 1);\n\n    if (expiry_ms > 0)\n      uv_ref(h);\n    else\n      uv_unref(h);\n  } else {\n    uv_unref(h);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里面，我删除了部分代码，保留骨干部分。可以看出，逻辑就是从拿到一个 ",(0,s.jsx)(n.code,{children:"cb"})," 函数，并去执行该回调函数，传入的参数为当前时间，并且 ",(0,s.jsx)(n.code,{children:"this"})," 对象为 ",(0,s.jsx)(n.code,{children:"process"}),"。",(0,s.jsx)(n.code,{children:"cb"})," 的返回值是由回调函数计算出来的下一次定时器触发时间。若触发时间为 ",(0,s.jsx)(n.code,{children:"0"}),"，则说明之后没有 ",(0,s.jsx)(n.code,{children:"Timeout"})," 定时器了，就不需要重新调度；若非 ",(0,s.jsx)(n.code,{children:"0"}),"，则通过一定逻辑计算出真正下一次触发所需的时刻，并通过调用之前解释过的 ",(0,s.jsx)(n.code,{children:"env->ScheduleTimer()"})," 函数重启定时器。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Local<Object> process = env->process_object();\nLocal<Function> cb = env->timers_callback_function();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这两行代码，主要就是获取 ",(0,s.jsx)(n.code,{children:"process"})," 对象，以及获取一个事先注册到 ",(0,s.jsx)(n.code,{children:"Environment"})," 中的 JavaScript 侧的定时器回调函数（也就是之前提到过产生 Dispatcher 效果的函数）。"]}),"\n",(0,s.jsxs)(n.p,{children:["这个 ",(0,s.jsx)(n.code,{children:"timers_callback_function()"})," 是在 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/bootstrap/node.js#L349-L360",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/bootstrap/node.js#L349-L360",target:"_blank",rel:"noopener noreferrer",children:"Node.js 启动的时候注册进去"}),"的。注册了两个个函数，分别是 ",(0,s.jsx)(n.code,{children:"processImmediate()"})," 和 ",(0,s.jsx)(n.code,{children:"processTimers()"}),"，分别对应处理哪个函数大家从名字应该能看出来。当下我们先只剖析 ",(0,s.jsx)(n.code,{children:"processTimers() 这个 Dispatcher"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function processTimers(now) {\n  nextExpiry = Infinity;\n\n  let list;\n  let ranAtLeastOneList = false;\n  while ((list = timerListQueue.peek()) != null) {\n    if (list.expiry > now) {\n      nextExpiry = list.expiry;\n      return timeoutInfo[0] > 0 ? nextExpiry : -nextExpiry;\n    }\n    if (ranAtLeastOneList)\n      runNextTicks();\n    else\n      ranAtLeastOneList = true;\n    listOnTimeout(list, now);\n  }\n  return 0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["逻辑很简单，不断从 ",(0,s.jsx)(n.code,{children:"timerListQueue"})," 这个优先队列中获取队首元素，也就是过期时间最近的那条链表。由于逻辑特性，链表头肯定是时间最近的元素。"]}),"\n",(0,s.jsxs)(n.p,{children:["判断一下，链表的过期时间是否大于当前时间。如果大于当前时间，则说明这个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 还未轮到执行，于是我将 ",(0,s.jsx)(n.code,{children:"nextExpiry"})," 用该链表的过期时间替换。我们之前提到，该回调函数返回值是下一次过期时间。注意这里的返回先判断了一个 ",(0,s.jsx)(n.code,{children:"timeoutInfo[0]"})," 的值大小，并以此返回正负的值。"]}),"\n",(0,s.jsxs)(n.p,{children:["实际上在 C++ 侧的 ",(0,s.jsx)(n.code,{children:"RunTimers()"})," 中始终用的是该值的绝对值，所以正负只是一个简易的判断标识，用于判断是否需要对 libuv 进行 Reference 或者 Unreference 操作，以让 Node.js 决定需不需要“及时退出”。这个事情不在主干上，不重要，暂且不提。所以先忽略正负吧。总之，如果 ",(0,s.jsx)(n.code,{children:"Timer"})," 还不需要执行，则返回 ",(0,s.jsx)(n.code,{children:"nextExpiry"})," 以让 ",(0,s.jsx)(n.code,{children:"RunTimers()"})," 开启下一轮的 libuv 的定时器。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果链表过期时间小于等于当前时间，则说明在当前状态下，该 ",(0,s.jsx)(n.code,{children:"Timeout"})," 是需要被触发的。由于时间的不精确性，如时间循环卡了一下，导致一下子过了好几毫秒，而在这之前有好几条链表都会过期，那么我们就需要在一次 ",(0,s.jsx)(n.code,{children:"processTimers"})," 里面持续执行 ",(0,s.jsx)(n.code,{children:"Timeout"})," 直到获取的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 未过期。所以这里一整套逻辑都是被一个 ",(0,s.jsx)(n.code,{children:"while"})," 所包围。"]}),"\n",(0,s.jsxs)(n.p,{children:["在执行 ",(0,s.jsx)(n.code,{children:"Timeout"})," 之前，先判断一下当前的 ",(0,s.jsx)(n.code,{children:"while"})," 里面是不是已经执行过至少一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 了。若未执行过，则直接执行；若已经执行过，则在 Node.js 的语义中已经过了 Tick 了，接下去的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 应该在下一个 Tick 执行，所以在这里执行一下 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 来让 Node.js 同步模拟出一个 Tick 结束的样子。这个 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 里面主要做的事情就是去处理微任务、",(0,s.jsx)(n.code,{children:"Promise"})," 的 ",(0,s.jsx)(n.code,{children:"rejection"})," 等。毕竟在 Node.js 的语义中，一个 Tick 结束要做的事情有好多。"]}),"\n",(0,s.jsxs)(n.p,{children:["到下一个 Tick 之后，就可以触发 JavaScript 侧的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 了。代码有点长，就不放出来了，有兴趣可以自己",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/timers.js#L517",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/timers.js#L517",target:"_blank",rel:"noopener noreferrer",children:"读代码"}),"，也可以听我瞎逼逼。"]}),"\n",(0,s.jsxs)(n.p,{children:["触发的逻辑是在 ",(0,s.jsx)(n.code,{children:"listOnTimeout()"})," 中。它所做的事情是从刚才拿出来的链表中不断获取第一个 ",(0,s.jsx)(n.code,{children:"Timeout"}),"。我们之前说过了，由于时间一往无前的特性，第一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 肯定是该链表中最早触发的 ",(0,s.jsx)(n.code,{children:"Timeout"}),"，然后依次往后排。每次获取首个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 都先判断确认一下，该 ",(0,s.jsx)(n.code,{children:"Timeout"})," 是否应该在当前时间点触发。"]}),"\n",(0,s.jsxs)(n.p,{children:["若不该，则说明该链表能处理的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 都处理完了。接下去扫尾，更新这条链表的最早过期时间，也就是当前 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的过期时间，更新完之后，再重排一下优先队列。比如最早的那张图，若当前时间是 ",(0,s.jsx)(n.code,{children:"1676275438013"}),"，那么执行 ",(0,s.jsx)(n.code,{children:"Timeout"})," 是这样的："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["若是当前 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的确已经可以被触发的话，仍旧先走一遍 ",(0,s.jsx)(n.code,{children:"runNextTicks()"})," 的逻辑，然后从链表中将当前 ",(0,s.jsx)(n.code,{children:"Timeout"})," 移除。做了一系列额外逻辑后（如操作 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的 Reference 值等），就是通过 ",(0,s.jsx)(n.code,{children:"try-catch"})," 去执行 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例的 ",(0,s.jsx)(n.code,{children:"_onTimeout()"})," 方法了。这里的 ",(0,s.jsx)(n.code,{children:"_onTimeout()"})," 暂时不研究，它就是某个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 触发后真正要执行的函数，并且它内部会调用 ",(0,s.jsx)(n.code,{children:"setTimeout()"})," 时传进去的回调。"]}),"\n",(0,s.jsxs)(n.p,{children:["执行完 ",(0,s.jsx)(n.code,{children:"Timeout"})," 后，先判断该 ",(0,s.jsx)(n.code,{children:"Timeout"})," 是否需要重复执行（即 ",(0,s.jsx)(n.code,{children:"setInterval()"}),"）。若需要重复执行，则将该 ",(0,s.jsx)(n.code,{children:"Timeout"})," 实例以新的一些参数重新调用 ",(0,s.jsx)(n.code,{children:"insert()"})," 回到链表中。因为该链表已存在，所以不需要生成新的，又因为当前 ",(0,s.jsx)(n.code,{children:"Timeout"})," 处理完之后，该条链表最后的时间不会超过 ",(0,s.jsx)(n.code,{children:"100ms"}),"（即当前链表对应的 ",(0,s.jsx)(n.code,{children:"timeout"}),"），所以新插入的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 在链表尾不会影响现有的时序。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"思考："})," 为什么当前 ",(0,s.jsx)(n.code,{children:"Timer"})," 结束后，其再插入同样 ",(0,s.jsx)(n.code,{children:"timeout"})," 的 ",(0,s.jsx)(n.code,{children:"Timer"})," 一定是在链表中触发时间最晚的。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["接下去就开始下一条循环，从链表中再获取下一条 ",(0,s.jsx)(n.code,{children:"Timeout"})," 重复上面的操作。如果链表空了，则退出。退出之后在外层循环实际上就是 Node.js 继续从优先队列中获取再继续判断了。"]}),"\n",(0,s.jsx)(n.p,{children:"简单总结这个流程就是：从优先队列拿最早的链表，里面元素一个个都做了，一直做到元素未超时，再把链表放回去重排优先队列；然后再从优先队列拿最早的链表，里面元素一个个都做了，一直做到元素未超时，再把链表放回去重排优先队列，一直做到优先队列里面第一条链表也未超时为止。"}),"\n",(0,s.jsxs)(n.p,{children:["我称之为",(0,s.jsx)(n.strong,{children:"薅羊毛算法（我瞎编的）"})," 。这就像是薅羊毛。比如有红黑黄三种羊的羊圈，每个羊圈若干羊。每次都选一只所有羊中羊毛长得最好最多的羊，进入它的羊圈，把羊毛薅秃了，并按羊毛多少，把这个圈里的羊依次薅一遍，直到没羊毛可薅。然后出羊圈后，再用同样逻辑找羊圈，进去薅一圈。这个时候可能第一个羊圈的毛又长差不多了，这个时候再用同样逻辑选羊圈薅羊毛。直到所有羊毛都薅没了，就等下一次可以薅的时候。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"薅羊毛（不是）"}),"\n",(0,s.jsxs)(n.p,{children:["或者也可以称其为",(0,s.jsx)(n.strong,{children:"劫匪算法（还是我瞎编的）"})," 。劫匪从一堆珠宝店里选出有最贵珠宝的店，进去从贵到便宜把能抢的都抢了。然后换一家继续。第二家最贵的不一定比第一家最便宜的便宜，正如一条链表内可触发的最迟的定时器不一定比后一条链表的可触发的最早的定时器要早。"]}),"\n",(0,s.jsxs)(n.p,{children:["这种做法虽然",(0,s.jsx)(n.strong,{children:"说不定"}),"效率比把所有 ",(0,s.jsx)(n.code,{children:"Timeout"})," 都归为一个大的优先队列好，但是在极端情况下会出一些岔子。根据上面的算法，我们很容易能倒推出下面这段代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"'use strict';\n\nsetTimeout(() => {\n  console.log(1);\n}, 10);\nsetTimeout(() => {\n  console.log(2);\n}, 15);\nlet now = Date.now();\nwhile (Date.now() - now < 100) {\n  //\n}\nsetTimeout(() => {\n  console.log(3);\n}, 10);\nnow = Date.now();\nwhile (Date.now() - now < 100) {\n  //\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["照理说，按实际 ",(0,s.jsx)(n.code,{children:"Timeout"})," 触发时间的迟早进行排序触发，3 个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 触发时机分别为 ",(0,s.jsx)(n.code,{children:"10"}),"、",(0,s.jsx)(n.code,{children:"15"}),"、",(0,s.jsx)(n.code,{children:"110"}),"，所以顺序应该一次是 ",(0,s.jsx)(n.code,{children:"1"}),"、",(0,s.jsx)(n.code,{children:"2"}),"、",(0,s.jsx)(n.code,{children:"3"}),"。哪怕第一个 Tick 是经过 ",(0,s.jsx)(n.code,{children:"200"})," 毫秒后才结束，开始触发第一个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 的时刻已经是 200 毫秒之后了，三个 ",(0,s.jsx)(n.code,{children:"Timeout"})," 都应该马上被触发。但这种情况下，触发顺序不再是 ",(0,s.jsx)(n.code,{children:"1"}),"、",(0,s.jsx)(n.code,{children:"2"}),"、",(0,s.jsx)(n.code,{children:"3"}),"，而是 ",(0,s.jsx)(n.code,{children:"1"}),"、",(0,s.jsx)(n.code,{children:"3"}),"、",(0,s.jsx)(n.code,{children:"2"}),"。至于为什么，想想羊毛是怎么薅的你就晓得了。",(0,s.jsx)(n.strong,{children:"第三只羊在第一只羊被薅之后，就因为与它同处一个羊圈而先于第二只羊被薅了。"})]}),"\n",(0,s.jsxs)(n.p,{children:["哦对了，最后忘了说，如果链表中的 ",(0,s.jsx)(n.code,{children:"Timeout"})," 全过完了，且没有因为 ",(0,s.jsx)(n.code,{children:"repeat"})," 被重新插回去，也就是说最后链表空了的情况下，在这个函数的最末尾会从 ",(0,s.jsx)(n.code,{children:"Map"})," 以及优先队列中把该链表删除。这就好比，羊毛薅完了还会长，但是薅完羊毛里面的羊都死光了，那羊圈就没必要留着了。"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"setTimeout"})," 并不是 ECMAScript 标准的函数，而是 Web 标准的。这意味着引擎不管这东西，需要各运行时自行实现。不同运行时实现方式不一样，Node.js 使用",(0,s.jsx)(n.strong,{children:"薅羊毛手法"}),"来实现。抛开运行时问实现的方式是耍流氓。"]}),"\n",(0,s.jsx)(n.p,{children:"具体的实现方式在上文已经给出解析了。这种方式在大部分情况下都是很欢乐的，性能也不赖。但是在极端情况下，还是会有无伤大雅的时序问题。虽然我没试过给 Node.js 提这一方面的 Issue 或者 PR，但估计就算提了，也许人家也会以“这是 Feature，不是 Bug”来判断。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let u=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F7-%E6%97%B6%E5%BA%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BC%82%E6%AD%A5%20API%EF%BC%9ATimer%E3%80%81setImmediate()%E3%80%81process.nextTick()%20%E4%B8%8E%20queueMicrotask()%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{text:"`setTimeout` 到底是哪的函数？怎么实现的？",id:"settimeout-到底是哪的函数怎么实现的",depth:2},{text:"Node.js 中的 `setTimeout()`",id:"nodejs-中的-settimeout",depth:2},{text:"两个关键对象：`Map` 与优先队列",id:"两个关键对象map-与优先队列",depth:3},{text:"就“一个”定时器",id:"就一个定时器",depth:3},{text:"`uv_timer_t`",id:"uv_timer_t",depth:4},{text:"Node.js 中针对 `Timer` 的定时器",id:"nodejs-中针对-timer-的定时器",depth:4},{text:"定时器回调",id:"定时器回调",depth:4},{text:"小结",id:"小结",depth:2}],title:"7-时序相关的异步 API：Timer、setImmediate()、process.nextTick() 与 queueMicrotask()（上）",headingTitle:"7-时序相关的异步 API：Timer、setImmediate()、process.nextTick() 与 queueMicrotask()（上）",frontmatter:{}}}}]);