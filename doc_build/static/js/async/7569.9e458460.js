"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["7569"],{607039:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var s=r(552676),i=r(740453);let h=r.p+"static/image/819e3efb3050871ce1029ca495defdbf.03b39230.webp",d=r.p+"static/image/fc5d7a9d26938c7781074bb1cb9088cc.a246110e.webp",c=r.p+"static/image/4c34292c2913f545f7355f98b061d5ae.dbac11bf.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ul:"ul",li:"li",h2:"h2",img:"img",h3:"h3"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"47项目进阶d2c-的实现",children:["47.项目进阶：D2C 的实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#47项目进阶d2c-的实现",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"D2C（Design to Code）"})," 是近年来在前端开发领域非常热门的方向之一。传统开发流程中上，前端开发人员需要手动将设计稿转换为前端代码，这是一个耗时且容易出错的过程。",(0,s.jsx)(n.strong,{children:"D2C"}),"的目标是通过算法和自动化工具，将设计稿自动转换为高质量、可维护的前端代码，从而提高开发效率并减少人为错误。"]}),"\n",(0,s.jsxs)(n.p,{children:["与低代码平台不同的是，",(0,s.jsx)(n.strong,{children:"D2C"}),"更加面向终端用户，让设计师可以直接将自己设计的作品呈现在自己眼前。目前，市场上已经涌现出一些优秀的",(0,s.jsx)(n.strong,{children:"D2C工具"}),"和",(0,s.jsx)(n.strong,{children:"平台"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"CodeFun"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Semi UIKit"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Builder Figma to React"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Deco"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Imgcook"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"React Figma"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Locofy"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"蓝湖(MasterGO)"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"目前而言主流的功能平台大体上覆盖以下几个平台："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Figma(支持大户)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Sketch"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Adobe XD"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Adobe Photoshop"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"在当下的现在，部分D2C产品与低代码平台开始进行相结合，从设计稿到低代码协议进行二次加工，最后渲染成我们熟知的页面以及导出相对应的前端工程。"}),"\n",(0,s.jsx)(n.p,{children:"在本章节中主要是了解相关D2C的一些技能知识点，以及如何来与低代码平台进行流程链路上的打通，在后续如果碰到相关的业务场景也能够有一定的思考方向。"}),"\n",(0,s.jsxs)(n.h2,{id:"转换流程",children:["转换流程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#转换流程",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"首先，当拿到类似Figma这样的设计平台提供的设计稿存储结构（如ObjectTree结构），我们可以根据自己的算法规则来调整逻辑。通过设计的标注行为或智能行为与设计体系打通的条件下，能够将其直接转换为对应的前端工程代码。此外，通过协议与协议的转换，还可以与低代码平台对接，将设计稿转换为DSL（Domain-Specific Language）协议，使其能够在低代码平台中使用。这样形成了一种一开、二开的迭代模式，将通用型页面交给设计师，将代码交互交给开发工程师，进一步提高整体的开发效率。"}),"\n",(0,s.jsx)(n.p,{children:"整体的转换大纲的思路如下图所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"实现原理",children:["实现原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现原理",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"解析图层",children:["解析图层",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解析图层",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"针对于不同的平台，会有不同的解析方式，目前社区中主流的开源解析如下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"PSD.js：老牌的Adobe Photoshop的解析器，可以将PSD相关的设计解析成为可管理的树结构数据。"}),"\n",(0,s.jsx)(n.li,{children:"sketch2json: 解析Sketch的方案，能够将Sketch保存的文件将其解析成为JSON节点数据，非常全面。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"如下图所示："}),"\n",(0,s.jsx)(n.p,{children:"通过sketch2json可以将sketch保存的文件进行解析得出以下可管理的树型结构数据，"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"以上两种方式都可以通过文件的形式进行处理，另外一种就是通过插件的形式集成，目前大多数平台都会提供相应的插件来完成这些工作。"}),"\n",(0,s.jsxs)(n.h3,{id:"adapter适配器",children:["Adapter适配器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#adapter适配器",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"适配器充当一个中间层，将不同平台或系统的数据转换成统一的格式，以便其他组件或系统能够识别和使用这些数据。它可以处理数据格式、协议、接口等方面的差异，确保数据在不同平台之间的正确传递和解释。"}),"\n",(0,s.jsx)(n.p,{children:"当后续想要适配更多的平台，只需要开发不同平台的插件或者是适配服务即可。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"布局",children:["布局",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#布局",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"绝大多数的设计软件抽离出来的树结构都是庞大的，且内部图形和图层布局基本杂乱，且相应的分组关系很考验设计师的规范梳理能力，所以大部分的可读性都比较依赖标注。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"标注：由设计师来对布局进行标注，进行人工干预，限制一定灵活性来得到一个标准化的研发设计链路。"}),"\n",(0,s.jsx)(n.li,{children:"智能组排：通过一系列的算法来干预内容的位置和布局，会把整体内容进行一个打散重排的过程。需要判断容器与容器之间的遮挡、平行、偏移等布局相关的干扰元素。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"不管是智能组排还是人工标注，其目的都是为了得到一颗可用的页面构建布局树，目前来看各家都有自己不同的智能方案手段。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"D2C技术的接入改变了常规的低代码业务流程，相比于低代码而言，面向的更为直接。低代码与D2C其实可以算是同一种体系内的建设平台，但其实从落地而言是两种不同的产品。"}),"\n",(0,s.jsx)(n.p,{children:"在之前的画布设计章节中也谈到了相关的一些D2C平台渲染其实更贴合于Canvas的特性，两者其中一个重视觉、还原度，另一个则是交互和系统体系性，侧重点不同，但是又都拥有一些相似的功能。如果有感兴趣的同学可以在交流群一起探讨一些其他的细节。"}),"\n",(0,s.jsx)(n.p,{children:"在后续小册的加更内容中，主体还是会更侧重低代码相关的内容知识点。"}),"\n",(0,s.jsxs)(n.h2,{id:"资源参考",children:["资源参考",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#资源参考",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7267418854124699702?searchId=2024021219563202FF0264F53C8F52DBE5",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/7267418854124699702?searchId=2024021219563202FF0264F53C8F52DBE5"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7163220544253329422",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/7163220544253329422"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/612581412",target:"_blank",rel:"noopener noreferrer",children:"携程 Design2Code 从零到一的实践"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/DouyinFE/semi-design/wiki/Semi-D2C-%E8%AE%BE%E8%AE%A1%E7%A8%BF%E8%BD%AC%E4%BB%A3%E7%A0%81%E7%9A%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF",target:"_blank",rel:"noopener noreferrer",children:"Semi D2C 设计稿转代码的演进之路"})}),"\n"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F47.%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6%EF%BC%9AD2C%20%E7%9A%84%E5%AE%9E%E7%8E%B0.md"]={toc:[{text:"转换流程",id:"转换流程",depth:2},{text:"实现原理",id:"实现原理",depth:2},{text:"解析图层",id:"解析图层",depth:3},{text:"Adapter适配器",id:"adapter适配器",depth:3},{text:"布局",id:"布局",depth:2},{text:"总结",id:"总结",depth:2},{text:"资源参考",id:"资源参考",depth:2}],title:"47.项目进阶：D2C 的实现",headingTitle:"47.项目进阶：D2C 的实现",frontmatter:{}}}}]);