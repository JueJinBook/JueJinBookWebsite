"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12160"],{49038:function(e,n,t){t.r(n),t.d(n,{default:()=>u});var i=t(552676),o=t(740453);let s=t.p+"static/image/2bb4f44b411dc5633b6c252f7258905c.e3df133c.webp",c=t.p+"static/image/08c64002f71e4080f0e26c7398e97a13.5cfbfd98.webp",r=t.p+"static/image/73e527df443156448edda60c6e9d37fa.e89a1126.webp",a=t.p+"static/image/5e832a1fcf40b309b68dadf6e40df071.ead6cb4f.webp",l=t.p+"static/image/d98ceb03c0807a8f45bb46363d0cd705.49ca5af5.webp",f=t.p+"static/image/48b2d4e809f0915822bb21d2e30dadc5.346b47f5.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",blockquote:"blockquote",img:"img"},(0,o.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"38原理篇-v18commit全流程",children:["38.原理篇-v18commit全流程",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#38原理篇-v18commit全流程",children:"#"})]}),"\n",(0,i.jsxs)(n.h2,{id:"一前言",children:["一前言",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一前言",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"本章节将继续围绕 v18 commit 阶段的细节展开，将具体介绍 commit 各个阶段做些什么？还有一些细节。"}),"\n",(0,i.jsx)(n.p,{children:"请大家带上如下问题去思考："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"commit 阶段具体分为那几个部分，分别做了哪些事？"}),"\n",(0,i.jsx)(n.li,{children:"父子组件在 commit 阶段各个部分的执行顺序是什么样的？"}),"\n",(0,i.jsx)(n.li,{children:"如何执行的生命周期和 hooks 钩子的回调函数？"}),"\n",(0,i.jsx)(n.li,{children:"commit 阶段如何更新的 dom 节点？"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"在正式讲解之前，我们先来两个例子："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"例子一："})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function Son(){\n    React.useEffect(()=>{\n        console.log('--------Son useEffect-------')\n    })\n    React.useLayoutEffect(()=>{\n        console.log('--------Son useLayoutEffect-------')\n    })\n    React.useInsertionEffect(()=>{\n        console.log('--------Son useInsertionEffect-------')\n    })\n    return <div>子组件</div>\n}\n\nfunction Father(){\n    React.useEffect(()=>{\n        console.log('--------Father useEffect-------')\n    })\n    React.useLayoutEffect(()=>{\n        console.log('--------Father useLayoutEffect-------')\n    })\n    React.useInsertionEffect(()=>{\n        console.log('--------Father useInsertionEffect-------')\n    })\n    return <div>\n         <div>父组件</div>\n        <Son/>\n    </div>\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"如上有父子组件，父子组件中分别有三个不同的 effect 。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"打印顺序："}),"\n",(0,i.jsx)(n.p,{children:"--------Son useInsertionEffect-------\n--------Father useInsertionEffect-------\n--------Son useLayoutEffect-------\n--------Father useLayoutEffect-------\n--------Son useEffect-------\n--------Father useEffect-------"}),"\n",(0,i.jsxs)(n.p,{children:["在生命周期章节中，讲解了不同 effect 的钩子函数；在第十六章中，我们讲到过，commit 阶段具体又分别三个小阶段，分别是 ",(0,i.jsx)(n.code,{children:"before mutation "}),"， ",(0,i.jsx)(n.code,{children:"mutation"})," 和 ",(0,i.jsx)(n.code,{children:"layout"}),"，而 DOM 的改变是在 mutation 阶段进行的。"]}),"\n",(0,i.jsx)(n.p,{children:"那么对于 effect 钩子在 commit 阶段执行时机如下："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"useInsertionEffect 是在 mutation 阶段执行的，虽然 mutation 是更新 DOM ，但是 useInsertionEffect 是在更新 DOM 之前 。"}),"\n",(0,i.jsx)(n.li,{children:"useLayoutEffect 是在 layout 阶段执行，此时 DOM 已经更新了。"}),"\n",(0,i.jsx)(n.li,{children:"useEffect 是在浏览器绘制之后，异步执行的。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["明白了 effect 每个钩子的执行时机 ，从上面的例子中还可以总结出，对于不同的 effect 钩子父子组件的执行顺序是：",(0,i.jsx)(n.strong,{children:"先子后父。"})]}),"\n",(0,i.jsx)(n.p,{children:"为了加深对 commit 阶段各个阶段的理解，来看一下第二个例子："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function Index(){\n    const [ color, setColor ] = React.useState('#000')\n    React.useEffect(()=>{\n        console.log('--------useEffect-------')\n    })\n    React.useLayoutEffect(()=>{\n        console.log('--------useLayoutEffect-------')\n    })\n    React.useInsertionEffect(()=>{\n        console.log('--------useInsertionEffect-------')\n    })\n    return <div>\n        <div id=\"text\" style={{ color }}> hello,react </div>\n        <button onClick={() => setColor('red')} >点击改变颜色</button>\n    </div>\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"如上点击按钮，触发 useState 那么接下来，为了让大家明白了解各个流程。我在 React 源码中获取 text 的颜色。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["commit 阶段主要的执行函数就是 ",(0,i.jsx)(n.code,{children:"commitRootImpl"}),"，我们打印 commitRootImpl 的重点阶段。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitRootImpl(){\n\n    if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n         /* 通过异步的方式处理 useEffect  */\n        scheduleCallback$1(NormalPriority, function () {\n            flushPassiveEffects(); \n            return null;\n        });\n    }\n\n    /* BeforeMutation 阶段执行 */\n    const text = document.getElementById('text')\n    console.log('-----BeforeMutation 执行-------')\n    commitBeforeMutationEffects(root, finishedWork);\n    console.log('-----BeforeMutation 执行完毕------')\n    /* Mutation 阶段执行 */\n    console.log('-----Mutation 执行-----')\n    if(text) console.log('颜色获取：',window.getComputedStyle(text).color)\n    commitMutationEffects(root, finishedWork, lanes);\n    console.log('-----Mutation 执行完毕-----')\n    if(text) console.log('颜色获取：',window.getComputedStyle(text).color)\n    /* Layout 阶段执行 */\n    console.log('-----Layout 执行-----')\n    commitLayoutEffects(finishedWork, root, lanes);\n    console.log('-----Layout 执行完毕-----')\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"接下来看一下打印内容："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:f,alt:"1.jpeg"})}),"\n",(0,i.jsx)(n.p,{children:"通过上面的打印内容，可以看出，真实 DOM 改变确实在 mutation 阶段执行的，在 mutation 前后的两次打印，可以看出打印颜色的变化。"}),"\n",(0,i.jsx)(n.p,{children:"通过上面两个例子，直观地表现出在 commit 阶段的大致更新流程，那么本章节将围绕着流程中的细节展开，探索一下在 v18 commit 阶段有什么奥秘。"}),"\n",(0,i.jsxs)(n.h2,{id:"二-更新标志",children:["二 更新标志",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-更新标志",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"我们都知道在 render 阶段，会遍历 fiber 树，收集需要更新的地方，打不同的标志，这些标志代表的意义不相同，有些是处理，这些标志的更新会在 commit 阶段执行。"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"更新相关：Update-组件更新标志， Ref-处理绑定元素和组件实例，"}),"\n",(0,i.jsx)(n.li,{children:"元素相关：Placement-插入元素，Update-更新元素，ChildDeletion-删除元素，Snapshot-元素快照，Visibility-offscreen新特性，ContentReset-文本内容更新。"}),"\n",(0,i.jsx)(n.li,{children:"更新回调，执行 effect：Callback-root 回调函数，类组件回调，Passive-useEffect 的钩子函数，Layout-useLayoutEffect 的钩子函数，Insertion-useInsertionEffect的钩子函数。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"在老版本的 React 中会形成一个 effectList ，然后执行 effectList 就可以了。在 v17 和 v18 新版本的 React ，不再用 effectList，而是通过 rootFiber 自上而下的调和方式来处理这些标志。"}),"\n",(0,i.jsx)(n.p,{children:"这些标志在 commit 各种阶段被执行，看一下在具体标志的执行时机："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"/* Before Mutation 阶段标志 */\nvar BeforeMutationMask = Update | Snapshot \n/* Mutation 阶段标志 */\nvar MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Visibility;\n/* Layout 阶段标志 */\nvar LayoutMask = Update | Callback | Ref | Visibility;\n/* useEffect 阶段标志 */\nvar PassiveMask = Passive | ChildDeletion;\n"})}),"\n",(0,i.jsx)(n.p,{children:"用一幅图表示在 commit 阶段执行哪些事？"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"5.jpeg"})}),"\n",(0,i.jsx)(n.p,{children:"这些 Mask 在整个 React 应用中充当什么角色呢？ React 又是怎么找到这些 Mask 并且处理的呢？ 接下来我们从 beforeMutation 开始寻找线索。"}),"\n",(0,i.jsxs)(n.h2,{id:"三-beforemutation-阶段",children:["三 beforeMutation 阶段",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-beforemutation-阶段",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在 beforeMutation 阶段会做哪些事情呢？接着 commitRootImpl 中的 commitBeforeMutationEffects 中来看。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitBeforeMutationEffects(root, firstChild) {\n    /* root 为 fiberRoot, firstChild 为 render 阶段调和完毕的 fiber 节点。  */\n    nextEffect = firstChild;\n    /* 开始进入 Before Mutation 流程 */\n    commitBeforeMutationEffects_begin();\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"commitBeforeMutationEffects 为 Before Mutation 阶段的入口函数。"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"nextEffect 为整个 commit 阶段的将要处理的 fiber 节点，类似于 render 阶段的 workInProgress 。"}),"\n",(0,i.jsx)(n.li,{children:"接下来会执行 begin 流程。"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitBeforeMutationEffects_begin() {\n    while (nextEffect !== null) {\n        var fiber = nextEffect;\n        var child = fiber.child;\n        if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n            /* 这里如果子代 fiber 树有 Before Mutation 的标志，那么把 nextEffect 赋值给子代 fiber  */\n            nextEffect = child;\n        } else {\n            /* 找到最底层有 Before Mutation 的标志的 fiber ，执行 complete */\n            commitBeforeMutationEffects_complete();\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"begin 流程解决了一个重要的问题，就是 commit 阶段执行的生命周期或者 effect 钩子为什么先子后父的。"}),"\n",(0,i.jsx)(n.p,{children:"首先为什么是先子后父的执行呢？"}),"\n",(0,i.jsx)(n.p,{children:"本质上 commit 阶段处理的事情和 dom 元素有关系，commit 阶段生命周期是可以改变真 实 dom 元素的状态的，所以如果在子组件生命周期内改变 dom 状态，并且想要在父组件的生命周期中同步状态，就需要确保父组件的生命周期执行时机要晚于子组件。"}),"\n",(0,i.jsx)(n.p,{children:"回到 begin 流程上来，begin 流程主要做了两件事："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"如果子代 fiber 树有 Before Mutation 的标志，那么把 nextEffect 赋值给子代 fiber 。这里可以理解成 begin 会向下递归，找到最底部并且有此标志的 fiber 。"}),"\n",(0,i.jsx)(n.li,{children:"找到最底层有 Before Mutation 的标志的 fiber ，执行 complete 。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"begin 流程本质上有上到下遍历，找到最底层的节点。接下来看一下 complete 流程。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitBeforeMutationEffects_complete(){\n    while (nextEffect !== null) {\n        var fiber = nextEffect;\n        try{\n            /* 真正的处理 Before Mutation 需要做的事情。 */\n            commitBeforeMutationEffectsOnFiber(fiber);\n        }\n        /* 优先处理兄弟节点上的 Before Mutation  */\n        var sibling = fiber.sibling;\n        if (sibling !== null) {\n            nextEffect = sibling;\n            return;\n        }\n        /* 如果没有兄弟节点，那么返回父级节点，继续进行如上流程。 */\n        nextEffect = fiber.return;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"complete 的流程是向上归并的流程，首先会执行 commitBeforeMutationEffectsOnFiber 真正的处理 Before Mutation 需要做的事情。"}),"\n",(0,i.jsx)(n.p,{children:"在向上归并的过程中，会先处理兄弟节点上的 Before Mutation，如果没有兄弟节点，那么返回父级节点，继续进行如上流程。"}),"\n",(0,i.jsx)(n.p,{children:"比如整个 fiber 树的结构如下所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:"2.jpeg"})}),"\n",(0,i.jsx)(n.p,{children:"那么 begin 流程如下所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:r,alt:"3.jpeg"})}),"\n",(0,i.jsx)(n.p,{children:"complete 流程如下所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"4.jpeg"})}),"\n",(0,i.jsx)(n.p,{children:"那么最重要的部分来了，就是 commitBeforeMutationEffectsOnFiber 做了什么事情："}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitBeforeMutationEffectsOnFiber(){\n    if ((flags & Snapshot) !== NoFlags) { /* 如果有 Snapshot 标志 */\n        switch (finishedWork.tag) {\n            case ClassComponent:\n              var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n              instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"commitBeforeMutationEffectsOnFiber 主要是用来处理 Snapshot，获取 DOM 更新前的快照信息，包括类组件执行生命周期 getSnapshotBeforeUpdate 。到此为止，Before Mutation 事情执行完毕。"}),"\n",(0,i.jsxs)(n.h2,{id:"四-mutation-阶段",children:["四 mutation 阶段",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-mutation-阶段",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"接下来就到了 mutation 阶段，mutation 阶段切切实实地更新了 DOM 元素，这个阶段对于整个 commit 阶段起着举足轻重的作用，mutation 的入口函数是 commitMutationEffects ，这个函数和 Before Mutation 做的事情差不多。"}),"\n",(0,i.jsx)(n.p,{children:"通过 Before Mutation 一下一上的操作之后，nextEffect 又返回的起点，接下来会和 Before Mutation 的操作一样，进入向下遍历，向上归并的流程，执行所有 mutation 阶段应该做的任务。"}),"\n",(0,i.jsx)(n.p,{children:"那么我们这里对比 Before Mutation ，看看 Mutation 会有哪些不同点。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitMutationEffects_begin(root, lanes) {\n     while (nextEffect !== null) {\n        var deletions = fiber.deletions;\n        if (deletions !== null) {\n            for (var i = 0; i < deletions.length; i++) {\n                var childToDelete = deletions[i];\n                commitDeletion(root, childToDelete, fiber);\n            }\n        }\n     }\n\n     /* 这里做的事情和 commitBeforeMutationEffects_begin 一样，找到最底层有 Mutation 的标志的 fiber ，执行 complete*/\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Mutation begin 做的事，除了和 BeforeMutation 一样，找到最底层有 Mutation 的标志的 fiber ，执行 complete 外。还有一件事情就是通过调用 commitDeletion 来执行删除元素操作。"}),"\n",(0,i.jsx)(n.p,{children:"在这里简化 commitDeletion 流程，commitDeletion 本质上会调用方法 unmountHostComponents。"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"如果是销毁，删除真实 DOM 节点"}),"\n如果 fiber 类型是 HostComponent （dom元素节点）HostText 文本元素节点。会走如下逻辑："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"if (node.tag === HostComponent || node.tag === HostText) {\n      /* 省去一些逻辑，这里调用真实 DOM 操作方法，删除 DOM 元素。 */\n      currentParent.removeChild(node.stateNode);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"如果是 DOM 元素，那么会调用 removeChild 方法，删除 DOM 元素。"}),"\n",(0,i.jsx)(n.p,{children:"如果其他类型的 fiber ，会调用 commitUnmount 方法。我们看一下 commitUnmount 会做些什么事情。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n       do {\n           /* 函数组件执行所有 effect 的， */\n            if (destroy !== undefined) {\n                if ((tag & Insertion) !== NoFlags$1) {\n                    /* 执行 useInsertionEffect 的 destroy */\n                  safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                }else if((tag & Layout) !== NoFlags$1){\n                   /* 执行 useLayoutEffect 的 destroy  */ \n                   safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                }\n            }\n           \n       }      \n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"如果是销毁，执行 destroy 函数"}),"\n对于函数组件，commitUnmount 会执行所有 useInsertionEffect 和 useLayoutEffect 销毁函数 destroy。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"如果是销毁，置空 ref"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"  case ClassComponent:\n    {\n        /* 清空 ref  */\n        safelyDetachRef(current, nearestMountedAncestor);\n        var instance = current.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          /* 调用类组件生命周期 componentWillUnmount  */\n          safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance);\n        }\n        return;\n    }\n"})}),"\n",(0,i.jsx)(n.p,{children:"对于类组件，commitUnmount 会清空 ref 对象，如果有生命周期 componentWillUnmount ，会调用该生命周期。"}),"\n",(0,i.jsx)(n.p,{children:"在 Mutation 的 begin 里面会做这么些操作，接下来在 complete 函数里会做同样的事情，优先处理兄弟节点，最后处理父节点，然后分别调用 commitMutationEffectsOnFiber。那么这个函数又做了哪些事情呢？"}),"\n",(0,i.jsx)(n.p,{children:"commitMutationEffectsOnFiber 做的事情比较重要，这里重点分了几个部分："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitMutationEffectsOnFiber(){\n  /* 如果是文本节点，那么重置节点内容 */  \n  if (flags & ContentReset) {\n    commitResetTextContent(finishedWork);\n  }\n  /* 如果是 ref 更新，那么重置 alternate 属性上的 ref */\n  if (flags & Ref) {\n    var current = finishedWork.alternate;\n    if (current !== null) {\n      commitDetachRef(current);\n    }\n  }\n  if(flags & Visibility){\n      /* 这一块和 v18 新属性有关，下面会介绍 */\n  }\n\n  var primaryFlags = flags & (Placement | Update );\n  switch (primaryFlags) {\n    /* 如果新插入节点 */\n    case Placement:\n      { \n        commitPlacement(finishedWork); \n\n        finishedWork.flags &= ~Placement;\n        break;\n      }\n    /* ... 省去其他的相关逻辑 */  \n    /* 对于更新会有 Update */\n    case Update:\n      {\n        var _current5 = finishedWork.alternate;\n        commitWork(_current5, finishedWork);\n        break;\n      }  \n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"commitMutationEffectsOnFiber 阶段主要做的事情很多，这里列举了几个非常重要的节点，对于 ContentReset ，执行 commitResetTextContent 置空文本节点的内容。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// node 为 stateNode 属性，为 fiber 元素的真实节点。\nvar firstChild = node.firstChild;\n\nif (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n    firstChild.nodeValue = '';\n    return;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"置空文本节点和 ref 属性"}),"\n对于文本节点，会先做准备工作，会置空文本节点的内容。对于 ref 属性，也会调用 commitDetachRef，做更新前的重置 ref。commitDetachRef 在 ref 章节，已经讲解了，这里就不赘述了。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"if (current !== null) {\n    commitDetachRef(current);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"那么如果是插入新的 fiber 节点，会调用 commitPlacement 。commitPlacement 做了些什么事情呢？"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitPlacement(finishedWork){\n    /* 获取父级 fiber */\n    var parentFiber = getHostParentFiber(finishedWork);\n    switch (parentFiber.tag) {\n        /* 如果节点类型是元素类型，比如 div */\n        case HostComponent:\n           /* 获取下一个兄弟节点 */\n           var before = getHostSibling(finishedWork); \n           /* 执行 insertOrAppendPlacementNode，插入节点。 */\n           insertOrAppendPlacementNode(finishedWork, before, parent);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"可以看出 commitPlacement 主要找到当前元素的父级和兄弟 fiber，然后执行 insertOrAppendPlacementNode\n，这个方法做了如下事情。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"插入元素节"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"if (before) {\n    insertBefore(parent, stateNode, before);\n} else {\n    appendChild(parent, stateNode);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"如果有兄弟节点，那么在调用 insertBefore 往兄弟节点之前插入就可以了。如果没有之后的兄弟节点，说明需要插入最后一个子节点，那么调用 appendChild 插入节点就可以了。最后对于更新节点，调用 commitWork 就可以了。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitWork(current, finishedWork) {\n    switch (finishedWork.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case MemoComponent:\n        case SimpleMemoComponent:\n            /* 先执行上一次 useInsertionEffect 的 destroy */\n            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n            /* 执行 useInsertionEffect 的 create  */\n            commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n        case HostComponent:\n            /* 元素节点会执行 commitUpdate */\n            if (updatePayload !== null) {\n                commitUpdate(instance, updatePayload, type, oldProps, newProps);\n            }    \n        case HostText: \n            /* 文本节点更新 */\n            commitTextUpdate(textInstance, oldText, newText);\n            return\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"执行 hooks useInsertionEffect"}),"\n可以看到 commitWork 对于函数组件会执行 hooks useInsertionEffect，也就证实了 useInsertionEffect 是在 Mutation 阶段执行的。"]}),"\n",(0,i.jsx)(n.p,{children:"在 effect 的执行特点上，所有的 effect hooks，会先执行上一个次 destroy 函数，然后再调用本次的 create 函数，这就比如在 effect 里面绑定事件监听器，如果绑定新的监听器，需要先解绑老的监听器。"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"更新文本节点"}),"\n上面说到了文本节点已经重置，接下来会调用 commitTextUpdate 来更新文本节点的 nodeValue 属性。"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"更新元素节点"}),"\n对于元素的更新，本质上调用 commitUpdate ，在 commitUpdate 会更新元素的属性，比如 style 等内容。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"if (propKey === STYLE) {\n    /* 更新 style 信息。 */\n      setValueForStyles(domElement, propValue);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n    /* 更新 innerHTML 。 */\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n    /* 更新 nodeValue 属性 */  \n      setTextContent(domElement, propValue);\n    } else {\n    /* 更新元素的 props  */    \n      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"commitUpdate 主要负责更新元素的状态，到此为止，Mutation 阶段执行完毕。"}),"\n",(0,i.jsxs)(n.h2,{id:"五-layout-阶段",children:["五 layout 阶段",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-layout-阶段",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"接下来到了 layout 阶段，Mutation 阶段做了些真实的 DOM 操作，比如元素删除，元素更新，元素添加等操作，那么 layout 阶段，已经能够获取更新之后的 DOM 元素。"}),"\n",(0,i.jsx)(n.p,{children:"在执行完 commitMutationEffects 之后，会执行 commitLayoutEffects ，这个方法做的事情和 Mutation 阶段一样。接下来也会走 begin 和 complete 流程。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitLayoutEffects_begin(){\n    while (nextEffect !== null) {\n        if ( fiber.tag === OffscreenComponent && isModernRoot) {\n            /* 对于 OffscreenComponent 逻辑 */\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Layout 的 begin 流程和 Mutation 差不多，重点就是 Offscreen 处理逻辑，在接下来章节会讲到。Layout 阶段 complete 也没有特殊处理。"}),"\n",(0,i.jsx)(n.p,{children:"重点就是 Layout 阶段的 commitLayoutEffectOnFiber 函数。这个函数非常重要，主要看一下 commitLayoutEffectOnFiber 做了哪些事情？"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n    if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n        switch (finishedWork.tag) {\n            /* 对于函数组件，执行  useLayoutEffect */\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent:\n                commitHookEffectListMount(Layout | HasEffect, finishedWork);\n            /* 对于类组件，如果初始化会执行 d，如果更新会执行 componentDidUpdate  */    \n            case ClassComponent:\n                var instance = finishedWork.stateNode;\n                if (finishedWork.flags & Update) {\n                    if (current === null) {\n                        /* 执行 componentDidMount 生命周期 */\n                        instance.componentDidMount();\n                    }else{\n                        /* 执行 componentDidUpdate 生命周期 */\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    }\n                }\n                var updateQueue = finishedWork.updateQueue;\n                /* 如果有 setState 的 callback ，执行回调函数。 */\n                if (updateQueue !== null) {\n                    commitUpdateQueue(finishedWork, updateQueue, instance);\n                }                   \n    }\n    if (finishedWork.flags & Ref) {\n        /* 更新 ref 属性 */\n        commitAttachRef(finishedWork);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"commitLayoutEffectOnFiber 做了非常重要的事："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"首先对于函数组件，执行 useLayoutEffect。"}),"\n",(0,i.jsx)(n.li,{children:"对于类组件，如果初始化会执行 componentDidMount，如果更新会执行 componentDidUpdate。如果类组件触发 setState 并且有第二个参数 callback，那么这些 callback 会被放进 updateQueue 中，那么接下来会通过 commitUpdateQueue 执行每个 callback 回调函数。"}),"\n",(0,i.jsx)(n.li,{children:"接下来会更新 ref 属性。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"整个 Layout 阶段就结束了，Layout 阶段主要是执行回调函数，比如 setState 的 callback 和生命周期等，还有比如 useLayoutEffect 的钩子就是在这里执行 。"}),"\n",(0,i.jsxs)(n.h2,{id:"六-useeffect-执行",children:["六 useEffect 执行",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#六-useeffect-执行",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"细心的同学可以看到 useEffect 的还没处理，对于 useEffect 处理，主要在 commitRootImpl 开始的时候通过 flushPassiveEffects 来执行了，但是细心的同学可以发现，flushPassiveEffects 是在 scheduleCallback 中执行的。"}),"\n",(0,i.jsx)(n.p,{children:"scheduleCallback 是采用异步模式下进行的，所以 useEffect 的钩子函数是在异步条件下执行的。"}),"\n",(0,i.jsx)(n.p,{children:"flushPassiveEffects 本质上会调用  flushPassiveEffectsImpl 。 flushPassiveEffectsImpl 内部会执行 commitPassiveMountEffects 。"}),"\n",(0,i.jsx)(n.p,{children:"commitPassiveMountEffects 会通过 begin ，complete 来从上到下找到最底部 fiber ，然后再从下到上执行 fiber 树上的所有的 effect，最后再执行 commitPassiveMountOnFiber。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitPassiveMountOnFiber(finishedRoot, finishedWork) {\n    switch (finishedWork.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent:\n           commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n    }    \n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"commitPassiveMountOnFiber 如果是函数组件，会通过 commitHookEffectListMount 执行所有的 useEffect 钩子函数。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"那么最后看一下 commitHookEffectListMount 做了哪些事情："}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.new.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitHookEffectListMount(flags, finishedWork) {\n    var updateQueue = finishedWork.updateQueue;\n    var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n    if (lastEffect !== null) {\n        var firstEffect = lastEffect.next;\n        var effect = firstEffect;\n        do {\n            if ((effect.tag & flags) === flags) {\n                var create = effect.create;\n                /* 执行 effect hooks 钩子函数，得到 destroy 函数 */\n                effect.destroy = create();\n            }\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"用一幅流程图表示 commit 阶段的流程："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:s,alt:"6.jpeg"})}),"\n",(0,i.jsxs)(n.h2,{id:"七-总结",children:["七 总结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#七-总结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"本章节主要介绍 commit 阶段的细节。还有就是 before Mutation ，Mutation ，Layout 阶段做了哪些事情。"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}let u=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F38.%E5%8E%9F%E7%90%86%E7%AF%87-v18commit%E5%85%A8%E6%B5%81%E7%A8%8B.md"]={toc:[{text:"一前言",id:"一前言",depth:2},{text:"二 更新标志",id:"二-更新标志",depth:2},{text:"三 beforeMutation 阶段",id:"三-beforemutation-阶段",depth:2},{text:"四 mutation 阶段",id:"四-mutation-阶段",depth:2},{text:"五 layout 阶段",id:"五-layout-阶段",depth:2},{text:"六 useEffect 执行",id:"六-useeffect-执行",depth:2},{text:"七 总结",id:"七-总结",depth:2}],title:"38.原理篇-v18commit全流程",headingTitle:"38.原理篇-v18commit全流程",frontmatter:{}}}}]);