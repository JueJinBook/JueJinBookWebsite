"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["24476"],{104092:function(e,n,s){s.r(n),s.d(n,{default:()=>m});var t=s(552676),r=s(740453);let c=s.p+"static/image/65afb81d33396099af6e5f22a5ccc94b.e82f1b16.gif",i=s.p+"static/image/20bc0dea8856ef7a019e49287c746316.f8373a48.gif",o=s.p+"static/image/ffa52395f1fe776eeaa0babde073facd.61d0ef37.gif",a=s.p+"static/image/d8444cb5f7cbfa1d45aa2e4890220684.b3ba2e43.gif";function d(e){let n=Object.assign({h2:"h2",a:"a",p:"p",pre:"pre",code:"code",strong:"strong",img:"img",blockquote:"blockquote",ol:"ol",li:"li"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["本篇我们会在 ",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309115240284127283",target:"_blank",rel:"noopener noreferrer",children:"《源码篇 | 实现 Streaming》"}),"的基础上，实现 Server Actions 功能。"]}),"\n",(0,t.jsx)(n.p,{children:"如果没有实现之前的代码，可以运行："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"# 69.源码篇 _ 实现 Server Actions\ngit clone -b react-rsc-10 git@github.com:mqyqingfeng/next-app-demo.git\n# 进入目录并安装依赖项\ncd next-app-demo && npm i\n# 启动\nnpm start\n"})}),"\n",(0,t.jsx)(n.p,{children:"为了演示 Server Actions 的效果，我们将以实现博客评论功能为例。"}),"\n",(0,t.jsxs)(n.p,{children:["在具体技术实现上，我们将使用 ",(0,t.jsx)(n.code,{children:"<form>"})," 实现评论框，评论内容储存在 JSON 文件中。此外我们会拓展 client.js 中的逻辑以拦截表单提交，防止提交数据的时候，页面重新加载。"]}),"\n",(0,t.jsx)(n.p,{children:"简单来说就是，form 表单提交后，页面无刷新，评论列表立刻更新。就像我们使用 Next.js 实现的效果一样。具体效果如下："}),"\n",(0,t.jsxs)(n.h2,{id:"step1实现正常表单提交",children:["Step1：实现正常表单提交",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step1实现正常表单提交",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["我们先实现正常的表单提交，也就是使用 ",(0,t.jsx)(n.code,{children:"<form>"})," 的 action 属性进行提交。"]}),"\n",(0,t.jsxs)(n.p,{children:["先添加表单和评论列表组件，修改",(0,t.jsx)(n.code,{children:"components.tsx"}),"，添加如下代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'export function PostPage({ slug }) {\n  return (\n    <Suspense fallback={<p>Loading Post...</p>}>\n      <Post slug={slug} />\n      <CommentForm slug={slug} />\n      <CommentList slug={slug} />\n    </Suspense>\n  );\n}\n\nasync function CommentForm({ slug }) {\n  return (\n    <form id="form" method="POST" action="/actions/comment" className="my-6 flex max-w-md gap-x-4 mx-auto">\n      <input\n        name="comment"\n        required\n        className="min-w-0 flex-auto rounded-md border-0 bg-white/5 px-3.5 py-2 text-black shadow-sm ring-1 ring-inset ring-white/10 focus:ring-2 focus:ring-inset focus:ring-indigo-500 sm:text-sm sm:leading-6"\n        placeholder="Enter your Comment"\n        />\n      <input type="hidden" name="slug" value={slug} />\n      <button\n        type="submit"\n        className="flex-none rounded-md bg-indigo-500 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-indigo-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500"\n        >\n        Submit\n      </button>\n    </form>\n  )\n}\n\nasync function CommentList({ slug }) {\n  let comments\n  try {\n    const commentsData = await readFile("./comments/" + slug + ".json", "utf8")\n    comments = JSON.parse(commentsData)\n  } catch (err) {\n    comments = []\n  }\n\n  return (\n    <div>\n      <h2>Comments:</h2>\n      <div className=\'divide-y divide-gray-100\'>\n        {comments.map((comment, i) => {\n      return (\n        <div key={i} className="px-4 py-6 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-0">\n          <div className="text-sm font-medium leading-6 text-gray-900">Floor {i+1}</div>\n          <div className="mt-1 text-sm leading-6 text-gray-700 sm:col-span-2 sm:mt-0">{comment.content}</div>\n        </div>\n      )\n    })}\n      </div>\n    </div>\n  )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["代码并不复杂，修改了 ",(0,t.jsx)(n.code,{children:"<PostPage>"}),"组件，新增了 ",(0,t.jsx)(n.code,{children:"<CommentForm>"})," 和 ",(0,t.jsx)(n.code,{children:"<CommentList>"}),"组件。在 ",(0,t.jsx)(n.code,{children:"<CommentForm>"})," 中，我们将表单数据提交到 ",(0,t.jsx)(n.code,{children:"/actions/comment"}),"，表示这是一个 Server Action，提交的数据有两个字段，其中 comment 字段表示具体评论的内容，slug 字段表示具体是哪篇文章的评论。"]}),"\n",(0,t.jsxs)(n.p,{children:["我们来实现下 ",(0,t.jsx)(n.code,{children:"/actions/comment"}),"请求处理，为了更便捷的处理表单提交数据，我们引入 body-parser，这是 Express 处理 body 非常常用的一个库。运行："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm i body-parser\n"})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"server/ssr.ts"}),"，完整代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import express from "express";\nimport { readFile } from "fs/promises";\nimport fetch from \'node-fetch\';\nimport { renderToPipeableStream } from "react-dom/server"\nimport { createFromNodeStream } from "react-server-dom-webpack/client"\nimport bodyParser from \'body-parser\';\nimport { serverAction }  from "../actions";\n\nconst app = express();\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({ extended: false }))\n\napp.get("/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n\n  // client.js\n  if (url.pathname === "/client.js") {\n    const content = await readFile("./client.js", "utf8");\n    res.setHeader("Content-Type", "text/javascript");\n    res.end(content);\n    return;\n  }\n\n  const response = await fetch("http://127.0.0.1:3001" + url.pathname);\n\n  if (!response.ok) {\n    res.statusCode = response.status;\n    res.end();\n    return;\n  }\n  const stream = response.body;\n\n  // 获取客户端 JSX 对象\n  if (url.searchParams.has("jsx")) {\n    res.set("Content-type", "text/x-component")\n    stream.on("data", (data) => {\n      res.write(data)\n    })\n    stream.on("end", (data) => {\n      res.end()\n    })\n  }\n  // 获取 HTML\n  else {\n    const root = await createFromNodeStream(stream, {})\n    res.set("Content-type", "text/html")\n    const { pipe } = renderToPipeableStream(root)\n    pipe(res)\n  }\n});\n\napp.post("/actions/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  if (url.pathname.startsWith("/actions/")) {\n    await serverAction(req, res)\n  }\n});\n\napp.listen(3000, (err) => {\n  if (err) return console.error(err);\n  return console.log(`Server is listening on 3000`);\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Next.js 中的 Server Actions 只支持 POST 请求，所以我们也写在 POST 请求上。如果请求以 ",(0,t.jsx)(n.code,{children:"/actions"}),"开头，并且是 POST 请求，我们就调用 serverAction 方法。"]}),"\n",(0,t.jsxs)(n.p,{children:["新建 ",(0,t.jsx)(n.code,{children:"actions.ts"}),"，写入具体的 serverAction 函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'export async function serverAction(req, res) {\n  const action = req.url.slice(9)\n\n  const module = await import("./actions/" + action + ".js")\n  const actionFunction = module.default\n  await actionFunction(req, res)\n\n  res.redirect(302, "/" + req.body.slug)\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["我们使用 Next.js Server Actions 的时候，往往会新建一个 ",(0,t.jsx)(n.code,{children:"actions.js"}),"，然后在其中写入具体的逻辑处理，换句话说，具体处理的逻辑由用户定义。这里我们也是交给用户来定义，如果请求的是 ",(0,t.jsx)(n.code,{children:"/actions/comment"})," 对应的处理代码就在 ",(0,t.jsx)(n.code,{children:"/actions/comment.js"}),"中。"]}),"\n",(0,t.jsxs)(n.p,{children:["新建 ",(0,t.jsx)(n.code,{children:"actions/comment.ts"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { readFile, writeFile } from "fs/promises"\n\nexport default async function handleCommentPost(req, res) {\n  const {slug, comment} = req.body\n\n  let comments\n\n  try {\n    const commentsData = await readFile("./comments/" + slug + ".json", "utf8")\n    comments = JSON.parse(commentsData)\n  } catch (err) {\n    if (err.code === "ENOENT") {\n      comments = []\n    } else {\n      throw err\n    }\n  }\n\n  comments.push({\n    content: comment\n  })\n  \n  const commentsFile = "./comments/" + slug + ".json"\n  await writeFile(commentsFile, JSON.stringify(comments, null, 2))\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["处理的代码并不复杂，读取保存数据的 json 文件，然后写入新的数据。目前还没有建立 json 文件，**我们先新建 **",(0,t.jsx)(n.code,{children:"**comments**"}),(0,t.jsx)(n.strong,{children:"文件夹，防止出现读取错误"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"此时涉及到的文件目录结构如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"next-app-demo         \n├─ actions            \n│  └─ comment.ts   \n├─ comments                \n├─ server             \n│  ├─ rsc.ts          \n│  └─ ssr.ts          \n├─ actions.ts          \n├─ components.tsx         \n"})}),"\n",(0,t.jsxs)(n.p,{children:["在 ",(0,t.jsx)(n.code,{children:"actions.ts"}),"中，最后我们调用了 ",(0,t.jsx)(n.code,{children:"res.redirect"}),"返回之前的页面。"]}),"\n",(0,t.jsx)(n.p,{children:"此时交互效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:"react-rsc-15.gif"})}),"\n",(0,t.jsxs)(n.p,{children:["表单数据成功提交和渲染。其实现逻辑是，Form 表单数据提交到 ",(0,t.jsx)(n.code,{children:"/actions/comment"}),"，对应读取 ",(0,t.jsx)(n.code,{children:"/actions/comment.js"}),"文件进行处理，然后重定向回到之前的页面，页面重新加载，评论列表数据更新。"]}),"\n",(0,t.jsx)(n.p,{children:"因为我们用的是 form 的 action 提交的数据，所以即使禁用 JavaScript，表单也是可以成功提交的。禁用 JavaScript 的效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"react-rsc-10.gif"})}),"\n",(0,t.jsxs)(n.p,{children:["注：这里的演示，我们删除了 Suspense 组件，因为 Suspense 需要依赖 JS，在获得数据后，更新 DOM 节点。此外因为我们的 tailwind.css 是通过 ",(0,t.jsx)(n.code,{children:"<script>"}),"标签引入的，所以禁用 JavaScript 时，样式失效。但是表单依然可以正常提交。"]}),"\n",(0,t.jsxs)(n.h2,{id:"step2-客户端拦截表单提交",children:["Step2: 客户端拦截表单提交",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step2-客户端拦截表单提交",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"但是在 Next.js 中，使用 Server Action 提交表单，页面是不会刷新的。这是因为客户端拦截了表单提交。"}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"client.js"}),"，添加如下代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'window.addEventListener("submit", async (e) => {\n  const action = e.target.action\n  const actionURL = new URL(action, window.location.origin)\n\n  if (!actionURL.pathname.startsWith("/actions/")) {\n    return\n  }\n\n  e.preventDefault()\n\n  if (e.target.method === "post") {\n    const formData = new FormData(e.target)\n    const body = Object.fromEntries(formData.entries())\n    const response = await fetch(action, {\n      method: "POST",\n      body: JSON.stringify(body),\n      headers: {\n        "Content-Type": "application/json",\n      },\n    })\n\n    if (!response.ok) return\n    navigate(window.location.pathname, true)\n    return\n  } else {\n    console.error("unknown method", e.target.method)\n  }\n})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["这段代码逻辑并不复杂，首先是阻止表单提交，然后是以 POST 请求调用 ",(0,t.jsx)(n.code,{children:"/actions/comment"}),"，具体返回的数据我们并未处理，主要是触发对应 ",(0,t.jsx)(n.code,{children:"/actions/comment.ts"}),"代码的执行，最后调用 navigate 函数重新渲染页面。交互效果如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"react-rsc-16.gif"})}),"\n",(0,t.jsxs)(n.p,{children:["你会发现，很奇怪，评论并没有更新。按理说，提交的时候应该有 3 个请求产生，首先是 ",(0,t.jsx)(n.code,{children:"/actions/comment"}),"请求，由客户端触发，",(0,t.jsx)(n.code,{children:"actions.ts"}),"代码重定向到原页面，于是触发了第 2 个 ",(0,t.jsx)(n.code,{children:"earth"})," 请求，客户端同时执行了 ",(0,t.jsx)(n.code,{children:"naviagte"})," 函数，触发第三个 ",(0,t.jsx)(n.code,{children:"/earth?jsx"}),"请求。"]}),"\n",(0,t.jsxs)(n.p,{children:["但是现在只有 2 个请求，没有第 3 个 ",(0,t.jsx)(n.code,{children:"/earth?jsx"}),"请求。这是因为我们在之前的实现中实现了客户端路由缓存，所以用了缓存中的数据。"]}),"\n",(0,t.jsxs)(n.p,{children:["继续修改 ",(0,t.jsx)(n.code,{children:"client.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async function navigate(pathname, revalidate) {\n  currentPathname = pathname;\n  if (!revalidate && clientJSXCache[pathname]) {\n    updateRoot(clientJSXCache[pathname])\n    return\n  } else {\n    const response = fetch(pathname + '?jsx')\n    const root = await createFromFetch(response)\n    clientJSXCache[pathname] = root\n    startTransition(() => {\n      updateRoot(root)\n    })\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们添加了一个 revalidate 变量，当为 true 的时候，不读取缓存，重新请求。此时页面正常运行："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"react-rsc-17.gif"})}),"\n",(0,t.jsx)(n.p,{children:"注：提交的时候之所以会有卡顿感，是因为我们为文章添加了 2s 延迟。"}),"\n",(0,t.jsxs)(n.p,{children:["想想 ",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7344650215729430565#heading-6",target:"_blank",rel:"noopener noreferrer",children:"《缓存篇 | Caching（下）》"}),"中，我们讲到客户端路由缓存的失效方式："]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"有两种方法可以让路由缓存失效："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["在 Server Action 中","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"通过 revalidatePath 或 revalidateTag 重新验证数据"}),"\n",(0,t.jsx)(n.li,{children:"使用 cookies.set 或者 cookies.delete 会使路由缓存失效，这是为了防止使用 cookie 的路由过时（如身份验证）"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"调用 router.refresh 会使路由缓存失效并发起一个重新获取当前路由的请求"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"我们这里的实现就是一个简易的 Server Action revalidate  功能。"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"功能实现：Server Action"}),"\n",(0,t.jsxs)(n.li,{children:["源码地址：",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-11",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-11"})]}),"\n",(0,t.jsxs)(n.li,{children:["下载代码：",(0,t.jsx)(n.code,{children:"git clone -b react-rsc-11 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"至此，我们的 Server Actions 功能就实现了，其实跟 Next.js 的实现有很大的差别。"}),"\n",(0,t.jsx)(n.p,{children:"在 Next.js 中，Server Actions 的请求是以 POST 请求提交到当前页面的 URL，提交的时候会携带 $ACTION_ID 以区分不同的 Server Action。同时 Next.js 会在这一次请求中返回所有需要的信息，然后更新状态，不像我们这般简单粗暴的重新请求。"}),"\n",(0,t.jsx)(n.p,{children:"但原理是类似的，希望这个简单的 Server Actions 实现对大家理解 Next.js 的实现有所帮助。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}let m=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F69.%E6%BA%90%E7%A0%81%E7%AF%87%20_%20%E5%AE%9E%E7%8E%B0%20Server%20Actions.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"Step1：实现正常表单提交",id:"step1实现正常表单提交",depth:2},{text:"Step2: 客户端拦截表单提交",id:"step2-客户端拦截表单提交",depth:2},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);