"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["84802"],{364721:function(n,e,t){t.r(e),t.d(e,{default:()=>l});var o=t(552676),r=t(740453);let i=t.p+"static/image/c42738b65c8965e803d96925a8f54d87.4906f7c3.png",s=t.p+"static/image/15db0c0ff9af2dbc1943e7f8455ba34e.49a37407.png";function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",img:"img",pre:"pre",code:"code",blockquote:"blockquote"},(0,r.ah)(),n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.h1,{id:"7方案了解web-components-方案",children:["7.方案了解：Web Components 方案",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#7方案了解web-components-方案",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"Web Components 可以理解为浏览器的原生组件，它通过组件化的方式封装微应用，从而实现应用自治。本课程会在动态 Script 方案的基础上做少许改动来实现简单的 Web Components 方案，帮助大家快速理解该方案的优缺点。"}),"\n",(0,o.jsxs)(e.h2,{id:"web-components-方案",children:["Web Components 方案",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#web-components-方案",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"在动态 Script 方案的基础上进行少许改动便可以简单支持 Web Components 方案，实现思路如下所示："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"通过请求获取后端的微应用列表数据，动态进行微应用的预获取和导航创建处理"}),"\n",(0,o.jsx)(e.li,{children:"根据导航进行微应用的切换，切换的过程会动态加载并执行 JS 和 CSS"}),"\n",(0,o.jsx)(e.li,{children:"JS 执行后会在主应用中添加微应用对应的自定义元素，从而实现微应用的加载"}),"\n",(0,o.jsx)(e.li,{children:"如果已经加载微应用对应的 JS 和 CSS，再次切换只需要对自定义元素进行显示和隐藏操作"}),"\n",(0,o.jsx)(e.li,{children:"微应用自定义元素会根据内部的生命周期函数在被添加和删除 DOM 时进行加载和卸载处理"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:s,alt:""})}),"\n",(0,o.jsx)(e.p,{children:"实现效果如下所示，点击按钮后会请求微应用的静态资源并解析 JS 和 CSS："}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:i,alt:""})}),"\n",(0,o.jsx)(e.p,{children:"文件的结构目录和动态 Script 保持一致，如下所示："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"├── public                  # 托管的静态资源目录\n│   ├── main/               # 主应用资源目录                        \n│   │   └── index.html                                        \n│   └── micro/              # 微应用资源目录\n│        ├── micro1.css   \n│        ├── micro1.js    \n│        ├── micro2.css         \n│        └── micro2.js      \n├── config.js                # 公共配置\n├── main-server.js           # 主应用服务\n└── micro-server.js          # 微应用服务\n"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,o.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/web-components",target:"_blank",rel:"noopener noreferrer",children:"demo/web-components"})," 分支获取。"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"主应用 HTML 的实现代码如下所示："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-html",children:'\x3c!-- public/main/index.html --\x3e\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n    <style>\n      h1 {\n        color: red;\n      }\n    </style>\n  </head>\n\n  <body>\n    <h1>Hello，Web Components!</h1>\n    <div id="nav"></div>\n    <div class="container">\n      <div id="micro-app-slot"></div>\n    </div>\n\n    <script type="text/javascript">\n      class UtilsManager {\n        constructor() {}\n\n        getMicroApps() {\n          return window\n            .fetch("/microapps", {\n              method: "post",\n            })\n            .then((res) => res.json())\n            .catch((err) => {\n              console.error(err);\n            });\n        }\n\n        isSupportPrefetch() {\n          const link = document.createElement("link");\n          const relList = link?.relList;\n          return relList && relList.supports && relList.supports("prefetch");\n        }\n\n        prefetchStatic(href, as) {\n          if (!this.isSupportPrefetch()) {\n            return;\n          }\n          const $link = document.createElement("link");\n          $link.rel = "prefetch";\n          $link.as = as;\n          $link.href = href;\n          document.head.appendChild($link);\n        }\n\n        loadScript({ script, id }) {\n          return new Promise((resolve, reject) => {\n            const $script = document.createElement("script");\n            $script.src = script;\n            $script.setAttribute("micro-script", id);\n            $script.onload = resolve;\n            $script.onerror = reject;\n            document.body.appendChild($script);\n          });\n        }\n\n        loadStyle({ style, id }) {\n          return new Promise((resolve, reject) => {\n            const $style = document.createElement("link");\n            $style.href = style;\n            $style.setAttribute("micro-style", id);\n            $style.rel = "stylesheet";\n            $style.onload = resolve;\n            $style.onerror = reject;\n            document.head.appendChild($style);\n          });\n        }\n        removeStyle({ id }) {\n          const $style = document.querySelector(`[micro-style=${id}]`);\n          $style && $style?.parentNode?.removeChild($style);\n        }\n\n        hasLoadScript({ id }) {\n          const $script = document.querySelector(`[micro-script=${id}]`);\n          return !!$script;\n        }\n\n        hasLoadStyle({ id }) {\n          const $style = document.querySelector(`[micro-style=${id}]`);\n          return !!$style;\n        }\n      }\n    <\/script>\n\n    <script type="text/javascript">\n      class MicroAppManager extends UtilsManager {\n        micrpApps = [];\n\n        constructor() {\n          super();\n          this.init();\n        }\n\n        init() {\n          this.processMicroApps();\n          this.navClickListener();\n          this.hashChangeListener();\n        }\n\n        processMicroApps() {\n          this.getMicroApps().then((res) => {\n            this.microApps = res;\n            this.prefetchMicroAppStatic();\n            this.createMicroAppNav();\n          });\n        }\n\n        prefetchMicroAppStatic() {\n          const prefetchMicroApps = this.microApps?.filter(\n            (microapp) => microapp.prefetch\n          );\n          prefetchMicroApps?.forEach((microApp) => {\n            microApp.script && this.prefetchStatic(microApp.script, "script");\n            microApp.style && this.prefetchStatic(microApp.style, "style");\n          });\n        }\n\n        createMicroAppNav(microApps) {\n          const fragment = new DocumentFragment();\n          this.microApps?.forEach((microApp) => {\n            const button = document.createElement("button");\n            button.textContent = microApp.name;\n            button.id = microApp.id;\n            fragment.appendChild(button);\n          });\n          const nav = document.getElementById("nav");\n          nav.appendChild(fragment);\n        }\n\n        navClickListener() {\n          const nav = document.getElementById("nav");\n          nav.addEventListener("click", (e) => {\n            window.location.hash = event?.target?.id;\n          });\n        }\n\n        hashChangeListener() {\n          // Web Components 方案\n          // 微应用的插槽\n          const $slot = document.getElementById("micro-app-slot");\n\n          window.addEventListener("hashchange", () => {\n            this.microApps?.forEach(async (microApp) => {\n              // Web Components 方案\n              const $webcomponent = document.querySelector(\n                `[micro-id=${microApp.id}]`\n              );\n\n              if (microApp.id === window.location.hash.replace("#", "")) {\n                console.time(`fetch microapp ${microApp.name} static`);\n                // 加载 CSS 样式\n                microApp?.style &&\n                  !this.hasLoadStyle(microApp) &&\n                  (await this.loadStyle(microApp));\n                // 加载 Script 标签\n                microApp?.script &&\n                  !this.hasLoadScript(microApp) &&\n                  (await this.loadScript(microApp));\n                console.timeEnd(`fetch microapp ${microApp.name} static`);\n\n                // 动态 Script 方案\n                // window?.[microApp.mount]?.("#micro-app-slot");\n\n                // Web Components 方案\n                // 如果没有在 DOM 中添加自定义元素，则先添加处理\n                if (!$webcomponent) {\n                  // Web Components 方案\n                  // 自定义元素的标签是微应用先定义出来的，然后在服务端的接口里通过 customElement 属性进行约定\n                  const $webcomponent = document.createElement(\n                    microApp.customElement\n                  );\n                  $webcomponent.setAttribute("micro-id", microApp.id);\n                  $slot.appendChild($webcomponent);\n                // 如果已经存在自定义元素，则进行显示处理\n                } else {\n                  $webcomponent.style.display = "block";\n                }\n              } else {\n                this.removeStyle(microApp);\n                // 动态 Script 方案\n                // window?.[microApp.unmount]?.();\n\n                // Web Components 方案\n                // 如果已经添加了自定义元素，则隐藏自定义元素\n                if ($webcomponent) {\n                  $webcomponent.style.display = "none";\n                }\n              }\n            });\n          });\n        }\n      }\n\n      new MicroAppManager();\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,o.jsx)(e.p,{children:"微应用的设计如下所示："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'// micro1.js\n\n// MDN: https://developer.mozilla.org/zh-CN/docs/Web/Web_Components\n// MDN: https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_custom_elements\nclass MicroApp1Element extends HTMLElement {\n  constructor() {\n    super();\n  }\n\n  // [生命周期回调函数] 当 custom element 自定义标签首次被插入文档 DOM 时，被调用\n  // 类似于 React 中的  componentDidMount 周期函数\n  // 类似于 Vue 中的 mounted 周期函数\n  connectedCallback() {\n    console.log(`[micro-app-1]：执行 connectedCallback 生命周期回调函数`);\n    // 挂载应用\n    // 相对动态 Script，组件内部可以自动进行 mount 操作，不需要对外提供手动调用的 mount 函数，从而防止不必要的全局属性冲突\n    this.mount();\n  }\n\n  // [生命周期回调函数] 当 custom element 从文档 DOM 中删除时，被调用\n  // 类似于 React 中的  componentWillUnmount 周期函数\n  // 类似于 Vue 中的 destroyed 周期函数\n  disconnectedCallback() {\n    console.log(\n      `[micro-app-1]：执行 disconnectedCallback 生命周期回调函数`\n    );\n    // 卸载处理\n    this.unmount();\n  }\n\n  mount() {\n    const $micro = document.createElement("h1");\n    $micro.textContent = "微应用1";\n    // 将微应用的内容挂载到当前自定义元素下\n    this.appendChild($micro);\n  }\n\n  unmount() {\n    // 这里可以去除相应的副作用处理\n  }\n}\n\n// MDN：https://developer.mozilla.org/zh-CN/docs/Web/API/CustomElementRegistry/define\n// 创建自定义元素，可以在浏览器中使用 <micro-app-1> 自定义标签\nwindow.customElements.define("micro-app-1", MicroApp1Element);\n'})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsxs)(e.p,{children:["温馨提示：需要注意 Web Components 存在",(0,o.jsx)(e.a,{href:"https://caniuse.com/?search=Web%20Components",target:"_blank",rel:"noopener noreferrer",children:"浏览器兼容性问题"}),"，可以通过 ",(0,o.jsx)(e.a,{href:"https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs",target:"_blank",rel:"noopener noreferrer",children:"Polyfill"})," 进行浏览器兼容性处理（IE 只能兼容到 11 版本）。"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["在 ",(0,o.jsx)(e.code,{children:"main-server.js"})," 中增加微应用对应的自定义元素标签属性："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'// main-server.js\nimport express from "express";\nimport path from "path";\nimport morgan from "morgan";\nimport config from "./config.js";\nconst app = express();\nconst { port, host } = config;\n\n// 打印请求日志\napp.use(morgan("dev"));\n\napp.use(express.static(path.join("public", "main")));\n\napp.post("/microapps", function (req, res) {\n  // 这里可以是管理后台新增菜单后存储到数据库的数据\n  // 从而可以通过管理后台动态配置微应用的菜单\n  res.json([\n    {\n      // 应用名称\n      name: "micro1",\n      // 应用标识\n      id: "micro1",\n      // Web Components 方案\n      // 自定义元素名称\n      customElement: \'micro-app-1\',\n      // 应用脚本（示例给出一个脚本，多个脚本也一样）\n      script: `http://${host}:${port.micro}/micro1.js`,\n      // 应用样式\n      style: `http://${host}:${port.micro}/micro1.css`,\n      // 动态 Script 方案\n      // 挂载到 window 上的加载函数 window.micro1_mount\n      // mount: "micro1_mount",\n      // 动态 Script 方案\n      // 挂载到 window 上的卸载函数 window.micro1_unmount\n      // unmount: "micro1_unmount",\n      // 是否需要预获取\n      prefetch: true,\n    },\n    {\n      name: "micro2",\n      id: "micro2",\n      customElement: \'micro-app-2\',\n      script: `http://${host}:${port.micro}/micro2.js`,\n      style: `http://${host}:${port.micro}/micro2.css`,\n      prefetch: true,\n    },\n  ]);\n});\n\n// 启动 Node 服务\napp.listen(port.main, host);\nconsole.log(`server start at http://${host}:${port.main}/`);\n'})}),"\n",(0,o.jsx)(e.p,{children:"对比动态 Script 的方案可以发现 Web Components 的优势如下所示："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"复用性：不需要对外抛出加载和卸载的全局 API，可复用能力更强"}),"\n",(0,o.jsx)(e.li,{children:"标准化：W3C 的标准，未来能力会得到持续升级（说不定支持了 JS 上下文隔离）"}),"\n",(0,o.jsx)(e.li,{children:"插拔性：可以非常便捷的进行移植和组件替换"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"当然使用 Web Components 也会存在一些劣势，例如："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"兼容性：对于 IE 浏览器不兼容，需要通过 Polyfill 的方式进行处理"}),"\n",(0,o.jsx)(e.li,{children:"学习曲线：相对于传统的 Web 开发，需要掌握新的概念和技术"}),"\n"]}),"\n",(0,o.jsxs)(e.h2,{id:"小结",children:["小结",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"本文主要讲解了 Web Components 方案的简单实现示例，Web Components 本身属于 W3C 的标准，符合微前端技术无关的特性，未来可以跟随浏览器进行升级和维护，这也是大多数微前端框架选择 Web Components 进行设计的重要原因。当然，在使用 Web Components 进行设计时也需要考虑一些副作用，例如浏览器兼容性。课程到这里，想必大家对于微前端的一些技术方案有了一定了解，在接下来的课程中，我们会重点讲解微前端中 Cookie 相关的知识点。"})]})}function p(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}let l=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F7.%E6%96%B9%E6%A1%88%E4%BA%86%E8%A7%A3%EF%BC%9AWeb%20Components%20%E6%96%B9%E6%A1%88.md"]={toc:[{text:"Web Components 方案",id:"web-components-方案",depth:2},{text:"小结",id:"小结",depth:2}],title:"7.方案了解：Web Components 方案",headingTitle:"7.方案了解：Web Components 方案",frontmatter:{}}}}]);