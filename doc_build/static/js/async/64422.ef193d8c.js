"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["64422"],{11083:function(n,e,t){t.r(e),t.d(e,{default:()=>d});var r=t(552676),a=t(740453);let c=t.p+"static/image/90fe99f8f5c33e2a961766a8ce03b08d.c0bf494f.webp",i=t.p+"static/image/fe204c0397165305c0e8666f7f0af4b6.86344f97.webp",s=t.p+"static/image/953a90ceaa986612d1984695b7e61bfa.f54ec2c0.webp";function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",img:"img",h2:"h2"},(0,a.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"35-实战蓝牙像素板绘图-api-的设计与实现",children:["35 实战：蓝牙像素板绘图 API 的设计与实现",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#35-实战蓝牙像素板绘图-api-的设计与实现",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们来设计设备的绘图 API，目的是更加方便地操作设备。"}),"\n",(0,r.jsxs)(e.p,{children:["首先，我们需要搞清楚设备具体的绘图指令。还记得在前两节课程中，我们使用",(0,r.jsx)(e.code,{children:"4501"}),"指令来让整个像素板填充某种颜色。这是因为，根据 Divoom 的协议，",(0,r.jsx)(e.code,{children:"4501"}),"指令会将像素板设置为",(0,r.jsx)(e.code,{children:"Lightning mode"}),"。在这个模式下，像素板可以显示纯色。"]}),"\n",(0,r.jsxs)(e.p,{children:["更多相关指令，可以详细阅读",(0,r.jsx)(e.a,{href:"https://github.com/RomRider/node-divoom-timebox-evo/blob/master/PROTOCOL.md",target:"_blank",rel:"noopener noreferrer",children:"这个文档"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["在这里，我们重点关注绘制静态图像的指令，这个指令固定以",(0,r.jsx)(e.code,{children:"44000A0A04"}),"序列开头。"]}),"\n",(0,r.jsx)(e.p,{children:"具体的图像格式如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"44000A0A04 AA LLLL 000000 NN COLOR_DATA PIXEL_DATA\n \xa0 \xa0 \xa0 \xa0 \xa0 |<---------- IMAGE_DATA -------------\x3e|\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面的指令中，AA 是固定的图像开头标志，LLLL 是图像的数据长度，接着是",(0,r.jsx)(e.code,{children:"000000"}),"的分隔位，接着是 NN 表示图像的颜色数量，最多是 256 色，用 00 表示，接着是颜色索引数据和像素数据。"]}),"\n",(0,r.jsx)(e.p,{children:"我们来试一下。大家还记得上一节课我们最后的通讯指令："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"picker.addEventListener('change', async ({target}) => {\n \xa0const colorStr = target.value.slice(1);\n \xa0const message = `4501${colorStr}500001000000`;\n \xa0const payload = generatePayload(message);\n \xa0const ret = await (await fetch('http://localhost:9527/send', {\n \xa0 \xa0method: 'POST',\n \xa0 \xa0body: JSON.stringify({\n \xa0 \xa0 \xa0payload,\n \xa0  }),\n  })).json();\n \xa0console.log(ret);\n});\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这里我们是通过",(0,r.jsx)(e.code,{children:"4501"}),"来发送指令，切换到",(0,r.jsx)(e.code,{children:"Lighting mode"}),"来显示纯色。那我们现在换一个形式用",(0,r.jsx)(e.code,{children:"44000A0A04"}),"指令来实现类似的功能。"]}),"\n",(0,r.jsx)(e.p,{children:"我们实现相关的函数："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"function number2HexString(int) {\n \xa0if(int > 255 || int < 0) {\n \xa0 \xa0throw new Error('number2HexString works only with number between 0 and 255');\n  }\n​\n \xa0return Math.round(int).toString(16).padStart(2, '0');\n}\n​\n​\nfunction generateImageData(pixels) {\n \xa0const colorMap = new Map();\n \xa0let index = 0;\n​\n \xa0let colorData = '';\n​\n \xa0const screen = [];\n​\n \xa0for(let i = 0; i < 256; i++) {\n \xa0 \xa0const color = pixels[i];\n \xa0 \xa0if(!colorMap.has(color)) {\n \xa0 \xa0 \xa0colorMap.set(color, index++);\n \xa0 \xa0 \xa0colorData += color;\n \xa0  }\n \xa0 \xa0screen.push(colorMap.get(color));\n  }\n​\n \xa0// Calculate how many bits are needed to fit all the palette values in\n \xa0// log(1) === 0. Therefore we clamp to [1,..]\n \xa0const referenceBitLength = Math.max(1, Math.ceil(Math.log2(colorData.length / 6)));\n​\n \xa0// Screen buffer is using minmal amount of bits to encode all palette codes.\n \xa0// Ordering of segments is Little endion\n \xa0let current = 0;\n \xa0let currentIndex = 0;\n​\n \xa0let pixelData = '';\n​\n \xa0screen.forEach((paletteIndex) => {\n \xa0 \xa0// Add the new color reference to the accumulator\n \xa0 \xa0const reference = paletteIndex & ((2 ** referenceBitLength) - 1);\n \xa0 \xa0current |= (reference << currentIndex);\n \xa0 \xa0currentIndex += referenceBitLength;\n​\n \xa0 \xa0// Write out all filled up bytes\n \xa0 \xa0while(currentIndex >= 8) {\n \xa0 \xa0 \xa0const lastByte = current & 0xff;\n \xa0 \xa0 \xa0current >>= 8;\n \xa0 \xa0 \xa0currentIndex -= 8;\n \xa0 \xa0 \xa0pixelData += number2HexString(lastByte);\n \xa0  }\n  });\n​\n \xa0// Add the last byte\n \xa0if(currentIndex !== 0) {\n \xa0 \xa0pixelData += number2HexString(current);\n  }\n​\n \xa0const colorCount = number2HexString(colorData.length / 6);\n \xa0const data = `${colorCount}${colorData}${pixelData}`;\n \xa0const length = int2hexlittle(data.length / 2 + 6);\n \xa0const prefix = '44000A0A04';\n \xa0return `${prefix}AA${length}000000${data}`;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"在这里，我们用一个数组表示像素点，因为设备是 16X16 的，所以我们数组的长度为 256，其中每个元素表示相应坐标下的颜色信息，存储一个六位的 RGB 字符串。"}),"\n",(0,r.jsxs)(e.p,{children:["在",(0,r.jsx)(e.code,{children:"generateImageData"}),"方法里，我们对像素点的颜色进行处理。根据协议，我们先将颜色信息存储到一个哈希表中，然后将所有用到的颜色拼接成",(0,r.jsx)(e.code,{children:"colorData"}),"数据。接着我们计算由这些颜色所以组成的 pixelData。注意，根据协议，这部分数据是压缩后的数据，用尽可能少的位数来表示坐标下的颜色索引。例如，图像如果一共只用到 3 个颜色，那么只需要用 2 位二进制位来存放一个坐标的索引，如果用了 15 个颜色，则使用 4 位二进制位来存放，以此类推。"]}),"\n",(0,r.jsxs)(e.p,{children:["最后，我们将颜色数量",(0,r.jsx)(e.code,{children:"colorCount"}),"、颜色数据",(0,r.jsx)(e.code,{children:"colorData"}),"和包含颜色索引的像素信息",(0,r.jsx)(e.code,{children:"pixelData"}),"拼接起来，再添加",(0,r.jsx)(e.code,{children:"AA LLLL 000000"}),"数据头，就可以生成我们要发送的信息了。"]}),"\n",(0,r.jsxs)(e.p,{children:["下面是完整的代码，可以",(0,r.jsx)(e.a,{href:"https://code.juejin.cn/pen/7216613245233135677",target:"_blank",rel:"noopener noreferrer",children:"访问这个链接"}),"在线运行效果。注意，别忘了先启动服务端，以便于建立设备连接。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"const picker = document.querySelector('input[type=color');\n​\nfunction int2hexlittle(value) {\n \xa0if(value > 65535 || value < 0) {\n \xa0 \xa0throw new TypeError('int2hexlittle only supports value between 0 and 65535');\n  }\n \xa0const byte1 = (value & 0xFF).toString(16).padStart(2, '0');\n \xa0const byte2 = ((value >> 8) & 0xFF).toString(16).padStart(2, '0');\n \xa0return `${byte1}${byte2}`;\n}\n​\nfunction lengthHS(message) {\n \xa0return int2hexlittle((message.length + 4) / 2);\n}\n​\nfunction calcCRC(message) {\n \xa0const msg = lengthHS(message) + message;\n \xa0let sum = 0;\n \xa0for(let i = 0, l = msg.length; i < l; i += 2) {\n \xa0 \xa0sum += parseInt(msg.substr(i, 2), 16);\n  }\n \xa0return int2hexlittle(sum % 65536);\n}\n​\nfunction number2HexString(int) {\n \xa0if(int > 255 || int < 0) {\n \xa0 \xa0throw new Error('number2HexString works only with number between 0 and 255');\n  }\n​\n \xa0return Math.round(int).toString(16).padStart(2, '0');\n}\n​\n​\nfunction generateImageData(pixels) {\n \xa0const colorMap = new Map();\n \xa0let index = 0;\n​\n \xa0let colorData = '';\n​\n \xa0const screen = [];\n​\n \xa0for(let i = 0; i < 256; i++) {\n \xa0 \xa0const color = pixels[i];\n \xa0 \xa0if(!colorMap.has(color)) {\n \xa0 \xa0 \xa0colorMap.set(color, index++);\n \xa0 \xa0 \xa0colorData += color;\n \xa0  }\n \xa0 \xa0screen.push(colorMap.get(color));\n  }\n​\n \xa0// Calculate how many bits are needed to fit all the palette values in\n \xa0// log(1) === 0. Therefore we clamp to [1,..]\n \xa0const referenceBitLength = Math.max(1, Math.ceil(Math.log2(colorData.length / 6)));\n​\n \xa0// Screen buffer is using minmal amount of bits to encode all palette codes.\n \xa0// Ordering of segments is Little endion\n \xa0let current = 0;\n \xa0let currentIndex = 0;\n​\n \xa0let pixelData = '';\n​\n \xa0screen.forEach((paletteIndex) => {\n \xa0 \xa0// Add the new color reference to the accumulator\n \xa0 \xa0const reference = paletteIndex & ((2 ** referenceBitLength) - 1);\n \xa0 \xa0current |= (reference << currentIndex);\n \xa0 \xa0currentIndex += referenceBitLength;\n​\n \xa0 \xa0// Write out all filled up bytes\n \xa0 \xa0while(currentIndex >= 8) {\n \xa0 \xa0 \xa0const lastByte = current & 0xff;\n \xa0 \xa0 \xa0current >>= 8;\n \xa0 \xa0 \xa0currentIndex -= 8;\n \xa0 \xa0 \xa0pixelData += number2HexString(lastByte);\n \xa0  }\n  });\n​\n \xa0// Add the last byte\n \xa0if(currentIndex !== 0) {\n \xa0 \xa0pixelData += number2HexString(current);\n  }\n​\n \xa0const colorCount = number2HexString(colorData.length / 6);\n \xa0const data = `${colorCount}${colorData}${pixelData}`;\n \xa0const length = int2hexlittle(data.length / 2 + 6);\n \xa0const prefix = '44000A0A04';\n \xa0return `${prefix}AA${length}000000${data}`;\n}\n​\nfunction setPixel(pixels, row, col, color = '000000') {\n \xa0pixels[row * 16 + col] = color;\n}\n​\nfunction generatePayload(message) {\n \xa0return `01${lengthHS(message)}${message}${calcCRC(message)}02`;\n}\n​\nasync function sendMessage(message) {\n \xa0const payload = generatePayload(message);\n \xa0const ret = await (await fetch('http://localhost:9527/send', {\n \xa0 \xa0method: 'POST',\n \xa0 \xa0body: JSON.stringify({\n \xa0 \xa0 \xa0payload,\n \xa0  }),\n  })).json();\n \xa0return ret;\n}\n​\nconst pixels = (new Array(256)).fill('000000');\n​\npicker.addEventListener('change', async ({target}) => {\n \xa0const colorStr = target.value.slice(1);\n \xa0for(let i = 0; i < 16; i++) {\n \xa0 \xa0for(let j = i; j < 16; j++) {\n \xa0 \xa0 \xa0setPixel(pixels, i, j, colorStr);\n \xa0  }\n  }\n \xa0await sendMessage(generateImageData(pixels));\n});\n"})}),"\n",(0,r.jsx)(e.p,{children:"最终运行效果如下："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:"Mar-31-2023 16-58-46.gif"})}),"\n",(0,r.jsxs)(e.h2,{id:"利用canvas绘图",children:["利用Canvas绘图",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#利用canvas绘图",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"上面的例子，我们可以通过像素点绘图，但是这么使用还是不够方便，我们可以做一个巧妙的设计，把代码封装成一个 Divoom 类，暴露一个 getContext 方法，返回一个 Canvas 的上下文对象，然后在 Canvas 中进行绘图！"}),"\n",(0,r.jsx)(e.p,{children:"我们看一下要怎么实现。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"class Divoom {\n \xa0constructor() {\n \xa0 \xa0this._canvas = new OffscreenCanvas(16, 16);\n  }\n​\n \xa0getContext() {\n \xa0 \xa0if(this._ctx) return this._ctx;\n \xa0 \xa0const ctx = this._canvas.getContext('2d', {willReadFrequently: true});\n \xa0 \xa0const {fill, stroke, fillRect, strokeRect, fillText, strokeText, drawImage, clearRect} = ctx;\n \xa0  [fill, stroke, fillRect, strokeRect, fillText, strokeText, drawImage, clearRect].forEach((fn) => {\n \xa0 \xa0 \xa0ctx[fn.name] = async (...rest) => {\n \xa0 \xa0 \xa0 \xa0fn.apply(ctx, rest);\n \xa0 \xa0 \xa0 \xa0return await this.forceUpdate();\n \xa0 \xa0  };\n \xa0  });\n \xa0 \xa0return ctx;\n  }\n​\n \xa0forceUpdate() {\n \xa0 \xa0this._needsUpdate = true;\n \xa0 \xa0if(!this._updatePromise) {\n \xa0 \xa0 \xa0this._updatePromise = new Promise((resolve) => {\n \xa0 \xa0 \xa0 \xa0requestAnimationFrame(() => {\n \xa0 \xa0 \xa0 \xa0 \xa0this._updatePromise = null;\n \xa0 \xa0 \xa0 \xa0 \xa0this.update();\n \xa0 \xa0 \xa0 \xa0 \xa0resolve();\n \xa0 \xa0 \xa0  });\n \xa0 \xa0  });\n \xa0  }\n \xa0 \xa0return this._updatePromise;\n  }\n​\n \xa0transferCanvasData() {\n \xa0 \xa0const ctx = this.getContext();\n \xa0 \xa0const imageData = ctx.getImageData(0, 0, 16, 16);\n \xa0 \xa0const data = imageData.data;\n \xa0 \xa0const pixels = [];\n​\n \xa0 \xa0for(let i = 0; i < 256; i++) {\n \xa0 \xa0 \xa0const index = i * 4;\n \xa0 \xa0 \xa0pixels[i] = number2HexString(data[index])\n \xa0 \xa0 \xa0 \xa0+ number2HexString(data[index + 1])\n \xa0 \xa0 \xa0 \xa0+ number2HexString(data[index + 2]);\n \xa0  }\n \xa0 \xa0return pixels;\n  }\n​\n \xa0async update() {\n \xa0 \xa0const pixels = this.transferCanvasData();\n \xa0 \xa0await sendMessage(generateImageData(pixels));\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面的代码我们简单封装了一个 Divoom 类，在这个类中，我们关联了一个 OffscreenCanvas 对象，我们让这个类能够通过 getContext 获得这个 Canvas 对象的上下文。同时，关键的一步是我们对这个对象的上下文中一些绘图方法进行了包装，我们让",(0,r.jsx)(e.code,{children:"fill, stroke, fillRect, strokeRect, fillText, strokeText, drawImage, clearRect"}),"这些 Canvas 方法在调用的时候，通过调用 forceUpdate 方法来异步触发 Divoom 对象的 update，在 update 方法里，我们读取 Canvas 对象的像素信息，并按照格式编码然后发送给设备。"]}),"\n",(0,r.jsx)(e.p,{children:"注意这里之所以要用异步，是考虑 HTTP 通讯的性能，我们不希望 Canvas 绘制的时候过于频繁地发送请求给服务。"}),"\n",(0,r.jsx)(e.p,{children:"那么实现了这个封装之后，我们就可以非常方便地使用 Canvas 来绘制我们的图形到设备上了："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"const device = new Divoom();\n​\nconst ctx = device.getContext();\nctx.fillStyle = 'blue';\nctx.beginPath();\nctx.rect(0, 0, 10, 10);\nctx.fill();\nctx.fillStyle = 'red';\nctx.beginPath();\nctx.rect(10, 10, 16, 16);\nctx.fill();\n"})}),"\n",(0,r.jsxs)(e.p,{children:["详细代码和完整的例子",(0,r.jsx)(e.a,{href:"https://code.juejin.cn/pen/7216633012636057655",target:"_blank",rel:"noopener noreferrer",children:"在这里"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"这是最终运行的效果："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"还可以用它来绘制各种图像，非常方便，比如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"(async () => {\n \xa0const device = new Divoom();\n​\n \xa0const url = 'https://p2.ssl.qhimg.com/t017f6883a6380b105b.png';\n \xa0const img = await loadImage(url);\n \xa0\n \xa0const ctx = device.getContext();\n​\n \xa0ctx.drawImage(img, 3, 5, 10, 10);\n \xa0ctx.fillStyle = 'white';\n \xa0ctx.fillRect(3, 3, 1, 1);\n \xa0ctx.fillRect(12, 3, 1, 1);\n})();\n"})}),"\n",(0,r.jsx)(e.p,{children:"最终效果如下："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"这一节课，我们对 Divoom 设备的客户端代码进行简单的封装，用 Canvas 上下文提供了强大的功能，这样就相当于我们从设备获得一个 16X16 的画布，可以随意发挥我们的想象力，绘制各种不同的图形，或者实现一些有趣的应用，非常的好玩。"}),"\n",(0,r.jsx)(e.p,{children:"不知道你入手了蓝牙设备吗？学到这里，你是否已经完成了设备的代码封装和调试，实现了什么有趣的功能？欢迎在评论区讨论。"})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let d=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F35%20%E5%AE%9E%E6%88%98%EF%BC%9A%E8%93%9D%E7%89%99%E5%83%8F%E7%B4%A0%E6%9D%BF%E7%BB%98%E5%9B%BE%20API%20%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.md"]={toc:[{text:"利用Canvas绘图",id:"利用canvas绘图",depth:2},{text:"小结",id:"小结",depth:2}],title:"35 实战：蓝牙像素板绘图 API 的设计与实现",headingTitle:"35 实战：蓝牙像素板绘图 API 的设计与实现",frontmatter:{}}}}]);