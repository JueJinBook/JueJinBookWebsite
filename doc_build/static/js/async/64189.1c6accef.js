"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["64189"],{430064:function(n,e,s){s.r(e),s.d(e,{default:()=>d});var i=s(552676),r=s(740453);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",h3:"h3",strong:"strong",pre:"pre",ul:"ul",li:"li"},(0,r.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"第07章替朋友着想优化我们的程序流",children:["第07章—替朋友着想：优化我们的程序流",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第07章替朋友着想优化我们的程序流",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["\uFEFF\n上一章我们讲了程序的执行流程，知道代码是怎么运行的了，那么，我们该怎么",(0,i.jsx)(e.code,{children:"让我们的代码更高效"}),"呢？"]}),"\n",(0,i.jsxs)(e.h2,{id:"条件语句的优化",children:["条件语句的优化",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#条件语句的优化",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["我们先来看条件语句的优化，我们知道，条件语句只有两种：",(0,i.jsx)(e.code,{children:"if-else"}),"和",(0,i.jsx)(e.code,{children:"switch"}),"。"]}),"\n",(0,i.jsxs)(e.h3,{id:"if-else-语句的优化",children:["if-else 语句的优化",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#if-else-语句的优化",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["根据上一章，我们知道 CPU 在遇到条件语句时，会执行跳转逻辑，那么，我们的优化点就是",(0,i.jsx)(e.strong,{children:"让 CPU 尽量不跳转，或者少跳转"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"考察如下代码："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public String check(int age, int sex) {\n    String msg = "";\n    if(age > 18) {\n        if(sex == 1) {\n            msg = "符合条件";\n        }else {\n            msg = "不符合条件";\n        }\n    }else {\n        msg = "不符合条件";\n    }\n    return msg;\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["逻辑很简单，就是筛选出",(0,i.jsx)(e.code,{children:"age>18"}),"并且",(0,i.jsx)(e.code,{children:"sex==1"}),"的人，代码一点儿问题都没有，但是太啰嗦，站在 CPU 的角度来看，需要执行两次跳转操作，当",(0,i.jsx)(e.code,{children:"age>18"}),"时，就进入内层的",(0,i.jsx)(e.code,{children:"if-else"}),"继续判断，也就意味着要再次跳转。"]}),"\n",(0,i.jsx)(e.p,{children:"其实我们可以直接优化下这个逻辑，我们知道，逻辑与操作有个特点：全真才真，那就意味着，只要第一个不满足条件，后面的就不用看了。根据这个特点，我们就直接优化成如下代码："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public String check(int age, int sex) {\n    String msg = "";\n    if(age > 18 && sex == 1) {\n        msg = "符合条件";\n    }else {\n        msg = "不符合条件";\n    }\n    return msg;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"这样一来，只需要执行一次判断，也就是只需要执行一次跳转逻辑，就可以了，这就节省了 CPU 的力气；其实这不是最简单的，还可以更简化，比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public String check(int age, int sex) {\n    if(age > 18 && sex == 1) return "符合条件";\n    return "不符合条件";\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["这样是不是更好了，连",(0,i.jsx)(e.code,{children:"else"}),"语句都省了，不仅效率提高了，而且连可读性也提高了。"]}),"\n",(0,i.jsxs)(e.p,{children:["其实，这些都可以总结为一点：",(0,i.jsx)(e.strong,{children:"逻辑能提前结束就提前结束"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:["比如，上述的两层",(0,i.jsx)(e.code,{children:"if-else"}),"判断逻辑，因为只要有一个不符合就能直接提前结束，所以我们就使用逻辑与操作来提前结束。"]}),"\n",(0,i.jsxs)(e.p,{children:["多个判断的",(0,i.jsx)(e.code,{children:"if-else"}),"逻辑，我们也可以优化，比如："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"public String getPrice(int level) {\n    if(level > 10) return 100;\n    if(level > 9) return 80;\n    if(level > 6) retrn 50;\n    if(level > 1) return 20;\n    return 10;\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["我们不用添加",(0,i.jsx)(e.code,{children:"else"}),"分支，尽量提前结束即可，这样执行效率高，可读性也强。"]}),"\n",(0,i.jsxs)(e.h3,{id:"switch-语句的优化",children:["switch 语句的优化",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#switch-语句的优化",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["其实",(0,i.jsx)(e.code,{children:"switch"}),"语句和",(0,i.jsx)(e.code,{children:"if-else"}),"语句的区别不大，只不过写法不同而已，但是，",(0,i.jsx)(e.code,{children:"switch"}),"语句有个特殊的优化点，那就是数组。"]}),"\n",(0,i.jsx)(e.p,{children:"比如还是上述代码，我们改成 switch 语句："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"public int getPrice(int level) {\n    switch(level)\n        case 10: return 100;\n        case 9: return 80;\n        case 8:\n        case 7:\n        case 6: return 50;\n        case 5:\n        case 4:\n        case 3:\n        case 2:\n        case 1: return 20;\n        default: return 10;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"看着没啥区别，其实编译器会把它优化成一个数组，其中数组的下标为 0 到 10，不同下标对应的价格就是 return 的数值，也就是："}),"\n",(0,i.jsxs)(e.p,{children:["而我们又知道，数组是支持随机访问的，速度极快，所以，编译器对",(0,i.jsx)(e.code,{children:"switch"}),"的这个优化就会大大提升程序的运行效率，这可比一条一条执行命令快多了。"]}),"\n",(0,i.jsxs)(e.p,{children:["那么，我还写个毛的",(0,i.jsx)(e.code,{children:"if-else"}),"语句啊，我直接全部写",(0,i.jsx)(e.code,{children:"switch"}),"不就行了？"]}),"\n",(0,i.jsxs)(e.p,{children:["不行！因为编译器对 switch 的优化是有条件的，",(0,i.jsx)(e.strong,{children:"它要求你的 code 必须是紧凑的"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"紧凑是啥意思呢？必须小吗？不是，是连续的，比如：你的 code 是 1、50、51、101、110。这不是紧凑。\n而你的 code 是 1000、1001、1002、1003。这就是紧凑。"}),"\n",(0,i.jsx)(e.p,{children:"这是为什么呢？因为我要用数组来优化你啊，你如果不是紧凑的，比如上述的最小 1，最大 110，我就要创建一个长度 110 的数组来存放你，而这么长的数组中，只有：1、50、51、101、110 这几个位置有用，岂不是浪费空间！"}),"\n",(0,i.jsx)(e.p,{children:"那这也不对啊，你那个 1000 开头的虽然紧凑，但是它大啊，你要创建一个长度为 1003 的数组呢。"}),"\n",(0,i.jsx)(e.p,{children:"真是老实人啊，我不需要创建那么大，我只需要创建长度为 4 的数组就行了，下标分别为 0、1、2、3。计算的时候，我就用实际数字减去 1000，就得到对应的下标了，这就是个减法问题，效率是很高的。"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsxs)(e.strong,{children:["所以，我们在使用",(0,i.jsx)(e.code,{children:"switch"}),"的时候，尽量保证 code 是紧凑的，也就是连续的；也尽量使用数字类型的，因为你使用引用类型的话，它实际执行的 code 是引用类型的 hashcode，hashcode 是个 int 类型的数字，也不能保证是连续的"]}),"。"]}),"\n",(0,i.jsxs)(e.h2,{id:"循环语句的优化",children:["循环语句的优化",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#循环语句的优化",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["其实循环语句跟条件语句很类似，只不过写法不同而已，循环语句的优化点也是以",(0,i.jsx)(e.code,{children:"减少指令"}),"为主。"]}),"\n",(0,i.jsx)(e.p,{children:"我们先来看一个中二的写法："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 找出名字为张三的人\npublic User findUserByName(Users users) {\n    User user = null;\n    for(int i = 0; i < users.length; i++) {\n        if(users[i].name.equals("张三")) {\n            user = users[i];\n        }\n    }\n    return user;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"哈哈哈哈哈，真是人才啊，如此代码，先拉出去打一顿再说。"}),"\n",(0,i.jsx)(e.p,{children:"大哥，你说你这都找到人了，直接返回不行吗？还要接着遍历干啥？如果数组长度是 10086，第一个人就叫张三，那后面那 10085 次遍历不就白做了，真拿 CPU 不当人啊，生产队的驴看了都流泪。"}),"\n",(0,i.jsx)(e.p,{children:"你直接这样写不就行了："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 找出名字为张三的人\npublic User findUserByName(Users users) {\n    for(int i = 0; i < users.length; i++) {\n         // 找到了就趁早返回，别在那墨迹了\n        if(users[i].name.equals("张三")) return user[i];\n    }\n    return null;\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["这样写效率高，可读性强，也符合我们上述的",(0,i.jsx)(e.strong,{children:"逻辑能提前结束就提前结束"}),"这个观点。CPU 直接感谢你全家。"]}),"\n",(0,i.jsx)(e.p,{children:"其实，这里还有一点可以优化的地方，就是我们的数组长度可以提取出来，不必每次都访问，也就是这样："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'// 找出名字为张三的人\npublic User findUserByName(Users users) {\n    // 将数组长度提取出来，不必每次循环都访问\n    int length = users.length;\n    for(int i = 0; i < length; i++) {\n         // 找到了就趁早返回，别在那墨迹了\n        if(users[i].name.equals("张三")) return user[i];\n    }\n    return null;\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["这看起来好像有点吹毛求疵了，确实是，但是如果考虑到性能的话，还是有点用的。比如有的集合的",(0,i.jsx)(e.code,{children:"size()"}),"函数，不是简单的属性访问，而是每次都需要计算一次，这种场景就是一次很大的优化了，因为省了很多次函数调用的过程，也就是省了很多个",(0,i.jsx)(e.code,{children:"call"}),"和",(0,i.jsx)(e.code,{children:"return"}),"指令，这无异是提高了代码的效率的。尤其是在循环语句这种容易量变引起质变的情况下，差距就是从这个细节拉开的。"]}),"\n",(0,i.jsx)(e.p,{children:"对于循环这种操作，我们要考虑的肯定是提前结束，越提前结束，效率越高。那么，遍历的时候，我们就要考虑一下遍历的方向了。"}),"\n",(0,i.jsx)(e.p,{children:"比如，我们要找一个年龄为 60 岁的人，而根据我们的经验，越早注册的用户，年龄越大，也就越早被添加到数据库中，也就越靠前，而 60 岁本来就是一个比较大的年龄，所以我们应该从前往后遍历，这样就能提前命中。而如果我们要找一个 20 岁的用户，则正好相反，就要从后往前遍历，这样才能更提前命中。"}),"\n",(0,i.jsxs)(e.p,{children:["这些原因，还是那句话：",(0,i.jsx)(e.strong,{children:"逻辑能提前结束就提前结束"}),"。所以我们的工作重点就变成了：怎么让逻辑提前结束？"]}),"\n",(0,i.jsx)(e.p,{children:"我们在执行循环的时候，尽量不要在循环体内创建变量，比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"int sum;\nfor(int a = 0; a < 10; a++) {\n    int b = a*2;\n    sum +=b;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"这每次循环，都创建一个 b，而前面我们讲过，局部变量的生命周期跟当前函数绑定，只要这个函数没调用完，它就一直存在，这真是没事找事，大大浪费内存，如果在循环体内创建对象，就更罪不可赦了。"}),"\n",(0,i.jsx)(e.p,{children:"要是真需要的话，可以改为如下代码："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"int sum;\nint b;\nfor(int a = 0; a < 10; a++) {\n    b = a*2;\n    sum +=b;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"这样只有一个变量，降低了内存使用率，也提升了代码的执行速度。"}),"\n",(0,i.jsxs)(e.p,{children:["另外一个点就是，我们在遍历集合的时候，应该优先使用",(0,i.jsx)(e.code,{children:"迭代器"}),"，这里面的原因就不多说了，大家去看一下相关的源码就明白了。"]}),"\n",(0,i.jsxs)(e.h2,{id:"递归的优化",children:["递归的优化",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#递归的优化",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"递归是一门伟大的发明，我们可以通过简单的函数调用，实现很复杂的逻辑。比如，求斐波那契数列的代码:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public int fib(int n) {\n    if(x < 0) throw  new IllegalArgumentException("参数不合法");\n    if(x == 0) return 0;\n    if(x == 1) return 1;\n    return fib(n-1) + fib(n-2); // 递归\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["代码很精彩，也没毛病，但是我们仔细想一下，假如",(0,i.jsx)(e.code,{children:"n=10"}),"，流程如下："]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"f(10) = f(9) + f(8); //分别计算f(9)和f(8)；"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"f(9) = f(8) + f(7); //分别计算f(8)和f(7)，唉等等，上面我们计算过了f(8)啊，这里怎么还要计算；"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"f(8) = f(7) + f(6); //分别计算f(7)和f(6)，又计算了一遍f(7)。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"想必你已经看出问题了，我们做了好多次重复计算，这显然是不应该的。那么，我们能不能把这些重复的计算只做一次呢？"}),"\n",(0,i.jsxs)(e.p,{children:["当然可以，不过我们就需要把重复计算的结果保存下来了，我们可以定义一个数组，将每个",(0,i.jsx)(e.code,{children:"f(n)"}),"都保存下来，后面需要的时候直接去取就行了，修改后的代码如下："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 修改后的代码，用一个数组保存计算过的结果\npublic int fib2(int n) {\n    if (n == 0) return 0;\n    int[] fibs = new int[n + 1]; // 用来保存从0到n的n个斐波那契数\n    fibs[0] = 0; // 存0\n    fibs[1] = 1; // 存1\n    for (int i = 2; i <= n; i++) {\n        fibs[i] = fibs[i - 1] + fibs[i - 2];// 这里不用递归计算了，直接用前面计算过的结果即可\n    }\n    return fibs[n];\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["改版后的代码不再是递归的了，而是采用一个数组缓存了计算的结果，后面的每个计算，直接去数组里获取即可。这种思维其实叫做",(0,i.jsx)(e.strong,{children:"动态规划（Dynamic Programming），简称为 DP"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"那么，什么情况下我们的递归函数可以使用动态规划呢？"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"当我们的递归函数是运算类型的，并且里面有大量重复的运算的时候，就该想到采用动态规划"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"关于动态规划的更多知识，我们会在后面的数据结构部分详细展开。"}),"\n",(0,i.jsxs)(e.h2,{id:"总结",children:["总结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["本章详细讲解了几个程序流的优化方案，其实说白了就是一点：",(0,i.jsx)(e.strong,{children:"逻辑能提前结束就提前结束"}),"，最后还对递归进行了一个优化讲解，也就是",(0,i.jsx)(e.strong,{children:"避免大量的重复计算"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"我们再来回顾下："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"对条件语句的优化，需要逻辑提前结束；"}),"\n",(0,i.jsx)(e.li,{children:"对 switch 语句的优化，需要 code 是数字类型的，且尽量紧凑；"}),"\n",(0,i.jsx)(e.li,{children:"对循环语句的优化，也需要逻辑提前结束，并且不在循环体内声明变量；"}),"\n",(0,i.jsx)(e.li,{children:"对递归函数调用的优化，不做大量重复计算。"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["这些所有优化都围绕着一个核心：",(0,i.jsx)(e.strong,{children:"减少 CPU 执行的指令数，减少 CPU 执行的运算次数"}),"。说白了就是，替我们的好朋友 CPU 着想，别光顾着自己写着爽。"]}),"\n",(0,i.jsx)(e.p,{children:"那么，下一章，我们就来看下我们人类和计算机之间的区别到底在哪里。"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC07%E7%AB%A0%E2%80%94%E6%9B%BF%E6%9C%8B%E5%8F%8B%E7%9D%80%E6%83%B3%EF%BC%9A%E4%BC%98%E5%8C%96%E6%88%91%E4%BB%AC%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%B5%81.md"]={toc:[{text:"条件语句的优化",id:"条件语句的优化",depth:2},{text:"if-else 语句的优化",id:"if-else-语句的优化",depth:3},{text:"switch 语句的优化",id:"switch-语句的优化",depth:3},{text:"循环语句的优化",id:"循环语句的优化",depth:2},{text:"递归的优化",id:"递归的优化",depth:2},{text:"总结",id:"总结",depth:2}],title:"第07章—替朋友着想：优化我们的程序流",headingTitle:"第07章—替朋友着想：优化我们的程序流",frontmatter:{}}}}]);