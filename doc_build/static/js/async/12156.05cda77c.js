"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12156"],{727714:function(e,n,r){r.r(n),r.d(n,{default:()=>E});var t=r(552676),c=r(740453);let s=r.p+"static/image/e597c6d0ffceec014e9eb4dadda7b18d.901f5258.webp",i=r.p+"static/image/95a9c4b4712d6440f2f126ec35227ed7.c26cc360.webp",o=r.p+"static/image/32c7767bd6f0faef93f642c222e069bb.c7812feb.webp",d=r.p+"static/image/510afb83acc037fcfa8300bce8ed6f5c.d403274d.webp",l=r.p+"static/image/8be3923f3ebeeb02df59bf7eebe40d83.d58a5110.webp",a=r.p+"static/image/fe9cb17a8df714107e6dfc78cba8e404.6b9b7f02.webp",h=r.p+"static/image/9515e6f0d085b98966cb65f40478fb14.0e8eac29.webp";function p(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",pre:"pre",code:"code",img:"img"},(0,c.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"7user-event怎么对-dom-组件绑定事件进行模拟触发",children:["7.User-event：怎么对 Dom 组件绑定事件进行模拟触发？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7user-event怎么对-dom-组件绑定事件进行模拟触发",children:"#"})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["代码仓库：",(0,t.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"经过前三节课的学习，我们现在已经学会了怎么对 DOM 元素进行查询和断言，但是光这样还不足够覆盖我们业务场景的用例需求。在实际的业务场景中，往往会包含各种事件，比如按钮点击，表单提交等，对于这类用例，我们需要模拟对应的事件来触发。"}),"\n",(0,t.jsx)(n.p,{children:"针对这种场景，React Testing Library 提供了两种手段来模拟，fireEvent 和 userEvent，这节课我们就来学习怎么通过它们来模拟事件。"}),"\n",(0,t.jsxs)(n.h2,{id:"fireevent",children:["fireEvent",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#fireevent",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"fireEvent 是 React Testing Library 提供的一组 API，通过它我们可以高效模拟事件的触发。在介绍之前，我们首先回到上节课中的例子。在上节课中，我们测试聚焦的断言时，有使用 fireEvent 来模拟文本框的聚焦。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/__test__/dom_expect.test.tsx\nimport React from "react";\nimport { render, screen } from "@testing-library/react";\nimport { DomExpect } from "../components/DomExpect/index";\n\ndescribe("tests for 《6 | DOM断言:页面元素的断言》", () => {\n  // ...\n  test(\'form validation without semi\', () => {\n    // ...\n    age.focus();\n    // ...\n  });\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"这是一种特殊的方式，focus 事件有被绑定在元素的对象上，与此类似的 blur（失焦）事件，执行的效果与 fireEvent 中提供的 focus 是相同的。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"fireEvent Api 的结构是这样的："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"fireEvent[eventName](node: HTMLElement, eventProperties: Object)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上面的参数 eventName 是指需要模拟的事件，除 focus 外，fireEvent 还可以模拟 click 等事件，其中 eventName 涉及大部分 document event，支持的内容大家可以在源码 ",(0,t.jsx)(n.a,{href:"https://github1s.com/testing-library/dom-testing-library/blob/main/src/event-map.js",target:"_blank",rel:"noopener noreferrer",children:"event-map.js"})," 中查看。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["小部分较难模拟的事件不支持，例如滚动，这部分我们可以采用端对端测试的方案来覆盖，具体会在 ",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7174044519350927395/section/7176804898074427427",target:"_blank",rel:"noopener noreferrer",children:"14 | E2E:  怎么覆盖滚动等复杂交互场景的测试？"})," 介绍。"]}),"\n",(0,t.jsxs)(n.p,{children:["除 eventName 外，还有一个 node 和 eventProperties ，node可以接收一个我们查询出来的对象，而 eventProperities 则是描述这个具体事件的属性，以键盘按下事件为例，不同的按键按下会有对应的属性，这个具体的属性可以通过 ",(0,t.jsx)(n.a,{href:"https://www.toptal.com/developers/keycode",target:"_blank",rel:"noopener noreferrer",children:"下面的页面"})," 查询，比如我们按一下空格键。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"与之对应的 fireEvent，我们就可以写作："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"firEvent.keyDown(node, {key: '', code: 'Space', charCode: 32})\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们来举个例子具体说明一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/components/DomEvent.tsx\nimport { FC } from "react";\n\ninterface IProps {\n  onClick: () => void;\n}\n\n// 《7 | User-event: 怎么对 Dom 组件绑定事件进行模拟触发？》\nexport const DomEvent: FC<IProps> = ({ onClick }) => {\n  return (\n    <div role="note" onClick={onClick}>\n      点我试试\n    </div>\n  );\n};\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/__test__/dom_event.test.tsx\nimport React from "react";\nimport { fireEvent, render, screen } from "@testing-library/react";\nimport { DomEvent } from "../components/DomEvent";\n\ndescribe("tests for 《7 | User-event: 怎么对 Dom 组件绑定事件进行模拟触发？》", () => {\n  test("mock events with fireEvent", () => {\n    const clickEvent = jest.fn();\n    render(<DomEvent onClick={clickEvent} />);\n    fireEvent.click(screen.getByRole("note"));\n    expect(clickEvent).toBeCalled();\n    expect(clickEvent).toBeCalledTimes(1);\n  });\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["通常对于事件的用例，我们会使用到 Jest 提供的 mock 事件，以及 ",(0,t.jsx)(n.code,{children:"toBeCalled"})," 和 ",(0,t.jsx)(n.code,{children:"toBeCalledTimes"})," 两个断言，",(0,t.jsx)(n.code,{children:"toBeCalled"})," 用来判断 mock 事件是否被调用，而 ",(0,t.jsx)(n.code,{children:"toBeCalledTimes"})," 用来判断 mock 事件被调用的次数。"]}),"\n",(0,t.jsx)(n.p,{children:"在上面的例子中，我们 mock 了一个函数，并且把它传入我们定义组件的 click 事件中，作为预期，我们断言了这个函数在模拟点击后，将会被执行，且执行次数为1。大家可能会有一个疑问，我们实际传入的方法并不是 mock 方法，那怎么保证这个事件触发后可以按预期执行呢？"}),"\n",(0,t.jsx)(n.p,{children:"其实，这个我们应该单独为函数本身书写用例来测试，因为根据单一原则，我们这边需要保证的是在事件触发后，可以执行对应的回调，至于回调自己的函数做了什么事情，我们应该直接配置入参来测试函数。"}),"\n",(0,t.jsxs)(n.h2,{id:"userevent",children:["userEvent",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#userevent",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"上面我们介绍了 fireEvent，虽然它是可以满足我们需求的，但是其实我们应该尽量避免使用 fireEvent，而是使用 userEvent，为什么呢？"}),"\n",(0,t.jsx)(n.p,{children:"在之前的章节我们反复提到，我们书写的用例应该尽可能从用户视角来展开，而不是代码层面，这样对于用例本身来说，才是更强健的，对于 fireEvent 而言，它只是在调度一个 DOM 事件，例如 click 事件，对于 fireEvent 而言，它只是直接触发了这个元素的 click。"}),"\n",(0,t.jsx)(n.p,{children:"然而在实际的场景中，我们点击一个按钮，会有先 hover 再聚焦的过程，这些事件的触发并不会在 fireEvent 中体现出来。 userEvent 则是在模拟完整的事件流程，我们上面提到的 click 事件，它同样也会触发 hover 等事件效果，更为真实地还原了用户的场景，我们可以从源码上来更深刻地认识这个问题。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这是 fireEvent 的实现，很简单，除了一些异常的兜底外，就是直接模拟返回的事件。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这是 userEvent 的实现，除了模拟传入实例直接需要的 click 外，它还触发了这个元素聚焦和失焦，就不像 fireEvent ，只是简单返回模拟的事件。对于其他事件，userEvent 也是针对事件来一一定制对应的响应函数的，目前支持的有下面的事件， 对于还没实现的事件大家可以用 fireEvent 先替代。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"对于之前写的 fireEvent 用例，我们尝试用 userEvent 改写一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/__test__/dom_event.test.tsx\nimport React from "react";\nimport { fireEvent, render, screen } from "@testing-library/react";\nimport { DomEvent } from "../components/DomEvent";\nimport userEvent from "@testing-library/user-event";\n\ndescribe("tests for 《7 | User-event: 怎么对 Dom 组件绑定事件进行模拟触发？》", () => {\n  // ... other content\n  test("mock events with userEvent", () => {\n    const clickEvent = jest.fn();\n    render(<DomEvent onClick={clickEvent} />);\n    userEvent.click(screen.getByRole("note"));\n    expect(clickEvent).toBeCalled();\n    expect(clickEvent).toBeCalledTimes(1);\n  });\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsxs)(n.h2,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这节课我们学习了怎么对 DOM 组件的事件进行模拟，React Testing Library 提供了 fireEvent 和 userEvent 两组 API 来帮助我们进行事件模拟，在 API 支持的情况下，我推荐大家优先使用 userEvent。"}),"\n",(0,t.jsx)(n.p,{children:"从实现上来说，fireEvent 采用简单的事件模拟方式，只会触发对应的事件，并不是真实还原用户操作的完整场景，而 userEvent 暴露的每个方法都是根据实际事件场景去定制的还原。从用例的强健性上看，与网页使用方式越相近的测试用例，给予我们的信心就会越大，用例也不容易变更或是遗漏边缘情况。"}),"\n",(0,t.jsx)(n.p,{children:"现在我们已经学习了查询、断言以及事件模拟的相关内容，对于 DOM 事件的用例书写，相信大家已经有了初步的认知，但是到目前为止，我们的用例都还是同步进行的，事实上在实际的业务场景，我们难免会遇到异步执行的逻辑，这个也是我们用例需要覆盖的重要模块，下节课我们就来学习如何测试异步逻辑。"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}let E=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F7.User-event%EF%BC%9A%E6%80%8E%E4%B9%88%E5%AF%B9%20Dom%20%E7%BB%84%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%A8%A1%E6%8B%9F%E8%A7%A6%E5%8F%91%EF%BC%9F.md"]={toc:[{text:"fireEvent",id:"fireevent",depth:2},{text:"userEvent",id:"userevent",depth:2},{text:"小结",id:"小结",depth:2}],title:"7.User-event：怎么对 Dom 组件绑定事件进行模拟触发？",headingTitle:"7.User-event：怎么对 Dom 组件绑定事件进行模拟触发？",frontmatter:{}}}}]);