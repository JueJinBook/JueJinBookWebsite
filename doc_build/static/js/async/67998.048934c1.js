"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["67998"],{635333:function(e,n,d){d.r(n),d.d(n,{default:()=>h});var s=d(552676),c=d(740453);let r=d.p+"static/image/d896946a529bfafca32ff848ab774f13.f4b40e34.webp";function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",hr:"hr",code:"code",pre:"pre",blockquote:"blockquote",h3:"h3",img:"img",strong:"strong"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"3一面-2js-web-api-知识点与高频考题解析",children:["3.一面 2：JS-Web-API 知识点与高频考题解析",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3一面-2js-web-api-知识点与高频考题解析",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"除 ES 基础之外，Web 前端经常会用到一些跟浏览器相关的 API，接下来我们一起梳理一下。"}),"\n",(0,s.jsxs)(n.h2,{id:"知识点梳理",children:["知识点梳理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点梳理",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"BOM 操作"}),"\n",(0,s.jsx)(n.li,{children:"DOM 操作"}),"\n",(0,s.jsx)(n.li,{children:"事件绑定"}),"\n",(0,s.jsx)(n.li,{children:"Ajax"}),"\n",(0,s.jsx)(n.li,{children:"存储"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"bom",children:["BOM",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#bom",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"navigator"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"screen"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"location"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"history"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这些对象就是一堆非常简单粗暴的 API，没任何技术含量，讲起来一点意思都没有，大家去 MDN 或者 w3school 这种网站一查就都明白了。面试的时候，面试官基本不会出太多这方面的题目，因为只要基础知识过关了，这些 API 即便你记不住，上网一查也都知道了。下面列举一下常用功能的代码示例"}),"\n",(0,s.jsxs)(n.p,{children:["获取浏览器特性（即俗称的",(0,s.jsx)(n.code,{children:"UA"}),"）然后识别客户端，例如判断是不是 Chrome 浏览器"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var ua = navigator.userAgent\nvar isChrome = ua.indexOf('Chrome')\nconsole.log(isChrome)\n"})}),"\n",(0,s.jsx)(n.p,{children:"获取屏幕的宽度和高度"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"console.log(screen.width)\nconsole.log(screen.height)\n"})}),"\n",(0,s.jsx)(n.p,{children:"获取网址、协议、path、参数、hash 等"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 例如当前网址是 https://juejin.cn/timeline/frontend?a=10&b=10#some\nconsole.log(location.href)  // https://juejin.cn/timeline/frontend?a=10&b=10#some\nconsole.log(location.protocol) // https:\nconsole.log(location.pathname) // /timeline/frontend\nconsole.log(location.search) // ?a=10&b=10\nconsole.log(location.hash) // #some\n"})}),"\n",(0,s.jsx)(n.p,{children:"另外，还有调用浏览器的前进、后退功能等"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"history.back()\nhistory.forward()\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"dom",children:["DOM",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dom",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：DOM 和 HTML 区别和联系"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"什么是-dom",children:["什么是 DOM",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是-dom",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"讲 DOM 先从 HTML 讲起，讲 HTML 先从 XML 讲起。XML 是一种可扩展的标记语言，所谓可扩展就是它可以描述任何结构化的数据，它是一棵树！"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" encoding="UTF-8"?>\n<note>\n  <to>Tove</to>\n  <from>Jani</from>\n  <heading>Reminder</heading>\n  <body>Don\'t forget me this weekend!</body>\n  <other>\n    <a></a>\n    <b></b>\n  </other>\n</note>\n'})}),"\n",(0,s.jsx)(n.p,{children:"HTML 是一个有既定标签标准的 XML 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一棵树。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n</head>\n<body>\n    <div>\n        <p>this is p</p>\n    </div>\n</body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["我们开发完的 HTML 代码会保存到一个文档中（一般以",(0,s.jsx)(n.code,{children:".html"}),"或者",(0,s.jsx)(n.code,{children:".htm"}),"结尾），文档放在服务器上，浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的是一个文档而已，文档的内容就是 HTML 格式的代码。"]}),"\n",(0,s.jsx)(n.p,{children:"但是浏览器要把这个文档中的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JS 能理解的东西，因为还得允许 JS 修改页面内容呢。"}),"\n",(0,s.jsx)(n.p,{children:"基于以上需求，浏览器就需要把 HTML 转变成 DOM，HTML 是一棵树，DOM 也是一棵树。对 DOM 的理解，可以暂时先抛开浏览器的内部因素，先从 JS 着手，即可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:"DOM图示"})}),"\n",(0,s.jsxs)(n.h3,{id:"获取-dom-节点",children:["获取 DOM 节点",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#获取-dom-节点",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"最常用的 DOM API 就是获取节点，其中常用的获取方法如下面代码示例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 通过 id 获取\nvar div1 = document.getElementById('div1') // 元素\n\n// 通过 tagname 获取\nvar divList = document.getElementsByTagName('div')  // 集合\nconsole.log(divList.length)\nconsole.log(divList[0])\n\n// 通过 class 获取\nvar containerList = document.getElementsByClassName('container') // 集合\n\n// 通过 CSS 选择器获取\nvar pList = document.querySelectorAll('p') // 集合\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：property 和 attribute 的区别是什么？"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"property",children:["property",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#property",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["DOM 节点就是一个 JS 对象，它符合之前讲述的对象的特征 —— 可扩展属性，因为 DOM 节点本质上也是一个 JS 对象。因此，如下代码所示，",(0,s.jsx)(n.code,{children:"p"}),"可以有",(0,s.jsx)(n.code,{children:"style"}),"属性，有",(0,s.jsx)(n.code,{children:"className"})," ",(0,s.jsx)(n.code,{children:"nodeName"})," ",(0,s.jsx)(n.code,{children:"nodeType"}),"属性。注意，",(0,s.jsx)(n.strong,{children:"这些都是 JS 范畴的属性，符合 JS 语法标准的"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var pList = document.querySelectorAll('p')\nvar p = pList[0]\nconsole.log(p.style.width)  // 获取样式\np.style.width = '100px'  // 修改样式\nconsole.log(p.className)  // 获取 class\np.className = 'p1'  // 修改 class\n\n// 获取 nodeName 和 nodeType\nconsole.log(p.nodeName)\nconsole.log(p.nodeType)\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"attribute",children:["attribute",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#attribute",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"property 的获取和修改，是直接改变 JS 对象，而 attribute 是直接改变 HTML 的属性，两种有很大的区别。attribute 就是对 HTML 属性的 get 和 set，和 DOM 节点的 JS 范畴的 property 没有关系。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var pList = document.querySelectorAll('p')\nvar p = pList[0]\np.getAttribute('data-name')\np.setAttribute('data-name', 'juejin')\np.getAttribute('style')\np.setAttribute('style', 'font-size:30px;')\n"})}),"\n",(0,s.jsx)(n.p,{children:"而且，get 和 set attribute 时，还会触发 DOM 的查询或者重绘、重排，频繁操作会影响页面性能。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：DOM 操作的基本 API 有哪些？"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"dom-树操作",children:["DOM 树操作",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dom-树操作",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"新增节点"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var div1 = document.getElementById('div1')\n\n// 添加新节点\nvar p1 = document.createElement('p')\np1.innerHTML = 'this is p1'\ndiv1.appendChild(p1) // 添加新创建的元素\n\n// 移动已有节点。注意，这里是“移动”，并不是拷贝\nvar p2 = document.getElementById('p2')\ndiv1.appendChild(p2)\n"})}),"\n",(0,s.jsx)(n.p,{children:"获取父元素"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var div1 = document.getElementById('div1')\nvar parent = div1.parentElement\n"})}),"\n",(0,s.jsx)(n.p,{children:"获取子元素"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var div1 = document.getElementById('div1')\nvar child = div1.childNodes\n"})}),"\n",(0,s.jsx)(n.p,{children:"删除节点"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var div1 = document.getElementById('div1')\nvar child = div1.childNodes\ndiv1.removeChild(child[0])\n"})}),"\n",(0,s.jsx)(n.p,{children:"还有其他操作的API，例如获取前一个节点、获取后一个节点等，但是面试过程中经常考到的就是上面几个。"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"事件",children:["事件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#事件",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"事件绑定",children:["事件绑定",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#事件绑定",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"普通的事件绑定写法如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var btn = document.getElementById('btn1')\nbtn.addEventListener('click', function (event) {\n    // event.preventDefault() // 阻止默认行为\n    // event.stopPropagation() // 阻止冒泡\n    console.log('clicked')\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"为了编写简单的事件绑定，可以编写通用的事件绑定函数。这里虽然比较简单，但是会随着后文的讲解，来继续完善和丰富这个函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 通用的事件绑定函数\nfunction bindEvent(elem, type, fn) {\n    elem.addEventListener(type, fn)\n}\nvar a = document.getElementById('link1')\n// 写起来更加简单了\nbindEvent(a, 'click', function(e) {\n    e.preventDefault() // 阻止默认行为\n    alert('clicked')\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最后，",(0,s.jsx)(n.strong,{children:"如果面试被问到 IE 低版本兼容性问题，我劝你果断放弃这份工作机会"}),"。现在互联网流量都在 App 上， IE 占比越来越少，再去为 IE 浪费青春不值得，要尽量去做 App 相关的工作。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：什么是事件冒泡？"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"事件冒泡",children:["事件冒泡",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#事件冒泡",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<body>\n    <div id="div1">\n        <p id="p1">激活</p>\n        <p id="p2">取消</p>\n        <p id="p3">取消</p>\n        <p id="p4">取消</p>\n    </div>\n    <div id="div2">\n        <p id="p5">取消</p>\n        <p id="p6">取消</p>\n    </div>\n</body>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["对于以上 HTML 代码结构，要求点击",(0,s.jsx)(n.code,{children:"p1"}),"时候进入激活状态，点击其他任何",(0,s.jsx)(n.code,{children:"<p>"}),"都取消激活状态，如何实现？代码如下，注意看注释："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var body = document.body\nbindEvent(body, 'click', function (e) {\n    // 所有 p 的点击都会冒泡到 body 上，因为 DOM 结构中 body 是 p 的上级节点，事件会沿着 DOM 树向上冒泡\n    alert('取消')\n})\n\nvar p1 = document.getElementById('p1')\nbindEvent(p1, 'click', function (e) {\n    e.stopPropagation() // 阻止冒泡\n    alert('激活')\n})\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果我们在",(0,s.jsx)(n.code,{children:"p1"})," ",(0,s.jsx)(n.code,{children:"div1"})," ",(0,s.jsx)(n.code,{children:"body"}),"中都绑定了事件，它是会根据 DOM 的结构来冒泡，从下到上挨个执行的。但是我们使用",(0,s.jsx)(n.code,{children:"e.stopPropagation()"}),"就可以阻止冒泡"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：如何使用事件代理？有何好处？"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"事件代理",children:["事件代理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#事件代理",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们设定一种场景，如下代码，一个",(0,s.jsx)(n.code,{children:"<div>"}),"中包含了若干个",(0,s.jsx)(n.code,{children:"<a>"}),"，而且还能继续增加。那如何快捷方便地为所有",(0,s.jsx)(n.code,{children:"<a>"}),"绑定事件呢？"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<div id="div1">\n    <a href="#">a1</a>\n    <a href="#">a2</a>\n    <a href="#">a3</a>\n    <a href="#">a4</a>\n</div>\n<button>点击增加一个 a 标签</button>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这里就会用到事件代理。我们要监听",(0,s.jsx)(n.code,{children:"<a>"}),"的事件，但要把具体的事件绑定到",(0,s.jsx)(n.code,{children:"<div>"}),"上，然后看事件的触发点是不是",(0,s.jsx)(n.code,{children:"<a>"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var div1 = document.getElementById('div1')\ndiv1.addEventListener('click', function (e) {\n    // e.target 可以监听到触发点击事件的元素是哪一个\n    var target = e.target\n    if (e.nodeName === 'A') {\n        // 点击的是 <a> 元素\n        alert(target.innerHTML)\n    }\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们现在完善一下之前写的通用事件绑定函数，加上事件代理。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function bindEvent(elem, type, selector, fn) {\n    // 这样处理，可接收两种调用方式 bindEvent(div1, 'click', 'a', function () {...}) 和 bindEvent(div1, 'click', function () {...}) 这两种\n    if (fn == null) {\n        fn = selector\n        selector = null\n    }\n\n    // 绑定事件\n    elem.addEventListener(type, function (e) {\n        var target\n        if (selector) {\n            // 有 selector 说明需要做事件代理\n            // 获取触发时间的元素，即 e.target\n            target = e.target\n            // 看是否符合 selector 这个条件\n            if (target.matches(selector)) {\n                fn.call(target, e)\n            }\n        } else {\n            // 无 selector ，说明不需要事件代理\n            fn(e)\n        }\n    })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后这样使用，简单很多。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 使用代理，bindEvent 多一个 'a' 参数\nvar div1 = document.getElementById('div1')\nbindEvent(div1, 'click', 'a', function (e) {\n    console.log(this.innerHTML)\n})\n\n// 不使用代理\nvar a = document.getElementById('a1')\nbindEvent(div1, 'click', function (e) {\n    console.log(a.innerHTML)\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"最后，使用代理的优点如下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"使代码简洁"}),"\n",(0,s.jsx)(n.li,{children:"减少浏览器的内存占用"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"ajax",children:["Ajax",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ajax",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"xmlhttprequest",children:["XMLHttpRequest",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#xmlhttprequest",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：手写 XMLHttpRequest 不借助任何库"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这是很多奇葩的、个性的面试官经常用的手段。这种考查方式存在很多争议，但是你不能完全说它是错误的，毕竟也是考查对最基础知识的掌握情况。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'var xhr = new XMLHttpRequest()\nxhr.onreadystatechange = function () {\n    // 这里的函数异步执行，可参考之前 JS 基础中的异步模块\n    if (xhr.readyState == 4) {\n        if (xhr.status == 200) {\n            alert(xhr.responseText)\n        }\n    }\n}\nxhr.open("GET", "/api", false)\nxhr.send(null)\n'})}),"\n",(0,s.jsx)(n.p,{children:"当然，使用 jQuery、Zepto 或 Fetch 等库来写就更加简单了，这里不再赘述。"}),"\n",(0,s.jsxs)(n.h3,{id:"状态码说明",children:["状态码说明",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#状态码说明",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上述代码中，有两处状态码需要说明。",(0,s.jsx)(n.code,{children:"xhr.readyState"}),"是浏览器判断请求过程中各个阶段的，",(0,s.jsx)(n.code,{children:"xhr.status"}),"是 HTTP 协议中规定的不同结果的返回状态说明。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"xhr.readyState"}),"的状态码说明："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["0 -代理被创建，但尚未调用 ",(0,s.jsx)(n.code,{children:"open()"})," 方法。"]}),"\n",(0,s.jsxs)(n.li,{children:["1 -",(0,s.jsx)(n.code,{children:"open()"})," 方法已经被调用。"]}),"\n",(0,s.jsxs)(n.li,{children:["2 -",(0,s.jsx)(n.code,{children:"send()"})," 方法已经被调用，并且头部和状态已经可获得。"]}),"\n",(0,s.jsxs)(n.li,{children:["3 -下载中， ",(0,s.jsx)(n.code,{children:"responseText"})," 属性已经包含部分数据。"]}),"\n",(0,s.jsx)(n.li,{children:"4 -下载操作已完成"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：HTTP 协议中，response 的状态码，常见的有哪些？"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"xhr.status"}),"即 HTTP 状态码，有 ",(0,s.jsx)(n.code,{children:"2xx"})," ",(0,s.jsx)(n.code,{children:"3xx"})," ",(0,s.jsx)(n.code,{children:"4xx"})," ",(0,s.jsx)(n.code,{children:"5xx"})," 这几种，比较常用的有以下几种："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"200"})," 正常"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"3xx"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"301"})," 永久重定向。如",(0,s.jsx)(n.code,{children:"http://xxx.com"}),"这个 GET 请求（最后没有",(0,s.jsx)(n.code,{children:"/"}),"），就会被",(0,s.jsx)(n.code,{children:"301"}),"到",(0,s.jsx)(n.code,{children:"http://xxx.com/"}),"（最后是",(0,s.jsx)(n.code,{children:"/"}),"）"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"302"})," 临时重定向。临时的，不是永久的"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"304"})," 资源找到但是不符合请求条件，不会返回任何主体。如发送 GET 请求时，head 中有",(0,s.jsx)(n.code,{children:"If-Modified-Since: xxx"}),"（要求返回更新时间是",(0,s.jsx)(n.code,{children:"xxx"}),"时间之后的资源），如果此时服务器 端资源未更新，则会返回",(0,s.jsx)(n.code,{children:"304"}),"，即不符合要求"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"404"})," 找不到资源"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"5xx"})," 服务器端出错了"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["看完要明白，为何上述代码中要同时满足",(0,s.jsx)(n.code,{children:"xhr.readyState == 4"}),"和",(0,s.jsx)(n.code,{children:"xhr.status == 200"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"fetch-api",children:["Fetch API",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#fetch-api",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["目前已经有一个获取 HTTP 请求更加方便的 API：",(0,s.jsx)(n.code,{children:"Fetch"}),"，通过",(0,s.jsx)(n.code,{children:"Fetch"}),"提供的",(0,s.jsx)(n.code,{children:"fetch()"}),"这个全局函数方法可以很简单地发起异步请求，并且支持",(0,s.jsx)(n.code,{children:"Promise"}),"的回调。但是 Fetch API 是比较新的 API，具体使用的时候还需要查查 ",(0,s.jsx)(n.a,{href:"https://caniuse.com/",target:"_blank",rel:"noopener noreferrer",children:"caniuse"}),"，看下其浏览器兼容情况。"]}),"\n",(0,s.jsx)(n.p,{children:"看一个简单的例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"fetch('some/api/data.json', {\n  method:'POST', //请求类型 GET、POST\n  headers:{}, // 请求的头信息，形式为 Headers 对象或 ByteString\n  body:{}, //请求发送的数据 blob、BufferSource、FormData、URLSearchParams（get 或head 方法中不能包含 body）\n  mode:'', //请求的模式，是否跨域等，如 cors、 no-cors 或 same-origin\n  credentials:'', //cookie 的跨域策略，如 omit、same-origin 或 include\n  cache:'', //请求的 cache 模式: default、no-store、reload、no-cache、 force-cache 或 only-if-cached\n}).then(function(response) { ... });\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Fetch"})," 支持",(0,s.jsx)(n.code,{children:"headers"}),"定义，通过",(0,s.jsx)(n.code,{children:"headers"}),"自定义可以方便地实现多种请求方法（ PUT、GET、POST 等）、请求头（包括跨域）和",(0,s.jsx)(n.code,{children:"cache"}),"策略等；除此之外还支持 response（返回数据）多种类型，比如支持二进制文件、字符串和",(0,s.jsx)(n.code,{children:"formData"}),"等。"]}),"\n",(0,s.jsxs)(n.h3,{id:"跨域",children:["跨域",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#跨域",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：如何实现跨域？"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["浏览器中有 ",(0,s.jsx)(n.strong,{children:"同源策略"})," ，即一个域下的页面中，无法通过 Ajax 获取到其他域的接口。例如有一个接口",(0,s.jsx)(n.code,{children:"http://m.juejin.com/course/ajaxcourserecom?cid=459"}),"，你自己的一个页面",(0,s.jsx)(n.code,{children:"http://www.yourname.com/page1.html"}),"中的 Ajax 无法获取这个接口。这正是命中了“同源策略”。如果浏览器哪些地方忽略了同源策略，那就是浏览器的安全漏洞，需要紧急修复。"]}),"\n",(0,s.jsx)(n.p,{children:"url 哪些地方不同算作跨域？"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"协议"}),"\n",(0,s.jsx)(n.li,{children:"域名"}),"\n",(0,s.jsx)(n.li,{children:"端口"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["但是 HTML 中几个标签能逃避过同源策略——",(0,s.jsx)(n.code,{children:'<script src="xxx">'}),"、",(0,s.jsx)(n.code,{children:'<img src="xxxx"/>'}),"、",(0,s.jsx)(n.code,{children:'<link href="xxxx">'}),"，这三个标签的",(0,s.jsx)(n.code,{children:"src/href"}),"可以加载其他域的资源，不受同源策略限制。"]}),"\n",(0,s.jsx)(n.p,{children:"因此，这使得这三个标签可以做一些特殊的事情。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<img>"}),"可以做打点统计，因为统计方并不一定是同域的，在讲解 JS 基础知识异步的时候有过代码示例。除了能跨域之外，",(0,s.jsx)(n.code,{children:"<img>"}),"几乎没有浏览器兼容问题，它是一个非常古老的标签。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"<script>"}),"和",(0,s.jsx)(n.code,{children:"<link>"}),"可以使用 CDN，CDN 基本都是其他域的链接。"]}),"\n",(0,s.jsxs)(n.li,{children:["另外",(0,s.jsx)(n.code,{children:"<script>"}),"还可以实现 JSONP，能获取其他域接口的信息，接下来马上讲解。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"但是请注意，所有的跨域请求方式，最终都需要信息提供方来做出相应的支持和改动，也就是要经过信息提供方的同意才行，否则接收方是无法得到它们的信息的，浏览器是不允许的。"}),"\n",(0,s.jsxs)(n.h3,{id:"解决跨域---jsonp",children:["解决跨域 - JSONP",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解决跨域---jsonp",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先，有一个概念你要明白，例如访问",(0,s.jsx)(n.code,{children:"http://coding.m.juejin.com/classindex.html"}),"的时候，服务器端就一定有一个",(0,s.jsx)(n.code,{children:"classindex.html"}),"文件吗？—— 不一定，服务器可以拿到这个请求，动态生成一个文件，然后返回。\n同理，",(0,s.jsx)(n.code,{children:'<script src="http://coding.m.juejin.com/api.js">'}),"也不一定加载一个服务器端的静态文件，服务器也可以动态生成文件并返回。OK，接下来正式开始。"]}),"\n",(0,s.jsx)(n.p,{children:"例如我们的网站和掘金网，肯定不是一个域。我们需要掘金网提供一个接口，供我们来获取。首先，我们在自己的页面这样定义"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<script>\nwindow.callback = function (data) {\n    // 这是我们跨域得到信息\n    console.log(data)\n}\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后掘金网给我提供了一个",(0,s.jsx)(n.code,{children:"http://coding.m.juejin.com/api.js"}),"，内容如下（之前说过，服务器可动态生成内容）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"callback({x:100, y:200})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最后我们在页面中加入",(0,s.jsx)(n.code,{children:'<script src="http://coding.m.juejin.com/api.js"><\/script>'}),"，那么这个js加载之后，就会执行内容，我们就得到内容了。"]}),"\n",(0,s.jsxs)(n.h3,{id:"解决跨域---服务器端设置-http-header",children:["解决跨域 - 服务器端设置 http header",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解决跨域---服务器端设置-http-header",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这是需要在服务器端设置的，作为前端工程师我们不用详细掌握，但是要知道有这么个解决方案。而且，现在推崇的跨域解决方案是这一种，比 JSONP 简单许多。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'response.setHeader("Access-Control-Allow-Origin", "http://m.juejin.com/");  // 第二个参数填写允许跨域的域名称，不建议直接写 "*"\nresponse.setHeader("Access-Control-Allow-Headers", "X-Requested-With");\nresponse.setHeader("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");\n\n// 接收跨域的cookie\nresponse.setHeader("Access-Control-Allow-Credentials", "true");\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"存储",children:["存储",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#存储",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"题目：cookie 和 localStorage 有何区别？"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"cookie",children:["cookie",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#cookie",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"cookie 本身不是用来做服务器端存储的（计算机领域有很多这种“狗拿耗子”的例子，例如 CSS 中的 float），它是设计用来在服务器和客户端进行信息传递的，因此我们的每个 HTTP 请求都带着 cookie。但是 cookie 也具备浏览器端存储的能力（例如记住用户名和密码），因此就被开发者用上了。"}),"\n",(0,s.jsxs)(n.p,{children:["使用起来也非常简单，",(0,s.jsx)(n.code,{children:"document.cookie = ...."}),"即可。"]}),"\n",(0,s.jsx)(n.p,{children:"但是 cookie 有它致命的缺点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"存储量太小，只有 4KB"}),"\n",(0,s.jsx)(n.li,{children:"所有 HTTP 请求都带着，会影响获取资源的效率"}),"\n",(0,s.jsx)(n.li,{children:"API 简单，需要封装才能用"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"localstorage-和-sessionstorage",children:["localStorage 和 sessionStorage",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#localstorage-和-sessionstorage",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["后来，HTML5 标准就带来了",(0,s.jsx)(n.code,{children:"sessionStorage"}),"和",(0,s.jsx)(n.code,{children:"localStorage"}),"，先拿",(0,s.jsx)(n.code,{children:"localStorage"}),"来说，它是专门为了浏览器端缓存而设计的。其优点有："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"存储量增大到 5MB"}),"\n",(0,s.jsx)(n.li,{children:"不会带到 HTTP 请求中"}),"\n",(0,s.jsxs)(n.li,{children:["API 适用于数据存储 ",(0,s.jsx)(n.code,{children:"localStorage.setItem(key, value)"})," ",(0,s.jsx)(n.code,{children:"localStorage.getItem(key)"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"sessionStorage"}),"的区别就在于它是根据 session 过去时间而实现，而",(0,s.jsx)(n.code,{children:"localStorage"}),"会永久有效，应用场景不同。例如，一些需要及时失效的重要信息放在",(0,s.jsx)(n.code,{children:"sessionStorage"}),"中，一些不重要但是不经常设置的信息，放在",(0,s.jsx)(n.code,{children:"localStorage"}),"中。"]}),"\n",(0,s.jsxs)(n.p,{children:["另外告诉大家一个小技巧，针对",(0,s.jsx)(n.code,{children:"localStorage.setItem"}),"，使用时尽量加入到",(0,s.jsx)(n.code,{children:"try-catch"}),"中，某些浏览器是禁用这个 API 的，要注意。"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本小节总结了 W3C 标准中 Web-API 部分，面试中常考的知识点，这些也是日常开发中最常用的 API 和知识。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let h=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Web%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E8%A7%A3%E6%9E%90%2F3.%E4%B8%80%E9%9D%A2%202%EF%BC%9AJS-Web-API%20%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E8%A7%A3%E6%9E%90.md"]={toc:[{text:"知识点梳理",id:"知识点梳理",depth:2},{text:"BOM",id:"bom",depth:2},{text:"DOM",id:"dom",depth:2},{text:"什么是 DOM",id:"什么是-dom",depth:3},{text:"获取 DOM 节点",id:"获取-dom-节点",depth:3},{text:"property",id:"property",depth:3},{text:"attribute",id:"attribute",depth:3},{text:"DOM 树操作",id:"dom-树操作",depth:3},{text:"事件",id:"事件",depth:2},{text:"事件绑定",id:"事件绑定",depth:3},{text:"事件冒泡",id:"事件冒泡",depth:3},{text:"事件代理",id:"事件代理",depth:3},{text:"Ajax",id:"ajax",depth:2},{text:"XMLHttpRequest",id:"xmlhttprequest",depth:3},{text:"状态码说明",id:"状态码说明",depth:3},{text:"Fetch API",id:"fetch-api",depth:3},{text:"跨域",id:"跨域",depth:3},{text:"解决跨域 - JSONP",id:"解决跨域---jsonp",depth:3},{text:"解决跨域 - 服务器端设置 http header",id:"解决跨域---服务器端设置-http-header",depth:3},{text:"存储",id:"存储",depth:2},{text:"cookie",id:"cookie",depth:3},{text:"localStorage 和 sessionStorage",id:"localstorage-和-sessionstorage",depth:3},{text:"小结",id:"小结",depth:2}],title:"3.一面 2：JS-Web-API 知识点与高频考题解析",headingTitle:"3.一面 2：JS-Web-API 知识点与高频考题解析",frontmatter:{}}}}]);