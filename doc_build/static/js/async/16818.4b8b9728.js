"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16818"],{56048:function(e,n,s){e.exports=s.p+"static/image/4958ece2e6bc530aa2704e42fb88e7a9.cba871e4.webp"},718933:function(e,n,s){e.exports=s.p+"static/image/57ce4b7f13efbd0b8cc5d327904b8cce.00a5def0.webp"},203467:function(e,n,s){e.exports=s.p+"static/image/5b6a57681ee9afd16635938dd4e319a2.82328c9a.webp"},251310:function(e,n,s){e.exports=s.p+"static/image/6bdaae3d4b4b6b41fd91efaecb5a80bb.17725e55.webp"},244786:function(e,n,s){e.exports=s.p+"static/image/9677b87e2c211441d6898214d21dbb28.4c5b9ae5.webp"},278304:function(e,n,s){e.exports=s.p+"static/image/98a28acb87033db90649b8417ad6cf4d.a46ac950.webp"},974693:function(e,n,s){e.exports=s.p+"static/image/b5f8de994372595b9b90fff8d7f41015.6ab2cfed.webp"},271451:function(e,n,s){e.exports=s.p+"static/image/b9257a88e040516d132ea7363f236ca2.28952446.webp"},816418:function(e,n,s){e.exports=s.p+"static/image/e3091817945c80839e583fbff66b39a4.e70a890e.webp"},888227:function(e,n,s){s.r(n),s.d(n,{default:()=>H});var r=s(552676),a=s(740453);let t=s.p+"static/image/ca3ec73ccdfd01b4b0d942abf30aed3a.db9edf95.webp",i=s.p+"static/image/154577cb8b297360c2094f117634eb8e.2503f7b2.webp",c=s.p+"static/image/e97d88d6bc987ea075e7b3b07baa433e.7728fe86.webp",d=s.p+"static/image/0844e0e42136cdbb9ebb6d3bde62d182.0b5fa2da.webp",o=s.p+"static/image/8c895819df8a6e3de1d408cb48bfa80a.c7796f65.webp",p=s.p+"static/image/e493003b728c0cc2293cd9b03b9ed42e.31d784ac.webp",l=s.p+"static/image/0876cdfb33ad3745ea3108b774a9ea00.b3d787aa.webp",h=s.p+"static/image/4ce638061ec977543c80fec1edc58bbb.f1e284d1.webp",j=s.p+"static/image/bb3c136ed238605a45e449a978c75192.377566df.webp",x=s.p+"static/image/09cda11b112eb0bc05748c8e5249949a.cf80b0dd.webp",u=s.p+"static/image/369f1d7588e20afc4e5c0861d3236736.b1d936fa.webp",g=s.p+"static/image/34ded4f2fd1d3dd04097d763f406a009.c87e4b3c.webp";var m=s(251310),b=s(718933);let f=s.p+"static/image/8dbc7384e364f2a2364f989bf126621c.b5a4f877.webp",w=s.p+"static/image/0fc25df6825b79b407dde83bfc1f27b1.9f2ae231.webp",v=s.p+"static/image/bee2926b9899207fea8e6a51e647d640.539699f9.webp",U=s.p+"static/image/2a35f2f686d2b3ea771119f7dc0929e9.5beda98f.webp",E=s.p+"static/image/265488a09cafb005f4591535c98e83e8.6b02cba5.webp",S=s.p+"static/image/4f91d3dd926a5d355315ca9f9a56fa78.7b6311dd.webp",q=s.p+"static/image/302972115484c182070d215aa4bccef0.fa7c9cb7.webp",I=s.p+"static/image/cef16eb597da894010e2d82a4a9089c9.4195e4be.webp",A=s.p+"static/image/6b84a2dfde9d65f5724d7c57b849af65.452fd9bc.webp",k=s.p+"static/image/bb31664910e7928d871d20b47a94e712.bee28659.webp";var D=s(56048);let _=s.p+"static/image/1c39757a465bb8d12528603a8461d41c.6f1fe7d8.webp",R=s.p+"static/image/d5d864e37b4caff3844fe66c22ac3702.5989bc0d.webp",y=s.p+"static/image/d94f5171547917439a54664427922b6b.250bddf4.webp",N=s.p+"static/image/03fd9b555678cfc1ba63ba4d569f81ca.dbabfa50.webp";var B=s(974693),P=s(816418),C=s(278304),L=s(271451),z=s(244786),G=s(203467);function M(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"159-考试系统用户登录修改密码",children:["159. 考试系统：用户登录、修改密码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#159-考试系统用户登录修改密码",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节我们实现下登录、修改密码。"}),"\n",(0,r.jsx)(n.p,{children:"在 UserController 添加一个 login 的路由："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Post('login')\nasync userLogin(@Body() loginUser: LoginUserDto) {\n    console.log(loginUser);\n    return 'success';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"创建 src/dto/login-user.dto.ts："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { IsNotEmpty } from "class-validator";\n\nexport class LoginUserDto {\n\n    @IsNotEmpty({\n        message: "用户名不能为空"\n    })\n    username: string;\n    \n    @IsNotEmpty({\n        message: \'密码不能为空\'\n    })\n    password: string;    \n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:G,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:z,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"服务端打印了接收的参数。"}),"\n",(0,r.jsx)(n.p,{children:"ValidationPipe 开启 transform: true"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:L,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"再次访问："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样会把参数转为 dto 的实例。"}),"\n",(0,r.jsx)(n.p,{children:"然后在 UserService 实现 login 方法："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async login(loginUserDto: LoginUserDto) {\n  const foundUser = await this.prismaService.user.findUnique({\n    where: {\n      username: loginUserDto.username\n    }\n  });\n\n  if(!foundUser) {\n      throw new HttpException('用户不存在', HttpStatus.BAD_REQUEST);\n  }\n\n  if(foundUser.password !== loginUserDto.password) {\n      throw new HttpException('密码错误', HttpStatus.BAD_REQUEST);\n  }\n\n  delete foundUser.password;\n  return foundUser;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"为了开发方便，我们注册的时候没有对密码做加密，登录的时候也就不用加密了。"}),"\n",(0,r.jsx)(n.p,{children:"在 UserController 里调用下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Post('login')\nasync userLogin(@Body() loginUser: LoginUserDto) {\n    const user = await this.userService.login(loginUser);\n\n    return user;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:"当用户名不存在时："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["当密码错误时：\n",(0,r.jsx)("img",{src:B,alt:""})]}),"\n",(0,r.jsx)(n.p,{children:"登录成功："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"登录成功之后我们要返回 jwt。"}),"\n",(0,r.jsx)(n.p,{children:"引入下 jwt 的包："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save @nestjs/jwt\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 UserModule 里引入："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"JwtModule.registerAsync({\n  global: true,\n  useFactory() {\n    return {\n      secret: 'guang',\n      signOptions: {\n        expiresIn: '30m' // 默认 30 分钟\n      }\n    }\n  }\n}),\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后登录成功之后返回 token："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Inject(JwtService)\nprivate jwtService: JwtService;\n\n@Post('login')\nasync userLogin(@Body() loginUser: LoginUserDto) {\n    const user = await this.userService.login(loginUser);\n\n    return {\n      user,\n      token: this.jwtService.sign({\n        userId: user.id,\n        username: user.username\n      }, {\n        expiresIn: '7d'\n      })\n    };\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"token 过期时间是 7 天。"}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们这里就不用双 token 的方式来刷新了，而是用单 token 无限续期来做。"}),"\n",(0,r.jsx)(n.p,{children:"也就是当访问接口的时候，就返回一个新的 token。"}),"\n",(0,r.jsx)(n.p,{children:"这样只要它在 token 过期之前，也就是 7 天内访问了一次系统，那就会刷新换成新 token。"}),"\n",(0,r.jsx)(n.p,{children:"超过 7 天没访问，那就需要重新登录了。"}),"\n",(0,r.jsx)(n.p,{children:"然后我们加上 AuthGuard 来做登录鉴权："}),"\n",(0,r.jsx)(n.p,{children:"创建一个 common 的 lib："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g lib common\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:_,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"进入 common 目录，生成 Guard："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g guard auth --flat --no-spec\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"AuthGuard 的实现代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { JwtService } from '@nestjs/jwt';\nimport { Request } from 'express';\nimport { Observable } from 'rxjs';\n\ninterface JwtUserData {\n  userId: number;\n  username: string;\n}\n\ndeclare module 'express' {\n  interface Request {\n    user: JwtUserData\n  }\n}\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  \n  @Inject()\n  private reflector: Reflector;\n\n  @Inject(JwtService)\n  private jwtService: JwtService;\n  \n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    const request: Request = context.switchToHttp().getRequest();\n    \n    const requireLogin = this.reflector.getAllAndOverride('require-login', [\n      context.getClass(),\n      context.getHandler()\n    ]);\n\n    if(!requireLogin) {\n      return true;\n    }\n\n    const authorization = request.headers.authorization;\n\n    if(!authorization) {\n      throw new UnauthorizedException('用户未登录');\n    }\n\n    try{\n      const token = authorization.split(' ')[1];\n      const data = this.jwtService.verify<JwtUserData>(token);\n\n      request.user = {\n        userId: data.userId,\n        username: data.username,\n      }\n      return true;\n    } catch(e) {\n      throw new UnauthorizedException('token 失效，请重新登录');\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"用 reflector 从目标 controller 和 handler 上拿到 require-login 的 metadata。"}),"\n",(0,r.jsx)(n.p,{children:"如果没有 metadata，就是不需要登录，返回 true 放行。"}),"\n",(0,r.jsx)(n.p,{children:"否则从 authorization 的 header 取出 jwt 来，把用户信息设置到 request，然后放行。"}),"\n",(0,r.jsx)(n.p,{children:"如果 jwt 无效，返回 401 响应，提示 token 失效，请重新登录。"}),"\n",(0,r.jsx)(n.p,{children:"导出下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"然后全局启用这个 Guard，在 UserModule 里添加这个 provider："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{\n  provide: APP_GUARD,\n  useClass: AuthGuard\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 UserController 添加 aaa、bbb 两个接口："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Get('aaa')\naaa() {\n    return 'aaa';\n}\n\n@Get('bbb')\nbbb() {\n    return 'bbb';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"访问下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:I,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:q,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"然后在 aaa 加上 require-login 的 matadata"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Get('aaa')\n@SetMetadata('require-login', true)\naaa() {\n    return 'aaa';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"会提示用户未登录："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"而 bbb 还是可以直接访问的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"登录下，拿到 token："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:U,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"添加到 authorization 的 header 里，就可以访问了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"我们把这个 @SetMetadata 封装成自定义装饰器"}),"\n",(0,r.jsx)(n.p,{children:"放在 libs/common 下"}),"\n",(0,r.jsx)(n.p,{children:"新建 src/custom.decorator.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { SetMetadata } from \"@nestjs/common\";\n\nexport const  RequireLogin = () => SetMetadata('require-login', true);\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:w,alt:"image.png"}),"\n然后就可以通过在 controller 或者 handler 上的 @RequiredLogin 来声明接口需要登录了："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"再实现个自定义参数装饰器来取 request.user"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { SetMetadata } from \"@nestjs/common\";\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\nimport { Request } from \"express\";\n\nexport const  RequireLogin = () => SetMetadata('require-login', true);\n\nexport const UserInfo = createParamDecorator(\n  (data: string, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest<Request>();\n\n    if(!request.user) {\n        return null;\n    }\n    return data ? request.user[data] : request.user;\n  },\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 aaa 方法里测试下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Get('aaa')\n@RequireLogin()\n// @SetMetadata('require-login', true)\naaa(@UserInfo() userInfo, @UserInfo('username') username) {\n    console.log(userInfo, username);\n    return 'aaa';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样，就完成了登录和鉴权。"}),"\n",(0,r.jsx)(n.p,{children:"还有 token 自动续期没有做，这个就是访问接口之后，在 header 或者 body 里额外返回新 token。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { JwtService } from '@nestjs/jwt';\nimport { Request, Response } from 'express';\nimport { Observable } from 'rxjs';\n\ninterface JwtUserData {\n  userId: number;\n  username: string;\n}\n\ndeclare module 'express' {\n  interface Request {\n    user: JwtUserData\n  }\n}\n\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  \n  @Inject()\n  private reflector: Reflector;\n\n  @Inject(JwtService)\n  private jwtService: JwtService;\n  \n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    const request: Request = context.switchToHttp().getRequest();\n    const response: Response = context.switchToHttp().getResponse();\n\n    const requireLogin = this.reflector.getAllAndOverride('require-login', [\n      context.getClass(),\n      context.getHandler()\n    ]);\n\n    if(!requireLogin) {\n      return true;\n    }\n\n    const authorization = request.headers.authorization;\n\n    if(!authorization) {\n      throw new UnauthorizedException('用户未登录');\n    }\n\n    try{\n      const token = authorization.split(' ')[1];\n      const data = this.jwtService.verify<JwtUserData>(token);\n\n      request.user = {\n        userId: data.userId,\n        username: data.username,\n      }\n\n      response.header('token', this.jwtService.sign({\n        userId: data.userId,\n        username: data.username\n      }, {\n        expiresIn: '7d'\n      }))\n\n      return true;\n    } catch(e) {\n      console.log(e);\n      throw new UnauthorizedException('token 失效，请重新登录');\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"再访问下 aaa 接口："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"可以看到返回了新 token。"}),"\n",(0,r.jsx)(n.p,{children:"这样只要访问需要登录的接口，就会刷新 token。"}),"\n",(0,r.jsx)(n.p,{children:"比双token 的方案简单多了，很多公司就是这样做的。"}),"\n",(0,r.jsx)(n.p,{children:"然后实现修改密码的接口："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Post('update_password')\nasync updatePassword(@Body() passwordDto: UpdateUserPasswordDto) {\n  console.log(passwordDto);\n  return 'success';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"创建 src/dto/update-user-password.dto.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { IsEmail, IsNotEmpty, MinLength } from \"class-validator\";\n\nexport class UpdateUserPasswordDto {    \n    @IsNotEmpty({\n        message: '密码不能为空'\n    })\n    @MinLength(6, {\n        message: '密码不能少于 6 位'\n    })\n    password: string;\n    \n    @IsNotEmpty({\n        message: '邮箱不能为空'\n    })\n    @IsEmail({}, {\n        message: '不是合法的邮箱格式'\n    })\n    email: string;\n    \n    @IsNotEmpty({\n        message: '用户名不能为空'\n    })\n    username: string;\n    \n    @IsNotEmpty({\n        message: '验证码不能为空'\n    })\n    captcha: string;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"需要传的是用户名、邮箱、密码、验证码。"}),"\n",(0,r.jsx)(n.p,{children:"确认密码在前端和密码对比就行，不需要传到后端。"}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:x,alt:"image.png"}),"\n然后实现下具体的更新密码的逻辑："]}),"\n",(0,r.jsx)(n.p,{children:"在 UserController 里调用 UserService 的方法："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Post('update_password')\nasync updatePassword(@Body() passwordDto: UpdateUserPasswordDto) {\n    return this.userService.updatePassword(passwordDto);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"UserService 实现具体的逻辑："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async updatePassword(passwordDto: UpdateUserPasswordDto) {\n  const captcha = await this.redisService.get(`update_password_captcha_${passwordDto.email}`);\n\n  if(!captcha) {\n      throw new HttpException('验证码已失效', HttpStatus.BAD_REQUEST);\n  }\n\n  if(passwordDto.captcha !== captcha) {\n      throw new HttpException('验证码不正确', HttpStatus.BAD_REQUEST);\n  }\n\n  const foundUser = await this.prismaService.user.findUnique({\n    where: {\n        username: passwordDto.username\n    }\n  });\n\n  foundUser.password = passwordDto.password;\n\n  try {\n    await this.prismaService.user.update({\n      where: {\n        id: foundUser.id\n      },\n      data: foundUser\n    });\n    return '密码修改成功';\n  } catch(e) {\n    this.logger.error(e, UserService);\n    return '密码修改失败';\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"先查询 redis 中相对应的验证码，检查通过之后根据 email 查询用户信息，修改密码之后 save。"}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"在 redis 里手动添加 update_password_captcha_邮箱 的 key，值为 111111"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"半小时过期。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"然后再试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"修改成功。"}),"\n",(0,r.jsx)(n.p,{children:"我们为了开发方便没对密码做加密，可以直观看出来密码修改成功了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"然后再加上发送邮箱验证码的接口："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Get('update_password/captcha')\nasync updatePasswordCaptcha(@Query('address') address: string) {\n    if(!address) {\n      throw new BadRequestException('邮箱地址不能为空');\n    }\n    const code = Math.random().toString().slice(2,8);\n\n    await this.redisService.set(`update_password_captcha_${address}`, code, 10 * 60);\n\n    await this.emailService.sendMail({\n      to: address,\n      subject: '更改密码验证码',\n      html: `<p>你的更改密码验证码是 ${code}</p>`\n    });\n    return '发送成功';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"用这个验证码修改下密码："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"修改成功。"}),"\n",(0,r.jsxs)(n.p,{children:["代码在",(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/exam-system",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节我们实现了登录、鉴权、修改密码。"}),"\n",(0,r.jsx)(n.p,{children:"添加了 /user/login 接口来实现登录，登录后返回 jwt token。"}),"\n",(0,r.jsx)(n.p,{children:"实现了 /user/update_password 用于修改密码，/user/update_password/captcha 用于发送验证码。"}),"\n",(0,r.jsx)(n.p,{children:"访问的时候在 Authorization 的 header 带上 jwt 的 token 就能通过 AuthGuard 的鉴权。"}),"\n",(0,r.jsx)(n.p,{children:"我们做了 token 的自动续期，也就是访问接口后在 header 返回新 token，这样比双 token 的方案简单。"}),"\n",(0,r.jsx)(n.p,{children:"然后封装了 @RequireLogin 和 @UserInfo 两个自定义装饰器。"}),"\n",(0,r.jsx)(n.p,{children:"登录之后，就可以访问一些需要 user 信息的接口了。"}),"\n",(0,r.jsx)(n.p,{children:"至此，用户微服务的三个接口就开发完了。"})]})}function J(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(M,{...e})}):M(e)}let H=J;J.__RSPRESS_PAGE_META={},J.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F159.%20%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F%EF%BC%9A%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"159. 考试系统：用户登录、修改密码",headingTitle:"159. 考试系统：用户登录、修改密码",frontmatter:{}}}}]);