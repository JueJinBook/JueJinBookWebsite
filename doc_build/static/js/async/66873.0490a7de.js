"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["66873"],{118419:function(n,e,c){c.r(e),c.d(e,{default:()=>u});var l=c(552676),s=c(740453);let r=c.p+"static/image/b4aef0ce89a6f12e2a78a9d7aa046eb1.5cd88a43.webp",i=c.p+"static/image/ea080474a192d16b58cdc97f11a2a8d0.38756d1a.webp",a=c.p+"static/image/8a79d7f1b52b0893965d3734d36628cd.9191b2b5.webp",d=c.p+"static/image/2ae8e8b4073bcac4c88dbfaa799c5940.dcb40759.webp",t=c.p+"static/image/138ae7d84879a7ad4361f7cdda4ea21f.d1a80dce.webp",h=c.p+"static/image/e98ec64d2049647d1bd3fa05ce8dd8d4.6faa6484.webp";function o(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",h3:"h3",strong:"strong",code:"code",blockquote:"blockquote",pre:"pre",img:"img"},(0,s.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.h1,{id:"36v18特性篇-concurrent-下的-state更新流程",children:["36.v18特性篇-concurrent 下的 state更新流程",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#36v18特性篇-concurrent-下的-state更新流程",children:"#"})]}),"\n",(0,l.jsxs)(e.h2,{id:"一-前言",children:["一 前言",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"之前介绍了在 legacy 模式下的 state 更新流程，这种模式下的批量更新原理本质上是通过不同的更新上下文开关 Context ，比如 batch 或者 event 来让更新变成‘可控的’。那么在 v18 conCurrent 下 React 的更新又有哪些特点呢？这就是本章节探讨的问题，本章节涵盖的知识点如下："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"concurrent 模式下的 state 更新流程是什么 ？"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"在同步异步条件下，state 更新有什么区别 ？"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"主流框架中更新处理方式。"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"二-主流框架中更新处理方式",children:["二 主流框架中更新处理方式",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二-主流框架中更新处理方式",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"在正式讲解 v18 concurrent 之前，先来看一下主流框架中两种批量更新的原理。"}),"\n",(0,l.jsxs)(e.h3,{id:"1-第一种微任务宏任务实现集中更新",children:["1 第一种：微任务｜宏任务实现集中更新",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-第一种微任务宏任务实现集中更新",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["第一种批量更新的实现，就是基于",(0,l.jsx)(e.strong,{children:"宏任务"})," 和 ",(0,l.jsx)(e.strong,{children:"微任务"})," 来实现。"]}),"\n",(0,l.jsxs)(e.p,{children:["先来描述一下这种方式，比如每次更新，我们先并不去立即执行更新任务，而是先把每一个更新任务放入一个待更新队列 ",(0,l.jsx)(e.code,{children:"updateQueue"})," 里面，然后 js 执行完毕，用一个微任务统一去批量更新队列里面的任务，如果微任务存在兼容性，那么降级成一个宏任务。这里",(0,l.jsx)(e.strong,{children:"优先采用微任务"}),"的原因就是微任务的执行时机要早于下一次宏任务的执行。"]}),"\n",(0,l.jsxs)(e.p,{children:["典型的案例就是 vue 更新原理，",(0,l.jsx)(e.code,{children:"vue.$nextTick"}),"原理 ，还有接下来要介绍的 v18 中 ",(0,l.jsx)(e.code,{children:"scheduleMicrotask"})," 的更新原理。"]}),"\n",(0,l.jsx)(e.p,{children:"以 vue 为例子我们看一下 nextTick 的实现："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"runtime-core/src/scheduler.ts"}),"\n"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"const p = Promise.resolve() \n/* nextTick 实现，用微任务实现的 */\nexport function nextTick(fn?: () => void): Promise<void> {\n  return fn ? p.then(fn) : p\n}\n"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["可以看到 nextTick 原理，本质就是 ",(0,l.jsx)(e.code,{children:"Promise.resolve()"})," 创建的微任务。"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"大致实现流程图如下所示："}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:h,alt:"4.jpeg"})}),"\n",(0,l.jsx)(e.p,{children:"我们也可以来模拟一下整个流程的实现。"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"class Scheduler {\n    constructor(){\n        this.callbacks = []\n        /* 微任务批量处理 */\n        queueMicrotask(()=>{\n            this.runTask()\n        })\n    }\n    /* 增加任务 */\n    addTask(fn){\n        this.callbacks.push(fn)\n    }\n    runTask(){\n        console.log('------合并更新开始------')\n        while(this.callbacks.length > 0){\n            const cur = this.callbacks.shift()\n            cur()\n        }\n        console.log('------合并更新结束------')\n        console.log('------开始更新组件------')\n    }\n}\nfunction nextTick(cb){\n    const scheduler = new Scheduler()\n    cb(scheduler.addTask.bind(scheduler))\n}\n\n/* 模拟一次更新 */\nfunction mockOnclick(){\n   nextTick((add)=>{\n       add(function(){\n           console.log('第一次更新')\n       })\n       console.log('----宏任务逻辑----')\n       add(function(){\n        console.log('第二次更新')\n       })\n   })\n}\n\nmockOnclick()\n"})}),"\n",(0,l.jsx)(e.p,{children:"我们来模拟一下具体实现细节："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"通过一个 Scheduler 调度器来完成整个流程。"}),"\n",(0,l.jsx)(e.li,{children:"通过 addTask 每次向队列中放入任务。"}),"\n",(0,l.jsx)(e.li,{children:"用 queueMicrotask 创建一个微任务，来统一处理这些任务。"}),"\n",(0,l.jsx)(e.li,{children:"mockOnclick 模拟一次更新。我们用 nextTick 来模拟一下更新函数的处理逻辑。"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"看一下打印效果："}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:t,alt:"3.jpeg"})}),"\n",(0,l.jsxs)(e.h3,{id:"2-第二种可控任务实现批量更新",children:["2 第二种：可控任务实现批量更新",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-第二种可控任务实现批量更新",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["还有一种方式，通过拦截把任务变成",(0,l.jsx)(e.strong,{children:"可控的"}),"，典型的就是 React v17 之前的 batchEventUpdate 批量更新，这个方式接下来会讲到，这里也不赘述了。这种情况的更新来源于对事件进行拦截，比如 React 的事件系统。"]}),"\n",(0,l.jsx)(e.p,{children:"以 React 的事件批量更新为例子，比如我们的 onClick ，onChange 事件都是被 React 的事件系统处理的。外层用一个统一的处理函数进行拦截。而我们绑定的事件都是在该函数的执行上下文内部被调用的。"}),"\n",(0,l.jsx)(e.p,{children:"那么比如在一次点击事件中触发了多次更新。本质上外层在 React 事件系统处理函数的上下文中，这样的情况下，就可以通过一个开关，证明当前更新是可控的，可以做批量处理。接下来 React 就用一次就可以了。"}),"\n",(0,l.jsx)(e.p,{children:"我们用一幅流程图来描述一下原理。"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:d,alt:"5.jpeg"})}),"\n",(0,l.jsx)(e.p,{children:"接下来我们模拟一下具体的实现："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-html",children:"<body>  \n    <button onclick=\"handleClick()\" >点击</button>\n</body>\n<script>\n  let  batchEventUpdate = false \n  let callbackQueue = []\n\n  function flushSyncCallbackQueue(){\n      console.log('-----执行批量更新-------')\n      while(callbackQueue.length > 0 ){\n          const cur = callbackQueue.shift()\n          cur()\n      }\n      console.log('-----批量更新结束-------')\n  }\n\n  function wrapEvent(fn){\n     return function (){\n         /* 开启批量更新状态 */\n        batchEventUpdate = true\n        fn()\n        /* 立即执行更新任务 */\n        flushSyncCallbackQueue()\n        /* 关闭批量更新状态 */\n        batchEventUpdate = false\n     }\n  }\n\n  function setState(fn){\n      /* 如果在批量更新状态下，那么批量更新 */\n      if(batchEventUpdate){\n          callbackQueue.push(fn)\n      }else{\n          /* 如果没有在批量更新条件下，那么直接更新。 */\n          fn()\n      }\n  }\n\n  function handleClick(){\n      setState(()=>{\n          console.log('---更新1---')\n      })\n      console.log('上下文执行')\n      setState(()=>{\n          console.log('---更新2---')\n      })\n  }\n  /* 让 handleClick 变成可控的  */\n  handleClick = wrapEvent(handleClick)\n\n\n<\/script>\n"})}),"\n",(0,l.jsx)(e.p,{children:"打印结果："}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:a,alt:"6.jpg"})}),"\n",(0,l.jsx)(e.p,{children:"分析一下核心流程："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"本方式的核心就是让 handleClick 通过 wrapEvent 变成可控的。首先 wrapEvent 类似于事件处理函数，在内部通过开关 batchEventUpdate 来判断是否开启批量更新状态，最后通过 flushSyncCallbackQueue 来清空待更新队列。"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"在批量更新条件下，事件会被放入到更新队列中，非批量更新条件下，那么立即执行更新任务。"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"三-与传统-legacy-模式的区别",children:["三 与传统 legacy 模式的区别",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#三-与传统-legacy-模式的区别",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"言归正传，回到接下来要介绍的主题上来，首先对于传统的 legacy 模式，有可控任务批量处理的概念，也就是采用了上面第二种批量更新模式，原理第33章讲到主要有两个："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"通过不同的更新上下文开关，在开关里的任务是可控的，可以进行批量处理。"}),"\n",(0,l.jsxs)(e.li,{children:["在事件之行完毕后，通过 ",(0,l.jsx)(e.code,{children:"flushSyncCallback"})," 来进行更新任务之行。"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"那么在 conCurrent 下的更新采用了一个什么方式呢？首先在这种模式下，取消了批量更新的感念。我们以事件系统的更新例子，研究一下两种的区别。"}),"\n",(0,l.jsx)(e.p,{children:"在老版本事件系统中："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"react-dom/src/events/ReactDOMUpdateBatching.js"}),"\n"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"export function batchedEventUpdates(fn,a){\n    isBatchingEventUpdates = true; //打开批量更新开关\n    try{\n       fn(a)  // 事件在这里执行\n    }finally{\n        isBatchingEventUpdates = false //关闭批量更新开关\n        if (executionContext === NoContext) {\n            flushSyncCallbackQueue(); // TODO: 这个很重要，用来同步执行更新队列中的任务\n        }\n    }\n}\n"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"通过开关 isBatchingEventUpdates 来让 fn 里面的更新变成可控的，所以可以进行批量更新。"}),"\n",(0,l.jsx)(e.li,{children:"重点就是 flushSyncCallbackQueue 用来同步执行更新队列中的任务。"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"在最新版本的 v18 alpha 系统中，事件变成了这样 （这个代码和代码仓库的有一些出入，我们这里只关心流程就好）："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function batchedEventUpdates(){\n    var prevExecutionContext = executionContext;\n    executionContext |= EventContext;  // 运算赋值\n    try {\n        return fn(a);  // 执行函数\n    }finally {\n        executionContext = prevExecutionContext; // 重置之前的状态\n        if (executionContext === NoContext) {\n            flushSyncCallbacksOnlyInLegacyMode() // 同步执行更新队列中的任务\n        }\n    }\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"从上述代码中可以清晰的看到，v18 alpha 版本的流程大致是这样的："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["也是通过类似开关状态来控制的，在刚开始的时候将赋值给 ",(0,l.jsx)(e.code,{children:"EventContext"})," ，然后在事件执行之后，赋值给 ",(0,l.jsx)(e.code,{children:"prevExecutionContext"}),"。"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"之后同样会触发 flushSyncCallbacksOnlyInLegacyMode ，不过通过函数名称就可以大胆猜想，这个方法主要是针对 legacy 模式的更新，那么 concurrent mode 下也就不会走 flushSyncCallback 的逻辑了。"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["为了证明这个猜想，一起来看一下 ",(0,l.jsx)(e.code,{children:"flushSyncCallbacksOnlyInLegacyMode"})," 做了些什么事："]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"react-reconciler/src/ReactFiberSyncTaskQueue.js"}),"\n"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"export function flushSyncCallbacksOnlyInLegacyMode(){\n    if(includesLegacySyncCallbacks){ /* 只有在 legacy 模式下，才会走这里的流程。 */\n        flushSyncCallbacks();\n    }\n}\n"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["验证了之前的猜测，",(0,l.jsx)(e.strong,{children:"只有在 legacy 模式下，才会执行 flushSyncCallbacks 来同步执行任务。"})]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"在之前的章节讲到过 flushSyncCallbacks 主要作用是，能够在一次更新中，直接同步更新任务，防止任务在下一次的宏任务中执行。那么对于 concurrent 下的更新流程是怎么样的呢？"}),"\n",(0,l.jsxs)(e.h3,{id:"一次更新-state-会发生什么",children:["一次更新 state 会发生什么？",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一次更新-state-会发生什么",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["接下来一起研究一下一次更新 state 会发生什么？首先编写一下如下 ",(0,l.jsx)(e.code,{children:"demo"})," ："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function Index(){\n    const [ number , setNumber ] = React.useState(0)\n    /* 同步条件下 */\n    const handleClickSync = () => {\n        setNumber(1)\n        setNumber(2)\n    }\n    /* 异步条件下 */\n    const handleClick = () => {\n        setTimeout(()=>{\n            setNumber(1)\n            setNumber(2)\n        },0)\n    }\n    console.log('----组件渲染----')\n    return <div>\n         {number}\n         <button onClick={handleClickSync} >同步环境下</button>\n         <button onClick={handleClick} >异步环境下</button>\n     </div>\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"在 v17 legacy 下更新："})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["点击按钮 ",(0,l.jsx)(e.code,{children:"同步环境下"}),"，组件渲染一次。"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:"data:image/webp;base64,UklGRlwLAABXRUJQVlA4IFALAADQOgCdASo0AygAPp1InkwlpCKoI/vKOQATiWlu4WxhFzNjak/gPyS86/Hv6XgU+af0xfM/3Tzu78fgJqBetf9pvNtmfQC9nvsH+48MHUd7u/8v3AP5R/av9t63d8l5l7AX84/vfqy/23/r82f1J/5/cT/X0ZgQF6MrY2ZluoKc2s0ZguUlz+GCYHjsHgeOzMgVLo1x0Ain1x8R1vlbHPq6qcvomIT8dUOx1WRyUtl9ZXtRwe2VTAwL8EIdJu0wm4PXYRC2M6M1FTFRk1hPz7PW7ZNZ9khllA6xQoNgKn0/aBBKURy2br9XIknEmMxJeFFbYfrSqcqc+KTV3x0/SFasghKLDXhMK5PjOEsHm+AAceDcdR//jEowqvS1EfG3A4yKKdEN0VHvxDFcL3LM2IYBrf81VRn7igQqIdf5/AypzIKTQRnmuEa2RIUO5DYulUFRKx9AeBKazjankm7cZRv4xDQGQoNwMcU1ZH+Keo1kuDlfQk0PeLh4bbkuFYXpB1zBzYP7hKRGePgMmK021mgb//bgiWjdrlZcvb4ABx4Nx1IAA46FeaFaIBmaldocDNWFJLRNYVUAVnlet/H/h0ZSSvm2Q0jj4pSlEjaTZ/8bMcVA7p+e6i0SRwbN21mmQAD+/Vyot08kR/ldfbzdnKZ1lWYEOy5lhH7dxKXG38ynALEDZ4UhxLxmiF5CxLhPwHlWtwaoJflrs6gLJYG7hM3qWzyUgHYiK2i1kq7jgN+TmEGguMpmB7rQfiW8NLzbAakkineWbAR6hfL53rAAh8FEV14O+9RgnBXuucqJmKuWkhTlU9o4KQZ7ol6YB7rzibzva98G0m3/Hx92HrnZIg/zDcudcm0LzSFn/By2vVup72ok9ZNjAkZCaV2i8PPXPbD2bIFqiaXk98BTnKrsZ6/n3c7wrhiGGt8DHqf+r9c18HmiouW91tAAYF3ESoFnrK3dyGkqLU4p33wTZeqhX8q6+xWiS8ILmlGY1bF1QV9BZGsM1pe5Qy6scROG4p8D5iFl49Srj/bgdKQGsELSKwot7PZZaLXXyNBtZdvseVY1gBvA372eUuifvZlBqjPD/8uju/pdhxRKUjWU+7YY6OJU+5sjONvzrLTlVOOhGGO6aobRJQmMEnurA+vI3Nrmp8QPKdcFnYdk/KnWB0ohiT9SNHs0LXNRmqXx/aRH/N0K+aKRfMh85yt03ppbhd+wUB8aTeO5DVxTYBeBuMtOmx06mBPkWhzdeUFaT5CiJnp/69wmjT8sia43BdDV6ebhmj9lX5UnmzOESTxxFh+cfOub4c235inoHiZSpPpzl/wHKygq2/nPQmRFv+Pf/rdojwOkZDwsnmAuGZxnPFJxsyPzZCujWBBvnSUJxhqThoQPe02jRrcvNqHODcwyt9jccEzMP8iSPBwP/xT/jbQE5ntQEQ5w1KPP3PgNib4uI3tuGRZdzsDWqhNIHX/M1emZ13CMfr/iEiJOtIE+ZD8Bn21i6wXSHuP+h4LQrDWo+9m8AAsV3EUdr04zK1CARolHvkuV+24gtJ/uFyLVYo57rvZNCR8PCs9MEkJyJYXrnh6r22inFa4E7HOiv+5TS1hYlix0gZ89uF6LtYg3sRiw3Scdo4pi0T0GJYWPbhLPhB9GeCVVo/wns9MozgP5o4Ta121AJtyGS7hspIuKjjZ5cuiMXt94M2H4NlH67jtla95D1Ere/Gn3/lFJK+DUpowv8VcQxHmfzzKJwAKJJtfCkC/zb4YhsMxAMEsWnQiC72CEgEDktGiT+TDr28cSAgsJSGaj5XfVLa3eeJDyZ9jL7ux3shvFUpmohuPgCjnHvSi/XT0gfug3W3NjRyPfWDwsyw8QB35grZUNYNEisXn3OVQ2cV6hzfVwhUeAHzXtIAGgDn+t6A8FZ9atyhjZZI58MaLyTrV3H/97TtltnL9SKBFimGa2tzi9l+wKZD7YQb244nsf9hImmIfPxuUD7uIaxYMwddljiklUpVBC8A0ogd79PIuP4181rH7j/5OvsXBE2ti+5Sbfb+jjp82fYDerhjrwCWPDvdRNNimsFAfr44DyHIMNycddpU0CeEcDFFpBPAruisVPTkkv1lhm4KD0zHBeL5IvlabaFlruAgTRwVGGsCC2ImsfENS04flXSmtbWygkkKD3PVOocb6ZhTGVIlrrmEHjjF9g0QaJ4HDoz+dTIQjB3NfGzofXmNRmPJGAF3nPUEWWiJJv02svUbeijLGeIS7AgFixvxcErIUiihxK8dBp9MK6RT4CJqhWKk/tKpb0GcnRpqog42c2tkXDDDYCaTbAqjuivKxo1p/yng71xb5gn0onSjo93tZYvASDYMm6WsP2rfJj8rDR7OmoDr0ihnTCNzvJApzQ6kaB8uky7rDxFFNYqjaeDZQwBZL0r6kMNG5rXz5mfEYPWxRMAMFvUADXd+33ILuMQ1VvaVZb/3AwXbx3uT6LzKSwsGM2vdUH7xeYORIYeODSyd5ZCyQ4FNpVIjhnWoE86wvnBNqPlhFl83V9+P94jZFB4Dodt6SnzEbBYh1XenWINoHFUmWy6/Nmsedd+hnC6ggLmY+aJgBdhtx6+DV6yDCqWhp+PLeoZOnzL+2xc/62xZpb/6EJxUmrbKc9cfkEX/uNj/lwMWmXrTtQAKhLR5mhodMdMh1C+N877z/umMUR0dqx5usVKgyZtysbua7HbyMq5UdZcE/VxtKaCjETqmqrgOYgyHJ+EHeXslMYU4pqSIprH3sU6iZOsBCfMn0sBjlblRKC2TNPIvIp3G/mxgh1O3NUcNdm1YPVHA16bfFHQ53Al590n+3MVBv2Ol43SXHoLl7J4VuO1p01mGvI9nwxajOUzR4FQHJSNASq3FBXZ1rwYMnBit634nyvDIZdro2s2vGK97UOpZ0DdvphYvo1Tm3U3zKI6xmJBdw9CTKi0wRyuq8WXbfHKAbi/faX/ZniNioaJUWiter47OtPSzkYkbwR2cgZn98XxHVOKmFY5EHq17aR31ziIsQz1+cYruqthtIMv8Wo5ghz/dXO+D2sQjDkVbwxDscZ1ilE9sYWHf7P0isK9FoQdvGj/cZ4tDxiCSdjx+XX7pGMGwSOeBwmVMl7MAC+i+nLQ5uUsYE25okBOp3tz0VkiEUEIgKzHOCHJERlPoCadhis1TQVaxiaSLsjvir+Bxc4Elt8NDJ0E/pqtggFEts//klGJKD74obZh2QYmSt5f+rO5nbhvYFXIdQCO+l8EaAPEXQzSHoiwtyb07tIced82G4J0hisa5PEXwKscSbU87cMASKxGE8qqVSkvq1+DjSkBnemKC0Kit4Zrdgt6SYNf174GMkzEOf9oQP8uM1ZWm3BJBovjhVhNbVnLdYzoF89qKJFUb+d8HRYyXQLkoxRjJ9YBd7ryBNMqtyHobGl7vBdL07q7NzB8OumlDF4yrdIXOIh1xKLaGrBILTyv1KORmcH1pmP0IaJFYLYAXhG7CRbKmqdTrNvaFlXyEPzMaVqal7N8cS2fZ/OKK2sHy8CxDUxjaXRyjpjmFUtNTAly3Xr9JEcU5qalW4+Sb28XKxh46yJ0ekgitQUJCV+FFhJ6TwIoXEI7Q6yLDoOH0mHluR0MYUSKaKo/ZAdbeROfhIihVNQLg3oCyDuvrxlQATqBn/pBU30x+Pxmtcdu/+AUX6kONyJ6xVheT0khORHWWKhbfFCA/J8KA1sTW0mI4bS6hhn4YWIp8Xw48O9y/OLsaHU5/EbVAkzLPRcErHue+wqibWkES2CrwhYHoBNXIIxJE1oYPn0Cx6cxTXiFAuair9ZYR/SWBLlPCX6rVTYaD4MdtmZyF4epeAiu3DlKvm1jjQhZy1NMV9QAAAA",alt:"7.jpg"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["点击按钮 ",(0,l.jsx)(e.code,{children:"异步环境下"}),"，组件会渲染二次。相信读过之前章节的同学，都明白原理是什么，在异步条件下的更新任务，不在 React 可控的范围内，所以会触发两次流程。"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:i,alt:"8.jpg"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"重点来了，我们看一下 v18 concurrent 下更新："})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["无论点击 ",(0,l.jsx)(e.strong,{children:(0,l.jsx)(e.code,{children:"同步环境下"})})," 还是 ",(0,l.jsx)(e.strong,{children:(0,l.jsx)(e.code,{children:"异步环境下"})})," ，组件都会执行一次。"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:"data:image/webp;base64,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",alt:"7.jpg"})}),"\n",(0,l.jsx)(e.p,{children:"首先想一下，在 concurrent 下，如何实现更新合并的呢？"}),"\n",(0,l.jsxs)(e.h2,{id:"四-v18-更新原理揭秘",children:["四 v18 更新原理揭秘",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#四-v18-更新原理揭秘",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["按照上面的问题，来探究一下 ",(0,l.jsx)(e.code,{children:"concurrent"})," 下的更新原理。我们还是按照",(0,l.jsx)(e.strong,{children:"同步"}),"和",(0,l.jsx)(e.strong,{children:"异步"}),"两个方向去探索。 无论是那种条件下，只要触发 React 的 ",(0,l.jsx)(e.code,{children:"setState"})," 或者 ",(0,l.jsx)(e.code,{children:"useState"}),"，最终进入调度任务开始更新的入口函数都是 ",(0,l.jsx)(e.code,{children:"ensureRootIsScheduled"})," ，所以可以从这个函数找到线索。"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js -> ensureRootIsScheduled"}),"\n"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function ensureRootIsScheduled(root,currentTime){\n    var existingCallbackNode = root.callbackNode;\n\n    var newCallbackPriority = getHighestPriorityLane(nextLanes);\n     var existingCallbackPriority = root.callbackPriority;\n\n    if (existingCallbackPriority === newCallbackPriority && \n    !( ReactCurrentActQueue.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n        /* 批量更新退出* */  \n        return;\n    }\n    \n    /* 同步更新条件下，会走这里的逻辑 */\n    if (newCallbackPriority === SyncLane) {\n        scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n        /* 用微任务去立即执行更新  */\n        scheduleMicrotask(flushSyncCallbacks);\n\n    }else{\n        newCallbackNode = scheduleCallback(\n            schedulerPriorityLevel,\n            performConcurrentWorkOnRoot.bind(null, root),\n        );\n    }\n    /* 这里很重要就是给当前 root 赋予 callbackPriority 和 callbackNode 状态 */\n    root.callbackPriority = newCallbackPriority;\n    root.callbackNode = newCallbackNode;\n}\n"})}),"\n",(0,l.jsxs)(e.h3,{id:"1-同步条件下的逻辑",children:["1 同步条件下的逻辑",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-同步条件下的逻辑",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"首先我们来看一下，同步更新的逻辑，上面讲到在 concurrent 中已经没有可控任务那一套逻辑。所以核心更新流程如下："}),"\n",(0,l.jsx)(e.p,{children:"当同步状态下触发多次 useState 的时候。"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["首先第一次进入到 ensureRootIsScheduled ，会计算出 ",(0,l.jsx)(e.code,{children:"newCallbackPriority"})," 可以理解成执行新的更新任务的优先级。那么和之前的 ",(0,l.jsx)(e.code,{children:"callbackPriority"})," 进行对比，如果相等那么退出流程，那么第一次两者肯定是不想等的。"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["同步状态下常规的更新 newCallbackPriority 是等于 ",(0,l.jsx)(e.code,{children:"SyncLane"})," 的，那么会执行两个函数，",(0,l.jsx)(e.code,{children:"scheduleSyncCallback"})," 和 ",(0,l.jsx)(e.code,{children:"scheduleMicrotask"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"scheduleSyncCallback"})," 会把任务 ",(0,l.jsx)(e.code,{children:"syncQueue"})," 同步更新队列中。来看一下这个函数："]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"react-reconciler/src/ReactFiberSyncTaskQueue.js -> scheduleSyncCallback"}),"\n"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"export function scheduleSyncCallback(callback: SchedulerCallback) {\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    syncQueue.push(callback);\n  }\n}\n"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:(0,l.jsx)(e.strong,{children:"注意：接下来就是 concurrent 下更新的区别了。在老版本的 React 是基于事件处理函数执行的 flushSyncCallbacks ，而新版本 React 是通过 scheduleMicrotask 执行的。"})}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"我们看一下 scheduleMicrotask 到底是什么？"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"react-reconciler/src/ReactFiberHostConfig.js -> scheduleMicrotask"}),"\n"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"var scheduleMicrotask = typeof queueMicrotask === 'function' ? queueMicrotask : typeof Promise !== 'undefined' ? function (callback) {\n  return Promise.resolve(null).then(callback).catch(handleErrorInNextTick);\n} : scheduleTimeout; \n"})}),"\n",(0,l.jsxs)(e.p,{children:["scheduleMicrotask 本质上就是 ",(0,l.jsx)(e.code,{children:"Promise.resolve"})," ，还有一个 setTimeout 向下兼容的情况。通过 scheduleMicrotask 去进行调度更新。"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsxs)(e.p,{children:["那么如果发生第二次 useState ，则会出现 ",(0,l.jsx)(e.code,{children:" existingCallbackPriority === newCallbackPriority"})," 的情况，接下来就会 return 退出更新流程了。"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.h3,{id:"2-异步条件下的逻辑",children:["2 异步条件下的逻辑",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-异步条件下的逻辑",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["在异步情况下，比如在 ",(0,l.jsx)(e.code,{children:"setTimeout"})," 或者是 ",(0,l.jsx)(e.code,{children:"Promise.resolve"})," 条件下的更新，会走哪些逻辑呢？"]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"第一步也会判断 existingCallbackPriority === newCallbackPriority 是否相等，相等则退出。"}),"\n",(0,l.jsxs)(e.li,{children:["第二步则就有点区别了。会直接执行 ",(0,l.jsx)(e.code,{children:"scheduleCallback"})," ，然后得到最新的 newCallbackNode，并赋值给 root 。"]}),"\n",(0,l.jsxs)(e.li,{children:["接下来第二次 useState ，同样会 return 跳出 ",(0,l.jsx)(e.code,{children:"ensureRootIsScheduled"})," 。"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"看一下 scheduleCallback 做了哪些事。"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js -> scheduleCallback"}),"\n"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function scheduleCallback(priorityLevel, callback) {\n    var actQueue = ReactCurrentActQueue.current;\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return scheduleCallback(priorityLevel, callback);\n    }\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"最后用一幅流程图描述一下流程："}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:r,alt:"9.jpg"})}),"\n",(0,l.jsxs)(e.h2,{id:"五-总结",children:["五 总结",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"通过本章节我们掌握的知识点有一下内容："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"主流框架中更新处理方式。"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"concurrent 模式下的 state 更新流程。"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"在同步异步条件下，state 更新的区别。"}),"\n"]}),"\n"]})]})}function x(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(o,{...n})}):o(n)}let u=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F36.v18%E7%89%B9%E6%80%A7%E7%AF%87-concurrent%20%E4%B8%8B%E7%9A%84%20state%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 主流框架中更新处理方式",id:"二-主流框架中更新处理方式",depth:2},{text:"1 第一种：微任务｜宏任务实现集中更新",id:"1-第一种微任务宏任务实现集中更新",depth:3},{text:"2 第二种：可控任务实现批量更新",id:"2-第二种可控任务实现批量更新",depth:3},{text:"三 与传统 legacy 模式的区别",id:"三-与传统-legacy-模式的区别",depth:2},{text:"一次更新 state 会发生什么？",id:"一次更新-state-会发生什么",depth:3},{text:"四 v18 更新原理揭秘",id:"四-v18-更新原理揭秘",depth:2},{text:"1 同步条件下的逻辑",id:"1-同步条件下的逻辑",depth:3},{text:"2 异步条件下的逻辑",id:"2-异步条件下的逻辑",depth:3},{text:"五 总结",id:"五-总结",depth:2}],title:"36.v18特性篇-concurrent 下的 state更新流程",headingTitle:"36.v18特性篇-concurrent 下的 state更新流程",frontmatter:{}}}}]);