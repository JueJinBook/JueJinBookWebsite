"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["17391"],{397754:function(e,n,r){e.exports=r.p+"static/image/10c1c54895c137975033586fe14b74c4.2a163fb0.webp"},76514:function(e,n,r){e.exports=r.p+"static/image/95a65d8db977c217d4bbf97433ac186b.dfd05010.webp"},513289:function(e,n,r){r.r(n),r.d(n,{default:()=>t});var c=r(552676),d=r(740453),s=r(76514),i=r(397754);function h(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",strong:"strong",h2:"h2",code:"code",ol:"ol",li:"li",ul:"ul",pre:"pre",h3:"h3",img:"img",h4:"h4"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"27-都说能写服务端下http上",children:["27-都说能写服务端（下）：http（上）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#27-都说能写服务端下http上",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"前段时间业余时间一直赖在医院了，所以断更了一段时间，真的非常不好意思。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Node.js 出来之后，除了现在的大前端工具链之外，还有一个举足轻重的能力，就是可以让大家可以用它来写 HTTP 服务端。社区上层出不穷的框架，Express、Koa、Egg.js、Midway.js 等等，基本上都是围绕 HTTP 服务端做的。偶尔出一些 RPC 能力的插件，也都不是其主要路线——主要除了 HTTP 之外，RPC 的协议不尽相同，不同公司也不一样，很难做统一。所以在社区来说，HTTP 基本上是唯一的解了，而且直面用户侧来说，HTTP 也都是浏览器唯一认的协议。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"HTTP（不同版本）"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"常用的"})," ",(0,c.jsx)(n.strong,{children:"RPC"})]}),"\n",(0,c.jsx)(n.p,{children:"HTTP/1.0"}),"\n",(0,c.jsx)(n.p,{children:"JSON-RPC"}),"\n",(0,c.jsx)(n.p,{children:"HTTP/1.1"}),"\n",(0,c.jsx)(n.p,{children:"gRPC"}),"\n",(0,c.jsx)(n.p,{children:"HTTP/2.0"}),"\n",(0,c.jsx)(n.p,{children:"Apache Thrift"}),"\n",(0,c.jsx)(n.p,{children:"HTTP/3.0"}),"\n",(0,c.jsx)(n.p,{children:"Dubbo"}),"\n",(0,c.jsx)(n.p,{children:"其实上面这张表格有一个不易被察觉的“误区”。实际上这两列并不能并列——HTTP 与 RPC 之间的关系与对比是相对复杂的，因为它们是不同层级和类别的概念。HTTP 是一个比较低级的协议，它处理的是如何在互联网上发送和接收数据包；而 RPC 则处理的是更高层次的抽象，即如何调用远程函数或方法，传递参数和获取结果。而 RPC 也有可能是基于 HTTP 进行传输的，比如 JSON-RPC，就是定义数据都以 JSON 格式传输，但是底下的协议可以是用 HTTP 或 HTTPS 进行的，也可以是其它一些网络传输协议。"}),"\n",(0,c.jsx)(n.p,{children:"本章说的是 Node.js 中的 HTTP 服务端相关内容，就不赘述 RPC 了。"}),"\n",(0,c.jsxs)(n.h2,{id:"经典八股题",children:["经典八股题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#经典八股题",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"我们先来一道最经典的面试题：当在浏览器中输入网址敲下回车后，到底会发生什么？"})}),"\n",(0,c.jsx)(n.p,{children:"这其实是一道烂俗得不能再烂俗的八股题了，它其实并没有标准答案，而是针对不同岗位的同学会有不同的侧重。比如面向前端同学，它可能更想听到的是偏浏览器侧的一些行为、优化，比如浏览器侧缓存、JavaScript 时序、渲染等等的内容，而对于网络请求侧，稍微模糊一点带过也问题不大；而面向后端同学，通常更想听到的答案是前面一系列流程，然后到服务端后，几次握手，如何负载均衡，如何分布式等等等等。"}),"\n",(0,c.jsx)(n.p,{children:"我也不回答这个八股，反正也没标准答案。我就挑跟本小册相关的一些重点讲。首先浏览器发起 DNS 查询，这个会用到各种缓存，比如浏览器缓存、操作系统缓存、路由器缓存等等，然后才会有对 ISP 或者自定义 DNS 服务器发起 DNS 查询——这个操作其实我们之前讲的 DNS 那章中，Node.js 发起网络请求也会有类似的操作，只是没那么多弯弯道道缓存罢了——总归用域名（主机名）访问某个地址之前，肯定会有一道 DNS 查询。有相关侧重的题目就可以着重讲讲这一道浏览器侧的行为，没有特别侧重的，随便糊弄两句就够了。"}),"\n",(0,c.jsx)(n.p,{children:"当浏览器获取到服务器的 IP 地址后，它会使用 TCP 与服务器建立一个连接，然后通过该连接发送 HTTP 请求（Request）。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["注意这里的 TCP，就是我们上一章 ",(0,c.jsx)(n.code,{children:"net"})," 中讲到的。所以 HTTP 模块是继承自 ",(0,c.jsx)(n.code,{children:"net"})," 相关模块继续写的。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"建立 TCP 的过程中，就是老生常谈的“三次握手”了，这不是本章的重点，大家尚不了解的，可自行网上搜索学习。一旦 TCP 连接建立，浏览器就会通过这个连接发送一个 HTTP 请求。一个 HTTP 的请求是按某种格式约定好的“字符串数据”。这么说是为了让大家好理解，并不是传输的真的是“字符串”。不过在早期的 HTTP 还真的只能传 ASCII 字符。"}),"\n",(0,c.jsx)(n.p,{children:"服务端（比如 Nginx、Node.js 或是更长的负载均衡链路）接收到这些数据之后，会进行服务端的逻辑计算和处理，最终返回一个 HTTP 响应（Response）数据，这个数据也是按某种格式约定好的“字符串数据”，浏览器会根据其来渲染结果。"}),"\n",(0,c.jsx)(n.p,{children:"接下去如果不是 keep-alive 头，那就“四次挥手”断开连接了。“四次挥手”也不是本章重点，大家可自行了解。"}),"\n",(0,c.jsx)(n.p,{children:"如果是 HTTPS，那么在上述过程之前还有一个 TLS 握手过程，用于在浏览器和服务器之间建立一个加密的连接。这涉及到证书验证、密钥交换等的加密算法。"}),"\n",(0,c.jsx)(n.p,{children:"那么问题来了，所谓的“字符串数据”究竟长什么样呢？一个“请求”的数据分为三部分："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"请求行"}),"，内含："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"方法："})," HTTP 请求的方法，如 ",(0,c.jsx)(n.code,{children:"GET"}),"、",(0,c.jsx)(n.code,{children:"POST"}),"、 ",(0,c.jsx)(n.code,{children:"PUT"}),"、",(0,c.jsx)(n.code,{children:"DELETE"})," 等；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"URI"})," ",(0,c.jsx)(n.strong,{children:"绝对路径："})," 请求的资源的路径，例如 ",(0,c.jsx)(n.code,{children:"/index.html"}),"；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"协议版本："})," HTTP 使用的版本，例如 ",(0,c.jsx)(n.code,{children:"HTTP/1.1"}),"。 \xa0\xa0"]}),"\n",(0,c.jsx)(n.p,{children:"如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"GET /index.html HTTP/1.1\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"请求头："})," 包含了一系列描述请求或客户端本身信息的键值对，一行一对。每个头部都是一个键值对，键和值之间用冒号 ",(0,c.jsx)(n.code,{children:":"})," 分隔，如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  Host: www.example.com\n  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36\n  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n  Accept-Language: en-US,en;q=0.5\n  Connection: keep-alive\n  ```\n\n"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"请求体："})," 包含了需要发送给服务器的数据。不是所有的 HTTP 请求都有请求体，例如，常见的 ",(0,c.jsx)(n.code,{children:"GET"})," 请求就不包含。但是，如 ",(0,c.jsx)(n.code,{children:"POST"})," 和 ",(0,c.jsx)(n.code,{children:"PUT"})," 这类需要上传数据的请求通常会包含请求体。如下方就是一个 JSON 格式的请求体："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'  {\n    "username": "john",\n    "password": "123456"\n  }\n  ```\n\n'})}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["理论上请求体可以是任意内容，比如有一些基于 HTTP 的 RPC 协议中，请求体就会是序列化之后的参数二进制数据。但在浏览器和服务端中会有一些“约定俗成”的“君子协议”。例如，如果请求头中的 ",(0,c.jsx)(n.code,{children:"Content-Type"})," 值为 ",(0,c.jsx)(n.code,{children:"application/json"}),"，就相当于告诉服务端，我的请求体是 JSON 格式的；又比如通常我们通过 ",(0,c.jsx)(n.code,{children:"<form>"})," 表单提交的 POST 数据，浏览器通常会将 ",(0,c.jsx)(n.code,{children:"Content-Type"})," 设置为 ",(0,c.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),"，请求体则是以类似 Query String 的方式出现。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["值得注意的是，在请求头和请求体之间，会有一个空行分割。也就是说，如果服务端接收到来自客户端的 HTTP 请求后，需要逐字节解析内容。第一行是请求体，方法、URI、版本号以空格分割；第二行往后是请求头，以 ",(0,c.jsx)(n.code,{children:":"})," 分割；若遇到两个换行符 ",(0,c.jsx)(n.code,{children:"\\n"}),"，则认为后续的就是请求体了。"]}),"\n",(0,c.jsxs)(n.h2,{id:"http-的历史与版本",children:["HTTP 的历史与版本",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http-的历史与版本",children:"#"})]}),"\n",(0,c.jsxs)(n.h3,{id:"http09",children:["HTTP/0.9",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http09",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"HTTP/0.9 是 HTTP 协议的最早版本，可以认为是该协议的“原始”形态。它诞生于 1991 年，由 Tim Berners-Lee 在欧洲核子研究组织（CERN）创造。这也是 World Wide Web 项目的开始。"}),"\n",(0,c.jsx)(n.p,{children:"当初的目的是提供一个简单的协议来允许文档之间进行超链接，所以 HTTP/0.9 的设计极为简化。它只支持 GET 请求，只能返回纯文本 HTML，没有 HTTP 头，也没有状态码。"}),"\n",(0,c.jsx)(n.p,{children:"第一个 Web 服务器是由 Tim Berners-Lee 在 NeXT 计算机上运行的，用于托管关于 World Wide Web 项目的信息。那时，许多人第一次通过浏览器访问该服务器，使用的就是 HTTP/0.9 协议。"}),"\n",(0,c.jsxs)(n.h3,{id:"http10",children:["HTTP/1.0",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http10",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["随着 Web 的迅速增长和应用的增加，HTTP/0.9 的限制变得越来越明显，因此需要一个更加灵活和强大的协议版本。这就导致了 HTTP/1.0 的诞生。HTTP/1.0 在 1996 年作为 ",(0,c.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/html/rfc1945",title:"https://datatracker.ietf.org/doc/html/rfc1945",target:"_blank",rel:"noopener noreferrer",children:"RFC 1945"})," 正式发布。"]}),"\n",(0,c.jsxs)(n.p,{children:["相对于前一版本，HTTP/1.0 带来了一系列的改进。首先，除了原来的 ",(0,c.jsx)(n.code,{children:"GET"})," 方法，它引入了新的方法，如 ",(0,c.jsx)(n.code,{children:"POST"})," 和 ",(0,c.jsx)(n.code,{children:"HEAD"}),"。其次，HTTP/1.0 引入了请求和响应头部，这允许客户端和服务器传递更多的信息。例如，客户端可以通过 ",(0,c.jsx)(n.code,{children:"User-Agent"})," 头告诉服务器它使用的浏览器类型，而服务器可以通过 ",(0,c.jsx)(n.code,{children:"Content-Type"})," 头告诉客户端响应的内容类型。此外，HTTP/1.0 还定义了一系列的状态代码，用于表示请求的结果，如 ",(0,c.jsx)(n.code,{children:"200"})," 表示请求成功，",(0,c.jsx)(n.code,{children:"404"})," 表示请求的资源未找到。此版本也开始支持多种内容类型，如文本、图像、视频等。在连接管理方面，尽管 HTTP/1.0 默认使用短连接（即每次请求后断开连接），但它引入了一个可选的 ",(0,c.jsx)(n.code,{children:"Keep-Alive"})," 头部，用于维持连接，这个就是我们先前说的，如果不维持连接，响应结束后就会“四次挥手”断开。"]}),"\n",(0,c.jsxs)(n.h3,{id:"http11",children:["HTTP/1.1",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http11",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["HTTP/1.0 也存在一些问题和局限性。一个明显的问题是效率。尽管存在 ",(0,c.jsx)(n.code,{children:"Keep-Alive"})," 头，但大多数 HTTP/1.0 请求仍然使用单次连接，导致每次请求都需要建立新的 TCP 连接，这在高延迟网络中会引入明显的开销。另一个问题是无状态性。HTTP/1.0 本身是无状态的，这意味着每次请求都是独立的，服务器不能记住前一个请求的信息。"]}),"\n",(0,c.jsx)(n.p,{children:"所以在 1997 年，HTTP/1.1 来了，解决了 HTTP/1.0 中的许多问题。是目前 Web 最主流的协议版本。"}),"\n",(0,c.jsx)(n.p,{children:"其中最显著的变化是持久连接的默认启用。在 HTTP/1.0 中，每次请求后连接都会被关闭，而在 HTTP/1.1 中，多个 HTTP 请求和响应可以在同一个 TCP 连接上连续发送。这大大减少了由于频繁建立和关闭连接而产生的开销，使得网络通信更加高效。"}),"\n",(0,c.jsx)(n.p,{children:"当然，上面这个只是“RFC 定义”，是让实现者（HTTP 客户端，比如浏览器）去遵守的——浏览器会在这一趴进行链接复用。但是如果客户端不遵守，你也不能拿它怎么样，最多骂一句“你不符合标准”。这里希望大家能明白“标准”与“现实”。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["在此版本中，HTTP 还增加了如 ",(0,c.jsx)(n.code,{children:"OPTIONS"}),"、",(0,c.jsx)(n.code,{children:"PUT"}),"、",(0,c.jsx)(n.code,{children:"DELETE"})," 和 ",(0,c.jsx)(n.code,{children:"TRACE"})," 等新的方法，赋予了 HTTP 更多的功能。同时，缓存控制也得到了增强，新引入的头如 ",(0,c.jsx)(n.code,{children:"ETag"})," 和 ",(0,c.jsx)(n.code,{children:"Cache-Control"})," 使得缓存管理变得更为精确。"]}),"\n",(0,c.jsxs)(n.p,{children:["考虑到虚拟主机的应用，HTTP/1.1 强制要求所有的请求都必须包含 ",(0,c.jsx)(n.code,{children:"Host"})," 头部。因为一个 IP 地址现在可以对应多个域名，通过 ",(0,c.jsx)(n.code,{children:"Host"})," 头部，服务器可以知道客户端请求的确切域名，从而提供相应的内容。如果你在浏览器中访问 ",(0,c.jsx)(n.a,{href:"http://juejin.cn",title:"http://juejin.cn",target:"_blank",rel:"noopener noreferrer",children:"juejin.cn"})," ，实际上是访问 DNS 查出来的 ",(0,c.jsx)(n.a,{href:"https://juejin.cn/",title:"https://juejin.cn/",target:"_blank",rel:"noopener noreferrer",children:"juejin.cn"})," 对应的 IP，并发送 HTTP 请求，且设置请求头的 ",(0,c.jsx)(n.code,{children:"Host"})," 为 ",(0,c.jsx)(n.code,{children:"juejin.cn"}),"，以此来让服务端知道自己访问的是什么域名。"]}),"\n",(0,c.jsx)(n.p,{children:"尽管 HTTP/1.1 带来了许多优势，但随着网络技术的发展，人们逐渐意识到它在性能和并行处理方面存在的局限性。这些问题在后来的 HTTP/2 和 HTTP/3 版本中得到了进一步的解决。"}),"\n",(0,c.jsxs)(n.h3,{id:"http2-与-http3",children:["HTTP/2 与 HTTP/3",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http2-与-http3",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["HTTP/2 的设计基于 Google 的 SPDY 协议，主要是为了解决 HTTP/1.1 在性能上的局限性。其核心优势在于实现了多路复用，允许在一个单一的 TCP 连接中",(0,c.jsx)(n.strong,{children:"并行发送"}),"多个请求和响应（HTTP/1.1 中的 keep-alive 是串行复用）。这大大降低了因为多次建立连接所带来的开销和延迟，使得连接可以被充分利用。HTTP/2 使用二进制格式（HTTP/1.1 是人肉可读的文本格式），这使得协议的解析和实现更加高效。"]}),"\n",(0,c.jsx)(n.p,{children:"HTTP/3 是基于一个全新的、名为 QUIC 的传输协议，这个协议是基于 UDP 构建的。最显著的好处是，HTTP/3 通过采用 QUIC，继承了其在并行传输、低延迟连接建立以及在不稳定网络环境中的高性能特点。QUIC 默认采用了 TLS 1.3 加密，为用户提供了强化的安全性。"}),"\n",(0,c.jsx)(n.p,{children:"本章中，我们主要介绍 HTTP/1.1 相关内容，这里就不赘述了。大家若对 HTTP/2、HTTP/3 感兴趣，可自行上网搜索学习相关内容。"}),"\n",(0,c.jsxs)(n.h2,{id:"nodejs-中的-http-服务端",children:["Node.js 中的 HTTP 服务端",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中的-http-服务端",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我对密码学不熟，HTTPS 的内容就不讲了。这里我们专注讲 HTTP。在 Node.js 写一个 HTTP 服务特别简单："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const http = require('http');\n\nconst server = http.createServer((req, resp) => {\n  resp.writeHead(200, { 'Content-Type': 'application/json' });\n  resp.end(JSON.stringify({\n    data: 'Hello World!',\n  }));\n});\n\nserver.listen(8000); \n"})}),"\n",(0,c.jsxs)(n.p,{children:["先用 ",(0,c.jsx)(n.code,{children:"http.createServer()"})," 来创建一个 HTTP 服务端，回调函数会在接收到一个 HTTP 请求时被触发。",(0,c.jsx)(n.code,{children:"req"})," 是接收到的请求，",(0,c.jsx)(n.code,{children:"resp"})," 是将要操作的响应。"]}),"\n",(0,c.jsxs)(n.p,{children:["这个例子中，先往响应中写响应行和响应头。其中响应行的状态码为 ",(0,c.jsx)(n.code,{children:"200"}),"，响应头就一个 ",(0,c.jsx)(n.code,{children:"Content-Type"}),"。然后再往响应中写入响应体，是一段 JSON 字符串：",(0,c.jsx)(n.code,{children:'{"data":"Hello World!"}'}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["有了“HTTP 服务端”实例后，将它监听至 ",(0,c.jsx)(n.code,{children:"8000"})," 端口，以接受请求。"]}),"\n",(0,c.jsxs)(n.h3,{id:"http-服务端实例",children:["HTTP 服务端实例",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http-服务端实例",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"http.createServer()"})," 里面就是返回一个 ",(0,c.jsx)(n.code,{children:"new Server()"}),"。这个 ",(0,c.jsx)(n.code,{children:"Server"})," 就是 HTTP 的服务端类了。我们看看 ",(0,c.jsxs)(n.a,{href:"https://github.com/nodejs/node/blob/v18.17.1/lib/_http_server.js#L506",title:"https://github.com/nodejs/node/blob/v18.17.1/lib/_http_server.js#L506",target:"_blank",rel:"noopener noreferrer",children:[(0,c.jsx)(n.code,{children:"Server"})," 怎么写的"]}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"function Server(options, requestListener) {\n  ...\n  net.Server.call(this, { ... });\n  ...\n}\n\nObjectSetPrototypeOf(Server.prototype, net.Server.prototype);\nObjectSetPrototypeOf(Server, net.Server);\n\n...\n"})}),"\n",(0,c.jsxs)(n.p,{children:["活生生把 ",(0,c.jsx)(n.code,{children:"Server"})," 继承自 ",(0,c.jsx)(n.code,{children:"net.Server"}),"。为什么？因为 ",(0,c.jsx)(n.code,{children:"net.Server"})," 是指 TCP 服务端呀，而 HTTP/1.1 来说，就是基于 TCP 的。"]}),"\n",(0,c.jsxs)(n.h3,{id:"接受流量",children:["接受流量",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#接受流量",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们先来看看，在 ",(0,c.jsx)(n.code,{children:"net"})," 的 ",(0,c.jsx)(n.code,{children:"Server"})," 中，用户侧是如何监听端口，以及处理来的数据的。这是一个最简单的 Echo Server 例子。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const net = require('net');\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后创建一个服务端对象。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const server = net.createServer(socket => {\n  console.log('客户端已连接');\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在这个回调函数中，就表示有客户端与之建立了连接。接下去就监听客户端的 ",(0,c.jsx)(n.code,{children:"data"})," 事件，以接受从客户端传过来的数据。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  socket.on('data', data => {\n    console.log(`收到数据：${data}`);\n"})}),"\n",(0,c.jsx)(n.p,{children:"既然是 Echo Server，我们把传过来的数据原封不动地传回给客户端。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"    socket.write(data);\n  });\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后监听客户端断开事件。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  socket.on('end', () => {\n    console.log('客户端已断开连接');\n  });\n"})}),"\n",(0,c.jsx)(n.p,{children:"错误事件。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  socket.on('error', (error) => {\n    console.error(`发生错误: ${error}`);\n  });\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["最后，得到的这个 ",(0,c.jsx)(n.code,{children:"server"})," 对象监听一个端口就可以了。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"server.listen(8080, () => {\n  console.log('服务器启动在 8080 端口');\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["启动这个程序后，我们就可以尝试使用 ",(0,c.jsx)(n.code,{children:"nc"})," 或者 ",(0,c.jsx)(n.code,{children:"telnet"})," 去连接上去看看了。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["关于 ",(0,c.jsx)(n.code,{children:"nc"})," 或者 ",(0,c.jsx)(n.code,{children:"telnet"})," 程序，大家可自行网上搜索。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"自己写一个服务端",children:["自己写一个服务端",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自己写一个服务端",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["既然知道了 HTTP 协议和简单原理，我们可以自己动手基于 ",(0,c.jsx)(n.code,{children:"net"})," 模块打造一个 HTTP 服务端了。首先我们知道，当客户端建连后，会给我们发送 HTTP 请求，其请求格式在前面提过了。所以我们需要改造的就是 ",(0,c.jsx)(n.code,{children:"socket"})," 的 ",(0,c.jsx)(n.code,{children:"data"})," 事件。为了写着简单，我们不走效率的状态机，也不考虑各种边界条件，仅给大家作示范。"]}),"\n",(0,c.jsxs)(n.p,{children:["首先还是 ",(0,c.jsx)(n.code,{children:"net.createServer()"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const server = net.createServer(socket => {\n  console.log('客户端已连接');\n"})}),"\n",(0,c.jsx)(n.p,{children:"当浏览器过来建立连接时，我们为这个连接准备一些变量，后面会用到。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  let lines = [];\n  let received = '';\n  let method;\n  let url;\n  let version;\n  let headers = {};\n"})}),"\n",(0,c.jsxs)(n.p,{children:["为了方便处理，我们把传输时开发者侧的编码改为 ",(0,c.jsx)(n.code,{children:"utf8"}),"，这样数据就能直接当字符串处理了（实际上线上得按二进制来，毕竟请求体响应体还是会有二进制内容的）。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  socket.setEncoding('utf8');\n"})}),"\n",(0,c.jsxs)(n.p,{children:["下一步，监听从 ",(0,c.jsx)(n.code,{children:"socket"})," 过来的数据。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  socket.on('data', data => {\n"})}),"\n",(0,c.jsxs)(n.p,{children:["由于 HTTP 的数据是流式传播的，所以数据不一定是一次性传输完毕，所以我们每次收到一坨数据的时候，先跟 ",(0,c.jsx)(n.code,{children:"received"})," 进行拼接，然后按 ",(0,c.jsx)(n.code,{children:"\\r\\n"}),"（HTTP 协议中的行分隔符是 CRLF）进行分割。由于最后一段数据不一定有 ",(0,c.jsx)(n.code,{children:"\\r\\n"}),"，所以我们先留着最后一段继续放在 ",(0,c.jsx)(n.code,{children:"receiced"})," 中跟后续数据进行拼接，前面分割好的数据扔进 ",(0,c.jsx)(n.code,{children:"lines"})," 数组中。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"    const splited = received.split('\\r\\n');\n    lines.push(...splited.slice(0, -1));\n    received = splited.slice(-1)[0];\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如此一来，",(0,c.jsx)(n.code,{children:"lines"})," 中会逐步推入每一行数据。刚开始传输的时候，我们的 ",(0,c.jsx)(n.code,{children:"method"})," 肯定是空的，因为这些数据是在请求的第一行请求行中得到。所以我们判断一下如果 ",(0,c.jsx)(n.code,{children:"lines"})," 中有数据了，且 ",(0,c.jsx)(n.code,{children:"method"})," 还为赋值，则把第一行进行拆解，赋值给 ",(0,c.jsx)(n.code,{children:"method"}),"、",(0,c.jsx)(n.code,{children:"url"})," 和 ",(0,c.jsx)(n.code,{children:"version"}),"。这里为了简化逻辑，我们只接受 ",(0,c.jsx)(n.code,{children:"GET"})," 的 ",(0,c.jsx)(n.code,{children:"HTTP/1.1"})," 的请求。毕竟如果需要接受 ",(0,c.jsx)(n.code,{children:"POST"})," 等请求，我们还需要解析 ",(0,c.jsx)(n.code,{children:"Content-Length"})," 来获取请求体的长度，然后再按请求体长度去获取后面的请求体数据，作为教程来说有些许麻烦和浪费篇幅。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"    if (!method && lines.length) {\n      ([ method, url, version ] = lines[0].split(' '));\n      if (method !== 'GET') {\n        socket.write('HTTP/1.1 405 Method Not Allowed\\r\\n\\r\\n', () => {\n          socket.end();\n        });\n        return;\n      }\n\n      if (!url.startsWith('/')) {\n        socket.write('HTTP/1.1 400 Bad Request\\r\\n\\r\\n', () => {\n          socket.end();\n        });\n        return;\n      }\n\n      if (version !== 'HTTP/1.1') {\n        socket.write('HTTP/1.1 400 Bad Request\\r\\n\\r\\n', () => {\n          socket.end();\n        });\n        return;\n      }\n    }\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面的代码中，我们做了判断，如果请求不是 ",(0,c.jsx)(n.code,{children:"GET"}),"，则往客户端写回请求："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"HTTP/1.1 405 Method Not Allowed\n"})}),"\n",(0,c.jsx)(n.p,{children:"注意后面有两个空行。第一个空行表示响应体结束，后面是响应头；第二个空行则表示响应头结束，后面是响应体。在这个例子中，我们没有响应头，所以连着来两个空行。没有响应体，所以第二个空行后面没有任何数据。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"HTTP/1.1 的响应与请求类似，都分为三个部分。只不过响应的第一行是响应行，并非请求行。响应行格式为 HTTP 版本号、HTTP 状态码以及 HTTP 状态码所对应的语义。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["最后，如果分割数据并且写回 ",(0,c.jsx)(n.code,{children:"received"})," 的数据是个空字符串，就说明这是由一个空行所切割出来的结果。连着两个空行就代表着请求头结束了。由于我们的例子中不可能存在请求体，所以当请求头结束后我们可以开始处理这个 HTTP 请求了。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"    if (received === '') {\n"})}),"\n",(0,c.jsxs)(n.p,{children:["从 ",(0,c.jsx)(n.code,{children:"lines"})," 第二行开始，就都是我们的请求头。每一行我们都用 ",(0,c.jsx)(n.code,{children:":"})," 切割一下，得到请求头的键值对，加入 ",(0,c.jsx)(n.code,{children:"headers"})," 中。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"      for (let i = 1; i < lines.length; i++) {\n        const [ key, value ] = lines[i].split(': ');\n        headers[key] = value;\n      }\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后根据这些数据构造出我们所需要返回给用户的 JSON 字符串。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"      const body = JSON.stringify({ method, headers, url });\n"})}),"\n",(0,c.jsx)(n.p,{children:"构造出我们的响应数据。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"      const output = [\n        'HTTP/1.1 200 OK',\n        'Content-Type: application/json',\n        `Content-Length: ${Buffer.byteLength(body)}`,\n        '',\n        body,\n      ].join('\\r\\n');\n"})}),"\n",(0,c.jsx)(n.p,{children:"最后，我们把这个数据写回给客户端，浏览器就可以收到我们的 JSON 输出了。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"      socket.write(output);\n"})}),"\n",(0,c.jsx)(n.p,{children:"最后的最后，还记得我们说的 HTTP/1.1 默认是 Keep-Alive 的吗？比如我们现在用 Chrome 来做请求，连接是会被复用的。一个请求结束后，Chrome 并不会断开这个连接，而是下次有相同 IP 端口的请求时，继续往这个连接写入请求、得到请求。"}),"\n",(0,c.jsx)(n.p,{children:"所以，当我们写完数据给客户端后，需要清空状态，以新的状态迎接下一个请求。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"      lines = [];\n      received = '';\n      headers = {};\n      method = '';\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后还是一些扫尾处理和监听。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  socket.on('end', () => {\n    console.log('客户端已断开连接');\n  });\n  socket.on('error', (error) => {\n    console.error(`发生错误: ${error}`);\n  });\n});\n\nserver.listen(8080, () => {\n  console.log('服务器启动在8080端口');\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["当你在本地跑起上面这段代码后，用浏览器访问 ",(0,c.jsx)(n.a,{href:"http://127.0.0.1:8080",title:"http://127.0.0.1:8080",target:"_blank",rel:"noopener noreferrer",children:(0,c.jsx)(n.a,{href:"http://127.0.0.1:8080",target:"_blank",rel:"noopener noreferrer",children:"http://127.0.0.1:8080"})})," ，你就能看到这样的输出了："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'{\n  "method": "GET",\n  "headers": {\n    "Host": "127.0.0.1:8080",\n    "Connection": "keep-alive",\n    "Cache-Control": "max-age=0",\n    "sec-ch-ua": ""Chromium";v="116", "Not)A;Brand";v="24", "Google Chrome";v="116"",\n    "sec-ch-ua-mobile": "?0",\n    "sec-ch-ua-platform": ""macOS"",\n    "Upgrade-Insecure-Requests": "1",\n    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36",\n    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",\n    "Sec-Fetch-Site": "none",\n    "Sec-Fetch-Mode": "navigate",\n    "Sec-Fetch-User": "?1",\n    "Sec-Fetch-Dest": "document",\n    "Accept-Encoding": "gzip, deflate, br",\n    "Accept-Language": "zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,sv;q=0.6,zh-TW;q=0.5"\n  },\n  "url": "/"\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，我们的确是 ",(0,c.jsx)(n.code,{children:"GET"})," 请求。而 ",(0,c.jsx)(n.code,{children:"Host"})," 头则是浏览器自行加上去的我们请求的域名，由于我们直接使用 IP 进行访问，所以 ",(0,c.jsx)(n.code,{children:"Host"})," 是 ",(0,c.jsx)(n.code,{children:"127.0.0.1:8080"}),"。接下去这些头也都是 Chrome 自行加上去的，我们原封不动输了出来。最后，",(0,c.jsx)(n.code,{children:"url"})," 是 ",(0,c.jsx)(n.code,{children:"/"}),"，即根路径。我们可以尝试访问别的路径试试看，如 ",(0,c.jsx)(n.a,{href:"http://127.0.0.1:8080/index.html",title:"http://127.0.0.1:8080/index.html",target:"_blank",rel:"noopener noreferrer",children:(0,c.jsx)(n.a,{href:"http://127.0.0.1:8080/index.html",target:"_blank",rel:"noopener noreferrer",children:"http://127.0.0.1:8080/index.html"})})," ，这回我们看到的 ",(0,c.jsx)(n.code,{children:"url"})," 就变成了 ",(0,c.jsx)(n.code,{children:"/index.html"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["这就是一个基于 ",(0,c.jsx)(n.code,{children:"net"})," 的简单的 HTTP 服务端实现了。"]}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["本章通过一个经典八股题，为大家引出了 HTTP 相关的内容。为大家介绍了 HTTP 的历史，以及不同的版本。并着重介绍了 HTTP/1.1 的请求格式和原理。在 Node.js 中，",(0,c.jsx)(n.code,{children:"http"})," 模块的服务端是基于 ",(0,c.jsx)(n.code,{children:"net"})," 模块的 ",(0,c.jsx)(n.code,{children:"Server"})," 实现的。在讲具体实现之前，我们自己用 ",(0,c.jsx)(n.code,{children:"net"})," 模块实现了一个最简单版本的 HTTP 服务端，以此来让大家更有体感。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:""})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}let t=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F27-%E9%83%BD%E8%AF%B4%E8%83%BD%E5%86%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9Ahttp%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{text:"经典八股题",id:"经典八股题",depth:2},{text:"HTTP 的历史与版本",id:"http-的历史与版本",depth:2},{text:"HTTP/0.9",id:"http09",depth:3},{text:"HTTP/1.0",id:"http10",depth:3},{text:"HTTP/1.1",id:"http11",depth:3},{text:"HTTP/2 与 HTTP/3",id:"http2-与-http3",depth:3},{text:"Node.js 中的 HTTP 服务端",id:"nodejs-中的-http-服务端",depth:2},{text:"HTTP 服务端实例",id:"http-服务端实例",depth:3},{text:"接受流量",id:"接受流量",depth:3},{text:"自己写一个服务端",id:"自己写一个服务端",depth:4},{text:"小结",id:"小结",depth:2}],title:"27-都说能写服务端（下）：http（上）",headingTitle:"27-都说能写服务端（下）：http（上）",frontmatter:{}}}}]);