"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["7662"],{173647:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var i=s(552676),t=s(740453);let o=s.p+"static/image/7bebf7b60a2bd5ff90001a5f197a70da.f2dd8980.webp",r=s.p+"static/image/58a26a25aebb451061d9156b1c90c653.6d706d95.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",ol:"ol",li:"li",ul:"ul",img:"img",code:"code",pre:"pre",strong:"strong"},(0,t.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"9-基础8vuex快速掌握",children:["9 基础8：Vuex快速掌握",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-基础8vuex快速掌握",children:"#"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"Done is better than perfect. —— Facebook"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"本节主要介绍 Vuex 的基本概念，并一步步引导读者如何去运用 Vuex 在一个应用中，以浅显易懂的例子掌握 Vuex 的核心知识。"}),"\n",(0,i.jsxs)(n.h2,{id:"什么是-vuex",children:["什么是 Vuex？",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是-vuex",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"首先我们要弄清楚 Vuex 是做什么的？为什么使用 Vuex ?"}),"\n",(0,i.jsx)(n.p,{children:"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。uniapp集成了vuex的状态管理功能，可以在多端情况下使用。"}),"\n",(0,i.jsx)(n.p,{children:"Vuex 需要解决的问题："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"多个视图依赖于同一状态。比如当前音乐应用的账号页，我的页面保持登录状态以及用户信息。"}),"\n",(0,i.jsx)(n.li,{children:"来自不同视图的行为需要变更同一状态。比如登录页更改登录状态，账号页面退出登录改成未登录状态。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"这个状态自管理应用包含以下几个部分："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"state，驱动应用的数据源；"}),"\n",(0,i.jsx)(n.li,{children:"view，以声明方式将 state 映射到视图；"}),"\n",(0,i.jsx)(n.li,{children:"actions，响应在 view 上的用户输入导致的状态变化。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:r,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"上面的概念比较模糊，我们先来点简单的。"}),"\n",(0,i.jsx)(n.p,{children:"在这引用了一位技术大拿关于管理状态（state）的讲解："}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"不管是 Vue ，还是 React，都需要管理状态（state），比如组件之间都有共享状态的需要。什么是共享状态？比如一个组件需要使用另一个组件的状态，或者一个组件需要改变另一个组件的状态，都是共享状态。"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"父子组件之间，兄弟组件之间共享状态，往往需要写很多没有必要的代码，比如把状态提升到父组件里，或者给兄弟组件写一个父组件，听听就觉得挺啰嗦。"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"如果不对状态进行有效的管理，状态在什么时候，由于什么原因，如何变化就会不受控制，就很难跟踪和测试了。如果没有经历过这方面的困扰，可以简单理解为会搞得很乱就对了。"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"在软件开发里，有些通用的思想，比如隔离变化，约定优于配置等，隔离变化就是说做好抽象，把一些容易变化的地方找到共性，隔离出来，不要去影响其他的代码。约定优于配置就是很多东西我们不一定要写一大堆的配置，比如我们几个人约定，view 文件夹里只能放视图，不能放过滤器，过滤器必须放到 filter 文件夹里，那这就是一种约定，约定好之后，我们就不用写一大堆配置文件了，我们要找所有的视图，直接从 view 文件夹里找就行。"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"根据这些思想，对于状态管理的解决思路就是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。根据这个思路，产生了很多的模式和库。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Vuex 防止随意修改而不好跟踪状态，规定组件不允许直接修改 store 实例的 state，组件必须通过 action 来改变 state ，也就是说，组件里面应该执行 action 来分发 (dispatch) 事件通知 store 去改变。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚的先进的调试工具。"}),"\n",(0,i.jsxs)(n.h2,{id:"vuex-的基础使用创建一个改变登录状态的应用",children:["Vuex 的基础使用（创建一个改变登录状态的应用）",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vuex-的基础使用创建一个改变登录状态的应用",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"我们一个简单的登录状态的应用开始。"}),"\n",(0,i.jsx)(n.p,{children:"第一步，创建 store ；"}),"\n",(0,i.jsxs)(n.p,{children:["首先在根目录下新建文件夹 ",(0,i.jsx)(n.code,{children:"store"}),"，并创建 index.js ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n    state: {\n        isLogin: false   // 是否登录的状态，默认为未登录 false\n    },\n    mutations: {\n        // 定义一个操作isLogin状态的方法\n        storeLogin (state) {\n          state.isLogin = true\n        }\n    }\n})\n\nexport default store\n"})}),"\n",(0,i.jsxs)(n.p,{children:["上面代码引入了 ",(0,i.jsx)(n.code,{children:"vue"}),"，",(0,i.jsx)(n.code,{children:"vuex"})," ，并使用 ",(0,i.jsx)(n.code,{children:"Vue.use(Vuex)"})," 安装Vuex插件，在 ",(0,i.jsx)(n.code,{children:"new Vuex.Store"})," 传参对象中定义 ",(0,i.jsx)(n.code,{children:"state"})," ，",(0,i.jsx)(n.code,{children:"mutations"})," 。"]}),"\n",(0,i.jsxs)(n.p,{children:["我在上面定义了 ",(0,i.jsx)(n.code,{children:"isLogin"}),"，整个项目以这个变量作为登录标记，",(0,i.jsx)(n.code,{children:"storeLogin"})," 的方法来修改 ",(0,i.jsx)(n.code,{children:"isLogin"})," 值，而且修改 ",(0,i.jsx)(n.code,{children:"isLogin"})," 值只能通过 ",(0,i.jsx)(n.code,{children:"storeLogin"})," 方法。"]}),"\n",(0,i.jsx)(n.p,{children:"第二步，新建登录页login.vue；"}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"pages"})," 下新建一个页面 login.vue，鼠标悬浮在当前项目目录下选择【新建页面】，命名为 ",(0,i.jsx)(n.code,{children:"login"})," 勾选【自动在 pages.json 中注册】:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["上面新建了一个 ",(0,i.jsx)(n.code,{children:"login"})," 路由页面，勾选【自动在 pages.json 中注册】是在 ",(0,i.jsx)(n.code,{children:"pages.json"})," 文件中注册页面路由，在 HBuilder 上部操作 【运行】>>【运行到浏览器】>> 选择一个浏览器，这样客户端就能以 ",(0,i.jsx)(n.code,{children:"http://localhost:8080/#/pages/login/login"})," 访问。"]}),"\n",(0,i.jsx)(n.p,{children:"第三步，引入 Vuex ；"}),"\n",(0,i.jsx)(n.p,{children:"在主入口 main.js 引入刚才新建的 store："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import Vue from 'vue'\nimport App from './App'\nimport store from './store'\n\nVue.prototype.$store = store\nVue.config.productionTip = false\n\nApp.mpType = 'app'\n\nconst app = new Vue({\n    ...App\n})\napp.$mount()\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["使用 ",(0,i.jsx)(n.code,{children:"Vue.prototype.$store = store"})," 把 ",(0,i.jsx)(n.code,{children:"store"})," 挂在到 ",(0,i.jsx)(n.code,{children:"Vue"})," 中，这样整个项目就可以共享这个 ",(0,i.jsx)(n.code,{children:"$store"})," 状态，通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 ",(0,i.jsx)(n.code,{children:"this.$store"})," 访问到。下面要在 login.vue 页面共享 ",(0,i.jsx)(n.code,{children:"isLogin"})," 登录状态；"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'\x3c!-- login.vue --\x3e\n<template>\n    <view>\n       登录状态: {{$store.state.isLogin}}\n    </view>\n</template>\n\n<script>\n    export default {\n        data() {\n            return {\n                \n            };\n        }\n    }\n<\/script>\n\n<style lang="scss">\n\n</style>\n'})}),"\n",(0,i.jsx)(n.p,{children:"第四步：访问 Vuex 定义变量。"}),"\n",(0,i.jsxs)(n.p,{children:["在应用启动情况下访问 ",(0,i.jsx)(n.code,{children:"http://localhost:8080/#/pages/login/login"})," 可以看到 login.vue 页面上的 ",(0,i.jsx)(n.code,{children:"{{$store.state.isLogin}}"})," 被渲染成了一个 ",(0,i.jsx)(n.code,{children:"false"}),"，这个 ",(0,i.jsx)(n.code,{children:"false"})," 是第一步在文件 store/index.js 中添加的 ",(0,i.jsx)(n.code,{children:"isLogin"})," 变量。"]}),"\n",(0,i.jsxs)(n.p,{children:["因为有 ",(0,i.jsx)(n.code,{children:"Vue.prototype.$store = store"})," 这样我们就可以在页面组件中以 ",(0,i.jsx)(n.code,{children:"$store"})," 访问 ",(0,i.jsx)(n.code,{children:"state"})," 定义下的所有状态变量，也就是说你可以在页面B，页面C，甚至是页面Y都可以访问到这个变量。"]}),"\n",(0,i.jsxs)(n.p,{children:["那问题来了，如果我定义的变量很多或者很长呢，这种写法 ",(0,i.jsx)(n.code,{children:"$store.state.isLogin"})," 有没有更加便捷的方法呢？请看下一步。"]}),"\n",(0,i.jsxs)(n.h2,{id:"vuex-的-state-多种用法",children:["Vuex 的 state 多种用法",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vuex-的-state-多种用法",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Vuex 封装了一些辅助函数 ",(0,i.jsx)(n.code,{children:"mapState"})," 方法，让你写的状态可以映射出来，减少查询。当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键。这样我们可以简化一下 login.vue 代码："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"\x3c!-- login.vue --\x3e\n<template>\n    <view>\n        登录状态: {{isLogin}}\n        登录状态: {{hasLogin}}\n    </view>\n</template>\n\n<script>\n    import { mapState } from 'vuex';\n    export default {\n        data() {\n            return {\n                \n            };\n        },\n        computed: mapState({\n            // 箭头函数可使代码更简练\n            isLogin: state => state.isLogin,\n        \n            // 传字符串参数 'isLogin' 等同于 `state => state.isLogin`\n            hasLogin: 'isLogin',\n        }),\n        // computed: {\n        //    ...mapState(['isLogin'])\n        // },\n    }\n<\/script>\n<style lang=\"scss\">\n\n</style>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"script"})," 中引入辅助函数 ",(0,i.jsx)(n.code,{children:"import { mapState } from 'vuex'"}),"，就可以在 ",(0,i.jsx)(n.code,{children:"computed"})," 对象中使用 ",(0,i.jsx)(n.code,{children:"mapState"})," 辅助函数了；"]}),"\n",(0,i.jsxs)(n.p,{children:["上面第一个写法中 由 ",(0,i.jsx)(n.code,{children:"state.isLogin"})," 映射到状态 ",(0,i.jsx)(n.code,{children:"isLogin"}),"，第二个写法是直接以传字符串参数的形式将Vuex的储存状态 ",(0,i.jsx)(n.code,{children:"isLogin"})," 直接映射到 ",(0,i.jsx)(n.code,{children:"hasLogin"})," ，保存后可以在浏览器看到 ",(0,i.jsx)(n.code,{children:"isLogin"})," ，",(0,i.jsx)(n.code,{children:"hasLogin"})," 渲染是一样的。好像还不够简便的样子，那来一个更简便的写法："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"computed: {\n   ...mapState(['isLogin'])\n},\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这样的形式也可以访问 ",(0,i.jsx)(n.code,{children:"isLogin"})," 状态，该写法运用了es6中的 ",(0,i.jsx)(n.code,{children:"..."})," 对象扩展运算符号，意思是里面的数组值 ",(0,i.jsx)(n.code,{children:"['isLogin']"})," 通过 ",(0,i.jsx)(n.code,{children:"mapState"})," 辅助方法映射出来之后，再通过扩展运算符一个一个对应出来，这样就可以在视图直接访问了 ",(0,i.jsx)(n.code,{children:"{{isLogin}}"}),"，如果有多个状态值（比如还有 'stateA' , 'stateB' ）就显得便捷很多了，不用写多余的方法："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"computed: {\n   ...mapState(['isLogin', 'stateA', 'stateB'])\n},\n"})}),"\n",(0,i.jsx)(n.p,{children:"上面的技术小点只是介绍如何获取 state 状态，那如果我想要改变状态呢？"}),"\n",(0,i.jsxs)(n.h2,{id:"vuex-的-mutation-用法",children:["Vuex 的 Mutation 用法",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vuex-的-mutation-用法",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["还记得我们在 store/index.js 文件中定义一个操作 ",(0,i.jsx)(n.code,{children:"isLogin"})," 状态的方法吗？"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// ...\nmutations: {\n    // 定义一个操作isLogin状态的方法\n    storeLogin (state) {\n      state.isLogin = true\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["更改 Vuex 的 store 中的状态的唯一方法是提交 mutation （在 mutations 中定义的方法），我们可以访问事件去触发 ",(0,i.jsx)(n.code,{children:"storeLogin()"})," 更改登录状态，重新回到 login.vue 页面，添加一个按钮方法去触发 ",(0,i.jsx)(n.code,{children:"storeLogin()"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"\x3c!-- login.vue --\x3e\n<template>\n    <view>\n        <view>\n            登录状态: {{isLogin}}\n        </view>\n        <button @click=\"login\">登录</button>\n    </view>\n</template>\n\n<script>\n    import { mapState } from 'vuex';\n    export default {\n        data() {\n            return {\n                \n            };\n        },\n        computed: {\n           ...mapState(['isLogin'])\n        },\n        methods: {\n            // 登录\n            login () {\n               this.$store.commit('storeLogin')\n            }\n        },\n    }\n<\/script>\n<style lang=\"scss\">\n\n</style>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["当我们点击登录按钮的时候执行 ",(0,i.jsx)(n.code,{children:"this.$store.commit('storeLogin')"})," 就可以把登录状态修改为 ",(0,i.jsx)(n.code,{children:"true"})," 了。"]}),"\n",(0,i.jsx)(n.p,{children:"我们不能直接调用一个 mutation 方法事件，我们要调用 store.commit 方法去触发，相当于中间搭了一个桥来衔接这些方法。现在想想好像是那么回事了 :)."}),"\n",(0,i.jsxs)(n.p,{children:["在程序设定开发中我们肯定会改变很多状态，不仅仅是把未登录改为登录，还会退出登录改为未登录，这样我们可以不用写一个退出登录的方法，我们直接传递一个参数过去就可以搞定了，回到 store/index.js 文件中 ",(0,i.jsx)(n.code,{children:"storeLogin()"})," 这个方法会接受 ",(0,i.jsx)(n.code,{children:"state"})," 作为第一个参数，自定义参数作为余后的参数，通常把这叫做 ",(0,i.jsx)(n.strong,{children:"载荷"})," ",(0,i.jsx)(n.code,{children:"payload"}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"import Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nconst store = ``({\n    state: {\n        isLogin: false   // 是否登录的状态，默认为未登录 false\n    },\n    mutations: {\n        // 定义一个操作isLogin状态的方法\n        storeLogin (state, payload) {\n          state.isLogin = payload\n        }\n    }\n})\n\nexport default store\n"})}),"\n",(0,i.jsx)(n.p,{children:"这样我们在 login.vue 页中就可以传参数了。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:"\x3c!-- login.vue --\x3e\n<template>\n    <view>\n        <view>\n            登录状态: {{isLogin}}\n        </view>\n        <button @click=\"login\">登录</button>\n        <button @click=\"logout\">退出</button>\n    </view>\n</template>\n\n<script>\n    import { mapState } from 'vuex';\n    export default {\n        data() {\n            return {\n                \n            };\n        },\n        computed: {\n           ...mapState(['isLogin'])\n        },\n        methods: {\n            // 登录\n            login () {\n               this.$store.commit('storeLogin', true)\n            },\n            // 退出\n            logout () {\n               this.$store.commit('storeLogin', false)\n            }\n        },\n    }\n<\/script>\n<style lang=\"scss\">\n\n</style>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["我们再添加一个退出按钮，同样调用触发 ",(0,i.jsx)(n.code,{children:"storeLogin()"})," 修改登录状态，这样只是更改参数就可以改变登录状态了，是不是很简单 :)，再优化一下代码："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'\x3c!-- login.vue --\x3e\n<template>\n    <view>\n        <view>\n            登录状态: {{isLogin}}\n        </view>\n        <button @click="login(true)">登录</button>\n        <button @click="login(false)">退出登录</button>\n        \n        <navigator url="../index/index">去首页</navigator>\n    </view>\n</template>\n\n<script>\n    import { mapState } from \'vuex\';\n    export default {\n        data() {\n            return {\n                \n            };\n        },\n        computed: {\n           ...mapState([\'isLogin\'])\n        },\n        methods: {\n            // 改变登录状态\n            login (bool) {\n               this.$store.commit(\'storeLogin\', bool)\n            },\n        },\n    }\n<\/script>\n<style lang="scss">\n\n</style>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["并修改下首页，让首页也可以访问登录状态 ",(0,i.jsx)(n.code,{children:"isLogin"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-html",children:'\x3c!-- 首页 index.vue --\x3e\n<template>\n    <view class="content">\n        <view class="text-area">\n            <text class="title">当前是首页</text>\n            <view>\n                登录状态: {{isLogin}}\n            </view>\n        </view>\n    </view>\n</template>\n\n<script>\n    import { mapState } from \'vuex\';\n    export default {\n        data() {\n            return {\n                \n            };\n        },\n        computed: {\n           ...mapState([\'isLogin\'])\n        },\n        methods: {\n            \n        },\n    }\n<\/script>\n<style>\n    \n</style>\n'})}),"\n",(0,i.jsx)(n.p,{children:"在浏览器运行一下，你就可以尝试改变登录状态的时候去首页查看，发现首页也是登录的。如果你做到了，恭喜你，你已经掌握了 Vuex 了。"}),"\n",(0,i.jsx)(n.p,{children:"Vuex 还有 Action 概念，可以包含任意异步操作，如果你使用了异步操作，直接调用 mutation 里面的方法可能并不会成功，因为 mutation 必须同步执行。"}),"\n",(0,i.jsx)(n.p,{children:"如果你的应用模块足够多的话，可以以模块的方式管理这些，比如客户模块，商品模块，这样这些状态就可以轻松管理了。整个项目，无论是页面还是组件都可以用上面提到的方式访问到 state 和修改 state。"}),"\n",(0,i.jsx)(n.p,{children:"然后再回顾一下这篇文章的第一个图，你就能轻松了解 Vuex 的机制了。"}),"\n",(0,i.jsxs)(n.p,{children:["想要查看更多的理论知识可以查看",(0,i.jsx)(n.a,{href:"https://vuex.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer",children:"官网 vuex"}),"。"]}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结：",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Vuex 是一个专为应用程序开发的状态管理模式。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。我们不能直接调用一个 mutation 方法事件，我们要调用 store.commit 方法去触发，相当于中间搭了一个桥来衔接这些方法。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"合理的使用 Vuex 可以让我们友好便捷的管理状态，不仅是登录状态，可以是用户信息，可以是一个修改标记，如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。我们不能为了技术而技术。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["本章代码 ",(0,i.jsx)(n.a,{href:"https://github.com/front-end-class/uniapp-music-code/blob/master/uni-course-vuex.zip",target:"_blank",rel:"noopener noreferrer",children:"uni-course-vuex"})]}),"\n"]}),"\n"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Uniapp%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%2F9%20%E5%9F%BA%E7%A1%808%EF%BC%9AVuex%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1.md"]={toc:[{text:"什么是 Vuex？",id:"什么是-vuex",depth:2},{text:"Vuex 的基础使用（创建一个改变登录状态的应用）",id:"vuex-的基础使用创建一个改变登录状态的应用",depth:2},{text:"Vuex 的 state 多种用法",id:"vuex-的-state-多种用法",depth:2},{text:"Vuex 的 Mutation 用法",id:"vuex-的-mutation-用法",depth:2},{text:"小结：",id:"小结",depth:2}],title:"9 基础8：Vuex快速掌握",headingTitle:"9 基础8：Vuex快速掌握",frontmatter:{}}}}]);