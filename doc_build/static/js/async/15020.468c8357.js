"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["15020"],{567202:function(e,n,t){e.exports=t.p+"static/image/0ccb657605f324b985420625854fbfa6.373e5ea9.webp"},175153:function(e,n,t){e.exports=t.p+"static/image/17d7bc8e4d7d886aca5faf9e8a1e5f51.5a871d3a.webp"},888476:function(e,n,t){e.exports=t.p+"static/image/3df8618d92f2e11fcf5cdc99466ffd55.da1c58d0.webp"},648800:function(e,n,t){e.exports=t.p+"static/image/7e533706fb66f6f55ed9765de95102dc.c8c223ba.webp"},619495:function(e,n,t){t.r(n),t.d(n,{default:()=>m});var r=t(552676),s=t(740453);let a=t.p+"static/image/f376b42238fc2d239ef72d64e9290d3d.7cb6118b.webp",d=t.p+"static/image/deffa66febfac850fe03a0367aaa08ac.1fa6a9aa.webp";var i=t(888476),o=t(648800),c=t(175153);let l=t.p+"static/image/719c8ceeeee275d9c87c199215080fc7.61cf6195.webp",p=t.p+"static/image/2f4689eaa86c7171c4e6f5637215dceb.1d02f4a7.webp";var h=t(567202);function u(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",blockquote:"blockquote",pre:"pre",code:"code",h3:"h3",strong:"strong",img:"img",ul:"ul",li:"li",h4:"h4"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"11业务篇-简历制作之数据的录入与展示",children:["11.业务篇-简历制作之数据的录入与展示",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11业务篇-简历制作之数据的录入与展示",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上一章节我们实现了点击工具条模块，显示弹窗，弹窗内通过 MyInput 组件展示当前的数据内容，本章节我们将实现简单数据录入与复杂数据的录入。如果你忘记了这块的内容知识，请回到 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962435230061821952",target:"_blank",rel:"noopener noreferrer",children:"设计篇-需求功能设计与数据存储方案设计"}),"重温一下知识。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"本章节篇幅较长，但属于项目中的重中之重，希望你能耐心往下看"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"useupdateresumehook",children:["useUpdateResumeHook",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useupdateresumehook",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"数据录入的本质是获取修改后的内容值，通过 dispatch 一个 Action，将 redux 中对应的数据替换，即可完成录入功能。"}),"\n",(0,r.jsx)(n.p,{children:"前面讲到组件颗粒化，事实上我们也是按照颗粒化思想去拆分组件的，到这你会发现，每个组件都履行着各自职责，此时如果对简历数据进行修改，最终的结果是：修改逻辑均散落在各自组件中。动动我们的小脑袋瓜，我们是否可以封装一个通用方法，所有修改简历数据都只能通过此方法，传入需要修改的 key 和 newValue，才能操作 redux 修改数据值？于是 useUpdateResumeHook 诞生了。"}),"\n",(0,r.jsx)(n.p,{children:"我们在 ResumeContent 文件夹下，新增一代码文件，取名为：useUpdateResumeHook.ts，下面以修改个人基本信息为例，编写我们的相关代码"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// app/renderer/container/resume/ResumeContent/useUpdateResumeHook.ts\nimport { useSelector, useDispatch } from 'react-redux';\n\n/**\n * @description 更新简历信息，这是修改 redux 简历信息的唯一方法\n * @param {string[]} stateKey 关键key，如路径为 [base/username] 表示修改 base 对象下的 username\n * @param {string} stateValue\n */\nfunction useUpdateResumeHook() {\n  const updatePersonalHook = useUpdatePersonalHook();\n  return <T>(stateKey: string, stateValue: T) => {\n    const keys = stateKey.split('/') || [];\n    if (keys[0]) {\n      if (keys[0] === 'base') updatePersonalHook(keys[1], stateValue);\n    }\n  };\n}\n\n/**\n * @description 修改个人信息（base）\n */\nfunction useUpdatePersonalHook() {\n  const dispatch = useDispatch();\n  const base: TSResume.Base = useSelector((state: any) => state.resumeModel.base);\n  return <T>(stateKey: string, stateValue: T) => {\n    dispatch({\n      type: 'resumeModel/setStore',\n      payload: {\n        key: 'base',\n        values: {\n          ...base,\n          [stateKey]: stateValue,\n        },\n      },\n    });\n  };\n}\n\nexport default useUpdateResumeHook;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["以上就完成了个人基本信息模块的更新（如何使用该 Hook 请往下看），更多模块信息的 hook 实现，小伙伴们可前往 github 阅读相关代码 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/blob/chapter-11/app/renderer/container/resume/ResumeContent/useUpdateResumeHook.ts",target:"_blank",rel:"noopener noreferrer",children:"\uD83D\uDC49 chapter-11 useUpdateResumeHook"})]}),"\n",(0,r.jsxs)(n.h2,{id:"简单数据录入",children:["简单数据录入",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简单数据录入",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"怎样才能被称为简单数据？在我们定义的简历数据类型约束上，属于简单数据类型如姓名、邮箱、电话等相关字段，在这我将它归为简单数据。"}),"\n",(0,r.jsx)(n.p,{children:"下面我们举几个例子，来实现简单数据的录入。"}),"\n",(0,r.jsxs)(n.h3,{id:"简历头像上传",children:["简历头像上传",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简历头像上传",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们进入 /UseTemplate/templateOne/components/Avatar 组件，通过已封装好的 ",(0,r.jsx)(n.code,{children:"<ImageUpload />"})," 组件实现选中图片，该组件的 ",(0,r.jsx)(n.code,{children:"onAfterChange"})," 事件会抛出一个文件数组，数组第一项就是我们的图片文件信息。通过调用 useUpdateResumeHook 进行修改简历头像链接地址（下面是伪代码）"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"/**\n * @desc 头像\n * @author pengdaokuan\n * @link container/resume/ResumeContent/UseTemplate/templateOne/components/Avatar/index.tsx\n */\nimport useUpdateResumeHook from '@src/container/resume/ResumeContent/useUpdateResumeHook';\n\nfunction Avatar() {\n  const updateResumeHook = useUpdateResumeHook();\n  const base: TSResume.Base = useSelector((state: any) => state.resumeModel.base);\n\n  // \uD83D\uDC47 更新用户的简历头像\n  const onUpdateUserAvatar = (avatarUrl: string) => {\n    updateResumeHook<string>('base/avatar', avatarUrl);\n  };\n\n  return (\n    <div styleName=\"box\">\n      {!base?.avatar && (\n        <ImageUpload\n          icon={uploadIcon}\n          accept=\"image/*\"\n          multiple={false}\n          onAfterChange={(files: TSUpload.File[]) => {\n            onUpdateUserAvatar(files[0]?.base64URL);\n          }}\n        />\n      )}\n      {base?.avatar && (\n        // \uD83D\uDC49 展示我们的头像...（伪代码，省略）\n      )}\n    </div>\n  );\n}\n\nexport default Avatar;\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"个人信息数据录入",children:["个人信息数据录入",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#个人信息数据录入",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"还记得上一章节我们添加了许多表单弹窗组件吧？我们选择进入个人信息的表单弹窗，赐予它修改简历数据的力量。我们来修改相关代码（下面是伪代码）"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'/**\n * @description 个人信息Form\n * @author pengdaokuan\n * @link /container/resume/ResumeContent/UseForm/Personal/index.tsx\n */\nimport useUpdateResumeHook from \'@src/container/resume/ResumeContent/useUpdateResumeHook\';\n\nfunction Personal() {\n  // \uD83D\uDC47 唯一能修改我们简历数据的方式\n  const updateResumeHook = useUpdateResumeHook();\n  const hobby: string = useSelector((state: any) => state.resumeModel.hobby);\n  const base: TSResume.Base = useSelector((state: any) => state.resumeModel.base);\n\n  return (\n    <MyModal.Dialog>\n      <div styleName="form">\n        <div styleName="flex">\n          <div styleName="left">\n            <span styleName="require">*</span>姓 名 ：\n          </div>\n          <div styleName="right">\n            <MyInput\n              onChange={(e) => {\n                // \uD83D\uDC47 修改个人基本信息中的姓名字段数据\n                updateResumeHook(\'base/username\', e.target?.value || \'\');\n              }}\n              value={base?.username || \'\'}\n              placeholder="请输入姓名"\n              allowClear={true}\n            />\n          </div>\n        </div>\n      </div>\n    </MyModal.Dialog>\n  );\n}\n\nexport default Personal;\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"更多简单数据录入",children:["更多简单数据录入",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更多简单数据录入",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["《论语\xb7述而》有记载：",(0,r.jsx)(n.strong,{children:"举一隅不以三隅反，则不复也"}),"。当你掌握了简单数据录入的核心流程之后，对于同数据类型的修改，对你而言不是什么大问题了。"]}),"\n",(0,r.jsx)(n.p,{children:"无非就是引入 useUpdateResumeHook，然后在 MyInput 输入框组件的 onChange 事件中，调此 hook，传入正确的参数，即可实现简历数据的更新录入。"}),"\n",(0,r.jsx)(n.p,{children:"对于更多简单数据的录入，这里将不再叙述，小伙伴们可私下独自完成或配合代码加以实现。"}),"\n",(0,r.jsxs)(n.h2,{id:"复杂数据录入",children:["复杂数据录入",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#复杂数据录入",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"怎样才能被称为复杂数据？项目经验、工作经验、在校经验等，我们很容易就能想到，这些肯定不是一个简单数据类型，他们是一个数组，数组中的每一项对应一次“非凡”的体验；"}),"\n",(0,r.jsxs)(n.p,{children:["在",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962435230061821952",target:"_blank",rel:"noopener noreferrer",children:"设计篇"}),"为大家中，已经明确通过类似“文档笔记”的交互效果实现复杂数据录入。我们再来看看效果图"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h3,{id:"项目经验数据录入",children:["项目经验数据录入",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#项目经验数据录入",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们将在这有限的弹窗空间中，做一些有趣的事情，先看看组件分层图"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"从图中我们可以很快知道，以弹窗内容区域为主，向左划分部分区域，用于条目列表的展示，以内容编辑为利器，占领右侧，两者结合，实现最佳效果。"}),"\n",(0,r.jsxs)(n.p,{children:["小伙伴们看完这图，不要着急去写代码，让我们再想想，如何开发会更好，毕竟可预见的后果是：工作经验、在校经验等也是一样的展示效果和交互体验，",(0,r.jsx)(n.strong,{children:"后人哀之而不鉴之,亦使后人而复哀后人也"}),"！设计如果不够好，则后期开发相同模块时会大大提高代码量和使用成本。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们要明白，这里面的核心思想：",(0,r.jsx)(n.strong,{children:"变与不变"}),"。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"何为变？上图中变的是左侧列表条目展示的数据源，表单内容信息的展示（也能称之为数据源）"}),"\n",(0,r.jsx)(n.li,{children:"谁能不变？条目的布局定位，UI 效果，交互效果，删除条目、新增条目、切换条目等这些都不会随着我们的数据源改变而改变。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我期望：业务开发过程中，只需要传入数据源 dataList 与表单组件 Form，就能达到我想要的效果。"}),"\n",(0,r.jsx)(n.p,{children:"我目前尝试过三种方案，下面给小伙伴们简单聊一下我的想法"}),"\n",(0,r.jsxs)(n.h4,{id:"方案一不通用各做各的",children:["方案一：不通用，各做各的",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方案一不通用各做各的",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"意思就是我们不将通用的逻辑抽出来（切换条目、删除条目等），等价于每个模块对应一套 EditorForm，如项目经验，就叫 ProjectEditorForm，工作经历就称为 WorkEditorForm。"}),"\n",(0,r.jsx)(n.p,{children:"该方案好处就是，各模块之间互不影响，代码阅读上相对直观；缺点就是存在重复代码逻辑，同时在将来相似模块，使用成本较大。"}),"\n",(0,r.jsxs)(n.h4,{id:"方案二hoc-高阶组件",children:["方案二：HOC 高阶组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方案二hoc-高阶组件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"核心思想是：封装一个高阶组件 ExperienceHoc，之后所有的 Form 都通过高阶组件进行组合"}),"\n",(0,r.jsxs)(n.p,{children:["该方案好处就是，所有逻辑如切换条目、删除条目等都抽离到 Hoc 处理，",(0,r.jsx)(n.code,{children:"Form 组件只需展示当前选中的条目数据与修改当前条目数据"}),"。但问题在于，我们的 Form 组件展示的数据是从 Hoc 传递而来，也许这么讲不够形象，下面结合图片与伪代码，帮助大家理解一下。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["图一大家能直观看懂，我们来说图二，从数据层面上看，我们在业务组件 Form 中，直连 Redux，然后将数据源 dataList 传给 ExperienceHoc，并定义一个方法，即数据修改之后的回传方法 updateDataList。我们的 Form 组件需展示当前选中的某条 Item 数据，而当前选中哪条数据是在 Hoc 中操作，然后传递给 Form 组件的，所以需要在 Hoc 中给我们的 Form 组件注入数据源。最终我们的代码如下所示。",(0,r.jsx)(n.strong,{children:"一定要看注释！！！"})]}),"\n",(0,r.jsx)(n.p,{children:"下面是 ExperienceHoc 的伪代码"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// 编辑器 HOC\nconst ExperienceHoc = (WrappedComponent: React.ComponentType | any) => ({ dataList, updateDataList }: HocProps) => {\n  return class extends React.Component {\n    constructor() {\n      this.state = {\n        currentItem: null,\n      };\n    }\n\n    // \uD83D\uDC47 1. 一顿逻辑操作，给 currentItem 赋值，表示当前选中的条目，代码略过\n    // \uD83D\uDC47 2. 给 Form 组件注入该数据源！！！！\n    getProps = () => ({\n      ...this.props,\n      currentItem: this.state.currentItem,\n      onChangeCurrentItem: this.onChangeCurrentItem\n    });\n     // \uD83D\uDC47 3. Form 组件中修改当前条目数据源\n    onChangeCurrentItem = () = {\n      // 当条数据源更新，同步更新整个数组，执行updateDataList方法！！！！！！\n    }\n\n    render() {\n      return (\n        <div styleName="editor-box">\n          <WrappedComponent {...this.getProps()} />\n        </div>\n      );\n    }\n  };\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"接下来我们看看业务组件 Form 如何使用该高阶组件"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 项目经验的 Form\nimport { useSelector } from 'react-redux';\n// \uD83D\uDC47 1. 引入高阶组件\nimport ExperienceHoc from '../ExperienceHoc';\nimport MyInput from '@common/components/MyInput';\n// \uD83D\uDC47 2. 引入修改简历数据的 Hooks\nimport useUpdateResumeHook from '@src/container/resume/ResumeContent/useUpdateResumeHook';\n// \uD83D\uDC47 3. 这里需要定义接收的 Props，事实上，这些 props 是高阶组件传的\nfunction ProjectForm({ currentItem, onChangeCurrentItem }) {\n  const updateResumeHook = useUpdateResumeHook();\n  const projectExperience = useSelector((state: any) => state.resumeModel.projectExperience);\n\n  return (\n    <MyInput\n      onChange={(e) => {\n        onChangeCurrentItem(e.target.value);\n      }}\n      value={currentItem?.projectName}\n      placeholder=\"请输入项目名\"\n      allowClear={true}\n    />\n  );\n}\n\n// \uD83D\uDC47 传递数据源\nexport default ExperienceHoc(ProjectForm)({\n  dataList: projectExperience,\n  updateDataList: (newDataList) => updateResumeHook(newDataList),\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"这种方式虽然也能实现我们的功能，但我在想是否还能改变一下写法？"}),"\n",(0,r.jsxs)(n.h4,{id:"方案三render-props-混合嵌套",children:["方案三：render Props 混合嵌套",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方案三render-props-混合嵌套",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["其实本质上，无论用什么方案，我们都避免不了一点的是：",(0,r.jsx)(n.code,{children:"往 Form 组件上注入 props"}),"，这是必须的，只是在编写代码的时候，哪种方式更加优雅，我们希望的是把非业务相关的代码隔离出去，我们只在乎 Form 组件里的数据展示和更改。"]}),"\n",(0,r.jsx)(n.p,{children:"下面是我想到的另一方式，先看代码，我们封装一个通用组件，暂且称为：WrapperExperience"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// ResumeContent/UseForm/WrapperExperience/index.tsx\nfunction WrapperExperience({ children, dataList, updateDataList }: IProps) {\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [currentItem, setCurrentItem] = useState(null);\n  // \uD83D\uDC47 1. 内部维护 currentIndex，根据索引从数组 dataList 中获取数据\n  // 一顿逻辑操作，给 currentItem 赋值，表示当前选中的条目，代码略过\n\n  // \uD83D\uDC47 2. 定义 Form 组件中修改当前条目数据源的方法\n  const onChangeCurrentItem = useCallback((newValue = {\n    // 当条数据源更新，同步更新整个数组，执行updateDataList方法！！！！！！\n  }), [currentItem]);\n\n  const newChildren = useMemo(() => {\n    return React.Children.map(children, (child) => {\n      if (React.isValidElement(child)) {\n        // \uD83D\uDC47 3. 核心在于，给子组件注入两个属性：当前条目与修改当前条目的方法\n        return React.cloneElement(child, {\n          currentItem: currentItem,\n          onChangeCurrentItem: onChangeCurrentItem,\n        });\n      }\n      return child;\n    });\n  }, [children, dataList]);\n\n  return <div styleName="wrapper">{newChildren}</div>;\n}\n\nexport default WrapperExperience;\n'})}),"\n",(0,r.jsx)(n.p,{children:"在业务使用上，也极为方便"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import MyModal from '@common/components/MyModal';\nimport Form from './Form';\nimport WrapperExperience from '../WrapperExperience';\nimport useUpdateResumeHook from '@src/container/resume/ResumeContent/useUpdateResumeHook';\n\nfunction ProjectExperience({ onClose }: IProps) {\n  const updateResumeHook = useUpdateResumeHook();\n  const projectExperience = useSelector((state: any) => state.resumeModel.projectExperience);\n\n  const updateDataList = (newDataList: any[]) => updateResumeHook(newDataList);\n\n  return (\n    <MyModal.Dialog title=\"项目经验\">\n      <WrapperExperience dataList={projectExperience} updateDataList={updateDataList}>\n        <Form />\n      </WrapperExperience>\n    </MyModal.Dialog>\n  );\n}\n\nexport default ProjectExperience;\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 Form 组件上，通过 props 获取数据即可。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function Form({ currentItem, onChangeCurrentItem }: IProps) {}\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"如果有更好方案的小伙伴，可以在评论区中留言，我们一起探讨～"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"其实该方案与 ExperienceHoc 高阶组件的方案并没有什么区别，核心还是给 Form 注入参数和方法，下面我将采用方案三，实现我们复杂数据的录入。"}),"\n",(0,r.jsxs)(n.h4,{id:"功能一适配器",children:["功能一：适配器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能一适配器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"怎么理解呢？在简历数据的类型定义上，存在兴许的差异，比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"interface SchoolExperience extends Experience {\n  department?: string; // 部门\n}\ninterface ProjectExperience extends Experience {\n  projectName?: string; // 项目名\n}\ninterface ProjectExperience extends Experience {\n  companyName?: string; // 公司名\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但是在条目列表中，它都属于 ",(0,r.jsx)(n.code,{children:"条目标题"}),"（能理解吗？小伙伴们），所以需要做成适配，将它适配成条目所需要的接口数据（",(0,r.jsx)(n.strong,{children:"适配器模式"}),"）下面我们实现一下适配器，具体代码在这里：",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/blob/chapter-11/app/renderer/container/resume/ResumeContent/UseForm/WrapperExperience/adapter.ts",target:"_blank",rel:"noopener noreferrer",children:"\uD83D\uDC49 adapter experience"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 具体代码前往GitHub阅读\nconst AdapterExperience = {\n  /**\n   * @description 项目经验\n   */\n  project(list: TSResume.ProjectExperience[]): AdapterExperienceType[] {},\n  /**\n   * @description 工作经验\n   */\n  work(list: TSResume.WorkExperience[]): AdapterExperienceType[] {},\n  /**\n   * @description 在校经验\n   */\n  school(list: TSResume.SchoolExperience[]): AdapterExperienceType[] {},\n};\n\nexport default AdapterExperience;\n"})}),"\n",(0,r.jsx)(n.p,{children:"在业务组件，只需要调用适配器进行转一下数据结构即可。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// 项目经验\nfunction ProjectExperience({ onClose }: IProps) {\n  const updateResumeHook = useUpdateResumeHook();\n  const projectExperience = useSelector((state: any) => state.resumeModel.projectExperience);\n\n  const updateDataList = (newDataList: AdapterExperienceType[]) => {\n    // \uD83D\uDC49 该数据为操作之后的最新数据源，将该数据进行操作并存入 Redux\n  };\n\n  return (\n    <MyModal.Dialog title="项目经验">\n      <Wrapper\n        // \uD83D\uDC47 数据经过适配器进行组件数据的适配\n        dataList={AdapterExperience.project(projectExperience)}\n        updateDataList={updateDataList}\n      >\n        <Form />\n      </Wrapper>\n    </MyModal.Dialog>\n  );\n}\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"功能二添加条目",children:["功能二：添加条目",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能二添加条目",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"添加条目不困难，只是需要考虑的一点是：编辑态下的新增条目，需要如何处理？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const onAddItem = () => {\n  // 1. 如果当前属于编辑态\n  if (editModal.status) {\n    onToggleEditModal({\n      showByCancel: true, // 当取消编辑内容，弹窗显示\n      onAfterFn: () => { // 确定取消，则新增条目\n        const newList = onAddExperience(experienceList);\n        if (newList.length > 0) {\n          // 定位激活刚添加的这条数据\n          setCurrentIndex(0);\n          setExperienceList(newList);\n          updateDataList && updateDataList(newList);\n        }\n      },\n    });\n  } else {\n    // 2. 不属于编辑态\n    const newList = onAddExperience(experienceList);\n    if (newList.length > 0) {\n      // 定位激活刚添加的这条数据\n      setCurrentIndex(0);\n      setExperienceList(newList);\n      updateDataList && updateDataList(newList);\n    }\n  }\n};\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"功能三切换条目",children:["功能三：切换条目",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能三切换条目",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"同上，我们切换条目时，并不复杂，唯一需要做的是：编辑态下的切换条目，如何处理？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const onChangeItem = useCallback(\n  (index: number) => {\n    // 5.1 当前正在编辑状态\n    if (editModal.status) {\n      onToggleEditModal({\n        showByCancel: true, // 当取消编辑内容，弹窗显示\n        onAfterFn: () => { // 确定取消，则新增条目\n          setCurrentIndex(index);\n        },\n      });\n    } else {\n      setCurrentIndex(index);\n    }\n  },\n  [editModal]\n);\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"功能四删除条目",children:["功能四：删除条目",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能四删除条目",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"删除之前，一样需要对编辑态的判断"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 1. 点击删除条目\nconst onDeleteItem = (index: number) => {\n  setDeleteModal({\n    show: true,\n    deleteIndex: index,\n  });\n};\n// 2. 删除弹窗的取消按钮回调\nconst onDeleteCancel = useCallback(() => {\n  setDeleteModal({\n    show: false,\n    deleteIndex: -1,\n  });\n}, [currentIndex, deleteModal]);\n// 3. 删除弹窗的确定按钮回调\nconst onDeleteOk = useCallback(() => {\n  const newList = onDeleteExperience(deleteModal.deleteIndex, experienceList);\n  if (newList.length > 0) setCurrentIndex(0);\n  else setCurrentIndex(-1);\n  setDeleteModal({\n    show: false,\n    deleteIndex: -1,\n  });\n  setExperienceList(newList);\n  updateDataList && updateDataList(newList);\n}, [currentIndex, deleteModal]);\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"功能五编辑条目",children:["功能五：编辑条目",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能五编辑条目",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这里很有意思的一点是：编辑态下的输入框可输入，非编辑态下的输入框处于 disabled 禁止状态。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"对当前正编辑的条目来说，只有当点击“保存”之后，才能将编辑后的数据更新至数据源，故而需要一个临时值缓存编辑后的数据。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"如果不这么做，会导致一个 Bug : 编辑后的数据直接在数据源中更新，当点击“取消”按钮并确定放弃当前编辑的内容时。我们期望此次的内容并不被更新进数据源，但实际上，当前编辑的内容早已被同步修改到数据源了。"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// 修改当前条目内容\nconst onChangeCurrentItem = useCallback((newItem: AdapterExperienceType) => {\n  // \uD83D\uDC47 临时存储当前编辑的内容数据\n  onToggleEditModal({\n    tempSaveItem: { ...newItem },\n  });\n  setCurrentItem(newItem);\n}, [children, onToggleEditModal]);\n\n// 当点击“保存”按钮时触发\nconst onSaveEditValue = useCallback(() => {\n  let newList = [...experienceList];\n  let item = editModal?.tempSaveItem\n    ? { ...editModal?.tempSaveItem }\n    : { ...currentItem };\n  newList[currentIndex] = item;\n  setExperienceList(newList);\n  updateDataList && updateDataList(newList);\n  onToggleEditModal({\n    status: false,\n  });\n}, [editModal?.tempSaveItem, currentIndex, onToggleEditModal]);\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"功能六数据同步-redux",children:["功能六：数据同步 Redux",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能六数据同步-redux",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们通过 ",(0,r.jsx)(n.code,{children:"updateDataList"})," 将最新的数据返回给业务层，我们只需要在业务层将数据同步到 Redux 即可，下面看看代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// \uD83D\uDC47 调用写好修改 redux 的 hooks 操作修改项目经验\nconst updateDataList = (newDataList: AdapterExperienceType[]) => {\n  updateResumeHook<AdapterExperienceType[]>('projectExperience', newDataList);\n};\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"简历数据在模版上同步展示",children:["简历数据在模版上同步展示",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简历数据在模版上同步展示",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面完成了简单数据和复杂数据的录入，接下来我们需要将录入的数据在简历模版上进行展示。"}),"\n",(0,r.jsxs)(n.p,{children:["进入 ",(0,r.jsx)(n.code,{children:"/ResumeContent/UseTemplate/templateOne"})," 组件下，我们对每个组件都直连 redux 取对应数据值，对数据进行判断，下面展示联系方式部分代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'/**\n * @desc 联系方式\n * @author pengdaokuan\n */\nimport { useSelector } from \'react-redux\';\n\nfunction Contact() {\n  const contact: TSResume.Contact = useSelector((state: any) => state.resumeModel.contact);\n  return (\n    <div styleName="container">\n      <p styleName="title">联系方式 Contact</p>\n      <ul styleName="content">\n        {contact?.phone && <li>电话：{contact?.phone}</li>}\n        {contact?.email && <li>邮箱：{contact?.email}</li>}\n      </ul>\n    </div>\n  );\n}\n\nexport default Contact;\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章节主要给大家介绍在项目中，简单数据与复杂数据的录入，具体逻辑小伙伴们直接去阅读相关代码，看代码会更加直观。"}),"\n",(0,r.jsxs)(n.p,{children:["相关代码：",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/chapter-11/app/renderer/container/resume/ResumeContent/UseForm/WrapperExperience",target:"_blank",rel:"noopener noreferrer",children:"\uD83D\uDC49 WrapperExperience"})]}),"\n",(0,r.jsx)(n.p,{children:"更多的是在实现上的思考，当然也不一定代表我的设计是正确的，有更好的欢迎小伙伴们提出，我们一起探讨。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"如果您在边阅读边实践时，发现代码报错或者 TS 报错，那么小伙伴们可以根据报错信息，去线上看看相应的代码。"})}),"\n",(0,r.jsx)(n.p,{children:"如果对本章节存在疑问，欢迎在评论区留言。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}let m=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F11.%E4%B8%9A%E5%8A%A1%E7%AF%87-%E7%AE%80%E5%8E%86%E5%88%B6%E4%BD%9C%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%95%E5%85%A5%E4%B8%8E%E5%B1%95%E7%A4%BA.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"useUpdateResumeHook",id:"useupdateresumehook",depth:2},{text:"简单数据录入",id:"简单数据录入",depth:2},{text:"简历头像上传",id:"简历头像上传",depth:3},{text:"个人信息数据录入",id:"个人信息数据录入",depth:3},{text:"更多简单数据录入",id:"更多简单数据录入",depth:3},{text:"复杂数据录入",id:"复杂数据录入",depth:2},{text:"项目经验数据录入",id:"项目经验数据录入",depth:3},{text:"方案一：不通用，各做各的",id:"方案一不通用各做各的",depth:4},{text:"方案二：HOC 高阶组件",id:"方案二hoc-高阶组件",depth:4},{text:"方案三：render Props 混合嵌套",id:"方案三render-props-混合嵌套",depth:4},{text:"功能一：适配器",id:"功能一适配器",depth:4},{text:"功能二：添加条目",id:"功能二添加条目",depth:4},{text:"功能三：切换条目",id:"功能三切换条目",depth:4},{text:"功能四：删除条目",id:"功能四删除条目",depth:4},{text:"功能五：编辑条目",id:"功能五编辑条目",depth:4},{text:"功能六：数据同步 Redux",id:"功能六数据同步-redux",depth:4},{text:"简历数据在模版上同步展示",id:"简历数据在模版上同步展示",depth:2},{text:"总结",id:"总结",depth:2}],title:"11.业务篇-简历制作之数据的录入与展示",headingTitle:"11.业务篇-简历制作之数据的录入与展示",frontmatter:{}}}}]);