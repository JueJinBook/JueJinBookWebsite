"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["20746"],{242880:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var s=t(552676),r=t(740453);let o=t.p+"static/image/2ca2db6a6217a144cb6faa943bf0b4df.00e67df6.webp",c=t.p+"static/image/361c7eba46f183017dc55b33252ece9f.33f5c1de.webp",a=t.p+"static/image/0bb4df83340931cbd31cb90560e66a71.9da547d5.webp",i=t.p+"static/image/7a207c2553796a8cc7a3ef23b14c21c6.f2deebaf.webp";function l(e){let n=Object.assign({p:"p",strong:"strong",code:"code",a:"a",img:"img",h1:"h1",pre:"pre",blockquote:"blockquote",h2:"h2",ol:"ol",li:"li",ul:"ul",h3:"h3"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["大家好，我是小杜杜，在 React v18 中提供了一个全新的 Hooks：",(0,s.jsx)(n.strong,{children:"useSyncExternalStore"}),"，它会通过",(0,s.jsx)(n.strong,{children:"强制的同步状态"}),"更新，使得外部 ",(0,s.jsx)(n.code,{children:"store"})," 可以支持并发读取。"]}),"\n",(0,s.jsxs)(n.p,{children:["实际上 useSyncExternalStore 是 useMutableSource 演变而来，主要解决",(0,s.jsx)(n.strong,{children:"外部数据撕裂"}),"的问题，并且官方明确指出它是提供给三方库（如：",(0,s.jsx)(n.code,{children:"redux"}),"、",(0,s.jsx)(n.code,{children:"mobx"}),"）使用，而非日常开发中使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["但在 React 文档中（",(0,s.jsx)(n.a,{href:"https://react.dev/reference/react/useSyncExternalStore#subscribing-to-a-browser-api",target:"_blank",rel:"noopener noreferrer",children:"Subscribing to a browser API"}),"）发现这样一段话："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["大致意思说：添加 useSyncExternalStore 另一个原因是使用浏览器的某些值时，这个值可能在",(0,s.jsx)(n.strong,{children:"将来某个时刻发生变化"}),"，如：网络连接的状态（",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Navigator/onLine",target:"_blank",rel:"noopener noreferrer",children:"navigator.onLine"}),"），此时更加推荐使用 useSyncExternalStore。"]}),"\n",(0,s.jsx)(n.p,{children:"通过上面这段话，可以得出 useSyncExternalStore 解决外部数据撕裂中的“外部”不仅仅是“第三方库”，也有可能是“浏览器“。当我们需要访问 windows 对象上的一些值时，也需要它的帮助。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"useSyncExternalStore.png"})}),"\n",(0,s.jsxs)(n.h1,{id:"14源码篇探索-usesyncexternalstore-的神秘面纱",children:["14.源码篇｜探索 useSyncExternalStore 的神秘面纱",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14源码篇探索-usesyncexternalstore-的神秘面纱",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们先来看看官网的示例：在 useSyncExternalStore 的基础上封装了 useOnlineStatus，去检查网络连接的状态："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// useOnlineStatus\nimport { useSyncExternalStore } from "react";\n\nexport function useOnlineStatus() {\n  const isOnline = useSyncExternalStore(subscribe, getSnapshot);\n  return isOnline;\n}\n\nfunction getSnapshot() {\n  return navigator.onLine;\n}\n\nfunction subscribe(callback: any) {\n  window.addEventListener("online", callback);\n  window.addEventListener("offline", callback);\n  return () => {\n    window.removeEventListener("online", callback);\n    window.removeEventListener("offline", callback);\n  };\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// Index\nimport { useOnlineStatus } from "./useOnlineStatus";\n\nfunction StatusBar() {\n  const isOnline = useOnlineStatus();\n  return <h1>{isOnline ? "✅ Online" : "❌ Disconnected"}</h1>;\n}\n\nfunction SaveButton() {\n  const isOnline = useOnlineStatus();\n\n  function handleSaveClick() {\n    console.log("✅ Progress saved");\n  }\n\n  return (\n    <button disabled={!isOnline} onClick={handleSaveClick}>\n      {isOnline ? "Save progress" : "Reconnecting..."}\n    </button>\n  );\n}\n\nconst Index = () => {\n  return (\n    <>\n      <SaveButton />\n      <StatusBar />\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"useSyncExternalStore API 在第四章中介绍过，这里就不过多赘述。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["useSyncExternalStore 解决的问题是",(0,s.jsx)(n.strong,{children:"数据撕裂"}),"问题，那么什么是数据撕裂呢？一起来看看。"]}),"\n",(0,s.jsxs)(n.h2,{id:"什么是数据撕裂",children:["什么是数据撕裂？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是数据撕裂",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"撕裂："})," 是图形编程中的一个传统术语，是指视觉上的不一致（参考：",(0,s.jsx)(n.a,{href:"https://github.com/reactwg/react-18/discussions/69",target:"_blank",rel:"noopener noreferrer",children:"#What is tearing?"}),"）。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 React v18 中增加",(0,s.jsx)(n.strong,{children:"并发"}),"机制，换句话说，React 由之前的",(0,s.jsx)(n.strong,{children:"同步渲染"}),"变为了",(0,s.jsx)(n.strong,{children:"并发渲染"}),"，接下来一起看看两者在渲染上的区别。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"同步渲染："})}),"\n",(0,s.jsx)(n.p,{children:"当我们渲染 React 树时，通过 external store 提供数据，如下图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"同步渲染流程如下："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"第一张图，当 external store 的数据变为蓝色，React 树开始渲染，对应的组件变为了蓝色。"}),"\n",(0,s.jsx)(n.li,{children:"第二张图，由于 JS 是单线程的，所以会一直执行下去，此时的组件都会取到 external store 对应的颜色。所以在第三张图中，我们可以看到所有的组件都渲染成了蓝色，UI 显示的状态始终与 external store 的颜色一致。"}),"\n",(0,s.jsxs)(n.li,{children:["第四张图，",(0,s.jsx)(n.strong,{children:"当 React 渲染完成后，才允许改变 external store 的值。"})," 如果 store 在 React 未渲染时更新，此时将进行下一次渲染，继续循环这个过程。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["大多数 UI 框架（包括 React v17 版本）都遵从同步渲染的流程，所渲染的 UI 也总是一致的。但在 React v18 上增加了",(0,s.jsx)(n.strong,{children:"并发机制"}),"，程序并不一定执行下去，会有中断的可能。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"并发渲染："})}),"\n",(0,s.jsx)(n.p,{children:"在并发模式下，程序并不会一直执行下去，当 external store 渲染组件变为蓝色的过程中，用户也可以改变 store 中的值，让用户感受到页面更加丝滑。如下图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"并发渲染流程如下："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"第一张图中，external store 的值为蓝色，渲染的组件也为蓝色。"}),"\n",(0,s.jsx)(n.li,{children:"在执行的过程中，将 external store 的值改为红色，此时再渲染剩余的组件，因为 store 发生变化，所以剩余的组件也变成了红色。"}),"\n",(0,s.jsxs)(n.li,{children:["第四张图，当渲染完成后，发现一个组件是蓝色，另外两个组件是红色，它们虽然读取相同的数据，但却是不同的值，此时所渲染的 UI 并不是统一的，这种情况就是 ",(0,s.jsx)(n.strong,{children:"“撕裂”"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"为什么不能用-usestate-和-useeffect-代替",children:["为什么不能用 useState 和 useEffect 代替？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么不能用-usestate-和-useeffect-代替",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在示例中，我们用 useSyncExternalStore 来监听网络的状态，这种方式明显比较麻烦，为什么不能用 useState 和 useEffect 来代替呢（如：之前介绍的 useNetwork）？"}),"\n",(0,s.jsx)(n.p,{children:"其本质原因跟 React v18 的并发机制有关，也就是并发渲染。因为通过并发渲染，React 会维护不同的 UI，一个是屏幕展示（current fiber），另一个是准备更新的树（workInProgress fiber），同时为了让用户体验更加丝滑，React 允许暂停优先级低的事件，优先处理优先级高的响应事件。"}),"\n",(0,s.jsx)(n.p,{children:"所以，在一次渲染的过程中，处理事件前后获取的外部 store 有可能不同，如果使用自身的状态，React 无法对此感知，这时就会触发撕裂的情况，即同一个 state 渲染出了不同的值。"}),"\n",(0,s.jsxs)(n.p,{children:["而 useSyncExternalStore 就是为了解决这类情况的出现。它会在渲染期间检测外部的 state 是否发生变化，如果展示的 UI 并不统一，会进行",(0,s.jsx)(n.strong,{children:"同步阻塞渲染"}),"，强制更新，使 UI 保持一致。"]}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们一起看看 useSyncExternalStore 的源码，共同揭开它神秘的面纱。"}),"\n",(0,s.jsxs)(n.h1,{id:"usesyncexternalstore-原理",children:["useSyncExternalStore 原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usesyncexternalstore-原理",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"useSyncExternalStore 的源码分为两个阶段，分别是：mountSyncExternalStore（初始化阶段）和 updateSyncExternalStore（更新阶段）。"}),"\n",(0,s.jsxs)(n.h2,{id:"mountsyncexternalstore初始化阶段",children:["mountSyncExternalStore（初始化阶段）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mountsyncexternalstore初始化阶段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["文件位置：",(0,s.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberHooks.js"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function mountSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const fiber = currentlyRenderingFiber;\n  const hook = mountWorkInProgressHook();\n\n  let nextSnapshot;\n  \n  // 是否属于 hydrate 模式\n  const isHydrating = getIsHydrating();\n  if (isHydrating) {\n    // hydrate 模式下\n    nextSnapshot = getServerSnapshot();\n  } else {\n  \n    nextSnapshot = getSnapshot();\n    const root: FiberRoot | null = getWorkInProgressRoot();\n\n    // 并发模式下，一致性检查\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  hook.memoizedState = nextSnapshot;\n  \n  const inst: StoreInstance<T> = {\n    value: nextSnapshot,\n    getSnapshot,\n  };\n  hook.queue = inst;\n\n  // useEffect 中的 mountEffect\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n\n  fiber.flags |= PassiveEffect;\n  \n  // 打上对应的标记，与useEffect中一样\n  pushEffect(\n    HookHasEffect | HookPassive,\n    updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),\n    undefined,\n    null,\n  );\n\n  return nextSnapshot;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"mountSyncExternalStore 对应三个入参，分别是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"subscribe"}),"：订阅函数，用于",(0,s.jsx)(n.strong,{children:"注册一个回调函数，当存储值发生更改时被调用"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"getSnapshot"}),"：返回当前存储值的函数；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"getServerSnapshot"}),"：返回服务端（",(0,s.jsx)(n.code,{children:"hydration"})," 模式下）渲染期间使用的存储值的函数（这里我们绕过 hydration 模式下的处理）。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"mountSyncExternalStore 整体流程："})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"首先拿到对应的 fiber 节点，创建一个 hook 对象，React 先判断当前的环境是不是 hydration 模式；"}),"\n",(0,s.jsx)(n.li,{children:"接下来生成 store 的快照，获取当前 store 的状态值，只是 hydration 模式下通过 getServerSnapshot 获取，否则通过 getSnapshot 获取。并将获取的状态值存储在对应的 memoizedState 中；"}),"\n",(0,s.jsx)(n.li,{children:"对 render 阶段结束时会对 store 进行一致性检查；"}),"\n",(0,s.jsx)(n.li,{children:"最后执行 mountEffect 和 pushEffect，这两步与 useEffect 的初始化步骤对应，打上对应的标记，在 commit 阶段进行一致性检查，防止 store 的状态不一致。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"阅读完 mountSyncExternalStore，核心点有 pushStoreConsistencyCheck、subscribeToStore、updateSyncExternalStore 三个函数，接下来我们逐一进行分析。"}),"\n",(0,s.jsxs)(n.h3,{id:"pushstoreconsistencycheck",children:["pushStoreConsistencyCheck",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pushstoreconsistencycheck",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"pushStoreConsistencyCheck"}),"：检查一致性，如果是并发模式，会创建一个 check 对象，并添加到 fiber 中的 updateQueue 对象的 store 数组中。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function pushStoreConsistencyCheck<T>(\n  fiber: Fiber,\n  getSnapshot: () => T,\n  renderedSnapshot: T,\n): void {\n  fiber.flags |= StoreConsistency;\n  \n  const check: StoreConsistencyCheck<T> = {\n    getSnapshot,\n    value: renderedSnapshot,\n  };\n  \n  let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n  \n  if (componentUpdateQueue === null) { // 第一个 check 对象\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    \n    componentUpdateQueue.stores = [check];\n  } else { // 多个 check 对象\n    const stores = componentUpdateQueue.stores;\n    \n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"从源码可以看出，收集 check 的过程和 useEffect 中收集 effect 对象类似， createFunctionComponentUpdateQueue() 用来创建一个更新队列，最终放入 stores 数组中。"}),"\n",(0,s.jsxs)(n.h3,{id:"subscribetostore",children:["subscribeToStore",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#subscribetostore",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"subscribeToStore："})," 通过 store 提供的 subscribe 方法订阅对应的状态变化，如果发生变化，则会采用同步阻塞模式渲染。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function subscribeToStore<T>(\n  fiber: Fiber,\n  inst: StoreInstance<T>,\n  subscribe: (() => void) => () => void,\n): any {\n // 通过 store 的 dispatch 方法修改 store 会触发\n const handleStoreChange = () => {\n    if (checkIfSnapshotChanged(inst)) {\n      forceStoreRerender(fiber);\n    }\n  };\n  return subscribe(handleStoreChange);\n}\n\n// 判断 store 的值是否发生变化\nfunction checkIfSnapshotChanged<T>(inst: StoreInstance<T>): boolean {\n  const latestGetSnapshot = inst.getSnapshot;\n  \n  // 旧值\n  const prevValue = inst.value;\n  try {\n    // 新值\n    const nextValue = latestGetSnapshot();\n    // 与 useEffect 中的一致，进行浅比较\n    return !is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\n// 使用阻塞模式渲染\nfunction forceStoreRerender(fiber: Fiber) {\n  const root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n  if (root !== null) {\n    scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 subscribeToStore 中，会进行一层判断：checkIfSnapshotChanged 函数，它会判断 store 是否发生变化，判断的依据也跟 useEffect 中的一致，通过 ",(0,s.jsx)(n.code,{children:"is"})," 进行",(0,s.jsx)(n.strong,{children:"浅比较"}),"，如果发生了变化，则会执行 forceStoreRerender 方法，手动触发 Sync 阻塞渲染，处理优先级和挂载更新节点。"]}),"\n",(0,s.jsx)(n.p,{children:"简单点说，我们通过 store 的 dispatch 修改内容时，store 会遍历依赖列表，按照顺序依次执行回调函数。"}),"\n",(0,s.jsxs)(n.h3,{id:"updatestoreinstance",children:["updateStoreInstance",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#updatestoreinstance",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"updateStoreInstance："})," 在 commit 阶段中，会统一处理 render 阶段的所有 effect，此时会再次检查 store 是否发生变化，防止 store 的状态不一致。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function updateStoreInstance<T>(\n  fiber: Fiber,\n  inst: StoreInstance<T>,\n  nextSnapshot: T,\n  getSnapshot: () => T,\n): void {\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot;\n\n  // 在 commit 阶段中，检查 store 是否发生变化\n  if (checkIfSnapshotChanged(inst)) {\n    // 触发同步阻塞渲染\n    forceStoreRerender(fiber);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"updatesyncexternalstore更新阶段",children:["updateSyncExternalStore（更新阶段）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#updatesyncexternalstore更新阶段",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function updateSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const fiber = currentlyRenderingFiber;\n  \n  // 获取更新的hooks\n  const hook = updateWorkInProgressHook();\n  \n  // 获取新的 store 状态\n  const nextSnapshot = getSnapshot();\n  const prevSnapshot = (currentHook || hook).memoizedState;\n  const snapshotChanged = !is(prevSnapshot, nextSnapshot);\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n  const inst = hook.queue;\n\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n    subscribe,\n  ]);\n\n  if (\n    inst.getSnapshot !== getSnapshot ||\n    snapshotChanged ||\n    (workInProgressHook !== null &&\n      workInProgressHook.memoizedState.tag & HookHasEffect)\n  ) {\n    fiber.flags |= PassiveEffect;\n    pushEffect(\n      HookHasEffect | HookPassive,\n      updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot),\n      undefined,\n      null,\n    );\n\n    const root: FiberRoot | null = getWorkInProgressRoot();\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看出 updateSyncExternalStore 和 mountSyncExternalStore 的步骤基本类似，来看看对应的流程："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"获取更新的 hooks 对象、新的 store 状态，存储到 memoizedState 中；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"通过 updateEffect 方法在节点更新后执行对应的 subscribe 方法。与 useEffect 的更新方法对应，只不过这里检查的并不是 deps，而是 subscribe。也就是说，如果 subscribe 不发生改变，则不会执行；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"接下来操作与 mountSyncExternalStore 一致，在 render 阶段结束时，commit 阶段会分别对 store 进行一致性检查，防止 store 的状态不一致。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h1,{id:"实现-usesyncexternalstore",children:["实现 useSyncExternalStore",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-usesyncexternalstore",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"实际上 useSyncExternalStore 的原理并没有那么难懂，从源码的角度来看，就是在渲染前后去检查 store 的值是否发生改变，如果发生改变，则更新值。你可以认为 useSyncExternalStore 就是 useState、useEffect、 useLayoutEffect 配合形成的。在 React 源码中也有对应的实现。"}),"\n",(0,s.jsxs)(n.p,{children:["文件位置：",(0,s.jsx)(n.code,{children:"packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { useState, useEffect, useLayoutEffect } from "react";\n\nconst useSyncExternalStore = <T,>(\n  subscribe: any,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T\n) => {\n  const value = getSnapshot();\n  const [{ inst }, forceUpdate] = useState({ inst: { value, getSnapshot } });\n\n  // 同步执行\n  useLayoutEffect(() => {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot;\n\n    if (checkIfSnapshotChanged(inst)) {\n      forceUpdate({ inst });\n    }\n  }, [subscribe, value, getSnapshot]);\n\n  // 异步执行\n  useEffect(() => {\n    if (checkIfSnapshotChanged(inst)) {\n      forceUpdate({ inst });\n    }\n    const handleStoreChange: any = () => {\n      if (checkIfSnapshotChanged(inst)) {\n        forceUpdate({ inst });\n      }\n    };\n    // 取消订阅\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n\n  return value;\n};\n\n// 检查 store 是否发生变化\nfunction checkIfSnapshotChanged<T>(inst: {\n  value: T;\n  getSnapshot: () => T;\n}): boolean {\n  const latestGetSnapshot = inst.getSnapshot;\n  const prevValue = inst.value;\n  try {\n    const nextValue = latestGetSnapshot();\n    // 对应 is 方法\n    return !Object.is(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nexport default useSyncExternalStore;\n'})}),"\n",(0,s.jsx)(n.p,{children:"实现流程："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"首先，通过 getSnapshot 方法生成快照，并保存在 value 中；"}),"\n",(0,s.jsx)(n.li,{children:"然后使用 useState 创建一个变量 inst，将 value 和 getSnapshot 作为初始化值；"}),"\n",(0,s.jsx)(n.li,{children:"之后分别用 useLayoutEffect 和 useEffect 创建一个副作用，通过 checkIfSnapshotChanged 检查外部状态管理工具的状态快照是否发生变化，如果发生变化，则通过 forceUpdate 去更新状态；"}),"\n",(0,s.jsx)(n.li,{children:"最后通过 useDebugValue 将 value 展示在 React 开发者工具中。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这里将副作用分为 useLayoutEffect 和 useEffect，也就是分为同步、异步两种模式，这样可以更好地控制组件的生命周期，避免出现意外。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"上述代码与源码略有不同，感兴趣的可以自己尝试一下。"}),"\n",(0,s.jsx)(n.p,{children:"此外，在 SSR 中，如果使用 useSyncExternalStore，必须定义 getServerSnapshot，否则会引发错误。"}),"\n",(0,s.jsxs)(n.p,{children:["如果在服务端渲染时不能提供一个初值，可以将组件转换成一个只在客户端渲染的组件，方法是在服务端渲染时抛出一个异常通过 ",(0,s.jsx)(n.code,{children:"<Suspense>"})," 展示 fallback 的 UI（具体可参照：",(0,s.jsx)(n.a,{href:"https://julesblom.com/writing/usesyncexternalstore",target:"_blank",rel:"noopener noreferrer",children:"useSyncExternalStore First Look"}),"）。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h1,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在本章中，我们首先了解到 useSyncExternalStore 为什么存在、解决了什么问题，主要明确 useSyncExternalStore 并不止适用于三方库，像网络、尺寸、媒体查询等外部因素都有可能影响 UI，产生数据撕裂，而 useSyncExternalStore 可有效地避免 UI 中的视觉不一致问题。"}),"\n",(0,s.jsxs)(n.p,{children:["之后我们对 useSyncExternalStore 的源码进行分析，为了保证 store 状态一致，会通过",(0,s.jsx)(n.strong,{children:"同步阻塞渲染，强制更新"}),"，共采取了三道保险："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"通过 dispatch 方式修改 store，强制使用 Sync 同步，期间不可中断渲染；"}),"\n",(0,s.jsx)(n.li,{children:"在并发模式下，协调结束后进行一致性检查，如果不同，则强制使用 Sync 同步；"}),"\n",(0,s.jsx)(n.li,{children:"在 commit 阶段再进行一致性检查，如果不同，则强制使用 Sync 同步。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"可以说 useSyncExternalStore 通过三道强力的保险，保证了 UI 的一致。"}),"\n",(0,s.jsx)(n.p,{children:"最后，我们通过 useState、useEffect 和 useLayoutEffect 简易地实现了 useSyncExternalStore，帮助我们更好地理解这个 Hooks。"}),"\n",(0,s.jsx)(n.p,{children:"总的来说，useSyncExternalStore 的实现原理并没有那么复杂，但它使用的场景要比想象中的更加广泛，所以掌握 useSyncExternalStore 是非常有必要的。"}),"\n",(0,s.jsx)(n.p,{children:"下一章，我们继续 React v18 提供的 Hooks：useTransition 和  useDeferredValue。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}let d=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F14.%E6%BA%90%E7%A0%81%E7%AF%87%EF%BD%9C%E6%8E%A2%E7%B4%A2%20useSyncExternalStore%20%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1.md"]={toc:[{text:"什么是数据撕裂？",id:"什么是数据撕裂",depth:2},{text:"为什么不能用 useState 和 useEffect 代替？",id:"为什么不能用-usestate-和-useeffect-代替",depth:2},{text:"mountSyncExternalStore（初始化阶段）",id:"mountsyncexternalstore初始化阶段",depth:2},{text:"pushStoreConsistencyCheck",id:"pushstoreconsistencycheck",depth:3},{text:"subscribeToStore",id:"subscribetostore",depth:3},{text:"updateStoreInstance",id:"updatestoreinstance",depth:3},{text:"updateSyncExternalStore（更新阶段）",id:"updatesyncexternalstore更新阶段",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);