"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58430"],{853904:function(e,n,s){s.r(n),s.d(n,{default:()=>b});var c=s(552676),r=s(740453);let d=s.p+"static/image/b6254436fa715a4e571e31c8ee68aabc.fd9f2ae6.webp",i=s.p+"static/image/eb3e6bf092cad54d6d8425873847e0a3.d7b1730b.webp",l=s.p+"static/image/a5fe5f3d961b39d8c68fbdcda5204570.e8ddc67d.webp",j=s.p+"static/image/244ce2fc721b1b7123d4f7ab27010247.fca39b96.webp",a=s.p+"static/image/01a22b767e5109996cea3588f44d2487.82356105.webp",o=s.p+"static/image/e01650f38deefec03e8083b7919e9b2c.3e843758.webp",h=s.p+"static/image/a6b7f79287d0fd282ebeb050a7ba6da7.cac9d75e.webp",t=s.p+"static/image/030bfe82abfa0b9b05b8a0ddf737afb5.2fd47a3e.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",code:"code",strong:"strong",ol:"ol",pre:"pre",img:"img",h3:"h3",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"4js-基础知识点及常考面试题二",children:["4.JS 基础知识点及常考面试题（二）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4js-基础知识点及常考面试题二",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在这一章节中我们继续来了解 JS 的一些常考和容易混乱的基础知识点。"}),"\n",(0,c.jsxs)(n.h2,{id:"更新日志",children:["更新日志",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新日志",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"重写闭包及深浅拷贝章节"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"-vs-",children:["== vs ===",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-vs-",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["对于 ",(0,c.jsx)(n.code,{children:"=="})," 来说，如果对比双方的类型",(0,c.jsx)(n.strong,{children:"不一样"}),"的话，就会进行",(0,c.jsx)(n.strong,{children:"类型转换"}),"，这也就用到了我们上一章节讲的内容。"]}),"\n",(0,c.jsxs)(n.p,{children:["当我们需要对比 ",(0,c.jsx)(n.code,{children:"x"})," 和 ",(0,c.jsx)(n.code,{children:"y"})," 是否相同时，就会进行如下判断流程："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["首先会判断两者类型是否",(0,c.jsx)(n.strong,{children:"相同"}),"。相同的话就是比大小了"]}),"\n",(0,c.jsx)(n.li,{children:"类型不相同的话，那么就会进行类型转换"}),"\n",(0,c.jsxs)(n.li,{children:["会先判断是否在对比 ",(0,c.jsx)(n.code,{children:"null"})," 和 ",(0,c.jsx)(n.code,{children:"undefined"}),"，是的话就会返回 ",(0,c.jsx)(n.code,{children:"true"})]}),"\n",(0,c.jsxs)(n.li,{children:["判断两者类型是否为 ",(0,c.jsx)(n.code,{children:"string"})," 和 ",(0,c.jsx)(n.code,{children:"number"}),"，是的话就会将字符串转换为 ",(0,c.jsx)(n.code,{children:"number"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"1 == '1'\n      ↓\n1 ==  1\n"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["判断其中一方是否为 ",(0,c.jsx)(n.code,{children:"boolean"}),"，是的话就会把 ",(0,c.jsx)(n.code,{children:"boolean"})," 转为 ",(0,c.jsx)(n.code,{children:"number"})," 再进重写进行判断流程","\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"'1' == true\n        ↓\n'1' ==  1\n        ↓\n 1  ==  1\n"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["判断其中一方是否为 ",(0,c.jsx)(n.code,{children:"object"})," 且另一方为 ",(0,c.jsx)(n.code,{children:"string"}),"、",(0,c.jsx)(n.code,{children:"number"}),"，是的话就会把 ",(0,c.jsx)(n.code,{children:"object"})," 转为原始类型再进行判断，也就是执行 ",(0,c.jsx)(n.code,{children:"x.toString()"})," 及 ",(0,c.jsx)(n.code,{children:"valueOf"}),"，具体内容在上一章节已经聊过","\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"'1' == { name: 'yck' }\n        ↓\n'1' == '[object Object]'\n"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["返回 ",(0,c.jsx)(n.code,{children:"false"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"如果你觉得记忆步骤太麻烦的话，我还提供了流程图供大家使用："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["以上内容大家也可以参考 ",(0,c.jsx)(n.a,{href:"https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1",target:"_blank",rel:"noopener noreferrer",children:"标准文档"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后对于 ",(0,c.jsx)(n.code,{children:"==="})," 来说，判断简单多了，就是判断两者类型和值是否相同就行。"]}),"\n",(0,c.jsxs)(n.h3,{id:"常见面试题",children:["常见面试题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见面试题",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"=="})," 和 ",(0,c.jsx)(n.code,{children:"==="})," 操作符有什么区别"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"=="})," 操作符的类型转换规则"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"闭包",children:["闭包",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#闭包",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"很多读者的闭包概念是完全错误的，如果你觉得你理解的闭包概念与我不同，那么请以我的内容为准。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["首先闭包正确的定义是：",(0,c.jsx)(n.strong,{children:"假如一个函数能访问外部的变量，那么就形成了一个闭包，而不是一定要返回一个函数"}),"。这个定义很重要，下面的内容需要用到。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = 1\n// 产生闭包\nfunction fn() {\n  console.log(a);\n}\n\nfunction fn1() {\n  let a = 1\n  // 产生闭包\n  return () => {\n    console.log(a);\n  }\n}\nconst fn2 = fn1()\nfn2()\n"})}),"\n",(0,c.jsx)(n.p,{children:"其实到这里为止闭包的概念已经讲完了，没有别的东西了。接下来我们通过 Chrome 的开发工具来进一步了解闭包是如何存储外部变量的。"}),"\n",(0,c.jsx)(n.p,{children:"先来说下数据存放的正确规则是：局部、占用空间确定的数据，一般会存放在栈中，否则就在堆中（也有例外）。 那么接下来我们来验证这个说法："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["上图中画红框的位置我们能看到一个内部的对象 ",(0,c.jsx)(n.code,{children:"[[Scopes]]"}),"，这个对象就是我们常说的作用域链。根据作用域链寻找的顺序，其中包含了闭包、全局对象。据此我们能通过闭包访问到本该销毁的变量，所以我会在上一章节中说原始数据一般存放在栈上。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外最开始我们对于闭包的定位是：",(0,c.jsx)(n.strong,{children:"假如一个函数能访问外部的变量，那么就形成了一个闭包"}),"，因此接下来我们看看在全局下的表现是怎么样的。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = 1\nvar b = 2\n// 形成闭包\nfunction fn() {\n  console.log(a, b);\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["从上图我们能发现全局下声明的变量，如果是 var 的话就直接被挂到 ",(0,c.jsx)(n.code,{children:"global"})," 上，如果是其他关键字声明的话就被挂到 ",(0,c.jsx)(n.code,{children:"Script"})," 上。虽然这些数据同样还是存在 ",(0,c.jsx)(n.code,{children:"[[Scopes]]"})," 上，但是全局变量在内存中是存放在静态区域的，因为全局变量无需进行垃圾回收。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后总结一下原始类型存储位置：",(0,c.jsx)(n.strong,{children:"局部变量被存储在栈上，全局变量存储在静态区域上，其它都存储在堆上。"})]}),"\n",(0,c.jsxs)(n.h3,{id:"常见考点",children:["常见考点",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"闭包能考的很多，概念和笔试题都会考。"}),"\n",(0,c.jsx)(n.p,{children:"概念题就是考考闭包是什么了。"}),"\n",(0,c.jsx)(n.p,{children:"笔试题的话基本都会结合上异步，比如最常见的："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"for (var i = 0; i < 6; i++) {\n  setTimeout(() => {\n    console.log(i)\n  })\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"这道题会问输出什么，有哪几种方式可以得到想要的答案？"}),"\n",(0,c.jsxs)(n.h2,{id:"深浅拷贝",children:["深浅拷贝",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#深浅拷贝",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在上一章节中，我们了解了对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方时其它也都被改变的情况。通常在开发中我们不希望出现这样的问题，此时我们可以使用浅拷贝来解决这个情况。"}),"\n",(0,c.jsxs)(n.h3,{id:"浅拷贝",children:["浅拷贝",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浅拷贝",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["首先可以通过 ",(0,c.jsx)(n.code,{children:"Object.assign"})," 来解决这个问题，这个函数会拷贝所有的属性值到新的对象中。如果属性值是对象的话，拷贝的是地址。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = {\n  age: 1\n}\nlet b = Object.assign({}, a)\na.age = 2\nconsole.log(b.age) // 1\n"})}),"\n",(0,c.jsxs)(n.p,{children:["另外我们还可以通过展开运算符 ",(0,c.jsx)(n.code,{children:"..."})," 来实现浅拷贝："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = {\n  age: 1\n}\nlet b = { ...a }\na.age = 2\nconsole.log(b.age) // 1\n"})}),"\n",(0,c.jsx)(n.p,{children:"通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = {\n  age: 1,\n  jobs: {\n    first: 'FE'\n  }\n}\nlet b = { ...a }\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // native\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"深拷贝",children:["深拷贝",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#深拷贝",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["深拷贝通常可以通过 ",(0,c.jsx)(n.code,{children:"JSON.parse(JSON.stringify(object))"})," 来解决，这个方式基本能解决大部分情况。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = {\n  age: 1,\n  jobs: {\n    first: 'FE'\n  }\n}\nlet b = JSON.parse(JSON.stringify(a))\na.jobs.first = 'native'\nconsole.log(b.jobs.first) // FE\n"})}),"\n",(0,c.jsx)(n.p,{children:"当然了，这个方法是存在局限性的。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3,\n  },\n}\nobj.c = obj.b\nobj.e = obj.a\nobj.b.c = obj.c\nobj.b.d = obj.b\nobj.b.e = obj.b.c\nlet newObj = JSON.parse(JSON.stringify(obj))\nconsole.log(newObj)\n"})}),"\n",(0,c.jsx)(n.p,{children:"如果对象中存在循环引用，你会发现程序会报错："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["同时在遇到不支持的数据类型，比如函数、 ",(0,c.jsx)(n.code,{children:"undefined"})," 或者 ",(0,c.jsx)(n.code,{children:"symbol"})," 的时候，这些属性都会被忽略："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let a = {\n  age: undefined,\n  sex: Symbol('male'),\n  jobs: function() {},\n  name: 'yck'\n}\nlet b = JSON.parse(JSON.stringify(a))\nconsole.log(b) // {name: \"yck\"}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["你会发现在上述代码中，",(0,c.jsx)(n.code,{children:"JSON.stringify(a)"})," 只保留了 ",(0,c.jsx)(n.code,{children:"name"})," 属性。"]}),"\n",(0,c.jsx)(n.p,{children:"以下是 JSON 支持的数据类型："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 ",(0,c.jsx)(n.code,{children:"MessageChannel"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function structuralClone(obj) {\n  return new Promise(resolve => {\n    const { port1, port2 } = new MessageChannel()\n    port2.onmessage = ev => resolve(ev.data)\n    port1.postMessage(obj)\n  })\n}\n\nvar obj = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\n\nobj.b.d = obj.b\n\n// 注意该方法是异步的\n// 可以处理 undefined 和循环引用对象\nconst test = async () => {\n  const clone = await structuralClone(obj)\n  console.log(clone)\n}\ntest()\n"})}),"\n",(0,c.jsx)(n.p,{children:"当然我们也可以自己实现一个深拷贝，同时这也是一个非常高频的手写题："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 利用 WeakMap 解决循环引用\nlet map = new WeakMap()\nfunction deepClone(obj) {\n  if (obj instanceof Object) {\n    if (map.has(obj)) {\n      return map.get(obj)\n    }\n    let newObj\n    if (obj instanceof Array) {\n      newObj = []     \n    } else if (obj instanceof Function) {\n      newObj = function() {\n        return obj.apply(this, arguments)\n      }\n    } else if (obj instanceof RegExp) {\n      // 拼接正则\n      newobj = new RegExp(obj.source, obj.flags)\n    } else if (obj instanceof Date) {\n      newobj = new Date(obj)\n    } else {\n      newObj = {}\n    }\n    // 克隆一份对象出来\n    let desc = Object.getOwnPropertyDescriptors(obj)\n    let clone = Object.create(Object.getPrototypeOf(obj), desc)\n    map.set(obj, clone)\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        newObj[key] = deepClone(obj[key])\n      }\n    }\n    return newObj\n  }\n  return obj\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"以上代码解决了常见类型的 copy 及循环引用的问题。"}),"\n",(0,c.jsx)(n.p,{children:"当然还是存在一部分缺陷的，比如说递归肯定会存在爆栈的问题，因为执行栈的大小是有限制的，到一定数量栈就会爆掉。当遇到这种问题，我们可以通过遍历的方式来改写递归。也就是如何写层序遍历（BFS）的问题了，只需要通过数组来模拟执行栈就能解决爆栈问题。"}),"\n",(0,c.jsx)(n.p,{children:"但是在面试时能写出上面的代码已经完全够了，剩下的能口述思路基本这道题就能拿到高分了。"}),"\n",(0,c.jsxs)(n.h3,{id:"常见面试题-1",children:["常见面试题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见面试题-1",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"浅拷贝和深拷贝的区别是什么"}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"JSON.parse(JSON.stringify(a))"})," 存在什么问题"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"手写深拷贝函数"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"原型",children:["原型",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["当我们创建一个对象时 ",(0,c.jsx)(n.code,{children:"let obj = { age: 25 }"}),"，我们可以发现能使用很多种函数，但是我们明明没有定义过它们，对于这种情况你是否有过疑惑？"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["当我们在浏览器中打印 ",(0,c.jsx)(n.code,{children:"obj"})," 时你会发现，在 ",(0,c.jsx)(n.code,{children:"obj"})," 上居然还有一个 ",(0,c.jsx)(n.code,{children:"__proto__"})," 属性，那么看来之前的疑问就和这个属性有关系了。"]}),"\n",(0,c.jsxs)(n.p,{children:["其实每个 JS 对象都有 ",(0,c.jsx)(n.code,{children:"__proto__"})," 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 ",(0,c.jsx)(n.code,{children:"[[prototype]]"})," 来实现的一个东西。"]}),"\n",(0,c.jsxs)(n.p,{children:["讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 ",(0,c.jsx)(n.code,{children:"__proto__"})," 里面有什么吧。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["看到这里你应该明白了，原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 ",(0,c.jsx)(n.code,{children:"obj"})," 来说，可以通过 ",(0,c.jsx)(n.code,{children:"__proto__"})," 找到一个原型对象，在该对象中定义了很多函数让我们来使用。"]}),"\n",(0,c.jsxs)(n.p,{children:["在上面的图中我们还可以发现一个 ",(0,c.jsx)(n.code,{children:"constructor"})," 属性，也就是构造函数"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["打开 ",(0,c.jsx)(n.code,{children:"constructor"})," 属性我们又可以发现其中还有一个 ",(0,c.jsx)(n.code,{children:"prototype"})," 属性，并且这个属性对应的值和先前我们在 ",(0,c.jsx)(n.code,{children:"__proto__"})," 中看到的一模一样。所以我们又可以得出一个结论：原型的 ",(0,c.jsx)(n.code,{children:"constructor"})," 属性指向构造函数，构造函数又通过 ",(0,c.jsx)(n.code,{children:"prototype"})," 属性指回原型，但是并不是所有函数都具有这个属性，",(0,c.jsx)(n.code,{children:"Function.prototype.bind()"})," 就没有这个属性。"]}),"\n",(0,c.jsx)(n.p,{children:"其实原型就是那么简单，接下来我们再来看一张图，相信这张图能让你彻底明白原型和原型链"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["看完这张图，我再来解释下什么是原型链吧。其实原型链就是多个对象通过 ",(0,c.jsx)(n.code,{children:"__proto__"})," 的方式连接了起来。为什么 ",(0,c.jsx)(n.code,{children:"obj"})," 可以访问到 ",(0,c.jsx)(n.code,{children:"valueOf"})," 函数，就是因为 ",(0,c.jsx)(n.code,{children:"obj"})," 通过原型链找到了 ",(0,c.jsx)(n.code,{children:"valueOf"})," 函数。"]}),"\n",(0,c.jsx)(n.p,{children:"对于这一小节的知识点，总结起来就是以下几点："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Object"})," 是所有对象的爸爸，所有对象都可以通过 ",(0,c.jsx)(n.code,{children:"__proto__"})," 找到它"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Function"})," 是所有函数的爸爸，所有函数都可以通过 ",(0,c.jsx)(n.code,{children:"__proto__"})," 找到它"]}),"\n",(0,c.jsxs)(n.li,{children:["函数的 ",(0,c.jsx)(n.code,{children:"prototype"})," 是一个对象"]}),"\n",(0,c.jsxs)(n.li,{children:["对象的 ",(0,c.jsx)(n.code,{children:"__proto__"})," 属性指向原型， ",(0,c.jsx)(n.code,{children:"__proto__"})," 将对象和原型连接起来组成了原型链"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["如果你还想深入学习原型这部分的内容，可以阅读我之前写的",(0,c.jsx)(n.a,{href:"https://github.com/KieSun/Dream/issues/2",target:"_blank",rel:"noopener noreferrer",children:"文章"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"常见面试题-2",children:["常见面试题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见面试题-2",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"如何理解原型及原型链"}),"\n",(0,c.jsx)(n.li,{children:"如何重写原型，这个在下一章节的继承小节中有解释"}),"\n",(0,c.jsx)(n.li,{children:"原型链指向"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"以上就是全部的常考和容易混乱的基础知识点了，下一章节我们将会学习 ES6 部分的知识。如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(x,{...e})}):x(e)}let b=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F4.JS%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89.md"]={toc:[{text:"更新日志",id:"更新日志",depth:2},{text:"== vs ===",id:"-vs-",depth:2},{text:"常见面试题",id:"常见面试题",depth:3},{text:"闭包",id:"闭包",depth:2},{text:"常见考点",id:"常见考点",depth:3},{text:"深浅拷贝",id:"深浅拷贝",depth:2},{text:"浅拷贝",id:"浅拷贝",depth:3},{text:"深拷贝",id:"深拷贝",depth:3},{text:"常见面试题",id:"常见面试题-1",depth:3},{text:"原型",id:"原型",depth:2},{text:"常见面试题",id:"常见面试题-2",depth:3},{text:"小结",id:"小结",depth:2}],title:"4.JS 基础知识点及常考面试题（二）",headingTitle:"4.JS 基础知识点及常考面试题（二）",frontmatter:{}}}}]);