"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["21350"],{414188:function(e,n,r){r.r(n),r.d(n,{default:()=>B});var s=r(552676),i=r(740453);let c=r.p+"static/image/f3d41a77ddeb799ec66533160f06a565.0f644572.webp",t=r.p+"static/image/ad7aeedd9ac536cedffc4dfe1febb28a.b18268a5.webp",d=r.p+"static/image/3e46572b857c3833ce5045d01bde4af4.37e2adc2.webp",a=r.p+"static/image/e3a3688b188f998b4b3b98db3a3357b3.0f1e0585.webp",p=r.p+"static/image/0eb39648bce8823d4483ff32d1c7f50a.701d9c0f.webp",l=r.p+"static/image/aede855755058e47604329ed7b63842e.178decfb.webp",x=r.p+"static/image/02c781ee294cda85009151ee89830b87.5f3f062e.webp",h=r.p+"static/image/d368bbfaef6b8578ecd6058d3d18fed1.0150b04d.webp",g=r.p+"static/image/2447e9c5616fe367f2f2a7601ef2acbd.0bb63691.webp",j=r.p+"static/image/ad32e17209d818e3549fa8d55fba8ee8.d3179f67.webp",f=r.p+"static/image/c86115aa999b5cb3f0a0024272f04546.6b1bbfcb.webp",b=r.p+"static/image/dea7768fd6765d553c45d7bfb1df5517.7c0d8b65.webp",A=r.p+"static/image/54e1788534400ecf5fcf5d891b9ff850.0c9fcfd4.webp",m=r.p+"static/image/746d8240e9e9ba1ecaaf9370527f059f.79664975.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",strong:"strong",h2:"h2"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"16新语法-infer-extends-是如何简化类型编程的",children:["16.新语法 infer extends 是如何简化类型编程的",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16新语法-infer-extends-是如何简化类型编程的",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们知道，TypeScript 支持 infer 来提取类型的一部分，通过模式匹配的方式。"}),"\n",(0,s.jsx)(n.p,{children:"比如元组类型提取最后一个元素的类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Last<Arr extends unknown[]> = \n    Arr extends [...infer rest,infer Ele]\n        ? Ele \n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"比如函数提取返回值类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type GetReturnType<Func extends Function> = \n    Func extends (...args: any[]) => infer ReturnType \n        ? ReturnType \n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"比如字符串提取一部分，然后替换："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReplaceStr<\n    Str extends string,\n    From extends string,\n    To extends string\n> = Str extends `${infer Prefix}${From}${infer Suffix}` \n        ? `${Prefix}${To}${Suffix}` : Str;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"模式匹配就是通过一个类型匹配一个模式类型，需要提取的部分通过 infer 声明一个局部变量，这样就能从局部变量里拿到提取的类型。"})}),"\n",(0,s.jsx)(n.p,{children:"infer 的模式匹配用法还是挺好理解的。"}),"\n",(0,s.jsx)(n.p,{children:"但是 infer 有一个问题，比如这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"从 string 数组中提取的元素，默认会推导为 unknown 类型，这就导致了不能直接把它当 string 用："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那怎么办呢？"}),"\n",(0,s.jsx)(n.p,{children:"之前的处理方式是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"加一层判断，这样 Last 就推导为 string 类型了。"}),"\n",(0,s.jsx)(n.p,{children:"或者也可以和 string 取交叉类型："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样也可以作为 string 来用。"}),"\n",(0,s.jsx)(n.p,{children:"但是我们明明知道这里就是 string，却还需要 & string 或者 xxx extends string 来转换一次，这也太麻烦了。"}),"\n",(0,s.jsx)(n.p,{children:"TS 也知道有这个问题，所以在 4.7 就引入了新语法：infer extends。"}),"\n",(0,s.jsx)(n.p,{children:"现在我们可以这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"infer 的时候加上 extends 来约束推导的类型，这样推导出的就不再是 unknown 了，而是约束的类型。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?ts=4.8.0-beta#code/C4TwDgpgBAKhDOwAyBDRAeAggJ21CAHsBAHYAm8Ui2AliQOYDaAugHxQC8UAUFH1DjyFi5SowB0kugDMIeAEoJgAGigy5UVIma9+egPxQABoABzQHAqgADlAVHKB6M0BY-wBIA3luBQAZFWC0GAXyO6enwAXFAkEABucgDc3NygkLBKrgBMWLj4RKQUXj5MbJw8eoKZIjkSUiSyCkqq6niuOkH8hq6l2ZTUdPSBzS3G5tb2zq7+vX1QoeFR2OP8U5ExcQnQcIiuAMzpQlmiud0s7Fy9JcIdUBXi9VCKiHVVGm1ne10MTX2Gppa2ji5owGMJgsZrEgA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(n.p,{children:"这个语法是 TS 4.7 引入的，在 4.8 又完善了一下。"}),"\n",(0,s.jsx)(n.p,{children:"比如这样一个类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type NumInfer<Str> = \n    Str extends `${infer Num extends number}`\n        ? Num\n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 4.7 的时候推导结果是这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而 4.8 就是这样了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"也就是说 4.7 的时候推导出的就是 extends 约束的类型，但是 4.8 的时候，如果是基础类型，会推导出字面量类型。"}),"\n",(0,s.jsx)(n.p,{children:"有了这个语法之后，除了能简化类型编程的逻辑之外，也能实现一些之前实现不了的功能："}),"\n",(0,s.jsx)(n.p,{children:"比如提取枚举的值的类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'enum Code {\n    a = 111,\n    b = 222,\n    c = "abc"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"我们都是这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但是有的值明明是数字，却被作为了字符串，所以要再处理一下，转换成数字类型，这时候就可以用 infer extends 了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type StrToNum<Str> =\n  Str extends `${infer Num extends number}`\n    ? Num\n    : Str\n"})}),"\n",(0,s.jsx)(n.p,{children:"做完 string 到 number 的转换，就拿到了我们想要的结果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是 infer extends 的第二个作用。"}),"\n",(0,s.jsx)(n.p,{children:"处理 string 转 number 之外，也可以转 boolean、null 等类型："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?ts=4.8.0-beta#code/KYOwrgtgBAwg9gE2FA3gKCpqBDKBeKARmIBoMsAjfKAJjrKygGNqBybCp1tAXzTQAuATwAOyAMoCATgBU4AOUgAeSVIB8+cqqjAAHgNAIAzlAAGAEhQBLEADNgUqIuh6DIY1HAQKDnqfKYAPxOkAFQAFxQqvzCYlBSwCYEqnLOShYo8Eh+agDcMaIS0nIAQnBwADbA2CAq0hp4WtI6+oYmGTb2jmWVLW4eFOVVNX5hwT0VYZHRgoXxiTTUKXAT1bWs0mDArHkFccuKFRV16pqY2q5tZpadDiFHfVfgR6OMwYeTjNPSe8gJRgBmJbFBRgI5KVjPCo7XJAA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Typescript 支持 infer 类型，可以通过模式匹配的方式，提取一部分类型返回。"}),"\n",(0,s.jsx)(n.p,{children:"但是 infer 提取出的类型是 unknown，后面用的时候需要类似和 string 取交叉类型，或者 xxx extends string 这样的方式来转换成别的类型来用。这样比较麻烦。"}),"\n",(0,s.jsx)(n.p,{children:"所以 TS 4.7 实现了 infer extends 的语法，可以指定推导出的类型，这样简化了类型编程。"}),"\n",(0,s.jsx)(n.p,{children:"而且，infer extends 还可以用来做类型转换，比如 string 转 number、转 boolean 等。"}),"\n",(0,s.jsx)(n.p,{children:"要注意的是，4.7 的时候，推导出的只是 extends 约束的类型，比如 number、boolean，但是 4.8 就能推导出字面量类型了，比如 1、2、true、false 这种。"}),"\n",(0,s.jsx)(n.p,{children:"有了 infer extends，不但能简化类型编程，还能实现一些之前很难实现的类型转换。"})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}let B=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F16.%E6%96%B0%E8%AF%AD%E6%B3%95%20infer%20extends%20%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%80%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E7%9A%84.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"16.新语法 infer extends 是如何简化类型编程的",headingTitle:"16.新语法 infer extends 是如何简化类型编程的",frontmatter:{}}}}]);