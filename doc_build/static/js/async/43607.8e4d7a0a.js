"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["43607"],{609070:function(e,n,t){t.r(n),t.d(n,{default:()=>m});var s=t(552676),r=t(740453);let o=t.p+"static/image/0036048d55aa25c2247d580e82e3cb86.c181b587.webp",c=t.p+"static/image/010ef27bb4268913034a973c7f466b62.cd808d56.webp",i=t.p+"static/image/5eccedfa548a75ecc9facf1af108b2e8.346e2c6a.webp",l=t.p+"static/image/4a084b8855db518da7dd52db18db91bf.15b2e750.webp",d=t.p+"static/image/8f74b614eaf6aa21c35d6db4db3d2973.4395701e.webp",a=t.p+"static/image/4dfb7d12da9552ceaabe3b9f486362fe.303d2ebe.webp",p=t.p+"static/image/4a1efa10c16c8239028084866c7f1390.32961bf8.webp",h=t.p+"static/image/05be48847c6ac20defc7c2ae2d133e77.f532ce4a.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",blockquote:"blockquote",pre:"pre",ul:"ul",li:"li",img:"img",h3:"h3",strong:"strong",h4:"h4"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"6基础篇-理解-lifecycle",children:["6.基础篇-理解 lifeCycle",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6基础篇-理解-lifecycle",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在本章节中主要讲 React 的生命周期，React 类组件为开发者提供了一些生命周期钩子函数，能让开发者在 React 执行的重要阶段，在钩子函数里做一些该做的事。自从 React Hooks 问世以来，函数组件也能优雅地使用 Hooks ，弥补函数组件没有生命周期的缺陷。"}),"\n",(0,s.jsxs)(n.p,{children:["希望通过本章节让你一次性搞定 React 生命周期的流程和能弄清楚在各个生命周期做些什么，第二点就是加深对 React Hooks 中 ",(0,s.jsx)(n.code,{children:"useEffect"})," 和 ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),"的使用。"]}),"\n",(0,s.jsxs)(n.h2,{id:"二-类组件生命周期介绍",children:["二 类组件生命周期介绍",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-类组件生命周期介绍",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在讲 React 生命周期之前，有必要先来简单聊聊 React 两个重要阶段，render 阶段和 commit 阶段，React 在调和( render )阶段会深度遍历 React fiber 树，目的就是发现不同( diff )，不同的地方就是接下来需要更新的地方，对于变化的组件，就会执行 render 函数。在一次调和过程完毕之后，就到了commit 阶段，commit 阶段会创建修改真实的 DOM 节点。"}),"\n",(0,s.jsxs)(n.p,{children:["如果在一次调和的过程中，发现了一个 ",(0,s.jsx)(n.code,{children:"fiber tag = 1 "})," 类组件的情况，就会按照类组件的逻辑来处理。对于类组件的处理逻辑，首先判断类组件是否已经被创建过，首先来看看源码里怎么写的。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberBeginWork.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/* workloop React 处理类组件的主要功能方法 */\nfunction updateClassComponent(){\n    let shouldUpdate\n    const instance = workInProgress.stateNode // stateNode 是 fiber 指向 类组件实例的指针。\n     if (instance === null) { // instance 为组件实例,如果组件实例不存在，证明该类组件没有被挂载过，那么会走初始化流程\n        constructClassInstance(workInProgress, Component, nextProps); // 组件实例将在这个方法中被new。\n        mountClassInstance(  workInProgress,Component, nextProps,renderExpirationTime ); //初始化挂载组件流程\n        shouldUpdate = true; // shouldUpdate 标识用来证明 组件是否需要更新。\n     }else{  \n        shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderExpirationTime) // 更新组件流程\n     }\n     if(shouldUpdate){\n         nextChildren = instance.render(); /* 执行render函数 ，得到子节点 */\n        reconcileChildren(current,workInProgress,nextChildren,renderExpirationTime) /* 继续调和子节点 */\n     }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"几个重要概念："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["① ",(0,s.jsx)(n.code,{children:"instance"})," 类组件对应实例。"]}),"\n",(0,s.jsxs)(n.li,{children:["② ",(0,s.jsx)(n.code,{children:"workInProgress"})," 树，当前正在调和的 fiber 树 ，一次更新中，React 会自上而下深度遍历子代 fiber ，如果遍历到一个 fiber ，会把当前 fiber 指向 workInProgress。"]}),"\n",(0,s.jsxs)(n.li,{children:["③ ",(0,s.jsx)(n.code,{children:"current"})," 树，在初始化更新中，current = null ，在第一次 fiber 调和之后，会将 workInProgress 树赋值给 current 树。React 来用workInProgress 和 current 来确保一次更新中，快速构建，并且状态不丢失。"]}),"\n",(0,s.jsxs)(n.li,{children:["④ ",(0,s.jsx)(n.code,{children:"Component"})," 就是项目中的 class 组件。"]}),"\n",(0,s.jsxs)(n.li,{children:["⑤ ",(0,s.jsx)(n.code,{children:"nextProps"})," 作为组件在一次更新中新的 props 。"]}),"\n",(0,s.jsxs)(n.li,{children:["⑥ ",(0,s.jsx)(n.code,{children:"renderExpirationTime"})," 作为下一次渲染的过期时间。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"上面这个函数流程我已经标的很清楚了，同学们在学习React的过程中，重要的属性一定要拿小本本记下来，比如说类组件完成渲染挂载之后， React 用什么记录组件对应的 fiber 对象和类组件实例之间的关系。只有搞清楚这些，才能慢慢深入学习 React 。"}),"\n",(0,s.jsxs)(n.p,{children:["在组件实例上可以通过 ",(0,s.jsx)(n.code,{children:"_reactInternals"})," 属性来访问组件对应的 fiber 对象。在 fiber 对象上，可以通过 ",(0,s.jsx)(n.code,{children:"stateNode"})," 来访问当前 fiber 对应的组件实例。两者的关系如下图所示。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"lifecycle3.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"react-类组件生命周期执行过程探秘",children:["React 类组件生命周期执行过程探秘",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-类组件生命周期执行过程探秘",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["React 的大部分生命周期的执行，都在 ",(0,s.jsx)(n.code,{children:"mountClassInstance"})," 和",(0,s.jsx)(n.code,{children:"updateClassInstance"})," 这两个方法中执行，所以为了让大家深入学习 React 生命周期的执行过程，我觉得有必要去揭秘这两个函数充当了什么角色。我把流程简化成 mount (初始化渲染) 和 update (更新)两个方向。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了让大家更理解生命周期的执行流程，我这里分为",(0,s.jsx)(n.strong,{children:"组件初始化"}),"，",(0,s.jsx)(n.strong,{children:"组件更新"})," ， ",(0,s.jsx)(n.strong,{children:"组件销毁"})," ，三大阶段分析。"]}),"\n",(0,s.jsxs)(n.h4,{id:"初始化阶段",children:["初始化阶段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化阶段",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"① constructor 执行"})}),"\n",(0,s.jsx)(n.p,{children:"在 mount 阶段，首先执行的 constructClassInstance 函数，用来实例化 React 组件，在组件章节已经介绍了这个函数，组件中 constructor 就是在这里执行的。"}),"\n",(0,s.jsx)(n.p,{children:"在实例化组件之后，会调用 mountClassInstance 组件初始化。"}),"\n",(0,s.jsx)(n.p,{children:"接下来看一下 mountClassInstance 做了些什么？ 我只写了和生命周期息息相关的代码。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberClassComponent.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function mountClassInstance(workInProgress,ctor,newProps,renderExpirationTime){\n    const instance = workInProgress.stateNode;\n     const getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') { /* ctor 就是我们写的类组件，获取类组件的静态方法 */\n     const partialState = getDerivedStateFromProps(nextProps, prevState); /* 这个时候执行 getDerivedStateFromProps 生命周期 ，得到将合并的state */\n     const memoizedState = partialState === null || partialState === undefined ? prevState : Object.assign({}, prevState, partialState); // 合并state\n     workInProgress.memoizedState = memoizedState;\n     instance.state = workInProgress.memoizedState; /* 将state 赋值给我们实例上，instance.state  就是我们在组件中 this.state获取的state*/\n  }\n  if(typeof ctor.getDerivedStateFromProps !== 'function' &&   typeof instance.getSnapshotBeforeUpdate !== 'function' && typeof instance.componentWillMount === 'function' ){\n      instance.componentWillMount(); /* 当 getDerivedStateFromProps 和 getSnapshotBeforeUpdate 不存在的时候 ，执行 componentWillMount*/\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"② getDerivedStateFromProps 执行"})}),"\n",(0,s.jsxs)(n.p,{children:["在初始化阶段，",(0,s.jsx)(n.code,{children:"getDerivedStateFromProps"})," 是第二个执行的生命周期，值得注意的是它是从 ctor 类上直接绑定的静态方法，传入 props ，state 。 返回值将和之前的 state 合并，作为新的 state ，传递给组件实例使用。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"③ componentWillMount 执行"})}),"\n",(0,s.jsxs)(n.p,{children:["如果存在 ",(0,s.jsx)(n.code,{children:"getDerivedStateFromProps"})," 和 ",(0,s.jsx)(n.code,{children:"getSnapshotBeforeUpdate"})," 就不会执行生命周期",(0,s.jsx)(n.code,{children:"componentWillMount"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"④ render 函数执行"})}),"\n",(0,s.jsxs)(n.p,{children:["到此为止 ",(0,s.jsx)(n.code,{children:"mountClassInstancec"})," 函数完成，但是上面 ",(0,s.jsx)(n.code,{children:"updateClassComponent"})," 函数， 在执行完 ",(0,s.jsx)(n.code,{children:"mountClassInstancec"})," 后，执行了 render 渲染函数，形成了 children ， 接下来 React 调用 reconcileChildren 方法深度调和 children 。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"⑤componentDidMount执行"})}),"\n",(0,s.jsxs)(n.p,{children:["细心的同学可能发现，生命周期 ",(0,s.jsx)(n.code,{children:"componentDidMount"})," 还没有出现，那么 ",(0,s.jsx)(n.code,{children:"componentDidMount"})," 是如何执行的呢？上文中简单介绍了 render 和 commit 两个阶段，上述提及的几生命周期都是在 render 阶段执行的。一旦 React 调和完所有的 fiber 节点，就会到 commit 阶段，在组件初始化 commit 阶段，会调用 ",(0,s.jsx)(n.code,{children:"componentDidMount"})," 生命周期。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function commitLifeCycles(finishedRoot,current,finishedWork){\n     switch (finishedWork.tag){                             /* fiber tag 在第一节讲了不同fiber类型 */\n        case ClassComponent: {                              /* 如果是 类组件 类型 */\n             const instance = finishedWork.stateNode        /* 类实例 */\n             if(current === null){                          /* 类组件第一次调和渲染 */\n                instance.componentDidMount() \n             }else{                                         /* 类组件更新 */\n                instance.componentDidUpdate(prevProps,prevState，instance.__reactInternalSnapshotBeforeUpdate); \n             }\n        }\n     }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["从上面可以直观看到 ",(0,s.jsx)(n.code,{children:"componentDidMount"})," 执行时机 和 ",(0,s.jsx)(n.code,{children:"componentDidUpdate"})," 执行时机是相同的 ，只不过一个是针对初始化，一个是针对组件再更新。到此初始化阶段，生命周期执行完毕。"]}),"\n",(0,s.jsx)(n.p,{children:"执行顺序：constructor -> getDerivedStateFromProps / componentWillMount -> render -> componentDidMount"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"lifesycle4.jpg"})}),"\n",(0,s.jsx)(n.p,{children:"接下来分析一下一次组件更新中，会有哪些生命周期执行呢？"}),"\n",(0,s.jsxs)(n.h4,{id:"更新阶段",children:["更新阶段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新阶段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["接下来一次类组件的更新阶段，到底会执行那些生命周期函数呢，回到了最开始 ",(0,s.jsx)(n.code,{children:"updateClassComponent"})," 函数了，当发现 current 不为 null 的情况时，说明该类组件被挂载过，那么直接按照更新逻辑来处理。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberClassComponent.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function updateClassInstance(current,workInProgress,ctor,newProps,renderExpirationTime){\n    const instance = workInProgress.stateNode; // 类组件实例\n    const hasNewLifecycles =  typeof ctor.getDerivedStateFromProps === 'function'  // 判断是否具有 getDerivedStateFromProps 生命周期\n    if(!hasNewLifecycles && typeof instance.componentWillReceiveProps === 'function' ){\n         if (oldProps !== newProps || oldContext !== nextContext) {     // 浅比较 props 不相等\n            instance.componentWillReceiveProps(newProps, nextContext);  // 执行生命周期 componentWillReceiveProps \n         }\n    }\n    let newState = (instance.state = oldState);\n    if (typeof getDerivedStateFromProps === 'function') {\n        ctor.getDerivedStateFromProps(nextProps,prevState)  /* 执行生命周期getDerivedStateFromProps  ，逻辑和mounted类似 ，合并state  */\n        newState = workInProgress.memoizedState;\n    }   \n    let shouldUpdate = true\n    if(typeof instance.shouldComponentUpdate === 'function' ){ /* 执行生命周期 shouldComponentUpdate 返回值决定是否执行render ，调和子节点 */\n        shouldUpdate = instance.shouldComponentUpdate(newProps,newState,nextContext,);\n    }\n    if(shouldUpdate){\n        if (typeof instance.componentWillUpdate === 'function') {\n            instance.componentWillUpdate(); /* 执行生命周期 componentWillUpdate  */\n        }\n    }\n    return shouldUpdate\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"①执行生命周期 componentWillReceiveProps"})}),"\n",(0,s.jsxs)(n.p,{children:["首先判断 ",(0,s.jsx)(n.code,{children:"getDerivedStateFromProps"})," 生命周期是否存在，如果不存在就执行",(0,s.jsx)(n.code,{children:"componentWillReceiveProps"}),"生命周期。传入该生命周期两个参数，分别是 newProps 和 nextContext 。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"②执行生命周期 getDerivedStateFromProps"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来执行生命周期",(0,s.jsx)(n.code,{children:"getDerivedStateFromProps"}),"， 返回的值用于合并state，生成新的state。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"③执行生命周期 shouldComponentUpdate"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来执行生命周期",(0,s.jsx)(n.code,{children:"shouldComponentUpdate"}),"，传入新的 props ，新的 state ，和新的 context ，返回值决定是否继续执行 render 函数，调和子节点。这里应该注意一个问题，",(0,s.jsx)(n.code,{children:"getDerivedStateFromProps"})," 的返回值可以作为新的 state ，传递给 shouldComponentUpdate 。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"④执行生命周期 componentWillUpdate"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来执行生命周期 ",(0,s.jsx)(n.code,{children:"componentWillUpdate"}),"。updateClassInstance 方法到此执行完毕了。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"⑤执行 render 函数"})}),"\n",(0,s.jsx)(n.p,{children:"接下来会执行 render 函数，得到最新的 React element 元素。然后继续调和子节点。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"⑥执行 getSnapshotBeforeUpdate"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function commitBeforeMutationLifeCycles(current,finishedWork){\n     switch (finishedWork.tag) {\n          case ClassComponent:{\n               const snapshot = instance.getSnapshotBeforeUpdate(prevProps,prevState) /* 执行生命周期 getSnapshotBeforeUpdate   */\n                instance.__reactInternalSnapshotBeforeUpdate = snapshot; /* 返回值将作为 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 生命周期  */\n          }\n     }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getSnapshotBeforeUpdate"})," 的执行也是在 commit 阶段，commit 阶段细分为 ",(0,s.jsx)(n.code,{children:"before Mutation"}),"( DOM 修改前)，",(0,s.jsx)(n.code,{children:"Mutation"})," ( DOM 修改)，",(0,s.jsx)(n.code,{children:"Layout"}),"( DOM 修改后) 三个阶段，getSnapshotBeforeUpdate 发生在",(0,s.jsx)(n.code,{children:"before Mutation"})," 阶段，生命周期的返回值，将作为第三个参数 __reactInternalSnapshotBeforeUpdate 传递给 componentDidUpdate 。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"⑦执行 componentDidUpdate"})}),"\n",(0,s.jsx)(n.p,{children:"接下来执行生命周期 componentDidUpdate ，此时 DOM 已经修改完成。可以操作修改之后的 DOM 。到此为止更新阶段的生命周期执行完毕。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"lifecycle5.jpg"})}),"\n",(0,s.jsx)(n.p,{children:"更新阶段对应的生命周期的执行顺序："}),"\n",(0,s.jsx)(n.p,{children:"componentWillReceiveProps( props 改变) / getDerivedStateFromProp -> shouldComponentUpdate -> componentWillUpdate -> render  -> getSnapshotBeforeUpdate ->  componentDidUpdate"}),"\n",(0,s.jsxs)(n.h4,{id:"销毁阶段",children:["销毁阶段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#销毁阶段",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberCommitWork.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function callComponentWillUnmountWithTimer(){\n    instance.componentWillUnmount();\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"①执行生命周期 componentWillUnmount"})}),"\n",(0,s.jsxs)(n.p,{children:["销毁阶段就比较简单了，在一次调和更新中，如果发现元素被移除，就会打对应的 Deletion 标签 ，然后在 commit 阶段就会调用 ",(0,s.jsx)(n.code,{children:"componentWillUnmount"})," 生命周期，接下来统一卸载组件以及 DOM 元素。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"lifecycle6.jpg"})}),"\n",(0,s.jsx)(n.p,{children:"三个阶段生命周期+无状态组件总览图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"lifesycyle8.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"react-各阶段生命周期能做些什么",children:["React 各阶段生命周期能做些什么",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-各阶段生命周期能做些什么",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上面部分详细的介绍了 React 各生命周期的执行时机和执行顺序。接下来分别介绍一下各个 lifecycle 能做些什么？"}),"\n",(0,s.jsxs)(n.h4,{id:"1-constructor",children:["1 constructor",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-constructor",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"React 在不同时期抛出不同的生命周期钩子，也就意味这这些生命周期钩子的使命。上面讲过 constructor 在类组件创建实例时调用，而且初始化的时候执行一次，所以可以在 constructor 做一些初始化的工作。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"constructor(props){\n    super(props)        // 执行 super ，别忘了传递props,才能在接下来的上下文中，获取到props。\n    this.state={       //① 可以用来初始化state，比如可以用来获取路由中的\n        name:'alien'\n    }\n    this.handleClick = this.handleClick.bind(this) /* ② 绑定 this */\n    this.handleInputChange = debounce(this.handleInputChange , 500) /* ③ 绑定防抖函数，防抖 500 毫秒 */\n    const _render = this.render\n    this.render = function(){\n        return _render.bind(this)  /* ④ 劫持修改类组件上的一些生命周期 */\n    }\n}\n/* 点击事件 */\nhandleClick(){ /* ... */ }\n/* 表单输入 */\nhandleInputChange(){ /* ... */ }\n"})}),"\n",(0,s.jsx)(n.p,{children:"constructor 作用："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"初始化 state ，比如可以用来截取路由中的参数，赋值给 state 。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"对类组件的事件做一些处理，比如绑定 this ， 节流，防抖等。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"对类组件进行一些必要生命周期的劫持，渲染劫持，这个功能更适合反向继承的HOC ，在 HOC 环节，会详细讲解反向继承这种模式。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"2-getderivedstatefromprops",children:["2 getDerivedStateFromProps",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-getderivedstatefromprops",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"getDerivedStateFromProps(nextProps,prevState)\n"})}),"\n",(0,s.jsx)(n.p,{children:"两个参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"nextProps 父组件新传递的 props ;"}),"\n",(0,s.jsx)(n.li,{children:"prevState 传入 getDerivedStateFromProps 待合并的 state 。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getDerivedStateFromProps"})," 方法作为类的静态属性方法执行，内部是访问不到 ",(0,s.jsx)(n.code,{children:"this"})," 的，它更趋向于纯函数，从源码中就能够体会到 React 对该生命周期定义为取缔 componentWillMount 和 componentWillReceiveProps 。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果把 getDerivedStateFromProps 英文分解 get ｜ Derived | State ｜ From ｜ Props  翻译  ",(0,s.jsx)(n.strong,{children:"得到 派生的 state 从 props 中"})," ，正如它的名字一样，这个生命周期用于，在初始化和更新阶段，接受父组件的 props 数据， 可以对 props 进行格式化，过滤等操作，返回值将作为新的 state 合并到 state 中，供给视图渲染层消费。"]}),"\n",(0,s.jsxs)(n.p,{children:["从源码中可以看到，只要组件更新，就会执行 ",(0,s.jsx)(n.code,{children:"getDerivedStateFromProps"}),"，不管是 props 改变，还是 setState ，或是 forceUpdate 。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"static getDerivedStateFromProps(newProps){\n    const { type } = newProps\n    switch(type){\n        case 'fruit' : \n        return { list:['苹果','香蕉','葡萄' ] } /* ① 接受 props 变化 ， 返回值将作为新的 state ，用于 渲染 或 传递给s houldComponentUpdate */\n        case 'vegetables':\n        return { list:['菠菜','西红柿','土豆']}\n    }\n}\nrender(){\n    return <div>{ this.state.list.map((item)=><li key={item} >{ item  }</li>) }</div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"getDerivedStateFromProps 作用："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"代替 componentWillMount 和 componentWillReceiveProps"}),"\n",(0,s.jsx)(n.li,{children:"组件初始化或者更新时，将 props 映射到 state。"}),"\n",(0,s.jsx)(n.li,{children:"返回值与 state 合并完，可以作为 shouldComponentUpdate 第二个参数  newState ，可以判断是否渲染组件。(请不要把 getDerivedStateFromProps 和 shouldComponentUpdate 强行关联到一起，两者没有必然联系)"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"3-componentwillmount-和-unsafe_componentwillmount",children:["3 componentWillMount 和 UNSAFE_componentWillMount",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-componentwillmount-和-unsafe_componentwillmount",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 React V16.3 componentWillMount ，componentWillReceiveProps ， componentWillUpdate 三个生命周期加上了不安全的标识符 ",(0,s.jsx)(n.code,{children:"UNSAFE"}),"，变成了如下形式，在目前最新的版本React ",(0,s.jsx)(n.code,{children:"V17.0.2 "}),"也没有废弃这三个生命周期。可能不久之后更高级的版本会被废除吧，首先先来看一下为什么要加",(0,s.jsx)(n.code,{children:"UNSAFE"}),"，首先根据源码，大家有没有发现一个问题，就是这三个生命周期，都是在 render 之前执行的，React 对于执行 render 函数有着像 shouldUpdate 等条件制约，但是对于执行在 render 之前生命周期没有限制，存在一定隐匿风险，如果 updateClassInstance 执行多次，React 开发者滥用这几个生命周期，可能导致生命周期内的上下文多次被执行。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"UNSAFE_componentWillMount"}),"\n",(0,s.jsx)(n.li,{children:"UNSAFE_componentWillReceiveProps"}),"\n",(0,s.jsx)(n.li,{children:"UNSAFE_componentWillUpdate"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"UNSAFE_componentWillMount 的作用还是做一些初始化操作，但是不建议在这个生命周期写，毕竟未来 React 可能完全取缔它。"}),"\n",(0,s.jsxs)(n.h4,{id:"4-componentwillreceiveprops-和-unsafe_componentwillreceiveprops",children:["4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-componentwillreceiveprops-和-unsafe_componentwillreceiveprops",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"UNSAFE_componentWillReceiveProps 函数的执行是在更新组件阶段，该生命周期执行驱动是因为父组件更新带来的 props 修改，但是只要父组件触发 render 函数，调用 React.createElement 方法，那么 props 就会被重新创建，生命周期 componentWillReceiveProps 就会执行了。这就解释了即使 props 没变，该生命周期也会执行。"}),"\n",(0,s.jsx)(n.p,{children:"componentWillReceiveProps 可以用来干什么？我把上面例子修改一下。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"UNSAFE_componentWillReceiveProps(newProps){\n        const { type } = newProps\n        console.log('父组件render执行') /*  ① 监听父组件执行render  */\n        setTimeout(()=>{  /* ② 异步控制props改变，派生出来的 state 的修改  */\n            switch(type){\n                case 'fruit' : \n                this.setState({list:['苹果','香蕉','葡萄' ] }) \n                break\n                case 'vegetables':\n                this.setState({list:['苹果','香蕉','葡萄' ] }) \n                break\n            }\n        },0)\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"componentWillReceiveProps 可以用来监听父组件是否执行 render 。"}),"\n",(0,s.jsx)(n.li,{children:"componentWillReceiveProps 可以用来接受 props 改变，组件可以根据props改变，来决定是否更新 state ，因为可以访问到 this ， 所以可以在异步成功回调(接口请求数据)改变 state 。这个是 getDerivedStateFromProps  不能实现的。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["但是笔者不建议用这种方式，props 改变，再触发 componentWillReceiveProps 异步请求数据渲染，这样首先在没做优化前提下会带来两次子组件的更新，第一次 props 改变，第二次 props 改变，异步改变state 。其次该生命周期的不安全性。再者需要在该生命周期内部，设置大量的条件判断语句，通过 this.props ， nextProps 判断 props 到底改变与否。所以完全可以换一种思路，那就是",(0,s.jsx)(n.strong,{children:"状态提升"}),"，把数据层完全托管父组件，子组件没有副作用，只负责渲染父组件传递的 props 即可。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"｜--------问与答---------｜"}),"\n问：当 props 不变的前提下， PureComponent 组件能否阻止 componentWillReceiveProps 执行？"]}),"\n",(0,s.jsx)(n.p,{children:"答案是否定的，componentWillReceiveProps 生命周期的执行，和纯组件没有关系，纯组件是在 componentWillReceiveProps 执行之后浅比较 props 是否发生变化。所以 PureComponent 下不会阻止该生命周期的执行。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"｜--------end---------｜"})}),"\n",(0,s.jsxs)(n.h4,{id:"5-componentwillupdate-和-unsafe_componentwillupdate",children:["5 componentWillUpdate 和 UNSAFE_componentWillUpdate",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-componentwillupdate-和-unsafe_componentwillupdate",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"UNSAFE_componentWillUpdate 可以意味着在更新之前，此时的 DOM 还没有更新。在这里可以做一些获取 DOM 的操作。就比如说在一次更新中，保存 DOM 之前的信息(记录上一次位置)。但是 React 已经出了新的生命周期 getSnapshotBeforeUpdate 来代替 UNSAFE_componentWillUpdate。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"UNSAFE_componentWillUpdate(){\n    const position = this.getPostion(this.node) /* 获取元素节点 node 位置 */\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"作用："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"获取组件更新之前的状态。比如 DOM 元素位置等。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"6-render",children:["6 render",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-render",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"还记得在第一节 jsx 主要讲了 render 之后会成什么样子。所谓 render 函数，就是 jsx 的各个元素被 React.createElement 创建成 React element 对象的形式。一次 render 的过程，就是创建 React.element 元素的过程。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["那么可以在render里面做一些,",(0,s.jsx)(n.strong,{children:"createElement创建元素"})," , ",(0,s.jsx)(n.strong,{children:"cloneElement 克隆元素"})," ，",(0,s.jsx)(n.strong,{children:"React.children 遍历 children"})," 的操作。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"7-getsnapshotbeforeupdate",children:["7 getSnapshotBeforeUpdate",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-getsnapshotbeforeupdate",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"getSnapshotBeforeUpdate(prevProps,preState){}\n"})}),"\n",(0,s.jsx)(n.p,{children:"两个参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"prevProps更新前的props ；"}),"\n",(0,s.jsx)(n.li,{children:"preState更新前的state；"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["把 getSnapshotBeforeUpdate 用英文解释一下 ， ",(0,s.jsx)(n.strong,{children:"get | snap shot | before | update"})," ， 中文翻译为 ",(0,s.jsx)(n.strong,{children:"获取更新前的快照"}),"，可以进一步理解为 获取更新前 DOM 的状态。见名知意，上面说过该生命周期是在 commit 阶段的before Mutation ( DOM 修改前)，此时 DOM 还没有更新，但是在接下来的 Mutation 阶段会被替换成真实 DOM 。此时是获取 DOM 信息的最佳时期，getSnapshotBeforeUpdate 将返回一个值作为一个",(0,s.jsx)(n.code,{children:"snapShot"}),"(快照)，传递给 componentDidUpdate作为第三个参数。"]}),"\n",(0,s.jsxs)(n.p,{children:["注意：如果没有返回值会给予警告⚠️，如果没有 ",(0,s.jsx)(n.code,{children:"componentDidUpdate"}),"也会给予警告。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"getSnapshotBeforeUpdate(prevProps,preState){\n    const style = getComputedStyle(this.node) \n    return { /* 传递更新前的元素位置 */\n        cx:style.cx,\n        cy:style.cy\n    }\n}\ncomponentDidUpdate(prevProps, prevState, snapshot){\n    /* 获取元素绘制之前的位置 */\n    console.log(snapshot)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当然这个快照 ",(0,s.jsx)(n.code,{children:"snapShot"})," 不限于 DOM 的信息，也可以是根据 DOM 计算出来产物。"]}),"\n",(0,s.jsx)(n.p,{children:"作用："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"getSnapshotBeforeUpdate 这个生命周期意义就是配合componentDidUpdate 一起使用，计算形成一个 snapShot 传递给 componentDidUpdate 。保存一次更新前的信息。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"8-componentdidupdate",children:["8 componentDidUpdate",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-componentdidupdate",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"componentDidUpdate(prevProps, prevState, snapshot){\n    const style = getComputedStyle(this.node)\n    const newPosition = { /* 获取元素最新位置信息 */\n        cx:style.cx,\n        cy:style.cy\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"三个参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"prevProps 更新之前的 props ；"}),"\n",(0,s.jsx)(n.li,{children:"prevState 更新之前的 state ；"}),"\n",(0,s.jsx)(n.li,{children:"snapshot 为 getSnapshotBeforeUpdate 返回的快照，可以是更新前的 DOM 信息。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"作用"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"componentDidUpdate 生命周期执行，此时 DOM 已经更新，可以直接获取 DOM 最新状态。这个函数里面如果想要使用 setState ，一定要加以限制，否则会引起无限循环。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"接受 getSnapshotBeforeUpdate 保存的快照信息。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"9-componentdidmount",children:["9 componentDidMount",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-componentdidmount",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["componentDidMount 生命周期执行时机和 componentDidUpdate 一样，一个是在",(0,s.jsx)(n.strong,{children:"初始化"}),"，一个是",(0,s.jsx)(n.strong,{children:"组件更新"}),"。此时 DOM 已经创建完，既然 DOM 已经创建挂载，就可以做一些基于 DOM 操作，DOM 事件监听器。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"async componentDidMount(){\n    this.node.addEventListener('click',()=>{\n        /* 事件监听 */\n    }) \n    const data = await this.getData() /* 数据请求 */\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"作用："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"可以做一些关于 DOM 操作，比如基于 DOM 的事件监听器。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"对于初始化向服务器请求数据，渲染视图，这个生命周期也是蛮合适的。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"10-shouldcomponentupdate",children:["10 shouldComponentUpdate",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-shouldcomponentupdate",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"shouldComponentUpdate(newProps,newState,nextContext){}\n"})}),"\n",(0,s.jsx)(n.p,{children:"shouldComponentUpdate 三个参数，第一个参数新的 props ，第二个参数新的 state ，第三个参数新的 context 。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"shouldComponentUpdate(newProps,newState){\n    if(newProps.a !== this.props.a ){ /* props中a属性发生变化 渲染组件 */\n        return true\n    }else if(newState.b !== this.props.b ){ /* state 中b属性发生变化 渲染组件 */\n        return true\n    }else{ /* 否则组件不渲染 */\n        return false\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"这个生命周期，一般用于性能优化，shouldComponentUpdate 返回值决定是否重新渲染的类组件。需要重点关注的是第二个参数 newState ，如果有 getDerivedStateFromProps 生命周期 ，它的返回值将合并到 newState ，供 shouldComponentUpdate 使用。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"11-componentwillunmount",children:["11 componentWillUnmount",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-componentwillunmount",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"componentWillUnmount 是组件销毁阶段唯一执行的生命周期，主要做一些收尾工作，比如清除一些可能造成内存泄漏的定时器，延时器，或者是一些事件监听器。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"componentWillUnmount(){\n    clearTimeout(this.timer)  /* 清除延时器 */\n    this.node.removeEventListener('click',this.handerClick) /* 卸载事件监听器 */\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"作用"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"清除延时器，定时器。"}),"\n",(0,s.jsx)(n.li,{children:"一些基于 DOM 的操作，比如事件监听器。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-函数组件生命周期替代方案",children:["3 函数组件生命周期替代方案",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-函数组件生命周期替代方案",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["React hooks也提供了 api ，用于弥补函数组件没有生命周期的缺陷。其原理主要是运用了 hooks 里面的 ",(0,s.jsx)(n.code,{children:"useEffect"})," 和 ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-useeffect-和-uselayouteffect",children:["1 useEffect 和 useLayoutEffect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-useeffect-和-uselayouteffect",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"useEffect"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"useEffect(()=>{\n    return destory\n},dep)\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"useEffect 第一个参数 callback, 返回的 destory ， destory 作为下一次callback执行之前调用，用于清除上一次 callback 产生的副作用。"}),"\n",(0,s.jsx)(n.p,{children:"第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 destory ，和执行新的 effect 第一个参数 callback 。"}),"\n",(0,s.jsxs)(n.p,{children:["对于 useEffect 执行， React 处理逻辑是采用异步调用 ，对于每一个 effect 的 callback， React 会向 ",(0,s.jsx)(n.code,{children:"setTimeout"}),"回调函数一样，放入任务队列，等到主线程任务完成，DOM 更新，js 执行完成，视图绘制完毕，才执行。所以 effect 回调函数不会阻塞浏览器绘制视图。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"useLayoutEffect:"})}),"\n",(0,s.jsx)(n.p,{children:"useLayoutEffect 和 useEffect 不同的地方是采用了同步执行，那么和useEffect有什么区别呢？"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"首先 useLayoutEffect 是在 DOM 更新之后，浏览器绘制之前，这样可以方便修改 DOM，获取 DOM 信息，这样浏览器只会绘制一次，如果修改 DOM 布局放在 useEffect ，那 useEffect 执行是在浏览器绘制视图之后，接下来又改 DOM ，就可能会导致浏览器再次回流和重绘。而且由于两次绘制，视图上可能会造成闪现突兀的效果。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"useLayoutEffect callback 中代码执行会阻塞浏览器绘制。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"一句话概括如何选择 useEffect 和 useLayoutEffect ：修改 DOM ，改变布局就用 useLayoutEffect ，其他情况就用 useEffect 。"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"｜--------问与答---------｜"}),"\n问：React.useEffect 回调函数 和 componentDidMount / componentDidUpdate 执行时机有什么区别 ？"]}),"\n",(0,s.jsx)(n.p,{children:"答：useEffect 对 React 执行栈来看是异步执行的，而 componentDidMount / componentDidUpdate 是同步执行的，useEffect代码不会阻塞浏览器绘制。在时机上 ，componentDidMount / componentDidUpdate 和 useLayoutEffect 更类似。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"｜---------end----------｜"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-useinsertioneffect",children:["2 useInsertionEffect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-useinsertioneffect",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"useInsertionEffect 是在 React v18 新添加的 hooks ，它的用法和 useEffect 和 useLayoutEffect 一样。那么这个 hooks 用于什么呢?"}),"\n",(0,s.jsx)(n.p,{children:"在介绍 useInsertionEffect 用途之前，先看一下 useInsertionEffect 的执行时机。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"React.useEffect(()=>{\n    console.log('useEffect 执行')\n},[])\n\nReact.useLayoutEffect(()=>{\n    console.log('useLayoutEffect 执行')\n},[])\n\nReact.useInsertionEffect(()=>{\n    console.log('useInsertionEffect 执行')\n},[])\n"})}),"\n",(0,s.jsx)(n.p,{children:"打印：\nuseInsertionEffect 执行\nuseLayoutEffect 执行\nuseEffect 执行"}),"\n",(0,s.jsx)(n.p,{children:"可以看到 useInsertionEffect 的执行时机要比 useLayoutEffect 提前，useLayoutEffect 执行的时候 DOM 已经更新了，但是在 useInsertionEffect 的执行的时候，DOM 还没有更新。"}),"\n",(0,s.jsx)(n.p,{children:"本质上 useInsertionEffect 主要是解决 CSS-in-JS 在渲染中注入样式的性能问题。这个 hooks 主要是应用于这个场景，在其他场景下 React 不期望用这个 hooks 。"}),"\n",(0,s.jsx)(n.p,{children:"CSS-in-JS 的注入会引发哪些问题呢？ 首先看部分 CSS-in-JS 的实现原理，拿 Styled-components 为例子，通过styled-components，你可以使用ES6的标签模板字符串语法（Tagged Templates）为需要 styled 的 Component 定义一系列CSS属性，当该组件的JS代码被解析执行的时候，styled-components 会动态生成一个 CSS 选择器，并把对应的 CSS 样式通过 style 标签的形式插入到 head 标签里面。动态生成的 CSS 选择器会有一小段哈希值来保证全局唯一性来避免样式发生冲突。这种模式下本质上是动态生成 style 标签。"}),"\n",(0,s.jsx)(n.p,{children:"明白了 Styled-components 原理之后，再来看一下，如果在 useLayoutEffect 使用 CSS-in-JS 会造成哪里问题呢？"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"首先 useLayoutEffect 执行的时机 DOM 已经更新完成，布局也已经确定了，剩下的就是交给浏览器绘制就行了。"}),"\n",(0,s.jsx)(n.li,{children:"如果在 useLayoutEffect 动态生成 style 标签，那么会再次影响布局，导致浏览器再次重回和重排。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这个是时候 useInsertionEffect 的作用就出现了，useInsertionEffect 的执行在 DOM 更新前，所以此时使用 CSS-in-JS 避免了浏览器出现再次重回和重排的可能，解决了性能上的问题。"}),"\n",(0,s.jsx)(n.p,{children:"接下来我们模拟一下在 useInsertionEffect 使用 CSS-in-JS 流程："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default function Index(){\n\n  React.useInsertionEffect(()=>{\n     /* 动态创建 style 标签插入到 head 中 */\n     const style = document.createElement('style')\n     style.innerHTML = `\n       .css-in-js{\n         color: red;\n         font-size: 20px;\n       }\n     `\n     document.head.appendChild(style)\n  },[])\n\n  return <div className=\"css-in-js\" > hello , useInsertionEffect </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"2.png"})}),"\n",(0,s.jsx)(n.p,{children:"此时 div 的字体颜色和字体大小已经更改。"}),"\n",(0,s.jsx)(n.p,{children:"上述详细的介绍了 useEffect，useLayoutEffect 和 useInsertionEffect，接下来拿 useEffect 做参考，详细介绍一下函数组件怎么实现生命周期的替代方案的。"}),"\n",(0,s.jsxs)(n.h3,{id:"3-componentdidmount-替代方案",children:["3 componentDidMount 替代方案",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-componentdidmount-替代方案",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"React.useEffect(()=>{\n    /* 请求数据 ， 事件监听 ， 操纵dom */\n},[])  /* 切记 dep = [] */\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里要记住 ",(0,s.jsx)(n.code,{children:"dep = []"})," ，这样当前 effect 没有任何依赖项，也就只有初始化执行一次。"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-componentwillunmount-替代方案",children:["4 componentWillUnmount 替代方案",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-componentwillunmount-替代方案",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:" React.useEffect(()=>{\n        /* 请求数据 ， 事件监听 ， 操纵dom ， 增加定时器，延时器 */\n        return function componentWillUnmount(){\n            /* 解除事件监听器 ，清除定时器，延时器 */\n        }\n},[])/* 切记 dep = [] */\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 componentDidMount 的前提下，useEffect 第一个函数的返回函数，可以作为 componentWillUnmount 使用。"}),"\n",(0,s.jsxs)(n.h3,{id:"5-componentwillreceiveprops-代替方案",children:["5 componentWillReceiveProps 代替方案",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-componentwillreceiveprops-代替方案",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"说 useEffect 代替 componentWillReceiveProps 着实有点牵强。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"首先因为二者的执行阶段根本不同，一个是在render阶段，一个是在commit阶段。"}),"\n",(0,s.jsxs)(n.li,{children:["其次 ",(0,s.jsx)(n.strong,{children:"useEffect 会初始化执行一次"}),"，但是 componentWillReceiveProps 只有组件更新 props 变化的时候才会执行。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"React.useEffect(()=>{\n    console.log('props变化：componentWillReceiveProps')\n},[ props ])\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时依赖项就是 props，props 变化，执行此时的 useEffect 钩子。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"React.useEffect(()=>{\n    console.log('props中number变化：componentWillReceiveProps')\n},[ props.number ]) /* 当前仅当 props中number变化，执行当前effect钩子 */\n"})}),"\n",(0,s.jsx)(n.p,{children:"useEffect 还可以针对 props 的某一个属性进行追踪。此时的依赖项为 props 的追踪属性。如上述代码，只有 props 中 number 变化，执行 effect 。"}),"\n",(0,s.jsxs)(n.h3,{id:"6-componentdidupdate-替代方案",children:["6 componentDidUpdate 替代方案",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-componentdidupdate-替代方案",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"useEffect 和 componentDidUpdate 在执行时期虽然有点差别，useEffect 是异步执行，componentDidUpdate 是同步执行 ，但都是在 commit 阶段 。但是向上面所说 useEffect 会默认执行一次，而 componentDidUpdate 只有在组件更新完成后执行。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"React.useEffect(()=>{\n    console.log('组件更新完成：componentDidUpdate ')     \n}) /* 没有 dep 依赖项 */\n"})}),"\n",(0,s.jsx)(n.p,{children:"注意此时useEffect没有第二个参数。"}),"\n",(0,s.jsx)(n.p,{children:"没有第二个参数，那么每一次执行函数组件，都会执行该 effect。"}),"\n",(0,s.jsxs)(n.h3,{id:"7-完整代码和效果",children:["7 完整代码和效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-完整代码和效果",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function FunctionLifecycle(props){\n    const [ num , setNum ] = useState(0)\n    React.useEffect(()=>{\n        /* 请求数据 ， 事件监听 ， 操纵dom  ， 增加定时器 ， 延时器 */\n        console.log('组件挂载完成：componentDidMount')\n        return function componentWillUnmount(){\n            /* 解除事件监听器 ，清除 */\n            console.log('组件销毁：componentWillUnmount')\n        }\n    },[])/* 切记 dep = [] */\n    React.useEffect(()=>{\n        console.log('props变化：componentWillReceiveProps')\n    },[ props ])\n    React.useEffect(()=>{ /*  */\n        console.log(' 组件更新完成：componentDidUpdate ')\n    })\n    return <div>\n        <div> props : { props.number } </div>\n        <div> states : { num } </div>\n        <button onClick={ ()=> setNum(state=>state + 1) }   >改变state</button>\n    </div>\n}\n\nexport default ()=>{\n    const [ number , setNumber ] = React.useState(0)\n    const [ isRender , setRender ] = React.useState(true)\n    return <div>\n        { isRender &&  <FunctionLifecycle number={number}  /> }\n        <button onClick={ ()=> setNumber(state => state + 1 ) } > 改变props  </button> <br/>\n        <button onClick={()=> setRender(false) } >卸载组件</button>\n    </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"lifecycle.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"四-实践-实现一个scrollview组件",children:["四 实践-实现一个ScrollView组件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-实践-实现一个scrollview组件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来为了让大家加深对生命周期各阶段的理解，我写了一个 demo ，编写一个类似小程序或是 webView 中的 scrollView 组件，主要用于长列表渲染，滑动底部请求渲染列表。"}),"\n",(0,s.jsx)(n.p,{children:"组件本身功能不重要，实现细节也不需要太纠结，本节讲的是生命周期，明白生命周期的各个阶段应该做些什么才重要。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"使用:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'/* item 完全是单元项的渲染ui */\nfunction Item({item}) {\n    return  <div className="goods_item" >\n        <img src={item.giftImage} className="item_image" />\n        <div className="item_content" >\n            <div className="goods_name" >\n                {item.giftName}\n            </div>\n            <div className="hold_price" />\n            <div className="new_price" >\n                <div className="new_price" >\n                    <div className="one view">\n                        \xa5 {item.price}\n                    </div>\n                </div>\n            </div>\n            <img className=\'go_share  go_text\' />\n        </div>\n    </div>\n}\n\nfunction () { \n    const [ data , setData ] = useState({ list:[],page:0,pageCount:1  }) /* 记录列表数据 */\n    /* 请求数据 */\n    const getData = async ()=>{\n        if(data.page === data.pageCount) return console.log(\'没有数据了～\')\n        const res = await fetchData(data.page + 1)\n        if(res.code === 0) setData({\n            ...res,\n            list:res.page === 1 ?  res.list : data.list.concat(res.list) \n        })\n    } \n    /* 滚动到底部触发 */\n    const handerScrolltolower = () => {\n        console.log(\'scroll已经到底部\')\n        getData()\n    }\n    /* 初始化请求数据 */\n    useEffect(()=>{\n        getData()\n    },[])\n    return <ScrollView \n            data={ data }       /*  */\n            component={ Item }  /* Item 渲染的单元组件 */\n            scrolltolower={ handerScrolltolower } \n            scroll={()=>{}} \n        />\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"实现效果"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"lifecycle2.gif"})}),"\n",(0,s.jsxs)(n.p,{children:["编写 ",(0,s.jsx)(n.strong,{children:"ScrollView"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class ScrollView extends React.Component{\n    /* -----自定义事件---- */\n    /* 控制滚动条滚动 */\n      handerScroll=(e)=>{\n        const { scroll } = this.props\n        scroll && scroll(e)\n        this.handerScrolltolower()\n    }\n    /* 判断滚动条是否到底部 */\n    handerScrolltolower(){\n       const { scrolltolower } = this.props\n       const { scrollHeight , scrollTop ,  offsetHeight } = this.node \n       if(scrollHeight === scrollTop + offsetHeight){ /* 到达容器底部位置 */\n           scrolltolower && scrolltolower()\n       }\n    }\n    node = null\n\n    /* ---——---生命周期------- */\n    constructor(props) {\n        super(props)\n        this.state={ /* 初始化 Data */\n            list:[]\n        }\n        this.handerScrolltolower = debounce(this.handerScrolltolower,200) /* 防抖处理 */               \n    }\n    /* 接收props, 合并到state */\n    static getDerivedStateFromProps(newProps){\n        const { data } = newProps\n        return { \n            list : data.list || [] ,\n        }\n    }\n    /* 性能优化，只有列表数据变化，渲染列表 */\n    shouldComponentUpdate(newProps,newState){\n       return newState.list !== this.state.list\n    }\n    /* 获取更新前容器高度 */\n    getSnapshotBeforeUpdate(){\n        return this.node.scrollHeight\n    }\n    /* 获取更新后容器高度 */\n    componentDidUpdate(prevProps, prevState, snapshot){\n        console.log('scrollView容器高度变化:' , this.node.scrollHeight - snapshot  )\n    }\n    /* 绑定事件监听器 - 监听scorll事件 */\n    componentDidMount() {\n        this.node.addEventListener('scroll',this.handerScroll)\n    }\n    /* 解绑事件监听器 */\n    componentWillUnmount(){\n        this.node.removeEventListener('scroll',this.handerScroll)\n    }\n    render() {\n        const { list } = this.state\n        const { component } = this.props\n        return <div className=\"list_box\"  ref={(node) => this.node = node }  >\n            <div >     \n                {\n                    list.map((item) => (\n                        React.createElement(component,{ item , key: item.id  }) //渲染 I\btem 列表内容。\n                    ))\n                }\n            </div>\n        </div>\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"scrollview组件各个生命周期功能："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"constructor"}),"： 做数据初始化，将滑动处理函数，做防抖处理。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getDerivedStateFromProps"}),": 将 props 中的 list ，合并到 state 。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"componentDidMount"}),": 绑定监听 scroll 事件。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"shouldComponentUpdate"}),"：性能优化，只有 list 改变，渲染视图。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"render"}),": 渲染视图，渲染 Item 。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getSnapshotBeforeUpdate"}),"：保存组件更新前的 scrollview 容器高度。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"componentDidUpdate"}),"：根据渲染前后容器高度，计算一次高度变化量。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"componentWillUnmount"}),"：解除 scroll 事件监听器。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"四-收获",children:["四 收获",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-收获",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"最后总结一下本章节收获哪些知识："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"类组件生命周期执行过程，以及细节；"}),"\n",(0,s.jsx)(n.li,{children:"讲解了类组件各个生命周期，每个生命周期能做的事情；"}),"\n",(0,s.jsx)(n.li,{children:"函数组件生命周期代替方案；"}),"\n",(0,s.jsx)(n.li,{children:"实战项目，各个生命周期应用实践。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"下一节，将一起探讨 React ref的奥秘。"})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}let m=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F6.%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%90%86%E8%A7%A3%20lifeCycle.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 类组件生命周期介绍",id:"二-类组件生命周期介绍",depth:2},{text:"React 类组件生命周期执行过程探秘",id:"react-类组件生命周期执行过程探秘",depth:3},{text:"初始化阶段",id:"初始化阶段",depth:4},{text:"更新阶段",id:"更新阶段",depth:4},{text:"销毁阶段",id:"销毁阶段",depth:4},{text:"React 各阶段生命周期能做些什么",id:"react-各阶段生命周期能做些什么",depth:3},{text:"1 constructor",id:"1-constructor",depth:4},{text:"2 getDerivedStateFromProps",id:"2-getderivedstatefromprops",depth:4},{text:"3 componentWillMount 和 UNSAFE_componentWillMount",id:"3-componentwillmount-和-unsafe_componentwillmount",depth:4},{text:"4 componentWillReceiveProps 和 UNSAFE_componentWillReceiveProps",id:"4-componentwillreceiveprops-和-unsafe_componentwillreceiveprops",depth:4},{text:"5 componentWillUpdate 和 UNSAFE_componentWillUpdate",id:"5-componentwillupdate-和-unsafe_componentwillupdate",depth:4},{text:"6 render",id:"6-render",depth:4},{text:"7 getSnapshotBeforeUpdate",id:"7-getsnapshotbeforeupdate",depth:4},{text:"8 componentDidUpdate",id:"8-componentdidupdate",depth:4},{text:"9 componentDidMount",id:"9-componentdidmount",depth:4},{text:"10 shouldComponentUpdate",id:"10-shouldcomponentupdate",depth:4},{text:"11 componentWillUnmount",id:"11-componentwillunmount",depth:4},{text:"3 函数组件生命周期替代方案",id:"3-函数组件生命周期替代方案",depth:2},{text:"1 useEffect 和 useLayoutEffect",id:"1-useeffect-和-uselayouteffect",depth:3},{text:"2 useInsertionEffect",id:"2-useinsertioneffect",depth:3},{text:"3 componentDidMount 替代方案",id:"3-componentdidmount-替代方案",depth:3},{text:"4 componentWillUnmount 替代方案",id:"4-componentwillunmount-替代方案",depth:3},{text:"5 componentWillReceiveProps 代替方案",id:"5-componentwillreceiveprops-代替方案",depth:3},{text:"6 componentDidUpdate 替代方案",id:"6-componentdidupdate-替代方案",depth:3},{text:"7 完整代码和效果",id:"7-完整代码和效果",depth:3},{text:"四 实践-实现一个ScrollView组件",id:"四-实践-实现一个scrollview组件",depth:2},{text:"四 收获",id:"四-收获",depth:2}],title:"6.基础篇-理解 lifeCycle",headingTitle:"6.基础篇-理解 lifeCycle",frontmatter:{}}}}]);