"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["5237"],{361085:function(n,e,s){s.r(e),s.d(e,{default:()=>l});var t=s(552676),r=s(740453);let c=s.p+"static/image/6243e36c4db24fe07630bc24a12d4523.48ee0e3e.webp",d=s.p+"static/image/3a1592849d1d8212a19d97104ccff779.52ad5d96.webp";function o(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",ol:"ol",li:"li",img:"img",h3:"h3",strong:"strong",h4:"h4",blockquote:"blockquote"},(0,r.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"12编译器模板是如何被编译成-ast-的",children:["12.编译器：模板是如何被编译成 AST 的？",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12编译器模板是如何被编译成-ast-的",children:"#"})]}),"\n",(0,t.jsxs)(e.h2,{id:"前言",children:["前言",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["通过前面的小节，我们知道，组件的渲染成 ",(0,t.jsx)(e.code,{children:"vnode"})," 的过程，其实就是组件的 ",(0,t.jsx)(e.code,{children:"render"})," 函数调用执行的结果。但是我们写 ",(0,t.jsx)(e.code,{children:"Vue"})," 项目时，经常会使用 ",(0,t.jsx)(e.code,{children:"<template>"})," 的模版式写法，很少使用 ",(0,t.jsx)(e.code,{children:"render"})," 函数的写法，那么 ",(0,t.jsx)(e.code,{children:"Vue"})," 是如何实现从 ",(0,t.jsx)(e.code,{children:"模版"})," 转成 ",(0,t.jsx)(e.code,{children:"render"})," 函数的呢？"]}),"\n",(0,t.jsxs)(e.p,{children:["另外，关于模版编译成 ",(0,t.jsx)(e.code,{children:"render"})," 函数的结果，也可以通过官方提供的 ",(0,t.jsx)(e.a,{href:"https://vue-next-template-explorer.netlify.app/#eyJzcmMiOiI8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+Iiwib3B0aW9ucyI6e319",target:"_blank",rel:"noopener noreferrer",children:"模版导出工具"})," 现在调试编译结果。"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Vue3"})," 的核心编译源码文件在 ",(0,t.jsx)(e.code,{children:"packages/compiler-dom/src/index.ts"})," 中："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"function compile(template, options = {}) { \n  return baseCompile(template, extend({}, parserOptions, options, { \n    nodeTransforms: [...DOMNodeTransforms, ...(options.nodeTransforms || [])], \n    directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}), \n    transformHoist:  null \n  })) \n} \n"})}),"\n",(0,t.jsxs)(e.p,{children:["其核心调用的就是 ",(0,t.jsx)(e.code,{children:"baseCompile"})," 函数，接下来一起看一下 ",(0,t.jsx)(e.code,{children:"baseCompile"})," 的实现："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"export function baseCompile(template, options = {}) {\n  // 如果是字符串模版，则直接进行解析，转成 AST\n  const ast = isString(template) ? baseParse(template, options) : template\n  const [nodeTransforms, directiveTransforms] =\n    getBaseTransformPreset(prefixIdentifiers)\n  \n  // AST 转换成 JS AST\n  transform(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers,\n      nodeTransforms: [\n        ...nodeTransforms,\n        ...(options.nodeTransforms || []) // user transforms\n      ],\n      directiveTransforms: extend(\n        {},\n        directiveTransforms,\n        options.directiveTransforms || {} // user transforms\n      )\n    })\n  )\n  \n  // JS AST 生成代码\n  return generate(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers\n    })\n  )\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["可以看到 ",(0,t.jsx)(e.code,{children:"baseCompile"})," 函数核心就只有 3 步："]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["对 ",(0,t.jsx)(e.code,{children:"template"})," 模版进行词法和语法分析，生成 ",(0,t.jsx)(e.code,{children:"AST"})]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"AST"})," 转换成附有 ",(0,t.jsx)(e.code,{children:"JS"})," 语义的 ",(0,t.jsx)(e.code,{children:"JavaScript AST"})]}),"\n",(0,t.jsxs)(e.li,{children:["解析 ",(0,t.jsx)(e.code,{children:"JavaScript AST"})," 生成代码"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"本小节着重来介绍下第一步"}),"\n",(0,t.jsxs)(e.h2,{id:"解析-template-生成-ast",children:["解析 ",(0,t.jsx)(e.code,{children:"template"})," 生成 ",(0,t.jsx)(e.code,{children:"AST"}),(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解析-template-生成-ast",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"一个简单的模版如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"<template>\n  \x3c!-- 这是一段注释 --\x3e\n  <p>{{ msg }}</p>\n</template>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["这个模版经过 ",(0,t.jsx)(e.code,{children:"baseParse"})," 后转成的 ",(0,t.jsx)(e.code,{children:"AST"})," 结果如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-json",children:'{\n  "type": 0,\n  "children": [\n    {\n      "type": 3,\n      "content": " 这是一段注释 ",\n      "loc": {\n        "start": {\n          "column": 3,\n          "line": 2,\n          "offset": 3\n        },\n        "end": {\n          "column": 18,\n          "line": 2,\n          "offset": 18\n        },\n        "source": "\x3c!-- 这是一段注释 --\x3e"\n      }\n    },\n    {\n      "type": 1,\n      "ns": 0,\n      "tag": "p",\n      "tagType": 0,\n      "props": [],\n      "isSelfClosing": false,\n      "children": [\n        {\n          "type": 5,\n          "content": {\n            "type": 4,\n            "isStatic": false,\n            "constType": 0,\n            "content": "msg",\n            "loc": {\n              "start": {\n                "column": 9,\n                "line": 3,\n                "offset": 27\n              },\n              "end": {\n                "column": 12,\n                "line": 3,\n                "offset": 30\n              },\n              "source": "msg"\n            }\n          },\n          "loc": {\n            "start": {\n              "column": 6,\n              "line": 3,\n              "offset": 24\n            },\n            "end": {\n              "column": 15,\n              "line": 3,\n              "offset": 33\n            },\n            "source": "{{ msg }}"\n          }\n        }\n      ],\n      "loc": {\n        "start": {\n          "column": 3,\n          "line": 3,\n          "offset": 21\n        },\n        "end": {\n          "column": 19,\n          "line": 3,\n          "offset": 37\n        },\n        "source": "<p>{{ msg }}</p>"\n      }\n    }\n  ],\n  "helpers": [],\n  "components": [],\n  "directives": [],\n  "hoists": [],\n  "imports": [],\n  "cached": 0,\n  "temps": 0,\n  "loc": {\n    "start": {\n      "column": 1,\n      "line": 1,\n      "offset": 0\n    },\n    "end": {\n      "column": 1,\n      "line": 4,\n      "offset": 38\n    },\n    "source": "\\n  \x3c!-- 这是一段注释 --\x3e\\n  <p>{{ msg }}</p>\\n"\n  }\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["其中有一个 ",(0,t.jsx)(e.code,{children:"type"})," 字段，用来标记 ",(0,t.jsx)(e.code,{children:"AST"})," 节点的类型，这里涉及到的枚举如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"export const enum NodeTypes {\n  ROOT, // 0 根节点\n  ELEMENT, // 1 元素节点\n  TEXT, // 2 文本节点\n  COMMENT, // 3 注释节点\n  SIMPLE_EXPRESSION, // 4 表达式\n  INTERPOLATION, // 5 插值节点\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["另外，",(0,t.jsx)(e.code,{children:"props"})," 描述的是节点的属性，",(0,t.jsx)(e.code,{children:"loc"})," 代表的是节点对应的代码相关信息，包括代码的起始位置等等。"]}),"\n",(0,t.jsxs)(e.p,{children:["有了上面的一些基础知识，我们来看看生成 ",(0,t.jsx)(e.code,{children:"AST"})," 的核心算法："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"export function baseParse(content, options) {\n  // 创建解析上下文\n  const context = createParserContext(content, options)\n  // 获取起点位置\n  const start = getCursor(context)\n  // 创建 AST\n  return createRoot(\n    parseChildren(context, TextModes.DATA, []),\n    getSelection(context, start)\n  )\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["其中创建解析上下文得到的 ",(0,t.jsx)(e.code,{children:"context"})," 的过程："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"function createParserContext(content, options) { \n  return { \n    options: extend({}, defaultParserOptions, options), \n    column: 1, \n    line: 1, \n    offset: 0, \n    // 存储原始模版内容\n    originalSource: content, \n    source: content, \n    inPre: false, \n    inVPre: false \n  } \n} \n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"createParserContext"})," 本质就是返回了一个 ",(0,t.jsx)(e.code,{children:"context"})," 对象，用来标记解析过程中的上下文内容。"]}),"\n",(0,t.jsxs)(e.p,{children:["接下来我们核心需要分析的是 ",(0,t.jsx)(e.code,{children:"parseChildren"})," 函数，该函数是生成 ",(0,t.jsx)(e.code,{children:"AST"})," 的核心函数。通过函数调用我们大致清楚该函数传入了初始化生成的 ",(0,t.jsx)(e.code,{children:"context"})," 对象，",(0,t.jsx)(e.code,{children:"context"})," 对象中包含我们初始的模版内容，存储在 ",(0,t.jsx)(e.code,{children:"originalSource"})," 和 ",(0,t.jsx)(e.code,{children:"source"})," 中。"]}),"\n",(0,t.jsxs)(e.p,{children:["先来看看 ",(0,t.jsx)(e.code,{children:"parseChildren"})," 对节点内容解析的过程："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"function parseChildren(context, mode, ancestors) {\n  // 获取父节点\n  const parent = last(ancestors)\n  const ns = parent ? parent.ns : Namespaces.HTML\n  const nodes: TemplateChildNode[] = []\n  // 判断是否到达结束位置，遍历结束\n  while (!isEnd(context, mode, ancestors)) {\n    // template 中的字符串\n    const s = context.source\n    let node = undefined\n    // 如果 mode 是 DATA 和 RCDATA 模式\n    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\n      // 处理 {{ 开头的情况\n      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\n        // '{{'\n        node = parseInterpolation(context, mode)\n      } else if (mode === TextModes.DATA && s[0] === '<') {\n        // 以 < 开头且就一个 < 字符\n        if (s.length === 1) {  \n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\n        } else if (s[1] === '!') {\n          // 以 <! 开头的情况\n          if (startsWith(s, '\x3c!--')) {\n            // 如果是 \x3c!-- 这种情况，则按照注释节点处理\n            node = parseComment(context)\n          } else if (startsWith(s, '<!DOCTYPE')) {\n            // 如果是 <!DOCTYPE 这种情况\n            node = parseBogusComment(context)\n          } else if (startsWith(s, '<![CDATA[')) {\n            // 如果是 <![CDATA[ 这种情况\n            if (ns !== Namespaces.HTML) {\n              node = parseCDATA(context, ancestors)\n            } else {\n              emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)\n              node = parseBogusComment(context)\n            }\n          } else {\n            // 都不是的话，则报错\n            emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)\n            node = parseBogusComment(context)\n          }\n        } else if (s[1] === '/') {\n          // 以 </ 开头，并且只有 </ 的情况\n          if (s.length === 2) {\n            emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)\n          } else if (s[2] === '>') {\n            // </> 缺少结束标签，报错\n            emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)\n            advanceBy(context, 3)\n            continue\n          } else if (/[a-z]/i.test(s[2])) {\n            // 文本中存在多余的结束标签的情况 </p>\n            emitError(context, ErrorCodes.X_INVALID_END_TAG)\n            parseTag(context, TagType.End, parent)\n            continue\n          } else {\n            emitError(\n              context,\n              ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,\n              2\n            )\n            node = parseBogusComment(context)\n          }\n        } else if (/[a-z]/i.test(s[1])) {\n          // 解析标签元素节点\n          node = parseElement(context, ancestors)\n        } else if (s[1] === '?') {\n          emitError(\n            context,\n            ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n            1\n          )\n          node = parseBogusComment(context)\n        } else {\n          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)\n        }\n      }\n    }\n    if (!node) {\n      // 解析普通文本节点\n      node = parseText(context, mode)\n    }\n\n    if (isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        pushNode(nodes, node[i])\n      }\n    } else {\n      pushNode(nodes, node)\n    }\n  }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["上述代码量虽然挺多，但整体要做的事情还是比较明确和清晰的。从上述代码中可以看到，",(0,t.jsx)(e.code,{children:"Vue"})," 在解析模板字符串时，可分为两种情况：以 ",(0,t.jsx)(e.code,{children:"<"})," 开头的字符串和不以 ",(0,t.jsx)(e.code,{children:"<"})," 开头的字符串。"]}),"\n",(0,t.jsxs)(e.p,{children:["其中，不以 ",(0,t.jsx)(e.code,{children:"<"})," 开头的字符串有两种情况：它是文本节点或 ",(0,t.jsx)(e.code,{children:"{{ exp }}"})," 插值表达式。"]}),"\n",(0,t.jsxs)(e.p,{children:["而以 ",(0,t.jsx)(e.code,{children:"<"})," 开头的字符串又分为以下几种情况："]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["元素开始标签，比如 ",(0,t.jsx)(e.code,{children:"<div>"})]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["注释节点 ",(0,t.jsx)(e.code,{children:"\x3c!-- 123 --\x3e"})]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["文档声明 ",(0,t.jsx)(e.code,{children:"<!DOCTYPE html>"})]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["纯文本标签 ",(0,t.jsx)(e.code,{children:"<![CDATA[<]]>"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:"接下来我们介绍几个比较重要的解析器。"}),"\n",(0,t.jsxs)(e.h3,{id:"1-解析插值",children:["1. 解析插值",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-解析插值",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["根据前面的描述，我们知道当遇到字符串 ",(0,t.jsx)(e.code,{children:"{{msg}}"})," 的时候，会把当前代码当做是插值节点来解析，进入 ",(0,t.jsx)(e.code,{children:"parseInterpolation"})," 函数体内："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"function parseInterpolation(context, mode) {\n  // 从配置中获取插值开始和结束分隔符，默认是 {{ 和 }}\n  const [open, close] = context.options.delimiters\n  // 获取结束分隔符的位置\n  const closeIndex = context.source.indexOf(close, open.length)\n  // 如果不存在结束分隔符，则报错\n  if (closeIndex === -1) {\n    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)\n    return undefined\n  }\n\n  // 获取开始解析的起点\n  const start = getCursor(context)\n  // 解析位置移动到插值开始分隔符后\n  advanceBy(context, open.length)\n  // 获取插值起点位置\n  const innerStart = getCursor(context)\n  // 获取插值结束位置\n  const innerEnd = getCursor(context)\n  // 插值原始内容的长度\n  const rawContentLength = closeIndex - open.length\n  // 插值原始内容\n  const rawContent = context.source.slice(0, rawContentLength)\n  // 获取插值的内容，并移动位置到插值的内容后\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\n  const content = preTrimContent.trim()\n  // 如果存在空格的情况，需要计算偏移值\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    // 更新插值起点位置\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  // 如果尾部存在空格的情况\n  const endOffset =\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\n  // 也需要更新尾部的位置\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  // 移动位置到插值结束分隔符后\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      // Set `isConstant` to false by default and will decide in transformExpression\n      constType: ConstantTypes.NOT_CONSTANT,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["这里大量使用了一个重要函数 ",(0,t.jsx)(e.code,{children:"advanceBy(context, numberOfCharacters)"}),"。其功能是更新解析上下文 ",(0,t.jsx)(e.code,{children:"context"})," 中的 ",(0,t.jsx)(e.code,{children:"source"})," 来移动代码解析的位置，同时更新 ",(0,t.jsx)(e.code,{children:"offset、line、column"})," 等和代码位置相关的属性，这样来达到一步步 ",(0,t.jsx)(e.strong,{children:"蚕食"})," 模版字符串的目的，从而达到对整个模版字符chuan",(0,t.jsx)(e.code,{children:"context"})," 是字符串的上下文对象，",(0,t.jsx)(e.code,{children:"numberOfCharacters"})," 是要前进的字符数。"]}),"\n",(0,t.jsx)(e.p,{children:"针对这样一段代码："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"<div>{{ msg }}<div>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["调用\xa0",(0,t.jsx)(e.code,{children:"advance(s, 14)"}),"\xa0函数，得到结果："]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,t.jsxs)(e.p,{children:["可以看到，",(0,t.jsx)(e.code,{children:"parseInterpolation"})," 函数本质就是通过插值的开始标签",(0,t.jsx)(e.code,{children:"{{"})," 和结束标签 ",(0,t.jsx)(e.code,{children:"}}"})," 找到插值的内容 ",(0,t.jsx)(e.code,{children:"content"}),"。然后再计算插值的起始位置，接着就是前进代码到插值结束分隔符后，表示插值部分代码处理完毕，可以继续解析后续代码了。"]}),"\n",(0,t.jsxs)(e.p,{children:["最后返回一个描述插值节点的 ",(0,t.jsx)(e.code,{children:"AST"})," 对象，其中，",(0,t.jsx)(e.code,{children:"loc"})," 记录了插值的代码开头和结束的位置信息，",(0,t.jsx)(e.code,{children:"type"})," 表示当前节点的类型，",(0,t.jsx)(e.code,{children:"content"})," 表示当前节点的内容信息。"]}),"\n",(0,t.jsxs)(e.h3,{id:"2-解析文本",children:["2. 解析文本",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-解析文本",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["针对源代码起点位置的字符不是 ",(0,t.jsx)(e.code,{children:"<"})," 或者 ",(0,t.jsx)(e.code,{children:"{{"})," 时，则当做是文本节点处理，调用 ",(0,t.jsx)(e.code,{children:"parseText"})," 函数："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"function parseText(context, mode) {\n  // 文本结束符\n  const endTokens = mode === TextModes.CDATA ? [']]>'] : ['<', context.options.delimiters[0]]\n\n  let endIndex = context.source.length\n  // 遍历文本结束符，匹配找到结束的位置\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1)\n    if (index !== -1 && endIndex > index) {\n      endIndex = index\n    }\n  }\n  \n  const start = getCursor(context)\n  // 获取文本的内容，并前进代码到文本的内容后\n  const content = parseTextData(context, endIndex, mode)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"parseText"})," 函数整体功能还是比较简单的，如果一段文本，在 ",(0,t.jsx)(e.code,{children:"CDATA"})," 模式下，当遇到 ",(0,t.jsx)(e.code,{children:"]]>"})," 即为结束位置，否则，都是在遇到 ",(0,t.jsx)(e.code,{children:"<"})," 或者插值分隔符 ",(0,t.jsx)(e.code,{children:"{{"})," 结束。所以通过遍历这些结束符，匹配并找到文本结束的位置。"]}),"\n",(0,t.jsxs)(e.p,{children:["找到文本结束位置后，就可以通过 ",(0,t.jsx)(e.code,{children:"parseTextData"})," 函数来获取到文本的内容并前进到文本内容后。"]}),"\n",(0,t.jsxs)(e.p,{children:["最后返回一个文本节点的 ",(0,t.jsx)(e.code,{children:"AST"})," 对象。"]}),"\n",(0,t.jsxs)(e.h3,{id:"3-解析节点",children:["3. 解析节点",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-解析节点",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["当起点字符是 ",(0,t.jsx)(e.code,{children:"<"})," 开头，且后续字符串匹配 ",(0,t.jsx)(e.code,{children:"/[a-z]/i"})," 正则表达式，则会进入 ",(0,t.jsx)(e.code,{children:"parseElement"})," 的节点解析函数："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"function parseElement(context, ancestors) {\n  // ...\n  // 开始标签\n  // 获取当前元素的父标签节点\n  const parent = last(ancestors)\n  // 解析开始标签，生成一个标签节点，并前进代码到开始标签后\n  const element = parseTag(context, TagType.Start, parent)\n  // 如果是自闭和标签，直接返回标签节点\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    return element\n  }\n  \n  // 下面是处理子节点的逻辑\n  // 先把标签节点添加到 ancestors，入栈\n  ancestors.push(element)\n  const mode = context.options.getTextMode(element, parent)\n  // 递归解析子节点，传入 ancestors\n  const children = parseChildren(context, mode, ancestors)\n  // 子节点解析完成 ancestors 出栈\n  ancestors.pop()\n\n  // ...\n  element.children = children\n  \n  // 结束标签\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    // 解析结束标签，并前进代码到结束标签后\n    parseTag(context, TagType.End, parent)\n  } else {\n    // ...\n  }\n  // 更新标签节点的代码位置，结束位置到结束标签后\n  element.loc = getSelection(context, element.loc.start)\n  \n  return element\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["可以看到，",(0,t.jsx)(e.code,{children:"parseElement"})," 主要做了三件事情：解析开始标签，解析子节点，解析闭合标签。"]}),"\n",(0,t.jsxs)(e.p,{children:["在解析子节点过程中， ",(0,t.jsx)(e.code,{children:"Vue"})," 会用一个栈 ",(0,t.jsx)(e.code,{children:"ancestors"})," 来保存解析到的元素标签。当它遇到开始标签时，会将这个标签推入栈，遇到结束标签时，将刚才的标签弹出栈。它的作用是保存当前已经解析了，但还没解析完的元素标签。这个栈还有另一个作用，在解析到某个字节点时，通过 ",(0,t.jsx)(e.code,{children:"ancestors[ancestors.length - 1]"})," 可以获取它的父元素。"]}),"\n",(0,t.jsx)(e.p,{children:"举个例子："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:'<div class="app">\n  <p>{{ msg }}</p> \n  一个文本节点 \n</div>\n'})}),"\n",(0,t.jsx)(e.p,{children:"从我们的示例来看，它的出入栈顺序是这样的："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"[] // 刚开始时空栈\n[div] // div 入栈\n[div, p] // p 入栈\n[div] // p 节点解析完成，出栈\n[] // div 节点解析完成，出栈\n"})}),"\n",(0,t.jsxs)(e.p,{children:["另外，在解析开始标签和解析闭合标签时，都用到了一个 ",(0,t.jsx)(e.code,{children:"parseTag"})," 函数，这也是节点标签解析的核心函数："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"function parseTag(context, type, parent) {\n  const start = getCursor(context)\n  // 匹配标签文本结束的位置\n  const match = /^</?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)!\n  const tag = match[1]\n  const ns = context.options.getNamespace(tag, parent)\n  // 前进代码到标签文本结束位置\n  advanceBy(context, match[0].length)\n  // 前进代码到标签文本后面的空白字符后\n  advanceSpaces(context)\n  \n  // 解析标签中的属性，并前进代码到属性后\n  let props = parseAttributes(context, type)\n  // ...\n  // 标签闭合.\n  let isSelfClosing = false\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_TAG)\n  } else {\n    // 判断是否自闭合标签\n    isSelfClosing = startsWith(context.source, '/>')\n    // 结束标签不应该是自闭和标签\n    if (type === TagType.End && isSelfClosing) {\n      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)\n    }\n    // 前进代码到闭合标签后\n    advanceBy(context, isSelfClosing ? 2 : 1)\n  }\n  \n  // 闭合标签，则退出\n  if (type === TagType.End) {\n    return\n  }\n  \n  let tagType = ElementTypes.ELEMENT\n  if (!context.inVPre) {\n    // 接下来判断标签类型，是组件、插槽还是模板\n    if (tag === 'slot') {\n      tagType = ElementTypes.SLOT\n    } else if (tag === 'template') {\n      if (\n        props.some(\n          p =>\n            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)\n        )\n      ) {\n        tagType = ElementTypes.TEMPLATE\n      }\n    } else if (isComponent(tag, props, context)) {\n      tagType = ElementTypes.COMPONENT\n    }\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  }\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"parseTag"})," 函数首先会匹配标签的文本的节点信息，比如\n",(0,t.jsx)(e.code,{children:'<div class="test">{{ msg }}</div>'}),"得到的 ",(0,t.jsx)(e.code,{children:"match"})," 信息如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"[\n  '<div',\n  'div', \n  index: 0,\n  input: '<div class=\"test\">{{ msg }}</div>\\n',\n  groups: undefined\n]\n"})}),"\n",(0,t.jsxs)(e.p,{children:["然后将代码前进到节点信息后，再通过 ",(0,t.jsx)(e.code,{children:"parseAttributes"})," 函数来解析标签中的 ",(0,t.jsx)(e.code,{children:"props"})," 属性，比如 ",(0,t.jsx)(e.code,{children:"class"}),"、",(0,t.jsx)(e.code,{children:"style"})," 等等。"]}),"\n",(0,t.jsx)(e.p,{children:"接下来再去判断是不是一个自闭和标签，并前进代码到闭合标签后；"}),"\n",(0,t.jsxs)(e.p,{children:["最后根据 ",(0,t.jsx)(e.code,{children:"tag"})," 判断标签类型，是组件、插槽还是模板。"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"parseTag"})," 完成后，最终就是返回一个节点描述的 ",(0,t.jsx)(e.code,{children:"AST"})," 对象，如果有子节点，会继续进入 ",(0,t.jsx)(e.code,{children:"parseChildren"})," 的递归流程，不断更新节点的 ",(0,t.jsx)(e.code,{children:"children"})," 对象。"]}),"\n",(0,t.jsxs)(e.h2,{id:"总结",children:["总结",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["有了上面的介绍，我们来看一个简单的 ",(0,t.jsx)(e.code,{children:"demo"})," 来理解 ",(0,t.jsx)(e.code,{children:"AST"})," 创建的过程。针对以下模版："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:'<div class="test">\n  {{ msg }}\n  <p>这是一段文本</p>\n</div>\n'})}),"\n",(0,t.jsx)(e.p,{children:"我们来演示一下创建过程："}),"\n",(0,t.jsxs)(e.h4,{id:"div-标签解析",children:["div 标签解析",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#div-标签解析",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["首先进入 ",(0,t.jsx)(e.code,{children:"parseChildren"})," 遇到 ",(0,t.jsx)(e.code,{children:"<div"})," 标签，进入 ",(0,t.jsx)(e.code,{children:"parseElement"})," 函数，",(0,t.jsx)(e.code,{children:"parseElement"})," 函数通过 ",(0,t.jsx)(e.code,{children:"parseTag"})," 函数得到 ",(0,t.jsx)(e.code,{children:"element"})," 的数据结构为："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-json",children:'{\n  "type": 1, // 标签节点\n  "ns": 0,\n  "tag": "div",\n  "tagType": 0,\n  "props": [\n    {\n      "type": 6,\n      "name": "class",\n      "value": {\n       // ...\n      },\n      "loc": {\n        // ...\n      }\n    }\n  ],\n  "isSelfClosing": false,\n  "children": [],\n  "loc": {\n    "start": {\n      "column": 3,\n      "line": 2,\n      "offset": 3\n    },\n    "end": {\n      "column": 21,\n      "line": 2,\n      "offset": 21\n    },\n    "source": "<div class="test">"\n  }\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["此时的 ",(0,t.jsx)(e.code,{children:"context"})," 经过 ",(0,t.jsx)(e.code,{children:"advanceBy"})," 操作后，内容为："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-json",children:'{\n  "options": {\n    // ...\n  },\n  "column": 18,\n  "line": 1,\n  "offset": 18,\n  "originalSource": "<div class="test">\\n    {{ msg }}\\n    <p>这是一段文本</p>\\n  </div>\\n",\n  "source": "\\n    {{ msg }}\\n    <p>这是一段文本</p>\\n  </div>\\n",\n  "inPre": false,\n  "inVPre": false\n}\n'})}),"\n",(0,t.jsxs)(e.h4,{id:"插值标签解析",children:["插值标签解析",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#插值标签解析",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["然后再进入 ",(0,t.jsx)(e.code,{children:"parseChildren"})," 流程，此时的 ",(0,t.jsx)(e.code,{children:"source"})," 内容如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"  {{ msg }}\n  <p>这是一段文本</p>\n</div>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["此时的开始标签是 ",(0,t.jsx)(e.code,{children:"{{"})," 所以进入插值解析的函数 ",(0,t.jsx)(e.code,{children:"parseInterpolation"}),"，该函数执行完成后得到的 ",(0,t.jsx)(e.code,{children:"source"})," 结果如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"  <p>这是一段文本</p>\n</div>\n"})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["这里关于 ",(0,t.jsx)(e.code,{children:"AST"})," 内容就会包含插值节点的信息描述。 ",(0,t.jsx)(e.code,{children:"context"})," 内容则会在 ",(0,t.jsx)(e.code,{children:"parseInterpolation"})," 后继续更新，执行后续 ",(0,t.jsx)(e.code,{children:"source"})," 的内容坐标，这里不再赘述"]}),"\n"]}),"\n",(0,t.jsxs)(e.h4,{id:"p-标签解析",children:["p 标签解析",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#p-标签解析",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["在完成，插值节点解析后，在 ",(0,t.jsx)(e.code,{children:"parseChildren"})," 内存在一个 ",(0,t.jsx)(e.code,{children:"while"})," 判断：",(0,t.jsx)(e.code,{children:"while (!isEnd(context, mode, ancestors))"}),"，因为还未到达闭合标签的位置，所以接着进入 ",(0,t.jsx)(e.code,{children:"p"})," 标签的解析 ",(0,t.jsx)(e.code,{children:"parseElement"}),"。解析完成后得到",(0,t.jsx)(e.code,{children:"source"})," 内容如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"  这是一段文本</p>\n</div>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["此时继续进入 ",(0,t.jsx)(e.code,{children:"parseChildren"})," 递归。"]}),"\n",(0,t.jsxs)(e.h4,{id:"解析文本节点",children:["解析文本节点",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解析文本节点",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["然后遇到的了文本开头的内容，会进入 ",(0,t.jsx)(e.code,{children:"parseText"})," 文本解析的流程，完成 ",(0,t.jsx)(e.code,{children:"parseText"})," 后，得到的 ",(0,t.jsx)(e.code,{children:"source"})," 内容如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"</p>\n</div>\n"})}),"\n",(0,t.jsxs)(e.h4,{id:"解析闭合标签",children:["解析闭合标签",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解析闭合标签",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["此时 ",(0,t.jsx)(e.code,{children:"while"})," 退出循环，进入 ",(0,t.jsx)(e.code,{children:"parseTag"})," 继续解析闭合标签，首先是 ",(0,t.jsx)(e.code,{children:"</p>"})," 标签，因为不是自闭和标签，则继续更新 ",(0,t.jsx)(e.code,{children:"content"})," 后，然后更新标签节点的代码位置，最后得到的 ",(0,t.jsx)(e.code,{children:"source"})," 如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"</div>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["最后再继续解析闭合标签 ",(0,t.jsx)(e.code,{children:"</div>"})," 更新 ",(0,t.jsx)(e.code,{children:"content"}),"和标签节点",(0,t.jsx)(e.code,{children:"div"}),"的代码位置，直到结束。"]})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(o,{...n})}):o(n)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F12.%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E7%BC%96%E8%AF%91%E6%88%90%20AST%20%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"解析 `template` 生成 `AST`",id:"解析-template-生成-ast",depth:2},{text:"1. 解析插值",id:"1-解析插值",depth:3},{text:"2. 解析文本",id:"2-解析文本",depth:3},{text:"3. 解析节点",id:"3-解析节点",depth:3},{text:"总结",id:"总结",depth:2},{text:"div 标签解析",id:"div-标签解析",depth:4},{text:"插值标签解析",id:"插值标签解析",depth:4},{text:"p 标签解析",id:"p-标签解析",depth:4},{text:"解析文本节点",id:"解析文本节点",depth:4},{text:"解析闭合标签",id:"解析闭合标签",depth:4}],title:"12.编译器：模板是如何被编译成 AST 的？",headingTitle:"12.编译器：模板是如何被编译成 AST 的？",frontmatter:{}}}}]);