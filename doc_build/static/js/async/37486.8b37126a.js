"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["37486"],{115858:function(e,n,a){a.r(n),a.d(n,{default:()=>C});var c=a(552676),s=a(740453);let r=a.p+"static/image/4edf3131bb0c568145e36da6907b7ae2.1e7d644a.webp",t=a.p+"static/image/6931e74c9905f419863563c1cd4cc78f.b1fb8cb0.webp",i=a.p+"static/image/90b5198bdb6dbd6e3a5e1dbf5e7cb89c.a9bd9490.webp",l=a.p+"static/image/5360afb85671458c3ad493a270fb253c.08d95e61.webp",d=a.p+"static/image/668a53b8adbd74988e484964da85169b.c7e5a197.webp",p=a.p+"static/image/de267088268f5be02f9a927250b4efca.77c29330.webp",o=a.p+"static/image/bc2211ed33427e4e3dfe2bbdde754ceb.5850812f.webp",m=a.p+"static/image/c6695f3af070ed68ef7bca506dc730fd.e77c0a83.webp",x=a.p+"static/image/d9dbb21762c71eecd4f57a9aa44e59ee.79fa1b1d.webp",h=a.p+"static/image/b6fb91164084956e47f1f325f5dbb868.32ca7ad3.webp",j=a.p+"static/image/7c737737d6843a0944e95f2742590615.90e473dd.webp",u=a.p+"static/image/17f014eb7a09c35d1a6104d458f4f015.8a998168.webp",f=a.p+"static/image/e5f07af462837f3c0bf4c52863e48fa1.e8578835.gif",b=a.p+"static/image/467d7e916001c0f45bfff5f7773c3b93.25ce0e2e.webp",g=a.p+"static/image/16563578b5b4a0131ce99ca68abc3dda.32c37c7a.gif",A=a.p+"static/image/2faf5b90ee3a58d2a6209e9e5ca6ab55.763a07bc.webp",E=a.p+"static/image/9ad37cc6fa7ec88ce5412bdbc2c351ba.ef071a95.webp",_=a.p+"static/image/0a6b87e67724c96c49e6856363b960f7.22728dcc.webp",k=a.p+"static/image/6dba0dfed16beedbaca75e83dc6c68f4.dc254417.gif",v=a.p+"static/image/8cdac58cf5ccad35967a4844e532de3a.8786119d.gif",w=a.p+"static/image/a4ae69493351e8cf4acf089c341b191a.0940a9bd.gif";function S(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",pre:"pre",code:"code"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"137-会议室预定系统前端代码优化",children:["137. 会议室预定系统：前端代码优化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#137-会议室预定系统前端代码优化",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"前端代码写的比较仓促，很多代码是可以优化的。"}),"\n",(0,c.jsx)(n.p,{children:"这节我们统一来优化一下："}),"\n",(0,c.jsxs)(n.h2,{id:"路由守卫",children:["路由守卫",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由守卫",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"登录之后，我们会在 localStorage 保存 access_token、refresh_token、user_info 的信息："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:w,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"然后进入会议室列表页。"}),"\n",(0,c.jsx)(n.p,{children:"这些页面是登录后才能访问的。"}),"\n",(0,c.jsx)(n.p,{children:"但是现在没登录访问会议室列表页不会自动跳转登录页："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:v,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"只有点击其他页面的时候，才会跳转登录页："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:k,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"因为这些页面的接口需要需要登录，没登录访问会返回 401，我们在响应的拦截器里做了处理，如果返回 401 就跳转登录页："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:_,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"但是只在接口返回 401 的时候做处理不够，我们应该在路由级别也做下判断，也就是路由守卫。"}),"\n",(0,c.jsx)(n.p,{children:"分析下 frontend_user 的现有路由，需要登录的这几个页面都会渲染 Index 组件："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:E,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"所以我们在 Index 组件里做下判断就好了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:A,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"之前有从 localStorage 里取 user_info 设置 headPic 的逻辑，我们加个 else，跳转登录页就好了。"}),"\n",(0,c.jsx)(n.p,{children:"测试下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"现在没有 user_info 的时候，也就是没有登录的时候就会跳转登录页了。"}),"\n",(0,c.jsx)(n.p,{children:"同理，frontend_admin 项目也是这样改："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"useEffect(()=> {\n    const userInfo = localStorage.getItem('user_info');\n    if(!userInfo) {\n        window.location.href = \"/login\";\n    }\n}, []);\n"})}),"\n",(0,c.jsx)(n.p,{children:"测试下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"没登录的时候，也同样跳转了登录页。"}),"\n",(0,c.jsxs)(n.h2,{id:"usecallbackusememo",children:["useCallback、useMemo",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecallbackusememo",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"前面我们代码里加了很多 useMemo 和 useCallback，其实这是没必要的。"}),"\n",(0,c.jsx)(n.p,{children:"我们创建个测试项目："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npx create-vite test-memo\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"进入项目，安装依赖，然后把开发服务跑起来："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install\n\nnpm run dev\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"去掉 main.tsx 里的 index.css 和 StrictMode："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"然后改下 App.tsx"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react'\n\nfunction Aaa(props: { text: string }) {\n  console.log('Aaa render...');\n\n  return <div>{props.text}</div>\n}\n\nfunction App() {\n  const [num, setNum] = useState(0);\n\n  useEffect(() => {\n    setInterval(() => {\n      setNum(num => num + 1);\n    }, 1000);\n  }, []);\n\n  return <Aaa text=\"aaa\"></Aaa>\n}\n\nexport default App\n"})}),"\n",(0,c.jsx)(n.p,{children:"App 组件里有一个定时器，不断的修改 setState 来触发重新渲染。"}),"\n",(0,c.jsx)(n.p,{children:"这时候 Aaa 会不会重新渲染呢？"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"答案是每次都会重新渲染。"}),"\n",(0,c.jsx)(n.p,{children:"很明显这里 Aaa 不需要重新渲染，因为参数没变。"}),"\n",(0,c.jsx)(n.p,{children:"这时候就可以用 memo 来做："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { memo, useEffect, useState } from 'react'\n\nfunction Aaa(props: { text: string }) {\n  console.log('Aaa render...');\n\n  return <div>{props.text}</div>\n}\n\nconst MemoAaa = memo(Aaa);\n\nfunction App() {\n  const [num, setNum] = useState(0);\n\n  useEffect(() => {\n    setInterval(() => {\n      setNum(num => num + 1);\n    }, 1000);\n  }, []);\n\n  return <MemoAaa text=\"aaa\"></MemoAaa>\n}\n\nexport default App\n"})}),"\n",(0,c.jsx)(n.p,{children:"现在 Aaa 就只会渲染一次了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"memo 里会对比 props 和上次有没有变化，没变就不会重新渲染。"}),"\n",(0,c.jsx)(n.p,{children:"那如果我加一个函数作为参数呢？"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { memo, useEffect, useState } from 'react'\n\nfunction Aaa(props: { text: string, callback: Function }) {\n  console.log('Aaa render...');\n\n  return <div>{props.text}</div>\n}\n\nconst MemoAaa = memo(Aaa);\n\nfunction App() {\n  const [num, setNum] = useState(0);\n\n  useEffect(() => {\n    setInterval(() => {\n      setNum(num => num + 1);\n    }, 1000);\n  }, []);\n\n  return <MemoAaa text=\"aaa\" callback={() => { console.log('xxx');}}></MemoAaa>\n}\n\nexport default App\n"})}),"\n",(0,c.jsx)(n.p,{children:"这时候每次都会重新渲染："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"因为函数每次都变，也就是参数每次都变，加了 memo 也没用。"}),"\n",(0,c.jsx)(n.p,{children:"这时候用 useCallback 就可以解决这个问题，它只有依赖数组变的时候才会返回新的函数，否则一直返回同一个函数："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { memo, useCallback, useEffect, useState } from 'react'\n\nfunction Aaa(props: { text: string, callback: Function }) {\n  console.log('Aaa render...');\n\n  return <div>{props.text}</div>\n}\n\nconst MemoAaa = memo(Aaa);\n\nfunction App() {\n  const [num, setNum] = useState(0);\n\n  useEffect(() => {\n    setInterval(() => {\n      setNum(num => num + 1);\n    }, 1000);\n  }, []);\n\n  const callback = useCallback(() => {\n    console.log('xxx');\n  }, []);\n\n  return <MemoAaa text=\"aaa\" callback={callback}></MemoAaa>\n}\n\nexport default App\n"})}),"\n",(0,c.jsx)(n.p,{children:"现在又只渲染一次了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"所以说，memo 和 useCallback、useMemo 是配合使用的，我们之前单独用 useCallback 没什么意义。"}),"\n",(0,c.jsx)(n.p,{children:"代码里的 useCallback 可以去掉。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"案例代码上传了小册仓库："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_user",target:"_blank",rel:"noopener noreferrer",children:"frontend_user"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_admin",target:"_blank",rel:"noopener noreferrer",children:"frontend_admin"})}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这节我们做了一些前端代码优化。"}),"\n",(0,c.jsx)(n.p,{children:"之前只是做了接口返回 401 的时候跳转登录页的逻辑，现在又补充了路由守卫，在 Index 组件里读取 localStorage 的值，如果没有 user_info 就跳转登录页面。"}),"\n",(0,c.jsx)(n.p,{children:"然后分析了 React 里 memo 的作用以及和 useCallback、useMemo 的配合使用，之前我们单独使用并没有什么意义，可以去掉。"}),"\n",(0,c.jsx)(n.p,{children:"这样，前端代码就没有啥明显的问题了，还有细节上的优化大家可以自己去做。"})]})}function N(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(S,{...e})}):S(e)}let C=N;N.__RSPRESS_PAGE_META={},N.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F137.%20%E4%BC%9A%E8%AE%AE%E5%AE%A4%E9%A2%84%E5%AE%9A%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96.md"]={toc:[{text:"路由守卫",id:"路由守卫",depth:2},{text:"useCallback、useMemo",id:"usecallbackusememo",depth:2},{text:"总结",id:"总结",depth:2}],title:"137. 会议室预定系统：前端代码优化",headingTitle:"137. 会议室预定系统：前端代码优化",frontmatter:{}}}}]);