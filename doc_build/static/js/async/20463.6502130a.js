"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["20463"],{298602:function(e,n,r){e.exports=r.p+"static/image/13e6d7d3d88d3a02b2685cb07b6b7e24.e6db0daa.webp"},235675:function(e,n,r){e.exports=r.p+"static/image/3dcfb4a62ca4e8563f5b80ceb485701c.0906c9f2.webp"},702438:function(e,n,r){e.exports=r.p+"static/image/78b36476f1c058a881b3139595126208.ed989b79.webp"},541471:function(e,n,r){e.exports=r.p+"static/image/9a97688da75505387bc1bef073b8d748.057104a7.webp"},513165:function(e,n,r){e.exports=r.p+"static/image/c94c4300f29d4cf45773dd3638070e79.8e95ae60.webp"},384004:function(e,n,r){e.exports=r.p+"static/image/e867fd8a92c2010324490ed71e13a106.2d3ee5fc.webp"},28324:function(e,n,r){r.r(n),r.d(n,{default:()=>I});var s=r(552676),c=r(740453);let a=r.p+"static/image/3fbc60a0c90439fd3f9eaacbc063cd2f.1690c176.webp",i=r.p+"static/image/0d629231131ba30eb8f10c02f623383e.05cc4a95.webp",d=r.p+"static/image/4e71732026ed008ac538826666b18d4f.510a7619.webp",t=r.p+"static/image/963f68c454fb10e3b8f87e33691862b6.7f61dc76.webp",l=r.p+"static/image/e75ead4cdc5a22fcb7e4e8972a603944.a037639a.webp",p=r.p+"static/image/40bfc4d6842fb8087d28a597fed633b7.69ddfadb.webp",o=r.p+"static/image/24fdffc3d3b54b75f6d715b36849c763.07fdbce3.webp",h=r.p+"static/image/c2a1f89b8cf5d11cc4bd51483f434d44.8a06009d.webp",j=r.p+"static/image/0b41e38025f8367e340ebe5cf7b69d3c.486ffa2b.webp",x=r.p+"static/image/23763f5feaecf16ef635b1cdf16b7df8.02a75728.webp",m=r.p+"static/image/6096e2b63ed18a6f264ea37e45848613.8d94ce37.webp",g=r.p+"static/image/8a5d3f67e50971bb6af5e167af22c56f.4c062525.webp",u=r.p+"static/image/26962bbfcd14c782fd137a0dcf308d47.e9313ee6.webp",b=r.p+"static/image/3e18fb93f40b5486ebe7e8b22bb1cde9.04efb641.webp",f=r.p+"static/image/54d0a1d69005be093951252618207765.9056d0f3.webp",k=r.p+"static/image/1b376123ba8ac4e1a64e137b414e357b.b7147890.webp",w=r.p+"static/image/d1fba7f20d807be9241497fd45982a23.56ae307e.webp",_=r.p+"static/image/5f7fb7ef1a51467a71684c60eab356cc.33d2cdfa.webp",E=r.p+"static/image/1ea1b3f447d972a4f39f9b7a24fe350c.a673b4f9.webp",v=r.p+"static/image/85212cde43660c5226f75a9240e7698f.e777bb1c.webp",R=r.p+"static/image/37576545505fa59fab54c5edc13947df.75f320df.webp";var N=r(298602),C=r(384004),P=r(702438),A=r(513165);let B=r.p+"static/image/a6f24252352caaed248ca5d8fc4623c1.4e969c7d.webp",M=r.p+"static/image/67d3c6a427e1388121ecb37a2c139bf0.81c5953f.webp";var W=r(235675),y=r(541471);function q(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",blockquote:"blockquote",strong:"strong",h3:"h3",pre:"pre",code:"code",img:"img",h4:"h4"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"22打包篇-应用程序生产环境构建",children:["22.打包篇-应用程序生产环境构建",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22打包篇-应用程序生产环境构建",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["截至目前，我们已将整个简历平台开发完毕。接下来我们实现应用程序的生产环境打包构建。相对于",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6972047382494052392",target:"_blank",rel:"noopener noreferrer",children:"第十四章"}),"而言，本章节的相关配置更为全面与详细。如果你对本章节内容兴趣不大，可以快速阅读或跳过。"]}),"\n",(0,s.jsx)(n.p,{children:"本章节的主要目的是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"实现 Electron 生产环境的构建打包"}),"\n",(0,s.jsx)(n.li,{children:"实现 React 生产环境的构建打包"}),"\n",(0,s.jsx)(n.li,{children:"通过 Electron-Builder 打包生成可执行文件"}),"\n",(0,s.jsx)(n.li,{children:"解决遇到的一系列问题"}),"\n",(0,s.jsx)(n.li,{children:"生成不同平台的可执行文件"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["同时此配置将会是后续 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962941321325576226",target:"_blank",rel:"noopener noreferrer",children:"Webpack 打包优化"}),"、",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962941003858706436",target:"_blank",rel:"noopener noreferrer",children:"Electron 打包体积优化"}),"的铺垫，接下来的两章将以此配置进行优化。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"搞清楚-electron-与-react-的关系",children:["搞清楚 Electron 与 React 的关系",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#搞清楚-electron-与-react-的关系",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["此关系已在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6961586491285831720",target:"_blank",rel:"noopener noreferrer",children:"\uD83D\uDCA5 第四章-开发前必读！Electron 与 React 的关系"}),"进行说明"]}),"，大家先去搞清楚关系之后（阅读时长 3 分钟），再返回看继续阅读。"]}),"\n",(0,s.jsxs)(n.h3,{id:"本地开发",children:["本地开发",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本地开发",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"当我们在本地开发时，运行的脚本命令是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"npm run start:main // 运行主进程\nnpm run start:render // 运行渲染进程\n"})}),"\n",(0,s.jsxs)(n.p,{children:["react 通过 ",(0,s.jsx)(n.code,{children:"webpack-dev-server"})," 起了一个本地服务，我们通过 ",(0,s.jsx)(n.code,{children:"http://127.0.0.1:7001"})," 就能访问我们的站点。Electron 是通过 BrowserWindow 创建了一个浏览器窗口，此窗口通过 loadURL 加载了我们的地址（你可以理解成 webview 形式），从而显示我们的网页。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 创建浏览器窗口\nconst mainWindow = new BrowserWindow({\n  width: 1200,\n  height: 800,\n  webPreferences: {\n    devTools: true,\n    nodeIntegration: true,\n  },\n});\n\nif (isDev()) {\n  // 开发环境\n  mainWindow.loadURL(`http://127.0.0.1:7001`);\n} else {\n  // 生产环境\n  mainWindow.loadURL(`file://${path.join(__dirname, '../dist/index.html')}`);\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"打包构建",children:["打包构建",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#打包构建",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"当我们本地开发完成之后，需要打包上线，需要跑什么命令？不要想太复杂。它们也是分开打包的"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"npm run build:main // 打包主进程（对 app/main/electron.ts进行打包 ）\nnpm run build:render // 打包渲染进程（也就是对 React 进行打包）\n"})}),"\n",(0,s.jsx)(n.p,{children:"打包之后，我们 dist 目录就会存在相应的资源文件。如 index.html、electron.js 等。"}),"\n",(0,s.jsxs)(n.h3,{id:"两者关系",children:["两者关系",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#两者关系",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"提问：抛开 Electron，我们常规的 React 项目，在打包之后，如何运行？"}),"\n",(0,s.jsx)(n.p,{children:"我们是通过点击 dist 下的 index.html 就能在浏览器页面中打开看效果（如果你发现没效果，请确保是以相对路径加载资源文件）但如果结合了 Electron，那么此时点击 dist 下的 index.html，在浏览器中打开，一般都会出错的。"}),"\n",(0,s.jsxs)(n.p,{children:["如何理解？Electron 它内置了 Chromium 和 Node，试想一下，你能在 Chrome 浏览器的控制台中输出 ",(0,s.jsx)(n.code,{children:"process"})," 吗？并不能，它会报错。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["但如果你是通过 Electron 的 BrowserWindow 创建的浏览器窗口，去打印 ",(0,s.jsx)(n.code,{children:"process"}),"，就能显示内容"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:W,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["这也是为什么 Electron 项目中 dist 下的 index.html 不能直接在 Chrome 浏览器运行，因为你的代码，可能用到了 Electron API、Node API，Chrome 浏览器无法识别这是什么东西。",(0,s.jsx)(n.strong,{children:"只有通过 Electron 生成的浏览器窗口，LoadURL 加载此页面，才能正常运行。"})]}),"\n",(0,s.jsx)(n.p,{children:"通过前面的代码可以看到，在生产环境下，我们 LoadURL 的是 dist 下的 index.html"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"if (isDev()) {\n  // 开发环境\n  mainWindow.loadURL(`http://127.0.0.1:7001`);\n} else {\n  // 生产环境\n  mainWindow.loadURL(`file://${path.join(__dirname, '../dist/index.html')}`);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"搞清楚了他们的关系之后，接下来该上主菜了。"}),"\n",(0,s.jsxs)(n.h2,{id:"-动手实践-打包构建",children:["\uD83D\uDD28 动手实践-打包构建",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-动手实践-打包构建",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"搞清楚上述远离之后，我们只需要分别实现 Electron 打包和 React 打包即可，接下来，让我们一步步动手实践。"}),"\n",(0,s.jsxs)(n.h3,{id:"第一步重新划分-webpack-目录",children:["第一步：重新划分 Webpack 目录",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一步重新划分-webpack-目录",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["回过头去看我们的 ",(0,s.jsx)(n.code,{children:"webpack"})," 目录，存在三个文件"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"但这是我们开发环境下所需的配置，为此我们需要新增生产环境下打包构建的配置。"}),"\n",(0,s.jsxs)(n.p,{children:["我们删掉 ",(0,s.jsx)(n.code,{children:"webpack.base.js"})," 文件，原因是：既然划分了主进程和渲染进程的分开打包，我认为没必要将两者的通用内容划分到一块。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"我们把上面的三个文件都删除，重新来配置一下 Electron 与 React 的相关打包内容。记得看注释"})}),"\n",(0,s.jsxs)(n.h4,{id:"-electron-方面",children:["\uD83D\uDC02 Electron 方面",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-electron-方面",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"新增三个文件"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"webpack.main.base.js"})," 基础配置"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"webpack.main.dev.base.js"})," 开发环境下的配置"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"webpack.main.prod.base.js"})," 生产环境下的配置"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.main.base.js\n\nconst path = require('path');\nconst webpack = require('webpack');\n\nmodule.exports = {\n  entry: path.resolve(__dirname, '../app/main/electron.ts'),\n  output: {\n    filename: 'electron.js',\n    path: path.resolve(__dirname, '../dist'),\n  },\n  target: 'electron-main',\n  devtool: 'inline-source-map',\n  resolve: {\n    // 主进程不会存在 jsx、tsx，所以不用配置这些后缀\n    // 至于为什么不需要，会在下一章节优化处说明\n    extensions: ['.js', '.ts'],\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|ts)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n    ],\n  },\n  plugins: [\n    // 用于打包后的主进程中正确获取__dirname\n    new webpack.DefinePlugin({\n      __dirname: '__dirname',\n    }),\n  ],\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Electron 方面的基础配置已经配好，接下来我们修改一下",(0,s.jsx)(n.code,{children:"开发环境"}),"和",(0,s.jsx)(n.code,{children:"生产环境"}),"的配置"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.main.dev.js\n\nconst webpackMerge = require('webpack-merge');\nconst mainBaseConfig = require('./webpack.main.base.js');\n\nconst devConfig = {\n  mode: 'development',\n};\n\nmodule.exports = webpackMerge.merge(mainBaseConfig, devConfig);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.main.prod.js\n\nconst webpackMerge = require('webpack-merge');\nconst mainBaseConfig = require('./webpack.main.base.js');\n\nconst prodConfig = {\n  mode: 'production',\n};\n\nmodule.exports = webpackMerge.merge(mainBaseConfig, prodConfig);\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"-react-方面",children:["\uD83D\uDC37 React 方面",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-react-方面",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"新增三个文件"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"webpack.render.base.js"})," 基础配置"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"webpack.render.dev.base.js"})," 开发环境下的配置"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"webpack.render.prod.base.js"})," 生产环境下的配置"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  // 多入口，这在第十七章有讲解\n  entry: {\n    index: path.resolve(__dirname, '../app/renderer/app.tsx'),\n    setting: path.resolve(\n      __dirname,\n      '../app/renderer/windowPages/setting/app.tsx'\n    ),\n  },\n  output: {\n    filename: '[name].[hash].js',\n    path: path.resolve(__dirname, '../dist'),\n  },\n  resolve: {\n    // 这里就需要 jsx 和 tsx 了\n    extensions: ['.js', '.jsx', '.ts', '.tsx'],\n    // 别名配置，在 Electron 中并未用到别名路径，所以拆到 React 这边的配置中\n    alias: {\n      '@assets': path.join(__dirname, '../', 'assets/'),\n      '@src': path.join(__dirname, '../', 'app/renderer'),\n      '@common': path.join(__dirname, '../', 'app/renderer/common'),\n    },\n  },\n  target: 'electron-renderer',\n  devtool: 'inline-source-map',\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx|ts|tsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n        },\n      },\n      {\n        test: /\\.(jpg|png|jpeg|gif)$/,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {\n              name: '[name]_[hash].[ext]',\n              outputPath: 'images/',\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader', 'postcss-loader'],\n      },\n      {\n        test: /\\.less$/,\n        exclude: /node_modules/,\n        use: [\n          'style-loader',\n          {\n            loader: 'css-loader',\n            options: {\n              modules: {\n                localIdentName: '[name]__[local]__[hash:base64:5]',\n              },\n            },\n          },\n          'postcss-loader',\n          'less-loader',\n        ],\n      },\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, '../app/renderer/index.html'),\n      filename: path.resolve(__dirname, '../dist/index.html'),\n      chunks: ['index'],\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, '../app/renderer/windowPages/setting/index.html'),\n      filename: path.resolve(__dirname, '../dist/setting.html'),\n      chunks: ['setting'],\n    }),\n  ],\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["React 方面的基础配置已经配好，接下来我们修改一下",(0,s.jsx)(n.code,{children:"开发环境"}),"和",(0,s.jsx)(n.code,{children:"生产环境"}),"的配置"]}),"\n",(0,s.jsx)(n.p,{children:"因为我们在开发环境下，通过 webpack-dev-server 起了一个本地服务，所以我们的开发环境配置应为"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.dev.js\n\nconst path = require('path');\nconst webpackMerge = require('webpack-merge');\nconst renderBaseConfig = require('./webpack.render.base.js');\n\nconst devConfig = {\n  mode: 'development',\n  devServer: {\n    contentBase: path.join(__dirname, '../dist'),\n    compress: true,\n    host: '127.0.0.1', // webpack-dev-server启动时要指定ip，不能直接通过localhost启动，不指定会报错\n    port: 7001, // 启动端口为 7001 的服务\n    hot: true,\n  },\n};\n\nmodule.exports = webpackMerge.merge(renderBaseConfig, devConfig);\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.prod.js\n\nconst webpackMerge = require('webpack-merge');\nconst renderBaseConfig = require('./webpack.render.base.js');\n\nconst prodConfig = {\n  mode: 'production',\n};\n\nmodule.exports = webpackMerge.merge(renderBaseConfig, prodConfig);\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"添加打包命令",children:["添加打包命令",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加打包命令",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["前往 ",(0,s.jsx)(n.code,{children:"package.json"}),"，我们为其添加一下打包构建的脚本命令"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"scripts": {\n  // 本地开发\n  "start:main": "webpack --config ./webpack/webpack.main.dev.js && electron ./dist/electron.js",\n  "start:render": "webpack-dev-server --config ./webpack/webpack.render.dev.js",\n  // \uD83D\uDC47 新增的生产打包命令\n  "build:main": "webpack --config ./webpack/webpack.main.prod.js",\n  "build:render": "webpack --config ./webpack/webpack.render.prod.js",\n},\n'})}),"\n",(0,s.jsxs)(n.p,{children:["最终我们的 ",(0,s.jsx)(n.code,{children:"webpack"})," 文件夹是这样的"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h3,{id:"第二步安装-electron-builder",children:["第二步：安装 electron-builder",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第二步安装-electron-builder",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这边我们通过 ",(0,s.jsx)(n.code,{children:"electron-builder"})," 进行打包，根据官方文档，我们进行安装"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install electron-builder --save-dev\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h3,{id:"第三步添加打包命令进行打包",children:["第三步：添加打包命令进行打包",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第三步添加打包命令进行打包",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["由于很多属性，一一细讲并不现实，小伙伴可以前往 ",(0,s.jsx)(n.a,{href:"https://www.electron.build/configuration/configuration",target:"_blank",rel:"noopener noreferrer",children:"electron-builder 官方文档"})," 阅读。"]}),"\n",(0,s.jsxs)(n.p,{children:["通过官方文档的 ",(0,s.jsx)(n.a,{href:"https://www.electron.build/#quick-setup-guide",target:"_blank",rel:"noopener noreferrer",children:"快速上手"}),"，只需要添加对应的一些配置即可实现打包。"]}),"\n",(0,s.jsxs)(n.p,{children:["首先我们在 ",(0,s.jsx)(n.code,{children:"package.json"})," 中添加 build 属性，紧接着添加 PC 打包构建命令"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    // \uD83D\uDC47 新增的PC构建打包命令\n    // 直接生成一个安装完毕的程序，能直接运行，而不是安装包\n    "pack": "electron-builder --dir",\n    // 这个命令是生成真正的安装包\n    "dist": "electron-builder"\n  },\n  // \uD83D\uDC47 新增打包相关的应用信息\n  "build": {\n    "appId": "visResumeMook.ElectronReact", // 自定义 appId\n    "productName": "VisResumeMook", // 打包之后的程序名\n    "copyright": "Copyright \xa9 2019 ${author}",\n    // https://www.electron.build/configuration/contents.html#files\n    // 打包的 app.asar 中包含哪些文件，到时候解压出来就是哪些文件\n    "files": ["dist/**/*", "package.json", "node_modules/"],\n    // 构建的可执行文件放在 package 目录下\n    "directories": {\n      "output": "package"\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"这时候我们就可以执行打包了。一个完整的打包构建命令为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 1. 删除上一轮打包的 dist 目录和 package 目录\nrm -rf dist package\n// 2. 构建打包Elctron\nnpm run build:main\n// 3. 构建打包 React\nnpm run build:render\n// 4. 通过 electron-builder 构建安装包\n//（如果你的静态资源没发生改变，可以直接 pack，不用再重新打包主进程和渲染进程）\nnpm run pack\n"})}),"\n",(0,s.jsx)(n.p,{children:"运行一下，发现报错了"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"我们将 electron 放到 devDependencies 中"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "dependencies": {\n    // \uD83D\uDC47 将其放在 devDependencies 中\n    // "electron": "^11.1.1"\n  },\n  "devDependencies": {\n    "electron": "^11.1.1"\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["重新 install，再执行一下命令 ",(0,s.jsx)(n.code,{children:"npm run pack"})," (因为这里我的静态资源没发生改变，可以直接 pack，不用再重新打包主进程和渲染进程)"]}),"\n",(0,s.jsx)(n.p,{children:"执行结果还是出错，原因在于我们的应用入口文件写错了"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"我们检查一下 package.json 中的 main 属性，果然有问题，进行修改"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  // \uD83D\uDC47 修改成打包后的入口文件\n  "main": "./dist/electron.js"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["再试一次，",(0,s.jsx)(n.code,{children:"npm run pack"}),"，发现这次没问题了。稳妥"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"进入到 package 目录下，找到 mac 目录，进入可以看到一个可执行文件"}),"\n",(0,s.jsx)(n.p,{children:"双击打开，发现好像有些问题"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h4,{id:"-what问题很多",children:["\uD83D\uDCA5 What？问题很多",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-what问题很多",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["怎么主题配色的功能消失了？换言之，读取的 ",(0,s.jsx)(n.code,{children:"appConfig"})," 文件好像都不存在？正因为读不到，所以没有了主题列表"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:"image.png"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["点击进入",(0,s.jsx)(n.code,{children:"简历制作"})," 模块无反应？"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:"image.png"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["模版列表怎么都没图片了，我们从 ",(0,s.jsx)(n.code,{children:"assets/template"})," 文件夹中读取的模版封面，怎么也不见了呢？"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h4,{id:"-问题一个个定位解决",children:["\uD83C\uDF08 问题一个个定位解决",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-问题一个个定位解决",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"有意思，这才是进步，毕竟快速定位问题也是一种技能。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Question1: 主题列表消失"})}),"\n",(0,s.jsx)(n.p,{children:"先来看第一个问题，主题配色的功能消失了？为什么没有主题列表？双击打开应用，我们进入切到开发者工具，看看控制台输出什么。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["果不其然，在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962761759404851239",target:"_blank",rel:"noopener noreferrer",children:"第十六章"}),"时讲到，我们的主题是通过读取 ",(0,s.jsx)(n.code,{children:"appConfig"})," 目录下的 ",(0,s.jsx)(n.code,{children:"theme.config.json"})," 文件构造出来的主题列表，",(0,s.jsx)(n.code,{children:"appConfig"})," 文件夹都找不到，怎么会有主题列表呢？"]}),"\n",(0,s.jsx)(n.p,{children:"百思不得其解？怎么会没有 appConfig 目录？前往 dist 文件夹瞧一瞧，果然没有！"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["为什么会如此？要知道，Webpack 只会将你所需要的资源进行打包，换言之，凡是你通过 ",(0,s.jsx)(n.code,{children:"import xxx"})," 的资源引入并使用，就会被打包到 dist 文件夹中。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"纸上得来终觉浅，得知此事要躬行"}),"，我们来试一试。我们就在 ",(0,s.jsx)(n.code,{children:"app/renderer/app.tsx"})," 根文件下，引入 ",(0,s.jsx)(n.code,{children:"assets/template/template1.jpg"})," 文件（验证一下）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Router from './router';\nimport store from './store';\nimport { Provider } from 'react-redux';\n\n// \uD83D\uDC47 ⚠️ 这里只是引入 template1.jpg 图片\nimport TestWebpackJpg from '@assets/template/template1.jpg';\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <Router />\n    </Provider>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById('root'));\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时我们再重新打包一下"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"// 1. 删除上一轮打包的 dist 目录\nrm -rf dist\n// 2. 重新打包 React\nnpm run build:render\n"})}),"\n",(0,s.jsxs)(n.p,{children:["小伙伴们猜一下，此时的 ",(0,s.jsx)(n.code,{children:"dist/images/"})," 目录下是否会出现这张图片呢？"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"让我来告诉你答案：并不会"}),"。你可以前往 dist 目录查看，你会发现这张照片并没有打进去。我们将代码稍作修改"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Router from './router';\nimport store from './store';\nimport { Provider } from 'react-redux';\n\n// \uD83D\uDC47 ⚠️ 引入 template1.jpg 图片\nimport TestWebpackJpg from '@assets/template/template1.jpg';\n\nfunction App() {\n  // \uD83D\uDC47⚠️ 打印这张图片\n  console.log(TestWebpackJpg);\n\n  return (\n    <Provider store={store}>\n      <Router />\n    </Provider>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById('root'));\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时我们再重新打包一下"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"// 1. 删除上一轮打包的 dist 目录\nrm -rf dist\n// 2. 重新打包 React\nnpm run build:render\n"})}),"\n",(0,s.jsxs)(n.p,{children:["小伙伴们猜一下，此时的 ",(0,s.jsx)(n.code,{children:"dist/images/"})," 目录下是否会出现这张图片呢？多说无益，是骡子是马，拉出来溜一溜"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["普天同庆，我们是能在 ",(0,s.jsx)(n.code,{children:"dist/images/"})," 下发现这张图片的。说明 Webpack 只会将我们使用到的 ",(0,s.jsx)(n.code,{children:"import"})," 资源打包到 dist 下，针对 ",(0,s.jsx)(n.code,{children:"appConfig"})," 和 ",(0,s.jsx)(n.code,{children:"assets/template"})," 根本不会打包，因为我们是通过 NodeJS 的 fs 文件系统进行读取的，问题来了，如何让打包之后的 dist 也能有这些文件呢？"]}),"\n",(0,s.jsxs)(n.p,{children:["在网上搜索了一些教程，发现如脚手架创建出来的目录，会存在一个 ",(0,s.jsx)(n.code,{children:"public"})," 文件夹存放静态资源，如果你将静态资源文件放入该 public 文件夹，webpack 将不会处理它，在你打包的时候，会将 ",(0,s.jsx)(n.code,{children:"public"})," 文件夹直接",(0,s.jsx)(n.strong,{children:"复制"}),"一份到你构建出来的文件夹中。"]}),"\n",(0,s.jsxs)(n.p,{children:["所以我的解决方案就是：",(0,s.jsxs)(n.strong,{children:["将所需的文件夹复制一份放在 ",(0,s.jsx)(n.code,{children:"dist"})," 目录下"]}),"，如何复制？在 webpack 官方文档中有提供一个插件，使用 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/copy-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"copy-webpack-plugin"}),"就能实现我们的需求。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来让我们修改一下 ",(0,s.jsx)(n.code,{children:"webpack.render.base.js"})," 文件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.base.js\n\n/* eslint-disable @typescript-eslint/no-require-imports */\nconst path = require('path');\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  plugins: [\n    // \uD83D\uDC47 通过该插件实现资源文件的拷贝\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: path.resolve(__dirname, '../assets'),\n          to: path.resolve(__dirname, '../dist/assets'),\n        },\n        {\n          from: path.resolve(__dirname, '../appConfig'),\n          to: path.resolve(__dirname, '../dist/appConfig'),\n        },\n      ],\n    }),\n  ],\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时我们再重新打包一下"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"// 1. 删除上一轮打包的 dist 目录\nrm -rf dist\n// 2. 重新打包 React\nnpm run build:render\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看到这时候在 dist 目录下，已经有对应的文件夹目录。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["这时候是不是重新用 ",(0,s.jsx)(n.code,{children:"electron-builder"})," 构建一个包，就可以了呢？让我们试试。走一个完整的打包构建命令"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 1. 删除上一轮打包的 dist 目录和 package 目录\nrm -rf dist package\n// 2. 构建打包Elctron\nnpm run build:main\n// 3. 构建打包 React\nnpm run build:render\n// 4. 通过 electron-builder 构建安装包\n//（如果你的静态资源没发生改变，可以直接 pack，不用再重新打包主进程和渲染进程）\nnpm run pack\n"})}),"\n",(0,s.jsx)(n.p,{children:"构建完毕之后，前往查看发现还是不行，控制台报错"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Uncaught (in promise) Error: ENOENT: no such file or directory, scandir '/Users/pengdaokuan/Desktop/pdk/visResumeMook/package/mac/VisResumeMook.app/Contents/Resources/assets/template'"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["有趣，这个路径不正确，我们所期望的是，这里的 ",(0,s.jsx)(n.code,{children:"assets/template"})," 前面应该是带有一个 ",(0,s.jsx)(n.code,{children:"dist"})," 目录的。让我们来看看这个安装包的相关代码，由于 electron 打包后的代码是压缩过后的，我们需要对其解压一下。我们到 ",(0,s.jsx)(n.code,{children:"package/mac/VisResumeMook.app/Contents/Resources"})," 中找到 app.asar，对它进行解压"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// 1. 全局安装\nnpm install -g asar\n// 2. 到该目录下，正确目录自行拼写\ncd package/mac/VisResumeMook.app/Contents/Resources\n// 3. 解压\nasar extract app.asar ./\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["事实证明是存在的，那到底是什么问题导致没有的呢？我们再注意看看报错信息，",(0,s.jsx)(n.strong,{children:"主要问题就是路径问题"}),"，我们通过断点来看看 ",(0,s.jsx)(n.code,{children:"appConfig"})," 的绝对路径是什么。进入到控制台，找到 ",(0,s.jsx)(n.code,{children:"Sources"})," ，然后对 ",(0,s.jsx)(n.code,{children:"useThemeActionHooks.ts"})," 文件打上端点。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["然后我们刷新一下页面，我们鼠标悬浮到 ",(0,s.jsx)(n.code,{children:"appPath"})," 上，看看输出的是什么"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["好家伙，这路径很明显不正确，如果你还记得 ",(0,s.jsx)(n.code,{children:"getAppPath()"})," 方法获取应用程序的路径，想必不会忘记我们是通过 ",(0,s.jsx)(n.strong,{children:"app.getAppPath()"})," 方法获取的，这个 API 得到的是在文件管理器中的应用程序路径。而我们期望得到的是带有 ",(0,s.jsx)(n.code,{children:"app.aras/dist"})," 这样的一个路径。所以说通过这个 API 获取是不正确的，那该通过什么获取呢？ 答案是 ",(0,s.jsx)(n.code,{children:"__dirname"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们在控制台打印一下 ",(0,s.jsx)(n.code,{children:"__dirname"}),"，看看结果是什么。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["这时候再去找 dist 下的 appConfig 是不是就行了？所以问题切到了，如何得到正确的路径。我们肯定不愿再改 ",(0,s.jsx)(n.code,{children:"getAppPath()"})," 方法，所以我们只需要改主进程中，ipc 响应的数据即可。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// app/main/electron.ts\n\n// getAppPath() 方法主要是通过 ipc 通信，得到项目路径，我们将 __dirname 的路径返回\nipcMain.on('get-root-path', (event, arg) => {\n  event.reply('reply-root-path', __dirname);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"让我们走一个完整的打包构建命令"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 1. 删除上一轮打包的 dist 目录和 package 目录\nrm -rf dist package\n// 2. 构建打包Elctron\nnpm run build:main\n// 3. 构建打包 React\nnpm run build:render\n// 4. 通过 electron-builder 构建安装包\n//（如果你的静态资源没发生改变，可以直接 pack，不用再重新打包主进程和渲染进程）\nnpm run pack\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后进入 ",(0,s.jsx)(n.code,{children:"package/mac"})," 双击应用程序，然后看到首页就有简历列表啦～"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Quesiton2: 简历模版列表没有封面"})}),"\n",(0,s.jsx)(n.p,{children:"上一个问题解决了，这个问题应该也不难，我们进入到模版列表，发现还是没有封面，原因竟然是"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Uncaught (in promise) Error: ENOENT, distassets/template not found in /Users/pengdaokuan/Desktop/pdk/visResumeMook/package/mac/VisResumeMook.app/Contents/Resources/app.asar"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["等等，这个路径有点问题，",(0,s.jsx)(n.code,{children:"distassets"})," 中间是不是少了个 ",(0,s.jsx)(n.code,{children:"/"}),"，前往 ",(0,s.jsx)(n.code,{children:"app/renderer/hooks"}),"，找到 ",(0,s.jsx)(n.code,{children:"useReadDirAssetsTemplateHooks.ts"})," 文件进行修改"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"让我们走一个完整的打包构建命令"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 1. 删除上一轮打包的 dist 目录\nrm -rf dist\n// 2. 构建打包Elctron\nnpm run build:main\n// 3. 构建打包 React\nnpm run build:render\n// 4. 通过 electron-builder 构建安装包\n//（如果你的静态资源没发生改变，可以直接 pack，不用再重新打包主进程和渲染进程）\nnpm run pack\n"})}),"\n",(0,s.jsxs)(n.p,{children:["进入 ",(0,s.jsx)(n.code,{children:"package/mac"})," 双击应用程序，进去到模版列表页面，是没问题的。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"此时再去点击简历制作，也是可行的。至此我们的打包问题已经得到解决。"}),"\n",(0,s.jsxs)(n.h3,{id:"第四步window--mac-双管齐下",children:["第四步：Window & Mac 双管齐下",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第四步window--mac-双管齐下",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["前面我们是根据文档，做了最为简单的配置，通过 electron-builder 官方文档，",(0,s.jsx)(n.a,{href:"https://www.electron.build/cli.html#target",target:"_blank",rel:"noopener noreferrer",children:"它声明"}),"："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Without target configuration, electron-builder builds Electron app for current platform and current architecture using default target."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"也就是说，如果你什么都不配置的情况下，会根据你的系统平台，给你打一个默认的包。但我们往往是希望构建时，能生成多平台的安装包。接下来让我们配置一下吧，更多属性可自行查阅文档"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "build": {\n    "appId": "visResumeMook.ElectronReact",\n    "productName": "VisResumeMook",\n    "copyright": "Copyright \xa9 2019 ${author}",\n    // 包含的文件，这个在解压 asar 时可以看到源代码\n    "files": ["dist/**/*", "package.json", "node_modules/"],\n    // 生成的安装包输出到 package 文件夹\n    "directories": {\n      "output": "package"\n    },\n    "mac": {\n      "target": ["dmg", "zip"],\n      "category": "public.app-category.productivity"\n    },\n    "dmg": {\n      // 这个是安装时的图标位置\n      "contents": [\n        {\n          "x": 130,\n          "y": 220,\n          "type": "link",\n          "path": "/Applications"\n        },\n        {\n          "x": 410,\n          "y": 220,\n          "type": "file"\n        }\n      ]\n    },\n    "win": {\n      "target": ["msi", "nsis"]\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"让我们走一个完整的打包构建命令"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 1. 删除上一轮打包的 dist 目录和 package 目录\nrm -rf dist package\n// 2. 构建打包Elctron\nnpm run build:main\n// 3. 构建打包 React\nnpm run build:render\n// 4. ⚠️ 这里是要执行 dist，生成真正的安装包\nnpm run dist\n"})}),"\n",(0,s.jsx)(n.p,{children:"经过一段时间等待，我们可以看到打包完成"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["让我们看看 ",(0,s.jsx)(n.code,{children:"package"})," 下有什么文件"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["有一个 ",(0,s.jsx)(n.code,{children:"zip"})," 和 ",(0,s.jsx)(n.code,{children:"dmg"}),"，我是 Mac 电脑，所以我双击打开 dmg 的安装包进行安装"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"安装之后就能愉快使用啦"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本章节内容特别多，构建过程也遇到了许多的问题，阿宽认为最重要的是小伙伴们能搞清楚 Electron 与 React 的构建关系，搞清楚之后再通过 ",(0,s.jsx)(n.code,{children:"electron-builder"})," 构建成安装包即可。"]}),"\n",(0,s.jsxs)(n.p,{children:["小伙伴们可以再回顾一下本章节的整体内容，代码可见\uD83D\uDC49 ",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/chapter-22-build",target:"_blank",rel:"noopener noreferrer",children:"chapter-22-build"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"到此，我们的应用程序的构建已结束。但事情真的如此简单吗？"})]})}function D(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(q,{...e})}):q(e)}let I=D;D.__RSPRESS_PAGE_META={},D.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F22.%E6%89%93%E5%8C%85%E7%AF%87-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"搞清楚 Electron 与 React 的关系",id:"搞清楚-electron-与-react-的关系",depth:2},{text:"本地开发",id:"本地开发",depth:3},{text:"打包构建",id:"打包构建",depth:3},{text:"两者关系",id:"两者关系",depth:3},{text:"\uD83D\uDD28 动手实践-打包构建",id:"-动手实践-打包构建",depth:2},{text:"第一步：重新划分 Webpack 目录",id:"第一步重新划分-webpack-目录",depth:3},{text:"\uD83D\uDC02 Electron 方面",id:"-electron-方面",depth:4},{text:"\uD83D\uDC37 React 方面",id:"-react-方面",depth:4},{text:"添加打包命令",id:"添加打包命令",depth:4},{text:"第二步：安装 electron-builder",id:"第二步安装-electron-builder",depth:3},{text:"第三步：添加打包命令进行打包",id:"第三步添加打包命令进行打包",depth:3},{text:"\uD83D\uDCA5 What？问题很多",id:"-what问题很多",depth:4},{text:"\uD83C\uDF08 问题一个个定位解决",id:"-问题一个个定位解决",depth:4},{text:"第四步：Window & Mac 双管齐下",id:"第四步window--mac-双管齐下",depth:3},{text:"总结",id:"总结",depth:2}],title:"22.打包篇-应用程序生产环境构建",headingTitle:"22.打包篇-应用程序生产环境构建",frontmatter:{}}}}]);