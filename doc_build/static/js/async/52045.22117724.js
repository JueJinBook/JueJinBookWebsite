"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["52045"],{796365:function(n,e,r){r.r(e),r.d(e,{default:()=>d});var s=r(552676),l=r(740453);function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",h2:"h2",pre:"pre",code:"code",blockquote:"blockquote",br:"br",strong:"strong",ul:"ul"},(0,l.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"第08章数组切片和集合一管理一组数据",children:["第08章—数组、切片和集合一｜管理一组数据",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第08章数组切片和集合一管理一组数据",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\uFEFF在上一讲的末尾，我们使用循环结构实现了查找10以内的素数。但这并不意味着结束，因为查找往往意味着使用。而要保存和访问找出的这一组数据，就需要使用数组了。"}),"\n",(0,s.jsx)(e.p,{children:"这节课，我们就来介绍一下Go语言中的数据“容器”。本节包括以下内容："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Go语言中的数组、切片的声明和赋值"}),"\n",(0,s.jsx)(e.li,{children:"集合的声明和赋值"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"数组",children:["数组",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数组",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"我们先来回顾查找10以内素数的代码实现："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   for i := 2; i < 10; i++ {\r\n      //假定i为素数\r\n      flag := true\r\n      for j := 2; j < i; j++ {\r\n         if i%j == 0 {\r\n            //当i能被某个整数整除时，不是素数\r\n            flag = false\r\n         }\r\n      }\r\n      //如果依旧为true，则i为素数\r\n      if flag {\r\n         //输出素数i\r\n         fmt.Println(i)\r\n      }\r\n   }\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"运行后，控制台输出："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["2",(0,s.jsx)(e.br,{}),"\n","3",(0,s.jsx)(e.br,{}),"\n","5",(0,s.jsx)(e.br,{}),"\n","7"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"显然，上述代码中当flag为true时输出的单个i值均为素数，总共有4个。为了方便在后续的代码中使用这4个数，我们将其放置在一个数据“组合”中。像这样的数据“组合”，可以使用数组来管理，数组中的每个值又称为数组中的“元素”。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"❗️ 注意： 数组中的元素并不限制值的类型，但要求所有元素均为相同的类型。"})}),"\n",(0,s.jsx)(e.p,{children:"对于本例而言，便可声明一个总共有4个元素的数组来管理素数结果。Go语言中声明数组的一般格式为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"var array_name [quantity]Type\n"})}),"\n",(0,s.jsx)(e.p,{children:"其中，var关键字用于声明变量；array_name表示数组名；quantity表示数组元素个数；Type表示元素类型。"}),"\n",(0,s.jsx)(e.p,{children:"因此，对于本例，便可声明名为“resultArray”的数组变量，其元素个数为4，类型为int，代码为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"var resultArray [4]int\n"})}),"\n",(0,s.jsx)(e.p,{children:"声明后即可为单个元素赋值了。和其它的编程语言类似，要为数组中的某个元素赋值，格式为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"array_name[index] = Value\n"})}),"\n",(0,s.jsx)(e.p,{children:"其中，array_name表示已声明的数组名；index表示数组中的第N个元素，称之为索引或下标，通常是包含0的正整数；Value则表示具体的数据值。"}),"\n",(0,s.jsx)(e.p,{children:"对于本例而言，若要为数组中的第3个元素赋值为5，对应的代码为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"resultArray[2] = 5\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"❗️ 注意： 数组的索引从0开始，因此索引的取值范围应该是从0至数组元素个数减1为止。如本例则为0、1、2、3。超出范围的赋值和取值将引发下标越界错误，导致程序出错。对某一索引位置的元素重复赋值将导致旧值被新值替换。"})}),"\n",(0,s.jsx)(e.p,{children:"到此，数组的声明和赋值方法都有了，下面就来将它们结合到原有代码中吧！"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   var resultArray [4]int\r\n   var arrayIndex int = 0\r\n   for i := 2; i < 10; i++ {\r\n      //假定i为素数\r\n      flag := true\r\n      for j := 2; j < i; j++ {\r\n         if i%j == 0 {\r\n            //当i能被某个整数整除时，不是素数\r\n            flag = false\r\n         }\r\n      }\r\n      //如果依旧为true，则i为素数\r\n      if flag {\r\n         //将素数存放到resultArray数组中\r\n         resultArray[arrayIndex] = i\r\n         arrayIndex++\r\n      }\r\n   }\r\n   fmt.Println(resultArray)\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"如上代码所示，除了声明resultArray外，还声明了arrayIndex作为数组赋值时的索引之用。每次赋值结束后arrayIndex都会自增1，以便为下个元素赋值。"}),"\n",(0,s.jsx)(e.p,{children:"运行这段代码，控制台输出："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"[2 3 5 7]"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"如此，查找到的结果集便保存到了resultArray数组中，后面的代码便通过resultArray随时访问结果集了。"}),"\n",(0,s.jsx)(e.p,{children:"接下来思考一个问题，本例要求查找了10以内的素数。如果换成查找30以内、50以内，甚至更大范围的话，查找到的结果必然会有不同程度的增加。"}),"\n",(0,s.jsxs)(e.p,{children:["如果使用数组来存放结果的话，很容易引发下标越界错误。和数组相对，Go语言还提供了一种专门存放",(0,s.jsx)(e.strong,{children:"不定元素个数"}),"的数据结构——切片。"]}),"\n",(0,s.jsxs)(e.h2,{id:"切片",children:["切片",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#切片",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"对于已经熟悉数组声明和赋值的朋友来说，使用切片并非难事。在Go语言中，切片的声明一般格式为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"var slice_name []Type\n"})}),"\n",(0,s.jsx)(e.p,{children:"其中，var关键字用于声明变量；slice_name表示切片名；Type表示元素类型。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"\uD83D\uDCA1 提示： 注意到了吗？声明切片和数组的区别仅仅是去掉了中括号中的元素个数！"})}),"\n",(0,s.jsx)(e.p,{children:"对于本例，代码实现为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"var resultSlice []int\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"❗️ 注意： 和数组类似，切片中的元素也不限制值的类型，但要求所有元素均为相同的类型。"})}),"\n",(0,s.jsx)(e.p,{children:"完成切片的声明后，就来到赋值环节。"}),"\n",(0,s.jsxs)(e.p,{children:["与数组不同，为切片赋值可以理解为“",(0,s.jsx)(e.strong,{children:"扩充"}),"”。在一开始，切片里面的元素个数为0。“扩充”一个值，就相当于为切片中的第一个元素赋值。赋值后，切片的元素个数就变成了1。若再次“扩充”，则相当于为切片中的第二个元素赋值。赋值后，切片的元素个数就变成了2，以此类推……"]}),"\n",(0,s.jsx)(e.p,{children:"在Go语言中，为切片“扩充”需要使用append()函数，使用格式如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"slice_name = append(slice_name, value)\n"})}),"\n",(0,s.jsx)(e.p,{children:"其中，slice_name表示已声明的切片变量名，value表示具体的数据值。"}),"\n",(0,s.jsxs)(e.p,{children:["值得一提的是，",(0,s.jsx)(e.strong,{children:"append()函数本身并不会改变原有切片"}),"，只是将切片“扩容”后的结果作为函数返回值。因此，需要将“扩容”后的结果再次（即函数返回值）赋值给slice_name，才能真正使slice_name发生改变。"]}),"\n",(0,s.jsx)(e.p,{children:"对于本例而言，若要“扩充”切片，添加值为2的元素，代码实现为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"resultSlice = append(resultSlice, value)\n"})}),"\n",(0,s.jsx)(e.p,{children:"到此，我们掌握了切片的声明和赋值方法，接下来又到了修改原有代码的时候。修改后的代码如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   var resultSlice []int\r\n   for i := 2; i < 30; i++ {\r\n      //假定i为素数\r\n      flag := true\r\n      for j := 2; j < i; j++ {\r\n         if i%j == 0 {\r\n            //当i能被某个整数整除时，不是素数\r\n            flag = false\r\n         }\r\n      }\r\n      //如果依旧为true，则i为素数\r\n      if flag {\r\n         //将素数存放到resultArray数组中\r\n         resultSlice = append(resultSlice, i)\r\n      }\r\n   }\r\n   fmt.Println(resultSlice)\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"显然，由于切片在赋值时无需关注下标，因此连原有的arrayIndex变量也省了。"}),"\n",(0,s.jsx)(e.p,{children:"运行这段代码，控制台将输出："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"[2 3 5 7 11 13 17 19 23 29]"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"接下来，如果想查找100以内的素数，该如何修改呢？答案是——只需要修改循环终止的条件即可（即将i < 30改为i < 100），是不是更方便呢？"}),"\n",(0,s.jsx)(e.p,{children:"在实际项目中，切片的使用其实更为广泛。例如：当用户发起搜索，搜索的结果个数往往会根据搜索关键字的不同而发生变化。在不确定总数的前提下，使用数组显然是不合适的。"}),"\n",(0,s.jsxs)(e.h2,{id:"集合",children:["集合",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#集合",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"使用数组不合适，那使用什么呢？答案是：集合。我们考虑另一个场景——管理学生信息。"}),"\n",(0,s.jsxs)(e.p,{children:["如何保存和查找一所学校所有学生的信息呢？通过姓名显然是不合适的，因为会有重名的情况。通过年级+姓名呢？显然也是不合适的，因为这可能会执行两次筛选，而且也无法从根本上排除重名的情况。所以，我们应使用一个能标识一个学生",(0,s.jsx)(e.strong,{children:"唯一性"}),"的数据作为保存和查找的依据。比如：学号。"]}),"\n",(0,s.jsx)(e.p,{children:"一个学号对应一个学生，保存时如此，查找时亦如此。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"\uD83D\uDCA1 提示： 与此类似的管理方式还有身份证号、驾驶证号、商品ID、图书ISBN等等。这些能标识唯一性的值可以统称为“唯一ID”。在实际项目中，为了保证单条数据的唯一性，为其构建唯一ID号是非常有必要的。"})}),"\n",(0,s.jsxs)(e.p,{children:["像上述这种唯一ID对应单条数据，可以使用集合来管理。集合可以看作是一类特殊的切片，只不过集合的元素都是由若干“",(0,s.jsx)(e.strong,{children:"键-值对"}),"”数据构成的。所谓“键”，相当于“唯一ID”；“值”，相当于单条数据，",(0,s.jsx)(e.strong,{children:"键不允许重复"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"Go语言中声明集合的一般格式为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"var map_name = make(map[key_type]value_type)\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.code,{children:"❗️ 注意： 和数组、切片类似，集合中的键和值均不限制数据类型，且键和值可分别使用不同的类型。但要求所有键均为相同的类型，所有值均为相同类型。"})}),"\n",(0,s.jsx)(e.p,{children:"其中，var用于声明变量；map_name表示集合的变量名；key_type表示键的类型；value_type表示值的类型。"}),"\n",(0,s.jsx)(e.p,{children:"对于本例而言，学号和学生信息都使用string类型来表示，集合的变量名为studentInfos。对应的代码为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:"var studentInfos = make(map[string]string)\n"})}),"\n",(0,s.jsx)(e.p,{children:"集合中元素的赋值和数组类似，只不过中括号中不再是索引，而是键的值。例如，保存学号为“0001”的学生，名为“王小红”，代码实现为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:'studentInfos["0001"] = "王小红"\n'})}),"\n",(0,s.jsx)(e.p,{children:"以此类推，继续增加4条信息，完整的代码如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   var studentInfos = make(map[string]string)\r\n   studentInfos["0001"] = "王小红"\r\n   studentInfos["0002"] = "李小明"\r\n   studentInfos["0003"] = "张三丰"\r\n   studentInfos["0004"] = "孙小贝"\r\n   studentInfos["0005"] = "何明明"\r\n   // 输出语句\r\n   fmt.Println(studentInfos)\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"程序运行结果为："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"map[0001:王小红 0002:李小明 0003:张三丰 0004:孙小贝 0005:何明明]"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["值得一提的是，若对一个已经存在数据的“键”再次赋值，原有的数据将被",(0,s.jsx)(e.strong,{children:"覆盖"}),"。比如，在本例输出语句前添加："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-go",children:'studentInfos["0003"] = "周丹"\n'})}),"\n",(0,s.jsx)(e.p,{children:"再次运行本例，结果则变为："}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"map[0001:王小红 0002:李小明 0003:周丹 0004:孙小贝 0005:何明明]"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["在实际项目中，充分利用集合键唯一的性质，还可以确保",(0,s.jsx)(e.strong,{children:"排除重复"}),"的数据。"]}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,s.jsx)(e.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Go语言中的数组、切片；"}),"\n",(0,s.jsx)(e.li,{children:"Go语言中集合的声明和赋值。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"数组、切片和集合都是Go语言中的数据“容器”。使用它们可以将多个数据成组保存，以备后用。"}),"\n",(0,s.jsx)(e.p,{children:"数组是固定长度的，切片是不定长度的。集合是一类特殊的切片，元素由若干键-值对构成，键不允许重复。"}),"\n",(0,s.jsx)(e.p,{children:"在本讲中，无论是数组、切片抑或是集合，获取元素的方式都是一股脑输出的。有没有办法只获取其中某个元素呢？另外，如何获取它们所拥有的元素个数呢？这些问题，我们将在下一讲中一一解答。"}),"\n",(0,s.jsx)(e.p,{children:"➡️ 在下次课程中，我们会介绍如下内容："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Go语言中的数据“容器”，包括：","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"数组、切片和集合的元素遍历、访问和修改"}),"\n"]}),"\n"]}),"\n"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(i,{...n})}):i(n)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC08%E7%AB%A0%E2%80%94%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E9%9B%86%E5%90%88%E4%B8%80%EF%BD%9C%E7%AE%A1%E7%90%86%E4%B8%80%E7%BB%84%E6%95%B0%E6%8D%AE.md"]={toc:[{text:"数组",id:"数组",depth:2},{text:"切片",id:"切片",depth:2},{text:"集合",id:"集合",depth:2},{text:"小结",id:"小结",depth:2}],title:"第08章—数组、切片和集合一｜管理一组数据",headingTitle:"第08章—数组、切片和集合一｜管理一组数据",frontmatter:{}}}}]);