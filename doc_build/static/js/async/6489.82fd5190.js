"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["6489"],{565831:function(e,r,n){n.r(r),n.d(r,{default:()=>l});var s=n(552676),d=n(740453);function o(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",blockquote:"blockquote",code:"code",pre:"pre",ol:"ol",strong:"strong"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"11基础-8用户业务逻辑处理",children:["11基础 8：用户业务逻辑处理",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#11基础-8用户业务逻辑处理",children:"#"})]}),"\n",(0,s.jsxs)(r.h2,{id:"本节核心内容",children:["本节核心内容",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#本节核心内容",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"这一节是核心小节，讲解如何处理用户业务，这也是 API 的核心功能。本小节会讲解实际开发中需要的一些重要功能点，并根据笔者的开发经验，给出一些建议。功能点包括："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["各种场景的业务逻辑处理","\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"创建用户"}),"\n",(0,s.jsx)(r.li,{children:"删除用户"}),"\n",(0,s.jsx)(r.li,{children:"更新用户"}),"\n",(0,s.jsx)(r.li,{children:"查询用户列表"}),"\n",(0,s.jsx)(r.li,{children:"查询指定用户的信息"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.li,{children:"数据库的 CURD 操作"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["本小节源码下载路径：",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo07",target:"_blank",rel:"noopener noreferrer",children:"demo07"})]}),"\n",(0,s.jsx)(r.p,{children:"可先下载源码到本地，结合源码理解后续内容，边学边练。"}),"\n",(0,s.jsxs)(r.p,{children:["本小节的代码是基于 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo06",target:"_blank",rel:"noopener noreferrer",children:"demo06"})," 来开发的。"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"配置路由信息",children:["配置路由信息",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#配置路由信息",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["需要先在 ",(0,s.jsx)(r.code,{children:"router/router.go"})," 文件中，配置路由信息："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'func Load(g *gin.Engine, mw ...gin.HandlerFunc) *gin.Engine {\r\n    ...\r\n	// 用户路由设置\r\n	u := g.Group("/v1/user")\r\n	{\r\n		u.POST("", user.Create)         // 创建用户\r\n		u.DELETE("/:id", user.Delete)   // 删除用户 \r\n		u.PUT("/:id", user.Update)      // 更新用户\r\n		u.GET("", user.List)            // 用户列表\r\n		u.GET("/:username", user.Get)   // 获取指定用户的详细信息\r\n	}\r\n    ...\r\n	return g\r\n}\n'})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["在 RESTful API 开发中，API 经常会变动，为了兼容老的 API，引入了版本的概念，比如上例中的 ",(0,s.jsx)(r.code,{children:"/v1/user"}),"，说明该 API 版本是 ",(0,s.jsx)(r.code,{children:"v1"}),"。"]}),"\n",(0,s.jsx)(r.p,{children:"很多 RESTful API 最佳实践文章中均建议使用版本控制，笔者这里也建议对 API 使用版本控制。"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"注册新的错误码",children:["注册新的错误码",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#注册新的错误码",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["在 ",(0,s.jsx)(r.code,{children:"pkg/errno/code.go"})," 文件中（详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/pkg/errno/code.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/pkg/errno/code.go"}),"），新增如下错误码："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'var (\r\n	// Common errors\r\n        ...\r\n\r\n	ErrValidation       = &Errno{Code: 20001, Message: "Validation failed."}\r\n	ErrDatabase         = &Errno{Code: 20002, Message: "Database error."}\r\n	ErrToken            = &Errno{Code: 20003, Message: "Error occurred while signing the JSON web token."}\r\n\r\n	// user errors\r\n	ErrEncrypt           = &Errno{Code: 20101, Message: "Error occurred while encrypting the user password."}\r\n	ErrTokenInvalid      = &Errno{Code: 20103, Message: "The token was invalid."}\r\n	ErrPasswordIncorrect = &Errno{Code: 20104, Message: "The password was incorrect."}\r\n)\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"新增用户",children:["新增用户",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#新增用户",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["更新 ",(0,s.jsx)(r.code,{children:"handler/user/create.go"})," 中 ",(0,s.jsx)(r.code,{children:"Create()"})," 的逻辑，更新后的内容见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/handler/user/create.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/handler/user/create.go"}),"。"]}),"\n",(0,s.jsx)(r.p,{children:"创建用户逻辑："}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"从 HTTP 消息体获取参数（用户名和密码）"}),"\n",(0,s.jsx)(r.li,{children:"参数校验"}),"\n",(0,s.jsx)(r.li,{children:"加密密码"}),"\n",(0,s.jsx)(r.li,{children:"在数据库中添加数据记录"}),"\n",(0,s.jsx)(r.li,{children:"返回结果（这里是用户名）"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"从 HTTP 消息体解析参数，前面小节已经介绍了。"}),"\n",(0,s.jsxs)(r.p,{children:["参数校验这里用的是 ",(0,s.jsx)(r.code,{children:"gopkg.in/go-playground/validator.v9"})," 包（详见 ",(0,s.jsx)(r.a,{href:"https://github.com/go-playground/validator",target:"_blank",rel:"noopener noreferrer",children:"go-playground/validator"}),"），实际开发过程中，该包可能不能满足校验需求，这时候可在程序中加入自己的校验逻辑，比如在 ",(0,s.jsx)(r.code,{children:"handler/user/creater.go"})," 中添加校验函数 ",(0,s.jsx)(r.code,{children:"checkParam"}),"："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'package user\r\n\r\nimport (\r\n    ...\r\n)\r\n\r\n// Create creates a new user account.\r\nfunc Create(c *gin.Context) {\r\n	log.Info("User Create function called.", lager.Data{"X-Request-Id": util.GetReqID(c)})\r\n	var r CreateRequest\r\n	if err := c.Bind(&r); err != nil {\r\n		SendResponse(c, errno.ErrBind, nil)\r\n		return\r\n	}\r\n\r\n	if err := r.checkParam(); err != nil {\r\n		SendResponse(c, err, nil)\r\n		return\r\n	}\r\n        ...\r\n}\r\n\r\nfunc (r *CreateRequest) checkParam() error {\r\n	if r.Username == "" {\r\n		return errno.New(errno.ErrValidation, nil).Add("username is empty.")\r\n	}\r\n\r\n	if r.Password == "" {\r\n		return errno.New(errno.ErrValidation, nil).Add("password is empty.")\r\n	}\r\n\r\n	return nil\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["例子通过 ",(0,s.jsx)(r.code,{children:"Encrypt()"})," 对密码进行加密："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:"// Encrypt the user password.\r\nfunc (u *UserModel) Encrypt() (err error) {\r\n    u.Password, err = auth.Encrypt(u.Password)\r\n    return\r\n}      \n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"Encrypt()"})," 函数引用 ",(0,s.jsx)(r.code,{children:"auth.Encrypt()"})," 来进行密码加密，具体实现见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/pkg/auth/auth.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/pkg/auth/auth.go"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["最后例子通过 ",(0,s.jsx)(r.code,{children:"u.Create()"})," 函数来向数据库中添加记录，ORM 用的是 ",(0,s.jsx)(r.code,{children:"gorm"}),"，",(0,s.jsx)(r.code,{children:"gorm"})," 详细用法请参考 ",(0,s.jsx)(r.a,{href:"/http:%E6%99%B0//gorm.io/zh_CN/docs/index.html",children:"GORM 指南"}),"。在 ",(0,s.jsx)(r.code,{children:"Create()"})," 函数中引用的数据库实例是 ",(0,s.jsx)(r.code,{children:"DB.Self"}),"，该实例在 API 启动之前已经完成初始化。",(0,s.jsx)(r.code,{children:"DB"})," 是个全局变量，可以直接引用。"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"在实际开发中，为了安全，数据库中是禁止保存密码的明文信息的，密码需要加密保存。"}),"\n",(0,s.jsxs)(r.p,{children:["笔者将接收和处理相关的 Go 结构体统一放在 ",(0,s.jsx)(r.code,{children:"handler/user/user.go"})," 文件中，这样可以使程序结构更清晰，功能更聚焦。当然每个人习惯不一样，读者根据自己的习惯放置即可。",(0,s.jsx)(r.code,{children:"handler/user/user.go"})," 对 ",(0,s.jsx)(r.code,{children:"UserInfo"})," 结构体的处理，也出于相同的目的。"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"删除用户",children:["删除用户",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#删除用户",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["删除用户代码详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/handler/user/delete.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/handler/user/delete.go"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["删除时，首先根据 URL 路径 ",(0,s.jsx)(r.code,{children:"DELETE http://127.0.0.1/v1/user/1"})," 解析出 id 的值 1，该 id 实际上就是数据库中的 id 索引，调用 ",(0,s.jsx)(r.code,{children:"model.DeleteUser()"})," 函数删除，函数详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/model/user.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/model/user.go"}),"。"]}),"\n",(0,s.jsxs)(r.h2,{id:"更新用户",children:["更新用户",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#更新用户",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["更新用户代码详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/handler/user/update.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/handler/user/update.go"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["更新用户逻辑跟创建用户差不多，在更新完数据库字段后，需要指定 gorm model 中的 id 字段的值，因为 gorm 在更新时默认是按照 id 来匹配记录的。通过解析 ",(0,s.jsx)(r.code,{children:"PUT http://127.0.0.1/v1/user/1"})," 来获取 id。"]}),"\n",(0,s.jsxs)(r.h2,{id:"查询用户列表",children:["查询用户列表",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#查询用户列表",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["查询用户列表代码详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/handler/user/list.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/handler/user/list.go"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["一般在 handler 中主要做解析参数、返回数据操作，简单的逻辑也可以在 handler 中做，像新增用户、删除用户、更新用户，代码量不大，所以也可以放在 handler 中。有些代码量很大的逻辑就不适合放在 handler 中，因为这样会导致 handler 逻辑不是很清晰，这时候实际处理的部分通常放在 ",(0,s.jsx)(r.code,{children:"service"})," 包中。比如本例的 ",(0,s.jsx)(r.code,{children:"LisUser()"})," 函数："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",children:'package user\r\n   \r\nimport (\r\n    "apiserver/service"\r\n    ...\r\n)  \r\n   \r\n// List list the users in the database.\r\nfunc List(c *gin.Context) {\r\n    ...\r\n    infos, count, err := service.ListUser(r.Username, r.Offset, r.Limit)\r\n    if err != nil {\r\n        SendResponse(c, err, nil)\r\n        return\r\n    }\r\n    ...\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["查询一个 REST 资源列表，通常需要做分页，如果不做分页返回的列表过多，会导致 API 响应很慢，前端体验也不好。本例中的查询函数做了分页，收到的请求中传入的 ",(0,s.jsx)(r.code,{children:"offset"})," 和 ",(0,s.jsx)(r.code,{children:"limit"})," 参数，分别对应于 MySQL 的 ",(0,s.jsx)(r.code,{children:"offset"})," 和 ",(0,s.jsx)(r.code,{children:"limit"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"service.ListUser()"})," 函数用来做具体的查询处理，代码详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/service/service.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/service/service.go"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["在 ",(0,s.jsx)(r.code,{children:"ListUser()"})," 函数中用了 ",(0,s.jsx)(r.code,{children:"sync"})," 包来做并行查询，以使响应延时更小。在实际开发中，查询数据后，通常需要对数据做一些处理，比如 ",(0,s.jsx)(r.code,{children:"ListUser()"})," 函数中会对每个用户记录返回一个 sayHello 字段。sayHello 只是简单输出了一个 ",(0,s.jsx)(r.code,{children:"Hello shortId"})," 字符串，其中 shortId 是通过 ",(0,s.jsx)(r.code,{children:"util.GenShortId()"})," 来生成的（",(0,s.jsx)(r.code,{children:"GenShortId"})," 实现详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/util/util.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/util/util.go"}),"）。像这类操作通常会增加 API 的响应延时，如果列表条目过多，列表中的每个记录都要做一些类似的逻辑处理，这会使得整个 API 延时很高，所以笔者在实际开发中通常会做并行处理。根据笔者经验，效果提升十分明显。"]}),"\n",(0,s.jsxs)(r.p,{children:["读者应该已经注意到了，在 ",(0,s.jsx)(r.code,{children:"ListUser()"})," 实现中，有 ",(0,s.jsx)(r.code,{children:"sync.Mutex"})," 和 ",(0,s.jsx)(r.code,{children:"IdMap"})," 等部分代码，使用 ",(0,s.jsx)(r.code,{children:"sync.Mutex"})," 是因为在并发处理中，更新同一个变量为了保证数据一致性，通常需要做锁处理。"]}),"\n",(0,s.jsxs)(r.p,{children:["使用 ",(0,s.jsx)(r.code,{children:"IdMap"})," 是因为查询的列表通常需要按时间顺序进行排序，一般数据库查询后的列表已经排过序了，但是为了减少延时，程序中用了并发，这时候会打乱排序，所以通过 ",(0,s.jsx)(r.code,{children:"IdMap"})," 来记录并发处理前的顺序，处理后再重新复位。"]}),"\n",(0,s.jsxs)(r.h2,{id:"获取指定用户的详细信息",children:["获取指定用户的详细信息",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#获取指定用户的详细信息",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["代码详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/handler/user/get.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/handler/user/get.go"}),"。"]}),"\n",(0,s.jsxs)(r.p,{children:["获取指定用户信息时，首先根据 URL 路径 ",(0,s.jsx)(r.code,{children:"GET http://127.0.0.1/v1/user/admin"})," 解析出 username 的值 admin，然后调用 ",(0,s.jsx)(r.code,{children:"model.GetUser()"})," 函数查询该用户的数据库记录并返回，函数详见 ",(0,s.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo07/model/user.go",target:"_blank",rel:"noopener noreferrer",children:"demo07/model/user.go"}),"。"]}),"\n",(0,s.jsxs)(r.h2,{id:"编译并运行",children:["编译并运行",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#编译并运行",children:"#"})]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"下载 apiserver_demos 源码包（如前面已经下载过，请忽略此步骤）"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"$ git clone https://github.com/lexkong/apiserver_demos\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"2",children:["\n",(0,s.jsxs)(r.li,{children:["将 ",(0,s.jsx)(r.code,{children:"apiserver_demos/demo07"})," 复制为 ",(0,s.jsx)(r.code,{children:"$GOPATH/src/apiserver"})]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"$ cp -a apiserver_demos/demo07/ $GOPATH/src/apiserver\n"})}),"\n",(0,s.jsxs)(r.ol,{start:"3",children:["\n",(0,s.jsx)(r.li,{children:"在 apiserver 目录下编译源码"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"$ cd $GOPATH/src/apiserver\r\n$ gofmt -w .\r\n$ go tool vet .\r\n$ go build -v .\n"})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"创建用户"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'$ curl -XPOST -H "Content-Type: application/json" http://127.0.0.1:8080/v1/user -d\'{"username":"kong","password":"kong123"}\'\r\n\r\n{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": {\r\n    "username": "kong"\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"查询用户列表"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'$ curl -XGET -H "Content-Type: application/json" http://127.0.0.1:8080/v1/user -d\'{"offset": 0, "limit": 20}\'\r\n\r\n{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": {\r\n    "totalCount": 2,\r\n    "userList": [\r\n      {\r\n        "id": 2,\r\n        "username": "kong",\r\n        "sayHello": "Hello qhXO5iIig",\r\n        "password": "$2a$10$vE9jG71oyzstWVwB/QfU3u00Pxb.ye8hFIDvnyw60nHBv/xsJZoUO",\r\n        "createdAt": "2018-06-02 14:47:54",\r\n        "updatedAt": "2018-06-02 14:47:54"\r\n      },\r\n      {\r\n        "id": 0,\r\n        "username": "admin",\r\n        "sayHello": "Hello qhXO5iSmgz",\r\n        "password": "$2a$10$veGcArz47VGj7l9xN7g2iuT9TF21jLI1YGXarGzvARNdnt4inC9PG",\r\n        "createdAt": "2018-05-28 00:25:33",\r\n        "updatedAt": "2018-05-28 00:25:33"\r\n      }\r\n    ]\r\n  }\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["可以看到，新增了一个用户 ",(0,s.jsx)(r.code,{children:"kong"}),"，数据库 id 索引为 ",(0,s.jsx)(r.code,{children:"2"}),"。",(0,s.jsx)(r.code,{children:"admin"})," 用户是上一节中初始化数据库时初始化的。"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"笔者建议在 API 设计时，对资源列表进行分页。"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"获取用户详细信息"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'$ curl -XGET -H "Content-Type: application/json" http://127.0.0.1:8080/v1/user/kong\r\n\r\n{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": {\r\n    "username": "kong",\r\n    "password": "$2a$10$vE9jG71oyzstWVwB/QfU3u00Pxb.ye8hFIDvnyw60nHBv/xsJZoUO"\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"更新用户"})}),"\n",(0,s.jsxs)(r.p,{children:["在 ",(0,s.jsx)(r.strong,{children:"查询用户列表"})," 部分，会返回用户的数据库索引。例如，用户 ",(0,s.jsx)(r.code,{children:"kong"})," 的数据库 id 索引是 ",(0,s.jsx)(r.code,{children:"2"}),"，所以这里调用如下 URL 更新 ",(0,s.jsx)(r.code,{children:"kong"})," 用户："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'$ curl -XPUT -H "Content-Type: application/json" http://127.0.0.1:8080/v1/user/2 -d\'{"username":"kong","password":"kongmodify"}\'\r\n\r\n{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": null\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["获取 ",(0,s.jsx)(r.code,{children:"kong"})," 用户信息："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'$ curl -XGET -H "Content-Type: application/json" http://127.0.0.1:8080/v1/user/kong\r\n\r\n{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": {\r\n    "username": "kong",\r\n    "password": "$2a$10$E0kwtmtLZbwW/bDQ8qI8e.eHPqhQOW9tvjwpyo/p05f/f4Qvr3OmS"\r\n  }\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["可以看到密码已经改变（旧密码为 ",(0,s.jsx)(r.code,{children:"$2a$10$vE9jG71oyzstWVwB/QfU3u00Pxb.ye8hFIDvnyw60nHBv/xsJZoUO"}),"）。"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)(r.strong,{children:"删除用户"})}),"\n",(0,s.jsxs)(r.p,{children:["在 ",(0,s.jsx)(r.strong,{children:"查询用户列表"})," 部分，会返回用户的数据库索引。例如，用户 ",(0,s.jsx)(r.code,{children:"kong"})," 的数据库 id 索引是 ",(0,s.jsx)(r.code,{children:"2"}),"，所以这里调用如下 URL 删除 ",(0,s.jsx)(r.code,{children:"kong"})," 用户："]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'$ curl -XDELETE -H "Content-Type: application/json" http://127.0.0.1:8080/v1/user/2\r\n\r\n{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": null\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"获取用户列表："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'$ curl -XGET -H "Content-Type: application/json" http://127.0.0.1:8080/v1/user -d\'{"offset": 0, "limit": 20}\'\r\n\r\n{\r\n  "code": 0,\r\n  "message": "OK",\r\n  "data": {\r\n    "totalCount": 1,\r\n    "userList": [\r\n      {\r\n        "id": 0,\r\n        "username": "admin",\r\n        "sayHello": "Hello EnqntiSig",\r\n        "password": "$2a$10$veGcArz47VGj7l9xN7g2iuT9TF21jLI1YGXarGzvARNdnt4inC9PG",\r\n        "createdAt": "2018-05-28 00:25:33",\r\n        "updatedAt": "2018-05-28 00:25:33"\r\n      }\r\n    ]\r\n  }\r\n}\n'})}),"\n",(0,s.jsxs)(r.p,{children:["可以看到用户 ",(0,s.jsx)(r.code,{children:"kong"})," 未出现在用户列表中，说明他已被成功删除。"]}),"\n",(0,s.jsxs)(r.h2,{id:"小结",children:["小结",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"本小节通过对用户增删改查和查询列表的操作，介绍了实际开发中如何对 REST 资源进行操作，并结合笔者的实际开发经验给出了一些开发习惯和建议。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,d.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Go%20%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84%20RESTful%20API%20%E6%9C%8D%E5%8A%A1%2F11%E5%9F%BA%E7%A1%80%208%EF%BC%9A%E7%94%A8%E6%88%B7%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86.md"]={toc:[{text:"本节核心内容",id:"本节核心内容",depth:2},{text:"配置路由信息",id:"配置路由信息",depth:2},{text:"注册新的错误码",id:"注册新的错误码",depth:2},{text:"新增用户",id:"新增用户",depth:2},{text:"删除用户",id:"删除用户",depth:2},{text:"更新用户",id:"更新用户",depth:2},{text:"查询用户列表",id:"查询用户列表",depth:2},{text:"获取指定用户的详细信息",id:"获取指定用户的详细信息",depth:2},{text:"编译并运行",id:"编译并运行",depth:2},{text:"小结",id:"小结",depth:2}],title:"11基础 8：用户业务逻辑处理",headingTitle:"11基础 8：用户业务逻辑处理",frontmatter:{}}}}]);