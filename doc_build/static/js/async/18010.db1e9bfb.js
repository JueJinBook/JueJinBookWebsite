"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18010"],{597457:function(e,r,d){d.r(r),d.d(r,{default:()=>h});var n=d(552676),l=d(740453);function c(e){let r=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",pre:"pre",code:"code",h4:"h4"},(0,l.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.h1,{id:"24拓展-3拾遗补漏--再谈分布式锁",children:["24拓展 3：拾遗补漏 —— 再谈分布式锁",(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#24拓展-3拾遗补漏--再谈分布式锁",children:"#"})]}),"\n",(0,n.jsx)(r.p,{children:"在第三节，我们细致讲解了分布式锁的原理，它的使用非常简单，一条指令就可以完成加锁操作。不过在集群环境下，这种方式是有缺陷的，它不是绝对安全的。"}),"\n",(0,n.jsx)(r.p,{children:"比如在 Sentinel 集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。"}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.img,{src:"https://user-gold-cdn.xitu.io/2018/7/16/164a15b65d4cd15a?w=738&h=313&f=png&s=29799",alt:""})}),"\n",(0,n.jsx)(r.p,{children:"不过这种不安全也仅仅是在主从发生 failover 的情况下才会产生，而且持续时间极短，业务系统多数情况下可以容忍。"}),"\n",(0,n.jsxs)(r.h2,{id:"redlock-算法",children:["Redlock 算法",(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#redlock-算法",children:"#"})]}),"\n",(0,n.jsx)(r.p,{children:"为了解决这个问题，Antirez 发明了 Redlock 算法，它的流程比较复杂，不过已经有了很多开源的 library 做了良好的封装，用户可以拿来即用，比如 redlock-py。"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-py",children:'import redlock\n\naddrs = [{\n    "host": "localhost",\n    "port": 6379,\n    "db": 0\n}, {\n    "host": "localhost",\n    "port": 6479,\n    "db": 0\n}, {\n    "host": "localhost",\n    "port": 6579,\n    "db": 0\n}]\ndlm = redlock.Redlock(addrs)\nsuccess = dlm.lock("user-lck-laoqian", 5000)\nif success:\n    print \'lock success\'\n    dlm.unlock(\'user-lck-laoqian\')\nelse:\n    print \'lock failed\'\n'})}),"\n",(0,n.jsx)(r.p,{children:"为了使用 Redlock，需要提供多个 Redis 实例，这些实例之前相互独立没有主从关系。同很多分布式算法一样，redlock 也使用「大多数机制」。"}),"\n",(0,n.jsxs)(r.p,{children:["加锁时，它会向过半节点发送 ",(0,n.jsx)(r.code,{children:"set(key, value, nx=True, ex=xxx)"})," 指令，只要过半节点 ",(0,n.jsx)(r.code,{children:"set"})," 成功，那就认为加锁成功。释放锁时，需要向所有节点发送 ",(0,n.jsx)(r.code,{children:"del"})," 指令。不过 Redlock 算法还需要考虑出错重试、时钟漂移等很多细节问题，同时因为 Redlock 需要向多个节点进行读写，意味着相比单实例 Redis 性能会下降一些。"]}),"\n",(0,n.jsxs)(r.h2,{id:"redlock-使用场景",children:["Redlock 使用场景",(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#redlock-使用场景",children:"#"})]}),"\n",(0,n.jsx)(r.p,{children:"如果你很在乎高可用性，希望挂了一台 redis 完全不受影响，那就应该考虑 redlock。不过代价也是有的，需要更多的 redis 实例，性能也下降了，代码上还需要引入额外的 library，运维上也需要特殊对待，这些都是需要考虑的成本，使用前请再三斟酌。"}),"\n",(0,n.jsxs)(r.h2,{id:"扩展阅读",children:["扩展阅读",(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"})]}),"\n",(0,n.jsxs)(r.h4,{id:"1-你以为-redlock-算法真的很完美",children:["1. ",(0,n.jsx)(r.a,{href:"http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html",target:"_blank",rel:"noopener noreferrer",children:"你以为 Redlock 算法真的很完美？"}),(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1-你以为-redlock-算法真的很完美",children:"#"})]}),"\n",(0,n.jsxs)(r.h4,{id:"2-redlock-py-的作者其人趣事",children:["2. Redlock-py 的作者其人趣事",(0,n.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2-redlock-py-的作者其人趣事",children:"#"})]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.img,{src:"https://user-gold-cdn.xitu.io/2018/7/16/164a1a0f66dcffb2?w=211&h=211&f=jpeg&s=8166",alt:""})}),"\n",(0,n.jsxs)(r.p,{children:["看头像非常酷，这位老哥的 Github 地址是 ",(0,n.jsx)(r.a,{href:"https://github.com/optimuspaul",target:"_blank",rel:"noopener noreferrer",children:(0,n.jsx)(r.a,{href:"https://github.com/optimuspaul",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/optimuspaul"})})]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,l.ah)(),e.components);return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}let h=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F24%E6%8B%93%E5%B1%95%203%EF%BC%9A%E6%8B%BE%E9%81%97%E8%A1%A5%E6%BC%8F%20%E2%80%94%E2%80%94%20%E5%86%8D%E8%B0%88%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md"]={toc:[{text:"Redlock 算法",id:"redlock-算法",depth:2},{text:"Redlock 使用场景",id:"redlock-使用场景",depth:2},{text:"扩展阅读",id:"扩展阅读",depth:2},{text:"1. 你以为 Redlock 算法真的很完美？",id:"1-你以为-redlock-算法真的很完美",depth:4},{text:"2. Redlock-py 的作者其人趣事",id:"2-redlock-py-的作者其人趣事",depth:4}],title:"24拓展 3：拾遗补漏 —— 再谈分布式锁",headingTitle:"24拓展 3：拾遗补漏 —— 再谈分布式锁",frontmatter:{}}}}]);