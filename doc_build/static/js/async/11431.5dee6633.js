"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11431"],{656371:function(n,e,r){r.r(e),r.d(e,{default:()=>c});var l=r(552676),s=r(740453);function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",ul:"ul",h2:"h2",pre:"pre",code:"code",strong:"strong",blockquote:"blockquote",h3:"h3"},(0,s.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.h1,{id:"第32章反射二当反射遇到结构体",children:["第32章—反射二｜当反射遇到结构体",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第32章反射二当反射遇到结构体",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"\uFEFF在上一讲中，介绍了 Go 语言反射的基本使用和三个定律。本讲继续深入探讨反射的更多用法，具体包含以下内容："}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["使用反射访问结构体","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"获取结构体成员信息"}),"\n",(0,l.jsx)(e.li,{children:"修改结构体成员的值"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.li,{children:"使用反射调用函数"}),"\n",(0,l.jsx)(e.li,{children:"使用反射创建实例"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"本讲内容不少，闲话不多说，我们直奔主题。"}),"\n",(0,l.jsxs)(e.h2,{id:"使用反射访问结构体",children:["使用反射访问结构体",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用反射访问结构体",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"反射能从普通变量中获取类型和值信息，对于结构体来说亦可获取其成员的类型和值。此外，还能获取结构体成员的个数、标签的值。为了讲解方便，我们先定义一个示例结构体，具体如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'type Person struct {\r\n   Name   string `display:"名字"`\r\n   age    int    `display:"年龄"`\r\n   gender int    `display:"性别"`\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"这个名为 Person 的结构体包含 3 个成员，分别是 string 类型的 Name、int 类型的 age 和 gender。每个成员都包含名为 display 的标签，用于解释它们的含义。"}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.code,{children:"\uD83D\uDCA1 提示：在 Person 中，Name 时大写开头，表示可从外部访问。只有这样的成员，其值才能被修改。"})}),"\n",(0,l.jsx)(e.p,{children:"在讨论其成员前，我们不妨先看看下面这段代码会产生怎样的运行结果："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   personExample := Person{Name: "小明", age: 18, gender: 1}\r\n   fmt.Println(reflect.TypeOf(personExample).Name())\r\n   fmt.Println(reflect.TypeOf(personExample).Kind())\r\n}\n'})}),"\n",(0,l.jsxs)(e.p,{children:["实际上，这段代码是在考察大家对上一讲关于“",(0,l.jsx)(e.strong,{children:"类型"}),"”和“",(0,l.jsx)(e.strong,{children:"种类"}),"”的理解。",(0,l.jsx)(e.strong,{children:"所有 Person 类型的变量，其类型名都是 Person；从分类上讲，所有 Person 类型的变量都属于结构体分类（struct）"}),"。所以，上述代码的运行结果为："]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Person"}),"\n",(0,l.jsx)(e.p,{children:"struct"}),"\n"]}),"\n",(0,l.jsxs)(e.h3,{id:"获取结构体成员信息",children:["获取结构体成员信息",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#获取结构体成员信息",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["结构体中的成员，在英语中通常被称为“Field”。Go 语言提供了",(0,l.jsx)(e.strong,{children:"获取成员个数"}),"和",(0,l.jsx)(e.strong,{children:"属性信息"}),"的方法，它们",(0,l.jsx)(e.strong,{children:"通过 reflect.Type 类型调用"}),"。较为常用的有以下两个方法："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"// 获取成员个数\r\nNumField()\r\n// 获取成员属性信息\r\nField()\n"})}),"\n",(0,l.jsx)(e.p,{children:"将上述两个方法结合使用，可以解读任何一个结构体的全部成员信息。写法也较为通用，具体如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   personExample := Person{Name: "小明", age: 18, gender: 1}\r\n   typeOfPersonExample := reflect.TypeOf(personExample)\r\n   for i := 0; i < typeOfPersonExample.NumField(); i++ {\r\n      fmt.Println(typeOfPersonExample.Field(i).Name,\r\n         typeOfPersonExample.Field(i).Type,\r\n      )\r\n}\n'})}),"\n",(0,l.jsxs)(e.p,{children:["这段代码中使用 for 循环遍历所有的成员，结束循环则以成员个数为条件，因此在循环体内不会发生下标越界的错误。typeOfPersonExample.Field() 方法包含了某个成员的属性信息，",(0,l.jsx)(e.strong,{children:"类型是 StructField"}),"。"]}),"\n",(0,l.jsx)(e.p,{children:"运行代码后，控制台将输出："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"Name string"}),"\n",(0,l.jsx)(e.p,{children:"age int"}),"\n",(0,l.jsx)(e.p,{children:"gender int"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["显然，成员的",(0,l.jsx)(e.strong,{children:"名称"}),"和类型一览无余。"]}),"\n",(0,l.jsxs)(e.p,{children:["细心的朋友还会发现，StructField 还提供了其它的信息，其中有名为 Tag 的，它是不是对应着",(0,l.jsx)(e.strong,{children:"标签"}),"呢？答案是肯定的。“实践是检验真理的唯一标准”，我们不妨尝试输出 Tag 的值。将本例的输出语句改为："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"fmt.Println(typeOfPersonExample.Field(i).Name,\r\n   typeOfPersonExample.Field(i).Type,\r\n   typeOfPersonExample.Field(i).Tag,\r\n)\n"})}),"\n",(0,l.jsx)(e.p,{children:"再次运行程序，可以看到控制台如下输出："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:'Name string display:"名字"'}),"\n",(0,l.jsx)(e.p,{children:'age int display:"年龄"'}),"\n",(0,l.jsx)(e.p,{children:'gender int display:"性别"'}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"很显然，输出了完整的标签的内容。"}),"\n",(0,l.jsxs)(e.p,{children:["随着标签的获取，问题也随之而来。",(0,l.jsx)(e.strong,{children:"结构体成员的标签允许多个同时存在"}),"，怎样获取某个特定标签的值呢？如果没有某个标签，该怎样处理呢？"]}),"\n",(0,l.jsxs)(e.p,{children:["要解答这个问题，就要看看获取来的 Tag 是怎样的数据结构了。经过研究可以发现，",(0,l.jsx)(e.strong,{children:"Tag 的值是 StructTag 类型"}),"。对于该类型，对外开放了 2 个方法。",(0,l.jsx)(e.strong,{children:"一个是 Get()，即直接获取某个标签的值；还有一个是 Lookup()，即查找某个标签。对于前者，直接返回 string 类型的值；对于后者则返回 string 类型的值和 bool 类型的值，查找结果。"})]}),"\n",(0,l.jsx)(e.p,{children:"对于本例而言，若要精准获取名为 display 的标签的值，方法如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   personExample := Person{Name: "小明", age: 18, gender: 1}\r\n   typeOfPersonExample := reflect.TypeOf(personExample)\r\n   for i := 0; i < typeOfPersonExample.NumField(); i++ {\r\n      fmt.Println(typeOfPersonExample.Field(i).Tag.Get("display"))\r\n   }\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"运行后，可以看到控制台如下输出："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"名字"}),"\n",(0,l.jsx)(e.p,{children:"年龄"}),"\n",(0,l.jsx)(e.p,{children:"性别"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.code,{children:"\uD83D\uDCA1 提示：标签实际上也是 Key-Value 的键值对结构，较为良好的编码习惯是在直接获取值之前先判断是否存在对应的键。幸运的是，Get() 方法的内部实现就是调用了 Lookup() 方法，在键不存在时返回空字符串（ Lookup() 方法在检测不到对应的键时的返回结果）。如此一来，开发者直接调用 Get() 方法即可。"})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.code,{children:"❗️ 注意：标签的内容也是区分大小写的，若将上例中的“display”改为“Display”，则得不到任何标签结果输出。"})}),"\n",(0,l.jsx)(e.p,{children:"说完成员的类型、标签的值的获取，接下来便是获取和修改成员的值了。"}),"\n",(0,l.jsx)(e.p,{children:"值的获取和类型的获取方法很类似，只需将获取类型改为获取值就可以了。具体代码如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   personExample := Person{Name: "小明", age: 18, gender: 1}\r\n   valueOfPersonExample := reflect.ValueOf(personExample)\r\n   for i := 0; i < valueOfPersonExample.NumField(); i++ {\r\n      fmt.Println(valueOfPersonExample.Field(i))\r\n   }\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"运行后，控制台将输出："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"小明"}),"\n",(0,l.jsx)(e.p,{children:"18"}),"\n",(0,l.jsx)(e.p,{children:"1"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"最后，无论是获取类型还是获取值，可以直接调用 FieldByName() 方法精准地获取某个成员的值。下面的代码演示了直接获取本例中 valueOfPersonExample 变量中 Name 成员的值。"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   personExample := Person{Name: "小明", age: 18, gender: 1}\r\n   valueOfPersonExample := reflect.ValueOf(personExample)\r\n   fmt.Println(valueOfPersonExample.FieldByName("Name"))\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"运行后，控制台将输出“小明”字样。"}),"\n",(0,l.jsxs)(e.p,{children:["最后，如果我们想使用反射来修改某个成员的值，也要确保",(0,l.jsx)(e.strong,{children:"被修改的操作对象必须是可修改的"}),"。另外还必须是",(0,l.jsx)(e.strong,{children:"可从外部访问的（即成员名开头是大写字母）"}),"。对于本例而言，只有 Name 成员可被修改。下面的代码演示了如何将“小明”改为“小红”。"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   personExample := &Person{Name: "小明", age: 18, gender: 1}\r\n   valueOfPersonExample := reflect.ValueOf(personExample).Elem()\r\n   valueOfPersonExample.FieldByName("Name").SetString("小红")\r\n   fmt.Println(valueOfPersonExample.FieldByName("Name"))\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"程序运行后，可以观察到控制台将输出“小红”字样。"}),"\n",(0,l.jsxs)(e.h2,{id:"使用反射调用函数",children:["使用反射调用函数",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用反射调用函数",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["在 Go 语言中通过反射调用函数，首先要明确一个概念：",(0,l.jsx)(e.strong,{children:"函数也可当作变量使用"}),"。"]}),"\n",(0,l.jsx)(e.p,{children:"比如：现有一个函数，名为 addCalc()，需要两个 int 参数 num1 和 num2。运行结果就是这两个数的相加和。完整的函数如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func addCalc(num1 int, num2 int) int {\r\n   return num1 + num2\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"当我们尝试使用下面的反射方法来获取 addCalc() 函数的类型："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   addCalcType := reflect.TypeOf(addCalc)\r\n   fmt.Println(addCalcType.Kind())\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"将得到这样的结果："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"func"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["从结果上看，",(0,l.jsx)(e.strong,{children:"函数类型被归为了“func”种类"}),"。"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.code,{children:"\uD83D\uDCA1 提示：凭借种类获取的结果（“func”），我们可以判断传入的参数是否为函数。"})}),"\n",(0,l.jsx)(e.p,{children:"接着，addCalc() 函数需要两个参数，通过 Value 类型的切片数据构建参数列表，具体如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"addCalcParam := []reflect.Value{reflect.ValueOf(20), reflect.ValueOf(200)}\n"})}),"\n",(0,l.jsxs)(e.p,{children:["最后，",(0,l.jsx)(e.strong,{children:"reflect.Value 类型提供了 Call() 方法，用于调用函数"}),"。该方法",(0,l.jsx)(e.strong,{children:"仅适用于函数"}),"，对普通变量或结构体不适用。该方法执行后，也将",(0,l.jsx)(e.strong,{children:"返回 Value 类型的切片数据，包含着函数运行后的返回结果"}),"。"]}),"\n",(0,l.jsx)(e.p,{children:"对于本例而言，则要首先获取 addCalc() 函数的值（reflect.Value）变量，在通过该变量调用 Call() 方法，传入 addCalcParam，最后即可从该方法结果中获取函数执行的返回值了。完整代码如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   addCalcValue := reflect.ValueOf(addCalc)\r\n   addCalcParam := []reflect.Value{reflect.ValueOf(20), reflect.ValueOf(200)}\r\n   results := addCalcValue.Call(addCalcParam)\r\n   fmt.Println(results[0])\r\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"运行后，控制台输出如下："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"220"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"使用反射创建实例",children:["使用反射创建实例",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用反射创建实例",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["通过反射创建实例，通常",(0,l.jsx)(e.strong,{children:"用于创建一个与已知变量同类型的变量"}),"。如此创建的",(0,l.jsx)(e.strong,{children:"变量类型只有在程序运行时才会被确定，更加灵活多变"}),"。"]}),"\n",(0,l.jsx)(e.p,{children:"举例来说，现有一个变量 num，它的类型是自定义的 myInt 类型。我们若想创建与其相同类型的变量，方法如下："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-go",children:"type myInt int\r\nfunc main() {\r\n   var num myInt = 100\r\n   typeOfNum := reflect.TypeOf(num)\r\n   anotherNum := reflect.New(typeOfNum)\r\n   anotherNum.Elem().SetInt(300)\r\n   fmt.Println(num)\r\n   fmt.Println(anotherNum.Type(), anotherNum.Type().Kind())\r\n   fmt.Println(anotherNum.Elem().Int())\r\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:["使用反射创建变量，核心在于 ",(0,l.jsx)(e.strong,{children:"reflect.New() 函数。该函数接收 reflect.Type 类型参数，返回 reflect.Value 类型值"}),"。该值是一个指针，本例中的 anotherNum 类型实际上是 *main.myInt，从种类上讲是 ptr。"]}),"\n",(0,l.jsx)(e.p,{children:"运行这段代码，控制台输出如下："}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"100"}),"\n",(0,l.jsx)(e.p,{children:"*main.myInt ptr"}),"\n",(0,l.jsx)(e.p,{children:"300"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"小结",children:["小结",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,l.jsx)(e.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsxs)(e.li,{children:["使用反射访问结构体","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"获取结构体成员信息"}),"\n",(0,l.jsx)(e.li,{children:"修改结构体成员的值"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(e.li,{children:"使用反射调用函数"}),"\n",(0,l.jsx)(e.li,{children:"使用反射创建实例"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["本讲继续深入探讨 Go 反射的使用。首先是",(0,l.jsx)(e.strong,{children:"访问结构体"}),"和结构体成员的",(0,l.jsx)(e.strong,{children:"属性信息"}),"（",(0,l.jsx)(e.strong,{children:"成员个数、类型、标签及单个标签值的获取"}),"）、",(0,l.jsx)(e.strong,{children:"值以及修改成员的值"}),"。"]}),"\n",(0,l.jsxs)(e.p,{children:["接下来介绍了如何使用反射调用函数，这里有个重要的思想：",(0,l.jsx)(e.strong,{children:"Go 语言中的函数也可以当作变量使用"}),"。这一点有点类似 JavaScript，或者是 TypeScript。"]}),"\n",(0,l.jsxs)(e.p,{children:["看到这，相信不少朋友会问：上述技术的",(0,l.jsx)(e.strong,{children:"实际应用场景"}),"是什么呢？"]}),"\n",(0,l.jsx)(e.p,{children:"诚然，反射在实际开发中用到的并不是很广泛。但若使用得当，将起到事半功倍之作用。比如标签的获取，就是 json 解析包的实现的基础。又如：我们可以定义若干结构体，对应数据库的表结构。然后使用反射进行一次编码，即可批量创建全部数据表等等。"}),"\n",(0,l.jsx)(e.p,{children:"随着 Go 使用日益增多，需求各异，像 Nirvana 这类 Http 框架内部就用到了反射调用函数。当然，说到“框架”，最好是基础全学完，再上手的东西了。"}),"\n",(0,l.jsxs)(e.p,{children:["最后介绍的是使用反射创建已知类型的实例。这样的创建方式使得",(0,l.jsx)(e.strong,{children:"变量的类型在程序运行时固定"}),"，而非编译时。为构建灵活、多变的程序逻辑提供了更多可能。可以通过不同的条件分支，对相同变量赋不同类型的数据。"]}),"\n",(0,l.jsx)(e.p,{children:"➡️ 在下次课程中，我们会收尾 Go 语言中反射的专题，同时也带来了理解难度最大的部分。具体内容如下："}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"控制反转与依赖注入"}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(i,{...n})}):i(n)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC32%E7%AB%A0%E2%80%94%E5%8F%8D%E5%B0%84%E4%BA%8C%EF%BD%9C%E5%BD%93%E5%8F%8D%E5%B0%84%E9%81%87%E5%88%B0%E7%BB%93%E6%9E%84%E4%BD%93.md"]={toc:[{text:"使用反射访问结构体",id:"使用反射访问结构体",depth:2},{text:"获取结构体成员信息",id:"获取结构体成员信息",depth:3},{text:"使用反射调用函数",id:"使用反射调用函数",depth:2},{text:"使用反射创建实例",id:"使用反射创建实例",depth:2},{text:"小结",id:"小结",depth:2}],title:"第32章—反射二｜当反射遇到结构体",headingTitle:"第32章—反射二｜当反射遇到结构体",frontmatter:{}}}}]);