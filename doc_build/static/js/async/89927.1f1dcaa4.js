"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["89927"],{445865:function(e,n,c){c.r(n),c.d(n,{default:()=>ed});var r=c(552676),s=c(740453);let a=c.p+"static/image/32cdbf27d3abb97a7a03ac5950a6c6be.33a9ec1d.webp",i=c.p+"static/image/3404e0827953d3a2756df18b7c19998c.8da1234e.webp",t=c.p+"static/image/733aa5398c9dfa3f3d39053f8b2e56ae.7a11708f.webp",d=c.p+"static/image/2d9f369004ce3e7a2681da179a9f9158.2656cd4f.webp",p=c.p+"static/image/78e1797d7f48dc22153ec3853eb141bf.2e8bb6c2.webp",l=c.p+"static/image/bc9e48a1d2ab4b6c1fac02fb064ad070.508abf9f.webp",h=c.p+"static/image/8618c0768168433d9080c78c4c7f9d52.8f627fef.webp",o=c.p+"static/image/22e29259e49c748196808b4a0b620cab.191f01d2.webp",j=c.p+"static/image/c4103f56a8126954553a3487548ad33a.8a56a604.webp",x=c.p+"static/image/32ed7e911c9fb99f9c29c1fdbd80a2d7.35d86799.webp",f=c.p+"static/image/313be3af22d2ef31ff9fa79791e5f24d.205c819f.webp",b=c.p+"static/image/4c0ad0b03990a280dc72327da81eb907.36436f40.webp",m=c.p+"static/image/7f848d16581716beeb6e45203b2a6e6b.c8d10df0.webp",u=c.p+"static/image/789753d9ac1b019fcc2616ed6cbef4a7.fddf3ae8.webp",g=c.p+"static/image/74441d44217fcfb4c86f08f619ce2526.970660d5.webp",R=c.p+"static/image/1a602fcae7922102242f606a33173123.86b9075e.webp",A=c.p+"static/image/e3284868a2f8e4d3f747032769f42890.68c818f1.webp",v=c.p+"static/image/214641a415197f8cee4c7c57eca044e0.6e22efe0.webp",w=c.p+"static/image/b0f6459f32e548da079cdb8ca119243b.d20d43a0.webp",E=c.p+"static/image/eab76bd9cbd8381bbad0577dc24d510e.9b1588dd.webp",C=c.p+"static/image/da93ba8d2a3ac265f155c73c72e8fc2d.b5c94568.webp",N=c.p+"static/image/043ec54a95c9113ff3b04318ef2cd0ff.b5f54c8c.webp",S=c.p+"static/image/6f3bf1707df10945c84a783b6a1943d8.c21f557b.webp",H=c.p+"static/image/d654f7a4bdc483a4fcbf6af39abc8ba0.2926cddf.webp",T=c.p+"static/image/117cb687f5fd5b5a89600733d1be4996.f94a94b9.webp",k=c.p+"static/image/8a480d2f614835bdbfa224a14ab1ec7a.bec0d864.webp",M=c.p+"static/image/9cf06c9c33343f64742e5775e97c8d61.1efe641f.webp",O=c.p+"static/image/78e912e8393fd42bbfab5e496ed118d5.b0a44d72.webp",P=c.p+"static/image/2a89540403995fcab740ef069d4d5c48.3f45810d.webp",G=c.p+"static/image/56241c32a0cd49030797f9f5cb32a4dc.75d077f3.webp",I=c.p+"static/image/342cc10fba9bda67e50f815dd875ef17.98d995fe.webp",F=c.p+"static/image/7ff9080a295c2f948eb1ca63359f74d0.6c9f3219.webp",L=c.p+"static/image/e98caaced0f71489f56e38a309bd6416.004cfc46.webp",X=c.p+"static/image/791bddbf47221f1b0949b7724dd067b1.c63833a6.webp",y=c.p+"static/image/ab51b8e44cc4f70f3ca0cbf7159bedad.bd52b0d9.webp",B=c.p+"static/image/1e0d4ef9d8fe17c87965e119b378027e.429b614c.webp",q=c.p+"static/image/da63cfd3a1f945440630fd78726b734a.5ec7e97f.webp",J=c.p+"static/image/b51f2cc4e995acd73ca60eaeede3f2dc.fa08be93.webp",D=c.p+"static/image/b036513275ff7d3291de14d3b5eab0f6.4dcd0982.webp",W=c.p+"static/image/31a2862b0055521e120e282d931efce7.8d5c1ad3.webp",Y=c.p+"static/image/6a3a87f825cd959e84c10d96b04ab21f.0c3938b7.webp",K=c.p+"static/image/9ef056d448ba726bf8036a16afdb2965.fe0774f5.webp",V=c.p+"static/image/82606186c8aa2a881045aa734696bf30.31a46cbe.webp",Z=c.p+"static/image/681e71a6259881e4ca688fda9547c590.ba663395.webp",z=c.p+"static/image/70c59dcdeb7a0770f37931cdfd225131.a52a26bf.webp",Q=c.p+"static/image/03754e6dfe67b38766f0219fd8adfc1e.1d74e532.webp",U=c.p+"static/image/53a9d01e1ed21941a4a190ed9328021f.adb38322.webp",_=c.p+"static/image/2f166dc229dcbc078751d6dfa96e3b52.2ca76c05.webp",$=c.p+"static/image/9035f5f97a82a4e0574407c4225c0b1f.199f35d4.webp",ee=c.p+"static/image/fbfb3e0ebe0dbe188a6cc89d83ba0460.0fac21bb.webp",en=c.p+"static/image/7a7635b88ca9cc0164830cf734bff563.3b66352a.webp",ec=c.p+"static/image/91c0040bddc130e74f19c65d9b7e9dc7.c0ef4c51.webp",er=c.p+"static/image/110a28277f1d341b9f416c635d626595.efeb5145.webp",es=c.p+"static/image/1c6d4ee42611c3976d7914c8da8d8317.4e583685.webp",ea=c.p+"static/image/ef69c253d7a6da833502ccbb886ecd87.e55b72bf.webp";function ei(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2",h3:"h3",ul:"ul",li:"li",strong:"strong"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"第04章react组件如何写typescript类型",children:["第04章—React组件如何写TypeScript类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第04章react组件如何写typescript类型",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"\uFEFF现在写 React 组件都是基于 TypeScript，所以如何给组件写类型也是很重要的。"}),"\n",(0,r.jsx)(n.p,{children:"这节我们就来学下 React 组件如何写 TypeScript 类型。"}),"\n",(0,r.jsx)(n.p,{children:"用 cra 创建个项目："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npx create-react-app --template typescript react-ts\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:ea,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们平时用的类型在 @types/react 这个包里，cra 已经帮我们引入了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:es,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"jsx-的类型",children:["JSX 的类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#jsx-的类型",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 App.tsx 里开始练习 TypeScript 类型："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'interface AaaProps {\n  name: string;\n}\n\nfunction Aaa(props: AaaProps) {\n  return <div>aaa, {props.name}</div>\n}\n\nfunction App() {\n  return <div>\n    <Aaa name="guang"></Aaa>\n  </div>\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.p,{children:"其实组件我们一般不写返回值类型，就用默认推导出来的。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:er,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"React 函数组件默认返回值就是 JSX.Element。"}),"\n",(0,r.jsx)(n.p,{children:"我们看下 JSX.Element 的类型定义："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const content: JSX.Element = <div>aaa</div>\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:ec,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到它就是 React.ReactElement。"}),"\n",(0,r.jsx)(n.p,{children:"也就是说，如果你想描述一个 jsx 类型，就用 React.ReactElement 就好了。"}),"\n",(0,r.jsx)(n.p,{children:"比如 Aaa 组件有一个 content 的 props，类型为 ReactElement："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:en,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样就只能传入 JSX。"}),"\n",(0,r.jsx)(n.p,{children:"跑一下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run start\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:ee,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"ReactElement 就是 jsx 类型，但如果你传入 null、number 等就报错了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:$,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:_,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那如果有的时候就是 number、null 呢？"}),"\n",(0,r.jsx)(n.p,{children:"换成 ReactNode 就好了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:U,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"看下它的类型定义："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:Q,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"ReactNode 包含 ReactElement、或者 number、string、null、boolean 等可以写在 JSX 里的类型。"}),"\n",(0,r.jsx)(n.p,{children:"这三个类型的关系 ReactNode > ReactElement > JSX.Element。"}),"\n",(0,r.jsx)(n.p,{children:"所以，一般情况下，如果你想描述一个参数接收 JSX 类型，就用 ReactNode 就行。"}),"\n",(0,r.jsxs)(n.h2,{id:"函数组件的类型",children:["函数组件的类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数组件的类型",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面的函数组件，我们都没明确定义类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:z,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"其实它的类型是 FunctionComponent："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:Z,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const Aaa: React.FunctionComponent<AaaProps> = (props) => {\n  return <div>aaa, {props.name}{props.content}</div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"看下它的类型定义："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:V,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，FC 和 FunctionComponent 等价，参数是 Props，返回值是 ReactNode。"}),"\n",(0,r.jsx)(n.p,{children:"而且函数组件还可以写几个可选属性，这些用到了再说。"}),"\n",(0,r.jsxs)(n.h2,{id:"hook-的类型",children:["hook 的类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hook-的类型",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来过一下 hook 的类型："}),"\n",(0,r.jsxs)(n.h3,{id:"usestate",children:["useState",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usestate",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"先从 useState 开始："}),"\n",(0,r.jsx)(n.p,{children:"一般用推导出的类型就行："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:K,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"也可以手动声明类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:Y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"useEffect 和 useLayoutEffect 这种没有类型参数的就不说了。"}),"\n",(0,r.jsxs)(n.h3,{id:"useref",children:["useRef",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useref",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"useRef 我们知道，可以保存 dom 引用或者其他内容。"}),"\n",(0,r.jsx)(n.p,{children:"所以它的类型也有两种。"}),"\n",(0,r.jsx)(n.p,{children:"保存 dom 引用的时候，参数需要传个 null："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:W,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"不然会报错："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而保存别的内容的时候，不能传 null，不然也会报错，说是 current 只读："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:J,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:q,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"为什么呢？"}),"\n",(0,r.jsx)(n.p,{children:"看下类型就知道了："}),"\n",(0,r.jsx)(n.p,{children:"当你传入 null 的时候，返回的是  RefObject，它的 current 是只读的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:B,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这很合理，因为保存的 dom 引用肯定不能改呀。"}),"\n",(0,r.jsx)(n.p,{children:"而不传 null 的时候，返回的 MutableRefObject，它的 current 就可以改了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:X,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:L,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"因为 ref 既可以保存 dom 引用，又可以保存其他数据，而保存 dom 引用又要加上 readonly，所以才用 null 做了个区分。"}),"\n",(0,r.jsx)(n.p,{children:"传 null 就是 dom 引用，返回 RefObject，不传就是其他数据，返回 MutableRefObject。"}),"\n",(0,r.jsx)(n.p,{children:"所以，这就是一种约定，知道传 null 和不传 null 的区别就行了。"}),"\n",(0,r.jsxs)(n.h3,{id:"useimperativehandle",children:["useImperativeHandle",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useimperativehandle",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们前面写过 forwardRef + useImperativeHandle 的例子，是这样的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useRef } from 'react';\nimport { useEffect } from 'react';\nimport React from 'react';\nimport { useImperativeHandle } from 'react';\n\ninterface GuangProps {\n  name: string;\n}\n\ninterface GuangRef {\n  aaa: () => void;\n}\n\nconst Guang: React.ForwardRefRenderFunction<GuangRef, GuangProps> = (props, ref) => {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useImperativeHandle(ref, () => {\n    return {\n      aaa() {\n        inputRef.current?.focus();\n      }\n    }\n  }, [inputRef]);\n\n  return <div>\n    <input ref={inputRef}></input>\n    <div>{props.name}</div>\n  </div>\n}\n\nconst WrapedGuang = React.forwardRef(Guang);\n\nfunction App() {\n  const ref = useRef<GuangRef>(null);\n \n  useEffect(()=> {\n    console.log('ref', ref.current)\n    ref.current?.aaa();\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <WrapedGuang name=\"guang\" ref={ref}/>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(n.p,{children:"forwardRef 包裹的组件会额外传入 ref 参数，所以它不是 FunctionComponent 类型，而是专门的 ForwardRefRenderFunction 类型。"}),"\n",(0,r.jsx)(n.p,{children:"它有两个类型参数，第一个是 ref 内容的类型，第二个是 props 的类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:F,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"其实 forwardRef 也是这两个类型参数，所以写在 forwardRef 上也行："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:I,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useRef } from 'react';\nimport { useEffect } from 'react';\nimport React from 'react';\nimport { useImperativeHandle } from 'react';\n\ninterface GuangProps {\n  name: string;\n}\n\ninterface GuangRef {\n  aaa: () => void;\n}\n\nconst WrapedGuang = React.forwardRef<GuangRef, GuangProps>((props, ref) => {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useImperativeHandle(ref, () => {\n    return {\n      aaa() {\n        inputRef.current?.focus();\n      }\n    }\n  }, [inputRef]);\n\n  return <div>\n    <input ref={inputRef}></input>\n    <div>{props.name}</div>\n  </div>\n});\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"useImperativeHanlde 可以有两个类型参数，一个是 ref 内容的类型，一个是 ref 内容扩展后的类型。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:G,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"useImperativeHanlde 传入的函数的返回值就要求满足第二个类型参数的类型"}),"\n",(0,r.jsx)(n.p,{children:"不过一般没必要写，因为传进来的 ref 就已经是有类型的了，直接用默认推导的就行。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"usereducer",children:["useReducer",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usereducer",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"useReducer 可以传一个类型参数也可以传两个："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:O,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:M,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当传一个的时候，是 Reducer<xx,yy> 类型，xx 是 state 的类型，yy 是 action 的类型。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当传了第二个的时候，就是传入的初始化函数参数的类型。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"其余-hook",children:["其余 hook",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其余-hook",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"剩下的 hook 的类型比较简单，我们快速过一遍："}),"\n",(0,r.jsx)(n.p,{children:"useCallback 的类型参数是传入的函数的类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:H,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"useMemo 的类型参数是传入的函数的返回值类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"useContext 的类型参数是 Context 内容的类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当然，这些都没必要手动声明，用默认推导的就行。"}),"\n",(0,r.jsx)(n.p,{children:"再就是 memo："}),"\n",(0,r.jsx)(n.p,{children:"它可以直接用包裹的函数组件的参数类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"也可以在类型参数里声明："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"参数类型",children:["参数类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参数类型",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"回过头来，我们再来看传入组件的 props 的类型。"}),"\n",(0,r.jsxs)(n.h3,{id:"propswithchildren",children:["PropsWithChildren",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#propswithchildren",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面讲过，jsx 类型用 ReactNode，比如这里的 content 参数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果你不想通过参数传入内容，可以在 children 里："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这时候就要声明 children 的类型为 ReactNode："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React, { ReactNode } from "react";\n\ninterface CccProps {\n  content: ReactNode,\n  children: ReactNode\n}\n\nfunction Ccc(props: CccProps) {\n  return <div>ccc,{props.content}{props.children}</div>\n}\n\nfunction App() {\n\n  return <div>\n    <Ccc content={<div>666</div>}>\n      <button>7777</button>\n    </Ccc>\n  </div>\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但其实没有必要自己写，传 children 这种情况太常见了，React 提供了相关类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"type CccProps = PropsWithChildren<{\n  content: ReactNode,\n}>\n"})}),"\n",(0,r.jsx)(n.p,{children:"看下它的类型定义："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"就是给 Props 加了一个 children 属性。"}),"\n",(0,r.jsxs)(n.h3,{id:"cssproperties",children:["CSSProperties",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#cssproperties",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"有时候组件可以通过 props 传入一些 css 的值，这时候怎么写类型呢？"}),"\n",(0,r.jsx)(n.p,{children:"用 CSSProperties。"}),"\n",(0,r.jsx)(n.p,{children:"比如加一个 color 参数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"或者加一个 styles 参数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，提示出了 css 的样式名，以及可用的值："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React, { CSSProperties, PropsWithChildren, ReactNode } from \"react\";\n\ntype CccProps = PropsWithChildren<{\n  content: ReactNode,\n  color: CSSProperties['color'],\n  styles: CSSProperties\n}>\n\n\nfunction Ccc(props: CccProps) {\n  return <div>ccc,{props.content}{props.children}</div>\n}\n\nfunction App() {\n\n  return <div>\n    <Ccc content={<div>666</div>} color=\"yellow\" styles={{\n      backgroundColor: 'blue'\n    }}>\n      <button>7777</button>\n    </Ccc>\n  </div>\n}\n\nexport default App;\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"htmlattributes",children:["HTMLAttributes",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#htmlattributes",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果你写的组件希望可以当成普通 html 标签一样用，也就是可以传很多 html 的属性作为参数呢？"}),"\n",(0,r.jsx)(n.p,{children:"那可以继承 HTMLAttributes："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"上图中可以看到，提示了很多 html 的属性。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React, { HTMLAttributes } from "react";\n\ninterface CccProps extends HTMLAttributes<HTMLDivElement>{\n\n    } \n\nfunction Ccc(props: CccProps) {\n  return <div>ccc</div>\n}\n\nfunction App() {\n\n  return <div>\n    <Ccc p>\n      <button>7777</button>\n    </Ccc>\n  </div>\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.p,{children:"那 HTMLAttributes 的类型参数是干嘛的呢？"}),"\n",(0,r.jsx)(n.p,{children:"是其中一些 onClick、onMouseMove 等事件处理函数的类型参数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当然，继承 HTMLAttributes 只有 html 通用属性，有些属性是某个标签特有的，这时候可以指定 FormHTMLAttributes、AnchorHTMLAttributes 等："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"比如 a 标签的属性，会有 href："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"componentprops",children:["ComponentProps",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#componentprops",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"继承 html 标签的属性，前面用的是 HTMLAttributes："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"其实也可以用 ComponentProps："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"效果一样。"}),"\n",(0,r.jsx)(n.p,{children:"ComponentProps 的类型参数是标签名，比如 a、div、form 这些。"}),"\n",(0,r.jsxs)(n.h2,{id:"eventhandler",children:["EventHandler",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#eventhandler",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"很多时候，组件需要传入一些事件处理函数，比如 clickHandler："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import React, { HTMLAttributes, MouseEventHandler } from "react";\n\ninterface CccProps {\n  clickHandler: MouseEventHandler\n} \n\nfunction Ccc(props: CccProps) {\n  return <div onClick={props.clickHandler}>ccc</div>\n}\n\nfunction App() {\n\n  return <div>\n    <Ccc clickHandler={(e) => {\n      console.log(e);\n    }}></Ccc>\n  </div>\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.p,{children:"这种参数就要用 xxxEventHandler 的类型，比如 MouseEventHandler、ChangeEventHandler 等，它的类型参数是元素的类型。"}),"\n",(0,r.jsx)(n.p,{children:"或者不用 XxxEventHandler，自己声明一个函数类型也可以："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"interface CccProps {\n  clickHandler: (e: MouseEvent<HTMLDivElement>) => void\n} \n"})}),"\n",(0,r.jsxs)(n.p,{children:["案例代码上传了",(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/react-ts",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们过了一遍写 React 组件会用到的类型："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ReactNode"}),"：JSX 的类型，一般用 ReactNode，但要知道 ReactNode、ReactElement、JSX.Element 的关系"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"FunctionComonent"}),"：也可以写 FC，第一个类型参数是 props 的类型"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useRef 的类型"}),"：传入 null 的时候返回的是 RefObj，current 属性只读，用来存 html 元素；不传 null 返回的是 MutableRefObj，current 属性可以修改，用来存普通对象。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ForwardRefRenderFunction"}),"：第一个类型参数是 ref 的类型，第二个类型参数是 props 的类型。forwardRef 和它类型参数一样，也可以写在 forwardRef 上"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"useReducer"}),"：第一个类型参数是 Reducer<data 类型, action 类型>，第二个类型参数是初始化函数的参数类型。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"PropsWithChildren"}),"：可以用来写有 children 的 props"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CSSProperties"}),"： css 样式对象的类型"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"HTMLAttributes"}),"：组件可以传入 html 标签的属性，也可以指定具体的 ButtonHTMLAttributes、AnchorHTMLAttributes。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ComponentProps"}),"：类型参数传入标签名，效果和 HTMLAttributes 一样"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"EventHandler"}),"：事件处理器的类型"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"后面写 React 组件的时候，会大量用到这些 typescript 的类型。"})]})}function et(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(ei,{...e})}):ei(e)}let ed=et;et.__RSPRESS_PAGE_META={},et.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC04%E7%AB%A0%E2%80%94React%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E5%86%99TypeScript%E7%B1%BB%E5%9E%8B.md"]={toc:[{text:"JSX 的类型",id:"jsx-的类型",depth:2},{text:"函数组件的类型",id:"函数组件的类型",depth:2},{text:"hook 的类型",id:"hook-的类型",depth:2},{text:"useState",id:"usestate",depth:3},{text:"useRef",id:"useref",depth:3},{text:"useImperativeHandle",id:"useimperativehandle",depth:3},{text:"useReducer",id:"usereducer",depth:3},{text:"其余 hook",id:"其余-hook",depth:3},{text:"参数类型",id:"参数类型",depth:2},{text:"PropsWithChildren",id:"propswithchildren",depth:3},{text:"CSSProperties",id:"cssproperties",depth:3},{text:"HTMLAttributes",id:"htmlattributes",depth:2},{text:"ComponentProps",id:"componentprops",depth:3},{text:"EventHandler",id:"eventhandler",depth:2},{text:"总结",id:"总结",depth:2}],title:"第04章—React组件如何写TypeScript类型",headingTitle:"第04章—React组件如何写TypeScript类型",frontmatter:{}}}}]);