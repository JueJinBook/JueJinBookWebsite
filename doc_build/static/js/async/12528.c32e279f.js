"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12528"],{232958:function(n,e,r){r.r(e),r.d(e,{default:()=>a});var i=r(552676),d=r(740453);function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ul:"ul",li:"li",h2:"h2",pre:"pre",code:"code",blockquote:"blockquote",h3:"h3"},(0,d.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"第15章结构体二构建有生命的对象",children:["第15章—结构体二｜构建有生命的对象",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第15章结构体二构建有生命的对象",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"\uFEFF在上一讲中，我们已经学习了Go语言中结构体、匿名结构体的定义和使用。并以创建游戏角色为例，演示了在真实开发环境中的应用。不过，关于结构体的故事还没有完结。"}),"\n",(0,i.jsxs)(e.p,{children:["请大家思考这样一个场景：在真实世界中，存在不同品种、不同毛色、不同体重、不同年龄以及其它不同特征的狗。每一只狗又能独自完成动作，比如吃饭、大叫、睡觉、奔跑等等。在大多数面向对象编程语言中，通常会",(0,i.jsx)(e.strong,{children:"使用“构造函数”来描述每一只狗的特征，使用“方法”来让某一只狗完成特定的动作。"})," 在Go语言中，则",(0,i.jsx)(e.strong,{children:"使用结构体来实现构造函数和方法"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:["从本质上说，Go语言的类型或结构体本身是没有构造函数功能的，但是我们可以",(0,i.jsx)(e.strong,{children:"使用结构体初始化的过程来模拟实现构造函数"}),"。从这一点上可以看出Go语言中的结构体使用起来是非常灵活、好用的。"]}),"\n",(0,i.jsx)(e.p,{children:"接下来，本讲将以“狗的特征和动作”为例，向大家讲述如何使用结构体来实现："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"面向对象语言中的构造函数；"}),"\n",(0,i.jsx)(e.li,{children:"面向对象语言中的方法。"}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"构建独一无二的对象构造函数",children:["构建独一无二的对象——构造函数",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#构建独一无二的对象构造函数",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"显然，标题中所说的“对象”，就是本例中的小狗了。依照惯例，我依然尽量简化代码，让各位更好地理解语言本身。"}),"\n",(0,i.jsx)(e.p,{children:"本例使用品种（string）、年龄(int)、体重(float)、性别(int)这四个特征来创建“狗”对象，根据我们现有的知识，若要使用结构体来描述，其代码实现类似如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:"type Dog struct {\r\n   Breed  string\r\n   Age    int\r\n   Weight float64\r\n   Gender string\r\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"既然说，构造函数是通过使用结构体初始化的过程来模拟实现的，我们不妨编写一个函数，将狗的四个特征作为参数传入其中，并最终返回Dog类型的变量。如此一来，一旦这个函数被调用后，便会生成一个独一无二的Dog类型变量。代码示例如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:"func NewDog(breed string, age int, weight float64, gender string) *Dog {\r\n   return &Dog{\r\n      Breed:  breed,\r\n      Age:    age,\r\n      Weight: weight,\r\n      Gender: gender,\r\n   }\r\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"类似NewDog()这样的函数，其作用与面向对象语言中的构造函数类似。如此，我们便使用结构体实现了Go语言中并未原生支持的构造函数。"}),"\n",(0,i.jsx)(e.p,{children:"构造函数在使用时非常简单，我们只需声明一个变量，并通过调用NewDog()函数为其赋值即可。比如下面这段完整的代码，就创建了两只胖瘦不同柴犬："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'type Dog struct {\r\n   Breed  string\r\n   Age    int\r\n   Weight float64\r\n   Gender string\r\n}\r\n\r\nfunc NewDog(breed string, age int, weight float64, gender string) *Dog {\r\n   return &Dog{\r\n      Breed:  breed,\r\n      Age:    age,\r\n      Weight: weight,\r\n      Gender: gender,\r\n   }\r\n}\r\n\r\nfunc main() {\r\n   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")\r\n   weakShibaInu := NewDog("Shiba Inu", 2, 7.0, "公")\r\n   fmt.Println(fatShibaInu)\r\n   fmt.Println(weakShibaInu)\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"运行本例，控制台将输出："}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:'&{Shiba Inu 2 12 "公"}'}),"\n",(0,i.jsx)(e.p,{children:'&{Shiba Inu 2 7 "公"}'}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"请大家关注代码的结构以及main()函数中的调用方式。为了讲解方便，我把结构体、相应的构造函数和main()函数放到了一起。一种更好的做法是将它们分开放到两个Go源码文件中，那样做会使代码结构更清晰、更有条理，日后维护起来就会更轻松了。"}),"\n",(0,i.jsx)(e.p,{children:"相信不少朋友可能会有疑问：使用构造函数，和直接创建结构体，似乎没有什么区别。就拿fatShibaInu变量来说吧，下面两种写法都能达到目的。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"使用构造函数："}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"不使用用构造函数："}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'fatShibaInu2 := &Dog{\r\n   Breed:  "Shiba Inu",\r\n   Age:    2,\r\n   Weight: 12.0,\r\n   Gender: "公",\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"乍看上去还真是一样，但我们考虑一种情况——使用多国语言。"}),"\n",(0,i.jsx)(e.p,{children:"像年龄和体重倒没关系，关键是品种和性别。就拿性别来说吧，当使用“公”来赋值时，只有懂汉语的人能看懂。所以更多时候我们使用0和1分别代表公和母，这样就屏蔽了语言不同造成的理解上的困难。"}),"\n",(0,i.jsx)(e.p,{children:"所以，我们就非常迫切地需要在赋值和取值过程中进行一个“转换”处理。在赋值时将不同语言中表达性别的文字转换成0或1，并在取值时反向转换。"}),"\n",(0,i.jsx)(e.p,{children:"因此，我们修改Dog的结构体和构造函数如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'type Dog struct {\r\n   Breed  string\r\n   Age    int\r\n   Weight float64\r\n   Gender int\r\n}\r\n\r\nfunc NewDog(breed string, age int, weight float64, gender string) *Dog {\r\n   genderValue := 0\r\n   if gender == "公" {\r\n      genderValue = 0\r\n   } else if gender == "母" {\r\n      genderValue = 1\r\n   }\r\n   return &Dog{\r\n      Breed:  breed,\r\n      Age:    age,\r\n      Weight: weight,\r\n      Gender: genderValue,\r\n   }\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"如此修改后，NewDog()函数内部完成了对gender参数的转换，尽管传入的是汉字，但最终创建Dog变量时用的却是数字。main()函数中创建fatShibaInu变量无需做任何修改，依然使用汉字来表示性别即可。"}),"\n",(0,i.jsx)(e.p,{children:"反观直接创建结构体的方式，就只能传入0和1了："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'fatShibaInu := &Dog{\r\n   Breed:  "Shiba Inu",\r\n   Age:    2,\r\n   Weight: 12.0,\r\n   Gender: 0,\r\n}\n'})}),"\n",(0,i.jsxs)(e.h2,{id:"让对象动起来",children:["让对象“动起来”",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#让对象动起来",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"获取静态指标",children:["获取“静态指标”",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#获取静态指标",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"经过上述一番修改，再次运行本例，控制台的输出就变为："}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"&{Shiba Inu 2 12 0}"}),"\n",(0,i.jsx)(e.p,{children:"&{Shiba Inu 2 7 0}"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"最后的“0”，表示的就是性别了。显然，这是不好理解的，我们需要再做一个“转换”，将0和1转换为汉字的“公”和“母”。为了完成这个转换，我们需要定义“方法”。"}),"\n",(0,i.jsxs)(e.p,{children:["在Go语言中，方法和函数的定义格式非常像，大家可不要搞混了。由于方法和对象存在紧密的关系，因此在定义的格式上需要",(0,i.jsx)(e.strong,{children:"接收器"}),"，具体格式如下："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:"func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {\r\n\xa0\xa0\xa0 函数体\r\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["其中，",(0,i.jsx)(e.strong,{children:"接收器变量和接收器类型共同构成了接收器"}),"；参数列表是可选的；返回参数也是可选的；方法名无需多做解释。"]}),"\n",(0,i.jsx)(e.p,{children:"对应到本例，我们就可以创建一个名为getGender()的方法，接收器就是Dog类型的指针，无需任何参数，返回值则是string类型的表示性别的汉字。代码示例如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'func (d *Dog) GetGender() string {\r\n   if d.Gender == 0 {\r\n      return "公"\r\n   } else if d.Gender == 1 {\r\n      return "母"\r\n   }\r\n   return ""\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"GetGender()通过fatShibaInu变量来调用，具体如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:"fmt.Println(fatShibaInu.GetGender())\n"})}),"\n",(0,i.jsx)(e.p,{children:"运行后，可以看到控制台中会输出："}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"公"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"再论接收器",children:["再论接收器",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#再论接收器",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"为对象定义方法时，需要注意接收器的类型。使用指针与否，将决定了是否对原始变量产生影响。本例使用了*Dog，即指针类型，在方法中对该类型变量（d变量）的任何影响都将影响原始变量（fatShibaInu）；反之，若使用Dog类型，则不会影响。"}),"\n",(0,i.jsx)(e.p,{children:"其原因是当不使用指针类型变量时，方法中的接收器变量实际上是对原始数据的“拷贝”，所做出的改变也仅仅会作用于这份“拷贝”的数据上，并不会影响到原始数据。"}),"\n",(0,i.jsx)(e.p,{children:"对比来说，我们分别定义两个不同的方法——GrowUp()和GrowUp2()，前者使用指针类型接收器，后者不使用。方法体均是对相应变量中的年龄属性自增1，然后在控制台输出运行结果。测试代码关键部分如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'func (d *Dog) GrowUp() {\r\n   d.Age++\r\n}\r\n\r\nfunc (d Dog) GrowUp2() {\r\n   d.Age++\r\n}\r\n\r\nfunc main() {\r\n   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")\r\n\r\n   fatShibaInu.GrowUp()\r\n   fmt.Println(fatShibaInu)\r\n\r\n   fatShibaInu.GrowUp2()\r\n   fmt.Println(fatShibaInu)\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"运行结果为："}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"&{Shiba Inu 3 12 0}"}),"\n",(0,i.jsx)(e.p,{children:"&{Shiba Inu 3 12 0}"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"显然，虽然GrowUp2()方法也对d变量中的Age属性做了自增1计算，但并未影响原始数据。"}),"\n",(0,i.jsxs)(e.h3,{id:"让对象动起来-1",children:["让对象“动起来”",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#让对象动起来-1",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"到此，我们已经掌握了如何使用结构体实现构造函数和方法。接下来到了该让对象“动起来”的时候了。"}),"\n",(0,i.jsx)(e.p,{children:"之前，我们已经声明了两个Dog类型的变量——fatShibaInu和weakShibaInu。要知道一只体重正常的成年雄性柴犬大概在9公斤左右。所以fatShibaInu过重了，要多运动来减肥；weakShibaInu太轻了，要多补充营养。那么，多运动和补营养便是它们接下来的动作了。"}),"\n",(0,i.jsx)(e.p,{children:"所以，我们不妨继续实现两个方法：一个叫做Sport()，每次执行后，体重都减0.1KG；另一个叫做Eat()，每次执行后，体重增加0.1KG。同时，向控制台输出具体的动作内容。代码如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'func (d *Dog) Sport() {\r\n   fmt.Println("做运动！")\r\n   d.Weight -= 0.1\r\n   fmt.Println("我减重到了", d.Weight)\r\n}\r\n\r\nfunc (d *Dog) Eat() {\r\n   fmt.Println("多吃饭！")\r\n   d.Weight += 0.1\r\n   fmt.Println("我增重到了", d.Weight)\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"接着，让fatShibaInu执行Sport()方法；让weakShibaInu执行Eat()方法："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")\r\n   weakShibaInu := NewDog("Shiba Inu", 2, 7.0, "公")\r\n   fatShibaInu.Sport()\r\n   weakShibaInu.Eat()\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"再次运行程序，可以看到控制台如下输出："}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"做运动！"}),"\n",(0,i.jsx)(e.p,{children:"我减重到了 11.9"}),"\n",(0,i.jsx)(e.p,{children:"多吃饭！"}),"\n",(0,i.jsx)(e.p,{children:"我增重到了 7.1"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"长此以往，这两只柴犬都能回到正常的体重了。要注意的是，在写代码的时候请务必让每只狗做正确的事情，不要让该运动的柴犬继续吃吃吃，也不要让该补充食物的柴犬做锻炼。"}),"\n",(0,i.jsxs)(e.h2,{id:"总结",children:["总结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,i.jsx)(e.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,i.jsx)(e.p,{children:"使用结构体实现："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"面向对象语言中的构造函数；"}),"\n",(0,i.jsx)(e.li,{children:"面向对象语言中的方法。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"本讲是结构体系列专题的第二篇，得益于Go语言设计的灵活，我们只需要结构体就能实现面向对象语言中的构造函数和方法了。"}),"\n",(0,i.jsx)(e.p,{children:"说到构造函数，其关键点要掌握如何使用结构体初始化的过程来模拟实现。同时，还要明白这样做和直接创建结构体的区别和优势。"}),"\n",(0,i.jsx)(e.p,{children:"说到方法，首先要掌握的就是定义方法的格式。其次还要明白接收器的概念以及不同类型对原始数据的影响。"}),"\n",(0,i.jsx)(e.p,{children:"➡️ 在下次课程中，我们会介绍Go语言结构体的最后一部分知识，具体内容是："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"使用结构体实现继承"}),"\n"]})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}let a=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC15%E7%AB%A0%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C%EF%BD%9C%E6%9E%84%E5%BB%BA%E6%9C%89%E7%94%9F%E5%91%BD%E7%9A%84%E5%AF%B9%E8%B1%A1.md"]={toc:[{text:"构建独一无二的对象——构造函数",id:"构建独一无二的对象构造函数",depth:2},{text:"让对象“动起来”",id:"让对象动起来",depth:2},{text:"获取“静态指标”",id:"获取静态指标",depth:3},{text:"再论接收器",id:"再论接收器",depth:3},{text:"让对象“动起来”",id:"让对象动起来-1",depth:3},{text:"总结",id:"总结",depth:2}],title:"第15章—结构体二｜构建有生命的对象",headingTitle:"第15章—结构体二｜构建有生命的对象",frontmatter:{}}}}]);