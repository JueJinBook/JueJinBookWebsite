"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["26548"],{704174:function(e,s,n){e.exports=n.p+"static/image/05fe13cd2d8464a8b668cd26d9b0840a.b5119a48.webp"},131554:function(e,s,n){n.r(s),n.d(s,{default:()=>A});var i=n(552676),r=n(740453);let c=n.p+"static/image/c6c454562fce4be62437e63503166854.5378506f.webp",d=n.p+"static/image/d761bbef2ef0ec8678721a1820377322.287a319d.webp",l=n.p+"static/image/149358aad5797db46edcfbc4e505f529.5524903f.webp",t=n.p+"static/image/bc52a6b0a34b9d492c19f479f9315fe6.af5c2c9d.webp",o=n.p+"static/image/fb52c4508ee9b4830adb54363b38472f.094c9a36.webp",a=n.p+"static/image/5d4e49692d176b6d6b4cc0d8c9e633ee.d89f6bfd.webp",p=n.p+"static/image/4e0b0f9c3c43c27511670af943f79a55.bf30ab10.webp",h=n.p+"static/image/4ea7dddb8ce5e1edab5d9db4e8d36a51.22a8f606.webp",j=n.p+"static/image/4bdad28c88de85f7b0ecb1b8a4eb2ed4.b86bc0be.webp",x=n.p+"static/image/71fe3890dcfdb6a50ba7ccae11c57b10.7fac2114.webp";var g=n(704174);let m=n.p+"static/image/0899a5fc202059e1f7ba11b0c1d6e78b.3f40114b.webp",S=n.p+"static/image/82d0ea49e9b636b956523858144f3ea5.ac823458.webp",f=n.p+"static/image/9a856eebffbf26f705d3f8160ee51980.efe85ab5.webp",u=n.p+"static/image/e373e82b63eeb62b2a8403e485246ea4.87da4336.webp",b=n.p+"static/image/8fdb51d24c9938143b30b287e863c3ea.74b3df4e.webp",v=n.p+"static/image/3543a4cdc6f9d072671f10def13e2f25.4521ca79.webp";function k(e){let s=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",ul:"ul",li:"li",h2:"h2"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.h1,{id:"81-基于-redis-实现分布式-session",children:["81. 基于 Redis 实现分布式 session",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#81-基于-redis-实现分布式-session",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"前面我们学习了登录鉴权的两种方式 session 和 jwt。"}),"\n",(0,i.jsx)(s.p,{children:"session 是在服务端保存用户数据，然后通过 cookie 返回 sessionId。cookie 在每次请求的时候会自动带上，服务端就能根据 sessionId 找到对应的 session，拿到用户的数据"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:v,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"而 jwt 是把所有的用户数据保存在加密后的 token 里返回，客户端只要在 authorization 的 header 里带上 token，服务端就能从中解析出用户数据。"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:b,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"jwt 天然是支持分布式的，比如有两个服务器的时候，任何一个服务器都能从 token 出拿到用户数据："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:u,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"但是 session 的方式不行，它的数据是存在单台服务器的内存的，如果再请求另一台服务器就找不到对应的 session 了："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:f,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"那如何让 session 支持分布式环境呢？"}),"\n",(0,i.jsx)(s.p,{children:"一种方式就是做 session 的同步，在多台服务器之间复制 session。"}),"\n",(0,i.jsx)(s.p,{children:"另一种方式就是自己基于 redis 实现一个分布式 session 了。"}),"\n",(0,i.jsx)(s.p,{children:"这节我们就来实现一下。"}),"\n",(0,i.jsx)(s.p,{children:"首先我们来分析下思路："}),"\n",(0,i.jsx)(s.p,{children:"分布式 session 就是在多台服务器都可以访问到同一个 session。"}),"\n",(0,i.jsx)(s.p,{children:"我们可以在 redis 里存储它："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:S,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"用户第一次请求的时候，生成一个随机 id，以它作为 key，存储的对象作为 value 放到 redis 里。"}),"\n",(0,i.jsx)(s.p,{children:"之后携带 cookie 的时候，根据其中的 sid 来取 redis 中的值，注入 handler。"}),"\n",(0,i.jsx)(s.p,{children:"修改 session 之后再设置到 redis 里。"}),"\n",(0,i.jsx)(s.p,{children:"这样就完成了 session 的创建、保存、修改。"}),"\n",(0,i.jsx)(s.p,{children:"我们具体实现下："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"nest new redis-session-test -p npm\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:m,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"创建 nest 项目。"}),"\n",(0,i.jsx)(s.p,{children:"安装 redis 的包："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"npm install --save redis\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后创建个 redis 模块："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"nest g module redis\nnest g service redis\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:g,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"在 RedisModule 创建连接 redis 的 provider，导出 RedisService，并把这个模块标记为 @Global 模块"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-javascript",children:"import { Global, Module } from '@nestjs/common';\nimport { createClient } from 'redis';\nimport { RedisService } from './redis.service';\n\n@Global()\n@Module({\n  providers: [\n    RedisService,\n    {\n      provide: 'REDIS_CLIENT',\n      async useFactory() {\n        const client = createClient({\n            socket: {\n                host: 'localhost',\n                port: 6379\n            }\n        });\n        await client.connect();\n        return client;\n      }\n    }\n  ],\n  exports: [RedisService]\n})\nexport class RedisModule {}\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后在 RedisService 里注入 REDIS_CLIENT，并封装一些方法："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-javascript",children:"import { Inject, Injectable } from '@nestjs/common';\nimport { RedisClientType } from 'redis';\n\n@Injectable()\nexport class RedisService {\n\n    @Inject('REDIS_CLIENT') \n    private redisClient: RedisClientType;\n\n    async hashGet(key: string) {\n        return await this.redisClient.hGetAll(key);\n    }\n\n    async hashSet(key: string, obj: Record<string, any>, ttl?: number) {\n        for(let name in obj) {\n            await this.redisClient.hSet(key, name, obj[name]);\n        }\n\n        if(ttl) {\n            await this.redisClient.expire(key, ttl);\n        }\n    }\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"因为我们要操作的是对象结构，比较适合使用 hash。"}),"\n",(0,i.jsx)(s.p,{children:"redis 的 hash 有这些方法："}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HSET key field value"}),"： 设置指定哈希表 key 中字段 field 的值为 value。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HGET key field"}),"：获取指定哈希表 key 中字段 field 的值。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HMSET key field1 value1 field2 value2 ..."}),"：同时设置多个字段的值到哈希表 key 中。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HMGET key field1 field2 ..."}),"：同时获取多个字段的值从哈希表 key 中。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HGETALL key"}),"：获取哈希表 key 中所有字段和值。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HDEL key field1 field2 ..."}),"：删除哈希表 key 中一个或多个字段。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HEXISTS key field"}),"：检查哈希表 key 中是否存在字段 field。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HKEYS key"}),"：获取哈希表 key 中的所有字段。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HVALUES key"}),"：获取哈希表 key 中所有的值。\n-",(0,i.jsx)(s.code,{children:"HLEN key"}),"：获取哈希表 key 中字段的数量。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HINCRBY key field increment"}),"：将哈希表 key 中字段 field 的值增加 increment。"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"HSETNX key field value"}),"：只在字段 field 不存在时，设置其值为 value。"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"这里我们就用到 hGetAll 和 hSet 方法，再就是用 expire 设置 key 的过期时间。"}),"\n",(0,i.jsx)(s.p,{children:"这里的 Record<string, any> 是对象类型的意思。"}),"\n",(0,i.jsx)(s.p,{children:"然后再封装个 SessionModule："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"nest g module session\nnest g service session --no-spec\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:x,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"导出 SessionService，并且设置 SessionModule 为 Global："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-javascript",children:"import { Global, Module } from '@nestjs/common';\nimport { SessionService } from './session.service';\n\n@Global()\n@Module({\n  providers: [SessionService],\n  exports: [SessionService]\n})\nexport class SessionModule {}\n\n"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:j,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"然后实现 SessionService："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-javascript",children:"import { Inject, Injectable } from '@nestjs/common';\nimport { RedisService } from 'src/redis/redis.service';\n\n@Injectable()\nexport class SessionService {\n\n    @Inject(RedisService)\n    private redisService: RedisService;\n\n    async setSession(sid: string, value: Record<string, any>, ttl: number = 30 * 60) {\n        if(!sid) {\n            sid = this.generateSid();\n        }\n        await this.redisService.hashSet(`sid_${sid}`, value, ttl);\n        return sid;\n    }\n\n    async getSession(sid: string) {\n        return await this.redisService.hashGet(`sid_${sid}`);\n    }\n\n    generateSid() {\n        return Math.random().toString().slice(2,12);\n    }\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"setSession 就是用 sid_xx 的 key 在 redis 里创建 string 的数据结构。"}),"\n",(0,i.jsx)(s.p,{children:"getSession 是用 sid_xx 从 redis 取值。"}),"\n",(0,i.jsx)(s.p,{children:"generateSid 是生成随机的 session id"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:h,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"setSession 的时候如果没有传入 sid，则随机生成一个，并返回 sid。"}),"\n",(0,i.jsx)(s.p,{children:"我们在 AppController 添加个方法测试下："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-javascript",children:"@Inject(SessionService)\nprivate sessionService: SessionService;\n\n@Get('count')\nasync count(@Req() req: Request, @Res() res: Response) {\n    const sid = req.cookies?.sid;\n\n    const session = await this.sessionService.getSession(sid);\n\n}\n\n"})}),"\n",(0,i.jsx)(s.p,{children:"这里用到 cookie，需要安装 cookie-parser 的包："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"npm install --save cookie-parser\n"})}),"\n",(0,i.jsx)(s.p,{children:"在 main.ts 里启用："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:p,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"现在 getSession 返回的是 Record<string, any> 也就是对象类型，但并不知道有啥具体的属性。"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"所以我们改造下 getSession 的类型声明加个重载："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"async getSession<SessionType extends Record<string,any>>(sid: string): Promise<SessionType>;\nasync getSession(sid: string) {\n    return await this.redisService.hashGet(`sid_${sid}`);\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"这样再用的时候，当不传类型参数，返回的是默认类型 Record<string, any>："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:o,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"传入类型参数之后，返回的就是该类型了："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"为什么这里是 string 呢？"}),"\n",(0,i.jsx)(s.p,{children:"因为 redis 虽然可以存整数、浮点数，但是它会转为 string 来存，所以取到的是 string，需要自己转换一下。"}),"\n",(0,i.jsx)(s.p,{children:"我们实现下计数逻辑："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-javascript",children:"@Inject(SessionService)\nprivate sessionService: SessionService;\n\n@Get('count')\nasync count(@Req() req: Request, @Res({ passthrough: true}) res: Response) {\n    const sid = req.cookies?.sid;\n\n    const session = await this.sessionService.getSession<{count: string}>(sid);\n\n    const curCount = session.count ? parseInt(session.count) + 1 : 1;\n    const curSid = await this.sessionService.setSession(sid, {\n      count: curCount\n    });\n\n    res.cookie('sid', curSid, { maxAge: 1800000 });\n    return curCount;\n}\n"})}),"\n",(0,i.jsx)(s.p,{children:"先根据 cookie 的 sid 调用 getSession 取 session。"}),"\n",(0,i.jsx)(s.p,{children:"拿到的如果有 count，就 + 1 之后放回去，没有就设置 1"}),"\n",(0,i.jsx)(s.p,{children:"然后 setSession 更新 session。"}),"\n",(0,i.jsx)(s.p,{children:"在 cookie 中返回 sid。"}),"\n",(0,i.jsx)(s.p,{children:"默认用了 @Res 传入 response 之后就需要手动返回响应了，比如 res.end('xxx')，如果还是想让 nest 把返回值作为响应，就加个 passthrough: true。"}),"\n",(0,i.jsx)(s.p,{children:"我们测试下："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,i.jsx)(s.p,{children:"我们自己实现的 session 就生效了："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"在 Redis Insight 里可以看到 session 的值"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:d,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"而且这个 session 是支持分布式的。"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)("img",{src:c,alt:""})}),"\n",(0,i.jsx)(s.p,{children:"我们用 nginx 做网关层，使用轮询的负载均衡策略，那请求可能到任何一台服务器上。"}),"\n",(0,i.jsx)(s.p,{children:"如果是之前的 session，当前机器没有对应的 session 对象，就拿不到登录状态。"}),"\n",(0,i.jsx)(s.p,{children:"而现在基于 redis 存储的 session，不管请求到了哪台服务器，都能从 redis 中取出对应的 session 从而拿到登录状态、用户数据。"}),"\n",(0,i.jsx)(s.p,{children:"这就是分布式 session。"}),"\n",(0,i.jsxs)(s.p,{children:["案例代码在",(0,i.jsx)(s.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/redis-session-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,i.jsxs)(s.h2,{id:"总结",children:["总结",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"session 是在服务端内存存储会话数据，通过 cookie 中的 session id 关联。"}),"\n",(0,i.jsx)(s.p,{children:"但它不支持分布式，换台机器就不行了。"}),"\n",(0,i.jsx)(s.p,{children:"jwt 是在客户端存储会话数据，所以天然支持分布式。"}),"\n",(0,i.jsx)(s.p,{children:"我们通过 redis 自己实现了分布式的 session。"}),"\n",(0,i.jsx)(s.p,{children:"我们使用的是 hash 的数据结构，封装了 RedisModule 来操作 Redis。"}),"\n",(0,i.jsx)(s.p,{children:"又封装了 SessionModule 来读写 redis 中的 session，以 sid_xxx 为 key。"}),"\n",(0,i.jsx)(s.p,{children:"之后在 ctronller 里就可以读取和设置 session 了，用起来和内置的传统 session 差不多。但是它是支持分布式的。"}),"\n",(0,i.jsx)(s.p,{children:"如果你想在分布式场景下用 session，就自己基于 redis 实现一个吧。"})]})}function w(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,r.ah)(),e.components);return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(k,{...e})}):k(e)}let A=w;w.__RSPRESS_PAGE_META={},w.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F81.%20%E5%9F%BA%E4%BA%8E%20Redis%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%20session.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"81. 基于 Redis 实现分布式 session",headingTitle:"81. 基于 Redis 实现分布式 session",frontmatter:{}}}}]);