"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["36030"],{445708:function(e,n,i){i.r(n),i.d(n,{default:()=>d});var s=i(552676),l=i(740453);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",strong:"strong"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"17原理-7开源节流--小对象压缩",children:["17原理 7：开源节流 —— 小对象压缩",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17原理-7开源节流--小对象压缩",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Redis 是一个非常耗费内存的数据库，它所有的数据都放在内存里。如果我们不注意节约使用内存，Redis 就会因为我们的无节制使用出现内存不足而崩溃。Redis 作者为了优化数据结构的内存占用，也苦心孤诣增加了非常多的优化点，这些优化也是以牺牲代码的可读性为代价的，但是毫无疑问这是非常值得的，尤其像 Redis 这种数据库。"}),"\n",(0,s.jsxs)(n.h2,{id:"32bit-vs-64bit",children:["32bit vs 64bit",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32bit-vs-64bit",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Redis 如果使用 32bit 进行编译，内部所有数据结构所使用的指针空间占用会少一半，如果你对 Redis 使用内存不超过 4G，可以考虑使用 32bit 进行编译，可以节约大量内存。4G 的容量作为一些小型站点的缓存数据库是绰绰有余了，如果不足还可以通过增加实例的方式来解决。"}),"\n",(0,s.jsxs)(n.h2,{id:"小对象压缩存储-ziplist",children:["小对象压缩存储 (ziplist)",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小对象压缩存储-ziplist",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"如果 Redis 内部管理的集合数据结构很小，它会使用紧凑存储形式压缩存储。"}),"\n",(0,s.jsx)(n.p,{children:"这就好比 HashMap 本来是二维结构，但是如果内部元素比较少，使用二维结构反而浪费空间，还不如使用一维数组进行存储，需要查找时，因为元素少进行遍历也很快，甚至可以比 HashMap 本身的查找还要快。比如下面我们可以使用数组来模拟 HashMap 的增删改操作。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class ArrayMap<K, V> {\n\n  private List<K> keys = new ArrayList<>();\n  private List<V> values = new ArrayList<>();\n\n  public V put(K k, V v) {\n    for (int i = 0; i < keys.size(); i++) {\n      if (keys.get(i).equals(k)) {\n        V oldv = values.get(i);\n        values.set(i, v);\n        return oldv;\n      }\n    }\n    keys.add(k);\n    values.add(v);\n    return null;\n  }\n\n  public V get(K k) {\n    for (int i = 0; i < keys.size(); i++) {\n      if (keys.get(i).equals(k)) {\n        return values.get(i);\n      }\n    }\n    return null;\n  }\n\n  public V delete(K k) {\n    for (int i = 0; i < keys.size(); i++) {\n      if (keys.get(i).equals(k)) {\n        keys.remove(i);\n        return values.remove(i);\n      }\n    }\n    return null;\n  }\n\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Redis 的 ziplist 是一个紧凑的字节数组结构，如下图所示，每个元素之间都是紧挨着的。我们不用过于关心 ",(0,s.jsx)(n.code,{children:"zlbytes/zltail"})," 和 ",(0,s.jsx)(n.code,{children:"zlend"})," 的含义，稍微了解一下就好。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/10/16481f85c83f803e?w=844&h=309&f=png&s=29412",alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果它存储的是 hash 结构，那么 key 和 value 会作为两个 entry 相邻存在一起。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'127.0.0.1:6379> hset hello a 1\n(integer) 1\n127.0.0.1:6379> hset hello b 2\n(integer) 1\n127.0.0.1:6379> hset hello c 3\n(integer) 1\n127.0.0.1:6379> object encoding hello\n"ziplist"\n'})}),"\n",(0,s.jsx)(n.p,{children:"如果它存储的是 zset，那么 value 和 score 会作为两个 entry 相邻存在一起。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'127.0.0.1:6379> zadd world 1 a\n(integer) 1\n127.0.0.1:6379> zadd world 2 b\n(integer) 1\n127.0.0.1:6379> zadd world 3 c\n(integer) 1\n127.0.0.1:6379> object encoding world\n"ziplist"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["关于压缩列表更多细节，请阅读第34节",(0,s.jsx)(n.a,{href:"https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5c95226fb9a04fa42fc3f6",target:"_blank",rel:"noopener noreferrer",children:"《极度深寒 —— 探索「列表」内部结构》"}),"和第35节",(0,s.jsx)(n.a,{href:"https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5d3ec0f265da0f91561c33",target:"_blank",rel:"noopener noreferrer",children:"《极度深寒 —— 探索「紧凑列表」内部》"})]}),"\n",(0,s.jsxs)(n.p,{children:["Redis 的 ",(0,s.jsx)(n.code,{children:"intset"})," 是一个紧凑的整数数组结构，它用于存放元素都是整数的并且元素个数较少的 set 集合。"]}),"\n",(0,s.jsx)(n.p,{children:"如果整数可以用 uint16 表示，那么 intset 的元素就是 16 位的数组，如果新加入的整数超过了 uint16 的表示范围，那么就使用 uint32 表示，如果新加入的元素超过了 uint32 的表示范围，那么就使用 uint64 表示，Redis 支持 set 集合动态从 uint16 升级到 uint32，再升级到 uint64。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/10/16481f959cf105bc?w=742&h=207&f=png&s=16520",alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'127.0.0.1:6379> sadd hello 1 2 3\n(integer) 3\n127.0.0.1:6379> object encoding hello\n"intset"\n'})}),"\n",(0,s.jsx)(n.p,{children:"如果 set 里存储的是字符串，那么 sadd 立即升级为 hashtable 结构。还记得 Java 的 HashSet 么，它内部是使用 HashMap 实现的。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'127.0.0.1:6379> sadd hello yes no\n(integer) 2\n127.0.0.1:6379> object encoding hello\n"hashtable"\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"存储界限"}),"\n当集合对象的元素不断增加，或者某个 value 值过大，这种小对象存储也会被升级为标准结构。Redis 规定在小对象存储结构的限制条件如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"hash-max-ziplist-entries 512  # hash 的元素个数超过 512 就必须用标准结构存储\nhash-max-ziplist-value 64  # hash 的任意元素的 key/value 的长度超过 64 就必须用标准结构存储\nlist-max-ziplist-entries 512  # list 的元素个数超过 512 就必须用标准结构存储\nlist-max-ziplist-value 64  # list 的任意元素的长度超过 64 就必须用标准结构存储\nzset-max-ziplist-entries 128  # zset 的元素个数超过 128 就必须用标准结构存储\nzset-max-ziplist-value 64  # zset 的任意元素的长度超过 64 就必须用标准结构存储\nset-max-intset-entries 512  # set 的整数元素个数超过 512 就必须用标准结构存储\n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来我们做一个小实验，看看这里的界限是不是真的起到作用了。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'import redis\nclient = redis.StrictRedis()\nclient.delete("hello")\nfor i in range(512):\n    client.hset("hello", str(i), str(i))\nprint client.object("encoding", "hello")  # 获取对象的存储结构\nclient.hset("hello", "512", "512")\nprint client.object("encoding", "hello") # 再次获取对象的存储结构\n'})}),"\n",(0,s.jsx)(n.p,{children:"输出："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ziplist\nhashtable\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看出来当 hash 结构的元素个数超过 512 的时候，存储结构就发生了变化。"}),"\n",(0,s.jsx)(n.p,{children:"接下来我们再试试递增 value 的长度，在 Python 里面对字符串乘以一个整数 n 相当于重复 n 次。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'import redis\nclient = redis.StrictRedis()\nclient.delete("hello")\nfor i in range(64):\n    client.hset("hello", str(i), "0" * (i+1))\nprint client.object("encoding", "hello")  # 获取对象的存储结构\nclient.hset("hello", "512", "0" * 65)\nprint client.object("encoding", "hello") # 再次获取对象的存储结构\n'})}),"\n",(0,s.jsx)(n.p,{children:"输出："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ziplist\nhashtable\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看出来当 hash 结构的任意 entry 的 value 值超过了 64，存储结构就升级成标准结构了。"}),"\n",(0,s.jsxs)(n.h2,{id:"内存回收机制",children:["内存回收机制",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内存回收机制",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Redis 并不总是可以将空闲内存立即归还给操作系统。"}),"\n",(0,s.jsx)(n.p,{children:"如果当前 Redis 内存有 10G，当你删除了 1GB 的 key 后，再去观察内存，你会发现内存变化不会太大。原因是操作系统回收内存是以页为单位，如果这个页上只要有一个 key 还在使用，那么它就不能被回收。Redis 虽然删除了 1GB 的 key，但是这些 key 分散到了很多页面中，每个页面都还有其它 key 存在，这就导致了内存不会立即被回收。"}),"\n",(0,s.jsxs)(n.p,{children:["不过，如果你执行 ",(0,s.jsx)(n.code,{children:"flushdb"}),"，然后再观察内存会发现内存确实被回收了。原因是所有的 key 都干掉了，大部分之前使用的页面都完全干净了，会立即被操作系统回收。"]}),"\n",(0,s.jsx)(n.p,{children:"Redis 虽然无法保证立即回收已经删除的 key 的内存，但是它会重用那些尚未回收的空闲内存。这就好比电影院里虽然人走了，但是座位还在，下一波观众来了，直接坐就行。而操作系统回收内存就好比把座位都给搬走了。这个比喻是不是很 6？"}),"\n",(0,s.jsxs)(n.h2,{id:"内存分配算法",children:["内存分配算法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内存分配算法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"内存分配是一个非常复杂的课题，需要适当的算法划分内存页，需要考虑内存碎片，需要平衡性能和效率。"}),"\n",(0,s.jsx)(n.p,{children:"Redis 为了保持自身结构的简单性，在内存分配这里直接做了甩手掌柜，将内存分配的细节丢给了第三方内存分配库去实现。目前 Redis 可以使用 jemalloc(facebook) 库来管理内存，也可以切换到tcmalloc(google)。因为 jemalloc 相比 tcmalloc的性能要稍好一些，所以Redis默认使用了jemalloc。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"127.0.0.1:6379> info memory\n# Memory\nused_memory:809608\nused_memory_human:790.63K\nused_memory_rss:8232960\nused_memory_peak:566296608\nused_memory_peak_human:540.06M\nused_memory_lua:36864\nmem_fragmentation_ratio:10.17\nmem_allocator:jemalloc-3.6.0\n"})}),"\n",(0,s.jsxs)(n.p,{children:["通过",(0,s.jsx)(n.code,{children:"info memory"}),"指令可以看到 Redis 的",(0,s.jsx)(n.code,{children:"mem_allocator"}),"使用了 jemalloc。"]}),"\n",(0,s.jsxs)(n.h2,{id:"扩展阅读",children:["扩展阅读",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"http://tinylab.org/memory-allocation-mystery-%C2%B7-jemalloc-a/",target:"_blank",rel:"noopener noreferrer",children:"jemalloc —— 内存分配的奥义"})})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}let d=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F17%E5%8E%9F%E7%90%86%207%EF%BC%9A%E5%BC%80%E6%BA%90%E8%8A%82%E6%B5%81%20%E2%80%94%E2%80%94%20%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%8E%8B%E7%BC%A9.md"]={toc:[{text:"32bit vs 64bit",id:"32bit-vs-64bit",depth:2},{text:"小对象压缩存储 (ziplist)",id:"小对象压缩存储-ziplist",depth:2},{text:"内存回收机制",id:"内存回收机制",depth:2},{text:"内存分配算法",id:"内存分配算法",depth:2},{text:"扩展阅读",id:"扩展阅读",depth:2}],title:"17原理 7：开源节流 —— 小对象压缩",headingTitle:"17原理 7：开源节流 —— 小对象压缩",frontmatter:{}}}}]);