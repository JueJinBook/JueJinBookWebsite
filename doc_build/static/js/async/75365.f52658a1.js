"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75365"],{275956:function(e,n,r){e.exports=r.p+"static/image/66aca542bd1bcafed12b6517093fb8e8.879bf77c.webp"},38122:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var s=r(552676),i=r(740453);let t=r.p+"static/image/2632735a588e5d38310f29143d61771c.f118a0c0.webp";var l=r(275956);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",img:"img",ul:"ul",li:"li",ol:"ol",pre:"pre",strong:"strong",blockquote:"blockquote",h3:"h3",h4:"h4"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"22插件流水线从整体到局部理解-vite-的核心编译能力",children:["22.插件流水线：从整体到局部，理解 Vite 的核心编译能力",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22插件流水线从整体到局部理解-vite-的核心编译能力",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们知道，Vite 在开发阶段实现了一个按需加载的服务器，每一个文件请求进来都会经历一系列的编译流程，然后 Vite 会将编译结果响应给浏览器。在生产环境下，Vite 同样会执行一系列编译过程，将编译结果交给 Rollup 进行模块打包。这一系列的编译过程指的就是 Vite 的插件工作流水线(Pipeline)，而插件功能又是 Vite 构建能力的核心，因此谈到阅读 Vite 源码，我们永远绕不开插件的作用与实现原理。"}),"\n",(0,s.jsxs)(n.p,{children:["接下来，我就和你一起分析 Vite 插件流水线的顶层架构，也就是各个插件如何被调度和组织起来的，详细说说 Vite 插件容器(",(0,s.jsx)(n.code,{children:"PluginContainer"}),")机制的实现，同时带你一起梳理开发阶段和生产环境各自会用到的插件，并分析各自的功能与实现原理，让你能够全面、准确地认识 Vite 的插件流水线！"]}),"\n",(0,s.jsxs)(n.h2,{id:"插件容器",children:["插件容器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插件容器",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["从",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7050063811973218341/section/7060398408430780431",target:"_blank",rel:"noopener noreferrer",children:"《双引擎架构》"}),"小节中我们知道 Vite 的插件机制是与 Rollup 兼容的，但它在开发和生产环境下的实现稍有差别，你可以回顾一下这张架构图:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"我们可以看到:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"在生产环境中 Vite 直接调用 Rollup 进行打包，所以 Rollup 可以调度各种插件；"}),"\n",(0,s.jsxs)(n.li,{children:["在开发环境中，Vite 模拟了 Rollup 的插件机制，设计了一个",(0,s.jsx)(n.code,{children:"PluginContainer"})," 对象来调度各个插件。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"PluginContainer"}),"(插件容器)对象非常重要，前两节我们也多次提到了它，接下来我们就把目光集中到这个对象身上，看看 Vite 的插件容器机制究竟是如何实现的。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"PluginContainer"})," 的 ",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/pluginContainer.ts",target:"_blank",rel:"noopener noreferrer",children:"实现"})," 基于借鉴于 WMR 中的",(0,s.jsx)(n.code,{children:"rollup-plugin-container.js"}),"，主要分为 2 个部分:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"实现 Rollup 插件钩子的调度"}),"\n",(0,s.jsx)(n.li,{children:"实现插件钩子内部的 Context 上下文对象"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["首先，你可以通过 ",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/server/pluginContainer.ts#L463",target:"_blank",rel:"noopener noreferrer",children:"container 的定义"})," 来看看各个 Rollup 钩子的实现方式，代码精简后如下:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const container = {\n  // 异步串行钩子\n  options: await (async () => {\n    let options = rollupOptions\n    for (const plugin of plugins) {\n      if (!plugin.options) continue\n      options =\n        (await plugin.options.call(minimalContext, options)) || options\n    }\n    return options;\n  })(),\n  // 异步并行钩子\n  async buildStart() {\n    await Promise.all(\n      plugins.map((plugin) => {\n        if (plugin.buildStart) {\n          return plugin.buildStart.call(\n            new Context(plugin) as any,\n            container.options as NormalizedInputOptions\n          )\n        }\n      })\n    )\n  },\n  // 异步优先钩子\n  async resolveId(rawId, importer) {\n    // 上下文对象，后文介绍\n    const ctx = new Context()\n\n    let id: string | null = null\n    const partial: Partial<PartialResolvedId> = {}\n    for (const plugin of plugins) {\n      const result = await plugin.resolveId.call(\n        ctx as any,\n        rawId,\n        importer,\n        { ssr }\n      )\n      if (!result) continue;\n      return result;\n    }\n  }\n  // 异步优先钩子\n  async load(id, options) {\n    const ctx = new Context()\n    for (const plugin of plugins) {\n      const result = await plugin.load.call(ctx as any, id, { ssr })\n      if (result != null) {\n        return result\n      }\n    }\n    return null\n  },\n  // 异步串行钩子\n  async transform(code, id, options) {\n    const ssr = options?.ssr\n    // 每次 transform 调度过程会有专门的上下文对象，用于合并 SourceMap，后文会介绍\n    const ctx = new TransformContext(id, code, inMap as SourceMap)\n    ctx.ssr = !!ssr\n    for (const plugin of plugins) {\n      let result: TransformResult | string | undefined\n      try {\n        result = await plugin.transform.call(ctx as any, code, id, { ssr })\n      } catch (e) {\n        ctx.error(e)\n      }\n      if (!result) continue;\n      // 省略 SourceMap 合并的逻辑 \n      code = result;\n    }\n    return {\n      code,\n      map: ctx._getCombinedSourcemap()\n    }\n  },\n  // close 钩子实现省略\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7050063811973218341/section/7061854307863232547",target:"_blank",rel:"noopener noreferrer",children:"《Vite 构建基石(下)——深入理解 Rollup 的插件机制》"})," 中，我们已经系统学习过 Rollup 中异步、串行、并行等钩子类型的执行原理了，现在再来阅读这部分 ",(0,s.jsx)(n.code,{children:"PluginContainer"})," 的实现代码应该并不困难。"]}),"\n",(0,s.jsxs)(n.p,{children:["不过值得注意的是，在各种钩子被调用的时候，Vite 会强制将钩子函数的 ",(0,s.jsx)(n.code,{children:"this"})," 绑定为一个上下文对象，如:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const ctx = new Context()\nconst result = await plugin.load.call(ctx as any, id, { ssr })\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个对象究竟是用来干什么的呢？"}),"\n",(0,s.jsxs)(n.p,{children:["我们知道，在 Rollup 钩子函数中，我们可以调用",(0,s.jsx)(n.code,{children:"this.emitFile"}),"、",(0,s.jsx)(n.code,{children:"this.resolve"})," 等诸多的上下文方法(",(0,s.jsx)(n.a,{href:"https://rollupjs.org/guide/en/#plugin-context",target:"_blank",rel:"noopener noreferrer",children:"详情地址"}),")，因此，Vite 除了要模拟各个插件的执行流程，还需要模拟插件执行的上下文对象，代码中的 ",(0,s.jsx)(n.code,{children:"Context"})," 对象就是用来完成这件事情的。我们来看看 Context 对象的具体实现:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { RollupPluginContext } from 'rollup';\ntype PluginContext = Omit<\n  RollupPluginContext,\n  // not documented\n  | 'cache'\n  // deprecated\n  | 'emitAsset'\n  | 'emitChunk'\n  | 'getAssetFileName'\n  | 'getChunkFileName'\n  | 'isExternal'\n  | 'moduleIds'\n  | 'resolveId'\n  | 'load'\n>\n\nconst watchFiles = new Set<string>()\n\nclass Context implements PluginContext {\n  // 实现各种上下文方法\n  // 解析模块 AST(调用 acorn)\n  parse(code: string, opts: any = {}) {\n    return parser.parse(code, {\n      sourceType: 'module',\n      ecmaVersion: 'latest',\n      locations: true,\n      ...opts\n    })\n  }\n  // 解析模块路径\n  async resolve(\n    id: string,\n    importer?: string,\n    options?: { skipSelf?: boolean }\n  ) {\n    let skip: Set<Plugin> | undefined\n    if (options?.skipSelf && this._activePlugin) {\n      skip = new Set(this._resolveSkips)\n      skip.add(this._activePlugin)\n    }\n    let out = await container.resolveId(id, importer, { skip, ssr: this.ssr })\n    if (typeof out === 'string') out = { id: out }\n    return out as ResolvedId | null\n  }\n\n  // 以下两个方法均从 Vite 的模块依赖图中获取相关的信息\n  // 我们将在下一节详细介绍模块依赖图，本节不做展开\n  getModuleInfo(id: string) {\n    return getModuleInfo(id)\n  }\n\n  getModuleIds() {\n    return moduleGraph\n      ? moduleGraph.idToModuleMap.keys()\n      : Array.prototype[Symbol.iterator]()\n  }\n  \n  // 记录开发阶段 watch 的文件\n  addWatchFile(id: string) {\n    watchFiles.add(id)\n    ;(this._addedImports || (this._addedImports = new Set())).add(id)\n    if (watcher) ensureWatchedFile(watcher, id, root)\n  }\n\n  getWatchFiles() {\n    return [...watchFiles]\n  }\n  \n  warn() {\n    // 打印 warning 信息\n  }\n  \n  error() {\n    // 打印 error 信息\n  }\n  \n  // 其它方法只是声明，并没有具体实现，这里就省略了\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["很显然，Vite 将 Rollup 的",(0,s.jsx)(n.code,{children:"PluginContext"}),"对象重新实现了一遍，因为只是开发阶段用到，所以去除了一些打包相关的方法实现。同时，上下文对象与 Vite 开发阶段的 ModuleGraph 即模块依赖图相结合，是为了实现开发时的 HMR。 HMR 实现的细节，我们将在下一节展开介绍。"]}),"\n",(0,s.jsx)(n.p,{children:"另外，transform 钩子也会绑定一个插件上下文对象，不过这个对象和其它钩子不同，实现代码精简如下:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class TransformContext extends Context {\n  constructor(filename: string, code: string, inMap?: SourceMap | string) {\n    super()\n    this.filename = filename\n    this.originalCode = code\n    if (inMap) {\n      this.sourcemapChain.push(inMap)\n    }\n  }\n\n  _getCombinedSourcemap(createIfNull = false) {\n    return this.combinedMap\n  }\n\n  getCombinedSourcemap() {\n    return this._getCombinedSourcemap(true) as SourceMap\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到，",(0,s.jsx)(n.code,{children:"TransformContext"}),"继承自之前所说的",(0,s.jsx)(n.code,{children:"Context"}),"对象，也就是说 transform 钩子的上下文对象相比其它钩子只是做了一些扩展，增加了 sourcemap 合并的功能，将不同插件的 transform 钩子执行后返回的 sourcemap 进行合并，以保证 sourcemap 的准确性和完整性。"]}),"\n",(0,s.jsxs)(n.h2,{id:"插件工作流概览",children:["插件工作流概览",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插件工作流概览",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在分析配置解析服务的小节中，我们提到过生成插件流水线即",(0,s.jsx)(n.code,{children:"resolvePlugins"}),"的逻辑，但没有具体展开，这里我们就来详细拆解一下 Vite 在这一步究竟做了啥。"]}),"\n",(0,s.jsxs)(n.p,{children:["让我们把目光集中在",(0,s.jsx)(n.code,{children:"resolvePlugins"}),"的",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/plugins/index.ts#L22",target:"_blank",rel:"noopener noreferrer",children:"实现"}),"上，Vite 所有的插件就是在这里被收集起来的。具体实现如下:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export async function resolvePlugins(\n  config: ResolvedConfig,\n  prePlugins: Plugin[],\n  normalPlugins: Plugin[],\n  postPlugins: Plugin[]\n): Promise<Plugin[]> {\n  const isBuild = config.command === 'build'\n  // 收集生产环境构建的插件，后文会介绍\n  const buildPlugins = isBuild\n    ? (await import('../build')).resolveBuildPlugins(config)\n    : { pre: [], post: [] }\n\n  return [\n    // 1. 别名插件\n    isBuild ? null : preAliasPlugin(),\n    aliasPlugin({ entries: config.resolve.alias }),\n    // 2. 用户自定义 pre 插件(带有`enforce: \"pre\"`属性)\n    ...prePlugins,\n    // 3. Vite 核心构建插件\n    // 数量比较多，暂时省略代码\n    // 4. 用户插件（不带有 `enforce` 属性）\n    ...normalPlugins,\n    // 5. Vite 生产环境插件 & 用户插件(带有 `enforce: \"post\"`属性)\n    definePlugin(config),\n    cssPostPlugin(config),\n    ...buildPlugins.pre,\n    ...postPlugins,\n    ...buildPlugins.post,\n    // 6. 一些开发阶段特有的插件\n    ...(isBuild\n      ? []\n      : [clientInjectionsPlugin(config), importAnalysisPlugin(config)])\n  ].filter(Boolean) as Plugin[]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"从上述代码中我们可以总结出 Vite 插件的具体执行顺序。"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"别名插件"}),"包括 ",(0,s.jsx)(n.code,{children:"vite:pre-alias"}),"和",(0,s.jsx)(n.code,{children:"@rollup/plugin-alias"}),"，用于路径别名替换。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["用户自定义 pre 插件，也就是带有",(0,s.jsx)(n.code,{children:'enforce: "pre"'}),"属性的自定义插件。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Vite 核心构建插件，这部分插件为 Vite 的核心编译插件，数量比较多，我们在下部分一一拆解。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["用户自定义的普通插件，即不带有 ",(0,s.jsx)(n.code,{children:"enforce"})," 属性的自定义插件。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Vite 生产环境插件"}),"和用户插件中带有",(0,s.jsx)(n.code,{children:'enforce: "post"'}),"属性的插件。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["一些开发阶段特有的插件，包括环境变量注入插件",(0,s.jsx)(n.code,{children:"clientInjectionsPlugin"}),"和 import 语句分析及重写插件",(0,s.jsx)(n.code,{children:"importAnalysisPlugin"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"那么，在执行过程中 Vite 到底应用了哪些插件，以及这些插件内部究竟做了什么？我们来一一梳理一下。"}),"\n",(0,s.jsxs)(n.h2,{id:"插件功能梳理",children:["插件功能梳理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插件功能梳理",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"这一节，我们主要围绕实现原理展开，并不会详细介绍所有插件的代码实现细节，不过相应的源码链接我都会放到文章当中，感兴趣的同学可以在课后进一步阅读。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"除用户自定义插件之外，我们需要梳理的 Vite 内置插件有下面这几类:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"别名插件"}),"\n",(0,s.jsx)(n.li,{children:"核心构建插件"}),"\n",(0,s.jsx)(n.li,{children:"生产环境特有插件"}),"\n",(0,s.jsx)(n.li,{children:"开发环境特有插件"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-别名插件",children:["1. 别名插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-别名插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["别名插件有两个，分别是 ",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/72cb33e947e7aa72d27ed0c5eacb2457d523dfbf/packages/vite/src/node/plugins/preAlias.ts",target:"_blank",rel:"noopener noreferrer",children:"vite:pre-alias"})," 和 ",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/72cb33e947e7aa72d27ed0c5eacb2457d523dfbf/packages/vite/src/node/plugins/index.ts#L3",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-alias"}),"。\n前者主要是为了将 bare import 路径重定向到预构建依赖的路径，如:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 假设 React 已经过 Vite 预构建\nimport React from 'react';\n// 会被重定向到预构建产物的路径\nimport React from '/node_modules/.vite/react.js'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["后者则是实现了比较通用的路径别名(即",(0,s.jsx)(n.code,{children:"resolve.alias"}),"配置)的功能，使用的是 ",(0,s.jsx)(n.a,{href:"https://github.com/rollup/plugins/tree/master/packages/alias#rollupplugin-alias",target:"_blank",rel:"noopener noreferrer",children:"Rollup 官方 Alias 插件"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-核心构建插件",children:["2. 核心构建插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-核心构建插件",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"21-module-preload-特性的-polyfill",children:["2.1 module preload 特性的 Polyfill",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-module-preload-特性的-polyfill",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"当你在 Vite 配置文件中开启下面这个配置时:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  build: {\n    polyfillModulePreload: true\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Vite 会自动应用 ",(0,s.jsx)(n.code,{children:"modulePreloadPolyfillPlugin"})," 插件，在产物中注入 module preload 的 Polyfill 代码，",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/modulePreloadPolyfill.ts#L7",target:"_blank",rel:"noopener noreferrer",children:"具体实现"})," 摘自之前我们提到过的 ",(0,s.jsx)(n.code,{children:"es-module-shims"}),"这个库，实现原理如下:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"扫描出当前所有的 modulepreload 标签，拿到 link 标签对应的地址，通过执行 fetch 实现预加载；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"同时通过 MutationObserver 监听 DOM 的变化，一旦发现包含 modulepreload 属性的 link 标签，则同样通过 fetch 请求实现预加载。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"由于部分支持原生 ESM 的浏览器并不支持 module preload，因此某些情况下需要注入相应的 polyfill 进行降级。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"22-路径解析插件",children:["2.2 路径解析插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-路径解析插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["路径解析插件(即",(0,s.jsx)(n.code,{children:"vite:resolve"}),")是 Vite 中比较核心的插件，几乎所有重要的 Vite 特性都离不开这个插件的实现，诸如依赖预构建、HMR、SSR 等等。同时它也是实现相当复杂的插件，一方面实现了 ",(0,s.jsx)(n.a,{href:"https://nodejs.org/api/modules.html#modules_all_together",target:"_blank",rel:"noopener noreferrer",children:"Node.js 官方的 resolve 算法"}),"，另一方面需要支持前面所说的各项特性，可以说是专门给 Vite 实现了一套路径解析算法。"]}),"\n",(0,s.jsx)(n.p,{children:"这个插件的实现细节足以再开一个小节专门分析了，所以本节我们就不展开了，你初步了解就可以了。"}),"\n",(0,s.jsxs)(n.h4,{id:"23-内联脚本加载插件",children:["2.3 内联脚本加载插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-内联脚本加载插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["对于 HTML 中的内联脚本，Vite 会通过",(0,s.jsx)(n.code,{children:"vite:html-inline-script-proxy"})," 插件来进行加载。比如下面这个 script 标签:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"<script type=\"module\">\nimport React from 'react';\nconsole.log(React)\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这些内容会在后续的",(0,s.jsx)(n.code,{children:"build-html"}),"插件从 HTML 代码中剔除，并且变成下面的这一行代码插入到项目入口模块的代码中:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import '/User/xxx/vite-app/index.html?http-proxy&index=0.js'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["而 ",(0,s.jsx)(n.code,{children:"vite:html-inline-script-proxy"})," 就是用来加载这样的模块，实现如下:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const htmlProxyRE = /\\?html-proxy&index=(\\d+)\\.js$/\n\nexport function htmlInlineScriptProxyPlugin(config: ResolvedConfig): Plugin {\n  return {\n    name: 'vite:html-inline-script-proxy',\n    load(id) {\n      const proxyMatch = id.match(htmlProxyRE)\n      if (proxyMatch) {\n        const index = Number(proxyMatch[1])\n        const file = cleanUrl(id)\n        const url = file.replace(normalizePath(config.root), '')\n        // 内联脚本的内容会被记录在 htmlProxyMap 这个表中\n        const result = htmlProxyMap.get(config)!.get(url)![index]\n        if (typeof result === 'string') {\n          // 加载脚本的具体内容\n          return result\n        } else {\n          throw new Error(`No matching HTML proxy module found from ${id}`)\n        }\n      }\n    }\n  }\n}\n\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"24-css-编译插件",children:["2.4 CSS 编译插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-css-编译插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["即名为",(0,s.jsx)(n.code,{children:"vite:css"}),"的",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/css.ts#L137",target:"_blank",rel:"noopener noreferrer",children:"插件"}),"，主要实现下面这些功能:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"CSS 预处理器的编译"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"CSS Modules"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"Postcss 编译"})}),"\n",(0,s.jsxs)(n.li,{children:["通过 @import ",(0,s.jsx)(n.code,{children:"记录依赖"}),"，便于 HMR"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这个插件的核心在于",(0,s.jsx)(n.code,{children:"compileCSS"}),"函数的实现，感兴趣的同学可以阅读一下",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/css.ts#L568",target:"_blank",rel:"noopener noreferrer",children:"这部分的源码"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"25-esbuild-转译插件",children:["2.5 Esbuild 转译插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-esbuild-转译插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["即名为",(0,s.jsx)(n.code,{children:"vite:esbuild"}),"的",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/esbuild.ts",target:"_blank",rel:"noopener noreferrer",children:"插件"}),"，用来进行 ",(0,s.jsx)(n.code,{children:".js"}),"、",(0,s.jsx)(n.code,{children:".ts"}),"、",(0,s.jsx)(n.code,{children:".jsx"}),"和",(0,s.jsx)(n.code,{children:"tsx"}),"，代替了传统的 Babel 或者 TSC 的功能，这也是 Vite 开发阶段性能强悍的一个原因。插件中主要的逻辑是",(0,s.jsx)(n.code,{children:"transformWithEsbuild"}),"函数，顾名思义，你可以通过这个函数进行代码转译。当然，Vite 本身也导出了这个函数，作为一种通用的 transform 能力，你可以这样来使用:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { transformWithEsbuild } from 'vite';\n\n// 传入两个参数: code, filename\ntransformWithEsbuild('<h1>hello</h1>', './index.tsx').then(res => {\n  // {\n  //   warnings: [],\n  //   code: '/* @__PURE__ */ React.createElement(\"h1\", null, \"hello\");\\n',\n  //   map: {/* sourcemap 信息 */}\n  // }\n  console.log(res);\n})\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"26-静态资源加载插件",children:["2.6 静态资源加载插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26-静态资源加载插件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"静态资源加载插件包括如下几个:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"vite:json"})," 用来加载 JSON 文件，通过",(0,s.jsx)(n.code,{children:"@rollup/pluginutils"}),"的",(0,s.jsx)(n.code,{children:"dataToEsm"}),"方法可实现 JSON 的按名导入，具体实现见",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/json.ts#L30",target:"_blank",rel:"noopener noreferrer",children:"链接"}),"；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"vite:wasm"})," 用来加载 ",(0,s.jsx)(n.code,{children:".wasm"})," 格式的文件，具体实现见",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/wasm.ts#L45",target:"_blank",rel:"noopener noreferrer",children:"链接"}),"；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"vite:worker"})," 用来 Web Worker 脚本，插件内部会使用 Rollup 对 Worker 脚本进行打包，具体实现见",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/worker.ts",target:"_blank",rel:"noopener noreferrer",children:"链接"}),"；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"vite:asset"}),"，开发阶段实现了其他格式静态资源的加载，而生产环境会通过 ",(0,s.jsx)(n.code,{children:"renderChunk"})," 钩子将静态资源地址重写为产物的文件地址，如",(0,s.jsx)(n.code,{children:"./img.png"})," 重写为 ",(0,s.jsx)(n.code,{children:"https://cdn.xxx.com/assets/img.91ee297e.png"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["值得注意的是，Rollup 本身存在 ",(0,s.jsx)(n.a,{href:"https://bundlers.tooling.report/hashing/asset-cascade/",target:"_blank",rel:"noopener noreferrer",children:"asset cascade"})," 问题，即静态资源哈希更新，引用它的 JS 的哈希并没有更新(",(0,s.jsx)(n.a,{href:"https://github.com/rollup/rollup/issues/3415",target:"_blank",rel:"noopener noreferrer",children:"issue 链接"}),")。因此 Vite 在静态资源处理的时候，并没有交给 Rollup 生成资源哈希，而是自己根据资源内容生成哈希(",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/asset.ts#L306",target:"_blank",rel:"noopener noreferrer",children:"源码实现"}),")，并手动进行路径重写，以此避免 ",(0,s.jsx)(n.code,{children:"asset-cascade"})," 问题。"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-生产环境特有插件",children:["3. 生产环境特有插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-生产环境特有插件",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"31-全局变量替换插件",children:["3.1 全局变量替换插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-全局变量替换插件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"提供全局变量替换功能，如下面的这个配置:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\nconst version = '2.0.0';\n\nexport default {\n  define: {\n    __APP_VERSION__: `JSON.stringify(${version})`\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["全局变量替换的功能和我们之前在 Rollup 插件小节中提到的",(0,s.jsx)(n.a,{href:"https://github.com/rollup/plugins/tree/master/packages/replace",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-replace"})," 差不多，当然在实现上 Vite 会有所区别:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["开发环境下，Vite 会通过将所有的全局变量挂载到",(0,s.jsx)(n.code,{children:"window"}),"对象，而不用经过 define 插件的处理，节省编译开销；"]}),"\n",(0,s.jsxs)(n.li,{children:["生产环境下，Vite 会使用 ",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/plugins/define.ts",target:"_blank",rel:"noopener noreferrer",children:"define 插件"}),"，进行字符串替换以及 sourcemap 生成。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"特殊情况: SSR 构建会在开发环境经过这个插件，仅替换字符串。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"32-css-后处理插件",children:["3.2 CSS 后处理插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-css-后处理插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["CSS 后处理插件即",(0,s.jsx)(n.code,{children:"name"}),"为",(0,s.jsx)(n.code,{children:"vite:css-post"}),"的插件，它的功能包括",(0,s.jsx)(n.code,{children:"开发阶段 CSS 响应结果处理"}),"和",(0,s.jsx)(n.code,{children:"生产环境 CSS 文件生成"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["首先，在开发阶段，这个插件会将之前的 CSS 编译插件处理后的结果，包装成一个 ESM 模块，返回给浏览器，",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/css.ts#L284",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现代码"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["其次，生产环境中，Vite 默认会通过这个插件进行 CSS 的 code splitting，即对于每个异步 chunk，Vite 会将其依赖的 CSS 代码单独打包成一个文件，关键代码如下(",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/css.ts#L400",target:"_blank",rel:"noopener noreferrer",children:"源码链接"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const fileHandle = this.emitFile({\n  name: chunk.name + '.css',\n  type: 'asset',\n  source: chunkCSS\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果 CSS 的 code splitting 功能被关闭(通过",(0,s.jsx)(n.code,{children:"build.cssCodeSplit"}),"配置)，那么 Vite 会将所有的 CSS 代码打包到同一个 CSS 文件中，",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/css.ts#L433",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后，插件会调用 Esbuild 对 CSS 进行压缩，实现在 ",(0,s.jsx)(n.code,{children:"minifyCSS"})," 函数中，",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/css.ts#L905",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"33-html-构建插件",children:["3.3 HTML 构建插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-html-构建插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"HTML"})," 构建插件 即",(0,s.jsx)(n.code,{children:"build-html"}),"插件。之前我们在",(0,s.jsx)(n.code,{children:"内联脚本加载插件"}),"中提到过，项目根目录下的",(0,s.jsx)(n.code,{children:"html"}),"会转换为一段 JavaScript 代码，如下面的这个例子:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  // 普通方式引入\n  <script src="./index.ts"><\/script>\n  // 内联脚本\n  <script type="module">\n    import React from \'react\';\n    console.log(React)\n  <\/script>\n</body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["首先，当 Vite 在生产环境",(0,s.jsx)(n.code,{children:"transform"}),"这段入口 HTML 时，会做 3 件事情:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["对 HTML 执行各个插件中带有 ",(0,s.jsx)(n.code,{children:'enforce: "pre"'})," 属性的 transformIndexHtml 钩子；"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["我们知道插件本身可以带有 ",(0,s.jsx)(n.code,{children:'enforce: "pre"|"post"'})," 属性，而 transformIndexHtml 本身也可以带有这个属性，用于在不同的阶段进行 HTML 转换。后文会介绍 transformIndexHtml 钩子带有 ",(0,s.jsx)(n.code,{children:'enforce: "post"'})," 时的执行时机。"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["将其中的 script 标签内容删除，并将其转换为 ",(0,s.jsx)(n.code,{children:"import 语句"}),"如",(0,s.jsx)(n.code,{children:"import './index.ts'"}),"，并记录下来；"]}),"\n",(0,s.jsxs)(n.li,{children:["在 transform 钩子中返回记录下来的 import 内容，将 import 语句作为模块内容进行加载。也就是说，虽然 Vite 处理的是一个 HTML 文件，但最后进行打包的内容却是一段 JS 的内容，",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/plugins/html.ts#L233",target:"_blank",rel:"noopener noreferrer",children:"点击查看具体实现"}),"。代码简化后如下所示:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export function buildHtmlPlugin() {\n  name: 'vite:build',\n  transform(html, id) {\n    if (id.endsWith('.html')) {\n      let js = '';\n      // 省略 HTML AST 遍历过程(通过 @vue/compiler-dom 实现)\n      // 收集 script 标签，转换成 import 语句，拼接到 js 字符串中\n      return js;\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其次，在生成产物的最后一步即",(0,s.jsx)(n.code,{children:"generateBundle"}),"钩子中，拿到入口 Chunk，分析入口 Chunk 的内容, 分情况进行处理。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果只有 import 语句，先通过 Rollup 提供的 ",(0,s.jsx)(n.code,{children:"chunk"})," 和 ",(0,s.jsx)(n.code,{children:"bundle"})," 对象获取入口 chunk 所有的依赖 chunk，并将这些 chunk 进行后序排列，如 ",(0,s.jsx)(n.code,{children:"a 依赖 b，b 依赖 c"}),"，最后的依赖数组就是",(0,s.jsx)(n.code,{children:"[c, b, a]"}),"。然后依次将 c，b, a 生成三个 script 标签，插入 HTML 中。最后，Vite 会将入口 chunk 的内容从 bundle 产物中移除，因此它的内容只要 import 语句，而它 import 的 chunk 已经作为 script 标签插入到了 HTML 中，那入口 Chunk 的存在也就没有意义了。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果除了 import 语句，还有其它内容， Vite 就会将入口 Chunk 单独生成一个 ",(0,s.jsx)(n.code,{children:"script 标签"}),"，分析出依赖的后序排列(和上一种情况分析手段一样)，然后通过注入 ",(0,s.jsx)(n.code,{children:'<link rel="modulepreload"> 标签'}),"对入口文件的依赖 chunk 进行预加载。"]}),"\n",(0,s.jsxs)(n.p,{children:["最后，插件会调用用户插件中带有 ",(0,s.jsx)(n.code,{children:'enforce: "post"'})," 属性的 transformIndexHtml 钩子，对 HTML 进行进一步的处理。",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/main/packages/vite/src/node/plugins/html.ts#L471",target:"_blank",rel:"noopener noreferrer",children:"点击查看具体实现"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"33-commonjs-转换插件",children:["3.3 Commonjs 转换插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-commonjs-转换插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们知道，在开发环境中，Vite 使用 Esbuild 将 Commonjs 转换为 ESM，而生产环境中，Vite 会直接使用 Rollup 的官方插件 ",(0,s.jsx)(n.a,{href:"https://github.com/rollup/plugins/tree/master/packages/commonjs",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-commonjs"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"34-date-uri-插件",children:["3.4 date-uri 插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34-date-uri-插件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"date-uri 插件用来支持 import 模块中含有 Base64 编码的情况，如:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import batman from 'data:application/json;base64, eyAiYmF0bWFuIjogInRydWUiIH0=';\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/dataUri.ts#L14",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"35-dynamic-import-vars-插件",children:["3.5 dynamic-import-vars 插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#35-dynamic-import-vars-插件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"用于支持在动态 import 中使用变量的功能，如下示例代码:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function importLocale(locale) {\n  return import(`./locales/${locale}.js`);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["内部使用的是 Rollup 的官方插件 ",(0,s.jsx)(n.a,{href:"https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars",target:"_blank",rel:"noopener noreferrer",children:"@rollup/plugin-dynamic-import-vars"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"36-import-meta-url-支持插件",children:["3.6 import-meta-url 支持插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36-import-meta-url-支持插件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"用来转换如下格式的资源 URL:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"new URL('./foo.png', import.meta.url)\n"})}),"\n",(0,s.jsx)(n.p,{children:"将其转换为生产环境的 URL 格式，如:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 使用 self.location 来保证低版本浏览器和 Web Worker 环境的兼容性\nnew URL('./assets.a4b3d56d.png, self.location)\n"})}),"\n",(0,s.jsx)(n.p,{children:"同时，对于动态 import 的情况也能进行支持，如下面的这种写法:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function getImageUrl(name) {\n  return new URL(`./dir/${name}.png`, import.meta.url).href\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Vite 识别到",(0,s.jsx)(n.code,{children:"./dir/${name}.png"}),"这样的模板字符串，会将整行代码转换成下面这样:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function getImageUrl(name) {\n    return import.meta.globEager('./dir/**.png')[`./dir/${name}.png`].default;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0/packages/vite/src/node/plugins/assetImportMetaUrl.ts#L18",target:"_blank",rel:"noopener noreferrer",children:"点击查看具体实现"})}),"\n",(0,s.jsxs)(n.h4,{id:"37-生产环境-import-分析插件",children:["3.7 生产环境 import 分析插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#37-生产环境-import-分析插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"vite:build-import-analysis"})," 插件会在生产环境打包时用作 import 语句分析和重写，主要目的是对动态 import 的模块进行预加载处理。"]}),"\n",(0,s.jsxs)(n.p,{children:["对含有动态 import 的 chunk 而言，会在插件的",(0,s.jsx)(n.code,{children:"tranform"}),"钩子中被添加这样一段工具代码用来进行模块预加载，逻辑并不复杂，你可以参考",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/importAnalysisBuild.ts#L43",target:"_blank",rel:"noopener noreferrer",children:"源码实现"}),"。关键代码简化后如下:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function preload(importModule, deps) {\n  return Promise.all(\n    deps.map(dep => {\n      // 如果异步模块的依赖还没有加载\n      if (!alreadyLoaded(dep)) { \n        // 创建 link 标签加载，包括 JS 或者 CSS\n        document.head.appendChild(createLink(dep))  \n        // 如果是 CSS，进行特殊处理，后文会介绍\n        if (isCss(dep)) {\n          return new Promise((resolve, reject) => {\n            link.addEventListener('load', resolve)\n            link.addEventListener('error', reject)\n          })\n        }\n      }\n    })\n  ).then(() => importModule())\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们知道，Vite 内置了 CSS 代码分割的能力，当一个模块通过动态 import 引入的时候，这个模块会被单独打包成一个 chunk，与此同时这个模块中的样式代码也会打包成单独的 CSS 文件。如果异步模块的 CSS 和 JS 同时进行预加载，那么在某些浏览器下(如 IE)就会出现 ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.",target:"_blank",rel:"noopener noreferrer",children:"FOUC 问题"}),"，页面样式会闪烁，影响用户体验。但 Vite 通过监听 link 标签 ",(0,s.jsx)(n.code,{children:"load"})," 事件的方式来保证 CSS 在 JS 之前加载完成，从而解决了 FOUC 问题。你可以注意下面这段关键代码:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"if (isCss) {\n  return new Promise((res, rej) => {\n    link.addEventListener('load', res)\n    link.addEventListener('error', rej)\n  })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"现在，我们已经知道了预加载的实现方法，那么 Vite 是如何将动态 import 编译成预加载的代码的呢？"}),"\n",(0,s.jsxs)(n.p,{children:["从源码的",(0,s.jsx)(n.code,{children:"transform"}),"钩子",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/importAnalysisBuild.ts#L111",target:"_blank",rel:"noopener noreferrer",children:"实现"}),"中，不难发现 Vite 会将动态 import 的代码进行转换，如下代码所示:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 转换前\nimport('a')\n// 转换后\n__vitePreload(() => 'a', __VITE_IS_MODERN__ ?\"__VITE_PRELOAD__\":void)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中，",(0,s.jsx)(n.code,{children:"__vitePreload"})," 会被加载为前文中的 ",(0,s.jsx)(n.code,{children:"preload"})," 工具函数，",(0,s.jsx)(n.code,{children:"__VITE_IS_MODERN__"})," 会在 ",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/importAnalysisBuild.ts#L208",target:"_blank",rel:"noopener noreferrer",children:"renderChunk"})," 中被替换成 true 或者 false，表示是否为 Modern 模式打包，而对于",(0,s.jsx)(n.code,{children:'"__VITE_PRELOAD__"'}),"，Vite 会在 ",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/importAnalysisBuild.ts#L208",target:"_blank",rel:"noopener noreferrer",children:"generateBundle"})," 阶段，分析出 a 模块所有依赖文件(包括 CSS)，将依赖文件名的数组作为 preload 工具函数的第二个参数。"]}),"\n",(0,s.jsx)(n.p,{children:"同时，对于 Vite 独有的 import.meta.glob 语法，也会在这个插件中进行编译，如:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const modules = import.meta.glob('./dir/*.js')\n"})}),"\n",(0,s.jsx)(n.p,{children:"会通过插件转换成下面这段代码:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n  './dir/bar.js': () => import('./dir/bar.js')\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["具体的实现在 ",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/075128a8dd0a2680540179dad2277a797f793199/packages/vite/src/node/importGlob.ts#L11",target:"_blank",rel:"noopener noreferrer",children:"transformImportGlob"})," 函数中，除了被该插件使用外，这个函数被还依赖预构建、开发环境 import 分析等核心流程使用，属于一类比较底层的逻辑，感兴趣的同学可以精读一下这部分的实现源码。"]}),"\n",(0,s.jsxs)(n.h4,{id:"38-js-压缩插件",children:["3.8 JS 压缩插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#38-js-压缩插件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Vite 中提供了两种 JS 代码压缩的工具，即 Esbuild 和 Terser，分别由两个插件插件实现:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"vite:esbuild-transpile"})," (",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/esbuild.ts#L219",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),")。在 renderChunk 阶段，调用 Esbuild 的 transform API，并指定 minify 参数，从而实现 JS 的压缩。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"vite:terser"}),"(",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/terser.ts#L23",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),")。同样也在 renderChunk 阶段，Vite 会单独的 Worker 进程中调用 Terser 进行 JS 代码压缩。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"39-构建报告插件",children:["3.9 构建报告插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#39-构建报告插件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"主要由三个插件输出构建报告:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"vite:manifest"}),"(",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/manifest.ts",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),")。提供打包后的各种资源文件及其关联信息，如下内容所示:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// manifest.json\n{\n  "index.html": {\n    "file": "assets/index.8edffa56.js",\n    "src": "index.html",\n    "isEntry": true,\n    "imports": [\n      // JS 引用\n      "_vendor.71e8fac3.js"\n    ],\n    "css": [\n      // 样式文件应用\n      "assets/index.458f9883.css"\n    ],\n    "assets": [\n      // 静态资源引用\n      "assets/img.9f0de7da.png"\n    ]\n  },\n  "_vendor.71e8fac3.js": {\n    "file": "assets/vendor.71e8fac3.js"\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"vite:ssr-manifest"}),"(",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/manifest.ts",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),")。提供每个模块与 chunk 之间的映射关系，方便 SSR 时期通过渲染的组件来确定哪些 chunk 会被使用，从而按需进行预加载。最后插件输出的内容如下:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// ssr-manifest.json\n{\n  "node_modules/object-assign/index.js": [\n    "/assets/vendor.71e8fac3.js"\n  ],\n  "node_modules/object-assign/index.js?commonjs-proxy": [\n    "/assets/vendor.71e8fac3.js"\n  ],\n  // 省略其它模块信息\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"vite:reporter"}),"(",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/reporter.ts",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),")。主要提供打包时的命令行构建日志:"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h3,{id:"4-开发环境特有插件",children:["4. 开发环境特有插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-开发环境特有插件",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"41-客户端环境变量注入插件",children:["4.1 客户端环境变量注入插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-客户端环境变量注入插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在开发环境中，Vite 会自动往 HTML 中注入一段 client 的脚本(",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/server/middlewares/indexHtml.ts#L159",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'<script type="module" src="/@vite/client"><\/script>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这段脚本主要提供",(0,s.jsx)(n.code,{children:"注入环境变量"}),"、",(0,s.jsx)(n.code,{children:"处理 HMR 更新逻辑"}),"、",(0,s.jsx)(n.code,{children:"构建出现错误时提供报错界面"}),"等功能，而我们这里要介绍的",(0,s.jsx)(n.code,{children:"vite:client-inject"}),"就是来完成时环境变量的注入，将 client 脚本中的",(0,s.jsx)(n.code,{children:"__MODE__"}),"、",(0,s.jsx)(n.code,{children:"__BASE__"}),"、",(0,s.jsx)(n.code,{children:"__DEFINE__"}),"等等字符串替换为运行时的变量，实现环境变量以及 HMR 相关上下文信息的注入，",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/clientInjections.ts",target:"_blank",rel:"noopener noreferrer",children:"点击查看插件实现"}),"。"]}),"\n",(0,s.jsxs)(n.h4,{id:"42-开发阶段-import-分析插件",children:["4.2 开发阶段 import 分析插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-开发阶段-import-分析插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["最后，Vite 会在开发阶段加入 import 分析插件，即",(0,s.jsx)(n.code,{children:"vite:import-analysis"}),"。与之前所介绍的",(0,s.jsx)(n.code,{children:"vite:build-import-analysis"}),"相对应，主要处理 import 语句相关的解析和重写，但",(0,s.jsx)(n.code,{children:"vite:import-analysis"})," 插件的关注点会不太一样，主要围绕 Vite 开发阶段的各项特性来实现，我们可以来梳理一下这个插件需要做哪些事情:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"对 bare import，将路径名转换为真实的文件路径，如:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 转换前\nimport 'foo'\n// 转换后\n// tip: 如果是预构建的依赖，则会转换为预构建产物的路径\nimport '/@fs/project/node_modules/foo/dist/foo.js'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["主要调用 ",(0,s.jsx)(n.code,{children:"PluginContainer"}),"的上下文对象方法即",(0,s.jsx)(n.code,{children:"this.resolve"}),"实现，这个方法会调用所有插件的 resolveId 方法，包括之前介绍的",(0,s.jsx)(n.code,{children:"vite:pre-alias"}),"和",(0,s.jsx)(n.code,{children:"vite:resolve"}),"，完成路径解析的核心逻辑，",(0,s.jsx)(n.a,{href:"/vite:html-inline-script-proxy",children:"点击查看实现"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["对于 HMR 的客户端 API，即 ",(0,s.jsx)(n.code,{children:"import.meta.hot"}),"，Vite 在识别到这样的 import 语句后，一方面会注入 import.meta.hot 的实现，因为浏览器原生并不具备这样的 API，",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/importAnalysis.ts#L502",target:"_blank",rel:"noopener noreferrer",children:"点击查看注入代码"}),"；另一方面会识别 accept 方法，并判断 accept 是否为",(0,s.jsx)(n.code,{children:"接受自身更新"}),"的类型(如果对 HMR 更新类型还不了解，可以回顾一下",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7050063811973218341/section/7065976180020609032",target:"_blank",rel:"noopener noreferrer",children:"第十三节"}),"的内容)，如果是，则标记为上",(0,s.jsx)(n.code,{children:"isSelfAccepting"})," 的 flag，便于 HMR 在服务端进行更新时进行",(0,s.jsx)(n.code,{children:"HMR Boundary"}),"的查找。对于具体的查找过程，下一节会详细介绍。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["对于全局环境变量读取语句，即 ",(0,s.jsx)(n.code,{children:"import.meta.env"}),"，Vite 会注入 ",(0,s.jsx)(n.code,{children:"import.meta.env"})," 的实现，也就是如下的",(0,s.jsx)(n.code,{children:"env"}),"字符串:"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// config 即解析完的配置\nlet env = `import.meta.env = ${JSON.stringify({\n  ...config.env,\n  SSR: !!ssr\n})};`\n// 对用户配置的 define 对象中，将带有 import.meta.env 前缀的全局变量挂到 import.meta.env 对象上\nfor (const key in config.define) {\n  if (key.startsWith(`import.meta.env.`)) {\n    const val = config.define[key]\n    env += `${key} = ${\n      typeof val === 'string' ? val : JSON.stringify(val)\n    };`\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["对于",(0,s.jsx)(n.code,{children:"import.meta.glob"}),"语法，Vite 同样会调用之前提到的",(0,s.jsx)(n.code,{children:"transformImportGlob"})," 函数来进行语法转换，但与生产环境的处理不同，在转换之后，Vite 会将该模块通过 glob 导入的依赖模块记录在 server 实例上，以便于 HMR 更新的时候能得到更准确的模块依赖信息，",(0,s.jsx)(n.a,{href:"https://github.com/vitejs/vite/blob/v2.7.0/packages/vite/src/node/plugins/importAnalysis.ts#L324",target:"_blank",rel:"noopener noreferrer",children:"点击查看实现"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"好，本小节的内容讲完了。"}),"\n",(0,s.jsxs)(n.p,{children:["这一节我们介绍了 Vite 的插件机制实现以及各个编译插件的作用和实现，信息密度比较大，需要你对照着官方的代码好好梳理一遍。其中，你需要重点掌握",(0,s.jsx)(n.strong,{children:"PluginContainer 的实现机制"}),"和 ",(0,s.jsx)(n.strong,{children:"Vite 内置插件各自的作用"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"首先，PluginContainer 主要由两部分实现，包括 Rollup 插件钩子的调度和插件钩子内部的 Context 上下文对象实现，总体上模拟了 Rollup 的插件机制。"}),"\n",(0,s.jsxs)(n.p,{children:["其次，Vite 内置的插件包括四大类: ",(0,s.jsx)(n.strong,{children:"别名插件"}),"、",(0,s.jsx)(n.strong,{children:"核心构建插件"}),"、",(0,s.jsx)(n.strong,{children:"生产环境特有插件"}),"和",(0,s.jsx)(n.strong,{children:"开发环境特有插件"}),"。这些插件包含了 Vite 核心的编译逻辑，可以说是 Vite 作为构建工具的命脉所在，希望你能对照本小节的内容及其对应的源码链接，了解各个插件的作用。"]}),"\n",(0,s.jsx)(n.p,{children:"此外，在学习这些插件的过程中，我们切忌扎到众多繁琐的实现细节中，要尽可能抓关键的实现思路，来高效理解插件背后的原理，这样学习效率会更高。进一步来讲，在你理解了各个插件的实现原理之后，如果遇到某些场景下需要调试某些插件的代码，你也可以做到有的放矢。"}),"\n",(0,s.jsx)(n.p,{children:"最后，欢迎大家在评论区记录自己的学习收获和心得，也欢迎大家来一起讨论，把这部分的难点啃下来，让你对 Vite 底层的理解更上一层楼！"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let d=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F22.%E6%8F%92%E4%BB%B6%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%9A%E4%BB%8E%E6%95%B4%E4%BD%93%E5%88%B0%E5%B1%80%E9%83%A8%EF%BC%8C%E7%90%86%E8%A7%A3%20Vite%20%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BC%96%E8%AF%91%E8%83%BD%E5%8A%9B.md"]={toc:[{text:"插件容器",id:"插件容器",depth:2},{text:"插件工作流概览",id:"插件工作流概览",depth:2},{text:"插件功能梳理",id:"插件功能梳理",depth:2},{text:"1. 别名插件",id:"1-别名插件",depth:3},{text:"2. 核心构建插件",id:"2-核心构建插件",depth:3},{text:"2.1 module preload 特性的 Polyfill",id:"21-module-preload-特性的-polyfill",depth:4},{text:"2.2 路径解析插件",id:"22-路径解析插件",depth:4},{text:"2.3 内联脚本加载插件",id:"23-内联脚本加载插件",depth:4},{text:"2.4 CSS 编译插件",id:"24-css-编译插件",depth:4},{text:"2.5 Esbuild 转译插件",id:"25-esbuild-转译插件",depth:4},{text:"2.6 静态资源加载插件",id:"26-静态资源加载插件",depth:4},{text:"3. 生产环境特有插件",id:"3-生产环境特有插件",depth:3},{text:"3.1 全局变量替换插件",id:"31-全局变量替换插件",depth:4},{text:"3.2 CSS 后处理插件",id:"32-css-后处理插件",depth:4},{text:"3.3 HTML 构建插件",id:"33-html-构建插件",depth:4},{text:"3.3 Commonjs 转换插件",id:"33-commonjs-转换插件",depth:4},{text:"3.4 date-uri 插件",id:"34-date-uri-插件",depth:4},{text:"3.5 dynamic-import-vars 插件",id:"35-dynamic-import-vars-插件",depth:4},{text:"3.6 import-meta-url 支持插件",id:"36-import-meta-url-支持插件",depth:4},{text:"3.7 生产环境 import 分析插件",id:"37-生产环境-import-分析插件",depth:4},{text:"3.8 JS 压缩插件",id:"38-js-压缩插件",depth:4},{text:"3.9 构建报告插件",id:"39-构建报告插件",depth:4},{text:"4. 开发环境特有插件",id:"4-开发环境特有插件",depth:3},{text:"4.1 客户端环境变量注入插件",id:"41-客户端环境变量注入插件",depth:4},{text:"4.2 开发阶段 import 分析插件",id:"42-开发阶段-import-分析插件",depth:4},{text:"小结",id:"小结",depth:2}],title:"22.插件流水线：从整体到局部，理解 Vite 的核心编译能力",headingTitle:"22.插件流水线：从整体到局部，理解 Vite 的核心编译能力",frontmatter:{}}}}]);