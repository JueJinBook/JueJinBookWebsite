"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18905"],{334027:function(n,e,s){s.r(e),s.d(e,{default:()=>c});var r=s(552676),t=s(740453);let a=s.p+"static/image/f9f2bc4c93f85516d75f80f4e8f8a40c.cd07c232.webp";function o(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",img:"img",code:"code",pre:"pre",br:"br",ol:"ol",li:"li",blockquote:"blockquote",ul:"ul"},(0,t.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"10结构型适配器模式兼容代码就是一把梭",children:["10.结构型：适配器模式——兼容代码就是一把梭",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10结构型适配器模式兼容代码就是一把梭",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["适配器模式通过",(0,r.jsx)(e.strong,{children:"把一个类的接口变换成客户端所期待的另一种接口"}),"，可以帮我们解决",(0,r.jsx)(e.strong,{children:"不兼容"}),"的问题。"]}),"\n",(0,r.jsxs)(e.h2,{id:"生活中的适配器",children:["生活中的适配器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#生活中的适配器",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"前段时间用了很久的 iPhone 6s丢了，请假跑出去买了台 iPhone X。结果有天听歌的时候发现X的耳机孔竟然是方形的，长这样："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"而重度 iPhone 6s 用户&耳机发烧友的耳机线，可能是如图一所示，没错，它们都是圆头耳机，意识到这一点的时候，我佛了。"}),"\n",(0,r.jsxs)(e.p,{children:["此时我好像只能在重新买一批耳机（很有可能同款耳机并没有方头的款式）和重新买一台手机之间做选择了。好在我不是一个普通的倒霉蛋，我学过设计模式，设计模式告诉我这种",(0,r.jsx)(e.strong,{children:"实际接口与目标接口不匹配的尴尬"}),"可以用一个叫",(0,r.jsx)(e.strong,{children:"适配器"}),"的东西来化解。打开万能的淘宝一搜，还真有，如图二所示。"]}),"\n",(0,r.jsx)(e.p,{children:"只要装上它，圆头耳机就可以完美适配方形插槽，最终效果如图三所示。"}),"\n",(0,r.jsx)(e.p,{children:"绝了，正合我意！赶紧买一个来救火，从此又可以开心地为圆头耳机氪金啦~"}),"\n",(0,r.jsxs)(e.p,{children:["大家现在回顾楼上这波操作，这个耳机转换头做的事情，是不是就是我们开头说的把一个",(0,r.jsx)(e.code,{children:"类"}),"（iPhone 新机型）的",(0,r.jsx)(e.code,{children:"接口"}),"（方形）变换成",(0,r.jsx)(e.code,{children:"客户端"}),"（用户）所期待的另一种",(0,r.jsx)(e.code,{children:"接口"}),"（圆形）？"]}),"\n",(0,r.jsxs)(e.p,{children:["最终达到的效果，就是",(0,r.jsx)(e.code,{children:"用户"}),"（我）可以像使用 iPhone 6s 插口一样使用 iPhoneX 的插口，而不用感知两者间的差异。我们设计模式中的适配器，和楼上这个适配器做的事情可以说是一模一样，同样具有化腐朽为神奇的力量。"]}),"\n",(0,r.jsxs)(e.h2,{id:"兼容接口就是一把梭适配器的业务场景",children:["兼容接口就是一把梭——适配器的业务场景",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#兼容接口就是一把梭适配器的业务场景",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"大家知道我们现在有一个非常好用异步方案叫fetch，它的写法比ajax优雅很多。因此在不考虑兼容性的情况下，我们更愿意使用fetch、而不是使用ajax来发起异步请求。李雷是拜fetch教的忠实信徒，为了能更好地使用fetch，他封装了一个基于fetch的http方法库："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"\nexport default class HttpUtils {\n  // get方法\n  static get(url) {\n    return new Promise((resolve, reject) => {\n      // 调用fetch\n      fetch(url)\n        .then(response => response.json())\n        .then(result => {\n          resolve(result)\n        })\n        .catch(error => {\n          reject(error)\n        })\n    })\n  }\n  \n  // post方法，data以object形式传入\n  static post(url, data) {\n    return new Promise((resolve, reject) => {\n      // 调用fetch\n      fetch(url, {\n        method: 'POST',\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        // 将object类型的数据格式化为合法的body参数\n        body: this.changeData(data)\n      })\n        .then(response => response.json())\n        .then(result => {\n          resolve(result)\n        })\n        .catch(error => {\n          reject(error)\n        })\n    })\n  }\n  \n  // body请求体的格式化方法\n  static changeData(obj) {\n    var prop,\n      str = ''\n    var i = 0\n    for (prop in obj) {\n      if (!prop) {\n        return\n      }\n      if (i == 0) {\n        str += prop + '=' + obj[prop]\n      } else {\n        str += '&' + prop + '=' + obj[prop]\n      }\n      i++\n    }\n    return str\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"当我想使用 fetch 发起请求时，只需要这样轻松地调用，而不必再操心繁琐的数据配置和数据格式化："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 定义目标url地址\nconst URL = "xxxxx"\n// 定义post入参\nconst params = {\n    ...\n}\n\n// 发起post请求\n const postResponse = await HttpUtils.post(URL,params) || {}\n \n // 发起get请求\n const getResponse = await HttpUtils.get(URL) || {}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["真是个好用的方法库！老板看了李雷的 HttpUtils 库，喜上眉梢——原来老板也是个拜 fetch 教。老板说李雷，咱们公司以后要做潮流公司了，写代码不再考虑兼容性，我希望你能",(0,r.jsx)(e.strong,{children:"把公司所有的业务的网络请求都迁移到你这个 HttpUtils 上来"}),"，这样以后你只用维护这一个库了，也方便。李雷一听，悲从中来——他是该公司的第 99 代员工，对远古时期的业务一无所知。而该公司第1代员工封装的网络请求库，是基于 XMLHttpRequest 的，差不多长这样："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function Ajax(type, url, data, success, failed){\n    // 创建ajax对象\n    var xhr = null;\n    if(window.XMLHttpRequest){\n        xhr = new XMLHttpRequest();\n    } else {\n        xhr = new ActiveXObject('Microsoft.XMLHTTP')\n    }\n \n   ...(此处省略一系列的业务逻辑细节)\n   \n   var type = type.toUpperCase();\n    \n    // 识别请求类型\n    if(type == 'GET'){\n        if(data){\n          xhr.open('GET', url + '?' + data, true); //如果有数据就拼接\n        } \n        // 发送get请求\n        xhr.send();\n \n    } else if(type == 'POST'){\n        xhr.open('POST', url, true);\n        // 如果需要像 html 表单那样 POST 数据，使用 setRequestHeader() 来添加 http 头。\n        xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n        // 发送post请求\n        xhr.send(data);\n    }\n \n    // 处理返回数据\n    xhr.onreadystatechange = function(){\n        if(xhr.readyState == 4){\n            if(xhr.status == 200){\n                success(xhr.responseText);\n            } else {\n                if(failed){\n                    failed(xhr.status);\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"实现逻辑我们简单描述了一下，这个不是重点，重点是它是这样调用的："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 发送get请求\nAjax('get', url地址, post入参, function(data){\n    // 成功的回调逻辑\n}, function(error){\n    // 失败的回调逻辑\n})\n"})}),"\n",(0,r.jsx)(e.p,{children:"李雷佛了 —— 不仅接口名不同，入参方式也不一样，这手动改要改到何年何日呢？"}),"\n",(0,r.jsxs)(e.p,{children:["还好李雷学过设计模式，他立刻联想到了专门为我们",(0,r.jsx)(e.strong,{children:"抹平差异"}),"的适配器模式。要把老代码迁移到新接口，不一定要挨个儿去修改每一次的接口调用——正如我们想用 iPhoneX + 旧耳机听歌，不必挨个儿去改造耳机一样，我们只需要在引入接口时进行",(0,r.jsx)(e.strong,{children:"一次适配"}),"，便可轻松地 cover 掉业务里可能会有的",(0,r.jsx)(e.strong,{children:"多次调用"}),"（具体的解析在注释里）："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Ajax适配器函数，入参与旧接口保持一致\nasync function AjaxAdapter(type, url, data, success, failed) {\n    const type = type.toUpperCase()\n    let result\n    try {\n         // 实际的请求全部由新接口发起\n         if(type === 'GET') {\n            result = await HttpUtils.get(url) || {}\n        } else if(type === 'POST') {\n            result = await HttpUtils.post(url, data) || {}\n        }\n        // 假设请求成功对应的状态码是1\n        result.statusCode === 1 && success ? success(result) : failed(result.statusCode)\n    } catch(error) {\n        // 捕捉网络错误\n        if(failed){\n            failed(error.statusCode);\n        }\n    }\n}\n\n// 用适配器适配旧的Ajax方法\nasync function Ajax(type, url, data, success, failed) {\n    await AjaxAdapter(type, url, data, success, failed)\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"如此一来，我们只需要编写一个适配器函数AjaxAdapter，并用适配器去承接旧接口的参数，就可以实现新旧接口的无缝衔接了~"}),"\n",(0,r.jsxs)(e.h2,{id:"生产实践axios中的适配器",children:["生产实践：axios中的适配器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#生产实践axios中的适配器",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["数月之后，李雷的老板发现了网络请求神库axios，于是团队的方案又整个迁移到了axios——对于心中有适配器的李雷来说，这现在已经根本不是个事儿。不过本小节我们要聊的可不再是“如何使现有接口兼容axios”了（这招我们上个小节学过了）。此处引出axios，一是因为大家对它足够熟悉（不熟悉的同学，点",(0,r.jsx)(e.a,{href:"https://github.com/axios/axios",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"可以快速熟悉一下~），二是因为axios本身就用到了我们的",(0,r.jsx)(e.strong,{children:"适配器模式"}),"，它的兼容方案值得我们学习和借鉴。",(0,r.jsx)(e.br,{}),"\n","在使用axios时，作为用户我们只需要掌握以下面三个最常用的接口为代表的一套api："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Make a request for a user with a given ID\naxios.get('/user?ID=12345')\n  .then(function (response) {\n    // handle success\n    console.log(response);\n  })\n  .catch(function (error) {\n    // handle error\n    console.log(error);\n  })\n  .then(function () {\n    // always executed\n  })   \n     \naxios.post('/user', {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  })\n  .then(function (response) {\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });   \n\naxios({\n  method: 'post',\n  url: '/user/12345',\n  data: {\n    firstName: 'Fred',\n    lastName: 'Flintstone'\n  }\n})\n"})}),"\n",(0,r.jsxs)(e.p,{children:["便可轻松地发起各种姿势的网络请求，而不用去关心底层的实现细节。",(0,r.jsx)(e.br,{}),"\n","除了简明优雅的api之外，axios 强大的地方还在于，它不仅仅是一个局限于浏览器端的库。在Node环境下，我们尝试调用上面的 api，会发现它照样好使 —— axios 完美地",(0,r.jsx)(e.strong,{children:"抹平了两种环境下api的调用差异"}),"，靠的正是对适配器模式的灵活运用。"]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.a,{href:"https://github.com/axios/axios/blob/master/lib/core/Axios.js",target:"_blank",rel:"noopener noreferrer",children:"axios 的核心逻辑"}),"中，我们可以注意到实际上派发请求的是 ",(0,r.jsx)(e.a,{href:"https://github.com/axios/axios/blob/master/lib/core/dispatchRequest.js",target:"_blank",rel:"noopener noreferrer",children:"dispatchRequest 方法"}),"。该方法内部其实主要做了两件事："]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"数据转换，转换请求体/响应体，可以理解为数据层面的适配；"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"调用适配器。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"调用适配器的逻辑如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 若用户未手动配置适配器，则使用默认的适配器\nvar adapter = config.adapter || defaults.adapter;\n  \n  // dispatchRequest方法的末尾调用的是适配器方法\n  return adapter(config).then(function onAdapterResolution(response) {\n    // 请求成功的回调\n    throwIfCancellationRequested(config);\n\n    // 转换响应体\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    // 请求失败的回调\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // 转换响应体\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n"})}),"\n",(0,r.jsx)(e.p,{children:"大家注意注释的第一行，“若用户未手动配置适配器，则使用默认的适配器”。手动配置适配器允许我们自定义处理请求，主要目的是为了使测试更轻松。"}),"\n",(0,r.jsxs)(e.p,{children:["实际开发中，我们使用默认适配器的频率更高。默认适配器在",(0,r.jsx)(e.a,{href:"https://github.com/axios/axios/blob/master/lib/defaults.js",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(e.code,{children:"axios/lib/default.js"})}),"里是通过",(0,r.jsx)(e.code,{children:"getDefaultAdapter"}),"方法来获取的："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function getDefaultAdapter() {\n  var adapter;\n  // 判断当前是否是node环境\n  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // 如果是node环境，调用node专属的http适配器\n    adapter = require('./adapters/http');\n  } else if (typeof XMLHttpRequest !== 'undefined') {\n    // 如果是浏览器环境，调用基于xhr的适配器\n    adapter = require('./adapters/xhr');\n  }\n  return adapter;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"我们再来看看 Node 的 http 适配器和 xhr 适配器大概长啥样："}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"http 适配器："}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"module.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    // 具体逻辑\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"xhr 适配器："}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"module.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    // 具体逻辑\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["具体逻辑啥样，咱们目前先不关心，有兴趣的同学，可以狠狠地点",(0,r.jsx)(e.a,{href:"https://github.com/axios/axios/tree/master/lib/adapters",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"阅读源码。咱们现在就注意两个事儿："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"两个适配器的入参都是 config；"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"两个适配器的出参都是一个 Promise。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-!",children:"Tips：要是仔细读了源码，会发现两个适配器中的 Promise 的内部结构也是如出一辙。\n"})}),"\n",(0,r.jsx)(e.p,{children:"这么一来，通过 axios 发起跨平台的网络请求，不仅调用的接口名是同一个，连入参、出参的格式都只需要掌握同一套。这导致它的学习成本非常低，开发者看了文档就能上手；同时因为足够简单，在使用的过程中也不容易出错，带来了极佳的用户体验，axios 也因此越来越流行。"}),"\n",(0,r.jsx)(e.p,{children:"这正是一个好的适配器的自我修养——把变化留给自己，把统一留给用户。在此处，所有关于 http 模块、关于 xhr 的实现细节，全部被 Adapter 封装进了自己复杂的底层逻辑里，暴露给用户的都是十分简单的统一的东西——统一的接口，统一的入参，统一的出参，统一的规则。用起来就是一个字 —— 爽！"}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本节我们除了针对适配器的原理、实践及应用场景进行讨论之外，还花了不少力气来讲 axios。这个操作可能会使一部分不太熟悉 axios 的同学阅读起来更加吃力——因为要想读懂这一节，你或许不得不点开我穿插进去的源码/文档链接先去尝试理解 axios —— 但这其实正是我想鼓励大家去做的事情。"}),"\n",(0,r.jsxs)(e.p,{children:["在",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/6844733750048210957",target:"_blank",rel:"noopener noreferrer",children:"性能小册"}),"的开篇，我说过，希望大家都能去读“纸的背面”。这个“纸的背面”不仅仅是说代码之外的东西，它也可以是一些超越这本书的东西 —— 楼上吹了那么多 axios 的“彩虹屁”，难道本节是 axios 大型夸夸群现场吗？难道 axios 真的完美无缺，无可替代吗？不是的。"]}),"\n",(0,r.jsx)(e.p,{children:"笔者洋洋洒洒这么多字，无非是希望给大家打开一个窗口 —— 在过去半年多和读者有直接沟通的这些时间里，我知道很多同学是不读源码的。这个“不读”不一定是不想读，可能只是不敢读，或者说读不动。无论是出于什么原因，在这里我都想告诉大家，开卷有益，源码是非常好的学习材料，它能教会你的东西，比你想象中多得多。"}),"\n",(0,r.jsx)(e.p,{children:"适配器模式的思想可以说是遍地开花，稍微多看几个库，你会发现不仅 axios 在用适配器，其它库也在用。如果哪怕只有一个同学因为今天读了这一节，对这个“看起来很厉害”的 axios 产生了好奇，或者说对读源码这件事情萌生了兴趣、进而刻意地去培养了自己的阅读习惯，那么你在繁忙的工作/学业中抽出的宝贵的用来阅读这一节内容的时间就没有白费，这本小册也算不负使命、远远大于它本身的价值了。"}),"\n",(0,r.jsx)(e.p,{children:"设计模式这座山，诸位已经翻过了半山腰。剩下的路，一起加油！"}),"\n",(0,r.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(o,{...n})}):o(n)}let c=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["JavaScript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F10.%E7%BB%93%E6%9E%84%E5%9E%8B%EF%BC%9A%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%85%BC%E5%AE%B9%E4%BB%A3%E7%A0%81%E5%B0%B1%E6%98%AF%E4%B8%80%E6%8A%8A%E6%A2%AD.md"]={toc:[{text:"生活中的适配器",id:"生活中的适配器",depth:2},{text:"兼容接口就是一把梭——适配器的业务场景",id:"兼容接口就是一把梭适配器的业务场景",depth:2},{text:"生产实践：axios中的适配器",id:"生产实践axios中的适配器",depth:2},{text:"小结",id:"小结",depth:2}],title:"10.结构型：适配器模式——兼容代码就是一把梭",headingTitle:"10.结构型：适配器模式——兼容代码就是一把梭",frontmatter:{}}}}]);