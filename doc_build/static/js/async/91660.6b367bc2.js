"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["91660"],{92299:function(e,t,n){e.exports=n.p+"static/image/89665eeceef801428231ab09c9a8b0d4.e52a5b7d.webp"},87005:function(e,t,n){n.r(t),n.d(t,{default:()=>Q});var s=n(552676),a=n(740453);let r=n.p+"static/image/7dd82428570c0f34d8c8c2a502ac0af6.74f34a3a.webp",c=n.p+"static/image/083e336c157e6c77ca6976abb1a754ed.38d8603a.webp",i=n.p+"static/image/55d17e99d21cf27becfd1754720c6633.4ca6ecd7.webp",d=n.p+"static/image/25d55f2c973d80b7c11025b11d74f81b.6bbc544f.webp",l=n.p+"static/image/568a94522900ba65358eb4380524570f.71f3e0bc.webp",p=n.p+"static/image/9a869b5fee8178c18ade1d05b53d5c45.1a4ba353.webp",o=n.p+"static/image/802c858de29d1bac4cd8208f5d8c1b2f.d323933c.webp",x=n.p+"static/image/5d9ebfeaa17c99200f0201ba0514d4e7.a26202e0.webp",j=n.p+"static/image/ea96eab2a6ab556dd968e809e18e70ac.62611b77.webp",u=n.p+"static/image/5e6796df6a352ecdfcccd4db4871e424.562e23d7.webp",h=n.p+"static/image/ff9f420b983828aa93ae67dbe287c8ba.cb4161c3.webp",b=n.p+"static/image/9c48b3ec40d2d0dc568436573817913f.646b99b1.webp",f=n.p+"static/image/d4736d1188b3336905f04c4301e8d20f.4dc9304c.webp",g=n.p+"static/image/1316e2135fa24d80972f04fa89676f14.d8d74551.webp",S=n.p+"static/image/40dbcfd7b8b1a700a8e37ad551740fc5.3ec68a1c.webp",m=n.p+"static/image/73a029e53324cf06b488595b2a89cb14.809a87c1.webp",w=n.p+"static/image/9d8e1486a69d6662f0fb85804939aa1c.42b40183.webp",z=n.p+"static/image/79be2ad94d5c650f40221da262396a28.30e8570e.webp",v=n.p+"static/image/bf4fa38c19c56af73bf321a91990790a.53ab1bec.webp",E=n.p+"static/image/3e88cd8e5779f4fc461ff299355d6b86.3d65f6a7.webp",y=n.p+"static/image/8129a97bea2fefdf3be86f8e82c07d6e.637012c9.gif";var B=n(92299);let A=n.p+"static/image/321a91be3fc8d7c6eafa899f2a41656f.ceeb1689.webp",k=n.p+"static/image/9abcb325ff39bc6d10cad6a8b37e2072.2fd32441.gif",_=n.p+"static/image/0bc3a44ea7b7d466023f09c800f6454d.fc739474.webp",O=n.p+"static/image/cffdda16e34f9ba5e4c46bb3458a5b62.38c7b4fa.webp",N=n.p+"static/image/3a6491a2c2ec3fd7d57cb4e3d482e2b0.7f6f4a1e.webp",R=n.p+"static/image/0ae77c8052acdc2381fafa7108ffd518.71f78f10.webp",C=n.p+"static/image/928be14cbe9e79d744583f1851b124c6.5e1e44c5.webp",X=n.p+"static/image/5e9afe73b16625f20f1f89c818506c9c.98e5c08a.webp",F=n.p+"static/image/271d37029420a167551888a2db9b26f9.f451371d.webp",M=n.p+"static/image/4689fe5d398ffe5f91c71a841957d26c.27f58ee0.webp",P=n.p+"static/image/918af1a3a6c4d9b3f428d5d7acd4b2a1.100761c5.webp",T=n.p+"static/image/a60111b512f94d9ff3cdab3c62f4d349.7347ca51.webp",Z=n.p+"static/image/e319563f5623a9a2360549afbf63a3e7.a35ec1c9.webp";function G(e){let t=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.h1,{id:"第47章手写一个zustand",children:["第47章—手写一个Zustand",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#第47章手写一个zustand",children:"#"})]}),"\n",(0,s.jsx)(t.p,{children:"\uFEFF提到状态管理，大家可能首先想到的是 redux。"}),"\n",(0,s.jsx)(t.p,{children:"redux 是老牌状态管理库，能完成各种基本功能，并且有着庞大的中间件生态来扩展额外功能。"}),"\n",(0,s.jsx)(t.p,{children:"但 redux 经常被人诟病它的使用繁琐。"}),"\n",(0,s.jsx)(t.p,{children:"近两年，React 社区出现了很多新的状态管理库，比如 zustand、jotai、recoil 等，都完全能替代 redux，而且更简单。"}),"\n",(0,s.jsx)(t.p,{children:"zustand 算是其中最流行的一个。"}),"\n",(0,s.jsx)(t.p,{children:"看 star 数，redux 有 60k，而 zustand 也有 38k 了："}),"\n",(0,s.jsx)(t.p,{children:"redux："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:Z,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"zustand："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"看 npm 包的周下载量，redux 有 880w，而 zustand 也有 260w 了："}),"\n",(0,s.jsx)(t.p,{children:"redux："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"zustand："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"从各方面来说，zustand 都在快速赶超 redux。"}),"\n",(0,s.jsx)(t.p,{children:"那 zustand 为什么会火起来呢？"}),"\n",(0,s.jsx)(t.p,{children:"我觉得主要是因为简单，zustand 用起来真的是没有什么学习成本，没有 redux 的 action、reducer 等概念。"}),"\n",(0,s.jsx)(t.p,{children:"而且功能很强大，zustand 也有中间件，可以给它额外扩展功能。"}),"\n",(0,s.jsx)(t.p,{children:"既然功能上能替代 redux，那为什么不选择一个更简单的呢？"}),"\n",(0,s.jsx)(t.p,{children:"下面我们就来试试看："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"npx create-react-app zustand-test\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:F,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"用 cra 创建个 react 项目。"}),"\n",(0,s.jsx)(t.p,{children:"进入项目把它跑起来："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"npm run start\n"})}),"\n",(0,s.jsx)(t.p,{children:"浏览器访问下："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:X,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"然后安装 zustand:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"npm install --save zustand\n"})}),"\n",(0,s.jsx)(t.p,{children:"改下 App.js"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import { create } from 'zustand'\n\nconst useXxxStore = create((set) => ({\n  aaa: '',\n  bbb: '',\n  updateAaa: (value) => set(() => ({ aaa: value })),\n  updateBbb: (value) => set(() => ({ bbb: value })),\n}))\n\nexport default function App() {\n  const updateAaa = useXxxStore((state) => state.updateAaa)\n  const aaa = useXxxStore((state) => state.aaa)\n\n  return (\n    <div>\n        <input\n          onChange={(e) => updateAaa(e.currentTarget.value)}\n          value={aaa}\n        />\n        <Bbb></Bbb>\n    </div>\n  )\n}\n\nfunction Bbb() {\n  return <div>\n    <Ccc></Ccc>\n  </div>\n}\n\nfunction Ccc() {\n  const aaa = useXxxStore((state) => state.aaa)\n  return <p>hello, {aaa}</p>\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"用 create 函数创建一个 store，定义 state 和修改 state 的方法。"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"然后在组件里调用 create 返回的函数，取出属性或者方法在组件里用："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"此外，你还可以调用 subscribe 来添加一个监听器："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"useEffect(() => {\n    useXxxStore.subscribe((state) => {\n        console.log(useXxxStore.getState());\n    })\n}, []);\n"})}),"\n",(0,s.jsx)(t.p,{children:"回调函数可以拿到当前 state，或者调用 store.getState 也可以拿到 state。"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"这就是 zustand 的全部用法了，就这么简单。"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"有的同学说，不是还有中间件么？"}),"\n",(0,s.jsx)(t.p,{children:"其实中间件并不是 zustand 自己实现的功能。"}),"\n",(0,s.jsx)(t.p,{children:"你看这个 create 方法的参数，它是一个接受 set、get、store 的三个参数的函数："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"那我们可不可以包一层，自己拿到 get、set、store，对这些做一些修改，之后返回一个接受三个参数的函数呢？"}),"\n",(0,s.jsx)(t.p,{children:"比如这样："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"function logMiddleware(func) {\n  return function(set, get, store) {\n\n    function newSet(...args) {\n      console.log('调用了 set，新的 state：', get());\n      return set(...args)\n    }\n  \n    return func(newSet, get, store)\n  }\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"我接受之前的函数，然后对把 set、get、store 修改之后再调用它："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"这样不就给 zustand 的 set 方法加上了额外的功能么？"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"这个就是中间件，和 redux 的中间件是一样的设计。"}),"\n",(0,s.jsx)(t.p,{children:"它并不需要 zustand 本身做啥支持，只要把 create 的参数设计成一个函数，这个函数接收 set、get 等函作为参数，那就自然支持了中间件。"}),"\n",(0,s.jsx)(t.p,{children:"zustand 内置了一些中间件，比如 immer、persist。"}),"\n",(0,s.jsx)(t.p,{children:"persist 就是同步 store 数据到 localStorage 的。"}),"\n",(0,s.jsx)(t.p,{children:"我们试一下："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"效果如下："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"而且，中间件是可以层层嵌套的："}),"\n",(0,s.jsx)(t.p,{children:"我们把自己写的 log 和内置的 persist 结合起来："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:z,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"效果如下："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"因为中间件不就是修改 set、get 这些参数么，这些 set、get 是可以层层包装的，所以自然中间件也就可以层层嵌套。"}),"\n",(0,s.jsx)(t.p,{children:"redux 和 zustand 的中间件一脉相承，都是很巧妙的设计。"}),"\n",(0,s.jsx)(t.p,{children:"学完了 zustand 的功能后，你觉得写这样一个 zustand 需要多少代码呢？"}),"\n",(0,s.jsx)(t.p,{children:"其实不到 100 行就能搞定。"}),"\n",(0,s.jsx)(t.p,{children:"不信我们试试看："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const createStore = (createState) => {\n    let state;\n    const listeners = new Set();\n  \n    const setState = (partial, replace) => {\n      const nextState = typeof partial === 'function' ? partial(state) : partial\n\n      if (!Object.is(nextState, state)) {\n        const previousState = state;\n\n        if(!replace) {\n            state = (typeof nextState !== 'object' || nextState === null)\n                ? nextState\n                : Object.assign({}, state, nextState);\n        } else {\n            state = nextState;\n        }\n        listeners.forEach((listener) => listener(state, previousState));\n      }\n    }\n  \n    const getState = () => state;\n  \n    const subscribe= (listener) => {\n      listeners.add(listener)\n      return () => listeners.delete(listener)\n    }\n  \n    const destroy= () => {\n      listeners.clear()\n    }\n  \n    const api = { setState, getState, subscribe, destroy }\n\n    state = createState(setState, getState, api)\n\n    return api\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"state 是全局状态，listeners 是监听器。"}),"\n",(0,s.jsx)(t.p,{children:"然后 setState 修改状态、getState 读取状态、subscribe 添加监听器、destroy 清除所有监听器。"}),"\n",(0,s.jsx)(t.p,{children:"这些都很容易理解。"}),"\n",(0,s.jsx)(t.p,{children:"至于 replace，这是 zustand 在 set 状态的时候默认是合并，你也可以传一个 true 改成替换："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"那如果状态变了，如何触发渲染呢？"}),"\n",(0,s.jsx)(t.p,{children:"useState 就可以。"}),"\n",(0,s.jsx)(t.p,{children:"这样写："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"function useStore(api, selector) {\n    const [,forceRender ] = useState(0);\n    useEffect(() => {\n        api.subscribe((state, prevState) => {\n            const newObj = selector(state);\n            const oldobj = selector(prevState);\n\n            if(newObj !== oldobj) {\n                forceRender(Math.random());\n            }       \n        })\n    }, []);\n    return selector(api.getState());\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"selector 说的是传入的这个函数："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"我们用 useState 设置随机数来触发渲染。"}),"\n",(0,s.jsx)(t.p,{children:"监听 state 的变化，变了之后，根据新旧 state 调用 selector 函数的结果，来判断是否需要重新渲染。"}),"\n",(0,s.jsx)(t.p,{children:"然后定义 create 方法："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"export const create = (createState) => {\n    const api = createStore(createState)\n\n    const useBoundStore = (selector) => useStore(api, selector)\n\n    Object.assign(useBoundStore, api);\n\n    return useBoundStore\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"它就是先调用 createStore 创建 store。"}),"\n",(0,s.jsx)(t.p,{children:"然后返回 useStore 的函数，用于组件内调用。"}),"\n",(0,s.jsx)(t.p,{children:"测试下："}),"\n",(0,s.jsx)(t.p,{children:"把 create 函数换成我们自己的，其余代码不变："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"可以看到，功能依然正常："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"我们的 my-zustand 已经能够完美替代 zustand 了。"}),"\n",(0,s.jsx)(t.p,{children:"全部代码如下："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import { useEffect, useState } from \"react\";\n\nconst createStore = (createState) => {\n    let state;\n    const listeners = new Set();\n  \n    const setState = (partial, replace) => {\n      const nextState = typeof partial === 'function' ? partial(state) : partial\n\n      if (!Object.is(nextState, state)) {\n        const previousState = state;\n\n        if(!replace) {\n            state = (typeof nextState !== 'object' || nextState === null)\n                ? nextState\n                : Object.assign({}, state, nextState);\n        } else {\n            state = nextState;\n        }\n        listeners.forEach((listener) => listener(state, previousState));\n      }\n    }\n  \n    const getState = () => state;\n  \n    const subscribe= (listener) => {\n      listeners.add(listener)\n      return () => listeners.delete(listener)\n    }\n  \n    const destroy= () => {\n      listeners.clear()\n    }\n  \n    const api = { setState, getState, subscribe, destroy }\n\n    state = createState(setState, getState, api)\n\n    return api\n}\n\nfunction useStore(api, selector) {\n    const [,forceRender ] = useState(0);\n    useEffect(() => {\n        api.subscribe((state, prevState) => {\n            const newObj = selector(state);\n            const oldobj = selector(prevState);\n\n            if(newObj !== oldobj) {\n                forceRender(Math.random());\n            }       \n        })\n    }, []);\n    return selector(api.getState());\n}\n\nexport const create = (createState) => {\n    const api = createStore(createState)\n\n    const useBoundStore = (selector) => useStore(api, selector)\n\n    Object.assign(useBoundStore, api);\n\n    return useBoundStore\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"60 多行代码。"}),"\n",(0,s.jsx)(t.p,{children:"其实，代码还可以进一步简化。"}),"\n",(0,s.jsxs)(t.p,{children:["react ",(0,s.jsx)(t.a,{href:"https://react.dev/reference/react/useSyncExternalStore",target:"_blank",rel:"noopener noreferrer",children:"有一个 hook"})," 就是用来定义外部 store 的，store 变化以后会触发 rerender："]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"有了这个 useSyncExternalStore 的 hook，我们就不用自己监听 store 变化触发 rerender 了："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"可以简化成这样："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"function useStore(api, selector) {\n    function getState() {\n        return selector(api.getState());\n    }\n    \n    return useSyncExternalStore(api.subscribe, getState)\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"这样，my-zustand 就完美了。"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import { useSyncExternalStore } from \"react\";\n\nconst createStore = (createState) => {\n    let state;\n    const listeners = new Set();\n  \n    const setState = (partial, replace) => {\n      const nextState = typeof partial === 'function' ? partial(state) : partial\n\n      if (!Object.is(nextState, state)) {\n        const previousState = state;\n\n        if(!replace) {\n            state = (typeof nextState !== 'object' || nextState === null)\n                ? nextState\n                : Object.assign({}, state, nextState);\n        } else {\n            state = nextState;\n        }\n        listeners.forEach((listener) => listener(state, previousState));\n      }\n    }\n  \n    const getState = () => state;\n  \n    const subscribe= (listener) => {\n      listeners.add(listener)\n      return () => listeners.delete(listener)\n    }\n  \n    const destroy= () => {\n      listeners.clear()\n    }\n  \n    const api = { setState, getState, subscribe, destroy }\n\n    state = createState(setState, getState, api)\n\n    return api\n}\n\nfunction useStore(api, selector) {\n    function getState() {\n        return selector(api.getState());\n    }\n    \n    return useSyncExternalStore(api.subscribe, getState)\n}\n\nexport const create = (createState) => {\n    const api = createStore(createState)\n\n    const useBoundStore = (selector) => useStore(api, selector)\n\n    Object.assign(useBoundStore, api);\n\n    return useBoundStore\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"有的同学可能会质疑，zustand 的源码就这么点么？"}),"\n",(0,s.jsx)(t.p,{children:"我们调试下就知道了："}),"\n",(0,s.jsx)(t.p,{children:"点击 vscode 的 create a launch.json file，创建一个调试配置："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"改下调试的端口，点击调试启动："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"把 zustand 换成之前的，然后打个断点："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"通过调试，可以看到 create 的实现如下："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"而 useStore 的实现如下："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"唯一的区别就是它用的是一个 shim 包里的，因为它要保证这个 hook 的兼容性。"}),"\n",(0,s.jsx)(t.p,{children:"所以说，我们通过 60 行代码实现的，就是一比一复刻的 zustand。"}),"\n",(0,s.jsx)(t.p,{children:"至此，zustand 还有一个非常大的优点就呼之欲出了：体积小。"}),"\n",(0,s.jsx)(t.p,{children:"一共也没多少代码，压缩后能多大呢？只有 1kb。"}),"\n",(0,s.jsx)(t.p,{children:"最后，zustand 有一个坑点要注意下："}),"\n",(0,s.jsx)(t.p,{children:"当你用了 ts 并且用了中间件，那要这样写，第一次调用不传参数，第二次传："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"源码里确实做了处理："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(t.p,{children:["至于为什么要这样，",(0,s.jsx)(t.a,{href:"https://github.com/pmndrs/zustand/blob/main/docs/guides/typescript.md",target:"_blank",rel:"noopener noreferrer",children:"官方解释"}),"说是为了好做中间件的 ts 类型处理："]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(t.p,{children:"反正功能是一样的，大家记住 ts + middleware 的场景换个写法就好了。"}),"\n",(0,s.jsxs)(t.p,{children:["案例代码上传了",(0,s.jsx)(t.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/hook-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,s.jsxs)(t.h2,{id:"总结",children:["总结",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(t.p,{children:"近几年出了很多可以替代 redux 的优秀状态管理库，zustand 是其中最优秀的一个。"}),"\n",(0,s.jsx)(t.p,{children:"它的特点有很多：体积小、简单、支持中间件扩展。"}),"\n",(0,s.jsx)(t.p,{children:"它的核心就是一个 create 函数，传入 state 来创建 store。"}),"\n",(0,s.jsx)(t.p,{children:"create 返回的函数可以传入 selector，取出部分 state 在组件里用。"}),"\n",(0,s.jsx)(t.p,{children:"它的中间件和 redux 一样，就是一个高阶函数，可以对 get、set 做一些扩展。"}),"\n",(0,s.jsx)(t.p,{children:"zustand 内置了 immer、persist 等中间件，我们也自己写了一个 log 的中间件。"}),"\n",(0,s.jsx)(t.p,{children:"zustand 本身的实现也很简单，就是 getState、setState、subscribe 这些功能，然后再加上 useSyncExternalStore 来触发组件 rerender。"}),"\n",(0,s.jsx)(t.p,{children:"一共也就 60 行代码。"}),"\n",(0,s.jsx)(t.p,{children:"这样一个简单强大、非常流行的状态管理库，你确定不自己手写一个试试么？"})]})}function D(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(G,{...e})}):G(e)}let Q=D;D.__RSPRESS_PAGE_META={},D.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC47%E7%AB%A0%E2%80%94%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAZustand.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第47章—手写一个Zustand",headingTitle:"第47章—手写一个Zustand",frontmatter:{}}}}]);