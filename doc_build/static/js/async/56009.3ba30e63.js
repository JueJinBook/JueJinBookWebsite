"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56009"],{100194:function(n,e,r){r.r(e),r.d(e,{default:()=>h});var c=r(552676),d=r(740453);let i=r.p+"static/image/2cc6a5cba2634fda9cf42b387e6dd520~tplv-k3u1fbpfcp-zoom-1.image.a267cf10.png";function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",strong:"strong",blockquote:"blockquote",h3:"h3",ol:"ol",li:"li",h4:"h4",img:"img"},(0,d.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"16-套娃の艺术如何构造一个通用的-curry-函数",children:["16 套娃の艺术：如何构造一个通用的 curry 函数？",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#16-套娃の艺术如何构造一个通用的-curry-函数",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"上回书说到，柯里化和偏函数一脉相承，两者解决的其实是同一类问题，也就是“调整函数的元”的问题。"}),"\n",(0,c.jsx)(e.p,{children:"我们同时提到了柯里化和偏函数都能够促进“逻辑的复用”，这是因为调整存量函数的元、生成新函数、减少重复传参的这整个过程，本身就是一个逻辑复用的过程，并且很多时候是以高阶函数的形式实现的。"}),"\n",(0,c.jsx)(e.p,{children:"我们在上一节围绕偏函数举了不少例子，本节，我们把重点放在柯里化上。"}),"\n",(0,c.jsxs)(e.h2,{id:"柯里化解决-multiply-函数的参数问题",children:["柯里化解决 multiply 函数的参数问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#柯里化解决-multiply-函数的参数问题",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"既然偏函数和柯里化解决的都是函数的元的问题，那么 multiply 函数一元化为 multiply3，想必也能够用柯里化求解。"}),"\n",(0,c.jsx)(e.p,{children:"大家还记得我们上一节是如何构造一个名为 curry 的高阶函数的吗？这里我们简单回顾下："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 定义高阶函数 curry\nfunction curry(addThreeNum) {\n  // 返回一个嵌套了三层的函数\n  return function addA(a) {\n    // 第一层“记住”参数a\n    return function addB(b) {\n      // 第二层“记住”参数b\n      return function addC(c) {\n        // 第三层直接调用现有函数 addThreeNum\n        return addThreeNum(a, b, c)\n      }\n    }\n  }\n}\n\n// 借助 curry 函数将 add\nconst curriedAddThreeNum = curry(addThreeNum)\n// 输出6，输出结果符合预期\ncurriedAddThreeNum(1)(2)(3)\n"})}),"\n",(0,c.jsx)(e.p,{children:"本着“对拓展开放，对修改封闭”的原则，我们在存量函数 addThreeNum 的基础上进行了层层包装。"}),"\n",(0,c.jsx)(e.p,{children:"本着同样的原则，我们也可以在存量函数 multiply 的基础上做一层包装，实现 multiply3："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 一元函数，一个入参\nfunction multiply(x, y) {\n  return x*y\n}\n\n// 定义一个包装函数，专门用来处理偏函数逻辑\nfunction curry(func) {\n  // 逐层拆解传参步骤 - 第一层\n  return function(x){\n    // 逐层拆解传参步骤 - 第二层\n    return function(y) {\n      // 参数传递完毕，执行回调\n      return func(x, y)\n    }\n  }\n}\nconst multiply3 = curry(multiply)(3)\n\n// 输出6\nmultiply3(2)\n"})}),"\n",(0,c.jsxs)(e.h2,{id:"柯里化的套路",children:["柯里化的“套路”",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#柯里化的套路",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["这里简单复习一道上一节做过的辨析题：",(0,c.jsx)(e.strong,{children:"柯里化和偏函数的区别是什么？"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"柯里化说的是一个 n 元函数变成 n 个一元函数。"}),"\n",(0,c.jsx)(e.p,{children:"偏函数说的是一个 n 元函数变成一个 m(m < n） 元函数。"}),"\n",(0,c.jsx)(e.p,{children:"对于柯里化来说，不仅函数的元发生了变化，函数的数量也发生了变化（1个变成n个）。"}),"\n",(0,c.jsx)(e.p,{children:"对于偏函数来说，仅有函数的元发生了变化（减少了），函数的数量是不变的。"}),"\n",(0,c.jsxs)(e.p,{children:["——引用自本册",(0,c.jsx)(e.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175423003319074876",target:"_blank",rel:"noopener noreferrer",children:"第15节"})]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"也就是说，柯里化函数的特征，在于它是嵌套定义的多个函数，也就是“套娃”。"}),"\n",(0,c.jsxs)(e.p,{children:["因此，",(0,c.jsx)(e.strong,{children:"柯里化的实现思路，我愿称之为“套娃之路”，简称“套路”。"})]}),"\n",(0,c.jsx)(e.p,{children:"这个“套路”有多深？截至目前来看，完全取决于原函数的参数个数。"}),"\n",(0,c.jsx)(e.p,{children:"比如我们的第一个柯里化示例，它是三元函数，就相应地需要套三层："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function curry(addThreeNum) {\n  // 返回一个嵌套了三层的函数\n  return function addA(a) {\n    // 第一层“记住”参数a\n    return function addB(b) {\n      // 第二层“记住”参数b\n      return function addC(c) {\n        // 第三层直接调用现有函数 addThreeNum\n        return addThreeNum(a, b, c)\n      }\n    }\n  }\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"而本节柯里化 multiply 函数，由于此函数是二元函数，curry 就只需要两层："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function curry(func) {\n  // 第一层“记住”参数x\n  return function(x){\n    // 第二层“记住”参数y\n    return function(y) {\n      // 参数传递完毕，执行回调\n      return func(x, y)\n    }\n  }\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"这样看来，似乎 curry 函数怎么写，还得先看回调函数的入参有几个。"}),"\n",(0,c.jsx)(e.p,{children:"如果我的一个应用程序里，有二元函数、三元函数......甚至 n 元函数，它们都想被柯里化，那岂不是要写不计其数个 curry 函数来适配每一个元数了？"}),"\n",(0,c.jsx)(e.p,{children:"这属于是暴力枚举了，这很不函数式呀。"}),"\n",(0,c.jsx)(e.p,{children:"有没有可能， curry 函数内部可以结合入参的情况，自动判断套娃要套几层呢？"}),"\n",(0,c.jsxs)(e.p,{children:["话都说到这儿了，咱也就引出了",(0,c.jsx)(e.strong,{children:"本节的重点，同时也是面试的重点——通用柯里化函数的实现"}),"。"]}),"\n",(0,c.jsxs)(e.h2,{id:"通用柯里化函数自动化的套娃",children:["通用柯里化函数：自动化的“套娃”",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#通用柯里化函数自动化的套娃",children:"#"})]}),"\n",(0,c.jsxs)(e.h3,{id:"思路分析",children:["思路分析",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"通用的 curry 函数应该具备哪些能力？"}),"\n",(0,c.jsx)(e.p,{children:"最关键的一点，如小标题所言，它要能“自动套娃”。"}),"\n",(0,c.jsx)(e.p,{children:"也就是说，不管我传入的函数有多少个参数，curry 都应该能分析出参数的数量，并且动态地根据参数的数量自动做嵌套。"}),"\n",(0,c.jsx)(e.p,{children:"我们简单拆解一下这个函数的任务："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsx)(e.li,{children:"获取函数参数的数量"}),"\n",(0,c.jsx)(e.li,{children:"自动分层嵌套函数：有多少参数，就有多少层嵌套"}),"\n",(0,c.jsx)(e.li,{children:"在嵌套的最后一层，调用回调函数，传入所有入参。"}),"\n"]}),"\n",(0,c.jsxs)(e.h4,{id:"获取函数参数的数量",children:["获取函数参数的数量",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#获取函数参数的数量",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"首先第一步，获取函数参数的数量。"}),"\n",(0,c.jsx)(e.p,{children:"这个简单，在 JS 里，函数作为一等公民，它和对象一样有许多可访问的属性。其中 Function.length 属性刚好就是用来存放函数参数个数的。"}),"\n",(0,c.jsx)(e.p,{children:"通过访问函数的 length 属性，就可以拿到函数参数的数量，如下："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function test(a, b, c, d) {\n}\n\n// 输出 4\nconsole.log(test.length)\n"})}),"\n",(0,c.jsxs)(e.h4,{id:"自动化套娃",children:["自动化“套娃”",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自动化套娃",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"给定一个嵌套的上限，期望函数能够自动重复执行嵌套，直至达到上限。"}),"\n",(0,c.jsxs)(e.p,{children:["而“",(0,c.jsx)(e.strong,{children:"嵌套"}),"”的逻辑，摊开来看的话无非是："]}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsx)(e.li,{children:"判断当前层级是否已经达到了嵌套的上限"}),"\n",(0,c.jsxs)(e.li,{children:["若达到，则执行回调函数；否则，继续“",(0,c.jsx)(e.strong,{children:"嵌套"}),"”"]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["在嵌套函数内部继续嵌套，相当于是“",(0,c.jsx)(e.strong,{children:"我调用我自己"}),"”。"]}),"\n",(0,c.jsx)(e.p,{children:"而“我调用我自己”有个学名，叫做“递归”。"}),"\n",(0,c.jsx)(e.p,{children:"没错，这里，我们正是借助递归来实现所谓的“自动化套娃”。"}),"\n",(0,c.jsxs)(e.h4,{id:"递归边界的判定",children:["递归边界的判定",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#递归边界的判定",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"curry 函数会在每次嵌套定义一个新的函数之前，先检查当前层级是否已经达到了嵌套的上限。"}),"\n",(0,c.jsx)(e.p,{children:"也就是说每一次递归，都会检查当前是否已经触碰到了递归边界。"}),"\n",(0,c.jsx)(e.p,{children:"一旦触碰到递归边界（嵌套上限），则执行递归边界逻辑（也就是回调函数）。"}),"\n",(0,c.jsx)(e.p,{children:"那么这个递归边界怎么认定呢？"}),"\n",(0,c.jsx)(e.p,{children:"柯里化的过程，是层层“记忆”每个参数的过程。每一层嵌套函数，都有它需要去“记住”的参数。如果我们递归到某一层，发现此时已经没有“待记忆”的参数了，那么就可以认为，当前已经触碰到了递归边界。"}),"\n",(0,c.jsx)(e.p,{children:"明确了这三个任务的解法，我们就可以开始写代码啦！"}),"\n",(0,c.jsxs)(e.h3,{id:"编码实现",children:["编码实现",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"（解析在注释里）"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// curry 函数借助 Function.length 读取函数元数\nfunction curry(func, arity=func.length) {\n  // 定义一个递归式 generateCurried\n  function generateCurried(prevArgs) {\n    // generateCurried 函数必定返回一层嵌套\n    return function curried(nextArg) {\n      // 统计目前“已记忆”+“未记忆”的参数\n      const args = [...prevArgs, nextArg]  \n      // 若 “已记忆”+“未记忆”的参数数量 >= 回调函数元数，则认为已经记忆了所有的参数\n      if(args.length >= arity) {\n        // 触碰递归边界，传入所有参数，调用回调函数\n        return func(...args)\n      } else {\n        // 未触碰递归边界，则递归调用 generateCurried 自身，创造新一层的嵌套\n        return generateCurried(args)\n      }\n    }\n  }\n  // 调用 generateCurried，起始传参为空数组，表示“目前还没有记住任何参数”\n  return generateCurried([])\n}\n"})}),"\n",(0,c.jsxs)(e.h2,{id:"柯里化解决组合链的元数问题",children:["柯里化解决组合链的元数问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#柯里化解决组合链的元数问题",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"接下来我们就借助一个函数元数五花八门的组合链，来验证一下通用 curry 函数的效果。"}),"\n",(0,c.jsx)(e.p,{children:"首先定义一系列元数不等、且不符合一元要求的算术函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function add(a, b) {\n  return a + b\n}\n\nfunction multiply(a, b, c) {\n  return a*b*c\n}\n\nfunction addMore(a, b, c, d) {\n  return a+b+c+d\n}\n\nfunction divide(a, b) {\n  return a/b\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"此时若像下面这样直接把四个函数塞进 pipe 中去，必定是会倒沫子的："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const compute = pipe(add, multiply, addMore, divide)\n"})}),"\n",(0,c.jsx)(e.p,{children:"我们需要首先对四个函数分别作“一元化”处理。"}),"\n",(0,c.jsx)(e.p,{children:"这“一元化”处理的第一步，就是借助 curry 函数把它们各自的传参方式重构掉："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const curriedAdd = curry(add)\nconst curriedMultiply = curry(multiply)\nconst curriedAddMore = curry(addMore)\nconst curriedDivide = curry(divide)\n"})}),"\n",(0,c.jsx)(e.p,{children:"然后对这些函数逐个传参，传至每个函数只剩下一个待传参数为止。这样，我们就得到了一堆一元函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const compute = pipe(\n  curriedAdd(1), \n  curriedMultiply(2)(3), \n  curriedAddMore(1)(2)(3), \n  curriedDivide(300)\n)\n"})}),"\n",(0,c.jsx)(e.p,{children:"试着调用一下 compute，结果符合预期："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(s,{...n})}):s(n)}let h=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F16%20%E5%A5%97%E5%A8%83%E3%81%AE%E8%89%BA%E6%9C%AF%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%20curry%20%E5%87%BD%E6%95%B0%EF%BC%9F.md"]={toc:[{text:"柯里化解决 multiply 函数的参数问题",id:"柯里化解决-multiply-函数的参数问题",depth:2},{text:"柯里化的“套路”",id:"柯里化的套路",depth:2},{text:"通用柯里化函数：自动化的“套娃”",id:"通用柯里化函数自动化的套娃",depth:2},{text:"思路分析",id:"思路分析",depth:3},{text:"获取函数参数的数量",id:"获取函数参数的数量",depth:4},{text:"自动化“套娃”",id:"自动化套娃",depth:4},{text:"递归边界的判定",id:"递归边界的判定",depth:4},{text:"编码实现",id:"编码实现",depth:3},{text:"柯里化解决组合链的元数问题",id:"柯里化解决组合链的元数问题",depth:2}],title:"16 套娃の艺术：如何构造一个通用的 curry 函数？",headingTitle:"16 套娃の艺术：如何构造一个通用的 curry 函数？",frontmatter:{}}}}]);