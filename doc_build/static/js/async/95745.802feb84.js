"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["95745"],{705560:function(n,e,i){i.r(e),i.d(e,{default:()=>d});var a=i(552676),s=i(740453);let l=i.p+"static/image/1d7ac5f659432266799f1fd388a5c0cb.a54873bf.webp",r=i.p+"static/image/6852e46d0ab880091ce67fb1c43fbee4.8acf9aae.webp",c=i.p+"static/image/de501544b7ebfff2bf2ca6ec5ac9a7d4.e19b68d5.webp";function t(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",ol:"ol",li:"li"},(0,s.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"19-实战9歌单列表页的开发",children:["19 实战9：歌单列表页的开发",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#19-实战9歌单列表页的开发",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"本节主要讲解分包机制，其他次级页面的开发。"}),"\n",(0,a.jsxs)(e.h2,{id:"小程序分包机制",children:["小程序分包机制",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小程序分包机制",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"每次打开小程序会发现有的小程序打开的很快，有些很慢，甚至白屏时间很长。原因是包代码量大小的问题。第一次进入小程序的时候，小程序会下载主包代码，如果我们的主包业务代码越多，那么白屏的时间也会越长。"}),"\n",(0,a.jsx)(e.p,{children:"小程序有个机制是在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。因此我们不能把所有代码都放在主页面里面。我们把次级页面放到分包里面。"}),"\n",(0,a.jsx)(e.p,{children:"在构建小程序分包项目时，通常会创建一个或多个分包。每个使用分包小程序必定含有一个主包。所谓的主包，即放置默认启动页面 TabBar 页面，以及一些所有分包都需用到公共资源（css，js，image）；而分包则是根据开发者的配置进行划分。"}),"\n",(0,a.jsx)(e.p,{children:"某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。在 pages.json 我们需要 subPackages 管理次级页面的路由："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:'// pages.json\n"pages": [],\n"subPackages": [\n	{\n		"root": "pages/subpages/index",   // 分包根目录\n		"pages": [{\n			"path": "album",              // 配置页面路径\n			"style": {\n				"navigationBarTitleText": "歌单",\n				"app-plus": {\n					"titleNView": false\n				}\n			}\n		}]\n	}\n],\n'})}),"\n",(0,a.jsx)(e.p,{children:"分包里面的 pages 与主包的 pages 页面组成保持一致。对小程序进行分包，可以优化小程序首次启动的下载时间，以及在多团队共同开发时可以更好的解耦协作。"}),"\n",(0,a.jsx)(e.p,{children:"因此像歌单这样的次级页面都会在分包中注册管理。"}),"\n",(0,a.jsxs)(e.h2,{id:"页面跳转与获取参数",children:["页面跳转与获取参数",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#页面跳转与获取参数",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"关于页面跳转，在我们常识中就是浏览器对象窗口 location（url）属性的改变，可能我们第一印象是 a 标签，或者 location 对象的 href 属性进行页面的跳转。可是在 Uniapp 框架中怎么实现跳转呢？比如我要从首页跳转到歌单页？"}),"\n",(0,a.jsxs)(e.p,{children:["在 Uniapp 中想要实现跳转，可以查看",(0,a.jsx)(e.a,{href:"https://uniapp.dcloud.io/api/router?id=navigateto",target:"_blank",rel:"noopener noreferrer",children:"路由与页面跳转"}),"，由 ",(0,a.jsx)(e.code,{children:"uni.navigateTo"}),", ",(0,a.jsx)(e.code,{children:"uni.redirectTo"}),", ",(0,a.jsx)(e.code,{children:"uni.navigateBack"}),", ",(0,a.jsx)(e.code,{children:"uni.switchTab"}),", ",(0,a.jsx)(e.code,{children:"uni.reLaunch"})," 五个 api 组成，比如从首页跳转到列表页："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// 跳转到歌单页面并传递参数 1\nuni.navigateTo({\n	url: '/pages/subpages/index/album?id=1',\n	success: function () {  // 成功时回调函数\n		console.log('跳转成功')\n	}\n})\n"})}),"\n",(0,a.jsxs)(e.p,{children:["在 Uniapp 中也有类似的 a 标签元素 ",(0,a.jsx)(e.code,{children:"navigator"}),"。"]}),"\n",(0,a.jsx)(e.p,{children:"由于 Uniapp 中并没有 a 标签以及 location 对象，页面跳转则要使用框架中的 api 来进行对象跳转。"}),"\n",(0,a.jsxs)(e.p,{children:["像平常的页面跳转，我们使用页面标签即可，要是在事件回调中则使用 api 进行跳转，比如在首页的场景中的推荐歌单跳转歌单页面，附带传参数 id，可以在生命周期回调函数 ",(0,a.jsx)(e.code,{children:"onLoad"})," 的参数值中获取到。"]}),"\n",(0,a.jsxs)(e.p,{children:["navigator 默认点击时的样式是有虚影状态的，我们需要设置 ",(0,a.jsx)(e.code,{children:'hover-class="none"'})," ，设置成点击没有态效果。默认跳转方式 ",(0,a.jsx)(e.code,{children:'open-type="navigate"'}),"。"]}),"\n",(0,a.jsx)(e.p,{children:"在 /pages/index/index.vue 首页"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:'\x3c!-- index.vue --\x3e\n\x3c!-- 歌单分类块 --\x3e\n<view class="song-list">\n	<view class="tit-bar">\n		推荐歌单\n		<view class="more fr">歌单广场</view>\n	</view>\n	<scroll-view class="scroll-view" scroll-x>\n		<navigator class="item" v-for="(item, index) in recommendSongs" :key="index" hover-class="none" :url="\'/pages/subpages/index/album?id=\'+ item.id">\n			<image class="img" :src="item.picUrl + $imgSuffix"></image>\n			<view class="desc ellipsis">{{ item.name }}</view>\n			<view class="count">{{ item.playCount }}</view>\n		</navigator>\n	</scroll-view>\n</view>\n'})}),"\n",(0,a.jsx)(e.p,{children:"在歌单页"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"//  /pages/subpages/index/album.vue\n<script>\n	export default {\n		data() {\n			return {}\n		},\n		onLoad(options) {  //options为object类型，会序列化上个页面传递的参数\n			console.log(options.id); //打印出上个页面传递的参数。\n			this.getData(options.id);\n		},\n		methods: {\n			// 获取歌单\n			getData(id) {\n				var par = {\n					id\n				};\n				apiAlbumDetail(par).then(res => {\n					res.playlist.description = res.playlist.description.slice(0, 27)\n					this.album = res.playlist;\n					this.playList = res.privileges;\n				});\n			},\n		}\n	}\n<\/script>\n"})}),"\n",(0,a.jsx)(e.p,{children:"以上实现了页面与页面之间的传值，这样的传值相对简单，在处理复杂传值情况下，遇到 url 有长度限制，太长的字符串会传递失败，可使用窗体通信、全局变量，或 encodeURIComponent 等多种方式解决，如下为 encodeURIComponent 示例。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:"<navigator :url=\"'/pages/navigate/navigate?item='+ encodeURIComponent(JSON.stringify(item))\"></navigator>\n\n// navigate.vue页面接受参数\nonLoad: function (option) {\n	// 参数解码\n	const item = JSON.parse(decodeURIComponent(option.item));\n}\n"})}),"\n",(0,a.jsxs)(e.h2,{id:"设置背景模糊图像",children:["设置背景模糊图像",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#设置背景模糊图像",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(e.p,{children:'这一块要使用 CSS3 filter(radius) 属性给图像设置高斯模糊。"radius"一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊；'}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:".bg {\n	position: absolute;\n	top: 0;\n	left: 0;\n	height: 100%;\n	width: 100%;\n	filter: blur(35px);    // 模糊程度\n	background-position: 0 0px;\n	background-repeat: no-repeat;\n	background-size: cover;\n	overflow: hidden;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:r,alt:""})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:'\x3c!-- 标题栏 --\x3e\n<view class="nav-bar">\n	<view class="h300">\n		<view class="bg" :style="\'background-image:url(\'+ (album.backgroundCoverUrl || (album.coverImgUrl + $imgSuffix)) +\');top: \' + scrollTop + \'px\'"></view>\n	</view>\n	<view class="nav-bar-con">\n		标题\n	</view>\n</view>\n\x3c!-- 内容 --\x3e\n<scroll-view scroll-y="true" class="page-content" @scroll="scrollpage">\n	<view class="album-top">\n		<view class="bg" :style="\'background-image:url(\' + (album.backgroundCoverUrl || (album.coverImgUrl + $imgSuffix)) + \')\'"></view>\n	</view>\n</scroll-view>\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:"$bgheight: 688rpx;\n$bgtop: -44px;\n.bg {   // 滤镜模糊\n	position: absolute;\n	top: 0;\n	left: 0;\n	height: 100%;\n	width: 100%;\n	filter: blur(35px);\n	background-position: 0 0px;\n	background-repeat: no-repeat;\n	background-size: cover;\n}\n.h300{ // 标题栏模糊背景容器\n	position:relative;\n	height: $bgheight;\n}\n.nav-bar-con{  // 标题层级比背景高，不会防止点击返回箭头\n	position: absolute;\n	z-index: 20;\n}\n\n.album-top {  // 内容头部画面\n	position: relative;\n	top: $bgtop;\n	height: $bgheight;\n	padding-top:44px;\n	overflow: hidden;\n	background: #fff;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这里的交互比较特殊，就是标题栏的背景一直衔接内容头部画面背景，因此在滑动内容区的时候监听滑动区的滚动高度，然后标题栏的背景相对应滚动同等高度"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// 防抖，防止高频率操作\nfunction debounce(fn, wait = 10) {    \n	var timeout = null;    \n	return function() {        \n		if(timeout !== null) clearTimeout(timeout);        \n		timeout = setTimeout(fn, wait);    \n	}\n}\nvar that = null\nmethods: {\n	scrollpage (e) {\n		this.scrollY = e.detail.scrollTop\n		this.scroll()\n	},\n	// 设置背景条\n	scroll: debounce(() => {\n		if (that.scrollY < 5) {\n			that.scrollTop = 20\n		} else {\n			if (that.scrollY < 300) {\n				that.scrollTop = - parseInt(that.scrollY) + 20\n			}\n		}\n	}),\n}\n"})}),"\n",(0,a.jsxs)(e.h2,{id:"小结",children:["小结",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"理解小程序分包机制，优化加载速度，提高用户体验；"}),"\n",(0,a.jsxs)(e.li,{children:["跳转 tabbar 页面，也就是底部导航指定的页面，必须在 navigator 设置跳转方式 ",(0,a.jsx)(e.code,{children:'open-type="switchTab"'}),"；"]}),"\n",(0,a.jsx)(e.li,{children:"页面之间通过 url 传参，对 url 参数一定的限制。"}),"\n"]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(t,{...n})}):t(n)}let d=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["Uniapp%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%2F19%20%E5%AE%9E%E6%88%989%EF%BC%9A%E6%AD%8C%E5%8D%95%E5%88%97%E8%A1%A8%E9%A1%B5%E7%9A%84%E5%BC%80%E5%8F%91.md"]={toc:[{text:"小程序分包机制",id:"小程序分包机制",depth:2},{text:"页面跳转与获取参数",id:"页面跳转与获取参数",depth:2},{text:"设置背景模糊图像",id:"设置背景模糊图像",depth:2},{text:"小结",id:"小结",depth:2}],title:"19 实战9：歌单列表页的开发",headingTitle:"19 实战9：歌单列表页的开发",frontmatter:{}}}}]);