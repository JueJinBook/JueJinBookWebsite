"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["79422"],{534448:function(e,n,r){r.r(n),r.d(n,{default:()=>t});var a=r(552676),s=r(740453);let i=r.p+"static/image/7808c39b030ea98f8cb28a58ba830775.6a3c4d46.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h3:"h3",pre:"pre",code:"code",strong:"strong",img:"img",h2:"h2"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"3typescript-类型编程为什么被叫做类型体操",children:["3.TypeScript 类型编程为什么被叫做类型体操？",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3typescript-类型编程为什么被叫做类型体操",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"类型系统不止 TypeScript 有，别的语言 Java、C++ 等都有，为什么 TypeScript 的类型编程被叫做类型体操，而其他语言没有呢？这节我们来分析下原因。"}),"\n",(0,a.jsx)(n.p,{children:"TypeScript 给 JavaScript 增加了一套静态类型系统，通过 TS Compiler 编译为 JS，编译的过程做类型检查。"}),"\n",(0,a.jsx)(n.p,{children:"它并没有改变 JavaScript 的语法，只是在 JS 的基础上添加了类型语法，所以被叫做 JavaScript 的超集。"}),"\n",(0,a.jsx)(n.p,{children:"JavaScript 的标准在不断的发展，TypeScript 的类型系统也在不断完善，因为“超集”的设计理念，这两者可以很好的融合在一起，是不会有冲突的。"}),"\n",(0,a.jsx)(n.p,{children:"静态类型编程语言都有自己的类型系统，从简单到复杂可以分为 3 类："}),"\n",(0,a.jsxs)(n.h3,{id:"简单类型系统",children:["简单类型系统",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简单类型系统",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"变量、函数、类等都可以声明类型，编译器会基于声明的类型做类型检查，类型不匹配时会报错。"}),"\n",(0,a.jsx)(n.p,{children:"这是最基础的类型系统，能保证类型安全，但有些死板。"}),"\n",(0,a.jsx)(n.p,{children:"比如一个 add 函数既可以做整数加法、又可以做浮点数加法，却需要声明两个函数："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"int\xa0add(int\xa0a,\xa0int\xa0b)\xa0{\n\xa0\xa0\xa0\xa0return\xa0a\xa0+\xa0b;\n}\n\ndouble\xa0add(double\xa0a,\xa0double\xa0b)\xa0{\n\xa0\xa0\xa0\xa0return\xa0a\xa0+\xa0b;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"这个问题的解决思路很容易想到：如果类型能传参数就好了，传入 int 就是整数加法，传入 double 就是浮点数加法。"}),"\n",(0,a.jsx)(n.p,{children:"所以，就有了第二种类型系统。"}),"\n",(0,a.jsxs)(n.h3,{id:"支持泛型的类型系统",children:["支持泛型的类型系统",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#支持泛型的类型系统",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["泛型的英文是 Generic Type，通用的类型，它可以代表任何一种类型，也叫做",(0,a.jsx)(n.code,{children:"类型参数"}),"。"]}),"\n",(0,a.jsx)(n.p,{children:"它给类型系统增加了一些灵活性，在整体比较固定，部分变量的类型有变化的情况下，可以减少很多重复代码。"}),"\n",(0,a.jsx)(n.p,{children:"比如上面的 add 函数，有了泛型之后就可以这样写："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-c++",children:"T\xa0add<T>(T\xa0a,\xa0T\xa0b)\xa0{\n\xa0\xa0\xa0\xa0return\xa0a\xa0+\xa0b;\n}\n\nadd(1,2);\nadd(1.111, 2.2222);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"声明时把会变化的类型声明成泛型（也就是类型参数），在调用的时候再确定类型。"})}),"\n",(0,a.jsx)(n.p,{children:"Java 就是这种类型系统。如果你看过 Java 代码，你会发现泛型用的特别多，这确实是一个很好的增加类型系统灵活性的特性。"}),"\n",(0,a.jsx)(n.p,{children:"但是，这种类型系统的灵活性对于 JavaScript 来说还不够，因为 JavaScript 太过灵活了。"}),"\n",(0,a.jsx)(n.p,{children:"比如，在 Java 里，对象都是由类 new 出来的，你不能凭空创建对象，但是 JavaScript 却可以，它支持对象字面量。"}),"\n",(0,a.jsx)(n.p,{children:"那如果是一个返回对象某个属性值的函数，类型该怎么写呢？"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function getPropValue<T>(obj: T, key): key对应的属性值类型 {\n    return obj[key];\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"好像拿到了 T，也不能拿到它的属性和属性值，如果能对类型参数 T 做一些逻辑处理就好了。"}),"\n",(0,a.jsx)(n.p,{children:"所以，就有了第三种类型系统。"}),"\n",(0,a.jsxs)(n.h3,{id:"支持类型编程的类型系统",children:["支持类型编程的类型系统",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#支持类型编程的类型系统",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"在 Java 里面，拿到了对象的类型就能找到它的类，进一步拿到各种信息，所以类型系统支持泛型就足够了。"}),"\n",(0,a.jsx)(n.p,{children:"但是在 JavaScript 里面，对象可以字面量的方式创建，还可以灵活的增删属性，拿到对象并不能确定什么，所以要支持对传入的类型参数做进一步的处理。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"对传入的类型参数（泛型）做各种逻辑运算，产生新的类型，这就是类型编程。"})}),"\n",(0,a.jsx)(n.p,{children:"比如上面那个 getProps 的函数，类型可以这样写："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function getPropValue<\n    T extends object,\n    Key extends keyof T\n>(obj: T, key: Key): T[Key] {\n    return obj[key];\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"这里的 keyof T、T[Key] 就是对类型参数 T 的类型运算。"}),"\n",(0,a.jsx)(n.p,{children:"TypeScript 的类型系统就是第三种，支持对类型参数做各种逻辑处理，可以写很复杂的类型逻辑。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"类型逻辑可以多复杂？"})}),"\n",(0,a.jsx)(n.p,{children:"类型逻辑是对类型参数的各种处理，可以实现很多强大的功能："}),"\n",(0,a.jsx)(n.p,{children:"比如这个 ParseQueryString 的类型："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"它可以对传入的字符串的类型参数做解析，返回解析以后的结果。"}),"\n",(0,a.jsx)(n.p,{children:"如果是 Java 的只支持泛型的类型系统可以做到么？明显不能。但是 TypeScript 的类型系统就可以，因为它可以对泛型（类型参数）做各种逻辑处理。"}),"\n",(0,a.jsx)(n.p,{children:"只不过，这个类型的类型逻辑的代码比较多（下面的 ts 类型暂时看不懂没关系，在顺口溜那节会有详解，这里只是用来直观感受下类型编程的复杂度的，等学完以后大家也能实现这样的复杂高级类型的）："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"type ParseParam<Param extends string> = \n    Param extends `${infer Key}=${infer Value}`\n        ? {\n            [K in Key]: Value \n        } : {};\n\ntype MergeValues<One, Other> = \n    One extends Other \n        ? One\n        : Other extends unknown[]\n            ? [One, ...Other]\n            : [One, Other];\n\ntype MergeParams<\n    OneParam extends Record<string, any>,\n    OtherParam extends Record<string, any>\n> = {\n  [Key in keyof OneParam | keyof OtherParam]: \n    Key extends keyof OneParam\n        ? Key extends keyof OtherParam\n            ? MergeValues<OneParam[Key], OtherParam[Key]>\n            : OneParam[Key]\n        : Key extends keyof OtherParam \n            ? OtherParam[Key] \n            : never\n}\ntype ParseQueryString<Str extends string> = \n    Str extends `${infer Param}&${infer Rest}`\n        ? MergeParams<ParseParam<Param>, ParseQueryString<Rest>>\n        : ParseParam<Str>;\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["TypeScript 的类型系统是",(0,a.jsx)(n.code,{children:"图灵完备"}),"的，也就是能描述各种可计算逻辑。简单点来理解就是循环、条件等各种 JS 里面有的语法它都有，JS 能写的逻辑它都能写。"]})}),"\n",(0,a.jsx)(n.p,{children:"对类型参数的编程是 TypeScript 类型系统最强大的部分，可以实现各种复杂的类型计算逻辑，是它的优点。但同时也被认为是它的缺点，因为除了业务逻辑外还要写很多类型逻辑。"}),"\n",(0,a.jsx)(n.p,{children:"不过，我倒是觉得这种复杂度是不可避免的，因为 JS 本身足够灵活，要准确定义类型那类型系统必然也要设计的足够灵活。"}),"\n",(0,a.jsxs)(n.p,{children:["是不是感觉 TypeScript 类型系统挺复杂的？确实，不然大家也不会把 TS 的类型编程戏称为",(0,a.jsx)(n.code,{children:"类型体操"}),"了。"]}),"\n",(0,a.jsx)(n.p,{children:"但不用担心，这本小册就是专门讲这个的，后面会讲各种 TS 类型编程的套路，学完那些之后，再回来看这个问题就没那么难了。"}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"TypeScript 给 JavaScript 增加了一套类型系统，但并没有改变 JS 的语法，只是做了扩展，是 JavaScript 的超集。"}),"\n",(0,a.jsx)(n.p,{children:"这套类型系统支持泛型，也就是类型参数，有了一些灵活性。而且又进一步支持了对类型参数的各种处理，也就是类型编程，灵活性进一步增强。"}),"\n",(0,a.jsx)(n.p,{children:"现在 TS 的类型系统是图灵完备的，JS 可以写的逻辑，用 TS 类型都可以写。"}),"\n",(0,a.jsx)(n.p,{children:"但是很多类型编程的逻辑写起来比较复杂，因此被戏称为类型体操。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}let t=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F3.TypeScript%20%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A2%AB%E5%8F%AB%E5%81%9A%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%EF%BC%9F.md"]={toc:[{text:"简单类型系统",id:"简单类型系统",depth:3},{text:"支持泛型的类型系统",id:"支持泛型的类型系统",depth:3},{text:"支持类型编程的类型系统",id:"支持类型编程的类型系统",depth:3},{text:"总结",id:"总结",depth:2}],title:"3.TypeScript 类型编程为什么被叫做类型体操？",headingTitle:"3.TypeScript 类型编程为什么被叫做类型体操？",frontmatter:{}}}}]);