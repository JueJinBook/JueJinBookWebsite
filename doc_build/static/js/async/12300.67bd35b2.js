"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12300"],{734810:function(e,n,t){t.r(n),t.d(n,{default:()=>C});var s=t(552676),l=t(740453);let r=t.p+"static/image/3b63bfff2bc8e8033a976d9cec74af5d.9e7447c2.webp",i=t.p+"static/image/6497f662c0af9b4420ab198e8a0a4c64.89efb004.webp",d=t.p+"static/image/e1ad20ab62120868ce098b4df4a44b3a.32270046.webp",c=t.p+"static/image/bac15b4ba4b4c3f41ab0a28725c28dbb.21447f5b.webp",a=t.p+"static/image/1e92f4435af00d8dff5eb78c0e03db95.d67d427b.webp",o=t.p+"static/image/c20b64225b3b6ab3f884427687585c66.e2c340b4.webp",h=t.p+"static/image/d00109616bb57f88de829cd0914f99aa.62e218a9.webp",p=t.p+"static/image/8e5d0e45c1b1fd7067d57a4acc2efd5a.c8d5e1fc.webp",m=t.p+"static/image/3ba6c7de98b347d163da17083fa33e3f.f2c073be.webp",x=t.p+"static/image/36f4303dacbb66c28fe998e98e7bc153.7fd46dc7.webp",v=t.p+"static/image/7633fef143efdf424883ec9f7e665cfa.40c7cddb.webp",j=t.p+"static/image/7b27346f561b9db9870b28d1e9996b3b.b25eac56.webp",f=t.p+"static/image/a03e48534f4666d7295fa5f23ef01d78.7f552e81.webp",b=t.p+"static/image/cbb81b0fb39cffbfb746ee931024d768.eee03c77.webp",u=t.p+"static/image/ab7fb56d278dbb081571f6ed7e24587c.aafae790.webp",g=t.p+"static/image/08fb035ae26a977acdd543d2c13952e8.15202300.webp",w=t.p+"static/image/411ff39fa8de3988ddd2468e79964b72.5178704c.webp",S=t.p+"static/image/f436cdcf343bc9a8e2f1cf918d2b17fc.0f873273.webp",y=t.p+"static/image/8df2161015ce76c6a5e355bf181bb21e.c31072fa.webp",N=t.p+"static/image/d91e3ff33d37d29db07c7fbea1d5d655.7768d9a2.webp";function k(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",h3:"h3",pre:"pre",img:"img",ol:"ol",li:"li"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"42-svelte-4--slots-与内置-elements",children:["42-Svelte 4 ❘ Slots 与内置 elements",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-svelte-4--slots-与内置-elements",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"推荐学习指数：⭐️️，了解即可"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本篇我们来介绍 Svelte 的重要概念 —— Special elements。为什么叫 Specail elements 呢？因为它们的写法类似于普通的 elements，但实现的功能却比较特殊。包括实现插槽的 ",(0,s.jsx)(n.code,{children:"<slot>"}),"、修改 HTML head 的 ",(0,s.jsx)(n.code,{children:"<svelte:body>"}),"等等。"]}),"\n",(0,s.jsx)(n.p,{children:"这些也是 Svlete 项目开发中常用的内容。就让我们一起看看如何使用吧！"}),"\n",(0,s.jsxs)(n.h2,{id:"2-插槽slots",children:["2. 插槽（Slots）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-插槽slots",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注：Svelte 5 提供了 Snippets 可替代插槽的功能，但 Slots 在 Svelte 5 中依然可以使用。这块内容看不看都行，你看了也不亏，Vue、Astro 框架中都是类似的用法。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"21-slot-basic",children:["2.1. Slot Basic",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-slot-basic",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"所谓 Slot，类似于 Vue 的 Slot 功能，看个最简单的例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Button from './Button.svelte';\n<\/script>\n\n<Button>\n  Primary Button\n</Button>\n\n\x3c!-- Button.svelte --\x3e\n<slot />\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/fc25463c8cdf4662bfe96f207feaa306?version=4.2.18",title:"https://svelte.dev/repl/fc25463c8cdf4662bfe96f207feaa306?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，子组件可以使用 ",(0,s.jsx)(n.code,{children:"<slot>"}),"元素获取父组件的插槽内容。"]}),"\n",(0,s.jsxs)(n.h3,{id:"22-slot-fallbacks",children:["2.2. Slot Fallbacks",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-slot-fallbacks",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Slot 可以设置 fallback 内容，当父组件没有传入插槽内容的时候，slot 会显示该内容："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Button from './Button.svelte';\n<\/script>\n\n<Button />\n\n\x3c!-- Button.svelte --\x3e\n<slot>Primary Button</slot>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/a108aec0eef04058b4ea0e56491c4f4a?version=4.2.18",title:"https://svelte.dev/repl/a108aec0eef04058b4ea0e56491c4f4a?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"23-slot-中的变量",children:["2.3. Slot 中的变量",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-slot-中的变量",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"父组件可以在插槽内容中正常使用变量，我们举个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Button from './Button.svelte';\n  let count = 0;\n\n<\/script>\n\n<button on:click={() => count++}>+</button>\n  {count}\n<button on:click={() => count--}>-</button>\n\n<br />\n\n<Button>\n  <button on:click={() => count++}>+</button>\n    {count}\n  <button on:click={() => count--}>-</button>\n</Button>\n\n<style>\n  button {\n    width: 50px;\n    color: orange\n  }\n</style>\n\n\x3c!-- Button.svelte --\x3e\n<slot>Primary Button</slot>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/4cbef48b4c164817a1231cfb4a618ec5?version=4.2.18",title:"https://svelte.dev/repl/4cbef48b4c164817a1231cfb4a618ec5?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["在这段代码中，",(0,s.jsx)(n.code,{children:"count"})," 变量写在了父组件插槽内容中，其值的变化受父组件的状态影响，且样式也是 scoped，受父组件的样式影响，而不会受子组件影响。"]}),"\n",(0,s.jsxs)(n.h3,{id:"24-named-slots",children:["2.4. Named Slots",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-named-slots",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"命名插槽可以让你在插槽中传递多个内容。让我们看个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import Article from \'./Article.svelte\';\n<\/script>\n\n<Article>\n  <span slot="header">header</span>\n\n  <small>body</small>\n\n  <span slot="footer">\n    <small>footer</small>\n  </span>\n</Article>\n\n\x3c!-- Article.svelte --\x3e\n<div class="article">\n  <header>\n    <slot name="header" />\n  </header>\n\n  <slot />\n\n  <footer>\n    <slot name="footer" />\n  </footer>\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/4726cc887b6741e39be724c62276246d?version=4.2.18",title:"https://svelte.dev/repl/4726cc887b6741e39be724c62276246d?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["也就是说：当你在父组件的插槽内容中通过 ",(0,s.jsx)(n.code,{children:'slot="xxx"'}),"方式声明一个插槽，你就可以在子组件通过 ",(0,s.jsx)(n.code,{children:'<slot name="xxx" />'}),"引用这个插槽内容。"]}),"\n",(0,s.jsxs)(n.h3,{id:"25-slot-props",children:["2.5. Slot Props",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-slot-props",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"有的时候，你需要将子组件的数据传递给父组件的插槽内容用于渲染。一个常见的例子是遍历数组，举个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import List from \'./List.svelte\';\n  const names = ["Aaron", "Baron", "Caesar"]\n<\/script>\n\n<List data={names} let:item>\n  <li>{item}</li>\n</List>\n\n\x3c!-- List.svelte --\x3e\n<script>\n  export let data;\n<\/script>\n\n<ul>\n  {#each data as item}\n    <slot {item} />\n  {/each}\n</ul>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["在这个例子中，我们声明了一个 ",(0,s.jsx)(n.code,{children:"<List>"})," 组件，",(0,s.jsx)(n.code,{children:"<List>"}),"组件的插槽用于声明单个 Item 的渲染样式，其中就需要获取数据，才能指定数据渲染的位置。这个时候就需要使用 Slot props。"]}),"\n",(0,s.jsxs)(n.p,{children:["它的使用方式是首先在子组件指定 ",(0,s.jsx)(n.code,{children:"<slot key={value}>"}),"（比如上面代码中的 ",(0,s.jsx)(n.code,{children:"<slot item={item} />"}),"），然后就可以在父组件通过 ",(0,s.jsx)(n.code,{children:"let"}),"指令将值传递给插槽模板（比如上面代码中的 ",(0,s.jsx)(n.code,{children:"<List let:item={item}>"}),"）。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/73557390b8b24306a46169bc881a0c53?version=4.2.18",title:"https://svelte.dev/repl/73557390b8b24306a46169bc881a0c53?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["注意：我们通过 ",(0,s.jsx)(n.code,{children:"<List let:item>"}),"获取了给插槽模板的 item 变量，如果该变量与父组件的变量冲突，可以使用 ",(0,s.jsx)(n.code,{children:"<List let:item={xxx}>"}),"进行重命名："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<List data={names} let:item={name}>\n  <li>{name}</li>\n</List>\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"26-slot-forwarding",children:["2.6. Slot Forwarding",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26-slot-forwarding",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"假设现在有 4 个组件，层级关系是 App > Parent > Child > GrandChild，如果想把 App 中声明的插槽模板用在子孙组件 GrandChild 中，作为中间组件的 Parent 和 Child 该怎么传递呢？"}),"\n",(0,s.jsx)(n.p,{children:"其实并不复杂："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import Parent from \'./Parent.svelte\';\n<\/script>\n\n<Parent>\n  <span slot="header">header</span>\n\n  <small>body</small>\n\n  <span slot="footer">\n    <small>footer</small>\n  </span>\n</Parent>\n\n\x3c!-- Parent.svelte --\x3e\n<script>\n  import Child from \'./Child.svelte\';\n<\/script>\n\n<Child>\n  <slot name="header" slot="header" />\n  <slot />\n  <slot name="footer" slot="footer" />\n</Child>\n\n\x3c!-- Child.svelte --\x3e\n<script>\n  import GrandChild from \'./GrandChild.svelte\';\n<\/script>\n\n<GrandChild>\n  <slot name="header" slot="header" />\n  <slot />\n  <slot name="footer" slot="footer" />\n</GrandChild>\n\n\x3c!-- GrandChild.svelte --\x3e\n<div class="article">\n  <header>\n    <slot name="header" />\n  </header>\n  <slot />\n  <footer>\n    <slot name="footer" />\n  </footer>\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/d23f6998bf384afeb6f56b427499be90?version=4.2.18",title:"https://svelte.dev/repl/d23f6998bf384afeb6f56b427499be90?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那么如果我们想要像 Slot Props 中的例子将子孙组件 GrandChild 的数据传递给顶层组件 App 呢？实现起来也不复杂："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import Parent from \'./Parent.svelte\';\n  const names = ["Aaron", "Baron", "Caesar"]\n<\/script>\n\n<Parent data={names}>\n  <li slot="item" let:item>{item}</li>\n</Parent>\n\n\x3c!-- Parent.svelte --\x3e\n<script>\n  import Child from \'./Child.svelte\';\n  export let data;\n<\/script>\n\n<Child data={data}>\n  <slot name="item" slot="item" let:item {item} />\n</Child>\n\n\x3c!-- Child.svelte --\x3e\n<script>\n  import GrandChild from \'./GrandChild.svelte\';\n  export let data;\n<\/script>\n\n<GrandChild data={data}>\n  <slot name="item" slot="item" let:item {item} />\n</GrandChild>\n\n\x3c!-- GrandChild.svelte --\x3e\n<script>\n  export let data;\n<\/script>\n\n<ul>\n  {#each data as item}\n    <slot name="item" {item} />\n  {/each}\n</ul>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/43747e12bd79470f80766317e8a56659?version=4.2.18",title:"https://svelte.dev/repl/43747e12bd79470f80766317e8a56659?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"27-slots",children:["2.7. $$slots",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#27-slots",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"$$slots"})," 是一个特殊变量，只有一个用途，就是判断父级是否传入了特定名称的插槽。以之前的 Named Slots 为例："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import Article from \'./Article.svelte\';\n<\/script>\n\n<Article>\n  \x3c!-- 假设没有下面这行--\x3e\n  <span slot="header">header</span>\n\n  <small>body</small>\n\n  <span slot="footer">\n    <small>footer</small>\n  </span>\n</Article>\n\n\x3c!-- Article.svelte --\x3e\n<div class="article">\n  <header>\n    <slot name="header" />\n  </header>\n\n  <slot />\n\n  <footer>\n    <slot name="footer" />\n  </footer>\n</div>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["假设父组件的插槽中没有 ",(0,s.jsx)(n.code,{children:'<span slot="header">header</span>'}),"这行内容，子组件会渲染一个空的 ",(0,s.jsx)(n.code,{children:"<header>"})," 元素。如果你想要子组件连 ",(0,s.jsx)(n.code,{children:"<header>"})," 元素也不渲染呢？"]}),"\n",(0,s.jsxs)(n.p,{children:["这个时候就可以用到 ",(0,s.jsx)(n.code,{children:"$$slots"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import Article from \'./Article.svelte\';\n<\/script>\n\n<Article>\n  <small>body</small>\n\n  <span slot="footer">\n    <small>footer</small>\n  </span>\n</Article>\n\n\x3c!-- Article.svelte --\x3e\n<script>\n  console.log($$slots)\n<\/script>\n<div class="article">\n  {#if $$slots.header}\n    <header>\n      <slot name="header" />\n    </header>\n  {/if}\n\n  <slot />\n\n  <footer>\n    <slot name="footer" />\n  </footer>\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/da4b29ec0d2e4f2d93c3474401667440?version=4.2.18",title:"https://svelte.dev/repl/da4b29ec0d2e4f2d93c3474401667440?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到，",(0,s.jsx)(n.code,{children:"$$slots"})," 是一个对象，它的键名是父组件传入的命名插槽的名称。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注意：假如父组件传入了空的命名插槽，比如 ，$$slots.header 也会返回 true"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-特殊元素",children:["3. 特殊元素",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-特殊元素",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"31-sveltecomponentlegacy",children:["3.1. ",(0,s.jsx)(n.a,{href:"/svelte:component",children:"svelte:component"}),"（Legacy）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-sveltecomponentlegacy",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<svelte:component>"}),"解决的是动态组件的问题，根据条件渲染不同的组件："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Foo from './Foo.svelte'\n  import Bar from './Bar.svelte'\n\n  let count = 0;\n<\/script>\n\n<button on:click={() => {\n  count += 1;\n}}>\n  Clicked {count}\n</button>\n\n{#if count > 3}\n  <Foo {count} />\n{:else}\n  <Bar {count} />\n{/if}\n\n\x3c!-- Foo.svelte --\x3e\n<script>\n  export let count\n<\/script>\n\nFoo {count}\n\n\x3c!-- Bar.svelte --\x3e\n<script>\n  export let count\n<\/script>\n\nBar {count}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"<svelte:component>"}),"，原本的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"{#if count > 3}\n  <Foo {count} />\n{:else}\n  <Bar {count} />\n{/if}\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以简化为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<svelte:component this={count > 3 ? Foo : Bar} {count} />\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/6c470fdfce8643da866afe437aae7922?version=4.2.18",title:"https://svelte.dev/repl/6c470fdfce8643da866afe437aae7922?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"使用时注意："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"当 this 的值为假值（false、null、undefined 等）时，组件不会渲染"}),"\n",(0,s.jsx)(n.li,{children:"当属性值更改的时候，组件会销毁重建"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"注：在 Svelte 5 中，这个例子可以写成："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n	import Foo from './Foo.svelte'\n	import Bar from './Bar.svelte'\n	\n	let count = $state(0);\n	\n	let Component = $derived(count > 3 ? Foo : Bar)\n<\/script>\n\n<button onclick={() => {\n	count += 1;\n}}>\n	Clicked {count}\n</button>\n\n<Component {count} />\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://svelte.dev/playground/2e4ce15d36d44109aa87f1d1338935f0?version=5.1.3",title:"https://svelte.dev/playground/2e4ce15d36d44109aa87f1d1338935f0?version=5.1.3",target:"_blank",rel:"noopener noreferrer",children:"点击查看浏览器效果"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"因此虽然可以继续使用，但在 Svelte 5 中该语法被认为是过时的。"}),"\n",(0,s.jsxs)(n.h3,{id:"32-svelteelement",children:["3.2. ",(0,s.jsx)(n.a,{href:"/svelte:element",children:"svelte:element"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-svelteelement",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<svelte:element>"}),"与 ",(0,s.jsx)(n.code,{children:"<svelte:component>"}),"类似，只不过解决的是动态元素的问题："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<script>\n  let count = 0;\n<\/script>\n\n<button on:click={() => {\n  count += 1;\n}}>\n  Clicked {count}\n</button>\n\n<svelte:element this={count > 3 ? "h1" : "p"}>{count}</svelte:element>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/b38580c52b88469fbab7435190920c08?version=4.2.18",title:"https://svelte.dev/repl/b38580c52b88469fbab7435190920c08?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"使用时注意："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"当 this 的值为假值（false、null、undefined 等）时，元素及其子元素都不会渲染"}),"\n",(0,s.jsx)(n.li,{children:"不能使用 bind:value 等绑定，因为 Svelte 并不知道你最终渲染的元素是什么，如果是 input 还好，万一只是一个普通的 div 呢"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"33-svelteselflegacy",children:["3.3. ",(0,s.jsx)(n.a,{href:"/svelte:self",children:"svelte:self"}),"（Legacy）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-svelteselflegacy",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<svelte:self>"})," 允许组件以递归的方式包含自身，主要是用来处理递归。场景倒很多，就是一不小心容易写成无限循环。就比如渲染城市数据："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n  export let data = [\n    { type: 'city', value: '北京'},\n    {\n      type: 'province',\n      value: '浙江',\n      children: [\n        { type: 'city', value: '杭州'},\n        { type: 'city', value: '宁波'}\n      ]\n    }\n  ];\n<\/script>\n\n  <ul>\n    {#each data as item}\n      <li>\n        {#if item.type === 'province'}\n          {item.value}\n          <svelte:self data={item.children} />\n        {:else if item.type === 'city'}\n          <span>{item.value}</span>\n        {/if}\n      </li>\n    {/each}\n  </ul>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/2fca66addb9348da8f78ea995415cf78?version=4.2.18",title:"https://svelte.dev/repl/2fca66addb9348da8f78ea995415cf78?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"使用时注意："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"不能用在顶层，只能用在 IF、Each 块或者组件插槽中，这都是为了防止无限循环"}),"\n",(0,s.jsx)(n.li,{children:"注意使用 export 才能在递归的时候获取数据"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"注：在 Svelte 5 中，这个例子可以写成："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n	import Self from './App.svelte'\n  export let data = [\n    { type: 'city', value: '北京'},\n    {\n      type: 'province',\n      value: '浙江',\n      children: [\n        { type: 'city', value: '杭州'},\n        { type: 'city', value: '宁波'}\n      ]\n    }\n  ];\n<\/script>\n\n<ul>\n    {#each data as item}\n    <li>\n        {#if item.type === 'province'}\n            {item.value}\n            <Self data={item.children} />\n        {:else if item.type === 'city'}\n            <span>{item.value}</span>\n        {/if}\n    </li>\n    {/each}\n</ul>\n"})}),"\n",(0,s.jsx)(n.p,{children:"因此虽然可以继续使用，但在 Svelte 5 中该语法被认为是过时的。"}),"\n",(0,s.jsxs)(n.h3,{id:"34-sveltewindow",children:["3.4. ",(0,s.jsx)(n.a,{href:"/svelte:window",children:"svelte:window"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34-sveltewindow",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<svelte:window>"})," 用于在 window 对象上添加事件监听器。"]}),"\n",(0,s.jsx)(n.p,{children:"通常我们需要这样写代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { onMount } from 'svelte';\n\n  let innerWidth = window.innerWidth;\n\n  onMount(() => {\n    function onResize() {\n      innerWidth = window.innerWidth;\n    }\n    window.addEventListener('resize', onResize);\n    return () => window.removeEventListener('resize', onResize);\n  });\n<\/script>\n\n<div>\n  Width: {innerWidth}\n</div>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里一段监听浏览器窗口宽度的代码。",(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/930a0ce858564a6da1c4dff978b5d6bf?version=4.2.18",title:"https://svelte.dev/repl/930a0ce858564a6da1c4dff978b5d6bf?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["我们需要在组件挂载的时候添加监听器，在组件卸载的时候移除监听器。使用 ",(0,s.jsx)(n.code,{children:"<svelte:window>"}),"后，代码简化为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { onMount } from 'svelte';\n\n  let innerWidth = window.innerWidth;\n\n  function onResize() {\n    innerWidth = window.innerWidth;\n  }\n<\/script>\n\n<svelte:window on:resize={onResize} />\n\n<div>\n  Width: {innerWidth}\n</div>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<svelte:window>"})," 会自动进行处理监听器的添加和移除。"]}),"\n",(0,s.jsxs)(n.p,{children:["Svelte 甚至提供了 ",(0,s.jsx)(n.code,{children:"<svelte:window bind:prop={value} />"}),"的方式，可以将代码进一步简化为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { onMount } from 'svelte';\n\n  let innerWidth = window.innerWidth;\n\n<\/script>\n\n<svelte:window bind:innerWidth={innerWidth} />\n\n<div>\n  Width: {innerWidth}\n</div>\n"})}),"\n",(0,s.jsx)(n.p,{children:"具体能够绑定获取哪些属性的值，Tutorial 中也有介绍："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"35-sveltebody",children:["3.5. ",(0,s.jsx)(n.a,{href:"/svelte:body",children:"svelte:body"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#35-sveltebody",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/",children:"svelte:body"})," 与 ",(0,s.jsx)(n.a,{href:"/",children:"svelte:window"})," 类似，用于在 document.body 上添加事件监听器。因为像比如 mouseenter 和 mouseleave 事件在 window 上就不能添加。"]}),"\n",(0,s.jsxs)(n.h3,{id:"36-sveltedocument",children:["3.6. ",(0,s.jsx)(n.a,{href:"/svelte:document",children:"svelte:document"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36-sveltedocument",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/",children:"svelte:document"})," 与 ",(0,s.jsx)(n.a,{href:"/",children:"svelte:window"})," 类似，用于在 document 上添加事件监听器。因为像比如 visibilitychange 不能在 window 上触发。"]}),"\n",(0,s.jsxs)(n.h3,{id:"37-sveltehead",children:["3.7. ",(0,s.jsx)(n.a,{href:"/svelte:head",children:"svelte:head"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#37-sveltehead",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/",children:"svelte:head"})," 用于将元素插入到 ",(0,s.jsx)(n.code,{children:"document.head"}),"中："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<svelte:head>\n  <title>Hello world!</title>\n  <meta name="description" content="This is where the description goes for SEO" />\n</svelte:head>\n'})}),"\n",(0,s.jsx)(n.p,{children:"你可以在其中正常使用变量："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<script>\n  let value = \'world\'\n<\/script>\n\n<input bind:value />\n\n<svelte:head>\n  <title>Hello {value}!</title>\n  <meta name="description" content="This is where the description goes for SEO" />\n  {@html `<style>\n    input {\n      color: red\n    }\n  </style>`}\n</svelte:head>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/5d329da2f8d54c5696b354459052b8fd?version=4.2.18",title:"https://svelte.dev/repl/5d329da2f8d54c5696b354459052b8fd?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["与 ",(0,s.jsx)(n.code,{children:"<svelte:window>"})," 一样，该元素只能出现在组件的顶层，绝不能位于块或元素内。"]}),"\n",(0,s.jsxs)(n.h3,{id:"38-svelteoptions",children:["3.8. ",(0,s.jsx)(n.a,{href:"/svelte:options",children:"svelte:options"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#38-svelteoptions",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/",children:"svelte:options"})," 提供了组件的编译选项，将决定 Svelte 如何编译组件。完整的选项查看 ",(0,s.jsx)(n.a,{href:"https://svelte.dev/docs/svelte-compiler#compile",title:"https://svelte.dev/docs/svelte-compiler#compile",target:"_blank",rel:"noopener noreferrer",children:"svelte/compiler • Docs • Svelte"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注：在 Svelte 5 中，immutable 编译器选项被弃用，因为 Svelte 5 的符文模式下，所有的状态都是 immutable"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"比较常见的是 3 个选型，一个是 immutable，默认为 false，当为 true 时，表示自己使用不可变数据，编译器可以执行简单的引用相等检查来确定值是否已更改，这会减少渲染次数，提升组件性能。让我们看个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"<script>\n    let numbers = [1, 2, 3, 4];\n    function addNumber() {\n        numbers.push(numbers.length + 1);\n        numbers = numbers;\n    }\n<\/script>\n\n<p>{numbers.join(' + ')}</p>\n\n<button on:click={addNumber}>\n    Add a number\n</button>\n\n<svelte:options immutable={false} />\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当 immutable 设置为 false 的时候，",(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/bd6cbc4865d84448bd436e51c89c3e7b?version=4.2.18",title:"https://svelte.dev/repl/bd6cbc4865d84448bd436e51c89c3e7b?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["此时正常运行，但如果修改 ",(0,s.jsx)(n.code,{children:"immutable={false}"}),"，点击则不会有任何反应。这是因为你已经告诉了编译器你将使用不可变数据，编译器只会比较 numbers 的引用是否发生变化，而此时并未发生变化，所以不会触发响应式。"]}),"\n",(0,s.jsx)(n.p,{children:"如果要触发，可以修改成："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"<script>\n    let numbers = [1, 2, 3, 4];\n    function addNumber() {\n        numbers.push(numbers.length + 1);\n        numbers = [...numbers];\n    }\n<\/script>\n\n<p>{numbers.join(' + ')}</p>\n\n<button on:click={addNumber}>\n    Add a number\n</button>\n\n<svelte:options immutable={true} />\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/fe676259798c4b87b4670a2e84b54980?version=4.2.18",title:"https://svelte.dev/repl/fe676259798c4b87b4670a2e84b54980?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"第二个是 accessors，默认为 false，当为 true 时，为组件的 props 添加 getter 和 setter。这样做的好处在于可以读取组件实例的 props，正常是无法直接读取的。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Child from './Child.svelte'\n\n  let component\n\n  function handler() {\n  component.name = 'Dasiy'\n  }\n<\/script>\n\n<button on:click={handler}>\n  切换名字\n</button>\n\n<Child bind:this={component} />\n\n\x3c!-- Child.svelte --\x3e\n<svelte:options accessors />\n\n<script>\n  export let name = 'Kevin'\n<\/script>\n<h1>{name}!</h1>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/966ddce1f9664f60b165d9a3ec66ec78?version=4.2.18",title:"https://svelte.dev/repl/966ddce1f9664f60b165d9a3ec66ec78?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"其实效果类似于使用客户端 API，只不过更加简洁："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"function handler() {\n  component.$set({\n    name: 'Daisy'\n  })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"还有一个是 namespace，将使用该组件的命名空间，最常见的是“svg”；使用“foreign”命名空间选择不区分大小写的属性名称和特定于 HTML 的警告"}),"\n",(0,s.jsx)(n.p,{children:"默认是 html，也就是说告诉 Svelte 我写的是 HTML，但也可以告诉 Svelte 我写的是 svg："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["当使用 ",(0,s.jsx)(n.code,{children:'<svelte:options namespace="svg" />'}),"时："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Svelte 会改为创建 Svg 元素。"}),"\n",(0,s.jsx)(n.p,{children:"还有一个是 customElement，用于将组件编译为自定义的元素："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<svelte:options customElement="my-custom-element" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"这个时候就可以使用："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"document.body.innerHTML = `\n  <my-element>\n    <p>This is some slotted content</p>\n  </my-element>\n`;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["不算是常用的功能，但展示了编译器的强大功能。具体使用查看",(0,s.jsx)(n.a,{href:"https://svelte.dev/docs/custom-elements-api",title:"https://svelte.dev/docs/custom-elements-api",target:"_blank",rel:"noopener noreferrer",children:"文档《自定义元素 API 》"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"39-sveltefragmentlegacy",children:["3.9. ",(0,s.jsx)(n.a,{href:"/svelte:fragment",children:"svelte:fragment"}),"（Legacy）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#39-sveltefragmentlegacy",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<svelte:fragment>"})," 用于将内容放置在命名插槽中，而无须包装在 DOM 元素中，类似于 React 的 ",(0,s.jsx)(n.code,{children:"<></>"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<Widget>\n  <h1 slot="header">Hello</h1>\n  <svelte:fragment slot="footer">\n    <p>All rights reserved.</p>\n    <p>Copyright (c) 2019 Svelte Industries</p>\n  </svelte:fragment>\n</Widget>\n\n\x3c!-- Widget.svelte --\x3e\n<div>\n  <slot name="header">No header was provided</slot>\n  <p>Some content between header and footer</p>\n  <slot name="footer" />\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://svelte.dev/repl/b2152b8d753b4c87824d4132a6387346?version=4.2.19",title:"https://svelte.dev/repl/b2152b8d753b4c87824d4132a6387346?version=4.2.19",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"注：在 Svelte 5 中使用 Snippets 即可，因此该语法虽然可以继续使用，但被认为是过时的"}),"\n",(0,s.jsxs)(n.h2,{id:"4-最后",children:["4. 最后",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-最后",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本篇我们介绍了插槽和特殊元素的用法，插槽在 Svelte 5 中可被 Snippets 替代。特殊元素不算常用，但有时很有必要，所以了解即可，用到的时候再细查用法。"})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(k,{...e})}):k(e)}let C=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F42-Svelte%204%20%E2%9D%98%20Slots%20%E4%B8%8E%E5%86%85%E7%BD%AE%20elements.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. 插槽（Slots）",id:"2-插槽slots",depth:2},{text:"2.1. Slot Basic",id:"21-slot-basic",depth:3},{text:"2.2. Slot Fallbacks",id:"22-slot-fallbacks",depth:3},{text:"2.3. Slot 中的变量",id:"23-slot-中的变量",depth:3},{text:"2.4. Named Slots",id:"24-named-slots",depth:3},{text:"2.5. Slot Props",id:"25-slot-props",depth:3},{text:"2.6. Slot Forwarding",id:"26-slot-forwarding",depth:3},{text:"2.7. $$slots",id:"27-slots",depth:3},{text:"3. 特殊元素",id:"3-特殊元素",depth:2},{text:"3.1. svelte:component（Legacy）",id:"31-sveltecomponentlegacy",depth:3},{text:"3.2. svelte:element",id:"32-svelteelement",depth:3},{text:"3.3. svelte:self（Legacy）",id:"33-svelteselflegacy",depth:3},{text:"3.4. svelte:window",id:"34-sveltewindow",depth:3},{text:"3.5. svelte:body",id:"35-sveltebody",depth:3},{text:"3.6. svelte:document",id:"36-sveltedocument",depth:3},{text:"3.7. svelte:head",id:"37-sveltehead",depth:3},{text:"3.8. svelte:options",id:"38-svelteoptions",depth:3},{text:"3.9. svelte:fragment（Legacy）",id:"39-sveltefragmentlegacy",depth:3},{text:"4. 最后",id:"4-最后",depth:2}],title:"42-Svelte 4 ❘ Slots 与内置 elements",headingTitle:"42-Svelte 4 ❘ Slots 与内置 elements",frontmatter:{}}}}]);