"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["91821"],{570726:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var r=s(552676),d=s(740453);let i=s.p+"static/image/012a00940f480d7e43c59d97efcd9625.0faab4bd.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",hr:"hr",blockquote:"blockquote",h3:"h3",code:"code",img:"img",strong:"strong",ol:"ol",h4:"h4",pre:"pre"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"6一面-5浏览器相关知识点与高频考题解析",children:["6.一面 5：浏览器相关知识点与高频考题解析",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6一面-5浏览器相关知识点与高频考题解析",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Web 前端工程师写的页面要跑在浏览器里面，所以面试中也会出现很多跟浏览器相关的面试题目。"}),"\n",(0,r.jsxs)(n.h2,{id:"知识点梳理",children:["知识点梳理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点梳理",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"浏览器加载页面和渲染过程"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"性能优化"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Web 安全"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"本小节会从浏览器的加载过程开始讲解，然后介绍如何进行性能优化，最后介绍下 Web 开发中常见的安全问题和预防。"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"加载页面和渲染过程",children:["加载页面和渲染过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载页面和渲染过程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"可将加载过程和渲染过程分开说。回答问题的时候，关键要抓住核心的要点，把要点说全面，稍加解析即可，简明扼要不拖沓。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"题目：浏览器从加载页面到渲染页面的过程"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"加载过程",children:["加载过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载过程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"要点如下："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"浏览器根据 DNS 服务器得到域名的 IP 地址"}),"\n",(0,r.jsx)(n.li,{children:"向这个 IP 的机器发送 HTTP 请求"}),"\n",(0,r.jsx)(n.li,{children:"服务器收到、处理并返回 HTTP 请求"}),"\n",(0,r.jsx)(n.li,{children:"浏览器得到返回内容"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["例如在浏览器输入",(0,r.jsx)(n.code,{children:"https://juejin.cn/timeline"}),"，然后经过 DNS 解析，",(0,r.jsx)(n.code,{children:"juejin.cn"}),"对应的 IP 是",(0,r.jsx)(n.code,{children:"36.248.217.149"}),"（不同时间、地点对应的 IP 可能会不同）。然后浏览器向该 IP 发送 HTTP 请求。"]}),"\n",(0,r.jsx)(n.p,{children:"server 端接收到 HTTP 请求，然后经过计算（向不同的用户推送不同的内容），返回 HTTP 请求，返回的内容如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"其实就是一堆 HMTL 格式的字符串，因为只有 HTML 格式浏览器才能正确解析，这是 W3C 标准的要求。接下来就是浏览器的渲染过程。"}),"\n",(0,r.jsxs)(n.h3,{id:"渲染过程",children:["渲染过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染过程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"要点如下："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"根据 HTML 结构生成 DOM 树"}),"\n",(0,r.jsx)(n.li,{children:"根据 CSS 生成 CSSOM"}),"\n",(0,r.jsx)(n.li,{children:"将 DOM 和 CSSOM 整合形成 RenderTree"}),"\n",(0,r.jsx)(n.li,{children:"根据 RenderTree 开始渲染和展示"}),"\n",(0,r.jsxs)(n.li,{children:["遇到",(0,r.jsx)(n.code,{children:"<script>"}),"时，会执行并阻塞渲染"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。"}),"\n",(0,r.jsxs)(n.p,{children:["解析过程中，如果遇到",(0,r.jsx)(n.code,{children:'<link href="...">'}),"和",(0,r.jsx)(n.code,{children:'<script src="...">'}),"这种外链加载  CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。"]}),"\n",(0,r.jsxs)(n.p,{children:["浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了。大家可以想一下，有 DOM 结构、有样式，此时就能满足渲染的条件了。另外，这里也可以解释一个问题 —— ",(0,r.jsx)(n.strong,{children:"为何要将  CSS 放在 HTML 头部？"}),"—— 这样会让浏览器尽早拿到 CSS 尽早生成 CSSOM，然后在解析 HTML 之后可一次性生成最终的 RenderTree，渲染一次即可。如果 CSS 放在 HTML 底部，会出现渲染卡顿的情况，影响性能和体验。"]}),"\n",(0,r.jsxs)(n.p,{children:["最后，渲染过程中，如果遇到",(0,r.jsx)(n.code,{children:"<script>"}),"就停止渲染，执行 JS 代码。因为浏览器渲染和 JS 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。待",(0,r.jsx)(n.code,{children:"<script>"}),"内容执行完之后，浏览器继续渲染。最后再思考一个问题 —— ",(0,r.jsx)(n.strong,{children:"为何要将 JS 放在 HTML 底部？"}),"—— JS 放在底部可以保证让浏览器优先渲染完现有的 HTML 内容，让用户先看到内容，体验好。另外，JS 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JS 放在底部执行时，HTML 肯定都解析成了 DOM 结构。JS 如果放在 HTML 顶部，JS 执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。"]}),"\n",(0,r.jsxs)(n.p,{children:["关于浏览器整个流程，百度的多益大神有更加详细的文章，推荐阅读下：《",(0,r.jsx)(n.a,{href:"http://fex.baidu.com/blog/2014/05/what-happen/",target:"_blank",rel:"noopener noreferrer",children:"从输入 URL 到页面加载完成的过程中都发生了什么事情？\n"}),"》。"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"性能优化",children:["性能优化",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能优化",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"性能优化的题目也是面试常考的，这类题目有很大的扩展性，能够扩展出来很多小细节，而且对个人的技术视野和业务能力有很大的挑战。这部分笔者会重点讲下常用的性能优化方案。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"题目：总结前端性能优化的解决方案"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"优化原则和方向",children:["优化原则和方向",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化原则和方向",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["性能优化的原则是",(0,r.jsx)(n.strong,{children:"以更好的用户体验为标准"}),"，具体就是实现下面的目标："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"多使用内存、缓存或者其他方法"}),"\n",(0,r.jsx)(n.li,{children:"减少 CPU 和GPU 计算，更快展现"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"优化的方向有两个："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"减少页面体积，提升网络加载"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"优化页面渲染"})}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"减少页面体积提升网络加载",children:["减少页面体积，提升网络加载",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#减少页面体积提升网络加载",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"静态资源的压缩合并（JS 代码压缩合并、CSS 代码压缩合并、雪碧图）"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"静态资源缓存（资源名称加 MD5 戳）"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"使用 CDN 让资源加载更快"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"优化页面渲染",children:["优化页面渲染",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优化页面渲染",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"CSS 放前面，JS 放后面"}),"\n",(0,r.jsx)(n.li,{children:"懒加载（图片懒加载、下拉加载更多）"}),"\n",(0,r.jsx)(n.li,{children:"减少DOM 查询，对 DOM 查询做缓存"}),"\n",(0,r.jsxs)(n.li,{children:["减少DOM 操作，多个操作尽量合并在一起执行（",(0,r.jsx)(n.code,{children:"DocumentFragment"}),"）"]}),"\n",(0,r.jsx)(n.li,{children:"事件节流"}),"\n",(0,r.jsxs)(n.li,{children:["尽早执行操作（",(0,r.jsx)(n.code,{children:"DOMContentLoaded"}),"）"]}),"\n",(0,r.jsx)(n.li,{children:"使用 SSR 后端渲染，数据直接输出到 HTML 中，减少浏览器使用 JS 模板渲染页面 HTML 的时间"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"详细解释",children:["详细解释",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#详细解释",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"静态资源的压缩合并",children:["静态资源的压缩合并",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#静态资源的压缩合并",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果不合并，每个都会走一遍之前介绍的请求过程"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<script src="a.js"><\/script>\n<script src="b.js"><\/script>\n<script src="c.js"><\/script>\n'})}),"\n",(0,r.jsx)(n.p,{children:"如果合并了，就只走一遍请求过程"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<script src="abc.js"><\/script>\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"静态资源缓存",children:["静态资源缓存",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#静态资源缓存",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"通过链接名称控制缓存"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<script src="abc_1.js"><\/script>\n'})}),"\n",(0,r.jsx)(n.p,{children:"只有内容改变的时候，链接名称才会改变"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<script src="abc_2.js"><\/script>\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。"}),"\n",(0,r.jsxs)(n.h4,{id:"使用-cdn-让资源加载更快",children:["使用 CDN 让资源加载更快",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-cdn-让资源加载更快",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"CDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上。例如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<script src="https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js"><\/script>\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"使用-ssr-后端渲染",children:["使用 SSR 后端渲染",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-ssr-后端渲染",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"可一次性输出 HTML 内容，不用在页面渲染完成之后，再通过 Ajax 加载数据、再渲染。例如使用 smarty、Vue SSR 等。"}),"\n",(0,r.jsxs)(n.h4,{id:"css-放前面js-放后面",children:["CSS 放前面，JS 放后面",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-放前面js-放后面",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上文讲述浏览器渲染过程时已经提过，不再赘述。"}),"\n",(0,r.jsxs)(n.h4,{id:"懒加载",children:["懒加载",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#懒加载",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["一开始先给为 ",(0,r.jsx)(n.code,{children:"src"})," 赋值成一个通用的预览图，下拉时候再动态赋值成正式的图片。如下，",(0,r.jsx)(n.code,{children:"preview.png"}),"是预览图片，比较小，加载很快，而且很多图片都共用这个",(0,r.jsx)(n.code,{children:"preview.png"}),"，加载一次即可。待页面下拉，图片显示出来时，再去替换",(0,r.jsx)(n.code,{children:"src"}),"为",(0,r.jsx)(n.code,{children:"data-realsrc"}),"的值。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<img src="preview.png" data-realsrc="abc.png"/>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["另外，这里为何要用",(0,r.jsx)(n.code,{children:"data-"}),"开头的属性值？—— 所有 HTML 中自定义的属性，都应该用",(0,r.jsx)(n.code,{children:"data-"}),"开头，因为",(0,r.jsx)(n.code,{children:"data-"}),"开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。"]}),"\n",(0,r.jsxs)(n.h4,{id:"dom-查询做缓存",children:["DOM 查询做缓存",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dom-查询做缓存",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"两段代码做一下对比："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var pList = document.getElementsByTagName('p')  // 只查询一个 DOM ，缓存在 pList 中了\nvar i\nfor (i = 0; i < pList.length; i++) {\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var i\nfor (i = 0; i < document.getElementsByTagName('p').length; i++) {  // 每次循环，都会查询 DOM ，耗费性能\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"总结：DOM 操作，无论查询还是修改，都是非常耗费性能的，应尽量减少。"}),"\n",(0,r.jsxs)(n.h4,{id:"合并-dom-插入",children:["合并 DOM 插入",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#合并-dom-插入",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'var listNode = document.getElementById(\'list\')\n// 要插入 10 个 li 标签\nvar frag = document.createDocumentFragment();\nvar x, li;\nfor(x = 0; x < 10; x++) {\n    li = document.createElement("li");\n    li.innerHTML = "List item " + x;\n    frag.appendChild(li);  // 先放在 frag 中，最后一次性插入到 DOM 结构中。\n}\nlistNode.appendChild(frag);\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"事件节流",children:["事件节流",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#事件节流",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"例如要在文字改变时触发一个 change 事件，通过 keyup 来监听。使用节流。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"var textarea = document.getElementById('text')\nvar timeoutId\ntextarea.addEventListener('keyup', function () {\n    if (timeoutId) {\n        clearTimeout(timeoutId)\n    }\n    timeoutId = setTimeout(function () {\n        // 触发 change 事件\n    }, 100)\n})\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"尽早执行操作",children:["尽早执行操作",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#尽早执行操作",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"window.addEventListener('load', function () {\n    // 页面的全部资源加载完才会执行，包括图片、视频等\n})\ndocument.addEventListener('DOMContentLoaded', function () {\n    // DOM 渲染完即可执行，此时图片、视频还可能没有加载完\n})\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"性能优化怎么做",children:["性能优化怎么做",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能优化怎么做",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面提到的都是性能优化的单个点，性能优化项目具体实施起来，应该按照下面步骤推进："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"建立性能数据收集平台，摸底当前性能数据，通过性能打点，将上述整个页面打开过程消耗时间记录下来"}),"\n",(0,r.jsx)(n.li,{children:"分析耗时较长时间段原因，寻找优化点，确定优化目标"}),"\n",(0,r.jsx)(n.li,{children:"开始优化"}),"\n",(0,r.jsx)(n.li,{children:"通过数据收集平台记录优化效果"}),"\n",(0,r.jsx)(n.li,{children:"不断调整优化点和预期目标，循环2~4步骤"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"性能优化是个长期的事情，不是一蹴而就的，应该本着先摸底、再分析、后优化的原则逐步来做。"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"web-安全",children:["Web 安全",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#web-安全",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"题目：前端常见的安全问题有哪些？"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Web 前端的安全问题，能回答出下文的两个问题，这个题目就能基本过关了。开始之前，先说一个最简单的攻击方式 —— SQL 注入。"}),"\n",(0,r.jsx)(n.p,{children:"上学的时候就知道有一个「SQL注入」的攻击方式。例如做一个系统的登录界面，输入用户名和密码，提交之后，后端直接拿到数据就拼接 SQL 语句去查询数据库。如果在输入时进行了恶意的 SQL 拼装，那么最后生成的 SQL 就会有问题。但是现在稍微大型一点的系统，都不会这么做，从提交登录信息到最后拿到授权，要经过层层的验证。因此，SQL 注入都只出现在比较低端小型的系统上。"}),"\n",(0,r.jsxs)(n.h3,{id:"xsscross-site-scripting跨站脚本攻击",children:["XSS（Cross Site Scripting，跨站脚本攻击）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#xsscross-site-scripting跨站脚本攻击",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这是前端最常见的攻击方式，很多大型网站（如 Facebook）都被 XSS 攻击过。"}),"\n",(0,r.jsxs)(n.p,{children:["举一个例子，我在一个博客网站正常发表一篇文章，输入汉字、英文和图片，完全没有问题。但是如果我写的是恶意的 JS 脚本，例如获取到",(0,r.jsx)(n.code,{children:"document.cookie"}),"然后传输到自己的服务器上，那我这篇博客的每一次浏览都会执行这个脚本，都会把访客 cookie 中的信息偷偷传递到我的服务器上来。"]}),"\n",(0,r.jsxs)(n.p,{children:["其实原理上就是黑客通过某种方式（发布文章、发布评论等）将一段特定的 JS 代码隐蔽地输入进去。然后别人再看这篇文章或者评论时，之前注入的这段 JS 代码就执行了。",(0,r.jsx)(n.strong,{children:"JS 代码一旦执行，那可就不受控制了，因为它跟网页原有的 JS 有同样的权限"}),"，例如可以获取 server 端数据、可以获取 cookie 等。于是，攻击就这样发生了。"]}),"\n",(0,r.jsxs)(n.h4,{id:"xss的危害",children:["XSS的危害",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#xss的危害",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"XSS 的危害相当大，如果页面可以随意执行别人不安全的 JS 代码，轻则会让页面错乱、功能缺失，重则会造成用户的信息泄露。"}),"\n",(0,r.jsx)(n.p,{children:"比如早些年社交网站经常爆出 XSS 蠕虫，通过发布的文章内插入 JS，用户访问了感染不安全 JS 注入的文章，会自动重新发布新的文章，这样的文章会通过推荐系统进入到每个用户的文章列表面前，很快就会造成大规模的感染。"}),"\n",(0,r.jsx)(n.p,{children:"还有利用获取 cookie 的方式，将 cookie 传入入侵者的服务器上，入侵者就可以模拟 cookie 登录网站，对用户的信息进行篡改。"}),"\n",(0,r.jsxs)(n.h4,{id:"xss的预防",children:["XSS的预防",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#xss的预防",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"那么如何预防 XSS 攻击呢？—— 最根本的方式，就是对用户输入的内容进行验证和替换，需要替换的字符有："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:"& 替换为：&amp;\n< 替换为：&lt;\n> 替换为：&gt;\n” 替换为：&quot;\n‘ 替换为：&#x27;\n/ 替换为：&#x2f;\n"})}),"\n",(0,r.jsx)(n.p,{children:"替换了这些字符之后，黑客输入的攻击代码就会失效，XSS 攻击将不会轻易发生。"}),"\n",(0,r.jsxs)(n.p,{children:["除此之外，还可以通过对 cookie 进行较强的控制，比如对敏感的 cookie 增加",(0,r.jsx)(n.code,{children:"http-only"}),"限制，让 JS 获取不到 cookie 的内容。"]}),"\n",(0,r.jsxs)(n.h3,{id:"csrfcross-site-request-forgery跨站请求伪造",children:["CSRF（Cross-site request forgery，跨站请求伪造）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#csrfcross-site-request-forgery跨站请求伪造",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"CSRF 是借用了当前操作者的权限来偷偷地完成某个操作，而不是拿到用户的信息。"}),"\n",(0,r.jsxs)(n.p,{children:["例如，一个支付类网站，给他人转账的接口是",(0,r.jsx)(n.code,{children:"http://buy.com/pay?touid=999&money=100"}),"，而这个接口在使用时没有任何密码或者 token 的验证，只要打开访问就直接给他人转账。一个用户已经登录了",(0,r.jsx)(n.code,{children:"http://buy.com"}),"，在选择商品时，突然收到一封邮件，而这封邮件正文有这么一行代码",(0,r.jsx)(n.code,{children:'<img src="http://buy.com/pay?touid=999&money=100"/>'}),"，他访问了邮件之后，其实就已经完成了购买。"]}),"\n",(0,r.jsxs)(n.p,{children:["CSRF 的发生其实是借助了一个 cookie 的特性。我们知道，登录了",(0,r.jsx)(n.code,{children:"http://buy.com"}),"之后，cookie 就会有登录过的标记了，此时请求",(0,r.jsx)(n.code,{children:"http://buy.com/pay?touid=999&money=100"}),"是会带着 cookie 的，因此 server 端就知道已经登录了。而如果在",(0,r.jsx)(n.code,{children:"http://buy.com"}),"去请求其他域名的 API 例如",(0,r.jsx)(n.code,{children:"http://abc.com/api"}),"时，是不会带 cookie 的，这是浏览器的同源策略的限制。但是 —— ",(0,r.jsxs)(n.strong,{children:["此时在其他域名的页面中，请求",(0,r.jsx)(n.code,{children:"http://buy.com/pay?touid=999&money=100"}),"，会带着",(0,r.jsx)(n.code,{children:"buy.com"}),"的 cookie ，这是发生 CSRF 攻击的理论基础。"]})]}),"\n",(0,r.jsxs)(n.p,{children:["预防 CSRF 就是加入各个层级的权限验证，例如现在的购物网站，只要涉及现金交易，肯定要输入密码或者指纹才行。除此之外，敏感的接口使用",(0,r.jsx)(n.code,{children:"POST"}),"请求而不是",(0,r.jsx)(n.code,{children:"GET"}),"也是很重要的。"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本小节总结了前端运行环境（即浏览器）的一些常考查知识点，包括页面加载过程、如何性能优化以及需要注意的安全问题。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let l=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Web%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E8%A7%A3%E6%9E%90%2F6.%E4%B8%80%E9%9D%A2%205%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E8%A7%A3%E6%9E%90.md"]={toc:[{text:"知识点梳理",id:"知识点梳理",depth:2},{text:"加载页面和渲染过程",id:"加载页面和渲染过程",depth:2},{text:"加载过程",id:"加载过程",depth:3},{text:"渲染过程",id:"渲染过程",depth:3},{text:"性能优化",id:"性能优化",depth:2},{text:"优化原则和方向",id:"优化原则和方向",depth:3},{text:"减少页面体积，提升网络加载",id:"减少页面体积提升网络加载",depth:3},{text:"优化页面渲染",id:"优化页面渲染",depth:3},{text:"详细解释",id:"详细解释",depth:3},{text:"静态资源的压缩合并",id:"静态资源的压缩合并",depth:4},{text:"静态资源缓存",id:"静态资源缓存",depth:4},{text:"使用 CDN 让资源加载更快",id:"使用-cdn-让资源加载更快",depth:4},{text:"使用 SSR 后端渲染",id:"使用-ssr-后端渲染",depth:4},{text:"CSS 放前面，JS 放后面",id:"css-放前面js-放后面",depth:4},{text:"懒加载",id:"懒加载",depth:4},{text:"DOM 查询做缓存",id:"dom-查询做缓存",depth:4},{text:"合并 DOM 插入",id:"合并-dom-插入",depth:4},{text:"事件节流",id:"事件节流",depth:4},{text:"尽早执行操作",id:"尽早执行操作",depth:4},{text:"性能优化怎么做",id:"性能优化怎么做",depth:4},{text:"Web 安全",id:"web-安全",depth:2},{text:"XSS（Cross Site Scripting，跨站脚本攻击）",id:"xsscross-site-scripting跨站脚本攻击",depth:3},{text:"XSS的危害",id:"xss的危害",depth:4},{text:"XSS的预防",id:"xss的预防",depth:4},{text:"CSRF（Cross-site request forgery，跨站请求伪造）",id:"csrfcross-site-request-forgery跨站请求伪造",depth:3},{text:"小结",id:"小结",depth:2}],title:"6.一面 5：浏览器相关知识点与高频考题解析",headingTitle:"6.一面 5：浏览器相关知识点与高频考题解析",frontmatter:{}}}}]);