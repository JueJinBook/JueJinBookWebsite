"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["50547"],{883656:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var d=s(552676),o=s(740453);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",strong:"strong",h2:"h2",ol:"ol",li:"li"},(0,o.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"3-nodejs-的模块管理下",children:["3 Node.js 的模块管理（下）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-nodejs-的模块管理下",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["上一节课我们说过，Node.js 诞生的时候，模块管理采用",(0,d.jsx)(n.code,{children:"CommonJS"}),"规范。",(0,d.jsx)(n.code,{children:"CommonJS"}),"规范是一套和",(0,d.jsx)(n.code,{children:"ES Modules"}),"不同的模块管理方式。因为 Node.js 的",(0,d.jsx)(n.code,{children:"ES Modules"}),"还处在实验特性阶段，大部分 Node 模块还是用",(0,d.jsx)(n.code,{children:"CommonJS"}),"规范实现的。"]}),"\n",(0,d.jsxs)(n.p,{children:["这一节课我们就来看一下，如果用",(0,d.jsx)(n.code,{children:"CommonJS"}),"规范实现",(0,d.jsx)(n.code,{children:"ziyue"}),"模块该怎么做。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们还是先写一个",(0,d.jsx)(n.code,{children:"ziyue.js"}),"文件，内容如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const ziyue = (text) => `\n                 __._                                   \n                / ___)_                                 \n               (_/Y ===\\\\                                __ \n               |||.==. =).                                | \n               |((| o |p|      |  ${text}\n            _./| \\\\(  /=\\\\ )     |__                    \n          /  |@\\\\ ||||||||.                             \n         /    \\\\@\\\\ ||||||||\\\\                          \n        /   \\\\  \\\\@\\\\ ||||||//\\\\                        \n       (     Y  \\\\@\\\\|||| // _\\\\                        \n       |    -\\\\   \\\\@\\\\ \\\\\\\\//    \\\\                    \n       |     -\\\\__.-./ //\\\\.---.^__                        \n       | \\\\    /  |@|__/\\\\_|@|  |  |                         \n       \\\\__\\\\      |@||| |||@|     |                    \n       <@@@|     |@||| |||@|    /                       \n      / ---|     /@||| |||@|   /                                 \n     |    /|    /@/ || |||@|  /|                        \n     |   //|   /@/  ||_|||@| / |                        \n     |  // \\\\ ||@|   /|=|||@| | |                       \n     \\\\ //   \\\\||@|  / |/|||@| \\\\ |                     \n     |//     ||@| /  ,/|||@|   |                        \n     //      ||@|/  /|/||/@/   |                        \n    //|   ,  ||//  /\\\\|/\\\\/@/  / /                      \n   //\\\\   /   \\\\|/  /H\\\\|/H\\\\/  /_/                     \n  // |\\\\_/     |__/|H\\\\|/H|\\\\_/                         \n |/  |\\\\        /  |H===H| |                            \n     ||\\\\      /|  |H|||H| |                            \n     ||______/ |  |H|||H| |                             \n      \\\\_/ _/  _/  |L|||J| \\\\_                          \n      _/  ___/   ___\\\\__/___ '-._                       \n     /__________/===\\\\__/===\\\\---'                     \n                                                        \n`;\n\nmodule.exports = ziyue;\n"})}),"\n",(0,d.jsxs)(n.p,{children:["然后写一个",(0,d.jsx)(n.code,{children:"index.js"}),"文件："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const ziyue = require('./ziyue');\n\nconst argv = process.argv;\nconsole.log(ziyue(argv[2] || '有朋自远方来，不亦乐乎！'));\n"})}),"\n",(0,d.jsxs)(n.p,{children:["运行",(0,d.jsx)(n.code,{children:"node index.js"}),"就可以得到我们要的输出了。可以看到，实际上",(0,d.jsx)(n.code,{children:"CommonJS"}),"和",(0,d.jsx)(n.code,{children:"ES Modules"}),"类似，和",(0,d.jsx)(n.code,{children:"ES Modules"}),"不同的地方是，",(0,d.jsx)(n.code,{children:"CommonJS"}),"采用",(0,d.jsx)(n.code,{children:"module.exports/require"}),"而",(0,d.jsx)(n.code,{children:"ES Modules"}),"则采用",(0,d.jsx)(n.code,{children:"export/import"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"同样，CommonJS 规范可以导出多个接口："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// abc.js\nconst a = 1;\nconst b = 2;\nconst c = () => a + b;\n\nmodule.exports = {\n  a, b, c\n};\n"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const {a, b, c} = require('./abc.js');\nconsole.log(a, b, c()); // 1 2 3\n"})}),"\n",(0,d.jsxs)(n.p,{children:["与",(0,d.jsx)(n.code,{children:"ES Modules"}),"不同的是，",(0,d.jsx)(n.code,{children:"module.exports"}),"导出的是真正的对象，所以我们可以这样给 API 别名："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// abc.js\nconst a = 1;\nconst b = 2;\nconst c = () => a + b;\n\nmodule.exports = {\n  d: a,\n  e: b,\n  f: c\n};\n"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const {d, e, f} = require('./abc.js'); // 这里要用d、e、f了\nconsole.log(d, e, f()); // 1 2 3\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在 CommonJS 规范中，有两种导出模块 API 的方式：",(0,d.jsx)(n.code,{children:"module.exports"}),"和",(0,d.jsx)(n.code,{children:"exports"}),"。这两个变量默认情况下都指向同一个初始值",(0,d.jsx)(n.code,{children:"{}"}),"。因此，除了使用",(0,d.jsx)(n.code,{children:"module.exports"}),"我们也可以使用",(0,d.jsx)(n.code,{children:"exports"}),"变量导出模块的 API："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// abc.js\nexports.a = 1;\nexports.b = 2;\nexports.c = () => a + b;\n"})}),"\n",(0,d.jsxs)(n.p,{children:["但是，这种用法",(0,d.jsx)(n.strong,{children:"不能"}),"和",(0,d.jsx)(n.code,{children:"module.exports"}),"混用。因为",(0,d.jsx)(n.code,{children:"module.exports = 新对象"}),"改写了",(0,d.jsx)(n.code,{children:"module.exports"}),"的默认引用，而引擎默认返回的是",(0,d.jsx)(n.code,{children:"modeule.exports"}),"，从而导致",(0,d.jsx)(n.code,{children:"exports"}),"指向的初始空间无效了。这样一来，原先用",(0,d.jsx)(n.code,{children:"exports"}),"导出的那些数据就不会被导出了。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"exports.a = 1;\nexports.b = 2;\nexports.c = () => a + b;\nconst d = 'foobar';\nmoudle.exports = {d};\n"})}),"\n",(0,d.jsxs)(n.p,{children:["上面的代码只导出了",(0,d.jsx)(n.code,{children:"d:foobar"}),"而没有导出",(0,d.jsx)(n.code,{children:"a、b、c"}),"，因为",(0,d.jsx)(n.code,{children:"module.exports = {d}"}),"覆盖了默认的初始空间，这让之前 exports 变量上增加的属性（a、b、c）不会再被导出。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"CommonJS"}),"规范有 1、2 两个版本，",(0,d.jsx)(n.code,{children:"exports.属性名 = ..."}),"的用法属于早期，也就是 CommonJS 1 的用法。",(0,d.jsx)(n.code,{children:"module.exports"}),"用法属于",(0,d.jsx)(n.code,{children:"CommonJS 2"}),"的用法，我们应该尽量用",(0,d.jsx)(n.code,{children:"module.exports"}),"，避免用",(0,d.jsx)(n.code,{children:"exports.属性名 = "}),"的写法。"]}),"\n",(0,d.jsxs)(n.h2,{id:"es-modules的向下兼容",children:[(0,d.jsx)(n.code,{children:"ES Modules"}),"的向下兼容",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#es-modules的向下兼容",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在 Node.js 环境中，ES Modules 向下兼容 CommonJS，因此用",(0,d.jsx)(n.code,{children:"import"}),"方式可以引入 CommonJS 方式导出的 API，但是会以 ",(0,d.jsx)(n.code,{children:"default"})," 方式引入。"]}),"\n",(0,d.jsx)(n.p,{children:"因此以下写法："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// abc.js 这是一个 CommonJS 规范的模块\nconst a = 1;\nconst b = 2;\nconst c = () => a + b;\n\nmodule.exports = {a, b, c};\n"})}),"\n",(0,d.jsxs)(n.p,{children:["它可以用",(0,d.jsx)(n.code,{children:"ES Modules"}),"的",(0,d.jsx)(n.code,{children:"import"}),"引入："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import abc from './test.js';\nconsole.log(abc.a, abc.b, abc.c()); // 1 2 3\n"})}),"\n",(0,d.jsx)(n.p,{children:"但是不能用"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import {a, b, c} from './test.js';\n"})}),"\n",(0,d.jsxs)(n.p,{children:["因为 ",(0,d.jsx)(n.code,{children:"module.exports = {a, b, c}"})," 相当于："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const abc = {a, b, c};\nexport default abc;\n"})}),"\n",(0,d.jsxs)(n.h2,{id:"es-modules与commonjs的主要区别",children:[(0,d.jsx)(n.code,{children:"ES Modules"}),"与",(0,d.jsx)(n.code,{children:"CommonJS"}),"的主要区别",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#es-modules与commonjs的主要区别",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ES Modules"}),"与",(0,d.jsx)(n.code,{children:"CommonJS"}),"的主要有四个区别。第一个区别前面也提到过，",(0,d.jsx)(n.strong,{children:"如果要在导出时使用别名"}),"，",(0,d.jsx)(n.code,{children:"ES Modules"}),"要写成："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"export {\n  a as d,\n  b as e,\n  c as f,\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["而对应的",(0,d.jsx)(n.code,{children:"CommonJS"}),"的写法是："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  d: a,\n  e: b,\n  f: c,\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["第二个区别是，",(0,d.jsxs)(n.strong,{children:[(0,d.jsx)(n.code,{children:"CommonJS"}),"在",(0,d.jsx)(n.code,{children:"require"}),"文件的时候采用文件路径，并且可以忽略 .js 文件扩展名"]}),"。也就是说，",(0,d.jsx)(n.code,{children:"require('./ziyue.js')"}),"也可以写成",(0,d.jsx)(n.code,{children:"require('./ziyue')"}),"。但是，",(0,d.jsx)(n.code,{children:"ES Modules"}),"在",(0,d.jsx)(n.code,{children:"import"}),"的时候采用的是 URL 规范就不能省略文件的扩展名，而必须写成完整的文件名",(0,d.jsx)(n.code,{children:"import {ziyue} from './ziyue.mjs'"}),"，",(0,d.jsx)(n.code,{children:".mjs"}),"的扩展名不能省略。"]}),"\n",(0,d.jsxs)(n.p,{children:["\uD83D\uDCA1如果你使用 Babel 编译的方式将",(0,d.jsx)(n.code,{children:"ES Modules"}),"编译成",(0,d.jsx)(n.code,{children:"CommonJS"}),"，因为 Babel 自己做了处理，所以可以省略文件扩展名，但是根据规范还是应该保留文件扩展名。"]}),"\n",(0,d.jsxs)(n.p,{children:["第三个区别是，",(0,d.jsxs)(n.strong,{children:[(0,d.jsx)(n.code,{children:"ES Modules"}),"的",(0,d.jsx)(n.code,{children:"import"}),"和",(0,d.jsx)(n.code,{children:"export"}),"都只能写在最外层，不能放在块级作用域或函数作用域中"]}),"。比如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"if(condition) {\n  import {a} from './foo';\n} else {\n  import {a} from './bar';\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["这样的写法，在",(0,d.jsx)(n.code,{children:"ES Modules"}),"中是不被允许的。但是，像下面这样写在",(0,d.jsx)(n.code,{children:"CommonJS"}),"中是被允许的："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"let api;\nif(condition) {\n  api = require('./foo');\n} else {\n  api = require('./bar');\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"事实上，CommonJS 的 require 可以写在任何语句块中。"}),"\n",(0,d.jsxs)(n.p,{children:["第四个区别是，",(0,d.jsx)(n.strong,{children:"require 是一个函数调用，路径是参数字符串，它可以动态拼接"}),"，比如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const libPath = ENV.supportES6 ? './es6/' : './';\nconst myLib = require(`${libPath}mylib.js`);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["但是",(0,d.jsx)(n.code,{children:"ES Modules"}),"的",(0,d.jsx)(n.code,{children:"import"}),"语句是不允许用动态路径的。"]}),"\n",(0,d.jsxs)(n.h2,{id:"import-动态加载",children:["import() 动态加载",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#import-动态加载",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ES Modules"}),"不允许",(0,d.jsx)(n.code,{children:"import"}),"语句用动态路径，也不允许在语句块中使用它。但是，它提供了一个异步动态加载模块的机制 —— 将",(0,d.jsx)(n.code,{children:"import"}),"作为异步函数使用。"]}),"\n",(0,d.jsx)(n.p,{children:"所以我们可以这样动态加载："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"(async function() {\n  const {ziyue} = await import('./ziyue.mjs');\n  \n  const argv = process.argv;\n  console.log(ziyue(argv[2] || '巧言令色，鮮矣仁！'));\n}());\n"})}),"\n",(0,d.jsxs)(n.p,{children:["同样地，我们也可以向下兼容地加载 CommonJS 模块，",(0,d.jsx)(n.code,{children:"module.exports"}),"导出的对象会被作为",(0,d.jsx)(n.code,{children:"default"}),"对象加载进来。"]}),"\n",(0,d.jsx)(n.p,{children:"一般来说，在写 Node.js 模块的时候，我们更多采用静态的方式引入模块。但是动态加载模块在一些复杂的库中比较有用，尤其是跨平台开发中，我们可能需要针对不同平台的环境加载不同的模块，这个时候采用动态加载就是必须的了。"}),"\n",(0,d.jsxs)(n.p,{children:["到这里，我们基本上介绍完了 Node.js 模块管理的 ES Modules 和 CommonJS 的基本用法，在后续的课程中，我们将会经常用到它们。关于 CommonJS 还有更多的用法，如果你想了解，可以参考",(0,d.jsx)(n.a,{href:"http://nodejs.cn/api/modules.html",target:"_blank",rel:"noopener noreferrer",children:"Node.js 官方 API 文档"}),"。"]}),"\n",(0,d.jsxs)(n.h2,{id:"总结",children:["总结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"这一节课，我们介绍了 CommonJS 规范创建和引入模块的语法。与 ES Module 语法不同，CommonJS 规范采用 module.export/require 的方式引出和引入模块。由于 ES Module 的向下兼容，遵循 CommonJS 规范的模块可以被 ES Module 规范以 default 方式引入。"}),"\n",(0,d.jsx)(n.p,{children:"此外，我们还要注意，CommonJS 和 ES Module 规范两者有四个不同："}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"重命名导出的公共 API 的方式不同；"}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["CommonJS 在",(0,d.jsx)(n.code,{children:"require"}),"文件的时候可以忽略 .js 文件扩展名，而 ES Module 在",(0,d.jsx)(n.code,{children:"import"}),"文件的时候不能忽略 .mjs 的扩展名；"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["CommonJS 规范的",(0,d.jsx)(n.code,{children:"require"}),"是可以放在块级作用域中的，而 ES Module 的",(0,d.jsx)(n.code,{children:"import"}),"则不能放在任何语句块中；"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["CommonJS 的",(0,d.jsx)(n.code,{children:"require"}),"是一个函数，可以动态拼接文件路径，而",(0,d.jsx)(n.code,{children:"ES Modules"}),"的",(0,d.jsx)(n.code,{children:"import"}),"语句是不允许用动态路径的。"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["虽然 ES Module 规范不允许",(0,d.jsx)(n.code,{children:"import"}),"语句动态拼接路径，但是它允许",(0,d.jsx)(n.code,{children:"import"}),"作为异步函数异步动态加载模块。"]})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(c,{...e})}):c(e)}let l=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F3%20Node.js%20%E7%9A%84%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"`ES Modules`的向下兼容",id:"es-modules的向下兼容",depth:2},{text:"`ES Modules`与`CommonJS`的主要区别",id:"es-modules与commonjs的主要区别",depth:2},{text:"import() 动态加载",id:"import-动态加载",depth:2},{text:"总结",id:"总结",depth:2}],title:"3 Node.js 的模块管理（下）",headingTitle:"3 Node.js 的模块管理（下）",frontmatter:{}}}}]);