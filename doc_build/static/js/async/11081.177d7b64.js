"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11081"],{497240:function(e,n,t){t.r(n),t.d(n,{default:()=>v});var s=t(552676),r=t(740453);let c=t.p+"static/image/ebf8b8caa90bd9ca8cb64b5ebf757df2.67f287be.webp",d=t.p+"static/image/a047de167321204a0930b1e5bf01d49b.225902b5.webp",i=t.p+"static/image/6e192e5e960838863a99653457506a38.d10ba0e8.webp",l=t.p+"static/image/ed4cba2c18e7ce7a07bb6e9c83702090.0ba52803.webp",a=t.p+"static/image/b73f46bbcca2a1d297d297f22a45b73d.1c5d1cdd.webp",o=t.p+"static/image/c350126f9e77f6c78475fbd3f4c60c9f.ebbe9328.webp",h=t.p+"static/image/3fcd2dd16bfd5ad88c67d1b1515479b4.38e80efa.webp",p=t.p+"static/image/5c0884b24c8bfe8a466328664944bc78.efd9c23d.webp",x=t.p+"static/image/577008a091f7895473213c0507565608.a9c09569.webp";function j(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",img:"img",pre:"pre",strong:"strong",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ol:"ol",li:"li"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"43-svelte-4--客户端-api-与服务端-api",children:["43-Svelte 4 ❘ 客户端 API 与服务端 API",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-svelte-4--客户端-api-与服务端-api",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"推荐学习指数：⭐️️，了解即可"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通常 Svelte 项目我们会使用官方脚手架 SvelteKit 进行开发，所以不会用到这些内容，本篇简单看一下了解即可。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注：在 Svelte 5 中，API 略有改变，参考 ",(0,s.jsx)(n.a,{href:"https://svelte.dev/docs/svelte/legacy-component-api",title:"https://svelte.dev/docs/svelte/legacy-component-api",target:"_blank",rel:"noopener noreferrer",children:"svelte.dev/docs/svelte…"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-客户端-api",children:["2. 客户端 API",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-客户端-api",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["当我们导入一个 ",(0,s.jsx)(n.code,{children:".svelte"})," 模块的时候，导入的其实是一个组件类："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们该如何使用这个组件类呢？这就是 Svelte 客户端 API 要介绍的内容。"}),"\n",(0,s.jsx)(n.p,{children:"如果我们使用的是 SvelteKit，基本不需要使用客户端 API。但如果是借助其他构建工具从头构建 Svelte 项目脚手架，则有可能会用到，比如使用 vite 创建一个 Svelte 的项目："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm create vite@latest\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们选择 Svelte 框架和 JavaScript 语法："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注：Svelte 项目并不建议使用 Vite 创建，因为这个模板的很多东西比如路由都需要自己从头实现，最好还是使用 SvelteKit，这里是为了方便客户端 API 的演示"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"创建的项目目录结构如下（做了部分精简）："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"vite-svelte\n├─ src\n│  ├─ lib\n│  │  └─ Counter.svelte\n│  ├─ App.svelte\n│  ├─ app.css\n│  ├─ main.js\n├─ index.html\n├─ jsconfig.json\n├─ package.json\n├─ svelte.config.js\n└─ vite.config.js\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个项目是如何运行起来的呢？"}),"\n",(0,s.jsxs)(n.p,{children:["首先 ",(0,s.jsx)(n.code,{children:"vite.config.js"})," 引入了 ",(0,s.jsx)(n.code,{children:"svelte"})," 插件，负责编译 ",(0,s.jsx)(n.code,{children:".svelte"})," 模块："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { defineConfig } from "vite";\nimport { svelte } from "@sveltejs/vite-plugin-svelte";\n\nexport default defineConfig({\n  plugins: [svelte()],\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["然后查看",(0,s.jsx)(n.code,{children:"main.js"})," 的代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import './app.css'\nimport App from './App.svelte'\n\nconst app = new App({\n  target: document.getElementById('app'),\n})\n\nexport default app\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"main.js"})," 中引入主要的 ",(0,s.jsx)(n.code,{children:"App.svelte"})," 模块，使用 new 构造了一个组件实例对象，通过 ",(0,s.jsx)(n.code,{children:"target"})," 属性指定挂载的位置，然后导出该组件实例。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"index.html"}),"中引入打包后的 ",(0,s.jsx)(n.code,{children:"main.js"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + Svelte</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script type="module" src="/src/main.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsx)(n.p,{children:"简而言之：vite 负责打包编译 svelte 模块，main.js 引入 svelte 模块并进行实例化，index.html 引入 main.js"}),"\n",(0,s.jsxs)(n.p,{children:["当然我们并不是要讲解如何从头构建一个 Svelte 项目，而是借这个例子说明 ",(0,s.jsx)(n.strong,{children:"Svelte 客户端 API 要解决的问题是如何在正常的 JavaScript 文件中使用 Svelte 模块"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"21-创建组件",children:["2.1. 创建组件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-创建组件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"如果创建并挂载一个组件呢？很简单，new 一个就行。基础示例代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import App from './App.svelte'; \nconst app = new App({ target: document.body });\n"})}),"\n",(0,s.jsx)(n.p,{children:"除了 target，还有以下等选项："}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{align:"center",children:"选项"}),"\n",(0,s.jsx)(n.th,{align:"center",children:"默认"}),"\n",(0,s.jsx)(n.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"target"})}),"\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"none"})}),"\n",(0,s.jsx)(n.td,{children:"必须，组件要挂载的位置"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"anchor"})}),"\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"null"})}),"\n",(0,s.jsx)(n.td,{children:"该元素必须是 target 的子级，组件会挂载在该元素之前"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"props"})}),"\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"{}"})}),"\n",(0,s.jsx)(n.td,{children:"传递给组件的属性"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"context"})}),"\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"new Map()"})}),"\n",(0,s.jsx)(n.td,{children:"传递给组件的上下文"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"hydrate"})}),"\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"false"})}),"\n",(0,s.jsx)(n.td,{children:"是否进行水合"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"intro"})}),"\n",(0,s.jsx)(n.td,{align:"center",children:(0,s.jsx)(n.code,{children:"false"})}),"\n",(0,s.jsx)(n.td,{children:"当为 true 的时候，会在组件初始化的时候播放过渡动画"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"与 React 不同，当进行挂载的时候，target 的现有子级会保留在原处。"}),"\n",(0,s.jsx)(n.p,{children:"为了体会这些选项的作用，我们可以写一个简单的例子。"}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"index.html"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + Svelte</title>\n  </head>\n  <body>\n    <div id="app">\n      <div id="header">Header</div>\n      <div id="footer">\n        <button id="reset1">Reset1</button>\n        <button id="reset2">Reset2</button>\n        <button id="destroy">destroy</button>\n      </div>\n    </div>\n    <script type="module" src="/src/main.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"src/main.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import "./app.css";\nimport App from "./App.svelte";\n\nconst app = new App({\n  target: document.getElementById("app"),\n  anchor: document.getElementById("footer"),\n  props: {\n    counter: 10,\n  },\n  context: new Map([["theme", "dark"]]),\n  intro: true,\n});\n\nexport default app;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"src/App.svelte"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { getContext } from 'svelte';\n  import { fade } from 'svelte/transition';\n  export let counter;\n\n  const theme = getContext('theme');\n<\/script>\n\n当前主题：{theme}\n\n<div transition:fade|global={{ delay: 250, duration: 1000}}>\n  <button on:click={()=> { counter += 1}}>+</button>\n  {counter}\n  <button on:click={()=> { counter -= 1}}>-</button>\n</div>\n"})}),"\n",(0,s.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个例子演示了除 hydrate 之外所有属性的用法。因为设置了 anchor，所以组件挂载在 Footer 之前。因为设置了 context，所以能在组件中通过 getContext 获取主题的值。因为设置了 props，所以组件能够获取该值并设置 计数器的初始值。因为设置了 intro，所以组件初始化的时候也有过渡动画。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注意：设置 ",(0,s.jsx)(n.code,{children:"intro:true"}),"后，还要将过渡动画设置为 ",(0,s.jsx)(n.code,{children:"global"}),"才能生效"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["最后我们说说 ",(0,s.jsx)(n.code,{children:"hydrate"}),"选项，所谓水合就是为 DOM 元素添加事件的过程。hydrate 通常搭配服务端渲染一起使用，当为 true 时，Svelte 会对现有 DOM 进行水合，而非重新创建 DOM 元素。"]}),"\n",(0,s.jsxs)(n.p,{children:["设置 ",(0,s.jsx)(n.code,{children:"hydrate: true"})," 将导致所有子级被删除。因此， ",(0,s.jsx)(n.code,{children:"anchor"})," 选项不能与 ",(0,s.jsx)(n.code,{children:"hydrate: true"})," 一起使用。"]}),"\n",(0,s.jsxs)(n.h3,{id:"22-set",children:["2.2. $set",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-set",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"component.$set(props)"}),"用于设置实例的 props，",(0,s.jsx)(n.code,{children:"component.$set({ x: 1 })"}),"相当于在组件的 ",(0,s.jsx)(n.code,{children:"<script>"}),"中设置 ",(0,s.jsx)(n.code,{children:"x = 1"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"main.js"}),"，添加如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'document.getElementById("reset1").addEventListener("click", () => {\n  app.$set({\n    counter: 10,\n  });\n});\n\ndocument.getElementById("reset2").addEventListener("click", () => {\n  app.reset();\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"src/App.svelte"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { getContext } from 'svelte';\n  import { fade } from 'svelte/transition';\n  export let counter;\n  export function reset() {\n    counter = 10\n  }\n\n  const theme = getContext('theme');\n<\/script>\n\n当前主题：{theme}\n\n<div transition:fade|global={{ delay: 250, duration: 1000}}>\n  <button on:click={()=> { counter += 1}}>+</button>\n  {counter}\n  <button on:click={()=> { counter -= 1}}>-</button>\n</div>\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们在 App.svelte 中新增导出了一个 reset 函数。浏览器效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"无论点击 Reset1 还是 Reset2 按钮都让数值重置，但实现的方式不同。一种是通过 $set 修改了组件的 props 传入，一种是调用组件本身的 reset 函数。"}),"\n",(0,s.jsxs)(n.p,{children:["要注意使用 $set，DOM 并不会同步更新，而是会在下一个微任务的时候执行更新。这点与 accessors 不同。当组件设置 ",(0,s.jsx)(n.code,{children:"accessors: true"}),"时，设置值将导致同步更新，而 ",(0,s.jsx)(n.code,{children:"$set"})," 是异步更新。"]}),"\n",(0,s.jsxs)(n.h3,{id:"23-on",children:["2.3. $on",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-on",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"每当组件 dispatch 一个 event 的时候，便会调用该回调函数。此函数返回一个函数，该函数调用的时候会删除事件监听器。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const off = component.$on('selected', (event) => {\n  console.log(event.detail.selection);\n});\n\noff();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"main.js"}),"，添加如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'app.$on("counterChange", (e) => {\n  console.log(e.detail);\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"src/App.svelte"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { getContext } from 'svelte';\n  import { fade } from 'svelte/transition';\n  export let counter;\n  export function reset() {\n    counter = 10\n  }\n\n  const theme = getContext('theme');\n<\/script>\n\n当前主题：{theme}\n\n<div transition:fade|global={{ delay: 250, duration: 1000}}>\n  <button on:click={()=> { counter += 1}}>+</button>\n  {counter}\n  <button on:click={()=> { counter -= 1}}>-</button>\n</div>\n"})}),"\n",(0,s.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"24-destroy",children:["2.4. $destroy()",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-destroy",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"从 DOM 中删除组件，并触发 onDestroy 监听器。"}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"main.js"}),"，添加如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'document.getElementById("destroy").addEventListener("click", () => {\n  app.$destroy();\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"3-服务端-api",children:["3. 服务端 API",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-服务端-api",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Svelte 服务端 API 的用法则比较简单："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const result = Component.render(...)\n"})}),"\n",(0,s.jsx)(n.p,{children:"这是因为服务端组件的主要工作就是渲染对应的 HTML 和 CSS。它会返回一个带有 head、html 和 css 属性的对象。"}),"\n",(0,s.jsx)(n.p,{children:"比如 Svelte 模块的代码为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<script>\n  export let counter = 10;\n<\/script>\n\n<svelte:head>\n  <title>Hello Counter!</title>\n  <meta name="description" content="This is a Counter Example" />\n</svelte:head>\n\n<div>\n  <button on:click={()=> { counter += 1}}>+</button>\n  {counter}\n  <button on:click={()=> { counter -= 1}}>-</button>\n</div>\n\n<style>\n  button {\n    color: red\n  }\n</style>\n'})}),"\n",(0,s.jsx)(n.p,{children:"它会返回这样一个对象："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"render 方法也支持参数，目前有 2 个，一个是 props 一个是 options。options 中目前只有 context。示例用法如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const { head, html, css } = App.render(\n  // props\n  { answer: 42 },\n  // options\n  {\n    context: new Map([['context-key', 'context-value']])\n  }\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"为了直观的感受服务端 API 的作用。我们再用 Vite 创建一个 SSR Svelte 项目。运行："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm create vite@latest\n"})}),"\n",(0,s.jsxs)(n.p,{children:["但是这次不直接选择 ",(0,s.jsx)(n.code,{children:"Svelte"}),"，而是选择 ",(0,s.jsx)(n.code,{children:"Others"}),"，然后再选择 ",(0,s.jsx)(n.code,{children:"create-vite-extra"}),"，最后选择 ",(0,s.jsx)(n.code,{children:"ssr-svelte"})," 创建项目。"]}),"\n",(0,s.jsx)(n.p,{children:"创建后的项目目录如下（做了部分精简）："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"vite-svelte-ssr\n├─ src\n│  ├─ lib\n│  │  └─ Counter.svelte\n│  ├─ App.svelte\n│  ├─ entry-client.js\n│  ├─ entry-server.js\n├─ index.html\n├─ server.js\n├─ svelte.config.js\n└─ vite.config.js\n"})}),"\n",(0,s.jsx)(n.p,{children:"那这个项目又是如何运行起来的呢？"}),"\n",(0,s.jsxs)(n.p,{children:["为了方便理解，首先修改 ",(0,s.jsx)(n.code,{children:"src/App.svelte"}),"的代码为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { getContext } from 'svelte';\n  export let counter;\n  const theme = getContext('theme');\n<\/script>\n\n<svelte:head>\n  <title>Hello Counter!</title>\n  <meta name=\"description\" content=\"This is a Counter Example\" />\n</svelte:head>\n\n当前主题：{theme}\n\n<div>\n  <button on:click={()=> { counter += 1}}>+</button>\n  {counter}\n  <button on:click={()=> { counter -= 1}}>-</button>\n</div>\n\n<style>\n  button {\n    color: red\n  }\n</style>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后查看 ",(0,s.jsx)(n.code,{children:"src/entry-server.js"})," 的代码并修改为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import App from "./App.svelte";\n\nexport function render() {\n  return App.render(\n    { counter: 10 },\n    {\n      context: new Map([["theme", "dark"]]),\n    }\n  );\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["再然后查看 ",(0,s.jsx)(n.code,{children:"server.js"}),"的代码，为了方便理解，代码做了精简："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'app.use("*", async (req, res) => {\n\n  let template = await fs.readFile(\'./dist/client/index.html\', \'utf-8\');\n  let render = (await import("./dist/server/entry-server.js")).render;\n\n  const rendered = await render();\n\n  const html = template\n    .replace(`\x3c!--app-head--\x3e`, rendered.head ?? "")\n    .replace(`\x3c!--app-html--\x3e`, rendered.html ?? "");\n\n  res.status(200).set({ "Content-Type": "text/html" }).send(html);\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["在这段代码中，我们导入了",(0,s.jsx)(n.code,{children:"entry-server.js"}),"导出的 render 函数，",(0,s.jsx)(n.code,{children:"await render()"}),"返回一个具有 html、head、css 属性的对象，然后通过 ",(0,s.jsx)(n.code,{children:"template.replace"})," 简单粗暴的得到最终渲染的 HTML 内容。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以打印看下 ",(0,s.jsx)(n.code,{children:"rendered"})," 变量的内容："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["再然后查看 ",(0,s.jsx)(n.code,{children:"src/entry-client.js"}),"的代码并修改为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import "./app.css";\nimport App from "./App.svelte";\n\nnew App({\n  target: document.getElementById("app"),\n  hydrate: true,\n  props: {\n    counter: 10,\n  },\n  context: new Map([["theme", "dark"]]),\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:"注意在这里我们的 hydrate 要设置为 true，这是因为之前我们已经通过服务端渲染出了最终的 DOM，无须再重新创建 DOM，直接进行水合即可。"}),"\n",(0,s.jsxs)(n.p,{children:["最后查看 ",(0,s.jsx)(n.code,{children:"vite-svelte-ssr/index.html"}),"的代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + Svelte</title>\n    \x3c!--app-head--\x3e\n  </head>\n  <body>\n    <div id="app">\x3c!--app-html--\x3e</div>\n    <script type="module" src="/src/entry-client.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这只是最一开始的 HTML 模板，server.js 会将组件进行服务端渲染，并将该 HTML 替换为最终的 HTML。然后访问该 HTML 的时候，因为引入了 ",(0,s.jsx)(n.code,{children:"entry-client.js"}),"，在 ",(0,s.jsx)(n.code,{children:"entry-client.js"}),"中，我们对 DOM 进行了水合，因此 Svelte 模块正常运行。"]}),"\n",(0,s.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"4-恭喜你",children:["4. 恭喜你！",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-恭喜你",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"看到这里，恭喜你完成了第一阶段 —— Svelte 4 的语法学习："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"第一阶段：Svelte 4 \uD83C\uDF89"}),"\n",(0,s.jsx)(n.li,{children:"第二阶段：Svelte 5"}),"\n",(0,s.jsx)(n.li,{children:"第三阶段：SvelteKit"}),"\n",(0,s.jsx)(n.li,{children:"第四阶段：项目实战"}),"\n",(0,s.jsx)(n.li,{children:"第五阶段：Svelte 原理"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Svelte 5 虽然是框架层面的完全重写，但在 API 改动上，主要是多了一个符文功能。接下来我们会进入 Svelte 5 新增内容的学习，有了 Svelte 4 的基础，相信你很快就可以掌握。"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}let v=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F43-Svelte%204%20%E2%9D%98%20%E5%AE%A2%E6%88%B7%E7%AB%AF%20API%20%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%20API.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. 客户端 API",id:"2-客户端-api",depth:2},{text:"2.1. 创建组件",id:"21-创建组件",depth:3},{text:"2.2. $set",id:"22-set",depth:3},{text:"2.3. $on",id:"23-on",depth:3},{text:"2.4. $destroy()",id:"24-destroy",depth:3},{text:"3. 服务端 API",id:"3-服务端-api",depth:2},{text:"4. 恭喜你！",id:"4-恭喜你",depth:2}],title:"43-Svelte 4 ❘ 客户端 API 与服务端 API",headingTitle:"43-Svelte 4 ❘ 客户端 API 与服务端 API",frontmatter:{}}}}]);