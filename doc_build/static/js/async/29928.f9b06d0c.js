"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["29928"],{395068:function(n,e,a){a.r(e),a.d(e,{default:()=>d});var t=a(552676),r=a(740453);let s=a.p+"static/image/866e22b0a5db54add1eac21db2cc4d78.17f9106a.png",i=a.p+"static/image/b588643e01408bd4c0d06ed8f35f5121.d8ec9071.png";function o(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li",h3:"h3",img:"img"},(0,r.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"18实战案例_自动生成-api-文档",children:["18.实战案例_自动生成 API 文档",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#18实战案例_自动生成-api-文档",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"如果我们提供了一个 sdk 给别人用，那么要把有哪些 api、都有什么参数等等信息写到文档中，并且每次改代码都要同步更新下文档。这件事情很繁琐，靠人来维护也不靠谱，可不可以自动生成呢？"}),"\n",(0,t.jsx)(e.p,{children:"api 文档的生成也是根据源码信息来的，有哪些函数、类、都有啥参数、参数是什么类型，这些都在源码里面，而更多信息一般都会写在注释里。我们可以通过 babel 取到这些信息，那么自然可以自动生成文档。"}),"\n",(0,t.jsxs)(e.h2,{id:"思路分析",children:["思路分析",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"比如这样一段代码："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"/**\n * say 你好\n * @param name 名字\n */\nfunction sayHi (name: string, age: number, a: boolean) {\n    console.log(`hi, ${name}`);\n    return `hi, ${name}`;\n}\n\n/**\n * 类测试\n */\nclass Guang {\n    name: string; // name 属性\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    /**\n     * 方法测试\n     */\n    sayHi (): string {\n        return `hi, I'm ${this.name}`;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"我们要处理 FunctionDeclaration 节点和 ClassDelcaration 节点："}),"\n",(0,t.jsx)(e.p,{children:"可以通过 AST 拿到各种信息，比如："}),"\n",(0,t.jsx)(e.p,{children:"FunctionDelcaration："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"函数名： path.get('id').toString()"}),"\n",(0,t.jsx)(e.li,{children:"参数： path.get('params')"}),"\n",(0,t.jsx)(e.li,{children:"返回值类型： path.get('returnType').getTypeAnnotation()"}),"\n",(0,t.jsx)(e.li,{children:"注释信息：path.node.leadingComments"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"注释可以使用 doctrine 来 parse，支持 @xxx 的解析"}),"\n",(0,t.jsx)(e.p,{children:"ClassDeclaration："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"类名：path.get('id').toString()"}),"\n",(0,t.jsx)(e.li,{children:"方法：travese ClassMethod 节点取信息（包括 constructor 和 method）"}),"\n",(0,t.jsx)(e.li,{children:"属性： traverse ClassProperty 节点取信息"}),"\n",(0,t.jsx)(e.li,{children:"注释信息： path.node.leadingComments"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"有了这些信息之后，就可以打印成文档了，打印就是拼接字符串的过程，可以支持 markdown、html、json 等格式。"}),"\n",(0,t.jsx)(e.p,{children:"我们来写下代码。"}),"\n",(0,t.jsxs)(e.h2,{id:"代码实现",children:["代码实现",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"首先搭一个插件的基本结构："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"const { declare } = require('@babel/helper-plugin-utils');\n\nconst autoDocumentPlugin = declare((api, options, dirname) => {\n    api.assertVersion(7);\n\n    return {\n        pre(file) {\n            file.set('docs', []);\n        },\n        visitor: {\n            FunctionDeclaration(path, state) {\n            },\n            ClassDeclaration (path, state) {\n            }\n         },\n         post(file) {\n            const docs = file.get('docs');\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"我们在全局的 file 对象中放一个 docs 的数组，用于收集信息。"}),"\n",(0,t.jsxs)(e.h3,{id:"functiondeclaration-的处理",children:["FunctionDeclaration 的处理",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#functiondeclaration-的处理",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"就像前面说的，通过 AST 可以拿到函数的各种信息："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"FunctionDeclaration(path, state) {\n    const docs = state.file.get('docs');\n    docs.push({\n        type: 'function',\n        name: path.get('id').toString(),\n        params: path.get('params').map(paramPath=> {\n            return {\n                name: paramPath.toString(),\n                type: resolveType(paramPath.getTypeAnnotation())\n            }\n        }),\n        return: resolveType(path.get('returnType').getTypeAnnotation()),\n        doc: path.node.leadingComments && parseComment(path.node.leadingComments[0].value)\n    });\n    state.file.set('docs', docs);\n},\n"})}),"\n",(0,t.jsx)(e.p,{children:"其中要注意的有两点："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"path.getTypeAnnotation() 取到的类型需要做进一步的处理，比如把 TSStringKeyword 换成 string，这样更易读"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"function resolveType(tsType) {\n    const typeAnnotation = tsType.typeAnnotation;\n    if (!typeAnnotation) {\n        return;\n    }\n    switch (typeAnnotation.type) {\n        case 'TSStringKeyword': \n            return 'string';\n        case 'TSNumberKeyword':\n            return 'number';\n        case 'TSBooleanKeyword':\n            return 'boolean';\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"注释信息用 doctrine 来 parse，可以解析注释里的 @xxx 信息"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"const doctrine = require('doctrine');\n\nfunction parseComment(commentStr) {\n    if (!commentStr) {\n        return;\n    }\n    return doctrine.parse(commentStr, {\n        unwrap: true\n    });\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"classdeclaration-的处理",children:["ClassDeclaration 的处理",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#classdeclaration-的处理",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"ClassDeclaration 的处理复杂一些，要分别提取 constructor、method、properties 的信息。"}),"\n",(0,t.jsx)(e.p,{children:"首先，收集 class 的整体信息"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"ClassDeclaration (path, state) {\n    const docs = state.file.get('docs');\n    const classInfo = {\n        type: 'class',\n        name: path.get('id').toString(),\n        constructorInfo: {},\n        methodsInfo: [],\n        propertiesInfo: []\n    };\n    if (path.node.leadingComments) {\n        classInfo.doc = parseComment(path.node.leadingComments[0].value);\n    }\n    docs.push(classInfo);\n    state.file.set('docs', docs);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"然后遍历 ClassProperty 和 ClassMethod 并提取信息"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"path.traverse({\n    ClassProperty(path) {\n        classInfo.propertiesInfo.push({\n            name: path.get('key').toString(),\n            type: resolveType(path.getTypeAnnotation()),\n            doc: [path.node.leadingComments, path.node.trailingComments].filter(Boolean).map(comment => {\n                return parseComment(comment.value);\n            }).filter(Boolean)\n        })\n    },\n    ClassMethod(path) {\n        if (path.node.kind === 'constructor') {\n            classInfo.constructorInfo = {\n                params: path.get('params').map(paramPath=> {\n                    return {\n                        name: paramPath.toString(),\n                        type: resolveType(paramPath.getTypeAnnotation()),\n                        doc: parseComment(path.node.leadingComments[0].value)\n                    }\n                })\n            }\n        } else {\n            classInfo.methodsInfo.push({\n                name: path.get('key').toString(),\n                doc: parseComment(path.node.leadingComments[0].value),\n                params: path.get('params').map(paramPath=> {\n                    return {\n                        name: paramPath.toString(),\n                        type: resolveType(paramPath.getTypeAnnotation())\n                    }\n                }),\n                return: resolveType(path.getTypeAnnotation())\n            })\n        }\n    }\n});\n"})}),"\n",(0,t.jsx)(e.p,{children:"这样处理完之后，在 post 阶段就能拿到所有的信息了，之后就是文档的生成"}),"\n",(0,t.jsxs)(e.h3,{id:"文档生成",children:["文档生成",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#文档生成",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"文档生成其实就是对象打印的过程，我们可以通过插件的参数传入 format，然后用不同的 renderer 来渲染，之后写入 docs 目录。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"post(file) {\n    const docs = file.get('docs');\n    const res = generate(docs, options.format);\n    fse.ensureDirSync(options.outputDir);\n    fse.writeFileSync(path.join(options.outputDir, 'docs' + res.ext), res.content);\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"renderer 其实就是拼接字符串，我们实现一下 markdown 的（比较简单的实现，大家如果有需求需要继续完善 renderer 和信息的提取，其实这里也可以用模版引擎来做，更易于维护）"}),"\n",(0,t.jsx)(e.p,{children:"function 和 class 分别拼接不同的字符串"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"module.exports = function(docs) {\n    let str = '';\n\n    docs.forEach(doc => {\n        if (doc.type === 'function') {\n            str += '##' + doc.name + '\\n';\n            str += doc.doc.description + '\\n';\n            if (doc.doc.tags) {\n                doc.doc.tags.forEach(tag => {\n                    str += tag.name + ': ' + tag.description + '\\n'; \n                })\n            }\n            str += '>' + doc.name + '(';\n            if (doc.params) {\n                str += doc.params.map(param => {\n                    return param.name + ': ' + param.type;\n                }).join(', ');\n            }\n            str += ')\\n';\n            str += '#### Parameters:\\n';\n            if (doc.params) {\n                str += doc.params.map(param => {\n                    return '-' + param.name + '(' + param.type + ')';\n                }).join('\\n');\n            }\n            str += '\\n'\n        } else if (doc.type === 'class'){\n            str += '##' + doc.name + '\\n';\n            str += doc.doc.description + '\\n';\n            if (doc.doc.tags) {\n                doc.doc.tags.forEach(tag => {\n                    str += tag.name + ': ' + tag.description + '\\n'; \n                })\n            }\n            str += '> new ' + doc.name + '(';\n            if (doc.params) {\n                str += doc.params.map(param => {\n                    return param.name + ': ' + param.type;\n                }).join(', ');\n            }\n            str += ')\\n';\n            str += '#### Properties:\\n';\n            if (doc.propertiesInfo) {\n                doc.propertiesInfo.forEach(param => {\n                    str += '-' + param.name + ':' + param.type + '\\n';\n                });\n            }\n            str += '#### Methods:\\n';\n            if (doc.methodsInfo) {\n                doc.methodsInfo.forEach(param => {\n                    str += '-' + param.name + '\\n';\n                });\n            }\n            str += '\\n'\n        }\n        str += '\\n'\n    })\n    return str;\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"这样我们就完成了 api 文档的自动生成。"}),"\n",(0,t.jsxs)(e.h2,{id:"测试",children:["测试",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#测试",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"处理的代码为："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"生成的文档："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(e.p,{children:"可以继续完善，比如生成这样的 html 文档："}),"\n",(0,t.jsxs)(e.h2,{id:"总结",children:["总结",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"这一节我们梳理了自动生成 api 文档的实现思路，如果对外提供 sdk 的话，那么自动文档生成是个刚需，不然每次都要人工同步改。"}),"\n",(0,t.jsx)(e.p,{children:"自动文档生成主要是信息的提取和渲染两部分，提取源码信息我们只需要分别处理 ClassDeclaration、FunctionDeclaration 或其他节点，然后从 ast 取出名字、注释等信息，之后通过 renderer 拼接成不同的字符串。"}),"\n",(0,t.jsx)(e.p,{children:"其实这种工具的应用有很多的，各种语言都有。"}),"\n",(0,t.jsxs)(e.p,{children:["（代码在",(0,t.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(o,{...n})}):o(n)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F18.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B_%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%20API%20%E6%96%87%E6%A1%A3.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"FunctionDeclaration 的处理",id:"functiondeclaration-的处理",depth:3},{text:"ClassDeclaration 的处理",id:"classdeclaration-的处理",depth:3},{text:"文档生成",id:"文档生成",depth:3},{text:"测试",id:"测试",depth:2},{text:"总结",id:"总结",depth:2}],title:"18.实战案例_自动生成 API 文档",headingTitle:"18.实战案例_自动生成 API 文档",frontmatter:{}}}}]);