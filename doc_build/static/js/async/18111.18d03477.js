"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18111"],{695819:function(n,e,s){n.exports=s.p+"static/image/9544d9903e56de89137436bce124138e.7fcf6296.webp"},907241:function(n,e,s){n.exports=s.p+"static/image/ac02760ef9298324c387ac7d1c4a57a3.31c4530d.webp"},945541:function(n,e,s){s.r(e),s.d(e,{default:()=>_});var r=s(552676),t=s(740453);let a=s.p+"static/image/98ab6cc2ad51f13f8bbd2af774623f93.8b52a8cf.webp";var d=s(907241);let c=s.p+"static/image/b90692169816bbbb452f278a97327728.5aef9b0d.webp",i=s.p+"static/image/96a47234895f902f074e8f22561ebcd5.a89f1396.webp",l=s.p+"static/image/fad30ab9d37e4b11a92cabf68b46e211.c274af54.webp",p=s.p+"static/image/db020163c589e6702058043363a59ced.1fe426be.webp",h=s.p+"static/image/e2bec5ef73d33420f9623b846dce04fb.67566254.webp",x=s.p+"static/image/ff274d1b52f350e8eb8810a4447ab862.fcdcc63e.webp",u=s.p+"static/image/bc5ea3523dcdecf7d5194b94cebd5a5f.6c7fbd67.webp",j=s.p+"static/image/e2775d6febd803eefb608d6617732ed1.9a804ed9.webp",o=s.p+"static/image/c6fe08b2858f06b6e071637ac1b20bf0.245f8289.webp",g=s.p+"static/image/4fc8bd4008750bfeff46983d069b1baf.5baa906d.webp",m=s.p+"static/image/d902c934c90726b67cb7cea30aa048d5.0b5492e3.webp",b=s.p+"static/image/7065f93cf7f78220177c2eede7c250f4.f87ae7eb.webp",f=s.p+"static/image/fde893712a41ed04ce490356a7afeacc.afe91e34.webp",S=s.p+"static/image/d0c5778f760ba4b8dabd1e029f9f4d57.fc98e5ae.webp",y=s.p+"static/image/9262d86e85bc7a5585888704aa4f216a.4fa62ced.webp",v=s.p+"static/image/4be0df7fdd232062b52a514cd805f970.4d9b9a9f.webp",q=s.p+"static/image/7402ab761aa48c1593c1a882f02b4b0a.db7e514a.webp";var w=s(695819);let T=s.p+"static/image/499f9a15f0c27f1d21edf5adfca2f00e.64142817.webp";function E(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",strong:"strong",pre:"pre",code:"code",h2:"h2"},(0,t.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"197-graphql-快速入门",children:["197. GraphQL 快速入门",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#197-graphql-快速入门",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"作为前端开发，想必经常做的事情就是：调接口、画页面、调接口、画页面..."}),"\n",(0,r.jsx)(e.p,{children:"调用的接口大概率是 restful 的，也就是类似这种："}),"\n",(0,r.jsx)(e.p,{children:"/students 查询所有学生信息"}),"\n",(0,r.jsx)(e.p,{children:"/student/1 查询 id 为 1 的学生信息"}),"\n",(0,r.jsx)(e.p,{children:"上面说的是 get 请求。"}),"\n",(0,r.jsx)(e.p,{children:"如果对 /student/1 发送 POST、PUT、DELETE 请求，就分别代表了新增、修改、删除。"}),"\n",(0,r.jsx)(e.p,{children:"这就是 restful 风格的 web 接口。"}),"\n",(0,r.jsx)(e.p,{children:"这种接口返回什么信息是服务端那边决定的，客户端只是传一下参数。"}),"\n",(0,r.jsx)(e.p,{children:"而不同场景下需要的数据不同，这时候可能就得新开发一个接口。特别是在版本更新的时候，接口会有所变动。"}),"\n",(0,r.jsx)(e.p,{children:"这样就很容易导致一大堆类似的接口。"}),"\n",(0,r.jsx)(e.p,{children:"facebook 当时也遇到了这个问题，于是他们创造了一种新的接口实现方案：GraphQL。"}),"\n",(0,r.jsx)(e.p,{children:"用了 GraphQL 之后，返回什么数据不再是服务端说了算，而是客户端自己决定。"}),"\n",(0,r.jsx)(e.p,{children:"服务端只需要提供一个接口，客户端通过这个接口就可以取任意格式的数据，实现 CRUD。"}),"\n",(0,r.jsx)(e.p,{children:"比如想查询所有的学生，就可以这样："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"想再查询他们的年龄，就可以这样："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"想查询老师的名字和他教的学生，就可以这样："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:q,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"而这些都是在一个 http 接口里完成的！"}),"\n",(0,r.jsx)(e.p,{children:"感受了 GraphQL 的好处了没？"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"一个 http 接口就能实现所有的 CRUD！"})}),"\n",(0,r.jsx)(e.p,{children:"那这么强大的 GraphQL 是怎么实现的呢？"}),"\n",(0,r.jsx)(e.p,{children:"我们先写个 demo 快速入门一下："}),"\n",(0,r.jsx)(e.p,{children:"facebook 提供了 graphql 的 npm 包，但那个封装的不够好，一般我们会用基于 graphql 包的 @apollo/server 和 @apollo/client 的包来实现 graphql。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"mkdir graphql-crud-demo\ncd graphql-crud-demo\nnpm init -y\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"安装用到的包："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"npm install @apollo/server\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后在 index.js 写一下这段代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { ApolloServer } from '@apollo/server';\n\nconst typeDefs = `\n  type Student {\n    id: String,\n    name: String,\n    sex: Boolean\n    age: Int\n  }\n\n  type Teacher {\n    id: String,\n    name: String,\n    age: Int,\n    subject: [String],\n    students: [Student]\n  }\n\n  type Query {\n    students: [Student],\n    teachers: [Teacher],\n  }\n\n  schema {\n    query: Query\n  }\n`;\n"})}),"\n",(0,r.jsx)(e.p,{children:"比较容易看懂，定义了一个 Student 的对象类型，有 id、name、sex、age 这几个字段。"}),"\n",(0,r.jsx)(e.p,{children:"又定义了一个 Teacher 的对象类型，有 id、name、age、subject、students 这几个字段。students 字段是他教的学生的信息。"}),"\n",(0,r.jsx)(e.p,{children:"然后定义了查询的入口，可以查 students 和 teachers 的信息。"}),"\n",(0,r.jsx)(e.p,{children:"这样就是一个 schema。"}),"\n",(0,r.jsx)(e.p,{children:"对象类型和对象类型之间有关联关系，老师关联了学生、学生也可以关联老师，关联来关联去这不就是一个图么，也就是 graph。"}),"\n",(0,r.jsx)(e.p,{children:"GraphQL 全称是 graph query language，就是从这个对象的 graph 中查询数据的。"}),"\n",(0,r.jsx)(e.p,{children:"现在我们声明的只是对象类型的关系，还要知道这些类型的具体数据，取数据的这部分叫做 resolver。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const students = [\n    {\n      id: '1',\n      name: async () => {\n        await '取数据';\n        return '光光'\n      },\n      sex: true,\n      age: 12\n    },\n    {\n      id: '2',\n      name:'东东',\n      sex: true,\n      age: 13\n    },\n    {\n      id: '3',\n      name:'小红',\n      sex: false,\n      age: 11\n    },\n];\n\nconst teachers = [\n  {\n    id: '1',\n    name: '神光',\n    sex: true,\n    subject: ['体育', '数学'],\n    age: 28,\n    students: students\n  }\n]\n\nconst resolvers = {\n    Query: {\n      students: () => students,\n      teachers: () => teachers\n    }\n};\n"})}),"\n",(0,r.jsx)(e.p,{children:"resolver 是取对象类型对应的数据的，每个字段都可以写一个 async 函数，里面执行 sql、访问接口等都可以，最终返回取到的数据。"}),"\n",(0,r.jsx)(e.p,{children:"当然，直接写具体的数据也是可以的。"}),"\n",(0,r.jsx)(e.p,{children:"这样有了 schema 类型定义，有了取数据的 resovler，就可以跑起 graphql 服务了。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"也就是这样："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { startStandaloneServer } from '@apollo/server/standalone' \n\nconst server = new ApolloServer({\n    typeDefs,\n    resolvers,\n});\n  \nconst { url } = await startStandaloneServer(server, {\n    listen: { port: 4000 },\n});\n  \nconsole.log(`\uD83D\uDE80  Server ready at: ${url}`);\n"})}),"\n",(0,r.jsx)(e.p,{children:"传入 schema 类型定义和取数据的 resolver，就可以用 node 把服务跑起来。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"有同学可能问了，node 可以直接解析 esm 模块么？"}),"\n",(0,r.jsx)(e.p,{children:"可以的。只需要在 package.json 中声明 type 为 module："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"那所有的 .js 就都会作为 esm 模块解析："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"跑起来之后，浏览器访问一下："}),"\n",(0,r.jsx)(e.p,{children:"就可以看到这样的 sandbox，这里可以执行 graphql 的查询："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"（graphql 接口是监听 POST 请求的，用 get 请求这个 url 才会跑这个调试的工具）"}),"\n",(0,r.jsx)(e.p,{children:"我查询所有学生的 id、name、age 就可以这样："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-graphql",children:"query Query {\n    students {\n        name,\n        id\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"这里 “光光” 那个学生是异步取的数据，resolver 会执行对应的异步函数，拿到最终数据："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"取老师的信息就可以这样："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"这样我们就实现了一个 graphql 接口！"}),"\n",(0,r.jsx)(e.p,{children:"感觉到什么叫客户端决定取什么数据了么？"}),"\n",(0,r.jsx)(e.p,{children:"当然，我们这里是在 sandbox 里测的，用 @apollo/client 包也很简单。"}),"\n",(0,r.jsx)(e.p,{children:"比如 react 的 graphql 客户端是这样的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"一个 gql 的 api 来写查询语言，一个 useQuery 的 api 来执行查询。"}),"\n",(0,r.jsx)(e.p,{children:"学起来很简单。"}),"\n",(0,r.jsx)(e.p,{children:"我们之后还是直接在 sandbox 里测试。"}),"\n",(0,r.jsx)(e.p,{children:"有的同学可能会说，如果我想查询某个名字的老师的信息呢？"}),"\n",(0,r.jsx)(e.p,{children:"怎么传参数？"}),"\n",(0,r.jsx)(e.p,{children:"graphql 当然是支持的，这样写："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"type Query {\n    students: [Student],\n    teachers: [Teacher],\n    studentsbyTeacherName(name: String!): [Student]\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"新加一个 query 入口，声明一个 name 的参数。（这里 String 后的 ! 代表不能为空）"}),"\n",(0,r.jsx)(e.p,{children:"然后它对应的 resolver 就是这样的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const resolvers = {\n    Query: {\n      students: () => students,\n      teachers: () => teachers,\n      studentsbyTeacherName: async (...args) => {\n        console.log(args);\n\n        await '执行了一个异步查询'\n        return students\n      }\n    }\n};\n"})}),"\n",(0,r.jsx)(e.p,{children:"studentsbyTeacherName 字段的 resolver 是一个异步函数，里面执行了查询，然后返回了查到的学生信息。"}),"\n",(0,r.jsx)(e.p,{children:"我们打印下参数看看传过来的是什么。"}),"\n",(0,r.jsx)(e.p,{children:"有参数的查询是这样的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"传入老师的 name 参数为 111，返回查到的学生的 id、name 信息。"}),"\n",(0,r.jsx)(e.p,{children:"可以看到返回的就是查询到的结果。"}),"\n",(0,r.jsx)(e.p,{children:"而服务端的 resolver 接收到的参数是这样的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"其余的几个参数不用管，只要知道第二个参数就是客户端传过来的查询参数就好了。"}),"\n",(0,r.jsx)(e.p,{children:"这样我们就可以根据这个 name 参数实现异步的查询，然后返回数据。"}),"\n",(0,r.jsx)(e.p,{children:"这就实现了有参数的查询。"}),"\n",(0,r.jsx)(e.p,{children:"不是说 graphql 能取代 restful 做 CRUD 么？那增删改怎么做呢？"}),"\n",(0,r.jsx)(e.p,{children:"其实看到上面的有参数的查询应该就能想到了，其实写起来差不多。"}),"\n",(0,r.jsx)(e.p,{children:"在 schema 里添加这样一段类型定义："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-grqphql",children:"type Res {\n    success: Boolean\n    id: String\n}\n\ntype Mutation {\n    addStudent(name:String! age:Int! sex:Boolean!): Res\n\n    updateStudent(id: String! name:String! age:Int! sex:Boolean!): Res\n\n    deleteStudent(id: String!): Res\n}\n\nschema {\n    mutation: Mutation\n    query: Query\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"和有参数的查询差不多，只不过这部分增删改的类型要定义在 mutation 部分。"}),"\n",(0,r.jsx)(e.p,{children:"然后 resolver 也要有对应的实现："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"async function addStudent (_, { name, age, sex }) {\n    students.push({\n        id: '一个随机 id',\n        name,\n        age,\n        sex\n    });\n    return {\n      success: true,\n      id: 'xxx'\n    }\n}\n\nasync function updateStudent (_, { id, name, age, sex }) {\n\n    return {\n      success: true,\n      id: 'xxx'\n    }\n}\n\nasync function deleteStudent (_, { id }) {\n    return {\n      success: true,\n      id: 'xxx'\n    }\n}\n  \nconst resolvers = {\n    Query: {\n      students: () => students,\n      teachers: () => teachers,\n      studentsbyTeacherName: async (...args) => {\n        console.log(args);\n\n        await '执行了一个异步查询'\n        return students\n      }\n    },\n    Mutation: {\n        addStudent: addStudent,\n        updateStudent: updateStudent,\n        deleteStudent: deleteStudent\n    }\n};\n\n"})}),"\n",(0,r.jsx)(e.p,{children:"和 query 部分差不多，只不过这里实现的是增删改。"}),"\n",(0,r.jsx)(e.p,{children:"我只对 addStudent 做了实现。"}),"\n",(0,r.jsx)(e.p,{children:"我们测试下："}),"\n",(0,r.jsx)(e.p,{children:"执行 addStudent，添加一个学生："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"然后再次查询所有的学生："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"就可以查到刚来的小刚同学。"}),"\n",(0,r.jsx)(e.p,{children:"这样，我们就可以在一个 graphql 的 POST 接口里完成所有的 CRUD！"}),"\n",(0,r.jsx)(e.p,{children:'全部代码如下，大家可以跑一跑（注意要在 package.json 里加个 type: "module"）'}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"import { ApolloServer } from '@apollo/server';\nimport { startStandaloneServer } from '@apollo/server/standalone' \n\nconst typeDefs = `\n  type Student {\n    id: String,\n    name: String,\n    sex: Boolean\n    age: Int\n  }\n\n  type Teacher {\n    id: String,\n    name: String,\n    age: Int,\n    subject: [String],\n    students: [Student]\n  }\n\n  type Query {\n    students: [Student],\n    teachers: [Teacher],\n    studentsbyTeacherName(name: String!): [Student]\n  }\n\n  type Res {\n    success: Boolean\n    id: String\n  }\n\n  type Mutation {\n    addStudent(name:String! age:Int! sex:Boolean!): Res\n\n    updateStudent(id: String! name:String! age:Int! sex:Boolean!): Res\n\n    deleteStudent(id: String!): Res\n  }\n\n  schema {\n    mutation: Mutation\n    query: Query\n  }\n`;\n\nconst students = [\n    {\n      id: '1',\n      name: async () => {\n        await '取数据';\n        return '光光'\n      },\n      sex: true,\n      age: 12\n    },\n    {\n      id: '2',\n      name:'东东',\n      sex: true,\n      age: 13\n    },\n    {\n      id: '3',\n      name:'小红',\n      sex: false,\n      age: 11\n    },\n];\n\nconst teachers = [\n  {\n    id: '1',\n    name: '神光',\n    sex: true,\n    subject: ['体育', '数学'],\n    age: 28,\n    students: students\n  }\n]\n\nasync function addStudent (_, { name, age, sex }) {\n    students.push({\n        id: '一个随机 id',\n        name,\n        age,\n        sex\n    });\n    return {\n      success: true,\n      id: 'xxx'\n    }\n}\n\nasync function updateStudent (_, { id, name, age, sex }) {\n\n    return {\n      success: true,\n      id: 'xxx'\n    }\n}\n\nasync function deleteStudent (_, { id }) {\n    return {\n      success: true,\n      id: 'xxx'\n    }\n}\n  \nconst resolvers = {\n    Query: {\n      students: () => students,\n      teachers: () => teachers,\n      studentsbyTeacherName: async (...args) => {\n        console.log(args);\n\n        await '执行了一个异步查询'\n        return students\n      }\n    },\n    Mutation: {\n        addStudent: addStudent,\n        updateStudent: updateStudent,\n        deleteStudent: deleteStudent\n    }\n};\n\nconst server = new ApolloServer({\n    typeDefs,\n    resolvers,\n});\n  \nconst { url } = await startStandaloneServer(server, {\n    listen: { port: 4000 },\n});\n  \nconsole.log(`\uD83D\uDE80  Server ready at: ${url}`);\n"})}),"\n",(0,r.jsx)(e.p,{children:"完成了 graphql 的入门，我们再稍微思考下它的原理。graphql 是怎么实现的呢？"}),"\n",(0,r.jsx)(e.p,{children:"回顾整个流程，我们发现涉及到两种 DSL（领域特定语言），一个是 schema 定义的 DSL，一个是查询的 DSL。"}),"\n",(0,r.jsx)(e.p,{children:"服务端通过 schema 定义的 DSL 来声明 graph 图，通过 resolver 来接受参数，执行查询和增删改。"}),"\n",(0,r.jsx)(e.p,{children:"客户端通过查询的 DSL 来定义如何查询和如何增删改，再发给服务端来解析执行。"}),"\n",(0,r.jsx)(e.p,{children:"通过这种 DSL 实现了动态的查询。"}),"\n",(0,r.jsx)(e.p,{children:"确实很方便很灵活，但也有缺点，就是 parse DSL 为 AST 性能肯定是不如 restful 那种直接执行增删改查高的。"}),"\n",(0,r.jsx)(e.p,{children:"具体要不要用 graphql 还是要根据具体场景来做判断。"}),"\n",(0,r.jsxs)(e.p,{children:["案例代码在",(0,r.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/graphql-crud-demo",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"restful 接口是 url 代表资源，GET、POST、PUT、DELETE 请求代表对资源的增删改查。"}),"\n",(0,r.jsx)(e.p,{children:"这种接口返回什么数据完全由服务端决定，每次接口变动可能就得新加一种接口。"}),"\n",(0,r.jsx)(e.p,{children:"为了解决这种问题，facebook 创造了 graphql，这种接口返回什么数据完全由客户端决定。增删改查通过这一个接口就可以搞定。"}),"\n",(0,r.jsx)(e.p,{children:"graphql 需要在服务端定义 schema，也就是定义对象类型和它的字段，对象类型和对象类型之间会有关联，也就是一个 graph，查询就是从这个 graph 里查询数据。"}),"\n",(0,r.jsx)(e.p,{children:"除了 schema 外，还需要有 resolver，它负责接受客户端的参数，完成具体数据的增删改查。"}),"\n",(0,r.jsx)(e.p,{children:"graphql 会暴露一个 post 接口，通过查询语言的语法就可以从通过这个接口完成所有增删改查。"}),"\n",(0,r.jsx)(e.p,{children:"本地测试的时候，get 请求会跑一个 sandbox，可以在这里测试接口。"}),"\n",(0,r.jsx)(e.p,{children:"整个流程涉及到两种新语言： schema 定义语言和 query 查询语言。入门之后向深入的话就是要学下这两种 DSL 的更多语法。"}),"\n",(0,r.jsx)(e.p,{children:"感受到 graphql 的强大之处了么？一个接口就可以实现所有的 CRUD！"})]})}function Q(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(E,{...n})}):E(n)}let _=Q;Q.__RSPRESS_PAGE_META={},Q.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F197.%20GraphQL%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"197. GraphQL 快速入门",headingTitle:"197. GraphQL 快速入门",frontmatter:{}}}}]);