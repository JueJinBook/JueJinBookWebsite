"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["37023"],{944958:function(e,n,s){s.r(n),s.d(n,{default:()=>a});var o=s(552676),c=s(740453);let r=s.p+"static/image/5062d805ab17dfc44982b43f74ae2f38.9322de07.webp",i=s.p+"static/image/b2ffc8c7ed4f5c91e534e28a6caaee6c.efea3867.webp";function t(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",img:"img",ul:"ul",li:"li",pre:"pre",strong:"strong"},(0,c.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.h1,{id:"20优化篇-公共弹窗拆解优化让职能更加单一",children:["20.优化篇-公共弹窗拆解优化，让职能更加单一",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#20优化篇-公共弹窗拆解优化让职能更加单一",children:"#"})]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"本章节主要是对公共弹窗的拆解优化，如果你对本章节内容兴趣不大，可以快速阅读或跳过。"}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"公共弹窗拆解流程梳理及职责划分",children:["公共弹窗拆解—流程梳理及职责划分",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#公共弹窗拆解流程梳理及职责划分",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["想必小伙伴们还记得我们在点击",(0,o.jsx)(n.code,{children:"导出PDF"}),"按钮时，会出现一个确认弹窗。如下图所示"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,o.jsxs)(n.p,{children:["这是一个常见的功能，我们在",(0,o.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962895451875966989",target:"_blank",rel:"noopener noreferrer",children:"第八章"}),"添加了 ",(0,o.jsx)(n.code,{children:"<MyModal.Comfirm />"})," 组件实现了上图的弹窗效果。但这仅仅只是一个最简单的场景，如果面对更为复杂多样的弹窗效果，就不适用了。让我们来预测一下，之后我们可能会出现什么弹窗场景呢？"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"场景一"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"当点击 Button 按钮，弹窗打开，弹窗的位置是水平垂直居中，存在蒙层，点击弹窗区域之外（即蒙层），弹窗关闭"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"场景二"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"当点击 Button 按钮，弹窗打开，弹窗的位置是水平垂直居中，存在蒙层"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"场景三"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"当点击 Button 按钮，弹窗打开，弹窗的位置是水平垂直居中，没有蒙层"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"场景四"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"当点击 Button 按钮，弹窗打开，弹窗的位置是垂直居中，位于顶部，没有蒙层，点击弹窗之外区域，弹窗关闭"}),"\n",(0,o.jsxs)(n.p,{children:["当然还有其他场景，以目前我们封装的 ",(0,o.jsx)(n.code,{children:"renderer/common/components/MyModal/MyConfirm"})," 组件仅能满足场景二，其他场景均不满足。所以我们需要进行优化处理，我们必须捋一捋我们的流程。"]}),"\n",(0,o.jsxs)(n.h2,{id:"流程梳理",children:["流程梳理",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#流程梳理",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"通过下面流程图，我们来捋一捋这个流程"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,o.jsx)(n.p,{children:"下面是一段伪代码："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import React, { useState, useEffect } from 'react';\n\nfunction DownloadPdf() {\n  // 控制弹窗显隐\n  const [showModal, setShowModal] = useState(false);\n\n  // 监听 click 事件，在组件卸载时移除\n  useEffect(() => {\n    window.addEventListener('click', handleClickBody, false);\n    return () => {\n      window.removeEventListener('click', handleClickBody, false);\n    };\n  }, []);\n\n  // 在点击弹窗之外区域，关闭弹窗\n  const handleClickBody = () => setShowModal(false);\n\n  // 点击按钮，显示弹窗\n  const handleClickButton = () => setShowModal(true);\n\n  return (\n    <div>\n      <button onClick={handleClickButton}>导出简历</button>\n\n      {showModal && (\n        <div\n          styleName=\"mask\"\n          onClick={(e) => {\n            // 需要阻止冒泡，不然点击弹窗区域会导致弹窗关闭\n            e.stopPropagation();\n            e.nativeEvent.stopImmediatePropagation();\n          }}\n        >\n          <DownLoadModal onCancel={() => setShowModal(false)} />\n        </div>\n      )}\n    </div>\n  );\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"整体来讲，我们弹窗的主要流程大致如上所示。"}),"\n",(0,o.jsxs)(n.h2,{id:"抽丝剥茧",children:["抽丝剥茧",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#抽丝剥茧",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["动动我们的小奶袋瓜，结合四种场景，想一下",(0,o.jsx)(n.strong,{children:"点击弹窗区域之外，关闭弹窗"}),"这个交互效果，是否能做成通用呢？换个说法，我们能否能抽象成：给你一个 ",(0,o.jsx)(n.code,{children:"elementRef"}),"，点击 ",(0,o.jsx)(n.code,{children:"elementRef"})," 区域之外，触发回调事件。"]}),"\n",(0,o.jsx)(n.p,{children:"举几个例子："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"点击弹窗区域之外，关闭弹窗（这里的 elementRef 元素就是弹窗组件，回调事件就是关闭弹窗）"}),"\n",(0,o.jsx)(n.li,{children:"点击侧边栏区域之外，给个提示框（这里的 elementRef 元素就是侧边栏组件，回调事件就是显示提示框）"}),"\n",(0,o.jsx)(n.li,{children:"点击简历头像，给个夸奖（这里的 elementRef 元素就是简历头像，回调事件就是一句夸奖提示）"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["我们肯定不想在每个实现此交互效果的组件中，内部实现一套 ",(0,o.jsx)(n.code,{children:"监听事件"}),"，所以我们能否将其抽离出来呢？思考思考如何实现？"]}),"\n",(0,o.jsxs)(n.p,{children:["还有一个问题，我们想一想，这个位置是否可选？比如我期望该显示的弹窗水平垂直居中，或者头部居中、底部居中，再或者我期望该蒙层的背景色能进行改变？我们肯定不期望每次都自己 ",(0,o.jsx)(n.code,{children:"Ctrl+C"})," 拷贝一份蒙层相关的代码吧？所以我们能否将其抽离出来呢？思考思考如何实现？"]}),"\n",(0,o.jsxs)(n.h2,{id:"useclickawayhook",children:["useClickAwayHook",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useclickawayhook",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["受 ",(0,o.jsx)(n.a,{href:"https://github.com/streamich/react-use",target:"_blank",rel:"noopener noreferrer",children:"react-use"})," 的 ",(0,o.jsx)(n.a,{href:"https://github.com/streamich/react-use/blob/master/docs/useClickAway.md",target:"_blank",rel:"noopener noreferrer",children:"useClickAway"})," 影响，自己动手实现了一个 useClickAwayHook，即 ",(0,o.jsx)(n.code,{children:"triggers a callback when user clicks outside the target element."})]}),"\n",(0,o.jsxs)(n.p,{children:["具体实现是怎样的呢？我们先前往 ",(0,o.jsx)(n.code,{children:"renderer/common"})," 目录下，新增一个名为 ",(0,o.jsx)(n.code,{children:"hook"})," 的文件夹，顾名思义，不再解释，我们新增一个名为 ",(0,o.jsx)(n.code,{children:"useClickAway.ts"})," 文件，让我们来写一下实现的代码"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// renderer/common/hook/useClickAway.ts\nimport { useEffect, useRef, useState } from 'react';\n\n/**\n * @description 点击元素之外区域关闭\n */\nfunction useClickAway(initIsVisible: boolean) {\n  const ref = useRef() as React.MutableRefObject<HTMLDivElement>;\n  const [componentVisible, setComponentVisible] = useState(initIsVisible);\n\n  const onClickOutSide = (event: any) => {\n    if (ref.current && !ref.current.contains(event.target)) {\n      setComponentVisible(false);\n    }\n  };\n\n  useEffect(() => {\n    document.addEventListener('click', onClickOutSide, true);\n    return () => {\n      document.removeEventListener('click', onClickOutSide, true);\n    };\n  });\n\n  return { ref, componentVisible, setComponentVisible };\n}\n\nexport default useClickAway;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["使用上非常简单，下面以",(0,o.jsx)(n.code,{children:"导出PDF"}),"弹窗确定为例，看看如何使用"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'// renderer/container/resume/ResumeAction/index.tsx\nimport useClickAway from \'@common/hook/useClickAway\';\n\nfunction ResumeAction() {\n  const { ref, componentVisible, setComponentVisible } = useClickAway(false);\n\n  return (\n    <div styleName="actions">\n      <div styleName="back" onClick={onBack}>\n        返回\n      </div>\n      <MyButton\n        size="middle"\n        className="export-btn"\n        onClick={() => setComponentVisible(true)}\n      >\n        导出PDF\n      </MyButton>\n      {componentVisible && (\n        <MyModal.Confirm\n          eleRef={ref}\n          title="确定要打印简历吗？"\n          description="请确保信息的正确，目前仅支持单页打印哦～"\n          config={{\n            cancelBtn: {\n              isShow: true,\n              callback: () => setComponentVisible(false),\n            },\n            submitBtn: {\n              isShow: true,\n              callback: exportPdf,\n            },\n          }}\n        />\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["\uD83D\uDC49 具体相关代码可看此 ",(0,o.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/2339afe4d32d9ce01d30d4ee395aef008e4c9b5c",target:"_blank",rel:"noopener noreferrer",children:"commit"})]}),"\n",(0,o.jsxs)(n.h2,{id:"mymaskhoc",children:["MyMaskHoc",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mymaskhoc",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["前往 ",(0,o.jsx)(n.code,{children:"renderer/common"})," 目录下，新增一个名为 ",(0,o.jsx)(n.code,{children:"hoc"})," 的文件夹，顾名思义，不再解释，我们新增一个名为 ",(0,o.jsx)(n.code,{children:"MyMaskHoc"})," 文件夹，让我们来写一下实现的代码"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"// renderer/common/hoc/MyMaskHoc/index.tsx\n/**\n * @description 为目标组件添加一层蒙层\n */\nimport React from 'react';\nimport './index.less';\nimport classnames from 'classnames';\nexport type Position = 'top' | 'bottom' | 'center';\n\nconst MyMaskHoc =\n  (WrappedComponent: React.ComponentType) =>\n  (hocProps: { position?: Position; backgroundColor?: string }) => {\n    return class extends React.Component {\n      getProps = () => ({\n        ...this.props,\n      });\n      render() {\n        const position = hocProps ? hocProps?.position : 'center';\n        const backgroundColor = hocProps\n          ? hocProps?.backgroundColor\n          : 'rgba(0, 0, 0, 0.78)';\n\n        return (\n          <div\n            styleName=\"vis-mask\"\n            style={{ backgroundColor: backgroundColor }}\n          >\n            <div\n              styleName={classnames({\n                top: position === 'top',\n                center: position === 'center',\n                bottom: position === 'bottom',\n              })}\n            >\n              <WrappedComponent {...this.getProps()} />\n            </div>\n          </div>\n        );\n      }\n    };\n  };\n\nexport default MyMaskHoc;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["\uD83D\uDC49 具体相关代码可看此 ",(0,o.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/edd835a57fee51a8f443d98fda89af4eb491d3a2",target:"_blank",rel:"noopener noreferrer",children:"commit"})]}),"\n",(0,o.jsxs)(n.p,{children:["使用就比较简单了，我们只给需要添加蒙层的组件，包裹一下 ",(0,o.jsx)(n.code,{children:"MyMaskHoc"})," 即可。这边就不一一改造了，感兴趣的小伙伴可以私下对项目中的弹窗蒙层进行改造一波，下面给出一个简单的使用例子"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// 测试例子\nimport React from 'react';\nimport MyMaskHoc from '@src/common/hoc/MyMaskHoc';\n\nfunction TestModal() {\n  return <div>我是测试带有蒙层的代码</div>;\n}\n\nexport default MyMaskHoc(TestModal)({\n  position: 'top',\n  backgroundColor: 'red',\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["小测试：上面的 ",(0,o.jsx)(n.code,{children:"TestModal"})," 实现了蒙层效果，那么我想将 ",(0,o.jsx)(n.code,{children:"useClickAway"})," 添加进来，实现交互级的效果，这代码该如何写呢？"]}),"\n",(0,o.jsxs)(n.h2,{id:"总结",children:["总结",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["上面我们对公共弹窗的交互进行了分析，从而实现了 ",(0,o.jsx)(n.code,{children:"useClickAwayHook"})," 和 ",(0,o.jsx)(n.code,{children:"MyMaskHoc"}),"，至于两者如何使用，我在这里当成是一个小测试。"]}),"\n",(0,o.jsx)(n.p,{children:"本章节的重点在于从一个常见的场景出发，去分析一整套流程下来，哪部分可以进行抽离分割，从而达到高内聚、低耦合的结果。关于此章节，如果有疑问，可以在评论区指出。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}let a=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F20.%E4%BC%98%E5%8C%96%E7%AF%87-%E5%85%AC%E5%85%B1%E5%BC%B9%E7%AA%97%E6%8B%86%E8%A7%A3%E4%BC%98%E5%8C%96%EF%BC%8C%E8%AE%A9%E8%81%8C%E8%83%BD%E6%9B%B4%E5%8A%A0%E5%8D%95%E4%B8%80.md"]={toc:[{text:"公共弹窗拆解—流程梳理及职责划分",id:"公共弹窗拆解流程梳理及职责划分",depth:2},{text:"流程梳理",id:"流程梳理",depth:2},{text:"抽丝剥茧",id:"抽丝剥茧",depth:2},{text:"useClickAwayHook",id:"useclickawayhook",depth:2},{text:"MyMaskHoc",id:"mymaskhoc",depth:2},{text:"总结",id:"总结",depth:2}],title:"20.优化篇-公共弹窗拆解优化，让职能更加单一",headingTitle:"20.优化篇-公共弹窗拆解优化，让职能更加单一",frontmatter:{}}}}]);