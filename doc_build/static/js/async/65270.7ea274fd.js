"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["65270"],{268413:function(e,n,s){s.r(n),s.d(n,{default:()=>f});var r=s(552676),c=s(740453);let d=s.p+"static/image/571185b24710c2e7b57bfc7cf382a28f.f6417c91.webp",i=s.p+"static/image/607be77e719a75a803c0f989b6bf4347.caf70a9e.webp",l=s.p+"static/image/c492827ceb4ca7f179063321ea9cdf06.665c1618.webp",h=s.p+"static/image/c37e763efc595ed87ea5ccdeca79996c.a41ca1a8.webp",a=s.p+"static/image/346bb92cad11db8d56bafe259ae196a7.a1bbab8c.webp",o=s.p+"static/image/78cb74825a33ccf340c440a98d0a12d3.f282f6fb.webp",j=s.p+"static/image/3a620e978be0664c2d3e36d0c7e13aaf.f630a00d.webp",x=s.p+"static/image/6b809dc2c2a53989da4929266a8fecc2.1f25839c.webp",p=s.p+"static/image/6bfa441bc12134fc8c7d1f4b9fef89a2.159137ed.webp",t=s.p+"static/image/0500323d013586467a8c0e2c4621531c.bbdb11be.webp",g=s.p+"static/image/57c279a0e15da2a9a8e0b223b17ec08c.81440fbb.webp",m=s.p+"static/image/fedfc34d64f6baf3b0c0396fe4ea28b0.dfcf28bf.webp";function u(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",code:"code",h4:"h4",pre:"pre",ol:"ol",li:"li",img:"img",ul:"ul",blockquote:"blockquote"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"26服务端实战服务部署",children:["26.服务端实战：服务部署",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26服务端实战服务部署",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["本章的纯服务端部署内容与《",(0,r.jsx)(n.strong,{children:"NestJS 实战"}),"》小册的应用部署有重合的地方，已经阅读过的同学，可以跳过纯服务端部署",(0,r.jsx)(n.strong,{children:"直接看混合应用部署的章节"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["对 ",(0,r.jsx)(n.strong,{children:"Docker"})," 不熟悉的同学可以参考以下两篇文章："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7147483669299462174",target:"_blank",rel:"noopener noreferrer",children:"前端全栈之路 - 玩转 Docker (基础)"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7160972042757079077",target:"_blank",rel:"noopener noreferrer",children:"前端全栈之路 - 玩转 Docker (Dockerfile)"})}),"\n",(0,r.jsxs)(n.h2,{id:"纯服务端部署",children:["纯服务端部署",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#纯服务端部署",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"NestJS"})," 两种方式的发布类型： ",(0,r.jsx)(n.code,{children:"PM2"})," 与 ",(0,r.jsx)(n.code,{children:"Docker Compose"})," 部署，纯服务段部署的列子为 ",(0,r.jsx)(n.a,{href:"https://github.com/Ignition-Space/fast-gateway",target:"_blank",rel:"noopener noreferrer",children:"fast-gateway"}),"。"]}),"\n",(0,r.jsxs)(n.h4,{id:"pm2",children:["PM2",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pm2",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://pm2.keymetrics.io/docs/usage/quick-start/",target:"_blank",rel:"noopener noreferrer",children:"PM2"})," 是一款使用于生产环境的 ",(0,r.jsx)(n.code,{children:"NodeJS"})," 的进程管理工具，操作非常简便，内置了进程管理、监控、日志以及负载均衡的能力。"]}),"\n",(0,r.jsxs)(n.p,{children:["首先需要安装 ",(0,r.jsx)(n.code,{children:"PM2"})," 的依赖，一般会安装在全局依赖："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"$ yarn global add pm2\n"})}),"\n",(0,r.jsx)(n.p,{children:"普通的前端项目启动的话，直接使用以下命令就行了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"pm2 start app.js\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但毕竟是这一个实战的项目而且也有不同的环境变量存在，直接这么启动并不合适，可以借助 ",(0,r.jsx)(n.code,{children:"Ecosystem File"})," 来完成我们的需求。"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"ecosystem.config.js"}),"："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  apps: [\n    {\n      name: "gateway",\n      script: "dist/src/main.js",\n      env_production: {\n        RUNNING_ENV: "prod"\n      },\n      env_development: {\n        RUNNING_ENV: "dev"\n      }\n    }\n  ]\n}\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["添加 ",(0,r.jsx)(n.code,{children:"package.json"})," 中的 ",(0,r.jsx)(n.code,{children:"scripts"})," 构建命令："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:'+ "build": "nest build",\n+ "build:webpack": "nest build --webpack",\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"对比一下两种构建命令的不同点："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"nest build"}),"：将 ",(0,r.jsx)(n.code,{children:"NestJS"})," 项目的源码从 ",(0,r.jsx)(n.code,{children:"TS"})," 编译成 ",(0,r.jsx)(n.code,{children:"JS"})," 之后再使用 ",(0,r.jsx)(n.code,{children:"node main.js"})," 来运行项目，这样有个好处是还能看到大概的工程路径，也可以使用 ",(0,r.jsx)(n.code,{children:"TypeOrm"})," 动态注册实体类的功能。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"nest build --webpack"})," 会将 ",(0,r.jsx)(n.code,{children:"NestJS"})," 项目打包成一个独立的 ",(0,r.jsx)(n.code,{children:"main.js"}),"，从文件类型的角度来说，做了一次混淆跟合并，原理跟之前提到过的热更新启动是一样的，按照这种模式的话来使用的话，",(0,r.jsx)(n.strong,{children:"就不能使用动态注册实体类的功能，只能手动引入实体类"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["两种构建产物的方式都可以完成要求，按照自己的喜好选择就行，但无论是 ",(0,r.jsx)(n.code,{children:"webpack"})," 打包成单文件的模式还是使用 ",(0,r.jsx)(n.code,{children:"TSC"})," 模式生成 ",(0,r.jsx)(n.code,{children:"JS"})," 项目代码，都需要在发布工程里面添加 ",(0,r.jsx)(n.code,{children:"node_modules"}),"，否则是没办法正常启动。"]}),"\n",(0,r.jsxs)(n.p,{children:["因为这两种模式并没有将依赖直接打包进产物内，虽然可以曲线修改 ",(0,r.jsx)(n.code,{children:"webpack.config"})," 可以使得在 ",(0,r.jsx)(n.code,{children:"webpack"})," 模式下，能将所有的依赖都打入单文件，但是由于环境依赖的问题，这种模式的产物大概率只能在相同的环境运行依赖，例如 ",(0,r.jsx)(n.code,{children:"windows"})," 下打包的产物是无法部署在 ",(0,r.jsx)(n.code,{children:"linux"})," 环境下。"]}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:["在 ",(0,r.jsx)(n.code,{children:"package.json"})," 的 ",(0,r.jsx)(n.code,{children:"scripts"})," 中添加启动脚本："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:'+ "start:prod": "nest build && pm2 start ecosystem.config.js --env production"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["添加完毕之后，执行 ",(0,r.jsx)(n.code,{children:"yarn start:prod"})," 出现如下界面既完成了项目生产环境的部署，如果不能正常访问接口的话，可以使用 ",(0,r.jsx)(n.code,{children:"pm2 log gateway"})," 查看启动日志，如果按照我给的方案走一般不会出现问题，有问题的话，大概率是配置文件找不到，调整配置文件即可。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"切记，如果使用 webpack 模式部署生产环境，一定要手动注册实体类！！！！不然会报错的！！！！"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["更多的 ",(0,r.jsx)(n.code,{children:"PM2"})," 的 ",(0,r.jsx)(n.code,{children:"API"})," 使用与黑科技，用兴趣的同学可以自己进行摸索，这里就不过多介绍了。"]}),"\n",(0,r.jsxs)(n.h4,{id:"docker-compose",children:["Docker Compose",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#docker-compose",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Docker Compose"})," 项目是 ",(0,r.jsx)(n.code,{children:"Docker"})," 官方的开源项目，负责实现对 ",(0,r.jsx)(n.code,{children:"Docker"})," 容器集群的快速编排日常开发工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。"]}),"\n",(0,r.jsxs)(n.p,{children:["比如我们的网关服务体系就由 ",(0,r.jsx)(n.strong,{children:"3"})," 个不同的服务组成，其中还不包括 ",(0,r.jsx)(n.code,{children:"Redis"}),"、",(0,r.jsx)(n.code,{children:"Mysql"})," 这种中间件的服务，所以每个服务都使用直接 ",(0,r.jsx)(n.code,{children:"Docker"})," 来部署的话，效率低下而且维护麻烦，而借助 ",(0,r.jsx)(n.code,{children:"Docker Compose"})," 可以将我们的服务统一一次性部署完成。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第一步"}),"：要把项目工程打包成 ",(0,r.jsx)(n.code,{children:"image"}),"，根路径创建文件 ",(0,r.jsx)(n.code,{children:"Dockerfile"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'FROM node:16-alpine3.15\n\nRUN mkdir -p /home/app/\n\nWORKDIR /home/app/\n\nCOPY package*.json ./\n\nRUN npm install\n\nCOPY . .\n\nEXPOSE 3000\n\nENTRYPOINT ["npm", "run"]\n\nCMD ["start"]\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第二步"}),"：根目录运行以下脚本来就行构建："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"$ docker build -f ./Dockerfile -t gateway:0.0.1 .\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第三步"}),"：运行以下命令既可以启动容器运行："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"docker run -d -e RUNNING_ENV=prod -p 3000:3000 gateway:0.0.1\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["使用 ",(0,r.jsx)(n.code,{children:"docker logs [容器id] "}),"既可以看到我们的项目已经正常启动了："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["以上是直接使用 ",(0,r.jsx)(n.code,{children:"Docker"})," 来部署项目，换成 ",(0,r.jsx)(n.code,{children:"Docker Compose"})," 的话，则需要额外新建文件 ",(0,r.jsx)(n.code,{children:"docker-compose.gateway-service-dev.yml"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'version: "3"\nservices:\n  gateway-service-dev:\n    container_name: gateway-service-dev\n    build:\n      context: ./\n      dockerfile: Dockerfile\n    ports:\n      - "3000:3000"\n    environment:\n      RUNNING_ENV: \'dev\'\n    networks:\n      - servicebus\nnetworks:\n  servicebus:\n    name: servicebus\n'})}),"\n",(0,r.jsx)(n.p,{children:"启动命令为："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"docker-compose -f docker-compose.gateway-service-dev.yml up -d  --build\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其中 ",(0,r.jsx)(n.code,{children:"build"})," 参数代表构建过程，所以我们在使用 docker-compose 构建的时候可以省去第二步构建镜像的步骤，配合 ",(0,r.jsx)(n.code,{children:"docker file"})," 中的前置安装依赖步骤，可以在每次更新代码后需要重新构建时，项目依赖不更新的情况下，使用缓存构建，大幅度减少构建时间。"]}),"\n",(0,r.jsxs)(n.h2,{id:"混合应用部署",children:["混合应用部署",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#混合应用部署",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["对于我们新的体系来说，是基于 ",(0,r.jsx)(n.strong,{children:"PNPM"})," 的 ",(0,r.jsx)(n.strong,{children:"monorepo"})," 的开发模式，前端的项目都是在同一个服项目开发。"]}),"\n",(0,r.jsxs)(n.p,{children:["虽然在同一个项目中开发，但你依然可以使用前后端分离的模式来发布对应的项目，前端构建完毕后推送到 ",(0,r.jsx)(n.strong,{children:"oss"})," 或者其他的静态服务器，也可以使用 ",(0,r.jsx)(n.strong,{children:"Docker Compose"})," 来同时发布前后端应用，接下来我们一起学一下同时发布前后端应用。"]}),"\n",(0,r.jsxs)(n.p,{children:["混合应用部署的列子为：",(0,r.jsx)(n.a,{href:"https://github.com/Ignition-Space/ignition",target:"_blank",rel:"noopener noreferrer",children:"ignition"})]}),"\n",(0,r.jsxs)(n.h4,{id:"准备构建脚本",children:["准备构建脚本",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#准备构建脚本",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在之前的项目架构中，我们使用了 ",(0,r.jsx)(n.strong,{children:"turbo"})," 来管理我们多个项目启动的问题，比如同时启动用户系统的前后端项目，可以使用："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-package",children:'"dev:user": "turbo run dev:user",\n'})}),"\n",(0,r.jsx)(n.p,{children:"启动完毕之后，如下所示前后端项目都正常运行起来了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["我们按照 ",(0,r.jsx)(n.strong,{children:"dev:user"})," 的模式来准备一下构建的脚本。"]}),"\n",(0,r.jsxs)(n.p,{children:["首先在 ",(0,r.jsx)(n.code,{children:"turbo.json"})," 中添加 ",(0,r.jsx)(n.code,{children:"build:user"})," 的命令。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:'{\n  "$schema": "https://turborepo.org/schema.json",\n  "pipeline": {\n    "dev": {\n      "cache": false\n    },\n    "dev:user": {\n      "cache": false\n    },\n    "dev:ig": {\n      "cache": false\n    },\n+    "build:user": {\n+       "dependsOn": ["^build"]\n+    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["然后在对应的项目中修改构建的脚本，",(0,r.jsx)(n.strong,{children:"NestJS"})," 只需要修改脚本命令即可，但 ",(0,r.jsx)(n.strong,{children:"Vite"})," 需要修改构建输出地址。"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"修改前端构建命令"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"/clients/userCenter/package.json"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:'+ "build:user": "vite build",\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["修改前端构建项目输出目录\n",(0,r.jsx)(n.code,{children:"/clients/userCenter/vite.config.ts"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"build: {\n    outDir: '../../dist-web/user',\n  },\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["小册的 用户系统是 ",(0,r.jsx)(n.strong,{children:"vite"})," 框架，如果是 ",(0,r.jsx)(n.strong,{children:"webpack"})," 的话，需要按照对应的规则修改。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"正常构建出的目录结构如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsx)(n.li,{children:"修改服务端的构建命令"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"/apps/userServer/package.json"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:'+ "build:user": "cd .. && pnpm build-server:user"\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"4",children:["\n",(0,r.jsx)(n.li,{children:"更目录新增构建命令"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:'+ "build:user": "turbo run build:user",\n+ "build-server:user": "nest build user-server",\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"5",children:["\n",(0,r.jsxs)(n.li,{children:["运行 ",(0,r.jsx)(n.code,{children:"pnpm build:user"}),"，可以获取到如下的构建产物"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"构建完毕的路径如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h4,{id:"准备-dokcer-镜像",children:["准备 dokcer 镜像",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#准备-dokcer-镜像",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["与 ",(0,r.jsx)(n.strong,{children:"build:user"})," 一样，我们需要重写创建 ",(0,r.jsx)(n.strong,{children:"deploy:user"})," 命令，为了减少容器以来，",(0,r.jsx)(n.strong,{children:"demo"})," 使用 ",(0,r.jsx)(n.strong,{children:"anywhere"})," 启动静态资源。"]}),"\n",(0,r.jsx)(n.p,{children:"启动命令需要修改成："}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"前端项目"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:'+ "deploy:user": "anywhere -p 8080 -d ../../dist-web/user -s",\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"服务端项目"}),"："]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"主工程"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:'+ "start-server:user": "node ./dist/apps/userServer/src/main.js",\n+ "deploy:user": "turbo run deploy:user",\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"子工程"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:'+ "deploy:user": "cd .. && pnpm start-server:user"\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"dockerfile"})," 脚本如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dockerfile",children:"FROM node:16-alpine3.15\n\nRUN mkdir -p /home/app/\n\nWORKDIR /home/app/\n\nRUN npm i anywhere -g\n\nRUN npm i pnpm -g\n\nCOPY package*.json ./\n\nRUN pnpm install\n\nCOPY . .\n\nRUN pnpm install\n\nRUN pnpm run build:user\n\nEXPOSE 8080\n\nEXPOSE 4000\n\nCMD pnpm run deploy:user  \n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["之所以会有 ",(0,r.jsx)(n.strong,{children:"2"})," 次 ",(0,r.jsx)(n.code,{children:"RUN pnpm install"}),"，第一次是安装全局的，可以加缓存，第二次是安装子工程的，一般也就前端会出现各种依赖需要更新的情况，服务端的更新频率一般较低。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"构建镜像"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"docker build -f ./Dockerfile -t ig:0.0.1 .\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"运行容器"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"docker run -d -p 8080:8080 -p 4000:4000 ig:0.0.1\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"正常启动之后效果如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h4,{id:"备注",children:["备注",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#备注",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["但 ",(0,r.jsx)(n.strong,{children:"Docker"})," 容器的哲学是一个 ",(0,r.jsx)(n.strong,{children:"Docker"})," 容器只运行一个进程。"]}),"\n",(0,r.jsxs)(n.p,{children:["同时 ",(0,r.jsx)(n.strong,{children:"Docker"})," 也不具备一次性运行多个进程的功能，无论是 ",(0,r.jsx)(n.strong,{children:"anywhere"})," 还是 ",(0,r.jsx)(n.strong,{children:"NestJS"})," 都属于进程，所以使用 ",(0,r.jsx)(n.code,{children:"&&"})," 符号是没办法同时启动两个进程的，这里我们使用 ",(0,r.jsx)(n.strong,{children:"turbo"})," 来帮助我们补充这个能力。"]}),"\n",(0,r.jsxs)(n.p,{children:["这种一个容器运行多个进程并不是最优解决，最好的办法还是前后端分离部署，前端资源上 ",(0,r.jsx)(n.strong,{children:"oss"})," 或者其他静态服务器，",(0,r.jsx)(n.strong,{children:"docker"})," 中只需要启动 ",(0,r.jsx)(n.strong,{children:"NestJS"})," 服务端的程序即可。"]}),"\n",(0,r.jsx)(n.p,{children:"但在一些内部服务，小项目也不失为一种方法，偶尔拿来练练。"}),"\n",(0,r.jsxs)(n.h2,{id:"写在最后",children:["写在最后",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#写在最后",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["部署篇的章节为了方便大家快速使用，目前较为简单，等待所有的项目都完成之后，会在 ",(0,r.jsx)(n.code,{children:"docker compose"})," 部分扩充内容，给大家展示容器编排的优势。"]}),"\n",(0,r.jsxs)(n.p,{children:["另外如果有机会或者想尝试 ",(0,r.jsx)(n.code,{children:"K8S"})," 部署的话，可以参考 ",(0,r.jsx)(n.code,{children:"Devops"})," 的小册，里面有 ",(0,r.jsx)(n.code,{children:"Rancher"})," 章节是关于集群部署的。"]}),"\n",(0,r.jsx)(n.p,{children:"后面也会有专门的直播&录播模块，应该都会尽快上线。"}),"\n",(0,r.jsx)(n.p,{children:"如果你有什么疑问，欢迎在评论区提出或者加群沟通。 \uD83D\uDC4F"})]})}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}let f=b;b.__RSPRESS_PAGE_META={},b.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F26.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2.md"]={toc:[{text:"纯服务端部署",id:"纯服务端部署",depth:2},{text:"PM2",id:"pm2",depth:4},{text:"Docker Compose",id:"docker-compose",depth:4},{text:"混合应用部署",id:"混合应用部署",depth:2},{text:"准备构建脚本",id:"准备构建脚本",depth:4},{text:"准备 dokcer 镜像",id:"准备-dokcer-镜像",depth:4},{text:"备注",id:"备注",depth:4},{text:"写在最后",id:"写在最后",depth:2}],title:"26.服务端实战：服务部署",headingTitle:"26.服务端实战：服务部署",frontmatter:{}}}}]);