"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["61137"],{695276:function(n,e,s){s.r(e),s.d(e,{default:()=>a});var r=s(552676),c=s(740453);function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",blockquote:"blockquote",strong:"strong",pre:"pre",code:"code",ol:"ol",li:"li",ul:"ul"},(0,c.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"第22章架构进阶灵活运用设计模式",children:["第22章—架构进阶：灵活运用设计模式",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第22章架构进阶灵活运用设计模式",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"\uFEFF上一章中，我们从宏观层面了解了六大设计原则，设计原则是总纲，设计模式就是具体的实现。"}),"\n",(0,r.jsx)(e.p,{children:"那么，本章我们就来深入了解下常见的设计模式，来看一看设计原则是怎么具像化的。"}),"\n",(0,r.jsxs)(e.h2,{id:"单例模式",children:["单例模式",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#单例模式",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"只有一个对象。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"在 LOL 中，你可以不会其他英雄，但是不能不会盖伦；在算法界，你可以不会其他算法，但是不能不会冒泡排序；在设计模式界，你可以不会其他的设计模式，但是不能不会单例模式。"}),"\n",(0,r.jsx)(e.p,{children:"这说明它重要吗？"}),"\n",(0,r.jsx)(e.p,{children:"不！这说明它段位低。"}),"\n",(0,r.jsx)(e.p,{children:"所以我们要先把它干掉来摆脱低段位，从而进入高分局。"}),"\n",(0,r.jsxs)(e.p,{children:["单例单例，单一的实例，所以单例模式的目的只有一个：",(0,r.jsx)(e.strong,{children:"只有一个对象"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"那这个简单啊，我就创建一个对象保存起来，下次来取的时候，如果对象已经创建了，直接返回这个对象就行。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"public SingleInstance {\n    // 定义一个对象\n    private static SingleInstance instance;\n    \n    // 获取对象\n    public static SingleInstance() {\n        // 如果对象为null就创建，否则直接返回 \n        if(instance == null) {\n            instance = new SingleInstance();\n        }\n        // 返回\n        return instance;\n    }\n    \n    // 构造函数私有化\n    private SingleInstance(){}\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["首先我们要把构造函数私有化，不然其他地方能随便",(0,r.jsx)(e.code,{children:"new"}),"出来了，就不是单例了。那么既然私有化了，别的地方没法",(0,r.jsx)(e.code,{children:"new"}),"出来，也就没法访问成员函数，所以只能访问静态函数，所以我们要提供一个静态函数来返回单例对象，所以，单例也要声明为静态的，因为静态函数只能使用静态变量。"]}),"\n",(0,r.jsx)(e.p,{children:"完事了吗？"}),"\n",(0,r.jsx)(e.p,{children:"当然没有。"}),"\n",(0,r.jsx)(e.p,{children:"上述代码在单线程中完全 OK。但是，免不了有多线程的情况啊，比如，两个线程 A、B 同时跑到："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"if(istance == null) {\n    instance = new SingleInstance();\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["按照我们",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196591134489968692",target:"_blank",rel:"noopener noreferrer",children:"第 14 章"}),"讲的，A 和 B 分别把",(0,r.jsx)(e.code,{children:"instance"}),"读入自己的缓存，然后判断都为 null，然后各自执行",(0,r.jsx)(e.code,{children:"instance = new SingleInstance();"}),"，此时，已经不是单例了，已经创建两个了。"]}),"\n",(0,r.jsx)(e.p,{children:"所以说，上述代码不够完美，那我们要修改一下，我们的问题不再是单例怎么写了，而是怎么避免多线程了。"}),"\n",(0,r.jsxs)(e.p,{children:["很简答，排队啊，加锁啊，加锁就是",(0,r.jsx)(e.code,{children:"synchronized"}),"呗。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"public SingleInstance {\n    // 定义一个对象\n    private static SingleInstance instance;\n    \n    // 获取对象，加锁\n    public static syncnronized SingleInstance() {\n        // 如果对象为null就创建，否则直接返回 \n        if(instance == null) {\n            instance = new SingleInstance();\n        }\n        // 返回\n        return instance;\n    }\n    \n    // 构造函数私有化\n    private SingleInstance(){}\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这下就线程安全了。"}),"\n",(0,r.jsxs)(e.p,{children:["但是，我们前面说过，",(0,r.jsx)(e.code,{children:"synchronized"}),"是悲观锁，效率偏低。其实我们仔细想想，加锁是为了避免多个线程同时创建对象，那就是说：如果不创建对象，就不需要加锁；而创建对象的前提是对象为 null 了。那不就意味着：如果对象不为 null，就不需要创建对象，也就不需要加锁吗？"]}),"\n",(0,r.jsx)(e.p,{children:"没错，那我们就来改下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"public SingleInstance {\n    // 定义一个对象\n    private static SingleInstance instance;\n    \n    // 获取对象\n    public static SingleInstance() {\n        // 如果对象为null就创建，否则直接返回 \n        if(instance == null) {\n            // 锁放这里了\n            synchronized(SingleInstance.class) {\n                instance = new SingleInstance();\n            }\n        }\n        // 返回\n        return instance;\n    }\n    \n    // 构造函数私有化\n    private SingleInstance(){}\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["现在我们的锁放在",(0,r.jsx)(e.code,{children:"if"}),"内了，也就是意味着如果",(0,r.jsx)(e.code,{children:"instance"}),"为 null 才会加锁，这样就不会出现白加锁的情况了，从而提高效率。"]}),"\n",(0,r.jsx)(e.p,{children:"唉，又出问题了。"}),"\n",(0,r.jsxs)(e.p,{children:["假如还是 A 和 B 俩线程，同时走到了",(0,r.jsx)(e.code,{children:"if(instance == null)"}),"，发现为 null，于是都进入",(0,r.jsx)(e.code,{children:"if"}),"块内，A 先执行，把对象创建出来，执行完后 B 再执行，",(0,r.jsxs)(e.strong,{children:["B 执行的时候并没有再次去判断",(0,r.jsx)(e.code,{children:"instance"}),"是否为 null"]}),"，而是直接去创建。于是，又创建了俩对象，干！"]}),"\n",(0,r.jsx)(e.p,{children:"愁死了，那何以解忧呢？"}),"\n",(0,r.jsxs)(e.p,{children:["其实我们也分析到了，",(0,r.jsxs)(e.strong,{children:["轮到 B 执行的时候，B 没有再次去判断",(0,r.jsx)(e.code,{children:"instance"}),"是否为 null"]}),"，那就再判断一次就行了。"]}),"\n",(0,r.jsx)(e.p,{children:"所以，我们的最终代码变成了："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"public SingleInstance {\n    // 定义一个对象，加volatile，保证内存可见性。\n    private static volatile SingleInstance instance;\n    \n    // 获取对象\n    public static SingleInstance() {\n        // 如果对象为null就创建，否则直接返回 \n        if(instance == null) {\n            // 锁放这里了\n            synchronized(SingleInstance.class) {\n                if(instance == null) {\n                    instance = new SingleInstance();\n                }\n            }\n        }\n        // 返回\n        return instance;\n    }\n    \n    // 构造函数私有化\n    private SingleInstance(){}\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"我们发现，我们一共做了两次判空处理，也就是做了两次检测（Double Check），并且加了一次锁（Lock），所以，我们就叫它：DCL 单例（Double Check Lock）。"}),"\n",(0,r.jsxs)(e.p,{children:["我们上面的代码中，",(0,r.jsx)(e.code,{children:"instance"}),"变量需要用",(0,r.jsx)(e.code,{children:"volatile"}),"修饰下，从而来保证内存可见性，这个属于语言层面的东西，这里不再废话。"]}),"\n",(0,r.jsxs)(e.p,{children:["当然，单例还有很多其他方法的写法，据我所知就有 7 种（别卷了！），其实，万变不离其宗，只要你满足",(0,r.jsx)(e.strong,{children:"单一的对象"}),"，就足矣。"]}),"\n",(0,r.jsx)(e.p,{children:"那么，单例有啥用呢？为啥要写单例？"}),"\n",(0,r.jsx)(e.p,{children:"比方说，我做了一个 App，我登录 App 后，我的信息全局是不是只能有一份儿？"}),"\n",(0,r.jsx)(e.p,{children:"再比如说，我做了个直播间 App，我是不是同时只能进入一个直播间？"}),"\n",(0,r.jsx)(e.p,{children:"那么我们找共性：只能有一个！"}),"\n",(0,r.jsx)(e.p,{children:"所以就叫单例。"}),"\n",(0,r.jsx)(e.p,{children:"或者你可以后发制人，你先不写单例，等到测试提 Bug 了：你这同时出俩数据，你这同时进俩直播间，等等。"}),"\n",(0,r.jsx)(e.p,{children:"此时就可以考虑单例了。"}),"\n",(0,r.jsxs)(e.h2,{id:"观察者模式",children:["观察者模式",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#观察者模式",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"给我联系方式，我完事了通知你。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"观察者模式是用得最多的了，很多响应式编程，都是用观察者模式实现的。"}),"\n",(0,r.jsx)(e.p,{children:"观察者模式的核心就是：A 发生了什么事，就告诉 B。这样 B 就能实时得知 A 的变化，就像 B 一直在观察着 A 似的，其中A就叫做被观察者，B就叫做观察者。"}),"\n",(0,r.jsx)(e.p,{children:"我们来看代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// 定义一个观察者\ninterface Observer {\n    // 定义一个通知方法 \n    void notify(String msg) {\n    \n    }\n}\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'// 定义一个被观察者\nclass BeObserver {\n    // 定义观察者集合\n    private List<Observer> observers = new ArrayList();\n    \n    // 添加观察者\n    public void addObserver(Observer observer) {\n        if(observers.contains(observer)) return;\n        observers.add(observer);\n    }\n    \n    // 移除观察者\n    public void removeObserver(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    // 自己发生变动\n    private void selfChange() {\n        // 通知观察者\n        observers.forEach {\n            it.notify("寡人改变了，通知你一下");\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"我们的代码很简单，说白了就是："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"定义观察者和被观察者；"}),"\n",(0,r.jsx)(e.li,{children:"观察者需要提供联系方式给被观察者，用于被观察者变动时通知自己；"}),"\n",(0,r.jsxs)(e.li,{children:["联系方式就是添加观察者",(0,r.jsx)(e.code,{children:"addObserver()"}),"；"]}),"\n",(0,r.jsxs)(e.li,{children:["当被观察者发生变动时，就用观察者的联系方式通知它，也就是",(0,r.jsx)(e.code,{children:"observer.noitfy()"}),"方法。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["其实说白了就是：",(0,r.jsx)(e.strong,{children:"你把你给我，我发生了改变就调你的方法"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["因为，“你把你给我”就意味着我要持有你，这明显就是耦合了，可能发生内存泄漏，所以我们要提供一个",(0,r.jsx)(e.strong,{children:"你把你移除"}),"的方法，也就是移除观察者",(0,r.jsx)(e.code,{children:"removeObserver()"}),"方法，用来在不需要的时候移除掉观察者。"]}),"\n",(0,r.jsxs)(e.p,{children:["在写观察者模式的时候，我们一定要注意",(0,r.jsx)(e.strong,{children:"最少知识原则"}),"和",(0,r.jsx)(e.strong,{children:"依赖倒置原则"}),"，我们的观察者模式尽量定义成接口，并且一定要缩小范围，这样方便拓展。比如，我只需要一个通知功能，你却为了省事把对象整个传递进去了："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'// 观察者定义成了对象，而且有很多没用的方法\nclass Teacher {\n    public void notify(String msg){\n    }\n    \n    public void teach() {\n    }\n    \n    public void write() {\n    }\n}\n\nclass Student {\n    // 添加观察者，直接传递了具体的对象：Teacher\n    public void addObserver(Teacher observer) {\n        if(observers.contains(observer)) return;\n        observers.add(observer);\n    }\n    \n    // 自己发生变动\n    private void selfChange() {\n        // 通知观察者，只需要用到notify()方法\n        observers.forEach {\n            it.notify("寡人改变了，通知你一下");\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["示例代码中，首先把观察者定义成了具体对象，而且里面有三个方法，但是我们的被观察者只需要调用",(0,r.jsx)(e.code,{children:"notify()"}),"就足够了，不需要知道其他的方法，这违背了",(0,r.jsx)(e.strong,{children:"最少知识原则"}),"；其次，被观察者的",(0,r.jsx)(e.code,{children:"addObserver()"}),"中，依赖了具体对象，而不是接口，这就意味着不好拓展，万一将来需要让校长、班长也可以观察呢？这违背了",(0,r.jsx)(e.strong,{children:"依赖倒置原则"}),"，所以我们需要改一下代码，改成如下的即可："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'// 定义观察者\ninterface Observer {\n    public void notify(String msg){\n    }\n}\n\n// 老师实现观察者接口就行了\nclass Teacher implements Observer{\n    public void notify(String msg){\n    }\n    \n    public void teach() {\n    }\n    \n    public void write() {\n    }\n}\n\nclass Student {\n    // 添加观察者，传递接口\n    public void addObserver(Observer observer) {\n        if(observers.contains(observer)) return;\n        observers.add(observer);\n    }\n    \n    // 自己发生变动\n    private void selfChange() {\n        // 通知观察者，只需要用到notify()方法\n        observers.forEach {\n            it.notify("寡人改变了，通知你一下");\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["仅仅需要抽离出一个接口，把需要用到什么函数定义到接口里面即可，将来校长、班长也想观察，直接实现接口即可，是不是更 ",(0,r.jsx)(e.strong,{children:"OCP"})," 了？"]}),"\n",(0,r.jsx)(e.p,{children:"你看，这一点改动，差距立刻出来了。"}),"\n",(0,r.jsx)(e.p,{children:"那观察者模式有啥用呢？"}),"\n",(0,r.jsx)(e.p,{children:"比如说：A 页面需要知道 B 页面上的一个按钮是否被点击，点击了之后自己就要刷新；再比如：A 页面上弹出了编辑框，编辑的时候 A 页面要跟着编辑的内容更新。"}),"\n",(0,r.jsx)(e.p,{children:"有人就说了：那这不就等于被观察者需要持有观察者吗？听着怎么有点别扭啊。"}),"\n",(0,r.jsx)(e.p,{children:"非也非也，不是被观察者持有观察者，而是被观察者持有观察者的函数，以此来通知观察者。"}),"\n",(0,r.jsxs)(e.p,{children:["所以，观察者模式也叫做",(0,r.jsx)(e.strong,{children:"订阅-发布模式"}),"，观察者就是订阅者，被观察者就是发布者，发布者一旦发生变动，就通知订阅者，所以需要订阅者的联系方式，也就等价于持有订阅者的函数，所以就是：被观察者持有观察者的函数。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"凡是需要实时了解其他地方的变动的，都可以用观察者模式"}),"。"]}),"\n",(0,r.jsxs)(e.h2,{id:"责任链模式",children:["责任链模式",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#责任链模式",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"沿着链路不断传递，直到有一个节点处理为止。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"这个很好理解：老板派发了一个任务，先发给部门主管，部门主管觉得自己不想处理，就向下派发给小组长，小组长想处理就处理了，不想处理就派发给员工处理，最后把事情处理掉。"}),"\n",(0,r.jsxs)(e.p,{children:["核心就是一个：",(0,r.jsx)(e.strong,{children:"在一个链上把问题解决掉"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"定义抽象事件处理者："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"interface EventHandler {\n    // 处理事件，返回值表示是否处理成功\n    boolean handleEvent();\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"定义具体的事件处理者："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// 老板\nclass Boss implements EventHandler {\n}\n\n// 主管\nclass Manager implements EventHandler {\n}\n\n// 小组长\nclass Leader implements EventHandler {\n}\n\n// 员工\nclass Staff implements EventHandler {\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"使用："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// 定义责任链\nList<EventHandler> handlers = new ArrayList();\n\n// 添加事件处理者\nhandlers.add(new Boss());\nhandlers.add(new Manager());\nhandlers.add(new Leader());\nhandlers.add(new Staff());\n\n// 处理事件\nfor(EventHandler handler : handlers) {\n    if(handler.handleEvent()) return;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["可以看到，我们遍历",(0,r.jsx)(e.code,{children:"handlers"}),"来处理事件，如果前面的人已经把事情处理了，就会直接返回，那么后面的就不用处理了；如果前面的没处理，那么就沿着这个链继续向下分发，最终把事情处理掉。"]}),"\n",(0,r.jsx)(e.p,{children:"有人说，如果都不处理呢？"}),"\n",(0,r.jsx)(e.p,{children:"都不处理就出 Bug 了。所以，最后一个处理者一定是兜底的，一定要保证能把问题解决掉，所以，我们的事件处理者是有优先级的，效率高的排在前面，效率低的排在后面，但是最后面的一定是能把问题解决的。"}),"\n",(0,r.jsx)(e.p,{children:"道理我都懂了，这有啥用呢？"}),"\n",(0,r.jsxs)(e.p,{children:["记忆这么差啊，我们",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196591549017243700",target:"_blank",rel:"noopener noreferrer",children:"第 18 章"}),"刚讲过的缓存，不就是责任链模式吗？当初我们是这么写的："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"// 从内存中获取数据\nif(data != null) return data;\n// 如果数据为空，就从本地缓存中获取数据\ndata = getLocalData();\nif(data != null) return data;\n// 如果数据为空，就从网络获取数据 \nString newData = requestData();\n"})}),"\n",(0,r.jsx)(e.p,{children:"也就是说，我们获取数据的顺序是：内存 -> 本地 -> 网络。"}),"\n",(0,r.jsx)(e.p,{children:"这不就是责任链吗？"}),"\n",(0,r.jsx)(e.p,{children:"我们就来改一下这个代码，让它更有段位："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// 定义一个缓存处理器\ninterface ICache {\n    String getData();    \n    \n    void cacheData(String data);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后来实现不同的缓存："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"// 内存缓存\nclass MemoryCache implements ICache {\n    // 保存的数据\n    private String data;\n    \n    public String getData() {\n        return data;\n    }\n    \n    public void cacheData(String data) {\n        this.data = data;\n    }\n}\n\n// 本地缓存\nclass LocalCache implements ICache {\n    // 这里就是读取本地文件，细节忽略\n    public String getData() {\n        return getLocalData();\n    }\n    \n    // 保存到本地文件\n    public void cacheData(String data) {\n        this.data = data;\n    }\n}\n\n// 网络缓存\nclass NetCache implements ICache {\n    // 这里可以用异步函数或者挂起操作\n    public String getData() {\n        return getNetWorkData();\n    }\n    \n    public void cacheData(String data) {\n        // 空实现即可\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后就可以使用："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"List<ICache> caches = new ArrayList();\n\ncaches.add(new MemoryCache());\ncaches.add(new LocalCache());\ncaches.add(new NetCache());\n\n// 获取数据\nString getData() {\n    String data;\n    for(ICache cache in caches) {\n        data = cache.getData();\n        if(!data == null) return data;\n    }\n}\n\n// 保存数据\nvoid saveData(String data) {\n    for(ICache cache in caches) {\n       cache.cacheData(data);\n    }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["是不是很方便了？我们按照“",(0,r.jsx)(e.strong,{children:"内存缓存>本地缓存>网络缓存"}),"”这个优先级组成一个责任链，获取数据的时候，按照优先级来获取，如果前面的返回了数据，后面的就不需要执行了，并且保存数据也很简单，而且代码容易拓展了，如果将来有一天，我们有个新的缓存，就可以直接加在适当的位置，而不用改其他任何地方的代码。"]}),"\n",(0,r.jsxs)(e.p,{children:["有人说，你这个网络缓存不需要保存数据啊，那就不应该实现",(0,r.jsx)(e.code,{children:"ICache"}),"接口，或者应该将",(0,r.jsx)(e.code,{children:"ICache"}),"接口拆分成两个，一个获取数据，一个保存数据，这样才满足",(0,r.jsx)(e.strong,{children:"接口隔离原则"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"完全正确！给你点赞。"}),"\n",(0,r.jsx)(e.p,{children:"只不过我偷懒了而已，这个任务就交给你去实现了。"}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本章就到此结束了，我们本章重点讲了 3 个设计模式。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"单例模式"}),"：保证只有一个对象，要注意多线程环境下的单例问题。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"观察者模式"}),"：被观察者的变动可以实时通知给观察者，要注意观察者要满足最少知识原则。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"责任链模式"}),"：将事件沿着责任链分发，直到事件被处理为止。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["其实，设计模式有很多，10 篇文章都讲不完。但是我们可以看到，",(0,r.jsx)(e.strong,{children:"设计模式都是由设计原则衍生出来的"}),'，也就是说，本来是没有设计模式的，写得多了，就觉得这样的场景太多，于是就把这个场景抽离出来，就成了设计模式，于是就有各种不同的设计模式，最后又发现，这些设计模式都要满足几条规则，也就是设计原则。我们要学，肯定是要学“根”，而不是学“枝叶”，有没有比设计原则更"根"的知识呢？']}),"\n",(0,r.jsxs)(e.p,{children:["有，",(0,r.jsx)(e.code,{children:"设计思想"}),"，那么，下一章，我们就脱离设计模式，上升到设计思想的角度来看问题。"]})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(i,{...n})}):i(n)}let a=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC22%E7%AB%A0%E2%80%94%E6%9E%B6%E6%9E%84%E8%BF%9B%E9%98%B6%EF%BC%9A%E7%81%B5%E6%B4%BB%E8%BF%90%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md"]={toc:[{text:"单例模式",id:"单例模式",depth:2},{text:"观察者模式",id:"观察者模式",depth:2},{text:"责任链模式",id:"责任链模式",depth:2},{text:"总结",id:"总结",depth:2}],title:"第22章—架构进阶：灵活运用设计模式",headingTitle:"第22章—架构进阶：灵活运用设计模式",frontmatter:{}}}}]);