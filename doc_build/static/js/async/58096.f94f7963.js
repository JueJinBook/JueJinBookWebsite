"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58096"],{944270:function(n,e,r){n.exports=r.p+"static/image/4edc12136e79f5e085e679df716da89e.ebc62ea9.webp"},406117:function(n,e,r){r.r(e),r.d(e,{default:()=>m});var s=r(552676),i=r(740453);let c=r.p+"static/image/5d681f5f3ae2d36c04d28db396578f58.93321fb3.webp",a=r.p+"static/image/8a5a98a6400e28bab758b131d1517f40.434ff859.webp",t=r.p+"static/image/64bb57bf34d8938e9f346f8e9d0827b1.3e9973bf.webp",d=r.p+"static/image/5b7b6e10ddddcbcff9023e0635e29fb4.1e2932e7.webp",p=r.p+"static/image/284953ed888939140b7da4aedabbe824.2b06783c.webp",h=r.p+"static/image/3de3cf624128c219cc7027d4e97fc115.af8c56c6.webp";var l=r(944270);let x=r.p+"static/image/654396bdbb20028d406a97e476944ec5.ee0941b0.webp",o=r.p+"static/image/798ce2fc8805301f0eee228456fbdeef.c5e026e4.webp",j=r.p+"static/image/055aaccc1b98b7c766da0451fbf2638e.0af770a1.webp",g=r.p+"static/image/998b45e9d92fbb454b6586cad7f2f690.e669525f.webp",A=r.p+"static/image/bbbcd4d50d862de4deac808695c82100.e66e544c.webp",b=r.p+"static/image/fd17186a0ddb72d4fc8d3cba99f45b31.ab53b0dd.webp";function f(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",pre:"pre",code:"code",img:"img"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"17原理篇逆变协变双向协变不变",children:["17.原理篇：逆变、协变、双向协变、不变",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17原理篇逆变协变双向协变不变",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"深入学习 TypeScript 类型系统的话，逆变、协变、双向协变、不变是绕不过去的概念。"}),"\n",(0,s.jsx)(e.p,{children:"这些概念看起来挺高大上的，其实并不复杂，这节我们就来学习下它们吧。"}),"\n",(0,s.jsxs)(e.h2,{id:"类型安全和型变",children:["类型安全和型变",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#类型安全和型变",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"TypeScript 给 JavaScript 添加了一套静态类型系统，是为了保证类型安全的，也就是保证变量只能赋同类型的值，对象只能访问它有的属性、方法。"}),"\n",(0,s.jsx)(e.p,{children:"比如 number 类型的值不能赋值给 boolean 类型的变量，Date 类型的对象就不能调用 exec 方法。"}),"\n",(0,s.jsx)(e.p,{children:"这是类型检查做的事情，遇到类型安全问题会在编译时报错。"}),"\n",(0,s.jsx)(e.p,{children:"但是这种类型安全的限制也不能太死板，有的时候需要一些变通，比如子类型是可以赋值给父类型的变量的，可以完全当成父类型来使用，也就是“型变（variant）”（类型改变）。"}),"\n",(0,s.jsx)(e.p,{children:"这种“型变”分为两种，一种是子类型可以赋值给父类型，叫做协变（covariant），一种是父类型可以赋值给子类型，叫做逆变（contravariant）。"}),"\n",(0,s.jsx)(e.p,{children:"先来看下协变："}),"\n",(0,s.jsxs)(e.h3,{id:"协变covariant",children:["协变（covariant）",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#协变covariant",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"其中协变是很好理解的，比如我们有两个 interface："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface Person {\n    name: string;\n    age: number;\n} \n\ninterface Guang {\n    name: string;\n    age: number;\n    hobbies: string[]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这里 Guang 是 Person 的子类型，更具体，那么 Guang 类型的变量就可以赋值给 Person 类型："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这并不会报错，虽然这俩类型不一样，但是依然是类型安全的。"}),"\n",(0,s.jsx)(e.p,{children:"这种子类型可以赋值给父类型的情况就叫做协变。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.typescriptlang.org/play?strictFunctionTypes=false&ts=4.5.0-beta#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyxyIcAthAFzIZhSgDmA3ESXI9aQK7kBG0VgF9kBAqEixEKAOLc4IRvjbEylGnQaLWJZBy4heAqDpIALLHz7AIGDfSYBtALoEhYgDYQwyAA6YcGnQobFwAXmVdNS4AchiAGhU9ThoAJgAGN1YvH0Z5RRo5BSUIwiiKWLzihKT9NPTE3QsrGztkRxjfDzgAT2RGCoTkGIB3BjAmGNchVgJ-EJxkCKrtAiA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(e.p,{children:"为什么要支持协变很容易理解：类型系统支持了父子类型，那如果子类型还不能赋值给父类型，还叫父子类型么？"}),"\n",(0,s.jsx)(e.p,{children:"所以型变是实现类型父子关系必须的，它在保证类型安全的基础上，增加了类型系统的灵活性。"}),"\n",(0,s.jsx)(e.p,{children:"逆变相对难理解一些："}),"\n",(0,s.jsxs)(e.h3,{id:"逆变contravariant",children:["逆变（contravariant）",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#逆变contravariant",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"我们有这样两个函数："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"let printHobbies: (guang: Guang) => void;\n\nprintHobbies = (guang) => {\n    console.log(guang.hobbies);\n}\n\nlet printName: (person: Person) => void;\n\nprintName = (person) => {\n    console.log(person.name);\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"printHobbies 的参数 Guang 是 printName 参数 Person 的子类型。"}),"\n",(0,s.jsx)(e.p,{children:"那么问题来了，printName 能赋值给 printHobbies 么？printHobbies 能赋值给 printName 么？"}),"\n",(0,s.jsx)(e.p,{children:"测试一下发现是这样的："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"printName 的参数 Person 不是 printHobbies 的参数 Guang 的父类型么，为啥能赋值给子类型？"}),"\n",(0,s.jsx)(e.p,{children:"因为这个函数调用的时候是按照 Guang 来约束的类型，但实际上函数只用到了父类型 Person 的属性和方法，当然不会有问题，依然是类型安全的。"}),"\n",(0,s.jsx)(e.p,{children:"这就是逆变，函数的参数有逆变的性质（而返回值是协变的，也就是子类型可以赋值给父类型）。"}),"\n",(0,s.jsx)(e.p,{children:"那反过来呢，如果 printHoobies 赋值给 printName 会发生什么？"}),"\n",(0,s.jsx)(e.p,{children:"因为函数声明的时候是按照 Person 来约束类型，但是调用的时候是按照 Guang 的类型来访问的属性和方法，那自然类型不安全了，所以就会报错。"}),"\n",(0,s.jsx)(e.p,{children:"但是在 ts2.x 之前支持这种赋值，也就是父类型可以赋值给子类型，子类型可以赋值给父类型，既逆变又协变，叫做“双向协变”。"}),"\n",(0,s.jsx)(e.p,{children:"但是这明显是有问题的，不能保证类型安全，所以之后 ts 加了一个编译选项 strictFunctionTypes，设置为 true 就只支持函数参数的逆变，设置为 false 则是双向协变。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"我们把 strictFunctionTypes 关掉之后，就会发现两种赋值都可以了："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这样就支持函数参数的双向协变，类型检查不会报错，但不能严格保证类型安全。"}),"\n",(0,s.jsx)(e.p,{children:"开启之后，函数参数就只支持逆变，子类型赋值给父类型就会报错："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.typescriptlang.org/play?strictFunctionTypes=false&ts=4.5.0-beta#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyxyIcAthAFzIZhSgDmA3ESXI9aQK7kBG0VgF9kBAqEixEKAOLc4IRvjbEylGnQaLWJZBy4heAqDpIALLHz7AIGDfSYBtALoEhYgDYQwyAA5awAAlLa1saAApGeUUaOQVGAEpkAF4APmQANyxgABNWAn8JYKsbDBTkSOjElPTCXQQcbC8AOg8sRkr45osS2wThT28-AIA5Ci5w30wcGnQobBAktMzsvLFC8DHKcsnpxZrlesasFraOqfmcZrUIfrd1gOLQsuThiS2IfI2wD-Lvp9K+SAA",target:"_blank",rel:"noopener noreferrer",children:"试一下（双向协变的情况）"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.typescriptlang.org/play?ts=4.5.0-beta#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyxyIcAthAFzIZhSgDmA3ESXI9aQK7kBG0VgF9kBAqEixEKAOLc4IRvjbEylGnQaLWJZBy4heAqDpIALLHz7AIGDfSYBtALoEhYgDYQwyAA5awAAlLa1saAApGeUUaOQVGAEpkAF4APmQANyxgABNWAn8JYKsbDBTkSOjElPTCXQQcbC8AOg8sRkr45osS2wThT28-AIA5Ci5w30wcGnQobBAktMzsvLFC8DHKcsnpxZrlesasFraOqfmcZrUIfrd1gOLQsuThiS2IfI2wD-Lvp9K+SAA",target:"_blank",rel:"noopener noreferrer",children:"试一下（逆变的情况）"})}),"\n",(0,s.jsx)(e.p,{children:"再举个逆变的例子，大家觉得下面这样的 ts 代码会报错么："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"type Func = (a: string) => void;\n\nconst func: Func = (a: 'hello') => undefined\n"})}),"\n",(0,s.jsx)(e.p,{children:"答案是参数的位置会，返回值的位置不会："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"参数的位置是逆变的，也就是被赋值的函数参数要是赋值的函数参数的子类型，而 string 不是 'hello' 的子类型，所以报错了。"}),"\n",(0,s.jsx)(e.p,{children:"返回值的位置是协变的，也就是赋值的函数的返回值是被赋值的函数的返回值的子类型，这里 undefined 是 void 的子类型，所以不报错。"}),"\n",(0,s.jsx)(e.p,{children:"在类型编程中这种逆变性质有什么用呢？"}),"\n",(0,s.jsx)(e.p,{children:"还记得之前联合转交叉的实现么？"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"type UnionToIntersection<U> = \n    (U extends U ? (x: U) => unknown : never) extends (x: infer R) => unknown\n        ? R\n        : never\n"})}),"\n",(0,s.jsx)(e.p,{children:"类型参数 U 是要转换的联合类型。"}),"\n",(0,s.jsx)(e.p,{children:"U extends U 是为了触发联合类型的 distributive 的性质，让每个类型单独传入做计算，最后合并。"}),"\n",(0,s.jsx)(e.p,{children:"利用 U 做为参数构造个函数，通过模式匹配取参数的类型。"}),"\n",(0,s.jsx)(e.p,{children:"结果就是交叉类型："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"我们通过构造了多个函数类型，然后模式提取参数类型的方式，来实现了联合转交叉，这里就是因为函数参数是逆变的，会返回联合类型的几个类型的子类型，也就是更具体的交叉类型。"}),"\n",(0,s.jsx)(e.p,{children:"再就是之前提取返回值类型的时候，当时说参数这里只能用 any[] 而不能用 unknown[]"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"type GetReturnType<Func extends Function> = \n    Func extends (...args: any[]) => infer ReturnType \n        ? ReturnType : never;\n"})}),"\n",(0,s.jsx)(e.p,{children:"这就是因为函数参数是逆变的，如果是 unknown[]，那当 Func 是这个函数的子类型，它的参数得是 unknown 的父类型，这显然是不可能的，所以这里只能用 any。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBA4hwCV4FcBOA7AKuCAeAYsugMZQQAewE6AJgM5SEnACWA9ugHxQC8jRpClVoMAFADpJAQ1QBzOgC4oRANbo2Ad3QBtALoBKXtxboAZhFRQkwNFhxQA-FZQZskKEvQQAbhYDcAFABoO7Wtm4QSHTIADYxwLyw8GGuOLii6FIAthBKdMCoJrKGPNwA5DQcsmWcgUA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(e.p,{children:"当然，如果不开启 strictFunctionTypes 的话，参数是双向协变，那也可以正常推导。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.typescriptlang.org/play?strictFunctionTypes=false#code/C4TwDgpgBA4hwCV4FcBOA7AKuCAeAYsugMZQQAewE6AJgM5SEnACWA9ugHxQC8jRpClVoMAFADpJAQ1QBzOgC4oRANbo2Ad3QBtALoBKXtxboAZhFRQkwNFhxQA-FZQZskKEvQQAbhYDcAFBBoO7Wtm4QSHTIADYxwLyw8GGuOLii6FIAthBKdMCoJrKGPNwA5DQcsmWcgUA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(e.p,{children:"逆变和协变都是型变，是针对父子类型而言的，非父子类型自然就不会型变，也就是不变："}),"\n",(0,s.jsxs)(e.h3,{id:"不变invariant",children:["不变（invariant）",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#不变invariant",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"非父子类型之间不会发生型变，只要类型不一样就会报错："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"那类型之间的父子关系是怎么确定的呢，好像也没有看到 extends 的继承？"}),"\n",(0,s.jsxs)(e.h2,{id:"类型父子关系的判断",children:["类型父子关系的判断",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#类型父子关系的判断",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"像 java 里面的类型都是通过 extends 继承的，如果 A extends B，那 A 就是 B 的子类型。这种叫做名义类型系统（nominal type）。"}),"\n",(0,s.jsx)(e.p,{children:"而 ts 里不看这个，只要结构上是一致的，那么就可以确定父子关系，这种叫做结构类型系统（structual type）。"}),"\n",(0,s.jsx)(e.p,{children:"还是拿上面那个例子来说："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"Guang 和 Person 有 extends 的关系么？"}),"\n",(0,s.jsx)(e.p,{children:"没有呀。"}),"\n",(0,s.jsx)(e.p,{children:"那是怎么确定父子关系的？"}),"\n",(0,s.jsx)(e.p,{children:"通过结构，更具体的那个是子类型。这里的 Guang 有 Person 的所有属性，并且还多了一些属性，所以 Guang 是 Person 的子类型。"}),"\n",(0,s.jsx)(e.p,{children:"注意，这里用的是更具体，而不是更多。"}),"\n",(0,s.jsx)(e.p,{children:"判断联合类型父子关系的时候， 'a' | 'b' 和 'a' | 'b' | 'c' 哪个更具体？"}),"\n",(0,s.jsx)(e.p,{children:"'a' | 'b' 更具体，所以  'a' | 'b' 是 'a' | 'b' | 'c' 的子类型。"}),"\n",(0,s.jsx)(e.p,{children:"测试下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"ts 通过给 js 添加了静态类型系统来保证了类型安全，大多数情况下不同类型之间是不能赋值的，但是为了增加类型系统灵活性，设计了父子类型的概念。父子类型之间自然应该能赋值，也就是会发生型变（variant）。"}),"\n",(0,s.jsx)(e.p,{children:"型变分为逆变（contravariant）和协变（covariant）。协变很容易理解，就是子类型赋值给父类型。逆变主要是函数赋值的时候函数参数的性质，参数的父类型可以赋值给子类型，这是因为按照子类型来声明的参数，访问父类型的属性和方法自然没问题，依然是类型安全的。但反过来就不一定了。"}),"\n",(0,s.jsx)(e.p,{children:"不过 ts 2.x 之前反过来依然是可以赋值的，也就是既逆变又协变，叫做双向协变。"}),"\n",(0,s.jsx)(e.p,{children:"为了更严格的保证类型安全，ts 添加了 strictFunctionTypes 的编译选项，开启以后函数参数就只支持逆变，否则支持双向协变。"}),"\n",(0,s.jsx)(e.p,{children:"型变都是针对父子类型来说的，非父子类型自然就不会型变也就是不变（invariant）。"}),"\n",(0,s.jsx)(e.p,{children:"ts 中父子类型的判定是按照结构来看的，更具体的那个是子类型。"}),"\n",(0,s.jsx)(e.p,{children:"理解了如何判断父子类型（结构类型系统），父子类型的型变（逆变、协变、双向协变），很多类型兼容问题就能得到解释了。"})]})}function u(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(f,{...n})}):f(n)}let m=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F17.%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%9A%E9%80%86%E5%8F%98%E3%80%81%E5%8D%8F%E5%8F%98%E3%80%81%E5%8F%8C%E5%90%91%E5%8D%8F%E5%8F%98%E3%80%81%E4%B8%8D%E5%8F%98.md"]={toc:[{text:"类型安全和型变",id:"类型安全和型变",depth:2},{text:"协变（covariant）",id:"协变covariant",depth:3},{text:"逆变（contravariant）",id:"逆变contravariant",depth:3},{text:"不变（invariant）",id:"不变invariant",depth:3},{text:"类型父子关系的判断",id:"类型父子关系的判断",depth:2},{text:"总结",id:"总结",depth:2}],title:"17.原理篇：逆变、协变、双向协变、不变",headingTitle:"17.原理篇：逆变、协变、双向协变、不变",frontmatter:{}}}}]);