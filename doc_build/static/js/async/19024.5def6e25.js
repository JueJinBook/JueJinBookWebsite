"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19024"],{447700:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var a=r(552676),i=r(740453);let s=r.p+"static/image/43644b92108e7e9cce8baf951591b212.30778780.webp",t=r.p+"static/image/de737d1c68f1091632c3ad90da8be91a.0168154c.webp",o=r.p+"static/image/2980219bd47bd159977ecc85291d9afa.cb63754e.webp",p=r.p+"static/image/3b12749aa960301128523377e35a25c8.b931304f.webp",l=r.p+"static/image/a33f65d0d79a7f0e76d376aca43aa4fd.f00beac1.webp",c=r.p+"static/image/4877baeb6f1775a27e852b6f6aca9bf5.037d6b4d.webp",d=r.p+"static/image/73bb4c6b36e2f35cd6d2e52ac7860450.dd82763b.webp",g=r.p+"static/image/04237d7f531f9ddc1212a79f23962699.b03609cb.webp",u=r.p+"static/image/9fd1794e0691af8aca3b58b8fef026f9.38e55edc.webp",m=r.p+"static/image/5feb9e008cad543e3a432a5b74dda38b.f36a0571.webp",h=r.p+"static/image/f310bacda4b7dd5a2c444b0fa5bddf05.3f5e791f.webp",y=r.p+"static/image/e64bf18c26e322e372c2268b88d6eb7b.7304f458.webp";function b(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",ul:"ul",li:"li",pre:"pre",code:"code",strong:"strong",h4:"h4",blockquote:"blockquote"},(0,i.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"18spring-boot-实践之整合-mybatis-操作数据库",children:["18.Spring Boot 实践之整合 MyBatis 操作数据库",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18spring-boot-实践之整合-mybatis-操作数据库",children:"#"})]}),"\n",(0,a.jsxs)(n.h2,{id:"mybatis--简介",children:["MyBatis  简介",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mybatis--简介",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"MyBatis 的前身是 Apache 社区的一个开源项目 iBatis，于 2010 年更名为 MyBatis。"}),"\n",(0,a.jsx)(n.p,{children:"MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集，使得开发人员更加关注 SQL 本身和业务逻辑，不用再去花费时间关注整个复杂的 JDBC 操作过程。"}),"\n",(0,a.jsx)(n.p,{children:"以下为 MyBatis 的结构图："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:y,alt:"MyBatis"})}),"\n",(0,a.jsx)(n.p,{children:"MyBatis 的优点如下："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"封装了 JDBC 大部分操作，减少开发人员工作量；"}),"\n",(0,a.jsx)(n.li,{children:"相比一些自动化的 ORM 框架，“半自动化”使得开发人员可以自由的编写 SQL 语句，灵活度更高；"}),"\n",(0,a.jsx)(n.li,{children:"Java 代码与 SQL 语句分离，降低维护难度；"}),"\n",(0,a.jsx)(n.li,{children:"自动映射结果集，减少重复的编码工作；"}),"\n",(0,a.jsx)(n.li,{children:"开源社区十分活跃，文档齐全，学习成本不高。"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"鉴于 MyBatis 框架受众更广且后续实践课程的技术选型包含 MyBatis，因此会在本章节内容中介绍它，以及如何使用 Spring Boot 整合 MyBatis 框架对数据层进行功能开发。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tip",children:"本篇文章中所涉及的源码已经整理好并上传到百度云，地址和提取密码如下：\n链接: https://pan.baidu.com/s/1UtmS8W7k6XxUT_P3pD57Rw \n提取码: qxp2\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"mybatis-springboot-starter-介绍",children:["mybatis-springboot-starter 介绍",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mybatis-springboot-starter-介绍",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Spring Boot 框架的核心特性包括简化配置并快速开发，当开发者们需要整合某一个功能时，只需要引入其特定的场景启动器 ( starter ) 即可，比如 Web 模块整合、JDBC 模块整合、Thymeleaf 模块整合，开发者们在编码前只需要在 pom.xml 文件中引入对应的 starter 依赖即可。"}),"\n",(0,a.jsxs)(n.p,{children:["Spring 官方并没有提供 MyBatis 的场景启动器，但是 MyBatis 官方却紧紧的抱住了 Spring 的大腿，MyBatis 团队提供了 MyBatis 整合 Spring Boot 项目时的场景启动器，也就是 ",(0,a.jsx)(n.strong,{children:"mybatis-springboot-starter"}),"，大家通过命名方式也能够发现其中的区别，Spring 官方提供的启动器的命名方式都为 ",(0,a.jsx)(n.strong,{children:"spring-boot-starter-"}),"*，与 MyBatis 官方提供的 starter 组件还是有一些差别的，接下来认识一下 ",(0,a.jsx)(n.strong,{children:"mybatis-springboot-starter"})," 场景启动器。"]}),"\n",(0,a.jsxs)(n.p,{children:["MyBatis 官网地址为 ",(0,a.jsx)(n.a,{href:"http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/index.html",target:"_blank",rel:"noopener noreferrer",children:(0,a.jsx)(n.a,{href:"http://www.mybatis.org",target:"_blank",rel:"noopener noreferrer",children:"http://www.mybatis.org"})}),"，感兴趣的读者可以去官网查看更多内容，在官网中对 ",(0,a.jsx)(n.strong,{children:"mybatis-springboot-starter"}),"  的介绍如下所示："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"The MyBatis-Spring-Boot-Starter help you build quickly MyBatis applications on top of the Spring Boot. \n"})}),"\n",(0,a.jsxs)(n.p,{children:["MyBatis-Spring-Boot-Starter 可以帮助开发者快速创建基于 Spring Boot 的 MyBatis 应用程序，那么使用 ",(0,a.jsx)(n.strong,{children:"MyBatis-Spring-Boot-Starter"})," 可以做什么呢？"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"构建独立的 MyBatis 应用程序"}),"\n",(0,a.jsx)(n.li,{children:"零模板"}),"\n",(0,a.jsx)(n.li,{children:"更少的 XML 配置代码甚至无 XML 配置"}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"mybatis-自动配置详解",children:["MyBatis 自动配置详解",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mybatis-自动配置详解",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"在正式使用 MyBatis 开发功能之前，先来结合其自动配置源码了解一下 mybatis-spring-boot-starter 场景启动器做了哪些操作，知其然也要知其所以然。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"1.mybatis-spring-boot-starter 依赖："})}),"\n",(0,a.jsx)(n.p,{children:"在 pom 文件中引入 spring-boot-starter-jdbc 依赖，如下图所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:h,alt:"image-20210107142441792"})}),"\n",(0,a.jsx)(n.p,{children:"点击 mybatis-spring-boot-starter 并进入 mybatis-spring-boot-starter-2.1.3.pom 文件，源码如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:m,alt:"image-20210107142736233"})}),"\n",(0,a.jsx)(n.p,{children:"通过源码可以看到，该 pom 文件中引入了 MyBatis 相关依赖以及其自动配置依赖包，同时可以看到该 pom 文件中也包含 JDBC 场景启动器，如果开发者没有在主 pom 配置文件中引入的话，这里也会引入并使用默认的 HikariCP 数据源。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"2.mybatis-spring-boot-starter 自动配置类："})}),"\n",(0,a.jsx)(n.p,{children:"通过 Maven Libraries 查找 MyBatis 的依赖文件可以得到其自动配置类，名称为 MybatisAutoConfiguration ，该自动配置类与官方的自动配置类不同，它并不是定义在 spring-boot-autoconfigure-2.3.7.RELEASE.jar 中的 org.springframework.boot.autoconfigure 包中，而是定义在 mybatis-spring-boot-autoconfigure-2.1.3.jar 中的 org.mybatis.spring.boot.autoconfigure 包中，目录结构如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:u,alt:"image-20210107143055609"})}),"\n",(0,a.jsx)(n.p,{children:"跟入 MybatisAutoConfiguration  类，其源码及注释如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@org.springframework.context.annotation.Configuration // 配置类\n@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class }) // 判断当前 classpath 下是否存在指定类，若存在则将当前的配置装载入 Spring 容器\n@ConditionalOnSingleCandidate(DataSource.class) // 在当前 IOC 容器中存在 DataSource 数据源对象时\n@EnableConfigurationProperties(MybatisProperties.class) // MyBatis 的配置项\n@AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })// 自动配置时机\npublic class MybatisAutoConfiguration implements InitializingBean {\n  \n  private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class);\n\n  private final MybatisProperties properties;\n\n  private final Interceptor[] interceptors;\n\n  private final TypeHandler[] typeHandlers;\n\n  private final LanguageDriver[] languageDrivers;\n\n  private final ResourceLoader resourceLoader;\n\n  private final DatabaseIdProvider databaseIdProvider;\n\n  private final List<ConfigurationCustomizer> configurationCustomizers;\n\n  public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider<Interceptor[]> interceptorsProvider,\n      ObjectProvider<TypeHandler[]> typeHandlersProvider, ObjectProvider<LanguageDriver[]> languageDriversProvider,\n      ResourceLoader resourceLoader, ObjectProvider<DatabaseIdProvider> databaseIdProvider,\n      ObjectProvider<List<ConfigurationCustomizer>> configurationCustomizersProvider) {\n    this.properties = properties;\n    this.interceptors = interceptorsProvider.getIfAvailable();\n    this.typeHandlers = typeHandlersProvider.getIfAvailable();\n    this.languageDrivers = languageDriversProvider.getIfAvailable();\n    this.resourceLoader = resourceLoader;\n    this.databaseIdProvider = databaseIdProvider.getIfAvailable();\n    this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();\n  }\n    \n  @Bean // 注册 SqlSessionFactory 到 IOC 容器中\n  @ConditionalOnMissingBean // 在当前 IOC 容器中不存在 SqlSessionFactory 类型的 bean 时注册\n  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();\n    factory.setDataSource(dataSource);\n    factory.setVfs(SpringBootVFS.class);\n    if (StringUtils.hasText(this.properties.getConfigLocation())) {\n      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));\n    }\n    applyConfiguration(factory);\n    if (this.properties.getConfigurationProperties() != null) {\n      factory.setConfigurationProperties(this.properties.getConfigurationProperties());\n    }\n    if (!ObjectUtils.isEmpty(this.interceptors)) {\n      factory.setPlugins(this.interceptors);\n    }\n    if (this.databaseIdProvider != null) {\n      factory.setDatabaseIdProvider(this.databaseIdProvider);\n    }\n    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {\n      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());\n    }\n    if (this.properties.getTypeAliasesSuperType() != null) {\n      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());\n    }\n    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {\n      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());\n    }\n    if (!ObjectUtils.isEmpty(this.typeHandlers)) {\n      factory.setTypeHandlers(this.typeHandlers);\n    }\n    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {\n      factory.setMapperLocations(this.properties.resolveMapperLocations());\n    }\n    Set<String> factoryPropertyNames = Stream\n        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)\n        .collect(Collectors.toSet());\n    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();\n    if (factoryPropertyNames.contains("scriptingLanguageDrivers") && !ObjectUtils.isEmpty(this.languageDrivers)) {\n      // Need to mybatis-spring 2.0.2+\n      factory.setScriptingLanguageDrivers(this.languageDrivers);\n      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {\n        defaultLanguageDriver = this.languageDrivers[0].getClass();\n      }\n    }\n    if (factoryPropertyNames.contains("defaultScriptingLanguageDriver")) {\n      // Need to mybatis-spring 2.0.2+\n      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);\n    }\n\n    return factory.getObject();\n  }\n\n  @Bean // 注册 SqlSessionTemplate 到 IOC 容器中\n  @ConditionalOnMissingBean // 在当前 IOC 容器中不存在 SqlSessionTemplate 类型的 bean 时注册\n  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n    ExecutorType executorType = this.properties.getExecutorType();\n    if (executorType != null) {\n      return new SqlSessionTemplate(sqlSessionFactory, executorType);\n    } else {\n      return new SqlSessionTemplate(sqlSessionFactory);\n    }\n  }\n \n  public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar {\n\n    private BeanFactory beanFactory;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n      if (!AutoConfigurationPackages.has(this.beanFactory)) {\n        logger.debug("Could not determine auto-configuration package, automatic mapper scanning disabled.");\n        return;\n      }\n\n      logger.debug("Searching for mappers annotated with @Mapper");\n\n      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);\n      if (logger.isDebugEnabled()) {\n        packages.forEach(pkg -> logger.debug("Using auto-configuration base package \'{}\'", pkg));\n      }\n\n      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);\n      builder.addPropertyValue("processPropertyPlaceHolders", true);\n      builder.addPropertyValue("annotationClass", Mapper.class);\n      builder.addPropertyValue("basePackage", StringUtils.collectionToCommaDelimitedString(packages));\n      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);\n      Stream.of(beanWrapper.getPropertyDescriptors())\n          // Need to mybatis-spring 2.0.2+\n          .filter(x -> x.getName().equals("lazyInitialization")).findAny()\n          .ifPresent(x -> builder.addPropertyValue("lazyInitialization", "${mybatis.lazy-initialization:false}"));\n      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) {\n      this.beanFactory = beanFactory;\n    }\n\n  }\n\n  @org.springframework.context.annotation.Configuration // 配置类\n  @Import(AutoConfiguredMapperScannerRegistrar.class) // 引入 AutoConfiguredMapperScannerRegistrar 类\n  @ConditionalOnMissingBean({ MapperFactoryBean.class, MapperScannerConfigurer.class }) // 在当前 IOC 容器中不存在 MapperFactoryBean 和 MapperScannerConfigurer 类型的 bean 时注册\n  public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {\n\n    @Override\n    public void afterPropertiesSet() {\n      logger.debug(\n          "Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.");\n    }\n\n  }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"DataSourceAutoConfiguration 类的注解释义如下："})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"@Configuration(proxyBeanMethods = false)"}),"\n",(0,a.jsx)(n.p,{children:"指定该类为配置类。"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"@ConditionalOnClass({{ SqlSessionFactory.class, SqlSessionFactoryBean.class })"}),"\n",(0,a.jsx)(n.p,{children:"判断当前 classpath 下是否存在指定类：SqlSessionFactory 类和 SqlSessionFactoryBean 类，存在则生效。"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"@ConditionalOnSingleCandidate(DataSource.class)"}),"\n",(0,a.jsx)(n.p,{children:"判断 IOC 容器中是否存在类型为 DataSource 的 bean，存在则生效。"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"@AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })"}),"\n",(0,a.jsx)(n.p,{children:"自动配置的时机。"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"结合该自动配置类的源码及源码注释可得知，Mybatis 自动配置类的自动配置触发机制为：当前项目的类路径中存在 SqlSessionFactory 类和 SqlSessionFactoryBean 类且 IOC 容器中存在 DataSource 类型的 bean，因为当前项目引入了 spring-boot-starter-jdbc 和 mybatis-spring-boot-starter 两个场景启动器，启动器中包含了相关依赖，且引入 spring-boot-starter-jdbc 后数据源已自动配置，该知识点前文已经讲解，因此 IOC 容器中存在 DataSource 类型的 bean，即 MyBatis 自动配置类会生效。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"3.DataSourceAutoConfiguration 自动配置类的作用"})}),"\n",(0,a.jsx)(n.p,{children:"以上是 MyBatis 自动配置流程生效的解释，接下来是另外一个问题，MyBatis 自动配置步骤做了哪些事情？"}),"\n",(0,a.jsx)(n.p,{children:"通过前文的条件注解分析可知，当自动配置流程开始且条件满足后，自动配置类 DataSourceAutoConfiguration 进行自动配置时会判断当前 IOC 容器中是否存在 SqlSessionFactory 和 SqlSessionTemplate 类型的 bean，如果存在则不做操作，如果不存在则初始化 SqlSessionFactory 类和 SqlSessionTemplate 类并注册到 IOC 容器中，MyBatis 框架对于数据库的访问和相关操作都是基于这两个对象展开。"}),"\n",(0,a.jsx)(n.p,{children:"除此之外，DataSourceAutoConfiguration 自动配置类还有一个静态内部类 MapperScannerRegistrarNotFoundConfiguration 类，当项目中不存在 @MapperScan 注解时生效，它是用于扫描项目中标注了 @Mapper 注解的接口，将这些接口与 xxxMapper.xml 文件一一映射后注入到 IOC 容器中以供业务代码调用来操作数据库，查看 @Mapper 注解的源码可知，它的定义中并没有 @Component 注解，因此 Spring 框架本身并不支持 @Mapper 注解的扫描，所以需要由 MyBatis 框架来完成这个操作，这一步的操作就由 MapperScannerRegistrarNotFoundConfiguration 类引入的 AutoConfiguredMapperScannerRegistrar 类来完成。当项目中存在 @MapperScan 注解时，Mapper 文件的扫描和配置工作就由 MapperScannerRegistrar 类来完成，感兴趣的读者可以自行查看这部分源码，这里就不再展开叙述。"}),"\n",(0,a.jsx)(n.p,{children:"在未使用 Spring Boot 框架配置 MyBatis 组件时，需要在 Spring 配置文件中增加 MyBatis 相关配置才能够正常的使用 MyBatis 框架，配置文件如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<bean id="dataSource"\n      class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n  <property name="driverClassName" value="com.mysql.jdbc.Driver"/>\n  <property name="url"\n            value="jdbc:mysql://localhost:3306/db"/>\n  <property name="username" value="root"/>\n  <property name="password" value="123456"/>\n</bean>\n\n\x3c!-- 配置mybatis的sqlSessionFactory --\x3e\n<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">\n  <property name="dataSource" ref="dataSource"/>\n  \x3c!-- 自动扫描mappers.xml文件 --\x3e\n  <property name="mapperLocations" value="classpath:com/**/mappers/*.xml"></property>\n  \x3c!-- mybatis配置文件 --\x3e\n  <property name="configLocation" value="classpath:mybatis-config.xml"></property>\n</bean>\n\n\x3c!-- DAO接口所在包名，Spring会自动查找其下的类 --\x3e\n<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">\n  <property name="basePackage" value="com.core.dao"/>\n  <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"></property>\n</bean>\n'})}),"\n",(0,a.jsx)(n.p,{children:"其实，以上源码分析中，DataSourceAutoConfiguration 自动配置类所做的就是之前开发者们需要手动完成的 MyBatis 配置文件中的内容，只是在 Spring Boot 项目中，这个步骤由 Spring Boot 框架接管了。与 Spring 项目中需要手动配置 MyBatis 相比，Spring Boot 自动配置了使用 MyBatis 框架时所需的相关组件，这个过程对于开发者来说是无感知的，虽然源码看起来比较吃力，但是实际使用的时候其实并不会有这种感觉，书中介绍这部分源码只是为了大家能够更好的理解 Spring Boot 项目中对于 MyBatis 框架的自动配置，知晓其原理。"}),"\n",(0,a.jsx)(n.p,{children:"实际开发过程中，开发者们只需引入 starter 依赖即可零配置使用 MyBatis 框架进行编码，这也是 Spring Boot 框架“约定优于配置”特性的体现，如果开发者不进行自定义的配置，就可以把相关的配置过程交给 Spring Boot 框架，如果有自定义的需求，那么开发者也可以自己去配置 MyBatis 框架相关的组件，有了自定义的配置，MyBatis 自动配置流程的部分步骤就不会执行。"}),"\n",(0,a.jsx)(n.p,{children:"总结下来可以发现，mybatis-spring-boot-starter 场景启动器首先在项目中引入了 MyBatis 的相关依赖，而其中的自动配置类会向 Spring 的 IOC 容器中注册 SqlSessionFactory 和 SqlSessionTemplate 两个 MyBatis 开发中必不可缺的对象，并扫描 Mapper 组件注册到 IOC 容器中。"}),"\n",(0,a.jsx)(n.p,{children:"读者朋友们可以参考本节内容进行源码探索，学习 MyBatis 的自动配置原理。"}),"\n",(0,a.jsxs)(n.h2,{id:"spring-boot-整合-mybatis-过程",children:["Spring Boot 整合 MyBatis 过程",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#spring-boot-整合-mybatis-过程",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"源码分析之后，接下来将结合实际的代码案例讲解一下 Spring Boot 框架整合 MyBatis 操作数据库的流程。"}),"\n",(0,a.jsxs)(n.h4,{id:"添加依赖",children:["添加依赖",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加依赖",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"想要把 MyBatis 框架整合到 Spring Boot 项目中，首先需要将其依赖配置增加到 pom.xml 文件中，本书代码案例中选择的 mybatis-springboot-starter 版本为 2.1.3，需要 Spring Boot 版本达到 2.0 或者以上版本，同时需要将数据源依赖和 JDBC 依赖也添加到配置文件中，pom.xml 配置文件如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">\n	<modelVersion>4.0.0</modelVersion>\n	<parent>\n		<groupId>org.springframework.boot</groupId>\n		<artifactId>spring-boot-starter-parent</artifactId>\n		<version>2.3.7.RELEASE</version>\n		<relativePath/> \x3c!-- lookup parent from repository --\x3e\n	</parent>\n	<groupId>ltd.newbee.mall</groupId>\n	<artifactId>newbee-mall</artifactId>\n	<version>0.0.1-SNAPSHOT</version>\n	<name>newbee-mall</name>\n	<description>mysql-demo</description>\n\n	<properties>\n		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n		<java.version>1.8</java.version>\n	</properties>\n\n	<dependencies>\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-web</artifactId>\n		</dependency>\n\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-jdbc</artifactId>\n		</dependency>\n\n		<dependency>\n			<groupId>mysql</groupId>\n			<artifactId>mysql-connector-java</artifactId>\n			<scope>runtime</scope>\n		</dependency>\n\n		\x3c!-- 引入 MyBatis 场景启动器，包含其自动配置类及 MyBatis 3 相关依赖 --\x3e\n		<dependency>\n			<groupId>org.mybatis.spring.boot</groupId>\n			<artifactId>mybatis-spring-boot-starter</artifactId>\n			<version>2.1.3</version>\n		</dependency>\n\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-test</artifactId>\n			<scope>test</scope>\n			<exclusions>\n				<exclusion>\n					<groupId>org.junit.vintage</groupId>\n					<artifactId>junit-vintage-engine</artifactId>\n				</exclusion>\n			</exclusions>\n		</dependency>\n	</dependencies>\n\n	<build>\n		<plugins>\n			<plugin>\n				<groupId>org.springframework.boot</groupId>\n				<artifactId>spring-boot-maven-plugin</artifactId>\n			</plugin>\n		</plugins>\n	</build>\n\n	<repositories>\n		<repository>\n			<id>alimaven</id>\n			<name>aliyun maven</name>\n			<url>http://maven.aliyun.com/nexus/content/repositories/central/</url>\n			<releases>\n				<enabled>true</enabled>\n			</releases>\n			<snapshots>\n				<enabled>false</enabled>\n			</snapshots>\n		</repository>\n	</repositories>\n\n</project>\n'})}),"\n",(0,a.jsx)(n.p,{children:"这样，MyBatis 的场景启动器和相关依赖就整合进项目中了。"}),"\n",(0,a.jsxs)(n.h4,{id:"applicationproperties-配置",children:["application.properties 配置",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#applicationproperties-配置",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Spring Boot 整合 MyBatis 时几个比较需要注意的配置参数："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"mybatis.config-location"})}),"\n",(0,a.jsx)(n.p,{children:"配置 mybatis-config.xml 路径，mybatis-config.xml 中配置 MyBatis 基础属性，如果项目中配置了 mybatis-config.xml 文件需要设置该参数"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"mybatis.mapper-locations"})}),"\n",(0,a.jsx)(n.p,{children:"配置 Mapper 文件对应的 XML 文件路径"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"mybatis.type-aliases-package"})}),"\n",(0,a.jsx)(n.p,{children:"配置项目中实体类包路径"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:"mybatis.config-location=classpath:mybatis-config.xml\nmybatis.mapper-locations=classpath:mapper/*Dao.xml\nmybatis.type-aliases-package=ltd.newbee.mall.entity\n"})}),"\n",(0,a.jsx)(n.p,{children:"开发时只配置 mapper-locations 即可，最终的 application.properties 文件如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-properties",children:"spring.datasource.name=newbee-mall-datasource\nspring.datasource.driverClassName=com.mysql.cj.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/test_db?useUnicode=true&serverTimezone=Asia/Shanghai&characterEncoding=utf8&autoReconnect=true&useSSL=false&allowMultiQueries=true&useAffectedRows=true\nspring.datasource.username=root\nspring.datasource.password=123456\n\nmybatis.mapper-locations=classpath:mapper/*Mapper.xml\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"各位开发者可以根据自己数据库的配置修改帐号和密码。"}),"\n"]}),"\n",(0,a.jsxs)(n.h4,{id:"启动类增加-mapper-扫描",children:["启动类增加 Mapper 扫描",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#启动类增加-mapper-扫描",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"在启动类中添加对 Mapper 包扫描 @MapperScan，Spring Boot 启动的时候会自动加载包路径下的 Mapper 接口："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@SpringBootApplication\n@MapperScan("ltd.newbee.mall.dao") //添加 @Mapper 注解\npublic class NewbeeMallApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"当然也可以直接在每个 Mapper 接口上面添加 @Mapper 注解，但是如果 Mapper 接口数量较多，在每个 Mapper  接口上加注解是比较繁琐的，建议使用扫描注解。"}),"\n",(0,a.jsxs)(n.h2,{id:"spring-boot-整合-mybatis-进行数据库的增删改查",children:["Spring Boot 整合 MyBatis 进行数据库的增删改查",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#spring-boot-整合-mybatis-进行数据库的增删改查",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"在开发项目之前需要在 MySQL 中先创建数据库和表作为项目演示使用，SQL 语句如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"DROP TABLE IF EXISTS `tb_user`;\n\nCREATE TABLE `tb_user` (\n  `id` INT(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `name` VARCHAR(100) NOT NULL DEFAULT '' COMMENT '登录名',\n  `password` VARCHAR(100) NOT NULL DEFAULT '' COMMENT '密码',\n  PRIMARY KEY (`id`)\n) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;\n\n/*Data for the table `jdbc_test` */\n\ninsert  into `tb_user`(`id`,`name`,`password`) values (1,'Spring Boot','123456'),(2,'MyBatis','123456'),(3,'Thymeleaf','123456'),(4,'Java','123456'),(5,'MySQL','123456'),(6,'IDEA','123456');\n"})}),"\n",(0,a.jsx)(n.p,{children:"在数据库中新建了一个名称为 tb_user 的数据表，表中有 id , name , password 三个字段，在本机测试时可以直接将以上 SQL 拷贝到 MySQL 中执行即可。"}),"\n",(0,a.jsx)(n.p,{children:"接下来是功能实现步骤，使用 MyBatis 进行数据的增删改查操作。"}),"\n",(0,a.jsxs)(n.h4,{id:"新建实体类和-mapper-接口",children:["新建实体类和 Mapper 接口",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#新建实体类和-mapper-接口",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"新建 entity 包并在 entity 包下新建 User 类，将 tb_user 中的字段映射到该实体类中，代码如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"package ltd.newbee.mall.entity;\n\npublic class User {\n\n    private Integer id;\n    private String name;\n    private String password;\n\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"新建 dao 包并在 dao 包中新建 UserDao 接口，并定义增删改查四个方法，代码如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"package ltd.newbee.mall.dao;\nimport ltd.newbee.mall.entity.User;\nimport java.util.List;\n\n/**\n * @author 十三\n * MyBatis 功能测试\n */\npublic interface UserDao {\n    /**\n     * 返回数据列表\n     *\n     * @return\n     */\n    List<User> findAllUsers();\n\n    /**\n     * 添加\n     *\n     * @param User\n     * @return\n     */\n    int insertUser(User User);\n\n    /**\n     * 修改\n     *\n     * @param User\n     * @return\n     */\n    int updUser(User User);\n\n    /**\n     * 删除\n     *\n     * @param id\n     * @return\n     */\n    int delUser(Integer id);\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"创建-mapper-接口的映射文件",children:["创建 Mapper 接口的映射文件",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#创建-mapper-接口的映射文件",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"在 resources 目录下新建 mapper 目录，并在 mapper 目录下新建 Mapper 接口的映射文件 UserMapper.xml，之后进行映射文件的编写。"}),"\n",(0,a.jsx)(n.p,{children:"1.首先，定义映射文件与 Mapper 接口的对应关系，比如该示例中，需要将 UserMapper.xml 文件与对应的 UserDao 接口类之间的关系定义出来："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<mapper namespace="ltd.newbee.mall.dao.UserDao">\n'})}),"\n",(0,a.jsx)(n.p,{children:"2.之后，配置表结构和实体类的对应关系："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<resultMap type="ltd.newbee.mall.entity.User" id="UserResult">\n  <result property="id" column="id"/>\n  <result property="name" column="name"/>\n  <result property="password" column="password"/>\n</resultMap>\n'})}),"\n",(0,a.jsx)(n.p,{children:"3.最后，按照对应的接口方法，编写增删改查方法具体的 SQL 语句，最终的 UserMapper.xml 文件如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n<mapper namespace="ltd.newbee.mall.dao.UserDao">\n  <resultMap type="ltd.newbee.mall.entity.User" id="UserResult">\n    <result property="id" column="id"/>\n    <result property="name" column="name"/>\n    <result property="password" column="password"/>\n  </resultMap>\n\n  <select id="findAllUsers" resultMap="UserResult">\n    select id,name,password from tb_user\n    order by id desc\n  </select>\n\n  <insert id="insertUser" parameterType="ltd.newbee.mall.entity.User">\n    insert into tb_user(name,password)\n    values(#{name},#{password})\n  </insert>\n\n  <update id="updUser" parameterType="ltd.newbee.mall.entity.User">\n    update tb_user\n    set\n    name=#{name},password=#{password}\n    where id=#{id}\n  </update>\n\n  <delete id="delUser" parameterType="int">\n    delete from tb_user where id=#{id}\n  </delete>\n</mapper>\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"新建-mybatiscontroller",children:["新建 MyBatisController",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#新建-mybatiscontroller",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"为了对 MyBatis 进行功能测试，在 controller 包下新建 MyBatisController 类，并新增 4 个方法分别接收对于 tb_user 表的增删改查请求，代码如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'package ltd.newbee.mall.controller;\n\nimport ltd.newbee.mall.dao.UserDao;\nimport ltd.newbee.mall.entity.User;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.annotation.Resource;\nimport java.util.List;\n\n@RestController\npublic class MyBatisController {\n\n    @Resource\n    UserDao userDao;\n\n    // 查询所有记录\n    @GetMapping("/users/mybatis/queryAll")\n    public List<User> queryAll() {\n        return userDao.findAllUsers();\n    }\n\n    // 新增一条记录\n    @GetMapping("/users/mybatis/insert")\n    public Boolean insert(String name, String password) {\n        if (StringUtils.isEmpty(name) || StringUtils.isEmpty(password)) {\n            return false;\n        }\n        User user = new User();\n        user.setName(name);\n        user.setPassword(password);\n        return userDao.insertUser(user) > 0;\n    }\n\n    // 修改一条记录\n    @GetMapping("/users/mybatis/update")\n    public Boolean update(Integer id, String name, String password) {\n        if (id == null || id < 1 || StringUtils.isEmpty(name) || StringUtils.isEmpty(password)) {\n            return false;\n        }\n        User user = new User();\n        user.setId(id);\n        user.setName(name);\n        user.setPassword(password);\n        return userDao.updUser(user) > 0;\n    }\n\n    // 删除一条记录\n    @GetMapping("/users/mybatis/delete")\n    public Boolean delete(Integer id) {\n        if (id == null || id < 1) {\n            return false;\n        }\n        return userDao.delUser(id) > 0;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"上述步骤完成后，项目的代码目录如下图所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:g,alt:"WX20210111-160615@2x"})}),"\n",(0,a.jsx)(n.p,{children:"编码完成后启动 Spring Boot 项目，启动成功后打开浏览器中对以上四个功能进行验证。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"1.Spring Boot 整合 MyBatis 向数据库中新增记录。"})}),"\n",(0,a.jsx)(n.p,{children:"在地址栏输入如下地址："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"http://localhost:8080/users/mybatis/insert?name=十三&password=1234567"})}),"\n",(0,a.jsx)(n.p,{children:"传参分别为“十三”和“1234567”，表示向数据库中新增一条记录，其中 name 字段值为“十三”，password 字段值为“1234567”，页面返回结果如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:"image-20210107173053707"})}),"\n",(0,a.jsx)(n.p,{children:"此时查看数据库中的记录，可以看到已经新增成功，新的记录已经生成，数据如下图所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:c,alt:"image-20210107173605571"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"2.Spring Boot 整合 MyBatis 删除数据库中的记录。"})}),"\n",(0,a.jsx)(n.p,{children:"在地址栏输入如下地址："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"http://localhost:8080/delete?id=3"})}),"\n",(0,a.jsx)(n.p,{children:"传参为 5，表示从数据库表中删除一条 id 为 5 的记录，页面返回结果如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:l,alt:"image-20210107173759835"})}),"\n",(0,a.jsx)(n.p,{children:"此时查看数据库中的记录，id 为 5 的记录已经被删除成功，数据如下图所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:p,alt:"image-20210107173901505"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"3.Spring Boot 整合 MyBatis 修改数据库中的记录。"})}),"\n",(0,a.jsx)(n.p,{children:"在地址栏输入如下地址："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"http://localhost:8080/users/mybatis/update?id=1&name=book01&password=12345678"})}),"\n",(0,a.jsx)(n.p,{children:"传参分别为为 “1”、“book01”和“12345678”，表示修改数据库表中 id 为 1 的记录，页面返回结果如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:o,alt:"image-20210107174052760"})}),"\n",(0,a.jsx)(n.p,{children:"此时查看数据库中的记录，id 为 1 的记录已经修改成功，数据如下图所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:t,alt:"image-20210107174139644"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"4.Spring Boot 整合 MyBatis 查询数据库中的记录。"})}),"\n",(0,a.jsx)(n.p,{children:"在地址栏输入如下地址："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.code,{children:"http://localhost:8080/users/mybatis/queryAll"})}),"\n",(0,a.jsx)(n.p,{children:"该请求会查询出数据库中的所有记录，页面返回结果如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:s,alt:"image-20210107174216282"})}),"\n",(0,a.jsx)(n.p,{children:"以上为笔者进行功能测试的步骤，大家在测试时也可以尝试多添加几条记录，如果能够正常获取到记录以及正确的 操作 tb_user 表中的记录就表示功能整合成功！"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(b,{...e})}):b(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F18.Spring%20Boot%20%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B4%E5%90%88%20MyBatis%20%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93.md"]={toc:[{text:"MyBatis  简介",id:"mybatis--简介",depth:2},{text:"mybatis-springboot-starter 介绍",id:"mybatis-springboot-starter-介绍",depth:2},{text:"MyBatis 自动配置详解",id:"mybatis-自动配置详解",depth:2},{text:"Spring Boot 整合 MyBatis 过程",id:"spring-boot-整合-mybatis-过程",depth:2},{text:"添加依赖",id:"添加依赖",depth:4},{text:"application.properties 配置",id:"applicationproperties-配置",depth:4},{text:"启动类增加 Mapper 扫描",id:"启动类增加-mapper-扫描",depth:4},{text:"Spring Boot 整合 MyBatis 进行数据库的增删改查",id:"spring-boot-整合-mybatis-进行数据库的增删改查",depth:2},{text:"新建实体类和 Mapper 接口",id:"新建实体类和-mapper-接口",depth:4},{text:"创建 Mapper 接口的映射文件",id:"创建-mapper-接口的映射文件",depth:4},{text:"新建 MyBatisController",id:"新建-mybatiscontroller",depth:4}],title:"18.Spring Boot 实践之整合 MyBatis 操作数据库",headingTitle:"18.Spring Boot 实践之整合 MyBatis 操作数据库",frontmatter:{}}}}]);