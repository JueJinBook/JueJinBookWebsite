"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["85343"],{123128:function(e,r,n){n.r(r),n.d(r,{default:()=>p});var c=n(552676),s=n(740453);function a(e){let r=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",strong:"strong",img:"img",hr:"hr",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(r.h1,{id:"8高阶篇-02把庞大的-npm-script-拆到单独文件中",children:["8高阶篇 02：把庞大的 npm script 拆到单独文件中",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#8高阶篇-02把庞大的-npm-script-拆到单独文件中",children:"#"})]}),"\n",(0,c.jsx)(r.p,{children:"当 npm script 不断累积、膨胀的时候，全部放在 package.json 里面可能并不是个好主意，因为这样会导致 package.json 糟乱，可读性降低。"}),"\n",(0,c.jsxs)(r.p,{children:["借助 ",(0,c.jsx)(r.a,{href:"https://github.com/testdouble/scripty",target:"_blank",rel:"noopener noreferrer",children:"scripty"})," 我们可以将 npm script 剥离到单独的文件中，从而把复杂性隔到单独的模块里面，让代码整体看起来更加清晰。"]}),"\n",(0,c.jsx)(r.p,{children:"示例项目中的覆盖率相关的 npm script 占据了很大的篇幅，如下："}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-json",children:'  "scripts": {\n    "cover": "nyc --reporter=html npm test",\n    "cover:cleanup": "rimraf coverage && rimraf .nyc_output",\n    "cover:archive": "cross-var \\"make-dir coverage_archive/$npm_package_version && cpr coverage/* coverage_archive/$npm_package_version -o\\"",\n    "cover:serve": "cross-var http-server coverage_archive/$npm_package_version -p $npm_package_config_port",\n    "cover:open": "cross-var opn http://localhost:$npm_package_config_port",\n    "precover": "npm run cover:cleanup",\n    "postcover": "npm-run-all cover:archive --parallel cover:serve cover:open"\n  },\n'})}),"\n",(0,c.jsx)(r.p,{children:"如果要隔离复杂性，我们可以考虑从 cover 相关的 script 入手，具体操作步骤如下："}),"\n",(0,c.jsxs)(r.h3,{id:"1-安装依赖",children:["1. 安装依赖",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#1-安装依赖",children:"#"})]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-shell",children:"npm i scripty -D\n# npm install scripty --save-dev\n# yarn add scripty -D\n"})}),"\n",(0,c.jsxs)(r.h3,{id:"2-准备目录和文件",children:["2. 准备目录和文件",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#2-准备目录和文件",children:"#"})]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-shell",children:"mkdir -p scripts/cover\n"})}),"\n",(0,c.jsx)(r.p,{children:"先创建两层的目录，因为我们计划把 cover 脚本写成多个，方便单独去执行，这里命名为 scripts 是 scripty 默认的，实际上是可以自定义的。"}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-shell",children:"touch scripts/cover.sh\ntouch scripts/cover/serve.sh\ntouch scripts/cover/open.sh\n"})}),"\n",(0,c.jsx)(r.p,{children:"然后创建空白的脚本文件，因为有了单独的脚本，我们可以把原来的 precover、cover、postcover、cover:archive、cover:cleanup 合并到一个文件中。"}),"\n",(0,c.jsx)(r.p,{children:"按照 scripty 的默认约定，npm script 命令和上面各文件的对应关系如下："}),"\n",(0,c.jsxs)(r.table,{children:["\n",(0,c.jsxs)(r.thead,{children:["\n",(0,c.jsxs)(r.tr,{children:["\n",(0,c.jsx)(r.th,{children:"命令"}),"\n",(0,c.jsx)(r.th,{children:"文件"}),"\n",(0,c.jsx)(r.th,{children:"备注"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(r.tbody,{children:["\n",(0,c.jsxs)(r.tr,{children:["\n",(0,c.jsx)(r.td,{children:"cover"}),"\n",(0,c.jsx)(r.td,{children:"scripts/cover.sh"}),"\n",(0,c.jsx)(r.td,{children:"内含 precover、postcover 的逻辑"}),"\n"]}),"\n",(0,c.jsxs)(r.tr,{children:["\n",(0,c.jsx)(r.td,{children:"cover:serve"}),"\n",(0,c.jsx)(r.td,{children:"scripts/cover/serve.sh"}),"\n",(0,c.jsx)(r.td,{children:"启动服务"}),"\n"]}),"\n",(0,c.jsxs)(r.tr,{children:["\n",(0,c.jsx)(r.td,{children:"cover:open"}),"\n",(0,c.jsx)(r.td,{children:"scripts/cover/open.sh"}),"\n",(0,c.jsx)(r.td,{children:"打开预览"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.strong,{children:"特别注意的是，给所有脚本增加可执行权限是必须的，否则 scripty 执行时会报错"}),"，我们可以给所有的脚本增加可执行权限："]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-shell",children:"chmod -R a+x scripts/**/*.sh\n"})}),"\n",(0,c.jsxs)(r.h3,{id:"3-修改-scripty-脚本",children:["3. 修改 scripty 脚本",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#3-修改-scripty-脚本",children:"#"})]}),"\n",(0,c.jsx)(r.p,{children:"准备好目录和文件之后，接下来需要给脚本填充内容，脚本内容如下（因为脚本使用的是 bash，所以直接忽略了跨平台兼容的处理，跨平台兼容脚本最好使用 Node.js 编写，下节会介绍）："}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.code,{children:"scripts/cover.sh"})," 内容如下（cleanup --\x3e cover --\x3e archive --\x3e preview）："]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-bash",children:"#!/usr/bin/env bash\n\n# remove old coverage reports\nrimraf coverage && rimraf .nyc_output\n\n# run test and collect new coverage\nnyc --reporter=html npm run test\n\n# achive coverage report by version\nmkdir -p coverage_archive/$npm_package_version\ncp -r coverage/* coverage_archive/$npm_package_version\n\n# open coverage report for preview\nnpm-run-all --parallel cover:serve cover:open\n"})}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.code,{children:"scripts/cover/serve.sh"})," 内容如下："]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-bash",children:"#!/usr/bin/env bash\n\nhttp-server coverage_archive/$npm_package_version -p $npm_package_config_port\n"})}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.code,{children:"scripts/cover/open.sh"})," 内容如下（这里有个 sleep，是为了确保文件系统写入完成）："]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-bash",children:"#!/usr/bin/env bash\n\nsleep 1\nopn http://localhost:$npm_package_config_port\n"})}),"\n",(0,c.jsx)(r.p,{children:"细心的同学可能注意到了，在 shell 脚本里面是可以随意使用 npm 的内置变量和自定义变量的。"}),"\n",(0,c.jsxs)(r.h3,{id:"4-修改-packagejson",children:["4. 修改 package.json",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#4-修改-packagejson",children:"#"})]}),"\n",(0,c.jsx)(r.p,{children:"主要改动是清理 cover:* 命令，接入 scripty，具体的 diff 如下："}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-patch",children:'   "scripts": {\n     "test": "cross-env NODE_ENV=test mocha tests/",\n-    "cover": "nyc --reporter=html npm test",\n-    "cover:cleanup": "rimraf coverage && rimraf .nyc_output",\n-    "cover:archive": "cross-var \\"make-dir coverage_archive/$npm_package_version && cpr coverage/* coverage_archive/$npm_package_version -o\\"",\n-    "cover:serve": "cross-var http-server coverage_archive/$npm_package_version -p $npm_package_config_port",\n-    "cover:open": "cross-var opn http://localhost:$npm_package_config_port",\n-    "precover": "npm run cover:cleanup",\n-    "postcover": "npm-run-all cover:archive --parallel cover:serve cover:open"\n+    "cover": "scripty",\n+    "cover:serve": "scripty",\n+    "cover:open": "scripty"\n   },\n'})}),"\n",(0,c.jsx)(r.p,{children:"这里我们只保留了 cover、cover:serve、cover:open 等 3 个命令，让它们都指向 scripty，调用哪个脚本都由 scripty 来处理。"}),"\n",(0,c.jsxs)(r.h3,{id:"5-实际测试",children:["5. 实际测试",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#5-实际测试",children:"#"})]}),"\n",(0,c.jsx)(r.p,{children:"修改完毕之后，重新运行 npm run cover，不出意外的话，我们能得到和原来完全相同的结果，仔细观察运行的日志，会发现在代码执行前有段额外的输出，如下图中红色框中的内容，scripty 在实际执行的时候会把执行的命令内容打印出来，方便调试："}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)(r.img,{src:"https://user-gold-cdn.xitu.io/2017/12/7/1602e70a1b4df91b?w=874&h=711&f=png&s=94680",alt:""})}),"\n",(0,c.jsxs)(r.h3,{id:"高级技巧",children:["高级技巧",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#高级技巧",children:"#"})]}),"\n",(0,c.jsxs)(r.p,{children:["scripty 比上面演示的要更强大，也支持通配符运行、脚本并行等特性、静默模式，如果有需求可以阅读官方的 ",(0,c.jsx)(r.a,{href:"https://github.com/testdouble/scripty#advanced-usage",target:"_blank",rel:"noopener noreferrer",children:"README.md"}),"，毕竟咱们已经入门了，不是么？"]}),"\n",(0,c.jsx)(r.hr,{}),"\n",(0,c.jsxs)(r.blockquote,{children:["\n",(0,c.jsxs)(r.p,{children:["本节用到的代码见 ",(0,c.jsx)(r.a,{href:"https://github.com/wangshijun/automated-workflow-with-npm-script/tree/07-manage-complexity-using-scripty",target:"_blank",rel:"noopener noreferrer",children:"GitHub"}),"，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 ",(0,c.jsx)(r.code,{children:"07-manage-complexity-using-scripty"}),"。"]}),"\n"]}),"\n",(0,c.jsx)(r.hr,{})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),e.components);return r?(0,c.jsx)(r,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}let p=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E7%94%A8%20npm%20script%20%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%2F8%E9%AB%98%E9%98%B6%E7%AF%87%2002%EF%BC%9A%E6%8A%8A%E5%BA%9E%E5%A4%A7%E7%9A%84%20npm%20script%20%E6%8B%86%E5%88%B0%E5%8D%95%E7%8B%AC%E6%96%87%E4%BB%B6%E4%B8%AD.md"]={toc:[{text:"1. 安装依赖",id:"1-安装依赖",depth:3},{text:"2. 准备目录和文件",id:"2-准备目录和文件",depth:3},{text:"3. 修改 scripty 脚本",id:"3-修改-scripty-脚本",depth:3},{text:"4. 修改 package.json",id:"4-修改-packagejson",depth:3},{text:"5. 实际测试",id:"5-实际测试",depth:3},{text:"高级技巧",id:"高级技巧",depth:3}],title:"8高阶篇 02：把庞大的 npm script 拆到单独文件中",headingTitle:"8高阶篇 02：把庞大的 npm script 拆到单独文件中",frontmatter:{}}}}]);