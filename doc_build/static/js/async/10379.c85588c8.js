"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["10379"],{193846:function(n,e,o){o.r(e),o.d(e,{default:()=>d});var s=o(552676),i=o(740453);function r(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",strong:"strong",ol:"ol",li:"li",blockquote:"blockquote"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"第28章详细设计开始实现业务逻辑",children:["第28章—详细设计：开始实现业务逻辑",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第28章详细设计开始实现业务逻辑",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\uFEFF上一章中，我们搭建了项目的顶层架构，我们知道，我们项目的整体是一个个的模块组成的，并且直播间这个模块，宏观上是一个 MVC 框架。"}),"\n",(0,s.jsx)(e.p,{children:"那么，本章我们就来实现具体的业务逻辑。"}),"\n",(0,s.jsxs)(e.h2,{id:"基础房间逻辑的实现",children:["基础房间逻辑的实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#基础房间逻辑的实现",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["首先，我们先来实现房间的基础功能，我们先定义下",(0,s.jsx)(e.code,{children:"IBaseRoomContext"}),"的实现类："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:'// 房间基础功能实现类\nclass BaseRoomContextImpl implements IBaseRoomContext {\n    \n    // 这个用来发送长链接消息，我们假设用的是socket\n    private SocketEngine socketEngine = new SocketEngine();\n\n    // 进房间 并且使用json初始化数据\n    void enterRoom(String json) {\n        \n    }\n    \n    // 退房间 成功则回调 true:退出成功 false:退出失败 \n    void exitRoom(Action<Boolean> callback) {\n        // 发送退出房间消息给服务器\n        socketEngine.sendMsg("{type:exit}")\n    }\n    \n    // 上座位 position:目标位置\n    void seatDown(int position) {\n        socketEngine.sendMsg("{type:seatDown,position:$position}")\n    }\n    \n    // 下座位\n    void leaveSeat() {\n        socketEngine.sendMsg("{type:levelSeat}")\n    }\n    \n    // 发消息\n    void sendMsg(String msg) {\n        socketEngine.sendMsg("{type:msg,msg:$msg}")\n    }\n    \n    // 送礼物\n    void sendGift(Gift gift, String uid) {\n        socketEngine.sendMsg("type:gift,gift:$gift,uid:$uid")\n    }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["逻辑很简单，我们只是实现了",(0,s.jsx)(e.code,{children:"IBaseRoomContext"}),"接口，并且定义了一个",(0,s.jsx)(e.code,{children:"SocketEngine"}),"用来向服务器发消息。"]}),"\n",(0,s.jsx)(e.p,{children:"那么，接收服务器消息的逻辑在哪里处理呢？"}),"\n",(0,s.jsx)(e.p,{children:"我们先来定义一个处理服务器消息的接口："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"interface IBaseRoomObserver {\n    \n    // 退出房间的回调\n    void onExitRoom();\n    \n    // 上座的回调\n    void onSeatDown(int position);\n    \n    // 下坐的回调\n    void onLeaveSeat();\n    \n    // 收到聊天消息的回调\n    void onRecvMsg(String msg);\n    \n    // 收到礼物的回调\n    void onRecvGift(Gift gift, String uid);\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["好，我们定义完了，看名字就像是个",(0,s.jsx)(e.strong,{children:"观察者模式"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["然后，我们来修改下",(0,s.jsx)(e.code,{children:"IBaseRoomContext"}),"，",(0,s.jsx)(e.strong,{children:"添加"}),"如下代码："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"interface IBaseRoomContext {\n    void addBaseRoomObserver(IBaseRoomObserver observer);\n    \n    void removeBaseRoomObserver(IBaseRoomObserver observer);\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"没错，我们添加了两个方法，一个用来添加观察者，一个用来移除观察者。"}),"\n",(0,s.jsxs)(e.p,{children:["然后，我们在",(0,s.jsx)(e.code,{children:"BaseRoomContextImpl"}),"里实现一下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"class BaseRoomContextImpl implements IBaseRoomContext {\n    // 定义观察者集合\n    private List<IBaseRoomObserver> observers = new ArrayList();\n    \n    // 添加观察者\n    void addBaseRoomObserver(IBaseRoomObserver observer) {\n        // 这里添加一个拦截，不能重复添加观察者\n        if(observers.contains(observer)) return;\n        observers.add(observer);\n    }\n    \n    // 移除观察者\n    void removeBaseRoomObserver(IBaseRoomObserver observer) {\n        observers.remove(observer);\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"好，到这里，我们已经添加完了观察者了，这个观察者是提供给 UI 用的，用来将自己接收到的服务器数据解析后，通知到 UI 层。"}),"\n",(0,s.jsx)(e.p,{children:"那服务器发送的数据你到底怎么处理呢？"}),"\n",(0,s.jsx)(e.p,{children:"别急别急，往下看。"}),"\n",(0,s.jsxs)(e.p,{children:["我们知道，对于",(0,s.jsx)(e.code,{children:"Socket"}),"来说，他有个",(0,s.jsx)(e.code,{children:"onMessage(String msg)"}),"方法，用来接收服务器发送的消息，那么突破点就来了，我们就通过这个方法接收并解析服务器的消息。"]}),"\n",(0,s.jsxs)(e.p,{children:["我们先定义一个",(0,s.jsx)(e.code,{children:"Socket"}),"行为的观察者："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// 定义socket行为的观察者\ninterface SocketActionObserver {\n\n    // 连接成功\n    void onConnect();\n    \n    // 断开连接\n    void onDisconnect();\n\n    // 重连成功\n    void onReconnect();\n    \n    // 收到消息\n    void onMsg(String msg);\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["然后，再实现",(0,s.jsx)(e.code,{children:"SocketEngine"}),"的逻辑："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"class SocketEngine {\n    private List<SocketActionObserver> socketActionObservers = new ArrayList();\n\n    // 添加观察者\n    public void addObserver(SocketActionObserver observer) {\n        //...\n    }\n    \n    // 移除观察者\n    public void rmObserver(SocketActionObserver observer) {\n        //...\n    }\n    \n\n    // 接收到服务器的消息\n    void onMessage(String msg) {\n        // 分发到观察者里面去\n        for(SocketActionObserver observer : socketActionObservers) {\n            observer.onMsg(msg);\n        }\n    }\n    \n    //...\n\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["最后，我们需要观察",(0,s.jsx)(e.code,{children:"Socket"}),"的消息行为："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"class BaseRoomContextImpl {\n    // 这个用来发送长链接消息，我们假设用的是socket\n    private SocketEngine socketEngine = new SocketEngine();\n    \n    // 定义一个Socket观测器\n    private SocketActionObserver sicketActionObserver = new SocketActionObserver {\n        void onMsg(String msg) {\n            // 我们假设msg是个json，那么，这里就应该在IO线程中解析json，然后在UI线程中分发\n            withIO() {\n                // .....解析数据\n                withUI() {\n                   // ....分发数据，分发到我们上面定义的IBaseRoomObserver里面去。 \n                }\n            }\n            \n        }\n        \n        // ...\n    }\n    \n    // 在构造函数里面开始注册观察者\n    void BaseRoomContextImpl {\n       // ...初始化数据\n       \n       // 注册观察者\n       socketEngine.addObserver(sicketActionObserver);\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"懵逼吗？有点。"}),"\n",(0,s.jsx)(e.p,{children:"好，我们来整理下逻辑："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["我们定义了",(0,s.jsx)(e.code,{children:"BaseRoomContextImpl"}),"，用来实现房间的基础逻辑。"]}),"\n",(0,s.jsxs)(e.li,{children:["我们定义了",(0,s.jsx)(e.code,{children:"SocketEngine"}),"，用来向服务器发数据和接收服务器数据。"]}),"\n",(0,s.jsxs)(e.li,{children:["我们定义了",(0,s.jsx)(e.code,{children:"SocketActionObserver"}),"，来让",(0,s.jsx)(e.code,{children:"BaseRoomContextImpl"}),"观察",(0,s.jsx)(e.code,{children:"SocketEngine"}),"，以此将数据从",(0,s.jsx)(e.code,{children:"SocketEngine"}),"传送到",(0,s.jsx)(e.code,{children:"BaseRoomContextImpl"}),"中。"]}),"\n",(0,s.jsxs)(e.li,{children:["我们定义了",(0,s.jsx)(e.code,{children:"IBaseRoomObserver"}),"，用来将",(0,s.jsx)(e.code,{children:"BaseRoomContextImpl"}),"中解析过的数据进行分发，分发给谁呢？肯定是 UI 了。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["所以，我们的数据流向现在明白了，就是：\n",(0,s.jsx)(e.code,{children:"服务器 -> SocketEngine的onMessage() -> SocketActionObserver(观察者) -> BaseRoomContextImpl(解析) -> IBaseRoomObserver(观察者) -> UI"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"可以看到，我们的目标就是：让服务器数据传送到 UI 上，UI 来进行绘制，以便让用户看到。"}),"\n",(0,s.jsx)(e.p,{children:"那么，数据怎么分发到 UI 上呢？"}),"\n",(0,s.jsx)(e.p,{children:"用户有很多行为，比如：发消息、送礼物、上座下座等，你怎么区分呢？"}),"\n",(0,s.jsx)(e.p,{children:"所以，我们需要定义一个类型来区分这些行为。"}),"\n",(0,s.jsx)(e.p,{children:"好，上类型，我们用枚举定义："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"enum ActionType {\n    // 构造函数，传递一个code，跟服务器商量好的code\n    ActionType(int code) {}\n    \n    // 发消息\n    SEND_MSG(0x0001),\n    // 送礼物\n    SEND_GIFT(0x0002),\n    // 上座位\n    UP_SEAT(0x0003),\n    // 下座位\n    DOWN_SEAT(0x0004);\n    // ... 其他\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"好，定义好了类型，我们就要定义对应的解析对象了，我们定义上述四个解析对象如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// 收到消息\nclass OnReceiveMsgBean {\n    String msg;\n    long fromUID;\n    long msgTime;\n}\n\n// 收到礼物\nclass OnReceiveGiftBean {\n    Gift gift;\n    int fromUID;\n    long toUID;\n}\n\n// 上座\nclass OnUpSeatBean {\n    long uid;\n    int toPosition;\n    int oldPosition;\n}\n\n// 下座\nclass OnDownSeatBean {\n    long uid;\n    int oldPosition;\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["那么接下来，我们就开始解析并分发我们的数据了，我们来重写下",(0,s.jsx)(e.code,{children:"BaseRoomContextImpl"}),"里面的",(0,s.jsx)(e.code,{children:"SocketActionObserver"}),"："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:'class BaseRoomContextImpl {\n    // 定义一个Socket观测器\n    private SocketActionObserver socketActionObserver = new SocketActionObserver {\n        void onMsg(String msg) {\n            // 我们假设msg是个json，那么，这里就应该在IO线程中解析json，然后在UI线程中分发\n            withIO() {\n                // 解析数据\n                int code = msg.getInt("code")\n                String json = msg.getString("data");\n                // 根据type选择不同的对象去解析\n                switch(code) {\n                    case ActionType.SEND_MSG.code: {\n                         // 发消息的，就用消息实体去解析\n                         OnReceiveMsgBean bean = JsonUtil.parseToBean(msg, OnReceiveMsgBean.class);\n                         // 分发到UI\n                         withUI(){\n                             for(IBaseRoomObserver observer : observers) {\n                                 // 这里传递整个消息实体\n                                 observer.onReceiveMsg(bean);\n                             }\n                         }\n                    }\n                    \n                    case ActionType.SEND_GIFT.code: {\n                         // 发消息的，就用消息实体去解析\n                         OnReceiveGiftBean bean = JsonUtil.parseToBean(msg, OnReceiveGiftBean.class);\n                         // 分发到UI\n                         withUI(){\n                             for(IBaseRoomObserver observer : observers) {\n                                 // 这里传递整个消息实体\n                                 observer.onRecvGift(bean);\n                             }\n                         }\n                    }\n                    \n                    // ... 其他类型\n                }\n            }\n        }\n        \n        // ...\n    }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["好，现在，我们的消息分发解决了，但是你看这大量的",(0,s.jsx)(e.code,{children:"switch-case"}),"，屎一样的代码，是可忍孰不可忍？"]}),"\n",(0,s.jsxs)(e.p,{children:["我们之前的章节讲过代码优化啊，像这种",(0,s.jsx)(e.code,{children:"switch-case"}),"的，明显就是一个对应关系，既然是对应关系，那就可以用",(0,s.jsx)(e.code,{children:"map"}),"来优化，那",(0,s.jsx)(e.code,{children:"key"}),"不就是我们定义的枚举的 code 吗？",(0,s.jsx)(e.code,{children:"value"}),"不就是一个实体类型吗？"]}),"\n",(0,s.jsx)(e.p,{children:"是是是，这样是可以，但是～，这只是解析，你后面的分发，不是还得判断吗？你这样一改，大体代码如下："}),"\n",(0,s.jsx)(e.p,{children:"于是，代码就变成了这样："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:'class BaseRoomContextImpl {\n    // 用来处理socket消息的map\n    private Map<Int,Class> actionMap = new HashMap<>();\n    \n    // 然后需要在构造器中，初始化这个map\n    void BaseRoomContextImpl {\n        actionMap.put(ActionType.SEND_MSG.code, OnReceiveMsgBean.class)\n        actionMap.put(ActionType.SEND_GIFT.code, OnReceiveGiftBean.class)\n        // ...其他\n    }\n    \n\n    // 定义一个Socket观测器\n    private SocketActionObserver sicketActionObserver = new SocketActionObserver {\n        void onMsg(String msg) {\n            // 我们假设msg是个json，那么，这里就应该在IO线程中解析json，然后在UI线程中分发\n            withIO() {\n                // 解析数据\n                int code = msg.getInt("code")\n                String json = msg.getString("data");\n                switch(code) {\n                    case ActionType.SEND_MSG.code: {\n                         // 这里直接getCode了\n                         OnReceiveMsgBean bean = JsonUtil.parseToBean(msg, actionMap.get(code));\n                         // 分发到UI\n                         withUI(){\n                             for(IBaseRoomObserver observer : observers) {\n                                 // 这里传递整个消息实体\n                                 observer.onReceiveMsg(bean);\n                             }\n                         }\n                    }\n                    \n                    // ... 其他类型\n                }\n            }\n        }\n        \n        // ...\n    }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["你看这，一点意义都没有啊，并没有节省代码，因为你虽然根据",(0,s.jsx)(e.code,{children:"code"}),"知道了是哪个解析对象，但是你不知道要走哪个分发函数，所以，还需要让",(0,s.jsx)(e.code,{children:"code"}),"跟",(0,s.jsx)(e.strong,{children:"分发函数"}),"对应上。"]}),"\n",(0,s.jsxs)(e.p,{children:["既然如此，那不如这样：我直接将",(0,s.jsx)(e.code,{children:"code"}),"作为",(0,s.jsx)(e.code,{children:"key"}),"，将",(0,s.jsx)(e.code,{children:"code"}),"对应的一套逻辑（也就是 switch）的分支，整体作为 value。没错！就该如此！"]}),"\n",(0,s.jsxs)(e.p,{children:["好，我们定义一个",(0,s.jsx)(e.code,{children:"Action"}),"如下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"interface Action {\n    void action(String json);\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"然后修改上述代码如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'class BaseRoomContextImpl {\n    // 用来处理socket消息的map\n    private Map<Int,Action> actionMap = new HashMap<>();\n    \n    // 然后需要在构造器中，初始化这个map\n    void BaseRoomContextImpl {\n        // 发消息的逻辑处理\n        actionMap.put(ActionType.SEND_MSG.code, Action { json->\n            // 在IO线程中解析，下发的时候，调用方已经直接切换收到IO线程了\n            OnReceiveMsgBean bean = JsonUtil.parseToBean(json, OnReceiveMsgBean.class);\n            // 在UI线程中分发\n            withUI() {\n                for(IBaseRoomObserver observer : observers) {\n                     // 这里传递整个消息实体\n                     observer.onReceiveMsg(bean);\n                 }\n            }\n        })\n        \n        // 送礼的逻辑处理\n        actionMap.put(ActionType.SEND_GIFT.code, Action { json-> \n            OnReceiveGiftBean bean = JsonUtil.parseToBean(msg, OnReceiveGiftBean.class);\n            withUI() {\n                for(IBaseRoomObserver observer : observers) {\n                    observer.onRecvGift(bean);\n               }\n            }\n        })\n        \n        // ...其他\n        \n    }\n    \n\n    // 定义一个Socket观测器\n    private SocketActionObserver sicketActionObserver = new SocketActionObserver {\n        void onMsg(String msg) {\n            // 我们假设msg是个json，那么，这里就应该在IO线程中解析json，然后在UI线程中分发\n            withIO() {\n                // 解析数据\n                int code = msg.getInt("code")\n                String json = msg.getString("data");\n                // 已经在IO线程了，直接分发即可\n                actionMap.get(code).action(json);\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["你看你看，上述的观察者好简单啊，就是获取",(0,s.jsx)(e.code,{children:"code"}),"和",(0,s.jsx)(e.code,{children:"json"}),"然后在",(0,s.jsx)(e.code,{children:"actionMap"}),"找到对应的执行者，neng 一下就完事了，将来新加其他类型的消息，它也不用动，简直美滋滋。"]}),"\n",(0,s.jsxs)(e.p,{children:["将来新加消息怎么办呢？直接在",(0,s.jsx)(e.code,{children:"actionMap"}),"新加一个",(0,s.jsx)(e.code,{children:"key-value"}),"就行，完全符合",(0,s.jsx)(e.code,{children:"OCP"}),"原则。"]}),"\n",(0,s.jsxs)(e.h2,{id:"语音逻辑的实现",children:["语音逻辑的实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#语音逻辑的实现",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"语音逻辑就相对简单了，不过我们还是要设计一下，进行二次包装，因为大部分语音 SDK 都是用的第三方的，万一将来要替换，我们二次包装的威力就出来了，因为顶层逻辑不用动啊。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// 单纯的语音直播间功能\ninterface IAudioEngine { \n\n    // 进入语音流 \n    void enterVoice();\n\n    // 退出语音流 \n    void exitVoice();\n\n    // 打开麦克风 \n    void openMic();\n\n    // 关闭麦克风\n    void closeMic();\n\n    // 打开扬声器 \n    void openSpeaker();\n\n    // 关闭扬声器\n    void closeSpeaker(); \n}\n"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"class AudioEngineManager implements IAudioEngine {\n    // 这是第三方的语音SDK\n    private AudioEngine audioEngine;\n    \n    void enterVoice() {\n        audioEngine.enterVoice();\n    }\n    \n    //...其他逻辑\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["很简单，核心就一个：",(0,s.jsx)(e.strong,{children:"我们二次包装一下第三方的 SDK"}),"，顶层使用我们包装过的即可，这样，将来如果要改变第三方的 SDK，我们直接替换",(0,s.jsx)(e.code,{children:"AudioEngineManager"}),"里面的",(0,s.jsx)(e.code,{children:"AudioEngine"}),"即可，顶层逻辑不需要变动，这也是为了",(0,s.jsx)(e.code,{children:"OCP"}),"原则而设计。"]}),"\n",(0,s.jsxs)(e.h2,{id:"语音聊天室的最终实现",children:["语音聊天室的最终实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#语音聊天室的最终实现",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"我们的房间基础功能实现了，并且也实现了语音模块，根据上一章的内容我们知道，语音聊天室就是集成了这两块功能。"}),"\n",(0,s.jsx)(e.p,{children:"我们需要先来修改下我们的语音房接口，需要添加对语音功能的观测行为："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// 语音房也需要添加自己的观察者，以此来观察跟语音相关的内容\ninterface IVoiceRoomContext {\n    void addObserver(IVoiceRoomObserver observer);\n    void rmObserver(IVoiceRoomObserver observer);\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["而我们知道，语音房的行为肯定比基础房间多，那么它的可观测行为就比基础房间多，因为包含了基础房间的行为，所以我们可以让",(0,s.jsx)(e.code,{children:"IVoiceRoomObserver"}),"实现",(0,s.jsx)(e.code,{children:"IBaseRoomObserver"}),"："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"interface IVoiceRoomObserver extends IBaseRoomObserver {\n    void onOpenMic();\n    \n    void onCloseMic();\n    \n    void onOpenSpeaker();\n    \n    void onCloseSpeaker();\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["然后，我们就可以实现",(0,s.jsx)(e.code,{children:"VoiceRoomContextImpl"}),"了，代码如下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"class VoiceRoomContextImpl extends BaseRoomContextImpl implements IVoiceRoomContext {\n\n    // 语音房间的观测器\n    private List<IVoiceRoomObserver> voiceRoomObservers = new ArrayList<>();\n\n    // 处理语音逻辑\n    private IAudioEngine audioEngineManager;\n\n    public VoiceRoomContextImpl() {\n        super();\n        this.audioEngineManager = new AudioEngineManager();\n    }\n\n    @Override\n    public void addObserver(IVoiceRoomObserver observer) {\n        // 添加到父类中\n        super.addObserver(observer);\n        // 添加到自身\n        if(!voiceRoomObservers.contains(observer)) {\n            voiceRoomObservers.add(observer);\n        }\n    }\n\n    @Override\n    public void rmObserver(IVoiceRoomObserver observer) {\n        // 从父类移除\n        super.rmObserver(observer);\n        // 从自身移除\n        voiceRoomObservers.remove(observer);\n    }\n\n    @Override\n    public void enterVoice() {\n        audioEngineManager.enterVoice();\n    }\n\n    @Override\n    public void exitVoice() {\n        audioEngineManager.exitVoice();\n    }\n\n    @Override\n    public void openMic() {\n        audioEngineManager.openMic();\n    }\n\n    @Override\n    public void closeMic() {\n        audioEngineManager.closeMic();\n    }\n\n    @Override\n    public void openSpeaker() {\n        audioEngineManager.openSpeaker();\n    }\n\n    @Override\n    public void closeSpeaker() {\n        audioEngineManager.closeSpeaker();\n    }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["可以看到，我们的语音房是一个",(0,s.jsx)(e.strong,{children:"实现了语音功能的基础房间"}),"，因为它继承了",(0,s.jsx)(e.code,{children:"BaseRoomContextImpl"}),"，说明是个房间，而又实现了",(0,s.jsx)(e.code,{children:"IAudioEngine"}),"接口，说明集成了语音功能。"]}),"\n",(0,s.jsxs)(e.p,{children:["那为啥不是继承",(0,s.jsx)(e.code,{children:"AudioEngineManager"}),"而实现",(0,s.jsx)(e.code,{children:"IBaseRoomContext"}),"呢？"]}),"\n",(0,s.jsx)(e.p,{children:"语音房，语音房，你品，你仔细品，语音房是个偏正短语，主体是房间，什么房间？有语音功能的房间。而不是有房间功能的语音。"}),"\n",(0,s.jsxs)(e.p,{children:["所以，就应该继承",(0,s.jsx)(e.code,{children:"BaseRoomContextImpl"}),"实现",(0,s.jsx)(e.code,{children:"IAudioEngine"}),"。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"继承表示是什么，实现表示有什么功能。"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["有人说，你这样的话，",(0,s.jsx)(e.code,{children:"VoiceRoomContext"}),"不就有了两个添加观察者的方法了吗？"]}),"\n",(0,s.jsx)(e.p,{children:"没错！"}),"\n",(0,s.jsx)(e.p,{children:"这样的话，不就会重复了吗？"}),"\n",(0,s.jsx)(e.p,{children:"不会！因为子类和父类都做了去重判断。"}),"\n",(0,s.jsxs)(e.p,{children:["那也不对啊，你这子类的",(0,s.jsx)(e.code,{children:"voiceRoomObservers"}),"和父类的",(0,s.jsx)(e.code,{children:"observers"}),"都添加了，那不就执行两次了吗？"]}),"\n",(0,s.jsxs)(e.p,{children:["不会！因为分发的时候，只有语音逻辑才会走",(0,s.jsx)(e.code,{children:"voiceRoomObservers"}),"，非语音逻辑就走",(0,s.jsx)(e.code,{children:"observers"}),"，所以没问题。这个就需要在分发时注意了，不要做无谓的重复操作。"]}),"\n",(0,s.jsx)(e.p,{children:"接下来，我们来看下我们的主页面要怎么实现："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// 主页面\nclass VoiceRoomPage {\n    protected IVoiceRoomContext voiceRoomContext;\n    \n    private List<VoiceRoomPanel> panels = new ArrayList();\n    \n    public void init() {\n        // 获取语音房上下文数据\n        this.voiceRoomContext = App.get().getModuleContext(ModuleType.VOICE_ROOM);\n        \n        // 进入语音流\n        this.voiceRoomContext.enterVoice();\n        \n        // 初始化房间组件\n        panels.add(new TitlePanel(voiceRoomContext));\n        panels.add(new SeatPanel(voiceRoomContext));\n        panels.add(new MsgPanel(voiceRoomContext));\n        panels.add(new OptionPanel(voiceRoomContext));\n        \n        // 注册观察者\n        this.voiceRoomContext.addObserver(roomMainObserver);\n    }\n    \n    // 观测房间行为\n    private IVoiceRoomObserver roomMainObserver = new IVoiceRoomObserver() {\n        // ... 处理对应逻辑\n    }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["接下来我们看下消息栏",(0,s.jsx)(e.code,{children:"MsgPanel"}),"："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"class MsgPanel extends VoiceRoomPanel{\n\n    public void init() { \n         // 初始化UI\n         initUI(this.voiceRoomContext)\n         \n         // 添加观察者\n         this.voiceRoomContext.addObserver(roomMainObserver);\n         \n         // 点击就发消息\n         this.sendButton.setOnClick { \n             String msg = this.textView.text;\n             this.voiceRoomContext.sendMsg(msg) \n         }\n    }\n    \n    // 观测房间行为，服务器发送的消息都会在这里收到，并且是已解析过的\n    private IVoiceRoomObserver roomMsgObserver = new IVoiceRoomObserver() {\n        // 只需要处理消息逻辑\n        public void onReceiveMsg(OnReceiveMsgBean bean) {\n            // 将消息添加到UI上\n            msgList.add(msg);\n        }\n    }\n    \n    public void onDestroy() {\n        // UI销毁就移除观察者\n        this.voiceRoomContext.rmObserver(roomMainObserver);\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"其他逻辑都跟消息栏逻辑一样，每一个模块都注册个观测器，然后只处理自己关心的逻辑，这不就是宏观的最小知识原则吗？"}),"\n",(0,s.jsx)(e.p,{children:"有人说，这不对啊，你这观察者是个接口，得所有方法都实现出来。"}),"\n",(0,s.jsx)(e.p,{children:"没错，你可以写个抽象类，默认实现了这个观察者接口，添加观察者的时候，直接创建这个抽象类即可。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"abstract class LightVoiceRoomObserver implements IVoiceRoomObserver {\n    @Override\n    public void onReceiveMsg(OnReceiveMsgBean bean) {\n\n    }\n\n    // ... 其他方法的默认实现\n\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["然后，将上述的",(0,s.jsx)(e.code,{children:"IVoiceRoomObserver"}),"替换为",(0,s.jsx)(e.code,{children:"LightVoiceRoomObserver"}),"即可。"]}),"\n",(0,s.jsx)(e.p,{children:"最后，我们的礼物模块是跟语音模块类似的，一定是独立的，不依赖于语音房，而是被语音房依赖，这样才能复用，这里就不废话了。"}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"本章代码比较多，大家可以仔细体会一下，理解一下其中的逻辑思想，尤其是持有和被持有、依赖和被依赖的关系。"}),"\n",(0,s.jsx)(e.p,{children:"我们再来回顾一下我们的整体代码流程："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["在 App 层面，我们收到服务器消息，就创建出房间上下文",(0,s.jsx)(e.code,{children:"VoiceRoomContext"}),"。"]}),"\n",(0,s.jsxs)(e.li,{children:["我们的",(0,s.jsx)(e.code,{children:"VoiceRoomContext"}),"被创建出来，就会自动创建出语音引擎",(0,s.jsx)(e.code,{children:"AudioEngine"}),"，并且进入语音流。此时其实已经进入房间了，只不过我们的 UI 还不可见。"]}),"\n",(0,s.jsxs)(e.li,{children:["然后我们启动我们的 UI 页面，用上一步创建出来的",(0,s.jsx)(e.code,{children:"VoiceRoomContext"}),"初始化我们的页面，并且初始化房间各个 UI 模块。"]}),"\n",(0,s.jsxs)(e.li,{children:["各个 UI 模块也依次使用",(0,s.jsx)(e.code,{children:"VoiceRoomContext"}),"初始化数据，然后就向",(0,s.jsx)(e.code,{children:"VoiceRoomContext"}),"注册自己创建的观察者，开启后续的各个房间行为的监听。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"由于我们的房间是语音房，带有语音功能的房间，所以我们继承了房间类，实现了语音接口。"}),"\n",(0,s.jsx)(e.p,{children:"由于我们考虑到了拓展性，所以对房间进行了分层，将非语音功能都分到了房间基础层。"}),"\n",(0,s.jsxs)(e.p,{children:["我们使用了两层观察者模式，第一是",(0,s.jsx)(e.code,{children:"RoomContext"}),"对",(0,s.jsx)(e.code,{children:"Socket"}),"的观察，第二是",(0,s.jsx)(e.code,{children:"UI"}),"对",(0,s.jsx)(e.code,{children:"RoomContext"}),"的观察。这两层观察的目的是不同的，前者是为了找到房间的数据，并进行解析；后者是为了找到对自己有用的数据，并刷新 UI。"]}),"\n",(0,s.jsx)(e.p,{children:"那么，下一章，我们就来做一下收尾工作，来看下我们代码中做的不好的地方，以及做的好的地方。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(r,{...n})}):r(n)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC28%E7%AB%A0%E2%80%94%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91.md"]={toc:[{text:"基础房间逻辑的实现",id:"基础房间逻辑的实现",depth:2},{text:"语音逻辑的实现",id:"语音逻辑的实现",depth:2},{text:"语音聊天室的最终实现",id:"语音聊天室的最终实现",depth:2},{text:"总结",id:"总结",depth:2}],title:"第28章—详细设计：开始实现业务逻辑",headingTitle:"第28章—详细设计：开始实现业务逻辑",frontmatter:{}}}}]);