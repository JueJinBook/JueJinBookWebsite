"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["52182"],{371604:function(n,e,s){s.r(e),s.d(e,{default:()=>a});var o=s(552676),i=s(740453);let r=s.p+"static/image/8e8442cca30a233b3ec63a7c04f8430d.b0bc3068.webp";function t(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",h3:"h3",img:"img"},(0,i.ah)(),n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.h1,{id:"9-文章生成器如何用-process-实现带参命令",children:["9 文章生成器：如何用 process 实现带参命令？",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#9-文章生成器如何用-process-实现带参命令",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"在上一节课，我们完成了文章生成和保存的功能，但是我们现在还不能自定义文章的标题，也不能配置文章的字数。那在这一节课，我们就来学习通过命令行交互配置标题和字数，自由生成我们想要的文章。"}),"\n",(0,o.jsxs)(e.h2,{id:"使用-processargv-传参",children:["使用 process.argv 传参",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-processargv-传参",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"在第 1 节课里，我们已经见过使用 process.argv 传参的例子。这里我们依然可以使用这个老办法，不过现在不只传一个参数，而是要传入多个参数，所以要比第 1 节课的使用复杂一些。我们先自定义几个参数："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"--title 标题 ： 表示传入的主题\n--min 最小字数： 表示文章最小字数，默认值6000\n--max 最大字数： 表示文章最大字数，默认值10000\n"})}),"\n",(0,o.jsx)(e.p,{children:"我们可以通过将 process.argv 数组遍历出来的方式获取参数："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"function parseOptions(options = {}) {\n  const argv = process.argv;\n  for(let i = 2; i < argv.length; i++) {\n    const cmd = argv[i - 1];\n    const value = argv[i];\n    if(cmd === '--title') {\n      options.title = value;\n    } else if(cmd === '--min') {\n      options.min = Number(value);\n    } else if(cmd === '--max') {\n      options.max = Number(value);\n    }\n  }\n  return options;\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["上面的代码，依次判断",(0,o.jsx)(e.code,{children:"process.argv"}),"的值，如果我们先读取到",(0,o.jsx)(e.code,{children:"--title"}),"，那么它后面紧跟着的参数即是我们要的文章主题。同样，我们读取到",(0,o.jsx)(e.code,{children:"--min"}),"和",(0,o.jsx)(e.code,{children:"--max"}),"，那么将它们后面的参数作为最小字数/最大字数取出。"]}),"\n",(0,o.jsx)(e.p,{children:"这样，我们就可以读取命令行中的参数了，然后稍微改一下调用方式："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"const corpus = loadCorpus('corpus/data.json');\nconst options = parseOptions();\nconst title = options.title || createRandomPicker(corpus.title)();\nconst article = generate(title, {corpus, ...options});\nconst output = saveToFile(title, article);\n\nconsole.log(`生成成功！文章保存于：${output}`);\n"})}),"\n",(0,o.jsx)(e.p,{children:"这样就可以选择标题、控制字数了。虽然我们完成了功能，却并不完美，因为这样做不能控制用户输入的错误。如果我们传入一个未定义的参数，或者参数重复，程序都不会报错。比如下面的命令行："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"$ node index.js --min 100 --min 200 --foo bar --title\n"})}),"\n",(0,o.jsxs)(e.h3,{id:"检查用户输入",children:["检查用户输入",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#检查用户输入",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["因为 Node.js 内置的 process 模块无法方便地检查用户的输入，所以我们需要使用三方库 ",(0,o.jsx)(e.a,{href:"https://github.com/75lb/command-line-args",target:"_blank",rel:"noopener noreferrer",children:"command-line-args "})," 替代 process.argv，它不仅能获得用户的输入，还能检测用户的输入是否正确。"]}),"\n",(0,o.jsx)(e.p,{children:"首先，我们在项目中安装这个包："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"$ npm install command-line-args --save\n"})}),"\n",(0,o.jsx)(e.p,{children:"然后，通过如下操作引入这个模块。"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import commandLineArgs from 'command-line-args';\n"})}),"\n",(0,o.jsxs)(e.p,{children:["其中，",(0,o.jsx)(e.code,{children:"command-line-args"}),"是基于配置的，我们可以配置要传的参数："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// 配置我们的命令行参数\nconst optionDefinitions = [\n  {name: 'title', alias: 't', type: String},\n  {name: 'min', type: Number},\n  {name: 'max', type: Number},\n];\nconst options = commandLineArgs(optionDefinitions); // 获取命令行的输入\n"})}),"\n",(0,o.jsxs)(e.p,{children:["然后，将我们的",(0,o.jsx)(e.code,{children:"index.js"}),"修改如下："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"const corpus = loadCorpus('corpus/data.json');\nconst optionDefinitions = [\n  {name: 'title', type: String},\n  {name: 'min', type: Number},\n  {name: 'max', type: Number},\n];\nconst options = commandLineArgs(optionDefinitions);\nconst title = options.title || createRandomPicker(corpus.title)();\nconst article = generate(title, {corpus, ...options});\nconst output = saveToFile(title, article);\n\nconsole.log(`生成成功！文章保存于：${output}`);\n"})}),"\n",(0,o.jsx)(e.p,{children:"这样，如果我们传入重复的参数或者传入错误的参数，命令行都会报错："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"$ node index.js --foo bar\n\nUNKNOWN_OPTION: Unknown option: --foo\n    at commandLineArgs (/Users/akirawu/Workspace/junyux/monkey_generator/node_modules/command-line-args/dist/index.js:1347:21)\n    at file:///Users/akirawu/Workspace/junyux/monkey_generator/index.js:38:17\n    at ModuleJob.run (internal/modules/esm/module_job.js:110:37)\n    at async Loader.import (internal/modules/esm/loader.js:167:24) {\n  name: 'UNKNOWN_OPTION',\n  optionName: '--foo'\n"})}),"\n",(0,o.jsx)(e.p,{children:"如上面代码所示，因为 --foo 不是合法的参数，所以控制台报错。"}),"\n",(0,o.jsxs)(e.p,{children:["为了让我们的应用更加友好，我们还可以添加一个",(0,o.jsx)(e.code,{children:"--help"}),"参数，告知用户有哪些合法的参数以及每个参数的意义。这个功能可以通过第三方库 ",(0,o.jsx)(e.a,{href:"https://github.com/75lb/command-line-usage",target:"_blank",rel:"noopener noreferrer",children:"command-line-usage"})," 来完成。"]}),"\n",(0,o.jsx)(e.p,{children:"同样，我们先安装 command-line-usage 包："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"$ npm install command-line-usage --save\n"})}),"\n",(0,o.jsx)(e.p,{children:"然后，我们使用它定义 help 输出的内容，这是一份 JSON 配置："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import commandLineUsage from 'command-line-usage';\n\n// 定义帮助的内容\nconst sections = [\n  {\n    header: '狗屁不通文章生成器',\n    content: '生成随机的文章段落用于测试',\n  },\n  {\n    header: 'Options',\n    optionList: [\n      {\n        name: 'title',\n        typeLabel: '{underline string}',\n        description: '文章的主题。',\n      },\n      {\n        name: 'min',\n        typeLabel: '{underline number}',\n        description: '文章最小字数。',\n      },\n      {\n        name: 'max',\n        typeLabel: '{underline number}',\n        description: '文章最大字数。',\n      },\n    ],\n  },\n];\nconst usage = commandLineUsage(sections); // 生成帮助文本\n"})}),"\n",(0,o.jsxs)(e.p,{children:["然后，我们在",(0,o.jsx)(e.code,{children:"command-line-args"}),"中添加一下",(0,o.jsx)(e.code,{children:"--help"}),"命令的配置："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"const corpus = loadCorpus('corpus/data.json');\nconst optionDefinitions = [\n  {name: 'help'}, // help命令配置\n  {name: 'title', type: String},\n  {name: 'min', type: Number},\n  {name: 'max', type: Number},\n];\nconst options = commandLineArgs(optionDefinitions);\nif('help' in options) { // 如果输入的是help，就打印帮助文本\n  console.log(usage);\n} else {\n  const title = options.title || createRandomPicker(corpus.title)();\n  const article = generate(title, {corpus, ...options});\n  const output = saveCorpus(title, article);\n\n  console.log(`生成成功！文章保存于：${output}`);\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["我们判断命令中如果有",(0,o.jsx)(e.code,{children:"--help"}),"那么就打印使用帮助，否则就输出文章。那么运行",(0,o.jsx)(e.code,{children:"node index.js --help"}),"实际效果如下图所示："]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:r,alt:""})}),"\n",(0,o.jsx)(e.p,{children:"现在，我们命令行交互就全部完成了。"}),"\n",(0,o.jsxs)(e.h2,{id:"规划模块",children:["规划模块",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#规划模块",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"现在来看，index.js 文件的内容有点多，功能上也比较杂，有加载文件和保存文件，有命令行配置、接收和判断，有生成文章功能等等。这显然不符合良好的程序设计，所以我们打算按照功能，重新规划我们的模块。"}),"\n",(0,o.jsxs)(e.p,{children:["第一步，将加载和保存文件功能（即：loadCorpus和saveCorpus）统一放置在",(0,o.jsx)(e.code,{children:"./lib/corpus.js"}),"模块中："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// lib/corpus.js\nimport {readFileSync, writeFileSync, existsSync, mkdirSync} from 'fs';\nimport {fileURLToPath} from 'url';\nimport {dirname, resolve} from 'path';\nimport moment from 'moment';\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nexport function loadCorpus(src) {\n  const path = resolve(__dirname, '..', src);\n  const data = readFileSync(path, {encoding: 'utf-8'});\n  return JSON.parse(data);\n}\n\nexport function saveCorpus(title, article) {\n  const outputDir = resolve(__dirname, '..', 'output');\n  const time = moment().format('|YYYY-MM-DD|HH:mm:ss');\n  const outputFile = resolve(outputDir, `${title}${time}.txt`);\n\n  if(!existsSync(outputDir)) {\n    mkdirSync(outputDir);\n  }\n\n  const text = `${title}\\n\\n    ${article.join('\\n    ')}`;\n  writeFileSync(outputFile, text);\n\n  return outputFile;\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["注意，因为放到了 lib 目录下，path 与",(0,o.jsx)(e.code,{children:"corpus/data.json"}),"的相对路径有了变换，所以 resolve 的时候要到父目录：",(0,o.jsx)(e.code,{children:"const path = resolve(__dirname, '..', src);"}),"。"]}),"\n",(0,o.jsxs)(e.p,{children:["第二步，将与命令行相关的功能（即：commandLineArgs 和 commandLineUsage）归为",(0,o.jsx)(e.code,{children:"lib/cmd.js"}),"模块。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// lib/cmd.js\nimport commandLineArgs from 'command-line-args';\nimport commandLineUsage from 'command-line-usage';\n\nconst sections = [\n  {\n    header: '狗屁不通文章生成器',\n    content: '生成随机的文章段落用于测试',\n  },\n  {\n    header: 'Options',\n    optionList: [\n      {\n        name: 'title',\n        typeLabel: '{underline string}',\n        description: '文章的主题。',\n      },\n      {\n        name: 'min',\n        typeLabel: '{underline number}',\n        description: '文章最小字数。',\n      },\n      {\n        name: 'max',\n        typeLabel: '{underline number}',\n        description: '文章最大字数。',\n      },\n    ],\n  },\n];\n\nconst usage = commandLineUsage(sections); \n\nconst optionDefinitions = [\n  {name: 'help'},\n  {name: 'title', type: String},\n  {name: 'min', type: Number},\n  {name: 'max', type: Number},\n];\n\nconst options = commandLineArgs(optionDefinitions);\n\nif('help' in options) {\n  console.log(usage);\n  process.exit();\n}\n\nexport {options};\n"})}),"\n",(0,o.jsxs)(e.p,{children:["注意，我们之前在",(0,o.jsx)(e.code,{children:"index.js"}),"中通过 if 语句判断是否包含",(0,o.jsx)(e.code,{children:"--help"}),"参数，如果包含，则输出帮助信息，否则生成文章。现在我们把这部分代码移到",(0,o.jsx)(e.code,{children:"cmd.js"}),"模块中之后，就不需要在",(0,o.jsx)(e.code,{children:"index.js"}),"中用 if 判断，可以在",(0,o.jsx)(e.code,{children:"cmd.js"}),"模块中判断，如果存在",(0,o.jsx)(e.code,{children:"--help"}),"参数，那么输出帮助信息后直接结束命令。"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:"process.exit()"}),"表示终止程序。当用户输入 --help 后，为了阻止后续生成文章的代码运行，我们需要在这里手动的终止程序。在 Node.js 中结束命令行的运行，可以直接调用 process 模块的 exit 方法。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"process.exit();\n"})}),"\n",(0,o.jsx)(e.p,{children:"最后，index.js 文件就变得简单清晰多了！"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import {options} from './lib/cmd.js';\nimport {loadCorpus, saveCorpus} from './lib/corpus.js';\nimport {generate} from './lib/generator.js';\nimport {createRandomPicker} from './lib/random.js';\n\nconst corpus = loadCorpus('corpus/data.json');\nconst title = options.title || createRandomPicker(corpus.title)();\nconst article = generate(title, {corpus, ...options});\nconst output = saveCorpus(title, article);\n\nconsole.log(`生成成功！文章保存于：${output}`);\n"})}),"\n",(0,o.jsxs)(e.h2,{id:"总结",children:["总结",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"这一节课，我们学习了如何使用 process 模块实现带参数的命令行交互。为了让程序能检查、控制用户输入是否正确，以及打印命令行帮助文本，我们还学习了两个第三方库 command-line-args 和 command-line-usage。"}),"\n",(0,o.jsx)(e.p,{children:"此外，我们还可以进一步改进代码：当我们不传任何命令参数的时候，让程序以用户互动的方式运行。下一节课，我们将介绍如何用 process.stdin 实现互动式交互。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(t,{...n})}):t(n)}let a=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F9%20%E6%96%87%E7%AB%A0%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%20process%20%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%8F%82%E5%91%BD%E4%BB%A4%EF%BC%9F.md"]={toc:[{text:"使用 process.argv 传参",id:"使用-processargv-传参",depth:2},{text:"检查用户输入",id:"检查用户输入",depth:3},{text:"规划模块",id:"规划模块",depth:2},{text:"总结",id:"总结",depth:2}],title:"9 文章生成器：如何用 process 实现带参命令？",headingTitle:"9 文章生成器：如何用 process 实现带参命令？",frontmatter:{}}}}]);