"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["70974"],{230643:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r(552676),t=r(740453);let c=r.p+"static/image/0c38f63d8340ceb3874025c652698a78.515f8cbd.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",ul:"ul",li:"li",h3:"h3",img:"img",blockquote:"blockquote",strong:"strong"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"6响应式原理基于-proxy-的响应式是什么样的",children:["6.响应式原理：基于 Proxy 的响应式是什么样的？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6响应式原理基于-proxy-的响应式是什么样的",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本小节我们开启响应式原理的篇章，在开启这个篇章之前，我们先来了解一下 ",(0,s.jsx)(n.code,{children:"Vue3"})," 中一个基于 ",(0,s.jsx)(n.code,{children:"Composition API"})," 响应式应用的例子是如何编写的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>\n    {{ state.msg }} {{ count }}\n  </div>\n</template>\n<script>\n  import { reactive, ref } from 'vue'\n  export default {\n    setup() {\n      const state = reactive({\n        msg: 'hello world'\n      })\n      \n      const count = ref(0)\n      \n      const changeMsg = () => {\n        state.msg = 'world hello'\n      }\n\n      return {\n        state,\n        count,\n        changeMsg,\n      }\n    }\n  }\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此时我们通过 ",(0,s.jsx)(n.code,{children:"reactive API"})," 或者 ",(0,s.jsx)(n.code,{children:"ref API"})," 来定义响应式对象。"]}),"\n",(0,s.jsxs)(n.p,{children:["对于 ",(0,s.jsx)(n.code,{children:"reactive API"})," 而言，核心是用来定义集合类型的数据，比如：普通对象、数组和\xa0",(0,s.jsx)(n.code,{children:"Map"}),"、",(0,s.jsx)(n.code,{children:"Set"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["对于 ",(0,s.jsx)(n.code,{children:"ref API"})," 而言，可以用来对 ",(0,s.jsx)(n.code,{children:"string"}),"、",(0,s.jsx)(n.code,{children:"number"}),"、",(0,s.jsx)(n.code,{children:"boolean"})," 这些原始类型数据进行响应式定义。"]}),"\n",(0,s.jsxs)(n.p,{children:["关于二者使用上的更多区别和差异，小伙伴们可以直接参见 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 官网上",(0,s.jsx)(n.a,{href:"https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html",target:"_blank",rel:"noopener noreferrer",children:"《响应式基础》"}),"这个章节中的介绍。对于二者的核心实现原理，其实都是依托于 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 的响应式基础，本小节将以 ",(0,s.jsx)(n.code,{children:"reactive API"})," 作为切入点，核心分析 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 的响应式原理。"]}),"\n",(0,s.jsxs)(n.h2,{id:"reactive",children:["Reactive",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reactive",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["找到源码中关于 ",(0,s.jsx)(n.code,{children:"reactive"})," 部分的定义："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function reactive(target: object) {\n  // 不需要对 readonly 的对象进行响应式\n  if (isReadonly(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个函数核心也就是通过 ",(0,s.jsx)(n.code,{children:"createReactiveObject"})," 把我们传入的 ",(0,s.jsx)(n.code,{children:"target"})," 变成响应式的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  // 如果目标不是对象，则直接返回\n  if (!isObject(target)) {\n    return target\n  }\n  // 已经是一个响应式对象了，也直接返回\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // proxyMap 中已经存入过 target，直接返回\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // 只有特定类型的值才能被 observe.\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  // 通过 proxy 来构造一个响应式对象\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  // 缓存 target proxy\n  proxyMap.set(target, proxy)\n  return proxy\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述整个核心流程就是首先经过一系列判断，判断符合要求的 ",(0,s.jsx)(n.code,{children:"target"})," 才能被响应式，整理的判断包括了",(0,s.jsx)(n.code,{children:"target"})," 的类型、是否是响应式的、是否已经被定义过了，以及是否是符合要求的类型这些步骤，最后执行的是 ",(0,s.jsx)(n.code,{children:"new Proxy()"})," 这样的一个响应式代理 ",(0,s.jsx)(n.code,{children:"API"}),"。一起来看看这个 ",(0,s.jsx)(n.code,{children:"API"})," 的实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Proxy"})," 根据 ",(0,s.jsx)(n.code,{children:"targetType"})," 来确定执行的是 ",(0,s.jsx)(n.code,{children:"collectionHandlers"})," 还是 ",(0,s.jsx)(n.code,{children:"baseHandlers"}),"。那 ",(0,s.jsx)(n.code,{children:"targetType"})," 是什么时候确定的呢？可以看一下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const targetType = getTargetType(target)\n\nfunction getTargetType(value) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\nexport const toRawType = (value) => {\n  // toTypeString 转换成字符串的方式，比如 \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["因为 ",(0,s.jsx)(n.code,{children:"target"})," 传入进来的是一个 ",(0,s.jsx)(n.code,{children:"Object"}),"，所以 ",(0,s.jsx)(n.code,{children:"toRawType(value)"})," 得到的值是 ",(0,s.jsx)(n.code,{children:"Object"}),"。所以这里的 ",(0,s.jsx)(n.code,{children:"targetType"})," 的值等于 ",(0,s.jsx)(n.code,{children:"TargetType.COMMON"})," 也就是执行了 ",(0,s.jsx)(n.code,{children:"baseHandlers"})," 。而当我们的 ",(0,s.jsx)(n.code,{children:"reactive(target)"})," 中的 ",(0,s.jsx)(n.code,{children:"target"})," 是个 ",(0,s.jsx)(n.code,{children:"WeakMap"})," 或者 ",(0,s.jsx)(n.code,{children:"WeakSet"})," 时，那么执行的就是 ",(0,s.jsx)(n.code,{children:"collectionHandlers"})," 了。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来看一下 ",(0,s.jsx)(n.code,{children:"baseHandlers"})," 的实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"export const mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里就是 ",(0,s.jsx)(n.code,{children:"Proxy"})," 中的定义 ",(0,s.jsx)(n.code,{children:"handler"})," 的一些属性。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"get：属性读取操作的捕捉器。"}),"\n",(0,s.jsx)(n.li,{children:"set：属性设置操作的捕捉器。"}),"\n",(0,s.jsxs)(n.li,{children:["deleteProperty：",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete",target:"_blank",rel:"noopener noreferrer",children:"delete"}),"\xa0操作符的捕捉器。"]}),"\n",(0,s.jsxs)(n.li,{children:["has：",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in",target:"_blank",rel:"noopener noreferrer",children:"in"}),"\xa0操作符的捕捉器。"]}),"\n",(0,s.jsxs)(n.li,{children:["ownKeys：",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames",target:"_blank",rel:"noopener noreferrer",children:"Object.getOwnPropertyNames"}),"\xa0方法和\xa0",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols",target:"_blank",rel:"noopener noreferrer",children:"Object.getOwnPropertySymbols"}),"\xa0方法的捕捉器。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["而关于响应式核心的部分就在 ",(0,s.jsx)(n.code,{children:"set"})," 和 ",(0,s.jsx)(n.code,{children:"get"})," 中，我们一起来看一下二者的定义实现。"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-get",children:["1. get",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-get",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["其中 ",(0,s.jsx)(n.code,{children:"get"})," 的实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const get = /*#__PURE__*/ createGetter()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到核心其实通过 ",(0,s.jsx)(n.code,{children:"createGetter"})," 来实现的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    // 对 ReactiveFlags 的处理部分\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\n      return shallow\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n          ? shallowReactiveMap\n          : reactiveMap\n        ).get(target)\n    ) {\n      return target\n    }\n    \n    const targetIsArray = isArray(target)\n    if (!isReadonly) {\n      // 数组的特殊方法处理\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver)\n      }\n      // 对象 hasOwnProperty 方法处理\n      if (key === 'hasOwnProperty') {\n        return hasOwnProperty\n      }\n    }\n    // 取值\n    const res = Reflect.get(target, key, receiver)\n    \n    // Symbol Key 不做依赖收集\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n    \n    // 进行依赖收集\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n    \n    // 如果是浅层响应，那么直接返回，不需要递归了\n    if (shallow) {\n      return res\n    }\n    \n    \n    if (isRef(res)) {\n      // 跳过数组、整数 key 的展开\n      return targetIsArray && isIntegerKey(key) ? res : res.value\n    }\n\n    if (isObject(res)) {\n      // 如果 isReadonly 是 true，那么直接返回 readonly(res)\n      // 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res 变成响应式\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n\n    return res\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["因为调用 ",(0,s.jsx)(n.code,{children:"createGetter"})," 时，默认参数 ",(0,s.jsx)(n.code,{children:"isReadonly = false"}),"，所以这里可以先忽略 ",(0,s.jsx)(n.code,{children:"isReadonly"})," 的部分。整体而言，该函数还是比较通俗易懂的，首先对 ",(0,s.jsx)(n.code,{children:"key"})," 属于 ",(0,s.jsx)(n.code,{children:"ReactiveFlags"})," 的部分做了特殊处理，这也是为什么在 ",(0,s.jsx)(n.code,{children:"createReactiveObject"})," 函数中判断响应式对象是否存在 ",(0,s.jsx)(n.code,{children:"ReactiveFlags.RAW"})," 属性，如果存在就返回这个响应式对象本身。"]}),"\n",(0,s.jsxs)(n.p,{children:["然后当我们的 ",(0,s.jsx)(n.code,{children:"target"})," 是数组，且 ",(0,s.jsx)(n.code,{children:"key"})," 值存在 ",(0,s.jsx)(n.code,{children:"arrayInstrumentations"})," 中时，返回 ",(0,s.jsx)(n.code,{children:"arrayInstrumentations"})," 中对应的 ",(0,s.jsx)(n.code,{children:"key"})," 值。再来看看 ",(0,s.jsx)(n.code,{children:"arrayInstrumentations"})," 是个什么："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const arrayInstrumentations = createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  (['includes', 'indexOf', 'lastIndexOf']).forEach(key => {\n    instrumentations[key] = function (this, ...args) {\n      // toRaw 可以把响应式对象转成原始数据\n      const arr = toRaw(this)\n      \n      for (let i = 0, l = this.length; i < l; i++) {\n        // 对数组的每一项进行依赖收集\n        track(arr, TrackOpTypes.GET, i + '')\n      }\n      // 先尝试用参数本身，可能是响应式数据\n      const res = arr[key](...args)\n      if (res === -1 || res === false) {\n        // 如果失败，再尝试把参数转成原始数据\n        return arr[key](...args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      pauseTracking()\n      const res = (toRaw(this) as any)[key].apply(this, args)\n      resetTracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当",(0,s.jsx)(n.code,{children:"reactive"}),"函数传入数组时，",(0,s.jsx)(n.code,{children:"get"}),"捕获器会先在",(0,s.jsx)(n.code,{children:"arrayInstrumentations"}),"对象上查找，如果找不到，再在代理对象",(0,s.jsx)(n.code,{children:"target"}),"上查找。",(0,s.jsx)(n.code,{children:"arrayInstrumentations"}),"对象会重写两类函数，一类是查询类函数: ",(0,s.jsx)(n.code,{children:"includes"}),"、 ",(0,s.jsx)(n.code,{children:"indexOf"}),"、 ",(0,s.jsx)(n.code,{children:"lastIndexOf"}),"，代表对数组的读取操作。在这些函数中会执行",(0,s.jsx)(n.code,{children:"track"}),"函数，对数组上的索引和",(0,s.jsx)(n.code,{children:"length"}),"属性进行追踪。"]}),"\n",(0,s.jsxs)(n.p,{children:["一类是修改类函数",(0,s.jsx)(n.code,{children:"push"}),"、 ",(0,s.jsx)(n.code,{children:"pop"}),"、 ",(0,s.jsx)(n.code,{children:"shift"}),"、 ",(0,s.jsx)(n.code,{children:"unshift"}),"、 ",(0,s.jsx)(n.code,{children:"splice"}),"，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。关于这里的一些说明也可以参见 ",(0,s.jsx)(n.a,{href:"https://github.com/vuejs/core/issues/2137",target:"_blank",rel:"noopener noreferrer",children:"Vue issue"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["再回过头看 ",(0,s.jsx)(n.code,{children:"createGetter"})," 中，接下来的操作就是通过 ",(0,s.jsx)(n.code,{children:"track(target, TrackOpTypes.GET, key)"})," 进行依赖收集，我们再来一起看一下 ",(0,s.jsx)(n.code,{children:"track"})," 的实现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 是否应该收集依赖\nlet shouldTrack = true\n// 当前激活的 effect\nlet activeEffect\n// 存放所有 reactive 传入的 receiver 容器\nconst targetMap = new WeakMap()\n\nexport function track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n      depsMap.set(key, (dep = createDep()))\n    }\n\n    trackEffects(dep)\n  }\n}\n\n\nexport function trackEffects(\n  dep,\n  debuggerEventExtraInfo\n) {\n  // ...\n  if (shouldTrack) {\n    // 把 activeEffect 添加到 dep 中\n    dep.add(activeEffect!)\n    activeEffect!.deps.push(dep)\n  }\n}\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["我们创建了全局的 ",(0,s.jsx)(n.code,{children:"targetMap"})," ，它的键是 ",(0,s.jsx)(n.code,{children:"target"}),"，值是 ",(0,s.jsx)(n.code,{children:"depsMap"}),"；这个 ",(0,s.jsx)(n.code,{children:"depsMap"})," 的键是 ",(0,s.jsx)(n.code,{children:"target"})," 的 ",(0,s.jsx)(n.code,{children:"key"}),"，值是 ",(0,s.jsx)(n.code,{children:"dep"})," 集合，",(0,s.jsx)(n.code,{children:"dep"})," 集合中存储的是依赖的副作用函数 ",(0,s.jsx)(n.code,{children:"effect"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，关于 ",(0,s.jsx)(n.code,{children:"trackEffects"})," 的实现细节，我们后面的小节再详细介绍。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注意到 ",(0,s.jsx)(n.code,{children:"Proxy"})," 在访问对象属性时才递归执行劫持对象属性，相比 ",(0,s.jsx)(n.code,{children:"Object.defineProperty"})," 在定义时就遍历把所有层级的对象设置成响应式而言，在性能上有所提升。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-set",children:["2. set",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-set",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上面说完了 ",(0,s.jsx)(n.code,{children:"get"})," 的流程，我们了解了依赖收集后的数据结构存储在了 ",(0,s.jsx)(n.code,{children:"targetMap"})," 中，接下来我们接着看 ",(0,s.jsx)(n.code,{children:"set"})," 的过程："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const set = /*#__PURE__*/ createSetter()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到核心其实通过 ",(0,s.jsx)(n.code,{children:"createSetter"})," 来实现的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    let oldValue = target[key]\n    // 不是浅层响应式，这里默认是 false\n    if (!shallow) {\n      // 不是浅层响应式对象\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue)\n        value = toRaw(value)\n      }\n      // ...\n    } else {\n      // 在浅模式中，对象被设置为原始值，而不管是否是响应式\n    }\n\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n     // 如果目标的原型链也是一个 proxy，通过 Reflect.set 修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger 了\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到 ",(0,s.jsx)(n.code,{children:"set"})," 的核心逻辑是先根据是否是浅层响应式来确定原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行 ",(0,s.jsx)(n.code,{children:"toRaw"})," 转换，然后通过 ",(0,s.jsx)(n.code,{children:"Reflect.set"})," 设置值，最后通过 ",(0,s.jsx)(n.code,{children:"trigger"})," 函数派发通知 ，并依据 ",(0,s.jsx)(n.code,{children:"key"})," 是否存在于 ",(0,s.jsx)(n.code,{children:"target"})," 上来确定通知类型是 ",(0,s.jsx)(n.code,{children:"add"}),"（新增） 还是 ",(0,s.jsx)(n.code,{children:"set"}),"（修改）。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来核心就是 ",(0,s.jsx)(n.code,{children:"trigger"})," 的逻辑，是如何实现触发响应的:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function trigger(target,type,key,newValue,oldValue,oldTarget) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    return\n  }\n  let deps: (Dep | undefined)[] = []\n  if (type === TriggerOpTypes.CLEAR) {\n    deps = [...depsMap.values()]\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= toNumber(newValue)) {\n        deps.push(dep)\n      }\n    })\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key))\n    }\n\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get('length'))\n        }\n        break\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        break\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      triggerEffects(deps[0])\n    }\n  } else {\n    const effects: ReactiveEffect[] = []\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep)\n      }\n    }\n    triggerEffects(createDep(effects))\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"内容有点多，看起来有点头大，我们来简化一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function trigger(target, type, key) {\n  const dep = targetMap.get(target)\n  dep.get(key).forEach(effect => effect.run())\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["核心其实就是通过 ",(0,s.jsx)(n.code,{children:"target"})," 找到 ",(0,s.jsx)(n.code,{children:"targetMap"})," 中的 ",(0,s.jsx)(n.code,{children:"dep"}),"，再根据 ",(0,s.jsx)(n.code,{children:"key"})," 来找到所有的副作用函数 ",(0,s.jsx)(n.code,{children:"effect"})," 遍历执行。副作用函数就是上面 ",(0,s.jsx)(n.code,{children:"get"})," 收集起来的。"]}),"\n",(0,s.jsx)(n.p,{children:"这里有个有意思的地方是对数组的操作监听，我们来看一段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const state = reactive([]);\n\neffect(() => {\n  console.log(`state: ${state[1]}`)\n});\n\n// 不会触发 effect\nstate.push(0);\n\n// 触发 effect\nstate.push(1);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面的 ",(0,s.jsx)(n.code,{children:"demo"})," 中，我们第一次访问了 ",(0,s.jsx)(n.code,{children:"state[1]"}),"， 所以，对 ",(0,s.jsx)(n.code,{children:"state[1]"})," 进行了依赖收集，而第一次的 ",(0,s.jsx)(n.code,{children:"state.push(0)"})," 设置的是 ",(0,s.jsx)(n.code,{children:"state"})," 的第 ",(0,s.jsx)(n.code,{children:"0"})," 个元素，所以不会触发响应式更新。而第二次的 ",(0,s.jsx)(n.code,{children:"push"})," 触发了对 ",(0,s.jsx)(n.code,{children:"state[1]"})," 的更新。这看起来很合理，没啥问题。那么我们再来看另外一个示例："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 响应式数据\nconst state = reactive([])\n\n// 观测变化\neffect(() => console.log('state map: ', state.map(item => item))\n\nstate.push(1)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["按照常理来说，",(0,s.jsx)(n.code,{children:"state.map"})," 由于 ",(0,s.jsx)(n.code,{children:"state"})," 是个空数组，所以理论上不会对数组的每一项进行访问，所以 ",(0,s.jsx)(n.code,{children:"state.push(1)"})," 理论上也不会触发 ",(0,s.jsx)(n.code,{children:"effect"}),"。但实际上是会的，为什么呢？我们再来看一下一个 ",(0,s.jsx)(n.code,{children:"proxy"})," 的 ",(0,s.jsx)(n.code,{children:"demo"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const raw = []\nconst arr = new Proxy(raw, {\n  get(target, key) {\n    console.log('get', key)\n    return Reflect.get(target, key)\n  },\n  set(target, key, value) {\n    console.log('set', key)\n    return Reflect.set(target, key, value)\n  }\n})\n\narr.map(v => v)\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看到打印的内容如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"get map\nget length\nget constructor\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到 ",(0,s.jsx)(n.code,{children:"map"})," 函数的操作，会触发对数组的 ",(0,s.jsx)(n.code,{children:"length"})," 访问！这就有意思了，当访问数组 ",(0,s.jsx)(n.code,{children:"length"})," 的时候，我们进行了对 ",(0,s.jsx)(n.code,{children:"state"})," 的依赖收集，而数组的 ",(0,s.jsx)(n.code,{children:"push"})," 操作也会改变 ",(0,s.jsx)(n.code,{children:"length"})," 的长度，如果我们对 ",(0,s.jsx)(n.code,{children:"length"})," 做监听，那么此时便会触发 ",(0,s.jsx)(n.code,{children:"effect"}),"！而 ",(0,s.jsx)(n.code,{children:"Vue"})," 也是这么做的，也就是这段代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"deps.push(depsMap.get('length'))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同理，对于 ",(0,s.jsx)(n.code,{children:"for in, forEach, map ... "})," 都会触发 ",(0,s.jsx)(n.code,{children:"length"})," 的依赖收集，从而 ",(0,s.jsx)(n.code,{children:"pop, push, shift..."})," 等等操作都会触发响应式更新！"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，除了数组，对象的 ",(0,s.jsx)(n.code,{children:"Object.keys"})," , ",(0,s.jsx)(n.code,{children:"for ... of ..."})," 等等对象遍历操作都会触发响应式的依赖收集，这是因为 ",(0,s.jsx)(n.code,{children:"Vue"})," 在定义 ",(0,s.jsx)(n.code,{children:"Proxy"})," 的时候，定义了 ",(0,s.jsx)(n.code,{children:"ownKeys"})," 这个函数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function ownKeys(target) {\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ownKeys"})," 函数内部执行了 ",(0,s.jsx)(n.code,{children:"track"})," 进行了对 ",(0,s.jsx)(n.code,{children:"Object"})," 的 ",(0,s.jsx)(n.code,{children:"ITERATE_KEY"})," 的依赖收集。而在 ",(0,s.jsx)(n.code,{children:"setter"})," 的时候，则对 ",(0,s.jsx)(n.code,{children:"ITERATE_KEY"})," 进行了响应式触发："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"deps.push(depsMap.get(ITERATE_KEY))\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["至此，我们讲完了对响应式的依赖收集和触发过程，但有个概览我们没有说清楚，那就是 ",(0,s.jsx)(n.code,{children:"effect"})," 到底是什么，以及是如何产生的被收集到 ",(0,s.jsx)(n.code,{children:"dep"})," 当中的。下一节我们将具体介绍。"]}),"\n",(0,s.jsxs)(n.h2,{id:"课外知识",children:["课外知识",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#课外知识",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这里细心的小伙伴，可能会注意到在上面的源码中出现了一个有意思的标识符 ",(0,s.jsx)(n.code,{children:"/*#__PURE__*/"}),"。要说这个东西，那就需要说到和这玩意相关的 ",(0,s.jsx)(n.code,{children:"Tree-Shaking"})," 副作用了。我们知道 ",(0,s.jsx)(n.code,{children:"Tree-Shaking"})," 可以删除一些 ",(0,s.jsx)(n.code,{children:"DC（dead code）"})," 代码。但是对于一些有副作用的函数代码，却是无法进行很好的识别和删除，举个例子："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"foo()\n\nfunction foo(obj) {\n  obj?.a\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述代码中，",(0,s.jsx)(n.code,{children:"foo"})," 函数本身是没有任何意义的，仅仅是对对象 ",(0,s.jsx)(n.code,{children:"obj"})," 进行了属性 ",(0,s.jsx)(n.code,{children:"a"})," 的读取操作，但是 ",(0,s.jsx)(n.code,{children:"Tree-Shaking"})," 是无法删除该函数的，因为上述的属性读取操作可能会产生副作用，因为 ",(0,s.jsx)(n.code,{children:"obj"})," 可能是一个响应式对象，我们可能对 ",(0,s.jsx)(n.code,{children:"obj"})," 定了一个 ",(0,s.jsx)(n.code,{children:"getter"})," 在 ",(0,s.jsx)(n.code,{children:"getter"})," 中触发了很多不可预期的操作。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果我们确认 ",(0,s.jsx)(n.code,{children:"foo"})," 函数是一个不会有副作用的",(0,s.jsx)(n.strong,{children:"纯净的函数"}),"，那么这个时候 ",(0,s.jsx)(n.code,{children:"/*#__PURE__*/"})," 就派上用场了，其作用就是",(0,s.jsxs)(n.strong,{children:["告诉打包器，对于\xa0",(0,s.jsx)(n.code,{children:"foo"}),"\xa0函数的调用不会产生副作用，你可以放心地对其进行 ",(0,s.jsx)(n.code,{children:"Tree-Shaking"})]}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，值得一提的是，在 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 源码中，包含了大量的 ",(0,s.jsx)(n.code,{children:"/*#__PURE__*/"})," 标识符，可见 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 对源码体积的控制是多么的用心！"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F6.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%9A%E5%9F%BA%E4%BA%8E%20Proxy%20%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"Reactive",id:"reactive",depth:2},{text:"1. get",id:"1-get",depth:3},{text:"2. set",id:"2-set",depth:3},{text:"总结",id:"总结",depth:2},{text:"课外知识",id:"课外知识",depth:2}],title:"6.响应式原理：基于 Proxy 的响应式是什么样的？",headingTitle:"6.响应式原理：基于 Proxy 的响应式是什么样的？",frontmatter:{}}}}]);