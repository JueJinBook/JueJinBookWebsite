"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["5387"],{948084:function(n,e,r){n.exports=r.p+"static/image/c594c33342120a40c432cb6c1de42fbe.7dffa350.webp"},710014:function(n,e,r){r.r(e),r.d(e,{default:()=>g});var t=r(552676),s=r(740453);let o=r.p+"static/image/8a9a95618ac68128eb2b5fd0c09a6a06.fab23fa3.webp",i=r.p+"static/image/da31998430c91c81d67139f388e33305.d6119e49.webp",d=r.p+"static/image/8c4a8d9a7174081ca8e5c28322fc831f.ad56b0bd.webp",l=r.p+"static/image/bf608fd6d3f1f1057ceaf8934e636303.4b75825c.webp",c=r.p+"static/image/424c20f2f136bf07cda6726e77e7f5d8.453c2f01.webp",a=r.p+"static/image/844da9c66734d0f844fcc637ca5c3b6d.6ea02807.webp",p=r.p+"static/image/25ac07c12ed528f6091ddc13a8191443.25e2fe94.webp",u=r.p+"static/image/80842f5c6ce5cd8a8e2d8a262f7ab500.263869f3.webp";var m=r(948084);function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",ul:"ul",li:"li",blockquote:"blockquote",h2:"h2",pre:"pre",code:"code",ol:"ol"},(0,s.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"25手写-vite_-实现-no-bundle-开发服务下",children:["25.手写 Vite_ 实现 no-bundle 开发服务(下)",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#25手写-vite_-实现-no-bundle-开发服务下",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"本小节为上一小节的续篇，我们基于下面的导图继续实现 no-bundle 构建服务:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:"接下来我们需要完成如下的模块:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"CSS 编译插件"}),"\n",(0,t.jsx)(e.li,{children:"静态资源加载插件"}),"\n",(0,t.jsx)(e.li,{children:"模块依赖图开发，并在 transform 中间件中接入"}),"\n",(0,t.jsx)(e.li,{children:"HMR 服务端代码开发"}),"\n",(0,t.jsx)(e.li,{children:"HMR 客户端代码开发"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"话不多说，下面我们正式进入实战的环节。"}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["注: 手写 Vite 项目的所有代码，我已经放到了小册的 Github 仓库中，",(0,t.jsx)(e.a,{href:"https://github.com/sanyuan0704/juejin-book-vite/tree/main/mini-vite",target:"_blank",rel:"noopener noreferrer",children:"点击查看"})]}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"css-编译插件",children:["CSS 编译插件",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#css-编译插件",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"首先，我们可以看看项目中 CSS 代码是如何被引入的:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// playground/src/main.tsx\nimport "./index.css";\n'})}),"\n",(0,t.jsxs)(e.p,{children:["为了让 CSS 能够在 no-bundle 服务中正常加载，我们需要将其包装成浏览器可以识别的模块格式，也就是 ",(0,t.jsx)(e.code,{children:"JS 模块"}),"，其中模块加载和转换的逻辑我们可以通过插件来实现。当然，首先我们需要在 transform 中间件中允许对 CSS 的请求进行处理，代码如下:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/server/middlewares/transform.ts\n// 需要增加的导入语句\n+ import { isCSSRequest } from \'../../utils\';\n\nexport function transformMiddleware(\n  serverContext: ServerContext\n): NextHandleFunction {\n  return async (req, res, next) => {\n    if (req.method !== "GET" || !req.url) {\n      return next();\n    }\n    const url = req.url;\n    debug("transformMiddleware: %s", url);\n    // transform JS request\n-    if (isJSRequest(url)) {\n+    if (isJSRequest(url) || isCSSRequest(url)) {\n      // 后续代码省略\n     }\n\n    next();\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"然后我们来补充对应的工具函数:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// src/node/utils.ts\nexport const isCSSRequest = (id: string): boolean =>\n  cleanUrl(id).endsWith(".css");\n'})}),"\n",(0,t.jsxs)(e.p,{children:["现在我们来开发 CSS 的编译插件，你可以新建",(0,t.jsx)(e.code,{children:"src/node/plugins/css.ts"}),"文件，内容如下:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { readFile } from "fs-extra";\nimport { Plugin } from "../plugin";\n\nexport function cssPlugin(): Plugin {\n  return {\n    name: "m-vite:css",\n    load(id) {\n      // 加载\n      if (id.endsWith(".css")) {\n        return readFile(id, "utf-8");\n      }\n    },\n    // 转换逻辑\n    async transform(code, id) {\n      if (id.endsWith(".css")) {\n        // 包装成 JS 模块\n        const jsContent = `\nconst css = "${code.replace(/\\n/g, "")}";\nconst style = document.createElement("style");\nstyle.setAttribute("type", "text/css");\nstyle.innerHTML = css;\ndocument.head.appendChild(style);\nexport default css;\n`.trim();\n        return {\n          code: jsContent,\n        };\n      }\n      return null;\n    },\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"这个插件的逻辑比较简单，主要是将封装一层 JS 样板代码，将 CSS 包装成一个 ES 模块，当浏览器执行这个模块的时候，会通过一个 style 标签将 CSS 代码作用到页面中，从而使样式代码生效。"}),"\n",(0,t.jsx)(e.p,{children:"接着我们来注册这个 CSS 插件:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/plugins/index.ts\n+ import { cssPlugin } from "./css";\n\nexport function resolvePlugins(): Plugin[] {\n  return [\n    // 省略前面的插件\n+     cssPlugin(),\n  ];\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["现在，你可以通过",(0,t.jsx)(e.code,{children:"pnpm dev"}),"来启动 playground 项目，不过在启动之前，需要保证 TSX 文件已经引入了对应的 CSS 文件:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// playground/src/main.tsx\nimport "./index.css";\n\n// playground/src/App.tsx\nimport "./App.css";\n'})}),"\n",(0,t.jsx)(e.p,{children:"在启动项目后，打开浏览器进行访问，可以看到样式已经正常生效:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,t.jsxs)(e.h2,{id:"静态资源加载",children:["静态资源加载",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#静态资源加载",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"在完成 CSS 加载之后，我们现在继续完成静态资源的加载。以 playground 项目为例，我们来支持 svg 文件的加载。首先，我们看看 svg 文件是如何被引入并使用的:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// playground/src/App.tsx\nimport logo from "./logo.svg";\n\nfunction App() {\n  return (\n    <img className="App-logo" src={logo} alt="" />\n  )\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"站在 no-bundle 服务的角度，从如上的代码我们可以分析出静态资源的两种请求:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["import 请求。如 ",(0,t.jsx)(e.code,{children:'import logo from "./logo.svg"'}),"。"]}),"\n",(0,t.jsx)(e.li,{children:"资源内容请求。如 img 标签将资源 url 填入 src，那么浏览器会请求具体的资源内容。"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"因此，接下来为了实现静态资源的加载，我们需要做两手准备: 对静态资源的 import 请求返回资源的 url；对于具体内容的请求，读取静态资源的文件内容，并响应给浏览器。"}),"\n",(0,t.jsx)(e.p,{children:"首先处理 import 请求，我们可以在 TSX 的 import 分析插件中，给静态资源相关的 import 语句做一个标记:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/plugins/importAnalysis.ts\n\nasync transform(code, id) {\n  // 省略前面的代码\n  for (const importInfo of imports) {\n    const { s: modStart, e: modEnd, n: modSource } = importInfo;\n    if (!modSource) continue;\n+    // 静态资源\n+    if (modSource.endsWith(".svg")) {\n+      // 加上 ?import 后缀\n+      const resolvedUrl = path.join(path.dirname(id), modSource);\n+      ms.overwrite(modStart, modEnd, `${resolvedUrl}?import`);\n+      continue;\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"编译后的 App.tsx 内容如下:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,t.jsxs)(e.p,{children:["接着浏览器会发出带有",(0,t.jsx)(e.code,{children:"?import"}),"后缀的请求，我们在 transform 中间件进行处理:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/server/middlewares/transform.ts\n// 需要增加的导入语句\n+ import { isImportRequest } from \'../../utils\';\n\nexport function transformMiddleware(\n  serverContext: ServerContext\n): NextHandleFunction {\n  return async (req, res, next) => {\n    if (req.method !== "GET" || !req.url) {\n      return next();\n    }\n    const url = req.url;\n    debug("transformMiddleware: %s", url);\n    // transform JS request\n-    if (isJSRequest(url) || isCSSRequest(url)) {\n+    if (isJSRequest(url) || isCSSRequest(url) || isImportRequest(url)) {\n      // 后续代码省略\n     }\n\n    next();\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"然后补充对应的工具函数:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// src/node/utils.ts\nexport function isImportRequest(url: string): boolean {\n  return url.endsWith("?import");\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["此时，我们就可以开发静态资源插件了。新建",(0,t.jsx)(e.code,{children:"src/node/plugins/assets.ts"}),"，内容如下:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { pathExists, readFile } from "fs-extra";\nimport { Plugin } from "../plugin";\nimport { ServerContext } from "../server";\nimport { cleanUrl, getShortName, normalizePath, removeImportQuery } from "../utils";\n\nexport function assetPlugin(): Plugin {\n  let serverContext: ServerContext;\n\n  return {\n    name: "m-vite:asset",\n    configureServer(s) {\n      serverContext = s;\n    },\n    async load(id) {\n      const cleanedId = removeImportQuery(cleanUrl(id));\n      const resolvedId = `/${getShortName(normalizePath(id), serverContext.root)}`;\n\n      // 这里仅处理 svg\n      if (cleanedId.endsWith(".svg")) {\n        return {\n          code: `export default "${resolvedId}"`,\n        };\n      }\n    },\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"接着来注册这个插件:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/plugins/index.ts\n+ import { assetPlugin } from "./assets";\n\nexport function resolvePlugins(): Plugin[] {\n  return [\n    // 省略前面的插件\n+     assetPlugin(),\n  ];\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"OK，目前我们处理完了静态资源的 import 请求，接着我们还需要处理非 import 请求，返回资源的具体内容。我们可以通过一个中间件来进行处理:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// src/node/server/middlewares/static.ts\nimport { NextHandleFunction } from "connect";\nimport { isImportRequest } from "../../utils";\n// 一个用于加载静态资源的中间件\nimport sirv from "sirv";\n\nexport function staticMiddleware(root: string): NextHandleFunction {\n  const serveFromRoot = sirv(root, { dev: true });\n  return async (req, res, next) => {\n    if (!req.url) {\n      return;\n    }\n    // 不处理 import 请求\n    if (isImportRequest(req.url)) {\n      return;\n    }\n    serveFromRoot(req, res, next);\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"然后在服务中注册这个中间件:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/server/index.ts\n// 需要添加的引入语句\n+ import { staticMiddleware } from "./middlewares/static";\n\nexport async function startDevServer() {\n  // 前面的代码省略\n+  app.use(staticMiddleware(serverContext.root));\n\n  app.listen(3000, async () => {\n    // 省略实现\n  });\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["现在，你可以通过",(0,t.jsx)(e.code,{children:"pnpm dev"}),"启动 playground 项目，在浏览器中访问，可以发现 svg 图片已经能够成功显示了:"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:"其实不光是 svg 文件，几乎所有格式的静态资源都可以按照如上的思路进行处理:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["通过加入",(0,t.jsx)(e.code,{children:"?import"}),"后缀标识 import 请求，返回将静态资源封装成一个 JS 模块，即",(0,t.jsx)(e.code,{children:"export default xxx"}),"的形式，导出资源的真实地址。"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:["对非 import 请求，响应静态资源的具体内容，通过 ",(0,t.jsx)(e.code,{children:"Content-Type"}),"响应头告诉浏览器资源的类型(这部分工作 sirv 中间件已经帮我们做了)。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"模块依赖图开发",children:["模块依赖图开发",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模块依赖图开发",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"模块依赖图在 no-bundle 构建服务中是一个不可或缺的数据结构，一方面可以存储各个模块的信息，用于记录编译缓存，另一方面也可以记录各个模块间的依赖关系，用于实现 HMR。"}),"\n",(0,t.jsxs)(e.p,{children:["接下来我们来实现模块依赖图，即",(0,t.jsx)(e.code,{children:"ModuleGraph"}),"类，新建",(0,t.jsx)(e.code,{children:"src/node/ModuleGraph.ts"}),"，内容如下:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { PartialResolvedId, TransformResult } from "rollup";\nimport { cleanUrl } from "./utils";\n\nexport class ModuleNode {\n  // 资源访问 url\n  url: string;\n  // 资源绝对路径\n  id: string | null = null;\n  importers = new Set<ModuleNode>();\n  importedModules = new Set<ModuleNode>();\n  transformResult: TransformResult | null = null;\n  lastHMRTimestamp = 0;\n  constructor(url: string) {\n    this.url = url;\n  }\n}\n\nexport class ModuleGraph {\n  // 资源 url 到 ModuleNode 的映射表\n  urlToModuleMap = new Map<string, ModuleNode>();\n  // 资源绝对路径到 ModuleNode 的映射表\n  idToModuleMap = new Map<string, ModuleNode>();\n\n  constructor(\n    private resolveId: (url: string) => Promise<PartialResolvedId | null>\n  ) {}\n\n  getModuleById(id: string): ModuleNode | undefined {\n    return this.idToModuleMap.get(id);\n  }\n\n  async getModuleByUrl(rawUrl: string): Promise<ModuleNode | undefined> {\n    const { url } = await this._resolve(rawUrl);\n    return this.urlToModuleMap.get(url);\n  }\n\n  async ensureEntryFromUrl(rawUrl: string): Promise<ModuleNode> {\n    const { url, resolvedId } = await this._resolve(rawUrl);\n    // 首先检查缓存\n    if (this.urlToModuleMap.has(url)) {\n      return this.urlToModuleMap.get(url) as ModuleNode;\n    }\n    // 若无缓存，更新 urlToModuleMap 和 idToModuleMap\n    const mod = new ModuleNode(url);\n    mod.id = resolvedId;\n    this.urlToModuleMap.set(url, mod);\n    this.idToModuleMap.set(resolvedId, mod);\n    return mod;\n  }\n\n  async updateModuleInfo(\n    mod: ModuleNode,\n    importedModules: Set<string | ModuleNode>\n  ) {\n    const prevImports = mod.importedModules;\n    for (const curImports of importedModules) {\n      const dep =\n        typeof curImports === "string"\n          ? await this.ensureEntryFromUrl(cleanUrl(curImports))\n          : curImports;\n      if (dep) {\n        mod.importedModules.add(dep);\n        dep.importers.add(mod);\n      }\n    }\n    // 清除已经不再被引用的依赖\n    for (const prevImport of prevImports) {\n      if (!importedModules.has(prevImport.url)) {\n        prevImport.importers.delete(mod);\n      }\n    }\n  }\n\n  // HMR 触发时会执行这个方法\n  invalidateModule(file: string) {\n    const mod = this.idToModuleMap.get(file);\n    if (mod) {\n      // 更新时间戳\n      mod.lastHMRTimestamp = Date.now();\n      mod.transformResult = null;\n      mod.importers.forEach((importer) => {\n        this.invalidateModule(importer.id!);\n      });\n    }\n  }\n\n  private async _resolve(\n    url: string\n  ): Promise<{ url: string; resolvedId: string }> {\n    const resolved = await this.resolveId(url);\n    const resolvedId = resolved?.id || url;\n    return { url, resolvedId };\n  }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"相信经过第 23 小节的学习，你已经对模块依赖图的实现结构比较熟悉了，对于代码细节这里也不再赘述。接着我们看看如何将这个 ModuleGraph 接入到目前的架构中。"}),"\n",(0,t.jsx)(e.p,{children:"首先在服务启动前，我们需要初始化 ModuleGraph 实例:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/server/index.ts\n+ import { ModuleGraph } from "../ModuleGraph";\n\nexport interface ServerContext {\n  root: string;\n  pluginContainer: PluginContainer;\n  app: connect.Server;\n  plugins: Plugin[];\n+  moduleGraph: ModuleGraph;\n}\n\nexport async function startDevServer() {\n+  const moduleGraph = new ModuleGraph((url) => pluginContainer.resolveId(url));\n  const pluginContainer = createPluginContainer(plugins);\n  const serverContext: ServerContext = {\n    root: process.cwd(),\n    app,\n    pluginContainer,\n    plugins,\n+    moduleGraph\n  };\n  \n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["然后在加载完模块后，也就是调用插件容器的 load 方法后，我们需要通过 ",(0,t.jsx)(e.code,{children:"ensureEntryFromUrl"})," 方法注册模块:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/server/middlewares/transform.ts\nlet code = await pluginContainer.load(resolvedResult.id);\nif (typeof code === "object" && code !== null) {\n  code = code.code;\n}\n+ const { moduleGraph }  = serverContext;\n+ mod = await moduleGraph.ensureEntryFromUrl(url);\n'})}),"\n",(0,t.jsx)(e.p,{children:"当我们对 JS 模块分析完 import 语句之后，需要更新模块之间的依赖关系:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/plugins/importAnalysis.ts\nexport function importAnalysis() {\n  return {\n    transform(code: string, id: string) {\n      // 省略前面的代码\n+      const { moduleGraph } = serverContext;\n+      const curMod = moduleGraph.getModuleById(id)!;\n+      const importedModules = new Set<string>();\n      for(const importInfo of imports) {\n        // 省略部分代码\n        if (BARE_IMPORT_RE.test(modSource)) {\n          // 省略部分代码\n+          importedModules.add(bundlePath);\n        } else if (modSource.startsWith(".") || modSource.startsWith("/")) {\n          const resolved = await resolve(modSource, id);\n          if (resolved) {\n            ms.overwrite(modStart, modEnd, resolved);\n+            importedModules.add(resolved);\n          }\n        }\n      }\n+      moduleGraph.updateModuleInfo(curMod, importedModules);\n      // 省略后续 return 代码\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"现在，一个完整的模块依赖图就能随着 JS 请求的到来而不断建立起来了。另外，基于现在的模块依赖图，我们也可以记录模块编译后的产物，并进行缓存。让我们回到 transform 中间件中:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'export async function transformRequest(\n  url: string,\n  serverContext: ServerContext\n) {\n  const { moduleGraph, pluginContainer } = serverContext;\n  url = cleanUrl(url);\n+  let mod = await moduleGraph.getModuleByUrl(url);\n+  if (mod && mod.transformResult) {\n+    return mod.transformResult;\n+  }\n  const resolvedResult = await pluginContainer.resolveId(url);\n  let transformResult;\n  if (resolvedResult?.id) {\n    let code = await pluginContainer.load(resolvedResult.id);\n    if (typeof code === "object" && code !== null) {\n      code = code.code;\n    }\n    mod = await moduleGraph.ensureEntryFromUrl(url);\n    if (code) {\n      transformResult = await pluginContainer.transform(\n        code as string,\n        resolvedResult?.id\n      );\n    }\n  }\n+  if (mod) {\n+    mod.transformResult = transformResult;\n+  }\n  return transformResult;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"在搭建好模块依赖图之后，我们把目光集中到最重要的部分——HMR 上面。"}),"\n",(0,t.jsxs)(e.h2,{id:"hmr-服务端",children:["HMR 服务端",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#hmr-服务端",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"HMR 在服务端需要完成如下的工作:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"创建文件监听器，以监听文件的变动"}),"\n",(0,t.jsx)(e.li,{children:"创建 WebSocket 服务端，负责和客户端进行通信"}),"\n",(0,t.jsx)(e.li,{children:"文件变动时，从 ModuleGraph 中定位到需要更新的模块，将更新信息发送给客户端"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"首先，我们来创建文件监听器:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// src/node/server/index.ts\nimport chokidar, { FSWatcher } from "chokidar";\n\nexport async function startDevServer() {\n  const watcher = chokidar.watch(root, {\n    ignored: ["**/node_modules/**", "**/.git/**"],\n    ignoreInitial: true,\n  });\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["接着初始化 WebSocket 服务端，新建",(0,t.jsx)(e.code,{children:"src/node/ws.ts"}),"，内容如下:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import connect from "connect";\nimport { red } from "picocolors";\nimport { WebSocketServer, WebSocket } from "ws";\nimport { HMR_PORT } from "./constants";\n\nexport function createWebSocketServer(server: connect.Server): {\n  send: (msg: string) => void;\n  close: () => void;\n} {\n  let wss: WebSocketServer;\n  wss = new WebSocketServer({ port: HMR_PORT });\n  wss.on("connection", (socket) => {\n    socket.send(JSON.stringify({ type: "connected" }));\n  });\n\n  wss.on("error", (e: Error & { code: string }) => {\n    if (e.code !== "EADDRINUSE") {\n      console.error(red(`WebSocket server error:\\n${e.stack || e.message}`));\n    }\n  });\n\n  return {\n    send(payload: Object) {\n      const stringified = JSON.stringify(payload);\n      wss.clients.forEach((client) => {\n        if (client.readyState === WebSocket.OPEN) {\n          client.send(stringified);\n        }\n      });\n    },\n\n    close() {\n      wss.close();\n    },\n  };\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["同时定义 ",(0,t.jsx)(e.code,{children:"HMR_PORT"})," 常量:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"// src/node/constants.ts\nexport const HMR_PORT = 24678;\n"})}),"\n",(0,t.jsx)(e.p,{children:"接着我们将 WebSocket 服务端实例加入 no-bundle 服务中:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:"// src/node/server/index.ts\nexport interface ServerContext {\n  root: string;\n  pluginContainer: PluginContainer;\n  app: connect.Server;\n  plugins: Plugin[];\n  moduleGraph: ModuleGraph;\n+  ws: { send: (data: any) => void; close: () => void };\n+  watcher: FSWatcher;\n}\n\nexport async function startDevServer() {\n+  // WebSocket 对象\n+  const ws = createWebSocketServer(app);\n  // // 开发服务器上下文\n  const serverContext: ServerContext = {\n    root: process.cwd(),\n    app,\n    pluginContainer,\n    plugins,\n    moduleGraph,\n+    ws,\n+    watcher\n  };\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["下面我们来实现当文件变动时，服务端具体的处理逻辑，新建 ",(0,t.jsx)(e.code,{children:"src/node/hmr.ts"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { ServerContext } from "./server/index";\nimport { blue, green } from "picocolors";\nimport { getShortName } from "./utils";\n\nexport function bindingHMREvents(serverContext: ServerContext) {\n  const { watcher, ws, root } = serverContext;\n\n  watcher.on("change", async (file) => {\n    console.log(`✨${blue("[hmr]")} ${green(file)} changed`);\n    const { moduleGraph } = serverContext;\n    // 清除模块依赖图中的缓存\n    await moduleGraph.invalidateModule(file);\n    // 向客户端发送更新信息\n    ws.send({\n      type: "update",\n      updates: [\n        {\n          type: "js-update",\n          timestamp: Date.now(),\n          path: "/" + getShortName(file, root),\n          acceptedPath: "/" + getShortName(file, root),\n        },\n      ],\n    });\n  });\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"注意补充一下缺失的工具函数:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// src/node/utils.ts\nexport function getShortName(file: string, root: string) {\n  return file.startsWith(root + "/") ? path.posix.relative(root, file) : file;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"接着我们在服务中添加如下代码:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'// src/node/server/index.ts\n+  import { bindingHMREvents } from "../hmr";\n+  import { normalizePath } from "../utils";\n\n// 开发服务器上下文\nconst serverContext: ServerContext = {\n  root: normalizePath(process.cwd()),\n  app,\n  pluginContainer,\n  plugins,\n  moduleGraph,\n  ws,\n  watcher,\n};\n+ bindingHMREvents(serverContext);\n'})}),"\n",(0,t.jsxs)(e.h2,{id:"hmr-客户端",children:["HMR 客户端",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#hmr-客户端",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"HMR 客户端指的是我们向浏览器中注入的一段 JS 脚本，这段脚本中会做如下的事情:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"创建 WebSocket 客户端，用于和服务端通信"}),"\n",(0,t.jsx)(e.li,{children:"在收到服务端的更新信息后，通过动态 import 拉取最新的模块内容，执行 accept 更新回调"}),"\n",(0,t.jsx)(e.li,{children:"暴露 HMR 的一些工具函数，比如 import.meta.hot 对象的实现"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["首先我们来开发客户端的脚本内容，你可以新建",(0,t.jsx)(e.code,{children:"src/client/client.ts"}),"文件，然后在 tsup.config.ts 中增加如下的配置:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'import { defineConfig } from "tsup";\n\nexport default defineConfig({\n  entry: {\n    index: "src/node/cli.ts",\n+    client: "src/client/client.ts",\n  },\n});\n'})}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsxs)(e.p,{children:["注: 改动 tsup 配置之后，为了使最新配置生效，你需要在 ",(0,t.jsx)(e.code,{children:"mini-vite"})," 项目中执行 ",(0,t.jsx)(e.code,{children:"pnpm start"})," 重新进行构建。"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"客户端脚本的具体实现如下:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// src/client/client.ts\nconsole.log("[vite] connecting...");\n\n// 1. 创建客户端 WebSocket 实例\n// 其中的 __HMR_PORT__ 之后会被 no-bundle 服务编译成具体的端口号\nconst socket = new WebSocket(`ws://localhost:__HMR_PORT__`, "vite-hmr");\n\n// 2. 接收服务端的更新信息\nsocket.addEventListener("message", async ({ data }) => {\n  handleMessage(JSON.parse(data)).catch(console.error);\n});\n\n// 3. 根据不同的更新类型进行更新\nasync function handleMessage(payload: any) {\n  switch (payload.type) {\n    case "connected":\n      console.log(`[vite] connected.`);\n      // 心跳检测\n      setInterval(() => socket.send("ping"), 1000);\n      break;\n\n    case "update":\n      // 进行具体的模块更新\n      payload.updates.forEach((update: Update) => {\n        if (update.type === "js-update") {\n          // 具体的更新逻辑，后续来开发\n        }\n      });\n      break;\n  }\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["关于客户端具体的 JS 模块更新逻辑和工具函数的实现，你暂且不用过于关心。我们先把这段比较简单的 HMR 客户端代码注入到浏览器中，首先在新建 ",(0,t.jsx)(e.code,{children:"src/node/plugins/clientInject.ts"}),"，内容如下:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { CLIENT_PUBLIC_PATH, HMR_PORT } from "../constants";\nimport { Plugin } from "../plugin";\nimport fs from "fs-extra";\nimport path from "path";\nimport { ServerContext } from "../server/index";\n\nexport function clientInjectPlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: "m-vite:client-inject",\n    configureServer(s) {\n      serverContext = s;\n    },\n    resolveId(id) {\n      if (id === CLIENT_PUBLIC_PATH) {\n        return { id };\n      }\n      return null;\n    },\n    async load(id) {\n      // 加载 HMR 客户端脚本\n      if (id === CLIENT_PUBLIC_PATH) {\n        const realPath = path.join(\n          serverContext.root,\n          "node_modules",\n          "mini-vite",\n          "dist",\n          "client.mjs"\n        );\n        const code = await fs.readFile(realPath, "utf-8");\n        return {\n          // 替换占位符\n          code: code.replace("__HMR_PORT__", JSON.stringify(HMR_PORT)),\n        };\n      }\n    },\n    transformIndexHtml(raw) {\n      // 插入客户端脚本\n      // 即在 head 标签后面加上 <script type="module" src="/@vite/client"><\/script>\n      // 注: 在 indexHtml 中间件里面会自动执行 transformIndexHtml 钩子\n      return raw.replace(\n        /(<head[^>]*>)/i,\n        `$1<script type="module" src="${CLIENT_PUBLIC_PATH}"><\/script>`\n      );\n    },\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"同时添加相应的常量声明:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'// src/node/constants.ts\nexport const CLIENT_PUBLIC_PATH = "/@vite/client";\n'})}),"\n",(0,t.jsx)(e.p,{children:"接着我们来注册这个插件:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:"// src/node/plugins/index.ts\n+ import { clientInjectPlugin } from './clientInject';\n\nexport function resolvePlugins(): Plugin[] {\n  return [\n+     clientInjectPlugin()\n    // 省略其它插件\n  ]\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["需要注意的是，",(0,t.jsx)(e.code,{children:"clientInject"}),"插件最好放到最前面的位置，以免后续插件的 load 钩子干扰客户端脚本的加载。"]}),"\n",(0,t.jsxs)(e.p,{children:["接下来你可以在 playground 项目下执行",(0,t.jsx)(e.code,{children:"pnpm dev"}),"，然后查看页面，可以发现控制台出现了如下的 log 信息:"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:"查看网络面板，也能发现客户端脚本的请求被正常响应:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:"OK，接下来我们就来继续完善客户端脚本的具体实现。"}),"\n",(0,t.jsxs)(e.p,{children:["值得一提的是，之所以我们可以在代码中编写类似",(0,t.jsx)(e.code,{children:"import.meta.hot.xxx"}),"之类的方法，是因为 Vite 帮我们在模块最顶层注入了",(0,t.jsx)(e.code,{children:"import.meta.hot"}),"对象，而这个对象由",(0,t.jsx)(e.code,{children:"createHotContext"}),"来实现，具体的注入代码如下所示:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { createHotContext as __vite__createHotContext } from "/@vite/client";\nimport.meta.hot = __vite__createHotContext("/src/App.tsx");\n'})}),"\n",(0,t.jsx)(e.p,{children:"下面我们在 import 分析插件中做一些改动，实现插入这段代码的功能:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-diff",children:'import { init, parse } from "es-module-lexer";\nimport {\n  BARE_IMPORT_RE,\n  CLIENT_PUBLIC_PATH,\n  PRE_BUNDLE_DIR,\n} from "../constants";\nimport {\n  cleanUrl,\n+  getShortName,\n  isJSRequest,\n} from "../utils";\nimport MagicString from "magic-string";\nimport path from "path";\nimport { Plugin } from "../plugin";\nimport { ServerContext } from "../server/index";\n\nexport function importAnalysisPlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: "m-vite:import-analysis",\n    configureServer(s) {\n      serverContext = s;\n    },\n    async transform(code: string, id: string) {\n+      if (!isJSRequest(id) || isInternalRequest(id)) {\n        return null;\n      }\n      await init;\n      const importedModules = new Set<string>();\n      const [imports] = parse(code);\n      const ms = new MagicString(code);\n+      const resolve = async (id: string, importer?: string) => {\n+        const resolved = await this.resolve(\n+          id,\n+          normalizePath(importer)\n+        );\n+        if (!resolved) {\n+          return;\n+        }\n+        const cleanedId = cleanUrl(resolved.id);\n+        const mod = moduleGraph.getModuleById(cleanedId);\n+        let resolvedId = `/${getShortName(resolved.id, serverContext.root)}`;\n+        if (mod && mod.lastHMRTimestamp > 0) {\n+          resolvedId += "?t=" + mod.lastHMRTimestamp;\n+        }\n+        return resolvedId;\n+      };\n      const { moduleGraph } = serverContext;\n      const curMod = moduleGraph.getModuleById(id)!;\n\n      for (const importInfo of imports) {\n        const { s: modStart, e: modEnd, n: modSource } = importInfo;\n        if (!modSource || isInternalRequest(modSource)) continue;\n        // 静态资源\n        if (modSource.endsWith(".svg")) {\n          // 加上 ?import 后缀\n          const resolvedUrl = await resolve(modSource, id);\n          ms.overwrite(modStart, modEnd, `${resolvedUrl}?import`);\n          continue;\n        }\n        // 第三方库: 路径重写到预构建产物的路径\n        if (BARE_IMPORT_RE.test(modSource)) {\n          const bundlePath = normalizePath(\n            path.join(\'/\', PRE_BUNDLE_DIR, `${modSource}.js`)\n          ms.overwrite(modStart, modEnd, bundlePath);\n          importedModules.add(bundlePath);\n        } else if (modSource.startsWith(".") || modSource.startsWith("/")) {\n+          const resolved = await resolve(modSource, id);\n          if (resolved) {\n            ms.overwrite(modStart, modEnd, resolved);\n            importedModules.add(resolved);\n          }\n        }\n      }\n      // 只对业务源码注入\n+      if (!id.includes("node_modules")) {\n+        // 注入 HMR 相关的工具函数\n+        ms.prepend(\n+          `import { createHotContext as __vite__createHotContext } from "${CLIENT_PUBLIC_PATH}";` +\n+            `import.meta.hot = __vite__createHotContext(${JSON.stringify(\n+              cleanUrl(curMod.url)\n+            )});`\n+        );\n+      }\n\n      moduleGraph.updateModuleInfo(curMod, importedModules);\n\n      return {\n        code: ms.toString(),\n        map: ms.generateMap(),\n      };\n    },\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"接着启动 playground，打开页面后你可以发现 import.meta.hot 的实现代码已经被成功插入:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsxs)(e.p,{children:["现在，我们回到客户端脚本的实现中，来开发",(0,t.jsx)(e.code,{children:"createHotContext"})," 这个工具方法:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'interface HotModule {\n  id: string;\n  callbacks: HotCallback[];\n}\n\ninterface HotCallback {\n  deps: string[];\n  fn: (modules: object[]) => void;\n}\n\n// HMR 模块表\nconst hotModulesMap = new Map<string, HotModule>();\n// 不在生效的模块表\nconst pruneMap = new Map<string, (data: any) => void | Promise<void>>();\n\nexport const createHotContext = (ownerPath: string) => {\n  const mod = hotModulesMap.get(ownerPath);\n  if (mod) {\n    mod.callbacks = [];\n  }\n\n  function acceptDeps(deps: string[], callback: any) {\n    const mod: HotModule = hotModulesMap.get(ownerPath) || {\n      id: ownerPath,\n      callbacks: [],\n    };\n    // callbacks 属性存放 accept 的依赖、依赖改动后对应的回调逻辑\n    mod.callbacks.push({\n      deps,\n      fn: callback,\n    });\n    hotModulesMap.set(ownerPath, mod);\n  }\n\n  return {\n    accept(deps: any, callback?: any) {\n      // 这里仅考虑接受自身模块更新的情况\n      // import.meta.hot.accept()\n      if (typeof deps === "function" || !deps) {\n        acceptDeps([ownerPath], ([mod]) => deps && deps(mod));\n      }\n    },\n    // 模块不再生效的回调\n    // import.meta.hot.prune(() => {})\n    prune(cb: (data: any) => void) {\n      pruneMap.set(ownerPath, cb);\n    },\n  };\n};\n'})}),"\n",(0,t.jsxs)(e.p,{children:["在 accept 方法中，我们会用",(0,t.jsx)(e.code,{children:"hotModulesMap"}),"这张表记录该模块所 accept 的模块，以及 accept 的模块更新之后回调逻辑。"]}),"\n",(0,t.jsx)(e.p,{children:"接着，我们来开发客户端热更新的具体逻辑，也就是服务端传递更新内容之后客户端如何来派发更新。实现代码如下:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'async function fetchUpdate({ path, timestamp }: Update) {\n  const mod = hotModulesMap.get(path);\n  if (!mod) return;\n\n  const moduleMap = new Map();\n  const modulesToUpdate = new Set<string>();\n  modulesToUpdate.add(path);\n\n  await Promise.all(\n    Array.from(modulesToUpdate).map(async (dep) => {\n      const [path, query] = dep.split(`?`);\n      try {\n        // 通过动态 import 拉取最新模块\n        const newMod = await import(\n          path + `?t=${timestamp}${query ? `&${query}` : ""}`\n        );\n        moduleMap.set(dep, newMod);\n      } catch (e) {}\n    })\n  );\n\n  return () => {\n    // 拉取最新模块后执行更新回调\n    for (const { deps, fn } of mod.callbacks) {\n      fn(deps.map((dep: any) => moduleMap.get(dep)));\n    }\n    console.log(`[vite] hot updated: ${path}`);\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"现在，我们可以来初步测试一下 HMR 的功能，你可以暂时将 main.tsx 的内容换成下面这样:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import React from "react";\nimport ReactDOM from "react-dom";\nimport "./index.css";\n\nconst App = () => <div>hello 123123</div>;\n\nReactDOM.render(<App />, document.getElementById("root"));\n\n// @ts-ignore\nimport.meta.hot.accept(() => {\n  ReactDOM.render(<App />, document.getElementById("root"));\n});\n'})}),"\n",(0,t.jsx)(e.p,{children:"启动 playground，然后打开浏览器，可以看到如下的文本:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:"data:image/webp;base64,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",alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:"现在回到编辑器中，修改文本内容，然后保存，你可以发现页面内容也跟着发生了变化，并且网络面板发出了拉取最新模块的请求，说明 HMR 已经成功生效:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsx)(e.p,{children:"同时，当你再次刷新页面，看到的仍然是最新的页面内容。这一点非常重要，之所以能达到这样的效果，是因为我们在文件改动后会调用 ModuleGraph 的 invalidateModule 方法，这个方法会清除热更模块以及所有上层引用方模块的编译缓存:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:"// 方法实现\ninvalidateModule(file: string) {\n  const mod = this.idToModuleMap.get(file);\n  if (mod) {\n    mod.lastHMRTimestamp = Date.now();\n    mod.transformResult = null;\n    mod.importers.forEach((importer) => {\n      this.invalidateModule(importer.id!);\n    });\n  }\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"这样每次经过 HMR 后，再次刷新页面，渲染出来的一定是最新的模块内容。"}),"\n",(0,t.jsx)(e.p,{children:"当然，我们也可以对 CSS 实现热更新功能，在客户端脚本中添加如下的工具函数:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'const sheetsMap = new Map();\n\nexport function updateStyle(id: string, content: string) {\n  let style = sheetsMap.get(id);\n  if (!style) {\n    // 添加 style 标签\n    style = document.createElement("style");\n    style.setAttribute("type", "text/css");\n    style.innerHTML = content;\n    document.head.appendChild(style);\n  } else {\n    // 更新 style 标签内容\n    style.innerHTML = content;\n  }\n  sheetsMap.set(id, style);\n}\n\nexport function removeStyle(id: string): void {\n  const style = sheetsMap.get(id);\n  if (style) {\n    document.head.removeChild(style);\n  }\n  sheetsMap.delete(id);\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"紧接着我们调整一下 CSS 编译插件的代码:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",children:'import { readFile } from "fs-extra";\nimport { CLIENT_PUBLIC_PATH } from "../constants";\nimport { Plugin } from "../plugin";\nimport { ServerContext } from "../server";\nimport { getShortName } from "../utils";\n\nexport function cssPlugin(): Plugin {\n  let serverContext: ServerContext;\n  return {\n    name: "m-vite:css",\n    configureServer(s) {\n      serverContext = s;\n    },\n    load(id) {\n      if (id.endsWith(".css")) {\n        return readFile(id, "utf-8");\n      }\n    },\n    // 主要变动在 transform 钩子中\n    async transform(code, id) {\n      if (id.endsWith(".css")) {\n        // 包装成 JS 模块\n        const jsContent = `\nimport { createHotContext as __vite__createHotContext } from "${CLIENT_PUBLIC_PATH}";\nimport.meta.hot = __vite__createHotContext("/${getShortName(id, serverContext.root)}");\n\nimport { updateStyle, removeStyle } from "${CLIENT_PUBLIC_PATH}"\n  \nconst id = \'${id}\';\nconst css = \'${code.replace(/\\n/g, "")}\';\n\nupdateStyle(id, css);\nimport.meta.hot.accept();\nexport default css;\nimport.meta.hot.prune(() => removeStyle(id));`.trim();\n        return {\n          code: jsContent,\n        };\n      }\n      return null;\n    },\n  };\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"最后，你可以重启 playground 项目，本地尝试修改 CSS 代码，可以看到类似如下的热更新效果:"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:o,alt:"css-hmr1.gif"})}),"\n",(0,t.jsxs)(e.h2,{id:"小结",children:["小结",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"OK，本节的内容到这里就结束了，恭喜你完成了本次手写 Vite 的实战项目，最后我们来总结和回顾一下。"}),"\n",(0,t.jsx)(e.p,{children:"在这一小节，我们完成了 CSS 编译插件、静态资源加载插件、模块依赖图、编译缓存、HMR 服务端和客户端的实现。其中，你需要重点掌握以下的开发要点:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"CSS 的模块热更新如何实现？"}),"\n",(0,t.jsx)(e.li,{children:"静态资源的加载分为哪两种请求？no-bundle 服务中分别是如何处理的？"}),"\n",(0,t.jsx)(e.li,{children:"HMR 服务端和客户端做了哪些事情？"}),"\n",(0,t.jsx)(e.li,{children:"如何保证在 HMR 更新之后，刷新页面后依然能保证是最新的模块内容？"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"最后，欢迎你把自己的学习心得打在评论区，大家一起来交流，我们下一节再见。"})]})}function x(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(h,{...n})}):h(n)}let g=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F25.%E6%89%8B%E5%86%99%20Vite_%20%E5%AE%9E%E7%8E%B0%20no-bundle%20%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1(%E4%B8%8B).md"]={toc:[{text:"CSS 编译插件",id:"css-编译插件",depth:2},{text:"静态资源加载",id:"静态资源加载",depth:2},{text:"模块依赖图开发",id:"模块依赖图开发",depth:2},{text:"HMR 服务端",id:"hmr-服务端",depth:2},{text:"HMR 客户端",id:"hmr-客户端",depth:2},{text:"小结",id:"小结",depth:2}],title:"25.手写 Vite_ 实现 no-bundle 开发服务(下)",headingTitle:"25.手写 Vite_ 实现 no-bundle 开发服务(下)",frontmatter:{}}}}]);