"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16613"],{990163:function(e,n,s){s.r(n),s.d(n,{default:()=>b});var r=s(552676),i=s(740453);let a=s.p+"static/image/b5c14bdf54650b4096543e4eb3207dc3.ce2fb5c3.webp",t=s.p+"static/image/267c5eb9b3accb6e60ebe0dcbaf85537.36883369.gif",d=s.p+"static/image/c291dddb2638b2a179c80d29bae509a1.c77c9565.webp",c=s.p+"static/image/973aef7e1a70f56d7bdf8f20c228ac63.f7df6a2e.webp",l=s.p+"static/image/019b02e4e9a9c201c621899933489a5a.e74c1306.webp",p=s.p+"static/image/038b64be1def27b06e155d97c9e25e6b.941ef49c.webp",h=s.p+"static/image/77e1412f8f984420e5613496c6eaf2b8.22e07b32.gif",o=s.p+"static/image/41909c22293287e05d24efd6a3ee306d.326d9804.webp",x=s.p+"static/image/08b354be557567db0b6fd6ad282eeb76.514192ce.gif",u=s.p+"static/image/178ce4dcb03999d6f3cb661576b400f7.7c02280a.webp",j=s.p+"static/image/e4f9299c03e997a19625dd7a375187a5.f7df6a2e.webp";function g(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ol:"ol",li:"li",img:"img",code:"code",pre:"pre",blockquote:"blockquote",h3:"h3"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"10渲染篇-_-suspense-与-streaming",children:["10.渲染篇 _ Suspense 与 Streaming",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10渲染篇-_-suspense-与-streaming",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Suspense 是 Next.js 项目中常用的一个组件，了解其原理和背景有助于我们正确使用 Suspense 组件。"}),"\n",(0,r.jsxs)(n.h2,{id:"传统-ssr",children:["传统 SSR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#传统-ssr",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在最近的两篇文章里，我们已经介绍了 SSR 的原理和缺陷。简单来说，使用 SSR，需要经过一系列的步骤，用户才能查看页面、与之交互。具体这些步骤是："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"服务端获取所有数据"}),"\n",(0,r.jsx)(n.li,{children:"服务端渲染 HTML"}),"\n",(0,r.jsx)(n.li,{children:"将页面的 HTML、CSS、JavaScript 发送到客户端"}),"\n",(0,r.jsx)(n.li,{children:"使用 HTML 和 CSS 生成不可交互的用户界面（non-interactive UI）"}),"\n",(0,r.jsx)(n.li,{children:"React 对用户界面进行水合（hydrate），使其可交互（interactive UI）"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"这些步骤是连续的、阻塞的。这意味着服务端只能在获取所有数据后渲染 HTML，React 只能在下载了所有组件代码后才能进行水合："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"还记得上篇总结的 SSR 的几个缺点吗？"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"SSR 的数据获取必须在组件渲染之前"}),"\n",(0,r.jsx)(n.li,{children:"组件的 JavaScript 必须先加载到客户端，才能开始水合"}),"\n",(0,r.jsx)(n.li,{children:"所有组件必须先水合，然后才能跟其中任意一个组件交互"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"suspense",children:["Suspense",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#suspense",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["为了解决这些问题，React 18 引入了 ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react/Suspense",target:"_blank",rel:"noopener noreferrer",children:"<Suspense>"})," 组件。我们来介绍下这个组件："]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"<Suspense>"})," 允许你推迟渲染某些内容，直到满足某些条件（例如数据加载完毕）。"]}),"\n",(0,r.jsx)(n.p,{children:"你可以将动态组件包装在 Suspense 中，然后向其传递一个 fallback UI，以便在动态组件加载时显示。如果数据请求缓慢，使用 Suspense 流式渲染该组件，不会影响页面其他部分的渲染，更不会阻塞整个页面。"}),"\n",(0,r.jsxs)(n.p,{children:["让我们来写一个例子，新建 ",(0,r.jsx)(n.code,{children:"app/dashboard/page.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import { Suspense } from 'react'\n\nconst sleep = ms => new Promise(r => setTimeout(r, ms));\n\nasync function PostFeed() {\n  await sleep(2000)\n  return <h1>Hello PostFeed</h1>\n}\n\nasync function Weather() {\n  await sleep(8000)\n  return <h1>Hello Weather</h1>\n}\n\nasync function Recommend() {\n  await sleep(5000)\n  return <h1>Hello Recommend</h1>\n}\n\nexport default function Dashboard() {\n  return (\n    <section style={{padding: '20px'}}>\n      <Suspense fallback={<p>Loading PostFeed Component</p>}>\n        <PostFeed />\n      </Suspense>\n      <Suspense fallback={<p>Loading Weather Component</p>}>\n        <Weather />\n      </Suspense>\n      <Suspense fallback={<p>Loading Recommend Component</p>}>\n        <Recommend />\n      </Suspense>\n    </section>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"在这个例子中，我们用 Suspense 包装了三个组件，并通过 sleep 函数模拟了数据请求耗费的时长。加载效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:"suspense.gif"})}),"\n",(0,r.jsx)(n.p,{children:"可是 Next.js 是怎么实现的呢？"}),"\n",(0,r.jsx)(n.p,{children:"让我们观察下 dashboard 这个 HTML 文件的加载情况，你会发现它一开始是 2.03s，然后变成了 5.03s，最后变成了 8.04s，这不就正是我们设置的 sleep 时间吗？"}),"\n",(0,r.jsx)(n.p,{children:"查看 dashboard 请求的响应头："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"截屏2024-03-04 22.47.51.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Transfer-Encoding"})," 标头的值为 ",(0,r.jsx)(n.code,{children:"chunked"}),"，表示数据将以一系列分块的形式进行发送。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许 HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在 HTTP 协议1.1版本（HTTP/1.1）中提供。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"再查看 dashboard 返回的数据（这里我们做了简化）："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n    <head>\n        // ...\n    </head>\n    <body class="__className_aaf875">\n        <section style="padding:20px">\n            \x3c!--$?--\x3e\n            <template id="B:0"></template>\n            <p>Loading PostFeed Component</p>\n            \x3c!--/$--\x3e\n            \x3c!--$?--\x3e\n            <template id="B:1"></template>\n            <p>Loading Weather Component</p>\n            \x3c!--/$--\x3e\n            \x3c!--$?--\x3e\n            <template id="B:2"></template>\n            <p>Loading Recommend Component</p>\n            \x3c!--/$--\x3e\n        </section>\n        // ...\n        <div hidden id="S:0">\n            <h1>Hello PostFeed</h1>\n        </div>\n        <script>\n            // 交换位置\n            $RC = function(b, c, e) {\n                // ...\n            };\n            $RC("B:0", "S:0")\n        <\/script>\n        <div hidden id="S:2">\n            <h1>Hello Recommend</h1>\n        </div>\n        <script>\n            $RC("B:2", "S:2")\n        <\/script>\n        <div hidden id="S:1">\n            <h1>Hello Weather</h1>\n        </div>\n        <script>\n            $RC("B:1", "S:1")\n        <\/script>\n    </body>\n</html>\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到使用 Suspense 组件的 fallback UI 和渲染后的内容都会出现在该 HTML 文件中，说明该请求持续与服务端保持连接，服务端在组件渲染完后会将渲染后的内容追加传给客户端，客户端收到新的内容后进行解析，执行类似于 ",(0,r.jsx)(n.code,{children:'$RC("B:2", "S:2")'}),"这样的函数交换 DOM 内容，使 fallback UI 替换为渲染后的内容。"]}),"\n",(0,r.jsx)(n.p,{children:"这个过程被称之为 Streaming Server Rendering（流式渲染），它解决了上节说的传统 SSR 的第一个问题，那就是数据获取必须在组件渲染之前。使用 Suspense，先渲染 Fallback UI，等数据返回再渲染具体的组件内容。"}),"\n",(0,r.jsx)(n.p,{children:"使用 Suspense 还有一个好处就是 Selective Hydration（选择性水合）。简单的来说，当多个组件等待水合的时候，React 可以根据用户交互决定组件水合的优先级。比如 Sidebar 和 MainContent 组件都在等待水合，快要到 Sidebar 了，但此时用户点击了 MainContent 组件，React 会在单击事件的捕获阶段同步水合 MainContent 组件以保证立即响应，Sidebar 稍后水合。"}),"\n",(0,r.jsx)(n.p,{children:"总结一下，使用 Suspense，可以解锁两个主要的好处，使得 SSR 的功能更加强大："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Streaming Server Rendering（流式渲染）：从服务器到客户端渐进式渲染 HTML"}),"\n",(0,r.jsx)(n.li,{children:"Selective Hydration（选择性水合）：React 根据用户交互决定水合的优先级"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"suspense-会影响-seo-吗",children:["Suspense 会影响 SEO 吗？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#suspense-会影响-seo-吗",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先，Next.js 会等待 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079119902277669#heading-3",target:"_blank",rel:"noopener noreferrer",children:"generateMetadata"})," 内的数据请求完毕后，再将 UI 流式传输到客户端，这保证了响应的第一部分就会包含 ",(0,r.jsx)(n.code,{children:"<head>"})," 标签。"]}),"\n",(0,r.jsx)(n.p,{children:"其次，因为 Streaming 是流式渲染，HTML 中会包含最终渲染的内容，所以它不会影响 SEO。"}),"\n",(0,r.jsxs)(n.h3,{id:"suspense-如何控制渲染顺序",children:["Suspense 如何控制渲染顺序？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#suspense-如何控制渲染顺序",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在刚才的例子中，我们是将三个组件同时进行渲染，哪个组件的数据先返回，就先渲染哪个组件。"}),"\n",(0,r.jsxs)(n.p,{children:["但有的时候，希望按照某种顺序展示组件，比如先展示 ",(0,r.jsx)(n.code,{children:"PostFeed"}),"，再展示",(0,r.jsx)(n.code,{children:"Weather"}),"，最后展示",(0,r.jsx)(n.code,{children:"Recommend"}),"，此时你可以将 Suspense 组件进行嵌套："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Suspense } from 'react'\n\nconst sleep = ms => new Promise(r => setTimeout(r, ms));\n\nasync function PostFeed() {\n  await sleep(2000)\n  return <h1>Hello PostFeed</h1>\n}\n\nasync function Weather() {\n  await sleep(8000)\n  return <h1>Hello Weather</h1>\n}\n\nasync function Recommend() {\n  await sleep(5000)\n  return <h1>Hello Recommend</h1>\n}\n\nexport default function Dashboard() {\n  return (\n    <section style={{padding: '20px'}}>\n      <Suspense fallback={<p>Loading PostFeed Component</p>}>\n        <PostFeed />\n        <Suspense fallback={<p>Loading Weather Component</p>}>\n          <Weather />\n          <Suspense fallback={<p>Loading Recommend Component</p>}>\n            <Recommend />\n          </Suspense>\n        </Suspense>\n      </Suspense>\n    </section>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"那么问题来了，此时页面的最终加载时间是多少秒？是请求花费时间最长的 8s 还是 2 + 8 + 5 = 15s 呢？让我们看下效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"suspense1.gif"})}),"\n",(0,r.jsx)(n.p,{children:"答案是 8s，这些数据请求是同时发送的，所以当 Weather 组件返回的时候，Recommend 组件立刻就展示了出来。"}),"\n",(0,r.jsx)(n.p,{children:"注意：这也是因为这里的数据请求并没有前后依赖关系，如果有那就另讲了。"}),"\n",(0,r.jsxs)(n.h2,{id:"streaming",children:["Streaming",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#streaming",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"介绍",children:["介绍",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#介绍",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Suspense 背后的这种技术称之为 Streaming。将页面的 HTML 拆分成多个 chunks，然后逐步将这些块从服务端发送到客户端。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"这样就可以更快的展现出页面的某些内容，而无需在渲染 UI 之前等待加载所有数据。提前发送的组件可以提前开始水合，这样当其他部分还在加载的时候，用户可以和已完成水合的组件进行交互，有效改善用户体验。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["Streaming 可以有效的阻止耗时长的数据请求阻塞整个页面加载的情况。它还可以减少加载",(0,r.jsx)(n.a,{href:"https://web.dev/articles/ttfb?hl=zh-cn",target:"_blank",rel:"noopener noreferrer",children:"第一个字节所需时间（TTFB）"}),"和",(0,r.jsx)(n.a,{href:"https://developer.chrome.com/docs/lighthouse/performance/first-contentful-paint/",target:"_blank",rel:"noopener noreferrer",children:"首次内容绘制（FCP）"}),"，有助于缩短",(0,r.jsx)(n.a,{href:"https://developer.chrome.com/en/docs/lighthouse/performance/interactive/",target:"_blank",rel:"noopener noreferrer",children:"可交互时间（TTI）"}),"，尤其在速度慢的设备上。"]}),"\n",(0,r.jsx)(n.p,{children:"传统 SSR："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"使用 Streaming 后："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h3,{id:"使用",children:["使用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 Next.js 中有两种实现 Streaming 的方法："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["页面级别，使用 ",(0,r.jsx)(n.code,{children:"loading.jsx"})]}),"\n",(0,r.jsxs)(n.li,{children:["特定组件，使用 ",(0,r.jsx)(n.code,{children:"<Suspense>"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"<Suspense>"})," 上节已经介绍过，",(0,r.jsx)(n.code,{children:"loading.jsx"})," 在 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7308681814742417434#heading-11",target:"_blank",rel:"noopener noreferrer",children:"《路由篇 | App Router》"}),"也介绍过。这里分享一个使用 ",(0,r.jsx)(n.code,{children:"loading.jsx"})," 的小技巧，那就是当多个页面复用一个 loading.jsx 效果的时候可以借助路由组来实现。"]}),"\n",(0,r.jsx)(n.p,{children:"目录结构如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"app                  \n├─ (dashboard)       \n│  ├─ about          \n│  │  └─ page.js     \n│  ├─ settings       \n│  │  └─ page.js     \n│  ├─ team           \n│  │  └─ page.js     \n│  ├─ layout.js      \n│  └─ loading.js         \n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其中 ",(0,r.jsx)(n.code,{children:"app/(dashboard)/layout.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import Link from \'next/link\'\n\nexport default function DashboardLayout({\n  children,\n}) {\n  return (\n    <section>\n        <nav className="flex items-center justify-center gap-10 text-blue-600 mb-6">\n          <Link href="/about">About</Link>\n          <Link href="/settings">Settings</Link>\n          <Link href="/team">Team</Link>\n        </nav>\n      {children}\n    </section>\n  )\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"app/(dashboard)/loading.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'export default function DashboardLoading() {\n  return  <div className="h-60 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">Loading</div>\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"app/(dashboard)/about/page.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const sleep = ms => new Promise(r => setTimeout(r, ms));\n\nexport default async function About() {\n  await sleep(2000)\n  return (\n    <div className="h-60 flex-1 rounded-xl bg-teal-400 text-white flex items-center justify-center">Hello, About!</div>\n  )\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"剩余两个组件代码与 About 组件类似。最终的效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"suspense2.gif"})}),"\n",(0,r.jsxs)(n.p,{children:["在线查看效果和代码：",(0,r.jsx)(n.a,{href:"https://codesandbox.io/p/devbox/loading-jsx-zx4mfy?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cltdu2u3z00073b6i08865iv9%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cltdu2u3z00023b6ijugbhpax%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cltdu2u3z00043b6i2wg1p3h8%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cltdu2u3z00063b6ig9e8y777%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cltdu2u3z00023b6ijugbhpax%2522%253A%257B%2522id%2522%253A%2522cltdu2u3z00023b6ijugbhpax%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cltdu2u3z00063b6ig9e8y777%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltdu2u3z00053b6i3v1assnv%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fabout%2522%257D%255D%252C%2522id%2522%253A%2522cltdu2u3z00063b6ig9e8y777%2522%252C%2522activeTabId%2522%253A%2522cltdu2u3z00053b6i3v1assnv%2522%257D%252C%2522cltdu2u3z00043b6i2wg1p3h8%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltdu2u3z00033b6i19ll8rh0%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522cltdu2u3z00043b6i2wg1p3h8%2522%252C%2522activeTabId%2522%253A%2522cltdu2u3z00033b6i19ll8rh0%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D",target:"_blank",rel:"noopener noreferrer",children:"CodeSandbox Loading"})]}),"\n",(0,r.jsxs)(n.h3,{id:"缺点",children:["缺点",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缺点",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Suspense 和 Streaming 确实很好，将原本只能先获取数据、再渲染水合的传统 SSR 改为渐进式渲染水合，但还有一些问题没有解决。就比如用户下载的 JavaScript 代码，该下载的代码还是没有少，可是用户真的需要下载那么多的 Javascript 代码吗？又比如所有的组件都必须在客户端进行水合，对于不需要交互性的组件其实没有必要进行水合。"}),"\n",(0,r.jsx)(n.p,{children:"为了解决这些问题，目前的最终方案就是上一篇介绍的 RSC："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"当然这并不是说 RSC 可以替代 Suspense，实际上两者可以组合使用，带来更好的性能体验。我们会在实战篇的项目中慢慢体会。"}),"\n",(0,r.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming",target:"_blank",rel:"noopener noreferrer",children:"https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://vercel.com/blog/how-streaming-helps-build-faster-web-applications",target:"_blank",rel:"noopener noreferrer",children:"https://vercel.com/blog/how-streaming-helps-build-faster-web-applications"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.builder.io/blog/why-react-server-components#suspense-for-server-side-rendering",target:"_blank",rel:"noopener noreferrer",children:"https://www.builder.io/blog/why-react-server-components#suspense-for-server-side-rendering"})}),"\n"]})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}let b=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F10.%E6%B8%B2%E6%9F%93%E7%AF%87%20_%20Suspense%20%E4%B8%8E%20Streaming.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"传统 SSR",id:"传统-ssr",depth:2},{text:"Suspense",id:"suspense",depth:2},{text:"Suspense 会影响 SEO 吗？",id:"suspense-会影响-seo-吗",depth:3},{text:"Suspense 如何控制渲染顺序？",id:"suspense-如何控制渲染顺序",depth:3},{text:"Streaming",id:"streaming",depth:2},{text:"介绍",id:"介绍",depth:3},{text:"使用",id:"使用",depth:3},{text:"缺点",id:"缺点",depth:3},{text:"参考链接",id:"参考链接",depth:2}],title:"10.渲染篇 _ Suspense 与 Streaming",headingTitle:"10.渲染篇 _ Suspense 与 Streaming",frontmatter:{}}}}]);