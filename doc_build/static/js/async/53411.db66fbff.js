"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["53411"],{154428:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r(552676),a=r(740453);let t=r.p+"static/image/b3af96d400827fbe915640631895ca6b.7c99b8f5.webp",o=r.p+"static/image/a76de1cdaecfbe67d17126b221cf9569.ba3b3ae1.gif",c=r.p+"static/image/f7f870dfe754f330195af1df8a10def9.2e5b7b1d.gif";function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ol:"ol",li:"li",code:"code",pre:"pre",img:"img",h3:"h3"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"26优化篇-_-懒加载",children:["26.优化篇 _ 懒加载",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26优化篇-_-懒加载",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"懒加载",children:["懒加载",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#懒加载",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"懒加载，英文：Lazy Loading，又被称为“延迟加载”，其重要性不言而喻。这是因为随着互联网的发展，网页资源大小在快速增长，为了提高加载的速度，带来更好的用户体验，便产生了懒加载这种技术理念，减少初始加载的资源，让部分资源等到合适的时候再去加载。"}),"\n",(0,s.jsx)(n.p,{children:"Next.js 基于懒加载做了很多优化，实现了延迟加载客户端组件和导入库，只在需要的时候才在客户端引入它们。举个例子，比如延迟加载模态框相关的代码，直到用户点击打开的时候。"}),"\n",(0,s.jsx)(n.p,{children:"在 Next.js 中有两种方式实现懒加载："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"React.lazy()"})," 和 ",(0,s.jsx)(n.code,{children:"Suspense"})]}),"\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"next/dynamic"}),"实现动态导入"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"默认情况下，服务端组件自动进行代码分隔，并且可以使用流将 UI 片段逐步发送到客户端，所以懒加载应用于客户端。"}),"\n",(0,s.jsxs)(n.h2,{id:"reactlazy-与-suspense",children:["React.lazy 与 Suspense",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reactlazy-与-suspense",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们先讲讲 React 的 lazy 方法，lazy 可以实现延迟加载组件代码，直到组件首次被渲染。换句话说，直到组件需要渲染的时候才加载组件的代码。使用示例如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { lazy } from 'react';\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["通过在组件外部调用 lazy 方法声明一个懒加载的 React 组件，非常适合搭配 ",(0,s.jsx)(n.code,{children:"<Suspense>"})," 组件使用："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"<Suspense fallback={<Loading />}>\n  <h2>Preview</h2>\n  <MarkdownPreview />\n</Suspense>\n"})}),"\n",(0,s.jsx)(n.p,{children:"一个简单完整的例子如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Suspense, lazy } from 'react';\n\nconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n\nexport default function Page() {\n  return (\n    <Suspense fallback={'loading'}>\n      <h2>Preview</h2>\n      <MarkdownPreview />\n    </Suspense>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"当然这个例子在实际开发中并无意义，因为延迟加载的目的在于需要的时候才去加载，结果这里没有条件判断就直接开始了加载，那还用延迟加载干什么，徒然降低了性能和加载时间。"}),"\n",(0,s.jsxs)(n.p,{children:["React 官网提供了一个非常的好的完整示例：",(0,s.jsx)(n.a,{href:"https://react.dev/reference/react/lazy#suspense-for-code-splitting",target:"_blank",rel:"noopener noreferrer",children:"https://react.dev/reference/react/lazy#suspense-for-code-splitting"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useState, Suspense, lazy } from 'react';\nimport Loading from './Loading.js';\n\nconst MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));\n\nexport default function MarkdownEditor() {\n  const [showPreview, setShowPreview] = useState(false);\n  const [markdown, setMarkdown] = useState('Hello, **world**!');\n  return (\n    <>\n      <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />\n      <label>\n        <input type=\"checkbox\" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />\n        Show preview\n      </label>\n      <hr />\n      {showPreview && (\n        <Suspense fallback={<Loading />}>\n          <h2>Preview</h2>\n          <MarkdownPreview markdown={markdown} />\n        </Suspense>\n      )}\n    </>\n  );\n}\n\n// 添加一个固定的延迟时间，以便你可以看到加载状态\nfunction delayForDemo(promise) {\n  return new Promise(resolve => {\n    setTimeout(resolve, 2000);\n  }).then(() => promise);\n}\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在这个例子中，只有当用户点击了 Show preview 选择框，",(0,s.jsx)(n.code,{children:"showPreview"})," 为 ",(0,s.jsx)(n.code,{children:"true"})," 的时候才去加载 ",(0,s.jsx)(n.code,{children:"<Suspense>"})," 和 ",(0,s.jsx)(n.code,{children:"<MarkdownPreview>"})," 组件，这是更符合实际开发中的例子。"]}),"\n",(0,s.jsx)(n.p,{children:"效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"1.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"nextdynamic",children:["next/dynamic",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nextdynamic",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["不过开发 Next.js 应用的时候，大部分时候并不需要用到 React.lazy 和 Suspense，使用 ",(0,s.jsx)(n.code,{children:"next/dynamic"})," 即可，它本质就是 React.lazy 和 Suspense 的复合实现。在 ",(0,s.jsx)(n.code,{children:"app"}),"和 ",(0,s.jsx)(n.code,{children:"pages"}),"目录下都可以使用。"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-基本示例",children:["1. 基本示例",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-基本示例",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"它的基本用法如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import dynamic from 'next/dynamic'\n \nconst WithCustomLoading = dynamic(\n  () => import('../components/WithCustomLoading'),\n  {\n    loading: () => <p>Loading...</p>,\n  }\n)\n \nexport default function Page() {\n  return (\n    <div>\n      <WithCustomLoading />\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"dynamic 函数的第一个参数表示加载函数，用法同 lazy 函数。第二个参数表示配置项，可以设置加载组件，如同 Suspense 中的 fallback。看似很简单，但使用的时候也有很多细节要注意："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"import() 中的路径不能是模板字符串或者是变量"}),"\n",(0,s.jsx)(n.li,{children:"import() 必须在 dynamic() 中调用"}),"\n",(0,s.jsx)(n.li,{children:"dynamic() 跟 lazy() 函数一样，需要放在模块顶层"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"前面我们讲过懒加载只应用于客户端的，如果动态导入的是一个服务端组件，只有这个服务端组件中的客户端组件才会被懒加载，服务端组件本身是不会懒加载的。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nimport dynamic from 'next/dynamic'\n \n// Server Component:\nconst ServerComponent = dynamic(() => import('../components/ServerComponent'))\n \nexport default function ServerComponentExample() {\n  return (\n    <div>\n      <ServerComponent />\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-跳过-ssr",children:["2. 跳过 SSR",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-跳过-ssr",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["之前讲客户端组件和服务端组件的时候，客户端组件默认也是会被预渲染的（SSR）。如果要禁用客户端组件的预渲染，可以将 ",(0,s.jsx)(n.code,{children:"ssr"})," 选项设置为 ",(0,s.jsx)(n.code,{children:"false"}),"。让我们看个例子："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n// app/page.js\nimport { useState } from 'react'\nimport dynamic from 'next/dynamic'\n \n// Client Components:\nconst ComponentA = dynamic(() => import('../components/a.js'))\nconst ComponentB = dynamic(() => import('../components/b.js'))\nconst ComponentC = dynamic(() => import('../components/c.js'), { ssr: false })\n \nexport default function ClientComponentExample() {\n  const [showMore, setShowMore] = useState(false)\n \n  return (\n    <div>\n      {/* 立刻加载，但会使用一个独立的客户端 bundle */}\n      <ComponentA />\n \n      {/* 按需加载 */}\n      {showMore && <ComponentB />}\n      <button onClick={() => setShowMore(!showMore)}>Toggle</button>\n \n      {/* 只在客户端加载 */}\n      <ComponentC />\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"三个组件内容相同，都是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n\nexport default function Page() {\n  return <h1>Hello World!</h1>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"加载效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"10.gif"})}),"\n",(0,s.jsxs)(n.p,{children:["从效果上看，设置 ",(0,s.jsx)(n.code,{children:"ssr"})," 为 ",(0,s.jsx)(n.code,{children:"false"})," 的 ",(0,s.jsx)(n.code,{children:"<ComponentC>"})," 会比 ",(0,s.jsx)(n.code,{children:"<ComponentA>"})," 晚显示，",(0,s.jsx)(n.code,{children:"<ComponentB>"})," 在点击的时候才会显示。"]}),"\n",(0,s.jsx)(n.p,{children:"这三个组件的加载到底有什么区别呢？"}),"\n",(0,s.jsxs)(n.p,{children:["首先是预渲染，",(0,s.jsx)(n.code,{children:"ComponentA"})," 默认会被预渲染，",(0,s.jsx)(n.code,{children:"ComponentC"})," 因为设置了 ",(0,s.jsx)(n.code,{children:"ssr"})," 为 ",(0,s.jsx)(n.code,{children:"false"}),"，不会被预渲染，也就是说，如果查看页面的 HTML 源码，可以看到这样的渲染代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<div>\n  <h1>Hello World!</h1>\n  <button>Toggle</button>\n  <template data-dgst="NEXT_DYNAMIC_NO_SSR_CODE"></template>\n</div>\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ComponentA"}),"  渲染了 HTML，",(0,s.jsx)(n.code,{children:"ComponentC"})," 只是留了一个占位。所以加载的时候，",(0,s.jsx)(n.code,{children:"ComponentA"})," 立刻就渲染了出来，",(0,s.jsx)(n.code,{children:"ComponentC"})," 会先显示空白，然后再展示出内容。"]}),"\n",(0,s.jsxs)(n.p,{children:["其次是 bundle，三个动态加载的组件都会打包成一个单独的包，",(0,s.jsx)(n.code,{children:"ComponentA"})," 和 ",(0,s.jsx)(n.code,{children:"ComponentC"})," 的包都会尽快加载，CompoentB 的包会在点击按钮的时候才加载："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["那你可能要问了，这个组件不就一个 Hello World！吗？",(0,s.jsx)(n.code,{children:"ComponentB"})," 在点击的时候才渲染，确实需要加载。",(0,s.jsx)(n.code,{children:"ComponentC"})," 只有一个占位，也确实需要加载，可 ",(0,s.jsx)(n.code,{children:"ComponentA"})," 有什么可加载的？"]}),"\n",(0,s.jsx)(n.p,{children:"这个例子比较简单，但实际开发并不如此，SSR 只能渲染出无交互的 HTML，还需要再加载一个 JS 文件，用于给比如 HTML 元素上添加事件，使其具有交互能力等（这个过程又称为水合）。所以使用懒加载的组件 Next.js 会打包一个单独的 bundle。"}),"\n",(0,s.jsxs)(n.h3,{id:"3-导入命名导出named-exports",children:["3. 导入命名导出（Named Exports）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-导入命名导出named-exports",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"JavaScript 支持两种导出方式：默认导出（default export）和命名导出（named export）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 默认导出\nexport default function add(a, b) {\n  return a + b;\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 命名导出\nexport function add(a, b) {\n  return a + b;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果要动态导入一个命名导出的组件，用法会略有不同，直接举个示例代码："}),"\n",(0,s.jsx)(n.p,{children:"假如要导入 Hello 组件，然而 Hello 组件以命名导出的形式导出："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n// components/hello.js\nexport function Hello() {\n  return <p>Hello!</p>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"关键字 import 可以像调用函数一样来动态的导入模块。以这种方式调用，将返回一个 promise，将模块作为对象传入 then 函数："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nimport dynamic from 'next/dynamic'\n \nconst ClientComponent = dynamic(() =>\n  import('../components/hello').then((mod) => mod.Hello)\n)\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"加载外部库",children:["加载外部库",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载外部库",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"import()"}),"函数可以按需加载外部库，比如当用户在搜索框输入的时候才开始加载模糊搜索库，这个例子就演示了如何使用 ",(0,s.jsx)(n.code,{children:"fuse.js"})," 实现模糊搜索。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n// app/page.js\nimport { useState } from 'react'\n \nconst names = ['Tim', 'Joe', 'Bel', 'Lee']\n \nexport default function Page() {\n  const [results, setResults] = useState()\n \n  return (\n    <div>\n      <input\n        type=\"text\"\n        placeholder=\"Search\"\n        onChange={async (e) => {\n          const { value } = e.currentTarget\n          const Fuse = (await import('fuse.js')).default\n          const fuse = new Fuse(names)\n \n          setResults(fuse.search(value))\n        }}\n      />\n      <pre>Results: {JSON.stringify(results, null, 2)}</pre>\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"谈谈懒加载",children:["谈谈懒加载",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#谈谈懒加载",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本篇的最后，我们简单聊聊在开发中使用懒加载的感受。Next.js 中的懒加载看似很好，但其实应用中有很多局限。就以刚才的例子为例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'use client'\n \nimport { useState } from 'react'\nimport dynamic from 'next/dynamic'\n \nconst ComponentA = dynamic(() => import('../components/a.js'))\nconst ComponentB = dynamic(() => import('../components/b.js'))\nconst ComponentC = dynamic(() => import('../components/c.js'), { ssr: false })\n \nexport default function ClientComponentExample() {\n  const [showMore, setShowMore] = useState(false)\n \n  return (\n    <div>\n      <ComponentA />\n      {showMore && <ComponentB />}\n      <button onClick={() => setShowMore(!showMore)}>Toggle</button>\n      <ComponentC />\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"首先，为了实现懒加载，我们需要将组件抽离到单独的文件中，这样做虽然有些繁琐，倒也可以接受。"}),"\n",(0,s.jsx)(n.p,{children:"其次，在这个例子中，其实只有 ComponentB 应用懒加载是有用的，ComponentA 和 ComponentC 应用懒加载，会导致初始加载的时候多加载两个 bundle，反而因为浏览器同时请求多个 bundle 降低了加载速度。所以懒加载的例子都是应用于那些初始并不渲染的组件。"}),"\n",(0,s.jsx)(n.p,{children:"最后，为了保证用户有一个流畅的体验，其实我们并不希望交互的时候才开始获取 JS，代码其实是应该预获取的。但是预获取的逻辑是需要开发者自己定义的。这就造成了更多的工作量。"}),"\n",(0,s.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/vercel/next.js/blob/canary/packages/next/src/shared/lib/dynamic.tsx",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/vercel/next.js/blob/canary/packages/next/src/shared/lib/dynamic.tsx"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.builder.io/blog/the-challenges-of-lazy-loading-in-javascript",target:"_blank",rel:"noopener noreferrer",children:"https://www.builder.io/blog/the-challenges-of-lazy-loading-in-javascript"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.fullctx.dev/p/lazy-loading-in-react-and-nextjs",target:"_blank",rel:"noopener noreferrer",children:"https://www.fullctx.dev/p/lazy-loading-in-react-and-nextjs"})}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F26.%E4%BC%98%E5%8C%96%E7%AF%87%20_%20%E6%87%92%E5%8A%A0%E8%BD%BD.md"]={toc:[{text:"懒加载",id:"懒加载",depth:2},{text:"React.lazy 与 Suspense",id:"reactlazy-与-suspense",depth:2},{text:"next/dynamic",id:"nextdynamic",depth:2},{text:"1. 基本示例",id:"1-基本示例",depth:3},{text:"2. 跳过 SSR",id:"2-跳过-ssr",depth:3},{text:"3. 导入命名导出（Named Exports）",id:"3-导入命名导出named-exports",depth:3},{text:"加载外部库",id:"加载外部库",depth:2},{text:"谈谈懒加载",id:"谈谈懒加载",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"26.优化篇 _ 懒加载",headingTitle:"26.优化篇 _ 懒加载",frontmatter:{}}}}]);