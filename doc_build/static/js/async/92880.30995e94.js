"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["92880"],{905058:function(e,n,s){s.r(n),s.d(n,{default:()=>i});var t=s(552676),c=s(740453);function r(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",pre:"pre",ol:"ol",li:"li",h3:"h3",strong:"strong",blockquote:"blockquote",h1:"h1"},(0,c.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在开启本小节之前，我们先看一个有意思的示例，组件上有一个动态文本节点 ",(0,t.jsx)(n.code,{children:"{{ msg }}"}),"，但是却有 ",(0,t.jsx)(n.code,{children:"2"})," 处定义了 ",(0,t.jsx)(n.code,{children:"msg"})," 响应式数据；另外有一个按钮，点击后会修改响应式数据。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ msg }}</p>\n  <button @click=\"changeMsg\">点击试试</button>\n</template>\n<script>\n  import { ref } from 'vue'\n  export default {\n    data() {\n      return {\n        msg: 'msg from data'\n      }\n    },\n    setup() {\n      const msg = ref('msg from setup')\n      return {\n        msg\n      }\n    },\n    methods: {\n      changeMsg() {\n        this.msg = 'change'\n      }\n    }\n  }\n<\/script>\n"})}),"\n",(0,t.jsx)(n.p,{children:"思考一下："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"界面显示的内容是什么？"}),"\n",(0,t.jsxs)(n.li,{children:["点击按钮后，修改的是哪部分的数据？是 ",(0,t.jsx)(n.code,{children:"data"})," 中定义的，还是 ",(0,t.jsx)(n.code,{children:"setup"})," 中的呢？"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"先别急着找答案，相信你阅读完这一节，一定会得到答案。"}),"\n",(0,t.jsxs)(n.p,{children:["上一节，我们知道了根组件在初始化渲染的过程中，会执行 ",(0,t.jsx)(n.code,{children:"mountComponent"})," 的函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function mountComponent(initialVNode, container, parentComponent) {\n  // 1. 先创建一个 component instance\n  const instance = (initialVNode.component = createComponentInstance(\n    initialVNode,\n    parentComponent\n  ));\n  \n  // 2. 初始化组件实例\n  setupComponent(instance);\n\n  // 3. 设置并运行带副作用的渲染函数\n  setupRenderEffect(instance, initialVNode, container);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上文，我们简单介绍了关于 ",(0,t.jsx)(n.code,{children:"setupComponent"})," 函数的作用是为了对实例化后的组件中的属性做一些优化、处理、赋值等操作。本小节我们将重点介绍 ",(0,t.jsx)(n.code,{children:"setupComponent"})," 的内部实现和作用。"]}),"\n",(0,t.jsxs)(n.h2,{id:"初始化组件实例",children:["初始化组件实例",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化组件实例",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["我们再来回顾一下 ",(0,t.jsx)(n.code,{children:"setupComponent"})," 在源码中的实现："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export function setupComponent(instance, isSSR = false) {\n  const { props, children } = instance.vnode\n  \n  // 判断组件是否是有状态的组件\n  const isStateful = isStatefulComponent(instance)\n  \n  // 初始化 props\n  initProps(instance, props, isStateful, isSSR)\n  \n  // 初始化 slots\n  initSlots(instance, children)\n\n  // 如果是有状态组件，那么去设置有状态组件实例\n  const setupResult = isStateful\n    ? setupStatefulComponent(instance, isSSR)\n    : undefined\n    \n  return setupResult\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"setupComponent"})," 方法做了什么？"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["通过 ",(0,t.jsx)(n.code,{children:"isStatefulComponent(instance)"})," 判断是否是有状态的组件；"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"initProps"})," 初始化 ",(0,t.jsx)(n.code,{children:"props"}),"；"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"initSlots"})," 初始化 ",(0,t.jsx)(n.code,{children:"slots"}),"；"]}),"\n",(0,t.jsxs)(n.li,{children:["根据组件是否是有状态的，来决定是否需要执行 ",(0,t.jsx)(n.code,{children:"setupStatefulComponent"})," 函数。"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["其中， ",(0,t.jsx)(n.code,{children:"isStatefulComponent"})," 判断是否是有状态的组件的函数如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["前面我们已经说过了，",(0,t.jsx)(n.code,{children:"ShapeFlags"})," 在遇到组件类型的 ",(0,t.jsx)(n.code,{children:"type = Object"})," 时，",(0,t.jsx)(n.code,{children:"vnode"})," 的",(0,t.jsx)(n.code,{children:"shapeFlags = ShapeFlags.STATEFUL_COMPONENT"}),"。所以这里会执行 ",(0,t.jsx)(n.code,{children:"setupStatefulComponent"})," 函数。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function setupStatefulComponent(instance, isSSR) {\n  // 定义 Component 变量\n  const Component = instance.type\n\n  // 1. 创建渲染代理的属性访问缓存\n  instance.accessCache = Object.create(null)\n  // 2. 创建渲染上下文代理, proxy 对象其实是代理了 instance.ctx 对象\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n  // 3. 执行 setup 函数\n  const { setup } = Component\n  if (setup) {\n    // 如果 setup 函数带参数，则创建一个 setupContext\n    const setupContext = (instance.setupContext =\n      setup.length > 1 ? createSetupContext(instance) : null)\n    // 执行 setup 函数，获取结果\n    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext])\n    // 处理 setup 执行结果\n    handleSetupResult(instance, setupResult)\n  } else {\n    // 4. 完成组件实例设置\n    finishComponentSetup(instance, isSSR)\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"setupStatefulComponent"})," 字面意思就是设置有状态组件，那么什么是有状态组件呢？简单而言，就是对于有状态组件，",(0,t.jsx)(n.code,{children:"Vue"})," 内部会保留组件状态数据。相对于有状态组件而言，",(0,t.jsx)(n.code,{children:"Vue"})," 还存在一种函数组件 ",(0,t.jsx)(n.code,{children:"FUNCTIONAL_COMPONENT"}),"，一起看个示例："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import { ref } from 'vue';\n\nexport default () => {\n  let num = ref(0);\n  const plusNum = () => {\n    num.value ++;\n  };\n  return (\n    <div>\n      <button onClick={plusNum}>\n        { num.value }\n      </button>\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这个函数点击按钮时，",(0,t.jsx)(n.code,{children:"num"})," 的值并不会按照我们预期那样值会一直递增，因为它是一个函数组件，函数组件内部是没有状态保持的，所以 ",(0,t.jsx)(n.code,{children:"num"})," 数据更新时，组件会重新渲染，",(0,t.jsx)(n.code,{children:"num"})," 的值永远不变一直是 ",(0,t.jsx)(n.code,{children:"0"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["所以在这个时候，为了能符合我们预期的结果，我们需要将其设置成有状态的组件。我们可以通过 ",(0,t.jsx)(n.code,{children:"defineComponent"})," 函数包装一下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import { ref, defineComponent } from 'vue';\n\nexport default defineComponent(() => {\n  let num = ref(0);\n  const plusNum = () => {\n    num.value ++;\n  };\n  \n  return () => (\n    <div>\n      <button onClick={plusNum}>\n        { num.value }\n      </button>\n    </div>\n  )\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"defineComponent"})," 返回的是个对象类型的 ",(0,t.jsx)(n.code,{children:"type"}),"，所以就变成了有状态组件。"]}),"\n",(0,t.jsxs)(n.p,{children:["好了，搞清楚什么是有状态组件后，我们接着回到 ",(0,t.jsx)(n.code,{children:"setupStatefulComponent"})," 实现中，来一步步地分析其核心实现的原理。"]}),"\n",(0,t.jsxs)(n.h2,{id:"创建渲染上下文代理",children:["创建渲染上下文代理",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#创建渲染上下文代理",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["首先我们看 ",(0,t.jsx)(n.code,{children:"1-2"})," 两个步骤，关于第一点：为什么要创建渲染代理的属性访问缓存呢？这里先卖个关子，先看第二步：创建渲染上下文代理，这里为什么要对 ",(0,t.jsx)(n.code,{children:"instance.ctx"})," 做代理呢？如果熟悉 ",(0,t.jsx)(n.code,{children:"Vue 2"})," 的小伙伴应该了解对于 ",(0,t.jsx)(n.code,{children:"Vue 2"})," 的 ",(0,t.jsx)(n.code,{children:"Options API"})," 的写法如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ num }}</p>\n</template>\n<script>\nexport default {\n  data() {\n    num: 1\n  },\n  mounted() {\n    this.num = 2\n  }\n}\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Vue 2.x"})," 是如何实现访问 ",(0,t.jsx)(n.code,{children:"this.num"})," 获取到 ",(0,t.jsx)(n.code,{children:"num"})," 的值，而不是通过 ",(0,t.jsx)(n.code,{children:"this._data.num"})," 来获取 ",(0,t.jsx)(n.code,{children:"num"})," 的值呢？其实 ",(0,t.jsx)(n.code,{children:"Vue 2.x"})," 版本中，为 ",(0,t.jsx)(n.code,{children:"_data"})," 设置了一层代理："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"_proxy(options.data);\n\nfunction _proxy (data) {\n  const that = this;\n  Object.keys(data).forEach(key => {\n    Object.defineProperty(that, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return that._data[key];\n      },\n      set: function proxySetter (val) {\n        that._data[key] = val;\n      }\n    })\n  });\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["本质就是通过\xa0",(0,t.jsx)(n.code,{children:"Object.defineProperty"}),"\xa0使在访问\xa0",(0,t.jsx)(n.code,{children:"this"}),"\xa0上的某属性时从\xa0",(0,t.jsx)(n.code,{children:"this._data"}),"\xa0中读取（写入）。"]}),"\n",(0,t.jsxs)(n.p,{children:["而 ",(0,t.jsx)(n.code,{children:"Vue 3"})," 也在这里做了类似的事情，",(0,t.jsx)(n.code,{children:"Vue 3"})," 内部有很多状态属性，存储在不同的对象上，比如 ",(0,t.jsx)(n.code,{children:"setupState"}),"、",(0,t.jsx)(n.code,{children:"ctx"}),"、",(0,t.jsx)(n.code,{children:"data"}),"、",(0,t.jsx)(n.code,{children:"props"}),"。这样用户取数据就会考虑具体从哪个对象中获取，这无疑增加了用户的使用负担，所以对 ",(0,t.jsx)(n.code,{children:"instance.ctx"})," 进行代理，然后根据属性优先级关系依次完成从特定对象上获取值。"]}),"\n",(0,t.jsxs)(n.h3,{id:"get",children:["get",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#get",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["了解了代理的功能后，我们来具体看一下是如何实现代理功能的，也就是 ",(0,t.jsx)(n.code,{children:"proxy"})," 的 ",(0,t.jsx)(n.code,{children:"PublicInstanceProxyHandlers"})," 它的实现。先看一下 ",(0,t.jsx)(n.code,{children:"get"})," 函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    const { ctx, setupState, data, props, accessCache, type, appContext } = instance\n    let normalizedProps\n    if (key[0] !== '$') {\n      // 从缓存中获取当前 key 存在于哪个属性中\n      const n = accessCache![key]\n      if (n !== undefined) {\n        switch (n) {\n          case AccessTypes.SETUP:\n            return setupState[key]\n          case AccessTypes.DATA:\n            return data[key]\n          case AccessTypes.CONTEXT:\n            return ctx[key]\n          case AccessTypes.PROPS:\n            return props![key]\n        }\n      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n        // 从 setupState 中取\n        accessCache![key] = AccessTypes.SETUP\n        return setupState[key]\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        // 从 data 中取\n        accessCache![key] = AccessTypes.DATA\n        return data[key]\n      } else if (\n        (normalizedProps = instance.propsOptions[0]) &&\n        hasOwn(normalizedProps, key)\n      ) {\n        // 从 props 中取\n        accessCache![key] = AccessTypes.PROPS\n        return props![key]\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        // 从 ctx 中取\n        accessCache![key] = AccessTypes.CONTEXT\n        return ctx[key]\n      } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\n        // 都取不到\n        accessCache![key] = AccessTypes.OTHER\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key]\n    let cssModule, globalProperties\n    if (publicGetter) {\n      // 以 $ 保留字开头的相关函数和方法\n      // ...\n    } else if (\n      // css module\n    (cssModule = type.__cssModules) && (cssModule = cssModule[key])\n    ) {\n      // ...\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      // ...\n    } else if (\n      // 全局属性\n      ((globalProperties = appContext.config.globalProperties),\n      hasOwn(globalProperties, key))\n    ) {\n      // ...\n    } else if (__DEV__) {\n      // 一些告警\n      // ...\n    }\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里，可以回答我们的第一步 ",(0,t.jsx)(n.code,{children:"创建渲染代理的属性访问缓存"})," 这个步骤的问题了。如果我们知道 ",(0,t.jsx)(n.code,{children:"key"})," 存在于哪个对象上，那么就可以直接通过对象取值的操作获取属性上的值了。如果我们不知道用户访问的 ",(0,t.jsx)(n.code,{children:"key"})," 存在于哪个属性上，那只能通过 ",(0,t.jsx)(n.code,{children:"hasOwn"})," 的方法先判断存在于哪个属性上，再通过对象取值的操作获取属性值，这无疑是多操作了一步，而且这个判断是比较耗费性能的。如果遇到大量渲染取值的操作，那么这块就是个性能瓶颈，所以这里用了 ",(0,t.jsx)(n.code,{children:"accessCache"})," 来标记缓存 ",(0,t.jsx)(n.code,{children:"key"})," 存在于哪个属性上。这其实也",(0,t.jsx)(n.strong,{children:"相当于用一部分空间换时间的优化"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["接下来，函数首先判断 ",(0,t.jsx)(n.code,{children:"key[0] !== '$'"})," 的情况（",(0,t.jsx)(n.code,{children:"$"})," 开头的一般是 ",(0,t.jsx)(n.code,{children:"Vue"}),"  组件实例上的内置属性），在 ",(0,t.jsx)(n.code,{children:"Vue 3"})," 源码中，会依次从 ",(0,t.jsx)(n.code,{children:"setupState、data、props、ctx"})," 这几类数据中取状态值。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里的定义顺序，决定了后续取值的优先级顺序：",(0,t.jsx)(n.code,{children:"setupState"})," >",(0,t.jsx)(n.code,{children:"data"})," >",(0,t.jsx)(n.code,{children:"props"})," > ",(0,t.jsx)(n.code,{children:"ctx"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["如果 ",(0,t.jsx)(n.code,{children:"key"})," 是以 ",(0,t.jsx)(n.code,{children:"$"})," 开头，则首先会判断是否是存在于组件实例上的内置属性："]}),"\n",(0,t.jsxs)(n.p,{children:["整体的获取顺序依次是：",(0,t.jsx)(n.code,{children:"publicGetter"})," > ",(0,t.jsx)(n.code,{children:"cssModule"})," > ",(0,t.jsx)(n.code,{children:"ctx"}),"。最后，如果都取不到，那么在开发环境就会给一些告警提示。"]}),"\n",(0,t.jsxs)(n.h3,{id:"set",children:["set",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"接着继续看一下设置对象属性的代理函数："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const PublicInstanceProxyHandlers = {\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance\n    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n      // 设置 setupState\n      setupState[key] = value\n      return true\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n      // 设置 data\n      data[key] = value\n      return true\n    } else if (hasOwn(instance.props, key)) {\n      // 不能给 props 赋值\n      return false\n    }\n    if (key[0] === '$' && key.slice(1) in instance) {\n      // 不能给组件实例上的内置属性赋值\n      return false\n    } else {\n      // 用户自定义数据赋值\n      ctx[key] = value\n    }\n    return true\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["可以看到这里也是和前面 ",(0,t.jsx)(n.code,{children:"get"})," 函数类似的通过调用顺序来实现对 ",(0,t.jsx)(n.code,{children:"set"})," 函数不同属性设置优先级的，可以直观地看到优先级关系为：",(0,t.jsx)(n.code,{children:"setupState"})," > ",(0,t.jsx)(n.code,{children:"data"})," > ",(0,t.jsx)(n.code,{children:"props"}),"。同时这里也有说明：就是如果直接对 ",(0,t.jsx)(n.code,{children:"props"})," 或者组件实例上的内置属性赋值，则会告警。"]}),"\n",(0,t.jsxs)(n.h3,{id:"has",children:["has",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#has",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["最后，再看一个 ",(0,t.jsx)(n.code,{children:"proxy"})," 属性 ",(0,t.jsx)(n.code,{children:"has"})," 的实现："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const PublicInstanceProxyHandlers = {\n  has({_: { data, setupState, accessCache, ctx, appContext, propsOptions }}, key) {\n    let normalizedProps\n    return (\n      !!accessCache![key] ||\n      (data !== EMPTY_OBJ && hasOwn(data, key)) ||\n      (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\n      ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\n      hasOwn(ctx, key) ||\n      hasOwn(publicPropertiesMap, key) ||\n      hasOwn(appContext.config.globalProperties, key)\n    )\n  },\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这个函数则是依次判断 ",(0,t.jsx)(n.code,{children:"key"})," 是否存在于 ",(0,t.jsx)(n.code,{children:"accessCache"})," > ",(0,t.jsx)(n.code,{children:"data"})," > ",(0,t.jsx)(n.code,{children:"setupState"})," > ",(0,t.jsx)(n.code,{children:"prop"})," > ",(0,t.jsx)(n.code,{children:"ctx"})," > ",(0,t.jsx)(n.code,{children:"publicPropertiesMap"})," > ",(0,t.jsx)(n.code,{children:"globalProperties"}),"，然后返回结果。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"has"})," 在业务代码的使用定义如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export default {\n  created () {\n    // 这里会触发 has 函数\n    console.log('msg' in this)\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"至此，我们就搞清楚了创建上下文代理的过程。"}),"\n",(0,t.jsxs)(n.h2,{id:"调用执行-setup-函数",children:["调用执行 setup 函数",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#调用执行-setup-函数",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["一个简单的包含 ",(0,t.jsx)(n.code,{children:"CompositionAPI"})," 的 ",(0,t.jsx)(n.code,{children:"Vue 3 demo"})," 如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ msg }}</p>\n</template>\n<script>\n  export default {\n    props: {\n      msg: String\n    },\n    setup (props, setupContext) {\n      // todo\n    }\n  }\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里的 ",(0,t.jsx)(n.code,{children:"setup"})," 函数，正是在这里被调用执行的："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"// 获取 setup 函数\nconst { setup } = Component\n// 存在 setup 函数\nif (setup) {\n  // 根据 setup 函数的入参长度，判断是否需要创建 setupContext 对象\n  const setupContext = (instance.setupContext =\n    setup.length > 1 ? createSetupContext(instance) : null)\n  // 调用 setup\n  const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext])\n  // 处理 setup 执行结果\n  handleSetupResult(instance, setupResult)\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"createsetupcontext",children:["createSetupContext",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#createsetupcontext",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["因为 ",(0,t.jsx)(n.code,{children:"setupContext"})," 是 ",(0,t.jsx)(n.code,{children:"setup"})," 中的第二个参数，所以会判断 ",(0,t.jsx)(n.code,{children:"setup"})," 函数参数的长度，如果大于 ",(0,t.jsx)(n.code,{children:"1"}),"，则会通过 ",(0,t.jsx)(n.code,{children:"createSetupContext"})," 函数创建 ",(0,t.jsx)(n.code,{children:"setupContext"})," 上下文。"]}),"\n",(0,t.jsx)(n.p,{children:"该上下文创建如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function createSetupContext (instance) {\n  return {\n    get attrs() {\n      return attrs || (attrs = createAttrsProxy(instance))\n    },\n    slots: instance.slots,\n    emit: instance.emit,\n    expose\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["可以看到，",(0,t.jsx)(n.code,{children:"setupContext"})," 中包含了 ",(0,t.jsx)(n.code,{children:"attrs、slots、emit、expose"})," 这些属性。这些属性分别代表着：组件的属性、插槽、派发事件的方法 ",(0,t.jsx)(n.code,{children:"emit"}),"、以及所有想从当前组件实例导出的内容 ",(0,t.jsx)(n.code,{children:"expose"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里有个小的知识点，就是可以通过函数的 ",(0,t.jsx)(n.code,{children:"length"})," 属性来判断函数参数的个数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"function foo() {};\n\nfoo.length // 0\n\nfunction bar(a) {};\n\nbar.length // 1\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"callwitherrorhandling",children:["callWithErrorHandling",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#callwitherrorhandling",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["第二步，通过 ",(0,t.jsx)(n.code,{children:"callWithErrorHandling"})," 函数来间接执行 ",(0,t.jsx)(n.code,{children:"setup"})," 函数，其实就是执行了以下代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const setupResult = setup && setup(shallowReadonly(instance.props), setupContext); \n"})}),"\n",(0,t.jsxs)(n.p,{children:["只不过增加了对执行过程中 ",(0,t.jsx)(n.code,{children:"handleError"})," 的捕获。"]}),"\n",(0,t.jsxs)(n.p,{children:["在后续章节的阅读中，你会发现 ",(0,t.jsx)(n.code,{children:"Vue 3"})," 很多函数的调用都是通过 ",(0,t.jsx)(n.code,{children:"callWithErrorHandling"})," 来包裹的："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export function callWithErrorHandling(fn, instance, type, args = []) {\n  let res\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    handleError(err, instance, type)\n  }\n  return res\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这样的好处一方面可以由 ",(0,t.jsx)(n.code,{children:"Vue"})," 内部统一 ",(0,t.jsx)(n.code,{children:"try...catch"})," 处理用户代码运行可能出现的错误。另一方面这些错误也可以交由用户统一注册的 ",(0,t.jsx)(n.code,{children:"errorHandler"})," 进行处理，比如上报给监控系统。"]}),"\n",(0,t.jsxs)(n.h3,{id:"handlesetupresult",children:["handleSetupResult",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#handlesetupresult",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["最后执行 ",(0,t.jsx)(n.code,{children:"handleSetupResult"})," 函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function handleSetupResult(instance, setupResult) {\n  if (isFunction(setupResult)) {\n    // setup 返回渲染函数\n    instance.render = setupResult\n  }\n  else if (isObject(setupResult)) {\n    // proxyRefs 的作用就是把 setupResult 对象做一层代理\n    instance.setupState = proxyRefs(setupResult);\n  }\n  finishComponentSetup(instance)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"setup"})," 返回值不一样的话，会有不同的处理，如果 ",(0,t.jsx)(n.code,{children:"setupResult"})," 是个函数，那么会把该函数绑定到 ",(0,t.jsx)(n.code,{children:"render"})," 上。比如："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"<script>\n  import { createVnode } from 'vue'\n  export default {\n    props: {\n      msg: String\n    },\n    setup (props, { emit }) {\n      return (ctx) => {\n        return [\n          createVnode('p', null, ctx.msg)\n        ]\n      }\n    }\n  }\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["当 ",(0,t.jsx)(n.code,{children:"setupResult"})," 是一个对象的时候，我们为 ",(0,t.jsx)(n.code,{children:"setupResult"})," 对象通过 ",(0,t.jsx)(n.code,{children:"proxyRefs"})," 作了一层代理，方便用户直接访问 ",(0,t.jsx)(n.code,{children:"ref"})," 类型的值。比如，在模板中访问 ",(0,t.jsx)(n.code,{children:"setupResult"})," 中的数据，就可以省略 ",(0,t.jsx)(n.code,{children:".value"})," 的取值，而由代理来默认取 ",(0,t.jsx)(n.code,{children:".value"})," 的值。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["注意，这里 ",(0,t.jsx)(n.code,{children:"instance.setupState = proxyRefs(setupResult);"})," 之前的 Vue 源码的写法是 ",(0,t.jsx)(n.code,{children:"instance.setupState = reactive(setupResult);"})," ，至于为什么改成上面的，Vue 作者也有相关说明：",(0,t.jsxs)(n.a,{href:"https://github.com/vuejs/core/pull/1682",target:"_blank",rel:"noopener noreferrer",children:["Template auto ref unwrapping for\xa0",(0,t.jsx)(n.code,{children:"setup()"}),"\xa0return object is now applied only to the root level refs."]})]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"完成组件实例设置",children:["完成组件实例设置",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#完成组件实例设置",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["最后，到了 ",(0,t.jsx)(n.code,{children:"finishComponentSetup"})," 这个函数了："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function finishComponentSetup(instance) {\n  // type 是个组件对象\n  const Component = instance.type;\n  \n  if (!instance.render) {\n    // 如果组件没有 render 函数，那么就需要把 template 编译成 render 函数\n    if (compile && !Component.render) {\n      if (Component.template) {\n        // 这里就是 runtime 模块和 compile 模块结合点\n        // 运行时编译\n        Component.render = compile(Component.template, {\n        isCustomElement: instance.appContext.config.isCustomElement || NO\n      })\n      }\n    }\n\n    instance.render = Component.render;\n  }\n  if (__FEATURE_OPTIONS_API__ && !(__COMPAT__ && skipOptions)) {\n    // 兼容选项式组件的调用逻辑\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里主要做的就是根据 ",(0,t.jsx)(n.code,{children:"instance"})," 上有没有 ",(0,t.jsx)(n.code,{children:"render"})," 函数来判断是否需要进行运行时渲染，运行时渲染指的是在浏览器运行的过程中，动态编译 ",(0,t.jsx)(n.code,{children:"<template>"})," 标签内的内容，产出渲染函数。对于编译时渲染，则是有渲染函数的，因为模板中的内容会被 ",(0,t.jsx)(n.code,{children:"webpack"})," 中 ",(0,t.jsx)(n.code,{children:"vue-loader"})," 这样的插件进行编译。"]}),"\n",(0,t.jsxs)(n.p,{children:["另外需要注意的，这里有个 ",(0,t.jsx)(n.code,{children:"__FEATURE_OPTIONS_API__"})," 变量用来标记是否是兼容 ",(0,t.jsx)(n.code,{children:"选项式 API"})," 调用，如果我们只使用 ",(0,t.jsx)(n.code,{children:"Composition Api"})," 那么就可以通过 ",(0,t.jsx)(n.code,{children:"webpack"})," 静态变量注入的方式关闭此特性。然后交由 ",(0,t.jsx)(n.code,{children:"Tree-Shacking"})," 删除无用的代码，从而减少引用代码包的体积。"]}),"\n",(0,t.jsxs)(n.h1,{id:"3渲染器数据访问是如何被代理的",children:["3.渲染器：数据访问是如何被代理的？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3渲染器数据访问是如何被代理的",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"有了上面的一些介绍，我们再来回答一下开篇中提到的问题："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["初始化渲染的时候，会从实例上获取状态 ",(0,t.jsx)(n.code,{children:"msg"})," 的值，获取的优先级是：",(0,t.jsx)(n.code,{children:"setupState"})," >",(0,t.jsx)(n.code,{children:"data"})," >",(0,t.jsx)(n.code,{children:"props"})," > ",(0,t.jsx)(n.code,{children:"ctx"}),"。",(0,t.jsx)(n.code,{children:"setupState"})," 就是 ",(0,t.jsx)(n.code,{children:"setup"})," 函数执行后返回的状态值，所以这里渲染的是：",(0,t.jsx)(n.code,{children:"msg from setup"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["点击按钮的时候，会更新实例上的状态，更新的优先级是：",(0,t.jsx)(n.code,{children:"setupState"}),"\xa0>\xa0",(0,t.jsx)(n.code,{children:"data"}),"。所以会更新 ",(0,t.jsx)(n.code,{children:"setup"})," 中的状态数据 ",(0,t.jsx)(n.code,{children:"msg"}),"。"]}),"\n"]}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}let i=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F3.%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%9A%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"初始化组件实例",id:"初始化组件实例",depth:2},{text:"创建渲染上下文代理",id:"创建渲染上下文代理",depth:2},{text:"get",id:"get",depth:3},{text:"set",id:"set",depth:3},{text:"has",id:"has",depth:3},{text:"调用执行 setup 函数",id:"调用执行-setup-函数",depth:2},{text:"createSetupContext",id:"createsetupcontext",depth:3},{text:"callWithErrorHandling",id:"callwitherrorhandling",depth:3},{text:"handleSetupResult",id:"handlesetupresult",depth:3},{text:"完成组件实例设置",id:"完成组件实例设置",depth:2}],title:"3.渲染器：数据访问是如何被代理的？",headingTitle:"3.渲染器：数据访问是如何被代理的？",frontmatter:{}}}}]);