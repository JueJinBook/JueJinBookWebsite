"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["8912"],{114933:function(e,n,r){r.r(n),r.d(n,{default:()=>k});var c=r(552676),s=r(740453);let d=r.p+"static/image/4f877257691ee52e32ba12059294c90f.6e64dca8.webp",i=r.p+"static/image/ca44847f2b7d853e083a29d70bcd6570.5d3a149b.webp",l=r.p+"static/image/a72934fd68ce30f2d170aa953c2a5b16.648a04d0.webp",o=r.p+"static/image/ea7188216da4e1476980c9307864e60f.477139ef.webp",t=r.p+"static/image/5683e12d5cafcc9ad6e29ca5648dd242.36fc805d.webp",a=r.p+"static/image/fad4ee1c85564d06ff49ea82cfe573af.f98e4735.webp",h=r.p+"static/image/d8ad3de9f4169ffd71ba4fe6784bae6e.463af047.webp",p=r.p+"static/image/56cdce05ecaa3065a599e338829cb508.e6f85608.webp",x=r.p+"static/image/2c65a37a7f99328004e224fdc7528401.f2a95459.webp",j=r.p+"static/image/ab9e28c87146b44d42a433f3f8b4e097.a7f1a2dc.webp",u=r.p+"static/image/93455b0a9971c11dee0f5defb548465b.9c1b8295.webp",m=r.p+"static/image/d01dec78635d48adaca0e444790f669d.a18790b1.webp";function b(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",img:"img",ul:"ul",li:"li",pre:"pre",strong:"strong",ol:"ol",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"27runtime模块编译打包及运行时逻辑",children:["27.Runtime：模块编译打包及运行时逻辑",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#27runtime模块编译打包及运行时逻辑",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["回顾最近几节内容，Webpack 运行过程中首先会根据 ",(0,c.jsx)(n.code,{children:"Module"})," 之间的引用关系构建 ",(0,c.jsx)(n.code,{children:"ModuleGraph"})," 对象；接下来按照若干内置规则将 ",(0,c.jsx)(n.code,{children:"Module"})," 组织进不同 ",(0,c.jsx)(n.code,{children:"Chunk"})," 对象中，形成 ",(0,c.jsx)(n.code,{children:"ChunkGraph"})," 关系图。"]}),"\n",(0,c.jsxs)(n.p,{children:["接着，构建流程将来到最后一个重要步骤：生成产物代码，这个过程会将所有 ",(0,c.jsx)(n.code,{children:"Module"})," 内容一一转换为适当的产物代码形态，并以 ",(0,c.jsx)(n.code,{children:"Chunk"})," 为单位合并 ",(0,c.jsx)(n.code,{children:"Module"})," 产物代码，之后根据 ",(0,c.jsx)(n.code,{children:"Module"})," 中出现的特性依赖，补充相应运行时代码，最终构建出我们日常所见的 Webpack Bundle 代码文件。"]}),"\n",(0,c.jsx)(n.p,{children:"本文将深入分析这个过程的源码，详细剖析模块转译、运行时依赖分析、产物合并的具体实现逻辑。"}),"\n",(0,c.jsxs)(n.h2,{id:"什么是模块转译",children:["什么是模块转译？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是模块转译",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"众所周知，Webpack 的打包功能并不是将原始文件代码“复制-粘贴”到产物文件那么简单，为了确保代码能在不同环境 —— 多种版本的浏览器、Node、Electron 等正常运行，构建时需要对模块源码适当做一些转换操作，这一点在大多数构建产物的内容中都有所体现，例如："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["示例包含 ",(0,c.jsx)(n.code,{children:"index.js"}),"、",(0,c.jsx)(n.code,{children:"name.js"})," 两个 JS 代码模块，经过 Webpack 构建后生成如图右侧所示的产物文件，文件自上而下包含三块内容："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"name.js"})," 模块对应的、函数形态的转译代码；"]}),"\n",(0,c.jsx)(n.li,{children:"Webpack 按需注入的运行时代码；"}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"index.js"})," 模块对应的 IIFE（立即执行函数） 转译代码。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["其中，",(0,c.jsx)(n.code,{children:"name.js"}),"、",(0,c.jsx)(n.code,{children:"index.js"})," 对应的产物代码，与源码相比，虽然语义与功能都基本相同，但表现形式发生了较大变化，例如 ",(0,c.jsx)(n.code,{children:"index.js"})," 编译前后的内容："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"整个模块被包裹进 IIFE（立即执行函数）中；"}),"\n",(0,c.jsxs)(n.li,{children:["添加 ",(0,c.jsx)(n.code,{children:"__webpack_require__.r(__webpack_exports__);"})," 语句，用于适配 ESM 规范；"]}),"\n",(0,c.jsxs)(n.li,{children:["源码中的 ",(0,c.jsx)(n.code,{children:"import"})," 语句被转译为 ",(0,c.jsx)(n.code,{children:"__webpack_require__"})," 函数调用；"]}),"\n",(0,c.jsxs)(n.li,{children:["源码 ",(0,c.jsx)(n.code,{children:"console"})," 语句所使用的 ",(0,c.jsx)(n.code,{children:"name"})," 变量被转译为 ",(0,c.jsx)(n.code,{children:"_name__WEBPACK_IMPORTED_MODULE_0__.default"})," ；"]}),"\n",(0,c.jsx)(n.li,{children:"添加若干注释。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"编译前后代码功能逻辑相同，但替换掉这些 ES 高级特性之后，却能让应用平稳运行在低版本浏览器中，那么，这种代码转换功能具体是怎么实现的呢？"}),"\n",(0,c.jsxs)(n.h2,{id:"模块转译主流程",children:["模块转译主流程",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块转译主流程",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在上一章《",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035921680302115",target:"_blank",rel:"noopener noreferrer",children:"Chunk：三种产物的打包逻辑"}),"》中，我们已经介绍了 ",(0,c.jsx)(n.code,{children:"compilation.seal"})," 函数内会调用 ",(0,c.jsx)(n.code,{children:"buildChunkGraph"})," 生成 Chunk 依赖关系图，之后 Webpack 就可以分析出："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"需要输出那些 Chunk；"}),"\n",(0,c.jsx)(n.li,{children:"每个 Chunk 包含那些 Module，以及每个 Module 经过 Loader 翻译后的代码内容；"}),"\n",(0,c.jsx)(n.li,{children:"Chunk 与 Chunk 之间的父子依赖关系。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["在此之后 ",(0,c.jsx)(n.code,{children:"seal"})," 函数会开始触发一堆优化钩子，借助插件对 ChunkGraph 做诸如合并、拆分、删除无效 Chunk 等优化操作，并在最后调用 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L3160-L3162",target:"_blank",rel:"noopener noreferrer",children:"compilation.codeGeneration"})," 方法："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class Compilation {\n  seal(callback) {\n    // 初始化 ChunkGraph、ChunkGroup 对象\n    for (const [name, { dependencies, includeDependencies, options }] of this.entries) {\n      // ...\n    }\n    for (const [name,{options: { dependOn, runtime },},] of this.entries) {\n      // ...\n    }\n    // 构建 ChunkGroup\n    buildChunkGraph(this, chunkGraphInit);\n    // 执行诸多优化钩子\n    this.hooks.optimize.call();\n    // ...\n\n    this.hooks.optimizeTree.callAsync(this.chunks, this.modules, (err) => {\n      // ...\n      this.hooks.optimizeChunkModules.callAsync(this.chunks, this.modules, (err) => {\n          // ...\n          this.hooks.beforeCodeGeneration.call();\n          // 开始生成最终产物代码\n          this.codeGeneration(/* ... */);\n        }\n      );\n    });\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"codeGeneration"})," 方法负责生成最终的资产代码，主要流程："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"有三个关键步骤。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"单模块转译"}),"：这一步主要用于计算模块实际输出代码，遍历 ",(0,c.jsx)(n.code,{children:"compilation.modules"})," 数组，",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L3326-L3327",target:"_blank",rel:"noopener noreferrer",children:"调用"})," ",(0,c.jsx)(n.code,{children:"module"})," 对象的 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/NormalModule.js#L1172-L1173",target:"_blank",rel:"noopener noreferrer",children:"codeGeneration"})," 方法，执行模块转译计算：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/NormalModule.js#L1204-L1205",target:"_blank",rel:"noopener noreferrer",children:"调用"})," ",(0,c.jsx)(n.code,{children:"JavascriptGenerator"})," 的 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/javascript/JavascriptGenerator.js#L89-L90",target:"_blank",rel:"noopener noreferrer",children:"generate"})," 方法；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/javascript/JavascriptGenerator.js#L111-L112",target:"_blank",rel:"noopener noreferrer",children:"遍历"})," ",(0,c.jsx)(n.code,{children:"module"})," 对象的 ",(0,c.jsx)(n.code,{children:"dependencies"})," 与 ",(0,c.jsx)(n.code,{children:"presentationalDependencies"})," 数组；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/javascript/JavascriptGenerator.js#L206-L207",target:"_blank",rel:"noopener noreferrer",children:"执行"})," 每个数组项 ",(0,c.jsx)(n.code,{children:"dependeny"})," 对象对应的 ",(0,c.jsx)(n.code,{children:"template.apply"})," 方法，方法中视情况可能产生三种副作用：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["直接修改模块 ",(0,c.jsx)(n.code,{children:"source"})," 数据，如 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/ConstDependency.js#L100-L101",target:"_blank",rel:"noopener noreferrer",children:"ConstDependency.Template"}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:["将结果记录到 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组如 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/HarmonyExportSpecifierDependency.js#L97-L99",target:"_blank",rel:"noopener noreferrer",children:"HarmonyExportSpecifierDependency"}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:["将运行时依赖记录到 ",(0,c.jsx)(n.code,{children:"runtimeRequirements"})," 数组如 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/HarmonyImportDependency.js#L105-L106",target:"_blank",rel:"noopener noreferrer",children:"HarmonyImportDependency"}),"。"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"收集运行时依赖"}),"：计算模块运行时，首先调用 ",(0,c.jsx)(n.code,{children:"compilation.processRuntimeRequirements"})," 方法，将上一步生成的 ",(0,c.jsx)(n.code,{children:"runtimeRequirements"})," 数组一一转换为 ",(0,c.jsx)(n.code,{children:"RuntimeModule"})," 对象，并挂载到 ",(0,c.jsx)(n.code,{children:"ChunkGroup"})," 中。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"模块合并"}),"：调用 ",(0,c.jsx)(n.code,{children:"compilation.createChunkAssets"})," 方法，以 Chunk 为单位，将相应的所有 ",(0,c.jsx)(n.code,{children:"module"})," 及 ",(0,c.jsx)(n.code,{children:"runtimeModule"})," 按规则塞进「",(0,c.jsx)(n.strong,{children:"产物框架"}),"」 中，最终合并输出成完整的 Bundle 文件。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"这些就是 Webpack 最终消费 ModuleGraph 与 ChunkGraph，生成最终产物代码的关键过程，总结而言，就是先遍历所有模块依赖对象，收集模块编译结果与运行时依赖，之后将这些内容合并在一起输出为 Bundle 文件。"}),"\n",(0,c.jsx)(n.p,{children:"下面我们逐一展开，了解每个步骤的细节。"}),"\n",(0,c.jsxs)(n.h2,{id:"单模块转译",children:["单模块转译",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单模块转译",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["「",(0,c.jsx)(n.strong,{children:"模块转译"}),"」 操作从 ",(0,c.jsx)(n.code,{children:"module.codeGeneration"})," 调用开始，对应到上述流程图的："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["这个过程首先调用 ",(0,c.jsx)(n.code,{children:"JavascriptGenerator.generate"})," 函数，遍历模块的 ",(0,c.jsx)(n.code,{children:"dependencies"})," 数组，依次调用依赖对象对应的 ",(0,c.jsx)(n.code,{children:"Template"})," 子类 ",(0,c.jsx)(n.code,{children:"apply"})," 方法更新模块内容，说起来有点绕，我将重要步骤抽取为如下伪代码："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class JavascriptGenerator {\n    generate(module, generateContext) {\n        // 先取出 module 的原始代码内容\n        const source = new ReplaceSource(module.originalSource());\n        const { dependencies, presentationalDependencies } = module;\n        const initFragments = [];\n        for (const dependency of [...dependencies, ...presentationalDependencies]) {\n            // 找到 dependency 对应的 template\n            const template = generateContext.dependencyTemplates.get(dependency.constructor);\n            // 调用 template.apply，传入 source、initFragments\n            // 在 apply 函数可以直接修改 source 内容，或者更改 initFragments 数组，影响后续转译逻辑\n            template.apply(dependency, source, {initFragments})\n        }\n        // 遍历完毕后，调用 InitFragment.addToSource 合并 source 与 initFragments\n        return InitFragment.addToSource(source, initFragments, generateContext);\n    }\n}\n\n// Dependency 子类\nclass xxxDependency extends Dependency {}\n\n// Dependency 子类对应的 Template 定义\nconst xxxDependency.Template = class xxxDependencyTemplate extends Template {\n    apply(dep, source, {initFragments}) {\n        // 1. 直接操作 source，更改模块代码\n        source.replace(dep.range[0], dep.range[1] - 1, 'some thing')\n        // 2. 通过添加 InitFragment 实例，补充代码\n        initFragments.push(new xxxInitFragment())\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["从上述伪代码可以看出，",(0,c.jsx)(n.code,{children:"JavascriptGenerator.generate"})," 函数的逻辑相对比较固化："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["初始化 ",(0,c.jsx)(n.code,{children:"source"}),"、",(0,c.jsx)(n.code,{children:"initFragments"})," 等变量；"]}),"\n",(0,c.jsxs)(n.li,{children:["遍历 ",(0,c.jsx)(n.code,{children:"module"})," 对象的依赖数组，找到每个 ",(0,c.jsx)(n.code,{children:"dependency"})," 对应的 ",(0,c.jsx)(n.code,{children:"template"})," 对象，调用 ",(0,c.jsx)(n.code,{children:"template.apply"})," 函数修改模块内容；"]}),"\n",(0,c.jsxs)(n.li,{children:["调用 ",(0,c.jsx)(n.code,{children:"InitFragment.addToSource"})," 方法，合并 ",(0,c.jsx)(n.code,{children:"source"})," 与 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组，生成最终结果。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这里的重点是 ",(0,c.jsx)(n.code,{children:"JavascriptGenerator.generate"})," 函数并不操作 ",(0,c.jsx)(n.code,{children:"module"})," 源码，它仅仅提供一个执行框架，真正处理模块内容转译的逻辑都在 ",(0,c.jsx)(n.code,{children:"xxxDependencyTemplate"})," 对象的 ",(0,c.jsx)(n.code,{children:"apply"})," 函数实现，如上例伪代码中 24-28 行。"]}),"\n",(0,c.jsxs)(n.p,{children:["每个 ",(0,c.jsx)(n.code,{children:"Dependency"})," 子类都会挂载一个 ",(0,c.jsx)(n.code,{children:"Template"})," 子类，且通常这两个类都会写在同一个文件中，例如 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/ConstDependency.js#L83-L84",target:"_blank",rel:"noopener noreferrer",children:"ConstDependency"})," 与 ",(0,c.jsx)(n.code,{children:"ConstDependencyTemplate"}),"；",(0,c.jsx)(n.code,{children:"NullDependency"})," 与 ",(0,c.jsx)(n.code,{children:"NullDependencyTemplate"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["Webpack 从「构建」(make) 阶段开始，就会通过 ",(0,c.jsx)(n.code,{children:"Dependency"})," 子类记录不同情况下模块之间的依赖关系；到「封装」(seal) 阶段再通过 ",(0,c.jsx)(n.code,{children:"Template"})," 子类修改 ",(0,c.jsx)(n.code,{children:"module"})," 代码，最终 ",(0,c.jsx)(n.code,{children:"Module"}),"、",(0,c.jsx)(n.code,{children:"Template"}),"、 ",(0,c.jsx)(n.code,{children:"JavascriptGenerator"}),"、",(0,c.jsx)(n.code,{children:"Dependency"})," 四个关键类形成如下交互关系："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Template"})," 对象会通过三种方法影响产物代码："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["直接操作 ",(0,c.jsx)(n.code,{children:"source"})," 对象，修改模块代码，该对象最初的内容等于模块的源码，经过多个 ",(0,c.jsx)(n.code,{children:"Template.apply"})," 函数流转后逐渐被替换成新的代码形式；"]}),"\n",(0,c.jsxs)(n.li,{children:["操作 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组，在模块源码之外插入补充代码片段；"]}),"\n",(0,c.jsxs)(n.li,{children:["将运行时依赖记录到 ",(0,c.jsx)(n.code,{children:"runtimeRequirements"})," 数组。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["其中第 1、2 种操作所产生的副作用，最终都会被传入 ",(0,c.jsx)(n.code,{children:"InitFragment.addToSource"})," 函数，合并成最终结果。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:["通过 ",(0,c.jsx)(n.code,{children:"source"})," 修改模块代码："]})}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["先来看看 ",(0,c.jsx)(n.code,{children:"source"})," 操作，",(0,c.jsx)(n.a,{href:"https://github.com/webpack/webpack-sources",target:"_blank",rel:"noopener noreferrer",children:"webpack-sources"})," 是 Webpack 中用于编辑字符串的一套工具类库，它提供了一系列代码编辑方法，包括："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"字符串合并、替换、插入等；"}),"\n",(0,c.jsx)(n.li,{children:"模块代码缓存、sourcemap 映射、hash 计算等。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["Webpack 内部以及社区的很多插件、loader 都会使用 ",(0,c.jsx)(n.a,{href:"https://github.com/webpack/webpack-sources",target:"_blank",rel:"noopener noreferrer",children:"webpack-sources"})," 库编辑代码内容，包括上文介绍的 ",(0,c.jsx)(n.code,{children:"Template.apply"})," 体系。逻辑上，在启动模块代码生成流程时，Webpack 会先用模块原始内容",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/javascript/JavascriptGenerator.js#L95-L96",target:"_blank",rel:"noopener noreferrer",children:"初始化"})," ",(0,c.jsx)(n.code,{children:"Source"})," 对象，即："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const source = new ReplaceSource(module.originalSource());\n"})}),"\n",(0,c.jsxs)(n.p,{children:["之后，不同 ",(0,c.jsx)(n.code,{children:"Dependency"})," 子类按序、按需更改 ",(0,c.jsx)(n.code,{children:"source"})," 内容，例如 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/HarmonyImportSpecifierDependency.js",target:"_blank",rel:"noopener noreferrer",children:"HarmonyImportSpecifierDependency"})," 中："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"HarmonyImportSpecifierDependency.Template = class HarmonyImportSpecifierDependencyTemplate extends (\n  HarmonyImportDependency.Template\n) {\n  apply(dependency, source, templateContext) {\n    const dep = /** @type {HarmonyImportSpecifierDependency} */ (dependency);\n    // ...\n    const ids = dep.getIds(moduleGraph);\n    const exportExpr = this._getCodeForIds(dep, source, templateContext, ids);\n    const range = dep.range;\n    if (dep.shorthand) {\n      source.insert(range[1], `: ${exportExpr}`);\n    } else {\n      source.replace(range[0], range[1] - 1, exportExpr);\n    }\n  }\n};\n"})}),"\n",(0,c.jsx)(n.p,{children:"举个例子，对于下面这段简单代码："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'import bar from "./bar";\nconsole.log(bar);\n'})}),"\n",(0,c.jsxs)(n.p,{children:["会产生 ",(0,c.jsx)(n.code,{children:"HarmonyImportSpecifierDependency"})," 与 ",(0,c.jsx)(n.code,{children:"ConstDependency"})," 两个依赖对象，之后："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'import bar from "./bar";\nconsole.log(bar);\n\n// 首先，HarmonyImportSpecifierDependency 替换导入变量名：\nimport bar from "./bar";\nconsole.log(_bar__WEBPACK_IMPORTED_MODULE_1__["default"]);\n\n// 之后，ConstDependency 删除模块导入语句：\nconsole.log(_bar__WEBPACK_IMPORTED_MODULE_1__["default"]);\n'})}),"\n",(0,c.jsxs)(n.p,{children:["可以看出，这部分逻辑的效果与 Babel 类似，会直接修改模块源码，实现语言层面的向下兼容。但这还不够，还需要将这段代码包裹进 Webpack 的模块框架中，这部分工作将由 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组完成。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.code,{children:"initFragments"})," 数组的作用："]})}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["上面我们聊到，除直接操作 ",(0,c.jsx)(n.code,{children:"source"})," 外，",(0,c.jsx)(n.code,{children:"Template.apply"})," 中还可能通过 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组达成修改模块产物的效果。",(0,c.jsx)(n.code,{children:"initFragments"})," 数组项为 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/InitFragment.js",target:"_blank",rel:"noopener noreferrer",children:"InitFragment"})," 子类实例，它们带有两个关键函数：",(0,c.jsx)(n.code,{children:"getContent"}),"、",(0,c.jsx)(n.code,{children:"getEndContent"}),"，分别用于获取代码片段的头尾部分。"]}),"\n",(0,c.jsxs)(n.p,{children:["例如 ",(0,c.jsx)(n.code,{children:"HarmonyImportDependencyTemplate"})," 的 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/HarmonyImportDependency.js#L310-L311",target:"_blank",rel:"noopener noreferrer",children:"apply"})," 函数中："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"HarmonyImportDependency.Template = class HarmonyImportDependencyTemplate extends (\n  ModuleDependency.Template\n) {\n  apply(dependency, source, templateContext) {\n    // ...\n    templateContext.initFragments.push(\n        new ConditionalInitFragment(\n          importStatement[0] + importStatement[1],\n          InitFragment.STAGE_HARMONY_IMPORTS,\n          dep.sourceOrder,\n          key,\n          runtimeCondition\n        )\n      );\n    //...\n  }\n }\n"})}),"\n",(0,c.jsxs)(n.p,{children:["也就是根据模块需求，不断增加新的代码片段 ",(0,c.jsx)(n.code,{children:"initFragments"}),"，所有 ",(0,c.jsx)(n.code,{children:"Dependency"})," 执行完毕后，接着就需要调用 ",(0,c.jsx)(n.code,{children:"InitFragment.addToSource"})," 函数将两者合并为模块产物。",(0,c.jsx)(n.code,{children:"addToSource"})," 的核心代码如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class InitFragment {\n  static addToSource(source, initFragments, generateContext) {\n    // 先排好顺序\n    const sortedFragments = initFragments\n      .map(extractFragmentIndex)\n      .sort(sortFragmentWithIndex);\n    // ...\n\n    const concatSource = new ConcatSource();\n    const endContents = [];\n    for (const fragment of sortedFragments) {\n        // 合并 fragment.getContent 取出的片段内容\n      concatSource.add(fragment.getContent(generateContext));\n      const endContent = fragment.getEndContent(generateContext);\n      if (endContent) {\n        endContents.push(endContent);\n      }\n    }\n\n    // 合并 source\n    concatSource.add(source);\n    // 合并 fragment.getEndContent 取出的片段内容\n    for (const content of endContents.reverse()) {\n      concatSource.add(content);\n    }\n    return concatSource;\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，",(0,c.jsx)(n.code,{children:"addToSource"})," 函数的逻辑："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["遍历 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组，按顺序合并 ",(0,c.jsx)(n.code,{children:"fragment.getContent()"})," 的产物；"]}),"\n",(0,c.jsxs)(n.li,{children:["合并 ",(0,c.jsx)(n.code,{children:"source"})," 对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["遍历 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组，按顺序合并 ",(0,c.jsx)(n.code,{children:"fragment.getEndContent()"})," 的产物。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["所以，模块代码合并操作主要就是用 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组一层一层包裹住模块代码 ",(0,c.jsx)(n.code,{children:"source"}),"，而两者都在 ",(0,c.jsx)(n.code,{children:"Template.apply"})," 层面维护。还是上面那个简单例子，经过这段 ",(0,c.jsx)(n.code,{children:"Template"})," 处理后，最终转化为："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'import bar from "./bar";\nconsole.log(bar);\n\n// 首先，HarmonyImportSpecifierDependency 替换导入变量名：\nimport bar from "./bar";\nconsole.log(_bar__WEBPACK_IMPORTED_MODULE_1__["default"]);\n\n// 之后，ConstDependency 删除模块导入语句：\nconsole.log(_bar__WEBPACK_IMPORTED_MODULE_1__["default"]);\n\n// 经过 ConditionalInitFragment 处理：\n/* harmony import */ var _bar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bar */ "./src/bar.js");\nconsole.log(_bar__WEBPACK_IMPORTED_MODULE_1__["default"]);\n'})}),"\n",(0,c.jsxs)(n.p,{children:["简单总结一下，Webpack 生成 ModuleGraph 与 ChunkGraph 后，会立即开始遍历所有 ",(0,c.jsx)(n.code,{children:"Dependency"})," 对象，依次调用对象的静态方法 ",(0,c.jsx)(n.code,{children:"template.apply"})," 修改 ",(0,c.jsx)(n.code,{children:"module"})," 代码，最后再将所有变更后的 ",(0,c.jsx)(n.code,{children:"source"})," 与模块脚手架 ",(0,c.jsx)(n.code,{children:"initFragments"})," 合并为最终产物，完成从单个模块的源码形态到产物形态的转变。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:["自定义 ",(0,c.jsx)(n.code,{children:"Template.apply"})," 示例："]})}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["「",(0,c.jsx)(n.strong,{children:"模块转译"}),"」 步骤流程比较长，整体逻辑很复杂，为了加深理解，接下来我们尝试开发一个简单的 Banner 插件：实现在每个模块前自动插入一段字符串。实现上，插件主要涉及 ",(0,c.jsx)(n.code,{children:"Dependency"}),"、",(0,c.jsx)(n.code,{children:"Template"}),"、",(0,c.jsx)(n.code,{children:"hooks"})," 对象，代码："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'const { Dependency, Template } = require("webpack");\n\nclass DemoDependency extends Dependency {\n  constructor() {\n    super();\n  }\n}\n\nDemoDependency.Template = class DemoDependencyTemplate extends Template {\n  apply(dependency, source) {\n    const today = new Date().toLocaleDateString();\n    source.insert(0, `/* Author: Tecvan */\n/* Date: ${today} */\n`);\n  }\n};\n\nmodule.exports = class DemoPlugin {\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap("DemoPlugin", (compilation) => {\n      // 调用 dependencyTemplates ，注册 Dependency 到 Template 的映射\n      compilation.dependencyTemplates.set(\n        DemoDependency,\n        new DemoDependency.Template()\n      );\n      compilation.hooks.succeedModule.tap("DemoPlugin", (module) => {\n        // 模块构建完毕后，插入 DemoDependency 对象\n        module.addDependency(new DemoDependency());\n      });\n    });\n  }\n};\n'})}),"\n",(0,c.jsx)(n.p,{children:"示例插件的关键步骤："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["编写 ",(0,c.jsx)(n.code,{children:"DemoDependency"})," 与 ",(0,c.jsx)(n.code,{children:"DemoDependencyTemplate"})," 类，其中 ",(0,c.jsx)(n.code,{children:"DemoDependency"})," 仅做示例用，没有实际功能；",(0,c.jsx)(n.code,{children:"DemoDependencyTemplate"})," 则在其 ",(0,c.jsx)(n.code,{children:"apply"})," 中调用 ",(0,c.jsx)(n.code,{children:"source.insert"})," 插入字符串，如示例代码第 10-14 行；"]}),"\n",(0,c.jsxs)(n.li,{children:["使用 ",(0,c.jsx)(n.code,{children:"compilation.dependencyTemplates"})," 注册 ",(0,c.jsx)(n.code,{children:"DemoDependency"})," 与 ",(0,c.jsx)(n.code,{children:"DemoDependencyTemplate"})," 的映射关系；"]}),"\n",(0,c.jsxs)(n.li,{children:["使用 ",(0,c.jsx)(n.code,{children:"thisCompilation"})," 钩子取得 ",(0,c.jsx)(n.code,{children:"compilation"})," 对象；"]}),"\n",(0,c.jsxs)(n.li,{children:["使用 ",(0,c.jsx)(n.code,{children:"succeedModule"})," 钩子订阅 ",(0,c.jsx)(n.code,{children:"module"})," 构建完毕事件，并调用 ",(0,c.jsx)(n.code,{children:"module.addDependency"})," 方法添加 ",(0,c.jsx)(n.code,{children:"DemoDependency"})," 依赖。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["完成上述操作后，",(0,c.jsx)(n.code,{children:"module"})," 对象的产物在生成过程就会调用到 ",(0,c.jsx)(n.code,{children:"DemoDependencyTemplate.apply"})," 函数，插入我们定义好的字符串，效果如："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"感兴趣的同学也可以直接阅读 Webpack 仓库的如下文件，学习更多用例："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/ConstDependency.js#L92-L93",target:"_blank",rel:"noopener noreferrer",children:"ConstDependency"}),"：一个简单示例，可学习 ",(0,c.jsx)(n.code,{children:"source"})," 的更多操作方法；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/HarmonyExportSpecifierDependency.js#L86-L87",target:"_blank",rel:"noopener noreferrer",children:"HarmonyExportSpecifierDependency"}),"：一个较简单的示例，可学习 ",(0,c.jsx)(n.code,{children:"initFragments"})," 数组的更多用法；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/HarmonyImportDependency.js#L253-L254",target:"_blank",rel:"noopener noreferrer",children:"HarmonyImportDependency"}),"：一个较复杂但使用率极高的示例，可综合学习 ",(0,c.jsx)(n.code,{children:"source"}),"、",(0,c.jsx)(n.code,{children:"initFragments"})," 数组的用法。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"收集运行时模块",children:["收集运行时模块",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#收集运行时模块",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["为了正常、正确运行业务项目，Webpack 需要将开发者编写的业务代码以及支撑、调配这些业务代码的 ",(0,c.jsx)(n.strong,{children:"运行时"})," 一并打包到产物（bundle）中，以建筑作类比的话，业务代码相当于砖瓦水泥，是看得见摸得着能直接感知的逻辑；运行时相当于掩埋在砖瓦之下的钢筋地基，通常不需要关注，但决定了整座建筑的功能、质量。"]}),"\n",(0,c.jsx)(n.p,{children:"大多数 Webpack 特性都需要特定钢筋地基才能跑起来，包括：异步加载、HMR、WASM、Module Federation 等。即使没有用到这些特性，仅仅是最简单的模块导入导出，也都需要生成若干模拟 CMD 模块化方案运行时代码，例如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// a.js\nexport default 'a module';\n\n// index.js\nimport name from './a'\nconsole.log(name)\n"})}),"\n",(0,c.jsx)(n.p,{children:"打包结果："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"可以看出，整个 Bundle 被包裹在一个立即执行函数中，函数内部从上到下依次定义："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"__webpack_modules__"})," 对象，包含了除入口外的所有模块，如示例中的 ",(0,c.jsx)(n.code,{children:"a.js"})," 模块；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"__webpack_module_cache__"})," 对象，用于存储被引用过的模块；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"__webpack_require__"})," 函数，实现模块引用(require) 逻辑；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"__webpack_require__.d"})," ，工具函数，实现将模块导出的内容附加的模块对象上；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"__webpack_require__.o"})," ，工具函数，判断对象属性用；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"__webpack_require__.r"})," ，工具函数，在 ESM 模式下声明 ESM 模块标识；"]}),"\n",(0,c.jsxs)(n.li,{children:["最后的 IIFE，对应 entry 模块即上述示例的 ",(0,c.jsx)(n.code,{children:"index.js"})," ，用于启动整个应用。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这几个 ",(0,c.jsx)(n.code,{children:"__webpack_"})," 开头奇奇怪怪的函数可以统称为 Webpack 运行时代码，作用如前面所说的，是搭起整个业务项目的骨架，就上述简单示例所罗列出来的几个函数、对象而言，它们协作构建起一个简单的模块化体系，从而实现 ES Module 规范所声明的模块化特性。"]}),"\n",(0,c.jsx)(n.p,{children:"上述函数、对象构成了 Webpack 运行时最基本的能力 —— 模块化，假如代码中用到更多 Webpack 特性，则会相应地注入更多运行时模块代码，例如："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["使用异步加载时，注入 ",(0,c.jsx)(n.code,{children:"__webpack_require__.e"}),"、",(0,c.jsx)(n.code,{children:"__webpack_require__.f"})," 等模块；"]}),"\n",(0,c.jsxs)(n.li,{children:["使用 HMR 时，注入 ",(0,c.jsx)(n.code,{children:"__webpack_require__.hmrF"}),"、",(0,c.jsx)(n.code,{children:"webpack/runtime/hot"})," 等模块。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"那么，Webpack 是如何收集运行时依赖，并将之合并到最终产物中的呢？"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"收集运行时依赖："})}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"早在「构建」阶段，Webpack 就已经开始在持续收集运行时依赖，例如，在一个非常简单的模块导入语句中："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import bar from './bar';\n"})}),"\n",(0,c.jsx)(n.p,{children:"Webpack 在处理上述代码 AST 时，会相应生成多个依赖对象，比较重要的有："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"HarmonyImportSideEffectDependency"}),"：主要的 Dependency 对象，Webpack 会为该对象创建相应的 ",(0,c.jsx)(n.code,{children:"NormalModule"})," 实例，从而递归处理新模块代码；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/HarmonyCompatibilityDependency.js#L72-L73",target:"_blank",rel:"noopener noreferrer",children:"HarmonyCompatibilityDependency"}),"：运行时模块依赖，对应的 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/dependencies/HarmonyCompatibilityDependency.js#L72-L73",target:"_blank",rel:"noopener noreferrer",children:"Template.apply"})," 函数会在生成代码时记录相应运行时需求。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["本质上，这是一个基于静态代码分析的方式收集依赖的过程。当所有模块处理完毕，收集到所有运行时依赖，进入 ",(0,c.jsx)(n.code,{children:"codeGeneration"})," 函数后，Webpack 会进一步将这些依赖对象挂载到 Chunk 中："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["这个过程集中 ",(0,c.jsx)(n.code,{children:"compilation.processRuntimeRequirements"})," 函数，函数中包含三次循环："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"第一次循环遍历所有 module，收集所有 module 的 runtime 依赖；"}),"\n",(0,c.jsx)(n.li,{children:"第二次循环遍历所有 chunk，将 chunk 下所有 module 的 runtime 统一收录到 chunk 中；"}),"\n",(0,c.jsxs)(n.li,{children:["第三次循环遍历所有 runtime chunk，收集其对应的子 chunk 下所有 runtime 依赖，之后遍历所有依赖并发布 ",(0,c.jsx)(n.code,{children:"runtimeRequirementInTree"})," 钩子，（主要是） ",(0,c.jsx)(n.code,{children:"RuntimePlugin"})," 插件订阅该钩子并根据依赖类型创建对应的 ",(0,c.jsx)(n.code,{children:"RuntimeModule"})," 子类实例。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L3392-L3393",target:"_blank",rel:"noopener noreferrer",children:"第一次循环：收集模块依赖"}),"："]})}),"\n",(0,c.jsxs)(n.p,{children:["在上述「模块转译主流程」中，我们聊到 ",(0,c.jsx)(n.code,{children:"Template.apply"})," 函数可能修改模块的 ",(0,c.jsx)(n.code,{children:"runtimeRequirements"})," 数组，最终形成如下结构："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["这个过程相当于将模块的 Runtime Dependency 都转化为 ",(0,c.jsx)(n.code,{children:"__webpack_require__"})," 等枚举值，并调用 ",(0,c.jsx)(n.code,{children:"compilation.processRuntimeRequirements"})," 进入第一重循环，将上述 ",(0,c.jsx)(n.code,{children:"runtimeRequirements"})," 数组 ",(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L3447-L3448",target:"_blank",rel:"noopener noreferrer",children:"挂载"})," 到 ",(0,c.jsx)(n.code,{children:"ChunkGraph"})," 对象中。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L3463-L3464",target:"_blank",rel:"noopener noreferrer",children:"第二次循环：整合 chunk 依赖"}),"："]})}),"\n",(0,c.jsx)(n.p,{children:"第一次循环针对 module 收集依赖，第二次循环则遍历 chunk 数组，收集将其对应所有 module 的 runtime 依赖，例如："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["示例图中，",(0,c.jsx)(n.code,{children:"module a"})," 包含两个运行时依赖；",(0,c.jsx)(n.code,{children:"module b"})," 包含一个运行时依赖，则经过第二次循环整合后，对应的 ",(0,c.jsx)(n.code,{children:"chunk"})," 会包含两个模块所包含的三个运行时依赖。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/lib/Compilation.js#L3483-L3484",target:"_blank",rel:"noopener noreferrer",children:"第三次循环：依赖标识转 RuntimeModule 对象"}),"："]})}),"\n",(0,c.jsx)(n.p,{children:"源码中，第三次循环的代码最少但逻辑最复杂，大致上执行三个操作："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"遍历所有 runtime chunk，收集其所有子 chunk 的 runtime 依赖；"}),"\n",(0,c.jsxs)(n.li,{children:["为该 runtime chunk 下的所有依赖发布 ",(0,c.jsx)(n.code,{children:"runtimeRequirementInTree"})," 钩子；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"RuntimePlugin"})," 监听钩子，并根据 runtime 依赖的标识信息创建对应的 ",(0,c.jsx)(n.code,{children:"RuntimeModule"})," 子类对象，并将对象加入到 ",(0,c.jsx)(n.code,{children:"ModuleDepedencyGraph"})," /",(0,c.jsx)(n.code,{children:"ChunkGraph"})," 体系中管理。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["至此，runtime 依赖完成了从 module 内容解析，到收集，到创建依赖对应的 ",(0,c.jsx)(n.code,{children:"Module"})," 子类，再将 ",(0,c.jsx)(n.code,{children:"Module"})," 加入到 ",(0,c.jsx)(n.code,{children:"ModuleDepedencyGraph"})," /",(0,c.jsx)(n.code,{children:"ChunkGraph"})," 体系的全流程，业务代码及运行时代码对应的模块依赖关系图完全 ready，可以准备进入下一阶段 —— 合并最终产物。"]}),"\n",(0,c.jsxs)(n.h2,{id:"合并最终产物",children:["合并最终产物",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#合并最终产物",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"讲完单个模块转译以及运行时模块收集过程后，我们终于来到最后一步："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["流程图中，",(0,c.jsx)(n.code,{children:"compilation.codeGeneration"})," 函数执行完毕 —— 也就是模块转译阶段完成后，模块的转译结果会一一保存到 ",(0,c.jsx)(n.code,{children:"compilation.codeGenerationResults"})," 对象中，之后会启动一个新的执行流程 —— ",(0,c.jsx)(n.strong,{children:"模块合并打包"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"模块合并打包"}),"过程会将 chunk 对应的 module 及 runtimeModule 按规则塞进",(0,c.jsx)(n.strong,{children:"模板框架"}),"中，最终合并输出成完整的 bundle 文件，例如上例中："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["示例右边 bundle 文件中，红框框出来的部分为用户代码文件及运行时模块生成的产物，其余部分撑起了一个 IIFE 形式的运行框架，即为",(0,c.jsx)(n.strong,{children:"模板框架"}),"，也就是："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'(() => { // webpackBootstrap\n    "use strict";\n    var __webpack_modules__ = ({\n        "module-a": ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n            // ! module 代码，\n        }),\n        "module-b": ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n            // ! module 代码，\n        })\n    });\n    // The module cache\n    var __webpack_module_cache__ = {};\n    // The require function\n    function __webpack_require__(moduleId) {\n        // ! webpack CMD 实现\n    }\n    /************************************************************************/\n    // ! 各种 runtime\n    /************************************************************************/\n    var __webpack_exports__ = {};\n    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n    (() => {\n        // ! entry 模块\n    })();\n})();\n'})}),"\n",(0,c.jsx)(n.p,{children:"捋一下这里的逻辑，运行框架包含如下关键部分："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"最外层是一个 IIFE 包裹；"}),"\n",(0,c.jsxs)(n.li,{children:["一个记录了除 ",(0,c.jsx)(n.code,{children:"entry"})," 外的其它模块代码的 ",(0,c.jsx)(n.code,{children:"__webpack_modules__"})," 对象，对象的 key 为模块标志符；值为模块转译后的代码；"]}),"\n",(0,c.jsxs)(n.li,{children:["一个极度简化的 CMD 实现： ",(0,c.jsx)(n.code,{children:"__webpack_require__"})," 函数；"]}),"\n",(0,c.jsxs)(n.li,{children:["最后，一个包裹了 ",(0,c.jsx)(n.code,{children:"entry"})," 代码的 IIFE 函数。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"模块转译"})," 是将 ",(0,c.jsx)(n.code,{children:"module"})," 转译为可以在宿主环境如浏览器上运行的代码形式；",(0,c.jsx)(n.strong,{children:"收集运行时模块"})," 负责决定整个 Bundle 需要的骨架代码；而 ",(0,c.jsx)(n.strong,{children:"模块合并"}),"  操作则串联这些 ",(0,c.jsx)(n.code,{children:"modules"})," ，使之整体符合开发预期，能够正常运行整个应用逻辑。接下来，我们揭晓这部分代码的生成原理。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"模块合并主流程："})}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"compilation.codeGeneration"})," 执行完毕，即所有用户代码模块做完转译，运行时模块都收集完毕作后，",(0,c.jsx)(n.code,{children:"seal"})," 函数调用 ",(0,c.jsx)(n.code,{children:"compilation.createChunkAssets"})," 函数，触发 ",(0,c.jsx)(n.code,{children:"renderManifest"})," 钩子，",(0,c.jsx)(n.code,{children:"JavascriptModulesPlugin"})," 插件监听到这个钩子消息后开始组装 bundle，伪代码："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'// Webpack 5\n// lib/Compilation.js\nclass Compilation {\n  seal() {\n    // 先把所有模块的代码都转译，准备好\n    this.codeGenerationResults = this.codeGeneration(this.modules);\n    // 1. 调用 createChunkAssets\n    this.createChunkAssets();\n  }\n\n  createChunkAssets() {\n    // 遍历 chunks ，为每个 chunk 执行 render 操作\n    for (const chunk of this.chunks) {\n      // 2. 触发 renderManifest 钩子\n      const res = this.hooks.renderManifest.call([], {\n        chunk,\n        codeGenerationResults: this.codeGenerationResults,\n        ...others,\n      });\n      // 提交组装结果\n      this.emitAsset(res.render(), ...others);\n    }\n  }\n}\n\n// lib/javascript/JavascriptModulesPlugin.js\nclass JavascriptModulesPlugin {\n  apply() {\n    compiler.hooks.compilation.tap("JavascriptModulesPlugin", (compilation) => {\n      compilation.hooks.renderManifest.tap("JavascriptModulesPlugin", (result, options) => {\n          // JavascriptModulesPlugin 插件中通过 renderManifest 钩子返回组装函数 render\n          const render = () =>\n            // render 内部根据 chunk 内容，选择使用模板 `renderMain` 或 `renderChunk`\n            // 3. 监听钩子，返回打包函数\n            this.renderMain(options);\n\n          result.push({ render /* arguments */ });\n          return result;\n        }\n      );\n    });\n  }\n\n  renderMain() {/*  */}\n\n  renderChunk() {/*  */}\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["这里的核心逻辑是，",(0,c.jsx)(n.code,{children:"compilation"})," 以 ",(0,c.jsx)(n.code,{children:"renderManifest"})," 钩子方式对外发布 bundle 打包需求； ",(0,c.jsx)(n.code,{children:"JavascriptModulesPlugin"})," 监听这个钩子，按照 chunk 的内容特性，调用不同的打包函数。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["\uD83D\uDCA1提示：上述仅针对 Webpack5 有效，在 Webpack4 中，打包逻辑集中在 ",(0,c.jsx)(n.code,{children:"MainTemplate"})," 完成。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"JavascriptModulesPlugin"})," 内置的打包函数有："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"renderMain"}),"：打包主 chunk 时使用；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"renderChunk"}),"：打包子 chunk ，如异步模块 chunk 时使用。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["两个打包函数实现的逻辑接近，都是按顺序拼接各个模块，下面简单介绍下 ",(0,c.jsx)(n.code,{children:"renderMain"})," 的实现。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:[(0,c.jsx)(n.code,{children:"JavascriptModulesPlugin.renderMain"})," 函数："]})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"renderMain"})," 函数涉及比较多场景判断，原始代码很长很绕，我摘了几个重点步骤："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'class JavascriptModulesPlugin {\n  renderMain(renderContext, hooks, compilation) {\n    const { chunk, chunkGraph, runtimeTemplate } = renderContext;\n\n    const source = new ConcatSource();\n    // ...\n    // 1. 先计算出 bundle CMD 核心代码，包含：\n    //      - "var __webpack_module_cache__ = {};" 语句\n    //      - "__webpack_require__" 函数\n    const bootstrap = this.renderBootstrap(renderContext, hooks);\n\n    // 2. 计算出当前 chunk 下，除 entry 外其它模块的代码\n    const chunkModules = Template.renderChunkModules(\n      renderContext,\n      inlinedModules\n        ? allModules.filter((m) => !inlinedModules.has(m))\n        : allModules,\n      (module) =>\n        this.renderModule(\n          module,\n          renderContext,\n          hooks,\n          allStrict ? "strict" : true\n        ),\n      prefix\n    );\n\n    // 3. 计算出运行时模块代码\n    const runtimeModules =\n      renderContext.chunkGraph.getChunkRuntimeModulesInOrder(chunk);\n\n    // 4. 重点来了，开始拼接 bundle\n    // 4.1 首先，合并核心 CMD 实现，即上述 bootstrap 代码\n    const beforeStartup = Template.asString(bootstrap.beforeStartup) + "\\n";\n    source.add(\n      new PrefixSource(\n        prefix,\n        useSourceMap\n          ? new OriginalSource(beforeStartup, "webpack/before-startup")\n          : new RawSource(beforeStartup)\n      )\n    );\n\n    // 4.2 合并 runtime 模块代码\n    if (runtimeModules.length > 0) {\n      for (const module of runtimeModules) {\n        compilation.codeGeneratedModules.add(module);\n      }\n    }\n    // 4.3 合并除 entry 外其它模块代码\n    for (const m of chunkModules) {\n      const renderedModule = this.renderModule(m, renderContext, hooks, false);\n      source.add(renderedModule)\n    }\n\n    // 4.4 合并 entry 模块代码\n    if (\n      hasEntryModules &&\n      runtimeRequirements.has(RuntimeGlobals.returnExportsFromRuntime)\n    ) {\n      source.add(`${prefix}return __webpack_exports__;\\n`);\n    }\n\n    return source;\n  }\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"核心逻辑为："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["先计算出 bundle CMD 代码，即 ",(0,c.jsx)(n.code,{children:"__webpack_require__"})," 函数；"]}),"\n",(0,c.jsxs)(n.li,{children:["计算出当前 chunk 下，除 entry 外其它模块代码 ",(0,c.jsx)(n.code,{children:"chunkModules"}),"；"]}),"\n",(0,c.jsx)(n.li,{children:"计算出运行时模块代码；"}),"\n",(0,c.jsxs)(n.li,{children:["开始执行合并操作，子步骤有：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"合并 CMD 代码；"}),"\n",(0,c.jsx)(n.li,{children:"合并 runtime 模块代码；"}),"\n",(0,c.jsxs)(n.li,{children:["遍历 ",(0,c.jsx)(n.code,{children:"chunkModules"})," 变量，合并除 entry 外其它模块代码；"]}),"\n",(0,c.jsx)(n.li,{children:"合并 entry 模块代码。"}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.li,{children:"返回结果。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"总结：先计算出不同组成部分的产物形态，之后按顺序拼接打包，输出合并后的版本。"}),"\n",(0,c.jsxs)(n.p,{children:["至此，Webpack 完成 bundle 的转译、打包流程，后续调用 ",(0,c.jsx)(n.code,{children:"compilation.emitAsset"}),"，将产物内容输出到 ",(0,c.jsx)(n.code,{children:"output"})," 指定的路径即可，Webpack 单次编译打包过程就结束了。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["从《",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035873802813475",target:"_blank",rel:"noopener noreferrer",children:"Init、Make、Seal：真正读懂 Webpack 核心流程"}),"》开始，我们花了四节篇幅，终于讲完了 Webpack 构建主流程中方方面面的原理，划重点："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Webpack 构建过程可以简单划分为 Init、Make、Seal 三个阶段；"}),"\n",(0,c.jsx)(n.li,{children:"Init 阶段负责初始化 Webpack 内部若干插件与状态，逻辑比较简单；"}),"\n",(0,c.jsx)(n.li,{children:"Make 阶段解决资源读入问题，这个阶段会从 Entry —— 入口模块开始，递归读入、解析所有模块内容，并根据模块之间的依赖关系构建 ModuleGraph —— 模块关系图对象；"}),"\n",(0,c.jsxs)(n.li,{children:["Seal 阶段更复杂：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"一方面，根据 ModuleGraph 构建 ChunkGraph；"}),"\n",(0,c.jsx)(n.li,{children:"另一方面，开始遍历 ChunkGraph，转译每一个模块代码；"}),"\n",(0,c.jsx)(n.li,{children:"最后，将所有模块与模块运行时依赖合并为最终输出的 Bundle —— 资产文件。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"这些内容都是介绍 Webpack 实现原理的文章，可能并不能马上解决你在业务中正在面临的现实问题，但放到更长的时间维度，这些内容所呈现的知识、思维、思辨过程可能能够长远地给到你："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"分析、理解复杂开源代码的能力；"}),"\n",(0,c.jsx)(n.li,{children:"理解 Webpack 架构及实现细节，下次遇到问题的时候能根据表象迅速定位到根源；"}),"\n",(0,c.jsx)(n.li,{children:"理解 Webpack 为 hooks、loader 提供的上下文，能够更通畅地理解其它开源组件，甚至能够自如地实现自己的组件。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"所以，希望你能沿着这个思路，反复、仔细阅读这些章节，深入理解底层实现原理，成为真正意义上的 Webpack 专家。"}),"\n",(0,c.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Dependency、Module 之间是什么关系？为什么需要设计 Dependency 这个看似可有可无的结构？"})]})}function g(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(b,{...e})}):b(e)}let k=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F27.Runtime%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%97%B6%E9%80%BB%E8%BE%91.md"]={toc:[{text:"什么是模块转译？",id:"什么是模块转译",depth:2},{text:"模块转译主流程",id:"模块转译主流程",depth:2},{text:"单模块转译",id:"单模块转译",depth:2},{text:"收集运行时模块",id:"收集运行时模块",depth:2},{text:"合并最终产物",id:"合并最终产物",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"27.Runtime：模块编译打包及运行时逻辑",headingTitle:"27.Runtime：模块编译打包及运行时逻辑",frontmatter:{}}}}]);