"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["92011"],{625814:function(e,n,s){s.r(n),s.d(n,{default:()=>b});var r=s(552676),c=s(740453);let t=s.p+"static/image/0881ee0db0b11ad7e8de3d6e3c3c43f5.998420d4.gif",a=s.p+"static/image/8d2d58023e151ae27823ac64badfb24f.998420d4.gif",i=s.p+"static/image/152942515305d8bbb3e5a91fecaab860.047fa5f1.webp",d=s.p+"static/image/52286f8d5a2338ddb8e1c097335505e8.19a7d441.gif",l=s.p+"static/image/8847a0d06e2def5a6c879b55b848cc9a.abd37b2c.webp",o=s.p+"static/image/f92ca8dd1ff0185f687cc1480fa2bf01.375d42f8.webp",p=s.p+"static/image/2e0631f82c687f701d1c7f36305d4734.b9a82e7c.webp",h=s.p+"static/image/e86d45cde8d1b893847a3fe93872f2da.82c1e310.gif",j=s.p+"static/image/4cc3ad944ff0501314dc7d0ef6b8f809.db3b7fdb.webp";function x(e){let n=Object.assign({h2:"h2",a:"a",p:"p",pre:"pre",code:"code",ol:"ol",li:"li",img:"img",blockquote:"blockquote",h3:"h3"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"讲了那么多遍 SSR，是不是对 SSR 感到很神奇？SSR 到底是怎么实现的呢？"}),"\n",(0,r.jsx)(n.p,{children:"本篇我们手写一个 Mini React SSR，借此来了解 SSR 的基本原理。千万不要觉得很难，其实很简单，让我们直接开始吧。"}),"\n",(0,r.jsxs)(n.h2,{id:"mini-react-csr",children:["Mini React CSR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mini-react-csr",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们先从 CSR 开始说起。如果对 CSR、SSR 这两个概念不太清楚，可以参考 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309077054263066662",target:"_blank",rel:"noopener noreferrer",children:"小册《渲染篇 | 从 CSR、SSR、SSG、ISR 开始说起》"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"涉及的目录结构和文件如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"react-csr             \n├─ app.js             \n├─ client.js          \n├─ index.html            \n├─ package.json       \n└─ webpack.client.js  \n"})}),"\n",(0,r.jsx)(n.p,{children:"运行："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 63.源码篇 _ 手写 React SSR\nmkdir react-csr && cd react-csr\n\n# 自动生成 package.json\nnpm init\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后安装用到的依赖项："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install webpack webpack-cli babel-loader @babel/core @babel/preset-env @babel/preset-react react react-dom\n"})}),"\n",(0,r.jsx)(n.p,{children:"其中："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"webpack、webpack-cli 用于 webpack 打包"}),"\n",(0,r.jsx)(n.li,{children:"babel-loader、@babel/core、@babel/preset-env、 @babel/preset-react 用于编译 React"}),"\n",(0,r.jsx)(n.li,{children:"react、react-dom 用于书写 React 代码"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"index.html"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<html>\n\n<head>\n  <title>Tiny React SSR</title>\n</head>\n\n<body>\n  <div id='root'>\n  </div>\n  <script src=\"./index.js\"><\/script>\n</body>\n\n</html>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们的目标是用 webpack 打包 React 代码，生成 index.js。浏览器打开 ",(0,r.jsx)(n.code,{children:"index.html"}),"，直接查看效果。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们开始写 React 代码，新建 ",(0,r.jsx)(n.code,{children:"client.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from'./app'\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"app.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useState } from 'react';\n\nexport default function MyApp() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <h1>Counters { count } times</h1>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"代码逻辑很简单，就是我们初学 React 时，在 React 官网常看到的点击按钮更新次数的计数器例子。"}),"\n",(0,r.jsxs)(n.p,{children:["因为 JavaScript 不能直接识别 React 的 JSX 格式，所以需要 webpack 和 babel 将 JSX 代码编译成普通的 JavaScript 代码。新建 ",(0,r.jsx)(n.code,{children:"webpack.client.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const path = require('path')\n\nmodule.exports = {\n  mode: 'development',\n  entry: './client.js',\n  output: {\n    filename: 'index.js',\n    path: path.resolve(__dirname)\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', [\"@babel/preset-react\", { \"runtime\": \"automatic\" }]]\n          }\n        }\n      }\n    ]\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["注：",(0,r.jsx)(n.code,{children:"webpack.client.js"}),"是为了我们区分用于客户端还是服务端而起的名字，它不会像 ",(0,r.jsx)(n.code,{children:"webpack.config.js"}),"一样被自动读取。所以我们还需要在运行 webpack 命令的时候，指定该配置文件。"]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"package.json"}),"，添加新的脚本命令："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'{\n  "scripts": {\n    "start": "webpack --config webpack.client.js"\n  }\n}\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["此时运行 ",(0,r.jsx)(n.code,{children:"npm start"}),"，交互效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录会生成 ",(0,r.jsx)(n.code,{children:"index.js"}),"，浏览器打开 ",(0,r.jsx)(n.code,{children:"index.html"}),"，效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"csr.gif"})}),"\n",(0,r.jsx)(n.p,{children:"这就是一个典型的 CSR 例子。我们查看其 HTML 文件，也只有一个 root 节点，渲染都在客户端发生。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"功能实现：React CSR"}),"\n",(0,r.jsxs)(n.li,{children:["源码地址：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-csr-1",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-csr-1"})]}),"\n",(0,r.jsxs)(n.li,{children:["下载代码：",(0,r.jsx)(n.code,{children:"git clone -b react-csr-1 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"mini-react-ssr",children:["Mini React SSR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mini-react-ssr",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"1-step1express-起个服务",children:["1. Step1：Express 起个服务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-step1express-起个服务",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在让我们实现 SSR。实现 SSR 需要起一个服务，我们借助 Express 来实现。"}),"\n",(0,r.jsx)(n.p,{children:"注：关于为什么使用 Express 而不是 koa2？主要考虑到以下几个因素："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Express 的使用远比 koa 更加广泛，根据 2022 年（虽然 2024 年了，但 2023 年还没有出来）的",(0,r.jsx)(n.a,{href:"https://2022.stateofjs.com/en-US/other-tools/#backend_frameworks",target:"_blank",rel:"noopener noreferrer",children:"后端框架统计"}),"："]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"Express 内置的功能更加强大，生态更加丰富。语法上的差异随着 Node 的发展问题不大。更新频率上，两个框架都不算频繁，不过其本身设计就比较简单，更上层的应用还是应该用 Next.js 这类框架。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"废话不多说，让我们开始吧！涉及的目录结构和文件如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"react-ssr                           \n├─ pages                            \n│  └─ index.js                                   \n├─ package.json                     \n├─ server.js                        \n└─ webpack.server.js                \n"})}),"\n",(0,r.jsx)(n.p,{children:"运行："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 新建文件夹\nmkdir react-ssr && cd react-ssr\n\n# 自动生成 package.json\nnpm init\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后安装用到的依赖项："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install webpack webpack-cli babel-loader @babel/core @babel/preset-env @babel/preset-react react react-dom express\n"})}),"\n",(0,r.jsx)(n.p,{children:"相比 CSR 的实现，多装了一个 express，毕竟我们需要 express 起个 Node 服务。"}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const express = require('express')\nconst app = express()\n\napp.get('/', (req, res) => res.send(`\n<html>\n   <head>\n       <title>Tiny React SSR</title>\n   </head>\n   <body>\n    <div id='root'>\n      Counters 0 times\n    </div>\n   </body>\n</html>\n`))\n\napp.listen(3000, () => console.log('listening on port 3000!'))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"node server.js"}),"，效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"说明 Express 启动成功。让我们继续写 SSR。"}),"\n",(0,r.jsxs)(n.h3,{id:"2-step2实现-ssr",children:["2. Step2：实现 SSR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-step2实现-ssr",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import express from 'express'\nimport React from 'react'\nimport { renderToString } from 'react-dom/server'\nimport App from './pages/index'\n\nconst app = express()\nconst content = renderToString(<App />)\n\napp.get('/', (req, res) => res.send(`\n<html>\n   <head>\n       <title>Tiny React SSR</title>\n   </head>\n   <body>\n    <div id='root'>${content}</div>\n   </body>\n</html>\n`))\n\napp.listen(3000, () => console.log('listening on port 3000!'))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"pages/index.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React, { useState } from 'react';\n\nexport default function MyApp() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <h1>Counters { count } times</h1>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"node server.js"}),"，此时肯定会报错，有两个原因："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"我们使用了 import 语法，这是 ES 规范，而非 Node.js 的 CommonJS 规范"}),"\n",(0,r.jsx)(n.li,{children:"我们使用了 React 的 JSX 语法，JavaScript 并不认识，需要进行编译"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["为此我们需要使用 webpack、babel 进行打包，新建 ",(0,r.jsx)(n.code,{children:"webpack.server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const path = require('path') \n\nmodule.exports = {\n  mode:'development',\n  target: 'node',\n  entry: './server.js',       \n  output: {                     \n    filename: 'server.bundle.js',    \n    path: path.resolve(__dirname, 'build')    \n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      }\n    ]\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["借助 webpack，我们将 server.js 代码和依赖项都打包到 build 下的 server.bundle.js，然后我们 node 命令启动server.bundle.js 即可。修改 ",(0,r.jsx)(n.code,{children:"package.json"}),"，添加脚本命令："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'{\n  "scripts": {\n    "start": "webpack --config webpack.server.js && node ./build/server.bundle.js"\n  }\n}\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm start"}),"，效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["此时打开 ",(0,r.jsx)(n.code,{children:"localhost:3000"}),"，你会发现页面成功渲染："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"ssr.gif"})}),"\n",(0,r.jsx)(n.p,{children:"但是点击按钮毫无反应……"}),"\n",(0,r.jsxs)(n.p,{children:["这是因为我们只是调用了 ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react-dom/server/renderToString",target:"_blank",rel:"noopener noreferrer",children:"renderToString"})," 将 React 组件树转为 HTML 字符串，并没有进行任何水合（事件绑定）相关的操作，自然只是输出静态的 HTML。查看返回的 HTML："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"借助 React 提供的 Server API —— renderToString，虽然没有绑定事件，但至少我们成功的实现了服务端渲染。"}),"\n",(0,r.jsxs)(n.h3,{id:"3-step3绑定事件",children:["3. Step3：绑定事件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-step3绑定事件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"怎么绑定事件呢？"}),"\n",(0,r.jsx)(n.p,{children:"既然服务端渲染只能渲染 HTML，客户端渲染能绑定事件，那就结合一下。"}),"\n",(0,r.jsx)(n.p,{children:"我们再实现一遍 CSR， 让页面插入一个打包后的 bundle，挂载到 id 为 root 的 DOM 节点上。"}),"\n",(0,r.jsx)(n.p,{children:"也就是说，先在服务端调用 renderToString 将组件代码渲染到 HTML 中，再调用一遍客户端打包后的 bundle 代码，挂载到相同的节点，让客户端将一模一样的内容重新渲染一遍，并绑定上事件。"}),"\n",(0,r.jsx)(n.p,{children:"虽然同样的内容被渲染了 2 遍，但至少事件是绑定上去了。让我们先干起来："}),"\n",(0,r.jsx)(n.p,{children:"涉及的目录和文件如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"react-ssr                           \n├─ pages                            \n│  └─ index.js                            \n├─ client.js                                      \n├─ package.json                     \n├─ server.js                        \n├─ webpack.client.js                \n└─ webpack.server.js                \n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import express from 'express'\nimport React from 'react'\nimport { renderToString } from 'react-dom/server'\nimport App from './pages/index'\n\nconst app = express()\napp.use(express.static('public'));\nconst content = renderToString(<App />)\n\napp.get('/', (req, res) => res.send(`\n<html>\n   <head>\n       <title>Tiny React SSR</title>\n   </head>\n   <body>\n    <div id='root'>${content}</div>\n    <script src=\"/client.bundle.js\"><\/script>\n   </body>\n</html>\n`))\n\napp.listen(3000, () => console.log('listening on port 3000!'))\n"})}),"\n",(0,r.jsx)(n.p,{children:"在这段代码中，我们声明了 public 为静态文件目录。"}),"\n",(0,r.jsxs)(n.p,{children:["引用的 JS 文件地址为 ",(0,r.jsx)(n.code,{children:"/client.bundle.js"}),"，所以还需要新建 ",(0,r.jsx)(n.code,{children:"public"})," 目录，我们会将客户端代码打包到 ",(0,r.jsx)(n.code,{children:"client.bundle.js"}),"，并放到 public 目录下。"]}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"client.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from'./pages/index'\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(<App />);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"webpack.client.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const path = require('path')\n\nmodule.exports = {\n  mode: 'development',\n  entry: './client.js',\n  output: {\n    filename: 'client.bundle.js',\n    path: path.resolve(__dirname, 'public')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', [\"@babel/preset-react\", { \"runtime\": \"automatic\" }]]\n          }\n        }\n      }\n    ]\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"梳理下现在的流程："}),"\n",(0,r.jsxs)(n.p,{children:["我们先打包客户端 JS，将引用 ",(0,r.jsx)(n.code,{children:"pages/index.js"}),"核心 React 代码的 client.js 打包到 ",(0,r.jsx)(n.code,{children:"public"}),"下的 client.bundle.js 中。"]}),"\n",(0,r.jsxs)(n.p,{children:["然后将同样引用 ",(0,r.jsx)(n.code,{children:"pages/index.js"}),"核心 React 代码的 server.js 打包到 ",(0,r.jsx)(n.code,{children:"build"})," 下的 server.bundle.js 中，然后 node 开启 server.bundle.js。"]}),"\n",(0,r.jsxs)(n.p,{children:["这样当访问 ",(0,r.jsx)(n.code,{children:"localhost:3000"}),"的时候，服务端会先渲染一遍组件代码，然后输出到 HTML 中，然后引用 client.bundle.js，然后用 JS 重新渲染一遍，并同时绑定上事件。"]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"package.json"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'{\n  "scripts": {\n    "start": "webpack --config webpack.client.js && webpack --config webpack.server.js && node ./build/server.bundle.js"\n  }\n}\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm start"}),"，打开 ",(0,r.jsx)(n.code,{children:"localhost:3000"}),"，交互效果如下："]}),"\n",(0,r.jsxs)(n.p,{children:["`",(0,r.jsx)("img",{src:a,alt:"ssr-1.gif"})]}),"\n",(0,r.jsx)(n.p,{children:"此时既实现了服务端渲染，客户端也绑定上了事件，能够进行正常的点击操作。"}),"\n",(0,r.jsxs)(n.h3,{id:"4-step4hydrateroot",children:["4. Step4：hydrateRoot",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-step4hydrateroot",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["目前最大的问题就是同样的内容渲染了两遍，为了解决这个问题，React 提供了 ",(0,r.jsx)(n.a,{href:"https://react.dev/reference/react-dom/client/hydrateRoot",target:"_blank",rel:"noopener noreferrer",children:"hydrateRoot"}),"  API。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"hydrateRoot 函数允许你在先前由 react-dom/server 生成的浏览器 HTML DOM 节点中展示 React 组件。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"简单的来说，我们常用的 createRoot 会重新渲染，hydrateRoot 会复用已有的 DOM 节点（当然前提是服务端和客户端渲染一致，这样才能够复用）。"}),"\n",(0,r.jsx)(n.p,{children:"hydrateRoot 通常就是搭配 React 的服务端 API react-dom/server 而使用的：react-dom/server 负责服务端渲染，hydrateRoot 负责复用 DOM 进行水合。"}),"\n",(0,r.jsxs)(n.p,{children:["我们修改下 ",(0,r.jsx)(n.code,{children:"client.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React from 'react';\nimport { hydrateRoot } from 'react-dom/client';\nimport App from'./pages/index'\n\nhydrateRoot(document.getElementById('root'), <App />);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm start"}),"，打开 ",(0,r.jsx)(n.code,{children:"localhost:3000"}),"，交互效果如下："]}),"\n",(0,r.jsxs)(n.p,{children:["`",(0,r.jsx)("img",{src:t,alt:"ssr-1.gif"})]}),"\n",(0,r.jsx)(n.p,{children:"此时既实现了服务端渲染，客户端也绑定上了事件，也不会渲染 2 遍。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"功能实现：React SSR"}),"\n",(0,r.jsxs)(n.li,{children:["源码地址：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-1",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-1"})]}),"\n",(0,r.jsxs)(n.li,{children:["下载代码：",(0,r.jsx)(n.code,{children:"git clone -b react-ssr-1 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["想想 Next.js 的 Pages Router，如果我们在 ",(0,r.jsx)(n.code,{children:"pages/index.js"})," 中写入如下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React, { useState } from 'react';\n\nexport default function MyApp() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <h1>Counters { count } times</h1>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["当访问 ",(0,r.jsx)(n.code,{children:"/"}),"的时候，会渲染该组件的内容。是不是跟我们现在的 Mini React SSR 很像？"]}),"\n",(0,r.jsx)(n.p,{children:"不过这才刚刚开始，下篇让我们继续完善这个 Mini React SSR，并在此基础上实现 React SSG 与 React ISR。"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}let b=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F63.%E6%BA%90%E7%A0%81%E7%AF%87%20_%20%E6%89%8B%E5%86%99%20React%20SSR.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"Mini React CSR",id:"mini-react-csr",depth:2},{text:"Mini React SSR",id:"mini-react-ssr",depth:2},{text:"1. Step1：Express 起个服务",id:"1-step1express-起个服务",depth:3},{text:"2. Step2：实现 SSR",id:"2-step2实现-ssr",depth:3},{text:"3. Step3：绑定事件",id:"3-step3绑定事件",depth:3},{text:"4. Step4：hydrateRoot",id:"4-step4hydrateroot",depth:3},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);