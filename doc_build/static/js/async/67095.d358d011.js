"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["67095"],{260743:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var c=r(552676),t=r(740453);let s=r.p+"static/image/68a8ea72df87f6bc8bf234195cdcf4e2.52d35872.webp",d=r.p+"static/image/4f172b19a3451fa76e77fa771b4ddabe.a0967c28.webp",i=r.p+"static/image/82a8fc19a7c040bdca34c4d4dd407be7.6693bb31.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",h4:"h4",strong:"strong",pre:"pre",code:"code",img:"img",ul:"ul",li:"li"},(0,t.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"16设备兼容ios-300ms-delay--橡皮筋问题解决方案",children:["16.设备兼容：IOS 300ms delay & 橡皮筋问题解决方案",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16设备兼容ios-300ms-delay--橡皮筋问题解决方案",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["仓库地址： ",(0,c.jsx)(n.a,{href:"https://github.com/czm1290433700/nextjs-demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/nextjs-demo"})]}),"\n",(0,c.jsx)(n.p,{children:"本节课程效果查看依赖 mac 环境，windows 环境的 chrome 没办法完全模拟橡皮筋等效果，windows系统的同学可以安装虚拟机或是直接查看录屏 gif"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"上节课我们学习了针对低网速场景，怎么对高分辨率图进行首屏优化，我们使用了 webp 的方式优化了静态资源的加载，对低网速下的首屏场景进行了优化。与首屏优化同样常见的，还有 IOS 的兼容场景。"}),"\n",(0,c.jsx)(n.p,{children:"移动端的 Web 应用用户有不少的比例是 IOS 相关设备，IOS 与安卓的规则和标准不尽相同，我们需要对这些场景进行兼容。这一节课我们就 IOS 最常见的 300ms delay 和橡皮筋问题来一起探讨一下解决的方案。"}),"\n",(0,c.jsxs)(n.h2,{id:"300-ms-delay",children:["300 ms delay",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#300-ms-delay",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我们平时的开发中，事件的触发大部分都是立刻响应，但是在 IOS 中，移动端的触摸事件会有 300ms 的延迟。使用过 IOS 的同学应该知道，IOS 浏览器有一个特点，可以通过双击来对屏幕页面进行缩放，这是导致 300ms 延迟的核心原因。因为当一个用户点击链接后，浏览器没办法判定用户是想双击缩放，还是进行点击事件触发，所以 IOS Safari 会统一等待 300ms，来判断用户是否会再次点击屏幕。"}),"\n",(0,c.jsxs)(n.h4,{id:"meta-禁用缩放",children:["Meta 禁用缩放",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#meta-禁用缩放",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"这个是我比较推荐的方案"}),"，因为 300ms 延迟的初衷是为了解决点击和缩放没办法区分的问题，针对不需要缩放的页面，我们可以通过禁用缩放来解决。事实上，大部分移动端页面都是可以避免缩放的，通过交互等样式的兼容即可。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'// ./pages/_app.tsx\n// head加这两行即可\n// ...\n< meta name="viewport" content="user-scalable=no" >\n< meta name="viewport" content="initial-scale=1,maximum-scale=1" > \n'})}),"\n",(0,c.jsxs)(n.h4,{id:"更改视口尺寸",children:["更改视口尺寸",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更改视口尺寸",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://codereview.chromium.org/18850005/",target:"_blank",rel:"noopener noreferrer",children:"Chrome 32 版本"})," 中 Chrome 浏览器对包含 width=device-width 或者比 viewport 更小的页面禁用双击缩放，我们只需要加上下面的 meta 头，就可以在 IOS 中的 chrome 浏览器解决 300ms delay 的问题，这个方案的好处是，并不会完全禁用缩放。但是 IOS 默认的 Safari 浏览器没有支持这个能力，所以我们可以加上这个 meta 头来兼容视口尺寸，但并不作为这个的解决方案。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'<meta name="viewport" content="width=device-width">\n'})}),"\n",(0,c.jsxs)(n.h4,{id:"touch-action",children:["Touch-action",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#touch-action",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.a,{href:"https://w3c.github.io/pointerevents/",target:"_blank",rel:"noopener noreferrer",children:"W3C 草案"})," 中，有提出一个 touch-action css 属性，通过设置 ",(0,c.jsx)(n.code,{children:"touch-action: none"}),"可以移除目标元素的 300ms delay，如果这个日后可以被主流浏览器支持，我更推荐大家用这种方式针对区域进行灵活的限制。"]}),"\n",(0,c.jsxs)(n.h4,{id:"fastclick",children:["fastclick",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#fastclick",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这是一个老牌的解决 300ms 延迟的轻量 JS 库，可以通过 npm 安装，且使用方式简单。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"window.addEventListener(\n    'load',\n    () => {\n      FastClick.attach(document.body);\n    },\n    false\n  );\n"})}),"\n",(0,c.jsx)(n.p,{children:"这个依赖我也有试用过，但是我觉得并不是一个好的方案，不建议大家使用 fastclick 的方式解决这个问题，有几个原因："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["对 TS 兼容性太差，fastclick 基于 JS ，虽然有 ts for fastclick 的依赖，但是不被原作者认可，并且类型定义存在问题，直接引入依赖存在问题，需要自行进入模块定义中修改，具体可参照 ",(0,c.jsx)(n.a,{href:"https://www.codenong.com/cs106613514/",target:"_blank",rel:"noopener noreferrer",children:"https://www.codenong.com/cs106613514/"})," 。"]}),"\n"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"包体过大，且包八年没再维护。"}),"\n"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"不能直接用于 SSR ，里面有直接用到 BOM ，在服务器端渲染的时候会有相关报错，没找到比较好的插件可以兼容这个问题。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"对 fastclick 感兴趣的同学可以下来试试，最终还是建议大家采用 meta 禁用缩放的方式，兼容性和效果相对是比较理想的。"}),"\n",(0,c.jsxs)(n.h2,{id:"橡皮筋问题",children:["橡皮筋问题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#橡皮筋问题",children:"#"})]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"IOS上，当页面滚动到顶部或底部仍可向下或向上拖拽，并伴随一个弹性的效果。该效果被称为“rubber band”——橡皮筋，十分贴切。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"IOS 和安卓不同，即使页面没有设置滚动，仍然可以拉扯，给人一种橡皮筋的感觉，如果是 Mac 系统的同学，可以打开 Chrome 模拟查看我们的页面，可以看到下面的效果。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:"dd956d94-6971-43af-8848-9ab4fdaa2297.gif"})}),"\n",(0,c.jsx)(n.p,{children:"那么怎么去解决这个问题呢？我们来讨论一下。"}),"\n",(0,c.jsxs)(n.h4,{id:"overflow-给定宽高--禁用-touchmove-事件",children:["overflow 给定宽高 / 禁用 touchmove 事件",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#overflow-给定宽高--禁用-touchmove-事件",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"大家如果尝试搜索橡皮筋的解决方案，会发现很多文章都会采用下面这两种方案去解决。但是，这两种方案是完全不可取的，会完全禁用掉下滑的滚动，对即使有滚动的页面也会影响到原有的滚动。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"html, body {\n  width: 100%;\n  height: 100%;\n  overflow: hidden；\n}\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"document.body.addEventListener('touchmove', function (e) {\n    e.preventDefault() \n  }, {passive: false}) \n"})}),"\n",(0,c.jsxs)(n.h4,{id:"监听滚动禁用",children:["监听滚动禁用",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#监听滚动禁用",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这是我之前开发时候想到的比较 hack 的方案，IOS 橡皮筋的原理还是通过滚动，只不过与安卓不同的是，当到边界状态时，仍允许滚动，如果我们替 IOS 禁用边界的情况，理论上就可以实现对橡皮筋效果的禁用。针对上述思路，我曾经有实现如下 hook。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"import { useEffect } from 'react';\n\n\nexport const useForbidIosScroll = (): void => {\n  let startEvent: TouchEvent;\n\n\n  const cancelEvent = (e: TouchEvent): void => {\n    // 有个瑕疵就是，如果是大惯性的那种滚动，浏览器该事件并不接受你禁用当前正在执行的动作\n    // 导致如果猛地滑动会出页面边界\n    if (e.cancelable) {\n      e.preventDefault();\n    }\n  };\n\n\n  const checkScroll = (e: TouchEvent): void => {\n    const startY = Number(startEvent?.touches[0].pageY);\n    const endY = Number(e?.touches[0].pageY);\n\n\n    // 下滑且滑动到底\n    if (startY > endY && window.scrollY + window.innerHeight >= document.body.scrollHeight) {\n      cancelEvent(e);\n    }\n\n\n    // 上滑且滑动到顶\n    if (startY < endY && window.scrollY <= 0) {\n      cancelEvent(e);\n    }\n  };\n\n\n  useEffect(() => {\n    const start = (e: TouchEvent): void => {\n      startEvent = e;\n    };\n    const end = (e: TouchEvent): void => {\n      checkScroll(e);\n    };\n    window.addEventListener('touchstart', start);\n    window.addEventListener('touchmove', end, { passive: false });\n    return (): void => {\n      window.removeEventListener('touchstart', start);\n      window.removeEventListener('touchmove', end);\n    };\n  }, []);\n};\n"})}),"\n",(0,c.jsx)(n.p,{children:"这个效果其实并不是很理想，即使脚本已经走到我们中断的逻辑，滚动的行为在到达边界的时候仍然不会中止。感兴趣的同学可以 cancelEvent 方法中加一个 debugger 断点验证。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"The scroll event cannot be canceled. ( scroll 事件无法取消。) But you can do it by canceling these interaction events"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["到谷歌浏览器开发者文档里可以查看到，浏览器的事件其实分为两种，cancelable（可暂停）和uncancelable（不可暂停），能够通过阻止默认事件的和阻止冒泡的都是可暂停的事件，滚动事件和鼠标滚轮事件，在触发的瞬间，就已经决定了要滚动到终点再停止，你只能暂停可能会影响滚动的前提的",(0,c.jsx)(n.strong,{children:"导线事件"}),"，我们这个场景下，滚动事件就已经是起源的操作，不存在间接触发，所以不行。"]}),"\n",(0,c.jsxs)(n.h4,{id:"最终方案",children:["最终方案",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最终方案",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["有一个很简单的方案，并且可以完美解决",(0,c.jsx)(n.a,{href:"https://bytedance.feishu.cn/docx/doxcnO1Ab9phKQaZiRHh63h2frg",target:"_blank",rel:"noopener noreferrer",children:"14 | 自定义组件: 如何实现一个动画弹窗组件？"}),"中提到的滚动栏丢失的问题，我们给 body 进行隐藏，然后对根节点设置 100 页宽的高度，",(0,c.jsx)(n.strong,{children:"将外部 body 的滚动移动到页面内，这样外界的滚动相关的问题都会解决"}),"，因为我们页面采用的实际是内部滚动。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"// ./pages/global.scss\n.forbidScroll {\n  height: 100vh;\n  overflow: hidden;\n}\nbody {\n  //...\n  overflow: hidden;\n}\n\n#__next {\n  height: 100vh;\n  overflow: auto;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"大家可以看看改后的效果，发现橡皮筋的功能已经禁用了，大家可以再把之前解决弹窗的那部分代码移除，问题应该同样解决了，因为我们现在页面采用的是页面内部 div 的滚动，外部 body 的滚动相关的问题也随之解决。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:"Screen-Recording-2022-08-27-at-4.05.26-PM.gif"})}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这节课我们学习了 IOS 300ms delay 和橡皮筋问题的缘由和解决方案，我们对比了几种不同的方案，通过 meta 解决了 300ms delay，以及移除外部滚动，改用页面内滚动的方式解决了橡皮筋问题，并且我们还得到了一个意外的收获，之前在",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7137945369635192836/section/7141554348504383500g",target:"_blank",rel:"noopener noreferrer",children:"14 | 自定义组件: 如何实现一个动画弹窗组件？"})," 中遇到的滚动栏丢失问题也因为禁用外部滚动，改用页面内滚动而随之解决。"]}),"\n",(0,c.jsx)(n.p,{children:"当然 IOS 的问题还远不止此，作为一名 C 端开发者，我们不仅要考虑常规的 B 端 ie 等兼容问题，移动端的兼容问题我们也需要着重关注，后续大家遇到这类问题，大家没有思路可以到 MDN 或是浏览器的开发文档中看看最新的草案，评估兼容性，可能会有额外的收获。"}),"\n",(0,c.jsx)(n.p,{children:"到这里，我们性能优化篇也就画上句号了，我们官网大部分的功能都已经实现了，从下一节课开始，我们将开始进入部署篇的学习，为上线和之后的运营做准备。下一节课，我们将先首先来学习如何对官网项目进行压力测试。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}let o=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["SSR%20%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%98%E7%BD%91%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F16.%E8%AE%BE%E5%A4%87%E5%85%BC%E5%AE%B9%EF%BC%9AIOS%20300ms%20delay%20%26%20%E6%A9%A1%E7%9A%AE%E7%AD%8B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.md"]={toc:[{text:"300 ms delay",id:"300-ms-delay",depth:2},{text:"Meta 禁用缩放",id:"meta-禁用缩放",depth:4},{text:"更改视口尺寸",id:"更改视口尺寸",depth:4},{text:"Touch-action",id:"touch-action",depth:4},{text:"fastclick",id:"fastclick",depth:4},{text:"橡皮筋问题",id:"橡皮筋问题",depth:2},{text:"overflow 给定宽高 / 禁用 touchmove 事件",id:"overflow-给定宽高--禁用-touchmove-事件",depth:4},{text:"监听滚动禁用",id:"监听滚动禁用",depth:4},{text:"最终方案",id:"最终方案",depth:4},{text:"小结",id:"小结",depth:2}],title:"16.设备兼容：IOS 300ms delay & 橡皮筋问题解决方案",headingTitle:"16.设备兼容：IOS 300ms delay & 橡皮筋问题解决方案",frontmatter:{}}}}]);