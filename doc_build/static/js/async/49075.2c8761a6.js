"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["49075"],{391565:function(e,r,n){n.r(r),n.d(r,{default:()=>o});var c=n(552676),s=n(740453);let i=n.p+"static/image/54d5b31ff9fb3570bfdd8f1d25d6d4e9.77f99e74.webp",h=n.p+"static/image/73876e040055713bc23dbbf8eef7b4d4.60e16570.webp",t=n.p+"static/image/9ca9e3a375224799c2f3ede8fb00c486.d617148c.webp",a=n.p+"static/image/fc2e74ae821bc0d56e1caa096ca52ae8.67401482.webp";function l(e){let r=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",strong:"strong",ul:"ul",li:"li",h3:"h3",img:"img",pre:"pre",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(r.h1,{id:"10浏览器缓存2渐进增强强大而又难以驾驭的-service-worker",children:["10.浏览器缓存2：渐进增强——强大而又难以驾驭的 Service Worker",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#10浏览器缓存2渐进增强强大而又难以驾驭的-service-worker",children:"#"})]}),"\n",(0,c.jsxs)(r.p,{children:["在浏览器缓存的世界中，不同的缓存扮演着不同的角色，缓存存储的位置的也不尽相同，除了上文介绍的内存和磁盘外，本文将介绍在服务器与浏览器间扮演中间人角色的缓存 —— ",(0,c.jsx)(r.code,{children:"Service Worker"}),"。"]}),"\n",(0,c.jsx)(r.p,{children:"提及 Service Worker 有些人可能会觉得陌生，因为不是所有的项目都适合使用它，但如果你的网页正在追求一种极致的性能体验，那么 Service Worker 可以帮你达成这一目标，而要了解 Service Worker 首先还得从渐进式 Web 应用说起。"}),"\n",(0,c.jsxs)(r.h2,{id:"从渐进式-web-应用开始",children:["从渐进式 Web 应用开始",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#从渐进式-web-应用开始",children:"#"})]}),"\n",(0,c.jsx)(r.p,{children:"随着移动互联网的发展，为了满足用户在手机上操作页面的便捷性，诸多 PC 应用也纷纷推出了自己的移动版本，而移动原生应用不管在用户体验还是功能上都比传统的 web 应用强大得多，比如快速的页面加载、及时的信息推送和离线可用等，而这些功能当时在 web 应用中都存在着限制，于是成千上万个采用 iOS、Android 原生技术开发的应用如雨后春笋般出现，成功打下了该领域的一片“江山”。"}),"\n",(0,c.jsxs)(r.p,{children:["为了让 web 技术在移动时代的浪潮中能够分得一杯羹，各大浏览器厂商便纷纷开始支持及推进渐进式 Web 应用（",(0,c.jsx)(r.code,{children:"Progressive Web Apps"}),"）的使用，即我们熟知的 PWA。"]}),"\n",(0,c.jsx)(r.p,{children:"那么什么是渐进式 Web 应用？"}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)(r.strong,{children:"从本质上讲，渐进式 Web 应用程序仍然是 Web 应用程序，但其支持渐进式增强，在现代浏览器中可以使用新功能，如果新功能不可用，用户仍然可以获得核心的体验。"})}),"\n",(0,c.jsx)(r.p,{children:"其特性主要体现在："}),"\n",(0,c.jsxs)(r.ul,{children:["\n",(0,c.jsx)(r.li,{children:"功能强大（在现代 API、WebAssembly 和新的即将推出的 API 之间，Web 应用程序比以往任何时候都更强大）"}),"\n",(0,c.jsx)(r.li,{children:"可靠性（无论网络如何，可靠的渐进式 Web 应用程序都会让用户感觉到快速）"}),"\n",(0,c.jsx)(r.li,{children:"可安装（已安装的渐进式 Web 应用程序在独立窗口中运行，而不是在浏览器 tab 页中运行）"}),"\n"]}),"\n",(0,c.jsx)(r.p,{children:"而实现以上特性的关键技术就是本文的主人公 Service Worker。"}),"\n",(0,c.jsxs)(r.h2,{id:"service-worker-登场",children:["Service Worker 登场",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#service-worker-登场",children:"#"})]}),"\n",(0,c.jsxs)(r.h3,{id:"概念",children:["概念",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#概念",children:"#"})]}),"\n",(0,c.jsx)(r.p,{children:"Service Worker 本质上是一种用 JavaScript 编写的脚本，其作为一个独立的线程，它可以使应用程序能够控制网络请求，缓存这些请求以提高性能，并提供对缓存内容的离线访问。"}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)("img",{src:a,alt:"Service Worker 中间人.png"})}),"\n",(0,c.jsxs)(r.p,{children:["Service Worker 依赖两个 API 使应用程序离线工作：",(0,c.jsx)(r.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Cache",target:"_blank",rel:"noopener noreferrer",children:"Cache"}),"（应用程序数据的持久性内容存储）和\xa0\xa0",(0,c.jsx)(r.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API",target:"_blank",rel:"noopener noreferrer",children:"Fetch"}),"（一种从网络检索内容的标准方法）。",(0,c.jsx)(r.strong,{children:"Service Worker 缓存是持久的，独立于浏览器缓存或网络状态。"})]}),"\n",(0,c.jsxs)(r.h3,{id:"生命周期与缓存",children:["生命周期与缓存",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#生命周期与缓存",children:"#"})]}),"\n",(0,c.jsx)(r.p,{children:"Service Worker 在其生命周期中会经历以下三个步骤："}),"\n",(0,c.jsxs)(r.ul,{children:["\n",(0,c.jsx)(r.li,{children:"注册"}),"\n",(0,c.jsx)(r.li,{children:"安装"}),"\n",(0,c.jsx)(r.li,{children:"激活"}),"\n"]}),"\n",(0,c.jsx)(r.p,{children:"通常我们会编写以下脚本进行 Service Worker 的注册："}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-javascript",children:"if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.register('/sw.js').then(function(registration) {\n          console.log('Registration successful, scope is:', registration.scope);\n      })\n      .catch(function(error) {\n          console.log('Service worker registration failed, error:', error);\n      });\n}\n"})}),"\n",(0,c.jsxs)(r.p,{children:["首先判断浏览器支不支持 ",(0,c.jsx)(r.code,{children:"serviceWorker"})," API，支持后注册时会去读取对应的 sw.js 文件，默认情况下 Service Worker 的作用范围不能超出其脚本所在的路径，如果上述脚本放在根目录下，那么代表项目根目录下的所有请求都可以代理。当然也可以在注册时指定对应的作用域："]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-javascript",children:"navigator.serviceWorker.register('/sw.js', {\n    scope: '/xxx' \n})\n"})}),"\n",(0,c.jsx)(r.p,{children:"此时 Service Worker 只会代理 xxx 目录下的请求。"}),"\n",(0,c.jsx)(r.p,{children:"一旦浏览器执行了注册流程后，在 sw.js 文件中，其便会尝试执行 Service Worker 的 install 安装事件，该事件只会触发一次，即在首次注册或者有新的 Service Worker 之后执行。在安装事件中我们可以下载并预缓存应用的部分内容，以便在用户下次访问时立即得到加载。以 Chrome 官网的例子为例："}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-javascript",children:"// sw.js\n\n// 此版本的 Service Worker 中使用的两个缓存的名称，更新任意一个缓存名称，都将再次触发安装事件\nconst PRECACHE = 'precache-v1'\nconst RUNTIME = 'runtime'\n\n// 想被缓存的本地资源列表\nconst PRECACHE_URLS = [\n    'index.html',\n    './', // index.html 的别名\n    'styles.css',\n\xa0   '../../styles/main.css',\n    'demo.js'\n]\n\n// 安装事件中缓存预先我们想要缓存的资源\nself.addEventListener('install', event => {\n    event.waitUntil(\n        // 调用浏览器 CacheStorage open 方法\n        caches.open(PRECACHE)\n            .then(cache => cache.addAll(PRECACHE_URLS))\n            .then(self.skipWaiting()) // self.skipWaiting 可以阻止等待，让新的 Service Worker 安装成功后立即激活\n    )\n})\n"})}),"\n",(0,c.jsx)(r.p,{children:"在安装事件中我们会缓存预先想要缓存的资源，成功安装 Service Worker 后，它会过渡到激活阶段。如果有前一个 Service Worker 控制的打开页面存在，则新的 Service Worker 会进入一个 waiting 状态。新的 Service Worker 仅在不再加载任何仍在使用旧 Service Worker 的页面时激活，这确保在任何给定时间只有一个版本的 Service Worker 正在运行。"}),"\n",(0,c.jsxs)(r.p,{children:["我们也可以调用 ",(0,c.jsx)(r.code,{children:"skipWaiting()"})," 方法阻止 Service Worker 等待，让新的 Service Worker 安装成功后立即激活。"]}),"\n",(0,c.jsxs)(r.p,{children:["当新的 Service Worker 激活时，其会触发 ",(0,c.jsx)(r.code,{children:"active"})," 事件，我们可以使用 ",(0,c.jsx)(r.code,{children:"addEventListener"})," 来监听 activate 事件。在此事件中我们通常会清理过期的缓存："]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-javascript",children:"// sw.js\n\n// active 事件负责清理过期缓存\nself.addEventListener('activate', event => {\n    const currentCaches = [PRECACHE, RUNTIME]\n\n    event.waitUntil(\n        caches.keys().then(cacheNames => {\n            return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));\n        }).then(cachesToDelete => {\n            return Promise.all(cachesToDelete.map(cacheToDelete => {\n                return caches.delete(cacheToDelete) // 删除不存在的过期缓存\n            }))\n        }).then(() => self.clients.claim()) // 启用新的 Service Worker\n    )\n})\n"})}),"\n",(0,c.jsxs)(r.p,{children:["上述我们在 active 生命周期中通过调用浏览器的 ",(0,c.jsx)(r.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Cache",target:"_blank",rel:"noopener noreferrer",children:"Cache"})," API 的 delete 方法将过期的缓存进行了删除操作，防止过期缓存影响现有的功能。"]}),"\n",(0,c.jsxs)(r.p,{children:["一旦激活，Service Worker 将控制在其范围内加载的所有页面，新的 Service Worker 只会在我们关闭并重新打开应用时启用，或者调用 ",(0,c.jsx)(r.code,{children:"clients.claim()"})," 方法。"]}),"\n",(0,c.jsx)(r.p,{children:"至此相信大家对 Service Worker 在其生命周期中会经历的三个步骤“注册、安装和激活”以及如何将资源添加到缓存中已经有了一定的认识，那么下面我们再来了解下 Service Worker 如何拦截网络请求并从缓存中获取资源。"}),"\n",(0,c.jsxs)(r.h3,{id:"优先从缓存中获取资源",children:["优先从缓存中获取资源",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#优先从缓存中获取资源",children:"#"})]}),"\n",(0,c.jsx)(r.p,{children:"如果大家想让自己的网页离线可用，那么拦截网络请求并从缓存中获取资源是最主要的方法，当然前提是缓存中已经存在了所要访问的资源。"}),"\n",(0,c.jsxs)(r.p,{children:["我们一般会采用",(0,c.jsx)(r.strong,{children:"缓存回退网络"}),"的方式进行代码的编写，即拦截请求时如果缓存中存在该资源则直接获取，否则再向服务端请求资源并进行缓存。示例代码如下："]}),"\n",(0,c.jsx)(r.pre,{children:(0,c.jsx)(r.code,{className:"language-javascript",children:"// sw.js\n\n// fetch 处理事件会处理同源资源的响应，如果缓存中存在，则会直接返回缓存资源\nself.addEventListener('fetch', event => {\n    // 跳过跨域请求\n    if (event.request.url.startsWith(self.location.origin)) {\n        event.respondWith(\n            // 从缓存中匹配请求的资源\n            caches.match(event.request).then(cachedResponse => {\n                // 存在则直接返回\n                if (cachedResponse) {\n                    return cachedResponse;\n                }\n                \n                // 不存在则回退网络请求\n                return caches.open(RUNTIME).then(cache => {\n                    return fetch(event.request).then(response => {\n                        // 拷贝响应资源存入 runtime 缓存.\n                        return cache.put(event.request, response.clone()).then(() => {\n                            return response;\n                        })\n                    })\n                })\n            })\n        )\n    }\n})\n"})}),"\n",(0,c.jsxs)(r.p,{children:["上述代码我们通过监听 ",(0,c.jsx)(r.code,{children:"fetch"})," 事件处理程序进行资源请求的拦截操作，实现了 Service Worker 基本的优先从缓存中获取资源的功能。"]}),"\n",(0,c.jsx)(r.p,{children:"最终我们将代码组合起来便完成了一个简单的可离线访问功能。当浏览器命中 Service Worker 缓存时，资源在开发者工具中将被显示为从 ServiceWorker 获取。"}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)("img",{src:t,alt:"20210924220113.jpg"})}),"\n",(0,c.jsxs)(r.p,{children:["当然除了上述介绍的 ",(0,c.jsx)(r.code,{children:"install"}),"、",(0,c.jsx)(r.code,{children:"activate"}),"、",(0,c.jsx)(r.code,{children:"fetch"})," 事件，Service Worker 还有其他几个主要的事件，通过按需集成这些事件我们便可以开发强大而体验友好的渐进式 web 应用程序。"]}),"\n",(0,c.jsx)(r.p,{children:"这里笔者用一张图汇总了 Service Worker 的一些主要事件，大家有兴趣可以继续探索。"}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)("img",{src:h,alt:"Service Worker 主要事件.png"})}),"\n",(0,c.jsxs)(r.h3,{id:"兼容性",children:["兼容性",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#兼容性",children:"#"})]}),"\n",(0,c.jsxs)(r.p,{children:["虽然 Service Worker 具有强大的功能，但不同浏览器及其版本对它的兼容性都有所不同，从 ",(0,c.jsx)(r.a,{href:"https://caniuse.com/?search=Service%20Worker",target:"_blank",rel:"noopener noreferrer",children:"caniuse"})," 中查询 Service Worker 的浏览器兼容性结果如下："]}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)("img",{src:i,alt:"20210920112302.jpg"})}),"\n",(0,c.jsx)(r.p,{children:"因此出于渐进式体验的考虑，在不支持 Service Worker 的低版本浏览器中，我们可能仍然需要进行一些兼容处理，使用户可以使用其主要功能。"}),"\n",(0,c.jsx)(r.p,{children:(0,c.jsx)(r.strong,{children:"同时出于安全考虑，Service worker 只能在 https 及 localhost 下被使用。"})}),"\n",(0,c.jsxs)(r.h2,{id:"结语",children:["结语",(0,c.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#结语",children:"#"})]}),"\n",(0,c.jsxs)(r.p,{children:[(0,c.jsx)(r.strong,{children:"渐进增强和优雅降级是程序开发中常用的两种手段"}),"，而渐进增强是渐进式 web 应用的核心所在，Service Worker 在传统网页中的使用也正是渐进增强手段的体现。"]}),"\n",(0,c.jsx)(r.p,{children:"当然并不是所有的网页都适合使用 Service Worker 技术，一般当你的应用趋于稳定并且用户体验决定着用户存留的时候，此时不妨可以试试它。比如 Twitter 在使用渐进式 Web 应用后的结果让人印象深刻："}),"\n",(0,c.jsxs)(r.blockquote,{children:["\n",(0,c.jsx)(r.p,{children:"Twitter 每次会话的页面增加了 65%，推文增加了 75%，跳出率降低了 20%，同时其应用程序的大小减少了 97% 以上。改用 PWA 后，日均自然流量增加了 2.3 倍，订阅增加了 58%，每日活跃用户增加了 49%。"}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),e.components);return r?(0,c.jsx)(r,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90%2F10.%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%982%EF%BC%9A%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E2%80%94%E2%80%94%E5%BC%BA%E5%A4%A7%E8%80%8C%E5%8F%88%E9%9A%BE%E4%BB%A5%E9%A9%BE%E9%A9%AD%E7%9A%84%20Service%20Worker.md"]={toc:[{text:"从渐进式 Web 应用开始",id:"从渐进式-web-应用开始",depth:2},{text:"Service Worker 登场",id:"service-worker-登场",depth:2},{text:"概念",id:"概念",depth:3},{text:"生命周期与缓存",id:"生命周期与缓存",depth:3},{text:"优先从缓存中获取资源",id:"优先从缓存中获取资源",depth:3},{text:"兼容性",id:"兼容性",depth:3},{text:"结语",id:"结语",depth:2}],title:"10.浏览器缓存2：渐进增强——强大而又难以驾驭的 Service Worker",headingTitle:"10.浏览器缓存2：渐进增强——强大而又难以驾驭的 Service Worker",frontmatter:{}}}}]);