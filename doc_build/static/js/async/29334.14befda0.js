"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["29334"],{300862:function(e,n,r){r.r(n),r.d(n,{default:()=>b});var s=r(552676),a=r(740453);let t=r.p+"static/image/c25a2ebe8c9bebe289e5f9eb1e417d6b.16f898f8.webp",o=r.p+"static/image/692d29055554d75b3cb14624bc8bdf79.7b2b6482.webp",i=r.p+"static/image/6e3983db002b8ee85be7019f97146752.21b049bb.webp",c=r.p+"static/image/a6f3f922bd3443d93f009f507ace0532.01a350e6.webp",l=r.p+"static/image/9b37651dfe1b2a134228ab4e2be5bacd.81d543d8.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",blockquote:"blockquote",code:"code",strong:"strong",pre:"pre",img:"img",h3:"h3",h4:"h4"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"24生态篇-react-mobx",children:["24.生态篇-React-mobx",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24生态篇-react-mobx",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章节将继续介绍 React 的另外一个状态管理工具 React-Mobx 。希望通过本章节的学习，你能收获："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Mobx 的特性及其基本使用；"}),"\n",(0,s.jsx)(n.li,{children:"Mobx ，React-Mobx 原理解析（源码级别）；"}),"\n",(0,s.jsx)(n.li,{children:"Mobx 和 Redux 区别。"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注意：今天讲的 Mobx 为 ",(0,s.jsx)(n.code,{children:"v6"})," 版本，Mobx-React 为 ",(0,s.jsx)(n.code,{children:"v7"})," 版本。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"二-mobx特性",children:["二 Mobx特性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-mobx特性",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"同为状态管理工具，Mobx 和 Redux 本质上上有很大的区别，但是 Mobx 和 Redux 都是独立的，不依赖于 React 本身；为了把 React 和 Mobx 关联起来，在 React 应用中更好的使用 Mobx ，出现了 mobx-react ， mobx-react 提供了 HOC ，可以获取状态管理 Mobx 的数据层，也能接受 mobx 数据改变带来的更新。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"①观察者模式"})}),"\n",(0,s.jsxs)(n.p,{children:["Mobx 采用了一种'观察者模式'——",(0,s.jsx)(n.code,{children:"Observer"}),"，整个设计架构都是围绕 Observer 展开："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["在 mobx 的状态层，每一个需要观察的属性都会添加一个观察者，可以称之为 ",(0,s.jsx)(n.code,{children:"ObserverValue"})," 。"]}),"\n",(0,s.jsx)(n.li,{children:"有了观察者，那么就需要向观察者中收集 listener ，mobx 中有一个 Reaction 模块，可以对一些行为做依赖收集，在 React 中，是通过劫持 render 函数执行行为，进行的依赖收集。"}),"\n",(0,s.jsx)(n.li,{children:"如何监听改变，用自定义存取器属性中的 get 和 set ，来进行的依赖收集和更新派发，当状态改变，观察者会直接精确通知每个 listener 。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"②状态提升"})}),"\n",(0,s.jsx)(n.p,{children:"在正常情况下，在 React 应用中使用 Mobx ，本质上 mobx 里面的状态，并不是存在 React 组件里面的，是在外部由一个个 mobx 的模块 model 构成，每一个 model 可以理解成一个对象，状态实质存在 model 中，model 状态通过 props 添加到组件中，可以用 mobx-react 中的 Provder 和 inject 便捷获取它们，虽然 mobx 中响应式处理这些状态，但是不要试图直接修改 props 来促使更新，这样违背了 React Prop 单向数据流的原则。正确的处理方法，还是通过 model 下面的 action 方法，来改变状态，React 实质上调用的是 action 方法。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"③装饰器模式"})}),"\n",(0,s.jsxs)(n.p,{children:["为了建立观察者模式，便捷地获取状态/监听状态，mobx 很多接口都支持装饰器模式的写法，所以在 mobx 中，装饰器模式是最常用的写法，如果不知道装饰器的同学，建议先了解一下下 ts 中",(0,s.jsx)(n.code,{children:"decorator"}),"，由于不是本章节的内容，我这里就不介绍了。比如如下就是 mobx 中装饰器的体现："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Root{\n    @observable name = 'alien' /* 建立观察者name属性 */\n    @action setName(name){  this.name = name   }  /* 改变 name 属性 */\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["目前 typescript 已经全面支持如上写法，如果在 javascript 中直接使用会报错，所以通常需要在",(0,s.jsx)(n.code,{children:".babelrc"})," 中这么配置一下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "plugins":[\n         [\n          "@babel/plugin-proposal-decorators",\n          {\n            "legacy": true,\n            "loose": true\n          }\n        ],\n        "@babel/plugin-proposal-class-properties",\n    ]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"如上添加配置后，就可以在 js 中正常使用装饰器模式了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"④精确颗粒化收集"})}),"\n",(0,s.jsx)(n.p,{children:"mobx 还有一个重要特点，就是对于属性的依赖收集是精确的，颗粒化的，为什么这么说呢？比如在 mobx 一个模块如下写道："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Root {\n    @observable object = {                  //C组件使用\n         name:'alien',                     // A组件使用\n         mes:'let us learn React!'         // B组件使用\n    }\n    @action setName(name){ this.object.name = name  }\n    @action setMes(mes){ this.object.mes = mes }\n    @action setObject(object){ this.object = object  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"对于 observable 处理过的属性，每一个属性都会有 ObserverValue ，比如上面的结构会产生三个 ObserverValue ，分别对应 object ，name ，mes 。"}),"\n",(0,s.jsx)(n.li,{children:"当上面通过 setName 改变 name 属性的时候，只有组件 A 会更新。也就是 name ObserverValue 只收集了用到 name 的依赖项 A 组件。"}),"\n",(0,s.jsx)(n.li,{children:"调用 setMes 同理，只有组件 B 更新。 mes  ObserverValue 只收集了 B 组件的依赖。"}),"\n",(0,s.jsx)(n.li,{children:"当上面通过 setObject 改变 object 的时候，即使 object 里面name ，mes 的值没有变化，也会让组件 A ，组件 B ，组件 C ，全部渲染。object 的 Observer 同样收集了name的 ObserverValue 和 mes 的 ObserverValue 。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"模型图如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"2.jpg"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"⑤引用类型处理"})}),"\n",(0,s.jsx)(n.p,{children:"observable 对于引用数据类型，比如 Object ，Array ，Set ，Map等，除了新建一个 observable 之外，还会做如下两点操作。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["一 ",(0,s.jsx)(n.code,{children:"Proxy"}),"：会把原始对象用 Proxy 代理，Proxy 会精确响应原始对象的变化，比如增加属性——给属性绑定 ObserverValue ，删除属性——给属性解绑 ObserverValue 等。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["二 ",(0,s.jsx)(n.code,{children:"ObservableAdministration"}),"： 对于子代属性，会创建一个 ",(0,s.jsx)(n.code,{children:"ObservableAdministration"}),"，用于管理子代属性的ObserverValue。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["对于外层 Root ，在 ",(0,s.jsx)(n.code,{children:"constructor"})," 使用 ",(0,s.jsx)(n.code,{children:"makeObservable"})," ，mobx 会默认给最外层的 Root 添加 ObservableAdministration 。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"三-基本用法",children:["三 基本用法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-基本用法",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1-mobx基本使用",children:["1 Mobx基本使用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-mobx基本使用",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"mobx常用api",children:["mobx常用api",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mobx常用api",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"把上述每一个 class 称之为一个模块，如上述 Root 就是一个模块。mobx的 api 基本用于构建每一个响应式模块。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"① makeObservable"})}),"\n",(0,s.jsx)(n.p,{children:"在新版本 mobx 中，想要让整个模块变成可响应式的，那么需要在 constructor 调用 makeObservable。老版本的 mobx 不需要这么做。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"constructor(){ makeObservable(this) }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"② observable"})}),"\n",(0,s.jsx)(n.p,{children:"会给属性值加一个观察者对象，使其能变成可观察的，当属性值改变的时候，观察者会通知每一个依赖项。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@observable name = '《React进阶实践指南》'\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"③action"})}),"\n",(0,s.jsx)(n.p,{children:"通过 action 包裹的函数，可以用来修改 mobx 中的状态。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@action setName(newName){ this.name = newName  }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"④computed"})}),"\n",(0,s.jsx)(n.p,{children:"根据现有的状态或其它计算值衍生出的值。如下 total 是通过 price 和 count 衍生出来的新值。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@observable price = 666  // 可观察属性——价格\n@observable count = 1    // 可观察属性——数量\n@computed get total() {  \n    return this.price * this.count\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"mobx-react-常用-api",children:["mobx-react 常用 api",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mobx-react-常用-api",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"mobx-react 中的 api ，用于把 mobx 中的状态，提供给组件，并把组件也变成可观察的 —— mobx 状态改变，组件触发更新。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"①Provider"})}),"\n",(0,s.jsx)(n.p,{children:"用于把 mobx 的各个模块，用 Context 上下文形式，保存起来，供给组件使用。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"<Provider Root={Root} > { /* ... */ } </Provider>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"②inject"})}),"\n",(0,s.jsx)(n.p,{children:"inject 高阶组件可以把 Provider 中的 mobx 模块，混入到组件的 props 中，所以就可以在组件中消费状态，或者调用改变状态的方法。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@inject('Root')\nclass Index extends React.Component{}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"③observer"})}),"\n",(0,s.jsx)(n.p,{children:"被 observer 高阶组件包装的组件，如果组件内部引入了 mobx 可观察属性值，当值改变的时候，会追溯到当前组件，促使当前组件更新。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@observer\nclass Index extends  React.Component{}\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面介绍了一遍 mobx 和 mobx-react 的各个部分功能，接下来针对两种使用场景进行实践。"}),"\n",(0,s.jsxs)(n.h3,{id:"2-实践实现状态共享",children:["2 实践——实现状态共享",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-实践实现状态共享",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来用 mobx 实现状态共享场景。首先创建 Root 模块，用于保存全局的一些数据。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { observable ,action ,makeObservable } from 'mobx'\nclass Root{\n   constructor(){\n      makeObservable(this)\n   }\n   @observable info={ name:'xxx', mes:'xxx' }\n   // @observable number = 1\n   @action setInfo(info){  this.info = info }\n}\nexport default new Root()\n"})}),"\n",(0,s.jsx)(n.p,{children:"根本组件注入状态："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import Root from './mobx'\nexport default function Index(){\n    return <Provider Root={Root} >\n        <Child />\n    </Provider>\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"全局通过 mobx-react 中的 Provider 传递内容。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"使用状态："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const getUserInfo = () => {\n   return new Promise((resolve=>{\n            setTimeout(()=>{resolve({ name:'alien', mes:'let us learn React!'})\n       },1000)\n   }))\n}\n@inject('Root')\n@observer\nclass Child extends React.Component{\n    async componentDidMount(){\n       /*  模拟数据交互 */\n       const res = await getUserInfo()\n       this.props.Root.setInfo(res)\n    }\n    render(){\n        const { info } = this.props.Root\n        return <div className=\"box\" >\n            <p> 姓名：{info.name} </p>\n            <p> 想对大家说：{info.mes} </p>\n        </div>\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"inject 引入 Root，observer 做数据响应，模拟数据交互，调用 setInfo 改变 Root 中 info 内容。 info 内容改变，重新渲染视图。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-实践实现组件通信",children:["3 实践——实现组件通信",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-实践实现组件通信",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来模拟组件通信场景：首先注册模块用于组件通信。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Communi {\n   constructor(){\n       makeObservable(this)\n   }\n   @observable mesA = ''\n   @observable mesB = ''\n   @action setMesA(mes){ this.mesA = mes }\n   @action setMesB(mes){ this.mesB = mes }\n}\nexport default new Communi()\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后建立A，B组件实现通信功能："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@inject('Communi')\n@observer\nclass ComponentA extends React.Component{ /* 组件A */\n    state={ CompAsay:''}\n    render(){\n        const { CompAsay } = this.state\n        const { mesB  } = this.props.Communi\n        return <div className=\"box\" >\n        <p>我是组件A</p>\n        <div> B组件对我说：{mesB} </div>\n        我对B组件说： <input onChange={(e) => this.setState({ CompAsay :e.target.value })} placeholder=\"CompAsay\" />\n        <button onClick={() => this.props.Communi.setMesA(CompAsay)} >确定</button>\n      </div>\n    }\n}\n@inject('Communi')\n@observer\nclass ComponentB extends React.Component{ /* 组件B */\n   state={ compBsay:''}\n   render(){\n       const { compBsay } = this.state\n       const {  mesA  } = this.props.Communi\n       return <div className=\"box pt50\" >\n            <p>我是组件B</p>\n           <div> A组件对我说：{mesA} </div>\n           我对A组件说：<input onChange={(e) => this.setState({ compBsay :e.target.value })}  placeholder=\"CompAsay\" />\n           <button onClick={() => this.props.Communi.setMesB(compBsay)} >确定</button>\n       </div>\n   }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"1.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"四-mobx流程分析和原理揭秘",children:["四 Mobx流程分析和原理揭秘",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-mobx流程分析和原理揭秘",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来开始正式进入 Mobx 流程分析和原理揭秘环节。从本章节的第二部分，就开始介绍了 mobx 内部，可观察属性 ObserverValue 最后会被mobx 底层处理的样子。于是顺藤摸瓜，剖析 mobx 的整个流程。"}),"\n",(0,s.jsx)(n.p,{children:"可以从三个角度分析 mobx 和 mobx-react 整个流程："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"初始化"}),"：首先就是 mobx 在初始化的时候，是如何处理 observable 可观察属性的。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"依赖收集"}),"：第二点就是通过 mobx-react 中的 observer ，如何收集依赖项，与 observable 建立起关系的。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"派发更新"}),"：最后就是当改变可观察属性的值的时候，如何更新对应组件的。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["比如如下在 mobx 中的一个模块这么写道（这里称之为 ",(0,s.jsx)(n.strong,{children:"DEMO1"})," ）："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Root {\n    constructor(){ makeObservable(this) }\n    @observable authorInfo = {\n        name:'alien',\n        mes:{\n            say:'let us learn React!',\n        }\n    }\n    @observable name='《React进阶实践指南》'\n    @action setName(newName){ this.name = newName  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"以上面的 DEMO1 作为基础参考。"}),"\n",(0,s.jsxs)(n.h3,{id:"1-模块初始化",children:["1 模块初始化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-模块初始化",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先是模块初始化流程。可以从 ",(0,s.jsx)(n.code,{children:"makeObservable"})," 和 ",(0,s.jsx)(n.code,{children:"observable"})," 入手。"]}),"\n",(0,s.jsx)(n.p,{children:"首先被 observable 装饰器包裹的属性到底做了些什么呢？"}),"\n",(0,s.jsxs)(n.h4,{id:"绑定状态observable",children:["①绑定状态——observable",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#绑定状态observable",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/api/observable.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function createObservable(target,name,descriptor){ // 对于如上DEMO1，target——Root类，name——属性名称 authorInfo 或者 name ，descriptor——属性描述，枚举性，可读性等\n     if(isStringish(name)){ /* 装饰器模式下 */\n         target[Symbol(\"mobx-stored-annotations\")][name] = { /* 向类的mobx-stored-annotations属性的name属性上，绑定 annotationType_ ， extend_ 等方法。 */\n            annotationType_: 'observable',  //这个标签证明是 observable，除了observable，还有 action， computed 等。\n            options_: null,\n            make_,  // 这个方法在类组件 makeObservable 会被激活\n            extend_ // 这个方法在类组件 makeObservable 会被激活\n        }\n     }       \n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"被 observable 装饰器包装的属性，本质上就是调用createObservable 方法。"}),"\n",(0,s.jsxs)(n.li,{children:["通过 ",(0,s.jsx)(n.code,{children:"createObservable"})," 将类上绑定当前 observable 对应的配置项，说白了，就是给 observable 绑定的属性添加一些额外的状态，这些状态将在类实例化的时候 ",(0,s.jsx)(n.code,{children:"makeObservable"})," 中被激活。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这里有必要先记录一下 ",(0,s.jsx)(n.code,{children:"make_"})," 和 ",(0,s.jsx)(n.code,{children:"extend_"})," 方法，都做了些什么。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/types/createObservableAnnotation.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function make_(adm,key,descriptor){ /*  */\n    return this.extend_(adm,key,descriptor)\n}\nfunction extend_(adm,key,descriptor){\n    return adm.defineObservableProperty_(key,descriptor,options)\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["需要记住一点就是：当调用 observable 配置项的 make_ ，本质上调用 ",(0,s.jsx)(n.code,{children:"adm.defineObservableProperty_"})," ，至于这个是什么，马上就会讲到。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"激活状态makeobservable",children:["②激活状态——makeObservable",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#激活状态makeobservable",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上边讲到过，在新版本 mobx 中，必须在类的 constructor 中调用",(0,s.jsx)(n.code,{children:"makeObservable(this)"})," 才能建立响应式。一起看一下makeObservable。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function makeObservable (target){ // target 模块实例——this\n    const adm = new ObservableObjectAdministration(target) /* 创建一个管理者——这个管理者是最上层的管理者，管理模块下的observable属性 */\n    target[Symbol("mobx administration")] = adm  /* 将管理者 adm 和 class 实例建立起关联 */\n    startBatch()\n    try{\n        let annotations = target[Symbol("mobx-stored-annotations"] /* 上面第一步说到，获取状态 */\n        Reflect.ownKeys(annotations)  /* 得到每个状态名称 */\n        .forEach(key => adm.make_(key, annotations[key])) /* 对每个属性调用 */\n    }finally{\n        endBatch()\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"makeObservable 主要做的事有以下两点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["创建一个管理者 ",(0,s.jsx)(n.code,{children:"ObservableAdministration"})," ，上面讲到过，管理者就是为了管理子代属性的 ObservableValue 。并和模块实例建立起关系。"]}),"\n",(0,s.jsxs)(n.li,{children:["然后会遍历观察者状态下的每一个属性，将每个属性通过",(0,s.jsx)(n.code,{children:"adm.make_"}),"处理，值得注意的是，",(0,s.jsx)(n.strong,{children:"这个make_是管理者的，并不是属性状态的make_，这一点不要弄混淆了"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"接下来一起看一下，管理者 ObservableAdministration 里面是如何管理状态的。"}),"\n",(0,s.jsxs)(n.h4,{id:"观察者属性管理者observableadministration",children:["③观察者属性管理者——ObservableAdministration",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#观察者属性管理者observableadministration",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["细心的同学应该会发现，上述初始化创建的管理者，调用的是  ",(0,s.jsx)(n.code,{children:"ObservableObjectAdministration"})," ，实际在 mobx 内部会存在多个种类的管理者，比如数组，对象数据类型。因为不同的类型，里面的方法和状态都是不同的。本文是以对象的管理者作为参考。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/types/observableobject.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class ObservableObjectAdministration{\n    constructor(target_,values_){\n        this.target_ = target_\n        this.values_ = new Map() //存放每一个属性的ObserverValue。\n    }\n    /* 调用 ObserverValue的 get —— 收集依赖  */\n    getObservablePropValue_(key){ \n        return this.values_.get(key)!.get()\n    }\n    /* 调用 ObserverValue的 setNewValue_   */\n    setObservablePropValue_(key,newValue){\n        const observable = this.values_.get(key)\n        observable.setNewValue_(newValue) /* 设置新值 */\n    }\n    make_(key,annotation){ // annotation 为每个observable对应的配置项的内容，{ make_,extends }\n        const outcome = annotation.make_(this, key, descriptor, source)\n    }\n    /* 这个函数很重要，用于劫持对象上的get,set */\n    defineObservableProperty_(key,value){\n        try{\n            startBatch()\n            const descriptor = {\n                get(){      // 当我们引用对象下的属性，实际上触发的是 getObservablePropValue_\n                   this.getObservablePropValue_(key)\n                },\n                set(value){ // 当我们改变对象下的属性，实际上触发的是 setObservablePropValue_\n                   this.setObservablePropValue_(key,value)\n                }\n            }\n            Object.defineProperty(this.target_, key , descriptor)\n            const observable = new ObservableValue(value) // 创建一个 ObservableValue\n            this.values_.set(key, observable)             // 设置observable到value中\n        }finally{\n            endBatch()\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["回到主流程上来，当 mobx 底层遍历观察者属性，然后调用 make_ 方法的时候，本质上调用的是如上 make_ 方法，会激活当前的 observable 属性，触发 observable 配置项上的 make_ 方法，然后就会进入真正的添加观察者属性环节 ",(0,s.jsx)(n.code,{children:"defineObservableProperty_"})," 。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["首先会通过 ",(0,s.jsx)(n.strong,{children:"Object.defineProperty"})," ，拦截对象的属性，添加get，set ，比如组件中引用对象上的属性，调用 get ——本质上调用 ",(0,s.jsx)(n.code,{children:"getObservablePropValue_"})," ，在 observableValues 调用的是 get 方法；当修改对象上的属性，调用 set ——本质上调用  ",(0,s.jsx)(n.code,{children:"setObservablePropValue_"})," ，setObservablePropValue_ 调用的是 ObservableValues 上的 ",(0,s.jsx)(n.code,{children:"setNewValue_"})," 方法。"]}),"\n",(0,s.jsx)(n.li,{children:"对于每一个属性会增加一个观察者 ObservableValue ，然后把当前 ObservableValue 放入管理者 ObservableAdministration 的 values_ 属性上。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"到此为止，形成了如下的模型图结构："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"3.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-依赖收集",children:["2 依赖收集",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-依赖收集",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"如上详细介绍了初始化过程，接下来一起研究一下依赖收集流程。通过初始化过程，还遗留一点就是 ObservableValue 做了哪些事？"}),"\n",(0,s.jsxs)(n.h4,{id:"观察者observablevalue",children:["①观察者——ObservableValue",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#观察者observablevalue",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上面我知道了只要通过 @observable 包裹，就会创建一个 ObservableValue 。"}),"\n",(0,s.jsx)(n.p,{children:"在 Mobx 有一个核心的思想就是 Atom 主要是收集依赖，通知依赖。先来看一下 Atom 的重点方法:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/core/atom.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Atom{\n    observers_ = new Set() /* 存放每个组件的 */\n    /* value改变，通知更新 */\n    reportChanged() {\n        startBatch()\n        propagateChanged(this)\n        endBatch()\n    }\n    /* 收集依赖 */\n    reportObserved() {\n        return reportObserved(this)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"ObservableValue 继承了 Atom。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/types/observablevalue.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class ObservableValue extends Atom{\n    get(){ //adm.getObservablePropValue_ 被调用\n        this.reportObserved() // 调用Atom中 reportObserved\n        return this.dehanceValue(this.value_)\n    }\n    setNewValue_(newValue) { // adm.setObservablePropValue_\n        const oldValue = this.value_\n        this.value_ = newValue\n        this.reportChanged()  // 调用Atom中reportChanged\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["重点看一下在观察者属性管理者最终调用的两个方法—— ",(0,s.jsx)(n.code,{children:"get"})," 和 ",(0,s.jsx)(n.code,{children:"setNewValue_"})," 。"]}),"\n",(0,s.jsxs)(n.h4,{id:"注入模块provider和injectmobx-react",children:["②注入模块——Provider和inject（mobx-react）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#注入模块provider和injectmobx-react",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["既然观察者模块已经搞定，那么接下来看一下，",(0,s.jsx)(n.code,{children:"mobx-react"})," 如何将模块注入到对应的组件中的。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Provider"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx-react/src/Provider.tsx"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const MobXProviderContext = React.createContext({})\nexport function Provider(props) {\n    /* ... */\n    return <MobXProviderContext.Provider value={value}>{children}</MobXProviderContext.Provider>\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"mobx-react 中的 Provide r非常简单，就是创建一个上下文 context ，并通过 context.Provider 传递上下文。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"inject"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx-react/src/inject.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function inject(...storeNames){\n   const Injector = React.forwardRef(((props, ref)=>{\n        let newProps = { ...props }\n        const context = React.useContext(MobXProviderContext)\n        storeNames.forEach(function(storeName){ //storeNames - [ 'Root' ]\n            if(storeName in newProps) return \n            if(!(storeName in context)){\n                /* 将mobx状态从context中混入到props中。 */\n                newProps[storeName] = context[storeName]\n            }\n        })\n        return React.createElement(component, newProps)\n   }))\n   return Injector \n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"为了让大家更清晰流程，inject 是合并加上简化后的。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"inject 作用很简单，就是将 mobx 的状态，从 context 中混入 props 中。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"可观察组件-observer-mobx-react-",children:["③可观察组件—— observer（ mobx-react ）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#可观察组件-observer-mobx-react-",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["被 observe 的组件，被赋予一项功能，就是可观察的，当里面引用了 mobx 中的 ObservableValue ，当 ObservableValue 改变，组件会更新。\n接下来就是核心了，需要看一下被 observe 包裹的组件会",(0,s.jsx)(n.strong,{children:"有哪些新特征"}),"，",(0,s.jsx)(n.strong,{children:"以及如何收集的依赖"}),"，",(0,s.jsx)(n.strong,{children:"又是如何更新的"}),"。被 observe 的组件分为函数组件和类组件两种情况，为了让大家明白流程，我这里只讲了类组件的情况。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"observer"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx-react/src/observer.tsx"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function observer(componentClass){\n    /* componentClass 是类组件的情况 (函数组件我们暂且忽略) */\n    return function makeClassComponentObserver(){\n        const target = componentClass.prototype\n        const baseRender = target.render /* 这个是原来组件的render */\n        /* 劫持render函数 */\n        target.render = function () {\n            return makeComponentReactive.call(this, baseRender)\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["到这里基本可以弄清楚 mobx-react 中 observer HOC 的作用了——",(0,s.jsx)(n.strong,{children:"渲染 render 的劫持"}),"。通过劫持 render 函数执行，收集里面的依赖。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"makeComponentReactive"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx-react/src/observerClass.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function makeComponentReactive(){\n    const baseRender = render.bind(this) // baseRender为真正的render方法\n     /* 创建一个反应器，绑定类组件的更新函数 —— forceUpdate  */\n     const reaction = new Reaction(`${initialName}.render()`,()=>{\n          Component.prototype.forceUpdate.call(this) /* forceUpdate 为类组件更新函数 */\n     })\n    reaction["reactComponent"] = this    /* Reaction 和 组件实例建立起关联 */\n    reactiveRender["$mobx"] = reaction\n    this.render = reactiveRender \n    function reactiveRender() { /* 改造的响应式render方法 */\n        reaction.track(() => {  // track中进行真正的依赖收集\n            try {\n                rendering = baseRender() /* 执行更新函数 */\n            } \n        })\n        return rendering\n    }\n    return reactiveRender.call(this)\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"makeComponentReactive"})," 通过改造 render 函数，来实现依赖的收集，里面包含了很多核心流程。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["每一个组件会创建一个 Reaction，Reaction 的第二个参数内部封装了更新组件的方法。那么如果触发可观察属性的 set ，那么最后触发更新的就是这个方法，对于类组件本质上就是的 ",(0,s.jsx)(n.code,{children:"forceUpdate"})," 方法。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"对 render 函数进行改造，改造成 reactiveRender ，在 reactiveRender 中，reaction.track 是真正的进行依赖的收集，track 回调函数中，执行真正的 render 方法，得到 element 对象 rendering 。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"反应器reaction",children:["④反应器——Reaction",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#反应器reaction",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"那么接下来重点看一下 Reaction 如何处理更新函数，还有就是 track 方法是如何收集依赖的。在如下 track 中，我标记了三个阶段，阅读的同学请细心看这个三阶段都做了些什么。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/core/reaction.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:" class Reaction{\n    constructor(name_,onInvalidate_){\n       this.name_ = name_\n       this.onInvalidate_ = onInvalidate_ /* onInvalidate_ 里面有组件的forceUpdate函数，用于更新组件 */\n    }\n    onBecomeStale_(){\n        this.schedule_() /* 触发调度更新 */\n    }\n    /* 开启调度更新 */\n    schedule_(){\n       if (!this.isScheduled_) {\n            this.isScheduled_ = true\n            globalState.pendingReactions.push(this)\n            runReactions()\n        }\n    }\n    /* 更新 */\n    runReaction_(){\n        startBatch()\n        this.isScheduled_ = false\n        const prev = globalState.trackingContext\n        globalState.trackingContext = this\n        this.onInvalidate_() /* 更新组件  */\n        globalState.trackingContext = prev\n        endBatch()\n    }\n    /* 收集依赖 */\n    track(fn){\n        startBatch()\n        /* 第一阶段 */\n        const prevTracking = globalState.trackingDerivation\n        globalState.trackingDerivation = this\n        /* 第二阶段 */\n        const result = fn.call(context)\n        globalState.trackingDerivation = prevTracking\n        /* 第三阶段 */\n        bindDependencies(this) \n    }\n }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"这个函数特别重要，是整个收集依赖核心。"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["第一阶段： 首先在执行 track 的时候，会把全局变量的 ",(0,s.jsx)(n.code,{children:"trackingDerivation"}),"，指向当前的 trackingDerivation 。这样在收集依赖的过程中，可以直接收集当前的 trackingDerivation ，也就是为什么 ObservableValue 能精确收集每一个 Reaction 。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["第二阶段：首先当被 observer 包装的组件，只要执行 render 函数，就会执行 track 方法，",(0,s.jsx)(n.code,{children:"fn.call(context)"}),"，真正的r ender 函数会在里面执行，如果在 render 的过程中，引用了 mobx 可观察模块，比如："]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"@inject('Root')\nclass Index extends React.Component{\n    render(){\n        return <div> \n           <p>{ this.props.Root.name }</p> \n           <button onClick={() => this.props.Root.setName('《React进阶实践指南》666')} >改变Mobx中name</button>\n        </div>\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["第二阶段：当如上 render 执行的时候，首先会触发 track ，将当前Reaction 赋值给 trackingDerivation ，然后访问了 Root 下面的name 属性，那么首先会触发观察状态管理者的 adm 的 getObservablePropValue_ ，接下来会触发 name 属性的观察者 ObservableValue 下面的 get 方法，最后执行的是 ",(0,s.jsx)(n.code,{children:"reportObserved(this)"}),"，看一下 reportObserved 里面做了写什么？"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/core/observable.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function reportObserved(observable){\n    /* 此时获取到当前函数对应的 Reaction。 */\n    const derivation = globalState.trackingDerivation \n    /* 将当前的 observable 存放到 Reaction 的 newObserving_ 中。 */\n    derivation.newObserving_![derivation.unboundDepsCount_++] = observable \n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第二阶段：reportObserved 做的事情非常直接，就是将当前的 observable 放入 Reaction 的 newObserving_ 中，这样就把观察者属性（如上例子中的name）和组件对应的 Reaction 建立起关联。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["当组件中 render 函数执行完毕，也就是 jsx 中的依赖全部收集完成，就会到第三阶段，细心的同学发现，上述只是 ObservableValue 到 Reaction 收集，但是没有 Reaction 到 ObservableValue ，也就是说 ObservableValue 里面还没有组件的 Reaction，别着急，这个都是第三阶段的 ",(0,s.jsx)(n.code,{children:"bindDependencies"})," 做的事。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/core/derivation.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function bindDependencies(Reaction){ /* 当前组件的 Reaction */\n    const prevObserving = derivation.observing_ /* 之前的observing_ */\n    const observing = (derivation.observing_ = derivation.newObserving_!) /* 新的observing_  */\n    let l = prevObserving.length\n    while (l--) { /* observableValue 删除之前的 Reaction  */\n        const observableValue = prevObserving[l]\n        observable.observers_.delete(Reaction)\n    }\n    let i0 = observing.length \n    while (i0--) { /* 给renderhanobservableValue重新添加 Reaction  */\n        const observableValue = observing[i0]\n         observable.observers_.add(Reaction)\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第三阶段： bindDependencies 主要做的事情如下：\n①  对于有",(0,s.jsx)(n.strong,{children:"当前 Reaction"}),"的 observableValue，observableValue会统一删除掉里面的 Reaction。","\n②  会给这一次 render 中用到的新的依赖 observableValue ，统一添加当前的 Reaction 。","\n③  还会有一些细节，比如说在 render 中，引入两次相同的值（如上的 demo 中的 name ），会统一收集一次依赖。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"依赖收集流程图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"4.jpeg"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-派发更新",children:["3 派发更新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-派发更新",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来就是一次更新中，比如在（ DEMO1 ）中点击按钮，通过 action ，改变 mobx 中的 name 属性。那么会发生什么呢。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"第一步："})," 首先对于观察者属性管理者 ObservableAdministration 会触发 setObservablePropValue_ ，然后找到对应的 ObservableValue 触发 setNewValue_ 方法。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"第二步："})," setNewValue_ 本质上会触发Atom中的reportChanged ，然后调用 ",(0,s.jsx)(n.code,{children:"propagateChanged"}),"。首先来看一下propagateChanged："]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/core/observable.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function propagateChanged(observable){\n    observable.observers_.forEach((Reaction)=>{\n        Reaction.onBecomeStale_()\n    })\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["调用 ",(0,s.jsx)(n.code,{children:"propagateChanged"})," 触发，依赖于当前组件的所有 Reaction 会触发 onBecomeStale_ 方法。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"第三步："}),"  Reaction 的 onBecomeStale_ 触发，会让Reaction 的 schedule_ 执行，注意一下这里 schedule_ 会开启更新调度。什么叫更新调度呢。就是 schedule_ 并不会马上执行组件更新，而是把当前的 Reaction 放入 globalState.pendingReactions（待更新 Reaction 队列）中，然后会执行 runReactions 外部方法。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"mobx/src/core/reaction.ts"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function runReactions(){\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return\n    globalState.isRunningReactions = true\n    const allReactions = globalState.pendingReactions\n    /* 这里的代码是经过修改过后的，源码中要比 */\n    allReactions.forEach(Reaction=>{\n         /* 执行每一个组件的更新函数 */\n         Reaction.runReaction_()\n    })\n    globalState.pendingReactions = []\n    globalState.isRunningReactions = false\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"第四步："})," 执行每一个 Reaction ，当一个 ObservableValue 的属性值改变，可以收集了多个组件的依赖，所以 mobx 用这个调度机制，先把每一个 Reaction 放入 pendingReactions 中，然后集中处理这些 Reaction ， Reaction 会触发 ",(0,s.jsx)(n.code,{children:"runReaction_()"})," 方法，会触发 onInvalidate_ ——类组件的 forceupdate 方法完成组件更新。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"借此完成整个流程。"}),"\n",(0,s.jsx)(n.p,{children:"状态派发流程图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"5.jpeg"})}),"\n",(0,s.jsxs)(n.h2,{id:"五-mobx与redux区别",children:["五 Mobx与Redux区别",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-mobx与redux区别",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"首先在 Mobx 在上手程度上，要优于 Redux ，比如 Redux 想使用异步，需要配合中间价，流程比较复杂。"}),"\n",(0,s.jsx)(n.li,{children:"Redux 对于数据流向更规范化，Mobx 中数据更加多样化，允许数据冗余。"}),"\n",(0,s.jsx)(n.li,{children:"Redux 整体数据流向简单，Mobx 依赖于 Proxy， Object.defineProperty 等，劫持属性 get ，set ，数据变化多样性。"}),"\n",(0,s.jsx)(n.li,{children:"Redux 可拓展性比较强，可以通过中间件自定义增强 dispatch 。"}),"\n",(0,s.jsx)(n.li,{children:"在 Redux 中，基本有一个 store ，统一管理 store 下的状态，在 mobx 中可以有多个模块，可以理解每一个模块都是一个 store ，相互之间是独立的。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"六-总结",children:["六 总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#六-总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"希望通过本章节的学习，可以学到一下内容："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"mobx 基本使用，实践状态管理和组件通信两种场景。"}),"\n",(0,s.jsx)(n.li,{children:"mobx 和 mobx-react 原理。"}),"\n",(0,s.jsx)(n.li,{children:"mobx 和 redux 的区别。"}),"\n"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let b=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F24.%E7%94%9F%E6%80%81%E7%AF%87-React-mobx.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 Mobx特性",id:"二-mobx特性",depth:2},{text:"三 基本用法",id:"三-基本用法",depth:2},{text:"1 Mobx基本使用",id:"1-mobx基本使用",depth:3},{text:"mobx常用api",id:"mobx常用api",depth:4},{text:"mobx-react 常用 api",id:"mobx-react-常用-api",depth:4},{text:"2 实践——实现状态共享",id:"2-实践实现状态共享",depth:3},{text:"3 实践——实现组件通信",id:"3-实践实现组件通信",depth:3},{text:"四 Mobx流程分析和原理揭秘",id:"四-mobx流程分析和原理揭秘",depth:2},{text:"1 模块初始化",id:"1-模块初始化",depth:3},{text:"①绑定状态——observable",id:"绑定状态observable",depth:4},{text:"②激活状态——makeObservable",id:"激活状态makeobservable",depth:4},{text:"③观察者属性管理者——ObservableAdministration",id:"观察者属性管理者observableadministration",depth:4},{text:"2 依赖收集",id:"2-依赖收集",depth:3},{text:"①观察者——ObservableValue",id:"观察者observablevalue",depth:4},{text:"②注入模块——Provider和inject（mobx-react）",id:"注入模块provider和injectmobx-react",depth:4},{text:"③可观察组件—— observer（ mobx-react ）",id:"可观察组件-observer-mobx-react-",depth:4},{text:"④反应器——Reaction",id:"反应器reaction",depth:4},{text:"3 派发更新",id:"3-派发更新",depth:3},{text:"五 Mobx与Redux区别",id:"五-mobx与redux区别",depth:2},{text:"六 总结",id:"六-总结",depth:2}],title:"24.生态篇-React-mobx",headingTitle:"24.生态篇-React-mobx",frontmatter:{}}}}]);