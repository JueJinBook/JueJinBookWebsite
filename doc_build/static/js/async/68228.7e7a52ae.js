"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["68228"],{813828:function(e,n,s){s.r(n),s.d(n,{default:()=>R});var a=s(552676),r=s(740453);let c=s.p+"static/image/c2b6a04fbc091e9b52eb1cc0b18a8df8.3199c0b5.gif",x=s.p+"static/image/7d33e3a45e16834d2867d5519ffb92d2.100f2467.gif",i=s.p+"static/image/727888adfd8e290b3d551dc8d7dcc00d.4cceb1ce.gif",t=s.p+"static/image/1037550d72d0af73bc941f30f2650a03.4febed79.webp",l=s.p+"static/image/647fe2c2ea70f09fbc29a1847f40b202.ba59863a.webp",d=s.p+"static/image/4bb1b80da51dec27674e33c87895d7ee.f66ff88f.webp",p=s.p+"static/image/877dc0fe45f7d4f5af7b4fb9a3983097.2adbba5c.gif",o=s.p+"static/image/728a290e4dbc06e6dd90ae9a66480e49.7335ad8f.webp",h=s.p+"static/image/2f247722b0b9242a0e5b07ac64c0f0f3.19b3fd9c.gif",j=s.p+"static/image/895ecce501baec318ffc0f336417b85c.1b66cbfe.webp",f=s.p+"static/image/cf573a7d5605d9b04b86f92a412b9bac.2bd5847a.webp",b=s.p+"static/image/cd725b8b55c10f1d65f37cc8d33ca725.55b21ab1.webp",g=s.p+"static/image/31aec32f295ce3a559aa9f58403ae181.4739a4ab.webp",m=s.p+"static/image/b21e07009d4b325ed423c01fde820cda.7475f647.gif",u=s.p+"static/image/6a0f65fb18d369a6e1895ac8a58051ab.542d31a6.gif",y=s.p+"static/image/983503b1533f378f7d7416e9eab4b0b5.07f08cfc.webp",v=s.p+"static/image/0b9d10cc207b90ddf43e6088098be98a.49918725.webp",z=s.p+"static/image/e8242875dce9a1ecaf58250761c9d79c.f38517cc.webp";function L(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,r.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"第19章手写react-lazyload",children:["第19章—手写react-lazyload",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第19章手写react-lazyload",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"\uFEFF网页里可能会有很多图片，图片加载有一个过程，我们会在图片加载过程中展示占位图片。"}),"\n",(0,a.jsx)(n.p,{children:"并且我们不需要一开始就加载所有图片，而是希望在图片滚动到可视区域再加载。"}),"\n",(0,a.jsx)(n.p,{children:"这种效果我们会用 react-lazyload 来实现。"}),"\n",(0,a.jsx)(n.p,{children:"创建个项目："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"npx create-vite\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:z,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"进入项目，安装 react-lazyload"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"npm install\n\nnpm install --save react-lazyload\n\nnpm install --save-dev @types/react-lazyload\n\nnpm install --save prop-types\n"})}),"\n",(0,a.jsx)(n.p,{children:"prop-types 是 react-lazyload 用到的包。"}),"\n",(0,a.jsx)(n.p,{children:"去掉 index.css 和 StrictMode："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:v,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"然后改下 App.tsx"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import img1 from './img1.png';\nimport img2 from './img2.png';\nimport LazyLoad from 'react-lazyload';\n\nexport default function App() {\n  return (\n    <div>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <p>xxxxxx</p>\n      <LazyLoad placeholder={<div>loading...</div>}>\n        <img src={img1}/>\n      </LazyLoad>\n      <LazyLoad placeholder={<div>loading...</div>}>\n        <img src={img2}/>\n      </LazyLoad>\n    </div>\n  );\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"在超出一屏的位置加载两张图片，用 LazyLoad 包裹。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:y,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，最开始展示 placeholder 的内容。"}),"\n",(0,a.jsx)(n.p,{children:"当图片划入可视区域后，会替换成图片："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"在网络里也可以看到，当图片进入可视区域才会下载："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"这就是 react-lazyload 的作用。"}),"\n",(0,a.jsx)(n.p,{children:"当然，它能做的可不只是懒加载图片，组件也可以。"}),"\n",(0,a.jsx)(n.p,{children:"我们知道，用 lazy 包裹的组件可以异步加载。"}),"\n",(0,a.jsx)(n.p,{children:"我们写一个 Guang.tsx"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"export default function Guang() {\n    return '神说要有光';\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"然后在 App.tsx 里异步引入："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const LazyGuang = React.lazy(() => import('./Guang'));\n"})}),"\n",(0,a.jsx)(n.p,{children:"import() 包裹的模块会单独打包，然后 React.lazy 是用到这个组件的时候才去加载。"}),"\n",(0,a.jsx)(n.p,{children:"试下效果："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，确实是异步下载了这个组件并渲染出来。"}),"\n",(0,a.jsx)(n.p,{children:"那如果我们想组件进入可视区域再加载呢？"}),"\n",(0,a.jsxs)(n.p,{children:["这样：\n",(0,a.jsx)("img",{src:f,alt:""})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:j,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"react-lazyload 是进入可视区域才会把内容替换为 LazyGuang，而这时候才会去下载组件对应的代码。"}),"\n",(0,a.jsx)(n.p,{children:"效果就是这样的："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，Guang.tsx 的组件代码，img2.png 的图片，都是进入可视区域才加载的。"}),"\n",(0,a.jsx)(n.p,{children:"你还可以设置 offset，也就是不用到可视区域，如果 offset 设置 200，那就是距离 200px 到可视区域就触发加载："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，现在 img2 还没到可视区域就加载了。"}),"\n",(0,a.jsx)(n.p,{children:"知道了 react-lazyload 怎么用，那它是怎么实现的呢？"}),"\n",(0,a.jsx)(n.p,{children:"用前两节讲过的 IntersectionObserver 就可以实现。"}),"\n",(0,a.jsx)(n.p,{children:"我们来写一下："}),"\n",(0,a.jsx)(n.p,{children:"src/MyLazyLoad.tsx"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import {\n    CSSProperties,\n    FC,\n    ReactNode,\n    useRef,\n    useState\n} from 'react';\n\ninterface MyLazyloadProps{\n    className?: string,\n    style?: CSSProperties,\n    placeholder?: ReactNode,\n    offset?: string | number,\n    width?: number | string,\n    height?: string | number,\n    onContentVisible?: () => void,\n    children: ReactNode,\n}\n\nconst MyLazyload: FC<MyLazyloadProps> = (props) => {\n\n    const {\n        className = '',\n        style,\n        offset = 0,\n        width,\n        onContentVisible,\n        placeholder,\n        height,\n        children\n    } = props;\n\n    const containerRef = useRef<HTMLDivElement>(null);\n    const [visible, setVisible] = useState(false);\n\n    const styles = { height, width, ...style };\n\n    return <div ref={containerRef} className={className} style={styles}>\n        {visible? children : placeholder}\n    </div>\n}\n\nexport default MyLazyload;\n"})}),"\n",(0,a.jsx)(n.p,{children:"先看下 props："}),"\n",(0,a.jsx)(n.p,{children:"className 和 style 是给外层 div 添加样式的。"}),"\n",(0,a.jsx)(n.p,{children:"placeholder 是占位的内容。"}),"\n",(0,a.jsx)(n.p,{children:"offset 是距离到可视区域多远就触发加载。"}),"\n",(0,a.jsx)(n.p,{children:"onContentVisible 是进入可视区域的回调。"}),"\n",(0,a.jsx)(n.p,{children:"然后用 useRef 保存外层 div 的引用。"}),"\n",(0,a.jsx)(n.p,{children:"用 useState 保存 visible 状态。"}),"\n",(0,a.jsx)(n.p,{children:"visible 的时候展示 children，否则展示 placeholder。"}),"\n",(0,a.jsx)(n.p,{children:"然后补充下 IntersectionObserver 监听 div 进入可视区域的情况："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const elementObserver = useRef<IntersectionObserver>();\n\nuseEffect(() => {\n    const options = {\n        rootMargin: typeof offset === 'number' ? `${offset}px` : offset || '0px',\n        threshold: 0\n    };\n\n    elementObserver.current = new IntersectionObserver(lazyLoadHandler, options);\n\n    const node = containerRef.current;\n\n    if (node instanceof HTMLElement) {\n        elementObserver.current.observe(node);\n    }\n    return () => {\n        if (node && node instanceof HTMLElement) {\n            elementObserver.current?.unobserve(node);\n        }\n    }\n}, []);\n"})}),"\n",(0,a.jsx)(n.p,{children:"这里的 rootMargin 就是距离多少进入可视区域就触发，和参数的 offset 一个含义。"}),"\n",(0,a.jsx)(n.p,{children:"threshold 是元素进入可视区域多少比例的时候触发，0 就是刚进入可视区域就触发。"}),"\n",(0,a.jsx)(n.p,{children:"然后用 IntersectionObserver 监听 div。"}),"\n",(0,a.jsx)(n.p,{children:"之后定义下 lazyloadHandler："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function lazyLoadHandler (entries: IntersectionObserverEntry[]) {\n    const [entry] = entries;\n    const { isIntersecting } = entry;\n\n    if (isIntersecting) {\n        setVisible(true);\n        onContentVisible?.();\n\n        const node = containerRef.current;\n        if (node && node instanceof HTMLElement) {\n            elementObserver.current?.unobserve(node);\n        }\n    }\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"当 isIntersecting 为 true 的时候，就是从不相交到相交，反之，是从相交到不相交。"}),"\n",(0,a.jsx)(n.p,{children:"这里设置 visible 为 true，回调 onContentVisible，然后去掉监听。"}),"\n",(0,a.jsx)(n.p,{children:"测试下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，首先是图片加载，然后是组件加载，这说明 offset 生效了："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"这样，我们就实现了 react-lazyload。"}),"\n",(0,a.jsxs)(n.p,{children:["案例代码上传了",(0,a.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/react-lazyload-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"当图片进入可视区域才加载的时候，可以用 react-lazyload。"}),"\n",(0,a.jsx)(n.p,{children:"它支持设置 placeholder 占位内容，设置 offset 距离多少距离进入可视区域触发加载。"}),"\n",(0,a.jsx)(n.p,{children:"此外，它也可以用来实现组件进入可视区域时再加载，配合 React.lazy + import() 即可。"}),"\n",(0,a.jsx)(n.p,{children:"它的实现原理就是 IntersectionObserver，我们自己实现了一遍，设置 rootMargin 也就是 offset，设置 threshold 为 0 也就是一进入可视区域就触发。"}),"\n",(0,a.jsx)(n.p,{children:"图片、组件的懒加载（进入可视区域再触发加载）是非常常见的需求，不但要会用 react-lazyload 实现这种需求，也要能够自己实现。"})]})}function E(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(L,{...e})}):L(e)}let R=E;E.__RSPRESS_PAGE_META={},E.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC19%E7%AB%A0%E2%80%94%E6%89%8B%E5%86%99react-lazyload.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第19章—手写react-lazyload",headingTitle:"第19章—手写react-lazyload",frontmatter:{}}}}]);