"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16028"],{905437:function(n,e,s){s.r(e),s.d(e,{default:()=>a});var r=s(552676),d=s(740453);let i=s.p+"static/image/87ab0c2fbac9dea90f8264abaf6d3062.1c8c39d5.webp",c=s.p+"static/image/246757d4e9adf134f5ea194be9821df1.24a04444.webp";function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",blockquote:"blockquote",h2:"h2",img:"img",pre:"pre",code:"code",ul:"ul",li:"li",h3:"h3"},(0,d.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"5架构通用-schema-设计",children:["5.架构：通用 Schema 设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5架构通用-schema-设计",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["作为前端开发一定会非常熟悉 ",(0,r.jsx)(e.strong,{children:"AST"})," 抽象语法树（",(0,r.jsx)(e.strong,{children:"Abstract Syntax Tree"}),"），当浏览器加载 ",(0,r.jsx)(e.strong,{children:"JS"})," 代码时，它会首先将代码转换为一棵抽象语法树（",(0,r.jsx)(e.strong,{children:"AST"}),"），然后再根据 ",(0,r.jsx)(e.strong,{children:"AST"})," 来渲染对应的 ",(0,r.jsx)(e.strong,{children:"DOM"})," 结构，对于一款低代码产品来说，如果能直接去解析 ",(0,r.jsx)(e.strong,{children:"AST"})," 肯定是最方便但这也是麻烦的，因为 ",(0,r.jsx)(e.strong,{children:"AST"})," 包含的内容非常多，所以大部分的低代码产品都会使用自定义的 ",(0,r.jsx)(e.strong,{children:"Schema"})," 来描述搭建的内容。"]}),"\n",(0,r.jsxs)(e.p,{children:["但也由于 ",(0,r.jsx)(e.strong,{children:"Schema"})," 只是一种通用的协议，并没有非常好的规范与最佳实践，现阶段都是属于各自为战的边界探索阶段，所以各个低代码平台中的 ",(0,r.jsx)(e.strong,{children:"Schema"})," 的规范并不相同。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"其实就算不是探索阶段，大多数平台的低代码产品肯定也很难做到统一，除了开发者的习惯也会涉及到用户习惯以及行业差异、产品定位等，此外商业产品为了盈利会主动营造技术壁垒、增加用户粘性、培养用户习惯以及迁移成本。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["但当我们想把这个产品升级为 ",(0,r.jsx)(e.strong,{children:"Pro Code"})," 或者想再添加更多交互功能的时候，是不是等同于又重新创建了一个新 ",(0,r.jsx)(e.strong,{children:"DSL"}),"，这也是我个人感觉低代码一个非常尴尬的点"]}),"\n",(0,r.jsxs)(e.p,{children:["当然在产品的初期由于时间与资源有限，肯定不会最开始就设计 ",(0,r.jsx)(e.strong,{children:"DSL"})," 解析，所以接下来我们将围绕 ",(0,r.jsx)(e.strong,{children:"Schema"})," 来逐步分析从",(0,r.jsx)(e.strong,{children:"设计"}),"到",(0,r.jsx)(e.strong,{children:"落地"}),"以及",(0,r.jsx)(e.strong,{children:"扩展"}),"的全过程。"]}),"\n",(0,r.jsxs)(e.h2,{id:"什么是-schema-协议",children:["什么是 Schema 协议",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是-schema-协议",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Schema"})," 本质上就是一个 ",(0,r.jsx)(e.strong,{children:"JSON"})," 格式的定义块，通过抽象属性定义来表达页面和组件的布局、属性配置、依赖关系、表达式解析，如果在偏向业务也有页面路由、多语种、数据源、权限等等各种各样的抽象声明。\n因此，我们也将刚刚提到的内容统称为 ",(0,r.jsx)(e.strong,{children:"Schema 协议"}),"，它也属于元数据结构模型的范畴。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["如果想要进行更多的了解，可以 ",(0,r.jsx)(e.strong,{children:"Google"})," 看看",(0,r.jsx)(e.strong,{children:"元数据"}),"的相关内容。或者入群探讨，小册里就不再过多展开。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"什么是协议渲染",children:["什么是协议渲染",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是协议渲染",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["当了解了 ",(0,r.jsx)(e.strong,{children:"Schema"})," 的基本概念后，接下来就需要具体来实施和设计相关 ",(0,r.jsx)(e.strong,{children:"Schema 协议"}),"的实现了。"]}),"\n",(0,r.jsx)(e.p,{children:"在正式开始设计协议之前，我们一起先来看下面的例子，一起来了解下协议渲染究竟是什么东西？"}),"\n",(0,r.jsxs)(e.p,{children:["相信很多朋友为了提高效率或多或少都封装过一些通用型的组件，比如通过 ",(0,r.jsx)(e.strong,{children:"JSON"})," 配置来实现一组表单布局，如下图，是一个简单的表单区块："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"前端实现的代码如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:'<Form>\n  <Form.Item\n    label="用户名"\n    name="username"\n    >\n    <Input />\n  </Form.Item>\n\n  <Form.Item\n    label="性别"\n    name="sex"\n    >\n    <Select />\n  </Form.Item>\n\n  <Form.Item wrapperCol={{ offset: 8, span: 16 }}>\n    <Button htmlType="reset">\n      重置\n    </Button>\n    <Button type="primary" htmlType="submit">\n      提交\n    </Button>\n  </Form.Item>\n</Form>\n'})}),"\n",(0,r.jsx)(e.p,{children:"可以看出，这其中大部分的代码都是冗余，特别是对于中台场景或者问答场景中会频繁大量的出现，所以社区早期就出现了配置式的解法，根据相对应的配置规则，我们可以将其抽象为以下代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"import { Form } from 'antd'\nimport { FormRender, FormRenderProps } from '@you-team/form-render'\n\nconst config: FormRenderProps['config'] = [\n  // username form.item config.\n  {\n    label: '用户名',\n    name: 'username',\n    renderType: 'Input',\n  },\n  // sex form.item config.\n  {\n    label: '性别',\n    name: 'sex',\n    renderType: 'Select',\n  }\n]\n\n<FormRender \n  as={Form} \n  config={config} \n  onFinish={data => console.log('FormData', data)} \n/>\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上述方式就是一个简单表单类型的 ",(0,r.jsx)(e.strong,{children:"Schema"})," 设计，借助封装好的 ",(0,r.jsx)(e.strong,{children:"FormRender"})," 组件来递归约定好的表单 ",(0,r.jsx)(e.strong,{children:"Schema"})," 协议快速进行页面表单内容的渲染。"]}),"\n",(0,r.jsx)(e.p,{children:"此类方案是协议约定式渲染的方案之一，在低代码平台中，通常也是使用相同的方式来实现的，只不过会更加的通用，复杂程度也会更高。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["目前而言，社区存在很多类似的实现解法，大部分都是 ",(0,r.jsx)(e.strong,{children:"UI(config)"})," 的思想。如果感兴趣可以搜索下对应的文章学习与了解。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"设计与实现",children:["设计与实现",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#设计与实现",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["上述的例子非常简单也是大家常用的组件封装方式，接下来就是我们这个低代码产品的 ",(0,r.jsx)(e.strong,{children:"Schema 协议"})," 的设计与实现了，首先来说下整个协议的主体采取 ",(0,r.jsx)(e.strong,{children:"JSON"})," 方式的原因："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"方便存储，可以存储到服务端中形成记录；"}),"\n",(0,r.jsx)(e.li,{children:"方便操作，跨平台解析；"}),"\n",(0,r.jsx)(e.li,{children:"结构简单，通俗易懂，方便开发者查阅。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["如下图所示，",(0,r.jsx)(e.strong,{children:"Schema 协议"}),"第一个版本先预留了如下几个领域区块，分别是",(0,r.jsx)(e.strong,{children:"依赖管理"}),"、",(0,r.jsx)(e.strong,{children:"国际化(多语种)"}),"、",(0,r.jsx)(e.strong,{children:"状态管理"}),"、",(0,r.jsx)(e.strong,{children:"数据源"}),"、",(0,r.jsx)(e.strong,{children:"生命周期"}),"以及",(0,r.jsx)(e.strong,{children:"页面结构"}),"等耳熟能详的结构定义。"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(e.h3,{id:"协议版本version",children:["协议版本(version)",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#协议版本version",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["代表着当前协议的版本，用于后续协议 ",(0,r.jsx)(e.strong,{children:"break change"})," 带来的兼容问题，可以通过版本来区分渲染器和解析器。而版本的升降级也是有规范可循的，如社区中比较常见的像",(0,r.jsx)(e.a,{href:"https://semver.org/",target:"_blank",rel:"noopener noreferrer",children:"semver"}),"，大体上的规则如下："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"major"}),": 如果包含 ",(0,r.jsx)(e.strong,{children:"Break Change"}),"(破坏更新)的内容;"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"minor"}),": 当你产出了一个新的功能的时候（无破坏更新）;"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"patch"}),": 当你修复了一个 ",(0,r.jsx)(e.strong,{children:"BUG"})," 问题的时候（无破坏更新）。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"依赖管理library",children:["依赖管理(library)",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖管理library",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["代表当前协议在编辑器中依赖的一些类库和包，为后续异步加载资源和动态引入留坑位。在内部声明出依赖的名称、加载的资源地址(如组件库会导出 ",(0,r.jsx)(e.code,{children:"index.js"})," 和 ",(0,r.jsx)(e.code,{children:"index.css"})," 多个资源)，类库的声明名称等等。那么可以分析得出如下依赖的大体结构："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"const librarys: SchemaModelConfig['librarys'] = [\n  {\n    name: 'dayjs',\n    urls: [\n      'https://unpkg.com/dayjs@1.11.7/dayjs.min.js'\n    ],\n    globalVar: 'dayjs'\n  },\n  {\n    name: 'arco',\n    urls: [\n      'https://unpkg.com/@arco-design/web-react@2.46.3/dist/arco.min.js',\n      'https://unpkg.com/@arco-design/web-react@latest/dist/arco-icon.min.js',\n      'https://unpkg.com/@arco-design/web-react@2.46.3/dist/css/arco.css',\n    ],\n    globalVar: 'Arco'\n  }\n]\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"国际化i18n",children:["国际化(i18n)",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#国际化i18n",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["管理当前协议生成页面的 ",(0,r.jsx)(e.strong,{children:"react-i18n-next"})," 相关的键对值，用于维护国际化项目时需要进行多语种的文案切换带来的业务诉求。参考业内成熟 ",(0,r.jsx)(e.strong,{children:"i18n"})," 的方案，多语种的协议字段就相对而言比较简单："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"\n  const i18n: SchemaModelConfig['i18n'] = {\n    zh: {},\n    eu: {},\n    ...后续补充需要支持的多语种\n  },\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"状态管理store",children:["状态管理(store)",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#状态管理store",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["维护一份页面上的状态。方便后续做绑定通信和事件广播的实现，用于赋予整个页面的组件联动交互，",(0,r.jsx)(e.strong,{children:"最常见的就是点击相关按钮唤起相关弹窗类型组件"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["当低代码产物为工程类型时，那么就会涉及到",(0,r.jsx)(e.strong,{children:"跨模块"}),"、",(0,r.jsx)(e.strong,{children:"跨页面"}),"这种全局状态管理，当然随之而来的是这块的配置会更加复杂，包括 ",(0,r.jsx)(e.strong,{children:"Schema"})," 的设计与配置的形式。"]}),"\n",(0,r.jsxs)(e.h3,{id:"数据源datasource",children:["数据源(dataSource)",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据源datasource",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在大多数业务场景当中，页面的元素结构渲染并不是根据静态数据来渲染的，而是通过获取相关接口中的远程数据来展示。所以数据源与远端挂钩，可以是远程的 ",(0,r.jsx)(e.strong,{children:"JSON"})," 文件，也可以是一个 ",(0,r.jsx)(e.strong,{children:"fetch"})," 请求，主要的目的是为了帮助页面组件支持动态渲染数据的能力。"]}),"\n",(0,r.jsxs)(e.p,{children:["一个请求包含以下几个重要的内容，",(0,r.jsx)(e.strong,{children:"请求资源 URI"}),"、",(0,r.jsx)(e.strong,{children:"Request"}),"、",(0,r.jsx)(e.strong,{children:"Header"}),"、",(0,r.jsx)(e.strong,{children:"Response"})," => ",(0,r.jsx)(e.code,{children:"params | query | body"})," ，所以在定义数据源的时候，我们将其抽象成如下结构："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"const i18n: SchemaModelConfig['dataSource'] = [\n  {\n    key: 'string|uuid',\n    name: 'getUserList',\n    request: {\n      url: 'https://localhost:3000/user/list',\n      params: {\n        pageSize: 10,\n        current: 1,\n      },\n      method: 'GET',\n      body: {},\n      header: {}\n      ...AxiosInstanceConfig\n    }\n  }\n]\n\n// 最终会抽象成一个函数调用来动态的执行。\nlowcodeSandBox?.loadDataSource('getUserList', ...其他参数): Promise<any>\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"生命周期lifecycles",children:["生命周期(lifeCycles)",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#生命周期lifecycles",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["一个项目的使用中有",(0,r.jsx)(e.strong,{children:"初始化"}),"、",(0,r.jsx)(e.strong,{children:"使用中"}),"、",(0,r.jsx)(e.strong,{children:"销毁"}),"等多个不同的生命周期，每个状态需要做的事情也不同，",(0,r.jsx)(e.strong,{children:"比如在程序初始化时会加载或者配置后续使用中需要的数据、资源等"}),"，同理对于低代码平台应用而言，搭建页面时与传统项目一样，同样需要自定义一套生命周期来帮助更好管理产物的拉取、",(0,r.jsx)(e.strong,{children:"Dom"})," 渲染、数据更新等操作。"]}),"\n",(0,r.jsxs)(e.h3,{id:"页面结构htmlbody",children:["页面结构(htmlBody)",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#页面结构htmlbody",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["与 ",(0,r.jsx)(e.strong,{children:"虚拟 DOM"})," 相似，本质上是对于当前页面渲染的抽象结构，便于跨平台之间的转换，为后续运行时渲染和动态出码垫定基础，提供后续结构化转换的能力。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们先来看一下 ",(0,r.jsx)(e.strong,{children:"React"})," 组件的",(0,r.jsx)(e.code,{children:"createElement"}),"方法的构成："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"React.createElement(type, props, children);\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"type"}),": 可以是",(0,r.jsx)(e.strong,{children:"原生标签"}),"，也可以是 ",(0,r.jsx)(e.strong,{children:"函数组件"})," 和 ",(0,r.jsx)(e.strong,{children:"Class 组件"})," 等;"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"props"}),"：组件元素需要的属性;"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"chidren"}),"：组件内容;"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["熟悉 ",(0,r.jsx)(e.strong,{children:"React"})," 的同学都知道，在编译时我们所写的 ",(0,r.jsx)(e.strong,{children:"JSX|TSX"})," 会被编辑成 ",(0,r.jsx)(e.code,{children:"React.createElement"})," 执行函数，而我们抽象出来的 ",(0,r.jsx)(e.strong,{children:"Schema"})," 结构也是做类似的事情。"]}),"\n",(0,r.jsxs)(e.p,{children:["如下代码所示，就是一个对页面的抽象设计，其中主要包含的内容就是",(0,r.jsx)(e.strong,{children:"渲染的组件名称"}),"、",(0,r.jsx)(e.strong,{children:"Props"}),"、",(0,r.jsx)(e.strong,{children:"子组件"}),"等等信息。"]}),"\n",(0,r.jsx)(e.p,{children:"至于属性具体有什么作用，在后续相关的实战章节会着重的分析，在这里只要先了解页面结构的基本画像即可。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-json",children:'{\n  "ROOT": {\n    "type": {\n      "resolvedName": "Container"\n    },\n    "props": {\n      "width": 800,\n      "height": "100%",\n      "paddingTop": 20,\n      "paddingBottom": 20,\n      "paddingLeft": 20,\n      "paddingRight": 20,\n      "background": "#FFFFFF"\n    },\n    "displayName": "基础容器",\n    "custom": {},\n    "hidden": false,\n    "nodes": [\n      "rpVYvatknx"\n    ],\n    "linkedNodes": {}\n  },\n  "rpVYvatknx": {\n    "type": {\n      "resolvedName": "Text"\n    },\n    "props": {},\n    "displayName": "文本",\n    "custom": {},\n    "parent": "ROOT",\n    "hidden": false,\n    "nodes": [],\n    "linkedNodes": {}\n  }\n}\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"最后",children:["最后",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"以上就是根据思维导图中初步拟定的协议草稿的字段定义解释。"}),"\n",(0,r.jsxs)(e.p,{children:["在有了明确的定义结构后，我们就可以写出一个简单的",(0,r.jsx)(e.code,{children:"Schema"}),"的数据结构，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:'const schema = JSON.stringify({\n  version: 1.0.0,\n  librarys: [],\n  i18n: {\n    zh: {},\n    eu: {},\n  },\n  store: {},\n  dataSource: {},\n  lifeCycles: {},\n  htmlBody: {\n  "ROOT": {\n    "type": {\n      "resolvedName": "Container"\n    },\n    "props": {\n      "width": 800,\n      "height": "100%",\n      "paddingTop": 20,\n      "paddingBottom": 20,\n      "paddingLeft": 20,\n      "paddingRight": 20,\n      "background": "#FFFFFF"\n    },\n    "displayName": "基础容器",\n    "custom": {},\n    "hidden": false,\n    "nodes": [\n      "rpVYvatknx"\n    ],\n    "linkedNodes": {}\n  },\n  "rpVYvatknx": {\n    "type": {\n      "resolvedName": "Text"\n    },\n    "props": {},\n    "displayName": "文本",\n    "custom": {},\n    "parent": "ROOT",\n    "hidden": false,\n    "nodes": [],\n    "linkedNodes": {}\n  }\n}\n})\n'})}),"\n",(0,r.jsxs)(e.p,{children:["这里需要注意的是，你的协议一定要遵守 ",(0,r.jsx)(e.strong,{children:"JSON"})," 数据格式的约束，否则会导致解析时出现问题，为了避免开发中出现解析 ",(0,r.jsx)(e.strong,{children:"Schema"})," 产生不可预期的错误，可以使用第三方推荐的 ",(0,r.jsx)(e.strong,{children:"JSON Schema"})," 库来检验 ",(0,r.jsx)(e.strong,{children:"Schema"})," 是否符合规范："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://github.com/networknt/json-schema-validator",title:"networknt/json-schema-validator",target:"_blank",rel:"noopener noreferrer",children:"json-schema-validator"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://github.com/everit-org/json-schema",title:"everit-org/json-schema",target:"_blank",rel:"noopener noreferrer",children:"json-schema"})}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["作为低代码编辑器的通用能力之一，",(0,r.jsx)(e.strong,{children:"Schema 协议"}),"在设计到使用中起着至关重要的",(0,r.jsx)(e.strong,{children:"转换器"}),"作用，使得不同的编辑器和工具之间可以共享和使用相同的数据结构，方便地将数据在不同的应用程序和系统之间进行转换和交换，从而实现更高效、更可靠的工作流程。"]}),"\n",(0,r.jsx)(e.p,{children:"目前初版协议起草其实已经能够面对绝大部分的问题了，在后续实战中涉及更加复杂的功能需要依赖协议的话，则可以在此基础上继续延伸做扩展。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"此章节的内容会随着项目的更新进度不断优化"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"写在最后",children:["写在最后",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#写在最后",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"如果你有什么疑问或者更好的建议，欢迎在评论区提出或者加群沟通。 \uD83D\uDC4F"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(h,{...n})}):h(n)}let a=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F5.%E6%9E%B6%E6%9E%84%EF%BC%9A%E9%80%9A%E7%94%A8%20Schema%20%E8%AE%BE%E8%AE%A1.md"]={toc:[{text:"什么是 Schema 协议",id:"什么是-schema-协议",depth:2},{text:"什么是协议渲染",id:"什么是协议渲染",depth:2},{text:"设计与实现",id:"设计与实现",depth:2},{text:"协议版本(version)",id:"协议版本version",depth:3},{text:"依赖管理(library)",id:"依赖管理library",depth:3},{text:"国际化(i18n)",id:"国际化i18n",depth:3},{text:"状态管理(store)",id:"状态管理store",depth:3},{text:"数据源(dataSource)",id:"数据源datasource",depth:3},{text:"生命周期(lifeCycles)",id:"生命周期lifecycles",depth:3},{text:"页面结构(htmlBody)",id:"页面结构htmlbody",depth:3},{text:"最后",id:"最后",depth:3},{text:"总结",id:"总结",depth:2},{text:"写在最后",id:"写在最后",depth:2}],title:"5.架构：通用 Schema 设计",headingTitle:"5.架构：通用 Schema 设计",frontmatter:{}}}}]);