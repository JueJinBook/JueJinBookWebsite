"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["69869"],{419842:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var s=r(552676),t=r(740453);let a=r.p+"static/image/aa282d0b99d10083fdf5d291bdba7e1d.ffc292f3.webp",l=r.p+"static/image/c08c211d022be5c34107973bf0b071eb.00d3a4ad.webp",i=r.p+"static/image/e12788ebb37d2ea9bb6d35882b40f692.e51c8f73.webp",o=r.p+"static/image/b8601d6f84874f6e69dd181d8bc0c649.3bb6a4f2.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",code:"code",pre:"pre",img:"img",blockquote:"blockquote",h3:"h3",br:"br",h5:"h5",ol:"ol"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"25-实战15基于koajs实现restful-api",children:["25 实战15：基于Koa.js实现Restful Api",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-实战15基于koajs实现restful-api",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这章内容内容包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Koa.js 框架快速入门"}),"\n",(0,s.jsx)(n.li,{children:"Koa 极简实现"}),"\n",(0,s.jsx)(n.li,{children:"常用 Koa 中间件"}),"\n",(0,s.jsx)(n.li,{children:"认识 Restful Api"}),"\n",(0,s.jsx)(n.li,{children:"实现简单的 Restful API"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"koajs-框架快速入门",children:["Koa.js 框架快速入门",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#koajs-框架快速入门",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Koa 是一个 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async/await 函数，摆脱回调地狱，并有力地增强错误处理。Koa 并没有捆绑任何中间件，而是提供了一套优雅的中间件方法，让你自由的按需加载，这种作法褒贬不一，各大厂都会根据团队需求来封装自己 node 框架，衍生出的比较有名的有 Egg.js、nest.js、thinkjs 和 hapi，有兴趣的可以自行搜索相关资料。"}),"\n",(0,s.jsxs)(n.p,{children:["Koa 应用程序是一个包含一组中间件函数的对象，它是按照类似堆栈的方式组织和执行的。 Koa 类似于其他中间件系统，然而，一个关键的设计点是在其低级中间件层中提供高级",(0,s.jsx)(n.code,{children:"语法糖"}),"。 尽管提供了相当多的有用的方法 Koa 仍保持了一个很小的体积，因为没有捆绑中间件。"]}),"\n",(0,s.jsx)(n.p,{children:"还是那个 Hello Uniapp 应用:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const Koa = require('koa');\nconst app = new Koa();\n\napp.use(async ctx => {\n  ctx.body = 'Hello Uniapp';\n});\n\napp.listen(3000);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Koa 中间件以更传统的方式级联，使用 async 功能，我们可以实现 “真实” 的中间件。"}),"\n",(0,s.jsx)(n.p,{children:"Koa 中间件包含两个参数 ctx 和 next。参数 next 是一个函数，它的作用是将处理控制权交给下一中间件。Koa 中间件采用级联代码方式执行。其中间件参数 next 的级联执行逻辑如图所示。"}),"\n",(0,s.jsx)(n.p,{children:"Koa 中间件执行顺序原理图"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"执行流程，事件从最外层逐层触发，每层都会一进一出穿过两次，且最先穿入的一层最后穿出，到达最后一层最后冒泡返回。好比水分进出洋葱一样，洋葱的每层相当于中间件，水分输入相当于请求，水分输出相当于相应。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["下面以",(0,s.jsx)(n.code,{children:"欢迎订阅，Uniapp从入门到进阶"}),"的响应作为示例，请求开始进入中间件1，打印",(0,s.jsx)(n.code,{children:"欢迎订阅，"}),"，当遇到第一个 next() 则该函数暂停并将控制传递给定义的下一个中间件2，打印",(0,s.jsx)(n.code,{children:"Uniapp"}),"，遇到第二个 next() 发现没有更多的中间件执行了，于是返回打印",(0,s.jsx)(n.code,{children:"从入门"}),"，再向上打印",(0,s.jsx)(n.code,{children:"到进阶"}),"，然后跳出中间往下执行其他代码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const Koa = require('koa');\nconst app = new Koa();\n// 中间件 1\napp.use(async (ctx, next) => {\n	console.log('欢迎订阅，')\n    await next();\n	console.log('到进阶')\n});\n// 中间件 2\napp.use(async (ctx, next) => {\n    ctx.body = 'Uniapp';\n	await next();\n	console.log('从入门')\n});\napp.listen(3000, () => {\n    console.log('server is running at http://localhost:3000')\n});\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"koa-极简实现",children:["Koa 极简实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#koa-极简实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"有的朋友可能之前已经了解过 Koa 的组成，网上也有很多的源码分析，我打算来简单的实现一个 mini 版本。麻雀虽小，但是核心依然是入口 Application 和 上下文 Context。"}),"\n",(0,s.jsx)(n.p,{children:"各模块的核心："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Application：",(0,s.jsx)(n.code,{children:"use()"}),"，",(0,s.jsx)(n.code,{children:"listen()"}),"，",(0,s.jsx)(n.code,{children:"callback()"}),"，",(0,s.jsx)(n.code,{children:"compose()"})]}),"\n",(0,s.jsxs)(n.li,{children:["Context：整合 ",(0,s.jsx)(n.code,{children:"req"}),"，",(0,s.jsx)(n.code,{children:"res"})," 到 ",(0,s.jsx)(n.code,{children:"ctx"})," 对象中"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"接下来实现入口 Application.js："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const http = require('http') // 利用 http 模块\nconst Context = require('./Context') // 导入 Context 模块\n\nmodule.exports = class Application {\n    constructor() {\n        this.middlewares = [] // 保存所有的中间件函数\n    }\n\n    // 构建ctx，传入到中间件集合，执行next递归\n    callback() {\n        return async(req, res) => {\n\n            // 初始化ctx\n            const ctx = new Context(req, res);\n\n            //调用 compose 函数，依次处理所有中间件函数\n            const fn = this.compose(this.middlewares);\n            await fn(ctx)\n            // 最后返回res body\n            this.responseBody(ctx)\n        }\n    }\n\n    // 简单粗暴处理res body\n    responseBody(ctx) {\n        const content = ctx.body;\n        ctx.res.end(content);\n        console.log(content)\n\n        // 可加入类型判断，error错误处理流程\n        // ...\n    }\n\n    // 核心：递归中间件，即所谓的 `next()` 方法，先执行第一个\n    compose(middlewares) {\n        return ctx => {\n            const useMiddleware = i => {\n                let fn = middlewares[i] //遍历中间件集合\n                if (!fn) {\n                    return\n                }\n                return fn(ctx, () => useMiddleware(i + 1)) //递归执行中间件方法，并且传到一下层\n            }\n            return useMiddleware(0)\n        }\n    }\n\n    // 挂载中间件\n    use(middleware) {\n        //打包中间件集合，middleware实则是个方法\n        this.middlewares.push(middleware)\n    }\n\n    // 启动服务器\n    listen(...args) {\n        const server = http.createServer(this.callback())\n        server.listen(...args)\n    }\n\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Context.js 暂且简单做个代理："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = class Context {\n    constructor(req, res) {\n        this.req = req\n        this.res = res\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"借用上小节的代码测试："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const MiniKoa = require('./Application.js');\nconst app = new MiniKoa();\n// 中间件 1\napp.use(async(ctx, next) => {\n    console.log('欢迎订阅，')\n    await next();\n    console.log('到进阶')\n    ctx.body = 'print to body';\n});\n// 中间件 2\napp.use(async(ctx, next) => {\n    console.log('Uniapp')\n    await next();\n    console.log('从入门')\n});\napp.listen(3000, () => {\n    console.log('启动 http://localhost:3000')\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看到网页显示：“print to body”"}),"\n",(0,s.jsx)(n.p,{children:"查看终端，显示和预想一样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"常用-koa-中间件",children:["常用 Koa 中间件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常用-koa-中间件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"随着ES6的普及，async/await 的语法受到更多开发者的青睐，Koa 作为比较早支持使用该语法的 Node 框架越来越受到大家的喜爱，虽然 Koa 本身支持的功能很有限，但官方和社区提供了很多各种功能的中间件。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/ZijianHe/koa-router",target:"_blank",rel:"noopener noreferrer",children:"koa-router"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/koajs/bodyparser",target:"_blank",rel:"noopener noreferrer",children:"koa-bodyparser"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/koa-modules/multer",target:"_blank",rel:"noopener noreferrer",children:"koa-multer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/queckezz/koa-views",target:"_blank",rel:"noopener noreferrer",children:"koa-views"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/koajs/static",target:"_blank",rel:"noopener noreferrer",children:"koa-static"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/koajs/session",target:"_blank",rel:"noopener noreferrer",children:"koa-session"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/koajs/jwt",target:"_blank",rel:"noopener noreferrer",children:"koa-jwt"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/venables/koa-helmet",target:"_blank",rel:"noopener noreferrer",children:"koa-helmet"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/koajs/compress",target:"_blank",rel:"noopener noreferrer",children:"koa-compress"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/koajs/logger",target:"_blank",rel:"noopener noreferrer",children:"koa-logger"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/koajs/cors",target:"_blank",rel:"noopener noreferrer",children:"@koa/cors@2"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["更多 Koa 插件可以到 ",(0,s.jsx)(n.a,{href:"https://github.com/koajs/koa/wiki",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.a,{href:"https://github.com/koajs/koa/wiki",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/koajs/koa/wiki"})})," 获取。"]}),"\n",(0,s.jsxs)(n.h2,{id:"认识-restful-api",children:["认识 Restful Api",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#认识-restful-api",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"rest",children:["Rest",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rest",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Rest 即表述性状态传递，Representational State Transfer 的简称；"}),"\n",(0,s.jsx)(n.li,{children:"Rest 是一种软件架构风格；"}),"\n",(0,s.jsx)(n.li,{children:"Rest 是一组架构约束条件和原则；"}),"\n",(0,s.jsx)(n.li,{children:"Rest 通常基于使用 HTTP，URI，和 XML 以及 HTML 这些现有的广泛流行的协议和标准；"}),"\n",(0,s.jsx)(n.li,{children:"Rest 通常使用 JSON 数据格式；"}),"\n",(0,s.jsx)(n.li,{children:"Rest 是设计风格而不是标准。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"restful",children:["Restful",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#restful",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"满足这些约束条件和原则的应用程序或设计就是 Restful"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["总结 REST 有两个最重要的原则：",(0,s.jsx)(n.br,{}),"\n","1.分离性；交互的客户端和服务器除了 Restful-API 没有其他的依赖关系，限制了整个系统的复杂性，促进了各个部分的独立性。",(0,s.jsx)(n.br,{}),"\n","2.无状态性：客户端和服务器之间的交互在请求之间是无状态的，从客户端到服务器的每个请求都必须包含理解请求所必需的信息。基于 Rest 架构的 Web Services 即是 Restful。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"restful-api",children:["Restful Api",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#restful-api",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"满足上面规范的 API 接口就是 Restful-API。客户端常常通过 HTTP 方法(GET、POST、PUT、DELETE等)，来发送 API 请求；服务端常常以 JSON 数据作为响应。"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Rest 基本架构的四个HTTP方法：",(0,s.jsx)(n.br,{}),"\n","GET - 用于获取数据。",(0,s.jsx)(n.br,{}),"\n","PUT - 用于更新或添加数据。",(0,s.jsx)(n.br,{}),"\n","DELETE - 用于删除数据。",(0,s.jsx)(n.br,{}),"\n","POST - 用于添加数据"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"实现简单的-restful-api",children:["实现简单的 Restful API",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现简单的-restful-api",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来，我尝试搭建简单的 Restful Api，这里直接列出代码，通过注释讲解："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const Koa = require('koa');\nconst logger = require('koa-logger');\nconst Router = require('koa-router');\nconst cors = require('@koa/cors');\nconst app = new Koa();\n\n//加入中间件\n//记录日志\napp.use(logger());\n\n//支持跨域请求\napp.use(cors());\n\n// 主页\nlet routerHome = new Router();\nrouterHome.get('/', async (ctx, next) => {\n    ctx.body = 'Hello Uniapp';\n})\n\nlet routerRest = new Router();\nrouterRest.get('/list', async (ctx, next) => { // 请求 /list 路由\n    ctx.body = {\n        code: 200,\n        msg: '请求成功',\n        data: 'list列表数据'\n    };\n}).post('/detail/:id', async (ctx, next) => { // 请求 /detail 路由 参数 id: 10086\n    ctx.body = {\n        code: 200,\n        msg: '请求成功',\n        data: 'detail详情数据'\n    };\n})\n\n// 装载所有路由\nlet router = new Router();\nrouter.use('/', routerHome.routes(), routerHome.allowedMethods());\nrouter.use('/rest', routerRest.routes(), routerRest.allowedMethods());\napp.use(router.routes(), router.allowedMethods());\n\n//监听3000端口\napp.listen(3000, () => {\n    console.log('server is running at http://localhost:3000')\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"使用 curl 命令测试 Restful Api"}),"\n",(0,s.jsxs)(n.h5,{id:"get请求",children:["GET请求",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#get请求",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$curl http://localhost:3000/rest/list\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"打印出：\n{\n	code: 200,\n	msg: '请求成功',\n	data: 'list列表数据'\n}\n"})}),"\n",(0,s.jsxs)(n.h5,{id:"post请求",children:["POST请求",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#post请求",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'$curl http://localhost:3000/rest/detail -X POST -H "Content-Type:application/json" -d \'{"id": 10086}\'\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"打印出：\n{\n	code: 200,\n	msg: '请求成功',\n	data: 'detail详情数据'\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"接口调试工具",children:["接口调试工具",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#接口调试工具",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["目前最受大众欢迎的API接口调试工具：",(0,s.jsx)(n.a,{href:"https://www.getpostman.com",target:"_blank",rel:"noopener noreferrer",children:"postman"}),"，免费的基本够用，当然你要高级的功能是收费的。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["因此，最近出现了一款 postman 的“老婆”：",(0,s.jsx)(n.a,{href:"https://github.com/liyasthomas/postwoman",target:"_blank",rel:"noopener noreferrer",children:"postwoman"}),"，免费开源、轻量级、快速的 API 调试工具，有兴趣的可以自己去尝试 ：）"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("img",{src:l,alt:""}),"\n",(0,s.jsx)("img",{src:a,alt:""})]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:['本章通过介绍 Koajs 框架，实现一个简易 Koajs 和 Restful 风格，并且实现简单 Restful Api，目的是让你对写后端接口有个"傻瓜式"的入门，下一章我会基于 ',(0,s.jsx)(n.a,{href:"https://binaryify.github.io/NeteaseCloudMusicApi",target:"_blank",rel:"noopener noreferrer",children:"NeteaseCloudMusicApi"})," 这个项目，来为每个入口页面提供接口。"]}),"\n",(0,s.jsxs)(n.li,{children:["本章代码 ",(0,s.jsx)(n.a,{href:"https://github.com/front-end-class/mini-koa",target:"_blank",rel:"noopener noreferrer",children:"mini-koa"}),"。"]}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Uniapp%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%2F25%20%E5%AE%9E%E6%88%9815%EF%BC%9A%E5%9F%BA%E4%BA%8EKoa.js%E5%AE%9E%E7%8E%B0Restful%20Api.md"]={toc:[{text:"Koa.js 框架快速入门",id:"koajs-框架快速入门",depth:2},{text:"Koa 极简实现",id:"koa-极简实现",depth:2},{text:"常用 Koa 中间件",id:"常用-koa-中间件",depth:2},{text:"认识 Restful Api",id:"认识-restful-api",depth:2},{text:"Rest",id:"rest",depth:3},{text:"Restful",id:"restful",depth:3},{text:"Restful Api",id:"restful-api",depth:3},{text:"实现简单的 Restful API",id:"实现简单的-restful-api",depth:2},{text:"接口调试工具",id:"接口调试工具",depth:2},{text:"小结",id:"小结",depth:2}],title:"25 实战15：基于Koa.js实现Restful Api",headingTitle:"25 实战15：基于Koa.js实现Restful Api",frontmatter:{}}}}]);