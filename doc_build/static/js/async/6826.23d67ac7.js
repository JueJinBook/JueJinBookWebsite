"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["6826"],{401747:function(n,e,r){r.r(e),r.d(e,{default:()=>l});var s=r(552676),a=r(740453);function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",blockquote:"blockquote",h2:"h2",pre:"pre",code:"code",h3:"h3"},(0,a.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"14反方向类型推导用好上下文相关类型",children:["14.反方向类型推导：用好上下文相关类型",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#14反方向类型推导用好上下文相关类型",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["TypeScript 拥有非常强大的类型推导能力，不仅会在你声明一个变量时自动推导其类型，也会基于函数内部逻辑自动推导其返回值类型，还会在你使用 typeof 、instanceof 等工具时自动地收窄类型（可辨识联合类型）等等。这些类型推导其实有一个共同点：",(0,s.jsx)(e.strong,{children:"它们的推导依赖开发者的输入"}),"，比如变量声明、函数逻辑、类型保护都需要开发者的输入。实际上， TypeScript 中还存在着另一种类型推导，它默默无闻却又无处不在，它就是这一节的主角：",(0,s.jsx)(e.strong,{children:"上下文类型（Contextual Typing）"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"这一节的内容比较短，因为上下文类型并不是一个多复杂、多庞大的概念（不涉及实现源码的情况下），但在实际开发中，我们经常会受益于上下文类型的推导能力，只不过你可能不知道背后是它得作用。学完这一节，以后感受到上下文类型存在时，你就可以在心里默默地说一句：“谢谢你，上下文类型”。"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["本节代码见：",(0,s.jsx)(e.a,{href:"https://github.com/linbudu599/TypeScript-Tiny-Book/tree/main/packages/11-contextual-typing",target:"_blank",rel:"noopener noreferrer",children:"Contextual Typings"})]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"无处不在的上下文类型",children:["无处不在的上下文类型",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#无处不在的上下文类型",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"首先举一个最常见的例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"window.onerror = (event, source, line, col, err) => {};\n"})}),"\n",(0,s.jsx)(e.p,{children:"在这个例子里，虽然我们并没有为 onerror 的各个参数声明类型，但是它们也已经获得了正确的类型。"}),"\n",(0,s.jsx)(e.p,{children:"当然你肯定能猜到，这是因为 onerror 的类型声明已经内置了："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"interface Handler {\n  // 简化\n  onerror: OnErrorEventHandlerNonNull;\n}\n\ninterface OnErrorEventHandlerNonNull {\n    (event: Event | string, source?: string, lineno?: number, colno?: number, error?: Error): any;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"我们自己实现一个函数签名，其实也是一样的效果："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"type CustomHandler = (name: string, age: number) => boolean;\n\n// 也推导出了参数类型\nconst handler: CustomHandler = (arg1, arg2) => true;\n"})}),"\n",(0,s.jsx)(e.p,{children:"除了参数类型，返回值类型同样会纳入管控："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"declare const struct: {\n  handler: CustomHandler;\n};\n// 不能将类型“void”分配给类型“boolean”。\nstruct.handler = (name, age) => {};\n"})}),"\n",(0,s.jsx)(e.p,{children:"当然，不仅是箭头函数，函数表达式也是一样的效果，这里就不做展开了。"}),"\n",(0,s.jsxs)(e.p,{children:["在这里，参数的类型基于其上下文类型中的参数类型位置来进行匹配，arg1 对应到 name ，所以是 string 类型，arg2 对应到 age，所以是 number 类型。这就是上下文类型的核心理念：",(0,s.jsx)(e.strong,{children:"基于位置的类型推导"}),"。同时，相对于我们上面提到的基于开发者输入进行的类型推导，上下文类型更像是",(0,s.jsx)(e.strong,{children:"反方向的类型推导"}),"，也就是",(0,s.jsx)(e.strong,{children:"基于已定义的类型来规范开发者的使用"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"在上下文类型中，我们实现的表达式可以只使用更少的参数，而不能使用更多，这还是因为上下文类型基于位置的匹配，一旦参数个数超过定义的数量，那就没法进行匹配了。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"// 正常\nwindow.onerror = (event) => {};\n// 报错\nwindow.onerror = (event, source, line, col, err, extra) => {};\n"})}),"\n",(0,s.jsx)(e.p,{children:"上下文类型也可以进行”嵌套“情况下的类型推导，如以下这个例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"declare let func: (raw: number) => (input: string) => any;\n\n// raw → number\nfunc = (raw) => {\n  // input → string\n  return (input) => {};\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:"在某些情况下，上下文类型的推导能力也会失效，比如这里我们使用一个由函数类型组成的联合类型："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"class Foo {\n  foo!: number;\n}\n\nclass Bar extends Foo {\n  bar!: number;\n}\n\nlet f1: { (input: Foo): void } | { (input: Bar): void };\n// 参数“input”隐式具有“any”类型。\nf1 = (input) => {};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["我们预期的结果是 input 被推导为 ",(0,s.jsx)(e.code,{children:"Foo | Bar"})," 类型，也就是所有符合结构的函数类型的参数，但却失败了。这是因为 TypeScript 中的上下文类型目前暂时不支持这一判断方式（而不是这不属于上下文类型的能力范畴）。"]}),"\n",(0,s.jsx)(e.p,{children:"你可以直接使用一个联合类型参数的函数签名："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"let f2: { (input: Foo | Bar): void };\n// Foo | Bar\nf2 = (input) => {};\n"})}),"\n",(0,s.jsx)(e.p,{children:"而如果联合类型中将这两个类型再嵌套一层，此时上下文类型反而正常了："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"let f3:\n  | { (raw: number): (input: Foo) => void }\n  | { (raw: number): (input: Bar) => void };\n\n// raw → number\nf3 = (raw) => {\n  // input → Bar\n  return (input) => {};\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:"这里被推导为 Bar 的原因，其实还和我们此前了解的协变、逆变有关。任何接收 Foo 类型参数的地方，都可以接收一个 Bar 类型参数，因此推导到 Bar 类型要更加安全。"}),"\n",(0,s.jsxs)(e.h2,{id:"void-返回值类型下的特殊情况",children:["void 返回值类型下的特殊情况",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#void-返回值类型下的特殊情况",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"我们前面说到，上下文类型同样会推导并约束函数的返回值类型，但存在这么个特殊的情况，当内置函数类型的返回值类型为 void 时："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"type CustomHandler = (name: string, age: number) => void;\n\nconst handler1: CustomHandler = (name, age) => true;\nconst handler2: CustomHandler = (name, age) => 'linbudu';\nconst handler3: CustomHandler = (name, age) => null;\nconst handler4: CustomHandler = (name, age) => undefined;\n"})}),"\n",(0,s.jsxs)(e.p,{children:["你会发现这个时候，我们的函数实现返回值类型变成了五花八门的样子，而且还都不会报错？同样的，这也是一条世界底层的规则，",(0,s.jsx)(e.strong,{children:"上下文类型对于 void 返回值类型的函数，并不会真的要求它啥都不能返回"}),"。然而，虽然这些函数实现可以返回任意类型的值，但",(0,s.jsx)(e.strong,{children:"对于调用结果的类型，仍然是 void"}),"："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const result1 = handler1('linbudu', 599); // void\nconst result2 = handler2('linbudu', 599); // void\nconst result3 = handler3('linbudu', 599); // void\nconst result4 = handler4('linbudu', 599); // void\n"})}),"\n",(0,s.jsx)(e.p,{children:"看起来这是一种很奇怪的、错误的行为，但实际上，我们日常开发中的很多代码都需要这一“不正确的”行为才不会报错，比如以下这个例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const arr: number[] = [];\nconst list: number[] = [1, 2, 3];\n\nlist.forEach((item) => arr.push(item));\n"})}),"\n",(0,s.jsx)(e.p,{children:"这是我们常用的简写方式，然而，push 方法的返回值是一个 number 类型（push 后数组的长度），而 forEach 的上下文类型声明中要求返回值是 void 类型。如果此时 void 类型真的不允许任何返回值，那这里我们就需要多套一个代码块才能确保类型符合了。"}),"\n",(0,s.jsxs)(e.p,{children:["但这真的是有必要的吗？对于一个 void 类型的函数，我们真的会去消费它的返回值吗？既然不会，那么它想返回什么，全凭它乐意就好了。我们还可以用另一种方式来描述这个概念：你可以",(0,s.jsxs)(e.strong,{children:["将返回值非 void 类型的函数（",(0,s.jsx)(e.code,{children:"() => list.push()"}),"）作为返回值类型为 void 类型（",(0,s.jsx)(e.code,{children:"arr.forEach"}),"）的函数类型参数"]}),"。"]}),"\n",(0,s.jsxs)(e.h2,{id:"总结与预告",children:["总结与预告",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结与预告",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在这一节里，我们学习了上下文类型这“另一个方向”的类型推导，了解了它是基于位置进行类型匹配的，以及上下文类型中 void 类型返回值的特殊情况。"}),"\n",(0,s.jsxs)(e.p,{children:["这一节比较轻松对吧？那在下一节，我们会学习一个稍微复杂点的概念：函数类型兼容性比较，以及其中的",(0,s.jsx)(e.strong,{children:"协变"}),"与",(0,s.jsx)(e.strong,{children:"逆变"}),"概念。我们在前面类型层级一节中，并没有提及函数类型地比较，这也是因为其中的概念相对复杂，需要更多的前置知识与更多的消化过程，因此我单独准备了一节内容。"]}),"\n",(0,s.jsxs)(e.h2,{id:"扩展阅读",children:["扩展阅读",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"将更少参数的函数赋值给具有更多参数的函数类型",children:["将更少参数的函数赋值给具有更多参数的函数类型",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#将更少参数的函数赋值给具有更多参数的函数类型",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在上面的例子中，我们看到了这么一段代码："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"const arr: number[] = [];\nconst list: number[] = [1, 2, 3];\n\nlist.forEach((item) => arr.push(item));\n"})}),"\n",(0,s.jsx)(e.p,{children:"在 forEach 的函数中，我们会消费 list 的每一个成员。但我们有时也会遇到并不实际消费数组成员的情况："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"list.forEach(() => arr.push(otherFactory));\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这个时候，我们实际上就是在",(0,s.jsx)(e.strong,{children:"将更少参数的函数赋值给具有更多参数的函数类型"}),"！"]}),"\n",(0,s.jsx)(e.p,{children:"再看一个更明显的例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"function handler(arg: string) {\n  console.log(arg);\n}\n\nfunction useHandler(callback: (arg1: string, arg2: number) => void) {\n  callback('linbudu', 599);\n}\n\nuseHandler(handler);\n"})}),"\n",(0,s.jsxs)(e.p,{children:["handler 函数的类型签名很明显与 useHandler 函数的 callback 类型签名并不一致，但这里却没有报错。从实用意义的角度来看，如果我们需要类型签名完全一致，那么就需要为 handler 再声明一个额外的对应到 arg2 的参数，然而我们的 handler 代码里实际上并没有去消费第二个参数。这实际上在 JavaScript 中也是我们经常使用的方式：",(0,s.jsx)(e.strong,{children:"即使用更少入参的函数来作为一个预期更多入参函数参数的实现"}),"。"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(i,{...n})}):i(n)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["TypeScript%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F14.%E5%8F%8D%E6%96%B9%E5%90%91%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%9A%E7%94%A8%E5%A5%BD%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9E%8B.md"]={toc:[{text:"无处不在的上下文类型",id:"无处不在的上下文类型",depth:2},{text:"void 返回值类型下的特殊情况",id:"void-返回值类型下的特殊情况",depth:2},{text:"总结与预告",id:"总结与预告",depth:2},{text:"扩展阅读",id:"扩展阅读",depth:2},{text:"将更少参数的函数赋值给具有更多参数的函数类型",id:"将更少参数的函数赋值给具有更多参数的函数类型",depth:3}],title:"14.反方向类型推导：用好上下文相关类型",headingTitle:"14.反方向类型推导：用好上下文相关类型",frontmatter:{}}}}]);