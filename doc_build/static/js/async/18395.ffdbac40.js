"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18395"],{752518:function(e,n,s){s.r(n),s.d(n,{default:()=>i});var c=s(552676),d=s(740453);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",ul:"ul",li:"li"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"12运算符的扩展",children:["12.运算符的扩展",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12运算符的扩展",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"本章介绍 ES6 后续标准添加的一些运算符。"}),"\n",(0,c.jsxs)(n.h2,{id:"指数运算符",children:["指数运算符",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#指数运算符",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["ES2016 新增了一个指数运算符（",(0,c.jsx)(n.code,{children:"**"}),"）。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"2 ** 2 // 4\n2 ** 3 // 8\n"})}),"\n",(0,c.jsx)(n.p,{children:"这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n"})}),"\n",(0,c.jsx)(n.p,{children:"上面代码中，首先计算的是第二个指数运算符，而不是第一个。"}),"\n",(0,c.jsxs)(n.p,{children:["指数运算符可以与等号结合，形成一个新的赋值运算符（",(0,c.jsx)(n.code,{children:"**="}),"）。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"let a = 1.5;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 4;\nb **= 3;\n// 等同于 b = b * b * b;\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"链判断运算符",children:["链判断运算符",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#链判断运算符",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["编程实务中，如果读取对象内部的某个属性，往往需要判断一下，属性的上层对象是否存在。比如，读取",(0,c.jsx)(n.code,{children:"message.body.user.firstName"}),"这个属性，安全的写法是写成下面这样。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// 错误的写法\nconst  firstName = message.body.user.firstName || 'default';\n\n// 正确的写法\nconst firstName = (message\n  && message.body\n  && message.body.user\n  && message.body.user.firstName) || 'default';\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面例子中，",(0,c.jsx)(n.code,{children:"firstName"}),"属性在对象的第四层，所以需要判断四次，每一层是否有值。"]}),"\n",(0,c.jsxs)(n.p,{children:["三元运算符",(0,c.jsx)(n.code,{children:"?:"}),"也常用于判断对象是否存在。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const fooInput = myForm.querySelector('input[name=foo]')\nconst fooValue = fooInput ? fooInput.value : undefined\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面例子中，必须先判断",(0,c.jsx)(n.code,{children:"fooInput"}),"是否存在，才能读取",(0,c.jsx)(n.code,{children:"fooInput.value"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["这样的层层判断非常麻烦，因此 ",(0,c.jsx)(n.a,{href:"https://github.com/tc39/proposal-optional-chaining",target:"_blank",rel:"noopener noreferrer",children:"ES2020"})," 引入了“链判断运算符”（optional chaining operator）",(0,c.jsx)(n.code,{children:"?."}),"，简化上面的写法。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const firstName = message?.body?.user?.firstName || 'default';\nconst fooValue = myForm.querySelector('input[name=foo]')?.value\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码使用了",(0,c.jsx)(n.code,{children:"?."}),"运算符，直接在链式调用的时候判断，左侧的对象是否为",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"。如果是的，就不再往下运算，而是返回",(0,c.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"下面是判断对象方法是否存在，如果存在就立即执行的例子。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"iterator.return?.()\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"iterator.return"}),"如果有定义，就会调用该方法，否则",(0,c.jsx)(n.code,{children:"iterator.return"}),"直接返回",(0,c.jsx)(n.code,{children:"undefined"}),"，不再执行",(0,c.jsx)(n.code,{children:"?."}),"后面的部分。"]}),"\n",(0,c.jsx)(n.p,{children:"对于那些可能没有实现的方法，这个运算符尤其有用。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"if (myForm.checkValidity?.() === false) {\n  // 表单校验失败\n  return;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，老式浏览器的表单对象可能没有",(0,c.jsx)(n.code,{children:"checkValidity()"}),"这个方法，这时",(0,c.jsx)(n.code,{children:"?."}),"运算符就会返回",(0,c.jsx)(n.code,{children:"undefined"}),"，判断语句就变成了",(0,c.jsx)(n.code,{children:"undefined === false"}),"，所以就会跳过下面的代码。"]}),"\n",(0,c.jsxs)(n.p,{children:["链判断运算符",(0,c.jsx)(n.code,{children:"?."}),"有三种写法。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"obj?.prop"})," // 对象属性是否存在"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"obj?.[expr]"})," // 同上"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"func?.(...args)"})," // 函数或对象方法是否存在"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["下面是",(0,c.jsx)(n.code,{children:"obj?.[expr]"}),"用法的一个例子。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:'let hex = "#C0FFEE".match(/#([A-Z]+)/i)?.[1];\n'})}),"\n",(0,c.jsxs)(n.p,{children:["上面例子中，字符串的",(0,c.jsx)(n.code,{children:"match()"}),"方法，如果没有发现匹配会返回",(0,c.jsx)(n.code,{children:"null"}),"，如果发现匹配会返回一个数组，",(0,c.jsx)(n.code,{children:"?."}),"运算符起到了判断作用。"]}),"\n",(0,c.jsxs)(n.p,{children:["下面是",(0,c.jsx)(n.code,{children:"?."}),"运算符常见形式，以及不使用该运算符时的等价形式。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"a?.b\n// 等同于\na == null ? undefined : a.b\n\na?.[x]\n// 等同于\na == null ? undefined : a[x]\n\na?.b()\n// 等同于\na == null ? undefined : a.b()\n\na?.()\n// 等同于\na == null ? undefined : a()\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，特别注意后两种形式，如果",(0,c.jsx)(n.code,{children:"a?.b()"}),"和",(0,c.jsx)(n.code,{children:"a?.()"}),"。如果",(0,c.jsx)(n.code,{children:"a?.b()"}),"里面的",(0,c.jsx)(n.code,{children:"a.b"}),"有值，但不是函数，不可调用，那么",(0,c.jsx)(n.code,{children:"a?.b()"}),"是会报错的。",(0,c.jsx)(n.code,{children:"a?.()"}),"也是如此，如果",(0,c.jsx)(n.code,{children:"a"}),"不是",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"，但也不是函数，那么",(0,c.jsx)(n.code,{children:"a?.()"}),"会报错。"]}),"\n",(0,c.jsx)(n.p,{children:"使用这个运算符，有几个注意点。"}),"\n",(0,c.jsx)(n.p,{children:"（1）短路机制"}),"\n",(0,c.jsxs)(n.p,{children:["本质上，",(0,c.jsx)(n.code,{children:"?."}),"运算符相当于一种短路机制，只要不满足条件，就不再往下执行。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"a?.[++x]\n// 等同于\na == null ? undefined : a[++x]\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，如果",(0,c.jsx)(n.code,{children:"a"}),"是",(0,c.jsx)(n.code,{children:"undefined"}),"或",(0,c.jsx)(n.code,{children:"null"}),"，那么",(0,c.jsx)(n.code,{children:"x"}),"不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。"]}),"\n",(0,c.jsx)(n.p,{children:"（2）括号的影响"}),"\n",(0,c.jsx)(n.p,{children:"如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"(a?.b).c\n// 等价于\n(a == null ? undefined : a.b).c\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"?."}),"对圆括号外部没有影响，不管",(0,c.jsx)(n.code,{children:"a"}),"对象是否存在，圆括号后面的",(0,c.jsx)(n.code,{children:".c"}),"总是会执行。"]}),"\n",(0,c.jsxs)(n.p,{children:["一般来说，使用",(0,c.jsx)(n.code,{children:"?."}),"运算符的场合，不应该使用圆括号。"]}),"\n",(0,c.jsx)(n.p,{children:"（3）报错场合"}),"\n",(0,c.jsx)(n.p,{children:"以下写法是禁止的，会报错。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// 构造函数\nnew a?.()\nnew a?.b()\n\n// 链判断运算符的右侧有模板字符串\na?.`{b}`\na?.b`{c}`\n\n// 链判断运算符的左侧是 super\nsuper?.()\nsuper?.foo\n\n// 链运算符用于赋值运算符左侧\na?.b = c\n"})}),"\n",(0,c.jsx)(n.p,{children:"（4）右侧不得为十进制数值"}),"\n",(0,c.jsxs)(n.p,{children:["为了保证兼容以前的代码，允许",(0,c.jsx)(n.code,{children:"foo?.3:0"}),"被解析成",(0,c.jsx)(n.code,{children:"foo ? .3 : 0"}),"，因此规定如果",(0,c.jsx)(n.code,{children:"?."}),"后面紧跟一个十进制数字，那么",(0,c.jsx)(n.code,{children:"?."}),"不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。"]}),"\n",(0,c.jsxs)(n.h2,{id:"null-判断运算符",children:["Null 判断运算符",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#null-判断运算符",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["读取对象属性的时候，如果某个属性的值是",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"，有时候需要为它们指定默认值。常见做法是通过",(0,c.jsx)(n.code,{children:"||"}),"运算符指定默认值。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const headerText = response.settings.headerText || 'Hello, world!';\nconst animationDuration = response.settings.animationDuration || 300;\nconst showSplashScreen = response.settings.showSplashScreen || true;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面的三行代码都通过",(0,c.jsx)(n.code,{children:"||"}),"运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"，默认值就会生效，但是属性的值如果为空字符串或",(0,c.jsx)(n.code,{children:"false"}),"或",(0,c.jsx)(n.code,{children:"0"}),"，默认值也会生效。"]}),"\n",(0,c.jsxs)(n.p,{children:["为了避免这种情况，",(0,c.jsx)(n.a,{href:"https://github.com/tc39/proposal-nullish-coalescing",target:"_blank",rel:"noopener noreferrer",children:"ES2020"})," 引入了一个新的 Null 判断运算符",(0,c.jsx)(n.code,{children:"??"}),"。它的行为类似",(0,c.jsx)(n.code,{children:"||"}),"，但是只有运算符左侧的值为",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"时，才会返回右侧的值。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const headerText = response.settings.headerText ?? 'Hello, world!';\nconst animationDuration = response.settings.animationDuration ?? 300;\nconst showSplashScreen = response.settings.showSplashScreen ?? true;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，默认值只有在左侧属性值为",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"时，才会生效。"]}),"\n",(0,c.jsxs)(n.p,{children:["这个运算符的一个目的，就是跟链判断运算符",(0,c.jsx)(n.code,{children:"?."}),"配合使用，为",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"的值设置默认值。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const animationDuration = response.settings?.animationDuration ?? 300;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，如果",(0,c.jsx)(n.code,{children:"response.settings"}),"是",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"，或者",(0,c.jsx)(n.code,{children:"response.settings.animationDuration"}),"是",(0,c.jsx)(n.code,{children:"null"}),"或",(0,c.jsx)(n.code,{children:"undefined"}),"，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。"]}),"\n",(0,c.jsx)(n.p,{children:"这个运算符很适合判断函数参数是否赋值。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function Component(props) {\n  const enable = props.enabled ?? true;\n  // …\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码判断",(0,c.jsx)(n.code,{children:"props"}),"参数的",(0,c.jsx)(n.code,{children:"enabled"}),"属性是否赋值，基本等同于下面的写法。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function Component(props) {\n  const {\n    enabled: enable = true,\n  } = props;\n  // …\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"??"}),"本质上是逻辑运算，它与其他两个逻辑运算符",(0,c.jsx)(n.code,{children:"&&"}),"和",(0,c.jsx)(n.code,{children:"||"}),"有一个优先级问题，它们之间的优先级到底孰高孰低。优先级的不同，往往会导致逻辑运算的结果不同。"]}),"\n",(0,c.jsx)(n.p,{children:"现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// 报错\nlhs && middle ?? rhs\nlhs ?? middle && rhs\nlhs || middle ?? rhs\nlhs ?? middle || rhs\n"})}),"\n",(0,c.jsx)(n.p,{children:"上面四个表达式都会报错，必须加入表明优先级的括号。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"(lhs && middle) ?? rhs;\nlhs && (middle ?? rhs);\n\n(lhs ?? middle) && rhs;\nlhs ?? (middle && rhs);\n\n(lhs || middle) ?? rhs;\nlhs || (middle ?? rhs);\n\n(lhs ?? middle) || rhs;\nlhs ?? (middle || rhs);\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"逻辑赋值运算符",children:["逻辑赋值运算符",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑赋值运算符",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["ES2021 引入了三个新的",(0,c.jsx)(n.a,{href:"https://github.com/tc39/proposal-logical-assignment",target:"_blank",rel:"noopener noreferrer",children:"逻辑赋值运算符"}),"（logical assignment operators），将逻辑运算符与赋值运算符进行结合。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// 或赋值运算符\nx ||= y\n// 等同于\nx || (x = y)\n\n// 与赋值运算符\nx &&= y\n// 等同于\nx && (x = y)\n\n// Null 赋值运算符\nx ??= y\n// 等同于\nx ?? (x = y)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这三个运算符",(0,c.jsx)(n.code,{children:"||="}),"、",(0,c.jsx)(n.code,{children:"&&="}),"、",(0,c.jsx)(n.code,{children:"??="}),"相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。"]}),"\n",(0,c.jsx)(n.p,{children:"它们的一个用途是，为变量或属性设置默认值。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// 老的写法\nuser.id = user.id || 1;\n\n// 新的写法\nuser.id ||= 1;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面示例中，",(0,c.jsx)(n.code,{children:"user.id"}),"属性如果不存在，则设为",(0,c.jsx)(n.code,{children:"1"}),"，新的写法比老的写法更紧凑一些。"]}),"\n",(0,c.jsx)(n.p,{children:"下面是另一个例子。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function example(opts) {\n  opts.foo = opts.foo ?? 'bar';\n  opts.baz ?? (opts.baz = 'qux');\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面示例中，参数对象",(0,c.jsx)(n.code,{children:"opts"}),"如果不存在属性",(0,c.jsx)(n.code,{children:"foo"}),"和属性",(0,c.jsx)(n.code,{children:"baz"}),"，则为这两个属性设置默认值。有了“Null 赋值运算符”以后，就可以统一写成下面这样。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function example(opts) {\n  opts.foo ??= 'bar';\n  opts.baz ??= 'qux';\n}\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"命令",children:[(0,c.jsx)(n.code,{children:"#!"}),"命令",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#命令",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["Unix 的命令行脚本都支持",(0,c.jsx)(n.code,{children:"#!"}),"命令，又称为 Shebang 或 Hashbang。这个命令放在脚本的第一行，用来指定脚本的执行器。"]}),"\n",(0,c.jsx)(n.p,{children:"比如 Bash 脚本的第一行。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"#!/bin/sh\n"})}),"\n",(0,c.jsx)(n.p,{children:"Python 脚本的第一行。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://github.com/tc39/proposal-hashbang",target:"_blank",rel:"noopener noreferrer",children:"ES2023"})," 为 JavaScript 脚本引入了",(0,c.jsx)(n.code,{children:"#!"}),"命令，写在脚本文件或者模块文件的第一行。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// 写在脚本文件第一行\n#!/usr/bin/env node\n'use strict';\nconsole.log(1);\n\n// 写在模块文件第一行\n#!/usr/bin/env node\nexport {};\nconsole.log(1);\n"})}),"\n",(0,c.jsx)(n.p,{children:"有了这一行以后，Unix 命令行就可以直接执行脚本。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"# 以前执行脚本的方式\n$ node hello.js\n\n# hashbang 的方式\n$ ./hello.js\n"})}),"\n",(0,c.jsxs)(n.p,{children:["对于 JavaScript 引擎来说，会把",(0,c.jsx)(n.code,{children:"#!"}),"理解成注释，忽略掉这一行。"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(r,{...e})}):r(e)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F12.%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%89%A9%E5%B1%95.md"]={toc:[{text:"指数运算符",id:"指数运算符",depth:2},{text:"链判断运算符",id:"链判断运算符",depth:2},{text:"Null 判断运算符",id:"null-判断运算符",depth:2},{text:"逻辑赋值运算符",id:"逻辑赋值运算符",depth:2},{text:"`#!`命令",id:"命令",depth:2}],title:"12.运算符的扩展",headingTitle:"12.运算符的扩展",frontmatter:{}}}}]);