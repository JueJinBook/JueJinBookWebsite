"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["72037"],{792699:function(e,r,n){e.exports=n.p+"static/image/fb5760fee7cd147658aa2ffb75e7b47f.8c005ae7.webp"},93615:function(e,r,n){n.r(r),n.d(r,{default:()=>x});var s=n(552676),i=n(740453),d=n(792699);let l=n.p+"static/image/1a2e5014c1719b198609d8ac7e21ab3e.82f3f5d8.webp",c=n.p+"static/image/ddd210d9e38c4be88031d3540c23d90b.eaf6c60c.webp",t=n.p+"static/image/df25a7e6237f351ed1a21ad87e3f978e.3276f609.webp",o=n.p+"static/image/7ab34e7e0ac9f564b5c244528fd0ba83.b5599468.webp",a=n.p+"static/image/5fcf84c9d1966ad23701f58fc64e45f1.57d341f9.webp";function p(e){let r=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"23-图解串一串-nest-核心概念",children:["23. 图解串一串 Nest 核心概念",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#23-图解串一串-nest-核心概念",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"前面讲了 IOC、AOP、全局模块、动态模块、自定义 provider、生命周期等概念，比较零散，这节我们画图来整体串一串。"}),"\n",(0,s.jsx)(r.p,{children:"首先，provider 是可以注入的对象，它们都有 token，比如 @Injectable 装饰器声明的 class"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"token 可以是 class 也可以是 string："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"provider 可以是 useClass 指定 class，也可以 useValue 指定值，或者 useFactory 动态创建。"}),"\n",(0,s.jsx)(r.p,{children:"provider 之间可以相互注入，还可以注入到 controller 里。"}),"\n",(0,s.jsx)(r.p,{children:"provider、controller 放在一个个 Module 里："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"module 里 exports 的 provider 在模块被 imports 之后就可以用于别的模块的注入了。"}),"\n",(0,s.jsx)(r.p,{children:"或者可以通过 @Global 把这个模块声明为全局的，那样 Module 内的 provider 就可以在各处注入了。"}),"\n",(0,s.jsx)(r.p,{children:"Provider 可以通过 useFactory 动态创建，Module 也是，可以通过 register、forRoot、forFeature 等方法来动态创建。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"在 main.ts 里调用 NestFactory.create 方法，就会从 AppModule 开始递归解析 Module，实例化其中的 provider、controller，并依次调用它们的 onModuleInit 生命周期方法。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"之后会再递归调用每个 Module 的 provider、controller 的还有 Module 自身的 onApplicationBootstrap 生命周期方法。"}),"\n",(0,s.jsx)(r.p,{children:"这样 Nest 就能对外提供服务了。"}),"\n",(0,s.jsx)(r.p,{children:"再就是 Nest 从接收到请求，到返回响应的这个流程，有很多切面。"}),"\n",(0,s.jsx)(r.p,{children:"路由最终是在 cotnroller 的方法，也就是 handler 里处理的。"}),"\n",(0,s.jsx)(r.p,{children:"在这个过程中，会经历很多层切面："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"首先，请求会被 middleware 处理，这一层可以复用 express 的中间件生态，实现 session、static files 等功能。"}),"\n",(0,s.jsx)(r.p,{children:"这个 middleware 也可以是 Nest 的那种 class 的 middleware，可以注入 provider。"}),"\n",(0,s.jsx)(r.p,{children:"然后在具体的路由会经历 Guard 的处理，它可以通过 ExecutionContext 拿到目标 class、handler 的metadata 等信息，可以实现权限验证等功能。"}),"\n",(0,s.jsx)(r.p,{children:"之后是 Interceptor 可以在请求前后做一些处理，它也可以通过 ExecutionContext 拿到 class、handler 的信息。"}),"\n",(0,s.jsx)(r.p,{children:"在到达 handler 之前，还会对参数用 Pipe 做下检验和转换。"}),"\n",(0,s.jsx)(r.p,{children:"这个过程中不管是哪一层抛的异常，都会被 Exception Filter 处理下，返回给用户友好的响应信息。"}),"\n",(0,s.jsx)(r.p,{children:"这就是整个请求到响应的流程。"}),"\n",(0,s.jsx)(r.p,{children:"通过 AOP 的切面，可以把通用逻辑封装起来，在各处复用。"}),"\n",(0,s.jsx)(r.p,{children:"之后，Nest 销毁的时候，也会依次调用 Module 的 provider、controller 还有 Module 自己的 onModuleDestroy 方法、beforeApplicationShutdown 还有 onApplicationShutdown 的生命周期方法。"}),"\n",(0,s.jsx)(r.p,{children:"后两者的区别是 beforeApplication 可以拿到终止信号。"}),"\n",(0,s.jsx)(r.p,{children:"这就是 Nest 从创建、启动，到处理请求返回响应，再就是销毁的整个流程。"}),"\n",(0,s.jsx)(r.p,{children:"通过 IOC 实现了对象的自动创建、依赖的自动组装。"}),"\n",(0,s.jsx)(r.p,{children:"通过 AOP 实现了通用逻辑的抽取和复用。"}),"\n",(0,s.jsx)(r.p,{children:"IOC 内部的 Module 和 Provider 也都支持动态创建，灵活度很高。"}),"\n",(0,s.jsxs)(r.h2,{id:"总结",children:["总结",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"我们通过图解串了一下 Module、Provider、Controller、动态模块、全局模块、自定义 Provider、生命周期、Middleware、Guard、Pipe、Interceptor、Exception Filter 等概念。"}),"\n",(0,s.jsx)(r.p,{children:"对 IOC、AOP 也有了更加清晰的认识。"}),"\n",(0,s.jsx)(r.p,{children:"把这些核心概念理解了，对 Nest 就算有比较好的掌握了。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}let x=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F23.%20%E5%9B%BE%E8%A7%A3%E4%B8%B2%E4%B8%80%E4%B8%B2%20Nest%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"23. 图解串一串 Nest 核心概念",headingTitle:"23. 图解串一串 Nest 核心概念",frontmatter:{}}}}]);