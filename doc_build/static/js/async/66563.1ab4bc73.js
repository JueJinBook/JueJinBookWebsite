"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["66563"],{538172:function(e,n,r){r.r(n),r.d(n,{default:()=>A});var s=r(552676),a=r(740453);let t=r.p+"static/image/a3e9d9154c5d5bd72410e34cedc7f003.a7e37672.webp",c=r.p+"static/image/6817a505607899fe5ea6c90edab5efae.84274816.webp",i=r.p+"static/image/1a7e09ecf9f89274768f5d48860732ce.63936758.webp",d=r.p+"static/image/f986c3c9cd833fe0285dce4f95eb6370.b4284c46.webp",l=r.p+"static/image/1ec2bb3f21319658f8c80533bbaf85a3.2df739ff.webp",o=r.p+"static/image/ed182ac11f5406af0b0cb6aa06e09eb7.37b66afe.webp",p=r.p+"static/image/bca31881aaad2ae709d5bd7a1b516c94.5310cbbb.webp",h=r.p+"static/image/7aa54096d88bc973d28ff51f8a1ba8af.8559c2b9.webp",x=r.p+"static/image/c4fb4c1ad8d39dba76ce69b413146461.0b9d3d7b.webp",j=r.p+"static/image/53d39b7fad2cdd60c4c661df34cc01ff.dfc4170e.webp",m=r.p+"static/image/5ce9391b1537826643dfd3be41a11373.9a9b3d65.webp",u=r.p+"static/image/2feb9c768398c0818382f15357ff2d46.aee87d93.webp",f=r.p+"static/image/62aff8dc79cbb018cfeb7db255b77e6d.12686565.webp",g=r.p+"static/image/67adeaf32ef2b824d0dbce03b10d1b75.97ae2a3d.webp",b=r.p+"static/image/8612834780b78d3fb5318bb72ca955c4.a863aff8.webp",y=r.p+"static/image/62e2f72e4e843f7a7bb5385141af3d1c.9e6713a9.webp",N=r.p+"static/image/489520bdbb46e4659e5218a4212b38ca.fe6c92da.webp",w=r.p+"static/image/4683dcd1b03cd11aae0b577e19e5a351.42d68627.webp",P=r.p+"static/image/a395f5467440f20e9e63b8341a50a836.03deafb3.webp",q=r.p+"static/image/83429a46ff70a688f940fe4003f58c8c.0a12551a.webp",E=r.p+"static/image/133f466ffda69112c9ba8ea7c100878f.16eaa874.webp";function C(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",pre:"pre",code:"code",img:"img",strong:"strong"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"5-5-种-http-数据传输方式",children:["5. 5 种 HTTP 数据传输方式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-5-种-http-数据传输方式",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"对于前端来说，后端主要是提供 http 接口来传输数据，而这种数据传输的方式主要有 5 种："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"url param"}),"\n",(0,s.jsx)(n.li,{children:"query"}),"\n",(0,s.jsx)(n.li,{children:"form-urlencoded"}),"\n",(0,s.jsx)(n.li,{children:"form-data"}),"\n",(0,s.jsx)(n.li,{children:"json"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"我们分别来看一下："}),"\n",(0,s.jsxs)(n.h2,{id:"url-param",children:["url param",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#url-param",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们可以把参数写在 url 中，比如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"http://guang.zxg/person/1111\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里的 1111 就是路径中的参数（url param），服务端框架或者单页应用的路由都支持从 url 中取出参数。"}),"\n",(0,s.jsxs)(n.h2,{id:"query",children:["query",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#query",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过 url 中 ？后面的用 & 分隔的字符串传递数据。比如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"http://guang.zxg/person?name=guang&age=20\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里的 name 和 age 就是 query 传递的数据。"}),"\n",(0,s.jsx)(n.p,{children:"其中非英文的字符和一些特殊字符要经过编码，可以使用 encodeURIComponent 的 api 来编码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const query = "?name=" + encodeURIComponent(\'光\') + "&age=20"\n\n// ?name=%E5%85%89&age=20\n'})}),"\n",(0,s.jsx)(n.p,{children:"或者使用封装了一层的 query-string 库来处理。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const queryString = require('query-string');\n\nqueryString.stringify({\n  name: '光',\n  age: 20\n});\n\n// ?name=%E5%85%89&age=20\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"form-urlencoded",children:["form-urlencoded",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#form-urlencoded",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["直接用 form 表单提交数据就是这种，它和 query 字符串的方式的区别只是放在了 body 里，然后指定下 content-type 是 ",(0,s.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"因为内容也是 query 字符串，所以也要用 encodeURIComponent 的 api 或者 query-string 库处理下。"}),"\n",(0,s.jsx)(n.p,{children:"这种格式也很容易理解，get 是把数据拼成 query 字符串放在 url 后面，于是表单的 post 提交方式的时候就直接用相同的方式把数据放在了 body 里。"}),"\n",(0,s.jsx)(n.p,{children:"通过 & 分隔的 form-urlencoded 的方式需要对内容做 url encode，如果传递大量的数据，比如上传文件的时候就不是很合适了，因为文件 encode 一遍的话太慢了，这时候就可以用 form-data。"}),"\n",(0,s.jsxs)(n.h2,{id:"form-data",children:["form-data",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#form-data",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"form data 不再是通过 & 分隔数据，而是用 --------- + 一串数字做为 boundary 分隔符。因为不是 url 的方式了，自然也不用再做 url encode。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:q,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["form-data 需要指定 content type 为 ",(0,s.jsx)(n.code,{children:"multipart/form-data"}),"，然后指定 boundary 也就是分割线。"]}),"\n",(0,s.jsx)(n.p,{children:"body 里面就是用 boundary 分隔符分割的内容。"}),"\n",(0,s.jsx)(n.p,{children:"很明显，这种方式适合传输文件，而且可以传输多个文件。"}),"\n",(0,s.jsx)(n.p,{children:"但是毕竟多了一些只是用来分隔的 boundary，所以请求体会增大。"}),"\n",(0,s.jsxs)(n.h2,{id:"json",children:["json",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#json",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"form-urlencoded 需要对内容做 url encode，而 form data 则需要加很长的 boundary，两种方式都有一些缺点。如果只是传输 json 数据的话，不需要用这两种。"}),"\n",(0,s.jsx)(n.p,{children:"可以直接指定content type 为 application/json 就行："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们平时传输 json 数据基本用的是这种。"}),"\n",(0,s.jsx)(n.p,{children:"那这 5 种接口怎么用 Nest 实现呢？"}),"\n",(0,s.jsx)(n.p,{children:"我们分别看一下："}),"\n",(0,s.jsx)(n.p,{children:"首先我们要把 Nest 服务端跑起来，并且支持 api 接口、静态页面。"}),"\n",(0,s.jsx)(n.p,{children:"Nest 创建一个 crud 服务是非常快的，只需要这么几步："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"安装 @nestjs/cli，使用 nest new xxx 创建一个 Nest 的项目，"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest new xxx\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"在根目录执行 nest g resource person 快速生成 person 模块的 crud 代码"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest g resource person\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"nest start --watch 启动 Nest 服务"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest start --watch\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样一个有 person 的 crud 接口的服务就跑起来了。"}),"\n",(0,s.jsx)(n.p,{children:"服务跑起来以后是这样的"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"打印出了有哪些接口可以用，可以在浏览器测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"api 接口跑通了，再支持下静态资源的访问："}),"\n",(0,s.jsx)(n.p,{children:"main.ts 是负责启动 Nest 的 ioc 容器的，调用下 useStaticAssets 来支持静态资源的请求："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { NestExpressApplication } from '@nestjs/platform-express';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n  app.useStaticAssets('public', { prefix: '/static'});\n  await app.listen(3000);\n}\nbootstrap();\n"})}),"\n",(0,s.jsx)(n.p,{children:"（注意要给 create 方法传入 NestExpressApplication 的泛型参数才有 useStaticAssets这些方法）"}),"\n",(0,s.jsx)(n.p,{children:"我们指定 prefix 为 static，然后在静态文件目录 public 下添加一个 html："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<html>\n<body>hello</body>\n</html>\n"})}),"\n",(0,s.jsx)(n.p,{children:"重启服务，然后浏览器访问下试试："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"api 接口和静态资源的访问都支持了，接下来就分别实现下 5 种前后端 http 数据传输的方式吧。"}),"\n",(0,s.jsxs)(n.h2,{id:"url-param-1",children:["url param",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#url-param-1",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"url param 是 url 中的参数，Nest 里通过 :参数名 的方式来声明（比如下面的 :id），然后通过 @Param(参数名) 的装饰器取出来注入到 controller："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Controller('api/person')\nexport class PersonController {\n  @Get(':id')\n  urlParam(@Param('id') id: string) {\n    return `received: id=${id}`;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"@Controller('api/person') 的路由和 @Get(':id') 的路由会拼到一起，也就是只有 /api/person/xxx 的 get 请求才会走到这个方法。"}),"\n",(0,s.jsx)(n.p,{children:"前端代码就是一个 get 方法，参数放在 url 里："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"><\/script>\n</head>\n<body>\n    <script>\n        async function urlParam() {\n            const res = await axios.get(\'/api/person/1\');\n            console.log(res);            \n        }\n        urlParam();\n   <\/script>\n</body>\n'})}),"\n",(0,s.jsx)(n.p,{children:"启动服务，在浏览器访问下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"控制台打印了服务端返回的消息，证明服务端拿到了通过 url param 传递的数据。"}),"\n",(0,s.jsx)(n.p,{children:"通过 url 传递数据的方式除了 url param 还有 query："}),"\n",(0,s.jsxs)(n.h2,{id:"query-1",children:["query",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#query-1",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"query 是 url 中 ? 后的字符串，需要做 url encode。"}),"\n",(0,s.jsx)(n.p,{children:"在 Nest 里，通过 @Query 装饰器来取："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Controller('api/person')\nexport class PersonController {\n  @Get('find')\n  query(@Query('name') name: string, @Query('age') age: number) {\n    return `received: name=${name},age=${age}`;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"注意，这个 find 的路由要放到 :id 的路由前面，因为 Nest 是从上往下匹配的，如果放在后面，那就匹配到 :id 的路由了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"前端代码同样是通过 axios 发送一个 get 请求："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <script src=\"https://unpkg.com/axios@0.24.0/dist/axios.min.js\"><\/script>\n</head>\n<body>\n    <script>\n        async function query() {\n            const res = await axios.get('/api/person/find', {\n                params: {\n                    name: '光',\n                    age: 20\n                }\n            });\n            console.log(res);            \n        }\n        query();\n   <\/script>\n</body>\n</html>\n"})}),"\n",(0,s.jsx)(n.p,{children:"参数通过 params 指定，axios 会做 url encode，不需要自己做。"}),"\n",(0,s.jsx)(n.p,{children:"然后测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"服务端成功接受了我们通过 query 传递的数据。"}),"\n",(0,s.jsx)(n.p,{children:"上面两种（url param、query）是通过 url 传递数据的方式，下面 3 种是通过 body 传递数据。"}),"\n",(0,s.jsxs)(n.h2,{id:"form-urlencoded-1",children:["form urlencoded",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#form-urlencoded-1",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"form urlencoded 是通过 body 传输数据，其实是把 query 字符串放在了 body 里，所以需要做 url encode："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"用 Nest 接收的话，使用 @Body 装饰器，Nest 会解析请求体，然后注入到 dto 中。"}),"\n",(0,s.jsx)(n.p,{children:"dto 是 data transfer object，就是用于封装传输的数据的对象："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export class CreatePersonDto {\n    name: string;\n    age: number;\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { CreatePersonDto } from './dto/create-person.dto';\n\n@Controller('api/person')\nexport class PersonController {\n  @Post()\n  body(@Body() createPersonDto: CreatePersonDto) {\n    return `received: ${JSON.stringify(createPersonDto)}`\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["前端代码使用 post 方式请求，指定 content type 为 ",(0,s.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),"，用 qs 做下 url encode："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <script src=\"https://unpkg.com/axios@0.24.0/dist/axios.min.js\"><\/script>\n    <script src=\"https://unpkg.com/qs@6.10.2/dist/qs.js\"><\/script>\n</head>\n<body>\n    <script>\n        async function formUrlEncoded() {\n            const res = await axios.post('/api/person', Qs.stringify({\n                name: '光',\n                age: 20\n            }), {\n                headers: { 'content-type': 'application/x-www-form-urlencoded' }\n            });\n            console.log(res);  \n        }\n\n        formUrlEncoded();\n    <\/script>\n</body>\n</html>\n"})}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"服务端成功的接收到了数据。"}),"\n",(0,s.jsx)(n.p,{children:"其实比起 form urlencoded，使用 json 来传输更常用一些："}),"\n",(0,s.jsxs)(n.h2,{id:"json-1",children:["json",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#json-1",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["json 需要指定 content-type 为 ",(0,s.jsx)(n.code,{children:"application/json"}),"，内容会以 JSON 的方式传输："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"后端代码同样使用 @Body 来接收，不需要做啥变动。form urlencoded 和 json 都是从 body 取值，Nest 内部会根据 content type 做区分，使用不同的解析方式。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"@Controller('api/person')\nexport class PersonController {\n  @Post()\n  body(@Body() createPersonDto: CreatePersonDto) {\n    return `received: ${JSON.stringify(createPersonDto)}`\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["前端代码使用 axios 发送 post 请求，默认传输 json 就会指定 content type 为 ",(0,s.jsx)(n.code,{children:"application/json"}),"，不需要手动指定："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <script src=\"https://unpkg.com/axios@0.24.0/dist/axios.min.js\"><\/script>\n</head>\n<body>\n    <script>\n        async function json() {\n            const res = await axios.post('/api/person', {\n                name: '光',\n                age: 20\n            });\n            console.log(res);     \n        }\n        json();\n    <\/script>\n</body>\n</html>\n"})}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"服务端成功接收到了通过 json 传递的数据！"}),"\n",(0,s.jsx)(n.p,{children:"json 和 form urlencoded 都不适合传递文件，想传输文件要用 form data："}),"\n",(0,s.jsxs)(n.h2,{id:"form-data-1",children:["form data",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#form-data-1",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"form data 是用 -------- 作为 boundary 分隔传输的内容的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Nest 解析 form data 使用 FilesInterceptor 的拦截器，用 @UseInterceptors 装饰器启用，然后通过 @UploadedFiles 来取。非文件的内容，同样是通过 @Body 来取。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { AnyFilesInterceptor } from '@nestjs/platform-express';\nimport { CreatePersonDto } from './dto/create-person.dto';\n\n@Controller('api/person')\nexport class PersonController {\n  @Post('file')\n  @UseInterceptors(AnyFilesInterceptor({\n      dest: 'uploads/'\n  }))\n  body2(@Body() createPersonDto: CreatePersonDto, @UploadedFiles() files: Array<Express.Multer.File>) {\n    console.log(files);\n    return `received: ${JSON.stringify(createPersonDto)}`\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这一步需要"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm i -D @types/multer\n"})}),"\n",(0,s.jsx)(n.p,{children:"引入相关类型声明。"}),"\n",(0,s.jsxs)(n.p,{children:["前端代码使用 axios 发送 post 请求，指定 content type 为 ",(0,s.jsx)(n.code,{children:"multipart/form-data"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <script src=\"https://unpkg.com/axios@0.24.0/dist/axios.min.js\"><\/script>\n</head>\n<body>\n    <input id=\"fileInput\" type=\"file\" multiple/>\n    <script>\n        const fileInput = document.querySelector('#fileInput');\n\n        async function formData() {\n            const data = new FormData();\n            data.set('name','光');\n            data.set('age', 20);\n            data.set('file1', fileInput.files[0]);\n            data.set('file2', fileInput.files[1]);\n\n            const res = await axios.post('/api/person/file', data, {\n                headers: { 'content-type': 'multipart/form-data' }\n            });\n            console.log(res);     \n        }\n\n        fileInput.onchange = formData;\n    <\/script>\n</body>\n</html>\n"})}),"\n",(0,s.jsx)(n.p,{children:"file input 指定 multiple 可以选择多个文件。"}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"服务端接收到了 name 和 age："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"去服务器控制台看下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，服务器成功的接收到了我们上传的文件。"}),"\n",(0,s.jsxs)(n.p,{children:["代码在",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/five-transmission-method",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"里，可以跑跑试试。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们用 axios 发送请求，使用 Nest 起后端服务，实现了 5 种 http/https 的数据传输方式："}),"\n",(0,s.jsx)(n.p,{children:"其中前两种是 url 中的："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"url param"}),"： url 中的参数，Nest 中使用 @Param 来取"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"query"}),"：url 中 ? 后的字符串，Nest 中使用 @Query 来取"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"后三种是 body 中的："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"form urlencoded"}),"： 类似 query 字符串，只不过是放在 body 中。Nest 中使用 @Body 来取，axios 中需要指定 content type 为 ",(0,s.jsx)(n.code,{children:"application/x-www-form-urlencoded"}),"，并且对数据用 qs 或者 query-string 库做 url encode"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"json"}),"： json 格式的数据。Nest 中使用 @Body 来取，axios 中不需要单独指定 content type，axios 内部会处理。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"form data"}),"：通过 ----- 作为 boundary 分隔的数据。主要用于传输文件，Nest 中要使用 FilesInterceptor 来处理其中的 binary 字段，用 @UseInterceptors 来启用，其余字段用 @Body 来取。axios 中需要指定 content type 为 ",(0,s.jsx)(n.code,{children:"multipart/form-data"}),"，并且用 FormData 对象来封装传输的内容。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这 5 种 http 的传输数据的方式覆盖了绝大多数开发场景，如果你想进阶全栈，理解这 5 种接口是首先要做到的。"})]})}function D(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(C,{...e})}):C(e)}let A=D;D.__RSPRESS_PAGE_META={},D.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F5.%205%20%E7%A7%8D%20HTTP%20%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F.md"]={toc:[{text:"url param",id:"url-param",depth:2},{text:"query",id:"query",depth:2},{text:"form-urlencoded",id:"form-urlencoded",depth:2},{text:"form-data",id:"form-data",depth:2},{text:"json",id:"json",depth:2},{text:"url param",id:"url-param-1",depth:2},{text:"query",id:"query-1",depth:2},{text:"form urlencoded",id:"form-urlencoded-1",depth:2},{text:"json",id:"json-1",depth:2},{text:"form data",id:"form-data-1",depth:2},{text:"总结",id:"总结",depth:2}],title:"5. 5 种 HTTP 数据传输方式",headingTitle:"5. 5 种 HTTP 数据传输方式",frontmatter:{}}}}]);