"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11526"],{452916:function(e,n,s){s.r(n),s.d(n,{default:()=>h});var t=s(552676),r=s(740453);let i=s.p+"static/image/b92ccf540f09935bf6b30d2c8102196d.7b85963b.webp",a=s.p+"static/image/b556c42076086a44cca19e7c9927a2db.50bf6100.webp",c=s.p+"static/image/e8f28059414d434a1af5fb05b6cbc754.36f9be7e.webp",o=s.p+"static/image/4382817bf36a7fb1312b2833f7c840d9.892978b2.webp",l=s.p+"static/image/ead488f7e56e1ad78e911d4611103348.a97a5ded.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",strong:"strong",img:"img",h2:"h2",h3:"h3",ol:"ol",li:"li"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"11具体实现提取-vue-文件中-ts-代码",children:["11.具体实现：提取 Vue 文件中 TS 代码",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11具体实现提取-vue-文件中-ts-代码",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["对于 React 技术栈的子应用项目，TypeScript parser 可以解析 TS(JX)、TSX(JSX) 等类型的代码文件，但对于 Vue 技术栈的子应用项目，如果不对 Vue 文件中的 TS 代码进行分析，就无法得到项目最全面、最准确的 API 调用信息，",(0,t.jsx)(n.code,{children:"因为 Vue 文件也可以从目标依赖导入 API 并调用"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"那么，有什么办法可以分析 Vue 中的 TS 代码呢？以下面 Vue 文件为例："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'<template>\n  <div class="page">\n    <div class="header">\n      <div class="title">\n        {{ $tr(\'title_sp_set\') }}\n      </div>\n      <div class="desc">\n        {{ $tr(\'b_basic_set_desc\') }}\n      </div>\n    </div>\n    <bn-tabs ref="tabs" :value="tab" @tab-click="handleClick">\n      <bn-tab-pane :label="$tr(\'m_bic_settings\')" name="sp" />\n      <bn-tab-pane :label="$tr(\'m_pri_settings\')" name="privacy" />\n      <bn-tab-pane name="chat">\n        <span id="bic-setings-tab-chat" slot="label">{{ $tr(\'m_chat_set\') }}</span>\n      </bn-tab-pane>\n      <bn-tab-pane :label="$tr(\'m_notif_settings\')" name="notification" />\n      <bn-tab-pane v-if="showSipTab" name="sip">\n        <span id="bic-setings-tab-sip" slot="label">{{ $tr(\'m_sip_set\') }}</span>\n      </bn-tab-pane>\n    </bn-tabs>\n    <router-view :can-edit-setting="canEditSetting" />\n  </div>\n</template>\n\n<script lang="ts">\nimport { Component, Vue, Watch } from \'vue-property-decorator\';\nimport { app } from \'framework\';\n\nconst onrnpStorageKey = \'basicSettingsskp\';\n\n@Component\nexport default class Index extends Vue {\n  private current = 0;\n  private showskp = false;\n\n  private get canEditSetting() {\n    return this.$acl.data(\'food_setting_edit_setting\');\n  }\n\n  private hideskp() {\n    this.showskp = false;\n    app.localStorage.set(onrnpStorageKey, false);\n  }\n\n  private handleClick(tab: string) {\n    this.$router.push(`/portal/settings/basic/${tab}`);\n  }\n\n  private mounted() {\n    const show = app.localStorage.get(onrnpStorageKey);\n    const showskp = show === null ? true : show;\n    setTimeout(() => {\n      this.showskp = showskp;\n    }, 1000);\n  }\n\n  private beforeDestroy() {\n    const mm = app.localStorage.get(onrnpStorageKey);\n  }\n}\n<\/script>\n\n<style lang="scss" scoped>\n.page {\n  background-color: #fff;\n  box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.12);\n  border-radius: 2px;\n  margin-top: 16px;\n}\n.header {\n  padding: 24px 24px 8px;\n}\n.title {\n  font-size: 22px;\n  color: $trext-primary;\n  font-weight: $bold;\n  margin-bottom: 6px;\n}\n</style>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Vue 文件是由三种类型代码组合而成的，那能不能把 ",(0,t.jsx)(n.code,{children:'<script lang="ts"><\/script>'})," 标签内的 TS 代码片段提取出来单独进行分析呢？答案是：",(0,t.jsx)(n.strong,{children:"可以"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["这一节课主要学习如何提取、解析 Vue 文件中的 TS 代码，属于分析范式中对 ",(0,t.jsx)(n.code,{children:"step3"})," 和 ",(0,t.jsx)(n.code,{children:"step4"})," 步骤的完善，需要大家弄清楚分析 Vue 中 TS 片段与直接分析 TS 代码文件两者的差异，在课程最后我们还会讲解文件解析异常，语法不规范等因素是如何影响分析数据准确性的。"]}),"\n",(0,t.jsxs)(n.h2,{id:"vuecompiler-dom-编译器",children:["@vue/compiler-dom 编译器",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vuecompiler-dom-编译器",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["我们先把上面的 Vue 示例代码放入 ",(0,t.jsx)(n.a,{href:"https://astexplorer.net/?spm=taofed.bloginfo.blog.3.3ba15ac8enL4hJ#/gist/d7f47e247dee746928a640fa5880715b/ed1350d7cf78a672df4da4a5d37ea06f32b235aa",target:"_blank",rel:"noopener noreferrer",children:"AST explorer"}),"，parser 选择 ",(0,t.jsx)(n.code,{children:"@vue/compiler-dom"}),"，观察一下右侧的 AST 结构：代码被拆解成 template、script 和 style 这三部分，并且通过 AST 节点属性可以获取到 script 标签内 TS 代码完整的字符串信息："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"（ps：上图中右侧蓝色框中的部分就是 Vue 中的 TS 代码字符串信息）"}),"\n",(0,t.jsxs)(n.p,{children:["言外之意，我们可以通过 ",(0,t.jsx)(n.code,{children:"@vue/compiler-dom"})," 这个 parser 来解析 Vue，获取其中的 TS 代码片段。"]}),"\n",(0,t.jsxs)(n.h2,{id:"parse-vue-逻辑实现",children:["Parse Vue 逻辑实现",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#parse-vue-逻辑实现",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["既然可以获取到 Vue 中的 TS 代码片段，那么自然可以分析这部分代码，我们可以实现一个名叫 ",(0,t.jsx)(n.code,{children:"parseVue"})," 的方法来解析 Vue 中的 TS，与 ",(0,t.jsx)(n.code,{children:"parseTS"})," 一样，返回 ",(0,t.jsx)(n.code,{children:"AST"}),"、",(0,t.jsx)(n.code,{children:"checker"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"具体包含 3 个步骤，提取 TS 片段、写入临时 TS 文件和解析临时 TS 文件，我们分别来说："}),"\n",(0,t.jsxs)(n.h3,{id:"1提取-ts-片段",children:["1.提取 TS 片段",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1提取-ts-片段",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["要提取 TS 代码片段，肯定要先找到 Vue 文件并获取其文件内容，",(0,t.jsx)(n.code,{children:"scanFileVue"})," 与 ",(0,t.jsx)(n.code,{children:"scanFileTs"})," 类似，用于扫描 Vue 文件，",(0,t.jsx)(n.code,{children:"getCode"})," 函数用于读取代码文件的字符串内容，这两个函数我们放在 ",(0,t.jsx)(n.code,{children:"file"})," 模块中实现，因为它们属于文件操作方面的辅助方法。"]}),"\n",(0,t.jsx)(n.p,{children:"file 模块中相关方法的实现如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// 扫描VUE文件\nexports.scanFileVue = function(scanPath) {\n    const entryFiles = glob.sync(path.join(process.cwd(), `${scanPath}/**/*.vue`));\n    // console.log(entryFiles);\n    return entryFiles;\n}\n\n// 获取代码文件内容\nexports.getCode = function(fileName) {\n    try{\n        const code = fs.readFileSync(fileName, 'utf-8');\n        // console.log(code);\n        return code;\n    }catch(e){\n        throw e;\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在 ",(0,t.jsx)(n.code,{children:"parse"})," 模块中实现 ",(0,t.jsx)(n.code,{children:"parseVue"})," 函数， 它会引入 file 模块的 ",(0,t.jsx)(n.code,{children:"getCode"})," 方法，获取 Vue 代码文件的字符串内容，然后调用 ",(0,t.jsx)(n.code,{children:"@vue/compiler-dom"})," 解析器的 parse 方法，将 Vue 代码解析为包含三部分代码片段的 AST，通过遍历它的 children 数组，找到其中的 script 片段，获取 content 属性，content 属性值就是 script 片段的代码字符串。"]}),"\n",(0,t.jsx)(n.p,{children:"另外我们需要获取 TS 代码片段在 Vue 代码文件中的代码行数据作来作为基准行，这是因为我们分析的是提取后的 TS 片段，在统计代码行信息时需要通过基准行来映射它在 Vue 文件中原本的代码行。"}),"\n",(0,t.jsx)(n.p,{children:"parse 模块中 parseVue 函数的实现如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const vueCompiler = require('@vue/compiler-dom');                  // Vue编译器\nconst tsCompiler = require('typescript');                          // TS编译器\nconst { getCode } = require(path.join(__dirname, './file'));       // 文件操作\n\n// 解析vue文件中的ts script片段，解析获取ast，checker\nexports.parseVue = function(fileName) {\n    // 获取vue代码\n    const vueCode = getCode(fileName);\n    // 解析vue代码\n    const result = vueCompiler.parse(vueCode);\n    const children = result.children;\n    // 获取script片段\n    let tsCode = '';\n    let baseLine = 0;\n    children.forEach(element => {\n      if (element.tag == 'script') {\n        tsCode = element.children[0].content;\n        baseLine = element.loc.start.line - 1;\n      }\n    });\n    console.log(tsCode);\n    console.log(baseLine);\n}\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"2写入临时-ts-文件",children:["2.写入临时 TS 文件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2写入临时-ts-文件",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"因为 TypeScript parser 在创建 Program 时需要传入 TS 文件的路径作为参数 ，所以我们需要把第一步提取出来的 TS 代码字符串流写入一些临时 TS 文件中，在完成代码分析后，将这些临时文件删除即可。"}),"\n",(0,t.jsx)(n.p,{children:"file 模块中相关方法的实现如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// 将TS片段写入TS文件\nexports.writeTsFile = function(content, fileName) {\n    try{\n        fs.writeFileSync(path.join(process.cwd(),`${fileName}.ts`), content, 'utf8');\n    }catch(e){\n        throw e;\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"writeTsFile"})," 函数用于将指定字符串写入特定路径下的 TS 文件中。"]}),"\n",(0,t.jsxs)(n.p,{children:["在 constant 模块中定义临时目录文件名常量如下所示。其中，",(0,t.jsx)(n.code,{children:"VUETEMPTSDIR"})," 表示临时文件的暂存目录配置。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// vue TS 片段提取后写入临时文件所在的暂存目录\nexports.VUETEMPTSDIR = 'vue_temp_ts_dir';\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后，我们完善一下 parseVue 函数："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const md5 = require('js-md5');                                                        // md5加密\nconst vueCompiler = require('@vue/compiler-dom');                           // Vue编译器\nconst tsCompiler = require('typescript');                                   // TS编译器\nconst { getCode, writeTsFile } = require(path.join(__dirname, './file'));   // 文件工具\nconst { VUETEMPTSDIR } = require(path.join(__dirname, './constant'));       // 常量模块\n\n// 解析vue文件中的ts script片段，解析获取ast，checker\nexports.parseVue = function(fileName) {\n    // 获取vue代码\n    const vueCode = getCode(fileName);\n    // 解析vue代码\n    const result = vueCompiler.parse(vueCode);\n    const children = result.children;\n    // 获取 TS 片段\n    let tsCode = '';\n    let baseLine = 0;\n    children.forEach(element => {\n      if (element.tag == 'script') {\n        tsCode = element.children[0].content;\n        baseLine = element.loc.start.line - 1;\n      }\n    });\n    // console.log(tsCode);\n    // console.log(baseLine);\n    const ts_hash_name = md5(fileName);\n    // 将ts片段写入临时目录下的ts文件中\n    writeTsFile(tsCode, `${VUETEMPTSDIR}/${ts_hash_name}`);\n    const vue_temp_ts_name = path.join(process.cwd(), `${VUETEMPTSDIR}/${ts_hash_name}.ts`);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里通过 ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/js-md5",target:"_blank",rel:"noopener noreferrer",children:"js-md5"})," 对 Vue 文件的完整路径字符串进行单向加密处理，生成唯一 hash 串后，将这个 hash 串作为 TS 片段写入临时文件时的文件名。这样做一方面可以防止文件出现重名，另一方面可以保证所有从 Vue 文件提取出来的 TS 片段都可以唯一映射到提取它的 Vue 文件。"]}),"\n",(0,t.jsx)(n.p,{children:"下图是在分析过程中临时生成的 TS 文件列表示例："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsxs)(n.h3,{id:"3解析临时-ts-文件",children:["3.解析临时 TS 文件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3解析临时-ts-文件",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"最后这一步与 parseTS 基本一致，只不过需要多传递一个 baseLine 的基准行信息，原因我们在上面已经解释过了。"}),"\n",(0,t.jsxs)(n.p,{children:["最终，",(0,t.jsx)(n.code,{children:"parseVue"})," 函数完整的代码实现如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const path = require('path');                                               // 路径操作\nconst md5 = require('js-md5');                                              // md5加密\nconst vueCompiler = require('@vue/compiler-dom');                           // Vue编译器\nconst tsCompiler = require('typescript');                                   // TS编译器\nconst { getCode, writeTsFile } = require(path.join(__dirname, './file'));   // 文件工具\nconst { VUETEMPTSDIR } = require(path.join(__dirname, './constant'));       // 常量模块\n\n// 解析vue文件中的ts script片段，解析获取ast，checker\nexports.parseVue = function(fileName) {\n    // 获取vue代码\n    const vueCode = getCode(fileName);\n    // 解析vue代码\n    const result = vueCompiler.parse(vueCode);\n    const children = result.children;\n    // 获取script片段\n    let tsCode = '';\n    let baseLine = 0;\n    children.forEach(element => {\n      if (element.tag == 'script') {\n        tsCode = element.children[0].content;\n        baseLine = element.loc.start.line - 1;\n      }\n    });\n    // console.log(tsCode);\n    // console.log(baseLine);\n    const ts_hash_name = md5(fileName);\n    // 将ts片段写入临时目录下的ts文件中\n    writeTsFile(tsCode, `${VUETEMPTSDIR}/${ts_hash_name}`);\n    const vue_temp_ts_name = path.join(process.cwd(), `${VUETEMPTSDIR}/${ts_hash_name}.ts`);\n    // 将ts代码转化为AST\n    const program = tsCompiler.createProgram([vue_temp_ts_name], {})\n    const ast = program.getSourceFile(vue_temp_ts_name);\n    const checker = program.getTypeChecker();\n    // console.log(ast);\n    return { ast, checker, baseLine };\n}\n\n// 解析ts文件代码，获取ast，checker\nexports.parseTs = function(fileName) {\n    // 将ts代码转化为AST\n    const program = tsCompiler.createProgram([fileName], {})\n    const ast = program.getSourceFile(fileName);\n    const checker = program.getTypeChecker();\n    // console.log(ast);\n    return { ast, checker };\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"有了 parseVue 函数，我们就可以像解析 TS 文件那样解析 Vue 中的 TS 代码，进而对其进行调用分析了。"}),"\n",(0,t.jsxs)(n.h2,{id:"代码文件解析异常",children:["代码文件解析异常",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码文件解析异常",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"影响代码分析准确性的因素会有很多，其中最直接的莫过于解析异常了，试想一下如果一个文件在 parse 阶段就出错了，AST 都没法正常获取，那么就没法进行分析了。举个例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'<template>\n  <div class="page">\n    <div class="title">\n      {{ \'title_settings\' }}\n    </div>\n\n    <div v-if="showAntest" class="onboarding">\n      <div class="icemecontent">\n        <div class="icemetarget">\n          <div class="icemetarget-text">\n            {{ currentAntest.text }}\n          </div>\n        </div>\n        <div class="icemetips">\n          <div class="icemetips-content">\n            {{ currentAntest.content }}\n          </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script lang="ts">\nimport { Component, Vue, Watch } from \'vue-property-decorator\';\nimport { app } from \'framework\';\n\nconst testStorageKey = \'basicSettings\';\n\n@Component\nexport default class Index extends Vue {\n  private title_settings = 10;\n  private showAntest = false;\n\n  private get currentAntest() {\n    return {\n      text: \'222\',\n      content: \'iceman\'\n    };\n  }\n\n  private beforeDestroy() {\n    const mm = app.cookie.get(testStorageKey);\n    document.documentElement.style.overflow = \'\';\n  }\n}\n<\/script>\n\n<style lang="scss" scoped>\n.page {\n  background-color: #fff;\n  box-shadow: 0 1px 4px 0 rgba(0, 0, 0, 0.12);\n  border-radius: 2px;\n  margin-top: 16px;\n}\n</style>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["上面的 Vue 文件在 parse 时会报错：",(0,t.jsx)(n.code,{children:"SyntaxError: Element is missing end tag. at createCompilerError"}),"，原因是 ",(0,t.jsx)(n.code,{children:"template"})," 中存在 ",(0,t.jsx)(n.code,{children:"div"})," 未闭合。大家可能会觉的这种异常文件应该很少，但实际情况是项目在迭代过程中，一些废弃的文件可能会一直残留在项目中，因为它们不参与构建，所以有问题也不会被发现。另外，还有一些同学对于小的变更会直接修改代码文件，不进行本地调试，这也可能导致有问题的代码文件被提交到仓库中。"]}),"\n",(0,t.jsx)(n.p,{children:"我们无法保证需要分析的 Vue、TS 文件一定是规范的，所以在分析过程中可以统计解析失败的文件及错误信息，将这些信息输出到代码分析报告中，推动开发者去修复文件，提升分析准确性。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"_scanCode"})," 函数在解析代码文件的外层逻辑会添加 try catch 来捕获可能出现的解析错误，在捕获到错误后将错误信息添加到 codeAnalysis 实例的 ",(0,t.jsx)(n.code,{children:"parseErrorInfos"})," 属性中。相关代码如下，完整代码参考 ",(0,t.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"lib/analysis.js"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// 扫描文件，分析代码\n  _scanCode(scanSource, type) {\n    let entrys = this._scanFiles(scanSource, type);\n    // console.log(entrys);\n    entrys.forEach((item)=>{\n      const parseFiles = item.parse;\n      if(parseFiles.length>0){\n        parseFiles.forEach((element, eIndex) => {\n          const showPath = item.name + '&' + item.show[eIndex];\n          try {\n            if(type === CODEFILETYPE.VUE){\n              const { ast, checker, baseLine } = parseVue(element);                                               // 解析vue文件中的ts script片段,将其转化为AST\n              const importItems = this._findImportItems(ast, showPath, baseLine);                                 // 从import语句中获取导入的需要分析的目标API\n              // console.log(importItems);\n              if(Object.keys(importItems).length>0 || this._browserApis.length>0){\n                this._dealAST(importItems, ast, checker, showPath, item.name, item.httpRepo, baseLine);           // 递归分析AST，统计相关信息\n              }\n            }else if(type === CODEFILETYPE.TS){\n              const { ast, checker } = parseTs(element);                                                          // 解析ts文件代码,将其转化为AST\n              const importItems = this._findImportItems(ast, showPath);                                           // 从import语句中获取导入的需要分析的目标API\n              // console.log(importItems);\n              if(Object.keys(importItems).length>0 || this._browserApis.length>0){\n                this._dealAST(importItems, ast, checker, showPath, item.name, item.httpRepo);                     // 递归分析AST，统计相关信息\n              }\n            }\n          } catch (e) {\n            const info = {\n              projectName: item.name,\n              httpRepo: item.httpRepo + item.show[eIndex],\n              file: item.show[eIndex],\n              stack: e.stack\n            }\n            this.parseErrorInfos.push(info);\n            this.addDiagnosisInfo(info);\n          }\n          processLog.stdout(chalk.green(`\\n${item.name} ${type}分析进度: ${eIndex+1}/${parseFiles.length}`));\n        });\n      }\n    })\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"规范代码语法",children:["规范代码语法",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#规范代码语法",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"除了代码文件解析异常，我们还需要注意语法错误对于分析准确性的影响。举个例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// 错误语法，或无意义代码\nconst env } 'iceman';\nif(d){\n"})}),"\n",(0,t.jsxs)(n.p,{children:["将上面的代码放入 ",(0,t.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/MYewdgzgLgBApmAbjAvjA5AS2HAtgQzHQG4AoTAMwAoATASgG8g",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"}),"，发现它可以正常解析成 AST，但这些语句是存在问题的，并没有分析意义，甚至会对正常的分析造成干扰。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["所以在实际应用中，建议使用者在代码分析前进行 ",(0,t.jsx)(n.code,{children:"ESLint"})," 语法检查，减少不必要的错误，提升分析准确性。"]}),"\n",(0,t.jsxs)(n.h2,{id:"配置解析-vue",children:["配置解析 Vue",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置解析-vue",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["配置文件中的 ",(0,t.jsx)(n.code,{children:"isScanVue"})," 配置项用来控制是否开启 Vue 文件的扫描分析流程，对于有 Vue 文件的项目开启即可，下面是入口函数 analysis 关于分析 Vue 文件的逻辑演示，完整代码参考 ",(0,t.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"lib/analysis.js"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const { CODEFILETYPE } = require(path.join(__dirname, './constant'));   // 常量模块\n\n// 代码分析基础类\nclass CodeAnalysis {\n    // 构造函数\n    constructor(options) {\n        ......\n        // 私有属性\n        this._scanSource = options.scanSource;           // 扫描源配置信息               \n        this._isScanVue = options.isScanVue || false;    // 是否扫描Vue配置    \n        ......  \n    }\n    // 入口函数\n    analysis() {\n        ......\n        // 扫描分析Vue\n        if(this._isScanVue){      // 开启配置则进行分析\n          this._scanCode(this._scanSource, CODEFILETYPE.VUE);\n        }\n        // 扫描分析TS\n        this._scanCode(this._scanSource, CODEFILETYPE.TS);\n        ......\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这一小节我们学习了如何提取解析 Vue 文件中的 TS 代码片段，需要大家掌握以下知识点："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["通过 ",(0,t.jsx)(n.code,{children:"@vue/compiler-dom"})," 这个 parser 可以将 Vue 解析为包含三种代码类型的 AST，通过节点属性可以获取其中的 TS 代码片段字符串信息。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["解析 TS 需要创建 program，所以需要把提取出来的 TS 代码字符串流写入一些临时 TS 文件中，通过 ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/js-md5",target:"_blank",rel:"noopener noreferrer",children:"js-md5"})," 生成的文件名 hash 名可用于映射提取 TS 片段的原 Vue 文件。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"代码文件解析异常，待分析代码文件中存在语法问题等因素都会影响代码分析的准确性。"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"学习完本节课程，对于 Vue 文件中的 TS，我们也可以分析其最真实的 API 调用情况了。"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}let h=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F11.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%8F%90%E5%8F%96%20Vue%20%E6%96%87%E4%BB%B6%E4%B8%AD%20TS%20%E4%BB%A3%E7%A0%81.md"]={toc:[{text:"@vue/compiler-dom 编译器",id:"vuecompiler-dom-编译器",depth:2},{text:"Parse Vue 逻辑实现",id:"parse-vue-逻辑实现",depth:2},{text:"1.提取 TS 片段",id:"1提取-ts-片段",depth:3},{text:"2.写入临时 TS 文件",id:"2写入临时-ts-文件",depth:3},{text:"3.解析临时 TS 文件",id:"3解析临时-ts-文件",depth:3},{text:"代码文件解析异常",id:"代码文件解析异常",depth:2},{text:"规范代码语法",id:"规范代码语法",depth:2},{text:"配置解析 Vue",id:"配置解析-vue",depth:2},{text:"小结",id:"小结",depth:2}],title:"11.具体实现：提取 Vue 文件中 TS 代码",headingTitle:"11.具体实现：提取 Vue 文件中 TS 代码",frontmatter:{}}}}]);