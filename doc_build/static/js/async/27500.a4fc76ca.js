"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["27500"],{884028:function(n,e,s){s.r(e),s.d(e,{default:()=>a});var i=s(552676),r=s(740453);let l=s.p+"static/image/d8c0c51a272c50260c365d0ad4bcf1df.6cb371a1.webp",c=s.p+"static/image/6c72cfa3e48a2d2e9578c3fb2c2ea8bb.09158cb4.webp";function d(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",img:"img",pre:"pre",code:"code",ul:"ul",li:"li",ol:"ol",h4:"h4",br:"br"},(0,r.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"4-基础3基础组件自定义组件全局组件",children:["4 基础3：基础组件、自定义组件、全局组件",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-基础3基础组件自定义组件全局组件",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"程序有问题时不要担心。如果所有东西都没问题，你就失业了。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"本章主要讲解组件与组件的使用。"}),"\n",(0,i.jsxs)(e.h2,{id:"什么是组件",children:["什么是组件？",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是组件",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"开篇我们先简单聊一下前端组件化。什么是组件化？在前端界，特别是现在 React，Vue，Angular 几大流行开发框架的盛行的时代下，已经把组件化的设计思想推向了一个新的高度了，出现了框架与组件共同繁荣的景象。"}),"\n",(0,i.jsx)(e.p,{children:"组件简单的来说就是可实现独立的功能的单一整体代码片段，无论把这个片段放在哪里，它还是保持着原有的功能和样式，从而可以实现复用，这种整体独立化的设计思想就是组件化，而这样设计出来的单一整体代码片段叫做组件。这样的设计可以非常灵活的使用在项目中，项目设计更具系统性，从而提高了项目管理开发效率。"}),"\n",(0,i.jsx)(e.p,{children:"如果上面说的比较拗口，来点简单的。比如一座房子，把房子看成一个独立的整体由屋顶、窗户、门，墙等组成。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:c,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"用代码来表示就是："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:"<template>\n    \x3c!-- 这是一个房子 --\x3e\n    <view>\n        \x3c!-- 屋顶 --\x3e\n        <roof></roof>\n        \x3c!-- 墙 --\x3e\n        <wall></wall>\n        \x3c!-- 窗户 --\x3e\n        <window></window>\n        \x3c!-- 门 --\x3e\n        <door></door>\n    </view>\n</template>\n"})}),"\n",(0,i.jsx)(e.p,{children:"那么换成一个页面呢？一个完整的页面由页头，内容，页脚等组成："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:"<template>\n    <view>\n        \x3c!-- 页头 --\x3e\n        <page-header></page-header>\n        \x3c!-- 内容 --\x3e\n        <content></content>\n        \x3c!-- 页脚 --\x3e\n        <pager-footer></pager-footer>\n    </view>\n</template>\n"})}),"\n",(0,i.jsx)(e.p,{children:"那我们在开发页面的时候，头部和尾部都是固定不变的，只要内容更改就行。在开发框架中，页面其实也是作为组件化的一部分，但是我们组件更多关注的是页面的每个部件，比如头部，内容区，弹出框甚至确认按钮都可以作为一个组件，每个组件有独立的HTML、css、js代码。"}),"\n",(0,i.jsxs)(e.h2,{id:"基础组件",children:["基础组件",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#基础组件",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"Uniapp 根据多端的特性以 Vue 语法糖 + 小程序的 API 打造了一大批组件，这些组件在开发的时候以 HBuliderX 为 IDE，生产的时候把那些代码编译转换为各个平台特性的语法与 API。"}),"\n",(0,i.jsx)(e.p,{children:"Uniapp 框架根据组件的设计思想为我们设计提供了一系列的基础组件，我们可以通过组合这些基础组件进行快速开发。每一个基础组件都独立定义了样式与功能，\n这些基础组件中比如 button 组件，你可以设置按钮的大小，文字样式，里面的回调时机，这个按钮组件具有独立的并且有完整的多样化功能，相当于我们以参数的形式去定义这个按钮。"}),"\n",(0,i.jsx)(e.p,{children:"Uniapp 基础组件分为以下八大类："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"视图容器（View Container）"}),"\n",(0,i.jsx)(e.li,{children:"基础内容（Basic Content）"}),"\n",(0,i.jsx)(e.li,{children:"表单组件（Form）"}),"\n",(0,i.jsx)(e.li,{children:"导航（Navigation）"}),"\n",(0,i.jsx)(e.li,{children:"媒体组件（Media）"}),"\n",(0,i.jsx)(e.li,{children:"地图（Map）"}),"\n",(0,i.jsx)(e.li,{children:"画布（Canvas）"}),"\n",(0,i.jsx)(e.li,{children:"webview（Web-view）"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"这些基础的组件可以让我们快速的开发项目，由于每个人都处理的业务功能都不一样，就需要根据自己的业务情况去定制一个组件。如果 Uniapp 基础组件没有你想要的组件，而你又需要一个代码片段来实现功能的复用，那么你可以根据组件规范来注册属于自己自定义的组件。"}),"\n",(0,i.jsxs)(e.h2,{id:"自定义组件",children:["自定义组件",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义组件",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"在数据绑定的三大框架 Angular、React、Vue 中，所有的元素都可以细分为一个组件，甚至是一个页面。这个组件可以重复的复用，组件的使用也造就了当今的前端的繁华的原因之一，当然现在使用的 Uniapp 也不例外，合成小程序，weex，h5 等的共有特性。"}),"\n",(0,i.jsx)(e.p,{children:"一个组件由三大部分组成：template 模板，js 数据交互和 css 样式层："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<template>\n    <view class="content">\n       <image class="logo" src="/static/logo.png"></image>\n       <button @tap="getMsg">{{title}}</button>\n    </view>\n</template>\n\n<script>\n    export default {\n        // props 是从父级（引用当前组件）的变量占位，在当前组件下给这些变量一个初始化值（initValue）\n        props:{\n            title: {\n                type: String,\n                default: \'\'\n            },\n            list:{\n                type: Array,\n                default () {  // 这里返回值需要是一个函数\n                    return []\n                }\n            }\n        },\n        data() {\n            return {\n                title: \'Hello\'\n            }\n        },\n        created() {\n\n        },\n        methods: {\n            getMsg () {\n                console.log(\'I am demo\')\n                this.$emit(\'getMsg\', this)\n            }\n        }\n    }\n<\/script>\n\n<style lang="scss">\n    ...\n</style>\n'})}),"\n",(0,i.jsxs)(e.p,{children:["可以看到上面主要由三个主要元素组成 ",(0,i.jsx)(e.code,{children:"template"})," ， ",(0,i.jsx)(e.code,{children:"script"})," ，",(0,i.jsx)(e.code,{children:"style"}),"。"]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["html 部分由 ",(0,i.jsx)(e.code,{children:"template"})," 标签元素闭合组成，其余 ",(0,i.jsx)(e.code,{children:"view"}),", ",(0,i.jsx)(e.code,{children:"image"})," 元素遵循",(0,i.jsx)(e.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/component/",target:"_blank",rel:"noopener noreferrer",children:"小程序的元素"}),"定义组成，需要注意的是组件元素必须有一个根元素（root element）包裹，不然会报错编译失败。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"script"})," 部分由 ES6 的 ",(0,i.jsx)(e.code,{children:"export default"})," 导出整个页面模块，可以在其他页面引入该组件。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"props"})," 是申明需要从父组件接收的数据"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"data"})," 数据部分是一个函数，返回该页面实例下的所有数据引用，data 必须声明为返回一个初始数据对象的函数；否则该组件关闭时，数据不会自动销毁，再次打开该组件时，会显示上次数据。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"//正确用法，使用函数返回对象\ndata() {\n    return {\n        title: 'Hello'\n    }\n}\n\n//错误写法，会导致再次打开页面时，显示上次数据\ndata: {\n    title: 'Hello'\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"props"})," 中声明的数据与组件 ",(0,i.jsx)(e.code,{children:"data"})," 函数 ",(0,i.jsx)(e.code,{children:"return"})," 的数据主要区别就是 ",(0,i.jsx)(e.code,{children:"props"})," 的来自父级，而 ",(0,i.jsx)(e.code,{children:"data"})," 中的是组件自己的数据，作用域是组件本身，这两种数据都可以在模板 ",(0,i.jsx)(e.code,{children:"template"})," 及计算属性 ",(0,i.jsx)(e.code,{children:"computed"})," 和方法 ",(0,i.jsx)(e.code,{children:"methods"})," 中使用。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"created"})," 组件生命周期函数, 还有 ",(0,i.jsx)(e.code,{children:"beforeCreate"})," , ",(0,i.jsx)(e.code,{children:"beforeMount"})," 等生命周期与 Vue 标准组件的生命周期相同，但没有页面级的 onLoad 等生命周期。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"methods"})," 是事件处理函数对象，包含整个页面交互及逻辑处理的函数。在上面例子中我定义了一个 tap 事件在 methods 中，当用户触碰（tap）的时候就会打印这个文字。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"this.$emit('getMsg', this)"})," 这一句是该组件通过 this.$emit() 派发事件，引用这个组件的地方可以利用 $on 对事件进行监听，实现参数的传递与事件向上传递，当前的 this 指的是该组件本身，指针指向当前组件。通俗的话就是，我传递一个叫 ",(0,i.jsx)(e.code,{children:"getMsg"})," 事件并当前所有的参数内容出去，你只要在外面接收就可以了。"]}),"\n",(0,i.jsxs)(e.ol,{start:"3",children:["\n",(0,i.jsxs)(e.li,{children:["css 部分由 ",(0,i.jsx)(e.code,{children:"style"})," 标签组成，这里面样式只作用当前的元素。style 支持 css3 标准，不用再写多余的 hack，比如 -webkit- 前缀等，已经由整个框架完成 hask 编译, 可以看到 style 标签有个 ",(0,i.jsx)(e.code,{children:'lang="scss"'}),",说明里面的样式表可以直接以 ",(0,i.jsx)(e.a,{href:"https://www.sass.hk/",target:"_blank",rel:"noopener noreferrer",children:"scss"})," 形式书写，当然 lang 的属性值还可以是 ",(0,i.jsx)(e.a,{href:"http://lesscss.cn/",target:"_blank",rel:"noopener noreferrer",children:"less"}),",",(0,i.jsx)(e.a,{href:"https://stylus-lang.net/",target:"_blank",rel:"noopener noreferrer",children:"stylus"}),"，找到合适自己的 css 预编译期可以事半功倍。"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"父子组件（组件引用者与组件）的关系可以总结为 props 向下传递，事件向上传递。父组件通过 props 给子组件下发数据，子组件通过事件给父组件发送消息。"}),"\n",(0,i.jsx)(e.p,{children:"注意："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"所有组件与属性名都是小写，单词之间以连字符-连接。"}),"\n",(0,i.jsxs)(e.li,{children:["根节点为 ",(0,i.jsx)(e.code,{children:"<template>"}),"，这个 ",(0,i.jsx)(e.code,{children:"<template>"})," 下只能有一个根 ",(0,i.jsx)(e.code,{children:"<view>"})," 组件。"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Uniapp 并没有限制使用 HTML 标签，如果开发者写了 div 等标签，在编译到非 H5 平台时也会被编译器转换为 view 标签，类似的还有 span 转 text 、a 转 navigator 等，包括 css 里的元素选择器也会转。但为了管理方便、策略统一，新写代码时仍然建议使用 view 等组件。"}),"\n",(0,i.jsxs)(e.h2,{id:"自定义完成一个商品卡片组件",children:["自定义完成一个商品卡片组件",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义完成一个商品卡片组件",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"一个商品信息由商品图片，商品名称，商品价格，商品参考价组成。"}),"\n",(0,i.jsx)(e.p,{children:"实现步骤："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"建立组件模板。"}),"\n",(0,i.jsx)(e.li,{children:"准备组件的数据输入，定义 props 里面的数据、类型。"}),"\n",(0,i.jsx)(e.li,{children:"准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。"}),"\n",(0,i.jsx)(e.li,{children:"封装完成，进行命名调用。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"在 components 文件夹创建 song.vue 文件:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<template>\n    <view class="song">\n        <image class="img" :src="imgSrc"></image>\n        <view class="desc">{{ title }}</view>\n        <view class="flex-box">\n            <view class="price">￥{{price}}</view>\n            <view class="market-price">{{marketPrice}}</view>\n        </view>\n    </view>\n</template>\n\n<script>\nexport default {\n    // 从父组件传值的\n    props:{\n        imgSrc: {\n            type: String,\n            default: \'\'\n        },\n        title: {\n            type: String,\n            default: \'\'\n        },\n        price: {\n            type: String,\n            default: \'\'\n        },\n        marketPrice: {\n            type: String,\n            default: \'\'\n        },\n    },\n    data() {\n        return {\n            \n        }\n    },\n    methods:{\n\n    }\n}\n<\/script>\n<style lang="scss" scoped>\n.song {\n    position: relative;\n    width: 342rpx;\n    height: 502rpx;\n    line-height: 34rpx;\n    color:#333;\n    background:#fff;\n    border-radius: 10rpx;\n    overflow:hidden;\n    font-size: 26rpx;\n    .img {\n        display: block;\n        width: 342rpx;\n        height: 342rpx;\n        margin-bottom: 24rpx;\n        background: #eee;\n    }\n    .desc {\n        height: 64rpx;\n        margin-top: 12rpx;\n        line-height: 30rpx;\n    }\n    .price{\n        color:#ff5000;\n    }\n    .market-price{\n        padding-left: 10px;\n        font-size: 24rpx;\n        color: #979797;\n        text-decoration: line-through;\n    }\n}\n</style>\n\n'})}),"\n",(0,i.jsx)(e.p,{children:"上面的组件的图片路径、商品名称、价格、市场价都经过 props 定义，只要在引用这个组件的页面里传值就行。"}),"\n",(0,i.jsx)(e.p,{children:"这样我们在首页 /pages/index.vue 就可以引用这个组件了"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:"<template>\n    <view class=\"content\">\n        <song \n            :imgSrc=\"song.img\"\n            :title=\"song.title\"\n            :price=\"song.price\"\n            :marketPrice=\"song.marketPrice\"\n        />\n    </view>\n</template>\n\n<script>\n    import song from '../../components/song.vue'\n    export default {\n        components: {\n            song\n        },\n        data() {\n            return {\n                song: {\n                    img: 'http://gw.alicdn.com/bao/uploaded/i3/1917047079/O1CN01VlEDD522AEJzpw3A5_!!2-item_pic.png_360x10000.jpg',\n                    title: 'Apple/苹果 iPhone 11 Pro',\n                    price: '8699.00',\n                    marketPrice: '￥8699.00',\n                }\n            }\n        },\n        onLoad() {\n        },\n        methods: {\n            \n        }\n    }\n<\/script>\n\n<style>\npage {\n    background: #f2f2f2;\n}\n</style>\n"})}),"\n",(0,i.jsx)(e.p,{children:"课程代码里面有列表数据循环，父子组件之间事件的传递的代码示例。"}),"\n",(0,i.jsxs)(e.h2,{id:"全局组件",children:["全局组件",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#全局组件",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["Uniapp 支持配置全局组件，需在 ",(0,i.jsx)(e.code,{children:"main.js"})," 里进行全局注册，注册后就可在所有页面里使用该组件。"]}),"\n",(0,i.jsxs)(e.h4,{id:"但是",children:["但是",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#但是",children:"#"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Vue.component 的第一个参数必须是静态的字符串。"}),"\n",(0,i.jsxs)(e.li,{children:["nvue 页面暂不支持全局组件",(0,i.jsx)(e.br,{}),"\n","(注：建议统一用按需页面引入组件)"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"main.js"}),"里进行全局导入和注册"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"import Vue from 'vue'\nimport pageHead from './components/page-head.vue'\nVue.component('page-head', pageHead)\n"})}),"\n",(0,i.jsx)(e.p,{children:"index.vue里可直接使用组件"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:"<template>\n  <view>\n    <page-head></page-head>\n  </view>\n</template>\n"})}),"\n",(0,i.jsxs)(e.h2,{id:"非h5端不支持列表",children:["非H5端不支持列表",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#非h5端不支持列表",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["Uniapp 只支持 Vue 单文件组件（ .vue 组件）。其他的诸如：动态组件，自定义 render 和 ",(0,i.jsx)(e.code,{children:'<script type="text/x-template">'})," 字符串模版等，在非 H5 端不支持。"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Slot（scoped 暂时还没做支持）"}),"\n",(0,i.jsx)(e.li,{children:"动态组件"}),"\n",(0,i.jsx)(e.li,{children:"异步组件"}),"\n",(0,i.jsx)(e.li,{children:"inline-template"}),"\n",(0,i.jsx)(e.li,{children:"X-Templates"}),"\n",(0,i.jsx)(e.li,{children:"keep-alive"}),"\n",(0,i.jsx)(e.li,{children:"transition （可使用 animation 或 CSS 动画替代）"}),"\n",(0,i.jsxs)(e.li,{children:["老的非自定义组件编译模式不支持在组件引用时，在组件上定义 click 等原生事件、v-show（可用 v-if 代替）和 class style 等样式属性(例：",(0,i.jsx)(e.code,{children:'<card class="class-name"> </card>'})," 样式是不会生效的)。建议更新为自定义组件模式。"]}),"\n",(0,i.jsx)(e.li,{children:"老的非自定义组件编译模式组件里使用 slot 嵌套的其他组件时不支持 v-for。建议更新为自定义组件模式。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"注意"}),"\n",(0,i.jsxs)(e.p,{children:["在 Uniapp 中有些关键字做了保留，不可作为组件名，所以建议自定义组件时加上前缀，类似 ",(0,i.jsx)(e.code,{children:"xm-button"}),"。"]}),"\n",(0,i.jsxs)(e.h2,{id:"小结",children:["小结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"组件是可实现独立的功能的单一整体代码片段，无论把这个片段放在哪里，它还是保持着原有的功能和样式，从而可以实现复用，这种整体独立化的设计思想就是组件化，而这样设计出来的单一整体代码片段叫做组件；"}),"\n",(0,i.jsx)(e.li,{children:"如果框架的功能组件满足不了你，你就需要根据组件的规范自己定义一个组件；"}),"\n",(0,i.jsx)(e.li,{children:"全局组件可以挂在到 Vue 实例中，作用在每一个页面文件上；"}),"\n",(0,i.jsxs)(e.li,{children:["本章代码 ",(0,i.jsx)(e.a,{href:"https://github.com/front-end-class/uniapp-music-code/blob/master/uni-course-components.zip",target:"_blank",rel:"noopener noreferrer",children:"uni-course-components"})]}),"\n"]})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Uniapp%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6%2F4%20%E5%9F%BA%E7%A1%803%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E3%80%81%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6.md"]={toc:[{text:"什么是组件？",id:"什么是组件",depth:2},{text:"基础组件",id:"基础组件",depth:2},{text:"自定义组件",id:"自定义组件",depth:2},{text:"自定义完成一个商品卡片组件",id:"自定义完成一个商品卡片组件",depth:2},{text:"全局组件",id:"全局组件",depth:2},{text:"但是",id:"但是",depth:4},{text:"非H5端不支持列表",id:"非h5端不支持列表",depth:2},{text:"小结",id:"小结",depth:2}],title:"4 基础3：基础组件、自定义组件、全局组件",headingTitle:"4 基础3：基础组件、自定义组件、全局组件",frontmatter:{}}}}]);