"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["77891"],{395985:function(e,n,d){e.exports=d.p+"static/image/0d7fea06f78fff2c3fcab686b5346c1b.79a0f0d3.gif"},282364:function(e,n,d){e.exports=d.p+"static/image/11f2e098778c045f3d59aba0bd6724b3.ee434b8e.webp"},489785:function(e,n,d){e.exports=d.p+"static/image/308bf24753f991b17d501618b1c4edec.248fdc73.webp"},617095:function(e,n,d){e.exports=d.p+"static/image/882971f12e4a69e23db53c33cb420592.6fa54bf6.webp"},342997:function(e,n,d){e.exports=d.p+"static/image/ee61034b156e6ee1a94d6c5eefc0d2c2.9cea7520.webp"},329559:function(e,n,d){d.r(n),d.d(n,{default:()=>x});var s=d(552676),r=d(740453),o=d(342997),l=d(395985),i=d(282364),c=d(617095),h=d(489785);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",blockquote:"blockquote",img:"img",ol:"ol",li:"li",h2:"h2",pre:"pre",ul:"ul",h3:"h3",h4:"h4",strong:"strong"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"4-模块机制详解cjs-与-esm中",children:["4-模块机制详解：CJS 与 ESM（中）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-模块机制详解cjs-与-esm中",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"书接上文，之前给大家大体介绍了一下 Node.js 下的 CJS 与 ESM，现在我们潜下水去看看吧。"}),"\n",(0,s.jsxs)(n.p,{children:["其实网上关于 CJS 的讲解很多，大家多少也会有耳濡目染，知道 CJS 模块实际上是对原来的代码首尾各加上点代码，形成一个闭包，才有了 ",(0,s.jsx)(n.code,{children:"__dirname"}),"、",(0,s.jsx)(n.code,{children:"__filename"})," 这些内容。网上也有很多关于 CJS 模块在 ",(0,s.jsx)(n.code,{children:"require"})," 时如何寻径的文章。"]}),"\n",(0,s.jsx)(n.p,{children:"不过既然本小册里面有提到了 CJS 与 ESM，就有必要帮大家重温一下。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"时光荏苒，拖稿严重。本章中代码以 Node.js v18.14.0 为例。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["本章内容重点介绍 Node.js 中 CommonJS 的模块机制。CommonJS 模块加载（",(0,s.jsx)(n.code,{children:"require"}),"）主要分为几步，如下图："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["事实上过程比这复杂得多。此处我做了很多“剪枝”，只留下最核心的骨干。流程很好理解，首先根据当前模块和目标模块标识（我们称其为 ",(0,s.jsx)(n.code,{children:"specifier"}),"）进行寻径。如当前模块地址是 ",(0,s.jsx)(n.code,{children:"/foo/main.js"}),"，而目标模块标识为 ",(0,s.jsx)(n.code,{children:"./module.js"}),"，那么文件路径就是 ",(0,s.jsx)(n.code,{children:"/foo/module.js"}),"；如果目标模块标识为 ",(0,s.jsx)(n.code,{children:"fs"}),"，那么文件路径就是 ",(0,s.jsx)(n.code,{children:"fs"}),"，是个内置模块。所以下面一步就是根据模块类型来走不同分支，究竟是加载内置模块还是对应文件的模块。加载完之后返回结束。"]}),"\n",(0,s.jsx)(n.p,{children:"这里有几个点我们需要弄清楚。"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"“CommonJS 模块”在 Node.js 中表现出的本质是什么？"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"寻径规则是什么？"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"内置模块和文件模块分别怎么加载？"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"搞清楚上面的三个点后，大家对 CommonJS 在 Node.js 中的本质约摸就了然了。"}),"\n",(0,s.jsxs)(n.h2,{id:"nodejs-中-commonjs-模块的本质",children:["Node.js 中 CommonJS 模块的本质",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中-commonjs-模块的本质",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"为了书写方便，下文中所有 CommonJS 都代表 “Node.js 中的 CommonJS”。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["先说结论，上一章中我们提到一个 CommonJS 模块在 Node.js 中，本质是一个 ",(0,s.jsx)(n.code,{children:"Module"})," 实例，实例中包含标识符（",(0,s.jsx)(n.code,{children:"id"}),"）、",(0,s.jsx)(n.code,{children:"module"}),"、",(0,s.jsx)(n.code,{children:"exports"})," 等。实际上，它是一个函数的执行结果。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们先简单地说，CommonJS 模块就是一个 ",(0,s.jsx)(n.code,{children:"module"})," 对象，内含 ",(0,s.jsx)(n.code,{children:"exports"}),"。那么 Node.js 在加载模块（",(0,s.jsx)(n.code,{children:"require()"}),"）时，内部会预先声明这个对象，不严谨地说，类似这样："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const module = {\n  exports: {},\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后，Node.js 在内部将目标模块的代码前后都加上一段代码，使之变成一个函数，这个函数大概长这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(function (exports, require, module, __filename, __dirname) {\n  // 实际模块代码\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"也就是说，如果你有一个模块，其代码是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"module.exports = {\n  hello: 'world',\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"那么其在 CommonJS 模块中，对应的函数代码是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(function (exports, require, module, __filename, __dirname) {\n  module.exports = {\n    hello: 'world',\n  };\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们可以看到，这个函数的参数分别为："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exports"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"require()"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"module"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"__filename"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"__dirname"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["下一步，就是 Node.js 在 ",(0,s.jsx)(n.code,{children:"require()"})," 内部执行这个函数。我们姑且称这个函数为 ",(0,s.jsx)(n.code,{children:"compiledWrapper()"}),"，那么大概就是这么执行的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const module = {\n  exports: {},\n};\n\nconst result = compiledWrapper(module.exports,\n                               <针对新模块的 `require` 函数>,\n                               module,\n                               <解析出来的文件名>,\n                               <解析出来的目录名>);\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"这是我简化后的版本。实际在 Node.js 中，代码复杂得多，分叉也多。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["上面的步骤执行下来之后，",(0,s.jsx)(n.code,{children:"module"})," 被传入之前准备好的函数，模块代码里面做了将其 ",(0,s.jsx)(n.code,{children:"exports"})," 值赋为 ",(0,s.jsx)(n.code,{children:"{ hello: 'world' }"})," 对象的操作。于是，一套操作下来之后，最先定义好的 ",(0,s.jsx)(n.code,{children:"module"})," 对象就在用户模块代码中被赋值了。"]}),"\n",(0,s.jsx)(n.p,{children:"一套流程行云流水，总结成粗糙的流程图如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["所以，CommonJS 模块本质就是一个 ",(0,s.jsx)(n.code,{children:"exports"})," 对象传入被编译的模块函数中执行挂载操作得到的终态。"]}),"\n",(0,s.jsxs)(n.h2,{id:"寻径规则是什么",children:["寻径规则是什么？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#寻径规则是什么",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这是一个老生常谈的问题了，当在一个文件 A 中，进行 ",(0,s.jsx)(n.code,{children:"require(<B>)"}),"，那么最终对应到的文件或者模块是什么。其实这块规则一直有在做一些变化。如果用古早的方式说，大概就是："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["若是以 ",(0,s.jsx)(n.code,{children:"./"})," 或 ",(0,s.jsx)(n.code,{children:"../"})," 等相对路径前缀开头的标识，则认为是一个相对路径，直接以当前模块文件为始去寻径；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"否则，认为其是一个三方模块或内置模块；"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"若是可被加载的内置模块，则使用该内置模块；"}),"\n",(0,s.jsxs)(n.li,{children:["否则，从当前文件目录的 ",(0,s.jsx)(n.code,{children:"node_modules"})," 目录下寻找对应模块（包）；"]}),"\n",(0,s.jsxs)(n.li,{children:["若无法找到，设当前目录为上级目录，重新执行 ",(0,s.jsx)(n.code,{children:"b"}),"；"]}),"\n",(0,s.jsx)(n.li,{children:"若一直到根目录还无法找到，那就是找不到了。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"古早逻辑的确是这样，而且这也的确是现在 Node.js 版本的寻径主要骨干逻辑。只不过现在的 Node.js 中寻径逻辑会多出一些细枝末节来。"}),"\n",(0,s.jsxs)(n.p,{children:["首先，在内置模块的判断上，多了一层判断，即是否以 ",(0,s.jsx)(n.code,{children:"node:"})," 为前缀，且能在用户侧加载的内置模块，或者无 ",(0,s.jsx)(n.code,{children:"node:"})," 前缀且 Node.js 可以通过无前缀方式加载内置模块，同样还需要是用户侧可加载的内置模块。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  if (\n    (\n      StringPrototypeStartsWith(request, 'node:') &&\n      BuiltinModule.canBeRequiredByUsers(StringPrototypeSlice(request, 5))\n    ) || (\n      BuiltinModule.canBeRequiredByUsers(request) &&\n      BuiltinModule.canBeRequiredWithoutScheme(request)\n    )\n  ) {\n    return request;\n  }\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["此处 ",(0,s.jsx)(n.code,{children:"request"})," 即传入 ",(0,s.jsx)(n.code,{children:"require()"})," 函数的标识。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["然后是一段",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L969-L1003",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L969-L1003",target:"_blank",rel:"noopener noreferrer",children:"自定义寻径基路径"}),"的逻辑，这段逻辑是给 ",(0,s.jsx)(n.code,{children:"require.resolve(id, options)"})," 用的，并不会在 ",(0,s.jsx)(n.code,{children:"require()"})," 加载模块的时候被用到，就不详表了。寻径基路径是一个数组，表示接下去对于 ",(0,s.jsx)(n.code,{children:"request"})," 的寻径会逐个从基路径数组中匹配，一旦匹配上就将其作为模块路径。默认情况下，基路径数组由 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L758-L804",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L758-L804",target:"_blank",rel:"noopener noreferrer",children:"Module._resolveLookupPaths() 生成"}),"，其逻辑如下："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["若是内置模块，则不需要基路径，为 ",(0,s.jsx)(n.code,{children:"null"}),"；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["若不是以相对路径标识开头（",(0,s.jsx)(n.code,{children:"./"}),"、",(0,s.jsx)(n.code,{children:"../"}),"），则："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["基路径为从当前目录开始往前的每一级目录，并为每一级目录都加上 ",(0,s.jsx)(n.code,{children:"node_modules"})," 一层（参考",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L720-L756",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L720-L756",target:"_blank",rel:"noopener noreferrer",children:"源码"}),"）；"]}),"\n",(0,s.jsxs)(n.li,{children:["除了上述的基路径之外，还包括 ",(0,s.jsx)(n.code,{children:"HOME"})," 环境变量下诸如 ",(0,s.jsx)(n.code,{children:".node_modules"}),"、",(0,s.jsx)(n.code,{children:".node_libraries"})," 等目录，包括 Global 包所安装的目录等（参考",(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/modules.html#loading-from-the-global-folders",title:"https://nodejs.org/dist/latest-v18.x/docs/api/modules.html#loading-from-the-global-folders",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"和",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1354-L1382",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1354-L1382",target:"_blank",rel:"noopener noreferrer",children:"源码"}),"）；"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"若是以相对路径标识开头，则基路径为当前模块的目录地址。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"此外，还有一些诸如 REPL 的基路径逻辑。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"有了基路径数组后，开始正式的寻径逻辑。"}),"\n",(0,s.jsxs)(n.p,{children:["跟古早时期不一样的是，现在的 Node.js 支持以 ",(0,s.jsx)(n.code,{children:"#"})," 开头的模块标识了。其逻辑是先读取最近的上层作用域中的 ",(0,s.jsx)(n.code,{children:"package.json"})," 文件，并从中获取 ",(0,s.jsx)(n.code,{children:"import"})," 字段中的映射关系，从而根据映射关系进行寻径，若寻径失败则直接抛错。由于 Node.js 中该逻辑使用的是 ESM 模块加载相关代码中的函数，就不在本章详表了。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下去，还是尝试读对应 ",(0,s.jsx)(n.code,{children:"package.json"}),"，看看包名是否与当前的 ",(0,s.jsx)(n.code,{children:"request"})," 相等——我加载我自己。比如当前包名（",(0,s.jsx)(n.code,{children:"package.json"})," 中的 ",(0,s.jsx)(n.code,{children:"name"}),"）为 ",(0,s.jsx)(n.code,{children:"example"}),"，那么这其中文件去 ",(0,s.jsx)(n.code,{children:"require('example/hello')"})," 的时候，会尝试在当前包的根目录下找 ",(0,s.jsx)(n.code,{children:"hello.js"}),"。这个操作在 Node.js 中叫 resolve self，毕竟",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1024",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1024",target:"_blank",rel:"noopener noreferrer",children:"相关代码"}),"是 ",(0,s.jsx)(n.code,{children:"const selfResolved = trySelf(...);"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"然后就是正儿八经地遍历之前拿到的基路径数组，开始寻径。规则为："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["若 ",(0,s.jsx)(n.code,{children:"request"})," 是个绝对路径，则忽略原来所有基路径，并仅以一个空字符串作为基路径；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"从数组中拿到下一个基路径；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["用基路径加上 ",(0,s.jsx)(n.code,{children:"request"})," 变成一个新路径；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["在新路径中找是否存在最近的上层 ",(0,s.jsx)(n.code,{children:"package.json"}),"，并判断是否有 ",(0,s.jsx)(n.code,{children:"exports"})," 字段做映射，若有映射，直接计算映射相关内容，最终若计算成功则直接返回，这是为了兼容 ESM 的 ",(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/packages.html#package-entry-points",title:"https://nodejs.org/dist/latest-v18.x/docs/api/packages.html#package-entry-points",target:"_blank",rel:"noopener noreferrer",children:"exports 语法糖"}),"，而且这段逻辑也是直接复用了 ECMAScript module 的相关逻辑；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["判断新路径状态，若新路径不以目录符号 ",(0,s.jsx)(n.code,{children:"/"})," 结尾，则："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"若是一个文件，则寻径成功；"}),"\n",(0,s.jsx)(n.li,{children:"否则，尝试加上各种后缀名再看看文件存不存在，若任一存在，则寻径成功；"}),"\n",(0,s.jsx)(n.li,{children:"否则，继续后续逻辑；"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"若新路径是个目录，则："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["若当前目录有 ",(0,s.jsx)(n.code,{children:"package.json"}),"，则尝试使用 ",(0,s.jsx)(n.code,{children:"main"}),"，若一切安好，则寻径成功；"]}),"\n",(0,s.jsxs)(n.li,{children:["否则尝试 ",(0,s.jsx)(n.code,{children:"index"})," 加上各种后缀看看文件存不存在，若存在，则寻径成功，否则继续后续逻辑；"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"最后，若还没寻径成功，则失败。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这是我用大白话解释 CommonJS 的寻径规则，实际上 Node.js 文档中有更严谨的说明，不过读着头大。想要更严谨的说法，可自行翻阅",(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/modules.html#all-together",title:"https://nodejs.org/dist/latest-v18.x/docs/api/modules.html#all-together",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，CommonJS 与 ESM 水乳交融。在 CommonJS 中，",(0,s.jsx)(n.code,{children:"#"})," 的逻辑与 ",(0,s.jsx)(n.code,{children:"package.json"})," 中 ",(0,s.jsx)(n.code,{children:"exports"})," 的逻辑都是直接复用了 ESM 相关代码的。"]}),"\n",(0,s.jsxs)(n.h2,{id:"内置模块和文件模块分别怎么加载",children:["内置模块和文件模块分别怎么加载？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内置模块和文件模块分别怎么加载",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"文件模块的加载",children:["文件模块的加载",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#文件模块的加载",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在前文中，我们总提到 ",(0,s.jsx)(n.code,{children:"Module"})," 实例（又称 ",(0,s.jsx)(n.code,{children:"module"})," 对象），包括上面流程图中也绕不开它。它究竟是个什么东西？首先我们看它的",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L206-L215",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L206-L215",target:"_blank",rel:"noopener noreferrer",children:"构造函数"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function Module(id = '', parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  setOwnProperty(this, 'exports', {});\n  moduleParentCache.set(this, parent);\n  updateChildren(parent, this, false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在构造之初，就把 ",(0,s.jsx)(n.code,{children:"id"}),"、",(0,s.jsx)(n.code,{children:"parent"}),"、",(0,s.jsx)(n.code,{children:"path"}),"、",(0,s.jsx)(n.code,{children:"filename"})," 等的初始化好了。这个类我们在上一章中有提到，它对象内部就是有这些成员变量。除了上面这些成员变量之外，还通过 ",(0,s.jsx)(n.code,{children:"setOwnProperty()"})," 把 ",(0,s.jsx)(n.code,{children:"exports"})," 挂载到 ",(0,s.jsx)(n.code,{children:"module"})," 对象中。这里的 ",(0,s.jsx)(n.code,{children:"setOwnProperty"})," 是对下面代码的封装："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"ObjectDefineProperty(obj, key, {\n  __proto__: null,\n  configurable: true,\n  enumerable: true,\n  value,\n  writable: true,\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["而在 ",(0,s.jsx)(n.code,{children:"require()"})," 一个模块的时候，当前序逻辑都执行完了后（如不使用缓存、是一个内置模块等），会实例化一个 ",(0,s.jsx)(n.code,{children:"Module"})," 对象。",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L914",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L914",target:"_blank",rel:"noopener noreferrer",children:"就像这样"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const module = new Module(filename, parent);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此处的 ",(0,s.jsx)(n.code,{children:"filename"})," 即寻径后得到的文件名，用于加载模块源码。",(0,s.jsx)(n.code,{children:"parent"})," 即当前发起 ",(0,s.jsx)(n.code,{children:"require()"})," 函数的模块所属的 ",(0,s.jsx)(n.code,{children:"Module"})," 实例。然后调用 ",(0,s.jsx)(n.code,{children:"module"})," 对象中的 ",(0,s.jsx)(n.code,{children:"load"})," 函数进行内里的逻辑，如读取模块代码、编译模块并执行等等。这些都是 ",(0,s.jsx)(n.code,{children:"Module"})," 的成员方法，所以我们在流程图中可以看见，直接用 ",(0,s.jsx)(n.code,{children:"this"})," 来代替 ",(0,s.jsx)(n.code,{children:"module"})," 对象了。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.h4,{children:[(0,s.jsx)(n.code,{children:"module.exports"})," 与 ",(0,s.jsx)(n.code,{children:"exports"})]}),"\n",(0,s.jsxs)(n.p,{children:["上一章中，我们提到了 ",(0,s.jsx)(n.code,{children:"module.exports"})," 与 ",(0,s.jsx)(n.code,{children:"exports"})," 的关系，为什么 ",(0,s.jsx)(n.code,{children:"module.exports"})," 被覆盖后，原 ",(0,s.jsx)(n.code,{children:"exports"})," 就不生效了。内在逻辑在上面的内容中就已经明晰了。"]}),"\n",(0,s.jsxs)(n.p,{children:["CommonJS 模块本质中有一个编译好的函数，其参数有 ",(0,s.jsx)(n.code,{children:"module"}),"、",(0,s.jsx)(n.code,{children:"exports"}),"。而传进去的 ",(0,s.jsx)(n.code,{children:"module"})," 即 ",(0,s.jsx)(n.code,{children:"this"}),"，也就是 ",(0,s.jsx)(n.code,{children:"Module"})," 实例；",(0,s.jsx)(n.code,{children:"exports"})," 则是 ",(0,s.jsx)(n.code,{children:"this.exports"}),"。传进去后，这两个对象均可以被目标模块内部随意更改。"]}),"\n",(0,s.jsxs)(n.p,{children:["只不过，我如果改了 ",(0,s.jsx)(n.code,{children:"module.exports"})," 整体后，",(0,s.jsx)(n.code,{children:"this.exports"})," 的引用就指向新的 ",(0,s.jsx)(n.code,{children:"exports"})," 了。而模块最终导出的是 ",(0,s.jsx)(n.code,{children:"Module"})," 实例的 ",(0,s.jsx)(n.code,{children:"this.exports"}),"，所以原来的 ",(0,s.jsx)(n.code,{children:"exports"})," 再怎么改也没用了。"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，还有一个",(0,s.jsx)(n.strong,{children:"冷知识"}),"，我们是可以通过 ",(0,s.jsx)(n.code,{children:"console"})," 输出形如 ",(0,s.jsx)(n.code,{children:"module._compile()"})," 等函数的，因为它就是 ",(0,s.jsx)(n.code,{children:"Module"})," 类的方法，而 ",(0,s.jsx)(n.code,{children:"module"})," 又是 ",(0,s.jsx)(n.code,{children:"Module"})," 实例。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"在 CommonJS 中，若无用户自定义类型的话，Node.js 支持三种类型的模块："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*.js"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*.json"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*.node"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"require()"})," 过程中，会根据不同文件后缀使用不同的逻辑来加载。如果是 ",(0,s.jsx)(n.code,{children:"*.js"})," 文件，就是上面讲的流程；如果是 ",(0,s.jsx)(n.code,{children:"*.json"})," 文件，则是同步读取对应文件后，对其进行 ",(0,s.jsx)(n.code,{children:"JSON.parse(content)"})," 得到内容，然后挂载到 ",(0,s.jsx)(n.code,{children:"module.exports"})," 中供其他模块使用（此处的 ",(0,s.jsx)(n.code,{children:"content"})," 是经过特殊处理的）；若是 ",(0,s.jsx)(n.code,{children:"*.node"}),"，则以 C++ 扩展的机制进行加载，篇幅过长，就不细介绍了，有兴趣可以阅读一下《Node.js：来一打 C++ 扩展》。"]}),"\n",(0,s.jsxs)(n.p,{children:["这三种逻辑被放置在 ",(0,s.jsx)(n.code,{children:"Module"})," 静态对象中，形式如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Module._extensions['.js'] = function(module, filename) { ... }\nModule._extensions['.json'] = function(...) { ... }\nModule._extensions['.node'] = function(...) { ... }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个逻辑是可被用户自定义修改的。如果你想让 Node.js 在运行时过程中可以加载编译 TypeScript 模块并执行，只需要新增一个 ",(0,s.jsx)(n.code,{children:".ts"})," 后缀的逻辑即可，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const Module = require('module');\n\nModule._extensions['.ts'] = function(module, filename) {\n  // 读取 TypeScript 源文件，加上函数前后缀，编译 TypeScript 函数并执行，传入 `module` 得到结果\n};\n\n// 或者\nrequire.extensions['.ts'] = ...; // 此处等同 `Module._extensions`\n"})}),"\n",(0,s.jsxs)(n.p,{children:["事实上，",(0,s.jsx)(n.a,{href:"https://github.com/TypeStrong/ts-node/blob/v10.9.1/src/index.ts#L1607-L1622",title:"https://github.com/TypeStrong/ts-node/blob/v10.9.1/src/index.ts#L1607-L1622",target:"_blank",rel:"noopener noreferrer",children:"ts-node"})," 就是这么做的。在 Node.js ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1235",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1235",target:"_blank",rel:"noopener noreferrer",children:"默认的 _extension['.js'] 中"}),"，会先判断一些缓存逻辑，通过文件名看之前是否加载过该模块。然后就是流程图中的读取文件内容。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"content = fs.readFileSync(filename, 'utf8');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面这行代码就是为什么上一章我们说 CommonJS 的模块加载是纯同步的，因为唯一一个可以异步编写的地方也用了同步的 API。接下去判断一下这个模块是不是合法 CommonJS 模块，如按上一章中提到的 ",(0,s.jsx)(n.code,{children:"package.json"})," 中的 ",(0,s.jsx)(n.code,{children:"type"})," 等，若不合法则抛错，同样像上一章中提到的一样。可以",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1245-L1279",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1245-L1279",target:"_blank",rel:"noopener noreferrer",children:"简化成"}),"（当然，这其中还是有很多分支条件）："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const pkg = readPackageScope(filename);  // 读取对应的 `package.json`\nif (pkg?.data?.type === 'module') {\n  ...\n  throw err;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["文件也读完了，合法性也判断了，接下去就是调用 ",(0,s.jsx)(n.code,{children:"module._compile()"})," 去编译并执行模块函数，得到最终结果了。这其中首先就是为得到的代码内容加上前后缀，",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1127",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1127",target:"_blank",rel:"noopener noreferrer",children:"得到模块函数源码"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\n...\nconst wrapper = [\n  '(function (exports, require, module, __filename, __dirname) { ',\n  '\\n});',\n];\n\n...\nconst wrapper = Module.wrap(content);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后是通过 ",(0,s.jsx)(n.code,{children:"vm"})," 中的 ",(0,s.jsx)(n.code,{children:"Script"})," 类去加载并执行，得到函数对象。",(0,s.jsx)(n.code,{children:"vm"})," 在本章不详说，后续章节会再涉及。"]}),"\n",(0,s.jsxs)(n.p,{children:["等这些都做完后，就是传入 ",(0,s.jsx)(n.code,{children:"this"})," 并调用函数，挂载最终 ",(0,s.jsx)(n.code,{children:"module.exports"})," 了："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Module.prototype._compile = function(content, filename) {\n  ...\n  \n  // 此处的 `wrapSafe` 就是上面代码块的相关逻辑\n  const compiledWrapper = wrapSafe(filename, content, this);\n  \n  ...\n  \n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this, redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  \n  ...\n  \n  result = Reflect.apply(compiledWrapper, thisValue,\n                         [exports, require, module, filename, dirname]);\n                        \n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如此一来，一个文件模块基本上就完成了。这里面还有一点，就是每个新的模块中，",(0,s.jsx)(n.code,{children:"require()"})," 函数都是现做的，通过 ",(0,s.jsx)(n.code,{children:"makeRequireFunction()"}),"，里面主要涉及一些安全策略相关的逻辑，然后才是 ",(0,s.jsx)(n.code,{children:"require()"})," 函数本体；若无策略相关逻辑，那么 ",(0,s.jsx)(n.code,{children:"makeRequireFunction()"})," 返回的 ",(0,s.jsx)(n.code,{children:"require()"})," 函数就是对 ",(0,s.jsx)(n.code,{children:"Module.prototype.require()"})," 的透传。除此之外，",(0,s.jsx)(n.code,{children:"makeRequireFunction()"})," 还为返回的 ",(0,s.jsx)(n.code,{children:"require()"})," 中注入了诸如 ",(0,s.jsx)(n.code,{children:"require.resolve()"})," 等函数，供大家使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["下面是 ",(0,s.jsx)(n.code,{children:"Module.prototype.require()"})," 的代码，非常简单："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Module.prototype.require = function(id) {\n  ...\n  \n  try {\n    return Module._load(id, this, /* isMain */ false);\n  } finally {\n    ...\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["而这个 ",(0,s.jsx)(n.code,{children:"Module._load()"})," 就是本章第一个流程图所写的流程了。内容比较长，就不展开了，毕竟本小册不是正儿八经的 Node.js 源码剖析，有兴趣大家可",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L859-L954",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L859-L954",target:"_blank",rel:"noopener noreferrer",children:"自行阅读源码"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"内置模块的加载",children:["内置模块的加载",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内置模块的加载",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Node.js 中内置模块加载与文件模块加载逻辑不一样。我们不讲解 Node.js 中的内置模块是如何 ",(0,s.jsx)(n.code,{children:"require()"})," 另一个内置模块的，讲来讲去讲不完了，这里我们只讲用户侧代码是如何加载内置模块的。"]}),"\n",(0,s.jsxs)(n.p,{children:["内置模块与文件模块加载逻辑的区别是在前文中提到的 ",(0,s.jsx)(n.code,{children:"Module._load()"})," 中体现的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Module._load = function(request, parent, isMain) {\n  ...\n  \n  if (String.prototype.startsWith(request, 'node:')) {\n    const id = String.prototype.slice(request, 5);  // 去掉 node: 前缀\n    const module = loadBuiltinModule(id, request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(request);\n    }\n    return module.exports;\n  }\n  \n  ...寻径及缓存等逻辑...\n  \n  const mod = loadBuiltinModule(filename, request);\n  if (mod?.canBeRequiredByUsers &&\n      BuiltinModule.canBeRequiredWithoutScheme(filename)) {\n    return mod.exports;\n  }\n  \n  ...\n  \n  文件模块加载逻辑\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看出来，实际上加载文件模块和内置模块的逻辑是杂糅在一起的，并不像最开始那张流程图那样泾渭分明。大概逻辑就是，先判断是否有 ",(0,s.jsx)(n.code,{children:"node:"})," 前缀，这是在 Node.js v14.18.0 中首次提出来的，大家可以显式地",(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/modules.html#core-modules",title:"https://nodejs.org/dist/latest-v18.x/docs/api/modules.html#core-modules",target:"_blank",rel:"noopener noreferrer",children:"通过 node: 前缀来说明此次加载的是一个内置模块"}),"，毕竟如果你的 ",(0,s.jsx)(n.code,{children:"node_modules"})," 目录下有同名包的情况下，不显式声明会找到犄角旮旯里去。若有 ",(0,s.jsx)(n.code,{children:"node:"})," 前缀，则直接通过 ",(0,s.jsx)(n.code,{children:"loadBuiltinModule()"})," 去加载对应模块并返回。然后是一系列的寻径逻辑，得到 ",(0,s.jsx)(n.code,{children:"filename"}),"，这个 ",(0,s.jsx)(n.code,{children:"filename"})," 有可能是个文件路径，也有可能没找到对应文件，直接是个标识符（如 ",(0,s.jsx)(n.code,{children:"fs"})," 等）。这个时候，再拿着 ",(0,s.jsx)(n.code,{children:"filename"})," 去尝试通过 ",(0,s.jsx)(n.code,{children:"loadBuiltinModule()"})," 加载对应内置模块。如果存在对应内置模块，则判断一下当前启动策略是否允许通过无 ",(0,s.jsx)(n.code,{children:"node:"})," 前缀方式加载内置模块，若都合法，则也返回 ",(0,s.jsx)(n.code,{children:"mod.exports"}),"。",(0,s.jsx)(n.code,{children:"loadBuiltModule()"})," 函数在未找到对应内置模块的情况下，是无返回（即 ",(0,s.jsx)(n.code,{children:"undefined"}),"）的，所以自然会走到后面文件模块加载逻辑。"]}),"\n",(0,s.jsx)(n.p,{children:"这点代码归结为流程图，就是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["而 ",(0,s.jsx)(n.code,{children:"loadBuiltinModule()"})," 函数逻辑也非常简单，这是因为我们的讲解点到为止，不继续深入内置函数具体怎么加载。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function loadBuiltinModule(filename, request) {\n  const mod = BuiltinModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load built-in module %s', request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["直接从 ",(0,s.jsx)(n.code,{children:"BuiltinModule"})," 的 ",(0,s.jsx)(n.code,{children:"map"})," 中获取对应标识（如 ",(0,s.jsx)(n.code,{children:"fs"}),"、",(0,s.jsx)(n.code,{children:"path"})," 等）的内置模块，然后看是不是存在且能被用户所 ",(0,s.jsx)(n.code,{children:"require()"}),"。若可以，那就将其编译为用户侧可用的模块，否则直接不返回。这个 ",(0,s.jsx)(n.code,{children:"BuiltinModule"})," 是另一种模块实例，与文件模块的 ",(0,s.jsx)(n.code,{children:"Module"})," 相对应。在 Node.js 初始化的时候，会通过 C++ 侧代码把所有的内置模块名放到 ",(0,s.jsx)(n.code,{children:"map"})," 中，并为其实例化一个对应的 ",(0,s.jsx)(n.code,{children:"BuiltinModule"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"const {\n  builtinIds,\n} = internalBinding('builtins');  // 从 C++ 侧代码中获取内置模块 ID 数组\n\nclass BuiltinModule {\n  ...\n  \n  static map = new SafeMap(\n    ArrayPrototypeMap(builtinIds, (id) => [id, new BuiltinModule(id)])\n  );\n  \n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["而所谓的 ",(0,s.jsx)(n.code,{children:"canBeRequiredByUser"})," 成员变量则是在 ",(0,s.jsx)(n.code,{children:"BuiltinModule"})," 构造函数时通过判断标识中是否以 ",(0,s.jsx)(n.code,{children:"internal/"})," 开头来决定的。用户侧不能加载 ",(0,s.jsx)(n.code,{children:"internal/*"})," 模块。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"mod.compileForPublicLoader()"})," 则是将内置模块编译好并返回结果，具体就不分析了，反正最终是在 C++ 侧通过标识拿到对应内置模块的源码字符串，然后再进行类似的编译，内置模块对应函数的参数与文件模块不同，其为："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exports"}),"：最终导出对象，即 ",(0,s.jsx)(n.code,{children:"module.exports"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"require()"}),"：内置模块特有的 ",(0,s.jsx)(n.code,{children:"require()"})," 函数，API 接口层与文件模块中的看起来一样，实际逻辑不同；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"module"}),"：当前 ",(0,s.jsx)(n.code,{children:"BuiltinModule"})," 对象；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"process"}),"：",(0,s.jsx)(n.code,{children:"process"})," 对象；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"internalBinding"}),"：用于加载内置 C++ binding 的函数，比如上面的代码块中就用到了；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"primordals"}),"：ECMAScript 原初对象、函数等的集合。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.h4,{children:[(0,s.jsx)(n.code,{children:"primordals"})," 原初对象"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"primordals"})," 的作用是，为防止用户侧通过篡改一些 ECMAScript 原初对象、函数，来篡改 Node.js 的实际执行意图的行为。例如，上面代码块中的 ",(0,s.jsx)(n.code,{children:"ArrayPrototypeMap"})," 就对应 ",(0,s.jsx)(n.code,{children:"Array.prototype.map()"}),"。包括在之前各种代码块中，我其实有手动将这些大驼峰的命名改为原来所代表的含义，在之前供大家理解。"]}),"\n",(0,s.jsxs)(n.p,{children:["实际上，若无 ",(0,s.jsx)(n.code,{children:"primordals"})," 机制，如果用户篡改了 ",(0,s.jsx)(n.code,{children:"Array.prototype.map()"}),"，如 ",(0,s.jsx)(n.code,{children:"Array.prototype.map = function() { throw new Error(...); }"}),"，或者做一些不安全的事情，那么 Node.js 就会从内部被瓦解。"]}),"\n",(0,s.jsxs)(n.p,{children:["所以，Node.js 将这些 ECMAScript 原初对象、函数等都在用户能执行代码的时间节点之前就预先存到 ",(0,s.jsx)(n.code,{children:"primordals"})," 下。后续所有的内置模块逻辑中都使用 ",(0,s.jsx)(n.code,{children:"primordals.<xxx>"})," 来代替原逻辑。比如上面代码块中就是 ",(0,s.jsx)(n.code,{children:"const { ArrayPrototypeMap } = primordals"}),"。这个 ",(0,s.jsx)(n.code,{children:"primordals"})," 对用户侧代码不可见，只会在内置模块中被传递，所以不会被外界所篡改。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["至此，内置模块的加载逻辑就清晰了。除了隐藏地更深的内置模块实际是如何编译、执行的，这块逻辑大家有兴趣可自行阅读源码。我们只需要知道，所有的内置模块源码都在 Node.js 自身可执行文件构建编译的时候，通过 ",(0,s.jsx)(n.code,{children:"js2c.py"})," 脚本将所有源码都写死生成到了一个叫 ",(0,s.jsx)(n.code,{children:"node_javascript.cc"})," 中，编译的时候直接就放到了 Node.js 二进制文件中，执行的时候直接就存在了内存里。当需要用到对应模块源码时，直接从内存拿就好了。关于这块的信息，网上有很多相关文章。"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本章中为大家揭示了 CommonJS 模块在 Node.js 中的本质。它实际上是一个 ",(0,s.jsx)(n.code,{children:"Module"})," 实例，内含 ",(0,s.jsx)(n.code,{children:"exports"})," 对象，当我们 ",(0,s.jsx)(n.code,{children:"require()"})," 某个模块的时候，拿到的是其 ",(0,s.jsx)(n.code,{children:"exports"})," 对象里的内容。而 ",(0,s.jsx)(n.code,{children:"Module"})," 实例在加载模块的时候，是先将模块源码前后包了额外代码将其变成一个函数样式，并编译该函数执行得到的 ",(0,s.jsx)(n.code,{children:"exports"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["它就像一个泡芙加工过程。它并不是工作人员从 0 开始做面包，做奶油，然后返回给你。工作人员做的事只是往递过去的面包（事先准备好的 ",(0,s.jsx)(n.code,{children:"module"})," 和 ",(0,s.jsx)(n.code,{children:"module.exports"}),"）里面注入奶油，这个奶油就是你要的模块了。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"CommonJS 模块加工过程（误）"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F4-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9ACJS%20%E4%B8%8E%20ESM%EF%BC%88%E4%B8%AD%EF%BC%89.md"]={toc:[{text:"Node.js 中 CommonJS 模块的本质",id:"nodejs-中-commonjs-模块的本质",depth:2},{text:"寻径规则是什么？",id:"寻径规则是什么",depth:2},{text:"内置模块和文件模块分别怎么加载？",id:"内置模块和文件模块分别怎么加载",depth:2},{text:"文件模块的加载",id:"文件模块的加载",depth:3},{text:"内置模块的加载",id:"内置模块的加载",depth:3},{text:"小结",id:"小结",depth:2}],title:"4-模块机制详解：CJS 与 ESM（中）",headingTitle:"4-模块机制详解：CJS 与 ESM（中）",frontmatter:{}}}}]);