"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["45659"],{499478:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var s=r(552676),t=r(740453);let i=r.p+"static/image/f24b555f3e3037f003b834272ed04779.743ffdd6.gif",c=r.p+"static/image/2cb5d4df181eb597b3a8206e232c5d67.dc1fd825.gif",a=r.p+"static/image/066aa0534ecd16f0977bc00009d33a52.3fd726de.webp",o=r.p+"static/image/a28df42948f3046ddd5b023ba1117bfb.77097102.webp",p=r.p+"static/image/4460393bbdc39f12802f1782b19fcdec.12c5b1c1.gif",d=r.p+"static/image/65fbcf7f42ca4e20a32824598b67188f.b7d5b601.webp",l=r.p+"static/image/6adf9bcddf8c09111675c64d1c0616c1.34e4c746.webp",h=r.p+"static/image/b5a824a0edb91227633ff2a589adf693.06989a20.webp";function j(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",pre:"pre",code:"code",img:"img",blockquote:"blockquote",ol:"ol",li:"li"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"64源码篇-_-手写-react-ssg-和-isr",children:["64.源码篇 _ 手写 React SSG 和 ISR",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#64源码篇-_-手写-react-ssg-和-isr",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上篇我们手写了一个 React SSR，实现了基本的服务端渲染和客户端绑定事件。"}),"\n",(0,s.jsx)(n.p,{children:"本篇我们先继续完善 React SSR，并在此基础上实现 React SSG 和 React ISR。"}),"\n",(0,s.jsxs)(n.h2,{id:"1-优化-ract-ssr",children:["1. 优化 Ract SSR",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-优化-ract-ssr",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"step1实现-getserversideprops",children:["Step1：实现 getServerSideProps",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step1实现-getserversideprops",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在使用 Next.js Pages Router 的时候，经常会用到一个 ",(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props",target:"_blank",rel:"noopener noreferrer",children:"getServerSideProps"})," 的 API，用于在页面请求时获取数据渲染页面的内容。举个例子："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export async function getServerSideProps() {\n  // 获取数据\n  const res = await fetch('https://api.github.com/repos/vercel/next.js')\n  const repo = await res.json()\n  // 通过 props 将数据传给 page\n  return { props: { repo } }\n}\n \nexport default function Page({ repo }) {\n  return (\n    <main>\n      <p>{repo.stargazers_count}</p>\n    </main>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个功能该怎么实现呢？"}),"\n",(0,s.jsx)(n.p,{children:"其实思路很简单：import 该文件，获取导出的 getServerSideProps 函数。然后在服务端调用该函数，最后将返回的数据传入到组件中。"}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"server.js"}),"，完整代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import express from 'express'\nimport React from 'react'\nimport { renderToString } from 'react-dom/server'\nimport { readdirSync } from \"fs\";\nimport { join } from \"path\";\n\nconst app = express()\napp.use(express.static('public'));\n\napp.get(\"/\", async (req, res) => {\n    const file = await import(`./pages/index.js`);\n    let propsObj = {};\n    if (file.getServerSideProps) {\n      const { props } = await file.getServerSideProps({ query: req.query });\n      propsObj = props\n    }\n    const Component = file.default;\n\n    const content = renderToString(<Component {...propsObj} />)\n    res.send(`\n    <html>\n       <head>\n           <title>Tiny React SSR</title>\n       </head>\n       <body>\n        <div id='root'>${content}</div>\n        <script src=\"/client.bundle.js\"><\/script>\n       </body>\n    </html>\n    `)\n})\n\napp.listen(3000, () => console.log('listening on port 3000!'))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["为了测试效果，修改 ",(0,s.jsx)(n.code,{children:"pages/index.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React from 'react';\n\nexport async function getServerSideProps() {\n  const res = await fetch('https://api.thecatapi.com/v1/images/search')\n  const cat = await res.json()\n  return { props: { cat } }\n}\n \nexport default function Page({ cat }) {\n  return <img src={cat[0].url} width=\"200\" />\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["运行 ",(0,s.jsx)(n.code,{children:"npm start"}),"，访问 ",(0,s.jsx)(n.code,{children:"http://localhost:3000/"}),"，此时页面空白且有报错："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"但是让我们查看 localhost 页面的 HTML 返回："}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("img",{src:l,alt:"image.png"}),"\n至少 HTML 返回是正确的，并成功的获取了数据。"]}),"\n",(0,s.jsx)(n.p,{children:"可是为什么会有报错呢？"}),"\n",(0,s.jsx)(n.p,{children:"根据报错的信息，是水合（hydration）时出现了错误。这是因为服务端渲染的 HTML 和客户端渲染的 HTML 并不匹配（前面我们说过，服务端渲染和客户端渲染一致，是复用 DOM 节点进行水合的前提）。"}),"\n",(0,s.jsx)(n.p,{children:"服务端渲染的时候我们调用接口传入了数据，但是客户端渲染的时候并没有调用接口传入数据，自然渲染不一致，导致了报错。"}),"\n",(0,s.jsx)(n.p,{children:"所以客户端渲染的时候也要获取数据，才能保证两端渲染一致。"}),"\n",(0,s.jsx)(n.p,{children:"尴尬的是我们的接口是一个随机返回数据的接口，每次调用都会返回不同的数据。"}),"\n",(0,s.jsx)(n.p,{children:"注：其实这种每次调用数据返回不一致的情况很常见，比如 feeds 流，客户端调用和服务端调用尽管时间差不了几秒，但可能数据已经发生了更改。"}),"\n",(0,s.jsx)(n.p,{children:"最为简单的方式是将数据写入 HTML 脚本中，然后客户端渲染的时候直接获取。"}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"server.js"}),"，完整代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import express from 'express'\nimport React from 'react'\nimport { renderToString } from 'react-dom/server'\nimport { readdirSync } from \"fs\";\nimport { join } from \"path\";\n\nconst app = express()\napp.use(express.static('public'));\n\napp.get(\"/\", async (req, res) => {\n    const file = await import(`./pages/index.js`);\n    let propsObj = {};\n    if (file.getServerSideProps) {\n      const { props } = await file.getServerSideProps({ query: req.query });\n      propsObj = props\n    }\n    const Component = file.default;\n\n    const content = renderToString(<Component {...propsObj} />)\n    res.send(`\n    <html>\n       <head>\n           <title>Tiny React SSR</title>\n       </head>\n       <body>\n        <div id='root'>${content}</div>\n        <script>\n          window.__DATA__ = ${JSON.stringify(propsObj)}\n        <\/script>\n        <script src=\"/client.bundle.js\"><\/script>\n       </body>\n    </html>\n    `)\n})\n\napp.listen(3000, () => console.log('listening on port 3000!'))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们将数据放到 ",(0,s.jsx)(n.code,{children:"window.__DATA__"}),"变量中，然后在 JS 文件中就可以直接获取。"]}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"client.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React from 'react';\nimport { hydrateRoot } from 'react-dom/client';\nimport App from'./pages/index'\n\nhydrateRoot(document.getElementById('root'), <App {...window.__DATA__}/>);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["重新运行 ",(0,s.jsx)(n.code,{children:"npm start"}),"，访问 ",(0,s.jsx)(n.code,{children:"http://localhost:3000/"}),"，现在页面渲染正常了："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"功能实现：React SSR 实现 gerServerSideProps"}),"\n",(0,s.jsxs)(n.li,{children:["源码地址：",(0,s.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-2",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-2"})]}),"\n",(0,s.jsxs)(n.li,{children:["下载代码：",(0,s.jsx)(n.code,{children:"git clone -b react-ssr-2 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"step2实现路由",children:["Step2：实现路由",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step2实现路由",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Next.js 的路由基于的是文件系统，也就是说，一个文件就可以是一个路由。"}),"\n",(0,s.jsxs)(n.p,{children:["举个例子，在 Next.js 的 Pages Router 下，你在 ",(0,s.jsx)(n.code,{children:"pages"})," 目录下创建一个 ",(0,s.jsx)(n.code,{children:"index.js"})," 文件，它会直接映射到 ",(0,s.jsx)(n.code,{children:"/"})," 路由地址："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React from 'react'\nexport default () => <h1>Hello world</h1>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"pages"})," 目录下创建一个 ",(0,s.jsx)(n.code,{children:"about.js"})," 文件，它会直接映射到 ",(0,s.jsx)(n.code,{children:"/about"})," 路由地址："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React from 'react'\nexport default () => <h1>About us</h1>\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果我们要实现这个效果，该怎么实现呢？"}),"\n",(0,s.jsx)(n.p,{children:"实现思路其实很简单，判断路由地址，导入对应的模块进行渲染即可。"}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"server.js"}),"，完整代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import express from 'express'\nimport React from 'react'\nimport { renderToString } from 'react-dom/server'\nimport { readdirSync } from \"fs\";\nimport { join } from \"path\";\n\nconst app = express()\napp.use(express.static('public'));\n\nconst pagesDir = join(process.cwd(), \"/pages\")\nconst pages = readdirSync(pagesDir).map(page => page.split(\".\")[0]);\n\napp.get(/.*$/, async (req, res) => {\n\n  const path = req.path.split('/')[1]\n  const page = path ? path : 'index'\n\n  if (pages.includes(page)) {\n    const file = await import(`./pages/${page}.js`);\n    const Component = file.default;\n\n    let propsObj = {};\n    if (file.getServerSideProps) {\n      const { props } = await file.getServerSideProps({ query: req.query });\n      propsObj = props\n    }\n\n    const content = renderToString(<Component {...propsObj} />)\n    res.send(`\n      <html>\n         <head>\n             <title>Tiny React SSR</title>\n         </head>\n         <body>\n          <div id='root'>${content}</div>\n          <script>\n            window.__DATA__ = ${JSON.stringify({\n              props: propsObj,\n              page: page\n            })}\n          <\/script>\n          <script src=\"/client.bundle.js\"><\/script>\n         </body>\n      </html>\n      `)\n  } else {\n    return res.status(200).json({ message: `${page} not found in ${pages}` });\n  }\n})\n\napp.listen(3000, () => console.log('listening on port 3000!'))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["但最为麻烦的地方是 ",(0,s.jsx)(n.code,{children:"client.js"}),"，之前的代码是："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React from 'react';\nimport { hydrateRoot } from 'react-dom/client';\nimport App from'./pages/index'\n\nhydrateRoot(document.getElementById('root'), <App />);\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们是固定导入的 App 组件，现在改成了跟随路由导入不同的组件，也就是说导入的组件要跟随路由不同而不同，然后打包成不同的 client.bundle.js。"}),"\n",(0,s.jsxs)(n.p,{children:["一种方案是打包 pages 下的文件，分别对应生成不同的 bundle.js，比如 ",(0,s.jsx)(n.code,{children:"index.js"}),"生成 ",(0,s.jsx)(n.code,{children:"index.bundle.js"}),"，",(0,s.jsx)(n.code,{children:"cat.js"}),"生成 ",(0,s.jsx)(n.code,{children:"cat.bundle.js"}),"，然后我们根据路由引入不同的 bundle.js。"]}),"\n",(0,s.jsxs)(n.p,{children:["一种方案可以参考最早的 ",(0,s.jsx)(n.a,{href:"https://github.com/vercel/next.js/tree/1.0.0",target:"_blank",rel:"noopener noreferrer",children:"Next.js v1.0.0 源码"}),"，可以说是简单粗暴的解决了这个问题，那就是用 node.fs 读取 pages 下的文件，然后放入到 ",(0,s.jsx)(n.code,{children:"window.__DATA__"}),"，然后客户端渲染的时候获取组件代码进行渲染，伪代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const {\n  __NEXT_DATA__: { component }\n} = window\n\nconst Component = evalScript(component).default\n\nrender(createElement(Component, appProps), container)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这两种方案都有些麻烦，这里我们直接使用 Webpack 动态加载来实现，修改 ",(0,s.jsx)(n.code,{children:"client.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React from 'react';\nimport { hydrateRoot } from 'react-dom/client';\n\nconst { props, page } = window.__DATA__\n\nconst importFile = async (path) => {\n  return await import (`./pages/${path}.js`)\n}\nconst data = await importFile(page)\nconst Component = data.default\n\nhydrateRoot(document.getElementById('root'), <Component {...props} />);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"pages"})," 目录下再新建一个 counter.js，代码如下:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useState } from 'react';\n\nexport default function MyApp() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <h1>Counters { count } times</h1>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["重新运行 ",(0,s.jsx)(n.code,{children:"npm start"}),"，访问 ",(0,s.jsx)(n.code,{children:"http://localhost:3000/"}),"，效果如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"react-rsc-19.gif"})}),"\n",(0,s.jsx)(n.p,{children:"当访问未定义的路由时，会出现错误提示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"功能实现：React SSR 实现路由"}),"\n",(0,s.jsxs)(n.li,{children:["源码地址：",(0,s.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-3",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-3"})]}),"\n",(0,s.jsxs)(n.li,{children:["下载代码：",(0,s.jsx)(n.code,{children:"git clone -b react-ssr-3 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-实现-react-ssg",children:["2. 实现 React SSG",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-实现-react-ssg",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"SSG 会在构建阶段，就将页面编译为静态的 HTML 文件。"}),"\n",(0,s.jsx)(n.p,{children:"其实核心方法不变，还是用 renderToString，只不过不写在路由中，而是渲染成具体的 HTML 文件。"}),"\n",(0,s.jsxs)(n.p,{children:["让我们新建一个 ",(0,s.jsx)(n.code,{children:"build.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { existsSync, readdirSync, mkdirSync, writeFileSync } from 'node:fs';\nimport { renderToString } from 'react-dom/server';\nimport { createElement } from 'react'\nimport { join } from \"path\";\n\nconst pagesDir = join(process.cwd(), \"/pages\")\nconst pages = readdirSync(pagesDir).map(page => page.split(\".\")[0]);\n\nif (!existsSync('output')) {\n  mkdirSync('output');\n}\n\npages.forEach(async (page) => {\n  const file = await import(`./pages/${page}.js`);\n  const Component = file.default;\n\n  let propsObj = {};\n  if (file.getServerSideProps) {\n    const { props } = await file.getServerSideProps();\n    propsObj = props\n  }\n  \n  const content = renderToString(createElement(Component, propsObj))\n  writeFileSync(\n    `output/${page}.html`,\n    `    <html>\n    <head>\n        <title>Tiny React SSR</title>\n    </head>\n    <body>\n     <div id='root'>${content}</div>\n     <script>\n       window.__DATA__ = ${JSON.stringify({\n      props: propsObj,\n      page: page\n    })}\n     <\/script>\n     <script src=\"../public/client.bundle.js\"><\/script>\n    </body>\n </html>`\n  );\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["为了让 node 能够正确运行 ",(0,s.jsx)(n.code,{children:"build.js"}),"，我们需要新建一个 ",(0,s.jsx)(n.code,{children:"webpack.build.js"})," 文件用于打包 build.js 文件："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const path = require('path') \n\nmodule.exports = {\n  mode:'development',\n  target: 'node',\n  entry: './build.js',       \n  output: {                     \n    filename: 'build.bundle.js',    \n    path: path.resolve(__dirname, 'build')    \n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      }\n    ]\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["现在让我们在 ",(0,s.jsx)(n.code,{children:"package.json"})," 中添加一个脚本命令："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'{\n  "scripts": {\n    "build": "webpack --config webpack.client.js && webpack --config webpack.build.js && node ./build/build.bundle.js"\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["现在运行 ",(0,s.jsx)(n.code,{children:"npm run build"}),"，",(0,s.jsx)(n.code,{children:"output"}),"文件夹下会生成两个 HTML 文件："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"浏览器直接打开这两个文件，都能正常运行："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"react-rsc-20.gif"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"功能实现：React SSG"}),"\n",(0,s.jsxs)(n.li,{children:["源码地址：",(0,s.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-4",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-4"})]}),"\n",(0,s.jsxs)(n.li,{children:["下载代码：",(0,s.jsx)(n.code,{children:"git clone -b react-ssr-4 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-实现-react-isr",children:["3. 实现 React ISR",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-实现-react-isr",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"SSG 都实现了，就让我们再实现一个 ISR 吧！"}),"\n",(0,s.jsx)(n.p,{children:"其实原理很简单，就是在访问的时候检查是否过期，如果过期了，就重新生成 HTML 文件。"}),"\n",(0,s.jsxs)(n.p,{children:["新建 ",(0,s.jsx)(n.code,{children:"isr.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import express from 'express'\nimport { createElement } from 'react'\nimport { renderToString } from 'react-dom/server'\nimport { existsSync, readdirSync, mkdirSync, writeFileSync, stat } from 'node:fs';\nimport { join } from \"path\";\n\nconst app = express()\napp.use(express.static('public'));\n\nasync function asyncForEach(array, callback) {\n  for (let index = 0; index < array.length; index++) {\n    await callback(array[index], index, array);\n  }\n}\n\nconst pagesDir = join(process.cwd(), \"/pages\")\nconst pages = readdirSync(pagesDir).map(page => page.split(\".\")[0]);\n\nconst expiresTime = 1000 * 10;\n\nasync function build() {\n  if (!existsSync('output')) {\n    mkdirSync('output');\n  }\n\n  await asyncForEach(pages, async (page) => {\n    const file = await import(`./pages/${page}.js`);\n    const Component = file.default;\n\n    let propsObj = {};\n    if (file.getServerSideProps) {\n      const { props } = await file.getServerSideProps();\n      propsObj = props\n    }\n\n    const content = renderToString(createElement(Component, propsObj))\n    writeFileSync(\n      `output/${page}.html`,\n      `    <html>\n      <head>\n          <title>Tiny React SSR</title>\n      </head>\n      <body>\n       <div id='root'>${content}</div>\n       <script>\n         window.__DATA__ = ${JSON.stringify({\n        props: propsObj,\n        page: page\n      })}\n       <\/script>\n       <script src=\"/client.bundle.js\"><\/script>\n      </body>\n   </html>`\n    );\n  })\n}\n\napp.get(/.*$/, async (req, res) => {\n\n  const path = req.path.split('/')[1]\n  const page = path ? path : 'index'\n\n  if (pages.includes(page)) {\n\n    const htmlPath = join('./output', page + '.html')\n\n    stat(htmlPath, async function (err, stats) {\n      if (err) {\n          await build()\n          return res.sendFile(join(process.cwd(), \"output\", page + '.html'));\n      }\n      if (Date.now() - stats.mtime > expiresTime) {\n        await build()\n        return res.sendFile(join(process.cwd(), \"output\", page + '.html'));\n      } else {\n        return res.sendFile(join(process.cwd(), \"output\", page + '.html'));\n      }\n    });\n  } else {\n    return res.status(200).json({ message: `${page} not found in ${pages}` });\n  }\n})\n\napp.listen(3000, () => console.log('listening on port 3000!'))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["为了编译 isr.js 文件，新建 ",(0,s.jsx)(n.code,{children:"webpack.isr.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const path = require('path') \n\nmodule.exports = {\n  mode:'development',\n  target: 'node',\n  entry: './isr.js',       \n  output: {                     \n    filename: 'isr.bundle.js',    \n    path: path.resolve(__dirname, 'build')    \n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['@babel/preset-env', '@babel/preset-react']\n          }\n        }\n      }\n    ]\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"packages.json"}),"文件添加对应的脚本命令："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'{\n  "scripts": {\n    "isr": "webpack --config webpack.isr.js && node ./build/isr.bundle.js"\n  }\n}\n\n'})}),"\n",(0,s.jsxs)(n.p,{children:["运行 ",(0,s.jsx)(n.code,{children:"npm run isr"}),"，交互效果如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"react-ssr-3.gif"})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，10s 后图片数据发生了更新。"}),"\n",(0,s.jsx)(n.p,{children:"注：当然这个 ISR 的实现并不算贴近 Next.js 的 ISR 实现，Next.js 的 ISR 是在超过验证时间的首次，依然返回之前的结果，同时进行更新，然后下次访问才返回新的结果。这里我们直接同步构建并返回了新的结果。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"功能实现：React ISR"}),"\n",(0,s.jsxs)(n.li,{children:["源码地址：",(0,s.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-5",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-5"})]}),"\n",(0,s.jsxs)(n.li,{children:["下载代码：",(0,s.jsx)(n.code,{children:"git clone -b react-ssr-5 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本篇我们优化了 React SSR 的功能，并在此基础上实现了 React SSG 和 React ISR，但至此实现的都是 Next.js 的 Pages Router，也就是 Next.js v13 之前的实现。"}),"\n",(0,s.jsx)(n.p,{children:"Next.js v13 推出了基于 React Server Components 的 App Router，下篇开始，我们会进入 RSC 的实现讲解。"})]})}function g(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}let x=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F64.%E6%BA%90%E7%A0%81%E7%AF%87%20_%20%E6%89%8B%E5%86%99%20React%20SSG%20%E5%92%8C%20ISR.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. 优化 Ract SSR",id:"1-优化-ract-ssr",depth:2},{text:"Step1：实现 getServerSideProps",id:"step1实现-getserversideprops",depth:3},{text:"Step2：实现路由",id:"step2实现路由",depth:3},{text:"2. 实现 React SSG",id:"2-实现-react-ssg",depth:2},{text:"3. 实现 React ISR",id:"3-实现-react-isr",depth:2},{text:"总结",id:"总结",depth:2}],title:"64.源码篇 _ 手写 React SSG 和 ISR",headingTitle:"64.源码篇 _ 手写 React SSG 和 ISR",frontmatter:{}}}}]);