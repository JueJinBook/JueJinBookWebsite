"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["82962"],{10813:function(e,s,n){n.r(s),n.d(s,{default:()=>t});var r=n(552676),d=n(740453);let l=n.p+"static/image/81f53ccaa7689a7eca2019832b23fef6.11aa1a88.webp",c=n.p+"static/image/9c3e1838642c060b0ec4b224fcf6d26e.55d920db.webp";function a(e){let s=Object.assign({blockquote:"blockquote",p:"p",h2:"h2",a:"a",h3:"h3",strong:"strong",code:"code",pre:"pre",img:"img",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ol:"ol",li:"li",ul:"ul"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"推荐学习指数：⭐️⭐⭐️，必学内容️"}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"1-前言",children:["1. 前言",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"本篇我们继续介绍路由。"}),"\n",(0,r.jsxs)(s.h2,{id:"2-动态路由",children:["2. 动态路由",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#2-动态路由",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"有的时候，你并不能提前知道路由的地址，就比如根据 URL 中的 id 参数展示该 id 对应的文章内容，文章那么多，我们不可能一一定义路由，这个时候就需要用到动态路由。"}),"\n",(0,r.jsxs)(s.h3,{id:"21-foldername",children:["2.1. [folderName]",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#21-foldername",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsxs)(s.strong,{children:["使用动态路由，你需要将文件夹的名字用方括号括住，比如 ",(0,r.jsx)(s.code,{children:"[id]"}),"、",(0,r.jsx)(s.code,{children:"[slug]"}),"。这个路由的具体值会传给 ",(0,r.jsx)(s.code,{children:"+page.svelte"}),"、",(0,r.jsx)(s.code,{children:"+page.js"}),"等文件。"]})}),"\n",(0,r.jsxs)(s.p,{children:["新建 ",(0,r.jsx)(s.code,{children:"src/routes/posts/[id]/+page.svelte"}),"，代码如下："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-xml",children:"<script>\n  import { page } from '$app/stores';\n  let { data } = $props();\n<\/script>\n\n{ $page.params.id } Post Content\n\n<hr />\n\n<h2>{ data.post.title }</h2>\n\n<hr />\n\n{ data.post.body }\n"})}),"\n",(0,r.jsxs)(s.p,{children:["如果 ",(0,r.jsx)(s.code,{children:"+page.svelte"}),"需要获取动态路由参数，可以从 ",(0,r.jsx)(s.code,{children:"$app/stores"}),"中获取。"]}),"\n",(0,r.jsxs)(s.p,{children:["新建 ",(0,r.jsx)(s.code,{children:"src/routes/posts/[id]/+page.js"}),"，代码如下："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-javascript",children:'import { error } from "@sveltejs/kit";\n\nexport async function load({ params }) {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/posts/${params.id}`\n  );\n  const post = await response.json();\n  if (post.title) {\n    return {\n      post,\n    };\n  }\n\n  error(404, "Not found");\n}\n'})}),"\n",(0,r.jsxs)(s.p,{children:["如果 ",(0,r.jsx)(s.code,{children:"+page(.server).js"}),"需要获取动态路由参数，可以从 ",(0,r.jsx)(s.code,{children:"load"}),"函数的 ",(0,r.jsx)(s.code,{children:"params"})," 参数中获取。"]}),"\n",(0,r.jsx)(s.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(s.h3,{id:"22-foldername-剩余参数",children:["2.2. [...folderName] 剩余参数",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#22-foldername-剩余参数",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsxs)(s.strong,{children:["在命名文件夹的时候，如果你在方括号内添加省略号，比如 ",(0,r.jsx)(s.code,{children:"[...folderName]"}),"，表示捕获匹配的所有路由片段。"]})}),"\n",(0,r.jsxs)(s.p,{children:["新建 ",(0,r.jsx)(s.code,{children:"src/routes/blog/[...id]/+page.svelte"}),"，代码如下："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-xml",children:"<script>\n  import { page } from '$app/stores';\n<\/script>\n\n{JSON.stringify($page.params, null, 2)}\n"})}),"\n",(0,r.jsxs)(s.table,{children:["\n",(0,r.jsxs)(s.thead,{children:["\n",(0,r.jsxs)(s.tr,{children:["\n",(0,r.jsx)(s.th,{children:"路由地址"}),"\n",(0,r.jsx)(s.th,{children:"params 值"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.tbody,{children:["\n",(0,r.jsxs)(s.tr,{children:["\n",(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"/blog"})}),"\n",(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:'{ "id": "" }'})}),"\n"]}),"\n",(0,r.jsxs)(s.tr,{children:["\n",(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"/blog/a"})}),"\n",(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:'{ "id": "a" }'})}),"\n"]}),"\n",(0,r.jsxs)(s.tr,{children:["\n",(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"/blog/a/b"})}),"\n",(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:'{ "id": "a/b" }'})}),"\n"]}),"\n",(0,r.jsxs)(s.tr,{children:["\n",(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"/blog/a/b/c"})}),"\n",(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:'{ "id": "a/b/c" }'})}),"\n"]}),"\n",(0,r.jsxs)(s.tr,{children:["\n",(0,r.jsx)(s.td,{children:"..."}),"\n",(0,r.jsx)(s.td,{}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["与 Next.js 不同，",(0,r.jsx)(s.code,{children:"[...folderName]"}),"也可用于路由中间，比如 ",(0,r.jsx)(s.code,{children:"src/routes/a/[...rest]/z/+page.svelte"}),"可以匹配 ",(0,r.jsx)(s.code,{children:"/a/z"}),"（此时值为空），也可匹配 ",(0,r.jsx)(s.code,{children:"/a/b/z"})," 和 ",(0,r.jsx)(s.code,{children:"/a/b/c/z"})," 等值。"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"[...folderName]"})," 这种剩余参数用法可用于渲染自定义的 404 页面。比如这样一个目录结构："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-xml",children:"src/routes/\n├ blog/\n│ ├ javascript/\n│ ├ css/\n│ ├ html/\n│ └ +error.svelte\n└ +error.svelte\n"})}),"\n",(0,r.jsxs)(s.p,{children:["当访问 ",(0,r.jsx)(s.code,{children:"/blog/javascript/react"})," 的时候，并不会渲染 ",(0,r.jsx)(s.code,{children:"blog/+error.svelte"}),"，因为没有匹配的路由。如果你想自定义该错误页面，就需要使用 [...xxx] 匹配到这些路由："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-diff",children:"  src/routes/\n  ├ blog/\n+ │ ├ [...notfound]\n+ │ │  └ +page.svelte\n  │ ├ javascript/\n  │ ├ css/\n  │ ├ html/\n  │ └ +error.svelte\n  └ +error.svelte\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"/src/routes/blog/[...notfound]/+page.svelte"}),"的代码为："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-xml",children:"import { error } from '@sveltejs/kit';\n\nexport function load(event) {\n  error(404, 'Not Found');\n}\n"})}),"\n",(0,r.jsxs)(s.h3,{id:"23-foldername-可选参数",children:["2.3. [[folderName]] 可选参数",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#23-foldername-可选参数",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsxs)(s.strong,{children:["如果将文件夹的名字用双方括号括住，比如 ",(0,r.jsx)(s.code,{children:"[[folderName]]"}),"，表示该路由段可选。"]})}),"\n",(0,r.jsxs)(s.p,{children:["像 ",(0,r.jsx)(s.code,{children:"[lang]/home"}),"可以匹配 ",(0,r.jsx)(s.code,{children:"/en/home"}),"、",(0,r.jsx)(s.code,{children:"/zh/home"}),"，但不能匹配 ",(0,r.jsx)(s.code,{children:"/home"}),"。而 ",(0,r.jsx)(s.code,{children:"[[lang]]/home"}),"，可以匹配 ",(0,r.jsx)(s.code,{children:"/en/home"}),"、",(0,r.jsx)(s.code,{children:"/zh/home"}),"，也可以匹配 ",(0,r.jsx)(s.code,{children:"/home"}),"。"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["注意：可选参数不能跟在剩余参数后面 (",(0,r.jsx)(s.code,{children:"[...rest]/[[optional]]"}),"这样是不行的)，因为参数会贪婪匹配，可选参数将始终为空"]}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"3-匹配器",children:["3. 匹配器",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#3-匹配器",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["匹配器可以让路由进行更精确的匹配。比如 ",(0,r.jsx)(s.code,{children:"src/routes/posts/[id]"}),"，我只希望匹配 id 从 1 到 50 的整数（因为我们用的模拟数据接口就只支持 1 到 100，为了做区分，我们只匹配 1 到 50），此时就可以借助匹配器。"]}),"\n",(0,r.jsxs)(s.p,{children:["匹配器的用法比较特殊。首先在 ",(0,r.jsx)(s.code,{children:"src/params"}),"文件夹下建一个导出 ",(0,r.jsx)(s.code,{children:"match"})," 函数的文件。"]}),"\n",(0,r.jsxs)(s.p,{children:["新建 ",(0,r.jsx)(s.code,{children:"src/params/blog.js"}),"，代码如下："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-javascript",children:"export function match(param) {\n  return Number.isInteger(+param) && param > 0 && param < 51;\n}\n"})}),"\n",(0,r.jsx)(s.p,{children:"该函数会接受动态路由值作为参数，通过返回 true/false 决定是否成功匹配。如果不匹配，则会继续进行其他匹配，如果都不匹配，则是 404。"}),"\n",(0,r.jsx)(s.p,{children:"然后修改文件夹的名称："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-diff",children:"-src/routes/posts/[id]\n+src/routes/posts/[id=blog]\n"})}),"\n",(0,r.jsxs)(s.p,{children:["此时访问 ",(0,r.jsx)(s.a,{href:"http://localhost:5173/posts/52",title:"http://localhost:5173/posts/52",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(s.a,{href:"http://localhost:5173/posts/52",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:5173/posts/52"})}),"，浏览器效果如下："]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["注意：",(0,r.jsx)(s.code,{children:"src/params"}),"的每个模块都对应一个匹配器。匹配器既运行在服务端也运行在客户端。"]}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"4-优先级",children:["4. 优先级",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#4-优先级",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"当多个路由都匹配一个路径的时候，就需要进行优先级判断。比如："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-diff",children:"src/routes/[...catchall]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/foo-abc/+page.svelte\n"})}),"\n",(0,r.jsxs)(s.p,{children:["这些路由都可以匹配 ",(0,r.jsx)(s.code,{children:"/foo-abc"}),"，那访问 ",(0,r.jsx)(s.code,{children:"/foo-abc"}),"的时候，会使用哪个文件进行处理呢？"]}),"\n",(0,r.jsx)(s.p,{children:"优先级规则："}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"更具体的路由优先级更高（比如普通路由比动态路由更具体）"}),"\n",(0,r.jsx)(s.li,{children:"带匹配器的路由比不带匹配器的路由优先级更高"}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"[[optional]]"})," 和 ",(0,r.jsx)(s.code,{children:"[...rest]"}),"以最低优先级进行处理"]}),"\n",(0,r.jsx)(s.li,{children:"如果前面都一样那就按字母顺序解决"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"所以让我们再回看下这个例子，它的优先级排序应该是："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-diff",children:"# 15-SvelteKit ❘ 高级路由\nsrc/routes/foo-abc/+page.svelte\n# 2.\nsrc/routes/foo-[c]/+page.svelte\n# 3. 带匹配器\nsrc/routes/[[a=x]]/+page.svelte\n# 4.\nsrc/routes/[b]/+page.svelte\n# 5.\nsrc/routes/[...catchall]/+page.svelte\n"})}),"\n",(0,r.jsxs)(s.h2,{id:"5-路由组",children:["5. 路由组",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#5-路由组",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsxs)(s.strong,{children:["将文件夹用括号括住如",(0,r.jsx)(s.code,{children:"(auth)"}),"就可以声明一个路由组，"]})," 比如这样一个目录："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-diff",children:"src/routes/\n│ (app)/\n│ ├ dashboard/\n│ ├ item/\n│ └ +layout.svelte\n│ (marketing)/\n│ ├ about/\n│ ├ testimonials/\n│ └ +layout.svelte\n├ admin/\n└ +layout.svelte\n"})}),"\n",(0,r.jsxs)(s.p,{children:["首先路由组并不会影响路由地址，比如 ",(0,r.jsx)(s.code,{children:"src/routes/(app)/dashboard"}),"对应的路由地址依然是 ",(0,r.jsx)(s.code,{children:"/dashboard"}),"。"]}),"\n",(0,r.jsxs)(s.p,{children:["然后使用路由组可以让不同路由组使用不同的布局结构。比如 ",(0,r.jsx)(s.code,{children:"(app)/dashboard"}),"和",(0,r.jsx)(s.code,{children:"(app)/item"}),"使用 ",(0,r.jsx)(s.code,{children:"(app)/+layout.svelte"}),"布局，而 ",(0,r.jsx)(s.code,{children:"(marketing)/about"}),"和",(0,r.jsx)(s.code,{children:"(marketing)/testimonials"}),"使用 ",(0,r.jsx)(s.code,{children:"(marketing)/+layout.svelte"}),"布局。而 admin 只使用 ",(0,r.jsx)(s.code,{children:"+layout.svelte"})," 布局。"]}),"\n",(0,r.jsxs)(s.h3,{id:"51-脱离布局",children:["5.1. 脱离布局",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#51-脱离布局",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"通常，布局会进行继承，比如这样一个目录结构："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-diff",children:"src/routes/\n├ (app)/\n│ ├ item/\n│ │ ├ [id]/\n│ │ │ ├ embed/\n│ │ │ │ └ +page.svelte\n│ │ │ └ +layout.svelte\n│ │ └ +layout.svelte\n│ └ +layout.svelte\n└ +layout.svelte\n"})}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"(app)/item/[id]/embed/+page.svelte"}),"会继承根布局、",(0,r.jsx)(s.code,{children:"(app)"})," 布局、",(0,r.jsx)(s.code,{children:"item"})," 布局、",(0,r.jsx)(s.code,{children:"[id]"})," 布局。"]}),"\n",(0,r.jsxs)(s.p,{children:["我们可以通过在文件名中添加 ",(0,r.jsx)(s.code,{children:"@"}),"指定继承的布局。比如："]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"+page@[id].svelte"}),"： 继承 ",(0,r.jsx)(s.code,{children:"src/routes/(app)/item/[id]/+layout.svelte"}),"，跟当前一致"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"+page@item.svelte"}),"： 继承 ",(0,r.jsx)(s.code,{children:"src/routes/(app)/item/+layout.svelte"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"+page@(app).svelte"}),"： 继承 ",(0,r.jsx)(s.code,{children:"src/routes/(app)/+layout.svelte"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"+page@.svelte"}),"： 继承 ",(0,r.jsx)(s.code,{children:"src/routes/+layout.svelte"})]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["指定继承的布局后，比如 ",(0,r.jsx)(s.code,{children:"+page@(app).svelte"})," 会继承根布局、(app) 布局，但不会继承 ",(0,r.jsx)(s.code,{children:"item"})," 布局、",(0,r.jsx)(s.code,{children:"[id]"})," 布局的内容。"]}),"\n",(0,r.jsx)(s.p,{children:"布局也可以指定继承的布局："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-diff",children:"src/routes/\n├ (app)/\n│ ├ item/\n│ │ ├ [id]/\n│ │ │ ├ embed/\n│ │ │ │ └ +page.svelte  // 使用 (app)/item/[id]/+layout.svelte\n│ │ │ ├ +layout.svelte  // 继承 from (app)/item/+layout@.svelte\n│ │ │ └ +page.svelte    // 使用 (app)/item/+layout@.svelte\n│ │ └ +layout@.svelte   // 继承根布局, 会跳过 (app)/+layout.svelte\n│ └ +layout.svelte\n└ +layout.svelte\n"})}),"\n",(0,r.jsxs)(s.h2,{id:"最后",children:["最后",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"路由是每一个全栈框架的基础知识，可以在开发中慢慢体会。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,d.ah)(),e.components);return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let t=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F15-SvelteKit%20%E2%9D%98%20%E9%AB%98%E7%BA%A7%E8%B7%AF%E7%94%B1.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. 动态路由",id:"2-动态路由",depth:2},{text:"2.1. [folderName]",id:"21-foldername",depth:3},{text:"2.2. [...folderName] 剩余参数",id:"22-foldername-剩余参数",depth:3},{text:"2.3. [[folderName]] 可选参数",id:"23-foldername-可选参数",depth:3},{text:"3. 匹配器",id:"3-匹配器",depth:2},{text:"4. 优先级",id:"4-优先级",depth:2},{text:"5. 路由组",id:"5-路由组",depth:2},{text:"5.1. 脱离布局",id:"51-脱离布局",depth:3},{text:"最后",id:"最后",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);