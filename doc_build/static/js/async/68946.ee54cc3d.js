"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["68946"],{448409:function(e,n,c){c.r(n),c.d(n,{default:()=>l});var s=c(552676),r=c(740453);function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",ul:"ul",li:"li",strong:"strong",h3:"h3"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"6正则的扩展",children:["6.正则的扩展",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6正则的扩展",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"regexp-构造函数",children:["RegExp 构造函数",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#regexp-构造函数",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 ES5 中，",(0,s.jsx)(n.code,{children:"RegExp"}),"构造函数的参数有两种情况。"]}),"\n",(0,s.jsx)(n.p,{children:"第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"var regex = new RegExp('xyz', 'i');\n// 等价于\nvar regex = /xyz/i;\n"})}),"\n",(0,s.jsx)(n.p,{children:"第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"var regex = new RegExp(/xyz/i);\n// 等价于\nvar regex = /xyz/i;\n"})}),"\n",(0,s.jsx)(n.p,{children:"但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"var regex = new RegExp(/xyz/, 'i');\n// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another\n"})}),"\n",(0,s.jsxs)(n.p,{children:["ES6 改变了这种行为。如果",(0,s.jsx)(n.code,{children:"RegExp"}),"构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"new RegExp(/abc/ig, 'i').flags\n// \"i\"\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，原有正则对象的修饰符是",(0,s.jsx)(n.code,{children:"ig"}),"，它会被第二个参数",(0,s.jsx)(n.code,{children:"i"}),"覆盖。"]}),"\n",(0,s.jsxs)(n.h2,{id:"字符串的正则方法",children:["字符串的正则方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#字符串的正则方法",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：",(0,s.jsx)(n.code,{children:"match()"}),"、",(0,s.jsx)(n.code,{children:"replace()"}),"、",(0,s.jsx)(n.code,{children:"search()"}),"和",(0,s.jsx)(n.code,{children:"split()"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["ES6 将这 4 个方法，在语言内部全部调用",(0,s.jsx)(n.code,{children:"RegExp"}),"的实例方法，从而做到所有与正则相关的方法，全都定义在",(0,s.jsx)(n.code,{children:"RegExp"}),"对象上。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"String.prototype.match"})," 调用 ",(0,s.jsx)(n.code,{children:"RegExp.prototype[Symbol.match]"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"String.prototype.replace"})," 调用 ",(0,s.jsx)(n.code,{children:"RegExp.prototype[Symbol.replace]"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"String.prototype.search"})," 调用 ",(0,s.jsx)(n.code,{children:"RegExp.prototype[Symbol.search]"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"String.prototype.split"})," 调用 ",(0,s.jsx)(n.code,{children:"RegExp.prototype[Symbol.split]"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"u-修饰符",children:["u 修饰符",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#u-修饰符",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["ES6 对正则表达式添加了",(0,s.jsx)(n.code,{children:"u"}),"修饰符，含义为“Unicode 模式”，用来正确处理大于",(0,s.jsx)(n.code,{children:"\\uFFFF"}),"的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/^\uD83D/u.test('\uD83D\uDC2A') // false\n/^\uD83D/.test('\uD83D\uDC2A') // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"\uD83D\uDC2A"}),"是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为",(0,s.jsx)(n.code,{children:"true"}),"。加了",(0,s.jsx)(n.code,{children:"u"}),"修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为",(0,s.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["一旦加上",(0,s.jsx)(n.code,{children:"u"}),"修饰符号，就会修改下面这些正则表达式的行为。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"（1）点字符"})}),"\n",(0,s.jsxs)(n.p,{children:["点（",(0,s.jsx)(n.code,{children:"."}),"）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于",(0,s.jsx)(n.code,{children:"0xFFFF"}),"的 Unicode 字符，点字符不能识别，必须加上",(0,s.jsx)(n.code,{children:"u"}),"修饰符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"var s = '\uD842\uDFB7';\n\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码表示，如果不添加",(0,s.jsx)(n.code,{children:"u"}),"修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"（2）Unicode 字符表示法"})}),"\n",(0,s.jsxs)(n.p,{children:["ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上",(0,s.jsx)(n.code,{children:"u"}),"修饰符，才能识别当中的大括号，否则会被解读为量词。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('\uD842\uDFB7') // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码表示，如果不加",(0,s.jsx)(n.code,{children:"u"}),"修饰符，正则表达式无法识别",(0,s.jsx)(n.code,{children:"\\u{61}"}),"这种表示法，只会认为这匹配 61 个连续的",(0,s.jsx)(n.code,{children:"u"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"（3）量词"})}),"\n",(0,s.jsxs)(n.p,{children:["使用",(0,s.jsx)(n.code,{children:"u"}),"修饰符后，所有量词都会正确识别码点大于",(0,s.jsx)(n.code,{children:"0xFFFF"}),"的 Unicode 字符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/a{2}/.test('aa') // true\n/a{2}/u.test('aa') // true\n/\uD842\uDFB7{2}/.test('\uD842\uDFB7\uD842\uDFB7') // false\n/\uD842\uDFB7{2}/u.test('\uD842\uDFB7\uD842\uDFB7') // true\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"（4）预定义模式"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"u"}),"修饰符也影响到预定义模式，能否正确识别码点大于",(0,s.jsx)(n.code,{children:"0xFFFF"}),"的 Unicode 字符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/^\\S$/.test('\uD842\uDFB7') // false\n/^\\S$/u.test('\uD842\uDFB7') // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码的",(0,s.jsx)(n.code,{children:"\\S"}),"是预定义模式，匹配所有非空白字符。只有加了",(0,s.jsx)(n.code,{children:"u"}),"修饰符，它才能正确匹配码点大于",(0,s.jsx)(n.code,{children:"0xFFFF"}),"的 Unicode 字符。"]}),"\n",(0,s.jsx)(n.p,{children:"利用这一点，可以写出一个正确返回字符串长度的函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function codePointLength(text) {\n  var result = text.match(/[\\s\\S]/gu);\n  return result ? result.length : 0;\n}\n\nvar s = '\uD842\uDFB7\uD842\uDFB7';\n\ns.length // 4\ncodePointLength(s) // 2\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"（5）i 修饰符"})}),"\n",(0,s.jsxs)(n.p,{children:["有些 Unicode 字符的编码不同，但是字型很相近，比如，",(0,s.jsx)(n.code,{children:"\\u004B"}),"与",(0,s.jsx)(n.code,{children:"\\u212A"}),"都是大写的",(0,s.jsx)(n.code,{children:"K"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/[a-z]/i.test('\\u212A') // false\n/[a-z]/iu.test('\\u212A') // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，不加",(0,s.jsx)(n.code,{children:"u"}),"修饰符，就无法识别非规范的",(0,s.jsx)(n.code,{children:"K"}),"字符。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"（6）转义"})}),"\n",(0,s.jsxs)(n.p,{children:["没有",(0,s.jsx)(n.code,{children:"u"}),"修饰符的情况下，正则中没有定义的转义（如逗号的转义",(0,s.jsx)(n.code,{children:"\\,"}),"）无效，而在",(0,s.jsx)(n.code,{children:"u"}),"模式会报错。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/\\,/ // /\\,/\n/\\,/u // 报错\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，没有",(0,s.jsx)(n.code,{children:"u"}),"修饰符时，逗号前面的反斜杠是无效的，加了",(0,s.jsx)(n.code,{children:"u"}),"修饰符就报错。"]}),"\n",(0,s.jsxs)(n.h2,{id:"regexpprototypeunicode-属性",children:["RegExp.prototype.unicode 属性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#regexpprototypeunicode-属性",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["正则实例对象新增",(0,s.jsx)(n.code,{children:"unicode"}),"属性，表示是否设置了",(0,s.jsx)(n.code,{children:"u"}),"修饰符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const r1 = /hello/;\nconst r2 = /hello/u;\n\nr1.unicode // false\nr2.unicode // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，正则表达式是否设置了",(0,s.jsx)(n.code,{children:"u"}),"修饰符，可以从",(0,s.jsx)(n.code,{children:"unicode"}),"属性看出来。"]}),"\n",(0,s.jsxs)(n.h2,{id:"y-修饰符",children:["y 修饰符",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#y-修饰符",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["除了",(0,s.jsx)(n.code,{children:"u"}),"修饰符，ES6 还为正则表达式添加了",(0,s.jsx)(n.code,{children:"y"}),"修饰符，叫做“粘连”（sticky）修饰符。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"y"}),"修饰符的作用与",(0,s.jsx)(n.code,{children:"g"}),"修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，",(0,s.jsx)(n.code,{children:"g"}),"修饰符只要剩余位置中存在匹配就可，而",(0,s.jsx)(n.code,{children:"y"}),"修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'var s = \'aaa_aa_a\';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s) // ["aaa"]\nr2.exec(s) // ["aaa"]\n\nr1.exec(s) // ["aa"]\nr2.exec(s) // null\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码有两个正则表达式，一个使用",(0,s.jsx)(n.code,{children:"g"}),"修饰符，另一个使用",(0,s.jsx)(n.code,{children:"y"}),"修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是",(0,s.jsx)(n.code,{children:"_aa_a"}),"。由于",(0,s.jsx)(n.code,{children:"g"}),"修饰没有位置要求，所以第二次执行会返回结果，而",(0,s.jsx)(n.code,{children:"y"}),"修饰符要求匹配必须从头部开始，所以返回",(0,s.jsx)(n.code,{children:"null"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果改一下正则表达式，保证每次都能头部匹配，",(0,s.jsx)(n.code,{children:"y"}),"修饰符就会返回结果了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'var s = \'aaa_aa_a\';\nvar r = /a+_/y;\n\nr.exec(s) // ["aaa_"]\nr.exec(s) // ["aa_"]\n'})}),"\n",(0,s.jsx)(n.p,{children:"上面代码每次匹配，都是从剩余字符串的头部开始。"}),"\n",(0,s.jsxs)(n.p,{children:["使用",(0,s.jsx)(n.code,{children:"lastIndex"}),"属性，可以更好地说明",(0,s.jsx)(n.code,{children:"y"}),"修饰符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const REGEX = /a/g;\n\n// 指定从2号位置（y）开始匹配\nREGEX.lastIndex = 2;\n\n// 匹配成功\nconst match = REGEX.exec('xaya');\n\n// 在3号位置匹配成功\nmatch.index // 3\n\n// 下一次匹配从4号位开始\nREGEX.lastIndex // 4\n\n// 4号位开始匹配失败\nREGEX.exec('xaya') // null\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"lastIndex"}),"属性指定每次搜索的开始位置，",(0,s.jsx)(n.code,{children:"g"}),"修饰符从这个位置开始向后搜索，直到发现匹配为止。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"y"}),"修饰符同样遵守",(0,s.jsx)(n.code,{children:"lastIndex"}),"属性，但是要求必须在",(0,s.jsx)(n.code,{children:"lastIndex"}),"指定的位置发现匹配。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const REGEX = /a/y;\n\n// 指定从2号位置开始匹配\nREGEX.lastIndex = 2;\n\n// 不是粘连，匹配失败\nREGEX.exec('xaya') // null\n\n// 指定从3号位置开始匹配\nREGEX.lastIndex = 3;\n\n// 3号位置是粘连，匹配成功\nconst match = REGEX.exec('xaya');\nmatch.index // 3\nREGEX.lastIndex // 4\n"})}),"\n",(0,s.jsxs)(n.p,{children:["实际上，",(0,s.jsx)(n.code,{children:"y"}),"修饰符号隐含了头部匹配的标志",(0,s.jsx)(n.code,{children:"^"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/b/y.exec('aba')\n// null\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码由于不能保证头部匹配，所以返回",(0,s.jsx)(n.code,{children:"null"}),"。",(0,s.jsx)(n.code,{children:"y"}),"修饰符的设计本意，就是让头部匹配的标志",(0,s.jsx)(n.code,{children:"^"}),"在全局匹配中都有效。"]}),"\n",(0,s.jsxs)(n.p,{children:["下面是字符串对象的",(0,s.jsx)(n.code,{children:"replace"}),"方法的例子。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const REGEX = /a/gy;\n'aaxa'.replace(REGEX, '-') // '--xa'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，最后一个",(0,s.jsx)(n.code,{children:"a"}),"因为不是出现在下一次匹配的头部，所以不会被替换。"]}),"\n",(0,s.jsxs)(n.p,{children:["单单一个",(0,s.jsx)(n.code,{children:"y"}),"修饰符对",(0,s.jsx)(n.code,{children:"match"}),"方法，只能返回第一个匹配，必须与",(0,s.jsx)(n.code,{children:"g"}),"修饰符联用，才能返回所有匹配。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'\'a1a2a3\'.match(/a\\d/y) // ["a1"]\n\'a1a2a3\'.match(/a\\d/gy) // ["a1", "a2", "a3"]\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"y"}),"修饰符的一个应用，是从字符串提取 token（词元），",(0,s.jsx)(n.code,{children:"y"}),"修饰符确保了匹配之间不会有漏掉的字符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y;\nconst TOKEN_G  = /\\s*(\\+|[0-9]+)\\s*/g;\n\ntokenize(TOKEN_Y, '3 + 4')\n// [ '3', '+', '4' ]\ntokenize(TOKEN_G, '3 + 4')\n// [ '3', '+', '4' ]\n\nfunction tokenize(TOKEN_REGEX, str) {\n  let result = [];\n  let match;\n  while (match = TOKEN_REGEX.exec(str)) {\n    result.push(match[1]);\n  }\n  return result;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，如果字符串里面没有非法字符，",(0,s.jsx)(n.code,{children:"y"}),"修饰符与",(0,s.jsx)(n.code,{children:"g"}),"修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"tokenize(TOKEN_Y, '3x + 4')\n// [ '3' ]\ntokenize(TOKEN_G, '3x + 4')\n// [ '3', '+', '4' ]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"g"}),"修饰符会忽略非法字符，而",(0,s.jsx)(n.code,{children:"y"}),"修饰符不会，这样就很容易发现错误。"]}),"\n",(0,s.jsxs)(n.h2,{id:"regexpprototypesticky-属性",children:["RegExp.prototype.sticky 属性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#regexpprototypesticky-属性",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["与",(0,s.jsx)(n.code,{children:"y"}),"修饰符相匹配，ES6 的正则实例对象多了",(0,s.jsx)(n.code,{children:"sticky"}),"属性，表示是否设置了",(0,s.jsx)(n.code,{children:"y"}),"修饰符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"var r = /hello\\d/y;\nr.sticky // true\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"regexpprototypeflags-属性",children:["RegExp.prototype.flags 属性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#regexpprototypeflags-属性",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["ES6 为正则表达式新增了",(0,s.jsx)(n.code,{children:"flags"}),"属性，会返回正则表达式的修饰符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// ES5 的 source 属性\n// 返回正则表达式的正文\n/abc/ig.source\n// \"abc\"\n\n// ES6 的 flags 属性\n// 返回正则表达式的修饰符\n/abc/ig.flags\n// 'gi'\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"s-修饰符dotall-模式",children:["s 修饰符：dotAll 模式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#s-修饰符dotall-模式",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["正则表达式中，点（",(0,s.jsx)(n.code,{children:"."}),"）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用",(0,s.jsx)(n.code,{children:"u"}),"修饰符解决；另一个是行终止符（line terminator character）。"]}),"\n",(0,s.jsx)(n.p,{children:"所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["U+000A 换行符（",(0,s.jsx)(n.code,{children:"\\n"}),"）"]}),"\n",(0,s.jsxs)(n.li,{children:["U+000D 回车符（",(0,s.jsx)(n.code,{children:"\\r"}),"）"]}),"\n",(0,s.jsx)(n.li,{children:"U+2028 行分隔符（line separator）"}),"\n",(0,s.jsx)(n.li,{children:"U+2029 段分隔符（paragraph separator）"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/foo.bar/.test('foo\\nbar')\n// false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，因为",(0,s.jsx)(n.code,{children:"."}),"不匹配",(0,s.jsx)(n.code,{children:"\\n"}),"，所以正则表达式返回",(0,s.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/foo[^]bar/.test('foo\\nbar')\n// true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这种解决方案毕竟不太符合直觉，ES2018 ",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-regexp-dotall-flag",target:"_blank",rel:"noopener noreferrer",children:"引入"}),(0,s.jsx)(n.code,{children:"s"}),"修饰符，使得",(0,s.jsx)(n.code,{children:"."}),"可以匹配任意单个字符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/foo.bar/s.test('foo\\nbar') // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这被称为",(0,s.jsx)(n.code,{children:"dotAll"}),"模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个",(0,s.jsx)(n.code,{children:"dotAll"}),"属性，返回一个布尔值，表示该正则表达式是否处在",(0,s.jsx)(n.code,{children:"dotAll"}),"模式。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const re = /foo.bar/s;\n// 另一种写法\n// const re = new RegExp('foo.bar', 's');\n\nre.test('foo\\nbar') // true\nre.dotAll // true\nre.flags // 's'\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"/s"}),"修饰符和多行修饰符",(0,s.jsx)(n.code,{children:"/m"}),"不冲突，两者一起使用的情况下，",(0,s.jsx)(n.code,{children:"."}),"匹配所有字符，而",(0,s.jsx)(n.code,{children:"^"}),"和",(0,s.jsx)(n.code,{children:"$"}),"匹配每一行的行首和行尾。"]}),"\n",(0,s.jsxs)(n.h2,{id:"后行断言",children:["后行断言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#后行断言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-regexp-lookbehind",target:"_blank",rel:"noopener noreferrer",children:"后行断言"}),"，V8 引擎 4.9 版（Chrome 62）已经支持。"]}),"\n",(0,s.jsxs)(n.p,{children:["“先行断言”指的是，",(0,s.jsx)(n.code,{children:"x"}),"只有在",(0,s.jsx)(n.code,{children:"y"}),"前面才匹配，必须写成",(0,s.jsx)(n.code,{children:"/x(?=y)/"}),"。比如，只匹配百分号之前的数字，要写成",(0,s.jsx)(n.code,{children:"/\\d+(?=%)/"}),"。“先行否定断言”指的是，",(0,s.jsx)(n.code,{children:"x"}),"只有不在",(0,s.jsx)(n.code,{children:"y"}),"前面才匹配，必须写成",(0,s.jsx)(n.code,{children:"/x(?!y)/"}),"。比如，只匹配不在百分号之前的数字，要写成",(0,s.jsx)(n.code,{children:"/\\d+(?!%)/"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/\\d+(?=%)/.exec('100% of US presidents have been male')  // [\"100\"]\n/\\d+(?!%)/.exec('that’s all 44 of them')                 // [\"44\"]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（",(0,s.jsx)(n.code,{children:"(?=%)"}),"），是不计入返回结果的。"]}),"\n",(0,s.jsxs)(n.p,{children:["“后行断言”正好与“先行断言”相反，",(0,s.jsx)(n.code,{children:"x"}),"只有在",(0,s.jsx)(n.code,{children:"y"}),"后面才匹配，必须写成",(0,s.jsx)(n.code,{children:"/(?<=y)x/"}),"。比如，只匹配美元符号之后的数字，要写成",(0,s.jsx)(n.code,{children:"/(?<=\\$)\\d+/"}),"。“后行否定断言”则与“先行否定断言”相反，",(0,s.jsx)(n.code,{children:"x"}),"只有不在",(0,s.jsx)(n.code,{children:"y"}),"后面才匹配，必须写成",(0,s.jsx)(n.code,{children:"/(?<!y)x/"}),"。比如，只匹配不在美元符号后面的数字，要写成",(0,s.jsx)(n.code,{children:"/(?<!\\$)\\d+/"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/(?<=\\$)\\d+/.exec('Benjamin Franklin is on the $100 bill')  // [\"100\"]\n/(?<!\\$)\\d+/.exec('it’s worth about €90')                   // [\"90\"]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面的例子中，“后行断言”的括号之中的部分（",(0,s.jsx)(n.code,{children:"(?<=\\$)"}),"），也是不计入返回结果。"]}),"\n",(0,s.jsx)(n.p,{children:"下面的例子是使用后行断言进行字符串替换。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const RE_DOLLAR_PREFIX = /(?<=\\$)foo/g;\n'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar');\n// '$bar %foo foo'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，只有在美元符号后面的",(0,s.jsx)(n.code,{children:"foo"}),"才会被替换。"]}),"\n",(0,s.jsxs)(n.p,{children:["“后行断言”的实现，需要先匹配",(0,s.jsx)(n.code,{children:"/(?<=y)x/"}),"的",(0,s.jsx)(n.code,{children:"x"}),"，然后再回到左边，匹配",(0,s.jsx)(n.code,{children:"y"}),"的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。"]}),"\n",(0,s.jsx)(n.p,{children:"首先，后行断言的组匹配，与正常情况下结果是不一样的。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'/(?<=(\\d+)(\\d+))$/.exec(\'1053\') // ["", "1", "053"]\n/^(\\d+)(\\d+)$/.exec(\'1053\') // ["1053", "105", "3"]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是",(0,s.jsx)(n.code,{children:"105"}),"和",(0,s.jsx)(n.code,{children:"3"}),"。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是",(0,s.jsx)(n.code,{children:"1"}),"和",(0,s.jsx)(n.code,{children:"053"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/(?<=(o)d\\1)r/.exec('hodor')  // null\n/(?<=\\1d(o))r/.exec('hodor')  // [\"r\", \"o\"]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，如果后行断言的反斜杠引用（",(0,s.jsx)(n.code,{children:"\\1"}),"）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。"]}),"\n",(0,s.jsxs)(n.h2,{id:"unicode-属性类",children:["Unicode 属性类",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#unicode-属性类",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["ES2018 ",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-regexp-unicode-property-escapes",target:"_blank",rel:"noopener noreferrer",children:"引入"}),"了 Unicode 属性类，允许使用",(0,s.jsx)(n.code,{children:"\\p{...}"}),"和",(0,s.jsx)(n.code,{children:"\\P{...}"}),"（",(0,s.jsx)(n.code,{children:"\\P"}),"是",(0,s.jsx)(n.code,{children:"\\p"}),"的否定形式）代表一类 Unicode 字符，匹配满足条件的所有字符。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π') // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"\\p{Script=Greek}"}),"表示匹配一个希腊文字母，所以匹配",(0,s.jsx)(n.code,{children:"π"}),"成功。"]}),"\n",(0,s.jsx)(n.p,{children:"Unicode 属性类的标准形式，需要同时指定属性名和属性值。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"\\p{UnicodePropertyName=UnicodePropertyValue}\n"})}),"\n",(0,s.jsx)(n.p,{children:"但是，对于某些属性，可以只写属性名，或者只写属性值。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"\\p{UnicodePropertyName}\n\\p{UnicodePropertyValue}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"\\P{…}"}),"是",(0,s.jsx)(n.code,{children:"\\p{…}"}),"的反向匹配，即匹配不满足条件的字符。"]}),"\n",(0,s.jsxs)(n.p,{children:["注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上",(0,s.jsx)(n.code,{children:"u"}),"修饰符。如果不加",(0,s.jsx)(n.code,{children:"u"}),"修饰符，正则表达式使用",(0,s.jsx)(n.code,{children:"\\p"}),"和",(0,s.jsx)(n.code,{children:"\\P"}),"会报错。"]}),"\n",(0,s.jsx)(n.p,{children:"由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const regex = /^\\p{Decimal_Number}+$/u;\nregex.test('\uD835\uDFCF\uD835\uDFD0\uD835\uDFD1\uD835\uDFDC\uD835\uDFDD\uD835\uDFDE\uD835\uDFE9\uD835\uDFEA\uD835\uDFEB\uD835\uDFEC\uD835\uDFED\uD835\uDFEE\uD835\uDFEF\uD835\uDFFA\uD835\uDFFB\uD835\uDFFC') // true\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"\\p{Number}"}),"甚至能匹配罗马数字。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 匹配所有数字\nconst regex = /^\\p{Number}+$/u;\nregex.test('\xb2\xb3\xb9\xbc\xbd\xbe') // true\nregex.test('㉛㉜㉝') // true\nregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true\n"})}),"\n",(0,s.jsx)(n.p,{children:"下面是其他一些例子。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 匹配所有空格\n\\p{White_Space}\n\n// 匹配十六进制字符\n\\p{Hex_Digit}\n\n// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w\n[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]\n\n// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W\n[^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]\n\n// 匹配 Emoji\n/\\p{Extended_Pictographic}/u\n\n// 匹配所有的箭头字符\nconst regexArrows = /^\\p{Block=Arrows}+$/u;\nregexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"v-修饰符unicode-属性类的运算",children:["v 修饰符：Unicode 属性类的运算",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v-修饰符unicode-属性类的运算",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["有时，需要向某个 Unicode 属性类添加或减少字符，即需要对属性类进行运算。",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-regexp-v-flag",target:"_blank",rel:"noopener noreferrer",children:"ES2024"})," 增加了 Unicode 属性类的运算功能。"]}),"\n",(0,s.jsx)(n.p,{children:"它提供两种形式的运算，一种是差集运算（A 集合减去 B 集合），另一种是交集运算。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 差集运算（A 减去 B）\n[A--B]\n\n// 交集运算（A 与 B 的交集）\n[A&&B]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面两种写法中，A 和 B 要么是字符类（例如",(0,s.jsx)(n.code,{children:"[a-z]"}),"），要么是 Unicode 属性类（例如",(0,s.jsx)(n.code,{children:"\\p{ASCII}"}),"）。"]}),"\n",(0,s.jsx)(n.p,{children:"而且，这种运算支持方括号之中嵌入方括号，即方括号的嵌套。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 方括号嵌套的例子\n[A--[0-9]]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这种运算的前提是，正则表达式必须使用新引入的",(0,s.jsx)(n.code,{children:"v"}),"修饰符。前面说过，Unicode 属性类必须搭配",(0,s.jsx)(n.code,{children:"u"}),"修饰符使用，这个",(0,s.jsx)(n.code,{children:"v"}),"修饰符等于代替",(0,s.jsx)(n.code,{children:"u"}),"，使用了它就不必再写",(0,s.jsx)(n.code,{children:"u"}),"了。"]}),"\n",(0,s.jsx)(n.p,{children:"下面是一些例子。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 十进制字符去除 ASCII 码的0到9\n[\\p{Decimal_Number}--[0-9]]\n\n// Emoji 字符去除 ASCII 码字符\n[\\p{Emoji}--\\p{ASCII}]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["看一个实际的例子，",(0,s.jsx)(n.code,{children:"0"}),"属于十进制字符类。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/[\\p{Decimal_Number}]/u.test('0') // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面示例中，字符类是 Unicode 专用的，所以必须使用",(0,s.jsx)(n.code,{children:"u"}),"修饰符。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果把",(0,s.jsx)(n.code,{children:"0-9"}),"从十进制字符类里面去掉，那么",(0,s.jsx)(n.code,{children:"0"}),"就不属于这个类了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"/[\\p{Decimal_Number}--[0-9]]/v.test('0') // false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面示例中，",(0,s.jsx)(n.code,{children:"v"}),"修饰符只能用于 Unicode，所以可以省略",(0,s.jsx)(n.code,{children:"u"}),"修饰符。"]}),"\n",(0,s.jsxs)(n.h2,{id:"具名组匹配",children:["具名组匹配",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#具名组匹配",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"简介",children:["简介",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简介",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"正则表达式使用圆括号进行组匹配。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，正则表达式里面有三组圆括号。使用",(0,s.jsx)(n.code,{children:"exec"}),"方法，就可以将这三组匹配结果提取出来。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\nconst matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj[1]; // 1999\nconst month = matchObj[2]; // 12\nconst day = matchObj[3]; // 31\n"})}),"\n",(0,s.jsxs)(n.p,{children:["组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如",(0,s.jsx)(n.code,{children:"matchObj[1]"}),"）引用，要是组的顺序变了，引用的时候就必须修改序号。"]}),"\n",(0,s.jsxs)(n.p,{children:["ES2018 引入了",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-regexp-named-groups",target:"_blank",rel:"noopener noreferrer",children:"具名组匹配"}),"（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const RE_DATE = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n\nconst matchObj = RE_DATE.exec(\'1999-12-31\');\nconst year = matchObj.groups.year; // "1999"\nconst month = matchObj.groups.month; // "12"\nconst day = matchObj.groups.day; // "31"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（",(0,s.jsx)(n.code,{children:"?<year>"}),"），然后就可以在",(0,s.jsx)(n.code,{children:"exec"}),"方法返回结果的",(0,s.jsx)(n.code,{children:"groups"}),"属性上引用该组名。同时，数字序号（",(0,s.jsx)(n.code,{children:"matchObj[1]"}),"）依然有效。"]}),"\n",(0,s.jsx)(n.p,{children:"具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。"}),"\n",(0,s.jsxs)(n.p,{children:["如果具名组没有匹配，那么对应的",(0,s.jsx)(n.code,{children:"groups"}),"对象属性会是",(0,s.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const RE_OPT_A = /^(?<as>a+)?$/;\nconst matchObj = RE_OPT_A.exec('');\n\nmatchObj.groups.as // undefined\n'as' in matchObj.groups // true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，具名组",(0,s.jsx)(n.code,{children:"as"}),"没有找到匹配，那么",(0,s.jsx)(n.code,{children:"matchObj.groups.as"}),"属性值就是",(0,s.jsx)(n.code,{children:"undefined"}),"，并且",(0,s.jsx)(n.code,{children:"as"}),"这个键名在",(0,s.jsx)(n.code,{children:"groups"}),"是始终存在的。"]}),"\n",(0,s.jsxs)(n.h3,{id:"解构赋值和替换",children:["解构赋值和替换",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解构赋值和替换",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n"})}),"\n",(0,s.jsxs)(n.p,{children:["字符串替换时，使用",(0,s.jsx)(n.code,{children:"$<组名>"}),"引用具名组。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n// '02/01/2015'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"replace"}),"方法的第二个参数是一个字符串，而不是正则表达式。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"replace"}),"方法的第二个参数也可以是函数，该函数的参数序列如下。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'2015-01-02'.replace(re, (\n   matched, // 整个匹配结果 2015-01-02\n   capture1, // 第一个组匹配 2015\n   capture2, // 第二个组匹配 01\n   capture3, // 第三个组匹配 02\n   position, // 匹配开始的位置 0\n   S, // 原字符串 2015-01-02\n   groups // 具名组构成的一个对象 {year, month, day}\n ) => {\n let {day, month, year} = groups;\n return `${day}/${month}/${year}`;\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。"}),"\n",(0,s.jsxs)(n.h3,{id:"引用",children:["引用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#引用",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果要在正则表达式内部引用某个“具名组匹配”，可以使用",(0,s.jsx)(n.code,{children:"\\k<组名>"}),"的写法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["数字引用（",(0,s.jsx)(n.code,{children:"\\1"}),"）依然有效。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const RE_TWICE = /^(?<word>[a-z]+)!\\1$/;\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n"})}),"\n",(0,s.jsx)(n.p,{children:"这两种引用语法还可以同时使用。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const RE_TWICE = /^(?<word>[a-z]+)!\\k<word>!\\1$/;\nRE_TWICE.test('abc!abc!abc') // true\nRE_TWICE.test('abc!abc!ab') // false\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"d-修饰符正则匹配索引",children:["d 修饰符：正则匹配索引",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#d-修饰符正则匹配索引",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["组匹配的结果，在原始字符串里面的开始位置和结束位置，目前获取并不是很方便。正则实例的",(0,s.jsx)(n.code,{children:"exec()"}),"方法有一个",(0,s.jsx)(n.code,{children:"index"}),"属性，可以获取整个匹配结果的开始位置。但是，组匹配的每个组的开始位置，很难拿到。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-regexp-match-Indices",target:"_blank",rel:"noopener noreferrer",children:"ES2022"})," 新增了",(0,s.jsx)(n.code,{children:"d"}),"修饰符，这个修饰符可以让",(0,s.jsx)(n.code,{children:"exec()"}),"、",(0,s.jsx)(n.code,{children:"match()"}),"的返回结果添加",(0,s.jsx)(n.code,{children:"indices"}),"属性，在该属性上面可以拿到匹配的开始位置和结束位置。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const text = 'zabbcdef';\nconst re = /ab/d;\nconst result = re.exec(text);\n\nresult.index // 1\nresult.indices // [ [1, 3] ]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面示例中，",(0,s.jsx)(n.code,{children:"exec()"}),"方法的返回结果",(0,s.jsx)(n.code,{children:"result"}),"，它的",(0,s.jsx)(n.code,{children:"index"}),"属性是整个匹配结果（",(0,s.jsx)(n.code,{children:"ab"}),"）的开始位置。由于正则表达式",(0,s.jsx)(n.code,{children:"re"}),"有",(0,s.jsx)(n.code,{children:"d"}),"修饰符，",(0,s.jsx)(n.code,{children:"result"}),"现在就会多出一个",(0,s.jsx)(n.code,{children:"indices"}),"属性。该属性是一个数组，它的每个成员还是一个数组，包含了匹配结果在原始字符串的开始位置和结束位置。由于上例的正则表达式",(0,s.jsx)(n.code,{children:"re"}),"没有包含组匹配，所以",(0,s.jsx)(n.code,{children:"indices"}),"数组只有一个成员，表示整个匹配的开始位置是",(0,s.jsx)(n.code,{children:"1"}),"，结束位置是",(0,s.jsx)(n.code,{children:"3"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["注意，开始位置包含在匹配结果之中，相当于匹配结果的第一个字符的位置。但是，结束位置不包含在匹配结果之中，是匹配结果的下一个字符。比如，上例匹配结果的最后一个字符",(0,s.jsx)(n.code,{children:"b"}),"的位置，是原始字符串的2号位，那么结束位置",(0,s.jsx)(n.code,{children:"3"}),"就是下一个字符的位置。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果正则表达式包含组匹配，那么",(0,s.jsx)(n.code,{children:"indices"}),"属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const text = 'zabbcdef';\nconst re = /ab+(cd)/d;\nconst result = re.exec(text);\n\nresult.indices // [ [ 1, 6 ], [ 4, 6 ] ]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面例子中，正则表达式",(0,s.jsx)(n.code,{children:"re"}),"包含一个组匹配",(0,s.jsx)(n.code,{children:"(cd)"}),"，那么",(0,s.jsx)(n.code,{children:"indices"}),"属性数组就有两个成员，第一个成员是整个匹配结果（",(0,s.jsx)(n.code,{children:"abbcd"}),"）的开始位置和结束位置，第二个成员是组匹配（",(0,s.jsx)(n.code,{children:"cd"}),"）的开始位置和结束位置。"]}),"\n",(0,s.jsx)(n.p,{children:"下面是多个组匹配的例子。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const text = 'zabbcdef';\nconst re = /ab+(cd(ef))/d;\nconst result = re.exec(text);\n\nresult.indices // [ [1, 8], [4, 8], [6, 8] ]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面例子中，正则表达式",(0,s.jsx)(n.code,{children:"re"}),"包含两个组匹配，所以",(0,s.jsx)(n.code,{children:"indices"}),"属性数组就有三个成员。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果正则表达式包含具名组匹配，",(0,s.jsx)(n.code,{children:"indices"}),"属性数组还会有一个",(0,s.jsx)(n.code,{children:"groups"}),"属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const text = 'zabbcdef';\nconst re = /ab+(?<Z>cd)/d;\nconst result = re.exec(text);\n\nresult.indices.groups // { Z: [ 4, 6 ] }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面例子中，",(0,s.jsx)(n.code,{children:"exec()"}),"方法返回结果的",(0,s.jsx)(n.code,{children:"indices.groups"}),"属性是一个对象，提供具名组匹配",(0,s.jsx)(n.code,{children:"Z"}),"的开始位置和结束位置。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果获取组匹配不成功，",(0,s.jsx)(n.code,{children:"indices"}),"属性数组的对应成员则为",(0,s.jsx)(n.code,{children:"undefined"}),"，",(0,s.jsx)(n.code,{children:"indices.groups"}),"属性对象的对应成员也是",(0,s.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const text = 'zabbcdef';\nconst re = /ab+(?<Z>ce)?/d;\nconst result = re.exec(text);\n\nresult.indices[1] // undefined\nresult.indices.groups['Z'] // undefined\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面例子中，由于组匹配",(0,s.jsx)(n.code,{children:"ce"}),"不成功，所以",(0,s.jsx)(n.code,{children:"indices"}),"属性数组和",(0,s.jsx)(n.code,{children:"indices.groups"}),"属性对象对应的组匹配成员",(0,s.jsx)(n.code,{children:"Z"}),"都是",(0,s.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"stringprototypematchall",children:["String.prototype.matchAll()",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#stringprototypematchall",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果一个正则表达式在字符串里面有多个匹配，现在一般使用",(0,s.jsx)(n.code,{children:"g"}),"修饰符或",(0,s.jsx)(n.code,{children:"y"}),"修饰符，在循环里面逐一取出。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'var regex = /t(e)(st(\\d?))/g;\nvar string = \'test1test2test3\';\n\nvar matches = [];\nvar match;\nwhile (match = regex.exec(string)) {\n  matches.push(match);\n}\n\nmatches\n// [\n//   ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],\n//   ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],\n//   ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]\n// ]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"while"}),"循环取出每一轮的正则匹配，一共三轮。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-string-matchall",target:"_blank",rel:"noopener noreferrer",children:"ES2020"})," 增加了",(0,s.jsx)(n.code,{children:"String.prototype.matchAll()"}),"方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const string = \'test1test2test3\';\nconst regex = /t(e)(st(\\d?))/g;\n\nfor (const match of string.matchAll(regex)) {\n  console.log(match);\n}\n// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]\n// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]\n// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，由于",(0,s.jsx)(n.code,{children:"string.matchAll(regex)"}),"返回的是遍历器，所以可以用",(0,s.jsx)(n.code,{children:"for...of"}),"循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。"]}),"\n",(0,s.jsxs)(n.p,{children:["遍历器转为数组是非常简单的，使用",(0,s.jsx)(n.code,{children:"..."}),"运算符和",(0,s.jsx)(n.code,{children:"Array.from()"}),"方法就可以了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 转为数组的方法一\n[...string.matchAll(regex)]\n\n// 转为数组的方法二\nArray.from(string.matchAll(regex))\n"})})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F6.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95.md"]={toc:[{text:"RegExp 构造函数",id:"regexp-构造函数",depth:2},{text:"字符串的正则方法",id:"字符串的正则方法",depth:2},{text:"u 修饰符",id:"u-修饰符",depth:2},{text:"RegExp.prototype.unicode 属性",id:"regexpprototypeunicode-属性",depth:2},{text:"y 修饰符",id:"y-修饰符",depth:2},{text:"RegExp.prototype.sticky 属性",id:"regexpprototypesticky-属性",depth:2},{text:"RegExp.prototype.flags 属性",id:"regexpprototypeflags-属性",depth:2},{text:"s 修饰符：dotAll 模式",id:"s-修饰符dotall-模式",depth:2},{text:"后行断言",id:"后行断言",depth:2},{text:"Unicode 属性类",id:"unicode-属性类",depth:2},{text:"v 修饰符：Unicode 属性类的运算",id:"v-修饰符unicode-属性类的运算",depth:2},{text:"具名组匹配",id:"具名组匹配",depth:2},{text:"简介",id:"简介",depth:3},{text:"解构赋值和替换",id:"解构赋值和替换",depth:3},{text:"引用",id:"引用",depth:3},{text:"d 修饰符：正则匹配索引",id:"d-修饰符正则匹配索引",depth:2},{text:"String.prototype.matchAll()",id:"stringprototypematchall",depth:2}],title:"6.正则的扩展",headingTitle:"6.正则的扩展",frontmatter:{}}}}]);