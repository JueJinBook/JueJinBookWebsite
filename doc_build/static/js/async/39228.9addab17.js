"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["39228"],{646366:function(e,n,t){t.r(n),t.d(n,{default:()=>h});var o=t(552676),r=t(740453);let c=t.p+"static/image/fa748e68b5501362591285cb78dc4b02.d12eafbe.webp",s=t.p+"static/image/d549b4f54a266fa5f47db64e1efc1165.66f1fe8a.webp",d=t.p+"static/image/8137be54c856c28c69ed5d9691ad9dfc.a4c8b689.webp",l=t.p+"static/image/6a4be67bf67c911fae370d5d35e365bb.5942b100.webp",i=t.p+"static/image/64cadad465846883ced0e007cb0d87d4.a9f1db3f.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",strong:"strong",img:"img",h3:"h3",pre:"pre",ul:"ul",li:"li",h4:"h4"},(0,r.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.h1,{id:"8基础篇-提供者-context",children:["8.基础篇-提供者 context",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8基础篇-提供者-context",children:"#"})]}),"\n",(0,o.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["本章节，我们来谈谈",(0,o.jsx)(n.code,{children:" React context"}),"。在正式介绍之前，我们首先来想一想为什么 React 会提供 context 的 API 呢？"]}),"\n",(0,o.jsxs)(n.p,{children:["带着这个疑问，首先假设一个场景：在 React 的项目有一个全局变量 theme（ theme 可能是初始化数据交互获得的，也有可能是切换主题变化的），有一些视图 UI 组件（比如表单 input 框、button 按钮），需要 theme 里面的变量来做对应的视图渲染，现在的问题是怎么能够把 theme 传递下去，合理分配到",(0,o.jsx)(n.strong,{children:"用到这个 theme"})," 的地方。"]}),"\n",(0,o.jsxs)(n.p,{children:["那么，首先想到的是 ",(0,o.jsx)(n.strong,{children:"props 的可行性"}),"，如果让 props 来解决上述问题可以是可以，不过会有两个问题。假设项目的组件树情况如下图所示，因为在设计整个项目的时候，不确定将来哪一个模块需要 theme ，所以必须将 theme 在根组件 A 注入，但是需要给组件 N 传递 props ，需要在上面每一层都去手动绑定 props ，如果将来其他子分支上有更深层的组件需要 theme ，还需要把上一级的组件全部绑定传递 props ，这样维护成本是巨大的。"]}),"\n",(0,o.jsx)(n.p,{children:"假设需要动态改变 theme ，那么需要从根组件更新，只要需要 theme 的组件，由它开始到根组件的一条组件链结构都需要更新，会造成牵一发动全身的影响。props 方式看来不切实际。"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:i,alt:"context1.jpg"})}),"\n",(0,o.jsx)(n.p,{children:"为了解决上述 props 传递的两个问题，React提供了context‘上下文’模式，具体模式是这样的，React组件树A节点，用Provider提供者注入theme，然后在需要theme的地方，用 Consumer 消费者形式取出theme，供给组件渲染使用即可，这样减少很多无用功。用官网上的一句话形容就是Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。"}),"\n",(0,o.jsxs)(n.p,{children:["但是必须注意一点是，",(0,o.jsx)(n.strong,{children:"提供者永远要在消费者上层"}),"，正所谓水往低处流，提供者一定要是消费者的某一层父级。"]}),"\n",(0,o.jsx)(n.p,{children:"希望通过本章节将学会 React Context 的基础用法，高阶用法，以及 Context 切换主题实践。让读过的同学，能够明白 context 使用场景，以及正确使用 context 。"}),"\n",(0,o.jsxs)(n.h3,{id:"老版本context",children:["老版本context",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#老版本context",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["在",(0,o.jsx)(n.code,{children:" v16.3.0 "}),"之前，React 用 PropTypes 来声明 context 类型，提供者需要 getChildContext 来返回需要提供的 context ，并且用静态属性  childContextTypes 声明需要提供的 context 数据类型。具体如下"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"老版本提供者"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// 提供者\nimport propsTypes from 'proptypes'\nclass ProviderDemo extends React.Component{ \n    getChildContext(){\n        const theme = { /* 提供者要提供的主题颜色，供消费者消费 */\n            color:'#ccc',\n            background:'pink'\n        }\n        return { theme }\n    }\n    render(){\n        return <div>\n            hello,let us learn React!\n            <Son/>\n        </div>\n    }\n }\n\nProviderDemo.childContextTypes = {\n    theme:propsTypes.object\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["老版本 api 在 v16 版本还能正常使用，对于提供者，需要通过 getChildContext 方法，将传递的 theme 信息返回出去，并通过 childContextTypes 声明要传递的 theme 是一个对象结构。声明类型需要",(0,o.jsx)(n.code,{children:"propsTypes"}),"库来助力。"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"老版本消费者"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// 消费者\nclass ConsumerDemo extends React.Component{\n   render(){\n       console.log(this.context.theme) // {  color:'#ccc',  bgcolor:'pink' }\n       const { color , background } = this.context.theme\n       return <div style={{ color,background } } >消费者</div>\n   }\n}\nConsumerDemo.contextTypes = {\n    theme:propsTypes.object\n}\n\nconst Son = ()=> <ConsumerDemo/>\n"})}),"\n",(0,o.jsx)(n.p,{children:"效果："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:"data:image/webp;base64,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",alt:"context2.jpg"})}),"\n",(0,o.jsx)(n.p,{children:"作为消费者，需要在组件的静态属性指明我到底需要哪个提供者提供的状态，在 demo 项目中，ConsumerDemo 的 contextTypes 明确的指明了需要 ProviderDemo 提供的 theme信息，然后就可以通过 this.context.theme 访问到 theme ，用做渲染消费。"}),"\n",(0,o.jsxs)(n.p,{children:["这种模式和 vue 中的 provide 和 inject 数据传输模式很像，在提供者中声明到底传递什么，然后消费者指出需要哪个提供者提供的 context 。打个比方，就好比去一个高档餐厅，每一个厨师都可以理解成一个提供者，而且每个厨师各有所长，有的擅长中餐，有的擅长西餐，每个厨师都把擅长的用 ",(0,o.jsx)(n.code,{children:"childContextTypes"})," 贴出来，你作为消费者，用 ",(0,o.jsx)(n.code,{children:"contextTypes"})," 明确出想要吃哪个厨师做的餐饮，借此做到物尽所需。"]}),"\n",(0,o.jsxs)(n.h2,{id:"二-新版本-context-基本使用",children:["二 新版本 context 基本使用",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-新版本-context-基本使用",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["上述的 API 用起来流程可能会很繁琐，而且还依赖于 propsTypes 等第三方库。所以 ",(0,o.jsx)(n.code,{children:"v16.3.0"})," 之后，context api 正式发布了，所以可以直接用 createContext 创建出一个 context 上下文对象，context 对象提供两个组件，",(0,o.jsx)(n.code,{children:"Provider"}),"和 ",(0,o.jsx)(n.code,{children:"Consumer"}),"作为新的提供者和消费者，这种 context 模式，更便捷的传递 context ，还增加了一些新的特性，但是也引出了一些新的问题，什么问题后面会讲到。接下来需要重点研究一下新版本的 context 。"]}),"\n",(0,o.jsxs)(n.h3,{id:"1-createcontext",children:["1 createContext",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-createcontext",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"React.createContext"})," 的基本用法如下所示。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const ThemeContext = React.createContext(null) //\nconst ThemeProvider = ThemeContext.Provider  //提供者\nconst ThemeConsumer = ThemeContext.Consumer // 订阅消费者\n"})}),"\n",(0,o.jsx)(n.p,{children:"createContext 接受一个参数，作为初始化 context 的内容，返回一个context 对象，Context 对象上的 Provider 作为提供者，Context 对象上的 Consumer 作为消费者。"}),"\n",(0,o.jsxs)(n.h3,{id:"2-新版本提供者",children:["2 新版本提供者",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-新版本提供者",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"首先来看一下Provider的用法。"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const ThemeProvider = ThemeContext.Provider  //提供者\nexport default function ProviderDemo(){\n    const [ contextValue , setContextValue ] = React.useState({  color:'#ccc', background:'pink' })\n    return <div>\n        <ThemeProvider value={ contextValue } > \n            <Son />\n        </ThemeProvider>\n    </div>\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"provider 作用有两个："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"value 属性传递 context，供给 Consumer 使用。"}),"\n",(0,o.jsx)(n.li,{children:"value 属性改变，ThemeProvider 会让消费 Provider value 的组件重新渲染。"}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"3-新版本消费者",children:["3 新版本消费者",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-新版本消费者",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"对于新版本想要获取 context 的消费者，React 提供了3种形式，接下来一一介绍这三种方式。"}),"\n",(0,o.jsxs)(n.h4,{id:"-类组件之contexttype-方式",children:["① 类组件之contextType 方式",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-类组件之contexttype-方式",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"React v16.6"})," 提供了 contextType 静态属性，用来获取上面 Provider 提供的 value 属性，这里注意的是 contextType ，不是上述老版的contextTypes, 对于 React 起的这两个名字，真是太相像了。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const ThemeContext = React.createContext(null)\n// 类组件 - contextType 方式\nclass ConsumerDemo extends React.Component{\n   render(){\n       const { color,background } = this.context\n       return <div style={{ color,background } } >消费者</div> \n   }\n}\nConsumerDemo.contextType = ThemeContext\n\nconst Son = ()=> <ConsumerDemo />\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"类组件的静态属性上的 contextType 属性，指向需要获取的 context（ demo 中的 ThemeContext ），就可以方便获取到最近一层 Provider 提供的 contextValue 值。"}),"\n",(0,o.jsx)(n.li,{children:"记住这种方式只适用于类组件。"}),"\n"]}),"\n",(0,o.jsxs)(n.h4,{id:"-函数组件之-usecontext-方式",children:["② 函数组件之 useContext 方式",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-函数组件之-usecontext-方式",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["既然类组件都可以快捷获取 context 了，那么函数组件也应该研究一下如何快速获取 context 吧，于是乎 v16.8 React hooks 提供了 ",(0,o.jsx)(n.code,{children:"useContext"}),"，下面看一下 useContext 使用。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const ThemeContext = React.createContext(null)\n// 函数组件 - useContext方式\nfunction ConsumerDemo(){\n    const  contextValue = React.useContext(ThemeContext) /*  */\n    const { color,background } = contextValue\n    return <div style={{ color,background } } >消费者</div> \n}\nconst Son = ()=> <ConsumerDemo />\n"})}),"\n",(0,o.jsx)(n.p,{children:"useContext 接受一个参数，就是想要获取的 context ，返回一个 value 值，就是最近的 provider 提供 contextValue 值。"}),"\n",(0,o.jsxs)(n.h4,{id:"-订阅者之-consumer-方式",children:["③ 订阅者之 Consumer 方式",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-订阅者之-consumer-方式",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"React 还提供了一种 Consumer 订阅消费者方式，我们研究一下这种方式如何传递 context 。"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const ThemeConsumer = ThemeContext.Consumer // 订阅消费者\n\nfunction ConsumerDemo(props){\n    const { color,background } = props\n    return <div style={{ color,background } } >消费者</div> \n}\nconst Son = () => (\n    <ThemeConsumer>\n       { /* 将 context 内容转化成 props  */ }\n       { (contextValue)=> <ConsumerDemo  {...contextValue}  /> }\n    </ThemeConsumer>\n) \n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Consumer 订阅者采取 render props 方式，接受最近一层 provider 中value 属性，作为 render props 函数的参数，可以将参数取出来，作为 props 混入 ",(0,o.jsx)(n.code,{children:"ConsumerDemo"})," 组件，说白了就是 context 变成了 props。"]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"4-动态context",children:["4 动态context",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-动态context",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"上面讲到的 context 都是静态的，不变的，但是实际的场景下，context 可能是动态的，可变的，比如说回到了本章节最开始的话题切换主题，因为切换主题就是在动态改变 context 的内容。所以接下来看一下动态改变 context 。"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function ConsumerDemo(){\n     const { color,background } = React.useContext(ThemeContext)\n    return <div style={{ color,background } } >消费者</div> \n}\nconst Son = React.memo(()=> <ConsumerDemo />) // 子组件\n\nconst ThemeProvider = ThemeContext.Provider //提供者\nexport default function ProviderDemo(){\n    const [ contextValue , setContextValue ] = React.useState({  color:'#ccc', background:'pink' })\n    return <div>\n        <ThemeProvider value={ contextValue } >\n            <Son />\n        </ThemeProvider>\n        <button onClick={ ()=> setContextValue({ color:'#fff' , background:'blue' })  } >切换主题</button>\n    </div>\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"效果"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:l,alt:"context5.gif"})}),"\n",(0,o.jsxs)(n.p,{children:["Provider 模式下 context 有一个显著的特点，就是 ",(0,o.jsx)(n.strong,{children:"Provder 的 value 改变，会使所有消费 value 的组件重新渲染"}),"，如上通过一个 useState 来改变 contextValue 的值，contextValue 改变，会使 ConsumerDemo 自动更新，注意这个更新并不是由父组件 son render 造成的，因为给 son 用 memo 处理过，这种情况下，Son 没有触发 render，而是 ConsumerDemo 自发的render。"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["总结：在 Provider 里 value 的改变，会使引用",(0,o.jsx)(n.code,{children:"contextType"}),",",(0,o.jsx)(n.code,{children:"useContext"})," 消费该 context 的组件重新 render ，同样会使 Consumer 的 children 函数重新执行，与前两种方式不同的是 Consumer 方式，当 context 内容改变的时候，不会让引用 Consumer 的父组件重新更新。"]})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"暴露问题"})}),"\n",(0,o.jsxs)(n.p,{children:["但是上述的 demo 暴露出一个问题，就是在上述 son 组件是用 memo 处理的，如果没有 memo 处理，useState 会让 ",(0,o.jsx)(n.code,{children:"ProviderDemo"})," 重新 render ，此时 son 没有处理，就会跟随父组件 render ，问题是如果 son 还有很多子组件，那么全部 render 一遍。那么",(0,o.jsx)(n.strong,{children:"如何阻止 Provider value 改变造成的 children （ demo 中的 Son ）不必要的渲染？"})]}),"\n",(0,o.jsx)(n.p,{children:"针对这个问题，我在知乎看见过大佬们解答，说的很玄乎，会让不是深入接触 React 的同学很疑惑\uD83E\uDD14，究其本质就是如下两个思路。"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"① 第一种就是利用 memo，pureComponent 对子组件 props 进行浅比较处理。"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const Son = React.memo(()=> <ConsumerDemo />)  \n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"② 第二种就是 React 本身对 React element 对象的缓存。React 每次执行 render 都会调用 createElement 形成新的 React element 对象，如果把 React element 缓存下来，下一次调和更新时候，就会跳过该 React element 对应 fiber 的更新。"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"<ThemeProvider value={ contextValue } >\n    { React.useMemo(()=>  <Son /> ,[]) }\n</ThemeProvider>\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"5-其他api",children:["5 其他api",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-其他api",children:"#"})]}),"\n",(0,o.jsxs)(n.h4,{id:"-displayname",children:["① displayName",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-displayname",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["context 对象接受一个名为 ",(0,o.jsx)(n.code,{children:"displayName"})," 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const MyContext = React.createContext(/* 初始化内容 */);\nMyContext.displayName = \'MyDisplayName\';\n\n<MyContext.Provider> // "MyDisplayName.Provider" 在 DevTools 中\n<MyContext.Consumer> // "MyDisplayName.Consumer" 在 DevTools 中\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"｜--------问与答---------｜"}),"\n",(0,o.jsx)(n.strong,{children:"问"}),"：context 与 props 和 react-redux 的对比？"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"答"}),"： context解决了："]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"解决了 props 需要每一层都手动添加 props 的缺陷。"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"解决了改变 value ，组件全部重新渲染的缺陷。"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"react-redux 就是通过 Provider 模式把 redux 中的 store 注入到组件中的。"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"｜--------end---------｜"})}),"\n",(0,o.jsxs)(n.h2,{id:"三-context高阶用法",children:["三 context高阶用法",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-context高阶用法",children:"#"})]}),"\n",(0,o.jsxs)(n.h3,{id:"嵌套-provider",children:["嵌套 Provider",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#嵌套-provider",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"多个 Provider 之间可以相互嵌套，来保存/切换一些全局数据："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const ThemeContext = React.createContext(null) // 主题颜色Context\nconst LanContext = React.createContext(null) // 主题语言Context\n\nfunction ConsumerDemo(){\n    return <ThemeContext.Consumer>\n        { (themeContextValue)=> (\n            <LanContext.Consumer>\n                { (lanContextValue) => {\n                    const { color , background } = themeContextValue\n                    return <div style={{ color,background } } > { lanContextValue === 'CH'  ? '大家好，让我们一起学习React!' : 'Hello, let us learn React!'  }  </div> \n                } }\n            </LanContext.Consumer>\n        )  }\n    </ThemeContext.Consumer>\n}\n\nconst Son = memo(()=> <ConsumerDemo />)\nexport default function ProviderDemo(){\n    const [ themeContextValue ] = React.useState({  color:'#FFF', background:'blue' })\n    const [ lanContextValue ] = React.useState('CH') // CH -> 中文 ， EN -> 英文\n    return <ThemeContext.Provider value={themeContextValue}  >\n         <LanContext.Provider value={lanContextValue} >\n             <Son  />\n         </LanContext.Provider>\n    </ThemeContext.Provider>\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"效果："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:d,alt:"context3.jpg"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"ThemeContext 保存主题信息，用 LanContext 保存语言信息。"}),"\n",(0,o.jsx)(n.li,{children:"两个 Provider 嵌套来传递全局信息。"}),"\n",(0,o.jsx)(n.li,{children:"用两个 Consumer 嵌套来接受信息。"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"还有就是可以学习一些优秀的开源库，比如 ant-design，看看它是如何优雅的使用 context 。"}),"\n",(0,o.jsxs)(n.h3,{id:"逐层传递provider",children:["逐层传递Provider",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#逐层传递provider",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"Provider 还有一个良好的特性，就是可以逐层传递 context ，也就是一个 context 可以用多个 Provder 传递，下一层级的 Provder 会覆盖上一层级的 Provder 。React-redux 中 connect 就是用这个良好特性传递订阅器的。"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// 逐层传递Provder\nconst ThemeContext = React.createContext(null)\nfunction Son2(){\n    return <ThemeContext.Consumer>\n        { (themeContextValue2)=>{\n            const { color , background } = themeContextValue2\n            return  <div  className=\"sonbox\"  style={{ color,background } } >  第二层Provder </div>\n        }  }\n    </ThemeContext.Consumer>\n}\nfunction Son(){\n    const { color, background } = React.useContext(ThemeContext)\n    const [ themeContextValue2 ] = React.useState({  color:'#fff', background:'blue' }) \n    /* 第二层 Provder 传递内容 */\n    return <div className='box' style={{ color,background } } >\n        第一层Provder\n        <ThemeContext.Provider value={ themeContextValue2 } >\n            <Son2  />\n        </ThemeContext.Provider>\n    </div>\n\n}\n\nexport default function Provider1Demo(){\n    const [ themeContextValue ] = React.useState({  color:'orange', background:'pink' })\n     /* 第一层  Provider 传递内容  */\n    return <ThemeContext.Provider value={ themeContextValue } >\n        <Son/>\n    </ThemeContext.Provider> \n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"效果："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:s,alt:"context4.jpg"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"全局只有一个 ThemeContext ，两次用 provider 传递两个不同 context 。"}),"\n",(0,o.jsx)(n.li,{children:"组件获取 context 时候，会获取离当前组件最近的上一层 Provider 。"}),"\n",(0,o.jsx)(n.li,{children:"下一层的 provider 会覆盖上一层的 provider 。"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Provider 特性总结："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"1 Provider 作为提供者传递 context ，provider中value属性改变会使所有消费context的组件重新更新。"}),"\n",(0,o.jsx)(n.li,{children:"2 Provider可以逐层传递context，下一层Provider会覆盖上一层Provider。"}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"四-进阶实践-切换主题模式",children:["四 进阶实践-切换主题模式",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-进阶实践-切换主题模式",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"接下来实践用 Provider Api 实现一个切换 主题颜色的 demo 。"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"实现效果"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:c,alt:"context6.gif"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const ThemeContext = React.createContext(null) // 主题颜色Context\n\nconst theme = { //主题颜色\n    dark:{  color:\'#1890ff\' , background:\'#1890ff\', border: \'1px solid blue\' ,type:\'dark\',  },\n    light: {  color:\'#fc4838\' , background:\'#fc4838\', border: \'1px solid pink\' ,type:\'light\'  }\n}\n\n/* input输入框 - useContext 模式 */\nfunction Input(props){\n    const  { color,border } = useContext(ThemeContext)\n    const { label , placeholder } = props\n    return <div>\n        <label style={{ color }} >{ label }</label>\n        <input className="input" placeholder={placeholder}  style={{ border }} />\n    </div>\n}\n/* 容器组件 -  Consumer模式 */\nfunction Box(props){\n    return <ThemeContext.Consumer>\n        { (themeContextValue)=>{\n            const { border,color } = themeContextValue\n            return <div className="context_box" style={{ border,color }} >\n            { props.children }\n        </div>\n        } }\n    </ThemeContext.Consumer>\n}\n\nfunction  Checkbox (props){\n    const { label ,name, onChange } = props\n    const { type , color } = React.useContext(ThemeContext)\n    return <div className="checkbox"  onClick={onChange} >\n        <label htmlFor="name" > {label} </label>\n       <input type="checkbox" id={name} value={type} name={name} checked={ type === name }  style={{ color } } />\n    </div>\n}\n\n// contextType 模式\nclass App extends React.PureComponent{\n    static contextType = ThemeContext\n    render(){\n        const { border , setTheme ,color  ,background} = this.context\n        return <div className="context_app" style={{ border , color }}  >\n          <div className="context_change_theme"   >\n             <span> 选择主题： </span>\n             <Checkbox label="light"  name="light" onChange={ ()=> setTheme(theme.light) }  />\n             <Checkbox label="dark" name="dark"  onChange={ ()=> setTheme(theme.dark) }   />\n          </div>\n          <div className=\'box_content\' >\n            <Box >\n                <Input label="姓名："  placeholder="请输入姓名"  />\n                <Input label="age："  placeholder="请输入年龄"  />\n                <button className="searchbtn" style={ { background } } >确定</button>\n                <button className="concellbtn" style={ { color } } >取消</button>\n            </Box>\n            <Box >\n                <HomeOutlined  twoToneColor={ color } />\n                <SettingFilled twoToneColor={ color }  />\n                <SmileOutlined twoToneColor={ color }  />\n                <SyncOutlined spin  twoToneColor={ color }  />\n                <SmileOutlined twoToneColor={ color }  rotate={180} />\n                <LoadingOutlined twoToneColor={ color }   />\n            </Box>\n            <Box >\n                <div className="person_des" style={{ color:\'#fff\' , background }}  >\n                    I am alien  <br/>\n                    let us learn React!\n                </div>\n            </Box>\n          </div>\n     </div>\n    }\n}\n\nexport default function (){\n    const [ themeContextValue ,setThemeContext ] = React.useState(theme.dark) \n    /* 传递颜色主题 和 改变主题的方法 */\n    return <ThemeContext.Provider value={ { ...themeContextValue, setTheme:setThemeContext  } } >\n        <App/>\n    </ThemeContext.Provider>\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"流程分析："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["在 Root 组件中，用 Provider 把主题颜色 ",(0,o.jsx)(n.code,{children:"themeContextValue"})," 和改变主题的 ",(0,o.jsx)(n.code,{children:"setTheme"})," 传入 context 。"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"在 App 中切换主题。"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"封装统一的 Input Checkbox Box 组件，组件内部消费主题颜色的 context ，主题改变，统一更新，这样就不必在每一个模块都绑定主题，统一使用主体组件就可以了。"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"五-总结",children:["五 总结",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"通过这节学习了："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"老版本的 context 和 新版本的 context 。"}),"\n",(0,o.jsx)(n.li,{children:"新版本提供者 Provider 特性和三种消费者模式。"}),"\n",(0,o.jsx)(n.li,{children:"context 的高阶用法。"}),"\n",(0,o.jsx)(n.li,{children:"实践 demo 切换主题。"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"下一节，将一起研究css in React!"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(x,{...e})}):x(e)}let h=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F8.%E5%9F%BA%E7%A1%80%E7%AF%87-%E6%8F%90%E4%BE%9B%E8%80%85%20context.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"老版本context",id:"老版本context",depth:3},{text:"二 新版本 context 基本使用",id:"二-新版本-context-基本使用",depth:2},{text:"1 createContext",id:"1-createcontext",depth:3},{text:"2 新版本提供者",id:"2-新版本提供者",depth:3},{text:"3 新版本消费者",id:"3-新版本消费者",depth:3},{text:"① 类组件之contextType 方式",id:"-类组件之contexttype-方式",depth:4},{text:"② 函数组件之 useContext 方式",id:"-函数组件之-usecontext-方式",depth:4},{text:"③ 订阅者之 Consumer 方式",id:"-订阅者之-consumer-方式",depth:4},{text:"4 动态context",id:"4-动态context",depth:3},{text:"5 其他api",id:"5-其他api",depth:3},{text:"① displayName",id:"-displayname",depth:4},{text:"三 context高阶用法",id:"三-context高阶用法",depth:2},{text:"嵌套 Provider",id:"嵌套-provider",depth:3},{text:"逐层传递Provider",id:"逐层传递provider",depth:3},{text:"四 进阶实践-切换主题模式",id:"四-进阶实践-切换主题模式",depth:2},{text:"五 总结",id:"五-总结",depth:2}],title:"8.基础篇-提供者 context",headingTitle:"8.基础篇-提供者 context",frontmatter:{}}}}]);