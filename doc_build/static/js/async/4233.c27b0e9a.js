"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["4233"],{255:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var c=r(552676),d=r(740453);let s=r.p+"static/image/58f9d44038184527bfd6dfa5b07103ce~tplv-k3u1fbpfcp-zoom-1.image.b9107322.png",i=r.p+"static/image/073c4ef3b9ba404281729f6f9ac9a11e~tplv-k3u1fbpfcp-zoom-1.image.db9fc830.png";function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",blockquote:"blockquote",em:"em",pre:"pre",ul:"ul",li:"li",h3:"h3",img:"img"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"9-思考持久化数据结构是-immutability-的唯一答案吗",children:["9 思考：持久化数据结构，是 Immutability 的唯一答案吗？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-思考持久化数据结构是-immutability-的唯一答案吗",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"react-与函数式编程",children:["React 与函数式编程",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-与函数式编程",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我所在的团队使用 React 作为主要技术栈已经有超过五年的时间了。因此，我们在招聘前端工程师时会格外注意 React 能力的考察。"}),"\n",(0,c.jsx)(n.p,{children:"而 React，它生来自带函数式光环。"}),"\n",(0,c.jsxs)(n.p,{children:["无论是",(0,c.jsx)(n.code,{children:"  UI = f(data)  "}),"的宏观设计，还是 ",(0,c.jsx)(n.code,{children:"setState"})," API 对“不可变值”的预期，抑或是好基友 Redux 中以纯函数形态存在的 ",(0,c.jsx)(n.code,{children:"reducer"}),"...... 这些无一不彰显着它和函数式思想的暧昧关系。"]}),"\n",(0,c.jsx)(n.p,{children:"当然，不得不提的还有随着 React16+ 逐渐普及开来的函数式组件+ Hooks 等等。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"函数式编程对现代前端框架、对前端生态的影响，我们在小册的后半程会单开章节来讨论。此处不多赘述。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"我相信，对许多前端工程师来说，React 才是大家入门函数式思想的起点。"}),"\n",(0,c.jsx)(n.p,{children:"也正因为如此，我们非常喜欢在 React 系列的问题结束后，和候选人聊一聊函数式编程。"}),"\n",(0,c.jsxs)(n.h2,{id:"关于-immutablility不可变性-的刻板印象",children:["关于 Immutablility（不可变性） 的刻板印象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于-immutablility不可变性-的刻板印象",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在许多团队的函数式编程题库里，“数据不可变性如何在前端业务中落地”都是一道高频考题。"}),"\n",(0,c.jsx)(n.p,{children:"遗憾的是，这道题目的答案多年来也几乎是“固定”的，八成左右的候选人的答案都有且仅有一个——Immutable.js/持久化数据结构。"}),"\n",(0,c.jsx)(n.p,{children:"如果是在 2016 年，这个答案确实足以成为问题的终点。"}),"\n",(0,c.jsx)(n.p,{children:"但在今天，很多时候面试官们会忍不住追问：Immutable.js/持久化数据结构是唯一的答案吗？"}),"\n",(0,c.jsx)(n.p,{children:"不少同学仍然会回答“是”，尽管这个“是”里夹带了那么些许的不确定，但它足以反映社区对 Immutability 的刻板印象。"}),"\n",(0,c.jsx)(n.p,{children:"这一节我希望大家学到的东西，就是如何对这个问题说“不”。"}),"\n",(0,c.jsx)(n.p,{children:"Immutable.js 对于前端函数式编程来说，有划时代的意义。许多同学正是通过它才了解到“不可变数据”、“持久化数据结构”等概念。"}),"\n",(0,c.jsx)(n.p,{children:"但它终究也只是实现 Immutability 的一种途径。在活跃的函数式社区中，优秀的 Immutability 实践还有很多——比如，Immer.js。"}),"\n",(0,c.jsxs)(n.h2,{id:"immerjs一个傻瓜式的-immutability-解决方案",children:["Immer.js，一个傻瓜式的 Immutability 解决方案",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#immerjs一个傻瓜式的-immutability-解决方案",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Immer.js 是我在 2019 年最喜欢的前端库之一。在理解了 Immer.js 的设计思想和工作方式之后，我将团队主要仓库的不可变数据的解决方案全部从 Immutable.js 迭代为了 Immer.js。"}),"\n",(0,c.jsx)(n.p,{children:"作为一个实用主义者，我至今没有后悔这个决定。"}),"\n",(0,c.jsxs)(n.p,{children:["因为用 Immer.js 写代码，真的是太爽啦！(",(0,c.jsx)(n.em,{children:"^▽^"}),")"]}),"\n",(0,c.jsx)(n.p,{children:"不需要操心深拷贝浅拷贝的事儿，更不需要背诵记忆 Immutable.js 定义的一大堆 API，你所需要做的，仅仅是在项目里轻轻地 Import 一个 produce（请看下文代码，解析在注释里）："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'import produce from "immer"\n\n// 这是我的源数据\nconst baseState = [\n    {\n        name: "修言",\n        age: 99\n    },\n    {\n        name: "秀妍",\n        age: 100\n    }\n]\n\n// 定义数据的写逻辑\nconst recipe = draft => {\n    draft.push({name: "xiuyan", age: 101})\n    draft[1].age = 102\n}\n\n// 借助 produce，执行数据的写逻辑\nconst nextState = produce(baseState, recipe)\n'})}),"\n",(0,c.jsx)(n.p,{children:"这个 API 里有几个要素："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"(base)state：源数据，是我们想要修改的目标数据"}),"\n",(0,c.jsx)(n.li,{children:"recipe：一个函数，我们可以在其中描述数据的写逻辑"}),"\n",(0,c.jsx)(n.li,{children:"draft：recipe 函数的默认入参，它是对源数据的代理，我们可以把想要应用在源数据的变更应用在 draft 上"}),"\n",(0,c.jsx)(n.li,{children:"produce：入口函数，它负责把上述要素串起来。具体逻辑请看下文分解。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"记住上述要素的基本特性，我们接下来要冲一波源码了xdm！"}),"\n",(0,c.jsxs)(n.h2,{id:"immerjs-是如何工作的",children:["Immer.js 是如何工作的",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#immerjs-是如何工作的",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Immer.js 实现 Immutability 的姿势非常有趣——它使用 Proxy，对目标对象的行为进行“元编程”。"}),"\n",(0,c.jsxs)(n.h3,{id:"回顾-proxy",children:["回顾 Proxy",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾-proxy",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Proxy 是 ES6 中引入的一个概念。这里为了确保所有知识层次的同学都具备足够清晰的上下文，我们先快速地对 Proxy 相关的要点做一个回顾。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n——MDN"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"Proxy 是 JS 语言中少有的“元编程”工具。"}),"\n",(0,c.jsx)(n.p,{children:"所谓“元编程”，指的是对编程语言进行再定义。"}),"\n",(0,c.jsx)(n.p,{children:"借助 ES6 暴露给我们的 Proxy 构造函数，我们可以创建一个 Proxy 实例，并借助这个实例对目标对象的一些行为进行再定义。"}),"\n",(0,c.jsx)(n.p,{children:"举个例子（解析在注释里）："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 定义一个 programmer 对象\nconst programmer = {\n  name: 'xiuyan',\n  age: 30\n}\n\n// 定义这个对象的拦截逻辑\nconst proxyHandler = {\n  // obj 是目标对象， key 是被访问的键名\n  get(obj, key) {\n    if(key === 'age')\n      return 100\n    return obj[key]\n  }\n}\n\n// 借助 Proxy，将这个对象使用拦截逻辑包起来\nconst wrappedProgrammer = new Proxy(programmer, proxyHandler)\n\n// 'xiuyan'\nconsole.log(wrappedProgrammer.name)\n// 100\nconsole.log(wrappedProgrammer.age)\n"})}),"\n",(0,c.jsx)(n.p,{children:"如这段代码所示， Proxy 接收两个参数，第一个参数是你需要处理的目标对象，第二个参数同样是一个对象，在这个对象里，描述了你希望对目标对象应用的拦截/代理行为。"}),"\n",(0,c.jsxs)(n.p,{children:["在这个例子里，我借助 ",(0,c.jsx)(n.code,{children:"proxyHandler"})," 拦截了目标对象（",(0,c.jsx)(n.code,{children:"programmer"}),"）的 ",(0,c.jsx)(n.code,{children:"getter"})," 方法，代理了 ",(0,c.jsx)(n.code,{children:"programmer"})," 对象的访问行为。"]}),"\n",(0,c.jsxs)(n.p,{children:["每次访问 ",(0,c.jsx)(n.code,{children:"wrappedProgrammer"})," 时，JS 不会执行 ",(0,c.jsx)(n.code,{children:"programmer"})," 对象的默认行为（返回 ",(0,c.jsx)(n.code,{children:"obj[key]"}),"），而是会执行 ",(0,c.jsx)(n.code,{children:"proxyHandler.get()"})," 方法所定义的行为：若访问的 key 是 ",(0,c.jsx)(n.code,{children:"age"}),"，则固定返回 100，否则返回 ",(0,c.jsx)(n.code,{children:"obj[key]"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["（同理，我们也可以对目标对象的 ",(0,c.jsx)(n.code,{children:"setter"})," 方法进行拦截，此处不再赘述）。"]}),"\n",(0,c.jsx)(n.p,{children:"总结一下：借助 Proxy，我们可以给目标对象创建一个代理（拦截）层、拦截原生对象的某些默认行为，进而实现对目标行为的自定义。"}),"\n",(0,c.jsx)(n.p,{children:"那么 Proxy 是如何帮助 Immer.js 实现 Immutability 的呢？"}),"\n",(0,c.jsxs)(n.h3,{id:"produce-关键逻辑抽象",children:["Produce 关键逻辑抽象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#produce-关键逻辑抽象",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["正如上文所说，使用 Immer.js，你只需要在项目里轻轻地 Import 一个名为 ",(0,c.jsx)(n.code,{children:"produce"})," 的 API。"]}),"\n",(0,c.jsxs)(n.p,{children:["Immer.js 的一切奥秘都蕴含在 ",(0,c.jsx)(n.code,{children:"produce"})," 里，包括其对 Proxy 的运用。"]}),"\n",(0,c.jsxs)(n.p,{children:["那么 ",(0,c.jsx)(n.code,{children:"produce"})," 是如何工作的呢？"]}),"\n",(0,c.jsxs)(n.p,{children:["Immer.js 的源代码虽然简洁，但整个读完也是个力气活。这里我们只关注 ",(0,c.jsx)(n.code,{children:"produce"})," 函数的核心逻辑，我将其提取为如下的极简版本（解析在注释里）："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function produce(base, recipe) {\n  // 预定义一个 copy 副本\n  let copy\n  // 定义 base 对象的 proxy handler\n  const baseHandler = {\n    set(obj, key, value) {\n      // 先检查 copy 是否存在，如果不存在，创建 copy\n      if (!copy) {\n        copy = { ...base }\n      }\n      // 如果 copy 存在，修改 copy，而不是 base\n      copy[key] = value\n      return true\n    }\n  }\n\n  // 被 proxy 包装后的 base 记为 draft\n  const draft = new Proxy(base, baseHandler)\n  // 将 draft 作为入参传入 recipe\n  recipe(draft)\n  // 返回一个被“冻结”的 copy，如果 copy 不存在，表示没有执行写操作，返回 base 即可\n  // “冻结”是为了避免意外的修改发生，进一步保证数据的纯度\n  return Object.freeze(copy || base)\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"接下来我尝试对这个超简易版的 producer 进行一系列的调用（解析在注释里）："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:'// 这是我的源对象\nconst baseObj = {\n  a: 1,\n  b: {\n    name: "修言"\n  }\n}\n\n// 这是一个执行写操作的 recipe\nconst changeA = (draft) => {\n  draft.a = 2\n}\n\n\n// 这是一个不执行写操作、只执行读操作的 recipe\nconst doNothing = (draft) => {\n  console.log("doNothing function is called, and draft is", draft)\n}\n\n// 借助 produce，对源对象应用写操作，修改源对象里的 a 属性\nconst changedObjA = produce(baseObj, changeA)\n\n// 借助 produce，对源对象应用读操作\nconst doNothingObj = produce(baseObj, doNothing)\n\n// 顺序输出3个对象，确认写操作确实生效了\nconsole.log(baseObj)\nconsole.log(changedObjA)\nconsole.log(doNothingObj)\n\n// 【源对象】 和 【借助 produce 对源对象执行过读操作后的对象】 还是同一个对象吗？\n// 答案为 true\nconsole.log(baseObj === doNothingObj)\n// 【源对象】 和 【借助 produce 对源对象执行过写操作后的对象】 还是同一个对象吗？\n// 答案为 false\nconsole.log(baseObj === changedObjA)\n// 源对象里没有被执行写操作的 b 属性，在 produce 执行前后是否会发生变化？\n// 输出为 true，说明不会发生变化\nconsole.log(baseObj.b === changedObjA.b)\n'})}),"\n",(0,c.jsxs)(n.p,{children:["下图为上述代码的执行结果 ",(0,c.jsx)(n.code,{children:"console"})," ："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["如果你想使用 ",(0,c.jsx)(n.code,{children:"produce"})," 本体验证上述用例，你只需要在项目里引入 ",(0,c.jsx)(n.code,{children:"produce"})," 后，注释掉我们自定义的 ",(0,c.jsx)(n.code,{children:"produce"})," 即可。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"produce"})," 本体运行该测试用例的执行结果 ",(0,c.jsx)(n.code,{children:"console"})," 如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["两边的输出完全一致，也就是说至少对这个基础用例来说，我们的极简版 ",(0,c.jsx)(n.code,{children:"produce"})," 是可以复刻 ",(0,c.jsx)(n.code,{children:"produce"})," 本体的表现的。"]}),"\n",(0,c.jsxs)(n.p,{children:["而 Immer.js 对 Proxy 的巧思，恰恰就藏在这个极简 ",(0,c.jsx)(n.code,{children:"produce"})," 里。"]}),"\n",(0,c.jsx)(n.p,{children:"欲知巧思何在，且看下回分解~"}),"\n",(0,c.jsx)(n.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(a,{...e})}):a(e)}let l=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F9%20%E6%80%9D%E8%80%83%EF%BC%9A%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E6%98%AF%20Immutability%20%E7%9A%84%E5%94%AF%E4%B8%80%E7%AD%94%E6%A1%88%E5%90%97%EF%BC%9F.md"]={toc:[{text:"React 与函数式编程",id:"react-与函数式编程",depth:2},{text:"关于 Immutablility（不可变性） 的刻板印象",id:"关于-immutablility不可变性-的刻板印象",depth:2},{text:"Immer.js，一个傻瓜式的 Immutability 解决方案",id:"immerjs一个傻瓜式的-immutability-解决方案",depth:2},{text:"Immer.js 是如何工作的",id:"immerjs-是如何工作的",depth:2},{text:"回顾 Proxy",id:"回顾-proxy",depth:3},{text:"Produce 关键逻辑抽象",id:"produce-关键逻辑抽象",depth:3}],title:"9 思考：持久化数据结构，是 Immutability 的唯一答案吗？",headingTitle:"9 思考：持久化数据结构，是 Immutability 的唯一答案吗？",frontmatter:{}}}}]);