"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["46810"],{339266:function(n,e,r){r.r(e),r.d(e,{default:()=>h});var c=r(552676),d=r(740453);let s=r.p+"static/image/ca5b5dd41f0b4f6b95e234cc3ef1c3b5~tplv-k3u1fbpfcp-zoom-1.image.06b69752.png";function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ul:"ul",li:"li",h2:"h2",h3:"h3",pre:"pre",code:"code",img:"img",blockquote:"blockquote",br:"br",h4:"h4"},(0,d.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"15-多元函数解决方案从编码工具视角看偏函数柯里化",children:["15 “多元函数”解决方案：从编码工具视角看偏函数&柯里化",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#15-多元函数解决方案从编码工具视角看偏函数柯里化",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"偏函数和柯里化堪称面试场上的“老八股”了，结合近两年面试的“行情”来看，大部分 3-5 年经验的前端同学都能够对这两者的概念进行充分的阐释和辨析，但却常常在 code test 环节折戟。"}),"\n",(0,c.jsx)(e.p,{children:"截止目前，当偏函数和柯里化出现在大家视野里的时候，它更多地是作为一道“名词解释题”，而非一个“编码工具”。"}),"\n",(0,c.jsx)(e.p,{children:"然而，要想理解偏函数和柯里化，最简单的姿势其实恰恰是从“编码工具”这个角度切入。"}),"\n",(0,c.jsx)(e.p,{children:"本节，我们就将从“编码工具”的角度来认识它们。"}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"认识一个锤子，我们首先要知道它可以被用来对付哪些钉子。"})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"认识一个编码工具，我们首先要知道它可以被用来解决哪些问题。"})}),"\n",(0,c.jsx)(e.p,{children:"偏函数和柯里化解决的最核心的问题有两个，分别是："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"函数组合链中的多元参数问题"}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"函数逻辑复用的问题"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.h2,{id:"函数组合链中的多元参数问题",children:["函数组合链中的多元参数问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#函数组合链中的多元参数问题",children:"#"})]}),"\n",(0,c.jsxs)(e.h3,{id:"理解函数中的元数arity",children:["理解函数中的“元数(Arity)”",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#理解函数中的元数arity",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"函数参数里的“元数”，指的其实就是函数参数的数量。"}),"\n",(0,c.jsxs)(e.p,{children:["在数学里，我们管",(0,c.jsx)(e.strong,{children:"只包含一个自变量的函数方程式"}),"叫“一元函数”，比如这种："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"y = x + 1   \ny = f(x)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["相应地，",(0,c.jsx)(e.strong,{children:"包含两个自变量的函数方程式"}),"就叫二元函数，比如这种："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"z = x + y  \nz = f(x, y)\n"})}),"\n",(0,c.jsx)(e.p,{children:"类比到 JS 函数里来说，单个入参的函数就是一元函数，像这种："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function double(x) {\n  return x*2\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"两个入参的函数就是二元函数，像这种："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function add(x, y) {\n  return x+y\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"显然，“多元函数”指的就是有多个（n个）入参的函数，像这种："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function multiple(x,y........n) {\n  return ....\n}\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"函数组合链中的参数对齐问题",children:["函数组合链中的参数对齐问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#函数组合链中的参数对齐问题",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"函数组合虽好，但各种限制少不了。现在请大家简单回顾一下上一节我们徒手撸过的 Pipe 函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 使用展开符来获取数组格式的 pipe 参数\nfunction pipe(...funcs) {\n  function callback(input, func) {\n    return func(input)\n  }  \n\n  return function(param) {\n    return funcs.reduce(callback,param)\n  }\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"当时我们给出的调用示例是这样的："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const compute = pipe(add4, multiply3, divide2)\n"})}),"\n",(0,c.jsx)(e.p,{children:"仔细一看，调用链的三个函数齐刷刷都是一元函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 一元函数，一个入参\nfunction add4(num) {\n  return num + 4\n}  \n\n// 一元函数，一个入参\nfunction multiply3(num) {\n  return num*3\n}  \n\n// 一元函数，一个入参\nfunction divide2(num) {\n  return num/2\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"这个属于是理想情况了。有的时候，一个调用链中的函数彼此之间可能并没有这么和谐。"}),"\n",(0,c.jsx)(e.p,{children:"举个例子，假如说我做乘法的时候，手边并没有一个 multiply3， 只有一个乘数和被乘数都可以自定义的函数，如下："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function multiply(x, y) {\n  return x*y\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"一元函数 multiply3 变成了二元函数 multiply，此时咱们若是把 multiply 直接丢回 pipe 链中去，那指定是要倒沫子的："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const compute = pipe(add4, multiply, divide2)\n// 输出 NaN\ncompute(20)\n"})}),"\n",(0,c.jsx)(e.p,{children:"这段代码的执行结果如图："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"竟然输出 NaN 了，为啥呢？当然是因为咱的 reduce callback 只能消化一个入参啦："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function callback(input, func) {\n  return func(input)\n}  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["当执行到 ",(0,c.jsx)(e.code,{children:" callback(input, multiply)  "}),"时，multiply 函数期望可以接收 2 个 number 类型的入参，但实际调用时却只传入了一个 number 类型的入参："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"multiply(input)\n"})}),"\n",(0,c.jsx)(e.p,{children:"这个调用等价于："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"multiply(input, undefined)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["一个数字乘以 ",(0,c.jsx)(e.code,{children:"undefined"}),"，结果自然是 ",(0,c.jsx)(e.code,{children:"NaN"})," 啦。"]}),"\n",(0,c.jsx)(e.p,{children:"对于函数组合链来说，它总是预期链上的函数是一元函数：函数吃进一个入参，吐出一个出参，然后这个出参又会作为下一个一元函数的入参......参数个数的对齐，是组合链能够运转的前提。"}),"\n",(0,c.jsx)(e.p,{children:"一旦链上乱入了多元函数，那么多元函数的入参数量就无法和上一个函数的出参数量对齐，进而导致执行错误。"}),"\n",(0,c.jsx)(e.p,{children:"这也就是我们小标题中所说的“参数对齐”问题。"}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["tips：函数组合链上的函数总是一元函数，这是一个通用且广泛的约定，但并不是一个“死规矩”。",(0,c.jsx)(e.br,{}),"\n","有时候，我们可以通过适当的改造，使组合链接受多元函数。比如 ramda.js 中的 pipe 函数，就允许链上的第一个函数有任意多个参数（注意，仅仅是第一个函数有此“特权”，其余函数仍然必须是一元函数）。"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"这可咋办呢？"}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"任何时候，只要我们想要对函数的入参数量进行改造，必须先想到偏函数&柯里化。"})}),"\n",(0,c.jsxs)(e.h3,{id:"求解多元参数问题",children:["求解多元参数问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#求解多元参数问题",children:"#"})]}),"\n",(0,c.jsxs)(e.h4,{id:"柯里化的概念与实现",children:["柯里化的概念与实现",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#柯里化的概念与实现",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"为了确保知识的完整性，这里我还是不能免俗地要做一下名词解释。"}),"\n",(0,c.jsx)(e.p,{children:"先来说说柯里化，维基百科中对柯里化有着这样的定义：\xa0 \xa0\xa0"}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。"}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["通俗来讲，它是这个意思：\xa0柯里化是把 ",(0,c.jsx)(e.strong,{children:"1 个 n 元函数"}),"改造为 ",(0,c.jsx)(e.strong,{children:"n 个相互嵌套的一元函数"}),"的过程。"]}),"\n",(0,c.jsxs)(e.p,{children:["再具体一点，就是说柯里化是一个把 ",(0,c.jsx)(e.code,{children:"fn(a, b, c)"}),"转化为",(0,c.jsx)(e.code,{children:"fn(a)(b)(c)"}),"的过程。"]}),"\n",(0,c.jsx)(e.p,{children:"举个例子，我有一个函数，可以将任意三个数相加："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function addThreeNum(a, b, c) {\n  return a+b+c\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["正常调用的话就是 ",(0,c.jsx)(e.code,{children:"addThreeNum(1, 2, 3)"})," 这样的。"]}),"\n",(0,c.jsxs)(e.p,{children:["但是通过柯里化，我可以把调用姿势改造为 ",(0,c.jsx)(e.code,{children:"addThreeNum(1)(2)(3)"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"如何做到呢？ 一个最直接的想法是在原有的函数上做改造，像这样（解析见注释）："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 将原函数改造为三个嵌套的一元函数\nfunction addThreeNum(a) {\n  // 第一个函数用于记住参数a\n  return function(b) {\n    // 第二个函数用于记住参数b\n    return function(c) {\n      // 第三个函数用于执行计算\n      return a+b+c\n    }\n  }\n}\n\n// 输出6，输出结果符合预期\naddThreeNum(1)(2)(3)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["但是，我们在",(0,c.jsx)(e.a,{href:"https://juejin.cn/book/6844733790204461070",target:"_blank",rel:"noopener noreferrer",children:"设计模式"}),"中强调过“开放封闭”原则——",(0,c.jsx)(e.strong,{children:"对拓展开放，对修改封闭"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"直接修改现有函数，显然违背了这一原则。"}),"\n",(0,c.jsxs)(e.p,{children:["有没有什么姿势，可以允许我在",(0,c.jsx)(e.strong,{children:"保留原有函数的基础上，单纯通过增量代码来实现柯里化"}),"呢？"]}),"\n",(0,c.jsx)(e.p,{children:"当然有啦！高阶函数不就是干这个的么！"}),"\n",(0,c.jsx)(e.p,{children:"下面我就针对加法这个场景，创建了一个名为 curry 的高阶函数（解析在注释里）："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 定义高阶函数 curry\nfunction curry(addThreeNum) {\n  // 返回一个嵌套了三层的函数\n  return function addA(a) {\n    // 第一层“记住”参数a\n    return function addB(b) {\n      // 第二层“记住”参数b\n      return function addC(c) {\n        // 第三层直接调用现有函数 addThreeNum\n        return addThreeNum(a, b, c)\n      }\n    }\n  }\n}\n\n// 借助 curry 函数将 add\nconst curriedAddThreeNum = curry(addThreeNum)\n// 输出6，输出结果符合预期\ncurriedAddThreeNum(1)(2)(3)\n"})}),"\n",(0,c.jsxs)(e.h4,{id:"偏函数-vs-柯里化",children:["偏函数 VS 柯里化",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#偏函数-vs-柯里化",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"在理解了柯里化的基础上，理解偏函数就是小菜一碟了。"}),"\n",(0,c.jsx)(e.p,{children:"这里为了体现对专业术语的respect，我仍然是象征性地先放一段维基百科的解释："}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["在计算机科学中，",(0,c.jsx)(e.strong,{children:"部分应用"}),"（或部分函数应用）指的是将一些参数固定在一个函数上，产生另一个较小元的函数的过程。"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"tips: 偏函数英文是 partial application， 直译过来就是“部分应用”。"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"元的概念我们开篇就捋清楚了。所以这个定义其实并不难懂，通俗来说："}),"\n",(0,c.jsxs)(e.p,{children:["偏函数是指通过",(0,c.jsx)(e.strong,{children:"固定函数的一部分参数"}),"，生成一个",(0,c.jsx)(e.strong,{children:"参数数量更少的函数"}),"的过程。"]}),"\n",(0,c.jsx)(e.p,{children:"咱来捋捋啊："}),"\n",(0,c.jsx)(e.p,{children:"柯里化说的是一个 n 元函数变成 n 个一元函数。"}),"\n",(0,c.jsx)(e.p,{children:"偏函数说的是一个 n 元函数变成一个 m(m < n） 元函数。"}),"\n",(0,c.jsx)(e.p,{children:"对于柯里化来说，不仅函数的元发生了变化，函数的数量也发生了变化（1个变成n个）。"}),"\n",(0,c.jsx)(e.p,{children:"对于偏函数来说，仅有函数的元发生了变化（减少了），函数的数量是不变的。"}),"\n",(0,c.jsx)(e.p,{children:"也就是说对于一个调用姿势长这样的四元函数来说："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"func(a, b, c, d)\n"})}),"\n",(0,c.jsx)(e.p,{children:"我们可以固定第一个入参，使其缩减为一个三元函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"func(b, c, d)\n"})}),"\n",(0,c.jsx)(e.p,{children:"也可以固定前两个入参，使其缩减为一个二元函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"func(c, d)\n"})}),"\n",(0,c.jsx)(e.p,{children:"总之，只要它的元比之前小，就满足了偏函数的要求。"}),"\n",(0,c.jsxs)(e.h4,{id:"偏函数求解组合链中的参数对齐问题",children:["偏函数求解组合链中的参数对齐问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#偏函数求解组合链中的参数对齐问题",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"对于开篇提到的组合链的“参数对齐”问题来说，偏函数就是一个不错的解法。"}),"\n",(0,c.jsx)(e.p,{children:"偏函数的实现思路是固定一部分函数参数，这里我仍然延续高阶函数的思路，对现有函数进行一定的“包装”来达到目的："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 定义一个包装函数，专门用来处理偏函数逻辑\nfunction wrapFunc(func, fixedValue) {\n  // 包装函数的目标输出是一个新的函数\n  function wrappedFunc(input){\n    // 这个函数会固定 fixedValue，然后把 input 作为动态参数读取\n    const newFunc = func(input, fixedValue)\n    return newFunc\n  }\n  return wrappedFunc\n}\nconst multiply3 = wrapFunc(multiply, 3)\n\n// 输出6\nmultiply3(2)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这样就成功固定了 ",(0,c.jsx)(e.code,{children:"multiply"})," 函数的第一个入参 x，得到了一个一元函数 ",(0,c.jsx)(e.code,{children:"multiply3"}),"，这完全符合组合链对函数元的预期。"]}),"\n",(0,c.jsxs)(e.h2,{id:"函数逻辑复用问题",children:["函数逻辑复用问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#函数逻辑复用问题",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["当我们看到偏函数和柯里化的实现分别都借助了",(0,c.jsx)(e.strong,{children:"高阶函数"}),"后，“逻辑复用”几乎是一件不言而喻的事情了。"]}),"\n",(0,c.jsxs)(e.h3,{id:"参数固定-复用存量逻辑",children:["参数固定-复用存量逻辑",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参数固定-复用存量逻辑",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["在 multiply3 这个例子中，偏函数除了解决了",(0,c.jsx)(e.strong,{children:"函数的元的问题"}),"，还充分地",(0,c.jsx)(e.strong,{children:"对现有逻辑进行了复用"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["multiply 函数是一个存量函数，我们的目标函数 ",(0,c.jsx)(e.strong,{children:"multiply3 其实可以看作是 multiply 函数功能的一个子集"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["这种情况下，与其单独定义一个 ",(0,c.jsx)(e.code,{children:"multiply3"}),"，不如试着通过偏函数处理实现对存量逻辑 ",(0,c.jsx)(e.strong,{children:(0,c.jsx)(e.code,{children:"multiply"})})," 的定制。"]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"multiply3"}),"、",(0,c.jsx)(e.code,{children:"multiply"})," 两个函数的逻辑都不算复杂，复用带来的利好体现得还不算特别明显。"]}),"\n",(0,c.jsx)(e.p,{children:"但在实际的应用中，我们的存量函数逻辑可以是非常复杂的。"}),"\n",(0,c.jsx)(e.p,{children:"比如我曾经在业务逻辑中，见到一个处理订单数据的函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function generateOrderData(type, area, settlement) {\n  // 省略数十行难以理解的业务逻辑......\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"generateOrderData"})," 通过读取订单类型、订单地区、订单结算信息等参数，对订单信息进行重构，最终输出一套能够供 UI 层直接消化的渲染数据。"]}),"\n",(0,c.jsx)(e.p,{children:"这样一个函数的改造成本是很高的。"}),"\n",(0,c.jsxs)(e.p,{children:["如果我们遇到一个场景，期望能够针对某一个特定区域、特定类型的订单数据进行计算（也就是固定 ",(0,c.jsx)(e.code,{children:"type"}),"、",(0,c.jsx)(e.code,{children:"area"})," 这两个参数），对应函数名为 ",(0,c.jsx)(e.code,{children:"generateSpecOrderData(settlement)"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["相比于参考 ",(0,c.jsx)(e.code,{children:"generateOrderData"})," 的具体逻辑重新写一个 ",(0,c.jsx)(e.code,{children:"generateSpecOrderData"})," 出来，直接在 ",(0,c.jsx)(e.code,{children:"generateOrderData"})," 的基础上做偏函数处理不仅可以帮助我们避免大量的重复代码，同时也省去了读函数、理解函数的时间成本——毕竟，做偏函数处理只需要我们了解函数的入参规则就可以了。"]}),"\n",(0,c.jsxs)(e.h3,{id:"缩小函数的元数-减少重复传参",children:["缩小函数的元数-减少重复传参",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#缩小函数的元数-减少重复传参",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"偏函数不仅仅可以帮我们减少定义函数时的重复代码，还可以帮我们减少调用函数时的重复传参。"}),"\n",(0,c.jsxs)(e.p,{children:["在 ",(0,c.jsx)(e.code,{children:"generateSpecOrderData"})," 函数被定义出来之前，我在项目里见到了大量这样的代码："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 文件 a\nconst res = generateOrderData('food', 'hunan', normalSettlement)\n\n// 文件 b\nconst UIData = generateOrderData('food', 'hunan', orderSettlement)  \n\n// 文件 c  \nconst result = generateOrderData('food', 'hunan', couponSettlement)  \n"})}),"\n",(0,c.jsxs)(e.p,{children:["不同的调用，重复的传参，重复的 ",(0,c.jsx)(e.code,{children:"food"})," + ",(0,c.jsx)(e.code,{children:"hunan"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["而偏函数恰恰就可以把 ",(0,c.jsx)(e.code,{children:"food"})," 和 ",(0,c.jsx)(e.code,{children:"hunan"})," “记忆”下来，帮助我们避免这些重复。"]}),"\n",(0,c.jsx)(e.p,{children:"实际上，通用函数为了确保其自身的灵活性，往往都具备“多元参数”的特征。但在一些特定的业务场景下，真正需要动态变化的只是其中的一部分的参数。这时候函数的一部分灵活性对我们来说是多余的，我们反而希望它的功能具体一点。"}),"\n",(0,c.jsxs)(e.p,{children:["比如 ",(0,c.jsx)(e.code,{children:"generateSpecOrderData"})," 函数，就对 ",(0,c.jsx)(e.code,{children:"type"})," 和 ",(0,c.jsx)(e.code,{children:"area"})," 并不感冒，只是想动态传入 ",(0,c.jsx)(e.code,{children:"settlement"})," 而已。"]}),"\n",(0,c.jsx)(e.p,{children:"这种场景下，偏函数出来扛大旗就再合适不过了。"}),"\n",(0,c.jsx)(e.p,{children:"至此，我们已经通过一些实例理解了偏函数和柯里化两者的概念和用途，并且结合函数组合链的例子，对偏函数解决问题的方式有了具体的认知。"}),"\n",(0,c.jsx)(e.p,{children:"开篇我们说过，偏函数和柯里化是一脉相承，它们解决的其实是同一类问题。"}),"\n",(0,c.jsx)(e.p,{children:"也就是说函数组合链的参数对不齐问题，用柯里化也是可以解决的，并且柯里化也能够协助我们更好地复用函数逻辑。"}),"\n",(0,c.jsx)(e.p,{children:"如何证明这一点呢？这里先留作思考题给大家，我在下一节会给出答案，并且带大家一起实现一个通用的柯里化函数。"}),"\n",(0,c.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(l,{...n})}):l(n)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F15%20%E2%80%9C%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E2%80%9D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E4%BB%8E%E7%BC%96%E7%A0%81%E5%B7%A5%E5%85%B7%E8%A7%86%E8%A7%92%E7%9C%8B%E5%81%8F%E5%87%BD%E6%95%B0%26%E6%9F%AF%E9%87%8C%E5%8C%96.md"]={toc:[{text:"函数组合链中的多元参数问题",id:"函数组合链中的多元参数问题",depth:2},{text:"理解函数中的“元数(Arity)”",id:"理解函数中的元数arity",depth:3},{text:"函数组合链中的参数对齐问题",id:"函数组合链中的参数对齐问题",depth:3},{text:"求解多元参数问题",id:"求解多元参数问题",depth:3},{text:"柯里化的概念与实现",id:"柯里化的概念与实现",depth:4},{text:"偏函数 VS 柯里化",id:"偏函数-vs-柯里化",depth:4},{text:"偏函数求解组合链中的参数对齐问题",id:"偏函数求解组合链中的参数对齐问题",depth:4},{text:"函数逻辑复用问题",id:"函数逻辑复用问题",depth:2},{text:"参数固定-复用存量逻辑",id:"参数固定-复用存量逻辑",depth:3},{text:"缩小函数的元数-减少重复传参",id:"缩小函数的元数-减少重复传参",depth:3}],title:"15 “多元函数”解决方案：从编码工具视角看偏函数&柯里化",headingTitle:"15 “多元函数”解决方案：从编码工具视角看偏函数&柯里化",frontmatter:{}}}}]);