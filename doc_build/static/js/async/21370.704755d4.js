"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["21370"],{322140:function(e,n,r){e.exports=r.p+"static/image/0dc471f4fefa10174049eb92de24abd1.44d5e1e6.webp"},559806:function(e,n,r){e.exports=r.p+"static/image/b0bb8d15a0f0cda2c0bb51d7be0d26d9.cec8c24a.webp"},242206:function(e,n,r){e.exports=r.p+"static/image/bc2862ddc1150c4bf5903d6a741d6f22.bd4871c6.webp"},402382:function(e,n,r){r.r(n),r.d(n,{default:()=>I});var s=r(552676),a=r(740453);let c=r.p+"static/image/a3fa0f8561636d67d37b10aa5b947f96.7a13fa3e.gif",t=r.p+"static/image/c07855cc3060e6f272062c513614e9cb.31e96cc5.webp",i=r.p+"static/image/a19ef3f3a5e5beddda47969b4f6240b5.14b18706.gif",d=r.p+"static/image/8a889bf587bcc0d8740935a6f4fac30c.f2587efc.gif",l=r.p+"static/image/ef20a4b1125dcab2472e50747e750e23.800440af.webp",p=r.p+"static/image/f85696060fc0c4a10a081a06e78c4ef5.54f66e41.webp";var o=r(322140);let f=r.p+"static/image/b1f76a2fa1d696d3b0f9b37a7596562f.057b1329.gif",m=r.p+"static/image/9857377398ec3dafe68001814d5af94f.7f25fd58.webp",g=r.p+"static/image/a849c0f2e51d86eb6669f40fcecb4e9e.5c98cfef.webp",j=r.p+"static/image/38a7bf7e6f877e16132e6e4ac34d75c1.8971cd7f.webp",x=r.p+"static/image/5f1894c2cd32a8f50d9d2a6adeb786a5.b969aa33.webp",h=r.p+"static/image/b9f8833fb0e2a91372d776848346bc38.bd4c27bf.webp",b=r.p+"static/image/4fff73fcae8f07e0e6d2657d2e66d243.73ceb57f.webp",u=r.p+"static/image/d5858d16535983f3c74a4c65c6b0e4ce.af353c8a.webp",E=r.p+"static/image/97091289f0595b2916e97b771791b24c.d2dd1a32.webp",k=r.p+"static/image/d821277c444533c6c712fedba8775b53.22d2ec3d.webp",w=r.p+"static/image/f927992319a293a74acae87be0c4bbb9.514c9ad1.webp",R=r.p+"static/image/d7bfb1edfc4f922c7bcbd4b4d1f0c09f.01c0c239.gif";var C=r(242206);let M=r.p+"static/image/5e86e41860824b356ef9828c1bb6c68d.8fa3e602.webp";var v=r(559806);let y=r.p+"static/image/073eba6808e37537a180b22724c75975.dfdbae16.gif",_=r.p+"static/image/0edd3bb3fc0689fedb7f073a5479480d.01ead794.gif",W=r.p+"static/image/b775c97f7fa8fd738a480521444cdad6.d7616172.webp";function P(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2",strong:"strong"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"第60章reactplayground项目实战webworker性能优化",children:["第60章—ReactPlayground项目实战：WebWorker性能优化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第60章reactplayground项目实战webworker性能优化",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"\uFEFF功能实现的差不多以后，我们做下代码的优化。"}),"\n",(0,s.jsx)(n.p,{children:"大家觉得我们的 playground 有啥性能瓶颈没有？"}),"\n",(0,s.jsx)(n.p,{children:"用 Performace 跑下就知道了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:W,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"用无痕模式打开这个页面，无痕模式下不会跑浏览器插件，比较准确。"}),"\n",(0,s.jsx)(n.p,{children:"打开 devtools，点击 reload 重新加载页面："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"等页面渲染完点击停止，就可以看到录制的性能数据。"}),"\n",(0,s.jsx)(n.p,{children:"按住可以上下左右拖动，按住然后上下滑动可以放大缩小："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这里的 main 就是主线程："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"主线程会通过 event loop 的方式跑一个个宏任务，也就是这里的 task。"}),"\n",(0,s.jsx)(n.p,{children:"超过 50ms 的被称为长任务 long task："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"long task 会导致主线程一直被占据，阻塞渲染，表现出来的就是页面卡顿。"}),"\n",(0,s.jsx)(n.p,{children:"性能优化的目标就是消除这种 long task。"}),"\n",(0,s.jsx)(n.p,{children:"图中的宽度代表耗时，可以看到是 babelTransform 这个方法耗费了 24 ms"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"点击火焰图中的 babelTransform，下面会展示它的代码位置，点击可以跳到 Sources 面板的代码："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是我们要优化性能的代码。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这是 babel 内部代码，怎么优化呢？"}),"\n",(0,s.jsx)(n.p,{children:"其实这段代码就是计算量比较大，我们把它放到单独的 worker 线程来跑就好了，这样就不会占用主线程的时间。"}),"\n",(0,s.jsx)(n.p,{children:"vite 项目用 web worker 可以这样用："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们用一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"把 compiler.ts 改名为 compiler.worker.ts"}),"\n",(0,s.jsx)(n.p,{children:"然后在 worker 线程向主线程 postMessage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"self.postMessage({\n    type: 'COMPILED_CODE',\n    data: 'xx'\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"主线程里创建这个 worker 线程，监听 message 消息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import CompilerWorker from './compiler.worker?worker'\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const compilerWorkerRef = useRef<Worker>();\n\nuseEffect(() => {\n    if(!compilerWorkerRef.current) {\n        compilerWorkerRef.current = new CompilerWorker();\n        compilerWorkerRef.current.addEventListener('message', (data) => {\n            console.log('worker', data)\n        })\n    }\n}, []);\n"})}),"\n",(0,s.jsx)(n.p,{children:"跑一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，主线程接收到了 worker 线程传过来的消息。"}),"\n",(0,s.jsx)(n.p,{children:"反过来通信也是一样的 postMessage 和监听 message 事件。"}),"\n",(0,s.jsx)(n.p,{children:"主线程这边给 worker 线程传递 files，然后拿到 woker 线程传回来的编译后的代码："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useContext, useEffect, useRef, useState } from \"react\"\nimport { PlaygroundContext } from \"../../PlaygroundContext\"\nimport Editor from \"../CodeEditor/Editor\";\nimport iframeRaw from './iframe.html?raw'\nimport { IMPORT_MAP_FILE_NAME } from \"../../files\";\nimport { Message } from \"../Message\";\nimport CompilerWorker from './compiler.worker?worker'\n\ninterface MessageData {\n    data: {\n      type: string\n      message: string\n    }\n}\n\nexport default function Preview() {\n\n    const { files} = useContext(PlaygroundContext)\n    const [compiledCode, setCompiledCode] = useState('')\n    const [error, setError] = useState('')\n\n    const compilerWorkerRef = useRef<Worker>();\n\n    useEffect(() => {\n        if(!compilerWorkerRef.current) {\n            compilerWorkerRef.current = new CompilerWorker();\n            compilerWorkerRef.current.addEventListener('message', ({data}) => {\n                console.log('worker', data);\n                if(data.type === 'COMPILED_CODE') {\n                    setCompiledCode(data.data);\n                } else {\n                    //console.log('error', data);\n                }\n            })\n        }\n    }, []);\n\n    useEffect(() => {\n        compilerWorkerRef.current?.postMessage(files)\n    }, [files]);\n\n    const getIframeUrl = () => {\n        const res = iframeRaw.replace(\n            '<script type=\"importmap\"><\/script>', \n            `<script type=\"importmap\">${\n                files[IMPORT_MAP_FILE_NAME].value\n            }<\/script>`\n        ).replace(\n            '<script type=\"module\" id=\"appSrc\"><\/script>',\n            `<script type=\"module\" id=\"appSrc\">${compiledCode}<\/script>`,\n        )\n        return URL.createObjectURL(new Blob([res], { type: 'text/html' }))\n    }\n\n    useEffect(() => {\n        setIframeUrl(getIframeUrl())\n    }, [files[IMPORT_MAP_FILE_NAME].value, compiledCode]);\n\n    const [iframeUrl, setIframeUrl] = useState(getIframeUrl());\n\n    const handleMessage = (msg: MessageData) => {\n        const { type, message } = msg.data\n        if (type === 'ERROR') {\n          setError(message)\n        }\n    }\n\n    useEffect(() => {\n        window.addEventListener('message', handleMessage)\n        return () => {\n          window.removeEventListener('message', handleMessage)\n        }\n    }, [])\n\n    return <div style={{height: '100%'}}>\n        <iframe\n            src={iframeUrl}\n            style={{\n                width: '100%',\n                height: '100%',\n                padding: 0,\n                border: 'none',\n            }}\n        />\n        <Message type='error' content={error} />\n\n        {/* <Editor file={{\n            name: 'dist.js',\n            value: compiledCode,\n            language: 'javascript'\n        }}/> */}\n    </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"而 worker 线程这边则是监听主线程的 message，传递 files 编译后的代码给主线程："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"self.addEventListener('message', async ({ data }) => {\n    try {\n        self.postMessage({\n            type: 'COMPILED_CODE',\n            data: compile(data)\n        })\n    } catch (e) {\n         self.postMessage({ type: 'ERROR', error: e })\n    }\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，拿到了 worker 线程传过来的编译后的代码："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"预览也正常。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"其实 files 变化没必要那么频繁触发编译，我们加个防抖："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"useEffect(debounce(() => {\n    compilerWorkerRef.current?.postMessage(files)\n}, 500), [files]);\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们再用 performance 看下优化后的效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"之前的编译代码的耗时没有了，现在被转移到了 worker 线程："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"还是 24ms，但是不占据主线程了。"}),"\n",(0,s.jsx)(n.p,{children:"当然，因为我们文件内容很少，所以编译耗时少，如果文件多了，那编译耗时自然也就增加了，拆分就很有必要。"}),"\n",(0,s.jsx)(n.p,{children:"这样，性能优化就完成了。"}),"\n",(0,s.jsx)(n.p,{children:"然后再优化两处代码："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"main.tsx 有个编辑器错误说 StrictMode 不是一个 jsx，这种不用解决，也不影响运行，改下模版把它去掉就行了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"上面那个只要编辑下文件就会触发类型下载，也不用解决："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"再就是我们生成的文件名没必要 6 位随机数："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"改为 4 位正好："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["案例代码上传了",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/react-playground-project",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节我们做了下性能优化。"}),"\n",(0,s.jsxs)(n.p,{children:["我们用 Performance 分析了页面的 Event Loop，发现有 long task，",(0,s.jsx)(n.strong,{children:"性能优化的目标就是消除 long task"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"分析发现是 babel 编译的逻辑导致的。"}),"\n",(0,s.jsx)(n.p,{children:"我们通过 Web Worker 把 babel 编译的逻辑放到了 worker 线程跑，通过 message 事件和 postMessage 和主线程通信。"}),"\n",(0,s.jsx)(n.p,{children:"拆分后功能正常，再用 Performance 分析，发现耗时逻辑被转移到了 worker 线程，主线程这个 long task 没有了。"}),"\n",(0,s.jsx)(n.p,{children:"这样就达到了性能优化的目的。"}),"\n",(0,s.jsx)(n.p,{children:"当需要编译的文件多了之后，这种性能优化就更有意义。"})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(P,{...e})}):P(e)}let I=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC60%E7%AB%A0%E2%80%94ReactPlayground%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9AWebWorker%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第60章—ReactPlayground项目实战：WebWorker性能优化",headingTitle:"第60章—ReactPlayground项目实战：WebWorker性能优化",frontmatter:{}}}}]);