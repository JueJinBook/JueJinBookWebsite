"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["76010"],{409741:function(e,n,c){c.r(n),c.d(n,{default:()=>o});var r=c(552676),s=c(740453);let d=c.p+"static/image/53396df5d8dd6f026fcd8a4e4add9cb6.e6675f01.webp",l=c.p+"static/image/8429c6bca64e4da4165095fe5454e507.812e538a.webp",i=c.p+"static/image/bee1006b28fef1c68f7249dd0a2a9e58.7480f691.webp",t=c.p+"static/image/a27ad0c6301c111eb7f74b65b604cf46.1c4f4020.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",ul:"ul",li:"li",code:"code",h3:"h3",pre:"pre",blockquote:"blockquote",img:"img",h4:"h4"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"35原理篇-更新流程进入调度任务",children:["35.原理篇-更新流程：进入调度任务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#35原理篇-更新流程进入调度任务",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"小贴士：有一些同学反馈调和和调度的章节听着有点懵，不能很好的串联起来，那么笔者打算写本章节作为前两个章节的补充和完善。"}),"\n",(0,r.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["之前的",(0,r.jsx)(n.strong,{children:"调度"}),"和",(0,r.jsx)(n.strong,{children:"调和"}),"章节分别讲解了调度的本质（时间分片，请求帧）和调和的流程（两大阶段 render 和 commit ）。本章节将继续围绕着核心的两部分展开。"]}),"\n",(0,r.jsx)(n.p,{children:"那么首先来回顾一下两者的概念："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"调度"}),"："]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"用一段简单的例子描述调度到底做了什么事？假设每一个更新，可以看作一个人拿着材料去办事处办理业务。那么办事处处理每一个人的业务需要时间，并且工作人员，需要维护办事处的正常运转，不能全身心投入给顾客办理业务，那么办事处应该如何处理呢？"}),"\n",(0,r.jsx)(n.p,{children:"1 首先需要所有来访的顾客排成一队。然后工作人员开始逐一受理业务，不能让工作人员一直办理业务，如果一直办理，假设任务过多的情况，那么会一直占用工作人员时间，前面说到办事处需要正常运转，如果这样就无法正常运转了。"}),"\n",(0,r.jsx)(n.p,{children:"2 那么工作人员每次办理一个任务后，就先维持办事处的正常运转，等到工作人员有闲暇的时间，再来办理下一个业务。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"那么调度的作用就显而易见了"}),"，首先调度一定是在多个任务情况下，单个更新任务就没调度可言了；多个任务情况下，如果一口气执行完所有更新任务，那么就会阻塞浏览器的正常渲染，给用户体验上就是卡住了。那么调度任务就是每一次执行一个任务，然后先让浏览器完成后续的渲染操作，然后在空暇时间，再执行下一个任务。"]}),"\n",(0,r.jsx)(n.p,{children:"在 v18 调度任务还有一些调整。还是拿办理业务这个例子。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Legacy"})," 模式下：在 v17 及其以下版本，所有的任务都是紧急任务，那么所有来办理的人员都是平等的，所以工作人员只需要按序办理业务就可以了。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"v18 Concurrent"})," 模式下：在 v18 模式下，正常紧急的任务都可以看作是会员，一些优先级低的任务比如 ",(0,r.jsx)(n.code,{children:"transtion"})," 过渡任务，可以看作非会员。如果会员和非会员排列到一起，那么优先会办理会员的业务（正常的紧急优先任务），正常情况下，会办理完所有的会员业务，才开始办理非会员任务；但是在一些极端的情况下，怕会员一直办理，非会员无法办理（被饿死的情况），所以设置一个超时时间，达到超时时间，会破格执行一个非会员任务。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"调和"}),"："]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"上面介绍了调度的本质，再来举一个例子描述一个调和流程。"})," 假设我们的应用看作一台设备，那么每一次更新，看作一次检修维护更新，那么维修师傅应该如何检修呢？ 维修师傅会用一个机器 （workLoop可以看作这个机器） ，依次检查每一个需要维护更新的零件（fiber可以看作零件），每一个需要检修的零件都会进入检查流程，如果需要更新，那么会更新，如果有子零件更新（子代 fiber），那么父代本身也会进入到机器运转（ workloop ）流程中。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Legacy"})," 模式下：在这个模式下，所有的零件维修，没有优先级的区分，所有的更新工作都被维修师傅依次检查执行。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Concurrent"})," 模式下：我们都清楚，对于设备的维修，实际有很多种类，比如影响设备运转的，那么这种维修任务迫在眉睫，还有一种就是相比不是那么重要的，比如机器打蜡，清理等，那么在 Concurrent 下的 workloop，就像师傅在用机器检修零件，但是遇到更高优先处理的任务，就会暂定当前零件的检修，而去检修更重要的任务一样。"]}),"\n",(0,r.jsx)(n.p,{children:"上面用两个例子描述了调度和调和的流程，那么两者之间的关系是什么呢？"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"调度"}),"：首先调度目的针对",(0,r.jsx)(n.strong,{children:"多个更新任务"}),"的情况，调度让多个任务井然有序的执行，执行任务的同时，也不要影响浏览器的绘制。调度决定着更新任务的执行时期。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"调和"}),"：一旦更新任务执行，那么就会进入调和流程，说白了就是根据 state 的改变，去切实地更新视图。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"接下来将重点介绍一下 Legacy 模式下调度任务是如何衔接的。"}),"\n",(0,r.jsxs)(n.h2,{id:"二-更新之溯源",children:["二 更新之溯源",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-更新之溯源",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 Legacy 下的 React 应用中，更新本质上有两种："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"第一种就是初始化的时候第一次页面的呈现。"}),"\n",(0,r.jsxs)(n.li,{children:["第二种就是初始化完毕，state 的更新，比如点击按钮，触发 ",(0,r.jsx)(n.code,{children:"setState"})," 或者 ",(0,r.jsx)(n.code,{children:"useState"}),"。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"接下来一一分析上面两个流程。"}),"\n",(0,r.jsxs)(n.h3,{id:"1-从-reactdomrender-看初始化流程",children:["1 从 ReactDOM.render 看初始化流程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-从-reactdomrender-看初始化流程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"假设现在开始初始化我们的应用，那么 Legacy 模式下是从 ReactDOM.render 开始的，一个传统的应用的开始应该是这个样子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import ReactDOM from 'react-dom'\n/* 通过 ReactDOM.render  */\nReactDOM.render(\n    <App />,\n    document.getElementById('app')\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:"那么 ReactDOM.render 到底做了什么呢？ 在 ReactDOM.render 做的事情是形成一个 Fiber Tree 挂载到 app 上。来看一下主要流程。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-dom/src/client/ReactDOMLegacy.js -> legacyRenderSubtreeIntoContainer"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function legacyRenderSubtreeIntoContainer(\n    parentComponent,  // null\n    children,         // <App/> 跟部组件\n    container,        // app dom 元素\n    forceHydrate,\n    callback          // ReactDOM.render 第三个参数回调函数。\n){\n    let root = container._reactRootContainer\n    let fiberRoot\n    if(!root){\n        /* 创建 fiber Root */\n        root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container,forceHydrate);\n        fiberRoot = root._internalRoot;\n        /* 处理 callback 逻辑，这里可以省略 */\n        /* 注意初始化这里用的是 unbatch */\n        unbatchedUpdates(() => {\n            /*  开始更新  */\n            updateContainer(children, fiberRoot, parentComponent, callback);\n        });\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["调用  ReactDOM.render 本质上就是 ",(0,r.jsx)(n.code,{children:"legacyRenderSubtreeIntoContainer"})," 方法。这个方法的主要做的事情是："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["创建整个应用的 ",(0,r.jsx)(n.code,{children:"FiberRoot"})," 。"]}),"\n",(0,r.jsxs)(n.li,{children:["然后调用 ",(0,r.jsx)(n.code,{children:"updateContainer"})," 开始初始化更新。"]}),"\n",(0,r.jsxs)(n.li,{children:["这里注意⚠️的是，用的是 ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"unbatch"})})," （非批量的情况），并不是批量更新的 ",(0,r.jsx)(n.code,{children:"batchUpdate"})," 。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["那么所有更新流程矛头都指向了 updateContainer ，那么接下来看一下 ",(0,r.jsx)(n.code,{children:"updateContainer"})," 主要做了哪些事。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reonciler/src/ReactFiberReconciler.js -> updateContainer"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function updateContainer(element,container,parentComponent,callback){\n    /* 计算优先级，在v16及以下版本用的是 expirationTime ，在 v17 ,v18 版本，用的是 lane。  */\n    const lane = requestUpdateLane(current);\n    /* 创建一个 update */\n    const update = createUpdate(eventTime, lane);\n    enqueueUpdate(current, update, lane);\n    /* 开始调度更新 */\n    const root = scheduleUpdateOnFiber(current, lane, eventTime);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"通过上面代码的简化，可以清晰的看出来 updateContainer 做了哪些事。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["首先计算更新优先级 ",(0,r.jsx)(n.code,{children:"lane"})," ，老版本用的是 ",(0,r.jsx)(n.code,{children:"expirationTime"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:["然后创建一个 ",(0,r.jsx)(n.code,{children:"update"})," ，通过 ",(0,r.jsx)(n.code,{children:"enqueueUpdate"})," 把当前的 update 放入到待更新队列 ",(0,r.jsx)(n.code,{children:"updateQueue"})," 中。"]}),"\n",(0,r.jsxs)(n.li,{children:["接下来开始调用 ",(0,r.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," ，开始进入调度更新流程中。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"到此为止，可以总结出，初始化更新的时候，最后调用的是 scheduleUpdateOnFiber，开始进入更新流程。具体逻辑一会会讲到。"}),"\n",(0,r.jsxs)(n.h3,{id:"2-从-usestate--setstate-看更新流程",children:["2 从 useState | setState 看更新流程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-从-usestate--setstate-看更新流程",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上面说到了初始化流程，接下来如果发生一次更新，比如一次点击事件带来的 state 的更新。我们这里分",(0,r.jsx)(n.strong,{children:"类组件"}),"和",(0,r.jsx)(n.strong,{children:"函数组件"}),"分别看一下："]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["类组件之 ",(0,r.jsx)(n.code,{children:"setState"})]}),"："]}),"\n",(0,r.jsxs)(n.p,{children:["在 state 章节讲到过，当触发 setState 本质上是调用 ",(0,r.jsx)(n.code,{children:"enqueueSetState"}),"。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberClassComponent.js -> enqueueSetState"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"enqueueSetState(inst,payload,callback){\n    const update = createUpdate(eventTime, lane);\n    enqueueUpdate(fiber, update, lane);\n    const root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到 setState 流程和初始化的流程一样。那么再看一下 hooks 的 ",(0,r.jsx)(n.code,{children:"useState"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["函数组件之 ",(0,r.jsx)(n.code,{children:"useState"})]})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberHooks.js -> dispatchAction"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function dispatchAction(fiber, queue, action) {\n    var lane = requestUpdateLane(fiber);\n    scheduleUpdateOnFiber(fiber, lane, eventTime);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面只保留了 dispatchAction 的核心逻辑，可以清楚的发现，无论是初始化，useState，setState 最后都是调用 ",(0,r.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," 方法。那么这个就是整个更新的入口。那么这个方法做了些什么事情呢？"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-更新入口-scheduleupdateonfiber",children:["3 更新入口 scheduleUpdateOnFiber",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-更新入口-scheduleupdateonfiber",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js -> scheduleUpdateOnFiber"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function scheduleUpdateOnFiber(fiber,lane,eventTime){\n    if (lane === SyncLane) {\n        if (\n            (executionContext & LegacyUnbatchedContext) !== NoContext && // unbatch 情况，比如初始化\n            (executionContext & (RenderContext | CommitContext)) === NoContext) {\n            /* 开始同步更新，进入到 workloop 流程 */    \n            performSyncWorkOnRoot(root);\n         }else{\n               /* 进入调度，把任务放入调度中 */\n               ensureRootIsScheduled(root, eventTime);\n               if (executionContext === NoContext) {\n                   /* 当前的执行任务类型为 NoContext ，说明当前任务是非可控的，那么会调用 flushSyncCallbackQueue 方法。 */\n                   flushSyncCallbackQueue();\n               }\n         }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["scheduleUpdateOnFiber 的核心逻辑如上，正常情况下，大多数任务都是 ",(0,r.jsx)(n.code,{children:"SyncLane"}),"。即便在异步任务里面触发的更新，比如在 ",(0,r.jsx)(n.code,{children:"Promise"})," 或者是 ",(0,r.jsx)(n.code,{children:"setTimeout"})," 里面的更新，也是 ",(0,r.jsx)(n.code,{children:"SyncLane"}),"，两者之间没有太大的联系。所以上述核心代码中，只保留了 ",(0,r.jsx)(n.code,{children:"SyncLane"})," 的逻辑。"]}),"\n",(0,r.jsxs)(n.p,{children:["那么在 ",(0,r.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," 内部主要做的事情是："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["在 ",(0,r.jsx)(n.code,{children:"unbatch"})," 情况下，会直接进入到 performSyncWorkOnRoot ，接下来会进入到 ",(0,r.jsx)(n.strong,{children:"调和流程"}),"，比如 ",(0,r.jsx)(n.code,{children:"render"})," ，",(0,r.jsx)(n.code,{children:"commit"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:["那么任务是 ",(0,r.jsx)(n.code,{children:"useState"})," 和 ",(0,r.jsx)(n.code,{children:"setState"}),"，那么会进入到 ",(0,r.jsx)(n.code,{children:"else"})," 流程，那么会进入到 ",(0,r.jsx)(n.code,{children:"ensureRootIsScheduled"})," 调度流程。"]}),"\n",(0,r.jsxs)(n.li,{children:["当前的执行任务类型为 ",(0,r.jsx)(n.code,{children:"NoContext"})," ，说明当前任务是非可控的，那么会调用 ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"})," 方法。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["通过上面知道了，",(0,r.jsx)(n.strong,{children:"performSyncWorkOnRoot"})," ： 这个方法会直接进入到调和阶段，会从 rootFiber 开始向下遍历。 ",(0,r.jsx)(n.strong,{children:"ensureRootIsScheduled"}),"  ：会进入到调度流程。 ",(0,r.jsx)(n.strong,{children:"flushSyncCallbackQueue"})," ：用于立即执行更新队列里面的任务。至于为什么，接下来会讲到，请细心阅读。"]}),"\n",(0,r.jsxs)(n.p,{children:["在介绍 ",(0,r.jsx)(n.code,{children:"ReactDOM.render"})," 的时候，初始化的更新会通过 unbatchedUpdates 包裹，那么",(0,r.jsx)(n.strong,{children:"初始化的更新会直接进入调和阶段同步更新，而不会放入到调度任务中"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"legacy"})," 模式下的可控任务和非可控任务。"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["可控任务：在事件系统章节和 state 章节讲到过，对于 React 事件系统中发生的任务，会被标记 ",(0,r.jsx)(n.code,{children:"EventContext"}),"，在 batchUpdate api 里面的更新任务，会被标记成 ",(0,r.jsx)(n.code,{children:"BatchedContext"}),"，那么这些任务是 React 可以检测到的，所以 ",(0,r.jsx)(n.code,{children:"executionContext !== NoContext"}),"，那么不会执行 ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["非可控任务：如果在",(0,r.jsx)(n.strong,{children:"延时器（timer）队列"}),"或者是",(0,r.jsx)(n.strong,{children:"微任务队列（microtask）"}),"，那么这种更新任务，React 是无法控制执行时机的，所以说这种任务就是非可控的任务。比如 ",(0,r.jsx)(n.code,{children:"setTimeout"})," 和 ",(0,r.jsx)(n.code,{children:"promise"})," 里面的更新任务，那么 ",(0,r.jsx)(n.code,{children:"executionContext === NoContext"})," ，接下来会执行一次 ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"})," 。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"那么用流程图描述一下过程："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"1.jpg"})}),"\n",(0,r.jsxs)(n.h2,{id:"三-进入调度更新",children:["三 进入调度更新",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-进入调度更新",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"1-控制进入调度",children:["1 控制进入调度",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-控制进入调度",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面非初始化类型的更新任务，那么最终会走到 ensureRootIsScheduled 流程中，所以来分析一下这个方法。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js -> ensureRootIsScheduled"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function ensureRootIsScheduled(root,currentTime){\n    /* 计算一下执行更新的优先级 */\n    var newCallbackPriority = returnNextLanesPriority();\n    /* 当前 root 上存在的更新优先级 */\n    const existingCallbackPriority = root.callbackPriority;\n    /* 如果两者相等，那么说明是在一次更新中，那么将退出 */\n    if(existingCallbackPriority === newCallbackPriority){\n        return \n    }\n    if (newCallbackPriority === SyncLanePriority) {\n        /* 在正常情况下，会直接进入到调度任务中。 */\n        newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }else{\n        /* 这里先忽略 */\n    }\n    /* 给当前 root 的更新优先级，绑定到最新的优先级  */\n    root.callbackPriority = newCallbackPriority;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"ensureRootIsScheduled 主要做的事情有："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["首先会计算最新的调度更新优先级 ",(0,r.jsx)(n.code,{children:"newCallbackPriority"}),"，接下来获取当前 root 上的 ",(0,r.jsx)(n.code,{children:"callbackPriority"})," 判断两者是否相等。如果两者相等，那么将直接退出不会进入到调度中。"]}),"\n",(0,r.jsxs)(n.li,{children:["如果不想等那么会真正的进入调度任务 ",(0,r.jsx)(n.code,{children:"scheduleSyncCallback"})," 中。注意的是放入调度中的函数就是",(0,r.jsx)(n.strong,{children:"调和流程"}),"的入口函数 ",(0,r.jsx)(n.code,{children:"performSyncWorkOnRoot"}),"。"]}),"\n",(0,r.jsx)(n.li,{children:"函数最后会将 newCallbackPriority 赋值给 callbackPriority。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"什么情况下会存在 existingCallbackPriority === newCallbackPriority，退出调度的情况？"})}),"\n",(0,r.jsxs)(n.p,{children:["我们注意到在一次更新中最后 callbackPriority 会被赋值成 newCallbackPriority 。那么如果在正常模式下（非异步）一次更新中触发了多次 ",(0,r.jsx)(n.code,{children:"setState"})," 或者 ",(0,r.jsx)(n.code,{children:"useState"})," ，那么第一个 setState 进入到 ensureRootIsScheduled 就会有 root.callbackPriority = newCallbackPriority，那么接下来如果还有 setState | useState，那么就会退出，将不进入调度任务中，",(0,r.jsx)(n.strong,{children:"原来这才是批量更新的原理，多次触发更新只有第一次会进入到调度中。"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"对于整个批量更新和批量更新打破原理，在第四部分会讲到。"})}),"\n",(0,r.jsxs)(n.h3,{id:"2-进入调度任务",children:["2 进入调度任务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-进入调度任务",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"那么当进入到 scheduleSyncCallback 中会发生什么呢？顺着线索往下看："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberSyncTaskQueue.js -> scheduleSyncCallback"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function scheduleSyncCallback(callback) {\n    if (syncQueue === null) {\n        /* 如果队列为空 */\n        syncQueue = [callback];\n        /* 放入调度任务 */\n        immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);\n    }else{\n        /* 如果任务队列不为空，那么将任务放入队列中。 */\n        syncQueue.push(callback);\n    }\n} \n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"flushSyncCallbackQueueImpl"})," 会真正的执行 ",(0,r.jsx)(n.code,{children:"callback"})," ，本质上就是调和函数 ",(0,r.jsx)(n.code,{children:"performSyncWorkOnRoot"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Scheduler_scheduleCallback"})," 就是在调度章节讲的调度的执行方法，本质上就是通过 ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"MessageChannel"})})," 向浏览器请求下一空闲帧，在空闲帧中执行更新任务。"]}),"\n",(0,r.jsx)(n.p,{children:"scheduleSyncCallback 做的事情如下："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如果执行队列为空，那么把当前任务放入队列中。然后执行调度任务。"}),"\n",(0,r.jsx)(n.li,{children:"如果队列不为空，此时已经在调度中，那么不需要执行调度任务，只需要把当前更新放入队列中就可以，调度中心会一个个按照顺序执行更新任务。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"到现在，已经知道了调和更新任务如何进入调度的。也知道了在初始化和改变 state 带来的更新原理。"}),"\n",(0,r.jsxs)(n.p,{children:["接下来有一个问题就是，",(0,r.jsx)(n.strong,{children:"比如在浏览器空闲状态下发生一次 state 更新，那么最后一定会进入调度，等到下一次空闲帧执行吗？"})]}),"\n",(0,r.jsxs)(n.p,{children:["答案是否定的，如果这样，那么就是一种性能的浪费，因为正常情况下，发生更新希望的是在一次事件循环中执行完更新到视图渲染，如果在下一次事件循环中执行，那么更新肯定会延时。但是 ",(0,r.jsx)(n.code,{children:"React"})," 是如何处理这个情况的呢？"]}),"\n",(0,r.jsxs)(n.h3,{id:"3-空闲期的同步任务",children:["3 空闲期的同步任务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-空闲期的同步任务",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在没有更新任务空闲期的条件下，为了让更新变成同步的，也就是本次更新不在调度中执行，那么 React 对于更新，会用 ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"})," 立即执行更新队列，发起更新任务，",(0,r.jsx)(n.strong,{children:"目的就是让任务不延时到下一帧"}),"。但是此时调度会正常执行，不过调度中的任务已经被清空，"]}),"\n",(0,r.jsx)(n.p,{children:"那么有的同学可以会产生疑问，既然不让任务进入调度，而选择同步执行任务，那么调度意义是什么呢?"}),"\n",(0,r.jsx)(n.p,{children:"调度的目的是处理存在多个更新任务的情况，比如发生了短时间内的连续的点击事件，每次点击事件都会更新 state ，那么对于这种更新并发的情况，第一个任务以同步任务执行，那么接下来的任务将放入调度，等到调度完成后，在下一空闲帧时候执行。"}),"\n",(0,r.jsxs)(n.h4,{id:"可控更新任务",children:["可控更新任务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#可控更新任务",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["那么知道了，发生一次同步任务之后，React 会让调度执行，但是会立即执行同步任务。原理就是通过 ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"})," 方法。对于可控的更新任务，比如事件系统里的同步的 setState 或者 useState，再比如 batchUpdate，如果此时处理空闲状态，在内部都会触发一个 ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"}),"来立即更新。我们看一下:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"事件系统中的"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js -> batchedEventUpdates"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function batchedEventUpdates(fn, a){\n     /* 批量更新流程，没有更新状态下，那么直接执行任务 */\n     var prevExecutionContext = executionContext;\n     executionContext |= EventContext;\n    try {\n        return fn(a) /* 执行事件本身，React 事件在这里执行，useState 和 setState 也会在这里执行 */\n    } finally {\n     /* 重置状态 */ \n    executionContext = prevExecutionContext;\n    if (executionContext === NoContext) { \n      /* 批量更新流程，没有更新状态下，那么直接执行任务 */\n      flushSyncCallbackQueue();\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["ReactDOM暴露的api ",(0,r.jsx)(n.code,{children:"batchedUpdates"})]})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js -> batchedUpdates"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function batchedUpdates(fn, a) {\n    /* 和上述流程一样 */\n    if (executionContext === NoContext) {\n      flushSyncCallbackQueue();\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如上可以看到，如果浏览器没有调度更新任务，那么如果发生一次可控更新任务，最后会默认执行一次 ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"})," 来让任务同步执行。"]}),"\n",(0,r.jsxs)(n.h4,{id:"非可控更新任务",children:["非可控更新任务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#非可控更新任务",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如果是非可控的更新任务，比如在 ",(0,r.jsx)(n.code,{children:"setTimeout"})," 或者 ",(0,r.jsx)(n.code,{children:"Promise"})," 里面的更新，那么在 scheduleUpdateOnFiber 中已经讲过。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"if (executionContext === NoContext) {\n    /* 执行 flushSyncCallbackQueue ，立即执行更新 */\n    flushSyncCallbackQueue();\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["综上这也就说明了，为什么在异步内部的 ",(0,r.jsx)(n.code,{children:"setState"})," | ",(0,r.jsx)(n.code,{children:"useState"})," 会打破批量更新的原则，本质上是因为，执行一次 ",(0,r.jsx)(n.code,{children:"setState"})," | ",(0,r.jsx)(n.code,{children:"useState"})," 就会触发一次 ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"})," 立即触发更新，所以就会进入到调和阶段，去真正的更新 fiber 树。"]}),"\n",(0,r.jsxs)(n.h2,{id:"四-同步异步模式下的更新流程实践",children:["四 同步异步模式下的更新流程实践",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-同步异步模式下的更新流程实践",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"为了强化本章节的学习，接下来我们来一起研究一下 legacy 模式下的更新流程。"}),"\n",(0,r.jsxs)(n.h3,{id:"初始化情况",children:["初始化情况",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化情况",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先看一下初始化流程。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"2.jpg"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"ReactDOM.render -> unbatchContext 开关打开 -> updateContainer。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"updateContainer：scheduleUpdateOnFiber -> performSyncWorkOnRoot -> renderRoot -> commitRoot -> 浏览器绘制。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"unbatchContext 开关关闭。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"同步情况",children:["同步情况",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#同步情况",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来一起看一下在同步（可控任务）和异步（非可控任务）下更新流程。"}),"\n",(0,r.jsx)(n.p,{children:"首先看一下同步的情况"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function Test(){\n    const [ number , setNumber ] = React.useState(0)\n    const handleClick = ()=>{ /* 同步条件下 */\n        setNumber(1)\n        setNumber(2)\n    }\n    return <div>\n        {number}\n        <button onClick={handleClick} >点击</button>\n    </div>\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如上当点击按钮的时候，会触发两次 ",(0,r.jsx)(n.code,{children:"setNumber"})," ，那么这两次 ",(0,r.jsx)(n.code,{children:"setNumber"})," 都做了些什么呢？"]}),"\n",(0,r.jsx)(n.p,{children:"两次更新流程图如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"3.jpg"})}),"\n",(0,r.jsx)(n.p,{children:"整个流程过程："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"事件上下文"}),"：开启事件开关 -> 进入第一次 ",(0,r.jsx)(n.code,{children:"setNumber"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["第一次 ",(0,r.jsx)(n.code,{children:"setNumber"})," 上下文"]}),"： ",(0,r.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," -> ",(0,r.jsx)(n.code,{children:"ensureRootIsScheduled"})," -> ",(0,r.jsx)(n.code,{children:"scheduleSyncCallback"})," (放入回调函数 ",(0,r.jsx)(n.code,{children:"performSyncWorkOnRoot"})," )。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["第二次 ",(0,r.jsx)(n.code,{children:"setNumber"})," 上下文"]}),"： ",(0,r.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," -> ",(0,r.jsx)(n.code,{children:"ensureRootIsScheduled"})," -> 退出。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"事件上下文"}),"：关闭事件开关 -> ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"flushSyncCallbackQueue"})," -> 执行回调函数 ",(0,r.jsx)(n.code,{children:"performSyncWorkOnRoot"})," -> 进入调和阶段 -> ",(0,r.jsx)(n.code,{children:"renderRoot"})," -> ",(0,r.jsx)(n.code,{children:"commitRoot"})," -> 浏览器绘制。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"异步情况",children:["异步情况",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步情况",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const handleClick = ()=>{\n    setTimeout(() => { /* 异步条件下 */\n        setNumber(1)\n        setNumber(2)\n    },0)    \n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"两次更新流程图如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"4.jpg"})}),"\n",(0,r.jsx)(n.p,{children:"整个流程过程："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"事件上下文"}),"：开启事件开关 -> 关闭事件开关 -> flushSyncCallbackQueue (此时更新队列为空)。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"setTimeout上下文"}),"：执行第一次 ",(0,r.jsx)(n.code,{children:"setNumber"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["第一次 ",(0,r.jsx)(n.code,{children:"setNumber"})," 上下文"]}),"：",(0,r.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," -> ",(0,r.jsx)(n.code,{children:"ensureRootIsScheduled"})," -> ",(0,r.jsx)(n.code,{children:"scheduleSyncCallback"})," (放入回调函数 ",(0,r.jsx)(n.code,{children:"performSyncWorkOnRoot"})," ) -> ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"})," -> 执行回调函数 ",(0,r.jsx)(n.code,{children:"performSyncWorkOnRoot"})," -> 进入调和阶段 -> ",(0,r.jsx)(n.code,{children:"renderRoot"})," -> ",(0,r.jsx)(n.code,{children:"commitRoot"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"回到 setTimeout 上下文"}),"：执行第二次 ",(0,r.jsx)(n.code,{children:"setNumber"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["第二次 ",(0,r.jsx)(n.code,{children:"setNumber"})," 上下文"]}),"：",(0,r.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," -> ",(0,r.jsx)(n.code,{children:"ensureRootIsScheduled"})," -> ",(0,r.jsx)(n.code,{children:"scheduleSyncCallback"})," (放入回调函数 ",(0,r.jsx)(n.code,{children:"performSyncWorkOnRoot"})," ) -> ",(0,r.jsx)(n.code,{children:"flushSyncCallbackQueue"})," -> 执行回调函数 ",(0,r.jsx)(n.code,{children:"performSyncWorkOnRoot"})," -> 进入调和阶段 -> ",(0,r.jsx)(n.code,{children:"renderRoot"})," -> ",(0,r.jsx)(n.code,{children:"commitRoot"}),"。"]}),"\n",(0,r.jsx)(n.li,{children:"js执行完毕，浏览器绘制。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"所以这种情况下 render 了两遍。到此为止 legacy 模式下更新流程真相大白。"}),"\n",(0,r.jsxs)(n.h2,{id:"五-总结",children:["五 总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"通过本章节的学习，收获的知识点如下："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["初始化和 ",(0,r.jsx)(n.code,{children:"state"})," 改变的更新流程。"]}),"\n",(0,r.jsx)(n.li,{children:"可控任务和非可控任务的更新原理。"}),"\n",(0,r.jsx)(n.li,{children:"如何进入调度任务。"}),"\n",(0,r.jsx)(n.li,{children:"强化 state | 调度 ｜ 调和 章节的学习。"}),"\n"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let o=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F35.%E5%8E%9F%E7%90%86%E7%AF%87-%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B%EF%BC%9A%E8%BF%9B%E5%85%A5%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 更新之溯源",id:"二-更新之溯源",depth:2},{text:"1 从 ReactDOM.render 看初始化流程",id:"1-从-reactdomrender-看初始化流程",depth:3},{text:"2 从 useState | setState 看更新流程",id:"2-从-usestate--setstate-看更新流程",depth:3},{text:"3 更新入口 scheduleUpdateOnFiber",id:"3-更新入口-scheduleupdateonfiber",depth:3},{text:"三 进入调度更新",id:"三-进入调度更新",depth:2},{text:"1 控制进入调度",id:"1-控制进入调度",depth:3},{text:"2 进入调度任务",id:"2-进入调度任务",depth:3},{text:"3 空闲期的同步任务",id:"3-空闲期的同步任务",depth:3},{text:"可控更新任务",id:"可控更新任务",depth:4},{text:"非可控更新任务",id:"非可控更新任务",depth:4},{text:"四 同步异步模式下的更新流程实践",id:"四-同步异步模式下的更新流程实践",depth:2},{text:"初始化情况",id:"初始化情况",depth:3},{text:"同步情况",id:"同步情况",depth:3},{text:"异步情况",id:"异步情况",depth:3},{text:"五 总结",id:"五-总结",depth:2}],title:"35.原理篇-更新流程：进入调度任务",headingTitle:"35.原理篇-更新流程：进入调度任务",frontmatter:{}}}}]);