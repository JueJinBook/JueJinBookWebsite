"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["28104"],{107257:function(e,n,r){r.r(n),r.d(n,{default:()=>p});var s=r(552676),c=r(740453);let d=r.p+"static/image/8ecc8d3655005af0929c00698607f386.2fc38603.webp",i=r.p+"static/image/1e198080baf2d0c79e367ebcb8c9ab45.1c5b2b15.webp",l=r.p+"static/image/12c646be90399c75b794ced235a5fc5c.6a0b5929.webp",o=r.p+"static/image/527308559c95b3c551dbba7159b4556e.3686ffb2.webp",t=r.p+"static/image/cedc52ea97bfd8a78cd931ca3a506220.1577e620.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ol:"ol",li:"li",code:"code",h2:"h2",pre:"pre",ul:"ul",blockquote:"blockquote",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",img:"img"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"11深入理解-webpack-核心配置结构",children:["11.深入理解 Webpack 核心配置结构",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11深入理解-webpack-核心配置结构",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 是一种 ",(0,s.jsx)(n.strong,{children:"「配置」"})," 驱动的构建工具，所以站在应用的角度，必须深入学习 Webpack 的各项配置规则，才能灵活应对各种构建需求。本文将作为小册应用系列的一个总结，汇总与应用配置相关的各项知识点，包括："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"剖析配置结构规则，解释对象、数组、函数三种形态的写法，以及各自应对的场景；"}),"\n",(0,s.jsx)(n.li,{children:"详细讲解环境治理的意义，以及如何借助多文件实现环境治理；"}),"\n",(0,s.jsxs)(n.li,{children:["完整、清晰地介绍若干核心配置项：",(0,s.jsx)(n.code,{children:"entry/output/target/mode"}),"，帮助你更深入理解配置规则。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"配置结构详解",children:["配置结构详解",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置结构详解",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在前面章节中，我们已经编写了许多 Webpack 配置示例，其大多数都以单文件导出单个配置对象方式实现，类似："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  entry: './src/index.js',\n  // 其它配置...\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"实际上，Webpack 还支持以数组、函数方式配置运行参数，以适配不同场景应用需求，它们之间大致上区别："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"单个配置对象"}),"：比较常用的一种方式，逻辑简单，适合大多数业务项目；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"配置对象数组"}),"：每个数组项都是一个完整的配置对象，每个对象都会触发一次单独的构建，通常用于需要为同一份代码构建多种产物的场景，如 Library；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"函数"}),"：Webpack 启动时会执行该函数获取配置，我们可以在函数中根据环境参数(如 ",(0,s.jsx)(n.code,{children:"NODE_ENV"}),")动态调整配置对象。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"下面我们着重介绍数组、函数两种方式。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"使用配置数组："})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"导出数组的方式很简单，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nmodule.exports = [{\n  entry: './src/index.js',\n  // 其它配置...\n}, {\n  entry: './src/index.js',\n  // 其它配置...\n}];\n"})}),"\n",(0,s.jsxs)(n.p,{children:["使用数组方式时，Webpack 会在启动后创建多个 ",(0,s.jsx)(n.code,{children:"Compilation"})," 实例，并行执行构建工作，但需要注意，",(0,s.jsx)(n.code,{children:"Compilation"})," 实例间基本上不作通讯，这意味着这种并行构建对运行性能并没有任何正向收益，例如某个 Module 在 ",(0,s.jsx)(n.code,{children:"Compilation"})," 实例 A 中完成解析、构建后，在其它 ",(0,s.jsx)(n.code,{children:"Compilation"})," 中依然需要完整经历构建流程，无法直接复用结果。"]}),"\n",(0,s.jsx)(n.p,{children:"数组方式主要用于应对“同一份代码打包出多种产物”的场景，例如在构建 Library 时，我们通常需要同时构建出 ESM/CMD/UMD 等模块方案的产物，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nmodule.exports = [\n  {\n    output: {\n      filename: './dist-amd.js',\n      libraryTarget: 'amd',\n    },\n    name: 'amd',\n    entry: './app.js',\n    mode: 'production',\n  },\n  {\n    output: {\n      filename: './dist-commonjs.js',\n      libraryTarget: 'commonjs',\n    },\n    name: 'commonjs',\n    entry: './app.js',\n    mode: 'production',\n  },\n];\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：使用配置数组时，还可以通过 ",(0,s.jsx)(n.code,{children:"--config-name"})," 参数指定需要构建的配置对象，例如上例配置中若执行 ",(0,s.jsx)(n.code,{children:"npx webpack --config-name='amd'"}),"，则仅使用数组中 ",(0,s.jsx)(n.code,{children:"name='amd'"})," 的项做构建。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["此时适合使用配置数组方式解决；若是“多份代码打包多份产物”的场景，则建议使用 ",(0,s.jsx)(n.code,{children:"entry"})," 配置多个应用入口。"]}),"\n",(0,s.jsxs)(n.p,{children:["使用数组方式时，我们还可以借助 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/webpack-merge",target:"_blank",rel:"noopener noreferrer",children:"webpack-merge"})," 工具简化配置逻辑，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const { merge } = require("webpack-merge");\n\nconst baseConfig = {\n  output: {\n    path: "./dist"\n  },\n  name: "amd",\n  entry: "./app.js",\n  mode: "production",\n};\n\nmodule.exports = [\n  merge(baseConfig, {\n    output: {\n      filename: "[name]-amd.js",\n      libraryTarget: "amd",\n    },\n  }),\n  merge(baseConfig, {\n    output: {\n      filename: "./[name]-commonjs.js",\n      libraryTarget: "commonjs",\n    },\n  }),\n];\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：",(0,s.jsx)(n.code,{children:"webpack-merge"})," 是 Webpack 生态内专门用于合并配置对象的工具，后面我们还会展开讲解使用方法。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["示例中将公共配置抽取为 ",(0,s.jsx)(n.code,{children:"baseConfig"})," 对象，之后配合 ",(0,s.jsx)(n.code,{children:"webpack-merge"})," 创建不同目标数组项，这种方式可有效减少重复的配置代码，非常推荐使用。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"使用配置函数："})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["配置函数方式要求在配置文件中导出一个函数，并在函数中返回 Webpack 配置对象，或配置数组，或 ",(0,s.jsx)(n.code,{children:"Promise"})," 对象，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = function(env, argv) {\n  // ...\n  return {\n    entry: './src/index.js',\n    // 其它配置...\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"运行时，Webpack 会传入两个环境参数对象："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"env"}),"：通过 ",(0,s.jsx)(n.code,{children:"--env"})," 传递的命令行参数，适用于自定义参数，例如："]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"​"}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"命令："}),"\n",(0,s.jsxs)(n.th,{children:[(0,s.jsx)(n.code,{children:"env"})," 参数值："]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"npx webpack --env prod"}),"\n",(0,s.jsx)(n.td,{children:"{ prod: true }"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"npx webpack --env prod --env min"}),"\n",(0,s.jsx)(n.td,{children:"{ prod: true, min: true }"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"npx webpack --env platform=app --env production"}),"\n",(0,s.jsx)(n.td,{children:'{ platform: "app", production: true }'}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"npx webpack --env foo=bar=app"}),"\n",(0,s.jsx)(n.td,{children:'{ foo: "bar=app"}'}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:'npx webpack --env app.platform="staging" --env app.name="test"'}),"\n",(0,s.jsx)(n.td,{children:'{ app: { platform: "staging", name: "test" }'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"argv"}),"：命令行 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/cli/#flags",target:"_blank",rel:"noopener noreferrer",children:"Flags"})," 参数，支持 ",(0,s.jsx)(n.code,{children:"entry"}),"/",(0,s.jsx)(n.code,{children:"output-path"}),"/",(0,s.jsx)(n.code,{children:"mode"}),"/",(0,s.jsx)(n.code,{children:"merge"})," 等。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["“",(0,s.jsx)(n.strong,{children:"配置函数"}),"”这种方式的意义在于，允许用户根据命令行参数动态创建配置对象，可用于实现简单的多环境治理策略，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// npx webpack --env app.type=miniapp --mode=production\nmodule.exports = function (env, argv) {\n  return {\n    mode: argv.mode ? "production" : "development",\n    devtool: argv.mode ? "source-map" : "eval",\n    output: {\n      path: path.join(__dirname, `./dist/${env.app.type}`,\n      filename: \'[name].js\'\n    },\n    plugins: [\n      new TerserPlugin({\n        terserOptions: {\n          compress: argv.mode === "production", \n        },\n      }),\n    ],\n  };\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["示例支持通过命令行传入 ",(0,s.jsx)(n.code,{children:"env.app.type"})," 与 ",(0,s.jsx)(n.code,{children:"argv.mode"})," 值，决定最终配置结构，我们可以为不同场景传入不同命令行参数，从而实现环境隔离效果。"]}),"\n",(0,s.jsxs)(n.p,{children:["不过这种方式并不常用，一是因为需要在配置函数内做许多逻辑判断，复杂场景下可能可读性会很低，维护成本高；二是强依赖于命令行参数，可能最终需要写出一串很长的运行命令，应用体验较差。目前社区比较流行通过不同配置文件区分不同环境的运行配置，配合 ",(0,s.jsx)(n.code,{children:"--config"})," 参数实现环境治理，下面我们会展开讲解这种方案。"]}),"\n",(0,s.jsx)(n.p,{children:"最后简单总结下，Webpack 支持三种配置方式：对象、数组、函数，其中对象方式最简单，且能够应对大多数业务开发场景，所以使用率最高；数组方式主要用于构建 Library 场景；函数方式灵活性较高，可用于实现一些简单的环境治理策略。同学们可根据实际场景，择优选用。"}),"\n",(0,s.jsxs)(n.h2,{id:"环境治理策略",children:["环境治理策略",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#环境治理策略",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在现代前端工程化实践中，通常需要将同一个应用项目部署在不同环境(如生产环境、开发环境、测试环境)中，以满足项目参与各方的不同需求。这就要求我们能根据部署环境需求，对同一份代码执行各有侧重的打包策略，例如："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["开发环境需要使用 ",(0,s.jsx)(n.code,{children:"webpack-dev-server"})," 实现 Hot Module Replacement；"]}),"\n",(0,s.jsx)(n.li,{children:"测试环境需要带上完整的 Soucemap 内容，以帮助更好地定位问题；"}),"\n",(0,s.jsx)(n.li,{children:"生产环境需要尽可能打包出更快、更小、更好的应用代码，确保用户体验。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Webpack 中有许多实现环境治理的方案，比如上面介绍过的，使用“配置函数”配合命令行参数动态计算配置对象。除此之外，业界比较流行将不同环境配置分别维护在单独的配置文件中，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:".\n└── config\n  ├── webpack.common.js\n  ├── webpack.development.js\n  ├── webpack.testing.js\n  └── webpack.production.js\n"})}),"\n",(0,s.jsxs)(n.p,{children:["之后配合 ",(0,s.jsx)(n.code,{children:"--config"})," 选项指定配置目标，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx webpack --config webpack.development.js\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这种模式下通常会将部分通用配置放在基础文件中，如上例的 ",(0,s.jsx)(n.code,{children:"webpack.common.js"}),"，之后在其它文件中引入该模块并使用 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.org/package/webpack-merge",target:"_blank",rel:"noopener noreferrer",children:"webpack-merge"})," 合并配置对象。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"webpack-merge"})," 是一个专为 Webpack 设计的数据合并(",(0,s.jsx)(n.code,{children:"merge"}),")的工具，功能逻辑与 Lodash 的 ",(0,s.jsx)(n.a,{href:"https://devdocs.io/lodash~4/index#merge",target:"_blank",rel:"noopener noreferrer",children:"merge"})," 函数、 ",(0,s.jsx)(n.a,{href:"https://devdocs.io/javascript/global_objects/object/assign",target:"_blank",rel:"noopener noreferrer",children:"Object.assign"})," 等相似，但支持更多特性，如："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"支持数组属性合并，例如："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"merge({ arr: [1] }, { arr: [2] }) === { arr: [1, 2] }\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"支持函数属性合并，例如："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const res = merge(\n  { func: () => console.log(1) },\n  { func: () => console.log(2) }\n);\nres.func();\n// => 1,2 \n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["支持设定对象合并策略，支持 ",(0,s.jsx)(n.code,{children:"match/append/prepend/replace/merge"})," 规则；"]}),"\n",(0,s.jsx)(n.li,{children:"支持传入自定义对象合并函数；"}),"\n",(0,s.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这些特性能更好地支持 Webpack 这种高度复杂的数据合并场景，例如对于 ",(0,s.jsx)(n.code,{children:"module.rules"})," 数组，若只是使用 ",(0,s.jsx)(n.code,{children:"Object.assign"})," 做合并，则只会导致后面对象属性替换了前面对象属性；而使用 ",(0,s.jsx)(n.code,{children:"webpack-merge"})," 能够实现两个数组项合并，更符合预期。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来，我们用一个 ",(0,s.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/blob/main/env-manage/webpack.common.js",target:"_blank",rel:"noopener noreferrer",children:"示例"})," 简单串一下与 ",(0,s.jsx)(n.code,{children:"webpack-merge"})," 实现环境管理的过程。首先我们需要将通用配置放在公共文件中，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// webpack.common.js\nconst path = require("path");\nconst HTMLWebpackPlugin = require("html-webpack-plugin");\n\nmodule.exports = {\n  entry: { main: "./src/index.js" },\n  output: {\n    filename: "[name].js",\n    path: path.resolve(__dirname, "dist"),\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ["babel-loader"],\n      },\n    ],\n  },\n  plugins: [new HTMLWebpackPlugin()],\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["其次，需要安装 ",(0,s.jsx)(n.code,{children:"webpack-merge"})," 做配置合并操作："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"yarn add -D webpack-merge\n"})}),"\n",(0,s.jsxs)(n.p,{children:["之后，创建对应环境配置文件，如 ",(0,s.jsx)(n.code,{children:"webpack.development.js"}),"，并输入开发环境专用配置代码，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// webpack.development.js\nconst { merge } = require("webpack-merge");\nconst baseConfig = require("./webpack.common");\n\n// 使用 webpack-merge 合并配置对象\nmodule.exports = merge(baseConfig, {\n  mode: "development",\n  devtool: "source-map",\n  devServer: { hot: true },\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["最后，执行构建命令并通过 ",(0,s.jsx)(n.code,{children:"--config"})," 参数传入配置文件路径，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx webpack --config=webpack.development.js\n"})}),"\n",(0,s.jsx)(n.p,{children:"至此，样例大致搭建完毕，接下来我们还可以继续为更多构建环境配备特定的配置文件，流程同上，此处不再赘述。"}),"\n",(0,s.jsxs)(n.h2,{id:"核心配置项汇总",children:["核心配置项汇总",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#核心配置项汇总",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在前面章节中，我们已经基于各种应用场景综合讲解了 Webpack 方方面面的应用方法，其中涉及多达上百种配置项，不太可能一一详细讲解，但大致上可以划分下图中展示的几种分类："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"包括：流程配置、性能优化类配置、日志类配置、开发效率类配置等，这里面较常用，需要着重学习的配置有："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"entry"}),"：声明项目入口文件，Webpack 会从这个文件开始递归找出所有文件依赖；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"output"}),"：声明构建结果的存放位置；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target"}),"：用于配置编译产物的目标运行环境，支持 ",(0,s.jsx)(n.code,{children:"web"}),"、",(0,s.jsx)(n.code,{children:"node"}),"、",(0,s.jsx)(n.code,{children:"electron"})," 等值，不同值最终产物会有所差异；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mode"}),"：编译模式短语，支持 ",(0,s.jsx)(n.code,{children:"development"}),"、",(0,s.jsx)(n.code,{children:"production"})," 等值，Webpack 会根据该属性推断默认配置；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"optimization"}),"：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"module"}),"：用于声明模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"plugin"}),"：Webpack 插件列表。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["其中，",(0,s.jsx)(n.code,{children:"optimization/module/plugin"})," 属性将在后续章节做专门介绍，此处先不展开。接下来我们将集中讲解 ",(0,s.jsx)(n.code,{children:"entry/output/target/mode"})," 属性，帮你更全面、立体、透彻地理解 Webpack 配置项逻辑。"]}),"\n",(0,s.jsxs)(n.h2,{id:"entry-配置详解",children:[(0,s.jsx)(n.code,{children:"entry"})," 配置详解",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#entry-配置详解",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 的基本运行逻辑是从 ",(0,s.jsx)(n.strong,{children:"「入口文件」"})," 开始，递归加载、构建所有项目资源，所以几乎所有项目都必须使用 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/entry-context/",target:"_blank",rel:"noopener noreferrer",children:"entry"})," 配置项明确声明项目入口。",(0,s.jsx)(n.code,{children:"entry"})," 配置规则比较复杂，支持如下形态："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"字符串：指定入口文件路径；"}),"\n",(0,s.jsx)(n.li,{children:"对象：对象形态功能比较完备，除了可以指定入口文件列表外，还可以指定入口依赖、Runtime 打包方式等；"}),"\n",(0,s.jsx)(n.li,{children:"函数：动态生成 Entry 配置信息，函数中可返回字符串、对象或数组；"}),"\n",(0,s.jsx)(n.li,{children:"数组：指明多个入口文件，数组项可以为上述介绍的文件路径字符串、对象、函数形式，Webpack 会将数组指明的入口全部打包成一个 Bundle。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"例如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  //...\n  entry: {\n    // 字符串形态\n    home: './home.js',\n    // 数组形态\n    shared: ['react', 'react-dom', 'redux', 'react-redux'],\n    // 对象形态\n    personal: {\n      import: './personal.js',\n      filename: 'pages/personal.js',\n      dependOn: 'shared',\n      chunkLoading: 'jsonp',\n      asyncChunks: true\n    },\n    // 函数形态\n    admin: function() {\n      return './admin.js';\n    }\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这其中，",(0,s.jsx)(n.strong,{children:"「对象」"})," 形态的配置逻辑最为复杂，支持如下配置属性："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"import"}),"：声明入口文件，支持路径字符串或路径数组(多入口)；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"dependOn"}),"：声明该入口的前置依赖 Bundle；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"runtime"}),"：设置该入口的 Runtime Chunk，若该属性不为空，Webpack 会将该入口的运行时代码抽离成单独的 Bundle；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"filename"}),"：效果与 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputfilename",target:"_blank",rel:"noopener noreferrer",children:"output.filename"})," 类同，用于声明该模块构建产物路径；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"library"}),"：声明该入口的 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputlibrary",target:"_blank",rel:"noopener noreferrer",children:"output.library"})," 配置，一般在构建 NPM Library 时使用；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"publicPath"}),"：效果与 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputpublicpath",target:"_blank",rel:"noopener noreferrer",children:"output.publicPath"})," 相同，用于声明该入口文件的发布 URL；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"chunkLoading"}),"：效果与 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputchunkloading",target:"_blank",rel:"noopener noreferrer",children:"output.chunkLoading"})," 相同，用于声明异步模块加载的技术方案，支持 ",(0,s.jsx)(n.code,{children:"false/jsonp/require/import"})," 等值；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"asyncChunks"}),"：效果与 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputasyncchunks",target:"_blank",rel:"noopener noreferrer",children:"output.asyncChunks"})," 相同，用于声明是否支持异步模块加载，默认值为 ",(0,s.jsx)(n.code,{children:"true"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["而这些属性中，",(0,s.jsx)(n.code,{children:"dependOn"})," 与 ",(0,s.jsx)(n.code,{children:"runtime"})," 最为晦涩难懂，有必要构造实例，展开讲解。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"entry.dependOn"})," 声明入口依赖："]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dependOn"})," 属性用于声明前置 Bundle 依赖，从效果上看能够减少重复代码，优化构建产物质量。例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  // ...\n  entry: {\n    main: "./src/index.js",\n    foo: { import: "./src/foo.js", dependOn: "main" },\n  },\n};\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：示例代码已上传到 ",(0,s.jsx)(n.a,{href:"https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/entry-obj/webpack.config.js",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["示例中，",(0,s.jsx)(n.code,{children:"foo"})," 入口的 ",(0,s.jsx)(n.code,{children:"dependOn"})," 属性指向 ",(0,s.jsx)(n.code,{children:"main"})," 入口，此时 Webpack 认为：客户端在加载 ",(0,s.jsx)(n.code,{children:"foo"})," 产物之前必然会加载 ",(0,s.jsx)(n.code,{children:"main"}),"，因此可以将重复的模块代码、运行时代码等都放到 ",(0,s.jsx)(n.code,{children:"main"})," 产物，减少不必要的重复，最终打包结果："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["左边为 ",(0,s.jsx)(n.code,{children:"main"})," 产物，包含所有模块、运行时代码，与普通 Bundle 无异；右边为 ",(0,s.jsx)(n.code,{children:"foo"})," 产物，代码结构非常清爽。作为对比，若不指定 ",(0,s.jsx)(n.code,{children:"dependOn"})," 属性，则构建结果："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"可以看出两边内容并无差异。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dependOn"})," 适用于哪些有明确入口依赖的场景，例如我们构建了一个主框架 Bundle，其中包含了项目基本框架(如 React)，之后还需要为每个页面单独构建 Bundle，这些页面代码也都依赖于主框架代码，此时可用 ",(0,s.jsx)(n.code,{children:"dependOn"})," 属性优化产物内容，减少代码重复。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"entry.runtime"})," 管理运行时代码："]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"为支持产物代码在各种环境中正常运行，Webpack 会在产物文件中注入一系列运行时代码，用以支撑起整个应用框架。运行时代码的多寡取决于我们用到多少特性，例如："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["需要导入导出文件时，将注入 ",(0,s.jsx)(n.code,{children:"__webpack_require__.r"})," 等；"]}),"\n",(0,s.jsxs)(n.li,{children:["使用异步加载时，将注入 ",(0,s.jsx)(n.code,{children:"__webpack_require__.l"})," 等；"]}),"\n",(0,s.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["不要小看运行时代码量，极端情况下甚至有可能超过业务代码总量！为此，必要时我们可以尝试使用 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/concepts/entry-points/#entrydescription-object",target:"_blank",rel:"noopener noreferrer",children:"runtime"})," 配置将运行时抽离为独立 Bundle，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const path = require("path");\n\nmodule.exports = {\n  mode: "development",\n  devtool: false,\n  entry: {\n    main: { import: "./src/index.js", runtime: "common-runtime" },\n    foo: { import: "./src/foo.js", runtime: "common-runtime" },\n  },\n  output: {\n    clean: true,\n    filename: "[name].js",\n    path: path.resolve(__dirname, "dist"),\n  },\n};\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：示例代码已上传到 ",(0,s.jsx)(n.a,{href:"https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/entry-runtime/webpack.config.js",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["示例中，",(0,s.jsx)(n.code,{children:"main"})," 与 ",(0,s.jsx)(n.code,{children:"foo"})," 入口均将 ",(0,s.jsx)(n.code,{children:"runtime"})," 声明为 ",(0,s.jsx)(n.code,{children:"common-runtime"}),"，此时 Webpack 会将这两个入口的运行时代码都抽取出来，放在 ",(0,s.jsx)(n.code,{children:"common-runtime"})," Bundle 中，效果："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"entry.runtime"})," 是一种常用的应用性能优化手段，建议大家多做尝试、使用。"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-output-声明输出方式",children:["使用 ",(0,s.jsx)(n.code,{children:"output"})," 声明输出方式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-output-声明输出方式",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 的 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/",target:"_blank",rel:"noopener noreferrer",children:"output"})," 配置项用于声明：如何输出构建结果，比如产物放在什么地方、文件名是什么、文件编码等。",(0,s.jsx)(n.code,{children:"output"})," 支持许多子配置项，包括："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputpath",target:"_blank",rel:"noopener noreferrer",children:"output.path"}),"：声明产物放在什么文件目录下；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputfilename",target:"_blank",rel:"noopener noreferrer",children:"output.filename"}),"：声明产物文件名规则，支持 ",(0,s.jsx)(n.code,{children:"[name]/[hash]"})," 等占位符；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputpublicpath",target:"_blank",rel:"noopener noreferrer",children:"output.publicPath"}),"：文件发布路径，在 Web 应用中使用率较高；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputclean",target:"_blank",rel:"noopener noreferrer",children:"output.clean"}),"：是否自动清除 ",(0,s.jsx)(n.code,{children:"path"})," 目录下的内容，调试时特别好用；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputlibrary",target:"_blank",rel:"noopener noreferrer",children:"output.library"}),"：NPM Library 形态下的一些产物特性，例如：Library 名称、模块化(UMD/CMD 等)规范；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputchunkloading",target:"_blank",rel:"noopener noreferrer",children:"output.chunkLoading"}),"：声明加载异步模块的技术方案，支持 ",(0,s.jsx)(n.code,{children:"false/jsonp/require"})," 等方式。"]}),"\n",(0,s.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["对于 Web 应用场景，多数情况下我们只需要使用 ",(0,s.jsx)(n.code,{children:"path/filename/publicPath"})," 即可满足需求，其它属性使用率不高，篇幅关系，此处不再赘述。"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-target-设置构建目标",children:["使用 ",(0,s.jsx)(n.code,{children:"target"})," 设置构建目标",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-target-设置构建目标",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["虽然多数时候 Webpack 都被用于打包 Web 应用，但实际上 Webpack 还支持构建 Node、Electron、NW.js、WebWorker 等应用形态，这一特性主要通过 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/target/",target:"_blank",rel:"noopener noreferrer",children:"target"})," 配置控制，支持如下数值："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"node[[X].Y]"}),"：编译为 Node 应用，此时将使用 Node 的 ",(0,s.jsx)(n.code,{children:"require"})," 方法加载其它 Chunk，支持指定 Node 版本，如：",(0,s.jsx)(n.code,{children:"node12.13"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"async-node[[X].Y]"}),"：编译为 Node 应用，与 ",(0,s.jsx)(n.code,{children:"node"})," 相比主要差异在于：",(0,s.jsx)(n.code,{children:"async-node"})," 方式将以异步(Promise)方式加载异步模块(",(0,s.jsx)(n.code,{children:"node"})," 时直接使用 ",(0,s.jsx)(n.code,{children:"require"}),")。支持指定 Node 版本，如：",(0,s.jsx)(n.code,{children:"async-node12.13"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nwjs[[X].Y]"}),"：编译为 NW.js 应用；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"node-webkit[[X].Y]"}),"：同 ",(0,s.jsx)(n.code,{children:"nwjs"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"electron[[X].Y]-main"}),"：构建为 Electron ",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/tutorial/process-model#%E4%B8%BB%E8%BF%9B%E7%A8%8B",target:"_blank",rel:"noopener noreferrer",children:"主进程"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"electron[[X].Y]-renderer"}),"：构建为 Electron ",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/tutorial/process-model#%E6%B8%B2%E6%9F%93%E5%99%A8%E8%BF%9B%E7%A8%8B",target:"_blank",rel:"noopener noreferrer",children:"渲染进程"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"electron[[X].Y]-preload"}),"：构建为 Electron Preload ",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/tutorial/process-model#preload-%E8%84%9A%E6%9C%AC",target:"_blank",rel:"noopener noreferrer",children:"脚本"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"web"}),"：构建为 Web 应用；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"esX"}),"：构建为特定版本 ECMAScript 兼容的代码，支持 ",(0,s.jsx)(n.code,{children:"es5"}),"、",(0,s.jsx)(n.code,{children:"es2020"})," 等；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"browserslist"}),"：根据浏览器平台与版本，推断需要兼容的 ES 特性，数据来源于 ",(0,s.jsx)(n.a,{href:"https://github.com/browserslist/browserslist#queries",target:"_blank",rel:"noopener noreferrer",children:"Browserslist"})," 项目，用法如：",(0,s.jsx)(n.code,{children:"browserslist: 'last 2 major versions'"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"不同构建目标会根据平台特性打包出略有差异的结果(主要体现在运行时与 NPM Library)，例如对于下面这种使用了异步导入的代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// foo.js\nexport default "foo";\n\n// index.js \nimport("./foo").then(console.log);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["使用如下配置，同时构建 ",(0,s.jsx)(n.code,{children:"node"})," 与 ",(0,s.jsx)(n.code,{children:"web"})," 版本："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const path = require("path");\nconst { merge } = require("webpack-merge");\n\nconst baseConfig = {\n  mode: "development",\n  target: "web",\n  devtool: false,\n  entry: {\n    main: { import: "./src/index.js" },\n  },\n  output: {\n    clean: true,\n    path: path.resolve(__dirname, "dist"),\n  },\n};\n\nmodule.exports = [\n  merge(baseConfig, { target: "web", output: { filename: "web-[name].js" } }),\n  merge(baseConfig, { target: "node", output: { filename: "node-[name].js" } }),\n];\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：相关示例已上传到小册",(0,s.jsx)(n.a,{href:"https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/target-node-web/webpack.config.js",target:"_blank",rel:"noopener noreferrer",children:"仓库"}),"，强烈建议你拉下来，对比两种目标下构建产物的差异。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"之后，执行构建命令，结果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到左边 ",(0,s.jsx)(n.code,{children:"web"})," 版本中需要注入使用 JSONP 异步加载 JS 文件的运行时代码；而右边 ",(0,s.jsx)(n.code,{children:"node"})," 版本则可以直接使用 Node 环境下的 ",(0,s.jsx)(n.code,{children:"require"})," 实现异步加载，因此不需要注入相关运行时。"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-mode-短语",children:["使用 ",(0,s.jsx)(n.code,{children:"mode"})," 短语",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-mode-短语",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack ",(0,s.jsx)(n.a,{href:"https://github.com/webpack/webpack/blob/main/lib/config/defaults.js",target:"_blank",rel:"noopener noreferrer",children:"内置"})," 了许多构建优化策略，我们可以通过 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/mode/",target:"_blank",rel:"noopener noreferrer",children:"mode"})," 配置项切换默认优化规则，支持如下值："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"production"}),"：默认值，生产模式，使用该值时 Webpack 会自动帮我们开启一系列优化措施：Three-Shaking、Terser 压缩代码、SplitChunk 提起公共代码，通常用于生产环境构建；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"development"}),"：开发模式，使用该值时 Webpack 会保留更语义化的 Module 与 Chunk 名称，更有助于调试，通常用于开发环境构建；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"none"}),"：关闭所有内置优化规则。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"mode"})," 规则比较简单，一般在开发模式使用 ",(0,s.jsx)(n.code,{children:"mode = 'development'"}),"，生产模式使用 ",(0,s.jsx)(n.code,{children:"mode = 'production'"})," 即可。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"至此，关于 Webpack 配置规则的重要知识点就补充完毕了，我们主要需要理解："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Webpack 配置文件支持导出对象、数组、函数三种形态，其中对象形式最为常用，足够应对多数业务项目场景；数组形式适用于需要为同一份代码同时构建多种产物的场景，如 NPM Library；函数形态适用于需要动态生成配置规则的场景；"}),"\n",(0,s.jsx)(n.li,{children:"为方便管理配置逻辑，我们通常需要引入一些环境治理策略，目前业界比较常用单独配置文件管理单个构建环境；"}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"entry"})," 配置项支持字符串、对象、函数、数组等方式，其中对象形式下的 ",(0,s.jsx)(n.code,{children:"dependOn/runtime"})," 规则比较复杂，建议深入学习；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"output"})," 用于声明构建产物的输出规则；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"target"})," 用于设置构建目标，不同目标会导致产物内容有轻微差异，支持 Node、Web、Electron、WebWorker 等场景；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mode"})," 构建模式，支持 ",(0,s.jsx)(n.code,{children:"development/production/none"})," 三种值。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"结合前面若干应用介绍的章节，相信已经帮你搭建起一套体系化的应用方法论，已经足以应付大多数业务场景。后续章节我们将转入更高阶的内容，包括：如何开发 Loader、Plugin；如何优化构建与应用性能；Webpack 构建原理等。"}),"\n",(0,s.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"假设在配置文件中需要通过远程接口动态获取配置片段，如何实现比较优雅？请试试。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let p=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F11.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Webpack%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84.md"]={toc:[{text:"配置结构详解",id:"配置结构详解",depth:2},{text:"环境治理策略",id:"环境治理策略",depth:2},{text:"核心配置项汇总",id:"核心配置项汇总",depth:2},{text:"`entry` 配置详解",id:"entry-配置详解",depth:2},{text:"使用 `output` 声明输出方式",id:"使用-output-声明输出方式",depth:2},{text:"使用 `target` 设置构建目标",id:"使用-target-设置构建目标",depth:2},{text:"使用 `mode` 短语",id:"使用-mode-短语",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"11.深入理解 Webpack 核心配置结构",headingTitle:"11.深入理解 Webpack 核心配置结构",frontmatter:{}}}}]);