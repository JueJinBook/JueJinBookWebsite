"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["60613"],{971416:function(e,n,r){r.r(n),r.d(n,{default:()=>i});var s=r(552676),t=r(740453);function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",h3:"h3",p:"p",strong:"strong",pre:"pre",code:"code",blockquote:"blockquote"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"71图像处理",children:["71.图像处理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71图像处理",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"114-图像处理",children:["11.4 图像处理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#114-图像处理",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1141-二维码qrcode",children:["11.4.1 二维码qrcode",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1141-二维码qrcode",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在移动互联网时代，二维码是一个非常重要的入口，有时候我们需要将一些文本、网址乃至文件、图片、名片等信息放置到一个小小的二维码里，让用户可以通过手机扫码的方式来获取传递的信息。云函数也可以借助于第三方模块，比如node-qrcode来创建二维码。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"技术文档："}),(0,s.jsx)(n.a,{href:"https://github.com/soldair/node-qrcode",target:"_blank",rel:"noopener noreferrer",children:"node-qrcode Github地址"})]}),"\n",(0,s.jsx)(n.p,{children:"使用开发者工具，创建一个云函数，如qrcode，然后在package.json增加qrcode最新版latest的依赖并用npm install安装："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'"dependencies": {\n  "qrcode": "latest"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"然后再在index.js输入如下代码，这里会先将创建的二维码写入到临时文件夹，然后再用fs.createReadStream方法读取图片，上传到云存储，还是以云存储为过渡，实现文件由服务端到小程序端的一个操作。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const cloud = require('wx-server-sdk')\nconst fs = require('fs')\nconst QRCode = require('qrcode')\ncloud.init({\n  env: cloud.DYNAMIC_CURRENT_ENV\n})\nexports.main = async (event, context) => {\n  //text为二维码里包含的内容，将创建的二维码图片先存储到/tmp临时文件夹里，命名为qrcode.png\n  const text=\"二维码里的有腾讯云云开发\"\n  await QRCode.toFile('/tmp/qrcode.png',text, {\n    color: {\n      dark: '#00F',  // 蓝点\n      light: '#0000' // 透明底\n    }\n  }, function (err) {\n    if (err) throw err\n    console.log('done')\n  })\n\n  //读取存储到/tmp临时文件夹里的二维码图片并上传到云存储里，返回fileID到小程序端\n  const fileStream = await fs.createReadStream('/tmp/qrcode.png')\n  return await cloud.uploadFile({\n    cloudPath: 'qrcode.jpg',\n    fileContent: fileStream,\n  }) \n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"执行云函数之后就能在云存储里看到我们生成的二维码图片qrcode.jpg了。如果想要深度定制更加符合你要求的二维码，可以去翻阅上面给的技术文档链接。"}),"\n",(0,s.jsxs)(n.h3,{id:"1142-sharp高速图像处理库",children:["11.4.2 Sharp高速图像处理库",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1142-sharp高速图像处理库",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"sharp是一个高速图像处理库，可以很方便的实现图片编辑操作，如裁剪、格式转换、旋转变换、滤镜添加、图片合成（如添加水印）、图片拼接等，支持JPEG, PNG, WebP, TIFF, GIF 和 SVG格式。在云函数端使用sharp来处理图片，而云存储则可以作为服务端和小程序端来传递图片的桥梁。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["由于图像处理是一件非常消耗性能的事情，不仅会对云函数的内存有要求，也可能会造成云函数的超时，以下只是研究使用云函数来处理图片的可行性，大家在实际开发中不要这么处理，建议使用",(0,s.jsx)(n.strong,{children:"云开发的拓展能力"}),"来对图像进行处理，功能更加强大（在后面的章节里，我们会介绍）。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"技术文档："}),(0,s.jsx)(n.a,{href:"https://sharp.pixelplumbing.com/en/stable/",target:"_blank",rel:"noopener noreferrer",children:"sharp官方技术文档"})]}),"\n",(0,s.jsxs)(n.p,{children:["使用开发者工具，创建一个云函数，如sharp，然后在package.json",(0,s.jsx)(n.strong,{children:"增加n"}),"ode-qrcode最新版latest的依赖，并右键云函数目录选择在终端中打开输入命令npm install安装依赖："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'"dependencies": {\n  "sharp": "latest"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"然后再在index.js输入如下代码，这里我们假定图片来源是云存储，我们需要先下载图片，然后用sharp对图片进行处理，处理完之后再把图片传回云存储。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const cloud = require('wx-server-sdk')\nconst fs = require('fs')\nconst path = require('path')\ncloud.init({\n  env: cloud.DYNAMIC_CURRENT_ENV,\n})\nconst sharp = require('sharp');\nexports.main = async (event, context) => {\n  //这里换成自己的fileID，也可以在小程序端上传文件之后，把fileID传进来event.fileID\n  const fileID = 'cloud://xly-xrlur.786c-xly-xrlur-1300446086/1572315793628-366.png'\n\n  //要用云函数处理图片，需要先下载图片，返回的图片类型为Buffer\n  const res = await cloud.downloadFile({\n    fileID: fileID,\n  })\n  const buffer = res.fileContent  \n\n  //sharp对图片进行处理之后，保存为output.png，也可以直接保存为Buffer\n  await sharp(buffer).rotate().resize(200).toFile('output.png')\n\n  // 云函数读取模块目录下的图片，并上传到云存储\n  const fileStream = await fs.createReadStream(path.join(__dirname, 'output.png'))\n  return await cloud.uploadFile({\n      cloudPath: 'sharpdemo.jpg',\n      fileContent: fileStream,\n  })  \n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"也可以让sharp不需要先toFile转成图片，而是直接转成Buffer，这样就可以直接作为参数传给fileContent上传到云存储，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const buffer2 = await sharp(buffer).rotate().resize(200).toBuffer();\n  return await cloud.uploadFile({\n    cloudPath: 'sharpdemo2.jpg',\n    fileContent: buffer2,\n  })\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["需要说明的是sharp有一定的前置条件，Node.js 的版本需要是v10.13.0+，以及云函数所在的服务器配置了libvips binaries，目前云开发的云函数不太支持，未来云开发会升级Node.js的版本。关于图像处理的库，我们也可以去Github awesome-Node.js 项目里去翻翻看有没有其他合适的解决方案，不过更加推荐的是使用",(0,s.jsx)(n.strong,{children:"云开发的图像处理拓展能力"}),"，更或者说",(0,s.jsx)(n.strong,{children:"强烈建议所有有图像处理需求的用户都应该安装图像处理拓展能力"}),"。"]}),"\n"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let i=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%2F71.%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86.md"]={toc:[{text:"11.4 图像处理",id:"114-图像处理",depth:2},{text:"11.4.1 二维码qrcode",id:"1141-二维码qrcode",depth:3},{text:"11.4.2 Sharp高速图像处理库",id:"1142-sharp高速图像处理库",depth:3}],title:"71.图像处理",headingTitle:"71.图像处理",frontmatter:{}}}}]);