"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["2596"],{413278:function(e,n,r){r.r(n),r.d(n,{default:()=>p});var a=r(552676),l=r(740453);let s=r.p+"static/image/54652d40437337f4b8d76505ad065ee8.d7574323.webp",d=r.p+"static/image/ce73a06524a0207a26601d2281320f89.b4b0ca60.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",strong:"strong",code:"code",ol:"ol",pre:"pre",img:"img"},(0,l.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"14webpack-都有哪些实现并行构建的方法",children:["14.Webpack 都有哪些实现并行构建的方法？",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14webpack-都有哪些实现并行构建的方法",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"受限于 Node.js 的单线程架构，原生 Webpack 对所有资源文件做的所有解析、转译、合并操作本质上都是在同一个线程内串行执行，CPU 利用率极低，因此，理所当然地，社区出现了一些以多进程方式运行 Webpack，或 Webpack 构建过程某部分工作的方案(从而提升单位时间利用率)，例如："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://github.com/amireh/happypack",target:"_blank",rel:"noopener noreferrer",children:"HappyPack"}),"：多进程方式运行资源加载(Loader)逻辑；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://webpack.js.org/loaders/thread-loader/",target:"_blank",rel:"noopener noreferrer",children:"Thread-loader"}),"：Webpack 官方出品，同样以多进程方式运行资源加载逻辑；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/parallel-webpack",target:"_blank",rel:"noopener noreferrer",children:"Parallel-Webpack"}),"：多进程方式运行多个 Webpack 构建实例；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/terser-webpack-plugin#terseroptions",target:"_blank",rel:"noopener noreferrer",children:"TerserWebpackPlugin"}),"：支持多进程方式执行代码压缩、uglify 功能。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"这些方案的核心设计都很类似：针对某种计算任务创建子进程，之后将运行所需参数通过 IPC 传递到子进程并启动计算操作，计算完毕后子进程再将结果通过 IPC 传递回主进程，寄宿在主进程的组件实例，再将结果提交给 Webpack。"}),"\n",(0,a.jsxs)(n.h2,{id:"使用-happypack",children:["使用 HappyPack",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-happypack",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/amireh/happypack",target:"_blank",rel:"noopener noreferrer",children:"HappyPack"})," 能够将耗时的",(0,a.jsx)(n.strong,{children:"文件加载"}),"（Loader）操作拆散到多个子进程中并发执行，子进程执行完毕后再将结果合并回传到 Webpack 进程，从而提升构建性能。不过，HappyPack 的用法稍微有点难以理解，需要同时："]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["使用 ",(0,a.jsx)(n.code,{children:"happypack/loader"})," 代替原本的 Loader 序列；"]}),"\n",(0,a.jsxs)(n.li,{children:["使用 ",(0,a.jsx)(n.code,{children:"HappyPack"})," 插件注入代理执行 Loader 序列的逻辑。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"基本用法："}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"安装依赖："}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-Bash",children:"yarn add -D happypack\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsxs)(n.li,{children:["将原有 ",(0,a.jsx)(n.code,{children:"loader"})," 配置替换为 ",(0,a.jsx)(n.code,{children:"happypack/loader"}),"，如："]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: \"happypack/loader\",\n        // 原始配置如：\n        // use: [\n        //  {\n        //      loader: 'babel-loader',\n        //      options: {\n        //          presets: ['@babel/preset-env']\n        //      }\n        //  },\n        //  'eslint-loader'\n        // ]\n      },\n    ],\n  },\n};\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsxs)(n.li,{children:["创建 ",(0,a.jsx)(n.code,{children:"happypack"})," 插件实例，并将原有 loader 配置迁移到插件中，完整配置："]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:'const HappyPack = require("happypack");\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: "happypack/loader",\n        // 原始配置如：\n        // use: [\n        //  {\n        //      loader: \'babel-loader\',\n        //      options: {\n        //          presets: [\'@babel/preset-env\']\n        //      }\n        //  },\n        //  \'eslint-loader\'\n        // ]\n      },\n    ],\n  },\n  plugins: [\n    new HappyPack({\n      // 将原本定义在 `module.rules.use` 中的 Loader 配置迁移到 HappyPack 实例中\n      loaders: [\n        {\n          loader: "babel-loader",\n          option: {\n            presets: ["@babel/preset-env"],\n          },\n        },\n        "eslint-loader",\n      ],\n    }),\n  ],\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["配置完毕后，再次启动 ",(0,a.jsx)(n.code,{children:"npx webpack"})," 命令，即可使用 HappyPack 的多进程能力提升构建性能。以 Three.js 为例，该项目包含 362 份 JS 文件，合计约 3w 行代码："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"开启 HappyPack 前，构建耗时大约为 11000ms 到 18000ms 之间，开启后耗时降低到 5800ms 到 8000ms 之间，提升约47%。"}),"\n",(0,a.jsxs)(n.p,{children:["上述示例仅演示了使用 HappyPack 加载单一资源类型的场景，实践中我们还可以创建多个 HappyPack 插件实例，来加载多种资源类型 —— 只需要用 ",(0,a.jsx)(n.code,{children:"id"})," 参数做好 Loader 与 Plugin 实例的关联即可，例如："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"const HappyPack = require('happypack');\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [{\n        test: /\\.js?$/,\n        // 使用 `id` 参数标识该 Loader 对应的 HappyPack 插件示例\n        use: 'happypack/loader?id=js'\n      },\n      {\n        test: /\\.less$/,\n        use: 'happypack/loader?id=styles'\n      },\n    ]\n  },\n  plugins: [\n    new HappyPack({\n      // 注意这里要明确提供 id 属性\n      id: 'js',\n      loaders: ['babel-loader', 'eslint-loader']\n    }),\n    new HappyPack({\n      id: 'styles',\n      loaders: ['style-loader', 'css-loader', 'less-loader']\n    })\n  ]\n};\n"})}),"\n",(0,a.jsx)(n.p,{children:"这里的重点是："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"js"}),"、",(0,a.jsx)(n.code,{children:"less"})," 资源都使用 ",(0,a.jsx)(n.code,{children:"happypack/loader"})," 作为唯一加载器，并分别赋予 ",(0,a.jsx)(n.code,{children:"id = 'js' | 'styles'"})," 参数；"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["创建了两个 ",(0,a.jsx)(n.code,{children:"HappyPack"})," 插件实例并分别配置 ",(0,a.jsx)(n.code,{children:"id"})," 属性，以及用于处理 js 与 css 的 ",(0,a.jsx)(n.code,{children:"loaders"})," 数组；"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["启动后，",(0,a.jsx)(n.code,{children:"happypack/loader"})," 与 ",(0,a.jsx)(n.code,{children:"HappyPack"})," 插件实例将通过 ",(0,a.jsx)(n.code,{children:"id"})," 值产生关联，以此实现对不同资源执行不同 Loader 序列。"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["上面这种多实例模式虽然能应对多种类型资源的加载需求，但默认情况下，HappyPack 插件实例 ",(0,a.jsx)(n.strong,{children:"自行管理"})," 自身所消费的进程，需要导致频繁创建、销毁进程实例 —— 这是非常昂贵的操作，反而会带来新的性能损耗。"]}),"\n",(0,a.jsxs)(n.p,{children:["为此，HappyPack 提供了一套简单易用的共享进程池接口，只需要创建 ",(0,a.jsx)(n.code,{children:"HappyPack.ThreadPool"})," 对象，并通过 ",(0,a.jsx)(n.code,{children:"size"})," 参数限定进程总量，之后将该例配置到各个 HappyPack 插件的 ",(0,a.jsx)(n.code,{children:"threadPool"})," 属性上即可，例如："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"const os = require('os')\nconst HappyPack = require('happypack');\nconst happyThreadPool = HappyPack.ThreadPool({\n  // 设置进程池大小\n  size: os.cpus().length - 1\n});\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new HappyPack({\n      id: 'js',\n      // 设置共享进程池\n      threadPool: happyThreadPool,\n      loaders: ['babel-loader', 'eslint-loader']\n    }),\n    new HappyPack({\n      id: 'styles',\n      threadPool: happyThreadPool,\n      loaders: ['style-loader', 'css-loader', 'less-loader']\n    })\n  ]\n};\n"})}),"\n",(0,a.jsxs)(n.p,{children:["使用 ",(0,a.jsx)(n.code,{children:"HappyPack.ThreadPool"})," 接口后，HappyPack 会预先创建好一组工作进程，所有插件实例的资源转译任务会通过内置的 ",(0,a.jsx)(n.code,{children:"HappyThread"})," 对象转发到空闲进程做处理，避免频繁创建、销毁进程。"]}),"\n",(0,a.jsx)(n.p,{children:"最后，我们再来看看 HappyPack 的执行流程："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"核心步骤："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"happlypack/loader"})," 接受到转译请求后，从 Webpack 配置中读取出相应 HappyPack 插件实例；"]}),"\n",(0,a.jsxs)(n.li,{children:["调用插件实例的 ",(0,a.jsx)(n.code,{children:"compile"})," 方法，创建 ",(0,a.jsx)(n.code,{children:"HappyThread"})," 实例（或从 ",(0,a.jsx)(n.code,{children:"HappyThreadPool"})," 取出空闲实例）；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"HappyThread"})," 内部调用 ",(0,a.jsx)(n.code,{children:"child_process.fork"})," 创建子进程，并执行",(0,a.jsx)(n.code,{children:"HappyWorkerChannel"})," 文件；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"HappyWorkerChannel"})," 创建 ",(0,a.jsx)(n.code,{children:"HappyWorker"})," ，开始执行 Loader 转译逻辑；"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["中间流程辗转了几层，最终由 ",(0,a.jsx)(n.code,{children:"HappyWorker"})," 类重新实现了一套与 Webpack Loader 相似的转译逻辑，代码复杂度较高，大家稍作了解即可。"]}),"\n",(0,a.jsx)(n.p,{children:"HappyPack 虽然确实能有效提升 Webpack 的打包构建速度，但它有一些明显的缺点："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"作者已经明确表示不会继续维护，扩展性与稳定性缺乏保障，随着 Webpack 本身的发展迭代，可以预见总有一天 HappyPack 无法完全兼容 Webpack；"}),"\n",(0,a.jsxs)(n.li,{children:["HappyPack 底层以自己的方式重新实现了加载器逻辑，源码与使用方法都不如 Thread-loader 清爽简单，而且会导致一些意想不到的兼容性问题，如 ",(0,a.jsx)(n.code,{children:"awesome-typescript-loader"}),"；"]}),"\n",(0,a.jsx)(n.li,{children:"HappyPack 主要作用于文件加载阶段，并不会影响后续的产物生成、合并、优化等功能，性能收益有限。"}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"使用-thread-loader",children:["使用 Thread-loader",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-thread-loader",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://webpack.js.org/loaders/thread-loader/",target:"_blank",rel:"noopener noreferrer",children:"Thread-loader"})," 与 HappyPack 功能类似，都是以多进程方式加载文件的 Webpack 组件，两者主要区别："]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Thread-loader 由 Webpack 官方提供，目前还处于持续迭代维护状态，理论上更可靠；"}),"\n",(0,a.jsx)(n.li,{children:"Thread-loader 只提供了一个 Loader 组件，用法简单很多；"}),"\n",(0,a.jsxs)(n.li,{children:["HappyPack 启动后会创建一套 Mock 上下文环境 —— 包含 ",(0,a.jsx)(n.code,{children:"emitFile"})," 等接口，并传递给 Loader，因此对大多数 Loader 来说，运行在 HappyPack 与运行在 Webpack 原生环境相比没有太大差异；但 Thread-loader 并不具备这一特性，所以要求 Loader 内不能调用特定上下文接口，兼容性较差。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"说一千道一万，先来看看基本用法："}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"安装依赖："}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-Bash",children:"yarn add -D thread-loader\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsxs)(n.li,{children:["将 Thread-loader 放在 ",(0,a.jsx)(n.code,{children:"use"})," 数组首位，确保最先运行，如："]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ["thread-loader", "babel-loader", "eslint-loader"],\n      },\n    ],\n  },\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["启动后，Thread-loader 会在加载文件时创建新的进程，在子进程中使用 ",(0,a.jsx)(n.code,{children:"loader-runner"})," 库运行 ",(0,a.jsx)(n.code,{children:"thread-loader"})," 之后的 Loader 组件，执行完毕后再将结果回传到 Webpack 主进程，从而实现性能更佳的文件加载转译效果。"]}),"\n",(0,a.jsx)(n.p,{children:"以 Three.js 为例，使用 Thread-loader 前，构建耗时大约为 11000ms 到 18000ms 之间，开启后耗时降低到 8000ms 左右，提升约37%。"}),"\n",(0,a.jsx)(n.p,{children:"此外，Thread-loader 还提供了一系列用于控制并发逻辑的配置项，包括："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"workers"}),"：子进程总数，默认值为 ",(0,a.jsx)(n.code,{children:"require('os').cpus() - 1"}),"；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"workerParallelJobs"}),"：单个进程中并发执行的任务数；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"poolTimeout"}),"：子进程如果一直保持空闲状态，超过这个时间后会被关闭；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"poolRespawn"}),"：是否允许在子进程关闭后重新创建新的子进程，一般设置为 ",(0,a.jsx)(n.code,{children:"false"})," 即可；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"workerNodeArgs"}),"：用于设置启动子进程时，额外附加的参数。"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["使用方法跟其它 Loader 一样，都是通过 ",(0,a.jsx)(n.code,{children:"use.options"})," 属性传递，如："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: "thread-loader",\n            options: {\n              workers: 2,\n              workerParallelJobs: 50,\n              // ...\n            },\n          },\n          "babel-loader",\n          "eslint-loader",\n        ],\n      },\n    ],\n  },\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["不过，Thread-loader 也同样面临着频繁的子进程创建、销毁所带来的性能问题，为此，Thread-loader 提供了 ",(0,a.jsx)(n.code,{children:"warmup"})," 接口用于前置创建若干工作子进程，降低构建时延，用法："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:'const threadLoader = require("thread-loader");\n\nthreadLoader.warmup(\n  {\n    // 可传入上述 thread-loader 参数\n    workers: 2,\n    workerParallelJobs: 50,\n  },\n  [\n    // 子进程中需要预加载的 node 模块\n    "babel-loader",\n    "babel-preset-es2015",\n    "sass-loader",\n  ]\n);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["执行效果与 ",(0,a.jsx)(n.code,{children:"HappyPack.ThreadPool"})," 相似，此处不再赘述。"]}),"\n",(0,a.jsx)(n.p,{children:"与 HappyPack 相比，Thread-loader 有两个突出的优点，一是产自 Webpack 官方团队，后续有长期维护计划，稳定性有保障；二是用法更简单。但它不可避免的也存在一些问题："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["在 Thread-loader 中运行的 Loader 不能调用 ",(0,a.jsx)(n.code,{children:"emitAsset"})," 等接口，这会导致 ",(0,a.jsx)(n.code,{children:"style-loader"})," 这一类加载器无法正常工作，解决方案是将这类组件放置在 ",(0,a.jsx)(n.code,{children:"thread-loader"})," 之前，如 ",(0,a.jsx)(n.code,{children:"['style-loader', 'thread-loader', 'css-loader']"}),"；"]}),"\n",(0,a.jsxs)(n.li,{children:["Loader 中不能获取 ",(0,a.jsx)(n.code,{children:"compilation"}),"、",(0,a.jsx)(n.code,{children:"compiler"})," 等实例对象，也无法获取 Webpack 配置。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"这会导致一些 Loader 无法与 Thread-loader 共同使用，大家需要仔细加以甄别、测试。"}),"\n",(0,a.jsxs)(n.h2,{id:"使用-parallel-webpack",children:["使用 Parallel-Webpack",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-parallel-webpack",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["Thread-loader、HappyPack 这类组件所提供的并行能力都仅作用于文件加载过程，对后续 AST 解析、依赖收集、打包、优化代码等过程均没有影响，理论收益还是比较有限的。对此，社区还提供了另一种并行度更高，以多个独立进程运行 Webpack 实例的方案 —— ",(0,a.jsx)(n.a,{href:"https://github.com/trivago/parallel-webpack",target:"_blank",rel:"noopener noreferrer",children:"Parallel-Webpack"}),"，基本用法："]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"安装依赖："}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-Bash",children:"yarn add -D parallel-webpack\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"2",children:["\n",(0,a.jsxs)(n.li,{children:["在 ",(0,a.jsx)(n.code,{children:"webpack.config.js"})," 配置文件中导出多个 Webpack 配置对象，如："]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = [{\n    entry: 'pageA.js',\n    output: {\n        path: './dist',\n        filename: 'pageA.js'\n    }\n}, {\n    entry: 'pageB.js',\n    output: {\n        path: './dist',\n        filename: 'pageB.js'\n    }\n}];\n"})}),"\n",(0,a.jsxs)(n.ol,{start:"3",children:["\n",(0,a.jsxs)(n.li,{children:["执行 ",(0,a.jsx)(n.code,{children:"npx parallel-webpack"})," 命令。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Parallel-Webpack 会为配置文件中导出的每个 Webpack 配置对象启动一个独立的构建进程，从而实现并行编译的效果。底层原理很简单，基本上就是在 Webpack 上套了个壳："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["根据传入的配置项数量，调用 ",(0,a.jsx)(n.code,{children:"worker-farm"})," 创建复数个工作进程；"]}),"\n",(0,a.jsx)(n.li,{children:"工作进程内调用 Webpack 执行构建；"}),"\n",(0,a.jsxs)(n.li,{children:["工作进程执行完毕后，调用 ",(0,a.jsx)(n.code,{children:"node-ipc"})," 向主进程发送结束信号。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"这种方式在需要同时执行多份配置的编译时特别有效，但若配置文件本身只是导出了单个配置对象则意义不大。"}),"\n",(0,a.jsxs)(n.p,{children:["为了更好地支持多种配置的编译，Parallel-Webpack 还提供了 ",(0,a.jsx)(n.code,{children:"createVariants"})," 函数，用于根据给定变量组合，生成多份 Webpack 配置对象，如："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:"const createVariants = require('parallel-webpack').createVariants\nconst webpack = require('webpack')\n\nconst baseOptions = {\n  entry: './index.js'\n}\n\n// 配置变量组合\n// 属性名为 webpack 配置属性；属性值为可选的变量\n// 下述变量组合将最终产生 2*2*4 = 16 种形态的配置对象\nconst variants = {\n  minified: [true, false],\n  debug: [true, false],\n  target: ['commonjs2', 'var', 'umd', 'amd']\n}\n\nfunction createConfig (options) {\n  const plugins = [\n    new webpack.DefinePlugin({\n      DEBUG: JSON.stringify(JSON.parse(options.debug))\n    })\n  ]\n  return {\n    output: {\n      path: './dist/',\n      filename: 'MyLib.' +\n                options.target +\n                (options.minified ? '.min' : '') +\n                (options.debug ? '.debug' : '') +\n                '.js'\n    },\n    plugins: plugins\n  }\n}\n\nmodule.exports = createVariants(baseOptions, variants, createConfig)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上述示例使用 ",(0,a.jsx)(n.code,{children:"createVariants"})," 函数，根据 ",(0,a.jsx)(n.code,{children:"variants"})," 变量搭配出 16 种不同的 ",(0,a.jsx)(n.code,{children:"minified"}),"、",(0,a.jsx)(n.code,{children:"debug"}),"、",(0,a.jsx)(n.code,{children:"target"})," 组合，最终生成如下产物："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"[WEBPACK] Building 16 targets in parallel\n[WEBPACK] Started building MyLib.umd.js\n[WEBPACK] Started building MyLib.umd.min.js\n[WEBPACK] Started building MyLib.umd.debug.js\n[WEBPACK] Started building MyLib.umd.min.debug.js\n\n[WEBPACK] Started building MyLib.amd.js\n[WEBPACK] Started building MyLib.amd.min.js\n[WEBPACK] Started building MyLib.amd.debug.js\n[WEBPACK] Started building MyLib.amd.min.debug.js\n\n[WEBPACK] Started building MyLib.commonjs2.js\n[WEBPACK] Started building MyLib.commonjs2.min.js\n[WEBPACK] Started building MyLib.commonjs2.debug.js\n[WEBPACK] Started building MyLib.commonjs2.min.debug.js\n\n[WEBPACK] Started building MyLib.var.js\n[WEBPACK] Started building MyLib.var.min.js\n[WEBPACK] Started building MyLib.var.debug.js\n[WEBPACK] Started building MyLib.var.min.debug.js\n"})}),"\n",(0,a.jsx)(n.p,{children:"虽然，parallel-webpack 相对于 Thread-loader、HappyPack 有更高的并行度，但进程实例之间并没有做任何形式的通讯，这可能导致相同的工作在不同进程 —— 或者说不同 CPU 核上被重复执行。"}),"\n",(0,a.jsx)(n.p,{children:"例如需要对同一份代码同时打包出压缩和非压缩版本时，在 parallel-webpack 方案下，前置的资源加载、依赖解析、AST 分析等操作会被重复执行，仅仅最终阶段生成代码时有所差异。"}),"\n",(0,a.jsx)(n.p,{children:"这种技术实现，对单 entry 的项目没有任何收益，只会徒增进程创建成本；但特别适合 MPA 等多 entry 场景，或者需要同时编译出 esm、umd、amd 等多种产物形态的类库场景。"}),"\n",(0,a.jsxs)(n.h2,{id:"并行压缩",children:["并行压缩",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#并行压缩",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["Webpack4 默认使用 ",(0,a.jsx)(n.a,{href:"https://www.npmjs.com/package/uglifyjs-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"Uglify-js"})," 实现代码压缩，Webpack5 之后则升级为 ",(0,a.jsx)(n.a,{href:"https://webpack.js.org/plugins/terser-webpack-plugin/",target:"_blank",rel:"noopener noreferrer",children:"Terser"})," —— 一种",(0,a.jsx)(n.a,{href:"https://blog.logrocket.com/terser-vs-uglify-vs-babel-minify-comparing-javascript-minifiers/",target:"_blank",rel:"noopener noreferrer",children:"性能"}),"与兼容性更好的 JavaScript 代码压缩混淆工具，两种组件都原生实现了多进程并行压缩能力。"]}),"\n",(0,a.jsxs)(n.p,{children:["以 Terser 为例，TerserWebpackPlugin 插件默认已开启并行压缩，开发者也可以通过 ",(0,a.jsx)(n.code,{children:"parallel"})," 参数（默认值为 ",(0,a.jsx)(n.code,{children:"require('os').cpus() - 1"}),"）设置具体的并发进程数量，如："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-JavaScript",children:'const TerserPlugin = require("terser-webpack-plugin");\n\nmodule.exports = {\n    optimization: {\n        minimize: true,\n        minimizer: [new TerserPlugin({\n            parallel: 2 // number | boolean\n        })],\n    },\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["上述配置即可设定最大并行进程数为 2。此外，Webpack4 所使用的 ",(0,a.jsx)(n.code,{children:"uglifyjs-webpack-plugin"})," 也提供了类似的功能，用法与 Terser 相同，此处不再赘述。"]}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"受限于 JavaScript 的单线程架构，Webpack 构建时并不能充分使用现代计算机的多核 CPU 能力，为此社区提供了若干基于多进程实现的并行构建组件，包括文中介绍的 HappyPack、Thread-loader、Parallel-Webpack、Terser。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"对于 Webpack4 之前的项目，可以使用 HappyPack 实现并行文件加载；"}),"\n",(0,a.jsx)(n.li,{children:"Webpack4 之后则建议使用 Thread-loader；"}),"\n",(0,a.jsx)(n.li,{children:"多实例并行构建场景建议使用 Parallel-Webpack 实现并行；"}),"\n",(0,a.jsxs)(n.li,{children:["生产环境下还可配合 ",(0,a.jsx)(n.code,{children:"terser-webpack-plugin"})," 的并行压缩功能，提升整体效率。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"理论上，并行确实能够提升系统运行效率，但 Node 单线程架构下，所谓的并行计算都只能依托与派生子进程执行，而创建进程这个动作本身就有不小的消耗 —— 大约 600ms，对于小型项目，构建成本可能可能很低，引入多进程技术反而导致整体成本增加，因此建议大家按实际需求斟酌使用上述多进程方案。"}),"\n",(0,a.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["有没有可能使用 Node ",(0,a.jsx)(n.a,{href:"https://nodejs.org/api/worker_threads.html",target:"_blank",rel:"noopener noreferrer",children:"Worker"})," 实现多线程形式的 Webpack 并行构建？社区是否已经有相关组件？与多进程相比，可能存在怎么样的优缺点？"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}let p=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F14.Webpack%20%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C%E6%9E%84%E5%BB%BA%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F.md"]={toc:[{text:"使用 HappyPack",id:"使用-happypack",depth:2},{text:"使用 Thread-loader",id:"使用-thread-loader",depth:2},{text:"使用 Parallel-Webpack",id:"使用-parallel-webpack",depth:2},{text:"并行压缩",id:"并行压缩",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"14.Webpack 都有哪些实现并行构建的方法？",headingTitle:"14.Webpack 都有哪些实现并行构建的方法？",frontmatter:{}}}}]);