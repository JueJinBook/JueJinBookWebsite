"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["26352"],{140615:function(n,e,s){s.r(e),s.d(e,{default:()=>l});var t=s(552676),o=s(740453);let r=s.p+"static/image/56dc839561eb950b9a9308ff17790bf7.76b4e7d6.webp",c=s.p+"static/image/3d87f24544690a9cabdc3ed9abb79d31.4aa411c0.webp";function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,o.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"34-实战使用-http-服务与蓝牙设备通信",children:["34 实战：使用 HTTP 服务与蓝牙设备通信",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#34-实战使用-http-服务与蓝牙设备通信",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"在上一节课里，我们使用蓝牙串口服务（Bluetooth Serial Port Service，简称 BSPS）实现了到蓝牙设备的连接。这样，我们就可以在 Node.js 中通过命令行来操作蓝牙设备。但是，通过命令行操作设备不够方便，我们可以在蓝牙串口服务器之上再设计一个 HTTP 服务，通过 HTTP 服务将数据转发给蓝牙串口服务，这样我们就能在网页中通过 HTTP 请求来与我们的蓝牙设备通信了。"}),"\n",(0,t.jsx)(e.p,{children:"在前面的课程里已经说过，实现 HTTP 服务有很多可选的框架，比如 Express、Koa、Hapi 等。在这里，我们使用  Express 来实现 HTTP 服务。"}),"\n",(0,t.jsx)(e.p,{children:"我们可以在 package.json 中添加 Express 依赖："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"npm install express --save\n"})}),"\n",(0,t.jsxs)(e.p,{children:["然后，我们创建一个",(0,t.jsx)(e.code,{children:"server/index.js"}),"文件，用来实现 HTTP 服务："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"import express from 'express';\nimport bodyParser from 'body-parser';\nimport cors from 'cors';\nimport {Bluetooth} from './bluetooth/bluetooth.js';\n​\nconst config = {\n \xa0spp: {\n \xa0 \xa0deviceMAC: null,\n \xa0 \xa0maxConnectAttempts: 3,\n \xa0 \xa0connectionAttemptDelay: 500,\n \xa0 \xa0connectionTimeout: 10000,\n  },\n \xa0http: {\n \xa0 \xa0port: 9527,\n  },\n};\n​\n(async function () {\n \xa0const args = process.argv.slice(2);\n \xa0if(!args[0]) {\n \xa0 \xa0console.log(`No device MAC address.\n \xa0 \xa0Please use `npm run server -- <MAC>` to set the MAC address manually.`);\n \xa0 \xa0process.exit(-1);\n  }\n​\n \xa0config.spp.deviceMAC = args[0].replace(/[: ]/mg, '');\n​\n \xa0const bluetooth = new Bluetooth(config.spp);\n​\n \xa0// Let's try connecting\n \xa0const connection = await bluetooth.connect();\n​\n \xa0if(!connection) {\n \xa0 \xa0console.error('Failed to connect.');\n \xa0 \xa0process.exit(-1);\n  }\n​\n \xa0connection.on('data', (buffer) => {\n \xa0 \xa0const result = buffer.toString('hex');\n \xa0 \xa0console.log('<==', result);\n  });\n​\n \xa0const app = express();\n​\n \xa0// ...\n})();\n"})}),"\n",(0,t.jsxs)(e.p,{children:["这里我们使用了",(0,t.jsx)(e.code,{children:"process.argv"}),"来获取命令行参数，然后将参数传递给蓝牙串口服务。这样，我们就可以在命令行中通过",(0,t.jsx)(e.code,{children:"npm run server -- <MAC>"}),"输入蓝牙设备的 MAC 地址，用来建立蓝牙连接。"]}),"\n",(0,t.jsxs)(e.p,{children:["我们在启动 HTTP 服务之前，先创建蓝牙连接服务的实例，然后异步地调用",(0,t.jsx)(e.code,{children:"connect()"}),"方法来建立蓝牙连接。如果连接成功，我们就可以在",(0,t.jsx)(e.code,{children:"connection"}),"事件中监听到蓝牙设备的数据。"]}),"\n",(0,t.jsx)(e.p,{children:"这里，我们需要把上一节课的蓝牙服务连接代码做一个小的改动："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"export class Bluetooth {\n \xa0...\n \xa0async connect(times = this._config.maxConnectAttempts) {\n \xa0 \xa0const {connectionAttemptDelay} = this._config;\n \xa0 \xa0let attempts = 0;\n \xa0 \xa0let success = false;\n \xa0 \xa0for(let i = 0; i < times; i += 1) {\n \xa0 \xa0 \xa0try {\n \xa0 \xa0 \xa0 \xa0console.log('connection attempt %d/%d', attempts, times);\n \xa0 \xa0 \xa0 \xa0// eslint-disable-next-line no-await-in-loop\n \xa0 \xa0 \xa0 \xa0await this._connect();\n \xa0 \xa0 \xa0 \xa0success = true;\n \xa0 \xa0 \xa0 \xa0break;\n \xa0 \xa0  } catch (error) {\n \xa0 \xa0 \xa0 \xa0console.error('error', error.message);\n \xa0 \xa0 \xa0 \xa0attempts++;\n \xa0 \xa0 \xa0 \xa0// eslint-disable-next-line no-await-in-loop\n \xa0 \xa0 \xa0 \xa0await sleep(connectionAttemptDelay);\n \xa0 \xa0  }\n \xa0  }\n \xa0 \xa0await sleep(500); // wait for device ready\n \xa0 \xa0return success ? this.server : null;\n  }\n \xa0...\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["我们在",(0,t.jsx)(e.code,{children:"connect()"}),"方法中，通过",(0,t.jsx)(e.code,{children:"success"}),"变量来判断是否连接成功。如果连接成功，我们就返回",(0,t.jsx)(e.code,{children:"this.server"}),"，否则返回",(0,t.jsx)(e.code,{children:"null"}),"。"]}),"\n",(0,t.jsxs)(e.p,{children:["Express 是采用洋葱模型的 HTTP 服务框架，我们可以通过中间件来添加需要的功能。在这里，我们需要添加",(0,t.jsx)(e.code,{children:"body-parser"}),"和",(0,t.jsx)(e.code,{children:"cors"}),"中间件，分别用来解析 HTTP 请求的 body 和设置跨域访问。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"import express from 'express';\nimport bodyParser from 'body-parser';\nimport cors from 'cors';\nimport {Bluetooth} from './bluetooth/bluetooth.js';\n​\nconst config = {\n \xa0spp: {\n \xa0 \xa0deviceMAC: null,\n \xa0 \xa0maxConnectAttempts: 3,\n \xa0 \xa0connectionAttemptDelay: 500,\n \xa0 \xa0connectionTimeout: 10000,\n  },\n \xa0http: {\n \xa0 \xa0port: 9527,\n  },\n};\n​\n(async function () {\n \xa0const args = process.argv.slice(2);\n \xa0if(!args[0]) {\n \xa0 \xa0console.log(`No device MAC address.\n \xa0 \xa0Please use `npm run server -- <MAC>` to set the MAC address manually.`);\n \xa0 \xa0process.exit(-1);\n  }\n​\n \xa0config.spp.deviceMAC = args[0].replace(/[: ]/mg, '');\n​\n \xa0const bluetooth = new Bluetooth(config.spp);\n​\n \xa0// Let's try connecting\n \xa0const connection = await bluetooth.connect();\n​\n \xa0if(!connection) {\n \xa0 \xa0console.error('Failed to connect.');\n \xa0 \xa0process.exit(-1);\n  }\n​\n \xa0connection.on('data', (buffer) => {\n \xa0 \xa0const result = buffer.toString('hex');\n \xa0 \xa0console.log('<==', result);\n  });\n​\n \xa0const app = express();\n \xa0app.use(cors());\n \xa0app.use(bodyParser.text({type: '*/*'}));\n​\n \xa0app.get('/', (req, res) => {\n \xa0 \xa0res.send(config);\n  });\n​\n \xa0app.listen(config.http.port);\n})();\n"})}),"\n",(0,t.jsx)(e.p,{children:"现在我们已经实现了基本的 HTTP 服务，虽然我们还没有实现蓝牙设备数据的发送，但是这个服务器可以正常运行了。"}),"\n",(0,t.jsxs)(e.p,{children:["我们在 package.json 中添加一个",(0,t.jsx)(e.code,{children:"server"}),"命令，用来启动 HTTP 服务："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'{\n \xa0"scripts": {\n \xa0 \xa0"server": "node server"\n  }\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["这样我们就可以通过",(0,t.jsx)(e.code,{children:"npm run server -- <MAC>"}),"来启动服务器，然后通过浏览器访问",(0,t.jsx)(e.code,{children:"http://localhost:9527"}),"来查看服务器的配置信息。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"npm run server -- 11:75:58:CE:DB:2F\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,t.jsxs)(e.p,{children:["接下来，我们需要实现蓝牙设备数据的发送。我们可以在",(0,t.jsx)(e.code,{children:"server/index.js"}),"中添加一个",(0,t.jsx)(e.code,{children:"post"}),"方法，用来接收 HTTP 请求，然后将请求的数据发送到蓝牙设备："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:" \xa0app.post('/send', async (req, res) => {\n \xa0 \xa0try {\n \xa0 \xa0 \xa0const {payload} = JSON.parse(req.body);\n \xa0 \xa0 \xa0if(payload) {\n \xa0 \xa0 \xa0 \xa0const result = await bluetooth.writeMessage(payload);\n \xa0 \xa0 \xa0 \xa0res.send({status: 'OK', result});\n \xa0 \xa0  } else {\n \xa0 \xa0 \xa0 \xa0res.send({status: 'OK'});\n \xa0 \xa0  }\n \xa0  } catch (error) {\n \xa0 \xa0 \xa0res.send({status: 'ERROR', error: error.message});\n \xa0  }\n  });\n"})}),"\n",(0,t.jsx)(e.p,{children:"注意，这里我们可以有一个设计上的取舍，那就是我们能将数据的编码放在服务器端进行，也可以将数据的编码放在客户端进行，它们各有利弊。前者的好处是，我们在 HTTP 传输中可以减少数据的传输量，弊端是我们每添加一类硬件，需要对应实现该硬件的编码和解码。后者的好处是，我们可以在客户端实现多种硬件的编码和解码，弊端是我们在 HTTP 传输中会增加数据的传输量。"}),"\n",(0,t.jsx)(e.p,{children:"在这个项目里，我希望保持 HTTP 服务尽量通用，所以选择了在客户端处理数据。这样的话，我们的 HTTP 服务就可以实现得非常简单了，最后完整代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"// General purpose blue-tooth SPP server\n​\nimport express from 'express';\nimport bodyParser from 'body-parser';\nimport cors from 'cors';\nimport {Bluetooth} from './bluetooth/bluetooth.js';\n​\nconst config = {\n \xa0spp: {\n \xa0 \xa0deviceMAC: null,\n \xa0 \xa0maxConnectAttempts: 3,\n \xa0 \xa0connectionAttemptDelay: 500,\n \xa0 \xa0connectionTimeout: 10000,\n  },\n \xa0http: {\n \xa0 \xa0port: 9527,\n  },\n};\n​\n(async function () {\n \xa0const args = process.argv.slice(2);\n \xa0if(!args[0]) {\n \xa0 \xa0console.log(`No device MAC address.\n \xa0 \xa0Please use `npm run server -- <MAC>` to set the MAC address manually.`);\n \xa0 \xa0process.exit(-1);\n  }\n​\n \xa0config.spp.deviceMAC = args[0].replace(/[: ]/mg, '');\n​\n \xa0const bluetooth = new Bluetooth(config.spp);\n​\n \xa0// Let's try connecting\n \xa0const connection = await bluetooth.connect();\n​\n \xa0if(!connection) {\n \xa0 \xa0console.error('Failed to connect.');\n \xa0 \xa0process.exit(-1);\n  }\n​\n \xa0connection.on('data', (buffer) => {\n \xa0 \xa0const result = buffer.toString('hex');\n \xa0 \xa0console.log('<==', result);\n  });\n​\n \xa0const app = express();\n \xa0app.use(cors());\n \xa0app.use(bodyParser.text({type: '*/*'}));\n​\n \xa0app.get('/', (req, res) => {\n \xa0 \xa0res.send(config);\n  });\n​\n \xa0app.post('/send', async (req, res) => {\n \xa0 \xa0try {\n \xa0 \xa0 \xa0const {payload} = JSON.parse(req.body);\n \xa0 \xa0 \xa0if(payload) {\n \xa0 \xa0 \xa0 \xa0const result = await bluetooth.writeMessage(payload);\n \xa0 \xa0 \xa0 \xa0res.send({status: 'OK', result});\n \xa0 \xa0  } else {\n \xa0 \xa0 \xa0 \xa0res.send({status: 'OK'});\n \xa0 \xa0  }\n \xa0  } catch (error) {\n \xa0 \xa0 \xa0res.send({status: 'ERROR', error: error.message});\n \xa0  }\n  });\n​\n \xa0app.listen(config.http.port);\n​\n \xa0process.on('SIGINT', (code) => {\n \xa0 \xa0console.log('Disconnecting…');\n \xa0 \xa0connection.close();\n \xa0 \xa0process.exit(0);\n  });\n}());\n"})}),"\n",(0,t.jsxs)(e.p,{children:["我们可以测试一下 HTTP 服务。首先，在终端启动这个服务，然后我们在",(0,t.jsx)(e.a,{href:"https://code.juejin.cn",target:"_blank",rel:"noopener noreferrer",children:"码上掘金"}),"创建一个新的项目："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'<input type="color"/>\n'})}),"\n",(0,t.jsx)(e.p,{children:"我们在 HTML 中放了一个颜色选择器，然后实现 JavaScript 部分："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"const picker = document.querySelector('input[type=color');\n\nfunction int2hexlittle(value) {\n  if(value > 65535 || value < 0) {\n    throw new TypeError('int2hexlittle only supports value between 0 and 65535');\n  }\n  const byte1 = (value & 0xFF).toString(16).padStart(2, '0');\n  const byte2 = ((value >> 8) & 0xFF).toString(16).padStart(2, '0');\n  return `${byte1}${byte2}`;\n}\n\nfunction lengthHS(message) {\n  return int2hexlittle((message.length + 4) / 2);\n}\n\nfunction calcCRC(message) {\n  const msg = lengthHS(message) + message;\n  let sum = 0;\n  for(let i = 0, l = msg.length; i < l; i += 2) {\n    sum += parseInt(msg.substr(i, 2), 16);\n  }\n  return int2hexlittle(sum % 65536);\n}\n\nfunction generatePayload(message) {\n  return `01${lengthHS(message)}${message}${calcCRC(message)}02`;\n}\n\npicker.addEventListener('change', async ({target}) => {\n  const colorStr = target.value.slice(1);\n  const message = `4501${colorStr}500001000000`;\n  const payload = generatePayload(message);\n  const ret = await (await fetch('http://localhost:9527/send', {\n    method: 'POST',\n    body: JSON.stringify({\n      payload,\n    }),\n  })).json();\n  console.log(ret);\n});\n"})}),"\n",(0,t.jsx)(e.p,{children:"在上面的代码里，我们将颜色选择器的值转换成了 16 进制的字符串，然后将其拼接成了一个完整的数据包，最后将其发送到 HTTP 服务。可以看到，我们的 HTTP 服务接收到了这个数据包，并将其发送到了蓝牙设备，最终的效果如下："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:r,alt:"Mar-20-2023 15-31-13.gif"})}),"\n",(0,t.jsxs)(e.h2,{id:"小结",children:["小结",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"这一节课，我们通过封装 HTTP 服务，实现了用浏览器控制 SPP 协议的蓝牙设备。本节课我们只演示了基本的功能，而且我们从设计上保持服务器代码的简洁。接下来的课程中，我会对客户端代码进行设计，实现更加完善的封装，这样我们就可以更灵活地操作我们的蓝牙设备，来实现一些有趣的复杂的功能了。"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,o.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(i,{...n})}):i(n)}let l=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F34%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BD%BF%E7%94%A8%20HTTP%20%E6%9C%8D%E5%8A%A1%E4%B8%8E%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E9%80%9A%E4%BF%A1.md"]={toc:[{text:"小结",id:"小结",depth:2}],title:"34 实战：使用 HTTP 服务与蓝牙设备通信",headingTitle:"34 实战：使用 HTTP 服务与蓝牙设备通信",frontmatter:{}}}}]);