"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["87359"],{349977:function(e,n,t){e.exports=t.p+"static/image/064201007c82603be2fc52d706e5df03.5d136124.gif"},524150:function(e,n,t){e.exports=t.p+"static/image/5c7f86b886f6a0cddb37cb1508060c88.beec0d87.webp"},161971:function(e,n,t){e.exports=t.p+"static/image/8a6c50553a2c279193b29099590933a5.ff47c0ef.webp"},103141:function(e,n,t){t.r(n),t.d(n,{default:()=>F});var s=t(552676),r=t(740453);let i=t.p+"static/image/f444ae9d1a3a0c8866c65e2b1efe6289.8b217948.gif",a=t.p+"static/image/08f30159c95f3423460b958d63732f54.6f4f13bf.webp",c=t.p+"static/image/6318ed8b1b3bbd5abe35247358563ea9.6fd3eb75.webp",o=t.p+"static/image/a6b754ae271cd3e59aa76ebb182acdde.35c34e5b.webp",d=t.p+"static/image/44803cb3ad04fcb223c8c721f5c35bef.185906ba.webp",l=t.p+"static/image/481aa75fe897efa509cc3e773a1138d7.daea4b22.webp",p=t.p+"static/image/d666a2642e06a80b5bc0a4c668c9c6f0.d0709bea.webp",h=t.p+"static/image/9a49e58a55226c2dc11cc8a6bdd9e05d.cd07561f.webp",u=t.p+"static/image/1ec34cf629326aa6bc3138f3f2756d33.d6b23c9f.gif",f=t.p+"static/image/12e73b1954c27d880b25a2d354cdb1da.bc51188b.webp",m=t.p+"static/image/7dfe598af89f2af6e7bac1f5f2610f1f.82c6dd20.webp",j=t.p+"static/image/0ce1a00c3f5f8b2a1d2341cce64952b8.376195ef.gif",x=t.p+"static/image/71d31e9845a13180b3851712d42810ec.8a70b6fe.gif",g=t.p+"static/image/1ac119580de68b50510c1cba5393e785.7945c2d2.gif",b=t.p+"static/image/60c423319f684089031c9f6c3973875a.0b6de92d.webp",v=t.p+"static/image/6695abb1b7843a2241efbd1524c90fc8.73f46167.webp",E=t.p+"static/image/17c7ee9bbc6784bad248770856050ed4.584f989c.webp",R=t.p+"static/image/21c31597f47a41109b62c76c5e96f8d2.876a591c.webp",k=t.p+"static/image/a1c5bb8b28a11ba69d4c92005043be8e.d4ddaebf.webp",y=t.p+"static/image/64d21f6e3bdc7b320e93d573b7401def.d27c44b3.gif",w=t.p+"static/image/4a10ce3d58666bed47f918ec43c5e622.09cadf72.gif",T=t.p+"static/image/a308d7ad1f83f7eb31688906f9560c62.84765f3f.webp",D=t.p+"static/image/1de5255eade5b9e2f3d5d40dd30136e5.d52a05f8.webp",S=t.p+"static/image/67f12824cd04981af17ed40bde541329.658dca4a.gif";var C=t(349977);let N=t.p+"static/image/01d787a4cd97dc1a8080226a6ff151a6.155708fc.gif",z=t.p+"static/image/d5d2a67a26ab001db572fc393bd0c2c8.3ddfdddc.webp",L=t.p+"static/image/09750547fefe763702a45b0516c67247.848e812f.webp",H=t.p+"static/image/e5914ad240ac845aca8ba04bbd4d93d1.4969ce7a.gif";var O=t(524150),M=t(161971);let P=t.p+"static/image/3e25409674bfc0f50f1ff50c23fada20.18c7d46c.webp";function _(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"第22章自定义hook练习二",children:["第22章—自定义hook练习（二）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第22章自定义hook练习二",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"\uFEFF上节写了几个 react-use 的 hook，这节来写几个 ahooks 里的。"}),"\n",(0,s.jsx)(n.p,{children:"新建个项目："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx create-vite\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"进入项目，安装依赖，然后把服务跑起来："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install\nnpm run dev\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"去掉 index.css 和 StrictMode："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"安装 ahooks："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save ahooks\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"usesize",children:["useSize",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usesize",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"useSize 是用来获取 dom 尺寸的，并且在窗口大小改变的时候会实时返回新的尺寸"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { useRef } from 'react';\nimport { useSize } from 'ahooks';\n\nexport default () => {\n  const ref = useRef<HTMLDivElement>(null);\n  const size = useSize(ref);\n  return (\n    <div ref={ref}>\n      <p>改变窗口大小试试</p>\n      <p>\n        width: {size?.width}px, height: {size?.height}px\n      </p>\n    </div>\n  );\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:H,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们来实现下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import ResizeObserver from 'resize-observer-polyfill';\nimport { RefObject, useEffect, useState } from 'react';\n\ntype Size = { width: number; height: number };\n\nfunction useSize(targetRef: RefObject<HTMLElement>): Size | undefined {\n\n    const [state, setState] = useState<Size | undefined>(\n        () => {\n            const el = targetRef.current;\n            return el ? { width: el.clientWidth, height: el.clientHeight } : undefined\n        },\n    );\n\n    useEffect(() => {\n        const el = targetRef.current;\n\n        if (!el) {\n            return;\n        }\n\n        const resizeObserver = new ResizeObserver((entries) => {\n            entries.forEach((entry) => {\n                const { clientWidth, clientHeight } = entry.target;\n                setState({ width: clientWidth, height: clientHeight });\n            });\n        });\n        resizeObserver.observe(el);\n\n        return () => {\n            resizeObserver.disconnect();\n        };\n    }, []);\n\n    return state;\n}\n\nexport default useSize;\n"})}),"\n",(0,s.jsx)(n.p,{children:"用 useState 创建 state，初始值是传入的 ref 元素的宽高。"}),"\n",(0,s.jsx)(n.p,{children:"这里取 clientHeight，也就是不包含边框的高度。"}),"\n",(0,s.jsxs)(n.p,{children:["网页里的各种距离、尺寸可以看",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7294082310658326565/section/7357716194742583330",target:"_blank",rel:"noopener noreferrer",children:"图解网页的各种距离"}),"那节。"]}),"\n",(0,s.jsx)(n.p,{children:"然后用 ResizeObserver 监听元素尺寸的变化，改变的时候 setState 触发重新渲染。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:L,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这里为了兼容，用了 resize-observer-polyfill"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm i --save resize-observer-polyfill\n"})}),"\n",(0,s.jsx)(n.p,{children:"换成我们实现的试一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:z,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没啥问题："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"usehover",children:["useHover",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usehover",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上节用用过 react-use 的 useHover，它是传入 React Element （或者返回 React Element 的函数）的方式："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import {useHover} from 'react-use';\n\nconst App = () => {\n  const element = (hovered: boolean) =>\n    <div>\n      Hover me! {hovered && 'Thanks'}\n    </div>;\n\n  const [hoverable, hovered] = useHover(element);\n\n  return (\n    <div>\n      {hoverable}\n      <div>{hovered ? 'HOVERED' : ''}</div>\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["而 ahooks 里的 ",(0,s.jsx)(n.a,{href:"https://ahooks.gitee.io/zh-CN/hooks/use-hover",target:"_blank",rel:"noopener noreferrer",children:"useHover"})," 是这样用的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { useRef } from 'react';\nimport { useHover } from 'ahooks';\n\nexport default () => {\n  const ref = useRef<HTMLDivElement>(null);\n  const isHovering = useHover(ref);\n  return <div ref={ref}>{isHovering ? 'hover' : 'leaveHover'}</div>;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"传入的是 ref。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"实现下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { RefObject, useEffect, useState } from 'react';\n\nexport interface Options {\n  onEnter?: () => void;\n  onLeave?: () => void;\n  onChange?: (isHovering: boolean) => void;\n}\n\nexport default (ref: RefObject<HTMLElement>, options?: Options): boolean => {\n    const { onEnter, onLeave, onChange } = options || {};\n\n    const [isEnter, setIsEnter] = useState<boolean>(false);\n\n    useEffect(() => {\n        ref.current?.addEventListener('mouseenter', () => {\n            onEnter?.();\n            setIsEnter(true);\n            onChange?.(true);\n        });\n    \n        ref.current?.addEventListener('mouseleave', () => {\n            onLeave?.();\n            setIsEnter(false);\n            onChange?.(false);\n        });\n    }, [ref]);\n\n    return isEnter;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"上节讲过事件绑定类的 hook 有三种写法，之前用传入 React Element + cloneElement 的方式实现过，这次用 ref + addEventListener 实现的。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,s.jsxs)(n.h2,{id:"usetimeout",children:["useTimeout",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usetimeout",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"讲闭包陷阱那节我们实现过定时器的 hook："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { useState } from 'react';\nimport { useTimeout } from 'ahooks';\n\nexport default () => {\n  const [state, setState] = useState(1);\n  useTimeout(() => {\n    setState(state + 1);\n  }, 3000);\n\n  return <div>{state}</div>;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"它要保证只能跑一次，不然计时会不准。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"ahooks 的实现和我们之前实现一样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useCallback, useEffect, useRef } from 'react';\n\nconst useTimeout = (fn: () => void, delay?: number) => {\n\n  const fnRef = useRef<Function>(fn);\n\n  fnRef.current = fn;\n\n  const timerRef = useRef<number>();\n\n  const clear = useCallback(() => {\n    if (timerRef.current) {\n      clearTimeout(timerRef.current);\n    }\n  }, []);\n\n  useEffect(() => {\n    timerRef.current = setTimeout(fnRef.current, delay);\n\n    return clear;\n  }, [delay]);\n\n  return clear;\n};\n\nexport default useTimeout;\n"})}),"\n",(0,s.jsx)(n.p,{children:"首先 useRef 保存回调函数，每次调用都会更新这个函数，避免闭包陷阱（函数里引用之前的 state）："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"setTimeout 执行从 fnRef.current 取的最新的函数。"}),"\n",(0,s.jsxs)(n.p,{children:["要不要在渲染函数里直接改 ref.current，其实都可以，",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7294082310658326565/section/7298292751051784230",target:"_blank",rel:"noopener noreferrer",children:"闭包陷阱那节"}),"也讲过。文档里不建议，但是很多库都是直接改的。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以包一层 useLayoutEffect 或者 useEffect，这里我们就可以改了。"}),"\n",(0,s.jsx)(n.p,{children:"然后用 useRef 保存 timer 引用，方便 clear 函数里拿到它来 clearTimeout："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,s.jsxs)(n.h2,{id:"usewhydidyouupdate",children:["useWhyDidYouUpdate",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usewhydidyouupdate",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["props 变了会导致组件重新渲染，而 ",(0,s.jsx)(n.a,{href:"https://ahooks.gitee.io/zh-CN/hooks/use-why-did-you-update",target:"_blank",rel:"noopener noreferrer",children:"useWhyDidYouUpdate"})," 就是用来打印是哪些 props 改变导致的重新渲染："]}),"\n",(0,s.jsx)(n.p,{children:"用下试试："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useWhyDidYouUpdate } from 'ahooks';\nimport React, { useState } from 'react';\n\nconst Demo: React.FC<{ count: number }> = (props) => {\n  const [randomNum, setRandomNum] = useState(Math.random());\n\n  useWhyDidYouUpdate('Demo', { ...props, randomNum });\n\n  return (\n    <div>\n      <div>\n        <span>number: {props.count}</span>\n      </div>\n      <div>\n        randomNum: {randomNum}\n        <button onClick={() => setRandomNum(Math.random)}>\n          设置随机 state\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default () => {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <Demo count={count} />\n      <div>\n        <button onClick={() => setCount((prevCount) => prevCount - 1)}>减一</button>\n        <button onClick={() => setCount((prevCount) => prevCount + 1)}>加一</button>\n      </div>\n    </div>\n  );\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Demo 组件有 count 的 props，有 randomNum 的 state。"}),"\n",(0,s.jsx)(n.p,{children:"当 count 导致组件重新渲染时："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"当 randomNum 导致组件重新渲染时："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"都能打印出值从 from 改变到 to 导致的。"}),"\n",(0,s.jsx)(n.p,{children:"它的实现其实很简单，我们来写一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef } from 'react';\n\nexport type IProps = Record<string, any>;\n\nexport default function useWhyDidYouUpdate(componentName: string, props: IProps) {\n  const prevProps = useRef<IProps>({});\n\n  useEffect(() => {\n    if (prevProps.current) {\n      const allKeys = Object.keys({ ...prevProps.current, ...props });\n      const changedProps: IProps = {};\n\n      allKeys.forEach((key) => {\n        if (!Object.is(prevProps.current[key], props[key])) {\n          changedProps[key] = {\n            from: prevProps.current[key],\n            to: props[key],\n          };\n        }\n      });\n\n      if (Object.keys(changedProps).length) {\n        console.log('[why-did-you-update]', componentName, changedProps);\n      }\n    }\n\n    prevProps.current = props;\n  });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Record<string, any> 是任意的对象的 ts 类型。"}),"\n",(0,s.jsx)(n.p,{children:"核心就是 useRef 保存 props 或者其他值，当下次渲染的时候，拿到新的值和上次的对比下，打印值的变化："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"props 可以传入任意 props、state 或者其他值："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"实现很简单，但是比较有用的一个 hook。"}),"\n",(0,s.jsxs)(n.h2,{id:"usecountdown",children:["useCountDown",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecountdown",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这个是用来获取倒计时的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useCountDown } from 'ahooks';\n\nexport default () => {\n  const [countdown, formattedRes] = useCountDown({\n    targetDate: `${new Date().getFullYear()}-12-31 23:59:59`,\n  });\n\n  const { days, hours, minutes, seconds, milliseconds } = formattedRes;\n\n  return (\n    <p>\n      距离今年年底还剩 {days} 天 {hours} 小时 {minutes} 分钟 {seconds} 秒 {milliseconds} 毫秒\n    </p>\n  );\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"比如获取到今年年底的倒计时。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们来实现下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import dayjs from 'dayjs';\nimport { useEffect, useMemo, useRef, useState } from 'react';\n\nexport type TDate = dayjs.ConfigType;\n\nexport interface Options {\n  leftTime?: number;\n  targetDate?: TDate;\n  interval?: number;\n  onEnd?: () => void;\n}\n\nexport interface FormattedRes {\n  days: number;\n  hours: number;\n  minutes: number;\n  seconds: number;\n  milliseconds: number;\n}\n\nconst calcLeft = (target?: TDate) => {\n  if (!target) {\n    return 0;\n  }\n\n  const left = dayjs(target).valueOf() - Date.now();\n  return left < 0 ? 0 : left;\n};\n\nconst parseMs = (milliseconds: number): FormattedRes => {\n  return {\n    days: Math.floor(milliseconds / 86400000),\n    hours: Math.floor(milliseconds / 3600000) % 24,\n    minutes: Math.floor(milliseconds / 60000) % 60,\n    seconds: Math.floor(milliseconds / 1000) % 60,\n    milliseconds: Math.floor(milliseconds) % 1000,\n  };\n};\n\nconst useCountdown = (options: Options = {}) => {\n    const { leftTime, targetDate, interval = 1000, onEnd } = options || {};\n\n    const memoLeftTime = useMemo<TDate>(() => {\n        return leftTime && leftTime > 0 ? Date.now() + leftTime : undefined;\n    }, [leftTime]);\n\n    const target = 'leftTime' in options ? memoLeftTime : targetDate;\n\n    const [timeLeft, setTimeLeft] = useState(() => calcLeft(target));\n\n    const onEndRef = useRef(onEnd);\n    onEndRef.current = onEnd;\n\n    useEffect(() => {\n        if (!target) {\n            setTimeLeft(0);\n            return;\n        }\n\n        setTimeLeft(calcLeft(target));\n\n        const timer = setInterval(() => {\n            const targetLeft = calcLeft(target);\n            setTimeLeft(targetLeft);\n            if (targetLeft === 0) {\n                clearInterval(timer);\n                onEndRef.current?.();\n            }\n        }, interval);\n\n        return () => clearInterval(timer);\n    }, [target, interval]);\n\n    const formattedRes = useMemo(() => parseMs(timeLeft), [timeLeft]);\n\n    return [timeLeft, formattedRes] as const;\n};\n\nexport default useCountdown;\n"})}),"\n",(0,s.jsx)(n.p,{children:"代码比较多，一部分一部分来看。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Options 是参数的类型，可以传入 leftTime 剩余时间，也可以传入目标日期值 targetDate。"}),"\n",(0,s.jsx)(n.p,{children:"interval 是倒计时变化的时间间隔，默认 1s。"}),"\n",(0,s.jsx)(n.p,{children:"onEnd 是倒计时结束的回调。"}),"\n",(0,s.jsx)(n.p,{children:"FormattedRes 是返回的格式化后的日期。"}),"\n",(0,s.jsx)(n.p,{children:"TDate 是 dayjs 允许的传入的日期类型。"}),"\n",(0,s.jsx)(n.p,{children:"然后 leftTime 和 targetDate 只需要取一个。"}),"\n",(0,s.jsx)(n.p,{children:"如果是 leftTime 那 Date.now() 加上 targetDate 就是目标日期。否则，就用传入的 targetDate。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"onEnd 的函数也是要用 useRef 保存，然后每次更新 ref.current，取的时候取 ref.current。"}),"\n",(0,s.jsx)(n.p,{children:"这也是为了避免闭包陷阱的。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"核心部分是 useState 创建一个 state，在初始和每次定时器都计算一次剩余时间："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个就是当前日期到目标日期的差值："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后把它格式化一下就好了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"倒计时的逻辑很简单，就是通过定时器，每次计算下当前日期和目标日期的差值，返回格式化以后的结果。"}),"\n",(0,s.jsx)(n.p,{children:"注意传入的回调函数都要用 useRef 包裹下，用的时候取 ref.current，避免闭包陷阱。"}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,s.jsxs)(n.p,{children:["案例代码上传了",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/ahooks-hook",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节我们写了几个 ahooks 里的自定义 hook。"}),"\n",(0,s.jsx)(n.p,{children:"useSize：拿到元素尺寸，通过 ResizeObserver 监听尺寸变动返回新的尺寸。"}),"\n",(0,s.jsx)(n.p,{children:"useHover：用 ref + addEventListener 实现的 hover 事件。"}),"\n",(0,s.jsx)(n.p,{children:"useTimeout：对 setTimeout 的封装，通过 useRef 保存 fn 避免了闭包陷阱。"}),"\n",(0,s.jsx)(n.p,{children:"useWhyDidYouUpdate：打印 props 或者 state 等的变化，排查引起组件重新渲染的原因，原理很简单，就是通过 useRef 保存之前的值，和当前渲染时的值对比"}),"\n",(0,s.jsx)(n.p,{children:"useCountDown：倒计时，通过当前时间和目标时间的差值实现，基于 dayjs。"}),"\n",(0,s.jsx)(n.p,{children:"写完这些 hook，相信你对自定义 hook 的封装更加得心应手了。"})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}let F=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC22%E7%AB%A0%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89hook%E7%BB%83%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89.md"]={toc:[{text:"useSize",id:"usesize",depth:2},{text:"useHover",id:"usehover",depth:2},{text:"useTimeout",id:"usetimeout",depth:2},{text:"useWhyDidYouUpdate",id:"usewhydidyouupdate",depth:2},{text:"useCountDown",id:"usecountdown",depth:2},{text:"总结",id:"总结",depth:2}],title:"第22章—自定义hook练习（二）",headingTitle:"第22章—自定义hook练习（二）",frontmatter:{}}}}]);