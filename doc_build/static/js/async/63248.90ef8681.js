"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["63248"],{928900:function(n,e,r){r.r(e),r.d(e,{default:()=>u});var i=r(552676),t=r(740453);let s=r.p+"static/image/af99108464e639d414284e7f51219f61.e590c0d0.webp",o=r.p+"static/image/7956fbd96d66048adbd1c421ed6cf797.6eddcb82.webp",l=r.p+"static/image/a0e916218acc444c5f20386625a46ffb.86a935df.webp",c=r.p+"static/image/b9806ad91136623c81b41ce062e43f49.023e5f51.webp";function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",strong:"strong",h2:"h2",ul:"ul",li:"li",h3:"h3",pre:"pre",code:"code"},(0,t.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"8软件包封装-如何发布兼容多种-js-模块标准的软件包",children:["8.软件包封装： 如何发布兼容多种 JS 模块标准的软件包？",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#8软件包封装-如何发布兼容多种-js-模块标准的软件包",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"为了方便用户使用，一款成熟的类库都会提供多种模块封装形式，比如大家最常用到的 Vue，就提供了cjs、esm、umd 等多种封装模式，并且还会提供对应的压缩版本，方便在生产环境下使用。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:c,alt:"img"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"第一，需要考虑的是需要支持哪些模块规范。"})}),"\n",(0,i.jsx)(e.p,{children:"目前常见的模块规范有：\n-   IFFE：使用立即执行函数实现模块化 例：(function()) {}；\n-   CJS：基于 CommonJS 标准的模块化；\n-   AMD：使用 Require 编写；\n-   CMD：使用 SeaJS 编写；\n-   ESM：ES 标准的模块化方案 ( ES6 标准提出 )；\n-   UMD：兼容 CJS 与 AMD、IFFE 规范。"}),"\n",(0,i.jsx)(e.p,{children:"其中最常用的有三类：ESM、CJS 和 IFFE。\nESM 标准目前已经是前端开发的标配，无论是选用 Webpack 还是 Vite ，都会采用这种模块规范。其次是 CJS，不可否认，有大量的存量代码还使用 CJS 规范，完全没有必要因为引入一个库去更改编译规则。最后是 IFFE 这种类型，非常适用于逻辑简单，无需搭建工程化环境的前端应用。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"第二，需要考虑的是代码的压缩和混淆问题。"})}),"\n",(0,i.jsx)(e.p,{children:"代码压缩是指去除代码中的空格、制表符、换行符等内容，将代码压缩至几行内容甚至一行，这样可以提高网站的加载速度。混淆是将代码转换成一种功能上等价，但是难以阅读和理解的形式。混淆的主要目的是增加反向工程的难度，同时也可以相对减少代码的体积，比如将变量名缩短就会减少代码的体积。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"第三，还需要考虑 SourceMap 配置。"})}),"\n",(0,i.jsx)(e.p,{children:"SourceMap 就是一个信息文件，里面存储了代码打包转换后的位置信息，实质是一个 json 描述文件，维护了打包前后的代码映射关系。通"}),"\n",(0,i.jsx)(e.p,{children:"常输出的模块不会提供 SourceMap，因为通过 sourcemap 就很容易还原原始代码。但是如果你想在浏览器中断点调试你的代码，或者希望在异常监控工具中定位出错位置，SourceMap 就非常有必要。所以还是要正确掌握 SourceMap 的生成方法。"}),"\n",(0,i.jsxs)(e.h2,{id:"用户故事userstory",children:["用户故事(UserStory)",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#用户故事userstory",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"让组件库能够兼容多种组件库打包格式，并可以输出压缩版本。"}),"\n",(0,i.jsxs)(e.h2,{id:"任务分解task",children:["任务分解(Task)",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#任务分解task",children:"#"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"配置Vite 输出多种格式模块；"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"配置SourceMap映射；"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"测试打包结果。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"任务实现",children:["任务实现",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#任务实现",children:"#"})]}),"\n",(0,i.jsxs)(e.h3,{id:"配置-vite-的打包方案",children:["配置 Vite 的打包方案",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#配置-vite-的打包方案",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"如果你使用过 Rollup 实现过多模块方案输出，你就会对 Vite 超级简单的配置所折服。在 Rollup 时代，通常这一步都需要自己编写复杂的 JS 脚本实现。比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'const outputs = ["esm", "cjs", "iife", "umd"].map((format) => ({\n \xa0file: `dist/smartyui.${format}.js`,\n \xa0name: "SmartyUI",\n \xa0format,\n \xa0exports: "named",\n \xa0globals: {\n \xa0 \xa0vue: "Vue",\n  },\n}));\n\nconst packageConfigs = outputs\n  .map((output) => createConfig(output))\n  .concat(outputs.map((output) => createMinifiedConfig(output)));\n\nfunction createPackageJSON() {\n \xa0const data = require("./package.json");\n  (data.main = "dist/smartyui.cjs.js"), (data.module = "dist/smartui.esm.js");\n\n \xa0fs.outputFileSync(\n \xa0 \xa0resolve("./dist", "package.json"),\n \xa0 \xa0JSON.stringify(data, "\\t", "\\t"),\n \xa0 \xa0"utf-8"\n  );\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"作为对比，看一下 Vite 的配置，就显得非常的简洁。"}),"\n",(0,i.jsx)(e.p,{children:"vite.config.ts"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:' const rollupOptions = {\n  external: ["vue"],\n  output: {\n \xa0  globals: {\n \xa0 \xa0  vue: "Vue",\n \xa0  },\n  },\n};\n'})}),"\n",(0,i.jsx)(e.p,{children:"这里面有几个配置需要说明一下。"}),"\n",(0,i.jsx)(e.p,{children:"首先是 rollupOptions 配置。由于 Vite 的构建是通过 rollup 完成的，所以 rollup 中的一些配置通过这个属性传递给 rollup。其中需要配置的两个属性如下："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"external： 作用是将该模块保留在 bundle 之外，比如在数组中添加了 vue ，就是为了不让 vue 打包到组件库中；"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"output： 这个配置用于 umd/iffe 包中，意思是全局中的某个模块在组件库中叫什么名字。比如："}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"import $ from 'jquery';\n"})}),"\n",(0,i.jsxs)(e.p,{children:["意味着",(0,i.jsx)(e.code,{children:"jquery"})," 模块的 id 等同于 ",(0,i.jsx)(e.code,{children:"$"})," 变量:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"var MyBundle = (function ($) {\n  // 代码到这里\n}(window.jQuery));\n"})}),"\n",(0,i.jsx)(e.p,{children:"接着："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'export default defineConfig({\n build: {\n \xa0 \xa0rollupOptions,\n \xa0 \xa0minify: \'terser\', // boolean | \'terser\' | \'esbuild\'\n \xa0 \xa0sourcemap: true, // 输出单独 source文件\n \xa0 \xa0brotliSize: true, \xa0// 生成压缩大小报告\n    cssCodeSplit: true,\n \xa0 \xa0lib: {\n \xa0 \xa0 \xa0entry: "./src/entry.ts",\n \xa0 \xa0 \xa0name: "SmartyUI",\n \xa0 \xa0 \xa0fileName: "smarty-ui",\n \xa0 \xa0 \xa0formats: ["esm", "umd", "iife"], // 导出模块类型\n \xa0  },\n  },\n});\n'})}),"\n",(0,i.jsx)(e.p,{children:"由于使用了 terser 用于代码压缩需要单独安装一下"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:'pnpm i terser@"5.4.0" -D\n'})}),"\n",(0,i.jsx)(e.p,{children:"其他属性："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:'formats： ["esm", "umd", "iife"] 是输出模块类型；'}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"fileName：是文件名，其实只是一个输出文件名的前缀，默认情况下会和模块类型配合组成最终的文件名。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:l,alt:"img"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["name 属性 : 生成包的名字，在 ",(0,i.jsx)(e.code,{children:"iife"}),"/",(0,i.jsx)(e.code,{children:"umd"})," 包，同一页上的其他脚本可以访问它。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"minify 属性： 是混淆的意思，这里面有两个混淆工具可以选择，即 terser 和 esbuild。我目前选择了比较老牌的压缩工具 terser，毕竟从 Rollup 时代开始就一直在用。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"这时候运行 pnpm build 就可以输出模块了。"}),"\n",(0,i.jsxs)(e.h3,{id:"配置-sourcemap-映射",children:["配置 SourceMap 映射",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#配置-sourcemap-映射",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"下面说一下 SourceMap 配置。"}),"\n",(0,i.jsx)(e.p,{children:"如果希望导出 SourceMap， 只需要添加 SourceMap 属性就好了。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"export default defineConfig({\n build: {\n \xa0 \xa0...\n \xa0 \xa0sourcemap: true, // 输出单独 source文件\n \xa0 \xa0...\n  },\n});\n"})}),"\n",(0,i.jsx)(e.p,{children:"此时，构建的时候会生成 SourceMap。"}),"\n",(0,i.jsx)(e.p,{children:"有了 SourceMap ，就可以在 Chrome 调试工具中进行断点调试了。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:o,alt:"img"})}),"\n",(0,i.jsxs)(e.h3,{id:"测试打包结果",children:["测试打包结果",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#测试打包结果",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"最后编写一个测试页来确定输出模块效果OK。"}),"\n",(0,i.jsx)(e.p,{children:"先测试是 IFFE 模块。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'<h1>Demo IFFE</h1>\n<div id="app"></div>\n<link rel="stylesheet" href="../dist/style.css">\n<script src="../node_modules/vue/dist/vue.global.js"><\/script>\n<script src="../dist/smarty-ui.iife.js"><\/script>\n<script>\n \xa0 \xa0console.log(\'111\')\n \xa0 \xa0const { createApp } = Vue\n \xa0 \xa0console.log(\'vue\', Vue)\n \xa0 \xa0console.log(\'SmartyUI\', SmartyUI)\n \xa0 \xa0createApp({\n \xa0 \xa0 \xa0 \xa0template: `\n \xa0 \xa0 \xa0 \xa0<div style="margin-bottom:20px;">\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="blue">主要按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="green">绿色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="gray">灰色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="yellow">黄色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="red">红色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0 \xa0 \xa0<div style="margin-bottom:20px;"\n \xa0 \xa0 \xa0 \xa0>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="blue" plain>朴素按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="green" plain>绿色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="gray" plain>灰色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="yellow" plain>黄色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="red" plain>红色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0 \xa0 \xa0<div style="margin-bottom:20px;">\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton size="small" plain>小按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton size="medium" plain>中按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton size="large" plain>大按钮</SButton>\n \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0 \xa0 \xa0<div style="margin-bottom:20px;">\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="blue" round plain icon="search">搜索按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="green" round plain icon="edit">编辑按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="gray" round plain icon="check">成功按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="yellow" round plain icon="message">提示按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="red" round plain icon="delete">删除按钮</SButton>\n \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0 \xa0 \xa0<div style="margin-bottom:20px;">\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="blue" round plain icon="search"></SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="green" round plain icon="edit"></SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="gray" round plain icon="check"></SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="yellow" round plain icon="message"></SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<SButton color="red" round plain icon="delete"></SButton>\n \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0`}).use(SmartyUI.default).mount(\'#app\')\n<\/script>\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:s,alt:"img"})}),"\n",(0,i.jsxs)(e.h2,{id:"复盘",children:["复盘",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#复盘",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"这节课我们讲了如何让组件库兼容多种模块化标准。"}),"\n",(0,i.jsx)(e.p,{children:"我们希望组件一次编写处处执行，希望组件库可以有更广阔的应用场景。无论是在 Webpack 或者 Vite 甚至直接在简单网页中都可以使用。还需要同时兼顾运行性能和调试的便利性。每种应用场景都需要不同的模块配置配合，输出模块需要考虑：支持模块风格、混淆压缩策略、Sourcemap三方面内容。这样才能够成为一个合格的组件库。"}),"\n",(0,i.jsx)(e.p,{children:"最后留一些思考题帮助大家复习，也欢迎大家在评论区讨论。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"常用的 JS 模块化标准都有哪些 ？"}),"\n",(0,i.jsx)(e.li,{children:"UMD 都兼容哪些模块标准 ？"}),"\n",(0,i.jsx)(e.li,{children:"sourcemap 的作用是什么 ？"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"下节课，我们将完成软件包的封装，下节课见。"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}let u=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Vite%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E6%88%98%2F8.%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%B0%81%E8%A3%85%EF%BC%9A%20%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E5%85%BC%E5%AE%B9%E5%A4%9A%E7%A7%8D%20JS%20%E6%A8%A1%E5%9D%97%E6%A0%87%E5%87%86%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%9F.md"]={toc:[{text:"用户故事(UserStory)",id:"用户故事userstory",depth:2},{text:"任务分解(Task)",id:"任务分解task",depth:2},{text:"任务实现",id:"任务实现",depth:2},{text:"配置 Vite 的打包方案",id:"配置-vite-的打包方案",depth:3},{text:"配置 SourceMap 映射",id:"配置-sourcemap-映射",depth:3},{text:"测试打包结果",id:"测试打包结果",depth:3},{text:"复盘",id:"复盘",depth:2}],title:"8.软件包封装： 如何发布兼容多种 JS 模块标准的软件包？",headingTitle:"8.软件包封装： 如何发布兼容多种 JS 模块标准的软件包？",frontmatter:{}}}}]);