"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["25772"],{786644:function(n,e,c){c.r(e),c.d(e,{default:()=>o});var s=c(552676),r=c(740453);function i(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",h3:"h3"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"21async-函数",children:["21.async 函数",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#21async-函数",children:"#"})]}),"\n",(0,s.jsxs)(e.h2,{id:"含义",children:["含义",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#含义",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"ES2017 标准引入了 async 函数，使得异步操作变得更加方便。"}),"\n",(0,s.jsx)(e.p,{children:"async 函数是什么？一句话，它就是 Generator 函数的语法糖。"}),"\n",(0,s.jsx)(e.p,{children:"前文有一个 Generator 函数，依次读取两个文件。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const fs = require('fs');\n\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\n\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码的函数",(0,s.jsx)(e.code,{children:"gen"}),"可以写成",(0,s.jsx)(e.code,{children:"async"}),"函数，就是下面这样。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["一比较就会发现，",(0,s.jsx)(e.code,{children:"async"}),"函数就是将 Generator 函数的星号（",(0,s.jsx)(e.code,{children:"*"}),"）替换成",(0,s.jsx)(e.code,{children:"async"}),"，将",(0,s.jsx)(e.code,{children:"yield"}),"替换成",(0,s.jsx)(e.code,{children:"await"}),"，仅此而已。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"函数对 Generator 函数的改进，体现在以下四点。"]}),"\n",(0,s.jsx)(e.p,{children:"（1）内置执行器。"}),"\n",(0,s.jsxs)(e.p,{children:["Generator 函数的执行必须靠执行器，所以才有了",(0,s.jsx)(e.code,{children:"co"}),"模块，而",(0,s.jsx)(e.code,{children:"async"}),"函数自带执行器。也就是说，",(0,s.jsx)(e.code,{children:"async"}),"函数的执行，与普通函数一模一样，只要一行。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"asyncReadFile();\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面的代码调用了",(0,s.jsx)(e.code,{children:"asyncReadFile"}),"函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用",(0,s.jsx)(e.code,{children:"next"}),"方法，或者用",(0,s.jsx)(e.code,{children:"co"}),"模块，才能真正执行，得到最后结果。"]}),"\n",(0,s.jsx)(e.p,{children:"（2）更好的语义。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"和",(0,s.jsx)(e.code,{children:"await"}),"，比起星号和",(0,s.jsx)(e.code,{children:"yield"}),"，语义更清楚了。",(0,s.jsx)(e.code,{children:"async"}),"表示函数里有异步操作，",(0,s.jsx)(e.code,{children:"await"}),"表示紧跟在后面的表达式需要等待结果。"]}),"\n",(0,s.jsx)(e.p,{children:"（3）更广的适用性。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"co"}),"模块约定，",(0,s.jsx)(e.code,{children:"yield"}),"命令后面只能是 Thunk 函数或 Promise 对象，而",(0,s.jsx)(e.code,{children:"async"}),"函数的",(0,s.jsx)(e.code,{children:"await"}),"命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。"]}),"\n",(0,s.jsx)(e.p,{children:"（4）返回值是 Promise。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用",(0,s.jsx)(e.code,{children:"then"}),"方法指定下一步的操作。"]}),"\n",(0,s.jsxs)(e.p,{children:["进一步说，",(0,s.jsx)(e.code,{children:"async"}),"函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而",(0,s.jsx)(e.code,{children:"await"}),"命令就是内部",(0,s.jsx)(e.code,{children:"then"}),"命令的语法糖。"]}),"\n",(0,s.jsxs)(e.h2,{id:"基本用法",children:["基本用法",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#基本用法",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"函数返回一个 Promise 对象，可以使用",(0,s.jsx)(e.code,{children:"then"}),"方法添加回调函数。当函数执行的时候，一旦遇到",(0,s.jsx)(e.code,{children:"await"}),"就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。"]}),"\n",(0,s.jsx)(e.p,{children:"下面是一个例子。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function getStockPriceByName(name) {\n  const symbol = await getStockSymbol(name);\n  const stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码是一个获取股票报价的函数，函数前面的",(0,s.jsx)(e.code,{children:"async"}),"关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个",(0,s.jsx)(e.code,{children:"Promise"}),"对象。"]}),"\n",(0,s.jsx)(e.p,{children:"下面是另一个例子，指定多少毫秒后输出一个值。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function timeout(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码指定 50 毫秒以后，输出",(0,s.jsx)(e.code,{children:"hello world"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["由于",(0,s.jsx)(e.code,{children:"async"}),"函数返回的是 Promise 对象，可以作为",(0,s.jsx)(e.code,{children:"await"}),"命令的参数。所以，上面的例子也可以写成下面的形式。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function timeout(ms) {\n  await new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nasync function asyncPrint(value, ms) {\n  await timeout(ms);\n  console.log(value);\n}\n\nasyncPrint('hello world', 50);\n"})}),"\n",(0,s.jsx)(e.p,{children:"async 函数有多种使用形式。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// 函数声明\nasync function foo() {}\n\n// 函数表达式\nconst foo = async function () {};\n\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n\n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n\n// 箭头函数\nconst foo = async () => {};\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"语法",children:["语法",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#语法",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"函数的语法规则总体上比较简单，难点是错误处理机制。"]}),"\n",(0,s.jsxs)(e.h3,{id:"返回-promise-对象",children:["返回 Promise 对象",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#返回-promise-对象",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"函数返回一个 Promise 对象。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"函数内部",(0,s.jsx)(e.code,{children:"return"}),"语句返回的值，会成为",(0,s.jsx)(e.code,{children:"then"}),"方法回调函数的参数。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  return 'hello world';\n}\n\nf().then(v => console.log(v))\n// \"hello world\"\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，函数",(0,s.jsx)(e.code,{children:"f"}),"内部",(0,s.jsx)(e.code,{children:"return"}),"命令返回的值，会被",(0,s.jsx)(e.code,{children:"then"}),"方法回调函数接收到。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"函数内部抛出错误，会导致返回的 Promise 对象变为",(0,s.jsx)(e.code,{children:"reject"}),"状态。抛出的错误对象会被",(0,s.jsx)(e.code,{children:"catch"}),"方法回调函数接收到。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log('resolve', v),\n  e => console.log('reject', e)\n)\n//reject Error: 出错了\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"promise-对象的状态变化",children:["Promise 对象的状态变化",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#promise-对象的状态变化",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"async"}),"函数返回的 Promise 对象，必须等到内部所有",(0,s.jsx)(e.code,{children:"await"}),"命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到",(0,s.jsx)(e.code,{children:"return"}),"语句或者抛出错误。也就是说，只有",(0,s.jsx)(e.code,{children:"async"}),"函数内部的异步操作执行完，才会执行",(0,s.jsx)(e.code,{children:"then"}),"方法指定的回调函数。"]}),"\n",(0,s.jsx)(e.p,{children:"下面是一个例子。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function getTitle(url) {\n  let response = await fetch(url);\n  let html = await response.text();\n  return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n}\ngetTitle('https://tc39.github.io/ecma262/').then(console.log)\n// \"ECMAScript 2017 Language Specification\"\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，函数",(0,s.jsx)(e.code,{children:"getTitle"}),"内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行",(0,s.jsx)(e.code,{children:"then"}),"方法里面的",(0,s.jsx)(e.code,{children:"console.log"}),"。"]}),"\n",(0,s.jsxs)(e.h3,{id:"await-命令",children:["await 命令",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#await-命令",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["正常情况下，",(0,s.jsx)(e.code,{children:"await"}),"命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  // 等同于\n  // return 123;\n  return await 123;\n}\n\nf().then(v => console.log(v))\n// 123\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，",(0,s.jsx)(e.code,{children:"await"}),"命令的参数是数值",(0,s.jsx)(e.code,{children:"123"}),"，这时等同于",(0,s.jsx)(e.code,{children:"return 123"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["另一种情况是，",(0,s.jsx)(e.code,{children:"await"}),"命令后面是一个",(0,s.jsx)(e.code,{children:"thenable"}),"对象（即定义了",(0,s.jsx)(e.code,{children:"then"}),"方法的对象），那么",(0,s.jsx)(e.code,{children:"await"}),"会将其等同于 Promise 对象。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"class Sleep {\n  constructor(timeout) {\n    this.timeout = timeout;\n  }\n  then(resolve, reject) {\n    const startTime = Date.now();\n    setTimeout(\n      () => resolve(Date.now() - startTime),\n      this.timeout\n    );\n  }\n}\n\n(async () => {\n  const sleepTime = await new Sleep(1000);\n  console.log(sleepTime);\n})();\n// 1000\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，",(0,s.jsx)(e.code,{children:"await"}),"命令后面是一个",(0,s.jsx)(e.code,{children:"Sleep"}),"对象的实例。这个实例不是 Promise 对象，但是因为定义了",(0,s.jsx)(e.code,{children:"then"}),"方法，",(0,s.jsx)(e.code,{children:"await"}),"会将其视为",(0,s.jsx)(e.code,{children:"Promise"}),"处理。"]}),"\n",(0,s.jsxs)(e.p,{children:["这个例子还演示了如何实现休眠效果。JavaScript 一直没有休眠的语法，但是借助",(0,s.jsx)(e.code,{children:"await"}),"命令就可以让程序停顿指定的时间。下面给出了一个简化的",(0,s.jsx)(e.code,{children:"sleep"}),"实现。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function sleep(interval) {\n  return new Promise(resolve => {\n    setTimeout(resolve, interval);\n  })\n}\n\n// 用法\nasync function one2FiveInAsync() {\n  for(let i = 1; i <= 5; i++) {\n    console.log(i);\n    await sleep(1000);\n  }\n}\n\none2FiveInAsync();\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"await"}),"命令后面的 Promise 对象如果变为",(0,s.jsx)(e.code,{children:"reject"}),"状态，则",(0,s.jsx)(e.code,{children:"reject"}),"的参数会被",(0,s.jsx)(e.code,{children:"catch"}),"方法的回调函数接收到。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  await Promise.reject('出错了');\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// 出错了\n"})}),"\n",(0,s.jsxs)(e.p,{children:["注意，上面代码中，",(0,s.jsx)(e.code,{children:"await"}),"语句前面没有",(0,s.jsx)(e.code,{children:"return"}),"，但是",(0,s.jsx)(e.code,{children:"reject"}),"方法的参数依然传入了",(0,s.jsx)(e.code,{children:"catch"}),"方法的回调函数。这里如果在",(0,s.jsx)(e.code,{children:"await"}),"前面加上",(0,s.jsx)(e.code,{children:"return"}),"，效果是一样的。"]}),"\n",(0,s.jsxs)(e.p,{children:["任何一个",(0,s.jsx)(e.code,{children:"await"}),"语句后面的 Promise 对象变为",(0,s.jsx)(e.code,{children:"reject"}),"状态，那么整个",(0,s.jsx)(e.code,{children:"async"}),"函数都会中断执行。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  await Promise.reject('出错了');\n  await Promise.resolve('hello world'); // 不会执行\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，第二个",(0,s.jsx)(e.code,{children:"await"}),"语句是不会执行的，因为第一个",(0,s.jsx)(e.code,{children:"await"}),"语句状态变成了",(0,s.jsx)(e.code,{children:"reject"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个",(0,s.jsx)(e.code,{children:"await"}),"放在",(0,s.jsx)(e.code,{children:"try...catch"}),"结构里面，这样不管这个异步操作是否成功，第二个",(0,s.jsx)(e.code,{children:"await"}),"都会执行。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  try {\n    await Promise.reject('出错了');\n  } catch(e) {\n  }\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// hello world\n"})}),"\n",(0,s.jsxs)(e.p,{children:["另一种方法是",(0,s.jsx)(e.code,{children:"await"}),"后面的 Promise 对象再跟一个",(0,s.jsx)(e.code,{children:"catch"}),"方法，处理前面可能出现的错误。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  await Promise.reject('出错了')\n    .catch(e => console.log(e));\n  return await Promise.resolve('hello world');\n}\n\nf()\n.then(v => console.log(v))\n// 出错了\n// hello world\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"错误处理",children:["错误处理",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#错误处理",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["如果",(0,s.jsx)(e.code,{children:"await"}),"后面的异步操作出错，那么等同于",(0,s.jsx)(e.code,{children:"async"}),"函数返回的 Promise 对象被",(0,s.jsx)(e.code,{children:"reject"}),"。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  await new Promise(function (resolve, reject) {\n    throw new Error('出错了');\n  });\n}\n\nf()\n.then(v => console.log(v))\n.catch(e => console.log(e))\n// Error：出错了\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，",(0,s.jsx)(e.code,{children:"async"}),"函数",(0,s.jsx)(e.code,{children:"f"}),"执行后，",(0,s.jsx)(e.code,{children:"await"}),"后面的 Promise 对象会抛出一个错误对象，导致",(0,s.jsx)(e.code,{children:"catch"}),"方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async 函数的实现原理”。"]}),"\n",(0,s.jsxs)(e.p,{children:["防止出错的方法，也是将其放在",(0,s.jsx)(e.code,{children:"try...catch"}),"代码块之中。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function f() {\n  try {\n    await new Promise(function (resolve, reject) {\n      throw new Error('出错了');\n    });\n  } catch(e) {\n  }\n  return await('hello world');\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["如果有多个",(0,s.jsx)(e.code,{children:"await"}),"命令，可以统一放在",(0,s.jsx)(e.code,{children:"try...catch"}),"结构中。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function main() {\n  try {\n    const val1 = await firstStep();\n    const val2 = await secondStep(val1);\n    const val3 = await thirdStep(val1, val2);\n\n    console.log('Final: ', val3);\n  }\n  catch (err) {\n    console.error(err);\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["下面的例子使用",(0,s.jsx)(e.code,{children:"try...catch"}),"结构，实现多次重复尝试。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const superagent = require('superagent');\nconst NUM_RETRIES = 3;\n\nasync function test() {\n  let i;\n  for (i = 0; i < NUM_RETRIES; ++i) {\n    try {\n      await superagent.get('http://google.com/this-throws-an-error');\n      break;\n    } catch(err) {}\n  }\n  console.log(i); // 3\n}\n\ntest();\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，如果",(0,s.jsx)(e.code,{children:"await"}),"操作成功，就会使用",(0,s.jsx)(e.code,{children:"break"}),"语句退出循环；如果失败，会被",(0,s.jsx)(e.code,{children:"catch"}),"语句捕捉，然后进入下一轮循环。"]}),"\n",(0,s.jsxs)(e.h3,{id:"使用注意点",children:["使用注意点",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用注意点",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["第一点，前面已经说过，",(0,s.jsx)(e.code,{children:"await"}),"命令后面的",(0,s.jsx)(e.code,{children:"Promise"}),"对象，运行结果可能是",(0,s.jsx)(e.code,{children:"rejected"}),"，所以最好把",(0,s.jsx)(e.code,{children:"await"}),"命令放在",(0,s.jsx)(e.code,{children:"try...catch"}),"代码块中。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function myFunction() {\n  try {\n    await somethingThatReturnsAPromise();\n  } catch (err) {\n    console.log(err);\n  }\n}\n\n// 另一种写法\n\nasync function myFunction() {\n  await somethingThatReturnsAPromise()\n  .catch(function (err) {\n    console.log(err);\n  });\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["第二点，多个",(0,s.jsx)(e.code,{children:"await"}),"命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"let foo = await getFoo();\nlet bar = await getBar();\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，",(0,s.jsx)(e.code,{children:"getFoo"}),"和",(0,s.jsx)(e.code,{children:"getBar"}),"是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有",(0,s.jsx)(e.code,{children:"getFoo"}),"完成以后，才会执行",(0,s.jsx)(e.code,{children:"getBar"}),"，完全可以让它们同时触发。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面两种写法，",(0,s.jsx)(e.code,{children:"getFoo"}),"和",(0,s.jsx)(e.code,{children:"getBar"}),"都是同时触发，这样就会缩短程序的执行时间。"]}),"\n",(0,s.jsxs)(e.p,{children:["第三点，",(0,s.jsx)(e.code,{children:"await"}),"命令只能用在",(0,s.jsx)(e.code,{children:"async"}),"函数之中，如果用在普通函数，就会报错。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码会报错，因为",(0,s.jsx)(e.code,{children:"await"}),"用在普通函数之中了。但是，如果将",(0,s.jsx)(e.code,{children:"forEach"}),"方法的参数改成",(0,s.jsx)(e.code,{children:"async"}),"函数，也有问题。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function dbFuc(db) { //这里不需要 async\n \xa0let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码可能不会正常工作，原因是这时三个",(0,s.jsx)(e.code,{children:"db.post()"}),"操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用",(0,s.jsx)(e.code,{children:"for"}),"循环。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["另一种方法是使用数组的",(0,s.jsx)(e.code,{children:"reduce()"}),"方法。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  await docs.reduce(async (_, doc) => {\n    await _;\n    await db.post(doc);\n  }, undefined);\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面例子中，",(0,s.jsx)(e.code,{children:"reduce()"}),"方法的第一个参数是",(0,s.jsx)(e.code,{children:"async"}),"函数，导致该函数的第一个参数是前一步操作返回的 Promise 对象，所以必须使用",(0,s.jsx)(e.code,{children:"await"}),"等待它操作结束。另外，",(0,s.jsx)(e.code,{children:"reduce()"}),"方法返回的是",(0,s.jsx)(e.code,{children:"docs"}),"数组最后一个成员的",(0,s.jsx)(e.code,{children:"async"}),"函数的执行结果，也是一个 Promise 对象，导致在它前面也必须加上",(0,s.jsx)(e.code,{children:"await"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["上面的",(0,s.jsx)(e.code,{children:"reduce()"}),"的参数函数里面没有",(0,s.jsx)(e.code,{children:"return"}),"语句，原因是这个函数的主要目的是",(0,s.jsx)(e.code,{children:"db.post()"}),"操作，不是返回值。而且",(0,s.jsx)(e.code,{children:"async"}),"函数不管有没有",(0,s.jsx)(e.code,{children:"return"}),"语句，总是返回一个 Promise 对象，所以这里的",(0,s.jsx)(e.code,{children:"return"}),"是不必要的。"]}),"\n",(0,s.jsxs)(e.p,{children:["如果确实希望多个请求并发执行，可以使用",(0,s.jsx)(e.code,{children:"Promise.all"}),"方法。当三个请求都会",(0,s.jsx)(e.code,{children:"resolved"}),"时，下面两种写法效果相同。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\n\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"第四点，async 函数可以保留运行堆栈。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = () => {\n  b().then(() => c());\n};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，函数",(0,s.jsx)(e.code,{children:"a"}),"内部运行了一个异步任务",(0,s.jsx)(e.code,{children:"b()"}),"。当",(0,s.jsx)(e.code,{children:"b()"}),"运行的时候，函数",(0,s.jsx)(e.code,{children:"a()"}),"不会中断，而是继续执行。等到",(0,s.jsx)(e.code,{children:"b()"}),"运行结束，可能",(0,s.jsx)(e.code,{children:"a()"}),"早就运行结束了，",(0,s.jsx)(e.code,{children:"b()"}),"所在的上下文环境已经消失了。如果",(0,s.jsx)(e.code,{children:"b()"}),"或",(0,s.jsx)(e.code,{children:"c()"}),"报错，错误堆栈将不包括",(0,s.jsx)(e.code,{children:"a()"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["现在将这个例子改成",(0,s.jsx)(e.code,{children:"async"}),"函数。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const a = async () => {\n  await b();\n  c();\n};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，",(0,s.jsx)(e.code,{children:"b()"}),"运行的时候，",(0,s.jsx)(e.code,{children:"a()"}),"是暂停执行，上下文环境都保存着。一旦",(0,s.jsx)(e.code,{children:"b()"}),"或",(0,s.jsx)(e.code,{children:"c()"}),"报错，错误堆栈将包括",(0,s.jsx)(e.code,{children:"a()"}),"。"]}),"\n",(0,s.jsxs)(e.h2,{id:"async-函数的实现原理",children:["async 函数的实现原理",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#async-函数的实现原理",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function fn(args) {\n  // ...\n}\n\n// 等同于\n\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["所有的",(0,s.jsx)(e.code,{children:"async"}),"函数都可以写成上面的第二种形式，其中的",(0,s.jsx)(e.code,{children:"spawn"}),"函数就是自动执行器。"]}),"\n",(0,s.jsxs)(e.p,{children:["下面给出",(0,s.jsx)(e.code,{children:"spawn"}),"函数的实现，基本就是前文自动执行器的翻版。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function spawn(genF) {\n  return new Promise(function(resolve, reject) {\n    const gen = genF();\n    function step(nextF) {\n      let next;\n      try {\n        next = nextF();\n      } catch(e) {\n        return reject(e);\n      }\n      if(next.done) {\n        return resolve(next.value);\n      }\n      Promise.resolve(next.value).then(function(v) {\n        step(function() { return gen.next(v); });\n      }, function(e) {\n        step(function() { return gen.throw(e); });\n      });\n    }\n    step(function() { return gen.next(undefined); });\n  });\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"与其他异步处理方法的比较",children:["与其他异步处理方法的比较",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#与其他异步处理方法的比较",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"我们通过一个例子，来看 async 函数与 Promise、Generator 函数的比较。"}),"\n",(0,s.jsx)(e.p,{children:"假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。"}),"\n",(0,s.jsx)(e.p,{children:"首先是 Promise 的写法。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function chainAnimationsPromise(elem, animations) {\n\n  // 变量ret用来保存上一个动画的返回值\n  let ret = null;\n\n  // 新建一个空的Promise\n  let p = Promise.resolve();\n\n  // 使用then方法，添加所有动画\n  for(let anim of animations) {\n    p = p.then(function(val) {\n      ret = val;\n      return anim(elem);\n    });\n  }\n\n  // 返回一个部署了错误捕捉机制的Promise\n  return p.catch(function(e) {\n    /* 忽略错误，继续执行 */\n  }).then(function() {\n    return ret;\n  });\n\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["虽然 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（",(0,s.jsx)(e.code,{children:"then"}),"、",(0,s.jsx)(e.code,{children:"catch"}),"等等），操作本身的语义反而不容易看出来。"]}),"\n",(0,s.jsx)(e.p,{children:"接着是 Generator 函数的写法。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function chainAnimationsGenerator(elem, animations) {\n\n  return spawn(function*() {\n    let ret = null;\n    try {\n      for(let anim of animations) {\n        ret = yield anim(elem);\n      }\n    } catch(e) {\n      /* 忽略错误，继续执行 */\n    }\n    return ret;\n  });\n\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码使用 Generator 函数遍历了每个动画，语义比 Promise 写法更清晰，用户定义的操作全部都出现在",(0,s.jsx)(e.code,{children:"spawn"}),"函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数，上面代码的",(0,s.jsx)(e.code,{children:"spawn"}),"函数就是自动执行器，它返回一个 Promise 对象，而且必须保证",(0,s.jsx)(e.code,{children:"yield"}),"语句后面的表达式，必须返回一个 Promise。"]}),"\n",(0,s.jsx)(e.p,{children:"最后是 async 函数的写法。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function chainAnimationsAsync(elem, animations) {\n  let ret = null;\n  try {\n    for(let anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。"}),"\n",(0,s.jsxs)(e.h2,{id:"实例按顺序完成异步操作",children:["实例：按顺序完成异步操作",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实例按顺序完成异步操作",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组 URL，然后按照读取的顺序输出结果。"}),"\n",(0,s.jsx)(e.p,{children:"Promise 的写法如下。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function logInOrder(urls) {\n  // 远程读取所有URL\n  const textPromises = urls.map(url => {\n    return fetch(url).then(response => response.text());\n  });\n\n  // 按次序输出\n  textPromises.reduce((chain, textPromise) => {\n    return chain.then(() => textPromise)\n      .then(text => console.log(text));\n  }, Promise.resolve());\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码使用",(0,s.jsx)(e.code,{children:"fetch"}),"方法，同时远程读取一组 URL。每个",(0,s.jsx)(e.code,{children:"fetch"}),"操作都返回一个 Promise 对象，放入",(0,s.jsx)(e.code,{children:"textPromises"}),"数组。然后，",(0,s.jsx)(e.code,{children:"reduce"}),"方法依次处理每个 Promise 对象，然后使用",(0,s.jsx)(e.code,{children:"then"}),"，将所有 Promise 对象连起来，因此就可以依次输出结果。"]}),"\n",(0,s.jsx)(e.p,{children:"这种写法不太直观，可读性比较差。下面是 async 函数实现。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function logInOrder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"async function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，虽然",(0,s.jsx)(e.code,{children:"map"}),"方法的参数是",(0,s.jsx)(e.code,{children:"async"}),"函数，但它是并发执行的，因为只有",(0,s.jsx)(e.code,{children:"async"}),"函数内部是继发执行，外部不受影响。后面的",(0,s.jsx)(e.code,{children:"for..of"}),"循环内部使用了",(0,s.jsx)(e.code,{children:"await"}),"，因此实现了按顺序输出。"]}),"\n",(0,s.jsxs)(e.h2,{id:"顶层-await",children:["顶层 await",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#顶层-await",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["早期的语法规定是，",(0,s.jsx)(e.code,{children:"await"}),"命令只能出现在 async 函数内部，否则都会报错。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// 报错\nconst data = await fetch('https://api.example.com');\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，",(0,s.jsx)(e.code,{children:"await"}),"命令独立使用，没有放在 async 函数里面，就会报错。"]}),"\n",(0,s.jsxs)(e.p,{children:["从 ",(0,s.jsx)(e.a,{href:"https://github.com/tc39/proposal-top-level-await",target:"_blank",rel:"noopener noreferrer",children:"ES2022"})," 开始，允许在模块的顶层独立使用",(0,s.jsx)(e.code,{children:"await"}),"命令，使得上面那行代码不会报错了。它的主要目的是使用",(0,s.jsx)(e.code,{children:"await"}),"解决模块异步加载的问题。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// awaiting.js\nlet output;\nasync function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n}\nmain();\nexport { output };\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，模块",(0,s.jsx)(e.code,{children:"awaiting.js"}),"的输出值",(0,s.jsx)(e.code,{children:"output"}),"，取决于异步操作。我们把异步操作包装在一个 async 函数里面，然后调用这个函数，只有等里面的异步操作都执行，变量",(0,s.jsx)(e.code,{children:"output"}),"才会有值，否则就返回",(0,s.jsx)(e.code,{children:"undefined"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"下面是加载这个模块的写法。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// usage.js\nimport { output } from "./awaiting.js";\n\nfunction outputPlusValue(value) { return output + value }\n\nconsole.log(outputPlusValue(100));\nsetTimeout(() => console.log(outputPlusValue(100)), 1000);\n'})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，",(0,s.jsx)(e.code,{children:"outputPlusValue()"}),"的执行结果，完全取决于执行的时间。如果",(0,s.jsx)(e.code,{children:"awaiting.js"}),"里面的异步操作没执行完，加载进来的",(0,s.jsx)(e.code,{children:"output"}),"的值就是",(0,s.jsx)(e.code,{children:"undefined"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"目前的解决方法，就是让原始模块输出一个 Promise 对象，从这个 Promise 对象判断异步操作有没有结束。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// awaiting.js\nlet output;\nexport default (async function main() {\n  const dynamic = await import(someMission);\n  const data = await fetch(url);\n  output = someProcess(dynamic.default, data);\n})();\nexport { output };\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，",(0,s.jsx)(e.code,{children:"awaiting.js"}),"除了输出",(0,s.jsx)(e.code,{children:"output"}),"，还默认输出一个 Promise 对象（async 函数立即执行后，返回一个 Promise 对象），从这个对象判断异步操作是否结束。"]}),"\n",(0,s.jsx)(e.p,{children:"下面是加载这个模块的新的写法。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// usage.js\nimport promise, { output } from "./awaiting.js";\n\nfunction outputPlusValue(value) { return output + value }\n\npromise.then(() => {\n  console.log(outputPlusValue(100));\n  setTimeout(() => console.log(outputPlusValue(100)), 1000);\n});\n'})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，将",(0,s.jsx)(e.code,{children:"awaiting.js"}),"对象的输出，放在",(0,s.jsx)(e.code,{children:"promise.then()"}),"里面，这样就能保证异步操作完成以后，才去读取",(0,s.jsx)(e.code,{children:"output"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["这种写法比较麻烦，等于要求模块的使用者遵守一个额外的使用协议，按照特殊的方法使用这个模块。一旦你忘了要用 Promise 加载，只使用正常的加载方法，依赖这个模块的代码就可能出错。而且，如果上面的",(0,s.jsx)(e.code,{children:"usage.js"}),"又有对外的输出，等于这个依赖链的所有模块都要使用 Promise 加载。"]}),"\n",(0,s.jsxs)(e.p,{children:["顶层的",(0,s.jsx)(e.code,{children:"await"}),"命令，就是为了解决这个问题。它保证只有异步操作完成，模块才会输出值。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// awaiting.js\nconst dynamic = import(someMission);\nconst data = fetch(url);\nexport const output = someProcess((await dynamic).default, await data);\n"})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码中，两个异步操作在输出的时候，都加上了",(0,s.jsx)(e.code,{children:"await"}),"命令。只有等到异步操作完成，这个模块才会输出值。"]}),"\n",(0,s.jsx)(e.p,{children:"加载这个模块的写法如下。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// usage.js\nimport { output } from "./awaiting.js";\nfunction outputPlusValue(value) { return output + value }\n\nconsole.log(outputPlusValue(100));\nsetTimeout(() => console.log(outputPlusValue(100)), 1000);\n'})}),"\n",(0,s.jsx)(e.p,{children:"上面代码的写法，与普通的模块加载完全一样。也就是说，模块的使用者完全不用关心，依赖模块的内部有没有异步操作，正常加载即可。"}),"\n",(0,s.jsxs)(e.p,{children:["这时，模块的加载会等待依赖模块（上例是",(0,s.jsx)(e.code,{children:"awaiting.js"}),"）的异步操作完成，才执行后面的代码，有点像暂停在那里。所以，它总是会得到正确的",(0,s.jsx)(e.code,{children:"output"}),"，不会因为加载时机的不同，而得到不一样的值。"]}),"\n",(0,s.jsxs)(e.p,{children:["注意，顶层",(0,s.jsx)(e.code,{children:"await"}),"只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的",(0,s.jsx)(e.code,{children:"require()"}),"是同步加载，如果有顶层",(0,s.jsx)(e.code,{children:"await"}),"，就没法处理加载了。"]}),"\n",(0,s.jsxs)(e.p,{children:["下面是顶层",(0,s.jsx)(e.code,{children:"await"}),"的一些使用场景。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// import() 方法加载\nconst strings = await import(`/i18n/${navigator.language}`);\n\n// 数据库操作\nconst connection = await dbConnector();\n\n// 依赖回滚\nlet jQuery;\ntry {\n  jQuery = await import('https://cdn-a.com/jQuery');\n} catch {\n  jQuery = await import('https://cdn-b.com/jQuery');\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["注意，如果加载多个包含顶层",(0,s.jsx)(e.code,{children:"await"}),"命令的模块，加载命令是同步执行的。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'// x.js\nconsole.log("X1");\nawait new Promise(r => setTimeout(r, 1000));\nconsole.log("X2");\n\n// y.js\nconsole.log("Y");\n\n// z.js\nimport "./x.js";\nimport "./y.js";\nconsole.log("Z");\n'})}),"\n",(0,s.jsxs)(e.p,{children:["上面代码有三个模块，最后的",(0,s.jsx)(e.code,{children:"z.js"}),"加载",(0,s.jsx)(e.code,{children:"x.js"}),"和",(0,s.jsx)(e.code,{children:"y.js"}),"，打印结果是",(0,s.jsx)(e.code,{children:"X1"}),"、",(0,s.jsx)(e.code,{children:"Y"}),"、",(0,s.jsx)(e.code,{children:"X2"}),"、",(0,s.jsx)(e.code,{children:"Z"}),"。这说明，",(0,s.jsx)(e.code,{children:"z.js"}),"并没有等待",(0,s.jsx)(e.code,{children:"x.js"}),"加载完成，再去加载",(0,s.jsx)(e.code,{children:"y.js"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["顶层的",(0,s.jsx)(e.code,{children:"await"}),"命令有点像，交出代码的执行权给其他的模块加载，等异步操作完成后，再拿回执行权，继续向下执行。"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(i,{...n})}):i(n)}let o=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F21.async%20%E5%87%BD%E6%95%B0.md"]={toc:[{text:"含义",id:"含义",depth:2},{text:"基本用法",id:"基本用法",depth:2},{text:"语法",id:"语法",depth:2},{text:"返回 Promise 对象",id:"返回-promise-对象",depth:3},{text:"Promise 对象的状态变化",id:"promise-对象的状态变化",depth:3},{text:"await 命令",id:"await-命令",depth:3},{text:"错误处理",id:"错误处理",depth:3},{text:"使用注意点",id:"使用注意点",depth:3},{text:"async 函数的实现原理",id:"async-函数的实现原理",depth:2},{text:"与其他异步处理方法的比较",id:"与其他异步处理方法的比较",depth:2},{text:"实例：按顺序完成异步操作",id:"实例按顺序完成异步操作",depth:2},{text:"顶层 await",id:"顶层-await",depth:2}],title:"21.async 函数",headingTitle:"21.async 函数",frontmatter:{}}}}]);