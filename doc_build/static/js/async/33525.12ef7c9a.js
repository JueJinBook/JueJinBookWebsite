"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["33525"],{261546:function(e,n,s){s.r(n),s.d(n,{default:()=>m});var a=s(552676),r=s(740453);let l=s.p+"static/image/39d5daff82ca7cbe1221a781d65f7ae4.2532ca71.png",i=s.p+"static/image/ce035acd9cf9cf14952236d08e613c33.9f794fae.png",t=s.p+"static/image/dadcf159fd4bb3b5639ab86b987ce573.4ea530da.png",c=s.p+"static/image/a0c341bf9aaf116634c9a181e9e677a0.6aed8253.png",d=s.p+"static/image/967f12535dc68c6023e38cab624e27ad.367faac1.png",p=s.p+"static/image/5248ebe163d7e47175e3f804b6820020.11756176.png",h=s.p+"static/image/c187d91a3322194a438ce5e6c3baf981.ed56fb50.png",o=s.p+"static/image/853c9faad9a05eae3fde45a816e62e74.ab8dd33a.png",x=s.p+"static/image/6faaf38ea7c572eeae1da300b87e3c80.00169074.png";function b(e){let n=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",h2:"h2",ul:"ul",li:"li",code:"code",img:"img",pre:"pre",strong:"strong",h4:"h4"},(0,r.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"4babel-的-api",children:["4.Babel 的 API",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4babel-的-api",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"学习了 babel 的编译流程和 AST 之后，我们就大概知道了 babel 做了什么。但还要学习下 babel 的 api，然后通过这些 api 来操作 AST，完成代码的转换。"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"注意，我们学习的 api 是 babel 7.x 的，babel 6 的 api 还没有按照 scope 来划分，也就是 babel-parser 这种，而 babel 7 变成了@babel/parser 这种。对应的插件也是从 babel-plugin-xxx 变成了 @babel/plugin-xxx。但只是包名变了，api 没啥大的变动，我们学的是一些原理性的东西，这些东西在版本迭代中是不会变的。"}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"babel-的-api-有哪些",children:["babel 的 api 有哪些",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babel-的-api-有哪些",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"我们知道 babel 的编译流程分为三步：parse、transform、generate，每一步都暴露了一些 api 出来。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["parse 阶段有",(0,a.jsx)(n.code,{children:"@babel/parser"}),"，功能是把源码转成 AST"]}),"\n",(0,a.jsxs)(n.li,{children:["transform 阶段有 ",(0,a.jsx)(n.code,{children:"@babel/traverse"}),"，可以遍历 AST，并调用 visitor 函数修改 AST，修改 AST 自然涉及到 AST 的判断、创建、修改等，这时候就需要 ",(0,a.jsx)(n.code,{children:"@babel/types"})," 了，当需要批量创建 AST 的时候可以使用  ",(0,a.jsx)(n.code,{children:"@babel/template"})," 来简化 AST 创建逻辑。"]}),"\n",(0,a.jsxs)(n.li,{children:["generate 阶段会把 AST 打印为目标代码字符串，同时生成 sourcemap，需要 ",(0,a.jsx)(n.code,{children:"@babel/generator"})," 包"]}),"\n",(0,a.jsxs)(n.li,{children:["中途遇到错误想打印代码位置的时候，使用 ",(0,a.jsx)(n.code,{children:"@babel/code-frame"})," 包"]}),"\n",(0,a.jsxs)(n.li,{children:["babel 的整体功能通过 ",(0,a.jsx)(n.code,{children:"@babel/core"})," 提供，基于上面的包完成 babel 整体的编译流程，并应用 plugin 和 preset。"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["我们主要学习的就是 ",(0,a.jsx)(n.code,{children:"@babel/parser"}),"，",(0,a.jsx)(n.code,{children:"@babel/traverse"}),"，",(0,a.jsx)(n.code,{children:"@babel/generator"}),"，",(0,a.jsx)(n.code,{children:"@babel/types"}),"，",(0,a.jsx)(n.code,{children:"@babel/template"})," 这五个包的 api 的使用。"]}),"\n",(0,a.jsxs)(n.p,{children:["这些包的 api 都可以在",(0,a.jsx)(n.a,{href:"https://www.babeljs.cn/docs/babel-parser",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"里查看："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"为了方便理解这里也分别介绍一下。"}),"\n",(0,a.jsxs)(n.h2,{id:"babelparser",children:["@babel/parser",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babelparser",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"babel parser 叫 babylon，是基于 acorn 实现的，扩展了很多语法，可以支持 es next（现在支持到 es2020）、jsx、flow、typescript 等语法的解析。"}),"\n",(0,a.jsx)(n.p,{children:"babel parser 默认只能 parse js 代码，jsx、flow、typescript 这些非标准的语法的解析需要指定语法插件。"}),"\n",(0,a.jsx)(n.p,{children:"它提供了有两个 api：parse 和 parseExpression。两者都是把源码转成 AST，不过 parse 返回的 AST 根节点是 File（整个 AST），parseExpression 返回的 AST 根节点是是 Expression（表达式的 AST），粒度不同。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"function parse(input: string, options?: ParserOptions): File\nfunction parseExpression(input: string, options?: ParserOptions): Expression\n"})}),"\n",(0,a.jsxs)(n.p,{children:["详细的 options 可以查看",(0,a.jsx)(n.a,{href:"https://babeljs.io/docs/en/babel-parser#options",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"。其实主要分为两类，一是 parse 的内容是什么，二是以什么方式去 parse"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"parse 的内容是什么："})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"plugins"}),"： 指定jsx、typescript、flow 等插件来解析对应的语法"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"allowXxx"}),"： 指定一些语法是否允许，比如函数外的 await、没声明的 export等"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"sourceType"}),"： 指定是否支持解析模块语法，有 module、script、unambiguous 3个取值：","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"module：解析 es module 语法"}),"\n",(0,a.jsx)(n.li,{children:"script：不解析 es module 语法"}),"\n",(0,a.jsx)(n.li,{children:"unambiguous：根据内容是否有 import 和 export 来自动设置 module 还是 script"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"一般我们会指定 sourceType 为 unambiguous。"}),"\n",(0,a.jsx)(n.p,{children:"比如："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const  parser = require('@babel/parser');\n\nconst ast = parser.parse(\"代码\", {\n    sourceType: 'unambiguous',\n    plugins: ['jsx']\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"以什么方式 parse"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"strictMode"})," 是否是严格模式"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"startLine"})," 从源码哪一行开始 parse"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"errorRecovery"})," 出错时是否记录错误并继续往下 parse"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tokens"})," parse 的时候是否保留 token 信息"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ranges"})," 是否在 ast 节点中添加 ranges 属性"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["用 ",(0,a.jsx)(n.a,{href:"https://astexplorer.net/#/gist/3af72fdd39c4950fd8afbcd488a18f7f/9fef2ce1da52b1698ded918e0c29eb7a1591a05f",target:"_blank",rel:"noopener noreferrer",children:"astexplorer.net"})," 来查看 AST 的时候，也同样支持 parser options 的设置："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsxs)(n.h2,{id:"babeltraverse",children:["@babel/traverse",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babeltraverse",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["parse 出的 AST 由 ",(0,a.jsx)(n.code,{children:"@babel/traverse"})," 来遍历和修改，babel traverse 包提供了 traverse 方法："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function traverse(parent, opts)\n"})}),"\n",(0,a.jsx)(n.p,{children:"常用的就前面两个参数，parent 指定要遍历的 AST 节点，opts 指定 visitor 函数。babel 会在遍历 parent 对应的 AST 时调用相应的 visitor 函数。"}),"\n",(0,a.jsxs)(n.h4,{id:"遍历过程",children:["遍历过程",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历过程",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"visitor 是指定对什么 AST 做什么处理的函数，babel 会在遍历到对应的 AST 时回调它们。"}),"\n",(0,a.jsx)(n.p,{children:"而且可以指定刚开始遍历（enter）和遍历结束后（exit）两个阶段的回调函数，"}),"\n",(0,a.jsx)(n.p,{children:"比如："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"traverse(ast, {\n  FunctionDeclaration: {\n      enter(path, state) {}, // 进入节点时调用\n      exit(path, state) {} // 离开节点时调用\n  }\n})\n"})}),"\n",(0,a.jsx)(n.p,{children:"如果只指定了一个函数，那就是 enter 阶段会调用的："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"traverse(ast, {\n  FunctionDeclaration(path, state) {} // 进入节点时调用\n})\n"})}),"\n",(0,a.jsx)(n.p,{children:"enter 时调用是在遍历当前节点的子节点前调用，exit 时调用是遍历完当前节点的子节点后调用。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"而且同一个 visitor 函数可以用于多个 AST 节点的处理，方式是指定一系列 AST，用 | 连接："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 进入 FunctionDeclaration 和 VariableDeclaration 节点时调用\ntraverse(ast, {\n  'FunctionDeclaration|VariableDeclaration'(path, state) {}\n})\n"})}),"\n",(0,a.jsx)(n.p,{children:"此外，AST 还有别名的，比如各种 XxxStatement 有个 Statement 的别名，各种 XxxDeclaration 有个 Declaration 的别名，那自然可以通过别名来指定对这些 AST 的处理："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 通过别名指定离开各种 Declaration 节点时调用\ntraverse(ast, {\n  Declaration: {\n      exit(path, state) {}\n  }\n})\n"})}),"\n",(0,a.jsxs)(n.p,{children:["具体的别名有哪些在",(0,a.jsx)(n.a,{href:"https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts#L2059",target:"_blank",rel:"noopener noreferrer",children:"babel-types 的类型定义"}),"可以查。"]}),"\n",(0,a.jsx)(n.p,{children:"当然，babel 文档里也有："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://www.babeljs.cn/docs/babel-types#aliases",target:"_blank",rel:"noopener noreferrer",children:(0,a.jsx)(n.a,{href:"https://www.babeljs.cn/docs/babel-types#aliases",target:"_blank",rel:"noopener noreferrer",children:"https://www.babeljs.cn/docs/babel-types#aliases"})})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"每个 visitor 都有 path 和 state 的参数，这些是干啥的呢？"}),"\n",(0,a.jsxs)(n.h4,{id:"path",children:["path",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#path",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"AST 是棵树，遍历过程中肯定是有个路径的，path 就记录了这个路径："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"如图，节点 1、节点 2、节点 3 是三层 AST，通过两个 path 关联了起来，"}),"\n",(0,a.jsx)(n.p,{children:"path1 就关联了节点 1 和 节点 2，记录了节点 1 是父节点，节点 2 是子节点。"}),"\n",(0,a.jsx)(n.p,{children:"path2 关联了节点 2 和节点 3，记录了节点 2 是父节点，节点 3 是子节点。"}),"\n",(0,a.jsx)(n.p,{children:"而且 path1 和 path2 还有父子关系。"}),"\n",(0,a.jsx)(n.p,{children:"通过这样的 path 对象，那不就把遍历的路径串联起来了么。"}),"\n",(0,a.jsx)(n.p,{children:"而且，最重要的是 path 有很多属性和方法，比如记录父子、兄弟等关系的："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"path.node 指向当前 AST 节点"}),"\n",(0,a.jsx)(n.li,{children:"path.parent 指向父级 AST 节点"}),"\n",(0,a.jsx)(n.li,{children:"path.getSibling、path.getNextSibling、path.getPrevSibling 获取兄弟节点"}),"\n",(0,a.jsx)(n.li,{children:"path.find 从当前节点向上查找节点"}),"\n",(0,a.jsx)(n.li,{children:"path.get、path.set 获取 / 设置属性的 path"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"还有作用域相关的："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"path.scope 获取当前节点的作用域信息"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"判断 AST 类型的："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"path.isXxx 判断当前节点是不是 xx 类型"}),"\n",(0,a.jsx)(n.li,{children:"path.assertXxx 判断当前节点是不是 xx 类型，不是则抛出异常"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"增删改 AST 的："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"path.insertBefore、path.insertAfter 插入节点"}),"\n",(0,a.jsx)(n.li,{children:"path.replaceWith、path.replaceWithMultiple、replaceWithSourceString 替换节点"}),"\n",(0,a.jsx)(n.li,{children:"path.remove 删除节点"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"跳过遍历的："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"path.skip 跳过当前节点的子节点的遍历"}),"\n",(0,a.jsx)(n.li,{children:"path.stop 结束后续遍历"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"可以增删改 AST，可以按照路径查找任意的节点，还有作用域的信息，那怎么转换和分析代码不就呼之欲出了么。"}),"\n",(0,a.jsx)(n.p,{children:"确实，path 的 api 是学习 babel 插件最核心的。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"上面罗列了一些常用的 api，可以通过这些 api 完成对 AST 的操作。当然，path 的 api 不是只有这些，后面实战案例用到了再介绍。"}),"\n",(0,a.jsxs)(n.h4,{id:"state",children:["state",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#state",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"第二个参数 state 则是遍历过程中在不同节点之间传递数据的机制，插件会通过 state 传递 options 和 file 信息，我们也可以通过 state 存储一些遍历过程中的共享数据。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"这个很容易理解，节点之间是有传输数据的需求的。不同状态下可能会做不同的处理，这就是为什么这个参数叫做 state。"}),"\n",(0,a.jsxs)(n.h2,{id:"babeltypes",children:["@babel/types",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babeltypes",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["遍历 AST 的过程中需要创建一些 AST 和判断 AST 的类型，这时候就需要 ",(0,a.jsx)(n.code,{children:"@babel/types"})," 包。"]}),"\n",(0,a.jsx)(n.p,{children:"举例来说，如果要创建IfStatement就可以调用"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"t.ifStatement(test, consequent, alternate);\n"})}),"\n",(0,a.jsx)(n.p,{children:"而判断节点是否是 IfStatement 就可以调用 isIfStatement 或者 assertIfStatement"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"t.isIfStatement(node, opts);\nt.assertIfStatement(node, opts);\n"})}),"\n",(0,a.jsx)(n.p,{children:"opts 可以指定一些属性是什么值，增加更多限制条件，做更精确的判断。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'t.isIdentifier(node, { name: "paths" })\n'})}),"\n",(0,a.jsx)(n.p,{children:"isXxx 和 assertXxx 看起来很像，但是功能不大一样：isXxx 会返回 boolean，而 assertXxx 则会在类型不一致时抛异常。"}),"\n",(0,a.jsxs)(n.p,{children:["所有的 AST 的 build、assert 的 api 可以在 ",(0,a.jsx)(n.a,{href:"https://babeljs.io/docs/en/babel-types#api",target:"_blank",rel:"noopener noreferrer",children:"babel types 文档"}),"中查。"]}),"\n",(0,a.jsxs)(n.h2,{id:"babeltemplate",children:["@babel/template",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babeltemplate",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["通过 @babel/types 创建 AST 还是比较麻烦的，要一个个的创建然后组装，如果 AST 节点比较多的话需要写很多代码，这时候就可以使用 ",(0,a.jsx)(n.code,{children:"@babel/template"})," 包来批量创建。"]}),"\n",(0,a.jsx)(n.p,{children:"这个包有这些 api："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const ast = template(code, [opts])(args);\nconst ast = template.ast(code, [opts]);\nconst ast = template.program(code, [opts]);\n"})}),"\n",(0,a.jsx)(n.p,{children:"这些都是传入一段字符串，返回创建好的 AST，区别只是返回的 AST 粒度不大一样："}),"\n",(0,a.jsx)(n.p,{children:"template.ast 返回的是整个 AST。"}),"\n",(0,a.jsx)(n.p,{children:"template.program 返回的是 Program 根节点。"}),"\n",(0,a.jsx)(n.p,{children:"template.expression 返回创建的 expression 的 AST。"}),"\n",(0,a.jsx)(n.p,{children:"template.statements 返回创建的 statems 数组的 AST。"}),"\n",(0,a.jsx)(n.p,{children:"可能有的同学会说，都是创建 AST，搞这么多 api。"}),"\n",(0,a.jsxs)(n.p,{children:["还是有意义的，比如上节说表达式作为语句执行的时候，",(0,a.jsx)(n.a,{href:"https://astexplorer.net/#/gist/3af72fdd39c4950fd8afbcd488a18f7f/9fef2ce1da52b1698ded918e0c29eb7a1591a05f",target:"_blank",rel:"noopener noreferrer",children:"AST 会有一层 ExpressionStatement 么"}),"："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"所以用 template.ast 创建的 Expression 会被包裹一层 ExpressionStatement 节点，而 template.expression 方法创建的 AST 就不会。"}),"\n",(0,a.jsx)(n.p,{children:"所以，当你明确知道了创建的 AST 的类型的话，用更细粒度的 api 会方便一些。"}),"\n",(0,a.jsx)(n.p,{children:"模版也支持占位符，可以在模版里设置一些占位符，调用时再传入这些占位符参数对应的 AST 节点。"}),"\n",(0,a.jsx)(n.p,{children:"比如："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const fn = template(`console.log(NAME)`);\n\nconst ast = fn({\n  NAME: t.stringLiteral("guang"),\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:"或者"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const fn = template(`console.log(%%NAME%%)`);\n\nconst ast = fn({\n  NAME: t.stringLiteral("guang"),\n});\n'})}),"\n",(0,a.jsx)(n.p,{children:"这样就是通过模版来批量创建 AST，但是其中的占位符是用传入的 AST。"}),"\n",(0,a.jsx)(n.p,{children:"加不加 %% 都行，当占位符和其他变量名冲突时可以加上。"}),"\n",(0,a.jsxs)(n.h2,{id:"babelgenerator",children:["@babel/generator",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babelgenerator",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["AST 转换完之后就要打印成目标代码字符串，通过 ",(0,a.jsx)(n.code,{children:"@babel/generator"})," 包的 generate api"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function (ast: Object, opts: Object, code: string): {code, map} \n"})}),"\n",(0,a.jsx)(n.p,{children:"第一个参数是要打印的 AST。"}),"\n",(0,a.jsx)(n.p,{children:"第二个参数是 options，指定打印的一些细节，比如通过 comments 指定是否包含注释，通过 minified 指定是否包含空白字符。"}),"\n",(0,a.jsxs)(n.p,{children:["第三个参数当多个文件合并打印的时候需要用到，这部分直接看",(0,a.jsx)(n.a,{href:"https://babeljs.io/docs/en/babel-generator",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"即可，基本用不到。"]}),"\n",(0,a.jsx)(n.p,{children:"options 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'import generate from "@babel/generator";\n\nconst { code, map } = generate(ast, { sourceMaps: true })\n'})}),"\n",(0,a.jsxs)(n.h2,{id:"babelcode-frame",children:["@babel/code-frame",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babelcode-frame",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"babel 的报错一半都会直接打印错误位置的代码，而且还能高亮，"}),"\n",(0,a.jsxs)(n.p,{children:["我们打印错误信息的时候也可以用，就是 ",(0,a.jsx)(n.code,{children:"@babel/code-frame"})," 这个包。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const result = codeFrameColumns(rawLines, location, {\n  /* options */\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"options 可以设置 highlighted （是否高亮）、message（展示啥错误信息）。"}),"\n",(0,a.jsx)(n.p,{children:"比如"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const { codeFrameColumns } = require("@babel/code-frame");\n\ntry {\n throw new Error("xxx 错误");\n} catch (err) {\n  console.error(codeFrameColumns(`const name = guang`, {\n      start: { line: 1, column: 14 }\n  }, {\n    highlightCode: true,\n    message: err.message\n  }));\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"打印的错误就是这样的："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"在控制台展示这样的错误，是不是比直接打印个错误堆栈好很多呀～"}),"\n",(0,a.jsx)(n.p,{children:"这种控制台打印代码格式的功能就叫做 code frame。"}),"\n",(0,a.jsxs)(n.h2,{id:"babelcore",children:["@babel/core",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babelcore",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"前面讲了 @babel/parser、@babel/traverse、@babel/generaotr、@babel/types、@babel/template 等包，babel 的功能就是通过这些包来实现的。"}),"\n",(0,a.jsx)(n.p,{children:"babel 基于这些包来实现编译、插件、预设等功能的包就是 @babel/core。"}),"\n",(0,a.jsx)(n.p,{children:"这个包的功能就是完成整个编译流程，从源码到目标代码，生成 sourcemap。实现 plugin 和 preset 的调用。"}),"\n",(0,a.jsx)(n.p,{children:"api 也有好几个："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"transformSync(code, options); // => { code, map, ast }\n\ntransformFileSync(filename, options); // => { code, map, ast }\n\ntransformFromAstSync(\n  parsedAst,\n  sourceCode,\n  options\n); // => { code, map, ast }\n"})}),"\n",(0,a.jsx)(n.p,{children:"比如这三个 transformXxx 的 api 分别是从源代码、源代码文件、源代码 AST 开始处理，最终生成目标代码和 sourcemap。"}),"\n",(0,a.jsx)(n.p,{children:"options 主要配置 plugins 和 presets，指定具体要做什么转换。"}),"\n",(0,a.jsx)(n.p,{children:"这些 api 也同样提供了异步的版本，异步地进行编译，返回一个 promise"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'transformAsync("code();", options).then(result => {})\ntransformFileAsync("filename.js", options).then(result => {})\ntransformFromAstAsync(parsedAst, sourceCode, options).then(result => {})\n'})}),"\n",(0,a.jsx)(n.p,{children:"注意：不带 sync、async 的 api 已经被标记过时了，也就是 transformXxx 这些，后续会删掉，不建议用，直接用 transformXxxSync 和 transformXxxAsync。也就是明确是同步还是异步。"}),"\n",(0,a.jsx)(n.p,{children:"@babel/core 支持 plugin 和 preset，一般我们配置的都是对象的格式，其实也有一个 api 来创建，也就是 createConfigItem："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"createConfigItem(value, options) // configItem\n"})}),"\n",(0,a.jsx)(n.p,{children:"不过用和不用的没啥区别，常用的还是直接写配置对象。"}),"\n",(0,a.jsx)(n.p,{children:"除了这些包之外，也可以安装 @types/babel__xx 的包来增加 ts 的提示，比如 @types/babel__parser、@types/babel__traverse 等。"}),"\n",(0,a.jsx)(n.p,{children:"或者通过 debugger 的方式跑，也可以看到有啥 api 可用。"}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"这一节我们了解了编译过程中各阶段的 api："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@babel/parser"})," 对源码进行 parse，可以通过 plugins、sourceType 等来指定 parse 语法"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@babel/traverse"})," 通过 visitor 函数对遍历到的 ast 进行处理，分为 enter 和 exit 两个阶段，具体操作 AST 使用 path 的 api，还可以通过 state 来在遍历过程中传递一些数据"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@babel/types"})," 用于创建、判断 AST 节点，提供了 xxx、isXxx、assertXxx 的 api"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@babel/template"})," 用于批量创建节点"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@babel/code-frame"})," 可以创建友好的报错信息"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@babel/generator"})," 打印 AST 成目标代码字符串，支持 comments、minified、sourceMaps 等选项。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"@babel/core"})," 基于上面的包来完成 babel 的编译流程，可以从源码字符串、源码文件、AST 开始。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"学完这一节，我们可以用 babel 的 api 来实现一些功能了，下一节开始第一个实战案例。"})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(b,{...e})}):b(e)}let m=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F4.Babel%20%E7%9A%84%20API.md"]={toc:[{text:"babel 的 api 有哪些",id:"babel-的-api-有哪些",depth:2},{text:"@babel/parser",id:"babelparser",depth:2},{text:"@babel/traverse",id:"babeltraverse",depth:2},{text:"遍历过程",id:"遍历过程",depth:4},{text:"path",id:"path",depth:4},{text:"state",id:"state",depth:4},{text:"@babel/types",id:"babeltypes",depth:2},{text:"@babel/template",id:"babeltemplate",depth:2},{text:"@babel/generator",id:"babelgenerator",depth:2},{text:"@babel/code-frame",id:"babelcode-frame",depth:2},{text:"@babel/core",id:"babelcore",depth:2},{text:"总结",id:"总结",depth:2}],title:"4.Babel 的 API",headingTitle:"4.Babel 的 API",frontmatter:{}}}}]);