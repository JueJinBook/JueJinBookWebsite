"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["72819"],{371445:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var r=s(552676),c=s(740453);function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ul:"ul",li:"li",pre:"pre",ol:"ol"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"7手写-promise",children:["7.手写 Promise",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7手写-promise",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在上一章节中我们了解了 ",(0,r.jsx)(n.code,{children:"Promise"})," 的一些易错点，在这一章节中，我们会通过手写一个符合 Promise/A+ 规范的 ",(0,r.jsx)(n.code,{children:"Promise"})," 来深入理解它，并且手写 ",(0,r.jsx)(n.code,{children:"Promise"})," 也是一道大厂常考题，在进入正题之前，推荐各位阅读一下 ",(0,r.jsx)(n.a,{href:"http://www.ituring.com.cn/article/66566",target:"_blank",rel:"noopener noreferrer",children:"Promise/A+ 规范"}),"，这样才能更好地理解这个章节的代码。"]}),"\n",(0,r.jsxs)(n.h2,{id:"更新日志",children:["更新日志",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新日志",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["利用 ",(0,r.jsx)(n.code,{children:"queueMicrotask"})," 替换 ",(0,r.jsx)(n.code,{children:"setTimeout"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"实现一个简易版-promise",children:["实现一个简易版 Promise",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现一个简易版-promise",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在完成符合 Promise/A+ 规范的代码之前，我们可以先来实现一个简易版 ",(0,r.jsx)(n.code,{children:"Promise"}),"，因为在面试中，如果你能实现出一个简易版的 ",(0,r.jsx)(n.code,{children:"Promise"})," 基本可以过关了。"]}),"\n",(0,r.jsx)(n.p,{children:"那么我们先来搭建构建函数的大体框架"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const PENDING = 'pending'\nconst RESOLVED = 'resolved'\nconst REJECTED = 'rejected'\n\nfunction MyPromise(fn) {\n  const that = this\n  that.state = PENDING\n  that.value = null\n  that.resolvedCallbacks = []\n  that.rejectedCallbacks = []\n  // 待完善 resolve 和 reject 函数\n  // 待完善执行 fn 函数\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护"}),"\n",(0,r.jsxs)(n.li,{children:["在函数体内部首先创建了常量 ",(0,r.jsx)(n.code,{children:"that"}),"，因为代码可能会异步执行，用于获取正确的 ",(0,r.jsx)(n.code,{children:"this"})," 对象"]}),"\n",(0,r.jsxs)(n.li,{children:["一开始 ",(0,r.jsx)(n.code,{children:"Promise"})," 的状态应该是 ",(0,r.jsx)(n.code,{children:"pending"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"value"})," 变量用于保存 ",(0,r.jsx)(n.code,{children:"resolve"})," 或者 ",(0,r.jsx)(n.code,{children:"reject"})," 中传入的值"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"resolvedCallbacks"})," 和 ",(0,r.jsx)(n.code,{children:"rejectedCallbacks"})," 用于保存 ",(0,r.jsx)(n.code,{children:"then"})," 中的回调，因为当执行完 ",(0,r.jsx)(n.code,{children:"Promise"})," 时状态可能还是等待中，这时候应该把 ",(0,r.jsx)(n.code,{children:"then"})," 中的回调保存起来用于状态改变时使用"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来我们来完善 ",(0,r.jsx)(n.code,{children:"resolve"})," 和 ",(0,r.jsx)(n.code,{children:"reject"})," 函数，添加在 ",(0,r.jsx)(n.code,{children:"MyPromise"})," 函数体内部"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function resolve(value) {\n  if (that.state === PENDING) {\n    that.state = RESOLVED\n    that.value = value\n    that.resolvedCallbacks.map(cb => cb(that.value))\n  }\n}\n\nfunction reject(value) {\n  if (that.state === PENDING) {\n    that.state = REJECTED\n    that.value = value\n    that.rejectedCallbacks.map(cb => cb(that.value))\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"这两个函数代码类似，就一起解析了"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态"}),"\n",(0,r.jsxs)(n.li,{children:["将当前状态更改为对应状态，并且将传入的值赋值给 ",(0,r.jsx)(n.code,{children:"value"})]}),"\n",(0,r.jsx)(n.li,{children:"遍历回调数组并执行"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["完成以上两个函数以后，我们就该实现如何执行 ",(0,r.jsx)(n.code,{children:"Promise"})," 中传入的函数了"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"try {\n  fn(resolve, reject)\n} catch (e) {\n  reject(e)\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"实现很简单，执行传入的参数并且将之前两个函数当做参数传进去"}),"\n",(0,r.jsxs)(n.li,{children:["要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 ",(0,r.jsx)(n.code,{children:"reject"})," 函数"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["最后我们来实现较为复杂的 ",(0,r.jsx)(n.code,{children:"then"})," 函数"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"MyPromise.prototype.then = function(onFulfilled, onRejected) {\n  const that = this\n  onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v\n  onRejected =\n    typeof onRejected === 'function'\n      ? onRejected\n      : r => {\n          throw r\n        }\n  if (that.state === PENDING) {\n    that.resolvedCallbacks.push(onFulfilled)\n    that.rejectedCallbacks.push(onRejected)\n  }\n  if (that.state === RESOLVED) {\n    onFulfilled(that.value)\n  }\n  if (that.state === REJECTED) {\n    onRejected(that.value)\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"首先判断两个参数是否为函数类型，因为这两个参数是可选参数"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"当参数不是函数类型时，需要创建一个函数赋值给对应的参数，同时也实现了透传，比如如下代码"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 该代码目前在简单版中会报错\n// 只是作为一个透传的例子\nPromise.resolve(4).then().then((value) => console.log(value))\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 ",(0,r.jsx)(n.code,{children:"push"})," 函数，比如如下代码就会进入等待态的逻辑"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"new MyPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(1)\n  }, 0)\n}).then(value => {\n  console.log(value)\n})\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["以上就是简单版 ",(0,r.jsx)(n.code,{children:"Promise"})," 实现，接下来一小节是实现完整版 ",(0,r.jsx)(n.code,{children:"Promise"})," 的解析，相信看完完整版的你，一定会对于 ",(0,r.jsx)(n.code,{children:"Promise"})," 的理解更上一层楼。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实现一个符合-promisea-规范的-promise",children:["实现一个符合 Promise/A+ 规范的 Promise",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现一个符合-promisea-规范的-promise",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这小节代码需要大家配合规范阅读，因为大部分代码都是根据规范去实现的。"}),"\n",(0,r.jsxs)(n.p,{children:["我们先来改造一下 ",(0,r.jsx)(n.code,{children:"resolve"})," 和 ",(0,r.jsx)(n.code,{children:"reject"})," 函数"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function resolve(value) {\n  if (value instanceof MyPromise) {\n    return value.then(resolve, reject)\n  }\n  // 以往都用 setTimeout 模拟，但是只能触发宏任务\n  // 目前浏览器支持 queueMicrotask，该函数可以触发微任务\n  queueMicrotask(() => {\n    if (that.state === PENDING) {\n      that.state = RESOLVED\n      that.value = value\n      that.resolvedCallbacks.map(cb => cb(that.value))\n    }\n  })\n}\nfunction reject(value) {\n  queueMicrotask(() => {\n    if (that.state === PENDING) {\n      that.state = REJECTED\n      that.value = value\n      that.rejectedCallbacks.map(cb => cb(that.value))\n    }\n  })\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["对于 ",(0,r.jsx)(n.code,{children:"resolve"})," 函数来说，首先需要判断传入的值是否为 ",(0,r.jsx)(n.code,{children:"Promise"})," 类型"]}),"\n",(0,r.jsxs)(n.li,{children:["为了保证函数执行顺序，需要将两个函数体代码使用 ",(0,r.jsx)(n.code,{children:"queueMicrotask"})," 包裹起来"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来继续改造 ",(0,r.jsx)(n.code,{children:"then"})," 函数中的代码，首先我们需要新增一个变量 ",(0,r.jsx)(n.code,{children:"promise2"}),"，因为每个 ",(0,r.jsx)(n.code,{children:"then"})," 函数都需要返回一个新的 ",(0,r.jsx)(n.code,{children:"Promise"})," 对象，该变量用于保存新的返回对象，然后我们先来改造判断等待态的逻辑"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"if (that.state === PENDING) {\n  return (promise2 = new MyPromise((resolve, reject) => {\n    that.resolvedCallbacks.push(() => {\n      try {\n        const x = onFulfilled(that.value)\n        resolutionProcedure(promise2, x, resolve, reject)\n      } catch (r) {\n        reject(r)\n      }\n    })\n\n    that.rejectedCallbacks.push(() => {\n      try {\n        const x = onRejected(that.value)\n        resolutionProcedure(promise2, x, resolve, reject)\n      } catch (r) {\n        reject(r)\n      }\n    })\n  }))\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["首先我们返回了一个新的 ",(0,r.jsx)(n.code,{children:"Promise"})," 对象，并在 ",(0,r.jsx)(n.code,{children:"Promise"})," 中传入了一个函数"]}),"\n",(0,r.jsxs)(n.li,{children:["函数的基本逻辑还是和之前一样，往回调数组中 ",(0,r.jsx)(n.code,{children:"push"})," 函数"]}),"\n",(0,r.jsxs)(n.li,{children:["同样，在执行函数的过程中可能会遇到错误，所以使用了 ",(0,r.jsx)(n.code,{children:"try...catch"})," 包裹"]}),"\n",(0,r.jsxs)(n.li,{children:["规范规定，执行 ",(0,r.jsx)(n.code,{children:"onFulfilled"})," 或者 ",(0,r.jsx)(n.code,{children:"onRejected"})," 函数时会返回一个 ",(0,r.jsx)(n.code,{children:"x"}),"，并且执行 ",(0,r.jsx)(n.code,{children:"Promise"})," 解决过程，这是为了不同的 ",(0,r.jsx)(n.code,{children:"Promise"})," 都可以兼容使用，比如 JQuery 的 ",(0,r.jsx)(n.code,{children:"Promise"})," 能兼容 ES6 的 ",(0,r.jsx)(n.code,{children:"Promise"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"接下来我们改造判断执行态的逻辑"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"if (that.state === RESOLVED) {\n  return (promise2 = new MyPromise((resolve, reject) => {\n    queueMicrotask(() => {\n      try {\n        const x = onFulfilled(that.value)\n        resolutionProcedure(promise2, x, resolve, reject)\n      } catch (reason) {\n        reject(reason)\n      }\n    })\n  }))\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"其实大家可以发现这段代码和判断等待态的逻辑基本一致，无非是传入的函数的函数体需要异步执行，这也是规范规定的"}),"\n",(0,r.jsx)(n.li,{children:"对于判断拒绝态的逻辑这里就不一一赘述了，留给大家自己完成这个作业"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["最后，当然也是最难的一部分，也就是实现兼容多种 ",(0,r.jsx)(n.code,{children:"Promise"})," 的 ",(0,r.jsx)(n.code,{children:"resolutionProcedure"})," 函数"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function resolutionProcedure(promise2, x, resolve, reject) {\n  if (promise2 === x) {\n    return reject(new TypeError('Error'))\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["首先规范规定了 ",(0,r.jsx)(n.code,{children:"x"})," 不能与 ",(0,r.jsx)(n.code,{children:"promise2"})," 相等，这样会发生循环引用的问题，比如如下代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"let p = new MyPromise((resolve, reject) => {\n  resolve(1)\n})\nlet p1 = p.then(value => {\n  return p1\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后需要判断 ",(0,r.jsx)(n.code,{children:"x"})," 的类型"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"if (x instanceof MyPromise) {\n    x.then(function(value) {\n        resolutionProcedure(promise2, value, resolve, reject)\n    }, reject)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里的代码是完全按照规范实现的。如果 ",(0,r.jsx)(n.code,{children:"x"})," 为 ",(0,r.jsx)(n.code,{children:"Promise"})," 的话，需要判断以下几个情况："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["如果 ",(0,r.jsx)(n.code,{children:"x"})," 处于等待态，",(0,r.jsx)(n.code,{children:"Promise"})," 需保持为等待态直至 ",(0,r.jsx)(n.code,{children:"x"})," 被执行或拒绝"]}),"\n",(0,r.jsxs)(n.li,{children:["如果 ",(0,r.jsx)(n.code,{children:"x"})," 处于其他状态，则用相同的值处理 ",(0,r.jsx)(n.code,{children:"Promise"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"当然以上这些是规范需要我们判断的情况，实际上我们不判断状态也是可行的。"}),"\n",(0,r.jsx)(n.p,{children:"接下来我们继续按照规范来实现剩余的代码"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"let called = false\nif (x !== null && (typeof x === 'object' || typeof x === 'function')) {\n  try {\n    let then = x.then\n    if (typeof then === 'function') {\n      then.call(\n        x,\n        y => {\n          if (called) return\n          called = true\n          resolutionProcedure(promise2, y, resolve, reject)\n        },\n        e => {\n          if (called) return\n          called = true\n          reject(e)\n        }\n      )\n    } else {\n      resolve(x)\n    }\n  } catch (e) {\n    if (called) return\n    called = true\n    reject(e)\n  }\n} else {\n  resolve(x)\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["首先创建一个变量 ",(0,r.jsx)(n.code,{children:"called"})," 用于判断是否已经调用过函数"]}),"\n",(0,r.jsxs)(n.li,{children:["然后判断 ",(0,r.jsx)(n.code,{children:"x"})," 是否为对象或者函数，如果都不是的话，将 ",(0,r.jsx)(n.code,{children:"x"})," 传入 ",(0,r.jsx)(n.code,{children:"resolve"})," 中"]}),"\n",(0,r.jsxs)(n.li,{children:["如果 ",(0,r.jsx)(n.code,{children:"x"})," 是对象或者函数的话，先把 ",(0,r.jsx)(n.code,{children:"x.then"})," 赋值给 ",(0,r.jsx)(n.code,{children:"then"}),"，然后判断 ",(0,r.jsx)(n.code,{children:"then"})," 的类型，如果不是函数类型的话，就将 ",(0,r.jsx)(n.code,{children:"x"})," 传入 ",(0,r.jsx)(n.code,{children:"resolve"})," 中"]}),"\n",(0,r.jsxs)(n.li,{children:["如果 ",(0,r.jsx)(n.code,{children:"then"})," 是函数类型的话，就将 ",(0,r.jsx)(n.code,{children:"x"})," 作为函数的作用域 ",(0,r.jsx)(n.code,{children:"this"})," 调用之，并且传递两个回调函数作为参数，第一个参数叫做 ",(0,r.jsx)(n.code,{children:"resolvePromise"})," ，第二个参数叫做 ",(0,r.jsx)(n.code,{children:"rejectPromise"}),"，两个回调函数都需要判断是否已经执行过函数，然后进行相应的逻辑"]}),"\n",(0,r.jsxs)(n.li,{children:["以上代码在执行的过程中如果抛错了，将错误传入 ",(0,r.jsx)(n.code,{children:"reject"})," 函数中"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"以上就是符合 Promise/A+ 规范的实现了，如果你对于这部分代码尚有疑问，欢迎在评论中与我互动。"}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这一章节我们分别实现了简单版和符合 Promise/A+ 规范的 ",(0,r.jsx)(n.code,{children:"Promise"}),"，前者已经足够应付大部分面试的手写题目，毕竟写出一个符合规范的 ",(0,r.jsx)(n.code,{children:"Promise"})," 在面试中不大现实。后者能让你更加深入地理解 ",(0,r.jsx)(n.code,{children:"Promise"})," 的运行原理，做技术的深挖者。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}let d=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F7.%E6%89%8B%E5%86%99%20Promise.md"]={toc:[{text:"更新日志",id:"更新日志",depth:2},{text:"实现一个简易版 Promise",id:"实现一个简易版-promise",depth:2},{text:"实现一个符合 Promise/A+ 规范的 Promise",id:"实现一个符合-promisea-规范的-promise",depth:2},{text:"小结",id:"小结",depth:2}],title:"7.手写 Promise",headingTitle:"7.手写 Promise",frontmatter:{}}}}]);