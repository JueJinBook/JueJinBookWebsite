"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58866"],{549312:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var r=s(552676),d=s(740453);let c=s.p+"static/image/96f8756312703bfc098d97cfacc65c45.928b6b69.webp",i=s.p+"static/image/2f38d0c38fe93994a0bbd507237f435c.beb24d13.webp";function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",img:"img",h3:"h3"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"10-文章生成器如何用-stdin-和-readline-实现命令行交互",children:["10 文章生成器：如何用 stdin 和 readline 实现命令行交互？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-文章生成器如何用-stdin-和-readline-实现命令行交互",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上一节课，我们介绍了两种读取命令行参数的方式：",(0,r.jsx)(n.code,{children:"process.argv"}),"和第三方库",(0,r.jsx)(n.code,{children:"command-line-args"}),"。这一节课，为了让程序可以和用户交互，我们将学习两种命令行交互的方式：",(0,r.jsx)(n.code,{children:"process.stdin"}),"和",(0,r.jsx)(n.code,{children:"readline"}),"模块。"]}),"\n",(0,r.jsxs)(n.h2,{id:"用户的输入与监听",children:["用户的输入与监听",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用户的输入与监听",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在命令行运行时，通过 process 模块的 stdin 对象可以获取用户输入。stdin 是一个异步模块，它通过监听输入时间并执行回调来处理用户输入，因此它的使用方式和之前那些模块有些区别。我们先通过一个简单的例子体会下它的用法。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"console.log('请输入一个要求和的整数，以0结束输入');\n\nprocess.stdin.setEncoding('utf8');\n\nlet sum = 0;\nprocess.stdin.on('readable', () => {\n  const chunk = process.stdin.read(); // 获取当前输入的字符，包含回车\n  const n = Number(chunk.slice(0, -1));\n  sum += n;\n  if(n === 0) process.stdin.emit('end');\n  process.stdin.read(); // 再调用一次，返回的是null，并继续监听\n});\n\nprocess.stdin.on('end', () => {\n  console.log(`求和结果是：${sum}`);\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"上面的代码是一个累加求和的交互程序，依次累加用户输入的数值，直到输入 0 为止，然后打印累加的结果。它执行的效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"process.stdin.setEncoding('utf8')"}),"表示将用户交互的编码设定为",(0,r.jsx)(n.code,{children:"utf-8"}),"，如果你要输入中文，这个必须要设置。"]}),"\n",(0,r.jsxs)(n.p,{children:["当用户输入字符串并回车，注册在",(0,r.jsx)(n.code,{children:"process.stdin"}),"对象上的",(0,r.jsx)(n.code,{children:"readable"}),"事件就会被触发。然后，在这个事件回调函数中，我们可以通过",(0,r.jsx)(n.code,{children:"process.stdin.read()"}),"读取用户输入的数字（用户的输入是字符串类型，所以需要对它进行类型转换）。注意，在这个回调函数中，当我们对输入的数字完成加法操作后，我们又调用了一次",(0,r.jsx)(n.code,{children:"process.stdin.read()"}),"方法，这是为什么呢？"]}),"\n",(0,r.jsxs)(n.p,{children:["这是因为",(0,r.jsx)(n.code,{children:"process.stdin.read()"}),"从标准输入流中读取内容，如果有内容，就会把读到的内容返回，如果没有内容，则会返回 null，并继续处于",(0,r.jsx)(n.code,{children:"readable"}),"状态，监听下一次输入。所以如果我们不在",(0,r.jsx)(n.code,{children:"readable"}),"事件回调函数里多调用一次",(0,r.jsx)(n.code,{children:"process.stdin.read()"}),"，它只会将读到的内容返回，不会继续监听下一次输入。"]}),"\n",(0,r.jsxs)(n.p,{children:["第一次读取出来的值是用户输入的字符串和末尾的回车，我们通过",(0,r.jsx)(n.code,{children:"chunk.slice(0, -1)"}),"把最后的回车符抛弃掉，把前面的内容通过",(0,r.jsx)(n.code,{children:"Number"}),"转为数值，就拿到了我们要的输入结果。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果这个数值是 0，我们通过",(0,r.jsx)(n.code,{children:"process.stdin.emit('end')"}),"派发一个结束输入的事件，然后在",(0,r.jsx)(n.code,{children:"process.stdin.on"}),"监听",(0,r.jsx)(n.code,{children:"end"}),"事件中，输出求和结果。",(0,r.jsx)(n.code,{children:"process.stdin"}),"是异步的，它继承",(0,r.jsx)(n.code,{children:"EventEmitter"}),"对象，能够派发和监听事件。关于异步编程和EventEmitter，在后续的课程中会有详细介绍。"]}),"\n",(0,r.jsxs)(n.p,{children:["了解了",(0,r.jsx)(n.code,{children:"process.stdin"}),"的用法之后，我们再用它来实现用户交互过程。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实现文章生成器的交互过程",children:["实现文章生成器的交互过程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现文章生成器的交互过程",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先，我们设计一个问题数据结构："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"[\n  {text: '请输入文章主题', value: title},\n  {text: '请输入最小字数', value: 6000},\n  {text: '请输入最大字数', value: 10000},\n]\n"})}),"\n",(0,r.jsx)(n.p,{children:"它是一个数组，包含了 3 个问题对象，属性 text 是问题的文字描述，value 表示问题的默认值。然后根据问题，我们实现一个 interact.js 的模块，让它接受我们定义好的一系列问题，并等待用户一一回答："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// interact.js\nexport function interact(questions) {\n  // questions 是一个数组，内容如 {text, value}\n  process.stdin.setEncoding('utf8');\n\n  return new Promise((resolve) => {\n    const answers = [];\n    let i = 0;\n    let {text, value} = questions[i++];\n    console.log(`${text}(${value})`);\n    process.stdin.on('readable', () => {\n      const chunk = process.stdin.read().slice(0, -1);\n      answers.push(chunk || value); // 保存用户的输入，如果用户输入为空，则使用缺省值\n      const nextQuestion = questions[i++];\n      if(nextQuestion) { //如果问题还未结束，继续监听用户输入\n        process.stdin.read();\n        text = nextQuestion.text;\n        value = nextQuestion.value;\n        console.log(`${text}(${value})`);\n      } else { // 如果问题结束了，结束readable监听事件\n        resolve(answers);\n      }\n    });\n  });\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如果用户回答了当前问题，还有下一个问题，就等待下一次",(0,r.jsx)(n.code,{children:"readable"}),"事件，否则就",(0,r.jsx)(n.code,{children:"resolve"}),"当前的 promise。"]}),"\n",(0,r.jsxs)(n.p,{children:["\uD83D\uDCA1注意，这里我们采用了和上一个例子不一样的结束监听方式。上一个例子中，我们使用",(0,r.jsx)(n.code,{children:"process.stdin.emit('end')"}),"发送一个结束事件来结束",(0,r.jsx)(n.code,{children:"readable"}),"事件的监听。这里，我们利用异步机制—— Promise 来结束用户输入的监听事件。"]}),"\n",(0,r.jsxs)(n.p,{children:["然后，我们可以在",(0,r.jsx)(n.code,{children:"index.js"}),"中，通过",(0,r.jsx)(n.code,{children:"async/await"}),"方式，等待用户回答所有问题后，再进行文章生成的操作："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const corpus = loadCorpus('corpus/data.json');\nlet title = options.title || createRandomPicker(corpus.title)();\n\n(async function () {\n  if(Object.keys(options).length <= 0) {\n    const answers = await interact([\n      {text: '请输入文章主题', value: title},\n      {text: '请输入最小字数', value: 6000},\n      {text: '请输入最大字数', value: 10000},\n    ]);\n    title = answers[0];\n    options.min = answers[1];\n    options.max = answers[2];\n  }\n\n  const article = generate(title, {corpus, ...options});\n  const output = saveCorpus(title, article);\n\n  console.log(`生成成功！文章保存于：${output}`);\n}());\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样我们就实现了用户互动的方式完成文章生成器。"}),"\n",(0,r.jsxs)(n.h3,{id:"processstdoutwrite",children:["process.stdout.write",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#processstdoutwrite",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["除了",(0,r.jsx)(n.code,{children:"process.stdin.read"}),"之外，对应的还有",(0,r.jsx)(n.code,{children:"process.stdout.write"}),"可以向终端输出字符，不过在这个例子里我们并没有用到。这是因为，",(0,r.jsx)(n.code,{children:"process.stdout.write"}),"在命令行终端里效果基本上和",(0,r.jsx)(n.code,{children:"console.log"}),"一样，区别是",(0,r.jsx)(n.code,{children:"console.log"}),"支持多个参数，且能够格式化字符串并自动输出回车符。也就是说，",(0,r.jsx)(n.code,{children:"console.log"}),"基本上可以替代",(0,r.jsx)(n.code,{children:"process.stdout.write"}),"功能且更强大，所以我们就基本上不需要使用",(0,r.jsx)(n.code,{children:"process.stdout.write"}),"了。"]}),"\n",(0,r.jsxs)(n.p,{children:["不过，如果我们不希望输出回车换行到终端，那还是可以使用",(0,r.jsx)(n.code,{children:"process.stdout.write"}),"的。"]}),"\n",(0,r.jsxs)(n.h2,{id:"使用-readline-模块",children:["使用 readline 模块",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-readline-模块",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["用 process.stdin 实现命令行交互，需要在",(0,r.jsx)(n.code,{children:"readable"}),"事件中多调一次",(0,r.jsx)(n.code,{children:"process.stdin.read()"}),"方法，这看起来似乎很奇怪，代码的可读性不高。幸好，node.js 为我们提供了一个比 process.stdin 更好用的内置模块—— readline，它是专门用来实现可交互命令行的。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们用它来改写一下",(0,r.jsx)(n.code,{children:"interact.js"}),"模块："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import readline from 'readline';\n\nfunction question(rl, {text, value}) {\n  const q = `${text}(${value})\\n`;\n  return new Promise((resolve) => {\n    rl.question(q, (answer) => {\n      resolve(answer || value);\n    });\n  });\n}\n\nexport async function interact(questions) {\n  const rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n  const answers = [];\n  for(let i = 0; i < questions.length; i++) {\n    const q = questions[i];\n    const answer = await question(rl, q); // 等待问题的输入\n    answers.push(answer);\n  }\n  rl.close();\n  return answers;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这段代码中，我们通过",(0,r.jsx)(n.code,{children:"readline.createInterface"}),"创建一个可交互的命令行对象。然后，我们遍历",(0,r.jsx)(n.code,{children:"questions"}),"数组，等待每一个问题的答案，并将答案存放在",(0,r.jsx)(n.code,{children:"answers"}),"数组中",(0,r.jsx)(n.code,{children:"readline.createInterface"}),"返回的对象有一个",(0,r.jsx)(n.code,{children:"question"}),"方法，它是个异步方法，接受一个问题描述和一个回调函数 —— 用于接受用户的输入。"]}),"\n",(0,r.jsx)(n.p,{children:"我们每次输出一个提问并等待用户输入答案，所以将它封装成一个返回 Promise 的异步方法："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function question(rl, {text, value}) {\n  const q = `${text}(${value})\\n`;\n  return new Promise((resolve) => {\n    rl.question(q, (answer) => {\n      resolve(answer || value);\n    });\n  });\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这么写的话，代码量虽然和直接使用",(0,r.jsx)(n.code,{children:"process.stdin"}),"差不多，但可读性要好很多。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这一节课，我们介绍了 process.stdin 和 readline 模块的使用，让我们的文章生成器应用实现了交互式的命令行功能。"}),"\n",(0,r.jsx)(n.p,{children:"process 模块是一个比较常用的内置模块，我们学完了 process 的 argv、stdin 和 stdout 的基本用法。在后续的课程中，我们还会继续用到这些 API，以及 process 模块的其他 API。"}),"\n",(0,r.jsx)(n.p,{children:"readline 模块是用来实现交互式命令行的，对于编写需要在终端与用户交互的 JavaScript 应用有很大帮助，在后续工程化主题里，我们还会使用它来实现一个自动化的项目脚手架。"}),"\n",(0,r.jsxs)(n.p,{children:["至于 process 和 readline 模块的其他内容，如果你有兴趣可以查看 ",(0,r.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v13.x/docs/api",target:"_blank",rel:"noopener noreferrer",children:"Node.js 官方文档"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["到这里为止，我们的文章生成器功能就全部实现了。我们在这个项目使用了",(0,r.jsx)(n.code,{children:"ES Modules"}),"。使用这个新的规范有一个好处，就是我们可以直接在浏览器中加载并使用同样的模块，因为最新的Chrome浏览器已经支持了",(0,r.jsx)(n.code,{children:"ES Modules"}),"规范。"]}),"\n",(0,r.jsx)(n.p,{children:"在下一节课中（加餐部分），我们将暂时偏离一下 Node.js 的主题，来看看如何在浏览器中复用我们写的代码，给这个应用添加一个网页版。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let l=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F10%20%E6%96%87%E7%AB%A0%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%20stdin%20%E5%92%8C%20readline%20%E5%AE%9E%E7%8E%B0%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92%EF%BC%9F.md"]={toc:[{text:"用户的输入与监听",id:"用户的输入与监听",depth:2},{text:"实现文章生成器的交互过程",id:"实现文章生成器的交互过程",depth:2},{text:"process.stdout.write",id:"processstdoutwrite",depth:3},{text:"使用 readline 模块",id:"使用-readline-模块",depth:2},{text:"总结",id:"总结",depth:2}],title:"10 文章生成器：如何用 stdin 和 readline 实现命令行交互？",headingTitle:"10 文章生成器：如何用 stdin 和 readline 实现命令行交互？",frontmatter:{}}}}]);