"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["9134"],{922087:function(e,n,s){s.r(n),s.d(n,{default:()=>A});var r=s(552676),d=s(740453);let c=s.p+"static/image/a983801ba4db0ec0117cf156336a2e82.2c3d50cd.webp",i=s.p+"static/image/aad4bd5a9601038201a7af544d73cc9f.24e9788b.webp",t=s.p+"static/image/3740de4bf3c29c070f48f76e1ef1e5fc.e612626a.webp",o=s.p+"static/image/1025589d7c44403a44ddb0ba37d2d3c5.24e9788b.webp",l=s.p+"static/image/3ea8777446fb394a0ef728f14190b1cd.111d5b0e.webp",p=s.p+"static/image/aa750f8442ae9511ced18bf2f364d7dc.3b428ed4.webp",a=s.p+"static/image/7d5ae9c70c7b153a7d62a8eca53d5e37.16bd5d9a.webp",h=s.p+"static/image/65878fda0401a76955bb19adb7428691.20eb1c50.webp",m=s.p+"static/image/c398c5fa4268f9ddc89dc650806f6bdd.4d6368f7.webp",x=s.p+"static/image/e8df4414f840ae55481b4239abc17192.05304868.webp";function I(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",code:"code",h2:"h2",pre:"pre",ol:"ol",li:"li"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"7具体实现判定-api-调用",children:["7.具体实现：判定 API 调用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7具体实现判定-api-调用",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"依赖调用分析需要对代码文件 AST 进行两轮遍历分析，上一节我们主要讲解了如何分析 Import 节点，也就是第一轮遍历， 分析 Import 节点是为了搞清楚有哪些 API 被导入，同时收集这些导入 API 的相关信息。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["这节课我们来讲解 ",(0,r.jsx)(n.code,{children:"step 5"})," 中的第二个小步骤，即如何判定代码中存在 API 调用，这一步会用到上节课收集的 API 信息，课程内容涉及 codeAnalysis 中 ",(0,r.jsx)(n.code,{children:"_dealAST"})," 函数的实现原理，完整源码可参考 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"lib/analysis.js"})," 。"]}),"\n",(0,r.jsxs)(n.p,{children:["在学习第 3 节课时，我们实现了一个分析 TS 代码中 API 调用的分析脚本，虽然存在一些缺陷，但通过遍历所有 ",(0,r.jsx)(n.code,{children:"identifier"})," 类型节点名称与 Import API 名称进行相等判断这个逻辑是成立的，我们这一节要讲的内容可以理解为对那个分析脚本的进一步完善。"]}),"\n",(0,r.jsxs)(n.h2,{id:"遍历-identifier-节点",children:["遍历 Identifier 节点",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历-identifier-节点",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先，基于原先简易的分析脚本搭建 ",(0,r.jsx)(n.code,{children:"_dealAST"})," 函数的雏形，",(0,r.jsx)(n.code,{children:"_dealAST"})," 函数是 AST 分析的核心函数，完整的代码会涉及很多其它课程内容，同样建议大家在学完全部课程后再去阅读完整源码，下面的简化版剔除了不相干的代码，让大家更专注于当前小节的内容，相关代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const tsCompiler = require('typescript');         // TS编译器\n\n// ImportItems 是上一节课程中Import节点分析的结果Map\n// ast 表示代码文件解析后的ast\n// checker 编译代码文件时创建的checker\n_dealAST(ImportItems, ast, checker, baseLine = 0) {\n    const ImportItemNames = Object.keys(ImportItems);    // 获取所有导入API信息的名称\n    \n    // 遍历AST\n    function walk(node) {\n      // console.log(node);\n      tsCompiler.forEachChild(node, walk);\n\n      // 判定当前遍历的节点是否为isIdentifier类型节点，\n      // 判断从Import导入的API中是否存在与当前遍历节点名称相同的API\n      if(tsCompiler.isIdentifier(node) \n          && node.escapedText \n          && ImportItemNames.length>0 \n          && ImportItemNames.includes(node.escapedText)) {        \n          // 过滤掉不相干的 Identifier 节点后\n      }\n    }\n\n    walk(ast);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"当前的判定条件只能说明，代码文件从 Import 导入的 API 中包含与遍历的 Identifier 节点名称相同的 API。也就是说，目前的判断条件找到的是所有与导入 API 同名的 Identifier 节点，这只能用于过滤一些不相干的节点，不能证明满足条件的节点都属于 API 调用。"}),"\n",(0,r.jsxs)(n.p,{children:["与第 3 节课中的简易分析脚步一样，目前的 ",(0,r.jsx)(n.code,{children:"_dealAST"})," 函数存在 3 个问题："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"无法排除 Import 中同名节点的干扰。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"无法排除局部声明的同名节点的干扰。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"无法检测 API 属于链式调用还是直接调用。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// 待分析代码\nImport { app } from 'framework';                   // Import app 定义\nImport { environment as env } from 'framework';    // Import request 定义\n\nfunction doWell () {\n    const app = 4;                                 // 局部常量 app 定义\n    if(env){                                       // Import app 调用(as别名)\n        return app;\n    }else{\n        return 0;\n    }\n}\nfunction getInfos (info: string) {\n    const result = app.get(info);                  // Import app 调用(链式) \n    return result;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["目前 ",(0,r.jsx)(n.code,{children:"_dealAST"})," 函数的 API 调用判定逻辑找到的 ",(0,r.jsx)(n.code,{children:"app"})," 调用会有 4 处（第 2、6、8、14 行 ），它无法排除上述示例代码中第 ",(0,r.jsx)(n.code,{children:"2"})," 行即 Import 节点中 ",(0,r.jsx)(n.code,{children:"app"})," 的干扰，也无法排除 doWell 函数中定义的局部常量 ",(0,r.jsx)(n.code,{children:"app"})," 的干扰，同时无法检测 ",(0,r.jsx)(n.code,{children:"14"})," 行中 app 调用方式是直接调用还是链式调用。"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来我们想办法解决这些问题，让 ",(0,r.jsx)(n.code,{children:"_dealAST"})," 判定逻辑更健壮、更准确。"]}),"\n",(0,r.jsxs)(n.h2,{id:"排除-import-中同名节点干扰",children:["排除 Import 中同名节点干扰",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#排除-import-中同名节点干扰",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们在之前的课程中提到过，每个 AST 节点都具备的公共属性有 ",(0,r.jsx)(n.code,{children:"pos"}),"、",(0,r.jsx)(n.code,{children:"end"}),"、",(0,r.jsx)(n.code,{children:"kind"}),"，其中 ",(0,r.jsx)(n.code,{children:"pos"})," 表示该节点在代码字符串流中索引的起始位置，",(0,r.jsx)(n.code,{children:"end"})," 表示该节点在代码字符串流中索引的结束位置，",(0,r.jsx)(n.code,{children:"pos"})," 与 ",(0,r.jsx)(n.code,{children:"end"})," 属性可以用来做节点的唯一性判定。"]}),"\n",(0,r.jsx)(n.p,{children:"举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"Import { app } from 'framework';                   // Import app 定义\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上述代码放入 ",(0,r.jsx)(n.a,{href:"https://astexplorer.net/?spm=taofed.bloginfo.blog.3.3ba15ac8enL4hJ#/gist/f0f498345c3f04ceb8c45d37b0068f2c/684e85493fa9401b2d2ee5a8a3651b37d7bdbb28",target:"_blank",rel:"noopener noreferrer",children:"AST explorer"}),"，可以看到 ",(0,r.jsx)(n.code,{children:"app"})," 这个 Identifier 类型节点的 pos 属性值为 8，end 属性值为 12，表明 ",(0,r.jsx)(n.code,{children:"app"})," 在上述代码字符串中索引的起始位置是 8，结束位置是 12。因为 AST 节点在代码字符串中的索引位置是唯一且固定的，所以 8，12 就可以用来标识这个 ",(0,r.jsx)(n.code,{children:"app"})," 在代码中的唯一性。"]}),"\n",(0,r.jsxs)(n.p,{children:["那想要排除 Import 语句中同名节点的干扰就变得非常容易了，在遍历所有 Identifier 类型节点时，如果发现当前节点的 ",(0,r.jsx)(n.code,{children:"pos"})," 和 ",(0,r.jsx)(n.code,{children:"end"})," 属性值与 Import 节点分析后得到的 API 信息中的 ",(0,r.jsx)(n.code,{children:"identifierPos"})," 和 ",(0,r.jsx)(n.code,{children:"identifierEnd"})," 属性值一致，则说明遍历到了 Import 中的同名节点，跳过即可，相关逻辑如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const tsCompiler = require('typescript');         // TS编译器\n\n// ImportItems 是上一节课程中Import节点分析的结果Map\n// ast 表示代码文件解析后的ast\n// checker 编译代码文件时创建的checker\n_dealAST(ImportItems, ast, checker, baseLine = 0) {\n    const ImportItemNames = Object.keys(ImportItems);    // 获取所有导入API信息的名称\n    \n    // 遍历AST\n    function walk(node) {\n      // console.log(node);\n      tsCompiler.forEachChild(node, walk);\n\n      // 判定当前遍历的节点是否为isIdentifier类型节点，\n      // 判断从Import导入的API中是否存在与当前遍历节点名称相同的API\n      if(tsCompiler.isIdentifier(node) \n          && node.escapedText \n          && ImportItemNames.length>0 \n          && ImportItemNames.includes(node.escapedText)) {        \n            // 过滤掉不相干的 Identifier 节点后\n            const matchImportItem = ImportItems[node.escapedText];\n            // console.log(matchImportItem);\n            if(node.pos !=matchImportItem.identifierPos \n                && node.end !=matchImportItem.identifierEnd){     \n                // 排除 Import 语句中同名节点干扰后\n            }\n      }\n    }\n\n    walk(ast);\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"排除局部声明的同名节点干扰",children:["排除局部声明的同名节点干扰",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#排除局部声明的同名节点干扰",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["那局部同名节点的干扰又该如何排除呢？这里需要用到 Import 节点分析后所收集的 API 信息中的 ",(0,r.jsx)(n.code,{children:"symbolPos"})," 和 ",(0,r.jsx)(n.code,{children:"symbolEnd"})," 这两个属性。Symbol 的概念在前面几节课程中反复提及，简单来讲，通过 Symbol 我们可以判定当前遍历的 AST 节点是否是由 Import 导入的 API 节点声明的。"]}),"\n",(0,r.jsxs)(n.p,{children:["为了更直观地理解上面这段话的含义，我们把示例代码放入 ",(0,r.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/JYWwDg9gTgLgBAbzgQzGOBfOAzKERwDkuyIApgO7QDWhA3HI08y8wPRtyiSwppyAs7UCScgChu0eEjIA7AG7A808tPjIAznBmzMOPAWJRSlGvXadxvKGQCOAVzJr4wkSOy3pAYxjAI0uABMIAHUyABtQuAAKAEpEEWYPX0c+dABeOAAWBlYc3LzGDjhAAR1AC4TADj1AecSUwVFmYGxIrWikfNa2lkKLVX5AYBjACldI9UBqJUBYFWj4nKsYWyg-VDA6CcYMMLUyBCWWKZm-AAZF5gwRI7dPb184AHMyGABJaWwIDUjgB4gALjhHKFfL2I2Ekl4FY1LZQvB0vMAHTXGAvN7RbLtJidcASar9SKAP5TAPD6sU221mcBBYJgiwwQA",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"})," ，在右下角也就是 Symbol 区域中可以看到相关节点对应的 Symbol 信息："]}),"\n",(0,r.jsxs)(n.p,{children:["（1）代码第 1 行 ",(0,r.jsx)(n.code,{children:"app"})," 节点的 Symbol 信息："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["（2）代码第 13 行 ",(0,r.jsx)(n.code,{children:"app"})," 节点的 Symbol 信息："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["（3）代码第 5 行 ",(0,r.jsx)(n.code,{children:"app"})," 节点的 Symbol 信息："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["（4）代码第 7 行 ",(0,r.jsx)(n.code,{children:"app"})," 节点的 Symbol 信息："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["根据前面几个章节的学习，我们可以从上面 4 张图的 ",(0,r.jsx)(n.code,{children:"Symbol"})," 信息中判定第 ",(0,r.jsx)(n.code,{children:"13"})," 行中的 ",(0,r.jsx)(n.code,{children:"app"})," 由第 ",(0,r.jsx)(n.code,{children:"1"})," 行 import 语句中的 ",(0,r.jsx)(n.code,{children:"app"})," 声明，而第 ",(0,r.jsx)(n.code,{children:"7"})," 行中的 ",(0,r.jsx)(n.code,{children:"app"})," 是由第 ",(0,r.jsx)(n.code,{children:"5"})," 行中的 ",(0,r.jsx)(n.code,{children:"app"})," 节点声明的局部变量。"]}),"\n",(0,r.jsxs)(n.p,{children:["因为 pos 与 end 可用来标识节点唯一性，所以在判定当前节点是否由 Import 导入的 API 声明时，我们只需要判断 Symbol 指向的声明节点 pos，end 属性值与同名 API 的 ",(0,r.jsx)(n.code,{children:"symbolPos"})," 和 ",(0,r.jsx)(n.code,{children:"symbolEnd"})," 属性值是否一致即可。"]}),"\n",(0,r.jsxs)(n.p,{children:["AST 节点对应的 Symbol 对象可以通过 ",(0,r.jsx)(n.code,{children:"checker.getSymbolAtLocation(node)"})," 方法获取，完善一下判断代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const tsCompiler = require('typescript');         // TS编译器\n\n// ImportItems 是上一节课程中Import节点分析的结果Map\n// ast 表示代码文件解析后的ast\n// checker 编译代码文件时创建的checker\n_dealAST(ImportItems, ast, checker, baseLine = 0) {\n    const ImportItemNames = Object.keys(ImportItems);    // 获取所有导入API信息的名称\n    \n    // 遍历AST\n    function walk(node) {\n      // console.log(node);\n      tsCompiler.forEachChild(node, walk);\n\n      // 判定当前遍历的节点是否为isIdentifier类型节点，\n      // 判断从Import导入的API中是否存在与当前遍历节点名称相同的API\n      if(tsCompiler.isIdentifier(node) \n          && node.escapedText \n          && ImportItemNames.length>0 \n          && ImportItemNames.includes(node.escapedText)) {        \n            // 过滤掉不相干的 Identifier 节点后\n            const matchImportItem = ImportItems[node.escapedText];\n            // console.log(matchImportItem);\n            if(node.pos !=matchImportItem.identifierPos \n                && node.end !=matchImportItem.identifierEnd){     \n                // 排除 Import 语句中同名节点干扰后\n                const symbol = checker.getSymbolAtLocation(node);\n                // console.log(symbol);\n                if(symbol && symbol.declarations && symbol.declarations.length>0){//存在声明\n                    const nodeSymbol = symbol.declarations[0];\n                    if(matchImportItem.symbolPos == nodeSymbol.pos \n                        && matchImportItem.symbolEnd == nodeSymbol.end){\n                        // 语义上下文声明与从Import导入的API一致, 属于导入API声明\n                    }else{\n                        // 同名Identifier干扰节点\n                    }\n                }\n            }\n      }\n    }\n\n    walk(ast);\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"检测链式调用",children:["检测链式调用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#检测链式调用",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["经过三轮过滤条件筛选，排除了两种干扰节点以后，我们找到了真正符合 API 调用特征的 ",(0,r.jsx)(n.code,{children:"Identifier"})," 类型节点，但我们无法判断它们属于链式调用还是直接调用，我们先来看一下链式调用场景下 AST的节点结构："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// 链式调用示例代码\napp\napp.get\napp.set.isWell\napp.set.isWell.info\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["结合 ",(0,r.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/IYBxChRA6BzBTALpM0DOToEs0HV4A2BKMGi2ehB2AdgGYD2QA",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"}),"，我们发现链式调用会在一个 PropertyAccessExpression 结构下，且每增加一级链式就多一层 PropertyAccessExpression 结构，转化为树状图，可以更直观地看出这个规律："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["我们可以通过判断当前 ",(0,r.jsx)(n.code,{children:"Identifier"})," 节点的父级节点是否为 ",(0,r.jsx)(n.code,{children:"PropertyAccessExpression"})," 类型来判断它是否存在链式调用，如果存在，则继续递归其父级节点，持续检查到最外层 ",(0,r.jsx)(n.code,{children:"PropertyAccessExpression"})," 就可以搞清楚链式调用的具体情况了，函数 ",(0,r.jsx)(n.code,{children:"_checkPropertyAccess"})," 来实现链式调用检查，它会返回链路顶层 node 节点："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const tsCompiler = require('typescript');         // TS编译器\n\n// 链式调用检查，找出链路顶点node\n  _checkPropertyAccess(node, index =0, apiName='') {\n    if(index>0){\n      apiName = apiName + '.' + node.name.escapedText;\n    }else{\n      apiName = apiName + node.escapedText;\n    }\n    if(tsCompiler.isPropertyAccessExpression(node.parent)){\n      index++;\n      return this._checkPropertyAccess(node.parent, index, apiName);\n    }else{                                                                                                                         \n      return {\n        baseNode :node, \n        depth: index,\n        apiName: apiName\n      };                                                                                                \n    }\n}\n\n// AST分析\n// ImportItems 是上一节课程中Import节点分析的结果Map\n// ast 表示代码文件解析后的ast，在这里可以理解成上面待分析demo代码的ast\n// checker 编译代码文件时创建的checker\n_dealAST(ImportItems, ast, checker, baseLine = 0) {\n    const that = this;\n    const ImportItemNames = Object.keys(ImportItems);\n    \n    // 遍历AST\n    function walk(node) {\n      // console.log(node);\n      tsCompiler.forEachChild(node, walk);\n      const line = ast.getLineAndCharacterOfPosition(node.getStart()).line + baseLine + 1;\n\n      // 判定是否命中Target Api Name\n      if(tsCompiler.isIdentifier(node) && node.escapedText && ImportItemNames.length>0 && ImportItemNames.includes(node.escapedText)) {\n        const matchImportItem = ImportItems[node.escapedText];\n        // console.log(matchImportItem);\n        if(node.pos !=matchImportItem.identifierPos && node.end !=matchImportItem.identifierEnd){\n          // 排除ImportItem Node自身后\n          const symbol = checker.getSymbolAtLocation(node);\n          // console.log(symbol);\n          if(symbol && symbol.declarations && symbol.declarations.length>0){    // 存在上下文声明\n            const nodeSymbol = symbol.declarations[0];\n            if(matchImportItem.symbolPos == nodeSymbol.pos && matchImportItem.symbolEnd == nodeSymbol.end){\n              // 语义上下文声明与Import item匹配, 符合API调用\n              if(node.parent){\n                // 获取基础分析节点信息\n                const { baseNode, depth, apiName } = that._checkPropertyAccess(node);                                                           \n                // 分析 API 用途（下一节讲解）\n                // isApiCheck(baseNode, depth, apiName, ...)\n                // isMethodCheck(baseNode, depth, apiName, ...)\n                // isTypeCheck(baseNode, depth, apiName, ...)\n                // ......\n              }else{\n                // Identifier节点如果没有parent属性，说明AST节点语义异常，不存在分析意义\n              }\n            }else{\n              // 同名Identifier干扰节点\n            }\n          }\n        }  \n      }\n    }\n\n    walk(ast);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如果是链式调用，",(0,r.jsx)(n.code,{children:"baseNode"})," 表示的是最顶层节点，如果不存在链式调用，",(0,r.jsx)(n.code,{children:"baseNode"})," 则表示 ",(0,r.jsx)(n.code,{children:"Identifier"})," 节点自身，",(0,r.jsx)(n.code,{children:"apiName"})," 为完整的 API 调用名，",(0,r.jsx)(n.code,{children:"depth"})," 表示链式调用深度，我们把 baseNode 称为基准节点，它是后续 API 用途分析的入口节点。"]}),"\n",(0,r.jsxs)(n.h2,{id:"自上而下-vs-自下而上",children:["自上而下 vs 自下而上",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自上而下-vs-自下而上",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们在做 Import 节点分析的时候，采用是",(0,r.jsx)(n.code,{children:"自上而下的分析模式"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["即先找到所有的 ",(0,r.jsx)(n.code,{children:"Import"})," 节点，然后通过观察不同导入方式下 AST 及其子节点结构特征，总结出了各种导入方式的唯一性判断条件，然后根据这些判定条件完成了分析逻辑。"]}),"\n",(0,r.jsxs)(n.p,{children:["这样做的好处是聚焦，因为分析目标是 API 导入情况，把 ",(0,r.jsx)(n.code,{children:"ImportDeclaration"})," 类型节点作为基准节点来分析自然是最好的切入点。另外，导入相关的语义特征可以通过它及它的子节点来体现，那么我们自然会以自上而下的分析思路来实现分析逻辑。"]}),"\n",(0,r.jsxs)(n.p,{children:["但在判定 API 调用的分析场景中，我们是以 identifier 这种处于 AST 末端的节点作为切入点来实现判定逻辑，采用的是",(0,r.jsx)(n.code,{children:"自下而上的分析模式"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["因为 AST 是树状结构，从最末端的叶子结点着手遍历，可以覆盖到全部 ",(0,r.jsx)(n.code,{children:"identifier"})," 结点，防止遗漏。自下而上分析像是一种倒向漏斗的筛选模式，在经过一轮一轮的分析筛选后，就能全面且准确地定位到目标节点。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"总之，采用自上而下还是自下而上，完全取决于我们的分析目的，因地制宜才是最好的策略。"}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这一小节我们学习了如何判定 API 调用，也就是分析范式中 ",(0,r.jsx)(n.code,{children:"step5"})," 的第二步，需要大家掌握以下知识点："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["通过遍历所有 ",(0,r.jsx)(n.code,{children:"identifier"})," 类型节点名称来与 Import API 名称进行相等判断这个逻辑是成立的，但这种判定只能用于过滤一些不相干的节点，不能证明满足条件的节点都属于 API 调用，需要进一步过滤处理。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["如果节点的 ",(0,r.jsx)(n.code,{children:"pos"})," 和 ",(0,r.jsx)(n.code,{children:"end"})," 属性值与 Import 节点分析后得到的 API 信息的 ",(0,r.jsx)(n.code,{children:"identifierPos"})," 和 ",(0,r.jsx)(n.code,{children:"identifierEnd"})," 属性值一致，就说明当前遍历的节点是 Import 中的同名节点，需要过滤掉它，排除干扰。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["判断节点 Symbol 对象指向的声明节点的 pos 与 end 属性值与同名 API 信息中的 ",(0,r.jsx)(n.code,{children:"symbolPos"})," 、",(0,r.jsx)(n.code,{children:"symbolEnd"})," 属性值是否一致，可以判定当前遍历的节点是否是由 Import 导入的 API 声明，而非局部同名节点。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["API 链式调用具有特定的 AST结构，通过递归父级节点持续检查 ",(0,r.jsx)(n.code,{children:"PropertyAccessExpression"})," 结构的方式，可以找到调用链路顶端的 node 节点，摸清完整调用链路。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"自上而下的分析模式"}),"适合于分析特征集中于子节点中的分析场景，而",(0,r.jsx)(n.code,{children:"自下而上的分析模式"}),"适合需要层层过滤，准确地定位目标结点的分析场景，因地制宜即可。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"判定 API 调用是为了证明代码中的确在调用导入的 API，但导入的 API 具体是哪种类型我们是不清楚的，它可能是一个方法，也可能是一个类型、属性。下一节课，我们将学习如何对 API 的具体用途进行分析、统计。"})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(I,{...e})}):I(e)}let A=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F7.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%88%A4%E5%AE%9A%20API%20%E8%B0%83%E7%94%A8.md"]={toc:[{text:"遍历 Identifier 节点",id:"遍历-identifier-节点",depth:2},{text:"排除 Import 中同名节点干扰",id:"排除-import-中同名节点干扰",depth:2},{text:"排除局部声明的同名节点干扰",id:"排除局部声明的同名节点干扰",depth:2},{text:"检测链式调用",id:"检测链式调用",depth:2},{text:"自上而下 vs 自下而上",id:"自上而下-vs-自下而上",depth:2},{text:"小结",id:"小结",depth:2}],title:"7.具体实现：判定 API 调用",headingTitle:"7.具体实现：判定 API 调用",frontmatter:{}}}}]);