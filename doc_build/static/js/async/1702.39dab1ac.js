"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["1702"],{720435:function(e,n,s){s.r(n),s.d(n,{default:()=>i});var r=s(552676),a=s(740453);let c=s.p+"static/image/a8d3130b3fd9f724d10723f842863086.f85e622e.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",blockquote:"blockquote",strong:"strong",img:"img",pre:"pre",h3:"h3",ol:"ol",li:"li"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"15-进阶篇如何理解索引集合与键值集合",children:["15 进阶篇｜如何理解索引集合与键值集合？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15-进阶篇如何理解索引集合与键值集合",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"像 XML、JSON 这种文本数据格式，往往用作不同系统之间的信息传递之用，兼顾了对人类阅读友好的特点。但是对于程序内部来说，则完全没有必要使用它，甚至很难用或者不能用。"}),"\n",(0,r.jsx)(n.p,{children:"本文我们来了解数据集合，这里指的是同一类数据的聚合体。通常我们使用数组（Array）来存储数据集，在必要的时候，它也可以很方便地转换为 JSON 来进行网络传输等跨系统交流。"}),"\n",(0,r.jsxs)(n.h2,{id:"索引集合",children:["索引集合",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#索引集合",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们在前面的章节中已经专门探讨过数组的创建、遍历、查找等基础操作，在什么样的场合适合使用什么样的方法。严格来说，数组也是对象的一种，只不过它以连续的非负整数来做 key，我们管这种结构叫做",(0,r.jsx)(n.code,{children:"索引集合"}),"。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"\uD83D\uDCA1 在 C++ 等语言中，索引往往意味着其内存是连续的，但是 JavaScript 不一定，取决于引擎的实现，ECMAScript 并没有做出规定。实际往往是根据其大小的不同，引擎会决定使用连续内存还是链表。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["ECMAScript 中内置的索引集合并非只有 Array 这一种，还有一类叫做 ",(0,r.jsx)(n.code,{children:"TypedArray"})," 的结构，也可以称之为广义上的数组，但是它们是用来存储数字的。"]}),"\n",(0,r.jsxs)(n.p,{children:["之所以称之为“它们”，是因为 ",(0,r.jsx)(n.code,{children:"TypedArray"})," 代表了一系列具体类型：",(0,r.jsx)(n.strong,{children:"Int8Array"}),"、",(0,r.jsx)(n.strong,{children:"Uint8Array"}),"、",(0,r.jsx)(n.strong,{children:"Uint8ClampedArray"}),"、",(0,r.jsx)(n.strong,{children:"Int16Array"}),"、",(0,r.jsx)(n.strong,{children:"Uint16Array"}),"、",(0,r.jsx)(n.strong,{children:"Int32Array"}),"、",(0,r.jsx)(n.strong,{children:"Uint32Array"}),"、",(0,r.jsx)(n.strong,{children:"BigInt64Array"}),"、",(0,r.jsx)(n.strong,{children:"BigUint64Array"}),"、",(0,r.jsx)(n.strong,{children:"Float32Array"}),"、",(0,r.jsx)(n.strong,{children:"Float64Array"}),"，共 11 种。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["以 ",(0,r.jsx)(n.strong,{children:"Int8Array"})," 为例，它只能存储 8 位有符号整数，取值范围是 -128～127。每一种 ",(0,r.jsx)(n.code,{children:"TypedArray"})," 上都有一个 ",(0,r.jsx)(n.code,{children:"BYTES_PER_ELEMENT"})," 常量属性，代表里面每个数字占据的字节数："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"Int8Array.BYTES_PER_ELEMENT // 1\nInt16Array.BYTES_PER_ELEMENT // 2\nInt32Array.BYTES_PER_ELEMENT // 4\nBigInt64Array.BYTES_PER_ELEMENT // 8\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"TypedArray"})," 上绝大多数方法都和 Array 是通用的，比如 fill、every、find、 slice、indexOf 等。但它和 Array 也有本质区别：",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"TypedArray 的大小是不可变的"})}),"。无论是使用 from、of、还是构造函数，一旦创建，它的容纳空间就是固定的了。因此，它没有 ",(0,r.jsx)(n.strong,{children:"push"}),"、",(0,r.jsx)(n.strong,{children:"shift"}),"、",(0,r.jsx)(n.strong,{children:"pop"}),"、",(0,r.jsx)(n.strong,{children:"unshift"})," 方法。"]}),"\n",(0,r.jsx)(n.p,{children:"关于在日常业务场景中如何使用 TypedArray，在本文紧接着的下一章中，我们再详细讨论。"}),"\n",(0,r.jsx)(n.p,{children:"总体来说，索引集合还是很容易理解的，毕竟它们是数组的“近亲”。但是，索引集合也缺少一些特性，比如快速查找（只能按顺序遍历）、去重，这时候就需要使用到键值集合了。"}),"\n",(0,r.jsxs)(n.h2,{id:"键值集合",children:["键值集合",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#键值集合",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"键值集合的 key 通常不再是数字，可以是字符串，但也可以是其他类型。对象本身就是一种键值结构，但其 key 只能是 String 或者 Symbol。"}),"\n",(0,r.jsx)(n.p,{children:"ECMAScript 在 ES6 引入了 Map 和 Set 两种新的集合类型。在其他高级语言中，大多早就已经实现了，因此它们也不算什么新鲜事物。对于传统的前端工程师来说，也应该善于在合适的场合充分利用它们。"}),"\n",(0,r.jsxs)(n.h3,{id:"map",children:["Map",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#map",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在有的语言中，Map 通常是一个抽象接口，具体可实现为 HashMap 等子类。JavaScript 的 Map 可以直接用。"}),"\n",(0,r.jsx)(n.p,{children:"相信很多同学都习惯于用对象当作 Map 来用，不过有几点限制："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"只能以 String 或者 Symbol 作为 key；"}),"\n",(0,r.jsx)(n.li,{children:"遍历需要考虑到属性的可遍历性、原型链等因素；"}),"\n",(0,r.jsx)(n.li,{children:"计数需要先遍历，成本高。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"现在我们来用 Map，它可以使用任意类型数据作为 key，甚至是 undefined、null："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const map = new Map();\n\nmap.set({}, 1);\nmap.set(1, 1);\nmap.set(true, 1);\nmap.set(undefined, 1);\nmap.set(null, 1);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["显然 key 是不可以重复的，这里判断是否重复使用的是内部的叫做 ",(0,r.jsx)(n.code,{children:"SameValueZero"})," 的方法。还记得么，这就是 ",(0,r.jsx)(n.code,{children:"Array.prototype.includes"})," 的算法，也就是相比 ",(0,r.jsx)(n.code,{children:"==="})," 多出来一个区分 NaN 的能力，但仍然不区分 +0 和 -0："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"map.set(NaN, 1)\nmap.get(NaN) // 1\n\nmap.set(+0, 1)\nmap.get(-0) // 1\n"})}),"\n",(0,r.jsx)(n.p,{children:"创建 Map 的时候可以预设数据："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"new Map([['a', 1], ['b', 2]])\n"})}),"\n",(0,r.jsxs)(n.p,{children:["构造参数常常是一个二维数组，形式是 ",(0,r.jsx)(n.code,{children:"[[key, value], [key, value]...]"}),"。但本质上这个参数是一个迭代器，每一项至少包含两个成员的",(0,r.jsx)(n.strong,{children:"类数组"}),"，因此，上面也可以这样实现："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function* ini() {\n    yield { 0: 'a', 1: '1'}; // 类数组\n    yield ['b', 2];\n}\n\nnew Map(ini());\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Map 内部数据的计数可以直接访问其 ",(0,r.jsx)(n.code,{children:"size"})," 属性。Map 有多种遍历操作，但都不依赖于 size。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Map.prototype.keys"})," 用以遍历其所有键，它返回一个迭代器："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"for (const key of map.keys()) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["相应的，",(0,r.jsx)(n.code,{children:"Map.prototype.values"})," 也可以遍历其所有的值："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"for (const key of map.values()) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["用 ",(0,r.jsx)(n.code,{children:"Map.prototype.entries"})," 键值可以一并遍历："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"for (const [key, value] of map.entries()) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但实际用起来，以上都稍显多余，因为 Map 的原型上已经定义了 ",(0,r.jsx)(n.code,{children:"[Symbol.iterator]"}),"，所以 Map 自身就是一个迭代器，等价于 ",(0,r.jsx)(n.code,{children:"Map.prototype.entries"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"for (const [key, value] of map) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如果不使用 ",(0,r.jsx)(n.code,{children:"for...of"}),"，Map 也提供了一个类似数组的 ",(0,r.jsx)(n.code,{children:"forEach"})," 方法："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"map.forEach(function(key, value) {});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["注意，由于 Map 没有提供 ",(0,r.jsx)(n.code,{children:"toJSON"})," 方法，且其数据也不存在于实例对象的属性上，因此一个 Map 被序列化成 JSON 时只能得到一个空对象："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"JSON.stringify(map) // {}\n"})}),"\n",(0,r.jsx)(n.p,{children:"你可能想到了，直接序列化不行，那么数据遍历出来再转换行不行？只能说部分可行，但你需要处理好各种不被 JSON 支持的数据类型，比如对象类型的 key。"}),"\n",(0,r.jsxs)(n.p,{children:["Map 的原型对象（Map.prototype）上定义了 ",(0,r.jsx)(n.code,{children:"[Symbol.toStringTag]"})," 属性，值为 ",(0,r.jsx)(n.strong,{children:'"Map"'}),"，根据前面我们学习到的关于变量隐式类型转换的知识，在不严格的条件下，可以这样判断一个变量是否是 Map 类型："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"Object.prototype.toString.call(map) === '[object Map]'\n\n// 或者\n\nString(map) === '[object Map]'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此外，Map 构造函数上还定义了 ",(0,r.jsx)(n.code,{children:"[Symbol.species]"})," 属性，返回 Map 本身。大家还记得这个 Symbol 是做什么的吗？想想 ",(0,r.jsx)(n.strong,{children:"Array.prototype.map"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["没错，当对象定义了返回派生对象的函数时，它应该根据 ",(0,r.jsx)(n.code,{children:"[Symbol.species]"})," 的值来决定此对象的构造器。Map 本身并没有定义这样的函数，但如果你继承了它，实现新函数："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class MyMap extends Map {\n    clone() {\n        const Constructor = MyMap[Symbol.species];\n        const newMap = new Constructor();\n        for (const [key, value] of this) {\n            newMap.set(key, value);\n        }\n\n        return newMap;\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["像上面那样，返回的新 Map 对象，使用哪一个构造器应该遵循 ",(0,r.jsx)(n.code,{children:"[Symbol.species]"})," 的定义，当然这只是一个君子协定。"]}),"\n",(0,r.jsxs)(n.h3,{id:"set",children:["Set",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Set 相比 Map 而言，就以数据自身为 key 进行存储，因此不可以存储重复数据，天然带有去重的能力。"}),"\n",(0,r.jsxs)(n.p,{children:["Set 判断数据相同与否和 Map 一样都是采用的 ",(0,r.jsx)(n.code,{children:"SameValueZero"})," 方法。"]}),"\n",(0,r.jsx)(n.p,{children:"创建一个 Set 只能使用构造函数，也可以传入预设的成员："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const set = new Set([+0, NaN, Symbol.for('x')]);\n\nset.has(NaN); // true\nset.has(-0); // true\nset.has(Symbol.for('x')); // true\n"})}),"\n",(0,r.jsx)(n.p,{children:"其构造参数本质上也是一个迭代器，因此字符串也可以直接被拆解："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const set = new Set(\"abc\");\n\nset.has('a'); // true\nset.has('b'); // true\nset.has('c'); // true\n"})}),"\n",(0,r.jsx)(n.p,{children:"在遍历方面，ECMAScript 故意将 Set 的 API 设计得和 Map 一模一样。只不过，由于 Set 的 key-value 同值的特性，遍历 keys 和 values 是等价的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 以下三者等价\nfor (const val of set.keys()) {}\nfor (const val of set.values()) {}\nfor (const val of set) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"[Symbol.toStringTag]"})," 和 ",(0,r.jsx)(n.code,{children:"[Symbol.species]"})," 上，Set 和 Map 也有类似的定义，不再多说。"]}),"\n",(0,r.jsx)(n.p,{children:"总体来说，可以把 Set 当作是简化版本的 Map。"}),"\n",(0,r.jsxs)(n.h2,{id:"weakmap-与-weakset",children:["WeakMap 与 WeakSet",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#weakmap-与-weakset",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["除了常规的 Map 与 Set 之外，ES6 同时引入了 ",(0,r.jsx)(n.code,{children:"WeakMap"})," 与 ",(0,r.jsx)(n.code,{children:"WeakSet"})," 这两个特殊类型。那它们是做什么的呢？"]}),"\n",(0,r.jsxs)(n.p,{children:["我们知道，有些编程语言需要主动清理内存，比如 C/C++，有些则具备自动功能，俗称 ",(0,r.jsx)(n.code,{children:"GC"}),"，即 ",(0,r.jsx)(n.strong,{children:"Garbage Collection"}),"，垃圾回收，像 Java、JavaScript 都属于这一类。"]}),"\n",(0,r.jsx)(n.p,{children:"垃圾回收有各种各样的策略，其中最简单的一条就是做引用计数。当引用变成 0 了，数据就变成一种游离状态，无法再被使用，自然就需要回收掉。"}),"\n",(0,r.jsx)(n.p,{children:"但是，很多代码的写法会造成变量始终被引用，无法被清理，比如下面的这种："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const pool = new Set();\n\nfunction createRequest() {\n    function request() {\n        \n    }\n    \n    pool.add(request);\n    \n    return request;\n}\n\nconst fetch = createRequest();\n"})}),"\n",(0,r.jsx)(n.p,{children:"无论 fetch 有没有真正被业务使用，它始终存在于 pool 集合中，导致一定程度上的内存泄漏。"}),"\n",(0,r.jsx)(n.p,{children:"一般来说，大多数 Web 页面的短生命周期特征，让内存泄漏产生的影响不会特别明显——在产生影响之前，就已经跳转或者关闭页面了。但也有一些场景对此足够敏感，比如 Node.js 服务、React Native 等等。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"WeakMap"})," 与 ",(0,r.jsx)(n.code,{children:"WeakSet"})," 提供了这样一种",(0,r.jsx)(n.strong,{children:"弱引用"}),"的能力，也就是说，数据放到它们上不会算作一次计数。一旦数据被回收，那么也就自动从集合中移除了。"]}),"\n",(0,r.jsxs)(n.p,{children:["这样的特性，让它们的行为变得非常特别——",(0,r.jsx)(n.code,{children:"它们都不可以遍历"}),"，WeakMap 只有 delete、get、has、set 四个方法，WeakSet 只有add、delete、has 三个方法。一旦允许遍历，那么就有可能发生遍历过程数据被回收的尴尬。"]}),"\n",(0,r.jsxs)(n.p,{children:["什么时候使用 ",(0,r.jsx)(n.code,{children:"WeakMap"})," 与 ",(0,r.jsx)(n.code,{children:"WeakSet"})," 呢？那种可有可无的数据，丢失也不影响主要业务逻辑的，考虑到性能，就可以使用它们。"]}),"\n",(0,r.jsxs)(n.p,{children:["由于 Primitive 类型不涉及到引用，所以 ",(0,r.jsx)(n.code,{children:"WeakMap"})," 与 ",(0,r.jsx)(n.code,{children:"WeakSet"})," 只支持对象类型，下面这样是不允许的："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'weakMap.set("x", 1);\nweakMap.set(1, 1);\nweakMap.set(true, 1);\nweakMap.set(undefined, 1);\nweakMap.set(null, 1);\n\nweakSet.add("x");\nweakSet.add(1);\nweakSet.add(true);\nweakSet.add(undefined);\nweakSet.add(null);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["不过也有例外，从 ES2023 开始，它们都开始支持以 Symbol 为 key，但是有条件：",(0,r.jsx)(n.code,{children:"以 Symbol.for() 创建的 Symbol 不被支持"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"weakMap.set(Symbol('x'), 1); // ✅\nweakSet.add(Symbol('x')); // ✅\n\nweakMap.set(Symbol.for('x'), 1); // ❌\nweakSet.add(Symbol.for('x')); // ❌\n"})}),"\n",(0,r.jsx)(n.p,{children:"目前浏览器支持情况还不太好，所以暂时不建议这样用。"}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["本章我们了解了 ECMAScript 内置的集合类型。Array 自然不比多说，由此派生出来的 11 种 ",(0,r.jsx)(n.code,{children:"TypedArray"})," 专门用于存储不同类型的数字，一般用于二进制数字的处理。它们的最大特点就是一旦创建，存储空间并不能像普通 Array 那样自由伸缩。Array 和 TypedArray 都是以数字下标为索引的，称之为",(0,r.jsx)(n.code,{children:"索引集合"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"键值集合"}),"的代表是 Map 和 Set。相对于普通对象来说，Map 允许以各种类型数据作为 key，甚至是对象、null、undefined，数字也不会被强转成字符串。Set 可理解为特殊的 Map，值本身就是 key，为避免冲突，Set 天生自带去重效果，所有有一种简便的数组去重写法就是："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"Array.from(new Set(arr))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Map 和 Set 的去重算法等价于 Array 的 ",(0,r.jsx)(n.strong,{children:"includes"}),"，能处理 NaN，可放心使用。Map 和 Set 本身都是可迭代的，一般用 ",(0,r.jsx)(n.code,{children:"for...of"})," 遍历即可。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"WeakMap"})," 和 ",(0,r.jsx)(n.code,{children:"WeakSet"})," 是特殊的 Map 与 Set。它们对数据成员是弱引用关系，有助于应用程序的内存回收。它们最大的特点是不可遍历以及只能存储对象（新版支持 Symbol）。"]}),"\n",(0,r.jsx)(n.p,{children:"这样看来，ECMAScript 本身关于数据集合的实现仍然是非常简单的，一些稍微高级点的结构仍然需要手动实现，比如 Queue（队列）、Stack（栈），以及 Map/ Set 的特殊形式如 TreeMap、EnumSet，同学们有兴趣的话不妨试一试能否封装得出来。"}),"\n",(0,r.jsx)(n.p,{children:"下一章，我们将展开 TypedArray，讨论在一些高级场景中，JavaScript 如何处理二进制数据。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F15%20%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BD%9C%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88%E4%B8%8E%E9%94%AE%E5%80%BC%E9%9B%86%E5%90%88%EF%BC%9F.md"]={toc:[{text:"索引集合",id:"索引集合",depth:2},{text:"键值集合",id:"键值集合",depth:2},{text:"Map",id:"map",depth:3},{text:"Set",id:"set",depth:3},{text:"WeakMap 与 WeakSet",id:"weakmap-与-weakset",depth:2},{text:"小结",id:"小结",depth:2}],title:"15 进阶篇｜如何理解索引集合与键值集合？",headingTitle:"15 进阶篇｜如何理解索引集合与键值集合？",frontmatter:{}}}}]);