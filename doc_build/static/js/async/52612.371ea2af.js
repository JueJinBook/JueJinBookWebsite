"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["52612"],{349977:function(e,n,s){e.exports=s.p+"static/image/064201007c82603be2fc52d706e5df03.5d136124.gif"},524150:function(e,n,s){e.exports=s.p+"static/image/5c7f86b886f6a0cddb37cb1508060c88.beec0d87.webp"},161971:function(e,n,s){e.exports=s.p+"static/image/8a6c50553a2c279193b29099590933a5.ff47c0ef.webp"},574520:function(e,n,s){s.r(n),s.d(n,{default:()=>w});var t=s(552676),c=s(740453);let o=s.p+"static/image/328fef9786cc552bde77d619d0ab6906.63526b53.webp",r=s.p+"static/image/badfc9ae81f5ac6d6a6edfb83d3a2111.d73eef72.webp",i=s.p+"static/image/f36a24abe7444120a5b52a3cc82fe110.297ed042.webp",a=s.p+"static/image/454952e3bcbf2e5953d08d303f9655c3.be3d91c8.webp",l=s.p+"static/image/123ee320610e4b8a3d5f9948f45db72d.2752966b.webp",d=s.p+"static/image/449a1fc96e99cdc53987fb958e525393.39fc9101.webp",u=s.p+"static/image/93d5c3708d5acc11e6692a2367f7e15f.bf28ba77.gif",p=s.p+"static/image/9fcc474f2bf5ddf4d4fc23ec5ba4732b.82d33b4d.gif",h=s.p+"static/image/198ccbbf2a93534a3a02bbe84424a1df.327e94d9.webp",f=s.p+"static/image/8a4f47ed08f41ac77e4aaa02df5fa851.e43fb15d.webp",m=s.p+"static/image/33d80fef00277fa582a371bf0d7fcf5a.c8a3b933.webp",x=s.p+"static/image/01bcd63f19cd774d6b1fd1f57614c35a.19262899.webp";var j=s(349977);let g=s.p+"static/image/e6158117acda02397ff96c42cba724f2.eccd628a.webp",v=s.p+"static/image/1a617a22455e30a160f0884bad36a520.5081cab8.webp",b=s.p+"static/image/b4ba28e13d6365e45466a3156392bd75.2e50cc3f.gif",k=s.p+"static/image/d1cca6b62a5bfa245ac9c285c010a3dc.fb6530e9.gif";var E=s(524150),C=s(161971);let S=s.p+"static/image/a1a34e04f6b1530611a3f8097e989ca1.a22ee1ba.webp",R=s.p+"static/image/94fe06f6eb90f1d6f757ce84b95a0630.c865f9cc.webp",M=s.p+"static/image/422be9a3b299fa5670262b7bf5fbe2a2.9d525010.webp";function A(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",strong:"strong",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li"},(0,c.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"第21章自定义hook练习",children:["第21章—自定义hook练习",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第21章自定义hook练习",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"\uFEFF组件里有很多逻辑是可以复用的。"}),"\n",(0,t.jsx)(n.p,{children:"对于常规的 JS 逻辑，我们会封装成函数，也会用一些通用函数的库，比如 lodash。"}),"\n",(0,t.jsx)(n.p,{children:"对于用到 hook 的逻辑，我们会封装成自定义 hook，当然，也会有通用 hook 库，比如 react-use 和 ahooks。"}),"\n",(0,t.jsx)(n.p,{children:"看周下载量，react-use 是 ahooks 的十倍："}),"\n",(0,t.jsx)(n.p,{children:"ahooks："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:M,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["react-use：\n",(0,t.jsx)("img",{src:R,alt:""})]}),"\n",(0,t.jsx)(n.p,{children:"这节我们就挑 react-use 里的几个 hook 来实现下。"}),"\n",(0,t.jsx)(n.p,{children:"写完这几个 hook，你会对封装自定义 hook 更得心应手。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"自定义 hook 就是函数封装，和普通函数的区别只是在于名字规范是用 use 开头，并且要用到 rect 的内置 hook。"})}),"\n",(0,t.jsx)(n.p,{children:"新建个项目："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx create-vite\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:S,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"进入项目，安装依赖，然后把服务跑起来："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install\nnpm run dev\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:C,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"去掉 index.css 和 StrictMode："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:E,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"安装 react-use："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install --save react-use\n"})}),"\n",(0,t.jsx)(n.p,{children:"接下来实现自定义 hook："}),"\n",(0,t.jsxs)(n.h2,{id:"usemountedstate-和-uselifecycles",children:["useMountedState 和 useLifeCycles",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usemountedstate-和-uselifecycles",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"useMountedState 可以用来获取组件是否 mount 到 dom："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react';\nimport {useMountedState} from 'react-use';\n\nconst App = () => {\n    const isMounted = useMountedState();\n    const [,setNum ] = useState(0);\n\n    useEffect(() => {\n        setTimeout(() => {\n            setNum(1);\n        }, 1000);\n    }, []);\n\n    return <div>{ isMounted() ? 'mounted' : 'pending' }</div>\n};\n\nexport default App;\n"})}),"\n",(0,t.jsx)(n.p,{children:"第一次渲染，组件渲染的时候，组件还没 mount 到 dom，1 秒后通过 setState 触发再次渲染的时候，这时候组件已经 mount 到 dom 了。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:k,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这个 hook 的实现也比较简单："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useCallback, useEffect, useRef } from 'react';\n\nexport default function useMountedState(): () => boolean {\n  const mountedRef = useRef<boolean>(false);\n  const get = useCallback(() => mountedRef.current, []);\n\n  useEffect(() => {\n    mountedRef.current = true;\n\n    return () => {\n      mountedRef.current = false;\n    };\n  }, []);\n\n  return get;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"通过 useRef 保存 mount 状态，然后 useEffect 回调里修改它为 true。"}),"\n",(0,t.jsx)(n.p,{children:"因为 useEffect 是在 dom 操作之后异步执行的，所以这时候就已经 mount 了。"}),"\n",(0,t.jsx)(n.p,{children:"而使用 useRef 而不是 useState 保存 mount 的值是因为修改 ref.current 并不会引起组件重新渲染。"}),"\n",(0,t.jsx)(n.p,{children:"并且返回的 get 函数要用 useCallback 包裹，这样用它作为其它 memo 组件参数的时候，就不会导致额外的渲染。"}),"\n",(0,t.jsx)(n.p,{children:"类似的还有个 useLifeCycles 的 hook："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import {useLifecycles} from 'react-use';\n\nconst App = () => {\n  useLifecycles(() => console.log('MOUNTED'), () => console.log('UNMOUNTED'));\n\n  return null;\n};\n\nexport default App;\n"})}),"\n",(0,t.jsx)(n.p,{children:"这个也是用 useEffect 的特性实现的："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect } from 'react';\n\nconst useLifecycles = (mount: Function, unmount?: Function) => {\n  useEffect(() => {\n    if (mount) {\n      mount();\n    }\n    return () => {\n      if (unmount) {\n        unmount();\n      }\n    };\n  }, []);\n};\n\nexport default useLifecycles;\n"})}),"\n",(0,t.jsx)(n.p,{children:"在 useEffect 里调用 mount，这时候 dom 操作完了，组件已经 mount。"}),"\n",(0,t.jsx)(n.p,{children:"然后返回的清理函数里调用 unmount，在组件从 dom 卸载时调用。"}),"\n",(0,t.jsx)(n.p,{children:"这两个 hook 都是依赖 useEffect 的特性来实现的。"}),"\n",(0,t.jsxs)(n.h2,{id:"usecookie",children:["useCookie",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecookie",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"useCookie 可以方便的增删改 cookie："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { useEffect } from "react";\nimport { useCookie } from "react-use";\n\nconst App = () => {\n  const [value, updateCookie, deleteCookie] = useCookie("guang");\n\n  useEffect(() => {\n    deleteCookie();\n  }, []);\n\n  const updateCookieHandler = () => {\n    updateCookie("666");\n  };\n\n  return (\n    <div>\n      <p>cookie 值: {value}</p>\n      <button onClick={updateCookieHandler}>更新 Cookie</button>\n      <br />\n      <button onClick={deleteCookie}>删除 Cookie</button>\n    </div>\n  );\n};\nexport default App;\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"它是对 js-cookie 这个包的封装："}),"\n",(0,t.jsx)(n.p,{children:"安装下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm i --save js-cookie\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后实现 useCookie："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useCallback, useState } from 'react';\nimport Cookies from 'js-cookie';\n\nconst useCookie = (\n  cookieName: string\n): [string | null, (newValue: string, options?: Cookies.CookieAttributes) => void, () => void] => {\n  const [value, setValue] = useState<string | null>(() => Cookies.get(cookieName) || null);\n\n  const updateCookie = useCallback(\n    (newValue: string, options?: Cookies.CookieAttributes) => {\n      Cookies.set(cookieName, newValue, options);\n      setValue(newValue);\n    },\n    [cookieName]\n  );\n\n  const deleteCookie = useCallback(() => {\n    Cookies.remove(cookieName);\n    setValue(null);\n  }, [cookieName]);\n\n  return [value, updateCookie, deleteCookie];\n};\n\nexport default useCookie;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["就是基于 js-cookie 来 get、set、remove cookie：\n",(0,t.jsx)("img",{src:v,alt:""})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"一般自定义 hook 里返回的函数都要用 useCallback 包裹下，这样调用者就不用自己处理了。"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsxs)(n.h2,{id:"usehover",children:["useHover",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usehover",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"css 里有 :hover 伪类，但是 js 里没有 hover 事件，只有 mouseenter、mouseleave 事件。"}),"\n",(0,t.jsx)(n.p,{children:"useHover 封装了 hover 事件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import {useHover} from 'react-use';\n\nconst App = () => {\n  const element = (hovered: boolean) =>\n    <div>\n      Hover me! {hovered && 'Thanks'}\n    </div>;\n\n  const [hoverable, hovered] = useHover(element);\n\n  return (\n    <div>\n      {hoverable}\n      <div>{hovered ? 'HOVERED' : ''}</div>\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们写一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { cloneElement, useState } from \"react\";\n\nexport type Element = ((state: boolean) => React.ReactElement) | React.ReactElement;\n\nconst useHover = (element: Element): [React.ReactElement, boolean] => {\n  const [state, setState] = useState(false);\n\n  const onMouseEnter = (originalOnMouseEnter?: any) => (event: any) => {\n    originalOnMouseEnter?.(event);\n    setState(true);\n  };\n  const onMouseLeave = (originalOnMouseLeave?: any) => (event: any) => {\n    originalOnMouseLeave?.(event);\n    setState(false);\n  };\n\n  if (typeof element === 'function') {\n    element = element(state);\n  }\n\n  const el = cloneElement(element, {\n    onMouseEnter: onMouseEnter(element.props.onMouseEnter),\n    onMouseLeave: onMouseLeave(element.props.onMouseLeave),\n  });\n\n  return [el, state];\n};\n\nexport default useHover;\n"})}),"\n",(0,t.jsx)(n.p,{children:"传入的可以是 ReactElement 也可以是返回 ReactElement 的函数，内部对函数做下处理："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"用 cloneElement 复制 ReactElement，给它添加 onMouseEnter、onMouseLeave 事件。"}),"\n",(0,t.jsx)(n.p,{children:"并用 useState 保存 hover 状态："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这里注意如果传入的 React Element 本身有 onMouseEnter、onMouseLeave 的事件处理函数，要先调用下："}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)("img",{src:f,alt:""}),"\n换成我们实现的试一下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,t.jsxs)(n.h2,{id:"usescrolling",children:["useScrolling",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usescrolling",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"useScrolling 封装了滚动的状态："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { useRef } from "react";\nimport { useScrolling } from "react-use";\n\nconst App = () => {\n  const scrollRef = useRef<HTMLDivElement>(null);\n  const scrolling = useScrolling(scrollRef);\n\n  return (\n    <>\n    {<div>{scrolling ? "滚动中.." : "没有滚动"}</div>}\n\n    <div ref={scrollRef} style={{height: \'200px\', overflow: \'auto\'}}>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n      <div>guang</div>\n    </div>\n    </>\n  );\n};\n\nexport default App;\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"和刚才的 useHover 差不多，但是传入的是 ref。"}),"\n",(0,t.jsx)(n.p,{children:"我们实现下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { RefObject, useEffect, useState } from 'react';\n\nconst useScrolling = (ref: RefObject<HTMLElement>): boolean => {\n  const [scrolling, setScrolling] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (ref.current) {\n      let scollingTimer: number;\n\n      const handleScrollEnd = () => {\n        setScrolling(false);\n      };\n\n      const handleScroll = () => {\n        setScrolling(true);\n        clearTimeout(scollingTimer);\n        scollingTimer = setTimeout(() => handleScrollEnd(), 150);\n      };\n\n      ref.current?.addEventListener('scroll', handleScroll);\n\n      return () => {\n        if (ref.current) {\n          ref.current?.removeEventListener('scroll', handleScroll);\n        }\n      };\n    }\n    return () => {};\n  }, [ref]);\n\n  return scrolling;\n};\n\nexport default useScrolling;\n"})}),"\n",(0,t.jsx)(n.p,{children:"用 useState 创建个状态，给 ref 绑定 scroll 事件，scroll 的时候设置 scrolling 为 true："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"并且定时器 150ms 以后修改为 false。"}),"\n",(0,t.jsx)(n.p,{children:"这样只要不断滚动，就会一直重置定时器，结束滚动后才会设置为 false。"}),"\n",(0,t.jsx)(n.p,{children:"为啥 useHover 的时候是传入 element，通过 cloneElement 添加事件，而 useScroll 里是传入 ref，通过 addEventListener 添加事件呢？"}),"\n",(0,t.jsx)(n.p,{children:"确实，这两种实现方式都可以。"}),"\n",(0,t.jsx)(n.p,{children:"但是有区别，传入 element 通过 cloneElement 修改后返回的方式，因为会覆盖这个属性，所以要先调用下之前的事件处理函数。"}),"\n",(0,t.jsx)(n.p,{children:"而传入 ref 直接 addEventListener 的方式，则是直接把事件绑定在元素上了，可以绑定多个。"}),"\n",(0,t.jsx)(n.p,{children:"这两种选择用哪种方式实现都可以，差不多。"}),"\n",(0,t.jsx)(n.p,{children:"比如 useHover 在 react-use 里用的 React Element + cloneElement 的方式实现，而在 ahooks 就是用的 ref + addEventListener 实现的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"其实还有一种方式更常用，就是返回 hook 返回 onXxx 函数，调用者自己绑定。"}),"\n",(0,t.jsx)(n.p,{children:"比如 @floating-ui/react 包的 useInteractions，就是返回 props 对象，比如 {onClick: xxx} 让调用者自己绑定："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"或者只返回事件处理函数："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"封装绑定事件的自定义 hook，总共就这三种封装方式。"}),"\n",(0,t.jsxs)(n.p,{children:["案例代码上传了",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/react-use-hook",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"组件里的逻辑可以抽成自定义 hook 来复用，在 react-use、ahooks 里也有很多通用 hook。"}),"\n",(0,t.jsx)(n.p,{children:"我们实现了 useMountedState、useLifecycles、useCookie、useHover、useScrolling 这些自定义 hook。"}),"\n",(0,t.jsx)(n.p,{children:"其中要注意的是返回的函数一般都用 useCallback 包裹，这样返回值作为 memo 组件的参数的时候，调用者不用再处理。"}),"\n",(0,t.jsx)(n.p,{children:"再就是绑定事件的 hook 有三种封装方式："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"传入 React Element 然后 cloneElement"}),"\n",(0,t.jsx)(n.li,{children:"传入 ref 然后拿到 dom 执行 addEventListener"}),"\n",(0,t.jsx)(n.li,{children:"返回 props 对象或者事件处理函数，调用者自己绑定"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"自定义 hook 的封装方式都差不多，练习几个就会了。"})]})}function N(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(A,{...e})}):A(e)}let w=N;N.__RSPRESS_PAGE_META={},N.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC21%E7%AB%A0%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89hook%E7%BB%83%E4%B9%A0.md"]={toc:[{text:"useMountedState 和 useLifeCycles",id:"usemountedstate-和-uselifecycles",depth:2},{text:"useCookie",id:"usecookie",depth:2},{text:"useHover",id:"usehover",depth:2},{text:"useScrolling",id:"usescrolling",depth:2},{text:"总结",id:"总结",depth:2}],title:"第21章—自定义hook练习",headingTitle:"第21章—自定义hook练习",frontmatter:{}}}}]);