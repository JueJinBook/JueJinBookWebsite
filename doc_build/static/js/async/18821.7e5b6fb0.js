"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18821"],{455533:function(n,e,s){s.r(e),s.d(e,{default:()=>h});var r=s(552676),i=s(740453);let l=s.p+"static/image/fe2e2f4a5c30fdee721031f4d601f412.11a3abf5.webp";function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",h2:"h2",img:"img",blockquote:"blockquote",ul:"ul",li:"li",h3:"h3",pre:"pre"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"第20章缓存策略让程序更快一步",children:["第20章—缓存策略：让程序更快一步",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第20章缓存策略让程序更快一步",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["\uFEFF在上一章中，我们讲了计算机的工作流程，我们知道计算机是通过：",(0,r.jsx)(e.code,{children:"读入->运算->输出"}),"，这样的步骤来执行的。那么，这三个步骤都需要一个空间来存放数据，这些数据存在哪里呢？"]}),"\n",(0,r.jsxs)(e.p,{children:["答案就是 ",(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"内存"})}),"！"]}),"\n",(0,r.jsx)(e.p,{children:"那么，本节我们就来彻底了解下计算机的内存是怎么设计的。"}),"\n",(0,r.jsxs)(e.h2,{id:"计算机的内存",children:["计算机的内存",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#计算机的内存",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"啥是内存呢？"}),"\n",(0,r.jsx)(e.p,{children:"有人说，是这个："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:"261681316430_.pic.jpg"})}),"\n",(0,r.jsx)(e.p,{children:"还有人说，是这个："}),"\n",(0,r.jsxs)(e.p,{children:["其实都对，第一个是内存条，或者叫做",(0,r.jsx)(e.strong,{children:"物理内存"}),"；第二个是内存的地址空间，或者叫做",(0,r.jsx)(e.strong,{children:"虚拟内存"}),"。当然，对于程序员来说，直接面对的肯定是虚拟内存，而数据，却是实实在在地存储在物理内存上的，那就意味着，我们是",(0,r.jsx)(e.code,{children:"通过虚拟内存来操作物理内存"}),"的。"]}),"\n",(0,r.jsx)(e.p,{children:"嗯，这个我们都知道，我们通过代码来操作虚拟内存地址，每个地址都对应物理内存上的一块空间，从而就间接操作了物理内存。"}),"\n",(0,r.jsxs)(e.p,{children:["没错。其实，我们的物理内存是一小块一小块的，就像一个小区的楼房一样，一间一间的，一层一层的，一栋一栋的；为了查找快一点，我们的内存不但进行了编址，还进行了分页，比如：这几块连起来的是第一页，那几块连起来的是第二页，就像小区的楼房一样，有单元、楼层以及门牌号。这个保存页面的信息就叫做",(0,r.jsx)(e.strong,{children:"页表"}),"，它也是要占用内存空间的，就像书籍的目录一样，也需要占用几张纸，这里就不废话了。"]}),"\n",(0,r.jsx)(e.p,{children:"那么，我们的物理内存是怎么存放数据呢？"}),"\n",(0,r.jsxs)(e.p,{children:["其实，我们的内存内部是由一个个的晶体管和电容组成的，为了简便起见，我们可以理解成是多个开关，开关打开就表示存储 1，开关关闭就表示存储 0，这样通过多个开关，就存储了一串串的 0 和 1，也就是二进制，比如要存放 a，a 的",(0,r.jsx)(e.code,{children:"ASCII"}),"码是 97，二进制就是 01100001，所以",(0,r.jsx)(e.code,{children:"关开开关关关关开"}),"就可以了。实际上操作的是晶体管，这里为了方便理解，所以用开关举例，但是道理都是一样的，都是通过电信号来表示二进制。"]}),"\n",(0,r.jsx)(e.p,{children:"好，道理都懂了，那么就有问题了：每次内存读写都要操作电路，这岂不是很费劲？因为按照我的理解，电路的操作不是很方便啊，开开关关的，听起来都不容易。"}),"\n",(0,r.jsxs)(e.p,{children:["没错！完全正确，电路的操作确实很费劲，我们在",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196589491266519080",target:"_blank",rel:"noopener noreferrer",children:"第 6 章"}),"讲过寄存器，寄存器的出现就是因为内存的读写速度太慢了。"]}),"\n",(0,r.jsx)(e.p,{children:"有多慢呢？是数量级的慢。这么说吧，假如 CPU 的运算速度是 S，内存的读写速度是 B，那么，B 就是 S 的高阶无穷小。也就是说："}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"$$B \\div S \\approx 0$$"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"伤害性大，侮辱性也高。"}),"\n",(0,r.jsx)(e.p,{children:"那怎么办呢？我们让 CPU 慢点？等等内存？"}),"\n",(0,r.jsx)(e.p,{children:"啥？那你的意思就是让考 100 分的下次考 60 分呗，从而去等等 60 分的同学？"}),"\n",(0,r.jsx)(e.p,{children:"这肯定不行，那我们就来在 60 分和 100 分之间插入一个 80 分来起个过渡作用，让它看起来不是那么突兀，这个 80 分是谁呢？"}),"\n",(0,r.jsx)(e.p,{children:"缓存！"}),"\n",(0,r.jsxs)(e.h2,{id:"计算机的缓存",children:["计算机的缓存",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#计算机的缓存",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196589491266519080",target:"_blank",rel:"noopener noreferrer",children:"第 6 章"}),"已经讲过高速缓存了，我们知道，计算机内部的高速缓存位于内存和 CPU 之间，CPU 在执行时，先把数据读入高速缓存中，然后去执行，执行完后，再把数据写回到内存中。"]}),"\n",(0,r.jsxs)(e.p,{children:["在",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196590625226293288",target:"_blank",rel:"noopener noreferrer",children:"第 13 章"}),"我们也讲过，内存是进程占有的，是线程共享的，而每个线程内部都有自己独立的缓存，线程在执行时，会先把内存中的数据读入自己的缓存中，然后在自己的后宫中进行一顿猛如虎的操作，最后再把数据写回到内存中晒给其他线程看。"]}),"\n",(0,r.jsxs)(e.p,{children:["而从内存中读，线程自己操作，然后再写回内存中，这个流程，可能出现并发导致数据不同，这个可以通过加锁等待来处理，这就叫",(0,r.jsx)(e.strong,{children:"缓存一致性"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["OK，现在我们知道了，",(0,r.jsx)(e.strong,{children:"因为 CPU 速度比内存快，为了解决这个问题，我们引入了速度更快的缓存，但是引入缓存会导致数据不一致，所以我们通过缓存一致性协议来保证数据一致"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"那为啥不直接用缓存呢？不要内存了，数据全部写到缓存中不就行了？"}),"\n",(0,r.jsx)(e.p,{children:"不行！"}),"\n",(0,r.jsx)(e.p,{children:"因为缓存很小，比内存小很多。"}),"\n",(0,r.jsx)(e.p,{children:"举个例子，你每次上厕所都要用纸，你大概似乎差不多会在厕所放一卷供自己用，没了就再去超市买。你肯定不会每次上厕所都去商店买几张，也不会直接把商店搬到厕所。这里的厕所就是缓存，商店就是内存。"}),"\n",(0,r.jsx)(e.p,{children:"内存条我想你也见到过，比 CPU 还大，CPU 屁大点地方，你还想在里面塞一个内存条那么大的东西？而且缓存也不是越大越好，因为大部分场景下我们不需要那么大的缓存，比如你平时只玩扫雷，你却买了个 4090 的显卡，何弃疗呢？"}),"\n",(0,r.jsx)(e.p,{children:"所以，不直接全部用缓存的根本原因有两个："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"缓存的成本很高，够用就行，没必要用那么大；"}),"\n",(0,r.jsx)(e.li,{children:"技术有限，无法在有限的空间内集成这么大的内存。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"那么，缓存既然空间有限，如果我不小心用满了，该怎么办呢？"}),"\n",(0,r.jsx)(e.p,{children:"删！只能删。"}),"\n",(0,r.jsx)(e.p,{children:"删谁呢？看不顺眼的吗？"}),"\n",(0,r.jsxs)(e.p,{children:["这就要提到缓存清除策略了，我们来看看以下",(0,r.jsx)(e.code,{children:"三种缓存清除策略"}),"。"]}),"\n",(0,r.jsxs)(e.h3,{id:"过期清除",children:["过期清除",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#过期清除",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"在缓存数据时，设置一个过期时间，到了这个时间后，就清除这个数据。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"道理很简单，等于给每个数据一个寿命，寿命到了直接咔嚓，不问是非，不问原因，非常公平。"}),"\n",(0,r.jsx)(e.p,{children:"那有人就不爽了，比如我这个数据很重要啊，我下了一部片子，看到一半就黑屏了，为啥？过期了！"}),"\n",(0,r.jsx)(e.p,{children:"你这不是耍人玩吗，肯定不合适，公平是公平了，但是不合理，有没有那种我正在用的就留着的？"}),"\n",(0,r.jsx)(e.p,{children:"有，就是大名鼎鼎的 LRU 缓存。"}),"\n",(0,r.jsxs)(e.h3,{id:"lru",children:["LRU",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#lru",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"LRU（Least Recently Used）最近最少使用：优先清除最近没有用过的数据。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"也就是说，当缓存满的时候，优先去删除很久没有用过的最老的数据。"}),"\n",(0,r.jsx)(e.p,{children:"假如有如下代码，我们要来设计 LRU 缓存："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:"// 定义一个大小为3的集合\nval list = ArrayList(3);\nlist.put(1);\nlist.put(2);\nlist.put(3);\n\n// 获取第一个元素，也就是1\nlist.get(0);\n// 获取第二个元素，也就是2\nlist.get(1);\n\n// 存放元素4\nlist.put(4);\n// 存放后，集合内的元素是多少呢？\n\n"})}),"\n",(0,r.jsx)(e.p,{children:"当我们在存放第 4 个元素的时候，发现放不下了，那么就要删除一个元素。由于元素 1 和元素 2 是刚刚访问过的，那么元素 3 就是最近没有被使用的，那么就会删除元素 3，然后存放元素 4，所以最后集合中的元素就是：1、2 和 4。"}),"\n",(0,r.jsx)(e.p,{children:"当然，如果我们没有获取过元素，而是直接存放元素 4，比如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:"// 定义一个大小为3的集合\nval list = ArrayList(3);\nlist.put(1);\nlist.put(2);\nlist.put(3);\n\n// 直接存放元素4\nlist.put(4);\n// 存放后，集合内的元素是多少呢？\n\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样的话，元素 1 就是最近没有被使用过的（因为存放元素也算是使用），所以，根据 LRU，就会删除元素 1，存放元素 4，那么最后结果就是：2、3 和 4。"}),"\n",(0,r.jsxs)(e.p,{children:["可以看到，LRU 是非公平的，只管你最近一次的使用时间，我们可以这么理解：",(0,r.jsx)(e.strong,{children:"LRU 内部维护了一个队列，每次元素被使用都会进行排队，也就是将被使用的元素放在队列尾部，那么，最近没被使用的自然就跑到了队列头部，当缓存满时，就直接删除掉队列头部的元素"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"这个策略的核心是：最近被使用了，那么我就认为将来一段时间还会被使用，这确实满足了我们上面的要求。"}),"\n",(0,r.jsx)(e.p,{children:"但是！如果我最近使用的那个是偶尔兴起呢？比如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:"// 定义一个大小为3的集合\nval list = ArrayList(3);\nlist.put(1);\nlist.put(2);\nlist.put(3);\n\n// 访问4次1，说明1很重要\nlist.get(1);\nlist.get(1);\nlist.get(1);\nlist.get(1);\nlist.get(2);\nlist.get(3);\n\n// 直接存放元素4\nlist.put(4);\n"})}),"\n",(0,r.jsx)(e.p,{children:"我们看到，1 在代码中被访问了 4 次，说明受众很高，将来大概率还会被访问，但是按照 LRU，却被删除了，这明显不对啊，那怎么解决呢？"}),"\n",(0,r.jsx)(e.p,{children:"用 LFU！"}),"\n",(0,r.jsxs)(e.h3,{id:"lfu",children:["LFU",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#lfu",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"LFU（Least Frequently Used）最不经常使用：它会将使用频率最低的数据删除掉。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"也就是说，LFU 会给每个缓存的数据设置一个计数器，每次数据被使用一次就将计数器加 1，当缓存满的时候，就删除掉计数器最小的那个数据。当然，如果有两个最小的呢？那就删除最老的那个。"}),"\n",(0,r.jsx)(e.p,{children:"还是上面的代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:"// 定义一个大小为3的集合\nval list = ArrayList(3);\nlist.put(1);\nlist.put(2);\nlist.put(3);\n\n// 访问4次1，说明1很重要\nlist.get(1);\nlist.get(1);\nlist.get(1);\nlist.get(1);\nlist.get(2);\nlist.get(3);\n\n// 直接存放元素4\nlist.put(4);\n"})}),"\n",(0,r.jsx)(e.p,{children:"此时，1 虽然是最老的数据，但是 1 是使用次数最多的数据，所以 1 不会被删除；而 2 和 3 都是使用次数最少的，但是 3 使用的时间要比 2 更新，所以就删除 2。这样以来，最后的数据就是 1、3 和 4。"}),"\n",(0,r.jsx)(e.p,{children:"这明显是符合我们的预期的。"}),"\n",(0,r.jsx)(e.p,{children:"我们的逻辑是这样: 如果一个数据被访问一次，我们就给它加 1 分，如果这个数据是最新的，我们就给它加 1 分，如果是老的，那就不加分，然后综合分数去做删除，这样，上面删的就是 2 了。"}),"\n",(0,r.jsx)(e.p,{children:"这是什么策略呢？"}),"\n",(0,r.jsxs)(e.p,{children:["就是",(0,r.jsx)(e.code,{children:"加权"}),"。我们给数据的访问次数和访问时间都定义一个权重，然后计算综合得分，得分低的就被删除。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"当我们遇到有多个因素对问题造成影响以至于无法抉择时，我们就可以使用加权策略，根据每个因素对问题的影响设置权重，最后给出一个综合得分，以此来决定取舍。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["其实，加权这个策略，我们在",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196591276454576162",target:"_blank",rel:"noopener noreferrer",children:"第 15 章"}),"的",(0,r.jsx)(e.strong,{children:"高优先权算法"}),"里也提及过，核心就是一个词：",(0,r.jsx)(e.strong,{children:"量化"}),"。"]}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本章我们讲了计算机内存的设计和缓存策略，我们再来回顾下。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"计算机内存是采用电容和晶体管实现的，我们通过虚拟内存来操作物理内存。"}),"\n",(0,r.jsx)(e.li,{children:"内存速度很慢，所以我们要采用缓存来存放数据。"}),"\n",(0,r.jsx)(e.li,{children:"缓存很珍贵，容量有限，所以我们要选择合适的清除算法。"}),"\n",(0,r.jsx)(e.li,{children:"过期清除：给数据设置过期时间，到期就清除，很公平，但是不符合常理。"}),"\n",(0,r.jsx)(e.li,{children:"LRU：优先删除最老的没有使用过的，有利于保存新数据，但是不利于保存使用率高的数据。"}),"\n",(0,r.jsx)(e.li,{children:"LFU：优先删除使用最少的数据，有利于保存使用率高的数据，但是不利于保存新数据。"}),"\n",(0,r.jsx)(e.li,{children:"加权删除算法：根据自己的场景，赋予使用次数和时间不同的权重，灵活删除。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["其实本章有两个核心思想：",(0,r.jsxs)(e.strong,{children:[(0,r.jsx)(e.code,{children:"分页"}),"和",(0,r.jsx)(e.code,{children:"量化"})]}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["比如，数据要",(0,r.jsx)(e.strong,{children:"分页"}),"，为啥呢？能提高查找速度。计算机要加缓存，为啥呢？能提高访问速度。所以你看，缓存其实也是一种分页思想。数据在寄存器找不到，那么就到缓存找，缓存就是二级页。缓存找不到，就到内存中找，内存就是三级页面。内存找不到，就到硬盘找，硬盘就是最后的页面。所以，核心就是",(0,r.jsx)(e.strong,{children:"分页"}),"。这跟我们",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196590693987385384",target:"_blank",rel:"noopener noreferrer",children:"第 12 章"}),"讲到的哈希表元素的访问是一个道理。"]}),"\n",(0,r.jsxs)(e.p,{children:["其次就是",(0,r.jsx)(e.strong,{children:"量化"}),"，一个问题被多个元素影响，那么就没办法采用满足每一个元素的策略，此时，就可以根据每个元素的影响力，赋予不同的权重，最后根据每个元素的权重得出综合得分，以此来判断取舍。这就是量化。用准确的数字来得出理性的结果，让你不再陷入感性的纠纷中，也是一种很重要的思想。"]}),"\n",(0,r.jsxs)(e.p,{children:["那么，计算机的基础课到这里就完结了，下一章开始，我们将开始讲解",(0,r.jsx)(e.code,{children:"编程"}),"的核心：",(0,r.jsx)(e.strong,{children:"设计思想"}),"。"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC20%E7%AB%A0%E2%80%94%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%9A%E8%AE%A9%E7%A8%8B%E5%BA%8F%E6%9B%B4%E5%BF%AB%E4%B8%80%E6%AD%A5.md"]={toc:[{text:"计算机的内存",id:"计算机的内存",depth:2},{text:"计算机的缓存",id:"计算机的缓存",depth:2},{text:"过期清除",id:"过期清除",depth:3},{text:"LRU",id:"lru",depth:3},{text:"LFU",id:"lfu",depth:3},{text:"总结",id:"总结",depth:2}],title:"第20章—缓存策略：让程序更快一步",headingTitle:"第20章—缓存策略：让程序更快一步",frontmatter:{}}}}]);