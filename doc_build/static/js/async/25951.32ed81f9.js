"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["25951"],{893447:function(e,n,r){e.exports=r.p+"static/image/75c4e673bff203a4688f2427eee3905c.94821e42.webp"},741760:function(e,n,r){r.r(n),r.d(n,{default:()=>p});var i=r(552676),t=r(740453),c=r(893447);let s=r.p+"static/image/a4dd334ce1aec8526d8a345911689aef.855eb5aa.webp",o=r.p+"static/image/b5701fed06934c11c1b6da5103e60f7a.ef2e71cf.webp",l=r.p+"static/image/c0e6195c0c92b7b209aab42cb38f9463.bb799b85.webp",d=r.p+"static/image/11b7993c41a8636b2ccb82d6653ab424.2b970014.webp",a=r.p+"static/image/63e6975ee2074589e66dfb2ef41ab95d.69546811.webp",h=r.p+"static/image/8f7bbf672b7837563243a48f21605cf9.039efa7a.webp",f=r.p+"static/image/d7ceda240a0356a7e3a58183e2c4f3e3.ede5ebb7.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",strong:"strong",code:"code",h3:"h3",img:"img",pre:"pre",blockquote:"blockquote",h4:"h4"},(0,t.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"18原理篇--调和与-fiber",children:["18.原理篇- 调和与 fiber",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18原理篇--调和与-fiber",children:"#"})]}),"\n",(0,i.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在之前的很多章节中，我们都提到了 React fiber ，理解 fiber 是吃透 React 原理的基石，所以这节将重点介绍一下 React Fiber 。"}),"\n",(0,i.jsx)(n.p,{children:"通过本章节，你会学到 React fiber 原理，以及 React 调和的两大阶段，解决面试中遇到的 fiber 问题。"}),"\n",(0,i.jsx)(n.p,{children:"参考问题："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"什么是fiber ? Fiber 架构解决了什么问题？\xa0"}),"\n",(0,i.jsx)(n.li,{children:"Fiber root 和 root fiber 有什么区别？\xa0"}),"\n",(0,i.jsx)(n.li,{children:"不同fiber 之间如何建立起关联的？"}),"\n",(0,i.jsx)(n.li,{children:"React 调和流程？"}),"\n",(0,i.jsx)(n.li,{children:"两大阶段 commit 和 render 都做了哪些事情？"}),"\n",(0,i.jsx)(n.li,{children:"什么是双缓冲树？ 有什么作用？"}),"\n",(0,i.jsx)(n.li,{children:"Fiber 深度遍历流程？"}),"\n",(0,i.jsx)(n.li,{children:"Fiber的调和能中断吗？ 如何中断？"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"什么是fiber"})}),"\n",(0,i.jsxs)(n.p,{children:["Fiber 的英文的是’纤维‘，fiber 诞生在 ",(0,i.jsx)(n.code,{children:"Reactv16"})," 版本，整个 React 团队花费两年时间重构 fiber 架构，目的就是解决大型 React 应用卡顿；fiber 在 React 中是最小粒度的执行单元，无论 React 还是 Vue ，在遍历更新每一个节点的时候都不是用的真实 DOM ，都是采用虚拟 DOM ，所以可以理解成 fiber 就是 React 的虚拟 DOM 。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"为什么要用fiber"})}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"Reactv15"})," 以及之前的版本，React 对于虚拟 DOM 是采用递归方式遍历更新的，比如一次更新，就会从应用根部递归更新，递归一旦开始，中途无法中断，随着项目越来越复杂，层级越来越深，导致更新的时间越来越长，给前端交互上的体验就是卡顿。"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Reactv16"})," 为了解决卡顿问题引入了 fiber ，为什么它能解决卡顿，更新 fiber 的过程叫做 ",(0,i.jsx)(n.code,{children:"Reconciler"}),"（调和器），每一个 fiber 都可以作为一个执行单元来处理，所以每一个 fiber 可以根据自身的过期时间",(0,i.jsx)(n.code,{children:"expirationTime"}),"（ v17 版本叫做优先级 ",(0,i.jsx)(n.code,{children:"lane"})," ）来判断是否还有空间时间执行更新，如果没有时间更新，就要把主动权交给浏览器去渲染，做一些动画，重排（ reflow ），重绘 repaints 之类的事情，这样就能给用户感觉不是很卡。然后等浏览器空余时间，在通过 ",(0,i.jsx)(n.code,{children:"scheduler"})," （调度器），再次恢复执行单元上来，这样就能本质上中断了渲染，提高了用户体验。"]}),"\n",(0,i.jsxs)(n.h2,{id:"二-全面认识fiber",children:["二 全面认识Fiber",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-全面认识fiber",children:"#"})]}),"\n",(0,i.jsxs)(n.h3,{id:"1-elementfiberdom三种什么关系",children:["1 element,fiber,dom三种什么关系？",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-elementfiberdom三种什么关系",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"首先必须需要弄明白 React.element ，fiber 和真实 DOM 三者是什么关系。"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"element 是 React 视图层在代码层级上的表象，也就是开发者写的 jsx 语法，写的元素结构，都会被创建成 element 对象的形式。上面保存了 props ， children 等信息。"}),"\n",(0,i.jsx)(n.li,{children:"DOM 是元素在浏览器上给用户直观的表象。"}),"\n",(0,i.jsx)(n.li,{children:"fiber 可以说是是 element 和真实 DOM 之间的交流枢纽站，一方面每一个类型 element 都会有一个与之对应的 fiber 类型，element 变化引起更新流程都是通过 fiber 层面做一次调和改变，然后对于元素，形成新的 DOM 做视图渲染。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"结构如下图所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:f,alt:"2.jpg"})}),"\n",(0,i.jsx)(n.p,{children:"首先先来看一下 element 与 fiber 之间的对应关系。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export const FunctionComponent = 0;       // 对应函数组件\nexport const ClassComponent = 1;          // 对应的类组件\nexport const IndeterminateComponent = 2;  // 初始化的时候不知道是函数组件还是类组件 \nexport const HostRoot = 3;                // Root Fiber 可以理解为跟元素 ， 通过reactDom.render()产生的根元素\nexport const HostPortal = 4;              // 对应  ReactDOM.createPortal 产生的 Portal \nexport const HostComponent = 5;           // dom 元素 比如 <div>\nexport const HostText = 6;                // 文本节点\nexport const Fragment = 7;                // 对应 <React.Fragment> \nexport const Mode = 8;                    // 对应 <React.StrictMode>   \nexport const ContextConsumer = 9;         // 对应 <Context.Consumer>\nexport const ContextProvider = 10;        // 对应 <Context.Provider>\nexport const ForwardRef = 11;             // 对应 React.ForwardRef\nexport const Profiler = 12;               // 对应 <Profiler/ >\nexport const SuspenseComponent = 13;      // 对应 <Suspense>\nexport const MemoComponent = 14;          // 对应 React.memo 返回的组件\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-fiber保存了那些信息",children:["2 fiber保存了那些信息",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-fiber保存了那些信息",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"刚才说到 fiber 作为 element 和真实 DOM 元素的沟通枢纽，那么一个 fiber 上到底保存了那些信息呢？"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiber.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function FiberNode(){\n\n  this.tag = tag;                  // fiber 标签 证明是什么类型fiber。\n  this.key = key;                  // key调和子节点时候用到。 \n  this.type = null;                // dom元素是对应的元素类型，比如div，组件指向组件对应的类或者函数。  \n  this.stateNode = null;           // 指向对应的真实dom元素，类组件指向组件实例，可以被ref获取。\n \n  this.return = null;              // 指向父级fiber\n  this.child = null;               // 指向子级fiber\n  this.sibling = null;             // 指向兄弟fiber \n  this.index = 0;                  // 索引\n\n  this.ref = null;                 // ref指向，ref函数，或者ref对象。\n\n  this.pendingProps = pendingProps;// 在一次更新中，代表element创建\n  this.memoizedProps = null;       // 记录上一次更新完毕后的props\n  this.updateQueue = null;         // 类组件存放setState更新队列，函数组件存放\n  this.memoizedState = null;       // 类组件保存state信息，函数组件保存hooks信息，dom元素为null\n  this.dependencies = null;        // context或是时间的依赖项\n\n  this.mode = mode;                //描述fiber树的模式，比如 ConcurrentMode 模式\n\n  this.effectTag = NoEffect;       // effect标签，用于收集effectList\n  this.nextEffect = null;          // 指向下一个effect\n\n  this.firstEffect = null;         // 第一个effect\n  this.lastEffect = null;          // 最后一个effect\n\n  this.expirationTime = NoWork;    // 通过不同过期时间，判断任务是否过期， 在v17版本用lane表示。\n\n  this.alternate = null;           //双缓存树，指向缓存的fiber。更新阶段，两颗树互相交替。\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"如上，我把 fiber 中每一个变量代表什么，都写出来了，大家可以参考一下。"}),"\n",(0,i.jsxs)(n.h3,{id:"3-每一个fiber如何建立起关联的",children:["3 每一个fiber如何建立起关联的",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-每一个fiber如何建立起关联的",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"看过之前章节的朋友都知道对于每一个 element 都会对应一个 fiber ，每一个 fiber 是通过 return ， child ，sibling 三个属性建立起联系的。"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"return： 指向父级 Fiber 节点。"}),"\n",(0,i.jsx)(n.li,{children:"child：  指向子 Fiber 节点。"}),"\n",(0,i.jsx)(n.li,{children:"sibling：指向兄弟 fiber 节点。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"比如项目中元素结构是这样的："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export default class Index extends React.Component{\n   state={ number:666 } \n   handleClick=()=>{\n     this.setState({\n         number:this.state.number + 1\n     })\n   }\n   render(){\n     return <div>\n       hello，world\n       <p > 《React进阶实践指南》 { this.state.number } \uD83D\uDC4D  </p>\n       <button onClick={ this.handleClick } >点赞</button>\n     </div>\n   }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"fiber对应的关系如下"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:"WechatIMG1720.jpeg"})}),"\n",(0,i.jsxs)(n.h2,{id:"三-fiber更新机制",children:["三 Fiber更新机制",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-fiber更新机制",children:"#"})]}),"\n",(0,i.jsxs)(n.h3,{id:"1-初始化",children:["1 初始化",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-初始化",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"既然上述明白了 fiber 里面有什么，以及 fiber 之间是如何建立起关联的，那么接下来就要从初始化和一次更新入手，看一下 fiber 是如何工作的。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"第一步：创建fiberRoot和rootFiber"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"fiberRoot"}),"：首次构建应用， 创建一个 fiberRoot ，作为整个 React 应用的根基。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"rootFiber"}),"： 如下通过 ReactDOM.render 渲染出来的，如上 Index 可以作为一个 rootFiber。一个 React 应用可以有多 ReactDOM.render 创建的 rootFiber ，但是只能有一个 fiberRoot（应用根节点）。"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"ReactDOM.render(<Index/>, document.getElementById('app'));\n"})}),"\n",(0,i.jsx)(n.p,{children:"第一次挂载的过程中，会将 fiberRoot 和 rootFiber 建立起关联。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberRoot.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function createFiberRoot(containerInfo,tag){\n    /* 创建一个root */\n    const root = new FiberRootNode(containerInfo,tag)\n    const rootFiber = createHostRootFiber(tag);\n    root.current = rootFiber\n    return root\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"效果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:"3.jpg"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"第二步：workInProgress和current"})}),"\n",(0,i.jsx)(n.p,{children:"经过第一步的处理，开始到正式渲染阶段，会进入 beginwork 流程，在讲渲染流程之前，要先弄明白两个概念："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"workInProgress是：正在内存中构建的 Fiber 树称为 workInProgress Fiber 树。在一次更新中，所有的更新都是发生在 workInProgress 树上。在一次更新之后，workInProgress 树上的状态是最新的状态，那么它将变成 current 树用于渲染视图。"}),"\n",(0,i.jsx)(n.li,{children:"current：正在视图层渲染的树叫做 current 树。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["接下来会到 rootFiber 的渲染流程，首先会复用当前 current 树（ rootFiber ）的 ",(0,i.jsx)(n.code,{children:"alternate"})," 作为 workInProgress ，如果没有 alternate （初始化的 rootFiber 是没有 alternate ），那么会创建一个 fiber 作为 workInProgress 。会用 alternate 将新创建的 workInProgress 与 current 树建立起关联。这个关联过程只有初始化第一次创建 alternate 时候进行。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"currentFiber.alternate = workInProgressFiber\nworkInProgressFiber.alternate = currentFiber\n"})}),"\n",(0,i.jsx)(n.p,{children:"效果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"4.jpg"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"第三步：深度调和子节点，渲染视图"})}),"\n",(0,i.jsx)(n.p,{children:"接下来会按照上述第二步，在新创建的 alternates 上，完成整个 fiber 树的遍历，包括 fiber 的创建。"}),"\n",(0,i.jsx)(n.p,{children:"效果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"5.jpg"})}),"\n",(0,i.jsx)(n.p,{children:"最后会以 workInProgress 作为最新的渲染树，fiberRoot 的 current 指针指向 workInProgress 使其变为 current Fiber 树。到此完成初始化流程。"}),"\n",(0,i.jsx)(n.p,{children:"效果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:"6.jpg"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-更新",children:["2 更新",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-更新",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"如果对于上述 demo ，开发者点击一次按钮发生更新，接下来会发生什么呢?\n首先会走如上的逻辑，重新创建一颗 workInProgresss 树，复用当前 current 树上的 alternate ，作为新的 workInProgress ，由于初始化 rootfiber 有 alternate ，所以对于剩余的子节点，React 还需要创建一份，和 current 树上的 fiber 建立起 alternate 关联。渲染完毕后，workInProgresss 再次变成 current 树。"}),"\n",(0,i.jsx)(n.p,{children:"效果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:s,alt:"7.jpg"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"｜--------问与答--------｜"}),"\n问：如果如上又发生一次点击，会发生什么？"]}),"\n",(0,i.jsx)(n.p,{children:"答：如果进行下一次更新，那么会将 current 的 alternate 作为基础（如图右树），复制一份作为 workInProgresss ，然后进行更新。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"｜--------end---------|"})}),"\n",(0,i.jsxs)(n.h3,{id:"双缓冲树",children:["双缓冲树",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#双缓冲树",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["canvas 绘制动画的时候，如果上一帧计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。为了解决这个问题，canvas 在内存中绘制当前动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。这种在内存中构建并直接替换的技术叫做",(0,i.jsx)(n.strong,{children:"双缓存"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"React 用 workInProgress 树(内存中构建的树) 和 current (渲染树) 来实现更新逻辑。双缓存一个在内存中构建，一个渲染视图，两颗树用 alternate 指针相互指向，在下一次渲染的时候，直接复用缓存树做为下一次渲染树，上一次的渲染树又作为缓存树，这样可以防止只用一颗树更新状态的丢失的情况，又加快了 DOM 节点的替换与更新。"}),"\n",(0,i.jsxs)(n.h2,{id:"四-两大阶段render和commit",children:["四 两大阶段：render和commit",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-两大阶段render和commit",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"render 阶段和 commit 阶段是整个 fiber Reconciler 的核心，接下来研究一下两个阶段能做些什么？在正式讲解之前，有必要看一下整个 fiber 的遍历开始—— workLoop ，那么首先看一下 workLoop 。"}),"\n",(0,i.jsxs)(n.h3,{id:"1-render阶段",children:["1 render阶段",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-render阶段",children:"#"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function workLoop (){\n    while (workInProgress !== null ) {\n      workInProgress = performUnitOfWork(workInProgress);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"上述已经说了，每一个 fiber 可以看作一个执行的单元，在调和过程中，每一个发生更新的 fiber 都会作为一次 workInProgress 。那么 workLoop 就是执行每一个单元的调度器，如果渲染没有被中断，那么 workLoop 会遍历一遍 fiber 树。\nperformUnitOfWork 包括两个阶段 beginWork 和 completeWork 。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function performUnitOfWork(){\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    if (next === null) {\n       next = completeUnitOfWork(unitOfWork);\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"beginWork"}),"：是向下调和的过程。就是由 fiberRoot 按照 child 指针逐层向下调和，期间会执行函数组件，实例类组件，diff 调和子节点，打不同effectTag。"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"completeUnitOfWork"}),"：是向上归并的过程，如果有兄弟节点，会返回 sibling兄弟，没有返回 return 父级，一直返回到 fiebrRoot ，期间可以形成effectList，对于初始化流程会创建 DOM ，对于 DOM 元素进行事件收集，处理style，className等。"]}),"\n",(0,i.jsx)(n.p,{children:"这么一上一下，构成了整个 fiber 树的调和。"}),"\n",(0,i.jsxs)(n.h4,{id:"向下调和beginwork",children:["向下调和beginWork",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#向下调和beginwork",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"先来看一下 beginwork 到底做了些什么？"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberBeginWork.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function beginWork(current,workInProgress){\n\n    switch(workInProgress.tag){\n       case IndeterminateComponent:{// 初始化的时候不知道是函数组件还是类组件 \n           //....\n       }\n       case FunctionComponent: {//对应函数组件\n           //....\n       }\n       case ClassComponent:{  //类组件\n           //...\n       }\n       case HostComponent:{\n           //...  \n       }\n       ...\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["到这里把之前讲的章节串联起来，在生命周期章节，主要讲了 ",(0,i.jsx)(n.code,{children:"ClassComponent"}),"，在第十八章节讲了 ",(0,i.jsx)(n.code,{children:"FunctionComponent"})," ，总结beginWork 作用如下："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"对于组件，执行部分生命周期，执行 render ，得到最新的 children 。"}),"\n",(0,i.jsx)(n.li,{children:"向下遍历调和 children ，复用 oldFiber ( diff 算法)，diff 流程在第十二章已经讲过了。"}),"\n",(0,i.jsx)(n.li,{children:"打不同的副作用标签 effectTag ，比如类组件的生命周期，或者元素的增加，删除，更新。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"reconcileChildren"})}),"\n",(0,i.jsx)(n.p,{children:"接下来看一下 React 是如何调和子节点的："}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberBeginWork.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function reconcileChildren(current,workInProgress){\n   if(current === null){  /* 初始化子代fiber  */\n        workInProgress.child = mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime)\n   }else{  /* 更新流程，diff children将在这里进行。 */\n        workInProgress.child = reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime)\n   }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"EffectTag"}),"\n我列举几个常用的 effectTag 。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"export const Placement = /*             */ 0b0000000000010;  // 插入节点\nexport const Update = /*                */ 0b0000000000100;  // 更新fiber\nexport const Deletion = /*              */ 0b0000000001000;  // 删除fiebr\nexport const Snapshot = /*              */ 0b0000100000000;  // 快照\nexport const Passive = /*               */ 0b0001000000000;  // useEffect的副作用\nexport const Callback = /*              */ 0b0000000100000;  // setState的 callback\nexport const Ref = /*                   */ 0b0000010000000;  // ref\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"向上归并-completeunitofwork",children:["向上归并 completeUnitOfWork",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#向上归并-completeunitofwork",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"completeUnitOfWork 的流程是自下向上的，那么 completeUnitOfWork 过程主要做写什么呢？"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"首先 completeUnitOfWork 会将 effectTag 的 Fiber 节点会被保存在一条被称为 effectList 的单向链表中。在 commit 阶段，将不再需要遍历每一个 fiber ，只需要执行更新 effectList 就可以了。"}),"\n",(0,i.jsx)(n.li,{children:"completeWork 阶段对于组件处理 context ；对于元素标签初始化，会创建真实 DOM ，将子孙 DOM 节点插入刚生成的 DOM 节点中；会触发 diffProperties 处理 props ，比如事件收集，style，className 处理，在15章讲到过。"}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"调和顺序",children:["调和顺序",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#调和顺序",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"那么上述写的demo片段，在初始化或者一次更新中调和顺序是怎样的呢？"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"beginWork    -> rootFiber"}),"\n",(0,i.jsx)(n.li,{children:"beginWork    -> Index fiber"}),"\n",(0,i.jsx)(n.li,{children:"beginWork    -> div fiber"}),"\n",(0,i.jsx)(n.li,{children:"beginWork    -> hello,world fiber"}),"\n",(0,i.jsx)(n.li,{children:"completeWork -> hello,world fiber (completeWork返回sibling)"}),"\n",(0,i.jsx)(n.li,{children:"beginWork    -> p fiber"}),"\n",(0,i.jsx)(n.li,{children:"completeWork -> p fiber"}),"\n",(0,i.jsx)(n.li,{children:"beginWork    -> button fiber"}),"\n",(0,i.jsx)(n.li,{children:"completeWork -> button fiber (此时没有sibling，返回return)"}),"\n",(0,i.jsx)(n.li,{children:"completeWork -> div fiber"}),"\n",(0,i.jsx)(n.li,{children:"completeWork -> Index fiber"}),"\n",(0,i.jsx)(n.li,{children:"completeWork -> rootFiber  (完成整个workLoop)"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"没有  《React进阶实践指南》 和 点赞  的 文本fiber的beginWork/completeWork流程，是因为作为一种性能优化手段，针对只有单一文本子节点的Fiber，React会特殊处理。"}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"2-commit阶段",children:["2 commit阶段",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-commit阶段",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"既然完成 render 阶段，接下来将进行第二阶段 commit 阶段。commit 阶段做的事情是："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"一方面是对一些生命周期和副作用钩子的处理，比如 componentDidMount ，函数组件的 useEffect ，useLayoutEffect ；"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["另一方面就是在一次更新中，添加节点（ ",(0,i.jsx)(n.code,{children:"Placement"})," ），更新节点（ ",(0,i.jsx)(n.code,{children:"Update"})," ），删除节点（ ",(0,i.jsx)(n.code,{children:"Deletion"})," ），还有就是一些细节的处理，比如 ref 的处理。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"commit 细分可以分为："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Before mutation"})," 阶段（执行 DOM 操作前）；"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"mutation"})," 阶段（执行 DOM 操作）；"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"layout"})," 阶段（执行 DOM 操作后）"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"-before-mutation",children:["① Before mutation",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-before-mutation",children:"#"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitBeforeMutationEffects() {\n  while (nextEffect !== null) {\n    const effectTag = nextEffect.effectTag;\n    if ((effectTag & Snapshot) !== NoEffect) {\n      const current = nextEffect.alternate;\n      // 调用getSnapshotBeforeUpdates\n      commitBeforeMutationEffectOnFiber(current, nextEffect);\n    }\n    if ((effectTag & Passive) !== NoEffect) {\n       scheduleCallback(NormalPriority, () => {\n          flushPassiveEffects();\n          return null;\n        });\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Before mutation 阶段做的事主要有以下内容："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"因为 Before mutation 还没修改真实的 DOM ，是获取 DOM 快照的最佳时期，如果是类组件有 getSnapshotBeforeUpdate ，那么会执行这个生命周期。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"会异步调用 useEffect ，在生命周期章节讲到 useEffect 是采用异步调用的模式，其目的就是防止同步执行时阻塞浏览器做视图渲染。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"-mutation",children:["② Mutation",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-mutation",children:"#"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitMutationEffects(){\n    while (nextEffect !== null) {\n        if (effectTag & Ref) { /* 置空Ref */\n            const current = nextEffect.alternate;\n            if (current !== null) {\n                commitDetachRef(current);\n            }\n        }\n        switch (primaryEffectTag) {\n            case Placement: {} //  新增元素\n            case Update:{}     //  更新元素\n            case Deletion:{}   //  删除元素\n        }\n    } \n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"mutation 阶段做的事情有："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"置空 ref ，在 ref 章节讲到对于 ref 的处理。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"对新增元素，更新元素，删除元素。进行真实的 DOM 操作。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"-layout",children:["③ Layout",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-layout",children:"#"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"function commitLayoutEffects(root){\n     while (nextEffect !== null) {\n          const effectTag = nextEffect.effectTag;\n          commitLayoutEffectOnFiber(root,current,nextEffect,committedExpirationTime)\n          if (effectTag & Ref) {\n             commitAttachRef(nextEffect);\n          }\n     }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Layout 阶段 DOM 已经更新完毕，Layout 做的事情有："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"commitLayoutEffectOnFiber 对于类组件，会执行生命周期，setState 的callback，对于函数组件会执行 useLayoutEffect 钩子。"}),"\n",(0,i.jsx)(n.li,{children:"如果有 ref ，会重新赋值 ref 。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"接下来对 commit 阶段做一个总结，主要做的事就是执行effectList，更新DOM，执行生命周期，获取ref等操作。"}),"\n",(0,i.jsxs)(n.h3,{id:"3-调和--异步调度-流程总图",children:["3 调和 + 异步调度 流程总图",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-调和--异步调度-流程总图",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"把上一章节和本章节串联起来，调和调度过程，如下图所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"3.jpeg"})}),"\n",(0,i.jsxs)(n.h2,{id:"五-总结",children:["五 总结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这节主要介绍了："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"fiber 的诞生的初衷，以及 fiber 组成，不同种类的 fiber ，fiber 如何建立起联系。"}),"\n",(0,i.jsx)(n.li,{children:"fiber 的更新机制，双缓冲树。"}),"\n",(0,i.jsx)(n.li,{children:"reconciler 调和过程，以及 render 和 commit 两大阶段。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"明白了 fiber 架构，下一节将深入 Hooks 原理 。"})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}let p=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F18.%E5%8E%9F%E7%90%86%E7%AF%87-%20%E8%B0%83%E5%92%8C%E4%B8%8E%20fiber.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 全面认识Fiber",id:"二-全面认识fiber",depth:2},{text:"1 element,fiber,dom三种什么关系？",id:"1-elementfiberdom三种什么关系",depth:3},{text:"2 fiber保存了那些信息",id:"2-fiber保存了那些信息",depth:3},{text:"3 每一个fiber如何建立起关联的",id:"3-每一个fiber如何建立起关联的",depth:3},{text:"三 Fiber更新机制",id:"三-fiber更新机制",depth:2},{text:"1 初始化",id:"1-初始化",depth:3},{text:"2 更新",id:"2-更新",depth:3},{text:"双缓冲树",id:"双缓冲树",depth:3},{text:"四 两大阶段：render和commit",id:"四-两大阶段render和commit",depth:2},{text:"1 render阶段",id:"1-render阶段",depth:3},{text:"向下调和beginWork",id:"向下调和beginwork",depth:4},{text:"向上归并 completeUnitOfWork",id:"向上归并-completeunitofwork",depth:4},{text:"调和顺序",id:"调和顺序",depth:4},{text:"2 commit阶段",id:"2-commit阶段",depth:3},{text:"① Before mutation",id:"-before-mutation",depth:4},{text:"② Mutation",id:"-mutation",depth:4},{text:"③ Layout",id:"-layout",depth:4},{text:"3 调和 + 异步调度 流程总图",id:"3-调和--异步调度-流程总图",depth:3},{text:"五 总结",id:"五-总结",depth:2}],title:"18.原理篇- 调和与 fiber",headingTitle:"18.原理篇- 调和与 fiber",frontmatter:{}}}}]);