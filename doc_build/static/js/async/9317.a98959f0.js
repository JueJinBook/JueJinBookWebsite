"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["9317"],{981953:function(n,e,t){t.r(e),t.d(e,{default:()=>a});var o=t(552676),r=t(740453);let i=t.p+"static/image/d7d17908f2ec58493eea8f27c861a082.b42545c9.webp",s=t.p+"static/image/575a38e6c46e7ace5229b51aa4bc23f2.5ca5d19d.webp";function c(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",h3:"h3",strong:"strong",img:"img",pre:"pre"},(0,r.ah)(),n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.h1,{id:"25实践篇-实现mini-router",children:["25.实践篇-实现mini-Router",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#25实践篇-实现mini-router",children:"#"})]}),"\n",(0,o.jsxs)(e.h2,{id:"一-前言",children:["一 前言",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["本章节，我们会从 0 到 1 实现一个 React 路由功能，这里可以称之为 ",(0,o.jsx)(e.code,{children:"mini-Router"}),"。实现的过程中会包含如下知识点："]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"路由更新流程与原理；"}),"\n",(0,o.jsx)(e.li,{children:"自定义 hooks 编写与使用；"}),"\n",(0,o.jsx)(e.li,{children:"context 实践；"}),"\n",(0,o.jsx)(e.li,{children:"hoc 编写与使用。"}),"\n"]}),"\n",(0,o.jsxs)(e.h2,{id:"二-设计思路",children:["二 设计思路",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二-设计思路",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["整个 mini-Router 还是采用 ",(0,o.jsx)(e.code,{children:"history"})," 库，也就是 mini-Router  需要完成的是 ",(0,o.jsx)(e.code,{children:"React-Router"})," 和 ",(0,o.jsx)(e.code,{children:"React-Router-DOM"})," 核心部分。今天编写的 mini-Router 是在 BrowserHistory 模式下。"]}),"\n",(0,o.jsxs)(e.h3,{id:"1-建立目标",children:["1 建立目标",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-建立目标",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"接下来要实现的具体功能如下："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"组件层面："})," 在组件层面，需要实现提供路由状态的 Router ，控制渲染的 Route ，匹配唯一路由的 Switch 。"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"api层面："})," 提供获取 history 对象的 useHistory 方法，获取 location 对象的 useLocation 方法。"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"高阶组件层面："})," 对于不是路由的页面，提供 withRouter，能够获取当前路由状态。"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"额外功能："})," 之前有很多同学问过我，在 React 应用中，可不可以提供有方法监听路由改变，所以 mini-Router 需要做的是增加路由监听器，当路由改变，触发路由监听器。"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.h3,{id:"2-设计功能图",children:["2 设计功能图",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-设计功能图",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:s,alt:"2.jpg"})}),"\n",(0,o.jsxs)(e.h2,{id:"三-代码实现",children:["三 代码实现",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#三-代码实现",children:"#"})]}),"\n",(0,o.jsxs)(e.h3,{id:"1-组件层面",children:["1 组件层面",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-组件层面",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"提供路由更新派发——Router"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import React ,{ useCallback, useState , useEffect ,createContext, useMemo  } from 'react'\nimport { createBrowserHistory as createHistory  } from 'history'\n\nexport const RouterContext = createContext()\nexport let rootHistory = null\n\nexport default function Router(props){\n     /* 缓存history属性 */\n     const history = useMemo(() => {\n          rootHistory = createHistory()\n          return rootHistory\n     },[])\n     const [ location, setLocation ] = useState(history.location)\n     useEffect(()=>{\n          /* 监听location变化，通知更新 */\n          const unlisten = history.listen((location)=>{\n               setLocation(location)\n          })\n          return function () {\n               unlisten && unlisten()\n          }\n     },[])\n     return <RouterContext.Provider\n         value={{\n               location,\n               history,\n               match: { path: '/', url: '/', params: {}, isExact: location.pathname === '/' }\n          }}\n            >\n          {props.children}\n     </RouterContext.Provider>\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:"Router 设计思路："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"创建一个 React Context ，用于保存路由状态。用 Provider 传递 context 。"}),"\n",(0,o.jsx)(e.li,{children:"用一个 useMemo 来缓存 BrowserHistory 模式下的产生的路由对象 history ，这里有一个小细节，就是产生 history 的同时，把它赋值给了一个全局变量 rootHistory ，为什么这么做呢，答案一会将揭晓。"}),"\n",(0,o.jsx)(e.li,{children:"通过 useEffect 进行真正的路由监听，当路由改变，通过 useState ，改变 location 对象，会改变 Provider 里面 value 的内容，通知消费 context 的 Route ，Switch 等组件更新。 useEffect 的 destory 用于解绑路由监听器。"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"控制更新——Route"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import React , { useContext } from 'react'\nimport { matchPath } from 'react-router'\nimport { RouterContext } from './Router'\n\nfunction  Route(props) {\n    const context = useContext(RouterContext)\n    /* 获取location对象 */\n    const location = props.location || context.location\n    /* 是否匹配当前路由，如果父级有switch，就会传入computedMatch来精确匹配渲染此路由 */\n    const match = props.computedMatch ? props.computedMatch\n                 : props.path ?  matchPath(location.pathname,props) : context.match\n     /* 这个props用于传递给路由组件 */\n    const newRouterProps = { ...context, location, match  }\n    let { children, component, render  } = props\n    if(Array.isArray(children) && children.length ===0 ) children = null\n    let renderChildren = null\n    if(newRouterProps.match){\n        if(children){\n            /* 当Router 是 props children 或者 render props 形式。*/\n            renderChildren =  typeof children === 'function' ? children(newRouterProps) : children\n        }else if(component){\n            /*  Route有component属性 */\n            renderChildren = React.createElement(component, newRouterProps)\n        }else if(render){\n            /*  Route有render属性 */\n            renderChildren = render(newRouterProps)\n        }\n    }\n    /* 逐层传递上下文 */\n    return <RouterContext.Provider  value={newRouterProps}  >\n        {renderChildren}\n    </RouterContext.Provider>\n}\nexport default Route\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"用 useContext 提取出路由上下文，当路由状态 location 改变，因为消费context 的组件都会重新渲染，当前Route会组件重新渲染，通过当前的 location 的 pathname 进行匹配，判断当前组件是否渲染，因为 Route 子组件有四种形式，所以会优先进行判断。"}),"\n",(0,o.jsx)(e.li,{children:"为了让 Route 的子组件访问到当前 Route 的信息，所以要选择通过 Provider 逐层传递的特点，再一次传递当前 Route 的信息，这样也能够让嵌套路由更简单的实现。"}),"\n",(0,o.jsx)(e.li,{children:"因为如果父级元素是 Switch ，就不需要匹配路由了，因为这些都是 Switch 该干的活，所以用 computedMatch 来识别是否上一层的 Switch 已经匹配完成了。"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"匹配正确路由—— Switch"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"\nimport React, { useContext } from 'react'\nimport { matchPath } from 'react-router'\n\nimport { RouterContext } from '../component/Router'\n\nexport default function Switch(props){\n    const context = useContext(RouterContext)\n    const location = props.location || context.location\n    let children , match\n    /* 遍历children Route 找到匹配的那一个 */\n    React.Children.forEach(props.children,child=>{\n        if(!match && React.isValidElement(child) ){ /* 路由匹配并为React.element元素的时候 */\n           const path = child.props.path //获取Route上的path\n           children = child /* 匹配的children */\n           match = path ? matchPath(location.pathname,{ ...child.props }) : context.match /* 计算是否匹配 */\n        }\n    })\n    /* 克隆一份Children，混入 computedMatch 并渲染。 */\n    return  match ? React.cloneElement(children, { location, computedMatch: match }) : null\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Switch 也要订阅来自 context 的变化，然后对 children 元素，进行唯一性的路由匹配。"}),"\n",(0,o.jsxs)(e.li,{children:["通过",(0,o.jsx)(e.code,{children:"React.Children.forEach"}),"遍历子 Route，然后通过 matchPath 进行匹配，如果匹配到组件，将克隆组件，混入 computedMatch，location 等信息。"]}),"\n"]}),"\n",(0,o.jsxs)(e.h3,{id:"2-hooksapi层面",children:["2 hooksAPI层面",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-hooksapi层面",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"为了让 mini-Router 每一个组件都能自由获取路由状态，这里编写了两个自定义 hooks。"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"获取history对象"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { useContext } from 'react'\nimport { RouterContext  } from '../component/Router'\n/* 用useContext获取上下文中的history对象 */\nexport default function useHistory() {\n    return useContext(RouterContext).history\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"用 useContext 获取上下文中的 history 对象。"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"获取 location 对象"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { useContext } from 'react'\nimport { RouterContext  } from '../component/Router'\n/* 用useContext获取上下文中的location对象 */\nexport default function  useLocation() {\n    return useContext(RouterContext).location\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"用 useContext 获取上下文中的 location 对象。"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"上述的两个 hooks 编写起来非常简单，但是也要注意一个问题，两个 hooks 本质上都是消费了 context ，所以用到上述两个 hook 的组件，当context 变化，都会重新渲染。接下来增加一个新的功能，监听路由改变。"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"监听路由改变"}),"，和上面两种情况不同，不想订阅 context 变化，而带来的更新作用，另外一点就是这种监听有可能在 Router 包裹的组件层级之外，那么如何达到目的呢？这个时候在 Router 中的 rootHistory 就派上了用场，这个 rootHistory 目的就是为了全局能够便捷的获取 history 对象。接下来具体实现一个监听路由变化的自定义 hooks 。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import { useEffect } from 'react'\nimport { rootHistory } from '../component/Router'\n\n/* 监听路由改变 */\nfunction useListen(cb) {\n    useEffect(()=>{\n        if(!rootHistory) return ()=> {}\n        /* 绑定路由事件监听器 */\n        const unlisten = rootHistory.listen((location)=>{\n             cb && cb(location)\n        })\n        return function () {\n            unlisten && unlisten()\n        }\n    },[])\n}\nexport default useListen\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"如果 rootHistory 不存在，那么这个 hooks 也就没有任何作用，直接返回空函数就可以了。"}),"\n",(0,o.jsx)(e.li,{children:"如果 rootHistory 存在，通过 useEffect ，绑定监听器，然后在销毁函数中，解绑监听器。"}),"\n"]}),"\n",(0,o.jsxs)(e.h3,{id:"3-高阶组件层面",children:["3 高阶组件层面",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-高阶组件层面",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"希望通过一个 HOC 能够自由获取路由的状态。所以要实现一个 react-router 中 withRouter 功能。"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"获取路由状态——withRouter"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import React , { useContext } from 'react'\nimport hoistStatics from 'hoist-non-react-statics'\n\nimport { RouterContext  } from '../component/Router'\n\nexport default function withRouter(Component){\n    const WrapComponent = (props) =>{\n        const { wrappedComponentRef, ...remainingProps } = props\n        const context = useContext(RouterContext)\n        return  <Component {...remainingProps}\n            ref={wrappedComponentRef}\n            {...context}\n                />\n    }\n    return hoistStatics(WrapComponent,Component)\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"在高阶组件的包装组件中，用useContext获取路由状态，并传递给原始组件。"}),"\n",(0,o.jsxs)(e.li,{children:["通过",(0,o.jsx)(e.code,{children:"hoist-non-react-statics"}),"继承原始组件的静态属性。"]}),"\n"]}),"\n",(0,o.jsxs)(e.h3,{id:"4-入口文件",children:["4 入口文件",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-入口文件",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"完成了核心 api 和组件，接下来需要出口文件，把这些方法暴露出去。"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"//component\nimport Router ,{ RouterContext } from './component/Router'\nimport Route from './component/Route'\nimport Switch from './component/Switch'\n//hooks\nimport useHistory from './hooks/useHistory'\nimport useListen from './hooks/useListen'\nimport useLocation from './hooks/useLocation'\n//hoc\nimport withRouter from './hoc/withRouter'\n\nexport {\n    Router,\n    Switch,\n    Route,\n    RouterContext,\n    useHistory,\n    useListen,\n    useLocation,\n    withRouter\n}\n"})}),"\n",(0,o.jsxs)(e.h2,{id:"四-验证效果",children:["四 验证效果",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#四-验证效果",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["一个简单的路由库就实现了，接下来验证一下",(0,o.jsx)(e.code,{children:"mini-Router"}),"的效果："]}),"\n",(0,o.jsxs)(e.h3,{id:"配置路由",children:["配置路由",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#配置路由",children:"#"})]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"import React from 'react'\nimport { Router, Route, useHistory, useListen, Switch } from './router'\n\n/* 引用业务组件 */\nimport Detail from './testPage/detail'  /* 详情页 */\nimport Home  from './testPage/home'     /* 首页 */\nimport List from './testPage/list'      /* 列表页 */\nimport './index.scss'\n\nconst menusList = [\n    {\n        name:'首页',\n        path:'/home'\n    },\n    {\n        name:'列表',\n        path:'/list'\n    },\n    {\n        name:'详情',\n        path:'/detail'\n    }\n]\n/**/\nfunction Nav() {\n    const history  = useHistory()\n    /* 路由跳转 */\n    const RouterGo = (url) =>  history.push(url)\n    const path = history.location.pathname\n    return <div>\n        {\n            menusList.map((item=><span className={`nav ${ item.path===path ? 'active'  : '' }`} key={item.path}\n                onClick={()=>RouterGo(item.path)} >{item.name}</span>))\n        }\n    </div>\n}\n\nfunction  Top() {\n    /* 路由监听 */\n    useListen((location)=>{\n        console.log( '当前路由是：', location.pathname)\n    })\n    console.log(111)\n    return <div>--------top------</div>\n}\nfunction Index() {\n    console.log('根组件渲染')\n    return <Router>\n        <Top/>\n        <Nav />\n        <Switch>\n            <Route component={Home} path=\"/home\"></Route>\n            <Route  component={Detail} path=\"/detail\" />\n            <Route path=\"/list\" render={(props)=> <List {...props} />} />\n        </Switch>\n        <div>--------bottom------</div>\n    </Router>\n}\n\nexport default Index\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"通过 Router，Route，Switch 给首页，列表，详情三个页面配置路由。"}),"\n",(0,o.jsx)(e.li,{children:"Top 里面进行路由监听，路由变化，组件不渲染。"}),"\n",(0,o.jsx)(e.li,{children:"Nav 里改变路由，切换页面。"}),"\n"]}),"\n",(0,o.jsxs)(e.h3,{id:"业务页面",children:["业务页面",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#业务页面",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"首页"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"export default function Home(){\n    return <div>\n        hello,world。\n        let us learn React!\n        <HomeOne />\n    </div>\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"高阶组件包裹的 HomeOne"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"@withRouter\nclass HomeOne extends React.Component{\n    RouteGo=()=>{\n        const { history } = this.props\n        history.push('/detail')\n    }\n    render(){\n        return <div>\n            <p>测试HOC——withRouter</p>\n            <button onClick={this.RouteGo} >跳转到详情页</button>\n        </div>\n    }\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"列表页面"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"export default function List(){\n    return <div>\n        <li>React.js</li>\n        <li>Vue.js</li>\n        <li>nodejs</li>\n    </div>\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"详情页面"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"export default function  Index() {\n    return <div>\n        <p>小册名称：《React进阶实践指南》</p>\n        <p>作者：我不是外星人</p>\n    </div>\n}\n"})}),"\n",(0,o.jsxs)(e.h3,{id:"效果",children:["效果",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#效果",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:i,alt:"1.gif"})}),"\n",(0,o.jsxs)(e.h2,{id:"五-总结",children:["五 总结",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"本章节通过实现一个 mini-router，来贯穿前面的章节中的内容。接下来对这节的收获做一个总结："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"强化 React-Router 的核心原理，Router，Route 等组件。"}),"\n",(0,o.jsx)(e.li,{children:"渲染控制，操作 children 。"}),"\n",(0,o.jsx)(e.li,{children:"高阶组件混入路由状态。"}),"\n",(0,o.jsx)(e.li,{children:"hooks 的使用指南，所有组件都是用 hooks 编写的。"}),"\n",(0,o.jsx)(e.li,{children:"自定义 hooks 的编写。"}),"\n"]})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}let a=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F25.%E5%AE%9E%E8%B7%B5%E7%AF%87-%E5%AE%9E%E7%8E%B0mini-Router.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 设计思路",id:"二-设计思路",depth:2},{text:"1 建立目标",id:"1-建立目标",depth:3},{text:"2 设计功能图",id:"2-设计功能图",depth:3},{text:"三 代码实现",id:"三-代码实现",depth:2},{text:"1 组件层面",id:"1-组件层面",depth:3},{text:"2 hooksAPI层面",id:"2-hooksapi层面",depth:3},{text:"3 高阶组件层面",id:"3-高阶组件层面",depth:3},{text:"4 入口文件",id:"4-入口文件",depth:3},{text:"四 验证效果",id:"四-验证效果",depth:2},{text:"配置路由",id:"配置路由",depth:3},{text:"业务页面",id:"业务页面",depth:3},{text:"效果",id:"效果",depth:3},{text:"五 总结",id:"五-总结",depth:2}],title:"25.实践篇-实现mini-Router",headingTitle:"25.实践篇-实现mini-Router",frontmatter:{}}}}]);