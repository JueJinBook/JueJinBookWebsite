"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["44023"],{407898:function(e,n,i){i.r(n),i.d(n,{default:()=>j});var s=i(552676),a=i(740453);let t=i.p+"static/image/deb60a52ef48d4fd803ca47f624d08e1.d1acbc5f.png",r=i.p+"static/image/dc3d91b6dd12c77d6ea8c6b2503f8d70.431bd47b.png",l=i.p+"static/image/7c1171d69cbd5787db34515c89d5f0d3.6b5b67ea.png",c=i.p+"static/image/76f139329829caca202be4ea9c785198.4386a600.png",d=i.p+"static/image/c86bf18ef1ddfc9a378af61eb4c0581e.a633f91a.png",h=i.p+"static/image/a4ece22681c5e3ecbd8e8f7233a4b6f7.8b4f5a98.png",p=i.p+"static/image/121d30f242986952687180778e3cad91.991c6485.png";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",h3:"h3",pre:"pre",code:"code",ul:"ul",li:"li",h4:"h4",strong:"strong"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"7traverse-的-pathscopevisitor",children:["7.traverse 的 path、scope、visitor",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7traverse-的-pathscopevisitor",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"源码 parse 成 AST 之后，需要进行 AST 的遍历和增删改（transform）。那么 transform 的流程是什么样的？"}),"\n",(0,s.jsx)(n.p,{children:"babel 会递归遍历 AST，遍历过程中处理到不同的 AST 会调用不同的 visitor 函数来实现 transform。这其实是一种设计模式，叫做访问者模式："}),"\n",(0,s.jsxs)(n.h2,{id:"visitor-模式",children:["visitor 模式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#visitor-模式",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"visitor 模式（访问者模式）是 23 种经典设计模式中的一种。visitor 模式的思想是：当被操作的对象结构比较稳定，而操作对象的逻辑经常变化的时候，通过分离逻辑和对象结构，使得他们能独立扩展。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"如图，Element 和 Visitor 分别代表对象结构和操作逻辑，两者可以独立扩展，在 Client 里面来组合两者，使用 visitor 操作 element。这就是 visitor 模式。"}),"\n",(0,s.jsx)(n.p,{children:"对应到 babel traverse 的实现，就是 AST 和 visitor 分离，在 traverse（遍历）AST 的时候，调用注册的 visitor 来对其进行处理。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"这样 AST 是独立的扩展的，visitor 是独立的扩展的，两者可以各自独立扩展单还能轻易地结合在一起。"}),"\n",(0,s.jsxs)(n.h2,{id:"path-和-scope",children:["path 和 scope",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#path-和-scope",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"path 是记录遍历路径的 api，它记录了父子节点的引用，还有很多增删改查 AST 的 api："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那 path 大概有哪些属性和方法呢？"}),"\n",(0,s.jsxs)(n.h3,{id:"path",children:["path",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#path",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"path 大概有这些属性和方法，不需要记，后面案例用到的时候知道是啥就行。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"path {\n    // 属性：\n    node \n    parent\n    parentPath\n    scope\n    hub\n    container\n    key\n    listKey\n    \n    // 方法\n    get(key) \n    set(key, node)\n    inList()\n    getSibling(key) \n    getNextSibling()\n    getPrevSibling()\n    getAllPrevSiblings()\n    getAllNextSiblings()\n    isXxx(opts)\n    assertXxx(opts)\n    find(callback)\n    findParent(callback)\n    \n    insertBefore(nodes)\n    insertAfter(nodes)\n    replaceWith(replacement)\n    replaceWithMultiple(nodes)\n    replaceWithSourceString(replacement)\n    remove()\n    \n    traverse(visitor, state)\n    skip()\n    stop()\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"它们各自的含义："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"path.node 当前 AST 节点"}),"\n",(0,s.jsx)(n.li,{children:"path.parent 父 AST 节点"}),"\n",(0,s.jsx)(n.li,{children:"path.parentPath 父 AST 节点的 path"}),"\n",(0,s.jsx)(n.li,{children:"path.scope 作用域"}),"\n",(0,s.jsx)(n.li,{children:"path.hub 可以通过 path.hub.file 拿到最外层 File 对象， path.hub.getScope 拿到最外层作用域，path.hub.getCode 拿到源码字符串"}),"\n",(0,s.jsx)(n.li,{children:"path.container 当前 AST 节点所在的父节点属性的属性值"}),"\n",(0,s.jsx)(n.li,{children:"path.key 当前 AST 节点所在父节点属性的属性名或所在数组的下标"}),"\n",(0,s.jsx)(n.li,{children:"path.listkey 当前 AST 节点所在父节点属性的属性值为数组时 listkey 为该属性名，否则为 undefined"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"containerlistkeykey",children:["container、listkey、key",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#containerlistkeykey",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这几个属性不太常用，简单介绍一下。"}),"\n",(0,s.jsx)(n.p,{children:"因为 AST 节点要挂在父 AST 节点的某个属性上，那个属性的属性值就是这个 AST 节点的 container。"}),"\n",(0,s.jsx)(n.p,{children:"比如 CallExpression 有 callee 和 arguments 属性，那么对于 callee 的 AST 节点来说，callee 的属性值就是它的 container，而 callee 就是它的 key。"}),"\n",(0,s.jsx)(n.p,{children:"因为不是一个列表，所以 listkey 是 undefined。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而 BlockStatement 有 body 属性，是一个数组，对于数组中的每一个 AST 来说，这个数组就是它们的 container，而 listKey 是 body，key 则是下标。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"path-的方法",children:["path 的方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#path-的方法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"path 有如下方法，同样也不需要记："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"get(key) 获取某个属性的 path"}),"\n",(0,s.jsx)(n.li,{children:"set(key, node) 设置某个属性的值"}),"\n",(0,s.jsx)(n.li,{children:"getSibling(key) 获取某个下标的兄弟节点"}),"\n",(0,s.jsx)(n.li,{children:"getNextSibling() 获取下一个兄弟节点"}),"\n",(0,s.jsx)(n.li,{children:"getPrevSibling() 获取上一个兄弟节点"}),"\n",(0,s.jsx)(n.li,{children:"getAllPrevSiblings() 获取之前的所有兄弟节点"}),"\n",(0,s.jsx)(n.li,{children:"getAllNextSiblings() 获取之后的所有兄弟节点"}),"\n",(0,s.jsx)(n.li,{children:"find(callback) 从当前节点到根节点来查找节点（包括当前节点），调用 callback（传入 path）来决定是否终止查找"}),"\n",(0,s.jsx)(n.li,{children:"findParent(callback) 从当前节点到根节点来查找节点（不包括当前节点），调用 callback（传入 path）来决定是否终止查找"}),"\n",(0,s.jsx)(n.li,{children:"inList() 判断节点是否在数组中，如果 container 为数组，也就是有 listkey 的时候，返回 true"}),"\n",(0,s.jsx)(n.li,{children:"isXxx(opts) 判断当前节点是否是某个类型，可以传入属性和属性值进一步判断，比如path.isIdentifier({name: 'a'})"}),"\n",(0,s.jsx)(n.li,{children:"assertXxx(opts) 同 isXxx，但是不返回布尔值，而是抛出异常"}),"\n",(0,s.jsx)(n.li,{children:"insertBefore(nodes) 在之前插入节点，可以是单个节点或者节点数组"}),"\n",(0,s.jsx)(n.li,{children:"insertAfter(nodes) 在之后插入节点，可以是单个节点或者节点数组"}),"\n",(0,s.jsx)(n.li,{children:"replaceWith(replacement) 用某个节点替换当前节点"}),"\n",(0,s.jsx)(n.li,{children:"replaceWithMultiple(nodes) 用多个节点替换当前节点"}),"\n",(0,s.jsx)(n.li,{children:"replaceWithSourceString(replacement) 解析源码成 AST，然后替换当前节点"}),"\n",(0,s.jsx)(n.li,{children:"remove() 删除当前节点"}),"\n",(0,s.jsx)(n.li,{children:"traverse(visitor, state) 遍历当前节点的子节点，传入 visitor 和 state（state 是不同节点间传递数据的方式）"}),"\n",(0,s.jsx)(n.li,{children:"skip() 跳过当前节点的子节点的遍历"}),"\n",(0,s.jsx)(n.li,{children:"stop() 结束所有遍历"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"作用域-pathscope",children:["作用域 path.scope",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#作用域-pathscope",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"scope 是作用域信息，javascript 中能生成作用域的就是模块、函数、块等，而且作用域之间会形成嵌套关系，也就是作用域链。babel 在遍历的过程中会生成作用域链保存在 path.scope 中。"}),"\n",(0,s.jsx)(n.p,{children:"属性和方法大概有这些"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"path.scope {\n    bindings\n    block\n    parent\n    parentBlock\n    path\n    references\n \n    dump()\n    getAllBindings()\n    getBinding(name)\n    hasBinding(name)\n    getOwnBinding(name)\n    parentHasBinding(name)\n    removeBinding(name)\n    moveBindingTo(name, scope)\n    generateUid(name)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"各自的含义："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"scope.bindings 当前作用域内声明的所有变量"}),"\n",(0,s.jsx)(n.li,{children:"scope.block 生成作用域的 block，详见下文"}),"\n",(0,s.jsx)(n.li,{children:"scope.path 生成作用域的节点对应的 path"}),"\n",(0,s.jsx)(n.li,{children:"scope.references 所有 binding 的引用对应的 path，详见下文"}),"\n",(0,s.jsx)(n.li,{children:"scope.dump() 打印作用域链的所有 binding 到控制台"}),"\n",(0,s.jsx)(n.li,{children:"scope.parentBlock 父级作用域的 block"}),"\n",(0,s.jsx)(n.li,{children:"getAllBindings() 从当前作用域到根作用域的所有 binding 的合并"}),"\n",(0,s.jsx)(n.li,{children:"getBinding(name) 查找某个 binding，从当前作用域一直查找到根作用域"}),"\n",(0,s.jsx)(n.li,{children:"getOwnBinding(name) 从当前作用域查找 binding"}),"\n",(0,s.jsx)(n.li,{children:"parentHasBinding(name, noGlobals) 查找某个 binding，从父作用域查到根作用域，不包括当前作用域。可以通过 noGlobals 参数指定是否算上全局变量（比如console，不需要声明就可用），默认是 false"}),"\n",(0,s.jsx)(n.li,{children:"removeBinding(name)  删除某个 binding"}),"\n",(0,s.jsx)(n.li,{children:"hasBinding(name, noGlobals) 从当前作用域查找 binding，可以指定是否算上全局变量，默认是 false"}),"\n",(0,s.jsx)(n.li,{children:"moveBindingTo(name, scope) 把当前作用域中的某个 binding 移动到其他作用域"}),"\n",(0,s.jsx)(n.li,{children:"generateUid(name) 生成作用域内唯一的名字，根据 name 添加下划线，比如 name 为 a，会尝试生成 _a，如果被占用就会生成 __a，直到生成没有被使用的名字。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"scopeblock",children:["scope.block",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#scopeblock",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"能形成 scope 的有这些节点，这些节点也叫 block 节点。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export type Scopable =\n  | BlockStatement\n  | CatchClause\n  | DoWhileStatement\n  | ForInStatement\n  | ForStatement\n  | FunctionDeclaration\n  | FunctionExpression\n  | Program\n  | ObjectMethod\n  | SwitchStatement\n  | WhileStatement\n  | ArrowFunctionExpression\n  | ClassExpression\n  | ClassDeclaration\n  | ForOfStatement\n  | ClassMethod\n  | ClassPrivateMethod\n  | StaticBlock\n  | TSModuleBlock;\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们可以通过 path.scope.block 来拿到所在的块对应的节点，通过 path.scope.parentBlock 拿到父作用域对应的块节点。"}),"\n",(0,s.jsx)(n.p,{children:"一般情况下我们不需要拿到生成作用域的块节点，只需要通过 path.scope 拿到作用域的信息，通过 path.scope.parent 拿到父作用域的信息。"}),"\n",(0,s.jsxs)(n.h4,{id:"scopebindingsscopereferences重点",children:["scope.bindings、scope.references（重点）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#scopebindingsscopereferences重点",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["作用域中保存的是声明的变量和对应的值，",(0,s.jsx)(n.strong,{children:"每一个声明叫做一个binding"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"比如这样一段代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const a = 1;\n"})}),"\n",(0,s.jsx)(n.p,{children:"它的 path.scope.bindings 是这样的"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"bindings: {\n    a: {\n        constant: true,\n        constantViolations: [],\n        identifier: {type: 'Identifier', ...}\n        kind:'const',\n        path: {node,...}\n        referenced: false\n        referencePaths: [],\n        references: 0,\n        scope: ...\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"因为我们在当前 scope 中声明了 a 这个变量，所以 bindings 中有 a 的 binding，每一个 binding 都有 kind，这代表绑定的类型："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"var、let、const 分别代表 var、let、const 形式声明的变量"}),"\n",(0,s.jsx)(n.li,{children:"param 代表参数的声明"}),"\n",(0,s.jsx)(n.li,{children:"module 代表 import 的变量的声明"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"binding 有多种 kind，代表变量是用不同的方式声明的。"}),"\n",(0,s.jsx)(n.p,{children:"binding.identifier 和 binding.path，分别代表标识符、整个声明语句。"}),"\n",(0,s.jsx)(n.p,{children:"声明之后的变量会被引用和修改，binding.referenced 代表声明的变量是否被引用，binding.constant 代表变量是否被修改过。如果被引用了，就可以通过 binding.referencePaths 拿到所有引用的语句的 path。如果被修改了，可以通过 binding.constViolations 拿到所有修改的语句的 path。"}),"\n",(0,s.jsx)(n.p,{children:"path 的 api 还是比较多的，这也是 babel 最强大的地方。主要是操作当前节点、当前节点的父节点、兄弟节点，作用域，以及增删改的方法。"}),"\n",(0,s.jsxs)(n.h2,{id:"state",children:["state",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#state",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"state 是遍历过程中 AST 节点之间传递数据的方式。插件的 visitor 中，第一个参数是 path，第二个参数就是 state。"}),"\n",(0,s.jsx)(n.p,{children:"插件可以从 state 中拿到 opts，也就是插件的配置项，也可以拿到 file 对象，file 中有一些文件级别的信息，这个也可以从 path.hub.file 中拿。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"state {\n    file\n    opts\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以在遍历的过程中在 state 中存一些状态信息，用于后续的 AST 处理。"}),"\n",(0,s.jsxs)(n.h2,{id:"ast-的别名",children:["AST 的别名",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ast-的别名",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"遍历的时候要指定 visitor 处理的 AST，有的时候需要对多个节点做同样的处理，babel 支持指定多个 AST 类型，也可以通过别名指定一系列类型。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"  // 单个 AST 类型\n  FunctionDeclaration(path, state) {},\n  // 多个 AST 类型\n  'FunctionDeclaration|VariableDeclaration'(path, state) {}\n  // AST 类型别名\n  Declaration(){}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以在",(0,s.jsx)(n.a,{href:"https://babeljs.io/docs/en/babel-types",target:"_blank",rel:"noopener noreferrer",children:"文档中"}),"查到某个 AST 类型的别名是啥，某个别名都包含哪些 AST 类型可以在",(0,s.jsx)(n.a,{href:"https://github.com/babel/babel/blob/main/packages/babel-types/src/ast-types/generated/index.ts#L2489-L2535",target:"_blank",rel:"noopener noreferrer",children:"babel-types的类型定义"}),"处查。"]}),"\n",(0,s.jsx)(n.p,{children:"可以把 @babel/types 源码下载下来看，类型定义在 src/ast-types/generated 目录下，这样可以利用 ide 的功能方便的查看每种 alias 的具体 AST 类型。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["所有的 AST 相关的信息都可以在",(0,s.jsx)(n.a,{href:"https://github.com/babel/babel/blob/main/packages/babel-types/src/definitions/core.ts",target:"_blank",rel:"noopener noreferrer",children:"babel-types"}),"里查看，每一个 AST 节点怎么创建、怎么校验、怎么遍历，其实都与 AST 的结构有关系，这些都在 babel-types 里面定义。"]}),"\n",(0,s.jsx)(n.p,{children:"比如 if 就定义了有哪些属性可以遍历、别名是什么，每一个属性怎么校验，然后会根据这些规则生成xxx，isXxx，assertXxx等api用于创建、判断AST节点。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这一节我们学习了 visitor 模式，通过对象和操作分离的方式使得 AST 和 visitor 可以独立扩展，还可以轻易的结合在一起。"}),"\n",(0,s.jsx)(n.p,{children:"然后学习了 babel 强大的 path，包括它的属性和操作 AST 的 api，以及作用域 scope 的一些概念和 api。"}),"\n",(0,s.jsx)(n.p,{children:"path 的 api 比较多，马上消化不太现实，不用着急，后面实战会大量用到。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F7.traverse%20%E7%9A%84%20path%E3%80%81scope%E3%80%81visitor.md"]={toc:[{text:"visitor 模式",id:"visitor-模式",depth:2},{text:"path 和 scope",id:"path-和-scope",depth:2},{text:"path",id:"path",depth:3},{text:"container、listkey、key",id:"containerlistkeykey",depth:4},{text:"path 的方法",id:"path-的方法",depth:3},{text:"作用域 path.scope",id:"作用域-pathscope",depth:3},{text:"scope.block",id:"scopeblock",depth:4},{text:"scope.bindings、scope.references（重点）",id:"scopebindingsscopereferences重点",depth:4},{text:"state",id:"state",depth:2},{text:"AST 的别名",id:"ast-的别名",depth:2},{text:"总结",id:"总结",depth:2}],title:"7.traverse 的 path、scope、visitor",headingTitle:"7.traverse 的 path、scope、visitor",frontmatter:{}}}}]);