"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["30478"],{956514:function(e,n,r){r.r(n),r.d(n,{default:()=>P});var c=r(552676),s=r(740453);let d=r.p+"static/image/bd4daa9d0e0ab735be4449ef01e58c8e.89275cbf.webp",o=r.p+"static/image/320850ffec0ae56e6425d0a432709ce1.0735a916.webp",i=r.p+"static/image/68ee02ee589103b6904bea45b1431f36.a6883f87.webp",l=r.p+"static/image/b4c3de3ce9d67c5b1e1e0914a6cf3862.39553850.webp",a=r.p+"static/image/c5f6c4550733be2c27912b537cf08739.f520d62b.webp",h=r.p+"static/image/421480d21e082ab4d4cd5871c55c8904.8f784d66.webp",x=r.p+"static/image/f1594a46b2341d6981807c16b793c317.2a13a289.webp",t=r.p+"static/image/a30d626d1bb0f167bb0fa4b068653498.5e840ad7.webp",j=r.p+"static/image/165d8227de26b2dcea62d33a0740646a.2698abd1.webp",A=r.p+"static/image/f313df3e65a8be9ed855d733117e1d4a.601c7dcf.webp",m=r.p+"static/image/2dd7942b11d6eadcc6de064dd5d62bdd.ea41b3cf.webp",p=r.p+"static/image/89ffc3b07e2917c911699abb39d5cf7b.a91a9114.webp",S=r.p+"static/image/dd47e1c57347ba3fbf765be56cd76d9d.c74561bc.webp",b=r.p+"static/image/9e675b639c683a357d6191279dfed95b.69461a92.webp",g=r.p+"static/image/124a8d3ce6168ffa927e3c8261d9e3dc.189cb341.webp",C=r.p+"static/image/2db9a398f350e49be5715120cd2cf84b.55517803.webp",f=r.p+"static/image/66d0416c4b10943c8caf89ded586dbd4.7718f26b.webp",u=r.p+"static/image/ababe450e574b3d4206da4b6829056ef.205c4a19.webp",O=r.p+"static/image/0a454832d089890e3cf5357484e46b69.cfeabda0.webp",w=r.p+"static/image/4e0bca87fa26c0536427d9c187f51468.1defc388.webp",D=r.p+"static/image/5580bd5ee58379781945d2f2173d1292.4991c897.webp",H=r.p+"static/image/83deff07cd4301e879e1f06a449c6ecc.cd2fad42.webp",y=r.p+"static/image/1b56db6629a4776662e53085c6426caf.1fbe5c70.webp",v=r.p+"static/image/c9bd4bf3c81571cac9886e62042cbffb.ec0d95ee.webp",k=r.p+"static/image/e0b037fc4649c4f6d0cf7c27dbd9ba8a.b9b12c85.webp",N=r.p+"static/image/ddb79464d191d721e74d3864562d8afb.1d07f798.webp",T=r.p+"static/image/966a129697a6eb70996c9337f60c3f8a.fc7b5d4a.webp",q=r.p+"static/image/1b8b1f1460cec1bc0c9a8a2ae05f0607.8b5afa0d.webp",Z=r.p+"static/image/ac2c52376fe4b0b20ed70265c2618def.7547bd1b.webp",V=r.p+"static/image/f418c13cdb612e18ce595447e5d8b11b.18056c09.webp",J=r.p+"static/image/ea24508d537526b7d779dd6a8a98229e.9b1061fe.webp",Q=r.p+"static/image/35f1ce3679e5503ec6f8c79315fb9c44.0d35c3a5.webp";function F(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",code:"code",pre:"pre",strong:"strong",h3:"h3",blockquote:"blockquote",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"第24章css自定义属性你知道多少",children:["第24章—CSS自定义属性你知道多少",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第24章css自定义属性你知道多少",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"\uFEFF大多数 Web 开发者更喜欢将 CSS 自定义属性称为 CSS 变量。近几年中，社区有关于 CSS 自定义属性的讨论到处可见，而且在很多 Web 应用或页面中也可以看到 CSS 自定义属性的身影。虽然如此，但有很多 Web 开发者对 CSS 自定义属性了解的并不多，甚至说不怎么理解，这样一来，在实际开发时就用不好 CSS 自定义属性。在这节课中，我们一起来探讨 CSS 自定义属性，将从不同的角度来阐述 CSS 自定义属性，希望大家能更好地理解 CSS 自定义属性，以及如何更好的使用 CSS 自定义属性。"}),"\n",(0,c.jsxs)(n.h2,{id:"css-自定义属性的发展进程",children:["CSS 自定义属性的发展进程",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性的发展进程",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"众所周知，CSS 和其他程序语言之间有一个最大的差异，即 CSS 中没有变量这样的概念。也正因此，很多 Web 开发者都觉得 CSS 非常简单，没有技术含量。然而，对于 Web 开发者而言，很多时候是希望 CSS 能像其他程序语言一样，有变量的概念，这样有利于 CSS 的编写和维护。比如构建下图这样的 UI Kit："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:Q,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["不难发现，上图中很多 UI 都应用了 ",(0,c.jsx)(n.code,{children:"#0055fe"})," 颜色，也就是说该色值会在 CSS 样式表中多次被使用："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* 页头的背景色 */\nheader { \n \xa0 \xa0background-color: #0055fe; \n} \n​\n/* label 文本颜色 */\nlabel { \n \xa0 \xa0color: #0055fe; \n} \n​\n/* 按钮边框颜色 */\nbutton { \n \xa0 \xa0border: 1px solid #0055fe; \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["想象一下，如果你正在维护一个大型的项目，会涉及很多个组件，也可能会有很多个 CSS 样式表文件。也就是说，在多个不同的样式表文件中都有可能会用到 ",(0,c.jsx)(n.code,{children:"#0055fe"})," 颜色。突然有一天，你被要求将 ",(0,c.jsx)(n.code,{children:"#0055fe"})," 这个颜色更换成别的颜色（即换肤）。那么，在没有 CSS 自定义属性（即 CSS 变量）的情况之下，可能最好的办法是在整个项目的样式表文件（即 ",(0,c.jsx)(n.code,{children:".css"})," 文件）中查找 ",(0,c.jsx)(n.code,{children:"#0055fe"})," ，然后再替换成所需要的目标颜色值。",(0,c.jsx)(n.strong,{children:"这么做，是多么痛苦的一件事情，而且还容易被遗漏"}),"！"]}),"\n",(0,c.jsx)(n.p,{children:"这样的操作模式对于 Web 开发者来说是极其痛苦的。庆幸的是，Web 开发者会使用像 Sass、LESS 和 Stylus 等 CSS 处理器来编写和维护 CSS 代码，因为在这些处理器中可以使用变量。例如，在 Sass 处理器中，可以像下面这样定义和使用变量："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"/* 定义一个 Sass 变量 */\n$primary-color: #0055fe;\n​\n/* 使用已定义好的 Sass 变量 */\nheader {\n \xa0 \xa0background-color: $primary-color;\n}\n​\nlabel {\n \xa0 \xa0color: $primary-color;\n}\n​\nbutton {\n \xa0 \xa0border: 1px solid $primary-color;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这样一来，我们可以在一个 ",(0,c.jsx)(n.code,{children:"_var.scss"})," 文件中放置项目中会运用到的所有变量，比如 ",(0,c.jsx)(n.code,{children:"$primary-color"})," ："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"/* _var.scss 文件 */\n$primary-color: #0055fe;\n$secondary-color: #09f;\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后在需要的地方引用已定义好的变量，例如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:'/* _header.scss 文件 */\n@import "./scss/_var.scss";\n​\nheader {\n \xa0 \xa0background-color: $primary-color;\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["这样做的目的是可以在不同的 ",(0,c.jsx)(n.code,{children:".scss"})," 文件中使用相同的值，从而实现 CSS 值的可重用性和减少冗余的 CSS 代码。基于该特性，Web 开发者可以轻易的实现换肤效果："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:J,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["另外，CSS 近几年发展和变革是非常地快，而且 W3C 的 CSS 工作者也知道，CSS 也应该具备“变量”这样的特性，为开发者减少重复性的工作和简化工作，并且减少对 CSS 处理器工具的依赖。为此，2012 年左右，W3C CSS 小组为 CSS 引入了 ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.a,{href:"https://www.w3.org/TR/css-variables-1/",target:"_blank",rel:"noopener noreferrer",children:"CSS自定义属性（CSS变量） 模块"})}),"，并在 2017 年左右获得大部分主流浏览器的支持。"]}),"\n",(0,c.jsx)(n.p,{children:"有了 CSS 自定义属性后，我们可以像下面这样来编写和维护 CSS："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--primary-color: #0055fe; \n} \n​\nheader { \n \xa0 \xa0background-color: var(--primary-color); \n} \n​\nlabel { \n \xa0 \xa0color: var(--primary-color); \n} \n​\nbutton { \n \xa0 \xa0border: 1px solid var(--primary-color); \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["不过 CSS 原生的自定义属性（变量），它也有一定的缺陷，比如说无法在声明变量的时候指定其语法类型。例如上面示例中，我们只能在 ",(0,c.jsx)(n.code,{children:":root{}"})," 中指定 ",(0,c.jsx)(n.code,{children:"--primary-color"})," 自定义属性的值是 ",(0,c.jsx)(n.code,{children:"#0055fe"}),"，它只是个字符串，并不是一个 ",(0,c.jsx)(n.code,{children:"<color>"})," 值类型。"]}),"\n",(0,c.jsxs)(n.p,{children:["除了在 CSS 中可以声明自定义属性之外，",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.a,{href:"https://www.w3.org/TR/css-properties-values-api-1/",target:"_blank",rel:"noopener noreferrer",children:"CSS Houdini 的属性和值 API "})})," 也对 CSS 自定义属性进行了扩展："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:V,alt:"img"})}),"\n",(0,c.jsx)(n.p,{children:"对于 CSS Houdini 中的自定义属性，我更喜欢称之为 CSS Houdini 变量。CSS Hounini 变量有两种方式来注册，一种是 JavaScript 来注册："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"CSS.registerProperty({ \n \xa0 \xa0name: '--primary-color', \n \xa0 \xa0syntax: '<color>', \n \xa0 \xa0inherits: false, \n \xa0 \xa0initialValue: '#0055fe' \n}) \n"})}),"\n",(0,c.jsxs)(n.p,{children:["另外一种是使用 ",(0,c.jsx)(n.code,{children:"@property"})," 规则注册："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"@property --primary-color { \n \xa0 \xa0syntax: '<color>'; \n \xa0 \xa0initial-value: #0055fe; \n \xa0 \xa0inherits: false; \n } \n"})}),"\n",(0,c.jsx)(n.p,{children:"CSS Houdini 变量的使用方式和 CSS 原生的 CSS 变量使用方式是相同的："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"header { \n \xa0 \xa0background-color: var(--primary-color); \n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"时至今日，你可能还在 CSS 处理器中使用变量，或许开始在使用原生的 CSS 变量，也有可能两者混合在一起使用。"}),"\n",(0,c.jsx)(n.p,{children:"换句话说，我们有多种方式使用 CSS 变量，但我们应该根据具体的场景使用更合适合的方式，不过我自己更建议从现在开始就使用原生的 CSS 变量，因为它有些特性是 CSS 处理器中变量无法具备的，特别是使用 CSS Houdini 的变量时，它的特性会变得更强大。"}),"\n",(0,c.jsxs)(n.h2,{id:"css-自定义属性的基础",children:["CSS 自定义属性的基础",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性的基础",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"如果你从未接触过 CSS 自定义属性，那么你可以从 CSS 自定义属性的一些基础开始；如果你是这方面的专家，你可以选择性的阅读后续的内容。"}),"\n",(0,c.jsx)(n.p,{children:"那我们从 CSS 自定义属性最基础的知识开始吧！"}),"\n",(0,c.jsxs)(n.h3,{id:"css-自定义属性简介",children:["CSS 自定义属性简介",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性简介",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义属性也常被称为 CSS 变量，被称为 CSS 变量主要还是源于 CSS 处理器或其他程序语言的一种叫法。但我想说的是“ ",(0,c.jsx)(n.strong,{children:"CSS 自定义属性不是变量"}),"”。为什么这么说呢？后面会向大家解释。"]}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义属性是以 ",(0,c.jsx)(n.code,{children:"--"})," 前缀开始命名，比如前面示例中的 ",(0,c.jsx)(n.code,{children:"--primary-color"}),"，其中 ",(0,c.jsx)(n.code,{children:"primary-color"})," 可以是任何字符串，它也被称为“",(0,c.jsx)(n.strong,{children:"自定义属性名"}),"”。即 ",(0,c.jsx)(n.code,{children:"--自定义属性名"}),"（比如 ",(0,c.jsx)(n.code,{children:"--primary-color"}),"）组合在一起才是“ CSS 自定义属性”。"]}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义属性的声明和 Sass 的变量声明有所不同，在 Sass 中，我们可以在 ",(0,c.jsx)(n.code,{children:"{}"})," 外声明，比如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"// _var.scss\n$primary-color: #0055fe;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["但 CSS 自定义属性声明需要放置在一个 ",(0,c.jsx)(n.code,{children:"{}"})," 花括号内，比如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--primary-color: #0055fe; \n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["除了在 ",(0,c.jsx)(n.code,{children:":root"})," 中之外，还可以是在其他的代码块中声明自定义属性，例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"html { \n \xa0 \xa0--primary-color: #0055fe; \n} \n​\nheader { \n \xa0 \xa0--primary-color: #00fe55; \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["虽然按上面的方式在 CSS 中注册了 CSS 自定义属性，但如果没有被 ",(0,c.jsx)(n.code,{children:"var()"})," 函数引用的话，它们不会有任何效果。比如下面这个示例，只有 ",(0,c.jsx)(n.code,{children:"--primary-color"})," 被 ",(0,c.jsx)(n.code,{children:"var()"})," 引用，而 ",(0,c.jsx)(n.code,{children:"--gap"})," 虽已注册，但未被 ",(0,c.jsx)(n.code,{children:"var()"})," 引用，它也就未运用到任何元素上："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--primary-color: #0055fe; \n \xa0 \xa0--gap: 20px; \n} \n​\nheader { \n \xa0 \xa0color: var(--primary-color); \n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["除了在 CSS 中使用 ",(0,c.jsx)(n.code,{children:"--varName"})," 来注册一个 CSS 自定义属性之外，我们还可以使用 JavaScript 的 ",(0,c.jsx)(n.code,{children:"style.setProperty()"})," 动态注册一个CSS自定义属性，比如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:" document.documentElement.style.setProperty('--primary-color', '#0055fe');\n"})}),"\n",(0,c.jsxs)(n.p,{children:["执行完上面脚本之后，在 ",(0,c.jsx)(n.code,{children:"<html>"})," 元素上会添加 ",(0,c.jsx)(n.code,{children:"style"})," 属性："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-HTML",children:'<html style="--primary-color: #0055fe"></html>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["在 CSS Houdini 中，我们还可以使用另外两种方式来注册 CSS 自定义属性（变量）。在 CSS 样式文件中可以使用 ",(0,c.jsx)(n.code,{children:"@property"})," 注册自定义属性："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"@property --primary-color { \n \xa0 \xa0syntax: '<color>'; \n \xa0 \xa0initial-value: #0055fe; \n \xa0 \xa0inherits: true; \n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在 JavaScript 中可以使用 ",(0,c.jsx)(n.code,{children:"CSS.registerProperty()"})," 注册："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"CSS.registerProperty({ \n \xa0 \xa0name: '--primary-color', \n \xa0 \xa0syntax: '<color>', \n \xa0 \xa0inherits: true, \n \xa0 \xa0initialValue: '#0055fe' \n}) \n"})}),"\n",(0,c.jsxs)(n.p,{children:["CSS Houdini 中注册好的 CSS 自定义属性同样只有被 ",(0,c.jsx)(n.code,{children:"var()"})," 函数调用才能生效。"]}),"\n",(0,c.jsxs)(n.h3,{id:"为什么要使用-css-自定义属性",children:["为什么要使用 CSS 自定义属性？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么要使用-css-自定义属性",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我将拿一个日常开发中非常常见的示例来回答这个问题。例如，CSS 更改悬浮状态下的颜色，我们会这样编写 CSS ："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"button {\n \xa0 \xa0color: #0055fe;\n \xa0 \xa0border: 2px solid #0055fe;\n \xa0 \xa0padding: .25em .5em;\n \xa0 \xa0border-radius: .25em;\n \xa0 \xa0background-color: #fefefe;\n}\n​\nbutton:hover {\n \xa0 \xa0color: #2196F3;\n \xa0 \xa0border-color: #2196F3;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/qBQRLVj",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/qBQRLVj"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["你也看到了，如果想在按钮悬浮状态下改变文本颜色（",(0,c.jsx)(n.code,{children:"color"}),"）和边框颜色（",(0,c.jsx)(n.code,{children:"border-color"}),"），需要在代码中重复写这些属性。但换成 CSS 自定义属性之后，我们就不再需要重复编写这些属性，仅需要在悬浮状态（",(0,c.jsx)(n.code,{children:":hover"}),"）下更改自定义属性 ",(0,c.jsx)(n.code,{children:"--primary-color"})," 的值："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root {\n \xa0 \xa0--primary-color: #0055fe;\n}\n​\nbutton {\n \xa0 \xa0color: var(--primary-color);\n \xa0 \xa0border: 2px solid var(--primary-color);\n \xa0 \xa0padding: .25em .5em;\n \xa0 \xa0border-radius: .25em;\n \xa0 \xa0background-color: #fefefe;\n}\n​\nbutton:hover {\n \xa0 \xa0--primary-color: #2196F3;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/MWzJZXa",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/MWzJZXa"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["正如你所看到的，以 ",(0,c.jsx)(n.code,{children:"var(--primary-color)"})," 函数作为 CSS 的 ",(0,c.jsx)(n.code,{children:"color"})," 和 ",(0,c.jsx)(n.code,{children:"border-color"})," 属性值时，可以获得更大的灵活性。它允许你定义一个或多个自定义属性，然后在整个样式表中使用这些属性。通过这样做，你可以通过简单地更新自定义属性的值来改变 UI 的样式风格。这使得你的代码更具可重用性和可维护性，从而使你的工作效率更高。"]}),"\n",(0,c.jsxs)(n.p,{children:["简单地说，我们可以使用 ",(0,c.jsx)(n.code,{children:"var()"})," 函数引用已注册的 CSS 自定义属性作为 CSS 属性的值。这为自定义属性开启了无尽的机会！"]}),"\n",(0,c.jsxs)(n.h2,{id:"css-自定义属性-vs-css-处理器的变量",children:["CSS 自定义属性 vs. CSS 处理器的变量",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性-vs-css-处理器的变量",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"很多 Web 开发者都会认为 CSS 自定义属性和 CSS 处理器中的变量有点类似，但事实上，它们之间还是有很大的差异。接下来，拿 CSS 处理器中的 Sass 处理器为例。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"注意，Sass 处理器又常被称为 SCSS 处理器。"}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"语法上的差异",children:["语法上的差异",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#语法上的差异",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义属性和 CSS 处理器之间最明显的差异就是语法上的差异。例如，在 Sass 中，我们使用 ",(0,c.jsx)(n.code,{children:"$"})," 符号来声明变量，而且不需要在代码块 ",(0,c.jsx)(n.code,{children:"{}"})," 中声明。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"// SCSS 中声明变量\n$primary-color: #0055fe;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["而 CSS 自定义属性是使用 ",(0,c.jsx)(n.code,{children:"--"})," 前缀来声明，并且需要在一个选择器块声明，例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* CSS 中自定义属性 */\n:root {\n \xa0 \xa0--primary-color: #0055fe;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"在引用变量的时候，它们也是有一定的差异。在 Sass 中引用已声明的变量，采用的是“键值对”的语法规则，例如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"// 声明一个 SCSS 变量\n$primary-color: #0055fe;\n​\n// 引用已声明的 $primary-color 变量\n​\nheader {\n \xa0 \xa0background-color: $primary-color;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在 CSS 中要引用已声明的 CSS 自定义属性，则必须通过 ",(0,c.jsx)(n.code,{children:"var()"})," 函数来引用，例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* 声明一个 CSS 自定义属性 */\n:root {\n \xa0 \xa0--primary-color: #0055fe;\n}\n​\n/* 引用已声明的 --primary-color 自定义属性 */\nheader {\n \xa0 \xa0background-color: var(--primary-color);\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["需要知道的是，CSS 处理器中的变量就是变量，它不会是其他任何东西。但 CSS 自定义属性则不同，",(0,c.jsx)(n.strong,{children:"它既是一个自定义属性，也是一个变量。"})," 有意思的是，我们又说 CSS 自定义属性不是 CSS 变量。"]}),"\n",(0,c.jsx)(n.p,{children:"那为什么说“CSS 自定义属性”不是“ CSS 变量”呢？我们先从相关的文档中来说起。"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties",target:"_blank",rel:"noopener noreferrer",children:"首先来看 MDN 文档，他是这样来描述的"}),"："]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"Custom properties (sometimes referred to as CSS variables or cascading variables) … You can define multiple fallback values when the given variable is not yet defined."}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"大致意思是： “自定义属性（有时也被称为 CSS 变量或级联变量）。当给定的变量尚未定义时，你可以定义多个回退值”。"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://web.dev/at-property/",target:"_blank",rel:"noopener noreferrer",children:"Google 开发者网站有篇文章对 CSS Houdini 的 @property 描述时提到"}),"："]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"This API supercharges your CSS custom properties (also commonly referred to as CSS variables) … The --colorPrimary variable has an initial-value of magenta."}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["它的意思是： 你可以使用 ",(0,c.jsx)(n.code,{children:"@property"})," API来自定义 CSS 属性（也就是通常所说的 CSS 变量）。比如 ",(0,c.jsx)(n.code,{children:"--colorPrimary"})," 变量的初始值是 ",(0,c.jsx)(n.code,{children:"magenta"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["为什么这么混乱呢？这是有因可查的。其实在 ",(0,c.jsx)(n.a,{href:"https://drafts.csswg.org/css-variables/",target:"_blank",rel:"noopener noreferrer",children:"W3C 的自定义属性描述的规范（CSS Custom Properties for Cascading Variables Module Level 1）"}),"就出现了“ CSS 自定义属性”和“ CSS 变量”这两个术语。甚至在规范的标题也出现这两个术语“CSS Custom Properties for Cascading Variables”。"]}),"\n",(0,c.jsxs)(n.p,{children:["事实上呢？前面也提到过，CSS 自定义属性也是 CSS 变量。不过，规范对这两个术语（“CSS 自定义属性”和“CSS 变量”）还是做了区分的： ",(0,c.jsx)(n.strong,{children:"CSS 自定义属性不是一个 CSS 变量，但它定义了一个 CSS 变量"})," 。"]}),"\n",(0,c.jsxs)(n.p,{children:["简单地说呢？在 CSS 代码块中使用 ",(0,c.jsx)(n.code,{children:"--"})," 注册的属性称为“自定义属性”，但只有被 ",(0,c.jsx)(n.code,{children:"var()"})," 引用的“CSS自定义属性”才能被称为“CSS 变量”，而且其值由相关的自定义属性定义。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:Z,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["上图描述的是， ",(0,c.jsx)(n.code,{children:"--accent-background"})," 自定义属性的值是 ",(0,c.jsx)(n.code,{children:"var(--main-color)"}),"(其中 ",(0,c.jsx)(n.code,{children:"--main-color"})," 是CSS 变量)，其值由 ",(0,c.jsx)(n.code,{children:"--main-color"})," 自定义属性定义。"]}),"\n",(0,c.jsxs)(n.p,{children:["在 CSS 中，这样来区分“ CSS 自定义属性”和“ CSS 变量”是有用的，因为它允许我们讨论 ",(0,c.jsx)(n.code,{children:"var()"})," 函数的回退值（CSS 自定义属性像其他 CSS 属性一样，并没有回退值一说）和“使用变量的属性”（一个属性不能使用自定义属性）："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"html { \n \xa0 \xa0/* 这是一个 CSS 自定义属性，它只有一个声明值，并不能有回退值 */ \n \xa0 \xa0--main-color: #ec130e; \n} \n​\nbutton { \n \xa0 \xa0/* 这是一个 CSS 变量，它可以有回退值 */ \n \xa0 \xa0background-color: var(--main-color, #eee); \n \xa0 \xa0\n \xa0 \xa0/* 同时使用了两个 CSS 变量 */ \n \xa0 \xa0box-shadow: 0 0 var(--shadow-size) var(--main-color); \n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"以及“在元素上声明一个自定义属性”（一个变量没有被声明，而是被分配给一个属性）和“自定义属性的计算值”（一个变量没有计算值，而是从其关联的自定义属性的计算值中提取）："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"html { \n \xa0 \xa0/* 在 html 元素上注册了一个 CSS 自定义属性 */ \n \xa0 \xa0--padding: 1rem; \n} \n​\nmain { \n \xa0 \xa0/* --padding 自定义属性继承到 main 元素上，它在这个元素上的计算值是 16px */ \n} \n​\nmain p { \n \xa0 \xa0/* --padding 自定义属性在 p 元素上重新注册，该属性在该元素上计算值是 8px */ \n \xa0 \xa0--padding: 0.5rem; \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["其实也可以简单地来区分“ CSS 自定义属性”和“ CSS 变量”，即 ",(0,c.jsx)(n.strong,{children:"CSS 的"})," ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"var()"})})," ",(0,c.jsx)(n.strong,{children:"引用的自定义属性被称为 CSS 变量"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"除此之外，它们还有另一个差异。CSS 处理器的变量和 CSS 自定义属性被引用也有所不同。在 CSS 处理器中，你可以在任何地方引用已声明的变量，比如外部声明块、媒体查询、选择器、属性中。例如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:'// SCSS\n$breakpoint: 800px;\n$primary-color: #0055fe;\n$list: ".text, .cats";\n$btm: bottom;\n​\n$color: $primary-color;\n​\n@media screen and (min-width: $breakpoint) {\n \xa0  #{$list} {\n \xa0 \xa0 \xa0 \xa0color: $color;\n \xa0  }\n}\n​\np { \n \xa0 \xa0padding-#{$btm}:5rem;\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义属性和常规 CSS 属性的用法是一样的，所以把 CSS 自定义属性当作动态属性会比 CSS 变量更好一些。这也意味着，它们只能在声明块中使用。也就是说，CSS 自定义属性和选择器是强绑定的。一般会在 ",(0,c.jsx)(n.code,{children:":root"})," 选择器中声明 CSS 自定义属性，事实上，只要是有效的 CSS 选择器都可以。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root {\n \xa0 \xa0--primary-color: #0055fe;\n}\n​\nmain {\n \xa0 \xa0--primary-color: #5500fe;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义属性要想被起作用，则需要通过 ",(0,c.jsx)(n.code,{children:"var()"})," 函数引用，并且赋予给相应的 CSS 属性。例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root {\n \xa0 \xa0--primary-color: #0055fe;\n}\n​\nheader {\n \xa0 \xa0background-color: var(--primary-color);\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在 CSS 中，你可以在属性声明中的任何地方获取 CSS 自定义属性的值。这也意味着，它们可以作为单个值使用，也可以作为一个简写属性的一部分，甚至还可以在 ",(0,c.jsx)(n.code,{children:"calc()"})," 函数中使用，例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:".cats { \n \xa0 \xa0color: var(--color); \n \xa0 \xa0margin: 0 var(--margin-horizontal); \n \xa0 \xa0padding: calc(var(--margin-horizontal) / 2); \n} \n"})}),"\n",(0,c.jsx)(n.p,{children:"不过，在某些地方，CSS 自定义属性的限制要比 CSS 处理器的变量要多。例如，CSS 自定义属性不能用于媒体查询的条件语句中，也不能用于 CSS 选择器中："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* 下面这样的用法是无效的 */ \n:root { \n \xa0 \xa0--num: 2; \n \xa0 \xa0--breakpoint: 30em; \n} \n \ndiv:nth-child(var(--num)) { \n \xa0 \xa0color: var(--color); \n} \n​\n@media screen and (min-width: var(--breakpoint)) { \n \xa0  :root { \n \xa0 \xa0 \xa0 \xa0--color: green; \n \xa0  } \n} \n"})}),"\n",(0,c.jsxs)(n.h3,{id:"动态-vs-静态",children:["动态 vs. 静态",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#动态-vs-静态",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"CSS 处理器运行机制的过程可能大致如下图："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:q,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["CSS 处理器中的代码最终是会编辑成 CSS 代码。也就是说，CSS 处理器中的变量或其他功能仅仅是在编译的时候生效，它是一种静态的。而 CSS 自定义属性却不一样，他是一种动态的，你在客户端运行时就可以做出相应的改变。比如，在不同的断点运行时，",(0,c.jsx)(n.code,{children:".card"})," 的间距不同。"]}),"\n",(0,c.jsx)(n.p,{children:"在 CSS 处理器，我们可能会这样来做："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"// SCSS \n$gutter: 1em; \n​\n@media screen and (min-width: 30em) { \n \xa0 \xa0$gutter: 2em; \n} \n​\n.card { \n \xa0 \xa0margin: $gutter; \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["使用过 CSS 处理器的同学都知道，",(0,c.jsx)(n.code,{children:"@media"})," 中的 ",(0,c.jsx)(n.code,{children:"$gutter"})," 并没有生效，最后编译出来的 CSS 代码中，只能找到："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* 编译后的 CSS 代码 */\n.card { \n \xa0 \xa0margin: 1em; \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["不管浏览器视窗宽度怎么变化，",(0,c.jsx)(n.code,{children:"$gutter"})," 的值始终都是 ",(0,c.jsx)(n.code,{children:"1em"}),"。这就是所谓的静态（处理器无法在客户端动态编译）。其主要原因是 CSS 处理器需要经过编译之后才能在客户端运行，而 CSS 自定义属性却不需要经过编译这一环节，可以在客户端上直接使用，比如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--gutter: 1em; \n} \n​\n@media screen and (min-width: 30em) { \n \xa0  :root { \n \xa0 \xa0 \xa0 \xa0--gutter: 2em; \n \xa0  } \n} \n​\n.card { \n \xa0 \xa0margin: var(--gutter); \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["就上面示例代码，当你改变浏览器窗口的时候，你会发现 ",(0,c.jsx)(n.code,{children:".card"})," 的 ",(0,c.jsx)(n.code,{children:"margin"})," 会发生相应的变化。"]}),"\n",(0,c.jsxs)(n.p,{children:["从这个示例不难看出，",(0,c.jsx)(n.strong,{children:"CSS 自定义属性是动态的（可以在客户端动态响应）"})," 。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:T,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["另外，我们无法使用 JavaScript 来动态修改 CSS 处理器的变量。但 CSS 自定义属性却不同，我们可以通过 **",(0,c.jsx)(n.a,{href:"https://www.w3cplus.com/javascript/cssom-css-typed-om.html",target:"_blank",rel:"noopener noreferrer",children:"CSSOM的 API "}),"**来动态获取或修改 CSS 自定义属性的值。例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--mouse-x; \n \xa0 \xa0--mouse-y; \n} \n​\n.move { \n \xa0 \xa0left: var(--mouse-x); \n \xa0 \xa0top: var(--mouse-y); \n}\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"let moveEle = document.querySelector('.move'); \nlet root = document.documentElement; \n​\nmoveEle.addEventListener('mousemove', e => { \n \xa0 \xa0root.style.setProperty('--mouse-x', `${e.clientX}px`); \n \xa0 \xa0root.style.setProperty('--mouse-y', `${e.clientY}px`); \n})\n"})}),"\n",(0,c.jsx)(n.p,{children:"利用该特性，我们很轻易可以实现下图这样的效果："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/BaGWOgb",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/BaGWOgb"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:N,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/MWzpPYy",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/MWzpPYy"})]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"级联和继承",children:["级联和继承",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#级联和继承",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"CSS 处理器和 CSS 自定义属性还有一个较大的差异性，那就是级联和继承方面的。CSS 变量在 CSS 处理器中是不具备级联和继承这方面特性的。先来看级联方面的特性："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"// SCSS \n$font-size: 1em; \n​\n.user-setting-larger-text { \n \xa0 \xa0$font-size: 1.5em; \n} \n​\nbody { \n \xa0 \xa0font-size: $font-size; \n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["编译之后 ，",(0,c.jsx)(n.code,{children:"body"})," 的 ",(0,c.jsx)(n.code,{children:"font-size"})," 始终都是 ",(0,c.jsx)(n.code,{children:"1em"}),"，哪怕是用户显式地在 ",(0,c.jsx)(n.code,{children:"<body>"})," 元素上设置了 ",(0,c.jsx)(n.code,{children:'class="user-setting-large-text"'})," 也是如此。但 CSS 自定义属性在这方面却不同。例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* CSS 自定义属性*/ \n:root { \n \xa0 \xa0--font-size: 1em; \n} \n​\n.user-setting-large-text { \n \xa0 \xa0--font-size: 1.5em; \n} \n​\nbody { \n \xa0 \xa0font-size: var(--font-size); \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["你会发现，当 ",(0,c.jsx)(n.code,{children:"<body>"})," 元素有类名 ",(0,c.jsx)(n.code,{children:"user-setting-large-text"})," 时，它的 ",(0,c.jsx)(n.code,{children:"font-size"})," 值为 ",(0,c.jsx)(n.code,{children:"1.5em"})," ，否则是 ",(0,c.jsx)(n.code,{children:"1em"})," 。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:k,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["可以说，",(0,c.jsx)(n.strong,{children:"CSS 自定义属性使用级联机制是它们最有用的特性之一"}),"。我们来重点阐述一下。"]}),"\n",(0,c.jsxs)(n.p,{children:["假设我们在 ",(0,c.jsx)(n.code,{children:"body"})," 元素上定义了一个自定义属性 ",(0,c.jsx)(n.code,{children:"--background"})," ，然后在特定的类（例如 ",(0,c.jsx)(n.code,{children:".sidebar"}),"）上重新定义了 ",(0,c.jsx)(n.code,{children:"--background"})," 。我们在特定的组件中（例如 ",(0,c.jsx)(n.code,{children:".module"}),"）使用它："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0--background: #5500fe;\n}\n​\n.sidebar {\n \xa0 \xa0--background: #fe890a;\n}\n​\n.module {\n \xa0 \xa0background-color: var(--background);\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"假设我们的 HTML 结构如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-HTML",children:'<body> \x3c!-- --background: #5500fe --\x3e\n \xa0 \xa0<main>\n \xa0 \xa0 \xa0 \xa0<div class="module">我将使用 #5500fe 作为背景颜色。</div>\n \xa0 \xa0</main>\n​\n \xa0 \xa0<aside class="sidebar"> \x3c!-- --background: #fe890a --\x3e\n \xa0 \xa0 \xa0 \xa0<div class="module">我将使用 #fe890a 作为背景颜色</div>\n \xa0 \xa0</aside>\n</body>\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:v,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/xxQqyrY",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/xxQqyrY"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["正如你所看到的，侧边栏（",(0,c.jsx)(n.code,{children:".sidebar"}),"）中的 ",(0,c.jsx)(n.code,{children:".module"})," 背景颜色是 ",(0,c.jsx)(n.code,{children:"#fe890a"})," ，因为自定义属性（像许多其他 CSS 属性一样）通过 HTML 结构进行继承。在这个示例中，第二个 ",(0,c.jsx)(n.code,{children:".module"})," 运用的自定义属性 ",(0,c.jsx)(n.code,{children:"--background"})," ，相比而言，它离 ",(0,c.jsx)(n.code,{children:".sidebar"})," 中的 ",(0,c.jsx)(n.code,{children:"--background"})," 更近，离 ",(0,c.jsx)(n.code,{children:"body"})," 中的 ",(0,c.jsx)(n.code,{children:"--background"})," 却更远，因此，",(0,c.jsx)(n.code,{children:"--background"})," 被解析为 ",(0,c.jsx)(n.code,{children:"#fe890a"})," ，而在其他地方解析为 ",(0,c.jsx)(n.code,{children:"#5500fe"})," 。"]}),"\n",(0,c.jsx)(n.p,{children:"这种机制也可以在其他方面发挥作用："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"button {\n \xa0 \xa0--primary-color: #5500fe; /* 默认值 */\n \xa0 \xa0background-color: var(--primary-color);\n}\n​\nbutton:hover {\n \xa0 \xa0--primary-color: #2196f3; /* 按钮悬浮时取该值 */\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面这个示例是一个更具体的选择器，因此重新设置自定义属性 ",(0,c.jsx)(n.code,{children:"--primary-color"})," 的值将会覆盖在 ",(0,c.jsx)(n.code,{children:"button"})," 定义的值。"]}),"\n",(0,c.jsx)(n.p,{children:"在 CSS 的媒体查询中不会改变权重，但它们通常位于 CSS 文件中比原始选择器设置值的位置后（或下面），这也意味着在媒体查询内部将覆盖自定义属性。例如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0--size: 16px;\n \xa0 \xa0font-size: var(--size);\n}\n​\n@media screen and (width < 600px) {\n \xa0 \xa0body {\n \xa0 \xa0 \xa0 \xa0--size: 14px;\n \xa0  } \xa0 \xa0\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在这个示例中，当浏览器屏幕小于 ",(0,c.jsx)(n.code,{children:"600px"})," 时，",(0,c.jsx)(n.code,{children:"body"})," 元素的 ",(0,c.jsx)(n.code,{children:"font-size"})," 将会取媒体查询中设置的 ",(0,c.jsx)(n.code,{children:"--size"})," 自定义属性的值，即 ",(0,c.jsx)(n.code,{children:"14px"})," 。除此之外，我们还可以借助媒体查询其他功能，例如用户偏好设置，可以实现其他的一些效果，其中最为典型的案例，就是在亮色和暗色模式下切换 Web 应用的皮肤效果："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:'/* 亮色模式下 */\n:root {\n \xa0 \xa0--color: #333;\n \xa0 \xa0--primary-color: #ffffff; /* 主色 */\n \xa0 \xa0--body-bg-color: #f1f1f1; /* body背景颜色 */\n \xa0 \xa0--card-box-shadow-color: #405070; /* card盒子阴影颜色 */\n \xa0 \xa0--btn-bg-color: #28c3f5; /* button背景颜色 */\n \xa0 \xa0--paragraph-color: gray; /* 段落文本颜色 */\n \xa0 \xa0--card-object-bg-color: #eaeff8; /* card顶部背景颜色 */\n \xa0 \xa0--title-color: #101c34; /* 标题2文本颜色 */\n \xa0 \xa0--avatar-bg-color: #fff;\n \xa0 \xa0--light: #fff;\n \xa0 \xa0--saturation: 0;\n \xa0 \xa0--invert: none;\n}\n​\n/* 暗色模式下 */\n@media (prefers-color-scheme: dark) {\n \xa0  :root {\n \xa0 \xa0 \xa0 \xa0--color-mode: "dark";\n \xa0  }\n​\n \xa0  :root:not([data-user-color-scheme]) {\n \xa0 \xa0 \xa0 \xa0--color: #fff;\n \xa0 \xa0 \xa0 \xa0--primary-color: #1a1515; /* 主色 */\n \xa0 \xa0 \xa0 \xa0--body-bg-color: #1a1818; /* body背景颜色 */\n \xa0 \xa0 \xa0 \xa0--card-box-shadow-color: #6a716e; /* card盒子阴影颜色 */\n \xa0 \xa0 \xa0 \xa0--btn-bg-color: #ff5722; /* button背景颜色 */\n \xa0 \xa0 \xa0 \xa0--paragraph-color: #c7c1c1; /* 段落文本颜色 */\n \xa0 \xa0 \xa0 \xa0--card-object-bg-color: #282035; /* card顶部背景颜色 */\n \xa0 \xa0 \xa0 \xa0--title-color: #ffffff; /* 标题2文本颜色 */\n \xa0 \xa0 \xa0 \xa0--avatar-bg-color: #673ab7;\n \xa0 \xa0 \xa0 \xa0--saturation: 1;\n \xa0 \xa0 \xa0 \xa0--invert: 0.8;\n \xa0  }\n}\n​\nbody {\n \xa0 \xa0background-color: var(--body-bg-color);\n \xa0 \xa0color: var(--color);\n}\n​\n.card {\n \xa0 \xa0background: var(--primary-color);\n \xa0 \xa0box-shadow: 0px 1px 10px 1px var(--card-box-shadow-color);\n}\n​\n.card__object {\n \xa0 \xa0background-color: var(--card-object-bg-color);\n}\n​\n.card__avatar {\n \xa0 \xa0background-color: var(--avatar-bg-color);\n}\n​\n.card__body h4 {\n \xa0 \xa0color: var(--title-color);\n}\n​\n.card__body p {\n \xa0 \xa0color: var(--paragraph-color);\n}\n​\n.card__body .btn {\n \xa0 \xa0background: var(--btn-bg-color);\n \xa0 \xa0color: var(--primary-color);\n}\n​\n.card__body .btn:hover {\n \xa0 \xa0color: var(--btn-bg-color);\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:y,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/zYMZmbj",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/zYMZmbj"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["所以说，在 CSS 中声明自定义属性时，都将它们放置在 ",(0,c.jsx)(n.code,{children:":root"})," 选择器中并不是一种明智的选择。实际上，推荐的方法是只在 ",(0,c.jsx)(n.code,{children:":root"})," 选择器放置全局的 CSS 自定义属性，而将更多与类或组件相关的样式放在它们需要的地方附近。"]}),"\n",(0,c.jsxs)(n.p,{children:["除了上面的示例可以解释之外，CSS 自定义还有一个关键概念，那就是",(0,c.jsx)(n.strong,{children:"自定义属性的值是在每个元素中计算一次，然后计算后的值可以继承"}),"。例如，你在 ",(0,c.jsx)(n.code,{children:"calc()"})," 或需要进行计算的其他值中使用了 CSS 自定义属性，比如 ",(0,c.jsx)(n.code,{children:"hsl()"})," 中的色调，那么就使得整个计算后的值可以被继承。如果某个值在父元素上进行设置，你将不能在计算中更改它，例如下面这个示例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root {\n \xa0 \xa0--unit: 10px;\n \xa0 \xa0--size-lg: calc(var(--unit) * 3);\n}\n​\n/* 这里计算时不会使用更新后的 --unit 值 */\n.margin-top-xxxl {\n \xa0 \xa0--unit: 30px;\n \xa0 \xa0margin-top: var(--size-lg);\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["修复上述继承问题的一个选项是，使用基础类和修饰类的组合，以便将值计算在同一个元素中。在示例中，我们仍然设置了一个全局的 ",(0,c.jsx)(n.code,{children:"--unit"})," 值，并将其作为基础类的默认值。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:':root {\n \xa0 \xa0--unit: 10px;\n}\n​\n.margin-top {\n \xa0 \xa0--margin-unit: var(--unit);\n \xa0 \xa0--multiplier: 1;\n​\n \xa0 \xa0margin-top: calc(var(--multiplier) * var(--margin-unit));\n}\n​\n.margin-top--xxxl {\n \xa0 \xa0--margin-unit: 30px;\n \xa0 \xa0--multiplier: 3;\n}\n​\ndiv[class*="margin"] {\n \xa0 \xa0background-color: dodgerblue;\n \xa0 \xa0color: white;\n \xa0 \xa0padding: 0.5rem;\n \xa0 \xa0font-size: 1.5rem;\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:H,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/ExOWdBp",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/ExOWdBp"})]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"全局-vs-局部",children:["全局 vs. 局部",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局-vs-局部",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"CSS 处理器的变量主要有两种类型，即全局和局部。拿 Sass 为例，定义在选择器外部的变量都被称为全局变量，可以在所有选择器中访问到，包括选择器内部和选择器外部。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"$color: red;\n​\nbody {\n \xa0 \xa0background-color: $color;\n}\n​\nh1 {\n \xa0 \xa0color: $color;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["而在选择器内部定义的变量被称为局部变量，只能在该选择器内部和其子选择器内部访问到，而无法在选择器外部访问到。比如下面这个示例，",(0,c.jsx)(n.code,{children:"$size"})," 变量就是一个局部变量，只能在选择器中访问到："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"body {\n \xa0 \xa0$size: 16px;\n \xa0 \xa0font-size: $size;\n \xa0\n \xa0 \xa0h1 {\n \xa0 \xa0 \xa0 \xa0font-size: $size * 2;\n \xa0  }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"需要注意的是，局部变量只能在其定义的选择器内部访问，如果选择器内部有嵌套的选择器，那么该变量也可以在嵌套的选择器内部访问。也就是说，任何嵌套的代码块都可以访问封闭内的变量："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"$globalVar : 10px; // 全局变量\n​\n.enclosing { \n \xa0 \xa0$enclosingVar: 20px; // 局部变量\n \xa0 \xa0\n \xa0 \xa0.closure { \n \xa0 \xa0 \xa0 \xa0$closureVar: 30px; // 局部变量 \n \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0font-size: $closureVar + $enclosingVar + $globalVar; // 60px \n \xa0 \xa0 } \n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"这也意味着，在 CSS 处理器中，变量的作用域完全依赖于代码的结构。"}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义属性的作用域和 CSS 处理器有所不同。一般情况之下，在选择器 ",(0,c.jsx)(n.code,{children:":root"})," 中声明的变量才被称为是全局变量，而在其他选择器内声明的变量称为局部变量。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，在 ",(0,c.jsx)(n.code,{children:"html"})," 选择器内声明的变量也称为全局变量，只不过在 ",(0,c.jsx)(n.code,{children:":root"})," 选择器声明的 CSS 自定义属性优先级要更高。"]}),"\n",(0,c.jsxs)(n.h3,{id:"css-自定义属性和-css-处理器可以混合使用",children:["CSS 自定义属性和 CSS 处理器可以混合使用",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性和-css-处理器可以混合使用",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"虽然 CSS 自定义属性和 CSS 处理器中的变量有所差异，甚至说 CSS 自定义属性胜于 CSS 处理器变量不少，但这也不是谁替代谁的主要原因。换句话说，如果你习惯了使用 CSS 处理器或者你现在还在使用 CSS 处理器，那么完全可以将 CSS 处理器和 CSS 自定义属性结合使用，以充分发挥各自的优势。"}),"\n",(0,c.jsx)(n.p,{children:"继续拿 Sass 处理器为例，为了将 Sass 变量用作自定义属性的值，你需要使用插值语法，如下所示："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:"--custom-property: #{$sass-var};\n"})}),"\n",(0,c.jsxs)(n.p,{children:["对于 Web 开发者，时常都会碰到换肤的需求。通过使用 Sass ，我们可以使用 ",(0,c.jsx)(n.code,{children:"!default"})," 标记来设置静态变量，这意味着它们可以被覆盖。然后，我们可以将其传递给 CSS 自定义属性。此外，我们还可以利用 Sass 的其他特性，比如循环遍历，来快速生成一组类似的属性。例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-SCSS",children:'$color-link: blue !default;\n$font-sizes: (\n \xa0 \xa0"small": .875rem,\n \xa0 \xa0"normal": 1rem,\n \xa0 \xa0"medium": 1.25rem,\n \xa0 \xa0"large": 2rem\n) !default;\n​\n:root {\n \xa0 \xa0--color-link: #{$color-link};\n​\n \xa0 \xa0@each $size, $value in $font-sizes {\n \xa0 \xa0 \xa0 \xa0--font-size-#{$size}: #{$value};\n \xa0  }\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"编译出来的 CSS 如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root {\n \xa0 \xa0--color-link: blue;\n \xa0 \xa0--font-size-small: 0.875rem;\n \xa0 \xa0--font-size-normal: 1rem;\n \xa0 \xa0--font-size-medium: 1.25rem;\n \xa0 \xa0--font-size-large: 2rem;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"通过这种设置，可以在不修改核心 Sass 文件设置的情况下重新定义应用程序的主题。这提供了主题处理的灵活性和可维护性。"}),"\n",(0,c.jsxs)(n.h2,{id:"css-自定义属性的特性",children:["CSS 自定义属性的特性",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性的特性",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"通过前面的学习，我想你对 CSS 的自定义属性有了一些基本的认识。接下来，我们来聊聊 CSS 自定义属性中你所不知道的特性。"}),"\n",(0,c.jsxs)(n.h3,{id:"当一个-var-函数使用一个未定义的变量时会发生什么",children:["当一个 var() 函数使用一个未定义的变量时，会发生什么？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#当一个-var-函数使用一个未定义的变量时会发生什么",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们在 CSS 中声明一个 CSS 自定义属性时，有一个细节需要注意，那就是 ",(0,c.jsx)(n.strong,{children:"CSS 自定义属性名称有大小写之分"}),"。比如， ",(0,c.jsx)(n.code,{children:"--on"})," 和 ",(0,c.jsx)(n.code,{children:"--ON"})," 是两个完全不同的 CSS 自定义属性。来看一个具体的示例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--ON: 1; \n} \n​\n.box { \n \xa0 \xa0transform: rotate(calc(var(--ON) * 45deg)); \n \xa0 \xa0transition: transform 1s ease-in-out; \n} \n​\n.box:hover { \n \xa0 \xa0transform: rotate(calc(var(--on) * 720deg)); \n} \n​\n.box:last-of-type:hover{ \n \xa0 \xa0transform: rotate(calc(var(--ON) * 720deg)); \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果你把鼠标移动蓝色 ",(0,c.jsx)(n.code,{children:".box"})," 上，效果和我们预想的并不相同，没有旋转 ",(0,c.jsx)(n.code,{children:"720deg"}),"，反而旋转到了 ",(0,c.jsx)(n.code,{children:"0deg"}),"，即 ",(0,c.jsx)(n.code,{children:"--on"})," 无效值；如果把鼠标移动到红色的 ",(0,c.jsx)(n.code,{children:".box"})," 上，可以看到元素从 ",(0,c.jsx)(n.code,{children:"45deg"})," 旋转到 ",(0,c.jsx)(n.code,{children:"720deg"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:D,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/LYXWqym",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/LYXWqym"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["从浏览器开发者工具中不能发现 ",(0,c.jsx)(n.code,{children:"var(--on)"}),"（注意，我们在代码中并没有显式声明 ",(0,c.jsx)(n.code,{children:"--on"})," 自定义属性），那么 ",(0,c.jsx)(n.code,{children:"transform: rotate(calc(var(--on) * 720deg))"})," 计算出来的 ",(0,c.jsx)(n.code,{children:"transfrom"})," 为 ",(0,c.jsx)(n.code,{children:"none"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:w,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["这个示例告诉我们：“",(0,c.jsx)(n.code,{children:"var()"})," 函数引用一个未定定义的变量（CSS 自定义属性）并不会导致样式解析错误，也不会阻止样式加载、解析或渲染”。这个就好比你在编写 CSS 时，因为手误将属性或属性值用借一样，客户端只是不识别这个错误的信息，比如："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:O,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["那么，在 ",(0,c.jsx)(n.code,{children:"var()"})," 函数中使用了一些未定义的 CSS 变量时，有可能是："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"var()"})," 函数引用的变量名输错了（手误造成）"]}),"\n",(0,c.jsxs)(n.li,{children:["你可能使用 ",(0,c.jsx)(n.code,{children:"var()"})," 引用了一个自认为它存在的 CSS 变量，但事实上它并不存在"]}),"\n",(0,c.jsx)(n.li,{children:"你可能正试图使用一个完全有效的 CSS 变量，但是你想在其他地方使用，它恰好不可见"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["我们再来看两个示例，先来看一个有关于 ",(0,c.jsx)(n.code,{children:"border"})," 的示例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--primary-color: #0055fe; \n} \n​\nbody { \n \xa0 \xa0color: #f36; \n} \n​\n/* 注意，这里运用的是一个 --primay-color 自定义属性，并没有显式声明 */\n.box { \n \xa0 \xa0border: 5px solid var(--primay-color); \n \xa0 \xa0color: var(--primay-color); \n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["注意，上面代码中 ",(0,c.jsx)(n.code,{children:".box"})," 元素的 ",(0,c.jsx)(n.code,{children:"border"})," 和 ",(0,c.jsx)(n.code,{children:"color"})," 运用的是一个并没有显式声明的 CSS 自定义属性 ",(0,c.jsx)(n.code,{children:"--primay-color"})," （可能因为手误，将声明的 ",(0,c.jsx)(n.code,{children:"--primary-color"})," 写成 ",(0,c.jsx)(n.code,{children:"--primay-color"}),"）。你将看到的效果如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/GRwWzeK",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/GRwWzeK"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["结果浏览器并不知道 ",(0,c.jsx)(n.code,{children:"border"})," 最终的值应该是什么？因为 ",(0,c.jsx)(n.code,{children:"border"})," 属性是一个不可继承的属性，这个时候浏览器会理解成用户把 ",(0,c.jsx)(n.code,{children:"border"})," 属性写错了。此时，浏览器解析 ",(0,c.jsx)(n.code,{children:"border"})," 的值为 ",(0,c.jsx)(n.code,{children:"0px none #f36"})," ："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["注意，在 CSS 中，如果 ",(0,c.jsx)(n.code,{children:"border-style"})," 的值被渲染为 ",(0,c.jsx)(n.code,{children:"none"})," 时，你是看不到任何边框效果的。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["再来看 ",(0,c.jsx)(n.code,{children:"color"})," 属性。虽然 ",(0,c.jsx)(n.code,{children:"var()"})," 引用的变量也手误写错了，但它却有颜色。这主要是因为 ",(0,c.jsx)(n.code,{children:"color"})," 是一个可继承的属性，所以浏览器渲染的时候会继承其祖先元素的 ",(0,c.jsx)(n.code,{children:"color"})," 值，在我们这个示例中，在 ",(0,c.jsx)(n.code,{children:"body"})," 中显式设置了",(0,c.jsx)(n.code,{children:"color: #f36"}),"，因此 ",(0,c.jsx)(n.code,{children:".box"})," 的 ",(0,c.jsx)(n.code,{children:"color"})," 继承了 ",(0,c.jsx)(n.code,{children:"body"})," 的 ",(0,c.jsx)(n.code,{children:"color"})," 值，即 ",(0,c.jsx)(n.code,{children:"#f36"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["这个示例令人感到困惑的是 ",(0,c.jsx)(n.code,{children:"var()"})," 引用错语的变量（其实是不存在的变量），浏览器渲染的时候到底会发生什么？从上面的示例中我们可以得知，它的根源在于 ",(0,c.jsx)(n.code,{children:"var()"})," 函数使用了无效的属性，这个时候浏览器渲染 CSS 时，它自己也无从得知。"]}),"\n",(0,c.jsxs)(n.p,{children:["浏览器在渲染 CSS 时，只有属性名或值无法被识别时（浏览器渲染引擎不知道时）才会认为是无效的。但是，",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"var()"})})," ",(0,c.jsx)(n.strong,{children:"函数可以解析为任何东西，所以样式引擎不知道"})," ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"var()"})})," ",(0,c.jsx)(n.strong,{children:"包含的值是否已知（浏览器渲染引擎可识别）"})," 。只有当这个属性真正被使用时，它才会知道，这时，它会默默地回退到属性的继承或初始状态，并让你疑惑发生了什么？当你碰到这个现象的时候，其实可以借助浏览器开发者工具来查找问题："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["除此之外，要是 ",(0,c.jsx)(n.code,{children:"var()"})," 函数引用的 CSS 自定义属性不存在，浏览器开发者调试工具也会有相应的提示，例如 Chrome 开发者调试工具会将引用的自定义属性置灰，Firefox 浏览器会更友好一些，它会告诉你自定义属性没有定义："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:C,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["不知道你有没有发现，CSS 原生中的自定义属性是一个字符串，可以说并不很严谨。比如说，",(0,c.jsx)(n.code,{children:"--primary-color"})," 应该是一个颜色值 ",(0,c.jsx)(n.code,{children:"<color>"})," ，但有的时候在另一个地方再次注册的时候，它可能被开发者定义成了一个长度值 ",(0,c.jsx)(n.code,{children:"<length>"})," ："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--primary-color: #0055fe; \n} \n​\nbody {\n \xa0 \xa0color: #f36;\n}\n​\n.box { \n \xa0 \xa0--primary-color: 5px; \n \xa0 \xa0\n \xa0 \xa0border: solid var(--primary-color); \n \xa0 \xa0color: var(--primary-color); \n} \n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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xYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFixYsWLFiz4FatWrVq1atWrVq1atWrVq1atWrVq1atWrVq1atWrVq1atWrVq1azyA4cOHDhw4cOHDhw4cOHDhw4cOHDhw4cOHDhw4cOHDhw4cOHDhw4s3mzZs2bNmzZs2bNmzZs2bNmzZs2bNmzZs2bNmzZs2bNmzZs2bNm0Fy6dOnTp06dOnTp06dOnTp06dOnTp06dOnTp06dOnTp06dOnTp06fCGfPnz58+fPnz58+fPnz58+fPnz58+fPnz58+fPnz58+fPnz58+fUSzVq1atWrVq1atWrVq1atWrVq1atWrVq1atWrVq1atWrVq1atWrV2369evXr169evXr169evXr169evXr169evXr169evXr169evXr1691y+XmgyZMmTJkyZMmTJkyZMmTJkyZMmTJkyZMmTJkyZMmTJkyZMmTJkx5DxevJTlFN/cNBQpDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYDAYCtgWFfzhjgA/v/U/WfPWh0fXHhkPbHaEAcGSh9WS858QQSikq+Yj88WBnQ15HrNFKK231tf8sOesHP1q6RelrkOQ7DeQz51DA9WN+74hezJppWjaTJec+Hgeh9D+bn5lYxIQhQg/x34Pl0aSwyRPkLTbOGFptnDC02zhhabZwwtNs4YWm2cMLTbOGFptnDC02zhhabZwwtNs4YWm2cMLTbOGFptnDC02zhhabZwwtNs4YWm2cMLTbOGFptnDC02zhhabZwwtNs4YWm2cMLTbOGFptnDC02zhhabZwwtNs4YWm2cMLTbOGFptnDC02zhhabZwwtNs4YWm2cMLTbOGFptnDC02zhhabZwwtNs7f5caX9IyAWqNUhRw7EMjM5+KiwzcjYLbuhYOh33opIu4T5Q5WQ889SxToind159nhknKPYfd5rpX4230AjqgD7+COUAX7P41KaI0s9VA+McFK8lG3EBbO+Hev+XmhXZuWUqppH6CqcgUQdRiOJauQl8Pc95bkgtxvmpkDjZT2BHTQ+2AqeN9j6906XN2DdmGUs9/6r5J7kd5dZW61as4Msk9yO8usrdatWcGWSe5HeXWVutWrODLJPcjvLrK3WrVnBlknuR3l1lbrVqzgyyT3I7y6yt1q1ZwZZJ7kd5dZW61as4Msk9yO8usrdatWcGWSe5HeXWVutWrODLJPcjvLrK3WrVnBlknuR3l1lbrVqzgyyT3I7y6yt1q1ZwZZJ7kd5dZW61as4Msk9yO8usrdatWcGWSe5HeXWVutWrODLJPcjvLrK3WrVnBlknuR3l1lbrVqzgyyT3I7y6yt1q1ZwZZJ7kd5dZW61as4Msk9yO8usrdatWcGWSe5HeXWVutW3W9i00eaaxVw192yws7mq72RnAAAAAAAAAAAAAfTbhV+wo4AAADi+oQAAAIWsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB87sk8gQQRSCKQRSCKQRSewAABSHJsRYwGiJfz/fUW6J6L86GU/28v/mdBritFRKU3wc3B/fGp4M9Utmuq8UuyNKNDHoa3zu/IT0nka0Hgr/cHBR4E29khkawrCsnJ66qAAACwGKtI30MMvWzRJ2JGp5L4MB9focvXKvG4/wD9AS2Z11Mt5S79AogA7cyA8r6urbGFNKTjPVdVjTEzUh1Lju1ppzwRjh2BkIwOgS46K5G+XcXKKJ1AOG88kA6cpLmQbSZquVGKo36RXQwtezfWz2PWSXkofo26F8NUEz1bxXNoAAALTeQ7Ar6CAvQoINxxGkLN64OMxn7pH9ISGQKrgfBB9kv0sqfzR/0nPNUk7vRycIki+mb31hoTMLnh0KjhpxqOxVQWyOpmXy63CAhnKtZuLLObs3M96IvO0bTgW/1wXt60plTzGFRoVDdR1T9Nr2/4yFjQXNTfDVejaRDMqzciTqY8n/oQNUjWE3350m2tTaB0gH/a71yp66kVx5jRR+4Rc+wcaEZUmKhCHQx+UkmGFeQAnxtT6IdK7LUDNHnq4kRBLQIUpXL51pv8N2RCAOvQF+3xXuA9zTjBHEhgakTNXyxgESz5XlNOZqiENB3KmVQdC3GUE1bGEs6NAKhIaXjZcT3aVFtumwrXLq5g/snhz+Yw0QyOvDT6cyNw9EXCUF6qtwJRPuVmBPeN8w/GW7XJbQ5L9QxAFu/H4FS9mDeTMuFOBgrAtjGnyxODkEHw0nkLEQJMdz5z9s0keIXR+4I+Pe9UqXqoaWY/fWTvzKxAAAF1HXdhL5Slw9Gy+g8OnDm9RlS0r5hU38W7qw0Q/cP66Uze0sEyssfaH2fUEsMDLN2AxlmELQKmJtzXjpeI6LYYwz8fy2YKCjo80stcKg0qveY9swSVwakCwtmRD44qGwsts35kKdA6t5x5eOyfreFlPGBF2kdnCXC7QoCDd5f9z5CxmxajuVLpQB7Ybz5KOJKtoPao2gAABnDL/cR8K80AufnzHB21VF9gL/cZl/wRdWJTigZzwrpoaZzRwF9kcFsClhQloLTnfBSvqe/CEzgVMQg2BQwAAAEQAWmQAQkvBRk8BeSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABy/Ln/oEAAAAfzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADamZs/GJbjORtEB+m1wF+7nIAAAAV/zj/pMyXYlqkHXS7V3qaDkNCF6/qnR7MUs4ADgAAAHNouY5UduarpjwkiiOp/778/hDQAAA==",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/gOQmEaa",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/gOQmEaa"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，",(0,c.jsx)(n.code,{children:".box"})," 元素的 ",(0,c.jsx)(n.code,{children:"border"})," 引用自己作用域中注册的 ",(0,c.jsx)(n.code,{children:"--primary-color"}),"，浏览器这个时候将其解析为 ",(0,c.jsx)(n.code,{children:"border-width: 5px"}),"，而 ",(0,c.jsx)(n.code,{children:"color"})," 也同时引用了 ",(0,c.jsx)(n.code,{children:"--primary-color"}),"，可相当于 ",(0,c.jsx)(n.code,{children:"color: 5px"})," ，此时浏览器将其继承祖先元素 ",(0,c.jsx)(n.code,{children:"<body>"})," 的 ",(0,c.jsx)(n.code,{children:"color"})," 值。"]}),"\n",(0,c.jsxs)(n.p,{children:["如果你尝试着将 ",(0,c.jsx)(n.code,{children:".box{}"})," 中的 ",(0,c.jsx)(n.code,{children:"--primary-color"})," 禁用，你会发现 ",(0,c.jsx)(n.code,{children:"border"})," 和 ",(0,c.jsx)(n.code,{children:"color"})," 中的 ",(0,c.jsx)(n.code,{children:"--primary-color"})," 将会引用全局的（即 ",(0,c.jsx)(n.code,{children:":root{}"}),"）中注册的值（",(0,c.jsx)(n.code,{children:"--primary-color: #0055fe"}),"）。此时 ",(0,c.jsx)(n.code,{children:"border"})," 中的",(0,c.jsx)(n.code,{children:"var(--primary-color)"})," 被浏览器解析为 ",(0,c.jsx)(n.code,{children:"border-color: #0055fe"}),"，而 ",(0,c.jsx)(n.code,{children:"border-width"})," 被解析为 ",(0,c.jsx)(n.code,{children:"medium"})," 。而 ",(0,c.jsx)(n.code,{children:"color"})," 中的 ",(0,c.jsx)(n.code,{children:"var(--primary-color)"})," 也就是一个有效值了。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["CSS 中的自定义属性的值类型没有任何约束，也就造成上面示例中提到的效果。如果你想对自定义属性值的类型有较强约束的话，就可以使用 CSS Houdini 的 ",(0,c.jsx)(n.code,{children:"@property"})," 来声明 CSS 自定义属性。有关于这方面更详细的介绍，将放到小册后面的相关课程中来介绍。"]}),"\n",(0,c.jsxs)(n.p,{children:["虽然 ",(0,c.jsx)(n.code,{children:"var()"})," 函数引用一个未定义的 CSS 自定义属性，很有可能会令浏览器解析 CSS 规则是造成一定的混乱，但并不是一无事处。有的时候，使用未定义的 CSS 自定义属性也是有益的，比如使实用类更加灵活。未定义属性的好处在于它可以从任何祖先继承其值，这对于更新一组相关元素的值非常理想。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"var()"})," 函数使用未定义的 CSS 自定义属性的两个选项："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["完全未定义且没有默认值，这意味着该属性可能具有未设置的行为，例如：",(0,c.jsx)(n.code,{children:"color: var(--color)"}),"，其中 ",(0,c.jsx)(n.code,{children:"--color"})," 在规则中未设置。"]}),"\n",(0,c.jsxs)(n.li,{children:["未定义但有一个回退值，以同时获得继承和确保默认值的好处，例如：",(0,c.jsx)(n.code,{children:"color: var(--color, blue)"}),"。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"比如下面这个示例："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"button {\n \xa0 \xa0--color: blue;\n​\n \xa0 \xa0color: var(--color);\n \xa0 \xa0border: 2px solid var(--border-color, var(--color));\n}\n​\nbutton:hover {\n \xa0 \xa0--border-color: red;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,UklGRkgGAABXRUJQVlA4IDwGAACQXACdASqqA14BPp1OpE4lpCOiIFLoGLATiWlu4XdhHZFmEBtgNwBvAHoZ/sB6Yfsefsh6O+rEMV/wHQL+Uo/tJX994Y/UBoW+NeCV9I/2XGB2zPGmRS/8T2Tf6Dxv/UX/Y9wz9aAHwi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5Y2IvEFR/ljYi8QVH+WNiLxBUf5X5J4UiX3MTH9WeBeBeBeATxVnxX4MyznI2IvEFR/ljYi8QVH+WNiLxBUf3i3L/I4w9nAfvgHJplTQNlrq+LObk4Z96MtlMibC9iy5Zp0w0z0ZlnORsReIKj/LGxF4gqP8sbEXiCo/vFwwmnPS4lpbw6edPOnnTwMN1FHYZQ8+YI8kPmF5drPsL7qznI2IvEFR/ljYi8QVH+WNiLxBUgZT27o4iWio/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiCo/yxsReIKj/LGxF4gqP8sbEXiAQAD+/9J6AAAAAAAAAAAAAAAAAAABuqQOI9Y95UmrqXwuOfX1R8mqtd1+LF2kt04ujP+JLwkTfGE+n/wjU4MPDZhs9A9YQ7vVw2Dy//eW09vfwciluZ2w+icFgsFYYQXqYna0WT91WnEGVR0RocHqKj2kkdd4pEsPv8f/PymVvXCA3y4Ah3YNvnf9hyYrwLDOcK9gF/Zm3af/iXJKCRfyaFY//jsWSbemAPcdAsQ/sDubQNstaImzn5UrS6aCusbr7rb+2Mj9kcaAV1pg2eWlVJn+gVbzxwDC6V9OVRkjToaZBrk1CQVftUphLwLkDtfAQS7851/fPDUdexWPkP0BOB79KreLyZ2VdjIMa0L1/m/ZYP5zME6MLWW273SjQqGkLe1zp2iRCKupMi+/Ah3k3bZloKUSZ6Ve2l4v/l5ZV/XcbCh9oOdb40o7TDm2tOKcS/j4PZnXX/4gpSL8AH/uZ/0U2cuF82sVC5Dgz2ncz6CxaiglsoYHzg5Lk19mYpRVFHca5xqE4Q/cX7z8JZixGQpL6mdZeTsrPoulo6YV9zZ3s0o1jNz/BHdb/ieDaUtytswYIHPLyrfX+95p7qHSmhqxCCJtmejHGcSkgP5uwWyxnA4Akrs+vB+HQGoex59/SWFCn50aYI4OYIUo0V85KQz2/mI/230po98d/3aA5u1ml37G7Uvuukdokbb2eKuP7Sl8Ft8ZRGss7pUmL5dBPEC0EN6mi31rubkq19oZ71v0tfUiCHtkOTqpOzjRBpw3cDysz1jk3kr0A8hg66ztVM6dPDzUnk/2vdBHzCVuP5dFT5ypYpomu8XXraL04icjbS0a/vMTfjCeVX/s5M6Dlc5UB1Y6gtzEPqBvY2kVjB6TqBPjmqiS838y3k80mR2qZor8emF2VnEnXUuEe9Q+kdPw0+SNHz7yBl66cq/vnTu/Ol8bfJ2ob8bR6F83dDDt4L1Yh+ELkcTm1XxB6gSNjxvuNQk91ZrRvc/e2hJHQdKjzigXqbuX8gwOyvqtanhGuxZT6SGw52/BMzK4Ho1hrUd5VBtO9Zje9Fud+H3b8ooEqI7oclT6k0l5lYPvA1OB8fsCOeutZdcptE8QAAAAAAAAAAAAAAAAAAAAAAAAAAA=",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/poQeYPa",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/poQeYPa"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["在这个示例中，我们并没有显式声明 ",(0,c.jsx)(n.code,{children:"--border-color"})," 这个自定义属性，但 ",(0,c.jsx)(n.code,{children:"var()"})," 函数调用它的时候提供了一个回退值 ",(0,c.jsx)(n.code,{children:"var(--color)"}),"，这样一来，",(0,c.jsx)(n.code,{children:"--border-color"})," 同时获得继承和确保默认值的好处，同时也为组件提供了一个可选的 ",(0,c.jsx)(n.code,{children:"--border-color"})," 值。"]}),"\n",(0,c.jsx)(n.p,{children:"使用第一种选项时需要注意的是，你可能会期望它使用你样式表中已设置的元素的先前样式。然而，当计算自定义属性时，浏览器已经丢弃了先前设置的、非继承的值。"}),"\n",(0,c.jsxs)(n.p,{children:["在这个示例中，如果未设置 ",(0,c.jsx)(n.code,{children:"--color"}),"，按钮的文本颜色（",(0,c.jsx)(n.code,{children:"color"}),"）就会使用继承的颜色，颜色将从最近的祖先继承。而按钮的边框颜色在默认状态下会被浏览器解析为 ",(0,c.jsx)(n.code,{children:"currentColor"})," ，但默认状态下按钮会没有边框，因为它被解析为 ",(0,c.jsx)(n.code,{children:"0px none currentColor"})," ，而其悬浮状态（",(0,c.jsx)(n.code,{children:":hover"}),"）下 ",(0,c.jsx)(n.code,{children:"--border-color"})," 的值为 ",(0,c.jsx)(n.code,{children:"red"})," ，此时浏览器会将按钮边框解析为 ",(0,c.jsx)(n.code,{children:"2px solid red"})," 。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:"img"})}),"\n",(0,c.jsx)(n.p,{children:"注意，这样的骚操作对于 Web 性能来说是昂贵的，按钮在悬浮状态下会产生重绘。"}),"\n",(0,c.jsxs)(n.h3,{id:"var-函数可以提供回退值",children:["var() 函数可以提供回退值",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#var-函数可以提供回退值",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["当 ",(0,c.jsx)(n.code,{children:"var()"})," 函数引用了一个未定义的自定义属性时，可能会给开发者带来一定的困惑。为了避免这种现象，我们可以使用 ",(0,c.jsx)(n.code,{children:"var()"})," 函数的第二个参数来作为其回退值。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"var() = var( <custom-property-name> [, <declaration-value> ]? ) \n"})}),"\n",(0,c.jsxs)(n.p,{children:["这样做的主要目的是，",(0,c.jsx)(n.code,{children:"var()"})," 函数引用了未定义或手误写错了自定义属性名称时，会有一个降级处理。例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--primary-color: #0055fe; \n} \n​\n.box { \n \xa0 \xa0background-color: var(--primy-color, #f36); \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["从代码中可以看得出来，",(0,c.jsx)(n.code,{children:"var()"})," 函数引用了一个没有定义的自定义属性，我们定义的是 ",(0,c.jsx)(n.code,{children:"--primary-color"})," 属性，而实际引用的是 ",(0,c.jsx)(n.code,{children:"--primy-color"})," 属性。在这个示例中，",(0,c.jsx)(n.code,{children:"--primy-color"})," 并不存在（未显式定义）。此时，",(0,c.jsx)(n.code,{children:"var()"})," 函数会将 ",(0,c.jsx)(n.code,{children:"#f36"})," 作为回退值，你会看到元素 ",(0,c.jsx)(n.code,{children:".box"})," 的背景颜色会是 ",(0,c.jsx)(n.code,{children:"#f36"})," ："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/wvQdGoL",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/wvQdGoL"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["在使用 ",(0,c.jsx)(n.code,{children:"var()"})," 函数时，还可以嵌套 ",(0,c.jsx)(n.code,{children:"var()"})," 函数，即在 ",(0,c.jsx)(n.code,{children:"var()"})," 函数的第二个参数也是 ",(0,c.jsx)(n.code,{children:"var()"})," 函数："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:".box { \n \xa0 \xa0background-color: var(--primary-color, var(--black, #f36)); \n} \n"})}),"\n",(0,c.jsx)(n.p,{children:"甚至还可以嵌套的更深："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:" .element {\n \xa0 \xa0 color: var(--foo, var(--bar, var(--baz, var(--are, var(--you, var(--crazy))))); \n }\n"})}),"\n",(0,c.jsx)(n.p,{children:"但在实际使用的时候并不推荐这样使用，因为层级嵌套的越深越容易出错，而且这样同时增加了代码维护的成本。"}),"\n",(0,c.jsxs)(n.h3,{id:"自定义属性的作用域",children:["自定义属性的作用域",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义属性的作用域",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["前面在介绍 CSS 自定义属性与 CSS 处理器的变量之间差异时，已经向大家介绍过，CSS 自定义属性的作用域也有全局和局部之分。通常的约定是，在 ",(0,c.jsx)(n.code,{children:":root"})," 或 ",(0,c.jsx)(n.code,{children:"html"})," 选择器中声明的自定义属性是全局的，而在其他选择器中声明的自定义属性则称为局部的。"]}),"\n",(0,c.jsxs)(n.p,{children:["很多时候大家都会把 ",(0,c.jsx)(n.code,{children:":root"})," 和 ",(0,c.jsx)(n.code,{children:"html"})," 等同起来，事实上并非如此，因为 ",(0,c.jsx)(n.code,{children:"html"})," 的权重小于 ",(0,c.jsx)(n.code,{children:":root"}),"，好比 ",(0,c.jsx)(n.code,{children:"div"})," 元素标签的权重小于带有类名的 ",(0,c.jsx)(n.code,{children:"div"})," 权重，比如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--color: red; \n} \n​\nhtml { \n \xa0 \xa0--color: green; \n} \n​\n.box { \n \xa0 \xa0--color: orange; \n} \n"})}),"\n",(0,c.jsx)(n.p,{children:"这样一来，其作用域是："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:".box"})," 中的 ",(0,c.jsx)(n.code,{children:"--color"})," 会作用于类名为 ",(0,c.jsx)(n.code,{children:".box"})," 元素以及其所有后代元素"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"html"})," 中的 ",(0,c.jsx)(n.code,{children:"--color"})," 会作用于 ",(0,c.jsx)(n.code,{children:"<html>"})," 元素以及其所有后代元素"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:":root"})," 中的 ",(0,c.jsx)(n.code,{children:"--color"})," 在 HTML 中会作用于 ",(0,c.jsx)(n.code,{children:"<html>"})," 以及其所有后代元素，在 XML 中（比如 ",(0,c.jsx)(n.code,{children:"svg"}),"）则会作用于 ",(0,c.jsx)(n.code,{children:"<svg>"})," 以及其所有后代元素"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"来看一个具体的示例，可能会更清晰一些："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-HTML",children:'<div class="box">\n \xa0  我带有一个名为 box 类\n \xa0 \xa0<span>我是 .box 元素的后代元素</span>\n \xa0 \xa0<span class="element">我也是 .box 元素的后代元素，但我有一个名为 element 的类 </span>\n</div>\n​\n<div class="element">\n \xa0  我带有一个名为 element 的类\n \xa0 \xa0<span>我是 .element 元素的后代元素</span>\n \xa0 \xa0<span class="box">我也是 .element 元素的后代元素，但我有一个名为 box 的类 </span>\n</div>\n'})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root {\n \xa0  --color: red;\n}\n​\nhtml {\n \xa0  --color: green;\n}\n​\n.box {\n \xa0  --color: orange;\n}\n​\n.box {\n \xa0  border-color: var(--color);\n \xa0  color: var(--color);\n}\n​\n.element {\n \xa0  border-color: var(--color);\n \xa0  color: var(--color);\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:S,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/YzRVqJB",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/YzRVqJB"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["不难发现，",(0,c.jsx)(n.code,{children:".box"})," 中定义的 ",(0,c.jsx)(n.code,{children:"--color"})," 会运用于 ",(0,c.jsx)(n.code,{children:".box"})," 元素及其所有后代元素，而 ",(0,c.jsx)(n.code,{children:".element"})," 元素并没有显式定义自定义属性 ",(0,c.jsx)(n.code,{children:"--color"})," ，它会根据 DOM 结构往上查询，查询其祖先元素是否显式定义了 ",(0,c.jsx)(n.code,{children:"--color"})," 。在我们这个示例中，",(0,c.jsx)(n.code,{children:"html"})," 元素中定义的 ",(0,c.jsx)(n.code,{children:"--color"})," 会运用于 ",(0,c.jsx)(n.code,{children:".element"})," 元素及其后代元素，只不过 ",(0,c.jsx)(n.code,{children:".element"})," 元素中的 ",(0,c.jsx)(n.code,{children:".box"})," 有自已定义的 ",(0,c.jsx)(n.code,{children:"--color"})," 而且，不会使用 ",(0,c.jsx)(n.code,{children:"html"})," 中的 ",(0,c.jsx)(n.code,{children:"--color"})," 。"]}),"\n",(0,c.jsxs)(n.p,{children:["因此，如果你要声明一个全局作用域的 CSS 的自定义属性，最佳方式是在 ",(0,c.jsx)(n.code,{children:":root"})," 或 ",(0,c.jsx)(n.code,{children:"html"})," 选择器内声明。这也将引出一个问题：“为什么我们要在 ",(0,c.jsx)(n.code,{children:":root"})," 或 ",(0,c.jsx)(n.code,{children:"html"})," 上定义全局自定义属性，而不是在 ",(0,c.jsx)(n.code,{children:"body"})," 上定义呢？”"]}),"\n",(0,c.jsxs)(n.p,{children:["这是个很好的问题：似乎大家都习惯于在 ",(0,c.jsx)(n.code,{children:":root"})," 选择器上定义全局自定义属性（也称为 CSS 变量），并且并没有再多考虑。但为什么选择 ",(0,c.jsx)(n.code,{children:":root"})," 呢？答案是，并没有真正理由，这只是一种惯例。将自定义属性定义在 ",(0,c.jsx)(n.code,{children:":root"})," 选择器上可能会使它们看起来更像是全局变量，因为 ",(0,c.jsx)(n.code,{children:":root"})," 相当于文档的根元素。在 HTML 中，根元素就是 ",(0,c.jsx)(n.code,{children:"<html>"})," 元素。在 SVG 中，根元素就是 ",(0,c.jsx)(n.code,{children:"<svg>"})," 元素。也就是说，如果你希望将相同的自定义属性应用于不同类型的文档，比如 HTML 文档或 SVG 文档，那么 ",(0,c.jsx)(n.code,{children:":root"})," 来定义全局自定义属性更有益处，否则它并不会带来其他的好处，也没有实际的技术优势。换句话说，如果你的 CSS 自定义属性仅服务于 HTML 文档，那么在 ",(0,c.jsx)(n.code,{children:":root"})," 、",(0,c.jsx)(n.code,{children:"html"})," 和 ",(0,c.jsx)(n.code,{children:"body"})," 声明的都将是全局 CSS 自定义属性，它们的工作方式完全相同。"]}),"\n",(0,c.jsx)(n.p,{children:"当然，如果你想使用 JavaScript 来操作 CSS 自定义属性，那么还是需要用稍微不同的方式来编码。如果你想通过文档根元素来访问它们，可以这样操作："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:'getComputedStyle(document.documentElement).getPropertyValue("–color")；\n'})}),"\n",(0,c.jsxs)(n.p,{children:["但如果你想获取或设置它们的值，你需要使用 ",(0,c.jsx)(n.code,{children:"body"})," 元素来操作："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:'getComputedStyle(document.body).getPropertyValue("–color")\n'})}),"\n",(0,c.jsx)(n.p,{children:"不过这只是个人偏好的问题。"}),"\n",(0,c.jsxs)(n.p,{children:["另外，了解到 ",(0,c.jsx)(n.code,{children:":root"})," 选择器的权重比 ",(0,c.jsx)(n.code,{children:"html"})," 选择器高可能会有趣，但在实践中并没有什么区别。只不过，使用 ",(0,c.jsx)(n.code,{children:":root"})," 作为最外层元素似乎是更合理的一种选择。如果从继承机制角度来看，使用 ",(0,c.jsx)(n.code,{children:":root"})," 并不总是能够确保自定义属性被所有元素继承。例如，它目前无法用于 ",(0,c.jsx)(n.code,{children:"::backdrop"})," 和 ",(0,c.jsx)(n.code,{children:"::selection"})," 等伪元素。在这两种情况下，尝试使用在 ",(0,c.jsx)(n.code,{children:":root"})," 上定义的自定义属性将毫无结果。",(0,c.jsx)(n.a,{href:"https://github.com/w3c/csswg-drafts/issues/6641",target:"_blank",rel:"noopener noreferrer",children:"CSS 工作组正在讨论解决这个问题的方法"}),"。但这绝对是许多人可能没有意识到的问题。"]}),"\n",(0,c.jsxs)(n.p,{children:["尽管在继承上存在一定的不一致性，尽管我们也可以在 ",(0,c.jsx)(n.code,{children:"<body>"})," 上定义，但使用 ",(0,c.jsx)(n.code,{children:":root"})," 选择器来定义全局自定义属性已成为一种常见做法。但对我而言，真正有趣的是，通过使用这种约定，我们在使用自定义属性的方式上似乎变得有些自满。因为在 ",(0,c.jsx)(n.code,{children:":root"})," 上定义大部分或所有自定义属性也可能成为一个问题。例如，你只在一个地方来定义所有的自定义属性，你可能在一个地方管理所有 CSS 的自定义属性，但你也会失去很多灵活性。例如，在构建组件时，我们应该将运用于组件的 CSS 自定义属性在组件的最外层容器中定义，以便你可以轻松地添加或删除自定义属性，而且还不会影响其周围的全局代码，甚至不会破坏系统的其他部分。全局定义的局部属性将使这变得更加困难。所以说，我们没有理由在 ",(0,c.jsx)(n.code,{children:":root"})," 中定义实际上属于单个组件的局部自定义属性。"]}),"\n",(0,c.jsxs)(n.p,{children:["当涉及到自定义属性的深度时，即多少属性继承或包含其他属性的值，我们仍然没有充分利用自定义属性的潜力。或者换句话说，我们并不经常在自定义属性中嵌套使用其他自定义属性。其中一个原因可能是我们仍然将 CSS 自定义属性视作为常量。我们通常将它们用作固定值的替代，只需在一个中心位置定义即可，这通常是 ",(0,c.jsx)(n.code,{children:":root"}),"。然而，要理解自定义属性能够做到更多，并改变这种习惯，是发掘其全部潜力的关键。"]}),"\n",(0,c.jsx)(n.p,{children:"比如，你可以在本地使用自定义属性，它们基本上就像是基于全局变量的私有变量。听起来复杂吗？想象一下一个简单的按钮组件，其中背景颜色存储在全局自定义属性中："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* tokens.css */\n:root {\n \xa0 \xa0--color: hsl(160 100% 75%);\n}\n​\n/* button.css */\nbutton {\n \xa0 \xa0background-color: var(--color);\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这通常情况下能很好地工作，并且该颜色值也能很好地继承到按钮组件中。这在设计系统（或模块化网站）中正是你想要的。然而，为自定义属性提供回退值是一个很好的做法，这样即使没有定义 ",(0,c.jsx)(n.code,{children:"--color"})," 属性，组件仍然能够正常工作。通过一个本地自定义属性，它基于全局属性，但已经包含了回退值，你可以保持从组件外部操纵颜色的灵活性。同时，你也使实现更加健壮："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* tokens.css */\n:root {\n \xa0 \xa0--color: hsl(160 100% 75%);\n}\n​\n/* button.css */\nbutton {\n \xa0 \xa0--_color: var(--color, black)\n \xa0 \xa0background-color: var(--_color);\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果我们在一个提供 ",(0,c.jsx)(n.code,{children:"--color"})," 的系统中使用按钮组件，按钮的背景颜色将是我们定义的颜色。如果没有提供 ",(0,c.jsx)(n.code,{children:"--color"}),"，组件仍然能够正常工作并使用回退颜色黑色。在组件内部，我们可以使用本地自定义属性（以下划线开头，这也是一种约定）来定义悬停样式、边框、阴影等。此外，我们仍然可以从组件外部操纵或设置 ",(0,c.jsx)(n.code,{children:"--color"})," 变量，而不会破坏组件。下图可以很好的说明这一点："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:"img"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"/* 全局的自定义属性 */ \n:root { \n \xa0 \xa0--primary-color: #235ad1; \n \xa0 \xa0--unit: 1rem; \n} \n​\n/* 运用了全局定义的自定义属性 */ \n.section-title { \n \xa0 \xa0color: var(--primary-color); \n \xa0 \xa0margin-bottom: var(--unit); \n} \n​\n/* 自定义了局部变量，将覆盖全局定义的自定义属性 */ \n.featured-authors .section-title { \n \xa0 \xa0--primary-color: #d16823; \n} \n​\n/* 自定义了局部变量，将覆盖全局定义的自定义属性 */ \n.latest-articles .section-title { \n \xa0 \xa0--primary-color: #d12374; \n \xa0 \xa0--unit: 2rem; \n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"循环依赖的-css-自定义属性是无效的",children:["循环依赖的 CSS 自定义属性是无效的",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#循环依赖的-css-自定义属性是无效的",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"CSS 是一门声明性的语言，元素的样式规则没有顺序的概念，相同的属性出现在同一个选择器块内，后者会覆盖前者。例如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--size: 10px; \n \xa0 \xa0--size: var(--size); \n} \n​\nbody { \n \xa0 \xa0font-size: var(--size, 2rem); \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["示例代码中的 ",(0,c.jsx)(n.code,{children:"--size"})," 在同一个选择器内出现了两次，按照 CSS 规则特性来说，上面代码中的 ",(0,c.jsx)(n.code,{children:"--size: var(--size)"})," 将会覆盖前面出现的 ",(0,c.jsx)(n.code,{children:"--size: 10px"})," 。而且第二个 ",(0,c.jsx)(n.code,{children:"--size"})," 自定义属性有一个明显的特征，它的值依赖了自身，即 ",(0,c.jsx)(n.code,{children:"var()"})," 函数引用的是自身，该值是无效的。",(0,c.jsx)(n.code,{children:"body"})," 的 ",(0,c.jsx)(n.code,{children:"font-size"})," 引用的是 ",(0,c.jsx)(n.code,{children:"--size"})," 是个无效值，但 ",(0,c.jsx)(n.code,{children:"var()"})," 会采用其第二个参数 ",(0,c.jsx)(n.code,{children:"2rem"})," 作为备用值。因此，",(0,c.jsx)(n.code,{children:"body"})," 现在的 ",(0,c.jsx)(n.code,{children:"font-size"})," 的值是 ",(0,c.jsx)(n.code,{children:"2rem"})," 。"]}),"\n",(0,c.jsxs)(n.h3,{id:"有效的自定义属性值",children:["有效的自定义属性值",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#有效的自定义属性值",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"自定义属性在接受值时非常宽容。以下是一些基本示例，你可以预期它们有效。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:':root {\n \xa0 \xa0--brand-color: #990000;\n \xa0 \xa0--transparent-black: rgba(0, 0, 0, 0.5);\n \xa0\n \xa0 \xa0--spacing: 0.66rem;\n \xa0 \xa0--max-reading-length: 70ch;\n \xa0 \xa0--brandAngle: 22deg;\n​\n \xa0 \xa0--visibility: hidden;\n \xa0 \xa0--my-name: "w3cplus";\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"现在看到了吗？它们可以是十六进制值、颜色函数、各种单位，甚至可以是文本字符串。"}),"\n",(0,c.jsx)(n.p,{children:"不过，自定义属性并不必像那样是完整的值。让我们看看将有效的 CSS 值拆分为可以放入自定义属性的部分的用法有多方便。"}),"\n",(0,c.jsxs)(n.p,{children:["让我们想象一下，你正在使用一个颜色函数，比如 ",(0,c.jsx)(n.code,{children:"rgb()"}),"。其中的每个颜色通道值都可以是自定义属性。这打开了很多可能性，比如针对特定用例更改 Alpha 值，或者创建颜色主题。"]}),"\n",(0,c.jsx)(n.p,{children:"以 HSL 颜色为例，我们可以将其拆分为各个部分，然后很容易地调整我们想要的部分。也许我们正在处理按钮的背景颜色。当鼠标悬停在按钮上时，我们可以更新其 HSL 构成的特定部分，在焦点状态下或禁用状态下，完全不需要在任何状态下声明背景。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"button {\n \xa0 \xa0--h: 100;\n \xa0 \xa0--s: 50%;\n \xa0 \xa0--l: 50%;\n \xa0 \xa0--a: 1;\n \xa0 \xa0\n \xa0 \xa0background-color: hsl(var(--h) var(--s) var(--l) / var(--a));\n}\n​\n/* 悬浮状态下改变亮度值 */\nbutton:hover {\n \xa0 \xa0--l: 75%; \xa0 \xa0\n}\n​\n/* 聚焦状态下改变饱和度 */\nbutton:focus {\n \xa0 \xa0--s: 75%;\n}\n​\n/* 禁用状态改变饱和度和透明度 */\nbutton[disabled] {\n \xa0 \xa0--s: 0%;\n \xa0 \xa0--a: .5;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"通过拆分这样的值，我们可以以前无法做到的方式来控制它们的各个部分。看看我们在样式化按钮的悬停、焦点和禁用状态时，没有必要声明 HSL 参数的所有值。我们只需要在需要的地方覆盖特定的 HSL 值即可。非常酷！"}),"\n",(0,c.jsxs)(n.p,{children:["熟悉 CSS 的同学应该知道，在 CSS 中有些属性是有子属性的，比如 ",(0,c.jsx)(n.code,{children:"border-width"})," 、",(0,c.jsx)(n.code,{children:"boder-style"})," 等，但有些属性是没有子属性的，比如 ",(0,c.jsx)(n.code,{children:"box-shadow"})," 属性。它是没有单独控制阴影的子属性。但是，我们可以将 ",(0,c.jsx)(n.code,{children:"box-shadow"})," 属性的值分离出来，将其作为自定义属性来控制。例如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root {\n \xa0 \xa0--shadow-x: 0;\n \xa0 \xa0--shadow-y: 0;\n \xa0 \xa0--shadow-color: rgb(0 0 0);\n \xa0 \xa0--shadow-blur: .2em;\n \xa0 \xa0--shadow-spread: .12em;\n}\n​\nbutton {\n \xa0 \xa0box-shadow: \n \xa0 \xa0 \xa0 \xa0var(--shadow-x) \n \xa0 \xa0 \xa0 \xa0var(--shadow-y) \n \xa0 \xa0 \xa0 \xa0var(--shadow-blur) \n \xa0 \xa0 \xa0 \xa0var(--shadow-spread)\n \xa0 \xa0 \xa0 \xa0var(--shadow-color);\n}\n​\nbutton:hover {\n \xa0 \xa0--shadow-y: .2em;\n \xa0 \xa0--shadow-spread: .5em;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/eYQWzEK",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/eYQWzEK"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["同样的，在 CSS 中并没有一个 ",(0,c.jsx)(n.code,{children:"background-gradient-angle"})," （或类似的）属性，允许我们调整渐变的角度。不过，我们可以将渐变的角度使用 CSS 自定义属性来描述，这样你就可以像下面这样来调整渐变的角度："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0--angle: 180deg;\n \xa0 \xa0background: linear-gradient(var(--angle), #09f, #5500fe);\n}\n​\nbody.sideways {\n \xa0 \xa0--angle: 90deg;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:A,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/vYQmKdO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/vYQmKdO"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["CSS 中有些属性是支持逗号分隔列表，比如 ",(0,c.jsx)(n.code,{children:"translate"})," 、",(0,c.jsx)(n.code,{children:"scale"})," 和 ",(0,c.jsx)(n.code,{children:"background"})," （多背景）。我们没办法仅针对逗号分隔列表中的一个值进行更改。但有了 CSS 自定义属性之后，这一切就变得很简单。拿多背景为例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0background-image:\n \xa0 \xa0 \xa0 \xa0url('./images/angles-top-left.svg'),\n \xa0 \xa0 \xa0 \xa0url('./images/angles-top-right.svg'),\n \xa0 \xa0 \xa0 \xa0url('./images/angles-bottom-left.svg'),\n \xa0 \xa0 \xa0 \xa0url('./images/angles-bottom-right.svg');\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"假设你想在媒体查询中仅删除或调整多背景中的一个，可以使用 CSS 自定义属性来完成，会灵活的多："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0--bg1: url(./images/angles-top-left.svg);\n \xa0 \xa0--bg2: url(./images/angles-top-right.svg);\n \xa0 \xa0--bg3: url(./images/angles-bottom-left.svg);\n \xa0 \xa0--bg4: url(./images/angles-bottom-right.svg);\n \xa0 \xa0--bg5: url(./images/bonus-background.svg);\n \xa0 \xa0\n \xa0 \xa0background-image:\n \xa0 \xa0 \xa0 \xa0var(--bg1),\n \xa0 \xa0 \xa0 \xa0var(--bg2),\n \xa0 \xa0 \xa0 \xa0var(--bg3),\n \xa0 \xa0 \xa0 \xa0var(--bg4);\n}\n​\n@media only screen and (width > 1500px) {\n \xa0 \xa0body {\n \xa0 \xa0 \xa0 \xa0background-image: var(--bg1), var(--bg2), var(--bg3), var(--bg4), var(--bg5);\n \xa0  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["CSS 很快就会支持单独的 ",(0,c.jsx)(n.code,{children:"transform"})," 属性，比如 ",(0,c.jsx)(n.code,{children:"translate"})," 、",(0,c.jsx)(n.code,{children:"rotate"})," 和 ",(0,c.jsx)(n.code,{children:"scalc"})," 等，但我们可以通过自定义属性提前实现它。这个想法是先应用元素可能得到的所有 ",(0,c.jsx)(n.code,{children:"transform"}),"，然后根据需要分别控制它们："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"button {\n \xa0 \xa0transform: var(--scale, scale(1)) var(--translate, translate(0));\n}\n​\nbutton:active {\n \xa0 \xa0--translate: translate(0, 2px);\n}\n​\nbutton:hover {\n \xa0 \xa0--scale: scale(.9);\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["有时候，将值的部分组合在一起并不完全如你所希望的那样。例如，你不能简单地将 ",(0,c.jsx)(n.code,{children:"24"})," 和 ",(0,c.jsx)(n.code,{children:"px"})," 粘在一起来获得 ",(0,c.jsx)(n.code,{children:"24px"}),"。不过，可以通过将原始数字乘以带有单位的数值来实现。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0--value: 24;\n \xa0 \xa0--unit: px;\n \xa0 \xa0\n \xa0 \xa0/* 无效，行不通的 */\n \xa0 \xa0font-size: var(--value) + var(--unit);\n \xa0 \xa0\n \xa0 \xa0/* 有效，可行的 */\n \xa0 \xa0font-size: calc(var(--value) * 1px);\n \xa0 \xa0\n \xa0 \xa0--pixel_converter: 1px;\n \xa0 \xa0font-size: calc(var(--value) * var(--pixel_converter));\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"css-自定义属性的基本运算和延迟计算",children:["CSS 自定义属性的基本运算和延迟计算",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性的基本运算和延迟计算",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"当我们将自定义属性与数学运算相结合时，就会释放出更多的力量！"}),"\n",(0,c.jsx)(n.p,{children:"这种情况很常见："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"main {\n \xa0 \xa0--spacing: 2rem;\n}\n​\n.module {\n \xa0 \xa0padding: var(--spacing);\n}\n​\n.module--tight {\n \xa0 \xa0padding: calc(var(--spacing) / 2);\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"我们还可以使用它来计算互补色的色调："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"html {\n \xa0 \xa0--brand-hue: 320;\n \xa0 \xa0--brand-color: hsl(var(--brand-hue) 50% 50%);\n \xa0 \xa0--complement: hsl(calc(var(--brand-hue) + 180) 50% 50%);\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"calc()"})," 甚至可以与多个自定义属性一起使用:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:".slider {\n \xa0 \xa0width: calc(var(--number-of-boxes) * var(--width-of-box));\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在没有 ",(0,c.jsx)(n.code,{children:"calc()"})," 函数的情况下进行类似数学计算，可能看起来有点奇怪："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0/* 合法的，但实际上尚未执行计算 */\n \xa0 \xa0--font-size: var(--base-font-size) * var(--modifier);\n \xa0 \xa0\n \xa0 \xa0/* 所以不会起作用 */\n \xa0 \xa0font-size: var(--font-size);\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["关键是，只要将其放入 ",(0,c.jsx)(n.code,{children:"calc()"})," 函数中，它就能正常工作："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0--base-font-size: 16px;\n \xa0 \xa0--modifier: 2;\n \xa0 \xa0--font-size: var(--base-font-size) * var(--modifier);\n \xa0 \xa0\n \xa0 \xa0/* calc() 在这里被延迟使用，这样就可以正常工作 */\n \xa0 \xa0font-size: calc(var(--font-size));\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果你在变量上进行了大量的数学计算，并且在代码中看到 ",(0,c.jsx)(n.code,{children:"calc()"})," 函数会分散注意力，这可能会很有用。"]}),"\n",(0,c.jsxs)(n.h3,{id:"css-自定义属性的逻辑运算",children:["CSS 自定义属性的逻辑运算",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性的逻辑运算",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 CSS 处理器中是有逻辑运算的功能，比如 ",(0,c.jsx)(n.code,{children:"@if"}),"、",(0,c.jsx)(n.code,{children:"@else"}),"等特性可以帮助我们在代码中做一些条件判断的操作。不幸的是，CSS 目前还不具备这方面的原生特性，不过，我们可以借助 CSS 自定义属性的相关特性配合 ",(0,c.jsx)(n.code,{children:"calc()"})," 函数来实现一个类似于 ",(0,c.jsx)(n.code,{children:"if ... else"})," 这样的条件判断功能。假设有一个自定义属性 ",(0,c.jsx)(n.code,{children:"--i"}),"，当："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"--i"})," 的值为 ",(0,c.jsx)(n.code,{children:"1"})," 时，表示真（即打开）"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"--i"})," 的值为 ",(0,c.jsx)(n.code,{children:"0"})," 时，表示假（即关闭）"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["来看一个小示例，我们有一个容器 ",(0,c.jsx)(n.code,{children:".box"}),"，希望根据自定义属性 ",(0,c.jsx)(n.code,{children:"--i"})," 的取值为 ",(0,c.jsx)(n.code,{children:"0"})," 或 ",(0,c.jsx)(n.code,{children:"1"})," 做条件判断："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["当 ",(0,c.jsx)(n.code,{children:"--i"})," 的值为 ",(0,c.jsx)(n.code,{children:"1"})," 时，表示真，容器 ",(0,c.jsx)(n.code,{children:".box"})," 旋转 ",(0,c.jsx)(n.code,{children:"30deg"})]}),"\n",(0,c.jsxs)(n.li,{children:["当 ",(0,c.jsx)(n.code,{children:"--i"})," 的值为 ",(0,c.jsx)(n.code,{children:"0"})," 时，表示假，容器 ",(0,c.jsx)(n.code,{children:".box"})," 不旋转"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"代码可能像下面这样："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--i: 0; \n} \n​\n.box { \n \xa0 \xa0/** \xa0\n \xa0 \xa0 * 当 --i = 0 \xbb calc(var(--i) * 30deg) = calc(0 * 30deg) = 0deg \n \xa0 \xa0 * 当 --i = 1 \xbb calc(var(--i) * 30deg) = calc(1 * 30deg) = 30deg \n \xa0 \xa0 */\n \xa0 \xa0transform: rotate(calc(1 - var(--i)) * 30deg)); \n} \n​\n.box.rotate { \n \xa0 \xa0--i: 1; \n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"或者："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:":root { \n \xa0 \xa0--i: 1; \n} \n​\n.box { \n \xa0 \xa0/** \n \xa0 \xa0 * 当 --i = 0 \xbb calc((1 - var(--i)) * 30deg) = calc((1 - 0) * 30deg) = calc(1 * 30deg) = 30deg \n \xa0 \xa0 * 当 --i = 0 \xbb calc((1 - var(--i)) * 30deg) = calc((1 - 1) * 30deg) = calc(0 * 30deg) = 0deg \n \xa0 \xa0 */\n \xa0 \xa0transform: rotate(calc((1 - var(--i)) * 30deg));\n} \n​\n.box.rotate { \n \xa0 \xa0--i: 0; \n} \n"})}),"\n",(0,c.jsx)(n.p,{children:"整个效果如下图："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:["上面演示的是 ",(0,c.jsx)(n.code,{children:"0"})," 和 ",(0,c.jsx)(n.code,{children:"1"})," 之间的切换，其实还可以非零之间的切换，非零值之间的切换相对而言要更为复杂一些，这里就不做过多的阐述，如果感兴趣的话，可以阅读 @Ana 的两篇博文："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://css-tricks.com/dry-switching-with-css-variables-the-difference-of-one-declaration/",target:"_blank",rel:"noopener noreferrer",children:"DRY Switching with CSS Variables: The Difference of One Declaration"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://css-tricks.com/dry-state-switching-with-css-variables-fallbacks-and-invalid-values/",target:"_blank",rel:"noopener noreferrer",children:"DRY State Switching With CSS Variables: Fallbacks and Invalid Values"})}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"有效使用-css-自定义属性的无效变量",children:["有效使用 CSS 自定义属性的无效变量",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#有效使用-css-自定义属性的无效变量",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义中有一个概念，被称为“无效变量”。",(0,c.jsx)(n.a,{href:"https://w3.org/TR/css-variables-1/#invalid-variables",target:"_blank",rel:"noopener noreferrer",children:"W3C 规范是这样描述 CSS 自定义属性的无效变量"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:"img"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"当一个自定义属性的值是"})," ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.code,{children:"initial"})})," ",(0,c.jsx)(n.strong,{children:"时，"}),(0,c.jsx)(n.code,{children:"var()"})," ",(0,c.jsx)(n.strong,{children:"函数不能使用它进行替换。除非指定了一个有效的回退值，否则会使声明在计算值时无效"})," 。"]}),"\n",(0,c.jsxs)(n.p,{children:["也就是说，当一个自定义属性的值是一个保证无效的值时，",(0,c.jsx)(n.code,{children:"var()"})," 函数不能使用它进行替换。即一个声明包含一个引用了具有保证无效值的自定义属性的 ",(0,c.jsx)(n.code,{children:"var()"})," 函数，或者它使用了一个有效的自定义属性，但在替换了它的 ",(0,c.jsx)(n.code,{children:"var()"})," 函数之后，属性值是无效的，那么这个声明在计算值时可能是无效的。"]}),"\n",(0,c.jsxs)(n.p,{children:["当这种情况发生时，属性的计算值要么是属性的继承值，要么是它的初始值，分别取决于属性是否被继承，就像属性的值被指定为 ",(0,c.jsx)(n.code,{children:"unset"})," 关键字一样。"]}),"\n",(0,c.jsxs)(n.p,{children:["其中原因是继承的标准属性将初始化处理为 ",(0,c.jsx)(n.code,{children:"unset"})," ，除了行为是“从根开始未设置”。而且前面也说过："]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"级联值在计算值时间无效时就应该被扔掉"})," 。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"比如下面这个示例："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-HTML",children:'<div class="element">Element</div>\n'})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:".element { \n \xa0  --color: red; \n \xa0  background-color: var(--color, orange); \n }\n \n .element:hover {\n \xa0 \xa0 --color: initial;\n }\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/JjeNbWO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/JjeNbWO"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["示例中 ",(0,c.jsx)(n.code,{children:".element"})," 在悬浮状态（",(0,c.jsx)(n.code,{children:":hover"}),"）设置了 ",(0,c.jsx)(n.code,{children:"--color"})," 自定属性的值为 ",(0,c.jsx)(n.code,{children:"initial"})," ，它是一个无效值，所以你看到悬浮状态会引用其备用值 ",(0,c.jsx)(n.code,{children:"orange"})," 。我想，通过这个示例，你对 CSS 自定义属性中的无效值有更深的了解了吧。如果没有理解的话，可以记住这两点："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["在同一作用域中，如果自定义属性的值是 ",(0,c.jsx)(n.code,{children:"initial"}),"，表示该自定义属性是一个保证无效值，那么它将会采用",(0,c.jsx)(n.code,{children:"var()"})," 回退值，如果 ",(0,c.jsx)(n.code,{children:"var()"})," 未设置回退值，那么会根据属性的 ",(0,c.jsx)(n.code,{children:"unset"})," 来设置值。"]}),"\n",(0,c.jsxs)(n.li,{children:["如果不在同一作用域中，当自定义属性值是保证无效值时，会类似 JavaScript 事件冒泡机制，向上寻找同名称的自定义属性，如果未找到，则会采用 ",(0,c.jsx)(n.code,{children:"var()"})," 的回退值，要是未设置回退值，将会根据属性的 ",(0,c.jsx)(n.code,{children:"unset"})," 取值；如果向上找到同名称的自定义属性，将会采用父（祖先）同名的自定义属性的值。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["我们回过头来看 ",(0,c.jsx)(n.a,{href:"https://lea.verou.me/2020/10/the-var-space-hack-to-toggle-multiple-values-with-one-custom-property/",target:"_blank",rel:"noopener noreferrer",children:"@Lea Verou 提供的示例"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/wvQdoJL",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/wvQdoJL"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"关键代码："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"button { \n \xa0 \xa0--is-raised: ; /* off by default */ \n \xa0 \xa0border: 1px solid var(--is-raised, rgb(0 0 0 / 0.1)); \n \xa0 \xa0background: var( --is-raised, linear-gradient(hsl(0 0% 100% / 0.3), transparent) ) hsl(200 100% 50%); \n \xa0 \xa0box-shadow: var( --is-raised, 0 1px hsl(0 0% 100% / 0.8) inset, 0 0.1em 0.1em -0.1em rgb(0 0 0 / 0.2) ); \n \xa0 \xa0text-shadow: var(--is-raised, 0 -1px 1px rgb(0 0 0 / 0.3)); \n} \n​\nbutton:hover { \n \xa0 \xa0--is-raised: initial; / turn on */ \n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["根据前面介绍的，当 ",(0,c.jsx)(n.code,{children:"--is-raised"})," 的值是个空字符串（",(0,c.jsx)(n.code,{children:" "})," ）时，",(0,c.jsx)(n.code,{children:"--is-raised"})," 是个有效值，那么："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"border"})," 的值是 ",(0,c.jsx)(n.code,{children:"1px solid ;"}),"（",(0,c.jsx)(n.code,{children:"solid"})," 后面有一个空格符），",(0,c.jsx)(n.code,{children:"border-color"})," 的值为 ",(0,c.jsx)(n.code,{children:"currentColor"}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"background"})," 的就是 ",(0,c.jsx)(n.code,{children:"hsl(200 100% 50%);"}),"（",(0,c.jsx)(n.code,{children:"hsl"})," 前面有一个空格符）；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"box-shadow"})," 和 ",(0,c.jsx)(n.code,{children:"text-shadow"})," 的值是 ``（空格符），最终的值将是它们的初始值 ",(0,c.jsx)(n.code,{children:"none"})," 。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"button"})," 在悬浮状态（ ",(0,c.jsx)(n.code,{children:":hover"})," ）时 ",(0,c.jsx)(n.code,{children:"--is-raised"})," 的值是 ",(0,c.jsx)(n.code,{children:"initial"})," ，这个时候 ",(0,c.jsx)(n.code,{children:"--is-raised"})," 是一个保证无效值，对应的："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"border"})," 的值是 ",(0,c.jsx)(n.code,{children:"1px solid rgb(0 0 0 / 0.1);"})," ，即 ",(0,c.jsx)(n.code,{children:"--is-raised"})," 取了 ",(0,c.jsx)(n.code,{children:"var()"})," 函数的回退值",(0,c.jsx)(n.code,{children:"rgb(0 0 0 / 0.1)"})," ；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"background"})," 的值是 ",(0,c.jsx)(n.code,{children:"linear-gradient(hsl(0 0% 100% / 0.3), transparent) hsl(200 100% 50%)"}),"，即 ",(0,c.jsx)(n.code,{children:"--is-raised"})," 取了 ",(0,c.jsx)(n.code,{children:"var()"})," 函数的回退值 ",(0,c.jsx)(n.code,{children:"linear-gradient(hsl(0 0% 100% / 0.3), transparent)"}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"box-shadow"})," 的值是 ",(0,c.jsx)(n.code,{children:"0 1px hsl(0 0% 100% / 0.8) inset, 0 0.1em 0.1em -0.1em rgb(0 0 0 / 0.2)"}),"，即 ",(0,c.jsx)(n.code,{children:"--is-raised"})," 取了 ",(0,c.jsx)(n.code,{children:"var()"})," 函数的回退值 ",(0,c.jsx)(n.code,{children:"0 1px hsl(0 0% 100% / 0.8) inset, 0 0.1em 0.1em -0.1em rgb(0 0 0 / 0.2)"}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"text-shadow"})," 的值是 ",(0,c.jsx)(n.code,{children:"0 -1px 1px rgb(0 0 0 / 0.3)"}),"，即 ",(0,c.jsx)(n.code,{children:"--is-raised"})," 取了 ",(0,c.jsx)(n.code,{children:"var()"})," 函数的回退值 ",(0,c.jsx)(n.code,{children:"0 -1px 1px rgb(0 0 0 / 0.3)"}),"。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["实现了两种 UI 效果，在同一个属性上对两个值做了切换。虽然效果出来了，但 ",(0,c.jsx)(n.code,{children:"--is-raised: ;"})," 和 ",(0,c.jsx)(n.code,{children:"--is-raised: initial;"})," 不易于阅读和理解。而且 ",(0,c.jsx)(n.code,{children:"--is-raised"})," 的值是从`` （空格符）到 ",(0,c.jsx)(n.code,{children:"initial"})," 切换的状态（即开（",(0,c.jsx)(n.code,{children:"ON"}),")和关（",(0,c.jsx)(n.code,{children:"OFF"}),"））切换，这样的话，可以将上面的 Demo 改成下面这样："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--ON: initial; \n \xa0 \xa0--OFF: ; \n} \n​\nbutton { \n \xa0 \xa0--is-raised: var(--OFF); \n \xa0 \xa0border: 1px solid var(--is-raised, rgb(0 0 0 / 0.1)); \n \xa0 \xa0background: var( --is-raised, linear-gradient(hsl(0 0% 100% / 0.3), transparent) ) hsl(200 100% 50%); \n \xa0 \xa0box-shadow: var( --is-raised, 0 1px hsl(0 0% 100% / 0.8) inset, 0 0.1em 0.1em -0.1em rgb(0 0 0 / 0.2) ); \n \xa0 \xa0text-shadow: var(--is-raised, 0 -1px 1px rgb(0 0 0 / 0.3)); } button:hover { --is-raised: var(--ON); \n} \n​\nbutton:active { \n \xa0 \xa0box-shadow: var(--is-raised, 0 1px 0.2em black inset); \n} \n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/rNQmWmj",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/rNQmWmj"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["使用这个功能特性，你可以在 CSS 中",(0,c.jsx)(n.strong,{children:"只使用一个 CSS 声明做两种状态的切换，从而实现不同的效果，比如在宽屏幕上，奇数和偶数项不同的效果"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 集合：",(0,c.jsx)(n.a,{href:"https://codepen.io/collection/DjmdjQ/",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/collection/DjmdjQ/"}),"（By ",(0,c.jsx)(n.a,{href:"https://codepen.io/thebabydino",target:"_blank",rel:"noopener noreferrer",children:"@Ana tudor"}),"）"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["或者",(0,c.jsx)(n.strong,{children:"收缩和扩展的动画效果"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/rNQmWYm",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/rNQmWYm"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["额外再提一点，CSS 自定义属性除了可以使 CSS 具备 ",(0,c.jsx)(n.code,{children:"if ... else ..."})," 能力之外，还可以使 CSS 具备其他的一些逻辑运算能力，比如与（",(0,c.jsx)(n.code,{children:"and"}),"）、或（",(0,c.jsx)(n.code,{children:"or"}),"）、非（",(0,c.jsx)(n.code,{children:"not"}),"）以及一些三角函数的能力，比如 ",(0,c.jsx)(n.code,{children:"abs()"}),"、",(0,c.jsx)(n.code,{children:"sign()"}),"、",(0,c.jsx)(n.code,{children:"round()"})," 和 ",(0,c.jsx)(n.code,{children:"mod()"})," 等。我们可以使用这些特性，构建一些超炫特酷的效果："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:"img"})}),"\n",(0,c.jsx)(n.p,{children:"这些知识已然超出本节课的范畴，如果你感兴趣的话，可以花一些时间阅读下面这些相关的教程："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://css-tricks.com/logical-operations-with-css-variables/",target:"_blank",rel:"noopener noreferrer",children:"Logical Operations with CSS Variables"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://css-tricks.com/using-absolute-value-sign-rounding-and-modulo-in-css-today/",target:"_blank",rel:"noopener noreferrer",children:"Using Absolute Value, Sign, Rounding and Modulo in CSS Today"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7199571709102391328/section/7217644982898720779",target:"_blank",rel:"noopener noreferrer",children:"条件 CSS 之 CSS 属性/值和 CSS 函数"})}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"css-自定义属性有助于行为和样式的真正分离",children:["CSS 自定义属性有助于行为和样式的真正分离",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性有助于行为和样式的真正分离",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["CSS 和 JavaScript 同为 Web 的基石，其中 CSS 用来设计样式，JavaScript 来实现 Web 的交互行为。而 CSS 自定义属性的到来，更有助于行为和样式的真正分离。为了更易于大家理解，我们通过一个简单的示例来阐述，比如我们有一个径向渐变（",(0,c.jsx)(n.code,{children:"radial-gradient"}),"）或圆锥渐变（",(0,c.jsx)(n.code,{children:"conic-gradient"}),"），让渐变的中心点能跟着鼠标移动。在过去，我们需要在 JavaScript 中创建整个渐变，并在每次鼠标移动时创建渐变。而有了 CSS 自定义属性，JavaScript 只需要设置两个 CSS 自定义属性 ",(0,c.jsx)(n.code,{children:"--mouse-x"})," 和 ",(0,c.jsx)(n.code,{children:"--mouse-y"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:":root { \n \xa0 \xa0--colors: red, yellow, lime, aqua, blue, magenta, red; \n \xa0 \xa0--mouse-x: 50%; \n \xa0 \xa0--mouse-y: 50%; \n} \n​\nbody { \n \xa0 \xa0width: 100vw; \n \xa0 \xa0height: 100vh; \n \xa0 \xa0background-image: conic-gradient( at var(--mouse-x) var(--mouse-y), var(--colors) ); \n} \xa0\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:"const root = document.documentElement; \n​\ndocument.addEventListener('mousemove', evt => { \n \xa0 \xa0let x = evt.clientX / innerWidth * 100 \n \xa0 \xa0let y = evt.clientY / innerHeight * 100 \n \xa0 \xa0\n \xa0 \xa0root.style.setProperty('--mouse-x', `${x}%`) \n \xa0 \xa0root.style.setProperty('--mouse-y', `${y}%`) \n})\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:"img"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/WNYjozv",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/WNYjozv"})]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"与-important-结合使用",children:["与 !important 结合使用",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#与-important-结合使用",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["你可以在变量之内或之外使用 ",(0,c.jsx)(n.code,{children:"!important"})," 修饰符。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:".override-red {\n \xa0 \xa0/* 这个有效 */\n \xa0 \xa0--color: red !important;\n \xa0 \xa0\n \xa0 \xa0color: var(--color);\n \xa0 \xa0\n \xa0 \xa0/* 这也有效 */\n \xa0 \xa0--border-color: red;\n \xa0 \xa0\n \xa0 \xa0border: 1px solid var(--border-color) !important;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["将 ",(0,c.jsx)(n.code,{children:"!important"})," 应用于 ",(0,c.jsx)(n.code,{children:"--color"})," 自定义属性会使得难以覆盖 ",(0,c.jsx)(n.code,{children:"--color"})," 自定义属性的值，但我们仍然可以通过更改 ",(0,c.jsx)(n.code,{children:"color"})," 属性来忽略它。"]}),"\n",(0,c.jsxs)(n.p,{children:["在自定义属性值中使用 ",(0,c.jsx)(n.code,{children:"!important"})," 的行为相当不寻常。",(0,c.jsx)(n.a,{href:"https://www.stefanjudis.com/today-i-learned/the-surprising-behavior-of-important-css-custom-properties/",target:"_blank",rel:"noopener noreferrer",children:"@Stefan Judis 进行了很好的文档记录"}),"，但主要思想是："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["最终，将从自定义属性的值中去除 ",(0,c.jsx)(n.code,{children:"!important"}),"。"]}),"\n",(0,c.jsx)(n.li,{children:"但是在确定哪个值在多个位置设置时获胜时会使用它。"}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:"div {\n \xa0 \xa0--color: red !important;\n}\n​\n#id {\n \xa0 \xa0--color: yellow;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果这两个选择器都应用于一个元素，你可能会认为由于更高的权重，",(0,c.jsx)(n.code,{children:"#id"})," 的值将获胜，但实际上红色会获胜，因为有 ",(0,c.jsx)(n.code,{children:"!important"}),"，但最终应用时不包含 ",(0,c.jsx)(n.code,{children:"!important"}),"。这有点难以理解。"]}),"\n",(0,c.jsxs)(n.p,{children:["如果将 ",(0,c.jsx)(n.code,{children:"!important"})," 应用于自定义属性之外，例如上面第二个示例中的代码块，我们的 ",(0,c.jsx)(n.code,{children:"--border-color"})," 自定义属性保持低权重（容易被覆盖），但难以改变该值如何应用于边框本身，因为整个声明保留了 ",(0,c.jsx)(n.code,{children:"!important"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"浏览器开发者工具中更好的使用-css-自定义属性",children:["浏览器开发者工具中更好的使用 CSS 自定义属性",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器开发者工具中更好的使用-css-自定义属性",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在未来我们可以使用浏览器开发者的一些技巧，让我们更容易地使用 CSS 自定义属性。"}),"\n",(0,c.jsxs)(n.h3,{id:"查看颜色值",children:["查看颜色值",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#查看颜色值",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"当你使用 CSS 自定义属性时，看到颜色和背景颜色值的可视化指示器是不是很有用，比如："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"计算值",children:["计算值",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#计算值",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在一些浏览器开发者工具中，开发者将鼠标悬浮或点击 CSS 自定义属性时，可以查看 CSS 自定义属性计算值："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"css-自定义属性自动完成",children:["CSS 自定义属性自动完成",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-自定义属性自动完成",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在开发项目时，可能会在项目中同时注册很多个 CSS 自定义属性，开发者一时可能很难记住这些已注册的 CSS 自定义属性，这样会阻碍开发者在 ",(0,c.jsx)(n.code,{children:"var()"})," 中引用已注册的 CSS 自定义属性，甚至还有可能会引用未定义或无效的 CSS 自定义属性。 我们同样可以借助浏览器开发者调试器，浏览器在输入 ",(0,c.jsx)(n.code,{children:"--"})," 符号时，会自动弹出 CSS 自定义属性列表，开发者可以快速定位到自己需要使用的 CSS 自定义属性："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:"img"})}),"\n",(0,c.jsxs)(n.h3,{id:"禁用-css-自定义属性",children:["禁用 CSS 自定义属性",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#禁用-css-自定义属性",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"当你需要禁用某个 CSS 自定义属性时，可以通过取消选中它所定义的元素来实现："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:"img"})}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["CSS 自定义属性是 CSS 的一个强大特性，用于创建可重用的样式规则。它们允许我们定义自己的属性，并在整个样式表中使用它们。我们可以通过声明变量，使用 ",(0,c.jsx)(n.code,{children:"var()"})," 函数来引用这些变量。"]}),"\n",(0,c.jsx)(n.p,{children:"通过使用自定义属性，我们可以轻松地调整样式的值，从而实现可维护性和灵活性。我们可以为颜色、尺寸、间距等常见的值定义自定义属性，并在元素中使用它们。"}),"\n",(0,c.jsxs)(n.p,{children:["自定义属性可以与其他 CSS 功能相结合，例如伪类、媒体查询和 ",(0,c.jsx)(n.code,{children:"transform"}),"，从而极大地增强了其灵活性和功能。"]}),"\n",(0,c.jsxs)(n.p,{children:["使用 ",(0,c.jsx)(n.code,{children:"calc()"})," 函数，我们可以在自定义属性中进行数学计算，为样式提供更多动态性和复杂性。"]}),"\n",(0,c.jsxs)(n.p,{children:["另一个强大的特性是我们可以在自定义属性中使用 ",(0,c.jsx)(n.code,{children:"!important"})," 来调整样式的特异性。例如，在自定义属性中应用 ",(0,c.jsx)(n.code,{children:"!important"}),"，可以保护样式不被覆盖。"]}),"\n",(0,c.jsxs)(n.p,{children:["通过延迟使用 ",(0,c.jsx)(n.code,{children:"calc()"})," 函数或使用 ",(0,c.jsx)(n.code,{children:"!important"})," 修饰符，我们可以提高代码的可读性，并使其更易于维护。"]}),"\n",(0,c.jsx)(n.p,{children:"综上所述，CSS 自定义属性为我们提供了更加灵活和可维护的样式规则，使我们能够轻松地调整样式的值以及实现动态和复杂的样式效果。这是一个强大的工具，值得在 CSS 开发中广泛应用。"})]})}function z(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(F,{...e})}):F(e)}let P=z;z.__RSPRESS_PAGE_META={},z.__RSPRESS_PAGE_META["%E7%8E%B0%E4%BB%A3CSS%2F%E7%AC%AC24%E7%AB%A0%E2%80%94CSS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91.md"]={toc:[{text:"CSS 自定义属性的发展进程",id:"css-自定义属性的发展进程",depth:2},{text:"CSS 自定义属性的基础",id:"css-自定义属性的基础",depth:2},{text:"CSS 自定义属性简介",id:"css-自定义属性简介",depth:3},{text:"为什么要使用 CSS 自定义属性？",id:"为什么要使用-css-自定义属性",depth:3},{text:"CSS 自定义属性 vs. CSS 处理器的变量",id:"css-自定义属性-vs-css-处理器的变量",depth:2},{text:"语法上的差异",id:"语法上的差异",depth:3},{text:"动态 vs. 静态",id:"动态-vs-静态",depth:3},{text:"级联和继承",id:"级联和继承",depth:3},{text:"全局 vs. 局部",id:"全局-vs-局部",depth:3},{text:"CSS 自定义属性和 CSS 处理器可以混合使用",id:"css-自定义属性和-css-处理器可以混合使用",depth:3},{text:"CSS 自定义属性的特性",id:"css-自定义属性的特性",depth:2},{text:"当一个 var() 函数使用一个未定义的变量时，会发生什么？",id:"当一个-var-函数使用一个未定义的变量时会发生什么",depth:3},{text:"var() 函数可以提供回退值",id:"var-函数可以提供回退值",depth:3},{text:"自定义属性的作用域",id:"自定义属性的作用域",depth:3},{text:"循环依赖的 CSS 自定义属性是无效的",id:"循环依赖的-css-自定义属性是无效的",depth:3},{text:"有效的自定义属性值",id:"有效的自定义属性值",depth:3},{text:"CSS 自定义属性的基本运算和延迟计算",id:"css-自定义属性的基本运算和延迟计算",depth:3},{text:"CSS 自定义属性的逻辑运算",id:"css-自定义属性的逻辑运算",depth:3},{text:"有效使用 CSS 自定义属性的无效变量",id:"有效使用-css-自定义属性的无效变量",depth:3},{text:"CSS 自定义属性有助于行为和样式的真正分离",id:"css-自定义属性有助于行为和样式的真正分离",depth:3},{text:"与 !important 结合使用",id:"与-important-结合使用",depth:3},{text:"浏览器开发者工具中更好的使用 CSS 自定义属性",id:"浏览器开发者工具中更好的使用-css-自定义属性",depth:2},{text:"查看颜色值",id:"查看颜色值",depth:3},{text:"计算值",id:"计算值",depth:3},{text:"CSS 自定义属性自动完成",id:"css-自定义属性自动完成",depth:3},{text:"禁用 CSS 自定义属性",id:"禁用-css-自定义属性",depth:3},{text:"小结",id:"小结",depth:2}],title:"第24章—CSS自定义属性你知道多少",headingTitle:"第24章—CSS自定义属性你知道多少",frontmatter:{}}}}]);