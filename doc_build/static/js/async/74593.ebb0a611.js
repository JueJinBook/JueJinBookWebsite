"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["74593"],{765728:function(c,e,d){d.r(e),d.d(e,{default:()=>A});var n=d(552676),r=d(740453);let s=d.p+"static/image/4.13.232f0cab.png",i=d.p+"static/image/4.12.46798638.png",h=d.p+"static/image/4.11.844fd7e3.png",l=d.p+"static/image/4.10.e0b414f2.png",x=d.p+"static/image/4.9.66d026f9.png",j=d.p+"static/image/4.8.17a83612.png",o=d.p+"static/image/4.7.82aea91b.png",a=d.p+"static/image/4.6.ad11577e.png",t=d.p+"static/image/4.5.3e414fa7.png",m=d.p+"static/image/4.4.2696eaf9.png",b=d.p+"static/image/4.3.0d6252ff.png",p=d.p+"static/image/4.2.fa7a85dc.png",g=d.p+"static/image/4.1.2297e6ed.png";function E(c){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",strong:"strong",img:"img",ol:"ol",li:"li",h3:"h3"},(0,r.ah)(),c.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.h1,{id:"4-进阶-1headmaster-与-branch",children:["4 进阶 1：HEAD、master 与 branch",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-进阶-1headmaster-与-branch",children:"#"})]}),"\n",(0,n.jsx)(e.p,{children:"这一节主要是几个概念的解释：HEAD、master 以及 Git 中非常重要的一个概念： branch。"}),"\n",(0,n.jsxs)(e.h2,{id:"引用commit-的快捷方式",children:["引用：commit 的快捷方式",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#引用commit-的快捷方式",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["首先，再看一次 ",(0,n.jsx)(e.code,{children:"log"}),"："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"git log\n"})}),"\n",(0,n.jsxs)(e.p,{children:["第一行的 ",(0,n.jsx)(e.code,{children:"commit"})," 后面括号里的 ",(0,n.jsx)(e.code,{children:"HEAD -> master, origin/master, origin/HEAD"})," ，是几个指向这个 ",(0,n.jsx)(e.code,{children:"commit"})," 的引用。在 Git 的使用中，经常会需要对指定的 ",(0,n.jsx)(e.code,{children:"commit"})," 进行操作。每一个 ",(0,n.jsx)(e.code,{children:"commit"})," 都有一个它唯一的指定方式——它的 SHA-1 校验和，也就是上图中每个黄色的 ",(0,n.jsx)(e.code,{children:"commit"})," 右边的那一长串字符。两个 SHA-1 值的重复概率极低，所以你可以使用这个 SHA-1 值来指代 ",(0,n.jsx)(e.code,{children:"commit"}),"，也可以只使用它的前几位来指代它（例如第一个 ",(0,n.jsx)(e.code,{children:"78bb0ab7d541…16b77"}),"，你使用 ",(0,n.jsx)(e.code,{children:"78bb0ab"})," 甚至 ",(0,n.jsx)(e.code,{children:"78bb"})," 来指代它通常也可以），但毕竟这种没有任何含义的字符串是很难记忆的，所以 Git 提供了「引用」的机制：使用固定的字符串作为引用，指向某个 ",(0,n.jsx)(e.code,{children:"commit"}),"，作为操作 ",(0,n.jsx)(e.code,{children:"commit"})," 时的快捷方式。"]}),"\n",(0,n.jsxs)(e.h2,{id:"head当前-commit-的引用",children:["HEAD：当前 commit 的引用",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#head当前-commit-的引用",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["上一段里说到，图中括号里是指向这个 ",(0,n.jsx)(e.code,{children:"commit"})," 的引用。其中这个括号里的 ",(0,n.jsx)(e.code,{children:"HEAD"})," 是引用中最特殊的一个：它是",(0,n.jsxs)(e.strong,{children:["指向当前 ",(0,n.jsx)(e.code,{children:"commit"})," 的引用"]}),"。所谓**当前 ",(0,n.jsx)(e.code,{children:"commit"}),"**这个概念很简单，它指的就是当前工作目录所对应的 ",(0,n.jsx)(e.code,{children:"commit"}),"。"]}),"\n",(0,n.jsxs)(e.p,{children:["例如上图中的当前 ",(0,n.jsx)(e.code,{children:"commit"})," 就是第一行中的那个最新的 ",(0,n.jsx)(e.code,{children:"commit"}),"。每次当有新的 ",(0,n.jsx)(e.code,{children:"commit"})," 的时候，工作目录自动与最新的 ",(0,n.jsx)(e.code,{children:"commit"})," 对应；而与此同时，",(0,n.jsx)(e.code,{children:"HEAD"})," 也会转而指向最新的 ",(0,n.jsx)(e.code,{children:"commit"}),"。事实上，当使用 ",(0,n.jsx)(e.code,{children:"checkout"}),"、",(0,n.jsx)(e.code,{children:"reset"})," 等指令手动指定改变当前 ",(0,n.jsx)(e.code,{children:"commit"})," 的时候，",(0,n.jsx)(e.code,{children:"HEAD"})," 也会一起跟过去。"]}),"\n",(0,n.jsxs)(e.p,{children:["总之，当前 ",(0,n.jsx)(e.code,{children:"commit"})," 在哪里，",(0,n.jsx)(e.code,{children:"HEAD"})," 就在哪里，这是一个永远自动指向当前 ",(0,n.jsx)(e.code,{children:"commit"})," 的引用，所以你永远可以用 ",(0,n.jsx)(e.code,{children:"HEAD"})," 来操作当前 ",(0,n.jsx)(e.code,{children:"commit"}),"。"]}),"\n",(0,n.jsxs)(e.h2,{id:"branch",children:["branch",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#branch",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:"HEAD"})," 是 Git 中一个独特的引用，它是唯一的。而除了 ",(0,n.jsx)(e.code,{children:"HEAD"})," 之外，Git 还有一种引用，叫做 ",(0,n.jsx)(e.code,{children:"branch"}),"（分支）。",(0,n.jsx)(e.code,{children:"HEAD"})," 除了可以指向 ",(0,n.jsx)(e.code,{children:"commit"}),"，还可以指向一个 ",(0,n.jsx)(e.code,{children:"branch"}),"，当它指向某个 ",(0,n.jsx)(e.code,{children:"branch"})," 的时候，会通过这个 ",(0,n.jsx)(e.code,{children:"branch"})," 来间接地指向某个 ",(0,n.jsx)(e.code,{children:"commit"}),"；另外，当 ",(0,n.jsx)(e.code,{children:"HEAD"})," 在提交时自动向前移动的时候，它会像一个拖钩一样带着它所指向的 ",(0,n.jsx)(e.code,{children:"branch"})," 一起移动。"]}),"\n",(0,n.jsxs)(e.p,{children:["例如上面的那张图里，",(0,n.jsx)(e.code,{children:"HEAD -> master"})," 中的 ",(0,n.jsx)(e.code,{children:"master"})," 就是一个 ",(0,n.jsx)(e.code,{children:"branch"})," 的名字，而它左边的箭头 ",(0,n.jsx)(e.code,{children:"->"})," 表示 ",(0,n.jsx)(e.code,{children:"HEAD"})," 正指向它（当然，也会间接地指向它所指向的 ",(0,n.jsx)(e.code,{children:"commit"}),"）。\n",(0,n.jsx)("img",{src:g,alt:""})]}),"\n",(0,n.jsxs)(e.p,{children:["如果我在这时创建一个 ",(0,n.jsx)(e.code,{children:"commit"}),"，那么 ",(0,n.jsx)(e.code,{children:"HEAD"})," 会带着 ",(0,n.jsx)(e.code,{children:"master"})," 一起移动到最新的 ",(0,n.jsx)(e.code,{children:"commit"}),"："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"git commit\n"})}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:p,alt:""})}),"\n",(0,n.jsxs)(e.p,{children:["通过查看 ",(0,n.jsx)(e.code,{children:"log"}),"，可以对这个逻辑进行验证："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"git log\n"})}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:b,alt:""})}),"\n",(0,n.jsxs)(e.p,{children:["从图中可以看出，最新的 ",(0,n.jsx)(e.code,{children:"commit"}),' （提交信息："Add feature1"）被创建后，',(0,n.jsx)(e.code,{children:"HEAD"})," 和 ",(0,n.jsx)(e.code,{children:"master"})," 这两个引用都指向了它，而在上面第一张图中的后两个引用 ",(0,n.jsx)(e.code,{children:"origin/master"})," 和 ",(0,n.jsx)(e.code,{children:"origin/HEAD"})," 则依然停留在原先的位置。"]}),"\n",(0,n.jsxs)(e.h2,{id:"master-默认-branch",children:["master: 默认 branch",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#master-默认-branch",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["上面的这个 ",(0,n.jsx)(e.code,{children:"master"})," ，其实是一个特殊的 ",(0,n.jsx)(e.code,{children:"branch"}),"：它是 Git 的默认 ",(0,n.jsx)(e.code,{children:"branch"}),"（俗称主 ",(0,n.jsx)(e.code,{children:"branch"})," / 主分支）。"]}),"\n",(0,n.jsx)(e.p,{children:"所谓的「默认 branch」，主要有两个特点："}),"\n",(0,n.jsxs)(e.ol,{children:["\n",(0,n.jsxs)(e.li,{children:["\n",(0,n.jsxs)(e.p,{children:["新创建的 repository（仓库）是没有任何 ",(0,n.jsx)(e.code,{children:"commit"})," 的。但在它创建第一个 ",(0,n.jsx)(e.code,{children:"commit"})," 时，会把 ",(0,n.jsx)(e.code,{children:"master"})," 指向它，并把 ",(0,n.jsx)(e.code,{children:"HEAD"})," 指向 ",(0,n.jsx)(e.code,{children:"master"}),"。"]}),"\n"]}),"\n",(0,n.jsxs)(e.li,{children:["\n",(0,n.jsxs)(e.p,{children:["当有人使用 ",(0,n.jsx)(e.code,{children:"git clone"})," 时，除了从远程仓库把 ",(0,n.jsx)(e.code,{children:".git"})," 这个仓库目录下载到工作目录中，还会 ",(0,n.jsx)(e.code,{children:"checkout"})," （签出） ",(0,n.jsx)(e.code,{children:"master"}),"（",(0,n.jsx)(e.code,{children:"checkout"})," 的意思就是把某个 ",(0,n.jsx)(e.code,{children:"commit"})," 作为当前 ",(0,n.jsx)(e.code,{children:"commit"}),"，把 ",(0,n.jsx)(e.code,{children:"HEAD"})," 移动过去，并把工作目录的文件内容替换成这个 ",(0,n.jsx)(e.code,{children:"commit"})," 所对应的内容）。"]}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:m,alt:""})}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(e.p,{children:["另外，需要说一下的是，大多数的开发团队会规定开发以 ",(0,n.jsx)(e.code,{children:"master"})," 为核心，所有的分支都在一定程度上围绕着 ",(0,n.jsx)(e.code,{children:"master"})," 来开发。这个在事实上构成了 ",(0,n.jsx)(e.code,{children:"master"})," 和其它分支在地位上的一个额外的区别。"]}),"\n",(0,n.jsxs)(e.h2,{id:"branch-的通俗化理解",children:["branch 的通俗化理解",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#branch-的通俗化理解",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["尽管在 Git 中，",(0,n.jsx)(e.code,{children:"branch"})," 只是一个指向 ",(0,n.jsx)(e.code,{children:"commit"})," 的引用，但它有一个更通俗的理解：你还可以把一个 ",(0,n.jsx)(e.code,{children:"branch"})," 理解为从初始 ",(0,n.jsx)(e.code,{children:"commit"})," 到 ",(0,n.jsx)(e.code,{children:"branch"})," 所指向的 ",(0,n.jsx)(e.code,{children:"commit"})," 之间的所有 ",(0,n.jsx)(e.code,{children:"commit"}),"s 的一个「串」。例如下面这张图："]}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:t,alt:""})}),"\n",(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:"master"})," 的本质是一个指向 ",(0,n.jsx)(e.code,{children:"3"})," 的引用，但你也可以把 ",(0,n.jsx)(e.code,{children:"master"})," 理解为是 ",(0,n.jsx)(e.code,{children:"1"})," ",(0,n.jsx)(e.code,{children:"2"})," ",(0,n.jsx)(e.code,{children:"3"})," 三个 ",(0,n.jsx)(e.code,{children:"commit"})," 的「串」，它的起点是 ",(0,n.jsx)(e.code,{children:"1"}),"，终点是 ",(0,n.jsx)(e.code,{children:"3"}),"。"]}),"\n",(0,n.jsxs)(e.p,{children:["这种理解方式比较符合 ",(0,n.jsx)(e.code,{children:"branch"})," 这个名字的本意（branch 的本意是树枝，可以延伸为事物的分支），也是大多数人对 ",(0,n.jsx)(e.code,{children:"branch"})," 的理解。不过如果你选择这样理解 ",(0,n.jsx)(e.code,{children:"branch"}),"，需要注意下面两点："]}),"\n",(0,n.jsxs)(e.ol,{children:["\n",(0,n.jsxs)(e.li,{children:["\n",(0,n.jsxs)(e.p,{children:["所有的 ",(0,n.jsx)(e.code,{children:"branch"})," 之间都是平等的。"]}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:a,alt:""})}),"\n",(0,n.jsxs)(e.p,{children:["例如上面这张图，",(0,n.jsx)(e.code,{children:"branch1"})," 是 ",(0,n.jsx)(e.code,{children:"1"})," ",(0,n.jsx)(e.code,{children:"2"})," ",(0,n.jsx)(e.code,{children:"5"})," ",(0,n.jsx)(e.code,{children:"6"})," 的串，而不要理解为 ",(0,n.jsx)(e.code,{children:"2"})," ",(0,n.jsx)(e.code,{children:"5"})," ",(0,n.jsx)(e.code,{children:"6"})," 或者 ",(0,n.jsx)(e.code,{children:"5"})," ",(0,n.jsx)(e.code,{children:"6"})," 。其实，起点在哪里并不是最重要的，重要的是你要知道，所有 ",(0,n.jsx)(e.code,{children:"branch"})," 之间是平等的，",(0,n.jsx)(e.code,{children:"master"})," 除了上面我说的那几点之外，并不比其他 ",(0,n.jsx)(e.code,{children:"branch"})," 高级。这个认知的理解对于 ",(0,n.jsx)(e.code,{children:"branch"})," 的正确使用非常重要。"]}),"\n",(0,n.jsx)(e.p,{children:"换个角度来说，上面这张图我可以用别的画法来表达，它们的意思是一样的："}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:o,alt:""})}),"\n",(0,n.jsx)(e.p,{children:"通过这张动图应该能够对「平等」这个概念更好地理解了吧？"}),"\n"]}),"\n",(0,n.jsxs)(e.li,{children:["\n",(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:"branch"})," 包含了从初始 ",(0,n.jsx)(e.code,{children:"commit"})," 到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。"]}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:j,alt:""})}),"\n",(0,n.jsxs)(e.p,{children:["像上图这样，",(0,n.jsx)(e.code,{children:"master"})," 在合并了 ",(0,n.jsx)(e.code,{children:"branch1"})," 之后，从初始 ",(0,n.jsx)(e.code,{children:"commit"})," 到 ",(0,n.jsx)(e.code,{children:"master"})," 有了两条路径。这时，",(0,n.jsx)(e.code,{children:"master"})," 的串就包含了 ",(0,n.jsx)(e.code,{children:"1"})," ",(0,n.jsx)(e.code,{children:"2"})," ",(0,n.jsx)(e.code,{children:"3"})," ",(0,n.jsx)(e.code,{children:"4"})," ",(0,n.jsx)(e.code,{children:"7"})," 和 ",(0,n.jsx)(e.code,{children:"1"})," ",(0,n.jsx)(e.code,{children:"2"})," ",(0,n.jsx)(e.code,{children:"5"})," ",(0,n.jsx)(e.code,{children:"6"})," ",(0,n.jsx)(e.code,{children:"7"})," 这两条路径。而且，这两条路径是平等的，",(0,n.jsx)(e.code,{children:"1"})," ",(0,n.jsx)(e.code,{children:"2"})," ",(0,n.jsx)(e.code,{children:"3"})," ",(0,n.jsx)(e.code,{children:"4"})," ",(0,n.jsx)(e.code,{children:"7"})," 这条路径并不会因为它是「原生路径」而拥有任何的特别之处。"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(e.p,{children:["如果你喜欢用「树枝」的概念来理解 Git 的 ",(0,n.jsx)(e.code,{children:"branch"}),"，一定要注意上面说的这两点，否则在今后使用 ",(0,n.jsx)(e.code,{children:"branch"})," 的时候就可能与出现理解偏差或者使用方式不当的问题。事实上我本人并不喜欢用这种方式来理解 ",(0,n.jsx)(e.code,{children:"branch"}),"，因为觉得它有点舍近求远的味道：我为了「直观」地思考，给它了一个形象的比喻，但由于它的本质含义其实更加简单，导致我的这种比喻反而增加了思考它时的复杂度，未免有点画蛇添足。不过这是我自己的感受，怎么理解 ",(0,n.jsx)(e.code,{children:"branch"})," 是个个人偏好的问题，这两种理解方式你选一个喜欢的就好。"]}),"\n",(0,n.jsxs)(e.h2,{id:"branch-的创建切换和删除",children:["branch 的创建、切换和删除",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#branch-的创建切换和删除",children:"#"})]}),"\n",(0,n.jsxs)(e.h3,{id:"创建-branch",children:["创建 branch",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#创建-branch",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["如果你想在某处创建 ",(0,n.jsx)(e.code,{children:"branch"})," ，只需要输入一行 ",(0,n.jsx)(e.code,{children:"git branch 名称"}),"。例如你现在在 ",(0,n.jsx)(e.code,{children:"master"})," 上："]}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:x,alt:""})}),"\n",(0,n.jsxs)(e.p,{children:["你想在这个 ",(0,n.jsx)(e.code,{children:"commit"}),' 处创建一个叫做 "feature1" 的 ',(0,n.jsx)(e.code,{children:"branch"}),"，只要输入："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"git branch feature1\n"})}),"\n",(0,n.jsxs)(e.p,{children:["你的 ",(0,n.jsx)(e.code,{children:"branch"})," 就创建好了：\n",(0,n.jsx)("img",{src:l,alt:""})]}),"\n",(0,n.jsxs)(e.h3,{id:"切换-branch",children:["切换 branch",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#切换-branch",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["不过新建的 ",(0,n.jsx)(e.code,{children:"branch"})," 并不会自动切换，你的 ",(0,n.jsx)(e.code,{children:"HEAD"})," 在这时依然是指向 ",(0,n.jsx)(e.code,{children:"master"})," 的。你需要用 ",(0,n.jsx)(e.code,{children:"checkout"})," 来主动切换到你的新 ",(0,n.jsx)(e.code,{children:"branch"})," 去："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"git checkout feature1\n"})}),"\n",(0,n.jsxs)(e.p,{children:["然后 ",(0,n.jsx)(e.code,{children:"HEAD"})," 就会指向新建的 ",(0,n.jsx)(e.code,{children:"branch"})," 了："]}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:h,alt:""})}),"\n",(0,n.jsxs)(e.p,{children:["除此之外，你还可以用 ",(0,n.jsx)(e.code,{children:"git checkout -b 名称"})," 来把上面两步操作合并执行。这行代码可以帮你用指定的名称创建 ",(0,n.jsx)(e.code,{children:"branch"})," 后，再直接切换过去。还以 ",(0,n.jsx)(e.code,{children:"feature1"})," 为例的话，就是："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"git checkout -b feature1\n"})}),"\n",(0,n.jsxs)(e.p,{children:["在切换到新的 ",(0,n.jsx)(e.code,{children:"branch"})," 后，再次 ",(0,n.jsx)(e.code,{children:"commit"})," 时 ",(0,n.jsx)(e.code,{children:"HEAD"})," 就会带着新的 ",(0,n.jsx)(e.code,{children:"branch"})," 移动了："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"...\ngit commit\n"})}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:i,alt:""})}),"\n",(0,n.jsxs)(e.p,{children:["而这个时候，如果你再切换到 ",(0,n.jsx)(e.code,{children:"master"})," 去 ",(0,n.jsx)(e.code,{children:"commit"}),"，就会真正地出现分叉了："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"git checkout master\n...\ngit commit\n"})}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)("img",{src:s,alt:""})}),"\n",(0,n.jsxs)(e.h3,{id:"删除-branch",children:["删除 branch",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#删除-branch",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["删除 ",(0,n.jsx)(e.code,{children:"branch"})," 的方法非常简单：",(0,n.jsx)(e.code,{children:"git branch -d 名称"}),"。例如要删除 ",(0,n.jsx)(e.code,{children:"feature1"})," 这个 branch："]}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-shell",children:"git branch -d feature1\n"})}),"\n",(0,n.jsx)(e.p,{children:"需要说明的有两点："}),"\n",(0,n.jsxs)(e.ol,{children:["\n",(0,n.jsxs)(e.li,{children:["\n",(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:"HEAD"})," 指向的 ",(0,n.jsx)(e.code,{children:"branch"})," 不能删除。如果要删除 ",(0,n.jsx)(e.code,{children:"HEAD"})," 指向的 ",(0,n.jsx)(e.code,{children:"branch"}),"，需要先用 ",(0,n.jsx)(e.code,{children:"checkout"})," 把 ",(0,n.jsx)(e.code,{children:"HEAD"})," 指向其他地方。"]}),"\n"]}),"\n",(0,n.jsxs)(e.li,{children:["\n",(0,n.jsxs)(e.p,{children:["由于 Git 中的 ",(0,n.jsx)(e.code,{children:"branch"})," 只是一个引用，所以删除 ",(0,n.jsx)(e.code,{children:"branch"})," 的操作也只会删掉这个引用，并不会删除任何的 ",(0,n.jsx)(e.code,{children:"commit"}),"。（不过如果一个 ",(0,n.jsx)(e.code,{children:"commit"})," 不在任何一个 ",(0,n.jsx)(e.code,{children:"branch"})," 的「路径」上，或者换句话说，如果没有任何一个 ",(0,n.jsx)(e.code,{children:"branch"})," 可以回溯到这条 ",(0,n.jsx)(e.code,{children:"commit"}),"（也许可以称为野生 ",(0,n.jsx)(e.code,{children:"commit"}),"？），那么在一定时间后，它会被 Git 的回收机制删除掉。）"]}),"\n"]}),"\n",(0,n.jsxs)(e.li,{children:["\n",(0,n.jsxs)(e.p,{children:["出于安全考虑，没有被合并到 ",(0,n.jsx)(e.code,{children:"master"})," 过的 ",(0,n.jsx)(e.code,{children:"branch"})," 在删除时会失败（因为怕你误删掉「未完成」的 ",(0,n.jsx)(e.code,{children:"branch"})," 啊）："]}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:"https://user-gold-cdn.xitu.io/2017/12/1/1600ff7520c3c1b5?w=550&h=61&f=jpeg&s=32646",alt:""})}),"\n",(0,n.jsxs)(e.p,{children:["这种情况如果你确认是要删除这个 ",(0,n.jsx)(e.code,{children:"branch"})," （例如某个未完成的功能被团队确认永久毙掉了，不再做了），可以把 ",(0,n.jsx)(e.code,{children:"-d"})," 改成 ",(0,n.jsx)(e.code,{children:"-D"}),"，小写换成大写，就能删除了。"]}),"\n",(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:"https://user-gold-cdn.xitu.io/2017/12/1/1600ff91f051d633?w=441&h=45&f=jpeg&s=21344",alt:""})}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(e.h2,{id:"引用的本质",children:["「引用」的本质",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#引用的本质",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["所谓「引用」（reference），其实就是一个个的字符串。这个字符串可以是一个 ",(0,n.jsx)(e.code,{children:"commit"})," 的 SHA-1 码（例：",(0,n.jsx)(e.code,{children:"c08de9a4d8771144cd23986f9f76c4ed729e69b0"}),"），也可以是一个 ",(0,n.jsx)(e.code,{children:"branch"}),"（例：",(0,n.jsx)(e.code,{children:"ref: refs/heads/feature3"}),"）。"]}),"\n",(0,n.jsxs)(e.p,{children:["Git 中的 ",(0,n.jsx)(e.code,{children:"HEAD"})," 和每一个 ",(0,n.jsx)(e.code,{children:"branch"})," 以及其他的引用，都是以文本文件的形式存储在本地仓库 ",(0,n.jsx)(e.code,{children:".git"})," 目录中，而 Git 在工作的时候，就是通过这些文本文件的内容来判断这些所谓的「引用」是指向谁的。"]}),"\n",(0,n.jsxs)(e.h2,{id:"小结",children:["小结",(0,n.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,n.jsxs)(e.p,{children:["这一节介绍了 Git 中的一些「引用」：",(0,n.jsx)(e.code,{children:"HEAD"}),"、",(0,n.jsx)(e.code,{children:"master"}),"、",(0,n.jsx)(e.code,{children:"branch"}),"。这里总结一下："]}),"\n",(0,n.jsxs)(e.ol,{children:["\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"HEAD"})," 是指向当前 ",(0,n.jsx)(e.code,{children:"commit"})," 的引用，它具有唯一性，每个仓库中只有一个 ",(0,n.jsx)(e.code,{children:"HEAD"}),"。在每次提交时它都会自动向前移动到最新的 ",(0,n.jsx)(e.code,{children:"commit"})," 。"]}),"\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"branch"})," 是一类引用。",(0,n.jsx)(e.code,{children:"HEAD"})," 除了直接指向 ",(0,n.jsx)(e.code,{children:"commit"}),"，也可以通过指向某个 ",(0,n.jsx)(e.code,{children:"branch"})," 来间接指向 ",(0,n.jsx)(e.code,{children:"commit"}),"。当 ",(0,n.jsx)(e.code,{children:"HEAD"})," 指向一个 ",(0,n.jsx)(e.code,{children:"branch"})," 时，",(0,n.jsx)(e.code,{children:"commit"})," 发生时，",(0,n.jsx)(e.code,{children:"HEAD"})," 会带着它所指向的 ",(0,n.jsx)(e.code,{children:"branch"})," 一起移动。"]}),"\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"master"})," 是 Git 中的默认 ",(0,n.jsx)(e.code,{children:"branch"}),"，它和其它 ",(0,n.jsx)(e.code,{children:"branch"})," 的区别在于：","\n",(0,n.jsxs)(e.ol,{children:["\n",(0,n.jsxs)(e.li,{children:["新建的仓库中的第一个 ",(0,n.jsx)(e.code,{children:"commit"})," 会被 ",(0,n.jsx)(e.code,{children:"master"})," 自动指向；"]}),"\n",(0,n.jsxs)(e.li,{children:["在 ",(0,n.jsx)(e.code,{children:"git clone"})," 时，会自动 ",(0,n.jsx)(e.code,{children:"checkout"})," 出 ",(0,n.jsx)(e.code,{children:"master"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:"branch"})," 的创建、切换和删除：","\n",(0,n.jsxs)(e.ol,{children:["\n",(0,n.jsxs)(e.li,{children:["创建 ",(0,n.jsx)(e.code,{children:"branch"})," 的方式是 ",(0,n.jsx)(e.code,{children:"git branch 名称"})," 或 ",(0,n.jsx)(e.code,{children:"git checkout -b 名称"}),"（创建后自动切换）；"]}),"\n",(0,n.jsxs)(e.li,{children:["切换的方式是 ",(0,n.jsx)(e.code,{children:"git checkout 名称"}),"；"]}),"\n",(0,n.jsxs)(e.li,{children:["删除的方式是 ",(0,n.jsx)(e.code,{children:"git branch -d 名称"}),"。"]}),"\n"]}),"\n"]}),"\n"]})]})}function u(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),c.components);return e?(0,n.jsx)(e,{...c,children:(0,n.jsx)(E,{...c})}):E(c)}let A=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["Git%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%2F4%E8%BF%9B%E9%98%B6%201%EF%BC%9AHEAD%E3%80%81master%20%E4%B8%8E%20branch.md"]={toc:[{text:"引用：commit 的快捷方式",id:"引用commit-的快捷方式",depth:2},{text:"HEAD：当前 commit 的引用",id:"head当前-commit-的引用",depth:2},{text:"branch",id:"branch",depth:2},{text:"master: 默认 branch",id:"master-默认-branch",depth:2},{text:"branch 的通俗化理解",id:"branch-的通俗化理解",depth:2},{text:"branch 的创建、切换和删除",id:"branch-的创建切换和删除",depth:2},{text:"创建 branch",id:"创建-branch",depth:3},{text:"切换 branch",id:"切换-branch",depth:3},{text:"删除 branch",id:"删除-branch",depth:3},{text:"「引用」的本质",id:"引用的本质",depth:2},{text:"小结",id:"小结",depth:2}],title:"4 进阶 1：HEAD、master 与 branch",headingTitle:"4 进阶 1：HEAD、master 与 branch",frontmatter:{}}}}]);