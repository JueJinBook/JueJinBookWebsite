"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["7161"],{977790:function(n,e,r){r.r(e),r.d(e,{default:()=>l});var i=r(552676),s=r(740453);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",blockquote:"blockquote",pre:"pre",code:"code",h3:"h3",ul:"ul",li:"li"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"第08章不同的思维面向过程和面向对象",children:["第08章—不同的思维：面向过程和面向对象",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第08章不同的思维面向过程和面向对象",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"\uFEFF"}),"\n",(0,i.jsx)(e.p,{children:"前面说到，代码是由我们写的，写完后就交给编译器去编译为电脑认识的东西，然后电脑再把它放到 CPU 里面去高速执行，最后再将结果展示给我们。这里面涉及到两次视角转换：一次是我们将写的转换为电脑认识的；一次是电脑执行完后转换为我们认识的。"}),"\n",(0,i.jsxs)(e.p,{children:["换句话说就是：",(0,i.jsx)(e.strong,{children:"我们写的代码是面向我们的，编译为电脑执行的代码就是面向计算机的。"})]}),"\n",(0,i.jsx)(e.p,{children:"正如下图所示："}),"\n",(0,i.jsx)(e.p,{children:"我们发现，人看的东西很直白，但是效率又很低；而电脑看的东西则根本无法读懂，但是效率又很高；那么怎么让人容易看明白，电脑执行起来又高效呢？"}),"\n",(0,i.jsx)(e.p,{children:"这就涉及到一个问题：面向对象和面向过程。"}),"\n",(0,i.jsxs)(e.h2,{id:"面向过程",children:["面向过程",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#面向过程",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"面向过程是以当前发生的事情为目标进行编程，以过程为核心，不考虑将来可能发生的事情。"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["简单直白点说就是：我只管现在的，将来啥样我不管，将来好不好改我也不管，我重视的就是当前这个过程，",(0,i.jsx)(e.strong,{children:"这就是计算机的思维"}),"。比如 C 语言，就是这个原理，C 语言是没有对象的，有对象的 C 语言叫 OC，虽然被骂的自己都不认识自己了，但是起码人家有了对象。"]}),"\n",(0,i.jsx)(e.p,{children:"比如，现在要做个车库管理软件，用面向过程的思维就是：只有一个类，你要干啥全部写在这里面，趁早把肚子里的需求直接梭哈，否则将来不好改我不改，或者你加钱。我不管好不好改，我只管现在写着爽不爽，快不快，刺激不刺激。"}),"\n",(0,i.jsx)(e.p,{children:"那么？面向过程这么垃圾的，为什么还存在呢？"}),"\n",(0,i.jsx)(e.p,{children:"因为有用啊！"}),"\n",(0,i.jsx)(e.p,{children:"面向过程本来就不是用来做客户软件的，是用来写计算机硬件的，谁家计算机硬件天天改？"}),"\n",(0,i.jsx)(e.p,{children:"而且，面向过程主要是针对计算机的，你跟计算机谈扩展性？跟计算机谈可读性和可维护性？抱歉，劳资是计算机，懂吗，计算机！我一秒一亿次的速度你有吗？就算我可读性再差，我也能用速度击败你。"}),"\n",(0,i.jsx)(e.p,{children:"其实，面向过程的速度并不差，反而更快！"}),"\n",(0,i.jsx)(e.p,{children:"为啥子呢？因为面向过程只注重当前，不注重未来的拓展性，所以就没有多余的逻辑，反而执行得更快。"}),"\n",(0,i.jsx)(e.p,{children:"考察如下代码："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"int getPrice(int level){\n    if(level>10) {\n        return 100;\n    }else if(level>9) {\n        return 90;\n    }else if(level>5) {\n        return 50;\n    }\n    return 10;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"这是面向过程的，如果将来加了其他 level，那就继续加 if-else 分支，拓展性真是差的一批，看不下去了，我去看面向对象的写法。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"interface IGetPrice {\n    int getPrice(int level);\n}\nclass Level10 implements IGetPrice{\n    int getPrice(int level) {\n        return 100;\n    }\n}\nclass Level9 implements IGetPrice {\n}\nclass ....\n"})}),"\n",(0,i.jsx)(e.p,{children:"嗯，拓展了多了类，用反射根据 level 创建出对应的对象就可以了，将来增加需求只需增加一个类就行了，拓展性确实强。"}),"\n",(0,i.jsx)(e.p,{children:"但是，哪个效率高啊，明显是面向过程效率高啊，只需要调用函数，甚至连对象都不用创建，就可以了。"}),"\n",(0,i.jsxs)(e.p,{children:["所以，你看，面向过程还是有用的，尤其是在开发",(0,i.jsx)(e.strong,{children:"需求修改不频繁"}),"，比如写一些工程算法或者写系统软件的时候，就应该采用面向过程，因为这时候要求的不是拓展性，而是速度，是性能！"]}),"\n",(0,i.jsx)(e.p,{children:"那么，不要求速度的时候呢？那就应该考虑面向对象了。"}),"\n",(0,i.jsxs)(e.h2,{id:"面向对象",children:["面向对象",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#面向对象",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"什么是面向对象呢？"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"面向对象就是将世间万物都视为对象，针对这些对象的具体行为进行编码。"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["面向对象有三大特点: ",(0,i.jsx)(e.strong,{children:"封装、继承和多态"}),"。"]}),"\n",(0,i.jsxs)(e.h3,{id:"封装",children:["封装",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#封装",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"封装就是把现实事物封装成抽象的类，并可以将类的权限加以修改，把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"简单来说就是：你只能看我给你看的，只能改我让你改的，别的你都不可以。"}),"\n",(0,i.jsx)(e.p,{children:"封装是面向对象的特征之一，是对象和类概念的主要特性，如果没有封装，那么继承就是无意义的，多态也就不存在了。"}),"\n",(0,i.jsx)(e.p,{children:"封装让对象针对不同的角色有不同的表现，让程序更有层级感。"}),"\n",(0,i.jsx)(e.p,{children:"有人说，封装不就是将一些属性改为私有的，一些属性改为公有的吗，也就是改个权限吗？"}),"\n",(0,i.jsx)(e.p,{children:"不是！"}),"\n",(0,i.jsxs)(e.p,{children:["修改权限只不过是封装的一部分，而且是次要部分，",(0,i.jsx)(e.strong,{children:"封装的主要部分是：将具体事物抽象成类这个过程"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"比如，现实中的一辆汽车，你把它抽象为一个类："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"class Car {}\n"})}),"\n",(0,i.jsx)(e.p,{children:"这才是封装的主要部分。"}),"\n",(0,i.jsxs)(e.h3,{id:"继承",children:["继承",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#继承",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:["继承是让类拥有另一个类的数据和函数，表达一种",(0,i.jsx)(e.strong,{children:"我也是你"}),"的关系。"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"继承的类叫做子类，也叫做派生类；被继承的类叫做父类，也叫基类。"}),"\n",(0,i.jsx)(e.p,{children:"就像人类只有一个亲爹一样，子类也只能有一个父类。C++ 这种就另当别论。"}),"\n",(0,i.jsx)(e.p,{children:"比如，上述的汽车，我们具体封装如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'class Car {\n    private int speed = 100;\n    public int price = 100;\n    public void run() {\n        println("run");\n    }\n}\n\nclass AudiCar extends Car {\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["我们的",(0,i.jsx)(e.code,{children:"AudiCar"}),"只需要继承一下",(0,i.jsx)(e.code,{children:"Car"}),"，那么它就自己带有了",(0,i.jsx)(e.code,{children:"Car"}),"里面的",(0,i.jsx)(e.code,{children:"price"}),"和",(0,i.jsx)(e.code,{children:"run()"}),"了，因为继承了就表示我也是你，那么奥迪车也是车，也有价格、也会跑。那么，里面有个",(0,i.jsx)(e.code,{children:"speed"}),"是私有的属性，",(0,i.jsx)(e.code,{children:"AudiCar"}),"有没有这个属性呢？答案是有的，其实也确实是继承了的，只不过不可见而已，不可见且不可修改，那也就等于没有继承。"]}),"\n",(0,i.jsx)(e.p,{children:"那你这继承有啥用呢？我自己再写一份不就行了吗？"}),"\n",(0,i.jsx)(e.p,{children:"继承可以省略大量代码，并且容易拓展，子类的公有属性和行为都可以放在父类中，而子类只需要放自己特有的属性和行为就可以了，这样可以统一处理子类的共有属性，方便管理；而子类的特有属性又可以在子类内部自己处理。"}),"\n",(0,i.jsxs)(e.p,{children:["如果，我不仅有一个奥迪车，还有宝马、奔驰、布加迪，那么我只要创建出它们的类型，直接继承",(0,i.jsx)(e.code,{children:"Car"}),"就行了，就不用反复声明",(0,i.jsx)(e.code,{children:"run()"}),"和",(0,i.jsx)(e.code,{children:"price"}),"了，这就节省了代码。"]}),"\n",(0,i.jsx)(e.p,{children:"有人说，不对啊，它们的速度都不一样，价格也不一样，你这直接继承了肯定有问题啊。"}),"\n",(0,i.jsxs)(e.p,{children:["这就涉及到多态了，其实",(0,i.jsx)(e.strong,{children:"继承就是为了多态"}),"。"]}),"\n",(0,i.jsxs)(e.h3,{id:"多态",children:["多态",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#多态",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"多态指的是：一个类的子类可以有不同的表现。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"比如，还是上述例子："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'class Car {\n    private int speed = 100;\n    public int price = 100;\n    public void run() {\n        pritnln("run");\n    }\n}\n\nclass AudiCar extends Car {\n    public void run() {\n        println("audi run");\n    }\n}\n\nclass BenchiCar extends Car {\n    public void run() {\n        println("Benchi run");\n    }\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["我们让奥迪和宝马分别实现了自己的",(0,i.jsx)(e.code,{children:"run()"}),"，但是它们价格和速度都一样，这就是多态，可以拥有相同的属性，也可以拥有不同的行为。"]}),"\n",(0,i.jsx)(e.p,{children:"上面我们说到，继承就是为了多态。"}),"\n",(0,i.jsx)(e.p,{children:"谁跟你说的？你怎么证明？"}),"\n",(0,i.jsx)(e.p,{children:"我跟我说的，这就来给你证明。"}),"\n",(0,i.jsxs)(e.p,{children:["假如继承不是为了多态，那么上述的",(0,i.jsx)(e.code,{children:"AudiCar"}),"和",(0,i.jsx)(e.code,{children:"BenchiCar"}),"的代码就一模一样，都跟",(0,i.jsx)(e.code,{children:"Car"}),"一样，那么，你是吃饱了撑的写三个一模一样的类吗？所有地方直接使用",(0,i.jsx)(e.code,{children:"Car"}),"不就行了吗。"]}),"\n",(0,i.jsx)(e.p,{children:"有人说，我复用啊，继承除了多态不就是复用吗？"}),"\n",(0,i.jsx)(e.p,{children:"大哥，你这不是复用，你这是 CV，你这代码一模一样，复用率都 100% 了，就不叫复用了。"}),"\n",(0,i.jsxs)(e.p,{children:["所以，",(0,i.jsx)(e.strong,{children:"继承就是为了多态"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"那么，多态又是为了啥呢？"}),"\n",(0,i.jsx)(e.p,{children:"多态是为了代码容易修改，容易拓展。换句话说，没有多态，就没有设计模式了。"}),"\n",(0,i.jsx)(e.p,{children:"我们考察如下代码，我要一辆汽车，上班开："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"public User {\n    public AudiCar car;\n    \n    public void goWork(){\n        car.run();\n    }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"简单明了的代码，直接给你一辆奥迪车。如果有一天，我发现奥迪车被偷了，那就只能换个奔驰了？"}),"\n",(0,i.jsx)(e.p,{children:"嗯，那就修改下代码："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"public User {\n    public BenchiCar car;\n    \n    public void goWork(){\n        car.run();\n    }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"如果后面再想换呢？那就再改？"}),"\n",(0,i.jsx)(e.p,{children:"这样不太好啊，我本来只说要个能跑的车就行，没有说要啥车，只要能跑就行啊，那所有的车都能跑啊，直接这样行吗："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"public User {\n    public Car car;\n    \n    public void goWork(){\n        car.run();\n    }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"并不指定啥牌子的车，只要是车就行，换句话说，不指定具体的子类，而是指定它们共同的能跑的父类——车！"}),"\n",(0,i.jsx)(e.p,{children:"这样将来不管你啥车被偷都没事，只要不被偷光，我就不用改代码："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"Car car = new AudiCar();\ncar = new BenchiCar();\ncar = new 还没被偷的Car();\n"})}),"\n",(0,i.jsxs)(e.p,{children:["都可以啊，这就是多态的好处，",(0,i.jsx)(e.strong,{children:"拓展性强，容易修改"}),"。"]}),"\n",(0,i.jsxs)(e.h3,{id:"继承和实现的关系",children:["继承和实现的关系",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#继承和实现的关系",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"我们上述说到了继承关系只能有一个，也就是只能有一个父类。那么，如果我需要多继承呢？"}),"\n",(0,i.jsxs)(e.p,{children:["这时候你就可以用",(0,i.jsx)(e.code,{children:"接口"}),"了。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"接口表示我具有某种功能"}),"，",(0,i.jsx)(e.strong,{children:"继承表示我就是某种东西"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"当然，你只能是一种东西，所以你只能单继承；但是你可以有多种功能，所以你可以实现多个接口。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"interface CanFly {}\ninterface CanSwim {}\ninterface Can72Change {}\nclass NvWa {}\n\nclass Sunwukong extends NvWa implenents CanFly, CanSwim, Can72Change {\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"孙悟空这么牛叉的人，即使会飞、会游泳、能 72 变，也只能有女娲这一个父类。"}),"\n",(0,i.jsxs)(e.h3,{id:"继承的坏处",children:["继承的坏处",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#继承的坏处",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"上面我们通过实现接口解决了多继承的问题，那么继承有什么坏处呢？"}),"\n",(0,i.jsxs)(e.p,{children:["嗯，",(0,i.jsx)(e.strong,{children:"继承破坏了封装"}),"。上面我们说了，封装的次要功能是：将某些属性保护起来，不被别人知道。但是，一旦你被继承了，你那些保护起来的东西，也都被子类继承到了，那么子类会不会滥用呢？"]}),"\n",(0,i.jsxs)(e.p,{children:["这就要看儿子的心情了。坑爹的儿子还是有的，所以，我们就发明了",(0,i.jsx)(e.code,{children:"权限关键词"}),"这个东西。"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"public：所有人可见。"}),"\n",(0,i.jsx)(e.li,{children:"protected：只有自己和子类可见。"}),"\n",(0,i.jsx)(e.li,{children:"private：只有自己可见。"}),"\n",(0,i.jsx)(e.li,{children:"final：用来修饰方法，避免被重写。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"父类只要把自己的属性声明为 private 类型的，那么子类也就不可见了（通过反射修改的行为是可耻的）。"}),"\n",(0,i.jsx)(e.p,{children:"通过这个东西，就可以惩治劣子，让继承更加完美。"}),"\n",(0,i.jsxs)(e.h2,{id:"总结",children:["总结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"本章我们重点介绍了面向过程和面向对象，其中面向过程主要使用在一些不可变的，或者少变的工程项目，比如：操作系统、工程算法，这类项目以追求性能为主。而面向对象则用在一些软件开发、客户需求上面，这类项目是最多的。"}),"\n",(0,i.jsx)(e.p,{children:"我们还讲了面向对象的三大特性：封装、继承和多态。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"封装：将事物抽象为一个类，然后针对不同的对象添加不同的访问权限。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"继承：使得自己拥有父类的属性和方法，只能单继承。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"多态：子类可以有跟父类不同的表现。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"下一章，我们就在实际项目中来使用面向对象的这些特点。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC08%E7%AB%A0%E2%80%94%E4%B8%8D%E5%90%8C%E7%9A%84%E6%80%9D%E7%BB%B4%EF%BC%9A%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.md"]={toc:[{text:"面向过程",id:"面向过程",depth:2},{text:"面向对象",id:"面向对象",depth:2},{text:"封装",id:"封装",depth:3},{text:"继承",id:"继承",depth:3},{text:"多态",id:"多态",depth:3},{text:"继承和实现的关系",id:"继承和实现的关系",depth:3},{text:"继承的坏处",id:"继承的坏处",depth:3},{text:"总结",id:"总结",depth:2}],title:"第08章—不同的思维：面向过程和面向对象",headingTitle:"第08章—不同的思维：面向过程和面向对象",frontmatter:{}}}}]);