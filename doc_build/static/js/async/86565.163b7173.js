"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["86565"],{905838:function(e,c,r){r.r(c),r.d(c,{default:()=>U});var a=r(552676),s=r(740453);let n=r.p+"static/image/761ff60b4363156022001cb498c0f7c0.1eda9d0c.webp",i=r.p+"static/image/0d1122fdc24db97e96aaa3673ce8351a.5fa9e90e.webp",d=r.p+"static/image/ec092083dd82b1b1154bf10bdbe306bb.889958b6.webp",t=r.p+"static/image/dfa24319faa5143c762b554c8c2beb7f.04673c04.webp",l=r.p+"static/image/fbd4437831538617251691e9adf76684.0db950b1.webp",h=r.p+"static/image/6301c8b7b4d3fe8717affa70ff4b7706.15ffe84f.webp",p=r.p+"static/image/95b91da93812d0b18ababcbcc06fa33b.33b4c4d4.webp",x=r.p+"static/image/32b401ec52e67eeebf785c51b154cdaa.591fcd45.webp",j=r.p+"static/image/4bda0dc868522d08b83749dc80d8a6bb.05580975.webp",b=r.p+"static/image/661c345597f5a023e222f4ea849c3c52.48b28cd0.webp",o=r.p+"static/image/bd4ce7ce612e6485c38f306f0a37833a.ae7cc2ef.webp",m=r.p+"static/image/80d4c42d21b4ce94a5d03e1aac1b77af.bce969d2.webp",g=r.p+"static/image/bb5495c7ad02743a9eb128328d4e0c0e.3c22f86f.webp",u=r.p+"static/image/f560440318dba8671d47303b96e9d9f9.d9303c4a.webp",f=r.p+"static/image/e137bec47402466fa1070244e98ce681.1154627a.webp",w=r.p+"static/image/3e9475efa4e164d4a7cbcadc6e4c8ece.4fd4e600.webp",C=r.p+"static/image/d21b7628c342a5e647807e6e81e16d24.17865dcf.webp",D=r.p+"static/image/8af7f93e44cde31ec254b97ed1a9a36b.f51b908a.webp",E=r.p+"static/image/fd0f37193dcc347fb896562ebbce2ae4.6bd6eb21.webp",S=r.p+"static/image/2667d2b8cc29ddaaaad3c367c9696ec9.17e037cc.webp",k=r.p+"static/image/e898a67e6f88ec9dc2d4474af1922226.f7cb6b1d.webp",A=r.p+"static/image/118b699035462d78c2cccab5431e6f35.4e664c5d.webp",v=r.p+"static/image/a91dc382b5a1da4741726347cf09934c.50a960dc.webp",_=r.p+"static/image/8a647b65c43db4f7cad93beb36c12f2f.c120ea93.webp",y=r.p+"static/image/7ada1d2eea0d27f1d6d4d44a4256a5eb.e8d32b0c.webp",V=r.p+"static/image/cfa06cec7fb43f11cb8df5bd106bb9a6.b9c3b01f.webp",G=r.p+"static/image/2018b08e60bf9b7d4b2d64ef4aa83276.18a8b081.webp",T=r.p+"static/image/31531e9a7c3426e81378ee08b23ffdbf.ac8f4e6a.webp",M=r.p+"static/image/e41db8e466634624f1ebc60cf5482d1e.e93cc2ba.webp",N=r.p+"static/image/769ed164eb658c0ea5ce96da6c32282a.b6f025b0.webp",O=r.p+"static/image/2ea57839ae628b91941edf543b45942e.f60401e7.webp",P=r.p+"static/image/abb05e291e639dcc95752e0cf96153ec.4da8b140.webp",R=r.p+"static/image/add2e28fd7330dc95961ddc012dcb652.3940bb88.webp",F=r.p+"static/image/b534e7b72ed645323e1667d2cc81f0bf.70b242cd.webp",B=r.p+"static/image/336092d82bccd4d11da1dd12bfcb950a.5d316d59.webp",H=r.p+"static/image/5f4a83db0f3dc9e1d0974b70136cb9da.a4df74fa.webp",J=r.p+"static/image/7eeac45429cfb11080100dc64cfd7efb.d9e4e55d.webp",L=r.p+"static/image/25a97cb92b098e69cd06e2584e4eae5d.dae31e24.webp",$=r.p+"static/image/c87d822e9de695701a04189a2aaaac3d.cec4f3d6.webp";function q(e){let c=Object.assign({h1:"h1",a:"a",p:"p",code:"code",img:"img",h2:"h2",pre:"pre",h3:"h3",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(c.h1,{id:"4vscode-chrome-debugger-配置详解",children:["4.VSCode Chrome Debugger 配置详解",(0,a.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#4vscode-chrome-debugger-配置详解",children:"#"})]}),"\n",(0,a.jsx)(c.p,{children:"上节我们学会了如何用 VSCode Debugger 调试网页的 JS，其实它还有很多有用的配置项，这节我们一起来过一遍："}),"\n",(0,a.jsxs)(c.p,{children:["首先，调试配置文件不用自己创建，可以直接点击 Debug 窗口的 ",(0,a.jsx)(c.code,{children:"create a launch.json file"})," 快速创建："]}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:$,alt:""})}),"\n",(0,a.jsxs)(c.h2,{id:"launchattach",children:["launch/attach",(0,a.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#launchattach",children:"#"})]}),"\n",(0,a.jsx)(c.p,{children:"创建 Chrome Debug 配置有两种方式：launch 和 attach："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:L,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"它们只是 request 的配置不同："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:J,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"我们知道，调试就是把浏览器跑起来，访问目标网页，这时候会有一个 ws 的调试服务，我们用 frontend 的 ws 客户端连接上这个 ws 服务，就可以进行调试了。"}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:H,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"VSCode 的 Debugger 会多一层适配器协议的转换，但是原理差不多。"}),"\n",(0,a.jsx)(c.p,{children:"launch 的意思是把 url 对应的网页跑起来，指定调试端口，然后 frontend 自动 attach 到这个端口。"}),"\n",(0,a.jsx)(c.p,{children:"但如果你已经有一个在调试模式跑的浏览器了，那直接连接上就行，这时候就直接 attach。"}),"\n",(0,a.jsx)(c.p,{children:"比如我们手动把 Chrome 跑起来，指定调试端口 remote-debugging-port 为 9222，指定用户数据保存目录 user-data-dir 为你自己创建一个目录。"}),"\n",(0,a.jsx)(c.p,{children:"在命令行执行下面的命令："}),"\n",(0,a.jsx)(c.pre,{children:(0,a.jsx)(c.code,{children:"/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --remote-debugging-port=9222 --user-data-dir=你自己创建的某个目录\n"})}),"\n",(0,a.jsx)(c.p,{children:"Chrome 跑起来之后，你可以打开几个网页，比如百度、掘金，然后你访问 localhost:9222/json，这时候你就会发现所有的 ws 服务的地址了："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:B,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"为什么每个页面有单独的 ws 服务呢？"}),"\n",(0,a.jsx)(c.p,{children:"这个很正常呀，每个页面的调试都是独立的，自然就需要单独的 ws 服务。"}),"\n",(0,a.jsx)(c.p,{children:"然后你创建一个 attach 的 Chrome Debug 配置："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:F,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"点击启动，就会看到 VSCode Debugger 和每一个页面的 ws 调试服务建立起了链接："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:R,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"比如访问之前的 React 项目，就可以进行调试了："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:P,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"可以多个页面一起调试，每个页面都有独立的调试上下文。"}),"\n",(0,a.jsxs)(c.h2,{id:"userdatadir",children:["userDataDir",(0,a.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#userdatadir",children:"#"})]}),"\n",(0,a.jsx)(c.p,{children:"不知道你有没有注意到刚才手动启动 Chrome 的时候，除了指定调试端口 remote-debugging-port 外，还指定了用户数据目录 user-data-dir。"}),"\n",(0,a.jsx)(c.p,{children:"为什么要指定这个呢？"}),"\n",(0,a.jsx)(c.p,{children:"user data dir 是保存用户数据的地方，比如你的浏览记录、cookies、插件、书签、网站的数据等等，在 macOS 下是保存在这个位置："}),"\n",(0,a.jsx)(c.pre,{children:(0,a.jsx)(c.code,{children:"~/Library/Application\\ Support/Google/Chrome\n"})}),"\n",(0,a.jsx)(c.p,{children:"比如你打开 Default/Bookmarks 看一下，是不是都是你保存的书签？"}),"\n",(0,a.jsx)(c.pre,{children:(0,a.jsx)(c.code,{children:"open ~/Library/Application\\ Support/Google/Chrome/Default/Bookmarks\n"})}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:O,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"你还可以删掉 Deault/Cookies，之后再访问之前登陆过的网站试一下，是不是都需要登录了？"}),"\n",(0,a.jsx)(c.p,{children:"这就是用户数据目录的作用。"}),"\n",(0,a.jsx)(c.p,{children:"那为什么启动 Chrome 要手动指定这个呢？都用默认的不行么？"}),"\n",(0,a.jsx)(c.p,{children:"用户数据目录有个特点，就是只能被一个 Chrome 实例所访问，如果你之前启动了 Chrome 用了这个默认的 user data dir，那就不能再启动一个 Chrome 实例用它了。"}),"\n",(0,a.jsx)(c.p,{children:"如果用户数据目录已经跑了一个 Chrome 实例，再跑一个候会报这样的错误："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:N,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"所以我们用调试模式启动 Chrome 的时候，需要单独指定一下 user data dir 的位置。或者你也把之前的 Chrome 实例关掉，这样才能用默认的。"}),"\n",(0,a.jsx)(c.p,{children:"launch 的配置项里也有 userDataDir 的配置："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:M,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"默认是 true，代表创建一个临时目录来保存用户数据。"}),"\n",(0,a.jsx)(c.p,{children:"你也可以设置为 false，使用默认 user data dir 启动 chrome。"}),"\n",(0,a.jsx)(c.p,{children:"这样的好处就是登录状态、历史记录啥的都有："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:T,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"把 userDataDir 设置为 true 就每次都需要登录了："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:G,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"你也可以指定一个自定义的路径，这样用户数据就会保存在那个目录下："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:V,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"更重要的是，你安装的 React DevTools、Vue DevTools 插件都是在默认用户数据目录的，要是用临时数据目录跑调试，那这些不都没了？"}),"\n",(0,a.jsx)(c.p,{children:"比如你 userDataDir 设置为 true 的时候，React DevTools 插件是没有的，需要再安装："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:y,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"userDataDir 设置为 false 的时候，安装过的插件都可以直接用："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:_,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"但是除了调试用之外，平时也会用到 Chrome 呀，同一个 user data dir 只能跑一个 Chrome 实例的话，那不就冲突了？"}),"\n",(0,a.jsx)(c.p,{children:"这个问题可以用下面的配置解决："}),"\n",(0,a.jsxs)(c.h2,{id:"runtimeexecutable",children:["runtimeExecutable",(0,a.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#runtimeexecutable",children:"#"})]}),"\n",(0,a.jsx)(c.p,{children:"调试网页的 JS，需要先把 Chrome 跑起来，默认跑的是 Google Chrome，其实它还有另外一个版本 Canary："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:v,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"这是给开发者用的每日构建版，能够快速体验新特性，但是不稳定。"}),"\n",(0,a.jsx)(c.p,{children:"而 Google Chrome 是给普通用户用的，比较稳定。"}),"\n",(0,a.jsx)(c.p,{children:"这俩是独立的，相互之间没影响，可以都用同一个 user data dir 来启动。"}),"\n",(0,a.jsxs)(c.p,{children:["你可以在",(0,a.jsx)(c.a,{href:"https://www.google.com/intl/zh-CN/chrome/canary/",target:"_blank",rel:"noopener noreferrer",children:"官网"}),"把 canary 下载下来。"]}),"\n",(0,a.jsx)(c.p,{children:"然后指定 runtimeExecutable 为 canary，使用默认的用户数据目录启动："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:A,alt:""})}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:k,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"这样你就可以调试用 canary，平时用 chrome 了，两者都有各自的默认数据目录。"}),"\n",(0,a.jsx)(c.p,{children:"（注意，一定要先安装了 canary，才能指定 canary 跑）"}),"\n",(0,a.jsx)(c.p,{children:"当然，runtimeExecutable 还可以指定用别的浏览器跑："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:S,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"可以是 stable，也就是稳定的 Google Chrome，或者 canary，也就是每日构建版的 Google Chrome Canary，还可以是 custom，然后用 CHROME_PATH 环境变量指定浏览器的地址。"}),"\n",(0,a.jsx)(c.p,{children:"不过常用的还是 Chrome 和 Canary。"}),"\n",(0,a.jsxs)(c.h3,{id:"runtimeargs",children:["runtimeArgs",(0,a.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#runtimeargs",children:"#"})]}),"\n",(0,a.jsx)(c.p,{children:"启动 Chrome 的时候，可以指定启动参数，比如每次打开网页都默认调起 Chrome DevTools，就可以加一个 --auto-open-devtools-for-tabs 的启动参数："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:E,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"效果就是这样的："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:D,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"想要无痕模式启动，也就是不加载插件，没有登录状态，就可以加一个 --incognito 的启动参数："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:C,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"调试用的浏览器就会以无痕模式启动了："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:w,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"其实我们设置的 userDataDir 就是指定了 --user-data-dir 的启动参数。"}),"\n",(0,a.jsxs)(c.h2,{id:"sourcemappathoverrides",children:["sourceMapPathOverrides",(0,a.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#sourcemappathoverrides",children:"#"})]}),"\n",(0,a.jsx)(c.p,{children:"代码是经过编译打包然后在浏览器运行的，比如这样："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:f,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"但我们却可以直接调试源码，这是通过 sourcemap 做到的。"}),"\n",(0,a.jsx)(c.p,{children:"调试工具都支持 sourcemap，并且是默认开启的："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"当然也可以关掉:"}),"\n",(0,a.jsx)(c.p,{children:"Chrome DevTools 里这么关（command + shift + p）："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"VSCode Debugger 这么关："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"这样调试的就是编译后的代码了："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"在开启 sourcemap 的情况下，用 Chrome DevTools 可以看到，源文件的路径是 /static/js/bundle.js"}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"被 sourcemap 到了 /Users/guang/code/test-react-debug/src/index.js"}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:j,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"而在 VSCode 里，这个路径是有对应的文件的，所以就会打开对应文件的编辑器，这样就可以边调试边修改代码。"}),"\n",(0,a.jsx)(c.p,{children:"但有的时候，sourcemap 到的文件路径在本地里找不到，这时候代码就只读了，因为没有地方保存："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"这种情况就需要对 sourcemap 到的路径再做一次映射："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"通过 sourceMapPathOverrides 这个配置项。"}),"\n",(0,a.jsx)(c.p,{children:"默认有这么三个配置："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"分别是把 meteor、webpack 开头的 path 映射到了本地的目录下。"}),"\n",(0,a.jsx)(c.p,{children:"其中 ?:* 代表匹配任意字符，但不映射，而 * 是用于匹配字符并映射的。"}),"\n",(0,a.jsx)(c.p,{children:"比如最后一个 webpack://?:*/* 到 ${workspaceFolder}/* 的映射，就是把 webpack:// 开头，后面接任意字符 + / 然后是任意字符的路径映射到了本地的项目目录。（workspaceFolder 是一个内置变量，代表项目根目录）"}),"\n",(0,a.jsx)(c.p,{children:"把调试的文件 sourcemap 到的路径映射到本地的文件，这样调试的代码就不再只读了："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsxs)(c.h2,{id:"file",children:["file",(0,a.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#file",children:"#"})]}),"\n",(0,a.jsx)(c.p,{children:"除了启动开发服务器然后连上 url 调试之外，也可以直接指定某个文件，VSCode Debugger 会启动静态服务器提供服务："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"index.html 的内容如下："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"打了个断点，然后启动调试："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"这样就可以直接调试静态网页了。"}),"\n",(0,a.jsx)(c.p,{children:"同样，要修改调试的内容需要把 url 映射到本地文件才行，所以有这样一个 pathMapping 的配置："}),"\n",(0,a.jsx)(c.p,{children:(0,a.jsx)("img",{src:n,alt:""})}),"\n",(0,a.jsx)(c.p,{children:"webRoot 其实就相当于把 / 的 url 映射到了 ${workspaceFoder}/。"}),"\n",(0,a.jsx)(c.p,{children:"这些配置倒是很少用，一般我们还是启动 dev server，再调试某个 url 更多一些。"}),"\n",(0,a.jsxs)(c.h2,{id:"总结",children:["总结",(0,a.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(c.p,{children:"这节我们过了一遍 VSCode Chrome Debugger 的配置："}),"\n",(0,a.jsxs)(c.ul,{children:["\n",(0,a.jsx)(c.li,{children:"launch：调试模式启动浏览器，访问某个 url，然后连上进行调试"}),"\n",(0,a.jsx)(c.li,{children:"attach：连接某个已经在调试模式启动的 url 进行调试"}),"\n",(0,a.jsx)(c.li,{children:"userDataDir： user data dir 是保存用户数据的地方，比如浏览历史、cookie 等，一个数据目录只能跑一个 chrome，所以默认会创建临时用户数据目录，想用默认的目录可以把这个配置设为 false"}),"\n",(0,a.jsx)(c.li,{children:"runtimeExecutable：切换调试用的浏览器，可以是 stable、canary 或者自定义的"}),"\n",(0,a.jsx)(c.li,{children:"runtimeArgs：启动浏览器的时候传递的启动参数"}),"\n",(0,a.jsx)(c.li,{children:"sourceMapPathOverrides：对 sourcemap 到的文件路径做一次映射，映射到 VSCode workspace 下的文件，这样调试的文件就可以修改了"}),"\n",(0,a.jsx)(c.li,{children:"file：可以直接指定某个文件，然后启动调试"}),"\n"]}),"\n",(0,a.jsx)(c.p,{children:"这些配置后面调试的时候经常会用到，要理解它们的含义。"})]})}function z(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,s.ah)(),e.components);return c?(0,a.jsx)(c,{...e,children:(0,a.jsx)(q,{...e})}):q(e)}let U=z;z.__RSPRESS_PAGE_META={},z.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F4.VSCode%20Chrome%20Debugger%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3.md"]={toc:[{text:"launch/attach",id:"launchattach",depth:2},{text:"userDataDir",id:"userdatadir",depth:2},{text:"runtimeExecutable",id:"runtimeexecutable",depth:2},{text:"runtimeArgs",id:"runtimeargs",depth:3},{text:"sourceMapPathOverrides",id:"sourcemappathoverrides",depth:2},{text:"file",id:"file",depth:2},{text:"总结",id:"总结",depth:2}],title:"4.VSCode Chrome Debugger 配置详解",headingTitle:"4.VSCode Chrome Debugger 配置详解",frontmatter:{}}}}]);