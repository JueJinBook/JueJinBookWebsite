"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["74072"],{289103:function(e,c,n){n.r(c),n.d(c,{default:()=>B});var i=n(552676),d=n(740453);let s=n.p+"static/image/764ce7aef536fb6faefb73e5041df31e.413050a5.webp",r=n.p+"static/image/2a8164640aa1b3ade4f72357a06c680e.3bc7a639.webp",l=n.p+"static/image/d1c1f7b0c0271376e0d10055d0a3d771.c6e5f2bb.webp",h=n.p+"static/image/027e755b524f3b05da362d1c95fc846a.4ea1927a.webp",x=n.p+"static/image/b9e0f28183ac9a71308f7fba965190cd.13eaf9ed.webp",j=n.p+"static/image/541f005add8a72d66769cefe18c8a74a.51209342.webp",t=n.p+"static/image/e892f2f6a0a247cd297eb50875f2242d.9805e3e8.webp",a=n.p+"static/image/42296af2d4ebe7f49a33b0146bd3d78d.8460aec7.webp",o=n.p+"static/image/ebf918f4bc43493c12a7894e1126fd29.11f9aac7.webp",g=n.p+"static/image/dd17e90a9d4928fd9c1ea60aa5905c6b.79392517.webp",p=n.p+"static/image/66dc3a33578a9317739ee12a67a216d2.41605495.webp",m=n.p+"static/image/f5dcfe7f561c07cd9ce4cdba31409a12.87d3b67c.webp",b=n.p+"static/image/319936b9fa1c83ec9eadc14d5ed2fd80.5a899824.webp",u=n.p+"static/image/c27b6fd8b95a4d1e3225372542ecc554.b5be5ed5.webp",f=n.p+"static/image/8fccc1eb7adbfc1f3145b1b3d17ad5f4.e51516dc.webp",E=n.p+"static/image/6e7c9d44a0e14f52acdba93d6ae4ace5.4695fb2f.webp",_=n.p+"static/image/457a1e6d322d7a82aa1714182cbca046.8db53455.webp";function w(e){let c=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",img:"img",strong:"strong",ul:"ul",li:"li",pre:"pre"},(0,d.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(c.h1,{id:"第31章git实践常用的gui工具和命令",children:["第31章—Git实践：常用的GUI工具和命令",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#第31章git实践常用的gui工具和命令",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["\uFEFF上一章，我们讲了",(0,i.jsx)(c.code,{children:"git"}),"的工作流程和原理，本章我们就回到使用的层面，来看看日常工作中，该怎么使用",(0,i.jsx)(c.code,{children:"git"}),"进行实操。"]}),"\n",(0,i.jsxs)(c.p,{children:["其实，就使用来说，我们可以把",(0,i.jsx)(c.code,{children:"git"}),"的操作分为两类。"]}),"\n",(0,i.jsxs)(c.p,{children:["一类是用",(0,i.jsx)(c.code,{children:"GUI"}),"工具的，这种看起来比较直观，比较简单，但是缺点就是耗内存，需要单独安装软件，有些场景下使用起来不是很方便。"]}),"\n",(0,i.jsx)(c.p,{children:"另一类就是使用命令行的，这个刚用起来比较费劲，让人有想骂娘的冲动，但是时间久了就会觉得真香，而且不需要安装额外的软件，熟了之后你就会发现真方便。"}),"\n",(0,i.jsx)(c.p,{children:"本章我们就一起来看看这两类用法。"}),"\n",(0,i.jsxs)(c.h2,{id:"sourcetree",children:["SourceTree",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#sourcetree",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["GUI 工具中，最好用的应该就是",(0,i.jsx)(c.code,{children:"SourceTree"}),"了，大家可以去",(0,i.jsx)(c.a,{href:"https://www.sourcetreeapp.com/",target:"_blank",rel:"noopener noreferrer",children:"官网"}),"下载对应的版本，这里就不废话了，我们直接下载完成安装即可。"]}),"\n",(0,i.jsx)(c.p,{children:"我们安装完启动，就会看到如下画面："}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:_,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["我们直接点击“新建” -> “添加已经存在的本地仓库”，然后选择我们上一章的",(0,i.jsx)(c.code,{children:"helloworld"}),"项目目录即可，然后就会发现我们的项目已经列出来了。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:E,alt:"image.png"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["然后我们打开我们的项目，随便修改一个文件，比如，修改我们的",(0,i.jsx)(c.code,{children:".gitignore"}),"文件，添加一行",(0,i.jsx)(c.code,{children:"/nm"}),"，然后就会发现",(0,i.jsx)(c.code,{children:"sourcetree"}),"中项目的目录右边有个 1，如下所示："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,i.jsx)(c.p,{children:"这就表示我们的项目有一个改动等待提交。"}),"\n",(0,i.jsx)(c.p,{children:"我们双击打开，如下："}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["其中最左边列出了我们项目的分支，上面是本地分支，可以看到当前只有一个",(0,i.jsx)(c.code,{children:"master"}),"分支，并且有个小圆圈，这表示当前所在的分支就是",(0,i.jsx)(c.code,{children:"master"}),"，下面有“远端”，表示远程的分支。中间列出了",(0,i.jsx)(c.code,{children:".gitignore"}),"文件，并且被打勾，表示已经暂存，右边列出了文件的改动，",(0,i.jsx)(c.code,{children:"-"}),"表示删除了一行，",(0,i.jsx)(c.code,{children:"+"}),"表示添加了一行。"]}),"\n",(0,i.jsxs)(c.p,{children:["现在，我们选中",(0,i.jsx)(c.code,{children:".gitignore"}),"文件，点击右键，选择“重置”，如下："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,i.jsx)(c.p,{children:"就会发现文件不提示了，其实，重置的意思就等于放弃修改，也就是把文件还原到上次提交后的状态。"}),"\n",(0,i.jsx)(c.p,{children:"这不是我们想要的，我们希望修改保留，但是不放在暂存区，怎么做呢？我们只需要取消文件前的打勾即可，如下："}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["这就是取消暂存，等价于执行了",(0,i.jsx)(c.code,{children:"git rm --cached"}),"命令，如果我们想要提交呢？"]}),"\n",(0,i.jsxs)(c.p,{children:["我们先勾选文件，让它变为暂存文件，然后在下方输入框中输入提交信息，点击右下方的“提交”即可提交，等价于执行了",(0,i.jsx)(c.code,{children:"git commit"}),"；如果你同时勾选了下面的“",(0,i.jsx)(c.strong,{children:"立即推送变更到 origin/master"}),"”，则文件在提交的同时也会推送，等价于同时执行了",(0,i.jsx)(c.code,{children:"git push"}),"。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,i.jsx)(c.p,{children:"如下图："}),"\n",(0,i.jsxs)(c.ul,{children:["\n",(0,i.jsx)(c.li,{children:"1 代表提交信息。"}),"\n",(0,i.jsx)(c.li,{children:"2 代表提交。"}),"\n",(0,i.jsx)(c.li,{children:"3 代表同时推送到远程仓库。"}),"\n"]}),"\n",(0,i.jsx)(c.p,{children:"好，我们执行完提交之后，再来看看历史记录，我们点击左侧的“历史”，就能在右边看到历史的提交记录，如下图："}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,i.jsx)(c.p,{children:"我们选择任意的一个提交，下方就会列出提交的具体内容，如下："}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,i.jsx)(c.p,{children:"这样很方便以后的查找，当然，有些想偷偷摸摸干坏事的人，这里就要小心了，你的每一行代码都会记录在案，作为呈堂供词，千万别再胡写八写了。"}),"\n",(0,i.jsx)(c.p,{children:"有人说，提交我知道了，下载代码怎么弄呢？"}),"\n",(0,i.jsxs)(c.p,{children:["我们关闭我们的仓库，回到",(0,i.jsx)(c.code,{children:"sourcetree"}),"的首页，然后选择“新建” -> “从URL克隆”，这就会从你输入的地址下载代码，等价于我们上一章执行的",(0,i.jsx)(c.code,{children:"git clone"}),"命令。"]}),"\n",(0,i.jsx)(c.p,{children:"那么，要拉取变动的内容呢？"}),"\n",(0,i.jsxs)(c.p,{children:["我们就可以选择左边的“远端” -> “拉取",(0,i.jsx)(c.code,{children:"origin/master"}),"到",(0,i.jsx)(c.code,{children:"master"}),"”："]}),"\n",(0,i.jsxs)(c.p,{children:["这也就等价于执行了",(0,i.jsx)(c.code,{children:"git pull"}),"指令。"]}),"\n",(0,i.jsxs)(c.p,{children:["好，到这里，你应该知道了",(0,i.jsx)(c.code,{children:"sourcetree"}),"的每一个操作跟对应的指令的关系了。"]}),"\n",(0,i.jsxs)(c.p,{children:["其实说白了，",(0,i.jsx)(c.code,{children:"sourcetree"}),"就是把指令实现的功能，用图形表示出来，提供一个可视化的操作方式，使用起来更直观、更方便而已。"]}),"\n",(0,i.jsx)(c.p,{children:"当然，对于高手来说，命令是最好的、最快捷的。"}),"\n",(0,i.jsxs)(c.h2,{id:"终端命令",children:["终端命令",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#终端命令",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"终端命令是装 x 耍帅必备的看家技能之一。一个程序员技术的高低，一方面取决于头发的稀少程度，另一方面就取决于终端命令的熟练程度。"}),"\n",(0,i.jsxs)(c.p,{children:["不仅",(0,i.jsx)(c.code,{children:"Linux"}),"有终端命令，我们的",(0,i.jsx)(c.code,{children:"git"}),"也有很多终端命令，我们在这里就列出一些常见的命令，来提供给大家记忆并使用。"]}),"\n",(0,i.jsxs)(c.ul,{children:["\n",(0,i.jsxs)(c.li,{children:["初始化命令 ",(0,i.jsx)(c.code,{children:"git init"}),"，将当前目录初始化为一个",(0,i.jsx)(c.code,{children:"git"}),"目录。"]}),"\n",(0,i.jsxs)(c.li,{children:["克隆命令 ",(0,i.jsx)(c.code,{children:"git clone xxxxxxx"}),"，拉取远程仓库的代码到本地。"]}),"\n",(0,i.jsxs)(c.li,{children:["暂存命令 ",(0,i.jsx)(c.code,{children:"git add xxx"}),"，其中 xxx 是文件名，将对应文件添加到暂存区，如果将",(0,i.jsx)(c.code,{children:"xxx"}),"换为",(0,i.jsx)(c.code,{children:"."}),"，就是将当前目录的所有文件添加到暂存区，并且 xxx 支持正则表达式。"]}),"\n",(0,i.jsxs)(c.li,{children:["撤销暂存命令 ",(0,i.jsx)(c.code,{children:"git rm --cached xxx"}),"，将 xxx 撤销暂存，同样可以替换为点号，同样支持正则表达式，下面的 xxx 都一样。"]}),"\n",(0,i.jsxs)(c.li,{children:["提交命令 ",(0,i.jsx)(c.code,{children:'git commit -m "aaa"'}),"，其中 aaa 为提交信息。"]}),"\n",(0,i.jsxs)(c.li,{children:["回退版本命令",(0,i.jsx)(c.code,{children:"git reset bbb"}),"，用于将本地版本进行回退，其中 bbb 是你想要回退到的版本号，将",(0,i.jsx)(c.code,{children:"bbb"}),"替换为",(0,i.jsx)(c.code,{children:"HEAD^"}),"可以直接回退到上一个版本。",(0,i.jsx)(c.code,{children:"HEAD"}),"后面",(0,i.jsx)(c.code,{children:"^"}),"的个数表示回退的版本的个数，比如， ",(0,i.jsx)(c.code,{children:"HEAD^^"}),"就表示上上个版本。"]}),"\n",(0,i.jsxs)(c.li,{children:["推送命令",(0,i.jsx)(c.code,{children:"git push -u aaa bbb"})," 将本地仓库的代码推送到远端，其中 aaa 表示远程仓库，bbb 表示本地分支。其实，当我们已经提交过一次之后，我们就可以不再输入",(0,i.jsx)(c.code,{children:"aaa bbb"}),"，而是直接使用",(0,i.jsx)(c.code,{children:"git push -u"}),"即可。"]}),"\n",(0,i.jsxs)(c.li,{children:["拉取命令",(0,i.jsx)(c.code,{children:"git fetch"}),"，拉取远程仓库的代码到本地。"]}),"\n",(0,i.jsxs)(c.li,{children:["合并命令",(0,i.jsx)(c.code,{children:"git merge aaa"}),"，将当前分支的代码和 aaa 分支的代码合并，当然可能会出现冲突。"]}),"\n",(0,i.jsxs)(c.li,{children:["查看命令",(0,i.jsx)(c.code,{children:"git diff"}),"，对比当前分支和合并分支的异同点。"]}),"\n",(0,i.jsxs)(c.li,{children:["拉取合并命令",(0,i.jsx)(c.code,{children:"git pull"}),"，将远端仓库的代码拉取到本地并合并，等价于同时执行了",(0,i.jsx)(c.code,{children:"git fetch"}),"和",(0,i.jsx)(c.code,{children:"git merge"}),"。"]}),"\n",(0,i.jsxs)(c.li,{children:["查看状态命令",(0,i.jsx)(c.code,{children:"git status"}),"，用得最频繁的一个命令，用来查看当前目录的状态。"]}),"\n"]}),"\n",(0,i.jsx)(c.p,{children:"接下来，我们就来看看分支命令："}),"\n",(0,i.jsxs)(c.ul,{children:["\n",(0,i.jsxs)(c.li,{children:["新建分支 ",(0,i.jsx)(c.code,{children:"git branch -xxx"}),"，从当前分支新建一个分支 xxx。"]}),"\n",(0,i.jsxs)(c.li,{children:["切换分支 ",(0,i.jsx)(c.code,{children:"git checkout xxx"}),"，从当前分支切换到 xxx 分支。"]}),"\n",(0,i.jsxs)(c.li,{children:["从当前分支检出新分支：",(0,i.jsx)(c.code,{children:"git checkout -b xxxx"}),"，xxx 是分支名，",(0,i.jsx)(c.code,{children:"b"}),"是 branch 的简写，就表示分支，这其实就等于先新建分支，然后切换到新分支，等于同时执行了",(0,i.jsx)(c.code,{children:"git branch -xxx"}),"和",(0,i.jsx)(c.code,{children:"git checkout xxx"}),"这两条指令。"]}),"\n",(0,i.jsxs)(c.li,{children:["合并分支 ",(0,i.jsx)(c.code,{children:"git merge xxx"}),"，将当前分支和 xxx 分支合并。"]}),"\n",(0,i.jsxs)(c.li,{children:["删除分支 ",(0,i.jsx)(c.code,{children:"git branch -d xxx"}),"，将 xxx 分支删除。"]}),"\n",(0,i.jsxs)(c.li,{children:["查看分支 ",(0,i.jsx)(c.code,{children:"git branch"}),"，会列出本地的所有分支，如果加上参数",(0,i.jsx)(c.code,{children:"-a"}),"，就会列出本地和远端的所有分支。如果加上参数",(0,i.jsx)(c.code,{children:"-v"}),"，就会看到所有分支的最新一次的提交信息。"]}),"\n"]}),"\n",(0,i.jsxs)(c.p,{children:["最后，也是我们最需要的，就是",(0,i.jsx)(c.code,{children:"log"}),"命令："]}),"\n",(0,i.jsxs)(c.ul,{children:["\n",(0,i.jsxs)(c.li,{children:["查看提交记录 ",(0,i.jsx)(c.code,{children:"git log"}),"。"]}),"\n",(0,i.jsxs)(c.li,{children:["查看最近的 3 次提交 ",(0,i.jsx)(c.code,{children:"git log -p -3"}),"，其中",(0,i.jsx)(c.code,{children:"p"}),"表示",(0,i.jsx)(c.code,{children:"param"}),"，也就是参数的意思。"]}),"\n",(0,i.jsxs)(c.li,{children:["单行展示提交信息 ",(0,i.jsx)(c.code,{children:"git log --pretty=oneline"}),"。"]}),"\n",(0,i.jsxs)(c.li,{children:["格式化展示提交记录 ",(0,i.jsx)(c.code,{children:"git log --pretty=format"}),"。"]}),"\n",(0,i.jsxs)(c.li,{children:["以图表形式查看提交记录 ",(0,i.jsx)(c.code,{children:"git log --graph"}),"。"]}),"\n"]}),"\n",(0,i.jsx)(c.p,{children:"以上就是我们常用的命令，当然，git 有很多命令，大家在工作中都可以搜索出来，我们这里就不再废话了。"}),"\n",(0,i.jsxs)(c.h2,{id:"git-分支",children:["git 分支",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#git-分支",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"终于到了分支的部分了，其实，git 最重要的就是分支，如果没有分支，git 的存在也就没有什么意义了。"}),"\n",(0,i.jsx)(c.p,{children:"那么，什么是分支呢？"}),"\n",(0,i.jsxs)(c.p,{children:["我们可以这么理解，我们的代码就像是向上生长的树，我们刚开始的代码就是树干，也就是",(0,i.jsx)(c.code,{children:"master"}),"分支，随着时间的推移，我们开发了很多版本，就像树干生出了很多树枝，也就是",(0,i.jsx)(c.code,{children:"master"}),"分支生出了很多很多的分支，这个时候，我们想要回到之前的某个版本上，我们直接切换到那个分支即可。"]}),"\n",(0,i.jsx)(c.p,{children:"到这里，你应该明白了，分支就是一个个的代码版本，随着时间的推移，随着项目的发版和迭代，我们就拥有不同版本对应的不同代码，那么，每一个版本对应的代码都应该是一个分支。"}),"\n",(0,i.jsx)(c.p,{children:"我们可以在分支之间切换，也就是回到不同版本的代码上去。"}),"\n",(0,i.jsx)(c.p,{children:"好，我们就来实际操作一下。"}),"\n",(0,i.jsxs)(c.p,{children:["首先打开我们上一章的",(0,i.jsx)(c.code,{children:"helloworld"}),"项目，我们默认就是在",(0,i.jsx)(c.code,{children:"master"}),"分支，现在，让我们从",(0,i.jsx)(c.code,{children:"master"}),"分支创建一个新分支",(0,i.jsx)(c.code,{children:"test_branch1"}),"出来，我们直接执行",(0,i.jsx)(c.code,{children:"git checkout -b test_branch1"}),"即可，根据前面的命令，我们知道这是创建一个新分支并切换到这个分支。如果你想用",(0,i.jsx)(c.code,{children:"sourcetree"}),"，你就直接点击顶部的“",(0,i.jsx)(c.strong,{children:"分支"}),"”。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["然后就回弹出如下一个创建新分支的提示框，直接输入",(0,i.jsx)(c.code,{children:"test_branch1"}),"然后点击“",(0,i.jsx)(c.strong,{children:"创建分支"}),"”即可。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["这样，我们就创建出了一个新分支，我们直接执行",(0,i.jsx)(c.code,{children:"git status"}),"，发现打印如下:"]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{children:"On branch test_branch1\nnothing to commit, working tree clean\n"})}),"\n",(0,i.jsxs)(c.p,{children:["这就意味着我们已经在",(0,i.jsx)(c.code,{children:"test_branch1"}),"这个新分支上了。然后我们修改一下",(0,i.jsx)(c.code,{children:"hello.java"}),"这个文件，添加一行文字",(0,i.jsx)(c.code,{children:"hello git"}),"，然后提交一下。这样，我们的",(0,i.jsx)(c.code,{children:"test_branch1"}),"分支上的",(0,i.jsx)(c.code,{children:"hello.java"}),"就是带有",(0,i.jsx)(c.code,{children:"hello git"}),"的，我们的",(0,i.jsx)(c.code,{children:"master"}),"分支上的",(0,i.jsx)(c.code,{children:"hello.java"}),"就是不带",(0,i.jsx)(c.code,{children:"hello git"}),"的，我们可以切回到",(0,i.jsx)(c.code,{children:"master"}),"分支验证一下。"]}),"\n",(0,i.jsxs)(c.p,{children:["那么，如果将来有一天，我想让",(0,i.jsx)(c.code,{children:"master"}),"分支也跟",(0,i.jsx)(c.code,{children:"test_branch1"}),"分支一样，都带有",(0,i.jsx)(c.code,{children:"hello git"}),"的话，该怎么办呢？"]}),"\n",(0,i.jsxs)(c.p,{children:["这就要说到分支的合并了，我们直接切到",(0,i.jsx)(c.code,{children:"master"}),"分支，然后执行",(0,i.jsx)(c.code,{children:"git merge test_branch1"}),"，这样，就会将",(0,i.jsx)(c.code,{children:"test_branch1"}),"上的提交合并到当前的",(0,i.jsx)(c.code,{children:"master"}),"分支，如果我们没有针对同一个文件做修改，那么",(0,i.jsx)(c.code,{children:"git"}),"会自动将所有的文件进行合并，如果我们对同一个文件做了修改，那么就会出现冲突，这个时候我们就需要手动解决下冲突了。"]}),"\n",(0,i.jsxs)(c.p,{children:["好，我们切换到",(0,i.jsx)(c.code,{children:"master"}),"分支，在",(0,i.jsx)(c.code,{children:"hello.java"}),"中添加一行文字",(0,i.jsx)(c.code,{children:"hello git2"}),"，然后提交一下。"]}),"\n",(0,i.jsxs)(c.p,{children:["此时，我们的",(0,i.jsx)(c.code,{children:"master"}),"分支是",(0,i.jsx)(c.code,{children:"hello git2"}),"，我们的",(0,i.jsx)(c.code,{children:"test_branch1"}),"分支是",(0,i.jsx)(c.code,{children:"hello git"}),"，它们自己分别有改动，并且是针对同一个文件的，那么，现在我们让",(0,i.jsx)(c.code,{children:"master"}),"分支合并一下",(0,i.jsx)(c.code,{children:"test_branch1"}),"分支，我们直接执行命令:",(0,i.jsx)(c.code,{children:"git merge test_branch1"}),"，或者在",(0,i.jsx)(c.code,{children:"sourcetree"}),"上执行如下操作。"]}),"\n",(0,i.jsxs)(c.p,{children:["先选择顶部的“",(0,i.jsx)(c.strong,{children:"合并"}),"”："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["然后在弹出框中选择“",(0,i.jsx)(c.strong,{children:"合并已抓取"}),"”，并选择",(0,i.jsx)(c.code,{children:"origin/test_branch1"}),"分支（如果没有这个分支，就是没有 push，push 下就可以了）："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,i.jsx)(c.p,{children:"此时，我们就会发现合并冲突，因为我们两个分支都修改了同一个文件，如下："}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{children:"Auto-merging hello.java\nCONFLICT (content): Merge conflict in hello.java\nAutomatic merge failed; fix conflicts and then commit the result.\n"})}),"\n",(0,i.jsxs)(c.p,{children:["此时，我们打开",(0,i.jsx)(c.code,{children:"sourcetree"}),"，选择文件状态，就会看到文件被标记为感叹号，并且右边列出了冲突的内容："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["其中，感叹号表示冲突，右边的",(0,i.jsx)(c.code,{children:"<<<HEAD"}),"和",(0,i.jsx)(c.code,{children:"====="}),"之间的内容表示",(0,i.jsx)(c.strong,{children:"当前分支的改动"}),"，而",(0,i.jsx)(c.code,{children:"====="}),"和",(0,i.jsx)(c.code,{children:">>>>>"}),"之间的内容表示",(0,i.jsx)(c.strong,{children:"合并的分支的改动"}),"，这里我们要手动处理下，我们把两行都保留即可，然后把",(0,i.jsx)(c.code,{children:"===="}),"和",(0,i.jsx)(c.code,{children:">>>"}),"以及",(0,i.jsx)(c.code,{children:"<<<<"}),"删除即可，如下："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,i.jsxs)(c.p,{children:["可以看到，它告诉我们本次修改添加了一行",(0,i.jsx)(c.code,{children:"hello git"}),"，我们注意到",(0,i.jsx)(c.code,{children:"hello.java"}),"还是带有感叹号，这就需要我们手动把文件标记为",(0,i.jsx)(c.strong,{children:"已解决"}),"了，我们选中文件，右键点击，然后选择",(0,i.jsx)(c.strong,{children:"解决冲突"})," -> ",(0,i.jsx)(c.strong,{children:"标记为已解决"}),"。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,i.jsx)(c.p,{children:"这样，我们的一次合并就完成了。"}),"\n",(0,i.jsxs)(c.p,{children:["当然，如果两个分支没有修改同一个文件，那么",(0,i.jsx)(c.code,{children:"git"}),"就会直接把我们的代码自动合并，也就不会有上述处理冲突的过程了。所以，我们要尽量避免",(0,i.jsx)(c.strong,{children:"同时修改同一文件"}),"。"]}),"\n",(0,i.jsx)(c.p,{children:"怎么避免呢？那就要只添加不修改，遵循开放闭合原则，遵循 OCP 了。"}),"\n",(0,i.jsxs)(c.h2,{id:"总结",children:["总结",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["本章我们着重讲了",(0,i.jsx)(c.code,{children:"sourcetree"}),"的操作，以及一些终端命令，最后，我们讲了分支的概念、分支的合并和冲突的解决方式，我们再来回顾下："]}),"\n",(0,i.jsxs)(c.ul,{children:["\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.code,{children:"sourcetree"}),"提供了一个 GUI 用来操作 git，操作直观，查看文件很方便。"]}),"\n",(0,i.jsx)(c.li,{children:"终端命令不需要打开额外的软件，操作简便、高效、快速，但是不够直观，且不容易记忆。"}),"\n",(0,i.jsxs)(c.li,{children:["分支代表着",(0,i.jsx)(c.code,{children:"git"}),"的每个代码版本，我们可以切换不同的分支来回到历史版本。"]}),"\n",(0,i.jsx)(c.li,{children:"分支的合并可能会出现冲突，所以我们要尽量避免修改同一个文件。"}),"\n"]}),"\n",(0,i.jsxs)(c.p,{children:["最后，在这里，我要鼓励下我们每个人多使用终端命令，或者说，我们对",(0,i.jsx)(c.code,{children:"git"}),"的日常操作尽量用命令，只要合并不冲突，就尽量使用命令；当合并冲突的时候，再使用",(0,i.jsx)(c.code,{children:"sourcetree"}),"等可视化工具来对比差异，从而进行修改。日久天长，锻炼的不仅仅是你的打字速度，同时也是你对",(0,i.jsx)(c.code,{children:"git"}),"系统的认识。到最后你会发现，原来我们的编辑器、我们的操作系统、我们的计算机，全部都是跑在一套套的命令里面的。"]}),"\n",(0,i.jsx)(c.p,{children:"这里我就不再废话了，本小册的所有技术层面的知识到这里就完事了，接下来的三个章节，我们就一起来返璞归真，大道至简，站在做人的层面来俯察下技术的真谛吧。"})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,d.ah)(),e.components);return c?(0,i.jsx)(c,{...e,children:(0,i.jsx)(w,{...e})}):w(e)}let B=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC31%E7%AB%A0%E2%80%94Git%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%B8%B8%E7%94%A8%E7%9A%84GUI%E5%B7%A5%E5%85%B7%E5%92%8C%E5%91%BD%E4%BB%A4.md"]={toc:[{text:"SourceTree",id:"sourcetree",depth:2},{text:"终端命令",id:"终端命令",depth:2},{text:"git 分支",id:"git-分支",depth:2},{text:"总结",id:"总结",depth:2}],title:"第31章—Git实践：常用的GUI工具和命令",headingTitle:"第31章—Git实践：常用的GUI工具和命令",frontmatter:{}}}}]);