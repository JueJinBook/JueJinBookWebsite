"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57843"],{173004:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var s=r(552676),t=r(740453);let c=r.p+"static/image/b58260bdfc9febe2378df4cdf747a150.696f0bfa.webp",d=r.p+"static/image/b9c090989734068b6f6f46bf7faa18b9.3e5146d8.webp",i=r.p+"static/image/2599ef69ce1a3e0e1e190bc91f9094a5.75ba899e.webp";function l(e){let n=Object.assign({p:"p",code:"code",ol:"ol",li:"li",blockquote:"blockquote",img:"img",h1:"h1",a:"a",pre:"pre",h2:"h2",h3:"h3",ul:"ul",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"经过几节的练习，我们已经学习了如何开发一个自定义 Hooks，但如果说把我们写的 Hooks 弄成开源，那么还差一步，就是：单元测试（单元测试：指的是以原件的单元为单位，对软件进行测试）。"}),"\n",(0,s.jsxs)(n.p,{children:["其中",(0,s.jsx)(n.code,{children:"单元"}),"可以是",(0,s.jsx)(n.code,{children:"一个函数"}),"，也可以是",(0,s.jsx)(n.code,{children:"一个模块"}),"或",(0,s.jsx)(n.code,{children:"一个组件"}),"，基本特征就是只要输入不变，必定返回同样的输出。同时，如果一个软件越容易写单元测试，就表明它的模块化结构越好，各模块之间的耦合越弱。"]}),"\n",(0,s.jsx)(n.p,{children:"单元测试的好处："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["保质保量：单元测试可以有效减少 ",(0,s.jsx)(n.code,{children:"bug 率"}),"，虽然 ",(0,s.jsx)(n.code,{children:"bug"})," 我们无法避免，但没有人想 ",(0,s.jsx)(n.code,{children:"bug"})," 多，单元测试会让我们不得不去思考一些异常场景，这样在无形之中，增强了代码的质量；"]}),"\n",(0,s.jsx)(n.li,{children:"提升个人实力：单元测试可以算是一个单独的领域，不同的框架需要不同的配置，其次，不同的环境也会引起一定的冲突，如何模拟各场景，不同环境的 Mock 能力，都是值得我们去研究的点；"}),"\n",(0,s.jsx)(n.li,{children:"描述代码：对现有的代码进行描述，也就是将用例作为记录。单元测试会对各种环境进行模拟，如果单元测试写得好，他人完全可以看单元测试去了解组件的意义。"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"问：单元测试在工作中能够使用到吗？"}),"\n",(0,s.jsx)(n.p,{children:"答：如果你开发业务代码，基本上不会要求有单元测试，因为写单元测试的时间有可能高于你写业务逻辑的时间，但如果想要进阶，之后写开源产品，进入架构层，那么单元测试则是不可缺少的。"}),"\n",(0,s.jsx)(n.p,{children:"因为我们这里主讲 Hooks，所以不会讲项目中如何配置 Jest，直接用 React v18 就可以满足测试条件，所有的概念，章节内容会配合自定义 Hooks 开讲，保证让你干货满满～"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(n.h1,{id:"5基础篇自定义-hooks-之-jest一如何测试自定义-hooks",children:["5.基础篇｜自定义 Hooks 之 Jest（一）：如何测试自定义 Hooks？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5基础篇自定义-hooks-之-jest一如何测试自定义-hooks",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们先写一个简单的求和函数，来看看是怎样的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'     // src/hooks/sum/index.ts \n     const sum = (a: number, b: number) => {\n      return a + b;\n    };\n\n    export default sum;\n\n    // src/hooks/sum/index.test.ts import sum from "./index";\n\n    describe("sum", () => {\n      it("求和：1 + 2 = 3", () => {\n        expect(sum(1, 2)).toEqual(3);\n      });\n    });\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"问：在测试文件中，使用了 describe、it 和 expect，没有引入，为什么可以使用？"}),"\n",(0,s.jsx)(n.p,{children:"答：实际上 Jest 会将这些方法和对象注入到测试文件的全局环境里，所以我们在使用的时候并不需要通过 import 或 require 导入。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"全局设定",children:["全局设定",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局设定",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 Jest 中，主要讲解下以下 6 种方法来帮助我们学习 Hooks，更多的方法还请参考：",(0,s.jsx)(n.a,{href:"https://jestjs.io/zh-Hans/docs/25.x/api",target:"_blank",rel:"noopener noreferrer",children:"Jest-全局设定"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"describe",children:["describe",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#describe",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"describe：描述块，将一组功能相关的测试用例组合在一块。"}),"\n",(0,s.jsxs)(n.p,{children:["用法：",(0,s.jsx)(n.code,{children:"describe(name, fn)"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"name：string，描述的话语；"}),"\n",(0,s.jsx)(n.li,{children:"fn：() => void，将所有的代码写到这个函数里即可。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"it",children:["it",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#it",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["it：别名",(0,s.jsx)(n.code,{children:"test"}),"，用来存放测试用例，可以说有几个 it 就会有几个测试用例。"]}),"\n",(0,s.jsxs)(n.p,{children:["用法：",(0,s.jsx)(n.code,{children:"it(name, fn, timeout)"})," 或 ",(0,s.jsx)(n.code,{children:"test(name, fn, timeout)"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"name：string，测试名称；"}),"\n",(0,s.jsx)(n.li,{children:"fn：() => void，包含测试期望的函数；"}),"\n",(0,s.jsxs)(n.li,{children:["timeout：number，默认：",(0,s.jsx)(n.code,{children:"5s"}),"，可选，测试的超时时间。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"afterall-和-beforeall",children:["afterAll 和 beforeAll",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#afterall-和-beforeall",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"afterAll：所有的测试用例执行完后执行的方法，如果传入的回调函数返回值是 promise 或者 generator，Jest 会等待 promise resolve 再继续执行。"}),"\n",(0,s.jsx)(n.p,{children:"beforeAll： 与 afterAll 相反， 所有的测试用例执行之前执行的方法。"}),"\n",(0,s.jsxs)(n.p,{children:["用法：",(0,s.jsx)(n.code,{children:"afterAll(fn, timeout)"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fn：() => void，执行的函数；"}),"\n",(0,s.jsxs)(n.li,{children:["timeout：number，默认：",(0,s.jsx)(n.code,{children:"5s"}),"，可选，测试的超时时间。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"aftereach-和-beforeeach",children:["afterEach 和 beforeEach",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#aftereach-和-beforeeach",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"afterEach：与 afterAll 相比，afterEach 可以在每个测试完成后都运行一遍。"}),"\n",(0,s.jsx)(n.p,{children:"beforeEach：beforeEach 可以在每个测试完成之前都运行一遍。"}),"\n",(0,s.jsxs)(n.p,{children:["用法：",(0,s.jsx)(n.code,{children:"afterEach(fn, timeout)"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fn：() => void，执行的函数；"}),"\n",(0,s.jsxs)(n.li,{children:["timeout：number，默认：",(0,s.jsx)(n.code,{children:"5s"}),"，可选，测试的超时时间。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"断言",children:["断言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#断言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["断言：Expect，我们在测试的时候常常需要判断，是否满足一个结果，比如像上面的 ",(0,s.jsx)(n.code,{children:"expect(sum(1, 2)).toEqual(3)"})," 就是为了验证，执行完 ",(0,s.jsx)(n.code,{children:"sum 函数"}),"后，结果是否等于 3。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来我们来看看一些常见的断言，详情：",(0,s.jsx)(n.a,{href:"https://jestjs.io/zh-Hans/docs/25.x/expect#expectvalue",target:"_blank",rel:"noopener noreferrer",children:"Expect 断言"}),"。"]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"基本断言"}),"\n",(0,s.jsx)(n.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"expect(value)"}),"\n",(0,s.jsx)(n.td,{children:"要测试一个值进行断言的时候，首先使用 expect 对值进行包裹"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"not"}),"\n",(0,s.jsx)(n.td,{children:"用于测试相反的结果，也就是不等于"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBeUndefined"}),"\n",(0,s.jsx)(n.td,{children:"用于检查变量是否未定义，也就是说，只会匹配 undefined，比如说上面的 sum 返回的结果明显不是 undefined，如果使用，则会报错"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBeDefined"}),"\n",(0,s.jsx)(n.td,{children:"与 toBeUndefined 相反，必须匹配有值的情况"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBe"}),"\n",(0,s.jsx)(n.td,{children:"使用 Object.is 来进行比较，严格的比较，需要注意的是，如果进行浮点数的比较，要使用 toBeCloseTo，可以理解为 ==="}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toEqual(value)"}),"\n",(0,s.jsx)(n.td,{children:"用于对象的深度，它一般比较的是对象的值，而并非对象本身"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toMatch(regexpOrString)"}),"\n",(0,s.jsx)(n.td,{children:"用来检查字符串是否匹配，可以是正则表达式或者字符串"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toContain(item)"}),"\n",(0,s.jsx)(n.td,{children:"用来判断 item 是否在一个数组中，也可以用于字符串的判断"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBeNull(value)"}),"\n",(0,s.jsx)(n.td,{children:"只匹配 null"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBeUndefined(value)"}),"\n",(0,s.jsx)(n.td,{children:"只匹配 undefined"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBeGreaterThan(number)"}),"\n",(0,s.jsx)(n.td,{children:"大于"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBeGreaterThanOrEqual(number)"}),"\n",(0,s.jsx)(n.td,{children:"大于等于"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBeLessThan(number)"}),"\n",(0,s.jsx)(n.td,{children:"小于"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"toBeLessThanOrEqual(number)"}),"\n",(0,s.jsx)(n.td,{children:"小于等于"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"覆盖率报告",children:["覆盖率报告",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#覆盖率报告",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["运行：",(0,s.jsx)(n.code,{children:"npm run test"})," 即可看到测试的结果，同时增加 ",(0,s.jsx)(n.code,{children:"--coverage"}),"，它可以帮助我们生成对应的覆盖率报告文件，为了效果更加明确，这里使用覆盖率文件的方式进行讲解。"]}),"\n",(0,s.jsxs)(n.p,{children:["会生成一个 coverage 文件（默认），这个文件包含很多种格式，如：",(0,s.jsx)(n.code,{children:"XML"}),"、",(0,s.jsx)(n.code,{children:"JSON"}),"、",(0,s.jsx)(n.code,{children:"HTML"})," 等，这里我们看 HTML 就可以了。"]}),"\n",(0,s.jsx)(n.p,{children:"当我们找到对应的 sum 文件，是这样的："}),"\n",(0,s.jsx)(n.p,{children:"终端上也是类似的样子，接下来看看四个字段分别是什么意思："}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"字段"}),"\n",(0,s.jsx)(n.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"Statements"}),"\n",(0,s.jsx)(n.td,{children:"语句覆盖率（statement coverage），是不是每个语句都执行"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"Branches"}),"\n",(0,s.jsx)(n.td,{children:"分支覆盖率（branch coverage），是不是每个 if 代码块都执行"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"Functions"}),"\n",(0,s.jsx)(n.td,{children:"函数覆盖率（function coverage)，是不是每个函数都调用"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"Lines"}),"\n",(0,s.jsx)(n.td,{children:"行覆盖率（line coverage)），是不是每一行都执行"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h1,{id:"测试自定义-hooks",children:["测试自定义 Hooks",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试自定义-hooks",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"自定义 Hooks 的本质是纯函数，那么我们可不可以用上述的方法去测试自定义 Hooks 呢？"}),"\n",(0,s.jsx)(n.p,{children:"先来尝试一下，创建一个简单的 Hooks：useCounter，里面有：增加、减少和设置三个功能。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'    import { useState } from "react";\n\n    const useCounter = (initialValue: number = 0) => {\n      const [current, setCurrent] = useState(initialValue);\n\n      const add = (number = 1) => setCurrent((v) => v + number);\n      const dec = (number = 1) => setCurrent((v) => v - number);\n      const set = (number = 1) => setCurrent(number);\n\n      return [\n        current,\n        {\n          add,\n          dec,\n          set,\n        },\n      ] as const;\n    };\n\n    export default useCounter;\n'})}),"\n",(0,s.jsx)(n.p,{children:"测试："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'    import useCounter from "./index";\n\n    describe("useCounter 测试", () => {\n      it("数字加1", () => {\n        const [counter, { add }] = useCounter(7);\n        expect(counter).toEqual(7);\n        add();\n        expect(counter).toEqual(8);\n      });\n    });\n'})}),"\n",(0,s.jsx)(n.p,{children:"这么一看似乎没什么问题，一开始是 7，触发 add 方法后，counter 变成 8，那么来看看 test 的结果："}),"\n",(0,s.jsx)(n.p,{children:"可是，此时却报错了，这是因为在 useCounter 中运用了 useState，但 useState 等 Hooks 只能在 React 中才行，在其他地方引用都会有这个问题，因此我们需要引入 renderHook 和 act 来解决测试问题。"}),"\n",(0,s.jsxs)(n.h2,{id:"renderhook",children:["renderHook",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#renderhook",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["renderHook：顾名思义，这个函数就是用来渲染 Hooks，它会帮助我们解决 Hooks 只能在组件中使用的问题（生成一个专门用来测试的 ",(0,s.jsx)(n.code,{children:"TestComponent"}),")。"]}),"\n",(0,s.jsx)(n.p,{children:"用法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"    function renderHook<Result, Props>(\n        render: (props: Props) => Result,\n        options?: RenderHookOptions<Props>,\n    ): RenderHookResult<Result, Props>\n"})}),"\n",(0,s.jsx)(n.p,{children:"入参："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"render： callBack 函数，这个函数会在 TestComponent 每次被重新渲染的时候调用，所以这个函数放入我们想测试的 Hooks 就行；"}),"\n",(0,s.jsx)(n.li,{children:"options：可选的 options，有两个属性，分别是 initialProps 和 wrapper。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"options 的参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"initialProps：TestComponent 初始的 props；"}),"\n",(0,s.jsxs)(n.li,{children:["wrapper：用来指定 TestComponent 的父级组件（Wrapper Component)，这个组件可以是一些 ",(0,s.jsx)(n.code,{children:"ContextProvider"})," 等用来为 TestComponent 的 Hooks 提供测试数据的东西。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"出参：renderHook，共返回三个参数，分别是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"result：结果，是一个对象结构，包含 current（保存 TestComponent 返回的 callback 值）和 error（所有错误存放的值）；"}),"\n",(0,s.jsx)(n.li,{children:"render：用来重新渲染 TestComponent，并且可以接受一个 newProps（参数）传递给 TestComponent；"}),"\n",(0,s.jsxs)(n.li,{children:["unmount：用来卸载 TestComponent，主要用来覆盖一些 ",(0,s.jsx)(n.code,{children:"useEffect cleanup"})," 函数的场景。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"act",children:["act",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#act",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"act：这个函数和 React 自带的 test-utils 的 act 函数是同一个函数，通过这个函数，我们可以将所有会更新到组件状态的操作封装在它的 callback 下，简单来说，我们如果对 TestComponent 有操作，改变 result 的值，就需要放到 act 下。"}),"\n",(0,s.jsxs)(n.h2,{id:"解决问题",children:["解决问题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解决问题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们用 rebderHook 和 act 来解决下问题："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'    import useCounter from "./index";\n    import { act, renderHook } from "@testing-library/react";\n\n    describe("useCounter 测试", () => {\n      it("数字加1", async () => {\n        const { result } = renderHook(() => useCounter(7));\n        expect(result.current[0]).toEqual(7);\n\n        act(() => {\n          result.current[1].add();\n        });\n\n        expect(result.current[0]).toEqual(8);\n      });\n    });\n'})}),"\n",(0,s.jsx)(n.p,{children:"结果："}),"\n",(0,s.jsx)(n.p,{children:"至于红色效果则代表代码没有执行，只要补齐相关代码即可，就能达到 100%。"}),"\n",(0,s.jsxs)(n.h1,{id:"dom-hooks-核心useeventlistener",children:["DOM Hooks 核心：useEventListener",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dom-hooks-核心useeventlistener",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"useEventListener：优雅地使用 addEventListener，帮助我们监听各种事件，如点击、键盘、滚动等。"}),"\n",(0,s.jsx)(n.p,{children:"分析：在 addEventListener 之上封装，也就是说这个钩子没有返参的情况，我们只需要考虑入参即可。"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["event 事件：需要告诉监听的是事件，如",(0,s.jsx)(n.code,{children:"click"}),"、",(0,s.jsx)(n.code,{children:"keydown"}),"；"]}),"\n",(0,s.jsx)(n.li,{children:"回调函数：监听后所执行的回调函数；"}),"\n",(0,s.jsx)(n.li,{children:"目标值：具体监听哪个节点的，还是全局的。"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"为了方便起见，这个 Hooks 就不写对应的 ts 了，因为这里面也会用到函数重载，代码过长不太方便查看。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'    import { useEffect } from "react";\n    import { useLatest } from "../";\n\n    const useEventListener = (\n      event: string,\n      handler: (...e: any) => void,\n      target?: any\n    ) => {\n      const handlerRef = useLatest(handler);\n\n      useEffect(() => {\n        // 支持useRef 和 DOM节点\n        let targetElement: any;\n        if (!target) {\n          targetElement = window;\n        } else if ("current" in target) {\n          targetElement = target.current;\n        } else {\n          targetElement = target;\n        }\n\n        //  防止没有 addEventListener 这个属性\n        if (!targetElement?.addEventListener) return;\n\n        const useEventListener = (event: Event) => {\n          return handlerRef.current(event);\n        };\n        targetElement.addEventListener(event, useEventListener);\n        return () => {\n          targetElement.removeEventListener(event, useEventListener);\n        };\n      }, [event, target]);\n    };\n\n    export default useEventListener;\n'})}),"\n",(0,s.jsx)(n.p,{children:"因为 useRef 的固定结构为 current，所以这里我们做个兼容，让它支持 useRef 和普通 DOM 传递的两种方式。"}),"\n",(0,s.jsxs)(n.h2,{id:"如何测试",children:["如何测试？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何测试",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们要测试 useEventListener，首先要创建一个 DOM 节点，然后模拟对应的点击事件。"}),"\n",(0,s.jsxs)(n.p,{children:["可以直接通过 ",(0,s.jsx)(n.code,{children:"document.createElement('div')"})," 来创建一个",(0,s.jsx)(n.code,{children:"div"}),"，并将它绑定在 ",(0,s.jsx)(n.code,{children:"body"})," 上，然后通过 useEventListener 来监听测试。如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'    import { renderHook } from "@testing-library/react";\n    import useEventListener from "./";\n\n    describe("useEventListener", () => {\n      it("should be defined", () => {\n        expect(useEventListener).toBeDefined();\n      });\n\n      let container: HTMLDivElement;\n\n      beforeEach(() => {\n        container = document.createElement("div"); // 创建一个div\n        document.body.appendChild(container);\n      });\n\n      afterEach(() => {\n        document.body.removeChild(container); // 卸载\n      });\n\n      it("测试监听点击事件", async () => {\n        let count: number = 0;\n        const onClick = () => {\n          count++;\n        };\n        const { rerender, unmount } = renderHook(() =>\n          useEventListener("click", onClick, container)\n        );\n\n        document.body.click(); // 点击 document应该无效\n        expect(count).toEqual(0);\n        container.click(); // 点击 container count + 1\n        expect(count).toEqual(1);\n        rerender(); // 重新渲染\n        container.click(); // 点击 container count + 1\n        expect(count).toEqual(2);\n        unmount(); // 卸载\n        container.click(); // 点击 container 应该无效\n        expect(count).toEqual(2);\n      });\n    });\n'})}),"\n",(0,s.jsx)(n.p,{children:"大概解释下步骤："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"通过 beforeEach 和 afterEach 创建 DOM 元素（container）并卸载；"}),"\n",(0,s.jsxs)(n.li,{children:["用 renderHook 监听对应的元素的点击事件，如果点击了，",(0,s.jsx)(n.code,{children:"count + 1"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["首先在 body 上进行点击，不应该触发 click 事件，",(0,s.jsx)(n.code,{children:"count = 0"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["然后点击 container，触发 click 事件，",(0,s.jsx)(n.code,{children:"count = 1"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["通过 rerender() 将 Hooks 重新渲染一遍，再点 container，看看会不会有影响，此时会触发 ",(0,s.jsx)(n.code,{children:"click"})," 事件，",(0,s.jsx)(n.code,{children:"count = 2"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["最后 unmount 卸载函数，再点击 container，此时已经卸载，所以无法触发，触发 click 事件，count 应该等于",(0,s.jsx)(n.code,{children:"2"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"覆盖率报告："}),"\n",(0,s.jsxs)(n.h2,{id:"useref-解决",children:["useRef 解决",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useref-解决",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"    if ('current' in target) {\n       targetElement = target.current;\n    }\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们知道，上述代码是处理 useRef 对象的，那么我们在测试的时候是不是要利用 useRef 呢？再通过 ref 对象绑定到对应的 DOM 节点上？"}),"\n",(0,s.jsx)(n.p,{children:"实际上，并不用，因为我们 useRef 存储的对象都在 current 下，所以我们只需要进行对应的模拟就 OK 了。如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'      beforeEach(() => {\n        containerRef = {\n          current: {},\n        };\n      });\n      \n      it("测试监听点击事件", async () => {\n        let count: number = 0;\n        const onClick = () => {\n          count++;\n        };\n        renderHook(() => useEventListener("click", onClick, containerRef));\n\n        document.body.click();\n        expect(count).toEqual(0);\n      });\n'})}),"\n",(0,s.jsx)(n.p,{children:"其他的也是同理，这里就不再介绍了，当所有的条件都走完，就会到达 100%。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"其实单元测试并不需要严格去按程序固有的方式去测试，比如 useRef，我们只要模拟出对应的数据即可，无需在意其他。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"扩展useeffectwithtarget",children:["扩展：useEffectWithTarget",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展useeffectwithtarget",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"ahooks 源码中的 useEventListener 实现原理与上述讲的一样，但阅读后发现有一个 useEffectWithTarget，如："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那么 useEffectWithTarget 的作用是什么呢？"}),"\n",(0,s.jsxs)(n.p,{children:["通过对应的代码，我们看到这个方法基本就做了一件事，就是兼容 ",(0,s.jsx)(n.code,{children:"target"}),"，如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["那么为什么会多一个函数的呢？实际上是因为 SSR，SSR 的类型为 ",(0,s.jsx)(n.code,{children:"() => HTMLElement"}),"，但如果把函数作为 useEffect 的参数，此时就会当 deps 不存在，也就是有其他变量改变时，useEffect 都会执行。"]}),"\n",(0,s.jsx)(n.p,{children:"所以，为了全面支持 target 动态变化，才会有 useEffectWithTarget 的诞生～"}),"\n",(0,s.jsxs)(n.h1,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本节学习了有关单元测试的概念，知道测试普通函数与自定义 Hooks 的测试方法，当然本文并没有详细讲解 Jest，只是介绍 Jest 的使用，帮助我们更好地完善自定义 Hooks。"}),"\n",(0,s.jsx)(n.p,{children:"除此之外，我还希望大家注意以下几个问题："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["本文使用的 renderHook 直接从 ",(0,s.jsx)(n.code,{children:"@testing-library/react"})," 拿出的，这是因为 ",(0,s.jsx)(n.code,{children:"@testing-library/react@13.1.0"})," 以上，把 ",(0,s.jsx)(n.code,{children:"renderHook"})," 内置了，并且这个版本必须配合 React v18 使用，如果是 v18 以下的版本，可以使用 ",(0,s.jsx)(n.code,{children:"@testing-library/react-hooks"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["当我们自行配置环境的时候，要注意 Jest 本身的环境是 node，如果要配置成浏览器环境需要：",(0,s.jsx)(n.code,{children:'"testEnvironment": "jsdom"'}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["调试，我们在直接用 ",(0,s.jsx)(n.code,{children:"console.log"})," 打印数据的时候，是打印不出来的，必须使用 ",(0,s.jsx)(n.code,{children:"--debug"}),"，当然也可以直接使用 ",(0,s.jsx)(n.code,{children:"vscode"})," 的插件，这里只是为了效果更加好看，才用文件去看。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"本节所介绍的 useEventListener 是 DOM 类 Hooks 的核心 API，下一节我们将会围绕 useEventListener 介绍其他有关 DOM 类的 Hooks，包括如何测试页面的开启与关闭、网络等方面的测试。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}let h=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F5.%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%20Hooks%20%E4%B9%8B%20Jest%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E8%87%AA%E5%AE%9A%E4%B9%89%20Hooks%EF%BC%9F.md"]={toc:[{text:"全局设定",id:"全局设定",depth:2},{text:"describe",id:"describe",depth:3},{text:"it",id:"it",depth:3},{text:"afterAll 和 beforeAll",id:"afterall-和-beforeall",depth:3},{text:"afterEach 和 beforeEach",id:"aftereach-和-beforeeach",depth:3},{text:"断言",id:"断言",depth:2},{text:"覆盖率报告",id:"覆盖率报告",depth:2},{text:"renderHook",id:"renderhook",depth:2},{text:"act",id:"act",depth:2},{text:"解决问题",id:"解决问题",depth:2},{text:"如何测试？",id:"如何测试",depth:2},{text:"useRef 解决",id:"useref-解决",depth:2},{text:"扩展：useEffectWithTarget",id:"扩展useeffectwithtarget",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);