"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["8749"],{951868:function(e,n,t){t.r(n),t.d(n,{default:()=>l});var r=t(552676),s=t(740453);let o=t.p+"static/image/358cdc48dcd00e3a76bbaadef8b832d6.38e664ee.webp";function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",pre:"pre",code:"code",img:"img"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"33-实战使用-nodejs-实现蓝牙串口服务与蓝牙设备通信",children:["33 实战：使用 Node.js 实现蓝牙串口服务与蓝牙设备通信",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-实战使用-nodejs-实现蓝牙串口服务与蓝牙设备通信",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在上一节课，我们介绍了用 Web Bluetooth API 操作智能 LED 设备，这样的设备是低功耗蓝牙设备，一般支持 GATT 协议。接下来，我们了解另一类的蓝牙设备，它们不属于低功耗蓝牙设备，因此不采用 GATT 协议，通常使用蓝牙串口通讯协议（SPP）进行通讯。"}),"\n",(0,r.jsxs)(n.h2,{id:"spp-通讯协议与设备",children:["SPP 通讯协议与设备",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#spp-通讯协议与设备",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"SPP 协议是一种基于串口的蓝牙通讯协议，它的特点是："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"串口通讯协议，即数据以字节流的形式传输，没有数据帧的概念。"}),"\n",(0,r.jsx)(n.li,{children:"通讯速率较低，一般为 9600bps。"}),"\n",(0,r.jsx)(n.li,{children:"通讯距离较短，一般为 10 米以内。"}),"\n",(0,r.jsx)(n.li,{children:"通讯稳定性较高，一般不会出现数据丢失的情况。"}),"\n",(0,r.jsx)(n.li,{children:"通讯延迟较低，一般为 10ms 以内。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["一些智能设备采用这个协议，比较有意思的设备有 Divoom 系列的像素板设备。在本节课中，我们的例子选择 Divoom 的一款迷你像素屏音箱 ",(0,r.jsx)(n.a,{href:"https://divoom.com/products/divoom-ditooplus?variant=32038376210550",target:"_blank",rel:"noopener noreferrer",children:"Ditoo-Plus"})," 来作为测试设备。你可以在 Divoom 官网或者国内的电商平台上购买这个系列的产品，也可以购买 Divoom 其他系列（除了Pixoo64）的像素屏产品。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实现蓝牙-spp-服务",children:["实现蓝牙 SPP 服务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现蓝牙-spp-服务",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在这里，我们使用 ",(0,r.jsx)(n.a,{href:"https://github.com/tinyprinter/node-bluetooth-serial-port",target:"_blank",rel:"noopener noreferrer",children:"node-bluetooth-serial-port"})," 模块来搭建服务。"]}),"\n",(0,r.jsx)(n.p,{children:"服务器的实现比较简单，我们可以直接创建一个服务的实例："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"import BluetoothSerialPort from 'node-bluetooth-serial-port';\nconst server = new BluetoothSerialPort.BluetoothSerialPort();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后，我们可以通过",(0,r.jsx)(n.code,{children:"server.findSerialPortChannel"}),"方法来查找设备的通讯通道并建立连接："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"server.findSerialPortChannel(deviceMAC, (channel) => {\n \xa0// Connect to the device\n \xa0server.connect(deviceMAC, channel, () => {\n \xa0 \xa0// We connected, resolve\n \xa0 \xa0console.log('connected');\n  }, () => throw new Error('Cannot connect'));\n}, () => throw new Error('Not found'));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在连接成功后，我们可以通过",(0,r.jsx)(n.code,{children:"server.write"}),"方法来写入数据："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"server.write(buffer, (error, bytes) => {\n \xa0console.log('==>', error, buffer, bytes);\n \xa0if(error) {\n \xa0 \xa0console.error(error);\n \xa0 \xa0server.close(); // 断开连接\n  }\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"为了方便使用，我们可以将整个蓝牙串口通讯服务封装成一个类："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"import BluetoothSerialPort from 'node-bluetooth-serial-port';\nimport {stringToBuffer} from '../utils.js';\n​\nfunction Defer() {\n \xa0this.promise = new Promise((resolve, reject) => {\n \xa0 \xa0this.resolve = resolve;\n \xa0 \xa0this.reject = reject;\n  });\n}\n​\nfunction sleep(ms) {\n \xa0return new Promise(resolve => setTimeout(resolve, ms));\n}\n​\nexport class Bluetooth {\n \xa0constructor({deviceMAC, connectionTimeout, maxConnectAttempts, connectionAttemptDelay}) {\n \xa0 \xa0this._config = {deviceMAC, connectionTimeout, maxConnectAttempts, connectionAttemptDelay};\n \xa0 \xa0this._dataBuffer = [];\n \xa0 \xa0this.server = new BluetoothSerialPort.BluetoothSerialPort();\n  }\n​\n \xa0async connect(times = this._config.maxConnectAttempts) {\n \xa0 \xa0const {connectionAttemptDelay} = this._config;\n \xa0 \xa0let attempts = 0;\n \xa0 \xa0for(let i = 0; i < times; i += 1) {\n \xa0 \xa0 \xa0try {\n \xa0 \xa0 \xa0 \xa0console.log('connection attempt %d/%d', attempts, times);\n \xa0 \xa0 \xa0 \xa0// eslint-disable-next-line no-await-in-loop\n \xa0 \xa0 \xa0 \xa0await this._connect();\n \xa0 \xa0 \xa0 \xa0break;\n \xa0 \xa0  } catch (error) {\n \xa0 \xa0 \xa0 \xa0console.error('error', error.message);\n \xa0 \xa0 \xa0 \xa0attempts++;\n \xa0 \xa0 \xa0 \xa0// eslint-disable-next-line no-await-in-loop\n \xa0 \xa0 \xa0 \xa0await sleep(connectionAttemptDelay);\n \xa0 \xa0  }\n \xa0  }\n \xa0 \xa0await sleep(500); // wait for device ready\n \xa0 \xa0return this.server;\n  }\n​\n \xa0_connect() {\n \xa0 \xa0const {deviceMAC, connectionTimeout} = this._config;\n \xa0 \xa0const server = this.server;\n \xa0 \xa0return new Promise((resolve, reject) => {\n \xa0 \xa0 \xa0// Find the device\n \xa0 \xa0 \xa0setTimeout(() => {\n \xa0 \xa0 \xa0 \xa0reject(new Error('Connection timeout'));\n \xa0 \xa0  }, connectionTimeout);\n​\n \xa0 \xa0 \xa0server.findSerialPortChannel(deviceMAC, (channel) => {\n \xa0 \xa0 \xa0 \xa0// Connect to the device\n \xa0 \xa0 \xa0 \xa0server.connect(deviceMAC, channel, () => {\n \xa0 \xa0 \xa0 \xa0 \xa0// We connected, resolve\n \xa0 \xa0 \xa0 \xa0 \xa0resolve(server);\n \xa0 \xa0 \xa0  }, () => reject(new Error('Cannot connect')));\n \xa0 \xa0  }, () => reject(new Error('Not found')));\n \xa0  });\n  }\n​\n \xa0/**\n \xa0 * Write a buffer to the device\n \xa0 */\n \xa0write(buffer) {\n \xa0 \xa0const server = this.server;\n \xa0 \xa0return new Promise((resolve, reject) => {\n \xa0 \xa0 \xa0server.write(buffer, (error, bytes) => {\n \xa0 \xa0 \xa0 \xa0console.log('==>', error, buffer, bytes);\n \xa0 \xa0 \xa0 \xa0if(error) {\n \xa0 \xa0 \xa0 \xa0 \xa0server.close(); // 重新连接\n \xa0 \xa0 \xa0 \xa0 \xa0this.connect(1000).then(() => {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0console.log('reconnected!');\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0this.write(buffer);\n \xa0 \xa0 \xa0 \xa0  });\n \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0return error ? reject(error) : resolve(bytes);\n \xa0 \xa0  });\n \xa0  });\n  }\n​\n \xa0async writeMessage(command) {\n \xa0 \xa0const buffers = stringToBuffer(command);\n \xa0 \xa0const status = [];\n​\n \xa0 \xa0const len = this._dataBuffer.length;\n \xa0 \xa0this._dataBuffer.push(...buffers);\n​\n \xa0 \xa0if(len === 0) {\n \xa0 \xa0 \xa0this._defer = new Defer();\n \xa0 \xa0 \xa0// eslint-disable-next-line no-restricted-syntax\n \xa0 \xa0 \xa0do {\n \xa0 \xa0 \xa0 \xa0const buffer = this._dataBuffer.shift();\n \xa0 \xa0 \xa0 \xa0// eslint-disable-next-line no-await-in-loop\n \xa0 \xa0 \xa0 \xa0status.push(await this.write(buffer));\n \xa0 \xa0  } while(this._dataBuffer.length > 0);\n \xa0 \xa0 \xa0this._defer.resolve();\n \xa0 \xa0 \xa0this._defer = null;\n \xa0  } else {\n \xa0 \xa0 \xa0await this._defer.promise;\n \xa0  }\n​\n \xa0 \xa0return status;\n  }\n​\n \xa0async disconnect() {\n \xa0 \xa0if(this._defer) await this._defer.promise;\n \xa0 \xa0this.server.close();\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"整个类的代码不是特别复杂，但有几个细节点需要注意一下。"}),"\n",(0,r.jsxs)(n.p,{children:["首先，蓝牙连接建立的时候不一定能保证成功，发现设备信道的成功率取决于设备的信号频率和距离等等因素。所以我们需要设置一个重试次数，如果重试次数用完还是没有成功，那么我们就抛出异常。在建立单次连接的时候，我们设置一个超时的时间，如果连接超时，那么等待一个重试间隔时间后再次尝试连接。在这里我们用",(0,r.jsx)(n.code,{children:"_connect"}),"来实现单次ci连接，然后在",(0,r.jsx)(n.code,{children:"connect"}),"方法中进行重试。"]}),"\n",(0,r.jsxs)(n.p,{children:["其次，我们需要保证数据的顺序性，然后在上一次数据发送完成后再发送下一次数据。这里我们在",(0,r.jsx)(n.code,{children:"writeMessage"}),"方法中使用了一个",(0,r.jsx)(n.code,{children:"_defer"}),"来实现这个功能，",(0,r.jsx)(n.code,{children:"writeMessage"}),"方法可以向设备发送字符串数据，当我们发送数据的时候，如果缓冲区中有数据，那么我们就等待上一次数据发送完成后再发送下一次数据。之所以这样设计，是因为在后续的章节中我们会实现一组 HTTP 接口，通过 HTTP 请求来转发数据给设备，这样我们就可以通过 HTTP 请求来控制设备了。但是，当我们通过 HTTP 请求发送数据的时候，我们有可能同时发起多次请求，那就需要将这些数据按照顺序发送给设备，所以我们还需要一个缓冲区来存储数据，再通过",(0,r.jsx)(n.code,{children:"_defer"}),"保证数据的顺序发送。"]}),"\n",(0,r.jsxs)(n.p,{children:["最后，我们在发送数据的时候，有可能出现连接错误。因此，如果数据发送失败，我们就重新建立连接，然后再发送数据。这里我们在",(0,r.jsx)(n.code,{children:"write"}),"方法里使用了",(0,r.jsx)(n.code,{children:"server.close"}),"方法来断开连接，然后再次调用",(0,r.jsx)(n.code,{children:"connect"}),"方法来重新建立连接。"]}),"\n",(0,r.jsx)(n.p,{children:"这样我们就实现了一个简单的蓝牙串口服务，我们可以通过这个服务连接设备的MAC地址来控制设备。"}),"\n",(0,r.jsxs)(n.h2,{id:"向设备发送数据",children:["向设备发送数据",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#向设备发送数据",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来，我们通过操控实际的设备来测试一下我们的蓝牙串口服务。"}),"\n",(0,r.jsx)(n.p,{children:"向具体的设备发送数据之前，我们必须根据设备的协议来构造正确的数据。"}),"\n",(0,r.jsxs)(n.p,{children:["Divoom 设备的协议有一个开放的文档，我们可以通过",(0,r.jsx)(n.a,{href:"https://github.com/RomRider/node-divoom-timebox-evo/blob/master/PROTOCOL.md",target:"_blank",rel:"noopener noreferrer",children:"这个文档"}),"来构造正确的数据。"]}),"\n",(0,r.jsx)(n.p,{children:"简单来说，Divoom 的协议是这样的格式："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"01 LLLL PAYLOAD CRCR 02"})}),"\n",(0,r.jsxs)(n.p,{children:["其中数据以 01 开头，02 结尾，中间的数据是",(0,r.jsx)(n.code,{children:"PAYLOAD"}),"，",(0,r.jsx)(n.code,{children:"PAYLOAD"}),"的长度是",(0,r.jsx)(n.code,{children:"LLLL"}),"，而",(0,r.jsx)(n.code,{children:"CRCR"}),"是",(0,r.jsx)(n.code,{children:"PAYLOAD"}),"的 CRC 校验码。"]}),"\n",(0,r.jsx)(n.p,{children:"根据这个协议，我设计一个类来编码构造正确的数据："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"​\n// https://github.com/RomRider/node-divoom-timebox-evo/blob/master/PROTOCOL.md\nfunction int2hexlittle(value) {\n \xa0if(value > 65535 || value < 0) {\n \xa0 \xa0throw new TypeError('int2hexlittle only supports value between 0 and 65535');\n  }\n \xa0const byte1 = (value & 0xFF).toString(16).padStart(2, '0');\n \xa0const byte2 = ((value >> 8) & 0xFF).toString(16).padStart(2, '0');\n \xa0return `${byte1}${byte2}`;\n}\n​\nconst _START = '01';\nconst _END = '02';\n​\nexport class TimeboxEvoMessage {\n \xa0constructor(msg = '') {\n \xa0 \xa0this._message = null;\n \xa0 \xa0this.append(msg);\n  }\n​\n \xa0_calcCRC() {\n \xa0 \xa0if(!this._message) return undefined;\n \xa0 \xa0const msg = this.lengthHS + this._message;\n \xa0 \xa0let sum = 0;\n \xa0 \xa0for(let i = 0, l = msg.length; i < l; i += 2) {\n \xa0 \xa0 \xa0sum += parseInt(msg.substr(i, 2), 16);\n \xa0  }\n \xa0 \xa0return sum % 65536;\n  }\n​\n \xa0get crc() {\n \xa0 \xa0if(!this._message) return undefined;\n \xa0 \xa0return this._calcCRC();\n  }\n​\n \xa0get crcHS() {\n \xa0 \xa0if(!this._message) return undefined;\n \xa0 \xa0return int2hexlittle(this.crc);\n  }\n​\n \xa0get length() {\n \xa0 \xa0if(!this._message) return undefined;\n \xa0 \xa0return (this._message.length + 4) / 2;\n  }\n​\n \xa0get lengthHS() {\n \xa0 \xa0if(!this._message) return undefined;\n \xa0 \xa0return int2hexlittle(this.length);\n  }\n​\n \xa0get payload() {\n \xa0 \xa0return this._message;\n  }\n​\n \xa0set payload(payload) {\n \xa0 \xa0this._message = payload;\n  }\n​\n \xa0get message() {\n \xa0 \xa0if(!this._message) return undefined;\n \xa0 \xa0return _START + this.lengthHS + this._message + this.crcHS + _END;\n  }\n​\n \xa0append(msg) {\n \xa0 \xa0if(msg) {\n \xa0 \xa0 \xa0this._message = this._message ? this._message + msg.toLowerCase() : msg.toLowerCase();\n \xa0  }\n \xa0 \xa0return this;\n  }\n​\n \xa0prepend(msg) {\n \xa0 \xa0if(msg) {\n \xa0 \xa0 \xa0this._message = this._message ? msg.toLowerCase() + this._message : msg.toLowerCase();\n \xa0  }\n \xa0 \xa0return this;\n  }\n​\n \xa0toString() {\n \xa0 \xa0return this.message;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样，我们就可以通过这个类来构造正确的数据发送给设备了。"}),"\n",(0,r.jsxs)(n.h2,{id:"测试服务",children:["测试服务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试服务",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来，我们写一段简单的脚本来测试一下我们的服务。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"import {Bluetooth} from '../server/bluetooth/bluetooth.js';\nimport {TimeboxEvoMessage} from '../src/divoom/message.js';\n​\nconst config = {\n \xa0deviceMAC: '11:75:58:CE:DB:2F',\n \xa0maxConnectAttempts: 3,\n \xa0connectionAttemptDelay: 500,\n \xa0connectionTimeout: 10000,\n};\n​\nfunction sleep(ms) {\n \xa0return new Promise(resolve => setTimeout(resolve, ms));\n}\n​\nfunction randomColor() {\n \xa0const R = Math.floor(Math.random() * 255);\n \xa0const G = Math.floor(Math.random() * 255);\n \xa0const B = Math.floor(Math.random() * 255);\n \xa0return `${R.toString(16)}${G.toString(16)}${B.toString(16)}`;\n}\n​\n(async function () {\n \xa0const bluetooth = new Bluetooth(config);\n \xa0const connection = await bluetooth.connect();\n \xa0console.log('connected');\n​\n \xa0connection.on('data', (buffer) => {\n \xa0 \xa0const result = buffer.toString('hex');\n \xa0 \xa0console.log('<==', result);\n  });\n​\n \xa0process.on('SIGINT', async () => {\n \xa0 \xa0await bluetooth.disconnect();\n \xa0 \xa0console.log('disconnected');\n \xa0 \xa0process.exit(0);\n  });\n​\n \xa0while(1) {\n \xa0 \xa0const color = randomColor();\n \xa0 \xa0const message = `4501${color}500001000000`;\n \xa0 \xa0const payload = new TimeboxEvoMessage(message).message;\n \xa0 \xa0// eslint-disable-next-line no-await-in-loop\n \xa0 \xa0await bluetooth.writeMessage(payload);\n \xa0 \xa0// eslint-disable-next-line no-await-in-loop\n \xa0 \xa0await sleep(1000);\n  }\n}());\n"})}),"\n",(0,r.jsx)(n.p,{children:"这段脚本会不断向设备发送随机颜色的数据，来测试我们的服务。根据协议，4501 是设置颜色的指令，格式如下："}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"4501 RRGGBB BB TT PP 000000"}),"，其中",(0,r.jsx)(n.code,{children:"RRGGBB"}),"是颜色的 RGB 值，",(0,r.jsx)(n.code,{children:"BB"}),"是亮度，我们设置为",(0,r.jsx)(n.code,{children:"50"}),"，中等亮度，",(0,r.jsx)(n.code,{children:"TT"}),"是类型，这里我们设置为",(0,r.jsx)(n.code,{children:"00"}),"，表示纯色，",(0,r.jsx)(n.code,{children:"PP"}),"是强度，一般设置为",(0,r.jsx)(n.code,{children:"01"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["所以，最后我们需要发送的数据是",(0,r.jsx)(n.code,{children:"4501${color}500001000000"}),"，其中",(0,r.jsx)(n.code,{children:"color"}),"是随机颜色的 RGB 值，我们通过",(0,r.jsx)(n.code,{children:"randomColor"}),"方法来生成随机颜色。"]}),"\n",(0,r.jsxs)(n.p,{children:["这样，我们将上面这段代码保存为",(0,r.jsx)(n.code,{children:"test.js"}),"，然后执行",(0,r.jsx)(n.code,{children:"node test.js"}),"，就可以看到设备的颜色在不断的变化了，效果如下图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"Mar-15-2023 10-41-14.gif"})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节课我们通过一个例子，熟悉了 SPP 协议的蓝牙通讯服务的实现，以及如何通过蓝牙向设备发送数据。这里我们只是简单发送了颜色数据，实际上，我们还可以通过蓝牙向设备发送图片、文字，以此来实现更多的功能。"}),"\n",(0,r.jsx)(n.p,{children:"下一节课，我们将尝试把设备的蓝牙通讯服务通过 HTTP 接口暴露出来。这样，我们就可以在 Web 上通过 HTTP 接口来控制设备了。同时，我们也会封装和测试 Divoom 设备的更多功能，以实现更加有趣的效果。"})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F33%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BD%BF%E7%94%A8%20Node.js%20%E5%AE%9E%E7%8E%B0%E8%93%9D%E7%89%99%E4%B8%B2%E5%8F%A3%E6%9C%8D%E5%8A%A1%E4%B8%8E%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87%E9%80%9A%E4%BF%A1.md"]={toc:[{text:"SPP 通讯协议与设备",id:"spp-通讯协议与设备",depth:2},{text:"实现蓝牙 SPP 服务",id:"实现蓝牙-spp-服务",depth:2},{text:"向设备发送数据",id:"向设备发送数据",depth:2},{text:"测试服务",id:"测试服务",depth:2},{text:"小结",id:"小结",depth:2}],title:"33 实战：使用 Node.js 实现蓝牙串口服务与蓝牙设备通信",headingTitle:"33 实战：使用 Node.js 实现蓝牙串口服务与蓝牙设备通信",frontmatter:{}}}}]);