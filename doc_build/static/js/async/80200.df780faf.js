"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["80200"],{290106:function(n,e,r){r.r(e),r.d(e,{default:()=>d});var i=r(552676),l=r(740453);function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",h2:"h2",ul:"ul",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",pre:"pre",h3:"h3",blockquote:"blockquote"},(0,l.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"第04章代码的基元初识数据类型",children:["第04章—代码的基元：初识数据类型",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第04章代码的基元初识数据类型",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["\uFEFF前面说了，计算机是使用二进制保存所有数据的，那我们写代码的时候不可能全部用 0101 这样的方式去写，这样多费劲啊。所以，我们就在二进制的基础上，衍生出其他人能看懂的数据类型，然后用人能看懂的语言来操作这些数据类型，这种语言就叫做",(0,i.jsx)(e.code,{children:"高级语言"}),"。相应的，那些由 0101 组成的语言就叫做",(0,i.jsx)(e.code,{children:"机器语言"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"那么，由二进制衍生出的数据类型有哪些呢？"}),"\n",(0,i.jsxs)(e.p,{children:["我们可以将这些数据类型分为两大类，",(0,i.jsxs)(e.strong,{children:[(0,i.jsx)(e.code,{children:"值类型"}),"和",(0,i.jsx)(e.code,{children:"引用类型"})]}),"。"]}),"\n",(0,i.jsxs)(e.h2,{id:"值类型",children:["值类型",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#值类型",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"首先要说的，就是值类型，我们按照表示的范围可以划分为如下几种类型。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"比特类型（byte）：8 位二进制。"}),"\n",(0,i.jsx)(e.li,{children:"短整型（short int）：16 位二进制。"}),"\n",(0,i.jsx)(e.li,{children:"整型（int）：32 位二进制。"}),"\n",(0,i.jsx)(e.li,{children:"长整型（long）：64 位二进制。"}),"\n",(0,i.jsx)(e.li,{children:"布尔类型（boolean）：默认是使用 int 表示的，也就是 32 位二进制。"}),"\n",(0,i.jsx)(e.li,{children:"字符类型（char）：16 位二进制。"}),"\n",(0,i.jsx)(e.li,{children:"单精度浮点（float）：32 位二进制。"}),"\n",(0,i.jsx)(e.li,{children:"双精度浮点（double）64 位二进制。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"其中，我们将 8 位二进制称作一个字节，也就是 1byte，也就是: 1byte = 8bit，也就是 8 个二进制位；因为最高位要用来表示符号位，所以，1 个 byte 的大小范围就是 [$$-2^7$$ ~ $$2^7-1$$]。"}),"\n",(0,i.jsx)(e.p,{children:"在 Java 语言中，boolean 比较特殊，当它单独使用时，就是一个 int 的大小，也就是 4 个字节；当它用作数组元素使用，就只占用 1 个字节，这也是为什么很多服务器在定义数据时，将 boolean 定义为 1 和 0 的原因。"}),"\n",(0,i.jsx)(e.p,{children:"我们将上述描述整理下，如表格所示："}),"\n",(0,i.jsxs)(e.table,{children:["\n",(0,i.jsxs)(e.thead,{children:["\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.th,{align:"center",children:"类型"}),"\n",(0,i.jsx)(e.th,{align:"center",children:"大小（字节）"}),"\n",(0,i.jsx)(e.th,{align:"center",children:"位数"}),"\n",(0,i.jsx)(e.th,{align:"center",children:"默认值"}),"\n",(0,i.jsx)(e.th,{align:"center",children:"范围"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.tbody,{children:["\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{align:"center",children:"byte"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"1"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"8"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"0B"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"$$-2^7$$~$$2^7-1$$"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{align:"center",children:"short"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"2"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"16"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"0S"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"$$-2^{15}$$~$$2^{15}-1$$"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{align:"center",children:"int"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"4"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"32"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"0"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"$$-2^{31}$$~$$2^{31}-1$$"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{align:"center",children:"long"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"8"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"64"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"0L"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"$$-2^{63}$$~$$2^{63}-1$$"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{align:"center",children:"boolean"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"4(1)"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"32(8)"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"false"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"false/true"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{align:"center",children:"char"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"2"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"16"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"null"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"见 ASCII 码表"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{align:"center",children:"float"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"4"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"32"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"0.0f"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"+/-(1.4E-45~3.4E+38)"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{align:"center",children:"double"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"8"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"64"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"0.0"}),"\n",(0,i.jsx)(e.td,{align:"center",children:"+/-(4.9E-324~1.7E+308)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"这属于理解性知识，我们不用死记硬背，会查表即可。"}),"\n",(0,i.jsx)(e.p,{children:"不过有同学可能会有疑问了，一个 byte 明明是 8 位，最大应该是：1111 1111，应该是 $$2^8-1$$，就像 10 进制中，8 位数最大就是 9999 9999 一样啊，也就是 $$10^8-1$$。"}),"\n",(0,i.jsx)(e.p,{children:"不是这样的，因为你那个 9999 9999，并不是 8 位数，而是 9 位数，你还有个符号位呢，也就是 +9999 9999，而我们上一节说到，二进制中所有数据都用 0 和 1 表示，所以 8 位二进制最高位是符号位，也就是实际只有 7 位表示数据，所以最大就是 $$2^7-1$$。"}),"\n",(0,i.jsx)(e.p,{children:"那这也不对啊，最大是 $$2^7-1$$，最小不应该是 $$-2^7-1$$ 吗，怎么会是 $$-2^7$$ 呢？这样不就等于负数比正数多一个吗？"}),"\n",(0,i.jsx)(e.p,{children:"不，我们仔细想一下，负数范围为：$$-2^7$$ ~ -1，也就是共有 $$2^7$$ 个负数；正数范围为：1 ~ $$2^7-1$$，共有 $$2^7-1$$ 个，确实少一个。唉，0 呢？0 的符号位是 0，也算是正数，所以正数应该是：0 ~ $$2^7-1$$，也是 $$2^7$$ 个，跟负数总数是一样的。"}),"\n",(0,i.jsx)(e.p,{children:"上述表格中的浮点数，采用的是规格化计数法，比如单精度浮点型 float 的范围：\n1.4E-45 ~ 3.4E+38，其中 E 表示以 10 为底的指数，E 后面为 + 就表示正指数，- 就表示负指数；这个范围就是：最小是 1.4 乘以 10 的 -45 次方，最大是 3.4 乘以 10 的 38 次方。"}),"\n",(0,i.jsx)(e.p,{children:"对于浮点数，还有个精度失真问题，比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"float a = 0.11f;\nfloat b = 0.22f;\nprintln((a+b)==0.33);// 输出false\n"})}),"\n",(0,i.jsx)(e.p,{children:"结果是 0.11+0.22 并不等于 0.33；这么奇葩吗？这是因为计算机是使用二进制存放数据的。根本无法获取精确的小数，比如：0.1 用二进制怎么表示呢？$$\\frac{1}{2}$$ 是 0.5，大了；$$\\frac{1}{4}$$ 是 0.25，大了；$$\\frac{1}{8}$$ 是 0.125，大了；$$\\frac{1}{16}$$ 是 0.0625，小了，需要再加点更小的；以此类推，就像十进制永远表述不出来 $$\\frac{1}{3}$$ 一样，只能无限接近，就是不能精确等于。"}),"\n",(0,i.jsx)(e.p,{children:"所以，我们做数据敏感的项目时，要使用其他的 api，比如 BigDecimal。"}),"\n",(0,i.jsxs)(e.h2,{id:"引用类型",children:["引用类型",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#引用类型",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"引用类型有三大类：字符串（string）、数组（array）和对象。准确地说，字符串和数组也是对象，只不过比较特殊，这里单独拎出来照顾照顾。"}),"\n",(0,i.jsxs)(e.p,{children:["引用和值最大的",(0,i.jsx)(e.code,{children:"不同在于"}),"：值类型是实实在在的一个数值，而引用类型则指向内存中的一个地址，修改一个引用类型可能带来其他风险，所以我们要慎之又慎，为了彻底解决这个问题，很多高级语言中直接就在函数调用的时候，按值传递，也就是把引用类型变量拷贝一份作为参数传递，而不是直接传递原有的引用。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 值类型demo\nint a = 10;\nfunction(a);\nvoid function(int num) {\n   num = 11;\n}\nprintln(a); // a还是10，没变化\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 引用类型demo\nint[] nums = {1,2,3,4,5};\nfunction(nums);\nvoid function(int[] nums) {\n    nums[0] = 100;\n}\nprintln(nums[0]); // nums[0]不是1了，而是100了。\n"})}),"\n",(0,i.jsxs)(e.p,{children:["上述例子简单明了地讲解了值类型和引用类型的区别，所以我们要尽量小心地使用引用类型，",(0,i.jsx)(e.strong,{children:"其实只要你尽量少地修改参数即可避免这类问题"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:["这里还有个 tips：",(0,i.jsx)(e.strong,{children:"能声明为局部变量的就不要声明为成员变量，能声明为成员变量的尽量不要声明为全局变量"}),"。因为变量的范围越大，越有可能被修改，风险就越高，所以我们要坚持 ",(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.code,{children:"小范围优先原则"})}),"。"]}),"\n",(0,i.jsxs)(e.h3,{id:"字符串",children:["字符串",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#字符串",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"字符串是引用类型，但是编译器对其做了特殊处理，使其使用起来就像值类型，那么这是为什么呢？"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"很简单，就是为了不可变。"})}),"\n",(0,i.jsxs)(e.p,{children:["字符串是代码中使用最多的类型，",(0,i.jsx)(e.strong,{children:"如果所有的数据类型只能保留一个，那么这个类型肯定是字符串"}),"，看看 json 就知道了。"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"我们一定要像保护我方水晶一样保护我方字符串。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"所以，字符串这么重要，肯定要保证它是安全的，如果它是引用类型，那么就很容易被修改，所以编译器就把它特殊处理了下，使其使用起来就像一个值类型一样。你看 java 的 String 就是 final 的，不但不让你改，也不让你继承。"}),"\n",(0,i.jsx)(e.p,{children:"有人说这不对啊，String 是为了不可变，那么字符串执行自加运算是怎么执行的呢？\n比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'String a = "abc";\na+="def"; // 结果a就是abcdef了。\n'})}),"\n",(0,i.jsx)(e.p,{children:"这不就变了吗，是变了，但不是字符串对象变了，是 a 指向了另一个地址。\n说白了就是："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'String a = "abc"; // a执行内存地址001，001放的是"abc";\na+="def"; // a指向内存地址002，002放的是"abcdef"; 001放的还是"abc"; \n'})}),"\n",(0,i.jsx)(e.p,{children:'也就是说，a 指向了 "abcdef" 的内存地址而已，而原来存放 "abc" 的那个地址的值还是 "abc"，并没有变化。'}),"\n",(0,i.jsxs)(e.p,{children:["也就是说： ",(0,i.jsx)(e.strong,{children:"字符串每次相加都会创建新字符串对象"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"而我们知道，创建对象本来就是个高代价操作，所以要尽量避免频繁执行字符串的相加操作，比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'String name = "";\nfor(int i = 0; i < names.length; i++){\n    name+=names[i];\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"写这种代码的人，先拉出去批斗一顿再说。"}),"\n",(0,i.jsx)(e.p,{children:"那么，怎么办呢？也不能不加啊，可以用字符串提供的 API，比如 Java 中的 StringBuilder、StringBuffer （名字起得真好，简写就是国粹）。"}),"\n",(0,i.jsxs)(e.h3,{id:"数组",children:["数组",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数组",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"数组是比较特殊的引用类型，数组指向的是第一个元素在内存中的地址，而且数组是占用一块连续的内存空间，这样一来，我们只要知道第一个元素的位置，就可以根据数组存储的变量类型的大小，计算出数组中每个元素在内存中的地址了。很多高级语言就是利用这个特点，衍生出了顺序存储的可变长度的线性集合。"}),"\n",(0,i.jsx)(e.p,{children:"数组这么设计有个特点：快！非常快！"}),"\n",(0,i.jsxs)(e.p,{children:["比如： ",(0,i.jsx)(e.code,{children:"int[] nums = {1,2,3,4,5};"}),"，nums 就指向元素 1 在内存中的地址，假如 1 的地址是 0x0001，那么因为一个 int 占用 4 个 byte，元素 2 的地址就是 0x0005，元素 3 的地址就是 0x0009，依次类推。"]}),"\n",(0,i.jsx)(e.p,{children:"这样就导致我们只需要知道数组的地址，也就是第一个元素的地址，就能快速定位到第 n 个元素的地址，这也是数组可以根据下标访问元素的原因。"}),"\n",(0,i.jsx)(e.p,{children:"那要这么说的话，我全部用数组不就行了吗？"}),"\n",(0,i.jsx)(e.p,{children:"那可不行！因为数组这个特点必须要连续的内存空间，如果现在我的内存没有那么大一块连续的可咋整呢？那就不申请了吗？就像你要 100 亩连续的地皮，但是我在朝阳区有 30 亩，海淀区有 30 亩，昌平区有 40 亩；我怎么给你整呢？"}),"\n",(0,i.jsxs)(e.p,{children:["这就导致一个问题，数组对内存的要求太苛刻了，一旦存满了想扩容，就有可能扩容失败，所以它的缺点就是：",(0,i.jsx)(e.strong,{children:"内存要求高，扩展性差"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"所以，当你对随机访问要求不高的时候，尽量不选择数组，可以选择我们后面要讲的链表。"}),"\n",(0,i.jsxs)(e.h3,{id:"对象",children:["对象",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#对象",children:"#"})]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"普天之下，莫非类；率土之滨，莫非对象。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"世间万物皆是对象，自从我干了程序员之后，我发现我做任何事都要分好几步。"}),"\n",(0,i.jsx)(e.p,{children:"比如吃年夜饭的时候，我就说：第一步拿碗筷；第二步：盛饭；第三步：端桌子上；第四步：吃饭；第五步：收拾碗筷；第六步：端走；第七步：洗碗；第八步：收碗筷。并且一定要确保步骤是偶数的，因为这样才左右对称，才有完整的生命周期。"}),"\n",(0,i.jsxs)(e.p,{children:["在这 8 个步骤之中，碗筷和饭都是",(0,i.jsx)(e.code,{children:"对象"}),"，其中碗筷属于长生命周期的对象，随着我家的存在而存在，随着我家的消失而消失；而饭则属于短生命周期的对象，随着出锅而出生，随着被吃下去而消失。"]}),"\n",(0,i.jsx)(e.p,{children:"所以，任何对象都有它的生命周期；局部变量的生命周期，随着函数的调用出生，随着函数调用结束死亡。比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"fun userName() {\n    let user = new User(); // 对象出生\n    println(user.name);\n    return user.name; // 对象死亡\n}\n\nfun test(){\n    let name = userName();\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"这个很好理解，因为调用一个函数的时候，会将函数的数据读入内存，而调用完了，也就会把读入的数据清空。"}),"\n",(0,i.jsxs)(e.p,{children:["所以，我们给每个变量都定义了叫做",(0,i.jsx)(e.strong,{children:"作用域"}),"的东西，上述例子说白了就是：",(0,i.jsx)(e.strong,{children:"局部变量的作用域仅限于它所在的函数"}),"。一旦函数调用完毕，作用域结束，生命周期也走完了，就等于死亡了。"]}),"\n",(0,i.jsx)(e.p,{children:"还有一种可能，即使函数没走完，对象也可能死掉，比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"void test() {\n    Object obj = new User(); // 创建了一个User对象，并用obj这个引用指向它\n    obj = new String(); // 创建了一个String对象，并用obj这个引用指向它，此时User对象已经没有引用指向了。\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["在上述代码中，当执行完",(0,i.jsx)(e.code,{children:"obj = new String();"}),"之后，User 对象已经没有引用指向了，如果此时进行垃圾回收，那么就可以被回收掉，也就是死亡了。那么，这又是为啥呢？"]}),"\n",(0,i.jsxs)(e.p,{children:["其实我们全部可以概括为一点：",(0,i.jsx)(e.strong,{children:"一个对象是否可以被回收，取决于执行垃圾回收时它有没有被引用"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"第一个例子中因为函数调用完了，引用也不存在了，所以 User 没有被引用；第二个例子中虽然函数没执行完，但是引用指向了另一个对象，所以也导致 User 没有被引用。所以它们都会被回收，也就是被干掉。"}),"\n",(0,i.jsx)(e.p,{children:"有人说，我还记得有个置为 null 的，这跟上述的有什么区别？"}),"\n",(0,i.jsx)(e.p,{children:"没区别！因为 null 也是个对象，只不过是个名字叫做 null 的里面啥都没有的对象而已。你可以这么理解："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Object null = new Object(); // 创建一个空对象\nUser user = new User(); // 创建一个User对象，并用user这个引用指向它\nuser = null; // 将user指向null，原来的User对象没人指向了，就可以回收了。\n"})}),"\n",(0,i.jsx)(e.p,{children:"这样是不是就很好理解了？"}),"\n",(0,i.jsxs)(e.h2,{id:"总结",children:["总结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["本章我们重点讲了值类型和引用类型，",(0,i.jsx)(e.strong,{children:"值类型存放的是具体数值，而引用类型存放的是数据的地址"}),"；并且，我们讲解了字符串、数组和对象这三大引用类型的特点。"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"字符串：是引用类型，用起来却是值类型；为了安全设置为不可变的。"}),"\n",(0,i.jsx)(e.li,{children:"数组：数组指向的地址就是第一个元素的地址，可以快速地访问其他元素。"}),"\n",(0,i.jsx)(e.li,{children:"对象：对象的生命周期跟着作用域走，如果没有引用指向它，它就可能提前死亡。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"另外，我们一定要注意浮点数的精度问题，下一节，我们就来看一下这些数据类型该如何选择。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(s,{...n})}):s(n)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC04%E7%AB%A0%E2%80%94%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9F%BA%E5%85%83%EF%BC%9A%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md"]={toc:[{text:"值类型",id:"值类型",depth:2},{text:"引用类型",id:"引用类型",depth:2},{text:"字符串",id:"字符串",depth:3},{text:"数组",id:"数组",depth:3},{text:"对象",id:"对象",depth:3},{text:"总结",id:"总结",depth:2}],title:"第04章—代码的基元：初识数据类型",headingTitle:"第04章—代码的基元：初识数据类型",frontmatter:{}}}}]);