"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["93772"],{698884:function(e,n,t){t.r(n),t.d(n,{default:()=>f});var s=t(552676),c=t(740453);let o=t.p+"static/image/2d51ec01fd59eed0bc0a6c83f935f66b.a05687a5.webp";function i(e){let n=Object.assign({p:"p",h1:"h1",a:"a",code:"code",img:"img",h2:"h2",pre:"pre",ul:"ul",li:"li",strong:"strong",ol:"ol",h3:"h3",blockquote:"blockquote"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"上节我们以 useState 的视角来看 Hooks 的运行机制，但 useEffect 执行机制与 useState 的机制略有不同。"}),"\n",(0,s.jsx)(n.p,{children:"通过本节的学习，你将彻底搞懂 useEffect 的源码，明白 React 如何处理 effect 函数，以及 Hooks 的闭包问题。"}),"\n",(0,s.jsxs)(n.h1,{id:"11源码篇从-useeffect-的源码上解决闭包问题",children:["11.源码篇｜从 useEffect 的源码上解决闭包问题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11源码篇从-useeffect-的源码上解决闭包问题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"众所周知，useEffect 是用来处理副作用函数的，那么什么是副作用呢？"}),"\n",(0,s.jsxs)(n.p,{children:["副作用（",(0,s.jsx)(n.code,{children:"Side Effect"}),"）是指 function 做了和本身运算返回值无关的事，如请求数据、修改全局变量，打印、数据获取、设置订阅，以及手动更改 React 组件中的 DOM，这些操作都属于副作用。"]}),"\n",(0,s.jsx)(n.p,{children:"useEffect 与 useState 的阶段有所不同，共分为：初始化阶段、更新阶段、commit 阶段，接下来我们围绕这三个阶段全面了解它。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"mounteffect初始化阶段",children:["mountEffect（初始化阶段）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mounteffect初始化阶段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["文件位置：",(0,s.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberHooks.js"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function mountEffect(\n  create: () => (() => void) | void, // 回调函数，也是副作用函数\n  deps: Array<mixed> | void | null, // 依赖项\n): void {\n  mountEffectImpl(\n    PassiveEffect | PassiveStaticEffect,\n    HookPassive,\n    create,\n    deps,\n  );\n}\n\nfunction mountEffectImpl(\n  fiberFlags: Flags,\n  hookFlags: HookFlags,\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookFlags,\n    create,\n    undefined,\n    nextDeps,\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["从 ",(0,s.jsx)(n.code,{children:"mountEffect"})," 进来，直接走向 ",(0,s.jsx)(n.code,{children:"mountEffectImpl"})," 函数，先来看看 mountEffectImpl 的入参："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"fiberFlags：有副作用的更新标记，用来标记 hook 在 fiber 中的位置；"}),"\n",(0,s.jsx)(n.li,{children:"hookFlags：副作用标记；"}),"\n",(0,s.jsx)(n.li,{children:"create：用户传入的回调函数，也是副作用函数；"}),"\n",(0,s.jsx)(n.li,{children:"deps：用户传递的依赖项。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"mountEffectImpl 执行流程"}),"："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"初始化一个 hook 对象，并和 fiber 建立关系；"}),"\n",(0,s.jsx)(n.li,{children:"判断 deps 是否存在，没有的话则是 null（需要注意下这个参数，后续会详细讲解）；"}),"\n",(0,s.jsx)(n.li,{children:"给 hook 所在的 fiber 打上副作用的更新标记；"}),"\n",(0,s.jsx)(n.li,{children:"将副作用的操作存放到 hook.memoizedState 中。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"pusheffect",children:["pushEffect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pusheffect",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["副作用的操作来到了 ",(0,s.jsx)(n.code,{children:"pushEffect"}),"，一起来看看："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function pushEffect(tag, create, destroy, deps): Effect {\n\n  // 初始化一个effect对象\n  const effect: Effect = {\n    tag,\n    create,\n    destroy,\n    deps,\n    next: (null: any),\n  };\n  \n  let componentUpdateQueue = (currentlyRenderingFiber.updateQueue: any);\n  \n  if (componentUpdateQueue === null) { //第一个effect对象\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any);\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else { // 存放多个effect对象\n    const lastEffect = componentUpdateQueue.lastEffect;\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      const firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n  return effect;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["别看 ",(0,s.jsx)(n.code,{children:"pushEffect"})," 中有一大坨，但是不是有种似曾相识的感觉呢？没错，它与上节的内容类似，它的作用是创建一个 ",(0,s.jsx)(n.code,{children:"effect"})," 对象，然后形成一个 effect 链表，通过 next 链接 ，最后绑定在 fiber 中的 updateQueue 上。比如下面这段代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'  const [name, setName] = useState("小杜杜");\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log(1);\n  }, []);\n\n  useEffect(() => {\n    console.log(2);\n  }, [name]);\n\n  useEffect(() => {\n    console.log(3);\n  }, [count]);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["转化后的 ",(0,s.jsx)(n.code,{children:"fiber.updateQueue"})," 为："]}),"\n",(0,s.jsxs)(n.h3,{id:"不同的-effect",children:["不同的 Effect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#不同的-effect",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["值得注意的是 fiber.updateQueue 保存的是所有副作用，除了包含 useEffect，同时还包含 ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," 和 ",(0,s.jsx)(n.code,{children:"useInsertionEffect"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["这里会通过不同的 ",(0,s.jsx)(n.code,{children:"fiberFlags"})," 给对应的 effect 打上标记，之后在 updateQueue 链表中的 tag 字段体现出来，最后在 commit 阶段，判断到底是哪种 effect，是同步还是异步等。如："]}),"\n",(0,s.jsxs)(n.h2,{id:"updateeffect更新阶段",children:["updateEffect（更新阶段）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#updateeffect更新阶段",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function updateEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  updateEffectImpl(PassiveEffect, HookPassive, create, deps);\n}\n\nfunction updateEffectImpl(\n  fiberFlags: Flags,\n  hookFlags: HookFlags,\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n\n  // 获取更新的hooks\n  const hook = updateWorkInProgressHook();\n  // 处理deps\n  const nextDeps = deps === undefined ? null : deps;\n  let destroy = undefined;\n\n  if (currentHook !== null) {\n    const prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n    if (nextDeps !== null) {\n      const prevDeps = prevEffect.deps;\n      \n      // 判断依赖是否发生改变，如果没有，只更新副作用链表\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  // 如果依赖发生改变，则在更新链表的时候，打上对应的标签\n  currentlyRenderingFiber.flags |= fiberFlags;\n\n  hook.memoizedState = pushEffect(\n    HookHasEffect | hookFlags,\n    create,\n    destroy,\n    nextDeps,\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["updateEffect：在更新阶段做的事其实很简单，就是判断 deps 是否发生改变，如果没有发生改变，则直接执行 ",(0,s.jsx)(n.code,{children:"pushEffect"}),"，如果发生改变，则附上不同的标签，最后在 commit 阶段，通过这些标签来判断是否执行 effect 函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"不同类型的-deps-对-effect-函数执行的影响",children:["不同类型的 deps 对 effect 函数执行的影响",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#不同类型的-deps-对-effect-函数执行的影响",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在日常的开发中，有些不熟悉 useEffect 的小伙伴只知道 deps 发生改变，则执行对应的 effect 函数，但对 deps 本身的类型并不了解，这也造就了一些莫名奇怪的 bug，怎么找也找不到，有时候真的有可能是规范所引起的，因此我们看看以下关于 deps 的问题："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"deps 不存在时，造成的后果是什么？"}),"\n",(0,s.jsxs)(n.li,{children:["deps 是空数组，造成的后果是什么（如：",(0,s.jsx)(n.code,{children:"[]"}),"）？"]}),"\n",(0,s.jsxs)(n.li,{children:["deps 是数组、对象、函数时，造成的后果是什么（如：",(0,s.jsx)(n.code,{children:"[ [1] ]"}),"、",(0,s.jsx)(n.code,{children:"[{ a: 1 }]"}),"）？"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["实际上，所有的答案都在 ",(0,s.jsx)(n.code,{children:"areHookInputsEqual"})," 函数中："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const nextDeps = deps === undefined ? null : deps;\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null,\n): boolean {\n\n  if (prevDeps === null) {\n    return false;\n  }\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (objectIs(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\n// 存在Object.is，就直接使用，没有的话，手动实现Object.is\nconst objectIs: (x: any, y: any) => boolean = typeof Object.is === 'function' ? Object.is : is;\n\nfunction is(x: any, y: any) {\n  return (\n    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) \n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"从代码中，共分为三种情况："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["当 deps 不存在时，也就是 ",(0,s.jsx)(n.code,{children:"undefined"}),"，则会当作 ",(0,s.jsx)(n.code,{children:"null"})," 处理，所以无论发生什么改变，areHookInputsEqual 的值始终为 ",(0,s.jsx)(n.code,{children:"false"}),"，从而每次都会执行；"]}),"\n",(0,s.jsxs)(n.li,{children:["当 deps 为空数组时，areHookInputsEqual 返回值为 ",(0,s.jsx)(n.code,{children:"true"}),"，此时只更新链表，并没有执行对应的副作用，所以只会走一次；"]}),"\n",(0,s.jsxs)(n.li,{children:["当 deps 为对象、数组、函数时，虽然保存了，但在 ",(0,s.jsx)(n.code,{children:"objectIs"})," 做比较时，旧值与新值永远不相等，也就是",(0,s.jsx)(n.code,{children:"[1] !== [1]"}),"、",(0,s.jsx)(n.code,{children:"{a: 1} !== {a: 1}"}),"（指向不同），所以只要当 deps 发生变动，都会触发更新。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"注意："})," 如果强行比较对象、数组时，可以通过 ",(0,s.jsx)(n.code,{children:"JSON.stringify()"})," 转化为字符串，当作 deps 的参数。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useMemo"})," 和 ",(0,s.jsx)(n.code,{children:"useCallback"})," 中的 deps 也是同理。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"commitrootcommit-阶段",children:["commitRoot（commit 阶段）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commitrootcommit-阶段",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"commitRoot 是 commit 阶段的入口，一起来看看。"}),"\n",(0,s.jsxs)(n.p,{children:["文件位置：",(0,s.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberWorkLoop.js"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function commitRoot(\n  root: FiberRoot,\n  recoverableErrors: null | Array<CapturedValue<mixed>>,\n  transitions: Array<Transition> | null,\n) {\n  // 获取优先级\n  const previousUpdateLanePriority = getCurrentUpdatePriority();\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ...\n  commitRootImpl(\n      root,\n      recoverableErrors,\n      transitions,\n      previousUpdateLanePriority,\n  );\n\n  return null;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 commitRoot 中，首先会制定函数的优先级，当执行完毕后，恢复优先级，而这个函数的主体为 ",(0,s.jsx)(n.code,{children:"commitRootImpl"})," 函数。"]}),"\n",(0,s.jsxs)(n.h3,{id:"commitrootimpl",children:["commitRootImpl",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commitrootimpl",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["commitRootImpl 函数非常复杂，这里我们只关注 effect 的逻辑即可，而关于 effect 的逻辑主要是 ",(0,s.jsx)(n.code,{children:"scheduleCallback"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel ) {\n  ...\n  scheduleCallback(NormalSchedulerPriority, () => {\n    // 调度 Effect\n    flushPassiveEffects();\n    return null;\n  });\n  ...\n  return null;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"scheduleCallback"})," 是 React 调度器（Scheduler）的一个 API，最终通过一个宏任务来异步调度传入的回调函数，使得该回调在下一轮事件循环中执行，此时浏览器已经绘制过一次。同时可以看出，effectlist 的优先级是：普通优先级。"]}),"\n",(0,s.jsxs)(n.h3,{id:"flushpassiveeffects",children:["flushPassiveEffects",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#flushpassiveeffects",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export function flushPassiveEffects(): boolean {\n\n  if (rootWithPendingPassiveEffects !== null) {\n    ...\n    try {\n      ReactCurrentBatchConfig.transition = null;\n      // 设置优先级\n      setCurrentUpdatePriority(priority);\n      // 调用函数\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig.transition = prevTransition;\n      releaseRootPooledCache(root, remainingLanes);\n    }\n  }\n  return false;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["到 ",(0,s.jsx)(n.code,{children:"flushPassiveEffects"})," 中，也是一系列跟优先级有关的操作，最终走向 ",(0,s.jsx)(n.code,{children:"flushPassiveEffectsImpl"})," 这个函数。而在这个函数中会执行两个方法，分别是：",(0,s.jsx)(n.code,{children:"commitPassiveUnmountEffects（执行所有 effect 的销毁程序）"})," 和 ",(0,s.jsx)(n.code,{children:"commitPassiveMountEffects（执行所有 effect 的回调函数）"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"接下来逐一进行分析，看看两者的的流向。"}),"\n",(0,s.jsxs)(n.h3,{id:"commitpassivemounteffects-的流向",children:["commitPassiveMountEffects 的流向",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commitpassivemounteffects-的流向",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"最终的走向为 commitHookEffectListMount 函数，着重看下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function commitHookEffectListMount(flags: HookFlags, finishedWork: Fiber) {\n  const updateQueue = (finishedWork.updateQueue: any);\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & flags) === flags) {\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        }\n\n        // 执行effect函数， 并保存effect函数的结果给destroy\n        const create = effect.create;\n        effect.destroy = create();\n\n        if (enableSchedulingProfiler) {\n          if ((flags & HookPassive) !== NoHookEffect) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & HookLayout) !== NoHookEffect) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["主要作用是：遍历所有的 ",(0,s.jsx)(n.code,{children:"effect list"}),"，然后依次执行对应的 effect 副作用函数，并将其结果保留在 ",(0,s.jsx)(n.code,{children:"destroy"})," 函数中。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"effect list 是一个用于 effectTag 副作用列表容器，包含第一个节点：firstEffect， 和最后一个节点 lastEffect，通过 next 链接，在 commit 阶段，根据这些 effectTag 来判断执行的时机，从而对相应的 DOM 树进行更改。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"commitpassiveunmounteffects-的流向",children:["commitPassiveUnmountEffects 的流向",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commitpassiveunmounteffects-的流向",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"最终的走向为 commitHookEffectListUnmount 函数， 来看看："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"function commitHookEffectListUnmount(\n  flags: HookFlags,\n  finishedWork: Fiber,\n  nearestMountedAncestor: Fiber | null,\n) {\n  const updateQueue= finishedWork.updateQueue;\n  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n  if (lastEffect !== null) {\n    const firstEffect = lastEffect.next;\n    let effect = firstEffect;\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        const destroy = effect.destroy;\n        effect.destroy = undefined;\n        if (destroy !== undefined) {\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n           // 调用销毁逻辑\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n          if (enableSchedulingProfiler) {\n            if ((flags & HookPassive) !== NoHookEffect) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & HookLayout) !== NoHookEffect) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["主要通过 ",(0,s.jsx)(n.code,{children:"safelyCallDestroy"})," 走对应的销毁逻辑，这里要注意下，effect 的执行需要保证所有组件的 effect 的销毁函数执行完才能够执行。"]}),"\n",(0,s.jsx)(n.p,{children:"因为多个组件可能共用一个 ref，如果不将销毁函数执行，改变 ref 的值，有可能会影响其他 effect 执行。"}),"\n",(0,s.jsxs)(n.h1,{id:"经典的闭包问题",children:["经典的闭包问题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#经典的闭包问题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"阅读完 useEffect 源码后，再来看最为经典的 React Hooks 的闭包问题，就会变得异常简单。相信各位小伙伴一定都踩过坑，我们解决一下这个问题，同时巩固之前所学的知识。"}),"\n",(0,s.jsx)(n.p,{children:"先看下面这段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { useState, useEffect } from "react";\nimport { Button, message } from "antd";\nconst Index = () => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setCount((v) => v + 1);\n    }, 2000);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, []);\n\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      message.info(`当前的count为：${count}`);\n    }, 3000);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, []);\n\n  return (\n    <div style={{ padding: 20 }}>\n      <div>数字：{count}</div>\n      <Button onClick={() => setCount((v) => v + 1)}>加1</Button>\n    </div>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["例子很简单，进入页面，创建 count，在第一个 useEffect 中过 ",(0,s.jsx)(n.code,{children:"2s"})," 给 count 加 1，并且在这 ",(0,s.jsx)(n.code,{children:"2s"})," 中点击按钮两次，之后在第二个 useEffect 中过 ",(0,s.jsx)(n.code,{children:"3s"})," 进行获取 count 值。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么你觉得 info 中的 count 是 ",(0,s.jsx)(n.code,{children:"0"}),"、",(0,s.jsx)(n.code,{children:"1"})," 还是 ",(0,s.jsx)(n.code,{children:"3"})," ？"]}),"\n",(0,s.jsx)(n.p,{children:"思考下，在页面中可以看到，渲染的值变成了 3，但为什么在 info 中是 0 呢？这种情况就是最经典的闭包问题。"}),"\n",(0,s.jsxs)(n.p,{children:["首先，在绝大多数的场景下，并不会出现闭包问题，只有在延迟调用的场景下（如：",(0,s.jsx)(n.code,{children:"setTimeout"}),"、",(0,s.jsx)(n.code,{children:"setInterval"}),"、",(0,s.jsx)(n.code,{children:"Promise.then"})," 等），才会出现闭包问题。接下来一起看看该如何解决。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们先温习下上节的内容。当进行初始化后，Hooks 信息在 Fiber 中的",(0,s.jsx)(n.code,{children:"memorizedState"})," 链表中，通过 ",(0,s.jsx)(n.code,{children:"next"})," 链接，直到没有，则为 ",(0,s.jsx)(n.code,{children:"null"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["案例中对应 ",(0,s.jsx)(n.code,{children:"useState"}),"、",(0,s.jsx)(n.code,{children:"useEffect"}),"、",(0,s.jsx)(n.code,{children:"useEffect"})," 3 个 ",(0,s.jsx)(n.code,{children:"hook"}),"，自然对应链表中的 3 个 ",(0,s.jsx)(n.code,{children:"memorizedState"}),"，如："]}),"\n",(0,s.jsxs)(n.p,{children:["当执行 useEffect 时，一直拿最初的 ",(0,s.jsx)(n.code,{children:"count = 0"})," 来记录引用关系。再加上 ",(0,s.jsx)(n.code,{children:"deps"})," 为空数组，此时只执行一次，所以无论点击多少次按钮，其结果都为 0。"]}),"\n",(0,s.jsxs)(n.h2,{id:"设置-deps-为-count",children:["设置 deps 为 count",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设置-deps-为-count",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["既然在引用时一直拿 ",(0,s.jsx)(n.code,{children:"count = 0"})," 为引用条件，那么我们将 deps 的参数设置为 count，去监听 count，从而初始化定时器，是不是就 ok了呢？"]}),"\n",(0,s.jsx)(n.p,{children:"来看下效果："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"问：为什么要在 useEffect 的 return 中清空定时器呢？"}),"\n",(0,s.jsxs)(n.p,{children:["答：useEffect 对应的 return 就是源码中的 ",(0,s.jsx)(n.code,{children:"destroy 函数"}),"，如果不清空，那么还会执行之前的定时器。setTimeout 的效果可能不是很清晰，感兴趣的小伙伴可以换成 setInterval 试试。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"uselatest-解决",children:["useLatest 解决",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#uselatest-解决",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"那么 deps 设置为 count 真的能够解决闭包问题吗？"}),"\n",(0,s.jsx)(n.p,{children:"我认为并不能彻底解决。在上述的问题中，useEffect 函数本身执行了 3 遍（2 次点击，1 次count+1），换句话说，只要 count 发生变化，就会执行 useEffect 函数。"}),"\n",(0,s.jsx)(n.p,{children:"如果现在的需求变为只想在 3s 后获取到最新值，之后再点击按钮，不获取最新值，该怎么办？"}),"\n",(0,s.jsx)(n.p,{children:"其实答案很简单，利用 ref 的高级用法——缓存数据，也就是 useLatest 去解决就 ok 了。如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"  const countRef = useLatest(count);\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      message.info(`当前的count为：${countRef.current}`);\n    }, 3000);\n\n  }, []);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsxs)(n.h2,{id:"结果何时为-1",children:["结果何时为 1？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结果何时为-1",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我在一开始的问题中写了 3 个答案，分别是：0、1、3。0 和 3 讲解了原因，那么 1 是怎么出现的呢？答案是将 ",(0,s.jsx)(n.code,{children:"setCount((v) => v + 1)"})," 替换为 ",(0,s.jsx)(n.code,{children:"setCount(count + 1)"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"如果不知道为什么，那就再看看上节的内容，做个简单的巩固吧～"}),"\n",(0,s.jsxs)(n.h1,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本节通过 useEffect 的源码，来了解 useEffect 的执行流程，大体分三个阶段：初始化、更新和执行阶段，同时讲解了不同 effect 的连接方式、deps 参数问题等，最后通过经典的闭包问题，巩固 useState、useEffect。"}),"\n",(0,s.jsx)(n.p,{children:"现在对 useEffect 的三个阶段做出简要总结。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. useEffect 初始化阶段"})}),"\n",(0,s.jsxs)(n.p,{children:["建立一个 hook 对象，与 fiber 建立关联，并给 hook 所在的 fiber 打上副作用更新标记，最后存储在 fiber 中的 ",(0,s.jsx)(n.code,{children:"memoizedState"}),"，同时在 fiber 中的 updateQueue 存储了相关的副作用（这些副作用是闭环链表）。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. useEffect 更新阶段"})}),"\n",(0,s.jsx)(n.p,{children:"这个阶段最主要的是：判断 deps 是否发生改变，如果没有改变，则更新副作用链表；如果发生改变，则在更新链表的时候，打上对应的副作用标签。之后在 commit 阶段，根据对应的标签，重新执行对应的副作用。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. useEffect 执行阶段"})}),"\n",(0,s.jsxs)(n.p,{children:["在 commit 阶段中，入口为 ",(0,s.jsx)(n.code,{children:"commitRoot"}),"，走到 ",(0,s.jsx)(n.code,{children:"commitRootImpl"}),"，用 ",(0,s.jsx)(n.code,{children:"scheduleCallback"})," 进行调度，同时 effectlist 属于普通调度，最终走向：",(0,s.jsx)(n.code,{children:"commitPassiveMountEffects"})," 和 ",(0,s.jsx)(n.code,{children:"commitPassiveUnmountEffects"}),"，回调和销毁的过程类似。值得注意的是：不同的 effect 通过 effectTag 来判断。"]}),"\n",(0,s.jsx)(n.p,{children:"实际上，执行阶段是非常复杂的，主要是有优先级的部分，需要判断执行的时机，是同步或异步，何时执行，在文节中只是简要地介绍下关于 effect list 的部分，并不涉及麻烦、难懂的知识点。"}),"\n",(0,s.jsx)(n.p,{children:"总的来说，源码确实比较头疼，但当你逐渐掌握后，会发现越来越有趣。下一节我们将学习 useMemo 和 useCallback 的源码及详解～"})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let f=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F11.%E6%BA%90%E7%A0%81%E7%AF%87%EF%BD%9C%E4%BB%8E%20useEffect%20%E7%9A%84%E6%BA%90%E7%A0%81%E4%B8%8A%E8%A7%A3%E5%86%B3%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98.md"]={toc:[{text:"mountEffect（初始化阶段）",id:"mounteffect初始化阶段",depth:2},{text:"pushEffect",id:"pusheffect",depth:3},{text:"不同的 Effect",id:"不同的-effect",depth:3},{text:"updateEffect（更新阶段）",id:"updateeffect更新阶段",depth:2},{text:"不同类型的 deps 对 effect 函数执行的影响",id:"不同类型的-deps-对-effect-函数执行的影响",depth:3},{text:"commitRoot（commit 阶段）",id:"commitrootcommit-阶段",depth:2},{text:"commitRootImpl",id:"commitrootimpl",depth:3},{text:"flushPassiveEffects",id:"flushpassiveeffects",depth:3},{text:"commitPassiveMountEffects 的流向",id:"commitpassivemounteffects-的流向",depth:3},{text:"commitPassiveUnmountEffects 的流向",id:"commitpassiveunmounteffects-的流向",depth:3},{text:"设置 deps 为 count",id:"设置-deps-为-count",depth:2},{text:"useLatest 解决",id:"uselatest-解决",depth:2},{text:"结果何时为 1？",id:"结果何时为-1",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);