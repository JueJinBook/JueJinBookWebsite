"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["26862"],{1388:function(n,e,r){r.r(e),r.d(e,{default:()=>l});var t=r(552676),s=r(740453);function a(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",strong:"strong"},(0,s.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"31设计模式",children:["31.设计模式",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#31设计模式",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"设计模式总的来说是一个抽象的概念，前人通过无数次的实践总结出的一套写代码的方式，通过这种方式写的代码可以让别人更加容易阅读、维护以及复用。"}),"\n",(0,t.jsx)(e.p,{children:"这一章节我们将来学习几种最常用的设计模式。"}),"\n",(0,t.jsxs)(e.h2,{id:"工厂模式",children:["工厂模式",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#工厂模式",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"工厂模式分为好几种，这里就不一一讲解了，以下是一个简单工厂模式的例子"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"class Man {\n  constructor(name) {\n    this.name = name\n  }\n  alertName() {\n    alert(this.name)\n  }\n}\n\nclass Factory {\n  static create(name) {\n    return new Man(name)\n  }\n}\n\nFactory.create('yck').alertName()\n"})}),"\n",(0,t.jsxs)(e.p,{children:["当然工厂模式并不仅仅是用来 new 出",(0,t.jsx)(e.strong,{children:"实例"}),"。"]}),"\n",(0,t.jsx)(e.p,{children:"可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。"}),"\n",(0,t.jsx)(e.p,{children:"工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。"}),"\n",(0,t.jsx)(e.p,{children:"在 Vue 源码中，你也可以看到工厂模式的使用，比如创建异步组件"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"export function createComponent (\n  Ctor: Class<Component> | Function | Object | void,\n  data: ?VNodeData,\n  context: Component,\n  children: ?Array<VNode>,\n  tag?: string\n): VNode | Array<VNode> | void {\n    \n    // 逻辑处理...\n  \n  const vnode = new VNode(\n    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,\n    data, undefined, undefined, undefined, context,\n    { Ctor, propsData, listeners, tag, children },\n    asyncFactory\n  )\n\n  return vnode\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["在上述代码中，我们可以看到我们只需要调用 ",(0,t.jsx)(e.code,{children:"createComponent"})," 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。"]}),"\n",(0,t.jsxs)(e.h2,{id:"单例模式",children:["单例模式",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#单例模式",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。"}),"\n",(0,t.jsx)(e.p,{children:"单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式并不能套入 JS 中，我们只需要用一个变量确保实例只创建一次就行，以下是如何实现单例模式的例子"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"class Singleton {\n  constructor() {}\n}\n\nSingleton.getInstance = (function() {\n  let instance\n  return function() {\n    if (!instance) {\n      instance = new Singleton()\n    }\n    return instance\n  }\n})()\n\nlet s1 = Singleton.getInstance()\nlet s2 = Singleton.getInstance()\nconsole.log(s1 === s2) // true\n"})}),"\n",(0,t.jsx)(e.p,{children:"在 Vuex 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 Vuex"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"let Vue // bind on install\n\nexport function install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    // 如果发现 Vue 有值，就不重新创建实例了\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"适配器模式",children:["适配器模式",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#适配器模式",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。"}),"\n",(0,t.jsx)(e.p,{children:"以下是如何实现适配器模式的例子"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"class Plug {\n  getName() {\n    return '港版插头'\n  }\n}\n\nclass Target {\n  constructor() {\n    this.plug = new Plug()\n  }\n  getName() {\n    return this.plug.getName() + ' 适配器转二脚插头'\n  }\n}\n\nlet target = new Target()\ntarget.getName() // 港版插头 适配器转二脚插头\n"})}),"\n",(0,t.jsxs)(e.p,{children:["在 Vue 中，我们其实经常使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 ",(0,t.jsx)(e.code,{children:"computed"})," 来做转换这件事情，这个过程就使用到了适配器模式。"]}),"\n",(0,t.jsxs)(e.h2,{id:"装饰模式",children:["装饰模式",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#装饰模式",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。"}),"\n",(0,t.jsx)(e.p,{children:"以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"function readonly(target, key, descriptor) {\n  descriptor.writable = false\n  return descriptor\n}\n\nclass Test {\n  @readonly\n  name = 'yck'\n}\n\nlet t = new Test()\n\nt.yck = '111' // 不可修改\n"})}),"\n",(0,t.jsx)(e.p,{children:"在 React 中，装饰模式其实随处可见"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:"import { connect } from 'react-redux'\nclass MyComponent extends React.Component {\n    // ...\n}\nexport default connect(mapStateToProps)(MyComponent)\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"代理模式",children:["代理模式",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代理模式",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"代理是为了控制对对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理的场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品。"}),"\n",(0,t.jsx)(e.p,{children:"在实际代码中其实代理的场景很多，也就不举框架中的例子了，比如事件代理就用到了代理模式。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"<ul id=\"ul\">\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n</ul>\n<script>\n    let ul = document.querySelector('#ul')\n    ul.addEventListener('click', (event) => {\n        console.log(event.target);\n    })\n<\/script>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["因为存在太多的 ",(0,t.jsx)(e.code,{children:"li"}),"，不可能每个都去绑定事件。这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。"]}),"\n",(0,t.jsxs)(e.h2,{id:"发布-订阅模式",children:["发布-订阅模式",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#发布-订阅模式",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。"}),"\n",(0,t.jsx)(e.p,{children:"在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",children:"<ul id=\"ul\"></ul>\n<script>\n    let ul = document.querySelector('#ul')\n    ul.addEventListener('click', (event) => {\n        console.log(event.target);\n    })\n<\/script>\n"})}),"\n",(0,t.jsxs)(e.p,{children:["在 Vue 中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 ",(0,t.jsx)(e.code,{children:"get"})," 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。"]}),"\n",(0,t.jsxs)(e.h2,{id:"外观模式",children:["外观模式",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#外观模式",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。"}),"\n",(0,t.jsx)(e.p,{children:"举个例子来说，我们现在需要实现一个兼容多种浏览器的添加事件方法"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",children:'function addEvent(elm, evType, fn, useCapture) {\n  if (elm.addEventListener) {\n    elm.addEventListener(evType, fn, useCapture)\n    return true\n  } else if (elm.attachEvent) {\n    var r = elm.attachEvent("on" + evType, fn)\n    return r\n  } else {\n    elm["on" + evType] = fn\n  }\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["对于不同的浏览器，添加事件的方式可能会存在兼容问题。如果每次都需要去这样写一遍的话肯定是不能接受的，所以我们将这些判断逻辑统一封装在一个接口中，外部需要添加事件只需要调用 ",(0,t.jsx)(e.code,{children:"addEvent"})," 即可。"]}),"\n",(0,t.jsxs)(e.h2,{id:"小结",children:["小结",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"这一章节我们学习了几种常用的设计模式。其实设计模式还有很多，有一些内容很简单，我就没有写在章节中了，比如迭代器模式、原型模式，有一些内容也是不经常使用，所以也就不一一列举了。"}),"\n",(0,t.jsxs)(e.p,{children:["如果你还想了解更多关于设计模式的内容，可以阅读",(0,t.jsx)(e.a,{href:"https://book.douban.com/subject/26382780/",target:"_blank",rel:"noopener noreferrer",children:"这本书"}),"。"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F31.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md"]={toc:[{text:"工厂模式",id:"工厂模式",depth:2},{text:"单例模式",id:"单例模式",depth:2},{text:"适配器模式",id:"适配器模式",depth:2},{text:"装饰模式",id:"装饰模式",depth:2},{text:"代理模式",id:"代理模式",depth:2},{text:"发布-订阅模式",id:"发布-订阅模式",depth:2},{text:"外观模式",id:"外观模式",depth:2},{text:"小结",id:"小结",depth:2}],title:"31.设计模式",headingTitle:"31.设计模式",frontmatter:{}}}}]);