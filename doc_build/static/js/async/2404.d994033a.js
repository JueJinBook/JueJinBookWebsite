"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["2404"],{120096:function(e,t,n){n.r(t),n.d(t,{default:()=>o});var s=n(552676),a=n(740453);let c=n.p+"static/image/ca9c1f322316e9d574d86fbe49b18b93.b0c74396.webp",r=n.p+"static/image/a33473852b8ea6d151ef32197bfcaf15.89fe2fe3.webp",l=n.p+"static/image/fa746a04f93849ca5b090ae8317ab735.aaee9f4d.webp",i=n.p+"static/image/de82833b1f4383e915316fb34b68e742.90241dcf.webp";function d(e){let t=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",code:"code",h3:"h3",pre:"pre",ul:"ul",li:"li",img:"img",blockquote:"blockquote"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.h1,{id:"4基础篇-玄学-state",children:["4.基础篇-玄学 state",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#4基础篇-玄学-state",children:"#"})]}),"\n",(0,s.jsxs)(t.h2,{id:"一-前言",children:["一 前言",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,s.jsx)(t.p,{children:"本章节将详细介绍一下 state ，题目叫做玄学 state ，为什么说玄学 state 呢，因为在不同的执行环境下，或者不同的 React 模式下，State 更新流程都是不同的。"}),"\n",(0,s.jsxs)(t.p,{children:["为了证实上面的话，首先翻出一道老掉牙的面试题：",(0,s.jsx)(t.strong,{children:"state 到底是同步还是异步的？"})]}),"\n",(0,s.jsx)(t.p,{children:"如果对 React 底层有一定了解，回答出 batchUpdate 批量更新概念，以及批量更新被打破的条件。似乎已经达到了面试官的要求，但是这里想说的是，这个答案在不久的将来有可能被颠覆。"}),"\n",(0,s.jsx)(t.p,{children:"为什么这么说呢？"}),"\n",(0,s.jsxs)(t.p,{children:["React 是有多种模式的，基本平时用的都是 legacy 模式下的 React，除了",(0,s.jsx)(t.code,{children:"legacy"})," 模式，还有 ",(0,s.jsx)(t.code,{children:"blocking"})," 模式和 ",(0,s.jsx)(t.code,{children:"concurrent"})," 模式， blocking 可以视为 concurrent 的优雅降级版本和过渡版本，React 最终目的，不久的未来将以 concurrent 模式作为默认版本，这个模式下会开启一些新功能。"]}),"\n",(0,s.jsx)(t.p,{children:"对于 concurrent 模式下，会采用不同 State 更新逻辑。前不久透露出未来的Reactv18 版本，concurrent 将作为一个稳定的功能出现。"}),"\n",(0,s.jsx)(t.p,{children:"本章节主要还是围绕 legacy 模式下的 state 。通过本文学习，目的是让大家了解 React 更新流程，以及类组件 setState 和函数组件 useState 的诸多细节问题。"}),"\n",(0,s.jsxs)(t.h2,{id:"二-类组件中的-state",children:["二 类组件中的 state",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#二-类组件中的-state",children:"#"})]}),"\n",(0,s.jsxs)(t.h3,{id:"setstate用法",children:["setState用法",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#setstate用法",children:"#"})]}),"\n",(0,s.jsxs)(t.p,{children:["React 项目中 UI 的改变来源于 state 改变，类组件中 ",(0,s.jsx)(t.code,{children:"setState"})," 是更新组件，渲染视图的主要方式。"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"基本用法"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"setState(obj,callback)\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"第一个参数：当 obj 为一个对象，则为即将合并的 state ；如果 obj 是一个函数，那么当前组件的 state 和 props 将作为参数，返回值用于合并新的 state。"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"第二个参数 callback ：callback 为一个函数，函数执行上下文中可以获取当前 setState 更新后的最新 state 的值，可以作为依赖 state 变化的副作用函数，可以用来做一些基于 DOM 的操作。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"/* 第一个参数为function类型 */\nthis.setState((state,props)=>{\n    return { number:1 } \n})\n/* 第一个参数为object类型 */\nthis.setState({ number:1 },()=>{\n    console.log(this.state.number) //获取最新的number\n})\n"})}),"\n",(0,s.jsx)(t.p,{children:"假如一次事件中触发一次如上 setState ，在 React 底层主要做了那些事呢？"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"首先，setState 会产生当前更新的优先级（老版本用 expirationTime ，新版本用 lane ）。"}),"\n",(0,s.jsx)(t.li,{children:"接下来 React 会从 fiber Root 根部 fiber 向下调和子节点，调和阶段将对比发生更新的地方，更新对比 expirationTime ，找到发生更新的组件，合并 state，然后触发 render 函数，得到新的 UI 视图层，完成 render 阶段。"}),"\n",(0,s.jsx)(t.li,{children:"接下来到 commit 阶段，commit 阶段，替换真实 DOM ，完成此次更新流程。"}),"\n",(0,s.jsxs)(t.li,{children:["此时仍然在 commit 阶段，会执行 setState 中 callback 函数,如上的",(0,s.jsx)(t.code,{children:"()=>{ console.log(this.state.number)  }"}),"，到此为止完成了一次 setState 全过程。"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"更新的流程图如下："})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:i,alt:"02.jpg"})}),"\n",(0,s.jsxs)(t.p,{children:["请记住一个主要任务的先后顺序，这对于弄清渲染过程可能会有帮助：","\nrender 阶段 render 函数执行 ->  commit 阶段真实 DOM 替换 -> setState 回调函数执行 callback 。"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"类组件如何限制 state 更新视图"})}),"\n",(0,s.jsx)(t.p,{children:"对于类组件如何限制 state 带来的更新作用的呢？"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"① pureComponent 可以对 state 和 props 进行浅比较，如果没有发生变化，那么组件不更新。"}),"\n",(0,s.jsx)(t.li,{children:"② shouldComponentUpdate 生命周期可以通过判断前后 state 变化来决定组件需不需要更新，需要更新返回true，否则返回false。"}),"\n"]}),"\n",(0,s.jsxs)(t.h3,{id:"setstate原理揭秘",children:["setState原理揭秘",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#setstate原理揭秘",children:"#"})]}),"\n",(0,s.jsxs)(t.p,{children:["知其然，知其所以然，想要吃透 setState，就需要掌握一些 setState 的底层逻辑。 上一章节讲到对于类组件，类组件初始化过程中绑定了负责更新的",(0,s.jsx)(t.code,{children:"Updater"}),"对象，对于如果调用 setState 方法，实际上是 React 底层调用 Updater 对象上的 enqueueSetState 方法。"]}),"\n",(0,s.jsx)(t.p,{children:"因为要弄明白 state 更新机制，所以接下来要从两个方向分析。"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"一是揭秘 enqueueSetState 到底做了些什么？"}),"\n",(0,s.jsx)(t.li,{children:"二是 React 底层是如何进行批量更新的？"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"首先，这里极致精简了一波 enqueueSetState 代码。如下"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"react-reconciler/src/ReactFiberClassComponent.js"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"enqueueSetState(){\n     /* 每一次调用`setState`，react 都会创建一个 update 里面保存了 */\n     const update = createUpdate(expirationTime, suspenseConfig);\n     /* callback 可以理解为 setState 回调函数，第二个参数 */\n     callback && (update.callback = callback) \n     /* enqueueUpdate 把当前的update 传入当前fiber，待更新队列中 */\n     enqueueUpdate(fiber, update); \n     /* 开始调度更新 */\n     scheduleUpdateOnFiber(fiber, expirationTime);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"enqueueSetState"})," 作用实际很简单，就是创建一个 update ，然后放入当前 fiber 对象的待更新队列中，最后开启调度更新，进入上述讲到的更新流程。"]}),"\n",(0,s.jsx)(t.p,{children:"那么问题来了，React 的 batchUpdate 批量更新是什么时候加上去的呢？"}),"\n",(0,s.jsxs)(t.p,{children:["这就要提前聊一下事件系统了。正常 ",(0,s.jsx)(t.strong,{children:"state 更新"}),"、",(0,s.jsx)(t.strong,{children:"UI 交互"}),"，都离不开用户的事件，比如点击事件，表单输入等，React 是采用事件合成的形式，每一个事件都是由 React 事件系统统一调度的，那么 State 批量更新正是和事件系统息息相关的。"]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"react-dom/src/events/DOMLegacyEventPluginSystem.js"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"/* 在`legacy`模式下，所有的事件都将经过此函数同一处理 */\nfunction dispatchEventForLegacyPluginEventSystem(){\n    // handleTopLevel 事件处理函数\n    batchedEventUpdates(handleTopLevel, bookKeeping);\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"重点来了，就是下面这个 batchedEventUpdates 方法。"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsx)(t.p,{children:"react-dom/src/events/ReactDOMUpdateBatching.js"}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"function batchedEventUpdates(fn,a){\n    /* 开启批量更新  */\n   isBatchingEventUpdates = true;\n  try {\n    /* 这里执行了的事件处理函数， 比如在一次点击事件中触发setState,那么它将在这个函数内执行 */\n    return batchedEventUpdatesImpl(fn, a, b);\n  } finally {\n    /* try 里面 return 不会影响 finally 执行  */\n    /* 完成一次事件，批量更新  */\n    isBatchingEventUpdates = false;\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["如上可以分析出流程，在 React 事件执行之前通过 ",(0,s.jsx)(t.code,{children:"isBatchingEventUpdates=true"})," 打开开关，开启事件批量更新，当该事件结束，再通过 ",(0,s.jsx)(t.code,{children:"isBatchingEventUpdates = false;"})," 关闭开关，然后在 scheduleUpdateOnFiber 中根据这个开关来确定是否进行批量更新。"]}),"\n",(0,s.jsx)(t.p,{children:"举一个例子，如下组件中这么写："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"export default class index extends React.Component{\n    state = { number:0 }\n    handleClick= () => {\n          this.setState({ number:this.state.number + 1 },()=>{   console.log( 'callback1', this.state.number)  })\n          console.log(this.state.number)\n          this.setState({ number:this.state.number + 1 },()=>{   console.log( 'callback2', this.state.number)  })\n          console.log(this.state.number)\n          this.setState({ number:this.state.number + 1 },()=>{   console.log( 'callback3', this.state.number)  })\n          console.log(this.state.number)\n    }\n    render(){\n        return <div>\n            { this.state.number }\n            <button onClick={ this.handleClick }  >number++</button>\n        </div>\n    }\n} \n"})}),"\n",(0,s.jsxs)(t.p,{children:["点击打印：",(0,s.jsx)(t.strong,{children:"0, 0, 0, callback1 1 ,callback2 1 ,callback3 1"})]}),"\n",(0,s.jsx)(t.p,{children:"如上代码，在整个 React 上下文执行栈中会变成这样："}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:l,alt:"03.jpg"})}),"\n",(0,s.jsx)(t.p,{children:"那么，为什么异步操作里面的批量更新规则会被打破呢？比如用 promise 或者 setTimeout 在 handleClick 中这么写："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"setTimeout(()=>{\n    this.setState({ number:this.state.number + 1 },()=>{   console.log( 'callback1', this.state.number)  })\n    console.log(this.state.number)\n    this.setState({ number:this.state.number + 1 },()=>{    console.log( 'callback2', this.state.number)  })\n    console.log(this.state.number)\n    this.setState({ number:this.state.number + 1 },()=>{   console.log( 'callback3', this.state.number)  })\n    console.log(this.state.number)\n})\n"})}),"\n",(0,s.jsxs)(t.p,{children:["打印 ： ",(0,s.jsx)(t.strong,{children:"callback1 1  ,  1, callback2 2 , 2,callback3 3  , 3"})," "]}),"\n",(0,s.jsx)(t.p,{children:"那么在整个 React 上下文执行栈中就会变成如下图这样:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:r,alt:"04.jpg"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"所以批量更新规则被打破"}),"。"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"那么，如何在如上异步环境下，继续开启批量更新模式呢？"})}),"\n",(0,s.jsxs)(t.p,{children:["React-Dom 中提供了批量更新方法 ",(0,s.jsx)(t.code,{children:"unstable_batchedUpdates"}),"，可以去手动批量更新，可以将上述 setTimeout 里面的内容做如下修改:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"import ReactDOM from 'react-dom'\nconst { unstable_batchedUpdates } = ReactDOM\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"\nsetTimeout(()=>{\n    unstable_batchedUpdates(()=>{\n        this.setState({ number:this.state.number + 1 })\n        console.log(this.state.number)\n        this.setState({ number:this.state.number + 1})\n        console.log(this.state.number)\n        this.setState({ number:this.state.number + 1 })\n        console.log(this.state.number) \n    })\n})\n"})}),"\n",(0,s.jsxs)(t.p,{children:["打印： ",(0,s.jsx)(t.strong,{children:"0 , 0 , 0 , callback1 1 , callback2 1 ,callback3 1"})]}),"\n",(0,s.jsx)(t.p,{children:"在实际工作中，unstable_batchedUpdates 可以用于 Ajax 数据交互之后，合并多次 setState，或者是多次 useState 。原因很简单，所有的数据交互都是在异步环境下，如果没有批量更新处理，一次数据交互多次改变 state 会促使视图多次渲染。"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"那么如何提升更新优先级呢？"})}),"\n",(0,s.jsx)(t.p,{children:"React-dom 提供了 flushSync ，flushSync 可以将回调函数中的更新任务，放在一个较高的优先级中。React 设定了很多不同优先级的更新任务。如果一次更新任务在 flushSync 回调函数内部，那么将获得一个较高优先级的更新。"}),"\n",(0,s.jsxs)(t.p,{children:["接下来，将上述 ",(0,s.jsx)(t.code,{children:"handleClick"})," 改版如下样子："]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"handerClick=()=>{\n    setTimeout(()=>{\n        this.setState({ number: 1  })\n    })\n    this.setState({ number: 2  })\n    ReactDOM.flushSync(()=>{\n        this.setState({ number: 3  })\n    })\n    this.setState({ number: 4  })\n}\nrender(){\n   console.log(this.state.number)\n   return ...\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["打印 ",(0,s.jsx)(t.strong,{children:"3 4 1"})," ，相信不难理解为什么这么打印了。"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["首先 ",(0,s.jsx)(t.code,{children:"flushSync"})," ",(0,s.jsx)(t.code,{children:"this.setState({ number: 3  })"}),"设定了一个高优先级的更新，所以 2 和 3 被批量更新到 3 ，所以 3 先被打印。"]}),"\n",(0,s.jsx)(t.li,{children:"更新为 4。"}),"\n",(0,s.jsx)(t.li,{children:"最后更新 setTimeout 中的 number = 1。"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"flushSync补充说明"}),"：flushSync 在同步条件下，会合并之前的 setState | useState，可以理解成，如果发现了 flushSync ，就会先执行更新，如果之前有未更新的 setState ｜ useState ，就会一起合并了，所以就解释了如上，2 和 3 被批量更新到 3 ，所以 3 先被打印。"]}),"\n",(0,s.jsxs)(t.p,{children:["综上所述， React 同一级别",(0,s.jsx)(t.strong,{children:"更新优先级"}),"关系是:"]}),"\n",(0,s.jsxs)(t.p,{children:["flushSync 中的 setState ",(0,s.jsx)(t.strong,{children:">"})," 正常执行上下文中 setState ",(0,s.jsx)(t.strong,{children:">"})," setTimeout ，Promise 中的 setState。"]}),"\n",(0,s.jsxs)(t.h2,{id:"三-函数组件中的state",children:["三 函数组件中的state",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#三-函数组件中的state",children:"#"})]}),"\n",(0,s.jsx)(t.p,{children:"React-hooks 正式发布以后， useState 可以使函数组件像类组件一样拥有 state，也就说明函数组件可以通过 useState 改变 UI 视图。那么 useState 到底应该如何使用，底层又是怎么运作的呢，首先一起看一下 useState 。"}),"\n",(0,s.jsxs)(t.h3,{id:"usestate用法",children:["useState用法",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#usestate用法",children:"#"})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"基本用法"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:" [ ①state , ②dispatch ] = useState(③initData)\n"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"① state，目的提供给 UI ，作为渲染视图的数据源。"}),"\n",(0,s.jsx)(t.li,{children:"② dispatch 改变 state 的函数，可以理解为推动函数组件渲染的渲染函数。"}),"\n",(0,s.jsx)(t.li,{children:"③ initData 有两种情况，第一种情况是非函数，将作为 state 初始化的值。 第二种情况是函数，函数的返回值作为 useState 初始化的值。"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"initData  为非函数的情况:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"/* 此时将把 0 作为初使值 */\nconst [ number , setNumber ] = React.useState(0)\n"})}),"\n",(0,s.jsx)(t.p,{children:"initData 为函数的情况:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:" const [ number , setNumber ] = React.useState(()=>{\n       /*  props 中 a = 1 state 为 0-1 随机数 ， a = 2 state 为 1 -10随机数 ， 否则，state 为 1 - 100 随机数   */\n       if(props.a === 1) return Math.random() \n       if(props.a === 2) return Math.ceil(Math.random() * 10 )\n       return Math.ceil(Math.random() * 100 ) \n    })\n"})}),"\n",(0,s.jsx)(t.p,{children:"对于 dispatch的参数,也有两种情况："}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"第一种非函数情况，此时将作为新的值，赋予给 state，作为下一次渲染使用;"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"第二种是函数的情况，如果 dispatch 的参数为一个函数，这里可以称它为reducer，reducer 参数，是上一次返回最新的 state，返回值作为新的 state。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"dispatch 参数是一个非函数值"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const [ number , setNumber ] = React.useState(0)\n/* 一个点击事件 */\nconst handleClick=()=>{\n   setNumber(1)\n   setNumber(2)\n   setNumber(3)\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"dispatch 参数是一个函数"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const [ number , setNumber ] = React.useState(0)\nconst handleClick=()=>{\n   setNumber((state)=> state + 1)  // state - > 0 + 1 = 1\n   setNumber(8)  // state - > 8\n   setNumber((state)=> state + 1)  // state - > 8 + 1 = 9\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"如何监听 state 变化？"})}),"\n",(0,s.jsx)(t.p,{children:"类组件 setState 中，有第二个参数 callback 或者是生命周期componentDidUpdate 可以检测监听到 state 改变或是组件更新。"}),"\n",(0,s.jsx)(t.p,{children:"那么在函数组件中，如何怎么监听 state 变化呢？这个时候就需要 useEffect 出场了，通常可以把 state 作为依赖项传入 useEffect 第二个参数 deps ，但是注意 useEffect 初始化会默认执行一次。"}),"\n",(0,s.jsx)(t.p,{children:"具体可以参考如下 Demo :"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"export default function Index(props){\n    const [ number , setNumber ] = React.useState(0)\n    /* 监听 number 变化 */\n    React.useEffect(()=>{\n        console.log('监听number变化，此时的number是:  ' + number )\n    },[ number ])\n    const handerClick = ()=>{\n        /** 高优先级更新 **/\n        ReactDOM.flushSync(()=>{\n            setNumber(2) \n        })\n        /* 批量更新 */\n        setNumber(1) \n        /* 滞后更新 ，批量更新规则被打破 */\n        setTimeout(()=>{\n            setNumber(3) \n        })\n       \n    }\n    console.log(number)\n    return <div>\n        <span> { number }</span>\n        <button onClick={ handerClick }  >number++</button>\n    </div>\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"效果:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)("img",{src:c,alt:"01.jpg"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"dispatch"}),"更新特点"]})}),"\n",(0,s.jsx)(t.p,{children:"上述讲的批量更新和 flushSync ，在函数组件中，dispatch 更新效果和类组件是一样的，但是 useState 有一点值得注意，就是当调用改变 state 的函数dispatch，在本次函数执行上下文中，是获取不到最新的 state 值的，把上述demo 如下这么改："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"const [ number , setNumber ] = React.useState(0)\nconst handleClick = ()=>{\n    ReactDOM.flushSync(()=>{\n        setNumber(2) \n        console.log(number) \n    })\n    setNumber(1) \n    console.log(number)\n    setTimeout(()=>{\n        setNumber(3) \n        console.log(number)\n    })   \n}\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"结果： 0 0 0"})}),"\n",(0,s.jsx)(t.p,{children:"原因很简单，函数组件更新就是函数的执行，在函数一次执行过程中，函数内部所有变量重新声明，所以改变的 state ，只有在下一次函数组件执行时才会被更新。所以在如上同一个函数执行上下文中，number 一直为0，无论怎么打印，都拿不到最新的 state 。"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"useState注意事项"})}),"\n",(0,s.jsx)(t.p,{children:"在使用 useState 的 dispatchAction 更新 state 的时候，记得不要传入相同的 state，这样会使视图不更新。比如下面这么写："}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-js",children:"export default function Index(){\n    const [ state  , dispatchState ] = useState({ name:'alien' })\n    const  handleClick = ()=>{ // 点击按钮，视图没有更新。\n        state.name = 'Alien'\n        dispatchState(state) // 直接改变 `state`，在内存中指向的地址相同。\n    }\n    return <div>\n         <span> { state.name }</span>\n        <button onClick={ handleClick }  >changeName++</button>\n    </div>\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"如上例子\uD83C\uDF30中，当点击按钮后，发现视图没有改变，为什么会造成这个原因呢？"}),"\n",(0,s.jsx)(t.p,{children:"在 useState 的 dispatchAction 处理逻辑中，会浅比较两次 state ，发现 state 相同，不会开启更新调度任务； demo 中两次   state 指向了相同的内存空间，所以默认为 state 相等，就不会发生视图更新了。"}),"\n",(0,s.jsx)(t.p,{children:"解决问题： 把上述的 dispatchState 改成 dispatchState({...state}) 根本解决了问题，浅拷贝了对象，重新申请了一个内存空间。"}),"\n",(0,s.jsxs)(t.h3,{id:"usestate原理揭秘",children:["useState原理揭秘",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#usestate原理揭秘",children:"#"})]}),"\n",(0,s.jsx)(t.p,{children:"对于 useState 原理，后面会有独立的篇章介绍，这里就不多说了。"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"｜--------问与答---------｜"})}),"\n",(0,s.jsxs)(t.p,{children:["类组件中的 ",(0,s.jsx)(t.code,{children:"setState"})," 和函数组件中的 ",(0,s.jsx)(t.code,{children:"useState"})," 有什么异同？\n",(0,s.jsx)(t.strong,{children:"相同点："})]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"首先从原理角度出发，setState和 useState 更新视图，底层都调用了 scheduleUpdateOnFiber 方法，而且事件驱动情况下都有批量更新规则。"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"不同点"})}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"在不是 pureComponent 组件模式下， setState 不会浅比较两次 state 的值，只要调用 setState，在没有其他优化手段的前提下，就会执行更新。但是 useState 中的 dispatchAction 会默认比较两次 state 是否相同，然后决定是否更新组件。"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"setState 有专门监听 state 变化的回调函数 callback，可以获取最新state；但是在函数组件中，只能通过 useEffect 来执行 state 变化引起的副作用。"}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"setState 在底层处理逻辑上主要是和老 state 进行合并处理，而 useState 更倾向于重新赋值。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"｜--------end---------｜"})}),"\n",(0,s.jsxs)(t.h2,{id:"四-总结",children:["四 总结",(0,s.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#四-总结",children:"#"})]}),"\n",(0,s.jsx)(t.p,{children:"从本章节学到了哪些知识："}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"1 setState用法详解，底层更新流程。"}),"\n",(0,s.jsx)(t.li,{children:"2 useState用法详解，注意事项。"}),"\n",(0,s.jsx)(t.li,{children:"3 几种不同优先级的更新任务。"}),"\n"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let o=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F4.%E5%9F%BA%E7%A1%80%E7%AF%87-%E7%8E%84%E5%AD%A6%20state.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 类组件中的 state",id:"二-类组件中的-state",depth:2},{text:"setState用法",id:"setstate用法",depth:3},{text:"setState原理揭秘",id:"setstate原理揭秘",depth:3},{text:"三 函数组件中的state",id:"三-函数组件中的state",depth:2},{text:"useState用法",id:"usestate用法",depth:3},{text:"useState原理揭秘",id:"usestate原理揭秘",depth:3},{text:"四 总结",id:"四-总结",depth:2}],title:"4.基础篇-玄学 state",headingTitle:"4.基础篇-玄学 state",frontmatter:{}}}}]);