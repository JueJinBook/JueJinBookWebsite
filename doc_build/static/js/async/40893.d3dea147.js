"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["40893"],{974939:function(n,e,c){c.r(e),c.d(e,{default:()=>S});var a=c(552676),s=c(740453);let r=c.p+"static/image/f122ccabc1e8a1cd29c64ba002667a2a.78080000.webp",t=c.p+"static/image/ab5d9d0e7a8c671ad8422dc533925598.87827122.webp",i=c.p+"static/image/2d9ba56a362635b47ebea2881d450128.25c8ce0c.webp",l=c.p+"static/image/6069a0853de374dcdef01897deae2410.85800f60.webp",h=c.p+"static/image/c9cd90d6e93a2c6c9a6876f822ab5b95.7bb9913e.webp",d=c.p+"static/image/2d77f79b21bfe7d3e30419b6835e13bc.feca4a6a.webp",o=c.p+"static/image/0148c810b681df153085d017ece99112.8aef2f3b.webp",p=c.p+"static/image/1c0dcb37654d9cf4dc51b6930214eb62.0cbeeb52.webp",x=c.p+"static/image/c1f91884a5afbf0964b5b67013431982.aee02f91.webp",j=c.p+"static/image/bd9e84057edc818797d60da26101febd.3e179a4e.webp",u=c.p+"static/image/832e87026f3fad50c8a7cc60345508a9.7d1d5671.webp",m=c.p+"static/image/3ac958f75f2beb3773ddcd3ccda6fee1.d02afd78.webp",g=c.p+"static/image/f6ba10993811964c799ec28e4ce3c22e.512c2ad3.webp",b=c.p+"static/image/ab45599fc637f297ac15466a0cc3cf32.80709e8d.webp",f=c.p+"static/image/39708cbf2b5e70e03abd06c6b1e5e700.4caaea5b.webp",q=c.p+"static/image/8fd074fd39b7a870538bb1eda348949c.420e829b.webp",w=c.p+"static/image/84d18654853db02639298bfed7c1b57c.44f8304f.webp",Q=c.p+"static/image/6d61d58877a59805f352cf028986e993.9da866d8.webp",E=c.p+"static/image/0bee07774006c65ae9889b4531caf6cd.337548df.webp",k=c.p+"static/image/8ffa24e35950059b7d74d3c2d14d8c5a.539686e0.webp",B=c.p+"static/image/594280b4eb26c06181eba3ba709d83cc.153a92e8.webp",C=c.p+"static/image/889ffc1f5d791756d329a50ef65e5ab2.9b88f3ed.webp",A=c.p+"static/image/472d23e1266332c8e5b94577a9581989.ff814bfb.webp",M=c.p+"static/image/8f187da21acb022b8bf5301bd5b51e1c.364952f8.webp",v=c.p+"static/image/9489f2a1be3d15966ce602c2b8af3aa2.abe98431.webp";function N(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",ul:"ul",li:"li",strong:"strong",h2:"h2"},(0,s.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"152-为什么前端监控系统要用-rabbitmq",children:["152. 为什么前端监控系统要用 RabbitMQ？",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#152-为什么前端监控系统要用-rabbitmq",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"前端监控系统是采集用户端的异常、性能、业务埋点等数据上报，在服务端做存储，并支持可视化分析的平台。"}),"\n",(0,a.jsx)(e.p,{children:"用户量可能很大，采集的数据可能比较多，这时候服务端的并发压力会比较大，要是直接存入数据库，那数据库服务很可能会崩掉。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:v,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"那就用现在的数据库，如何保证面对大量并发请求的时候，服务不崩呢？"}),"\n",(0,a.jsx)(e.p,{children:"答案就是消息队列，比如常用的 RabbitMQ："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:M,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"第一个 web 服务接收请求，把消息存入 RabbitMQ，然后另一个 web 服务从 MQ 中取出消息存入数据库。"}),"\n",(0,a.jsx)(e.p,{children:"有同学说，这不是一样么？"}),"\n",(0,a.jsx)(e.p,{children:"不一样，MQ 的并发量比数据库高很多。之前 web 服务要等数据库存储完成才能响应，而现在只存入 MQ 就可以响应了。那可以支持的并发量就更多。"}),"\n",(0,a.jsx)(e.p,{children:"而数据库的并发比较低，我们可以通过 MQ 把消费的上限调低，就能保证数据库服务不崩。"}),"\n",(0,a.jsx)(e.p,{children:"比如 10w 的消息进来，每次只从中取出 1000 来消费："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:A,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"并发量被控制住了，自然就崩不了了，从 MQ 中取出慢慢处理就好了。"}),"\n",(0,a.jsx)(e.p,{children:"这就是 MQ 的流量削峰的功能。"}),"\n",(0,a.jsx)(e.p,{children:"而且完全可以加几个 web 服务来同时消费 MQ 中的消息："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:C,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"知道了 RabbitMQ 能干啥，那我们就来用一下试试吧！"}),"\n",(0,a.jsx)(e.p,{children:"我们通过 docker 来跑 RabbitMQ。"}),"\n",(0,a.jsx)(e.p,{children:"搜索 rabbitmq 的镜像，选择 3.11-management 的版本："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:B,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这个版本是有 web 管理界面的。"}),"\n",(0,a.jsx)(e.p,{children:"点击 run："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:k,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"映射容器内的 5672、15672 这俩端口到本地的端口。"}),"\n",(0,a.jsx)(e.p,{children:"15672 是管理界面的，5672 是 mq 服务的端口。"}),"\n",(0,a.jsx)(e.p,{children:"等 rabbitmq 跑起来之后："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:E,alt:""})}),"\n",(0,a.jsxs)(e.p,{children:["就可以在浏览器访问 ",(0,a.jsx)(e.a,{href:"http://localhost:15672",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:15672"})," 了："]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:Q,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这就是它的 web 管理界面。"}),"\n",(0,a.jsx)(e.p,{children:"输入 guest、guest 进入管理页面："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:w,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到 connection、channel、exchange、queue 的分别的管理页面。"}),"\n",(0,a.jsx)(e.p,{children:"这些都是什么呢？"}),"\n",(0,a.jsx)(e.p,{children:"写个 demo 就理解了："}),"\n",(0,a.jsx)(e.p,{children:"创建个项目："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"mkdir rabbitmq-test\n\ncd rabbitmq-test\n\nnpm init -y\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:q,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"安装用到的包："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"npm install amqplib\n"})}),"\n",(0,a.jsx)(e.p,{children:"创建 src/producer.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertQueue('aaa');\nawait channel.sendToQueue('aaa',Buffer.from('hello'))\n"})}),"\n",(0,a.jsx)(e.p,{children:"安装 amqplib 的包，这个是 rabbitmq 的 node 客户端（amqp 是 rabbitmq 的协议）。"}),"\n",(0,a.jsx)(e.p,{children:"上面的代码连接了 rabbitmq 服务，创建了一个名字为 aaa 的队列，并向队列中发送了一个消息。"}),"\n",(0,a.jsx)(e.p,{children:"然后 node 跑一下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node ./src/producer.js\n"})}),"\n",(0,a.jsx)(e.p,{children:"（这里要用 es module 语法并且支持顶层 await 需要在 packege.json 里设置 type 为 module）"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:f,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"之后就可以在管理界面看到这个队列了："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"然后我们再写一个消费端 src/consumer.js："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nconst { queue } = await channel.assertQueue('aaa');\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n"})}),"\n",(0,a.jsx)(e.p,{children:"assertQueue 是如果没有就创建队列，有的话就直接返回。"}),"\n",(0,a.jsx)(e.p,{children:"这里取到那个队列，就可以从中消费消息了："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/consumer.js\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这样，我们就完成了第一次 RabbitMQ 的通信，两个服务之间也是这样通信的。"}),"\n",(0,a.jsx)(e.p,{children:"是不是还挺简单的？"}),"\n",(0,a.jsx)(e.p,{children:"rabbitmq 使用确实挺简单。"}),"\n",(0,a.jsx)(e.p,{children:"那怎么控制并发数呢？"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"我们改一下 src/producer.js："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertQueue('aaa', {durable: false});\n\nlet i = 1;\nsetInterval(async () => {\n    const msg = 'hello' + i;\n    console.log('发送消息：', msg);\n    await channel.sendToQueue('aaa',Buffer.from(msg))\n    i++;\n}, 500);\n"})}),"\n",(0,a.jsx)(e.p,{children:"生产者每 0.5s 发送一次消息。"}),"\n",(0,a.jsx)(e.p,{children:"消费者每 1s 处理一条消息："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nconst { queue } = await channel.assertQueue('aaa');\nchannel.prefetch(3);\n\nconst currentTask = [];\nchannel.consume(queue, msg => {\n    currentTask.push(msg);\n    console.log('收到消息：', msg.content.toString());\n}, { noAck: false });\n\nsetInterval(() => {\n    const curMsg = currentTask.pop();\n    channel.ack(curMsg);\n}, 1000);\n"})}),"\n",(0,a.jsx)(e.p,{children:"每条消费者收到的消息要确认之后才会在 MQ 里删除。可以收到消息自动确认，也可以手动确认。"}),"\n",(0,a.jsx)(e.p,{children:"这里我把 noAck 设置为 false 了，也就是不自动确认。"}),"\n",(0,a.jsx)(e.p,{children:"把收到的消息放入一个数组中，每 1s 确认一次。"}),"\n",(0,a.jsx)(e.p,{children:"然后我设置了 prefetch 为 3，也就是每次最多取回 3 条消息来处理。"}),"\n",(0,a.jsx)(e.p,{children:"跑一下试试："}),"\n",(0,a.jsx)(e.p,{children:"消息生产端："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node ./src/producer.js\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:j,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"消息消费端："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node ./src/consumer.js\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到生产者是每 0.5s 往队列里放一条消息。"}),"\n",(0,a.jsx)(e.p,{children:"消费者一开始取出 3 条，然后每处理完一条取一条，保证最多并发处理 3 条。"}),"\n",(0,a.jsx)(e.p,{children:"这就是流量削峰的功能。"}),"\n",(0,a.jsx)(e.p,{children:"不同服务之间的速度差异可以通过 MQ 来缓冲。"}),"\n",(0,a.jsx)(e.p,{children:"大概了解了 rabbitmq 之后，我们来看看它的整体架构图："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"Producer 和 Consumer 分别是生产者和消费者。"}),"\n",(0,a.jsx)(e.p,{children:"Connection 是连接，但我们不会每用一次 rabbitmq 就创建一个单独的 Connection，而是在一个 Connection 里做一下划分，叫做 Channel，每个 Channel 做自己的事情。"}),"\n",(0,a.jsx)(e.p,{children:"而 Queue 就是两端存取消息的地方了。"}),"\n",(0,a.jsx)(e.p,{children:"整个接收消息和转发消息的服务就叫做 Broker。"}),"\n",(0,a.jsx)(e.p,{children:"至于 Exchange，我们前面的例子没有用到，这个是把消息放到不同的队列里用的，叫做交换机。"}),"\n",(0,a.jsx)(e.p,{children:"我们前面生产者和消费者都是直接指定了从哪个队列存取消息，那如果是一对多的场景呢？"}),"\n",(0,a.jsx)(e.p,{children:"总不能一个个的调用 sendQueue 发消息吧？"}),"\n",(0,a.jsx)(e.p,{children:"这时候就要找一个 Exchange（交换机） 来帮我们完成把消息按照规则放入不同的 Queue 的工作了。"}),"\n",(0,a.jsx)(e.p,{children:"Exchange 主要有 4 种："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"fanout：把消息放到这个交换机的所有 Queue"}),"\n",(0,a.jsx)(e.li,{children:"direct：把消息放到交换机的指定 key 的队列"}),"\n",(0,a.jsx)(e.li,{children:"topic：把消息放到交换机的指定 key 的队列，支持模糊匹配"}),"\n",(0,a.jsx)(e.li,{children:"headers：把消息放到交换机的满足某些 header 的队列"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"一个个来试下："}),"\n",(0,a.jsx)(e.p,{children:"首先是 direct，生产者端 src/direct.js："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange', 'direct');\n\nchannel.publish('direct-test-exchange', 'aaa',  Buffer.from('hello1'));\nchannel.publish('direct-test-exchange', 'bbb',  Buffer.from('hello2'));\nchannel.publish('direct-test-exchange', 'ccc',  Buffer.from('hello3'));\n"})}),"\n",(0,a.jsx)(e.p,{children:"不再是直接 sendToQueue 了，而是创建一个 exchange，然后调用 publish 往这个 exchange 发消息。"}),"\n",(0,a.jsx)(e.p,{children:"其中第二个参数是 routing key，也就是消息路由到哪个队列。"}),"\n",(0,a.jsx)(e.p,{children:"然后创建两个消费者："}),"\n",(0,a.jsx)(e.p,{children:"src/direct-consumer1.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nconst { queue } = await channel.assertQueue('queue1');\nawait channel.bindQueue(queue,  'direct-test-exchange', 'aaa');\n\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n"})}),"\n",(0,a.jsx)(e.p,{children:"src/direct-consumer2.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nconst { queue } = await channel.assertQueue('queue2');\nawait channel.bindQueue(queue,  'direct-test-exchange', 'bbb');\n\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n\n"})}),"\n",(0,a.jsx)(e.p,{children:"分别创建 queue1 和 queue2 两个队列，绑定到前面创建的 direct-test-exchange 这个交换机上，指定了路由 key 分别是 aaa 和 bbb。"}),"\n",(0,a.jsx)(e.p,{children:"然后把生产者和两个消费者跑起来。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/direct.js\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/direct-consumer1.js\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/direct-consumer2.js\n"})}),"\n",(0,a.jsx)(e.p,{children:"就可以看到队列 queue1 和 queue2 分别接收到了对应的消息："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这就是通过 direct 交换机发送消息的过程。"}),"\n",(0,a.jsx)(e.p,{children:"在管理页面上也可以看到这个交换机的信息："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"包括 exchange 下的两个 queue 以及各自的 routing key。"}),"\n",(0,a.jsx)(e.p,{children:"再来试下 topic 类型的 Exchange。"}),"\n",(0,a.jsx)(e.p,{children:"src/topic.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange2', 'topic');\n\nchannel.publish('direct-test-exchange2', 'aaa.1',  Buffer.from('hello1'));\nchannel.publish('direct-test-exchange2', 'aaa.2',  Buffer.from('hello2'));\nchannel.publish('direct-test-exchange2', 'bbb.1',  Buffer.from('hello3'));\n"})}),"\n",(0,a.jsx)(e.p,{children:"生产者端创建叫 direct-test-exchange2 的 topic 类型的 Exchange，然后发三条消息。"}),"\n",(0,a.jsx)(e.p,{children:"创建两个消费端："}),"\n",(0,a.jsx)(e.p,{children:"src/topic-consumer1.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange2', 'topic');\n\nconst { queue } = await channel.assertQueue('queue1');\nawait channel.bindQueue(queue,  'direct-test-exchange2', 'aaa.*');\n\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n"})}),"\n",(0,a.jsx)(e.p,{children:"src/topic-consumer2.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange2', 'topic');\n\nconst { queue } = await channel.assertQueue('queue2');\nawait channel.bindQueue(queue,  'direct-test-exchange2', 'bbb.*');\n\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n"})}),"\n",(0,a.jsx)(e.p,{children:"两个消费者端分别创建 queue1 和 queue2 两个队列，绑定到 direct-test-exchange2 的交换机下。"}),"\n",(0,a.jsx)(e.p,{children:"指定路由 key 分别为 aaa.* 和 bbb.*，这里的 * 是模糊匹配的意思。"}),"\n",(0,a.jsx)(e.p,{children:"消费者端也 assertExchange 了，如果不存在就创建，保证 exchange 一定存在。"}),"\n",(0,a.jsx)(e.p,{children:"然后跑一下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/topic.js\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/topic-consumer1.js\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/topic-consumer2.js\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，两个消费者分别收到了不同 routing key 对应的消息。"}),"\n",(0,a.jsx)(e.p,{children:"当然，在管理界面这里也是可以发消息的："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"消费者端同样可以收到："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这就是 topic 类型的交换机，可以根据模糊匹配 routing key 来发消息到不同队列。"}),"\n",(0,a.jsx)(e.p,{children:"再来试下 fanout 类型的 exchange："}),"\n",(0,a.jsx)(e.p,{children:"生产者："}),"\n",(0,a.jsx)(e.p,{children:"src/fanout.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange3', 'fanout');\n\nchannel.publish('direct-test-exchange3', '',  Buffer.from('hello1'));\nchannel.publish('direct-test-exchange3', '',  Buffer.from('hello2'));\nchannel.publish('direct-test-exchange3', '',  Buffer.from('hello3'));\n"})}),"\n",(0,a.jsx)(e.p,{children:"消费者："}),"\n",(0,a.jsx)(e.p,{children:"src/fanout-consumer1.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange3', 'fanout');\n\nconst { queue } = await channel.assertQueue('queue1');\nawait channel.bindQueue(queue,  'direct-test-exchange3', 'aaa');\n\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n"})}),"\n",(0,a.jsx)(e.p,{children:"src/fanout-consumer2.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange3', 'fanout');\n\nconst { queue } = await channel.assertQueue('queue2');\nawait channel.bindQueue(queue,  'direct-test-exchange3', 'bbb');\n\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n"})}),"\n",(0,a.jsx)(e.p,{children:"fanout 是广播消息到 Exchange 下的所有队列，不需要指定 routing key，计算指定了也会忽略。"}),"\n",(0,a.jsx)(e.p,{children:"跑起来可以看到，两个消费者都收到了消息："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/fanout.js\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/fanout-consumer1.js\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/fanout-consumer2.js\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这就是 fanout 类型交换机的特点，广播消息到所有绑定到它的 queue。"}),"\n",(0,a.jsx)(e.p,{children:"最后再来看下 headers 类型的 Exchange，这个不是根据 routing key 来匹配了，而是根据 headers："}),"\n",(0,a.jsx)(e.p,{children:"生产者端："}),"\n",(0,a.jsx)(e.p,{children:"src/headers.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange4', 'headers');\n\nchannel.publish('direct-test-exchange4', '',  Buffer.from('hello1'), {\n    headers: {\n        name: 'guang'\n    }\n});\nchannel.publish('direct-test-exchange4', '',  Buffer.from('hello2'), {\n    headers: {\n        name: 'guang'\n    }\n});\nchannel.publish('direct-test-exchange4', '',  Buffer.from('hello3'), {\n    headers: {\n        name: 'dong'\n    }\n});\n"})}),"\n",(0,a.jsx)(e.p,{children:"消费者端："}),"\n",(0,a.jsx)(e.p,{children:"src/headers-consumer1.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange4', 'headers');\n\nconst { queue } = await channel.assertQueue('queue1');\nawait channel.bindQueue(queue,  'direct-test-exchange4', '', {\n    name: 'guang'\n});\n\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n"})}),"\n",(0,a.jsx)(e.p,{children:"src/headers-consumer2.js"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import * as amqp from 'amqplib'\n\nconst connect = await amqp.connect(`amqp://localhost:5672`);\nconst channel = await connect.createChannel();\n\nawait channel.assertExchange('direct-test-exchange4', 'headers');\n\nconst { queue } = await channel.assertQueue('queue2');\nawait channel.bindQueue(queue,  'direct-test-exchange4', '', {\n    name: 'dong'\n});\n\nchannel.consume(queue, msg => {\n    console.log(msg.content.toString())\n}, { noAck: true });\n"})}),"\n",(0,a.jsx)(e.p,{children:"跑起来是这样的："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/headers.js\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/headers-consumer1.js\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"node src/headers-consumer2.js\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:r,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"很容易理解，只是从匹配 routing key 变成了匹配 header。"}),"\n",(0,a.jsx)(e.p,{children:"这就是 Exchange，当你需要一对多发消息的时候，就可以选择这些类型的交换机。"}),"\n",(0,a.jsx)(e.p,{children:"回过头来，我们来总结下 rabbitmq 解决了什么问题："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"流量削峰"}),"：可以把很大的流量放到 mq 种按照一定的流量上限来慢慢消费，这样虽然慢一点，但不至于崩溃。"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"应用解耦"}),"：应用之间不再直接依赖，就算某个应用挂掉了，也可以再恢复后继续从 mq 中消费消息。并不会一个应用挂掉了，它关联的应用也挂掉。"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"比如前端监控系统的后端服务，就很适合使用 mq 来做流量削峰。"}),"\n",(0,a.jsxs)(e.p,{children:["案例代码在",(0,a.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/rabbitmq-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,a.jsxs)(e.h2,{id:"总结",children:["总结",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"前端监控系统会收到很多来自用户端的请求，如果直接存入数据库很容易把数据库服务搞挂掉，所以一般会加一个 RabbitMQ 来缓冲。"}),"\n",(0,a.jsx)(e.p,{children:"它是生产者往 queue 里放入消息，消费者从里面读消息，之后确认消息收到的流程。"}),"\n",(0,a.jsx)(e.p,{children:"当一对多的时候，还要加一个 Exchange 交换机来根据不同的规则转发消息："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"direct 交换机：根据 routing key 转发消息到队列"}),"\n",(0,a.jsx)(e.li,{children:"topic 交换机：根据 routing key 转发消息到队列，支持模糊匹配"}),"\n",(0,a.jsx)(e.li,{children:"headers 交换机：根据 headers 转发消息到队列"}),"\n",(0,a.jsx)(e.li,{children:"fanout 交换机：广播消息到交换机下的所有队列"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"而且消费者可以设置一个消费的并发上限，这样就可以保证服务不会因并发过高而崩溃。"}),"\n",(0,a.jsx)(e.p,{children:"这就是流量削峰的功能。"}),"\n",(0,a.jsx)(e.p,{children:"RabbitMQ 在后端系统中经常能见到，是很常用的中间件。"})]})}function y(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(N,{...n})}):N(n)}let S=y;y.__RSPRESS_PAGE_META={},y.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F152.%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%94%A8%20RabbitMQ%EF%BC%9F.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"152. 为什么前端监控系统要用 RabbitMQ？",headingTitle:"152. 为什么前端监控系统要用 RabbitMQ？",frontmatter:{}}}}]);