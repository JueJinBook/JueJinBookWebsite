"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18243"],{396518:function(n,e,s){s.r(e),s.d(e,{default:()=>a});var r=s(552676),i=s(740453);function t(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"32手写-babel-core篇",children:["32.手写 Babel： core篇",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#32手写-babel-core篇",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"core 包的功能是串联整个编译流程，并且实现插件和 preset。"}),"\n",(0,r.jsx)(e.p,{children:"这节我们来实现一下 core 包。"}),"\n",(0,r.jsxs)(e.h2,{id:"思路分析",children:["思路分析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"前面，我们实现了 parser、traverse、generator 包，使用方式是这样的："}),"\n",(0,r.jsx)(e.p,{children:"分别调用 parse、traverse、generate，来完成源码的 parse、AST 的遍历和修改，以及目标代码和 sourcemap 的打印。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const sourceCode = `\nconst c = 1;\nconst d = 2;\nconst e = 4;\n\nfunction add(a, b) {\n    const tmp = 1;\n    return a + b;\n}\n\nadd(c, d);\n`;\n\nconst ast = parser.parse(sourceCode, {\n    plugins: ['literal', 'guangKeyword']\n});\n\ntraverse(ast, {\n    Program(path) {\n       Object.entries(path.scope.bindings).forEach(([id, binding]) => {\n        if (!binding.referenced) {\n            binding.path.remove();\n        }\n       });\n    }\n});\n\nconst { code, map} = generate(ast, sourceCode, 'foo.js');\nconsole.log(code);\nconsole.log(map);\n"})}),"\n",(0,r.jsx)(e.p,{children:"而如果用了 core 包，使用方式是这样的："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function plugin1(api, options) {\n    return {\n        visitor: {\n            Program(path) {\n               Object.entries(path.scope.bindings).forEach(([id, binding]) => {\n                    if (!binding.referenced) {\n                        binding.path.remove();\n                    }\n                });\n            }\n    }\n}\nconst { code, map } = transformSync(sourceCode, {\n    parserOpts: {\n        plugins: ['literal']\n    },\n    fileName: 'foo.js',\n    plugins: [\n        [plugin1, {}]\n    ],\n    presets: []\n});\n"})}),"\n",(0,r.jsx)(e.p,{children:"可以看到，transformSync 封装了 parse、traverse、generate 的逻辑，并且还实现了插件和 preset 机制。"}),"\n",(0,r.jsx)(e.p,{children:"集成 parse、traverse、generate 比较简单，但插件和 preset 是怎么实现的呢？"}),"\n",(0,r.jsx)(e.p,{children:"插件是一个函数返回包含 visitor 的对象，我们只要把各种通过 options 传入的插件，在 transformSync 里面合并，之后把合并后的 visitors 传入  traverse 方法就可以了。"}),"\n",(0,r.jsx)(e.p,{children:"而 preset 是插件的集合，调用函数返回插件数组，之后再调用插件返回 visitor 等，然后 visitor，调用 traverse。"}),"\n",(0,r.jsx)(e.p,{children:"此外要注意的是 babel 插件的顺序是先 plugin 后 preset，plugin 从前往后、preset 从后往前。"}),"\n",(0,r.jsxs)(e.h2,{id:"代码实现",children:["代码实现",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"首先我们集成 parse、traverse、generate 3步："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function transformSync(code, options) {\n    const ast = parser.parse(code, options.parserOpts);\n\n    const visitors = {};\n\n    traverse(ast, visitors);\n    return generate(ast, code, options.fileName);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这里的 visitor 就是插件里面 visitor 的合并，我们实现下插件机制："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function transformSync(code, options) {\n    const ast = parser.parse(code, options.parserOpts);\n\n    const pluginApi = {\n        template\n    }\n    const visitors = {};\n    options.plugins && options.plugins.forEach(([plugin, options]) => {\n        const res = plugin(pluginApi, options);\n        Object.assign(visitors, res.visitor);\n    });\n\n    traverse(ast, visitors);\n    return generate(ast, code, options.fileName);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"其实比较简单，就是调用 options 里面的 plugin，传入 options、api，然后把返回的 visitor 合并，之后传入 traverse。"}),"\n",(0,r.jsx)(e.p,{children:"而 preset 是插件的集合，所以要多调用一层，并且因为顺序是从右往左，所以要 reverse 一下。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"options.presets && options.presets.reverse().forEach(([preset, options]) => {\n    const plugins = preset(pluginApi, options);\n    plugins.forEach(([plugin, options])=> {\n        const res = plugin(pluginApi, options);\n        Object.assign(visitors, res.visitor);\n    })\n})\n"})}),"\n",(0,r.jsx)(e.p,{children:"完整代码如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function transformSync(code, options) {\n    const ast = parser.parse(code, options.parserOpts);\n\n    const pluginApi = {\n        template\n    }\n    const visitors = {};\n    options.plugins && options.plugins.forEach(([plugin, options]) => {\n        const res = plugin(pluginApi, options);\n        Object.assign(visitors, res.visitor);\n    });\n    options.presets && options.presets.reverse().forEach(([preset, options]) => {\n        const plugins = preset(pluginApi, options);\n        plugins.forEach(([plugin, options])=> {\n            const res = plugin(pluginApi, options);\n            Object.assign(visitors, res.visitor);\n        })\n    })\n\n    traverse(ast, visitors);\n    return generate(ast, code, options.fileName);\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"core 包集成了 parser、traverse、generator 等包，并且实现了 plugin、preset 机制。"}),"\n",(0,r.jsx)(e.p,{children:"我们会把插件返回的 visitor 做合并，然后作为 visitor 调用 traverse。"}),"\n",(0,r.jsx)(e.p,{children:"插件是一个函数，传入可用的 api 以及调用时传入的 options，返回 visitor 等，而 preset 是插件的集合，要调用 preset 之后拿到插件集合，之后再调用具体的插件，最后把所有 visitor 做合并。"}),"\n",(0,r.jsx)(e.p,{children:"babel 是微内核架构，就是因为核心只实现了编译流程，具体的转换功能都是通过插件来实现的，而 preset 则是为了简化用户使用 babel 的成本而引入的一种机制，是插件的集合，让用户不需要直接配置具体的插件，选择不同的 preset 即可。"}),"\n",(0,r.jsxs)(e.p,{children:["（代码在",(0,r.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(t,{...n})}):t(n)}let a=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F32.%E6%89%8B%E5%86%99%20Babel%EF%BC%9A%20core%E7%AF%87.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"总结",id:"总结",depth:2}],title:"32.手写 Babel： core篇",headingTitle:"32.手写 Babel： core篇",frontmatter:{}}}}]);