"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["20753"],{519511:function(n,e,t){t.r(e),t.d(e,{default:()=>l});var r=t(552676),i=t(740453);let o=t.p+"static/image/323d132955b7263f021c862b6166f0bd.34c59da7.png",c=t.p+"static/image/9e29d99975bd51df0c41c9899f848bc0.c3ef1fa3.png";function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",blockquote:"blockquote",ul:"ul",li:"li",img:"img"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"6方案了解动态-script-方案",children:["6.方案了解：动态 Script 方案",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#6方案了解动态-script-方案",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在上一节课程中，我们通过封装 NPM 包的方式实现了微前端，该方案需要我们设计时导出 ",(0,r.jsx)(e.code,{children:"mount"})," 和 ",(0,r.jsx)(e.code,{children:"unmount"})," API，从而可以使主应用进行微应用的加载和卸载处理。NPM 包形式的微应用发布后，往往需要主应用升级相应 NPM 版本依赖并进行构建处理。如果想要主应用具备线上动态的微应用管理能力，最简单的方案是动态加载 Script。"]}),"\n",(0,r.jsxs)(e.h2,{id:"动态-script-方案",children:["动态 Script 方案",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#动态-script-方案",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"如果想要主应用具备线上动态的微应用管理能力，最简单的方案是动态加载 Script，大致的示例如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    \x3c!-- 主导航设计，这里可以根据后端数据动态渲染导航 --\x3e\n    <div id="nav">\n      <button onclick="handleClick(\'x\')">x 应用</button>\n      <button onclick="handleClick(\'y\')">y 应用</button>\n    </div>\n    \x3c!-- 内容区设计 --\x3e\n    <div class="container">\n      \x3c!-- 微应用渲染的插槽 --\x3e\n      <div id="micro-app-slot"></div>\n    </div>\n\n    \x3c!-- 微应用 x：提供 window.xMount 和 window.xUnmount 全局函数--\x3e\n    <script defer src="http://xxx/x.js"><\/script>\n    \x3c!-- 微应用 y：提供 window.yMount 和 window.yUnmount 全局函数--\x3e\n    <script defer src="http://yyy/y.js"><\/script>\n\n    <script>\n      function handleClick(type) {\n        switch (type) {\n          case "x":\n            // 告诉微应用需要挂载在 #micro-app-slot 元素上\n            window.xMount("#micro-app-slot");\n            window.yUnmount();\n          case "y":\n            window.yMount("#micro-app-slot");\n            window.xUnmount();\n          default:\n            break;\n        }\n      }\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：该示例中一个时刻只加载一个微应用。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"上述只是一个简单的示例，在真正的设计时可以将导航和需要加载的微应用进行动态化，这里给出一个相对完整的示例，大概实现的思路如下所示，主应用 HTML 渲染之后："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"通过请求获取微应用列表数据，动态进行微应用的预获取和导航创建处理"}),"\n",(0,r.jsx)(e.li,{children:"根据导航进行微应用的切换，切换的过程会动态加载和执行 JS 和 CSS 资源"}),"\n",(0,r.jsxs)(e.li,{children:["微应用需要提供 ",(0,r.jsx)(e.code,{children:"mount"})," 和 ",(0,r.jsx)(e.code,{children:"unmount"})," 全局函数，方便主应用进行加载和卸载处理"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：这里点击导航改变 Hash 来模拟 Vue 或者 React 框架中路由的切换。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"实现效果如下所示，图中的两个按钮（微应用导航）根据后端数据动态渲染，点击按钮后会请求微应用的静态资源并解析相应的 JS 和 CSS，并渲染微应用的文本信息到插槽中："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：主应用中的文本样式会被切换的微应用样式污染，从一开始的红色变成绿色或蓝色。首次点击按钮加载微应用的静态资源时会命中 ",(0,r.jsx)(e.code,{children:"prefetch cache"}),"，从而缩短应用资源的加载时间（不会发送请求给服务端），再次点击按钮请求资源时会命中缓存，状态码是 304。关于缓存会在后续的性能优化课程中详细讲解。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"文件的结构目录如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"├── public                  # 托管的静态资源目录\n│   ├── main/               # 主应用资源目录                        \n│   │   └── index.html                                        \n│   └── micro/              # 微应用资源目录\n│        ├── micro1.css   \n│        ├── micro1.js    \n│        ├── micro2.css         \n│        └── micro2.js      \n├── config.js               # 公共配置\n├── main-server.js          # 主应用服务\n└── micro-server.js         # 微应用服务\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/dynamic-script",target:"_blank",rel:"noopener noreferrer",children:"demo/dynamic-script"})," 分支获取。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"主应用 HTML 的实现代码如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-html",children:'\x3c!-- public/main/index.html --\x3e\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n    <style>\n      h1 {\n        color: red;\n      }\n    </style>\n  </head>\n\n  <body>\n    \x3c!-- 主应用的样式会被微应用覆盖 --\x3e\n    <h1>Hello，Dynamic Script!</h1>\n    \x3c!-- 主导航设计，这里可以根据后端数据动态渲染 --\x3e\n    <div id="nav"></div>\n    \x3c!-- 内容区设计 --\x3e\n    <div class="container">\n      \x3c!-- 微应用渲染的插槽 --\x3e\n      <div id="micro-app-slot"></div>\n    </div>\n\n    \x3c!-- 微应用工具类 --\x3e\n    <script type="text/javascript">\n      class UtilsManager {\n        constructor() {}\n\n        // API 接口管理\n        getMicroApps() {\n          return window\n            .fetch("/microapps", {\n              method: "post",\n            })\n            .then((res) => res.json())\n            .catch((err) => {\n              console.error(err);\n            });\n        }\n\n        isSupportPrefetch() {\n          const link = document.createElement("link");\n          const relList = link?.relList;\n          return relList && relList.supports && relList.supports("prefetch");\n        }\n\n        // 预请求资源，注意此种情况下不会执行 JS\n         // 后续在性能优化的课程中还会讲解，暂时可以忽略\n        prefetchStatic(href, as) {\n          // prefetch 浏览器支持检测\n          if (!this.isSupportPrefetch()) {\n            return;\n          }\n          const $link = document.createElement("link");\n          $link.rel = "prefetch";\n          $link.as = as;\n          $link.href = href;\n          document.head.appendChild($link);\n        }\n\n        // 请求 & 执行 JS（这里封装的不是很通用，可以考虑更加通用的封装处理）\n        loadScript({ script, id }) {\n          return new Promise((resolve, reject) => {\n            const $script = document.createElement("script");\n            $script.src = script;\n            $script.setAttribute("micro-script", id);\n            $script.onload = resolve;\n            $script.onerror = reject;\n            document.body.appendChild($script);\n          });\n        }\n\n        loadStyle({ style, id }) {\n          return new Promise((resolve, reject) => {\n            const $style = document.createElement("link");\n            $style.href = style;\n            $style.setAttribute("micro-style", id);\n            $style.rel = "stylesheet";\n            $style.onload = resolve;\n            $style.onerror = reject;\n            document.head.appendChild($style);\n          });\n        }\n\n        // 为什么需要删除 CSS 样式？不删除会有什么后果吗？\n        // 为什么没有删除 JS 文件的逻辑呢？\n        removeStyle({ id }) {\n          const $style = document.querySelector(`[micro-style=${id}]`);\n          $style && $style?.parentNode?.removeChild($style);\n        }\n\n        hasLoadScript({ id }) {\n          const $script = document.querySelector(`[micro-script=${id}]`);\n          return !!$script;\n        }\n\n        hasLoadStyle({ id }) {\n          const $style = document.querySelector(`[micro-style=${id}]`);\n          return !!$style;\n        }\n      }\n    <\/script>\n\n    \x3c!-- 根据路由切换微应用 --\x3e\n    <script type="text/javascript">\n      // 微应用管理\n      class MicroAppManager extends UtilsManager {\n        micrpApps = [];\n\n        constructor() {\n          super();\n          this.init();\n        }\n\n        init() {\n          this.processMicroApps();\n          this.navClickListener();\n          this.hashChangeListener();\n        }\n\n        processMicroApps() {\n          this.getMicroApps().then((res) => {\n            this.microApps = res;\n            this.prefetchMicroAppStatic();\n            this.createMicroAppNav();\n          });\n        }\n\n        prefetchMicroAppStatic() {\n          const prefetchMicroApps = this.microApps?.filter(\n            (microapp) => microapp.prefetch\n          );\n          prefetchMicroApps?.forEach((microApp) => {\n            microApp.script && this.prefetchStatic(microApp.script, "script");\n            microApp.style && this.prefetchStatic(microApp.style, "style");\n          });\n        }\n\n        createMicroAppNav(microApps) {\n          const fragment = new DocumentFragment();\n          this.microApps?.forEach((microApp) => {\n            // TODO: APP 数据规范检测 (例如是否有 script、mount、unmount 等）\n            const button = document.createElement("button");\n            button.textContent = microApp.name;\n            button.id = microApp.id;\n            fragment.appendChild(button);\n          });\n          const nav = document.getElementById("nav");\n          nav.appendChild(fragment);\n        }\n\n        navClickListener() {\n          const nav = document.getElementById("nav");\n          nav.addEventListener("click", (e) => {\n            // 并不是只有 button 可以触发导航变更，例如 a 标签也可以，因此这里不直接处理微应用切换，只是改变 Hash 地址\n            // 不会触发刷新，类似于框架的 Hash 路由\n            window.location.hash = event?.target?.id;\n          });\n        }\n\n        hashChangeListener() {\n          // 监听 Hash 路由的变化，切换微应用\n          // 这里设定一个时刻页面上只有一个微应用\n          window.addEventListener("hashchange", () => {\n            this.microApps?.forEach(async (microApp) => {\n              // 匹配需要激活的微应用\n              if (microApp.id === window.location.hash.replace("#", "")) {\n                console.time(`fetch microapp ${microApp.name} static`);\n                // 加载 CSS 样式\n                microApp?.style &&\n                  !this.hasLoadStyle(microApp) &&\n                  (await this.loadStyle(microApp));\n                // 加载 Script 标签\n                microApp?.script &&\n                  !this.hasLoadScript(microApp) &&\n                  (await this.loadScript(microApp));\n                console.timeEnd(`fetch microapp ${microApp.name} static`);\n                window?.[microApp.mount]?.("#micro-app-slot");\n                // 如果存在卸载 API 则进行应用卸载处理\n              } else {\n                this.removeStyle(microApp);\n                window?.[microApp.unmount]?.();\n              }\n            });\n          });\n        }\n      }\n\n      new MicroAppManager();\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：在微应用切换的执行逻辑中，为什么需要删除 CSS 样文件？那为什么不删除 JS 文件呢？删除 JS 文件会有什么副作用吗？假设删除 ",(0,r.jsx)(e.code,{children:"micro1.js"}),"，那么还能获取 ",(0,r.jsx)(e.code,{children:"window.micro1_mount"})," 吗？如果能够获取，浏览器为什么不在删除 JS 的同时进行内存释放处理呢？如果释放，会有什么副作用呢？"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"微应用的设计如下所示（完全可以替换成 React 或者 Vue 框架打包的 JS 脚本和 CSS 资源）："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// micro1.js\n// 立即执行的匿名函数可以防止变量 root 产生冲突\n(function () {\n  let root;\n\n  window.micro1_mount = function (slot) {\n    // 以下其实可以是 React 框架或者 Vue 框架生成的 Document 元素，这里只是做一个简单的示例\n    root = document.createElement("h1");\n    root.textContent = "微应用1";\n    // 在微应用插槽上挂载 DOM 元素\n    const $slot = document.querySelector(slot);\n    $slot?.appendChild(root);\n  };\n\n  window.micro1_unmount = function () {\n    if (!root) return;\n    root.parentNode?.removeChild(root);\n  };\n})();\n\n\n// micro1.css\nh1 {\n  color: green;\n}\n\n\n// micro2.js\n// 立即执行的匿名函数可以防止变量 root 产生冲突\n(function () {\n  let root;\n\n  window.micro2_mount = function (slot) {\n    // 以下其实可以是 React 框架或者 Vue 框架生成的 Document 元素，这里只是做一个简单的示例\n    root = document.createElement("h1");\n    root.textContent = "微应用2";\n    const $slot = document.querySelector(slot);\n    $slot?.appendChild(root);\n  };\n\n  window.micro2_unmount = function () {\n    if (!root) return;\n    root.parentNode?.removeChild(root);\n  };\n})();\n\n// micro2.css\nh1 {\n  color: blue;\n}\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：如果去除 ",(0,r.jsx)(e.code,{children:"micro1.js"})," 和 ",(0,r.jsx)(e.code,{children:"micro2.js"})," 的立即执行匿名函数，在微应用切换时，会发生什么情况呢？"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"相应的服务端设计如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// config.js\nimport ip from "ip";\n\nexport default {\n  port: {\n    main: 4000,\n    micro: 3000,\n  },\n  // 获取本机的 IP 地址\n  host: ip.address(),\n};\n\n\n// main-server.js\nimport express from "express";\nimport path from "path";\nimport morgan from "morgan";\nimport config from "./config.js";\nconst app = express();\nconst { port, host } = config;\n\n// 打印请求日志\napp.use(morgan("dev"));\n\napp.use(express.static(path.join("public", "main")));\n\napp.post("/microapps", function (req, res) {\n  // 这里可以是管理后台新增菜单后存储到数据库的数据\n  // 从而可以通过管理后台动态配置微应用的菜单\n  res.json([\n    {\n      // 应用名称\n      name: "micro1",\n      // 应用标识\n      id: "micro1",\n      // 应用脚本（示例给出一个脚本，多个脚本也一样）\n      script: `http://${host}:${port.micro}/micro1.js`,\n      // 应用样式\n      style: `http://${host}:${port.micro}/micro1.css`,\n      // 挂载到 window 上的加载函数 window.micro1_mount\n      mount: "micro1_mount",\n      // 挂载到 window 上的卸载函数 window.micro1_unmount\n      unmount: "micro1_unmount",\n      // 是否需要预获取\n      prefetch: true,\n    },\n    {\n      name: "micro2",\n      id: "micro2",\n      script: `http://${host}:${port.micro}/micro2.js`,\n      style: `http://${host}:${port.micro}/micro2.css`,\n      mount: "micro2_mount",\n      unmount: "micro2_unmount",\n      fetch: true,\n    },\n  ]);\n});\n\n// 启动 Node 服务\napp.listen(port.main, host);\nconsole.log(`server start at http://${host}:${port.main}/`);\n\n// micro-server.js\nimport express from "express";\nimport morgan from "morgan";\nimport path from \'path\';\nimport config from "./config.js";\nconst app = express();\nconst { port, host } = config;\n\n// 打印请求日志\napp.use(morgan("dev"));\napp.use(express.static(path.join("public", "micro")));\n\n// 启动 Node 服务\napp.listen(port.micro, host);\nconsole.log(`server start at http://${host}:${port.main}/`);\n'})}),"\n",(0,r.jsx)(e.p,{children:"同时启动主应用和微应用的服务，并通过访问主应用的 HTML 实现上述动图中的切换效果。动态 Script 的方案相对于 NPM 方案而言，具备如下优势："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"主应用在线上运行时可以动态增加、删除和更新（升级或回滚）需要上架的微应用"}),"\n",(0,r.jsx)(e.li,{children:"微应用可以进行构建时性能优化，包括代码分割和静态资源分离处理"}),"\n",(0,r.jsx)(e.li,{children:"不需要额外对微应用进行库构建配置去适配 NPM 包的模块化加载方式"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"当然，动态 Script 方案和 NPM 包方案一样，会存在如下问题："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"主应用和各个微应用的全局变量会产生属性冲突"}),"\n",(0,r.jsx)(e.li,{children:"主应用和各个微应用的 CSS 样式会产生冲突"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本课程简单讲解了动态 Script 的方案的示例和优缺点，接下来可以在动态 Script 方案的基础上做少许改动，实现一个简单的 Web Components 方案，下个课程我们来看下 Web Components 的方案设计。"})]})}function p(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(s,{...n})}):s(n)}let l=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F6.%E6%96%B9%E6%A1%88%E4%BA%86%E8%A7%A3%EF%BC%9A%E5%8A%A8%E6%80%81%20Script%20%E6%96%B9%E6%A1%88.md"]={toc:[{text:"动态 Script 方案",id:"动态-script-方案",depth:2},{text:"小结",id:"小结",depth:2}],title:"6.方案了解：动态 Script 方案",headingTitle:"6.方案了解：动态 Script 方案",frontmatter:{}}}}]);