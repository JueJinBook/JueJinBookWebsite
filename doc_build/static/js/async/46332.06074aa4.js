"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["46332"],{33500:function(n,e,t){t.r(e),t.d(e,{default:()=>a});var c=t(552676),r=t(740453);let s=t.p+"static/image/7d8abf012e9639b8fecb06ad552af834.49dd0315.webp",d=t.p+"static/image/9ac5bc5ebb2e5cd98a996948c0351837.b903b3b4.webp";function o(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",pre:"pre",ol:"ol",li:"li",img:"img"},(0,r.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"35-原理篇--svelte-4-响应式基本原理",children:["35-原理篇 ❘ Svelte 4 响应式基本原理",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#35-原理篇--svelte-4-响应式基本原理",children:"#"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"推荐学习指数：⭐️️⭐️️"}),"\n"]}),"\n",(0,c.jsxs)(e.h2,{id:"1-前言",children:["1. 前言",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["Svelte 本质上是一个编译器。虽说是原理篇，但我们并不会讲 Svelte 的编译原理，即 Svelte 如何将 ",(0,c.jsx)(e.code,{children:".svelte"}),"文件转为 AST 又如何生成最终的代码："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-typescript",children:'// 伪代码\n\nconst source = fs.readFileSync("App.svelte");\n// 将源码转为 AST\nconst ast = parse(source);\n// 追踪引用和依赖\nconst component = new Component(ast);\n// 创建代码区块和片段\nconst renderer =\n  options.generate === "ssr" ? SSRRenderer(component) : DomRenderer(component);\n// 生成代码\nconst { js, css } = renderer.render();\nfs.writeFileSync("App.js", js);\nfs.writeFileSync("App.css", css);\n'})}),"\n",(0,c.jsx)(e.p,{children:"这对大家使用 Svelte 并无太大帮助，而且个人能力有限。所以我们干脆讲解编译后的代码运行原理，从中大家可以了解到 Svelte 的响应式奥秘。"}),"\n",(0,c.jsx)(e.p,{children:"我们先从最基础的代码开始说起。"}),"\n",(0,c.jsxs)(e.h2,{id:"2-hello-world",children:["2. Hello World!",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-hello-world",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["最基础的代码莫过于 ",(0,c.jsx)(e.code,{children:'"Hello World!"'})," 了："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:"<h1>Hello world!</h1>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["查看 ",(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/dadcfb1e41154db2a83e8c7a9ac99b9e?version=4.2.19",title:"https://svelte.dev/repl/dadcfb1e41154db2a83e8c7a9ac99b9e?version=4.2.19",target:"_blank",rel:"noopener noreferrer",children:"REPL 生成的代码"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-typescript",children:'/* App.svelte generated by Svelte v4.2.19 */\nimport {\n  SvelteComponent,\n  detach,\n  element,\n  init,\n  insert,\n  noop,\n  safe_not_equal,\n} from "svelte/internal";\n\nimport "svelte/internal/disclose-version";\n\nfunction create_fragment(ctx) {\n  let h1;\n\n  return {\n    c() {\n      h1 = element("h1");\n      h1.textContent = "Hello world!";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n    },\n    p: noop,\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n      }\n    },\n  };\n}\n\nclass App extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment, safe_not_equal, {});\n  }\n}\n\nexport default App;\n'})}),"\n",(0,c.jsx)(e.p,{children:"生成的代码主要有两部分："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsx)(e.li,{children:(0,c.jsx)(e.code,{children:"create_fragment"})}),"\n",(0,c.jsx)(e.li,{children:(0,c.jsx)(e.code,{children:"class App extends SvelteComponent"})}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["其中，",(0,c.jsx)(e.code,{children:"create_fragment"}),"负责生成代码片段，而且代码会随着左侧输入的代码改变而不断改变，而 ",(0,c.jsx)(e.code,{children:"class App extends SvelteComponent"}),"则负责导出类，实例化的时候会运行 ",(0,c.jsx)(e.code,{children:"init"}),"函数完成组件的初始化。"]}),"\n",(0,c.jsxs)(e.p,{children:["所以 ",(0,c.jsx)(e.code,{children:"<h1>Hello world!</h1>"}),"主要对应了这段代码："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'function create_fragment(ctx) {\n  let h1;\n\n  return {\n    c() {\n      h1 = element("h1");\n      h1.textContent = "Hello world!";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n    },\n    p: noop,\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n      }\n    },\n  };\n}\n'})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"create_fragment"}),"函数会返回一个包含多个函数的对象，其中："]}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"c"}),"是 ",(0,c.jsx)(e.code,{children:"create"}),"的缩写，表示创建 DOM 片段"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"m"}),"是 ",(0,c.jsx)(e.code,{children:"mount"}),"的缩写，表示挂载 DOM"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"p"})," 表示 ",(0,c.jsx)(e.code,{children:"update"}),"，表示更新 DOM（为啥不叫 ",(0,c.jsx)(e.code,{children:"u"}),"我也不知道……）"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"i"})," 是 ",(0,c.jsx)(e.code,{children:"intro"})," 的缩写，与入场动画相关"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"o"})," 是 ",(0,c.jsx)(e.code,{children:"outro"})," 的缩写，与退场动画相关"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"d"})," 是 ",(0,c.jsx)(e.code,{children:"destroy"}),"的缩写，表示销毁 DOM"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"之所以使用缩写是因为代码压缩的时候，对象属性并不会被压缩，所以使用缩写，代码量会更小。"}),"\n",(0,c.jsxs)(e.p,{children:["其中还涉及 ",(0,c.jsx)(e.code,{children:"element"})," 和 ",(0,c.jsx)(e.code,{children:"insert"}),"两个函数，源码其实很简单："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"function element(name) {\n  return document.createElement(name);\n}\n\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"也就是将 DOM 操作改为函数形式而已。"}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"class App extends SvelteComponent"})," 则负责组件的导出和初始化。最后我们会 ",(0,c.jsx)(e.code,{children:"export default App"}),"，所以每个组件都是一个类，这也就是为什么我们可以通过 ",(0,c.jsx)(e.code,{children:"import Button from './button.svelte'"}),"的方式导入其他 ",(0,c.jsx)(e.code,{children:"svelte"}),"组件。"]}),"\n",(0,c.jsxs)(e.p,{children:["让我们说下 ",(0,c.jsx)(e.code,{children:"init"})," 函数，",(0,c.jsx)(e.code,{children:"init"}),"函数是 Svelte 组件完成初始化的函数，它会："]}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsx)(e.li,{children:"传入组件属性、上下文等"}),"\n",(0,c.jsx)(e.li,{children:"写入组件生命周期事件"}),"\n",(0,c.jsx)(e.li,{children:"绑定事件，并建立组件的更新机制"}),"\n",(0,c.jsxs)(e.li,{children:["调用 ",(0,c.jsx)(e.code,{children:"create_fragment"}),"创建元素并挂载到 DOM 上"]}),"\n",(0,c.jsx)(e.li,{children:"..."}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["输出的代码中并没有 ",(0,c.jsx)(e.code,{children:"init"}),"函数的源码，所以仅靠输出的代码无法直接运行，不过我提供一个极简版的可运行代码，大家可以从中看到大致的执行过程。新建 ",(0,c.jsx)(e.code,{children:"index.html"}),"，代码如下："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:'<html>\n  <head>\n    <title>svelte-under-the-hood</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script src="./svelte.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,c.jsxs)(e.p,{children:["新建 ",(0,c.jsx)(e.code,{children:"svelte.js"}),"，代码如下："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'function element(name) {\n  return document.createElement(name);\n}\n\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n\nfunction noop() {}\n\nfunction safe_not_equal(a, b) {\n  return a != a\n    ? b == b\n    : a !== b || (a && typeof a === "object") || typeof a === "function";\n}\n\nfunction mount_component(component, target, anchor) {\n  const { fragment } = component.$$;\n  fragment && fragment.m(target, anchor);\n}\n\nfunction init(\n  component,\n  options,\n  instance,\n  create_fragment,\n  not_equal,\n  props,\n  append_styles = null,\n  dirty = [-1]\n) {\n  const $$ = (component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || []),\n    dirty,\n    skip_bound: false,\n    root: options.target,\n  });\n\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  $$.fragment && $$.fragment.c();\n  mount_component(component, options.target, options.anchor);\n}\n\nfunction create_fragment(ctx) {\n  let h1;\n\n  return {\n    c() {\n      h1 = element("h1");\n      h1.textContent = "Hello world!";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n    },\n    p: noop,\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n      }\n    },\n  };\n}\n\nclass SvelteComponent {}\n\nclass App extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment, safe_not_equal, {});\n  }\n}\n\nnew App({\n  target: document.getElementById("app"),\n});\n'})}),"\n",(0,c.jsx)(e.p,{children:"浏览器效果如下："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsxs)(e.h2,{id:"3-变量",children:["3. 变量",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-变量",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"假如现在使用了变量呢？现在代码改为："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let name = 'world';\n<\/script>\n\n<h1>Hello {name}!</h1>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["让我们看看 ",(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/hello-world?version=4.2.19",title:"https://svelte.dev/repl/hello-world?version=4.2.19",target:"_blank",rel:"noopener noreferrer",children:"REPL 的变化"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'// ...\n\nfunction create_fragment(ctx) {\n  let h1;\n\n  return {\n    c() {\n      h1 = element("h1");\n      h1.textContent = `Hello ${name}!`;\n    },\n    // ...\n  };\n}\n\nlet name = "world";\n\nclass App extends SvelteComponent {\n  // ...\n}\n\nexport default App;\n'})}),"\n",(0,c.jsxs)(e.p,{children:["可以看到，我们将 ",(0,c.jsx)(e.code,{children:"<script>"}),"中的代码移动到了代码最外层。而 ",(0,c.jsx)(e.code,{children:"h1"})," 的 ",(0,c.jsx)(e.code,{children:"textContent"}),"使用了模板字符串。"]}),"\n",(0,c.jsxs)(e.h2,{id:"4-更新变量",children:["4. 更新变量",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-更新变量",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"假设我们现在要更新变量呢？代码改为："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-xml",children:"<script>\n  let name = 'World';\n  function update() {\n    name = 'Svelte';\n  }\n<\/script>\n<h1 on:click={update}>Hello {name}</h1>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["查看 ",(0,c.jsx)(e.a,{href:"https://svelte.dev/repl/cb8b2da019d748e3b7020a50c80ac15d?version=4.2.19",title:"https://svelte.dev/repl/cb8b2da019d748e3b7020a50c80ac15d?version=4.2.19",target:"_blank",rel:"noopener noreferrer",children:"REPL 的变化"}),"，可以看到代码发生了不少变化："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'// ...\n\nfunction create_fragment(ctx) {\n  let h1;\n  let t0;\n  let t1;\n  let mounted;\n  let dispose;\n\n  return {\n    c() {\n      h1 = element("h1");\n      t0 = text("Hello ");\n      t1 = text(/*name*/ ctx[0]);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      append(h1, t0);\n      append(h1, t1);\n\n      if (!mounted) {\n        dispose = listen(h1, "click", /*update*/ ctx[1]);\n        mounted = true;\n      }\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n      }\n\n      mounted = false;\n      dispose();\n    },\n  };\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n  let name = "World";\n\n  function update() {\n    $$invalidate(0, (name = "Svelte"));\n  }\n\n  return [name, update];\n}\n\nclass App extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {});\n  }\n}\n\nexport default App;\n'})}),"\n",(0,c.jsxs)(e.p,{children:["首先是我们将 ",(0,c.jsx)(e.code,{children:"<script>"}),"中的代码移到了 ",(0,c.jsx)(e.code,{children:"instance"})," 函数中，之所以放在单独的函数中，是因为 Svelte 检测到变量可能会被更改，而我们要保证每个组件的变量更改都是独立的。"]}),"\n",(0,c.jsxs)(e.p,{children:["换句话说，在第二个例子中，",(0,c.jsx)(e.code,{children:"name"})," 的值是不变的，所以放在外面也没有什么关系，但在现在的例子中，",(0,c.jsx)(e.code,{children:"name"})," 的值是可能被更改的，所以需要放在单独的函数中："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:"<App />\n<App />\n<App />\n\n\x3c!-- 组件的数据应该是独立的 --\x3e\n<h1>Hello World</h1>\n<h1>Hello World</h1>\n<h1>Hello Svelte</h1>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["然后在 ",(0,c.jsx)(e.code,{children:"instance()"}),"函数中，我们将 ",(0,c.jsx)(e.code,{children:"name"})," 和 ",(0,c.jsx)(e.code,{children:"update"})," 以数组的形式进行了返回，在 Svelte 中，这个变量列表就是上下文（ctx），",(0,c.jsx)(e.code,{children:"create_fragment"}),"函数执行时传入的 ",(0,c.jsx)(e.code,{children:"ctx"})," 就是它："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:"// 简化过程： // 执行 instance 函数，获取该组件的上下文 const ctx = instance();\n// 传入上下文，获取片段 const fragment = create_fragment(ctx); // 创建 DOM\nfragment.c(); // 挂载 DOM fragment.m(target);\n"})}),"\n",(0,c.jsxs)(e.p,{children:["再然后看 ",(0,c.jsx)(e.code,{children:"create_fragment()"}),"函数，我们不再直接获取变量，而是从 ",(0,c.jsx)(e.code,{children:"ctx"})," 中获取变量的值："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'function create_fragment(ctx) {\n  // ...\n  return {\n    c() {\n      // ...\n      t1 = text(/*name*/ ctx[0]);\n    },\n    m(target, anchor) {\n      // ...\n      if (!mounted) {\n        dispose = listen(h1, "click", /*update*/ ctx[1]);\n        mounted = true;\n      }\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);\n    },\n    // ...\n  };\n}\n'})}),"\n",(0,c.jsxs)(e.p,{children:["这其中有 3 个新函数，",(0,c.jsx)(e.code,{children:"text"}),"、",(0,c.jsx)(e.code,{children:"listen"}),"和 ",(0,c.jsx)(e.code,{children:"set_data"}),"，其实源码都很简单："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'function text(data) {\n  return document.createTextNode(data);\n}\n\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\n\nfunction set_data(text, data) {\n  data = "" + data;\n  if (text.data === data) return;\n  text.data = data;\n}\n'})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"set_data"}),"看起来可能让人有些迷惑，但其实很简单，就是修改文本节点的意思。第一个参数是 ",(0,c.jsx)(e.code,{children:"text"}),"，是通过 ",(0,c.jsx)(e.code,{children:"document.createTextNode"})," 创建的文本节点，第二个参数是 ",(0,c.jsx)(e.code,{children:"data"}),"，表示修改后的数据，",(0,c.jsx)(e.code,{children:"text.data = (data)"}),"就是修改此文本节点的数据为新值。"]}),"\n",(0,c.jsx)(e.p,{children:"当 mount 的时候，我们会调用："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'dispose = listen(h1, "click", /*update*/ ctx[1]);\n'})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"ctx[1]"})," 就是 ",(0,c.jsx)(e.code,{children:"update"}),"函数，由此我们完成事件绑定。"]}),"\n",(0,c.jsxs)(e.p,{children:["当点击的时候，触发 ",(0,c.jsx)(e.code,{children:"update"}),"函数，update 函数被编译为："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'function instance($$self, $$props, $$invalidate) {\n  let name = "World";\n\n  function update() {\n    $$invalidate(0, (name = "Svelte"));\n  }\n\n  return [name, update];\n}\n'})}),"\n",(0,c.jsxs)(e.p,{children:["那么 ",(0,c.jsx)(e.code,{children:"$$invalidate"})," 是什么呢？这个函数其实可以在 ",(0,c.jsx)(e.code,{children:"init"})," ",(0,c.jsx)(e.a,{href:"https://github.com/sveltejs/svelte/blob/svelte%404.2.19/packages/svelte/src/runtime/internal/Component.js",title:"https://github.com/sveltejs/svelte/blob/svelte%404.2.19/packages/svelte/src/runtime/internal/Component.js",target:"_blank",rel:"noopener noreferrer",children:"函数的源码"}),"中查看到："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"// 简略了部分代码：\n\nfunction init(\n  component,\n  options,\n  instance,\n  create_fragment,\n  not_equal,\n  props,\n  append_styles = null,\n  dirty = [-1]\n) {\n  const $$ = (component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || []),\n    // everything else\n    dirty,\n    skip_bound: false,\n    root: options.target,\n  });\n\n  let ready = false;\n  $$.ctx = instance\n    ? instance(component, options.props || {}, (i, ret, ...rest) => {\n        const value = rest.length ? rest[0] : ret;\n        if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n          if (ready) make_dirty(component, i);\n        }\n        return ret;\n      })\n    : [];\n  $$.update();\n  ready = true;\n\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    $$.fragment && $$.fragment.c();\n    mount_component(component, options.target, options.anchor);\n    flush();\n  }\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["其实就是我们调用 ",(0,c.jsx)(e.code,{children:"instance"})," 函数传入的第三个参数，也就是这部分："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"(i, ret, ...rest) => {\n  const value = rest.length ? rest[0] : ret;\n  if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n    if (ready) make_dirty(component, i);\n  }\n  return ret;\n};\n"})}),"\n",(0,c.jsxs)(e.p,{children:["此时 ",(0,c.jsx)(e.code,{children:"i"}),"是 ",(0,c.jsx)(e.code,{children:"0"}),"，",(0,c.jsx)(e.code,{children:"ret"}),"是 ",(0,c.jsx)(e.code,{children:"name = 'Svelte'"}),"，分析函数的执行内容，",(0,c.jsx)(e.code,{children:"value"})," 是 ",(0,c.jsx)(e.code,{children:"'Svelte'"}),"，",(0,c.jsx)(e.code,{children:"not_equal($$.ctx[i], ($$.ctx[i] = value))"}),"用于判断之前的值和现在的值是否相同，不相同说明值发生了更改，此时 ",(0,c.jsx)(e.code,{children:"ready"}),"为 ",(0,c.jsx)(e.code,{children:"true"}),"，我们就会调用 ",(0,c.jsx)(e.code,{children:"make_dirty(component, i)"}),"，标记需要修改的组件和 ",(0,c.jsx)(e.code,{children:"ctx"})," 的下标值。"]}),"\n",(0,c.jsxs)(e.p,{children:["函数名为 ",(0,c.jsx)(e.code,{children:"make_dirty"}),"，很多框架都用 ",(0,c.jsx)(e.code,{children:"dirty"})," 来表示产生了变化的数据。翻译成“脏”，听起来稍微有些奇怪，习惯就好。"]}),"\n",(0,c.jsxs)(e.p,{children:["现在让我们看下 ",(0,c.jsx)(e.code,{children:"make_dirty"})," ",(0,c.jsx)(e.a,{href:"https://github.com/sveltejs/svelte/blob/svelte%404.2.19/packages/svelte/src/runtime/internal/Component.js#L78",title:"https://github.com/sveltejs/svelte/blob/svelte%404.2.19/packages/svelte/src/runtime/internal/Component.js#L78",target:"_blank",rel:"noopener noreferrer",children:"相关的源码"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"const dirty_components = [];\n\nlet update_scheduled = false;\n\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n\nfunction make_dirty(component, i) {\n  // 组件是否已经“脏了”\n  if (component.$$.dirty[0] === -1) {\n    // 将组件放到需要“脏组件”数组中\n    dirty_components.push(component);\n    // 异步更新\n    schedule_update();\n    // 标记该组件已经“脏了”\n    component.$$.dirty.fill(0);\n  }\n  // 标记该组件的脏数据的下标\n  component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这段代码并不算复杂，主要是判断该组件是否已经“脏了”，也就是有要改变的值。如果没有，将其放到 ",(0,c.jsx)(e.code,{children:"dirty_components"}),"中，然后再调用 ",(0,c.jsx)(e.code,{children:"schedule_update()"})," 进行异步更新。这点类似于 React 的 setState，为了防止重复更新，采用异步的方式集中更新。"]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;"}),"这句很简练，主要是借助了一种称为“位掩码”的技术，我们在下一篇文章中单独讲讲。"]}),"\n",(0,c.jsxs)(e.p,{children:["现在你只用知道，它的作用是将 ",(0,c.jsx)(e.code,{children:"i"}),"的值存储下来，用于知道上下文（ctx）中哪些下标值发生了变化，然后将其存放在该组件的 ",(0,c.jsx)(e.code,{children:"$$.dirty"})," 属性中。"]}),"\n",(0,c.jsxs)(e.p,{children:["进入 ",(0,c.jsx)(e.code,{children:"schedule_update()"}),"函数代码："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"function schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["它主要是借助浏览器的微任务机制，执行 ",(0,c.jsx)(e.code,{children:"flush"}),"函数。我们再看下 ",(0,c.jsx)(e.code,{children:"flush"}),"的源码："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"let flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n\n  while (flushidx < dirty_components.length) {\n    const component = dirty_components[flushidx];\n    flushidx++;\n\n    update(component.$$);\n  }\n\n  dirty_components.length = 0;\n  flushidx = 0;\n}\n\nfunction update($$) {\n  if ($$.fragment !== null) {\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n  }\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["简单来说，就是遍历 ",(0,c.jsx)(e.code,{children:"dirty_components"}),"数组，执行组件的更新，最后执行 ",(0,c.jsx)(e.code,{children:"create_fragment"})," 返回的 ",(0,c.jsx)(e.code,{children:"p"}),"函数："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"function create_fragment(ctx) {\n  // ...\n\n  return {\n    // ...\n    p(ctx, [dirty]) {\n      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);\n    },\n    // ...\n  };\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["对于 ",(0,c.jsx)(e.code,{children:"p"})," 函数，第一个参数时 ",(0,c.jsx)(e.code,{children:"ctx"}),"表示当前上下文，第二个参数时 ",(0,c.jsx)(e.code,{children:"dirty"}),"表示该组件需要更新的下标值，",(0,c.jsx)(e.code,{children:"if (dirty & /*name*/ 1)"}),"则是为了判断当下下标值是否是 dirty 中需要更新的下标值，如果需要更新，则执行 ",(0,c.jsx)(e.code,{children:"set_data"}),"函数。"]}),"\n",(0,c.jsxs)(e.p,{children:["注：",(0,c.jsx)(e.code,{children:"if (dirty & /*name*/ 1)"}),"这个判断我们也会在下篇详细讲解背后的原理。"]}),"\n",(0,c.jsx)(e.p,{children:"由此 Svelte 实现了点击时的 DOM 更新操作。"}),"\n",(0,c.jsxs)(e.p,{children:["当然此时你可能还是有些懵逼，没有关系，我直接提供一个可运行的版本，修改 ",(0,c.jsx)(e.code,{children:"svelte.js"})," 的代码为："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'function element(name) {\n  return document.createElement(name);\n}\n\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n\nfunction text(data) {\n  return document.createTextNode(data);\n}\n\nfunction append(target, node) {\n  target.appendChild(node);\n}\n\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\n\nfunction noop() {}\n\nfunction safe_not_equal(a, b) {\n  return a != a\n    ? b == b\n    : a !== b || (a && typeof a === "object") || typeof a === "function";\n}\n\nfunction set_data(text, data) {\n  data = "" + data;\n  if (text.data === data) return;\n  text.data = data;\n}\n\nconst dirty_components = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\nlet flushidx = 0;\nfunction flush() {\n  // Do not reenter flush while dirty components are updated, as this can\n  // result in an infinite loop. Instead, let the inner flush handle it.\n  // Reentrancy is ok afterwards for bindings etc.\n  if (flushidx !== 0) {\n    return;\n  }\n\n  while (flushidx < dirty_components.length) {\n    const component = dirty_components[flushidx];\n    flushidx++;\n\n    update(component.$$);\n  }\n\n  dirty_components.length = 0;\n  flushidx = 0;\n}\n\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    // run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    // $$.after_update.forEach(add_render_callback);\n  }\n}\n\nfunction mount_component(component, target, anchor) {\n  const { fragment } = component.$$;\n  fragment && fragment.m(target, anchor);\n}\n\nfunction init(\n  component,\n  options,\n  instance,\n  create_fragment,\n  not_equal,\n  props,\n  append_styles = null,\n  dirty = [-1]\n) {\n  const $$ = (component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || []),\n    // everything else\n    dirty,\n    skip_bound: false,\n    root: options.target,\n  });\n\n  let ready = false;\n  $$.ctx = instance\n    ? instance(component, options.props || {}, (i, ret, ...rest) => {\n        const value = rest.length ? rest[0] : ret;\n        if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n          // if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n          if (ready) make_dirty(component, i);\n        }\n        return ret;\n      })\n    : [];\n  $$.update();\n  ready = true;\n\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    $$.fragment && $$.fragment.c();\n    mount_component(component, options.target, options.anchor);\n    flush();\n  }\n}\n\nfunction create_fragment(ctx) {\n  let h1;\n  let t0;\n  let t1;\n  let mounted;\n  let dispose;\n\n  return {\n    c() {\n      h1 = element("h1");\n      t0 = text("Hello ");\n      t1 = text(/*name*/ ctx[0]);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      append(h1, t0);\n      append(h1, t1);\n\n      if (!mounted) {\n        dispose = listen(h1, "click", /*update*/ ctx[1]);\n        mounted = true;\n      }\n    },\n    p(ctx, [dirty]) {\n      if (dirty & /*name*/ 1) set_data(t1, /*name*/ ctx[0]);\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n      }\n\n      mounted = false;\n      dispose();\n    },\n  };\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n  let name = "World";\n\n  function update() {\n    $$invalidate(0, (name = "Svelte"));\n  }\n\n  return [name, update];\n}\n\nclass SvelteComponent {}\n\nclass App extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {});\n  }\n}\n\nnew App({\n  target: document.getElementById("app"),\n});\n'})}),"\n",(0,c.jsx)(e.p,{children:"浏览器效果如下："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"大家可以通过调试这段可运行的代码，同时参照本篇文章的思路学习 Svelte 响应式实现方式。"}),"\n",(0,c.jsxs)(e.h2,{id:"5-最后",children:["5. 最后",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5-最后",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["让我们回顾下整个流程，我们在 ",(0,c.jsx)(e.code,{children:".svelte"}),"中写的代码，会对应编译成 ",(0,c.jsx)(e.code,{children:"create_fragment"}),"中的代码，它会返回一个包含 DOM 创建、挂载、更新、销毁等函数的对象。当组件实例化的时候，会调用 ",(0,c.jsx)(e.code,{children:"init"}),"函数，执行 DOM 的创建和挂载。"]}),"\n",(0,c.jsxs)(e.p,{children:["Svelte 之所以能够实现数据的响应式，是因为 Svelte 会判断变量是否被用到、是否会发生变化，然后将赋值操作语句编译成类似于 ",(0,c.jsx)(e.code,{children:"$$invalidate(0, name = 'Svelte')"}),"的代码。",(0,c.jsx)(e.code,{children:"0"}),"表示该数据在上下文的下标值。而在 ",(0,c.jsx)(e.code,{children:"$$invalidate"}),"中，为了防止重复更新，Svelte 会先将需要更新的组件和下标值进行存储，然后统一执行更新。最后更新的时候，会进入到 ",(0,c.jsx)(e.code,{children:"create_fragment"})," 返回的 DOM 更新函数，也就是 ",(0,c.jsx)(e.code,{children:"p"})," 函数，在 ",(0,c.jsx)(e.code,{children:"p"}),"函数中，我们会判断数据是否需要更新，最后进行更新操作。"]}),"\n",(0,c.jsxs)(e.p,{children:["因为 Svelte 在编译的时候就建立了数据和 DOM 之间的映射关系，所以更新的时候，只用记录哪些数据发生了变化，然后进入了 ",(0,c.jsx)(e.code,{children:"p"}),"函数，通过 ",(0,c.jsx)(e.code,{children:"if"})," 判断直接更新对应的 DOM 节点。这点不像 React 或者 Vue，需要通过 Virtual DOM 的 Diff 算法先算出哪些 DOM 节点需要更新，所以 Svelte 的 DOM 更新比 React、Vue 都更加高效。"]}),"\n",(0,c.jsx)(e.p,{children:"但是因为 Svelte 会根据你的代码编译代码，过程中可能会产生很多冗余代码，所以 Svelte 尤其适合小型项目和追求高性能的项目。"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(o,{...n})}):o(n)}let a=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F35-%E5%8E%9F%E7%90%86%E7%AF%87%20%E2%9D%98%20Svelte%204%20%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. Hello World!",id:"2-hello-world",depth:2},{text:"3. 变量",id:"3-变量",depth:2},{text:"4. 更新变量",id:"4-更新变量",depth:2},{text:"5. 最后",id:"5-最后",depth:2}],title:"35-原理篇 ❘ Svelte 4 响应式基本原理",headingTitle:"35-原理篇 ❘ Svelte 4 响应式基本原理",frontmatter:{}}}}]);