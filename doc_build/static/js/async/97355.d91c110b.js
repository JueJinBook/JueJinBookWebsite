"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["97355"],{86373:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var r=s(552676),i=s(740453);let o=s.p+"static/image/bbbf87d108f5e822230e21a154d929a1.95dd2ddf.png",c=s.p+"static/image/7c3c70f65ab36a15ddceec8d7feb0d97.9bc8d79c.png";function a(e){let n=Object.assign({p:"p",h2:"h2",a:"a",pre:"pre",code:"code",blockquote:"blockquote",ul:"ul",li:"li",img:"img",strong:"strong",h3:"h3"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"在上节课中，我们重点讲解了如何设计构建脚本生成发布需要的目标文件。本节课我们主要讲解如何基于目标文件进行版本发布，并讲解版本的规范以及安装策略。"}),"\n",(0,r.jsxs)(n.h2,{id:"发布-npm-库包",children:["发布 NPM 库包",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布-npm-库包",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在发布 NPM 库包之前，首先需要在 NPM 官方网站进行",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/signup",target:"_blank",rel:"noopener noreferrer",children:"账号注册"}),"，注册成功后可以在本地利用 NPM CLI 进行登录和后续的发布操作："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 30.工程设计：版本发布\nnpm login\nnpm WARN adduser `adduser` will be split into `login` and `register` in a future version. `adduser` will become an alias of `register`. `login` (currently an alias) will become its own command.\nnpm notice Log in on https://registry.npmjs.org/\n# 输入账号\nUsername: ziyi22\n# 输入密码\nPassword: \n# 输入邮箱\nEmail: (this IS public) 18768107826@163.com\nnpm notice Please check your email for a one-time password (OTP)\n# 通过邮箱输入 OTP code 进行验证\nEnter one-time password: 73326070\nLogged in as ziyi22 on https://registry.npmjs.org/.\n# 登录以后查看账号名\nnpm whoami\nziyi22\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：登录时不要使用 NPM 淘宝镜像地址，需要使用 NPM 官方地址。通过 ",(0,r.jsx)(n.code,{children:"npm config set registry  https://registry.npmjs.org/"})," 命令设置成 NPM 官方发布地址。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"在按需加载的设计中，构建后的目录结构如下所示："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"├── src                            \n│   ├── index.js                 \n│   ├── core                     \n│   │   └── core.js              \n│   ├── sandbox                   \n│   │   ├── sandbox1.js          \n│   │   ├── sandbox2.js          \n│   │   └── sandbox3.js          \n│   ├── nav                        \n│   │   └── nav.js              \n│   ├── opt                      \n│   │   ├── opt1.js              \n│   │   └── opt2.js              \n│   └── comm                     \n│       ├── comm1.js              \n│       └── comm2.js    \n├── lib\n│   ├── commonjs #需要发布的 NPM 包                    \n│   │   ├── comm1.d.ts                \n│   │   ├── comm1.js                  \n│   │   ├── comm2.d.ts                \n│   │   ├── comm2.js                  \n│   │   ├── core.d.ts                \n│   │   ├── core.js                   \n│   │   ├── index.d.ts               \n│   │   ├── index.js     \n│   │   ├── nav.d.ts                 \n│   │   ├── nav.js    \n│   │   ├── op1.d.ts   \n│   │   ├── op1.js\n│   │   ├── op2.d.ts  \n│   │   ├── op2.js\n│   │   ├── sandbox1.d.ts\n│   │   ├── sandbox1.js  \n│   │   ├── sandbox2.d.ts\n│   │   ├── sandbox2.js  \n│   │   ├── sandbox3.d.ts\n│   │   └── sandbox3.js     \n│   └── es #需要发布的 NPM 包，和 commonjs 类似，本课程未实现目录平铺\n├── gulpfile.js                   \n├── tsconfig.json                 \n└── package.json     \n"})}),"\n",(0,r.jsxs)(n.p,{children:["构建完成后可以基于目标文件进行发布，在发布之前需要在 ",(0,r.jsx)(n.code,{children:"package.json"})," 中指定库名称、库版本和库的入口文件地址，并将其拷贝到 ",(0,r.jsx)(n.code,{children:"lib/commonjs"})," 和 ",(0,r.jsx)(n.code,{children:"lib/es"})," 目录下进行发布准备："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'// lib/commonjs/package.json\n{\n  "name": "micro-framework",\n  "version": "1.0.0",\n  "main": "index.js",\n}\n\n// lib/es/package.json\n{\n  "name": "micro-framework-es",\n  "version": "1.0.0",\n  "main": "index.js",\n  "module": "index.js",\n  "jsnext:main": "index.js"\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"name"}),"：包名称，发布以后可以通过 ",(0,r.jsx)(n.code,{children:"npm i ${name} --save"})," 进行安装；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"version"}),"：包版本，需要遵循版本规范，开发者可以通过指定版本进行安装使用；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"main"}),"： 包入口地址，使用 ",(0,r.jsx)(n.code,{children:"import xxx from '${name}'"})," 会引入 ",(0,r.jsx)(n.code,{children:"main"})," 所在的文件；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"module"}),"： ES Modules 入口，作用和 ",(0,r.jsx)(n.code,{children:"main"})," 相同；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"jsnext:main"}),"：社区约定的 ES Modules 入口文件，作用和 ",(0,r.jsx)(n.code,{children:"module"})," 相同。"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：关于 ",(0,r.jsx)(n.code,{children:"package.json"})," 字段的详细描述，可以查看 NPM 官网的 ",(0,r.jsx)(n.a,{href:"https://docs.npmjs.com/cli/v8/configuring-npm/package-json",target:"_blank",rel:"noopener noreferrer",children:"package.json"}),"。除了上述字段，和 NPM 库包发布息息相关的字段包括 ",(0,r.jsx)(n.code,{children:"files"}),"、",(0,r.jsx)(n.code,{children:"bin (用于制作 CLI 库)"}),"、",(0,r.jsx)(n.code,{children:"peerDependencies"}),"、",(0,r.jsx)(n.code,{children:"dependencies"}),"、",(0,r.jsx)(n.code,{children:"publishConfig"}),"、",(0,r.jsx)(n.code,{children:"typings | types"})," 等。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["由于同时需要发布两个库包，并且每次发布都需要更新各自的 ",(0,r.jsx)(n.code,{children:"pacakge.json"})," 包描述文件，因此拷贝和发布的工作可以利用脚本进行自动化执行，在之前的按需加载脚本上设计一个 ",(0,r.jsx)(n.code,{children:"release.ts"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"build\n├── base.ts                      # 可以被构建、发布等脚本进行继承使用\n├── build.ts                     # 构建脚本\n├── config.ts                    # 配置，主要被 base 进行消费\n├── gulpfile.ts                  # Gulp 构建配置文件\n├── release.ts                   # 发布脚本（新增）\n└── type.ts                      # 接口、枚举说明\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：示例源码可以从 ",(0,r.jsx)(n.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/release-script",target:"_blank",rel:"noopener noreferrer",children:"demo/release-script"})," 分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"type.ts"})," 和 ",(0,r.jsx)(n.code,{children:"config.ts"})," 中新增了和发布息息相关的配置信息："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// type.ts\nimport { Settings } from "gulp-typescript";\n\nexport enum TargetTypeEnum {\n  CommonJS = "CommonJS",\n  ESModule = "ESModule",\n}\n\nexport interface IPackageJson {\n  name: string;\n  main: string;\n  module?: string;\n  "jsnext:main"?: string;\n  [key: string]: any;\n}\n\nexport interface ITarget {\n  name: string;\n  type: TargetTypeEnum;\n  tsconfig: Settings;\n  // 新增 packageJson 的接口描述\n  packagejson: IPackageJson;\n  dest: string;\n}\n\n\n\n// config.ts\nimport path from "path";\nimport { TargetTypeEnum } from "./type";\n\nexport const targets = [\n  {\n    name: "build commonjs",\n    type: TargetTypeEnum.CommonJS,\n    tsconfig: {\n      module: "CommonJS",\n      target: "ES5",\n    },\n    dest: path.join(__dirname, "../lib/commonjs"),\n    // 新增 CommonJS 包的 package.json 配置\n    packagejson: {\n      name: "micro-framework",\n      main: "index.js"\n    }\n  },\n  {\n    name: "build esmodule",\n    type: TargetTypeEnum.ESModule,\n    tsconfig: {\n      module: "ES2015",\n      target: "ES5",\n    },\n    dest: path.join(__dirname, "../lib/es"),\n    // 新增 ES Modules 包的 package.json 配置\n    packagejson: {\n      name: "micro-framework-es",\n      main: "index.js",\n      module: "index.js",\n      "jsnext:main": "index.js"\n    },\n  },\n];\n'})}),"\n",(0,r.jsxs)(n.p,{children:["重点来看下 ",(0,r.jsx)(n.code,{children:"release.ts"})," 中的发布脚本设计，首先是生成 NPM 包需要的 ",(0,r.jsx)(n.code,{children:"README.md"})," 和 ",(0,r.jsx)(n.code,{children:"package.json"})," 文件，其次进行发布前的检查工作，最后进行发布处理："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// release.ts\nimport fs from "fs-extra";\nimport shell from "shelljs";\nimport semver from "semver";\nimport fetch from "node-fetch";\nimport path from "path";\nimport { Base } from "./base";\nimport { ITarget } from "./type";\n\nclass Release extends Base {\n  constructor() {\n    super();\n  }\n\n  async run() {\n    // 拷贝 README.md 并生成 package.json\n    this.prepare();\n    // 发布预检\n    await this.check();\n    // 发布处理\n    this.release();\n  }\n\n  // 在项目根目录下使用 package.json 进行 NPM 发布，项目的引入路径为 import xxx from \'micro-framwork/lib/commonjs/xxx\'\n  // 如果将 package.json 拷贝到 lib/commonjs 目录下并进入 lib/commonjs 目录进行发布，则引入路径为 import xxx from \'micro-framwork/xxx\'\n  // 除此之外，天然解决了需要在 package.json 中配置 files 字段或者在项目目录中配置 .npmignore 的问题\n  prepare() {\n    const targets = this.getTargets();\n    targets?.forEach((target) => {\n      // 生成 package.json\n      fs.writeJSONSync(\n        path.join(target.dest, "package.json"),\n        this.filterPackageJson(target),\n        { spaces: 2 }\n      );\n      // 拷贝 README.md\n      fs.copyFileSync(\n        path.join(this.rootPath, "README.md"),\n        path.join(target.dest, "README.md")\n      );\n    });\n  }\n\n  filterPackageJson(target: ITarget) {\n    const packageJson = this.getPackageJson();\n    const releasePackageJson: any = {};\n    [\n      "name",\n      "version",\n      "description",\n      "typings",\n      "types",\n      "author",\n      "license",\n      "homepage",\n      "dependencies",\n      "peerDependencies",\n    ].forEach((key) => {\n      releasePackageJson[key] = packageJson[key];\n    });\n    return {\n      ...releasePackageJson,\n      ...target.packagejson,\n    };\n  }\n\n  async check() {\n    const targets = this.getTargets();\n    if (!targets?.length) return;\n    // 检查 package.json 和 README.md 是否存在\n    this.checkPublishFiles(targets);\n    // 检查远程发布的版本是否大于本地待发布的版本（防止先发布 1.0.3，后发布 1.0.2）\n    await this.checkLocalVersion(targets);\n  }\n\n  checkPublishFiles(targets: ITarget[]) {\n    targets.forEach((target) => {\n      const checkFiles = ["package.json", "README.md"];\n      checkFiles.forEach((file) => {\n        const filePath = path.join(target.dest, file);\n        if (!fs.existsSync(filePath)) {\n          this.logError(`[发布失败]：${filePath} 不存在！`);\n          process.exit(1);\n        }\n      });\n    });\n  }\n\n  async checkLocalVersion(targets: ITarget[]) {\n    const packageJson = this.getPackageJson();\n    const localVersion = packageJson?.version;\n    if (!localVersion) {\n      this.logError(\n        `[发布失败]：请填写 ${path.join(\n          this.rootPath,\n          "package.json"\n        )} 中的 version 字段信息！`\n      );\n      process.exit(1);\n    }\n\n    for (const target of targets) {\n      const packageName = target.packagejson?.name;\n      if (packageName) {\n        const res = await fetch(\n          `http://registry.npmjs.org/${packageName}/latest`\n        );\n        const remotePackage = await res.json();\n        if (semver.gte(remotePackage?.version, localVersion)) {\n          this.logError(\n            `[发布失败]：当前 ${packageName} 需要发布的版本 ${localVersion} 小于等于已经发布的版本 ${remotePackage.version}！`\n          );\n          process.exit(1);\n        }\n      }\n    }\n  }\n\n  release() {\n    const targets = this.getTargets();\n    const packageJson = this.getPackageJson();\n    targets.forEach((target) => {\n      // 进入需要发布的目录文件夹，例如 lib/commonjs\n      shell.cd(target.dest);\n\n      // 使用 npm publish 执行发布\n      // TODO：npm 可以做成一个工具函数，例如检测 cnpm、npm、yarn、pnpm 命令是否存在以及执行的优先级，`${getPackageManager()} publish`\n      const result = shell.exec("npm publish")\n      if (result.code !== 0) {\n        this.logError(`[发布失败]：${target.packagejson.name} 发布失败！`);\n        shell.cd(this.rootPath);\n        fs.ensureFileSync("release.log");\n        fs.appendFileSync(\n          "release.log",\n          `${new Date().toLocaleString()}：${\n            target.packagejson.name\n          } 发布版本 ${packageJson.version} 失败！\\n失败原因：${result.stderr}`\n        );\n      }\n    });\n  }\n}\n\nnew Release().run();\n'})}),"\n",(0,r.jsxs)(n.p,{children:["上述发布脚本 ",(0,r.jsx)(n.code,{children:"release.ts"})," 主要做了几件事情："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["发布前准备：拷贝 ",(0,r.jsx)(n.code,{children:"README.md"})," 和生成 ",(0,r.jsx)(n.code,{children:"package.json"})," 文件到发布的文件目录下；"]}),"\n",(0,r.jsx)(n.li,{children:"发布时检测：检测需要发布的文件目录是否正确，检测本地需要发布的版本号是否正确；"}),"\n",(0,r.jsx)(n.li,{children:"发布设计：进行库包的发布处理，如果发布失败，则记录失败的日志。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"发布成功后可以通过在本地新建的项目安装 NPM 包进行测试："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 执行\nnpm i ziyi-micro-framework --save-dev\n# 打印\nadded 1 package, and audited 448 packages in 4s\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：发布的 NPM 包可以在",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer",children:" NPM 官网"}),"中搜索，例如本文发布的 NPM 包 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/search?q=ziyi-micro-framework",target:"_blank",rel:"noopener noreferrer",children:"ziyi-micro-framework"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"发布管控",children:["发布管控",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布管控",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在多人协作的开发中建议设计发布规则，例如这里设计适配 Github 的发布规则："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"只能基于远程最新的 master 分支进行发布；"}),"\n",(0,r.jsx)(n.li,{children:"需要发布的代码至少指定 1 个人进行 Code Review。"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"温馨提示：在多人协作的过程中尽可能设计发布规则，否则容易导致库版本的不稳定性。本文中的规则设计仅仅只是提供一种设计思路，并不是什么最佳实践，具体的设计规则需要依据多人协作的实际情况而定。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"第 1 条发布规则有多层含义，首先发布必须是 master 分支，其余分支不能进行发布操作。其次，为了强制进行 Code Review，任何人不能在 master 分支进行代码提交，master 分支始终是被 Code Review 后进行代码合并和库包发布的目标分支。最后，需要防止修改本地 master 分支，从而绕过 Code Review 进行代码发布。因此开发模式如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"温馨提示：开发者只能在非 master 分支进行开发，并且只能将代码通过 Code Review 的方式合并到远程的 master 代码中进行发布，这样可以确保发布的稳定性。如果是多个大版本的并行迭代，则只需要将 master 分支更改为相应的大版本迭代分支即可。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"为了实现上述发布规则，首先需要在 Github 上对仓库的 master 分支进行保护规则设置，点击项目的 Settings，并点击 Branches，进行如下规则设置："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Require a pull request before merging："})," When enabled, all commits must be made to a non-protected branch and submitted via a pull request before they can be merged into a branch that matches this rule."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Require approvals："})," When enabled, pull requests targeting a matching branch require a number of approvals and no changes requested before they can be merged."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Require review from Code Owners："})," Require an approved review in pull requests including files with a designated code owner."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Do not allow bypassing the above settings："}),' The above settings will apply to administrators and custom roles with the "bypass branch protections" permission.']}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"设置 master 分支的保护规则之后："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"本地 master 分支不能进行 push 和强制 push 代码到远程 Github 仓库；"}),"\n",(0,r.jsx)(n.li,{children:"远程 master 分支必须通过提交 PR 并通过 Code Review 后才能进行代码合并；"}),"\n",(0,r.jsx)(n.li,{children:"包括管理员在内的任何人都不允许绕过上述设置。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"上述保护策略的设置，可以确保远程 master 分支的代码必定是通过 Code Review 进行合并，例如在本地 master 分支进行代码提交："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 执行 push\ngit push origin master \nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 315 bytes | 315.00 KiB/s, done.\nTotal 3 (delta 2), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (2/2), completed with 2 local objects.\nremote: error: GH006: Protected branch update failed for refs/heads/master.\n# 提示至少需要 1 位开发者通过 Code Review 才能进行远程 master 分支的合并\nremote: error: At least 1 approving review is required by reviewers with write access.\nTo https://github.com/ziyi2/micro-framework.git\n ! [remote rejected] master -> master (protected branch hook declined)\n# 提示 push 失败\nerror: failed to push some refs to 'https://github.com/ziyi2/micro-framework.git'\n\n# 执行强制 push\n git push -f origin master\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 315 bytes | 315.00 KiB/s, done.\nTotal 3 (delta 2), reused 0 (delta 0), pack-reused 0\nremote: Resolving deltas: 100% (2/2), completed with 2 local objects.\nremote: error: GH006: Protected branch update failed for refs/heads/master.\n# 提示至少需要 1 位开发者通过 Code Review 才能进行远程 master 分支的合并\nremote: error: At least 1 approving review is required by reviewers with write access.\nTo https://github.com/ziyi2/micro-framework.git\n ! [remote rejected] master -> master (protected branch hook declined)\n # 提示 push 失败\nerror: failed to push some refs to 'https://github.com/ziyi2/micro-framework.git'\n"})}),"\n",(0,r.jsx)(n.p,{children:"但是上述设置并不能确保具有库包发布权限的开发者偷偷修改本地 master 分支进行库包发布，从而绕过远程的保护分支策略，为了防止开发者进行本地 master 分支的偷偷发布，需要对发布脚本进行发布检测："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// release.ts\nimport fs from "fs-extra";\nimport shell from "shelljs";\nimport semver from "semver";\nimport fetch from "node-fetch";\nimport simpleGit from "simple-git";\nimport path from "path";\nimport { Base } from "./base";\nimport { ITarget } from "./type";\n\nclass Release extends Base {\n  constructor() {\n    super();\n  }\n\n  async run() {\n    this.prepare();\n    // 新增发布预检\n    await this.check();\n    this.release();\n  }\n    \n  // ...\n\n  async check() {\n    const targets = this.getTargets();\n    if (!targets?.length) return;\n    // 发布分支检测\n    await this.checkBranch();\n    // 发布文件检测\n    this.checkPublishFiles(targets);\n    // 发布版本检测\n    await this.checkLocalVersion(targets);\n  }\n\n  // 发布分支检测\n  // 1、发布只能基于 master 分支进行（在 checkBranch 函数中进行卡口设置）\n  // 2、所有的开发不能将本地 master 分支的变更 push 到远程的 master 分支（在 Github 上进行分支保护设置）\n  // 3、所有的开发不能对本地 master 分支进行变更后再发布操作，防止本地偷偷发布没有 Code Review 的代码（在 checkBranch 函数中进行卡口设置）\n  async checkBranch() {\n    const git = simpleGit();\n    const branch = await git.branchLocal();\n    if (!/^master$/.test(branch?.current)) {\n      // 这里以 github 为例，进行打印说明\n      this.logError(\n        `[发布失败]: 发布分支只能为 master 分支，请切换发布分支并提交 Pull Request 和 Code Review 流程进行发布！`\n      );\n      process.exit(1);\n    }\n    // 确保当前的 master 分支的文件没有变更\n    const status = await git.status();\n    if (status?.files?.length) {\n      this.logError("[发布失败]: 不允许更改本地 master 代码！");\n      process.exit(1);\n    }\n    // 确保当前 master 分支的代码和远程代码一致（防止本地偷偷发布没有 Code Review 的代码）\n    // 有没有其他方式可以比较本地 master 和远程 master 分支是一致的？\n    const { stdout } = shell.exec("git diff origin/master master", {\n      silent: true,\n    });\n    // 如果有打印信息，则说明存在差异\n    if (stdout) {\n      this.logError(\n        `[发布失败]: 发布之前确保本地 master 分支和远程 master 分支内容一致！`\n      );\n      process.exit(1);\n    }\n  }\n\n  // ...\n}\n\nnew Release().run();\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,r.jsx)(n.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/release-script",target:"_blank",rel:"noopener noreferrer",children:"demo/release-script"})," 分支获取。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"此时如果通过脚本执行发布，则会报发布错误："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 在 test/release-script 分支下尝试发布\nnpm run release\n\n> micro-framework@1.0.5 release\n> ts-node build/release.ts\n\n[发布失败]: 发布分支只能为 master 分支，请切换发布分支并提交 Pull Request 和 Code Review 流程进行发布！\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：这里仍然无法防止发布者通过 ",(0,r.jsx)(n.code,{children:"npm publish"})," 命令进行发布处理，因此最好是在执行 ",(0,r.jsx)(n.code,{children:"publish"})," 钩子前进行校验脚本设置，例如使用 ",(0,r.jsx)(n.a,{href:"https://docs.npmjs.com/cli/v9/using-npm/scripts#life-cycle-scripts",target:"_blank",rel:"noopener noreferrer",children:"Life Cycle Scripts"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"版本规范",children:["版本规范",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#版本规范",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["库包需要发布的版本在 ",(0,r.jsx)(n.code,{children:"package.json"}),"的 ",(0,r.jsx)(n.code,{children:"version"})," 字段中进行设置，发布之后其他开发者就可以进行安装和使用。关于版本规范这里需要考虑两种情况："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"从库的设计者出发，需要考虑如何控制发布的版本号；"}),"\n",(0,r.jsx)(n.li,{children:"从库的使用者出发，需要考虑如何安装合适的版本号。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"库的设计者",children:["库的设计者",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#库的设计者",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 Web 前端的开发中，",(0,r.jsx)(n.code,{children:"version"}),"一般使用三位版本号 ",(0,r.jsx)(n.code,{children:"X.Y.Z"}),"（例如 1.2.3），如下所示："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"X：主版本号，当代码有非兼容性更新时，应该更新主版本号；"}),"\n",(0,r.jsx)(n.li,{children:"Y：次版本号，当代码有兼容性的新功能增加时，应该更新次版本号；"}),"\n",(0,r.jsx)(n.li,{children:"Z：修订号，当代码有兼容性的 Bug 修复时，应该更新修订号。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"库的设计一般需要遵循上述规范，比如新增一个函数，需要升级 Y 版本号。修复某个函数的 Bug，需要升级 Z 版本号。对项目进行了重构，导致使用者的库无法兼容，那么应该升级 X 版本号。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：更多关于版本的规范，可以查看 ",(0,r.jsx)(n.a,{href:"https://semver.org/lang/zh-CN/",target:"_blank",rel:"noopener noreferrer",children:"semver 2.0.0"})," 和 ",(0,r.jsx)(n.a,{href:"https://github.com/npm/node-semver#versions",target:"_blank",rel:"noopener noreferrer",children:"node-semver"}),"。 ",(0,r.jsx)(n.a,{href:"https://github.com/npm/node-semver#versions",target:"_blank",rel:"noopener noreferrer",children:"node-semver"})," 本身是一个库包，可用于版本比较。例如在发布脚本中可以使用 ",(0,r.jsx)(n.a,{href:"https://github.com/npm/node-semver#versions",target:"_blank",rel:"noopener noreferrer",children:"node-semver"})," 判断需要发布的版本是否低于已经在 NPM 官方发布的版本号，从而防止未遵循语义化的版本规范。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"库的使用者",children:["库的使用者",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#库的使用者",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"新增一个测试项目，并通过 NPM 包管理器安装 ziyi-micro-framework 库："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 随便找一个目录结构\nmkdir sdk-test\n# 进入项目目录\ncd sdk-test\n# 项目初始化，会自动新增 package.json\nnpm init\n# 安装库包，默认会安装最新版本，自动新增 package-lock.json 和 node_modules 文件夹\nnpm i ziyi-micro-framework --save\n"})}),"\n",(0,r.jsx)(n.p,{children:"安装完成后，默认会在项目中生成如下目录结构："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"├── node_modules/       # 库包存放的目录 \n├── package-lock.json   # 版本描述文件\n└── package.json        # 项目描述文件\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：",(0,r.jsx)(n.code,{children:"package-lock.json"})," 只会在 NPM >= 5.x 的版本中才会自动生成。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["使用 ",(0,r.jsx)(n.code,{children:"npm i ziyi-micro-framework --save"})," 进行库版本安装，默认会安装最新的版本 ，并会在 ",(0,r.jsx)(n.code,{children:"package.json"})," 中生成版本依赖信息："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'  "dependencies": {\n   // 安装时最新的版本为 1.0.4，并默认会在版本号之前添加一个 ^ 符号\n    "ziyi-micro-framework": "^1.0.4"\n  }\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：使用 ",(0,r.jsx)(n.code,{children:"npm i"})," 进行依赖安装时，如果是库的开发者，需要严格区分 ",(0,r.jsx)(n.code,{children:"--save"})," 和 ",(0,r.jsx)(n.code,{children:"--save-dev"})," 两个参数，前者是安装生产依赖，后者是安装开发依赖。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["在 NPM < 5 的版本中不会随着执行 ",(0,r.jsx)(n.code,{children:"npm i"})," 而自动生成",(0,r.jsx)(n.code,{children:"package-lock.json"}),"，",(0,r.jsx)(n.code,{children:"npm i"})," 的安装算法会遵循 ",(0,r.jsx)(n.a,{href:"https://semver.org/lang/zh-CN/",target:"_blank",rel:"noopener noreferrer",children:"semver 2.0.0"})," 规范，如果此时库的设计者发布了 1.0.5 版本，开发者执行 ",(0,r.jsx)(n.code,{children:"npm i"})," 进行依赖安装时，自动会将 ziyi-micro-framework 升级到 1.0.5 版本。在 ",(0,r.jsx)(n.code,{children:"package.json"})," 中的 semver 通配符的含义如下："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"^"}),"：例如以 ^1.0.0 为例，表示自动安装 1.0.0 <= 最新版本号 < 2.0.0；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"~"}),"：例如以 ~1.0.0 为例，表示自动安装 1.0.0 <= 最新版本号 < 1.1.0；"]}),"\n",(0,r.jsx)(n.li,{children:"无符号：例如 1.0.0，始终安装 1.0.0 固定版本号。"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：上述情况是在 ",(0,r.jsx)(n.code,{children:"package.json"})," 中常见的三位数版本号，可以思考一下 ",(0,r.jsx)(n.code,{children:"^0.1"}),"、",(0,r.jsx)(n.code,{children:"~1"})," 自动安装的最新版本号范围。NPM 安装的策略会确保不会自动升级主版本号，如果库的版本发布者严格遵循了 semver 版本规范，NPM 库包的版本自动升级不会给项目造成非兼容性更新。"]}),"\n",(0,r.jsxs)(n.p,{children:["需要注意固定版本并不代表 ",(0,r.jsx)(n.code,{children:"node_modules"})," 不存在该依赖的其他版本，因为可能存在安装的其他依赖也需要安装该依赖，而且依赖的版本不一致，此时 ",(0,r.jsx)(n.code,{children:"node_modules"})," 会形成一棵依赖树，可能存在不同版本的依赖。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"如果库的设计者不遵循 semver 2.0.0 规范，在 ziyi-micro-framework 发布了一个 1.0.5 非兼容性版本，那么使用 NPM 安装自动升级版本会导致项目出现 Bug。最可怕的是项目使用云构建出现如下情况而导致隐患："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"开发者 A：本地已经安装 ziyi-micro-framework 1.0.4 版本，开发没有问题；"}),"\n",(0,r.jsxs)(n.li,{children:["云构建：在服务器上使用 ",(0,r.jsx)(n.code,{children:"npm i"})," 自动安装了 1.0.5 版本进行构建，导致 Bug。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["为了可以在不同的开发环境或者构建环境都可以生成相同的 ",(0,r.jsx)(n.code,{children:"node_modules"})," 依赖树，NPM 5.x 版本在安装依赖时会自动生成 ",(0,r.jsx)(n.code,{children:"package-lock.json"})," 文件，该文件可以锁定项目的依赖树版本，从而确保通常情况下使用 ",(0,r.jsx)(n.code,{children:"npm i"})," 进行安装时不会自动升级版本号。",(0,r.jsx)(n.code,{children:"package-lock.json"}),"如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "name": "sdk-test",\n  "version": "1.0.0",\n  // 锁住的版本数量为 2（包括当前创建的测试项目自身的版本）\n  "lockfileVersion": 2,\n  "requires": true,\n  "packages": {\n    // 项目自身\n    "": {\n      "name": "sdk-test",\n      "version": "1.0.0",\n      "license": "ISC",\n      "dependencies": {\n        "ziyi-micro-framework": "^1.0.4"\n      }\n    },\n    // ziyi-micro-framework 库包\n    "node_modules/ziyi-micro-framework": {\n      "version": "1.0.4",\n      "resolved": "https://registry.npmjs.org/ziyi-micro-framework/-/ziyi-micro-framework-1.0.4.tgz",\n      "integrity": "sha512-kGMjHgdEOtlBfM+k/UAekoyGohmQFnJBFq5U09ajsdRsI89pLLEoSzas9/y02I6gEs+Hc05mKqJWAsL4mJZu+A=="\n    }\n  },\n  // 锁定的依赖树\n  "dependencies": {\n    // 依赖包的名称\n    "ziyi-micro-framework": {\n      // 依赖包的版本号\n      "version": "1.0.4",\n      // 依赖包的下载地址\n      "resolved": "https://registry.npmjs.org/ziyi-micro-framework/-/ziyi-micro-framework-1.0.4.tgz",\n      // 类似于 md5 算法的作用，可以用于验证下载资源的完整性（防篡改）\n      "integrity": "sha512-kGMjHgdEOtlBfM+k/UAekoyGohmQFnJBFq5U09ajsdRsI89pLLEoSzas9/y02I6gEs+Hc05mKqJWAsL4mJZu+A=="\n    }\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：在开发的过程中建议将 ",(0,r.jsx)(n.code,{children:"package-lock.json"})," 提交到仓库，任何情况下更新代码进行依赖安装都可以确保安装相同的 ",(0,r.jsx)(n.code,{children:"node_modules"})," 依赖树。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["例如开发者安装了 1.0.4 的版本，此时库包的发布者发布了 ziyi-micro-framework 的 1.0.5 版本，如果删除 ",(0,r.jsx)(n.code,{children:"node_modules"})," 重新执行 ",(0,r.jsx)(n.code,{children:"npm i"})," 进行依赖安装："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 删除依赖\nrm -rf node_modules\n# 依赖安装\nnpm i\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时项目中安装的仍然是 ziyi-micro-framework 的 1.0.4 版本，使用 ",(0,r.jsx)(n.code,{children:"package-lock.json"})," 的优势在于："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"多人协同开发时，可以确保都能安装完全一致的依赖树版本，确保开发的稳定性；"}),"\n",(0,r.jsx)(n.li,{children:"开发者本地开发和 CI / CD 自动构建能得到完全一致的依赖树版本，确保部署的稳定性。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["当然真正使用 CI / CD 进行自动构建时，可以使用更纯净的 ",(0,r.jsx)(n.code,{children:"npm ci"})," 进行依赖安装，它和 ",(0,r.jsx)(n.code,{children:"npm i"})," 的差异主要是："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["项目必须存在 ",(0,r.jsx)(n.code,{children:"package-lock.json"}),"或者 ",(0,r.jsx)(n.code,{children:"npm-shrinkwrap.json"}),"，否则会退出并报错；"]}),"\n",(0,r.jsxs)(n.li,{children:["如果 ",(0,r.jsx)(n.code,{children:"package-lock.json"})," 和 ",(0,r.jsx)(n.code,{children:"package.json"}),"中的依赖不匹配，会退出并报错；"]}),"\n",(0,r.jsx)(n.li,{children:"只能安装整个项目的依赖，无法安装单个依赖项；"}),"\n",(0,r.jsxs)(n.li,{children:["如果项目存在 ",(0,r.jsx)(n.code,{children:"node_modules"}),"，则会先删除 ",(0,r.jsx)(n.code,{children:"node_modules"})," 再进行依赖安装；"]}),"\n",(0,r.jsxs)(n.li,{children:["安装不会更改 ",(0,r.jsx)(n.code,{children:"package-lock.json"})," 和 ",(0,r.jsx)(n.code,{children:"package.json"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["温馨提示：如果在 ",(0,r.jsx)(n.code,{children:"package.json"}),"中更改或新增了某个依赖，使用 ",(0,r.jsx)(n.code,{children:"npm i"})," 进行安装，如果需要安装的依赖和 ",(0,r.jsx)(n.code,{children:"package-lock.json"})," 不匹配，则会根据 semver 规范进行安装，并将依赖版本更新到 ",(0,r.jsx)(n.code,{children:"package-lock.json"})," 中进行版本锁定，这和 ",(0,r.jsx)(n.code,{children:"npm ci"})," 命令是有差异的。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["在开发的过程中 1.0.4 版本的 ziyi-micro-framework 发生了 Bug，于是库的开发者发布了兼容性的 1.0.5 的版本进行 Bug 修复，在有 ",(0,r.jsx)(n.code,{children:"package-lock.json"})," 的情况下，可以通过如下几种方式进行版本升级："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 无效方式，因为 package-lock.json 锁定了安装依赖的版本号，默认不会自动进行安装依赖升级\nnpm i\n\n# 方式一：手动修改 package.json 中 ziyi-micro-framework 的版本号后，执行安装\n# 会自动更新 package-lock.json 中依赖的版本号进行锁定\nnpm i\n\n# 方式二：指定版本进行依赖安装，会自动更新 package-lock.json 中相应依赖的版本号进行锁定\nnpm i ziyi-micro-framework@1.0.5 --save\n\n# 方式三：执行 npm update，此种方式会升级 package.json 中的所有依赖的版本（固定版本除外）\n# 会自动更新 package-lock.json 中相应依赖的版本号进行锁定\nnpm update\n\n# 方式四：此种方式会升级 package.json 中的所有依赖的版本（固定版本除外）\n# 会自动更新 package-lock.json 中相应依赖的版本号进行锁定\n# 注意只删除 package-lock.json 可能无效\nrm -rf node_modules\nrm package-lock.json\nnpm i\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本节课主要讲解了如何基于构建产物进行发布脚本设计，该脚本支持发布前的构建文件预处理、发布分支卡口检测、构建产物检测和发布版本检测等，并可以一键发布 CommonJS 和 ES Modules 规范包。除此之外，本节课从版本的发布者和使用者出发，讲解了库包的版本发布规范和安装使用注意事项。在下节课中，我们重点讲解如何使用 ESLint 和 Prettier 规范微前端框架库的代码设计。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let l=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F30.%E5%B7%A5%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83.md"]={toc:[{text:"发布 NPM 库包",id:"发布-npm-库包",depth:2},{text:"发布管控",id:"发布管控",depth:2},{text:"版本规范",id:"版本规范",depth:2},{text:"库的设计者",id:"库的设计者",depth:3},{text:"库的使用者",id:"库的使用者",depth:3},{text:"小结",id:"小结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);