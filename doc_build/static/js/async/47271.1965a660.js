"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["47271"],{472975:function(e,n,r){r.r(n),r.d(n,{default:()=>t});var s=r(552676),i=r(740453);let h=r.p+"static/image/36975046619e61e3cbfd7354332a30ec.f1f7aa97.webp",d=r.p+"static/image/db105197744128d0b137f1ec9b4b97cb.71a04d3a.webp",l=r.p+"static/image/d80b3acf1ebd8bf4a069a81a7eb15d3b.3f41017a.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",strong:"strong",h3:"h3",ol:"ol",li:"li",code:"code",pre:"pre"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"17结语总结--延伸",children:["17.结语：总结 & 延伸",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17结语总结--延伸",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本课程从前端依赖治理这个角度出发，由浅入深讲解了代码静态分析需要掌握的基础知识、通用能力，帮助开发者一步一步实现了前端代码分析工具。"}),"\n",(0,s.jsx)(n.p,{children:"这一节课，我们一起来回顾一下课程的重点内容。"}),"\n",(0,s.jsxs)(n.h2,{id:"重点内容回顾",children:["重点内容回顾",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重点内容回顾",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"总的来说，课程分为三个阶段："}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"阶段一："})," 学习 AST 抽象语法树、编译原理，利用所学知识实现简单的 TS 代码分析脚本，帮助开发者快速上手。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"阶段二："})," 学习工具架构设计，掌握依赖调用的分析范式，建立通用方法论，根据分析范式逐步实现分析工具。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"阶段三："})," 学习配置 GitLab CI，通过分析工具实现“脏调用”拦截、自动化分析、报告推送、代码告警等应用场景。"]}),"\n",(0,s.jsxs)(n.h3,{id:"工具分析范式",children:["工具分析范式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工具分析范式",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"根据分析范式完善 codeAnalysis 基础类的过程就是实现代码分析工具的过程。"}),"\n",(0,s.jsxs)(n.h3,{id:"ast-分析方式",children:["AST 分析方式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ast-分析方式",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"自上而下的分析模式："})," 观察关键 AST 及其子节点结构特征，总结判定条件，然后根据判定条件实现分析逻辑。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"自下而上的分析模式："})," 从最末端叶子节点开启倒向漏斗筛选模式，经过多轮筛选后，可以准确定位目标节点。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"代码设计模式",children:["代码设计模式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码设计模式",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"面向对象："})," 把依赖调用分析过程中涉及的方法，属性都封装在一个名为 ",(0,s.jsx)(n.code,{children:"codeAnalysis"})," 的基础类中，可以把它理解成依赖调用分析流程的抽象，通过 new 生成分析实例后，我们可以通过该实例来驱动整个分析流程。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"组合模式："})," parse、file、score、report、constant 等模块供了代码分析之外的辅助能力，采用函数式设计，由 ",(0,s.jsx)(n.code,{children:"analysis"})," 模块通过组合模式按需引入，将分析代码之外的可复用逻辑抽离出来放在不同的模块中，可以更好地与主逻辑解耦。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"插件模式："})," 通过插件方案将 ",(0,s.jsx)(n.code,{children:"codeAnalysis"})," 主程序与分析具体指标的插件程序进行了分离，提高了主程序的稳定性，同时提升了工具的可拓展性。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"工具入口设计",children:["工具入口设计",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工具入口设计",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"CLI 模式："})," 即命令行模式，可以配合 npm script 来驱动，入口为可执行脚本，通常在 CI 中使用，特点是简单便捷。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"API 模式："})," 一种标准输出模式，可以让使用者快速集成代码分析能力到其它工具或服务中，该模式拓展了分析工具的应用场景。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"代码分析延伸",children:["代码分析延伸",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码分析延伸",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"代码静态分析是一个很大的概念，课程中关于代码编译、AST 处理等通用知识是可以帮助开发者实现针对其它分析目的的代码分析工具的，比如代码注释检查、变量命名检查和依赖套娃检查，下面我们一一来说。"}),"\n",(0,s.jsxs)(n.h3,{id:"代码注释检查",children:["代码注释检查",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码注释检查",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"代码注释是帮助开发者快速了解项目非常重要的参考信息，但是很多项目代码中存在乱写/不写注释的情况，我们可以通过代码静态分析来发现这些问题，进而推动开发者完善相应注释。"}),"\n",(0,s.jsx)(n.p,{children:"举个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"// add number deal fun\nfunction add(n: number) {\n    return n + 3;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["将上述代码放入 ",(0,s.jsx)(n.a,{href:"https://astexplorer.net/?spm=taofed.bloginfo.blog.3.3ba15ac8enL4hJ#/gist/881d78bbff88e23e52d6fc2b35f2b419/08994501ee540fe2e93afc6877ab738261ce14fd",target:"_blank",rel:"noopener noreferrer",children:"AST explorer"}),"，观察一下与注释相关的 AST 节点特征："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["遍历 AST 找到所有 ",(0,s.jsx)(n.code,{children:"FunctionDeclaration"})," 类型节点，这些节点就是在代码中定义的函数，然后依次检查这些节点的 ",(0,s.jsx)(n.code,{children:"*leadingComments"})," 属性。如果该属性不为空，则证明该函数有注释，然后遍历 ",(0,s.jsx)(n.code,{children:"*leadingComments"})," 这个数组，其中会有多行、单行等几种类型的注释，我们针对注释内容字符串进行拆解分析即可。如果函数类型节点不存在 ",(0,s.jsx)(n.code,{children:"*leadingComments"})," 属性，则说明该函数在声明时未写注释。"]}),"\n",(0,s.jsx)(n.p,{children:"虽然我们的课程没有教大家如何分析代码注释，但你在看完代码示例后就能基本明白要怎么做了，所以在学习完这门课程后，你已经不知不觉地掌握了代码静态分析的通用能力，这些东西会帮助你开发其它类型的分析工具。"}),"\n",(0,s.jsxs)(n.h3,{id:"变量命名检查",children:["变量命名检查",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#变量命名检查",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"很多前端项目开发者不会按照特定的规范去给变量起名字，所以在代码文件中难免会出现一些“敏感”变量名，或者抒发开发者“情绪”的变量名。"}),"\n",(0,s.jsx)(n.p,{children:"针对这种情况，我们可以通过代码静态分析找到并修复它们，一提到变量名称，大家肯定会想起 identifier 类型节点。是的，遍历所有 identifier 类型节点，对它们的名称属性进行检测，对命中敏感词系统的变量标记即可。"}),"\n",(0,s.jsxs)(n.h3,{id:"依赖套娃检查",children:["依赖套娃检查",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖套娃检查",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"很多项目会从外部依赖导入一些 API，但是它并不会直接使用，而是将外部依赖包裹一层后，再次导出给自己项目中的其它文件使用，举个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"import app from 'framework';\n\nexport { app as myApp };\n"})}),"\n",(0,s.jsx)(n.p,{children:"套娃会干扰正常依赖关系的判定，需要识别并标记此类场景，在学习了如何对 import 节点分析后，大家可以思考下如何识别代码套娃。"}),"\n",(0,s.jsx)(n.p,{children:"综上所述，代码静态分析是前端开发者必须掌握的一项基础能力，它可以帮助开发者了解并管控业务代码，这也是本门课程想要传达的核心思想。"}),"\n",(0,s.jsxs)(n.h2,{id:"相关源码",children:["相关源码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#相关源码",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts",target:"_blank",rel:"noopener noreferrer",children:"code-analysis-ts"}),"：代码分析工具 GitHub 源码。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-plugins",target:"_blank",rel:"noopener noreferrer",children:"code-analysis-plugins"}),"：分析工具插件库 GitHub 源码，承载社区贡献的自定义分析插件。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"}),"：演示如何使用 code-analysis-ts 代码分析工具的 Demo 项目，可以帮助开发者了解分析工具配置文件、评分插件、分析插件，API / CLI 使用模式，GitLab CI 自动化配置等，建议结合课程一起学习。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/all-projects-analysis",target:"_blank",rel:"noopener noreferrer",children:"all-projects-analysis"}),"：演示如何使用 code-analysis-ts 代码分析工具实现微前端架构全应用代码分析。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"参考阅读",children:["参考阅读",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考阅读",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://jkchao.github.io/typescript-book-chinese/compiler/overview.html",target:"_blank",rel:"noopener noreferrer",children:"https://jkchao.github.io/typescript-book-chinese/compiler/overview.html"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/372381276",target:"_blank",rel:"noopener noreferrer",children:"https://zhuanlan.zhihu.com/p/372381276"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6860749323181768717",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/6860749323181768717"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6844904177286512653#heading-8",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/6844904177286512653#heading-8"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6953963506693570573#heading-5",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/6953963506693570573#heading-5"})}),"\n"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F17.%E7%BB%93%E8%AF%AD%EF%BC%9A%E6%80%BB%E7%BB%93%20%26%20%E5%BB%B6%E4%BC%B8.md"]={toc:[{text:"重点内容回顾",id:"重点内容回顾",depth:2},{text:"工具分析范式",id:"工具分析范式",depth:3},{text:"AST 分析方式",id:"ast-分析方式",depth:3},{text:"代码设计模式",id:"代码设计模式",depth:3},{text:"工具入口设计",id:"工具入口设计",depth:3},{text:"代码分析延伸",id:"代码分析延伸",depth:2},{text:"代码注释检查",id:"代码注释检查",depth:3},{text:"变量命名检查",id:"变量命名检查",depth:3},{text:"依赖套娃检查",id:"依赖套娃检查",depth:3},{text:"相关源码",id:"相关源码",depth:2},{text:"参考阅读",id:"参考阅读",depth:2}],title:"17.结语：总结 & 延伸",headingTitle:"17.结语：总结 & 延伸",frontmatter:{}}}}]);