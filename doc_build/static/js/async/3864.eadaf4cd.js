"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["3864"],{308010:function(n,e,t){t.r(e),t.d(e,{default:()=>l});var r=t(552676),s=t(740453);let i=t.p+"static/image/e437a7715b3d41dff3ec4b797daf80e8.e167bc0d.webp",a=t.p+"static/image/41f13d282ce08d23de5197ed338b20e2.950eda70.webp",o=t.p+"static/image/e1f3f860a2cfe12f220d6fab7a1d47ec.c097934e.webp";function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",img:"img",strong:"strong",ul:"ul",li:"li",h3:"h3"},(0,s.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"26手写-bundler_--实现-javascript-ast-解析器词法分析语义分析",children:["26.手写 Bundler_  实现 JavaScript AST 解析器——词法分析、语义分析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#26手写-bundler_--实现-javascript-ast-解析器词法分析语义分析",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在前面两节的内容中，我们一起手写了一个迷你版的 no-bundle 开发服务，也就是 Vite 开发阶段的 Dev Server，而在生产环境下面，处于页面性能的考虑，Vite 还是选择进行打包(bundle)，并且在底层使用 Rollup 来完成打包的过程。在接下来的篇幅中，我们就来实现一个 JavaScript Bundler，让你理解生产环境下 Vite/Rollup 的模块打包究竟是如何实现的。"}),"\n",(0,r.jsxs)(e.p,{children:["不过，需要提前声明的是，Bundler 的实现非常依赖于 AST 的实现，有相当多的地方需要解析模块 AST 并且操作 AST 节点，因此，我们有必要先完成 AST 解析的方案。目前在业界有诸多的 JavaScript AST 解析方案，如",(0,r.jsx)(e.code,{children:"acorn"}),"、",(0,r.jsx)(e.code,{children:"@babel/parser"}),"、",(0,r.jsx)(e.code,{children:"swc"})," 等，可以实现开箱即用，但为了让大家对其中的原理理解得更为深入，本小节会教大家一步步开发出 AST 的解析器，实现 ",(0,r.jsx)(e.code,{children:"tokenize"})," 和 ",(0,r.jsx)(e.code,{children:"parse"})," 的底层逻辑，而这本身也是一件非常有意思的事情，相信你经过本节的学习也能领略到前端编译领域的底层风光。"]}),"\n",(0,r.jsxs)(e.h2,{id:"搭建开发测试环境",children:["搭建开发测试环境",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#搭建开发测试环境",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["首先通过",(0,r.jsx)(e.code,{children:"pnpm init -y"}),"新建项目，安装测试工具",(0,r.jsx)(e.code,{children:"vitest"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"pnpm i vitest -D\n"})}),"\n",(0,r.jsxs)(e.p,{children:["新建 ",(0,r.jsx)(e.code,{children:"src/__test__"})," 目录，之后所有的测试代码都会放到这个目录中。我们不妨先尝试编写一个测试文件:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'// src/__test__/example.test.ts\nimport { describe, test, expect } from "vitest";\n\ndescribe("example test", () => {\n  test("should return correct result", () => {\n    expect(2 + 2).toBe(4);\n  });\n});\n'})}),"\n",(0,r.jsxs)(e.p,{children:["然后在",(0,r.jsx)(e.code,{children:"package.json"}),"中增加如下的 ",(0,r.jsx)(e.code,{children:"scripts"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-json",children:'"test": "vitest"\n'})}),"\n",(0,r.jsxs)(e.p,{children:["接着在命令行执行 ",(0,r.jsx)(e.code,{children:"pnpm test"}),"，如果你可以看到如下的终端界面，说明测试环境已经搭建成功:"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(e.h2,{id:"词法分析器开发",children:["词法分析器开发",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#词法分析器开发",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["接下来，我们正式进入 AST 解析器的开发，主要分为两个部分来进行: ",(0,r.jsx)(e.code,{children:"词法分析器"}),"和",(0,r.jsx)(e.code,{children:"语法分析器"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["首先是",(0,r.jsx)(e.code,{children:"词法分析器"}),"，也叫分词器(Tokenizer)，它的作用是将代码划分为一个个词法单元，便于进行后续的语法分析。比如下面的这段代码:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"let foo = function() {}\n"})}),"\n",(0,r.jsx)(e.p,{children:"在经过分词之后，代码会被切分为如下的 token 数组:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"['let', 'foo', '=', 'function', '(', ')', '{', '}']\n"})}),"\n",(0,r.jsxs)(e.p,{children:["从中你可以看到，原本一行普通的代码字符串被拆分成了拥有语法属性的 token 列表，不同的 token 之间也存在千丝万缕的联系，而后面所要介绍的",(0,r.jsx)(e.code,{children:"语法分析器"}),"，就是来梳理各个 token 之间的联系，整理出 AST 数据结构。"]}),"\n",(0,r.jsxs)(e.p,{children:["当下我们所要实现的词法分析器，本质上是",(0,r.jsx)(e.strong,{children:"对代码字符串进行逐个字符的扫描，然后根据一定的语法规则进行分组"}),"。其中，涉及到几个关键的步骤:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"确定语法规则，包括语言内置的关键词、单字符、分隔符等"}),"\n",(0,r.jsx)(e.li,{children:"逐个代码字符扫描，根据语法规则进行 token 分组"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"接下来我们以一个简单的语法为例，来初步实现如上的关键流程。需要解析的示例代码如下:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"let foo = function() {}\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"1-确定语法规则",children:["1. 确定语法规则",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-确定语法规则",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["新建",(0,r.jsx)(e.code,{children:"src/Tokenizer.ts"}),"，首先声明一些必要的类型:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'export enum TokenType {\n  // let\n  Let = "Let",\n  // =\n  Assign = "Assign",\n  // function\n  Function = "Function",\n  // 变量名\n  Identifier = "Identifier",\n  // (\n  LeftParen = "LeftParen",\n  // )\n  RightParen = "RightParen",\n  // {\n  LeftCurly = "LeftCurly",\n  // }\n  RightCurly = "RightCurly",\n}\n\nexport type Token = {\n  type: TokenType;\n  value?: string;\n  start: number;\n  end: number;\n  raw?: string;\n};\n'})}),"\n",(0,r.jsx)(e.p,{children:"然后定义 Token 的生成器对象:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'const TOKENS_GENERATOR: Record<string, (...args: any[]) => Token> = {\n  let(start: number) {\n    return { type: TokenType.Let, value: "let", start, end: start + 3 };\n  },\n  assign(start: number) {\n    return { type: TokenType.Assign, value: "=", start, end: start + 1 };\n  },\n  function(start: number) {\n    return {\n      type: TokenType.Function,\n      value: "function",\n      start,\n      end: start + 8,\n    };\n  },\n  leftParen(start: number) {\n    return { type: TokenType.LeftParen, value: "(", start, end: start + 1 };\n  },\n  rightParen(start: number) {\n    return { type: TokenType.RightParen, value: ")", start, end: start + 1 };\n  },\n  leftCurly(start: number) {\n    return { type: TokenType.LeftCurly, value: "{", start, end: start + 1 };\n  },\n  rightCurly(start: number) {\n    return { type: TokenType.RightCurly, value: "}", start, end: start + 1 };\n  },\n  identifier(start: number, value: string) {\n    return {\n      type: TokenType.Identifier,\n      value,\n      start,\n      end: start + value.length,\n    };\n  },\n}\n\ntype SingleCharTokens = "(" | ")" | "{" | "}" | "=";\n\n// 单字符到 Token 生成器的映射\nconst KNOWN_SINGLE_CHAR_TOKENS = new Map<\n  SingleCharTokens,\n  typeof TOKENS_GENERATOR[keyof typeof TOKENS_GENERATOR]\n>([\n  ["(", TOKENS_GENERATOR.leftParen],\n  [")", TOKENS_GENERATOR.rightParen],\n  ["{", TOKENS_GENERATOR.leftCurly],\n  ["}", TOKENS_GENERATOR.rightCurly],\n  ["=", TOKENS_GENERATOR.assign],\n]);\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"2-代码字符扫描分组",children:["2. 代码字符扫描、分组",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-代码字符扫描分组",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"现在我们开始实现 Tokenizer 对象:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"export class Tokenizer {\n  private _tokens: Token[] = [];\n  private _currentIndex: number = 0;\n  private _source: string;\n  constructor(input: string) {\n    this._source = input;\n  }\n  tokenize(): Token[] {\n    while (this._currentIndex < this._source.length) {\n      let currentChar = this._source[this._currentIndex];\n      const startIndex = this._currentIndex;\n      \n      // 根据语法规则进行 token 分组\n    }\n    return this._tokens;\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"在扫描字符的过程，我们需要对不同的字符各自进行不同的处理，具体的策略如下："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["当前字符为分隔符，如",(0,r.jsx)(e.code,{children:"空格"}),"，直接跳过，不处理；"]}),"\n",(0,r.jsxs)(e.li,{children:["当前字符为字母，需要继续扫描，获取完整的单词:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"如果单词为语法关键字，则新建相应关键字的 Token"}),"\n",(0,r.jsx)(e.li,{children:"否则视为普通的变量名"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["当前字符为单字符，如",(0,r.jsx)(e.code,{children:"{"}),"、",(0,r.jsx)(e.code,{children:"}"}),"、",(0,r.jsx)(e.code,{children:"("}),"、",(0,r.jsx)(e.code,{children:")"}),"，则新建单字符对应的 Token"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"接着我们在代码中实现:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'// while 循环内部\nlet currentChar = this._source[this._currentIndex];\nconst startIndex = this._currentIndex;\n\nconst isAlpha = (char: string): boolean => {\n  return (char >= "a" && char <= "z") || (char >= "A" && char <= "Z");\n}\n\n// 1. 处理空格\nif (currentChar === \' \') {\n  this._currentIndex++;\n  continue;\n}\n// 2. 处理字母\nelse if (isAlpha(currentChar)) {\n  let identifier = \'\';\n  while(isAlpha(currentChar)) {\n    identifier += currentChar;\n    this._currentIndex ++;\n    currentChar = this._source[this._currentIndex];\n  }\n  let token: Token;\n  if (identifier in TOKENS_GENERATOR) {\n    // 如果是关键字\n    token =\n        TOKENS_GENERATOR[identifier as keyof typeof TOKENS_GENERATOR](\n          startIndex\n        );\n  } else {\n    // 如果是普通标识符\n    token = TOKENS_GENERATOR["identifier"](startIndex, identifier);\n  }\n  this._tokens.push(token);\n  continue;\n}\n// 3. 处理单字符\nelse if(KNOWN_SINGLE_CHAR_TOKENS.has(currentChar as SingleCharTokens)) {\n  const token = KNOWN_SINGLE_CHAR_TOKENS.get(\n    currentChar as SingleCharTokens\n  )!(startIndex);\n  this._tokens.push(token);\n  this._currentIndex++;\n  continue;\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["OK，接下来我们来增加测试用例，新建",(0,r.jsx)(e.code,{children:"src/__test__/tokenizer.test.ts"}),"，内容如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'describe("testTokenizerFunction", () => {\n  test("test example", () => {\n    const result = [\n      { type: "Let", value: "let", start: 0, end: 3 },\n      { type: "Identifier", value: "a", start: 4, end: 5 },\n      { type: "Assign", value: "=", start: 6, end: 7 },\n      { type: "Function", value: "function", start: 8, end: 16 },\n      { type: "LeftParen", value: "(", start: 16, end: 17 },\n      { type: "RightParen", value: ")", start: 17, end: 18 },\n      { type: "LeftCurly", value: "{", start: 19, end: 20 },\n      { type: "RightCurly", value: "}", start: 20, end: 21 },\n    ];\n    const tokenizer = new Tokenizer("let a = function() {}");\n    expect(tokenizer.tokenize()).toEqual(result);\n  });\n});\n'})}),"\n",(0,r.jsxs)(e.p,{children:["然后在终端执行",(0,r.jsx)(e.code,{children:"pnpm test"}),"，可以发现如下的测试结果:"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"说明此时一个简易版本的分词器已经被我们开发出来了，不过目前的分词器还比较简陋，仅仅支持有限的语法，不过在明确了核心的开发步骤之后，后面继续完善的过程就比较简单了。"}),"\n",(0,r.jsxs)(e.h2,{id:"语法分析器开发",children:["语法分析器开发",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#语法分析器开发",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在解析出词法 token 之后，我们就可以进入语法分析阶段了。在这个阶段，我们会依次遍历 token，对代码进行语法结构层面的分析，最后的目标是生成 AST 数据结构。至于代码的 AST 结构到底是什么样子，你可以去 ",(0,r.jsx)(e.a,{href:"https://astexplorer.net/",target:"_blank",rel:"noopener noreferrer",children:"AST Explorer"})," 网站进行在线预览:"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们要做的就是将 token 数组转换为上图所示的 AST 数据。"}),"\n",(0,r.jsxs)(e.p,{children:["首先新建",(0,r.jsx)(e.code,{children:"src/Parser.ts"}),"，添加如下的类型声明代码及 ",(0,r.jsx)(e.code,{children:"Parser"})," 类的初始化代码:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'export enum NodeType {\n  Program = "Program",\n  VariableDeclaration = "VariableDeclaration",\n  VariableDeclarator = "VariableDeclarator",\n  Identifier = "Identifier",\n  FunctionExpression = "FunctionExpression",\n  BlockStatement = "BlockStatement",\n}\n\nexport interface Node { \n  type: string;\n  start: number;\n  end: number;\n}\n\nexport interface Identifier extends Node {\n  type: NodeType.Identifier;\n  name: string;\n}\n\ninterface Expression extends Node {}\n\ninterface Statement extends Node {}\n\nexport interface Program extends Node {\n  type: NodeType.Program;\n  body: Statement[];\n}\n\nexport interface VariableDeclarator extends Node {\n  type: NodeType.VariableDeclarator;\n  id: Identifier;\n  init: Expression;\n}\n\nexport interface VariableDeclaration extends Node {\n  type: NodeType.VariableDeclaration;\n  kind: "var" | "let" | "const";\n  declarations: VariableDeclarator[];\n}\n\nexport interface FunctionExpression extends Node {\n  type: NodeType.FunctionExpression;\n  id: Identifier | null;\n  params: Expression[] | Identifier[];\n  body: BlockStatement;\n}\n\nexport interface BlockStatement extends Node {\n  type: NodeType.BlockStatement;\n  body: Statement[];\n}\n\nexport type VariableKind = "let";\n\nexport class Parser {\n  private _tokens: Token[] = [];\n  private _currentIndex = 0;\n  constructor(token: Token[]) {\n    this._tokens = [...token];\n  }\n  \n  parse(): Program {\n    const program = this._parseProgram();\n    return program;\n  }\n  \n  private _parseProgram(): Program {\n    const program: Program = {\n      type: NodeType.Program,\n      body: [],\n      start: 0,\n      end: Infinity,\n    };\n    // 解析 token 数组\n    return program;\n  }\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["从中你可以看出，解析 AST 的核心逻辑就集中在 ",(0,r.jsx)(e.code,{children:"_parseProgram"})," 方法中，接下来让我们一步步完善一个方法:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'export class Parser {\n  private _parseProgram {\n    // 省略已有代码\n    while (!this._isEnd()) {\n      const node = this._parseStatement();\n      program.body.push(node);\n      if (this._isEnd()) {\n        program.end = node.end;\n      }\n    }\n    return program;\n  }\n  // token 是否已经扫描完\n  private _isEnd(): boolean {\n    return this._currentIndex >= this._tokens.length;\n  }\n  // 工具方法，表示消费当前 Token，扫描位置移动到下一个 token\n  private _goNext(type: TokenType | TokenType[]): Token {\n    const currentToken = this._tokens[this._currentIndex];\n    // 断言当前 Token 的类型，如果不能匹配，则抛出错误\n    if (Array.isArray(type)) {\n      if (!type.includes(currentToken.type)) {\n        throw new Error(\n          `Expect ${type.join(",")}, but got ${currentToken.type}`\n        );\n      }\n    } else {\n      if (currentToken.type !== type) {\n        throw new Error(`Expect ${type}, but got ${currentToken.type}`);\n      }\n    }\n    this._currentIndex++;\n    return currentToken;\n  }\n  \n  private _checkCurrentTokenType(type: TokenType | TokenType[]): boolean {\n    if (this._isEnd()) {\n      return false;\n    }\n    const currentToken = this._tokens[this._currentIndex];\n    if (Array.isArray(type)) {\n      return type.includes(currentToken.type);\n    } else {\n      return currentToken.type === type;\n    }\n  }\n\n  private _getCurrentToken(): Token {\n    return this._tokens[this._currentIndex];\n  }\n  \n  private _getPreviousToken(): Token {\n    return this._tokens[this._currentIndex - 1];\n  }\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["一个程序(Program)实际上由各个语句(Statement)来构成，因此在",(0,r.jsx)(e.code,{children:"_parseProgram"}),"逻辑中，我们主要做的就是扫描一个个语句，然后放到 Program 对象的 body 中。那么，接下来，我们将关注点放到语句的扫描逻辑上面。"]}),"\n",(0,r.jsx)(e.p,{children:"从之前的示例代码:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"let a = function() {}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["我们可以知道这是一个变量声明语句，那么现在我们就在 ",(0,r.jsx)(e.code,{children:"_parseStatement"})," 中实现这类语句的解析:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'export enum NodeType {\n  Program = "Program",\n  VariableDeclarator = "VariableDeclarator",\n}\n\nexport class Parser {\n  private _parseStatement(): Statement {\n    // TokenType 来自 Tokenizer 的实现中\n    if (this._checkCurrentTokenType(TokenType.Let)) {\n      return this._parseVariableDeclaration();\n    }\n    throw new Error("Unexpected token");\n  }\n  \n  private _parseVariableDeclaration(): VariableDeclaration {\n    // 获取语句开始位置\n    const { start } = this._getCurrentToken();\n    // 拿到 let\n    const kind = this._getCurrentToken().value;\n    this._goNext(TokenType.Let);\n    // 解析变量名 foo\n    const id = this._parseIdentifier();\n    // 解析 = \n    this._goNext(TokenType.Assign);\n    // 解析函数表达式\n    const init = this._parseFunctionExpression();\n    const declarator: VariableDeclarator = {\n      type: NodeType.VariableDeclarator,\n      id,\n      init,\n      start: id.start,\n      end: init ? init.end : id.end,\n    };\n    // 构造 Declaration 节点\n    const node: VariableDeclaration = {\n      type: NodeType.VariableDeclaration,\n      kind: kind as VariableKind,\n      declarations: [declarator],\n      start,\n      end: this._getPreviousToken().end,\n    };\n    return node;\n  }\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"接下来主要的代码解析逻辑可以梳理如下:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["发现 ",(0,r.jsx)(e.code,{children:"let"})," 关键词对应的 token，进入 ",(0,r.jsx)(e.code,{children:"_parseVariableDeclaration"})]}),"\n",(0,r.jsxs)(e.li,{children:["解析变量名，如示例代码中的 ",(0,r.jsx)(e.code,{children:"foo"})]}),"\n",(0,r.jsxs)(e.li,{children:["解析函数表达式，如示例代码中的 ",(0,r.jsx)(e.code,{children:"function() {}"})]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["其中，解析变量名的过程我们通过",(0,r.jsx)(e.code,{children:"_parseIdentifier"})," 方法实现，解析函数表达式的过程由",(0,r.jsx)(e.code,{children:"_parseFunctionExpression"}),"来实现，代码如下:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'// 1. 解析变量名\nprivate _parseIdentifier(): Identifier {\n  const token = this._getCurrentToken();\n  const identifier: Identifier = {\n    type: NodeType.Identifier,\n    name: token.value!,\n    start: token.start,\n    end: token.end,\n  };\n  this._goNext(TokenType.Identifier);\n  return identifier;\n}\n\n// 2. 解析函数表达式\nprivate _parseFunctionExpression(): FunctionExpression {\n  const { start } = this._getCurrentToken();\n  this._goNext(TokenType.Function);\n  let id = null;\n  if (this._checkCurrentTokenType(TokenType.Identifier)) {\n    id = this._parseIdentifier();\n  }\n  const node: FunctionExpression = {\n    type: NodeType.FunctionExpression,\n    id,\n    params: [],\n    body: {\n      type: NodeType.BlockStatement,\n      body: [],\n      start: start,\n      end: Infinity,\n    },\n    start,\n    end: 0,\n  };\n  return node;\n}\n\n// 用于解析函数参数\nprivate _parseParams(): Identifier[] | Expression[] {\n  // 消费 "("\n  this._goNext(TokenType.LeftParen);\n  const params = [];\n  // 逐个解析括号中的参数\n  while (!this._checkCurrentTokenType(TokenType.RightParen)) {\n    let param = this._parseIdentifier();\n    params.push(param);\n  }\n  // 消费 ")"\n  this._goNext(TokenType.RightParen);\n  return params;\n}\n\n// 用于解析函数体\nprivate _parseBlockStatement(): BlockStatement {\n  const { start } = this._getCurrentToken();\n  const blockStatement: BlockStatement = {\n    type: NodeType.BlockStatement,\n    body: [],\n    start,\n    end: Infinity,\n  };\n  // 消费 "{"\n  this._goNext(TokenType.LeftCurly);\n  while (!this._checkCurrentTokenType(TokenType.RightCurly)) {\n    // 递归调用 _parseStatement 解析函数体中的语句(Statement)\n    const node = this._parseStatement();\n    blockStatement.body.push(node);\n  }\n  blockStatement.end = this._getCurrentToken().end;\n  // 消费 "}"\n  this._goNext(TokenType.RightCurly);\n  return blockStatement;\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"OK，一个简易的 Parser 现在就已经搭建出来了，你可以用如下的测试用例看看程序运行的效果，代码如下:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:'// src/__test__/parser.test.ts\ndescribe("testParserFunction", () => {\n  test("test example code", () => {\n    const result = {\n      type: "Program",\n      body: [\n        {\n          type: "VariableDeclaration",\n          kind: "let",\n          declarations: [\n            {\n              type: "VariableDeclarator",\n              id: {\n                type: "Identifier",\n                name: "a",\n                start: 4,\n                end: 5,\n              },\n              init: {\n                type: "FunctionExpression",\n                id: null,\n                params: [],\n                body: {\n                  type: "BlockStatement",\n                  body: [],\n                  start: 19,\n                  end: 21,\n                },\n                start: 8,\n                end: 21,\n              },\n              start: 0,\n              end: 21,\n            },\n          ],\n          start: 0,\n          end: 21,\n        },\n      ],\n      start: 0,\n      end: 21,\n    };\n    const code = `let a = function() {};`;\n    const tokenizer = new Tokenizer(code);\n    const parser = new Parser(tokenizer.tokenize());\n    expect(parser.parse()).toEqual(result);\n  });\n});\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["恭喜你，学习完了本小节的内容。在本小节中，你需要重点掌握 AST 解析器中",(0,r.jsx)(e.code,{children:"词法分析"}),"和",(0,r.jsx)(e.code,{children:"语法分析"}),"的核心原理与实现细节。"]}),"\n",(0,r.jsx)(e.p,{children:"虽然本节只是实现了一个比较简陋的 AST 解析器，但重点在于整个词法分析和语法分析代码框架的搭建。当核心的流程已经实现之后，接下来的事情就是基于已有的代码框架不断地完善语法细节，整体的难度降低了很多。"}),"\n",(0,r.jsx)(e.p,{children:"另外，小册的 Github 仓库中在本小节的基础上已经实现了一个更加完整的 AST 解析器，虽然代码量远远多于本节的示例代码，但原理完全一样，很容易理解。当 AST 解析的功能被开发完成后，接下来要做的就是正式实现一个 Bundler 的功能了，让我们下一节不见不散\uD83D\uDC4B\uD83C\uDFFB"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F26.%E6%89%8B%E5%86%99%20Bundler_%20%20%E5%AE%9E%E7%8E%B0%20JavaScript%20AST%20%E8%A7%A3%E6%9E%90%E5%99%A8%E2%80%94%E2%80%94%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E3%80%81%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90.md"]={toc:[{text:"搭建开发测试环境",id:"搭建开发测试环境",depth:2},{text:"词法分析器开发",id:"词法分析器开发",depth:2},{text:"1. 确定语法规则",id:"1-确定语法规则",depth:3},{text:"2. 代码字符扫描、分组",id:"2-代码字符扫描分组",depth:3},{text:"语法分析器开发",id:"语法分析器开发",depth:2},{text:"小结",id:"小结",depth:2}],title:"26.手写 Bundler_  实现 JavaScript AST 解析器——词法分析、语义分析",headingTitle:"26.手写 Bundler_  实现 JavaScript AST 解析器——词法分析、语义分析",frontmatter:{}}}}]);