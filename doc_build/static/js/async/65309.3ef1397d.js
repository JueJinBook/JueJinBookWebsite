"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["65309"],{281647:function(n,e,r){r.r(e),r.d(e,{default:()=>p});var i=r(552676),o=r(740453);let t=r.p+"static/image/bfae04eca188b64ad52dbd2fee122100.f00d8454.webp",s=r.p+"static/image/e240bac60fc3bf01ecbf5a121add7385.2b3a8f74.webp",l=r.p+"static/image/dc1787cb82308728c2c485801b411d87.9ded458f.webp",c=r.p+"static/image/8a91c8686385a0a4d4e2a72724b72cf7.ef3baf2f.webp";function d(n){let e=Object.assign({p:"p",img:"img",h2:"h2",a:"a",ul:"ul",li:"li",h3:"h3",pre:"pre",code:"code",ol:"ol"},(0,o.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:"组件库一般都会配有周边产品，比如 Admin 、Template、CLI 工具等等。周边产品相当于有关联的多个项目，更准确的说法是多个软件包。这个时候就应该使用 Monorepo 方式组织代码，方便频繁在多个项目间同时交替开发，同时发布，保持版本间没有冲突。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:c,alt:""})}),"\n",(0,i.jsxs)(e.h2,{id:"传统-mutirepo-方式的不足",children:["传统 Mutirepo 方式的不足",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#传统-mutirepo-方式的不足",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"所谓传统方式，我们称之为 Multirepo 方式，或者可以称之为 MutiPackage-MultiRepo 方式。就是说遇到多个软件包的场景，使用多个 Repo 仓库的方式组织代码。"}),"\n",(0,i.jsx)(e.p,{children:"换句话说就是，一个软件包一个 Repo 仓库。其实我们常见的前端项目默认就是这样的模式。这种方式最大的问题就是在多个项目间切换开发会非常不方便。比如： 在开发 Admin 项目的时候，发现 UI 库需要增加了一个功能，那你需要以下步骤："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"从 Git 库克隆 UI 库代码；"}),"\n",(0,i.jsx)(e.li,{children:"修改 UI 库代码；"}),"\n",(0,i.jsx)(e.li,{children:"推送 UI 库到 Git 库；"}),"\n",(0,i.jsx)(e.li,{children:"推送 UI 库到 Npm 库；"}),"\n",(0,i.jsx)(e.li,{children:"在 Admin 中更新最新的 UI 库。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"这个过程假设一次修改不满意频繁更新，那么整个过程还会不断重复。"}),"\n",(0,i.jsx)(e.p,{children:"优化的方案，是使用 npm link 方式把几个项目的本地目录链接起来。但是这种方法依然有弊端，比如在团队开发的时候，你必须随时同步所有的代码仓库。另外如果你的代码不希望公开到 Npm 上，你还需要建立私有的 Npm 仓库。"}),"\n",(0,i.jsxs)(e.h2,{id:"monorepo-的优势",children:["Monorepo 的优势",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#monorepo-的优势",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"Monorepo 其实就是将多个项目 （pacakage 软件包）放到同一个仓库 （Repo） 中进行管理。这种代码组织形式可以更好地管理多 Package 项目。主要的优点有："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"可见性 （Visibility）: 每个开发者都可以方便地查看多个包的代码，方便修改跨 Package 的 Bug。比如开发 Admin 的时候发现UI 有问题，随手就可以修改。"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"更简单的包管理方式（Simpler dependency management）： 由于共享依赖简单，因此所有模块都托管在同一个存储库中，因此都不需要私有包管理器。"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"唯一依赖源（Single source of truth）： 每个依赖只有一个版本，可以防止版本冲突，没有依赖地狱。"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"原子提交： 方便大规模重构，开发者可以一次提交多个包（package）。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"同样是上面的那个同时开发 Admin 和 UI 的场景。当你开发 Admin 时，发现UI 有要修改之处，只需要切换目录修改，这时候马上就可以验证修改后的效果了，无需提交软件包，无需担心软件冲突。"}),"\n",(0,i.jsx)(e.p,{children:"越复杂的场景，你会发现这种好处会更加明显。比如一个 UI 库对应两个Admin 。这时候你希望重构一下某个组件的属性。这种重构需要同时调整三个包中的代码。使用 Monorepo ，你可以不必有任何心智负担，调整后立刻验证两个 Admin 效果，同时发布就好。"}),"\n",(0,i.jsxs)(e.h2,{id:"用户故事userstory",children:["用户故事(UserStory)",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#用户故事userstory",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"将组件库重构为 Monorepo 风格管理，方便后续组件库生态建设。"}),"\n",(0,i.jsxs)(e.h2,{id:"任务分解task",children:["任务分解(Task)",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#任务分解task",children:"#"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Monorepo方案选型；"}),"\n",(0,i.jsx)(e.li,{children:"重构Monorepo；"}),"\n",(0,i.jsx)(e.li,{children:"测试Monorepo效果。"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"方案选型",children:["方案选型",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#方案选型",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"目前 JS 中常见的 Monorepo 大概有两种选择：Lerna、Pnpm workspace。"}),"\n",(0,i.jsx)(e.p,{children:"其实在 Pnpm 横空出世前，基本上就是 lerna 一统天下的局面。连 Vue3 早期都是使用 lerna 做的 Monorepo 方案。"}),"\n",(0,i.jsx)(e.p,{children:"lernaJS 是由 Babel 团队编写的多包管理工具。因为 Babel 体系的规模庞大后有很多子包需要管理，放在多个仓库管理起来比较困难。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://github.com/babel/babel/tree/main/packages",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/babel/babel/tree/main/packages"})}),"\n",(0,i.jsx)(e.p,{children:"小伙伴们可以欣赏一下，一眼望不到边。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"无奈长江后浪推前浪，2021 年底 Pnpm 横空出世，闪电般的性能一下子征服了所有前端开发者。更重要的是它还附带 monorepo 方案。这个时候基本上没有任何开发者会抵挡这种诱惑，包括Vue3.0。"}),"\n",(0,i.jsx)(e.p,{children:"最终毫无疑问，我们选择 Pnpm 来搭建我们的技术方案。"}),"\n",(0,i.jsxs)(e.h3,{id:"修改软件包目录结构",children:["修改软件包目录结构",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#修改软件包目录结构",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"├── packages\n|   ├── smarty-ui-vite  // UI组件库\n|   |   ├── package.json\n|   ├── docs-ui-vite // docs文档\n|   |   ├── package.json\n├── package.json\n"})}),"\n",(0,i.jsx)(e.p,{children:"首先将原有的组件库代码移动至 smarty-ui-vite目录。"}),"\n",(0,i.jsxs)(e.h3,{id:"初始化monorepo软件包",children:["初始化Monorepo软件包",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化monorepo软件包",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"在根目录重新初始化一个 npm。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"pnpm init\n"})}),"\n",(0,i.jsx)(e.p,{children:"然后需要在软件包中禁用 npm 和 yarn。这一步的目的是允许项目使用 pnpm 进行模块管理。不然的话会出现不兼容问题。"}),"\n",(0,i.jsx)(e.p,{children:"方法是添加 preinstall npm hook 钩子，这个钩子会在安装模块前触发，检查该代码是否是使用 pnpm 运行。如果不是的话会推出并提示错误。"}),"\n",(0,i.jsx)(e.p,{children:"package.json"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'"scripts": {\n  "preinstall": "node ./scripts/preinstall.js"\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"实现当运行 npm install 或 yarn，就会发生错误并且不会继续安装。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"if (!/pnpm/.test(process.env.npm_execpath || '')) {\n  console.log('不懂问然叔')\n  console.warn(\n    `\\u001b[33mThis repository requires using pnpm as the package manager ` +\n      ` for scripts to work properly.\\u001b[39m\\n`\n  )\n  process.exit(1)\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"或者可以考虑使用"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-json",children:'"scripts": {\n    "preinstall": "npx only-allow pnpm"\n}\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"初始化工作空间",children:["初始化工作空间",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化工作空间",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"在monorepo项目中，每个软件包会存放在工作空间，方便管理。"}),"\n",(0,i.jsx)(e.p,{children:"首先需要创建一个 pnpm-workspace.yaml，这个文件用于声明所有软件包全部存放在 packages 目录之中。其实目前 monorepo 风格的项目也普遍使用 packages 作为默认软件包目录位置。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"packages:\n  # all packages in subdirs of packages/ and components/\n  - 'packages/**'\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"创建一个新的软件包",children:["创建一个新的软件包",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#创建一个新的软件包",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"由于 smarty-ui-vite 这个组件库包已经放在 packages 目录之中了。无需其他过多的设置，它就可以当做 monorepo 工程中的一个项目了。"}),"\n",(0,i.jsx)(e.p,{children:"下面我们试试从零开始如何使用 pnpm 创建一个子软件包，并正确引用组件库。"}),"\n",(0,i.jsx)(e.p,{children:"比如：创建一个 docs-vite 用于文档化建设。在做文档化时需要引用 smarty-ui-vite 这个库，用于在网页上直接展示组件运行效果。"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"初始化项目"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# 12.建立组件库生态： 利用 Monorepo 方式管理组件库生态\nmkdir docs-vite\npnpm init \n"})}),"\n",(0,i.jsxs)(e.ol,{start:"2",children:["\n",(0,i.jsx)(e.li,{children:"安装 Vite"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"这个时候就可以做一个选择了，假设我们认为 Vite 多个软件包都需要依赖，这个时候就可以选择将依赖安装到 workspace 中，这样每个包都可以使用 vite 而无需单独安装。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# 安装 workspace 中\npnpm i vite -w\n"})}),"\n",(0,i.jsx)(e.p,{children:"如果只安装在子 package 里面，可以使用 -r ，比如："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# 子package安装\npnpm i vue -r --filter smarty-ui-vite\n\n# 或者 直接在 docs-vite 目录下\npnpm i vue\n"})}),"\n",(0,i.jsx)(e.p,{children:"下面需要做的是将 smarty-ui-vite 安装到 docs-vite 中。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"# 内部依赖package安装\npnpm i  smarty-ui-vite -r --filter docs-vite\n"})}),"\n",(0,i.jsx)(e.p,{children:"在安装后， docs-vite 中 smarty-ui-vite 的位置会指向到 workspace ，这也是 monorepo 的精髓所在。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:s,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"编辑一个页面测试一下, 直接加载 node_module 中的 smarty-ui-vite 的 module 和 css。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n\n<body>\n\n    <h1>\uD83D\uDD28 SmartyUI Demo</h1>\n    <div id="app"></div>\n    <script type="module">\n        import style from "smarty-ui-vite/dist/style.css"\n        import { createApp } from "vue/dist/vue.esm-bundler.js";\n        import SmartyUI, { SFCButton, JSXButton, SButton } from "smarty-ui-vite/dist/smarty-ui.es.js";\n\n        createApp({\n            template: `\n        <div style="margin-bottom:20px;">\n            <SButton color="blue">主要按钮</SButton>\n            <SButton color="green">绿色按钮</SButton>\n            <SButton color="gray">灰色按钮</SButton>\n            <SButton color="yellow">黄色按钮</SButton>\n            <SButton color="red">红色按钮</SButton>\n        </div>\n        <div style="margin-bottom:20px;"\n        >\n            <SButton color="blue" plain>朴素按钮</SButton>\n            <SButton color="green" plain>绿色按钮</SButton>\n            <SButton color="gray" plain>灰色按钮</SButton>\n            <SButton color="yellow" plain>黄色按钮</SButton>\n            <SButton color="red" plain>红色按钮</SButton>\n        </div>\n        <div style="margin-bottom:20px;">\n            <SButton size="small" plain>小按钮</SButton>\n            <SButton size="medium" plain>中按钮</SButton>\n            <SButton size="large" plain>大按钮</SButton>\n        </div>\n        <div style="margin-bottom:20px;">\n            <SButton color="blue" round plain icon="search">搜索按钮</SButton>\n            <SButton color="green" round plain icon="edit">编辑按钮</SButton>\n            <SButton color="gray" round plain icon="check">成功按钮</SButton>\n            <SButton color="yellow" round plain icon="message">提示按钮</SButton>\n            <SButton color="red" round plain icon="delete">删除按钮</SButton>\n        </div>\n        <div style="margin-bottom:20px;">\n            <SButton color="blue" round plain icon="search"></SButton>\n            <SButton color="green" round plain icon="edit"></SButton>\n            <SButton color="gray" round plain icon="check"></SButton>\n            <SButton color="yellow" round plain icon="message"></SButton>\n            <SButton color="red" round plain icon="delete"></SButton>\n        </div>\n    `}).use(SmartyUI).mount(\'#app\')\n\n    <\/script>\n</body>\n\n</html>\n'})}),"\n",(0,i.jsx)(e.p,{children:"运行 dev 测试一下。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"pnpm dev\n"})}),"\n",(0,i.jsx)(e.p,{children:"测试一下效果。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsxs)(e.h2,{id:"复盘",children:["复盘",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#复盘",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"这节课的主要内容是利用Monorepo方式管理组件库生态。组件库的周边可以包括 cli 工具、admin、插件等内容，使用 monorepo 风格非常符合这样的应用场景。"}),"\n",(0,i.jsx)(e.p,{children:"最后留一些思考题帮助大家复习，也欢迎在留言区讨论。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"monorepo是什么"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"monorepo的应用场景和优点是什么 ？"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"如何使用 pnpm workspace 实现 monorepo 风格的项目 ？"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"下节课，我们将给大家讲解如何用对组件库实现按需加载，下节课见。"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,o.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}let p=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Vite%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E6%88%98%2F12.%E5%BB%BA%E7%AB%8B%E7%BB%84%E4%BB%B6%E5%BA%93%E7%94%9F%E6%80%81%EF%BC%9A%20%E5%88%A9%E7%94%A8%20Monorepo%20%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86%E7%BB%84%E4%BB%B6%E5%BA%93%E7%94%9F%E6%80%81.md"]={toc:[{text:"传统 Mutirepo 方式的不足",id:"传统-mutirepo-方式的不足",depth:2},{text:"Monorepo 的优势",id:"monorepo-的优势",depth:2},{text:"用户故事(UserStory)",id:"用户故事userstory",depth:2},{text:"任务分解(Task)",id:"任务分解task",depth:2},{text:"方案选型",id:"方案选型",depth:3},{text:"修改软件包目录结构",id:"修改软件包目录结构",depth:3},{text:"初始化Monorepo软件包",id:"初始化monorepo软件包",depth:3},{text:"初始化工作空间",id:"初始化工作空间",depth:3},{text:"创建一个新的软件包",id:"创建一个新的软件包",depth:3},{text:"复盘",id:"复盘",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);