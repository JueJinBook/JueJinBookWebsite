"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["51378"],{338135:function(e,n,r){r.r(n),r.d(n,{default:()=>i});var s=r(552676),l=r(740453);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",ul:"ul",li:"li"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"4字符串的扩展",children:["4.字符串的扩展",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4字符串的扩展",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章介绍 ES6 对字符串的改造和增强，下一章介绍字符串对象的新增方法。"}),"\n",(0,s.jsxs)(n.h2,{id:"字符的-unicode-表示法",children:["字符的 Unicode 表示法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#字符的-unicode-表示法",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["ES6 加强了对 Unicode 的支持，允许采用",(0,s.jsx)(n.code,{children:"\\uxxxx"}),"形式表示一个字符，其中",(0,s.jsx)(n.code,{children:"xxxx"}),"表示字符的 Unicode 码点。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'"\\u0061"\n// "a"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["但是，这种表示法只限于码点在",(0,s.jsx)(n.code,{children:"\\u0000"}),"~",(0,s.jsx)(n.code,{children:"\\uFFFF"}),"之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'"\uD842\uDFB7"\n// "\uD842\uDFB7"\n\n"\\u20BB7"\n// " 7"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码表示，如果直接在",(0,s.jsx)(n.code,{children:"\\u"}),"后面跟上超过",(0,s.jsx)(n.code,{children:"0xFFFF"}),"的数值（比如",(0,s.jsx)(n.code,{children:"\\u20BB7"}),"），JavaScript 会理解成",(0,s.jsx)(n.code,{children:"\\u20BB+7"}),"。由于",(0,s.jsx)(n.code,{children:"\\u20BB"}),"是一个不可打印字符，所以只会显示一个空格，后面跟着一个",(0,s.jsx)(n.code,{children:"7"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'"\\u{20BB7}"\n// "\uD842\uDFB7"\n\n"\\u{41}\\u{42}\\u{43}"\n// "ABC"\n\nlet hello = 123;\nhell\\u{6F} // 123\n\n\'\\u{1F680}\' === \'\uD83D\uDE80\'\n// true\n'})}),"\n",(0,s.jsx)(n.p,{children:"上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。"}),"\n",(0,s.jsx)(n.p,{children:"有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'\\z' === 'z'  // true\n'\\172' === 'z' // true\n'\\x7A' === 'z' // true\n'\\u007A' === 'z' // true\n'\\u{7A}' === 'z' // true\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"字符串的遍历器接口",children:["字符串的遍历器接口",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#字符串的遍历器接口",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被",(0,s.jsx)(n.code,{children:"for...of"}),"循环遍历。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'for (let codePoint of \'foo\') {\n  console.log(codePoint)\n}\n// "f"\n// "o"\n// "o"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["除了遍历字符串，这个遍历器最大的优点是可以识别大于",(0,s.jsx)(n.code,{children:"0xFFFF"}),"的码点，传统的",(0,s.jsx)(n.code,{children:"for"}),"循环无法识别这样的码点。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let text = String.fromCodePoint(0x20BB7);\n\nfor (let i = 0; i < text.length; i++) {\n  console.log(text[i]);\n}\n// " "\n// " "\n\nfor (let i of text) {\n  console.log(i);\n}\n// "\uD842\uDFB7"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，字符串",(0,s.jsx)(n.code,{children:"text"}),"只有一个字符，但是",(0,s.jsx)(n.code,{children:"for"}),"循环会认为它包含两个字符（都不可打印），而",(0,s.jsx)(n.code,{children:"for...of"}),"循环会正确识别出这一个字符。"]}),"\n",(0,s.jsxs)(n.h2,{id:"直接输入-u2028-和-u2029",children:["直接输入 U+2028 和 U+2029",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#直接输入-u2028-和-u2029",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式",(0,s.jsx)(n.code,{children:"\\u4e2d"}),"，两者是等价的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"'中' === '\\u4e2d' // true\n"})}),"\n",(0,s.jsx)(n.p,{children:"但是，JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"U+005C：反斜杠（reverse solidus)"}),"\n",(0,s.jsx)(n.li,{children:"U+000D：回车（carriage return）"}),"\n",(0,s.jsx)(n.li,{children:"U+2028：行分隔符（line separator）"}),"\n",(0,s.jsx)(n.li,{children:"U+2029：段分隔符（paragraph separator）"}),"\n",(0,s.jsx)(n.li,{children:"U+000A：换行符（line feed）"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["举例来说，字符串里面不能直接包含反斜杠，一定要转义写成",(0,s.jsx)(n.code,{children:"\\\\"}),"或者",(0,s.jsx)(n.code,{children:"\\u005c"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["这个规定本身没有问题，麻烦在于 JSON 格式允许字符串里面直接使用 U+2028（行分隔符）和 U+2029（段分隔符）。这样一来，服务器输出的 JSON 被",(0,s.jsx)(n.code,{children:"JSON.parse"}),"解析，就有可能直接报错。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const json = '\"\\u2028\"';\nJSON.parse(json); // 可能报错\n"})}),"\n",(0,s.jsxs)(n.p,{children:["JSON 格式已经冻结（RFC 7159），没法修改了。为了消除这个报错，",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-json-superset",target:"_blank",rel:"noopener noreferrer",children:"ES2019"})," 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符）。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const PS = eval(\"'\\u2029'\");\n"})}),"\n",(0,s.jsx)(n.p,{children:"根据这个提案，上面的代码不会报错。"}),"\n",(0,s.jsx)(n.p,{children:"注意，模板字符串现在就允许直接输入这两个字符。另外，正则表达式依然不允许直接输入这两个字符，这是没有问题的，因为 JSON 本来就不允许直接包含正则表达式。"}),"\n",(0,s.jsxs)(n.h2,{id:"jsonstringify-的改造",children:["JSON.stringify() 的改造",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#jsonstringify-的改造",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的",(0,s.jsx)(n.code,{children:"JSON.stringify()"}),"方法有可能返回不符合 UTF-8 标准的字符串。"]}),"\n",(0,s.jsxs)(n.p,{children:["具体来说，UTF-8 标准规定，",(0,s.jsx)(n.code,{children:"0xD800"}),"到",(0,s.jsx)(n.code,{children:"0xDFFF"}),"之间的码点，不能单独使用，必须配对使用。比如，",(0,s.jsx)(n.code,{children:"\uD834\uDF06"}),"是两个码点，但是必须放在一起配对使用，代表字符",(0,s.jsx)(n.code,{children:"\uD834\uDF06"}),"。这是为了表示码点大于",(0,s.jsx)(n.code,{children:"0xFFFF"}),"的字符的一种变通方法。单独使用",(0,s.jsx)(n.code,{children:"\uD834"}),"和",(0,s.jsx)(n.code,{children:"\uDF06"}),"这两个码点是不合法的，或者颠倒顺序也不行，因为",(0,s.jsx)(n.code,{children:"\uDF06\uD834"}),"并没有对应的字符。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"JSON.stringify()"}),"的问题在于，它可能返回",(0,s.jsx)(n.code,{children:"0xD800"}),"到",(0,s.jsx)(n.code,{children:"0xDFFF"}),"之间的单个码点。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"JSON.stringify('\u{D834}') // \"\u{D834}\"\n"})}),"\n",(0,s.jsxs)(n.p,{children:["为了确保返回的是合法的 UTF-8 字符，",(0,s.jsx)(n.a,{href:"https://github.com/tc39/proposal-well-formed-stringify",target:"_blank",rel:"noopener noreferrer",children:"ES2019"})," 改变了",(0,s.jsx)(n.code,{children:"JSON.stringify()"}),"的行为。如果遇到",(0,s.jsx)(n.code,{children:"0xD800"}),"到",(0,s.jsx)(n.code,{children:"0xDFFF"}),"之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'JSON.stringify(\'\u{D834}\') // ""\\\uD834""\nJSON.stringify(\'\uDF06\uD834\') // ""\\\udf06\\\ud834""\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"模板字符串",children:["模板字符串",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模板字符串",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"$('#result').append(\n  'There are <b>' + basket.count + '</b> ' +\n  'items in your basket, ' +\n  '<em>' + basket.onSale +\n  '</em> are on sale!'\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"$('#result').append(`\n  There are <b>${basket.count}</b> items\n   in your basket, <em>${basket.onSale}</em>\n  are on sale!\n`);\n"})}),"\n",(0,s.jsx)(n.p,{children:"模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// 普通字符串\n`In JavaScript \'\\n\' is a line-feed.`\n\n// 多行字符串\n`In JavaScript this is\n not legal.`\n\nconsole.log(`string text line 1\nstring text line 2`);\n\n// 字符串中嵌入变量\nlet name = "Bob", time = "today";\n`Hello ${name}, how are you ${time}?`\n'})}),"\n",(0,s.jsx)(n.p,{children:"上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let greeting = `\\`Yo\\` World!`;\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，所有模板字符串的空格和换行，都是被保留的，比如",(0,s.jsx)(n.code,{children:"<ul>"}),"标签前面会有一个换行。如果你不想要这个换行，可以使用",(0,s.jsx)(n.code,{children:"trim"}),"方法消除它。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`.trim());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["模板字符串中嵌入变量，需要将变量名写在",(0,s.jsx)(n.code,{children:"${}"}),"之中。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function authorize(user, action) {\n  if (!user.hasPrivilege(action)) {\n    throw new Error(\n      // 传统写法为\n      // 'User '\n      // + user.name\n      // + ' is not authorized to do '\n      // + action\n      // + '.'\n      `User ${user.name} is not authorized to do ${action}.`);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let x = 1;\nlet y = 2;\n\n`${x} + ${y} = ${x + y}`\n// "1 + 2 = 3"\n\n`${x} + ${y * 2} = ${x + y * 2}`\n// "1 + 4 = 5"\n\nlet obj = {x: 1, y: 2};\n`${obj.x + obj.y}`\n// "3"\n'})}),"\n",(0,s.jsx)(n.p,{children:"模板字符串之中还能调用函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function fn() {\n  return "Hello World";\n}\n\n`foo ${fn()} bar`\n// foo Hello World bar\n'})}),"\n",(0,s.jsxs)(n.p,{children:["如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的",(0,s.jsx)(n.code,{children:"toString"}),"方法。"]}),"\n",(0,s.jsx)(n.p,{children:"如果模板字符串中的变量没有声明，将报错。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 变量place没有声明\nlet msg = `Hello, ${place}`;\n// 报错\n"})}),"\n",(0,s.jsx)(n.p,{children:"由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"`Hello ${'World'}`\n// \"Hello World\"\n"})}),"\n",(0,s.jsx)(n.p,{children:"模板字符串甚至还能嵌套。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const data = [\n    { first: '<Jane>', last: 'Bond' },\n    { first: 'Lars', last: '<Croft>' },\n];\n\nconsole.log(tmpl(data));\n// <table>\n//\n//   <tr><td><Jane></td></tr>\n//   <tr><td>Bond</td></tr>\n//\n//   <tr><td>Lars</td></tr>\n//   <tr><td><Croft></td></tr>\n//\n// </table>\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果需要引用模板字符串本身，在需要时执行，可以写成函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let func = (name) => `Hello ${name}!`;\nfunc('Jack') // \"Hello Jack!\"\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面代码中，模板字符串写成了一个函数的返回值。执行这个函数，就相当于执行这个模板字符串了。"}),"\n",(0,s.jsxs)(n.h2,{id:"实例模板编译",children:["实例：模板编译",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例模板编译",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"下面，我们来看一个通过模板字符串，生成正式模板的实例。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let template = `\n<ul>\n  <% for(let i=0; i < data.supplies.length; i++) { %>\n    <li><%= data.supplies[i] %></li>\n  <% } %>\n</ul>\n`;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码在模板字符串之中，放置了一个常规模板。该模板使用",(0,s.jsx)(n.code,{children:"<%...%>"}),"放置 JavaScript 代码，使用",(0,s.jsx)(n.code,{children:"<%= ... %>"}),"输出 JavaScript 表达式。"]}),"\n",(0,s.jsx)(n.p,{children:"怎么编译这个模板字符串呢？"}),"\n",(0,s.jsx)(n.p,{children:"一种思路是将其转换为 JavaScript 表达式字符串。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"echo('<ul>');\nfor(let i=0; i < data.supplies.length; i++) {\n  echo('<li>');\n  echo(data.supplies[i]);\n  echo('</li>');\n};\necho('</ul>');\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个转换使用正则表达式就行了。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let evalExpr = /<%=(.+?)%>/g;\nlet expr = /<%([\\s\\S]+?)%>/g;\n\ntemplate = template\n  .replace(evalExpr, '`); \\n  echo( $1 ); \\n  echo(`')\n  .replace(expr, '`); \\n $1 \\n  echo(`');\n\ntemplate = 'echo(`' + template + '`);';\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后，将",(0,s.jsx)(n.code,{children:"template"}),"封装在一个函数里面返回，就可以了。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let script =\n`(function parse(data){\n  let output = "";\n\n  function echo(html){\n    output += html;\n  }\n\n  ${ template }\n\n  return output;\n})`;\n\nreturn script;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["将上面的内容拼装成一个模板编译函数",(0,s.jsx)(n.code,{children:"compile"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function compile(template){\n  const evalExpr = /<%=(.+?)%>/g;\n  const expr = /<%([\\s\\S]+?)%>/g;\n\n  template = template\n    .replace(evalExpr, '`); \\n  echo( $1 ); \\n  echo(`')\n    .replace(expr, '`); \\n $1 \\n  echo(`');\n\n  template = 'echo(`' + template + '`);';\n\n  let script =\n  `(function parse(data){\n    let output = \"\";\n\n    function echo(html){\n      output += html;\n    }\n\n    ${ template }\n\n    return output;\n  })`;\n\n  return script;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"compile"}),"函数的用法如下。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let parse = eval(compile(template));\ndiv.innerHTML = parse({ supplies: [ "broom", "mop", "cleaner" ] });\n//   <ul>\n//     <li>broom</li>\n//     <li>mop</li>\n//     <li>cleaner</li>\n//   </ul>\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"标签模板",children:["标签模板",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#标签模板",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"alert`hello`\n// 等同于\nalert(['hello'])\n"})}),"\n",(0,s.jsx)(n.p,{children:"标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。"}),"\n",(0,s.jsx)(n.p,{children:"但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let a = 5;\nlet b = 10;\n\ntag`Hello ${ a + b } world ${ a * b }`;\n// 等同于\ntag(['Hello ', ' world ', ''], 15, 50);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，模板字符串前面有一个标识名",(0,s.jsx)(n.code,{children:"tag"}),"，它是一个函数。整个表达式的返回值，就是",(0,s.jsx)(n.code,{children:"tag"}),"函数处理模板字符串后的返回值。"]}),"\n",(0,s.jsxs)(n.p,{children:["函数",(0,s.jsx)(n.code,{children:"tag"}),"依次会接收到多个参数。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function tag(stringArr, value1, value2){\n  // ...\n}\n\n// 等同于\n\nfunction tag(stringArr, ...values){\n  // ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tag"}),"函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tag"}),"函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此",(0,s.jsx)(n.code,{children:"tag"}),"会接受到",(0,s.jsx)(n.code,{children:"value1"}),"和",(0,s.jsx)(n.code,{children:"value2"}),"两个参数。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tag"}),"函数所有参数的实际值如下。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第一个参数：",(0,s.jsx)(n.code,{children:"['Hello ', ' world ', '']"})]}),"\n",(0,s.jsx)(n.li,{children:"第二个参数: 15"}),"\n",(0,s.jsx)(n.li,{children:"第三个参数：50"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，",(0,s.jsx)(n.code,{children:"tag"}),"函数实际上以下面的形式调用。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"tag(['Hello ', ' world ', ''], 15, 50)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们可以按照需要编写",(0,s.jsx)(n.code,{children:"tag"}),"函数的代码。下面是",(0,s.jsx)(n.code,{children:"tag"}),"函数的一种写法，以及运行结果。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let a = 5;\nlet b = 10;\n\nfunction tag(s, v1, v2) {\n  console.log(s[0]);\n  console.log(s[1]);\n  console.log(s[2]);\n  console.log(v1);\n  console.log(v2);\n\n  return "OK";\n}\n\ntag`Hello ${ a + b } world ${ a * b}`;\n// "Hello "\n// " world "\n// ""\n// 15\n// 50\n// "OK"\n'})}),"\n",(0,s.jsx)(n.p,{children:"下面是一个更复杂的例子。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let total = 30;\nlet msg = passthru`The total is ${total} (${total*1.05} with tax)`;\n\nfunction passthru(literals) {\n  let result = '';\n  let i = 0;\n\n  while (i < literals.length) {\n    result += literals[i++];\n    if (i < arguments.length) {\n      result += arguments[i];\n    }\n  }\n\n  return result;\n}\n\nmsg // \"The total is 30 (31.5 with tax)\"\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"passthru"}),"函数采用 rest 参数的写法如下。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function passthru(literals, ...values) {\n  let output = "";\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += literals[index] + values[index];\n  }\n\n  output += literals[index]\n  return output;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let message =\n  SaferHTML`<p>${sender} has sent you a message.</p>`;\n\nfunction SaferHTML(templateData) {\n  let s = templateData[0];\n  for (let i = 1; i < arguments.length; i++) {\n    let arg = String(arguments[i]);\n\n    // Escape special characters in the substitution.\n    s += arg.replace(/&/g, "&amp;")\n            .replace(/</g, "&lt;")\n            .replace(/>/g, "&gt;");\n\n    // Don\'t escape special characters in the template.\n    s += templateData[i];\n  }\n  return s;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"sender"}),"变量往往是用户提供的，经过",(0,s.jsx)(n.code,{children:"SaferHTML"}),"函数处理，里面的特殊字符都会被转义。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'let sender = \'<script>alert("abc")<\/script>\'; // 恶意代码\nlet message = SaferHTML`<p>${sender} has sent you a message.</p>`;\n\nmessage\n// <p>&lt;script&gt;alert("abc")&lt;/script&gt; has sent you a message.</p>\n'})}),"\n",(0,s.jsx)(n.p,{children:"标签模板的另一个应用，就是多语言转换（国际化处理）。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`\n// "欢迎访问xxx，您是第xxxx位访问者！"\n'})}),"\n",(0,s.jsx)(n.p,{children:"模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 下面的hashTemplate函数\n// 是一个自定义的模板处理函数\nlet libraryHtml = hashTemplate`\n  <ul>\n    #for book in ${myBooks}\n      <li><i>#{book.title}</i> by #{book.author}</li>\n    #end\n  </ul>\n`;\n"})}),"\n",(0,s.jsx)(n.p,{children:"除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"jsx`\n  <div>\n    <input\n      ref='input'\n      onChange='${this.handleChange}'\n      defaultValue='${this.state.value}' />\n      ${this.state.value}\n   </div>\n`\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面的代码通过",(0,s.jsx)(n.code,{children:"jsx"}),"函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到",(0,s.jsx)(n.code,{children:"jsx"}),"函数的",(0,s.jsx)(n.a,{href:"https://gist.github.com/lygaret/a68220defa69174bdec5",target:"_blank",rel:"noopener noreferrer",children:"具体实现"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["下面则是一个假想的例子，通过",(0,s.jsx)(n.code,{children:"java"}),"函数，在 JavaScript 代码之中运行 Java 代码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'java`\nclass HelloWorldApp {\n  public static void main(String[] args) {\n    System.out.println("Hello World!"); // Display the string.\n  }\n}\n`\nHelloWorldApp.main();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["模板处理函数的第一个参数（模板字符串数组），还有一个",(0,s.jsx)(n.code,{children:"raw"}),"属性。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'console.log`123`\n// ["123", raw: Array[1]]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"console.log"}),"接受的参数，实际上是一个数组。该数组有一个",(0,s.jsx)(n.code,{children:"raw"}),"属性，保存的是转义后的原字符串。"]}),"\n",(0,s.jsx)(n.p,{children:"请看下面的例子。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'tag`First line\\nSecond line`\n\nfunction tag(strings) {\n  console.log(strings.raw[0]);\n  // strings.raw[0] 为 "First line\\\\nSecond line"\n  // 打印输出 "First line\\nSecond line"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，",(0,s.jsx)(n.code,{children:"tag"}),"函数的第一个参数",(0,s.jsx)(n.code,{children:"strings"}),"，有一个",(0,s.jsx)(n.code,{children:"raw"}),"属性，也指向一个数组。该数组的成员与",(0,s.jsx)(n.code,{children:"strings"}),"数组完全一致。比如，",(0,s.jsx)(n.code,{children:"strings"}),"数组是",(0,s.jsx)(n.code,{children:'["First line\\nSecond line"]'}),"，那么",(0,s.jsx)(n.code,{children:"strings.raw"}),"数组就是",(0,s.jsx)(n.code,{children:'["First line\\\\nSecond line"]'}),"。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将",(0,s.jsx)(n.code,{children:"\\n"}),"视为",(0,s.jsx)(n.code,{children:"\\\\"}),"和",(0,s.jsx)(n.code,{children:"n"}),"两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。"]}),"\n",(0,s.jsxs)(n.h2,{id:"模板字符串的限制",children:["模板字符串的限制",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模板字符串的限制",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。"}),"\n",(0,s.jsx)(n.p,{children:"举例来说，标签模板里面可以嵌入 LaTEX 语言。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function latex(strings) {\n  // ...\n}\n\nlet document = latex`\n\\newcommand{\\fun}{\\textbf{Fun!}}  // 正常工作\n\\newcommand{\\unicode}{\\textbf{Unicode!}} // 报错\n\\newcommand{\\xerxes}{\\textbf{King!}} // 报错\n\nBreve over the h goes \\u{h}ere // 报错\n`\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，变量",(0,s.jsx)(n.code,{children:"document"}),"内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。"]}),"\n",(0,s.jsxs)(n.p,{children:["模板字符串会将",(0,s.jsx)(n.code,{children:"\\u00FF"}),"和",(0,s.jsx)(n.code,{children:"\\u{42}"}),"当作 Unicode 字符进行转义，所以",(0,s.jsx)(n.code,{children:"\\unicode"}),"解析时报错；而",(0,s.jsx)(n.code,{children:"\\x56"}),"会被当作十六进制字符串转义，所以",(0,s.jsx)(n.code,{children:"\\xerxes"}),"会报错。也就是说，",(0,s.jsx)(n.code,{children:"\\u"}),"和",(0,s.jsx)(n.code,{children:"\\x"}),"在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了解决这个问题，ES2018 ",(0,s.jsx)(n.a,{href:"https://tc39.github.io/proposal-template-literal-revision/",target:"_blank",rel:"noopener noreferrer",children:"放松"}),"了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回",(0,s.jsx)(n.code,{children:"undefined"}),"，而不是报错，并且从",(0,s.jsx)(n.code,{children:"raw"}),"属性上面可以得到原始字符串。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'function tag(strs) {\n  strs[0] === undefined\n  strs.raw[0] === "\\\\unicode and \\\\u{55}";\n}\ntag`\\unicode and \\u{55}`\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为",(0,s.jsx)(n.code,{children:"undefined"}),"，但是",(0,s.jsx)(n.code,{children:"raw"}),"属性依然可以得到原始字符串，因此",(0,s.jsx)(n.code,{children:"tag"}),"函数还是可以对原字符串进行处理。"]}),"\n",(0,s.jsx)(n.p,{children:"注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let bad = `bad escape sequence: \\unicode`; // 报错\n"})})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let i=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95.md"]={toc:[{text:"字符的 Unicode 表示法",id:"字符的-unicode-表示法",depth:2},{text:"字符串的遍历器接口",id:"字符串的遍历器接口",depth:2},{text:"直接输入 U+2028 和 U+2029",id:"直接输入-u2028-和-u2029",depth:2},{text:"JSON.stringify() 的改造",id:"jsonstringify-的改造",depth:2},{text:"模板字符串",id:"模板字符串",depth:2},{text:"实例：模板编译",id:"实例模板编译",depth:2},{text:"标签模板",id:"标签模板",depth:2},{text:"模板字符串的限制",id:"模板字符串的限制",depth:2}],title:"4.字符串的扩展",headingTitle:"4.字符串的扩展",frontmatter:{}}}}]);