"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["64265"],{781619:function(n,e,s){s.r(e),s.d(e,{default:()=>b});var c=s(552676),r=s(740453);let i=s.p+"static/image/c106f485b0a544ab964d61569b1aada6.29c2cd2a.webp",d=s.p+"static/image/e78a13f2166d39bfeb4def6c53675239.e632f98f.webp",h=s.p+"static/image/3722a7a92466cf249b95b67cce644ea3.edb19b0d.webp",l=s.p+"static/image/f499172a5679bba779ba74c5143033a3.4505eae9.webp",t=s.p+"static/image/48d32a17d3b414fc91e975633696b160.e4dcac68.webp",a=s.p+"static/image/232ee5f449cde6bfa53cb940c19d4f41.a21a9634.webp",x=s.p+"static/image/873a3d29b36aab98d771f83f1b381b58.b7054039.webp",j=s.p+"static/image/9fb8843dad255773b30ec0f2516a719a.ab688b1d.webp",u=s.p+"static/image/8b686832a99195912ff8bf5c6d5fce4e.04fa8e04.webp",o=s.p+"static/image/a885825318ee03ac71aa1c5a7c08c82f.b92ad831.webp";function p(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",h2:"h2",strong:"strong",blockquote:"blockquote",br:"br",ul:"ul",h3:"h3",img:"img",code:"code",pre:"pre"},(0,r.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"13栈与队列怎么玩下",children:["13.栈与队列怎么玩（下）",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13栈与队列怎么玩下",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"结束了针对栈结构的定点轰炸，我们现在开始要缓缓过渡到队列的世界了。"}),"\n",(0,c.jsx)(e.p,{children:"关于队列，在算法面试中大家需要掌握以下重点："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsx)(e.li,{children:"栈向队列的转化"}),"\n",(0,c.jsx)(e.li,{children:"双端队列"}),"\n",(0,c.jsx)(e.li,{children:"优先队列"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"以上考点中，1 属于基础难度， 2 对一部分同学来说已经有点吃力，3 的区分度最高——优先队列属于高级数据结构，其本质是二叉堆结构，考虑到相关题目具有较强的综合性，我们把它放在小册二叉树和堆相关的专题来展开。在本节，我们集中火力向前两个命题点开炮。"}),"\n",(0,c.jsxs)(e.h2,{id:"为什么一道题可以成为高频面试题",children:["为什么一道题可以成为高频面试题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么一道题可以成为高频面试题",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"如何用栈实现队列？这个问题在近几年的算法面试中热度非常高。"}),"\n",(0,c.jsxs)(e.p,{children:["所谓“热度”从何而来？这里就引出了一个非常有趣的话题：（在前端算法面试中）",(0,c.jsx)(e.strong,{children:"什么样的题目是好题"}),"？"]}),"\n",(0,c.jsx)(e.p,{children:"首先，不能剑走偏锋：好的面试题，它考察的大多是算法/数据结构中最经典、最关键的一部分内容，这样才能体现公平；其次，它的知识点要尽可能密集、题目本身要尽可能具备综合性，这样才能一箭双雕甚至一箭N雕，进而体现区分度、最大化面试过程的效率。"}),"\n",(0,c.jsxs)(e.p,{children:["能够同时在这两个方面占尽优势的考题其实并不是很多，“",(0,c.jsx)(e.strong,{children:"用栈实现队列"}),"”这样的问题算是其中的佼佼者：一方面，它考察的确实是数据结构中的经典内容；另一方面，它又覆盖了两个大的知识点、足以检验出候选人编码基本功的扎实程度。唯一的 BUG 可能就是深度和复杂度不够，换句话说就是不够难。"]}),"\n",(0,c.jsx)(e.p,{children:"这个特点，在普通算法面试中可能是 BUG，但在前端算法面试中，实在未必。大家要知道，你是前端，你的面试官也是前端，前端行业普遍的算法水平是啥样他心里还没个数吗...... 实际上大多数前端算法面试题的风格都是非常务实的，需要你炫技的实属特殊情况。"}),"\n",(0,c.jsxs)(e.h2,{id:"如何用栈实现一个队列",children:["如何用栈实现一个队列？",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#如何用栈实现一个队列",children:"#"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["题目描述：使用栈实现队列的下列操作：",(0,c.jsx)(e.br,{}),"\n","push(x) -- 将一个元素放入队列的尾部。",(0,c.jsx)(e.br,{}),"\n","pop() -- 从队列首部移除元素。",(0,c.jsx)(e.br,{}),"\n","peek() -- 返回队列首部的元素。",(0,c.jsx)(e.br,{}),"\n","empty() -- 返回队列是否为空。"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["示例:\nMyQueue queue = new MyQueue();",(0,c.jsx)(e.br,{}),"\n","queue.push(1);",(0,c.jsx)(e.br,{}),"\n","queue.push(2);",(0,c.jsx)(e.br,{}),"\n","queue.peek();  // 返回 1",(0,c.jsx)(e.br,{}),"\n","queue.pop();   // 返回 1",(0,c.jsx)(e.br,{}),"\n","queue.empty(); // 返回 false"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"说明:"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"你只能使用标准的栈操作 -- 也就是只有\xa0push to top,\xa0peek/pop from top,\xa0size, 和\xa0is empty\xa0操作是合法的。"}),"\n",(0,c.jsx)(e.li,{children:"你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。"}),"\n",(0,c.jsx)(e.li,{children:"假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"思路分析",children:["思路分析",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["做这道题大家首先要在心里清楚一个事情：栈和队列的区别在哪里？",(0,c.jsx)(e.br,{}),"\n","仔细想想，栈，后进先出；队列，先进先出。也就是说两者的进出顺序其实是反过来的。用栈实现队列，说白了就是用栈实现先进先出的效果，再说直接点，就是想办法",(0,c.jsx)(e.strong,{children:"让栈底的元素首先被取出"}),"，也就是让出栈序列被",(0,c.jsx)(e.strong,{children:"逆序"}),"。",(0,c.jsx)(e.br,{}),"\n","乍一看有点头大：栈结构决定了栈底元素只能被死死地压在最底下，如何使它首先被取出呢？",(0,c.jsx)(e.br,{}),"\n","一个栈做不到的事情，我们用两个栈来做："]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"首先，准备两个栈："}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"现在问题是，怎么把第一个栈底下的那个 1 给撬出来。仔细想想，阻碍我们接触到 1 的是啥？是不是它头上的 3 和 2？那么如何让 3 和 2 给 1 让路呢？实际上咱们完全可以把这三个元素按顺序从 stack1 中出栈、然后入栈到 stack 2 里去："}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"此时 1 变得触手可及。不仅如此，下一次我们试图出队 2 的时候，可以继续直接对 stack2 执行出栈操作——因为转移 2 和 3 的时候已经做过一次逆序了，此时 stack2 的出栈序列刚好就对应队列的出队序列。"}),"\n",(0,c.jsxs)(e.li,{children:["有同学会问，那如果 stack1 里入栈新元素怎么办？比如这样：",(0,c.jsx)(e.br,{}),"\n",(0,c.jsx)("img",{src:j,alt:""})]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["你会发现这个4按照顺序应该在 1、2、3 后出栈。当 4 需要被出栈时，",(0,c.jsx)(e.code,{children:"stack2"})," 一定已经空掉了。当 ",(0,c.jsx)(e.code,{children:"stack2"})," 为空、而 ",(0,c.jsx)(e.code,{children:"stack1"})," 不为空时，我们需要继续把 ",(0,c.jsx)(e.code,{children:"stack1"})," 中的元素转移到 ",(0,c.jsx)(e.code,{children:"stack2"})," 中去，然后再从 ",(0,c.jsx)(e.code,{children:"stack2"})," 里取元素。也就是说，所有的出队操作都只能依赖 ",(0,c.jsx)(e.code,{children:"stack2"})," 来完成——只要我们坚持这个原则，就可以确保 ",(0,c.jsx)(e.code,{children:"stack1"})," 里的元素都能够按照正确的顺序（逆序）出栈。"]}),"\n",(0,c.jsx)(e.p,{children:"我们按照这个思路来写代码："}),"\n",(0,c.jsxs)(e.h3,{id:"编码实现",children:["编码实现",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"/**\n * 初始化构造函数\n */\nconst MyQueue = function () {\n  // 初始化两个栈\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/**\n* Push element x to the back of queue.\n* @param {number} x\n* @return {void}\n*/\nMyQueue.prototype.push = function (x) {\n  // 直接调度数组的 push 方法\n  this.stack1.push(x);\n};\n\n/**\n* Removes the element from in front of queue and returns that element.\n* @return {number}\n*/\nMyQueue.prototype.pop = function () {\n  // 假如 stack2 为空，需要将 stack1 的元素转移进来\n  if (this.stack2.length <= 0) {\n    // 当 stack1 不为空时，出栈\n    while (this.stack1.length !== 0) {\n      // 将 stack1 出栈的元素推入 stack2\n      this.stack2.push(this.stack1.pop());\n    }\n  }\n  // 为了达到逆序的目的，我们只从 stack2 里出栈元素\n  return this.stack2.pop();\n};\n\n/**\n* Get the front element.\n* @return {number}\n* 这个方法和 pop 唯一的区别就是没有将定位到的值出栈\n*/\nMyQueue.prototype.peek = function () {\n  if (this.stack2.length <= 0) {\n    // 当 stack1 不为空时，出栈\n    while (this.stack1.length != 0) {\n      // 将 stack1 出栈的元素推入 stack2\n      this.stack2.push(this.stack1.pop());\n    }\n  }\n  // 缓存 stack2 的长度\n  const stack2Len = this.stack2.length;\n  return stack2Len && this.stack2[stack2Len - 1];\n};\n\n/**\n* Returns whether the queue is empty.\n* @return {boolean}\n*/\nMyQueue.prototype.empty = function () {\n  // 若 stack1 和 stack2 均为空，那么队列空\n  return !this.stack1.length && !this.stack2.length;\n};\n"})}),"\n",(0,c.jsxs)(e.h2,{id:"认识双端队列",children:["认识双端队列",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#认识双端队列",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"双端队列衍生出的滑动窗口问题，是一个经久不衰的命题热点。关于双端队列，各种各样的解释五花八门，这里大家不要纠结，就记住一句话："}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"双端队列就是允许在队列的两端进行插入和删除的队列"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"体现在编码上，最常见的载体是既允许使用 pop、push 同时又允许使用 shift、unshift 的数组："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const queue = [1,2,3,4] // 定义一个双端队列   \nqueue.push(1) // 双端队列尾部入队 \nqueue.pop() // 双端队列尾部出队   \nqueue.shift() // 双端队列头部出队 \nqueue.unshift(1) // 双端队列头部入队\n"})}),"\n",(0,c.jsx)(e.p,{children:"现在相信你对双端队列已经形成了一个感性的认知，咱们紧接着就开始做题，在题里去认知这种结构的特征和效用。"}),"\n",(0,c.jsxs)(e.h2,{id:"滑动窗口问题",children:["滑动窗口问题",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#滑动窗口问题",children:"#"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目描述：给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。"}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"示例:\n输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7]"}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["解释:  滑动窗口的位置",(0,c.jsx)(e.br,{}),"\n","---------------",(0,c.jsx)(e.br,{}),"\n","[1  3  -1] -3  5  3  6  7",(0,c.jsx)(e.br,{}),"\n","1 [3  -1  -3] 5  3  6  7",(0,c.jsx)(e.br,{}),"\n","1  3 [-1  -3  5] 3  6  7",(0,c.jsx)(e.br,{}),"\n","1  3  -1 [-3  5  3] 6  7",(0,c.jsx)(e.br,{}),"\n","1  3  -1  -3 [5  3  6] 7",(0,c.jsx)(e.br,{}),"\n","1  3  -1  -3  5 [3  6  7]"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["最大值分别对应：",(0,c.jsx)(e.br,{}),"\n","3\n3\n5\n5\n6\n7"]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤\xa0输入数组的大小。"}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"思路分析双指针遍历法",children:["思路分析：双指针+遍历法",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析双指针遍历法",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["这道题如果只是为了做对，那么思路其实不难想，我们直接模拟题中描述的这个过程就行。",(0,c.jsx)(e.br,{}),"\n","按照题意，它要求我们在遍历数组的过程当中，约束一个窗口——窗口的本质其实就是一个范围，像这样："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"[1  3  -1] -3  5  3  6  7 \n"})}),"\n",(0,c.jsxs)(e.p,{children:["范围就被圈定在了前三个元素。",(0,c.jsx)(e.br,{}),"\n","我们前面学过，约束范围，可以用双指针。因此我这里定义一个 ",(0,c.jsx)(e.code,{children:"left"})," 左指针、定义一个 ",(0,c.jsx)(e.code,{children:"right"})," 右指针，分别指向窗口的两端即可："]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)("img",{src:x,alt:""}),"\n接下来我们可以把这个窗口里的数字取出来，直接遍历一遍、求出最大值，然后把最大值存进结果数组。这样第一个窗口的最大值就有了。"]}),"\n",(0,c.jsx)(e.p,{children:"接着按照题意，窗口每次前进一步（左右指针每次一起往前走一步），此时的范围变成了这样："}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)("img",{src:a,alt:""}),"\n我们要做的仍然是取出当前范围的所有元素、遍历一遍求出最大值，然后将最大值存进结果数组。"]}),"\n",(0,c.jsx)(e.p,{children:"反复执行上面这个过程，直到数组完全被滑动窗口遍历完毕，我们也就得到了问题的答案。"}),"\n",(0,c.jsx)(e.p,{children:"基于这个淳朴的思路，我们来写一波代码："}),"\n",(0,c.jsxs)(e.h3,{id:"编码实现双指针遍历法",children:["编码实现：双指针+遍历法",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现双指针遍历法",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst maxSlidingWindow = function (nums, k) {\n  // 缓存数组的长度\n  const len = nums.length;\n  // 定义结果数组\n  const res = [];\n  // 初始化左指针\n  let left = 0;\n  // 初始化右指针\n  let right = k - 1;\n  // 当数组没有被遍历完时，执行循环体内的逻辑\n  while (right < len) {\n    // 计算当前窗口内的最大值\n    const max = calMax(nums, left, right);\n    // 将最大值推入结果数组\n    res.push(max);\n    // 左指针前进一步\n    left++;\n    // 右指针前进一步\n    right++;\n  }\n  // 返回结果数组\n  return res;\n};\n\n// 这个函数用来计算最大值\nfunction calMax(arr, left, right) {\n  // 处理数组为空的边界情况\n  if (!arr || !arr.length) {\n    return;\n  }\n  // 初始化 maxNum 的值为窗口内第一个元素\n  let maxNum = arr[left];\n  // 遍历窗口内所有元素，更新 maxNum 的值\n  for (let i = left; i <= right; i++) {\n    if (arr[i] > maxNum) {\n      maxNum = arr[i];\n    }\n  }\n  // 返回最大值\n  return maxNum;\n}\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"解法复盘",children:["解法复盘",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#解法复盘",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["上面这个解法，你在面试的时候写上去，完全没有问题，也不用担心超时。",(0,c.jsx)(e.br,{}),"\n","有的同学可能会觉得 ",(0,c.jsx)(e.code,{children:"calMax"})," 这个函数多余了，认为可以直接用 ",(0,c.jsx)(e.code,{children:"Math.max"})," 这个 JS 原生方法。其实就算是",(0,c.jsx)(e.code,{children:"Math.max"}),"，也不可避免地需要对你传入的多个数字做最小值查找，",(0,c.jsx)(e.code,{children:"calMax"})," 和",(0,c.jsx)(e.code,{children:"Math.max"}),"做的工作可以说是一样的辛苦。我这里手动实现一个 ",(0,c.jsx)(e.code,{children:"calMax"}),"， 大家会对查找过程造成的时间开销有更直观的感知。"]}),"\n",(0,c.jsxs)(e.p,{children:["现在我们来思考一下，上面这一波操作下来，时间复杂度是多少？",(0,c.jsx)(e.br,{}),"\n","这波操作里其实涉及了两层循环，外层循环是 ",(0,c.jsx)(e.code,{children:"while"}),"，它和滑动窗口前进的次数有关。滑动窗口前进了多少次，",(0,c.jsx)(e.code,{children:"while"})," 就执行了多少次。"]}),"\n",(0,c.jsxs)(e.p,{children:["假设数组的规模是 ",(0,c.jsx)(e.code,{children:"n"}),"，那么从起始位置开始，滑动窗口每次走一步，一共可以走 ",(0,c.jsx)(e.code,{children:"n - k "})," 次。注意别忘了初始位置也算作一步的，因此一共走了 ",(0,c.jsx)(e.code,{children:"n - k + 1"}),"次。然后每个窗口内部我们又会固定执行 ",(0,c.jsx)(e.code,{children:"k"})," 次遍历。注意 ",(0,c.jsx)(e.code,{children:"k"})," 可不是个常数，它和 ",(0,c.jsx)(e.code,{children:"n"})," 一样是个变量。因此这个时间复杂度简化后用大 O 表示法可以记为 ",(0,c.jsx)(e.code,{children:"O(kn)"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"O(kn)"})," 虽然不差，但对这道题来说，还不是最好。因此在面试过程中，如果你采用了上面这套解法做出了这个题，面试官有 99% 的可能性会追问你：这个题可以优化吗？如何优化？（或者直接问你，你能在线性时间复杂度内解决此题吗？）"]}),"\n",(0,c.jsxs)(e.p,{children:["答案当然是能，然后面试官就会搬个小板凳坐你旁边，看看你怎么妙手回春，变 ",(0,c.jsx)(e.code,{children:"O(kn)"})," 为 ",(0,c.jsx)(e.code,{children:"O(n)"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"接下来你需要表演的，正是面试官期待已久的双端队列解法啊！"}),"\n",(0,c.jsxs)(e.h3,{id:"思路分析双端队列法",children:["思路分析：双端队列法",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析双端队列法",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["要想变 ",(0,c.jsx)(e.code,{children:"O(kn)"})," 为 ",(0,c.jsx)(e.code,{children:"O(n)"}),"，我们就要想怎么做才能丢掉这个 ",(0,c.jsx)(e.code,{children:"k"}),"。",(0,c.jsx)(e.br,{}),"\n",(0,c.jsx)(e.code,{children:"k"})," 之所以会产生，是因为我们现在只能通过遍历来更新最大值。那么更新最大值，有没有更高效的方法呢？",(0,c.jsx)(e.br,{}),"\n","大家仔细想想，当滑动窗口往后前进一步的时候，比如我从初始位置前进到第二个位置："]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)("img",{src:t,alt:""}),"\n（图中红色的范围是初始位置时，滑动窗口覆盖到的元素）"]}),"\n",(0,c.jsxs)(e.p,{children:["此时滑动窗口内的元素少了一个 1，增加了一个 -3——减少的数不是当前最大值，增加的数也没有超越当前最大值，因此最大值仍然是 3。此时我们不禁要想：如果我们能",(0,c.jsx)(e.strong,{children:"在窗口发生移动时，只根据发生变化的元素对最大值进行更新"}),"，那复杂度是不是就低很多了？"]}),"\n",(0,c.jsx)(e.p,{children:"双端队列可以完美地帮助我们达到这个目的。"}),"\n",(0,c.jsxs)(e.p,{children:["使用双端队列法，核心的思路是维护一个",(0,c.jsx)(e.strong,{children:"有效的递减队列"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"在遍历数组的前期，我们尝试将遍历到的每一个元素都推入队列内部（下图是第一个元素入队的示意图）："}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)("img",{src:l,alt:""}),"\n每尝试推入一个元素前，都把这个元素与队列尾部的元素作对比。根据对比结果的不同，采取不同的措施："]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"如果试图推入的元素（当前元素）大于队尾元素，则意味着队列的递减趋势被打破了。此时我们需要将队列尾部的元素依次出队（注意由于是双端队列，所以队尾出队是没有问题的）、直到队尾元素大于等于当前元素为止，此时再将当前元素入队。"}),"\n",(0,c.jsx)(e.li,{children:"如果试图推入的元素小于队列尾部的元素，那么就不需要额外的操作，直接把当前元素入队即可。"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"我用动画来表达一下这个过程："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(e.p,{children:["（注：动画大小已经极致压缩，如果仍然存在加载失败问题，可能与网络环境有关。如果你遇到了这个问题，建议 PC 端点击",(0,c.jsx)(e.a,{href:"./images/3722a7a92466cf249b95b67cce644ea3.webp",children:"这里"}),"直接访问动图试试看）"]}),"\n",(0,c.jsxs)(e.p,{children:["维持递减队列的目的，就在于",(0,c.jsx)(e.strong,{children:"确保队头元素始终是当前窗口的最大值"}),"。",(0,c.jsx)(e.br,{}),"\n","当遍历到的元素个数达到了 ",(0,c.jsx)(e.code,{children:"k"})," 个时，意味着滑动窗口的第一个最大值已经产生了，我们把它 push 进结果数组里："]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsxs)(e.p,{children:["然后继续前进，我们发现数组索引 0 处的元素（",(0,c.jsx)(e.code,{children:"1"}),"）已经被踢出滑动窗口了（图中红色方块对应的是当前滑动窗口覆盖到的元素们）："]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)("img",{src:i,alt:""}),"\n为了确保",(0,c.jsx)(e.strong,{children:"队列的有效性"}),"，需要及时地去队列检查下 ",(0,c.jsx)(e.code,{children:"1"})," 这个元素在不在队列里（在的话要及时地踢出去，因为队列本身只维护当前滑动窗口内的元素）。"]}),"\n",(0,c.jsxs)(e.p,{children:["这里大家思考一下，我在查找 ",(0,c.jsx)(e.code,{children:"1"})," 的时候，需不需要遍历整个队列？答案是不需要，因为 ",(0,c.jsx)(e.code,{children:"1"})," 是最靠前的一个元素，如果它在，那么它一定是队头元素。这里我们只需要检查队头元素是不是 ",(0,c.jsx)(e.code,{children:"1"})," 就行了。 此时我们检查队头，发现是 ",(0,c.jsx)(e.code,{children:"3"}),"："]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,c.jsxs)(e.p,{children:["没错，",(0,c.jsx)(e.code,{children:"1"}),"早就因为不符合递减趋势被从队头干掉了。此时我们可以断定，当前双端队列里的元素都是滑动窗口已经覆盖的有效元素——没毛病，继续往下走就行了。"]}),"\n",(0,c.jsx)(e.p,{children:"接下来，每往前遍历一个元素，都需要重复以上的几个步骤。这里我总结一下每一步都做了什么："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsx)(e.li,{children:"检查队尾元素，看是不是都满足大于等于当前元素的条件。如果是的话，直接将当前元素入队。否则，将队尾元素逐个出队、直到队尾元素大于等于当前元素为止。"}),"\n",(0,c.jsx)(e.li,{children:"将当前元素入队"}),"\n",(0,c.jsx)(e.li,{children:"检查队头元素，看队头元素是否已经被排除在滑动窗口的范围之外了。如果是，则将队头元素出队。"}),"\n",(0,c.jsxs)(e.li,{children:["判断滑动窗口的状态：看当前遍历过的元素个数是否小于 ",(0,c.jsx)(e.code,{children:"k"}),"。如果元素个数小于",(0,c.jsx)(e.code,{children:"k"}),"，这意味着第一个滑动窗口内的元素都还没遍历完、第一个最大值还没出现，此时我们还不能动结果数组，只能继续更新队列；如果元素个数大于等于",(0,c.jsx)(e.code,{children:"k"}),"，这意味着滑动窗口的最大值已经出现了，此时每遍历到一个新元素（也就是滑动窗口每往前走一步）都要及时地往结果数组里添加当前滑动窗口对应的最大值（最大值就是此时此刻双端队列的队头元素）。"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"这四个步骤分别有以下的目的："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:["维持队列的",(0,c.jsx)(e.strong,{children:"递减性"}),"：确保队头元素是当前滑动窗口的最大值。这样我们每次取最大值时，直接取队头元素即可。"]}),"\n",(0,c.jsx)(e.li,{children:"这一步没啥好说的，就是在维持队列递减性的基础上、更新队列的内容。"}),"\n",(0,c.jsxs)(e.li,{children:["维持队列的",(0,c.jsx)(e.strong,{children:"有效性"}),"：确保队列里所有的元素都在滑动窗口圈定的范围以内。"]}),"\n",(0,c.jsx)(e.li,{children:"排除掉滑动窗口还没有初始化完成、第一个最大值还没有出现的特殊情况。"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"结合以上的分析，我们来写代码："}),"\n",(0,c.jsxs)(e.h3,{id:"编码实现-1",children:["编码实现",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-1",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nconst maxSlidingWindow = function (nums, k) {\n  // 缓存数组的长度\n  const len = nums.length;\n  // 初始化结果数组\n  const res = [];\n  // 初始化双端队列\n  const deque = [];\n  // 开始遍历数组\n  for (let i = 0; i < len; i++) {\n    // 当队尾元素小于当前元素时\n    while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {\n      // 将队尾元素（索引）不断出队，直至队尾元素大于等于当前元素\n      deque.pop();\n    }\n    // 入队当前元素索引（注意是索引）\n    deque.push(i);\n    // 当队头元素的索引已经被排除在滑动窗口之外时\n    while (deque.length && deque[0] <= i - k) {\n      // 将队头元素索引出队\n      deque.shift();\n    }\n    // 判断滑动窗口的状态，只有在被遍历的元素个数大于 k 的时候，才更新结果数组\n    if (i >= k - 1) {\n      res.push(nums[deque[0]]);\n    }\n  }\n  // 返回结果数组\n  return res;\n};\n"})}),"\n",(0,c.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function f(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(p,{...n})}):p(n)}let b=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%2F13.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%8E%E4%B9%88%E7%8E%A9%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"为什么一道题可以成为高频面试题",id:"为什么一道题可以成为高频面试题",depth:2},{text:"如何用栈实现一个队列？",id:"如何用栈实现一个队列",depth:2},{text:"思路分析",id:"思路分析",depth:3},{text:"编码实现",id:"编码实现",depth:3},{text:"认识双端队列",id:"认识双端队列",depth:2},{text:"滑动窗口问题",id:"滑动窗口问题",depth:2},{text:"思路分析：双指针+遍历法",id:"思路分析双指针遍历法",depth:3},{text:"编码实现：双指针+遍历法",id:"编码实现双指针遍历法",depth:3},{text:"解法复盘",id:"解法复盘",depth:3},{text:"思路分析：双端队列法",id:"思路分析双端队列法",depth:3},{text:"编码实现",id:"编码实现-1",depth:3}],title:"13.栈与队列怎么玩（下）",headingTitle:"13.栈与队列怎么玩（下）",frontmatter:{}}}}]);