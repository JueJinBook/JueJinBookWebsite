"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["39956"],{509922:function(e,n,t){t.r(n),t.d(n,{default:()=>i});var r=t(552676),s=t(740453);let c=t.p+"static/image/53eff38812daa4a78ee00502a164b11f.a5492fe3.webp",a=t.p+"static/image/8cc854a4363d60260a5a69008b35f95d.3c1a54c2.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",pre:"pre",code:"code",img:"img",h3:"h3"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"17-理解-http拦截器与动态路由",children:["17 理解 HTTP：拦截器与动态路由",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17-理解-http拦截器与动态路由",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面几节课，我们借助 http、url、path、fs、zlib 等内置模块，以及 mime 第三方模块，以非常简单的代码实现了处理静态资源的 HTTP 服务的大致功能。这一节课，我们将实现更加复杂的动态部分。"}),"\n",(0,r.jsx)(n.p,{children:"在开始学习之前，我们首先要弄清楚什么是静态 HTTP 服务和动态 HTTP 服务。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"静态 HTTP 服务"}),"是指不需要任何业务逻辑处理的，直接返回与请求 URL 对应的文件（这里的文件包括了图片、音频、视频、html 文件等等）。而",(0,r.jsx)(n.strong,{children:"动态 HTTP 服务"}),"是指需要根据不同的请求信息（如路径、query 等），将请求分配给不同的模块进行相应的业务逻辑处理，然后将结果返回给客户端。"]}),"\n",(0,r.jsx)(n.p,{children:"静态服务的处理逻辑简单，全部功能加起来也就五六十行代码，所以我们没有必要使用任何特别的设计和封装。相比静态服务，动态 HTTP 服务要复杂得多，因为它需要对请求信息进行解析，分配相应的模块并处理数据，所以有必要进行架构设计。"}),"\n",(0,r.jsx)(n.p,{children:"目前比较流行的 Node.js HTTP 服务框架的架构采用了拦截器模式，这种模式将 HTTP 请求响应的过程分为若干切面，每个切面上进行一项或若干项关联的操作。比如说，我们可以通过不同的拦截切面处理用户信息验证、会话（session）验证、表单数据验证、query 解析，或者业务逻辑处理等等。这种架构设计让切面与切面之间彼此独立，有其可取之处。"}),"\n",(0,r.jsx)(n.p,{children:"接下来，我们就使用这种拦截器模式来设计我们的动态 HTTP 服务器。在这个过程中，大家可以体会这种模式的优点。"}),"\n",(0,r.jsxs)(n.h2,{id:"设计一个拦截器",children:["设计一个拦截器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计一个拦截器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"拦截器是由很多个拦截切面构成。所谓拦截切面实际上是一个函数，它的函数签名如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async (ctx, next) => {\n  do sth...\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"它有两个参数。第一个参数是一个上下文，这个上下文在多个拦截切面中是共享的。第二个参数是一个 next 函数，调用它会进入下一个拦截切面。"}),"\n",(0,r.jsx)(n.p,{children:"接下来，我们实现一个拦截器模块（interceptor.js）："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class Interceptor {\n  constructor() {\n    this.aspects = []; // 用于存储拦截切面\n  }\n\n  use(/* async */ functor) { // 注册拦截切面\n    this.aspects.push(functor);\n    return this;\n  }\n\n  async run(context) { // 执行注册的拦截切面\n    const aspects = this.aspects;\n\n    // 将注册的拦截切面包装成一个洋葱模型\n    const proc = aspects.reduceRight(function (a, b) { // eslint-disable-line\n      return async () => {\n        await b(context, a);\n      };\n    }, () => Promise.resolve());\n\n    try {\n      await proc(); //从外到里执行这个洋葱模型\n    } catch (ex) {\n      console.error(ex.message);\n    }\n\n    return context;\n  }\n}\n\nmodule.exports = Interceptor;\n"})}),"\n",(0,r.jsx)(n.p,{children:"这段代码只有二三十行，却运用了函数式编程的思想实现了能够注册多个拦截切面函数，并将这些拦截切面包装成一个异步的洋葱模型的拦截器框架。"}),"\n",(0,r.jsxs)(n.p,{children:["其中，",(0,r.jsx)(n.code,{children:"use"}),"方法将拦截切面存入 aspects 数组。",(0,r.jsx)(n.code,{children:"run"}),"方法通过数组的 reduceRight 方法迭代 aspects 数组，将所有注册的拦截切面拼接成异步调用嵌套的洋葱模式并执行它。此时你可能会对这段代码感到困惑，没有关系，我们通过一个简单的例子来理解这个框架是如何拼接和执行所有拦截切面的。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function wait(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nconst inter = new Interceptor();\n\nconst task = function(id) {\n  return async (ctx, next) => {\n    console.log(`task ${id} begin`);\n    ctx.count++;\n    await wait(1000);\n    console.log(`count: ${ctx.count}`);\n    await next();\n    console.log(`task ${id} end`);\n  };\n}\n\n// 将多个任务以拦截切面的方式注册到拦截器中\ninter.use(task(0));\ninter.use(task(1));\ninter.use(task(2));\ninter.use(task(3));\ninter.use(task(4));\n\n// 从外到里依次执行拦截切面\ninter.run({count: 0});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["首先，我们给拦截器注册了 5 个拦截切面，分别是 task0 到 task4 。当我们调用 run 方法时，这 5 个拦截切面被拼接为如下形式，即 ",(0,r.jsx)(n.code,{children:"proc"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后，执行这个异步洋葱模型，它的输出结果如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'"task 0 begin"\n"count: 1"\n"task 1 begin"\n"count: 2"\n"task 2 begin"\n"count: 3"\n"task 3 begin"\n"count: 4"\n"task 4 begin"\n"count: 5"\n"task 4 end"\n"task 3 end"\n"task 2 end"\n"task 1 end"\n"task 0 end"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到，这是一个层层深入的异步嵌套调用模型，但写法上却是同步的写法。拦截器通过 use 方法将不同业务逻辑的拦截切面串联起来，然后通过 run 方法依次执行。当然，我们还可以使用",(0,r.jsx)(n.code,{children:"try...catch"}),"，使得其中一个拦截切面执行失败，就阻止后续拦截切面继续运行："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const task = function(id) {\n  return async (ctx, next) => {\n    try {\n      console.log(`task ${id} begin`);\n      ctx.count++;\n      await wait(1000);\n      console.log(`count: ${ctx.count}`);\n      await next();\n      console.log(`task ${id} end`);\n    } catch(ex) {\n      throw new Error(ex);\n    }\n  };\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"现在，我们可以用拦截器来改进一下 HTTP 服务器了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const http = require('http');\nconst Interceptor = require('./interceptor.js');\n\nmodule.exports = class {\n  constructor() {\n    const interceptor = new Interceptor();\n\n    this.server = http.createServer(async (req, res) => {\n      await interceptor.run({req, res}); // 执行注册的拦截函数\n      if(!res.writableFinished) {\n        let body = res.body || '200 OK';\n        if(body.pipe) {\n          body.pipe(res);\n        } else {\n          if(typeof body !== 'string' && res.getHeader('Content-Type') === 'application/json') {\n            body = JSON.stringify(body);\n          }\n          res.end(body);\n        }\n      }\n    });\n\n    this.server.on('clientError', (err, socket) => {\n      socket.end('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');\n    });\n\n    this.interceptor = interceptor;\n  }\n\n  listen(opts, cb = () => {}) {\n    if(typeof opts === 'number') opts = {port: opts};\n    opts.host = opts.host || '0.0.0.0';\n    console.log(`Starting up http-server\n    http://${opts.host}:${opts.port}`);\n    this.server.listen(opts, () => cb(this.server));\n  }\n\n  use(aspect) { // 向http服务器添加不同功能的拦截切面\n    return this.interceptor.use(aspect);\n  }\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如上代码所示，我们在 HTTP 服务的构造函数中初始化拦截器，并开放",(0,r.jsx)(n.code,{children:"use"}),"接口，允许用户将不同功能的拦截函数添加到服务器中，比如用户信息验证、表单数据验证、业务逻辑处理等等。当服务器接收到请求数据，就会根据上下文",(0,r.jsx)(n.code,{children:"{req, res}"}),"依次执行拦截器中的每个拦截函数。"]}),"\n",(0,r.jsx)(n.p,{children:"现在，我们启动这个服务："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Server = require('./lib/server');\n\nconst app = new Server();\n\napp.listen({\n  port: 9090,\n  host: '0.0.0.0',\n});\n\n// 未添加任何拦截函数\n"})}),"\n",(0,r.jsxs)(n.p,{children:["现在访问",(0,r.jsx)(n.code,{children:"http://localhost:9090"}),"，浏览器返回的内容是文本",(0,r.jsx)(n.code,{children:"200 OK"}),"，这是因为我们现在还没有添加拦截器。"]}),"\n",(0,r.jsx)(n.p,{children:"然后，我们增加一个拦截器："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Server = require('./lib/server');\n\nconst app = new Server();\n\n// 添加拦截切面\napp.use(async ({res}, next) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.body = '<h1>Hello world</h1>';\n  await next();\n});\n\napp.listen({\n  port: 9090,\n  host: '0.0.0.0',\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"如上代码所示，我们向服务器添加了一个非常简单的拦截切面 —— 返回“hello world”HTML 文本。这时再启动服务器，我们就能在浏览器上看到“hello world”的网页了。"}),"\n",(0,r.jsxs)(n.p,{children:["当然，上面的例子并不能体现拦截器的好处。但在实际业务处理中，拦截器确是非常有用的。比如，我们有一个业务需求：授权的用户提交申请表单，可以查看数据。这时，我们可以将这个业务需求切分为 3 个切面：用户信息验证、表单信息验证、查询业务数据并返回。如果用户信息验证的切面不能通过，那么后面 2 个切面就不会执行。一个项目中，用户信息验证可能在很多业务逻辑中都用到，那么",(0,r.jsx)(n.strong,{children:"这个拦截切面还可以被共用，避免了代码的冗余"}),"。所以拦截器的好处至少有两个：",(0,r.jsx)(n.strong,{children:"控制业务流程和复用功能模块"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"当然，我们也可以创建一个用户信息验证的拦截切面，比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"app.use(async ({res}, next) => {\n  // 验证用户信息，成功继续执行\n  await next();\n\n  // 如果失败，暂停剩下的拦截切面的执行\n});\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"路由",children:["路由",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"到目前为止，我们的 HTTP 服务器，无论用户访问任何 path，它都只能分配到 createServer 的回调模块中。如果我们需要根据用户访问的不同 URL 路径，将请求分配给不同的模块，那么我们就需要实现路由功能。"}),"\n",(0,r.jsx)(n.p,{children:"什么是路由？这里的路由和网络物理层的路由不是一个概念。我们知道 URL 是由几个部分组成："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"protocol: // hostname:port / pathname ? query # hash\n"})}),"\n",(0,r.jsx)(n.p,{children:"所以我们的路由模块需要实现的功能就是 —— 解析 URL 中的 pathname，根据不同的路径将请求分配给相应的模块去处理。"}),"\n",(0,r.jsxs)(n.h3,{id:"实现路由",children:["实现路由",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现路由",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们先来看看路由的实现思路。"}),"\n",(0,r.jsxs)(n.p,{children:["一个简单的路由是一个类，它的方法能够返回不同的拦截切面，这样的类叫做 HTTP 服务",(0,r.jsx)(n.strong,{children:"中间件（Middleware）"}),"。具体实现代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Router类\n\nconst url = require('url');\nconst path = require('path');\n\n/*\n@rule：路径规则\n@pathname：路径名\n*/\nfunction check(rule, pathname) {\n  /* \n  解析规则，比如：/test/:course/:lecture\n  paraMatched = ['/test/:course/:lecture', ':course', ':lecture']\n  */\n  const paraMatched = rule.match(/:[^/]+/g);\n  const ruleExp = new RegExp(`^${rule.replace(/:[^/]+/g, '([^/]+)')}$`);\n\n  /*\n  解析真正的路径，比如：/test/123/abc\n  ruleMatched = ['/test/123/abs', '123', 'abs']\n  */\n  const ruleMatched = pathname.match(ruleExp);\n\n  /*\n  将规则和路径拼接为对象：\n  ret = {course: 123, lecture: abc}\n  */\n  if(ruleMatched) {\n    const ret = {};\n    if(paraMatched) {\n      for(let i = 0; i < paraMatched.length; i++) {\n        ret[paraMatched[i].slice(1)] = ruleMatched[i + 1];\n      }\n    }\n    return ret;\n  }\n  return null;\n}\n\n/*\n@method: GET/POST/PUT/DELETE\n@rule: 路径规则，比如：test/:course/:lecture\n@aspect: 拦截函数\n*/\nfunction route(method, rule, aspect) {\n  return async (ctx, next) => {\n    const req = ctx.req;\n    if(!ctx.url) ctx.url = url.parse(`http://${req.headers.host}${req.url}`);\n    const checked = check(rule, ctx.url.pathname); // 根据路径规则解析路径\n    if(!ctx.route && (method === '*' || req.method === method)\n      && !!checked) {\n      ctx.route = checked;\n      await aspect(ctx, next);\n    } else { // 如果路径与路由规则不匹配，则跳过当前拦截切面，执行下一个拦截切面\n      await next();\n    }\n  };\n}\n\nclass Router {\n  constructor(base = '') {\n    this.baseURL = base;\n  }\n\n  get(rule, aspect) {\n    return route('GET', path.join(this.baseURL, rule), aspect);\n  }\n\n  post(rule, aspect) {\n    return route('POST', path.join(this.baseURL, rule), aspect);\n  }\n\n  put(rule, aspect) {\n    return route('PUT', path.join(this.baseURL, rule), aspect);\n  }\n\n  delete(rule, aspect) {\n    return route('DELETE', path.join(this.baseURL, rule), aspect);\n  }\n\n  all(rule, aspect) {\n    return route('*', path.join(this.baseURL, rule), aspect);\n  }\n}\n\nmodule.exports = Router;\n"})}),"\n",(0,r.jsx)(n.p,{children:"这里的 route 函数是一个高阶函数，它返回的函数作为拦截切面被添加到 server 的拦截器中。check 函数利用正则表达式检查真正的路径和路由规则是否匹配，如果命中规则，就返回解析后的规则对象，并将它写入到 ctx.route 属性中去，然后 route 函数调用真正的切面（即：aspect 函数）执行内容。如果没有命中，则跳过这个拦截切面，执行下一个拦截切面。"}),"\n",(0,r.jsx)(n.p,{children:"下面，我们将路由中间件应用到我们的 HTTP 服务中："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const router = new Router();\n\napp.use(router.all('/test/:course/:lecture', async ({route, res}, next) => {\n  res.setHeader('Content-Type', 'application/json');\n  res.body = route;\n  await next();\n}));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里我们设置了一个路由规则：",(0,r.jsx)(n.code,{children:"/test/:course/:lecture"}),"。如果我们访问的路径和这条路由规则匹配，则执行这条规则里的拦截函数。"]}),"\n",(0,r.jsxs)(n.p,{children:["比如，我们访问的路径是",(0,r.jsx)(n.code,{children:"http://localhost:9090/test/123/abc"}),"，它刚好与路由规则匹配，所以",(0,r.jsx)(n.code,{children:"ctx.route"}),"得到的是",(0,r.jsx)(n.code,{children:'{course: "123", lecture: "abc"}'}),"。这个请求的效果如下图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后我们还可以再添加一个默认的路由："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"app.use(router.all('.*', async ({req, res}, next) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.body = '<h1>Hello world</h1>';\n  await next();\n}));\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这条规则表示让未匹配到的 URL 走这个默认的路由，打印出",(0,r.jsx)(n.code,{children:"<h1>Hello world</h1>"}),"。完整的服务器代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const Server = require('./lib/server');\nconst Router = require('./lib/middleware/router');\n\nconst app = new Server();\nconst router = new Router();\n\napp.listen({\n  port: 9090,\n  host: '0.0.0.0',\n});\n\napp.use(router.all('/test/:course/:lecture', async ({route, res}, next) => {\n  res.setHeader('Content-Type', 'application/json');\n  res.body = route;\n  await next();\n}));\n\napp.use(router.all('.*', async ({req, res}, next) => {\n  res.setHeader('Content-Type', 'text/html');\n  res.body = '<h1>Hello world</h1>';\n  await next();\n}));\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["因为动态 HTTP 服务器需要根据不同的请求信息（比如：路径、query 等）将请求分配给不同的处理模块，所以我们需要对它进行架构设计。在动态服务器架构设计中，最基础的就是",(0,r.jsx)(n.strong,{children:"拦截器模块和路由模块"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"拦截器可以注册多个拦截切面，各切面通过 next 方法联系，运行时依次异步执行每个拦截切面。使用拦截器的优点在于，它可以将一个业务流程按照功能分为若干切面，当其中一个切面执行失败时，它能够阻止后面的切面继续执行，起到了流程控制的作用。同时，每个功能切面还能被其他业务需求共享，降低了项目代码的冗余度。"}),"\n",(0,r.jsx)(n.p,{children:"路由的目的是将不同的 HTTP 请求根据不同的 URL 路径分配给不同的业务处理模块。路由模块是一个中间件，可以自定义路由规则。我们的例子中，HTTP 服务会根据 URL 的 pathname 匹配路由规则，执行命中规则中的拦截切面函数。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F17%20%E7%90%86%E8%A7%A3%20HTTP%EF%BC%9A%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1.md"]={toc:[{text:"设计一个拦截器",id:"设计一个拦截器",depth:2},{text:"路由",id:"路由",depth:2},{text:"实现路由",id:"实现路由",depth:3},{text:"总结",id:"总结",depth:3}],title:"17 理解 HTTP：拦截器与动态路由",headingTitle:"17 理解 HTTP：拦截器与动态路由",frontmatter:{}}}}]);