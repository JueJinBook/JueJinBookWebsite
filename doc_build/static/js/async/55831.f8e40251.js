"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55831"],{624102:function(e,n,t){t.r(n),t.d(n,{default:()=>l});var s=t(552676),r=t(740453);let o=t.p+"static/image/0a75cfce3b920ddc51c025ccbac1b00c.214c2e80.webp",h=t.p+"static/image/2ddbba2a9f1682329e964e1d5a3e973a.80d18054.webp",i=t.p+"static/image/8832aa533f4fb4b07a5897a79b4952a7.26bbc7f6.webp",c=t.p+"static/image/f4499a9105857d3da79be8054438384e.db776e21.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",strong:"strong",code:"code",pre:"pre",ul:"ul",li:"li",ol:"ol",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"16业务篇-首页主题换肤功能实现且hooks优化逻辑",children:["16.业务篇-首页主题换肤功能实现且Hooks优化逻辑",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16业务篇-首页主题换肤功能实现且hooks优化逻辑",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章节将一步步带你开发主题换肤功能，如果你对本章节内容兴趣不大，可以快速阅读或跳过。"}),"\n",(0,s.jsxs)(n.h2,{id:"开发前的思考",children:["开发前的思考",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#开发前的思考",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"为们先来看看效果图，当我们选择不同主题颜色时，整个应用主题跟着进行改变"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["在开发之前，我们先来思考一个问题：",(0,s.jsx)(n.strong,{children:"该换肤功能是否只局限于首页"}),"？"]}),"\n",(0,s.jsx)(n.p,{children:"很明显，并不是，举个场景，将来我进入到二级、三级页面，在该页面中也想实现主题换肤功能，那我需要先回到首页进行换肤吗？这明显是不合理的。"}),"\n",(0,s.jsxs)(n.p,{children:["有小伙伴可以会想：我将相同的逻辑代码拷贝一份在目标页面，可以吗？答案是：可以的。但随之带来的问题就是：重复代码多，并且这不符合 React 的设计，",(0,s.jsx)(n.strong,{children:"React 的最大的特性就是组件化"}),"，组件化的目的就是为了能够进行复用，减少代码的冗余。"]}),"\n",(0,s.jsxs)(n.h2,{id:"mytheme-组件",children:["MyTheme 组件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mytheme-组件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们尝试将其抽离成公共组件，前往 ",(0,s.jsx)(n.code,{children:"renderer/common/components"})," 下新增文件夹，命名为 MyTheme，我们创建 index.tsx 与 index.less"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/common/components/MyTheme/index.tsx\n\nimport React from 'react';\nimport './index.less';\n\ninterface IProps {\n  themeList: TSTheme.Item[];\n  currentTheme: TSTheme.Item;\n  onChangeTheme: (theme: TSTheme.Item) => void;\n}\n\nfunction MyTheme({ themeList = [], currentTheme, onChangeTheme }: IProps) {\n  return (\n    <div styleName=\"box\">\n      {themeList.length > 0 &&\n        themeList.map((t: TSTheme.Item, index: number) => {\n          return (\n            <span\n              key={index}\n              style={{ backgroundColor: t.backgroundColor }}\n              styleName={`${currentTheme.id === t.id ? 'active' : ''}`}\n              onClick={() => {\n                onChangeTheme && onChangeTheme(t);\n              }}\n            />\n          );\n        })}\n    </div>\n  );\n}\n\nexport default MyTheme;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["老规矩，TSTheme 会报红，我们去 ",(0,s.jsx)(n.code,{children:"renderer/common/types"})," 中新增 theme.d.ts"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/common/types/theme.d.ts\n\ndeclare namespace TSTheme {\n  export interface Item {\n    /**\n     * @description 唯一标识\n     */\n    id: string;\n    /**\n     * @description 字体填充颜色\n     */\n    fontColor: string;\n    /**\n     * @description 背景色\n     */\n    backgroundColor: string;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"回到上面代码，MyTheme 组件接收 3 个 Props 参数"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"themeList：主题皮肤列表"}),"\n",(0,s.jsx)(n.li,{children:"currentTheme：当前选中的皮肤"}),"\n",(0,s.jsx)(n.li,{children:"onChangeTheme：切换皮肤回调方法"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["假设我们业务端要用到此组件，往往会写成以下形式：【",(0,s.jsx)(n.strong,{children:"这是例子代码，不用在项目中写入"}),"】"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import MyTheme from './MyTheme';\nimport { useDispatch, useSelector } from 'react-redux';\n\n// 这是例子代码，不要在项目中写入\nfunction Demo() {\n  const dispatch = useDispatch();\n  // \uD83D\uDC47 1. 从 Redux 中取数据\n  const themeList = useSelector((state: any) => state.themeModel.themeList);\n  const currentTheme = useSelector((state: any) => state.themeModel.currentTheme);\n\n  // \uD83D\uDC47 2. 修改 Redux 数据\n  function changeTheme(theme: TSTheme.Item) {\n    dispatch({\n      type: 'themeModel/setStore',\n      payload: {\n        key: 'currentTheme',\n        values: theme,\n      },\n    });\n  }\n\n  // \uD83D\uDC47 3. 给组件传递数据\n  return (\n    <MyTheme\n      themeList={themeList}\n      currentTheme={currentTheme}\n      onChangeTheme={changeTheme}\n    />\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这并不是错误的使用方式，但我们需要想一想，这样写是否合理？"}),"\n",(0,s.jsx)(n.p,{children:"思考一下，这些 Props 的意义何在。对于 themeList，我们反问自己：它常变化吗？不会，在我看来，它更像是“配置”，类似于从配置表中获取主题列表。而我们每次都将一个不常变化的数据源引入，再传递给 MyTheme 组件，是否多此一举？"}),"\n",(0,s.jsxs)(n.p,{children:["其次，我们的数据存放于 redux 与 file 文件中，放 redux 是为了数据实时响应，当我们切换 currentTheme 主题时，",(0,s.jsx)(n.strong,{children:"数据驱动视图更新"}),"。同步到 file 文件是为了防止页面刷新后，redux 数据重置使得选中的主题皮肤失效。",(0,s.jsx)(n.strong,{children:"当然最为关键的莫过于在初次进入应用时，会从 file 中载入最后一次修改的主题"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"所以你认为这些 Props 是否设计得合理？其次还会有什么问题：将来在其他业务组件中使用 MyTheme 组件，我们得拷贝一段相同的逻辑代码（获取 Redux 数据，点击修改 Redux 数据）。"}),"\n",(0,s.jsx)(n.p,{children:"为此，我们来优化一下～"}),"\n",(0,s.jsxs)(n.h2,{id:"thememodel-状态数据",children:["themeModel 状态数据",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#thememodel-状态数据",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["进入 ",(0,s.jsx)(n.code,{children:"renderer/store"})," 文件夹下，新增 themeModel.ts 文件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/store/themeModel.ts\n\nexport interface TStore {\n  /**\n   * @description 主题列表\n   */\n  themeList: TSTheme.Item[];\n  /**\n   * @description 当前选中的主题\n   */\n  currentTheme: TSTheme.Item;\n}\n\nconst themeModel: TSRcReduxModel.Props<TStore> = {\n  namespace: 'themeModel',\n  openSeamlessImmutable: true,\n  state: {\n    themeList: [],\n    currentTheme: {\n      id: '',\n      fontColor: '',\n      backgroundColor: '',\n    },\n  },\n};\n\nexport default themeModel;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"store/index.ts"}),"，将其引入并加入到 redux 中（其他代码略过）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// \uD83D\uDC47 引入\nimport themeModel from './themeModel';\n// \uD83D\uDC47 添加\nconst reduxModel = new RcReduxModel([..., themeModel]);\n"})}),"\n",(0,s.jsx)(n.p,{children:"至此我们已将主题换肤相关的数据状态建立起来，接下来我们通过 Hooks 来实现优化"}),"\n",(0,s.jsxs)(n.h2,{id:"usethemeactionhooks",children:["useThemeActionHooks",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usethemeactionhooks",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"回头看，上述代码中，哪些逻辑需要进行复用？"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["引入 ",(0,s.jsx)(n.code,{children:"useDispatch"}),"、",(0,s.jsx)(n.code,{children:"useSelector"}),"，目的是为了通过此 API 获取 redux 值，并且发起 dispatch 修改 redux 状态"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import { useDispatch, useSelector } from 'react-redux';\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"获取 redux 主题皮肤相关数据，每个业务组件用 MyTheme 组件时都需要这么写"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const themeList = useSelector((state: any) => state.themeModel.themeList);\nconst currentTheme = useSelector((state: any) => state.themeModel.currentTheme);\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"修改主题皮肤的方法实现，通过 dispatch 进行修改当前选中的主题皮肤"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const dispatch = useDispatch();\nfunction changeTheme(theme: TSTheme.Item) {\n  dispatch({\n    type: 'themeModel/setStore',\n    payload: {\n      key: 'currentTheme',\n      values: theme,\n    },\n  });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们主逻辑就这些，但假设多个业务使用 ",(0,s.jsx)(n.code,{children:"MyTheme"})," 组件时，就需要写一坨相同的逻辑。为此通过 Hooks 进行抽离，从而达到复用。"]}),"\n",(0,s.jsxs)(n.p,{children:["自定义 Hooks 抽离状态逻辑，前往 ",(0,s.jsx)(n.code,{children:"renderer/hooks"})," 文件夹下新增 ",(0,s.jsx)(n.code,{children:"useThemeActionHooks.ts"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/hooks/useThemeActionHooks.ts\nimport { useDispatch, useSelector } from 'react-redux';\n\n/**\n * @description 获取当前主题与修改组件方法\n */\nfunction useGetCurrentTheme() {\n  const changeTheme = useChangeCurrentTheme();\n  const currentTheme = useSelector((state: any) => state.themeModel.currentTheme);\n  return [currentTheme, changeTheme];\n}\n\n/**\n * @description 更新当前选中的主题\n * @param {TSTheme.Item} theme 目标主题\n */\nfunction useChangeCurrentTheme() {\n  const dispatch = useDispatch();\n  return (theme: TSTheme.Item) => {\n    dispatch({\n      type: 'themeModel/setStore',\n      payload: {\n        key: 'currentTheme',\n        values: theme,\n      },\n    });\n  };\n}\n\nexport default {\n  useGetCurrentTheme,\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上所示，我们定义了一个 hook，返回的是一对值：当前状态和一个更新它的函数。当前状态是从 redux 中获取的",(0,s.jsx)(n.code,{children:"实时数据"}),"，同时我们支持了更新它的函数，已通过 dispatch action 进行数据更新。"]}),"\n",(0,s.jsxs)(n.h2,{id:"初始化读取配置获取主题皮肤列表",children:["初始化读取配置获取主题皮肤列表",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化读取配置获取主题皮肤列表",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上面我们通过 ",(0,s.jsx)(n.code,{children:"useThemeActionHooks"})," 能轻松实现获取当前主题并修改主题，但我们在初始化时，需要从配置文件中读取主题皮肤列表，从而进行展示，并且需要得到上一轮最后保存的主题。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们在应用文件夹中新增 ",(0,s.jsx)(n.code,{children:"appConfig"})," 配置文件，新增主题配置文件 ",(0,s.jsx)(n.code,{children:"theme.config.json"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "name": "主题配置表",\n  "currentTheme": { "id": "dark", "fontColor": "#ffffff", "backgroundColor": "#27292c" },\n  "themeList": [\n    { "id": "dark", "fontColor": "#ffffff", "backgroundColor": "#27292c" },\n    { "id": "blue", "fontColor": "#ffffff", "backgroundColor": "#35495e" },\n    { "id": "green", "fontColor": "#ffffff", "backgroundColor": "#416f5b" },\n    { "id": "purple", "fontColor": "#ffffff", "backgroundColor": "#54546c" },\n    { "id": "princess", "fontColor": "#ffffff", "backgroundColor": "#945454" }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["接下来通过 fs 文件系统读取该配置表的内容，存入 Redux 中。前往 ",(0,s.jsx)(n.code,{children:"useThemeActionHooks.ts"})," 文件，我们追加几个 Hooks 方法"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"useSelectTheme：对比上一轮的选中的主题皮肤，选中当前最新的主题"}),"\n",(0,s.jsx)(n.li,{children:"useInitThemeConfig：应用进入时，初始化读取主题配置文件"}),"\n",(0,s.jsxs)(n.li,{children:["useReadAppConfigThemeFile：",(0,s.jsx)(n.strong,{children:"读取"})," appConfig 下的主题配置表文件内容"]}),"\n",(0,s.jsxs)(n.li,{children:["useUpdateAppConfigThemeFile：",(0,s.jsx)(n.strong,{children:"更新"})," appConfig 下的主题配置表文件内容"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/hooks/useThemeActionHooks.ts\n\n/**\n * @description 初始化读取主题配置文件\n */\nfunction useInitThemeConfig() {\n  const selectTheme = useSelectTheme();\n  const readAppConfigThemeFile = useReadAppConfigThemeFile();\n  \n  return () => {\n    readAppConfigThemeFile().then((value: { [key: string]: any }) => {\n      selectTheme(value);\n    });\n  };\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * @description 对比上一轮的选中的主题皮肤\n */\nfunction useSelectTheme() {\n  const dispatch = useDispatch();\n  return (themeConfigValues: any) => {\n    const prevTheme: string = themeConfigValues?.currentTheme || '';\n    const initTheme = { id: 'dark', fontColor: '#ffffff', backgroundColor: '#27292c' };\n\n    let nextTheme: TSTheme.Item;\n    if (themeConfigValues?.themeList.length > 0) {\n      if (prevTheme) nextTheme = _.find(themeConfigValues?.themeList, { id: prevTheme }) || initTheme;\n      else nextTheme = themeConfigValues?.themeList[0];\n    } else {\n      nextTheme = initTheme;\n    }\n    dispatch({\n      type: 'themeModel/setStoreList',\n      payload: [\n        {\n          key: 'currentTheme',\n          values: nextTheme,\n        },\n        {\n          key: 'themeList',\n          values: themeConfigValues?.themeList,\n        },\n      ],\n    });\n  };\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * @description 读取配置文件的内容\n */\nfunction useReadAppConfigThemeFile() {\n  return () => {\n    return new Promise((resolve: (values: { [key: string]: any }) => void, reject: (value: Error) => void) => {\n      getAppPath().then((appPath: string) => {\n        const jsonPath = path.join(appPath, 'appConfig/theme.config.json');\n        fileAction\n          .hasFile(jsonPath)\n          .then(async () => {\n            const themeConfigValues = await fileAction.read(jsonPath, 'utf-8');\n            resolve(JSON.parse(themeConfigValues));\n          })\n          .catch(() => {\n            reject(new Error('appConfig does not exist !'));\n          });\n      });\n    });\n  };\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"/**\n * @description 更新配置表中的用户设置信息\n * @param {string} updateKey 键\n * @param {any} updateValues 值\n * @param {function} callback 回调函数\n */\nfunction useUpdateAppConfigThemeFile() {\n  const readAppConfigThemeFile = useReadAppConfigThemeFile();\n  return (updateKey: string, updateValues: any, callback?: () => void) => {\n    getAppPath().then((appPath: string) => {\n      const jsonPath = path.join(appPath, 'appConfig/theme.config.json');\n      readAppConfigThemeFile().then((values: { [key: string]: any }) => {\n        if (values && !!Object.keys(values).length) {\n          const nextConfigContent = {\n            ...values,\n            [`${updateKey}`]: updateValues,\n          };\n          fileAction.canWrite(jsonPath).then(() => {\n            fileAction.write(jsonPath, nextConfigContent, 'utf-8').then(() => {\n              callback && callback();\n            });\n          });\n        }\n      });\n    });\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"由于我们使用了 lodash 的 find 方法，所以记得安装一下 lodash"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install --save-dev lodash\nnpm install --save-dev @types/lodash\n"})}),"\n",(0,s.jsx)(n.p,{children:"为此，我们通过 Hooks ，将复杂的工作交给它去完成。"}),"\n",(0,s.jsx)(n.p,{children:"接下来看看我们的 MyTheme 组件将会变成什么样子"}),"\n",(0,s.jsxs)(n.h2,{id:"改造后的-mytheme-组件",children:["改造后的 MyTheme 组件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#改造后的-mytheme-组件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们前往修改 MyTheme 组件下的代码，更改为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport './index.less';\nimport { useSelector } from 'react-redux';\n// \uD83D\uDC47 引入该 hooks\nimport useThemeActionHooks from '@src/hooks/useThemeActionHooks';\n\nfunction MyTheme() {\n  const themeList = useSelector((state: any) => state.themeModel.themeList);\n  // \uD83D\uDC47 通过这个 Hooks 得到的是一对值：当前状态和一个更新它的函数\n  const [currentTheme, setCurrentTheme] = useThemeActionHooks.useGetCurrentTheme();\n\n  return (\n    <div styleName=\"box\">\n      {themeList &&\n        themeList.length > 0 &&\n        [...themeList].map((t: TSTheme.Item, index: number) => {\n          return (\n            <span\n              key={index}\n              style={{ backgroundColor: t.backgroundColor }}\n              styleName={`${currentTheme.id === t.id ? 'active' : ''}`}\n              onClick={() => {\n                setCurrentTheme && setCurrentTheme(t, true);\n              }}\n            />\n          );\n        })}\n    </div>\n  );\n}\n\nexport default MyTheme;\n"})}),"\n",(0,s.jsx)(n.p,{children:"那么在业务组件该如何使用此组件呢？前往应用首页，引入此组件使用"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// renderer/container/root/index.tsx\n\n// \uD83D\uDC47  引入此组件\nimport MyTheme from \'@common/components/MyTheme\';\n// \uD83D\uDC47 引入此Hook\nimport useThemeActionHooks from \'@src/hooks/useThemeActionHooks\';\n\n\nfunction Root() {\n  const [currentTheme] = useThemeActionHooks.useGetCurrentTheme();\n\n  return (\n    <div styleName="root" style={{ backgroundColor: currentTheme?.backgroundColor }}>\n      <div styleName="container">\n        {/* \uD83D\uDC47 直接使用即可 */}\n        <div styleName="theme">\n          <MyTheme />\n        </div>\n      </div>\n    </div>\n  );\n}\nexport default Root;\n'})}),"\n",(0,s.jsx)(n.p,{children:"当然我们也需要在应用刚启动时，就读取配置进行赋值，并且需要读到应用上次退出时，最后的主题皮肤。所以我们前往路由组件 router.tsx 的 didMount 生命周期中执行初始化的相关工作。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/router.tsx\n\nimport useThemeActionHooks from './hooks/useThemeActionHooks';\n\nfunction Router() {\n  const initThemeConfig = useThemeActionHooks.useInitThemeConfig();\n  \n  // \uD83D\uDC47 进行初始化工作\n  useEffect(() => {\n    // ...\n    initThemeConfig();\n  }, []);\n\n  // 后面代码忽略\n}\nexport default Router;\n"})}),"\n",(0,s.jsx)(n.p,{children:"刷新一下页面，就可以看到换肤效果了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["接下来，我们只需要给换肤的组件引入 ",(0,s.jsx)(n.code,{children:"useThemeActionHooks"}),"，然后动态绑定一下 style 即可。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章节主要通过动态绑定 style 方式进行简单的换肤功能，一开始通过抽离组件，再到组件 Props 属性的思考，结合其他业务模块之后可能也会用到此组件，在使用上会出现较多重复工作，进而采用 Hooks 进行优化。"}),"\n",(0,s.jsxs)(n.p,{children:["本章节最为重要的在于 useThemeActionHooks 的封装，小伙伴们一定要结合",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/chapter-16",target:"_blank",rel:"noopener noreferrer",children:"线上代码"}),"进行配套学习。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"如果您在边阅读边实践时，发现代码报错或者 TS 报错，那么小伙伴们可以根据报错信息，去线上看看相应的代码。"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["可能有小伙伴认为这不算主题换肤。其实这算最简单的换肤方式，如 AntDesign 的换肤效果，主要原理是通过 less-loader 实现的，阿宽之前也在项目组的UI库中实现过换肤效果，具体可看此文章：",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6912061407961808903",target:"_blank",rel:"noopener noreferrer",children:"【KT】sugard自定义主题皮肤实践踩坑总结"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"本章节的代码量相对较大，如果对本章节存在疑问，欢迎在评论区留言。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let l=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F16.%E4%B8%9A%E5%8A%A1%E7%AF%87-%E9%A6%96%E9%A1%B5%E4%B8%BB%E9%A2%98%E6%8D%A2%E8%82%A4%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E4%B8%94Hooks%E4%BC%98%E5%8C%96%E9%80%BB%E8%BE%91.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"开发前的思考",id:"开发前的思考",depth:2},{text:"MyTheme 组件",id:"mytheme-组件",depth:2},{text:"themeModel 状态数据",id:"thememodel-状态数据",depth:2},{text:"useThemeActionHooks",id:"usethemeactionhooks",depth:2},{text:"初始化读取配置获取主题皮肤列表",id:"初始化读取配置获取主题皮肤列表",depth:2},{text:"改造后的 MyTheme 组件",id:"改造后的-mytheme-组件",depth:2},{text:"总结",id:"总结",depth:2}],title:"16.业务篇-首页主题换肤功能实现且Hooks优化逻辑",headingTitle:"16.业务篇-首页主题换肤功能实现且Hooks优化逻辑",frontmatter:{}}}}]);