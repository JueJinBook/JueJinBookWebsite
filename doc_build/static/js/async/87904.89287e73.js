"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["87904"],{688366:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var a=r(552676),i=r(740453);let c=r.p+"static/image/80202b20bb1a45d8f52fd89668ebe892.48fa3d3c.webp",s=r.p+"static/image/38ecd090e436a6e05fe2c07260f738cc.a20e32f8.webp",t=r.p+"static/image/170e746144b243f690464464f8d2b982.59fb7a9b.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",code:"code",h2:"h2",h3:"h3",pre:"pre",blockquote:"blockquote",img:"img",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"7创建型原型模式谈prototype无小事",children:["7.创建型：原型模式——谈Prototype无小事",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7创建型原型模式谈prototype无小事",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["原型模式不仅是一种设计模式，它还是一种",(0,a.jsx)(n.strong,{children:"编程范式"}),"（programming paradigm），是 JavaScript 面向对象系统实现的根基。"]}),"\n",(0,a.jsxs)(n.p,{children:["在原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过",(0,a.jsx)(n.strong,{children:"克隆原型"}),"的方式来创建出一个与原型一样（共享一套数据/方法）的对象。在 JavaScript 里，",(0,a.jsx)(n.code,{children:"Object.create"}),"方法就是原型模式的天然实现——准确地说，只要我们还在借助",(0,a.jsx)(n.code,{children:"Prototype"}),"来实现对象的创建和原型的继承，那么我们就是在应用原型模式。"]}),"\n",(0,a.jsx)(n.p,{children:"有的设计模式资料中会强调，原型模式就是拷贝出一个新对象，认为在 JavaScript 类里实现了深拷贝方法才算是应用了原型模式。这是非常典型的对 JAVA/C++ 设计模式的生搬硬套，更是对 JavaScript 原型模式的一种误解。"}),"\n",(0,a.jsx)(n.p,{children:"事实上，在JAVA中，确实存在原型模式相关的克隆接口规范。但在 JavaScript 中，我们使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享。克隆是实现这个目的的方法，但克隆本身并不是我们的目的。"}),"\n",(0,a.jsxs)(n.h2,{id:"以类为中心的语言和以原型为中心的语言",children:["以类为中心的语言和以原型为中心的语言",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#以类为中心的语言和以原型为中心的语言",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["相信很多小伙伴读到这儿还会有些迷惑：使用 JavaScript 以来，我确实离不开",(0,a.jsx)(n.code,{children:"Prototype"}),"，按照上面的说法，也算是原型模式重度用户了。但这个原型模式用得我一脸懵逼啊——难道我还有除了",(0,a.jsx)(n.code,{children:"Prototype"}),"以外的选择？"]}),"\n",(0,a.jsxs)(n.h3,{id:"java-中的类",children:["Java 中的类",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#java-中的类",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"作为 JavaScript 开发者，我们确实没有别的选择 —— 毕竟开头我们说过，原型模式是 JavaScript 这门语言面向对象系统的根本。但在其它语言，比如 JAVA 中，类才是它面向对象系统的根本。所以说在 JAVA 中，我们可以选择不使用原型模式 —— 这样一来，所有的实例都必须要从类中来，当我们希望创建两个一模一样的实例时，就只能这样做（假设实例从 Dog 类中来,必传参数为姓名、性别、年龄和品种）："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Dog dog = new Dog('旺财', 'male', 3, '柴犬')\nDog dog_copy = new Dog('旺财', 'male', 3, '柴犬')\n"})}),"\n",(0,a.jsx)(n.p,{children:"没错，我们不得不把一模一样的参数传两遍，非常麻烦。而原型模式允许我们通过调用克隆方法的方式达到同样的目的，比较方便，所以 Java 专门针对原型模式设计了一套接口和方法，在必要的场景下会通过原型方法来应用原型模式。当然，在更多的情况下，Java 仍以“实例化类”这种方式来创建对象。"}),"\n",(0,a.jsx)(n.p,{children:"所以说在以类为中心的语言中，原型模式确实不是一个必选项，它只有在特定的场景下才会登场。"}),"\n",(0,a.jsxs)(n.h3,{id:"javascript-中的类",children:["JavaScript 中的“类”",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-中的类",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["这时有一部分小伙伴估计要炸毛了：啥？？？JavaScript 只能用",(0,a.jsx)(n.code,{children:"Prototype"}),"？我看你还活在上世纪，ES6 早就支持类了！现在我们 JavaScript 也是以类为中心的语言了。"]}),"\n",(0,a.jsx)(n.p,{children:"这波同学的思想非常危险，因为 ES6 的类其实是原型继承的语法糖:"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖。类语法不会为 JavaScript 引入新的面向对象的继承模型。 ——MDN\n当我们尝试用 class 去定义一个 Dog 类时："}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"class Dog {\n  constructor(name ,age) {\n   this.name = name\n   this.age = age\n  }\n  \n  eat() {\n    console.log('肉骨头真好吃')\n  }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"其实完全等价于写了这么一个构造函数:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function Dog(name, age) {\n  this.name = name\n  this.age = age\n}\nDog.prototype.eat = function() {\n  console.log('肉骨头真好吃')\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["所以说 JavaScript 这门语言的根本就是原型模式。在 Java 等强类型语言中，原型模式的出现是为了实现类型之间的解耦。而 JavaScript 本身类型就比较模糊，不存在类型耦合的问题，所以说咱们平时",(0,a.jsx)(n.strong,{children:"根本不会刻意地去使用原型模式"}),"。因此我们此处不必强行把原型模式当作一种设计模式去理解，把它作为一种编程范式来讨论会更合适。"]}),"\n",(0,a.jsxs)(n.h2,{id:"谈原型模式其实是谈原型范式",children:["谈原型模式，其实是谈原型范式",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#谈原型模式其实是谈原型范式",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["原型编程范式的核心思想就是",(0,a.jsx)(n.strong,{children:"利用实例来描述对象，用实例作为定义对象和继承的基础"}),"。在 JavaScript 中，原型编程范式的体现就是",(0,a.jsx)(n.strong,{children:"基于原型链的继承"}),"。这其中，对原型、原型链的理解是关键。"]}),"\n",(0,a.jsxs)(n.h3,{id:"原型",children:["原型",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["在 JavaScript 中，每个构造函数都拥有一个",(0,a.jsx)(n.code,{children:"prototype"}),"属性，它指向构造函数的原型对象，这个原型对象中有一个 constructor 属性指回构造函数；每个实例都有一个",(0,a.jsx)(n.code,{children:"__proto__"}),"属性，当我们使用构造函数去创建实例时，实例的",(0,a.jsx)(n.code,{children:"__proto__"}),"属性就会指向构造函数的原型对象。\n具体来说，当我们这样使用构造函数创建一个对象时："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// 创建一个Dog构造函数\nfunction Dog(name, age) {\n  this.name = name\n  this.age = age\n}\nDog.prototype.eat = function() {\n  console.log('肉骨头真好吃')\n}\n// 使用Dog构造函数创建dog实例\nconst dog = new Dog('旺财', 3)\n"})}),"\n",(0,a.jsx)(n.p,{children:"这段代码里的几个实体之间就存在着这样的关系："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsxs)(n.h3,{id:"原型链",children:["原型链",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"现在我在上面那段代码的基础上，进行两个方法调用:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'// 输出"肉骨头真好吃"\ndog.eat()\n// 输出"[object Object]"\ndog.toString()\n'})}),"\n",(0,a.jsx)(n.p,{children:"明明没有在 dog 实例里手动定义 eat 方法和 toString 方法，它们还是被成功地调用了。这是因为当我试图访问一个 JavaScript 实例的属性/方法时，它首先搜索这个实例本身；当发现实例没有定义对应的属性/方法时，它会转而去搜索实例的原型对象；如果原型对象中也搜索不到，它就去搜索原型对象的原型对象，这个搜索的轨迹，就叫做原型链。"}),"\n",(0,a.jsx)(n.p,{children:"以我们的 eat 方法和 toString 方法的调用过程为例，它的搜索过程就是这样子的："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:s,alt:""})}),"\n",(0,a.jsxs)(n.p,{children:["楼上这些彼此相连的",(0,a.jsx)(n.code,{children:"prototype"}),"，就组成了一个原型链。 注： 几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例，除了",(0,a.jsx)(n.code,{children:"Object.prototype"}),"（当然，如果我们手动用",(0,a.jsx)(n.code,{children:"Object.create(null)"}),"创建一个没有任何原型的对象，那它也不是 Object 的实例）。"]}),"\n",(0,a.jsxs)(n.p,{children:["以上为大家介绍了原型、原型链等 JavaScript 中核心的基础知识。这些不仅是基础中的基础，也是面试中的重点。此外在面试中，一些面试官可能会刻意混淆 JavaScript 中原型范式和强类型语言中原型模式的区别，当他们这么做的时候不一定是因为对语言、对设计模式的理解有问题，而很有可能是为了考察你",(0,a.jsx)(n.strong,{children:"对象的深拷贝"}),"。"]}),"\n",(0,a.jsxs)(n.h3,{id:"对象的深拷贝",children:["对象的深拷贝",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象的深拷贝",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"这类题目的发问方式又很多，除了“模拟 JAVA 中的克隆接口”、“JavaScript 实现原型模式”以外，它更常见、更友好的发问形式是“请实现JS中的深拷贝”。"}),"\n",(0,a.jsx)(n.p,{children:"实现 JavaScript 中的深拷贝，有一种非常取巧的方式 —— JSON.stringify："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const liLei = {\n    name: 'lilei',\n    age: 28,\n    habits: ['coding', 'hiking', 'running']\n}\nconst liLeiStr = JSON.stringify(liLei)\nconst liLeiCopy = JSON.parse(liLeiStr)\nliLeiCopy.habits.splice(0, 1) \nconsole.log('李雷副本的habits数组是', liLeiCopy.habits)\nconsole.log('李雷的habits数组是',  liLei.habits)\n"})}),"\n",(0,a.jsx)(n.p,{children:"丢进控制台检验一下，我们发现引用类型也被成功拷贝了，副本和本体相互不干扰，正合我意~"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)("img",{src:c,alt:""}),"\n但是注意，这个方法存在一些局限性，比如无法处理 function、无法处理正则等等——只有当你的对象是一个严格的 JSON 对象时，可以顺利使用这个方法。在面试过程中，大家答出这个答案没有任何问题，但不要仅仅答这一种做法。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"深拷贝没有完美方案，每一种方案都有它的边界 case"}),"。而面试官向你发问也并非是要求你破解人类未解之谜，多数情况下，他只是希望考查你对",(0,a.jsx)(n.strong,{children:"递归"}),"的熟练程度。所以递归实现深拷贝的核心思路，大家需要重点掌握（解析在注释里）："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"function deepClone(obj) {\n    // 如果是 值类型 或 null，则直接return\n    if(typeof obj !== 'object' || obj === null) {\n        return obj\n    }\n    \n    // 定义结果对象\n    let copy = {}\n    \n    // 如果对象是数组，则定义结果数组\n    if(obj.constructor === Array) {\n        copy = []\n    }\n    \n    // 遍历对象的key\n    for(let key in obj) {\n        // 如果key是对象的自有属性\n        if(obj.hasOwnProperty(key)) {\n            // 递归调用深拷贝方法\n            copy[key] = deepClone(obj[key])\n        }\n    }\n    \n    return copy\n} \n"})}),"\n",(0,a.jsx)(n.p,{children:"调用深拷贝方法，若属性为值类型，则直接返回；若属性为引用类型，则递归遍历。这就是我们在解这一类题时的核心的方法。"}),"\n",(0,a.jsxs)(n.h3,{id:"拓展阅读",children:["拓展阅读",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#拓展阅读",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"深拷贝在命题时，可发挥的空间主要在于针对不同数据结构的处理，比如除了考虑 Array、Object，还需要考虑一些其它的数据结构（Map、Set 等）；此外还有一些极端 case（循环引用等）的处理等等。深拷贝的实现细节，这里为大家推荐两个阅读材料："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/jquery/jquery/blob/1472290917f17af05e98007136096784f9051fab/src/core.js#L121",target:"_blank",rel:"noopener noreferrer",children:"jQuery中的extend方法源码"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://segmentfault.com/a/1190000016672263",target:"_blank",rel:"noopener noreferrer",children:"深拷贝的终极探索"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"想要在深拷贝这一命题上拿高分的同学，不妨点开一看，相信你的收获会比你想象中更多~"}),"\n",(0,a.jsx)(n.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}let l=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["JavaScript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F7.%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%9A%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B0%88Prototype%E6%97%A0%E5%B0%8F%E4%BA%8B.md"]={toc:[{text:"以类为中心的语言和以原型为中心的语言",id:"以类为中心的语言和以原型为中心的语言",depth:2},{text:"Java 中的类",id:"java-中的类",depth:3},{text:"JavaScript 中的“类”",id:"javascript-中的类",depth:3},{text:"谈原型模式，其实是谈原型范式",id:"谈原型模式其实是谈原型范式",depth:2},{text:"原型",id:"原型",depth:3},{text:"原型链",id:"原型链",depth:3},{text:"对象的深拷贝",id:"对象的深拷贝",depth:3},{text:"拓展阅读",id:"拓展阅读",depth:3}],title:"7.创建型：原型模式——谈Prototype无小事",headingTitle:"7.创建型：原型模式——谈Prototype无小事",frontmatter:{}}}}]);