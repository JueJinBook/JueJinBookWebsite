"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["9093"],{718384:function(e,n,r){e.exports=r.p+"static/image/854ef10194b83ca1aba5d67cf7d7a271.27e6ead8.webp"},910761:function(e,n,r){e.exports=r.p+"static/image/ab7aae78dc0503e9fb2c8111e67e57d2.116d14c3.webp"},245423:function(e,n,r){e.exports=r.p+"static/image/af9589a57317e5dd227a71d9dc94136f.68aa0ed8.webp"},112131:function(e,n,r){e.exports=r.p+"static/image/b165c1da7b89bf93e102427529d6f16d.8b0a8763.webp"},738923:function(e,n,r){r.r(n),r.d(n,{default:()=>b});var s=r(552676),a=r(740453);let i=r.p+"static/image/8ef4434493b10f3519ae93d9c3cc0f5c.d01d48d4.webp",d=r.p+"static/image/dea94bd087c4d75aa9a934f7a6e518c9.2ff5d4e2.webp",c=r.p+"static/image/8b00e6ad9d2a4da4d1009b348603236b.044d7390.webp",t=r.p+"static/image/846a8b3738d9cd8a5857262907335094.174f25b1.webp",p=r.p+"static/image/47ea76f1c87f7bcf94e0d53999f7138e.f2513868.webp",h=r.p+"static/image/8617365094775c366c785f6fbe52549c.9d704c71.webp",l=r.p+"static/image/4cc01a4d87bf1c6cca523b8604ab4665.18534a1a.webp",x=r.p+"static/image/7dbc45380597dc3e901603f2136f31f5.fbce2aa0.webp";var g=r(245423),A=r(910761);let j=r.p+"static/image/6545f2c19f412e9b1503b54b461345a9.ac4640d3.webp";var y=r(112131),m=r(718384);let u=r.p+"static/image/93e9c3de2a1cbc9b366bb53c0603288d.bfa2d031.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",pre:"pre",code:"code",img:"img",h3:"h3"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"11类型体操顺口溜",children:["11.类型体操顺口溜",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11类型体操顺口溜",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 类型编程难么？"}),"\n",(0,s.jsx)(n.p,{children:"难。不然怎么会被叫做类型体操呢。"}),"\n",(0,s.jsx)(n.p,{children:"但其实类型体操是有套路的，我把类型体操的各种套路总结成了一个顺口溜："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"类型体操顺口溜"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"模式匹配做提取，重新构造做变换。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"递归复用做循环，数组长度做计数。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"联合分散可简化，特殊特性要记清。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"基础扎实套路熟，类型体操可通关。"})}),"\n",(0,s.jsx)(n.p,{children:"逐句解释下："}),"\n",(0,s.jsxs)(n.h2,{id:"模式匹配做提取",children:["模式匹配做提取",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模式匹配做提取",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"就像字符串可以通过正则提取子串一样，TypeScript 的类型也可以通过匹配一个模式类型来提取部分类型到 infer 声明的局部变量中返回。"}),"\n",(0,s.jsx)(n.p,{children:"比如提取函数类型的返回值类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type GetReturnType<Func extends Function> = \n    Func extends (...args: any[]) => infer ReturnType \n        ? ReturnType \n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"重新构造做变换",children:["重新构造做变换",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重新构造做变换",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 类型系统可以通过 type 声明类型变量，通过 infer 声明局部变量，类型参数在类型编程中也相当于局部变量，但是它们都不能做修改，想要对类型做变换只能构造一个新的类型，在构造的过程中做过滤和转换。"}),"\n",(0,s.jsx)(n.p,{children:"在字符串、数组、函数、索引等类型都有很多应用，特别是索引类型。"}),"\n",(0,s.jsx)(n.p,{children:"比如把索引变为大写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type UppercaseKey<Obj extends Record<string, any>> = { \n    [Key in keyof Obj as Uppercase<Key & string>]: Obj[Key]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"递归复用做循环",children:["递归复用做循环",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#递归复用做循环",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 TypeScript 类型编程中，遇到数量不确定问题时，就要条件反射的想到递归，每次只处理一个类型，剩下的放到下次递归，直到满足结束条件，就处理完了所有的类型。"}),"\n",(0,s.jsx)(n.p,{children:"比如把长度不确定的字符串转为联合类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type StringToUnion<Str extends string> = \n    Str extends `${infer First}${infer Rest}`\n        ? First | StringToUnion<Rest>\n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"数组长度做计数",children:["数组长度做计数",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数组长度做计数",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 类型系统没有加减乘除运算符，但是可以构造不同的数组再取 length 来得到相应的结果。这样就把数值运算转为了数组类型的构造和提取。"}),"\n",(0,s.jsx)(n.p,{children:"比如实现减法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type BuildArray<\n    Length extends number, \n    Ele = unknown, \n    Arr extends unknown[] = []\n> = Arr['length'] extends Length \n        ? Arr \n        : BuildArray<Length, Ele, [...Arr, Ele]>;\n\ntype Subtract<Num1 extends number, Num2 extends number> = \n    BuildArray<Num1> extends [...arr1: BuildArray<Num2>, ...arr2: infer Rest]\n        ? Rest['length']\n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"联合分散可简化",children:["联合分散可简化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#联合分散可简化",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 对联合类型做了特殊处理，当遇到字符串类型或者作为类型参数出现在条件类型左边的时候，会分散成单个的类型传入做计算，最后把计算结果合并为联合类型。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type UppercaseA<Item extends string> = \n    Item extends 'a' ?  Uppercase<Item> : Item;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样虽然简化了类型编程，但也带来了一些认知负担。"}),"\n",(0,s.jsx)(n.p,{children:"比如联合类型的判断是这样的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type IsUnion<A, B = A> =\n    A extends A\n        ? [B] extends [A]\n            ? false\n            : true\n        : never\n"})}),"\n",(0,s.jsx)(n.p,{children:"联合类型做为类型参数直接出现在条件类型左边的时候就会触发 distributive 特性，而不是直接出现在左边的时候不会。"}),"\n",(0,s.jsx)(n.p,{children:"所以， A 是单个类型、B 是整个联合类型。通过比较 A 和 B 来判断联合类型。"}),"\n",(0,s.jsxs)(n.h2,{id:"特殊特性要记清",children:["特殊特性要记清",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#特殊特性要记清",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"会了提取、构造、递归、数组长度计数、联合类型分散这 5 个套路以后，各种类型体操都能写，但是有一些特殊类型的判断需要根据它的特性来，所以要重点记一下这些特性。"}),"\n",(0,s.jsx)(n.p,{children:"比如 any 和任何类型的交叉都为 any，可以用来判断 any 类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type IsAny<T> = 'dong' extends ('guang' & T) ? true : false\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"比如索引一般是 string，而可索引签名不是，可以根据这个来过滤掉可索引签名："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type RemoveIndexSignature<Obj extends Record<string, any>> = {\n  [\n      Key in keyof Obj \n          as Key extends `${infer Str}`? Str : never\n  ]: Obj[Key]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"基础扎实套路熟类型体操可通关",children:["基础扎实套路熟，类型体操可通关",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基础扎实套路熟类型体操可通关",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"基础指的是 TypeScript 类型系统中的各种类型，以及可以对它们做的各种类型运算逻辑，这是类型编程的原材料。"}),"\n",(0,s.jsx)(n.p,{children:"但是只是会了基础不懂一些套路也很难做好类型编程，所以要熟悉上面 6 种套路。"}),"\n",(0,s.jsx)(n.p,{children:"基础扎实、套路也熟了之后，各种类型编程问题都可以搞定，也就是“通关”。"}),"\n",(0,s.jsxs)(n.h2,{id:"练练手",children:["练练手",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#练练手",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在讲 “TypeScript 类型编程为什么被叫做类型体操” 的时候我举了一个 ParseQueryString 的类型例子，用来说明类型编程的复杂度。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"学完了所有套路之后，我们来实现下这个类型："}),"\n",(0,s.jsxs)(n.h3,{id:"parsequerystring",children:["ParseQueryString",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#parsequerystring",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"a=1&b=2&c=3&d=4，这样的字符串明显是 query param 个数不确定的，遇到数量不确定的问题，条件反射的就要想到递归："}),"\n",(0,s.jsx)(n.p,{children:"递归解析出每一个 query params，也就是 & 分隔的每个字符串，每个字符串单独去解析，构造成索引类型，最后把这些所有的单个索引类型合并就行。"}),"\n",(0,s.jsx)(n.p,{children:"也就是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"第一步并不知道有多少个 a=1、b=2 这种 query param，要递归的做模式匹配来提取。"}),"\n",(0,s.jsx)(n.p,{children:"然后每一个 query param 再通过模式匹配取出 key 和 value，构造成索引类型。"}),"\n",(0,s.jsx)(n.p,{children:"然后把每个索引类型合并成一个大的索引类型就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"思路理清了，我们一步步来实现下。"}),"\n",(0,s.jsx)(n.p,{children:"首先，要递归的提取 & 分隔的 query param："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ParseQueryString<Str extends string> = \n    Str extends `${infer Param}&${infer Rest}`\n        ? MergeParams<ParseParam<Param>, ParseQueryString<Rest>>\n        : ParseParam<Str>;\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Str 为待处理的 query 字符串，通过 extends 约束为 string 类型。"}),"\n",(0,s.jsx)(n.p,{children:"提取 & 分割的字符串到 infer 声明的局部变量 Param 里，后面的字符串放到 Rest 里。"}),"\n",(0,s.jsx)(n.p,{children:"通过 ParseParam 来处理单个的 query param，剩下 query 字符串也是一样的递归处理，然后把这些处理结果合并到一起，也就是 MergeParams。"}),"\n",(0,s.jsx)(n.p,{children:"当提取不出 & 分割的字符串时递归结束，把剩下的字符串也用 ParseParam 来处理。"}),"\n",(0,s.jsx)(n.p,{children:"ParseParam 的实现就是提取和构造："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ParseParam<Param extends string> = \n    Param extends `${infer Key}=${infer Value}`\n        ? {\n            [K in Key]: Value \n        } : {};\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Param 类单个的 query param，比如 a=1 这种。"}),"\n",(0,s.jsx)(n.p,{children:"通过模式匹配提取 key 和 value 到 infer 声明的局部变量 Key、Value 里。"}),"\n",(0,s.jsx)(n.p,{children:"通过映射类型语法构造成索引类型返回："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBACghgJwM4XguBbAPGzUIAewEAdgCZJRLAICWJA5gHxQC8UAUFN7InocXKUABgBIA3vQBmEBFADSEEAF9WE6bKgA1OABsArhGXCuPMwH4o402dtQA2vKj0FSgLoAubXsOc73ZSgvcWUAbg4OUEheZFQ+DAAlCCR9XWA2GJRcbAByOFYARhymUKA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(n.p,{children:"每个 query param 处理完了，最后把这一系列构造出的索引类型合并成一个就行了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这也是构造索引类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type MergeParams<\n    OneParam extends Record<string, any>,\n    OtherParam extends Record<string, any>\n> = {\n  [Key in keyof OneParam | keyof OtherParam]: \n    Key extends keyof OneParam\n        ? Key extends keyof OtherParam\n            ? MergeValues<OneParam[Key], OtherParam[Key]>\n            : OneParam[Key]\n        : Key extends keyof OtherParam \n            ? OtherParam[Key] \n            : never\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 OneParam、OtherParam 是要合并的 query param，约束为索引类型（索引为 string，索引值为任意类型。"}),"\n",(0,s.jsx)(n.p,{children:"构造一个新的索引类型返回，索引来自两个的合并，也就是 Key in keyof OneParam | keyof OtherParam。"}),"\n",(0,s.jsx)(n.p,{children:"值也要做合并："}),"\n",(0,s.jsx)(n.p,{children:"如果两个索引类型中都有，那就合并成一个，也就是 MergeValues<OneParam[Key], OtherParam[Key]>。"}),"\n",(0,s.jsx)(n.p,{children:"否则，如果是 OneParam 中的，就取 OneParam[Key]，如果是 OtherParam 中的，就取 OtherParam[Key]。"}),"\n",(0,s.jsx)(n.p,{children:"MegeValues 的合并逻辑就是如果两个值是同一个就返回一个，否则构造一个数组类型来合并："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type MergeValues<One, Other> = \n    One extends Other \n        ? One\n        : Other extends unknown[]\n            ? [One, ...Other]\n            : [One, Other];\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 One、Other 是要合并的两个值。"}),"\n",(0,s.jsx)(n.p,{children:"如果两者是同一个类型，也就是 One extends Other，就返回任意一个。"}),"\n",(0,s.jsx)(n.p,{children:"否则，如果是数组就做数组合并，否则构造一个数组把两个类型放进去。"}),"\n",(0,s.jsx)(n.p,{children:"我们单独测试下索引合并："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAshBOBzCA1AhgGwK4QM4B4B5AOwgBopDgALBAPigF4oAoKdy0qCAD2AmIATXJRoJWHSVAD8nCGynsAXKNrxufAcKhZiAa2IB7AO7EA2gF0FiybLMlyUAHQuqaqzakr7pCm4QWANwsLKCQsAjIAApo8GgAtgTWcjFx8Rr8QiIAShAAxobwgvi4wPAAlsSIFGjEIHRkyf7wqQkZWjn5hcWlFVU1dXQsDMwA3gpmANIQIFCVUHozhgBmKbFtAD4LS6vNrfEWKsnTs7yZ2osgK2tpybZQJ+1Z21e7Yi3r8Xc2snBIqJgcAQHPspjMLH53qCThYhp5JCoQZ8wSAPDYVI8zh0Xtc9p8JPD2LI8WkURYCYSVKQAG4IFgAXxCYWgf2in1wuVwWAwwCYEX++wIoygaBUAEYoPSKMKAEYqABMkrowRCQA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(n.p,{children:"每个 query param 的解析和构造索引类型，多个索引类型的合并都实现了，合并起来也就实现了 query string 的解析："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ParseQueryString<Str extends string> = \n    Str extends `${infer Param}&${infer Rest}`\n        ? MergeParams<ParseParam<Param>, ParseQueryString<Rest>>\n        : ParseParam<Str>;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBACghgJwM4XguBbAPGzUIAewEAdgCZJRLAICWJA5gHxQC8UAUFN7InocXKUABgBIA3vQBmEBFADSEEAF9WE6bKgA1OABsArhGXCuPMwH4o402dtQA2vKj0FSgLoAubXsOc73ZSgvcWUAbg4OUEgoAFlZBggdAwgkLAB5EggAGig04AALWRZ2G1zM-CJSClyCzVKLMoh6ni88wrkBKsp9EgBrEgB7AHcSezdmu0t7DOyoADoFttlx-1svacycpYQ3cMjwaDiEBNwMVNKZ04rBaoAlCABjAYQyLGo6Rhy4EhAmLIvaggrp0hFB7k8Xm8aPQGF8fkwOMUrKZHEpnCQoL0lAMpI0rgAfTHY3HbU6ePw8RQga5dIkgHF4vgYCZQSxUmmgrH0kmA04shpHBJJQypS5M1EgNxbXniqluBGrMytTKnCUrfxedkg6pchmkpkUxWsmrtVVyw2KryZABusg4ygiUWgaBQAEVDAgQABlaGMLA+jqVUHvGFI0oBjnVMSSEgyOSnZQAMnUsc092oxhZlkFqCZqRdufQ2FOf14yAg7tk3t9DCw6eATAVGrLKFO-poTD2+2iBcrnoDMPT+l0wDYLYrHurH1rAHI4KwAIyJ+cAJkTACNWGuHqwAMwzzsRDhAA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsxs)(n.p,{children:["在实现 ParseQueryString 的类型的时候，我们大量用到了",(0,s.jsx)(n.code,{children:"模式匹配做提取"}),"、",(0,s.jsx)(n.code,{children:"重新构造做变换"}),"、",(0,s.jsx)(n.code,{children:"递归复用做循环"}),"这 3 大套路，思路理清之后利用这些套路能够很顺畅的把这个高级类型写出来。"]}),"\n",(0,s.jsx)(n.p,{children:"这是最开始被我用来说明类型编程复杂度的例子，是有一定复杂度的，而学到这我们也能实现了。"}),"\n",(0,s.jsx)(n.p,{children:"再回到最开始的问题："}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 类型编程难么？"}),"\n",(0,s.jsx)(n.p,{children:"其实熟悉一些套路以后，也没那么难。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"为了方便记忆，我总结了类型体操顺口溜，然后分别解释了每句话的含义，之后又做了一个类型体操来练手。"}),"\n",(0,s.jsx)(n.p,{children:"那个最开始被我用来说明 TypeScript 类型编程复杂度的例子，现在我们也能顺畅的实现了，所用的就是类型体操顺口溜中的套路。"}),"\n",(0,s.jsx)(n.p,{children:"这就像武功秘籍一样，理解了每句话的含义，反复修炼，就能成为类型体操的武林高手："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"模式匹配做提取，重新构造做变换。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"递归复用做循环，数组长度做计数。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"联合分散可简化，特殊特性要记清。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"基础扎实套路熟，类型体操可通关。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBACghgJwM4XguBbAPGzUIAewEAdgCZJRLAICWJA5gHxQC8UAUFN7InocXKUABgBIA3vQBmEBFADSEEAF9WE6bKgA1OABsArhGXCuPMwH4o402dtQA2vKj0FSgLoAubXsOc73ZSgvcWUAbg4OUEheZFQ+DAAlCCR9XWA2GJRcbAByOFYARhymcMjwaABZWQYIHQNkrAB5EggAGihG4AALWRZ2Gw6W-CJSCg7uzQGLQYgpni9OnrkBUcp9EgBrEgB7AHcSezc5u0t7ZraoADprxdkj-1svM5b224Q3UqjK6rj0DCQsANztlhoIxkkAMbbBBkLDUOiMdpwEggJitIETBAglZCKCQ6Gw+H0BhIlFMDh9KymRxKZwkKAbJTbKQzEEAHwZTJZb2ynj8PEUIFBq05IGZrPixyglkFwtxjLF3Mx2Sl0yqCBqdUMAOB8RpIDcr2VesFbnJDzMCxa2X1938XllOLGCvFPPi-It0vGSxtpo9Fq8LQAbrIOMoIl8oOqatkkEkUmkMtHfpgAeIoHAvAUoMp2umAEZeABMOZKEfKmQgAEVDAgQABlGjErCN5YjXFExiUgatuVjMSSEgyOTZZQAMnUQ808eAxillmTsZwiCy8WXfzRlZrsgbTcYWBnTHN9sr2RbNDL5eiaBQ27rreJ8dS6XYN+rtd3CIYWDyhTH+SLMd81YQCIVYABmYpSg4IA",target:"_blank",rel:"noopener noreferrer",children:"本文案例的合并"})})]})}function B(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}let b=B;B.__RSPRESS_PAGE_META={},B.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F11.%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%A1%BA%E5%8F%A3%E6%BA%9C.md"]={toc:[{text:"模式匹配做提取",id:"模式匹配做提取",depth:2},{text:"重新构造做变换",id:"重新构造做变换",depth:2},{text:"递归复用做循环",id:"递归复用做循环",depth:2},{text:"数组长度做计数",id:"数组长度做计数",depth:2},{text:"联合分散可简化",id:"联合分散可简化",depth:2},{text:"特殊特性要记清",id:"特殊特性要记清",depth:2},{text:"基础扎实套路熟，类型体操可通关",id:"基础扎实套路熟类型体操可通关",depth:2},{text:"练练手",id:"练练手",depth:2},{text:"ParseQueryString",id:"parsequerystring",depth:3},{text:"总结",id:"总结",depth:2}],title:"11.类型体操顺口溜",headingTitle:"11.类型体操顺口溜",frontmatter:{}}}}]);