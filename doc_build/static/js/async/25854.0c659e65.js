"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["25854"],{546761:function(e,n,i){i.r(n),i.d(n,{default:()=>o});var s=i(552676),d=i(740453);function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"28拓展-7妙手仁心--优雅地使用-jedis",children:["28拓展 7：妙手仁心 —— 优雅地使用 Jedis",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#28拓展-7妙手仁心--优雅地使用-jedis",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本节面向 Java 用户，主题是如何优雅地使用 Jedis 编写应用程序，既可以让代码看起来赏心悦目，又可以避免使用者犯错。"}),"\n",(0,s.jsx)(n.p,{children:"Jedis 是 Java 用户最常用的 Redis 开源客户端。它非常小巧，实现原理也很简单，最重要的是很稳定，而且使用的方法参数名称和官方的文档非常 match，如果有什么方法不会用，直接参考官方的指令文档阅读一下就会了，省去了非必要的重复学习成本。不像有些客户端把方法名称都换了，虽然表面上给读者带来了便捷，但是需要挨个重新学习这些 API，提高了学习成本。"}),"\n",(0,s.jsx)(n.p,{children:"Java 程序一般都是多线程的应用程序，意味着我们很少直接使用 Jedis，而是要用到 Jedis 的连接池 —— JedisPool。同时因为 Jedis 对象不是线程安全的，当我们要使用 Jedis 对象时，需要从连接池中拿出一个 Jedis 对象独占，使用完毕后再将这个对象还给连接池。"}),"\n",(0,s.jsx)(n.p,{children:"用代码表示如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class JedisTest {\n\n  public static void main(String[] args) {\n    JedisPool pool = new JedisPool();\n    Jedis jedis = pool.getResource(); // 拿出 Jedis 链接对象\n    doSomething(jedis);\n    jedis.close(); // 归还链接\n  }\n\n  private static void doSomething(Jedis jedis) {\n    // code it here\n  }\n\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上面的代码有个问题，如果 ",(0,s.jsx)(n.code,{children:"doSomething"})," 方法抛出了异常的话，从连接池中拿出来的 Jedis 对象将无法归还给连接池。如果这样的异常发生了好几次，连接池中的所有链接都被持久占用了，新的请求过来时就会阻塞等待空闲的链接，这样的阻塞一般会直接导致应用程序卡死。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了避免这种情况的发生，程序员需要在使用 JedisPool 里面的 Jedis 链接时，应该使用 ",(0,s.jsx)(n.code,{children:"try-with-resource"})," 语句来保护 Jedis 对象。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class JedisTest {\n\n  public static void main(String[] args) {\n    JedisPool pool = new JedisPool();\n    try (Jedis jedis = pool.getResource()) { // 用完自动 close\n      doSomething(jedis);\n    }\n  }\n\n  private static void doSomething(Jedis jedis) {\n    // code it here\n  }\n\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样 Jedis 对象肯定会归还给连接池 (死循环除外)，避免应用程序卡死的惨剧发生。"}),"\n",(0,s.jsxs)(n.p,{children:["但是当一个团队够大的时候，并不是所有的程序员都会非常有经验，他们可能因为各种原因忘记了使用 ",(0,s.jsx)(n.code,{children:"try-with-resource"})," 语句，惨剧就会突然冒出来让运维人员措手不及。我们需要在代码上加上一层硬约束，通过这层约束，当程序员想要访问 Jedis 对象时，不会再出现使用了 Jedis 对象而不归还。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"import redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\ninterface CallWithJedis {\n  public void call(Jedis jedis);\n}\n\nclass RedisPool {\n\n  private JedisPool pool;\n\n  public RedisPool() {\n    this.pool = new JedisPool();\n  }\n\n  public void execute(CallWithJedis caller) {\n    try (Jedis jedis = pool.getResource()) {\n      caller.call(jedis);\n    }\n  }\n\n}\n\npublic class JedisTest {\n\n  public static void main(String[] args) {\n    RedisPool redis = new RedisPool();\n    redis.execute(new CallWithJedis() {\n\n      @Override\n      public void call(Jedis jedis) {\n        // do something with jedis\n      }\n\n    });\n  }\n\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们通过一个特殊的自定义的 RedisPool 对象将 JedisPool 对象隐藏起来，避免程序员直接使用它的 ",(0,s.jsx)(n.code,{children:"getResource"})," 方法而忘记了归还。程序员使用 RedisPool 对象时需要提供一个回调类来才能使用 Jedis 对象。"]}),"\n",(0,s.jsx)(n.p,{children:"但是每次访问 Redis 都需要写一个回调类，真是特别繁琐，代码也显得非常臃肿。幸好 Java8 带来了 Lambda 表达式，我们可以使用 Lambda 表达式简化上面的代码。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public class JedisTest {\n\n  public static void main(String[] args) {\n    Redis redis = new Redis();\n    redis.execute(jedis -> {\n      // do something with jedis\n    });\n  }\n\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样看起来就简洁优雅多了。但是还有个问题，Java 不允许在闭包里修改闭包外面的变量。比如下面的代码，我们想从 Redis 里面拿到某个 zset 对象的长度，编译器会直接报错。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'public class JedisTest {\n\n  public static void main(String[] args) {\n    Redis redis = new Redis();\n    long count = 0;\n    redis.execute(jedis -> {\n      count = jedis.zcard("codehole");  // 此处应该报错\n    });\n    System.out.println(count);\n  }\n\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["编译器暴露出来的错误时：",(0,s.jsx)(n.code,{children:"Local variable count defined in an enclosing scope must be final or effectively final"}),"，告诉我们 count 变量必须设置成 final 类型才可以让闭包来访问。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果这时我们将 count 设置成 final 类型，结果编辑器又报错了：",(0,s.jsx)(n.code,{children:"The final local variable count cannot be assigned. It must be blank and not using a compound assignment"}),"，告诉我们 final 类型的变量在闭包里面不能被修改。"]}),"\n",(0,s.jsx)(n.p,{children:"那该怎么办呢？"}),"\n",(0,s.jsx)(n.p,{children:"这里需要定义一个 Holder 类型，将需要修改的变量包装起来。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'class Holder<T> {\n  private T value;\n\n  public Holder() {\n  }\n\n  public Holder(T value) {\n    this.value = value;\n  }\n\n  public void value(T value) {\n    this.value = value;\n  }\n\n  public T value() {\n    return value;\n  }\n}\n\npublic class JedisTest {\n\n  public static void main(String[] args) {\n    Redis redis = new Redis();\n    Holder<Long> countHolder = new Holder<>();\n    redis.execute(jedis -> {\n      long count = jedis.zcard("codehole");\n      countHolder.value(count);\n    });\n    System.out.println(countHolder.value());\n  }\n\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"有了上面定义的 Holder 包装类，就可以绕过闭包对变量修改的限制。只不过代码上要多一层略显繁琐的变量包装过程。这些都是对程序员的硬约束，他们必须这么做才可以得到自己想要的数据。"}),"\n",(0,s.jsxs)(n.h2,{id:"重试",children:["重试",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重试",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们知道 Jedis 默认没有提供重试机制，意味着如果网络出现了抖动，就会大范围报错，或者一个后台应用因为链接过于空闲被服务端强制关闭了链接，当重新发起新请求时就第一个指令会出错。而 Redis 的 Python 客户端 redis-py 提供了这种重试机制，redis-py 在遇到链接错误时会尝试进行重连，然后再重发指令。"}),"\n",(0,s.jsx)(n.p,{children:"那如果我们希望在 Jedis 上面增加重试机制，该如何做呢？有了上面的 RedisPool 对象，重试就非常容易进行了。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"class Redis {\n\n  private JedisPool pool;\n\n  public Redis() {\n    this.pool = new JedisPool();\n  }\n\n  public void execute(CallWithJedis caller) {\n    Jedis jedis = pool.getResource();\n    try {\n      caller.call(jedis);\n    } catch (JedisConnectionException e) {\n      caller.call(jedis);  // 重试一次\n    } finally {\n      jedis.close();\n    }\n  }\n\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"上面的代码我们只重试了一次，如有需要也可以重试多次，但是也不能无限重试，就好比人逝不可复生，要节哀顺变。"}),"\n",(0,s.jsxs)(n.h2,{id:"作业",children:["作业",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#作业",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"囿于精力，以上代码并没有做到非常细致，比如 Redis 的链接参数都没有提及，连接池的大小以及超时参数等也没有配置，这些细节工作就留给读者们作为本节的作业，自己动手完成一个完善的封装吧。"})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}let o=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F28%E6%8B%93%E5%B1%95%207%EF%BC%9A%E5%A6%99%E6%89%8B%E4%BB%81%E5%BF%83%20%E2%80%94%E2%80%94%20%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%20Jedis.md"]={toc:[{text:"重试",id:"重试",depth:2},{text:"作业",id:"作业",depth:2}],title:"28拓展 7：妙手仁心 —— 优雅地使用 Jedis",headingTitle:"28拓展 7：妙手仁心 —— 优雅地使用 Jedis",frontmatter:{}}}}]);