"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["22616"],{799101:function(e,n,c){c.r(n),c.d(n,{default:()=>V});var d=c(552676),s=c(740453);let i=c.p+"static/image/c7d01cb96a50adec5c7fb56a24821a8c.e245cffa.webp",r=c.p+"static/image/e9ac1e9509fd95d7374ca331ea539be3.f0130a7c.webp",h=c.p+"static/image/809fcc0c7fc02cdb7e6f8c943130aa51.2f0ec4f9.webp",l=c.p+"static/image/ea8607e293a9ff5538f72357c83abee1.d18b5e02.webp",a=c.p+"static/image/4dc1c9a88f557d932d800ce580b95156.11bb4c4f.webp",t=c.p+"static/image/89587757dde7e7c6a4995dd3972c83b0.c1ddcd07.webp",x=c.p+"static/image/d3407dad951281f26c74d0014dc4483a.b244a242.webp",j=c.p+"static/image/c12d152686d70a15547f5d880f52ac05.67836ab0.webp",o=c.p+"static/image/bce0b764a371eb61efa00ed46bf616fb.b2ca27be.webp",p=c.p+"static/image/fb9d354229c131bac17d9f140bdadf3f.04e918d9.webp",u=c.p+"static/image/03c3e29d7e0e407080cbd4062a506609.4f543640.webp",g=c.p+"static/image/f9fa7b3f81c4dd381407e1a0e4c5e1c3.4ccef46b.webp",m=c.p+"static/image/ef4d9ec97b55f8178e12c02f04b9c207.02b4f94a.webp",f=c.p+"static/image/6d98fa135ce686d24648070ce113017b.df5ce9d4.webp";function b(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",h4:"h4",pre:"pre",img:"img",strong:"strong",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"9vue3-性能和业务层面上的提升",children:["9.Vue3 性能和业务层面上的提升",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9vue3-性能和业务层面上的提升",children:"#"})]}),"\n",(0,d.jsxs)(n.h2,{id:"前言",children:["前言",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"人云亦云，并不会让你变得有多优秀，而会让你越来越随大流。"}),"\n",(0,d.jsxs)(n.p,{children:["当你和别的开发在聊到 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 有哪些亮点时，你的答案之一肯定有:"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["性能更好了，比 ",(0,d.jsx)(n.code,{children:"Vue 2"})," 快上 2.2 倍。"]}),"\n",(0,d.jsxs)(n.li,{children:["支持 ",(0,d.jsx)(n.code,{children:"Tree-shaking"}),"。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"本章节着重分析这两个亮点。"}),"\n",(0,d.jsxs)(n.h2,{id:"虚拟-dom-性能优化",children:["虚拟 DOM 性能优化",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#虚拟-dom-性能优化",children:"#"})]}),"\n",(0,d.jsxs)(n.h4,{id:"patchflag静态标记",children:["PatchFlag（静态标记）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#patchflag静态标记",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Vue 2"})," 中的虚拟 ",(0,d.jsx)(n.code,{children:"DOM"})," 是全量对比的模式，而到了 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 开始，新增了静态标记（PatchFlag）。在更新前的节点进行对比的时候，只会去对比带有静态标记的节点。并且 ",(0,d.jsx)(n.code,{children:"PatchFlag"})," 枚举定义了十几种类型，用以更精确的定位需要对比节点的类型。下面我们通过图文实例分析这个对比的过程。假设我们有下面一段代码："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-html",children:"<div>\n  <p>老八食堂</p>\n  <p>{{ message }}</p>\n</div>\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在 ",(0,d.jsx)(n.code,{children:"Vue 2"})," 的全量对比模式下，如下图所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:f,alt:"diff (2).png"})}),"\n",(0,d.jsxs)(n.p,{children:["通过上图，我们发现，",(0,d.jsx)(n.code,{children:"Vue 2"})," 的 ",(0,d.jsx)(n.code,{children:"diff"})," 算法将每个标签都比较了一次，最后发现带有 ",(0,d.jsx)(n.code,{children:"{{ message }}"}),"\xa0变量的标签是需要被更新的标签，显然这还有优化的空间。"]}),"\n",(0,d.jsxs)(n.p,{children:["在 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 中，对 ",(0,d.jsx)(n.code,{children:"diff"})," 算法进行了优化，在创建虚拟 ",(0,d.jsx)(n.code,{children:"DOM"})," 时，根据 ",(0,d.jsx)(n.code,{children:"DOM"})," 内容是否会发生变化，而给予相对应类型的静态标记（PatchFlag），如下图所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:m,alt:"diff (3).png"})}),"\n",(0,d.jsxs)(n.p,{children:["观察上图，不难发现视图的更新只对带有 ",(0,d.jsx)(n.code,{children:"flag"})," 标记的标签进行了对比（diff），所以只进行了 1 次比较，而相同情况下，",(0,d.jsx)(n.code,{children:"Vue 2"})," 则进行了 3 次比较。这便是 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 比 ",(0,d.jsx)(n.code,{children:"Vue 2"})," 性能好的第一个原因。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们再通过把模板代码转译成虚拟 ",(0,d.jsx)(n.code,{children:"DOM"}),"，来验证我们上述的分析是否正确。我们可以打开模板转化",(0,d.jsx)(n.a,{href:"https://vue-next-template-explorer.netlify.app/",target:"_blank",rel:"noopener noreferrer",children:"网站"}),"，对上述代码进行转译："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:g,alt:"laoba.png"})}),"\n",(0,d.jsxs)(n.p,{children:["上图蓝色框内为转译后的虚拟 ",(0,d.jsx)(n.code,{children:"DOM"})," 节点，第一个 ",(0,d.jsx)(n.code,{children:"p"})," 标签为写死的静态文字，而第二个 ",(0,d.jsx)(n.code,{children:"p"})," 标签则为绑定的变量，所以打上了 1 标签，代表的是 ",(0,d.jsx)(n.code,{children:"TEXT"}),"（文字），标记枚举类型如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"export const enum PatchFlags {\n  \n  TEXT = 1,// 动态的文本节点\n  CLASS = 1 << 1,  // 2 动态的 class\n  STYLE = 1 << 2,  // 4 动态的 style\n  PROPS = 1 << 3,  // 8 动态属性，不包括类名和样式\n  FULL_PROPS = 1 << 4,  // 16 动态 key，当 key 变化时需要完整的 diff 算法做比较\n  HYDRATE_EVENTS = 1 << 5,  // 32 表示带有事件监听器的节点\n  STABLE_FRAGMENT = 1 << 6,   // 64 一个不会改变子节点顺序的 Fragment\n  KEYED_FRAGMENT = 1 << 7, // 128 带有 key 属性的 Fragment\n  UNKEYED_FRAGMENT = 1 << 8, // 256 子节点没有 key 的 Fragment\n  NEED_PATCH = 1 << 9,   // 512\n  DYNAMIC_SLOTS = 1 << 10,  // 动态 solt\n  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作 diff\n  BAIL = -2 // 一个特殊的标志，指代差异算法\n}\n"})}),"\n",(0,d.jsxs)(n.h4,{id:"hoiststatic静态提升",children:["hoistStatic（静态提升）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hoiststatic静态提升",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"我们平时在开发过程中写函数的时候，定义一些写死的变量时，都会将变量提升出去定义，如下所示："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-javascript",children:"const PAGE_SIZE = 10\nfunction getData () {\n	$.get('/data', {\n  	data: {\n    	page: PAGE_SIZE\n    },\n    ...\n  })\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["诸如上述代码，如果将 ",(0,d.jsx)(n.code,{children:"PAGE_SIZE = 10"}),"\xa0写在 ",(0,d.jsx)(n.code,{children:"getData"}),"\xa0方法内，每次调用 ",(0,d.jsx)(n.code,{children:"getData"}),"\xa0都会重新定义一次变量。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Vue 3"})," 在这方面也做了同样的优化，继续用我们上一个例子写的代码，观察编译之后的虚拟 ",(0,d.jsx)(n.code,{children:"DOM"})," 结构，如下所示。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"没有做静态提升前："})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:u,alt:"hoist.png"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsxs)(n.strong,{children:["选择 Option 下的 ",(0,d.jsx)(n.code,{children:"hoistStatic"}),"："]})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:p,alt:"optionh.png"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"静态提升后："})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:o,alt:"hoist2.png"})}),"\n",(0,d.jsxs)(n.p,{children:["细心的同学会发现， ",(0,d.jsx)(n.code,{children:"老八食堂"}),"\xa0被提到了 ",(0,d.jsx)(n.code,{children:"render"}),"\xa0函数外，每次渲染的时候只要取 ",(0,d.jsx)(n.code,{children:"_hoisted_1"}),"\xa0变量便可。认真看文章的同学又会发现一个细节， ",(0,d.jsx)(n.code,{children:"_hoisted_1"}),"\xa0被打上了 ",(0,d.jsx)(n.code,{children:"PatchFlag"}),"\xa0，静态标记值为 -1 ，特殊标志是负整数表示永远不会用作 ",(0,d.jsx)(n.code,{children:"diff"}),"。也就是说被打上 -1 标记的，将不在参与 ",(0,d.jsx)(n.code,{children:"diff"})," 算法，这又提升了 ",(0,d.jsx)(n.code,{children:"Vue"})," 的性能。"]}),"\n",(0,d.jsxs)(n.h4,{id:"cachehandler事件监听缓存",children:["cacheHandler（事件监听缓存）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#cachehandler事件监听缓存",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["默认情况下 ",(0,d.jsx)(n.code,{children:"@click"}),"\xa0事件被认为是动态变量，所以每次更新视图的时候都会追踪它的变化。但是正常情况下，我们的 ",(0,d.jsx)(n.code,{children:"@click"}),"\xa0事件在视图渲染前和渲染后，都是同一个事件，基本上不需要去追踪它的变化，所以 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 对此作出了相应的优化叫 ",(0,d.jsx)(n.code,{children:"事件监听缓存"}),"，我们在上述代码中加一段："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-html",children:'<div>\n  <p @click="handleClick">屋里一giao</p>\n</div>\n'})}),"\n",(0,d.jsx)(n.p,{children:"编译后如下图所示（还未开启 cacheHandler）："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:j,alt:"giao.png"})}),"\n",(0,d.jsxs)(n.p,{children:["在未开启 ",(0,d.jsx)(n.code,{children:"事件监听缓存"})," 的情况下，我们看到这串代码编译后被静态标记为 8，之前讲解过被静态标记的标签就会被拉去做比较，而静态标记 8 对应的是“动态属性，不包括类名和样式”。 ",(0,d.jsx)(n.code,{children:"@click"}),"\xa0被认为是动态属性，所以我们需要开启 ",(0,d.jsx)(n.code,{children:"Options"})," 下的 ",(0,d.jsx)(n.code,{children:"cacheHandler"}),"\xa0属性，如下图所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:x,alt:"giao1.png"})}),"\n",(0,d.jsxs)(n.p,{children:["细心的同学又会发现，开启 ",(0,d.jsx)(n.code,{children:"cacheHandler"}),"\xa0之后，编译后的代码已经没有静态标记（PatchFlag），也就表明图中 ",(0,d.jsx)(n.code,{children:"p"})," 标签不再被追踪比较变化，进而提升了 ",(0,d.jsx)(n.code,{children:"Vue"})," 的性能。"]}),"\n",(0,d.jsxs)(n.h4,{id:"ssr-服务端渲染",children:["SSR 服务端渲染",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ssr-服务端渲染",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["当你在开发中使用 ",(0,d.jsx)(n.code,{children:"SSR"})," 开发时，",(0,d.jsx)(n.code,{children:"Vue 3"})," 会将静态标签直接转化为文本，相比 ",(0,d.jsx)(n.code,{children:"React"})," 先将 ",(0,d.jsx)(n.code,{children:"jsx"})," 转化为虚拟 ",(0,d.jsx)(n.code,{children:"DOM"}),"，再将虚拟 ",(0,d.jsx)(n.code,{children:"DOM"})," 转化为 ",(0,d.jsx)(n.code,{children:"HTML"}),"，",(0,d.jsx)(n.code,{children:"Vue 3"})," 已经赢了。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:t,alt:"ssr.jpg"})}),"\n",(0,d.jsxs)(n.h4,{id:"staticnode静态节点",children:["StaticNode（静态节点）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#staticnode静态节点",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["上述 ",(0,d.jsx)(n.code,{children:"SSR"})," 服务端渲染，会将静态标签直接转化为文本。在客户端渲染的时候，只要标签嵌套得足够多，编译时也会将其转化为 ",(0,d.jsx)(n.code,{children:"HTML"})," 字符串，如下图所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:a,alt:"staticnode.jpg"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"需要开启 Options 下的 hoistStatic"}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"tree-shaking",children:["Tree-shaking",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#tree-shaking",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["说到 ",(0,d.jsx)(n.code,{children:"Tree-shaking"})," 这个属于，官方的解释用大白话说就是，没有被应用到的代码，编译后自动将其剔除。"]}),"\n",(0,d.jsxs)(n.p,{children:["我个人是这么记住 ",(0,d.jsx)(n.code,{children:"Tree-shaking"})," 的，翻译成中文就是 ",(0,d.jsx)(n.code,{children:"摇树"}),"，树上有枯叶和绿叶，我摇动树干，枯叶掉了，新叶留着。这里的枯叶就是指没用到的代码，新叶指被应用到的代码，这么记就完全可以技术这个技术点。"]}),"\n",(0,d.jsxs)(n.p,{children:["在 ",(0,d.jsx)(n.code,{children:"Vue 2"})," 中，无论有没有用到全部的功能，这些功能的代码都会被打包到生产环境中。究其原因，主要还是怪 ",(0,d.jsx)(n.code,{children:"Vue 2"})," 生成实例是单例，这样打包的时候就无法检测到实例中的各个方法是否被引用到。如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import Vue from 'vue'\n\nVue.nextTick(() => {})\n"})}),"\n",(0,d.jsxs)(n.p,{children:["而 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 经过改良之后，引入了 ",(0,d.jsx)(n.code,{children:"Tree-shaking"})," 的特性，所有的方法通过模块化导入的形式。如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import { nextTick, onMounted } from 'vue'\n\nnextTick(() => {})\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"nextTick"})," 方法会被打进生产包，而 ",(0,d.jsx)(n.code,{children:"onMounted"})," 在代码里没有用到，最终不会出现在编译后的代码里。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Tree-shaking"})," 做了两件事："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["编译阶段利用 ",(0,d.jsx)(n.code,{children:"ES"})," 的模块化判断有哪些模块已经加载。"]}),"\n",(0,d.jsx)(n.li,{children:"判断哪些模块和变量，没有被使用或者引用到，从而删除对应的代码。"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["光看文字没有说服力，我们通过代码实例来演示一遍，通过 ",(0,d.jsx)(n.code,{children:"Vue CLI"})," 启动一个 ",(0,d.jsx)(n.code,{children:"Vue 2"})," 的项目，修改 ",(0,d.jsx)(n.code,{children:"App.vue"})," 如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{ test }}</div>\n</template>\n<script>\n  export default {\n    data() {\n      return {\n        test: '十三'\n      }\n    }\n  }\n<\/script>\n"})}),"\n",(0,d.jsxs)(n.p,{children:["运行打包指令 ",(0,d.jsx)(n.code,{children:"npm run build"}),"，打完包后体积如下："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:l,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["我们再加一个 ",(0,d.jsx)(n.code,{children:"Option"}),"，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{ test }}</div>\n</template>\n<script>\n  export default {\n    data() {\n      return {\n        test: '十三'\n      }\n    },\n    computed: {\n      testc: function () {\n        return this.test + '测试'\n      }\n    }\n  }\n<\/script>\n"})}),"\n",(0,d.jsxs)(n.p,{children:["再次运行 ",(0,d.jsx)(n.code,{children:"npm run build"}),"，如下所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:h,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"业务代码从 2.04 -> 2.10，而工具包还是 89.66。由此可见，增减代码，并不会影响工具包的打包大小。"}),"\n",(0,d.jsxs)(n.p,{children:["我们再来看看 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 的表现，通过 ",(0,d.jsx)(n.code,{children:"Vue CLI"})," 启动一个 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 的项目，",(0,d.jsx)(n.code,{children:"App.vue"})," 作如下修改："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{ state.test }}</div>\n</template>\n<script setup>\nimport { reactive } from 'vue'\nconst state = reactive({\n  test: '十三'\n})\n<\/script>\n"})}),"\n",(0,d.jsxs)(n.p,{children:["运行 ",(0,d.jsx)(n.code,{children:"npm run build"}),"，打包后，体积如下："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:r,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["我们加一个添加一个 ",(0,d.jsx)(n.code,{children:"computed"})," 方法，如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{ state.test }}</div>\n</template>\n<script>\nimport { reactive, computed } from 'vue'\nconst state = reactive({\n  test: '十三'\n})\n\nconst testc = computed(() => {\n  return state.test + '测试'\n})\n<\/script>\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:i,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["添加了 ",(0,d.jsx)(n.code,{children:"computed"})," 之后，可以看到，工具包的大小从 87.35 -> 87.39，变大了。也就是说，之前没有用到 ",(0,d.jsx)(n.code,{children:"computed"}),"，它是不会被打包到生产环境的工具包里的。"]}),"\n",(0,d.jsxs)(n.p,{children:["综上所述，",(0,d.jsx)(n.code,{children:"Vue 3"})," 的 ",(0,d.jsx)(n.code,{children:"Tree-shaking"})," 为我们带来了一下几个升级："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"减少打包后的静态资源体积"}),"\n",(0,d.jsx)(n.li,{children:"程序执行更快"}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"总结",children:["总结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["本章节我们分析了 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 在性能和业务能力上的重大改变，可以推测出，随着周边插件的升级，",(0,d.jsx)(n.code,{children:"Vue 3"})," 将很快被大众所接受，慢慢的会取代 ",(0,d.jsx)(n.code,{children:"Vue 2"})," 版本，包括市面上面试官的问题，也将会从 ",(0,d.jsx)(n.code,{children:"Vue 2"})," 相关迁移到 ",(0,d.jsx)(n.code,{children:"Vue 3"})," 相关。"]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"文档最近更新时间：2022 年 9 月 20 日。"}),"\n"]})]})}function E(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(b,{...e})}):b(e)}let V=E;E.__RSPRESS_PAGE_META={},E.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F9.Vue3%20%E6%80%A7%E8%83%BD%E5%92%8C%E4%B8%9A%E5%8A%A1%E5%B1%82%E9%9D%A2%E4%B8%8A%E7%9A%84%E6%8F%90%E5%8D%87.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"虚拟 DOM 性能优化",id:"虚拟-dom-性能优化",depth:2},{text:"PatchFlag（静态标记）",id:"patchflag静态标记",depth:4},{text:"hoistStatic（静态提升）",id:"hoiststatic静态提升",depth:4},{text:"cacheHandler（事件监听缓存）",id:"cachehandler事件监听缓存",depth:4},{text:"SSR 服务端渲染",id:"ssr-服务端渲染",depth:4},{text:"StaticNode（静态节点）",id:"staticnode静态节点",depth:4},{text:"Tree-shaking",id:"tree-shaking",depth:2},{text:"总结",id:"总结",depth:2}],title:"9.Vue3 性能和业务层面上的提升",headingTitle:"9.Vue3 性能和业务层面上的提升",frontmatter:{}}}}]);