"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19894"],{778990:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var t=r(552676),s=r(740453);let o=r.p+"static/image/f8eec33e0942bbee89004a2f5d88b97d.7482597a.webp",d=r.p+"static/image/3a406a7b6ebabdcd72cfb0acf48999bb.ad645999.webp",a=r.p+"static/image/8fa14bfc3e08ffa43a9dafd51424dc0c.0f82eff0.webp",i=r.p+"static/image/d4344518f5c57dea61d9a39c46d50182.d4521916.webp",c=r.p+"static/image/06102a2a293a8d7a472666d9f07aede2.481436b9.webp",l=r.p+"static/image/cf35da0d89f26252039cdc5f4300b500.ea52299d.webp",h=r.p+"static/image/baaa15868da27b4df2c460f57f112912.e3252c19.webp";function p(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",img:"img",h3:"h3",pre:"pre",code:"code",ul:"ul",li:"li",h4:"h4",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"34客户端实战组件状态绑定实现",children:["34.客户端实战：组件状态绑定实现",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34客户端实战组件状态绑定实现",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["对于低代码平台而言，灵活的动态能力可以赋予平台更多的可操作性，我们在现有的基础上实现了动态执行的能力，借助浏览器的 ",(0,t.jsx)(n.strong,{children:"eval"})," 特性，并使用 ",(0,t.jsx)(n.strong,{children:"with"})," 和 ",(0,t.jsx)(n.strong,{children:"iframe"})," 构建了一个安全的隔离沙箱来确保可执行逻辑的安全性。"]}),"\n",(0,t.jsxs)(n.p,{children:["那么，本章节的内容更多的是围绕实现好的 ",(0,t.jsx)(n.strong,{children:"BrowserRuntimeVM"})," 来将编辑器的状态管理(",(0,t.jsx)(n.strong,{children:"StoreProvider"}),")与示图进行结合，从而完成最基础的执行动作改变状态，最终完成示图刷新的这么一个过程。"]}),"\n",(0,t.jsxs)(n.h2,{id:"实现过程",children:["实现过程",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现过程",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["接下来就来实现在可视化编辑器当中是如何通过",(0,t.jsx)(n.strong,{children:"BrowserRuntimeVM"}),"与",(0,t.jsx)(n.strong,{children:"Redux"}),"进行绑定完成整个逻辑执行的闭环。"]}),"\n",(0,t.jsx)(n.p,{children:"基础的实现思路就是将实现的动态执行能力与状态管理结合起来。在之前的状态管理设计章节提到了利用vm来执行按钮组件的点击事件。"}),"\n",(0,t.jsx)(n.p,{children:"如下图所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"除此之外，编辑器还需要具备组件级别的状态声明。"}),"\n",(0,t.jsxs)(n.p,{children:["如下图所示：在物料组件内部添加的组件会绑定到对应物料组件的",(0,t.jsx)(n.strong,{children:"uid"}),"结构下，以此来形成组件与组件之间的状态空间，彼此之间可以通过对应的索引获取到组件状态，从而实现共享。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h3,{id:"storeprovider",children:["StoreProvider",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#storeprovider",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["首先，在 ",(0,t.jsx)(n.strong,{children:"@lgnition-lowcode/core"})," 中创建一个 ",(0,t.jsx)(n.strong,{children:"store.ts"})," 文件，用于实现 ",(0,t.jsx)(n.strong,{children:"StoreProvider"}),"来管理应用程序的状态。"]}),"\n",(0,t.jsx)(n.p,{children:"代码实现如下："}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"@reduxjs/toolkit"})," 是",(0,t.jsx)(n.strong,{children:"react-redux"}),"官方提倡的一个架构思想模型，当使用 ",(0,t.jsx)(n.strong,{children:"@reduxjs/toolkit"})," 来创建简单的状态管理层时。我们可以通过定义一个名为 ",(0,t.jsx)(n.strong,{children:"onUpdated"})," 的",(0,t.jsx)(n.strong,{children:"reducer"}),"来更新状态，此方法的目的是将传入的状态与当前已有的状态进行合并，从而得到一个完整真实的状态树，以便后续动态地管理状态属性。"]}),"\n",(0,t.jsxs)(n.p,{children:["最后，通过调用 ",(0,t.jsx)(n.strong,{children:"configureStore"})," 方法将其导出成为",(0,t.jsx)(n.strong,{children:"redux的store"}),"，里面包含了熟知的",(0,t.jsx)(n.strong,{children:"dispatch"}),"、",(0,t.jsx)(n.strong,{children:"getState"}),"等常见的方法提供后续在外部的使用。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { createSlice, configureStore } from '@reduxjs/toolkit'\nimport { merge } from 'lodash-es'\n\nconst counterSlice = createSlice({\n  name: '@@lgnition-space',\n  initialState: {\n    test: 1\n  } as Record<string, any>,\n  reducers: {\n    onUpdated: (state, { payload = {} }) => {\n      const mergeState = merge(state, payload)\n      return mergeState\n    }\n  }\n})\n\nexport const { onUpdated } = counterSlice.actions\n\nexport const store = configureStore({\n  reducer: counterSlice.reducer\n})\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"frameworkcontextprovider",children:["FrameworkContextProvider",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#frameworkcontextprovider",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["FrameworkContextProvider存放了整个编辑器框架顶层的一个",(0,t.jsx)(n.strong,{children:"Provider配置"}),"，如下代码所示，通过",(0,t.jsx)(n.strong,{children:"react-redux"}),"提供的",(0,t.jsx)(n.strong,{children:"Provider"}),"将上一节中创建的",(0,t.jsx)(n.strong,{children:"store"}),"进行配置注入到当前编辑器当中。在这之后，被",(0,t.jsx)(n.strong,{children:"StoreProvider"}),"包裹的组件内部就可以使用redux相关功能来进行状态的管理了。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import * as React from "react";\nimport { Editor } from "@craftjs/core";\n+ import { Provider as StoreProvider } from "react-redux";\n+ import { store } from "../store";\nimport type { FrameworRef } from "./mount-ref";\nimport { MountRef } from "./mount-ref";\n\ntype EditorProps = React.ComponentProps<typeof Editor>;\n\nexport type FrameworkProviderProps = Pick<EditorProps, "enabled">;\n\nexport const FrameworkContext = React.createContext<EditorProps | null>({\n  enabled: true,\n});\n\nexport const FrameworkContextProvider = React.forwardRef<FrameworRef, EditorProps>((props, ref) => {\n  return (\n+     <StoreProvider store={store}>\n      <FrameworkContext.Provider\n        value={{\n          enabled: props.enabled,\n        }}\n      >\n        <Editor {...props}>\n          <MountRef ref={ref} />\n          {props.children}\n        </Editor>\n      </FrameworkContext.Provider>\n+    </StoreProvider>\n  );\n});\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"状态管理setter",children:["状态管理Setter",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#状态管理setter",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["当有了状态管理的容器后，那么我们该如何设置状态呢？各位同学在开发应用的时候，大多数情况下会通过如下代码来设置一个",(0,t.jsx)(n.strong,{children:"count"}),"状态。"]}),"\n",(0,t.jsx)(n.p,{children:"那么可以将其拆分成为拆分以下几个信息"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"状态count"}),": 直接给页面显示的一个变量，也就是真实渲染到页面上的state,"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"设置状态setCount"}),"：设置count的改变，并且能够刷新响应页面的事图改变"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"默认值"}),"：初始化的内容"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const [count, setCount] = React.useState<number>(1)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["通过以上几个关键信息，就可以来基于 ",(0,t.jsx)(n.strong,{children:"StoreProvider(redux)"})," 实现组件级别的状态绑定了。"]}),"\n",(0,t.jsx)(n.p,{children:"如下图所示："}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"BindStateManageSetter"}),"是一个组件级别的状态管理",(0,t.jsx)(n.strong,{children:"setter"}),"，它负责的功能就是能够让用户可视化的声明组件应用的状态。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsxs)(n.h4,{id:"bindstatemanagesetter",children:["BindStateManageSetter",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#bindstatemanagesetter",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"如下代码："}),"\n",(0,t.jsxs)(n.p,{children:["在 ",(0,t.jsx)(n.strong,{children:"@lgnition-lowcode/setter"})," 新增 ",(0,t.jsx)(n.strong,{children:"BindStateManageSetter"})," 组件。通过",(0,t.jsx)(n.strong,{children:"ProForm.Item"}),"创建自定义的表单绑定组件。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"export const BindStateManageSetter: React.FC<ProFormItemProps> = (\n  props\n) => {\n  return (\n    <ProFormItem {...props}>\n      <BindStatePrototypeModal {...props.fieldProps} />\n    </ProFormItem>\n  );\n};\n"})}),"\n",(0,t.jsxs)(n.h4,{id:"bindstateprototypemodal",children:["BindStatePrototypeModal",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#bindstateprototypemodal",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["创建好了 ",(0,t.jsx)(n.strong,{children:"BindStateManageSetter"})," 后，接下来将着手实现 ",(0,t.jsx)(n.strong,{children:"BindStatePrototypeModal"})," 的逻辑。当点击 ",(0,t.jsx)(n.strong,{children:"DOM"})," 触发事件后，将弹出一个状态管理的弹窗。该弹窗由 ",(0,t.jsx)(n.strong,{children:"CodeEditor"})," 和可编辑表格组件构成，用于管理字段的名称、描述和默认值等相关信息。"]}),"\n",(0,t.jsx)(n.p,{children:"如下代码所示："}),"\n",(0,t.jsx)(n.p,{children:"首先将刚提到的信息类型进行声明，用于表格编辑的类型检查。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"interface StateRowType {\n  id: React.Key;\n  name: string;\n  defaultVal?: any;\n  desc?: string;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"如下代码所示："}),"\n",(0,t.jsxs)(n.p,{children:["创建完类型后，使用 ",(0,t.jsx)(n.strong,{children:"@ant-design/pro-components"})," 中的 ",(0,t.jsx)(n.strong,{children:"EditableProTable"})," 组件可以快速的来完成一个可编辑的表格。使用 ",(0,t.jsx)(n.strong,{children:"@monaco-editor/react"})," 来完成JSON编辑器的实现，当dataSource发生变化时，",(0,t.jsx)(n.strong,{children:"React.useEffect"}),"会将",(0,t.jsx)(n.strong,{children:"dataSource"}),"最新的内容同步到编辑器中。"]}),"\n",(0,t.jsxs)(n.p,{children:["以下是整个",(0,t.jsx)(n.strong,{children:"BindStatePrototypeModal"}),"组件的实现。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'const BindStatePrototypeModal: React.FC<CustomFormItemFieldProps> = (props) => {\n\n  // 表格数据\n  const [dataSource, setDataSource] = React.useState<readonly StateRowType[]>([]);\n\n  // JSON编辑器Ref实例\n  const editorRef = React.useRef<Parameters<OnMount>[0]>();\n\n  // 处理编辑器Mount生命周期\n  const handleEditorDidMount: EditorProps["onMount"] = (editor) => {\n    editorRef.current = editor;\n    if (dataSource) {\n      editor.setValue(JSON.stringify(dataSource, null, 2));\n    }\n  };\n\n  // 同步更新当前编辑器内容\n  React.useEffect(() => {\n    if (editorRef.current) {\n      editorRef.current.setValue(JSON.stringify(dataSource, null, 2));\n    }\n  }, [dataSource])\n\n  // 表格columns配置\n  const columns: ProColumns<StateRowType>[] = [\n    {\n      title: "名称",\n      dataIndex: "name",\n      formItemProps: () => {\n        return {\n          rules: [{ required: true, message: "必填" }],\n        };\n      },\n    },\n    {\n      title: "默认值",\n      dataIndex: "defaultVal",\n      formItemProps: () => {\n        return {\n          rules: [{ required: true, message: "必填" }],\n        };\n      },\n    },\n    {\n      title: \'字段描述\',\n      dataIndex: \'desc\'\n    },\n    {\n      title: "操作",\n      valueType: "option",\n    },\n  ];\n\n  const saveEditorComponentState = async () => {\n    if (props.onChange) {\n      props.onChange(dataSource)\n    }\n    return true\n  }\n\n  React.useEffect(() => {\n    setDataSource([])\n  }, [props.value])\n\n  return (\n    <ModalForm\n      title="状态管理"\n      width={800}\n      trigger={<Button block>状态管理</Button>}\n      onFinish={saveEditorComponentState}\n    >\n      <Space direction="vertical" style={{ width: "100%" }}>\n        <ProCard\n          bordered\n          collapsible\n          size="small"\n          title="JSON编辑"\n          headerBordered\n          defaultCollapsed={false}\n        >\n          <Editor\n            height="300px"\n            defaultLanguage="json"\n            onMount={handleEditorDidMount}\n          />\n        </ProCard>\n        <EditableProTable<StateRowType>\n            bordered\n            tableStyle={{\n              padding: 0,\n              margin: 0\n            }}\n            rowKey="id"\n            columns={columns}\n            recordCreatorProps={{\n              record: () => ({ id: (Math.random() * 1000000).toFixed(0) }),\n            }}\n            dataSource={dataSource}\n            onChange={setDataSource}\n            editable={{\n              type: "multiple",\n            }}\n          />\n      </Space>\n    </ModalForm>\n  );\n};\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"使用bindstatemanagesetter",children:["使用BindStateManageSetter",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用bindstatemanagesetter",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"BindStateManageSetter"})," 实现完成后，在对应组件的属性面板进行绑定，在这里比较推荐的是使用 $$ 的形式来避免与一些 props 产生冲突，因此我在这里是将 BindStateManageSetter声明的状态属性绑定在props.$$store上面。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { BindStateManageSetter } from \'@lgnition-lowcode/setter\'\n\n<BindStateManageSetter label="状态" name="$$store" />\n'})}),"\n",(0,t.jsx)(n.p,{children:"如下图所示："}),"\n",(0,t.jsxs)(n.p,{children:["在状态管理中，我为当前组件绑定了",(0,t.jsx)(n.strong,{children:"name、age、desc"}),"的状态。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["在此时，",(0,t.jsx)(n.strong,{children:"$$store"})," 中已经保存了刚刚生成的相应列表数据。接下来的一步是将数据同步到 ",(0,t.jsx)(n.strong,{children:"StoreProvider"})," 中。"]}),"\n",(0,t.jsx)(n.p,{children:"如下代码所示："}),"\n",(0,t.jsxs)(n.p,{children:["当",(0,t.jsx)(n.strong,{children:"props.$$store"}),"发生改变的时候，此时通过 ",(0,t.jsx)(n.strong,{children:"forEach"})," 遍历获取需要绑定的状态键和默认值的对象。然后使用 ",(0,t.jsx)(n.strong,{children:"onUpdated"})," 方法将需要更新的内容传递给 ",(0,t.jsx)(n.strong,{children:"store.dispatch"})," 进行更新。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"useThrottleEffect(() => {\n      if (props.$$store && Array.isArray(props.$$store)) {\n        const result: Record<string, any> = {}\n        props.$$store.forEach((item: any) => {\n          result[item.name] = item.defaultVal\n        })\n        console.log(result, 'result')\n\n      \n      store.dispatch(onUpdated({\n        [id]: result\n      }))\n      }\n    }, [props.$$store])\n"})}),"\n",(0,t.jsx)(n.p,{children:"如下图显示："}),"\n",(0,t.jsxs)(n.p,{children:["此时就完成了",(0,t.jsx)(n.strong,{children:"react-redux"}),"的相关绑定的工作，可以通过",(0,t.jsx)(n.strong,{children:"store.name"}),"测试一下当前的状态显示是否正常。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"需要注意的是，由于是组件级别的变量绑定，绑定到react-redux中会放入在UID的Scope下的。所以传入的payload是[id]: result的形式。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["通过组件状态的绑定，我们能够实现可视化编辑的重要环节。通过将组件的数据和行为进行关联，可以实现动态的交互和可视化效果。在本章节中，实现了状态声明的 ",(0,t.jsx)(n.strong,{children:"BindStateManageSetter"})," 设置器，它可以帮助编辑器使用者可视化地建立状态模型。通过使用该设置器，用户可以方便地定义组件的状态并自动挂载到",(0,t.jsx)(n.strong,{children:"StoreProvider"}),"当中，并为后续的可视化操作提供有利的数据支持。编辑器使用者可以根据自己的需求建立状态模型，从而为后续开发过程中的组件绑定提供更加灵活和便捷的方式。"]}),"\n",(0,t.jsxs)(n.h2,{id:"资源",children:["资源",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#资源",children:"#"})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"本篇未有参考资源提供"}),"\n"]})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F34.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0.md"]={toc:[{text:"实现过程",id:"实现过程",depth:2},{text:"StoreProvider",id:"storeprovider",depth:3},{text:"FrameworkContextProvider",id:"frameworkcontextprovider",depth:3},{text:"状态管理Setter",id:"状态管理setter",depth:3},{text:"BindStateManageSetter",id:"bindstatemanagesetter",depth:4},{text:"BindStatePrototypeModal",id:"bindstateprototypemodal",depth:4},{text:"使用BindStateManageSetter",id:"使用bindstatemanagesetter",depth:3},{text:"总结",id:"总结",depth:2},{text:"资源",id:"资源",depth:2}],title:"34.客户端实战：组件状态绑定实现",headingTitle:"34.客户端实战：组件状态绑定实现",frontmatter:{}}}}]);