"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75438"],{731696:function(e,c,d){d.r(c),d.d(c,{default:()=>u});var i=d(552676),s=d(740453);let n=d.p+"static/image/6.11.0916ca05.png",r=d.p+"static/image/6.10.7be7d6b0.png",l=d.p+"static/image/6.9.1909dd2e.png",h=d.p+"static/image/6.8.acd8f63a.png",x=d.p+"static/image/6.7.7eb875cb.png",o=d.p+"static/image/6.6.ae51a81c.png",j=d.p+"static/image/6.5.6149af68.png",t=d.p+"static/image/6.4.1dee0f67.png",m=d.p+"static/image/6.3.c3f44612.png",a=d.p+"static/image/6.2.194861f1.png",g=d.p+"static/image/6.1.2953affc.png";function p(e){let c=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",strong:"strong",pre:"pre",img:"img",ol:"ol",li:"li",blockquote:"blockquote",h3:"h3"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(c.h1,{id:"6-进阶-3merge合并-commits",children:["6 进阶 3：merge：合并 commits",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#6-进阶-3merge合并-commits",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["前面说到，",(0,i.jsx)(c.code,{children:"pull"})," 的内部操作其实是把远程仓库取到本地后（使用的是 ",(0,i.jsx)(c.code,{children:"fetch"}),"），再用一次 ",(0,i.jsx)(c.code,{children:"merge"})," 来把远端仓库的新 ",(0,i.jsx)(c.code,{children:"commits"})," 合并到本地。这一节就说一下，",(0,i.jsx)(c.code,{children:"merge"})," 到底是什么。"]}),"\n",(0,i.jsxs)(c.h2,{id:"含义和用法",children:["含义和用法",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#含义和用法",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:[(0,i.jsx)(c.code,{children:"merge"})," 的意思是「合并」，它做的事也是合并：指定一个 ",(0,i.jsx)(c.code,{children:"commit"}),"，把它合并到当前的 ",(0,i.jsx)(c.code,{children:"commit"})," 来。具体来讲，",(0,i.jsx)(c.code,{children:"merge"})," 做的事是："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsxs)(c.strong,{children:["从目标 ",(0,i.jsx)(c.code,{children:"commit"})," 和当前 ",(0,i.jsx)(c.code,{children:"commit"})," （即 ",(0,i.jsx)(c.code,{children:"HEAD"})," 所指向的 ",(0,i.jsx)(c.code,{children:"commit"}),"）分叉的位置起，把目标 ",(0,i.jsx)(c.code,{children:"commit"})," 的路径上的所有 ",(0,i.jsx)(c.code,{children:"commit"})," 的内容一并应用到当前 ",(0,i.jsx)(c.code,{children:"commit"}),"，然后自动生成一个新的 ",(0,i.jsx)(c.code,{children:"commit"}),"。"]})}),"\n",(0,i.jsx)(c.p,{children:"例如下面这个图中："}),"\n",(0,i.jsxs)(c.p,{children:[(0,i.jsx)(c.code,{children:"HEAD"})," 指向了 ",(0,i.jsx)(c.code,{children:"master"}),"，所以如果这时执行："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git merge branch1\n"})}),"\n",(0,i.jsxs)(c.p,{children:["Git 会把 ",(0,i.jsx)(c.code,{children:"5"})," 和 ",(0,i.jsx)(c.code,{children:"6"})," 这两个 ",(0,i.jsx)(c.code,{children:"commit"})," 的内容一并应用到 ",(0,i.jsx)(c.code,{children:"4"})," 上，然后生成一个新的提交，并跳转到提交信息填写的界面："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:g,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:[(0,i.jsx)(c.code,{children:"merge"})," 操作会帮你自动地填写简要的提交信息。在提交信息修改完成后（或者你打算不修改默认的提交信息），就可以退出这个界面，然后这次 ",(0,i.jsx)(c.code,{children:"merge"})," 就算完成了。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsxs)(c.h2,{id:"适用场景",children:["适用场景",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#适用场景",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:[(0,i.jsx)(c.code,{children:"merge"})," 有什么用？最常用的场景有两处："]}),"\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsxs)(c.li,{children:["\n",(0,i.jsx)(c.p,{children:"合并分支"}),"\n",(0,i.jsxs)(c.p,{children:["当一个 ",(0,i.jsx)(c.code,{children:"branch"})," 的开发已经完成，需要把内容合并回去时，用 ",(0,i.jsx)(c.code,{children:"merge"})," 来进行合并。"]}),"\n",(0,i.jsxs)(c.blockquote,{children:["\n",(0,i.jsxs)(c.p,{children:["那 ",(0,i.jsx)(c.code,{children:"branch"})," 又应该怎么用呢？"]}),"\n",(0,i.jsx)(c.p,{children:"下节就说。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(c.li,{children:["\n",(0,i.jsxs)(c.p,{children:[(0,i.jsx)(c.code,{children:"pull"})," 的内部操作"]}),"\n",(0,i.jsxs)(c.p,{children:["之前说过，",(0,i.jsx)(c.code,{children:"pull"})," 的实际操作其实是把远端仓库的内容用 ",(0,i.jsx)(c.code,{children:"fetch"})," 取下来之后，用 ",(0,i.jsx)(c.code,{children:"merge"})," 来合并。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(c.h2,{id:"特殊情况-1冲突",children:["特殊情况 1：冲突",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#特殊情况-1冲突",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:[(0,i.jsx)(c.code,{children:"merge"})," 在做合并的时候，是有一定的自动合并能力的：如果一个分支改了 A 文件，另一个分支改了 B 文件，那么合并后就是既改 A 也改 B，这个动作会自动完成；如果两个分支都改了同一个文件，但一个改的是第 1 行，另一个改的是第 2 行，那么合并后就是第 1 行和第 2 行都改，也是自动完成。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:m,alt:""})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["但，如果两个分支修改了同一部分内容，",(0,i.jsx)(c.code,{children:"merge"})," 的自动算法就搞不定了。这种情况 Git 称之为：冲突（Conflict）。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:j,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["直白点说就是，你的两个分支改了相同的内容，Git 不知道应该以哪个为准。如果在 ",(0,i.jsx)(c.code,{children:"merge"})," 的时候发生了这种情况，Git 就会把问题交给你来决定。具体地，它会告诉你 ",(0,i.jsx)(c.code,{children:"merge"})," 失败，以及失败的原因："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git merge feature1\n"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:o,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["提示信息说，在 ",(0,i.jsx)(c.code,{children:"shopping list.txt"}),' 中出现了 "merge conflict"，自动合并失败，要求 "fix conflicts and then commit the result"（把冲突解决掉后提交）。那么你现在需要做两件事：']}),"\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsx)(c.li,{children:"解决掉冲突"}),"\n",(0,i.jsxs)(c.li,{children:["手动 ",(0,i.jsx)(c.code,{children:"commit"})," 一下"]}),"\n"]}),"\n",(0,i.jsxs)(c.h3,{id:"1-解决冲突",children:["1. 解决冲突",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#1-解决冲突",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["解决掉冲突的方式有多个，我现在说最直接的一个。你现在再打开 ",(0,i.jsx)(c.code,{children:"shopping list.txt"})," 看一下，会发现它的内容变了："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:x,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["可以看到，Git 虽然没有帮你完成自动 ",(0,i.jsx)(c.code,{children:"merge"}),"，但它对文件还是做了一些工作：它把两个分支冲突的内容放在了一起，并用符号标记出了它们的边界以及它们的出处。上面图中表示，",(0,i.jsx)(c.code,{children:"HEAD"})," 中的内容是 ",(0,i.jsx)(c.code,{children:"移动硬盘（已买）"}),"，而 ",(0,i.jsx)(c.code,{children:"feature1"})," 中的内容则是 ",(0,i.jsx)(c.code,{children:"移动硬盘（不买了）"}),"。这两个改动 Git 不知道应该怎样合并，于是把它们放在一起，由你来决定。假设你决定保留 ",(0,i.jsx)(c.code,{children:"HEAD"})," 的修改，那么只要删除掉 ",(0,i.jsx)(c.code,{children:"feature1"})," 的修改，再把 Git 添加的那三行 ",(0,i.jsx)(c.code,{children:"<<<"})," ",(0,i.jsx)(c.code,{children:"==="})," ",(0,i.jsx)(c.code,{children:">>>"})," 辅助文字也删掉，保存文件退出，所谓的「解决掉冲突」就完成了。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:h,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["你也可以选择使用更方便的 ",(0,i.jsx)(c.code,{children:"merge"})," 工具来解决冲突，这个你可以自己搜索一下。"]}),"\n",(0,i.jsxs)(c.h3,{id:"2-手动提交",children:["2. 手动提交",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#2-手动提交",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["解决完冲突以后，就可以进行第二步—— ",(0,i.jsx)(c.code,{children:"commit"})," 了。"]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git add shopping\\ list.txt # 嗯是的，这里 commit 前也需要先 add 一下\ngit commit\n"})}),"\n",(0,i.jsxs)(c.p,{children:[(0,i.jsx)("img",{src:l,alt:""}),"\n可以看到，被冲突中断的 ",(0,i.jsx)(c.code,{children:"merge"}),"，在手动 ",(0,i.jsx)(c.code,{children:"commit"})," 的时候依然会自动填写提交信息。这是因为在发生冲突后，Git 仓库处于一个「merge 冲突待解决」的中间状态，在这种状态下 ",(0,i.jsx)(c.code,{children:"commit"}),"，Git 就会自动地帮你添加「这是一个 merge commit」的提交信息。"]}),"\n",(0,i.jsxs)(c.h3,{id:"放弃解决冲突取消-merge",children:["放弃解决冲突，取消 merge？",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#放弃解决冲突取消-merge",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["同理，由于现在 Git 仓库处于冲突待解决的中间状态，所以如果你最终决定放弃这次 ",(0,i.jsx)(c.code,{children:"merge"}),"，也需要执行一次 ",(0,i.jsx)(c.code,{children:"merge --abort"})," 来手动取消它："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git merge --abort\n"})}),"\n",(0,i.jsxs)(c.p,{children:["输入这行代码，你的 Git 仓库就会回到 ",(0,i.jsx)(c.code,{children:"merge"})," 前的状态。"]}),"\n",(0,i.jsxs)(c.h2,{id:"特殊情况-2head-领先于目标-commit",children:["特殊情况 2：HEAD 领先于目标 commit",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#特殊情况-2head-领先于目标-commit",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["如果 ",(0,i.jsx)(c.code,{children:"merge"})," 时的目标 ",(0,i.jsx)(c.code,{children:"commit"})," 和 ",(0,i.jsx)(c.code,{children:"HEAD"})," 处的 ",(0,i.jsx)(c.code,{children:"commit"})," 并不存在分叉，而是 ",(0,i.jsx)(c.code,{children:"HEAD"})," 领先于目标 ",(0,i.jsx)(c.code,{children:"commit"}),"："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:r,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["那么 ",(0,i.jsx)(c.code,{children:"merge"})," 就没必要再创建一个新的 ",(0,i.jsx)(c.code,{children:"commit"})," 来进行合并操作，因为并没有什么需要合并的。在这种情况下， Git 什么也不会做，",(0,i.jsx)(c.code,{children:"merge"})," 是一个空操作。"]}),"\n",(0,i.jsxs)(c.h2,{id:"特殊情况-3head-落后于-目标-commitfast-forward",children:["特殊情况 3：HEAD 落后于 目标 commit——fast-forward",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#特殊情况-3head-落后于-目标-commitfast-forward",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["而另一种情况：如果 ",(0,i.jsx)(c.code,{children:"HEAD"})," 和目标 ",(0,i.jsx)(c.code,{children:"commit"})," 依然是不存在分叉，但 ",(0,i.jsx)(c.code,{children:"HEAD"})," 不是领先于目标 ",(0,i.jsx)(c.code,{children:"commit"}),"，而是落后于目标 ",(0,i.jsx)(c.code,{children:"commit"}),"："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:n,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["那么 Git 会直接把 ",(0,i.jsx)(c.code,{children:"HEAD"}),"（以及它所指向的 ",(0,i.jsx)(c.code,{children:"branch"}),"，如果有的话）移动到目标 ",(0,i.jsx)(c.code,{children:"commit"}),"："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git merge feature1\n"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)(c.img,{src:"https://user-gold-cdn.xitu.io/2017/11/21/15fddc2b2486758a?w=494&h=376&f=gif&s=113911",alt:""})}),"\n",(0,i.jsx)(c.p,{children:'这种操作有一个专有称谓，叫做 "fast-forward"（快速前移）。'}),"\n",(0,i.jsxs)(c.p,{children:["一般情况下，创建新的 ",(0,i.jsx)(c.code,{children:"branch"})," 都是会和原 ",(0,i.jsx)(c.code,{children:"branch"})," （例如上图中的 ",(0,i.jsx)(c.code,{children:"master"})," ）并行开发的，不然没必要开 ",(0,i.jsx)(c.code,{children:"branch"})," ，直接在原 ",(0,i.jsx)(c.code,{children:"branch"})," 上开发就好。但事实上，上图中的情形其实很常见，因为这其实是 ",(0,i.jsx)(c.code,{children:"pull"})," 操作的一种经典情形：本地的 ",(0,i.jsx)(c.code,{children:"master"})," 没有新提交，而远端仓库中有同事提交了新内容到 ",(0,i.jsx)(c.code,{children:"master"}),"："]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)(c.img,{src:"https://user-gold-cdn.xitu.io/2017/11/21/15fddc2b2f15e16f?w=518&h=640&f=jpeg&s=38371",alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["那么这时如果在本地执行一次 ",(0,i.jsx)(c.code,{children:"pull"})," 操作，就会由于 ",(0,i.jsx)(c.code,{children:"HEAD"})," 落后于目标 ",(0,i.jsx)(c.code,{children:"commit"})," （也就是远端的 ",(0,i.jsx)(c.code,{children:"master"}),'）而造成 "fast-forward"：']}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git pull\n"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)(c.img,{src:"https://user-gold-cdn.xitu.io/2017/11/21/15fddc2b46c69d46?w=572&h=858&f=gif&s=412287",alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["简单解释一下上图中的 ",(0,i.jsx)(c.code,{children:"origin/master"})," 和 ",(0,i.jsx)(c.code,{children:"origin/HEAD"})," 是什么鬼：它们是对远端仓库的 ",(0,i.jsx)(c.code,{children:"master"})," 和 ",(0,i.jsx)(c.code,{children:"HEAD"})," 的本地镜像，在 ",(0,i.jsx)(c.code,{children:"git pull"})," 的「两步走」中的第一步——",(0,i.jsx)(c.code,{children:" git fetch"})," 下载远端仓库内容时，这两个镜像引用得到了更新，也就是上面这个动图中的第一步：",(0,i.jsx)(c.code,{children:"origin/master"})," 和 ",(0,i.jsx)(c.code,{children:"origin/HEAD"})," 移动到了最新的 ",(0,i.jsx)(c.code,{children:"commit"}),"。"]}),"\n",(0,i.jsxs)(c.blockquote,{children:["\n",(0,i.jsx)(c.p,{children:"为什么前面的图里面从来都没有这两个「镜像引用」？因为我没有画呀！其实它们是一直存在的。"}),"\n"]}),"\n",(0,i.jsxs)(c.p,{children:["而 ",(0,i.jsx)(c.code,{children:"git pull"})," 的第二步操作 ",(0,i.jsx)(c.code,{children:"merge"})," 的目标 ",(0,i.jsx)(c.code,{children:"commit"})," ，是远端仓库的 ",(0,i.jsx)(c.code,{children:"HEAD"}),"，也就是 ",(0,i.jsx)(c.code,{children:"origin/HEAD"})," ，所以 ",(0,i.jsx)(c.code,{children:"git pull"})," 的第二步的完整内容是："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git merge origin/HEAD\n"})}),"\n",(0,i.jsxs)(c.p,{children:["因此 ",(0,i.jsx)(c.code,{children:"HEAD"})," 就会带着 ",(0,i.jsx)(c.code,{children:"master"})," 一起，也指向图中绿色的最新 ",(0,i.jsx)(c.code,{children:"commit"})," 了。"]}),"\n",(0,i.jsxs)(c.h2,{id:"小结",children:["小结",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["本节对 ",(0,i.jsx)(c.code,{children:"merge"})," 进行了介绍，内容大概有这么几点："]}),"\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.code,{children:"merge"})," 的含义：从两个 ",(0,i.jsx)(c.code,{children:"commit"}),"「分叉」的位置起，把目标 ",(0,i.jsx)(c.code,{children:"commit"})," 的内容应用到当前 ",(0,i.jsx)(c.code,{children:"commit"}),"（",(0,i.jsx)(c.code,{children:"HEAD"})," 所指向的 ",(0,i.jsx)(c.code,{children:"commit"}),"），并生成一个新的 ",(0,i.jsx)(c.code,{children:"commit"}),"；"]}),"\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.code,{children:"merge"})," 的适用场景：","\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsxs)(c.li,{children:["单独开发的 ",(0,i.jsx)(c.code,{children:"branch"})," 用完了以后，合并回原先的 ",(0,i.jsx)(c.code,{children:"branch"}),"；"]}),"\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.code,{children:"git pull"})," 的内部自动操作。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.code,{children:"merge"})," 的三种特殊情况：","\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsxs)(c.li,{children:["冲突","\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsx)(c.li,{children:"原因：当前分支和目标分支修改了同一部分内容，Git 无法确定应该怎样合并；"}),"\n",(0,i.jsxs)(c.li,{children:["应对方法：解决冲突后手动 ",(0,i.jsx)(c.code,{children:"commit"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.code,{children:"HEAD"})," 领先于目标 ",(0,i.jsx)(c.code,{children:"commit"}),"：Git 什么也不做，空操作；"]}),"\n",(0,i.jsxs)(c.li,{children:[(0,i.jsx)(c.code,{children:"HEAD"})," 落后于目标 ",(0,i.jsx)(c.code,{children:"commit"}),"：fast-forward。"]}),"\n"]}),"\n"]}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,s.ah)(),e.components);return c?(0,i.jsx)(c,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}let u=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Git%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%2F6%E8%BF%9B%E9%98%B6%203%EF%BC%9Amerge%EF%BC%9A%E5%90%88%E5%B9%B6%20commits.md"]={toc:[{text:"含义和用法",id:"含义和用法",depth:2},{text:"适用场景",id:"适用场景",depth:2},{text:"特殊情况 1：冲突",id:"特殊情况-1冲突",depth:2},{text:"1. 解决冲突",id:"1-解决冲突",depth:3},{text:"2. 手动提交",id:"2-手动提交",depth:3},{text:"放弃解决冲突，取消 merge？",id:"放弃解决冲突取消-merge",depth:3},{text:"特殊情况 2：HEAD 领先于目标 commit",id:"特殊情况-2head-领先于目标-commit",depth:2},{text:"特殊情况 3：HEAD 落后于 目标 commit——fast-forward",id:"特殊情况-3head-落后于-目标-commitfast-forward",depth:2},{text:"小结",id:"小结",depth:2}],title:"6 进阶 3：merge：合并 commits",headingTitle:"6 进阶 3：merge：合并 commits",frontmatter:{}}}}]);