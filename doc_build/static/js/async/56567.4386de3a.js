"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56567"],{916817:function(e,n,t){t.r(n),t.d(n,{default:()=>h});var s=t(552676),i=t(740453);let a=t.p+"static/image/bcb482c0de3b380f740ba49d70dc5a88.61aa704c.webp",r=t.p+"static/image/926f8b7735fbcec54545d5ac25c32707.f7e25663.webp",c=t.p+"static/image/cff4160b5ba2763b2bd714790b70c723.622c5634.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",strong:"strong",blockquote:"blockquote",ul:"ul",li:"li",img:"img"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"16原理篇事件原理v18新版本",children:["16.\uD83D\uDD25原理篇—事件原理（v18新版本）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16原理篇事件原理v18新版本",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在上一章节中，我们讲到了老版本的事件原理，老版本的事件原理有一个问题就是，捕获阶段和冒泡阶段的事件都是模拟的，本质上都是在冒泡阶段执行的，比如如下例子中："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function Index(){\n    const refObj = React.useRef(null)\n    useEffect(()=>{\n        const handler = ()=>{\n            console.log('事件监听')\n        }\n        refObj.current.addEventListener('click',handler)\n        return () => {\n            refObj.current.removeEventListener('click',handler)\n        }\n    },[])\n    const handleClick = ()=>{\n       console.log('冒泡阶段执行')\n    }\n    const handleCaptureClick = ()=>{\n       console.log('捕获阶段执行')\n    }\n    return  <button ref={refObj} onClick={handleClick} onClickCapture={handleCaptureClick} >点击</button>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如上通过 onClick，onClickCapture 和原生的 DOM 监听器给元素 button 绑定了三个事件处理函数，那么当触发一次点击事件的时候，处理函数的执行，老版本打印顺序为："}),"\n",(0,s.jsx)(n.p,{children:"老版本事件系统：事件监听 -> 捕获阶段执行 -> 冒泡阶段执行"}),"\n",(0,s.jsx)(n.p,{children:"但是老版本的事件系统，一定程度上，不符合事件流的执行时机，但是在新版本 v18 的事件系统中，这个问题得以解决。"}),"\n",(0,s.jsx)(n.p,{children:"新版本事件系统：捕获阶段执行 -> 事件监听 -> 冒泡阶段执行"}),"\n",(0,s.jsx)(n.p,{children:"那么新版本事件系统有哪里改变呢？ 本章节我们来看一下新版本的事件系统原理。"}),"\n",(0,s.jsxs)(n.p,{children:["对于 React 事件原理挖掘，主要体现在两个方面，那就是",(0,s.jsx)(n.strong,{children:"事件绑定"}),"和",(0,s.jsx)(n.strong,{children:"事件触发"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"二-事件绑定事件初始化",children:["二 事件绑定——事件初始化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-事件绑定事件初始化",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 React 新版的事件系统中，在 createRoot 会一口气向外层容器上注册完全部事件，我们来看一下具体的实现细节："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-dom/client.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function createRoot(container, options) {\n    /* 省去和事件无关的代码，通过如下方法注册事件 */\n    listenToAllSupportedEvents(rootContainerElement);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 createRoot 中，通过 listenToAllSupportedEvents 注册事件，接下来看一下这个方法做了些什么："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-dom/src/events/DOMPluginEventSystem.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function listenToAllSupportedEvents(rootContainerElement) {\n    /* allNativeEvents 是一个 set 集合，保存了大多数的浏览器事件 */\n    allNativeEvents.forEach(function (domEventName) {\n      if (domEventName !== 'selectionchange') {\n         /* nonDelegatedEvents 保存了 js 中，不冒泡的事件 */ \n        if (!nonDelegatedEvents.has(domEventName)) {\n          /* 在冒泡阶段绑定事件 */ \n          listenToNativeEvent(domEventName, false, rootContainerElement);\n        }\n        /* 在捕获阶段绑定事件 */\n        listenToNativeEvent(domEventName, true, rootContainerElement);\n      }\n    });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"listenToAllSupportedEvents 这个方法比较核心，主要目的就是通过 listenToNativeEvent 绑定浏览器事件，这里引出了两个常量，allNativeEvents 和 nonDelegatedEvents ，它们分别代表的意思如下："}),"\n",(0,s.jsx)(n.p,{children:"allNativeEvents：allNativeEvents 是一个 set 集合，保存了 81 个浏览器常用事件。\nnonDelegatedEvents ：这个也是一个集合，保存了浏览器中不会冒泡的事件，一般指的是媒体事件，比如 pause，play，playing 等，还有一些特殊事件，比如 cancel ，close，invalid，load，scroll 。"}),"\n",(0,s.jsx)(n.p,{children:"接下来如果事件是不冒泡的，那么会执行一次，listenToNativeEvent，第二个参数为 true 。\n如果是常规的事件，那么会执行两次 listenToNativeEvent，分别在冒泡和捕获阶段绑定事件。"}),"\n",(0,s.jsx)(n.p,{children:"那么 listenToNativeEvent 就是事件监听，这个函数这里给它精简化，listenToNativeEvent 主要逻辑如下"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var listener = dispatchEvent.bind(null,domEventName,...)\nif(isCapturePhaseListener){\n    target.addEventListener(eventType, dispatchEvent, true);\n}else{\n    target.addEventListener(eventType, dispatchEvent, false);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如上代码是源代码精简后的，并不是源码，isCapturePhaseListener 就是 listenToNativeEvent 的第二个参数，target 为 DOM 对象。dispatchEvent 为统一的事件监听函数。"}),"\n",(0,s.jsx)(n.p,{children:"如上可以看到 listenToNativeEvent 本质上就是向原生 DOM 中去注册事件，上面还有一个细节，就是 dispatchEvent 已经通过 bind 的方式将事件名称等信息保存下来了。经过这第一步，在初始化阶段，就已经注册了很多的事件监听器了。"}),"\n",(0,s.jsx)(n.p,{children:"此时如果发生一次点击事件，就会触发两次 dispatchEvent ："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"第一次捕获阶段的点击事件；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"第二次冒泡阶段的点击事件；"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"三-事件触发",children:["三 事件触发",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-事件触发",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来就是重点，当触发一次点击事件，会发生什么，首先就是执行 dispatchEvent 事件，我们来看看这个函数做了些什么？"}),"\n",(0,s.jsx)(n.p,{children:"dispatchEvent 保留核心的代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"batchedUpdates(function () {\n    return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"dispatchEvent 如果是正常的事件，就会通过 batchedUpdates 来处理 dispatchEventsForPlugins ，batchedUpdates 是批量更新的逻辑，在之前的章节中已经讲到通过这种方式来让更新变成可控的。所有的矛头都指向了 dispatchEventsForPlugins ，这个函数做了些什么呢？"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n  /* 找到发生事件的元素——事件源 */  \n  var nativeEventTarget = getEventTarget(nativeEvent);\n  /* 待更新队列 */\n  var dispatchQueue = [];\n  /* 找到待执行的事件 */\n  extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n  /* 执行事件 */\n  processDispatchQueue(dispatchQueue, eventSystemFlags);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个函数非常重要，首先通过 getEventTarget 找到发生事件的元素，也就是事件源。然后创建一个待更新的事件队列，这个队列做什么，马上会讲到，接下来通过 extractEvents 找到待更新的事件，然后通过 processDispatchQueue 执行事件。"}),"\n",(0,s.jsx)(n.p,{children:"上面的信息量比较大，我们会逐一进行解析，先举一个例子如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function Index(){\n    const handleClick = ()=>{\n       console.log('冒泡阶段执行')\n    }\n    const handleCaptureClick = ()=>{\n       console.log('捕获阶段执行')\n    }\n    const handleParentClick = () => {\n        console.log('div 点击事件')\n    }\n    return  <div onClick={handleParentClick} >\n        <button onClick={handleClick} onClickCapture={handleCaptureClick} >点击</button>\n    </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如上的例子，有一个 div 和 button 均绑定了一个正常的点击事件 ，div 是 button 的父元素，除此之外 button 绑定了一个在捕获阶段执行的点击事件。"}),"\n",(0,s.jsx)(n.p,{children:"当点击按钮，触发一次点击事件的时候，如果 nativeEventTarget 本质上就是发生点击事件的 button 对应的 DOM 元素。"}),"\n",(0,s.jsx)(n.p,{children:"那么第一个问题就是 dispatchQueue 是什么？ extractEvents 有如何处理的 dispatchQueue。"}),"\n",(0,s.jsx)(n.p,{children:"发生点击事件，通过上面我们知道，会触发两次 dispatchEvents，第一次是捕获阶段，第二次是冒泡阶段 ，两次我们分别打印一下 dispatchQueue ："}),"\n",(0,s.jsx)(n.p,{children:"第一次打印："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"1.png"})}),"\n",(0,s.jsx)(n.p,{children:"第一次打印："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:"10-8-2.png"})}),"\n",(0,s.jsx)(n.p,{children:"如上可以看到两次 dispatchQueue 中只有一项元素，也就是在一次用户中，产生一次事件就会向 dispatchQueue 放入一个对象，对象中有两个状态，一个是 event ，一个是 listeners。那么这两个东西是如何来的呢？"}),"\n",(0,s.jsx)(n.p,{children:"event 是通过事件插件合成的事件源 event，在 React 事件系统中，事件源也不是原生的事件源，而是 React 自己创建的事件源对象。对于不同的事件类型，会创建不同的事件源对象。本质上是在 extractEvents 函数中，有这么一段处理逻辑。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:" var SyntheticEventCtor = SyntheticEvent;\n /* 针对不同的事件，处理不同的事件源 */\n switch (domEventName) {\n    case 'keydown':\n    case 'keyup':\n      SyntheticEventCtor = SyntheticKeyboardEvent;\n      break;\n    case 'focusin':\n      reactEventType = 'focus';\n      SyntheticEventCtor = SyntheticFocusEvent;\n      break;\n    ....    \n }\n/* 找到事件监听者，也就是我们 onClick 绑定的事件处理函数 */ \nvar _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);\n/* 向 dispatchQueue 添加 event 和 listeners  */\nif(_listeners.length > 0){\n    var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);\n    dispatchQueue.push({\n        event: _event,\n        listeners: _listeners\n    });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如上可以看到，首先根据不同事件类型，选用不同的构造函数，通过 new 的方式去合成不同事件源对象。上面还有一个细节就是 _listeners 是什么？ _listeners 本质上也是一个对象，里面有三个属性。"}),"\n",(0,s.jsx)(n.p,{children:"currentTarget：发生事件的 DOM 元素。\ninstance ： button 对应的 fiber 元素。\nlistener ：一个数组，存放绑定的事件处理函数本身，上面 demo 中就是绑定给 onClick，onClickCapture 的函数。"}),"\n",(0,s.jsx)(n.p,{children:"接下来可以通过 DOM 元素找到对应的 fiber，找到元素对应的 fiber 之后，也就能找到 props 事件了。但是这里有一个细节，就是 listener 可以有多个，比如如上捕获阶段的 listener 只有一个，而冒泡阶段的 listener 有两个，这是因为 div button 上都有 onClick 事件。"}),"\n",(0,s.jsx)(n.p,{children:"如上可以总结为："}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"当发生一次点击事件，React 会根据事件源对应的 fiber 对象，根据 return指针向上遍历，收集所有相同的事件"}),"，比如是 onClick，那就收集父级元素的所有  onClick 事件，比如是 onClickCapture，那就收集父级的所有 onClickCapture。"]}),"\n",(0,s.jsx)(n.p,{children:"得到了 dispatchQueue 之后，就需要 processDispatchQueue 执行事件了，这个函数的内部会经历两次遍历："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第一次遍历 dispatchQueue，通常情况下，只有一个事件类型，所有 dispatchQueue 中只有一个元素。"}),"\n",(0,s.jsx)(n.li,{children:"接下来会遍历每一个元素的 listener，执行 listener 的时候有一个特点："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/* 如果在捕获阶段执行。 */\nif (inCapturePhase) {\n    for (var i = dispatchListeners.length - 1; i >= 0; i--) {\n      var _dispatchListeners$i = dispatchListeners[i],\n          instance = _dispatchListeners$i.instance,\n          currentTarget = _dispatchListeners$i.currentTarget,\n          listener = _dispatchListeners$i.listener;\n     \n      \n      if (instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n      \n      /* 执行事件 */\n      executeDispatch(event, listener, currentTarget);\n      previousInstance = instance;\n    }\n  } else {\n    for (var _i = 0; _i < dispatchListeners.length; _i++) {\n      var _dispatchListeners$_i = dispatchListeners[_i],\n          _instance = _dispatchListeners$_i.instance,\n          _currentTarget = _dispatchListeners$_i.currentTarget,\n          _listener = _dispatchListeners$_i.listener;\n      \n      if (_instance !== previousInstance && event.isPropagationStopped()) {\n        return;\n      }\n      /* 执行事件 */\n      executeDispatch(event, _listener, _currentTarget);\n      previousInstance = _instance;\n    }\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"如上在 executeDispatch 会负责执行事件处理函数，也就是上面的 handleClick ，handleParentClick 等。这个有一个区别就是，如果是捕获阶段执行的函数，那么 listener 数组中函数，会从后往前执行，如果是冒泡阶段执行的函数，会从前往后执行，用这个模拟出冒泡阶段先子后父，捕获阶段先父后子。"}),"\n",(0,s.jsx)(n.p,{children:"还有一个细节就是如果触发了阻止冒泡事件，上述讲到事件源是 React 内部自己创建的，所以如果一个事件中执行了 e.stopPropagation ，那么事件源中就能感知得到，接下来就可以通过 event.isPropagationStopped 来判断是否阻止冒泡，如果组织，那么就会退出，这样就模拟了事件流的执行过程，以及阻止事件冒泡。"}),"\n",(0,s.jsxs)(n.h2,{id:"四-总结",children:["四 总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"以上就是新版本事件系统的原理，这里用一幅图来总结，新老版本事件系统在每个阶段的区别。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"8-6-3.png"})})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F16.%F0%9F%94%A5%E5%8E%9F%E7%90%86%E7%AF%87%E2%80%94%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86%EF%BC%88v18%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%89.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 事件绑定——事件初始化",id:"二-事件绑定事件初始化",depth:2},{text:"三 事件触发",id:"三-事件触发",depth:2},{text:"四 总结",id:"四-总结",depth:2}],title:"16.\uD83D\uDD25原理篇—事件原理（v18新版本）",headingTitle:"16.\uD83D\uDD25原理篇—事件原理（v18新版本）",frontmatter:{}}}}]);