"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["93312"],{471980:function(n,e,s){n.exports=s.p+"static/image/76b01480388835de0da694a1a2bb5b1a.54dd3dc3.png"},558579:function(n,e,s){s.r(e),s.d(e,{default:()=>v});var r=s(552676),c=s(740453);let a=s.p+"static/image/1084324ea8e4097182885124878b78d7.f3cc9170.png";var i=s(471980);let t=s.p+"static/image/fe48e03bb4d70804ffc8eac41c8b8c18.a2dba0a7.png",o=s.p+"static/image/dd54b2664bb08d9ae88e7d6f79ac74b6.3697c974.png",l=s.p+"static/image/5c49a4b55cbea9df7148e41c9f270f41.ce769e71.png",p=s.p+"static/image/c6253424ab555878a257e90cce3635d6.74359da3.png",d=s.p+"static/image/74b28b0cdc1495ac0bfba4a4cb6d19f4.68882743.png",u=s.p+"static/image/63463677db31598144b4a54733ea465e.16192ef0.png",h=s.p+"static/image/b518a5787ff48863254822dfb83675d7.ec5b2cb3.png",_=s.p+"static/image/80f899c1c7425ea586dada1f1f0415af.d04adb1d.png",m=s.p+"static/image/44d741f8970a637868b16d226cf096bc.a3981f4a.png",j=s.p+"static/image/887d5f5e7a0424842676cedac0d912ac.80c8dd48.png",b=s.p+"static/image/1c78f45431a920cde8ce0ef7e5654e8f.f4028c29.png",k=s.p+"static/image/6f48ca4481584e926c4915d052c37e75.bf5ab3cd.png",x=s.p+"static/image/95d048fa55f1097f24b1c1db0c6da6ea.bec6febe.png",g=s.p+"static/image/850f6307aa93fff9f3223ba4aab52ca1.73621e3b.png",w=s.p+"static/image/06090c6a607fbf22ff3cc21370c6ef61.f5b196e9.png";function f(n){let e=Object.assign({p:"p",h2:"h2",a:"a",ul:"ul",li:"li",strong:"strong",blockquote:"blockquote",h3:"h3",pre:"pre",code:"code",img:"img"},(0,c.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"在之前的动态 Script 以及 Fetch 示例中，我们讲解的微应用都是单个 Bundle 的加载示例，但在实际的开发中，考虑到页面的加载性能，往往需要将微应用的资源进行代码分割（Code Splitting），从而实现首屏加载的性能优化。本课程会设计基于代码分割的 Fetch 示例。"}),"\n",(0,r.jsxs)(e.h2,{id:"为什么需要代码分割",children:["为什么需要代码分割",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么需要代码分割",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"代码分割（Code Splitting）是一种性能优化技术，它主要是将单个 Bundle 文件拆分成多个较小的 Bundle，然后实现这些 Bundle 的按需加载或者并行加载。如果拆分合理，可以极大的减少页面的首屏加载时间，并可以提升移动端或者弱网环境的页面加载性能。常用的代码分割包含以下几种情况："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"多入口配置"}),"：如果项目存在多个入口的应用，可以抽离被这些应用重复使用的代码（例如常见的三方库、通用的框架和工具方法等），从而减少整体体积，并可以提高复用代码的缓存效率。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"按需加载"}),"：例如在 React 和 Vue 等 Web 框架中通常会使用路由访问页面，此时可以实现按路由加载资源，当用户打开页面时，只需要加载激活路由对应的资源，从而缩短首屏资源的加载和解析时间。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"并行加载"}),"：现代浏览器允许并行下载多个文件，在单个 Bundle 体积较大时，可以将 Bundle 拆分成多个更小的 Bundle，从而利用并行下载的特性缩短资源的加载时间。除此之外，在计算资源受限的移动设备上，较小的文件可以更快的被解析和编译。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["本课程会简单讲解如何实现代码分割，并讲解",(0,r.jsx)(e.strong,{children:"按需加载"}),"代码分割的运行时原理，从而使大家可以更好的了解在微前端中使用代码分割的注意事项。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：在多入口的应用开发中，为了节省前端资源的整体体积大小，可以通过\xa0",(0,r.jsx)(e.a,{href:"https://github.com/webpack-contrib/webpack-bundle-analyzer",target:"_blank",rel:"noopener noreferrer",children:"webpack-bundle-analyzer"}),"\xa0来分析这些应用的可复用模块，从而将其从各个应用的\xa0bundle\xa0中抽离出来，形成可复用的\xa0chunk\xa0文件。例如可以切分出公共的\xa0node_modules、公共业务组件、公共\xa0service、公共\xa0utils\xa0等。例如在弱网环境中，请求加载一个完整的超大\xa0JS\xa0文件会比并行加载多个切割的小型\xa0JS\xa0文件需要更多的时间。另外，可复用的\xa0chunk\xa0文件在多页应用中可以进行 HTTP 缓存，从而增加\xa0JS\xa0的缓存命中数。当然，在分离的过程中需要考虑单个\xa0chunk\xa0的大小以及\xa0chunk\xa0的数量等，从而适配移动设备、弱网、HTTP\xa0并发请求数量限制等不同的场景。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"如何实现代码分割",children:["如何实现代码分割",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#如何实现代码分割",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"这里简单讲解一些代码分割的简单示例，从而帮助大家更好的了解该功能的作用。"}),"\n",(0,r.jsxs)(e.h3,{id:"多入口配置",children:["多入口配置",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#多入口配置",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"假设应用 1 和应用 2 都是 Vue 应用，示例代码的目录结构如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:".\n├── public              # 静态资源托管目录\n│   ├── dist            # 构建目录\n│   │   ├── app1.js\n│   │   └── app2.js   \n│   ├── app1.html         \n│   └── app2.html       \n├── src                 # 源文件目录\n│   ├── app1.js         # 微应用 1 源码\n│   └── app2.js         # 微应用 2 源码\n├── server.js           # 启动服务          \n├── package.json        # 项目描述文件\n└── webpack.config.js   # webpack 配置文件\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 webpack-runtime-analyze 的\xa0",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/webpack-runtime-analyze/tree/demo/code_splitting",target:"_blank",rel:"noopener noreferrer",children:"demo/code_splitting"}),"\xa0分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"src/app1.js"})," 和 ",(0,r.jsx)(e.code,{children:"src/app2.js"})," 中引入 Vue 创建 ",(0,r.jsx)(e.code,{children:"div"})," 元素进行渲染，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/app1.js\nimport { createApp, ref, h } from "vue";\n\ncreateApp({\n  setup() {\n    // 详见 https://cn.vuejs.org/api/composition-api-setup.html#usage-with-render-functions\n    const message = ref(\'Hello App 1\');\n    return () => h("div", message.value);\n  },\n}).mount("#app");\n\n\n// src/app2.js\nimport { createApp, ref, h } from "vue";\n\ncreateApp({\n  setup() {\n    const message = ref(\'Hello App 2\');\n    return () => h("div", message.value);\n  },\n}).mount("#app");\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在 Webpack 的 ",(0,r.jsx)(e.code,{children:"webpack.config.js"})," 文件中新增如下多入口配置："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 用于分析构建产物\nconst BundleAnalyzerPlugin =\n  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;\nconst path = require("path");\n\nmodule.exports = {\n  mode: "production",\n  entry: {\n    // 应用 1 入口\n    app1: "./src/app1.js",\n    // 应用 2 入口\n    app2: "./src/app2.js",\n  },\n  output: {\n    path: path.resolve(__dirname, "public/dist"), // 输出的文件夹\n  },\n  plugins: [new BundleAnalyzerPlugin()],\n};\n\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在项目的根目录执行 ",(0,r.jsx)(e.code,{children:"npm run build"})," 后会在 ",(0,r.jsx)(e.code,{children:"public/dist"})," 目录下生成构建文件："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 22.框架解析：single-spa 的 Code Splitting 示例\nnpm run build \n\n# 打印\n> webpack-runtime-analyze@1.0.0 build\n> webpack\n\n# 构建产物的可视化分析访问地址\nWebpack Bundle Analyzer is started at http://127.0.0.1:8888\nUse Ctrl+C to close it\n# 生成 app1.js，大小为 57.8 KiB\nasset app1.js 57.8 KiB [emitted] [minimized] (name: app1) 1 related asset\n# 生成 app2.js，大小为 57.8 KiB\nasset app2.js 57.8 KiB [emitted] [minimized] (name: app2) 1 related asset\norphan modules 348 KiB [orphan] 5 modules\nruntime modules 442 bytes 2 modules\ncacheable modules 696 KiB\n  ./src/app1.js + 4 modules 348 KiB [built] [code generated]\n  ./src/app2.js + 4 modules 348 KiB [built] [code generated]\nwebpack 5.89.0 compiled successfully in 1095 ms\n"})}),"\n",(0,r.jsxs)(e.p,{children:["在构建时使用 ",(0,r.jsx)(e.a,{href:"https://github.com/webpack-contrib/webpack-bundle-analyzer",target:"_blank",rel:"noopener noreferrer",children:"webpack-bundle-analyzer"})," 对构建产物进行可视化分析，可以发现两个应用构建后各自打包了 ",(0,r.jsx)(e.code,{children:"node_modules"})," 下的代码，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:w,alt:"image.png"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：从上图左侧 Show chunks 的 All 可以看出默认没有分割的情况下，两个应用的总体积为 115.51 KB。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"public/app1.html"})," 和 ",(0,r.jsx)(e.code,{children:"public/app2.html"})," 中引入构建后的脚本，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-html",children:'\x3c!-- app1.html --\x3e\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script src="./dist/app1.js"><\/script>\n  </body>\n</html>\n\n\x3c!-- app2.html --\x3e\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script src="./dist/app2.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"server.js"})," 中使用 Express ",(0,r.jsx)(e.a,{href:"https://www.expressjs.com.cn/starter/static-files.html",target:"_blank",rel:"noopener noreferrer",children:"配置静态文件服务"}),"，使得 ",(0,r.jsx)(e.code,{children:"public"})," 目录下的文件可以对外访问："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'const express = require("express");\nconst morgan = require("morgan");\nconst app = express();\nconst port = 4000;\n\n// 打印请求日志\napp.use(morgan("dev"));\n\napp.use(\n  // 利用 Express 托管静态文件：https://www.expressjs.com.cn/starter/static-files.html\n  express.static("public", {\n    cacheControl: false,\n    // HTTP 缓存\n    // 每次请求都会向服务器进行验证\n    // 如果资源没有变化，则会返回 304（不携带资源）继续使用缓存\n    // 如果资源变化，则返回 200 并携带变化后的资源\n    etag: true,\n    lastModified: false,\n  })\n);\n\n// 启动 Node 服务\napp.listen(port);\nconsole.log(`server start at http://localhost:${port}/`);\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：在托管静态资源时加入了 HTTP 缓存，这里设置成强制向服务器验证服务文件的缓存有效性。如果你对缓存不清楚，可以查看",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7258893482318626868/section/7259192938658267151#heading-0",target:"_blank",rel:"noopener noreferrer",children:"原理解析：性能优化 / HTTP 缓存"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["托管后我们可以访问 ",(0,r.jsx)(e.code,{children:"public"})," 目录下的所有文件，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"http://localhost:4000/app1.html\nhttp://localhost:4000/app2.html\nhttp://localhost:4000/dist/app1.js\nhttp://localhost:4000/dist/app2.js\n"})}),"\n",(0,r.jsxs)(e.p,{children:["执行 ",(0,r.jsx)(e.code,{children:"node server.js"})," 启动服务，访问对应的应用，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 执行 node server.js\nnpm run start\n\n# 打印信息\n> webpack-runtime-analyze@1.0.0 start\n> node server.js\n\nserver start at http://localhost:4000/\n# 首次访问 http://localhost:4000/app1.html 所有资源返回 200 状态码\nGET /app1.html 200 10.138 ms - 281\nGET /dist/app1.js 200 1.343 ms - 59141\n# 首次访问 http://localhost:4000/app2.html 所有资源返回 200 状态码\nGET /app2.html 200 1.819 ms - 281\nGET /dist/app2.js 200 1.608 ms - 59141\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：重新启动服务会对 HTTP 缓存产生影响吗？"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"首次访问应用 1 和微应用 2 时所有资源都返回状态码 200："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"我们可以计算一下两个微应用首次请求资源的情况："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 首次请求微应用 1\napp1.html：517 B\napp1.js：59.4 kB\n应用 1 的总请求：517 + 59.4 * 1024 = 61342.6 B（59.9 kB）\n# 首次请求微应用 2\napp2.html：517 B\napp2.js：59.4 kB\n应用 2 的总请求：517 + 59.4 * 1024 = 61342.6 B（59.9 kB）\n"})}),"\n",(0,r.jsxs)(e.p,{children:["由于应用 1 和应用 2 共用了 ",(0,r.jsx)(e.code,{children:"node_modules"})," 中的库代码，因此这里可以将 ",(0,r.jsx)(e.code,{children:"node_modules"})," 的代码分割出来，我们重新修改 ",(0,r.jsx)(e.code,{children:"webpack.config.js"})," 文件："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 用于分析构建产物\nconst BundleAnalyzerPlugin =\n  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;\nconst path = require("path");\n\nmodule.exports = {\n  mode: "production",\n  entry: {\n    app1: "./src/app1.js",\n    app2: "./src/app2.js",\n  },\n  output: {\n    path: path.resolve(__dirname, "public/dist"), // 输出的文件夹\n  },\n  plugins: [new BundleAnalyzerPlugin()],\n  optimization: {\n    // 将复用的代码抽离出来，形成一个单独的 vendors.js 文件\n    splitChunks: {\n      chunks: \'all\',\n      name: \'vendors\'\n    },\n  },\n};\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在项目的根目录执行\xa0",(0,r.jsx)(e.code,{children:"npm run build"}),"\xa0后会在\xa0",(0,r.jsx)(e.code,{children:"public/dist"}),"\xa0目录下生成构建文件："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 执行\nnpm run build\n\n# 打印\n> webpack-runtime-analyze@1.0.0 build\n> webpack\n\n# 构建产物的可视化分析访问地址\nWebpack Bundle Analyzer is started at http://127.0.0.1:8888\nUse Ctrl+C to close it\n# 生成 vendors.js，大小为 60.9 KiB\nasset vendors.js 60.9 KiB [emitted] [minimized] (name: vendors) (id hint: vendors) 1 related asset\n# 生成 app1.js，大小为 1.35 KiB\nasset app1.js 1.35 KiB [emitted] [minimized] (name: app1)\n# 生成 app2.js，大小为 1.35 KiB\nasset app2.js 1.35 KiB [emitted] [minimized] (name: app2)\nEntrypoint app1 62.2 KiB = vendors.js 60.9 KiB app1.js 1.35 KiB\nEntrypoint app2 62.2 KiB = vendors.js 60.9 KiB app2.js 1.35 KiB\nruntime modules 6.03 KiB 10 modules\norphan modules 580 bytes [orphan] 1 module\ncacheable modules 348 KiB\n  modules by path ./node_modules/@vue/ 348 KiB\n    ./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js 48.2 KiB [built] [code generated]\n    ./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js 245 KiB [built] [code generated]\n    ./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js 34.1 KiB [built] [code generated]\n    ./node_modules/@vue/shared/dist/shared.esm-bundler.js 20.3 KiB [built] [code generated]\n  modules by path ./src/*.js 436 bytes\n    ./src/app1.js 265 bytes [built] [code generated]\n    ./src/app2.js 171 bytes [built] [code generated]\nwebpack 5.89.0 compiled successfully in 1193 ms\n"})}),"\n",(0,r.jsxs)(e.p,{children:["使用\xa0",(0,r.jsx)(e.a,{href:"https://github.com/webpack-contrib/webpack-bundle-analyzer",target:"_blank",rel:"noopener noreferrer",children:"webpack-bundle-analyzer"}),"\xa0对构建产物进行可视化分析，可以发现两个应用构建后分割出了共同复用的 ",(0,r.jsx)(e.code,{children:"vendors.js"})," 文件，该文件主要打包了所有 ",(0,r.jsx)(e.code,{children:"node_modules"})," 中的库包代码，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：从上图左侧 Show chunks 的 All 可以看出在分割代码的情况下，两个应用的总体积为 63.57 KB，因为抽离了可复用的 ",(0,r.jsx)(e.code,{children:"node_modules"}),"，不再是每一个应用都打包 ",(0,r.jsx)(e.code,{children:"node_modules"})," 的代码，因此相对没有分割代码的情况而言总体积少了 51.94 KB（115.51 KB - 63.57 KB）。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["接下来修改\xa0",(0,r.jsx)(e.code,{children:"public/app1.html"}),"\xa0和\xa0",(0,r.jsx)(e.code,{children:"public/app2.html"}),"\xa0中的引入脚本，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-html",children:'\x3c!-- app1.html --\x3e\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    \x3c!-- 引入复用的 vendors.js --\x3e\n    <script src="./dist/vendors.js"><\/script>\n    <script src="./dist/app1.js"><\/script>\n  </body>\n</html>\n\n\x3c!-- app2.html --\x3e\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    \x3c!-- 引入复用的 vendors.js --\x3e\n    <script src="./dist/vendors.js"><\/script>\n    <script src="./dist/app2.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(e.p,{children:["服务代码保持不变，重新执行 ",(0,r.jsx)(e.code,{children:"node server.js"})," 启动服务，访问对应的应用，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 执行 node server.js\nnpm run start\n\n# 打印信息\n> webpack-runtime-analyze@1.0.0 start\n> node server.js\n\nserver start at http://localhost:4000/\nGET / 404 2.914 ms - 139\n# 首次请求微应用 1\n# 所有资源返回 200 状态码\nGET /app1.html 200 7.572 ms - 327\nGET /dist/app1.js 200 6.890 ms - 1387\nGET /dist/vendors.js 200 10.638 ms - 62326\n# 首次请求微应用 2\n# vendors.js 命中 304 缓存\nGET /app2.html 200 1.819 ms - 327\nGET /dist/vendors.js 304 3.722 ms - -\nGET /dist/app2.js 200 9.547 ms - 1387\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：为了模拟首次请求的情况，防止命中缓存，可以将 ",(0,r.jsx)(e.code,{children:"dist"})," 目录下的资源删除后重新生成（包括 ",(0,r.jsx)(e.code,{children:"app1.html"})," 和 ",(0,r.jsx)(e.code,{children:"app2.html"}),"）。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"首次访问微应用 1 时所有资源返回状态码 200："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:k,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["首次访问微应用 2 时 ",(0,r.jsx)(e.code,{children:"vendors.js"})," 命中 304 缓存："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"我们可以计算一下两个微应用首次请求资源的情况："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 首次请求微应用 1\napp1.html：559 B\nvendors.js：62.6 kB\napp1.js：1.6 kB\n应用 1 的总请求：559 + (62.6 + 1.6) * 1024 = 66299.8 B（64.7 kB）\n# 首次请求微应用 2\napp2.html：559 B\nvendors.js：186 kB\napp2.js：1.6 kB\n应用 2 的总请求：559 + 186 + 1.6 * 1024 = 2383.4 B（2.3 kB）\n"})}),"\n",(0,r.jsxs)(e.p,{children:["在真实的业务场景中我们往往需要修改应用的业务代码，此时如果 ",(0,r.jsx)(e.code,{children:"node_modules"})," 没有新增任何库包，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/app1.js\nimport { createApp, ref, h } from "vue";\n\ncreateApp({\n  setup() {\n    // 更改渲染内容 1 为 11\n    const message = ref(\'Hello App 11\');\n    return () => h("div", message.value);\n  },\n}).mount("#app");\n\n\n// src/app2.js\nimport { createApp, ref, h } from "vue";\n\ncreateApp({\n  setup() {\n    // 更改渲染内容 2 为 22\n    const message = ref(\'Hello App 22\');\n    return () => h("div", message.value);\n  },\n}).mount("#app");\n'})}),"\n",(0,r.jsx)(e.p,{children:"构建代码后访问对应的应用，如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 执行\nnpm run start\n\n# 打印\n> webpack-runtime-analyze@1.0.0 start\n> node server.js\n\nserver start at http://localhost:4000/\n# 首次请求微应用 1\n# app1.html 和 vendors.js 命中 304 缓存\nGET /app1.html 304 7.847 ms - -\nGET /dist/vendors.js 304 9.076 ms - -\n# 首次请求微应用 2\n# app2.html 和 vendors.js 命中 304 缓存\nGET /dist/app1.js 200 10.146 ms - 1388\nGET /app2.html 304 1.123 ms - -\nGET /dist/vendors.js 304 0.721 ms - -\nGET /dist/app2.js 200 3.627 ms - 1388\n"})}),"\n",(0,r.jsxs)(e.p,{children:["首次访问微应用 1 和微应用 2 时 ",(0,r.jsx)(e.code,{children:"vendors.js"})," 都会命中 304 缓存："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"我们可以总结一下上述这些示例的首屏加载情况，如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:_,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"从上述表格中可以发现，如果没有进行代码分割，应用 1 和应用 2 的代码在首次加载时无法做到性能优化，并且每次构建都会因为构建脚本的变化而无法命中服务器缓存。而进行代码分割后，首先分割后的通用代码可以在第二次加载时命中缓存，并且如果再次构建后通用代码没有发生变化，则可以在后续的使用中继续命中服务缓存，从而节省应用的首屏加载时间。"}),"\n",(0,r.jsxs)(e.h3,{id:"按需加载",children:["按需加载",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#按需加载",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"多入口配置主要应用于 MPA 场景，旨在多个应用中分割出可复用的代码，从而节省应用总体积的同时，增加复用代码的缓存命中率，实现优化首屏加载的性能。除此之外，我们也可以考虑在单个应用中考虑分割代码，例如按路由加载资源，从而继续减少首屏加载的体积。我们在应用 1 的基础上进行修改，示例代码的目录结构如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:".\n├── public              # 静态资源托管目录\n│   ├── dist            # 构建目录\n│   │   └── app1.js         \n│   └── app1.html       \n├── src                 # 源文件目录\n│   └── app1.js         # 微应用 2 源码\n├── server.js           # 启动服务          \n├── package.json        # 项目描述文件\n└── webpack.config.js   # webpack 配置文件\n"})}),"\n",(0,r.jsxs)(e.p,{children:["首先根据 Vue Router 官方文档的",(0,r.jsx)(e.a,{href:"https://router.vuejs.org/zh/guide/",target:"_blank",rel:"noopener noreferrer",children:"入门"}),"，我们将 Vue 和 Vue Router 通过 CDN 的方式引入，",(0,r.jsx)(e.code,{children:"app1.html"})," 的代码如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>App1</title>\n    <script src="https://unpkg.com/vue@3"><\/script>\n    <script src="https://unpkg.com/vue-router@4"><\/script>\n  </head>\n  <body>\n    <div id="app">\n      <h1>Hello App!</h1>\n      <p>\n        \x3c!--使用 router-link 组件进行导航 --\x3e\n        \x3c!--通过传递 `to` 来指定链接 --\x3e\n        \x3c!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签--\x3e\n        <router-link to="/">Go to Home</router-link>\n        <router-link to="/about">Go to About</router-link>\n      </p>\n      \x3c!-- 路由出口 --\x3e\n      \x3c!-- 路由匹配到的组件将渲染在这里 --\x3e\n      <router-view></router-view>\n    </div>\n    \x3c!-- 声明需要匹配路由的组件 --\x3e\n    <script src="./dist/app1.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(e.p,{children:["根据文档在\xa0",(0,r.jsx)(e.code,{children:"src/app1.js"}),"中声明需要匹配路由的组件，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 1. 定义路由组件.\n// 也可以从其他文件导入\nimport About from './about.js'\nconst Home = { template: '<div>Home</div>' }\n\n// 2. 定义一些路由\n// 每个路由都需要映射到一个组件。\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About },\n]\n\n// 3. 创建路由实例并传递 `routes` 配置\n// 你可以在这里输入更多的配置，但我们在这里\n// 暂时保持简单\nconst router = VueRouter.createRouter({\n  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\n\n// 5. 创建并挂载根实例\nconst app = Vue.createApp({})\n//确保 _use_ 路由实例使\n//整个应用支持路由。\napp.use(router)\n\napp.mount('#app')\n\n// 现在，应用已经启动了！\n"})}),"\n",(0,r.jsxs)(e.p,{children:["其中 ",(0,r.jsx)(e.code,{children:"about.js"})," 是一个体积较大的",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/webpack-runtime-analyze/blob/demo/import/src/about.js",target:"_blank",rel:"noopener noreferrer",children:"组件"}),"，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsx",children:"export default {\n  template: `<div>\n  About\n  About\n  // 省略 1 万行\n  About\n  </div>`,\n};\n"})}),"\n",(0,r.jsxs)(e.p,{children:["修改 Webpack 的 ",(0,r.jsx)(e.code,{children:"webpack.config.js"})," 文件："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 用于分析构建产物\nconst BundleAnalyzerPlugin =\n  require("webpack-bundle-analyzer").BundleAnalyzerPlugin;\nconst path = require("path");\n\nmodule.exports = {\n  mode: "production",\n  entry: {\n    app1: "./src/app1.js",\n    // app2: "./src/app2.js",\n  },\n  output: {\n    path: path.resolve(__dirname, "public/dist"), // 输出的文件夹\n  },\n  plugins: [new BundleAnalyzerPlugin()]\n};\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在项目的根目录执行\xa0",(0,r.jsx)(e.code,{children:"npm run build"}),"\xa0后会在\xa0",(0,r.jsx)(e.code,{children:"public/dist"}),"\xa0目录下生成构建文件："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 执行\nnpm run build                                                                           \n\n# 打印\n> webpack-runtime-analyze@1.0.0 build\n> webpack\n\nNo bundles were parsed. Analyzer will show only original module sizes from stats file.\n# 构建产物的可视化分析访问地址\nWebpack Bundle Analyzer is started at http://127.0.0.1:8888\nUse Ctrl+C to close it\n# 生成 app1.js，大小为 88.8 KiB\nasset app1.js 88.8 KiB [compared for emit] [minimized] (name: app1)\norphan modules 78.8 KiB [orphan] 1 module\n./src/app1.js + 1 modules 79.7 KiB [built] [code generated]\nwebpack 5.89.0 compiled successfully in 155 ms\n"})}),"\n",(0,r.jsxs)(e.p,{children:["使用\xa0",(0,r.jsx)(e.a,{href:"https://github.com/webpack-contrib/webpack-bundle-analyzer",target:"_blank",rel:"noopener noreferrer",children:"webpack-bundle-analyzer"}),"\xa0对构建产物进行可视化分析，其中 ",(0,r.jsx)(e.code,{children:"about.js"})," 没有被分割出来，其大小为 78.8 KiB， 如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["执行\xa0",(0,r.jsx)(e.code,{children:"node server.js"}),"\xa0启动服务，访问对应的应用，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 执行\nnpm run start                                                                          \n\n# 打印\n> webpack-runtime-analyze@1.0.0 start\n> node server.js\n\nserver start at http://localhost:4000/\n# 首次请求微应用 1\nGET /app1.html 200 10.147 ms - 865\nGET /dist/app1.js 200 0.849 ms - 90977\n"})}),"\n",(0,r.jsxs)(e.p,{children:["首次请求应用时会先加载 ",(0,r.jsx)(e.code,{children:"app1.js"}),"，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["上述示例不论是否会点击 Go to About 对应的路由，都会在首次加载应用时加载路由对应的资源，因为 Webpack 构建后会将 ",(0,r.jsx)(e.code,{children:"src/about.js"})," 对应的资源构建到 ",(0,r.jsx)(e.code,{children:"dist/app1.js"})," 中。如果用户进入后不会点击 Go to About 对应的路由，那么加载路由相应组件资源 ",(0,r.jsx)(e.code,{children:"src/about.js"})," 对于加载首屏而言就是一种多余请求。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们可以修改源代码，从而可以利用 Webpack 的代码分割能力将 ",(0,r.jsx)(e.code,{children:"src/about.js"})," 抽离出来，并且只在点击 Go to About 对应的路由时按需动态加载 ",(0,r.jsx)(e.code,{children:"src/about.js"})," 对应的构建资源。我么可以修改 ",(0,r.jsx)(e.code,{children:"src/app1.js"})," 源码，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const Home = { template: '<div>Home</div>' }\n\nconst routes = [\n  { path: '/', component: Home },\n  // 详见\n  // https://webpack.docschina.org/api/module-methods \n  // https://webpack.docschina.org/guides/code-splitting/#dynamic-imports\n  // 调用 import() 被视为分割点，意思是，被请求的模块和它引用的所有子模块，会分割到一个单独的 chunk 中\n  // 使用 /* webpackChunkName: \"about\" */ 注释可以使得分割后的 chunk 文件命名为 about.js\n  { path: '/about', component: () => import(/* webpackChunkName: \"about\" */ './about.js')},\n]\n\nconst router = VueRouter.createRouter({\n  history: VueRouter.createWebHashHistory(),\n  routes, // `routes: routes` 的缩写\n})\n\n\nconst app = Vue.createApp({})\n\napp.use(router)\n\napp.mount('#app')\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["示例源码可以从 webpack-runtime-analyze 的\xa0",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/webpack-runtime-analyze/tree/demo/import",target:"_blank",rel:"noopener noreferrer",children:"demo/import"}),"\xa0分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在项目的根目录执行\xa0",(0,r.jsx)(e.code,{children:"npm run build"}),"\xa0后会在\xa0",(0,r.jsx)(e.code,{children:"public/dist"}),"\xa0目录下生成构建文件："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# 执行\nnpm run build\n\n# 打印\n> webpack-runtime-analyze@1.0.0 build\n> webpack\n\nWebpack Bundle Analyzer is started at http://127.0.0.1:8888\nUse Ctrl+C to close it\n# 生成 about.js，大小为 88.8 KiB\nasset about.js 88.8 KiB [compared for emit] [minimized] (name: about)\n# 生成 app1.js，大小为 2.79 KiB\nasset app1.js 2.79 KiB [compared for emit] [minimized] (name: app1)\nruntime modules 6.75 KiB 9 modules\ncacheable modules 80 KiB\n  ./src/app1.js 1.19 KiB [built] [code generated]\n  ./src/about.js 78.8 KiB [built] [code generated]\nwebpack 5.89.0 compiled successfully in 163 ms\n"})}),"\n",(0,r.jsxs)(e.p,{children:["使用\xa0",(0,r.jsx)(e.a,{href:"https://github.com/webpack-contrib/webpack-bundle-analyzer",target:"_blank",rel:"noopener noreferrer",children:"webpack-bundle-analyzer"}),"\xa0对构建产物进行可视化分析，其中 ",(0,r.jsx)(e.code,{children:"about.js"})," 被分割出来，其大小为 88.8 KiB， 如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["需要注意手动分离复用代码和使用 ",(0,r.jsx)(e.code,{children:"import()"})," 实现自动分离存在一定的差异，手动分离需要将分离的脚本地址手动添加到 HTML 文件中进行加载，而通过 ",(0,r.jsx)(e.code,{children:"import()"})," 自动分离的脚本则不需要 HTML 做任何处理，因为其内部本质就是利用 ",(0,r.jsx)(e.code,{children:"<script>"})," 标签进行动态加载（接下来会讲解 Webpack 运行时原理），此时我们启动服务访问应用，会发现首次加载 ",(0,r.jsx)(e.code,{children:"app1.js"})," 时资源非常小，点击 Go to About 路由时才会按需动态加载 ",(0,r.jsx)(e.code,{children:"about.js"}),"，从而相对于之前的示例在首屏加载时节省了加载资源："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:"录屏2024-03-05 19.37.52.gif"})}),"\n",(0,r.jsxs)(e.h2,{id:"代码分割的运行时原理",children:["代码分割的运行时原理",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码分割的运行时原理",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在 qiankun 官方文档",(0,r.jsx)(e.a,{href:"https://qiankun.umijs.org/zh/guide/getting-started#2-%E9%85%8D%E7%BD%AE%E5%BE%AE%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7",target:"_blank",rel:"noopener noreferrer",children:"配置微应用的打包工具"}),"说明中需要进行如下 Webpack 配置："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// webpack 5.x\nconst packageName = require('./package.json').name;\n\nmodule.exports = {\n  output: {\n    // library 和 libraryTarget 用于暴露微应用的生命周期函数\n    library: `${packageName}-[name]`,\n    libraryTarget: 'umd',\n    // chunkLoadingGlobal 用于代码分割\n    chunkLoadingGlobal: `webpackJsonp_${packageName}`,\n  },\n};\n\n// webpack 4.x\nconst packageName = require('./package.json').name;\n\n\nmodule.exports = {\n  output: {\n    library: `${packageName}-[name]`,\n    libraryTarget: 'umd',\n    jsonpFunction: `webpackJsonp_${packageName}`,\n  },\n};\n"})}),"\n",(0,r.jsxs)(e.p,{children:["其中为了让主应用能识别微应用暴露出来的生命周期函数，需要配置 ",(0,r.jsx)(e.code,{children:"library"})," 和 ",(0,r.jsx)(e.code,{children:"libraryTarget"}),"，这两个配置以及对应的 Webpack 运行时原理已经在上一个课程中讲解。本课程主要讲解和代码分割息息相关的 ",(0,r.jsx)(e.code,{children:"chunkLoadingGlobal"})," 配置。"]}),"\n",(0,r.jsx)(e.p,{children:"为了简化大家对于 Webpack 运行时的原理，在这里基于上一个课程的 Webpack 示例进行讲解，示例代码的目录结构如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:".\n├── dist                        # 构建目录\n│   ├── index.js                # 构建入口文件\n│   └── src_single-spa_js.js    # 构建分离 chunk\n├── src                         # 源文件目录\n│   ├── index.js                 # 入口文件\n│   └── single-spa.js           # 被动态导入的文件\n├── index.html                  # 网页代码，用于运行构建代码进行测试\n├── package.json                # 项目描述文件\n└── webpack.config.js           # Webpack 配置文件\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 webpack-runtime-analyze 的\xa0",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/webpack-runtime-analyze/tree/demo/chunkLoadingGlobal",target:"_blank",rel:"noopener noreferrer",children:"demo/chunkLoadingGlobal"}),"\xa0分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["如果在\xa0",(0,r.jsx)(e.code,{children:"src/main.js"}),"\xa0中通过\xa0ES\xa0模块引入\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"}),"\xa0中的代码，那么\xa0Webpack\xa0构建时只会生成单个\xa0Bundle\xa0文件\xa0",(0,r.jsx)(e.code,{children:"dist/main.js"}),"。如果在\xa0",(0,r.jsx)(e.code,{children:"src/main.js"}),"\xa0中通过\xa0",(0,r.jsx)(e.code,{children:"import()"}),"\xa0动态导入\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"}),"，那么\xa0Webpack\xa0在构建时会自动对引入的\xa0",(0,r.jsx)(e.code,{children:"single-spa.js"}),"\xa0进行代码分割，从而生成新的\xa0chunk\xa0文件\xa0",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"}),"。动态导入的源代码如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/index.js\n// 使用 import { bootstrap } from \'./single-spa.js\' 引入时只会构建单个 Bundle\n// 这里采用 import(\'./single-spa.js\') 进行动态导入，会自动分离 chunk 文件\nimport("./single-spa.js").then((res) => {\n  console.log(res);\n});\n\n// src/single-spa.js\nexport async function bootstrap() {\n  console.log("bootstrap");\n}\n\nexport async function mount() {\n  console.log("mount");\n}\n\nexport async function unmount() {\n  console.log("unmount");\n}\n\nexport async function update() {\n  console.log("update");\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在 Webpack 中新增 ",(0,r.jsx)(e.code,{children:"chunkLoadingGlobal"})," 配置，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'const packageName = require("./package.json").name;\n\nmodule.exports = {\n  output: {\n    library: "myLibrary",\n    libraryTarget: "umd",\n    // 代码分割配置\n    chunkLoadingGlobal: `webpackJsonp_${packageName}`,\n  },\n};index\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"index.html"})," 中引入构建后的脚本，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script src="dist/main.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在浏览器中打开 ",(0,r.jsx)(e.code,{children:"index.html"})," 执行后查看打印信息，可以发现\xa0",(0,r.jsx)(e.code,{children:"import()"})," 的\xa0Promise\xa0回调中可以获取到\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"})," 导出的生命周期函数，除此之外\xa0",(0,r.jsx)(e.code,{children:"single-spa.js"}),"\xa0中的代码被分离到了独立的\xa0chunk\xa0文件\xa0",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"})," 中："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"promise.then"}),"\xa0中打印的生命周期函数如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:["在上一个课程中我们讲解了 ",(0,r.jsx)(e.code,{children:"output.library"})," 的运行时原理，这里和直接暴露库属性的构建代码存在一些差异，在暴露库属性的构建代码中只有一个 ",(0,r.jsx)(e.code,{children:"src/index.js"}),"\xa0ES\xa0模块，因此只需要执行对应的模块化包装函数并返回模块化导出对象\xa0",(0,r.jsx)(e.code,{children:"__webpack_exports__"}),"\xa0即可，而在这个动态导入的示例中存在\xa0",(0,r.jsx)(e.code,{children:"src/index.js"}),"\xa0和\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"})," 两个模块，并且\xa0",(0,r.jsx)(e.code,{children:"single-spa.js"}),"\xa0所在的模块是一个需要异步加载的\xa0chunk\xa0文件。执行的大致流程包含："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"src/index.js"})," 模块化包装函数的执行，返回对应的模块化导出对象\xa0",(0,r.jsx)(e.code,{children:"__webpack_exports__"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"src/index.js"})," 动态导入\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"})," 对应的构建\xa0chunk\xa0的动态加载和执行"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"src/single-spa.js"})," 模块化包装函数的执行，返回对应的模块化导出对象"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"src/index.js"})," 动态导入的\xa0",(0,r.jsx)(e.code,{children:"promise.then"})," 获取\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"})," 对应的模块化导出对象"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["我们重点来分析一下 ",(0,r.jsx)(e.code,{children:"dist/main.js"})," 的构建代码，去除\xa0Webpack\xa0自带的注释后如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// dist/main.js\n(function webpackUniversalModuleDefinition(root, factory) {\n  // UMD 规范的代码，支持 CommonJS、AMD 和浏览器运行环境\n  if (typeof exports === "object" && typeof module === "object")\n    module.exports = factory();\n  else if (typeof define === "function" && define.amd) define([], factory);\n  else if (typeof exports === "object") exports["myLibrary"] = factory();\n  // 如果在浏览器中通过 <script> 标签引入，那么这里的代码会被执行\n  // root 是全局对象，例如在浏览器中就是 window\n  else root["myLibrary"] = factory();\n})(self, () => {\n  return (() => {\n    // webpackBootstrap\n    // 这里是模块化路径对应的模块化包装函数，上一节课中已经详细讲解\n    var __webpack_modules__ = {\n      "./src/index.js": (\n        __unused_webpack_module,\n        __unused_webpack_exports,\n        __webpack_require__\n      ) => {\n        eval(\n          "// 使用 import { bootstrap } from \'./single-spa.js\' 引入时只会构建单个 Bundle\\n// 这里采用 import(\'./single-spa.js\') 进行动态导入，会自动分离 chunk 文件\\n__webpack_require__.e(/*! import() */ \\"src_single-spa_js\\").then(__webpack_require__.bind(__webpack_require__, /*! ./single-spa.js */ \\"./src/single-spa.js\\")).then((res) => {\\n  console.log(res);\\n});\\n\\n//# sourceURL=webpack://myLibrary/./src/index.js?"\n        );\n      },\n    };\n\n    // The module cache\n    // 模块化缓存对象\n    var __webpack_module_cache__ = {};\n\n    // The require function\n    // 该函数的作用是根据模块路径加载模块\n    function __webpack_require__(moduleId) {\n      // Check if module is in cache\n      // 检查模块是否在缓存中\n      // 如果在缓存中，则直接返回缓存中的模块导出值\n      // 可以想象一下模块被导入多次后，这里会有什么作用？\n      var cachedModule = __webpack_module_cache__[moduleId];\n      if (cachedModule !== undefined) {\n        return cachedModule.exports;\n      }\n      // Create a new module (and put it into the cache)\n      // 创建一个新的模块，并将其放入缓存中\n      var module = (__webpack_module_cache__[moduleId] = {\n        // no module.id needed\n        // no module.loaded needed\n        exports: {},\n      });\n\n      // Execute the module function\n      // 执行模块化包装函数\n      __webpack_modules__[moduleId](\n        module,\n        module.exports,\n        __webpack_require__\n      );\n\n      // Return the exports of the module\n      // 返回模块导出值\n      return module.exports;\n    }\n\n    // expose the modules object (__webpack_modules__)\n    // 将 __webpack_modules__ 赋值给 __webpack_require__.m\n    __webpack_require__.m = __webpack_modules__;\n\n    /* webpack/runtime/define property getters */\n    (() => {\n      // define getter functions for harmony exports\n      \n      // 函数作用\n      // 用于定义 harmony 模块（ES2015 模块）的 exports 导出对象\n      // 将源文件模块导出的对象赋值给模块化导出对象 __webpack_exports__\n\n      // 参数说明\n      // exports： 模块化导出对象 __webpack_exports__\n      // definition： 源文件中的导出对象（例如 src/index.js 中导出的生命周期函数）\n\n      // 举个例子\n      // 如果在 src/index.js 中导出了 bootstrap、mount、unmount、update 四个函数\n      // 那么 definition 对象就是 { bootstrap, mount, unmount, update }\n      __webpack_require__.d = (exports, definition) => {\n        // 遍历源文件中导出对象的属性\n        for (var key in definition) {\n          if (\n            // 检查 definition 对象是否有 key 属性\n            // 检查 exports 对象是否有 key 属性\n            __webpack_require__.o(definition, key) &&\n            !__webpack_require__.o(exports, key)\n          ) {\n            // 为 exports 对象定义 key 属性，属性值为 definition 对象的 key 属性值\n            // 即将 src/index.js 中导出的 bootstrap 等函数添加到 __webpack_exports__ 对象中\n            Object.defineProperty(exports, key, {\n              // enumerable: true 表示该属性可以被枚举\n              enumerable: true,\n              // 设置 getter 函数，该函数返回 definition 对象的 key 属性值\n              get: definition[key],\n            });\n          }\n        }\n      };\n    })();\n\n    /* webpack/runtime/ensure chunk */\n    (() => {\n      // __webpack_require__.f 内部存储了所有的加载器处理函数\n      __webpack_require__.f = {};\n      // This file contains only the entry chunk.\n      // The chunk loading function for additional chunks\n      // 该函数会在 ./src/index.js 中执行 __webpack_require__.e(/*! import() */ "src_single-spa_js") 时调用\n      // 用于对 chunk 进行加载器的批量处理,\n      // 在这个示例中主要用于异步加载 chunk 文件（src_single-spa_js）\n      __webpack_require__.e = (chunkId) => {\n        return Promise.all(\n        \n          // Object.keys(__webpack_require__.f) 获取所有的加载器\n          // 这些加载器用于处理不同类型的模块,\n          // 例如处理动态 script 加载的是 __webpack_require__.f.j\n          \n          // 在 reduce 的回调函数中，每个加载器都会被调用\n          // 传入 chunkId 和 promises 两个参数\n          \n          // 加载器的任务就是根据 chunkId 加载对应的模块\n          // 并将加载的结果（通常是一个 Promise 对象）添加到 promises 数组中\n          \n          // 最后，Promise.all 会等待 promises 处理完成，然后返回一个新的 Promise 对象\n          // 这个新的 Promise 对象在所有加载器执行完成时解析\n          // 如果有任何加载器执行失败，则会被拒绝。\n          Object.keys(__webpack_require__.f).reduce((promises, key) => {\n            // 调用加载器，如果加载器是 __webpack_require__.f.j\n            // 那么就会调用 __webpack_require__.f.j(chunkId, promises)\n            __webpack_require__.f[key](chunkId, promises);\n            // 返回 promises 数组用于下一次迭代\n            return promises;\n          }, [])\n        );\n      };\n    })();\n\n    /* webpack/runtime/get javascript chunk filename */\n    (() => {\n      // This function allow to reference async chunks\n      // 主要作用是计算 chunk 文件名\n      __webpack_require__.u = (chunkId) => {\n        // return url for filenames based on template\n        return "" + chunkId + ".js";\n      };\n    })();\n\n    /* webpack/runtime/global */\n    (() => {\n      // 主要作用是计算 window 全局对象并将其赋值给 __webpack_require__.g\n      __webpack_require__.g = (function () {\n        if (typeof globalThis === "object") return globalThis;\n        try {\n          return this || new Function("return this")();\n        } catch (e) {\n          if (typeof window === "object") return window;\n        }\n      })();\n    })();\n\n    /* webpack/runtime/hasOwnProperty shorthand */\n    (() => {\n      // 函数名称\n      // __webpack_require__.o\n\n      // 函数作用\n      // 用于检查一个对象是否有某个自身属性（即不包括继承的属性）\n\n      // 参数说明\n      // obj： 需要被检查的对象\n      // prop： 需要被检查的属性\n      __webpack_require__.o = (obj, prop) =>\n        Object.prototype.hasOwnProperty.call(obj, prop);\n    })();\n\n    /* webpack/runtime/load script */\n    (() => {\n      var inProgress = {};\n      var dataWebpackPrefix = "myLibrary:";\n      // loadScript function to load a script via script tag\n      // 主要作用是通过创建和插入一个 <script> 标签来动态加载一个 chunk 文件\n      __webpack_require__.l = (url, done, key, chunkId) => {\n        // 首先检查给定的 URL 是否已经在加载中\n        // 如果是在加载中，将回调函数添加到回调函数列表中，并立即返回\n        if (inProgress[url]) {\n          inProgress[url].push(done);\n          return;\n        }\n        var script, needAttach;\n        if (key !== undefined) {\n          // 如果 key 参数存在，则检查是否已经存在对应的 <script> 标签\n          var scripts = document.getElementsByTagName("script");\n          for (var i = 0; i < scripts.length; i++) {\n            var s = scripts[i];\n            if (\n              s.getAttribute("src") == url ||\n              s.getAttribute("data-webpack") == dataWebpackPrefix + key\n            ) {\n              script = s;\n              break;\n            }\n          }\n        }\n        if (!script) {\n          // 如果没有找到具有相同 key 属性值的 <script> 标签，则创建一个新的 <script> 标签\n          needAttach = true;\n          script = document.createElement("script");\n\n          script.charset = "utf-8";\n          // 设置超时时间为 120 秒\n          script.timeout = 120;\n          // 如果 __webpack_require__.nc 存在\n          // 那么就设置 <script> 标签的 nonce 属性值为 __webpack_require__.nc\n          if (__webpack_require__.nc) {\n            script.setAttribute("nonce", __webpack_require__.nc);\n          }\n          // 设置 data-webpack 属性值为 "myLibrary:chunk-src_single-spa_js"\n          // 这个属性值是用于标记 <script> 是否被创建\n          script.setAttribute("data-webpack", dataWebpackPrefix + key);\n          // 设置 <script> 标签的 src 属性值为 url\n          script.src = url;\n        }\n        inProgress[url] = [done];\n        // onScriptComplete 函数的作用是清理加载过程中创建的资源\n        // 防止内存泄漏，并调用所有注册的回调函数\n        var onScriptComplete = (prev, event) => {\n          // avoid mem leaks in IE.\n          script.onerror = script.onload = null;\n          clearTimeout(timeout);\n          var doneFns = inProgress[url];\n          delete inProgress[url];\n          // 删除 <script> 标签\n          script.parentNode && script.parentNode.removeChild(script);\n          // 遍历所有的回调函数，进行调用\n          doneFns && doneFns.forEach((fn) => fn(event));\n          if (prev) return prev(event);\n        };\n        // 创建一个超时定时器，用于检测加载是否超时\n        var timeout = setTimeout(\n          onScriptComplete.bind(null, undefined, {\n            type: "timeout",\n            target: script,\n          }),\n          120000\n        );\n        script.onerror = onScriptComplete.bind(null, script.onerror);\n        script.onload = onScriptComplete.bind(null, script.onload);\n        // 将 <script> 标签添加到文档的 <head> 中进行 chunk 的动态加载\n        needAttach && document.head.appendChild(script);\n      };\n    })();\n\n    /* webpack/runtime/make namespace object */\n    (() => {\n      // define __esModule on exports\n      // 函数名称\n      // __webpack_require__.r\n\n      // 函数作用\n      // 该函数用于定义 ES6 模块的标准行为\n      // 即为模块化导出对象 __webpack_exports__ 定义 __esModule 属性值等\n      // 可用于识别 __webpack_exports__ 的模块性质\n\n      // 参数说明\n      // exports： 模块化导出对象 __webpack_exports__\n      __webpack_require__.r = (exports) => {\n        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {\n          // 为 exports 对象定义属性 Symbol.toStringTag，值为 "Module"\n          // Symbol.toStringTag：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag\n          // ES6 模块的标准行为\n          // Object.prototype.toString.call(exports) = "[object Module]"\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: "Module",\n          });\n        }\n        // exports.__esModule = true\n        // 这是一个约定，用于标记这个模块是一个 ES 模块。\n        // 其他模块在导入该模块时可以知道它是一个 ES 模块，从而使用正确的导入语法\n        Object.defineProperty(exports, "__esModule", { value: true });\n        \n        // 为什么使用 Object.defineProperty 而不是直接 exports.__esModule = true 呢？ \n        // 因为 Object.defineProperty 有一个特性 configurable \n        // 当 configurable 为 false 时，该属性不可被删除，也不可被修改 \n        // 这样可以防止其他模块修改 __esModule 的值，从而保证了 __esModule 的值为 true \n        // Object.defineProperty 被用于在 exports 对象上定义 __esModule 属性， \n        // 这个属性是不可枚举的，这意味着它不会出现在 for-in 循环或 Object.keys 方法中。 \n        // 这个属性也是不可写的，这意味着你不能改变它的值。 \n        // 这些特性都是通过 Object.defineProperty 方法来实现的 \n        // { configurable: false, enumerable: false, value: true, writable: false } \n        console.log(Object.getOwnPropertyDescriptor(exports, "__esModule"));\n      };\n    })();\n\n    /* webpack/runtime/publicPath */\n    // 这个函数的主要作用是确定 Webpack 的公共路径（publicPath）\n    // 这是 Webpack 用来确定异步加载的模块的 URL 的基础路径\n    (() => {\n      var scriptUrl;\n      // 判断 Web Worker 环境\n      // 函数首先检查全局对象（__webpack_require__.g）是否有 importScripts 方法\n      // 将 scriptUrl 设置为全局对象的 location 属性的字符串表示\n      if (__webpack_require__.g.importScripts)\n        scriptUrl = __webpack_require__.g.location + "";\n      var document = __webpack_require__.g.document;\n      // 判断浏览器环境\n      // 获取全局对象的 document 属性，\n      // 如果 scriptUrl 还没有被设置\n      // 并且 document 存在\n      // 那么它将尝试从 document.currentScript.src 获取 scriptUrl\n      if (!scriptUrl && document) {\n        if (document.currentScript) scriptUrl = document.currentScript.src;\n        if (!scriptUrl) {\n          var scripts = document.getElementsByTagName("script");\n          // 如果 scriptUrl 还没有被设置\n          // 那么函数将获取页面上所有的 <script> 标签，并从最后一个标签开始向前遍历\n          // 直到找到一个具有 src 属性的标签并将 src 属性的值设置为 scriptUrl\n          if (scripts.length) {\n            var i = scripts.length - 1;\n            while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;\n          }\n        }\n      }\n      // When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n      // or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.\n      // 如果函数无法确定 scriptUrl\n      // 那么它将抛出一个错误，因为在这种情况下\n      // Webpack 无法自动确定公共路径\n      if (!scriptUrl)\n        throw new Error(\n          "Automatic publicPath is not supported in this browser"\n        );\n      // 将 scriptUrl 清理（移除哈希和查询参数，以及最后一个斜杠后的所有内容）\n      // 并将其设置为 Webpack 的公共路径（__webpack_require__.p）\n      scriptUrl = scriptUrl\n        .replace(/#.*$/, "")\n        .replace(/\\?.*$/, "")\n        .replace(/\\/[^\\/]+$/, "/");\n      __webpack_require__.p = scriptUrl;\n    })();\n\n    /* webpack/runtime/jsonp chunk loading */\n    (() => {\n      // no baseURI\n\n      // object to store loaded and loading chunks\n      // undefined = chunk not loaded, null = chunk preloaded/prefetched\n      // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\n      \n      // installedChunks 对象存储了已加载和正在加载的模块。其值的含义如下：\n      // undefined：模块未加载\n      // [resolve, reject, Promise]：模块正在加载\n      // 0：模块已加载\n      var installedChunks = {\n        main: 0,\n      };\n\n      // 1. 初始化异步 chunk 文件的加载状态 installedChunks\n      // 当异步 chunk 文件所在的 <script> 加载完成后\n      // 会在 webpackJsonpCallback 中进行 promise.resolve 和 installedChunks[chunkId] = 0 处理\n      \n      // 2. 执行 __webpack_require__.l 函数\n      // 动态创建 <script> 标签，加载分离的 chunk 代码块\n      __webpack_require__.f.j = (chunkId, promises) => {\n        // JSONP chunk loading for javascript\n        // 获取当前 chunkId 对应的模块加载状态信息\n        var installedChunkData = __webpack_require__.o(installedChunks, chunkId)\n          ? installedChunks[chunkId]\n          : undefined;\n          \n        // 对应的模块是否已经被加载。如果已经被加载，则不做任何事情\n        if (installedChunkData !== 0) {\n          // 0 means "already installed".\n\n          // a Promise means "currently loading".\n          // 如果 installedChunkData 存在，且 installedChunkData 不为 0\n          // 那么就说明当前模块正在加载中\n          if (installedChunkData) {\n            promises.push(installedChunkData[2]);\n          // 否则说明当前模块未加载\n          } else {\n            if (true) {\n              // all chunks have JS\n              // setup Promise in chunk cache\n              \n              // 创建一个新的 Promise\n              \n              // 给当前即将需要加载的 chunk 文件创建一个 Promise 对象\n              // 并将其添加到 promises 数组中\n              \n              // installedChunks[chunkId] 的值是一个数组\n              // 数组的第一个元素是 Promise 的 resolve 函数\n              \n              // 第二个元素是 Promise 的 reject 函数\n              // 用于表明当前的 chunkId 对应的 chunk 文件正在加载\n              var promise = new Promise(\n                (resolve, reject) =>\n                  (installedChunkData = installedChunks[chunkId] =\n                    [resolve, reject])\n              );\n              \n              // installedChunks[chunkId] 的第三个元素是 Promise 对象\n              promises.push((installedChunkData[2] = promise));\n\n              // start chunk loading\n              // 计算 chunk 的 URL\n              var url = __webpack_require__.p + __webpack_require__.u(chunkId);\n              // create error before stack unwound to get useful stacktrace later\n              \n              // 在开始加载模块之前，它会创建一个新的 Error 对象\n              // 这个 Error 对象会在加载结束后用于处理可能的错误\n              var error = new Error();\n              \n              // 1. 如果 <script> 加载失败，\n              // 那么 installedChunkData 的状态仍然是 [resolve, reject, Promise]\n              // 此时触发 script.onerror 执行 loadingEnded 函数重置加载状态\n              \n              // 2. 如果 <script> 加载成功，\n              // 那么会先执行 webpackJsonpCallback 设置 installedChunkData 的加载状态为 0，\n              //然后触发 script.onload 执行 loadingEnded 函数\n              \n              // 3. 如果超时，那么 installedChunkData 的状态仍然是 [resolve, reject, Promise]，\n              // 会触发定时器执行 loadingEnded 函数重置加载状态\n              var loadingEnded = (event) => {\n                if (__webpack_require__.o(installedChunks, chunkId)) {\n                  installedChunkData = installedChunks[chunkId];\n                  \n                  // 如果 installedChunkData 不为 0\n                  // 那么将 installedChunks[chunkId] 设置为 undefined（模块未加载）\n                  \n                  // 下次加载该 chunk 文件时会重新加载,\n                  // 这样可以避免加载失败的模块一直加载失败（例如超时重试）\n                  if (installedChunkData !== 0)\n                    installedChunks[chunkId] = undefined;\n                    \n                  // 失败处理\n                  if (installedChunkData) {\n                    var errorType =\n                      event && (event.type === "load" ? "missing" : event.type);\n                    // realSrc 是失败的模块的 URL，它从事件 target 的 src 属性中获取\n                    var realSrc = event && event.target && event.target.src;\n                    error.message =\n                      "Loading chunk " +\n                      chunkId +\n                      " failed.\\n(" +\n                      errorType +\n                      ": " +\n                      realSrc +\n                      ")";\n                    error.name = "ChunkLoadError";\n                    error.type = errorType;\n                    error.request = realSrc;\n                    // 使用 installedChunkData[1]（即 Promise 的 reject 函数）来处理错误\n                    installedChunkData[1](error);\n                  }\n                }\n              };\n              \n              // 通过动态 Script 标签加载分离的 chunk 代码块\n              __webpack_require__.l(\n                url,\n                loadingEnded,\n                "chunk-" + chunkId,\n                chunkId\n              );\n            }\n          }\n        }\n      };\n\n      // no prefetching\n\n      // no preloaded\n\n      // no HMR\n\n      // no HMR manifest\n\n      // no on chunks loaded\n\n      // install a JSONP callback for chunk loading\n      \n      // 当异步 chunk 文件所在的 <script> 加载完成后，会触发该函数执行\n      // 该函数的作用是将 chunk 文件的模块映射对象合并到现有的模块映射对象 __webpack_require__.m\n      // 并将 installedChunks[chunkId] 设置为 0，表示该模块加载完成\n      var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n      \n        // chunkIds（chunkId 数组）\n        \n        // moreModules（chunk 文件映射对象，和 __webpack_require__.m \n        // 以及 __webpack_modules__ 的结构一样）\n        \n        // runtime（暂时忽略，这里没有使用到）\n        var [chunkIds, moreModules, runtime] = data;\n        // add "moreModules" to the modules object,\n        // then flag all "chunkIds" as loaded and fire callback\n        var moduleId,\n          chunkId,\n          i = 0;\n          \n        // 检查 chunkIds 中是否有模块尚未加载（installedChunks[id] !== 0）\n        // 将 moreModules 中未加载的模块添加到模块映射对象 __webpack_require__.m 中\n        if (chunkIds.some((id) => installedChunks[id] !== 0)) {\n          for (moduleId in moreModules) {\n            // 判断 moreModules 中是否有 moduleId 属性\n            if (__webpack_require__.o(moreModules, moduleId)) {\n                // 将 moreModules 中的模块映射对象合并到\n                // 现有的模块映射对象 __webpack_require__.m 中\n              __webpack_require__.m[moduleId] = moreModules[moduleId];\n            }\n          }\n          \n          // 在本示例中没有 runtime 函数，所以这里不会执行\n          if (runtime) var result = runtime(__webpack_require__);\n        }\n        \n        // 如果 chunkLoadingGlobal.push 函数存在\n        // 则将 chunk 文件对应的 data 数据添加到 chunkLoadingGlobal 中\n        // 即添加到 window.webpackJsonp_webpack-runtime-analyze 数组中\n        if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n        \n        // 函数遍历 chunkIds，\n        // 如果 installedChunks[chunkId] 为 [resolve, reject, Promise]\n        // 说明当前模块的状态为加载中\n        \n        // 执行 installedChunks[chunkId][0]()\n        // 即执行 __webpack_require__.f.j 中创建的 Promise 对象的 resolve 函数\n        \n        // 然后将 installedChunks[chunkId] 设置为 0，表示该模块加载完成\n        for (; i < chunkIds.length; i++) {\n          chunkId = chunkIds[i];\n          if (\n            __webpack_require__.o(installedChunks, chunkId) &&\n            installedChunks[chunkId]\n          ) {\n            installedChunks[chunkId][0]();\n          }\n          installedChunks[chunkId] = 0;\n        }\n      };\n\n\n      // 重点：Webpack 的 output.chunkLoadingGlobal 的配置值在此生效\n      // output.chunkLoadingGlobal = webpackJsonp_webpack-runtime-analyze\n      \n      // 这行代码创建了一个全局数组 chunkLoadingGlobal（即 window.webpackJsonp_webpack-runtime-analyze）\n      // 用于存储所有的 chunk 文件的数据\n      var chunkLoadingGlobal = (self["webpackJsonp_webpack-runtime-analyze"] =\n        self["webpackJsonp_webpack-runtime-analyze"] || []);\n      // 这行代码遍历 chunkLoadingGlobal 中的每个元素\n      // 对每个元素执行 webpackJsonpCallback 函数\n      chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\n      \n      // 重写 chunkLoadingGlobal.push 方法\n      // 当执行 chunkLoadingGlobal.push 方法时\n      // 会自动执行 webpackJsonpCallback 函数\n      \n      // 在 chunk 文件所在的 <script> 加载完成后\n      // 会触发 chunk 文件中的 chunkLoadingGlobal.push 方法执行\n      // 从而触发 webpackJsonpCallback 函数执行\n      chunkLoadingGlobal.push = webpackJsonpCallback.bind(\n        null,\n        chunkLoadingGlobal.push.bind(chunkLoadingGlobal)\n      );\n    })();\n\n    // startup\n    // Load entry module and return exports\n    // This entry module can\'t be inlined because the eval devtool is used.\n    var __webpack_exports__ = __webpack_require__("./src/index.js");\n\n    return __webpack_exports__;\n  })();\n});\n\n'})}),"\n",(0,r.jsx)(e.p,{children:"由于上述代码过于复杂，在这里可以做一下简化，如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// dist/main.js\n(function webpackUniversalModuleDefinition(root, factory) {\n  // UMD 规范的代码，支持 CommonJS、AMD 和浏览器运行环境\n  if (typeof exports === "object" && typeof module === "object")\n    module.exports = factory();\n  else if (typeof define === "function" && define.amd) define([], factory);\n  else if (typeof exports === "object") exports["myLibrary"] = factory();\n  // 如果在浏览器中通过 <script> 标签引入，那么这里的代码会被执行\n  // root 是全局对象，例如在浏览器中就是 window\n  else root["myLibrary"] = factory();\n})(self, () => {\n  return (() => {\n    // webpackBootstrap\n    // 这里是模块化路径对应的模块化包装函数，上一节课中已经详细讲解\n    var __webpack_modules__ = {\n      "./src/index.js": (\n        __unused_webpack_module,\n        __unused_webpack_exports,\n        __webpack_require__\n      ) => {\n        eval(\n          // src/index.js 的模块化处理源码\n          "xxx"\n        );\n      },\n    };\n\n    // The module cache\n    // 模块化缓存对象\n    var __webpack_module_cache__ = {};\n\n    // The require function\n    // 该函数的作用是根据模块路径加载模块，如果有缓存则直接获取缓存对象\n    function __webpack_require__(moduleId) {}\n\n    // expose the modules object (__webpack_modules__)\n    // 将 __webpack_modules__ 赋值给 __webpack_require__.m\n    __webpack_require__.m = __webpack_modules__;\n\n    /* webpack/runtime/define property getters */\n    (() => {\n      __webpack_require__.d = (exports, definition) => {};\n    })();\n\n    /* webpack/runtime/ensure chunk */\n    (() => {\n      // __webpack_require__.f 内部存储了所有的加载器处理函数\n      // 例如 f.j 用于加载 script\n      __webpack_require__.f = {};\n      \n      // This file contains only the entry chunk.\n      // The chunk loading function for additional chunks\n      // 该函数会在 ./src/index.js 中执行 \n      // __webpack_require__.e(/*! import() */ "src_single-spa_js") 时调用\n      \n      // 用于对 chunk 进行加载器的批量处理,\n      // 在这个示例中主要用于异步加载 chunk 文件（src_single-spa_js）\n      __webpack_require__.e = (chunkId) => {\n         // 这里会调用 __webpack_require__.f.j\n      };\n    })();\n\n    /* webpack/runtime/get javascript chunk filename */\n    (() => {\n      // This function allow to reference async chunks\n      // 主要作用是计算 chunk 文件名\n      __webpack_require__.u = (chunkId) => {};\n    })();\n\n    /* webpack/runtime/global */\n    (() => {\n      // 主要作用是计算 window 全局对象并将其赋值给 __webpack_require__.g\n      __webpack_require__.g = (function () {})();\n    })();\n\n    /* webpack/runtime/hasOwnProperty shorthand */\n    (() => {\n      // 用于检查一个对象是否有某个自身属性（即不包括继承的属性）\n      __webpack_require__.o = (obj, prop) =>\n        Object.prototype.hasOwnProperty.call(obj, prop);\n    })();\n\n    /* webpack/runtime/load script */\n    (() => {\n      var inProgress = {};\n      var dataWebpackPrefix = "myLibrary:";\n      // loadScript function to load a script via script tag\n      \n      // 主要作用是通过创建和插入一个 <script> 标签来动态加载一个 chunk 文件\n      __webpack_require__.l = (url, done, key, chunkId) => {};\n    })();\n\n    /* webpack/runtime/make namespace object */\n    (() => {\n      \n      // 该函数用于定义 ES6 模块的标准行为\n      // 即为模块化导出对象 __webpack_exports__ 定义 __esModule 属性值等\n      // 可用于识别 __webpack_exports__ 的模块性质\n      __webpack_require__.r = (exports) => {}\n      \n    })();\n\n    /* webpack/runtime/publicPath */\n    // 这个函数的主要作用是确定 Webpack 的公共路径（publicPath）\n    // 这是 Webpack 用来确定异步加载的模块的 URL 的基础路径\n    (() => {\n      var scriptUrl;\n      // 省略计算过程\n      __webpack_require__.p = scriptUrl;\n    })();\n\n    /* webpack/runtime/jsonp chunk loading */\n    (() => {\n      \n      // installedChunks 对象存储了已加载和正在加载的模块。其值的含义如下：\n      // undefined：模块未加载\n      // [resolve, reject, Promise]：模块正在加载\n      // 0：模块已加载\n      var installedChunks = {\n        main: 0,\n      };\n\n      // 1. 初始化异步 chunk 文件的加载状态 installedChunks\n      // 当异步 chunk 文件所在的 <script> 加载完成后\n      // 会在 webpackJsonpCallback 中进行 promise.resolve 和 installedChunks[chunkId] = 0 处理\n      \n      // 2. 执行 __webpack_require__.l 函数\n      // 动态创建 <script> 标签，加载分离的 chunk 代码块\n      __webpack_require__.f.j = (chunkId, promises) => {};\n\n      // no prefetching\n\n      // no preloaded\n\n      // no HMR\n\n      // no HMR manifest\n\n      // no on chunks loaded\n\n      // install a JSONP callback for chunk loading\n      \n      // 当异步 chunk 文件所在的 <script> 加载完成后，会触发该函数执行\n      // 该函数的作用是将 chunk 文件的模块映射对象合并到现有的模块映射对象 __webpack_require__.m\n      // 并将 installedChunks[chunkId] 设置为 0，表示该模块加载完成\n      var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {};\n\n      // 这行代码创建了一个全局数组 chunkLoadingGlobal\n      // 即 window.webpackJsonp_webpack-runtime-analyze\n      \n      // 用于存储所有的 chunk 文件的数据\n      var chunkLoadingGlobal = (self["webpackJsonp_webpack-runtime-analyze"] =\n        self["webpackJsonp_webpack-runtime-analyze"] || []);\n      // 这行代码遍历 chunkLoadingGlobal 中的每个元素\n      // 对每个元素执行 webpackJsonpCallback 函数\n      chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\n      \n      // 重写 chunkLoadingGlobal.push 方法\n      // 当执行 chunkLoadingGlobal.push 方法时\n      // 会自动执行 webpackJsonpCallback 函数\n      \n      // 在 chunk 文件所在的 <script> 加载完成后\n      // 会触发 chunk 文件中的 chunkLoadingGlobal.push 方法执行\n      // 从而触发 webpackJsonpCallback 函数执行\n      chunkLoadingGlobal.push = webpackJsonpCallback.bind(\n        null,\n        chunkLoadingGlobal.push.bind(chunkLoadingGlobal)\n      );\n    })();\n\n    // startup\n    // Load entry module and return exports\n    // This entry module can\'t be inlined because the eval devtool is used.\n    // 执行 ./src/index.js 对应的模块化包装函数\n    var __webpack_exports__ = __webpack_require__("./src/index.js");\n\n    return __webpack_exports__;\n  })();\n});\n\n'})}),"\n",(0,r.jsxs)(e.p,{children:["其中\xa0",(0,r.jsx)(e.code,{children:"src/index.js"})," 对应的模块化包装函数中的\xa0",(0,r.jsx)(e.code,{children:"eval"}),"\xa0代码如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 通过调用 __webpack_require__.e 函数\n// 会动态创建 <script> 标签异步加载 chunk 文件 \n\n// 内部会调用 __webpack_require__.f.j 函数\n// 根据 chunkId 加载 chunk 文件\n\n// 同时会标记 chunk 文件的加载状态\n// 如果已经加载过，则不会重复加载（可以试试重复的动态导入）\n__webpack_require__\n  .e(/*! import() */ "src_single-spa_js")\n  .then(\n    // chunk 加载成功后\n    // 会在 __webpack_modules__ 以及 __webpack_require__.m 模块化映射对象中\n    // 建立新加载 chunk 的模块映射关系\n    \n    // 因此这里可以通过 __webpack_require__ 函数加载 chunk 文件\n    // 并返回模块的 模块化导出 exports 对象\n    __webpack_require__.bind(\n      __webpack_require__,\n      /*! ./single-spa.js */ "./src/single-spa.js"\n    )\n  )\n  // 通过链式调用，可以获取到新加载的 chunk 文件的 exports 对象\n  .then((res) => {\n    // 这里的 res 就是 chunk 文件的 exports 对象\n    console.log(res);\n  });\n\n//# sourceURL=webpack://myLibrary/./src/index.js?\n'})}),"\n",(0,r.jsxs)(e.p,{children:["我们先来分析一下主运行时代码\xa0",(0,r.jsx)(e.code,{children:"dist/main.js"}),"和\xa0",(0,r.jsx)(e.code,{children:"src/index.js"}),"\xa0模块化包装函数中的\xa0",(0,r.jsx)(e.code,{children:"eval"}),"代码，如下所示："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["通过\xa0UMD\xa0模式执行\xa0",(0,r.jsx)(e.code,{children:"factory"})," 函数"]}),"\n",(0,r.jsxs)(e.li,{children:["定义模块化映射对象\xa0",(0,r.jsx)(e.code,{children:"__webpack_modules__"}),"(包含了\xa0",(0,r.jsx)(e.code,{children:"src/index.js"}),"\xa0模块化包装代码)"]}),"\n",(0,r.jsxs)(e.li,{children:["定义模块化运行时函数\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__"})," （增加了模块的缓存处理）以及各种运行时方法"]}),"\n",(0,r.jsxs)(e.li,{children:["使用\xa0",(0,r.jsx)(e.code,{children:"__webpack_modules__.m"}),"\xa0引用\xa0",(0,r.jsx)(e.code,{children:"__webpack_modules__"}),"\xa0模块化映射对象"]}),"\n",(0,r.jsxs)(e.li,{children:["计算\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.p"})," （计算拼装\xa0chunk\xa0文件\xa0URL\xa0需要的\xa0",(0,r.jsx)(e.code,{children:"publicPath"}),"）"]}),"\n",(0,r.jsxs)(e.li,{children:["声明\xa0",(0,r.jsx)(e.code,{children:"webpackJsonpCallback"}),"\xa0函数，主要用于合并异步\xa0chunk\xa0文件的模块映射对象"]}),"\n",(0,r.jsxs)(e.li,{children:["开辟\xa0",(0,r.jsx)(e.code,{children:"window.webpackJsonp_webpack-runtime-analyze"})," 数组，用于存放异步\xa0chunk\xa0文件的数据（包括\xa0chunkId、模块映射对象等）"]}),"\n",(0,r.jsxs)(e.li,{children:["重写\xa0",(0,r.jsx)(e.code,{children:"window.webpackJsonp_webpack-runtime-analyze.push"}),"，使其指向\xa0",(0,r.jsx)(e.code,{children:"webpackJsonpCallback"}),"\xa0函数"]}),"\n",(0,r.jsxs)(e.li,{children:["执行\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__"}),"\xa0获取\xa0",(0,r.jsx)(e.code,{children:"src/index.js"})," 对应的模块化包装函数（内含",(0,r.jsx)(e.code,{children:"eval"}),"代码）","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["执行\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.e"})," 动态加载\xa0chunk\xa0文件并标记模块的加载状态"]}),"\n",(0,r.jsxs)(e.li,{children:["使用\xa0",(0,r.jsx)(e.code,{children:"<script>"}),"\xa0标签加载\xa0chunk\xa0文件成功后，会立即执行\xa0chunk\xa0文件的脚本并调用\xa0",(0,r.jsx)(e.code,{children:"window.webpackJsonp_webpack-runtime-analyze.push"}),"，此时会将\xa0chunk\xa0对应的模块映射对象合并到\xa0",(0,r.jsx)(e.code,{children:"__webpack_modules__.m"})," 中"]}),"\n",(0,r.jsxs)(e.li,{children:["在\xa0",(0,r.jsx)(e.code,{children:"then"})," 回调中执行\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__"}),"\xa0获取并执行\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"})," 模块路径对应的模块化包装函数，返回相应的模块化导出对象"]}),"\n",(0,r.jsxs)(e.li,{children:["在链式调用的\xa0",(0,r.jsx)(e.code,{children:"then"})," 中获取\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"}),"\xa0的模块化导出对象"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["将\xa0",(0,r.jsx)(e.code,{children:"src/index.js"}),"\xa0的模块化导出对象\xa0",(0,r.jsx)(e.code,{children:"__webpack_exports__"}),"赋值给\xa0",(0,r.jsx)(e.code,{children:"window.myLibrary"})]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：上述的\xa0chunk\xa0文件或者\xa0chunk\xa0文件在动态导入示例中指代\xa0Webpack\xa0分离的\xa0",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"}),"文件。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在\xa0",(0,r.jsx)(e.code,{children:"src/index.js"}),"\xa0的模块化包装函数中会执行\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.e"}),"\xa0异步加载\xa0",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"}),"，该\xa0chunk\xa0文件的构建代码如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// dist/src_single-spa_js.js\n"use strict";\n(self["webpackJsonp_webpack-runtime-analyze"] = self["webpackJsonp_webpack-runtime-analyze"] || []).push([\n  ["src_single-spa_js"],\n  {\n    /***/ "./src/single-spa.js":\n      /*!***************************!*\\\n  !*** ./src/single-spa.js ***!\n  \\***************************/\n      /***/ (\n        __unused_webpack_module,\n        __webpack_exports__,\n        __webpack_require__\n      ) => {\n        eval(\n          \'__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\\n/* harmony export */   mount: () => (/* binding */ mount),\\n/* harmony export */   unmount: () => (/* binding */ unmount),\\n/* harmony export */   update: () => (/* binding */ update)\\n/* harmony export */ });\\nasync function bootstrap() {\\n\\tconsole.log("bootstrap");\\n  }\\n  \\n  async function mount() {\\n\\tconsole.log("mount");\\n  }\\n  \\n  async function unmount() {\\n\\tconsole.log("unmount");\\n  }\\n  \\n  async function update() {\\n\\tconsole.log("update");\\n  }\\n\\n//# sourceURL=webpack://myLibrary/./src/single-spa.js?\'\n        );\n\n        /***/\n      },\n  },\n]);\n'})}),"\n",(0,r.jsxs)(e.p,{children:["其中\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"})," 对应的模块化包装函数中的\xa0",(0,r.jsx)(e.code,{children:"eval"}),"\xa0代码如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 首先定义 ES 模块的标准行为，\n// 可以通过标准行为识别 __webpack_exports__ 为 ES 模块\n__webpack_require__.r(__webpack_exports__);\n\n// 为 __webpack_exports__ 对象定义源码中的 ES 模块导出值，即 bootstrap、mount、unmount、update 四个函数\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\n/* harmony export */   mount: () => (/* binding */ mount),\n/* harmony export */   unmount: () => (/* binding */ unmount),\n/* harmony export */   update: () => (/* binding */ update)\n/* harmony export */ });\nasync function bootstrap() {\n	console.log("bootstrap");\n  }\n  \n  async function mount() {\n	console.log("mount");\n  }\n  \n  async function unmount() {\n	console.log("unmount");\n  }\n  \n  async function update() {\n	console.log("update");\n  }\n\n//# sourceURL=webpack://myLibrary/./src/single-spa.js?\n'})}),"\n",(0,r.jsxs)(e.p,{children:["因此在\xa0",(0,r.jsx)(e.code,{children:"src/index.js"}),"\xa0对应的模块化包装函数中使用\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.e"}),"\xa0异步加载\xa0",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"})," 的详细执行流程如下所示："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["调用\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.e"}),"，内部会遍历加载器从而调用\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.f.j"}),"，返回一个\xa0",(0,r.jsx)(e.code,{children:"Promise.all"})," 用于等待所有的加载器执行完成"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["执行\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.f.j"}),"，通过\xa0",(0,r.jsx)(e.code,{children:"installedChunks"})," 标记\xa0chunk\xa0文件的异步加载状态，内部会调用\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.l"}),"\xa0 动态创建\xa0",(0,r.jsx)(e.code,{children:"<script>"}),"\xa0加载\xa0chunk\xa0文件"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"})," chunk\xa0文件通过\xa0",(0,r.jsx)(e.code,{children:"<script>"}),"\xa0标签加载完成后，浏览器会立即执行该脚本，脚本会立即执行\xa0",(0,r.jsx)(e.code,{children:"window.webpackJsonp_webpack-runtime-analyze.push"}),"\xa0从而触发\xa0",(0,r.jsx)(e.code,{children:"webpackJsonpCallback"}),"函数的执行"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["在\xa0",(0,r.jsx)(e.code,{children:"webpackJsonpCallback"}),"\xa0函数中合并当前异步加载的\xa0chunk\xa0文件对应的模块映射对象到\xa0",(0,r.jsx)(e.code,{children:"__webpack_modules__.m"})," 中，并将\xa0",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"})," 对应的异步模块的加载状态设置为加载完成，并执行\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.f.j"})," 加载器对应的\xa0",(0,r.jsx)(e.code,{children:"promise.resolve"}),"，从而触发\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.e"}),"\xa0的\xa0",(0,r.jsx)(e.code,{children:"then"}),"回调"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["在\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.e"}),"\xa0的\xa0",(0,r.jsx)(e.code,{children:"then"})," 回调中通过\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__"})," 执行 ",(0,r.jsx)(e.code,{children:"src/single-spa.js"})," 对应的模块化包装函数，并返回对应的模块化导出对象 ",(0,r.jsx)(e.code,{children:"__webpack_exports__"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["执行\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.r"})," 定义\xa0",(0,r.jsx)(e.code,{children:"__webpack_exports__"}),"\xa0的\xa0ES\xa0模块标准行为"]}),"\n",(0,r.jsxs)(e.li,{children:["执行\xa0",(0,r.jsx)(e.code,{children:"__webpack_require__.d"})," 将当前模块的导出值赋值给\xa0",(0,r.jsx)(e.code,{children:"__webpack_exports__"})," 对象"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["在",(0,r.jsx)(e.code,{children:"__webpack_require__.e"})," 链式调用中获取\xa0",(0,r.jsx)(e.code,{children:"src/single-spa.js"}),"\xa0的模块化导出对象进行处理"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：通过\xa0",(0,r.jsx)(e.code,{children:"<script>"}),"\xa0脚本异步加载\xa0chunk\xa0文件\xa0",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"}),"\xa0时，如果加载超时或者失败，还会进行加载模块的状态重置处理，从而可以在下一次加载时进行加载重试。如果加载完成，那么会删除\xa0",(0,r.jsx)(e.code,{children:"<script>"}),"\xa0标签并释放对应的\xa0JS\xa0资源防止内存泄漏。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["通过\xa0",(0,r.jsx)(e.code,{children:"import()"}),"\xa0动态加载的构建代码的整体运行时流程如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:t,alt:"Webpack 运行时分析-流程图 (1).jpg"})}),"\n",(0,r.jsx)(e.p,{children:"我们重新回顾一下 Webpack 的配置："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// webpack 5.x\nconst packageName = require('./package.json').name;\n\nmodule.exports = {\n  output: {\n    // library 和 libraryTarget 用于暴露微应用的生命周期函数\n    library: `${packageName}-[name]`,\n    libraryTarget: 'umd',\n    // chunkLoadingGlobal 用于代码分割\n    // chunkLoadingGlobal = webpackJsonp_webpack-runtime-analyze\n    chunkLoadingGlobal: `webpackJsonp_${packageName}`,\n  },\n};\n\n// package.json\n{\n  \"name\": \"webpack-runtime-analyze\"\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["再来看一下构建后的 ",(0,r.jsx)(e.code,{children:"dist/main.js"})," 中的部分代码："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n    var [chunkIds, moreModules, runtime] = data;\n    // add "moreModules" to the modules object,\n    // then flag all "chunkIds" as loaded and fire callback\n    var moduleId,\n      chunkId,\n      i = 0;\n    if (chunkIds.some((id) => installedChunks[id] !== 0)) {\n      for (moduleId in moreModules) {\n        if (__webpack_require__.o(moreModules, moduleId)) {\n          __webpack_require__.m[moduleId] = moreModules[moduleId];\n        }\n      }\n      if (runtime) var result = runtime(__webpack_require__);\n    }\n    if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n    for (; i < chunkIds.length; i++) {\n      chunkId = chunkIds[i];\n      if (\n        __webpack_require__.o(installedChunks, chunkId) &&\n        installedChunks[chunkId]\n      ) {\n        installedChunks[chunkId][0]();\n      }\n      installedChunks[chunkId] = 0;\n    }\n};\n\n// 可以发现这里的 webpackJsonp_webpack-runtime-analyze \n// 就是 Webpack 的配置的 chunkLoadingGlobal\nvar chunkLoadingGlobal = (self["webpackJsonp_webpack-runtime-analyze"] =\nself["webpackJsonp_webpack-runtime-analyze"] || []);\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\n\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(\nnull,\nchunkLoadingGlobal.push.bind(chunkLoadingGlobal)\n);\n'})}),"\n",(0,r.jsxs)(e.p,{children:["并且在 ",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"})," 中也会使用该全局属性，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// dist/src_single-spa_js.js\n"use strict";\n(self["webpackJsonp_webpack-runtime-analyze"] = self["webpackJsonp_webpack-runtime-analyze"] || []).push([\n  ["src_single-spa_js"],\n  {\n    /***/ "./src/single-spa.js":\n      /*!***************************!*\\\n  !*** ./src/single-spa.js ***!\n  \\***************************/\n      /***/ (\n        __unused_webpack_module,\n        __webpack_exports__,\n        __webpack_require__\n      ) => {\n        eval(\n          \'__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   bootstrap: () => (/* binding */ bootstrap),\\n/* harmony export */   mount: () => (/* binding */ mount),\\n/* harmony export */   unmount: () => (/* binding */ unmount),\\n/* harmony export */   update: () => (/* binding */ update)\\n/* harmony export */ });\\nasync function bootstrap() {\\n\\tconsole.log("bootstrap");\\n  }\\n  \\n  async function mount() {\\n\\tconsole.log("mount");\\n  }\\n  \\n  async function unmount() {\\n\\tconsole.log("unmount");\\n  }\\n  \\n  async function update() {\\n\\tconsole.log("update");\\n  }\\n\\n//# sourceURL=webpack://myLibrary/./src/single-spa.js?\'\n        );\n\n        /***/\n      },\n  },\n]);\n'})}),"\n",(0,r.jsxs)(e.p,{children:["可以发现 ",(0,r.jsx)(e.code,{children:"window.webpackJsonp_webpack-runtime-analyze"})," 是实现 ",(0,r.jsx)(e.code,{children:"dist/main.js"})," 和 ",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"})," 之间的通信对象，通过该对象可以将 ",(0,r.jsx)(e.code,{children:"dist/src_single-spa_js.js"})," 所在的异步模块添加到 ",(0,r.jsx)(e.code,{children:"dist/main.js"})," 所在的模块化映射对象\xa0",(0,r.jsx)(e.code,{children:"__webpack_modules__.m"})," 中。因此这个全局属性对应的 Webpack 配置 ",(0,r.jsx)(e.code,{children:"chunkLoadingGlobal"})," 在微应用中需要保证唯一性，否则多个微应用加载时如果没有做好隔离，互相之间的 ",(0,r.jsx)(e.code,{children:"chunkLoadingGlobal"})," 可能会因为名称相同而被覆盖，从而可能产生意想不到的问题。"]}),"\n",(0,r.jsxs)(e.p,{children:["除此之外，我们也了解到动态加载 ",(0,r.jsx)(e.code,{children:"import()"})," 本质上就是通过动态 ",(0,r.jsx)(e.code,{children:"<script>"})," 进行加载，因此所谓的按需加载就是利用了 Webpack 内部实现动态 ",(0,r.jsx)(e.code,{children:"<script>"})," 加载。"]}),"\n",(0,r.jsxs)(e.h2,{id:"fetch-示例",children:["Fetch 示例",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#fetch-示例",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"了解了 Webpack 配置的代码分割运行时原理后，我们可以设计一个基于代码分割的微前端方案。整体的目录结构如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"├── packages                                                                       \n│   ├── main-app/                # 主应用\n│   ├── react-app/               # React 微应用\n│   ├── single-spa/              # single-spa 5.9.5 版本\n│   └── vue-app/                 # Vue 微应用\n└── lerna.json                   # Lerna 配置\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的\xa0",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/code_splitting",target:"_blank",rel:"noopener noreferrer",children:"demo/code_splitting"}),"\xa0分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["Fetch 方案示例的实现流程如下所示，当主应用切换路由时会先失活没有匹配路由的微应用，执行相应的\xa0",(0,r.jsx)(e.code,{children:"unmount"}),"\xa0函数卸载微应用，然后会激活匹配路由的微应用，通过 Fetch 请求获取微应用的脚本文本，然后使用\xa0",(0,r.jsx)(e.code,{children:"eval"}),"\xa0执行脚本代码，并立即获取执行代码后的微应用生命周期函数，最后执行\xa0",(0,r.jsx)(e.code,{children:"mount"}),"\xa0函数挂载应用，从而实现监听路由切换微应用的功能："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:"yuque_diagram (2).jpg"})}),"\n",(0,r.jsxs)(e.h3,{id:"主应用设计",children:["主应用设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#主应用设计",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"首先来看下 Fetch 示例的实现效果，如下所示，点击左侧的导航切换路由，使用 single-spa 监听路由的变化来切换微应用："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:"录屏2024-03-11 09.10.35.gif"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：切换路由的时候可以通过 Network 发现使用 Fetch 请求获取了微应用的 JS 脚本文本。除此之外，在 single-spa 源码的各个阶段植入了很多打印信息，可以根据打印信息来感性了解 single-spa 的内部运行机制。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"主应用的目录结构如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"├── src                  \n│   ├── index.js            # 入口文件，包含了 single-spa 的注册和 React 路由             \n│   ├── App.js              # 主应用布局，包含了导航和内容区的布局设计           \n│   └── utils/              # 工具方法\n│        ├── micros.js      # 微应用数据信息（Mock 后端数据结构）      \n│        └── single-spa.ts  # single-spa 的注册 API 封装\n"})}),"\n",(0,r.jsxs)(e.p,{children:["在\xa0",(0,r.jsx)(e.code,{children:"src/utils/micros.js"}),"\xa0中定义了微应用列表的数据结构（在真实业务场景中这个数据会更复杂，并且可以从服务端进行动态加载），该数据主要用于注册 single-spa 的微应用、生成 React 路由和主应用导航，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/utils/micros.js\n\nimport { IMicroApp } from "../types";\n\n// 微应用容器元素的 ID\nexport const MICRO_APP_CONTAINER_ID = "micro-app-container";\n\nexport const MICRO_APP_ROUTER = {\n  REACT: "react",\n  VUE: "vue",\n};\n\n// 菜单信息，这里用于 Mock 后端数据\n// 真实业务可能是一个树状的带权限的菜单信息\nexport const mockMicroApps: IMicroApp[] = [\n  {\n    // 应用标识\n    name: "react",\n    // 菜单名称\n    title: "React Micro App",\n    // 应用地址\n    // 注意这里因为使用了代码分割，所以存在分割的 chunk 文件\n    // 注意由于遍历执行 entry 中的脚本，需要和 HTML 中 <script> 标签的放置顺序保持一致\n    // 分离出来的 chunk 文件需要优先于主文件执行\n    entry: [\n      "http://localhost:3000/vendors.js",\n      "http://localhost:3000/main.js",\n    ],\n    // 激活路由\n    router: MICRO_APP_ROUTER.REACT,\n  },\n  {\n    name: "vue",\n    title: "Vue Micro App",\n    entry: [\n      "http://localhost:8080/js/chunk-vendors.js",\n      "http://localhost:8080/js/app.js",\n    ],\n    router: MICRO_APP_ROUTER.VUE,\n  },\n];\n'})}),"\n",(0,r.jsx)(e.p,{children:"主应用在初始化时需要消费微应用列表数据，在初始化时使用 single-spa 注册微应用并生成对应的 React 路由："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import React from "react";\nimport ReactDOM from "react-dom/client";\nimport "./index.css";\nimport App from "./App.tsx";\nimport reportWebVitals from "./reportWebVitals.js";\nimport { createBrowserRouter, RouterProvider } from "react-router-dom";\nimport { registerMicroApps, fetchApp } from "./utils/single-spa.ts";\nimport { MICRO_APP_CONTAINER_ID, mockMicroApps } from "./utils/micros.ts";\n\n// 对 single-spa 的注册 API 进行了二次封装，支持传入数组进行批量注册\nregisterMicroApps(\n  // 根据后端提供的动态数据批量注册微应用\n  mockMicroApps.map((item) => ({\n    name: item.name,\n    app: () => {\n      // 通过 Fetch 请求方式获取\n      return fetchApp(item.entry);\n    },\n    activeWhen: item.router,\n    customProps: {\n      // 向微应用传递需要挂载的容器元素 ID\n      container: MICRO_APP_CONTAINER_ID,\n    },\n  }))\n);\n\nconst router = createBrowserRouter([\n  {\n    path: "/",\n    // <App /> 中提供了左侧导航栏和右侧内容区域的布局结构\n    element: <App />,\n    // children 中的元素会被渲染到 <App /> 的 <Outlet /> 中\n    // <Outlet> 是 react-router-dom 提供的一个组件，用于渲染子路由：https://reactrouter.com/en/main/components/outlet\n\n    // 遍历迭代 mockMicroApps 中的数据，生成对应的路由配置\n    // 这里的路由配置和微应用注册 API 中的 activeWhen 一致\n    children: mockMicroApps.map((item) => ({\n      path: item.router,\n      // 微应用的容器元素，用于渲染微应用\n      element: <div id={MICRO_APP_CONTAINER_ID}></div>,\n    })),\n  },\n]);\n\nconst root = ReactDOM.createRoot(document.getElementById("root")!);\nroot.render(<RouterProvider router={router} />);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在\xa0",(0,r.jsx)(e.code,{children:"src/utils/single-spa.ts"}),"\xa0中重点看下\xa0",(0,r.jsx)(e.code,{children:"fetchApp"}),"\xa0的实现，通过\xa0",(0,r.jsx)(e.code,{children:"window.fetch"}),"\xa0获取微应用的 JS 脚本文本进行动态执行，执行完成后立马获取相应的生命周期函数："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 这里使用 npm link 进行连接调试\nimport { start, registerApplication } from "single-spa/src/single-spa";\nimport { LifeCycles, RegisterApplicationConfig } from "single-spa";\n\n// 对 single-spa 的 registerApplication 进行二次封装，使其可以接收一个数组，批量注册子应用\nexport function registerMicroApps(apps: RegisterApplicationConfig[]) {\n  // @ts-ignore\n  // 如果不开启 __DEV__，single-spa 的源码无法正常运行\n  window.__DEV__ = true;\n  apps.forEach(registerApplication);\n  start();\n}\n\nexport function getAppLifeCycles() {\n  // 使用 UMD 进行子应用的构建，挂载全局变量的动作是在内部微应用的代码执行完毕后\n  // 例如 root["myLibrary"] = factory(), 这里的 factory 包含了内部微应用代码的执行\n  // 因此这里通过遍历全局对象的属性顺序拿到子应用的生命周期函数\n\n  // Object.keys 可以获取到对象的属性\n  // 对象自身属性的返回顺序查看 ECMAScript 2015 标准：\n  // https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys\n\n  // 按照这个规范，Object.keys() 的返回顺序如下：\n\n  // 数字键（整数索引），按照升序排列。\n  // 字符串键，按照它们被添加到对象的顺序。\n  // 符号键，按照它们被添加到对象的顺序。\n  // 由于 Object.keys() 只返回字符串键，因此只需要关心数字键和字符串键。\n  // 数字键会被视为数组索引并按照数值升序排列，而字符串键则会按照它们创建时的顺序排列。\n  // 符号键不会被 Object.keys() 返回，但如果要获取它们，可以使用 Object.getOwnPropertySymbols()。\n\n  // 注意，这里的“数字键”指的是那些可被转换为32位无符号整数的字符串键，它们属于数组索引的范围，即在0到2^32-1之间的整数。\n  // 对于这些数字键，即使它们是作为对象的属性添加的，它们也会被当作数组索引并按照数值排序。其他非数字的字符串键则按照它们添加到对象的顺序进行枚举。\n\n  // 需要注意和 for...in 的区别，for...in 还能遍历原型链上的属性\n\n  // for...in\n  // https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-for-in-and-for-of-statements-static-semantics-early-errors\n\n  const keys = Object.keys(window);\n  const lifeCycles = window[keys[keys.length - 1]];\n  console.info(\n    "%c当前 window 对象的最后一个属性是：%c" + keys[keys.length - 1],\n    "color: blue; font-weight: bold; font-size: 20px;",\n    "color: red; font-weight: bold; font-size: 20px;"\n  );\n  return lifeCycles as LifeCycles;\n}\n\nexport async function fetchApp(urls: string[]) {\n  // 在上一个 Fetch 示例中没有进行代码分割，只需要请求单个 Bundle 文件进行执行\n  // 而在本示例中因为进行了代码分离，因此需要遍历执行微应用的所有脚本\n  // 这里需要先执行分离的 chunk 文件，后执行主文件\n  for (let url of urls) {\n    const res = await window.fetch(url);\n    const text = await res.text();\n    // 使用 eval 执行\n    (0, eval)(text);\n  }\n\n  // 执行微应用的代码后立即获取对应的生命周期函数\n  return getAppLifeCycles();\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["最后在\xa0",(0,r.jsx)(e.code,{children:"<App>"}),"\xa0中对主应用进行布局设计，将左侧设计成能够切换路由的导航，导航的信息来源于微应用数据列表，右侧设计成用于渲染微应用的内容区："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-jsx",children:'// src/App.js\nimport { Outlet, Link } from "react-router-dom";\nimport "./App.css";\nimport { mockMicroApps } from "./utils/micros";\n\nfunction App() {\n  return (\n    <div className="app">\n      <div className="app-nav">\n        <p>Micro App List</p>\n        <nav>\n          <ul>\n            {/* 遍历微应用的数据列表生成导航路由信息 */}\n            {mockMicroApps.map((item) => (\n              <li key={item.name}>\n                <Link to={item.router}>{item.title}</Link>\n              </li>\n            ))}\n          </ul>\n        </nav>\n      </div>\n      <div className="app-content">\n        {/* 这里的 <Outlet /> 会被 <RouterProvider router={router} /> 中 router 提供的 children 进行替换 */}\n        {/* 所以本质上会被微应用的容器元素 <div id={MICRO_APP_CONTAINER_ID}></div> 替代  */}\n        <Outlet />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"微应用设计",children:["微应用设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#微应用设计",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本示例采用了代码分割，除了上个课程中的 UMD 导出配置外，需要额外注意和代码分割息息相关的 ",(0,r.jsx)(e.code,{children:"chunkLoadingGlobal"}),"，本课程的 React 示例需要在\xa0",(0,r.jsx)(e.code,{children:"config/webpack.config.js"}),"\xa0中修改如下配置："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// config/webpack.config.js\n\n// ...\n\n// 保证全局属性的唯一性\nconst { v4: uuidv4 } = require("uuid");\nconst { name } = require("../package.json");\n\n// 确保全局对象属性的唯一性\n// name: 保持微应用的可辨识性\n// uuidv4: 保持全局唯一性\nconst appKey = `${name}_${uuidv4()}`;\n\n//  ...\n\n// This is the production and development configuration.\n// It is focused on developer experience, fast rebuilds, and a minimal bundle.\nmodule.exports = function (webpackEnv) {\n  \n  // ...\n \n  return {\n    \n    output: {\n      // 在 Webpack 的运行时原理中已经说明会计算动态 import 的 publicPath\n      // 通过动态 import 访问时需要计算 publicPath\n      publicPath: `//localhost:${process.env.PORT || 3000}/`,\n      // Point sourcemap entries to original disk location (format as URL on Windows)\n      \n      // 确保唯一性\n      library: appKey,\n      libraryTarget: "umd",\n      // 确保唯一性\n      chunkLoadingGlobal: `webpackJsonp_${appKey}`,\n    },\n    \n    // ...\n    \n    optimization: {\n      // 支持代码分割\n      splitChunks: {\n        chunks: "all",\n        name: "vendors",\n      },\n    \n    // ...\n    \n    plugins: [\n      // ...\n      // 注释该配置\n      // 构建单个 JS 脚本\n      // new webpack.optimize.LimitChunkCountPlugin({\n      //   maxChunks: 1,\n      // }),\n    ].filter(Boolean),\n    // Turn off performance processing because we utilize\n    // our own hints via the FileSizeReporter\n    performance: false,\n  };\n};\n'})}),"\n",(0,r.jsx)(e.p,{children:"同时在 React 微应用的入口文件中导出生命周期函数，如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/index.js\n\nimport React from "react";\nimport ReactDOM from "react-dom/client";\nimport "./index.css";\nimport App from "./App";\n// import reportWebVitals from \'./reportWebVitals\';\n\nlet root;\n\n// 这里可以用于测试动态 import 自动分割，注意需要配置 publicPath\n// 否则请求的 publicPath 会根据主应用的访问地址进行计算\n// 需要新建 about.js 文件并导出内容\n// 例如：src/about.js\n// export function about() {\n//   return "about";\n// }\nimport(/* webpackChunkName: "about" */ "./about.js").then((res) => {\n  console.log(res);\n});\n\n// 判断是否在 single-spa 的环境中运行\n// 如果不是，那么说明不在微前端的环境中，可以独立启动\nif (!window.singleSpaNavigate) {\n  root = ReactDOM.createRoot(document.getElementById("root"));\n  root.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n}\n\n/**\n * bootstrap 只会在微应用首次激活时调用一次\n * 微应用重新激活时会直接调用 mount 周期函数，不会再重复触发 bootstrap。\n * 通常情况下这里不需要进行任何处理，初始化的代码可以放在当前入口文件的顶层处理\n * 除非会执行微应用的 unload 动作，然后需要再次执行 bootstrap，可能需要在此做一些必要的初始化动作\n * 注意这里的周期函数不是 async 函数，在主应用中引入该周期函数后需要进行 async 处理\n */\n\n// 注意这里的每一个生命周期函数必须是 async 函数\nexport async function bootstrap() {\n  console.log("[React 子应用] bootstrap excuted");\n}\n\n/**\n * 微应用每次激活时都会调用 mount 周期函数，通常在这里执行微应用的渲染\n */\nexport async function mount(props) {\n  console.log("[React 子应用] mount excuted, props: ", props);\n  // 在 single-spa 的注册 API 中会通过 customProps 传递 container 微应用容器元素 ID\n  // 因此这里将微应用挂载在主应用的容器元素上\n  root = ReactDOM.createRoot(document.getElementById(props.container));\n  root.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n}\n\n/**\n * 微应用每次失活时会调用 unmount 周期函数，通常在这里执行微应用的卸载\n */\nexport async function unmount(props) {\n  console.log("[React 子应用] unmount excuted, props: ", props);\n  root && root.unmount();\n}\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n\n'})}),"\n",(0,r.jsx)(e.p,{children:"Vue 示例也需要进行更改，首先使其支持代码分割："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// vue.config.js\nconst { defineConfig } = require("@vue/cli-service");\nconst { name } = require("./package.json");\nconst { v4: uuidv4 } = require("uuid");\n\nconst port = 8080;\n\n// 确保全局对象属性的唯一性\n// name: 保持微应用的可辨识性\n// uuidv4: 保持全局唯一性\nconst appKey = `${name}_${uuidv4()}`;\n\nmodule.exports = defineConfig({\n  transpileDependencies: true,\n  css: { extract: false },\n  // 去除文件名哈希\n  filenameHashing: false,\n\n  publicPath: `//localhost:${port}/`,\n\n  configureWebpack: {\n    // 支持代码分割\n    optimization: {\n      splitChunks: {\n        chunks: "all",\n      },\n    },\n    output: {\n      // 保证唯一性\n      library: appKey,\n      libraryTarget: "umd",\n      // 保证唯一性\n      chunkLoadingGlobal: `webpackJsonp_${appKey}`,\n    },\n  },\n  devServer: {\n    port: port, // 设置启动端口号\n    headers: {\n      "Access-Control-Allow-Origin": "*",\n    },\n  },\n});\n'})}),"\n",(0,r.jsx)(e.p,{children:"同时在 Vue 微应用的入口文件中导出生命周期函数，如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/main.js\nimport { createApp } from "vue";\nimport App from "./App.vue";\nlet app;\n\nimport(/* webpackChunkName: "about" */ "./about.js").then((res) => {\n  console.log(res);\n});\n\n// 判断是否在 single-spa 的环境中运行\n// 如果不是，那么说明不在微前端的环境中，可以独立启动\nif (!window.singleSpaNavigate) {\n  app = createApp(App);\n  app.mount("#app");\n}\n\n// 注意这里的每一个生命周期函数必须是 async 函数\nexport async function bootstrap() {\n  console.log("[Vue 子应用] bootstrap excuted");\n}\n\nexport async function mount(props) {\n  console.log("[Vue 子应用] mount excuted, props: ", props);\n  app = createApp(App);\n  app.mount(`#${props.container}`);\n}\n\nexport async function unmount(props) {\n  console.log("[Vue 子应用] unmount excuted, props: ", props);\n  app && app.unmount();\n}\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本课程讲解了 Fetch 请求方案的代码分割实现示例，重点讲解了代码分割的 Webpack 运行时原理，并详细讲解了 ",(0,r.jsx)(e.code,{children:"output.chunkLoadingGlobal"})," 在微前端中的详细作用。在下一个课程中，我们会重点讲解 single-spa 的内部运行机制，从而为了解 qiankun 内部的运行机制奠定基础。"]})]})}function y(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(f,{...n})}):f(n)}let v=y;y.__RSPRESS_PAGE_META={},y.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F22.%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%EF%BC%9Asingle-spa%20%E7%9A%84%20Code%20Splitting%20%E7%A4%BA%E4%BE%8B.md"]={toc:[{text:"为什么需要代码分割",id:"为什么需要代码分割",depth:2},{text:"如何实现代码分割",id:"如何实现代码分割",depth:2},{text:"多入口配置",id:"多入口配置",depth:3},{text:"按需加载",id:"按需加载",depth:3},{text:"代码分割的运行时原理",id:"代码分割的运行时原理",depth:2},{text:"Fetch 示例",id:"fetch-示例",depth:2},{text:"主应用设计",id:"主应用设计",depth:3},{text:"微应用设计",id:"微应用设计",depth:3},{text:"小结",id:"小结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);