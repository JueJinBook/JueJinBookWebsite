"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11390"],{371608:function(n,e,o){o.r(e),o.d(e,{default:()=>l});var i=o(552676),c=o(740453);function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",blockquote:"blockquote",pre:"pre",code:"code",ul:"ul",li:"li",ol:"ol"},(0,c.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"第27章概要设计设计我们的项目架构",children:["第27章—概要设计：设计我们的项目架构",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第27章概要设计设计我们的项目架构",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"\uFEFF上一章节我们进行了直播间的需求评审，对我们的需求进行了详细探讨，那么，既然需求已定，接下来就是撸码阶段了。"}),"\n",(0,i.jsx)(e.p,{children:"我们知道，好的设计是成功的一半，我们要先好好地思考一下，并把我们代码的地基打瓷实了。"}),"\n",(0,i.jsxs)(e.h2,{id:"全局的委任模式",children:["全局的委任模式",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#全局的委任模式",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["首先，针对直播间来说，我们的直播间是",(0,i.jsx)(e.strong,{children:"一块功能"}),"，我们称之为一个",(0,i.jsx)(e.strong,{children:"模块"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"其实，我们可以这么理解：我们的项目就是一个个的模块组成的，我们把项目比喻成一个国家，那么模块就像是三省六部一样，而皇帝呢，直接管理这三省六部即可。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:["我们把项目称为 ",(0,i.jsx)(e.strong,{children:"App"}),"，把模块称为 ",(0,i.jsx)(e.strong,{children:"Module"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["所以，到这里，我们可以总结出来：",(0,i.jsx)(e.strong,{children:"项目管理模块，模块实现自己的功能"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"这像不像一个委任模式呢？"}),"\n",(0,i.jsx)(e.p,{children:"其中，App 管理着 Module，Module 管理着自己内部的逻辑。"}),"\n",(0,i.jsx)(e.p,{children:"好，那么，我们来实现一下相关的代码。"}),"\n",(0,i.jsxs)(e.p,{children:["首先，我们定义一下",(0,i.jsx)(e.strong,{children:"模块"}),"的相关逻辑："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 抽象的模块逻辑\ninterface IModuleContext {\n    // 返回模块类型\n    IModuleType getModuleType();\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"定义模块的类型："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"enum ModuleType(int value) {\n    HOME(1), // 首页\n    CHAT(2), // 聊天\n    MOMENTS(3), // 朋友圈\n    PROFILE(4), // 个人信息\n    VOICE_ROOM(5), // 语音聊天室\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"接下来，定义一下我们的直播间的顶层模块："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 直播间的顶层接口定义，需要实现模块类的Context\ninterface IVoiceRoomContext extends IModuleContext {\n    // ... 具体的业务定义，App一级的不感兴趣\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["就是这么一个接口，只需要继承",(0,i.jsx)(e.code,{children:"IModuleContext"}),"表示自己是一个",(0,i.jsx)(e.code,{children:"Module"}),"即可，就是这么简单。"]}),"\n",(0,i.jsxs)(e.p,{children:["等等，写的不太对，因为我们",(0,i.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196592164002856960",target:"_blank",rel:"noopener noreferrer",children:"第 23 章"}),"说过",(0,i.jsx)(e.strong,{children:"分层思想"}),"，我们应该把直播间的基础功能抽离出来，抽成一个",(0,i.jsx)(e.code,{children:"IBaseRoomContext"}),"，没错，搞起来。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"interface IBaseRoomContext extends IModuleContext {\n     // 房间基础功能\n}\n\ninterface IVoiceRoomContext extends IBaseRoomContext {\n    // 房间语音功能\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"这样就定义完我们的顶层架构了。"}),"\n",(0,i.jsxs)(e.p,{children:["然后，我们需要让",(0,i.jsx)(e.code,{children:"App"}),"管理这些",(0,i.jsx)(e.code,{children:"Module"}),"，那么，怎么管理呢？"]}),"\n",(0,i.jsxs)(e.p,{children:["其实，所谓管理，就是控制生命周期，也就是控制你的存在和销毁，换句话说就是",(0,i.jsx)(e.strong,{children:"控制这些 Module 的创建和删除"}),"，我们可以用一个集合来管理这些",(0,i.jsx)(e.code,{children:"Module"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"No BB，Show Code."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// App代表我们的主项目\nclass App {\n    \n    // 存放所有的模块数据,key是类型，value是对应的Module的数据\n    private Map<ModuleType,IModuleContext> modulePoll = new HashMap<>();\n    \n    // 根据模块类型，获取对应的模块数据\n    // 这里采用了泛型，其中MC代表泛型\n    public <MC extends IModuleContext> MC getModuleContext(ModuleType type) {\n        if(!modulePoll.containsKey(type)) return null;\n        // 需要强转一下\n        retrun <MC> modulePoll.get(type);\n    }\n    \n    // 注册模块，因为map自带去重功能，所以不需要去重\n    // IModuleContext可以获取自己的ModuleType，所以一个参数就够了\n    public void addModuleContext(IModuleContext moduleContext) {\n        modulePoll.put(moduleContext.getModuleType(), moduleContext);\n    }\n    \n    // 删除模块，根据最小知识原则，我们只需要知道ModuleType就行，没必要传递IModuleContext过来\n    public void rmModuleContext(ModuleType type){\n        modulePoll.remove(type);\n    }\n    \n    \n    因为我们的App代表项目，所以只有一个，且全局存在，所以可以采用单例模式，且不用考虑内存泄露\n    private static App instance = new App();\n    public static void getApp() {\n        return instance;\n    }\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["好，到这里，我们的",(0,i.jsx)(e.code,{children:"App"}),"层的逻辑就完成了，我们在任意地方可以通过："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"App.getApp().getModuleContext()\n"})}),"\n",(0,i.jsxs)(e.p,{children:["来获取到对应的模块数据，可以通过",(0,i.jsx)(e.code,{children:"addModuleContext()"}),"和",(0,i.jsx)(e.code,{children:"rmModuleContext()"}),"来控制，从而达到控制模块生命周期的目的。"]}),"\n",(0,i.jsx)(e.p,{children:"那么，这个模块什么时候开始存在，什么时候死亡呢？换句话说，这个模块的生命周期是多长呢？"}),"\n",(0,i.jsxs)(e.p,{children:["当我们点击按钮进入直播间的时候，直播间的生命周期就开始了，我们就应该通过",(0,i.jsx)(e.code,{children:"addModuleContext()"}),"来保存我们的直播间数据；当我们退出直播间的时候，直播间的生命周期就结束了，我们就应该通过",(0,i.jsx)(e.code,{children:"rmModuleContext()"}),"来移除直播间数据。"]}),"\n",(0,i.jsx)(e.p,{children:"假如，我们通过长链接来实现我们的直播间，我们的代码如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:'public void onReceiveData(String json) {\n    String type = json.optString("type");\n    String data = json.optString("data");\n    if("enterRoom".equals(type)) {\n        // 进入房间成功，创建直播间数据\n        IVoiceRoomContext voiceRoomContext = new VoiceRoomContextImpl();\n        voiceRoomContext.enterRoom(data);\n        \n        // 存储数据\n        App.getApp().addModuleContext(voiceRoomContext);\n        \n        // 启动页面\n        VoiceRoomPage.start();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"退出房间的时候，就是："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 退出房间\nvoiceRoomContext.exitRoom();\n// 移除数据\nApp.getApp().rmModuleContext(voiceRoomContext);\n// 销毁页面\nexitPage();\n"})}),"\n",(0,i.jsx)(e.p,{children:"上述只是伪代码，我们需要根据具体业务来实现具体逻辑。"}),"\n",(0,i.jsxs)(e.p,{children:["那么，",(0,i.jsx)(e.code,{children:"VoiceRoomContextImpl"}),"是什么玩意儿呢？它里面的具体逻辑是什么呢？"]}),"\n",(0,i.jsx)(e.p,{children:"我们就来看一看它的具体逻辑。"}),"\n",(0,i.jsxs)(e.h2,{id:"局部的-mvc",children:["局部的 MVC",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#局部的-mvc",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"好，现在，我们就要对直播间下手了，现在，我们可以完全无视上述代码，我们的眼里只有直播间，直播间就是全部。"}),"\n",(0,i.jsx)(e.p,{children:"经过分析，我们可以很简单地定义出直播间的功能，如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"interface IVoiceRoomContext extends IBaseRoomContext {\n    \n    // 进房间 并且使用json初始化数据\n    void enterRoom(String json);\n    \n    // 退房间 成功则回调 true:退出成功 false:退出失败\n    void exitRoom(Action<Boolean> callback);\n    \n    // 上座位 position:目标位置\n    void seatDown(int position);\n    \n    // 下座位\n    void leaveSeat();\n    \n    // 打开麦克风\n    void openMic();\n    \n    // 关闭麦克风\n    void closeMic();\n    \n    // 发消息\n    void sendMsg(String msg);\n    \n    // 送礼物\n    void sendGift(Gift gift, String uid)\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"好，这就是最基本的业务逻辑了。"}),"\n",(0,i.jsxs)(e.p,{children:["等等，不对，这些函数全部定义到",(0,i.jsx)(e.code,{children:"IVoiceRoomContext"}),"里面了，那么，",(0,i.jsx)(e.code,{children:"IBaseRoomContext"}),"有什么意义呢？为了看看？"]}),"\n",(0,i.jsx)(e.p,{children:"大哥质疑的对，我这就改。"}),"\n",(0,i.jsxs)(e.p,{children:["经过分析，我们知道",(0,i.jsx)(e.code,{children:"IVoiceRoomContext"}),"的重点就是",(0,i.jsx)(e.code,{children:"Voice"}),"，也就是跟语音相关的，那么，跟语音无关的，就意味着其他非",(0,i.jsx)(e.code,{children:"Voice"}),"系列的",(0,i.jsx)(e.code,{children:"Room"}),"也可以使用，就是共用的，可以提取出来，放到上层逻辑（也就是父类）中去。所以，我们修改过的代码如下："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 基础房间功能\ninterface IBaseRoomContext {\n    \n    // 进房间 并且使用json初始化数据\n    void enterRoom(String json);\n    \n    // 退房间 成功则回调 true:退出成功 false:退出失败\n    void exitRoom(Action<Boolean> callback);\n    \n    // 上座位 position:目标位置\n    void seatDown(int position);\n    \n    // 下座位\n    void leaveSeat();\n    \n    // 发消息\n    void sendMsg(String msg);\n    \n    // 送礼物\n    void sendGift(Gift gift, String uid)\n}\n\n// 语音房间功能\ninterface IVoiceRoomContext extends IBaseRoomContext {\n    \n    // 进入语音流\n    void enterVoice();\n    \n    // 退出语音流\n    void exitVoice();\n    \n     // 打开麦克风\n    void openMic();\n    \n    // 关闭麦克风\n    void closeMic();\n    \n    // 打开扬声器\n    void openSpeaker();\n    \n    // 关闭扬声器\n    void closeSpeaker();\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["好，完事了，这样是不是好很多了？如果将来有一个新直播间 A，不需要语音功能，只需要基础功能，那么这个 A 只需要继承",(0,i.jsx)(e.code,{children:"IBaseRoomContext"}),"即可，就不会有任何语音功能，完全符合最小知识原则；如果 A 需要有语音功能，那么直接修改继承自",(0,i.jsx)(e.code,{children:"IVoiceRoomContext"}),"即可；反正你需要啥就找啥，然后继承它就可以了。"]}),"\n",(0,i.jsx)(e.p,{children:"那业务逻辑到这里就完事了。"}),"\n",(0,i.jsxs)(e.p,{children:["上一章我们讲了，需要将",(0,i.jsx)(e.strong,{children:"语音模块"}),"单独定义出来，其他地方可能要使用，语音模块的功能是啥呢？"]}),"\n",(0,i.jsxs)(e.p,{children:["正是我们上面定义在",(0,i.jsx)(e.code,{children:"IVoiceRoomContext"}),"里面的功能。"]}),"\n",(0,i.jsx)(e.p,{children:"那我们直接在里面实现不就行了吗？反正它也是一个模块。"}),"\n",(0,i.jsxs)(e.p,{children:["不行！因为",(0,i.jsx)(e.code,{children:"IVoiceRoomContext"}),"还继承了",(0,i.jsx)(e.code,{children:"IBaseRoomContext"}),"，也就是里面",(0,i.jsx)(e.strong,{children:"不光有语音相关功能，还有房间相关功能"}),"，如果将来我们的其他模块不需要房间功能呢？",(0,i.jsx)(e.strong,{children:"这不符合最小知识原则"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"所以我们应该单独定义出来。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 单纯的语音直播间功能\ninterface IAudioEngine {\n    // 进入语音流\n    void enterVoice();\n    \n    // 退出语音流\n    void exitVoice();\n    \n     // 打开麦克风\n    void openMic();\n    \n    // 关闭麦克风\n    void closeMic();\n    \n    // 打开扬声器\n    void openSpeaker();\n    \n    // 关闭扬声器\n    void closeSpeaker();\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["然后，让我们的",(0,i.jsx)(e.code,{children:"IVoiceRoomContext"}),"也继承它就可以了，如下："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 语音房，也就是在普通房间上 添加了 语音功能\ninterface IVoiceRoomContext extends IBaseRoomContext, IAudioEngine {\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["可以看到，我们的",(0,i.jsx)(e.code,{children:"IVoiceRoomContext"}),"其实就是个功能的结合体。"]}),"\n",(0,i.jsx)(e.p,{children:"语音房，语音房，偏正短语，一个房间，一个带语音功能的房间，所以就是俩功能：语音功能+房间功能。而接口，就是代表某种功能，所以，语音房，只要用两个接口接合一下，就完美实现了。"}),"\n",(0,i.jsxs)(e.p,{children:["有人说，不对啊，",(0,i.jsx)(e.code,{children:"java"}),"不是只能继承一个吗？你这都继承了两个了。"]}),"\n",(0,i.jsx)(e.p,{children:"问这个问题的人，就是语言能力不过关，或者说，根本就没有彻底理解面向对象设计理念。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"Tips：在面向对象语言中，继承表示：是什么；接口表示：有什么功能；因为你要么是 A 要么是 B，所以如果你是对象，你只能单继承；而如果你是接口，你可以既有 A 功能，又有 B 功能，你就可以多继承。"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["当你明白了上述道理后，你就不会纠结于有几个父类了，你会看得更远，理解得更深刻，你就会开始去理解语言的设计理念了。比如",(0,i.jsx)(e.code,{children:"C++"}),"就可以多继承，但是无所谓啊，它这个多继承描述的",(0,i.jsx)(e.strong,{children:"设计理念"}),"跟",(0,i.jsx)(e.code,{children:"java"}),"是一样的，并补互斥，这里不再废话。"]}),"\n",(0,i.jsxs)(e.p,{children:["好，那么到这里，我们的语音直播间，就完全可以使用",(0,i.jsx)(e.code,{children:"IVoiceRoomContext"}),"来表示了，并且，我们的",(0,i.jsx)(e.code,{children:"App"}),"对象，不需要做任何修改，因为",(0,i.jsx)(e.code,{children:"App"}),"存储的是",(0,i.jsx)(e.code,{children:"IModuleContext"}),"，是接口，是抽象，我们做的是面向抽象编程，也就是依赖倒置原则，这正如我们第 ",(0,i.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196591861673230371",target:"_blank",rel:"noopener noreferrer",children:"21 章"}),"所讲的。"]}),"\n",(0,i.jsxs)(e.p,{children:["那么，假如，我们的 UI 页面叫",(0,i.jsx)(e.code,{children:"VoiceRoomPage"}),"，那么，它应该由 4 部分组成，就像我们在上一章需求评审里面讲的一样："]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"顶部标题栏；"}),"\n",(0,i.jsx)(e.li,{children:"座位栏；"}),"\n",(0,i.jsx)(e.li,{children:"消息栏；"}),"\n",(0,i.jsx)(e.li,{children:"底部操作栏。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"所以，我们可以定义四个部分来处理 UI，如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 标题栏\nclass TitlePanel {}\n\n// 座位栏\nclass SeatPanel {}\n\n// 消息栏\nclass MsgPanel {}\n\n// 操作栏\nclass OptionPanel {}\n\n"})}),"\n",(0,i.jsx)(e.p,{children:"为了方便处理，我们可以将 UI 抽离一层，叫做房间组件，那么上述四个 UI 块，就是四个组件，如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"// 房间组件\nabstract class VoiceRoomPanel {\n    // 房间组件都持有房间上下文数据类\n    protected IVoiceRoomContext voiceRoomContext;\n    \n    // 通过构造函数传入上下文\n    public void VoiceRoomPanel(IVoiceRoomContext voiceRoomContext) {\n        this.voiceRoomContext = voiceRoomContext;\n    }\n}\n\n// 标题栏\nclass TitlePanel extends VoiceRoomPanel {\n}\n\n// 座位栏\nclass SeatPanel extends VoiceRoomPanel {\n}\n\n// 消息栏\nclass MsgPanel extends VoiceRoomPanel {\n}\n\n// 操作栏\nclass OptionPanel extends VoiceRoomPanel {\n} \n"})}),"\n",(0,i.jsxs)(e.p,{children:["这样，我们的四个 UI 组件都持有了同一份",(0,i.jsx)(e.code,{children:"VoiceRoomContext"}),"，那就意味着数据是共享的，其中",(0,i.jsx)(e.code,{children:"OptionPanel"}),"如果进行了操作，那么就会修改",(0,i.jsx)(e.code,{children:"VoiceRoomContext"}),"里面的数据，",(0,i.jsx)(e.code,{children:"TitlePanel"}),"再去拿，就是修改过的数据。"]}),"\n",(0,i.jsx)(e.p,{children:"还记得我们上一章留下的悬念吗?"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"不同的 UI 模块之间的数据通信，要怎么做呢？"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"就是这么做的，通过数据共享。"}),"\n",(0,i.jsxs)(e.p,{children:["接下来我们来看一看我们的",(0,i.jsx)(e.code,{children:"VoiceRoomPage"}),"的定义："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-java",children:"class VoiceRoomPage {\n    protected IVoiceRoomContext voiceRoomContext;\n    \n    private List<VoiceRoomPanel> panels = new ArrayList();\n    \n    public void init() {\n        // 获取语音房上下文数据\n        this.voiceRoomContext = App.get().getModuleContext(ModuleType.VOICE_ROOM);\n        \n        // 进入语音流\n        this.voiceRoomContext.enterVoice();\n        \n        // 初始化房间组件\n        panels.add(new TitlePanel(voiceRoomContext));\n        panels.add(new SeatPanel(voiceRoomContext));\n        panels.add(new MsgPanel(voiceRoomContext));\n        panels.add(new OptionPanel(voiceRoomContext));\n    }\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["上面就是初始化逻辑，我们看到，经过上述初始化，我们的上下文数据已经分发到房间的各个 UI 块里面了，任何想使用它的地方，都可以直接使用，并且，所有的操作都是共享的，因为它们用的是同一份",(0,i.jsx)(e.code,{children:"VoiceRoomContext"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:["其实，我们可以将我们的 UI 看作一棵树，我们的",(0,i.jsx)(e.code,{children:"VoiceRoomContext"}),"在树根创建，然后沿着我们的 UI 树向下分发，到达不同的分支节点、叶子结点。这样一来，任何节点的操作，都会反馈到这个树的其他节点，达到数据共享。"]}),"\n",(0,i.jsx)(e.p,{children:"那么，A 节点操作了之后，B 节点怎么能立刻知道呢？"}),"\n",(0,i.jsxs)(e.p,{children:["没错，就是我们第 ",(0,i.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196592051146719272",target:"_blank",rel:"noopener noreferrer",children:"22 章"}),"讲的观察者模式，这个我们在下一章的具体实现里面会仔细列出代码。"]}),"\n",(0,i.jsx)(e.p,{children:"好，现在让我们来捋一下我们的代码流程："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"我们通过长链接建立连接，进入了房间；"}),"\n",(0,i.jsxs)(e.li,{children:["用长链接返回的数据创建",(0,i.jsx)(e.code,{children:"VoiceRoomContext"}),"，并保存起来；"]}),"\n",(0,i.jsx)(e.li,{children:"进入语音流，默认打开扬声器；"}),"\n",(0,i.jsxs)(e.li,{children:["启动房间页面，并获取上一步的",(0,i.jsx)(e.code,{children:"VoiceRoomContext"}),"，用来初始化各个 UI 块。"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"这样，我们的房间页面就起来了，并且也能听到声音了。"}),"\n",(0,i.jsxs)(e.p,{children:["到这里，我们的顶层框架就搭建完成了，我们通过",(0,i.jsx)(e.code,{children:"VoiceRoomContext"}),"来控制非 UI 逻辑，通过",(0,i.jsx)(e.code,{children:"IAudioEngine"}),"来实际控制声音，我们的 UI 不做任何数据逻辑。这样，即使要实现上一章的小窗口功能，我们只需要销毁 UI 就行了，因为数据还在",(0,i.jsx)(e.code,{children:"App"}),"的",(0,i.jsx)(e.code,{children:"modulePoll"}),"里存放着，还在执行着，只是不更新 UI 而已。"]}),"\n",(0,i.jsxs)(e.h2,{id:"总结",children:["总结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"本章我们仔细分析了语音直播间的功能，并搭建出顶层架构，我们没看到任何具体的实现代码，但是光看接口定义就已经知道这个需求的所有功能了，这就是面向抽象编程，不写具体的实现代码也能知道在干什么。其实这可以分为几个步骤："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"深入理解需求，并剖析成一个个的功能块；"}),"\n",(0,i.jsx)(e.li,{children:"定义接口来描述这些功能块；"}),"\n",(0,i.jsx)(e.li,{children:"找出不是当前需求独有的特性的功能块，并抽离成公用的；"}),"\n",(0,i.jsx)(e.li,{children:"整理上面定义的接口，找出符合当前需求的最小接口集合；"}),"\n",(0,i.jsx)(e.li,{children:"将这个接口集合集中到一个接口里面，这个接口就是我们要实现的需求。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"当然，光嘴说没用，还得多实践，多体会，那么，下一节，我们就来实现我们的详细业务代码，来深入体会一下自顶向下的编程理念。"})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}let l=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC27%E7%AB%A0%E2%80%94%E6%A6%82%E8%A6%81%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%AE%BE%E8%AE%A1%E6%88%91%E4%BB%AC%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.md"]={toc:[{text:"全局的委任模式",id:"全局的委任模式",depth:2},{text:"局部的 MVC",id:"局部的-mvc",depth:2},{text:"总结",id:"总结",depth:2}],title:"第27章—概要设计：设计我们的项目架构",headingTitle:"第27章—概要设计：设计我们的项目架构",frontmatter:{}}}}]);