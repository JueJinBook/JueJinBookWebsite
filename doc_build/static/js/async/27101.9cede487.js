"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["27101"],{458575:function(n,e,s){s.r(e),s.d(e,{default:()=>j});var a=s(552676),d=s(740453);let r=s.p+"static/image/f53592a7587204d94b9965a7e13ed39d.b75a577c.webp",c=s.p+"static/image/5b90e76df6803c5903ac6ea29f37a68b.3d6df901.webp",i=s.p+"static/image/c5d4979d0622d27fd9ff72891212453a.414d055b.webp",t=s.p+"static/image/5585c434944b0367ddee5361221d603e.aac4c955.webp",o=s.p+"static/image/ec0698c30c9d9390fa1668a74c35f641.683c3162.webp",l=s.p+"static/image/27db99545fee1613285e984506823513.5983d6af.webp",p=s.p+"static/image/929feb75fb6092622944d85ef2eb557e.5a2117d8.webp",h=s.p+"static/image/15c109a63dc94276681ee7cc47c60a06.8ac614c0.webp",x=s.p+"static/image/e50e92d43af9596edac660f6d5948869.d42723c3.webp";function m(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",ul:"ul",li:"li",h4:"h4",code:"code",pre:"pre",blockquote:"blockquote",strong:"strong"},(0,d.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"17前端实战新增账单弹窗封装",children:["17.前端实战：新增账单弹窗封装",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17前端实战新增账单弹窗封装",children:"#"})]}),"\n",(0,a.jsxs)(e.h2,{id:"前言",children:["前言",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"回顾一下上一章节学习的内容。无限滚动列表、弹窗组件的内部控制显隐、工具方法以及常量的提取。若是你开发项目时，在潜意识里，有对这些内容进行封装的思想，那么你已经有模块化、组件化的开发理念了。在大量的工程中得出的实践，将会根深蒂固在你的开发理念里。"}),"\n",(0,a.jsx)(e.p,{children:"之前，我们是对一个小组件，如时间筛选、类型筛选等小组件进行封装。本章节，我们对一个添加模块进行封装，好处就是你在任何地方，都能使用这个添加组件，对账单进行增加操作。"}),"\n",(0,a.jsx)(e.p,{children:"我们先来看看本章节要绘制的页面和逻辑："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"如上图所示，本章节要实现的需求逻辑，基本上已经绘制在图中。所有的努力，都是为了凑出这几个参数："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"账单类型"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"账单金额"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"账单日期"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"账单种类"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"备注"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"然后将这些数据，提交给服务端进行处理，然后存储到数据库，完事。"}),"\n",(0,a.jsxs)(e.h2,{id:"正文",children:["正文",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#正文",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"上述需求整理清楚之后，我们开始本章节的制作环节。"}),"\n",(0,a.jsxs)(e.h4,{id:"弹窗组件实现",children:["弹窗组件实现",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#弹窗组件实现",children:"#"})]}),"\n",(0,a.jsxs)(e.p,{children:["先实现点击新增按钮，调出弹窗的功能。首先，在 ",(0,a.jsx)(e.code,{children:"Home/index.jsx"})," 文件中添加 「新增按钮」，如下所示："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import CustomIcon from '@/components/CustomIcon'\n... \nconst Home = () => {\n  ... \n  const addToggle = () => {\n    // do something\n  }\n  ...\n  return <div className={s.home}>\n    ... \n    <div className={s.add} onClick={addToggle}><CustomIcon type='tianjia' /></div>\n  </div>\n}\n"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["样式中，注意我给 ",(0,a.jsx)(e.code,{children:"border"})," 设置的是 ",(0,a.jsx)(e.code,{children:"1PX"}),"，大写的单位，因为这样写的话，",(0,a.jsx)(e.code,{children:"postcss-pxtorem"})," 插件就不会将其转化为 ",(0,a.jsx)(e.code,{children:"rem"})," 单位。"]}),"\n",(0,a.jsx)(e.p,{children:"重启项目之后，刷新浏览器，如下所示："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsxs)(e.p,{children:["根据之前实现的弹窗组件，我们再实现一套类似的，在弹窗内控制弹窗组件的显示隐藏，在 ",(0,a.jsx)(e.code,{children:"components"})," 下新建 ",(0,a.jsx)(e.code,{children:"PopupAddBill"})," 文件夹，再新建 ",(0,a.jsx)(e.code,{children:"index.jsx"})," 和 ",(0,a.jsx)(e.code,{children:"style.module.less"}),"，代码如下："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// PopupAddBill/index.jsx\nimport React, { forwardRef, useEffect, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { Popup  } from 'zarm';\n\nconst PopupAddBill = forwardRef((props, ref) => {\n  const [show, setShow] = useState(false) // 内部控制弹窗显示隐藏。\n  // 通过 forwardRef 拿到外部传入的 ref，并添加属性，使得父组件可以通过 ref 控制子组件。\n  if (ref) {\n    ref.current = {\n      show: () => {\n        setShow(true);\n      },\n      close: () => {\n        setShow(false);\n      }\n    }\n  };\n\n  return <Popup\n    visible={show}\n    direction=\"bottom\"\n    onMaskClick={() => setShow(false)}\n    destroy={false}\n    mountContainer={() => document.body}\n  >\n    <div style={{ height: 200, background: '#fff' }}>弹窗</div>\n  </Popup>\n})\n\nexport default PopupAddBill\n"})}),"\n",(0,a.jsxs)(e.p,{children:["写完弹窗组件，当然就得去 ",(0,a.jsx)(e.code,{children:"Home/index.jsx"})," 中调用："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// Home/index.jsx\nimport PopupAddBill from '@/components/PopupAddBill'\n\nconst Home = () => {\n  ...\n  const addRef = useRef(); // 添加账单 ref\n  ... \n  // 添加账单弹窗\n  const addToggle = () => {\n    addRef.current && addRef.current.show()\n  }\n\n  return <div className={s.home}>\n    ...\n    <PopupAddBill ref={addRef} />\n  </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"重启浏览器，效果如下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"此时我们的“地基”已经打好了，接下来我们要在这个基础上给新增账单弹窗“添砖加瓦”。"}),"\n",(0,a.jsxs)(e.h4,{id:"账单类型和账单时间",children:["账单类型和账单时间",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#账单类型和账单时间",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"我们先实现弹窗头部左侧的「支出」和「收入」账单类型切换功能，添加代码如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// components/PopupAddBill/index.jsx\n...\nimport cx from 'classnames';\nimport { Popup, Icon  } from 'zarm';\n\nimport s from './style.module.less';\n\nconst PopupAddBill = forwardRef((props, ref) => {\n  ...\n  const [payType, setPayType] = useState('expense'); // 支出或收入类型\n  ...\n  // 切换收入还是支出\n  const changeType = (type) => {\n    setPayType(type);\n  };\n\n  return <Popup\n    visible={show}\n    direction=\"bottom\"\n    onMaskClick={() => setShow(false)}\n    destroy={false}\n    mountContainer={() => document.body}\n  >\n    <div className={s.addWrap}>\n      {/* 右上角关闭弹窗 */}\n      <header className={s.header}>\n        <span className={s.close} onClick={() => setShow(false)}><Icon type=\"wrong\" /></span>\n      </header>\n       {/* 「收入」和「支出」类型切换 */}\n      <div className={s.filter}>\n        <div className={s.type}>\n          <span onClick={() => changeType('expense')} className={cx({ [s.expense]: true, [s.active]: payType == 'expense' })}>支出</span>\n          <span onClick={() => changeType('income')} className={cx({ [s.income]: true, [s.active]: payType == 'income' })}>收入</span>\n        </div>\n      </div>\n    </div>\n  </Popup>\n})\n\nexport default PopupAddBill\n"})}),"\n",(0,a.jsx)(e.p,{children:"为了减少代码的重复，上述代码只展示了需要添加的部分，尽量不让大家混淆视听。"}),"\n",(0,a.jsxs)(e.p,{children:["我们定义 ",(0,a.jsx)(e.code,{children:"expense"})," 为支出，",(0,a.jsx)(e.code,{children:"income"})," 为收入，代码中通过 ",(0,a.jsx)(e.code,{children:"payType"})," 变量，来控制「收入」和「支出」按钮的切换。上述代码视图效果如下所示："]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"接下来在类型边上添加时间筛选弹窗，此时你将体会到之前提取时间筛选组件是多么的明智。我们继续添加代码："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import React, { forwardRef, useEffect, useRef, useState } from 'react';\n...\nimport dayjs from 'dayjs';\nimport PopupDate from '../PopupDate'\n...\n\nconst PopupAddBill = forwardRef((props, ref) => {\n  ...\n  const dateRef = useRef();\n  const [date, setDate] = useState(new Date()); // 日期\n  ...\n  // 日期选择回调\n  const selectDate = (val) => {\n    setDate(val);\n  }\n\n  return <Popup\n    visible={show}\n    direction=\"bottom\"\n    onMaskClick={() => setShow(false)}\n    destroy={false}\n    mountContainer={() => document.body}\n  >\n    <div className={s.addWrap}>\n       {/* 「收入」和「支出」类型切换 */}\n      <div className={s.filter}>\n        ...\n        <div\n          className={s.time}\n          onClick={() => dateRef.current && dateRef.current.show()}\n        >{dayjs(date).format('MM-DD')} <Icon className={s.arrow} type=\"arrow-bottom\" /></div>\n      </div>\n      <PopupDate ref={dateRef} onSelect={selectDate} />\n    </div>\n  </Popup>\n})\n\nexport default PopupAddBill\n"})}),"\n",(0,a.jsxs)(e.p,{children:["我们引入了公共组件 ",(0,a.jsx)(e.code,{children:"PopupDate"}),"，传入 ",(0,a.jsx)(e.code,{children:"ref"})," 控制弹窗的显示隐藏，传入 ",(0,a.jsx)(e.code,{children:"onSelect"})," 获取日期组件选择后回调的值，并通过 ",(0,a.jsx)(e.code,{children:"setDate"})," 重制 ",(0,a.jsx)(e.code,{children:"date"}),"，触发视图的更新，我们来看浏览器展示效果如下："]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"我们通过上述代码，已经创造出了两个值，分别是「账单类型」和「账单日期」，还差「账单金额」\n「账单种类」、「备注」。"}),"\n",(0,a.jsxs)(e.h4,{id:"账单金额",children:["账单金额",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#账单金额",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"本章开头大家也应该看到了，金额输入框是模拟的，也就是说当下面模拟数字键盘点击的时候，我们将返回的数据渲染到进入输入框的位置，下面我们先将金额输入框搭建出来，添加代码如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"<div className={s.money}>\n  <span className={s.sufix}>\xa5</span>\n  <span className={cx(s.amount, s.animation)}>10</span>\n</div>\n"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,a.jsxs)(e.p,{children:["我们将金额动态化，引入 ",(0,a.jsx)(e.code,{children:"Zarm"})," 为我们提供的模拟数字键盘组件 ",(0,a.jsx)(e.code,{children:"Keyboard"}),"，代码如下："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"...\n// 监听输入框改变值\n  const handleMoney = (value) => {\n    value = String(value)\n    // 点击是删除按钮时\n    if (value == 'delete') {\n      let _amount = amount.slice(0, amount.length - 1)\n      setAmount(_amount)\n      return\n    }\n\n    // 点击确认按钮时\n    if (value == 'ok') {\n      // 这里后续将处理添加账单逻辑\n      return\n    }\n\n    // 当输入的值为 '.' 且 已经存在 '.'，则不让其继续字符串相加。\n    if (value == '.' && amount.includes('.')) return\n    // 小数点后保留两位，当超过两位时，不让其字符串继续相加。\n    if (value != '.' && amount.includes('.') && amount && amount.split('.')[1].length >= 2) return\n    // amount += value\n    setAmount(amount + value)\n  }\n...\n\n<div className={s.money}>\n  <span className={s.sufix}>\xa5</span>\n  <span className={cx(s.amount, s.animation)}>{amount}</span>\n</div>\n<Keyboard type=\"price\" onKeyClick={(value) => handleMoney(value)} />\n"})}),"\n",(0,a.jsx)(e.p,{children:"重启项目，浏览器展示如下图所示："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"这里一个小提示，我在制作项目的过程中，发现一个 Zarm 2.9.0 版本的 bug，Keyboard 组件在点击删除按钮的时候，onKeyClick 方法会反复被执行，于是我降级为 2.8.2 版本，并且去他们的官网提了 issue。"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"此时「账单金额」也被安排上了。"}),"\n",(0,a.jsxs)(e.h4,{id:"账单种类",children:["账单种类",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#账单种类",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"账单种类的作用是表示该笔账单的大致用途，我们通过接口从数据库回去账单种类列表，以横向滚动的形式，展示在金额的下面，接下来我们看具体的代码实现："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"... \nimport CustomIcon from '../CustomIcon';\nimport { get, typeMap } from '@/utils';\n\n...\nconst [currentType, setCurrentType] = useState({}); // 当前选中账单类型\nconst [expense, setExpense] = useState([]); // 支出类型数组\nconst [income, setIncome] = useState([]); // 收入类型数组\n\nuseEffect(async () => {\n  const { data: { list } } = await get('/api/type/list');\n  const _expense = list.filter(i => i.type == 1); // 支出类型\n  const _income = list.filter(i => i.type == 2); // 收入类型\n  setExpense(_expense);\n  setIncome(_income);\n  setCurrentType(_expense[0]); // 新建账单，类型默认是支出类型数组的第一项\n}, [])\n\n\n...\n<div className={s.typeWarp}>\n  <div className={s.typeBody}>\n    {/* 通过 payType 判断，是展示收入账单类型，还是支出账单类型 */}\n    {\n      (payType == 'expense' ? expense : income).map(item => <div onClick={() => setCurrentType(item)} key={item.id} className={s.typeItem}>\n        {/* 收入和支出的字体颜色，以及背景颜色通过 payType 区分，并且设置高亮 */}\n        <span className={cx({[s.iconfontWrap]: true, [s.expense]: payType == 'expense', [s.income]: payType == 'income', [s.active]: currentType.id == item.id})}>                \n          <CustomIcon className={s.iconfont} type={typeMap[item.id].icon} />\n        </span>\n        <span>{item.name}</span>\n      </div>)\n    }\n  </div>\n</div>\n"})}),"\n",(0,a.jsxs)(e.p,{children:["注意，在 ",(0,a.jsx)(e.code,{children:"h5"})," 界面实现横向滚动，和在网页端相比，多了如下属性："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:"* {\n  touch-action: pan-x;\n}\n"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"CSS属性 touch-action 用于设置触摸屏用户如何操纵元素的区域(例如，浏览器内置的缩放功能)。"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["如果不设置它，只是通过 ",(0,a.jsx)(e.code,{children:"overflow-x: auto"}),"，无法实现 ",(0,a.jsx)(e.code,{children:"h5"})," 端的横向滚动的，并且你要在一个 ",(0,a.jsx)(e.code,{children:"div"})," 容器内设置全局 ",(0,a.jsx)(e.code,{children:"*"})," 为 ",(0,a.jsx)(e.code,{children:"touch-action: pan-x;"}),"，如果后续遇到类似的问题，大家可以参考我上述做法，这是经过实践验证过的方法。"]}),"\n",(0,a.jsx)(e.p,{children:"我们来看看浏览器的展示效果："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsxs)(e.h4,{id:"备注弹窗",children:["备注弹窗",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#备注弹窗",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"备注虽然不起眼，但是别小看它，它可以在账单类型不足以概括账单时，加以一定的文字描述。"}),"\n",(0,a.jsx)(e.p,{children:"我们直接将其放置于「账单种类」的下面，代码如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"...\nimport {  Input  } from 'zarm';\n\n...\nconst [remark, setRemark] = useState(''); // 备注\nconst [showRemark, setShowRemark] = useState(false); // 备注输入框展示控制\n\n... \n<div className={s.remark}>\n  {\n    showRemark ? <Input\n      autoHeight\n      showLength\n      maxLength={50}\n      type=\"text\"\n      rows={3}\n      value={remark}\n      placeholder=\"请输入备注信息\"\n      onChange={(val) => setRemark(val)}\n      onBlur={() => setShowRemark(false)}\n    /> : <span onClick={() => setShowRemark(true)}>{remark || '添加备注'}</span>\n  }\n</div>\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"CSS 样式部分"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".remark {\n  padding: 0 24px;\n  padding-bottom: 12px;\n  color: #4b67e2;\n  :global {\n    .za-input--textarea {\n      border: 1px solid #e9e9e9;\n      padding:  10px;\n    }\n  }\n}\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:":global"})," 的使用之前已经有描述过，这里再提醒大家一句，目前项目使用的是 ",(0,a.jsx)(e.code,{children:"css module"})," 的形式，所以样式名都会被打上 ",(0,a.jsx)(e.code,{children:"hash"})," 值，我们需要修改没有打 ",(0,a.jsx)(e.code,{children:"hash"})," 值的 ",(0,a.jsx)(e.code,{children:"zarm"})," 内部样式，需要通过 ",(0,a.jsx)(e.code,{children:":global"})," 方法。"]}),"\n",(0,a.jsx)(e.p,{children:"浏览器展示效果如下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsxs)(e.h4,{id:"调用上传账单接口",children:["调用上传账单接口",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#调用上传账单接口",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"此时我们集齐了五大参数："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"账单类型：payType"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"账单金额：amount"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"账单日期：date"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"账单种类：currentType"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"备注：remark"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:["我们给 ",(0,a.jsx)(e.code,{children:"Keyboard"})," 的「确定」按钮回调添加方法："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import { Toast } from 'zarm';\nimport { post } from '@/utils';\n// 监听输入框改变值\nconst handleMoney = (value) => {\n  value = String(value)\n  // 点击是删除按钮时\n  if (value == 'delete') {\n    let _amount = amount.slice(0, amount.length - 1)\n    setAmount(_amount)\n    return\n  }\n  // 点击确认按钮时\n  if (value == 'ok') {\n    addBill()\n    return\n  }\n  // 当输入的值为 '.' 且 已经存在 '.'，则不让其继续字符串相加。\n  if (value == '.' && amount.includes('.')) return\n  // 小数点后保留两位，当超过两位时，不让其字符串继续相加。\n  if (value != '.' && amount.includes('.') && amount && amount.split('.')[1].length >= 2) return\n  // amount += value\n  setAmount(amount + value)\n}\n\n// 添加账单\nconst addBill = async () => {\n  if (!amount) {\n    Toast.show('请输入具体金额')\n    return\n  }\n  const params = {\n    amount: Number(amount).toFixed(2), // 账单金额小数点后保留两位\n    type_id: currentType.id, // 账单种类id\n    type_name: currentType.name, // 账单种类名称\n    date: dayjs(date).unix() * 1000, // 日期传时间戳\n    pay_type: payType == 'expense' ? 1 : 2, // 账单类型传 1 或 2\n    remark: remark || '' // 备注\n  }\n  const result = await post('/api/bill/add', params);\n  // 重制数据\n  setAmount('');\n  setPayType('expense');\n  setCurrentType(expense[0]);\n  setDate(new Date());\n  setRemark('');\n  Toast.show('添加成功');\n  setShow(false);\n  if (props.onReload) props.onReload();\n}\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:"onReload"})," 方法为首页账单列表传进来的函数，当添加完账单的时候，执行 ",(0,a.jsx)(e.code,{children:"onReload"})," 重新获取首页列表数据。"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"<PopupAddBill ref={addRef} onReload={refreshData} />\n"})}),"\n",(0,a.jsx)(e.p,{children:"浏览器展示如下所示："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:r,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"如果如上图所示，恭喜你，你已经成功完成了添加账单的\n工作，此时再回头甚至之前写的代码，马上改正一些变量及一些方法的命名，规范化一下代码。"}),"\n",(0,a.jsx)(e.p,{children:"千万别在后面再去完善，因为很大程度上，到后面你会懒得翻前面写的代码，除非实在是逻辑问题导致的 bug。"}),"\n",(0,a.jsxs)(e.h2,{id:"总结",children:["总结",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"本章节的内容也是非常丰富，我们的所有的努力，就是为了集齐「添加账单」所需要的五大参数。这是很多需求的一个索引，试问前端在调用接口的过程中，不都是做各种努力为了凑齐那几个参数呢？过程很重要，只要流程做得完善，结果自然水到渠成。"})]})}function u(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(m,{...n})}):m(n)}let j=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F17.%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E6%96%B0%E5%A2%9E%E8%B4%A6%E5%8D%95%E5%BC%B9%E7%AA%97%E5%B0%81%E8%A3%85.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"正文",id:"正文",depth:2},{text:"弹窗组件实现",id:"弹窗组件实现",depth:4},{text:"账单类型和账单时间",id:"账单类型和账单时间",depth:4},{text:"账单金额",id:"账单金额",depth:4},{text:"账单种类",id:"账单种类",depth:4},{text:"备注弹窗",id:"备注弹窗",depth:4},{text:"调用上传账单接口",id:"调用上传账单接口",depth:4},{text:"总结",id:"总结",depth:2}],title:"17.前端实战：新增账单弹窗封装",headingTitle:"17.前端实战：新增账单弹窗封装",frontmatter:{}}}}]);