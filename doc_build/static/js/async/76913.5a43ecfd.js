"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["76913"],{359411:function(e,n,s){s.r(n),s.d(n,{default:()=>j});var r=s(552676),c=s(740453);let i=s.p+"static/image/d74e50cb1c4314011e04b11efaff17d4.39487057.webp",l=s.p+"static/image/633b907093c8a7d9140d84da924aff0f.035c5f4d.webp",d=s.p+"static/image/c2c1dec1b0eb98796c22f95077f980de.ae2587a6.webp",o=s.p+"static/image/5390e1a9bd2a302b15c8859c6b2bd7c3.b77fb0bd.webp",a=s.p+"static/image/ef317047760256ed325b8b05b4aaf3d5.5cd13c27.webp",t=s.p+"static/image/38e77b7c82f157d8d70ffd61a2cc0c42.a97a5ded.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",code:"code",h2:"h2",h3:"h3",pre:"pre",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ol:"ol",li:"li",strong:"strong"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"5具体实现扫描--解析-ts-文件",children:["5.具体实现：扫描 & 解析 TS 文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5具体实现扫描--解析-ts-文件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["上一节课我们学习了代码分析工具的基础架构 & 分析范式，并基于此捋顺了后续课程的讲解顺序。这一节我们主要来讲解分析范式中 ",(0,r.jsx)(n.code,{children:"step3"}),"、",(0,r.jsx)(n.code,{children:"step4"})," 的实现细节，大家可以结合 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"analysis"})," 模块中的 ",(0,r.jsx)(n.code,{children:"_scanCode"}),"，",(0,r.jsx)(n.code,{children:"_scanFiles"})," 方法以及 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/file.js",target:"_blank",rel:"noopener noreferrer",children:"file"})," 与 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/parse.js",target:"_blank",rel:"noopener noreferrer",children:"parse"})," 这两个模块来理解本节内容。"]}),"\n",(0,r.jsx)(n.p,{children:"根据配置扫描所有需要分析的 TS 文件是代码分析的前提，这个很好理解，如果连要分析的代码文件在哪都不知道，又何谈去分析呢？"}),"\n",(0,r.jsxs)(n.h2,{id:"扫描-ts-文件",children:["扫描 TS 文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扫描-ts-文件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"扫描代码文件就是遍历指定目录，找出目录及其子目录下所有特定类型的文件（如：TS 文件、Vue 文件），并返回这些文件的目录路径信息。"}),"\n",(0,r.jsxs)(n.h3,{id:"glob",children:["glob",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#glob",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这里介绍一个实现文件目录扫描常用的 node 工具库 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/glob",target:"_blank",rel:"noopener noreferrer",children:"glob"}),"，它支持配置通配符规则的方式来扫描文件目录，像在 shell 里执行命令一样，获取匹配对应规则的文件。"]}),"\n",(0,r.jsx)(n.p,{children:"举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const tsFiles = glob.sync(path.join(process.cwd(), `src/**/*.ts`));\n"})}),"\n",(0,r.jsx)(n.p,{children:"上述代码演示了如何寻找 src 目录及子目录下所有的 TS 文件，要注意的一点是，这里的 src 目录指的是执行上述脚本代码时所在的工作目录，很多初学者会混淆在 node 环境中获取路径的两种方式："}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"__dirname"})," 表示当前被执行脚本文件所在的目录的绝对路径 ——脚本文件所在目录"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"process.cwd()"})," 返回运行当前脚本的工作目录的路径 —— 脚本文件执行目录"]}),"\n",(0,r.jsxs)(n.p,{children:["分析工具是以 npm 包的形式对外提供，在被安装后通常是在项目的 node_modules 目录（",(0,r.jsx)(n.code,{children:"脚本文件所在目录"}),"）下，但是需要分析的代码文件往往在项目的其他目录中，所以执行分析工具脚本的工作目录与安装目录并不一致。"]}),"\n",(0,r.jsx)(n.p,{children:"举个例子：对于 d:\\dir\\index.js"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"console.log(`cwd: ${process.cwd()}`);\nconsole.log(`dirname: ${__dirname}`);\n"})}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{}),"\n",(0,r.jsx)(n.th,{children:"process.cwd()"}),"\n",(0,r.jsx)(n.th,{children:"__dirname"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"node index.js"}),"\n",(0,r.jsx)(n.td,{children:"d:\\dir"}),"\n",(0,r.jsx)(n.td,{children:"d:\\dir"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"node dir\\index.js"}),"\n",(0,r.jsx)(n.td,{children:"d:"}),"\n",(0,r.jsx)(n.td,{children:"d:\\dir"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"file-模块",children:["File 模块",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#file-模块",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["搞清楚实现原理后，我们把扫描 TS 代码文件的方法封装成函数放在 ",(0,r.jsx)(n.code,{children:"file"})," 模块中："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// 扫描TS文件\nexports.scanFileTs = function(scanPath) {\n    const tsFiles = glob.sync(path.join(process.cwd(), `${scanPath}/**/*.ts`));\n    const tsxFiles = glob.sync(path.join(process.cwd(), `${scanPath}/**/*.tsx`));\n    // console.log(tsFiles);\n    // console.log(tsxFiles);\n    return tsFiles.concat(tsxFiles);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"scanFileTs"})," 函数以 scanPath 作为入参，用于扫描 scanPath 目录及其子目录下所有的 TS、TSX 文件，并返回它们的文件路径信息。"]}),"\n",(0,r.jsx)(n.p,{children:"扫描文件是一种基础通用能力，它的实现方式也多种多样，封装在独立的 file 模块中，codeAnalysis 在需要扫描文件的时候只需要引入 file 模块并调用其相关方法就可以了，不需要了解其具体实现细节，单独修改它也不会影响到 codeAnalysis 的分析逻辑。"}),"\n",(0,r.jsxs)(n.h2,{id:"解析-ts-文件",children:["解析 TS 文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解析-ts-文件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在扫描找到所有需要分析的 TS 代码文件后，接下来我们要将代码文件中的 TS 代码解析为 AST 对象，在第 2 节课程中，我们学习了如何通过 TypeScript Parser 的 Compiler API 来生成 AST，不过在此之前，我们有必要先了解下 TypeScript 的编译原理。"}),"\n",(0,r.jsxs)(n.h3,{id:"typescript-编译原理",children:["TypeScript 编译原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#typescript-编译原理",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["TS 编译器相关源码位于 ",(0,r.jsx)(n.a,{href:"https://github.com/Microsoft/TypeScript/tree/main/src/compiler",target:"_blank",rel:"noopener noreferrer",children:"src/compiler"})," ，主要包含 ",(0,r.jsx)(n.code,{children:"scanner"})," 扫描器（scanner.ts），",(0,r.jsx)(n.code,{children:"parser"})," 解析器（parser.ts），",(0,r.jsx)(n.code,{children:"binder"})," 绑定器（binder.ts），",(0,r.jsx)(n.code,{children:"checker"})," 检查器（checker.ts），",(0,r.jsx)(n.code,{children:"emitter"})," 发射器（emitter.ts）这 5 部分。"]}),"\n",(0,r.jsx)(n.p,{children:"编译流程可以简化为下图："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"相关概念："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Program :"})," 在编译开始时创建为一个名为 Program 编译上下文对象，通过 ",(0,r.jsx)(n.code,{children:"编译选项"})," 和 ",(0,r.jsx)(n.code,{children:"输入文件"}),"（","1个或多个，我们进行单文件分析时通常只传 1 个","）这两部分配置，加载所有输入文件以及输入文件中 imports 导入的文件（ps : 加载很多文件是因为在编译过程中会进行类型检查，而类型信息可能需要结合多个文件得出）。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tsconfig :"})," TypeScript 编译配置信息，其实就是 TS 项目中的 ",(0,r.jsx)(n.code,{children:"tsconfig.json"})," 配置文件。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tokens :"})," ",(0,r.jsx)(n.code,{children:"Scanner"})," 扫描源代码进行词法分析后生成的 ",(0,r.jsx)(n.code,{children:"Token"})," 流。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"AST :"})," ",(0,r.jsx)(n.code,{children:"Parser"})," 将 ",(0,r.jsx)(n.code,{children:"Token"})," 流进行语法分析，生成 ",(0,r.jsx)(n.code,{children:"AST"})," 对象。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Symbol :"})," ",(0,r.jsx)(n.code,{children:"Binder"})," 会创建一个用来存储每个 ",(0,r.jsx)(n.code,{children:"AST"})," 节点和对应符号 ",(0,r.jsx)(n.code,{children:"Symbol"})," 的映射表，当初次定义或者从 import 导入一个变量、函数或类时，会为其创建一个符号（唯一标识符），当在其他地方使用相同名称时，就查表找出这个名称所代表的符号, 通过 symbol 可以判定 AST 节点的语义上下文。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Checker :"})," ",(0,r.jsx)(n.code,{children:"Checker"})," 用来检查代码中变量的类型信息，提供了一些 API 获取节点类型及关联信息。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Emitter :"})," 处理 Node 节点，将 AST 转化为 js、d.ts、map等编译产物，代码分析不会涉及此阶段，可暂时忽略它。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"上面的流程也可以概括为以下四个阶段："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// 1.解析代码生成AST对象\nSourceCode（源码）~~ 扫描器 ~~> Token 流 ~~ 解析器 ~~> AST\n\n// 2.为AST节点绑定符号\nAST ~~ 绑定器 ~~> Symbols\n\n// 3.语义检查，类型检查\nAST + Symbols ~~ 检查器 ~~> 类型验证，语义上下文判断\n\n// 4.代码生成阶段（代码分析不需要关注这个阶段）\nAST + 检查器 ~~ 发射器 ~~> JavaScript 代码 （无需关注）\n"})}),"\n",(0,r.jsxs)(n.p,{children:["第一阶段我们只需要掌握如何通过 Parser 的 Compiler API 生成 ",(0,r.jsx)(n.code,{children:"AST"})," 即可，第二、第三阶段会涉及 ",(0,r.jsx)(n.code,{children:"Symbol"})," 这个概念，它会贯穿第 ",(0,r.jsx)(n.code,{children:"5"}),"、",(0,r.jsx)(n.code,{children:"6"}),"、",(0,r.jsx)(n.code,{children:"7"})," 这 3 节课程，是 API 调用分析的基础，接下来我们详细了解下 ",(0,r.jsx)(n.code,{children:"Symbol"})," 的作用。"]}),"\n",(0,r.jsxs)(n.h3,{id:"symbol",children:["Symbol",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#symbol",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Symbol"})," 正如其名就是一个标志。同一个文件中，两个不同的函数里面定义了名称相同的变量，它们属于不同的 ",(0,r.jsx)(n.code,{children:"Symbol"}),"，如果有两个文件， a.ts 导出的变量 app 在 b.ts 里使用，那这个 app 在两个文件中对应的是同一个 ",(0,r.jsx)(n.code,{children:"Symbol"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们在实现简易分析脚本的时候，没法判断下面示例代码中 getInfos 函数中的 ",(0,r.jsx)(n.code,{children:"app"})," 与 doWell 函数中的 ",(0,r.jsx)(n.code,{children:"app"})," 有什么区别，有了 Symbol 就可以区分它们了。示例代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// 待分析代码\nimport { app } from 'framework';        // import app 定义 (symbol1)\n\nconst dataLen = 3;\nlet name = 'iceman';\n\nfunction doWell () {\n    const app =4;                      // 局部常量 app 定义 (symbol2)\n    return app;                        // 局部常量 app 调用(symbol2)\n}\n\nfunction getInfos (info: string) {\n    const result = app.get(info);     // import app 调用(symbol1)\n    return result;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"Symbol Table"})," 中，每个 AST 节点都有唯一对应的符号 Symbol，相同语义上下文的 AST 节点拥有相同 Symbol，并且该 Symbol 指向第一次声明该变量的 AST 节点。"]}),"\n",(0,r.jsxs)(n.p,{children:["什么意思呢？我们把上面的示例代码放入 ",(0,r.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/PTAElD9QwJUBPNGO5RADwFAEsC2AHA9gJwC6gG9QBDddUAX1ADNtNVQByW41AUwHccBrRgblCChgkKDRY8JMqEBZ2oEk5UAAoAzgE9UAI0wAbAIwBKRIgDGmAHbL8AE2K5iAGTZnQAXlABmPom1t8Z1myuTMjGbKjEZvxG1ACuZsa4yOagVpgA6mza2kr6hIjCphb4pOQuACwCwlXV1aKAAjqAFwmAHHqA84lS5PJKapo6AEyGwti+MdjOJZU1kzX1zW0loIDAMYAUrirqWtr9iBTRcQlJzgDmvgCSZtSYykrIZ5gAXKCW2NcHuQT5QoWWoEPKMdr4bhKADojrhFNdzvoJiIwOIcMVpMtVj09AMhENcCNnD8-rgvBQgA",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"}),"，可以在右下角看到 AST 节点对应的 Symbol 信息，Symbol 对象的 declarations 属性中第一个元素指向的就是当前节点的声明节点。"]}),"\n",(0,r.jsx)(n.p,{children:"（1）第 2 行中 app 节点的 Symbol 信息："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"（2）第 13 行中 app 节点的 Symbol 信息："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"（3）第 8 行中 app 节点的 Symbol 信息："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"（4）第 9 行中 app 节点的 Symbol 信息："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["我们可以发现第 2 行中的 app 与 第 13 行中的 app 拥有相同 ",(0,r.jsx)(n.code,{children:"Symbol1"}),"，且 ",(0,r.jsx)(n.code,{children:"Symbol1"})," 指向在第 ",(0,r.jsx)(n.code,{children:"2"})," 行中由 import 语句引入的 app 声明节点。而第 8 行，第 9 行中的 app 拥有相同 ",(0,r.jsx)(n.code,{children:"Symbol2"}),"，且 ",(0,r.jsx)(n.code,{children:"Symbol2"})," 指向第 ",(0,r.jsx)(n.code,{children:"8"})," 行中的 app 声明节点，所以由此证明 doWell 中的 app 并非从 framework 中引入，属于局部常量，应该排除。"]}),"\n",(0,r.jsxs)(n.p,{children:["(上图绿框内的 ",(0,r.jsx)(n.code,{children:"pos"}),"，",(0,r.jsx)(n.code,{children:"end"})," 属性值可作为",(0,r.jsx)(n.code,{children:"声明节点"}),"的唯一性表述信息)"]}),"\n",(0,r.jsxs)(n.p,{children:["既然 Symbol 如此重要，那么如何获取 AST 节点对应的 Symbol 呢？可以通过 Compiler API 。在 第 2 节课程介绍 AST 相关知识的时候，我们学习了 ",(0,r.jsx)(n.code,{children:"createProgram"}),"、",(0,r.jsx)(n.code,{children:"getSourceFiles"})," 这 2 个 API："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"ts.createProgram"}),"，创建 Program 编译上下文，是 TS 代码分析的基础；"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"program.getSourceFiles"}),"，通过 Program 获取代码文件对应的 SourceFile 对象，也就是 AST。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"想获取 Symbol，需要通过 program 获取 Checker 对象，再由 Checker获取 Symbol ，需要学习 2 个新 API："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"program.getTypeChecker"}),"，用于通过 program 获取 Checker 控制器，该控制器用来类型检查、语义检查等；"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"typeChecker.getSymbolAtLocation"}),"，用于查询 Symbol table，获取指定 AST 节点相关联的 Symbol 信息。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"获取 Symbol 的代码示例："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// TS编译器\nconst tsCompiler = require('typescript');\n// 创建Program\n// fileNames参数表示文件路径列表，是一个数组，可以只传1个文件\n// options参数是编译选项，可以理解成tsconfig\nconst program = tsCompiler.createProgram(fileNames, options);\n// 从 Program 中获取 SourceFile 即 AST对象\n// fileName表示某一个文件路径\nconst ast = program.getSourceFile(fileName);\n// 获取 TypeChecker控制器\nconst checker = program.getTypeChecker();\n// 获取 AST node节点对应的symbol\nconst symbol = checker.getSymbolAtLocation(node);\n"})}),"\n",(0,r.jsx)(n.p,{children:"可见想要进行代码分析，仅仅获取 AST 是不够的，还需要一些编译上下文信息，控制器对象等。"}),"\n",(0,r.jsxs)(n.h3,{id:"parse-模块",children:["Parse 模块",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#parse-模块",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["基于以上所学的编译知识，我们封装一个名为 ",(0,r.jsx)(n.code,{children:"parseTs"})," 用于解析指定 TS 文件并返回 ast、checker 控制器（ 用于获取 Symbol ）的函数，并把它放在 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/parse.js",target:"_blank",rel:"noopener noreferrer",children:"parse"})," 模块中。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// 解析ts文件代码，获取ast，checker\nexports.parseTs = function(fileName) {\n    // 将ts代码转化为AST\n    const program = tsCompiler.createProgram([fileName], {})\n    const ast = program.getSourceFile(fileName);\n    const checker = program.getTypeChecker();\n    // console.log(ast);\n    return { ast, checker };\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"codeanalysis-相关逻辑",children:["codeAnalysis 相关逻辑",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#codeanalysis-相关逻辑",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上面我们学习了扫描 TS 文件，解析 TS 文件相关的知识，并将实现逻辑封装到了 ",(0,r.jsx)(n.code,{children:"file"})," 模块和 ",(0,r.jsx)(n.code,{children:"parse"})," 模块中，接下来我们看下 codeAnalysis 是如何使用它们的。"]}),"\n",(0,r.jsxs)(n.h3,{id:"扫描文件",children:["扫描文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扫描文件",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"_scanFiles"})," 函数是 codeAnalysis 基础类扫描代码文件的核心方法，它根据配置文件中的 ",(0,r.jsx)(n.code,{children:"scanSource"})," 配置项扫描指定目录下的代码文件，返回满足条件的代码文件路径信息，下面是简化后的演示片段："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { scanFileTs } = require(path.join(__dirname, './file'));  // 文件操作\n\n// 扫描文件\n_scanFiles(scanSource, type) {\n    let entrys = [];\n    scanSource.forEach((item)=>{\n      ......\n      const entryObj = {\n        name: item.name,\n        httpRepo: item.httpRepo\n      }\n      let parse = [];\n      const scanPath = item.path;\n      scanPath.forEach((sitem)=>{\n        ......\n        let tempEntry = [];\n        tempEntry = scanFileTs(sitem);\n        parse = parse.concat(tempEntry);\n        ......\n      })\n      entryObj.parse = parse;\n      entrys.push(entryObj);\n      ......\n    })\n    // console.log(entrys);\n    return entrys;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["用演示片段来讲述是想让大家只关注当前章节的内容即可，它与完整的源码肯定会有差异。上述片段完整源码实现请参考 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"lib/analysis.js"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"解析文件",children:["解析文件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解析文件",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"_scanCode"})," 是 codeAnalysis 驱动扫描文件，分析代码相关逻辑的核心方法，它还会关联 ",(0,r.jsx)(n.code,{children:"step5"})," 中的几个重要方法 ",(0,r.jsx)(n.code,{children:"_findImportItems"}),"，",(0,r.jsx)(n.code,{children:"_dealAST"}),"，下面是简化后的演示片段："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { parseTs } = require(path.join(__dirname, './parse')); // 解析模块\n\n// 扫描文件，分析代码\n_scanCode(scanSource, type) {\n    let entrys = this._scanFiles(scanSource, type);\n    // console.log(entrys);\n    entrys.forEach((item)=>{\n        const parseFiles = item.parse;\n        if(parseFiles.length>0){\n            parseFiles.forEach((element, eIndex) => {\n                ......\n                const { ast, checker } = parseTs(element);  // 解析ts文件代码,将其转化为AST                                                                                                  \n                this._findImportItems();                    // 遍历AST分析import节点\n                if(Object.keys(importItems).length >0){\n                      this._dealAST(importItems, ast, ...)  // 遍历 AST 分析 API 调用\n                  }\n                ......\n            });\n        }\n    })\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上述片段完整源码实现请参考 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"lib/analysis.js"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这一小节我们学习了如何扫描 & 解析 TS 文件，也就是分析范式中 ",(0,r.jsx)(n.code,{children:"step3"})," 和 ",(0,r.jsx)(n.code,{children:"step4"})," 的实现原理，需要大家掌握以下知识点："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["掌握 ",(0,r.jsx)(n.code,{children:"__dirname"})," 与 ",(0,r.jsx)(n.code,{children:"process.cwd()"})," 在node环境中获取路径时的区别，后续很多代码会涉及获取文件路径的逻辑，弄清楚才可以更好的阅读源码。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["基于 ",(0,r.jsx)(n.code,{children:"glob"})," 我们实现了用于扫描 TS（TSX）代码文件的 ",(0,r.jsx)(n.code,{children:"scanFileTs"})," 函数，并将其放在了 file 模块中。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["理解 Typescript 编译原理及相关控制器的用途，学会获取 ",(0,r.jsx)(n.code,{children:"Symbol"}),"， 因为它可以帮助我们判定 AST 节点的语义上下文，这一点很重要。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["掌握 codeAnalysis 中 ",(0,r.jsx)(n.code,{children:"_scanFiles"})," 函数的实现，结合 ",(0,r.jsx)(n.code,{children:"_scanCode"})," 理解 ",(0,r.jsx)(n.code,{children:"step3"})," 和 ",(0,r.jsx)(n.code,{children:"step4"})," 在分析流程中的重要性。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来的 3 节我们会针对 ",(0,r.jsx)(n.code,{children:"step5"})," 的实现原理展开学习，主要讲解 API 调用分析最核心的逻辑实现，也就是上面提到的 ",(0,r.jsx)(n.code,{children:"_findImportItems"})," 和 ",(0,r.jsx)(n.code,{children:"_dealAST"})," 等函数的具体实现原理。"]})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}let j=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F5.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%89%AB%E6%8F%8F%20%26%20%E8%A7%A3%E6%9E%90%20TS%20%E6%96%87%E4%BB%B6.md"]={toc:[{text:"扫描 TS 文件",id:"扫描-ts-文件",depth:2},{text:"glob",id:"glob",depth:3},{text:"File 模块",id:"file-模块",depth:3},{text:"解析 TS 文件",id:"解析-ts-文件",depth:2},{text:"TypeScript 编译原理",id:"typescript-编译原理",depth:3},{text:"Symbol",id:"symbol",depth:3},{text:"Parse 模块",id:"parse-模块",depth:3},{text:"codeAnalysis 相关逻辑",id:"codeanalysis-相关逻辑",depth:2},{text:"扫描文件",id:"扫描文件",depth:3},{text:"解析文件",id:"解析文件",depth:3},{text:"小结",id:"小结",depth:2}],title:"5.具体实现：扫描 & 解析 TS 文件",headingTitle:"5.具体实现：扫描 & 解析 TS 文件",frontmatter:{}}}}]);