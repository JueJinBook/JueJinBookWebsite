"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["80892"],{84309:function(n,e,s){s.r(e),s.d(e,{default:()=>l});var c=s(552676),d=s(740453);let o=s.p+"static/image/90235cc7535981b64df597ad3650c8a8.b81a6329.webp",t=s.p+"static/image/6d0f7dc4113cc95baef302bfb7786a8a.26f489e5.webp";function r(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",h3:"h3",blockquote:"blockquote",strong:"strong",img:"img",ol:"ol",li:"li"},(0,d.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"4渲染器组件是如何完成更新的",children:["4.渲染器：组件是如何完成更新的？",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4渲染器组件是如何完成更新的",children:"#"})]}),"\n",(0,c.jsxs)(e.h2,{id:"前言",children:["前言",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["上一小节，我们介绍了数据访问代理的过程以及组件实例初始化的过程，接下来，我们将介绍组件的更新逻辑，这部分逻辑主要包含在 ",(0,c.jsx)(e.code,{children:"setupRenderEffect"})," 这个函数中。"]}),"\n",(0,c.jsxs)(e.h2,{id:"组件更新",children:["组件更新",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#组件更新",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["在前面的小节中，我们说完了关于 ",(0,c.jsx)(e.code,{children:"mounted"})," 的流程。接下来我们将着重来看一下组件更新的逻辑："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n      let { next, vnode } = instance\n      // 如果有 next 的话说明需要更新组件的数组（props, slot 等）\n      if (next) {\n        next.el = vnode.el\n        // 更新组件实例信息\n        updateComponentPreRender(instance, next, optimized)\n      } else {\n        next = vnode\n      }\n      // 获取新的子树 vnode\n      const nextTree = renderComponentRoot(instance)\n      // 获取旧的子树 vnode\n      const prevTree = instance.subTree\n      // 更新子树 vnode\n      instance.subTree = nextTree\n      // patch 新老子树的 vnode\n      patch(\n        prevTree, \n        nextTree,\n        // 处理 teleport 相关\n        hostParentNode(prevTree.el),\n        // 处理 fragment 相关\n        getNextHostNode(prevTree),\n        instance,\n        parentSuspense,\n        isSVG)\n      // 缓存更新后的 DOM 节点\n      next.el = nextTree.el\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这里的核心流程是通过 ",(0,c.jsx)(e.code,{children:"next"})," 来判断当前是否需要更新 ",(0,c.jsx)(e.code,{children:"vnode"})," 的节点信息，然后渲染出新的子树 ",(0,c.jsx)(e.code,{children:"nextTree"}),"，再进行比对新旧子树并找出需要更新的点，进行 ",(0,c.jsx)(e.code,{children:"DOM"})," 更新。我们先来看一下 ",(0,c.jsx)(e.code,{children:"patch"})," 的更新流程："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function patch(n1, n2, container = null, anchor = null, parentComponent = null) {\n  // 对于类型不同的新老节点，直接进行卸载\n  if (n1 && !isSameVNodeType(n1, n2)) {\n    anchor = getNextHostNode(n1)\n    unmount(n1, parentComponent, parentSuspense, true)\n    n1 = null\n  }\n  // 基于 n2 的类型来判断\n  // 因为 n2 是新的 vnode\n  const { type, shapeFlag } = n2;\n  switch (type) {\n    case Text:\n      processText(n1, n2, container);\n      break;\n    // 其中还有几个类型比如： static fragment comment\n    case Fragment:\n      processFragment(n1, n2, container);\n      break;\n    default:\n      // 这里就基于 shapeFlag 来处理\n      if (shapeFlag & ShapeFlags.ELEMENT) {\n        processElement(n1, n2, container, anchor, parentComponent);\n      } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n        processComponent(n1, n2, container, parentComponent);\n      }\n  }\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["首先判断当 ",(0,c.jsx)(e.code,{children:"n1"})," 存在，即存在老节点，但新节点和老节点不是同类型的节点情况，那么执行销毁老节点，新增新节点。那么 ",(0,c.jsx)(e.code,{children:"Vue"})," 如何判断是否是不同类型的节点呢？答案就在 ",(0,c.jsx)(e.code,{children:"isSameVNodeType"})," 函数中："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"export function isSameVNodeType(n1, n2) {\n  // 新老节点的 type 和 key 都相同\n  return n1.type === n2.type && n1.key === n2.key\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这里比如从 ",(0,c.jsx)(e.code,{children:"div"})," 变成了 ",(0,c.jsx)(e.code,{children:"p"})," 标签，那么 ",(0,c.jsx)(e.code,{children:"isSameVNodeType"})," 就会是个 ",(0,c.jsx)(e.code,{children:"false"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["如果当新老节点是同类型的节点，则会根据 ",(0,c.jsx)(e.code,{children:"shapeFlag"}),"不同走到不同的逻辑，如果是普通元素更新，那么就会走到 ",(0,c.jsx)(e.code,{children:"processElement"})," 的逻辑中；如果是组件更新，则会走到 ",(0,c.jsx)(e.code,{children:"processComponent"})," 中。"]}),"\n",(0,c.jsx)(e.p,{children:"接下来分别看看这两种更新机制有什么不同。"}),"\n",(0,c.jsxs)(e.h3,{id:"processelement",children:["processElement",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#processelement",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["这里我们也着重看一下 ",(0,c.jsx)(e.code,{children:"processElement"})," 的更新流程："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  isSVG = isSVG || n2.type === 'svg'\n  if (n1 == null) {\n    // 初始化的过程\n  }\n  else {\n    // 更新的过程\n    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)\n  }\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"processElement"})," 更新逻辑调用 ",(0,c.jsx)(e.code,{children:"patchElement"})," 函数："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {\n  const el = (n2.el = n1.el)\n  let { patchFlag, dynamicChildren, dirs } = n2\n  // ...\n  // 旧节点的 props\n  const oldProps = (n1 && n1.props) || EMPTY_OBJ\n  // 新节点的 props\n  const newProps = n2.props || EMPTY_OBJ\n  // 对比 props 并更新\n  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG)  \n  // 先省略 dynamicChildren 的逻辑，后续介绍... \n  // 全量比对子节点更新\n  patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG)\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["可以看到普通元素的更新主要做的就是先更新 ",(0,c.jsx)(e.code,{children:"props"})," ，当 ",(0,c.jsx)(e.code,{children:"props"})," 更新完成后，然后再统一更新子节点。关于如何进行 ",(0,c.jsx)(e.code,{children:"patchProps"})," 做节点的属性更新不是本小节的重点，这里先跳过。"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["这里省略了对 ",(0,c.jsx)(e.code,{children:"dynamicChildren"})," 存在时，执行 ",(0,c.jsx)(e.code,{children:"patchBlockChildren"})," 的优化 ",(0,c.jsx)(e.code,{children:"diff"})," 过程，我们直接先看全量 ",(0,c.jsx)(e.code,{children:"diff"})," 也就是 ",(0,c.jsx)(e.code,{children:"patchChildren"})," 函数。关于 ",(0,c.jsx)(e.code,{children:"patchBlockChildren"})," 我们将在",(0,c.jsx)(e.strong,{children:"编译过程中的优化"}),"小节中进行详细介绍"]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["接着来看 ",(0,c.jsx)(e.code,{children:"patchChildren"})," 更新子节点的函数："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized = false) => {\n  // c1 代表旧节点的子节点元素\n  const c1 = n1 && n1.children\n  const prevShapeFlag = n1 ? n1.shapeFlag : 0\n  // c2 代表新节点的子节点元素\n  const c2 = n2.children\n  const { patchFlag, shapeFlag } = n2\n  // 新节点是文本\n  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n    // 旧节点是数组\n    if (prevShapeFlag & ARRAY_CHILDREN) {\n      // 卸载旧节点\n      unmountChildren(c1, parentComponent, parentSuspense)\n    }\n    if (c2 !== c1) {\n      // 新旧节点都是文本，但内容不一样，则替换\n      hostSetElementText(container, c2)\n    }\n  } else {\n    // 新节点不为文本\n    // 旧节点是数组\n    if (prevShapeFlag & ARRAY_CHILDREN) {\n      // 新节点也是数组\n      if (shapeFlag & ARRAY_CHILDREN) {\n        // 进行新旧节点的 diff\n        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n      } else {\n        // 卸载旧节点\n        unmountChildren(c1, parentComponent, parentSuspense, true)\n      }\n    } else {\n      // 新节点不为文本\n      // 旧节点不是数组\n      // 旧节点是文本\n      if (prevShapeFlag & TEXT_CHILDREN) {\n        // 则把它清空\n        hostSetElementText(container, '')\n      }\n      // 新节点是数组\n      if (shapeFlag & ARRAY_CHILDREN) {\n        // 挂载新节点\n        mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, optimized)\n      }\n    }\n  }\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["对于子节点来说，节点类型只会有三种可能，分别是：文本节点、数组节点、空节点。所以这个方法里所有的 ",(0,c.jsx)(e.code,{children:"if else"})," 分支就是在考虑新旧节点可能的全部情况，并进行相应的处理。这里流程分支有点多，画个图大家就明白在做啥了："]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,c.jsxs)(e.p,{children:["其中新旧节点都是数组的情况涉及到我们平常所说的 ",(0,c.jsx)(e.code,{children:"diff"})," 算法，会放到后面专门去解析。"]}),"\n",(0,c.jsxs)(e.p,{children:["看完处理",(0,c.jsx)(e.code,{children:"DOM"}),"元素的情况，接下来看处理",(0,c.jsx)(e.code,{children:"vue"}),"组件。"]}),"\n",(0,c.jsxs)(e.h3,{id:"processcomponent",children:["processComponent",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#processcomponent",children:"#"})]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {\n  if (n1 == null) {\n    // 初始化的过程\n  }\n  else {\n    // 更新的过程\n    updateComponent(n1, n2, parentComponent, optimized)\n  }\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"processComponent"})," 更新逻辑调用 ",(0,c.jsx)(e.code,{children:"updateComponent"})," 函数："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const updateComponent = (n1, n2, optimized) => {\n  const instance = (n2.component = n1.component)!\n   // 根据新老节点判断是否需要更新子组件\n  if (shouldUpdateComponent(n1, n2, optimized)) {\n    //...\n    // 如果需要更新，则将新节点 vnode 赋值给 next\n    instance.next = n2\n    // 执行前面定义在 instance 上的 update 函数。\n    instance.update()\n  } else {\n    // 如果不需要更新，则将就节点的内容更新到新节点上即可\n    n2.el = n1.el\n    instance.vnode = n2\n  }\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"updateComponent"})," 函数首先通过 ",(0,c.jsx)(e.code,{children:"shouldUpdateComponent"})," 函数来判断当前是否需要更新。 因为有些 ",(0,c.jsx)(e.code,{children:"VNode"})," 值的变化并不需要立即显示更新子组件，举个例子："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:"<template>\n   <div>{{msg}}</div>\n   <Child />\n</template>\n<script setup>\nimport { ref } from 'vue'\n\nconst msg = ref('hello')\n<script>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["因为子组件不依赖父组件的状态数据，所以子组件是不需要更新的。这也从侧面反映出 ",(0,c.jsx)(e.code,{children:"Vue"})," 的更新不仅是组件层面的细粒度更新，更在源码层面帮我们处理了一些不必要的子节点更新！"]}),"\n",(0,c.jsxs)(e.p,{children:["最后执行的 ",(0,c.jsx)(e.code,{children:"instance.update"}),"，这个函数其实就是在 ",(0,c.jsx)(e.code,{children:"setupRenderEffect"})," 内创建的。最终子组件的更新还会走一遍自己副作用函数的渲染，然后 ",(0,c.jsx)(e.code,{children:"patch"})," 子组件的子模板 ",(0,c.jsx)(e.code,{children:"DOM"}),"，接上上面的流程。"]}),"\n",(0,c.jsxs)(e.p,{children:["回过头来再看这里我们多次出现了 ",(0,c.jsx)(e.code,{children:"next"})," 变量。为了更好地理解整体的流程，我们再来看一个 ",(0,c.jsx)(e.code,{children:"demo"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:"<template>\n  <div>\n    hello world\n    <hello :msg=\"msg\" />\n    <button @click=\"changeMsg\">修改 msg</button>\n  </div>\n</template>\n<script>\nimport { ref } from 'vue'\nexport default {\n  setup () {\n    const msg = ref('你好')\n    function changeMsg() {\n      msg.value = '你好啊，我变了'\n    }\n    return {\n      msg,\n      changeMsg\n    }\n  }\n}\n<\/script>\n\n// hello.vue\n<template>\n  <div>\n    {{msg}}\n  </div>\n</template>\n<script>\nexport default {\n  props: {\n    msg: String\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这里有个 ",(0,c.jsx)(e.code,{children:"App.vue"})," 组件，内部有一个 ",(0,c.jsx)(e.code,{children:"hello"})," 组件，我们来从头再捋一下整体的流程，就清楚了 ",(0,c.jsx)(e.code,{children:"next"})," 的作用。"]}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:["当点击 ",(0,c.jsx)(e.code,{children:"修改 msg"})," 后， ",(0,c.jsx)(e.code,{children:"App"})," 组件自身的数据变化，导致 ",(0,c.jsx)(e.code,{children:"App"})," 组件进入 ",(0,c.jsx)(e.code,{children:"update"})," 逻辑，此时是没有 ",(0,c.jsx)(e.code,{children:"next"})," 的，接下来渲染新的子组件",(0,c.jsx)(e.code,{children:"vnode"}),"，得到真实的模板",(0,c.jsx)(e.code,{children:"vnode nextTree"}),"，用新旧",(0,c.jsx)(e.code,{children:"subTree"}),"进行",(0,c.jsx)(e.code,{children:"patch"}),"。"]}),"\n",(0,c.jsxs)(e.li,{children:["此时",(0,c.jsx)(e.code,{children:"patch"}),"的元素类型是 ",(0,c.jsx)(e.code,{children:"div"}),"，进入更新普通元素的流程，先更新",(0,c.jsx)(e.code,{children:"props"}),"，再更新子节点，当前",(0,c.jsx)(e.code,{children:"div"}),"下的子节点有",(0,c.jsx)(e.code,{children:"Hello"}),"组件时，进入组件的的更新流程。"]}),"\n",(0,c.jsxs)(e.li,{children:["在更新 ",(0,c.jsx)(e.code,{children:"Hello"})," 组件时，根据 ",(0,c.jsx)(e.code,{children:"updateComponent"})," 函数执行的逻辑，会先将",(0,c.jsx)(e.code,{children:"Hello"}),"组件 ",(0,c.jsx)(e.code,{children:"instance.next"})," 赋值为最新的子组件 ",(0,c.jsx)(e.code,{children:"vnode"}),"，之后再主动调用",(0,c.jsx)(e.code,{children:"instance.update"})," 进入上面的副作用渲染函数，这次的实例是 ",(0,c.jsx)(e.code,{children:"Hello"})," 组件自身的渲染，且 ",(0,c.jsx)(e.code,{children:"next"})," 存在值。"]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["当 ",(0,c.jsx)(e.code,{children:"next"})," 存在时，会执行 ",(0,c.jsx)(e.code,{children:"updateComponentPreRender"})," 函数："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const updateComponentPreRender = (instance, nextVNode, optimized) => {\n  // 新节点 vnode.component 赋值为 instance\n  nextVNode.component = instance\n  // 获取老节点的 props\n  const prevProps = instance.vnode.props\n  // 为 instance.vnode 赋值为新的组件 vnode \n  instance.vnode = nextVNode\n  instance.next = null\n  // 更新 props\n  updateProps(instance, nextVNode.props, prevProps, optimized)\n  // 更新 slots\n  updateSlots(instance, nextVNode.children)\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"updateComponentPreRender"})," 函数核心功能就是完成了对实例上的属性、",(0,c.jsx)(e.code,{children:"vnode"})," 信息、",(0,c.jsx)(e.code,{children:"slots"})," 进行更新，当后续组件渲染的时候，得到的就是最新的值。"]}),"\n",(0,c.jsxs)(e.p,{children:["总而言之，",(0,c.jsx)(e.code,{children:"next"})," 就是用来标记接下来需要渲染的子组件，如果 ",(0,c.jsx)(e.code,{children:"next"})," 存在，则会进行子组件实例相关内容属性的更新操作，再进行子组件的更新流程。"]}),"\n",(0,c.jsxs)(e.h2,{id:"总结",children:["总结",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["本节着重介绍了组件的更新逻辑，我们再补齐一下",(0,c.jsx)(e.a,{href:"https://juejin.cn/book/7146465352120008743/section/7146465352287780875",target:"_blank",rel:"noopener noreferrer",children:"第二节"}),"中的流程图："]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,c.jsxs)(e.p,{children:["本节介绍了关于普通元素的简单更新过程，那关于复杂的更新过程的逻辑，也就是新老子节点都是数组的普通元素，应该如何进行更新呢？这就涉及到了 ",(0,c.jsx)(e.code,{children:"diff"})," 算法，我们下节接着介绍。"]})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(r,{...n})}):r(n)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F4.%E6%B8%B2%E6%9F%93%E5%99%A8%EF%BC%9A%E7%BB%84%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%9B%B4%E6%96%B0%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"组件更新",id:"组件更新",depth:2},{text:"processElement",id:"processelement",depth:3},{text:"processComponent",id:"processcomponent",depth:3},{text:"总结",id:"总结",depth:2}],title:"4.渲染器：组件是如何完成更新的？",headingTitle:"4.渲染器：组件是如何完成更新的？",frontmatter:{}}}}]);