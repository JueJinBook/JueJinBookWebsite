"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["62319"],{385871:function(e,n,a){a.r(n),a.d(n,{default:()=>t});var r=a(552676),s=a(740453);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",h4:"h4",pre:"pre",code:"code"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"11babel-插件的单元测试",children:["11.Babel 插件的单元测试",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11babel-插件的单元测试",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"单元测试可以保证代码质量，我们写完代码实现了功能之后，要书写对应功能点的单测，这样有很多好处："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"单测就是文档，可以根据单测了解插件的功能"}),"\n",(0,r.jsx)(n.li,{children:"代码改动跑一下单测就知道功能是否正常，快速回归测试，方便后续迭代"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"那 babel 插件应该怎样做单测？"}),"\n",(0,r.jsxs)(n.h2,{id:"babel-插件单元测试的方式",children:["babel 插件单元测试的方式",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babel-插件单元测试的方式",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"babel 插件做的事情就是对 AST 做转换，那么我们很容易可以想到几种测试的方式："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"测试转换后的 AST，是否符合预期"}),"\n",(0,r.jsx)(n.li,{children:"测试转换后生成的代码，是否符合预期（如果代码比较多，可以存成快照，进行快照对比）"}),"\n",(0,r.jsx)(n.li,{children:"转换后的代码执行一下，测试是否符合预期"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"分别对应的代码（使用 jest）："}),"\n",(0,r.jsxs)(n.h4,{id:"ast测试",children:["AST测试",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ast测试",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这种测试方法就是判断AST 修改的对不对"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"it('包含guang', () => {\n  const {ast} = babel.transform(input, {plugins: [plugin]});\n  \n  const program = ast.program;\n  const declaration = program.body[0].declarations[0];\n  \n  assert.equal(declaration.id.name, 'guang');// 判断 AST 节点的值\n});\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"生成代码的快照测试",children:["生成代码的快照测试",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#生成代码的快照测试",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这种测试方法是每次测试记录下快照，后面之前的对比下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"it('works', () => {\n  const {code} = babel.transform(input, {plugins: [plugin]});\n  \n  expect(code).toMatchSnapshot();\n});\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"执行测试",children:["执行测试",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行测试",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这种测试就是执行下转换后的代码，看执行是否正常："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"it('替换baz为foo', () => {\n  var input = `\n    var foo = 'guang';\n    // 把baz重命名为foo\n    var res = baz;\n  `;\n  \n  var {code} = babel.transform(input, {plugins: [plugin]});\n  \n  var f = new Function(`\n    ${code};\n    return res;\n  `);\n  var res = f();\n  \n  assert(res === 'guang', 'res is guang');\n});\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"这三种方式都可以，一般还是第二种方式用的比较多，babel 也是封装了这种方式，提供了 babel-plugin-tester 包。"}),"\n",(0,r.jsxs)(n.h2,{id:"babel-plugin-tester",children:["babel-plugin-tester",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#babel-plugin-tester",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"babel-plugin-tester 就是对比生成的代码的方式来实现的。"}),"\n",(0,r.jsx)(n.p,{children:"可以直接对比输入输出的字符串，也可以对比文件，还可以对比快照："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import pluginTester from 'babel-plugin-tester';\nimport xxxPlugin from '../xxx-plugin';\n\npluginTester({\n  plugin: xxxPlugin,\n  fixtures: path.join(__dirname, '__fixtures__'), // 保存测试点的地方\n  tests: {\n    'case1:xxxxxx': '\"hello\";', // 输入输出都是同个字符串\n    'case2:xxxxxx': { // 指定输入输出的字符串\n      code: 'var hello = \"hi\";',\n      output: 'var olleh = \"hi\";',\n    },\n    'case3:xxxxxx': { // 指定输入输出的文件，和真实输出对比\n      fixture: 'changed.js',\n      outputFixture: 'changed-output.js',\n    },\n    'case4:xxxxxx': { // 指定输入字符串，输出到快照文件中，对比测试\n      code: `\n        function sayHi(person) {\n          return 'Hello ' + person + '!'\n        }\n      `,\n      snapshot: true,\n    },\n  },\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"这三种方式本质上都一样，但是根据情况，如果比较少的内容可以直接对比字符串，内容比较多的时候可以使用快照测试，或者指定输出内容，然后对比测试。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这一节我们了解了 babel 插件测试的几种思路，babel-plugin-tester 是利用对结果进行对比的思路，对比方式可以选择直接对比字符串、对比 fixture 文件的内容和实际输出内容、对比快照这 3 种方式。"}),"\n",(0,r.jsx)(n.p,{children:"学完这一节，我们可以给 babel 插件加上单元测试来保证质量了。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let t=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F11.Babel%20%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.md"]={toc:[{text:"babel 插件单元测试的方式",id:"babel-插件单元测试的方式",depth:2},{text:"AST测试",id:"ast测试",depth:4},{text:"生成代码的快照测试",id:"生成代码的快照测试",depth:4},{text:"执行测试",id:"执行测试",depth:4},{text:"babel-plugin-tester",id:"babel-plugin-tester",depth:2},{text:"总结",id:"总结",depth:2}],title:"11.Babel 插件的单元测试",headingTitle:"11.Babel 插件的单元测试",frontmatter:{}}}}]);