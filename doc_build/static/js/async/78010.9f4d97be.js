"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["78010"],{520618:function(e,n,s){e.exports=s.p+"static/image/1c1e2939afe79aa2373f7f9120bc0fa9.f60fe213.webp"},750087:function(e,n,s){e.exports=s.p+"static/image/5ae4ce59071323a7a331d39d5fe6e988.739b63e8.webp"},433495:function(e,n,s){e.exports=s.p+"static/image/7c7b9d21ab6f11eb594c2a3a5d32b38c.8ab8d811.webp"},929040:function(e,n,s){e.exports=s.p+"static/image/7ef110dfa7abf9daa9516e919c09ccca.18869f06.webp"},700649:function(e,n,s){e.exports=s.p+"static/image/7f725810e559df684943b7d74cdec9bb.3ca44127.webp"},467446:function(e,n,s){e.exports=s.p+"static/image/8914b66b0c7a14487df9f2ff8b4089d3.8353e9b9.webp"},679949:function(e){e.exports="data:image/webp;base64,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"},310009:function(e,n,s){e.exports=s.p+"static/image/a0e32a0f294ab74cc533897ced9c3ead.9cea7520.webp"},810507:function(e,n,s){e.exports=s.p+"static/image/a3c09d2de90059ff560092027eb1c3f4.bfba8c47.webp"},16209:function(e,n,s){e.exports=s.p+"static/image/a47f3bab2d5e33d49ce8dc48268a12d8.ce66ccde.webp"},359700:function(e,n,s){e.exports=s.p+"static/image/a9e549ee8c9a78358d0481d8cf7e89bf.e32eeed9.webp"},134621:function(e,n,s){e.exports=s.p+"static/image/e5ae480d7574699aa5bdab2209dfab2c.0078f5f1.webp"},487753:function(e,n,s){e.exports=s.p+"static/image/f43385c5581deed47ef6ebc995717945.37a44a85.webp"},97406:function(e,n,s){s.r(n),s.d(n,{default:()=>C});var r=s(552676),d=s(740453),o=s(310009),i=s(16209),c=s(929040),l=s(700649),t=s(487753),h=s(520618),j=s(810507),a=s(750087),m=s(433495),x=s(134621),p=s(679949),u=s(359700),S=s(467446);function f(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",ol:"ol",li:"li",blockquote:"blockquote",h3:"h3",img:"img",ul:"ul",h4:"h4",strong:"strong",h5:"h5"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"3-模块机制详解cjs-与-esm上",children:["3-模块机制详解：CJS 与 ESM（上）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-模块机制详解cjs-与-esm上",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Node.js 为什么能崛起？一方面自然是语言群体使然，JavaScript 群体本来就拥有巨量的人口，可以不换语言就能上手，自然就引来了一大波从业人员；另一方面，“生态”功不可没。"}),"\n",(0,r.jsxs)(n.h2,{id:"javascript-模块机制",children:["JavaScript 模块机制",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-模块机制",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"为什么这里提到的是 JavaScript 模块机制，而不是 Node.js 的模块机制？因为模块机制不是 Node.js 特有的，这是一路发展下来的产物，只不过 Node.js 恰好用了其之一二。"}),"\n",(0,r.jsx)(n.p,{children:"最早的时候，JavaScript 只用来做简单的交互操作，非常简单。这个时候自然也没模块的概念，最多是一个 HTML 页面中，嵌入多个 JavaScript 标签，如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<html>\n  <head>\n     <script src="foo.js"><\/script>\n     <script src="bar.js"><\/script>\n     <script>\n     alert(\'Hello world!\');\n     <\/script>\n  </head>\n  <body>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这里面就有三“段” JavaScript 代码，依次是 ",(0,r.jsx)(n.code,{children:"foo.js"}),"、",(0,r.jsx)(n.code,{children:"bar.js"})," 和之后一段嵌入页面的 JavaScript 代码。硬要说其是“模块”也不是不可以，只不过它们在未经特殊处理的前提下，是会互相污染的。比如，在 ",(0,r.jsx)(n.code,{children:"foo.js"})," 中写 ",(0,r.jsx)(n.code,{children:"window.alert = function() {}"})," 是会实实在在影响到后面的。"]}),"\n",(0,r.jsx)(n.p,{children:"所谓模块就是为了解决这些问题的："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"模块必须是密闭空间，所有与外界沟通交互的事项都必须有明确意图；"}),"\n",(0,r.jsx)(n.li,{children:"模块是为了将大型应用程序切割成独立维护的小块事物，可以更易被使用和维护。"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.h3,{children:"人类是模块化的"}),"\n",(0,r.jsx)(n.p,{children:"按照上述两个问题，人类各器官是“密闭”的，与其他模块交互都是通过各自的“接口”。如胰腺通过主胰管与十二指肠相连，分泌胰液以助消化。接口一旦出问题，则会引起模块故障，急性胰腺炎就是这么来的。其他器官也多多少少会通过各种管子相互连接，进行交互。"}),"\n",(0,r.jsxs)(n.p,{children:["人类各器官虽然各有关联，但都相对独立。比如胃出问题了，不会让你把整个人换掉，而是定点“修胃”即可，这样更好维护。脑子同理\uD83E\uDD2A。 ",(0,r.jsx)("img",{src:S,alt:"image.png"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"JavaScript 后来逐渐发展，Gmail 出来了。Gmail 曾尝试了一些新的概念——AJAX，这个概念在当下早已习以为常，甚至已经开始了“下一代”的技术。Gmail 产品经理基斯\xb7科尔曼（Keith Coleman）曾说：“在编写 Gmail 时，AJAX 这个术语还不存在。”Gmail 推出的时机很耐人寻味，是在大家对邮箱应用已经毫无兴趣的时候。不过所有人却都眼前一亮——原来邮箱还可以这么做。"}),"\n",(0,r.jsx)(n.p,{children:"除了 AJAX 之外，这也昭示着 JavaScript 应用越写越复杂。那自然，大家对“模块”的诉求就开始展露出来。古早时候，虽然在 JavaScript 尚未出现模块概念，但大家已经开始用一些奇技淫巧来做一些事情了。"}),"\n",(0,r.jsxs)(n.h3,{id:"iife",children:["IIFE",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#iife",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:"04插图1.png"})}),"\n",(0,r.jsxs)(n.p,{children:["IIFE 就是所谓的古早方式。它全称 Immediately Invoked Function Expression，即",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE",title:"https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE",target:"_blank",rel:"noopener noreferrer",children:"立即函数调用表达式"}),"。它是一个在定义时就会立即执行的 JavaScript 函数。就像这样："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"(function () {\n  // statements\n})();\n"})}),"\n",(0,r.jsx)(n.p,{children:"它通过一个闭包来做到内部变量的一些隔离，然后通过立即执行该闭包来得到相应的结果。这样就可以很方便地通过执行一些复杂逻辑来得到一个所谓的“模块”，而把逻辑变成内部私有形式给隔离开来，如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"const pub = (function () {\n  const priv = '你拿不到我';\n  return priv.replace('不', '') + '了';\n})();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["你拿不到 ",(0,r.jsx)(n.code,{children:"priv"})," 的 ",(0,r.jsx)(n.code,{children:"'你拿不到我'"}),"，但你可以拿到 ",(0,r.jsx)(n.code,{children:"pub"})," 的 ",(0,r.jsx)(n.code,{children:"'你拿到我了'"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"四大模块体系",children:["四大模块体系",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四大模块体系",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"在 IIFE 之后，业界内迸发出几类 JavaScript 的模块体系。其中最流行的四大体系分别为："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"CommonJS；"}),"\n",(0,r.jsx)(n.li,{children:"AMD；"}),"\n",(0,r.jsx)(n.li,{children:"CMD；"}),"\n",(0,r.jsx)(n.li,{children:"UMD。"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"amd--cmd--umd",children:["AMD / CMD / UMD",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#amd--cmd--umd",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这里三大模块体系中，只有首字母不一样，而后两个字母则都是 Module Definition 的缩写。AMD 是 Asynchronous Module Definition，即异步模块定义；CMD 是 Common Module Definition，即一般模块定义，虽然 Common 也含通用意思，但这里将其译为“一般”是为了不与后面 UMD 冲突；UMD 则是 Universal Module Definition，即通用模块定义。"}),"\n",(0,r.jsxs)(n.p,{children:["AMD 最开始在 ",(0,r.jsx)(n.a,{href:"https://requirejs.org/",title:"https://requirejs.org/",target:"_blank",rel:"noopener noreferrer",children:"require.js"})," 中被使用，其首个提交是在 2009 年发出的。CMD 与 AMD 很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。CMD 是在推行 ",(0,r.jsx)(n.a,{href:"https://seajs.github.io/seajs",title:"https://seajs.github.io/seajs",target:"_blank",rel:"noopener noreferrer",children:"Sea.js"})," 中产生的，而 Sea.js 则是玉伯大佬多年前的作品。UMD 是个“大一统”，在当时的野心是对 CommonJS、AMD 和 CMD 做兼容。"]}),"\n",(0,r.jsx)(n.p,{children:"由于这三种模块方式与 Node.js 几乎没有关系，就不继续展开了。"}),"\n",(0,r.jsxs)(n.h4,{id:"commonjs",children:["CommonJS",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:"04插图2.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://www.commonjs.org/",title:"https://www.commonjs.org/",target:"_blank",rel:"noopener noreferrer",children:"CommonJS"})," 模块规范发布于 2009 年，由 Mozilla 工程师 Kevin Dangoor 起草，他于当年 1 月发表了一篇文章《",(0,r.jsx)(n.a,{href:"https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/",title:"https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/",target:"_blank",rel:"noopener noreferrer",children:"What Server-side JavaScript Needs"}),"》。",(0,r.jsx)(n.strong,{children:"注意这个时间，2009 年。嘿！这不巧了吗！"})," 其实 AMD 这类也基本上是在 2009、2010 时间点出现的。而本小册的主角 Node.js，以及其依赖的 V8 也都是相仿阶段出生的。",(0,r.jsx)(n.strong,{children:"我们说 2010 年前后几年是泛前端体系开始觉醒的两年是丝毫不怵的。"})]}),"\n",(0,r.jsx)(n.p,{children:"CommonJS 最初的主要目的是为除浏览器环境之外的 JavaScript 环境建立模块生态系统公约。继续注意这个词，“除浏览器之外的 JavaScript 环境”。答案是不是呼之欲出？其实 CommonJS 最初不叫 CommonJS，而是叫 ServerJS。后来觉得路走窄了没朋友，就把 Server 改成了 Common——把浏览器又给包括回来了。在 CommonJS 的官网，是这么一句口号："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"JavaScript: not just for browsers any more!"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"按其说法，在 CommonJS 规范之下，你可以写："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"服务端 JavaScript 应用；"}),"\n",(0,r.jsx)(n.li,{children:"命令行工具；"}),"\n",(0,r.jsx)(n.li,{children:"桌面 GUI 应用；"}),"\n",(0,r.jsx)(n.li,{children:"混合应用（Titanium，Adobe AIR……）。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["怎么看都是 Node.js 的覆盖范围呀。所以在 CommonJS 发布之后，它就一直被 Node.js 所使用，沿用至今。回到本章的标题上，",(0,r.jsx)(n.strong,{children:"CommonJS 缩写就是 CJS"}),"。所以，这个就是 Node.js 一直以来的模块规范。"]}),"\n",(0,r.jsx)(n.p,{children:"CommonJS 中定义了其需包含三项必选项和一些可选项。"}),"\n",(0,r.jsxs)(n.h5,{id:"必选项",children:["必选项",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#必选项",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在一个符合 CommonJS 的 JavaScript 模块中，需包含三个必选项。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["第一个，",(0,r.jsx)(n.code,{children:"require"})]}),"。",(0,r.jsx)(n.code,{children:"require"})," 是一个函数，这个函数有一个参数代表模块标识，它的返回值就是其所引用的外部模块所暴露的 API。"]}),"\n",(0,r.jsxs)(n.p,{children:["讲得直白一点，就是能通过代码 ",(0,r.jsx)(n.code,{children:"const biu = require('boom_shakalaka')"})," 的形式引入 boom_shakalaka 这个模块并赋给 biu。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第二个，模块上下文"}),"。在一个 CommonJS 的模块上下文中，需要有满足如下条件的一些事项存在："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"require"})," 函数，即前面提到的那个“倒霉鬼”；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"exports"})," 对象，这是一个用于导出模块内容的通道，对应前面胰腺的“主胰管”；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"module"})," 对象，内含该模块元信息，比如一个制度的 ",(0,r.jsx)(n.code,{children:"id"})," 字段；实际上，Node.js 中的 ",(0,r.jsx)(n.code,{children:"module"})," 下还含了初始的 ",(0,r.jsx)(n.code,{children:"exports"})," 对象。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"第三个，模块标识"}),"。模块标识其实就是一个字符串，用于传给 ",(0,r.jsx)(n.code,{children:"require"})," 函数。"]}),"\n",(0,r.jsxs)(n.h5,{id:"可选项",children:["可选项",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#可选项",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"可选项中，有两个未指定的约定。在必选项符合 CommonJS 规范的情况下，下面两项无论是什么都可。"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"模块的存储方案未指定，一个模块的内容可以存在于数据库、文件系统、工厂函数，甚至于一个链接库中；"}),"\n",(0,r.jsx)(n.li,{children:"实现 CommonJS 规范的模块加载器可以支持 PATH 环境变量用以加载时的寻径，但是也可以不支持。"}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"看一眼",children:["看一眼",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#看一眼",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面我只是用通俗的方式来讲述 CommonJS 的规范，并不严谨。若需要严谨的解释，大家可自行前往 CommonJS 的 Wiki 获取官方资料。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://wiki.commonjs.org/wiki/Modules/1.1.1",title:"https://wiki.commonjs.org/wiki/Modules/1.1.1",target:"_blank",rel:"noopener noreferrer",children:"wiki.commonjs.org/wiki/Module…"})}),"\n",(0,r.jsx)(n.p,{children:"这里给出一个遵循 CommonJS 规范的简单样例代码，同样来自 CommonJS 的 Wiki。其是遵循 CommonJS 规范的模块，但并不代表它就是 Node.js 的模块。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// math.js\nexports.add = function() {\n    var sum = 0, i = 0, args = arguments, l = args.length;\n    while (i < l) {\n        sum += args[i++];\n    }\n    return sum;\n};\n\n// increment.js\nvar add = require('math').add;\nexports.increment = function(val) {\n    return add(val, 1);\n};\n\n// program.js\nvar inc = require('increment').increment;\nvar a = 1;\ninc(a); // 2\n\nmodule.id == \"program\";\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们可以看到，在 ",(0,r.jsx)(n.code,{children:"increment.js"})," 模块中，其加载了 ",(0,r.jsx)(n.code,{children:"math.js"})," 模块（类比胰腺），",(0,r.jsx)(n.code,{children:"math.js"})," 又通过 ",(0,r.jsx)(n.code,{children:"exports"}),"（主胰管）将 ",(0,r.jsx)(n.code,{children:"add"}),"（胰液）输送到了 ",(0,r.jsx)(n.code,{children:"increment.js"}),"（十二指肠）中。"]}),"\n",(0,r.jsxs)(n.p,{children:["同样，我们可以用类似的话来套用到 ",(0,r.jsx)(n.code,{children:"program.js"})," 与 ",(0,r.jsx)(n.code,{children:"increment.js"})," 中。"]}),"\n",(0,r.jsx)(n.p,{children:"它看起来就像这样："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h3,{id:"ecmascript-modules",children:["ECMAScript Modules",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ecmascript-modules",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"之前 JavaScript 一直没有一个模块机制，所谓的 IIFE、四大模块体系都是三方规范和实现，与 JavaScript 自身并无关系。Node.js 一直以来用的都是 CommonJS 模块机制，而非 “JavaScript 模块机制”或 “ECMAScript 模块机制”。"}),"\n",(0,r.jsx)(n.p,{children:"但 ECMAScript 规范自身一直在迭代。ECMAScript modules 就是 ECMAScript 的官方模块机制了。像 Sea.js、require.js，都是三方实现的，甚至 Node.js 中的 CommonJS 也是 Node.js 在自身代码里面实现的，并不是 V8 的能力。ECMAScript Modules 则不一样，其会被实现对应 ECMAScript 版本的引擎内置在语言特性中，而不用自己实现一套模块机制。比如你用了 V8 对应版本，那么只要通过 V8 的 API 适配一下模块加载，就直接拥有了导入模块的能力。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ECMAScript Modules 又称 ES Modules，缩写 ESM"}),"。因为其首次在 ECMAScript 6 中",(0,r.jsx)(n.a,{href:"https://262.ecma-international.org/6.0/#sec-modules",title:"https://262.ecma-international.org/6.0/#sec-modules",target:"_blank",rel:"noopener noreferrer",children:"被提出"}),"，网上也有人称其为 ES6 Modules。这个弯弯绕绕就是在",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7196627546253819916/section/7196992628036993028",title:"https://juejin.cn/book/7196627546253819916/section/7196992628036993028",target:"_blank",rel:"noopener noreferrer",children:"第三章"}),"中提到的“「茴」字的四种写法”。但无论它叫什么，我们都说它是 ECMAScript 规范中定义的模块机制。"]}),"\n",(0,r.jsxs)(n.p,{children:["它的设计非常“精简”与“官方”，从语法层面就完成了对模块的定义。像 CommonJS 也好，AMD、CMD 等也罢，都是通过三方实现函数和对象来模拟模块，而 ESM 则直接通过 ",(0,r.jsx)(n.code,{children:"import"})," 与 ",(0,r.jsx)(n.code,{children:"export"})," 语法来导入和导出模块。只要宿主支持，那么该语法就直接能用。事实上，大多数现代浏览器都已经支持这种语法了，最新的几个大版本 Node.js 中也有了 ESM 的支持。"]}),"\n",(0,r.jsx)(n.p,{children:"CommonJS 是运行时做的模块加载和运行，它可以在代码执行一半的时候以动态的方式加载，这种方法在一些静态分析的时候会造成阻碍。而 ESM 则是在模块顶部以语法的形式加载模块，完全可以做静态分析。"}),"\n",(0,r.jsx)(n.p,{children:"它的语法像这样："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// export.js\nexport default function () {\n  console.log('foo');\n}\n\n// import.js\nimport foo from 'export';\nfoo(); // 'foo'\n"})}),"\n",(0,r.jsx)(n.p,{children:"抛开语法、语义及运行时机不说，其实它的效果图还是跟 CommonJS 差不多："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["这里点到为止，不会讲 ESM 导出导入的各种方式，是 ",(0,r.jsx)(n.code,{children:"default"})," 还是什么 ",(0,r.jsx)(n.code,{children:"*"}),"。如果你想补这方面的课，建议可以看看网上文章，资料非常多。或者看看 ECMAScript 规范、Node.js 相关教程，或者阮一峰的《",(0,r.jsx)(n.a,{href:"https://es6.ruanyifeng.com/#docs/module",title:"https://es6.ruanyifeng.com/#docs/module",target:"_blank",rel:"noopener noreferrer",children:"ECMAScript 6 入门"}),"》。"]}),"\n",(0,r.jsxs)(n.h2,{id:"nodejs-的模块机制",children:["Node.js 的模块机制",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-的模块机制",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["其实在前文提到了，",(0,r.jsx)(n.strong,{children:"Node.js 一直以来都是以 CommonJS 作为其模块的基座"}),"，而在最新几个大版本中则加入了对 ESM 的支持。"]}),"\n",(0,r.jsxs)(n.p,{children:["Node.js 的 ESM 最开始是在 v8.5.0 中支持的，当时还是 Experimental 特性，需要加上 ",(0,r.jsx)(n.code,{children:"--experimental-modules"})," 参数启动 Node.js 才行。Node.js 在 v12.17.0 中移除了 ",(0,r.jsx)(n.code,{children:"--experimental-modules"})," 参数，并于 v12 后续版本中将 ESM 转正（Stable）。"]}),"\n",(0,r.jsxs)(n.h3,{id:"nodejs-中的-cjs",children:["Node.js 中的 CJS",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中的-cjs",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 Node.js 中，一个文件被视为一个“模块”，它同样遵循 CommonJS 规范，在一个“模块”中，自带了："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"require"})," 函数；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"exports"})," 对象；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"module"})," 对象。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["要导出模块，同样是将胰液输到 ",(0,r.jsx)(n.code,{children:"exports"})," 中。"]}),"\n",(0,r.jsxs)(n.p,{children:["不过，它也做了一些额外的事情，比如 CommonJS 中定义了模块得是 ",(0,r.jsx)(n.code,{children:"."}),"、",(0,r.jsx)(n.code,{children:".."})," 或者小驼峰命名的标识，而 Node.js 则更宽泛，基本上等同于“文件名”。"]}),"\n",(0,r.jsxs)(n.p,{children:["以及，Node.js 的 ",(0,r.jsx)(n.code,{children:"module"})," 对象下还挂载了个 ",(0,r.jsx)(n.code,{children:"module.exports"})," 对象，其初始值指向 CommonJS 所定义的 ",(0,r.jsx)(n.code,{children:"exports"})," 对象。而真正的“主胰管”是 ",(0,r.jsx)(n.code,{children:"module.exports"}),"，并不是 ",(0,r.jsx)(n.code,{children:"exports"}),"。当二者指向相同的时候，我们的确是可以 ",(0,r.jsx)(n.code,{children:"exports.foo = bar"}),"。但若我们重新指定了 ",(0,r.jsx)(n.code,{children:"module.exports"}),"，就相当于我们换了条“主胰管”，原来那条作废了。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"module.exports = {  // 换主胰管手术\n  foo: 'bar',\n};\n\nexports.hello = 'world';  // 原主胰管作废\n"})}),"\n",(0,r.jsx)(n.p,{children:"在一个模块的作用域中，除了上面提到的 CommonJS 规范的内容、Node.js 自己做的改变外，Node.js 还增加了一些内容。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"__dirname"}),"：这个变量在每个 CJS 模块中都存在，它的值是模块所在的目录名。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"__filename"}),"：同上，只不过其值为模块的文件名。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"require.cache"}),"：",(0,r.jsx)(n.code,{children:"require"})," 本身是个函数，但它下面还挂了一个 ",(0,r.jsx)(n.code,{children:"cache"})," 对象，缓存了所 ",(0,r.jsx)(n.code,{children:"require"})," 的内容，通常不会用到，更多内容可以查看 Node.js 的",(0,r.jsx)(n.a,{href:"https://nodejs.org/docs/latest-v18.x/api/modules.html#requirecache",title:"https://nodejs.org/docs/latest-v18.x/api/modules.html#requirecache",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"require.main"}),"：入口文件的所映射的 ",(0,r.jsx)(n.code,{children:"Module"})," 实例。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"其实还有更多内容被列在文档中，有兴趣可自行查询。"}),"\n",(0,r.jsxs)(n.p,{children:["在上面有提到，",(0,r.jsx)(n.code,{children:"require.main"})," 是入口文件所映射的 ",(0,r.jsx)(n.code,{children:"Module"})," 对象。这里的 ",(0,r.jsx)(n.code,{children:"Module"})," 对象之前没提过。在 Node.js 中，每一个 CJS 模块最终会被加载成一个 ",(0,r.jsx)(n.code,{children:"Module"})," 类的实例，被放在 Node.js 内部的内存中，并在“必要”的时候传递给各模块。"]}),"\n",(0,r.jsxs)(n.p,{children:["各模块中大家所使用的 ",(0,r.jsx)(n.code,{children:"module"})," 对象就是该模块对应的 ",(0,r.jsx)(n.code,{children:"Module"})," 类实例。它除了包含 ",(0,r.jsx)(n.code,{children:"exports"})," 对象之外，还包含："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"children"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"filename"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"id"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"loaded"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"path"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"paths"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"require()"}),"。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们来看看这么个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// test2.js\nconsole.log(module);\nconsole.log(require.main);\n\n// test.js\nrequire('./test2');\nconsole.log(module);\nprocess.nextTick(() => {\n    console.log(module);\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这两个文件代码中，执行 ",(0,r.jsx)(n.code,{children:"node test.js"})," 后，会有四次关于 ",(0,r.jsx)(n.code,{children:"Module"})," 实例的输出。"]}),"\n",(0,r.jsxs)(n.p,{children:["第一次是 ",(0,r.jsx)(n.code,{children:"test2.js"})," 自身的 ",(0,r.jsx)(n.code,{children:"module"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Module {\n  id: '/foo/test2.js',\n  path: '/foo',\n  exports: {},\n  filename: '/foo/test2.js',\n  loaded: false,\n  children: [],\n  paths: [\n    '/foo/node_modules',\n    '/node_modules'\n  ]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["因为在做这一次 ",(0,r.jsx)(n.code,{children:"console.log"})," 的时候，",(0,r.jsx)(n.code,{children:"test2.js"})," 模块自身代码还没执行完，也就是说仍在“加载”，所以 ",(0,r.jsx)(n.code,{children:"loaded"})," 为 ",(0,r.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["第二次是 ",(0,r.jsx)(n.code,{children:"test2.js"})," 输出 ",(0,r.jsx)(n.code,{children:"require.main"}),"，它对应的是入口模块的 ",(0,r.jsx)(n.code,{children:"Module"})," 实例，即 ",(0,r.jsx)(n.code,{children:"test.js"})," 这个模块。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Module {\n  id: '.',\n  path: '/foo',\n  exports: {},\n  filename: '/foo/test.js',\n  loaded: false,\n  children: [\n    Module {\n      id: '/foo/test2.js',\n      path: '/foo',\n      exports: {},\n      filename: '/foo/test2.js',\n      loaded: false,\n      children: [],\n      paths: [Array]\n    }\n  ],\n  paths: [\n    '/foo/node_modules',\n    '/node_modules'\n  ]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看出，主模块正在执行 ",(0,r.jsx)(n.code,{children:"require('./test2.js')"})," 这行代码，自身也并未加载完，",(0,r.jsx)(n.code,{children:"loaded"})," 自然也为 ",(0,r.jsx)(n.code,{children:"false"}),"。而它对比 ",(0,r.jsx)(n.code,{children:"test2.js"})," 的 ",(0,r.jsx)(n.code,{children:"Module"})," 实例又多了 ",(0,r.jsx)(n.code,{children:"children"})," 元素，里面的 ",(0,r.jsx)(n.code,{children:"Module"})," 实例就是 ",(0,r.jsx)(n.code,{children:"test2.js"})," 的 ",(0,r.jsx)(n.code,{children:"Module"})," 实例。这说明了它们的依赖关系。这个依赖关系是运行时生成的，也就是说如果你在未来某个时刻通过 ",(0,r.jsx)(n.code,{children:"setTimeout"})," 之类的方式去加载某个模块，那么依赖关系会在那个时刻再多一个元素。"]}),"\n",(0,r.jsxs)(n.p,{children:["第三次输出是由 ",(0,r.jsx)(n.code,{children:"test.js"})," 输出的自身 ",(0,r.jsx)(n.code,{children:"module"})," 对象。这个对象指向等同于 ",(0,r.jsx)(n.code,{children:"require.main"}),"。所以输出与第二次基本一致，但有个不同，那就是此时 ",(0,r.jsx)(n.code,{children:"test2.js"})," 代码已加载完毕，执行上下文回到了 ",(0,r.jsx)(n.code,{children:"test.js"}),"，所以里面关于 ",(0,r.jsx)(n.code,{children:"test2.js"})," 的 ",(0,r.jsx)(n.code,{children:"Module"})," 实例中的 ",(0,r.jsx)(n.code,{children:"loaded"})," 变为 ",(0,r.jsx)(n.code,{children:"true"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["然后下一步是执行 ",(0,r.jsx)(n.code,{children:"process.nextTick()"}),"，将回调函数进去，以供下一个 Tick 执行。至此，",(0,r.jsx)(n.code,{children:"test.js"})," 模块也加载完毕，后面就是正式进入事件循环了。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["过了一个 Tick 之后，Node.js 代码执行 ",(0,r.jsx)(n.code,{children:"process.nextTick()"})," 回调，此时执行第四次输出。这次输出对象仍旧是 ",(0,r.jsx)(n.code,{children:"test.js"})," 的 ",(0,r.jsx)(n.code,{children:"module"}),"，所以内容与第三次输出基本一致。只不过这个时刻，",(0,r.jsx)(n.code,{children:"test.js"})," 也已加载完毕，",(0,r.jsx)(n.code,{children:"loaded"})," 也变为 ",(0,r.jsx)(n.code,{children:"true"})," 了。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h3,{id:"nodejs-中的-esm",children:["Node.js 中的 ESM",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中的-esm",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["ESM 是 ECMAScript 官方的模块机制，从语法层面直接支持。虽然语法上面支持了，但是当 Node.js 拿到一个 ",(0,r.jsx)(n.code,{children:"import ... 'foo'"})," 的时候，还是得决定从哪怎么加载一个模块。V8 只是实现了语法上面的解析，具体加载代码等操作还是需要各运行时自行适配。毕竟不同运行时对于标识解析、代码加载的规则不一样，比如 Deno 支持从 HTTP 进行远端加载，而 Node.js 至少在 v18 还没有这层内置默认打开，需要用户自行实现或开启。甚至有些私有运行时会从数据库、内存等等地方加载，这些都是需要自行适配的。"]}),"\n",(0,r.jsxs)(n.p,{children:["Node.js 自然也有了这层最基本的从文件系统加载的适配。以及，为了给未来留口子，Node.js 还支持让用户自定义加载。即当 Node.js 收到了 ",(0,r.jsx)(n.code,{children:"import ... 'foo'"})," 语法之后，可以将 ",(0,r.jsx)(n.code,{children:"foo"})," 等信息传给用户自定义加载器，由其来决定如何加载模块。只需要你在执行 Node.js 的时候，通过命令行参数指定加载器即可，如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ node --experimental-loader ./https-loader.mjs main.mjs\n"})}),"\n",(0,r.jsx)(n.p,{children:"这个特性一直到 Node.js v18.13 还是 Experimental 状态。未来应该会并入 Stable 状态的。"}),"\n",(0,r.jsxs)(n.p,{children:["通过上面的这个特性，用户可以自己实现一个 HTTP 的模块加载器。当接收到类似 ",(0,r.jsx)(n.code,{children:"import * from 'https://exmple.com'"})," 的时候，通过 HTTP 模块加载器来加载对应远端代码，并编译成 ECMAScript 模块。大家有兴趣可自行查阅 Node.js 官方文档中的",(0,r.jsx)(n.a,{href:"https://nodejs.org/docs/latest-v18.x/api/esm.html#https-loader",title:"https://nodejs.org/docs/latest-v18.x/api/esm.html#https-loader",target:"_blank",rel:"noopener noreferrer",children:"自定义 HTTP 加载器示例"}),"。另外，现版本的 Node.js 中，也内置了 HTTP 加载器，只不过并没有默认启动。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ node --experimental-network-imports main.mjs\n"})}),"\n",(0,r.jsxs)(n.p,{children:["除了协议上可以自定义之外，自定义加载器还可以用于在加载模块时期编译非 JavaScript 代码等操作。比如 CoffeeScript 的加载，就可以通过自定义加载器将源码转译成 JavaScript 再加载，大家有兴趣可自行查阅 Node.js 官方文档中的",(0,r.jsx)(n.a,{href:"https://nodejs.org/docs/latest-v18.x/api/esm.html#transpiler-loader",title:"https://nodejs.org/docs/latest-v18.x/api/esm.html#transpiler-loader",target:"_blank",rel:"noopener noreferrer",children:"自定义转译加载器示例"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"关于 Experimental 的内容点到为止，这里只是讲一个未来的趋势，具体大家都可以直接看 Node.js 文档，该有的内容都很详尽。"}),"\n",(0,r.jsxs)(n.h3,{id:"cjs-与-esm-的识别与启用",children:["CJS 与 ESM 的识别与启用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#cjs-与-esm-的识别与启用",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Node.js 支持两套模块机制，但其又各自独立。不同的场景下，Node.js 会将一个模块判断为是 CJS 模块，还是 ESM 模块。"}),"\n",(0,r.jsx)(n.p,{children:"虽然这个判断在 Node.js 文档中原原本本写着了，我在这里还是稍微提一下。"}),"\n",(0,r.jsxs)(n.p,{children:["通常一个 ",(0,r.jsx)(n.code,{children:"*.mjs"})," 会被认为是 ECMAScript module，而一个 ",(0,r.jsx)(n.code,{children:"*.cjs"})," 则会被认为是 CommonJS 模块。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果是 ",(0,r.jsx)(n.code,{children:"*.js"})," 文件，则需要看离它最近的父 ",(0,r.jsx)(n.code,{children:"package.json"})," 文件。这个就涉及到 Node.js 的包机制了，后续章节中会提。Node.js 在 v12.0.0 中，为 ",(0,r.jsx)(n.code,{children:"package.json"})," 增加了 ",(0,r.jsx)(n.code,{children:"type"})," 字段，用于判别其麾下的 ",(0,r.jsx)(n.code,{children:"*.js"})," 文件是 ECMAScript module 还是 CommonJS 模块。若 ",(0,r.jsx)(n.code,{children:"type"})," 值为 ",(0,r.jsx)(n.code,{children:"module"}),"，则其 ",(0,r.jsx)(n.code,{children:"*.js"})," 为 ECMAScript module；若其值为 ",(0,r.jsx)(n.code,{children:"commonjs"})," 或者不存在该值，则其 ",(0,r.jsx)(n.code,{children:"*.js"})," 为 CommonJS 模块。"]}),"\n",(0,r.jsxs)(n.p,{children:["另外，还有一种情况，就是当通过 ",(0,r.jsx)(n.code,{children:"--eval"})," 参数启动 Node.js，或者直接通过字符串 pipe 给 Node.js 时，其源码对应的模块类型要看另一个 ",(0,r.jsx)(n.code,{children:"--input-type"})," 参数是 ",(0,r.jsx)(n.code,{children:"module"})," 还是 ",(0,r.jsx)(n.code,{children:"commonjs"}),"，若没有这个 ",(0,r.jsx)(n.code,{children:"--input-type"})," 参数，则默认认为其是 CommonJS 模块。"]}),"\n",(0,r.jsxs)(n.p,{children:["上面的“不存在 ",(0,r.jsx)(n.code,{children:"type"})," 字段”或“不存在 ",(0,r.jsx)(n.code,{children:"--input-type"})," 参数”都是为了向下兼容。当下 Node.js 既支持 CommonJS 和 ECMAScript modules，所以官方还是建议在需要这个字段的时候都填上，哪怕你的模块是 CommonJS，也不要留空。"]}),"\n",(0,r.jsxs)(n.h4,{id:"commonjs-下的-import",children:["CommonJS 下的 ",(0,r.jsx)(n.code,{children:"import"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs-下的-import",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["一个 CommonJS 的模块中是无法使用 ",(0,r.jsx)(n.code,{children:"import"})," 语法的。例如还是上面的 ",(0,r.jsx)(n.code,{children:"test2.js"}),"，如果我们把 ",(0,r.jsx)(n.code,{children:"test.js"})," 改成："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"import * as a from './test2.js';\n"})}),"\n",(0,r.jsxs)(n.p,{children:["并且没有 ",(0,r.jsx)(n.code,{children:"package.json"})," 文件去指定 ",(0,r.jsx)(n.code,{children:"test.js"})," 是一个 ESM，这是会报错的："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'(node:*****) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.\n(Use `node --trace-warnings ...` to show where the warning was created)\n/foo/test.js:1\nimport * as a from \'./test2.js\';\n^^^^^^\n\nSyntaxError: Cannot use import statement outside a module\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1084:15)\n    at Module._compile (node:internal/modules/cjs/loader:1119:27)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1209:10)\n    at Module.load (node:internal/modules/cjs/loader:1033:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:868:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:22:47\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"ecmascript-module-下-import-commonjs",children:["ECMAScript module 下 ",(0,r.jsx)(n.code,{children:"import"})," CommonJS",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ecmascript-module-下-import-commonjs",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如果把 ",(0,r.jsx)(n.code,{children:"test.js"})," 重命名为 ",(0,r.jsx)(n.code,{children:"test.mjs"})," 则可正常运行。在 ESM 下，对 CommonJS 模块进行 ",(0,r.jsx)(n.code,{children:"import"})," 是可以的。不过这么一来，由于入口文件是 ESM 的，所以 ",(0,r.jsx)(n.code,{children:"require.main"})," 就不存在了。这么执行下来的结果就是两个输出，第一个输出是 ",(0,r.jsx)(n.code,{children:"test2.js"})," 这个 CommonJS 模块自身，就跟上面输出 ",(0,r.jsx)(n.code,{children:"test2.js"})," 这个 ",(0,r.jsx)(n.code,{children:"Module"})," 实例一致；第二个输出是输出 ",(0,r.jsx)(n.code,{children:"require.main"}),"，此时输出是 ",(0,r.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,r.jsxs)(n.h4,{id:"ecmascript-module-下的-require",children:["ECMAScript module 下的 ",(0,r.jsx)(n.code,{children:"require"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ecmascript-module-下的-require",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 ESM 的作用域下，不再存在 CommonJS 对应的上下文，如 ",(0,r.jsx)(n.code,{children:"require()"}),"、",(0,r.jsx)(n.code,{children:"module"}),"、",(0,r.jsx)(n.code,{children:"exports"})," 这些统统不存在。也就说，把 ",(0,r.jsx)(n.code,{children:"test.mjs"})," 源码改成："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"require('test2');\n"})}),"\n",(0,r.jsx)(n.p,{children:"是会执行失败的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"require('test2');\n^\n\nReferenceError: require is not defined in ES module scope, you can use import instead\n    at file:///foo/test.mjs:1:1\n    at ModuleJob.run (node:internal/modules/esm/module_job:193:25)\n    at async Promise.all (index 0)\n    at async ESMLoader.import (node:internal/modules/esm/loader:526:24)\n    at async loadESM (node:internal/process/esm_loader:91:5)\n    at async handleMainPromise (node:internal/modules/run_main:65:12)\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"commonjs-下加载-ecmascript-module",children:["CommonJS 下加载 ECMAScript module",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs-下加载-ecmascript-module",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["ECMAScript module 可以通过 ",(0,r.jsx)(n.code,{children:"import"})," 加载 CommonJS 模块，而反过来 CommonJS 模块是无法通过 ",(0,r.jsx)(n.code,{children:"require()"})," 来加载 ECMAScript module 的。这里涉及到一个本质问题，那就是",(0,r.jsx)(n.strong,{children:"模块加载的异同步"}),"。CommonJS 的 ",(0,r.jsx)(n.code,{children:"require()"})," 机制是完全同步的，而 ECMAScript module 的 ",(0,r.jsx)(n.code,{children:"import"})," 机制则是异步的。具体的分析在后话，这里大家要记住它们加载的异同步问题。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"import"})," 是异步的，那么在内部通过同步的方式模拟一个 ",(0,r.jsx)(n.code,{children:"require"})," 流程是没问题的，所以 ECMAScript module 下可以通过 ",(0,r.jsx)(n.code,{children:"import"})," 去加载 CommonJS 模块；反过来不行，一个同步的东西是无法加载异步内容的，至少无法通过比较正统的方式解决。"]}),"\n",(0,r.jsxs)(n.p,{children:["CommonJS 虽然无法通过 ",(0,r.jsx)(n.code,{children:"require"})," 去加载一个 ECMAScript module，但不意味着它无法加载 ECMAScript module。实际上，Node.js 的 CommonJS 模块虽然不支持 ",(0,r.jsx)(n.code,{children:"import"})," 语法，但它却支持 ",(0,r.jsx)(n.code,{children:"import()"})," 函数。我们仍可以在 CommonJS 中通过 ",(0,r.jsx)(n.code,{children:"import()"})," 函数来加载一个 ECMAScript module。"]}),"\n",(0,r.jsxs)(n.p,{children:["这里将 ",(0,r.jsx)(n.code,{children:"import()"})," 称为函数其实也不严谨。",(0,r.jsxs)(n.strong,{children:["具体来讲，",(0,r.jsx)(n.code,{children:"import()"})," 也是一个语法，叫动态载入（dynamic import）。只不过长得像函数，我这里姑且这么称呼，大家背八股的时候别学我。"]})]}),"\n",(0,r.jsxs)(n.p,{children:["上文中，我们提到，ECMAScript module 加载机制是异步的。虽然在 ",(0,r.jsx)(n.code,{children:"import * as mod from 'xxx'"})," 的语法中我们看起来是同步的，但其实在引擎内部帮你吃掉了异步的部分。然而在 ",(0,r.jsx)(n.code,{children:"import()"})," 中，该异步需要自己处理，它的返回值是一个 ",(0,r.jsx)(n.code,{children:"Promise"}),"。如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"import('xxx').then(mod => {\n  // 这里的 mod 就是加载的 ECMAScript module\n});\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"commonjs-与-ecmascript-module-互通小结",children:["CommonJS 与 ECMAScript module 互通小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs-与-ecmascript-module-互通小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["通过上面的四节小标题，我们大概明白了，",(0,r.jsx)(n.strong,{children:"CommonJS 与 ECMAScript module 虽然是两套模块机制，但在 Node.js 中一定程度上是可以互通的"}),"。"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["CommonJS 下无法使用 ",(0,r.jsx)(n.code,{children:"import"})," 语法，ECMAScript module 中没有 ",(0,r.jsx)(n.code,{children:"require()"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["ECMAScript module 可以 ",(0,r.jsx)(n.code,{children:"import"})," CommonJS 模块；"]}),"\n",(0,r.jsxs)(n.li,{children:["CommonJS 模块无法 ",(0,r.jsx)(n.code,{children:"require()"})," ECMAScript module，但可以通过 ",(0,r.jsx)(n.code,{children:"import()"})," 语法动态加载它。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章为大家讲解了 JavaScript 模块机制的发展史，从最开始无模块机制，到后面 IIFE，再到四大模块体系打架的阶段，到最后官方下场搞 ECMAScript modules。"}),"\n",(0,r.jsx)(n.p,{children:"其中 CommonJS 是由 Mozilla 工程师 Kevin Dangoor 起草，他本来想搞一套 ServerJS 的模块体系。后来觉得路走窄了没朋友，又改成了 CommonJS。"}),"\n",(0,r.jsx)(n.p,{children:"Node.js 是在四大模块体系打架的阶段诞生的。从诞生之初就与 CommonJS 绑定在一起，一直使用该机制作为它的模块机制，也算是呼应了它的原名 ServerJS。"}),"\n",(0,r.jsx)(n.p,{children:"官方下场后，Node.js 也开始了与官方绑定之路，脚踏两条船，齐头并进，对齐标准。发展至今，Node.js 同时支持 CommonJS 与 ECMAScript module，并且两种方式可在一定程度上互通，从而继续享受庞大的存量的 Node.js 生态。"}),"\n",(0,r.jsx)(n.p,{children:"我个人一直更倾向于使用 CommonJS 规范，但历史车轮滚滚，很多时候并不由我一个小人物的看法。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}let C=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F3-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9ACJS%20%E4%B8%8E%20ESM%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{text:"JavaScript 模块机制",id:"javascript-模块机制",depth:2},{text:"IIFE",id:"iife",depth:3},{text:"四大模块体系",id:"四大模块体系",depth:3},{text:"AMD / CMD / UMD",id:"amd--cmd--umd",depth:4},{text:"CommonJS",id:"commonjs",depth:4},{text:"ECMAScript Modules",id:"ecmascript-modules",depth:3},{text:"Node.js 的模块机制",id:"nodejs-的模块机制",depth:2},{text:"Node.js 中的 CJS",id:"nodejs-中的-cjs",depth:3},{text:"Node.js 中的 ESM",id:"nodejs-中的-esm",depth:3},{text:"CJS 与 ESM 的识别与启用",id:"cjs-与-esm-的识别与启用",depth:3},{text:"CommonJS 下的 `import`",id:"commonjs-下的-import",depth:4},{text:"ECMAScript module 下 `import` CommonJS",id:"ecmascript-module-下-import-commonjs",depth:4},{text:"ECMAScript module 下的 `require`",id:"ecmascript-module-下的-require",depth:4},{text:"CommonJS 下加载 ECMAScript module",id:"commonjs-下加载-ecmascript-module",depth:4},{text:"CommonJS 与 ECMAScript module 互通小结",id:"commonjs-与-ecmascript-module-互通小结",depth:4},{text:"小结",id:"小结",depth:2}],title:"3-模块机制详解：CJS 与 ESM（上）",headingTitle:"3-模块机制详解：CJS 与 ESM（上）",frontmatter:{}}}}]);