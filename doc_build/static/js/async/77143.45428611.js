"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["77143"],{910761:function(e,n,s){e.exports=s.p+"static/image/ab7aae78dc0503e9fb2c8111e67e57d2.116d14c3.webp"},972786:function(e,n,s){s.r(n),s.d(n,{default:()=>m});var r=s(552676),i=s(740453);let c=s.p+"static/image/e3b086a9fd2ba42ccc8c530731b1ce37.11d6401d.webp",l=s.p+"static/image/9fbf241644dc9e7f866a75d494bc90b1.a76f60a5.webp",t=s.p+"static/image/04a5f12f41743453eb7523950ac62bc3.d516ce64.webp",a=s.p+"static/image/73920d4ab22a91064fc15aa4cd21cc6d.9a68396b.webp",d=s.p+"static/image/8ea253e027a31829b6aa43a3e2d3a833.ff56468c.webp",A=s.p+"static/image/cc5e75c02d99405cb80c1ac763df464c.9a7b627e.webp",p=s.p+"static/image/287ee9f0048f53653887b8583676f00f.5706a4e6.webp",h=s.p+"static/image/43b1bcb02336cdfbdb38fc4964c4cbe4.89b2fc20.webp",x=s.p+"static/image/317e45aaf4564508c7346dd296ad7cb2.d881b930.webp",o=s.p+"static/image/9eb17a280ccf5e54ffd7a5532fedd541.2d9a1df9.webp";var j=s(910761);function g(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",pre:"pre",code:"code",img:"img",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"9套路五联合分散可简化",children:["9.套路五：联合分散可简化",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9套路五联合分散可简化",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"联合类型在类型编程中是比较特殊的，TypeScript 对它做了专门的处理，写法上可以简化，但也增加了一些认知成本。"}),"\n",(0,r.jsx)(n.p,{children:"这是类型体操的第五个套路：联合分散可简化。"}),"\n",(0,r.jsxs)(n.h2,{id:"分布式条件类型",children:["分布式条件类型",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#分布式条件类型",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"当类型参数为联合类型，并且在条件类型左边直接引用该类型参数的时候，TypeScript 会把每一个元素单独传入来做类型运算，最后再合并成联合类型，这种语法叫做分布式条件类型。"})}),"\n",(0,r.jsx)(n.p,{children:"比如这样一个联合类型："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Union = 'a' | 'b' | 'c';\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们想把其中的 a 大写，就可以这样写："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type UppercaseA<Item extends string> = \n    Item extends 'a' ?  Uppercase<Item> : Item;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，我们类型参数 Item 约束为 string，条件类型的判断中也是判断是否是 a，但传入的是联合类型。"}),"\n",(0,r.jsx)(n.p,{children:"这就是 TypeScript 对联合类型在条件类型中使用时的特殊处理：会把联合类型的每一个元素单独传入做类型计算，最后合并。"}),"\n",(0,r.jsx)(n.p,{children:"这和联合类型遇到字符串时的处理一样："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样确实是简化了类型编程逻辑的，不需要递归提取每个元素再处理。"}),"\n",(0,r.jsx)(n.p,{children:"TypeScript 之所以这样处理联合类型也很容易理解，因为联合类型的每个元素都是互不相关的，不像数组、索引、字符串那样元素之间是有关系的。所以设计成了每一个单独处理，最后合并。"}),"\n",(0,r.jsx)(n.p,{children:"知道了 TypeScript 怎么处理的联合类型，趁热打铁来练习一下："}),"\n",(0,r.jsxs)(n.h2,{id:"camelcaseunion",children:["CamelcaseUnion",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#camelcaseunion",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Camelcase 我们实现过，就是提取字符串中的字符，首字母大写以后重新构造一个新的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Camelcase<Str extends string> = \n    Str extends `${infer Left}_${infer Right}${infer Rest}`\n    ? `${Left}${Uppercase<Right>}${Camelcase<Rest>}`\n    : Str;\n"})}),"\n",(0,r.jsx)(n.p,{children:"提取 _ 左右的字符，把右边字符大写之后构造成新的字符串，余下的字符串递归处理。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果是对字符串数组做 Camelcase，那就要递归处理每一个元素："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type CamelcaseArr<\n  Arr extends unknown[]\n> = Arr extends [infer Item, ...infer RestArr]\n  ? [Camelcase<Item & string>, ...CamelcaseArr<RestArr>]\n  : [];\n"})}),"\n",(0,r.jsx)(n.p,{children:"类型参数 Arr 为待处理数组。"}),"\n",(0,r.jsx)(n.p,{children:"递归提取每一个元素做 Camelcase，因为 Camelcase 要求传入 string，这里要 & string 来变成 string 类型。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那如果是联合类型呢？"}),"\n",(0,r.jsx)(n.p,{children:"联合类型不需要递归提取每个元素，TypeScript 内部会把每一个元素传入单独做计算，之后把每个元素的计算结果合并成联合类型。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type CamelcaseUnion<Item extends string> = \n  Item extends `${infer Left}_${infer Right}${infer Rest}` \n    ? `${Left}${Uppercase<Right>}${CamelcaseUnion<Rest>}` \n    : Item;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/FAFwngDgpgBAwgQwLZQDYGMEGcoB4DKIATjFAB4hQB2AJljFsQJZUDmAfDALwzAz8xCJcpVr0ABgBIA3iwBmUEgBkockAF8A+jPmKYAJSasAFhp1UFJfVEbrxfAQH4YU6SrXqZAVQjQimHFxDExB2T2lEFAxsPGtGMPsBGAAuQWIAbmBQSFhItACoOIBXVBBueGR8mNwAcgQETXrGhBr2TOzoCqiCgEEiIlwHPuEKajoYIqoAayoAewB3KgBtAF1gTh5h0lGxGCXdEgBJSiQAGhgAOiuDgxsQYbX+ZyW86MDjqCQYADIGZjZ2OcrhdXr1+kE7sN2I8UnsVu1wJ1QTFhsVSuVkThhrglnUGk16jVzjUAEYkzRkikkokwGrodCaemM9A1FZtLKI3KVN5QLxUJizKi4D5fERjeiMIgsDjlBwi7aicauG7uDTaWQWPTBUzhG5xDTiXhJZyuVXhHx+ApBIymMIyTG8-mCiHxOxGgSpEUInJdKo4PkCqhoso8B0B5145rNGowAA+tMpiepcdpTLTLLaQA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,r.jsx)(n.p,{children:"这不和单个字符串的处理没区别么？"}),"\n",(0,r.jsx)(n.p,{children:"没错，对联合类型的处理和对单个类型的处理没什么区别，TypeScript 会把每个单独的类型拆开传入。不需要像数组类型那样需要递归提取每个元素做处理。"}),"\n",(0,r.jsx)(n.p,{children:"确实简化了很多，好像都是优点？"}),"\n",(0,r.jsx)(n.p,{children:"也不全是，其实这样处理也增加了一些认知成本，不信我们再来看个例子："}),"\n",(0,r.jsxs)(n.h2,{id:"isunion",children:["IsUnion",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#isunion",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"判断联合类型我们会这样写："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type IsUnion<A, B = A> =\n    A extends A\n        ? [B] extends [A]\n            ? false\n            : true\n        : never\n"})}),"\n",(0,r.jsx)(n.p,{children:"当传入联合类型时，会返回 true："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["当传入其他类型时，会返回 false：\n",(0,r.jsx)("img",{src:d,alt:""})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAkgzgVQHYEsD2SA8BBANFAISgF4psA+EgKClrKggA9gIkATOMmungfigDaBALoNmrDoOzDuPOVH4AzAIYAbOBFny6ALijAATgFdN2qHqQQAbhANUqoSLESoMAJQhwjq4CWfJ0LAByZSCAHyCAI3CggGMYtiDyAG57R2h4APdPb2AAJj9M1ywBKBCgqDCy6Mqy+OEUoA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,r.jsx)(n.p,{children:"是不是在心里会问：什么鬼？这段逻辑是啥？"}),"\n",(0,r.jsx)(n.p,{children:"这就是分布式条件类型带来的认知成本。"}),"\n",(0,r.jsx)(n.p,{children:"我们先来看这样一个类型："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type TestUnion<A, B = A> = A  extends A ? { a: A, b: B} : never;\n\ntype TestUnionResult = TestUnion<'a' | 'b' | 'c'>;\n"})}),"\n",(0,r.jsx)(n.p,{children:"传入联合类型 'a' | 'b' | 'c' 的时候，结果是这样的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"A 和 B 都是同一个联合类型，为啥值还不一样呢？"}),"\n",(0,r.jsx)(n.p,{children:"因为条件类型中如果左边的类型是联合类型，会把每个元素单独传入做计算，而右边不会。"}),"\n",(0,r.jsx)(n.p,{children:"所以 A 是 'a' 的时候，B 是 'a' | 'b' | 'c'， A 是 'b' 的时候，B 是 'a' | 'b' | 'c'。。。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAKhDOwCqA7AlgexQHgIIBooAhKAXilwD4yKooIAPYCFAE3loH4oBvKAQwBcFQgCNhRAL5RhKCADcIAJwDcAKDWhIsBMnRYASggCuAG2A04iVJhwByfnagAfKHdFPXdgMZ3KKoA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,r.jsx)(n.p,{children:"那么利用这个特点就可以实现 Union 类型的判断："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type IsUnion<A, B = A> =\n    A extends A\n        ? [B] extends [A]\n            ? false\n            : true\n        : never\n"})}),"\n",(0,r.jsx)(n.p,{children:"类型参数 A、B 是待判断的联合类型，B 默认值为 A，也就是同一个类型。"}),"\n",(0,r.jsx)(n.p,{children:"A extends A 这段看似没啥意义，主要是为了触发分布式条件类型，让 A 的每个类型单独传入。"}),"\n",(0,r.jsx)(n.p,{children:"[B] extends [A]  这样不直接写 B 就可以避免触发分布式条件类型，那么 B 就是整个联合类型。"}),"\n",(0,r.jsx)(n.p,{children:"B 是联合类型整体，而 A 是单个类型，自然不成立，而其它类型没有这种特殊处理，A 和 B 都是同一个，怎么判断都成立。"}),"\n",(0,r.jsx)(n.p,{children:"利用这个特点就可以判断出是否是联合类型。"}),"\n",(0,r.jsx)(n.p,{children:"其中有两个点比较困惑，我们重点记一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"当 A 是联合类型时："})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"A extends A 这种写法是为了触发分布式条件类型，让每个类型单独传入处理的，没别的意义。"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"A extends A 和 [A] extends [A] 是不同的处理，前者是单个类型和整个类型做判断，后者两边都是整个联合类型，因为只有 extends 左边直接是类型参数才会触发分布式条件类型。"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"理解了这两点，分布式条件类型就算掌握了。"}),"\n",(0,r.jsx)(n.p,{children:"掌握了难点之后，我们再做些练习："}),"\n",(0,r.jsxs)(n.h2,{id:"bem",children:["BEM",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#bem",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"bem 是 css 命名规范，用 block__element--modifier 的形式来描述某个区块下面的某个元素的某个状态的样式。"}),"\n",(0,r.jsx)(n.p,{children:"那么我们可以写这样一个高级类型，传入 block、element、modifier，返回构造出的 class 名："}),"\n",(0,r.jsx)(n.p,{children:"这样使用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type bemResult = BEM<'guang', ['aaa', 'bbb'], ['warning', 'success']>;\n"})}),"\n",(0,r.jsx)(n.p,{children:"它的实现就是三部分的合并，但传入的是数组，要递归遍历取出每一个元素来和其他部分组合，这样太麻烦了。"}),"\n",(0,r.jsx)(n.p,{children:"而如果是联合类型就不用递归遍历了，因为联合类型遇到字符串也是会单独每个元素单独传入做处理。"}),"\n",(0,r.jsx)(n.p,{children:"数组转联合类型可以这样写："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那么 BEM 就可以这样实现："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type BEM<\n    Block extends string,\n    Element extends string[],\n    Modifiers extends string[]\n> = `${Block}__${Element[number]}--${Modifiers[number]}`;\n"})}),"\n",(0,r.jsx)(n.p,{children:"类型参数 Block、Element、Modifiers 分别是 bem 规范的三部分，其中 Element 和 Modifiers 都可能多个，约束为 string[]。"}),"\n",(0,r.jsx)(n.p,{children:"构造一个字符串类型，其中 Element 和 Modifiers 通过索引访问来变为联合类型。"}),"\n",(0,r.jsx)(n.p,{children:"字符串类型中遇到联合类型的时候，会每个元素单独传入计算，也就是这样的效果："}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:l,alt:""}),"\n",(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAQgogWQDwCgrtgGwPYGMDWUEAHsBAHYAmAzlNcAE4CW5A5gDRoZyYQC2FYEVIUadRi1YBtALqcMUBNkpMAZkwgNaJMlVr1mbWSgB8UALxQABgBIA3jBwEAvgH1X9nv0FTyAVz4AI00ZZwBaMPslFXVNal8A4IZQqwBuFAzQSChgvgAlCGo-TCFLeGQAclY-AEM2CvYoKQqa1oaoCsCuirkmioB3GoZySXaKotxcQuoek1SgA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})]}),"\n",(0,r.jsx)(n.p,{children:"可以看到，用好了联合类型，确实能简化类型编程逻辑。"}),"\n",(0,r.jsxs)(n.h2,{id:"allcombinations",children:["AllCombinations",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#allcombinations",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们再来实现一个全组合的高级类型，也是联合类型相关的："}),"\n",(0,r.jsx)(n.p,{children:"希望传入 'A' | 'B' 的时候，能够返回所有的组合： 'A' | 'B' | 'BA' | 'AB'。"}),"\n",(0,r.jsx)(n.p,{children:"这种全组合问题的实现思路就是两两组合，组合出的字符串再和其他字符串两两组和："}),"\n",(0,r.jsx)(n.p,{children:"比如 'A' | 'B' | 'c'，就是 A 和 B、C 组合，B 和 A、C 组合，C 和 A、B 组合。然后组合出来的字符串再和其他字符串组合。"}),"\n",(0,r.jsx)(n.p,{children:"任何两个类型的组合有四种：A、B、AB、BA"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Combination<A extends string, B extends string> =\n    | A\n    | B\n    | `${A}${B}`\n    | `${B}${A}`;\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后构造出来的字符串再和其他字符串组合。"}),"\n",(0,r.jsx)(n.p,{children:"所以全组合的高级类型就是这样："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type AllCombinations<A extends string, B extends string = A> = \n    A extends A\n        ? Combination<A, AllCombinations<Exclude<B, A>>>\n        : never;\n"})}),"\n",(0,r.jsx)(n.p,{children:"类型参数 A、B 是待组合的两个联合类型，B 默认是 A 也就是同一个。"}),"\n",(0,r.jsx)(n.p,{children:"A extends A 的意义就是让联合类型每个类型单独传入做处理，上面我们刚学会。"}),"\n",(0,r.jsx)(n.p,{children:"A 的处理就是 A 和 B 中去掉 A 以后的所有类型组合，也就是 Combination<A, B 去掉 A 以后的所有组合>。"}),"\n",(0,r.jsx)(n.p,{children:"而 B 去掉 A 以后的所有组合就是 AllCombinations<Exclude<B, A>>，所以全组合就是 Combination<A, AllCombinations<Exclude<B, A>>>。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这里利用到了分布式条件类型的特性，通过 A extends A 来取出联合类型中的单个类型。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAwg9gWwEYEsB2BDYK5oDwCCUEAHsBGgCYDOU1wATugOYA0UAQsWRTXYywB8UALwAoKJKgAfKAQlTZHBZNkADACQBvAgF9tHXWpUyomrYe161AbgljQkOQBtn8ZOiw401Qt3JUtPRMaGyc-rxBAqGicsIichGBciYA-LCIqJjYuITsBK7uWV64vgCiJADGzgCulBB4HPmCLSYAXFBoEABuEAx2DuDQBW6Znjk+AEoQ1DXOwLEjRePevgDkBGumaxxbsmswa4I2QA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"联合类型中的每个类型都是相互独立的，TypeScript 对它做了特殊处理，也就是遇到字符串类型、条件类型的时候会把每个类型单独传入做计算，最后把每个类型的计算结果合并成联合类型。"})}),"\n",(0,r.jsx)(n.p,{children:"条件类型左边是联合类型的时候就会触法这种处理，叫做分布式条件类型。"}),"\n",(0,r.jsx)(n.p,{children:"有两点特别要注意："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"A extends A 不是没意义，意义是取出联合类型中的单个类型放入 A"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"A extends A 才是分布式条件类型， [A] extends [A] 就不是了，只有左边是单独的类型参数才可以。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们后面做了一些案例，发现联合类型的这种 distributive 的特性确实能简化类型编程，但是也增加了认知成本，不过这也是不可避免的事。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/PTAEGEEMFsFMBsDGkDOsBQAXAngB1hDAsmgDwDKmATqLAB6awB2AJiqCtQJZMDmAfKAC8odKHGhKNeo1bsABgBIA3jwBmsGgBlYazAF8A+ivWbQAJS68AFgZNMNNc7E775YiQH5QS5Tr36KgCquPhUJLCkljaY-IHKUHBIqJHOnHHuEqAAXJLUANzoWHgEicQpaQCu8JjChEkRpADkkJCGre2QTfyFxfj15WgAglRUpB4j0gzMbKCVTADWTAD2AO5MANoAuuiCIpO003KgG6Y0AJKM0AA0oAB0D2cWLpiTO+LeG2XJZJew0KAAGQcbh8fi3B53b4RSZRF6TfjvHInLa9HD9aEpSZVGp1THDUakDYtNodVpNW5NABGVMMNLpVIpoCaiEQhlZ7MQTS2PSK6NKRB+sCCTC4yyYpD+AJkM3YnCoPAEdQ8UsOslmvie-gMxlUDjM0Vs8SeaQM8lEWW8vm18RCYUahti8XxwtF4rh6TcFokuSlaJKAyFIrFTBxtRELuD7pJnU6TVAAB9mfSU4zE8yOZmubz0CBQOcUFGmHyAwWi6QhrcAEJ1IZ7DziIZq2WgIYNrKgT5VrbN44bIZIjsd7xqSDwNDtofiXLUSoYKfIpiwABumhL-TLbtDLmq4fzha3zS6CepTRPXJPLG6-o3B5DYYATHVNyGicyuunT5+uTzenmACovEWfQEIBnDlpWoA1vseytuIMrHE23jKKAkC5JBVK5FW+iLiumg3qBQFbmGdRgZg5YtPGSZftR2Z-mAVYAKIALIgVBLHjFkVbwMsiALL2szyoq1ztox8D-MwtQIYJoK8NsIlZMxywsFwahcJo7DSXKsnbLsdS+NxvELEYupiRJTCYBsTCVNAVKaFs+gALSOSoSkqWpGlWTZdlUA58i9GxdnQCRIhMcxzS8JUkB8EyxKtF0lI0oyWy3MSqyQFQooxZSKCVKyLgoNyOZ5kM8DwOAyy2TwkCYCGKBsRVVVMDVr5NlpIIKnw1YCdpnVKkI7ZJm2WRJlWg0+CoQzxNhmQSEmBnxFN-liGxpXlZVVLVbV4ooBWPUdcJUH7UJfC1rBbVHLMw1eBAG1ba1txrY1m3NdtTC7YxdCIPAlQsJEVaPfwQPtrkS6rlQBGtmVz33TtIVQ+tTUtTtzRDFRzJVujTTgNeQA",target:"_blank",rel:"noopener noreferrer",children:"本文案例的合并"})})]})}function B(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}let m=B;B.__RSPRESS_PAGE_META={},B.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F9.%E5%A5%97%E8%B7%AF%E4%BA%94%EF%BC%9A%E8%81%94%E5%90%88%E5%88%86%E6%95%A3%E5%8F%AF%E7%AE%80%E5%8C%96.md"]={toc:[{text:"分布式条件类型",id:"分布式条件类型",depth:2},{text:"CamelcaseUnion",id:"camelcaseunion",depth:2},{text:"IsUnion",id:"isunion",depth:2},{text:"BEM",id:"bem",depth:2},{text:"AllCombinations",id:"allcombinations",depth:2},{text:"总结",id:"总结",depth:2}],title:"9.套路五：联合分散可简化",headingTitle:"9.套路五：联合分散可简化",frontmatter:{}}}}]);