"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["43767"],{376609:function(e,n,s){s.r(n),s.d(n,{default:()=>k});var r=s(552676),t=s(740453);let c=s.p+"static/image/a1d6557657e1bd7550bba7e9094e84ec.4ab51810.webp",i=s.p+"static/image/480c9fbe77e55667829a856e6d272eea.5409a57d.webp",a=s.p+"static/image/60c4ef380197fa9fa7f6abbf6890d0f4.4c7ed643.webp",o=s.p+"static/image/2fbfaf1f206a4e99771f1632c942ca2f.5ca72660.webp",d=s.p+"static/image/1af4f51aebcf94fa5e7810ba2c84bfba.5ee8d6ca.webp",l=s.p+"static/image/eb3574a545493f46dc1e5c5989a43857.662d24d8.webp",h=s.p+"static/image/464e0378b39d9477e3731472bb366607.3679093d.webp",p=s.p+"static/image/266107519ac4fb78fe64023e90df1930.530b27aa.webp",x=s.p+"static/image/024296726b7e21e2721a03bb4f8a7af9.cf3d811d.webp",m=s.p+"static/image/1c65626f5197a38672a806b69913a9c9.0bfd509b.webp",j=s.p+"static/image/64558a3e0a71d4a6c4c0947e1e93f8e5.b78ccc35.webp",g=s.p+"static/image/c9938ffa7f71fe75d2f9f61b84fc7cd5.670504f7.webp";function u(e){let n=Object.assign({h2:"h2",a:"a",p:"p",h3:"h3",pre:"pre",code:"code",img:"img",blockquote:"blockquote",ol:"ol",li:"li"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本篇我们讲解使用 Docker 部署我们的 Next.js 项目。"}),"\n",(0,r.jsxs)(n.h2,{id:"docker-直接部署",children:["Docker 直接部署",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#docker-直接部署",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果只是把项目部署上去，其实并不复杂。我给大家一个简单的、用于理解学习、演示核心要点的示例："}),"\n",(0,r.jsxs)(n.h3,{id:"下载代码",children:["下载代码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#下载代码",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们以 Day11 分支的代码为例，此时我们的代码中使用了 Prisma + MySQL。"}),"\n",(0,r.jsx)(n.p,{children:"下载我们的 day11 分支代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone -b day11 git@github.com:mqyqingfeng/next-react-notes-demo.git\n"})}),"\n",(0,r.jsx)(n.p,{children:"先本地运行一下，验证代码无问题："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 49.实战篇 _ React Notes _ Docker 部署\nnpm i && npm run dev\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"构建镜像",children:["构建镜像",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#构建镜像",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:".dockerignore"}),"文件，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"Dockerfile\n.dockerignore\nnode_modules\nnpm-debug.log\nREADME.md\n.next\ndocker\n.git\n"})}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"Dockerfile"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'FROM node:18-alpine\n\nWORKDIR /app\n\nCOPY . .\n\nRUN npm install --registry=https://registry.npmmirror.com\n\nRUN npx prisma generate\n\nRUN chmod +x /startup.sh\n\nEXPOSE 3000\n\nENTRYPOINT ["/startup.sh"]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["注意：这里的镜像构建指令并不复杂，相信大家有",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7330567768579637299",target:"_blank",rel:"noopener noreferrer",children:"《实战篇 | React Notes | Docker 快速入门》"}),"的基础，都很容易理解。关于最后一句指令，我们并没有使用 ",(0,r.jsx)(n.code,{children:"CMD"}),"，而是 ",(0,r.jsx)(n.code,{children:"ENTRYPOINT"}),"，两者作用类似。使用 ",(0,r.jsx)(n.code,{children:"ENTRYPOINT"}),"，我们将执行内容放到了脚本文件 ",(0,r.jsx)(n.code,{children:"startup.sh"}),"中。"]}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"startup.sh"}),"文件，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/sh\n\nMIGRATION_STATUS=$(npx prisma migrate status)\n\nif echo "$MIGRATION_STATUS" | grep -q "Database schema is up to date"; then\n    echo "No migrations needed."\nelse\n    echo "Running migrations..."\n    npx prisma migrate deploy\nfi\n\nnpm run build && npm run start\n'})}),"\n",(0,r.jsxs)(n.p,{children:["执行的内容并不复杂，主要是因为我们使用了 Prisma，所以需要运行 ",(0,r.jsx)(n.code,{children:"prisma generate"}),"和",(0,r.jsx)(n.code,{children:"prisma migrate deploy"}),"。",(0,r.jsx)(n.code,{children:"prisma generate"}),"我们已经放到了构建指令中，",(0,r.jsx)(n.code,{children:"prisma migrate deploy"}),"我们放到了运行脚本中。"]}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"docker-compose.yml"}),"文件，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"version: \"3.9\"\n\nnetworks:\n  react-notes:\n    driver: bridge\n\nservices:\n\n  mysql:\n    image: mysql:8.0\n    container_name: mysql\n    command: --default-authentication-plugin=caching_sha2_password\n    restart: unless-stopped\n    environment:\n      - MYSQL_ROOT_PASSWORD=admin\n      - MYSQL_DATABASE=notes\n      - MYSQL_USER=notes\n      - MYSQL_PASSWORD=cpZfriEBbmJjWeiR\n    ports:\n      - '3306:3306'\n    healthcheck:\n      test: ['CMD', 'mysqladmin', 'ping', '-h127.0.0.1', '-P3306']\n      interval: 5s\n      timeout: 2s\n      retries: 20\n    networks:\n      - react-notes\n\n  next-app:\n    container_name: next-app\n    build:\n      context: .\n    restart: always\n    ports:\n      - 3000:3000\n    networks:\n      - react-notes\n    depends_on:\n      mysql:\n        condition: service_healthy\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，这里我们声明了 ",(0,r.jsx)(n.code,{children:"mysql"}),"的容器名为 ",(0,r.jsx)(n.code,{children:"mysql"}),"，并建立了一个名为 ",(0,r.jsx)(n.code,{children:"notes"})," 的 MySQL 用户，对应修改根目录的 ",(0,r.jsx)(n.code,{children:"env"}),"文件为："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'DATABASE_URL="mysql://notes:cpZfriEBbmJjWeiR@mysql:3306/notes"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["稍微复杂一点的是 ",(0,r.jsx)(n.code,{children:"healthcheck"}),"，这是为了保证  mysql 完全运行后才运行 ",(0,r.jsx)(n.code,{children:"next-app"}),"。我们可以看到 ",(0,r.jsx)(n.code,{children:"next-app"}),"的 ",(0,r.jsx)(n.code,{children:"depends_on"})," 里有 ",(0,r.jsx)(n.code,{children:"mysql"}),"，依赖的条件是 ",(0,r.jsx)(n.code,{children:"service_healthy"}),"，也就是说 ",(0,r.jsx)(n.code,{children:"mysql"})," 的 ",(0,r.jsx)(n.code,{children:"healthcheck"})," 要先通过才会运行 ",(0,r.jsx)(n.code,{children:"next-app"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"服务器运行",children:["服务器运行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务器运行",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"服务器安装 Docker 和 Docker Compose，我是直接用宝塔安装了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["注：安装的速度不算快，大概等待了 20 分钟。服务器直接安装可以参考：",(0,r.jsx)(n.a,{href:"https://help.aliyun.com/zh/ecs/use-cases/deploy-and-use-docker-on-alibaba-cloud-linux-2-instances",target:"_blank",rel:"noopener noreferrer",children:"《安装Docker并使用（Linux）》"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["然后把代码推送到服务器，注意如果服务器已经开启了 MySQL，先关闭 MySQL。最后命令行进入服务器项目目录，运行 ",(0,r.jsx)(n.code,{children:"docker compose up"}),"，我们就成功的将项目运行在了服务器的 ",(0,r.jsx)(n.code,{children:"3000"})," 端口。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果参照过",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309114747482275850",target:"_blank",rel:"noopener noreferrer",children:"《实战篇 | React Notes | 服务器部署》"}),"，因为已经设置过 Nginx，所以会将域名 ",(0,r.jsx)(n.code,{children:"notes.yayujs.com"}),"代理到 3000 端口，所以直接访问：",(0,r.jsx)(n.a,{href:"https://notes.yayujs.com/",target:"_blank",rel:"noopener noreferrer",children:"https://notes.yayujs.com/"})," 就会生效："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"如果你没有设置过，宝塔里也支持容器快捷的设置反向代理、绑定到具体的域名上："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"docker-本地开发",children:["Docker 本地开发",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#docker-本地开发",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在我们非常随意的就用 Docker 把代码部署到了服务器上。但是这样的方法只能说——又不是不能用……"}),"\n",(0,r.jsxs)(n.p,{children:["问题依然很多，比如用了数据库却没有做数据持久化、Next.js 项目没有开启 ",(0,r.jsx)(n.code,{children:"standalone"})," 输出模式，Docker 的镜像构建太过随意导致构建包很大等等……"]}),"\n",(0,r.jsx)(n.p,{children:"实际上，选择用 Docker 选择的是一种开发方式。也就是说，不是在本地开发完了项目，最后用 Docker 部署一下，而是在本地开发项目的时候，就已经开始使用 Docker 了。"}),"\n",(0,r.jsx)(n.p,{children:"所以学习本篇不要着急，我们从头开始说起。"}),"\n",(0,r.jsxs)(n.h3,{id:"下载代码-1",children:["下载代码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#下载代码-1",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"先说说日常开发项目怎么使用 Docker。我们依然以 Day11 分支的代码为例，此时我们的代码中用了 Prisma + MySQL。"}),"\n",(0,r.jsx)(n.p,{children:"下载我们的 day11 分支代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"git clone -b day11 git@github.com:mqyqingfeng/next-react-notes-demo.git\n"})}),"\n",(0,r.jsx)(n.p,{children:"老规矩，先本地运行一下，验证代码无问题："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 注意要在本地开启 MySQL 后运行：\nnpm i && npm run dev\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"dockerignore",children:[(0,r.jsx)(n.code,{children:".dockerignore"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dockerignore",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:".dockerignore"}),"文件，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"Dockerfile\n.dockerignore\nnode_modules\nnpm-debug.log\nREADME.md\n.next\ndocker\n.git\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"devdockerfile",children:[(0,r.jsx)(n.code,{children:"dev.Dockerfile"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#devdockerfile",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"dev.Dockerfile"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'FROM node:18-alpine\n\n# RUN apt-get update -y\n# RUN apt-get install -y openssl\n\nWORKDIR /app\n\nCOPY . .\n\nRUN npm i --registry=https://registry.npmmirror.com;\n\nRUN chmod +x /app/dev.startup.sh\n\nENTRYPOINT ["sh", "/app/dev.startup.sh"]\n'})}),"\n",(0,r.jsx)(n.p,{children:"在这段代码中："}),"\n",(0,r.jsxs)(n.p,{children:["我们新建的是 ",(0,r.jsx)(n.code,{children:"dev.Dockerfile"}),"，但跟 Next.js 的 ",(0,r.jsx)(n.code,{children:".env.development"}),"不同的是，",(0,r.jsx)(n.code,{children:".env.development"})," Next.js 是会自动读取的，但 Docker 并不会自动读取 ",(0,r.jsx)(n.code,{children:"dev.Dockerfile"}),"，所以名字其实可以乱取，我们只是为了方便区分不同环境的 Dockerfile。（PS：Docker 其实也支持",(0,r.jsx)(n.a,{href:"https://docs.docker.com/desktop/dev-environments/",target:"_blank",rel:"noopener noreferrer",children:"开发环境"}),"，不过目前处于开发停滞状态）"]}),"\n",(0,r.jsxs)(n.p,{children:["再解释下代码的含义。",(0,r.jsx)(n.code,{children:"RUN apt-get"}),"这两句是为了避免出现类似于下面这样的错误提示（如果你遇到了这个问题的话，参考此 ",(0,r.jsx)(n.a,{href:"https://github.com/prisma/prisma/issues/19729",target:"_blank",rel:"noopener noreferrer",children:"GitHub Issue"}),"，没有遇到就不用写了）："]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:'Prisma Client could not locate the Query Engine for runtime "debian-openssl-1.1.x".'}),"\n",(0,r.jsx)(n.p,{children:'This happened because Prisma Client was generated for "debian-openssl-3.0.x", but the actual deployment required "debian-openssl-1.1.x".'}),"\n",(0,r.jsxs)(n.p,{children:['Add "debian-openssl-1.1.x" to ',(0,r.jsx)(n.code,{children:"binaryTargets"}),' in the "schema.prisma" file and run ',(0,r.jsx)(n.code,{children:"prisma generate"})," after saving it:"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"然后指定工作目录，拷贝所有文件、安装依赖包、给脚本文件添加运行权限。最后用 ENTRYPOINT 指定了容器启动脚本。因为我们用了 Prisma，脚本内容比较多，所以单独使用了一个脚本文件。"}),"\n",(0,r.jsxs)(n.h3,{id:"devstartupsh",children:["dev.startup.sh",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#devstartupsh",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"dev.startup.sh"}),"文件，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/sh\n\nMIGRATION_STATUS=$(npx prisma migrate status)\n\nif echo "$MIGRATION_STATUS" | grep -q "Database schema is up to date"; then\n    echo "No migrations needed."\nelse\n    echo "Running migrations..."\n    npx prisma migrate deploy\nfi\n\nnpx prisma generate\n\nif [ -f yarn.lock ]; then \n    yarn dev;\nelif [ -f package-lock.json ]; then \n    npm run dev;\nelif [ -f pnpm-lock.yaml ]; then \n    pnpm dev;\nelse \n    npm run dev;\nfi\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这段代码并不复杂，一是  Prisma 相关处理，二是运行 ",(0,r.jsx)(n.code,{children:"npm run dev"}),"开启开发模式。你可能会问，",(0,r.jsx)(n.code,{children:"prisma generate"}),"怎么又放到了脚本里执行？之前不是放在镜像构建指令里吗？其实这里放哪里都可以的。（但是线上部署的时候因为开启了 standalone 输出模式只能放在构建指令中）"]}),"\n",(0,r.jsxs)(n.h3,{id:"devdocker-composeyml",children:["dev.docker-compose.yml",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#devdocker-composeyml",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"dev.docker-compose.yml"})," 文件，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"version: \"3.8\"\n\nnetworks:\n  react-notes-dev:\n    driver: bridge\n\nservices:\n  next-app-dev:\n    container_name: next-app\n    build:\n      context: .\n      dockerfile: dev.Dockerfile\n    env_file:\n      - .env\n      - .env.development\n    volumes:\n      - .:/app\n    restart: always\n    ports:\n      - 3000:3000\n    networks:\n      - react-notes-dev\n    depends_on:\n      mysql:\n        condition: service_healthy\n      \n  mysql:\n    image: mysql:8.0\n    container_name: next-app-mysql\n    command: --default-authentication-plugin=caching_sha2_password\n    restart: unless-stopped\n    # volumes:\n    #   - ./docker/data/mysql/:/var/lib/mysql/\n    environment:\n      - MYSQL_ROOT_PASSWORD=admin\n      - MYSQL_DATABASE=notes\n      - MYSQL_USER=notes\n      - MYSQL_PASSWORD=cpZfriEBbmJjWeiR\n    ports:\n      - '3306:3306'\n    healthcheck:\n      test: ['CMD', 'mysqladmin', 'ping', '-h127.0.0.1', '-P3306']\n      interval: 5s\n      timeout: 2s\n      retries: 20\n    networks:\n      - react-notes-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这段代码也很好理解，注意 ",(0,r.jsx)(n.code,{children:"next-app"})," 的数据卷，因为我们将项目的所有内容都挂载到工作目录 ",(0,r.jsx)(n.code,{children:"/app"})," 下，当我们修改项目文件时，Docker 里运行的项目也会正常发生修改，所以即便使用了 Docker 也继续支持热更新。"]}),"\n",(0,r.jsxs)(n.p,{children:["根目录的 ",(0,r.jsx)(n.code,{children:".env.development"}),"文件对应修改为："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'DATABASE_URL="mysql://notes:cpZfriEBbmJjWeiR@next-app-mysql:3306/notes"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["此时运行 ",(0,r.jsx)(n.code,{children:"docker compose -f dev.docker-compose.yml up"}),"，本地访问 ",(0,r.jsx)(n.code,{children:"http://localhost:3000/"}),"应该已经可以正常运行："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h3,{id:"host",children:["host",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#host",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["使用 ",(0,r.jsx)(n.code,{children:"next-auth"})," 的时候，如果部署到线上环境，可能需要额外设置一下 ",(0,r.jsx)(n.code,{children:"AUTH_URL"}),"。对于初学者而言，又有可能忘记这件事情，于是明明在本地运行没有问题，但发布到线上后就出现了问题……干脆我们本地开发的时候就直接使用线上域名进行开发！"]}),"\n",(0,r.jsxs)(n.p,{children:["我们设想的开发方式是本地浏览器访问 ",(0,r.jsx)(n.code,{children:"https://notes.yayujs.com"}),"就会进入我们本地启用的页面。为此你需要修改主机的 ",(0,r.jsx)(n.code,{children:"host"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 修改 host 文件\nvim /etc/hosts\n\n# 添加如下：\n127.0.0.1 notes.yayujs.com\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其实修改 host 并不算复杂，但是发布到线上又需要注释掉对应的域名才能查看效果，开发本地又需要解开注释才能查看效果。一来二去也就麻烦了，为此你可以使用 ",(0,r.jsx)(n.a,{href:"https://switchhosts.vercel.app/zh",target:"_blank",rel:"noopener noreferrer",children:"SwitchHosts"})," 这个软件："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"借助 SwitchHosts 这个软件，你可以轻松切换 host。"}),"\n",(0,r.jsx)(n.p,{children:"注意：如果切换 host 后，浏览器没有成功解析，你可以进行这样一些尝试："}),"\n",(0,r.jsxs)(n.p,{children:["有可能是浏览器做了 DNS 缓存或其他处理。浏览器打开 ",(0,r.jsx)(n.code,{children:"chrome://net-internals/#sockets"}),"，点击 ",(0,r.jsx)(n.code,{children:"Flush Socket Pools"}),"。注意 Flush 的是当前窗口里的所有页面。"]}),"\n",(0,r.jsxs)(n.p,{children:["有可能是使用了代理导致。这个时候就需要将你的域名放到代理的排除名单里。我们以 ClashX 为例，打开 ",(0,r.jsx)(n.code,{children:"~/.config/clash"}),"，添加一个名为 ",(0,r.jsx)(n.code,{children:"proxyIgnoreList.plist"}),"的文件，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<array>\n    <string>192.168.0.0/16</string>\n    <string>10.0.0.0/8</string>\n    <string>172.16.0.0/12</string>\n    <string>127.0.0.1</string>\n    <string>localhost</string>\n    <string>*.local</string>\n    <string>http://notes.yayujs.com</string>\n    <string>https://notes.yayujs.com</string>\n</array>\n</plist>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"<string>"}),"标签中添加要排除的域名，然后重启 ClashX 即可。"]}),"\n",(0,r.jsxs)(n.p,{children:["设置 host 后，此时访问 ",(0,r.jsx)(n.a,{href:"http://notes.yayujs.com:3000/",target:"_blank",rel:"noopener noreferrer",children:"http://notes.yayujs.com:3000/"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"注：此时也只是能正常访问首页，功能比如登录还有问题"}),"\n",(0,r.jsxs)(n.h3,{id:"nginx",children:["nginx",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nginx",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们的目标是本地访问 ",(0,r.jsx)(n.code,{children:"https://notes.yayujs.com"}),"的时候可以进入我们的开发页面，通过 switchHosts 关闭相关 host 的时候，访问 ",(0,r.jsx)(n.code,{children:"https://notes.yayujs.com"}),"则会进入我们的线上部署页面。为此我们需要用到 nginx 镜像。"]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"dev.docker-compose.yml"})," 文件，完整代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"version: \"3.8\"\n\nnetworks:\n  react-notes-dev:\n    driver: bridge\n\nservices:\n  next-app-dev:\n    container_name: next-app\n    build:\n      context: .\n      dockerfile: dev.Dockerfile\n    env_file:\n      - .env\n      - .env.development\n    volumes:\n      - .:/app\n    restart: always\n    ports:\n      - 3000:3000\n    networks:\n      - react-notes-dev\n    depends_on:\n      mysql:\n        condition: service_healthy\n      \n  mysql:\n    image: mysql:8.0\n    container_name: next-app-mysql\n    command: --default-authentication-plugin=caching_sha2_password\n    restart: unless-stopped\n    # volumes:\n    #   - ./docker/data/mysql/:/var/lib/mysql/\n    environment:\n      - MYSQL_ROOT_PASSWORD=admin\n      - MYSQL_DATABASE=notes\n      - MYSQL_USER=notes\n      - MYSQL_PASSWORD=cpZfriEBbmJjWeiR\n    ports:\n      - '3306:3306'\n    healthcheck:\n      test: ['CMD', 'mysqladmin', 'ping', '-h127.0.0.1', '-P3306']\n      interval: 5s\n      timeout: 2s\n      retries: 20\n    networks:\n      - react-notes-dev\n\n  nginx:\n    image: nginx\n    container_name: next-app-nginx\n    volumes:\n      - ./docker/nginx.conf:/etc/nginx/nginx.conf\n      - ./docker/ssl/notes.yayujs.com.key:/etc/nginx/ssl/notes.yayujs.com.key\n      - ./docker/ssl/notes.yayujs.com.pem:/etc/nginx/ssl/notes.yayujs.com.pem\n    ports:\n      - 80:80\n      - 443:443\n    restart: always\n    networks:\n      - react-notes-dev\n    depends_on:\n      - next-app-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"docker"}),"文件夹，然后新建 ",(0,r.jsx)(n.code,{children:"nginx.conf"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"events {\n    worker_connections   1000;\n}\nhttp {\n    include /etc/nginx/mime.types;\n    upstream nextjs_upstream {\n        server next-app:3000;\n    }\n    server {\n        listen 80;\n        listen 443 ssl;\n        server_name  notes.yayujs.com;\n\n        ssl_certificate /etc/nginx/ssl/notes.yayujs.com.pem;\n        ssl_certificate_key /etc/nginx/ssl/notes.yayujs.com.key;\n        ssl_session_timeout 5m;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n        ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;\n        ssl_prefer_server_ciphers on;\n        \n        gzip on;\n        gzip_proxied any;\n        gzip_comp_level 4;\n        gzip_types text/css application/javascript image/svg+xml;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_set_header Host $host;\n\n        location / {\n          proxy_pass http://nextjs_upstream;\n          proxy_set_header Host $host;\n          proxy_set_header X-Real-IP $remote_addr;\n          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n          proxy_set_header REMOTE-HOST $remote_addr;\n          add_header X-Cache $upstream_cache_status;\n          proxy_set_header X-Host $host;\n          proxy_set_header X-Scheme $scheme;\n          proxy_connect_timeout 30s;\n          proxy_read_timeout 86400s;\n          proxy_send_timeout 30s;\n          proxy_http_version 1.1;\n          proxy_set_header Upgrade $http_upgrade;\n          proxy_set_header Connection \"upgrade\";\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["同时在 ",(0,r.jsx)(n.code,{children:"docker"}),"目录下新建 ",(0,r.jsx)(n.code,{children:"ssl"}),"文件夹，然后放入开启 https 会用到的 key 和 pem 文件。"]}),"\n",(0,r.jsxs)(n.p,{children:["注：按理说这些再加上设置 AUTH_URL 就够了，但是因为用的是 next-auth v5 beta 版本，目前还不算稳定，如果不使用 AUTH_URL，点击 ",(0,r.jsx)(n.code,{children:"signIn"})," 的时候跳转地址的 callbackUrl 会设置为 ",(0,r.jsx)(n.code,{children:"localhost:3000"}),"，如果添加 ",(0,r.jsx)(n.code,{children:"AUTH_URL"}),"，会出现报错："]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"TypeError: next_dist_server_web_exports_next_request__WEBPACK_IMPORTED_MODULE_0__ is not a constructor"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["根据这个 ",(0,r.jsx)(n.a,{href:"https://github.com/nextauthjs/next-auth/issues/9922",target:"_blank",rel:"noopener noreferrer",children:"GitHub Issue"})," 的描述，此问题会由 Next.js 修复，但目前还没有发布到稳定版。对此我的处理方式是在 ",(0,r.jsx)(n.code,{children:"next-auth"})," 的 ",(0,r.jsx)(n.code,{children:"redirects"})," 回调函数中做一层处理，修改 ",(0,r.jsx)(n.code,{children:"auth.js"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import NextAuth from "next-auth"\n// import GitHub from "next-auth/providers/github"\nimport CredentialsProvider from "next-auth/providers/credentials";\nimport { addUser, getUser } from "@/lib/prisma";\n\nexport const { handlers, auth, signIn, signOut } = NextAuth({\n  providers:[CredentialsProvider({\n    // 显示按钮文案 (e.g. "Sign in with...")\n    name: "密码登录",\n    // `credentials` 用于渲染登录页面表单\n    credentials: {\n      username: { label: "账号", type: "text", placeholder: "输入您的账号" },\n      password: { label: "密码", type: "password", placeholder: "输入您的密码" }\n    },\n    // 处理从用户收到的认证信息\n    async authorize(credentials, req) {\n      // 默认情况下不对用户输入进行验证，确保使用 Zod 这样的库进行验证\n      let user = null\n\n      // 登陆信息验证\n      user = await getUser(credentials.username, credentials.password)\n\n      // 密码错误\n      if (user === 1) return null\n\n      // 用户注册\n      if (user === 0) {\n        user = await addUser(credentials.username, credentials.password)\n      }\n\n      if (!user) {\n        throw new Error("User was not found and could not be created.")\n      }\n\n      return user\n    }\n  })],\n  pages: {\n    signIn: \'/auth/signin\'\n  },\n  callbacks: {\n    authorized({ request, auth }) {\n      const { pathname } = request.nextUrl\n      if (pathname.startsWith("/note/edit")) return !!auth\n      return true\n    },\n    async jwt({ token, user, account }) {\n      if (account && account.type === "credentials" && user) {\n        token.userId = user.userId;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token.userId) {\n        session.user.userId = token.userId\n      }\n      return session;\n    },\n    async redirect({ url, baseUrl }) {\n      if (url.startsWith("/")) return `${baseUrl}${url}`\n      else if (new URL(url).origin === baseUrl) return url\n      if (baseUrl.indexOf(":3000") > -1) return url\n      return baseUrl\n    }\n  },\n  trustHost: true\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"运行："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 删除掉之前的容器\ndocker compose -f dev.docker-compose.yml down\n# 重新构建镜像\ndocker compose -f dev.docker-compose.yml up --build\n"})}),"\n",(0,r.jsxs)(n.p,{children:["本地访问 ",(0,r.jsx)(n.a,{href:"https://notes.yayujs.com",target:"_blank",rel:"noopener noreferrer",children:"https://notes.yayujs.com"}),"，此时应该可以正常运行："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"那么问题来了，如果我切换了 host，我如何知道浏览器打开的地址访问的是线上还是本地呢？"}),"\n",(0,r.jsx)(n.p,{children:"方法有很多种，一种简单的方式是查看页面请求头，如果是本地："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"截屏2024-02-20 16.39.06.png"})}),"\n",(0,r.jsx)(n.p,{children:"如果是线上："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"截屏2024-02-20 16.40.20.png"})}),"\n",(0,r.jsx)(n.p,{children:"如果切换后没有生效，就参照上节讲的两种方式试试。"}),"\n",(0,r.jsx)(n.p,{children:"至此我们就用 Docker 搭建了一个开发环境，我们的目标是："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"提供一个一致的开发环境，不用在每台主机上都配置一遍"}),"\n",(0,r.jsx)(n.li,{children:"模拟复制一个线上环境，不用担心漏掉某些配置"}),"\n",(0,r.jsx)(n.li,{children:"正常本地开发 Next.js 项目的功能如热更新继续支持，能够实时查看效果"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"docker-生产部署",children:["Docker 生产部署",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#docker-生产部署",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来我们看看生产部署的时候要做些什么。"}),"\n",(0,r.jsx)(n.p,{children:"其实主要就两件事情，一是编译和运行生产版本，二是减少镜像大小，毕竟我们开发时构建的镜像包都快有 1G 了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"这谁能忍？（其实我能忍，但为了显得我精益求精、既要又要还要，我们还是努力优化一下……）"}),"\n",(0,r.jsx)(n.p,{children:"减少镜像的大小，主要是开启 Next.js 项目的 standalone 模式，然后优化镜像构建。"}),"\n",(0,r.jsxs)(n.p,{children:["注：关于 standalone 输出模式的介绍可以查看",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079467967414310",target:"_blank",rel:"noopener noreferrer",children:"《API 篇 | next.config.js（下）》"})]}),"\n",(0,r.jsx)(n.p,{children:"那就让我们开始吧。"}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"next.config.js"}),"，开启 standalone 输出模式，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const nextConfig = {\n  output: 'standalone'\n}\nmodule.exports = nextConfig\n"})}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"prod.Dockerfile"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-dockerfile",children:'FROM node:18-alpine AS base\n\nFROM base AS builder\n\nWORKDIR /app\n\nCOPY . .\n\nRUN npm i --registry=https://registry.npmmirror.com;\n\nRUN npx prisma generate\n\nRUN npm run build;\n\nFROM base AS runner\n\nWORKDIR /app\n\nCOPY --from=builder /app/public ./public\n\nCOPY --from=builder /app/.next/standalone ./\nCOPY --from=builder /app/.next/static ./.next/static\n\nENV NEXT_TELEMETRY_DISABLED 1\n\nCOPY prisma ./prisma/\nCOPY prod.startup.sh ./prod.startup.sh\nRUN chmod +x /app/prod.startup.sh\n\nENTRYPOINT ["sh", "/app/prod.startup.sh"]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"prod.startup.sh"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/sh\n\nMIGRATION_STATUS=$(npx prisma migrate status)\n\nif echo "$MIGRATION_STATUS" | grep -q "Database schema is up to date"; then\n    echo "No migrations needed."\nelse\n    echo "Running migrations..."\n    npx prisma migrate deploy\nfi\n\nnode server.js\n'})}),"\n",(0,r.jsxs)(n.p,{children:["项目根目录新建 ",(0,r.jsx)(n.code,{children:"prod.docker-compose.yml"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"version: \"3.8\"\n\nnetworks:\n  react-notes-prod:\n    driver: bridge\n\nservices:\n  next-app-prod:\n    container_name: next-app\n    build:\n      context: .\n      dockerfile: prod.Dockerfile\n    env_file:\n      - .env\n      - .env.production\n    restart: always\n    ports:\n      - 3000:3000\n    networks:\n      - react-notes-prod\n    depends_on:\n      mysql:\n        condition: service_healthy\n      \n  mysql:\n    image: mysql:8.0\n    container_name: next-app-mysql\n    command: --default-authentication-plugin=caching_sha2_password\n    restart: unless-stopped\n    # volumes:\n    #   - ./docker/data/mysql/:/var/lib/mysql/\n    environment:\n      - MYSQL_ROOT_PASSWORD=admin\n      - MYSQL_DATABASE=notes\n      - MYSQL_USER=notes\n      - MYSQL_PASSWORD=cpZfriEBbmJjWeiR\n    ports:\n      - '3306:3306'\n    healthcheck:\n      test: ['CMD', 'mysqladmin', 'ping', '-h127.0.0.1', '-P3306']\n      interval: 5s\n      timeout: 2s\n      retries: 20\n    networks:\n      - react-notes-prod\n\n  nginx:\n    image: nginx\n    container_name: next-app-nginx\n    volumes:\n      - ./docker/nginx.conf:/etc/nginx/nginx.conf\n      - ./docker/ssl/notes.yayujs.com.key:/etc/nginx/ssl/notes.yayujs.com.key\n      - ./docker/ssl/notes.yayujs.com.pem:/etc/nginx/ssl/notes.yayujs.com.pem\n    ports:\n      - 80:80\n      - 443:443\n    restart: always\n    networks:\n      - react-notes-prod\n    depends_on:\n      - next-app-prod\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:".env"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'DATABASE_URL="mysql://notes:cpZfriEBbmJjWeiR@next-app-mysql:3306/notes"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:".env.production"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 注释掉 AUTH_URL，因为会导致报错，预计会在 Next.js v14.1.1 版本修复\n# AUTH_URL=https://notes.yayujs.com\n"})}),"\n",(0,r.jsx)(n.p,{children:"因为容器名不能重复，我们删除掉之前用于开发模式的容器："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"docker compose -f dev.docker-compose.yml down\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后构建镜像并运行生产模式的容器："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"docker compose -f prod.docker-compose.yml up\n"})}),"\n",(0,r.jsx)(n.p,{children:"此时本地应该可以正常访问："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"查看镜像大小："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"镜像从之前的 830M 优化到了现在的 169M，可喜可贺！（懒得继续优化了……）"}),"\n",(0,r.jsx)(n.p,{children:"部署到线上的方式也很简单："}),"\n",(0,r.jsx)(n.p,{children:"将代码推送到服务器上，然后登陆服务器，进入到项目根目录，运行相同的命令："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"docker compose -f prod.docker-compose.yml up\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如果参照",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309114747482275850",target:"_blank",rel:"noopener noreferrer",children:"《实战篇 | React Notes | 服务器部署》"}),"在宝塔设置过 Node 项目，记得删除 Node 项目或者修改对应的 Nginx 配置，否则可能会因为端口占用影响容器运行。"]}),"\n",(0,r.jsx)(n.p,{children:"现在我们又一次用 Docker 把代码部署到了服务器上，还做了不少优化，但是这样的方法只能说——勉强能用……"}),"\n",(0,r.jsxs)(n.p,{children:["大问题基本解决，小问题依然很多：比如还是没有解决数据库持久化问题，不过这个比较简单，参考上篇 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7330567768579637299",target:"_blank",rel:"noopener noreferrer",children:"《实战篇 | React Notes | Docker 快速入门》"}),"即可自己创建数据卷。如果大家在实际的开发中用到 Redis，比如用 Redis 做数据缓存，也可以参考《实战篇 | React Notes | Docker 快速入门》中的 Docker Compose 配置。"]}),"\n",(0,r.jsx)(n.p,{children:"比如目前我们虽然构建了两个镜像，但因为容器名不能重复，所以我们运行本地或者线上的时候，都要删除掉之前的容器再重新开一个容器，如果分别建立两个容器，Nginx 配置需要做两份或者改为读取环境变量的方式，这又要做一点配置工作。此外流程上还可以借助 Jenkins 实现 CI/CD，优化开发流程……"}),"\n",(0,r.jsx)(n.p,{children:"总之任重而道远。Docker 会用就好用，不会用的时候要踩一堆坑，我们慢慢讲解。后面的项目我们会继续用 Docker 作为基本的开发方式。"}),"\n",(0,r.jsxs)(n.p,{children:["本篇项目源码：",(0,r.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day12",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day12"})]}),"\n",(0,r.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://stackoverflow.com/questions/76698529/how-to-update-the-prisma-in-a-production-docker-instance",target:"_blank",rel:"noopener noreferrer",children:"https://stackoverflow.com/questions/76698529/how-to-update-the-prisma-in-a-production-docker-instance"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/vercel/next.js/blob/canary/examples/with-docker-compose/next-app/dev.Dockerfile",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/vercel/next.js/blob/canary/examples/with-docker-compose/next-app/dev.Dockerfile"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/prisma/prisma/blob/main/docker/docker-compose.yml",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/prisma/prisma/blob/main/docker/docker-compose.yml"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/prisma/prisma-examples/blob/latest/databases/mongodb/docker-compose.yml",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/prisma/prisma-examples/blob/latest/databases/mongodb/docker-compose.yml"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://github.com/nextauthjs/next-auth/issues/9922",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/nextauthjs/next-auth/issues/9922"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://gist.github.com/malteneuss/a7fafae22ea81e778654f72c16fe58d3",target:"_blank",rel:"noopener noreferrer",children:"https://gist.github.com/malteneuss/a7fafae22ea81e778654f72c16fe58d3"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client",target:"_blank",rel:"noopener noreferrer",children:"https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client"})}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}let k=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F49.%E5%AE%9E%E6%88%98%E7%AF%87%20_%20React%20Notes%20_%20Docker%20%E9%83%A8%E7%BD%B2.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"Docker 直接部署",id:"docker-直接部署",depth:2},{text:"下载代码",id:"下载代码",depth:3},{text:"构建镜像",id:"构建镜像",depth:3},{text:"服务器运行",id:"服务器运行",depth:3},{text:"Docker 本地开发",id:"docker-本地开发",depth:2},{text:"下载代码",id:"下载代码-1",depth:3},{text:"`.dockerignore`",id:"dockerignore",depth:3},{text:"`dev.Dockerfile`",id:"devdockerfile",depth:3},{text:"dev.startup.sh",id:"devstartupsh",depth:3},{text:"dev.docker-compose.yml",id:"devdocker-composeyml",depth:3},{text:"host",id:"host",depth:3},{text:"nginx",id:"nginx",depth:3},{text:"Docker 生产部署",id:"docker-生产部署",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);