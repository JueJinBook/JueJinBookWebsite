"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["20092"],{412166:function(e,n,c){c.r(n),c.d(n,{default:()=>l});var r=c(552676),d=c(740453);function t(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",strong:"strong"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"10响应式原理computed-函数和普通函数有什么不同",children:["10.响应式原理：computed 函数和普通函数有什么不同？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10响应式原理computed-函数和普通函数有什么不同",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["计算属性接受一个 ",(0,r.jsx)(n.code,{children:"getter"})," 函数，返回一个只读的响应式\xa0",(0,r.jsx)(n.a,{href:"https://cn.vuejs.org/api/reactivity-core.html#ref",target:"_blank",rel:"noopener noreferrer",children:"ref"}),"\xa0对象。该 ",(0,r.jsx)(n.code,{children:"ref"})," 通过\xa0",(0,r.jsx)(n.code,{children:".value"}),"\xa0暴露 ",(0,r.jsx)(n.code,{children:"getter"})," 函数的返回值。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // 错误\n"})}),"\n",(0,r.jsxs)(n.p,{children:["它也可以接受一个带有\xa0",(0,r.jsx)(n.code,{children:"get"}),"\xa0和\xa0",(0,r.jsx)(n.code,{children:"set"}),"\xa0函数的对象来创建一个可写的 ref 对象。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: (val) => {\n    count.value = val - 1\n  }\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0\n"})}),"\n",(0,r.jsxs)(n.p,{children:["接下来看看源码里是如何实现 ",(0,r.jsx)(n.code,{children:"computed"})," 的 ",(0,r.jsx)(n.code,{children:"API"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"构造-setter-和-getter",children:["构造 setter 和 getter",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#构造-setter-和-getter",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter\n  let setter\n  // 判断第一个参数是不是一个函数\n  const onlyGetter = isFunction(getterOrOptions)\n  \n  // 构造 setter 和 getter 函数\n  if (onlyGetter) {\n    getter = getterOrOptions\n    // 如果第一个参数是一个函数，那么就是只读的\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n  // 构造 ref 响应式对象\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\n  // 返回响应式 ref\n  return cRef\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到，这段 ",(0,r.jsx)(n.code,{children:"computed"})," 函数体最初就是需要格式化传入的参数，根据第一个参数入参的类型来构造统一的 ",(0,r.jsx)(n.code,{children:"setter"})," 和 ",(0,r.jsx)(n.code,{children:"getter"})," 函数，并传入 ",(0,r.jsx)(n.code,{children:"ComputedRefImpl"})," 类中，进行实例化 ",(0,r.jsx)(n.code,{children:"ref"})," 响应式对象。"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来一起看看 ",(0,r.jsx)(n.code,{children:"ComputedRefImpl"})," 是如何构造 ",(0,r.jsx)(n.code,{children:"cRef"})," 响应式对象的。"]}),"\n",(0,r.jsxs)(n.h2,{id:"构造-cref-响应式对象",children:["构造 cRef 响应式对象",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#构造-cref-响应式对象",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class ComputedRefImpl {\n  public dep = undefined\n\n  private _value\n  public readonly effect\n  //表示 ref 类型\n  public readonly __v_isRef = true\n  //是否只读\n  public readonly [ReactiveFlags.IS_READONLY] = false\n  //用于控制是否进行值更新(代表是否脏值)\n  public _dirty = true\n  // 缓存\n  public _cacheable\n\n  constructor(\n    getter,\n    _setter,\n    isReadonly,\n    isSSR\n  ) {\n    // 把 getter 作为响应式依赖函数 fn 参数\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true\n        // 触发更新\n        triggerRefValue(this)\n      }\n    })\n    // 标记 effect 的 computed 属性\n    this.effect.computed = this\n    this.effect.active = this._cacheable = !isSSR\n    this[ReactiveFlags.IS_READONLY] = isReadonly\n  }\n\n  get value() {\n    const self = toRaw(this)\n    // 依赖收集\n    trackRefValue(self)\n    // 脏值则进行更新\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false\n      // 更新值\n      self._value = self.effect.run()!\n    }\n    return self._value\n  }\n  // 执行 setter\n  set value(newValue) {\n    this._setter(newValue)\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["简单看一下该类的实现：在构造函数的时候，创建了一个副作用对象 ",(0,r.jsx)(n.code,{children:"effect"}),"。并为 ",(0,r.jsx)(n.code,{children:"effect"})," 额外定义了一个 ",(0,r.jsx)(n.code,{children:"computed"})," 属性执行当前响应式对象 ",(0,r.jsx)(n.code,{children:"cRef"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["另外，定义了一个 ",(0,r.jsx)(n.code,{children:"get"})," 方法，当我们通过 ",(0,r.jsx)(n.code,{children:"ref.value"})," 取值的时候可以进行依赖收集，将定义的 ",(0,r.jsx)(n.code,{children:"effect"})," 收集起来。"]}),"\n",(0,r.jsxs)(n.p,{children:["其次，定义了一个 ",(0,r.jsx)(n.code,{children:"set"})," 方法，该方法就是执行传入进来的 ",(0,r.jsx)(n.code,{children:"setter"})," 函数。"]}),"\n",(0,r.jsxs)(n.p,{children:["最后，熟悉\xa0",(0,r.jsx)(n.code,{children:"Vue"}),"\xa0的开发者都知道\xa0",(0,r.jsx)(n.code,{children:"computed"}),"\xa0的特性就在于能够缓存计算的值（提升性能），只有当\xa0",(0,r.jsx)(n.code,{children:"computed"}),"\xa0的依赖发生变化时才会重新计算，否则读取\xa0",(0,r.jsx)(n.code,{children:"computed"}),"\xa0的值则一直是之前的值。在源码这里，实现上述功能相关的变量分别是 ",(0,r.jsx)(n.code,{children:"_dirty"})," 和 ",(0,r.jsx)(n.code,{children:"_cacheable"})," 这 2 个，用来控制缓存的实现。"]}),"\n",(0,r.jsxs)(n.p,{children:["有了上面的介绍，我们来看一个具体的例子，看看 ",(0,r.jsx)(n.code,{children:"computed"})," 是如何执行的："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<template> \n  <div> \n    {{ plusOne }} \n  </div> \n  <button @click=\"plus\">plus</button> \n</template> \n<script> \n  import { ref, computed } from 'vue' \n  export default { \n    setup() { \n      const num = ref(0) \n      const plusOne = computed(() => { \n        return num.value + 1 \n      }) \n\n      function plus() { \n        num.value++ \n      } \n      return { \n        plusOne, \n        plus \n      } \n    } \n  } \n<\/script>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Step 1"}),"：",(0,r.jsx)(n.code,{children:"setup"})," 函数体内，",(0,r.jsx)(n.code,{children:"computed"})," 函数执行，初始的过程中，生成了一个 ",(0,r.jsx)(n.code,{children:"computed effect"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Step 2"}),"：初始化渲染的时候，",(0,r.jsx)(n.code,{children:"render"})," 函数访问了 ",(0,r.jsx)(n.code,{children:"plusOne.value"}),"，触发了收集，此时收集的副作用为 ",(0,r.jsx)(n.code,{children:"render effect"}),"，因为是首次访问，所以此时的 ",(0,r.jsx)(n.code,{children:"self._dirty = true"})," 执行 ",(0,r.jsx)(n.code,{children:"effect.run()"})," 也就是执行了 ",(0,r.jsx)(n.code,{children:"getter"})," 函数，得到 ",(0,r.jsx)(n.code,{children:"_value = 1"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Step 3"}),"：",(0,r.jsx)(n.code,{children:"getter"})," 函数体内访问了 ",(0,r.jsx)(n.code,{children:"num.value"})," 触发了对 ",(0,r.jsx)(n.code,{children:"num"})," 的依赖收集，此时收集到的依赖为 ",(0,r.jsx)(n.code,{children:"computed effect"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Step 4"}),"：点击按钮，此时 ",(0,r.jsx)(n.code,{children:"num = 1"})," 触发了 ",(0,r.jsx)(n.code,{children:"computed effect"})," 的 ",(0,r.jsx)(n.code,{children:"schduler"})," 调度，因为 ",(0,r.jsx)(n.code,{children:"_dirty = false"}),"，所以触发了 ",(0,r.jsx)(n.code,{children:"triggerRefValue"})," 的执行，同时，设置 ",(0,r.jsx)(n.code,{children:"_dirty = true"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Step 5"}),"：",(0,r.jsx)(n.code,{children:"triggerRefValue"})," 执行过程中，会执行 ",(0,r.jsx)(n.code,{children:"computed effect.run()"})," 触发 ",(0,r.jsx)(n.code,{children:"getter"})," 函数的执行。因为此时的 ",(0,r.jsx)(n.code,{children:"_dirty = true"}),"，所以 ",(0,r.jsx)(n.code,{children:"get value"})," 会重新计算 ",(0,r.jsx)(n.code,{children:"_value"})," 的值为 ",(0,r.jsx)(n.code,{children:"plusOne.value = 2"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Step 6"}),"：",(0,r.jsx)(n.code,{children:"plusOne.value"})," 值变化后，触发了 ",(0,r.jsx)(n.code,{children:"render effect.run"})," 重新渲染。"]}),"\n",(0,r.jsxs)(n.p,{children:["可以看到 ",(0,r.jsx)(n.code,{children:"computed"})," 函数通过 ",(0,r.jsx)(n.code,{children:"_dirty"})," 把 ",(0,r.jsx)(n.code,{children:"computed"})," 的缓存特性表现得淋漓尽致，只有当 ",(0,r.jsx)(n.code,{children:"_dirty = true"})," 的时候，才会进行重新计算求值，而 ",(0,r.jsx)(n.code,{children:"_dirty = true"})," 只有在首次取值或者取值内部依赖发生变化时才会执行。"]}),"\n",(0,r.jsxs)(n.h2,{id:"计算属性的执行顺序",children:["计算属性的执行顺序",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#计算属性的执行顺序",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这里，我们介绍完了 ",(0,r.jsx)(n.code,{children:"computed"})," 的核心流程，但是细心的同学可能发现，这里我们还漏了一个小的知识点没有介绍，就是在类 ",(0,r.jsx)(n.code,{children:"ComputedRefImpl"})," 的构造函数中，执行了这样一行代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"this.effect.computed = this\n"})}),"\n",(0,r.jsxs)(n.p,{children:["那么这行代码的作用是什么呢？在说这个作用之前，我们先来看一个 ",(0,r.jsx)(n.code,{children:"demo"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { ref, effect, computed } = Vue\n\nconst n = ref(0)\nconst plusOne = computed(() => n.value + 1)\neffect(() => {\n  n.value\n  console.log(plusOne.value)\n})\nn.value++\n"})}),"\n",(0,r.jsx)(n.p,{children:"小伙伴们可以猜测一下上述代码的打印结果。"}),"\n",(0,r.jsx)(n.p,{children:"可能有些小伙伴猜测应该是："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n1\n2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["首先是 ",(0,r.jsx)(n.code,{children:"effect"})," 函数先执行，触发 ",(0,r.jsx)(n.code,{children:"n"})," 的依赖收集，然后访问了 ",(0,r.jsx)(n.code,{children:"plusOne.value"}),"，再收集 ",(0,r.jsx)(n.code,{children:"computed effect"}),"。然后执行 ",(0,r.jsx)(n.code,{children:"n.value++"})," 按照顺序触发 ",(0,r.jsx)(n.code,{children:"effect"})," 执行，所以理论上先触发 ",(0,r.jsx)(n.code,{children:"effect"})," 函数内部的回调，再去执行 ",(0,r.jsx)(n.code,{children:"computed"})," 的重新求值。所以输出是上述结果。"]}),"\n",(0,r.jsx)(n.p,{children:"但事实确实："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1\n2\n2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这就是因为上面那一行代码的作用。",(0,r.jsx)(n.code,{children:"effect.computed"})," 的标记保障了 ",(0,r.jsx)(n.code,{children:"computed effect"})," 会优先于其他普通副作用函数先执行，关于具体的实现，可以看一下 ",(0,r.jsx)(n.code,{children:"triggerEffects"})," 函数体内对 ",(0,r.jsx)(n.code,{children:"computed"})," 的特殊处理："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = isArray(dep) ? dep : [...dep]\n  // 确保执行完所有的 computed\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n  // 再执行其他的副作用函数\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect, debuggerEventExtraInfo)\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["总而言之，计算属性可以",(0,r.jsx)(n.strong,{children:"从状态数据中计算出新数据"}),"，",(0,r.jsx)(n.code,{children:"computed"})," 和 ",(0,r.jsx)(n.code,{children:"methods"})," 的最大差异是它具备缓存性，如果依赖项不变时不会重新计算，而是直接返回缓存的值。"]}),"\n",(0,r.jsxs)(n.p,{children:["搞懂了本小节关于 ",(0,r.jsx)(n.code,{children:"computed"})," 函数的介绍后，相信你已经知道计算属性相对于普通函数的不同之处的原理，在以后的开发中，可以更合理地使用计算属性！"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let l=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F10.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%9Acomputed%20%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"构造 setter 和 getter",id:"构造-setter-和-getter",depth:2},{text:"构造 cRef 响应式对象",id:"构造-cref-响应式对象",depth:2},{text:"计算属性的执行顺序",id:"计算属性的执行顺序",depth:2},{text:"总结",id:"总结",depth:2}],title:"10.响应式原理：computed 函数和普通函数有什么不同？",headingTitle:"10.响应式原理：computed 函数和普通函数有什么不同？",frontmatter:{}}}}]);