"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19590"],{303268:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var s=r(552676),a=r(740453);function c(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",pre:"pre",ul:"ul",li:"li",blockquote:"blockquote",h3:"h3",strong:"strong"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"作为一名前端开发者，我们会很轻松地将我们开发的网页部署到各类云 OSS 上。如果后续在需求迭代中，出现了一些 bug，我们可以对代码进行修复后再次发布，所有用户都会很容易更新到最新的代码。"}),"\n",(0,s.jsx)(n.p,{children:"然而，如果你正在使用 Electron 构建桌面应用程序，此时出现了一些 bug，你也尝试修复了这个问题，但是如何确保你的用户收到并更新呢？"}),"\n",(0,s.jsx)(n.p,{children:"这个小节，我们来一起探讨 Electron 更新的几种方式以及各种更新模式下的优劣问题。"}),"\n",(0,s.jsxs)(n.h2,{id:"1-全量更新",children:["1. 全量更新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-全量更新",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["手动全量更新核心原理是在启动 Electron 应用程序的时候获取服务器当前软件最新的版本号和本地软件中的 ",(0,s.jsx)(n.code,{children:"package.json"})," 版本进行匹配，如果发现落后于服务器版本则进行更新提示，并引导用户进行手动下载安装，核心代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { dialog, shell } from 'electron';\nimport { lt } from 'semver';\nimport pkg from '../../../package.json';\nimport { getLatestVersion } from './getLatestVersion';\n\n// 本地版本号，从 package.json 中获取\nconst version = pkg.version;\nconst downloadUrl = 'https://xxx/releases/latest';\n\nconst checkVersion = async () => {\n  // 获取服务器软件的最新版本\n  const res = await getLatestVersion();\n  if (res !== '') {\n    const latest = res;\n    // 版本比对，确认是否落后于服务器版本\n    const result = compareVersion2Update(version, latest);\n    if (result) {\n      // 如果落后，则提示更新信息\n      dialog\n        .showMessageBox({\n          type: 'info',\n          title: 'Rubick 更新提示',\n          buttons: ['Yes', 'No'],\n          message: `发现新版本 v${latest}，是否更新？`,\n        })\n        .then((res) => {\n          if (res.response === 0) {\n            // 跳转到更新地址，进行手动下载\n            shell.openExternal(downloadUrl);\n          }\n        });\n    }\n  } else {\n    return false;\n  }\n};\n\n// if true -> update else return false\nconst compareVersion2Update = (current, latest) => {\n  try {\n    if (latest.includes('beta')) {\n      return false;\n    }\n    return lt(current, latest);\n  } catch (e) {\n    return false;\n  }\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"这种更新方式优点是实现方式简单，而且非常稳定。但过程繁琐、软件包大多在 100M 左右，更新速度特别慢，而且用户更新意愿也不是很强烈，更新率低，极大可能会出现下面这幅图的情况："}),"\n",(0,s.jsxs)(n.h2,{id:"2-文件覆盖式更新",children:["2. 文件覆盖式更新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-文件覆盖式更新",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们知道，Electron 在打包后会将我们的业务代码全部导入到 ",(0,s.jsx)(n.code,{children:"app.asar"})," 文件中，",(0,s.jsx)(n.code,{children:"app.asar"})," 文件一般包含以下文件："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"main"})," ：主进程的入口文件。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"renderer"}),"：渲染进程入口文件。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"preload"}),"：预加载脚本文件"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["所以，如果我们只修改了渲染进程里面的东西的话，并不需要进行完全的打包更新，只要对 ",(0,s.jsx)(n.code,{children:"renderer"})," 文件中依赖的 ",(0,s.jsx)(n.code,{children:"js、html、css"})," 进行替换，那我们的页面也会更新。要完成对 ",(0,s.jsx)(n.code,{children:"renderer"})," 更新大多数想到办法是直接替换覆盖用户本地的 ",(0,s.jsx)(n.code,{children:"app.asar"})," 文件即可。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"macOS"})," 上确实可以，在需要更新时，下载新的 ",(0,s.jsx)(n.code,{children:"asar"})," 包覆盖旧的 ",(0,s.jsx)(n.code,{children:"asar"})," 包并重启应用即可，而且在应用程序运行的过程中，依然可以操作覆盖，不影响正常使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["但是在 ",(0,s.jsx)(n.code,{children:"Windows"})," 上，并不能直接替换 ",(0,s.jsx)(n.code,{children:"asar"})," 文件，主要是因为："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如果程序正在运行，是不可以覆盖 asar 文件的，否则会出现锁定提示，必须关闭当前应用。"}),"\n",(0,s.jsx)(n.li,{children:"即使应用已关闭，如果用户安装到 C 盘，还需要管理员权限才能覆盖 asar 文件。"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["要解决上面的问题其实也有解决方案，可以参考这篇文章：",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7250288616533491749?searchId=20231222144125C40E2E68EAD7905996F0",target:"_blank",rel:"noopener noreferrer",children:"详解 Electron 应用升级"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"21-使用-extraresources-字段",children:["2.1 使用 extraResources 字段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-使用-extraresources-字段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["既然 ",(0,s.jsx)(n.code,{children:".asar"})," 文件不可以覆盖，那就把需要更新的资源不打包到 ",(0,s.jsx)(n.code,{children:".asar"})," 中，在 ",(0,s.jsx)(n.code,{children:"electron-builder"})," 中，我们可以通过 ",(0,s.jsx)(n.a,{href:"https://www.electron.build/configuration/contents#extraresources",target:"_blank",rel:"noopener noreferrer",children:"extraResources"})," 字段，将一些不需要打包进 ",(0,s.jsx)(n.code,{children:".asar"})," 的文件提取到 ",(0,s.jsx)(n.code,{children:"app.asar.unpacked"})," 文件夹中。比如，我们可以通过以下配置将渲染进程中的代码在打包的时候提取到 ",(0,s.jsx)(n.code,{children:"app.asar.unpacked"})," 中："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'builderOptions: {\n  // ...\n  extraResources: [{\n    from: "dist_electron/bundled",\n    to: "app.asar.unpacked",\n    filter: [\n      "!**/icons",\n      "!**/preload.js",\n      "!**/node_modules",\n      "!**/background.js"\n    ]\n  }],\n  files: [\n    "**/icons/*",\n    "**/preload.js",\n    "**/node_modules/**/*",\n    "**/background.js"\n  ]\n},\n'})}),"\n",(0,s.jsxs)(n.p,{children:["其中，我们通过 ",(0,s.jsx)(n.code,{children:"extraResources.filter"})," 字段指明了：",(0,s.jsxs)(n.strong,{children:["除了哪些内容外，需要构建到 ",(0,s.jsx)(n.code,{children:"app.asar.unpacked"})," 中的资源"]}),"，通过 ",(0,s.jsx)(n.code,{children:"files"})," 字段指明了：",(0,s.jsxs)(n.strong,{children:["需要构建到 ",(0,s.jsx)(n.code,{children:"app.asar"})," 中的资源"]}),"。这段配置的意思就是除了 ",(0,s.jsx)(n.code,{children:"icons、preload.js、node_modules、background.js"})," 外，其他渲染进程中的 ",(0,s.jsx)(n.code,{children:"index.html、js、css"})," 资源全部打包进 ",(0,s.jsx)(n.code,{children:"app.asar.unpacked"})," 中。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以通过 ",(0,s.jsx)(n.code,{children:"electron-builder"})," 打包试试看，最终的目录大致如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"app.asar.unpacked\n├── css\n│\xa0\xa0 └── index.b2d625b8.css\n├── index.html\n├── js\n│\xa0\xa0 ├── chunk-vendors.96b10160.js\n│\xa0\xa0 ├── chunk-vendors.96b10160.js.map\n│\xa0\xa0 ├── index.cfe3540f.js\n│\xa0\xa0 └── index.cfe3540f.js.map\n└── package.json\n"})}),"\n",(0,s.jsxs)(n.p,{children:["因为之前默认打包的是 ",(0,s.jsx)(n.code,{children:"app.asar"})," 文件，主窗口也是从 ",(0,s.jsx)(n.code,{children:"app.asar"})," 文件中加载 ",(0,s.jsx)(n.code,{children:"html"})," 文件的，以 ",(0,s.jsx)(n.code,{children:"vue-cli-plugin-electron-builder"})," 为例："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { createProtocol } from 'vue-cli-plugin-electron-builder/lib'\n\n// 开发环境\nif (process.env.WEBPACK_DEV_SERVER_URL) {\n  await win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)\n  if (!process.env.IS_TEST) win.webContents.openDevTools()\n} else {\n  // 生产环境\n  createProtocol('app')\n  win.loadURL('app://./index.html')\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里的 ",(0,s.jsx)(n.code,{children:"app://"})," 是通过 ",(0,s.jsx)(n.code,{children:"createProtocol('app')"})," 函数注册的请求协议，指向的是 ",(0,s.jsx)(n.code,{children:"app.asar"})," 文件，一起来看看 ",(0,s.jsx)(n.code,{children:"vue-cli-plugin-electron-builder"})," 中的 ",(0,s.jsx)(n.code,{children:"createProtocol"})," 方法："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// createProtocol.js\nimport { protocol } from 'electron'\nimport * as path from 'path'\nimport { readFile } from 'fs'\nimport { URL } from 'url'\n\nexport default (scheme, customProtocol) => {\n  (customProtocol || protocol).registerBufferProtocol(\n    scheme,\n    (request, respond) => {\n      let pathName = new URL(request.url).pathname\n      pathName = decodeURI(pathName) \n      //  __dirname 在打包后指向的是 app.asar\n      // dev 环境指向的是 dist_electron\n      readFile(path.join(__dirname, pathName), (error, data) => {\n        if (error) {\n          console.error(\n            `Failed to read ${pathName} on ${scheme} protocol`,\n            error\n          )\n        }\n        const extension = path.extname(pathName).toLowerCase()\n        let mimeType = ''\n\n        if (extension === '.js') {\n          mimeType = 'text/javascript'\n        } else if (extension === '.html') {\n          mimeType = 'text/html'\n        } else if (extension === '.css') {\n          mimeType = 'text/css'\n        } else if (extension === '.svg' || extension === '.svgz') {\n          mimeType = 'image/svg+xml'\n        } else if (extension === '.json') {\n          mimeType = 'application/json'\n        } else if (extension === '.wasm') {\n          mimeType = 'application/wasm'\n        }\n        // 响应数据\n        respond({ mimeType, data })\n      })\n    }\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["所以，我们需要修改 ",(0,s.jsx)(n.code,{children:"createProtocol"})," 函数，将从 ",(0,s.jsx)(n.code,{children:"app.asar"})," 中读取文件修改成 ",(0,s.jsx)(n.code,{children:"app.asar.unpacked"})," 中的资源："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// process.resourcesPath 指向 Resource 目录\nconst serverPath = path.join(process.resourcesPath, './app.asar.unpacked')\n\nexport default (scheme) => {\n  protocol.registerBufferProtocol(\n    scheme,\n    (request, respond) => {\n      // ...\n      // 这里改成 app.asar.unpacked 的路径\n      readFile(path.join(serverPath, pathName), (error, data) => {\n        // ...  \n      })\n    }\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这样，我们就可以实现正确的资源加载了。后面的操作就是通过检测版本号判断是否需要更新，如果需要更新可以通过 ",(0,s.jsx)(n.a,{href:"https://github.com/kevva/download",target:"_blank",rel:"noopener noreferrer",children:"download"})," 这个库来完成对资源的覆盖式下载更新："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import download from 'download';\nimport path from 'path';\n\n// 指定下载地址为 app.asar.unpacked\nconst target = path.join(process.resourcesPath, './app.asar.unpacked')\n\nconst update = async () => {\n  try {\n    // 下载打包后的 zip 包并解压到 app.asar.unpacked 中\n    await download('github.com/muwoo/test-zip/releases/download/asd/dist.zip', target, {\n      extract: true,\n      strip: 1,\n    });\n  } catch (e) {\n    console.log(e);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"22-使用-asar-字段",children:["2.2 使用 asar 字段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-使用-asar-字段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["除了使用 ",(0,s.jsx)(n.code,{children:"extraResources"})," 字段外，我们还可以通过 ",(0,s.jsx)(n.code,{children:"electron-builder"})," 的 ",(0,s.jsx)(n.code,{children:"asar"})," 字段来指明不打包成 ",(0,s.jsx)(n.code,{children:"asar"})," 虚拟目录："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"asar: false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["通过这种方式打包，我们可以直接得到一个无 ",(0,s.jsx)(n.code,{children:"app.asar"})," 的 ",(0,s.jsx)(n.code,{children:"app"})," 目录："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"app\n├── background.js\n├── css\n│\xa0\xa0 └── index.b2d625b8.css\n├── index.html\n├── js\n│\xa0\xa0 ├── chunk-vendors.96b10160.js\n│\xa0\xa0 ├── chunk-vendors.96b10160.js.map\n│\xa0\xa0 ├── index.882b48ee.js\n│\xa0\xa0 └── index.882b48ee.js.map\n├── package.json\n└── preload.js\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个 ",(0,s.jsx)(n.code,{children:"app"})," 文件夹目录是直接可以进行替换的，那么接下来覆盖式更新和设置就和上面的使用 ",(0,s.jsx)(n.code,{children:"extraResources"})," 字段打包后是一致的了，需要指明一下加载的文件资源路径。"]}),"\n",(0,s.jsxs)(n.h2,{id:"3-自动更新",children:["3. 自动更新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-自动更新",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果你使用的 ",(0,s.jsx)(n.code,{children:"electron-builder"}),"，那么你可以直接使用 ",(0,s.jsx)(n.a,{href:"https://www.electron.build/auto-update.html",target:"_blank",rel:"noopener noreferrer",children:"electron-updater"})," 来进行软件的自动更新。接下来，我们将基于 ",(0,s.jsx)(n.code,{children:"vue-cli-plugin-electron-builder"})," 来详细介绍一下如何使用 ",(0,s.jsx)(n.code,{children:"electron-updater"})," 来完成应用的自动更新能力。"]}),"\n",(0,s.jsxs)(n.p,{children:["首先，需要配置一下 ",(0,s.jsx)(n.code,{children:"electron-builder"})," 的 ",(0,s.jsx)(n.code,{children:"publish"})," 和 ",(0,s.jsx)(n.code,{children:"releaseInfo"})," 字段，来记录发布更新地址和发布日志："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 更新服务器信息\npublish: [\n  {\n    provider: 'github',\n    owner: 'rubickCenter',\n    repo: 'rubick',\n  },\n],\n// 更新日志\nreleaseInfo: {\n  releaseName: 'normal', // normal 弹窗 / major 强制更新\n  releaseNotesFile: './release/releaseNotes.md',\n},\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里，",(0,s.jsx)(n.code,{children:"publish"})," 中使用的是基于 ",(0,s.jsx)(n.code,{children:"github"})," 提供给 ",(0,s.jsx)(n.code,{children:"release"})," 包。然后在我们执行打包构建，会在 ",(0,s.jsx)(n.code,{children:"build"})," 目录下生成一个 ",(0,s.jsx)(n.code,{children:"latest.yml"})," 文件，记录着此次更新的一些信息，大致如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",children:"# 第20章—通用篇：Electron应用更新\nversion: 版本号\npath: 文件名路径\nsha512: 文件的 sha512 值\nreleaseName: normal\nreleaseNotes: 发布日志\nreleaseDate: 发布时间\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后，在 Electron 主进程中引入 ",(0,s.jsx)(n.code,{children:"electron-updater"})," 模块："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const { autoUpdater } = require('electron-updater');\n"})}),"\n",(0,s.jsx)(n.p,{children:"在创建完主窗口后，添加以下代码来检查主窗口准备就绪后是否有可用的更新。如果有的话，它们将会自动下载："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"mainWindow.once('ready-to-show', () => {\n  autoUpdater.checkForUpdates();\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中 ",(0,s.jsx)(n.code,{children:"checkForUpdates"})," 方法执行时，应用会先请求 github 上的 ",(0,s.jsx)(n.code,{children:"latest.yml"})," 文件，得到文件里的内容后，再拿此文件中的版本号与当前版本号对比，如果此文件中的版本号比当前版本号新，则自动下载新版本。"]}),"\n",(0,s.jsx)(n.p,{children:"然后再添加以下事件监听器来处理更新事件："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let version;\nlet releaseNotes;\n// 默认会自动下载新版本\n// 如果不想自动下载，设置 autoUpdater.autoDownload = false\nautoUpdater.on('update-available', (info) => {\n  // 获取 版本号、发布日志\n  { version, releaseNotes } = info;\n  console.log('有新版本');\n});\n\n// 监听下载进度\nautoUpdater.on('download-progress', ({ percent }) => {\n  console.log('下载进度', percent);\n});\n\n// 下载完成\nautoUpdater.on('update-downloaded', () => {\n  console.log('下载完成');\n   dialog\n    .showMessageBox(mainWindow, {\n      title: '版本更新',\n      message: `发现新版本${version}，是否更新\\n\\n${releaseNotes}`,\n      type: 'info',\n      buttons: ['稍后提示', '立即更新'],\n    })\n    .then(({ response }) => {\n      console.log(response);\n      if (response === 1) {\n        autoUpdater.quitAndInstall();\n      }\n    });\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["通过订阅 ",(0,s.jsx)(n.code,{children:"download-progress"})," 事件，我们可以监听到下载的进度，一旦下载完成，我们将发送一个弹窗，告知用户发现新版本是否退出重新安装更新，用户手动进行确认更新，通过 ",(0,s.jsx)(n.code,{children:"autoUpdater.quitAndInstall()"})," 方法进行退出更新。"]}),"\n",(0,s.jsxs)(n.p,{children:["关于自动更新的完整代码见：",(0,s.jsx)(n.a,{href:"https://github.com/rubickCenter/rubick/blob/e2ea081d2553125790e4a05a746b583e27cc6ca5/src/main/common/versionHandler.ts",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/rubickCenter/rubick/blob/e2ea081d2553125790e4a05a746b583e27cc6ca5/src/main/common/versionHandler.ts"})]}),"\n",(0,s.jsxs)(n.p,{children:["以上，便是使用 ",(0,s.jsx)(n.code,{children:"electron-updater"})," 更新的全流程，但是需要注意的是如果你需要支持 macOS 上的自动更新，那么你还需要对应用程序进行代码签名和公正，然后再进行打包构建，这块内容参考 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7302990019642261567/section/7304842389166751754",target:"_blank",rel:"noopener noreferrer",children:"《通用篇：Electron 应用打包》"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本小节我们详细介绍了 Electron 常见的三种更新方式：手动更新、覆盖式更新、自动更新。"}),"\n",(0,s.jsx)(n.p,{children:"手动更新又称全量更新，是一种比较传统的更新方式，其优势是稳定、简单。缺点就是过程繁琐、慢、影响使用、更新率低。适用于低频更新、用户粘性高、作为各种升级技术的降级方案。"}),"\n",(0,s.jsxs)(n.p,{children:["覆盖式更新（增量更新）其优势就是更新速度快，但是实现比较复杂、稳定性差、写文件容易失败，比较适合 ",(0,s.jsx)(n.code,{children:"hotfix"})," 打补丁式的发布更新。"]}),"\n",(0,s.jsx)(n.p,{children:"自动更新比较稳定、快、而且对用户的打扰少，但是整体实现稍微复杂，一般适用于高频更新软件、体验要求高的场景。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let d=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC20%E7%AB%A0%E2%80%94%E9%80%9A%E7%94%A8%E7%AF%87%EF%BC%9AElectron%E5%BA%94%E7%94%A8%E6%9B%B4%E6%96%B0.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. 全量更新",id:"1-全量更新",depth:2},{text:"2. 文件覆盖式更新",id:"2-文件覆盖式更新",depth:2},{text:"2.1 使用 extraResources 字段",id:"21-使用-extraresources-字段",depth:3},{text:"2.2 使用 asar 字段",id:"22-使用-asar-字段",depth:3},{text:"3. 自动更新",id:"3-自动更新",depth:2},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);