"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["43936"],{969868:function(e,c,s){s.r(c),s.d(c,{default:()=>i});var d=s(552676),h=s(740453);function r(e){let c=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",img:"img",pre:"pre",ol:"ol",li:"li"},(0,h.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(c.h1,{id:"15高级-6代码已经-push-上去了才发现写错",children:["15高级 6：代码已经 push 上去了才发现写错？",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#15高级-6代码已经-push-上去了才发现写错",children:"#"})]}),"\n",(0,d.jsxs)(c.p,{children:["有的时候，代码 ",(0,d.jsx)(c.code,{children:"push"})," 到了中央仓库，才发现有个 ",(0,d.jsx)(c.code,{children:"commit"})," 写错了。这种问题的处理分两种情况："]}),"\n",(0,d.jsxs)(c.h2,{id:"1-出错的内容在你自己的-branch",children:["1. 出错的内容在你自己的 branch",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#1-出错的内容在你自己的-branch",children:"#"})]}),"\n",(0,d.jsxs)(c.p,{children:["假如是某个你自己独立开发的 ",(0,d.jsx)(c.code,{children:"branch"})," 出错了，不会影响到其他人，那没关系用前面几节讲的方法把写错的 ",(0,d.jsx)(c.code,{children:"commit"})," 修改或者删除掉，然后再 ",(0,d.jsx)(c.code,{children:"push"})," 上去就好了。不过……"]}),"\n",(0,d.jsx)(c.p,{children:(0,d.jsx)(c.img,{src:"https://user-gold-cdn.xitu.io/2017/11/22/15fe2638ac5c1dd0?w=676&h=162&f=jpeg&s=95234",alt:""})}),"\n",(0,d.jsxs)(c.p,{children:["由于你在本地对已有的 ",(0,d.jsx)(c.code,{children:"commit"})," 做了修改，这时你再 ",(0,d.jsx)(c.code,{children:"push"})," 就会失败，因为中央仓库包含本地没有的 ",(0,d.jsx)(c.code,{children:"commit"}),"s。但这个和前面讲过的情况不同，这次的冲突不是因为同事 ",(0,d.jsx)(c.code,{children:"push"})," 了新的提交，而是因为你刻意修改了一些内容，这个冲突是你预料到的，你本来就希望用本地的内容覆盖掉中央仓库的内容。那么这时就不要乖乖听话，按照提示去先 ",(0,d.jsx)(c.code,{children:"pull"})," 一下再 ",(0,d.jsx)(c.code,{children:"push"})," 了，而是要选择「强行」",(0,d.jsx)(c.code,{children:"push"}),"："]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-shell",children:"git push origin branch1 -f\n"})}),"\n",(0,d.jsxs)(c.p,{children:[(0,d.jsx)(c.code,{children:"-f"})," 是 ",(0,d.jsx)(c.code,{children:"--force"})," 的缩写，意为「忽略冲突，强制 ",(0,d.jsx)(c.code,{children:"push"}),"」。"]}),"\n",(0,d.jsx)(c.p,{children:(0,d.jsx)(c.img,{src:"https://user-gold-cdn.xitu.io/2017/11/22/15fe2638ab7b7e6d?w=507&h=154&f=jpeg&s=74359",alt:""})}),"\n",(0,d.jsxs)(c.p,{children:["这样，在本地修改了错误的 ",(0,d.jsx)(c.code,{children:"commit"}),"s，然后强制 ",(0,d.jsx)(c.code,{children:"push"})," 上去，问题就解决了。"]}),"\n",(0,d.jsxs)(c.h2,{id:"2-出错的内容已经合并到-master",children:["2. 出错的内容已经合并到 master",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#2-出错的内容已经合并到-master",children:"#"})]}),"\n",(0,d.jsxs)(c.p,{children:["这就不能用上面那招了。同事的工作都在 ",(0,d.jsx)(c.code,{children:"master"})," 上，你永远不知道你的一次强制 ",(0,d.jsx)(c.code,{children:"push"})," 会不会洗掉同事刚发上去的新提交。所以除非你是人员数量和行为都完全可控的超小团队，可以和同事做到无死角的完美沟通，不然一定别在 ",(0,d.jsx)(c.code,{children:"master"})," 上强制 ",(0,d.jsx)(c.code,{children:"push"}),"。"]}),"\n",(0,d.jsxs)(c.p,{children:["在这种时候，你只能退一步，选用另一种策略：增加一个新的提交，把之前提交的内容抹掉。例如之前你增加了一行代码，你希望撤销它，那么你就做一个删掉这行代码的提交；如果你删掉了一行代码，你希望撤销它，那么你就做一个把这行代码还原回来的提交。这种事做起来也不算麻烦，因为 Git 有一个对应的指令：",(0,d.jsx)(c.code,{children:"revert"}),"。"]}),"\n",(0,d.jsxs)(c.p,{children:["它的用法很简单，你希望撤销哪个 ",(0,d.jsx)(c.code,{children:"commit"}),"，就把它填在后面："]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-shell",children:"git revert HEAD^\n"})}),"\n",(0,d.jsxs)(c.p,{children:["上面这行代码就会增加一条新的 ",(0,d.jsx)(c.code,{children:"commit"}),"，它的内容和倒数第二个 ",(0,d.jsx)(c.code,{children:"commit"})," 是相反的，从而和倒数第二个 ",(0,d.jsx)(c.code,{children:"commit"})," 相互抵消，达到撤销的效果。"]}),"\n",(0,d.jsxs)(c.p,{children:["在 ",(0,d.jsx)(c.code,{children:"revert"})," 完成之后，把新的 ",(0,d.jsx)(c.code,{children:"commit"})," 再 ",(0,d.jsx)(c.code,{children:"push"})," 上去，这个 ",(0,d.jsx)(c.code,{children:"commit"})," 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 ",(0,d.jsx)(c.code,{children:"commit"})," ：一个原始 ",(0,d.jsx)(c.code,{children:"commit"})," ，一个对它的反转 ",(0,d.jsx)(c.code,{children:"commit"}),"。"]}),"\n",(0,d.jsxs)(c.h2,{id:"小结",children:["小结",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,d.jsxs)(c.p,{children:["这节的内容是讲当错误的 ",(0,d.jsx)(c.code,{children:"commit"})," 已经被 ",(0,d.jsx)(c.code,{children:"push"})," 上去时的解决方案。具体的方案有两类："]}),"\n",(0,d.jsxs)(c.ol,{children:["\n",(0,d.jsxs)(c.li,{children:["如果出错内容在私有 ",(0,d.jsx)(c.code,{children:"branch"}),"：在本地把内容修正后，强制 ",(0,d.jsx)(c.code,{children:"push"})," (",(0,d.jsx)(c.code,{children:"push -f"}),"）一次就可以解决；"]}),"\n",(0,d.jsxs)(c.li,{children:["如果出错内容在 ",(0,d.jsx)(c.code,{children:"master"}),"：不要强制 ",(0,d.jsx)(c.code,{children:"push"}),"，而要用 ",(0,d.jsx)(c.code,{children:"revert"})," 把写错的 ",(0,d.jsx)(c.code,{children:"commit"})," 撤销。"]}),"\n"]})]})}function n(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,h.ah)(),e.components);return c?(0,d.jsx)(c,{...e,children:(0,d.jsx)(r,{...e})}):r(e)}let i=n;n.__RSPRESS_PAGE_META={},n.__RSPRESS_PAGE_META["Git%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%2F15%E9%AB%98%E7%BA%A7%206%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%B7%B2%E7%BB%8F%20push%20%E4%B8%8A%E5%8E%BB%E4%BA%86%E6%89%8D%E5%8F%91%E7%8E%B0%E5%86%99%E9%94%99%EF%BC%9F.md"]={toc:[{text:"1. 出错的内容在你自己的 branch",id:"1-出错的内容在你自己的-branch",depth:2},{text:"2. 出错的内容已经合并到 master",id:"2-出错的内容已经合并到-master",depth:2},{text:"小结",id:"小结",depth:2}],title:"15高级 6：代码已经 push 上去了才发现写错？",headingTitle:"15高级 6：代码已经 push 上去了才发现写错？",frontmatter:{}}}}]);