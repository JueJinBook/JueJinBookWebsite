"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["78387"],{788522:function(n,e,r){r.r(e),r.d(e,{default:()=>h});var c=r(552676),d=r(740453);let a=r.p+"static/image/28d50bb3f7c14fbb874c88a1d83d40dc~tplv-k3u1fbpfcp-zoom-1.image.5e4b4450.png",i=r.p+"static/image/58720708a08f494a8dbcfa647884b6cc~tplv-k3u1fbpfcp-zoom-1.image.7c8c24dd.png",s=r.p+"static/image/b77c699e8dd646ff9d0a592e22dc1aec~tplv-k3u1fbpfcp-zoom-1.image.5535cd87.png";function t(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",img:"img",strong:"strong",h3:"h3",ol:"ol",li:"li"},(0,d.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"18-functor函子盒子模式构造函数组合链",children:["18 Functor（函子）：“盒子模式”构造函数组合链",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#18-functor函子盒子模式构造函数组合链",children:"#"})]}),"\n",(0,c.jsxs)(e.h2,{id:"js-functor-中的顶流array",children:["JS Functor 中的“顶流”——Array",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#js-functor-中的顶流array",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"按照上一节我们对 Functor 的定义，Array 其实也属于是 Functor，它也是一种实现了 map 方法的数据结构。"}),"\n",(0,c.jsx)(e.p,{children:"常见的 Array.prototype.map 调用如下："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const fruits = ['apple', 'orange', 'banana', 'papaya']   \n\nconst fruitsWithSugar = fruits.map((fruit)=> `Super Sweet ${fruit}`)\n"})}),"\n",(0,c.jsx)(e.p,{children:"这里我定义了一个 fruits 数组，数组这个数据结构就可以被看作是一个盒子。"}),"\n",(0,c.jsx)(e.p,{children:"就这个盒子来说，它盛放的数据是一套水果名称的集合。与此同时，它还实现了 map 方法。整体的结构如下图："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"通过调用 map 方法，我们可以将盒子盛放的源数据映射为一套新的数据，并且新的数据也盛放在 Array 盒子里。"}),"\n",(0,c.jsx)(e.p,{children:"整个过程如下图，这同样是一个藉由 map 方法创造新“盒子”的过程。"}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(e.h2,{id:"box又名-identity-functor",children:["“Box”又名 Identity Functor",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#box又名-identity-functor",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"在本册中，我们认识的第一个 Functor 其实是上一节中实现的 Box（代码如下），而不是 Array。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const Box = x => ({\n  map: f => Box(f(x)),\n  valueOf: () => x\n})\n"})}),"\n",(0,c.jsx)(e.p,{children:"这个 Box 其实是一种最简单的 Functor 。在这个 Functor 的 map 里，除了“执行回调f”之外，没有任何其他逻辑。"}),"\n",(0,c.jsx)(e.p,{children:"它的存在有点像60年代登场的初代奥特曼，外形很朴素、招式很简单，但是具备了一个奥特曼应该有的所有要素。"}),"\n",(0,c.jsx)(e.p,{children:"后续出现的中生代。新生代奥特曼等等，都要以它为蓝本制作——它本身就可以被视作是一种“标准”。"}),"\n",(0,c.jsx)(e.p,{children:"也正因为如此，我把 Box 放在了这个系列的开篇——对于刚入门范畴论设计模式的同学来说，它是一个绝佳的起手式。"}),"\n",(0,c.jsx)(e.p,{children:"这个 Box 还有一个学名，叫做 “Identity Functor”。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const Identity = x => ({\n  map: f => Identity(f(x)),\n  valueOf: () => x\n})\n"})}),"\n",(0,c.jsx)(e.p,{children:"为了标识 Functor 的类别，我们可以给它补充一个 inspect 函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const Identity = x => ({\n  map: f => Identity(f(x)),\n  valueOf: () => x,\n  inspect: () => `Identity {${x}}`\n})\n"})}),"\n",(0,c.jsxs)(e.p,{children:["没错，Functor 世界里，也是有“类别”一说的。",(0,c.jsx)(e.strong,{children:"同一类 Functor，往往具有相同的 map 行为"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"通过往 map 行为里“加料”，我们就可以制作出不同的 Functor。"}),"\n",(0,c.jsx)(e.p,{children:"在本节，除了 Identity Functor 以外，我们还将探讨 Maybe Functor。"}),"\n",(0,c.jsxs)(e.h2,{id:"maybe-functor识别空数据",children:["Maybe Functor：识别空数据",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#maybe-functor识别空数据",children:"#"})]}),"\n",(0,c.jsxs)(e.h3,{id:"maybe-functor-如何编码",children:["Maybe Functor 如何编码",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#maybe-functor-如何编码",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"Maybe Functor 在 Identity Functor 的基础上，增加了对空数据的校验。"}),"\n",(0,c.jsx)(e.p,{children:"在细说 Maybe Functor 之前，我们先来看它的代码："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const isEmpty = x => x === undefined || x === null  \n\nconst Maybe = x => ({\n  map: f => isEmpty(x) ? Maybe(null) : Maybe(f(x)),  \n  valueOf: () => x,  \n  inspect: () => `Maybe {${x}}`\n})\n"})}),"\n",(0,c.jsx)(e.p,{children:"我们看到，Maybe Functor 在执行回调函数 f 之前，会先执行校验函数 isEmpty。"}),"\n",(0,c.jsx)(e.p,{children:"如果入参 x 为空（undefined 或者 null），那么 isEmpty 就会返回 true，接下来 map 方法就不会再执行 f 函数的，而是直接返回一个空的 Maybe 盒子。"}),"\n",(0,c.jsx)(e.p,{children:"对于这个空的 Maybe 盒子来说，既然它盛放的数据是 null，那么无论我以什么样的姿势调用它的 map 方法，也都只能得到一个新的 Maybe(null) 而已。"}),"\n",(0,c.jsxs)(e.h3,{id:"maybe-functor-是如何工作的",children:["Maybe Functor 是如何工作的",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#maybe-functor-是如何工作的",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"举个例子，大家看下面这个 Maybe 调用链："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function add4(x) {\n  return x + 4\n}  \n\nfunction add8(x) {\n  x + 8\n}\n\nfunction toString(x) {\n  return x.toString()\n}  \n\nfunction addX(x) {\n  return x + 'X'\n}  \n\nfunction add10(x) {\n  return x + '10'\n}\n\nconst res = Maybe(10)\n              .map(add4)\n              .map(add8)\n              .map(toString)\n              .map(addX)  \n              .inspect()\n\n// 输出 Maybe {null}\nconsole.log(res)\n"})}),"\n",(0,c.jsx)(e.p,{children:"在这个调用链中，我分别组合了以下函数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"[add4, add8, toString, addX]\n"})}),"\n",(0,c.jsx)(e.p,{children:"其中 add8 这个函数是有问题的，我在定义它的时候，手滑了，没有写 return。"}),"\n",(0,c.jsxs)(e.p,{children:["这就会导致 add8 在任何情况下都会输出 ",(0,c.jsx)(e.code,{children:"undefined"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["也就是说，当执行到 map(add8) 这一行的时候，",(0,c.jsx)(e.code,{children:"Maybe(null)"})," 已经出现了。"]}),"\n",(0,c.jsxs)(e.p,{children:["而 ",(0,c.jsx)(e.code,{children:"Maybe(null)"}),"相当于是一个“终结者”，只要它一出现，就掐灭了后续所有 map 调用的可能性——这些 map 都只会返回 ",(0,c.jsx)(e.code,{children:"Maybe(null)"}),"而已。"]}),"\n",(0,c.jsxs)(e.h3,{id:"为什么我们需要-maybe-functor",children:["为什么我们需要 Maybe Functor",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么我们需要-maybe-functor",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"试想，如果我们选择的盒子不是 Maybe Functor，而是 Identity Functor，彼时的调用链将会是一个什么样的光景呢？"}),"\n",(0,c.jsx)(e.p,{children:"这里我以身试法，让控制台来告诉大家答案："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"没错，报错是必然的。因为 add8 返回的 undefined 畅通无阻地走进了 toString 的逻辑里，toString 将会尝试去调用 undefined 上的 toString 方法，这显然是违法的。"}),"\n",(0,c.jsx)(e.p,{children:"在 JS 里，一旦 throw Error，就意味着整个程序 crash 了。除了当前的函数调用链被终止外，程序后续的其它逻辑也无法再运行了。"}),"\n",(0,c.jsx)(e.p,{children:"而 Maybe Functor 则能够把这个错误控制在组合链的内部。"}),"\n",(0,c.jsx)(e.p,{children:"这就好像我们开车从杭州出发，走高速去上海团建。"}),"\n",(0,c.jsx)(e.p,{children:"赶上饭点，又不想下高速，就直接在车里吃点KFC疯狂星期四解决了。"}),"\n",(0,c.jsx)(e.p,{children:"如果我把吃剩下的汉堡、饮料罐子等东西直接丢出车窗，等待我的将是交警的罚单，相当于我把“异常”丢到外面（高速上）去了，这是对外部环境的污染，是一种副作用。"}),"\n",(0,c.jsx)(e.p,{children:"万一我的垃圾不小心砸中了哪个司机，可能就引发连环车祸了，这条高速也就瘫痪了。"}),"\n",(0,c.jsx)(e.p,{children:"更好的做法，是我把垃圾揣到怀里，等下了高速后，找个垃圾桶“输出”一下。"}),"\n",(0,c.jsx)(e.p,{children:"Maybe 就仿佛是交警叔叔那无形的手，它能够控制乘客们把垃圾保留在车厢内部，不到行车终点，绝不乱丢垃圾。"}),"\n",(0,c.jsxs)(e.h2,{id:"拓展functor-的生存法则",children:["拓展：Functor 的“生存法则”",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#拓展functor-的生存法则",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"最后， 我想补充一些 Functor 的数学背景，也即“生存法则”。"}),"\n",(0,c.jsx)(e.p,{children:"一个合法的 Functor 需要满足以下条件："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"恒等性（Identity）"}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"可组合性（Composition）"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"恒等性",children:["恒等性",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#恒等性",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"所谓“恒等性”，是说如果我们传递了一个恒等函数（Identity Function ）到盒子的 map 方法里，map 方法创建出的新盒子应该和原来的盒子等价。"}),"\n",(0,c.jsx)(e.p,{children:"“恒等函数”长这样："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const identity = x => x\n"})}),"\n",(0,c.jsx)(e.p,{children:"以 Array 为例，我们试着在 Array 的 map 方法里传入 identity："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const originArr = [1, 2, 3]  \n\nconst identityArr = originArr.map(x=>x)  \n\n// 输出 [1, 2, 3]  \nconsole.log(identityArr)\n"})}),"\n",(0,c.jsx)(e.p,{children:"可见，将恒等函数传入 map 后，最终的映射结果 identityArr 和源数据 originArr 是等价的。"}),"\n",(0,c.jsx)(e.p,{children:"感兴趣的同学也可以在 Identity Functor 上验证一下这个规则，结果也是没有悬念的，这里我就不多赘述了。我们继续解读这条规则本身。"}),"\n",(0,c.jsx)(e.p,{children:"这条规则的目的有二："}),"\n",(0,c.jsx)(e.p,{children:"其一，是为了确保你的 map 方法具备“创造一个新的盒子（Functor）”的能力。"}),"\n",(0,c.jsx)(e.p,{children:"决定一个接口是否“配”做 map 的并不是它的名字，而是它的行为。"}),"\n",(0,c.jsx)(e.p,{children:"（否则，岂不是随便写个函数，只要给它命名叫 map，它所在的容器就叫 Functor 了？ ）"}),"\n",(0,c.jsxs)(e.p,{children:["而 map 接口对应的行为，就应该是",(0,c.jsx)(e.strong,{children:"映射"}),"——把数据从一个盒子映射到另一个盒子里去。"]}),"\n",(0,c.jsx)(e.p,{children:"其二，是为了确保你的 map 方法足够“干净”。"}),"\n",(0,c.jsx)(e.p,{children:"说到底，map 方法只是一个行为框架，尽管不同的 Functor 会往 map 方法里加不同的料，但这些“料”都不能改变其“行为框架”的本质。"}),"\n",(0,c.jsx)(e.p,{children:"所谓“行为框架”，就意味着 map 方法的主要作用是串联不同的行为（函数），而不是编辑这些行为。"}),"\n",(0,c.jsx)(e.p,{children:"恒等性可以确保 map 方法本身是没有“小动作”的。"}),"\n",(0,c.jsxs)(e.h3,{id:"可组合性",children:["可组合性",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#可组合性",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"可组合性可以直接用一行代码来解释："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"Functor.map(x => f(g(x))) = Functor.map(g).map(f)\n"})}),"\n",(0,c.jsx)(e.p,{children:"这个就比较直观了，它要求 Functor 能够将嵌套的函数拆解为平行的链式调用。"}),"\n",(0,c.jsx)(e.p,{children:"这一点我们其实已经验证麻了，要不咱怎么说“盒子模式”是函数组合的另一种解法呢？"}),"\n",(0,c.jsxs)(e.h2,{id:"functor黑盒般强大的组合姿势",children:["Functor，黑盒般强大的组合姿势",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#functor黑盒般强大的组合姿势",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"初识盒子模式的时候，咱就说过，这神秘兮兮的“范畴论”，无非也只是我们解决函数组合问题的一个工具而已。"}),"\n",(0,c.jsxs)(e.p,{children:["当时，我还问过大家另一个问题：",(0,c.jsx)(e.strong,{children:"这个 Functor 到底能干啥？难道只是 compose 的另一种姿势而已吗？"})]}),"\n",(0,c.jsx)(e.p,{children:"眼见为实，通过本节的学习，相信大家都能切身感受到：“盒子模式”的存在，绝不仅仅是换个姿势实现 compose/pipe 这么简单。"}),"\n",(0,c.jsx)(e.p,{children:"通过往盒子里“加料”，我们可以在实现组合的同时，内化掉类似空态识别这样的逻辑。"}),"\n",(0,c.jsx)(e.p,{children:"从“面子”上看，Functor 为我们提供了更加强大的组合能力。"}),"\n",(0,c.jsxs)(e.p,{children:["从“里子”上来说，",(0,c.jsx)(e.strong,{children:"Functor 在实现函数组合的基础上，确保了副作用的可控"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"而这，也正是“盒子模式”的价值所在。"}),"\n",(0,c.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(t,{...n})}):t(n)}let h=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F18%20Functor%EF%BC%88%E5%87%BD%E5%AD%90%EF%BC%89%EF%BC%9A%E2%80%9C%E7%9B%92%E5%AD%90%E6%A8%A1%E5%BC%8F%E2%80%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88%E9%93%BE.md"]={toc:[{text:"JS Functor 中的“顶流”——Array",id:"js-functor-中的顶流array",depth:2},{text:"“Box”又名 Identity Functor",id:"box又名-identity-functor",depth:2},{text:"Maybe Functor：识别空数据",id:"maybe-functor识别空数据",depth:2},{text:"Maybe Functor 如何编码",id:"maybe-functor-如何编码",depth:3},{text:"Maybe Functor 是如何工作的",id:"maybe-functor-是如何工作的",depth:3},{text:"为什么我们需要 Maybe Functor",id:"为什么我们需要-maybe-functor",depth:3},{text:"拓展：Functor 的“生存法则”",id:"拓展functor-的生存法则",depth:2},{text:"恒等性",id:"恒等性",depth:3},{text:"可组合性",id:"可组合性",depth:3},{text:"Functor，黑盒般强大的组合姿势",id:"functor黑盒般强大的组合姿势",depth:2}],title:"18 Functor（函子）：“盒子模式”构造函数组合链",headingTitle:"18 Functor（函子）：“盒子模式”构造函数组合链",frontmatter:{}}}}]);