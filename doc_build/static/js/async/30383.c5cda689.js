"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["30383"],{515552:function(e,n,s){s.r(n),s.d(n,{default:()=>B});var r=s(552676),c=s(740453);let d=s.p+"static/image/b3be159fdbb3615a4e7cfa7e5a07bf35.17d9edf1.webp",i=s.p+"static/image/fd221e90be8704181e08b12e20f4267a.d9dbd185.webp",a=s.p+"static/image/7a67ad7f6921ad89aeea9d5ad2ced6e5.53f84c9c.webp",l=s.p+"static/image/c4e14462200a267074293b5b314997b0.f1dcd1e3.webp",t=s.p+"static/image/ff99315f1846d811e1072d8be1075e85.9e86d051.webp",h=s.p+"static/image/debc8219a5ff27430858ec6e97fee932.138bb6c8.webp",p=s.p+"static/image/cac1c936fc31879da86d97851d520511.6cf85bf0.webp",x=s.p+"static/image/f3be7e3ad6de36bd17c2b31aebf4e9e1.906482ea.webp",j=s.p+"static/image/acd243541e3c21b2446a9b4dbbf1ceca.fc154f07.webp",g=s.p+"static/image/ad0fed0b9f16b70be27324bee28f372c.4ca08025.webp",A=s.p+"static/image/cdc6f6c6f6db7bf4cf63af4e33fd5b8a.5abea65b.webp",b=s.p+"static/image/e50a32c228314b2dbd829fcfcc2482de.bf6bba98.webp",o=s.p+"static/image/38d0270352da89114360582fdac7c811.a1227011.webp",m=s.p+"static/image/dd7f9461cb874a3c08aa7c8bb0722202.a680a136.webp",f=s.p+"static/image/43a0a2aedbedec9064091bc311980b7d.968d71b2.webp",u=s.p+"static/image/111e0eabdc7eabb2a40ed4e726a28e8f.11cda6d0.webp",w=s.p+"static/image/ce5ceadbc22b355f07ef04969614d54c.3b3baa51.webp",E=s.p+"static/image/cd46f3b011b6dcbb1807250b48643495.a2e132b9.webp";function y(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",strong:"strong",h3:"h3",ul:"ul",li:"li"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"21原理篇一些特殊情况的说明",children:["21.原理篇：一些特殊情况的说明",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21原理篇一些特殊情况的说明",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"学完了各种套路，做了大量练习之后，各种类型编程逻辑我们都能写了。但是依然会遇到一些难以解释的、令人困惑的点。"}),"\n",(0,r.jsx)(n.p,{children:"这一节就来集中讲一下这些令人困惑的地方的原理。"}),"\n",(0,r.jsxs)(n.h2,{id:"isequal-为什么要这样写",children:["isEqual 为什么要这样写",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#isequal-为什么要这样写",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面讲过 isEqual 要这样写："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type IsEqual<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2)\n    ? true : false;\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样才能正确的判断 any："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?ts=4.5.0-beta#code/C4TwDgpgBAkgzgUQI4FcCGAbAPAQQDRQBCAfFALxQAUWAKsZQJTmk1QQAewEAdgCZxQcUAPxQAjFABcUAExMOXPgOp1GzKKwU9+REeKmyGAKCim9wAE4po0gGaY4EANxHXoSLESpMAJQgCKeGR0bEtrAjRuEGInIA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,r.jsx)(n.p,{children:"这是为什么呢？"}),"\n",(0,r.jsx)(n.p,{children:"其实就是源码里的特殊处理。"}),"\n",(0,r.jsx)(n.p,{children:"xx extends yy 这里的判断逻辑在 checkTypeRelatedTo 这个函数里，里面定义了各种类型之间如何判断相关性。"}),"\n",(0,r.jsx)(n.p,{children:"其中就有两个都是条件类型的情况的处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如图，source 和 target 都是条件类型（Conditional Type）的时候会走到这里，然后有这样一段注释："}),"\n",(0,r.jsxs)(n.p,{children:["如果是两个条件类型 ",(0,r.jsx)(n.code,{children:"T1 extends U1 ? X1 : Y1"})," 和 ",(0,r.jsx)(n.code,{children:"T2 extends U2 ? X2 : Y2"})," 相关的话，那 T1 和 T2 相关、X1 和 X2 相关、Y1 和 Y2 相关，而 U1 和 U2 相等。"]}),"\n",(0,r.jsx)(n.p,{children:"注意，这里 U1 和 U2 是相等的，不是相关。"}),"\n",(0,r.jsx)(n.p,{children:"如果是判断相关性的话，任意类型 extends any 都是 true，但通过构造两个条件类型判断相关性，就可以利用 extends 右边部分相等的性质来判断两个类型是否 equal。"}),"\n",(0,r.jsx)(n.p,{children:"比如 any 和 1，判断相关性的话，肯定是 true，但是判断相等的话，就是 false 了。不过 TS 没有暴露判断相等的方式，只有 extends 这个来判断类型相关性的语法。"}),"\n",(0,r.jsxs)(n.p,{children:["这就是为什么我们要这样判断两个类型相等，就是利用了",(0,r.jsx)(n.strong,{children:"两个条件类型判断相关性的时候会判断右边部分是否相等"}),"的这个性质，算是一种 hack 的写法。答案要从源码找。"]}),"\n",(0,r.jsxs)(n.h2,{id:"为什么我调整了下-extends-左右类型的位置就报错了",children:["为什么我调整了下 extends 左右类型的位置，就报错了",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么我调整了下-extends-左右类型的位置就报错了",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面我们实现过加法，是这样写的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"通过递归构造长度为 Num1 和 Num2 的元组，然后合并成一个新的元组再取长度的方式来实现的。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAQgrgSwDYBMCCAnDBDEAeAKCmKgBkIA7Ac2AAsoIAPYSlAZygrgFsAjCDABooREgFEk0ALxQ4FANYUA9gHcKw0cUwYGzVhzmLVFANoBdKDPMEAfJajaTAcknU6Ti0xYV2ZSjXpNEmIAfgcsEWDggC5YRFRtXDxyN1phCQhhEwA6XO10yTMbAG4CAlBIBxQUPAA5HgBGXW9fLj4BYXruACZm-U4efgw7GSCc3PhkdCwkroabQVzsyYSZ-C7umzNnVwCPUrKK6DRqgCUINjgkYHsTmoBmbuFugFYSoA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,r.jsx)(n.p,{children:"有的同学发现把 Length 和 Arr['length'] 对调之后就报错了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"报的错误是无限递归了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAQgrgSwDYBMCCAnDBDEAeAKCmKgBkIA7Ac2AAsoIAPYSlAZygrgFsAjCDABooREgFEk0ALxQ4FANYUA9gHcKw0cUwYGzVhzmLVFANoBdKDPMEAfJbKUa9Jiwrso2kwHJJ1Ol7NNEmIAfg8sEWDggC5YRFRtXDxyP1phCQhhEwA6XO10yTMbAG4CAlBIDxQUPAA5HgBGXVd3Lj4BYXruACZm-U4efgw7GSCc3PhkdCwkroabQVzsyYSZ-C7umzNvXycA0rKK6DRqgCUINjgkYHsTmoBmbuFugFYSoA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,r.jsx)(n.p,{children:"这是为什么呢，逻辑看起来没啥错误呀？"}),"\n",(0,r.jsx)(n.p,{children:"大家可以先看下这个案例："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"声明一个泛型函数，取它的参数类型，结果是 unknown。"}),"\n",(0,r.jsx)(n.p,{children:"有的同学说，这很正常啊，高级类型就像函数调用一样，现在还没调用，没传入参数呢，当然是 unknown。"}),"\n",(0,r.jsxs)(n.p,{children:["对，",(0,r.jsx)(n.strong,{children:"类型编程中如果需要取类型参数做一些计算的时候，默认推导出的是约束的类型，如果没有类型约束，那就是 unknown"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"上面那个类型把 T 约束为 number，推导出的就是 number："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"Add 那个类型把约束写死为具体的数字的时候，就会发现不报错了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAQgrgSwDYBMCCAnDBDEAeAKCmKgBkIA7Ac2AAsoIAPYSlAZygrgFsAjCDABooREgFEk0ALxQ4FANYUA9gHcKw0cUwYGzVhzmLVFANoBdKDPMEAfJbKUa9Jiwrso2kwHJJ1Ol7NNEmIAfg8sEWDggC5YRFRtXDxyP1phCQhhEwA6XO10yTMbAG4CAlBIDxQUPAA5HgBGXVd3AGYAJmF67nbm-Sh2gFY7GSCc3PhkdCwk7oabQVzsyYSZ-G72mzNvXycA0vLwaDRqgCUINjgkYHsTmo7hIZKCIA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,r.jsx)(n.p,{children:"所以上面 Add 那个类型里取 Num1 和 Num2 传入 BuildArray 做计算的话，其实传入的是 number："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"number extends 某个具体的数字自然永远不成立，永远是 false，所以就无限递归了。反过来写就不会有这个问题。"}),"\n",(0,r.jsxs)(n.h2,{id:"几个条件类型的特殊情况",children:["几个条件类型的特殊情况",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#几个条件类型的特殊情况",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"有这样几个条件类型，大家先试着猜下 res 都是啥："}),"\n",(0,r.jsx)(n.p,{children:"第一个："}),"\n",(0,r.jsx)(n.p,{children:"传入的类型参数为联合类型 1 | 'a'，问 res 是啥"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Test<T> = T extends number ? 1 : 2;\n\ntype res = Test<1 | 'a'>;\n"})}),"\n",(0,r.jsx)(n.p,{children:"第二个："}),"\n",(0,r.jsx)(n.p,{children:"传入的类型参数为 boolean，问 res 是啥"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Test<T> = T extends true ? 1 : 2;\n\ntype res = Test<boolean>;\n"})}),"\n",(0,r.jsx)(n.p,{children:"第三个："}),"\n",(0,r.jsx)(n.p,{children:"传入的类型参数为 any，问 res 是啥"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Test<T> = T extends true ? 1 : 2;\n\ntype res = Test<any>;\n"})}),"\n",(0,r.jsx)(n.p,{children:"第四个："}),"\n",(0,r.jsx)(n.p,{children:"传入的类型参数为 never，问 res 是啥"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"type Test<T> = T extends true ? 1 : 2;\n\ntype res = Test<never>;\n"})}),"\n",(0,r.jsx)(n.p,{children:"先记一下自己的答案，接下来我公布正确答案，大家看下猜对了几个。"}),"\n",(0,r.jsxs)(n.h3,{id:"答案",children:["答案",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#答案",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"第一个类型 res 是 1 | 2"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"再来看第二个类型，res 也是 1 | 2"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"接下来是第三个类型，res 也是 1 | 2"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"最后是第四个类型，res 是 never"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"不管答对了几个都没关系，关键是要知道它的原因，接下来我解释下："}),"\n",(0,r.jsxs)(n.h3,{id:"原因",children:["原因",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原因",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"第一个就是分布式条件类型的特性，联合类型作为类型参数出现在条件类型左边的时候，会把每个类型单独传入做计算，把结果合并成联合类型。这个我们上节还看过源码。"}),"\n",(0,r.jsx)(n.p,{children:"第二个是因为 boolean 也是联合类型，是 true | false，所以也会触发分布式条件类型。这个可以从源码的注释中找到说明，感兴趣也可以调试下源码，判断下 flags。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"第三个是条件类型中 any 的特殊处理，如果左边是 any，则会返回 trueType 和 falseType 的联合类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"第四个其实严格来说也是分布式条件类型的一种情况，ts 处理分布式条件类型的时候对 Union 和 Never 都做了特殊处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但是后面走的分支不一样："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，如果是 never，那就直接返回了。"}),"\n",(0,r.jsx)(n.p,{children:"所以当条件类型左边是 never 的时候，就会直接返回 never。"}),"\n",(0,r.jsx)(n.p,{children:"严格来说分布式条件类型是包含 Union 和 Never 两种情况的，只不过 never 的情况比较特殊，可以单独摘出来讲，平时我们谈到分布式条件类型（distributive conditional type）就是指联合类型 Union 的情况。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这一节我们集中讲了一些 ts 里令人困惑的点："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"判断相等是根据“两个条件类型如果相关，那么 extendsType 部分是相等的”这个特性。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"类型参数默认推导出的是类型约束的类型。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"条件类型中，联合类型、any、never、boolean 都比较特殊："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"联合类型有分布式条件类型的特性，会分发传入"}),"\n",(0,r.jsx)(n.li,{children:"boolean 也是联合类型"}),"\n",(0,r.jsx)(n.li,{children:"any 会直接返回 trueType 和 falseType 的联合类型"}),"\n",(0,r.jsx)(n.li,{children:"never 会直接返回 never，严格来说这个也是分布式条件类型的一种情况"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"这节从源码角度理清了一些情况的原理，如果大家还有一些困惑的点的话可以告诉我，我再补充进来。"})]})}function T(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}let B=T;T.__RSPRESS_PAGE_META={},T.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F21.%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%9A%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%9A%84%E8%AF%B4%E6%98%8E.md"]={toc:[{text:"isEqual 为什么要这样写",id:"isequal-为什么要这样写",depth:2},{text:"为什么我调整了下 extends 左右类型的位置，就报错了",id:"为什么我调整了下-extends-左右类型的位置就报错了",depth:2},{text:"几个条件类型的特殊情况",id:"几个条件类型的特殊情况",depth:2},{text:"答案",id:"答案",depth:3},{text:"原因",id:"原因",depth:3},{text:"总结",id:"总结",depth:2}],title:"21.原理篇：一些特殊情况的说明",headingTitle:"21.原理篇：一些特殊情况的说明",frontmatter:{}}}}]);