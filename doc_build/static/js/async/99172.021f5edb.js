"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["99172"],{985429:function(e,n,r){r.r(n),r.d(n,{default:()=>f});var i=r(552676),s=r(740453);let l=r.p+"static/image/bc7400090d7d952983febeb1b3fefb8d.4b6e051c.webp",c=r.p+"static/image/ae7b75f62025dfcac5bc4d864fd6f0ba.edd4d76a.webp",d=r.p+"static/image/491d9bd657ebc80d93aeb9527c6a0a83.8fa5aa72.webp",o=r.p+"static/image/1e84491a92238796915ebf1ee27c25ab.f9653e53.webp",a=r.p+"static/image/066d7873efd09d6043190522525293e5.bfabfee0.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",img:"img",ul:"ul",li:"li",h3:"h3",pre:"pre",blockquote:"blockquote",h4:"h4"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"5初级入门-----绘制渐变三角形深入理解缓冲区",children:["5.初级入门 --- 绘制渐变三角形：深入理解缓冲区",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5初级入门-----绘制渐变三角形深入理解缓冲区",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["上节带领大家学习了基本三角形图元的绘制过程，以及如何使用",(0,i.jsx)(n.code,{children:"缓冲区"}),"向着色器传递多个数据，但上节只演示了往着色器传递",(0,i.jsx)(n.code,{children:"坐标"}),"这一种数据，本节通过绘制渐变三角形，讲解一下如何通过缓冲区向着色器传递多种数据。"]}),"\n",(0,i.jsxs)(n.h2,{id:"目标",children:["目标",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#目标",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["本节通过一个鼠标每点击三次便会绘制一个渐变三角形的示例，带大家深入理解缓冲区的用法，最终效果如下图所示：\n",(0,i.jsx)("img",{src:c,alt:""})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"http://ifanqi.top/webgl/pages/lesson4.html",target:"_blank",rel:"noopener noreferrer",children:"演示地址"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/lucefer/webgl/blob/master/pages/lesson4.html",target:"_blank",rel:"noopener noreferrer",children:"源码地址"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"通过本节学习，你将会掌握如下内容："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["顶点数据在 ",(0,i.jsx)(n.code,{children:"buffer"})," 中的排布方式。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["切换 ",(0,i.jsx)(n.code,{children:"buffer"})," 时，",(0,i.jsx)(n.code,{children:"bindBuffer"})," 的重要性。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["使用多个 ",(0,i.jsx)(n.code,{children:"buffer"})," 读取多种顶点数据。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["使用单个 ",(0,i.jsx)(n.code,{children:"buffer"})," 读取多种顶点数据。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"如何实现渐变效果。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"渐变三角形",children:["渐变三角形",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#渐变三角形",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["上节我们实现的是单色三角形，通过在片元着色器中定义一个 ",(0,i.jsx)(n.code,{children:"uniform"})," 变量，接收 JavaScript 传递过去的颜色值来实现。那渐变三角形的处理与单色三角形有何不同呢？"]}),"\n",(0,i.jsxs)(n.p,{children:["渐变三角形颜色不单一，在顶点与顶点之间进行颜色的渐变过渡，这就要求我们的顶点信息除了包含",(0,i.jsx)(n.code,{children:"坐标"}),"，还要包含",(0,i.jsx)(n.code,{children:"颜色"}),"。这样在顶点着色器之后，GPU 根据每个顶点的颜色对顶点与顶点之间的颜色进行插值，自动填补顶点之间像素的颜色，于是形成了渐变三角形。"]}),"\n",(0,i.jsxs)(n.p,{children:["那既然我们需要为每个顶点传递坐标信息和颜色信息，因此需要在顶点着色器中额外增加一个 ",(0,i.jsx)(n.code,{children:"attribute"})," 变量",(0,i.jsx)(n.code,{children:"a_Color"}),"，用来接收顶点的颜色，同时还需要在顶点着色器和片元着色器中定义一个 varying 类型的变量",(0,i.jsx)(n.code,{children:"v_Color"}),"，用来传递顶点颜色信息。"]}),"\n",(0,i.jsxs)(n.h3,{id:"着色器",children:["着色器",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#着色器",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"依然从顶点着色器开始，顶点着色器新增一个 attribute 变量，用来接收顶点颜色。"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"    //设置浮点数精度为中等精度。\n    precision mediump float;\n    //接收顶点坐标 (x, y)\n    attribute vec2 a_Position;\n    //接收浏览器窗口尺寸(width, height)\n    attribute vec2 a_Screen_Size;\n    //接收 JavaScript 传递的顶点颜色\n    attribute vec4 a_Color;\n    //传往片元着色器的颜色。\n    varying vec4 v_Color;\n    void main(){\n      vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0;\n      position = position * vec2(1.0,-1.0);\n      gl_Position = vec4(position, 0, 1);\n      v_Color = a_Color;\n    }\n\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"片元着色器"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["片元着色器新增一个 varying 变量 ",(0,i.jsx)(n.code,{children:"v_Color"}),"，用来接收插值后的颜色。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"    //设置浮点数精度为中等。\n    precision mediump float;\n    //接收 JavaScript 传过来的颜色值（rgba）。\n    varying vec4 v_Color;\n    void main(){\n      vec4 color = v_Color / vec4(255, 255, 255, 1);\n      gl_FragColor = color;\n   }\n"})}),"\n",(0,i.jsx)(n.p,{children:"我们的着色器部分还是和之前一样简单，只是在顶点着色器中增加了顶点颜色这一变量。"}),"\n",(0,i.jsx)(n.p,{children:"接下来我们用 JavaScript 向着色器传递数据。"}),"\n",(0,i.jsxs)(n.h3,{id:"javascript-部分",children:["JavaScript 部分",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-部分",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"用缓冲区向着色器传递数据有两种方式："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"利用一个缓冲区传递多种数据。"}),"\n",(0,i.jsx)(n.li,{children:"另一种是利用多个缓冲区传递多个数据。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["上节绘制三角形的时候我们给顶点着色器传递的只是坐标信息，并且只用了一个 ",(0,i.jsx)(n.code,{children:"buffer"}),"，本节示例，我们除了传递顶点的坐标数据，还要传递顶点颜色。\n按照正常思路，我们可以创建两个 ",(0,i.jsx)(n.code,{children:"buffer"}),"，其中一个 ",(0,i.jsx)(n.code,{children:"buffer"})," 传递坐标，另外一个 ",(0,i.jsx)(n.code,{children:"buffer"})," 传递颜色。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["创建两个 ",(0,i.jsx)(n.code,{children:"buffer"}),"，将 ",(0,i.jsx)(n.code,{children:"a_Position"})," 和 ",(0,i.jsx)(n.code,{children:"positionBuffer"})," 绑定，",(0,i.jsx)(n.code,{children:"a_Color"})," 和 ",(0,i.jsx)(n.code,{children:"colorBuffer"})," 绑定，然后设置各自读取 ",(0,i.jsx)(n.code,{children:"buffer"})," 的方式。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["请谨记：程序中如果有多个 ",(0,i.jsx)(n.code,{children:"buffer"})," 的时候，在切换 ",(0,i.jsx)(n.code,{children:"buffer"})," 进行操作时，一定要通过调用 ",(0,i.jsx)(n.code,{children:"gl.bindBuffer"})," 将要操作的 ",(0,i.jsx)(n.code,{children:"buffer"})," 绑定到 ",(0,i.jsx)(n.code,{children:"gl.ARRAY_BUFFER"})," 上，这样才能正确地操作 ",(0,i.jsx)(n.code,{children:"buffer"})," 。您可以将 ",(0,i.jsx)(n.code,{children:"bindBuffer"})," 理解为一个状态机，",(0,i.jsx)(n.code,{children:"bindBuffer"})," 之后的对 ",(0,i.jsx)(n.code,{children:"buffer"})," 的一些操作，都是基于最近一次绑定的 ",(0,i.jsx)(n.code,{children:"buffer"})," 来进行的。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["以下 ",(0,i.jsx)(n.code,{children:"buffer"})," 的操作需要在绑定 ",(0,i.jsx)(n.code,{children:"buffer"})," 之后进行："]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"gl.bufferData：传递数据。"}),"\n",(0,i.jsx)(n.li,{children:"gl.vertexAttribPointer：设置属性读取 buffer 的方式。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"方式一多个-buffer-传递",children:["方式一：多个 buffer 传递",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方式一多个-buffer-传递",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/lucefer/webgl/blob/master/pages/lesson3.html",target:"_blank",rel:"noopener noreferrer",children:"示例代码"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"http://ifanqi.top/webgl/pages/lesson3.html",target:"_blank",rel:"noopener noreferrer",children:"演示地址"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"我们使用一个 buffer 传递坐标信息，另一个 buffer 传递颜色信息。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// 创建 坐标信息 buffer\nvar positionBuffer = gl.createBuffer();\n// 将当前 buffer 设置为 postionBuffer，接下来对 buffer 的操作都是针对 positionBuffer 了。\ngl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n// 设置 a_Position 变量读取 positionBuffer 缓冲区的方式。\nvar size = 2;\nvar type = gl.FLOAT;\nvar normalize = false;\nvar stride = 0;\nvar offset = 0;\ngl.vertexAttribPointer(\n      a_Position, size, type, normalize, stride, offset);\n      \n// 创建 颜色信息 buffer\nvar colorBuffer = gl.createBuffer();\n// 将当前 buffer 设置为 postionBuffer，接下来对 buffer 的操作都是针对 positionBuffer 了。\ngl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n// 设置 a_Position 变量读取 positionBuffer 缓冲区的方式。\nvar size = 4;\nvar type = gl.FLOAT;\nvar normalize = false;\nvar stride = 0;\nvar offset = 0;\ngl.vertexAttribPointer(\n      a_Color, size, type, normalize, stride, offset);\n\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"gl.vertexAttribPointer(\na_Color, size, type, normalize, stride, offset)。这个方法比较重要，上节已经向大家详细介绍了，如果还不太明白的，可以再次回顾下上节内容。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["我们发现，上面代码对 ",(0,i.jsx)(n.code,{children:"buffer"})," 的操作有些冗余，我们还是提取出一个方法 ",(0,i.jsx)(n.code,{children:"createBuffer"})," 放到 ",(0,i.jsx)(n.code,{children:"webgl-helper.js"}),"，减少重复编码，之后我们对 ",(0,i.jsx)(n.code,{children:"buffer"})," 的一系列调用只需要如下两句就可以了："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var positionBuffer = createBuffer(gl, a_Position, { size: 2});\nvar colorBuffer = createBuffer(gl, a_Color, { size: 4});\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["假如我们顶点坐标数组中有四个顶点 8 个元素【30, 30, 30, 40, 40, 30, 20, 0】，顶点着色器中的 ",(0,i.jsx)(n.code,{children:"a_Position"})," 属性在读取顶点坐标信息时，以 2 个元素为一组进行读取："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["又假如我们顶点颜色数组中有两个顶点 8 个元素 【244, 230, 100, 1, 125, 30, 206, 1】，那么顶点着色器中的 ",(0,i.jsx)(n.code,{children:"a_Color"})," 属性在读取顶点颜色信息时，以 4 个元素（r, g, b, a）为一组进行读取，如下图所示。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:""})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["以多少元素作为一个顶点信息进行读取的设置，是在调用 ",(0,i.jsx)(n.code,{children:"gl.vertexAttribPointer"})," 时设置的 ",(0,i.jsx)(n.code,{children:"size"})," 参数值。"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["言归正传，接下来我们为 ",(0,i.jsx)(n.code,{children:"canvas"})," 添加点击事件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"canvas.addEventListener('click', e => {\n    var x = e.pageX;\n    var y = e.pageY;\n    positions.push(x, y);\n    //随机一种颜色\n    var color = randomColor();\n    //将随机颜色的 rgba 值添加到顶点的颜色数组中。\n    colors.push(color.r, color.g, color.b, color.a);\n    //顶点的数量是 3 的整数倍时，执行绘制操作。\n    if (positions.length % 6 == 0) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);\n        render(gl);\n    }\n})\n"})}),"\n",(0,i.jsx)(n.p,{children:"万事俱备，只欠绘制："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"    function render(gl) {\n      //用设置的清空画布颜色清空画布。\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      if (positions.length <= 0) {\n        return;\n      }\n      //绘制图元设置为三角形。\n      var primitiveType = gl.TRIANGLES;\n      //因为我们要绘制三个点，所以执行三次顶点绘制操作。\n      gl.drawArrays(primitiveType, 0, positions.length / 2);\n    }\n"})}),"\n",(0,i.jsx)(n.p,{children:"至此，三角形的渐变效果就实现啦。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:""})}),"\n",(0,i.jsxs)(n.h4,{id:"另一种思路使用-1-个-buffer-同时传递坐标和颜色信息",children:["另一种思路：使用 1 个 buffer 同时传递坐标和颜色信息",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#另一种思路使用-1-个-buffer-同时传递坐标和颜色信息",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/lucefer/webgl/blob/master/pages/lesson4.html",target:"_blank",rel:"noopener noreferrer",children:"示例代码"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"http://ifanqi.top/webgl/pages/lesson4.html",target:"_blank",rel:"noopener noreferrer",children:"演示地址"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["常规思路使用多个 ",(0,i.jsx)(n.code,{children:"buffer"})," 传递多种数据（坐标和颜色），我们再演示另外一种思路：使用 1 个 ",(0,i.jsx)(n.code,{children:"buffer"})," 同时传递多种数据。"]}),"\n",(0,i.jsx)(n.p,{children:"着色器部分的代码和上面的一样，无需改动，改动的主要部分是 JavaScript 程序。"}),"\n",(0,i.jsxs)(n.p,{children:["首先，我们依然是创建 ",(0,i.jsx)(n.code,{children:"buffer"}),"，只不过这次是创建一个 ",(0,i.jsx)(n.code,{children:"buffer"}),"。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"var buffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["创建完 ",(0,i.jsx)(n.code,{children:"buffer"}),"，接下来设置读取 ",(0,i.jsx)(n.code,{children:"buffer"})," 的方式，我们有两个属性 ",(0,i.jsx)(n.code,{children:"a_Position"}),"、",(0,i.jsx)(n.code,{children:"a_Color"}),"，由于我们只有一个 ",(0,i.jsx)(n.code,{children:"buffer"}),"，该 ",(0,i.jsx)(n.code,{children:"buffer"})," 中既存储坐标信息，又存储颜色信息，所以两个属性需要读取同一个 ",(0,i.jsx)(n.code,{children:"buffer"}),"："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["我们可以看到，一个顶点信息占用 6  个元素，前两个元素代表坐标信息，后四个元素代表颜色信息，所以在下面设置属性读取 ",(0,i.jsx)(n.code,{children:"buffer"})," 方式时，",(0,i.jsx)(n.code,{children:"a_Color"})," 和 ",(0,i.jsx)(n.code,{children:"a_Position"})," 的设置会有不同："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"a_Position：坐标信息占用 2 个元素，故 size 设置为 2。\n坐标信息是从第一个元素开始读取，偏移值为 0 ，所以 offset 设置为 0."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"a_Color：由于 color 信息占用 4 个元素，所以 size 设置为 4 。\ncolor 信息是在坐标信息之后，偏移两个元素所占的字节（2 * 4 = 8）。所以，offset 设置为 8。"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"stride：代表一个顶点信息所占用的字节数，我们的示例，一个顶点占用 6 个元素，每个元素占用 4 字节，所以，stride = 4 * 6 = 24 个字节。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"gl.vertexAttribPointer(\n      a_Color, 4, gl.FLOAT, false, 24, 8);\n      \ngl.vertexAttribPointer(\n      a_Position, 2, gl.FLOAT, false, 24, 0);\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"canvas"})," 的点击事件也有所不同，一个顶点占用 6 个元素，三个顶点组成一个三角形，所以我们的 ",(0,i.jsx)(n.code,{children:"positions"})," 的元素数量必须是 18 的整数倍，才能组成一个三角形："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"    canvas.addEventListener('click', e => {\n      var x = e.pageX;\n      var y = e.pageY;\n      positions.push(x);\n      positions.push(y);\n      //随机出一种颜色\n      var color = randomColor();\n      //将随机颜色的 rgba 值添加到顶点的颜色数组中。\n      positions.push(color.r, color.g, color.b, color.a);\n      //顶点的数量是 18 的整数倍时，执行绘制操作。\n      if (positions.length % 18 == 0) {\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n        render(gl);\n      }\n    })\n"})}),"\n",(0,i.jsx)(n.p,{children:"实现效果和上面操作多缓冲区的方式一样，但是单缓冲区不仅减少了缓冲区的数量，而且减少了传递数据的次数以及复杂度。"}),"\n",(0,i.jsxs)(n.h2,{id:"回顾",children:["回顾",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["至此，我们对缓冲区的讲解就结束了，本节所讲知识点和上节基本类似，不同点在于用单个缓冲区传递多类数据时，",(0,i.jsx)(n.code,{children:"gl.vertexAttribPointer"})," 各个参数如何设置，理解这点对我们以后编程十分有用，希望大家课下多多练习，深刻理解它的用法。"]}),"\n",(0,i.jsx)(n.p,{children:"到目前为止，我们掌握了三角形的绘制方法，接下来学习怎样用三角形构建其他图形。"}),"\n",(0,i.jsx)(n.p,{children:"下一节我们将从简单平面开始：先用三角形构建一个矩形。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}let f=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F5.%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%20---%20%E7%BB%98%E5%88%B6%E6%B8%90%E5%8F%98%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BC%93%E5%86%B2%E5%8C%BA.md"]={toc:[{text:"目标",id:"目标",depth:2},{text:"渐变三角形",id:"渐变三角形",depth:2},{text:"着色器",id:"着色器",depth:3},{text:"JavaScript 部分",id:"javascript-部分",depth:3},{text:"方式一：多个 buffer 传递",id:"方式一多个-buffer-传递",depth:4},{text:"另一种思路：使用 1 个 buffer 同时传递坐标和颜色信息",id:"另一种思路使用-1-个-buffer-同时传递坐标和颜色信息",depth:4},{text:"回顾",id:"回顾",depth:2}],title:"5.初级入门 --- 绘制渐变三角形：深入理解缓冲区",headingTitle:"5.初级入门 --- 绘制渐变三角形：深入理解缓冲区",frontmatter:{}}}}]);