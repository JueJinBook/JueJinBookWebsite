"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56381"],{876918:function(n,e,o){o.r(e),o.d(e,{default:()=>w});var r=o(552676),i=o(740453);let t=o.p+"static/image/a105c67a023ff329df8e34ab745705a7.a8c7660f.png",s=o.p+"static/image/dada62432c3055d30319a2474855d5fe.5b8f1fa6.png",c=o.p+"static/image/07a6e86a08f0ac56c1c10209b25099de.581776cd.png",d=o.p+"static/image/5f5a93e1d1334f5f8d1ba9799387f886.569c5a4c.png",a=o.p+"static/image/d32309ec08c6491fa2b30917a28df2c2.6c2441de.png",l=o.p+"static/image/f976f4acd064eec0fce2f9f7dd031819.a4ec8479.png";function p(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",blockquote:"blockquote",h2:"h2",ul:"ul",li:"li",img:"img",pre:"pre"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"13原理解析iframe--proxy-隔离",children:["13.原理解析：iframe + Proxy 隔离",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13原理解析iframe--proxy-隔离",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在上一节课程中，我们讲解了 ",(0,r.jsx)(e.code,{children:"src = about:blank"})," iframe 隔离和同源的 iframe 隔离，后者需要服务端提供空白页或者服务接口才能实现，并且请求本身也会产生性能损耗，如果能够解决前者隔离的 ",(0,r.jsx)(e.code,{children:"history"})," 运行问题，那么可以减少服务接口和网络请求，从而达到隔离效果。本课程会重点讲解如何解决 ",(0,r.jsx)(e.code,{children:"src = about:blank"})," iframe 隔离的运行问题。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：如果想要解决同源 iframe 隔离中需要网络请求和服务端网关的问题，有没有什么解决方案呢？"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"隔离思路",children:["隔离思路",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#隔离思路",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在 iframe 中可以创建新的全局执行上下文从而和主应用彻底隔离，因此我们可以将 iframe 创建的 ",(0,r.jsx)(e.code,{children:"window"})," 对象作为微应用的全局对象，从而实现应用之间 JS 的彻底隔离，但是在之前的 iframe 隔离设计中还存在以下问题没有解决："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"src = about:blank"})," iframe 的 ",(0,r.jsx)(e.code,{children:"history"})," 无法正常工作，框架的路由功能丢失"]}),"\n",(0,r.jsx)(e.li,{children:"虽然 DOM 环境天然隔离，却无法使得 iframe 中的 Modal 相对于主应用居中"}),"\n",(0,r.jsx)(e.li,{children:"主应用和微应用的 URL 状态没有同步"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["同源的 iframe 方案虽然能解决 ",(0,r.jsx)(e.code,{children:"history"})," 运行的问题，但是需要主应用额外提供服务接口，对于框架设计而言并不是特别通用（如果业务本身能够支持，那么这种方案是非常不错的选择）。我们可以换个方式思考一下，是否可以将 ",(0,r.jsx)(e.code,{children:"src = about:blank"})," iframe 中的 ",(0,r.jsx)(e.code,{children:"history"})," 使用主应用的 ",(0,r.jsx)(e.code,{children:"history"})," 代替运行，这样带来的好处如下："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"不同微应用可以拥有各自 iframe 对应的全局上下文执行环境，可以实现 JS 的彻底隔离"}),"\n",(0,r.jsxs)(e.li,{children:["使用主应用的 ",(0,r.jsx)(e.code,{children:"history"}),"，iframe 可以设置成 ",(0,r.jsx)(e.code,{children:"src = about:blank"}),"，不会产生运行时错误"]}),"\n",(0,r.jsxs)(e.li,{children:["使用主应用的 ",(0,r.jsx)(e.code,{children:"history"}),"，未来可以处理主应用和微应用的历史会话同步问题"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["为了实现上述思路，可以使用 ",(0,r.jsx)(e.code,{children:"Proxy"})," 对 iframe 的 ",(0,r.jsx)(e.code,{children:"window"})," 对象进行拦截处理，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：本课程只是提供简单的解决思路，真正要实现会话同步还需要考虑主子应用之间的路由冲突问题。"}),"\n",(0,r.jsxs)(e.p,{children:["除此之外，如果要实现 iframe 中的模态框相对于主应用进行居中，可以在设计时将微应用的 ",(0,r.jsx)(e.code,{children:"document"})," 代理成主应用 ",(0,r.jsx)(e.code,{children:"document"}),"，并且将需要渲染的微应用内容放在主应用的 DOM 环境中。当然这种方式解除了 iframe 中 DOM 天然隔离的限制，并且可以使得微应用任意修改主应用的 DOM 环境，而且还需要额外处理 DOM 的副作用（例如移除微应用时需要清空相应的 DOM 事件）以及 CSS 隔离问题，如果考虑不够完善，很容易产生意想不到的 Bug。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"为了实现该代理功能，接下来需要额外了解一些 JavaScript 的语言特性，从而帮助大家更好的理解方案设计。"}),"\n",(0,r.jsxs)(e.h2,{id:"proxy",children:["Proxy",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#proxy",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Proxy"})," 可以对需要访问的对象进行拦截，并可以通过拦截函数对返回值进行修改，这种特性可以使我们在微应用中访问 ",(0,r.jsx)(e.code,{children:"window"})," 对象的属性时，返回定制化的属性值，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'const iframe = document.createElement("iframe");\n// 设置成 about:blank 后和主应用同源\niframe.src = "about:blank";\n// 这里只用于演示 JS 运行，暂时不考虑加载微应用的 DOM，可以隐藏 iframe 处理\niframe.style = "display: none";\ndocument.body.appendChild(iframe);\n\n// iframe.contentWindow： iframe 的 window 对象\niframe.contentWindow.proxy = new Proxy(iframe.contentWindow, {\n  get: (target, prop) => {\n    console.log("[proxy get 执行] 拦截的 prop: ", prop);\n    // 访问微应用的 window.history 时，返回主应用的 history\n    if (prop === "history") {\n      return window[prop];\n    }\n    // target 是被代理的 iframe.contentWindow\n    // 除了 history，其余都返回 iframe 上 window 的属性值\n    return target[prop];\n  },\n\n  set: (target, prop, value) => {\n    console.log("[proxy set 执行] 拦截的 prop: ", prop);\n    target[prop] = value;\n  },\n});\n\nfunction execMicroCode() {\n  // microCode 可以视为通过请求获取的微应用的 JS 脚本文本（不包括立即执行的匿名函数）\n  // 在微应用中执行的 window，就是主应用中执行的 iframe.contentWindow\n  // window.proxy 指的是已经设置了代理的 iframe.contentWindow.proxy\n  const microCode = `(function(window){\n\n  // 在立即执行的匿名函数中 window.proxy 作为形参被传入\n  // 内部使用的 window 本质上是 iframe.contentWindow 的代理对象\n  // 任何 window 属性访问和设置都会触发 Proxy 的 get 和 set 拦截行为\n  \n  // 访问 window.a 触发 Proxy 的 get，本质上读取的是 iframe.contentWindow 的 a 属性值\n  // 打印信息 \n  // [proxy get 执行] 拦截的 prop:  a\n  // [微应用执行] window.a:  undefined\n  console.log(\'[微应用执行] window.a: \', window.a);\n  \n  // 访问 window.history 触发 Proxy 的 get，本质上读取的是主应用的 history 对象\n  // 访问 window.parent 触发 Proxy 的 get，本质上读取的是微应用的 iframe.contentWindow.parent 对象\n  // 打印信息 \n  // [proxy get 执行] 拦截的 prop:  history\n  // [proxy get 执行] 拦截的 prop:  parent\n  // [微应用执行] 是否是主应用的 history： true\n  console.log(\'[微应用执行] 是否是主应用的 history：\', window.history === window.parent.history);\n  \n  // 访问 window.history 触发 Proxy 的 get，本质上读取的是主应用的 history 对象\n  // 打印信息 \n  // [proxy get 执行] 拦截的 prop:  history\n  window.history.pushState({}, \'\', \'/micro\');\n  \n  // 设置 window.a 触发 Proxy 的 set，本质上设置的是 iframe.contentWindow 的 a 属性值\n  // 打印信息 \n  // [proxy set 执行] 拦截的 prop:  a\n  window.a = 2;\n  \n  // 访问 window.a 触发 Proxy 的 get，本质上读取的是 iframe.contentWindow 的 a 属性值\n  // 打印信息 \n  // [proxy get 执行] 拦截的 prop:  a\n  // [微应用执行] window.a:  2\n  console.log(\'[微应用执行] window.a: \', window.a);\n\n})(window.proxy)`;\n\n  const scriptElement =\n    iframe.contentWindow.document.createElement("script");\n  scriptElement.textContent = microCode;\n  // 添加内嵌的 script 元素时会自动触发 JS 的解析和执行\n  iframe.contentWindow.document.head.appendChild(scriptElement);\n}\n\n// 主应用的 window.a 设置为 1\nwindow.a = 1;\n\n// 执行微应用的代码，此时微应用中的 window 使用了 iframe 的 window 进行代理，不会受到主应用的 window 影响\nexecMicroCode();\n\n// 主应用的 window 不会受到微应用的影响，输出为 1\n// 控制台打印信息 [主应用执行] window.a:  1\nconsole.log(\'[主应用执行] window.a: \', window.a);\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：这里立即执行的匿名函数本质上不是为了隔离微应用的执行作用域，因为微应用都运行在 iframe 中，已经天然做到了完全隔离，这里的作用是为了通过传入形参的方式改变内部使用的 ",(0,r.jsx)(e.code,{children:"window"})," 变量。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["从下图打印的信息可以可以发现， ",(0,r.jsx)(e.code,{children:"history"})," 被正确的进行了代理，并且主应用和微应用由于使用了不同的全局执行上下文，形成了非常彻底的隔离效果："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：从红框部分可以发现，尽管 iframe 设置成了 ",(0,r.jsx)(e.code,{children:"src=about:blank"}),"，但是由于微应用使用了主应用的 ",(0,r.jsx)(e.code,{children:"history"})," 执行，使得主应用的 URL 发生了变化。这里只是演示了主子应用共用 ",(0,r.jsx)(e.code,{children:"history"})," 的情况，真正在设计时还需要考虑处理主子应用以及子应用之间在使用 Vue 或者 React 框架时的路由嵌套以及冲突问题。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在 iframe 隔离中我们知道设置 ",(0,r.jsx)(e.code,{children:"src=about:blank"})," 会使得 ",(0,r.jsx)(e.code,{children:"history"})," 无法正常工作，例如修改上述示例："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function execMicroCode() {\n  \n  const microCode = `(function(window){\n\n      // 省略微应用执行的代码\n\n   // window 指的是 iframe.contentWindow，注意传入的参数不是 window.proxy\n   })(window)`;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["如果不使用 Proxy 进行代理，那么 ",(0,r.jsx)(e.code,{children:"window.history"})," 访问的是 ",(0,r.jsx)(e.code,{children:"iframe"})," 的 ",(0,r.jsx)(e.code,{children:"history"}),"，此时页面会无法正常工作："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:["需要注意以下场景无法被 Proxy 的 ",(0,r.jsx)(e.code,{children:"set"})," 拦截，通过 ",(0,r.jsx)(e.code,{children:"get"})," 拦截获取属性值时部分场景无法达到预期的效果："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function execMicroCode() {\n    \n  // 注意传入了第二个参数 contentWindow，这是没有被代理的 iframe 的 window 对象\n  const microCode = `(function(window, contentWindow){\n\n    // 没有触发 Proxy 的 set 函数，由于在立即执行的匿名函数中执行 var，此时不是全局变量\n    var a = 2;\n    \n    // 触发 Proxy 的 get\n    // 打印信息 \n    // [proxy get 执行] 拦截的 prop:  a\n    // [微应用执行] window.a:  undefined\n    console.log('[微应用执行] window.a: ', window.a);\n    \n    // 没有触发 Proxy 的 set 函数，因为 this 指代的是没有被代理的 iframe 的 window 对象\n    this.a = 2;\n    \n    // 打印信息 \n    // [proxy get 执行] 拦截的 prop:  parent\n    // [微应用执行] this 是否是主应用的 window:  false\n    console.log('[微应用执行] this 是否是主应用的 window: ', this === window.parent);\n    \n    // 打印信息 \n    // [微应用执行] this 是否是子应用的 window:  true\n    console.log('[微应用执行] this 是否是子应用的 window: ', this === contentWindow);\n    \n    // 打印信息 \n    // [proxy get 执行] 拦截的 prop:  a\n    // [微应用执行] window.a:  2\n    console.log('[微应用执行] window.a: ', window.a);\n    \n    // 没有触发 Proxy 的 set 函数，因为属性挂载在没有被代理的 iframe 的 window 对象\n    b = 2;\n    \n    // 打印信息 \n    // [proxy get 执行] 拦截的 prop:  b\n    // [微应用执行] window.b:  2\n    console.log('[微应用执行] window.b: ', window.b);\n    \n    })(window.proxy, window)`;\n\n  const scriptElement =\n    iframe.contentWindow.document.createElement(\"script\");\n  scriptElement.textContent = microCode;\n  // 添加内嵌的 script 元素时会自动触发 JS 的解析和执行\n  iframe.contentWindow.document.head.appendChild(scriptElement);\n}\n\n// 省略其余代码\n\n// 控制台打印信息 [主应用执行] window.a:  1\nconsole.log('[主应用执行] window.a: ', window.a);\n// 控制台打印信息 [主应用执行] window.b:  undefined\nconsole.log('[主应用执行] window.b: ', window.b);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["从下图打印的信息可以可以发现， 在立即执行匿名函数中的 ",(0,r.jsx)(e.code,{children:"var"})," 声明没有被拦截，这和微应用独立运行的结果不一致。而 ",(0,r.jsx)(e.code,{children:"this"})," 赋值和未限定标识符变量时，可以正确设置 ",(0,r.jsx)(e.code,{children:"window"})," 属性，但是没有通过 Proxy 代理，因为赋值行为不是发生在代理的 ",(0,r.jsx)(e.code,{children:"window"})," 对象上，而是发生在没有被代理的 ",(0,r.jsx)(e.code,{children:"window"})," 对象上："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:["如果希望 ",(0,r.jsx)(e.code,{children:"this"})," 也可以受到 Proxy 代理的管控，那么可以重新绑定 ",(0,r.jsx)(e.code,{children:"this"})," 的指向："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascrpt",children:"function execMicroCode() {\n    \n    // 注意传入了第二个参数 contentWindow，这是没有被代理的 iframe 的 window 对象\n    const microCode = `(function(window, contentWindow){\n      \n      // 打印信息 \n      // [proxy set 执行] 拦截的 prop:  a\n      this.a = 2;\n      \n      // 打印信息 \n      // [proxy get 执行] 拦截的 prop:  parent\n      // this 是否是主应用的 window:  false\n      console.log('[微应用执行] this 是否是主应用的 window: ', this === window.parent);\n      \n      // 打印信息 \n      // [微应用执行] this 是否是子应用的 window:  false\n      console.log('[微应用执行] this 是否是子应用的 window: ', this === contentWindow);\n      \n      // 打印信息 \n      // [proxy get 执行] 拦截的 prop:  proxy\n      // [微应用执行] this 是否是子应用的 window.proxy:  true\n      console.log('[微应用执行] this 是否是子应用的 window.proxy: ', this === window.proxy);\n\n    // 将内部的 this 指向 window 的代理对象\n    }).bind(window.proxy)(window.proxy, window)`;\n  \n    const scriptElement =\n      iframe.contentWindow.document.createElement(\"script\");\n    scriptElement.textContent = microCode;\n    // 添加内嵌的 script 元素时会自动触发 JS 的解析和执行\n    iframe.contentWindow.document.head.appendChild(scriptElement);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"因此具备了上述的 iframe + Proxy 隔离设计后："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["可以解决 JS 运行环境的隔离问题，当然除了 ",(0,r.jsx)(e.code,{children:"history"})," 故意不进行隔离"]}),"\n",(0,r.jsxs)(e.li,{children:["微应用在使用 ",(0,r.jsx)(e.code,{children:"var"})," 时需要挂载在全局对象上的能力缺失"]}),"\n",(0,r.jsxs)(e.li,{children:["可以解决微应用之间的全局属性隔离问题，包括使用未限定标识符的变量、",(0,r.jsx)(e.code,{children:"this"})]}),"\n",(0,r.jsxs)(e.li,{children:["使用 ",(0,r.jsx)(e.code,{children:"this"})," 时访问是 iframe 的 ",(0,r.jsx)(e.code,{children:"window"})," 代理对象，可以和主应用的 ",(0,r.jsx)(e.code,{children:"this"})," 隔离"]}),"\n",(0,r.jsxs)(e.li,{children:["可以解决 iframe 隔离中无法进行 ",(0,r.jsx)(e.code,{children:"history"})," 操作和同步的问题"]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：可以将 Proxy 理解为微应用隔离的逃生窗口，在上述设计中可以将 ",(0,r.jsx)(e.code,{children:"history"})," 理解为隔离的白名单，在后续的设计中需要精细化考虑子应用的 ",(0,r.jsx)(e.code,{children:"history"})," 操作不能对主应用产生额外的影响。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"proxy--with",children:["Proxy + With",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#proxy--with",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["基于上述的 Proxy 示例，我们会发现微应用中的 ",(0,r.jsx)(e.code,{children:"var"})," 在主应用中运行时无法挂载在全局属性上。除此之外，我们单独使用 ",(0,r.jsx)(e.code,{children:"history"})," 而不是 ",(0,r.jsx)(e.code,{children:"window.history"})," 进行访问时也无法进行拦截："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:" const microCode = `(function(window){\n    // 没有触发 Proxy 的 set 函数，由于在立即执行的匿名函数中执行 var，此时不是全局变量\n    var a = 2;\n    \n    // 触发 Proxy 的 get\n    \n    // 打印信息 \n    // [proxy get 执行] 拦截的 prop:  a\n    // [微应用执行] window.a:  undefined\n    console.log('[微应用执行] window.a: ', window.a);\n    \n    // window.history.pushState({}, '', '/micro');\n    // 如果不使用 window.history，那么无法进行拦截，此时使用的仍然是子应用的 history，执行会报错\n    history.pushState({}, '', '/micro');\n\n})(window.proxy)`;\n"})}),"\n",(0,r.jsxs)(e.p,{children:["关于 ",(0,r.jsx)(e.code,{children:"history"})," 的问题解决方案有很多，这里可以列举多种实现方式："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["在执行微应用的代码前修改 ",(0,r.jsx)(e.code,{children:"contentWindow.history"}),"，使其指向主应用的 ",(0,r.jsx)(e.code,{children:"history"})]}),"\n",(0,r.jsxs)(e.li,{children:["在立即执行的匿名函数中传入第二个形参 ",(0,r.jsx)(e.code,{children:"history"}),"，指向 ",(0,r.jsx)(e.code,{children:"widnow.proxy.history"})]}),"\n",(0,r.jsxs)(e.li,{children:["对 ",(0,r.jsx)(e.code,{children:"contentWindow.history"})," 进行单独代理，并传入立即执行的匿名函数"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["而在函数中声明 ",(0,r.jsx)(e.code,{children:"var"})," 局部变量无法将属性挂载在全局对象上，我们希望微应用独立运行和嵌入主应用运行的行为应该保持一致，为了解决该问题可以使用 ",(0,r.jsx)(e.code,{children:"with"})," 配合 ",(0,r.jsx)(e.code,{children:"Proxy"})," 实现。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：一般情况下不需要考虑 ",(0,r.jsx)(e.code,{children:"var"})," 声明的问题，例如在 Vue 或者 React 框架中使用的 ",(0,r.jsx)(e.code,{children:"var"})," 都是在模块中声明的变量，不会挂载在全局属性上。除此之外，在写代码时大概率也不会采用上述的设计风格（声明了 ",(0,r.jsx)(e.code,{children:"var"})," 以后不直接访问，而是通过 ",(0,r.jsx)(e.code,{children:"window"})," 进行访问）。本课程讨论该问题单纯是为了讲述该问题的解决方案。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"with"})," 设计的本意用于缩短查找作用域链，并且可以减少变量的使用长度，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'var person = {\n    name: "ziyi",\n    address: {\n      country: "China",\n      city: "Hangzhou",\n    },\n  };\n\n  with (person) {\n    console.log("name: ", name); // ziyi\n    with (address) {\n      console.log("country: ", country); // China\n      console.log("city: ", city); // Hangzhou\n    }\n  }\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在上述示例中，通过 ",(0,r.jsx)(e.code,{children:"with"})," 语句将 ",(0,r.jsx)(e.code,{children:"person"})," 对象的所有属性和方法添加到了当前作用域链的顶端（作用域链的最底下是全局对象 ",(0,r.jsx)(e.code,{children:"window"}),"），因此在 ",(0,r.jsx)(e.code,{children:"with (person)"})," 内部需要访问 ",(0,r.jsx)(e.code,{children:"person.name"})," 时可以直接使用 ",(0,r.jsx)(e.code,{children:"name"}),"，本质上在查找 ",(0,r.jsx)(e.code,{children:"name"})," 的过程中先判断 ",(0,r.jsx)(e.code,{children:"name in person"}),"，如果返回的是 ",(0,r.jsx)(e.code,{children:"true"}),"，则直接获取 ",(0,r.jsx)(e.code,{children:"person.name"})," 的值。有了 ",(0,r.jsx)(e.code,{children:"with"})," 的能力后，可以使用 Proxy 的 ",(0,r.jsx)(e.code,{children:"has"})," 对 ",(0,r.jsx)(e.code,{children:"in"})," 操作进行拦截，从而对 ",(0,r.jsx)(e.code,{children:"var"})," 进行拦截处理："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const person = {}\n\nwith(person) {\n  // 此时声明的 var 在全局作用域下，会添加属性到 window 上\n  // 注意块级作用域对 var 没有任何作用\n  var a = 2;\n  console.log('person a: ', person.a); // undefined\n  console.log(window.a); // 2\n}\n\nconst person1 = new Proxy({}, {\n  set(target, prop, value) {\n    console.log('触发 set: ', prop);\n    target[prop] = value\n  },\n    \n  // has 可以拦截的操作类型：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/has#%E6%8B%A6%E6%88%AA\n  // has 会对 with(proxy) { (foo); }  中的 foo 访问进行拦截 \n  // has 返回为 true 时告诉 with 语句，with(proxy) 的 proxy 对象一定存在 foo 属性（实际上可能不存在 foo 属性）\n  // 一旦 foo in proxy 为 true，那么 foo 就不会沿着原型链进行向上查找，从而切断了 with 中变量对象的原型链查找能力\n  has(target, prop) {\n    console.log('触发 has: ', prop);\n    return true\n  }\n})\n\nwith(person1) {\n  // 实现对 var 的拦截操作，此时的 var 被拦截，无法到达全局对象\n  // 触发 has:  a\n  // 触发 set:  a\n  var a = 2;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"了解了上述能力后，我们在 Proxy 示例的基础上进行如下代码的尝试："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"iframe.contentWindow.proxy = new Proxy(iframe.contentWindow, {\n        get: (target, prop) => {\n          console.log(\"[proxy get 执行] 拦截的 prop: \", prop);\n\n          if (prop === \"history\") {\n            return window[prop];\n          }\n\n          // 访问 window.window 时返回 proxy\n          // 访问 proxy.history 时 history 可以被拦截处理\n          if(prop === 'window') {\n            return iframe.contentWindow.proxy;\n          }\n\n          // target 就是被代理的 iframe.contentWindow\n          // 除了 history，其余都返回 iframe 上 window 的属性值\n          return target[prop];\n        },\n\n        set: (target, prop, value) => {\n          console.log(\"[proxy set 执行] 拦截的 prop: \", prop);\n          target[prop] = value;\n        },\n\n        \n        // 拦截 in 操作符\n        // has 可以拦截的操作类型：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/has#%E6%8B%A6%E6%88%AA\n        // 返回为 true 时告诉 with 语句，一定存在属性，禁止向上进行原型链查找\n        has: (target, prop) => true\n      });\n\n\n\nconst microCode = `(function(window){\n    with(window) {\n         // 打印信息\n         // [proxy get 执行] 拦截的 prop:  Symbol(Symbol.unscopables)\n         // [proxy set 执行] 拦截的 prop:  a\n         var a = 2;\n            \n         // 打印信息   \n         // [proxy get 执行] 拦截的 prop:  Symbol(Symbol.unscopables)\n         // [proxy get 执行] 拦截的 prop:  console\n         // [proxy get 执行] 拦截的 prop:  Symbol(Symbol.unscopables)\n         // [proxy get 执行] 拦截的 prop:  window\n         // [proxy get 执行] 拦截的 prop:  a\n         // with a:  2\n         console.log('with a: ', window.a); // 注意访问 window.a 在 with 下是访问了 window.window.a\n         \n         // 打印信息\n         // [proxy get 执行] 拦截的 prop:  Symbol(Symbol.unscopables)\n         // [proxy get 执行] 拦截的 prop:  history\n         history.pushState({}, '', '/micro1');\n         \n         // 打印信息\n         // [proxy get 执行] 拦截的 prop:  window   \n         // [proxy get 执行] 拦截的 prop:  history\n         window.history.pushState({}, '', '/micro2'); // 在 with 下是访问了 window.window.history\n    }\n\n}).bind(window.proxy)(window.proxy)`;\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：感兴趣的同学可以额外了解一下 ",(0,r.jsx)(e.code,{children:"Symbol.unscopables"})," 的作用。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"具备了上述 iframe + Proxy + With 的隔离设计后："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["可以解决 JS 运行环境的隔离问题，当然除了 ",(0,r.jsx)(e.code,{children:"history"})," 故意不进行隔离"]}),"\n",(0,r.jsxs)(e.li,{children:["微应用在使用 ",(0,r.jsx)(e.code,{children:"var"})," 时可以挂载在全局对象上"]}),"\n",(0,r.jsxs)(e.li,{children:["可以解决微应用之间的全局属性隔离问题，包括使用未限定标识符的变量、",(0,r.jsx)(e.code,{children:"this"})]}),"\n",(0,r.jsxs)(e.li,{children:["使用 ",(0,r.jsx)(e.code,{children:"this"})," 时访问是 iframe 的 ",(0,r.jsx)(e.code,{children:"window"})," 代理对象，可以和主应用的 ",(0,r.jsx)(e.code,{children:"this"})," 隔离"]}),"\n",(0,r.jsxs)(e.li,{children:["可以解决 iframe 隔离中无法进行 ",(0,r.jsx)(e.code,{children:"history"})," 操作和同步的问题"]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：使用 ",(0,r.jsx)(e.code,{children:"with"})," 可能会产生性能损耗，例如在 ",(0,r.jsx)(e.code,{children:"with(window)"})," 下访问 ",(0,r.jsx)(e.code,{children:"window"})," 时事实上是访问了 ",(0,r.jsx)(e.code,{children:"window.window"}),"，导致拦截的频率变高。如果不考虑全局作用域的 ",(0,r.jsx)(e.code,{children:"var"})," 兼容问题，那么完全可以去掉 ",(0,r.jsx)(e.code,{children:"with"})," 从而减少性能损耗。在 qiankun 中为了使内部的微应用执行可以快速访问 ",(0,r.jsx)(e.code,{children:"history"}),"、",(0,r.jsx)(e.code,{children:"location"})," 等，专门进行了作用域内的局部声明，从而防止作用域链查找带来的性能损耗。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"修正-this-指向",children:["修正 ",(0,r.jsx)(e.code,{children:"this"})," 指向",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#修正-this-指向",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["使用 Proxy 加载微应用时，由于内部使用的是代理后的 ",(0,r.jsx)(e.code,{children:"window"})," 对象，会产生如下问题："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const microCode = `(function(window){\n    with(window) {\n       // Uncaught TypeError: Illegal invocation\n       // 此时 `this` 指向了 proxy，而不是 iframe 的 window 对象\n       window.alert(1);\n       // Uncaught TypeError: Illegal invocation\n       window.addEventListener('load', (e) => {});\n    }\n\n}).bind(window.proxy)(window.proxy)`;\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：阅读 ",(0,r.jsx)(e.a,{href:"https://mtsknn.fi/blog/illegal-invocations-in-js/",target:"_blank",rel:"noopener noreferrer",children:'"Illegal invocation" errors in JavaScript'})," 了解更多详情信息。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"可能上述示例需要一定的理解能力，我们可以换一个示例："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 正常运行\nalert(1);\n// 正常运行\nwindow.alert(1);\n\nconst obj = {\n  // 将 window.alert 赋值给 obj.alert\n  alert\n}\n\n// Uncaught TypeError: Illegal invocation\n// 因为内部的 alert 执行的 this 指向了 obj\n// 此时所需要的执行上下文是 window，否则会报错 Illegal invocation\nobj.alert(1);\n\n// 正常运行，因为修正了 this 的指向\nobj.alert.bind(window)(1);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["为了修正 ",(0,r.jsx)(e.code,{children:"this"})," 指向，需要将 ",(0,r.jsx)(e.code,{children:"proxy"})," 中的原生函数调用指向原始的 ",(0,r.jsx)(e.code,{children:"window"})," 对象，但是在这个识别过程中还需要考虑其他情况，例如有些函数已经进行了 ",(0,r.jsx)(e.code,{children:"bind"}),"，那么不应该进行再次的绑定操作，此时可以通过函数名来识别，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// MDN: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name#%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%8D%E7%A7%B0\nfunction foo() {};\n// 绑定后生成的函数的 name 属性会以 bound 开头\nfoo.bind({}).name; // "bound foo"\n'})}),"\n",(0,r.jsxs)(e.p,{children:["除此之外，一些构造函数不需要进行 ",(0,r.jsx)(e.code,{children:"bind"})," 操作，因为 ",(0,r.jsx)(e.code,{children:"bind"})," 生成的函数会失去原有函数的属性和 ",(0,r.jsx)(e.code,{children:"prototype"}),"："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 也可以是 function Person {} 构造函数\nclass Person {\n    constructor(name) {\n      this.name = name;\n    }\n    getName() {\n      return this.name;\n    }\n}\n\n// 添加一个属性\nPerson.age = 1;\n\nconsole.log("Person.prototype: ", Person.prototype); // {constructor: ƒ, getName: ƒ}\nconsole.log("Person.age: ", Person.age); // 1\n\n// 假设不小心进行了 bind 操作\n// bind 的 this 指向 Person，bind 的参数为 window，简单理解为 Person.bind(window)\n// 返回的是一个改变 this 指向 window 的新的 Person 构造函数\nconst BoundPerson = Function.prototype.bind.call(Person, window);\n\n// ECMA 2022：https://262.ecma-international.org/13.0/#sec-function.prototype.bind (无法跳转可以搜索 Function.prototype.bind)\n// Function objects created using Function.prototype.bind are exotic objects. They also do not have a "prototype" property.\n// 从打印信息可以发现 bind 之后的函数失去了原有函数的 prototype 和属性\nconsole.log("BoundPerson.prototype: ", BoundPerson.prototype); // undefined\nconsole.log("BoundPerson.age: ", BoundPerson.age); // undefined\n\n// window.name、this.name 都可以获取\nvar name = "global ziyi";\n\n// MDN 构造函数使用的绑定函数：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0\n// 绑定函数自动适应于使用 new 操作符去构造一个由目标函数创建的新实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。不过提供的参数列表仍然会插入到构造函数调用时的参数列表之前。\nconst person = new BoundPerson("ziyi");\n// 构造函数绑定的 this 指向被忽略，仍然指向新实例，因此打印的不是 global ziyi\nconsole.log("person.name: ", person.getName()); // ziyi\n'})}),"\n",(0,r.jsxs)(e.p,{children:["为了修复上述问题，可以在 iframe 的 ",(0,r.jsx)(e.code,{children:"window"})," 被拦截时对 ",(0,r.jsx)(e.code,{children:"prop"})," 进行判断，通过 ",(0,r.jsx)(e.code,{children:"bind"})," 对 ",(0,r.jsx)(e.code,{children:"window.alert"})," 、",(0,r.jsx)(e.code,{children:"window.addEventListener"}),"、",(0,r.jsx)(e.code,{children:"window.atob"})," 等进行 ",(0,r.jsx)(e.code,{children:"this"})," 修正："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 1. 修正 window.alert、window.addEventListener 等 API 的 this 指向，需要识别出这些函数\n// 2. 过滤掉已经做了 bind 的函数\n// 3. 过滤掉构造函数，例如原生的 Object、Array 以及用户自己创建的构造函数等\n\nfunction isFunction(value) {\n   return typeof value === "function";\n}\n\nfunction isBoundedFunction(fn) {\n   // 被绑定的函数本身没有 prototype\n   return fn.name.indexOf("bound ") === 0 && !fn.hasOwnProperty("prototype")\n}\n\n// 是否是构造函数（这个实现比较复杂，这里可以简单参考 qiankun 实现）\nfunction isConstructable() {\n  // 可以过滤 Object、Array 等\n  return (\n    // 过滤掉箭头函数、 async 函数等。这些函数没有 prototype\n    fn.prototype &&\n    // 通常情况下构造函数的 prototype.constructor 指向本身\n    fn.prototype.constructor === fn &&\n    // 通常情况下构造函数和类都会存在 prototype.constructor，因此长度至少大于 1\n    // 需要注意普通函数中也会存在 prototype.constructor，\n    // 因此如果 prototype 有自定义属性或者方法，那么判定为类或者构造函数，因此这里的判断是大于 1\n    // 注意不要使用 Object.keys 进行判断，Object.keys 无法获取 Object.defineProperty 定义的属性\n    Object.getOwnPropertyNames(fn.prototype).length > 1\n  );\n  // TODO: 没有 constructor 的构造函数识别、class 识别、function Person() {} 识别等\n  // 例如 function Person {};  Person.prototype = {}; 此时没有 prototype.constructor 属性\n}\n\n\n// 最后可以对 window 的属性进行修正，以下函数执行在 Proxy 的 get 函数中\nfunction getTargetValue(target, prop) {\n    const value = target[prop];\n    // 过滤出 window.alert、window.addEventListener 等 API \n    if(isFunction(value) && !isBoundedFunction(value) && !isConstructable(value)) {\n        // 修正 value 的 this 指向为 target \n        const boundValue = Function.prototype.bind.call(value, target);\n        // 重新恢复 value 在 bound 之前的属性和原型（bind 之后会丢失）\n        for (const key in value) {\n          boundValue[key] = value[key];\n        }\n        // 如果原来的函数存在 prototype 属性，而 bound 之后丢失了，那么重新设置回来\n        if(value.hasOwnProperty("prototype") && !boundValue.hasOwnProperty("prototype")) {\n            boundValue.prototype = value.prototye;\n        }\n        return boundValue;\n    }\n    return value;\n}    \n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：实际在微应用使用的情况千变万化，上述设计并不能覆盖所有场景，如果想了解社区框架的完善程度，可以查看 qiankun 框架中的 ",(0,r.jsx)(e.code,{children:"getTargetValue"})," 处理。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"隔离方案设计",children:["隔离方案设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#隔离方案设计",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"了解了上述 Proxy 和 with 的作用后，我们可以重新修改 iframe 隔离中的空白页隔离方案，具体方案如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"实现效果如下所示，图中的两个按钮（微应用导航）根据后端数据动态渲染，点击按钮后会跨域请求微应用的 JS 静态资源并创建空白的 iframe 进行隔离执行："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"文件的结构目录如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"├── public                  # 托管的静态资源目录\n│   ├── main/               # 主应用资源目录                        \n│   │   └── index.html                                        \n│   └── micro/              # 微应用资源目录\n│        ├── micro1.js        \n│        └── micro2.js      \n├── config.js               # 公共配置\n├── main-server.js          # 主应用服务\n└── micro-server.js         # 微应用服务\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/iframe-proxy-sandbox",target:"_blank",rel:"noopener noreferrer",children:"demo/iframe-proxy-sandbox"})," 分支获取。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"对前端微应用进行隔离测试："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// public/micro/micro1.js\nthis.a = \'a\';\nconsole.log(\'微应用1 a: \', a);\n\nvar b = \'b\';\nconsole.log(\'微应用1 b: \', window.b);\n\nwindow.c = \'c\';\nconsole.log(\'微应用1 c: \', window.c);\n\nlet root = document.createElement("button");\nroot.textContent = "微应用 1 更改 history 为 micro1";\ndocument.body.appendChild(root);\n\n// 尽管 iframe 设置了 src="about:blank"，但是由于 history 被代理成主应用的 history，因此不会出错\nroot.onclick = () => {\n  history.pushState({}, \'\', \'/micro1\');\n}\n\n// public/micro/micro2.js\nthis.a = 1;\nconsole.log("微应用2 a: ", a);\n\nvar b = 2;\nconsole.log("微应用2 b: ", window.b);\n\nwindow.c = 3;\nconsole.log("微应用2 c: ", window.c);\n\nlet root = document.createElement("button");\nroot.textContent = "微应用 2 更改 history 为 micro2";\ndocument.body.appendChild(root);\n\n// 尽管 iframe 设置了 src="about:blank"，但是由于 history 被代理成主应用的 history，因此不会出错\nroot.onclick = () => {\n  history.pushState({}, "", "/micro2");\n};\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在原有空白 iframe 隔离的基础上对 ",(0,r.jsx)(e.code,{children:"MicroAppSandbox"})," 类进行修改，具体如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'\x3c!-- public/main/index.html --\x3e\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Main App Document</title>\n  </head>\n\n  <body>\n    <h1>Hello，Sandbox Script!</h1>\n\n    \x3c!-- 主应用导航 --\x3e\n    <div id="nav"></div>\n\n    \x3c!-- 主应用内容区 --\x3e\n    <div id="container"></div>\n\n    <script type="text/javascript">\n      // 隔离类\n      class IframeSandbox {\n        // 沙箱配置信息\n        options = null;\n        // iframe 实例\n        iframe = null;\n        // iframe 的 Window 实例\n        iframeWindow = null;\n        // 是否执行过 JS\n        execScriptFlag = false;\n\n        constructor(options) {\n          this.options = options;\n          // 创建 iframe 时浏览器会创建新的全局执行上下文，用于隔离主应用的全局执行上下文\n          this.iframe = this.createIframe();\n          this.iframeWindow = this.iframe.contentWindow;\n          this.proxyIframeWindow();\n        }\n\n        createIframe() {\n          const { rootElm, id, url } = this.options;\n          const iframe = window.document.createElement("iframe");\n          const attrs = {\n            src: "about:blank",\n            "app-id": id,\n            "app-src": url,\n            style: "border:none;width:100%;height:100%;",\n          };\n          Object.keys(attrs).forEach((name) => {\n            iframe.setAttribute(name, attrs[name]);\n          });\n          rootElm?.appendChild(iframe);\n          return iframe;\n        }\n\n        isBoundedFunction(fn) {\n          return (\n            // 被绑定的函数本身没有 prototype\n            fn.name.indexOf("bound ") === 0 && !fn.hasOwnProperty("prototype")\n          );\n        }\n\n        isConstructable(fn) {\n          // 可以识别 Object、Array 等原生构造函数，也可以识别用户自己创建的构造函数\n          return (\n            fn.prototype &&\n            // 通常情况下构造函数和类的 prototype.constructor 指向本身\n            fn.prototype.constructor === fn &&\n            // 通常情况下构造函数和类都会存在 prototype.constructor，因此长度至少大于 1\n            // 需要注意普通函数中也会存在 prototype.constructor，\n            // 因此如果 prototype 有自定义属性或者方法，那么可以判定为类或者构造函数，因此这里的判断是大于 1\n            // 注意不要使用 Object.keys 进行判断，Object.keys 无法获取 Object.defineProperty 定义的属性\n            Object.getOwnPropertyNames(fn.prototype).length > 1\n          );\n          // TODO: 没有 constructor 的构造函数识别、class 识别、function Person() {} 识别等\n          // 例如 function Person {};  Person.prototype = {}; 此时没有 prototype.constructor 属性\n        }\n\n        // 修复 window.alert、window.addEventListener 等报错 Illegal invocation 的问题\n        // window.alert 内部的 this 不是指向 iframe 的 window，而是指向被代理后的 proxy，因此在调用 alert 等原生函数会报错 Illegal invocation\n        // 因此这里需要重新将这些原生 native api 的 this 修正为 iframe 的 window\n        getTargetValue(target, prop) {\n          const value = target[prop];\n\n          // 过滤出 window.alert、window.addEventListener 等 API\n          if (\n            typeof value === "function" &&\n            !this.isBoundedFunction(value) &&\n            !this.isConstructable(value)\n          ) {\n\n            console.log(\'修正 this: \', prop);\n\n            // 修正 value 的 this 指向为 target\n            const boundValue = Function.prototype.bind.call(value, target);\n            // 重新恢复 value 在 bound 之前的属性和原型（bind 之后会丢失）\n            for (const key in value) {\n              boundValue[key] = value[key];\n            }\n            // 如果原来的函数存在 prototype 属性，而 bound 之后丢失了，那么重新设置回来\n            if (\n              value.hasOwnProperty("prototype") &&\n              !boundValue.hasOwnProperty("prototype")\n            ) {\n              boundValue.prototype = value.prototye;\n            }\n            return boundValue;\n          }\n          return value;\n        }\n\n        proxyIframeWindow() {\n          this.iframeWindow.proxy = new Proxy(this.iframeWindow, {\n            get: (target, prop) => {\n              // console.log("get target prop: ", prop);\n\n              // TODO: 这里只是课程演示，主要用于解决 src:about:blank 下的 history 同域问题，并没有真正设计主子应用的路由冲突问题，后续的课程会进行该设计\n              // 思考：为了防止 URL 冲突问题，是否也可以形成设计规范，比如主应用采用 History 路由，子应用采用 Hash 路由，从而确保主子应用的路由不会产生冲突的问题\n              if (prop === "history" || prop === "location") {\n                return window[prop];\n              }\n\n              if (prop === "window" || prop === "self") {\n                return this.iframeWindow.proxy;\n              }\n\n              return this.getTargetValue(target, prop);\n            },\n\n            set: (target, prop, value) => {\n  \n              target[prop] = value;\n              return true;\n            },\n\n            has: (target, prop) => true,\n          });\n        }\n\n        execScript() {\n          const scriptElement =\n            this.iframeWindow.document.createElement("script");\n          scriptElement.textContent = `\n              (function(window) {\n                with(window) {\n                  ${this.options.scriptText}\n                }\n              }).bind(window.proxy)(window.proxy);\n              `;\n          this.iframeWindow.document.head.appendChild(scriptElement);\n        }\n\n        // 激活\n        async active() {\n          this.iframe.style.display = "block";\n          // 如果已经通过 Script 加载并执行过 JS，则无需重新加载处理\n          if (this.execScriptFlag) return;\n          this.execScript();\n          this.execScriptFlag = true;\n        }\n\n        // 失活\n        // INFO: JS 加载以后无法通过移除 Script 标签去除执行状态\n        // INFO: 因此这里不是指代失活 JS，如果是真正想要失活 JS，需要销毁 iframe 后重新加载 Script\n        inactive() {\n          this.iframe.style.display = "none";\n        }\n\n        // 销毁沙箱\n        destroy() {\n          this.options = null;\n          this.exec = false;\n          if (this.iframe) {\n            this.iframe.parentNode?.removeChild(this.iframe);\n          }\n          this.iframe = null;\n        }\n      }\n\n      // 微应用管理\n      class MicroAppManager {\n        // 缓存微应用的脚本文本（这里假设只有一个执行脚本）\n        scriptText = "";\n        // 隔离实例\n        sandbox = null;\n        // 微应用挂载的根节点\n        rootElm = null;\n\n        constructor(rootElm, app) {\n          this.rootElm = rootElm;\n          this.app = app;\n        }\n\n        // 获取 JS 文本（微应用服务需要支持跨域请求）\n        async fetchScript(src) {\n          try {\n            const res = await window.fetch(src);\n            return await res.text();\n          } catch (err) {\n            console.error(err);\n          }\n        }\n\n        // 激活\n        async active() {\n          // 缓存资源处理\n          if (!this.scriptText) {\n            this.scriptText = await this.fetchScript(this.app.script);\n          }\n\n          // 如果没有创建沙箱，则实时创建\n          // 需要注意只给激活的微应用创建 iframe 沙箱，因为创建 iframe 会产生内存损耗\n          if (!this.sandbox) {\n            this.sandbox = new IframeSandbox({\n              rootElm: this.rootElm,\n              scriptText: this.scriptText,\n              url: this.app.script,\n              id: this.app.id,\n            });\n          }\n\n          this.sandbox.active();\n        }\n\n        // 失活\n        inactive() {\n          this.sandbox?.inactive();\n        }\n      }\n\n      // 微前端管理\n      class MicroManager {\n        // 微应用实例映射表\n        appsMap = new Map();\n        // 微应用挂载的根节点信息\n        rootElm = null;\n\n        constructor(rootElm, apps) {\n          this.rootElm = rootElm;\n          this.setAppMaps(apps);\n        }\n\n        setAppMaps(apps) {\n          apps.forEach((app) => {\n            this.appsMap.set(app.id, new MicroAppManager(this.rootElm, app));\n          });\n        }\n\n        // TODO: prefetch 微应用\n        prefetchApps() {}\n\n        // 激活微应用\n        activeApp(id) {\n          const current = this.appsMap.get(id);\n          current && current.active();\n        }\n\n        // 失活微应用\n        inactiveApp(id) {\n          const current = this.appsMap.get(id);\n          current && current.inactive();\n        }\n      }\n\n      // 主应用管理\n      class MainApp {\n        microApps = [];\n        microManager = null;\n\n        constructor() {\n          this.init();\n        }\n\n        async init() {\n          this.microApps = await this.fetchMicroApps();\n          this.createNav();\n          this.navClickListener();\n          this.hashChangeListener();\n          // 创建微前端管理实例\n          this.microManager = new MicroManager(\n            document.getElementById("container"),\n            this.microApps\n          );\n        }\n\n        // 从主应用服务器获请求微应用列表信息\n        async fetchMicroApps() {\n          try {\n            const res = await window.fetch("/microapps", {\n              method: "post",\n            });\n            return await res.json();\n          } catch (err) {\n            console.error(err);\n          }\n        }\n\n        // 根据微应用列表创建主导航\n        createNav(microApps) {\n          const fragment = new DocumentFragment();\n          this.microApps?.forEach((microApp) => {\n            // TODO: APP 数据规范检测 (例如是否有 script）\n            const button = document.createElement("button");\n            button.textContent = microApp.name;\n            button.id = microApp.id;\n            fragment.appendChild(button);\n          });\n          nav.appendChild(fragment);\n        }\n\n        // 导航点击的监听事件\n        navClickListener() {\n          const nav = document.getElementById("nav");\n          nav.addEventListener("click", (e) => {\n            // 并不是只有 button 可以触发导航变更，例如 a 标签也可以，因此这里不直接处理微应用切换，只是改变 Hash 地址\n            // 不会触发刷新，类似于框架的 Hash 路由\n            window.location.hash = event?.target?.id;\n          });\n        }\n\n        // hash 路由变化的监听事件\n        hashChangeListener() {\n          // 监听 Hash 路由的变化，切换微应用（这里设定一个时刻只能切换一个微应用）\n          window.addEventListener("hashchange", () => {\n            this.microApps?.forEach(async ({ id }) => {\n              id === window.location.hash.replace("#", "")\n                ? this.microManager.activeApp(id)\n                : this.microManager.inactiveApp(id);\n            });\n          });\n        }\n      }\n\n      new MainApp();\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsx)(e.p,{children:"可以发现在空白 iframe 隔离的基础上增强了能力设计："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["解决了 iframe ",(0,r.jsx)(e.code,{children:'src="about:blank"'})," 时的 ",(0,r.jsx)(e.code,{children:"history"})," 报错问题"]}),"\n",(0,r.jsx)(e.li,{children:"后续还可以增强子应用和主应用的 URL 同步问题"}),"\n",(0,r.jsx)(e.li,{children:"DOM 环境天然隔离，但是无法处理 Modal 相对于主应用的居中问题"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本课程主要讲解了如何利用 iframe + Proxy 实现 JS 隔离，该隔离在 iframe 隔离的基础上解决了 ",(0,r.jsx)(e.code,{children:"history"})," 的报错问题，从而可以兼容 Vue 或者 React 框架的隔离执行。当然，由于微应用和主应用共用 ",(0,r.jsx)(e.code,{children:"history"}),"，还可以额外去实现主子应用的历史会话同步问题。由于 Proxy 存在浏览器兼容性，在下一节课程中我们会简单讲解快照隔离方案。"]})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}let w=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F13.%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%9Aiframe%20%2B%20Proxy%20%E9%9A%94%E7%A6%BB.md"]={toc:[{text:"隔离思路",id:"隔离思路",depth:2},{text:"Proxy",id:"proxy",depth:2},{text:"Proxy + With",id:"proxy--with",depth:2},{text:"修正 `this` 指向",id:"修正-this-指向",depth:2},{text:"隔离方案设计",id:"隔离方案设计",depth:2},{text:"小结",id:"小结",depth:2}],title:"13.原理解析：iframe + Proxy 隔离",headingTitle:"13.原理解析：iframe + Proxy 隔离",frontmatter:{}}}}]);