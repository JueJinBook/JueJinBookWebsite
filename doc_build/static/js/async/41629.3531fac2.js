"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["41629"],{846469:function(n,s,e){e.r(s),e.d(s,{default:()=>t});var r=e(552676),i=e(740453);let c=e.p+"static/image/5ca875709df56632e3cd114ae42616aa.b83de59c.webp",d=e.p+"static/image/59a4c3d381eb444178e57a69f3e0bb2d.2c27f6e1.webp",l=e.p+"static/image/16889ad3537ed777300d5666cc7b7e73.5b7fa68e.webp",h=e.p+"static/image/b87ebcb18391c688b9b81d262a31b924.7e37dbee.webp";function j(n){let s=Object.assign({p:"p",strong:"strong",h1:"h1",a:"a",img:"img",ul:"ul",li:"li"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.p,{children:["目前，主流的 C 端网站，它们都会采用服务器端渲染（简称：SSR）的方式去进行网页应用的开发，类似大家熟知的掘金、CSDN、博客园，或是字节官网、淘系官网等。我们的官网实战项目，架构选型上也会选择 SSR。那么你有没有想过，",(0,r.jsx)(s.strong,{children:"为什么 SSR 会广泛用于 C 端"})," ",(0,r.jsx)(s.strong,{children:"网站"})," ",(0,r.jsx)(s.strong,{children:"？"})]}),"\n",(0,r.jsx)(s.p,{children:"在解释这个问题前，我们需要先来了解一下浏览器渲染一个网页是怎样的一个过程。"}),"\n",(0,r.jsxs)(s.h1,{id:"2架构选型ssr-为什么广泛应用于-c端网站",children:["2.架构选型：SSR 为什么广泛应用于 C端网站？",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#2架构选型ssr-为什么广泛应用于-c端网站",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)("img",{src:h,alt:"image.png"}),"\n浏览器渲染一个网页，简单来说可以分为以下几个步骤："]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["HTML 解析：在这个过程之前，浏览器会进行 DNS 解析及 TCP 握手等网络协议相关的操作，来与用户需要访问的域名服务器建议连接，域名服务器会给用户返回一个 HTML 文本用于后面的渲染 ",(0,r.jsx)(s.strong,{children:"（这一点很关键，要注意）。"})]}),"\n"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"渲染树的构建：浏览器客户端在收到服务端返回的 HTML 文本后，会对 HTML 的文本进行相关的解析，其中 DOM 会用于生成 DOM 树来决定页面的布局结构，CSS 则用于生成 CSSOM 树来决定页面元素的样式。如果在这个过程遇到脚本或是静态资源，会执行预加载对静态资源进行提前请求，最后将它们生成一个渲染树。"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"布局：浏览器在拿到渲染树后，会进行布局操作，来确定页面上每个对象的大小和位置，再进行渲染。"}),"\n"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"渲染：我们电脑的视图都是通过 GPU 的图像帧来显示出来的，渲染的过程其实就是将上面拿到的渲染树转化成 GPU 的图像帧来显示。首先浏览器会根据布局树的位置进行栅格化（用过组件库的同学应该不陌生，就是把页面按行列分成对应的层，比如 12 栅格，根据对应的格列来确定位置），最后得到一个合成帧，包括文本、颜色、边框等，最后将合成帧提升到 GPU 的图像帧，进而显示到页面中，就可以在电脑上看到我们的页面了。"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"相信看到这里，大家对浏览器怎么渲染出一个页面已经有了大致的了解。页面的绘制其实就是浏览器将 HTML 文本转化为对应页面帧的过程，页面的内容及渲染过程与第一步拿到的 HTML 文本是紧密相关的。"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"而服务器端渲染对 C 端"})," ",(0,r.jsx)(s.strong,{children:"网站"})," ",(0,r.jsx)(s.strong,{children:"的优势，主要也是在于它拿到的 HTML 不同。"})," 这样的差异，会给 Web 应用带来不同的表现。"]}),"\n",(0,r.jsxs)(s.h1,{id:"易传播性-ssr爬虫精度更高",children:[(0,r.jsx)(s.strong,{children:"易传播性："})," ",(0,r.jsx)(s.strong,{children:"SSR爬虫精度更高"}),(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#易传播性-ssr爬虫精度更高",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["我们知道，相比于 B 端网站，C 端 Web 应用更要求",(0,r.jsx)(s.strong,{children:"易传播性和交互稳定性"}),"。如果B端管理平台，即使在浏览器上搜不到、不好用、卡顿，甚至死机，用户可能会因为公司要求或是选择有限而强制使用。但是没有人可以强迫你使用一个 C 端网站 ",(0,r.jsx)(s.strong,{children:"。"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"相比"})," ",(0,r.jsx)(s.strong,{children:"客户端渲染"})," ",(0,r.jsx)(s.strong,{children:"，服务端渲染可以有效提高搜索引擎爬取的精度，进而提高网站的易传播性。"})]}),"\n",(0,r.jsx)(s.p,{children:"浏览器的推广程度，取决于搜索引擎对站点检索的排名，搜索引擎可以理解是一种爬虫，它会爬取指定页面的 HTML，并根据用户输入的关键词对页面内容进行排序检索，最后形成我们看到的结果。"}),"\n",(0,r.jsxs)(s.p,{children:["页面渲染过程中，HTML 解析过程中从服务器端拉取的 HTML 并不是页面最终预期的结果，对于一些高级爬虫，会待页面渲染完成后进行页面数据的拉取和关键词匹配，但是也有一些低级爬虫，它们爬取的将是服务器端拉取的 HTML，",(0,r.jsx)(s.strong,{children:"那么服务器端拉取下来的HTML中包含的实际页面关键词和数据越多，搜索引擎匹配的精度也会越高。"})]}),"\n",(0,r.jsx)(s.p,{children:"SSR 会在服务器端完成对页面数据数据的请求，将对应数据注入 DOM 一同返回，会得到一个完整可预览的 HTML。以掘金首页举例，可以看到下图服务器端拉取的 HTML 是包含这个页面中所将展示的实际数据。"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)("img",{src:d,alt:"image.png"}),"\n而对于客户端渲染，数据的拉取将会在客户端完成，请求服务器拿到的 HTML 将是一个空的包含有执行脚本的 HTML，也就是说，客户端渲染页面的服务器响应的 HTML 并不包含页面中实际数据，也可以参考下图一个 B 端管理平台的 HTML 响应。"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(s.p,{children:["服务器端渲染和客户端渲染的差异，",(0,r.jsx)(s.strong,{children:"决定了服务器端渲染在"})," ",(0,r.jsx)(s.strong,{children:"爬虫"})," ",(0,r.jsx)(s.strong,{children:"关键词爬取的精准度上会远胜客户端渲染，使得站点更容易获得相关关键词更高的排名。"})]}),"\n",(0,r.jsxs)(s.h1,{id:"交互稳定性-ssr-更高效",children:[(0,r.jsx)(s.strong,{children:"交互稳定性："})," ",(0,r.jsx)(s.strong,{children:"SSR"})," ",(0,r.jsx)(s.strong,{children:"更高效"}),(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#交互稳定性-ssr-更高效",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["交互稳定性，这个也与服务器端渲染和客户端渲染的 HTML 差异有关。对于客户端渲染，实际的数据需要在执行脚本后请求数据后才可以得到，而对于服务器端渲染，数据请求的过程在在服务器端已经完成了，",(0,r.jsx)(s.strong,{children:"这就使得服务器渲染将不再需要进行数据请求，可以拥有更短的首屏时间。"})]}),"\n",(0,r.jsx)(s.p,{children:"所以，官网作为 C 端网站的一种，架构选型上我们也会选取服务器端渲染来进行开发。"}),"\n",(0,r.jsxs)(s.h1,{id:"小结",children:["小结",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"本章我们学习了 浏览器渲染的过程，服务器端和客户器端渲染过程的差异， 因为服务器端渲染包含了完整页面 Dom 的 HTML 文本，可以获得精度更高的 SEO，同样也因为这个特性，服务器端渲染在客户端需要执行的脚本更少，首屏时间很短，用户体验更佳。这就是服务器端渲染为什么广泛应用于 C 端网站的原因。"}),"\n",(0,r.jsx)(s.p,{children:"选好了开发的架构，那么下一章开始，我们将就服务器端渲染原理的架构原理进行学习，从零手写一个 SSR 框架项目，你将会了解到服务器端渲染内部究竟是怎么实现的。"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,i.ah)(),n.components);return s?(0,r.jsx)(s,{...n,children:(0,r.jsx)(j,{...n})}):j(n)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["SSR%20%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%98%E7%BD%91%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F2.%E6%9E%B6%E6%9E%84%E9%80%89%E5%9E%8B%EF%BC%9ASSR%20%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8%E4%BA%8E%20C%E7%AB%AF%E7%BD%91%E7%AB%99%EF%BC%9F.md"]={toc:[],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);