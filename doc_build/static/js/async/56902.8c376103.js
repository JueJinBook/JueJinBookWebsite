"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56902"],{504880:function(n,s,e){e.r(s),e.d(s,{default:()=>t});var r=e(552676),i=e(740453);let h=e.p+"static/image/8963ddb17a36f70bde38276a0cca4e97.9b68b15a.webp",d=e.p+"static/image/5b950d7dbaebc4fb9272d944e9cf5623.6f1831d2.webp";function l(n){let s=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",ul:"ul",li:"li",h3:"h3",img:"img",ol:"ol",blockquote:"blockquote",code:"code",pre:"pre"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.h1,{id:"7架构模板设计",children:["7.架构：模板设计",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#7架构模板设计",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"在低代码开发中，除了基础组件与物料之外，模板也是必不可少的模块，是基于物料之上的更高级的产物，除了具备业务属性之外会更偏向专属的技术领域，例如可视化大屏、数据分析、中台管理等。"}),"\n",(0,r.jsxs)(s.p,{children:["此外",(0,r.jsx)(s.strong,{children:"模板通常是比较完整的应用程序结构，可以快速创建一个具有基本功能的应用程序，并且可以根据需要进行修改和扩展"}),"，不再单单只有前端可见的内容，会与对应的业务绑定更深，比如电商、",(0,r.jsx)(s.strong,{children:"CRM"}),"、",(0,r.jsx)(s.strong,{children:"CMS"})," 等。"]}),"\n",(0,r.jsx)(s.p,{children:"本章节就来带各位同学一起学习低代码中模板的相关设计。"}),"\n",(0,r.jsxs)(s.h2,{id:"模板中心",children:["模板中心",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#模板中心",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"在设计低代码模板的时候，往往需要考虑以下几点："}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"什么用户需要来使用模板"}),"？"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"模板具体需要做哪些事情"}),"？"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"怎么有效管理模板"}),"？"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"对此，我们的模板中心需要具备如下的能力："}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"业务需求"}),"：了解目标用户的需求和场景，以便针对具体实施事物进行设计，从而带来更好的用户产品体验；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"灵活可用"}),"：设计易于使用的界面和流程，将复杂度收敛到底层维护，让用户能够更流畅的完成任务；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"可维护性"}),"：打造标准化、自动化的模板管理方案，能够更加方便的管理平台内的通用模板的创建、修改、发布等相关事宜。"]}),"\n"]}),"\n",(0,r.jsxs)(s.h3,{id:"功能设计",children:["功能设计",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#功能设计",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"如使用物料平台来管理组件一样，我们也需要一个可视化的模板中心来统一管理各种丰富的模板库，包括不同领域行业能力的应用，如企业人事管理、物流管理、电商报表平台、意见收集、疫情管控等标准化的能力，提供可视化的能力方便用户使用。"}),"\n",(0,r.jsx)(s.p,{children:"如下原型图所示。在设计初期，模板中心大体上需要具备以下几个功能："}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"模板分类"}),"：为了方便用户查找和选择模板，模板中心需要进行分类，如按行业、领域、应用功能等分类，提供细致化的市场管理；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"预览查阅"}),"：用户可以先查阅模板的具体效果和功能，再决定是否进行安装使用；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"模板发布"}),"：需要设计将应用发布为模板的能力，使用者可以将自己的想法和经验发布到模板中心，更好地管理自己的应用，方便团队其他成员和自己复用能力；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"模板管理"}),"：需要设计管理员和用户相应的模板管理能力，可以对其进行删除和更新等行为。在这之上可以扩展相关数据能力，如收藏、喜欢、下载排行等 ",(0,r.jsx)(s.strong,{children:"Rank"})," 功能。"]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"与常规的搭建不同的是，模板中心的使用者一般都是对开发并不熟悉的普通人，所以物料市场在开发的过程中一定要提供非常完善的功能，尽可能减少用户的理解与使用成本。"}),"\n"]}),"\n",(0,r.jsxs)(s.h3,{id:"发布为模板",children:["发布为模板",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#发布为模板",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"既然模板中心拥有能够管理示例模版的功能，那么理所应当的编辑器方面就需要在发布中开辟一条支线功能，那就是将当前的应用发布成为模板。"}),"\n",(0,r.jsxs)(s.p,{children:["比如，公司销售员工小张需要做一个销售客户信息收集表，需要用户录入信息且进行数据管理。此时小张就使用平台搭建了一个简单的应用完成自己的工作。但是过了一段时间，小张的几个同事也有类似的需求，那么小张就可以将其发布为模板，他的同事就可以 ",(0,r.jsx)(s.strong,{children:"Fork"})," 当前模板到自己的编辑器下进行一些字段信息的修改和调整，从而快速满足自己需求的应用。"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["所以模板也可以看成更高级的复合物料，由当前领域的熟练工按照业务需求使用基础的物料配置一个模板，通过模板市场可以提供给不熟悉开发模式，或者对当前领域并不熟悉的人使用，如果熟悉淘宝装修的话，也可以理解一些设计功底好的运营配置好各种不同的营销店铺模板提供给小 ",(0,r.jsx)(s.strong,{children:"B"})," 商家使用。"]}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"模板工程",children:["模板工程",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#模板工程",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["尽管低代码平台可以大大减少应用程序开发的时间和成本，",(0,r.jsx)(s.strong,{children:"但基于 Schema 配置出来的功能一定是平台内置的且要保持最大程度的通用性"}),"，所以在一些特殊的情况下依旧需要进行一些二次开发，和一些相应的配置及逻辑的修改。"]}),"\n",(0,r.jsxs)(s.p,{children:["因此，低代码平台通常会提供",(0,r.jsx)(s.strong,{children:"运行时渲染"}),"和",(0,r.jsx)(s.strong,{children:"代码工程生成"}),"这两种产物结构，使得用户可以查看和编辑由平台生成的代码。这个机制可以是一个内置的代码编辑器，也可以是一种将代码导出为标准工程项目的功能。通过这种方式，用户可以在需要时",(0,r.jsx)(s.strong,{children:"查看"}),"和",(0,r.jsx)(s.strong,{children:"编辑"}),"代码，从而更好地控制他们的应用程序完成需求开发。"]}),"\n",(0,r.jsxs)(s.p,{children:["如果需要实现这种工程，我们就需要抽离出一套通用模板提供给",(0,r.jsx)(s.strong,{children:"出码生成器"}),"，将 ",(0,r.jsx)(s.strong,{children:"Schema"})," 中约定的协议注入到模板工程当中，最后不管是在线编码还是导出二开都由用户自己决定。"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["导出二开有一个非常严重的问题，就是产物很容易脱离原有的 ",(0,r.jsx)(s.strong,{children:"Schema"})," 架构。一旦脱离了 ",(0,r.jsx)(s.strong,{children:"Schema"})," 的架构，这个项目就很难再次使用低代码模式去迭代了，如果想长期迭代，最好还是在线编码，约束开发者的编码界限。"]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["即使导出二开有上述弊端，依然有其存在的价值，基础的功能都可以通过低代码配置完毕，而且通过模板渲染出来 ",(0,r.jsx)(s.strong,{children:"ProCode"})," 产物，从代码风格、命名规范、安全性等来说都能达到较高的水准，给未来的项目迭代打一个好底子。"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"模板工程是指一种预先配置好的代码项目，它包含了一些基本的代码结构、依赖库、配置文件等内容。"}),"\n",(0,r.jsxs)(s.p,{children:["在团队中，我们往往都会有自己的脚手架（",(0,r.jsx)(s.strong,{children:"CLI"}),"）工具，其中一定会具备通用项目的拉取和创建。"]}),"\n",(0,r.jsxs)(s.p,{children:["哪怕团队规模小，也不会完完全全从 ",(0,r.jsx)(s.strong,{children:"0"})," 到 ",(0,r.jsx)(s.strong,{children:"1"})," 去搭建一个新的项目，都是利用已经封装好的一些特定模板项目来直接开发。这就是我们常说的模板工程了。比如 ",(0,r.jsx)(s.strong,{children:"Vite"})," 在初始化项目时，可以通过 ",(0,r.jsx)(s.code,{children:"--template [template name]"})," 来指定需要生成的项目类型，以此来生成一个开箱即用的环境。"]}),"\n",(0,r.jsxs)(s.p,{children:["通常情况下，一个模板工程会包含一些通用的功能和模块，例如",(0,r.jsx)(s.strong,{children:"路由"}),"、",(0,r.jsx)(s.strong,{children:"状态管理"}),"、",(0,r.jsx)(s.strong,{children:"主题"}),"等，开发者可以在这个基础上进行扩展和定制。在低代码平台中，整个模板工程的基础模块通常会取决于产品的协议和工程的设计，基于这个基础之上才能保证后续生成的项目工程具备一定的扩展能力和可用性。"]}),"\n",(0,r.jsxs)(s.h2,{id:"生成代码",children:["生成代码",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#生成代码",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["开头就介绍了我们是通过",(0,r.jsx)(s.code,{children:"Schema"}),"的通用协议来生成代码的，那么如何将 ",(0,r.jsx)(s.strong,{children:"Schema"})," 协议输出成完整的代码文件呢？"]}),"\n",(0,r.jsx)(s.p,{children:"此时就需要用到一个前端历史发展以来最常见的技术，也就是模板引擎。通过模板引擎定义好渲染规则来插入相应的内容，最后将其输出成为一系列的文件夹与文件，最后插入到模板工程当中，就可以进行打包下载了。"}),"\n",(0,r.jsxs)(s.p,{children:["如果有同学做过通过 ",(0,r.jsx)(s.strong,{children:"Swagger"}),"、",(0,r.jsx)(s.strong,{children:"OpenApi"})," 等接口协议生成本地 ",(0,r.jsx)(s.strong,{children:"Axios"})," 接口和 ",(0,r.jsx)(s.strong,{children:"TypeScript"})," 的类型的同学获取就会比较清楚内部的一些实现逻辑："]}),"\n",(0,r.jsxs)(s.p,{children:["如下示例所示：\n这是我早期写过的一个接口生成器 ",(0,r.jsx)(s.strong,{children:"tpl"}),"，它是基于 ",(0,r.jsx)(s.strong,{children:"ArtTemplate"})," 的规则来实现的，通过拉取 yapi 或者 ",(0,r.jsx)(s.strong,{children:"Swagger"})," 的相关 ",(0,r.jsx)(s.strong,{children:"JSON"})," ",(0,r.jsx)(s.strong,{children:"Schema"})," 解析，通过以下提前声明好的模板配置，传入相关的数据就可以生成对应的接口请求函数文件。"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-xml",children:"import request from '{{requestImportResolve}}'\n\nconst {{name}} = (allParams, options) => {\n\n  {{set isParams = params.length > 0}}\n  {{set isQuery = query.length > 0}}\n  {{if isQuery || isParams}}\n  const {\n    {{if isParams}}\n      {{ each params }}\n        {{$value}},\n      {{/each}}\n    {{/if}}\n    {{if isQuery}}\n      {{ each query }}\n        {{$value}},\n      {{/each}}\n    {{/if}}\n    ...data\n  } = allParams\n  {{/if}}\n\n  return request(`{{path}}`, {\n    method: '{{method}}',\n    params: {\n      {{each query}}\n        {{$value}},\n      {{/each}}\n    },\n    data: {{isQuery || isParams ? 'data' : 'allParams'}}\n    \n  })\n}\n\nexport default {{name}}\n"})}),"\n",(0,r.jsx)(s.p,{children:"当所有文件生成完毕后，就可以写入到本地目录。此时一个简单的接口代码生成器就完成了。"}),"\n",(0,r.jsx)(s.p,{children:"低代码平台的模板渲染也是一个道理，不过相比于生成接口请求而言，页面生成更加复杂，需要将国际化多语言、动态表达式、页面异步资源依赖、数据源等都做一个通用的生成处理。这里先简单做一个初步了解，后续在实现的时候会一步步去进行实现。"}),"\n",(0,r.jsxs)(s.p,{children:["如下图所示，左侧是之前在协议篇提到过的基础协议结构，右侧则是模板工程的结构。在后面的实现过程中，会提供一个 ",(0,r.jsx)(s.strong,{children:"@lgnition-lowcode/generate"})," 包来完成以下 ",(0,r.jsx)(s.strong,{children:"Schema"})," 协议转换到模板工程的转换逻辑。"]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsxs)(s.h3,{id:"模板引擎对比",children:["模板引擎对比",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#模板引擎对比",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"市面上有很多非常优质的模板引擎开源项目，已经获得了很多知名项目的认可。在这里我就简单列举一些我个人觉得不错的项目："}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Handlebars.js"}),"：它使用基于标记的模板语言，支持条件、迭代、部分和帮助程序。它易于学习和使用，并且具有广泛的社区支持；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Mustache"}),"：也是基于标记的模板引擎，它的语法简单易懂，易于学习和使用。它支持条件、迭代和部分，可用于多种编程语言，并且有大量的社区支持；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"EJS"}),"：基于 ",(0,r.jsx)(s.strong,{children:"JavaScript"})," 的模板引擎，它使用嵌入式 ",(0,r.jsx)(s.strong,{children:"JavaScript"})," 作为模板语言，支持条件、迭代和部分。它易于学习和使用，可以轻松地与 ",(0,r.jsx)(s.strong,{children:"Node.js"})," 和 ",(0,r.jsx)(s.strong,{children:"Express.js"})," 等 ",(0,r.jsx)(s.strong,{children:"Web"})," 框架集成；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"doT.js"}),"：大小只有 ",(0,r.jsx)(s.strong,{children:"4KB"}),"，渲染性能很好，支持原生的写法，无过多的三方依赖；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"art-template"}),": 是一个简单且超快的模板引擎，它通过范围预声明技术优化模板渲染速度，从而实现接近 ",(0,r.jsx)(s.strong,{children:"JavaScript"})," 极限的运行时性能。同时，它同时支持 ",(0,r.jsx)(s.strong,{children:"Node.js"})," 和浏览器;"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Nunjucks"}),": 它允许在应用程序中使用类似 ",(0,r.jsx)(s.strong,{children:"HTML"})," 的模板语言，从而快速生成动态内容。",(0,r.jsx)(s.strong,{children:"Nunjucks"})," 支持变量、条件语句、循环语句、过滤器等基本语法，同时还支持继承、包含、宏等高级特性，可以用来创建复杂的模板结构。"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["由于我们未来的模板生成具备一定的复杂度，所以最终这个产品的模板引擎将选择 ",(0,r.jsx)(s.strong,{children:"Nunjucks"}),"，具体的开发介绍将在后续的文章中进行。"]}),"\n",(0,r.jsxs)(s.h2,{id:"总结",children:["总结",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"本章节主要讲了模版相关的设计与我们需要实现的模块。"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"模版工程"}),"：提供了应用代码的生成下载，可以具备应用独立部署和二开调整的能力。"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"模板中心"}),"：提供了通用解决方案的页面与应用的快速生成。"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"通过以上功能，用户可以根据业务需求进行自定义和调整，同时将低代码平台的适用人群扩大，还降低了用户的学习与使用成本。"}),"\n",(0,r.jsxs)(s.h2,{id:"写在最后",children:["写在最后",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#写在最后",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"如果你有什么疑问或者更好的建议，欢迎在评论区提出或者加群沟通。 \uD83D\uDC4F"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,i.ah)(),n.components);return s?(0,r.jsx)(s,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let t=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F7.%E6%9E%B6%E6%9E%84%EF%BC%9A%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1.md"]={toc:[{text:"模板中心",id:"模板中心",depth:2},{text:"功能设计",id:"功能设计",depth:3},{text:"发布为模板",id:"发布为模板",depth:3},{text:"模板工程",id:"模板工程",depth:2},{text:"生成代码",id:"生成代码",depth:2},{text:"模板引擎对比",id:"模板引擎对比",depth:3},{text:"总结",id:"总结",depth:2},{text:"写在最后",id:"写在最后",depth:2}],title:"7.架构：模板设计",headingTitle:"7.架构：模板设计",frontmatter:{}}}}]);