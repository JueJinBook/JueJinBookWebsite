"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["45101"],{592028:function(e,n,c){c.r(n),c.d(n,{default:()=>a});var r=c(552676),d=c(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",ul:"ul",li:"li",strong:"strong"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"5字符串的新增方法",children:["5.字符串的新增方法",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5字符串的新增方法",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章介绍字符串对象的新增方法。"}),"\n",(0,r.jsxs)(n.h2,{id:"stringfromcodepoint",children:["String.fromCodePoint()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#stringfromcodepoint",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["ES5 提供",(0,r.jsx)(n.code,{children:"String.fromCharCode()"}),"方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于",(0,r.jsx)(n.code,{children:"0xFFFF"}),"的字符。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'String.fromCharCode(0x20BB7)\n// "ஷ"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"String.fromCharCode()"}),"不能识别大于",(0,r.jsx)(n.code,{children:"0xFFFF"}),"的码点，所以",(0,r.jsx)(n.code,{children:"0x20BB7"}),"就发生了溢出，最高位",(0,r.jsx)(n.code,{children:"2"}),"被舍弃了，最后返回码点",(0,r.jsx)(n.code,{children:"U+0BB7"}),"对应的字符，而不是码点",(0,r.jsx)(n.code,{children:"U+20BB7"}),"对应的字符。"]}),"\n",(0,r.jsxs)(n.p,{children:["ES6 提供了",(0,r.jsx)(n.code,{children:"String.fromCodePoint()"}),"方法，可以识别大于",(0,r.jsx)(n.code,{children:"0xFFFF"}),"的字符，弥补了",(0,r.jsx)(n.code,{children:"String.fromCharCode()"}),"方法的不足。在作用上，正好与下面的",(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法相反。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"String.fromCodePoint(0x20BB7)\n// \"\uD842\uDFB7\"\nString.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'\n// true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，如果",(0,r.jsx)(n.code,{children:"String.fromCodePoint"}),"方法有多个参数，则它们会被合并成一个字符串返回。"]}),"\n",(0,r.jsxs)(n.p,{children:["注意，",(0,r.jsx)(n.code,{children:"fromCodePoint"}),"方法定义在",(0,r.jsx)(n.code,{children:"String"}),"对象上，而",(0,r.jsx)(n.code,{children:"codePointAt"}),"方法定义在字符串的实例对象上。"]}),"\n",(0,r.jsxs)(n.h2,{id:"stringraw",children:["String.raw()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#stringraw",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["ES6 还为原生的 String 对象，提供了一个",(0,r.jsx)(n.code,{children:"raw()"}),"方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'String.raw`Hi\\n${2+3}!`\n// 实际返回 "Hi\\\\n5!"，显示的是转义后的结果 "Hi\\n5!"\n\nString.raw`Hi\\u000A!`;\n// 实际返回 "Hi\\\\u000A!"，显示的是转义后的结果 "Hi\\u000A!"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["如果原字符串的斜杠已经转义，那么",(0,r.jsx)(n.code,{children:"String.raw()"}),"会进行再次转义。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'String.raw`Hi\\\\n`\n// 返回 "Hi\\\\\\\\n"\n\nString.raw`Hi\\\\n` === "Hi\\\\\\\\n" // true\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"String.raw()"}),"方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"String.raw()"}),"本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有",(0,r.jsx)(n.code,{children:"raw"}),"属性的对象，且",(0,r.jsx)(n.code,{children:"raw"}),"属性的值应该是一个数组，对应模板字符串解析后的值。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// `foo${1 + 2}bar`\n// 等同于\nString.raw({ raw: ['foo', 'bar'] }, 1 + 2) // \"foo3bar\"\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"String.raw()"}),"方法的第一个参数是一个对象，它的",(0,r.jsx)(n.code,{children:"raw"}),"属性等同于原始的模板字符串解析后得到的数组。"]}),"\n",(0,r.jsxs)(n.p,{children:["作为函数，",(0,r.jsx)(n.code,{children:"String.raw()"}),"的代码实现基本如下。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"String.raw = function (strings, ...values) {\n  let output = '';\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += strings.raw[index] + values[index];\n  }\n\n  output += strings.raw[index]\n  return output;\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法codepointat",children:["实例方法：codePointAt()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法codepointat",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为",(0,r.jsx)(n.code,{children:"2"}),"个字节。对于那些需要",(0,r.jsx)(n.code,{children:"4"}),"个字节储存的字符（Unicode 码点大于",(0,r.jsx)(n.code,{children:"0xFFFF"}),"的字符），JavaScript 会认为它们是两个字符。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"var s = \"\uD842\uDFB7\";\n\ns.length // 2\ns.charAt(0) // ''\ns.charAt(1) // ''\ns.charCodeAt(0) // 55362\ns.charCodeAt(1) // 57271\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，汉字“\uD842\uDFB7”（注意，这个字不是“吉祥”的“吉”）的码点是",(0,r.jsx)(n.code,{children:"0x20BB7"}),"，UTF-16 编码为",(0,r.jsx)(n.code,{children:"0xD842 0xDFB7"}),"（十进制为",(0,r.jsx)(n.code,{children:"55362 57271"}),"），需要",(0,r.jsx)(n.code,{children:"4"}),"个字节储存。对于这种",(0,r.jsx)(n.code,{children:"4"}),"个字节的字符，JavaScript 不能正确处理，字符串长度会误判为",(0,r.jsx)(n.code,{children:"2"}),"，而且",(0,r.jsx)(n.code,{children:"charAt()"}),"方法无法读取整个字符，",(0,r.jsx)(n.code,{children:"charCodeAt()"}),"方法只能分别返回前两个字节和后两个字节的值。"]}),"\n",(0,r.jsxs)(n.p,{children:["ES6 提供了",(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let s = '\uD842\uDFB7a';\n\ns.codePointAt(0) // 134071\ns.codePointAt(1) // 57271\n\ns.codePointAt(2) // 97\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“\uD842\uDFB7a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“\uD842\uDFB7”，返回了它的十进制码点 134071（即十六进制的",(0,r.jsx)(n.code,{children:"20BB7"}),"）。在第二个字符（即“\uD842\uDFB7”的后两个字节）和第三个字符“a”上，",(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法的结果与",(0,r.jsx)(n.code,{children:"charCodeAt()"}),"方法相同。"]}),"\n",(0,r.jsxs)(n.p,{children:["总之，",(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与",(0,r.jsx)(n.code,{children:"charCodeAt()"}),"方法相同。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法返回的是码点的十进制值，如果想要十六进制的值，可以使用",(0,r.jsx)(n.code,{children:"toString()"}),"方法转换一下。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'let s = \'\uD842\uDFB7a\';\n\ns.codePointAt(0).toString(16) // "20bb7"\ns.codePointAt(2).toString(16) // "61"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["你可能注意到了，",(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法的参数，仍然是不正确的。比如，上面代码中，字符",(0,r.jsx)(n.code,{children:"a"}),"在字符串",(0,r.jsx)(n.code,{children:"s"}),"的正确位置序号应该是 1，但是必须向",(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法传入 2。解决这个问题的一个办法是使用",(0,r.jsx)(n.code,{children:"for...of"}),"循环，因为它会正确识别 32 位的 UTF-16 字符。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let s = '\uD842\uDFB7a';\nfor (let ch of s) {\n  console.log(ch.codePointAt(0).toString(16));\n}\n// 20bb7\n// 61\n"})}),"\n",(0,r.jsxs)(n.p,{children:["另一种方法也可以，使用扩展运算符（",(0,r.jsx)(n.code,{children:"..."}),"）进行展开运算。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let arr = [...'\uD842\uDFB7a']; // arr.length === 2\narr.forEach(\n  ch => console.log(ch.codePointAt(0).toString(16))\n);\n// 20bb7\n// 61\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"codePointAt()"}),"方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function is32Bit(c) {\n  return c.codePointAt(0) > 0xFFFF;\n}\n\nis32Bit("\uD842\uDFB7") // true\nis32Bit("a") // false\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法normalize",children:["实例方法：normalize()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法normalize",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如",(0,r.jsx)(n.code,{children:"Ǒ"}),"（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如",(0,r.jsx)(n.code,{children:"O"}),"（\\u004F）和",(0,r.jsx)(n.code,{children:"ˇ"}),"（\\u030C）合成",(0,r.jsx)(n.code,{children:"Ǒ"}),"（\\u004F\\u030C）。"]}),"\n",(0,r.jsx)(n.p,{children:"这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'\\u01D1'==='\\u004F\\u030C' //false\n\n'\\u01D1'.length // 1\n'\\u004F\\u030C'.length // 2\n"})}),"\n",(0,r.jsx)(n.p,{children:"上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。"}),"\n",(0,r.jsxs)(n.p,{children:["ES6 提供字符串实例的",(0,r.jsx)(n.code,{children:"normalize()"}),"方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()\n// true\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"normalize"}),"方法可以接受一个参数来指定",(0,r.jsx)(n.code,{children:"normalize"}),"的方式，参数的四个可选值如下。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"NFC"}),"，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"NFD"}),"，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"NFKC"}),"，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，",(0,r.jsx)(n.code,{children:"normalize"}),"方法不能识别中文。）"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"NFKD"}),"，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'\\u004F\\u030C'.normalize('NFC').length // 1\n'\\u004F\\u030C'.normalize('NFD').length // 2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码表示，",(0,r.jsx)(n.code,{children:"NFC"}),"参数返回字符的合成形式，",(0,r.jsx)(n.code,{children:"NFD"}),"参数返回字符的分解形式。"]}),"\n",(0,r.jsxs)(n.p,{children:["不过，",(0,r.jsx)(n.code,{children:"normalize"}),"方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法includes-startswith-endswith",children:["实例方法：includes(), startsWith(), endsWith()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法includes-startswith-endswith",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["传统上，JavaScript 只有",(0,r.jsx)(n.code,{children:"indexOf"}),"方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"includes()"}),"：返回布尔值，表示是否找到了参数字符串。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"startsWith()"}),"：返回布尔值，表示参数字符串是否在原字符串的头部。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"endsWith()"}),"：返回布尔值，表示参数字符串是否在原字符串的尾部。"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n"})}),"\n",(0,r.jsx)(n.p,{children:"这三个方法都支持第二个参数，表示开始搜索的位置。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let s = 'Hello world!';\n\ns.startsWith('world', 6) // true\ns.endsWith('Hello', 5) // true\ns.includes('Hello', 6) // false\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码表示，使用第二个参数",(0,r.jsx)(n.code,{children:"n"}),"时，",(0,r.jsx)(n.code,{children:"endsWith"}),"的行为与其他两个方法有所不同。它针对前",(0,r.jsx)(n.code,{children:"n"}),"个字符，而其他两个方法针对从第",(0,r.jsx)(n.code,{children:"n"}),"个位置直到字符串结束。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法repeat",children:["实例方法：repeat()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法repeat",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"repeat"}),"方法返回一个新字符串，表示将原字符串重复",(0,r.jsx)(n.code,{children:"n"}),"次。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'x'.repeat(3) // \"xxx\"\n'hello'.repeat(2) // \"hellohello\"\n'na'.repeat(0) // \"\"\n"})}),"\n",(0,r.jsx)(n.p,{children:"参数如果是小数，会被取整。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'na'.repeat(2.9) // \"nana\"\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如果",(0,r.jsx)(n.code,{children:"repeat"}),"的参数是负数或者",(0,r.jsx)(n.code,{children:"Infinity"}),"，会报错。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'na'.repeat(Infinity)\n// RangeError\n'na'.repeat(-1)\n// RangeError\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于",(0,r.jsx)(n.code,{children:"-0"}),"，",(0,r.jsx)(n.code,{children:"repeat"}),"视同为 0。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'na'.repeat(-0.9) // \"\"\n"})}),"\n",(0,r.jsxs)(n.p,{children:["参数",(0,r.jsx)(n.code,{children:"NaN"}),"等同于 0。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'na'.repeat(NaN) // \"\"\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如果",(0,r.jsx)(n.code,{children:"repeat"}),"的参数是字符串，则会先转换成数字。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'na'.repeat('na') // \"\"\n'na'.repeat('3') // \"nanana\"\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法padstartpadend",children:["实例方法：padStart()，padEnd()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法padstartpadend",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。",(0,r.jsx)(n.code,{children:"padStart()"}),"用于头部补全，",(0,r.jsx)(n.code,{children:"padEnd()"}),"用于尾部补全。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"padStart()"}),"和",(0,r.jsx)(n.code,{children:"padEnd()"}),"一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。"]}),"\n",(0,r.jsx)(n.p,{children:"如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'xxx'.padStart(2, 'ab') // 'xxx'\n'xxx'.padEnd(2, 'ab') // 'xxx'\n"})}),"\n",(0,r.jsx)(n.p,{children:"如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'abc'.padStart(10, '0123456789')\n// '0123456abc'\n"})}),"\n",(0,r.jsx)(n.p,{children:"如果省略第二个参数，默认使用空格补全长度。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'x'.padStart(4) // '   x'\n'x'.padEnd(4) // 'x   '\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"padStart()"}),"的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'1'.padStart(10, '0') // \"0000000001\"\n'12'.padStart(10, '0') // \"0000000012\"\n'123456'.padStart(10, '0') // \"0000123456\"\n"})}),"\n",(0,r.jsx)(n.p,{children:"另一个用途是提示字符串格式。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"\n'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\"\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法trimstarttrimend",children:["实例方法：trimStart()，trimEnd()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法trimstarttrimend",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/tc39/proposal-string-left-right-trim",target:"_blank",rel:"noopener noreferrer",children:"ES2019"})," 对字符串实例新增了",(0,r.jsx)(n.code,{children:"trimStart()"}),"和",(0,r.jsx)(n.code,{children:"trimEnd()"}),"这两个方法。它们的行为与",(0,r.jsx)(n.code,{children:"trim()"}),"一致，",(0,r.jsx)(n.code,{children:"trimStart()"}),"消除字符串头部的空格，",(0,r.jsx)(n.code,{children:"trimEnd()"}),"消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const s = \'  abc  \';\n\ns.trim() // "abc"\ns.trimStart() // "abc  "\ns.trimEnd() // "  abc"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"trimStart()"}),"只消除头部的空格，保留尾部的空格。",(0,r.jsx)(n.code,{children:"trimEnd()"}),"也是类似行为。"]}),"\n",(0,r.jsx)(n.p,{children:"除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。"}),"\n",(0,r.jsxs)(n.p,{children:["浏览器还部署了额外的两个方法，",(0,r.jsx)(n.code,{children:"trimLeft()"}),"是",(0,r.jsx)(n.code,{children:"trimStart()"}),"的别名，",(0,r.jsx)(n.code,{children:"trimRight()"}),"是",(0,r.jsx)(n.code,{children:"trimEnd()"}),"的别名。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法matchall",children:["实例方法：matchAll()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法matchall",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"matchAll()"}),"方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法replaceall",children:["实例方法：replaceAll()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法replaceall",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["历史上，字符串的实例方法",(0,r.jsx)(n.code,{children:"replace()"}),"只能替换第一个匹配。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'aabbcc'.replace('b', '_')\n// 'aa_bcc'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面例子中，",(0,r.jsx)(n.code,{children:"replace()"}),"只将第一个",(0,r.jsx)(n.code,{children:"b"}),"替换成了下划线。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果要替换所有的匹配，不得不使用正则表达式的",(0,r.jsx)(n.code,{children:"g"}),"修饰符。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'aabbcc'.replace(/b/g, '_')\n// 'aa__cc'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["正则表达式毕竟不是那么方便和直观，",(0,r.jsx)(n.a,{href:"https://github.com/tc39/proposal-string-replaceall",target:"_blank",rel:"noopener noreferrer",children:"ES2021"})," 引入了",(0,r.jsx)(n.code,{children:"replaceAll()"}),"方法，可以一次性替换所有匹配。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'aabbcc'.replaceAll('b', '_')\n// 'aa__cc'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["它的用法与",(0,r.jsx)(n.code,{children:"replace()"}),"相同，返回一个新字符串，不会改变原字符串。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"String.prototype.replaceAll(searchValue, replacement)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"searchValue"}),"是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有",(0,r.jsx)(n.code,{children:"g"}),"修饰符）。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果",(0,r.jsx)(n.code,{children:"searchValue"}),"是一个不带有",(0,r.jsx)(n.code,{children:"g"}),"修饰符的正则表达式，",(0,r.jsx)(n.code,{children:"replaceAll()"}),"会报错。这一点跟",(0,r.jsx)(n.code,{children:"replace()"}),"不同。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 不报错\n'aabbcc'.replace(/b/, '_')\n\n// 报错\n'aabbcc'.replaceAll(/b/, '_')\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面例子中，",(0,r.jsx)(n.code,{children:"/b/"}),"不带有",(0,r.jsx)(n.code,{children:"g"}),"修饰符，会导致",(0,r.jsx)(n.code,{children:"replaceAll()"}),"报错。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"replaceAll()"}),"的第二个参数",(0,r.jsx)(n.code,{children:"replacement"}),"是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"$&"}),"：匹配的字符串。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:" $` "}),"：匹配结果前面的文本。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"$'"}),"：匹配结果后面的文本。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"$n"}),"：匹配成功的第",(0,r.jsx)(n.code,{children:"n"}),"组内容，",(0,r.jsx)(n.code,{children:"n"}),"是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"$$"}),"：指代美元符号",(0,r.jsx)(n.code,{children:"$"}),"。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"下面是一些例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// $& 表示匹配的字符串，即`b`本身\n// 所以返回结果与原字符串一致\n'abbc'.replaceAll('b', '$&')\n// 'abbc'\n\n// $` 表示匹配结果之前的字符串\n// 对于第一个`b`，$` 指代`a`\n// 对于第二个`b`，$` 指代`ab`\n'abbc'.replaceAll('b', '$`')\n// 'aaabc'\n\n// $' 表示匹配结果之后的字符串\n// 对于第一个`b`，$' 指代`bc`\n// 对于第二个`b`，$' 指代`c`\n'abbc'.replaceAll('b', `$'`)\n// 'abccc'\n\n// $1 表示正则表达式的第一个组匹配，指代`ab`\n// $2 表示正则表达式的第二个组匹配，指代`bc`\n'abbc'.replaceAll(/(ab)(bc)/g, '$2$1')\n// 'bcab'\n\n// $$ 指代 $\n'abc'.replaceAll('b', '$$')\n// 'a$c'\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"replaceAll()"}),"的第二个参数",(0,r.jsx)(n.code,{children:"replacement"}),"除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数",(0,r.jsx)(n.code,{children:"searchValue"}),"匹配的文本。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"'aabbcc'.replaceAll('b', () => '_')\n// 'aa__cc'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面例子中，",(0,r.jsx)(n.code,{children:"replaceAll()"}),"的第二个参数是一个函数，该函数的返回值会替换掉所有",(0,r.jsx)(n.code,{children:"b"}),"的匹配。"]}),"\n",(0,r.jsx)(n.p,{children:"这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const str = '123abc456';\nconst regex = /(\\d+)([a-z]+)(\\d+)/g;\n\nfunction replacer(match, p1, p2, p3, offset, string) {\n  return [p1, p2, p3].join(' - ');\n}\n\nstr.replaceAll(regex, replacer)\n// 123 - abc - 456\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面例子中，正则表达式有三个组匹配，所以",(0,r.jsx)(n.code,{children:"replacer()"}),"函数的第一个参数",(0,r.jsx)(n.code,{children:"match"}),"是捕捉到的匹配内容（即字符串",(0,r.jsx)(n.code,{children:"123abc456"}),"），后面三个参数",(0,r.jsx)(n.code,{children:"p1"}),"、",(0,r.jsx)(n.code,{children:"p2"}),"、",(0,r.jsx)(n.code,{children:"p3"}),"则依次为三个组匹配。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法at",children:["实例方法：at()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法at",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"at()"}),"方法接受一个整数作为参数，返回参数指定位置的字符，支持负索引（即倒数的位置）。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const str = \'hello\';\nstr.at(1) // "e"\nstr.at(-1) // "o"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["如果参数位置超出了字符串范围，",(0,r.jsx)(n.code,{children:"at()"}),"返回",(0,r.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["该方法来自数组添加的",(0,r.jsx)(n.code,{children:"at()"}),"方法，目前还是一个第三阶段的提案，可以参考《数组》一章的介绍。"]}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法towellformed",children:["实例方法：toWellFormed()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法towellformed",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["ES2024 引入了新的字符串方法",(0,r.jsx)(n.code,{children:"toWellFormed()"}),"，用来处理 Unicode 的代理字符对问题（surrogates）。"]}),"\n",(0,r.jsxs)(n.p,{children:["JavaScript 语言内部使用 UTF-16 格式，表示每个字符。UTF-16 只有16位，只能表示码点在",(0,r.jsx)(n.code,{children:"U+0000"}),"到",(0,r.jsx)(n.code,{children:"U+FFFF"}),"之间的 Unicode 字符。对于码点大于",(0,r.jsx)(n.code,{children:"U+FFFF"}),"的 Unicode 字符（即码点大于16位的字符，",(0,r.jsx)(n.code,{children:"U+10000"}),"到",(0,r.jsx)(n.code,{children:"U+10FFFF"}),"），解决办法是使用代理字符对，即用两个 UTF-16 字符组合表示。"]}),"\n",(0,r.jsxs)(n.p,{children:["具体来说，UTF-16 规定，",(0,r.jsx)(n.code,{children:"U+D800"}),"至",(0,r.jsx)(n.code,{children:"U+DFFF"}),"是空字符段，专门留给代理字符对使用。只要遇到这个范围内的码点，就知道它是代理字符对，本身没有意义，必须两个字符结合在一起解读。其中，前一个字符的范围规定为",(0,r.jsx)(n.code,{children:"0xD800"}),"到",(0,r.jsx)(n.code,{children:"0xDBFF"}),"之间，后一个字符的范围规定为",(0,r.jsx)(n.code,{children:"0xDC00"}),"到",(0,r.jsx)(n.code,{children:"0xDFFF"}),"之间。举例来说，码点",(0,r.jsx)(n.code,{children:"U+1D306"}),"对应的字符为",(0,r.jsx)(n.code,{children:"\uD834\uDF06"}),"，它写成 UTF-16 就是",(0,r.jsx)(n.code,{children:"0xD834 0xDF06"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["但是，字符串里面可能会出现单个代理字符对，即",(0,r.jsx)(n.code,{children:"U+D800"}),"至",(0,r.jsx)(n.code,{children:"U+DFFF"}),"里面的字符，它没有配对的另一个字符，无法进行解读，导致出现各种状况。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:".toWellFormed()"}),"就是为了解决这个问题，不改变原始字符串，返回一个新的字符串，将原始字符串里面的单个代理字符对，都替换为",(0,r.jsx)(n.code,{children:"U+FFFD"}),"，从而可以在任何正常处理字符串的函数里面使用。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"\"ab\uD800\".toWellFormed() // 'ab�'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，",(0,r.jsx)(n.code,{children:"\uD800"}),"是单个的代理字符对，单独使用时没有意义。",(0,r.jsx)(n.code,{children:"toWellFormed()"}),"将这个字符转为",(0,r.jsx)(n.code,{children:"\\uFFFD"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["再看下面的例子，",(0,r.jsx)(n.code,{children:"encodeURI()"}),"遇到单个的代理字符对，会报错。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const illFormed = "https://example.com/search?q=\uD800";\n\nencodeURI(illFormed) // 报错\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"toWellFormed()"}),"将其转换格式后，再使用",(0,r.jsx)(n.code,{children:"encodeURI()"}),"就不会报错了。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const illFormed = "https://example.com/search?q=\uD800";\n\nencodeURI(illFormed.toWellFormed()) // 正确\n'})})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(s,{...e})}):s(e)}let a=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F5.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95.md"]={toc:[{text:"String.fromCodePoint()",id:"stringfromcodepoint",depth:2},{text:"String.raw()",id:"stringraw",depth:2},{text:"实例方法：codePointAt()",id:"实例方法codepointat",depth:2},{text:"实例方法：normalize()",id:"实例方法normalize",depth:2},{text:"实例方法：includes(), startsWith(), endsWith()",id:"实例方法includes-startswith-endswith",depth:2},{text:"实例方法：repeat()",id:"实例方法repeat",depth:2},{text:"实例方法：padStart()，padEnd()",id:"实例方法padstartpadend",depth:2},{text:"实例方法：trimStart()，trimEnd()",id:"实例方法trimstarttrimend",depth:2},{text:"实例方法：matchAll()",id:"实例方法matchall",depth:2},{text:"实例方法：replaceAll()",id:"实例方法replaceall",depth:2},{text:"实例方法：at()",id:"实例方法at",depth:2},{text:"实例方法：toWellFormed()",id:"实例方法towellformed",depth:2}],title:"5.字符串的新增方法",headingTitle:"5.字符串的新增方法",frontmatter:{}}}}]);