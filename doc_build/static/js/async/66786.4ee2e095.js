"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["66786"],{460012:function(e,n,s){s.r(n),s.d(n,{default:()=>x});var t=s(552676),i=s(740453);let r=s.p+"static/image/633cee110120c3c8dd32a3de25598d9e.1be1d436.webp",l=s.p+"static/image/2ea3950f9e24f845d056b075a30030dd.dfda0672.webp",d=s.p+"static/image/e5017f2650c1bb6b380ce40c38d28c3d.f3e46f25.webp",c=s.p+"static/image/ad18fef9a5630655fcb3db22fdbc7052.2ea650d1.webp",o=s.p+"static/image/c3a0c52b4511c497094f5a89ce7a9cb2.928e426c.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",img:"img",ol:"ol",li:"li",h3:"h3",code:"code",pre:"pre",em:"em",ul:"ul"},(0,i.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"6第六日谈谈组件封装",children:["6.第六日：谈谈组件封装",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6第六日谈谈组件封装",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"第一个故事首页轮播图",children:["第一个故事：首页轮播图",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一个故事首页轮播图",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["组件封装是一个前端工程师进阶的必经之路。组件封装是指Web页面上抽出来一个个包含模版（HTML）、功能（Javascript）和样式（CSS）的单元。所以，今天的内容，我们将带你了解组件封装的开发思路，让你的组件具备",(0,t.jsx)(n.strong,{children:"封装性"}),"、",(0,t.jsx)(n.strong,{children:"正确性"}),"、",(0,t.jsx)(n.strong,{children:"扩展性"}),"和",(0,t.jsx)(n.strong,{children:"复用性"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"我们以实现一个首页轮播图的UI组件为例，这个组件的效果如下图所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"上图中的组件实现了3个功能："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"四张图片循环播放，每张图片停留若干时间；"}),"\n",(0,t.jsx)(n.li,{children:"当用户点击左右两边的小箭头时，图片分别切换到上一张/下一张；"}),"\n",(0,t.jsx)(n.li,{children:"当用户点击底部的小圆点的时候，则立即跳到小圆点顺序所对应的那张图片。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"下面，我们就带你一步步实现这个组件："}),"\n",(0,t.jsxs)(n.h3,{id:"第一步确定ui组件的html结构",children:["第一步：确定UI组件的HTML结构。",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一步确定ui组件的html结构",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["根据效果图，这个组件包含了4张图片，4张图片就需要有4个HTML元素来封装。你可以采用4个块级元素来安排，比如",(0,t.jsx)(n.code,{children:"div"}),"元素等。我们也可以将这4张图看作是一个图片列表，使用列表元素作为图片的容器："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<div class="slider">\n  <ul>\n    <li class="slider__item--selected">\n      <img src="https://p5.ssl.qhimg.com/t0119c74624763dd070.png"/>\n    </li>\n    <li class="slider__item">\n      <img src="https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg"/>\n    </li>\n    <li class="slider__item">\n      <img src="https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg"/>\n    </li>\n    <li class="slider__item">\n      <img src="https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg"/>\n    </li>\n  </ul>\n  <a class="slider__next"></a>\n  <a class="slider__previous"></a>\n  <div class="slider__control">\n    <span class="slider__control-buttons--selected"></span>\n    <span class="slider__control-buttons"></span>\n    <span class="slider__control-buttons"></span>\n    <span class="slider__control-buttons"></span>\n  </div>\n</div>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["上面的HTML结构中，首先是一个大的容器，",(0,t.jsx)(n.code,{children:"div.slider"}),"，其中包含一个",(0,t.jsx)(n.code,{children:"ul"}),"列表，列表中是包含四张图片的四个",(0,t.jsx)(n.code,{children:"li"}),"元素。"]}),"\n",(0,t.jsxs)(n.p,{children:["这里，我们使用两个",(0,t.jsx)(n.code,{children:"<a>"}),"元素分别表示“下一张“和”上一张“的控制"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<a class="slider__next"></a> \n<a class="slider__previous"></a>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["用四个",(0,t.jsx)(n.code,{children:"<span>"}),"元素表示底部的四个小圆点的控制："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<div class="slider__control">\n  <span class="slider__control-buttons--selected"></span>\n  <span class="slider__control-buttons"></span>\n  <span class="slider__control-buttons"></span>\n  <span class="slider__control-buttons"></span>\n</div>\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"当然这些控制你也可以使用其他的HTML元素来表示。"})}),"\n",(0,t.jsxs)(n.p,{children:["\uD83D\uDCA1注意：这里我们使用的CSS规则名有点特别，如果你是第一次见到可能会觉得有些奇怪。实际上这里的命名是一种CSS书写规范，叫做",(0,t.jsx)(n.code,{children:"BEM"}),"，是英文",(0,t.jsx)(n.code,{children:"Block-Element-Modifier"}),"的简写。"]}),"\n",(0,t.jsxs)(n.p,{children:["这一规范采用三个部分来描述规则，首先是Block表示组件名，这个任务是写轮播图，我们给这个组件起名字叫",(0,t.jsx)(n.code,{children:"slider"}),"。然后是Element，比如对应的列表项",(0,t.jsx)(n.code,{children:"li"}),"元素，表示item，所以它的class就是",(0,t.jsx)(n.code,{children:"slider__item"}),"，这里Block和Element之间使用双下划线",(0,t.jsx)(n.code,{children:"__"}),"连接。最后是Modifier表示状态，其中一个列表的状态是",(0,t.jsx)(n.code,{children:"selected"}),"，所以最终的class是",(0,t.jsx)(n.code,{children:"slider__item--selected"}),"，这里Element和Modifier之间使用双横杠",(0,t.jsx)(n.code,{children:"--"}),"连接。"]}),"\n",(0,t.jsxs)(n.p,{children:["在比较复杂的UI组件中，使用",(0,t.jsx)(n.code,{children:"BEM"}),"有几个好处："]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"让CSS规则保持相对简单，只用一个class就能定位对应的元素，这样优先级也相对扁平，管理起来不容易冲突。"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["阅读代码的人一眼可以知道一个元素是哪个组件的哪个部分。由于组件复杂的时候，HTML代码比较长，可能元素离组件容器比较远，如果使用普通层级关系，你看到一个",(0,t.jsx)(n.code,{children:".item"}),"元素，除非找到外层的",(0,t.jsx)(n.code,{children:".slider"}),"，你才能知道它属于",(0,t.jsx)(n.code,{children:".slider"}),"组件而不是其他组件的",(0,t.jsx)(n.code,{children:".item"}),"，那样在HTML代码很复杂的时候找起来就比较费劲。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"第二步设置元素的样式",children:["第二步：设置元素的样式",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第二步设置元素的样式",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"然后根据效果图，我们给这段HTML代码添加CSS样式。"}),"\n",(0,t.jsxs)(n.p,{children:["首先，我们给",(0,t.jsx)(n.code,{children:"class=slider"}),"的",(0,t.jsx)(n.code,{children:"div"}),"元素设置了宽度和高度，以及取消",(0,t.jsx)(n.code,{children:"ul"}),"元素默认的列表样式："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-css",children:".slider {\n  position: relative;\n  width: 790px;\n  height: 340px;\n}\n\n.slider ul {\n  list-style-type:none;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  padding: 0;\n  margin: 0;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后，将",(0,t.jsx)(n.code,{children:"class=slider__item"}),"和",(0,t.jsx)(n.code,{children:"class=slider__item--selected"}),"的",(0,t.jsx)(n.code,{children:"li"}),"元素的position属性设置为绝对定位（absolute），这样就能够将这4张图片重叠显示在同一个位置。如下代码所示："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-css",children:".slider__item,\n.slider__item--selected {\n  position: absolute;\n  transition: opacity 1s;\n  opacity: 0;\n  text-align: center;\n}\n\n.slider__item--selected {\n  transition: opacity 1s;\n  opacity: 1;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["其中，",(0,t.jsx)(n.code,{children:"transition: opacity 1s"}),"表示设置图片透明度变化的动画，时间为1秒。状态为",(0,t.jsx)(n.code,{children:"slider__item"}),"时，显示为透明。状态为",(0,t.jsx)(n.code,{children:"slider__item--selected"}),"时显示为不透明。"]}),"\n",(0,t.jsx)(n.p,{children:"接着是控制元素的样式："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-css",children:".slider__next,\n.slider__previous{\n  display: inline-block;\n  position: absolute;\n  top: 50%; /*定位在录播图组件的纵向中间的位置*/\n  margin-top: -25px;\n  width: 30px;\n  height:50px;\n  text-align: center;\n  font-size: 24px;\n  line-height: 50px;\n  overflow: hidden;\n  border: none;\n  color: white;\n  background: rgba(0,0,0,0.2); /*设置为半透明*/\n  cursor: pointer; /*设置鼠标移动到这个元素时显示为手指状*/\n  opacity: 0; /*初始状态为透明*/\n  transition: opacity .5s; /*设置透明度变化的动画，时间为.5秒*/\n}\n\n.slider__previous {\n  left: 0; /*定位在slider元素的最左边*/\n}\n\n.slider__next {\n  right: 0; /*定位在slider元素的最右边*/\n}\n\n.slider:hover .slider__previous {\n  opacity: 1;\n}\n\n.slider:hover .slider__next {\n  opacity: 1;\n}\n\n.slider__previous:after {\n  content: '<';\n}\n\n.slider__next:after {\n  content: '>';\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上面的规则中，",(0,t.jsx)(n.code,{children:".slider__next, .slider__previous"}),"分别表示“向下一张”和“向上一张”的控制。初始状态下，这两个控制元素的背景色为半透明，字体颜色是白色。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:".slider:hover .slider__previous"})," 和 ",(0,t.jsx)(n.code,{children:".slider:hover .slider__next"}),"这两条规则表示当鼠标悬停在",(0,t.jsx)(n.code,{children:"class=slider"}),"的元素上时，显示左右两侧的控制元素。"]}),"\n",(0,t.jsx)(n.p,{children:"最后，定义底部四个小点的样式："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-css",children:".slider__control{\n  position: relative;\n  display: table; /* table 布局*/\n  background-color: rgba(255, 255, 255, 0.5);\n  padding: 5px;\n  border-radius: 12px;\n  bottom: 30px;\n  margin: auto;\n}\n\n.slider__control-buttons,\n.slider__control-buttons--selected{\n  display: inline-block;\n  width: 15px;\n  height: 15px;\n  border-radius: 50%;/*设置为圆形*/\n  margin: 0 5px;\n  background-color: white;\n  cursor: pointer;\n}\n\n.slider__control-buttons--selected {\n  background-color: red;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"上面的规则中，"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["第一条规则表示给四个小圆点设置一个灰色的背景。其中的",(0,t.jsx)(n.code,{children:"position: relative; display: table;"}),"声明表示将它的子元素（也就是4个小圆点）采用相对定位和table布局，让它们固定显示在图片中部下方。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"第二条规则设置了小圆点的大小，形状，默认情况下，小圆点的颜色（白色），以及鼠标滑入后的状态（pointer)"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"第三条规则表示，当选择后，小圆点的颜色变成红色。"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"第三步设计api",children:["第三步：设计API",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第三步设计api",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"页面的主体结构和样式完成之后，我们需要根据组件的功能，为该组件设计API。"}),"\n",(0,t.jsx)(n.p,{children:"我们回顾一下这个组件的需求："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"四张图片循环播放，每张图片停留若干时间；"}),"\n",(0,t.jsx)(n.li,{children:"当用户点击左右两边的小箭头时，图片分别切换到上一张/下一张；"}),"\n",(0,t.jsx)(n.li,{children:"当用户点击中下部的小圆点的时候，则立即跳到小圆点顺序所对应的那张图片。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"根据上述的需求呢，我们设计了4个组件API:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"slideTo(idx) - 切换显示idx指示位置的图片"}),"\n",(0,t.jsx)(n.li,{children:"slideNext() - 切换到下一张图"}),"\n",(0,t.jsx)(n.li,{children:"slidePrevious() - 切换到上一张图"}),"\n",(0,t.jsx)(n.li,{children:"getSelectedItem() - 获取选中的图片"}),"\n",(0,t.jsx)(n.li,{children:"getSelectedItemIndex() - 获取选中的图片的位置"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后，将这个组件封装为一个类——slider："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Slider {\n  constructor({container}) {\n    this.container = container;\n    this.items = Array.from(container.querySelectorAll('.slider__item, .slider__item--selected'));\n  }\n\n  /*\n    通过选择器`.slider__item--selected`获得被选中的元素\n  */\n  getSelectedItem() {\n    const selected = this.container.querySelector('.slider__item--selected');\n    return selected;\n  }\n\n  /*\n    返回选中的元素在items数组中的位置。\n  */\n  getSelectedItemIndex() {\n    return this.items.indexOf(this.getSelectedItem());\n  }\n\n  slideTo(idx) {\n    const selected = this.getSelectedItem();\n    if(selected) { // 将之前选择的图片标记为普通状态\n      selected.className = 'slider__item';\n    }\n    const item = this.items[idx];\n    if(item) { // 将当前选中的图片标记为选中状态\n      item.className = 'slider__item--selected';\n    }\n  }\n\n  /*\n    将下一张图片标记为选中状态\n  */\n  slideNext() {\n    const currentIdx = this.getSelectedItemIndex();\n    const nextIdx = (currentIdx + 1) % this.items.length;\n    this.slideTo(nextIdx);\n  }\n\n  /*\n    将上一张图片标记为选中状态\n  */\n  slidePrevious() {\n    const currentIdx = this.getSelectedItemIndex();\n    const previousIdx = (this.items.length + currentIdx - 1) % this.items.length;\n    this.slideTo(previousIdx);\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上面的代码中：Slider的构造器中的参数",(0,t.jsx)(n.code,{children:"{container}"}),"表示放置这4张图片的父容器。在构造器中，我们获取了这个父容器下所有的",(0,t.jsx)(n.code,{children:"<li>"}),"元素。"]}),"\n",(0,t.jsxs)(n.p,{children:["然后，通过",(0,t.jsx)(n.code,{children:"setInterval"}),"方法实现循环播放，间隔为3秒："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const container = document.querySelector('.slider');\nconst slider = new Slider({container});\nsetInterval(() => {\n  slider.slideNext();\n}, 3000);\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样，我们的轮播图就以每3秒的切换一次频率动起来了。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsxs)(n.h3,{id:"第四步实现用户控制",children:["第四步：实现用户控制",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第四步实现用户控制",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"实现了组件的API后，我们还需要实现用户控制功能："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"当用户点击左右两边的小箭头时，图片分别切换到上一张/下一张，并点亮与该图片相对应的小圆点；"}),"\n",(0,t.jsx)(n.li,{children:"当用户鼠标移进到底部小圆点时，则立即跳到小圆点顺序所对应的那张图片，停止轮播；"}),"\n",(0,t.jsx)(n.li,{children:"当用户鼠标移出底部小圆点后，图片再次恢复轮播。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"我们将构造器修改为下面这样："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"constructor({container, cycle = 3000} = {}) {\n  this.container = container;\n  this.items = Array.from(container.querySelectorAll('.slider__item, .slider__item--selected'));\n  this.cycle = cycle;\n\n  const controller = this.container.querySelector('.slider__control');\n  const buttons = controller.querySelectorAll('.slider__control-buttons, .slider__control-buttons--selected');\n\n  controller.addEventListener('mouseover', (evt) => {\n    const idx = Array.from(buttons).indexOf(evt.target);\n    if(idx >= 0) {\n      this.slideTo(idx);\n      this.stop();\n    }\n  });\n\n  controller.addEventListener('mouseout', (evt) => {\n    this.start();\n  });\n\n  /*\n    注册slide事件，将选中的图片和小圆点设置为selected状态\n  */\n  this.container.addEventListener('slide', (evt) => {\n    const idx = evt.detail.index;\n    const selected = controller.querySelector('.slider__control-buttons--selected');\n    if(selected) selected.className = 'slider__control-buttons';\n    buttons[idx].className = 'slider__control-buttons--selected';\n  });\n\n  const previous = this.container.querySelector('.slider__previous');\n  previous.addEventListener('click', (evt) => {\n    this.stop();\n    this.slidePrevious();\n    this.start();\n    evt.preventDefault();\n  });\n\n  const next = this.container.querySelector('.slider__next');\n  next.addEventListener('click', (evt) => {\n    this.stop();\n    this.slideNext();\n    this.start();\n    evt.preventDefault();\n  });\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如上代码所示，参数",(0,t.jsx)(n.code,{children:"cycle"}),"表示循环播放的时间间隔，默认为3秒。然后是每个控制元素相应的事件处理。下面，我们来依次分析一下它们。"]}),"\n",(0,t.jsx)(n.p,{children:"第一个用户事件：当鼠标移入或移出小圆点事件"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const controller = this.container.querySelector('.slider__control');\n\nconst buttons = controller.querySelectorAll('.slider__control-buttons, .slider__control-buttons--selected');\n\ncontroller.addEventListener('mouseover', (evt) =>{\n  const idx = Array.from(buttons).indexOf(evt.target);\n  if(idx >= 0){\n    this.slideTo(idx);\n    this.stop(); // 停止自动循环播放\n  }\n});\n\ncontroller.addEventListener('mouseout', (evt) => {\n  this.start(); // 开始自动循环播放\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"上面代码表示：当鼠标移动到小圆点上方的时候（mouseover），判断当前选中的是第几个小圆点，停止自动循环播放功能，然后切换到对应的图片。当鼠标移出controller元素后（mouseout），重启自动循环播放功能。"}),"\n",(0,t.jsxs)(n.p,{children:["这里呢，我们先来看看",(0,t.jsx)(n.code,{children:"stop()"}),"和",(0,t.jsx)(n.code,{children:"start()"}),"的实现："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"start() {\n  this.stop();\n  this._timer = setInterval(() => this.slideNext(), this.cycle);\n}\n\nstop() {\n  clearInterval(this._timer);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如上代码所示：",(0,t.jsx)(n.code,{children:"start()"}),"方法启动了一个定时器，每隔",(0,t.jsx)(n.code,{children:"cycle"}),"秒执行一次",(0,t.jsx)(n.code,{children:"slideNext()"}),"。",(0,t.jsx)(n.code,{children:"stop()"}),"则是停止这个定时器。"]}),"\n",(0,t.jsx)(n.p,{children:"第二个用户事件：点击上一张或下一张事件"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const previous = this.container.querySelector('.slider__previous');\nprevious.addEventListener('click', evt => {\n  this.stop();\n  this.slidePrevious();\n  this.start();\n  evt.preventDefault();\n});\n\nconst next = this.container.querySelector('.slider__next');\nnext.addEventListener('click', evt => {\n  this.stop();\n  this.slideNext();\n  this.start();\n  evt.preventDefault();\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如上代码所示：当用户点击上一张时，程序停止定时器，然后执行",(0,t.jsx)(n.code,{children:"slidePrevious()"}),"方法，让图片向前翻一张，然后重启定时器。类似的，当用户点击下一张时，先停止定时器，然后向后翻一张，再重启定时器。"]}),"\n",(0,t.jsx)(n.p,{children:"第三个是处理一个自定义事件 —— slide事件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"this.container.addEventListener('slide', evt => {\n  const idx = evt.detail.index\n  const selected = controller.querySelector('.slider__control-buttons--selected');\n  if(selected) selected.className = 'slider__control-buttons';\n  buttons[idx].className = 'slider__control-buttons--selected';\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["对应地，修改",(0,t.jsx)(n.code,{children:"slideTo"}),"方法，加入自定义事件触发。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"slideTo(idx) {\n  const selected = this.getSelectedItem();\n  if(selected) {\n    selected.className = 'slider__item';\n  }\n  const item = this.items[idx];\n  if(item) {\n    item.className = 'slider__item--selected';\n  }\n\n  const detail = {index: idx};\n  const event = new CustomEvent('slide', {bubbles: true, detail});\n  this.container.dispatchEvent(event);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这个自定义事件（CustomEvent），它的作用是让底部小圆点控件监听",(0,t.jsx)(n.code,{children:"slideTo"}),"方法。当",(0,t.jsx)(n.code,{children:"slideTo"}),"方法执行后，这个方法就会分发一次",(0,t.jsx)(n.code,{children:"slide"}),"事件，然后在这个事件中，更新底部小圆点的状态，让小圆点的状态和各自的图片状态对应起来。"]}),"\n",(0,t.jsx)(n.p,{children:"最后将调用过程改成："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const slider = new Slider({container});\nslider.start();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["到此，这个组件的全部功能就完成了。",(0,t.jsx)(n.a,{href:"https://junyux.github.io/FE-Advance/day06/index1.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})]}),"\n",(0,t.jsx)(n.p,{children:"通过轮播组件编写过程，我们可以总结一下组件设计的一般性步骤："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"设计HTML结构"}),"\n",(0,t.jsx)(n.li,{children:"设计组件的API"}),"\n",(0,t.jsx)(n.li,{children:"设计用户控制流程"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["从上面的代码中，我们可以看到这个轮播组件实现了",(0,t.jsx)(n.strong,{children:"封装性"}),"和",(0,t.jsx)(n.strong,{children:"正确性"}),"，但是缺少了",(0,t.jsx)(n.strong,{children:"可扩展性"}),"。这个组件只能满足自身的使用，它的实现代码很难扩展到其他的组件，当有功能变化时，也需要修改其自身内部的代码。"]}),"\n",(0,t.jsx)(n.p,{children:"比如产品经理因为某种原因，希望将图片下方的小圆点暂时去掉，只保留左右箭头。那么在这个版本中，就需要这么做："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["注释掉HTML中",(0,t.jsx)(n.code,{children:".slider__control"}),"相关的代码"]}),"\n",(0,t.jsx)(n.li,{children:"修改Slider组件，注释掉与小圆点控制相关的代码"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"又或者，将来需要为这个组件添加新的用户控制，都需要对这个组件进行再修改。"}),"\n",(0,t.jsxs)(n.p,{children:["那么，如何可以避免这样的修改，让组件具备",(0,t.jsx)(n.strong,{children:"可扩展性"}),"呢？"]}),"\n",(0,t.jsxs)(n.h2,{id:"第二个故事组件的插件化",children:["第二个故事：组件的插件化",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第二个故事组件的插件化",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["上一个故事中的轮播组件封装，我们实现了",(0,t.jsx)(n.strong,{children:"封装性"}),"和",(0,t.jsx)(n.strong,{children:"正确性"}),"。但这仅能满足项目当前的基本要求，是对初级工程师的基本要求，而",(0,t.jsx)(n.strong,{children:"可扩展性"}),"和",(0,t.jsx)(n.strong,{children:"可复用性"}),"，则对于整个项目的未来有很大的帮助，是对高级工程师的要求。在前端UI组件中，提升可扩展性的基本思路，是",(0,t.jsx)(n.strong,{children:"插件化"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"那么，对于这个图片轮播组件来说，它的插件化可以是将用户控制组件从Slider组件中剥离出来，做成插件，这样才能提高Slider组件的可扩展性。"}),"\n",(0,t.jsxs)(n.p,{children:["在图片轮播组件中，用户的控制组件分为三个部分：图片下部的小圆点以及左右翻页按钮。我们分别用",(0,t.jsx)(n.code,{children:"controller"}),"、",(0,t.jsx)(n.code,{children:"previous"}),"、",(0,t.jsx)(n.code,{children:"next"}),"三个变量来分别处理它们。"]}),"\n",(0,t.jsx)(n.p,{children:"现在我们来重构一下上一版的代码："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"constructor({container, cycle = 3000} = {}) {\n  this.container = container;\n  this.items = Array.from(container.querySelectorAll('.slider__item, .slider__item--selected'));\n  this.cycle = cycle;\n}\n\nregisterPlugins(...plugins) {\n  plugins.forEach(plugin => plugin(this));\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如上代码所示：在Sliders类的构造器中，我们将注册控制流程的代码移除，增加了一个新的方法叫",(0,t.jsx)(n.code,{children:"registerPlugins"}),"。这个方法接受一组参数",(0,t.jsx)(n.code,{children:"plugins"}),"，每个",(0,t.jsx)(n.code,{children:"plugin"}),"本身是一个初始化函数，可以做任何事情。"]}),"\n",(0,t.jsx)(n.p,{children:"然后，我们将之前写在构造器的控制流程代码移到对应的插件中："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"/* 小圆点控件 */\nfunction pluginController(slider) {\n  const controller = slider.container.querySelector('.slider__control');\n  if(controller) {\n    const buttons = controller.querySelectorAll('.slider__control-buttons, .slider__control-buttons--selected');\n    controller.addEventListener('mouseover', (evt) => {\n      const idx = Array.from(buttons).indexOf(evt.target);\n      if(idx >= 0) {\n        slider.slideTo(idx);\n        slider.stop();\n      }\n    });\n\n    controller.addEventListener('mouseout', (evt) => {\n      slider.start();\n    });\n\n    slider.container.addEventListener('slide', (evt) => {\n      const idx = evt.detail.index;\n      const selected = controller.querySelector('.slider__control-buttons--selected');\n      if(selected) selected.className = 'slider__control-buttons';\n      buttons[idx].className = 'slider__control-buttons--selected';\n    });\n  }\n}\n\nfunction pluginPrevious(slider) {\n  const previous = slider.container.querySelector('.slider__previous');\n  if(previous) {\n    previous.addEventListener('click', (evt) => {\n      slider.stop();\n      slider.slidePrevious();\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n}\n\nfunction pluginNext(slider) {\n  const next = slider.container.querySelector('.slider__next');\n  if(next) {\n    next.addEventListener('click', (evt) => {\n      slider.stop();\n      slider.slideNext();\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如上代码所示，",(0,t.jsx)(n.code,{children:"pluginController"}),"、",(0,t.jsx)(n.code,{children:"pluginPrevious"}),"和",(0,t.jsx)(n.code,{children:"pluginNext"}),"分别表示小圆点控制和左右翻页控制插件。每个插件接受一个Slider的实例。然后，将各自的用户事件注册在对应的插件上。"]}),"\n",(0,t.jsxs)(n.p,{children:["\uD83D\uDCA1注意：我们在 ",(0,t.jsx)(n.code,{children:"Slider.registerPlugins"})," 对象方法里，给每个 ",(0,t.jsx)(n.code,{children:"plugin"}),"（即：插件）传入当前的 slider 对象实例。在插件的初始化函数中，我们就可以拿到这个 slider 对象。这种将依赖对象传入插件初始化函数的方式，叫做",(0,t.jsx)(n.strong,{children:"依赖注入"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"依赖注入"}),"是一种组件/插件解耦合的基本思路，在UI设计中经常被使用，在我们后续的课程中还会见到。"]}),"\n",(0,t.jsx)(n.p,{children:"最后再将插件注册到slider对象上："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const container = document.querySelector('.slider');\nconst slider = new Slider({container});\nslider.registerPlugins(pluginController, pluginPrevious, pluginNext);\nslider.start();\n"})}),"\n",(0,t.jsx)(n.p,{children:"所以，最终，这一版的JS代码是这样的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://junyux.github.io/FE-Advance/day06/index2.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Slider {\n  constructor({container, cycle = 3000} = {}) {\n    this.container = container;\n    this.items = Array.from(container.querySelectorAll('.slider__item, .slider__item--selected'));\n    this.cycle = cycle;\n  }\n\n  registerPlugins(...plugins) {\n    plugins.forEach(plugin => plugin(this));\n  }\n\n  /*\n    通过选择器`.slider__item--selected`获得被选中的元素\n  */\n  getSelectedItem() {\n    const selected = this.container.querySelector('.slider__item--selected');\n    return selected;\n  }\n\n  /*\n    返回选中的元素在items数组中的位置。\n  */\n  getSelectedItemIndex() {\n    return this.items.indexOf(this.getSelectedItem());\n  }\n\n  slideTo(idx) {\n    const selected = this.getSelectedItem();\n    if(selected) {\n      selected.className = 'slider__item';\n    }\n    const item = this.items[idx];\n    if(item) {\n      item.className = 'slider__item--selected';\n    }\n\n    const detail = {index: idx};\n    const event = new CustomEvent('slide', {bubbles: true, detail});\n    this.container.dispatchEvent(event);\n  }\n\n  /*\n    将下一张图片标记为选中状态\n  */\n  slideNext() {\n    const currentIdx = this.getSelectedItemIndex();\n    const nextIdx = (currentIdx + 1) % this.items.length;\n    this.slideTo(nextIdx);\n  }\n\n  /*\n    将上一张图片标记为选中状态\n  */\n  slidePrevious() {\n    const currentIdx = this.getSelectedItemIndex();\n    const previousIdx = (this.items.length + currentIdx - 1) % this.items.length;\n    this.slideTo(previousIdx);\n  }\n\n  start() {\n    this.stop();\n    this._timer = setInterval(() => this.slideNext(), this.cycle);\n  }\n\n  stop() {\n    clearInterval(this._timer);\n  }\n}\n\n/* 小圆点控件 */\nfunction pluginController(slider) {\n  const controller = slider.container.querySelector('.slider__control');\n  if(controller) {\n    const buttons = controller.querySelectorAll('.slider__control-buttons, .slider__control-buttons--selected');\n    controller.addEventListener('mouseover', (evt) => {\n      const idx = Array.from(buttons).indexOf(evt.target);\n      if(idx >= 0) {\n        slider.slideTo(idx);\n        slider.stop();\n      }\n    });\n\n    controller.addEventListener('mouseout', (evt) => {\n      slider.start();\n    });\n\n    slider.container.addEventListener('slide', (evt) => {\n      const idx = evt.detail.index;\n      const selected = controller.querySelector('.slider__control-buttons--selected');\n      if(selected) selected.className = 'slider__control-buttons';\n      buttons[idx].className = 'slider__control-buttons--selected';\n    });\n  }\n}\n\nfunction pluginPrevious(slider) {\n  const previous = slider.container.querySelector('.slider__previous');\n  if(previous) {\n    previous.addEventListener('click', (evt) => {\n      slider.stop();\n      slider.slidePrevious();\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n}\n\nfunction pluginNext(slider) {\n  const next = slider.container.querySelector('.slider__next');\n  if(next) {\n    next.addEventListener('click', (evt) => {\n      slider.stop();\n      slider.slideNext();\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n}\n\nconst container = document.querySelector('.slider');\nconst slider = new Slider({container});\nslider.registerPlugins(pluginController, pluginPrevious, pluginNext);\nslider.start();\n"})}),"\n",(0,t.jsx)(n.p,{children:"这个版本中，我们将组件核心和插件部分进行了分离，这样就允许我们的组件随时减少或者增加用户控制。比如，上一故事中，当我们的产品经理要求去掉图片下方的小圆点控制时，我们自需要简单将小圆点从插件注册中去掉，完全不需要修改组件代码。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"slider.registerPlugins(pluginPrevious, pluginNext);\n"})}),"\n",(0,t.jsx)(n.p,{children:"如果，有一天，产品经理又需要对这个组件添加新的用户控制，比如，添加一个按钮叫“试试手气”，点击该按钮，让轮播图随机切换到一张图片上，那么们我们只需要这样做："}),"\n",(0,t.jsx)(n.p,{children:"在HTML代码中增加“试试手气“这个按钮："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<button class="lucky">试试手气</button>\n'})}),"\n",(0,t.jsx)(n.p,{children:"然后创建这个插件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function  pluginLucky(slider) {\n  const luckyBtn = document.querySelector('.lucky');\n  if(luckyBtn) {\n    luckyBtn.addEventListener('click', evt => {\n      slider.stop();\n      slider.slideTo(Math.floor(Math.random() * slider.items.length));\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"最后将它注册到slider中去即可："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"slider.registerPlugins(pluginController, pluginPrevious, pluginNext, pluginLucky);\n"})}),"\n",(0,t.jsx)(n.p,{children:"由此可见，插件化之后，组件的可扩展性得到了增强，现在我们可以任意扩展插件，而不用修改Slider本身的核心代码了。"}),"\n",(0,t.jsx)(n.p,{children:"这时，你可能发现了另一个问题 —— 组件的HTML和JS是分开写的，这意味着我们修改组件本身和增加插件的时候，不可避免地需要同时修改HTML和JS代码。"}),"\n",(0,t.jsxs)(n.p,{children:["比如，产品经理希望我们将图片数量从四张增加为六张，那么我们需要修改组件和插件的HTML（即：增加",(0,t.jsx)(n.code,{children:"<li>"}),"元素和小圆点控制）。甚至现在连修改一张图片的URL，我们也需要手工修改HTML内容。这也不符合前面课程中学过的数据抽象原则。所以，我们需要去掉组件的HTML代码，让JS来渲染组件需要的HTML。"]}),"\n",(0,t.jsx)(n.p,{children:"那么，我们如何让JS渲染组件的HTML呢？"}),"\n",(0,t.jsxs)(n.h2,{id:"第三个故事-组件的模板化",children:["第三个故事 组件的模板化",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第三个故事-组件的模板化",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["为了让JS渲染组件的HTML，我们需要将组件",(0,t.jsx)(n.strong,{children:"模板化"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"为了方便实现模板化，我们需要重构组件的部分API:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["如上图所示，我们给Slider组件添加了一个",(0,t.jsx)(n.code,{children:"render()"}),"方法。这个方法是用于渲染Slider组件的HTML部分。然后，我们将插件由原先单一的初始化函数重构为一个包含",(0,t.jsx)(n.code,{children:"render()"}),"方法和",(0,t.jsx)(n.code,{children:"initialize()"}),"方法的对象。其中",(0,t.jsx)(n.code,{children:"render()"}),"方法是用来渲染插件的HTML部分，而",(0,t.jsx)(n.code,{children:"initialize()"}),"方法则是用于注册和插件对应的用户事件。"]}),"\n",(0,t.jsx)(n.p,{children:"首先，我们来渲染Slider组件的HTML："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Slider {\n  constructor({container, images = [], cycle = 3000} = {}) {\n    this.container = container;\n    this.data = images;\n    this.container.innerHTML = this.render(this.data);\n    this.items = Array.from(this.container.querySelectorAll('.slider__item, .slider__item--selected'));\n    this.cycle = cycle;\n    this.slideTo(0);\n  }\n\n  render(images) {\n    const content = images.map(image => `\n      <li class=\"slider__item\">\n        <img src=\"${image}\"/>\n      </li>    \n    `.trim());\n\n    return `<ul>${content.join('')}</ul>`;\n  }\n  \n  /*此处省略组件其他的API*/\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如上代码所示：我们将数据源（这里就是图片数组）传递给Slider组件。然后Slider的构造器利用这个数据源渲染自己的HTML —— ",(0,t.jsx)(n.code,{children:"this.container.innerHTML = this.render(this.data);"}),"，再将这部分HTML添加到container元素中去。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const images = ['https://p5.ssl.qhimg.com/t0119c74624763dd070.png',\n  'https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg',\n  'https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg',\n  'https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg'];\n\nconst container = document.querySelector('.slider');\nconst slider = new Slider({container, images});\n"})}),"\n",(0,t.jsx)(n.p,{children:"上面这段调用代码渲染的结果如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-HTML",children:'<ul>\n  <li class="slider__item">\n    <img src="https://p5.ssl.qhimg.com/t0119c74624763dd070.png"/>\n  </li>\n  <li class="slider__item">\n    <img src="https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg"/>\n  </li>\n  <li class="slider__item">\n    <img src="https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg"/>\n  </li>\n  <li class="slider__item">\n    <img src="https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg"/>\n  </li>\n</ul>\n'})}),"\n",(0,t.jsx)(n.p,{children:"这样，组件的HTML代码部分就简化为下面的形式："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<div class="slider"></div>\n'})}),"\n",(0,t.jsx)(n.p,{children:"然后，我们为每个插件添加渲染代码："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const pluginController = { // 小圆点插件\n  render(images){ //随着图片数量的增加，小圆点元素也需要增加\n    return `\n      <div class=\"slider__control\">\n        ${images.map((image, i) => `\n            <span class=\"slider__control-buttons${i===0?'--selected':''}\"></span>\n        `).join('')}\n      </div>    \n    `.trim();\n  },\n\n  initialize(slider){\n    const controller = slider.container.querySelector('.slider__control');\n    \n    if(controller){\n      const buttons = controller.querySelectorAll('.slider__control-buttons, .slider__control-buttons--selected');\n      controller.addEventListener('mouseover', evt => {\n        const idx = Array.from(buttons).indexOf(evt.target);\n        if(idx >= 0){\n          slider.slideTo(idx);\n          slider.stop();\n        }\n      });\n\n      controller.addEventListener('mouseout', evt => {\n        slider.start();\n      });\n\n      slider.container.addEventListener('slide', evt => {\n        const idx = evt.detail.index\n        const selected = controller.querySelector('.slider__control-buttons--selected');\n        if(selected) selected.className = 'slider__control-buttons';\n        buttons[idx].className = 'slider__control-buttons--selected';\n      });\n    }    \n  }\n};\n\nconst pluginPrevious = {\n  render(){\n    return `<a class=\"slider__previous\"></a>`;\n  },\n\n  initialize(slider){\n    const previous = slider.container.querySelector('.slider__previous');\n    if(previous){\n      previous.addEventListener('click', evt => {\n        slider.stop();\n        slider.slidePrevious();\n        slider.start();\n        evt.preventDefault();\n      });\n    }  \n  }\n};\n\nconst pluginNext = {\n  render(){\n    return `<a class=\"slider__next\"></a>`;\n  },\n\n  initialize(slider){\n    const previous = slider.container.querySelector('.slider__next');\n    if(previous){\n      previous.addEventListener('click', evt => {\n        slider.stop();\n        slider.slideNext();\n        slider.start();\n        evt.preventDefault();\n      });\n    }  \n  }\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如上代码所示：每个插件都被构造成一个对象。每个对象中都有一个",(0,t.jsx)(n.code,{children:"render"}),"方法，负责渲染各自的HTML。",(0,t.jsx)(n.code,{children:"initialize"}),"方法则是负责注册各自的用户事件。"]}),"\n",(0,t.jsxs)(n.p,{children:["为了将每个插件添加到Slider组件中，我们需要修改Slider的",(0,t.jsx)(n.code,{children:"Slider.registerPlugins()"}),"方法："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"registerPlugins(...plugins) {\n  plugins.forEach((plugin) => {\n    const pluginContainer = document.createElement('div');\n    pluginContainer.className = 'slider__plugin';\n    pluginContainer.innerHTML = plugin.render(this.data);\n    this.container.appendChild(pluginContainer);\n    plugin.initialize(this);\n  });\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如上代码所示：Slider组件为每个plugin创建了一个",(0,t.jsx)(n.code,{children:"class=slider__plugin"}),"的容器，然后将插件的HTML元素添加到这个容器中，再把这个容器添加到Slider组件中去，最后再调用插件的",(0,t.jsx)(n.code,{children:"initialize"}),"方法，以便为每个插件添加各自的用户控制。"]}),"\n",(0,t.jsx)(n.p,{children:"这次重构的完整代码如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://junyux.github.io/FE-Advance/day06/index3.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Slider {\n  constructor({container, images = [], cycle = 3000} = {}) {\n    this.container = container;\n    this.data = images;\n    this.container.innerHTML = this.render(this.data);\n    this.items = Array.from(this.container.querySelectorAll('.slider__item, .slider__item--selected'));\n    this.cycle = cycle;\n    this.slideTo(0);\n  }\n\n  render(images) {\n    const content = images.map(image => `\n      <li class=\"slider__item\">\n        <img src=\"${image}\"/>\n      </li>    \n    `.trim());\n\n    return `<ul>${content.join('')}</ul>`;\n  }\n\n  registerPlugins(...plugins) {\n    plugins.forEach((plugin) => {\n      const pluginContainer = document.createElement('div');\n      pluginContainer.className = 'slider__plugin';\n      pluginContainer.innerHTML = plugin.render(this.data);\n      this.container.appendChild(pluginContainer);\n      plugin.initialize(this);\n    });\n  }\n\n  /*\n    通过选择器`.slider__item--selected`获得被选中的元素\n  */\n  getSelectedItem() {\n    const selected = this.container.querySelector('.slider__item--selected');\n    return selected;\n  }\n\n  /*\n    返回选中的元素在items数组中的位置。\n  */\n  getSelectedItemIndex() {\n    return this.items.indexOf(this.getSelectedItem());\n  }\n\n  slideTo(idx) {\n    const selected = this.getSelectedItem();\n    if(selected) {\n      selected.className = 'slider__item';\n    }\n    const item = this.items[idx];\n    if(item) {\n      item.className = 'slider__item--selected';\n    }\n\n    const detail = {index: idx};\n    const event = new CustomEvent('slide', {bubbles: true, detail});\n    this.container.dispatchEvent(event);\n  }\n\n  /*\n    将下一张图片标记为选中状态\n  */\n  slideNext() {\n    const currentIdx = this.getSelectedItemIndex();\n    const nextIdx = (currentIdx + 1) % this.items.length;\n    this.slideTo(nextIdx);\n  }\n\n  /*\n    将上一张图片标记为选中状态\n  */\n  slidePrevious() {\n    const currentIdx = this.getSelectedItemIndex();\n    const previousIdx = (this.items.length + currentIdx - 1) % this.items.length;\n    this.slideTo(previousIdx);\n  }\n\n  start() {\n    this.stop();\n    this._timer = setInterval(() => this.slideNext(), this.cycle);\n  }\n\n  stop() {\n    clearInterval(this._timer);\n  }\n}\n\nconst pluginController = { // 小圆点插件\n  render(images) { // 随着图片数量的增加，小圆点元素也需要增加\n    return `\n      <div class=\"slider__control\">\n        ${images.map((image, i) => `\n            <span class=\"slider__control-buttons${i === 0 ? '--selected' : ''}\"></span>\n        `).join('')}\n      </div>    \n    `.trim();\n  },\n\n  initialize(slider) {\n    const controller = slider.container.querySelector('.slider__control');\n\n    if(controller) {\n      const buttons = controller.querySelectorAll('.slider__control-buttons, .slider__control-buttons--selected');\n      controller.addEventListener('mouseover', (evt) => {\n        const idx = Array.from(buttons).indexOf(evt.target);\n        if(idx >= 0) {\n          slider.slideTo(idx);\n          slider.stop();\n        }\n      });\n\n      controller.addEventListener('mouseout', (evt) => {\n        slider.start();\n      });\n\n      slider.container.addEventListener('slide', (evt) => {\n        const idx = evt.detail.index;\n        const selected = controller.querySelector('.slider__control-buttons--selected');\n        if(selected) selected.className = 'slider__control-buttons';\n        buttons[idx].className = 'slider__control-buttons--selected';\n      });\n    }\n  },\n};\n\nconst pluginPrevious = {\n  render() {\n    return '<a class=\"slider__previous\"></a>';\n  },\n\n  initialize(slider) {\n    const previous = slider.container.querySelector('.slider__previous');\n    if(previous) {\n      previous.addEventListener('click', (evt) => {\n        slider.stop();\n        slider.slidePrevious();\n        slider.start();\n        evt.preventDefault();\n      });\n    }\n  },\n};\n\nconst pluginNext = {\n  render() {\n    return '<a class=\"slider__next\"></a>';\n  },\n\n  initialize(slider) {\n    const previous = slider.container.querySelector('.slider__next');\n    if(previous) {\n      previous.addEventListener('click', (evt) => {\n        slider.stop();\n        slider.slideNext();\n        slider.start();\n        evt.preventDefault();\n      });\n    }\n  },\n};\n\nconst images = ['https://p5.ssl.qhimg.com/t0119c74624763dd070.png',\n  'https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg',\n  'https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg',\n  'https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg'];\n\nconst container = document.querySelector('.slider');\nconst slider = new Slider({container, images});\nslider.registerPlugins(pluginController, pluginPrevious, pluginNext);\nslider.start();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["模板化之后，代码的可扩展性得到了进一步的提升。现在，如果我们增加或者减少轮播图片数量，只需要修改数据中images数组的元素个数。如果我们需要或者不需要某个插件，我们只需要修改传给",(0,t.jsx)(n.code,{children:"registerPlugins()"}),"方法的参数即可。可以说，这一版代码的可扩展性是达到了发布要求的较高标准的。"]}),"\n",(0,t.jsxs)(n.p,{children:["这个版本的组件虽然具有较高的可扩展性，但是它缺少",(0,t.jsx)(n.strong,{children:"可复用性"}),"。这里的可复用性是指，这套组件（包括Slider的插件）没有统一的规范。如果我们的同事同样需要设置一套组件，其中也有小圆点组件，但是他使用的渲染方法是",(0,t.jsx)(n.code,{children:"draw()"}),"而不是",(0,t.jsx)(n.code,{children:"render()"}),"，组件事件的注册使用的也不是",(0,t.jsx)(n.code,{children:"initialized()"}),"方法， 那么这个同事就需要再重复开发一个小圆点组件。这样代码的可复用性就比较差了。所以，为了提高代码可复用性，我们需要为组件设计一套规范。大家同时遵循这套规范，就能让不同开发者设计的组件被他人复用。"]}),"\n",(0,t.jsx)(n.p,{children:"那么，如何实现组件的统一规范呢？"}),"\n",(0,t.jsxs)(n.h2,{id:"第四个故事设计组件框架",children:["第四个故事：设计组件框架",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第四个故事设计组件框架",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["为了提高组件的复用性，我们需要为组件设计一个",(0,t.jsx)(n.strong,{children:"统一的规范"}),"。实现这个统一的规范，我们可以通过设计一套通用的",(0,t.jsx)(n.strong,{children:"组件机制"}),"，并以这套机制为原则构建一个库。这个",(0,t.jsx)(n.strong,{children:"通用机制"}),"实际上提供了代码设计和抽象的一套通用规范，而遵循这套规范的基础库，实际上就是完整的",(0,t.jsx)(n.strong,{children:"UI组件框架"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"设计UI组件框架是一件比较复杂的事情，因为要考虑许多细节。但在这里，我们可以简要地设计一个基础简化版。"}),"\n",(0,t.jsx)(n.p,{children:"我们继续修改上一版的设计，提炼出通用的Component类："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"如上图所示，一个组件 Component 包含以下 API:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"static name - 静态属性，表示这个组件的名称"}),"\n",(0,t.jsx)(n.li,{children:"contructor({container, data, parent}) - 组件构造函数"}),"\n",(0,t.jsx)(n.li,{children:"registerSubComponents(...Comps) - 给当前组件注册子组件"}),"\n",(0,t.jsx)(n.li,{children:"render(data) - 渲染HTML模板"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Component {\n  static name = 'component';\n\n  constructor({container, data, parent = null} = {}) {\n    this.data = data;\n    this.container = container;\n    this.container.innerHTML = this.render(this.data);\n  }\n\n  registerSubComponents(...Comps) {\n    const data = this.data;\n    const container = this.container;\n    this.children = this.children || [];\n    Comps.forEach((Comp) => {\n      const subContainer = document.createElement('div');\n      const sub = new Comp({container: subContainer, data, parent: this});\n      container.appendChild(subContainer);\n      this.children.push(sub);\n    });\n  }\n\n  render(data) {\n    /* abstract */\n    return '';\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后 Slider 和其他几个插件都作为组件类继承自 Component。"}),"\n",(0,t.jsx)(n.p,{children:"Slider 组件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Slider extends Component {\n  static name = 'slider';\n\n  constructor({container, images = [], cycle = 3000} = {}) {\n    super({container, data: images});\n    this.items = Array.from(this.container.querySelectorAll('.slider__item, .slider__item--selected'));\n    this.cycle = cycle;\n    this.slideTo(0);\n  }\n\n  render(images) {\n    const content = images.map(image => `\n      <li class=\"slider__item\">\n        <img src=\"${image}\"/>\n      </li>    \n    `.trim());\n\n    return `<ul>${content.join('')}</ul>`;\n  }\n\n  getSelectedItem() {\n    const selected = this.container.querySelector('.slider__item--selected');\n    return selected;\n  }\n\n  getSelectedItemIndex() {\n    return this.items.indexOf(this.getSelectedItem());\n  }\n\n  slideTo(idx) {\n    const selected = this.getSelectedItem();\n    if(selected) {\n      selected.className = 'slider__item';\n    }\n    const item = this.items[idx];\n    if(item) {\n      item.className = 'slider__item--selected';\n    }\n\n    const detail = {index: idx};\n    const event = new CustomEvent('slide', {bubbles: true, detail});\n    this.container.dispatchEvent(event);\n  }\n\n  slideNext() {\n    const currentIdx = this.getSelectedItemIndex();\n    const nextIdx = (currentIdx + 1) % this.items.length;\n    this.slideTo(nextIdx);\n  }\n\n  slidePrevious() {\n    const currentIdx = this.getSelectedItemIndex();\n    const previousIdx = (this.items.length + currentIdx - 1) % this.items.length;\n    this.slideTo(previousIdx);\n  }\n\n  start() {\n    this.stop();\n    this._timer = setInterval(() => this.slideNext(), this.cycle);\n  }\n\n  stop() {\n    clearInterval(this._timer);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"SliderController 组件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class SliderController extends Component {\n  static name = 'slider__control';\n\n  constructor({container, data, parent: slider}) {\n    super({container, data});\n\n    const buttons = container.querySelectorAll('.slider__control-buttons, .slider__control-buttons--selected');\n    container.addEventListener('mouseover', (evt) => {\n      const idx = Array.from(buttons).indexOf(evt.target);\n      if(idx >= 0) {\n        slider.slideTo(idx);\n        slider.stop();\n      }\n    });\n\n    container.addEventListener('mouseout', (evt) => {\n      slider.start();\n    });\n\n    slider.container.addEventListener('slide', (evt) => {\n      const idx = evt.detail.index;\n      const selected = container.querySelector('.slider__control-buttons--selected');\n      if(selected) selected.className = 'slider__control-buttons';\n      buttons[idx].className = 'slider__control-buttons--selected';\n    });\n  }\n\n  render(images) {\n    return `\n      <div class=\"slider__control\">\n        ${images.map((image, i) => `\n            <span class=\"slider__control-buttons${i === 0 ? '--selected' : ''}\"></span>\n        `).join('')}\n      </div>    \n    `.trim();\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"SliderPrevious 和 SliderNext 组件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class SliderPrevious extends Component {\n  constructor({container, parent: slider}) {\n    super({container});\n    const previous = container.querySelector('.slider__previous');\n    previous.addEventListener('click', (evt) => {\n      slider.stop();\n      slider.slidePrevious();\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n\n  render() {\n    return '<a class=\"slider__previous\"></a>';\n  }\n}\n\nclass SliderNext extends Component {\n  constructor({container, parent: slider}) {\n    super({container});\n    const previous = container.querySelector('.slider__next');\n    previous.addEventListener('click', (evt) => {\n      slider.stop();\n      slider.slidePrevious();\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n\n  render() {\n    return '<a class=\"slider__next\"></a>';\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样，我们就以组件化的方式实现了这个版本的轮播图，完整的JS代码如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://junyux.github.io/FE-Advance/day06/index4.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Component {\n  static name = 'component';\n\n  constructor({container, data, parent = null} = {}) {\n    this.data = data;\n    this.container = container;\n    this.container.innerHTML = this.render(this.data);\n  }\n\n  registerSubComponents(...Comps) {\n    const data = this.data;\n    const container = this.container;\n    this.children = this.children || [];\n    Comps.forEach((Comp) => {\n      const subContainer = document.createElement('div');\n      const sub = new Comp({container: subContainer, data, parent: this});\n      container.appendChild(subContainer);\n      this.children.push(sub);\n    });\n  }\n\n  render(data) {\n    /* abstract */\n    return '';\n  }\n}\n\nclass Slider extends Component {\n  static name = 'slider';\n\n  constructor({container, images = [], cycle = 3000} = {}) {\n    super({container, data: images});\n    this.items = Array.from(this.container.querySelectorAll('.slider__item, .slider__item--selected'));\n    this.cycle = cycle;\n    this.slideTo(0);\n  }\n\n  render(images) {\n    const content = images.map(image => `\n      <li class=\"slider__item\">\n        <img src=\"${image}\"/>\n      </li>    \n    `.trim());\n\n    return `<ul>${content.join('')}</ul>`;\n  }\n\n  getSelectedItem() {\n    const selected = this.container.querySelector('.slider__item--selected');\n    return selected;\n  }\n\n  getSelectedItemIndex() {\n    return this.items.indexOf(this.getSelectedItem());\n  }\n\n  slideTo(idx) {\n    const selected = this.getSelectedItem();\n    if(selected) {\n      selected.className = 'slider__item';\n    }\n    const item = this.items[idx];\n    if(item) {\n      item.className = 'slider__item--selected';\n    }\n\n    const detail = {index: idx};\n    const event = new CustomEvent('slide', {bubbles: true, detail});\n    this.container.dispatchEvent(event);\n  }\n\n  slideNext() {\n    const currentIdx = this.getSelectedItemIndex();\n    const nextIdx = (currentIdx + 1) % this.items.length;\n    this.slideTo(nextIdx);\n  }\n\n  slidePrevious() {\n    const currentIdx = this.getSelectedItemIndex();\n    const previousIdx = (this.items.length + currentIdx - 1) % this.items.length;\n    this.slideTo(previousIdx);\n  }\n\n  start() {\n    this.stop();\n    this._timer = setInterval(() => this.slideNext(), this.cycle);\n  }\n\n  stop() {\n    clearInterval(this._timer);\n  }\n}\n\nclass SliderController extends Component {\n  static name = 'slider__control';\n\n  constructor({container, data, parent: slider}) {\n    super({container, data});\n\n    const buttons = container.querySelectorAll('.slider__control-buttons, .slider__control-buttons--selected');\n    container.addEventListener('mouseover', (evt) => {\n      const idx = Array.from(buttons).indexOf(evt.target);\n      if(idx >= 0) {\n        slider.slideTo(idx);\n        slider.stop();\n      }\n    });\n\n    container.addEventListener('mouseout', (evt) => {\n      slider.start();\n    });\n\n    slider.container.addEventListener('slide', (evt) => {\n      const idx = evt.detail.index;\n      const selected = container.querySelector('.slider__control-buttons--selected');\n      if(selected) selected.className = 'slider__control-buttons';\n      buttons[idx].className = 'slider__control-buttons--selected';\n    });\n  }\n\n  render(images) {\n    return `\n      <div class=\"slider__control\">\n        ${images.map((image, i) => `\n            <span class=\"slider__control-buttons${i === 0 ? '--selected' : ''}\"></span>\n        `).join('')}\n      </div>    \n    `.trim();\n  }\n}\n\nclass SliderPrevious extends Component {\n  constructor({container, parent: slider}) {\n    super({container});\n    const previous = container.querySelector('.slider__previous');\n    previous.addEventListener('click', (evt) => {\n      slider.stop();\n      slider.slidePrevious();\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n\n  render() {\n    return '<a class=\"slider__previous\"></a>';\n  }\n}\n\nclass SliderNext extends Component {\n  constructor({container, parent: slider}) {\n    super({container});\n    const previous = container.querySelector('.slider__next');\n    previous.addEventListener('click', (evt) => {\n      slider.stop();\n      slider.slideNext();\n      slider.start();\n      evt.preventDefault();\n    });\n  }\n\n  render() {\n    return '<a class=\"slider__next\"></a>';\n  }\n}\n\nconst images = ['https://p5.ssl.qhimg.com/t0119c74624763dd070.png',\n  'https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg',\n  'https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg',\n  'https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg'];\n\nconst container = document.querySelector('.slider');\nconst slider = new Slider({container, images});\nslider.registerSubComponents(SliderController, SliderPrevious, SliderNext);\nslider.start();\n"})}),"\n",(0,t.jsx)(n.p,{children:"于是我们就得到了一个虽然简单，却自成体系的“组件框架”，这已经不仅仅是考虑Slider这一个组件的问题，依据这一套原则，我们的框架可以逐步添加和实现其他的UI组件，并且可以让这些组件被其他组件复用。"}),"\n",(0,t.jsx)(n.p,{children:"这样复用性的问题就得到了解决。当然，这个小小的组件框架还有许多细节问题未考虑。"}),"\n",(0,t.jsx)(n.p,{children:"比如："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"我们抽象了HTML和JS，却没有把CSS包含进来。"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"registerSubComponents"}),"方法传入的是子组件类，如果我们要创建子组件多个实例，还需要继续完善这套机制才能做到。"]}),"\n",(0,t.jsx)(n.li,{children:"我们可以在子组件中拿到parent对象，然后通过parent.container随意操作父组件的HTML结构，这导致不安全和可能的冲突，也需要引入适当的机制来处理这一问题。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"上述这些问题和其他一些问题有待继续完善，在一般较成熟的UI框架中，这些问题都有对应的解决方法，不过这超出了我们课程的范畴，我们把这些问题留待其他的课程。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}let x=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%2010%20%E6%97%A5%E8%B0%88%2F6.%E7%AC%AC%E5%85%AD%E6%97%A5%EF%BC%9A%E8%B0%88%E8%B0%88%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85.md"]={toc:[{text:"第一个故事：首页轮播图",id:"第一个故事首页轮播图",depth:2},{text:"第一步：确定UI组件的HTML结构。",id:"第一步确定ui组件的html结构",depth:3},{text:"第二步：设置元素的样式",id:"第二步设置元素的样式",depth:3},{text:"第三步：设计API",id:"第三步设计api",depth:3},{text:"第四步：实现用户控制",id:"第四步实现用户控制",depth:3},{text:"第二个故事：组件的插件化",id:"第二个故事组件的插件化",depth:2},{text:"第三个故事 组件的模板化",id:"第三个故事-组件的模板化",depth:2},{text:"第四个故事：设计组件框架",id:"第四个故事设计组件框架",depth:2}],title:"6.第六日：谈谈组件封装",headingTitle:"6.第六日：谈谈组件封装",frontmatter:{}}}}]);