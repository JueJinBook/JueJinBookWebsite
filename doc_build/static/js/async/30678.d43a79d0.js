"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["30678"],{995241:function(e,n,r){r.r(n),r.d(n,{default:()=>k});var s=r(552676),c=r(740453);let a=r.p+"static/image/09ab87b44f18f4017a2686bab400b963.1641b0fe.webp",i=r.p+"static/image/fb0e137df79ca432fc32bd92af229729.2bd1376e.webp",o=r.p+"static/image/0e55fc63704f1cbd13db332228977676.38ea81e8.webp",l=r.p+"static/image/3c93860b590770a0ea29573d532062a3.6b6e6d06.webp",t=r.p+"static/image/c989a86cc9cd6b0cab6a9483928a8610.5f11b04a.webp",g=r.p+"static/image/9c37b31d6c94bcf0223b1c0835cd1917.414a43ab.webp",p=r.p+"static/image/61a12bfe9a76bfa2a9a8074c46915e55.e7962897.webp",d=r.p+"static/image/cba9c4e144a99348f19959cda7c41d61.1f70ccb4.webp",j=r.p+"static/image/f5f6ae98f265bb9741f4006ebfd6657a.90ee794c.webp",x=r.p+"static/image/76f2ed2a5ab83e9fb7db6c5014afce47.e33be208.webp",h=r.p+"static/image/6c66e904e3c66a32ea32a859c8f3f044.b701cc87.webp",m=r.p+"static/image/53f36865b2a76d90a8a6d08c206ac5ed.e25faca7.webp",b=r.p+"static/image/f0fffae3b5a8161226f9703db82782da.d946f0a2.webp",f=r.p+"static/image/59afe2478c309cb2d9d9b114237ef27b.ee8d8fd4.webp",L=r.p+"static/image/934e1ec24f94fc7d12af6adb7a1a4352.bb15f21f.webp",u=r.p+"static/image/753bfb5889f7f5226d3e4c688a7fc971.f1fd6ca8.webp",v=r.p+"static/image/78afa344a9d767e288fc8468c120e10e.fbc387aa.webp",w=r.p+"static/image/5c747cc49f620e6fc7e81b47c5b7ad1e.f3548bc2.webp",S=r.p+"static/image/607e6ce0a4caea8115d52630fbe81b4e.0065c075.webp",A=r.p+"static/image/7c5d4d4a9d4024674f3a0e5040428b57.1d725308.webp",M=r.p+"static/image/63a4a1f625f2c2f5eb289bb435d7ce8d.75808ea8.webp",C=r.p+"static/image/e3a74554a874935636c6fe8d1c249092.2e2cc64c.webp",E=r.p+"static/image/9a0b4094ee7198062fc337564bf9ee4e.de244153.webp",y=r.p+"static/image/dfa5645b79e6726f667a35824417a6d3.8295dc2e.webp",N=r.p+"static/image/a8beb6dafd8136e9839bfbf3f3296035.c164c850.webp";function _(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"36-nest-里如何打印日志",children:["36. Nest 里如何打印日志？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36-nest-里如何打印日志",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前面我们都是用 console.log 打印的日志，这样有不少弊端：没有日志的不同级别的区分，不能通过开关控制是否打印等。"}),"\n",(0,s.jsx)(n.p,{children:"其实 Nest 提供了打印日志的 api，这节我们就来学习一下吧。"}),"\n",(0,s.jsx)(n.p,{children:"还是先创建个项目："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest new logger-test -p npm\n"})}),"\n",(0,s.jsx)(n.p,{children:"进入目录，执行 nest start --watch 把服务跑起来。"}),"\n",(0,s.jsx)(n.p,{children:"Nest 会打印这些日志："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"它也同样提供了打印这种日志的 api。"}),"\n",(0,s.jsx)(n.p,{children:"我们在 AppController 里创建个 logger 对象，使用它的 api 打印日志："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { ConsoleLogger, Controller, Get, Logger } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Controller()\nexport class AppController {\n  private logger = new Logger();\n\n  constructor(private readonly appService: AppService) {}\n\n  @Get()\n  getHello(): string {\n    this.logger.debug('aaa', AppController.name);\n    this.logger.error('bbb', AppController.name);\n    this.logger.log('ccc', AppController.name);\n    this.logger.verbose('ddd', AppController.name);\n    this.logger.warn('eee', AppController.name);\n    \n    return this.appService.getHello();\n  }\n}\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"浏览器访问下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"会打印这样的日志："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这里的 verbose、debug、log、warn、error 就是日志级别，而 [] 中的是 context，也就是当前所在的上下文，最后是日志的内容。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个日志是受 Nest 控制的，可以在创建应用的时候指定是否开启："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"设置 logger 为 false 之后就没有日志了。"}),"\n",(0,s.jsx)(n.p,{children:"你也可以自己决定输出什么级别的日志："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"此外，你还可以自定义日志打印的方式，定义一个实现 LoggerService 接口的类："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"只要实现 log、warn、error 3 个方法就好了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { LoggerService, LogLevel } from '@nestjs/common';\n\nexport class MyLogger implements LoggerService {\n    log(message: string, context: string) {\n        console.log(`---log---[${context}]---`, message)\n    }\n\n    error(message: string, context: string) {\n        console.log(`---error---[${context}]---`, message)\n    }\n\n    warn(message: string, context: string) {\n        console.log(`---warn---[${context}]---`, message)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在创建应用时指定这个 logger："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后现在项目启动就是这样了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"刷新页面打印的日志是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"确实还挺丑的。。"}),"\n",(0,s.jsx)(n.p,{children:"我们只是测试下自定义 Logger。"}),"\n",(0,s.jsx)(n.p,{children:"你也可以不自己实现 LoggerService 的全部方法，而是继承 ConsoleLogger，重写一些方法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { ConsoleLogger } from '@nestjs/common';\n\nexport class MyLogger2 extends ConsoleLogger{\n    log(message: string, context: string) {\n        console.log(`[${context}]`,message)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"因为 ConsoleLogger 实现了 LoggerService 接口："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:L,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样你没重写的方法就是原来的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是创建应用时 logger 的 3 种取值："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但这样有个问题，没法注入依赖，因为 Logger 是在容器外面，手动 new 的对象。"}),"\n",(0,s.jsx)(n.p,{children:"怎么办呢？"}),"\n",(0,s.jsx)(n.p,{children:"这时候可以这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"bufferLogs 就是先不打印日志，把它放到 buffer 缓冲区，直到用 useLogger 指定了 Logger 并且应用初始化完毕。"}),"\n",(0,s.jsx)(n.p,{children:"app.get 就是从容器中取这个类的实例的，我们写一个 Logger 类放到容器里："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Inject } from '@nestjs/common';\nimport { ConsoleLogger, Injectable } from '@nestjs/common';\nimport { AppService } from './app.service';\n\n@Injectable()\nexport class MyLogger3 extends ConsoleLogger{\n    @Inject(AppService)\n    private appService: AppService;\n\n    log(message, context) {\n        console.log(this.appService.getHello());\n        console.log(`[${context}]`, message);\n        console.log('--------------')\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"添加 @Injectable() 装饰器，代表这是一个 provider，并且要在 Module 里引入："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"通过 @Inject 注入 AppService，并在 log 的时候调用。"}),"\n",(0,s.jsx)(n.p,{children:"现在的日志是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"很明显，logger 里成功注入了 appService 的依赖。"}),"\n",(0,s.jsx)(n.p,{children:"我们可以单独搞一个模块来放 Logger。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest g module logger\n"})}),"\n",(0,s.jsx)(n.p,{children:"把这个 Module 设置为全局模块："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样在任何地方都可以注入这个 logger 对象了。"}),"\n",(0,s.jsx)(n.p,{children:"我们创建个新模块："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nest g resource aaa \n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在这个模块里可以直接注入 MyLogger，不用 imports 那个 Module。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，成功注入了 MyLogger。"}),"\n",(0,s.jsx)(n.p,{children:"或者你也可以声明一个动态模块，每次 imports 的时候配置下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { DynamicModule, Global, Module } from '@nestjs/common';\nimport { MyLogger } from './MyLogger';\n\n@Module({})\nexport class Logger2Module{\n\n    static register(options): DynamicModule {\n        return {\n            module: Logger2Module,\n            providers: [\n                MyLogger, \n                {\n                    provide: 'LOG_OPTIONS',\n                    useValue: options\n                }\n            ],\n            exports: [MyLogger, 'LOG_OPTIONS']\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"把传入的 options 作为 provider，在 Logger 里注入："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"每次 imports 的时候传入不同的配置："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在 AppService 里注入下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Inject, Injectable } from '@nestjs/common';\nimport { MyLogger } from './logger2/MyLogger';\n\n@Injectable()\nexport class AppService {\n\n  @Inject(MyLogger)\n  private logger: MyLogger;\n\n  getHello(): string {\n    this.logger.log('yyy', AppService.name);\n    \n    return 'Hello World!';\n  }\n}\n\n"})}),"\n",(0,s.jsxs)(n.p,{children:["浏览器访问 ",(0,s.jsx)(n.a,{href:"http://localhost:3000",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3000"})," 就可以看到 MyLogger 打印的传入的 option："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"具体是用全局模块还是动态模块，可以根据情况来选择。"}),"\n",(0,s.jsxs)(n.p,{children:["案例代码在",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/logger-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"日志打印可以用 Nest 的 Logger，它支持在创建应用的时候指定 logger 是否开启，打印的日志级别，还可以自定义 logger。"}),"\n",(0,s.jsx)(n.p,{children:"自定义 Logger 需要实现 LoggerService 接口，或者继承 ConsoleLogger 然后重写部分方法。"}),"\n",(0,s.jsx)(n.p,{children:"如果想在 Logger 注入一些 provider，就需要创建应用时设置 bufferLogs 为 true，然后用 app.useLogger(app.get(xxxLogger)) 来指定 Logger。"}),"\n",(0,s.jsx)(n.p,{children:"你可以把这个自定义 Logger 封装到全局模块，或者动态模块里。"}),"\n",(0,s.jsx)(n.p,{children:"当然，一般情况下，直接使用 Logger 就可以了。"})]})}function I(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_(e)}let k=I;I.__RSPRESS_PAGE_META={},I.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F36.%20Nest%20%E9%87%8C%E5%A6%82%E4%BD%95%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%EF%BC%9F.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"36. Nest 里如何打印日志？",headingTitle:"36. Nest 里如何打印日志？",frontmatter:{}}}}]);