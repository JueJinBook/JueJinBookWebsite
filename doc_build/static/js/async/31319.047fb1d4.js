"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["31319"],{115990:function(n,e,s){s.r(e),s.d(e,{default:()=>l});var c=s(552676),r=s(740453);let i=s.p+"static/image/1a98fab8e8c1431b82c1cf30194d7d19~tplv-k3u1fbpfcp-zoom-1.image.31639897.png";function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",code:"code",pre:"pre",img:"img",h3:"h3",ol:"ol",li:"li",blockquote:"blockquote"},(0,r.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"7-安全帽的使用哲学不可变数据实践指南",children:["7 “安全帽”的使用哲学——不可变数据实践指南",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#7-安全帽的使用哲学不可变数据实践指南",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["在上一节，我们围绕“什么是不可变数据”这个话题进行了深入的探讨，并建立了不可变数据和函数纯度之间的关联关系。我们已经明确知道，",(0,c.jsx)(e.strong,{children:"要想写出好的函数式代码，就需要确保数据的不可变性。"})]}),"\n",(0,c.jsx)(e.p,{children:"理解了“what”和“why”的问题，本节我们来好好聊一下“how”。"}),"\n",(0,c.jsxs)(e.h2,{id:"不可变不是要消灭变化而是要控制变化",children:["“不可变”不是要消灭变化，而是要控制变化",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#不可变不是要消灭变化而是要控制变化",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"大家知道，我们现代前端应用的复杂度整体是比较高的，其中最引人注目的莫过于“状态的复杂度”。"}),"\n",(0,c.jsx)(e.p,{children:"“状态”其实就是数据。"}),"\n",(0,c.jsx)(e.p,{children:"一个看似简单的 H5 营销游戏页面，背后可能就有几十上百个状态需要维护，如果没有状态之间的相互作用、相互转化，又怎能将精彩纷呈的前端交互呈现给用户呢？"}),"\n",(0,c.jsx)(e.p,{children:"程序失去变化，宛如人类失去灵魂。"}),"\n",(0,c.jsx)(e.p,{children:"所以咱们说，消灭变化是不可能的事情，也是万万不可的事情。"}),"\n",(0,c.jsxs)(e.p,{children:["我们真正要做的，是",(0,c.jsx)(e.strong,{children:"控制变化，确保所有的变化都在可预期的范围内发生"}),"，从而防止我们的程序被变化“偷袭”。"]}),"\n",(0,c.jsx)(e.p,{children:"正如老话所说：不怕他来，就怕他乱来。"}),"\n",(0,c.jsx)(e.p,{children:"我们本节要学习的，正是“不让他有机会乱来”的技术。"}),"\n",(0,c.jsxs)(e.h2,{id:"名不副实的-constant",children:['名不副实的 "constant"',(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#名不副实的-constant",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"首先，你需要小心 constant。"}),"\n",(0,c.jsx)(e.p,{children:"我至今仍然记得，“const” 关键字首次被引入 JavaScript 的那一年，函数式编程社区的 JS 开发者几乎集体高潮——不少人都认为，const 是对 JS 语言特性的一次重大改进，它将从根本上限制开发者的reassign（重新赋值）操作，进而保障数据的不可变性。"}),"\n",(0,c.jsx)(e.p,{children:"然而，理想很丰满，现实很骨感。const 真的能够保证数据的不变性吗？我只能说，const 了，但没完全 const（此处应有苦笑）。"}),"\n",(0,c.jsx)(e.p,{children:"众所周知，const 其实是单词“constant”的缩写，而“constant”意为“不变的”。如果我说，“the price is constant”，那么我想表达的就是“价格是不变的”：我早上去买是10块钱一斤，晚上去买也应该是10块钱一斤。"}),"\n",(0,c.jsxs)(e.p,{children:["也就是说，假如我们单纯从",(0,c.jsx)(e.strong,{children:"语义上"}),"来理解“const”这个关键字，那么它确实应该为我们保障数据的不变性。"]}),"\n",(0,c.jsxs)(e.p,{children:["但语义归语义，现实情况是，",(0,c.jsx)(e.strong,{children:"const 只能够保证值类型数据的不变性，却不能够保证引用类型数据的不变性。"})]}),"\n",(0,c.jsxs)(e.p,{children:["对于值类型来说，我这里用 ",(0,c.jsx)(e.code,{children:"const"})," 创建一个变量 ",(0,c.jsx)(e.code,{children:"price"}),"，并将它赋值为一个值类型（Number）数据："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const price = 10\n"})}),"\n",(0,c.jsxs)(e.p,{children:["如果我想修改 ",(0,c.jsx)(e.code,{children:"price"})," 的值，我只能尝试对它进行 reassign（重新赋值），比如这样："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"price = 20\n"})}),"\n",(0,c.jsxs)(e.p,{children:["显然，如下图所示，这是行不通的，毕竟我们的 ",(0,c.jsx)(e.code,{children:"const"})," 生下来就是专门阻止你做 reassign 这个动作的。"]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"只要禁止了 reassign， 就堵死了修改值类型变量的唯一一条路，也就确保了其数据内容的不变性。"}),"\n",(0,c.jsxs)(e.p,{children:["因此，对于存储值类型数据的变量来说，",(0,c.jsx)(e.code,{children:"const"})," 确实能够确保其内容的不变性。"]}),"\n",(0,c.jsx)(e.p,{children:"但对于引用类型来说，就算堵住了 reassign，也不影响我们修改数据的内容。 比如这段代码就是不会抛错的："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const me = {\n  name: 'xiuyan',\n  age: 30\n}\n\n// 这一行不会报错\nme.age = 35\n\nconsole.log(me)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["在这个案例中，我同样是使用 ",(0,c.jsx)(e.code,{children:"const"})," 关键字创建了变量 ",(0,c.jsx)(e.code,{children:"me"}),"，但在尝试修改 me 的内容时，我并没有将一个新的对象 reassign 给 me 变量，而是使用“.age”语法来访问并修改既有对象的其中一个属性。"]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"const"})," 没想到啊，引用类型的数据内容改变居然根本不需要 reassign。没有了 reassign，",(0,c.jsx)(e.code,{children:"const"})," 察觉不到变化的发生，也就只能原地摆烂了。"]}),"\n",(0,c.jsxs)(e.p,{children:["因此，",(0,c.jsxs)(e.strong,{children:[(0,c.jsx)(e.code,{children:"const"})," 对数据不变性的保证是有前提的，对于引用类型来说，const 并没有什么卵用"]}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"事实上，由于值类型数据天然存在不可变性，当我们讨论“JS 数据不可变性”时，更多的其实就是在讨论如何保证【引用类型】数据的不可变性。"}),"\n",(0,c.jsxs)(e.h2,{id:"不可变数据の实践原则拷贝而不是修改",children:["不可变数据の实践原则：拷贝，而不是修改",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#不可变数据の实践原则拷贝而不是修改",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"既然 constant 指望不上，那么我们有什么办法来确保引用类型数据的不可变性呢？"}),"\n",(0,c.jsxs)(e.p,{children:["答案也很简单，大家只需要记住一个原则：",(0,c.jsx)(e.strong,{children:"不要修改，要拷贝。"})]}),"\n",(0,c.jsxs)(e.h3,{id:"拷贝行为实践安全快速药到病除",children:["拷贝行为实践：安全、快速、药到病除",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#拷贝行为实践安全快速药到病除",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"这里我们继续沿用上一节招聘平台的例子，首先我有一个编号为001的岗位，它的主要信息囊括在这样一个对象里："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"const JOB_INFO_001 = {level: 7, workTime:2 , type:'engineer', city:'New York'} \n"})}),"\n",(0,c.jsx)(e.p,{children:"某天，hr找到我说，想要给代码里添加这样一段动态增加新职位的逻辑："}),"\n",(0,c.jsxs)(e.ol,{children:["\n",(0,c.jsxs)(e.li,{children:["首先确认公司当前的高管职位总数是否少于一定的阈值，从而决定要增加的新职位是高管职位还是基础职位 (这里我们假定有一个现成的函数可以使用，它叫做 ",(0,c.jsx)(e.code,{children:"isHighPosition()"}),"）"]}),"\n",(0,c.jsxs)(e.li,{children:["如果 ",(0,c.jsx)(e.code,{children:"isHighPosition()"})," 调用返回为 ",(0,c.jsx)(e.code,{children:"true"}),"，那么就动态地增加一个高管职位，这个职位基本所有信息都和某个现有的基础职位（此处以",(0,c.jsx)(e.code,{children:"001"}),"为例）一致，只有 ",(0,c.jsx)(e.code,{children:"level"})," 需要调整为 10。"]}),"\n",(0,c.jsxs)(e.li,{children:["否则，不增加高管职位，只增加一个基础职位（此处以",(0,c.jsx)(e.code,{children:"001"}),"为例）。"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"这个需求很简单，我们先来无脑实现一个粗糙版本："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 将 hr 的需求实现为函数 dynamicCreateJob()\nfunction dynamicCreateJob(baseJob) {\n  let newJob = baseJob\n  // 判断当前是否需要增加一个高管职位\n  if(isHighPosition()) {\n      // 针对高管职位，调整level信息\n      newJob.level = 10 \n  }\n  return newJob\n}\n\n// 这里以 001 为例，对函数进行测试\nconst dynamicJob = dynamicCreateJob(JOB_INFO_001)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这个粗糙版本显然并没有遵循“不可变数据”的原则——它直接在 ",(0,c.jsx)(e.code,{children:"baseJob"})," 的对象本体上进行了篡改，这将导致 ",(0,c.jsx)(e.code,{children:"JOB_INFO_001"})," 的内容直接被覆盖，从而影响整个程序中所有引用到 ",(0,c.jsx)(e.code,{children:"JOB_INFO_001"})," 的逻辑模块，导致这些模块集体“躺枪”。"]}),"\n",(0,c.jsxs)(e.p,{children:["人生建议：",(0,c.jsx)(e.strong,{children:"不要修改 baseJob，而是修改它的副本"}),"："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"// 将 hr 的需求实现为函数 dynamicCreateJob()\nfunction dynamicCreateJob(baseJob) {\n  // 创建一个 baseJob 的副本\n  let newJob = {...baseJob}\n  // 判断当前是否需要增加一个高管职位\n  if(isHighPosition()) {\n      // 针对高管职位，调整level信息\n      newJob.level = 10 \n  }\n  return newJob\n}\n\n// 这里以 001 为例，对函数进行测试\nconst dynamicJob = dynamicCreateJob(JOB_INFO_001)\n"})}),"\n",(0,c.jsx)(e.p,{children:"这样一来，baseJob 和 newJob 就彻底变成了两个泾渭分明的对象了。我对 newJob 所做的任何修改，都不会影响到 baseJob。"}),"\n",(0,c.jsxs)(e.p,{children:["通过拷贝，我们顺利地",(0,c.jsxs)(e.strong,{children:["将变化控制在了 ",(0,c.jsx)(e.code,{children:"dynamicCreateJob()"})," 函数内部"]}),"，避免了对全局其它逻辑模块的影响。"]}),"\n",(0,c.jsxs)(e.h3,{id:"拷贝的目的确保外部数据的只读性",children:["拷贝的目的：确保外部数据的只读性",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#拷贝的目的确保外部数据的只读性",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["用拷贝代替修改后，",(0,c.jsx)(e.code,{children:"baseJob"})," 对于 ",(0,c.jsx)(e.code,{children:"dynamicCreateJob()"})," 函数来说，成为了一个彻头彻尾的",(0,c.jsx)(e.strong,{children:"只读数据"}),"。"]}),"\n",(0,c.jsx)(e.p,{children:"关于只读数据，如果你是一个函数式编程发烧友，你可能会在一些文章中读到过一种过度概括的观点：不可变数据的内涵就是创造并使用“只读数据”。"}),"\n",(0,c.jsxs)(e.p,{children:["之所以说这种观点是过度概括的，是因为它少了一个“",(0,c.jsx)(e.strong,{children:"外部数据"}),"”的限定词。"]}),"\n",(0,c.jsx)(e.p,{children:"正如我在开篇时强调的那样，如果一个程序里只有只读数据、而没有数据的变化，这个程序几乎无法做任何事情。"}),"\n",(0,c.jsxs)(e.p,{children:["因此，无论是什么样的编程范式，",(0,c.jsx)(e.strong,{children:"只读数据都必须和可写数据共存"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["对于函数式编程来说，",(0,c.jsx)(e.strong,{children:"函数的外部数据是只读的，函数的内部数据则是可写的"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["对于一个函数来说，”外部数据“可以包括全局变量、文件系统数据、数据库数据、网络层数据等。有且仅有这些",(0,c.jsx)(e.strong,{children:"外部数据"}),"，存在【只读】的必要。"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"注：由于纯函数只能通过参数获取数据，因此如果需要使用外部数据，就必须将其作为参数传递给函数。"}),"\n"]}),"\n",(0,c.jsxs)(e.h2,{id:"小结",children:["小结",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"本节，我们探讨了不可变数据的两种最直接的实践思路：对于值类型数据，我们可以使用 const 来确保其不变性；对于引用类型数据，我们可以使用拷贝来确保源数据的不变性。"}),"\n",(0,c.jsx)(e.p,{children:"这其中，引用类型数据的不可变性值得我们再三思考——拷贝是否是一个完美的解法？它背后是否隐藏着种种问题？有没有比拷贝更加高效的解法呢？"}),"\n",(0,c.jsx)(e.p,{children:"答案当然是有啦，下一节，我们就将讨论不可变数据的进阶解法中最有名的一个——Persistent Data Structure（持久化数据结构）。"}),"\n",(0,c.jsxs)(e.h2,{id:"补充",children:["补充",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#补充",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"在本节，我们探讨了拷贝行为在函数式编程中的作用与意义，由此不难联想到另一个更加独立的命题：如何在 JS 中实现引用类型数据的拷贝？"}),"\n",(0,c.jsx)(e.p,{children:"这也是一道非常经典、也相对基础的面试题。"}),"\n",(0,c.jsx)(e.p,{children:"由于过于经典，相关的探讨在社区随处可见，有过面试经历的同学也基本都能对此信手拈来。这里我并不打算单独为其铺陈一个章节来叙述。"}),"\n",(0,c.jsx)(e.p,{children:"但对于不熟悉拷贝的同学，我想要给你以下的学习建议："}),"\n",(0,c.jsx)(e.p,{children:"在本文的示例中，我使用了扩展运算符来拷贝一个简单的对象。"}),"\n",(0,c.jsx)(e.p,{children:"类似的，你也可以使用 Object.assign 接口来实现拷贝。"}),"\n",(0,c.jsx)(e.p,{children:"而对于数组，除了扩展运算符外，还有像 slice、concat、map 等实用的数组接口供你挑选。"}),"\n",(0,c.jsx)(e.p,{children:"当然啦，这还并非“拷贝”的全貌，若想学得精些，你还需要辨析深、浅拷贝的区别。"}),"\n",(0,c.jsx)(e.p,{children:"其中深拷贝的实现尤其耐人寻味，也经常作为大厂的笔试题出现。"}),"\n",(0,c.jsxs)(e.p,{children:["学习深拷贝时，我建议你不仅要多吸收社区群众的智慧，更要善于向成熟的工具方法库进行学习，",(0,c.jsx)(e.a,{href:"https://github.com/lodash/lodash",target:"_blank",rel:"noopener noreferrer",children:"lodash"})," 的 deepClone 函数就是一个不错的教材。"]}),"\n",(0,c.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(d,{...n})}):d(n)}let l=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F7%20%E2%80%9C%E5%AE%89%E5%85%A8%E5%B8%BD%E2%80%9D%E7%9A%84%E4%BD%BF%E7%94%A8%E5%93%B2%E5%AD%A6%E2%80%94%E2%80%94%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97.md"]={toc:[{text:"“不可变”不是要消灭变化，而是要控制变化",id:"不可变不是要消灭变化而是要控制变化",depth:2},{text:'名不副实的 "constant"',id:"名不副实的-constant",depth:2},{text:"不可变数据の实践原则：拷贝，而不是修改",id:"不可变数据の实践原则拷贝而不是修改",depth:2},{text:"拷贝行为实践：安全、快速、药到病除",id:"拷贝行为实践安全快速药到病除",depth:3},{text:"拷贝的目的：确保外部数据的只读性",id:"拷贝的目的确保外部数据的只读性",depth:3},{text:"小结",id:"小结",depth:2},{text:"补充",id:"补充",depth:2}],title:"7 “安全帽”的使用哲学——不可变数据实践指南",headingTitle:"7 “安全帽”的使用哲学——不可变数据实践指南",frontmatter:{}}}}]);