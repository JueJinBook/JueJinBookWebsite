"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["2399"],{518016:function(e,t,a){a.r(t),a.d(t,{default:()=>o});var n=a(552676),s=a(740453);let d=a.p+"static/image/c243acc6595062b608f95847de40c94c.4853acc2.webp",r=a.p+"static/image/088f844c26c2d3f9c84a41df15318e10.c29158c9.webp",l=a.p+"static/image/13d4fc73b5c18ab679a95f456215636d.d1d3c717.webp";function i(e){let t=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",ol:"ol",li:"li",pre:"pre",h3:"h3",img:"img",ul:"ul"},(0,s.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.h1,{id:"21-sveltekit--链接选项",children:["21-SvelteKit ❘ 链接选项",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#21-sveltekit--链接选项",children:"#"})]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:"推荐学习指数：⭐️️，了解即可"}),"\n"]}),"\n",(0,n.jsxs)(t.h2,{id:"1-前言",children:["1. 前言",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,n.jsxs)(t.p,{children:["在 Next.js 中，客户端导航使用 ",(0,n.jsx)(t.code,{children:"<Link>"})," 组件实现，但 SvelteKit 直接使用 ",(0,n.jsx)(t.code,{children:"<a>"}),"标签实现。猛一看，使用 ",(0,n.jsx)(t.code,{children:"<a>"}),"更为自然，但细细一想，这样就修改了原生 ",(0,n.jsx)(t.code,{children:"<a>"}),"标签的默认行为。如果一个链接我不希望点击后被 JS 拦截，而是正常刷新页面该怎么是实现呢？"]}),"\n",(0,n.jsxs)(t.p,{children:["本篇讲解的链接选项就是为了解决这一问题。只要在 ",(0,n.jsx)(t.code,{children:"<a>"}),"标签上添加 ",(0,n.jsx)(t.code,{children:"data-sveltekit-*"}),"属性就可以自定义链接的行为。"]}),"\n",(0,n.jsxs)(t.p,{children:["当然这些属性不止可用于 ",(0,n.jsx)(t.code,{children:"<a>"}),"标签，也可以用于 ",(0,n.jsx)(t.code,{children:"<a>"})," 的父元素，也适用于 ",(0,n.jsx)(t.code,{children:'<form method="GET">'}),"。"]}),"\n",(0,n.jsxs)(t.h2,{id:"2-data-sveltekit-preload-data",children:["2. data-sveltekit-preload-data",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#2-data-sveltekit-preload-data",children:"#"})]}),"\n",(0,n.jsxs)(t.p,{children:["当用户将鼠标悬停在链接上，或者触发了 ",(0,n.jsx)(t.code,{children:"touchstart"}),"或 ",(0,n.jsx)(t.code,{children:"mousedown"}),"事件，此时用户很有可能会触发 ",(0,n.jsx)(t.code,{children:"click"}),"事件，SvelteKit 就会开始预加载数据，这会为应用多处几百毫秒的加载时间，让应用表现更加自然。"]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"data-sveltekit-preload-data"}),"属性就是控制这种行为，有两个值："]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:'"hover"'}),"：鼠标悬停的时候就开始预加载。如果是移动设备，则从 ",(0,n.jsx)(t.code,{children:"touchstart"})," 开始"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:'"tap"'}),"：从 ",(0,n.jsx)(t.code,{children:"touchstart"})," 或 ",(0,n.jsx)(t.code,{children:"mousedown"})," 事件开始，适用于预加载会导致误报的情况，因为预加载会调用目标页面的 load 函数"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["默认项目模板的 ",(0,n.jsx)(t.code,{children:"src/app.html"}),"中的 ",(0,n.jsx)(t.code,{children:"<body>"}),"元素就应用了 ",(0,n.jsx)(t.code,{children:'data-sveltekit-preload-data="hover"'}),"："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<body data-sveltekit-preload-data="hover">\n  <div style="display: contents">%sveltekit.body%</div>\n</body>\n'})}),"\n",(0,n.jsx)(t.p,{children:"这意味着每个链接都会在鼠标悬停时预加载。"}),"\n",(0,n.jsxs)(t.h3,{id:"21-拦截路由",children:["2.1. 拦截路由",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#21-拦截路由",children:"#"})]}),"\n",(0,n.jsxs)(t.p,{children:["也可以调用 ",(0,n.jsx)(t.code,{children:"$app/navigation"}),"的 ",(0,n.jsx)(t.code,{children:"preloadData"}),"实现预加载，这种实现方式类似于 Next.js 的拦截路由效果。让我们写个例子，目录结构如下："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-diff",children:"routes\n├─ posts\n│  ├─ [id]\n│  │  ├─ +page.js\n│  │  └─ +page.svelte\n│  ├─ +page.js\n│  └─ +page.svelte\n"})}),"\n",(0,n.jsxs)(t.p,{children:["新建 ",(0,n.jsx)(t.code,{children:"src/routes/posts/+page.js"}),"，代码如下："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:'export async function load() {\n  const posts = [\n    {\n      userId: 1,\n      id: 1,\n      title:\n        "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",\n      body: "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto",\n    },\n    {\n      userId: 1,\n      id: 2,\n      title: "qui est esse",\n      body: "est rerum tempore vitae\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\nqui aperiam non debitis possimus qui neque nisi nulla",\n    },\n    {\n      userId: 1,\n      id: 3,\n      title: "ea molestias quasi exercitationem repellat qui ipsa sit aut",\n      body: "et iusto sed quo iure\nvoluptatem occaecati omnis eligendi aut ad\nvoluptatem doloribus vel accusantium quis pariatur\nmolestiae porro eius odio et labore et velit aut",\n    },\n  ];\n\n  return {\n    posts,\n  };\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["新建 ",(0,n.jsx)(t.code,{children:"src/routes/posts/+page.svelte"}),"，代码如下："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-xml",children:'<script>\n  let { data } = $props();\n  import { preloadData, pushState, goto } from \'$app/navigation\';\n  import { page } from \'$app/stores\';\n<\/script>\n\n<h1>Posts list</h1>\n\n<ul>\n  {#each data.posts as { id, title }}\n    <li class="list-disc list-inside underline text-blue-500">\n      <a\n        href={`/posts/${id}`}\n        onclick={async (e) => {\n          e.preventDefault();\n          const { href } = e.currentTarget;\n          const result = await preloadData(href);\n          if (result.type === \'loaded\' && result.status === 200) {\n            console.log(result.data);\n            pushState(href, { selected: result.data });\n          } else {\n            goto(href);\n          }\n        }}>{title}</a\n      >\n    </li>\n  {/each}\n</ul>\n\n{#if $page.state.selected}\n  <div\n    class="flex h-screen w-full place-content-center items-center fixed left-0 bottom-0 py-5 bg-gray-500 bg-opacity-50"\n  >\n    <div class="bg-white mx-10 rounded-md p-5">\n      <h2>{$page.state.selected.post.title}</h2>\n      <hr />\n      {$page.state.selected.post.body}\n    </div>\n    <button class="absolute right-5 top-0 text-lg" onclick={() => history.back()}>x</button>\n  </div>\n{/if}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["新建 ",(0,n.jsx)(t.code,{children:"src/routes/posts/[id]/+page.js"}),"，代码如下："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:'import { error } from "@sveltejs/kit";\n\nexport async function load({ params }) {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/posts/${params.id}`\n  );\n  const post = await response.json();\n  if (post.title) {\n    return {\n      post,\n    };\n  }\n\n  error(404, "Not found");\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["新建 ",(0,n.jsx)(t.code,{children:"src/routes/posts/[id]/+page.svelte"}),"，代码如下："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:"<script>\n  let { data } = $props();\n<\/script>\n\nPost Content\n\n<hr />\n\n<h2>{data.post.title}</h2>\n\n<hr />\n\n{data.post.body}\n"})}),"\n",(0,n.jsx)(t.p,{children:"浏览器效果如下："}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)("img",{src:l,alt:""})}),"\n",(0,n.jsxs)(t.p,{children:["其实这种交互效果在国内网站并不常见，国外的一些艺术网站比如 ",(0,n.jsx)(t.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fdribbble.com%2F",title:"https://link.juejin.cn/?target=https%3A%2F%2Fdribbble.com%2F",target:"_blank",rel:"noopener noreferrer",children:"dribbble.com"})," 有类似的效果。当点击链接的时候，会在 Modal 中渲染链接的内容，但此时路由已经发生了变化，用户如果直接复制地址分享给其他用户，打开后就会直接进入分享的内容界面，而不是 Modal。这种交互的好处在于不打断已有的浏览体验，让用户继续停留在重要的页面上。"]}),"\n",(0,n.jsxs)(t.h2,{id:"3-data-sveltekit-preload-code",children:["3. data-sveltekit-preload-code",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#3-data-sveltekit-preload-code",children:"#"})]}),"\n",(0,n.jsx)(t.p,{children:"如果不想预加载数据，也可以预加载代码。"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"data-sveltekit-preload-code"})," 有 4 个值："]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:'"eager"'}),"：链接立刻预加载"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:'"viewport"'})," ：链接进入视口后预加载"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:'"hover"'}),"：类似于 preload-data，但仅预加载代码"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.code,{children:'"tap"'}),"：类似于 preload-data，但仅预加载代码"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"这是开发环境预加载数据的效果："}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)("img",{src:r,alt:""})}),"\n",(0,n.jsx)(t.p,{children:"这是开发环境预加载代码的效果："}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)("img",{src:d,alt:""})}),"\n",(0,n.jsxs)(t.p,{children:["可以看出：预加载代码不会触发目标路由的 ",(0,n.jsx)(t.code,{children:"load"})," 函数加载。"]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["注意：",(0,n.jsx)(t.code,{children:"viewport"})," 和 ",(0,n.jsx)(t.code,{children:"eager"})," 仅应用于导航后立刻出现在 DOM 中的链接，如果链接稍后才添加（比如在 ",(0,n.jsx)(t.code,{children:"{#if ...}"}),"中），则不会被预加载，直到被 ",(0,n.jsx)(t.code,{children:"hover"})," 或 ",(0,n.jsx)(t.code,{children:"tap"}),"触发。这是为了避免监控 DOM 变化而造成的性能损失。"]}),"\n"]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:"注意：当 preload data 和 preload code 一起使用的时候，要注意，preload code 是 preoload data 的前提条件，所以只有 preload code 比 preload data 更急切（eager）的时候，该属性才会起作用。举个例子，preload data 是 hover，preload code 是 tap，鼠标悬浮的时候预加载数据，点击的时候预加载代码，此时 preload code 不会起作用，最终表现是鼠标悬浮的时候预加载数据。"}),"\n"]}),"\n",(0,n.jsxs)(t.h2,{id:"4-data-sveltekit-reload",children:["4. data-sveltekit-reload",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#4-data-sveltekit-reload",children:"#"})]}),"\n",(0,n.jsx)(t.p,{children:"有的时候，你可能并不希望走客户端导航，而是正常的跳转刷新页面，此时可以添加 data-sveltekit-reload 属性："}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:'<a data-sveltekit-reload href="/path">\n  Path\n</a>\n'})}),"\n",(0,n.jsxs)(t.p,{children:["具有 ",(0,n.jsx)(t.code,{children:'rel="external"'}),"属性的链接也会是相同的处理。"]}),"\n",(0,n.jsxs)(t.h2,{id:"5-data-sveltekit-replacestate",children:["5. data-sveltekit-replacestate",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#5-data-sveltekit-replacestate",children:"#"})]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"data-sveltekit-replacestate"}),"在导航时不会创建新的条目，而是替换当前条目："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-javascript",children:'<a data-sveltekit-replacestate href="/path">\n  Path\n</a>\n'})}),"\n",(0,n.jsxs)(t.h2,{id:"6-data-sveltekit-keepfocus",children:["6. data-sveltekit-keepfocus",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#6-data-sveltekit-keepfocus",children:"#"})]}),"\n",(0,n.jsx)(t.p,{children:"如果希望导航后，焦点不要重置，比如希望搜索表单提交后，用户的注意力依然在文本输入上："}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-html",children:'<form data-sveltekit-keepfocus>\n  <input type="text" name="query" />\n</form>\n'})}),"\n",(0,n.jsx)(t.p,{children:"此时表单提交后，表单元素依然保留焦点。"}),"\n",(0,n.jsxs)(t.h2,{id:"7-data-sveltekit-noscroll",children:["7. data-sveltekit-noscroll",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#7-data-sveltekit-noscroll",children:"#"})]}),"\n",(0,n.jsxs)(t.p,{children:["当导航后，页面会滚动到顶点（除非链接包含 ",(0,n.jsx)(t.code,{children:"#hash"}),"），如果希望禁用这种行为："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-html",children:'<a href="path" data-sveltekit-noscroll>Path</a>\n'})}),"\n",(0,n.jsxs)(t.h2,{id:"8-禁用选项",children:["8. 禁用选项",(0,n.jsx)(t.a,{className:"header-anchor","aria-hidden":"true",href:"#8-禁用选项",children:"#"})]}),"\n",(0,n.jsxs)(t.p,{children:["如果要在已启用这些选项的元素上禁用这些选项，可以使用 ",(0,n.jsx)(t.code,{children:"false"}),"值："]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-html",children:'<div data-sveltekit-preload-data>\n  \x3c!-- 链接预加载 --\x3e\n  <a href="/a">a</a>\n  <a href="/b">b</a>\n  <a href="/c">c</a>\n\n  <div data-sveltekit-preload-data="false">\n    \x3c!-- 链接不会预加载 --\x3e\n    <a href="/d">d</a>\n    <a href="/e">e</a>\n    <a href="/f">f</a>\n  </div>\n</div>\n'})}),"\n",(0,n.jsx)(t.p,{children:"也可以有条件的应用到元素上："}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-html",children:"<div data-sveltekit-preload-data={condition ? 'hover' : false}>\n"})})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,s.ah)(),e.components);return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(i,{...e})}):i(e)}let o=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F21-SvelteKit%20%E2%9D%98%20%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. data-sveltekit-preload-data",id:"2-data-sveltekit-preload-data",depth:2},{text:"2.1. 拦截路由",id:"21-拦截路由",depth:3},{text:"3. data-sveltekit-preload-code",id:"3-data-sveltekit-preload-code",depth:2},{text:"4. data-sveltekit-reload",id:"4-data-sveltekit-reload",depth:2},{text:"5. data-sveltekit-replacestate",id:"5-data-sveltekit-replacestate",depth:2},{text:"6. data-sveltekit-keepfocus",id:"6-data-sveltekit-keepfocus",depth:2},{text:"7. data-sveltekit-noscroll",id:"7-data-sveltekit-noscroll",depth:2},{text:"8. 禁用选项",id:"8-禁用选项",depth:2}],title:"21-SvelteKit ❘ 链接选项",headingTitle:"21-SvelteKit ❘ 链接选项",frontmatter:{}}}}]);