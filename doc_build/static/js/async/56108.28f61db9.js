"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56108"],{448740:function(e,n,r){r.r(n),r.d(n,{default:()=>i});var o=r(552676),s=r(740453);let a=r.p+"static/image/13-3.07da8bc5.png",d=r.p+"static/image/13-2.33adcb15.png",t=r.p+"static/image/13-1.60067111.png";function c(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",pre:"pre",code:"code",p:"p",img:"img",ul:"ul",li:"li",h2:"h2"},(0,s.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h3,{id:"",children:(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,o.jsxs)(n.h1,{id:"13源码解读node-的程序架构及启动流程",children:["13源码解读：Node 的程序架构及启动流程",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13源码解读node-的程序架构及启动流程",children:"#"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-!",children:"本节有一定理解难度，建议新手同学在完成前面章节后，再来消化本节。\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:t,alt:"image.png | left | 746x363"})}),"\n",(0,o.jsx)(n.p,{children:"通常，网上搜 Node 的架构或者源码，经常搜到这样一张图，大体把 Node 分为了 3 层："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"第一层是对外暴露的 API，比如 fs/buffer/net 等，直接 require 进来用"}),"\n",(0,o.jsx)(n.li,{children:"第二层可以看做是桥接层，一头连 JS，一头连 C++，让这两种不同语言直接借助 layer 互相调用，比如 Node 项目中针对底层模块所封装的各种 bindings，或者我们可以直接从外部来引入 C++ 模块作为插件使用，通过 JS 直接调用第三方 C++ 模块"}),"\n",(0,o.jsx)(n.li,{children:"最后一层，就是 Node 整个底层所依赖的一坨 C/C++ 库，包括提供 JS 解释与运行的 v8 引擎，提供 crypto 加密算法的 openssl 等等。"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"那么这三层是如何分工协作的，他们的关系是什么，内部调用机制如何，我们先埋下一个伏笔在这里。"}),"\n",(0,o.jsxs)(n.h3,{id:"一切美好的事情总是从源码开始",children:["一切美好的事情，总是从源码开始",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一切美好的事情总是从源码开始",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["我们首先在命令行里输入 ",(0,o.jsx)(n.code,{children:"node"}),"（输入 .exit 则是退出）进入命令行模式，然后输入 ",(0,o.jsx)(n.code,{children:"global"})," 回车，可以看到类似下面的一坨内容："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"Object [global] {\n  ...\n  global: [Circular],\n  process:\n   process {\n     execArgv: [],\n     argv: [ '/Users/black/.nvm/versions/node/v10.11.0/bin/node' ],\n     env: { ..., _: '/Users/black/.nvm/versions/node/v10.11.0/bin/node' },\n     moduleLoadList:\n      [ 'Binding contextify',\n        'NativeModule buffer',\n        'Binding fs',\n        'Binding v8', ... ],\n     binding: [Function: binding] }},\n  Buffer: { [Function: Buffer] },\n  setImmediate: { [Function: setImmediate] },\n"})}),"\n",(0,o.jsxs)(n.p,{children:["可以看到一个 global 的对象上挂载了一堆的属性，比如 setTimeout process 都是可以直接访问的， 如果大家对浏览器熟悉，会知道在浏览器里面会有一个顶层全局变量 ",(0,o.jsx)(n.code,{children:"window"}),"，在 window 里面有 setTimeout alert 等各种属性或者方法。"]}),"\n",(0,o.jsxs)(n.p,{children:["可以这样简单理解，Node 里面有一个顶层全局对象 ",(0,o.jsx)(n.code,{children:"global"}),"，我们所写的所有 JS 代码，都是活跃在这个 global 下面，就像我们网页上的 JS 变量/函数都活跃在 window 下面一样，那么 window 或者 global 可以想象它是存在于某一个 context 或者说沙箱（说盒子也行吧）里面，这个沙箱呢是在 v8 的引擎实例里面运行的，也就是说，浏览器里的代码也好，我们所写的 Nodejs 代码也好，都运行在这个 Chrome v8 里面，在 v8 实例的 context 里面，我们具备访问 window/global 的能力。"]}),"\n",(0,o.jsxs)(n.p,{children:["在 global 下面，有一个很重要的对象 process，我们继续命令行输入： ",(0,o.jsx)(n.code,{children:"process.moduleLoadList"}),"，可以看到所有按照打印的顺序所加载进来的模块列表："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"[ 'Binding contextify',\n'Internal Binding worker',\n'NativeModule events',\n'NativeModule internal/async_hooks',\n'Binding uv',\n'NativeModule util'\n...\n"})}),"\n",(0,o.jsx)(n.p,{children:"这些模块有很多，如果再仔细辨认一下，会发现主要有这样几种："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Binding 的一类"}),"\n",(0,o.jsx)(n.li,{children:"Internal Binding 的一类"}),"\n",(0,o.jsx)(n.li,{children:"NativeModule 的一类"}),"\n",(0,o.jsx)(n.li,{children:"NativeModule internal 的一类"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["我们继续命令行输入：",(0,o.jsx)(n.code,{children:"module"}),"，会打印出来："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Module {\n  id: '<repl>',\n  exports: {},\n  parent: undefined,\n  filename: null,\n  loaded: false,\n  children: [],\n  paths:\n   [ '/Users/black/Downloads/node-10.x/repl/node_modules',\n     '/Users/black/Downloads/node_modules', ... ] }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["发现 module 也是一个对象，还有模块 id 啊，文件名称 filename 等等这些属性，继续命令行输入 ",(0,o.jsx)(n.code,{children:"require"}),"："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"{ [Function: require]\n  resolve: { [Function: resolve] paths: [Function: paths] },\n  main: undefined,\n  extensions: { '.js': [Function], '.json': [Function], '.node': [Function] },\n  cache: {} }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["发现 require 是一个函数而已，通过命令行，我们可以看到许多 Node 运行中提供的对象、方法和属性，比如 ",(0,o.jsx)(n.code,{children:"process"})," ",(0,o.jsx)(n.code,{children:"module"})," ",(0,o.jsx)(n.code,{children:"require"}),"，那它们都是怎么来的呢，我们还是得回到源头。"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:d,alt:"image.png | left | 746x155"})}),"\n",(0,o.jsxs)(n.p,{children:["源码里面藏着一切答案，我们就从源码开始吧，本册源码基于 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/tree/v10.x",target:"_blank",rel:"noopener noreferrer",children:"v10.x"}),"，下载地址 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/archive/v10.x.zip",target:"_blank",rel:"noopener noreferrer",children:(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/archive/v10.x.zip",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/nodejs/node/archive/v10.x.zip"})}),"，不同版本的源码差异有大有小，但整体加载流程大概一致，首次阅读源码，建议以本册下载的版本为准。"]}),"\n",(0,o.jsx)(n.p,{children:"首先在本地，创建一个 server.js，写入如下代码："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const path = require('path')\n\nconsole.log(path.resolve(__dirname, './server.js'))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["这段代码做的事情，是导入 path 模块，通过 ",(0,o.jsx)(n.code,{children:"path.resolve"})," 拼接当前 server.js 的完整路径，用 console.log 打印出来，在我的电脑上打印结果是：",(0,o.jsx)(n.code,{children:"/Users/black/Downloads/node-10.x/server.js"}),"。"]}),"\n",(0,o.jsxs)(n.h3,{id:"node-serverjs-的时候发生了什么",children:[(0,o.jsx)(n.code,{children:"node server.js"})," 的时候发生了什么？",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#node-serverjs-的时候发生了什么",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["在对 node 不熟悉的时候，我们发挥想象力，凭空猜测一下：node 应该是一个可执行程序，可能跟 windows 上的 exe 差不多，只不过是以命令的形式在终端上调用了一下，然后告诉它来把 server.js 代码运行一下，这个代码通过 require 加载了  path，运行后的结果它通过 ",(0,o.jsx)(n.code,{children:"console.log"})," 再告诉我们电脑的命令行（终端），打印出来，整个运行过程的细节我们可能是不清楚的，特别是 node 是如何启动的，如何把 server.js 加载进来，以及如何提供运行环境来执行这个 JS 文件的，今天我们只关注比较粗的大流程，细节和深度方面都不涉及，大家不用担心难度，整本小册也会尽量多配插图，帮助大家消化理解。"]}),"\n",(0,o.jsx)(n.p,{children:"开始之前，我们先定义一个便签纸篓子，来存放我们阶段性得出的结论，以便于我们脑海中形成记忆："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"let 纸篓子 = []\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"node-的源码目录和-c-代码占比",children:["Node 的源码目录和 C++ 代码占比",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#node-的源码目录和-c-代码占比",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:a,alt:"image.png | left | 746x163"})}),"\n",(0,o.jsx)(n.p,{children:"Node 的整个底层代码，大量使用 C/C++，JS 和 C/C++ 各 100 多万行，我们再看下 Node 的源码主要目录结构（暴力删减版）："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:".$ /Users/black/Downloads/node-10.x/\n├── deps               # Node 各种依赖\n│\xa0\xa0 ├── acorn            * Javascript 解析库\n│\xa0\xa0 ├── cares            * 异步 DNS 解析库\n│\xa0\xa0 ├── gtest            * C/C++ 单元测试框架\n│\xa0\xa0 ├── http_parser      * C 语言的 http 解析库\n│\xa0\xa0 ├── icu-small        * 跨平台 unicode 编码集\n│\xa0\xa0 ├── nghttp2          * HTTP/2 协议库\n│\xa0\xa0 ├── node-inspect     * Node 调试工具\n│\xa0\xa0 ├── npm              * Node 包管理工具\n│\xa0\xa0 ├── openssl          * 通信/算法加密库\n│\xa0\xa0 ├── uv(libuv)        * C 语言封装的异步 I/O 库\n│\xa0\xa0 ├── v8               * 提供 JS 的运行环境的 vm\n│\xa0\xa0 └── zlib             * 数据压缩解压的类库\n├── lib                # 原生 JS 模块库\n│\xa0\xa0 ├── fs.js\n│\xa0\xa0 ├── http.js\n│\xa0\xa0 ├── buffer.js\n│\xa0\xa0 ├── events.js\n│\xa0\xa0 ├── internal\n│\xa0\xa0 │\xa0\xa0 ├── bootstrap\n│\xa0\xa0 │\xa0\xa0 │\xa0\xa0 ├── cache.js\n│\xa0\xa0 │\xa0\xa0 │\xa0\xa0 ├── loaders.js\n│\xa0\xa0 │\xa0\xa0 │\xa0\xa0 └── node.js\n│\xa0\xa0 │\xa0\xa0 ├── http.js\n│\xa0\xa0 │\xa0\xa0 ├── modules\n│\xa0\xa0 │\xa0\xa0 │\xa0\xa0 ├── cjs\n│\xa0\xa0 │\xa0\xa0 │\xa0\xa0 └── esm\n│\xa0\xa0 │\xa0\xa0 ├── process\n├── src                # Node 底层源码\n│\xa0\xa0 ├── node_main.cc    * Node 启动的入口\n│\xa0\xa0 ├── node.cc         * Node 的启动主逻辑\n└── tools              # 编译所需要的工具\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"纸篓子 = [\n  '1. Node 源码有一坨依赖，大部分是 C/C++ 底层'\n]\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"node-初步启动---调用入口函数-main",children:["Node 初步启动 - 调用入口函数 main",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#node-初步启动---调用入口函数-main",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"我们大学上 C/C++ 语言课，可能对这坨代码印象比较深刻："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c++",children:"int main(void) {\n  \n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["没错，main 函数就是 C 语言世界里的程序入口了，我们到 Node 目录下，找到 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node_main.cc#L124",target:"_blank",rel:"noopener noreferrer",children:"node-master/src/node_main.cc"})," 第 124 行，核心就干了一点事，根据操作系统干了些处理额外参数的活儿，就跑去调用 Start 函数了。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"94 int main(int argc, char* argv[]) {\n25  #ifdef _WIN32\n..\n72:   return node::Start(argc, argv);\n73  }\n74  #else\n..\n124:   return node::Start(argc, argv);\n125  }\n126  #endif\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"纸篓子 = [\n  '1. Node 源码有一坨依赖，大部分是 C/C++ 底层',\n  '2. Node 启动入口是 node_main.cc 的 main 函数',\n]\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"进入多层-start-函数跑通主逻辑",children:["进入多层 Start 函数跑通主逻辑",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#进入多层-start-函数跑通主逻辑",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["到 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L3034",target:"_blank",rel:"noopener noreferrer",children:"node-master/src/node.cc"})," 里面能找到好几个 Start 函数以及函数调用，我们从 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L2891",target:"_blank",rel:"noopener noreferrer",children:"2891 行"}),"、",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L2987",target:"_blank",rel:"noopener noreferrer",children:"2987 行"}),"、",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L3034",target:"_blank",rel:"noopener noreferrer",children:"3034 行"})," 能拎出来这 3 个 Start 函数定义，他们存在依次调用关系。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c++",children:"inline int Start(Isolate* isolate,..\ninline int Start(uv_loop_t* event_loop...\nint Start(int argc, char** argv) {\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"纸篓子 = [\n  '1. Node 源码有一坨依赖，大部分是 C/C++ 底层',\n  '2. Node 启动入口是 node_main.cc 的 main 函数',\n  '3. 入口函数找到 node.cc 的 3 个 Start，依次调用',\n]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["先来看第一个 Start 函数，它里面的入参 ",(0,o.jsx)(n.code,{children:"(int argc, char** argv)"}),"，跟我们在上面 main 函数里面，调用 Start 的入参保持一致，然后开始各种忙活，比如 ",(0,o.jsx)(n.code,{children:"Init"})," ",(0,o.jsx)(n.code,{children:"v8"})," 参数处理和 v8 初始化啊，最后清理战场，帮助 Node 退出，我们关注 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L3034",target:"_blank",rel:"noopener noreferrer",children:"3034 行"})," 这里："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c++",children:"int Start(int argc, char** argv) {\n  // 注册内置模块/参数预处理等工作\n  Init(&args, &exec_args);\n  // v8 初始化\n  V8::Initialize();\n\n  Start(uv_default_loop(), args, exec_args);\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"纸篓子 = [\n  '1. Node 源码有一坨依赖，大部分是 C/C++ 底层',\n  '2. Node 启动入口是 node_main.cc 的 main 函数',\n  '3. 入口函数找到 node.cc 的 3 个 Start，依次调用',\n  '4. node.cc 的第一个 Start 做了初始化工作，调用第二个 Start',\n]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["这里的 ",(0,o.jsx)(n.code,{children:"Start(uv_default_loop(), args, exec_args)"})," 调用了第二个 Start 函数，且对这个 Start 传了 3 个参数，第一个参数是一个函数，直接执行掉了，它来初始化了 Node 的事件循环，也就是 Event Loop，后两个参数略去不表，我们继续前往第二个 Start，也就是 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L2987",target:"_blank",rel:"noopener noreferrer",children:"2987 行"}),"："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c++",children:"inline int Start(uv_loop_t* event_loop,\n                <std::string>& args,\n                <std::string>& exec_args) {\n  // 生成一个独立 v8 引擎实例，所有 JS 代码都将丢到它里面执行\n  const isolate = NewIsolate(allocator.get());\n\n  // 配置 v8 的引擎实例和里面的工作区，准备干活\n  Locker locker(isolate);\n  Isolate::Scope isolate_scope(isolate);\n  HandleScope handle_scope(isolate);\n  ...\n  \n  // 第三个 Start，传进去引擎实例，准备编译我们的 JS 代码了\n  Start(isolate, isolate_data.get(), args, exec_args);\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"纸篓子 = [\n  '1. Node 源码有一坨依赖，大部分是 C/C++ 底层',\n  '2. Node 启动入口是 node_main.cc 的 main 函数',\n  '3. 入口函数找到 node.cc 的 3 个 Start，依次调用',\n  '4. node.cc 的第一个 Start 初始化了 v8，调用第二个 Start',\n  '5. 第二个 Start 让 v8 准备了引擎实例，调用第三个 Start',\n]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["如上面代码中的注释，前面都是准备工作，我们继续前往 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L2891",target:"_blank",rel:"noopener noreferrer",children:"2891 行"}),"，这个 Start 有点贪心，做的事情太多，我们先精简下："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c++",children:"inline int Start(isolate, isolate_data,\n                 args, exec_args) {\n\n  // 先在一个引擎实例中准备 v8 上下文\n  Context::Scope context_scope(context);\n\n  // 拼凑起来一个 node 启动环境，然后把它收拾舒服\n  // 比如 libuv 事件循环，process 全局变量之类\n  Environment env(isolate_data,\n      context, v8_platform.GetTracingAgentWriter())\n  env.Start(args, exec_args, v8_is_profiling);\n\n  // 把原生模块和我们的 JS 代码加载进来\n  LoadEnvironment(&env);\n\n  // libuv 上场，不断轮询有没有活儿干\n  uv_run(env.event_loop(), UV_RUN_DEFAULT);\n  more = uv_loop_alive(env.event_loop());\n  if (more) continue;\n  more = uv_loop_alive(env.event_loop());\n\n  // 没活儿了就抛 exit 事件，拼命退出进程，各种清理工作\n  EmitExit(&env)\n  env.RunCleanup();\n  RunAtExit(&env);\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"跟着上面的注释，我们获取到了一个信息，那就是这个 Start 把所有的活儿都干了，既有场地准备，又有各种环境条件准备，又把演员们（模块和 JS） 拉过来，表演一个又一个节目，节目演完了就收拾场地跑人，来把纸篓子扩充下："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"纸篓子 = [\n  '1. Node 源码有一坨依赖，大部分是 C/C++ 底层',\n  '2. Node 启动入口是 node_main.cc 的 main 函数',\n  '3. 入口函数找到 node.cc 的 3 个 Start，依次调用',\n  '4. node.cc 的第一个 Start 初始化了 v8，调用第二个 Start',\n  '5. 第二个 Start 让 v8 准备了引擎实例，调用第三个 Start',\n  '6. 第三个 Start：\n      6.1 首先准备了 v8 的上下文 Context',\n  '   6.2 其次准备了 Node 的启动环境，对各种需要的变量做整理',\n  '   6.3 再把 Node 原生模块和我们的 JS 代码都加载进来运行',\n  '   6.4 最后把主持人 libuv 请上场，执行 JS 里的各种任务',\n  '7. libuv 没活干了，就一层层来退出进程、收拾场地，退出程序',\n]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["对于 6.3 的 ",(0,o.jsx)(n.code,{children:"LoadEnvironment(&env)"}),"，它是台柱子，代码在 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L2120",target:"_blank",rel:"noopener noreferrer",children:"2120 行"}),"："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c++",children:'void LoadEnvironment(Environment* env) {\n  // 先把 loaders.js 和 node.js 的代码拎过来\n  // 配置各种对象、变量，如全局对象 global，内置模块的 bind 等等\n  loaders_name = ...("internal/bootstrap/loaders.js");\n  loaders_bootstrapper = ...(LoadersBootstrapperSource(env), loaders_name);\n  node_name = ...("internal/bootstrap/node.js");\n  node_bootstrapper = ...(NodeBootstrapperSource(env), node_name);\n\n  // 把 global 全局对象挂载到 context 上\n  Local<Object> global = env->context()->Global();\n  global->Set(env->isolate(), "global", global);\n\n  // 各种配置函数的参数后，执行 Bootstrap 的 loaders.js 和 Node.js\n  ExecuteBootstrapper(env, loaders_bootstrapper,\n    loaders_bootstrapper_args, &bootstrapped_loaders))\n  ExecuteBootstrapper(env, node_bootstrapper,\n    node_bootstrapper_args, &bootstrapped_node))\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["这两个 JS 是靠 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L2099",target:"_blank",rel:"noopener noreferrer",children:"2099 行 ExecuteBootstrapper"})," 执行的，在它里面，很简单，就是通过 ",(0,o.jsx)(n.code,{children:"bootstrapper->Call()"})," 来调用执行。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-c++",children:"static bool ExecuteBootstrapper(\n  Environment* env,\n  Local<Function> bootstrapper, \n  int argc, Local<Value> argv[],\n  Local<Value>* out) {\n  bool ret = bootstrapper->Call(\n      env->context(), Null(env->isolate()), argc, argv).ToLocal(out);\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"调用执行后，Node 里面的模块系统就 Ready 了，有了模块系统，我们各种 require 就能跑起来了。"}),"\n",(0,o.jsx)(n.p,{children:"至此，Node 启动过程一日游结束，再来看下纸篓子："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"纸篓子 = [\n  '1. Node 源码有一坨依赖，大部分是 C/C++ 底层',\n  '2. Node 启动入口是 node_main.cc 的 main 函数',\n  '3. 入口函数找到 node.cc 的 3 个 Start，依次调用',\n  '4. node.cc 的第一个 Start 初始化了 v8，调用第二个 Start',\n  '5. 第二个 Start 让 v8 准备了引擎实例，调用第三个 Start',\n  '6. 第三个 Start：\n      6.1 首先准备了 v8 的上下文 Context',\n  '   6.2 其次准备了 Node 的启动环境，对各种需要的变量做整理',\n  '   6.3 再把 Node 原生模块和我们的 JS 代码都加载进来运行',\n  '   6.4 最后把主持人 libuv 请上场，执行 JS 里的各种任务',\n  '7. libuv 没活干了，就一层层来退出进程、收拾场地，退出程序',\n]\n"})}),"\n",(0,o.jsx)(n.p,{children:"简单总结一下，Node 的运行是按照一定的顺序，来分别把 v8 启动，libuv 初始化，再把 v8 实例创建，Context 准备好，最后把模块代码导进来，最后把 libuv 跑起来，按照一定策略执行模块代码里的任务，直到任务跑完。"}),"\n",(0,o.jsx)(n.p,{children:"这里面还有 1 个遗留问题："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"到底 loaders.js 和 node.js 是怎么让我们的模块系统生效的？"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["第一个问题，它的背后涉及到 ",(0,o.jsx)(n.code,{children:"require/exports"})," 如何生效，Node 里面的模块和我们 npm install 的模块是如何加载进来工作的，是非常核心的基础知识，我们在 ",(0,o.jsx)(n.a,{href:"https://juejin.im/editor/book/5bc1bf3e5188255c3272e315/section/5bc213906fb9a05cd676e08b",target:"_blank",rel:"noopener noreferrer",children:"[视频时长统计] Node 的模块机制（CommonJS）与包管理"}),"有过探讨。"]}),"\n",(0,o.jsxs)(n.h2,{id:"思考",children:["思考",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["最后给大家留一个小作业，比如 Node server.js 的这个 server.js 作为被执行文件的路径参数，到底是如何一层层传下来的，以及从 main 到 3 个 Start，到 ",(0,o.jsx)(n.code,{children:"bootstrapper->Call()"}),"，中间有引擎实例啊，上下文啊各种参数，它们一路传下来，参数也经过不断加工，在每个环节又各是什么意思，大家可以自己尝试思考下，结合源码在本地画一画答案。"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F13%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%EF%BC%9ANode%20%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.md"]={toc:[{text:"",id:"",depth:3},{text:"一切美好的事情，总是从源码开始",id:"一切美好的事情总是从源码开始",depth:3},{text:"`node server.js` 的时候发生了什么？",id:"node-serverjs-的时候发生了什么",depth:3},{text:"Node 的源码目录和 C++ 代码占比",id:"node-的源码目录和-c-代码占比",depth:3},{text:"Node 初步启动 - 调用入口函数 main",id:"node-初步启动---调用入口函数-main",depth:3},{text:"进入多层 Start 函数跑通主逻辑",id:"进入多层-start-函数跑通主逻辑",depth:3},{text:"思考",id:"思考",depth:2}],title:"13源码解读：Node 的程序架构及启动流程",headingTitle:"13源码解读：Node 的程序架构及启动流程",frontmatter:{}}}}]);