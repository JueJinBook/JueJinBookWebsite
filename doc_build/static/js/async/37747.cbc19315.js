"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["37747"],{587193:function(n,e,i){i.r(e),i.d(e,{default:()=>m});var r=i(552676),t=i(740453);let s=i.p+"static/image/17ffe217580233f2f74c0bd0e2821244.7c1a5f2f.png",a=i.p+"static/image/0d8474b67482d53d738d7da15208eea2.1d674e1e.png",c=i.p+"static/image/0e2b07e7f8649b48cf1ac913655b569e.5806d156.png",o=i.p+"static/image/8ac7201837562284317bd712bd1983ef.f81a5f43.png",l=i.p+"static/image/36fe8cc69cd664340c4ae6a8a452a2f5.f8b86f44.png",d=i.p+"static/image/ae1c662142b609f2fa12c6b5c5ae2bbf.1c55aa22.png";function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",code:"code",img:"img",pre:"pre",blockquote:"blockquote",strong:"strong"},(0,t.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"12原理解析iframe-隔离",children:["12.原理解析：iframe 隔离",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12原理解析iframe-隔离",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在 V8 隔离中我们重点讲解了 Isolate 以及 Context 的概念，这也是 V8 实现 JS 执行上下文隔离的重要能力。本文主要讲解如何利用 iframe 实现在 SPA 模式下的 Context 隔离思路，从而帮助大家更好的理解 JS 隔离。"}),"\n",(0,r.jsxs)(e.h2,{id:"隔离思路",children:["隔离思路",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#隔离思路",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在动态 Script 方案中，我们发现在同一个全局执行上下文加载不同微应用的 JS 进行执行时，由于没有隔离措施，很容易导致微应用产生 JS 运行时冲突。在 V8 的隔离中我们了解到可以通过创建不同的 Isolate 或者 Context 对 JS 代码进行上下文隔离处理，但是这种能力没有直接开放给浏览器，因此我们无法直接利用 Web API 在动态 Script 方案中实现微应用的 JS 隔离。同时我们了解到在浏览器中创建 iframe 时会创建相应的全局执行上下文栈，用于切换主应用和 iframe 应用的全局执行上下文环境，因此可以通过在应用框架中创建空白的 iframe 来隔离微应用的 JS 运行环境。为此，我们大致可以做如下几个阶段的隔离尝试："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["阶段一：加载空白的 iframe 应用，例如 ",(0,r.jsx)(e.code,{children:'src="about:blank"'}),"，生成新的微应用执行环境"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"解决全局执行上下文隔离问题"}),"\n",(0,r.jsx)(e.li,{children:"解决加载 iframe 的白屏体验问题"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"阶段二：加载同源的 iframe 应用，返回空的内容，生成新的微应用执行环境"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"解决全局执行上下文隔离问题"}),"\n",(0,r.jsx)(e.li,{children:"解决加载 iframe 的白屏体验问题"}),"\n",(0,r.jsx)(e.li,{children:"解决数据状态同步问题"}),"\n",(0,r.jsx)(e.li,{children:"解决前进后退问题"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"接下来本课程将实现上述两个阶段的隔离能力。"}),"\n",(0,r.jsxs)(e.h2,{id:"阶段一空白页隔离",children:["阶段一：空白页隔离",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#阶段一空白页隔离",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在动态 Script 方案中，微应用的 JS 运行在主应用的 Renderer UI 线程中（通过 Script 标签进行加载执行），这会导致微应用和主应用共享一个 JS 执行环境而产生全局属性冲突。为了解决冲突问题，当时采用了立即执行的匿名函数来创建各自执行的作用域，但是没有在本质上隔离全局执行上下文（例如原型链），接下来我们重新设计一个 iframe 隔离方案，使微应用和主应用彼此可以真正隔离 JS 的运行环境。具体方案如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"大致实现的思路如下所示："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"通过请求获取后端的微应用列表数据，动态创建主导航"}),"\n",(0,r.jsx)(e.li,{children:"根据导航切换微应用，切换时会跨域请求微应用 JS 的文本内容并进行缓存处理"}),"\n",(0,r.jsx)(e.li,{children:"微应用的 JS 会在 iframe 环境中通过 Script 标签进行隔离执行"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"实现效果如下所示，图中的两个按钮（微应用导航）根据后端数据动态渲染，点击按钮后会跨域请求微应用的 JS 静态资源并创建空白的 iframe 进行隔离执行："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"文件的结构目录如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"├── public                  # 托管的静态资源目录\n│   ├── main/               # 主应用资源目录                        \n│   │   └── index.html                                        \n│   └── micro/              # 微应用资源目录\n│        ├── micro1.js        \n│        └── micro2.js      \n├── config.js               # 公共配置\n├── main-server.js          # 主应用服务\n└── micro-server.js         # 微应用服务\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/iframe-sandbox-blank",target:"_blank",rel:"noopener noreferrer",children:"demo/iframe-sandbox-blank"})," 分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["iframe 隔离中获取微应用 JS 进行执行的方式和动态 Script 的方案存在差异，在动态 Script 的方案中利用浏览器内置的 ",(0,r.jsx)(e.code,{children:"<script>"})," 标签进行请求和执行，天然支持跨域。而在 iframe 隔离中需要通过 Ajax 的形式获取 JS 文件进行手动隔离执行。由于微应用和主应用跨域，因此需要微应用的服务支持跨域请求，具体如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// micro-server.js\nimport express from "express";\nimport morgan from "morgan";\nimport path from "path";\nimport config from "./config.js";\nconst app = express();\n\nconst { port, host } = config;\n\n// 打印请求日志\napp.use(morgan("dev"));\n\n// 设置支持跨域请求头（也可以使用 cors 中间件）\n// 这里设置了所有请求的跨域支持，也可以单独对 express.static 设置跨域响应头\napp.use((req, res, next) => {\n  res.header("Access-Control-Allow-Origin", \'*\');\n  res.header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");\n  res.header("Allow", "GET, POST, OPTIONS");\n  next();\n});\n\napp.use(\n  express.static(path.join("public", "micro"))\n);\n\n// 启动 Node 服务\napp.listen(port.micro, host);\nconsole.log(`server start at http://${host}:${port.main}/`);\n'})}),"\n",(0,r.jsx)(e.p,{children:"在动态 Script 的微应用设计中，必须通过立即执行的匿名函数进行作用域隔离，为了验证 iframe 隔离的效果，这里把立即执行的匿名函数去除："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// public/micro/micro1.js\nlet root;\nroot = document.createElement("h1");\nroot.textContent = "微应用1";\ndocument.body.appendChild(root);\n\n// public/micro/micro2.js\nlet root;\nroot = document.createElement("h1");\nroot.textContent = "微应用2";\ndocument.body.appendChild(root);\n'})}),"\n",(0,r.jsxs)(e.p,{children:["如果是在动态 Script 的方案下，上述 ",(0,r.jsx)(e.code,{children:"micro1.js"})," 和 ",(0,r.jsx)(e.code,{children:"micro2.js"})," 由于都是在主应用的全局执行上下文中执行，会产生属性命令冲突。这里通过空白的 iframe 来建立完整的隔离执行环境，具体实现如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-html",children:'\x3c!-- public/main/index.html --\x3e\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n\n  <body>\n    <h1>Hello，Sandbox Script!</h1>\n\n    \x3c!-- 主应用导航 --\x3e\n    <div id="nav"></div>\n\n    \x3c!-- 主应用内容区 --\x3e\n    <div id="container"></div>\n\n    <script type="text/javascript">\n      // 隔离类\n      class MicroAppSandbox {\n        // 配置信息\n        options = null;\n        // iframe 实例\n        iframe = null;\n        // iframe 的 Window 实例\n        iframeWindow = null;\n        // 是否执行过 JS\n        exec = false;\n\n        constructor(options) {\n          this.options = options;\n          // 创建 iframe 时浏览器会创建新的全局执行上下文，用于隔离主应用的全局执行上下文\n          this.iframe = this.createIframe();\n          this.iframeWindow = this.iframe.contentWindow;\n        }\n\n        createIframe() {\n          const { rootElm, id, url } = this.options;\n          const iframe = window.document.createElement("iframe");\n          // 创建一个空白的 iframe\n          const attrs = {\n            src: "about:blank",\n            "app-id": id,\n            "app-src": url,\n            style: "border:none;width:100%;height:100%;",\n          };\n          Object.keys(attrs).forEach((name) => {\n            iframe.setAttribute(name, attrs[name]);\n          });\n          rootElm?.appendChild(iframe);\n          return iframe;\n        }\n\n        // 激活\n        active() {\n          this.iframe.style.display = "block";\n          // 如果已经通过 Script 加载并执行过 JS，则无需重新加载处理\n          if(this.exec) return;\n          this.exec = true;\n          const scriptElement = this.iframeWindow.document.createElement(\'script\');\n          scriptElement.textContent = this.options.scriptText;\n          this.iframeWindow.document.head.appendChild(scriptElement);\n        }\n\n        // 失活\n        // INFO: JS 加载以后无法通过移除 Script 标签去除执行状态\n        // INFO: 因此这里不是指代失活 JS，如果是真正想要失活 JS，需要销毁 iframe 后重新加载 Script\n        inactive() {\n          this.iframe.style.display = "none";\n        }\n\n        // 销毁隔离实例\n        destroy() {\n          this.options = null;\n          this.exec = false;\n          if(this.iframe) {\n            this.iframe.parentNode?.removeChild(this.iframe);\n          }\n          this.iframe = null;\n        }\n      }\n\n      // 微应用管理\n      class MicroApp {\n        // 缓存微应用的脚本文本（这里假设只有一个执行脚本）\n        scriptText = "";\n        // 隔离实例\n        sandbox = null;\n        // 微应用挂载的根节点\n        rootElm = null;\n\n        constructor(rootElm, app) {\n          this.rootElm = rootElm;\n          this.app = app;\n        }\n\n        // 获取 JS 文本（微应用服务需要支持跨域请求获取 JS 文件）\n        async fetchScript(src) {\n          try {\n            const res = await window.fetch(src);\n            return await res.text();\n          } catch (err) {\n            console.error(err);\n          }\n        }\n\n        // 激活\n        async active() {\n          // 缓存资源处理\n          if (!this.scriptText) {\n            this.scriptText = await this.fetchScript(this.app.script);\n          }\n\n          // 如果没有创建隔离实例，则实时创建\n          // 需要注意只给激活的微应用创建 iframe 隔离，因为创建 iframe 会产生内存损耗\n          if (!this.sandbox) {\n            this.sandbox = new MicroAppSandbox({\n              rootElm: this.rootElm,\n              scriptText: this.scriptText,\n              url: this.app.script,\n              id: this.app.id,\n            });\n          }\n\n          this.sandbox.active();\n        }\n\n        // 失活\n        inactive() {\n          this.sandbox?.inactive();\n        }\n      }\n\n      // 微前端管理\n      class MicroApps {\n        // 微应用实例映射表\n        appsMap = new Map();\n        // 微应用挂载的根节点信息\n        rootElm = null;\n\n        constructor(rootElm, apps) {\n          this.rootElm = rootElm;\n          this.setAppMaps(apps);\n        }\n\n        setAppMaps(apps) {\n          apps.forEach((app) => {\n            this.appsMap.set(app.id, new MicroApp(this.rootElm, app));\n          });\n        }\n\n        // TODO: prefetch 微应用\n        prefetchApps() {}\n\n        // 激活微应用\n        activeApp(id) {\n          const app = this.appsMap.get(id);\n          app?.active();\n        }\n\n        // 失活微应用\n        inactiveApp(id) {\n          const app = this.appsMap.get(id);\n          app?.inactive();\n        }\n      }\n\n      // 主应用管理\n      class MainApp {\n        microApps = [];\n        microAppsManager = null;\n\n        constructor() {\n          this.init();\n        }\n\n        async init() {\n          this.microApps = await this.fetchMicroApps();\n          this.createNav();\n          this.navClickListener();\n          this.hashChangeListener();\n          // 创建微前端管理实例\n          this.microAppsManager = new MicroApps(\n            document.getElementById("container"),\n            this.microApps\n          );\n        }\n\n        // 从主应用服务器获请求微应用列表信息\n        async fetchMicroApps() {\n          try {\n            const res = await window.fetch("/microapps", {\n              method: "post",\n            });\n            return await res.json();\n          } catch (err) {\n            console.error(err);\n          }\n        }\n\n        // 根据微应用列表创建主导航\n        createNav(microApps) {\n          const fragment = new DocumentFragment();\n          this.microApps?.forEach((microApp) => {\n            // TODO: APP 数据规范检测 (例如是否有 script）\n            const button = document.createElement("button");\n            button.textContent = microApp.name;\n            button.id = microApp.id;\n            fragment.appendChild(button);\n          });\n          nav.appendChild(fragment);\n        }\n\n        // 导航点击的监听事件\n        navClickListener() {\n          const nav = document.getElementById("nav");\n          nav.addEventListener("click", (e) => {\n            // 并不是只有 button 可以触发导航变更，例如 a 标签也可以，因此这里不直接处理微应用切换，只是改变 Hash 地址\n            // 不会触发刷新，类似于框架的 Hash 路由\n            window.location.hash = event?.target?.id;\n          });\n        }\n\n        // hash 路由变化的监听事件\n        hashChangeListener() {\n          // 监听 Hash 路由的变化，切换微应用（这里设定一个时刻只能切换一个微应用）\n          window.addEventListener("hashchange", () => {\n            this.microApps?.forEach(async ({ id }) => {\n              id === window.location.hash.replace("#", "")\n                ? this.microAppsManager.activeApp(id)\n                : this.microAppsManager.inactiveApp(id);\n            });\n          });\n        }\n      }\n\n      new MainApp();\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsx)(e.p,{children:"上述示例中主要设计了几个类，具体的功能如下所示："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"MainApp"}),"：负责管理主应用，包括获取微应用列表、创建微应用的导航、切换微应用"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"MicroApps"}),"：负责维护微应用列表，包括预加载、添加和删除微应用等"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"MicroApp"}),"：负责维护微应用，包括请求和缓存静态资源、激活微应用、状态管理等"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"MicroAppSandbox"}),"：负责维护微应用隔离，包括创建、激活和销毁隔离实例等"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"使用该隔离方案不仅仅可以解决动态 Script 方案无法解决的全局执行上下文隔离问题（包括 CSS 隔离），还可以通过空闲时间预获取微应用的静态资源来加速 iframe 内容的渲染，从而解决原生 iframe 产生的白屏体验问题。"})," 除此之外，使用 ",(0,r.jsx)(e.code,{children:"src=about:blank"})," 会使当前 iframe 继承父浏览上下文的源，从而会遵循同源策略："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// iframe src: about:blank \n// 嵌入一个遵从同源策略的空白页：https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe\n// 源的继承：在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URL 没有包含源服务器的相关信息：https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E6%BA%90%E7%9A%84%E7%BB%A7%E6%89%BF\nconsole.log(window.document.domain === window.parent.document.domain);  // true\n"})}),"\n",(0,r.jsx)(e.p,{children:"因此在 iframe 中可以像动态 Script 脚本一样发起 Ajax 请求，例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 可以请求主应用服务所在的接口，因为继承了主应用的源\nvar oReq = new XMLHttpRequest();\noReq.addEventListener("load", reqListener);\noReq.open("POST", "/microapps");\noReq.send();\nfunction reqListener() {\n  console.log(this.responseText);\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["需要注意，将 iframe 设置成 ",(0,r.jsx)(e.code,{children:"src=about:blank"})," 会产生一些限制，例如在 Vue 中使用 Vue-Router 时底层框架源码会用到 ",(0,r.jsx)(e.code,{children:"history.pushState"})," 或者 ",(0,r.jsx)(e.code,{children:"history.replaceState"}),"，此时会因为 ",(0,r.jsx)(e.code,{children:"about:blank"})," 而导致 iframe 无法正常运行，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 在微应用的 micro1.js 中运行如下代码会 产生 history 报错\nwindow.history.pushState({ key: "hello" }, "", "/test");\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:["使用 ",(0,r.jsx)(e.code,{children:"history"})," 更改 URL 时可以保持页面无刷（不会发起服务请求，除非手动刷新页面），但是必须使新的 URL 和当前 URL 同源，否则就会抛出上述异常。此时很多同学可能会联想到 SPA 应用的路由，在 Vue 或者 React 框架中，路由可以分为 hash 模式或者 history 模式，hash 模式本质使用 ",(0,r.jsx)(e.code,{children:"window.location.hash"})," 进行处理，而 history 模式本质使用 ",(0,r.jsx)(e.code,{children:"history.pushState"})," 或者 ",(0,r.jsx)(e.code,{children:"history.replaceState"})," 进行处理。如果使用路由模式在空白的 iframe 中运行，会使得框架出错。为了验证该观点，大家可以将 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/sandbox-micro-app-test",target:"_blank",rel:"noopener noreferrer",children:"demo/sandbox-micro-app-test"})," 中的 Vue 路由示例（构建浏览器中运行的 UMD 规范）放入空白的 iframe 中运行，此时不管是 hash 模式或者 history 模式，底层都会因为调用 ",(0,r.jsx)(e.code,{children:"history"})," 而产生异常。"]}),"\n",(0,r.jsxs)(e.h2,{id:"阶段二同源-iframe-隔离",children:["阶段二：同源 iframe 隔离",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#阶段二同源-iframe-隔离",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["使用 ",(0,r.jsx)(e.code,{children:"about:blank"})," 会导致 ",(0,r.jsx)(e.code,{children:"history"})," 无法正常工作，因此可以在空白页的基础上进行改造，例如在主应用的服务中提供一个空白的 HTML 页面，可用于 iframe 的请求加载，从而保持和主应用完全同域。具体方案如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"大致实现的思路如下所示："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"通过请求获取后端的微应用列表数据，动态创建主导航"}),"\n",(0,r.jsx)(e.li,{children:"根据导航切换微应用，切换时会跨域请求微应用 JS 的文本内容并进行缓存处理"}),"\n",(0,r.jsx)(e.li,{children:"切换微应用的同时创建一个同域的 iframe 应用，请求主应用下空白的 HTML 进行渲染"}),"\n",(0,r.jsx)(e.li,{children:"DOM 渲染完成后，微应用的 JS 会在 iframe 环境中通过 Script 标签进行隔离执行"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"实现效果如下所示，图中的两个按钮（微应用导航）根据后端数据动态渲染，点击按钮后会跨域请求微应用的 JS 静态资源并创建同域的 iframe 进行隔离执行："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"文件的结构目录如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"├── public                  # 托管的静态资源目录\n│   ├── main/               # 主应用资源目录      \n│   │   ├── blank.html      # 用于 iframe 应用进行空白页渲染                          \n│   │   └── index.html                                        \n│   └── micro/              # 微应用资源目录\n│        ├── micro1.js        \n│        └── micro2.js      \n├── config.js               # 公共配置\n├── main-server.js          # 主应用服务\n└── micro-server.js         # 微应用服务\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/iframe-sandbox",target:"_blank",rel:"noopener noreferrer",children:"demo/iframe-sandbox"})," 分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["相对于空白页隔离，iframe 同源隔离需要在主应用中提供一个空白的 HTML 页面，从而可以使 iframe 和主应用完全同域，具体的改动主要是 ",(0,r.jsx)(e.code,{children:"MicroAppSandbox"})," 类："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'  // 隔离类\n  class MicroAppSandbox {\n    // 配置信息\n    options = null;\n    // iframe 实例\n    iframe = null;\n    // iframe 的 Window 实例\n    iframeWindow = null;\n    // 是否执行过 JS\n    exec = false;\n    // iframe 加载延迟执行标识\n    iframeLoadDeferred = null;\n\n    constructor(options) {\n      this.options = options;\n      // 创建 iframe 时浏览器会创建新的全局执行上下文，用于隔离主应用的全局执行上下文\n      this.iframe = this.createIframe();\n      this.iframeWindow = this.iframe.contentWindow;\n      this.iframeLoadDeferred = this.deferred();\n      this.iframeWindow.onload = () => {\n        // 用于等待 iframe 加载完成\n        this.iframeLoadDeferred.resolve();\n      };\n    }\n\n    deferred() {\n      const deferred = Object.create({});\n      deferred.promise = new Promise((resolve, reject) => {\n        deferred.resolve = resolve;\n        deferred.reject = reject;\n      });\n      return deferred;\n    }\n\n    createIframe() {\n      const { rootElm, id, url } = this.options;\n      const iframe = window.document.createElement("iframe");\n      const attrs = {\n        // 请求主应用服务下的 blank.html（保持和主应用同源）\n        src: "blank.html",\n        "app-id": id,\n        "app-src": url,\n        style: "border:none;width:100%;height:100%;",\n      };\n      Object.keys(attrs).forEach((name) => {\n        iframe.setAttribute(name, attrs[name]);\n      });\n      rootElm?.appendChild(iframe);\n      return iframe;\n    }\n\n    // 激活\n    async active() {\n      this.iframe.style.display = "block";\n      // 如果已经通过 Script 加载并执行过 JS，则无需重新加载处理\n      if (this.exec) return;\n      // 延迟等待 iframe 加载完成（这里会有 HTML 请求的性能损耗，可以进行优化处理）\n      await this.iframeLoadDeferred.promise;\n      this.exec = true;\n      const scriptElement =\n        this.iframeWindow.document.createElement("script");\n      scriptElement.textContent = this.options.scriptText;\n      this.iframeWindow.document.head.appendChild(scriptElement);\n    }\n\n    // 失活\n    // INFO: JS 加载以后无法通过移除 Script 标签去除执行状态\n    // INFO: 因此这里不是指代失活 JS，如果是真正想要失活 JS，需要销毁 iframe 后重新加载 Script\n    inactive() {\n      this.iframe.style.display = "none";\n    }\n\n    // 销毁\n    destroy() {\n      this.options = null;\n      this.exec = false;\n      if (this.iframe) {\n        this.iframe.parentNode?.removeChild(this.iframe);\n      }\n      this.iframe = null;\n      this.iframeWindow = null;\n    }\n  }\n'})}),"\n",(0,r.jsxs)(e.p,{children:["此时由于和主应用完全同源，在微应用的 Vue 或者 React 中使用路由调用 ",(0,r.jsx)(e.code,{children:"history"})," 不会存在异常问题，并且浏览器的前进和后退按钮都可以正常工作："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"至此 iframe 隔离的基本功能已经完成，需要注意该隔离示例只是用于理解隔离的简单示例，真正在生产环境使用时，还需要考虑如下设计："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"主应用刷新时， iframe 微应用无法保持自身 URL 的状态"}),"\n",(0,r.jsx)(e.li,{children:"主应用和 iframe 微应用处于不同的浏览上下文，无法使 iframe 中的模态框 Modal 相对于主应用居中"}),"\n",(0,r.jsx)(e.li,{children:"主子应用的通信处理以及持久化数据的隔离处理"}),"\n",(0,r.jsx)(e.li,{children:"解决主应用空白 HTML 请求的性能优化处理（例如 GET 请求空内容、请求渲染时中断请求等）"}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：关于模态框居中的问题，如果主应用本身只是一层壳子，只包含了应用顶部和左侧菜单信息，微应用渲染的区域占据了主要的空间，那么模态框居中的问题可以被忽略。当然，如果要使的微应用中的模态框完全居中，可以在微应用中对模态框的位置进行调整，从而适配成相对于主应用进行居中展示。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"需要注意，采用 iframe 隔离和之前讲解的 iframe 方案是有差异的，具体优势在于："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"可以持续优化白屏体验"}),"\n",(0,r.jsx)(e.li,{children:"可以实现 URL 状态同步"}),"\n",(0,r.jsx)(e.li,{children:"可以额外处理浏览上下文隔离"}),"\n",(0,r.jsx)(e.li,{children:"同域带来的便利性（应用免登、数据共享、通信等）"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"感兴趣的同学可以在隔离示例的基础上进行设计，上述未完成的设计可以根据业务的需求进行不同方案的设计考虑。以模态框无法居中的情况为例，可以在已有模态框组件的基础上进行再次封装，从而使其可以适配隔离方案相对于主应用居中。当然如果想要真正实现天然居中，也可以考虑在 iframe 外进行 DOM 渲染（感兴趣的同学可以思考一下大致的实现思路），从而保持和主应用完全一致的 DOM 环境，当然此种方案还需要额外考虑 CSS 的隔离问题，如果不是为了实现非常通用的微前端框架，个人觉得会有一些得不偿失的感觉。"}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本课程主要讲解了如何利用 iframe 进行 JS 隔离，当然这种隔离也适合 CSS 的隔离，本质上是在 iframe 中创建了和主应用不同的浏览上下文。在下一个课程中我们将在 iframe 隔离（",(0,r.jsx)(e.code,{children:"src=about:blank"}),"）的基础上解决 ",(0,r.jsx)(e.code,{children:"history"})," 报错的问题。"]})]})}function p(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(h,{...n})}):h(n)}let m=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F12.%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%9Aiframe%20%E9%9A%94%E7%A6%BB.md"]={toc:[{text:"隔离思路",id:"隔离思路",depth:2},{text:"阶段一：空白页隔离",id:"阶段一空白页隔离",depth:2},{text:"阶段二：同源 iframe 隔离",id:"阶段二同源-iframe-隔离",depth:2},{text:"小结",id:"小结",depth:2}],title:"12.原理解析：iframe 隔离",headingTitle:"12.原理解析：iframe 隔离",frontmatter:{}}}}]);