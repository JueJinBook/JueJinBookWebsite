"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["38127"],{778443:function(e,n,a){a.r(n),a.d(n,{default:()=>j});var t=a(552676),r=a(740453);let l=a.p+"static/image/db09169e16dbfb83194b4eb5bb4901e6.aa46ef53.png",c=a.p+"static/image/81c2cf1a059d07c967f1e5a25b285384.efc8ed2e.png",o=a.p+"static/image/9fd6c45e87fb4fe61cb89cdf31c01f2d.d6c5da83.png",i=a.p+"static/image/7218dc094c68b74a8e17fae41913cb9b.09e71b30.png",s=a.p+"static/image/4aa0ab7dba285a2b4ac232944766fe08.d823db79.png",d=a.p+"static/image/6c1fb0ad2803ae21b49bb0f836d19060.5ce203f0.png",h=a.p+"static/image/b3b21e15813f076e87434495577fdddb.e6c7a2a6.png",p=a.p+"static/image/dd89eb2f9225dc1827e47ce6ee14e8f4.4d54e34e.png",x=a.p+"static/image/048b6f53f82d4b1b7ee3bb4515f92d64.e734cda9.png";function m(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",img:"img",blockquote:"blockquote",code:"code",pre:"pre",h3:"h3",ul:"ul",li:"li",h4:"h4"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"51原理进阶v8-的概念说明",children:["51.原理进阶：V8 的概念说明",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51原理进阶v8-的概念说明",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["V8 是高性能的 JavaScript 引擎，它不仅可以在 Chrome 和 Node.js 中使用，也可以在其它 C++ 应用中嵌入使用，因此可以使 JavaScript 能运行在一些嵌入式设备以及移动设备中。在",(0,t.jsx)(n.strong,{children:"原理进阶：V8 的嵌入实践"}),"中只讲解了如何将 V8 源代码编译成静态库以及如何在 C++ 中嵌入使用，没有详细讲解 V8 运行示例中的重要概念，本节课程主要根据 V8 的 Demo 示例来讲解其中的重要概念。"]}),"\n",(0,t.jsxs)(n.h2,{id:"javascript-引擎",children:["JavaScript 引擎",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-引擎",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"Web 前端经常会接触浏览器中的 H5 应用开发、 PC 桌面端和移动设备中的 H5 和小程序应用开发，在开发这些应用的背后，需要 JavaScript 引擎和视图渲染引擎的支持，如下所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["在 Chrome 以及 Chromium 中通过嵌入 V8 的方式来运行 JavaScript，在 iOS 以及 Andriod 的 WebView 中也是通过嵌入 JavaScript 引擎的方式来运行 JavaScript，只是两者嵌入的引擎不同，在 iOS 中是 ",(0,t.jsx)(n.a,{href:"https://developer.apple.com/documentation/javascriptcore",target:"_blank",rel:"noopener noreferrer",children:"JavaScriptCore"})," ，而在 Andriod 中则是 V8。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"温馨提示：Andriod 和 iOS 中嵌入的 WebView 存在差异，例如 Andriod 中是 WebView，而 iOS 中则是 WKWebView。这里不会介绍和解释 WebView 的框架设计，可以暂时将它们理解为简单的浏览器。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"除此之外，小程序在视图线程对应的 WebView 之外单独嵌入了一个 JavaScript 引擎。Chrome 浏览器中 Web 应用的 JavaScript 执行和视图渲染在同一个 Renderer 进程的同一个线程中，因此两者的执行是互斥的，一个时刻只能执行一项任务，而小程序为了提升页面的渲染性能，视图渲染和 JavaScript 执行是在两个不同的线程中，它们之间的信息同步需要借助移动设备 APP 所在的 Native 应用进行通信。"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"温馨提示：可以自行查阅 JavaScript 运行和视图渲染在不同线程中执行的优点和缺点。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["V8 是一款高性能的 JavaScript 引擎，除此之外，也存在一些其它 JavaScript 引擎，例如 ",(0,t.jsx)(n.a,{href:"https://github.com/bellard/quickjs",target:"_blank",rel:"noopener noreferrer",children:"QuickJs"}),"，以下是在 QuickJs 的性能测试文档中给出的引擎对比表格："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["温馨提示：",(0,t.jsx)(n.code,{children:"Total score"}),"的值越高说明引擎的表现越好，从表中可以发现具备 JIT 功能的 V8 性能表现非常突出，V8 的体积则相对于 QuickJS 大很多，在一些资源相对紧张的嵌入式设备中，使用 QuickJS 是一个不错的选择。表格来源于 ",(0,t.jsx)(n.a,{href:"https://bellard.org/quickjs/bench.html",target:"_blank",rel:"noopener noreferrer",children:"QuickJS Benchmark"}),"。"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"接下来以 V8 的官方示例来重点说明 V8 的一些概念。"}),"\n",(0,t.jsxs)(n.h2,{id:"v8-的概念说明",children:["V8 的概念说明",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v8-的概念说明",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在",(0,t.jsx)(n.strong,{children:"原理进阶：V8 的嵌入实践"}),"中，我们主要编译和执行了官方的 ",(0,t.jsx)(n.a,{href:"https://github.com/v8/v8/blob/10.2.154.4/samples/hello-world.cc",target:"_blank",rel:"noopener noreferrer",children:"Hello World Example"})," 示例："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c++",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include "libplatform/libplatform.h"\n#include "v8.h"\n\nint main(int argc, char* argv[]) {\n  // V8 初始化\n  v8::V8::InitializeICUDefaultLocation(argv[0]);\n  v8::V8::InitializeExternalStartupData(argv[0]);\n  std::unique_ptr<v8::Platform> platform = v8::platform::NewDefaultPlatform();\n  v8::V8::InitializePlatform(platform.get());\n  v8::V8::Initialize();\n\n  // 创建 V8 隔离实例需要的参数\n  v8::Isolate::CreateParams create_params;\n  create_params.array_buffer_allocator =\n      v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n\n  // V8 隔离实例，通常情况下一个线程对应一个隔离实例\n  v8::Isolate* isolate = v8::Isolate::New(create_params);\n  {\n\n\n    v8::Isolate::Scope isolate_scope(isolate);\n\n    // 分配一个栈空间用于存储 HandleScope\n    // HandleScope 在使用的时候必须绑定一个 Isolate，因为 Isolate 管理内存相关信息\n    v8::HandleScope handle_scope(isolate);\n\n    // 接下来所有的 Local Handle 都归当前的 HandleScope 管理\n    // .............................................\n\n    // Local<SomeType> 用于表明是一个 Local Handle\n    // 在 HandleScope 开辟的栈中放入一个 Local Handle，指向 v8 的 context\n    // 在 V8 的隔离实例中创建一个新的上下文\n    v8::Local<v8::Context> context = v8::Context::New(isolate);\n\n    // 进入 context 上下文\n    v8::Context::Scope context_scope(context);\n\n    {\n      // 在 HandleScope 开辟的栈中放入一个 Local Handle，指向 v8 的 source \n      v8::Local<v8::String> source =\n          v8::String::NewFromUtf8Literal(isolate, "\'Hello\' + \', World!\'");\n\n      // Compile the source code.\n      // 在 HandleScope 开辟的栈中放入一个 Local Handle，指向 v8 的 script    \n      v8::Local<v8::Script> script =\n          v8::Script::Compile(context, source).ToLocalChecked();\n\n      // Run the script to get the result.\n      // 在 HandleScope 开辟的栈中放入一个 Local Handle，指向 v8 的 result    \n      v8::Local<v8::Value> result = script->Run(context).ToLocalChecked();\n\n      // Convert the result to an UTF8 string and print it.\n      v8::String::Utf8Value utf8(isolate, result);\n      printf("%s\\n", *utf8);\n    }\n  }\n\n  // Dispose the isolate and tear down V8.\n  isolate->Dispose();\n  v8::V8::Dispose();\n  v8::V8::DisposePlatform();\n  delete create_params.array_buffer_allocator;\n  return 0;\n\n  // .............................................\n  // C++ 的特性，在 HandleScope 所处的作用域结束时，程序会自动调用它的析构函数，将其内部的所有 Local Handle 释放  \n  // C++ 析构函数：http://c.biancheng.net/view/2224.html \n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"isolate",children:["Isolate",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#isolate",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"Isolate 是隔离的 V8 运行时实例，在 V8 中使用 Isolate 来实现 Web 页面、Web Workder 以及 Chrome 插件中的 JavaScript 运行时环境隔离，如下所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"在 Renderer 进程对应的 Blink 渲染引擎中，主线程有一个 Isolate 用来运行页面中的 JavaScript 代码，而每个 Worker 线程也有各自关联的 Isolate，通常情况下 Isolate 和线程是 1:1 的关系。每需要创建一个隔离的 V8 运行时环境，都需要创建一个 Isolate，例如官方的示例代码："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c++",children:"// V8 隔离实例需要的参数\n v8::Isolate::CreateParams create_params;\n create_params.array_buffer_allocator =\n     v8::ArrayBuffer::Allocator::NewDefaultAllocator();\n\n // V8 隔离实例，通常情况下一个线程对应一个隔离实例\n v8::Isolate* isolate = v8::Isolate::New(create_params);\n"})}),"\n",(0,t.jsx)(n.p,{children:"在浏览器的沙箱和站点隔离中，重点讲解了浏览器页面和 Renderer 进程之间的关联关系，如下所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"如果各个应用的站点各不相同，那么浏览器会分配不同的 Renderer 进程进行站点隔离。 Renderer 进程的主线程中存在对应的 Isolate 用于隔离JavaScript 运行环境，具体如下所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"如果在同一个标签页中的几个页面站点相同，此时浏览器会分配同一个 Renderer 进程进行页面渲染，如下所示："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h3,{id:"handle",children:["Handle",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#handle",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"HandleScope：主要用于管理 JavaScript 对象的生命周期的范围，在 C++ 中会开辟栈空间来存储 Handle，当栈中的 Handle 释放后，会从栈中推出该 Handle。如果释放 HandleScope，则栈中所有的 Handle 都会被释放，因此 Handle Scope 便于管理内部所有 Handle 的自动释放。"}),"\n",(0,t.jsx)(n.li,{children:"Handle：Handle 指向 JavaScript 对象在堆中存储的地址，如果 JavaScript 对象需要被释放，则首先会从 HandleScope 对应的栈中推出相应的 Handle，然后会被垃圾回收器标注，方便后续可以快速通过释放的 Handle 寻找需要被释放的 JavaScript 对象所在的内存地址。"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c++",children:"v8::Isolate::Scope isolate_scope(isolate);\n\n// 分配一个栈空间用于存储 handle scope\n// HandleScope 在使用的时候必须绑定一个 Isolate，因为 Isolate 管理内存相关信息\nv8::HandleScope handle_scope(isolate);\n\n// 接下来所有的 Local Handle 都归该 HandleScope 管理\n// .............................................\n\n// Local<SomeType> 用于表明是一个 Local Handle\n// 在 HandleScope 开辟的栈中放入一个 Local Handle，指向 v8 的 context\nv8::Local<v8::Context> context = v8::Context::New(isolate);\n\n// 在 HandleScope 开辟的栈中放入一个 Local Handle，指向 v8 的 source \nv8::Local<v8::String> source =\n    v8::String::NewFromUtf8(isolate, code).ToLocalChecked();\n\n// 在 HandleScope 开辟的栈中放入一个 Local Handle，指向 v8 的 script  \nv8::Local<v8::Script> script =\n    v8::Script::Compile(context, source).ToLocalChecked();\n\n// 在 HandleScope 开辟的栈中放入一个 Local Handle，指向 v8 的 result  \nv8::Local<v8::Value> result = script->Run(context).ToLocalChecked();\n\n// Dispose the isolate and tear down V8.\nisolate->Dispose();\n\nv8::V8::Dispose();\nv8::V8::DisposePlatform();\n\n// .............................................\n// C++ 的特性，在 HandleScope 所处的作用域结束时，其生命周期也就结束了，这时候程序会自动调用它的析构函数。\n// C++ 析构函数：http://c.biancheng.net/view/2224.html\n// HandleScope 的生命周期结束，其析构函数将被调用，其内部的所有 Local Handle 将被释放\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["温馨提示：感兴趣的同学可以在 v8 源码中查找 ",(0,t.jsx)(n.code,{children:"HandleScope::~HandleScope"}),"析构函数。从 Handle 的介绍可以猜测它和作用域链以及闭包都息息相关，想了解更多关于 Handle 类型以及它和垃圾回收器的关系，可以阅读 ",(0,t.jsx)(n.a,{href:"https://v8.dev/docs/embed#handles-and-garbage-collection",target:"_blank",rel:"noopener noreferrer",children:"Handles and garbage collection"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"context",children:["Context",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#context",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在 Isolate 中讲解了不同站点的页面和 Isolate 的关系是 1:1，而同一个标签页中如果存在多个相同站点的页面，那么页面会共享 Isolate，可能有人会有疑问，既然 Isolate 是同一个，那么页面之间的 ",(0,t.jsx)(n.code,{children:"window"})," 全局对象是如何做到互相隔离？其实 Isolate 是物理空间级别的隔离，而 JavaScript 中的 ",(0,t.jsx)(n.code,{children:"window"})," 对象隔离则是通过 Context 来实现，具体如下所示："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"温馨提示：从上图可以发现 Isolate 和 Context 的关系是 1:N。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["由于 JavaScript 可以通过代码更改内置的 ",(0,t.jsx)(n.code,{children:"window"})," 全局变量（例如通过原型链来更改内置对象的方法），因此不同的应用程序必须隔离 ",(0,t.jsx)(n.code,{children:"window"}),"。Context 可以简单理解为 JavaScript 的全局上下文，通过创建不同的 Context，可以使各个站点应用对应的 JavaScript 隔离彼此的 ",(0,t.jsx)(n.code,{children:"window"})," 全局变量。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["温馨提示：Isolate 在安全上用于物理空间的隔离，可以防止跨站攻击，有自己的堆内存和垃圾回收器等资源，不同的 Isolate 之间的内存和资源相互隔离，它们之间无法共享数据，是非常安全可靠的隔离。而 Context 隔离是指在同一个 Isolate 中，可以创建不同的 Context，这些 Context 有自己的全局变量、函数和对象等，默认情况下不同 Context 对应的 JavaScript 全局上下文无法访问其他全局上下文，但是也可以通过 ",(0,t.jsx)(n.a,{href:"https://v8.dev/docs/embed#security-model",target:"_blank",rel:"noopener noreferrer",children:"Security model "}),"实现安全访问。除此之外，多个 Context 可以共享同一个 Isolate 对应的底层 C++ DOM 对象，并且可以共享 Isolate 的内存和资源，本身的隔离能力相对于 Isolate 更弱，当然两者的应用场景有所差异。"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["例如下述代码，主应用和 iframe 应用有各自的 Context，因此各自的 ",(0,t.jsx)(n.code,{children:"window"})," 对象互不干扰："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'// main.html\n<html><body>\n<iframe src="iframe.html"></iframe>\n<script>\nvar foo = 1234;\nString.prototype.substr =\n    function (position, length) { // Hijacks String.prototype.substr\n        console.log(length);\n        return "hijacked";\n    };\n<\/script>\n</body></html>\n\n// iframe.html\n<script>\nconsole.log(foo);  // undefined\nvar bar = "aaaa".substr(0, 2);  // Nothing is logged.\nconsole.log(bar);  // "aa"\n<\/script>\n'})}),"\n",(0,t.jsxs)(n.h4,{id:"全局执行上下文栈",children:["全局执行上下文栈",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局执行上下文栈",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在 Isolate 中执行 JavaScript，可以通过切换 Context 来实现不同 JavaScript 代码的运行，例如从主应用的 Context 切换到 iframe 应用的 Context："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<-- main.html --\x3e\n<html>\n\n<body>\n    <iframe src=\"iframe.html\"></iframe>\n    <script>\n        // 当前全局上下文为 main.html 对应的 Context\n        var a = 1;\n        var iframe = document.querySelector(\"iframe\");\n        iframe.onload = function () {\n            // 执行 iframe.contentWindow 时在全局上下文栈中 push iframe.html 对应的 Context  \n            // 当前全局上下文为 ifram.html 对应的 Context\n            iframe.contentWindow.func();\n            // 执行后在全局上下文栈中 pop iframe.html 对应的 Context  \n            // 当前全局上下文为 main.html 对应的 Context\n            console.log('main a: ', a); // main a:  1\n        }\n    <\/script>\n</body>\n\n</html>\n\n<-- iframe.html --\x3e\n<script>\n    // 当前全局上下文为 iframe.html 对应的 Context\n    var a = 2;\n    function func() {\n        console.log('iframe a:', a); // iframe a: 2\n    }\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在 ",(0,t.jsx)(n.code,{children:"main.html"})," 中运行的 JavaScript 处于 ",(0,t.jsx)(n.code,{children:"main.html"})," 所在的 Context 环境，而执行 ",(0,t.jsx)(n.code,{children:"iframe.contentWindow.func"})," 时是在 ",(0,t.jsx)(n.code,{children:"iframe.html"})," 所在的 Context 环境："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["在 JavaScript 代码层面感知不到 Context 在全局上下文栈中的切换情况，事实上在执行 ",(0,t.jsx)(n.code,{children:"main.html"})," 中的 JavaScript 代码时你可以简单理解为底层的 C++ 执行了以下操作："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c++",children:"// 在 V8 的隔离实例中创建一个 main.html 对应的上下文（忽略设置 window 变量）\nv8::Local<v8::Context> main = v8::Context::New(isolate);\n// 在 V8 的隔离实例中创建一个 iframe.html 对应的上下文（忽略设置 window 变量）\nv8::Local<v8::Context> iframe = v8::Context::New(isolate);\n\n// 进入 main.html 的 上下文\nv8::Context::Scope context_scope(main);\n\n// 编译和执行 main.html 对应的 script \n// ...\n// 当执行 iframe.contentWindow 时，C++ 中的 V8 会对 contentWindow 属性进行拦截，类似于 Vue 中的数据劫持\n// 拦截属性后进行 Context 切换，切换到 iframe.html 对应的 Context\n// Context 是一个栈式结构的存储方式，此时栈顶是 iframe.html 对应的 Context\n\nv8::Context::Scope context_scope(iframe);\n\n// iframe.contentWindow 执行完毕后，将 iframe.html 对应的 Context 推出栈顶\n// 此时栈顶是 main.html 对应的 Context\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["温馨提示：关于 V8 中 C++ 代码对 JavaScript 属性拦截的操作可以查看 ",(0,t.jsx)(n.a,{href:"https://v8.dev/docs/embed#interceptors",target:"_blank",rel:"noopener noreferrer",children:"Interceptors"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"执行上下文栈",children:["执行上下文栈",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行上下文栈",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在切换 Context 中重点讲解了全局上下文栈的概念，全局上下文栈可以简单理解为用于切换 JavaScript 中的 ",(0,t.jsx)(n.code,{children:"window"})," 变量。除此之外，在当前的 Context 中运行时，会有执行上下文栈的概念，例如在主应用的 Context 中实现调用 ",(0,t.jsx)(n.code,{children:"fun1"}),"，并使用 ",(0,t.jsx)(n.code,{children:"fun1"})," 调用 ",(0,t.jsx)(n.code,{children:"fun2"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// 函数开始执行时，默认的执行上下文栈中只有全局上下文\n\nfunction fun2() {\n    console.log('fun2')\n}\n\nfunction fun1() {\n    // 在上下文栈中 push fun2 函数上下文\n    fun2();\n    // 函数执行完毕，在上下文栈中 pop fun2 函数上下文\n}\n\n// 在上下文栈中 push fun1 函数上下文\nfun1();\n// 函数执行完毕，在上下文栈中 pop  fun1 函数上下文\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在当前 Context 中运行时，JavaScript 的执行上下文主要分为全局上下文、函数上下文以及 ",(0,t.jsx)(n.code,{children:"eval"}),"上下文。JavaScript 的执行通过上下文栈进行控制，当函数被执行时，当前函数对应的上下文会被推入一个上下文栈，当函数执行完毕后，上下文栈会弹出该函数的上下文，并将控制权返回给之前的上下文："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsxs)(n.h2,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"本课程主要讲解了 V8 的一些基础概念，包括 Isolate、Handle Scope、Handle、Context 以及上下文栈。需要重点理解 Renderer 进程的主线程和 Isolate 的关系比例为 1:1，而 Isolate 和 Context 的比例为 1:N，这是 Web 应用可以进行全局执行上下文隔离的主要原因。"})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}let j=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F51.%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%EF%BC%9AV8%20%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AF%B4%E6%98%8E.md"]={toc:[{text:"JavaScript 引擎",id:"javascript-引擎",depth:2},{text:"V8 的概念说明",id:"v8-的概念说明",depth:2},{text:"Isolate",id:"isolate",depth:3},{text:"Handle",id:"handle",depth:3},{text:"Context",id:"context",depth:3},{text:"全局执行上下文栈",id:"全局执行上下文栈",depth:4},{text:"执行上下文栈",id:"执行上下文栈",depth:4},{text:"小结",id:"小结",depth:2}],title:"51.原理进阶：V8 的概念说明",headingTitle:"51.原理进阶：V8 的概念说明",frontmatter:{}}}}]);