"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57737"],{540564:function(n,e,t){n.exports=t.p+"static/image/74aa81a419badfaf34a03e2ebbdba274.faa2e5d4.gif"},745285:function(n,e,t){n.exports=t.p+"static/image/b4b8cd415bd7bcea202c7566c1c20880.e5781a95.webp"},459903:function(n,e,t){n.exports=t.p+"static/image/ed156d131758af0eb7aae541c5c8519e.faeec5b5.gif"},820158:function(n,e,t){t.r(e),t.d(e,{default:()=>j});var a=t(552676),r=t(740453);let b=t.p+"static/image/7d7b53fdd026205be6cd5a98dc32ca58.67d0d783.gif",s=t.p+"static/image/5f2025ee8954cd9630a03fd77dc264ed.fcd6755f.webp",o=t.p+"static/image/08d7cf27bfbbfe6c481e9fcd229ac779.72f9520a.gif";var c=t(745285),i=t(540564),d=t(459903);let l=t.p+"static/image/b13ef28fe031eb39ab49531c06958b92.7de18d86.webp",x=t.p+"static/image/16fb7a636a1c44ab39ec0a45291188a6.8e72c8ac.webp",p=t.p+"static/image/7294644a8a34cffbee65db420b75bbbe.fcc35432.webp";function u(n){let e=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2",ul:"ul",li:"li"},(0,r.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"第46章reactcontext的性能缺点和解决方案",children:["第46章—ReactContext的性能缺点和解决方案",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第46章reactcontext的性能缺点和解决方案",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"\uFEFF上节我们学了 Context 的用法、实现原理，还有它在 antd 里的应用。"}),"\n",(0,a.jsx)(e.p,{children:"在跨层传递数据方面，确实很好用，在组件库里有很多应用。"}),"\n",(0,a.jsx)(e.p,{children:"但是它也有一些缺点。"}),"\n",(0,a.jsx)(e.p,{children:"我们创建个项目来试下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"npx create-vite\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"改下 App.tsx"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'import { FC, PropsWithChildren, createContext, useContext, useState } from "react";\n\ninterface ContextType {\n  aaa: number;\n  bbb: number;\n  setAaa: (aaa: number) => void;\n  setBbb: (bbb: number) => void;\n}\n\nconst context = createContext<ContextType>({\n  aaa: 0,\n  bbb: 0,\n  setAaa: () => {},\n  setBbb: () => {}\n});\n\nconst Provider: FC<PropsWithChildren> = ({ children }) => {\n  const [aaa, setAaa] = useState(0);\n  const [bbb, setBbb] = useState(0);\n\n  return (\n    <context.Provider\n      value={{\n        aaa,\n        bbb,\n        setAaa,\n        setBbb\n      }}\n    >\n      {children}\n    </context.Provider>\n  );\n};\n\nconst App = () => (\n  <Provider>\n    <Aaa />\n    <Bbb />\n  </Provider>\n);\n\nconst Aaa = () => {\n  const { aaa, setAaa } = useContext(context);\n  \n  console.log(\'Aaa render...\')\n\n  return <div>\n    aaa: {aaa}\n    <button onClick={() => setAaa(aaa + 1)}>加一</button>\n  </div>;\n};\n\nconst Bbb = () => {\n  const { bbb, setBbb } = useContext(context);\n  \n  console.log("Bbb render...");\n  \n  return <div>\n    bbb: {bbb}\n    <button onClick={() => setBbb(bbb + 1)}>加一</button>\n  </div>;\n};\n\nexport default App;\n\n'})}),"\n",(0,a.jsx)(e.p,{children:"用 createContext 创建了 context，其中保存了 2 个useState 的 state 和 setState 方法。"}),"\n",(0,a.jsx)(e.p,{children:"用 Provider 向其中设置值，在 Aaa、Bbb 组件里用 useContext 取出来渲染。"}),"\n",(0,a.jsx)(e.p,{children:"去掉 main.tsx 里的 index.css 和 StrictMode："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"把服务跑起来："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"npm install\nnpm run dev\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"浏览器访问下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，修改 aaa 的时候，会同时触发 bbb 组件的渲染，修改 bbb 的时候，也会触发 aaa 组件的渲染。"}),"\n",(0,a.jsx)(e.p,{children:"因为不管修改 aaa 还是 bbb，都是修改 context 的值，会导致所有用到这个 context 的组件重新渲染。"}),"\n",(0,a.jsx)(e.p,{children:"这就是 Context 的问题。"}),"\n",(0,a.jsx)(e.p,{children:"解决方案也很容易想到：拆分成两个 context 不就不会互相影响了？"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'import { FC, PropsWithChildren, createContext, useContext, useState } from "react";\n\ninterface AaaContextType {\n  aaa: number;\n  setAaa: (aaa: number) => void;\n}\n\nconst aaaContext = createContext<AaaContextType>({\n  aaa: 0,\n  setAaa: () => {}\n});\n\ninterface BbbContextType {\n  bbb: number;\n  setBbb: (bbb: number) => void;\n}\n\nconst bbbContext = createContext<BbbContextType>({\n  bbb: 0,\n  setBbb: () => {}\n});\n\nconst AaaProvider: FC<PropsWithChildren> = ({ children }) => {\n  const [aaa, setAaa] = useState(0);\n\n  return (\n    <aaaContext.Provider\n      value={{\n        aaa,\n        setAaa\n      }}\n    >\n      {children}\n    </aaaContext.Provider>\n  );\n};\n\nconst BbbProvider: FC<PropsWithChildren> = ({ children }) => {\n  const [bbb, setBbb] = useState(0);\n\n  return (\n    <bbbContext.Provider\n      value={{\n        bbb,\n        setBbb\n      }}\n    >\n      {children}\n    </bbbContext.Provider>\n  );\n};\n\nconst App = () => (\n  <AaaProvider>\n    <BbbProvider>\n      <Aaa />\n      <Bbb />\n    </BbbProvider>\n  </AaaProvider>\n);\n\nconst Aaa = () => {\n  const { aaa, setAaa } = useContext(aaaContext);\n  \n  console.log(\'Aaa render...\')\n\n  return <div>\n    aaa: {aaa}\n    <button onClick={() => setAaa(aaa + 1)}>加一</button>\n  </div>;\n};\n\nconst Bbb = () => {\n  const { bbb, setBbb } = useContext(bbbContext);\n  \n  console.log("Bbb render...");\n  \n  return <div>\n    bbb: {bbb}\n    <button onClick={() => setBbb(bbb + 1)}>加一</button>\n  </div>;\n};\n\nexport default App;\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这样就好了。"}),"\n",(0,a.jsx)(e.p,{children:"在 antd 里，也是不同的数据放到不同的 context 里："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"但这样也会导致 Provider 嵌套过深："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"<context1.Provider value={}>\n  <context2.Provider value={}>\n    <context3.Provider value={}>\n      <context4.Provider value={}>\n        <context5.Provider value={}>\n          {children}\n        </context5.Provider>\n      </context4.Provider>\n    </context3.Provider>\n  </context2.Provider>\n</context1.Provider>\n"})}),"\n",(0,a.jsx)(e.p,{children:"所以 context 来存放一些配置数据还好，比如 theme、size 等，用来存很多业务数据就不大合适了。"}),"\n",(0,a.jsx)(e.p,{children:"这时候可以用 redux、zustand、jotai 等状态管理库。"}),"\n",(0,a.jsx)(e.p,{children:"它们都不是基于 context 实现的，那自然也没有 context 这种问题。"}),"\n",(0,a.jsx)(e.p,{children:"比如用 zustand："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"npm install --save zustand\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { create } from 'zustand'\n\ntype State = {\n  aaa: number\n  bbb: number\n}\n\ntype Action = {\n  setAaa: (aaa: State['aaa']) => void\n  setBbb: (bbb: State['bbb']) => void\n}\n\nconst useStore = create<State & Action>((set) => ({\n  aaa: 0,\n  bbb: 0,\n  setAaa: (aaa) => set(() => ({ aaa })),\n  setBbb: (bbb) => set(() => ({ bbb })),\n}))\n\n\nconst App = () => (\n  <div>\n    <Aaa />\n    <Bbb />\n  </div>\n);\n\nconst Aaa = () => {\n  const aaa = useStore((state) => state.aaa);\n  const setAaa = useStore(state => state.setAaa);\n  \n  console.log('Aaa render...')\n\n  return <div>\n    aaa: {aaa}\n    <button onClick={() => setAaa(aaa + 1)}>加一</button>\n  </div>;\n};\n\nconst Bbb = () => {\n  const bbb = useStore((state) => state.bbb);\n  const setBbb = useStore(state => state.setBbb);\n  \n  console.log(\"Bbb render...\");\n  \n  return <div>\n    bbb: {bbb}\n    <button onClick={() => setBbb(bbb + 1)}>加一</button>\n  </div>;\n};\n\nexport default App;\n\n"})}),"\n",(0,a.jsx)(e.p,{children:"zustand 虽然也是集中存放的数据，但是内部做了处理，更新某个 state 不会导致依赖其它 state 的组件重新渲染："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"此外，不用状态管理库，不拆分 context，也可以解决，比如用 memo："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:s,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"memo 会对新旧 props 做对比，只有 props 变化了才会渲染。"}),"\n",(0,a.jsx)(e.p,{children:"这样就能避免没必要的渲染。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'import { FC, PropsWithChildren, createContext, memo, useCallback, useContext, useState } from "react";\n\ninterface CounterContext {\n  aaa: number;\n  bbb: number;\n  setAaa: (aaa: number) => void;\n  setBbb: (bbb: number) => void;\n}\n\nconst context = createContext<CounterContext>({\n  aaa: 0,\n  bbb: 0,\n  setAaa: () => {},\n  setBbb: () => {}\n});\n\nconst Provider: FC<PropsWithChildren> = ({ children }) => {\n  const [aaa, setAaa] = useState(0);\n  const [bbb, setBbb] = useState(0);\n\n  return (\n    <context.Provider\n      value={{\n        aaa,\n        bbb,\n        setAaa,\n        setBbb\n      }}\n    >\n      {children}\n    </context.Provider>\n  );\n};\n\nconst App = () => (\n  <Provider>\n    <WrappedAaa />\n    <WrappedBbb />\n  </Provider>\n);\n\nconst WrappedAaa = () => {\n  const { aaa, setAaa } = useContext(context);\n\n  return <Aaa aaa={aaa} setAaa={setAaa}/>\n};\n\ninterface AaaProps {\n  aaa: number;\n  setAaa: (aaa: number) => void\n}\n\nconst Aaa = memo((props: AaaProps) => {\n  const { aaa, setAaa } = props;\n\n  console.log(\'Aaa render...\')\n\n  return <div>\n    aaa: {aaa}\n    <button onClick={() => setAaa(aaa + 1)}>加一</button>\n  </div>\n});\n\nconst WrappedBbb = () => {\n  const { bbb, setBbb } = useContext(context);\n    \n  return <Bbb bbb={bbb} setBbb={setBbb}/>\n};\n\ninterface BbbProps {\n  bbb: number;\n  setBbb: (bbb: number) => void\n}\n\nconst Bbb = memo((props: BbbProps) => {\n  const { bbb, setBbb } = props;\n\n  console.log("Bbb render...");\n\n  return <div>\n    bbb: {bbb}\n    <button onClick={() => setBbb(bbb + 1)}>加一</button>\n  </div>\n})\n\nexport default App;\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这样也能解决 context 会导致额外渲染的问题。"}),"\n",(0,a.jsxs)(e.p,{children:["案例代码上传了",(0,a.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/context-trap",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,a.jsxs)(e.h2,{id:"总结",children:["总结",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"context 在跨层传递数据方面很好用，在组件库里用的很多，但是它也有一些性能方面的缺点。"}),"\n",(0,a.jsx)(e.p,{children:"context 中如果是一个对象，不管任意属性变了，都会导致依赖其它属性的组件跟着重新渲染。"}),"\n",(0,a.jsx)(e.p,{children:"解决这个问题有几种方案："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"拆分 context，每种数据放在一个 context 里"}),"\n",(0,a.jsx)(e.li,{children:"用 zustand 等状态管理库，因为它们不是用 context 实现的，自然没有这种问题"}),"\n",(0,a.jsx)(e.li,{children:"用 memo 包裹子组件，它会对比新旧 props，没变就不会重新渲染"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"context 虽然好用，但是用的时候也要注意下这个性能方面的缺点。"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(u,{...n})}):u(n)}let j=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC46%E7%AB%A0%E2%80%94ReactContext%E7%9A%84%E6%80%A7%E8%83%BD%E7%BC%BA%E7%82%B9%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第46章—ReactContext的性能缺点和解决方案",headingTitle:"第46章—ReactContext的性能缺点和解决方案",frontmatter:{}}}}]);