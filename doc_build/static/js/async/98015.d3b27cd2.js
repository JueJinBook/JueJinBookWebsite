"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["98015"],{530166:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var s=r(552676),d=r(740453);function c(e){let n=Object.assign({h2:"h2",a:"a",p:"p",blockquote:"blockquote",code:"code",pre:"pre",ul:"ul",li:"li",ol:"ol",h3:"h3",strong:"strong",h4:"h4"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["进程间通信（IPC）并非仅限于 Electron，而是源自甚至早于 Unix 诞生的概念。尽管“进程间通信”这个术语的确创造于何时并不清楚，但将数据传递给另一个程序或进程的理念可以追溯至 1964 年，当时 ",(0,s.jsx)(n.a,{href:"https://www.cs.dartmouth.edu/~doug/",target:"_blank",rel:"noopener noreferrer",children:"Douglas McIlroy"})," 在 Unix 的第三版（1973 年）中描述了 Unix 管道的概念。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"We should have some ways of coupling programs like garden hose--screw in another segment when it becomes when it becomes necessary to massage data in another way."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以通过使用管道操作符（",(0,s.jsx)(n.code,{children:"|"}),"）将一个程序的输出传递到另一个程序，比如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 第03章—基础篇：Electron进程间的通信\nls | grep .ts\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 Unix 系统中，管道只是 IPC 的一种形式，还有许多其他形式，比如信号、消息队列、信号量和共享内存。在 Electron 中也有自己的 IPC 形式，接下来我们将会详细介绍。"}),"\n",(0,s.jsxs)(n.h2,{id:"ipcmain-和-ipcrenderer",children:["ipcMain 和 ipcRenderer",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ipcmain-和-ipcrenderer",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"与 Chromium 相同，Electron 使用进程间通信（IPC）来在进程之间进行通信，在介绍 Electron 进程间通信前，我们必须先认识一下 Electron 的 2 个模块。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/ipc-main",target:"_blank",rel:"noopener noreferrer",children:"ipcMain"})," 是一个仅在主进程中以异步方式工作的模块，用于与渲染进程交换消息。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/ipc-renderer",target:"_blank",rel:"noopener noreferrer",children:"ipcRenderer"})," 是一个仅在渲染进程中以异步方式工作的模块，用于与主进程交换消息。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ipcMain"})," 和 ",(0,s.jsx)(n.code,{children:"ipcRenderer"})," 是 Electron 中负责通信的两个主要模块。它们继承自 NodeJS 的 ",(0,s.jsx)(n.a,{href:"https://nodejs.org/api/events.html#events_class_eventemitter",target:"_blank",rel:"noopener noreferrer",children:"EventEmitter"})," 模块。在 ",(0,s.jsx)(n.code,{children:"EventEmitter"})," 中允许我们向指定 ",(0,s.jsx)(n.code,{children:"channel"})," 发送消息。",(0,s.jsx)(n.code,{children:"channel"})," 是一个字符串，在 Electron 中 ",(0,s.jsx)(n.code,{children:"ipcMain"})," 和 ",(0,s.jsx)(n.code,{children:"ipcRenderer"})," 使用它来发出和接收事件/数据。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// 接受消息\n// EventEmitter: ipcMain / ipcRenderer\nEventEmitter.on("string", function callback(event, messsage) {});\n\n// 发送消息\n// EventEmitter: win.webContents / ipcRenderer\nEventEmitter.send("string", "mydata");\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"渲染进程---主进程",children:["渲染进程 -> 主进程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染进程---主进程",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["大多数情况下的通信都是从渲染进程到主进程，渲染进程依赖\xa0",(0,s.jsx)(n.code,{children:"ipcRenderer"}),"\xa0模块给主进程发送消息，官方提供了三个方法："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ipcRenderer.send(channel, ...args)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ipcRenderer.invoke(channel, ...args)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ipcRenderer.sendSync(channel, ...args)"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"channel"}),"\xa0表示的就是事件名(消息名称)，\xa0",(0,s.jsx)(n.code,{children:"args"}),"\xa0是参数。需要注意的是参数将使用结构化克隆算法进行序列化，就像浏览器的 ",(0,s.jsx)(n.code,{children:"window.postMessage"})," 一样，因此不会包含原型链。发送函数、Promise、Symbol、WeakMap 或 WeakSet 将会抛出异常。"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-ipcrenderersend",children:["1. ipcRenderer.send",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-ipcrenderersend",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["渲染进程通过 ",(0,s.jsx)(n.code,{children:"ipcRenderer.send"})," 发送消息："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// render.js\nimport { ipcRenderer } from 'electron';\n\nfunction sendMessageToMain() {\n  ipcRenderer.send('my_channel', 'my_data');\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["主进程通过 ",(0,s.jsx)(n.code,{children:"ipcMain.on"})," 来接收消息："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// main.js\nimport { ipcMain } from 'electron';\n\nipcMain.on('my_channel', (event, message) => {\n  console.log(`receive message from render: ${message}`) \n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["请注意，如果使用 ",(0,s.jsx)(n.code,{children:"send"})," 来发送数据，如果你的主进程需要回复消息，那么需要使用 ",(0,s.jsx)(n.code,{children:"event.replay"})," 来进行回复："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// main.js\nimport { ipcMain } from 'electron';\n\nipcMain.on('my_channel', (event, message) => {\n  console.log(`receive message from render: ${message}`)\n  event.reply('reply', 'main_data')\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"同时，渲染进程需要进行额外的监听："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// renderer.js\nipcRenderer.on('reply', (event, message) => { \n  console.log('replyMessage', message);\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-ipcrendererinvoke",children:["2. ipcRenderer.invoke",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-ipcrendererinvoke",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["渲染进程通过 ",(0,s.jsx)(n.code,{children:"ipcRenderer.invoke"})," 发送消息："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// render.js\nimport { ipcRenderer } from 'electron';\n\nasync function invokeMessageToMain() {\n  const replyMessage = await ipcRenderer.invoke('my_channel', 'my_data');\n  console.log('replyMessage', replyMessage);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["主进程通过 ",(0,s.jsx)(n.code,{children:"ipcMain.handle"})," 来接收消息："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// main.js\nimport { ipcMain } from 'electron';\nipcMain.handle('my_channel', async (event, message) => {\n  console.log(`receive message from render: ${message}`);\n  return 'replay';\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["注意，渲染进程通过 ",(0,s.jsx)(n.code,{children:"ipcRenderer.invoke"})," 发送消息后，",(0,s.jsx)(n.code,{children:"invoke"}),"\xa0的返回值是一个\xa0",(0,s.jsx)(n.code,{children:"Promise<pending>"}),"\xa0。主进程回复消息需要通过 ",(0,s.jsx)(n.code,{children:"return"})," 的方式进行回复，而 ",(0,s.jsx)(n.code,{children:"ipcRenderer"})," 只需要等到 ",(0,s.jsx)(n.code,{children:"Promise resolve"})," 即可获取到返回的值。"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-ipcrendersendsync",children:["3. ipcRender.sendSync",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-ipcrendersendsync",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["渲染进程通过 ",(0,s.jsx)(n.code,{children:"ipcRender.sendSync"})," 来发送消息："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// render.js\nimport { ipcRenderer } from 'electron';\n\nasync function sendSyncMessageToMain() {\n  const replyMessage = await ipcRenderer.sendSync('my_channel', 'my_data');\n  console.log('replyMessage', replyMessage);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["主进程通过 ",(0,s.jsx)(n.code,{children:"ipcMain.on"})," 来接收消息："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// main.js\nimport { ipcMain } from 'electron';\nipcMain.on('my_channel', async (event, message) => {\n  console.log(`receive message from render: ${message}`);\n  event.returnValue = 'replay';\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["注意，渲染进程通过 ",(0,s.jsx)(n.code,{children:"ipcRenderer.sendSync"})," 发送消息后，主进程回复消息需要通过 ",(0,s.jsx)(n.code,{children:"e.returnValue"})," 的方式进行回复，如果\xa0",(0,s.jsx)(n.code,{children:"event.returnValue"}),"\xa0不为\xa0",(0,s.jsx)(n.code,{children:"undefined"}),"\xa0的话，渲染进程会等待\xa0",(0,s.jsx)(n.code,{children:"sendSync"}),"\xa0的返回值才执行后面的代码。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["发送同步消息将阻止整个渲染过程直到收到回复。这样使用此方法只能作为最后手段。使用异步版本更好\xa0",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/ipc-renderer#ipcrendererinvokechannel-args",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"invoke()"})}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-小节",children:["4. 小节",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-小节",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ipcRenderer.send："})," 这个方法是异步的，用于从渲染进程向主进程发送消息。它发送消息后不会等待主进程的响应，而是立即返回，适合在不需要等待主进程响应的情况下发送消息。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ipcRenderer.sendSync："})," 与 ",(0,s.jsx)(n.code,{children:"ipcRenderer.send"})," 不同，这个方法是同步的，也是用于从渲染进程向主进程发送消息，但是它会等待主进程返回响应。它会阻塞当前进程，直到收到主进程的返回值或者超时。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ipcRenderer.invoke："})," 这个方法也是用于从渲染进程向主进程发送消息，但是它是一个异步的方法，可以方便地在渲染进程中等待主进程返回 Promise 结果。相对于 ",(0,s.jsx)(n.code,{children:"send"})," 和 ",(0,s.jsx)(n.code,{children:"sendSync"}),"，它更适合处理异步操作，例如主进程返回 Promise 的情况。"]}),"\n",(0,s.jsxs)(n.h2,{id:"主进程---渲染进程",children:["主进程 -> 渲染进程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主进程---渲染进程",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["主进程向渲染进程发送消息一种方式是当渲染进程通过 ",(0,s.jsx)(n.code,{children:"ipcRenderer.send、ipcRenderer.sendSync、ipcRenderer.invoke"})," 向主进程发送消息时，主进程通过 ",(0,s.jsx)(n.code,{children:"event.replay"}),"、",(0,s.jsx)(n.code,{children:"event.returnValue"}),"、",(0,s.jsx)(n.code,{children:"return ..."})," 的方式进行发送。这种方式是被动的，需要等待渲染进程先建立消息推送机制，主进程才能进行回复。"]}),"\n",(0,s.jsxs)(n.p,{children:["其实除了上面说的几种被动接收消息的模式进行推送外，还可以通过 ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"webContents"})})," 模块进行消息通信。"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-ipcmain-和-webcontents",children:["1. ipcMain 和 webContents",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-ipcmain-和-webcontents",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["主进程使用 ipcMain 模块来监听来自渲染进程的事件，通过 ",(0,s.jsx)(n.code,{children:"event.sender.send()"})," 方法向渲染进程发送消息。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 主进程\nimport { ipcMain, BrowserWindow } from 'electron';\n\nipcMain.on('messageFromMain', (event, arg) => {\n  event.sender.send('messageToRenderer', 'Hello from Main!');\n});\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-browserwindowwebcontentssend",children:["2. BrowserWindow.webContents.send",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-browserwindowwebcontentssend",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BrowserWindow.webContents.send"})," 可以在主进程中直接使用 ",(0,s.jsx)(n.code,{children:"BrowserWindow"})," 对象的 ",(0,s.jsx)(n.code,{children:"webContents.send()"})," 方法向渲染进程发送消息。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 主进程\nimport { BrowserWindow } from 'electron';\n\nconst mainWindow = new BrowserWindow();\nmainWindow.loadFile('index.html');\n\n// 在某个事件或条件下发送消息\nmainWindow.webContents.send('messageToRenderer', 'Hello from Main!');\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-小节",children:["3. 小节",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-小节",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["不管是通过 ",(0,s.jsx)(n.code,{children:"event.sender.send()"})," 还是 ",(0,s.jsx)(n.code,{children:"BrowserWindow.webContents.send"})," 的方式，如果你只是单窗口的数据通信，那么本质上是没什么差异的。"]}),"\n",(0,s.jsxs)(n.p,{children:["但是如果你想要发送一些数据到特定的窗口，那么你可以直接使用 ",(0,s.jsx)(n.code,{children:"BrowserWindow.webContents.send"})," 这种方式。"]}),"\n",(0,s.jsxs)(n.h2,{id:"渲染进程---渲染进程",children:["渲染进程 -> 渲染进程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染进程---渲染进程",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"默认情况下，渲染进程和渲染进程之间是无法直接进行通信的："}),"\n",(0,s.jsx)(n.p,{children:"既然说的是无法直接通信，那么肯定还有一些“曲线救国”的方式。"}),"\n",(0,s.jsxs)(n.h3,{id:"1-利用主进程作为中间人",children:["1. 利用主进程作为中间人",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-利用主进程作为中间人",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"首先，需要在主进程注册一个事件监听程序，监听来自渲染进程的事件："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// main.js\n\n// window 1\nfunction createWindow1 () {\n  window1 = new BrowserWindow({width: 800,height: 600})\n  window1.loadURL('window1.html')\n  window1.on('closed', function () {\n     window1 = null\n  })\n  return window1\n}\n\n// window 2\nfunction createWindow2 () {\n  window2 = new BrowserWindow({width: 800, height: 600})\n  window2.loadURL('window2.html')\n  window2.on('closed', function () {\n    window2 = null\n  })\n  return window2\n}\n\napp.on('ready', () => {\n  createWindow1();\n  createWindow2();\n  ipcMain.on('win1-msg', (event, arg) => {\n    // 这条消息来自 window 1\n    console.log(\"name inside main process is: \", arg); \n    // 发送给 window 2 的消息.\n    window2.webContents.send( 'forWin2', arg );\n  });\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后在 ",(0,s.jsx)(n.code,{children:"window2"})," 窗口建立一个监听事件："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"ipcRenderer.on('forWin2', function (event, arg){\n  console.log(arg);\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这样，",(0,s.jsx)(n.code,{children:"window1"})," 发送的 ",(0,s.jsx)(n.code,{children:"win1-msg"})," 事件，就可以传输到 ",(0,s.jsx)(n.code,{children:"window2"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"ipcRenderer.send('win1-msg', 'msg from win1');\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-使用-messageport",children:["2. 使用 MessagePort",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-使用-messageport",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上面的传输方式虽然可以实现渲染进程之间的通信，但是非常依赖主进程，写起来也比较麻烦，那有什么不依赖于主进程的方式嘛？那当然也是有的，那就是 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/MessagePort",target:"_blank",rel:"noopener noreferrer",children:"MessagePort"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"MessagePort"})," 并不是 Electron 提供的能力，而是基于 MDN 的 Web 标准 API，这意味着它可以在渲染进程直接创建。同时 Electron 提供了 node.js 侧的实现，所以它也能在主进程创建。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来，我们将通过一个示例来描述如何通过 ",(0,s.jsx)(n.code,{children:"MessagePort"})," 来实现渲染进程之间的通信。"]}),"\n",(0,s.jsxs)(n.h4,{id:"21-主进程中创建-messageport",children:["2.1 主进程中创建 ",(0,s.jsx)(n.code,{children:"MessagePort"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-主进程中创建-messageport",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { BrowserWindow, app, MessageChannelMain } from 'electron';\n\napp.whenReady().then(async () => {\n  // 创建窗口\n  const mainWindow = new BrowserWindow({\n    show: false,\n    webPreferences: {\n      contextIsolation: false,\n      preload: 'preloadMain.js'\n    }\n  })\n\n  const secondaryWindow = new BrowserWindow({\n    show: false,\n    webPreferences: {\n      contextIsolation: false,\n      preload: 'preloadSecondary.js'\n    }\n  })\n\n  // 建立通道\n  const { port1, port2 } = new MessageChannelMain()\n\n  // webContents准备就绪后，使用postMessage向每个webContents发送一个端口。\n  mainWindow.once('ready-to-show', () => {\n    mainWindow.webContents.postMessage('port', null, [port1])\n  })\n\n  secondaryWindow.once('ready-to-show', () => {\n    secondaryWindow.webContents.postMessage('port', null, [port2])\n  })\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["实例化\xa0",(0,s.jsx)(n.code,{children:"MessageChannel"}),"\xa0类之后，就产生了两个\xa0",(0,s.jsx)(n.code,{children:"port"}),"：\xa0",(0,s.jsx)(n.code,{children:"port1 和 port2"}),"。接下来只要让 ",(0,s.jsx)(n.code,{children:"渲染进程1"})," 拿到 ",(0,s.jsx)(n.code,{children:"port1"}),"、",(0,s.jsx)(n.code,{children:"渲染进程2"})," 拿到 ",(0,s.jsx)(n.code,{children:"port2"}),"，那么现在这两个进程就可以通过\xa0",(0,s.jsx)(n.code,{children:"port.onmessage"}),"\xa0和\xa0",(0,s.jsx)(n.code,{children:"port.postMessage"}),"\xa0来收发彼此间的消息了。如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// mainWindow\nport1.onmessage = (event) => {\n  console.log('received result:', event.data)\n};\nport1.postMessage('我是渲染进程一发送的消息');\n\n// secondaryWindow\nport2.onmessage = (event) => {\n  console.log('received result:', event.data)\n};\nport2.postMessage('我是渲染进程二发送的消息');\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"22-渲染进程中获取-port",children:["2.2 渲染进程中获取 port",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-渲染进程中获取-port",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["有了上面的知识，我们最重要的任务就是需要获取主进程中创建的 ",(0,s.jsx)(n.code,{children:"port"})," 对象，要做的是在你的预加载脚本（preload.js）中通过 IPC 接收 ",(0,s.jsx)(n.code,{children:"port"}),"，并设置相应的监听器。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// preloadMain.js\n// preloadSecondary.js\nconst { ipcRenderer } = require('electron')\n\nipcRenderer.on('port', e => {\n  // 接收到端口，使其全局可用。\n  window.electronMessagePort = e.ports[0]\n\n  window.electronMessagePort.onmessage = messageEvent => {\n    // 处理消息\n  }\n})\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"23-消息通信",children:["2.3 消息通信",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-消息通信",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["通过上面的一些操作后，就可以在应用程序的任何地方调用 ",(0,s.jsx)(n.code,{children:"postMessage"}),"\xa0方法向另一个渲染进程发送消息。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// mainWindow renderer.js\n// 在 renderer 的任何地方都可以调用 postMessage 向另一个进程发送消息\nwindow.electronMessagePort.postMessage('ping')\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本小节，我们从 IPC 的历史开始逐步介绍了 Electron IPC 的基本概念，以及 Electron IPC 如何完成通信。希望能让你对 Electron IPC 通信的知识有更深刻的理解。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["本小节的渲染进程和渲染进程通信其实还有另一种方式，那就是 ",(0,s.jsx)(n.code,{children:"ipcRenderer.sendTo"}),"，不过在 ",(0,s.jsx)(n.code,{children:"Electron"})," 最新的版本中已经被废弃了，所以没有做介绍，有兴趣了解这块的，可以参考阅读这篇文章：",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/7078476722223448095",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/7078476722223448095"})," 。"]}),"\n"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC03%E7%AB%A0%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9AElectron%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"ipcMain 和 ipcRenderer",id:"ipcmain-和-ipcrenderer",depth:2},{text:"渲染进程 -> 主进程",id:"渲染进程---主进程",depth:2},{text:"1. ipcRenderer.send",id:"1-ipcrenderersend",depth:3},{text:"2. ipcRenderer.invoke",id:"2-ipcrendererinvoke",depth:3},{text:"3. ipcRender.sendSync",id:"3-ipcrendersendsync",depth:3},{text:"4. 小节",id:"4-小节",depth:3},{text:"主进程 -> 渲染进程",id:"主进程---渲染进程",depth:2},{text:"1. ipcMain 和 webContents",id:"1-ipcmain-和-webcontents",depth:3},{text:"2. BrowserWindow.webContents.send",id:"2-browserwindowwebcontentssend",depth:3},{text:"3. 小节",id:"3-小节",depth:3},{text:"渲染进程 -> 渲染进程",id:"渲染进程---渲染进程",depth:2},{text:"1. 利用主进程作为中间人",id:"1-利用主进程作为中间人",depth:3},{text:"2. 使用 MessagePort",id:"2-使用-messageport",depth:3},{text:"2.1 主进程中创建 `MessagePort`",id:"21-主进程中创建-messageport",depth:4},{text:"2.2 渲染进程中获取 port",id:"22-渲染进程中获取-port",depth:4},{text:"2.3 消息通信",id:"23-消息通信",depth:4},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);