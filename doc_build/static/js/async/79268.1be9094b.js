"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["79268"],{915543:function(e,n,t){e.exports=t.p+"static/image/3749b06fc0d0297d1b301eb9c9786ac7.a9c7ec20.webp"},200089:function(e,n,t){t.r(n),t.d(n,{default:()=>j});var s=t(552676),r=t(740453);let a=t.p+"static/image/181866b661cd175562e6d248228622a0.24e2770f.webp",i=t.p+"static/image/10583a60e998e00608b6853e8fa351d6.7ce46838.webp",d=t.p+"static/image/61511ad2df88643304818fe1a6309736.51edc130.webp",o=t.p+"static/image/bbf7cbab14ee4d37c7db115e9f458191.53b9cfb5.webp",l=t.p+"static/image/7cb9ded5b5071a2964c17cb99c36759f.073e9922.webp";var c=t(915543);let h=t.p+"static/image/81998c30b1ba233207c7e81b03fa3468.1183d3a7.webp",p=t.p+"static/image/96785570497eda8b05d6861df444c60a.719ec181.webp",m=t.p+"static/image/47fef747045e5d47a06f020278562191.5bd9db19.webp",g=t.p+"static/image/7434ac3e94214627a4fc2a414a7f9144.12f4fe6c.webp";function u(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",code:"code",pre:"pre",h3:"h3",img:"img",ul:"ul",li:"li",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"17业务篇-简历数据存档且自定义存储路径多窗口",children:["17.业务篇-简历数据存档且自定义存储路径（多窗口）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17业务篇-简历数据存档且自定义存储路径多窗口",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本章节将实现",(0,s.jsx)(n.strong,{children:"多 Webpack 入口、多浏览器窗口"}),"进行实践设置模块，并实现自定义简历数据的本地存档，如果你对本章节内容兴趣不大，可以快速阅读或跳过。"]}),"\n",(0,s.jsxs)(n.h2,{id:"明确定位",children:["明确定位",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#明确定位",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们先来看看这个",(0,s.jsx)(n.code,{children:"自定义存储路径"}),"功能，看起来它更像是一个完整独立的模块，对整个应用来讲，多它如虎添翼，少它也无伤大雅。"]}),"\n",(0,s.jsx)(n.p,{children:"所以我期望：将来对该模块的迁移、改动，甚至删除，是不会影响主流程功能。"}),"\n",(0,s.jsxs)(n.p,{children:["所以将它写成一个独立的模块看起来是个不错的选择，通过对市面上的一些 PC 应用做调研，我发现，应用设置都是",(0,s.jsx)(n.strong,{children:"新开一个窗口"}),"进行展示，这边我也采用此方式进行实现。"]}),"\n",(0,s.jsxs)(n.h2,{id:"核心问题",children:["核心问题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#核心问题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过前边的实践，我们在应用主进程中只创建了一个渲染进程且对应一个浏览器窗口。"}),"\n",(0,s.jsxs)(n.p,{children:["如果你认真看第二章节，想必你还有印象：",(0,s.jsx)(n.strong,{children:"渲染进程的入口是一个 HTML 文件"}),"。多说无益，直接上代码(部分代码省略，只标注关键代码)，看代码的注释"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.dev.js\nconst devConfig = {\n  // \uD83D\uDC49 第一步：我们指定了入口文件，大部分情况下都是单入口文件，这里我们制定 app.tsx\n  entry: {\n    index: path.resolve(__dirname, '../app/renderer/app.tsx'),\n  },\n  // \uD83D\uDC49 第二步：我们指定导出的文件名称和导出的文件路径\n  output: {\n    filename: '[name].[hash].js',\n    path: path.resolve(__dirname, '../dist'),\n  },\n  // \uD83D\uDC49 第三步：我们通过 dev-server 开了一个本地的服务，通过 http://127.0.0.1:7001/index.html 就能访问页面\n  devServer: {\n    host: '127.0.0.1',\n    port: 7001,\n  },\n  // \uD83D\uDC49 第四步：我们指定了自动生成 HTML 的模版，并且声明打包后的模版名称\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, '../app/renderer/index.html'),\n      filename: path.resolve(__dirname, '../dist/index.html'),\n      chunks: ['index'],\n    }),\n  ],\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["通过上述的代码解读，想必大家都能理解这段 Webpack 的配置以及最终的打包结果，最后的我们主进程中，只需要通过 ",(0,s.jsx)(n.code,{children:"loadURL('http://127.0.0.1/index.html')"})," 加载链接即可。"]}),"\n",(0,s.jsxs)(n.p,{children:["问题随之而来，我们期望“应用设置”是一个独立的窗口，也就是再新增一个渲染进程。而渲染进程的入口是一个 HTML 文件，等价于我们在 Webpack 打包时，需要打包一份 ",(0,s.jsx)(n.code,{children:"setting.html"}),"，这样我们新增加的窗口只需要 ",(0,s.jsx)(n.code,{children:"loadURL('http://127.0.0.1/setting.html')"})," 即可。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"所以最核心的问题在于：如何实现 Webpack 的多入口打包。"})}),"\n",(0,s.jsxs)(n.h2,{id:"开始实践",children:["开始实践",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#开始实践",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"由于前期我们不断开发，项目已经有了雏形，此时不宜改动文件目录结构。照目前情况来看，最好的方式莫过于将新窗口的相关代码进行分割。"}),"\n",(0,s.jsxs)(n.h3,{id:"第一步独立文件夹管理",children:["第一步：独立文件夹管理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一步独立文件夹管理",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们在 renderer 文件夹下，新增一个文件夹，取名为：",(0,s.jsx)(n.code,{children:"windowPages"}),"，意味着此文件夹是之后所有新增窗口的模块代码。"]}),"\n",(0,s.jsxs)(n.p,{children:["接着创建一个文件夹，取名为 setting，这是我们应用设置的代码文件夹，在其文件夹下追加 ",(0,s.jsx)(n.code,{children:"app.tsx"}),"、",(0,s.jsx)(n.code,{children:"index.tsx"}),"、",(0,s.jsx)(n.code,{children:"index.less"}),"、",(0,s.jsx)(n.code,{children:"index.html"}),"，通过下图可以看到现在的文件结构"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h3,{id:"第二步编写-setting-相关代码",children:["第二步：编写 setting 相关代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第二步编写-setting-相关代码",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["进入 ",(0,s.jsx)(n.code,{children:"renderer/windowPages/setting"})," 文件夹，我们编写 ",(0,s.jsx)(n.code,{children:"app.tsx"})," 文件"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/windowPages/setting/app.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n// \uD83D\uDC47 引入Redux\nimport { Provider } from 'react-redux';\nimport store from '@src/store';\n// \uD83D\uDC47 应用设置的入口组件\nimport Setting from './index';\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <Setting />\n    </Provider>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById('root'));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["紧接着我们编写一下 ",(0,s.jsx)(n.code,{children:"index.tsx"}),"，简短的写下两行代码"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/windowPages/setting/index.tsx\nimport React from 'react';\n\nfunction Setting() {\n  return <div>应用设置-新窗口</div>;\n}\n\nexport default Setting;\n"})}),"\n",(0,s.jsx)(n.p,{children:"再修改一下我们应用设置的 HTML 入口模版代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// renderer/windowPages/setting/index.html\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>应用设置</title>\n    <style>\n      * {\n        margin: 0;\n      }\n    </style>\n  </head>\n  <body>\n    <div id="root"></div>\n  </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"第三步编写-webpack-配置",children:["第三步：编写 Webpack 配置",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第三步编写-webpack-配置",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们进入 ",(0,s.jsx)(n.code,{children:"webpack/webpack.render.dev.js"})," 文件，为其新增一个打包入口（部分代码省略）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack/webpack.render.dev.js\n\nconst devConfig = {\n  // \uD83D\uDC47 这里定义多 entry\n  entry: {\n    index: path.resolve(__dirname, '../app/renderer/app.tsx'),\n    setting: path.resolve(__dirname, '../app/renderer/windowPages/setting/app.tsx'),\n  },\n  // \uD83D\uDC47 这里定义多个 htmlHtmlPlugin\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, '../app/renderer/index.html'),\n      filename: path.resolve(__dirname, '../dist/index.html'),\n      chunks: ['index'],\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, '../app/renderer/windowPages/setting/index.html'),\n      filename: path.resolve(__dirname, '../dist/setting.html'),\n      chunks: ['setting'],\n    }),\n  ],\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们通过运行 ",(0,s.jsx)(n.code,{children:"npm run start:render"})," 来瞧瞧，是不是会打包一份名为 ",(0,s.jsx)(n.code,{children:"setting.html"})," 文件呢？"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h3,{id:"第四步编写主进程",children:["第四步：编写主进程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第四步编写主进程",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们新增了“应用设置”模块的窗口代码，也在 Webpack 中定义了多入口，并且打包也存在此 HTML 文件，话不多说，新增窗口加载此 HTML 文件吧。"}),"\n",(0,s.jsxs)(n.p,{children:["我们进入 ",(0,s.jsx)(n.code,{children:"app/main/electron.ts"})," 中稍作修改"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/main/electron.ts\n\nfunction createWindow() {\n  // 创建主应用窗口\n  const mainWindow = new BrowserWindow({\n    width: 1200,\n    height: 800,\n    webPreferences: {\n      devTools: true,\n      nodeIntegration: true,\n    },\n  });\n\n  // 创建应用设置窗口\n  const settingWindow = new BrowserWindow({\n    width: 720,\n    height: 240,\n    resizable: false, // \uD83D\uDC48 我们设置该窗口不可拉伸宽高\n    webPreferences: {\n      devTools: true,\n      nodeIntegration: true,\n    },\n  });\n\n  if (isDev()) {\n    mainWindow.loadURL(`http://127.0.0.1:7001/index.html`);\n    settingWindow.loadURL(`http://127.0.0.1:7001/setting.html`);\n  } else {\n    mainWindow.loadURL(`file://${path.join(__dirname, '../dist/index.html')}`);\n    settingWindow.loadURL(`file://${path.join(__dirname, '../dist/setting.html')}`);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"第五步运行",children:["第五步：运行",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第五步运行",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来，通过运行应用，看看是否效果如我们所期望的一样"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run start:render\nnpm run start:main\n"})}),"\n",(0,s.jsxs)(n.p,{children:["最终效果，可以看到会存在两个窗口，并且新增的“应用设置”窗口如我们所期望的一样。可看此 ",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/26926466bfd27184d236a87ed11855a9565c999f",target:"_blank",rel:"noopener noreferrer",children:"\uD83D\uDC49 commit"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"应用设置模块代码实现",children:["应用设置模块代码实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#应用设置模块代码实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过上边实践，我们完成了“应用设置”窗口的创建，接下来我们来实现一下具体功能。先看一下原型稿"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["看起来并不麻烦， 我们先在 ",(0,s.jsx)(n.code,{children:"windowPages/setting/index.tsx"})," 中写下这段代码，样式代码忽略"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/windowPages/setting/index.tsx\n\nimport React, { useState } from 'react';\nimport './index.less';\nimport MyButton from '@common/components/MyButton';\n\nfunction Setting() {\n  const [resumeSavePath, setResumeSavePath] = useState('');\n\n  const onSave = () => {};\n  return (\n    <div styleName=\"container\">\n      <p styleName=\"label\">修改简历数据储存路径</p>\n      <div styleName=\"input\">\n        <div styleName=\"value\">{resumeSavePath || '当前存储路径为：'}</div>\n        <div styleName=\"update-btn\">更改路径</div>\n      </div>\n    </div>\n  );\n}\n\nexport default Setting;\n"})}),"\n",(0,s.jsx)(n.p,{children:"刷新一下页面，可以看到效果"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["静态效果已被我们实现，接下来就是主逻辑：",(0,s.jsx)(n.strong,{children:"进行更换路径"}),"。通过 Electron 提供的 ",(0,s.jsx)(n.a,{href:"https://www.electronjs.org/docs/api/dialog#dialogshowsavedialogsyncbrowserwindow-options",target:"_blank",rel:"noopener noreferrer",children:"dialog"})," 模块，我们可以实现文件的打开和保存，接下来试试."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/windowPages/setting/index.tsx\n\nimport React, { useState } from 'react';\nimport './index.less';\nimport MyButton from '@common/components/MyButton';\n\nfunction Setting() {\n  const [resumeSavePath, setResumeSavePath] = useState('');\n\n  const onChangePath = () => {\n    // 1. 向主进程发送消息，因为 dialog 模块只能在主进程中调用\n    ipcRenderer.send('open-save-resume-path', '');\n    // 2. 监听从主进程发送回来的消息\n    ipcRenderer.on('reply-save-resume-path', (event, arg: string[]) => {\n      if (arg) {\n        if (arg.length > 0) setResumeSavePath(arg[0]);\n      } else {\n        console.log('自定义存储路径失败');\n      }\n    });\n  };\n\n  return (\n    <div styleName=\"container\">\n      <p styleName=\"label\">修改简历数据储存路径</p>\n      <div styleName=\"input\">\n        <div styleName=\"value\">{resumeSavePath || '当前存储路径为：'}</div>\n        <div styleName=\"update-btn\" onClick={onChangePath}>\n          更改路径\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default Setting;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上图所示，我们定义了 ",(0,s.jsx)(n.code,{children:"onChangePath"})," 方法，在该方法中通过 IPC 的方式进行通信。为什么进行通信？因为 ",(0,s.jsx)(n.code,{children:"dialog"})," 模块只能作用于主进程，我们在渲染进程中是无法使用的。那么我们接着去修改一下主进程，添加下面这段代码"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// app/main/electron.ts\n\n// 应用设置，保存自定义存储路径\nipcMain.on('open-save-resume-path', (event, arg) => {\n  dialog\n    .showOpenDialog({\n      properties: ['openDirectory'],\n    })\n    .then((result) => {\n      event.reply('reply-save-resume-path', result.filePaths);\n    })\n    .catch((err) => {\n      event.reply('reply-save-resume-path', err);\n    });\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后重新运行一下应用，此时点击“更改路径”，可以看到如我们预期一致。可看此 ",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/ed8a9b323ffd4c1d0aa27953c29f9598db96e044",target:"_blank",rel:"noopener noreferrer",children:"\uD83D\uDC49 commit"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"实现默认存储路径",children:["实现默认存储路径",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现默认存储路径",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上面我们是实现了“更改路径”的功能，但实际上，应用初次进入时，是默认不存在存储路径的，所以我们需要赋于默认的的存储路径值。接下来我们实现一下此功能点。"}),"\n",(0,s.jsxs)(n.p,{children:["我们在 ",(0,s.jsx)(n.code,{children:"appConfig"})," 文件夹下，新增全局配置项文件，暂且称为 ",(0,s.jsx)(n.code,{children:"global.config.json"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// appConfig/global.config.json\n{\n  "name": "全局配置表",\n  "resumeSavePath": ""\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["先来明确一下，",(0,s.jsx)(n.code,{children:"resumeSavePath"})," 数据在什么时候使用："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"作用于主应用窗口，在导出 PDF 时，以此地址为前提，进行简历数据文件的存储"}),"\n",(0,s.jsx)(n.li,{children:"作用于应用设置窗口，用于存储地址的展示"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"既然两个浏览器窗口都需要此数据（两个渲染进程需要进行通信），那将此数据放在哪个渲染进程管理呢？其实不管放在哪个渲染进程管理，都逃不过主进程做消息中转。"}),"\n",(0,s.jsx)(n.p,{children:"第二章有提到，官方对于渲染进程与渲染进程之间的通信是不提供任何方式的，我们只能通过主进程进行中转，也就是主应用窗口先发一条消息给主进程，然后主进程再发给应用设置窗口，同时应用窗口在“更改路径”之后，也以同样的方式告知主应用窗口。"}),"\n",(0,s.jsxs)(n.p,{children:["下面我简单给大家演示一下代码：(",(0,s.jsx)(n.strong,{children:"演示示例代码，注意看注释"}),")"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 渲染进程：主应用窗口，假设在路由组件\n\nfunction Router() {\n  useEffect(() => {\n    // 1. 读取到默认的存储路径\n    getAppPath().then((path: string) => {\n      const defaultPath = `${path}resumeCache`;\n      // 2. IPC 通信，告知主进程\n      ipcRenderer.send('default-path_from_mainWindow_to_settingWindow', defaultPath);\n    });\n  });\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 主进程\n\nlet currentSettingWindow: BrowserWindow;\n\nfunction createWindow() {\n  // 1. 创建主应用窗口\n  const mainWindow = new BrowserWindow({});\n  // 2. 创建应用程序窗口\n  const settingWindow = new BrowserWindow({});\n  currentSettingWindow = settingWindow;\n}\n\n// 3. 在主应用窗口获取默认路径之后，监听消息\nipcMain.on('default-path_from_mainWindow_to_settingWindow', (event, arg) => {\n  console.log('从主应用窗口过来的默认路径：', arg);\n\n  // 4. 主进程中转消息，同步到应用设置窗口\n  currentSettingWindow.webContents.on('did-finish-load', () => {\n    currentSettingWindow.webContents.send('default-path_from_settingWindow_to_mainWindow', arg);\n  });\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 渲染进程：应用设置窗口\n\nfunction Setting() {\n  useEffect(() => {\n    // 1. 监听事件，获取默认的地址\n    ipcRenderer.on('default-path_from_settingWindow_to_mainWindow', (event, arg: string) => {\n      if (arg) {\n        setResumeSavePath(arg);\n      } else {\n        console.log('自定义存储路径失败');\n      }\n    });\n  }, []);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这只是初始进入应用时读取默认存储路径，接下来我们还有“更改路径”操作，这也是需要进行频繁通信的。所以这种方式固然可以实现，但实际上不合理。我们放弃这种方式，探索一条正确的道路。"}),"\n",(0,s.jsx)(n.p,{children:"我们思考一下，主应用窗口在什么时候用到这个字段数据？在导出 PDF 时；那需要实时数据吗？并不需要，只要保证在导出 PDF 时，该数据是最新的即可。"}),"\n",(0,s.jsxs)(n.p,{children:["最终的解决方案为：",(0,s.jsx)(n.strong,{children:"在应用设置窗口处理所有与存储路径相关的工作，主应用窗口就只需要读取全局配置表文件内容即可。"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"在修改更改存储路径上，也是通过读写操作全局配置表文件进行实现。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["在主应用窗口中，导出 PDF 时，读取文件内容，得到存储地址。这里需要注意：",(0,s.jsx)(n.strong,{children:"如果用户压根就没打开应用设置窗口，进行存储路径的配置，那么需要给定一个默认地址。"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"在应用设置窗口读取默认配置并支持更改路径",children:["在应用设置窗口读取默认配置并支持更改路径",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在应用设置窗口读取默认配置并支持更改路径",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们前往 ",(0,s.jsx)(n.code,{children:"renderer/hooks"})," 文件夹下，新增 ",(0,s.jsx)(n.code,{children:"useGlobalConfigActionHooks.ts .ts"})," 文件，该文件是对全局配置文件的读取的更新"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/hooks/useGlobalConfigActionHooks.ts\n\nimport path from 'path';\nimport fileAction from '@common/utils/file';\nimport { getAppPath } from '@common/utils/appPath';\n\n/**\n * @description 读取全局配置文件的内容\n */\nexport function useReadGlobalConfigFile() {\n  return () => {\n    return new Promise((resolve: (values: { [key: string]: any }) => void, reject: (value: Error) => void) => {\n      getAppPath().then((appPath: string) => {\n        const jsonPath = path.join(appPath, 'appConfig/global.config.json');\n        fileAction\n          .hasFile(jsonPath)\n          .then(async () => {\n            const themeConfigValues = await fileAction.read(jsonPath, 'utf-8');\n            resolve(JSON.parse(themeConfigValues));\n          })\n          .catch(() => {\n            reject(new Error('appConfig does not exist !'));\n          });\n      });\n    });\n  };\n}\n\n/**\n * @description 读取配置文件的内容\n * @param {string} updateKey 键\n * @param {any} updateValues 值\n * @param {function} callback 回调函数\n */\nexport function useUpdateGlobalConfigFile() {\n  const readGlobalConfigFile = useReadGlobalConfigFile();\n  return (updateKey: string, updateValues: any, callback?: () => void) => {\n    getAppPath().then((appPath: string) => {\n      const jsonPath = path.join(appPath, 'appConfig/global.config.json');\n      readGlobalConfigFile().then((values: { [key: string]: any }) => {\n        if (values && !!Object.keys(values).length) {\n          const nextConfigContent = {\n            ...values,\n            [`${updateKey}`]: updateValues,\n          };\n          fileAction.canWrite(jsonPath).then(() => {\n            fileAction.write(jsonPath, nextConfigContent, 'utf-8').then(() => {\n              callback && callback();\n            });\n          });\n        }\n      });\n    });\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["接着我们前往 ",(0,s.jsx)(n.code,{children:"renderer/windowPages/setting/index.tsx"}),"，修改一下我们的文件内容，注意看注释内容（伪代码）"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/windowPages/setting/index.tsx\n\nimport React, { useState, useEffect } from 'react';\nimport './index.less';\nimport { ipcRenderer } from 'electron';\nimport { getAppPath } from '@common/utils/appPath';\nimport { useReadGlobalConfigFile, useUpdateGlobalConfigFile,} from '@src/hooks/useGlobalConfigActionHooks';\n\nfunction Setting() {\n  const [resumeSavePath, setResumeSavePath] = useState('');\n  // \uD83D\uDC47 1. 引入 Hooks，进行读取文件内容和更新内容\n  const readAppConfigThemeFile = useReadGlobalConfigFile();\n  const updateGlobalConfigFile = useUpdateGlobalConfigFile();\n\n  // \uD83D\uDC47 2. 在 didMount 周期时，读取配置文件内容\n  useEffect(() => {\n    readAppConfigThemeFile().then((value: { [key: string]: any }) => {\n      // \uD83D\uDC47 2.1 如果存在默认路径，以此为主\n      if (value?.resumeSavePath) {\n        setResumeSavePath(value?.resumeSavePath);\n      } else {\n        // \uD83D\uDC47 2.2 不存在默认路径，则设置默认路径并更新文件内容\n        getAppPath().then((appPath: string) => {\n          setResumeSavePath(`${appPath}resumeCache`);\n          updateGlobalConfigFile('resumeSavePath', `${appPath}resumeCache`);\n        });\n      }\n    });\n  }, []);\n\n  // \uD83D\uDC47 3. 更改存储路径，发起 IPC 通信\n  const onChangePath = () => {\n    // 3.1 向主进程发送消息，因为 dialog 模块只能在主进程中调用\n    ipcRenderer.send('open-save-resume-path', '');\n    // 3.2 监听从主进程发送回来的消息\n    ipcRenderer.on('reply-save-resume-path', (event, arg: string[]) => {\n      if (arg) {\n        // 3.3 设置最新存储路径，并更新文件内容\n        if (arg.length > 0) {\n          setResumeSavePath(arg[0]);\n          updateGlobalConfigFile('resumeSavePath', arg[0]);\n        }\n      } else {\n        console.log('自定义存储路径失败');\n      }\n    });\n  };\n}\n\nexport default Setting;\n"})}),"\n",(0,s.jsx)(n.p,{children:"接着刷新一下页面，看看是否与我们期望一致？经过验证，是没问题的。接下来就是主应用在导出 PDF 时的工作处理了。"}),"\n",(0,s.jsxs)(n.h2,{id:"在主应用窗口导出时进行存储",children:["在主应用窗口导出时进行存储",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在主应用窗口导出时进行存储",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们实现导出 PDF 时，以 json 文件形式存储我们的简历数据"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["文件格式以 ",(0,s.jsx)(n.code,{children:"年月日_姓名_学校_岗位_${UUID}"})," 命名。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们前往 ",(0,s.jsx)(n.code,{children:"renderer/container/resume/ResumeAction"}),"，修改",(0,s.jsx)(n.code,{children:"index.tsx"})," 中的导出回调函数"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/container/resume/ResumeAction/index.tsx\n\nimport { toPrintPdf } from '@common/utils/htmlToPdf';\nimport fileAction from '@common/utils/file';\nimport { createUID } from '@common/utils';\nimport { intToDateString } from '@common/utils/time';\nimport { getAppPath } from '@common/utils/appPath';\nimport { useReadGlobalConfigFile, useUpdateGlobalConfigFile } from '@src/hooks/useGlobalConfigActionHooks';\n\nfunction ResumeAction() {\n  const [showModal, setShowModal] = useState(false);\n  const base: TSResume.Base = useSelector((state: any) => state.resumeModel.base);\n  const work: TSResume.Work = useSelector((state: any) => state.resumeModel.work);\n  const resume = useSelector((state: any) => state.resumeModel);\n\n  // \uD83D\uDC47 1. 引入 Hooks\n  const readAppConfigThemeFile = useReadGlobalConfigFile();\n  const updateGlobalConfigFile = useUpdateGlobalConfigFile();\n\n  // 导出PDF\n  const exportPdf = () => {\n    toPrintPdf(`${base?.username}+${base?.school}+${work?.job}`);\n    setShowModal(false);\n    readAppConfigThemeFile().then((value: { [key: string]: any }) => {\n      if (value?.resumeSavePath) {\n        saveResumeJson(value?.resumeSavePath);\n      } else {\n        // \uD83D\uDC47 2.2 不存在默认路径，则设置默认路径并更新文件内容\n        getAppPath().then((appPath: string) => {\n          updateGlobalConfigFile('resumeSavePath', `${appPath}resumeCache`);\n          saveResumeJson(`${appPath}resumeCache`);\n        });\n      }\n    });\n  };\n\n  // 存储数据json\n  const saveResumeJson = (resumeSavePath: string) => {\n    const date = intToDateString(new Date().valueOf(), '_');\n    const prefix = `${date}_${base?.username}_${base?.school}_${work?.job}_${createUID()}.json`;\n    // 如果路径中不存在 resumeCache 文件夹，则默认创建此文件夹\n    if (resumeSavePath && resumeSavePath.search('resumeCache') > -1) {\n      fileAction?.write(`${resumeSavePath}/${prefix}`, resume, 'utf8');\n    } else {\n      fileAction\n        ?.mkdirDir(`${resumeSavePath}/resumeCache`)\n        .then((path) => {\n          if (path) fileAction?.write(`${path}/${prefix}`, resume, 'utf8');\n        })\n        .catch(() => {\n          console.log('创建文件夹失败');\n        });\n    }\n  };\n}\n\nexport default ResumeAction;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["不出意外的话，此时的你会报错，原因是找不到 ",(0,s.jsx)(n.code,{children:"fileAction.mkdirDir()"})," 方法，原来在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962906314565484551",target:"_blank",rel:"noopener noreferrer",children:"第七章节"}),"我们封装的 file.ts 文件中未支持 mkdirDir，我们前往 ",(0,s.jsx)(n.code,{children:"@common/utils/file.ts"}),"，添加一下代码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const fileAction = {\n  /**\n   * @description 创建文件夹\n   * @param path 创建 /a/b/c，不管`/a` 和 /a/b 是否存在。\n   * @returns {Promise}\n   */\n  mkdirDir: (path: string): Promise<string | undefined> => {\n    return fsPromiseAPIs.mkdir(path, { recursive: true });\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"接着我们刷新一下页面，看看效果如何。不存意外，会在你选中的文件夹下，存在一个 resumeCache 文件夹"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"最后",children:["最后",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"此章节以带着小伙伴实现 Webpack 入口与创建多个渲染进程及浏览器窗口，通过实现应用设置的存储路径，从而现象简历数据存储的最终效果。"}),"\n",(0,s.jsxs)(n.p,{children:["本章节最为重要的在于主进程处的创建渲染进程，以及进程间通信，当然还有还堵全局配置文件的默认路径赋值与更改路径，章节篇幅有限，小伙伴们一定要结合",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/chapter-17",target:"_blank",rel:"noopener noreferrer",children:"线上代码"}),"进行配套学习。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"如果您在边阅读边实践时，发现代码报错或者 TS 报错，那么小伙伴们可以根据报错信息，去线上看看相应的代码。"})}),"\n",(0,s.jsx)(n.p,{children:"本章节的代码量相对较大，如果对本章节存在疑问，欢迎在评论区留言。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F17.%E4%B8%9A%E5%8A%A1%E7%AF%87-%E7%AE%80%E5%8E%86%E6%95%B0%E6%8D%AE%E5%AD%98%E6%A1%A3%E4%B8%94%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E8%B7%AF%E5%BE%84%EF%BC%88%E5%A4%9A%E7%AA%97%E5%8F%A3%EF%BC%89.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"明确定位",id:"明确定位",depth:2},{text:"核心问题",id:"核心问题",depth:2},{text:"开始实践",id:"开始实践",depth:2},{text:"第一步：独立文件夹管理",id:"第一步独立文件夹管理",depth:3},{text:"第二步：编写 setting 相关代码",id:"第二步编写-setting-相关代码",depth:3},{text:"第三步：编写 Webpack 配置",id:"第三步编写-webpack-配置",depth:3},{text:"第四步：编写主进程",id:"第四步编写主进程",depth:3},{text:"第五步：运行",id:"第五步运行",depth:3},{text:"应用设置模块代码实现",id:"应用设置模块代码实现",depth:2},{text:"实现默认存储路径",id:"实现默认存储路径",depth:2},{text:"在应用设置窗口读取默认配置并支持更改路径",id:"在应用设置窗口读取默认配置并支持更改路径",depth:2},{text:"在主应用窗口导出时进行存储",id:"在主应用窗口导出时进行存储",depth:2},{text:"最后",id:"最后",depth:2}],title:"17.业务篇-简历数据存档且自定义存储路径（多窗口）",headingTitle:"17.业务篇-简历数据存档且自定义存储路径（多窗口）",frontmatter:{}}}}]);