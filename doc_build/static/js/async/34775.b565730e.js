"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["34775"],{998092:function(e,n,t){t.r(n),t.d(n,{default:()=>A});var r=t(552676),s=t(740453);let c=t.p+"static/image/ca62382b77d13d51322aea2c51972678.2a52b0be.webp",d=t.p+"static/image/90f19e69b9a78b26853fc8a3b0cc5a28.653bb9f7.webp",o=t.p+"static/image/3f7fa0e020504fa817410ce852a1925d.5e4503be.webp",i=t.p+"static/image/3b98de6d6ef650e5ce77b3c6b2688cbe.10f22367.webp",a=t.p+"static/image/178040b8c6f6331dec4fc2f5f3d95b58.63b96182.webp",l=t.p+"static/image/ea5640e76d814553f929cfea29b6236d.74b78d15.webp",h=t.p+"static/image/da195c9e39d5bcc3919d01e86f2c6e5e.fac993e1.webp",x=t.p+"static/image/6eb4cdaeb93f99355470ffb6e7c34679.d4c82683.webp";function p(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",pre:"pre",code:"code",h2:"h2",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",strong:"strong",h3:"h3",img:"img",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"3jest-断言如何告诉程序什么是你的预期",children:["3.Jest 断言：如何告诉程序什么是你的预期？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3jest-断言如何告诉程序什么是你的预期",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["代码仓库：",(0,r.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"上节课我们详细聊了技术选型，选用了 Jest + React Testing Library 来作为单元测试的技术栈，Jest 是一个 JavaScript 集大成的测试库，是我们单元测试的基础，而 React Testing Library 则提供了一些 React Component 的 Api ，来协助我们进行 React Dom 和事件相关的单测编写。"}),"\n",(0,r.jsx)(n.p,{children:"这节课将详细介绍我们是如何通过 Jest 来描述我们的预期的，在开始这节课的学习前，我们来看看上节写的单元测试。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// ./src/App.test.tsx\nimport React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"其中 test 用于定义单个的用例， 与此类似的还有 describe 和 it，describe 表示一组分组，其中可以包含多组 test，而 it 是 test 的别名，有相同的作用，例如上节课中 Enzyme 的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./App.test.tsx\nimport { mount } from "enzyme";\nimport App from "./App";\n\ndescribe("test", () => {\n  it("first unit test", () => {\n    const app = mount(<App />);\n    expect(app.find(".read-the-docs").getDOMNode().textContent).toEqual(\n      "Click on the Vite and React logos to learn more"\n    );\n  });\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["我们来看其中的 Callback 逻辑，在这则单测中我们判断了 Learn react 这则文案是否在我们的 DOM 中，",(0,r.jsx)(n.code,{children:"screen.getByText"}),"用于元素的查找，是 React Testing Library 提供给我们的 API，这部分会在 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7174044519350927395/section/7176804322653503528",target:"_blank",rel:"noopener noreferrer",children:"6 | DOM断言：页面元素的断言"})," 详细举例介绍，我们这边不过多介绍。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"expect(linkElement).toBeInTheDocument();\n"})}),"\n",(0,r.jsx)(n.p,{children:"在选取完元素后，上面这行代码告诉了单测程序，我们希望选取的元素可以存在页面正文中。其实从语义上也很好理解，expect(期望）linkElement(这个元素）toBeInTheDocument（可以在页面正文）。"}),"\n",(0,r.jsxs)(n.p,{children:["其中",(0,r.jsx)(n.code,{children:"expect"}),"在我们后面的每次测试中都会频繁用到，其中的参数填入你需要进行判断的对象，",(0,r.jsx)(n.code,{children:"toBeInTheDocument"})," 这个 Api 是匹配器，也称断言，用来告诉程序你的预期是什么，通过对预期的对象进行断言就是单元测试的基本原理。"]}),"\n",(0,r.jsxs)(n.p,{children:["在 Jest 中有提供很多基础的断言，来帮助描述我们需求中的常见场景，这节课我们就先来学习 Jest 提供哪些断言的 Api 来帮助我们编写测试预期（",(0,r.jsx)(n.code,{children:"toBeInTheDocument"}),"是React Testing Library 提供的额外断言 Api，我们在",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7174044519350927395/section/7176804322653503528",target:"_blank",rel:"noopener noreferrer",children:"6 | DOM断言：页面元素的断言"})," 一起介绍）。"]}),"\n",(0,r.jsxs)(n.h2,{id:"jest-常见断言场景",children:["Jest 常见断言场景",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#jest-常见断言场景",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我根据常用断言的使用场景分成了以下六个方向："}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{children:"场景方向"}),"\n",(0,r.jsx)(n.th,{children:"涉及的断言Api"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"基础类型的比较"}),"\n",(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"not"}),"  ",(0,r.jsx)(n.code,{children:"toBe(value)"}),"  ",(0,r.jsx)(n.code,{children:"toBeTruthy(value)"}),"  ",(0,r.jsx)(n.code,{children:"toBeFalsy(value)"}),"  ",(0,r.jsx)(n.code,{children:"toBeDefined()"}),"  ",(0,r.jsx)(n.code,{children:"toBeUndefined()"}),"  ",(0,r.jsx)(n.code,{children:"toBeCloseTo(value)"})," ",(0,r.jsx)(n.code,{children:"toBeNaN()"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"引用类型的比较"}),"\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"toEqual(value)"})}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"数字符号"}),"\n",(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"toBeGreaterThan(value)"}),"  ",(0,r.jsx)(n.code,{children:"toBeLessThan(value)"}),"  ",(0,r.jsx)(n.code,{children:"toBeGreaterThanOrEqual(value)"}),"  ",(0,r.jsx)(n.code,{children:"toBeLessThanOrEqual(value)"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"正则匹配"}),"\n",(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"toMatch(value)"}),"  ",(0,r.jsx)(n.code,{children:"toMatchObject(value)"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"表单验证"}),"\n",(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"toContain(value)"}),"  ",(0,r.jsx)(n.code,{children:"arrayContaining(value)"})," ",(0,r.jsx)(n.code,{children:"toContainEqual(value)"}),"  ",(0,r.jsx)(n.code,{children:"toHaveLength(value)"}),"  ",(0,r.jsx)(n.code,{children:"toHaveProperty(value)"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:"错误抛出"}),"\n",(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"toThrow()"}),"  ",(0,r.jsx)(n.code,{children:"toThrowError()"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["下面我们就按照上述方向，依次来学习以下对应断言的应用，首先我们在 src 目录下创建一个 ",(0,r.jsx)(n.strong,{children:"test"})," 来存放我们纯逻辑的单测。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\nimport React from "react";\n\ndescribe("examples for jest expect", () => {\n    // ... 本节课后续的test就放在这里\n});\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"基础类型的比较",children:["基础类型的比较",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基础类型的比较",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们知道，JavaScript 中分为基础类型和引用类型，其中基础类型中，大部分比较都可以通过 ",(0,r.jsx)(n.code,{children:"toBe"})," 来完成，而",(0,r.jsx)(n.code,{children:"not"}),"则用来表示非的判断，比如下面的简单例子。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("基础类型的比较", () => {\n    // tobe\n    expect(1 + 1).toBe(2);\n    // not\n    expect(1 + 1).not.toBe(3);\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"不仅是数字，包括 boolean 和 undefined 在内都是可以的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("基础类型的比较", () => {\n    // ...\n    // boolean\n    expect(true).toBe(true);\n    // undefined\n    expect(undefined).toBe(undefined); \n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"虽然这些可以通过 toBe 判断，但是同时 Jest 还提供了 4 个 API 来判断 true、 false、undefined、defined，效果与 toBe 来判断是都相同的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("基础类型的比较", () => {\n    // ...\n    // boolean\n    expect(true).toBe(true);\n    expect(true).toBeTruthy();\n    expect(false).toBeFalsy();\n    // undefined\n    expect(undefined).toBe(undefined);\n    expect(undefined).not.toBeDefined();\n    expect(undefined).toBeUndefined();\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"不仅是针对变量，对函数返回值的判断也是可以的，比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("基础类型的比较", () => {\n    // ...\n    // undefined\n    const test = () => {\n      console.log(test);\n    };\n    expect(test()).toBeUndefined();\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"虽然 toBe 的能力很强大，但是针对浮点类型就不行了，比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("基础类型的比较", () => {\n    // ...\n    // 浮点数\n    expect(0.2 + 0.1).toBe(0.3);\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"针对这个用例，我们会得到下面的结果。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个倒不是 Jest 的原因，而是由于 JavaScript 本身的特性导致的，我们知道 JavaScript 中数字只有一个 number 类型，与 Java 等语言不同，JavaScript 并没有类似 float 或是 double 的浮点类型，浮点的实现都采用 double(双精度存储）。"}),"\n",(0,r.jsx)(n.p,{children:"大学时候计组课程我们学过，针对双精度存储，包含 8 个字节，也就是 64 位二进制（1 位符号位，11 位阶码（指数位），52 位尾数位），而十进制转二进制可能是除不尽的，52 位尾数位后面的位数就会被抹掉。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"所以针对 0.1 + 0.2 的计算其实是这样的过程，首先需要把 0.1 和 0.2 转化成对应的二进制。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样加起来得到的结果就是 0.0100110011001100110011001100110011001100110011001101，因为上面我们说过 JavaScript 是会把 52位尾数后的内容抹掉的，所以这个结果并不是完全精准的，转换为十进制就是 0.30000000000000004，所以没办法全等。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"所以针对浮点数的比较，Jest 有提供一个专门的断言来进行判断，那就是 toBeCloseTo，和它的字面意思相同，这个断言用来判断对象和预期的精度是否足够接近，而不再是全等，例如下面的例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("基础类型的比较", () => {\n    // ...\n    // 浮点数\n    expect(0.2 + 0.1).toBe(0.3);\n    expect(0.2 + 0.1).toBeCloseTo(0.3);\n})\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这样看下来，toBe 是不是和我们平时常用的 === 很像，不过严格意义上说，toBe 的效果并不等同于 全等===， ",(0,r.jsx)(n.strong,{children:"它是一种更加精确的匹配，应该说等同于 Object.is"}),"，这个是 ES6 提供的新方法，相比 ===， 它修复了 JavaScript 历史的两个问题，NaN 和 +(-)0 。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,UklGRhgFAABXRUJQVlA4IAwFAABQIgCdASp3AVAAPp1Oo0ylpCMiIrTZOLATiWdu4XHg3JlzVsytcy+hPbAc776Ed4T6Kv1Wv8lkwPjn+b9of+AxvfInZhQ48gXTp5FN0Ixh/qe+t1Gu5GtT0AP5J/kP9r7K/8V/1f83+O3tN+g/2M+AL9XP+VwKv7TCWv7ykGQZW3hVemmvRHZ4ZtM0+ApvPZpST9PfSOoxaK1/qub7seL9oO+3oiiNci/NyWsjRSumOCWrAi61jdaxutY1sANJraTsvk1as8N+1BqNKshMCAmje/l8bfeCs77ukSoXVxdwAYEtHyQWb94QW7Ay8kTIcaIn7wP/DXCt8mtY1qnELLHLzviQkmKQEyh3n8wEd5JIPJuA5fZGk3AcvsUgAP7ElocW+7zOmYaEp4XSZCkXLX6j7OPF7+BG6PYsmWQaKpFlpjT6DgHCwVaAI3Dl0a1PiUPzwXVuP3UB+eRifn1nHJped5g2QgtoRGzAX1B3VSPpeh2U7motzh3teEyw+kBalGPM3hbD9HyKfF87A51A3+NC4Y7pVTTIi5DvdYsac+C5zs8j7Lf3s5jCwF2vpHt13gDztdXA8nLBI75MH21tf/TCMmRZpPvJccGHPp64X5eZde0AToXtzIarz1igraz0DAb+G0dJ7u/5MWtXPGv/eG9oDvIrpI2CMerHiHBYOMIWKYqXltl/4CBWCL31Br+37wU0J+Fao5wCBDUi4dZBtr3HuQ1g8uWh0KERTNnSVZ/3HMIlRjeW8rmR2U2PkrWm2mxLdh/ljcFixr9WlRRi/e4FdEvewb5dddRb/ww6Q9g/WeT6JVuPHgEJB/UUd2nIQvwmN7iB67Ug5avjpOQlfFaIzV7nxRQchK+K0RkxfWg42m1QkxtN0yzpA2duVgOEKQ+wTxzOwvgDbPSU4zMUMHdlu7nFxWkOSC8wsZXEcyjY+ZoJ/Hy+clN9pxIXPNgjGAKguRMhTqXiLBSo+4RN4LAm0qEiGLrdVfsffJoCRQ0CYgraQNBCNcFv6rjy5CYppIeNwR4E4/sI0wZ5Tj4If2x5sOPY/IOd6vpLT/Iu5Uf7v3RQ1Q5E0QTx2V2F1qsM/KLVuAAAABxBZaV1Y2pApK5kCnqCM3IHrNcBaceqIqlpXQgYH4giSoxp4FpBVJuOfFmwpoofjzGnnJjxMpvm2GBWfrLunTuY05HJuE2qkJQqOXdSJfAF+h/MV9XNqeY22OVJmj0NMF9AiQliNLX+uIJQe5y/q+dAfQsknxgW0NJTAh7M4mQCUwvvi8ZUZwAJZgmXt0uylSJDL5pQd3vpgvTHwmusNJf1AkN4i2+0+NNWSqq8ZtXgEPa8d+eZyPX9bPZetY6fe3eAv5ERCOHVXMUuzp5GFWzuN5v8mbTGfBgOcA2sY87UJunpdfI5Mjag3rk+lIJ+vrhabNbfYBjz+eEJrlkwW2Awl3a/0MLiTnahPWwJM7Uz84+d/qmPJpRgPZGZsBANqsO23/YwMpXbYr5Ny/04Ww+9MSkQWQAAe/Af9OcOaCbqCuGQheaSifWnlSzaMk1KXlU+ZT5LxI2y7T0Ue0/SfzTThVMaapcNJJLoIGa7vCz8/x7smwjPFXUouyuiOWxc1bMJyzEvqz6cGQC4zcoph2TYyXn8QL95lk4PyQPXPZmjzAEeFW4oVdnCsZhkNhxs7c6TZy/LeNa5nqc2FxAZDoaTjFCmH/dt/pq8wMozChm+A9LqAAAAAA==",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"对于 Object.is 这两个不合理的判断都得到了修复。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["针对这两个场景，我们可以写如下的断言，其中",(0,r.jsx)(n.code,{children:"toBeNaN"})," 也是 Jest 提供的额外基础断言 API，效果上与",(0,r.jsx)(n.code,{children:"toBe(NaN)"})," 也是相同的。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("基础类型的比较", () => {\n    // ...\n    // NaN\n    expect(NaN).toBe(NaN);\n    expect(NaN).toBeNaN();\n    // +0 -0\n    expect(+0).not.toBe(-0);\n})\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"引用类型的比较",children:["引用类型的比较",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#引用类型的比较",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"除了基础类型外，我们知道 JavaScript 还有引用类型，与基础类型不同的是，引用类型的全等，是对引用类型的内存指针进行比较，对于深拷贝或是属性完全相同的对象，使用 toBe 的断言是不能满足预期的，所以 Jest 有专门为这类情况提供断言 toEqual(value)，相比 toBe，toEqual 会深度递归对象的每个属性，进行深度比较，只要原始值相同，那就可以通过断言。我们来看下面的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("引用类型的比较", () => {\n    const a = { obj1: { name: "obj1", obj2: { name: "obj2" } } };\n    const b = Object.assign(a);\n    const c = JSON.parse(JSON.stringify(a));\n    expect(a).toBe(b);\n    expect(a).not.toBe(c);\n    expect(a).toEqual(b);\n    expect(a).toEqual(c);\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"其中有 a, b, c 三个对象，b 对象是基于 a 对象的浅拷贝，而 c 对象是基于 a 对象的深拷贝，我们可以看到，a 和 b 是可以通过 toBe 来验证的，因为它们指向同一个内存指针，而 c 是完全开创出来的独立的内存空间，所以不能用全等进行验证，这里我们采用 toEqual 进行验证。"}),"\n",(0,r.jsx)(n.p,{children:"值得一提的是，toEqual 能不能用于验证基础类型呢？也是可以的，我们看下面的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("引用类型的比较", () => {\n    // ...\n    expect(1 + 1).toEqual(2);\n})\n'})}),"\n",(0,r.jsx)(n.p,{children:"我们上面有提到，toEqual 是采用深度递归的方式进行的原始值比较，虽然基础类型本身并不是对象，但是在对它们的 proto 进行递归比较的时候，会调用它们对应的包装类型创建实例，实例本身是可以作为对象进行比较的，所以 toEqual 同样可以用于基础类型的比较，比较的结果预期将是所有递归属性的值相等。"}),"\n",(0,r.jsxs)(n.h3,{id:"数字符号",children:["数字符号",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数字符号",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们在书写单测验证一些场景的时候，经常会有数字值比较的需求，比如 > ， < 等，这些也有对应的基础断言可以进行验证，比较简单就不过多讲解了，大家可以看看下面的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("数字符号", () => {\n    // >\n    expect(3).toBeGreaterThan(2);\n    // <\n    expect(3).toBeLessThan(4);\n    // >=\n    expect(3).toBeGreaterThanOrEqual(3);\n    expect(3).toBeGreaterThanOrEqual(2);\n    // <=\n    expect(3).toBeLessThanOrEqual(3);\n    expect(3).toBeLessThanOrEqual(4);\n  });\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"正则匹配",children:["正则匹配",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正则匹配",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["正则匹配同样也是我们开发中比较常见的场景，针对这个场景，Jest 断言中有两个常用的匹配器会经常使用，分别是 ",(0,r.jsx)(n.code,{children:"toMatch(regexp)"})," 和 ",(0,r.jsx)(n.code,{children:"toMatchObj(value)"}),"，其中 ",(0,r.jsx)(n.code,{children:"toMatch(regexp)"})," 会匹配字符串是否能够满足正则的验证，而",(0,r.jsx)(n.code,{children:"toMatchObj(value)"}),"则用来验证对象能否包含 value 的全部属性，即 value 是否是匹配对象的子集，我们来看下面的例子。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("正则匹配", () => {\n    expect("This is a regexp validation").toMatch(/regexp/);\n    const obj = { prop1: "test", prop2: "regexp validation" };\n    const childObj = { prop1: "test" };\n    expect(obj).toMatchObject(childObj);\n  });\n'})}),"\n",(0,r.jsx)(n.p,{children:"其中“This is a regexp validation” 包含 “regexp”字符串，childObj 也作为 obj 的子集，所以这个验证是可以通过的。"}),"\n",(0,r.jsxs)(n.h3,{id:"表单验证",children:["表单验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#表单验证",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们在需求中经常会有很多表单，对于表单值的判断也是一个很常遇到的场景，表单验证中我们经常会有值为数组或是对象的判定，所以验证某个字段是否在对象或者数组中是很有必要的。表单验证中也有提供对应能力的断言："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toContain(value)"})," ：判定某个值是否存在在数组中。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"arrayContaining(value)"}),"：匹配接收到的数组，与 toEqual 结合使用可以用于判定某个数组是否是另一个数组的子集。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toContainEqual(value)"})," ：用于判定某个对象元素是否在数组中。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toHaveLength(value)"}),"：断言数组的长度 。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"toHaveProperty(value)"}),"：断言对象中是否包含某个属性，针对多层级的对象可以通过 xx.yy 的方式进行传参断言。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们来结合下面的例子具体说明："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("表单验证", () => {\n    // 数组元素验证\n    expect([1, 2, 3]).toContain(1);\n    expect([1, 2, 3]).toEqual(expect.arrayContaining([1, 2]));\n    expect([{ a: 1, b: 2 }]).toContainEqual({ a: 1, b: 2 });\n    // 数组长度\n    expect([1, 2, 3]).toHaveLength(3);\n    // 对象属性验证\n    const testObj = {\n      prop1: 1,\n      prop2: {\n        child1: 2,\n        child2: "test",\n      },\n    };\n    expect(testObj).toHaveProperty("prop1");\n    expect(testObj).toHaveProperty("prop2.child1");\n  });\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在上面的例子中，我们分别对基础元素、数组子集、对象子集的包含关系、数组长度、对象包含的属性进行了断言，对于复合属性断言的场景，我们可以采用类似 ",(0,r.jsx)(n.code,{children:'expect(testObj).toHaveProperty("prop2.child1")'}),"的方式进行传参，用 . 来体现对应的层级关系即可。"]}),"\n",(0,r.jsxs)(n.p,{children:["值得一提的是，",(0,r.jsx)(n.code,{children:"expect([1, 2, 3]).toEqual(expect.arrayContaining([1, 2]));"}),"与之前的断言不同，我们使用",(0,r.jsx)(n.code,{children:"expect.arrayContaining([1, 2])"}),"来替代了文字值，也就是能匹配所有能够涵括它的数组。只要 [1, 2] 是数组 A 的子集，那么数组 A 就可以成为 ",(0,r.jsx)(n.code,{children:"arrayContaining"})," 的匹配对象。"]}),"\n",(0,r.jsxs)(n.h3,{id:"错误抛出",children:["错误抛出",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#错误抛出",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["最后一个要介绍的场景就是错误抛出，无论是业务或是基础组件代码，错误抛出都是一个常见的场景，对于这些异常情况的断言，也是我们单元测试的一个重要部分。针对这种场景，Jest 提供了 ",(0,r.jsx)(n.code,{children:"toThrow"})," 和 ",(0,r.jsx)(n.code,{children:"toThrowError"})," 两个匹配器，这两个匹配器能力都相同，",(0,r.jsx)(n.code,{children:"toThrowError"})," 可以理解成是 ",(0,r.jsx)(n.code,{children:"toThrow"})," 的一个别名，我们来看下面的例子。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("错误抛出", () => {\n    const throwError = () => {\n      const err = new Error("console err: this is a test error!");\n      throw err;\n    };\n    expect(throwError).toThrow();\n    expect(throwError).toThrowError();\n\n    const catchError = () => {\n      try {\n        const err = new Error("console err: this is a test error!");\n        throw err;\n      } catch (err) {\n        console.log(err);\n      }\n    };\n    expect(catchError).not.toThrow();\n    expect(catchError).not.toThrowError();\n  });\n'})}),"\n",(0,r.jsxs)(n.p,{children:["对于上面的例子，值得一提的是",(0,r.jsx)(n.code,{children:"expect(throwError).toThrow();"}),"中，throwError方法只需要传入即可，不需要执行，即",(0,r.jsx)(n.code,{children:"expect(throwError).toThrow();"}),"，直接执行会抛出未捕获的错误，中断后续的测试进程。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果我们在方法中，已经有了错误的捕获，那么断言本身是无法生效的，这个大家需要注意一下。"}),"\n",(0,r.jsxs)(n.h2,{id:"自定义断言",children:["自定义断言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义断言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上文我们已经针对常见的断言场景，介绍了 Jest 提供的一些常用的匹配器 API，当然官方还提供了一些别的匹配器，不过在日常需求中并不常用，感兴趣的同步可以移步",(0,r.jsx)(n.a,{href:"https://jestjs.io/docs/expect#expectarraycontainingarray",target:"_blank",rel:"noopener noreferrer",children:"官网"}),"了解更多。"]}),"\n",(0,r.jsx)(n.p,{children:"除了基础的已经定义好的断言 API，Jest 也支持我们自定义断言匹配器，来覆盖基础的断言不能覆盖到的特殊业务场景，我们可以使用 Expect.extend 来自定义断言，我们先通过这个 API 的类型，来对它的能力有个初步的了解。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到 ",(0,r.jsx)(n.code,{children:"extend"})," 可以接收一个 key - matcher 的映射 map，不难猜到，key 是自定义匹配器的名称，而 CustomMatcher 则对应匹配器的定义。通过 CustomMatcher 的类型定义我们可以看到，自定义匹配器包含同步（CustomeMatcherResult) 和 异步（Promise",")两种，它们都接收类型为 ",(0,r.jsx)(n.code,{children:" { pass: boolean; message: () => string }  "}),"的返回值，其中 pass 表示这个断言是否通过，而 message 则作为这个结果的备注信息。"]}),"\n",(0,r.jsx)(n.p,{children:"我们首先来尝试定义一个同步的匹配器，想象一个场景，假如我们需要断言一个数字是否在 0 到 10 之间，应该怎么实现这个匹配器呢？我们来看下面的例子。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("同步自定义匹配器", () => {\n    const toBeBetweenZeroAndTen = (num: number) => {\n      if (num >= 0 && num <= 10) {\n        return {\n          message: () => "",\n          pass: true,\n        };\n      } else {\n        return {\n          message: () => "expected num to be a number between zero and ten",\n          pass: false,\n        };\n      }\n    };\n    expect.extend({\n      toBeBetweenZeroAndTen,\n    });\n    expect(8).toBeBetweenZeroAndTen();\n    expect(11).not.toBeBetweenZeroAndTen();\n  });\n'})}),"\n",(0,r.jsx)(n.p,{children:"可以看到同步匹配器的实现很简单，我们只需要在我们预期的判断逻辑中返回对应的结构体，然后将对应的匹配器方法传给 extend 后，就可以通过 expect 来调用对应的匹配器了。现在我们来改造一下这个匹配器，使得它可以支持异步的场景。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// ./src/__test__/expect.test.ts\ntest("异步自定义匹配器", async () => {\n    const toBeBetweenZeroAndTen = async (num: number) => {\n      const res = await new Promise<{ message: () => string; pass: boolean }>(\n        (resolve) => {\n          setTimeout(() => {\n            if (num >= 0 && num <= 10) {\n              resolve({\n                message: () => "",\n                pass: true,\n              });\n            } else {\n              resolve({\n                message: () =>\n                  "expected num to be a number between zero and ten",\n                pass: false,\n              });\n            }\n          }, 1000);\n        }\n      );\n      return (\n        res || {\n          message: () => "expected num to be a number between zero and ten",\n          pass: false,\n        }\n      );\n    };\n    expect.extend({\n      toBeBetweenZeroAndTen,\n    });\n    await expect(8).toBeBetweenZeroAndTen();\n    await expect(11).not.toBeBetweenZeroAndTen();\n  });\n'})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，异步场景只是在同步的基础上加上了 async/await 相关的逻辑，然后在 expect 调用对应匹配器的时候，使用 await 等待结果返回即可。"}),"\n",(0,r.jsxs)(n.h2,{id:"怎么调试单测程序",children:["怎么调试单测程序？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#怎么调试单测程序",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上文我们介绍了 Jest 提供的常用断言匹配器，以及如何自定义一个断言匹配器，这里加一个小彩蛋，很多同学可能并不知道怎么调试测试代码，与业务逻辑不同，测试代码运行在 node，所以并不能通过浏览器 console 调试，我们可以采用和调试 node 服务相同的方式来调试我们的单测程序。下面简单举例说明一下。"}),"\n",(0,r.jsx)(n.p,{children:"首先我们在需要断点的位置写入 debugger，或是在左侧点击断点红点都可。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后通过 vscode JavaScript 调试终端而非普通运行终端，运行对应的单测命令。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到对应断点处就已经停顿下来了，并且可以在左侧视图层看到当前状态下的变量值，顶部也会有步进等调试的按钮，后面我们就像平时调试代码一样正常调试代码就好了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节课我们学习了怎么告诉测试程序你的预期，我们通过不同的断言来对每个需要验证的对象提出自己的预期，当断言的结果与预期不符的时候，测试程序就会将错误和未通过的用例反馈给你。"}),"\n",(0,r.jsx)(n.p,{children:"针对断言有很多种类，我们基于场景分类，分别学习了基础类型比较，引用类型比较、数字符号、正则匹配等常见的 Jest 断言匹配器。同时我们还尝试自己自定义了断言匹配器，来覆盖基础断言器不足以满意的业务需求。"}),"\n",(0,r.jsx)(n.p,{children:"最后我们还了解了怎么去测试一个单测程序，因为与常规业务代码不同，测试程序执行于 node 环境，所以我们采用开发 node 服务类似的调试方式对测试用例进行调试。"}),"\n",(0,r.jsx)(n.p,{children:"相信经过这节课的学习，同学们已经入门了对纯逻辑的单元测试进行用例的编写，但是这样还远远不够，因为我们的单元测试主要还是覆盖于包含 DOM 的组件场景下，下一节课，我们将来学习 React Testing Library 给我们提供的 DOM 扩展能力，掌握如何对期望 DOM 区域进行选取。"})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}let A=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F3.Jest%20%E6%96%AD%E8%A8%80%EF%BC%9A%E5%A6%82%E4%BD%95%E5%91%8A%E8%AF%89%E7%A8%8B%E5%BA%8F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%A0%E7%9A%84%E9%A2%84%E6%9C%9F%EF%BC%9F.md"]={toc:[{text:"Jest 常见断言场景",id:"jest-常见断言场景",depth:2},{text:"基础类型的比较",id:"基础类型的比较",depth:3},{text:"引用类型的比较",id:"引用类型的比较",depth:3},{text:"数字符号",id:"数字符号",depth:3},{text:"正则匹配",id:"正则匹配",depth:3},{text:"表单验证",id:"表单验证",depth:3},{text:"错误抛出",id:"错误抛出",depth:3},{text:"自定义断言",id:"自定义断言",depth:2},{text:"怎么调试单测程序？",id:"怎么调试单测程序",depth:2},{text:"小结",id:"小结",depth:2}],title:"3.Jest 断言：如何告诉程序什么是你的预期？",headingTitle:"3.Jest 断言：如何告诉程序什么是你的预期？",frontmatter:{}}}}]);