"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["86913"],{368796:function(e,n,d){d.r(n),d.d(n,{default:()=>t});var s=d(552676),c=d(740453);let l=d.p+"static/image/a4d2a3d3f7c89f5d3f73a4c41308290d.9baaa4a8.webp",r=d.p+"static/image/ea982150042f66ffdae33816b094981e.1fa533af.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",img:"img",h3:"h3",h4:"h4",pre:"pre",ol:"ol",li:"li",ul:"ul",blockquote:"blockquote",h2:"h2"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"2模块标准为什么-esm-是前端模块化的未来",children:["2.模块标准：为什么 ESM 是前端模块化的未来？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2模块标准为什么-esm-是前端模块化的未来",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["2002 年 AJAX 诞生至今，前端从刀耕火种的年代，经历了一系列的发展，各种标准和工具百花齐放。下图中我们可以看到，自 2009 年 Node.js 诞生，前端先后出现了 ",(0,s.jsx)(n.code,{children:"CommonJS"}),"、",(0,s.jsx)(n.code,{children:"AMD"}),"、",(0,s.jsx)(n.code,{children:"CMD"}),"、",(0,s.jsx)(n.code,{children:"UMD"}),"和",(0,s.jsx)(n.code,{children:"ES Module"})," 等模块规范，底层规范的发展催生出了一系列工具链的创新，比如 AMD 规范提出时社区诞生的模块加载工具",(0,s.jsx)(n.code,{children:"requireJS"}),"，基于 CommonJS 规范的模块打包工具",(0,s.jsx)(n.code,{children:"browserify"}),"，还有能让用户提前用上 ",(0,s.jsx)(n.code,{children:"ES Module"})," 语法的 JS 编译器",(0,s.jsx)(n.code,{children:"Babel"}),"、兼容各种模块规范的重量级打包工具",(0,s.jsx)(n.code,{children:"Webpack"}),"以及基于浏览器原生 ES Module 支持而实现的 ",(0,s.jsx)(n.strong,{children:"no-bundle"})," 构建工具 ",(0,s.jsx)(n.code,{children:"Vite"})," 等等。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["总体而言，业界经历了一系列",(0,s.jsx)(n.strong,{children:"由规范、标准引领工程化改革"}),"的过程。构建工具作为前端工程化的核心要素，与底层的前端模块化规范和标准息息相关。接下来的时间，我就带你梳理一下前端模块化是如何演进的。这样你能更清楚地了解到各种模块化标准诞生的背景和意义，也能更好地理解 ES Module 为什么能够成为现今最主流的前端模块化标准。"]}),"\n",(0,s.jsxs)(n.h3,{id:"无模块化标准阶段",children:["无模块化标准阶段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#无模块化标准阶段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["早在模块化标准还没有诞生的时候，前端界已经产生了一些模块化的开发手段，如",(0,s.jsx)(n.code,{children:"文件划分"}),"、",(0,s.jsx)(n.code,{children:"命名空间"}),"和 ",(0,s.jsx)(n.code,{children:"IIFE 私有作用域"}),"。下面，我来简单介绍一下它们的实现以及背后存在的问题。"]}),"\n",(0,s.jsxs)(n.h4,{id:"1-文件划分",children:["1. 文件划分",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-文件划分",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["文件划分方式是最原始的模块化实现，简单来说就是将应用的状态和逻辑分散到不同的文件中，然后通过 HTML 中的 script 来一一引入。下面是一个通过",(0,s.jsx)(n.code,{children:"文件划分"}),"实现模块化的具体例子:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-a.js\nlet data = "data";\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-b.js\nfunction method() {\n  console.log("execute method");\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'// index.html\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script src="./module-a.js"><\/script>\n    <script src="./module-b.js"><\/script>\n    <script>\n      console.log(data);\n      method();\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["从中可以看到",(0,s.jsx)(n.code,{children:"module-a"}),"和",(0,s.jsx)(n.code,{children:"module-b"}),"为两个不同的模块，通过两个 script 标签分别引入到 HTML 中，这么做看似是分散了不同模块的状态和运行逻辑，但实际上也隐藏着一些风险因素:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["模块变量相当于在全局声明和定义，会有变量名冲突的问题。比如 ",(0,s.jsx)(n.code,{children:"module-b"})," 可能也存在",(0,s.jsx)(n.code,{children:"data"}),"变量，这就会与 ",(0,s.jsx)(n.code,{children:"module-a"})," 中的变量冲突。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"由于变量都在全局定义，我们很难知道某个变量到底属于哪些模块，因此也给调试带来了困难。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["无法清晰地管理模块之间的依赖关系和加载顺序。假如",(0,s.jsx)(n.code,{children:"module-a"}),"依赖",(0,s.jsx)(n.code,{children:"module-b"}),"，那么上述 HTML 的 script 执行顺序需要手动调整，不然可能会产生运行时错误。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"2-命名空间",children:["2. 命名空间",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-命名空间",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"命名空间"}),"是模块化的另一种实现手段，它可以解决上述文件划分方式中",(0,s.jsx)(n.code,{children:"全局变量定义"}),"所带来的一系列问题。下面是一个简单的例子:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-a.js\nwindow.moduleA = {\n  data: "moduleA",\n  method: function () {\n    console.log("execute A\'s method");\n  },\n};\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-b.js\nwindow.moduleB = {\n  data: "moduleB",\n  method: function () {\n    console.log("execute B\'s method");\n  },\n};\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script src="./module-a.js"><\/script>\n    <script src="./module-b.js"><\/script>\n    <script>\n      // 此时 window 上已经绑定了 moduleA 和 moduleB\n      console.log(moduleA.data);\n      moduleB.method();\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这样一来，每个变量都有自己专属的命名空间，我们可以清楚地知道某个变量到底属于哪个",(0,s.jsx)(n.code,{children:"模块"}),"，同时也避免全局变量命名的问题。"]}),"\n",(0,s.jsxs)(n.h4,{id:"3-iife立即执行函数",children:["3. IIFE(立即执行函数)",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-iife立即执行函数",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["不过，相比于",(0,s.jsx)(n.code,{children:"命名空间"}),"的模块化手段，",(0,s.jsx)(n.code,{children:"IIFE"}),"实现的模块化安全性要更高，对于模块作用域的区分更加彻底。你可以参考如下",(0,s.jsx)(n.code,{children:"IIFE 实现模块化"}),"的例子:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-a.js\n(function () {\n  let data = "moduleA";\n\n  function method() {\n    console.log(data + "execute");\n  }\n\n  window.moduleA = {\n    method: method,\n  };\n})();\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-b.js\n(function () {\n  let data = "moduleB";\n\n  function method() {\n    console.log(data + "execute");\n  }\n\n  window.moduleB = {\n    method: method,\n  };\n})();\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'// index.html\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script src="./module-a.js"><\/script>\n    <script src="./module-b.js"><\/script>\n    <script>\n      // 此时 window 上已经绑定了 moduleA 和 moduleB\n      console.log(moduleA.data);\n      moduleB.method();\n    <\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["我们知道，每个",(0,s.jsx)(n.code,{children:"IIFE"})," 即",(0,s.jsx)(n.code,{children:"立即执行函数"}),"都会创建一个私有的作用域，在私有作用域中的变量外界是无法访问的，只有模块内部的方法才能访问。拿上述的",(0,s.jsx)(n.code,{children:"module-a"}),"来说:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-a.js\n(function () {\n  let data = "moduleA";\n\n  function method() {\n    console.log(data + "execute");\n  }\n\n  window.moduleA = {\n    method: method,\n  };\n})();\n'})}),"\n",(0,s.jsxs)(n.p,{children:["对于其中的 ",(0,s.jsx)(n.code,{children:"data"}),"变量，我们只能在模块内部的 ",(0,s.jsx)(n.code,{children:"method"})," 函数中通过闭包访问，而在其它模块中无法直接访问。这就是模块",(0,s.jsx)(n.code,{children:"私有成员"}),"功能，避免模块私有成员被其他模块非法篡改，相比于",(0,s.jsx)(n.code,{children:"命名空间"}),"的实现方式更加安全。"]}),"\n",(0,s.jsxs)(n.p,{children:["但实际上，无论是",(0,s.jsx)(n.code,{children:"命名空间"}),"还是",(0,s.jsx)(n.code,{children:"IIFE"}),"，都是为了解决全局变量所带来的命名冲突及作用域不明确的问题，也就是在",(0,s.jsx)(n.code,{children:"文件划分方式"}),"中所总结的",(0,s.jsx)(n.code,{children:"问题 1"})," 和",(0,s.jsx)(n.code,{children:"问题 2"}),"，而并没有真正解决另外一个问题——",(0,s.jsx)(n.strong,{children:"模块加载"}),"。如果模块间存在依赖关系，那么 script 标签的加载顺序就需要受到严格的控制，一旦顺序不对，则很有可能产生运行时 Bug。"]}),"\n",(0,s.jsx)(n.p,{children:"而随着前端工程的日益庞大，各个模块之间相互依赖已经是非常常见的事情，模块加载的需求已经成为了业界刚需，而以上的几种非标准模块化手段不能满足这个需求，因此我们需要指定一个行业标准去统一前端代码的模块化。"}),"\n",(0,s.jsxs)(n.p,{children:["不过前端的模块化规范统一也经历了漫长的发展阶段，即便是到现在也没有实现完全的统一。接下来，我们就来熟悉一下业界主流的三大模块规范: ",(0,s.jsx)(n.code,{children:"CommonJS"}),"、",(0,s.jsx)(n.code,{children:"AMD"})," 和 ",(0,s.jsx)(n.code,{children:"ES Module"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"commonjs-规范",children:["CommonJS 规范",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs-规范",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"CommonJS 是业界最早正式提出的 JavaScript 模块规范，主要用于服务端，随着 Node.js 越来越普及，这个规范也被业界广泛应用。对于模块规范而言，一般会包含 2 方面内容:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"统一的模块化代码规范"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["实现自动加载模块的加载器(也称",(0,s.jsx)(n.code,{children:"loader"}),")"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"对于 CommonJS 模块规范本身，相信有 Node.js 使用经验的同学都不陌生了，为了方便你理解，我举一个使用 CommonJS 的简单例子:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-a.js\nvar data = "hello world";\nfunction getData() {\n  return data;\n}\nmodule.exports = {\n  getData,\n};\n\n// index.js\nconst { getData } = require("./module-a.js");\nconsole.log(getData());\n'})}),"\n",(0,s.jsxs)(n.p,{children:["代码中使用 ",(0,s.jsx)(n.code,{children:"require"})," 来导入一个模块，用",(0,s.jsx)(n.code,{children:"module.exports"}),"来导出一个模块。实际上 Node.js 内部会有相应的 loader 转译模块代码，最后模块代码会被处理成下面这样:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"(function (exports, require, module, __filename, __dirname) {\n  // 执行模块代码\n  // 返回 exports 对象\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["对 CommonJS 而言，一方面它定义了一套完整的模块化代码规范，另一方面 Node.js 为之实现了自动加载模块的",(0,s.jsx)(n.code,{children:"loader"}),"，看上去是一个很不错的模块规范，但也存在一些问题:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["模块加载器由 Node.js 提供，依赖了 Node.js 本身的功能实现，比如文件系统，如果 CommonJS 模块直接放到浏览器中是无法执行的。当然, 业界也产生了 ",(0,s.jsx)(n.a,{href:"https://github.com/browserify/browserify",target:"_blank",rel:"noopener noreferrer",children:"browserify"})," 这种打包工具来支持打包 CommonJS 模块，从而顺利在浏览器中执行，相当于社区实现了一个第三方的 loader。"]}),"\n",(0,s.jsxs)(n.li,{children:["CommonJS 本身约定以同步的方式进行模块加载，这种加载机制放在服务端是没问题的，一来模块都在本地，不需要进行网络 IO，二来只有服务启动时才会加载模块，而服务通常启动后会一直运行，所以对服务的性能并没有太大的影响。但如果这种加载机制放到浏览器端，会带来明显的性能问题。它会产生大量同步的模块请求，浏览器要等待响应返回后才能继续解析模块。也就是说，",(0,s.jsx)(n.strong,{children:"模块请求会造成浏览器 JS 解析过程的阻塞"}),"，导致页面加载速度缓慢。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["总之，CommonJS 是一个不太适合在浏览器中运行的模块规范。因此，业界也设计出了全新的规范来作为浏览器端的模块标准，最知名的要数 ",(0,s.jsx)(n.code,{children:"AMD"})," 了。"]}),"\n",(0,s.jsxs)(n.h3,{id:"amd-规范",children:["AMD 规范",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#amd-规范",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AMD"}),"全称为",(0,s.jsx)(n.code,{children:"Asynchronous Module Definition"}),"，即异步模块定义规范。模块根据这个规范，在浏览器环境中会被异步加载，而不会像 CommonJS 规范进行同步加载，也就不会产生同步请求导致的浏览器解析过程阻塞的问题了。我们先来看看这个模块规范是如何来使用的:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// main.js\ndefine(["./print"], function (printModule) {\n  printModule.print("main");\n});\n\n// print.js\ndefine(function () {\n  return {\n    print: function (msg) {\n      console.log("print " + msg);\n    },\n  };\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["在 AMD 规范当中，我们可以通过 define 去定义或加载一个模块，比如上面的 ",(0,s.jsx)(n.code,{children:"main"})," 模块和",(0,s.jsx)(n.code,{children:"print"}),"模块，如果模块需要导出一些成员需要通过在定义模块的函数中 return 出去(参考 ",(0,s.jsx)(n.code,{children:"print"})," 模块)，如果当前模块依赖了一些其它的模块则可以通过 define 的第一个参数来声明依赖(参考",(0,s.jsx)(n.code,{children:"main"}),"模块)，这样模块的代码执行之前浏览器会先",(0,s.jsx)(n.strong,{children:"加载依赖模块"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"当然，你也可以使用 require 关键字来加载一个模块，如:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// module-a.js\nrequire(["./print.js"], function (printModule) {\n  printModule.print("module-a");\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["不过 require 与 define 的区别在于前者只能加载模块，而",(0,s.jsx)(n.code,{children:"不能定义一个模块"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["由于没有得到浏览器的原生支持，AMD 规范需要由第三方的 loader 来实现，最经典的就是 ",(0,s.jsx)(n.a,{href:"https://github.com/requirejs/requirejs",target:"_blank",rel:"noopener noreferrer",children:"requireJS"})," 库了，它完整实现了 AMD 规范，至今仍然有不少项目在使用。"]}),"\n",(0,s.jsx)(n.p,{children:"不过 AMD 规范使用起来稍显复杂，代码阅读和书写都比较困难。因此，这个规范并不能成为前端模块化的终极解决方案，仅仅是社区中提出的一个妥协性的方案，关于新的模块化规范的探索，业界从仍未停止脚步。"}),"\n",(0,s.jsxs)(n.p,{children:["同期出现的规范当中也有 CMD 规范，这个规范是由淘宝出品的",(0,s.jsx)(n.code,{children:"SeaJS"}),"实现的，解决的问题和 AMD 一样。不过随着社区的不断发展，SeaJS 已经被",(0,s.jsx)(n.code,{children:"requireJS"}),"兼容了。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["当然，你可能也听说过 ",(0,s.jsx)(n.code,{children:"UMD"})," (Universal Module Definition)规范，其实它并不算一个新的规范，只是兼容 AMD 和 CommonJS 的一个模块化方案，可以同时运行在浏览器和 Node.js 环境。顺便提一句，后面将要介绍的 ES Module 也具备这种跨平台的能力。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"es6-module",children:["ES6 Module",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#es6-module",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ES6 Module"})," 也被称作 ",(0,s.jsx)(n.code,{children:"ES Module"}),"(或 ",(0,s.jsx)(n.code,{children:"ESM"}),")， 是由 ECMAScript 官方提出的模块化规范，作为一个官方提出的规范，",(0,s.jsx)(n.code,{children:"ES Module"})," 已经得到了现代浏览器的内置支持。在现代浏览器中，如果在 HTML 中加入含有",(0,s.jsx)(n.code,{children:'type="module"'}),"属性的 script 标签，那么浏览器会按照 ES Module 规范来进行依赖加载和模块解析，这也是 Vite 在开发阶段实现 no-bundle 的原因，由于模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码，具体的模块加载流程我们会在下一节进行详细的解释。"]}),"\n",(0,s.jsxs)(n.p,{children:["大家可能会担心 ES Module 的兼容性问题，其实 ES Module 的浏览器兼容性如今已经相当好了，覆盖了 90% 以上的浏览器份额，在 ",(0,s.jsx)(n.a,{href:"https://caniuse.com/",target:"_blank",rel:"noopener noreferrer",children:"CanIUse"})," 上的详情数据如下图所示:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["不仅如此，一直以 CommonJS 作为模块标准的 Node.js 也紧跟 ES Module 的发展步伐，从 ",(0,s.jsx)(n.code,{children:"12.20"})," 版本开始",(0,s.jsx)(n.a,{href:"https://nodejs.org/api/esm.html#modules-ecmascript-modules",target:"_blank",rel:"noopener noreferrer",children:"正式支持"}),"原生 ES Module。也就是说，如今 ES Module 能够同时在浏览器与 Node.js 环境中执行，拥有天然的跨平台能力。"]}),"\n",(0,s.jsx)(n.p,{children:"下面是一个使用 ES Module 的简单例子:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// main.js\nimport { methodA } from "./module-a.js";\nmethodA();\n\n//module-a.js\nconst methodA = () => {\n  console.log("a");\n};\n\nexport { methodA };\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="./main.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["如果在 Node.js 环境中，你可以在",(0,s.jsx)(n.code,{children:"package.json"}),"中声明",(0,s.jsx)(n.code,{children:'type: "module"'}),"属性:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// package.json\n{\n  "type": "module"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"然后 Node.js 便会默认以 ES Module 规范去解析模块:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"node main.js\n// 打印 a\n"})}),"\n",(0,s.jsxs)(n.p,{children:["顺便说一句，在 Node.js 中，即使是在 CommonJS 模块里面，也可以通过 ",(0,s.jsx)(n.code,{children:"import"})," 方法顺利加载 ES 模块，如下所示:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'async function func() {\n  // 加载一个 ES 模块\n  // 文件名后缀需要是 mjs\n  const { a } = await import("./module-a.mjs");\n  console.log(a);\n}\n\nfunc();\n\nmodule.exports = {\n  func,\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"ES Module 作为 ECMAScript 官方提出的规范，经过五年多的发展，不仅得到了众多浏览器的原生支持，也在 Node.js 中得到了原生支持，是一个能够跨平台的模块规范。同时，它也是社区各种生态库的发展趋势，尤其是被如今大火的构建工具 Vite 所深度应用。可以说，ES Module 前景一片光明，成为前端大一统的模块标准指日可待。"}),"\n",(0,s.jsxs)(n.p,{children:["当然，这一讲我们只简单介绍了 ESM。至于高级特性，我们将在「高级应用篇」专门介绍。你可以先利用我这里给到的官方资料提前预习： ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules",target:"_blank",rel:"noopener noreferrer",children:"MDN 官方解释"}),"、",(0,s.jsx)(n.a,{href:"https://262.ecma-international.org/6.0/#sec-modules",target:"_blank",rel:"noopener noreferrer",children:"ECMAScript 内部提案细节"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这一节，我们要重点掌握",(0,s.jsx)(n.strong,{children:"前端模块化的诞生意义"}),"、",(0,s.jsx)(n.strong,{children:"主流的模块化规范"}),"和 ",(0,s.jsx)(n.strong,{children:"ESM 规范的优势"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["由于前端构建工具的改革与底层模块化规范的发展息息相关，从一开始我就带你从头梳理了前端模块化的演进史，从无模块化标准的时代开始谈起，跟你介绍了",(0,s.jsx)(n.code,{children:"文件划分"}),"的模块化方案，并分析了这个方案潜在的几个问题。随后又介绍了",(0,s.jsx)(n.code,{children:"命名空间"}),"和",(0,s.jsx)(n.code,{children:"IIFE"}),"两种方案，但这两种方式并没有解决模块自动加载的问题。由此展开对前端模块化规范的介绍，我主要给你分析了三个主流的模块化标准: ",(0,s.jsx)(n.code,{children:"CommonJS"}),"、",(0,s.jsx)(n.code,{children:"AMD"})," 以及 ",(0,s.jsx)(n.code,{children:"ES Module"}),"，针对每个规范从",(0,s.jsx)(n.code,{children:"模块化代码标准"}),"、",(0,s.jsx)(n.code,{children:"模块自动加载方案"}),"这两个维度给你进行了详细的拆解，最后得出 ES Module 即将成为主流前端模块化方案的结论。"]}),"\n",(0,s.jsx)(n.p,{children:"本小节的内容就到这里了，希望能对你有所启发，也欢迎你把自己的学习心得打到评论区，我们下一节再见~"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}let t=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F2.%E6%A8%A1%E5%9D%97%E6%A0%87%E5%87%86%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%20ESM%20%E6%98%AF%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9F.md"]={toc:[{text:"无模块化标准阶段",id:"无模块化标准阶段",depth:3},{text:"1. 文件划分",id:"1-文件划分",depth:4},{text:"2. 命名空间",id:"2-命名空间",depth:4},{text:"3. IIFE(立即执行函数)",id:"3-iife立即执行函数",depth:4},{text:"CommonJS 规范",id:"commonjs-规范",depth:3},{text:"AMD 规范",id:"amd-规范",depth:3},{text:"ES6 Module",id:"es6-module",depth:3},{text:"小结",id:"小结",depth:2}],title:"2.模块标准：为什么 ESM 是前端模块化的未来？",headingTitle:"2.模块标准：为什么 ESM 是前端模块化的未来？",frontmatter:{}}}}]);