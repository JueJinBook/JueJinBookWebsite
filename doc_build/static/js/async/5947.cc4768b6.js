"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["5947"],{411923:function(n,e,r){r.r(e),r.d(e,{default:()=>T});var a=r(552676),c=r(740453);let i=r.p+"static/image/fe3f0391b8dddf443c42fa072ef30920.2e4305e7.gif",s=r.p+"static/image/970c3a67bd240b5fa82f54c012497cb4.8ddc8527.webp",d=r.p+"static/image/917968cc94bf6e1f1d8ec867f91f596d.51d771b7.gif",t=r.p+"static/image/a0335427fa57db22e8ecbaab00d68525.b25daa30.webp",p=r.p+"static/image/189d20bd0a49497d9674ce01aa38ab3e.d3b2996a.gif",o=r.p+"static/image/ab174282429350e94775a57a422fa7e6.b42a081b.webp",l=r.p+"static/image/54a946287cb911ad9bca1966782cf260.11f260bd.gif",x=r.p+"static/image/ba0b57be551e28bdab108ee839eb60fe.a9e2355c.webp",g=r.p+"static/image/ea220b5901100203e1e3b57d759128aa.02451243.gif",f=r.p+"static/image/cd6ac9aa79b96950e7e9295fba4d03b9.b4c83fe9.webp",m=r.p+"static/image/a599bea4e2c44e740e3d0f7de3de3be6.b85763ca.webp",h=r.p+"static/image/6c9f8c77dc5ccf13791f87a7dd605664.38b76bce.gif",j=r.p+"static/image/0ab55df7f152d742296aadc77164276d.432550f8.webp",u=r.p+"static/image/164031b5cd1e65ab74c09cb7dd4bcbfd.f69c00bd.webp",b=r.p+"static/image/2bd88c9c0c3955d8f09f7aa0f34d9347.977745c9.gif",v=r.p+"static/image/af08596d4eae6b5e5f6135ba68fd728a.6ac8b98e.webp",A=r.p+"static/image/2427be57ffa0f1bf9e9e0e8f4ba53c2e.83a47ed1.gif",D=r.p+"static/image/b052b2d26662bb134c2e4ad43e8a33b1.e8bb59b5.webp",y=r.p+"static/image/9b0dff40c6af4c4b4b9bb89c92c10289.5c6d7a1a.gif",B=r.p+"static/image/89108eb73d3969bfff734db88d511be4.fcc18560.webp",L=r.p+"static/image/cf30daddad6bbb48f24127fa898f6f83.a4e78b98.gif",w=r.p+"static/image/e38df482231235ad1ecab6491520188b.797d92f7.webp",C=r.p+"static/image/47bb6f5316b2bc46c2876b730088a9a6.035317de.webp",N=r.p+"static/image/0499f004bc02445772a28d7c1d7e01e8.9e096b91.webp",P=r.p+"static/image/53650c02f6df161772a64c901afce8c5.dbb3e3d4.webp",E=r.p+"static/image/edbeaa15fd1795fb84826349b21b4093.03da29f2.gif",k=r.p+"static/image/d83ca199372caba25bbd4c600c8ca78c.36b26aea.webp",I=r.p+"static/image/5041bd3acaf8391e1d3959113607c75f.ef916317.gif",S=r.p+"static/image/2340122e8dea826f67ab7ef0d7acb893.b2ab0421.webp",R=r.p+"static/image/0af2579917f82ac6623ae8d7d8bd83ac.f0a5cf3f.webp",J=r.p+"static/image/a299f07e05e24c0a15c2631cd63cd276.e4df95c8.webp",H=r.p+"static/image/d5d38f6fe743a05b850ee5c00380c61b.fa2c5ee9.webp";function K(n){let e=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",ul:"ul",li:"li",h2:"h2"},(0,c.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"第51章基于react-dnd实现拖拽排序",children:["第51章—基于react-dnd实现拖拽排序",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第51章基于react-dnd实现拖拽排序",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"\uFEFF拖拽是常见的需求，在 react 里我们会用 react-dnd 来做。"}),"\n",(0,a.jsx)(e.p,{children:"这节我们通过一个拖拽排序的案例来入门下 react-dnd。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"npx create-react-app --template=typescript react-dnd-test\n"})}),"\n",(0,a.jsx)(e.p,{children:"新建个 react 项目"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:H,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"安装 react-dnd 相关的包："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"npm install react-dnd react-dnd-html5-backend\n"})}),"\n",(0,a.jsx)(e.p,{children:"然后改一下 App.tsx"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import './App.css';\n\nfunction Box() {\n  return <div className='box'></div>\n}\n\nfunction Container() {\n  return <div className=\"container\"></div>\n}\n\nfunction App() {\n  return <div>\n    <Container></Container>\n    <Box></Box>\n  </div>\n}\n\nexport default App;\n"})}),"\n",(0,a.jsx)(e.p,{children:"css 部分如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".box {\n  width: 50px;\n  height: 50px;\n  background: blue;\n  margin: 10px;\n}\n\n.container {\n  width: 300px;\n  height: 300px;\n  border: 1px solid #000;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"把它跑起来："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"npm run start\n"})}),"\n",(0,a.jsxs)(e.p,{children:["是这样的：\n",(0,a.jsx)("img",{src:J,alt:""})]}),"\n",(0,a.jsx)(e.p,{children:"现在我们想把 box 拖拽到 container 里，用 react-dnd 怎么做呢？"}),"\n",(0,a.jsx)(e.p,{children:"dnd 是 drag and drop 的意思，api 也分有两个 useDrag 和 useDrop。"}),"\n",(0,a.jsx)(e.p,{children:"box 部分用 useDrag 让元素可以拖拽："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function Box() {\n  const ref = useRef(null);\n\n  const [, drag]= useDrag({\n    type: 'box',\n    item: {\n      color: 'blue'\n    }\n  });\n\n  drag(ref);\n\n  return <div ref={ref} className='box'></div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"用 useRef 保存 dom 引用，然后用 useDrag 返回的第二个参数处理它。"}),"\n",(0,a.jsx)(e.p,{children:"至于 type 和 item，后面再讲。"}),"\n",(0,a.jsx)(e.p,{children:"然后是 Container："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function Container() {\n  const ref = useRef(null);\n\n  const [,drop] = useDrop(() => {\n    return {\n      accept: 'box',\n      drop(item) {\n        console.log(item);\n      }\n    }\n  });\n  drop(ref);\n\n  return <div ref={ref} className=\"container\"></div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"用 useDrop 让它可以接受拖拽过来的元素。"}),"\n",(0,a.jsx)(e.p,{children:"接收什么元素呢？"}),"\n",(0,a.jsx)(e.p,{children:"就是我们 useDrag 的时候声明的 type 的元素。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:R,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"在 drop 的时候会触发 drop 回调函数，第一个参数是 item，就是 drag 的元素声明的那个。"}),"\n",(0,a.jsx)(e.p,{children:"只是这样还不行，还要在根组件加上 Context："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:S,alt:""})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport { DndProvider } from 'react-dnd';\nimport { HTML5Backend } from 'react-dnd-html5-backend';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(<DndProvider backend={HTML5Backend}><App></App></DndProvider>);\n"})}),"\n",(0,a.jsx)(e.p,{children:"之前是直接渲染 App，现在要在外面加上 DndProvider。"}),"\n",(0,a.jsx)(e.p,{children:"这个就是设置 dnd 的 context的，用于在不同组件之间共享数据。"}),"\n",(0,a.jsx)(e.p,{children:"然后我们试试看："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:I,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"确实，现在元素能 drag 了，并且拖到目标元素也能触发 drop 事件，传入 item 数据。"}),"\n",(0,a.jsx)(e.p,{children:"那如果 type 不一样呢？"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:k,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:E,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"那就触发不了 drop 了。"}),"\n",(0,a.jsx)(e.p,{children:"然后我们给 Box 组件添加一个 color 的 props，用来设置背景颜色："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:P,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"并且给 item 的数据加上类型。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"interface ItemType {\n  color: string;\n}\ninterface BoxProps {\n  color: string\n}\nfunction Box(props: BoxProps) {\n  const ref = useRef(null);\n\n  const [, drag]= useDrag({\n    type: 'box',\n    item: {\n      color: props.color\n    }\n  });\n\n  drag(ref);\n\n  return <div ref={ref} className='box' style={\n    { background: props.color || 'blue'}\n  }></div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"添加几个 Box 组件试一下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:N,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:C,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"没啥问题。"}),"\n",(0,a.jsx)(e.p,{children:"然后我们改下 Container 组件，增加一个 boxes 数组的 state，在 drop 的时候把 item 加到数组里，并触发渲染："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:w,alt:""})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function Container() {\n  const [boxes, setBoxes] = useState<ItemType[]>([]);\n\n  const ref = useRef(null);\n\n  const [,drop] = useDrop(() => {\n    return {\n      accept: 'box',\n      drop(item: ItemType) {\n        setBoxes((boxes) => [...boxes, item])\n      }\n    }\n  });\n  drop(ref);\n\n  return <div ref={ref} className=\"container\">\n    {\n      boxes.map(item => {\n        return <Box color={item.color}></Box>\n      })\n    }\n  </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"这里 setBoxes 用了函数的形式，这样能拿到最新的 boxes 数组，不然会形成闭包，始终引用最初的空数组。"}),"\n",(0,a.jsx)(e.p,{children:"测试下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:L,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这样，拖拽到容器里的功能就实现了。"}),"\n",(0,a.jsx)(e.p,{children:"我们再加上一些拖拽过程中的效果："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:B,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"useDrag 可以传一个 collect 的回调函数，它的参数是 monitor，可以拿到拖拽过程中的状态。"}),"\n",(0,a.jsx)(e.p,{children:"collect 的返回值会作为 useDrag 的返回的第一个值。"}),"\n",(0,a.jsx)(e.p,{children:"我们判断下，如果是在 dragging 就设置一个 dragging 的 className。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function Box(props: BoxProps) {\n  const ref = useRef(null);\n\n  const [{dragging}, drag]= useDrag({\n    type: 'box',\n    item: {\n      color: props.color\n    },\n    collect(monitor) {\n      return {\n        dragging: monitor.isDragging()\n      }\n    }\n  });\n\n  drag(ref);\n\n  return <div ref={ref} className={ dragging ? 'box dragging' : 'box'} style={\n    { background: props.color || 'blue'}\n  }></div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"然后添加 dragging 的样式："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".dragging {\n  border: 5px dashed #000;\n  box-sizing: border-box;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"测试下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:y,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"确实，这样就给拖拽中的元素加上了对应的样式。"}),"\n",(0,a.jsx)(e.p,{children:"但如果我们想把这个预览的样式也给改了呢？"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这时候就要新建个组件了："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"const DragLayer = () => {\n  const { isDragging, item, currentOffset} = useDragLayer((monitor) => ({\n      item: monitor.getItem(),\n      isDragging: monitor.isDragging(),\n      currentOffset: monitor.getSourceClientOffset(),\n    }));\n\n    if (!isDragging) {\n      return null;\n    }\n    return (\n      <div className='drag-layer' style={{\n        left: currentOffset?.x,\n        top: currentOffset?.y\n      }}>{item.color} 拖拖拖</div>\n    );\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"useDragLayer 的参数是函数，能拿到 monitor，从中取出很多东西，比如 item、isDragging，还是有 clientOffset，也就是拖拽过程中的坐标。"}),"\n",(0,a.jsx)(e.p,{children:"其中 drag-layer 的样式如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".drag-layer {\n  position: fixed;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"引入下这个组件："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:D,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"现在的效果是这样的："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:A,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"确实加上了自定义的预览样式，但是原来的还保留着。"}),"\n",(0,a.jsx)(e.p,{children:"这个也可以去掉："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:v,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"useDrag 的第三个参数就是处理预览元素的，我们用 getEmptyImage 替换它，就看不到了。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"dragPreview(getEmptyImage())\n"})}),"\n",(0,a.jsx)(e.p,{children:"这时候就只有我们自定义的预览样式了："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"但其实这种逻辑只要执行一次就行，我们优化一下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"useEffect(() => {\n    drag(ref);\n    dragPreview(getEmptyImage(), { captureDraggingState: true });\n}, [])\n"})}),"\n",(0,a.jsx)(e.p,{children:"drop 的逻辑也同样："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"useEffect(()=> {\n    drop(ref);\n}, []);\n"})}),"\n",(0,a.jsx)(e.p,{children:"这样，我们就学会了 react-dnd 的基本使用。"}),"\n",(0,a.jsx)(e.p,{children:"总结下："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"使用 useDrag 处理拖拽的元素，使用 useDrop 处理 drop 的元素，使用 useDragLayer 处理自定义预览元素"}),"\n",(0,a.jsx)(e.li,{children:"在根组件使用 DndProvider 设置 context 来传递数据"}),"\n",(0,a.jsx)(e.li,{children:"useDrag 可以传入 type、item、collect 等。type 标识类型，同类型才可以 drop。item 是传递的数据。collect 接收 monitor，可以取拖拽的状态比如  isDragging 返回。"}),"\n",(0,a.jsx)(e.li,{children:"useDrag 返回三个值，第一个值是 collect 函数返回值，第二个是处理 drag 的元素的函数，第三个值是处理预览元素的函数"}),"\n",(0,a.jsx)(e.li,{children:"useDrop 可以传入 accept、drop 等。accept 是可以 drop 的类型。drop 回调函数可以拿到 item，也就是 drag 元素的数据"}),"\n",(0,a.jsx)(e.li,{children:"useDragLayer 的回调函数会传入 monitor，可以拿到拖拽的实时坐标，用来设置自定义预览效果"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"全部代码如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { useDrag, useDragLayer, useDrop } from 'react-dnd';\nimport './App.css';\nimport { useEffect, useRef, useState } from 'react';\nimport { getEmptyImage } from 'react-dnd-html5-backend'\n\ninterface ItemType {\n  color: string;\n}\ninterface BoxProps {\n  color: string\n}\nfunction Box(props: BoxProps) {\n  const ref = useRef(null);\n\n  const [{dragging}, drag, dragPreview]= useDrag({\n    type: 'box',\n    item: {\n      color: props.color\n    },\n    collect(monitor) {\n      return {\n        dragging: monitor.isDragging()\n      }\n    }\n  });\n\n  useEffect(() => {\n    drag(ref);\n    dragPreview(getEmptyImage());\n  }, [])\n\n  return <div ref={ref} className={ dragging ? 'box dragging' : 'box'} style={\n    { background: props.color || 'blue'}\n  }></div>\n}\n\nfunction Container() {\n  const [boxes, setBoxes] = useState<ItemType[]>([]);\n\n  const ref = useRef(null);\n\n  const [,drop] = useDrop(() => {\n    return {\n      accept: 'box',\n      drop(item: ItemType) {\n        setBoxes((boxes) => [...boxes, item])\n      }\n    }\n  });\n\n  useEffect(()=> {\n    drop(ref);\n  }, []);\n\n  return <div ref={ref} className=\"container\">\n    {\n      boxes.map(item => {\n        return <Box color={item.color}></Box>\n      })\n    }\n  </div>\n}\n\n\nconst DragLayer = () => {\n  const { isDragging, item, currentOffset} = useDragLayer((monitor) => ({\n      item: monitor.getItem(),\n      isDragging: monitor.isDragging(),\n      currentOffset: monitor.getSourceClientOffset(),\n    }));\n\n    if (!isDragging) {\n      return null;\n    }\n    return (\n      <div className='drag-layer' style={{\n        left: currentOffset?.x,\n        top: currentOffset?.y\n      }}>{item.color}拖拖拖</div>\n    );\n}\n\nfunction App() {\n  return <div>\n    <Container></Container>\n    <Box color=\"blue\"></Box>\n    <Box color=\"red\"></Box>\n    <Box color=\"green\"></Box>\n    <DragLayer></DragLayer>\n  </div>\n}\n\nexport default App;\n"})}),"\n",(0,a.jsx)(e.p,{children:"css："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".box {\n  width: 50px;\n  height: 50px;\n  background: blue;\n  margin: 10px;\n}\n\n.dragging {\n  border: 5px dashed #000;\n  box-sizing: border-box;\n}\n.drag-layer {\n  position: fixed;\n}\n\n.container {\n  width: 300px;\n  height: 300px;\n  border: 1px solid #000;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"入了门之后，我们再来做个进阶案例：拖拽排序"}),"\n",(0,a.jsx)(e.p,{children:"我们写个 App2.tsx"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { useState } from \"react\";\nimport './App2.css';\n\ninterface CardItem {\n    id: number;\n    content: string;\n}\n\ninterface CardProps {\n    data: CardItem\n}\nfunction Card(props: CardProps) {\n    const { data } = props;\n    return <div className=\"card\">{data.content}</div>\n}\nfunction App() {\n    const [cardList, setCardList] = useState<CardItem[]>([\n        {\n            id:0,\n            content: '000',\n        },\n        {\n            id:1,\n            content: '111',\n        },\n        {\n            id:2,\n            content: '222',\n        },\n        {\n            id:3,\n            content: '333',\n        },\n        {\n            id:4,\n            content: '444',\n        }\n    ]);\n\n    return <div className=\"card-list\">\n        {\n            cardList.map((item: CardItem) => (\n                <Card data={item} key={'card_' + item.id} />\n            ))\n        }\n    </div>\n}\n\nexport default App;\n"})}),"\n",(0,a.jsx)(e.p,{children:"还有 App2.css："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".card {\n  width: 200px;\n  line-height: 60px;\n  padding: 0 20px;\n  border: 1px solid #000;\n  margin: 10px;\n  cursor: move;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"就是根据 cardList 的数据渲染一个列表。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"把它渲染出来是这样的："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:j,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"拖拽排序，显然 drag 和 drop 的都是 Card。"}),"\n",(0,a.jsx)(e.p,{children:"我们给它加上 useDrag 和 useDrop："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function Card(props: CardProps) {\n    const { data } = props;\n\n    const ref = useRef(null);\n\n    const [, drag] = useDrag({\n        type: 'card',\n        item: props.data\n    });\n    const [, drop] = useDrop({\n        accept: 'card',\n        drop(item) {\n            console.log(item);\n        }\n    });\n\n    useEffect(() => {\n        drag(ref);\n        drop(ref);\n    }, []);\n\n    return <div ref={ref} className=\"card\">{data.content}</div>\n}\n\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"接下来做的很显然就是交换位置了。"}),"\n",(0,a.jsx)(e.p,{children:"我们实现一个交换位置的方法，传入 Card 组件，并且把当前的 index 也传入："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"const swapIndex = useCallback((index1: number, index2: number) => {\n    const tmp = cardList[index1];\n    cardList[index1] = cardList[index2];\n    cardList[index2] = tmp;\n    setCardList([...cardList]);\n}, [])\n"})}),"\n",(0,a.jsx)(e.p,{children:"这里 setState 时需要创建一个新的数组，才能触发渲染。"}),"\n",(0,a.jsx)(e.p,{children:"然后在 Card 组件里调用下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:f,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"增加 index 和 swapIndex 两个参数，声明 drag 传递的 item 数据的类型"}),"\n",(0,a.jsx)(e.p,{children:"在 drop 的时候互换 item.index 和当前 drop 的 index 的 Card"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"interface CardProps {\n    data: CardItem;\n    index: number;\n    swapIndex: Function;\n}\n\ninterface DragData {\n    id: number;\n    index: number;\n}\n\nfunction Card(props: CardProps) {\n    const { data, swapIndex, index } = props;\n\n    const ref = useRef(null);\n\n    const [, drag] = useDrag({\n        type: 'card',\n        item: {\n            id: data.id,\n            index: index\n        }\n    });\n    const [, drop] = useDrop({\n        accept: 'card',\n        drop(item: DragData) {\n            swapIndex(index, item.index)\n        }\n    });\n\n    useEffect(() => {\n        drag(ref);\n        drop(ref);\n    }, []);\n\n    return <div ref={ref} className=\"card\">{data.content}</div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这样就实现了拖拽排序。"}),"\n",(0,a.jsx)(e.p,{children:"不过因为背景是透明的，看着不是很明显。"}),"\n",(0,a.jsx)(e.p,{children:"我们设置个背景色："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"清晰多了。"}),"\n",(0,a.jsx)(e.p,{children:"但是现在是 drop 的时候才改变位置，如果希望在 hover 的时候就改变位置呢？"}),"\n",(0,a.jsx)(e.p,{children:"useDrop 有 hover 时的回调函数，我们把 drop 改成 hover就好了："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"但现在你会发现它一直在换："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"那是因为交换位置后，没有修改 item.index 为新的位置，导致交换逻辑一致触发："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"在 hover 时就改变顺序，体验好多了。"}),"\n",(0,a.jsx)(e.p,{children:"然后我们再处理下拖拽时的样式。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:s,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"样式如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".dragging {\n  border-style: dashed;\n  background: #fff; \n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"效果是这样的："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这样，拖拽排序就完成了。"}),"\n",(0,a.jsx)(e.p,{children:"我们对 react-dnd 的掌握又加深了一分。"}),"\n",(0,a.jsx)(e.p,{children:"这个案例的全部代码如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { useCallback, useEffect, useRef, useState } from \"react\";\nimport './App2.css';\nimport { useDrag, useDrop } from \"react-dnd\";\n\ninterface CardItem {\n    id: number;\n    content: string;\n}\n\ninterface CardProps {\n    data: CardItem;\n    index: number;\n    swapIndex: Function;\n}\n\ninterface DragData {\n    id: number;\n    index: number;\n}\n\nfunction Card(props: CardProps) {\n    const { data, swapIndex, index } = props;\n\n    const ref = useRef(null);\n\n    const [{ dragging }, drag] = useDrag({\n        type: 'card',\n        item: {\n            id: data.id,\n            index: index\n        },\n        collect(monitor) {\n            return {\n                dragging: monitor.isDragging()\n            }\n        }\n    });\n    const [, drop] = useDrop({\n        accept: 'card',\n        hover(item: DragData) {\n            swapIndex(index, item.index);\n            item.index = index;\n        }\n        // drop(item: DragData) {\n        //     swapIndex(index, item.index)\n        // }\n    });\n\n    useEffect(() => {\n        drag(ref);\n        drop(ref);\n    }, []);\n\n    return <div ref={ref} className={ dragging ? 'card dragging' : 'card'}>{data.content}</div>\n}\n\nfunction App() {\n    const [cardList, setCardList] = useState<CardItem[]>([\n        {\n            id:0,\n            content: '000',\n        },\n        {\n            id:1,\n            content: '111',\n        },\n        {\n            id:2,\n            content: '222',\n        },\n        {\n            id:3,\n            content: '333',\n        },\n        {\n            id:4,\n            content: '444',\n        }\n    ]);\n\n    const swapIndex = useCallback((index1: number, index2: number) => {\n        const tmp = cardList[index1];\n        cardList[index1] = cardList[index2];\n        cardList[index2] = tmp;\n\n        setCardList([...cardList]);\n    }, [])\n\n    return <div className=\"card-list\">\n        {\n            cardList.map((item: CardItem, index) => (\n                <Card data={item} key={'card_' + item.id} index={index} swapIndex={swapIndex}/>\n            ))\n        }\n    </div>\n}\n\nexport default App;\n"})}),"\n",(0,a.jsx)(e.p,{children:"css："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".card {\n  width: 200px;\n  line-height: 60px;\n  padding: 0 20px;\n  border: 1px solid #000;\n  background: skyblue;\n  margin: 10px;\n  cursor: move;\n}\n\n.dragging {\n  border-style: dashed;\n  background: #fff; \n}\n"})}),"\n",(0,a.jsxs)(e.p,{children:["案例代码上传了",(0,a.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/react-dnt-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,a.jsxs)(e.h2,{id:"总结",children:["总结",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"我们学了 react-dnd 并用它实现了拖拽排序。"}),"\n",(0,a.jsx)(e.p,{children:"react-dnd 主要就是 useDrag、useDrop、useDragLayout 这 3 个 API。"}),"\n",(0,a.jsx)(e.p,{children:"useDrag 是给元素添加拖拽，指定 item、type、collect 等参数。"}),"\n",(0,a.jsx)(e.p,{children:"useDrop 是给元素添加 drop，指定 accepet、drop、hover、collect 等参数。"}),"\n",(0,a.jsx)(e.p,{children:"useDragLayout 是自定义预览，可以通过 monitor 拿到拖拽的实时位置。"}),"\n",(0,a.jsx)(e.p,{children:"此外，最外层还要加上 DndProvider，用来组件之间传递数据。"}),"\n",(0,a.jsx)(e.p,{children:"其实各种拖拽功能的实现思路比较固定：什么元素可以拖拽，什么元素可以 drop，drop 或者 hover 的时候修改数据触发重新渲染就好了。"}),"\n",(0,a.jsx)(e.p,{children:"比如拖拽排序就是 hover 的时候互换两个 index 的对应的数据，然后 setState 触发渲染。"}),"\n",(0,a.jsx)(e.p,{children:"用 react-dnd，我们能实现各种基于拖拽的功能。"})]})}function O(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(K,{...n})}):K(n)}let T=O;O.__RSPRESS_PAGE_META={},O.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC51%E7%AB%A0%E2%80%94%E5%9F%BA%E4%BA%8Ereact-dnd%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第51章—基于react-dnd实现拖拽排序",headingTitle:"第51章—基于react-dnd实现拖拽排序",frontmatter:{}}}}]);