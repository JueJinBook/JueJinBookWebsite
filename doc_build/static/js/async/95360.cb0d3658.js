"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["95360"],{828586:function(e,i,s){s.r(i),s.d(i,{default:()=>r});var n=s(552676),t=s(740453);function l(e){let i=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2",ul:"ul",li:"li"},(0,t.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(i.h1,{id:"36源码-4风驰电掣--探索快速列表内部",children:["36源码 4：风驰电掣 —— 探索「快速列表」内部",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#36源码-4风驰电掣--探索快速列表内部",children:"#"})]}),"\n",(0,n.jsx)(i.p,{children:"Redis 早期版本存储 list 列表数据结构使用的是压缩列表 ziplist 和普通的双向链表 linkedlist，也就是元素少时用 ziplist，元素多时用 linkedlist。"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c",children:"// 链表的节点\nstruct listNode<T> {\n    listNode* prev;\n    listNode* next;\n    T value;\n}\n// 链表\nstruct list {\n    listNode *head;\n    listNode *tail;\n    long length;\n}\n"})}),"\n",(0,n.jsx)(i.p,{children:"考虑到链表的附加空间相对太高，prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。后续版本对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"> rpush codehole go java python\n(integer) 3\n> debug object codehole\nValue at:0x7fec2dc2bde0 refcount:1 encoding:quicklist serializedlength:31 lru:6101643 lru_seconds_idle:5 ql_nodes:1 ql_avg_node:3.00 ql_ziplist_max:-2 ql_compressed:0 ql_uncompressed_size:29\n"})}),"\n",(0,n.jsxs)(i.p,{children:["注意观察上面输出字段 encoding 的值。quicklist 是 ziplist 和 linkedlist 的混合体，它将 linkedlist 按段切分，每一段使用 ziplist 来紧凑存储，多个 ziplist 之间使用双向指针串接起来。\n",(0,n.jsx)(i.img,{src:"https://user-gold-cdn.xitu.io/2018/7/29/164e3b0b953f2fc7?w=1510&h=542&f=png&s=64217",alt:""})]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-c",children:"struct ziplist {\n    ...\n}\nstruct ziplist_compressed {\n    int32 size;\n    byte[] compressed_data;\n}\nstruct quicklistNode {\n    quicklistNode* prev;\n    quicklistNode* next;\n    ziplist* zl; // 指向压缩列表\n    int32 size; // ziplist 的字节总数\n    int16 count; // ziplist 中的元素数量\n    int2 encoding; // 存储形式 2bit，原生字节数组还是 LZF 压缩存储\n    ...\n}\nstruct quicklist {\n    quicklistNode* head;\n    quicklistNode* tail;\n    long count; // 元素总数\n    int nodes; // ziplist 节点的个数\n    int compressDepth; // LZF 算法压缩深度\n    ...\n}\n"})}),"\n",(0,n.jsx)(i.p,{children:"上述代码简单地表示了 quicklist 的大致结构。为了进一步节约空间，Redis 还会对 ziplist 进行压缩存储，使用 LZF 算法压缩，可以选择压缩深度。"}),"\n",(0,n.jsxs)(i.h2,{id:"每个-ziplist-存多少元素",children:["每个 ziplist 存多少元素？",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#每个-ziplist-存多少元素",children:"#"})]}),"\n",(0,n.jsxs)(i.p,{children:["quicklist 内部默认单个 ziplist 长度为 8k 字节，超出了这个字节数，就会新起一个 ziplist。ziplist 的长度由配置参数",(0,n.jsx)(i.code,{children:"list-max-ziplist-size"}),"决定。"]}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"# Lists are also encoded in a special way to save a lot of space.\n# The number of entries allowed per internal list node can be specified\n# as a fixed maximum size or a maximum number of elements.\n# For a fixed maximum size, use -5 through -1, meaning:\n# -5: max size: 64 Kb  <-- not recommended for normal workloads\n# -4: max size: 32 Kb  <-- not recommended\n# -3: max size: 16 Kb  <-- probably not recommended\n# -2: max size: 8 Kb   <-- good\n# -1: max size: 4 Kb   <-- good\n# Positive numbers mean store up to _exactly_ that number of elements\n# per list node.\n# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),\n# but if your use case is unique, adjust the settings as necessary.\nlist-max-ziplist-size -2\n"})}),"\n",(0,n.jsxs)(i.h2,{id:"压缩深度",children:["压缩深度",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#压缩深度",children:"#"})]}),"\n",(0,n.jsx)(i.p,{children:(0,n.jsx)(i.img,{src:"https://user-gold-cdn.xitu.io/2018/7/29/164e3d168aa62cc9?w=1348&h=532&f=png&s=73235",alt:""})}),"\n",(0,n.jsxs)(i.p,{children:["quicklist 默认的压缩深度是 0，也就是不压缩。压缩的实际深度由配置参数",(0,n.jsx)(i.code,{children:"list-compress-depth"}),"决定。为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。"]}),"\n",(0,n.jsxs)(i.h2,{id:"扩展阅读",children:["扩展阅读",(0,n.jsx)(i.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"})]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:(0,n.jsx)(i.a,{href:"https://matt.sh/redis-quicklist",target:"_blank",rel:"noopener noreferrer",children:"《ziplist、linkedlist 和 quicklist 的性能对比》"})}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:i}=Object.assign({},(0,t.ah)(),e.components);return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}let r=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F36%E6%BA%90%E7%A0%81%204%EF%BC%9A%E9%A3%8E%E9%A9%B0%E7%94%B5%E6%8E%A3%20%E2%80%94%E2%80%94%20%E6%8E%A2%E7%B4%A2%E3%80%8C%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8%E3%80%8D%E5%86%85%E9%83%A8.md"]={toc:[{text:"每个 ziplist 存多少元素？",id:"每个-ziplist-存多少元素",depth:2},{text:"压缩深度",id:"压缩深度",depth:2},{text:"扩展阅读",id:"扩展阅读",depth:2}],title:"36源码 4：风驰电掣 —— 探索「快速列表」内部",headingTitle:"36源码 4：风驰电掣 —— 探索「快速列表」内部",frontmatter:{}}}}]);