"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["27237"],{667709:function(e,n,r){r.r(n),r.d(n,{default:()=>u});var t=r(552676),a=r(740453);let s=r.p+"static/image/548bfd814efed907fa0fb891f33c90d9.ef22b25b.gif",c=r.p+"static/image/2df1737ff790ee950a9db62b6025e68c.ebfcbc01.gif",o=r.p+"static/image/7a1648076786dfee512c154b8c39d534.46f67b72.webp",i=r.p+"static/image/860537d9710f95568e3c180b98422870.82830036.webp",l=r.p+"static/image/e4a31da786240b36be7ac05ad7bf38c1.28fe4f4a.webp",d=r.p+"static/image/4cfd6a9350e14a137931d60f434a3365.6ef6f823.webp",p=r.p+"static/image/c9d0ce7e39df5521c42e7a4af911bd35.28fe4f4a.webp",h=r.p+"static/image/f0537ad343d3a1e5c03f188477857c7d.5c2b3221.webp",m=r.p+"static/image/a9cd7289ab712d20cf1c8c301a7b8846.a957dabf.webp",j=r.p+"static/image/7d2ab9267b4453967a334e822836d070.069d03a4.gif";function x(e){let n=Object.assign({h2:"h2",a:"a",p:"p",img:"img",code:"code",pre:"pre",blockquote:"blockquote",ol:"ol",li:"li"},(0,a.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309115864737611827",target:"_blank",rel:"noopener noreferrer",children:"《 源码篇 | RSC 实现原理》"}),"中，我们优化了 React RSC 的实现，最终的效果如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:"react-rsc-12.gif"})}),"\n",(0,t.jsx)(n.p,{children:"导航的时候，其实获取的是目标页面的 JSX 对象，但在 Next.js 中，返回的其实是针对流进行过优化的特殊格式，我们称之为 RSC Payload，效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:"截屏2024-04-16 15.49.37.png"})}),"\n",(0,t.jsxs)(n.p,{children:["此外 Next.js 也支持 ",(0,t.jsx)(n.code,{children:"<Suspense>"})," 组件："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import { Suspense } from 'react'\n\nconst sleep = ms => new Promise(r => setTimeout(r, ms));\n\nasync function PostFeed() {\n  await sleep(2000)\n  return <h1>Hello PostFeed</h1>\n}\n\nexport default function Dashboard() {\n  return (\n    <section>\n      <Suspense fallback={<p>Loading PostFeed Component</p>}>\n        <PostFeed />\n      </Suspense>\n    </section>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"但目前我们的实现并不支持 Suspense 组件，因为我们使用自定义的 renderJSXToClientJSX 获取页面 JSX 对象时，并不支持识别 Suspense 组件。"}),"\n",(0,t.jsxs)(n.p,{children:["本篇我们会在",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309115864737611827",target:"_blank",rel:"noopener noreferrer",children:"《 源码篇 | RSC 实现原理》"}),"的实现基础上，实现 Streaming 并且支持 ",(0,t.jsx)(n.code,{children:"<Suspense>"})," 组件。如果没有实现之前的代码，可以运行："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"# 68.源码篇 _ 实现 Streaming\ngit clone -b react-rsc-9 git@github.com:mqyqingfeng/next-app-demo.git\n# 进入目录并安装依赖项\ncd next-app-demo && npm i\n# 启动\nnpm start\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"实现思路",children:["实现思路",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现思路",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"该如何实现 Streaming 效果呢？"}),"\n",(0,t.jsxs)(n.p,{children:["其实 React 提供了 ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/react-server-dom-webpack?activeTab=readme",target:"_blank",rel:"noopener noreferrer",children:"react-server-dom-webpack"})," 用于处理 RSC，尽管它现在都没有正式的介绍，查看 ",(0,t.jsx)(n.a,{href:"https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack",target:"_blank",rel:"noopener noreferrer",children:"GitHub 仓库"}),"，也只有简短的说明："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"其中 Flight 是 RSC 的代号，简单来说，就是该功能还在实验中，使用 Webpack 用于 RSC DOM 绑定，可以自己玩着玩，但不能用于生产……"}),"\n",(0,t.jsxs)(n.p,{children:["虽然介绍很少，但在 ",(0,t.jsx)(n.a,{href:"https://github.com/facebook/react/blob/734956ace6450bc0c95d8d749dee74f4a140597b/fixtures/flight/src/index.js#L4",target:"_blank",rel:"noopener noreferrer",children:"React Flight"})," 以及 ",(0,t.jsx)(n.a,{href:"https://github.com/reactjs/server-components-demo/blob/main/server/api.server.js",target:"_blank",rel:"noopener noreferrer",children:"server-components-demo"})," 都可以看到它的身影。而我们今天的实现也要用到 react-server-dom-webpack，所以我们先介绍一下它的基本用法（以下都是我摸索出来的，最终用法还尚未确定）。"]}),"\n",(0,t.jsx)(n.p,{children:"当在服务端使用的时候："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { renderToPipeableStream } from "react-server-dom-webpack/server.node"\n\napp.get("/", async (req, res) => {\n  const { pipe } = renderToPipeableStream(<App />);\n  pipe(res);\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"它会将组件渲染成下图这种流格式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"而在客户端使用的时候，如果是在浏览器环境："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { createFromFetch } from \"react-server-dom-webpack/client\"\n\nlet data = createFromFetch(\n  fetch(currentPathname + '?jsx')\n)\n"})}),"\n",(0,t.jsx)(n.p,{children:"data 是一个包含页面 JSX 对象的 Promise，你可以这样读取其中的值："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"data.then((jsx) => {\n  hydrateRoot(document, jsx)\n})\n"})}),"\n",(0,t.jsxs)(n.p,{children:["但为了优雅一点，可以结合 React 的 ",(0,t.jsx)(n.a,{href:"https://react.dev/reference/react/use#",target:"_blank",rel:"noopener noreferrer",children:"use hook"})," 来使用："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function Shell({ data }) {\n  const [root, setRoot] = useState(use(data))\n  return root\n}\n\nhydrateRoot(document, React.createElement(Shell, { data }))\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里我们构建了一个空壳 Shell 组件，并将 JSX 对象设置为状态，这样当调用 setRoot 的时候，页面内容就会更新。"}),"\n",(0,t.jsx)(n.p,{children:"如果是在 Node 环境（就比如 SSR Server）："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { createFromNodeStream } from "react-server-dom-webpack/client"\n\nconst root = await createFromNodeStream(stream, {})\n'})}),"\n",(0,t.jsxs)(n.p,{children:["root 最终是页面的 JSX 对象。因为是流，可以结合 react-dom/server 的 ",(0,t.jsx)(n.a,{href:"https://react.dev/reference/react-dom/server/renderToPipeableStream",target:"_blank",rel:"noopener noreferrer",children:"renderToPipeableStream"})," 来使用："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'app.get("/", async (req, res) => {\n  const { pipe } = renderToPipeableStream(root)\n  pipe(res)\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"让我们再回顾下之前的实现方案："}),"\n",(0,t.jsxs)(n.p,{children:["页面首次加载时，RSC Server 负责生成页面的 JSX 对象，SSR Server 负责生成 HTML，页面 client.js 调用 ",(0,t.jsx)(n.code,{children:"hydrateRoot(document, getInitialClientJSX())"}),"水合页面。在后续导航时，获取目标页面的 JSX 对象，调用 ",(0,t.jsx)(n.code,{children:"root.render(clientJSX)"})," 进行更新。"]}),"\n",(0,t.jsx)(n.p,{children:"但是鉴于 react-server-dom-webpack 的特殊使用方式，新的实现方案为："}),"\n",(0,t.jsxs)(n.p,{children:["页面首次加载时，RSC Server 负责生成页面的 RSC Payload，SSR Server 负责生成 HTML，页面 client.js 调用",(0,t.jsx)(n.code,{children:"createFromFetch()"}),"获取页面 JSX 对象，调用 ",(0,t.jsx)(n.code,{children:"hydrateRoot(document, jsx)"}),"水合页面。在后续导航时，依然用 createFromFetch 获取目标页面 JSX 对象，借助空壳 Shell 组件的更新状态函数，实现页面更新。"]}),"\n",(0,t.jsx)(n.p,{children:"其核心代码实现是："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// fetch 返回的是页面的 RSC Payload，createFromFetch 返回的是包含页面 JSX 对象的 Promise\nlet data = createFromFetch(fetch(currentPathname + '?jsx'))\n\nlet updateRoot\n\nfunction Shell({ data }) {\n  // 使用 use(data) 读取页面 JSX 对象\n  const [root, setRoot] = useState(use(data))\n  updateRoot = setRoot\n  return root\n}\n\n// 首次加载的时候使用页面的 JSX 对象水合页面\nhydrateRoot(document, React.createElement(Shell, { data }))\n\n// 后续导航时更新状态\nasync function navigate(pathname) {\n  const root = await createFromFetch(fetch(pathname + '?jsx'))\n  updateRoot(root)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"如果你还不理解，没有关系，我们边写边理解吧！"}),"\n",(0,t.jsxs)(n.h2,{id:"step1实现-rsc-payload",children:["Step1：实现 RSC Payload",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step1实现-rsc-payload",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["首先安装依赖，为了保持与 React、React DOM 与 react-server-dom-webpack 版本一致，我们统一使用 ",(0,t.jsx)(n.code,{children:"18.3.0-canary-c3048aab4-20240326"})," 这个版本："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"npm i react@18.3.0-canary-c3048aab4-20240326 react-dom@18.3.0-canary-c3048aab4-20240326 react-server-dom-webpack@18.3.0-canary-c3048aab4-20240326\n"})}),"\n",(0,t.jsxs)(n.p,{children:["注：为什么使用这个版本呢？翻看 react-server-dom-webpack npm 的",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/react-server-dom-webpack?activeTab=versions",target:"_blank",rel:"noopener noreferrer",children:"版本记录"}),"，这是 18.3.0 版本最新的一版。下一版本就是 19.0.0 了，鉴于 React 的最新版本才 18.2.0，我们继续使用 v18。"]}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"generator.tsx"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { renderToPipeableStream } from "react-server-dom-webpack/server.node"\n\n// 注意是普通函数，而非 async 函数\nexport function jsxGenerator(url) {\n  return renderToPipeableStream(<Router url={url} />)\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"server/rsc.ts"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'app.get("/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n  const { pipe } = jsxGenerator(url);\n  pipe(res)\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"此时我们就完成了 RSC 组件的流式渲染。但命令行会出现报错："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["这是因为 React Server Components 需要 ",(0,t.jsx)(n.code,{children:"react-server"})," condition（关于 condition，参考 ",(0,t.jsx)(n.a,{href:"https://nodejs.org/api/cli.html#-c-condition---conditionscondition",target:"_blank",rel:"noopener noreferrer",children:"Node 官方文档"}),"）。"]}),"\n",(0,t.jsxs)(n.p,{children:["我们修改 ",(0,t.jsx)(n.code,{children:"package.json"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'{\n  "scripts": {\n    "start": "concurrently \\"npm run start:ssr\\" \\"npm run start:rsc\\"",\n    "start:rsc": "tsx watch --conditions=react-server ./server/rsc.ts",\n    "start:ssr": "tsx watch ./server/ssr.ts"\n  }\n}\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["运行 ",(0,t.jsx)(n.code,{children:"npm start"}),"，你会发现此时还是有报错，页面也是空白。但是没有关系，我们慢慢解决，访问 ",(0,t.jsx)(n.a,{href:"http://localhost:3001/hello",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3001/hello"}),"，也就是直接访问 RSC 服务，效果如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"借助 react-server-dom-webpack，我们已经将 React Server Component 渲染成流的格式，但是 SSR Server 和客户端还不能做正确的解析，所以出现了错误。"}),"\n",(0,t.jsxs)(n.h2,{id:"step2服务端解析-rsc-payload",children:["Step2：服务端解析 RSC Payload",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step2服务端解析-rsc-payload",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"SSR Server 该如何解析返回的 RSC Payload 呢？"}),"\n",(0,t.jsxs)(n.p,{children:["其实在实现思路一节已经讲过了，借助 createFromNodeStream 和 renderToPipeableStream。首先安装 ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/node-fetch",target:"_blank",rel:"noopener noreferrer",children:"node-fetch"})," 这个包："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"npm i node-fetch\n"})}),"\n",(0,t.jsx)(n.p,{children:"这是因为我们使用的毕竟是 react-server-dom-webpack 的 createFromNodeStream，既然是 NodeStream，自然是要用 Node 的 Stream。"}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"server/ssr.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import express from "express";\nimport { readFile } from "fs/promises";\nimport fetch from \'node-fetch\';\nimport { renderToPipeableStream } from "react-dom/server"\nimport { createFromNodeStream } from "react-server-dom-webpack/client"\n\nconst app = express();\n\napp.get("/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n\n  // client.js\n  if (url.pathname === "/client.js") {\n    const content = await readFile("./client.js", "utf8");\n    res.setHeader("Content-Type", "text/javascript");\n    res.end(content);\n    return;\n  }\n\n  const response = await fetch("http://127.0.0.1:3001" + url.pathname);\n\n  if (!response.ok) {\n    res.statusCode = response.status;\n    res.end();\n    return;\n  }\n  const stream = response.body;\n\n  // 获取客户端 JSX 对象\n  if (url.searchParams.has("jsx")) {\n    res.set("Content-type", "text/x-component")\n    stream.on("data", (data) => {\n      res.write(data)\n    })\n    stream.on("end", (data) => {\n      res.end()\n    })\n  }\n  // 获取 HTML\n  else {\n    const root = await createFromNodeStream(stream, {})\n    res.set("Content-type", "text/html")\n    const { pipe } = renderToPipeableStream(root)\n    pipe(res)\n  }\n});\n\napp.listen(3000, (err) => {\n  if (err) return console.error(err);\n  return console.log(`Server is listening on 3000`);\n});\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"fetch 的 response.body 会返回一个 Stream，createFromNodeStream 传入的便是这个 Steam，最终返回的 root 是页面的 JSX 对象，我们有调用了 renderToPipeableStream 将其渲染为流式 HTML。"}),"\n",(0,t.jsxs)(n.p,{children:["此时访问 ",(0,t.jsx)(n.a,{href:"http://localhost:3000/",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3000/"}),"，页面已经可以正常渲染："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["尽管页面正常渲染，但注意这里，页面的请求数量只有 3 个，没有 ",(0,t.jsx)(n.code,{children:"client.js"}),"，也没有 react 相关的 JS。"]}),"\n",(0,t.jsx)(n.p,{children:"这是因为以前我们是在将 clientJSX 渲染成 HTML 后再拼接的 HTML，但是这里我们直接返回了渲染结果，所以没有机会写入 client.js。"}),"\n",(0,t.jsxs)(n.p,{children:["此外，访问 ",(0,t.jsx)(n.a,{href:"http://localhost:3000/?jsx",target:"_blank",rel:"noopener noreferrer",children:"http://localhost:3000/?jsx"}),"，效果如下："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["你可以发现，无论是 ",(0,t.jsx)(n.code,{children:"/"}),"的 Transfer-Encoding 响应头还是 ",(0,t.jsx)(n.code,{children:"/?jsx"})," 的 Transfer-Encoding 响应头都是 chunked。这说明 HTML 和 RSC Payload 都已经实现了 Streaming。"]}),"\n",(0,t.jsxs)(n.h2,{id:"step3客户端解析-rsc-payload",children:["Step3：客户端解析 RSC Payload",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#step3客户端解析-rsc-payload",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"回到刚才的问题，如何引入 client.js 呢？"}),"\n",(0,t.jsxs)(n.p,{children:["我们可以改为在 components.tsx 的 ",(0,t.jsx)(n.code,{children:"<Layout>"}),"中引入，修改 ",(0,t.jsx)(n.code,{children:"components.tsx"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const importMap = `{\n  "imports": {\n    "react": "https://esm.sh/react@18.3.0-canary-c3048aab4-20240326?dev",\n        "react-dom/client": "https://esm.sh/react-dom@18.3.0-canary-c3048aab4-20240326/client?dev",\n        "react-server-dom-webpack": "https://esm.sh/react-server-dom-webpack@18.3.0-canary-c3048aab4-20240326/client?dev"\n  }\n}`\n\nexport function Layout({ children }) {\n  const author = "YaYu";\n  return (\n    <html>\n    <head>\n      <title>My blog</title>\n      <script src="https://cdn.tailwindcss.com"><\/script>\n      <script dangerouslySetInnerHTML={{ __html: `window.__webpack_require__ = async (id) => {\n          return import(id)\n        }` }}>\n      <\/script>\n      <script\n          type="importmap"\n          dangerouslySetInnerHTML={{ __html: importMap }}\n      ><\/script>\n      <script type="module" src="/client.js"><\/script>\n    </head>\n    <body className="p-5">\n      <nav className="flex items-center justify-center gap-10 text-blue-600">\n        <a href="/">Home</a>\n      </nav>\n      <input required className="block w-full rounded-md border-0 px-1.5 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6" />\n      <main>{children}</main>\n      <Footer author={author} />\n    </body>\n  </html>\n  );\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"client.js"}),"，完整代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import * as React from "react"\nimport { use, useState, startTransition } from "react"\nimport { createFromFetch } from "react-server-dom-webpack"\nimport { hydrateRoot } from \'react-dom/client\';\n\n// 客户端路由缓存\nlet clientJSXCache = {}\nlet currentPathname = window.location.pathname\nlet updateRoot\n\nfunction Shell({ data }) {\n  console.log("Shell", data)\n  const [root, setRoot] = useState(use(data))\n  clientJSXCache[currentPathname] = root\n  updateRoot = setRoot\n  return root\n}\n\nlet data = createFromFetch(\n  fetch(currentPathname + \'?jsx\')\n)\n\nhydrateRoot(document, React.createElement(Shell, { data }))\n\nasync function navigate(pathname) {\n  currentPathname = pathname;\n  if (clientJSXCache[pathname]) {\n    updateRoot(clientJSXCache[pathname])\n    return\n  } else {\n    const response = fetch(pathname + \'?jsx\')\n    const root = await createFromFetch(response)\n    clientJSXCache[pathname] = root\n    startTransition(() => {\n      updateRoot(root)\n    })\n  }\n}\n\nwindow.addEventListener("click", (e) => {\n  // 忽略非 <a> 标签点击事件\n  if (e.target.tagName !== "A") {\n    return;\n  }\n  // 忽略 "open in a new tab".\n  if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {\n    return;\n  }\n  // 忽略外部链接\n  const href = e.target.getAttribute("href");\n  if (!href.startsWith("/")) {\n    return;\n  }\n  // 组件浏览器重新加载页面\n  e.preventDefault();\n  // 但是 URL 还是要更新\n  window.history.pushState(null, null, href);\n  // 调用我们自己的导航逻辑\n  navigate(href);\n}, true);\n\nwindow.addEventListener("popstate", () => {\n  // 处理浏览器前进后退事件\n  navigate(window.location.pathname);\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"此时页面已经可以正常运行："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"react-rsc-13.gif"})}),"\n",(0,t.jsxs)(n.p,{children:["现在 Suspense 组件也能正常使用了，修改 ",(0,t.jsx)(n.code,{children:"components.tsx"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import React, { Suspense } from \'react\';\nconst sleep = ms => new Promise(r => setTimeout(r, ms));\n\nexport async function IndexPage() {\n  const files = await readdir("./posts");\n  const slugs = files.map((file) =>\n    file.slice(0, file.lastIndexOf("."))\n  );\n\n  return (\n    <section>\n      <h1>Blog List:</h1>\n      <div>\n        {slugs.map((slug, index) => (\n          <Suspense key={index} fallback={<p>Loading Post...</p>}>\n            <Post slug={slug} />\n          </Suspense>\n        ))}\n      </div>\n    </section>\n  );\n}\n\nexport function PostPage({ slug }) {\n  return (\n    <Suspense fallback={<p>Loading Post...</p>}>\n      <Post slug={slug} />\n    </Suspense>\n  );\n}\n\nasync function Post({ slug }) {\n  let content = await readFile("./posts/" + slug + ".txt", "utf8");\n  await sleep(2000)\n  return (\n    <section>\n      <a className="text-blue-600" href={"/" + slug}>{slug}</a>\n      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{content}</article>\n    </section>\n  )\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"为了让效果明显，我们为 Post 组件添加了 2s 的延时，并在 IndexPage 和 PostPage 中使用了 Suspense。"}),"\n",(0,t.jsx)(n.p,{children:"最终的交互效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:"react-rsc-14.gif"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"功能实现：Streaming 与 Suspense"}),"\n",(0,t.jsxs)(n.li,{children:["源码地址：",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-10",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-10"})]}),"\n",(0,t.jsxs)(n.li,{children:["下载代码：",(0,t.jsx)(n.code,{children:"git clone -b react-rsc-10 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://timtech.blog/posts/react-server-components-rsc-no-framework/",target:"_blank",rel:"noopener noreferrer",children:"https://timtech.blog/posts/react-server-components-rsc-no-framework/"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://react.dev/reference/react-dom/server/renderToPipeableStream",target:"_blank",rel:"noopener noreferrer",children:"https://react.dev/reference/react-dom/server/renderToPipeableStream"})}),"\n"]})]})}function g(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}let u=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F68.%E6%BA%90%E7%A0%81%E7%AF%87%20_%20%E5%AE%9E%E7%8E%B0%20Streaming.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"实现思路",id:"实现思路",depth:2},{text:"Step1：实现 RSC Payload",id:"step1实现-rsc-payload",depth:2},{text:"Step2：服务端解析 RSC Payload",id:"step2服务端解析-rsc-payload",depth:2},{text:"Step3：客户端解析 RSC Payload",id:"step3客户端解析-rsc-payload",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);