"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11339"],{612705:function(n,e,a){n.exports=a.p+"static/image/c2722cc0ab951b1c275ca87d658571ac.967cac4b.png"},197823:function(n,e,a){a.r(e),a.d(e,{default:()=>P});var r=a(552676),t=a(740453);let o=a.p+"static/image/880cadf9c838a0669b21a7df8f70ec09.8b369bf2.png",s=a.p+"static/image/18a77a4d20bece5a5734801830b8225f.6b66b12a.png";var i=a(612705);let p=a.p+"static/image/a72dbaf74f50c4ab41a3acbbbd030a65.84e3a9ce.png",l=a.p+"static/image/410d3fa5b2c532da582aebc84b33bff7.22e6a65c.png",c=a.p+"static/image/67b2b3bad89f2c5bedb138735090d036.84b66fcb.png",d=a.p+"static/image/a2af5fdb4ff994edc213762d29c2bd05.188592ec.png",h=a.p+"static/image/6ff6df463595641963e4923b9c99454e.8d7eb445.png",u=a.p+"static/image/a2aae36a0791b70039fff843afb8e1a9.42f8bf11.png",m=a.p+"static/image/704e3c49fb40965776e3cd1c5d5db458.566d0ec2.png",g=a.p+"static/image/47ba23358ee4a85ab15c97c7ce5805d3.37f2618d.png",f=a.p+"static/image/a7a7f4c8e093a675f9ab95d6faf8ef8e.68ecbae1.png",x=a.p+"static/image/b07fa10888e61f879ee399e935399f63.ba173ccb.png";function j(n){let e=Object.assign({p:"p",blockquote:"blockquote",h1:"h1",a:"a",img:"img",code:"code",strong:"strong",ul:"ul",li:"li",h2:"h2",h3:"h3",pre:"pre",h4:"h4"},(0,t.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:"在之前的四个课程中，我们重点讲解了如何使用 single-spa 设计微前端，这使得大家对于 single-spa 有了感性认知，本课程接下来重点讲解 single-spa 的内部运行原理，为了解 qiankun 的使用和内部运行原理奠定基础。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：为了防止源码解析偏差，本课程讲解的 single-spa 源码基于 5.9.5 版本。"}),"\n"]}),"\n",(0,r.jsxs)(e.h1,{id:"23框架解析single-spa-源码解析",children:["23.框架解析：single-spa 源码解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#23框架解析single-spa-源码解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在使用 qiankun 或者 single-spa 的过程中，大家经常会遇到微前端框架无法正常加载微应用的情况，在这种情况下框架通常会给出错误提示，例如微应用没有导出生命周期函数：\n",(0,r.jsx)("img",{src:x,alt:"image.png"}),"\nsingle-spa 会给出 ",(0,r.jsx)(e.code,{children:"application ${appName} died in status ${status}：${errorMessage}"})," 错误提示，当然上述错误示例相对简单，而有些信息看起来比较隐晦，很难一眼看出微应用无法加载的根本原因。为此，我们可以了解微应用框架的内部运行机制，帮助我们快速进行问题排查。"]}),"\n",(0,r.jsx)(e.p,{children:"除此之外，了解框架源码也会使我们在使用框架时更加得心应手，可以更好的结合 Vue 或者 React 框架的路由来实现微应用的切换，例如：single-spa 如何感知 Vue 或者 React 框架路由的变化从而切换微应用？它是如何保证框架路由的代码执行完毕后再执行微应用的加载和卸载？接下来我们以上一个课程的 Fetch 示例来重点讲解 single-spa 的内部运行原理。"}),"\n",(0,r.jsxs)(e.h1,{id:"阅读建议",children:["阅读建议",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#阅读建议",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["single-spa 的源码解析主要分为三个部分：",(0,r.jsx)(e.strong,{children:"源码剖析"}),"、",(0,r.jsx)(e.strong,{children:"场景剖析"}),"、",(0,r.jsx)(e.strong,{children:"状态和事件剖析"}),"。如果你觉得源码剖析太枯燥，可以先大致扫一下 single-spa 有哪些函数，这些函数的作用是什么。然后在场景剖析中详细了解这些函数的执行流程，有了完整的执行流程概念后，如果还想深入了解内部的运行机制，可以重新回来阅读源码剖析中的代码注释。"]}),"\n",(0,r.jsxs)(e.h1,{id:"源码剖析",children:["源码剖析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#源码剖析",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"整个 single-spa 源码可以被分为几个主要部分，如下所示："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"applications"}),"：注册微应用并解析微应用的注册参数"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"start"}),"：启动微应用的生命周期函数执行"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"navigation"}),"：处理导航事件、根据导航变化计算和执行微应用的变化"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"lifecycles"}),"：异步执行微应用的生命周期函数以及相应的错误处理"]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：源码解析不包含 single-spa 的 ",(0,r.jsx)(e.code,{children:"parcels"})," 部分，感兴趣的同学需要自行了解。示例源码可以从 micro-framework 的\xa0",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/analyze/single-spa",target:"_blank",rel:"noopener noreferrer",children:"analyze/single-spa"}),"\xa0分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"applications-解析",children:[(0,r.jsx)(e.code,{children:"applications"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#applications-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"registerapplication-入参解析",children:[(0,r.jsx)(e.code,{children:"registerApplication"})," 入参解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#registerapplication-入参解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"registerApplication"})," 是 single-spa 对外提供的注册 API，它可以通过对象或者函数两种方式进行调用，在主应用中的使用如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// single-spa-config.js  \n// 引入 single-spa 的 NPM 库包\nimport { registerApplication, start } from 'single-spa';  \n  \n// 函数调用方式，需要提供四个参数\nregisterApplication(  \n  // 参数 1：微应用名称标识\n  'app2',  \n  // 参数 2：微应用加载逻辑 / 微应用对象，必须返回 Promise\n  () => import('src/app2/main.js'),  \n  // 参数 3：微应用的激活条件\n  (location) => location.pathname.startsWith('/app2'),  \n  // 参数 4：传递给微应用的 props 数据\n  { some: 'value' }  \n);  \n  \n// 对象调用方式，只需要一个对象参数\n// 更加清晰，易于阅读和维护，无须记住参数的顺序\nregisterApplication({  \n  // name 参数\n  name: 'app1',  \n  // app 参数，必须返回 Promise\n  app: () => import('src/app1/main.js'),  \n  // activeWhen 参数\n  activeWhen: '/app1',  \n  // customProps 参数\n  customProps: {  \n    some: 'value',  \n  }  \n});  \n"})}),"\n",(0,r.jsxs)(e.p,{children:["在使用库包 API 时可以通过 signle-spa 对外提供的 TypeScript 声明进行参数的自动提示，这里可以查看 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/typings/single-spa.d.ts#L163",target:"_blank",rel:"noopener noreferrer",children:"typings/single-spa.d.ts"})," 的 ",(0,r.jsx)(e.code,{children:"registerApplication"})," 参数声明："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// typings/single-spa.d.ts\n\n// 函数调用方式，需要提供四个参数\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n    // 参数 1：微应用名称标识\n    appName: string,\n    // 参数 2：微应用加载逻辑 / 微应用对象\n    applicationOrLoadingFn: Application<ExtraProps>,\n    // 参数 3：微应用的激活条件\n    activityFn: ActivityFn,\n    // 参数 4：传递给微应用的 props 数据\n    // 由于外部可以传入自定义数据，因此需要一个泛型可以让外部对该参数进行自定义声明\n    customProps?: ExtraProps | CustomPropsFn<ExtraProps>\n): void;\n\n// 对象调用方式，只需要一个对象参数\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n    config: RegisterApplicationConfig<ExtraProps>\n): void;\n\n// 对象调用方式的参数声明\nexport type RegisterApplicationConfig<ExtraProps extends CustomProps = {}> = {\n  // 参数 1：微应用名称标识\n  name: string;\n  // 参数 2：微应用加载逻辑 / 微应用对象\n  app: Application<ExtraProps>;\n  // 参数 3：微应用的激活条件\n  activeWhen: Activity;\n  // 参数 4：传递给微应用的 props 数据\n  customProps?: ExtraProps | CustomPropsFn<ExtraProps>;\n};\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：从上述函数调用方式和对象调用方式可以发现参数 3 的声明存在差异，在函数调用中声明的是 ",(0,r.jsx)(e.code,{children:"ActivityFn（函数方式）"}),"，而在对象调用方式中则是 ",(0,r.jsx)(e.code,{children:"Activity"}),"，而其余参数声明相同。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"参数-2",children:["参数 2",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参数-2",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["参数 2 主要是在首次激活微应用时获取微应用的生命周期函数。我们来看下参数 2\xa0声明的 ",(0,r.jsx)(e.code,{children:"Application<ExtraProps>"}),"，从下述代码可以发现参数 2 可以是一个微应用生命周期对象 ",(0,r.jsx)(e.code,{children:"LifeCycles<ExtraProps>"}),"，也可以是一个返回 ",(0,r.jsx)(e.code,{children:"Promise<LifeCycles<ExtraProps>>"})," 的函数，其中 ",(0,r.jsx)(e.code,{children:"LifeCycles<ExtraProps>"})," 必须包含\xa0",(0,r.jsx)(e.code,{children:"boostrap"}),"、",(0,r.jsx)(e.code,{children:"mount"}),"\xa0和\xa0",(0,r.jsx)(e.code,{children:"unmount"}),"\xa0等属性，这些属性的值 ",(0,r.jsx)(e.code,{children:"LifeCycleFn<ExtraProps>"})," 也必须是\xa0",(0,r.jsx)(e.code,{children:"async"}),"\xa0函数。如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 参数 2 app 的详细声明\ntype Application<ExtraProps = {}> =\n  // 可以是 LifeCycles<ExtraProps>\n  // 这里先忽略 <ExtraProps>，会在参数 4 中进行讲解\n  | LifeCycles<ExtraProps>\n  // 也可以是一个返回了 LifeCycles<ExtraProps> 的 async 函数（注意需要返回 Promise）\n  | ((config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>>);\n  \n// LifeCycles<ExtraProps> 声明的是一个对象，\n// 包含了微应用的生命周期\nexport type LifeCycles<ExtraProps = {}> = {\n  // 这里可以是一个 LifeCycleFn<ExtraProps>，\n  // 也可以是一个内含 LifeCycleFn<ExtraProps> 的数组\n  bootstrap: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  mount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  unmount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  // update 和 Parcel 息息相关，\n  // 在 Application 中不会使用，这里可以先忽略\n  update?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n};\n\n// LifeCycleFn<ExtraProps> 是一个 async 函数（注意需要返回 Promise）\ntype LifeCycleFn<ExtraProps> = (\n  config: ExtraProps & AppProps\n) => Promise<any>;\n"})}),"\n",(0,r.jsx)(e.p,{children:"因此参数 2 可以是以下四种数据格式："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// LifeCycles<ExtraProps> 示例 1：对象形式\n{\n  // 每一个生命周期都是一个 async 函数\n  async bootstrap(props) {\n    console.log("app bootstraped");\n  },\n  async mount(props) {\n    console.log("app mounted");\n  },\n  async unmount(props) {\n    console.log("app unmounted");\n  }\n},\n\n// LifeCycles<ExtraProps> 示例 2：对象形式\n{\n  // 每一个生命周期都是内含 async 函数的数组\n  bootstrap: [\n    async (props) => {\n      console.log("app first bootstraped");\n    },\n    async (props) => {\n      console.log("app second bootstraped");\n    },\n  ],\n  mount: [\n    async (props) => {\n      console.log("app first mount");\n    },\n    async (props) => {\n      console.log("app second mount");\n    },\n  ],\n  unmount: [\n    async (props) => {\n      console.log("app first unmount");\n    },\n    async (props) => {\n      console.log("app second unmount");\n    },\n  ],\n};\n\n\n\n// ((config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>>) \n// 示例 1：函数形式\nasync (props) => {\n  return {\n    async bootstrap(props) {\n      console.log("app bootstraped");\n    },\n    async mount(props) {\n      console.log("app mounted");\n    },\n    async unmount(props) {\n      console.log("app unmounted");\n    }\n  };\n}\n\n// ((config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>>) \n// 示例 2：函数形式\nasync (props) => {\n  return {\n    // 每一个生命周期都是内含 async 函数的数组\n    bootstrap: [\n      async (props) => {\n        console.log("app first bootstraped");\n      },\n\n      async (props) => {\n        console.log("app second bootstraped");\n      },\n    ],\n    mount: [\n      async (props) => {\n        console.log("app first mount");\n      },\n\n      async (props) => {\n        console.log("app second mount");\n      },\n    ],\n    unmount: [\n      async (props) => {\n        console.log("app first unmount");\n      },\n\n      async (props) => {\n        console.log("app second unmount");\n      },\n    ],\n  }\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：在 qiankun 中使用了上述哪种数据格式呢？为什么要使用这种数据格式呢？"}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"参数-3",children:["参数 3",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参数-3",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"参数 3 会在应用初始化或者路由变化时触发执行，主要用于判断微应用的激活和失活。每一个微应用都需要声明自己的激活判断条件，参数 3\xa0的类型声明如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 函数调用方式\n// 必须是函数，可以获取 location 参数，而且必须返回 boolean 用于判断是否激活微应用\ntype ActivityFn = (location: Location) => boolean;\n\n// 对象调用方式\n// 可以是一个函数、字符串、或者函数和字符串两种联合类型的数组\ntype Activity = ActivityFn | string | (ActivityFn | string)[];\n"})}),"\n",(0,r.jsx)(e.p,{children:"参数 3 可以是以下几种格式："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 函数调用方式\n(location) => {\n  return location.pathname.startsWith('/react')\n}\n\n// 对象调用方式（字符串）\n\"/react\"\n\n// 对象调用方式（联合类型的数组）\n[\n  // 函数\n  (location) => {\n    return location.pathname.startsWith('/vue')\n  },\n  // 字符串\n  \"/vue\"\n]\n\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"参数-4",children:["参数 4",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参数-4",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"当微应用激活或者失活时都会执行相应的生命周期函数，此时在主应用中注册微应用时可以将主应用的信息通过参数 4 传递给微应用的生命周期函数。微应用在执行生命周期函数时可以通过参数的方式获取传递信息，从而实现和主应用的简单通信。我们来看下参数 4\xa0的类型声明："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 在外部使用 registerApplication 的时候可以定义参数 4 customProps 的接口类型\n// 这里使用了 ExtraProps 这个泛型来传递外部声明的接口\nexport function registerApplication<ExtraProps extends CustomProps = {}>(\n  // 参数 2 也会涉及到 customProps，因此这里需要传递泛型 ExtraProps\n  applicationOrLoadingFn: Application<ExtraProps>,\n  // 可以是对象，也可以是一个函数\n  customProps?: ExtraProps | CustomPropsFn<ExtraProps>\n): void;\n\n// 如果 customProps 是函数，那么必须返回外部声明的接口类型 ExtraProps\ntype CustomPropsFn<ExtraProps extends CustomProps = CustomProps> = (\n  name: string,\n  location: Location\n) => ExtraProps;\n\ntype Application<ExtraProps = {}> =\n  // 可以发现在参数 2 中需要返回的生命周期对象里传入了 customProps 对应的泛型 ExtraProps\n  | LifeCycles<ExtraProps>\n  | ((config: ExtraProps & AppProps) => Promise<LifeCycles<ExtraProps>>);\n\n// 这里继续传递  customProps 对应的泛型 ExtraProps\nexport type LifeCycles<ExtraProps = {}> = {\n  bootstrap: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  mount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  unmount: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n  update?: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>>;\n};\n\ntype LifeCycleFn<ExtraProps> = (\n  // 从这里可以发现每一个生命周期函数都可以获取 customProps 的数据\n  // customProps 会和 single-spa 内置的其他数据一起传递给生命周期函数\n  config: ExtraProps & AppProps\n) => Promise<any>;\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：在上述 TypeScript 声明中 ",(0,r.jsx)(e.code,{children:"ExtraProps"})," 是一个",(0,r.jsx)(e.a,{href:"https://www.tslang.cn/docs/handbook/generics.html",target:"_blank",rel:"noopener noreferrer",children:"泛型"}),"，如果你对泛型不了解，可以先查阅官网文档。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"可能上面这个声明看起来有点复杂，我们可以看下如何使用："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-typescript",children:'// 以下采用 typescript 语法\nimport { registerApplication, AppProps } from "single-spa";\n\ninterface ICustomProps {\n  hello: string;\n}\n\n// 使用 ICustomProps 代替通用类型（泛型）ExtraProps\nregisterApplication<ICustomProps>({\n  name: "vue",\n  app: { \n    // 在生命周期函数中可以通过 props 参数获取 customProps 的数据\n    // props 参数会包含 hello 属性\n    async bootstrap(props: ICustomProps & AppProps) {\n      console.log(props.hello); // 111\n      console.log("app bootstraped");\n    },\n    async mount(props) {\n      console.log("app mounted");\n    },\n    async unmount(props) {\n      console.log("app unmounted");\n    }\n  },\n  activeWhen: "/vue",\n  \n  // customProps 必须符合 ICustomProps 的接口声明\n  customProps: {\n    hello: "111", // ICustomProps 声明中有一个字符串类型的 hello 属性\n  },\n});\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"registerapplication-解析",children:[(0,r.jsx)(e.code,{children:"registerApplication"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#registerapplication-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["主应用在初始化时需要通过 ",(0,r.jsx)(e.code,{children:"registerApplication"})," 注册微应用，它的源码如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/applications/apps.js\n/**\n * @\n * @description 注册微应用\n * @export\n * @param appNameOrConfig 应用名称或者应用配置对象\n * @param appOrLoadApp  应用对象或者加载应用的函数，返回值是一个 Promise\n * @param activeWhen  一个函数或者字符串，用于判断应用是否激活\n * @param customProps 一个对象，用于传递自定义属性\n */\nexport function registerApplication(\n  appNameOrConfig,\n  appOrLoadApp,\n  activeWhen,\n  customProps\n) {\n  console.log(\n    "[applications/apps.js - registerApplication] registerApplication 函数开始执行， app: ",\n    appNameOrConfig\n  );\n\n  // 对注册应用的参数进行格式化\n  const registration = sanitizeArguments(\n    appNameOrConfig,\n    appOrLoadApp,\n    activeWhen,\n    customProps\n  );\n\n  // 如果已经注册了同名的应用，那么抛出异常\n  if (getAppNames().indexOf(registration.name) !== -1)\n    throw Error(\n      formatErrorMessage(\n        21,\n        __DEV__ &&\n          `There is already an app registered with name ${registration.name}`,\n        registration.name\n      )\n    );\n\n  // 将注册应用缓存到 apps 数组中\n  apps.push(\n    // Object.assign() 的兼容性处理\n    assign(\n      {\n        // 加载错误的时间\n        loadErrorTime: null,\n        // 应用的初始状态\n        status: NOT_LOADED,\n        parcels: {},\n        devtools: {\n          overlays: {\n            options: {},\n            selectors: [],\n          },\n        },\n      },\n      // 格式化后的注册应用参数\n      registration\n    )\n  );\n\n  if (isInBrowser) {\n    // 支持 jQuery 的路由事件监听\n    ensureJQuerySupport();\n    console.log(\n      "[applications/apps.js - registerApplication] 在 registerApplication 中准备执行 reroute 函数..."\n    );\n    reroute();\n  }\n}\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"sanitizearguments-解析",children:[(0,r.jsx)(e.code,{children:"sanitizeArguments"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#sanitizearguments-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["该函数主要对 ",(0,r.jsx)(e.code,{children:"registerApplication"})," 的四个入参进行格式化，从而为微应用的加载、路由匹配以及参数传递进行前置准备，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/applications/apps.js\n\n/**\n * @description 对注册应用的参数进行格式化\n * @param appNameOrConfig 应用名称或者应用配置对象\n * @param appOrLoadApp 应用对象或者加载应用的函数，返回值是一个 Promise\n * @param activeWhen 一个函数或者字符串，用于判断应用是否激活\n * @param customProps 一个对象，用于传递自定义属性\n * @returns {Object} 返回格式化后的注册应用参数，例如 { name: \'app1\', app: loadApp, activeWhen, customProps }\n */\nfunction sanitizeArguments(\n  appNameOrConfig,\n  appOrLoadApp,\n  activeWhen,\n  customProps\n) {\n  // registerApplication 的参数可以是两种形式：\n  // 1. 函数 API: single-spa.registerApplication(name, loadApp, activeWhen, customProps);\n  // 2. 对象 API: single-spa.registerApplication({ name: \'app1\', app: loadApp, activeWhen, customProps });\n\n  // 如果 appNameOrConfig 是一个对象，表示使用对象 API\n  const usingObjectAPI = typeof appNameOrConfig === "object";\n\n  const registration = {\n    name: null,\n    loadApp: null,\n    activeWhen: null,\n    customProps: null,\n  };\n\n  // 如果使用对象 API，那么 appNameOrConfig 就是一个对象\n  if (usingObjectAPI) {\n    // 对 registerApplication 的首个参数进行格式校验（其余三个参数不需要校验）\n    // 1. name 必须是字符串\n    // 2. app 必须是对象或者函数\n    // 3. activeWhen 必须是函数或者字符串\n    // 4. customProps 必须是对象\n    validateRegisterWithConfig(appNameOrConfig);\n    registration.name = appNameOrConfig.name;\n    registration.loadApp = appNameOrConfig.app;\n    registration.activeWhen = appNameOrConfig.activeWhen;\n    registration.customProps = appNameOrConfig.customProps;\n\n    // 如果使用函数 API，那么 appNameOrConfig 是一个字符串\n  } else {\n    // 对 registerApplication 的四个参数进行格式校验\n    validateRegisterWithArguments(\n      appNameOrConfig,\n      appOrLoadApp,\n      activeWhen,\n      customProps\n    );\n    registration.name = appNameOrConfig;\n    registration.loadApp = appOrLoadApp;\n    registration.activeWhen = activeWhen;\n    registration.customProps = customProps;\n  }\n\n  // 对注册应用的 loadApp 参数进行格式化，统一成返回 Promise 的函数\n  registration.loadApp = sanitizeLoadApp(registration.loadApp);\n  // 对注册应用的 customProps 参数进行格式化，如果没有传递，则默认为空对象\n  registration.customProps = sanitizeCustomProps(registration.customProps);\n  // 对注册应用的 activeWhen 参数进行格式化，统一成路由匹配函数\n  registration.activeWhen = sanitizeActiveWhen(registration.activeWhen);\n\n  return registration;\n}\n\n/**\n * @description 对注册应用的 loadApp 参数进行格式化，统一为一个返回 Promise 的函数\n * @param loadApp 应用对象或者加载应用的函数，返回值是一个 Promise\n * @returns {Function} 返回一个返回 Promise 的函数\n */\nfunction sanitizeLoadApp(loadApp) {\n  // 如果 loadApp 是一个对象，转化成返回 Promise 的函数\n  // 例如：{ bootstrap, mount, unmount } \n  // --\x3e () => Promise.resolve({ bootstrap, mount, unmount })\n  if (typeof loadApp !== "function") {\n    return () => Promise.resolve(loadApp);\n  }\n\n  // 如果 loadApp 是一个函数，直接返回 loadApp\n  return loadApp;\n}\n\n/**\n * @description 对注册应用的 customProps 参数进行格式化，如果没有传递，则默认为空对象\n * @param customProps 一个对象，用于传递自定义属性\n * @returns {Object} 返回格式化后的 customProps 参数\n */\nfunction sanitizeCustomProps(customProps) {\n  return customProps ? customProps : {};\n}\n\n/**\n * @description 对注册应用的 activeWhen 参数进行格式化，统一为路由匹配函数\n * @param activeWhen 一个函数或者字符串，用于判断应用是否激活\n * @returns {Function} 返回匹配路由的函数\n */\nfunction sanitizeActiveWhen(activeWhen) {\n  // 如果 activeWhen 不是数组，转化成数组\n  let activeWhenArray = Array.isArray(activeWhen) ? activeWhen : [activeWhen];\n  // 对 activeWhen 数组中的每一项进行格式化，统一为函数\n  activeWhenArray = activeWhenArray.map((activeWhenOrPath) =>\n    typeof activeWhenOrPath === "function"\n      ? activeWhenOrPath\n      : // 如果 activeWhenOrPath 是字符串，转化成函数\n        pathToActiveWhen(activeWhenOrPath)\n  );\n\n  return (location) =>\n    // 判断当前路由是否匹配 activeWhenArray 数组中的任意一项\n    activeWhenArray.some((activeWhen) => activeWhen(location));\n}\n\n/**\n * @description 对 path 进行格式化，统一为一个匹配路由的函数\n * @export\n * @param path 一个字符串，用于匹配路由\n * @param exactMatch 一个布尔值，用于判断是否精确匹配\n * @returns {Function} 返回匹配路由的函数\n */\nexport function pathToActiveWhen(path, exactMatch) {\n  // 根据 path 和 exactMatch 参数，动态组装需要匹配路由的正则表达式\n  const regex = toDynamicPathValidatorRegex(path, exactMatch);\n\n  return (location) => {\n    // compatible with IE10\n    let origin = location.origin;\n    if (!origin) {\n      origin = `${location.protocol}//${location.host}`;\n    }\n    // 判断当前路由是否匹配 path\n    // 1. location.href: http://localhost:8080/react/path/to/something?name=123#/home\n    // 2. location.origin: http://localhost:8080\n    // 3. location.search: ?name=123\n    // 4. location.hash: #/home\n    // 5. route: /react/path/to/something\n    const route = location.href\n      .replace(origin, "")\n      .replace(location.search, "")\n      .split("?")[0];\n    return regex.test(route);\n  };\n}\n\n/**\n * @description 根据 path 和 exactMatch 参数，动态组装需要匹配路由的正则表达式\n *\n * @example\n * toDynamicPathValidatorRegex("/react") => /^\\/react(\\/.*)?(#.*)?$/i\n *\n * 正则：\n * /^\\/react(\\/.*)?(#.*)?$/i\n *\n * 详细说明：\n * 1. ^：匹配输入的开始\n * 2. \\/react：匹配字符串 /react\n * 3. (\\/.*)?：匹配零次或一次以 / 开头的任意字符串\n * 4. (#.*)?：匹配零次或一次以 # 开头的任意字符串，例如 hash 路由\n * 5. $：匹配输入的结束\n * 6. i：不区分大小写\n *\n * 匹配示例：\n * 1. /react\n * 2. /react/path/to/something\n * 3. /react#hash\n * 4. /react/path/to/something#hash\n *\n * @example\n * toDynamicPathValidatorRegex("/react/:id") => /^\\/react\\/[^/]+\\/?/i\n *\n * 正则：\n * /^\\/react\\/[^/]+\\/?/i\n *\n * 详细说明：\n * 1. ^：匹配输入的开始\n * 2. \\/react\\/：匹配字符串 /react/\n * 3. [^/]+：匹配一次或多次不包含 / 的任意字符，可以匹配 /react/ 后面的一段路径\n * 4. \\/?：匹配零次或一次 /，可以匹配路径的结束 / 或者没有结束 /\n * 5. i：不区分大小写\n *\n * 匹配示例：\n * 1. /react/123\n * 2. /react/123/\n * 3. /react/123/path/to/something\n * 4. /react/123/path/to/something/\n * 5. /react/123#hash\n * 6. /react/123#hash/\n *\n * @param path 一个字符串，用于匹配路由\n * @param exactMatch 一个布尔值，用于判断是否精确匹配\n * @returns {RegExp} 返回匹配路由的正则表达式\n */\n\nfunction toDynamicPathValidatorRegex(path, exactMatch) {\n  let lastIndex = 0,\n    inDynamic = false,\n    regexStr = "^";\n\n  if (path[0] !== "/") {\n    path = "/" + path;\n  }\n\n  // 遍历 path，判断 path 中是否包含动态路由\n  for (let charIndex = 0; charIndex < path.length; charIndex++) {\n    const char = path[charIndex];\n    const startOfDynamic = !inDynamic && char === ":";\n    const endOfDynamic = inDynamic && char === "/";\n    if (startOfDynamic || endOfDynamic) {\n      // 如果 path 中包含动态路由，那么 inDynamic 为 true\n      appendToRegex(charIndex);\n    }\n  }\n\n  appendToRegex(path.length);\n  return new RegExp(regexStr, "i");\n\n  function appendToRegex(index) {\n    const anyCharMaybeTrailingSlashRegex = "[^/]+/?";\n    // escapeStrRegex 函数用于转义字符串中的特殊字符\n    const commonStringSubPath = escapeStrRegex(path.slice(lastIndex, index));\n\n    regexStr += inDynamic\n      ? anyCharMaybeTrailingSlashRegex\n      : commonStringSubPath;\n\n    if (index === path.length) {\n      if (inDynamic) {\n        if (exactMatch) {\n          // Ensure exact match paths that end in a dynamic portion don\'t match\n          // urls with characters after a slash after the dynamic portion.\n          regexStr += "$";\n        }\n      } else {\n        // For exact matches, expect no more characters. Otherwise, allow\n        // any characters.\n        const suffix = exactMatch ? "" : ".*";\n\n        regexStr =\n          // use charAt instead as we could not use es6 method endsWith\n          regexStr.charAt(regexStr.length - 1) === "/"\n            ? `${regexStr}${suffix}$`\n            : `${regexStr}(/${suffix})?(#.*)?$`;\n      }\n    }\n\n    inDynamic = !inDynamic;\n    lastIndex = index;\n  }\n\n  function escapeStrRegex(str) {\n    // borrowed from https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js\n    return str.replace(/[|\\\\{}()[\\]^$+*?.]/g, "\\\\$&");\n  }\n}\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"start-解析",children:[(0,r.jsx)(e.code,{children:"start"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#start-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在主应用中通过 ",(0,r.jsx)(e.code,{children:"registerApplication"})," 函数注册完所有的微应用后，会调用 ",(0,r.jsx)(e.code,{children:"start"})," 函数启动，启动后微应用的生命周期函数才会被 single-spa 执行，而在启动之前只能对微应用进行加载和解析生命周期函数处理。",(0,r.jsx)(e.code,{children:"start"})," 函数执行后会标记 single-spa 的启动标识 ",(0,r.jsx)(e.code,{children:"started"}),"，后续",(0,r.jsx)(e.code,{children:"reroute"})," 函数可使用该标识判断是否要执行微应用的生命周期函数，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'let started = false;\n\n/**\n * @description 启动 single-spa 应用\n * @export\n * @param opts\n */\nexport function start(opts) {\n  console.log("[start.js]: start 函数开始执行...");\n  // 标记 single-spa 已经启动\n  started = true;\n\n  // 如果 opts.urlRerouteOnly 为 true，执行 setUrlRerouteOnly 函数\n  // urlRerouteOnly 在后续的监听路由变化中讲解\n  if (opts && opts.urlRerouteOnly) {\n    setUrlRerouteOnly(opts.urlRerouteOnly);\n  }\n  // 如果是在浏览器环境中，执行 reroute 函数\n  if (isInBrowser) {\n    console.log("[start.js]: 在 start 中准备执行 reroute 函数...");\n    reroute();\n  }\n}\n\n// 判断 single-spa 是否已经启动\nexport function isStarted() {\n  return started;\n}\n\nif (isInBrowser) { \n  // 一般注册完所有的微应用后就需要立马调用 start 函数启动 single-spa\n  // 如果没有调用 start 函数则给出警告提示\n  setTimeout(() => {\n    if (!started) {\n      console.warn(\n        formatErrorMessage(\n          1,\n          __DEV__ &&\n            `singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted.`\n        )\n      );\n    }\n  }, 5000);\n}\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"navigation-解析",children:[(0,r.jsx)(e.code,{children:"navigation"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#navigation-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"reroute-解析",children:[(0,r.jsx)(e.code,{children:"reroute"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#reroute-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"registerApplication"})," 和 ",(0,r.jsx)(e.code,{children:"start"})," 都会调用 ",(0,r.jsx)(e.code,{children:"reroute"})," 函数，该函数主要是在微应用需要发生变化时触发，它会通过 ",(0,r.jsx)(e.code,{children:"getAppChanges"})," 判断需要变化的微应用列表，然后根据外部是否调用了 ",(0,r.jsx)(e.code,{children:"start"})," 函数来判断执行微应用的批量加载 ",(0,r.jsx)(e.code,{children:"loadApps"})," 还是执行所有微应用的变化 ",(0,r.jsx)(e.code,{children:"performAppChanges"}),"："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/navigation/reroute.js\n\n/**\n * @description 重新路由\n * 触发的时机：\n * 1. 当浏览器的 url 发生变化\n * 2. 当调用 start() 方法后\n * 3. 当调用 registerApplication() 方法后\n * 4. 当调用 navigateToUrl() 方法后\n * 5. 当调用 triggerAppChange() 方法后\n * 6. 当调用 unloadApplication() 方法后\n * 7. 当调用 loadApplication() 方法后\n * 8. 当调用 mountRootParcel() 方法后\n * 9. 当调用 unmountRootParcel() 方法后\n *\n * 总结：\n * retoute 主要是在微应用需要发生变化时触发，\n * 比如新增、删除、更新、加载、彻底卸载（unload）、卸载、挂载应用等。\n *\n * @export\n * @param [pendingPromises=[]] 等待应用变化的 Promise 数组\n * @param eventArguments 事件参数\n * @returns {*}\n */\nexport function reroute(pendingPromises = [], eventArguments) {\n  // eslint-disable-next-line no-console\n  console.log("[navigation/reroute.js - reroute]: reroute 函数开始执行...");\n\n  // 如果当前正在执行 performAppChanges 处理应用变化，\n  // 则将 eventArguments 存储到 peopleWaitingOnAppChange 数组中\n  \n  // 如果 performAppChanges 函数还未执行完毕，\n  // 但是再次调用了 reroute 函数，\n  // 那么会等待 performAppChanges 函数执行完毕\n  \n  // 在 performAppChanges 函数执行完毕后，\n  // 会调用 finishUpAndReturn 函数，\n  // 如果 peopleWaitingOnAppChange 数组中有数据，\n  // 则会再次执行 reroute 函数\n  // 因此这里主要用于延迟执行 reroute 函数\n  if (appChangeUnderway) {\n    return new Promise((resolve, reject) => {\n      // 将 resolve、reject、eventArguments 存储到 peopleWaitingOnAppChange 数组中\n      \n      // 当 performAppChanges 函数执行完毕后，\n      // 会调用 finishUpAndReturn 函数，\n      // 如果 peopleWaitingOnAppChange 数组中有数据，\n      // 则会再次执行 reroute 函数\n      peopleWaitingOnAppChange.push({\n        resolve,\n        reject,\n        eventArguments,\n      });\n    });\n  }\n\n  // 获取当前应用的变化情况\n  // 1. appsToUnload: 需要彻底卸载的应用\n  // 2. appsToUnmount: 需要卸载的应用\n  // 3. appsToLoad: 需要加载的应用\n  // 4. appsToMount: 需要挂载的应用\n  const { appsToUnload, appsToUnmount, appsToLoad, appsToMount } =\n    getAppChanges();\n  let appsThatChanged,\n    navigationIsCanceled = false,\n    oldUrl = currentUrl,\n    newUrl = (currentUrl = window.location.href);\n\n  // 如果已经调用了 start 函数启动\n  if (isStarted()) {\n    // 设置当前应用变化正在进行中，避免多次同时触发应用变化\n    appChangeUnderway = true;\n    appsThatChanged = appsToUnload.concat(\n      appsToLoad,\n      appsToUnmount,\n      appsToMount\n    );\n    console.log(\n      "[navigation/reroute.js - reroute]: appsToUnload 数据: ",\n      appsToUnload\n    );\n    console.log(\n      "[navigation/reroute.js - reroute]: appsToUnmount 数据: ",\n      appsToUnmount\n    );\n    console.log(\n      "[navigation/reroute.js - reroute]: appsToLoad 数据: ",\n      appsToLoad\n    );\n    console.log(\n      "[navigation/reroute.js - reroute]: appsToMount 数据: ",\n      appsToMount\n    );\n    console.log(\n      "[navigation/reroute.js - reroute]: 准备执行 performAppChanges..."\n    );\n    return performAppChanges();\n    // 如果还没有启动\n    // 调用 singleSpa.registerApplication() 方法后，\n    // 还没有调用 singleSpa.start() 方法之前会走到这里\n  } else {\n    appsThatChanged = appsToLoad;\n    console.log("[navigation/reroute.js - reroute]: 准备执行 loadApps...");\n    return loadApps();\n  }\n  \n  \n  /**\n   * @description 如果外部监听\n   * single-spa:before-routing-event 事件\n   * 并调用了 cancelNavigation 方法，则取消导航\n   */\n  function cancelNavigation() {\n    navigationIsCanceled = true;\n  }\n  \n  /**\n   * @description 加载应用\n   * @returns\n   */\n  function loadApps() {\n    // ...\n  }\n  \n  /**\n   * @description 执行应用变化\n   * @returns {*}\n   */\n  function performAppChanges() {\n    // ...\n  }\n  \n  /**\n   * @description performAppChanges 函数执行完毕后，\n   * 执行 finishUpAndReturn 函数\n   * @returns {*}\n   */\n  function finishUpAndReturn() {\n    // ...\n  }\n  \n  /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n  function callAllEventListeners() {\n     // ...\n  }\n  \n  /**\n   * @description 获取自定义事件详情信息\n   * @param isBeforeChanges 是否在应用变化之前\n   * @param extraProperties 额外的属性，例如 { cancelNavigation }\n   * @returns {Object} 自定义事件详情信息\n   */\n  function getCustomEventDetail(isBeforeChanges = false, extraProperties) {\n    // ...\n  }\n}\n'})}),"\n",(0,r.jsxs)(e.h4,{id:"getappchanges-解析",children:[(0,r.jsx)(e.code,{children:"getAppChanges"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#getappchanges-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"reoute"})," 函数会先执行 ",(0,r.jsx)(e.code,{children:"getAppChanges"})," 计算需要变化的微应用列表，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// src/applications/apps.js\n\n/**\n * @description 计算应用的变更情况\n * @export\n * @returns {Object} 返回变更的应用，\n * 例如 { appsToUnload, appsToUnmount, appsToLoad, appsToMount }\n */\nexport function getAppChanges() {\n  const appsToUnload = [],\n    appsToUnmount = [],\n    appsToLoad = [],\n    appsToMount = [];\n\n  // We re-attempt to download applications in LOAD_ERROR after a timeout of 200 milliseconds\n  const currentTime = new Date().getTime();\n\n  apps.forEach((app) => {\n    // 判断应用是否应该激活\n    // 1. 如果应用的状态是 SKIP_BECAUSE_BROKEN，那么不需要激活\n    // 2. 通过 shouldBeActive 函数判断应用是否应该激活\n    const appShouldBeActive =\n      app.status !== SKIP_BECAUSE_BROKEN && shouldBeActive(app);\n\n    // 状态机（即将进行状态转换），对应用进行分类\n    switch (app.status) {\n      // 应用之前的状态是 LOAD_ERROR\n      case LOAD_ERROR:\n        // 判断应用是否要加载：如果应用之前加载失败，此时被激活，\n        // 并且加载失败的时间超过 200 毫秒，那么即将重新加载应用\n        if (appShouldBeActive && currentTime - app.loadErrorTime >= 200) {\n          appsToLoad.push(app);\n        }\n        break;\n\n      // 应用之前的状态是 NOT_LOADED 或者 LOADING_SOURCE_CODE\n      // 1. 注册应用后，应用的初始状态是 NOT_LOADED\n      case NOT_LOADED:\n      case LOADING_SOURCE_CODE:\n        // 判断应用是否要加载：如果应用被激活，那么即将加载应用\n        if (appShouldBeActive) {\n          appsToLoad.push(app);\n        }\n        break;\n      // 应用之前的状态是 NOT_BOOTSTRAPPED 或者 NOT_MOUNTED\n      case NOT_BOOTSTRAPPED:\n      case NOT_MOUNTED:\n        // 判断应用是否要彻底卸载\n        // 1. 如果应用被激活\n        // 2. 如果确实被标记了要彻底卸载，\n        // 在 lifecycles/unload.js 中会维护 appsToUnload 对象，\n        // 用于标记应用是否要彻底卸载\n        if (!appShouldBeActive && getAppUnloadInfo(toName(app))) {\n          appsToUnload.push(app);\n          // 判断应用是否要挂载：如果应用被激活，那么即将挂载应用\n        } else if (appShouldBeActive) {\n          appsToMount.push(app);\n        }\n        break;\n\n      // 应用之前的状态是 MOUNTED\n      case MOUNTED:\n        // 判断应用是否要卸载：如果应用失活，那么即将卸载应用\n        if (!appShouldBeActive) {\n          appsToUnmount.push(app);\n        }\n        break;\n      // all other statuses are ignored\n    }\n  });\n\n  return { appsToUnload, appsToUnmount, appsToLoad, appsToMount };\n}\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：这里可以结合后续的",(0,r.jsx)(e.strong,{children:"状态和事件剖析"}),"加深对于微应用的状态变更理解。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"loadapps-解析",children:[(0,r.jsx)(e.code,{children:"loadApps"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#loadapps-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["通过执行 ",(0,r.jsx)(e.code,{children:"getAppChanges"})," 函数可以计算出需要批量加载的 ",(0,r.jsx)(e.code,{children:"appsToLoad"})," 数组，如果主应用初始化时还未执行 ",(0,r.jsx)(e.code,{children:"start"})," 函数启动，那么 ",(0,r.jsx)(e.code,{children:"reroute"})," 会调用 ",(0,r.jsx)(e.code,{children:"loadApps"})," 进行批量加载："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/navigation/reroute.js\n\n/**\n   * @description 加载应用\n   * @returns\n   */\n  function loadApps() {\n    console.log("[navigation/reroute.js - loadApps]: loadApps 开始执行...");\n    \n    // 开启微任务，异步执行微应用的加载函数，\n    // 例如等待主应用的 React 路由执行完毕\n    return Promise.resolve().then(() => {\n      console.log(\n        "[navigation/reroute.js - loadApps]: loadApps 的 Promise.resolve 开始执行..."\n      );\n\n      // 批量执行 appsToLoad 数组中的 app.loadApp 方法（registerApplication 的第二个参数 app）\n      const loadPromises = appsToLoad.map(toLoadPromise);\n\n      return (\n        Promise.all(loadPromises)\n          .then(callAllEventListeners)\n          .then(() => {\n            console.log(\n              "[navigation/reroute.js - loadApps]: 所有子应用的 app.loadApp 方法（registerApplication 的第二个参数 app）执行完毕。"\n            );\n          })\n          // there are no mounted apps, before start() is called, so we always return []\n          .then(() => [])\n          .catch((err) => {\n            callAllEventListeners();\n            throw err;\n          })\n      );\n    });\n  }\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：这里暂时先忽略 ",(0,r.jsx)(e.code,{children:"toLoadPromise"}),"，会在后续统一讲解。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"performappchanges-解析",children:[(0,r.jsx)(e.code,{children:"performAppChanges"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#performappchanges-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["通过执行 ",(0,r.jsx)(e.code,{children:"getAppChanges"})," 函数可以计算出需要批量处理的 ",(0,r.jsx)(e.code,{children:"appsToUnload、appsToUnmount、appsToLoad、appsToMount"})," 等数组，如果主应用初始化时已经执行 ",(0,r.jsx)(e.code,{children:"start"})," 函数启动，那么 ",(0,r.jsx)(e.code,{children:"reroute"})," 会调用 ",(0,r.jsx)(e.code,{children:"performAppChanges"})," 对所有微应用的 ",(0,r.jsx)(e.code,{children:"unload"}),"、",(0,r.jsx)(e.code,{children:"unmount"}),"、",(0,r.jsx)(e.code,{children:"loadApp"}),"、",(0,r.jsx)(e.code,{children:"bootstrap"})," 以及 ",(0,r.jsx)(e.code,{children:"mount"})," 等所有生命周期函数进行批量异步执行："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'/**\n   * @description 执行应用变化\n   * @returns {*}\n   */\n  function performAppChanges() {\n    console.log(\n      "[navigation/reroute.js - performAppChanges]: performAppChanges 开始执行..."\n    );\n    \n    // 开启微任务，异步执行应用变化，\n    // 例如等待主应用的 React 路由执行完毕\n    return Promise.resolve().then(() => {\n      console.log(\n        "[navigation/reroute.js - performAppChanges]: performAppChanges 的 Promise.resolve 开始执行..."\n      );\n      // https://github.com/single-spa/single-spa/issues/545\n      // 如果没有应用发生变化，则触发 single-spa:before-no-app-change 事件\n      // 如果有应用发生变化，则触发 single-spa:before-app-change 事件\n      window.dispatchEvent(\n        new CustomEvent(\n          appsThatChanged.length === 0\n            ? "single-spa:before-no-app-change"\n            : "single-spa:before-app-change",\n          getCustomEventDetail(true)\n        )\n      );\n\n      console.log(\n        "[navigation/reroute.js - performAppChanges]: 触发 window.dispatchEvent 的 single-spa:before-routing-event 事件， event: ",\n        getCustomEventDetail(true, { cancelNavigation })\n      );\n\n      // 通过监听 single-spa:before-routing-event 事件，\n      // 可以取消导航\n      window.dispatchEvent(\n        new CustomEvent(\n          "single-spa:before-routing-event",\n          getCustomEventDetail(true, { cancelNavigation })\n        )\n      );\n\n      // 如果外部监听了 single-spa:before-routing-event 事件，\n      // 并且调用了 cancelNavigation 方法，则取消导航\n      if (navigationIsCanceled) {\n        window.dispatchEvent(\n          new CustomEvent(\n            "single-spa:before-mount-routing-event",\n            getCustomEventDetail(true)\n          )\n        );\n        // 结束 performAppChanges 函数的执行\n        finishUpAndReturn();\n        // 重新导航到旧的 url\n        navigateToUrl(oldUrl);\n        return;\n      }\n\n      // 批量执行 appsToUnload 数组中的 app.unload 方法\n      const unloadPromises = appsToUnload.map(toUnloadPromise);\n      console.log(\n        "[navigation/reroute.js - performAppChanges]: performAppChanges 中的 unloadPromises 数据: ",\n        unloadPromises\n      );\n\n      // 批量执行 appsToUnmount 数组中的 app.unmount 方法\n      const unmountUnloadPromises = appsToUnmount\n        .map(toUnmountPromise)\n        // unmount 执行完毕后，再执行 unload\n        .map((unmountPromise) => unmountPromise.then(toUnloadPromise));\n\n      // 将所有的 toUnmountPromise 和 toUnloadPromise 方法合并到 allUnmountPromises 数组中\n      const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n      const unmountAllPromise = Promise.all(allUnmountPromises);\n\n      console.log(\n        "[navigation/reroute.js - performAppChanges]: 准备执行所有子应用的 toUnmountPromise 和 toUnloadPromise 方法..."\n      );\n      // 等待所有的 toUnmountPromise 和 toUnloadPromise 方法执行完毕\n      unmountAllPromise.then(() => {\n        // 触发 single-spa:before-mount-routing-event 事件\n        window.dispatchEvent(\n          new CustomEvent(\n            "single-spa:before-mount-routing-event",\n            getCustomEventDetail(true)\n          )\n        );\n      });\n\n      console.log(\n        "[navigation/reroute.js - performAppChanges]: performAppChanges 中的 unmountAllPromise 数据: ",\n        unmountAllPromise\n      );\n\n      /* We load and bootstrap apps while other apps are unmounting, but we\n       * wait to mount the app until all apps are finishing unmounting\n       */\n      // 批量执行 appsToLoad 数组中的 app.loadApp 方法（registerApplication 的第二个参数 app）\n      // 这里不会等待 unmountAllPromise 执行完毕，而是直接执行\n      const loadThenMountPromises = appsToLoad.map((app) => {\n        console.log(\n          "[navigation/reroute.js - performAppChanges]: 准备执行子应用的 app.loadApp 方法（registerApplication 的第二个参数 app）...",\n          app.name,\n          app.status\n        );\n        // 执行 app.loadApp 方法（registerApplication 的第二个参数 app）\n        return toLoadPromise(app).then((app) => {\n          console.log(\n            "[navigation/reroute.js - performAppChanges]: 子应用的 app.loadApp 方法执行完毕，准备执行子应用的周期函数 bootstrap 和 mount ...",\n            app.name,\n            app.status\n          );\n          // load 之后，需要执行 bootstrap 和 mount\n          tryToBootstrapAndMount(app, unmountAllPromise);\n        });\n      });\n\n      console.log(\n        "[navigation/reroute.js - performAppChanges]: performAppChanges 中的  loadThenMountPromises 数据: ",\n        loadThenMountPromises\n      );\n\n      /* These are the apps that are already bootstrapped and just need\n       * to be mounted. They each wait for all unmounting apps to finish up\n       * before they mount.\n       */\n      // 批量执行 appsToMount 数组中的 app.bootstrap 和 app.mount 方法\n      const mountPromises = appsToMount\n        // 过滤掉 appsToLoad 数组中的 app\n        .filter((appToMount) => appsToLoad.indexOf(appToMount) < 0)\n        .map((appToMount) => {\n          console.log(\n            "[navigation/reroute.js - performAppChanges]: appsToMount 准备执行子应用的周期函数 bootstrap 和 mount ..."\n          );\n          // 执行 app.bootstrap 和 app.mount 方法\n          return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n        });\n\n      console.log(\n        "[navigation/reroute.js - performAppChanges]: performAppChanges 中的 mountPromises 数据: ",\n        mountPromises\n      );\n\n      return unmountAllPromise\n        .catch((err) => {\n          callAllEventListeners();\n          throw err;\n        })\n        .then(() => {\n          /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n           * events (like hashchange or popstate) should have been cleaned up. So it\'s safe\n           * to let the remaining captured event listeners to handle about the DOM event.\n           */\n          callAllEventListeners();\n\n          return Promise.all(loadThenMountPromises.concat(mountPromises))\n            .catch((err) => {\n              pendingPromises.forEach((promise) => promise.reject(err));\n              throw err;\n            })\n            .then(finishUpAndReturn);\n        });\n    });\n  }\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：这里暂时先忽略 ",(0,r.jsx)(e.code,{children:"toLoadPromise"}),"、",(0,r.jsx)(e.code,{children:"toUnloadPromise"})," 等微应用的生命周期函数异步执行处理，会在后续统一讲解。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"getcustomeventdetail-解析",children:[(0,r.jsx)(e.code,{children:"getCustomEventDetail"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#getcustomeventdetail-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["通过 single-spa 调用 ",(0,r.jsx)(e.code,{children:"window.dispatchEvent"})," 发送事件时会携带各个微应用需要变更的状态信息，此时需要通过 ",(0,r.jsx)(e.code,{children:"getCustomEventDetail"})," 函数进行计算，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:" /**\n   * @description 获取自定义事件详情信息\n   * @param isBeforeChanges 是否在应用变化之前\n   * @param extraProperties 额外的属性，例如 { cancelNavigation }\n   * @returns {Object} 自定义事件详情信息\n   */\n  function getCustomEventDetail(isBeforeChanges = false, extraProperties) {\n    const newAppStatuses = {};\n    const appsByNewStatus = {\n      // for apps that were mounted\n      [MOUNTED]: [],\n      // for apps that were unmounted\n      [NOT_MOUNTED]: [],\n      // apps that were forcibly unloaded\n      [NOT_LOADED]: [],\n      // apps that attempted to do something but are broken now\n      [SKIP_BECAUSE_BROKEN]: [],\n    };\n\n    // 如果在应用变化之前，则获取应用的状态\n    if (isBeforeChanges) {\n      appsToLoad.concat(appsToMount).forEach((app, index) => {\n        addApp(app, MOUNTED);\n      });\n      appsToUnload.forEach((app) => {\n        addApp(app, NOT_LOADED);\n      });\n      appsToUnmount.forEach((app) => {\n        addApp(app, NOT_MOUNTED);\n      });\n    } else {\n      appsThatChanged.forEach((app) => {\n        addApp(app);\n      });\n    }\n\n    // 发送事件时包装的详细信息\n    const result = {\n      detail: {\n        newAppStatuses,\n        appsByNewStatus,\n        totalAppChanges: appsThatChanged.length,\n        originalEvent: eventArguments?.[0],\n        oldUrl,\n        newUrl,\n        navigationIsCanceled,\n      },\n    };\n\n    // 如果有额外的属性，则添加到 result.detail 对象中\n    if (extraProperties) {\n      assign(result.detail, extraProperties);\n    }\n\n    return result;\n\n    /**\n     * @description 添加应用\n     * @param app 应用\n     * @param status 状态\n     */\n    function addApp(app, status) {\n      // 获取应用的名称\n      const appName = toName(app);\n      // 获取应用的状态\n      status = status || getAppStatus(appName);\n      // 将应用的状态添加到 newAppStatuses 对象中\n      newAppStatuses[appName] = status;\n      // 将应用的名称添加到 appsByNewStatus 对象中\n      // 例如：appsByNewStatus = { MOUNTED: ['app1', 'app2'], NOT_MOUNTED: ['app3', 'app4'] }\n      const statusArr = (appsByNewStatus[status] =\n        appsByNewStatus[status] || []);\n      statusArr.push(appName);\n    }\n  }\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"callalleventlisteners-解析",children:[(0,r.jsx)(e.code,{children:"callAllEventListeners"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#callalleventlisteners-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"loadApps"})," 中批量异步加载微应用后会执行 ",(0,r.jsx)(e.code,{children:"callAllEventListeners"})," 延迟触发微应用因未加载代码执行而错过的 ",(0,r.jsx)(e.code,{children:"hashchange"})," 和 ",(0,r.jsx)(e.code,{children:"popstate"})," 导航事件。同理在 ",(0,r.jsx)(e.code,{children:"performAppChanges"})," 中也会等待所有微应用的 ",(0,r.jsx)(e.code,{children:"unmount"})," 和 ",(0,r.jsx)(e.code,{children:"unload"})," 执行完毕后再延迟触发执行导航事件，一旦微应用在卸载时移除了相应的监听器，延迟执行则能够确保这些事件不会被监听执行："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:' /* We need to call all event listeners that have been delayed because they were\n   * waiting on single-spa. This includes haschange and popstate events for both\n   * the current run of performAppChanges(), but also all of the queued event listeners.\n   * We want to call the listeners in the same order as if they had not been delayed by\n   * single-spa, which means queued ones first and then the most recent one.\n   */\n   \n  // 延迟执行 hashchange 和 popstate 事件的监听器\n  // 1.在微应用激活时触发了 `popstate` 事件，\n  // 但是此时微应用的代码还没有加载完成，\n  // 这会使得微应用错过事件监听，\n  // 因此在 loadApps 执行完毕后会执行 callAllEventListeners。\n  \n  // 2.如果微应用失活时正好触发了 `popstate` 事件，\n  // 微应用可能希望在卸载时移除监听 `hashchange` 和 `popstate` 事件，\n  // 此时 single-spa 可以将事件延迟到微应用卸载后执行，\n  // 这样微应用在卸载后因为移除了相应的监听事件并不会触发事件的监听执行，\n  // 所以 performAppChanges 会在所有微应用 `unmount` 和 `unload` 后\n  // 才延迟执行 callAllEventListeners。\n  function callAllEventListeners() {\n    console.log(\n      "[navigation/reroute.js - callAllEventListeners]: callAllEventListeners 中的 pendingPromises 数据： ",\n      pendingPromises\n    );\n    pendingPromises.forEach((pendingPromise) => {\n      callCapturedEventListeners(pendingPromise.eventArguments);\n    });\n\n    callCapturedEventListeners(eventArguments);\n  }\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：关于 ",(0,r.jsx)(e.code,{children:"callCapturedEventListeners"})," 可以查看后续的 ",(0,r.jsx)(e.code,{children:"navigation-events"})," 解析。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"finishupandreturn-解析",children:[(0,r.jsx)(e.code,{children:"finishUpAndReturn"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#finishupandreturn-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"finishUpAndReturn"})," 函数会在用户调用 ",(0,r.jsx)(e.code,{children:"cancelNavigation"})," 取消导航和 ",(0,r.jsx)(e.code,{children:"performAppChanges"})," 中所有微应用的 ",(0,r.jsx)(e.code,{children:"load"})," 和 ",(0,r.jsx)(e.code,{children:"mount"})," 生命周期函数执行完毕后触发，它主要用于触发 single-spa 的内置事件、清除 ",(0,r.jsx)(e.code,{children:"performAppChanges"})," 正在执行的标志位以及执行被延迟的 ",(0,r.jsx)(e.code,{children:"reroute"})," 函数："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'function finishUpAndReturn() {\n    console.log(\n      "[navigation/reroute.js - finishUpAndReturn]: finishUpAndReturn 开始执行..."\n    );\n\n    const returnValue = getMountedApps();\n    console.log(\n      "[navigation/reroute.js - finishUpAndReturn]: finishUpAndReturn 中的 returnValue 数据: ",\n      returnValue\n    );\n    pendingPromises.forEach((promise) => promise.resolve(returnValue));\n    console.log(\n      "[navigation/reroute.js - finishUpAndReturn]: finishUpAndReturn 中的 pendingPromises 数据: ",\n      pendingPromises\n    );\n\n    try {\n      const appChangeEventName =\n        appsThatChanged.length === 0\n          ? "single-spa:no-app-change"\n          : "single-spa:app-change";\n      window.dispatchEvent(\n        new CustomEvent(appChangeEventName, getCustomEventDetail())\n      );\n      window.dispatchEvent(\n        new CustomEvent("single-spa:routing-event", getCustomEventDetail())\n      );\n    } catch (err) {\n      /* We use a setTimeout because if someone else\'s event handler throws an error, single-spa\n       * needs to carry on. If a listener to the event throws an error, it\'s their own fault, not\n       * single-spa\'s.\n       */\n      setTimeout(() => {\n        throw err;\n      });\n    }\n\n    /* Setting this allows for subsequent calls to reroute() to actually perform\n     * a reroute instead of just getting queued behind the current reroute call.\n     * We want to do this after the mounting/unmounting is done but before we\n     * resolve the promise for the `reroute` function.\n     */\n    // 设置 appChangeUnderway 为 false，表示应用变化已经结束\n    appChangeUnderway = false;\n    \n    // 在 performAppChanges 函数异步执行期间，\n    // 如果调用了 reroute 函数，\n    // 那么会将 eventArguments 存储到 peopleWaitingOnAppChange 数组中\n    // 等待 performAppChanges 函数执行完毕后延迟执行 reroute 函数\n    if (peopleWaitingOnAppChange.length > 0) {\n      /* While we were rerouting, someone else triggered another reroute that got queued.\n       * So we need reroute again.\n       */\n      const nextPendingPromises = peopleWaitingOnAppChange;\n      peopleWaitingOnAppChange = [];\n      console.log(\n        "[navigation/reroute.js - finishUpAndReturn]: 在 finishUpAndReturn 中准备执行 reroute 函数..."\n      );\n      reroute(nextPendingPromises);\n    }\n\n    return returnValue;\n  }\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"navigation-events-解析",children:[(0,r.jsx)(e.code,{children:"navigation-events"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#navigation-events-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["除了页面初始化加载时需要通过 ",(0,r.jsx)(e.code,{children:"start"})," 函数调用 ",(0,r.jsx)(e.code,{children:"reroute"})," 实时激活和加载微应用，在页面路由发生变化时也需要调用 ",(0,r.jsx)(e.code,{children:"reroute"})," 变化微应用，因此 single-spa 需要监听导航事件的变化以及框架的路由变化："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import { reroute } from "./reroute.js";\nimport { find } from "../utils/find.js";\nimport { formatErrorMessage } from "../applications/app-errors.js";\nimport { isInBrowser } from "../utils/runtime-environment.js";\nimport { isStarted } from "../start.js";\n\n/* We capture navigation event listeners so that we can make sure\n * that application navigation listeners are not called until\n * single-spa has ensured that the correct applications are\n * unmounted and mounted.\n */\n// 在 single-spa 中会捕获导航事件监听器，进行延迟执行\n// 例如微应用 A 在 unmount 中移除了 hashchange 事件监听器，\n// 在微应用 A  unmount 时触发了 hashchange 事件，\n// 为了防止微应用 A 执行 hashchange 事件，\n// 需要在 single-spa 中提前捕获 hashchange 事件，\n// 等待微应用 A unmount 完成后再延迟执行 hashchange 事件监听器\n\n// capturedEventListeners 用于存储捕获的事件监听器\nconst capturedEventListeners = {\n  hashchange: [],\n  popstate: [],\n};\n\nexport const routingEventsListeningTo = ["hashchange", "popstate"];\n\nexport function navigateToUrl(obj) {\n  let url;\n  if (typeof obj === "string") {\n    url = obj;\n  } else if (this && this.href) {\n    url = this.href;\n  } else if (\n    obj &&\n    obj.currentTarget &&\n    obj.currentTarget.href &&\n    obj.preventDefault\n  ) {\n    url = obj.currentTarget.href;\n    obj.preventDefault();\n  } else {\n    throw Error(\n      formatErrorMessage(\n        14,\n        __DEV__ &&\n          `singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag`\n      )\n    );\n  }\n\n  const current = parseUri(window.location.href);\n  const destination = parseUri(url);\n\n  if (url.indexOf("#") === 0) {\n    window.location.hash = destination.hash;\n  } else if (current.host !== destination.host && destination.host) {\n    if (process.env.BABEL_ENV === "test") {\n      return { wouldHaveReloadedThePage: true };\n    } else {\n      window.location.href = url;\n    }\n  } else if (\n    destination.pathname === current.pathname &&\n    destination.search === current.search\n  ) {\n    window.location.hash = destination.hash;\n  } else {\n    // different path, host, or query params\n    window.history.pushState(null, null, url);\n  }\n}\n\n/**\n * @description 在 single-spa 中延迟执行捕获的事件监听器（批量加载微应用后、批量 unmount 微应用后）\n * @export\n * @param eventArguments 事件参数\n */\nexport function callCapturedEventListeners(eventArguments) {\n  console.log(\n    "[navigation/navigation-events.js - callCapturedEventListeners]: callCapturedEventListeners 函数开始执行...",\n    eventArguments\n  );\n  // 如果 eventArguments 存在，\n  // 则会执行 capturedEventListeners 中对应事件类型的监听器\n  \n  // 注意这里的 eventArguments 由 createPopStateEvent 函数创建，\n  // 是一个 PopStateEvent 实例\n  // 例如触发流程：\n  // history.pushState（React 或者 Vue 框架路由变化） \n  // -> patchedUpdateState -> createPopStateEvent \n  // -> window.dispatchEvent \n  // -> window.addEventListener \n  // -> urlReroute -> reroute \n  // -> performAppChanges -> 批量 unmount 执行完毕 \n  // -> callCapturedEventListeners\n  if (eventArguments) {\n    const eventType = eventArguments[0].type;\n    if (routingEventsListeningTo.indexOf(eventType) >= 0) {\n      // 遍历 capturedEventListeners 中对应事件类型的监听器，执行监听器\n      capturedEventListeners[eventType].forEach((listener) => {\n        try {\n          // The error thrown by application event listener should not break single-spa down.\n          // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did\n          listener.apply(this, eventArguments);\n        } catch (e) {\n          setTimeout(() => {\n            throw e;\n          });\n        }\n      });\n    }\n  }\n}\n\nlet urlRerouteOnly;\n\n// 设置 urlRerouteOnly 变量，如果为 true，\n// 则只有 url 变化时才会执行 reroute 函数\n\n// 在 start 函数中可以传递 opts.urlRerouteOnly 参数触发执行 setUrlRerouteOnly 函数\nexport function setUrlRerouteOnly(val) {\n  urlRerouteOnly = val;\n}\n\n// urlReroute 函数，会携带事件参数，\n// 携带事件参数的 urlReroute 函数最终会执行 callCapturedEventListeners 函数\nfunction urlReroute() {\n  console.log(\n    "[navigation/navigation-events.js - urlReroute]: 在 urlReroute 中准备执行 reroute 函数..."\n  );\n  // 最终会将 arguments 传递给 callCapturedEventListeners 函数\n  reroute([], arguments);\n}\n\n/**\n * @description 重写 window.history.pushState 和 window.history.replaceState 方法\n * @param updateState window.history.pushState 或 window.history.replaceState\n * @param methodName pushState 或 replaceState\n * @returns {*}\n */\nfunction patchedUpdateState(updateState, methodName) {\n  return function () {\n    const urlBefore = window.location.href;\n    // 执行原生的 pushState 或 replaceState 方法\n    // 这里也是为什么 React 框架和 Vue 框架路由变化后，\n    // single-spa 能够触发微应用激活和失活的主要原因\n    const result = updateState.apply(this, arguments);\n    const urlAfter = window.location.href;\n\n    // 如果 urlRerouteOnly 为 true，\n    // 则只会判断 url 是否发生变化，\n    // 如果发生变化，则执行 reroute 函数\n    \n    // 如果为 false, 则不管 url 是否发生变化，\n    // 都会执行 reroute 函数\n    if (!urlRerouteOnly || urlBefore !== urlAfter) {\n      if (isStarted()) {\n        // fire an artificial popstate event once single-spa is started,\n        // so that single-spa applications know about routing that\n        // occurs in a different application\n        // 在 single-spa 启动之后，\n        // 触发人工的 popstate 事件，\n        // 以便 single-spa 延迟执行事件监听器\n        window.dispatchEvent(\n          createPopStateEvent(window.history.state, methodName)\n        );\n      } else {\n        // do not fire an artificial popstate event before single-spa is started,\n        // since no single-spa applications need to know about routing events\n        // outside of their own router.\n        // 在 single-spa 启动之前，\n        // 不要触发人工的 popstate 事件，\n        // 因为没有启动微前端，\n        // 没有微应用需要 unmount 或者 mount，\n        // 也就不需要延迟执行事件监听器\n        console.log(\n          "[navigation/navigation-events.js - patchedUpdateState]: 在 patchedUpdateState 中准备执行 reroute 函数..."\n        );\n        reroute([]);\n      }\n    }\n\n    return result;\n  };\n}\n\n/**\n * @description 创建 popstate 事件\n * @param state\n * @param originalMethodName\n * @returns {*}\n */\nfunction createPopStateEvent(state, originalMethodName) {\n  // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49\n  // We need a popstate event even though the browser doesn\'t do one by default when you call replaceState, so that\n  // all the applications can reroute. We explicitly identify this extraneous event by setting singleSpa=true and\n  // singleSpaTrigger=<pushState|replaceState> on the event instance.\n  let evt;\n  try {\n    // 创建 popstate 事件\n    evt = new PopStateEvent("popstate", { state });\n  } catch (err) {\n    // IE 11 compatibility https://github.com/single-spa/single-spa/issues/299\n    // https://docs.microsoft.com/en-us/openspecs/ie_standards/ms-html5e/bd560f47-b349-4d2c-baa8-f1560fb489dd\n    evt = document.createEvent("PopStateEvent");\n    evt.initPopStateEvent("popstate", false, false, state);\n  }\n  evt.singleSpa = true;\n  evt.singleSpaTrigger = originalMethodName;\n  return evt;\n}\n\nif (isInBrowser) {\n  // We will trigger an app change for any routing events.\n  // 监听 hashchange 事件，执行 urlReroute 函数\n  window.addEventListener("hashchange", (event) => {\n    console.log(\n      "[navigation/navigation-events.js - hashchange]: 在 hashchange 中准备执行 urlReroute 函数..."\n    );\n    urlReroute(event);\n  });\n  // 监听 popstate 事件，执行 urlReroute 函数\n  window.addEventListener("popstate", (event) => {\n    console.log(\n      "[navigation/navigation-events.js - popstate]: 在 popstate 中准备执行 urlReroute 函数..."\n    );\n    urlReroute(event);\n  });\n\n  // Monkeypatch addEventListener so that we can ensure correct timing\n  const originalAddEventListener = window.addEventListener;\n  const originalRemoveEventListener = window.removeEventListener;\n  // 重写 window.addEventListener 方法，用于捕获 hashchange 和 popstate 事件监听器\n  window.addEventListener = function (eventName, fn) {\n    if (typeof fn === "function") {\n      if (\n        // 如果是 hashchange 或者 popstate 事件，\n        // 并且 capturedEventListeners 中没有对应事件监听器\n        // 则将事件监听器添加到 capturedEventListeners 中\n        routingEventsListeningTo.indexOf(eventName) >= 0 &&\n        !find(capturedEventListeners[eventName], (listener) => listener === fn)\n      ) {\n        capturedEventListeners[eventName].push(fn);\n        return;\n      }\n    }\n\n    // 如果不是 hashchange 或者 popstate 事件，\n    // 或者 capturedEventListeners 中已经存在对应事件监听器，\n    // 则执行原生的 addEventListener 方法\n    return originalAddEventListener.apply(this, arguments);\n  };\n\n  // 重写 window.removeEventListener 方法，\n  // 用于移除 hashchange 和 popstate 事件监听器\n  window.removeEventListener = function (eventName, listenerFn) {\n    if (typeof listenerFn === "function") {\n      if (routingEventsListeningTo.indexOf(eventName) >= 0) {\n        capturedEventListeners[eventName] = capturedEventListeners[\n          eventName\n        ].filter((fn) => fn !== listenerFn);\n        return;\n      }\n    }\n\n    return originalRemoveEventListener.apply(this, arguments);\n  };\n\n  // 重写 window.history.pushState 方法，\n  // 用于捕获 React 或者 Vue 框架路由变化\n  window.history.pushState = patchedUpdateState(\n    window.history.pushState,\n    "pushState"\n  );\n  // 重写 window.history.replaceState 方法，\n  // 用于捕获 React 或者 Vue 框架路由变化\n  window.history.replaceState = patchedUpdateState(\n    window.history.replaceState,\n    "replaceState"\n  );\n\n  if (window.singleSpaNavigate) {\n    console.warn(\n      formatErrorMessage(\n        41,\n        __DEV__ &&\n          "single-spa has been loaded twice on the page. This can result in unexpected behavior."\n      )\n    );\n  } else {\n    /* For convenience in `onclick` attributes, we expose a global function for navigating to\n     * whatever an <a> tag\'s href is.\n     */\n    window.singleSpaNavigate = navigateToUrl;\n  }\n}\n\nfunction parseUri(str) {\n  const anchor = document.createElement("a");\n  anchor.href = str;\n  return anchor;\n}\n'})}),"\n",(0,r.jsxs)(e.h2,{id:"lifecycles-解析",children:[(0,r.jsx)(e.code,{children:"lifecycles"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#lifecycles-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"toloadpromise-解析",children:[(0,r.jsx)(e.code,{children:"toLoadPromise"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#toloadpromise-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"toLoadPromise"})," 本质上不是微应用提供的生命周期函数，而是注册加载 API 时需要提供的激活加载函数，它可以在 single-spa 调用 ",(0,r.jsx)(e.code,{children:"start"})," 函数后加载，也可以在初始化微应用的路由被激活时触发加载："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'export function toLoadPromise(app) {\n  console.log(\n    "[lifecycles/load.js - toLoadPromise]: toLoadPromise 函数开始执行...",\n    app.name,\n    app.status\n  );\n\n  // 开启微任务，异步执行微应用的加载函数\n  return Promise.resolve().then(() => {\n    console.log(\n      "[lifecycles/load.js - toLoadPromise]: toLoadPromise Promise.resolve 开始执行, 开始检测 app.loadPromise 是否已经执行过。",\n      app.name,\n      app.status\n    );\n\n    // 如果 app.loadPromise 存在，\n    // 直接返回 app.loadPromise\n    // 这里可以确保同一个 app 只会执行一次 loadApp 方法\n\n    // 例如注册微应用时会调用 loadApps 方法，\n    // 会执行微应用的 toLoadPromise，\n    // 此时会缓存 app.loadPromise\n    \n    // 而启动 start 函数最终调用 performAppChanges 时还会执行微应用的 toLoadPromise\n    // 为了避免重复执行 app.loadPromise 方法，\n    // 这里会直接返回 app.loadPromise（Promise 对象）\n    if (app.loadPromise) {\n      console.log(\n        "[lifecycles/load.js - toLoadPromise]: 已经执行过 app.loadPromise，直接返回对应的 Promise 结果。",\n        app.name,\n        app.status\n      );\n      return app.loadPromise;\n    }\n\n    // 如果 app.status 不是 NOT_LOADED 和 LOAD_ERROR，直接返回 app\n    if (app.status !== NOT_LOADED && app.status !== LOAD_ERROR) {\n      return app;\n    }\n\n    // 将 app.status 设置为 LOADING_SOURCE_CODE\n    app.status = LOADING_SOURCE_CODE;\n\n    let appOpts, isUserErr;\n\n    console.log(\n      "[lifecycles/load.js - toLoadPromise]: app.loadPromise 开始执行...",\n      app.name,\n      app.status\n    );\n\n    // 使用 app.loadPromise 缓存 app 的加载，\n    // 避免在 loadApps 以及 performAppChanges 时重复加载\n    return (app.loadPromise = Promise.resolve()\n      .then(() => {\n        console.log(\n          "[lifecycles/load.js - toLoadPromise]: 在 Promise.resolve 中开始执行 app.loadPromise...",\n          app.name,\n          app.status\n        );\n\n        console.log(\n          "[lifecycles/load.js - toLoadPromise]: 准备执行 app.loadApp（registerApplication 的第二个参数 app）...",\n          app.name,\n          app.status\n        );\n        // 这里的 loadApp 其实就是 registerApplication 的第二个参数\n        // 在主应用中使用 window.fetch 获取子应用的资源，\n        // 执行后需要返回 Promise，\n        // 并且返回的是子应用的生命周期函数对象\n        const loadPromise = app.loadApp(getProps(app));\n        // 如果 loadPromise 不是 Promise 对象，抛出异常\n        if (!smellsLikeAPromise(loadPromise)) {\n          // The name of the app will be prepended to this error message inside of the handleAppError function\n          // app.loadApp 返回的不是 Promise 对象，抛出异常\n          isUserErr = true;\n          throw Error(\n            formatErrorMessage(\n              33,\n              __DEV__ &&\n                `single-spa loading function did not return a promise. Check the second argument to registerApplication(\'${toName(\n                  app\n                )}\', loadingFunction, activityFunction)`,\n              toName(app)\n            )\n          );\n        }\n\n        // 这里的 val 其实就是 loadApp 的 Promise 返回值\n        // 也就是 registerApplication 的第二个参数 app 的返回值\n        \n        // 例如：() => import("react-micro-app")，\n        // 返回的是一个 Promise\n        \n        // 例如：() => Promise.resolve({ bootstrap: async () => {}, mount, unmount })，\n        // 返回的是一个 Promise\n        \n        // 所以 val 就是各个子应用的生命周期函数组成的对象，\n        // 例如：{ bootstrap: async () => {}, mount, unmount }\n        return loadPromise.then((val) => {\n          console.log(\n            "[lifecycles/load.js - toLoadPromise]: app.loadApp 执行完成，开始检测子应用的生命周期函数是否符合要求...",\n            app.name,\n            app.status\n          );\n\n          app.loadErrorTime = null;\n\n          appOpts = val;\n\n          let validationErrMessage, validationErrCode;\n\n          if (typeof appOpts !== "object") {\n            validationErrCode = 34;\n            if (__DEV__) {\n              validationErrMessage = `does not export anything`;\n            }\n          }\n\n          // 判断 appOpts 的 bootstrap、mount、unmount 是否符合要求\n          if (\n            // ES Modules don\'t have the Object prototype\n            // ES 模块没有 Object 原型\n            Object.prototype.hasOwnProperty.call(appOpts, "bootstrap") &&\n            !validLifecycleFn(appOpts.bootstrap)\n          ) {\n            validationErrCode = 35;\n            if (__DEV__) {\n              validationErrMessage = `does not export a valid bootstrap function or array of functions`;\n            }\n          }\n\n          if (!validLifecycleFn(appOpts.mount)) {\n            validationErrCode = 36;\n            if (__DEV__) {\n              validationErrMessage = `does not export a mount function or array of functions`;\n            }\n          }\n\n          if (!validLifecycleFn(appOpts.unmount)) {\n            validationErrCode = 37;\n            if (__DEV__) {\n              validationErrMessage = `does not export a unmount function or array of functions`;\n            }\n          }\n\n          const type = objectType(appOpts);\n\n          if (validationErrCode) {\n            let appOptsStr;\n            try {\n              appOptsStr = JSON.stringify(appOpts);\n            } catch {}\n            console.error(\n              formatErrorMessage(\n                validationErrCode,\n                __DEV__ &&\n                  `The loading function for single-spa ${type} \'${toName(\n                    app\n                  )}\' resolved with the following, which does not have bootstrap, mount, and unmount functions`,\n                type,\n                toName(app),\n                appOptsStr\n              ),\n              appOpts\n            );\n            handleAppError(validationErrMessage, app, SKIP_BECAUSE_BROKEN);\n            return app;\n          }\n\n          if (appOpts.devtools && appOpts.devtools.overlays) {\n            app.devtools.overlays = assign(\n              {},\n              app.devtools.overlays,\n              appOpts.devtools.overlays\n            );\n          }\n\n          // 设置 app 的状态为 NOT_BOOTSTRAPPED\n          app.status = NOT_BOOTSTRAPPED;\n          // 将 appOpts 中的周期函数扁平化\n          app.bootstrap = flattenFnArray(appOpts, "bootstrap");\n          app.mount = flattenFnArray(appOpts, "mount");\n          app.unmount = flattenFnArray(appOpts, "unmount");\n          app.unload = flattenFnArray(appOpts, "unload");\n          app.timeouts = ensureValidAppTimeouts(appOpts.timeouts);\n\n          // 删除 app.loadPromise，表明 app.loadPromise 已经执行完成\n          // 下一次执行 toLoadPromise 时会重新执行 app.loadPromise\n          delete app.loadPromise;\n\n          console.log(\n            "[lifecycles/load.js - toLoadPromise]:  app.loadApp 返回的周期函数解析完成，所有周期函数符合要求。",\n            app.name,\n            app.status\n          );\n\n          return app;\n        });\n      })\n      .catch((err) => {\n        delete app.loadPromise;\n\n        let newStatus;\n        if (isUserErr) {\n          // 经常会在微前端中出现这种情况，执行 app.loadApp 时返回的不是 Promise 对象\n          // 这里会将 app 的状态设置为 SKIP_BECAUSE_BROKEN\n          newStatus = SKIP_BECAUSE_BROKEN;\n        } else {\n          // 如果 app.loadApp 执行失败，将 app 的状态设置为 LOAD_ERROR\n          newStatus = LOAD_ERROR;\n          app.loadErrorTime = new Date().getTime();\n        }\n        handleAppError(err, app, newStatus);\n\n        return app;\n      }));\n  });\n}\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"tobootstrappromise-解析",children:[(0,r.jsx)(e.code,{children:"toBootstrapPromise"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#tobootstrappromise-解析",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'export function toBootstrapPromise(appOrParcel, hardFail) {\n  console.log(\n    "[lifecycles/bootstrap.js - toBootstrapPromise]: toBootstrapPromise 函数开始执行...",\n    appOrParcel.name,\n    appOrParcel.status\n  );\n  // 开启微任务，异步执行微应用的加载函数\n  return Promise.resolve().then(() => {\n    console.log(\n      "[lifecycles/bootstrap.js - toBootstrapPromise]: toBootstrapPromise Promise.resolve 开始执行...",\n      appOrParcel.name,\n      appOrParcel.status\n    );\n\n    // 如果 appOrParcel.status 不是 NOT_BOOTSTRAPPED，直接返回 appOrParcel\n    if (appOrParcel.status !== NOT_BOOTSTRAPPED) {\n      return appOrParcel;\n    }\n\n    // 将 appOrParcel.status 设置为 BOOTSTRAPPING\n    appOrParcel.status = BOOTSTRAPPING;\n\n    if (!appOrParcel.bootstrap) {\n      // Default implementation of bootstrap\n      return Promise.resolve().then(successfulBootstrap);\n    }\n\n    console.log(\n      "[lifecycles/bootstrap.js - toBootstrapPromise]: 准备执行子应用的 bootstrap 周期函数...",\n      appOrParcel.name,\n      appOrParcel.status\n    );\n    // 执行子应用的 bootstrap 函数（注意使用 resonableTime 包裹，是为了添加执行的超时逻辑）\n    return reasonableTime(appOrParcel, "bootstrap")\n      .then(successfulBootstrap)\n      .catch((err) => {\n        if (hardFail) {\n          throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n        } else {\n          handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          return appOrParcel;\n        }\n      });\n  });\n\n  function successfulBootstrap() {\n    // boostrap 生命周期函数执行成功, 将 appOrParcel.status 设置为 NOT_MOUNTED\n    appOrParcel.status = NOT_MOUNTED;\n    console.log(\n      "[lifecycles/bootstrap.js - toBootstrapPromise]: 子应用的 bootstrap 周期函数执行成功",\n      appOrParcel.name,\n      appOrParcel.status\n    );\n    return appOrParcel;\n  }\n}\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"tomountpromise-解析",children:[(0,r.jsx)(e.code,{children:"toMountPromise"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#tomountpromise-解析",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'export function toMountPromise(appOrParcel, hardFail) {\n  console.log(\n    "[lifecycles/mount.js - toMountPromise]: toMountPromise 函数开始执行...",\n    appOrParcel.name,\n    appOrParcel.status\n  );\n\n  // 开启微任务，异步执行微应用的加载函数\n  return Promise.resolve().then(() => {\n    console.log(\n      "[lifecycles/mount.js - toMountPromise]: toMountPromise Promise.resolve 开始执行...",\n      appOrParcel.name,\n      appOrParcel.status\n    );\n\n    // 如果 appOrParcel.status 不是 NOT_MOUNTED，\n    // 直接返回 appOrParcel\n    if (appOrParcel.status !== NOT_MOUNTED) {\n      return appOrParcel;\n    }\n\n    // 如果是第一次挂载子应用，\n    // 触发 single-spa:before-first-mount 事件\n    if (!beforeFirstMountFired) {\n      window.dispatchEvent(new CustomEvent("single-spa:before-first-mount"));\n      beforeFirstMountFired = true;\n    }\n\n    console.log(\n      "[lifecycles/mount.js - toMountPromise]: 准备执行子应用的 mount 周期函数...",\n      appOrParcel.name,\n      appOrParcel.status\n    );\n\n    // 触发子应用的 mount 函数（注意使用 resonableTime 包裹，是为了添加执行的超时逻辑）\n    return reasonableTime(appOrParcel, "mount")\n      .then(() => {\n        // mount 生命周期函数执行成功, \n        // 将 appOrParcel.status 设置为 MOUNTED\n        appOrParcel.status = MOUNTED;\n\n        // 如果是第一次挂载子应用，触发 single-spa:first-mount 事件\n        if (!firstMountFired) {\n          window.dispatchEvent(new CustomEvent("single-spa:first-mount"));\n          firstMountFired = true;\n        }\n        console.log(\n          "[lifecycles/mount.js - toMountPromise]: 子应用的 mount 周期函数执行成功",\n          appOrParcel.name,\n          appOrParcel.status\n        );\n\n        return appOrParcel;\n      })\n      .catch((err) => {\n        // If we fail to mount the appOrParcel, we should attempt to unmount it before putting in SKIP_BECAUSE_BROKEN\n        // We temporarily put the appOrParcel into MOUNTED status so that toUnmountPromise actually attempts to unmount it\n        // instead of just doing a no-op.\n        appOrParcel.status = MOUNTED;\n        return toUnmountPromise(appOrParcel, true).then(\n          setSkipBecauseBroken,\n          setSkipBecauseBroken\n        );\n\n        function setSkipBecauseBroken() {\n          if (!hardFail) {\n            handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n            return appOrParcel;\n          } else {\n            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          }\n        }\n      });\n  });\n}\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"tounmountpromise-解析",children:[(0,r.jsx)(e.code,{children:"toUnmountPromise"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#tounmountpromise-解析",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'export function toUnmountPromise(appOrParcel, hardFail) {\n  console.log(\n    "[lifecycles/unmount.js - toUnmountPromise]: 开始执行 toUnmountPromise 函数..."\n  );\n\n  // 开启微任务，异步执行微应用的卸载函数\n  return Promise.resolve().then(() => {\n    console.log(\n      "[lifecycles/unmount.js - toUnmountPromise]: toUnmountPromise Promise.resolve 开始执行...",\n      appOrParcel.name,\n      appOrParcel.status\n    );\n\n    // 如果 appOrParcel.status 不是 MOUNTED，直接返回 appOrParcel\n    if (appOrParcel.status !== MOUNTED) {\n      return appOrParcel;\n    }\n\n    // 将 appOrParcel.status 设置为 UNMOUNTING\n    appOrParcel.status = UNMOUNTING;\n\n    // 没有涉及到 Parcel 的逻辑，这里暂时不用考虑\n    const unmountChildrenParcels = Object.keys(appOrParcel.parcels).map(\n      (parcelId) => appOrParcel.parcels[parcelId].unmountThisParcel()\n    );\n\n    let parcelError;\n\n    return (\n      Promise.all(unmountChildrenParcels)\n        // 执行子应用的 unmount 函数\n        .then(unmountAppOrParcel, (parcelError) => {\n          // There is a parcel unmount error\n          return unmountAppOrParcel().then(() => {\n            // Unmounting the app/parcel succeeded, but unmounting its children parcels did not\n            const parentError = Error(parcelError.message);\n            if (hardFail) {\n              throw transformErr(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n            } else {\n              handleAppError(parentError, appOrParcel, SKIP_BECAUSE_BROKEN);\n            }\n          });\n        })\n        .then(() => appOrParcel)\n    );\n\n    function unmountAppOrParcel() {\n      console.log(\n        "[lifecycles/unmount.js - toUnmountPromise]: 准备执行子应用的 unmount 周期函数...",\n        appOrParcel.name,\n        appOrParcel.status\n      );\n\n      // We always try to unmount the appOrParcel, even if the children parcels failed to unmount.\n      // 执行子应用的 unmount 函数（注意使用 resonableTime 包裹，是为了添加执行的超时逻辑）\n      return reasonableTime(appOrParcel, "unmount")\n        .then(() => {\n          // The appOrParcel needs to stay in a broken status if its children parcels fail to unmount\n          if (!parcelError) {\n            // 如果子应用的 unmount 函数执行成功，将 appOrParcel.status 设置为 NOT_MOUNTED\n            appOrParcel.status = NOT_MOUNTED;\n          }\n\n          console.log(\n            "[lifecycles/unmount.js - toUnmountPromise]: 子应用的 unmount 周期函数执行成功",\n            appOrParcel.name,\n            appOrParcel.status\n          );\n        })\n        .catch((err) => {\n          if (hardFail) {\n            throw transformErr(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          } else {\n            handleAppError(err, appOrParcel, SKIP_BECAUSE_BROKEN);\n          }\n        });\n    }\n  });\n}\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"tounloadpromise-解析",children:[(0,r.jsx)(e.code,{children:"toUnloadPromise"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#tounloadpromise-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["single-spa 对外提供了 ",(0,r.jsx)(e.code,{children:"unloadApplication"})," 函数，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"/**\n * @description unload 应用\n * @export\n * @param appName 应用名称\n * @param [opts={ waitForUnmount: false }]\n * @returns {*}\n */\nexport function unloadApplication(appName, opts = { waitForUnmount: false }) {\n  if (typeof appName !== \"string\") {\n    throw Error(\n      formatErrorMessage(\n        26,\n        __DEV__ && `unloadApplication requires a string 'appName'`\n      )\n    );\n  }\n\n  // 查找应用\n  const app = find(apps, (App) => toName(App) === appName);\n  if (!app) {\n    throw Error(\n      formatErrorMessage(\n        27,\n        __DEV__ &&\n          `Could not unload application '${appName}' because no such application has been registered`,\n        appName\n      )\n    );\n  }\n\n  // 获取应用的 unload 信息\n  const appUnloadInfo = getAppUnloadInfo(toName(app));\n  // 如果应用应用需要等待 unmount，那么将应用添加到 unload 列表中\n  if (opts && opts.waitForUnmount) {\n    // We need to wait for unmount before unloading the app\n    // 如果当前应用已经在等待 unload，那么直接返回 appUnloadInfo.promise\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this, too\n      return appUnloadInfo.promise;\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      const promise = new Promise((resolve, reject) => {\n        // 将应用添加到 unload 列表中\n        addAppToUnload(app, () => promise, resolve, reject);\n      });\n      return promise;\n    }\n    // 否则，直接 unload 应用\n  } else {\n    /* We should unmount the app, unload it, and remount it immediately.\n     */\n\n    let resultPromise;\n\n    // 如果当前应用已经在等待 unload\n    if (appUnloadInfo) {\n      // Someone else is already waiting for this app to unload\n      resultPromise = appUnloadInfo.promise;\n      /// 直接 unload 应用\n      immediatelyUnloadApp(app, appUnloadInfo.resolve, appUnloadInfo.reject);\n    } else {\n      // We're the first ones wanting the app to be resolved.\n      resultPromise = new Promise((resolve, reject) => {\n        // 将应用添加到去加载列表中\n        addAppToUnload(app, () => resultPromise, resolve, reject);\n        // 直接 unload 应用\n        immediatelyUnloadApp(app, resolve, reject);\n      });\n    }\n\n    return resultPromise;\n  }\n}\n\nfunction immediatelyUnloadApp(app, resolve, reject) {\n  // 执行微应用的 unmount 生命周期函数\n  toUnmountPromise(app)\n    // 执行微应用的 unload 生命周期函数\n    .then(toUnloadPromise)\n    .then(() => {\n      resolve();\n      setTimeout(() => {\n        // reroute, but the unload promise is done\n        console.log(\n          \"[applications/apps.js - immediatelyUnloadApp] 在 immediatelyUnloadApp 中准备执行 reroute 函数...\"\n        );\n        reroute();\n      });\n    })\n    .catch(reject);\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["当外部调用上述函数时会将需要 ",(0,r.jsx)(e.code,{children:"unload"})," 的微应用先通过 ",(0,r.jsx)(e.code,{children:"addAppToUnload"})," 添加到 ",(0,r.jsx)(e.code,{children:"appsToUnload"})," 中，然后通过 ",(0,r.jsx)(e.code,{children:"immediatelyUnloadApp"})," 立即执行 ",(0,r.jsx)(e.code,{children:"toUnmountPromise"}),"，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'const appsToUnload = {};\n\nexport function toUnloadPromise(app) {\n  // 开启微任务，异步执行微应用的去加载函数\n  return Promise.resolve().then(() => {\n    // 如果外部调用 unloadApplication，\n    // 那么 appsToUnload 中会有对应的 app 信息\n    const unloadInfo = appsToUnload[toName(app)];\n    // 如果不存在 unloadInfo，\n    // 说明外部没有调用 unloadApplication 卸载应用，\n    // 或者微应用 unloadInfo 发生了变化，直接返回 app\n    if (!unloadInfo) {\n      /* No one has called unloadApplication for this app,\n       */\n      return app;\n    }\n\n    // 如果 app.status 为 NOT_LOADED，\n    // 说明 app 从未加载或者已经被卸载了，\n    // 直接清理掉 app 的状态\n    if (app.status === NOT_LOADED) {\n      /* This app is already unloaded. We just need to clean up\n       * anything that still thinks we need to unload the app.\n       */\n      finishUnloadingApp(app, unloadInfo);\n      return app;\n    }\n\n    // 如果 app.status 为 UNLOADING，\n    // 说明 app 正在卸载中，直接返回 unloadInfo.promise\n    if (app.status === UNLOADING) {\n      /* Both unloadApplication and reroute want to unload this app.\n       * It only needs to be done once, though.\n       */\n      // 在 unloadApplication 和 reroute 中都会调用 toUnloadPromise，\n      // 但是只需要执行一次（防止重复执行），\n      // 所以直接返回 unloadInfo.promise\n      return unloadInfo.promise.then(() => app);\n    }\n\n    // 如果 app.status 不是 NOT_MOUNTED 和 LOAD_ERROR，\n    // 则说明 app 没有被 unmount\n    \n    // 这里需要等待 app unmount 完成后再执行 app unload 操作\n    if (app.status !== NOT_MOUNTED && app.status !== LOAD_ERROR) {\n      /* The app cannot be unloaded until it is unmounted.\n       */\n      return app;\n    }\n\n    // 如果 app.status 为 LOAD_ERROR，\n    // 则说明 app 加载失败，不需要进行 unload 操作\n    // 否则需要执行 app unload 操作\n    const unloadPromise =\n      app.status === LOAD_ERROR\n        ? Promise.resolve()\n        : // 注意使用 resonableTime 包裹，是为了添加执行的超时逻辑\n          reasonableTime(app, "unload");\n\n    // 将 app.status 设置为 UNLOADING，表示 app 正在卸载中\n    app.status = UNLOADING;\n\n    return unloadPromise\n      .then(() => {\n        // 如果 app 的 unload 函数执行成功，\n        // 清理 app 的状态，\n        // 删除 app 的生命周期函数，重置 app 的状态\n        finishUnloadingApp(app, unloadInfo);\n        return app;\n      })\n      .catch((err) => {\n        errorUnloadingApp(app, unloadInfo, err);\n        return app;\n      });\n  });\n}\n\n/**\n * @description 清理 app 的状态，删除 app 的生命周期函数，重置 app 的状态\n * @param app 应用\n * @param unloadInfo 微应用卸载信息\n */\nfunction finishUnloadingApp(app, unloadInfo) {\n  delete appsToUnload[toName(app)];\n\n  // Unloaded apps don\'t have lifecycles\n  // 删除 app 的生命周期函数\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  // 重置 app 的状态为 NOT_LOADED\n  app.status = NOT_LOADED;\n\n  /* resolve the promise of whoever called unloadApplication.\n   * This should be done after all other cleanup/bookkeeping\n   */\n  unloadInfo.resolve();\n}\n\nfunction errorUnloadingApp(app, unloadInfo, err) {\n  delete appsToUnload[toName(app)];\n\n  // Unloaded apps don\'t have lifecycles\n  delete app.bootstrap;\n  delete app.mount;\n  delete app.unmount;\n  delete app.unload;\n\n  handleAppError(err, app, SKIP_BECAUSE_BROKEN);\n  unloadInfo.reject(err);\n}\n\n/**\n * @description 将微应用添加到去加载列表中（外部调用 unloadApplication 时会触发）\n * @export\n * @param app 微应用\n * @param promiseGetter 获取微应用去加载 Promise 的函数\n * @param resolve Promise 的 resolve 函数\n * @param reject Promise 的 reject 函数\n */\nexport function addAppToUnload(app, promiseGetter, resolve, reject) {\n  // 将微应用添加到去加载列表 appsToUnload 中\n  appsToUnload[toName(app)] = { app, resolve, reject };\n  Object.defineProperty(appsToUnload[toName(app)], "promise", {\n    get: promiseGetter,\n  });\n}\n\n/**\n * @description 获取微应用去加载信息\n * @export\n * @param appName 微应用名称\n * @returns {*} 微应用去加载信息\n */\nexport function getAppUnloadInfo(appName) {\n  return appsToUnload[appName];\n}\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"reasonabletime-解析",children:[(0,r.jsx)(e.code,{children:"reasonableTime"})," 解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#reasonabletime-解析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"toLoadPromise"}),"、",(0,r.jsx)(e.code,{children:"toBootstrapPromise"})," 以及 ",(0,r.jsx)(e.code,{children:"toMountPromise"})," 等最终都会调用 ",(0,r.jsx)(e.code,{children:"reasonableTime"}),"，由于外部生命周期函数的执行不可控，single-spa 在 ",(0,r.jsx)(e.code,{children:"reasonableTime"})," 中提供超时执行的计算逻辑，防止外部生命周期函数执行时间过长从而影响框架的稳定性，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"/**\n * @description 执行微应用的生命周期函数，并且设置超时时间\n * @export\n * @param appOrParcel 微应用信息\n * @param lifecycle 生命周期名称，例如：bootstrap、mount、unmount、unload\n * @returns {*}\n */\nexport function reasonableTime(appOrParcel, lifecycle) {\n  console.log(\n    \"[applications/timeouts.js - reasonableTime]: 开始执行 reasonableTime 函数...\",\n    appOrParcel.name,\n    appOrParcel.status,\n    lifecycle\n  );\n\n  // 获取微应用的超时配置\n  const timeoutConfig = appOrParcel.timeouts[lifecycle];\n  // 获取超时时间\n  const warningPeriod = timeoutConfig.warningMillis;\n  const type = objectType(appOrParcel);\n\n  // 返回一个 Promise 对象\n  return new Promise((resolve, reject) => {\n    let finished = false;\n    let errored = false;\n\n    console.log(\n      `[applications/timeouts.js - reasonableTime]: 开始执行子应用的 ${lifecycle} 函数...`,\n      appOrParcel.name,\n      appOrParcel.status,\n      getProps(appOrParcel)\n    );\n\n    // 执行微应用的生命周期函数\n    // 在 toLoadPromise 函数中，\n    // 已经获取并解析了微应用的生命周期函数，\n    // 并且将其缓存到 app 对象中\n    // 因此在这里可以执行 appOrParcel[lifecycle]\n\n    // 和在 toLoadPromise 中执行 app.loadApp 函数一样，\n    // 生命周期函数的执行也需要传入 props 参数（这是实现主应用和微应用通信的主要方式）\n    appOrParcel[lifecycle](getProps(appOrParcel))\n      .then((val) => {\n        // 如果生命周期函数执行成功，将 finished 设置为 true，并且调用 resolve 函数\n        finished = true;\n        resolve(val);\n      })\n      .catch((val) => {\n        finished = true;\n        reject(val);\n      });\n\n    // 超时处理\n    setTimeout(() => maybeTimingOut(1), warningPeriod);\n    // 超时处理\n    setTimeout(() => maybeTimingOut(true), timeoutConfig.millis);\n\n    const errMsg = formatErrorMessage(\n      31,\n      __DEV__ &&\n        `Lifecycle function ${lifecycle} for ${type} ${toName(\n          appOrParcel\n        )} lifecycle did not resolve or reject for ${timeoutConfig.millis} ms.`,\n      lifecycle,\n      type,\n      toName(appOrParcel),\n      timeoutConfig.millis\n    );\n\n    function maybeTimingOut(shouldError) {\n      // 如果 finished 为 true，说明生命周期函数执行成功，不需要处理超时\n      if (!finished) {\n        if (shouldError === true) {\n          errored = true;\n          if (timeoutConfig.dieOnTimeout) {\n            reject(Error(errMsg));\n          } else {\n            console.error(errMsg);\n            //don't resolve or reject, we're waiting this one out\n          }\n        } else if (!errored) {\n          const numWarnings = shouldError;\n          const numMillis = numWarnings * warningPeriod;\n          console.warn(errMsg);\n          if (numMillis + warningPeriod < timeoutConfig.millis) {\n            setTimeout(() => maybeTimingOut(numWarnings + 1), warningPeriod);\n          }\n        }\n      }\n    }\n  });\n}\n"})}),"\n",(0,r.jsxs)(e.h1,{id:"场景剖析",children:["场景剖析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#场景剖析",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在本课程我们会通过以下几个简单场景来剖析 single-spa 的内部执行流程："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["初始化没有激活微应用，例如直接访问 ",(0,r.jsx)(e.code,{children:"http://localhost:3001/"})]}),"\n",(0,r.jsxs)(e.li,{children:["初始化激活 Vue 微应用，例如直接访问 ",(0,r.jsx)(e.code,{children:"http://localhost:3001/vue"})]}),"\n",(0,r.jsxs)(e.li,{children:["初始化完成后切换微应用，例如从 ",(0,r.jsx)(e.code,{children:"/vue"})," 切换到 ",(0,r.jsx)(e.code,{children:"/react"})]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：上述解析场景是常见的真实业务场景，例如在管理后台应用中，登录后的应用如果是微前端框架，登录后往往会先进入一个 dashboard 主页，这个主页如果是在主应用中设计，访问的路径是 ",(0,r.jsx)(e.code,{children:"/"}),"，此时没有激活任何 single-spa 微应用。用户在使用的过程中不断切换微应用，则会出现从 ",(0,r.jsx)(e.code,{children:"/vue"})," 切换到 ",(0,r.jsx)(e.code,{children:"/react"})," 的情况，而当用户停留在 ",(0,r.jsx)(e.code,{children:"/vue"})," 并且再次刷新页面时则会出现初始化就需要立即激活某个微应用的场景。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"初始化没有激活微应用",children:["初始化没有激活微应用",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化没有激活微应用",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们重新回顾 Fetch 示例的 single-spa 简化代码，如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import { start, registerApplication } from "single-spa";\n\n// 注册 React 微应用\nregisterApplication({\n  name: \'react\',\n  // app 参数如果是函数，则必须返回 Promise 对象\n  app: () => {\n    return fetchApp([\n      "http://localhost:3000/vendors.js",\n      "http://localhost:3000/main.js",\n    ])\n  },\n  // react 路由可以激活 React 微应用，\n  // 从而执行 app 参数进行微应用的加载和执行\n  activeWhen: \'react\',\n  customProps: {\n    container: "micro-app-container"\n  }\n});\n\n// 注册 Vue 微应用\nregisterApplication({\n  name: \'vue\',\n  app: () => {\n    return fetchApp([\n      "http://localhost:8080/js/chunk-vendors.js",\n      "http://localhost:8080/js/app.js", \n    ])\n  },\n  // vue 路由可以激活 Vue 微应用，从而执行 app 参数进行微应用的加载和执行\n  activeWhen: \'vue\',\n  customProps: {\n    container: "micro-app-container"\n  }\n});\n\nstart();\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的\xa0",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/analyze/single-spa",target:"_blank",rel:"noopener noreferrer",children:"analyze/single-spa"}),"\xa0分支获取。这里建议下载该代码查看 ",(0,r.jsx)(e.code,{children:"pakcages/single-spa"})," 的源码，内部加入了源码注释，也可以直接调试源代码加深对于源码的理解。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["其中 ",(0,r.jsx)(e.code,{children:"fetchApp"})," 方法主要通过 ",(0,r.jsx)(e.code,{children:"window.fetch"})," 来获取微应用的执行脚本："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function async fetchApp(urls: string[]) {\n  for (let url of urls) {\n    const res = await window.fetch(url);\n    const text = await res.text();\n    // 使用 eval 执行\n    (0, eval)(text);\n  }\n  \n  // 执行微应用的代码后立即获取对应的生命周期函数\n  const keys = Object.keys(window);\n  const lifeCycles = window[keys[keys.length - 1]];\n  return lifeCycles;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["从上述代码可以发现，当我们将路由切换到 ",(0,r.jsx)(e.code,{children:"/react"})," 时会激活 React 微应用，切换到 ",(0,r.jsx)(e.code,{children:"/vue"})," 时会激活 Vue 微应用，但是当我们默认打开 ",(0,r.jsx)(e.code,{children:"/"})," 时不会激活任何微应用。假设我们首次进入主应用时打开的地址是 ",(0,r.jsx)(e.code,{children:"/"}),"，此时没有激活任何微应用，我们来查看一下 single-spa 的执行流程，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:f,alt:"no-app.svg"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：可以下载图片到本地查看，或者在浏览器的新标签页打开并放大查看。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["我们可以简化上述 UML 流程图，在主应用中使用 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/apps.js#L123",target:"_blank",rel:"noopener noreferrer",children:"registerApplication"})," 注册微应用的执行流程如下所示，需要注意每注册一个微应用以下流程都会执行一遍："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:g,alt:"load-app-1.jpg"})}),"\n",(0,r.jsxs)(e.p,{children:["从上述执行流程可以发现，每注册一个微应用 single-spa 都会通过 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/app.helpers.js#L27",target:"_blank",rel:"noopener noreferrer",children:"shouldBeActive"})," 判断当前注册的微应用是否需要激活，如果在注册期间激活微应用则会将其加入 ",(0,r.jsx)(e.code,{children:"appsToLoad"})," 数组，然后通过 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L142",target:"_blank",rel:"noopener noreferrer",children:"loadApps"})," 加载该微应用。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：通过 ",(0,r.jsx)(e.code,{children:"appsToLoad"})," 批量加载微应用时需要获取和解析微应用的生命周期函数，此时必须在执行微应用的代码后才能获取它所导出的生命周期函数。因此，微应用代码的执行时机不是在微应用加载之前（例如之前的 NPM 示例）就是在微应用加载的过程中实时执行（例如 Script 和 Fetch 示例）。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["微应用注册完成后需要调用 single-spa 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/start.js#L13",target:"_blank",rel:"noopener noreferrer",children:"start"})," 函数启动，它的执行流程如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:m,alt:"start-1"})}),"\n",(0,r.jsxs)(e.p,{children:["从上述流程可以发现，通过\xa0",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/apps.js#L123",target:"_blank",rel:"noopener noreferrer",children:"registerApplication"}),"\xa0注册微应用时只会执行微应用的加载逻辑（执行注册参数 ",(0,r.jsx)(e.code,{children:"app"}),"），但是调用 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/start.js#L13",target:"_blank",rel:"noopener noreferrer",children:"start"})," 函数启动后，single-spa 会调用 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174",target:"_blank",rel:"noopener noreferrer",children:"performAppChanges"})," 批量处理所有需要变化的微应用，除了会对激活的微应用批量进行异步加载，还会批量异步执行微应用的生命周期函数，包括 ",(0,r.jsx)(e.code,{children:"bootstrap"}),"、",(0,r.jsx)(e.code,{children:"mount"}),"、",(0,r.jsx)(e.code,{children:"unmount"})," 以及 ",(0,r.jsx)(e.code,{children:"unload"}),"。"]}),"\n",(0,r.jsxs)(e.h2,{id:"初始化激活-vue-微应用",children:["初始化激活 Vue 微应用",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化激活-vue-微应用",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["如果首次直接访问 ",(0,r.jsx)(e.code,{children:"http://localhost:3001/vue"}),"，那么需要激活 Vue 微应用。我们来查看一下 single-spa 的执行流程，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:u,alt:"vue.svg"})}),"\n",(0,r.jsxs)(e.p,{children:["从上述 UML 时序图可以看出 ",(0,r.jsx)(e.code,{children:"toLoadPromise"}),"、",(0,r.jsx)(e.code,{children:"toMountPromise"}),"、",(0,r.jsx)(e.code,{children:"toBootstrapPromise"}),"、",(0,r.jsx)(e.code,{children:"toUnloadPromise"})," 以及 ",(0,r.jsx)(e.code,{children:"toUnmountPromise"})," 都是在微任务中异步执行，因此刷新 ",(0,r.jsx)(e.code,{children:"/vue"})," 路由时可以确保主应用的同步代码先执行完毕，例如 Vue 或者 React 框架的路由代码，等框架的路由切换完成后，才会执行 single-spa 中微应用的生命周期函数，确保运行时序的正确性。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：可以下载图片到本地查看，或者在浏览器的新标签页打开并放大查看。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["我们同样可以简化上述 UML 流程图，其中在主应用中使用\xa0",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/apps.js#L123",target:"_blank",rel:"noopener noreferrer",children:"registerApplication"}),"\xa0注册微应用的执行流程如下所示，此时因为激活了 Vue 微应用，在注册 Vue 微应用时会异步加载该微应用，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:"load-app-2.jpg"})}),"\n",(0,r.jsxs)(e.p,{children:["在加载 Vue 微应用的过程中应用的状态会发生 ",(0,r.jsx)(e.code,{children:"NOT_LOADED"})," -> ",(0,r.jsx)(e.code,{children:"LOADING_SOURCE_CODE"})," -> ",(0,r.jsx)(e.code,{children:"NOT_BOOTSTRAPPED"})," 转变。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：需要注意，在 ",(0,r.jsx)(e.code,{children:"LOADING_SOURCE_CODE"})," 阶段经常会出错，此时会异步加载微应用并且解析微应用导出的生命周期函数，还会对这些生命周期函数进行格式校验，开发者在这个阶段一旦没有导出生命周期函数，或者导出的不是 ",(0,r.jsx)(e.code,{children:"async"})," 函数，都会使得 single-spa 解析不到正确格式的生命周期函数而产生报错。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["微应用注册完成后需要调用 single-spa 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/start.js#L13",target:"_blank",rel:"noopener noreferrer",children:"start"})," 函数启动，此时因为 Vue 微应用被激活，在 ",(0,r.jsx)(e.code,{children:"start"})," 函数启动并且 Vue 微应用的生命周期函数解析完毕后，再次判断 Vue 微应用是否激活，如果仍然激活则会执行微应用的 ",(0,r.jsx)(e.code,{children:"bootstrap"})," 和 ",(0,r.jsx)(e.code,{children:"mount"})," 生命周期函数，从而可以渲染出 Vue 微应用，它的执行流程如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:"start-2.jpg"})}),"\n",(0,r.jsxs)(e.p,{children:["完成 Vue 应用的激活、加载和渲染后，应用的状态会发生 ",(0,r.jsx)(e.code,{children:"NOT_LOADED"})," -> ",(0,r.jsx)(e.code,{children:"LOADING_SOURCE_CODE"})," -> ",(0,r.jsx)(e.code,{children:"NOT_BOOTSTRAPPED"})," -> ",(0,r.jsx)(e.code,{children:"BOOTSTRAPPING"})," -> ",(0,r.jsx)(e.code,{children:"NOT_MOUNTED"})," -> ",(0,r.jsx)(e.code,{children:"MOUNTED"})," 转变。"]}),"\n",(0,r.jsxs)(e.p,{children:["从上述流程可以发现，失活微应用的 ",(0,r.jsx)(e.code,{children:"unmout"}),"、",(0,r.jsx)(e.code,{children:"unload"})," 和激活微应用的 ",(0,r.jsx)(e.code,{children:"loadApp"}),"、",(0,r.jsx)(e.code,{children:"bootstrap"})," 同时执行，而激活微应用的 ",(0,r.jsx)(e.code,{children:"mount"})," 则需要依赖所有失活微应用的 ",(0,r.jsx)(e.code,{children:"unmount"})," 和 ",(0,r.jsx)(e.code,{children:"unload"})," 执行完毕。除此之外，不管是在注册微应用还是 ",(0,r.jsx)(e.code,{children:"start"})," 函数中，都会实时执行 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/applications/app.helpers.js#L27",target:"_blank",rel:"noopener noreferrer",children:"shouldBeActive"})," 来判断应用的激活和失活情况，因此首次直接访问 ",(0,r.jsx)(e.code,{children:"http://localhost:3001/vue"})," 时能够立即判断出需要激活的 Vue 微应用。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：在 ",(0,r.jsx)(e.code,{children:"loadApps"})," 中已经批量执行了 ",(0,r.jsx)(e.code,{children:"toLoadPromise"}),"，为什么在 ",(0,r.jsx)(e.code,{children:"performAppChanges"})," 函数中还需要再次执行 ",(0,r.jsx)(e.code,{children:"toLoadPromise"}),"？主要是因为 ",(0,r.jsx)(e.code,{children:"loadApps"})," 只会在应用初始化的注册阶段激活微应用时被执行，而后续的 ",(0,r.jsx)(e.code,{children:"load"})," 处理需要依赖路由变化后 ",(0,r.jsx)(e.code,{children:"performAppChanges"})," 执行。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"初始化完成后切换微应用",children:["初始化完成后切换微应用",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化完成后切换微应用",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["首次直接访问 ",(0,r.jsx)(e.code,{children:"http://localhost:3001/vue"})," 后，single-spa 会激活 Vue 微应用，然后会依次执行微应用的 ",(0,r.jsx)(e.code,{children:"loadApp"}),"、 ",(0,r.jsx)(e.code,{children:"bootstrap"})," 以及 ",(0,r.jsx)(e.code,{children:"mount"}),"。当 Vue 微应用渲染后，我们可以切换路由来实现微应用的切换，此时如果点击导航从 ",(0,r.jsx)(e.code,{children:"/vue"})," 路由切换到 ",(0,r.jsx)(e.code,{children:"/react"})," 路由，我们来查看一下 single-spa 的执行流程，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:"vue-react.svg"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：可以下载图片到本地查看，或者在浏览器的新标签页打开并放大查看。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"从上述 UML 时序图可以看出，在 single-spa 中需要感知到 React 或者 Vue 框架的路由变化，从而实现微应用的切换。我们可以简化一下上述 UML 流程图，先来剖析一下 single-spa 是如何识别框架的路由变化，它的具体执行流程如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:"nav.jpg"})}),"\n",(0,r.jsxs)(e.p,{children:["signle-spa 在初始化时会先监听 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L187",target:"_blank",rel:"noopener noreferrer",children:"hashchagne"})," 和 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L194",target:"_blank",rel:"noopener noreferrer",children:"popstate"})," 事件的变化，一旦这些事件触发，并且检测到 URL 发生变化，则会调用 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L110",target:"_blank",rel:"noopener noreferrer",children:"urlReroute"})," 函数重新计算需要变化的微应用，最终会执行 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174",target:"_blank",rel:"noopener noreferrer",children:"performAppChanges"}),"  函数批量处理微应用的卸载和加载。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：通常情况下，",(0,r.jsx)(e.code,{children:"hashchage"})," 事件用于监听 ",(0,r.jsx)(e.code,{children:"hash"})," 路由的变化（跟在 ",(0,r.jsx)(e.code,{children:"＃"})," 符号后面的 URL 部分），例如点击锚链接元素、修改 ",(0,r.jsx)(e.code,{children:"location.hash"}),"、浏览器历史导航（前进、后退）、修改导航栏地址、调用 ",(0,r.jsx)(e.code,{children:"location.replace"}),"、",(0,r.jsx)(e.code,{children:"history.go"}),"、",(0,r.jsx)(e.code,{children:"history.back"})," 以及 ",(0,r.jsx)(e.code,{children:"history.forward"})," 等，而 ",(0,r.jsx)(e.code,{children:"popstate"})," 事件用于监听历史记录的变化，例如浏览器历史导航（前进、后退）、调用 ",(0,r.jsx)(e.code,{children:"history.go"}),"、",(0,r.jsx)(e.code,{children:"history.back"})," 以及 ",(0,r.jsx)(e.code,{children:"history.forward"})," 等。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["但是上述监听事件无法处理 React 或者 Vue 框架的路由变化，因为这些框架是调用 ",(0,r.jsx)(e.code,{children:"history.pushState"})," 或者 ",(0,r.jsx)(e.code,{children:"history.replaceState"})," 来更改 URL 地址，而这两个 API 的执行并不会触发 ",(0,r.jsx)(e.code,{children:"popstate"})," 事件。为了捕获框架的路由变化，single-spa 在初始化时会重写 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L237",target:"_blank",rel:"noopener noreferrer",children:"window.history.pushState"})," 和 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L242",target:"_blank",rel:"noopener noreferrer",children:"window.history.replaceState"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["当主应用通过 React Router DOM 的 ",(0,r.jsx)(e.code,{children:"<Link>"})," 标签切换路由时，经过一系列的封装调用最终会抵达 ",(0,r.jsx)(e.code,{children:"history.replaceState"}),"，此时调用的是 single-spa 初始化后重写的 ",(0,r.jsx)(e.code,{children:"replaceState"}),"，然后会触发 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L124",target:"_blank",rel:"noopener noreferrer",children:"patchedUpdateState"})," 函数并",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L164",target:"_blank",rel:"noopener noreferrer",children:"手动创建和分发 popstate 事件"}),"，最终执行 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174",target:"_blank",rel:"noopener noreferrer",children:"performAppChanges"})," 函数进行微应用的加载和卸载处理。"]}),"\n",(0,r.jsxs)(e.p,{children:["除此之外，在 single-spa 的初始化中还会重写 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L205",target:"_blank",rel:"noopener noreferrer",children:"window.addEventListener"})," 和 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L223",target:"_blank",rel:"noopener noreferrer",children:"window.removeEventListener"}),"， 这是为了捕获和延迟执行微应用注册的 ",(0,r.jsx)(e.code,{children:"hashchange"})," 和 ",(0,r.jsx)(e.code,{children:"popstate"})," 事件。例如在微应用激活时触发了 ",(0,r.jsx)(e.code,{children:"popstate"})," 事件，但是此时微应用的代码还没有加载完成，这会使得微应用错过事件监听，因此在 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L142",target:"_blank",rel:"noopener noreferrer",children:"loadApps"})," 执行完毕后会执行 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L394",target:"_blank",rel:"noopener noreferrer",children:"callAllEventListeners"}),"。而如果微应用失活时正好触发了 ",(0,r.jsx)(e.code,{children:"popstate"})," 事件，微应用可能希望在卸载时移除监听 ",(0,r.jsx)(e.code,{children:"hashchange"})," 和 ",(0,r.jsx)(e.code,{children:"popstate"})," 事件，此时 single-spa 可以将事件延迟到微应用卸载后执行，这样微应用在卸载后因为移除了相应的监听事件并不会触发事件的监听执行，所以 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174",target:"_blank",rel:"noopener noreferrer",children:"performAppChanges"})," 会在所有微应用 ",(0,r.jsx)(e.code,{children:"unmount"})," 和 ",(0,r.jsx)(e.code,{children:"unload"})," 后才延迟执行 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L394",target:"_blank",rel:"noopener noreferrer",children:"callAllEventListeners"}),"。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：上述说明可以配合",(0,r.jsx)(e.strong,{children:"源码剖析"}),"的 ",(0,r.jsx)(e.code,{children:"navigation"})," 解析一起理解。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["从上述解析流程我们了解了 single-spa 对于导航事件的处理，当 React 发生从 ",(0,r.jsx)(e.code,{children:"/vue"})," 到 ",(0,r.jsx)(e.code,{children:"/react"})," 的路由变化时，single-spa 会执行 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L124",target:"_blank",rel:"noopener noreferrer",children:"patchedUpdateState"})," 函数并",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L164",target:"_blank",rel:"noopener noreferrer",children:"手动创建和分发 popstate 事件"}),"，然后调用 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/navigation-events.js#L110",target:"_blank",rel:"noopener noreferrer",children:"urlReroute"})," 函数（携带 ",(0,r.jsx)(e.code,{children:"event"})," 事件参数），最终执行 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174",target:"_blank",rel:"noopener noreferrer",children:"performAppChanges"})," 实现 Vue 微应用的卸载和 React 微应用的加载和渲染，最后因为携带了 ",(0,r.jsx)(e.code,{children:"event"})," 参数而延迟执行 ",(0,r.jsx)(e.code,{children:"hashchange"})," 和 ",(0,r.jsx)(e.code,{children:"popstate"})," 事件。此时 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/blob/analyze/single-spa/packages/single-spa/src/navigation/reroute.js#L174",target:"_blank",rel:"noopener noreferrer",children:"performAppChanges"})," 的执行流程如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:"performAppChanges.jpg"})}),"\n",(0,r.jsxs)(e.p,{children:["在上述流程中可以发现，完成 Vue 应用的卸载后，应用的状态会发生从\xa0",(0,r.jsx)(e.code,{children:"MOUNTED"}),"\xa0->\xa0",(0,r.jsx)(e.code,{children:"UNMOUNTING"}),"\xa0->\xa0",(0,r.jsx)(e.code,{children:"NOT_MOUNTED"}),"\xa0的转变，而完成 React 应用的加载和之前 Vue 状态的转变流程一致，会发生从  ",(0,r.jsx)(e.code,{children:"NOT_LOADED"})," -> ",(0,r.jsx)(e.code,{children:"LOADING_SOURCE_CODE"})," -> ",(0,r.jsx)(e.code,{children:"NOT_BOOTSTRAPPED"})," -> ",(0,r.jsx)(e.code,{children:"BOOTSTRAPPING"})," -> ",(0,r.jsx)(e.code,{children:"NOT_MOUNTED"})," -> ",(0,r.jsx)(e.code,{children:"MOUNTED"})," 转变。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：single-spa 的所有生命周期函数执行都是在微任务中执行，这可以确保主应用框架路由的代码先执行完毕，然后处理微应用的加载和卸载。"}),"\n"]}),"\n",(0,r.jsxs)(e.h1,{id:"状态和事件剖析",children:["状态和事件剖析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#状态和事件剖析",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在",(0,r.jsx)(e.strong,{children:"框架解析：引言"}),"中我们讲解了在 MPA 的模式下前端天然可以做到小型应用的拆分，微应用只需要考虑如何根据导航进行跳转，在跳转的过程中无论是新开标签页还是在当前标签页切换应用，浏览器会处理标签页应用的状态的周期事件，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:["从上图可以发现，在标签页应用切换的过程中，浏览器控制了应用运行的",(0,r.jsx)(e.strong,{children:"状态"}),"和",(0,r.jsx)(e.strong,{children:"事件"}),"，其中部分应用状态由用户发起，包括激活、失活、隐藏和终止等，而部分应用的状态则是浏览器自行发起，包括冻结和丢弃。其实 single-spa 中微应用的切换和浏览器中标签页的切换非常相似，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:"yuque_diagram (44).jpg"})}),"\n",(0,r.jsx)(e.p,{children:"如果用户导航到了新的路由，当前 single-spa 在计算应用变化时会参考微应用当下的状态："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["如果还未加载（",(0,r.jsx)(e.code,{children:"NOT_LOADED"}),"）并匹配了路由，会准备加载，状态会变成 ",(0,r.jsx)(e.code,{children:"LOADING_SOURCE_CODE"})]}),"\n",(0,r.jsxs)(e.li,{children:["如果正在加载中（",(0,r.jsx)(e.code,{children:"LOADING_SOURCE_CODE"}),"）并匹配了路由，会继续加载（会命中重复执行）"]}),"\n",(0,r.jsxs)(e.li,{children:["如果已经加载失败（",(0,r.jsx)(e.code,{children:"LOAD_ERROR"}),"）并匹配了路由，会继续加载，重试请求"]}),"\n",(0,r.jsx)(e.li,{children:"..."}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：上图中的虚线指向的状态表明当前微应用在计算变化前所处的状态，而实线则表示微应用的状态变更。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"由于部分事件的触发依赖多个状态的同时变更，因此单独将其进行展示，如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:"yuque_diagram (46).jpg"})}),"\n",(0,r.jsxs)(e.p,{children:["在上述事件中，如果开发者监听了 ",(0,r.jsx)(e.code,{children:"single-spa:before-routing-event"})," 事件并调用了事件传递的 ",(0,r.jsx)(e.code,{children:"cancelNavigation"})," 函数取消导航，那么 single-spa 会立即触发 ",(0,r.jsx)(e.code,{children:"single-spa:before-mount-routing-event"})," 事件，而如果没有取消导航，则在正常执行时会等待所有微应用的卸载 ",(0,r.jsx)(e.code,{children:"unmount"})," 和彻底卸载 ",(0,r.jsx)(e.code,{children:"unload"})," 执行完毕后再触发 ",(0,r.jsx)(e.code,{children:"single-spa:before-mount-routing-event"})," 事件。"]}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本课程从场景剖析、状态和事件剖析、源码剖析三个方面详细讲解了 single-spa 的内部运行原理，如果还想深入了解内部原理，可以结合本课程提供的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/analyze/single-spa",target:"_blank",rel:"noopener noreferrer",children:"analyze/single-spa"}),"\xa0分支逐行调试源码。single-spa 内部的运行原理解析为了解 qiankun 内部的运行机制奠定了基础。在下一个课程中，我们会重点了解如何使用 qiankun 设计微前端。"]})]})}function v(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(j,{...n})}):j(n)}let P=v;v.__RSPRESS_PAGE_META={},v.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F23.%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%EF%BC%9Asingle-spa%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md"]={toc:[{text:"`applications` 解析",id:"applications-解析",depth:2},{text:"`registerApplication` 入参解析",id:"registerapplication-入参解析",depth:3},{text:"参数 2",id:"参数-2",depth:4},{text:"参数 3",id:"参数-3",depth:4},{text:"参数 4",id:"参数-4",depth:4},{text:"`registerApplication` 解析",id:"registerapplication-解析",depth:3},{text:"`sanitizeArguments` 解析",id:"sanitizearguments-解析",depth:3},{text:"`start` 解析",id:"start-解析",depth:2},{text:"`navigation` 解析",id:"navigation-解析",depth:2},{text:"`reroute` 解析",id:"reroute-解析",depth:3},{text:"`getAppChanges` 解析",id:"getappchanges-解析",depth:4},{text:"`loadApps` 解析",id:"loadapps-解析",depth:4},{text:"`performAppChanges` 解析",id:"performappchanges-解析",depth:4},{text:"`getCustomEventDetail` 解析",id:"getcustomeventdetail-解析",depth:4},{text:"`callAllEventListeners` 解析",id:"callalleventlisteners-解析",depth:4},{text:"`finishUpAndReturn` 解析",id:"finishupandreturn-解析",depth:4},{text:"`navigation-events` 解析",id:"navigation-events-解析",depth:3},{text:"`lifecycles` 解析",id:"lifecycles-解析",depth:2},{text:"`toLoadPromise` 解析",id:"toloadpromise-解析",depth:3},{text:"`toBootstrapPromise` 解析",id:"tobootstrappromise-解析",depth:3},{text:"`toMountPromise` 解析",id:"tomountpromise-解析",depth:3},{text:"`toUnmountPromise` 解析",id:"tounmountpromise-解析",depth:3},{text:"`toUnloadPromise` 解析",id:"tounloadpromise-解析",depth:3},{text:"`reasonableTime` 解析",id:"reasonabletime-解析",depth:3},{text:"初始化没有激活微应用",id:"初始化没有激活微应用",depth:2},{text:"初始化激活 Vue 微应用",id:"初始化激活-vue-微应用",depth:2},{text:"初始化完成后切换微应用",id:"初始化完成后切换微应用",depth:2},{text:"小结",id:"小结",depth:2}],title:"状态和事件剖析",headingTitle:"状态和事件剖析",frontmatter:{}}}}]);