"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75820"],{104757:function(e,n,a){a.r(n),a.d(n,{default:()=>K});var t=a(552676),l=a(740453);let s=a.p+"static/image/616a0fdb9602b783acac8239724792eb.5f709a50.gif",r=a.p+"static/image/e856d19e2cb67472cd3dee5b0603e81d.98127a61.webp",c=a.p+"static/image/b049fb4f8785df0331edf638b0d17489.9a1b354c.webp",i=a.p+"static/image/9a10911d0cc0f5447165533257bb3121.ac4f67ef.webp",d=a.p+"static/image/f40db9c74bc0f05abf662988e7641408.0995a5f7.webp",u=a.p+"static/image/a7a2c4900221757ae127de6389fbee43.ea4acf72.webp",p=a.p+"static/image/c1c21d9a6baef940f531ac586aafde9b.0eb00530.webp",o=a.p+"static/image/0a569ef82c0c4993bb500a7fb118cc85.35b4c8d6.webp",h=a.p+"static/image/b1682ae983441875fe0ee50844ea4b53.bfc7777e.webp",f=a.p+"static/image/8f62eb8392335afbdd1496609d8b9cb3.66951967.webp",j=a.p+"static/image/c65977ea57ad74743d403015fab64f6f.fd572301.webp",x=a.p+"static/image/f51e6dd60ff9a8a647c3f3733a03a521.d9f74a81.webp",g=a.p+"static/image/700b59e134e41fa603a8443262895eb3.de4fb728.webp",v=a.p+"static/image/e9c616950f95cd87fedc356062539a2c.094e2ca6.webp",m=a.p+"static/image/06e23a3dc0f50512b9db35c8b55751eb.5cce47e1.webp",b=a.p+"static/image/1391b66a2b0c2f8b789eb2416ad35998.7a1ec810.gif",V=a.p+"static/image/e261efe9c018603473c6f683ea44d5f5.6782ee4e.webp",C=a.p+"static/image/95d72a7c5bc846c65c67fcc2da4c6dbc.aeb9ae24.gif",S=a.p+"static/image/e9d4a3a7351495d1e727cab453549269.58e6f0e6.webp",w=a.p+"static/image/611e7f9fede2942190c92fb3bd70fd0a.6984957e.webp",D=a.p+"static/image/11f73584d367ccae0e525da38435dbb3.813b4d11.webp",E=a.p+"static/image/f157df49c8fa1f335fffad732d576cc7.b05c58aa.webp",k=a.p+"static/image/b344128a5e6ef1a7b5d1e289a2369c41.0db25395.webp",A=a.p+"static/image/869c37d27ed7d93a472622f8d57e016f.f4ad0369.webp",R=a.p+"static/image/b22bb00ae7f6f647ce00c63772ce1250.af49a642.webp",F=a.p+"static/image/c4a550d70cd47cf19f267dbf8c849c15.d4c5462c.gif",T=a.p+"static/image/8d3a55414a0f463a596092060d189690.75aa3d6e.gif",_=a.p+"static/image/b5d8f41235daab9b89e034c7d82a4b3b.f0e95e7f.webp",P=a.p+"static/image/b497e7a577375788236bf8659695f37b.5389f1aa.gif",M=a.p+"static/image/63a94ead37fa268e67799bb0b3c83e2d.91c7c745.webp",L=a.p+"static/image/fc6b8bbc28add1dbe117ba615cb33843.0bb7d1e2.webp",N=a.p+"static/image/01081610c8dbc80188851e394c045ebb.efdd3bb8.gif",B=a.p+"static/image/b64aa9ecf3d2e0872f016e06e4b3d4a8.604d0c18.gif",I=a.p+"static/image/f7e13b54f77ff300a4678c8b0894a71a.780df193.gif",G=a.p+"static/image/0f6faf9326df638b1207c08afa7ba106.14a0a2cc.gif",H=a.p+"static/image/1a34b25494b34b7c95bf8db644f8b295.1148a400.webp",O=a.p+"static/image/2f0388fe88b722f72fd5dc66c7d1add8.61d03096.webp",Q=a.p+"static/image/3d839a0379b60369f27a1b9839d9c1bd.6239bf51.webp",y=a.p+"static/image/3583f6cc71712a9515ec31f5ad7b3755.3e2dab25.webp",U=a.p+"static/image/f07cb06d1b74d9c2cda7e2be89e4953a.28315a48.webp",q=a.p+"static/image/5c511a953bc3f40e174c9c455d4abf38.6ede30af.webp";function z(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",strong:"strong",pre:"pre",code:"code",h2:"h2"},(0,l.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"第06章受控模式vs非受控模式",children:["第06章—受控模式VS非受控模式",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第06章受控模式vs非受控模式",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"\uFEFF前端开发经常会涉及表单的处理，或者其他一些用于输入的组件，比如日历组件。"}),"\n",(0,t.jsx)(n.p,{children:"涉及到输入，就绕不开受控模式和非受控模式的概念。"}),"\n",(0,t.jsx)(n.p,{children:"什么是受控，什么是非受控呢？"}),"\n",(0,t.jsx)(n.p,{children:"想一下，改变表单值只有两种情况："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:q,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"用户去改变 value 或者代码去改变 value。"}),"\n",(0,t.jsx)(n.p,{children:"如果不能通过代码改表单值 value，那就是非受控，也就是不受我们控制。"}),"\n",(0,t.jsx)(n.p,{children:"但是代码可以给表单设置初始值 defaultValue。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:U,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"代码设置表单的初始 value，但是能改变 value 的只有用户，代码通过监听 onChange 来拿到最新的值，或者通过 ref 拿到 dom 之后读取 value。"}),"\n",(0,t.jsx)(n.p,{children:"这种就是非受控模式。"}),"\n",(0,t.jsx)(n.p,{children:"反过来，代码可以改变表单的 value，就是受控模式。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:y,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"注意，value 和 defaultValue 不一样："}),"\n",(0,t.jsx)(n.p,{children:"defaultValue 会作为 value 的初始值，后面用户改变的是 value。"}),"\n",(0,t.jsx)(n.p,{children:"而一旦你给 input 设置了 value，那用户就不能修改它了，可以输入触发 onChange 事件，但是表单的值不会变。"}),"\n",(0,t.jsx)(n.p,{children:"用户输入之后在 onChange 事件里拿到输入，然后通过代码去设置 value。"}),"\n",(0,t.jsx)(n.p,{children:"这就是受控模式。"}),"\n",(0,t.jsx)(n.p,{children:"其实绝大多数情况下，非受控就可以了，因为我们只是要拿到用户的输入，不需要手动去修改表单值。"}),"\n",(0,t.jsx)(n.p,{children:"但有的时候，你需要根据用户的输入做一些处理，然后设置为表单的值，这种就需要受控模式。"}),"\n",(0,t.jsx)(n.p,{children:"或者你想同步表单的值到另一个地方的时候，类似 Form 组件，也可以用受控模式。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"value 由用户控制就是非受控模式，由代码控制就是受控模式"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"我们写代码试一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx create-vite\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:Q,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"创建 vite + react 的项目。"}),"\n",(0,t.jsx)(n.p,{children:"去掉 main.tsx 的 index.css 和 StrictMode："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:O,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"改下 App.tsx"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { ChangeEvent } from \"react\"\n\nfunction App() {\n\n  function onChange(event: ChangeEvent<HTMLInputElement>) {\n    console.log(event.target.value);\n  }\n\n  return <input defaultValue={'guang'} onChange={onChange}/>\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"跑一下开发服务："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install\nnpm run dev\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:H,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"看下效果："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:G,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"defaultValue 作为 value 的初始值，然后用户输入触发 onChange 事件，通过 event.target 拿到了 value。"}),"\n",(0,t.jsx)(n.p,{children:"当然，非受控模式也不一定通过 onChange 拿到最新 value，通过 ref 也可以。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef } from \"react\"\n\nfunction App() {\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(inputRef.current?.value);\n    }, 2000);\n  }, []);\n\n  return <input defaultValue={'guang'} ref={inputRef}/>\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:I,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"接下来看下受控模式的写法："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { ChangeEvent, useState } from \"react\"\n\nfunction App() {\n\n  const [value, setValue] = useState('guang');\n\n  function onChange(event: ChangeEvent<HTMLInputElement>) {\n    console.log(event.target.value);\n    // setValue(event.target.value);\n  }\n\n  return <input value={value} onChange={onChange}/>\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们先把 setValue 注释掉，看下用户可不可以改："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:B,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，用户可以输入，onChange 也可以拿到输入后的表单值，但是 value 并没有变。"}),"\n",(0,t.jsx)(n.p,{children:"把 setValue 那一行注释去掉就可以了。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:N,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"虽然功能上差不多，但这种写法并不推荐："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:L,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"你不让用户自己控制，而是通过代码控制，绕了一圈结果也没改 value 的值，还是原封不动的，图啥呢？"}),"\n",(0,t.jsx)(n.p,{children:"而且受控模式每次 setValue 都会导致组件重新渲染。"}),"\n",(0,t.jsx)(n.p,{children:"试一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:M,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:P,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"每次输入都会 setValue，然后触发组件重新渲染："}),"\n",(0,t.jsx)(n.p,{children:"而非受控模式下只会渲染一次："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:_,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:T,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"绕了一圈啥也没改，还导致很多组件的重新渲染，那你用受控模式图啥呢？"}),"\n",(0,t.jsx)(n.p,{children:"那什么情况用受控模式呢？"}),"\n",(0,t.jsxs)(n.p,{children:["当然是你",(0,t.jsx)(n.strong,{children:"需要对输入的值做处理之后设置到表单的时候，或者是你想实时同步状态值到父组件。"})]}),"\n",(0,t.jsx)(n.p,{children:"比如把用户输入改为大写："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { ChangeEvent, useState } from \"react\"\n\nfunction App() {\n\n  const [value, setValue] = useState('guang');\n\n  function onChange(event: ChangeEvent<HTMLInputElement>) {\n    console.log(event.target.value)\n    setValue(event.target.value.toUpperCase());\n  }\n\n  return <input value={value} onChange={onChange}/>\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:F,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这种，需要把用户的输入修改一下再设置 value 的。"}),"\n",(0,t.jsx)(n.p,{children:"但这种场景其实很少。"}),"\n",(0,t.jsx)(n.p,{children:"有的同学可能会说 Form 组件，确实，用 Form.Item 包裹的表单项都是受控组件："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:R,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"确实，那是因为 Form 组件内有一个 Store，会把表单值同步过去，然后集中管理和设置值："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:A,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"但也因为都是受控组件，随着用户的输入，表单重新渲染很多次，性能会不好。"}),"\n",(0,t.jsx)(n.p,{children:"如果是单独用的组件，比如 Calendar，那就没必要用受控模式了，用非受控模式，设置 defaultValue 就可以了。"}),"\n",(0,t.jsx)(n.p,{children:"很多人上来就设置 value，然后监听 onChange，但是绕了一圈又原封不动的把用户输入转为 value。"}),"\n",(0,t.jsx)(n.p,{children:"没啥意义，还平白导致组件的很多次重新渲染。"}),"\n",(0,t.jsx)(n.p,{children:"除了原生表单元素外，组件也需要考虑受控和非受控的情况。"}),"\n",(0,t.jsx)(n.p,{children:"比如日历组件："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:k,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"它的参数就要考虑是支持非受控模式的 defaultValue，还是用受控模式的 value + onChange。"}),"\n",(0,t.jsx)(n.p,{children:"如果这是一个业务组件，那基本就是用非受控模式的 defaultValue 了，调用方只要拿到用户的输入就行。"}),"\n",(0,t.jsx)(n.p,{children:"用受控模式的 value 还要 setValue 触发额外的渲染。"}),"\n",(0,t.jsx)(n.p,{children:"但是基础组件不能这样，你得都支持，让调用者自己去选择。"}),"\n",(0,t.jsx)(n.p,{children:"ant design 的 Calendar 组件就是这样的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:E,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:D,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["ColorPicker 组件也是：\n",(0,t.jsx)("img",{src:w,alt:""})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:S,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"它同时支持了受控组件和非受控组件。"}),"\n",(0,t.jsx)(n.p,{children:"咋做到的呢？"}),"\n",(0,t.jsx)(n.p,{children:"我们来试试："}),"\n",(0,t.jsx)(n.p,{children:"首先写下非受控组件的写法："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { ChangeEvent, useState } from \"react\"\n\ninterface CalendarProps{\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n}\nfunction Calendar(props: CalendarProps) {\n  \n  const {\n    defaultValue = new Date(),\n    onChange\n  } = props;\n\n  const [value, setValue] = useState(defaultValue);\n\n  function changeValue(date: Date) {\n    setValue(date);\n    onChange?.(date);\n  } \n\n\n  return <div>\n    {value.toLocaleDateString()}\n    <div onClick={()=> {changeValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n\nfunction App() {\n  return <Calendar defaultValue={new Date('2024-5-1')} onChange={(date) => {\n    console.log(date.toLocaleDateString());\n  }}/>\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里 Calendar 组件传入 defaultValue 和 onChange 参数。"}),"\n",(0,t.jsx)(n.p,{children:"defaultValue 会作为 value 的初始值，然后用户点击不同日期会修改 value，然后回调 onChange 函数。"}),"\n",(0,t.jsx)(n.p,{children:"这种情况，调用者只能设置 defaultValue 初始值，不能直接传入 value 来控制，所以是非受控模式。"}),"\n",(0,t.jsx)(n.p,{children:"试一下；"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:C,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后再来写下受控模式的版本："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { ChangeEvent, useEffect, useState } from \"react\"\n\ninterface CalendarProps{\n  value: Date;\n  onChange?: (date: Date) => void;\n}\nfunction Calendar(props: CalendarProps) {\n  \n  const {\n    value,\n    onChange\n  } = props;\n\n  function changeValue(date: Date) {\n    onChange?.(date);\n  } \n\n  return <div>\n    {value.toLocaleDateString()}\n    <div onClick={()=> {changeValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n\nfunction App() {\n  const [value, setValue] = useState(new Date('2024-5-1'));\n\n  return <Calendar value={value} onChange={(date) => {\n    console.log(date.toLocaleDateString());\n    setValue(date);\n  }}/>\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"直接用 props 传入的 value，然后切换日期的时候回调 onChange 函数："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:V,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"value 的值的维护在调用方。"}),"\n",(0,t.jsx)(n.p,{children:"这就是受控组件的写法："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"那能不能同时支持受控和非受控模式呢？"}),"\n",(0,t.jsx)(n.p,{children:"可以的，组件库基本都是这么做的："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef, useState } from \"react\"\n\ninterface CalendarProps{\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n}\n\nfunction Calendar(props: CalendarProps) {\n  \n  const {\n    value: propsValue,\n    defaultValue,\n    onChange\n  } = props;\n\n  const [value, setValue] = useState(() => {\n    if (propsValue !== undefined) {\n      return propsValue;\n    } else {\n      return defaultValue;\n    }\n  });\n\n  const isFirstRender = useRef(true);\n\n  useEffect(() => {\n    if(propsValue === undefined && !isFirstRender.current) {\n      setValue(propsValue);\n    }\n    isFirstRender.current = false;\n  }, [propsValue]);\n\n  const mergedValue = propsValue === undefined ? value : propsValue;\n\n  function changeValue(date: Date) {\n    if (propsValue === undefined) {\n      setValue(date);\n    }\n    onChange?.(date);\n  } \n\n  return <div>\n    {mergedValue?.toLocaleDateString()}\n    <div onClick={()=> {changeValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n\nfunction App() {\n  return <Calendar defaultValue={new Date('2024-5-1')} onChange={(date) => {\n    console.log(date.toLocaleDateString());\n  }}/>\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"参数同时支持 value 和 defaultValue，通过判断 value 是不是 undefined 来区分受控模式和非受控模式。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"如果是受控模式，useState 的初始值设置 props.value，然后渲染用 props.value。"}),"\n",(0,t.jsx)(n.p,{children:"如果是非受控模式，那渲染用内部 state 的 value，然后 changeValue 里 setValue。"}),"\n",(0,t.jsx)(n.p,{children:"当不是首次渲染，但 value 变为 undefined 的情况，也就是从受控模式切换到了非受控模式，要同步设置 state 为 propsValue。"}),"\n",(0,t.jsx)(n.p,{children:"这样，组件就同时支持了受控和非受控模式。"}),"\n",(0,t.jsx)(n.p,{children:"测试下："}),"\n",(0,t.jsx)(n.p,{children:"非受控模式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"受控模式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"其实组件库也都是这么做的。"}),"\n",(0,t.jsxs)(n.p,{children:["比如 ",(0,t.jsx)(n.a,{href:"https://github.com/arco-design/arco-design/blob/1e677c3c5bba72728668c40d78faea6536c480a8/components/_util/hooks/useMergeValue.ts",target:"_blank",rel:"noopener noreferrer",children:"arco design 的 useMergeValue 的 hook"}),"："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:v,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"代码差不多，它也是 useState 根据 value 是不是 undefined 来设置 value 或者 defaultValue。"}),"\n",(0,t.jsx)(n.p,{children:"不过它这里又加了一个默认值，没有 defaultValue 的时候用它哪个 defaultStateValue。"}),"\n",(0,t.jsx)(n.p,{children:"然后渲染用的 state 根据 value 是不是 undefind 来判断受控非受控从而决定用 props 的 value 还是 state 的 value。"}),"\n",(0,t.jsx)(n.p,{children:"它也处理了 value 从别的值变为 undefined 的情况："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"保存了之前的 value，判断是从 props.value 别的值变为 undefined 的情况再修改内部 state 为这个 value。"}),"\n",(0,t.jsx)(n.p,{children:"这里保存之前的值是用的 useRef："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"ref 的特点是修改了 current 属性不会导致渲染。"}),"\n",(0,t.jsx)(n.p,{children:"我们是判断非首次渲染，但是 props.value 变为了 undefined，效果一样。"}),"\n",(0,t.jsxs)(n.p,{children:["再比如 ant design 的工具包 rc-util 里的 ",(0,t.jsx)(n.a,{href:"https://github.com/react-component/util/blob/master/src/hooks/useMergedState.ts",target:"_blank",rel:"noopener noreferrer",children:"useMergedValue"})," 的 hook："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"它也是 useState 根据 value 是不是 undefined 来设置 value 或者 defaultValue"}),"\n",(0,t.jsx)(n.p,{children:"然后又加了一个默认值，没有 defaultValue 的时候用它那个 defaultStateValue。"}),"\n",(0,t.jsx)(n.p,{children:"渲染的时候也是判断 value 是不是 undefind 来决定用 props.value 还是 state 的 value："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"并且也做了别的值变为 undefined 的处理。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"大家都这么搞，我们也来封装个 hook："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function useMergeState<T>(\n  defaultStateValue: T,\n  props?: {\n    defaultValue?: T,\n    value?: T\n  }\n): [T, React.Dispatch<React.SetStateAction<T>>,] {\n  const { defaultValue, value: propsValue } = props || {};\n\n  const isFirstRender = useRef(true);\n\n  const [stateValue, setStateValue] = useState<T>(() => {\n    if (propsValue !== undefined) {\n      return propsValue!;\n    } else if(defaultValue !== undefined){\n      return defaultValue!;\n    } else {\n      return defaultStateValue;\n    }\n  });\n\n  useEffect(() => {\n    if(propsValue === undefined && !isFirstRender.current) {\n      setStateValue(propsValue!);\n    }\n\n    isFirstRender.current = false;\n  }, [propsValue]);\n\n  const mergedValue = propsValue === undefined ? stateValue : propsValue;\n\n  return [mergedValue, setStateValue]\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"用一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"interface CalendarProps{\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n}\n\nfunction Calendar(props: CalendarProps) {\n  const {\n    value: propsValue,\n    defaultValue,\n    onChange\n  } = props;\n\n  const [mergedValue, setValue] = useMergeState(new Date(), {\n    value: propsValue,\n    defaultValue\n  });\n\n  function changeValue(date: Date) {\n    if (propsValue === undefined) {\n      setValue(date);\n    }\n    onChange?.(date);\n  } \n\n  return <div>\n    {mergedValue?.toLocaleDateString()}\n    <div onClick={()=> {changeValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {changeValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"试试效果："}),"\n",(0,t.jsx)(n.p,{children:"非受控模式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"受控模式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"再就是这个 onChange 部分，也应该封装进来："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"不然用户用的时候还要想着去处理非受控组件的情况。"}),"\n",(0,t.jsx)(n.p,{children:"我看 arco design 里是没封装进去："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"但是 ahooks 的 useControllableValue 就封装进去了："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们也加一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import {  SetStateAction, useCallback, useEffect, useRef, useState } from \"react\"\n\nfunction useMergeState<T>(\n  defaultStateValue: T,\n  props?: {\n    defaultValue?: T,\n    value?: T,\n    onChange?: (value: T) => void;\n  },\n): [T, React.Dispatch<React.SetStateAction<T>>,] {\n  const { defaultValue, value: propsValue, onChange } = props || {};\n\n  const isFirstRender = useRef(true);\n\n  const [stateValue, setStateValue] = useState<T>(() => {\n    if (propsValue !== undefined) {\n      return propsValue!;\n    } else if(defaultValue !== undefined){\n      return defaultValue!;\n    } else {\n      return defaultStateValue;\n    }\n  });\n\n  useEffect(() => {\n    if(propsValue === undefined && !isFirstRender.current) {\n      setStateValue(propsValue!);\n    }\n\n    isFirstRender.current = false;\n  }, [propsValue]);\n\n  const mergedValue = propsValue === undefined ? stateValue : propsValue;\n\n  function isFunction(value: unknown): value is Function {\n    return typeof value === 'function';\n  } \n\n  const setState = useCallback((value: SetStateAction<T>) => {\n    let res = isFunction(value) ? value(stateValue) : value\n\n    if (propsValue === undefined) {\n      setStateValue(res);\n    }\n    onChange?.(res);\n  }, [stateValue]);\n\n  return [mergedValue, setState]\n}\n\ninterface CalendarProps{\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n}\n\nfunction Calendar(props: CalendarProps) {\n  const {\n    value: propsValue,\n    defaultValue,\n    onChange\n  } = props;\n\n  const [mergedValue, setValue] = useMergeState(new Date(), {\n    value: propsValue,\n    defaultValue,\n    onChange\n  });\n\n  return <div>\n    {mergedValue?.toLocaleDateString()}\n    <div onClick={()=> {setValue(new Date('2024-5-1'))}}>2023-5-1</div>\n    <div onClick={()=> {setValue(new Date('2024-5-2'))}}>2023-5-2</div>\n    <div onClick={()=> {setValue(new Date('2024-5-3'))}}>2023-5-3</div>\n  </div>\n}\n\nfunction App() {\n  const [value, setValue] = useState(new Date('2024-5-1'));\n\n  return <Calendar value={value} onChange={(date) => {\n    console.log(date.toLocaleDateString());\n    setValue(date);\n  }}/>\n  // return <Calendar defaultValue={new Date('2024-5-1')} onChange={(date) => {\n  //   console.log(date.toLocaleDateString());\n  // }}/>\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这里把 onChange 传入了，然后 setState 的时候拿到新的状态值，如果是非受控模式就 setStateValue，然后调用 onChange。"}),"\n",(0,t.jsx)(n.p,{children:"用的时候就不用区分受控非受控了，直接 setState 就行："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"试试效果："}),"\n",(0,t.jsx)(n.p,{children:"非受控模式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"受控模式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"完美！"}),"\n",(0,t.jsx)(n.p,{children:"这样，我们的组件就同时支持了受控模式和非受控模式。"}),"\n",(0,t.jsx)(n.p,{children:"平时写组件，你想同时支持受控和非受控，可以像这样自己封装一个 hook，也可以直接用 ahooks 的 useControllableValue，实现逻辑是一样的。"}),"\n",(0,t.jsxs)(n.p,{children:["案例代码上传了react 小册仓库：",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/controlled-and-uncontrolled",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/controlled-and-uncontrolled"})]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"涉及到用户输入的组件都要考虑用受控模式还是非受控模式。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"value 由用户控制就是非受控模式，由代码控制就是受控模式"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"非受控模式就是完全用户自己修改 value，我们只是设置个 defaultValue，可以通过 onChange 或者 ref 拿到表单值。"}),"\n",(0,t.jsx)(n.p,{children:"受控模式是代码来控制 value，用户输入之后通过 onChange 拿到值然后 setValue，触发重新渲染。"}),"\n",(0,t.jsx)(n.p,{children:"单独用的组件，绝大多数情况下，用非受控模式就好了，因为你只是想获取到用户的输入。"}),"\n",(0,t.jsx)(n.p,{children:"受控模式只在需要对用户的输入做一些修改然后再设置到 value 的情况用，再就是实时同步表单值到父组件的时候，比如 Form。"}),"\n",(0,t.jsx)(n.p,{children:"如果需要结合 Form 表单用，那是要支持受控模式，因为 Form 会通过 Store 来统一管理所有表单项。"}),"\n",(0,t.jsx)(n.p,{children:"封装业务组件的话，用非受控模式或者受控都行。"}),"\n",(0,t.jsx)(n.p,{children:"有的团队就要求组件一定是受控的，然后在父组件里维护状态并同步到状态管理库，这样组件重新渲染也不会丢失数据。"}),"\n",(0,t.jsx)(n.p,{children:"但是基础组件还是都要支持，也就是支持 defaultValue 和 value + onChange 两种参数，内部通过判断 value 是不是 undefined 来区分。"}),"\n",(0,t.jsx)(n.p,{children:"写组件想同时支持受控和非受控，可以直接用 ahooks 的 useControllableValue，也可以自己实现。"}),"\n",(0,t.jsx)(n.p,{children:"arco design、ant design 等组件库都是这么做的，并且不约而同封装了 useMergedValue 的 hook，我们也封装了一个。"}),"\n",(0,t.jsx)(n.p,{children:"理清受控模式和非受控模式的区别，在写组件的时候灵活选用或者都支持。"})]})}function J(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(z,{...e})}):z(e)}let K=J;J.__RSPRESS_PAGE_META={},J.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC06%E7%AB%A0%E2%80%94%E5%8F%97%E6%8E%A7%E6%A8%A1%E5%BC%8FVS%E9%9D%9E%E5%8F%97%E6%8E%A7%E6%A8%A1%E5%BC%8F.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第06章—受控模式VS非受控模式",headingTitle:"第06章—受控模式VS非受控模式",frontmatter:{}}}}]);