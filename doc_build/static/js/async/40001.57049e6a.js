"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["40001"],{87817:function(e,n,d){d.r(n),d.d(n,{default:()=>i});var c=d(552676),s=d(740453);function o(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",ol:"ol",li:"li",h3:"h3"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"17内置组件keepalive-保活的原理",children:["17.内置组件：KeepAlive 保活的原理",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17内置组件keepalive-保活的原理",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Vue"})," 内置了 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 组件，帮助我们实现缓存多个组件实例切换时，完成对卸载组件实例的缓存，从而使得组件实例在来会切换时不会被重复创建，又是一个空间换时间的典型例子。在介绍源码之前，我们先来了解一下 ",(0,c.jsx)(n.code,{children:"KeppAlive"})," 使用的基础示例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'<template>\n  <KeepAlive> \n    <component :is="activeComponent" /> \n  </KeepAlive>\n</template>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["当动态组件在随着 ",(0,c.jsx)(n.code,{children:"activeComponent"})," 变化时，如果没有 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 做缓存，那么组件在来回切换时就会进行重复的实例化，这里就是通过 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 实现了对不活跃组件的缓存。"]}),"\n",(0,c.jsx)(n.p,{children:"这里需要思考几个问题："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"组件是如何被缓存的，以及是如何被重新激活的？"}),"\n",(0,c.jsx)(n.li,{children:"既然缓存可以提高组件渲染的性能，那么是不是缓存的越多越好呢？"}),"\n",(0,c.jsx)(n.li,{children:"如果不是越多越好，那么如何合理的丢弃多余的缓存呢？"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["接下来我们通过对源码的分析，一步步找到答案。先找到定义 ",(0,c.jsx)(n.code,{children:"KeppAlive"})," 组件的地方，然后看一下其大致内容："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const KeepAliveImpl = {\n  // 组件名称\n  name: `KeepAlive`,\n  // 区别于其他组件的标记\n  __isKeepAlive: true,\n  // 组件的 props 定义\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, {slots}) {\n    // ...\n    // setup 返回一个函数\n    return () => {\n      // ...\n    }\n  }\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，",(0,c.jsx)(n.code,{children:"KeepAlive"})," 组件中，通过 ",(0,c.jsx)(n.code,{children:"__isKeepAlive"})," 属性来完成对这个内置组件的特殊标记，这样外部可以通过 ",(0,c.jsx)(n.code,{children:"isKeepAlive"})," 函数来做区分："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const isKeepAlive = vnode => vnode.type.__isKeepAlive\n"})}),"\n",(0,c.jsxs)(n.p,{children:["紧接着定义了 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 的一些 ",(0,c.jsx)(n.code,{children:"props"}),"："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"include"})," 表示包含哪些组件可被缓存"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"exclude"})," 表示排除那些组件"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"max"})," 则表示最大的缓存数"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["后面我们将可以详细的看到这些 ",(0,c.jsx)(n.code,{children:"props"})," 是如何被发挥作用的。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后实现了一个 ",(0,c.jsx)(n.code,{children:"setup"})," 函数，该函数返回了一个函数，我们前面提到 ",(0,c.jsx)(n.code,{children:"setup"})," 返回函数的话，那么这个函数将会被当做节点 ",(0,c.jsx)(n.code,{children:"render"})," 函数。了解了 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 的整体骨架后，我们先来看看这个 ",(0,c.jsx)(n.code,{children:"render"})," 函数具体做了哪些事情。"]}),"\n",(0,c.jsxs)(n.h2,{id:"keepalive-的-render-函数",children:["KeepAlive 的 render 函数",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#keepalive-的-render-函数",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["先来看看 ",(0,c.jsx)(n.code,{children:"render"})," 函数的源码实现："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const KeepAliveImpl = {\n  // ...\n  setup(props, { slot }) {\n    // ...\n    return () => {\n      // 记录需要被缓存的 key\n      pendingCacheKey = null\n      // ...\n      // 获取子节点\n      const children = slots.default()\n      const rawVNode = children[0]\n      if (children.length > 1) {\n        // 子节点数量大于 1 个，不会进行缓存，直接返回\n        current = null\n        return children\n      } else if (\n        !isVNode(rawVNode) ||\n        (!(rawVNode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) &&\n          !(rawVNode.shapeFlag & ShapeFlags.SUSPENSE))\n      ) {\n        current = null\n        return rawVNode\n      }\n      // suspense 特殊处理，正常节点就是返回节点 vnode\n      let vnode = getInnerChild(rawVNode)\n      const comp = vnode.type\n    \n      // 获取 Component.name 值\n      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp)\n      // 获取 props 中的属性\n      const { include, exclude, max } = props\n      // 如果组件 name 不在 include 中或者存在于 exclude 中，则直接返回\n      if (\n        (include && (!name || !matches(include, name))) ||\n        (exclude && name && matches(exclude, name))\n      ) {\n        current = vnode\n        return rawVNode\n      }\n      \n      // 缓存相关，定义缓存 key\n      const key = vnode.key == null ? comp : vnode.key\n      // 从缓存中取值\n      const cachedVNode = cache.get(key)\n    \n      // clone vnode，因为需要重用\n      if (vnode.el) {\n        vnode = cloneVNode(vnode)\n        if (rawVNode.shapeFlag & ShapeFlags.SUSPENSE) {\n          rawVNode.ssContent = vnode\n        }\n      }\n      // 给 pendingCacheKey 赋值，将在 beforeMount/beforeUpdate 中被使用\n      pendingCacheKey = key\n      // 如果存在缓存的 vnode 元素\n      if (cachedVNode) {\n        // 复制挂载状态\n        // 复制 DOM\n        vnode.el = cachedVNode.el\n        // 复制 component\n        vnode.component = cachedVNode.component\n        \n        // 增加 shapeFlag 类型 COMPONENT_KEPT_ALIVE\n        vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE\n        // 把缓存的 key 移动到到队首\n        keys.delete(key)\n        keys.add(key)\n      } else {\n        // 如果缓存不存在，则添加缓存\n        keys.add(key)\n        // 如果超出了最大的限制，则移除最早被缓存的值\n        if (max && keys.size > parseInt(max as string, 10)) {\n          pruneCacheEntry(keys.values().next().value)\n        }\n      }\n      // 增加 shapeFlag 类型 COMPONENT_SHOULD_KEEP_ALIVE，避免被卸载\n      vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\n    \n      current = vnode\n      // 返回 vnode 节点\n      return isSuspense(rawVNode.type) ? rawVNode : vnode\n    }\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到返回的这个 ",(0,c.jsx)(n.code,{children:"render"})," 函数执行的结果就是返回被 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 包裹的子节点的 ",(0,c.jsx)(n.code,{children:"vnode"})," 只不过在返回子节点的过程中做了很多处理而已，如果子节点数量大于一个，那么将不会被 ",(0,c.jsx)(n.code,{children:"keepAlive"}),"，直接返回子节点的 ",(0,c.jsx)(n.code,{children:"vnode"}),"，如果组件 ",(0,c.jsx)(n.code,{children:"name"})," 不在用户定义的 ",(0,c.jsx)(n.code,{children:"include"})," 中或者存在于 ",(0,c.jsx)(n.code,{children:"exclude"})," 中，也会直接返回子节点的 ",(0,c.jsx)(n.code,{children:"vnode"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"缓存设计",children:["缓存设计",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存设计",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["接着来看后续的缓存步骤，首先定义了一个 ",(0,c.jsx)(n.code,{children:"pendingCacheKey"})," 变量，用来作为 ",(0,c.jsx)(n.code,{children:"cache"})," 的缓存 ",(0,c.jsx)(n.code,{children:"key"}),"。对于初始化的 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 组件的时候，此时还没有缓存，那么只会讲 ",(0,c.jsx)(n.code,{children:"key"})," 添加到 ",(0,c.jsx)(n.code,{children:"keys"})," 这样一个 ",(0,c.jsx)(n.code,{children:"Set"})," 的数据结构中，在组件 ",(0,c.jsx)(n.code,{children:"onMounted"})," 和 ",(0,c.jsx)(n.code,{children:"onUpdated"})," 钩子中进行缓存组件的 ",(0,c.jsx)(n.code,{children:"vnode"})," 收集，因为这个时候收集到的 ",(0,c.jsx)(n.code,{children:"vnode"})," 节点是稳定不会变的缓存。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const cacheSubtree = () => {\n  if (pendingCacheKey != null) {\n    // 以 pendingCacheKey 作为key 进行缓存收集\n    cache.set(pendingCacheKey, getInnerChild(instance.subTree))\n  }\n}\n\nonMounted(cacheSubtree)\nonUpdated(cacheSubtree)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["另外，注意到 ",(0,c.jsx)(n.code,{children:"props"})," 中还有一个 ",(0,c.jsx)(n.code,{children:"max"})," 变量用来标记最大的缓存数量，这个缓存策略就是类似于 ",(0,c.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)",target:"_blank",rel:"noopener noreferrer",children:"LRU 缓存"})," 的方式实现的。在缓存重新被激活时，之前缓存的 ",(0,c.jsx)(n.code,{children:"key"})," 会被重新添加到队首，标记为最近的一次缓存，如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被销毁，以便为新的实例腾出空间。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后，当缓存的节点被重新激活时，则会将缓存中的节点的 ",(0,c.jsx)(n.code,{children:"el"})," 属性赋值给新的 ",(0,c.jsx)(n.code,{children:"vnode"})," 节点，从而减少了再进行 ",(0,c.jsx)(n.code,{children:"patch"})," 生成 ",(0,c.jsx)(n.code,{children:"DOM"})," 的过程，这里也说明了 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 核心目的就是缓存 ",(0,c.jsx)(n.code,{children:"DOM"})," 元素。"]}),"\n",(0,c.jsxs)(n.h2,{id:"激活态设计",children:["激活态设计",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#激活态设计",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["上述源码中，当组件被添加到 ",(0,c.jsx)(n.code,{children:"KeepAlive"})," 缓存池中时，也会为 ",(0,c.jsx)(n.code,{children:"vnode"})," 节点的 ",(0,c.jsx)(n.code,{children:"shapeFlag"})," 添加两额外的两个属性，分别是 ",(0,c.jsx)(n.code,{children:"COMPONENT_KEPT_ALIVE"})," 和 ",(0,c.jsx)(n.code,{children:"COMPONENT_SHOULD_KEEP_ALIVE"}),"。我们先说 ",(0,c.jsx)(n.code,{children:"COMPONENT_KEPT_ALIVE"})," 这个属性，当一个节点被标记为 ",(0,c.jsx)(n.code,{children:"COMPONENT_KEPT_ALIVE"})," 时，会在 ",(0,c.jsx)(n.code,{children:"processComponent"})," 时进行特殊处理："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const processComponent = (...) => {\n  if (n1 == null) {\n    // 处理 KeepAlive 组件\n    if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {\n      // 执行 activate 钩子\n      ;(parentComponent!.ctx as KeepAliveContext).activate(\n        n2,\n        container,\n        anchor,\n        isSVG,\n        optimized\n      )\n    } else {\n      mountComponent(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        optimized\n      )\n    }\n  }\n  else {\n    // 更新组件\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，在 ",(0,c.jsx)(n.code,{children:"processComponent"})," 阶段如果是 ",(0,c.jsx)(n.code,{children:"keepAlive"})," 的组件，在挂载过程中，不会执行执行 ",(0,c.jsx)(n.code,{children:"mountComponent"})," 的逻辑，因为已经缓存好了，所以只需要再次调用 ",(0,c.jsx)(n.code,{children:"activate"})," 激活就好了。接下来看看这个激活函数做了哪些事儿："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const KeepAliveImpl = {\n  // ...\n  setup(props, { slot }) {\n    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n      // 获取组件实例\n      const instance = vnode.component!\n      // 将缓存的组件挂载到容器中\n      move(vnode, container, anchor, MoveType.ENTER, parentSuspense)\n      // 如果 props 有变动，还是需要对 props 进行 patch\n      patch(\n        instance.vnode,\n        vnode,\n        container,\n        anchor,\n        instance,\n        parentSuspense,\n        isSVG,\n        vnode.slotScopeIds,\n        optimized\n      )\n      // 执行组件的钩子函数\n      queuePostRenderEffect(() => {\n        instance.isDeactivated = false\n        // 执行 onActivated 钩子\n        if (instance.a) {\n          invokeArrayFns(instance.a)\n        }\n        // 执行 onVnodeMounted 钩子\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode)\n        }\n      }, parentSuspense)\n    }\n    // ...\n  }\n}    \n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以直观的看到 ",(0,c.jsx)(n.code,{children:"activate"})," 激活函数，核心就是通过 ",(0,c.jsx)(n.code,{children:"move"})," 方法，将缓存中的 ",(0,c.jsx)(n.code,{children:"vnode"})," 节点直接挂载到容器中，同时为了防止 ",(0,c.jsx)(n.code,{children:"props"})," 变化导致组件变化，也会执行 ",(0,c.jsx)(n.code,{children:"patch"})," 方法来更新组件，注意此时的 ",(0,c.jsx)(n.code,{children:"patch"})," 函数的调用是会传入新老子节点的，所以只会进行 ",(0,c.jsx)(n.code,{children:"diff"})," 而不会进行重新创建。"]}),"\n",(0,c.jsxs)(n.p,{children:["当这一切都执行完成后，最后再通过 ",(0,c.jsx)(n.code,{children:"queuePostRenderEffect"})," 函数，将用户定义的 ",(0,c.jsx)(n.code,{children:"onActivated"})," 钩子放到状态更新流程后执行。"]}),"\n",(0,c.jsxs)(n.h2,{id:"卸载态设计",children:["卸载态设计",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#卸载态设计",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["接下来我们再看另一个标记态：",(0,c.jsx)(n.code,{children:"COMPONENT_SHOULD_KEEP_ALIVE"}),"，我们看一下组件的卸载函数 ",(0,c.jsx)(n.code,{children:"unmount"})," 的设计："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const unmount = (vnode, parentComponent, parentSuspense, doRemove = false) => {\n  // ...\n  const { shapeFlag  } = vnode\n  if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {\n    ;(parentComponent!.ctx as KeepAliveContext).deactivate(vnode)\n    return\n  }\n  // ...\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，如果 ",(0,c.jsx)(n.code,{children:"shapeFlag"})," 上存在 ",(0,c.jsx)(n.code,{children:"COMPONENT_SHOULD_KEEP_ALIVE"})," 属性的话，那么将会执行 ",(0,c.jsx)(n.code,{children:"ctx.deactivate"})," 方法，我们再来看一下 ",(0,c.jsx)(n.code,{children:"deactivate"})," 函数的定义："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const KeepAliveImpl = {\n  // ...\n  setup(props, { slot }) {\n    // 创建一个隐藏容器\n    const storageContainer = createElement('div')\n\n    sharedContext.deactivate = (vnode: VNode) => {\n      // 获取组件实例\n      const instance = vnode.component!\n      // 将组件移动到隐藏容器中\n      move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense)\n      // 执行组件的钩子函数\n      queuePostRenderEffect(() => {\n        // 执行组件的 onDeactivated 钩子\n        if (instance.da) {\n          invokeArrayFns(instance.da)\n        }\n        // 执行 onVnodeUnmounted\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode)\n        }\n        instance.isDeactivated = true\n      }, parentSuspense)\n    }\n    // ...\n  }\n} \n"})}),"\n",(0,c.jsxs)(n.p,{children:["卸载态函数 ",(0,c.jsx)(n.code,{children:"deactivate"})," 核心工作就是将页面中的 ",(0,c.jsx)(n.code,{children:"DOM"})," 移动到一个隐藏不可见的容器 ",(0,c.jsx)(n.code,{children:"storageContainer"})," 当中，这样页面中的元素就被移除了。当这一切都执行完成后，最后再通过 ",(0,c.jsx)(n.code,{children:"queuePostRenderEffect"})," 函数，将用户定义的 ",(0,c.jsx)(n.code,{children:"onDeactivated"})," 钩子放到状态更新流程后执行。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"现在我们尝试着再回答文中开篇提到的三个问题："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["组件是通过类似于 ",(0,c.jsx)(n.code,{children:"LRU"})," 的缓存机制来缓存的，并为缓存的组件 ",(0,c.jsx)(n.code,{children:"vnode"})," 的 ",(0,c.jsx)(n.code,{children:"shapeFlag"})," 属性打上 ",(0,c.jsx)(n.code,{children:"COMPONENT_KEPT_ALIVE"})," 属性，当组件在 ",(0,c.jsx)(n.code,{children:"processComponent"})," 挂载时，如果存在 ",(0,c.jsx)(n.code,{children:"COMPONENT_KEPT_ALIVE"})," 属性，则会执行激活函数，激活函数内执行具体的缓存节点挂载逻辑。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["缓存不是越多越好，因为所有的缓存节点都会被存在 ",(0,c.jsx)(n.code,{children:"cache"})," 中，如果过多，则会增加内存负担。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["丢弃的方式就是在缓存重新被激活时，之前缓存的 ",(0,c.jsx)(n.code,{children:"key"})," 会被重新添加到队首，标记为最近的一次缓存，如果缓存的实例数量即将超过指定的那个最大数量，则最久没有被访问的缓存实例将被丢弃。"]}),"\n"]}),"\n"]})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(o,{...e})}):o(e)}let i=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F17.%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%EF%BC%9AKeepAlive%20%E4%BF%9D%E6%B4%BB%E7%9A%84%E5%8E%9F%E7%90%86.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"KeepAlive 的 render 函数",id:"keepalive-的-render-函数",depth:2},{text:"缓存设计",id:"缓存设计",depth:3},{text:"激活态设计",id:"激活态设计",depth:2},{text:"卸载态设计",id:"卸载态设计",depth:2},{text:"总结",id:"总结",depth:2}],title:"17.内置组件：KeepAlive 保活的原理",headingTitle:"17.内置组件：KeepAlive 保活的原理",frontmatter:{}}}}]);