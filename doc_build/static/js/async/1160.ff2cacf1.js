"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["1160"],{927163:function(n,e,s){s.r(e),s.d(e,{default:()=>i});var c=s(552676),l=s(740453);function r(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",hr:"hr",strong:"strong",blockquote:"blockquote",h3:"h3",code:"code",pre:"pre"},(0,l.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"2一面-1es-基础知识点与高频考题解析",children:["2.一面 1：ES 基础知识点与高频考题解析",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2一面-1es-基础知识点与高频考题解析",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"JavaScript 是 ECMAScript 规范的一种实现，本小节重点梳理下 ECMAScript 中的常考知识点，然后就一些容易出现的题目进行解析。"}),"\n",(0,c.jsxs)(e.h2,{id:"知识点梳理",children:["知识点梳理",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点梳理",children:"#"})]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["变量类型","\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"JS 的数据类型分类和判断"}),"\n",(0,c.jsx)(e.li,{children:"值类型和引用类型"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["原型与原型链（继承）","\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"原型和原型链定义"}),"\n",(0,c.jsx)(e.li,{children:"继承写法"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["作用域和闭包","\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"执行上下文"}),"\n",(0,c.jsx)(e.li,{children:"this"}),"\n",(0,c.jsx)(e.li,{children:"闭包是什么"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["异步","\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"同步 vs 异步"}),"\n",(0,c.jsx)(e.li,{children:"异步和单线程"}),"\n",(0,c.jsx)(e.li,{children:"前端异步的场景"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["ES6/7 新标准的考查","\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"箭头函数"}),"\n",(0,c.jsx)(e.li,{children:"Module"}),"\n",(0,c.jsx)(e.li,{children:"Class"}),"\n",(0,c.jsx)(e.li,{children:"Set 和 Map"}),"\n",(0,c.jsx)(e.li,{children:"Promise"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsxs)(e.h2,{id:"变量类型",children:["变量类型",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#变量类型",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"JavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。"}),"\n",(0,c.jsx)(e.p,{children:"ECMAScript 中定义了 6 种原始类型："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"Boolean"}),"\n",(0,c.jsx)(e.li,{children:"String"}),"\n",(0,c.jsx)(e.li,{children:"Number"}),"\n",(0,c.jsx)(e.li,{children:"Null"}),"\n",(0,c.jsx)(e.li,{children:"Undefined"}),"\n",(0,c.jsx)(e.li,{children:"Symbol（ES6 新定义）"}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.strong,{children:"注意"}),"：原始类型不包含 Object。"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：类型判断用到哪些方法？"}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"typeof",children:[(0,c.jsx)(e.code,{children:"typeof"}),(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#typeof",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"typeof xxx"}),"得到的值有以下几种类型：",(0,c.jsx)(e.code,{children:"undefined"})," ",(0,c.jsx)(e.code,{children:"boolean"})," ",(0,c.jsx)(e.code,{children:"number"})," ",(0,c.jsx)(e.code,{children:"string"})," ",(0,c.jsx)(e.code,{children:"object"})," ",(0,c.jsx)(e.code,{children:"function"}),"、",(0,c.jsx)(e.code,{children:"symbol"})," ，比较简单，不再一一演示了。这里需要注意的有三点："]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"typeof null"}),"结果是",(0,c.jsx)(e.code,{children:"object"})," ，实际这是",(0,c.jsx)(e.code,{children:"typeof"}),"的一个bug，null是原始值，非引用类型"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"typeof [1, 2]"}),"结果是",(0,c.jsx)(e.code,{children:"object"}),"，结果中没有",(0,c.jsx)(e.code,{children:"array"}),"这一项，引用类型除了",(0,c.jsx)(e.code,{children:"function"}),"其他的全部都是",(0,c.jsx)(e.code,{children:"object"})]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"typeof Symbol()"})," 用",(0,c.jsx)(e.code,{children:"typeof"}),"获取",(0,c.jsx)(e.code,{children:"symbol"}),"类型的值得到的是",(0,c.jsx)(e.code,{children:"symbol"}),"，这是 ES6 新增的知识点"]}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"instanceof",children:[(0,c.jsx)(e.code,{children:"instanceof"}),(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#instanceof",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["用于实例和构造函数的对应。例如判断一个变量是否是数组，使用",(0,c.jsx)(e.code,{children:"typeof"}),"无法判断，但可以使用",(0,c.jsx)(e.code,{children:"[1, 2] instanceof Array"}),"来判断。因为，",(0,c.jsx)(e.code,{children:"[1, 2]"}),"是数组，它的构造函数就是",(0,c.jsx)(e.code,{children:"Array"}),"。同理："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function Foo(name) {\n    this.name = name\n}\nvar foo = new Foo('bar')\nconsole.log(foo instanceof Foo) // true\n"})}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：值类型和引用类型的区别"}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"值类型-vs-引用类型",children:["值类型 vs 引用类型",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#值类型-vs-引用类型",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["除了原始类型，ES 还有引用类型，上文提到的",(0,c.jsx)(e.code,{children:"typeof"}),"识别出来的类型中，只有",(0,c.jsx)(e.code,{children:"object"}),"和",(0,c.jsx)(e.code,{children:"function"}),"是引用类型，其他都是值类型。"]}),"\n",(0,c.jsxs)(e.p,{children:["根据 JavaScript 中的变量类型传递方式，又分为",(0,c.jsx)(e.strong,{children:"值类型"}),"和",(0,c.jsx)(e.strong,{children:"引用类型"}),"，值类型变量包括 Boolean、String、Number、Undefined、Null，引用类型包括了 Object 类的所有，如 Date、Array、Function 等。在参数传递方式上，值类型是按值传递，引用类型是按共享传递。"]}),"\n",(0,c.jsx)(e.p,{children:"下面通过一个小题目，来看下两者的主要区别，以及实际开发中需要注意的地方。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 值类型\nvar a = 10\nvar b = a\nb = 20\nconsole.log(a)  // 10\nconsole.log(b)  // 20\n"})}),"\n",(0,c.jsxs)(e.p,{children:["上述代码中，",(0,c.jsx)(e.code,{children:"a"})," ",(0,c.jsx)(e.code,{children:"b"}),"都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 引用类型\nvar a = {x: 10, y: 20}\nvar b = a\nb.x = 100\nb.y = 200\nconsole.log(a)  // {x: 100, y: 200}\nconsole.log(b)  // {x: 100, y: 200}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["上述代码中，",(0,c.jsx)(e.code,{children:"a"})," ",(0,c.jsx)(e.code,{children:"b"}),"都是引用类型。在执行了",(0,c.jsx)(e.code,{children:"b = a"}),"之后，修改",(0,c.jsx)(e.code,{children:"b"}),"的属性值，",(0,c.jsx)(e.code,{children:"a"}),"的也跟着变化。因为",(0,c.jsx)(e.code,{children:"a"}),"和",(0,c.jsx)(e.code,{children:"b"}),"都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此",(0,c.jsx)(e.code,{children:"b"}),"修改属性时，",(0,c.jsx)(e.code,{children:"a"}),"的值随之改动。"]}),"\n",(0,c.jsx)(e.p,{children:"再借助题目进一步讲解一下。"}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"说出下面代码的执行结果，并分析其原因。"}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function foo(a){\n    a = a * 10;\n}\nfunction bar(b){\n    b.value = 'new';\n}\nvar a = 1;\nvar b = {value: 'old'};\nfoo(a);\nbar(b);\nconsole.log(a); // 1\nconsole.log(b); // value: new\n"})}),"\n",(0,c.jsx)(e.p,{children:"通过代码执行，会发现："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"a"}),"的值没有发生改变"]}),"\n",(0,c.jsxs)(e.li,{children:["而",(0,c.jsx)(e.code,{children:"b"}),"的值发生了改变"]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["这就是因为",(0,c.jsx)(e.code,{children:"Number"}),"类型的",(0,c.jsx)(e.code,{children:"a"}),"是按值传递的，而",(0,c.jsx)(e.code,{children:"Object"}),"类型的",(0,c.jsx)(e.code,{children:"b"}),"是按共享传递的。"]}),"\n",(0,c.jsx)(e.p,{children:"JS 中这种设计的原因是：按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。"}),"\n",(0,c.jsxs)(e.p,{children:["引用类型经常会在代码中按照下面的写法使用，或者说",(0,c.jsx)(e.strong,{children:"容易不知不觉中造成错误"}),"！"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var obj = {\n    a: 1,\n    b: [1,2,3]\n}\nvar a = obj.a\nvar b = obj.b\na = 2\nb.push(4)\nconsole.log(obj, a, b)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["虽然",(0,c.jsx)(e.code,{children:"obj"}),"本身是个引用类型的变量（对象），但是内部的",(0,c.jsx)(e.code,{children:"a"}),"和",(0,c.jsx)(e.code,{children:"b"}),"一个是值类型一个是引用类型，",(0,c.jsx)(e.code,{children:"a"}),"的赋值不会改变",(0,c.jsx)(e.code,{children:"obj.a"}),"，但是",(0,c.jsx)(e.code,{children:"b"}),"的操作却会反映到",(0,c.jsx)(e.code,{children:"obj"}),"对象上。"]}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsxs)(e.h2,{id:"原型和原型链",children:["原型和原型链",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#原型和原型链",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。"}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：如何理解 JavaScript 的原型"}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["对于这个问题，可以从下面这几个要点来理解和回答，",(0,c.jsx)(e.strong,{children:"下面几条必须记住并且理解"})]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:(0,c.jsxs)(e.strong,{children:["所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（",(0,c.jsx)(e.code,{children:"null"}),"除外）"]})}),"\n",(0,c.jsx)(e.li,{children:(0,c.jsxs)(e.strong,{children:["所有的引用类型（数组、对象、函数），都有一个",(0,c.jsx)(e.code,{children:"__proto__"}),"属性，属性值是一个普通的对象"]})}),"\n",(0,c.jsx)(e.li,{children:(0,c.jsxs)(e.strong,{children:["所有的函数，都有一个",(0,c.jsx)(e.code,{children:"prototype"}),"属性，属性值也是一个普通的对象"]})}),"\n",(0,c.jsx)(e.li,{children:(0,c.jsxs)(e.strong,{children:["所有的引用类型（数组、对象、函数），",(0,c.jsx)(e.code,{children:"__proto__"}),"属性值指向它的构造函数的",(0,c.jsx)(e.code,{children:"prototype"}),"属性值"]})}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"通过代码解释一下，大家可自行运行以下代码，看结果。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 要点一：自由扩展属性\nvar obj = {}; obj.a = 100;\nvar arr = []; arr.a = 100;\nfunction fn () {}\nfn.a = 100;\n\n// 要点二：__proto__\nconsole.log(obj.__proto__);\nconsole.log(arr.__proto__);\nconsole.log(fn.__proto__);\n\n// 要点三：函数有 prototype\nconsole.log(fn.prototype)\n\n// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值\nconsole.log(obj.__proto__ === Object.prototype)\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"原型",children:["原型",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#原型",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"先写一个简单的代码示例。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 构造函数\nfunction Foo(name, age) {\n    this.name = name\n}\nFoo.prototype.alertName = function () {\n    alert(this.name)\n}\n// 创建示例\nvar f = new Foo('zhangsan')\nf.printName = function () {\n    console.log(this.name)\n}\n// 测试\nf.printName()\nf.alertName()\n"})}),"\n",(0,c.jsxs)(e.p,{children:["执行",(0,c.jsx)(e.code,{children:"printName"}),"时很好理解，但是执行",(0,c.jsx)(e.code,{children:"alertName"}),"时发生了什么？这里再记住一个重点 ",(0,c.jsxs)(e.strong,{children:["当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的",(0,c.jsx)(e.code,{children:"__proto__"}),"（即它的构造函数的",(0,c.jsx)(e.code,{children:"prototype"}),"）中寻找"]}),"，因此",(0,c.jsx)(e.code,{children:"f.alertName"}),"就会找到",(0,c.jsx)(e.code,{children:"Foo.prototype.alertName"}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["那么如何判断这个属性是不是对象本身的属性呢？使用",(0,c.jsx)(e.code,{children:"hasOwnProperty"}),"，常用的地方是遍历一个对象的时候。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var item\nfor (item in f) {\n    // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性\n    if (f.hasOwnProperty(item)) {\n        console.log(item)\n    }\n}\n"})}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：如何理解 JS 的原型链"}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"原型链",children:["原型链",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["还是接着上面的示例，如果执行",(0,c.jsx)(e.code,{children:"f.toString()"}),"时，又发生了什么？"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 省略 N 行\n\n// 测试\nf.printName()\nf.alertName()\nf.toString()\n"})}),"\n",(0,c.jsxs)(e.p,{children:["因为",(0,c.jsx)(e.code,{children:"f"}),"本身没有",(0,c.jsx)(e.code,{children:"toString()"}),"，并且",(0,c.jsx)(e.code,{children:"f.__proto__"}),"（即",(0,c.jsx)(e.code,{children:"Foo.prototype"}),"）中也没有",(0,c.jsx)(e.code,{children:"toString"}),"。这个问题还是得拿出刚才那句话——",(0,c.jsxs)(e.strong,{children:["当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的",(0,c.jsx)(e.code,{children:"__proto__"}),"（即它的构造函数的",(0,c.jsx)(e.code,{children:"prototype"}),"）中寻找"]}),"。"]}),"\n",(0,c.jsxs)(e.p,{children:["如果在",(0,c.jsx)(e.code,{children:"f.__proto__"}),"中没有找到",(0,c.jsx)(e.code,{children:"toString"}),"，那么就继续去",(0,c.jsx)(e.code,{children:"f.__proto__.__proto__"}),"中寻找，因为",(0,c.jsx)(e.code,{children:"f.__proto__"}),"就是一个普通的对象而已嘛！"]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"f.__proto__"}),"即",(0,c.jsx)(e.code,{children:"Foo.prototype"}),"，没有找到",(0,c.jsx)(e.code,{children:"toString"}),"，继续往上找"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"f.__proto__.__proto__"}),"即",(0,c.jsx)(e.code,{children:"Foo.prototype.__proto__"}),"。",(0,c.jsx)(e.code,{children:"Foo.prototype"}),"就是一个普通的对象，因此",(0,c.jsx)(e.code,{children:"Foo.prototype.__proto__"}),"就是",(0,c.jsx)(e.code,{children:"Object.prototype"}),"，在这里可以找到",(0,c.jsx)(e.code,{children:"toString"})]}),"\n",(0,c.jsxs)(e.li,{children:["因此",(0,c.jsx)(e.code,{children:"f.toString"}),"最终对应到了",(0,c.jsx)(e.code,{children:"Object.prototype.toString"})]}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回",(0,c.jsx)(e.code,{children:"undefined"}),"。最上层是什么 —— ",(0,c.jsx)(e.code,{children:"Object.prototype.__proto__ === null"})]}),"\n",(0,c.jsxs)(e.h3,{id:"原型链中的this",children:["原型链中的",(0,c.jsx)(e.code,{children:"this"}),(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#原型链中的this",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["所有从原型或更高级原型中得到、执行的方法，其中的",(0,c.jsx)(e.code,{children:"this"}),"在执行时，就指向了当前这个触发事件执行的对象。因此",(0,c.jsx)(e.code,{children:"printName"}),"和",(0,c.jsx)(e.code,{children:"alertName"}),"中的",(0,c.jsx)(e.code,{children:"this"}),"都是",(0,c.jsx)(e.code,{children:"f"}),"。"]}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsxs)(e.h2,{id:"作用域和闭包",children:["作用域和闭包",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#作用域和闭包",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"作用域和闭包是前端面试中，最可能考查的知识点。例如下面的题目："}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就",(0,c.jsx)(e.code,{children:"alert"}),"弹出其编号"]}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-html",children:"<ul>\n    <li>编号1，点击我请弹出1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n</ul>\n"})}),"\n",(0,c.jsx)(e.p,{children:"一般不知道这个题目用闭包的话，会写出下面的代码："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var list = document.getElementsByTagName('li');\nfor (var i = 0; i < list.length; i++) {\n    list[i].addEventListener('click', function(){\n        alert(i + 1)\n    }, true)\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["实际上执行才会发现始终弹出的是",(0,c.jsx)(e.code,{children:"6"}),"，这时候就应该通过闭包来解决："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var list = document.getElementsByTagName('li');\nfor (var i = 0; i < list.length; i++) {\n    list[i].addEventListener('click', function(i){\n        return function(){\n            alert(i + 1)\n        }\n    }(i), true)\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"要理解闭包，就需要我们从「执行上下文」开始讲起。"}),"\n",(0,c.jsxs)(e.h3,{id:"执行上下文",children:["执行上下文",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#执行上下文",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["先讲一个关于 ",(0,c.jsx)(e.strong,{children:"变量提升"})," 的知识点，面试中可能会遇见下面的问题，很多候选人都回答错误："]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：说出下面执行的结果（这里笔者直接注释输出了）"}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"console.log(a)  // undefined\nvar a = 100\n\nfn('zhangsan')  // 'zhangsan' 20\nfunction fn(name) {\n    age = 20\n    console.log(name, age)\n    var age\n}\n\nconsole.log(b); // 这里报错\n// Uncaught ReferenceError: b is not defined\nb = 100;\n\n"})}),"\n",(0,c.jsxs)(e.p,{children:["在一段 JS 脚本（即一个",(0,c.jsx)(e.code,{children:"<script>"}),"标签中）执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 ",(0,c.jsx)(e.strong,{children:"全局执行上下文"})," 环境，先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为",(0,c.jsx)(e.code,{children:"undefined"}),"，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。"]}),"\n",(0,c.jsxs)(e.p,{children:["我们来看下上面的面试小题目，为什么",(0,c.jsx)(e.code,{children:"a"}),"是",(0,c.jsx)(e.code,{children:"undefined"}),"，而",(0,c.jsx)(e.code,{children:"b"}),"却报错了，实际 JS 在代码执行之前，要「全文解析」，发现",(0,c.jsx)(e.code,{children:"var a"}),"，知道有个",(0,c.jsx)(e.code,{children:"a"}),"的变量，存入了执行上下文，而",(0,c.jsx)(e.code,{children:"b"}),"没有找到",(0,c.jsx)(e.code,{children:"var"}),"关键字，这时候没有在执行上下文提前「占位」，所以代码执行的时候，提前报到的",(0,c.jsx)(e.code,{children:"a"}),"是有记录的，只不过值暂时还没有赋值，即为",(0,c.jsx)(e.code,{children:"undefined"}),"，而",(0,c.jsx)(e.code,{children:"b"}),"在执行上下文没有找到，自然会报错（没有找到",(0,c.jsx)(e.code,{children:"b"}),"的引用）。"]}),"\n",(0,c.jsxs)(e.p,{children:["另外，一个函数在执行之前，也会创建一个 ",(0,c.jsx)(e.strong,{children:"函数执行上下文"})," 环境，跟 ",(0,c.jsx)(e.strong,{children:"全局上下文"})," 差不多，不过 ",(0,c.jsx)(e.strong,{children:"函数执行上下文"})," 中会多出",(0,c.jsx)(e.code,{children:"this"})," ",(0,c.jsx)(e.code,{children:"arguments"}),"和函数的参数。参数和",(0,c.jsx)(e.code,{children:"arguments"}),"好理解，这里的",(0,c.jsx)(e.code,{children:"this"}),"咱们需要专门讲解。"]}),"\n",(0,c.jsx)(e.p,{children:"总结一下："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["范围：一段",(0,c.jsx)(e.code,{children:"<script>"}),"、js 文件或者一个函数"]}),"\n",(0,c.jsx)(e.li,{children:"全局上下文：变量定义，函数声明"}),"\n",(0,c.jsxs)(e.li,{children:["函数上下文：变量定义，函数声明，",(0,c.jsx)(e.code,{children:"this"}),"，",(0,c.jsx)(e.code,{children:"arguments"})]}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"this",children:[(0,c.jsx)(e.code,{children:"this"}),(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#this",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["先搞明白一个很重要的概念 —— ",(0,c.jsxs)(e.strong,{children:[(0,c.jsx)(e.code,{children:"this"}),"的值是在执行的时候才能确认，定义的时候不能确认！"]})," 为什么呢 —— 因为",(0,c.jsx)(e.code,{children:"this"}),"是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var a = {\n    name: 'A',\n    fn: function () {\n        console.log(this.name)\n    }\n}\na.fn()  // this === a\na.fn.call({name: 'B'})  // this === {name: 'B'}\nvar fn1 = a.fn\nfn1()  // this === window\n"})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"this"}),"执行会有不同，主要集中在这几个场景中"]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsx)(e.p,{children:"作为构造函数执行，构造函数中"}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["作为对象属性执行，上述代码中",(0,c.jsx)(e.code,{children:"a.fn()"})]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["作为普通函数执行，上述代码中",(0,c.jsx)(e.code,{children:"fn1()"})]}),"\n"]}),"\n",(0,c.jsxs)(e.li,{children:["\n",(0,c.jsxs)(e.p,{children:["用于",(0,c.jsx)(e.code,{children:"call"})," ",(0,c.jsx)(e.code,{children:"apply"})," ",(0,c.jsx)(e.code,{children:"bind"}),"，上述代码中",(0,c.jsx)(e.code,{children:"a.fn.call({name: 'B'})"})]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"下面再来讲解下什么是作用域和作用域链，作用域链和作用域也是常考的题目。"}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：如何理解 JS 的作用域和作用域链"}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"作用域",children:["作用域",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#作用域",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"ES6 之前 JS 没有块级作用域。例如"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"if (true) {\n    var name = 'zhangsan'\n}\nconsole.log(name)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["从上面的例子可以体会到作用域的概念，作用域就是一个独立的地盘，让变量不会外泄、暴露出去。上面的",(0,c.jsx)(e.code,{children:"name"}),"就被暴露出去了，因此，",(0,c.jsx)(e.strong,{children:"JS 没有块级作用域，只有全局作用域和函数作用域"}),"。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var a = 100\nfunction fn() {\n    var a = 200\n    console.log('fn', a)\n}\nconsole.log('global', a)\nfn()\n"})}),"\n",(0,c.jsx)(e.p,{children:"全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易撞车、冲突。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 张三写的代码中\nvar data = {a: 100}\n\n// 李四写的代码中\nvar data = {x: true}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在",(0,c.jsx)(e.code,{children:"(function(){....})()"}),"中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。"]}),"\n",(0,c.jsxs)(e.p,{children:["附：ES6 中开始加入了块级作用域，使用",(0,c.jsx)(e.code,{children:"let"}),"定义变量即可，如下："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"if (true) {\n    let name = 'zhangsan'\n}\nconsole.log(name)  // 报错，因为let定义的name是在if这个块级作用域\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"作用域链",children:["作用域链",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#作用域链",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["首先认识一下什么叫做 ",(0,c.jsx)(e.strong,{children:"自由变量"})," 。如下代码中，",(0,c.jsx)(e.code,{children:"console.log(a)"}),"要得到",(0,c.jsx)(e.code,{children:"a"}),"变量，但是在当前的作用域中没有定义",(0,c.jsx)(e.code,{children:"a"}),"（可对比一下",(0,c.jsx)(e.code,{children:"b"}),"）。当前作用域没有定义的变量，这成为 ",(0,c.jsx)(e.strong,{children:"自由变量"})," 。自由变量如何得到 —— 向父级作用域寻找。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var a = 100\nfunction fn() {\n    var b = 200\n    console.log(a)\n    console.log(b)\n}\nfn()\n"})}),"\n",(0,c.jsxs)(e.p,{children:["如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 ",(0,c.jsx)(e.strong,{children:"作用域链"})," 。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var a = 100\nfunction F1() {\n    var b = 200\n    function F2() {\n        var c = 300\n        console.log(a) // 自由变量，顺作用域链向父作用域找\n        console.log(b) // 自由变量，顺作用域链向父作用域找\n        console.log(c) // 本作用域的变量\n    }\n    F2()\n}\nF1()\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"闭包",children:["闭包",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#闭包",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"讲完这些内容，我们再来看一个例子，通过例子来理解闭包。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function F1() {\n    var a = 100\n    return function () {\n        console.log(a)\n    }\n}\nvar f1 = F1()\nvar a = 200\nf1()\n"})}),"\n",(0,c.jsxs)(e.p,{children:["自由变量将从作用域链中去寻找，但是 ",(0,c.jsx)(e.strong,{children:"依据的是函数定义时的作用域链，而不是函数执行时"}),"，以上这个例子就是闭包。闭包主要有两个应用场景："]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"函数作为返回值"}),"，上面的例子就是"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.strong,{children:"函数作为参数传递"}),"，看以下例子"]}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function F1() {\n    var a = 100\n    return function () {\n        console.log(a)\n    }\n}\nfunction F2(f1) {\n    var a = 200\n    console.log(f1())\n}\nvar f1 = F1()\nF2(f1)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["至此，对应着「作用域和闭包」这部分一开始的点击弹出",(0,c.jsx)(e.code,{children:"alert"}),"的代码再看闭包，就很好理解了。"]}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsxs)(e.h2,{id:"异步",children:["异步",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#异步",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"异步和同步也是面试中常考的内容，下面笔者来讲解下同步和异步的区别。"}),"\n",(0,c.jsxs)(e.h3,{id:"同步-vs-异步",children:["同步 vs 异步",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#同步-vs-异步",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["先看下面的 demo，根据程序阅读起来表达的意思，应该是先打印",(0,c.jsx)(e.code,{children:"100"}),"，1秒钟之后打印",(0,c.jsx)(e.code,{children:"200"}),"，最后打印",(0,c.jsx)(e.code,{children:"300"}),"。但是实际运行根本不是那么回事。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"console.log(100)\nsetTimeout(function () {\n    console.log(200)\n}, 1000)\nconsole.log(300)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["再对比以下程序。先打印",(0,c.jsx)(e.code,{children:"100"}),"，再弹出",(0,c.jsx)(e.code,{children:"200"}),"（等待用户确认），最后打印",(0,c.jsx)(e.code,{children:"300"}),"。这个运行效果就符合预期要求。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"console.log(100)\nalert(200)  // 1秒钟之后点击确认\nconsole.log(300)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这俩到底有何区别？—— 第一个示例中间的步骤根本没有阻塞接下来程序的运行，而第二个示例却阻塞了后面程序的运行。前面这种表现就叫做 ",(0,c.jsx)(e.strong,{children:"异步"}),"（后面这个叫做 ",(0,c.jsx)(e.strong,{children:"同步"})," ），即",(0,c.jsx)(e.strong,{children:"不会阻塞后面程序的运行"}),"。"]}),"\n",(0,c.jsxs)(e.h3,{id:"异步和单线程",children:["异步和单线程",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#异步和单线程",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["JS 需要异步的根本原因是 ",(0,c.jsx)(e.strong,{children:"JS 是单线程运行的"}),"，即在同一时间只能做一件事，不能“一心二用”。"]}),"\n",(0,c.jsx)(e.p,{children:"一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。"}),"\n",(0,c.jsx)(e.p,{children:"讲到单线程，我们再来看个真题："}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：讲解下面代码的执行过程和结果"}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"var a = true;\nsetTimeout(function(){\n    a = false;\n}, 100)\nwhile(a){\n    console.log('while执行了')\n}\n"})}),"\n",(0,c.jsxs)(e.p,{children:["这是一个很有迷惑性的题目，不少候选人认为",(0,c.jsx)(e.code,{children:"100ms"}),"之后，由于",(0,c.jsx)(e.code,{children:"a"}),"变成了",(0,c.jsx)(e.code,{children:"false"}),"，所以",(0,c.jsx)(e.code,{children:"while"}),"就中止了，实际不是这样，因为JS是单线程的，所以进入",(0,c.jsx)(e.code,{children:"while"}),"循环之后，没有「时间」（线程）去跑定时器了，所以这个代码跑起来是个死循环！"]}),"\n",(0,c.jsxs)(e.h3,{id:"前端异步的场景",children:["前端异步的场景",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前端异步的场景",children:"#"})]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["定时 ",(0,c.jsx)(e.code,{children:"setTimeout"})," ",(0,c.jsx)(e.code,{children:"setInterval"})]}),"\n",(0,c.jsxs)(e.li,{children:["网络请求，如 ",(0,c.jsx)(e.code,{children:"Ajax"})," ",(0,c.jsx)(e.code,{children:"<img>"}),"加载"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"Ajax 代码示例"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"console.log('start')\n$.get('./data1.json', function (data1) {\n    console.log(data1)\n})\nconsole.log('end')\n"})}),"\n",(0,c.jsx)(e.p,{children:"img 代码示例（常用于打点统计）"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"console.log('start')\nvar img = document.createElement('img')\n// 或者 img = new Image()\nimg.onload = function () {\n    console.log('loaded')\n    img.onload = null\n}\nimg.src = '/xxx.png'\nconsole.log('end')\n"})}),"\n",(0,c.jsx)(e.hr,{}),"\n",(0,c.jsxs)(e.h2,{id:"es67-新标准的考查",children:["ES6/7 新标准的考查",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#es67-新标准的考查",children:"#"})]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.p,{children:["题目：ES6 箭头函数中的",(0,c.jsx)(e.code,{children:"this"}),"和普通函数中的有什么不同"]}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"箭头函数",children:["箭头函数",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#箭头函数",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:["箭头函数是 ES6 中新的函数定义形式，",(0,c.jsx)(e.code,{children:"function name(arg1, arg2) {...}"}),"可以使用",(0,c.jsx)(e.code,{children:"(arg1, arg2) => {...}"}),"来定义。示例如下："]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// JS 普通函数\nvar arr = [1, 2, 3]\narr.map(function (item) {\n    console.log(index)\n    return item + 1\n})\n\n// ES6 箭头函数\nconst arr = [1, 2, 3]\narr.map((item, index) => {\n    console.log(index)\n    return item + 1\n})\n"})}),"\n",(0,c.jsxs)(e.p,{children:["箭头函数存在的意义，第一写起来更加简洁，第二可以解决 ES6 之前函数执行中",(0,c.jsx)(e.code,{children:"this"}),"是全局变量的问题，看如下代码"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function fn() {\n    console.log('real', this)  // {a: 100} ，该作用域下的 this 的真实的值\n    var arr = [1, 2, 3]\n    // 普通 JS\n    arr.map(function (item) {\n        console.log('js', this)  // window 。普通函数，这里打印出来的是全局变量，令人费解\n        return item + 1\n    })\n    // 箭头函数\n    arr.map(item => {\n        console.log('es6', this)  // {a: 100} 。箭头函数，这里打印的就是父作用域的 this\n        return item + 1\n    })\n}\nfn.call({a: 100})\n"})}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：ES6 模块化如何使用？"}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"module",children:["Module",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#module",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"ES6 中模块化语法更加简洁，直接看示例。"}),"\n",(0,c.jsxs)(e.p,{children:["如果只是输出一个唯一的对象，使用",(0,c.jsx)(e.code,{children:"export default"}),"即可，代码如下"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 创建 util1.js 文件，内容如\nexport default {\n    a: 100\n}\n\n// 创建 index.js 文件，内容如\nimport obj from './util1.js'\nconsole.log(obj)\n"})}),"\n",(0,c.jsxs)(e.p,{children:["如果想要输出许多个对象，就不能用",(0,c.jsx)(e.code,{children:"default"}),"了，且",(0,c.jsx)(e.code,{children:"import"}),"时候要加",(0,c.jsx)(e.code,{children:"{...}"}),"，代码如下"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 创建 util2.js 文件，内容如\nexport function fn1() {\n    alert('fn1')\n}\nexport function fn2() {\n    alert('fn2')\n}\n\n// 创建 index.js 文件，内容如\nimport { fn1, fn2 } from './util2.js'\nfn1()\nfn2()\n"})}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：ES6 class 和普通构造函数的区别"}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"class",children:["class",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#class",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"class 其实一直是 JS 的关键字（保留字），但是一直没有正式使用，直到 ES6 。 ES6 的 class 就是取代之前构造函数初始化对象的形式，从语法上更加符合面向对象的写法。例如："}),"\n",(0,c.jsx)(e.p,{children:"JS 构造函数的写法"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"function MathHandle(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nMathHandle.prototype.add = function () {\n  return this.x + this.y;\n};\n\nvar m = new MathHandle(1, 2);\nconsole.log(m.add())\n"})}),"\n",(0,c.jsx)(e.p,{children:"用 ES6 class 的写法"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"class MathHandle {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add() {\n    return this.x + this.y;\n  }\n}\nconst m = new MathHandle(1, 2);\nconsole.log(m.add())\n"})}),"\n",(0,c.jsx)(e.p,{children:"注意以下几点，全都是关于 class 语法的："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["class 是一种新的语法形式，是",(0,c.jsx)(e.code,{children:"class Name {...}"}),"这种形式，和函数的写法完全不一样"]}),"\n",(0,c.jsxs)(e.li,{children:["两者对比，构造函数函数体的内容要放在 class 中的",(0,c.jsx)(e.code,{children:"constructor"}),"函数中，",(0,c.jsx)(e.code,{children:"constructor"}),"即构造器，初始化实例时默认执行"]}),"\n",(0,c.jsxs)(e.li,{children:["class 中函数的写法是",(0,c.jsx)(e.code,{children:"add() {...}"}),"这种形式，并没有",(0,c.jsx)(e.code,{children:"function"}),"关键字"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"使用 class 来实现继承就更加简单了，至少比构造函数实现继承简单很多。看下面例子"}),"\n",(0,c.jsx)(e.p,{children:"JS 构造函数实现继承"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 动物\nfunction Animal() {\n    this.eat = function () {\n        console.log('animal eat')\n    }\n}\n// 狗\nfunction Dog() {\n    this.bark = function () {\n        console.log('dog bark')\n    }\n}\nDog.prototype = new Animal()\n// 哈士奇\nvar hashiqi = new Dog()\n"})}),"\n",(0,c.jsx)(e.p,{children:"ES6 class 实现继承"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"class Animal {\n    constructor(name) {\n        this.name = name\n    }\n    eat() {\n        console.log(`${this.name} eat`)\n    }\n}\n\nclass Dog extends Animal {\n    constructor(name) {\n        super(name)\n        this.name = name\n    }\n    say() {\n        console.log(`${this.name} say`)\n    }\n}\nconst dog = new Dog('哈士奇')\ndog.say()\ndog.eat()\n"})}),"\n",(0,c.jsx)(e.p,{children:"注意以下两点："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:["使用",(0,c.jsx)(e.code,{children:"extends"}),"即可实现继承，更加符合经典面向对象语言的写法，如 Java"]}),"\n",(0,c.jsxs)(e.li,{children:["子类的",(0,c.jsx)(e.code,{children:"constructor"}),"一定要执行",(0,c.jsx)(e.code,{children:"super()"}),"，以调用父类的",(0,c.jsx)(e.code,{children:"constructor"})]}),"\n"]}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsx)(e.p,{children:"题目：ES6 中新增的数据类型有哪些？"}),"\n"]}),"\n",(0,c.jsxs)(e.h3,{id:"set-和-map",children:["Set 和 Map",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#set-和-map",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"Set 和 Map 都是 ES6 中新增的数据结构，是对当前 JS 数组和对象这两种重要数据结构的扩展。由于是新增的数据结构，目前尚未被大规模使用，但是作为前端程序员，提前了解是必须做到的。先总结一下两者最关键的地方："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"Set 类似于数组，但数组可以允许元素重复，Set 不允许元素重复"}),"\n",(0,c.jsx)(e.li,{children:"Map 类似于对象，但普通对象的 key 必须是字符串或者数字，而 Map 的 key 可以是任何数据类型"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Set"})}),"\n",(0,c.jsxs)(e.p,{children:["Set 实例不允许元素有重复，可以通过以下示例证明。可以通过一个数组初始化一个 Set 实例，或者通过",(0,c.jsx)(e.code,{children:"add"}),"添加元素，元素不能重复，重复的会被忽略。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"// 例1\nconst set = new Set([1, 2, 3, 4, 4]);\nconsole.log(set) // Set(4)\xa0{1, 2, 3, 4}\n\n// 例2\nconst set = new Set();\n[2, 3, 5, 4, 5, 8, 8].forEach(item => set.add(item));\nfor (let item of set) {\n  console.log(item);\n}\n// 2 3 5 4 8\n"})}),"\n",(0,c.jsx)(e.p,{children:"Set 实例的属性和方法有"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"size"}),"：获取元素数量。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"add(value)"}),"：添加元素，返回 Set 实例本身。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"delete(value)"}),"：删除元素，返回一个布尔值，表示删除是否成功。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"has(value)"}),"：返回一个布尔值，表示该值是否是 Set 实例的元素。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"clear()"}),"：清除所有元素，没有返回值。"]}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const s = new Set();\ns.add(1).add(2).add(2); // 添加元素\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2);\ns.has(2) // false\n\ns.clear();\nconsole.log(s);  // Set(0)\xa0{}\n"})}),"\n",(0,c.jsx)(e.p,{children:"Set 实例的遍历，可使用如下方法"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"keys()"}),"：返回键名的遍历器。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"values()"}),"：返回键值的遍历器。不过由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以",(0,c.jsx)(e.code,{children:"keys()"}),"和",(0,c.jsx)(e.code,{children:"values()"}),"返回结果一致。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"entries()"}),"：返回键值对的遍历器。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"forEach()"}),"：使用回调函数遍历每个成员。"]}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:'let set = new Set([\'aaa\', \'bbb\', \'ccc\']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// aaa\n// bbb\n// ccc\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// aaa\n// bbb\n// ccc\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// ["aaa", "aaa"]\n// ["bbb", "bbb"]\n// ["ccc", "ccc"]\n\nset.forEach((value, key) => console.log(key + \' : \' + value))\n// aaa : aaa\n// bbb : bbb\n// ccc : ccc\n'})}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)(e.strong,{children:"Map"})}),"\n",(0,c.jsx)(e.p,{children:"Map 的用法和普通对象基本一致，先看一下它能用非字符串或者数字作为 key 的特性。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const map = new Map();\nconst obj = {p: 'Hello World'};\n\nmap.set(obj, 'OK')\nmap.get(obj) // \"OK\"\n\nmap.has(obj) // true\nmap.delete(obj) // true\nmap.has(obj) // false\n"})}),"\n",(0,c.jsxs)(e.p,{children:["需要使用",(0,c.jsx)(e.code,{children:"new Map()"}),"初始化一个实例，下面代码中",(0,c.jsx)(e.code,{children:"set"})," ",(0,c.jsx)(e.code,{children:"get"})," ",(0,c.jsx)(e.code,{children:"has"})," ",(0,c.jsx)(e.code,{children:"delete"}),"顾名即可思义（下文也会演示）。其中，",(0,c.jsx)(e.code,{children:"map.set(obj, 'OK')"}),"就是用对象作为的 key （不光可以是对象，任何数据类型都可以），并且后面通过",(0,c.jsx)(e.code,{children:"map.get(obj)"}),"正确获取了。"]}),"\n",(0,c.jsx)(e.p,{children:"Map 实例的属性和方法如下："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"size"}),"：获取成员的数量"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"set"}),"：设置成员 key 和 value"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"get"}),"：获取成员属性值"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"has"}),"：判断成员是否存在"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"delete"}),"：删除成员"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"clear"}),"：清空所有"]}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const map = new Map();\nmap.set('aaa', 100);\nmap.set('bbb', 200);\n\nmap.size // 2\n\nmap.get('aaa') // 100\n\nmap.has('aaa') // true\n\nmap.delete('aaa')\nmap.has('aaa') // false\n\nmap.clear()\n"})}),"\n",(0,c.jsx)(e.p,{children:"Map 实例的遍历方法有："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"keys()"}),"：返回键名的遍历器。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"values()"}),"：返回键值的遍历器。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"entries()"}),"：返回所有成员的遍历器。"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"forEach()"}),"：遍历 Map 的所有成员。"]}),"\n"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-js",children:"const map = new Map();\nmap.set('aaa', 100);\nmap.set('bbb', 200);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// \"aaa\"\n// \"bbb\"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// 100\n// 200\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// aaa 100\n// bbb 200\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// aaa 100\n// bbb 200\n"})}),"\n",(0,c.jsxs)(e.h3,{id:"promise",children:["Promise",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#promise",children:"#"})]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"Promise"}),"是 CommonJS 提出来的这一种规范，有多个版本，在 ES6 当中已经纳入规范，原生支持 Promise 对象，非 ES6 环境可以用类似 Bluebird、Q 这类库来支持。"]}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"Promise"})," 可以将回调变成链式调用写法，流程更加清晰，代码更加优雅。"]}),"\n",(0,c.jsxs)(e.p,{children:["简单归纳下 Promise：",(0,c.jsx)(e.strong,{children:"三个状态、两个过程、一个方法"}),"，快速记忆方法：",(0,c.jsx)(e.strong,{children:"3-2-1"})]}),"\n",(0,c.jsxs)(e.p,{children:["三个状态：",(0,c.jsx)(e.code,{children:"pending"}),"、",(0,c.jsx)(e.code,{children:"fulfilled"}),"、",(0,c.jsx)(e.code,{children:"rejected"})]}),"\n",(0,c.jsx)(e.p,{children:"两个过程："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"pending→fulfilled（resolve）"}),"\n",(0,c.jsx)(e.li,{children:"pending→rejected（reject）"}),"\n"]}),"\n",(0,c.jsxs)(e.p,{children:["一个方法：",(0,c.jsx)(e.code,{children:"then"})]}),"\n",(0,c.jsxs)(e.p,{children:["当然还有其他概念，如",(0,c.jsx)(e.code,{children:"catch"}),"、 ",(0,c.jsx)(e.code,{children:"Promise.all/race"}),"，这里就不展开了。"]}),"\n",(0,c.jsxs)(e.p,{children:["关于 ES6/7 的考查内容还有很多，本小节就不逐一介绍了，如果想继续深入学习，可以在线看《",(0,c.jsx)(e.a,{href:"http://es6.ruanyifeng.com/",target:"_blank",rel:"noopener noreferrer",children:"ES6入门"}),"》。"]}),"\n",(0,c.jsxs)(e.h2,{id:"小结",children:["小结",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"本小节主要总结了 ES 基础语法中面试经常考查的知识点，包括之前就考查较多的原型、异步、作用域，以及 ES6 的一些新内容，这些知识点希望大家都要掌握。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(r,{...n})}):r(n)}let i=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Web%20%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E8%A7%A3%E6%9E%90%2F2.%E4%B8%80%E9%9D%A2%201%EF%BC%9AES%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E9%AB%98%E9%A2%91%E8%80%83%E9%A2%98%E8%A7%A3%E6%9E%90.md"]={toc:[{text:"知识点梳理",id:"知识点梳理",depth:2},{text:"变量类型",id:"变量类型",depth:2},{text:"`typeof`",id:"typeof",depth:3},{text:"`instanceof`",id:"instanceof",depth:3},{text:"值类型 vs 引用类型",id:"值类型-vs-引用类型",depth:3},{text:"原型和原型链",id:"原型和原型链",depth:2},{text:"原型",id:"原型",depth:3},{text:"原型链",id:"原型链",depth:3},{text:"原型链中的`this`",id:"原型链中的this",depth:3},{text:"作用域和闭包",id:"作用域和闭包",depth:2},{text:"执行上下文",id:"执行上下文",depth:3},{text:"`this`",id:"this",depth:3},{text:"作用域",id:"作用域",depth:3},{text:"作用域链",id:"作用域链",depth:3},{text:"闭包",id:"闭包",depth:3},{text:"异步",id:"异步",depth:2},{text:"同步 vs 异步",id:"同步-vs-异步",depth:3},{text:"异步和单线程",id:"异步和单线程",depth:3},{text:"前端异步的场景",id:"前端异步的场景",depth:3},{text:"ES6/7 新标准的考查",id:"es67-新标准的考查",depth:2},{text:"箭头函数",id:"箭头函数",depth:3},{text:"Module",id:"module",depth:3},{text:"class",id:"class",depth:3},{text:"Set 和 Map",id:"set-和-map",depth:3},{text:"Promise",id:"promise",depth:3},{text:"小结",id:"小结",depth:2}],title:"2.一面 1：ES 基础知识点与高频考题解析",headingTitle:"2.一面 1：ES 基础知识点与高频考题解析",frontmatter:{}}}}]);