"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["1174"],{810508:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var s=r(552676),d=r(740453);let c=r.p+"static/image/b2749596d2e7fa52bfdbcf7724d80402.73443da7.webp",i=r.p+"static/image/3ea18ffc15651b2fc9a49b4e55473e30.fbda3922.webp",l=r.p+"static/image/a88b26e8da0f6bbbeba96da8865bb5b3.519e35ae.webp",t=r.p+"static/image/f9bf6a895293faa23f1eef252bc99aee.6c4ab51a.webp",h=r.p+"static/image/4ab2b3c78e5f5e7f7ba4ca261adbdfab.0a2c667d.webp",a=r.p+"static/image/f10138a7ae632f9121ed8433d4f561de.10b371cc.webp";function x(e){let n=Object.assign({p:"p",h1:"h1",a:"a",code:"code",strong:"strong",ul:"ul",li:"li",img:"img",h2:"h2",pre:"pre",blockquote:"blockquote",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ol:"ol"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"在正式进入 React Hooks 源码的章节前，我们需要了解两个核心概念：Fiber 和并发。\n因为学习源码必然绕不开这两大核心概念，了解它们，对我们之后学习源码有着莫大的好处。"}),"\n",(0,s.jsxs)(n.h1,{id:"9源码前置篇搞懂-fiber-和并发",children:["9.源码前置篇｜搞懂 Fiber 和并发",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9源码前置篇搞懂-fiber-和并发",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在一个庞大的项目中，如果有某个节点发生变化，就会给 ",(0,s.jsx)(n.code,{children:"diff"})," 带来巨大的压力，此时想要找到真正变化的部分就会耗费大量的时间，也就是说此时，js 会占据主线程去做对比，导致无法正常的页面渲染，此时就会发生页面卡顿、页面响应变差、动画、手势等应用效果差。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了解决这一问题，React 团队花费两年时间，重写了 React 的核心算法",(0,s.jsx)(n.code,{children:"reconciliation"}),"，在 React v16 中发布，为了区分 ",(0,s.jsx)(n.code,{children:"reconciler（调和器）"}),"，将之前的 ",(0,s.jsx)(n.code,{children:"reconciler"})," 称为 ",(0,s.jsx)(n.code,{children:"stack reconciler"}),"，之后称作 ",(0,s.jsx)(n.strong,{children:"fiber reconciler（简称：Fiber）"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["简而言之，",(0,s.jsx)(n.strong,{children:"Fiber"})," 实际上是一种核心算法，为了解决",(0,s.jsx)(n.strong,{children:"中断和树庞大"}),"的问题，也可以认为 ",(0,s.jsx)(n.strong,{children:"Fiber"})," 就是 v16 之后的",(0,s.jsx)(n.strong,{children:"虚拟 DOM"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了之后更好的理解，我们先来看看 ",(0,s.jsx)(n.code,{children:"element"}),"、",(0,s.jsx)(n.code,{children:"fiber"}),"、",(0,s.jsx)(n.code,{children:"DOM 元素"}),"三者的关系："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["element 对象就是我们的 ",(0,s.jsx)(n.code,{children:"jsx"})," 代码，上面保存了 ",(0,s.jsx)(n.code,{children:"props"}),"、",(0,s.jsx)(n.code,{children:"key"}),"、",(0,s.jsx)(n.code,{children:"children"})," 等信息；"]}),"\n",(0,s.jsx)(n.li,{children:"DOM 元素就是最终呈现给用户展示的效果；"}),"\n",(0,s.jsxs)(n.li,{children:["而 fiber 就是充当 element 和 DOM 元素的桥梁，简单来说，",(0,s.jsx)(n.strong,{children:"只要 element 发生改变，就会通过 fiber 做一次调和，使对应的 DOM 元素发生改变。"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这里附上一张关于 ",(0,s.jsx)(n.strong,{children:"Fiber"})," 的简图："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"知悉Fiber.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"虚拟-dom-如何转化为-fiber-的",children:["虚拟 DOM 如何转化为 Fiber 的？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#虚拟-dom-如何转化为-fiber-的",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["万物始于 ",(0,s.jsx)(n.code,{children:"jsx"}),"，那么我们就从 jsx 入手，从而了解 Fiber。"]}),"\n",(0,s.jsx)(n.p,{children:"先看看最常见的一段 jsx 代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const Index = () => {\n  return <div>大家好，我是小杜杜，一起玩转hooks吧！</div>;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后到达绑定的结构："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import ReactDOM from 'react-dom/client';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  <App />\n);\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注：React v18 将原先的 ",(0,s.jsx)(n.code,{children:"render"})," 替换为 ",(0,s.jsx)(n.code,{children:"createRoot"}),"，也就是将原先的",(0,s.jsx)(n.code,{children:"legacy"})," 模式转化为 ",(0,s.jsx)(n.code,{children:"concurrent"})," 模式。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"ReactDOM.createRoot 结构："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"实际上，依旧走的是之前的 render 方法。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"问：既然都走的 render 方法，那么 React 为什么要替换为 createRoot 呢？"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["答：最大的改变点是模式的转化，原先的 ",(0,s.jsx)(n.strong,{children:"legacy 模式是同步"}),"的，而转化后的 ",(0,s.jsx)(n.strong,{children:"concurrent 模式是异步"}),"的。可以说在 React v18 的版本中兼容了",(0,s.jsx)(n.strong,{children:"同步渲染"}),"和",(0,s.jsx)(n.strong,{children:"异步渲染"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["其次是对服务端的改变，在新版本中，替换了原有的 ",(0,s.jsx)(n.code,{children:"hydrate API"}),"，做成了配置项，而非原有的 ",(0,s.jsx)(n.code,{children:"ReactDOM.hydrate"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"beginwork-方法",children:["beginWork 方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#beginwork-方法",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["当普通的 JSX 代码被 babel 编译成 React.createElement 的形式后，最终会走到",(0,s.jsx)(n.code,{children:"beginWork"})," 这个方法中。"]}),"\n",(0,s.jsx)(n.p,{children:"这个方法可以说是 React 整个流程的开始，要特别注意这个方法。beginWork 中有个 tag，而这个 tag 的类型就是判断 element 对应的 fiber，如："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["由于 ",(0,s.jsx)(n.strong,{children:"beginWork"})," 这个方法非常重要，因为将这三个参数提及下，我们要存在一个基础的概念。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"beginWork 的入参"}),"："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"current"}),"：在视图层渲染的树；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"workInProgress"}),"：这个参数尤为重要，它就是在整个内存中所构建的 ",(0,s.jsx)(n.code,{children:"Fiber"}),"；树，所有的更新都发生在 ",(0,s.jsx)(n.code,{children:"workInProgress"})," 中，所以这个树是",(0,s.jsx)(n.strong,{children:"最新"}),"状态的，之后它将替换给 ",(0,s.jsx)(n.code,{children:"current"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"renderLanes"}),"：跟优先级有关。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"element 与 fiber 的对应关系"}),"（这里总结了一些常见的对照表，提供参考）："]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"fiber"}),"\n",(0,s.jsx)(n.th,{children:"element"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"FunctionComponent"})," = 0"]}),"\n",(0,s.jsx)(n.td,{children:"函数组件"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"ClassComponent"})," = 1"]}),"\n",(0,s.jsx)(n.td,{children:"类组件"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"IndeterminateComponent = 2"}),"\n",(0,s.jsx)(n.td,{children:"初始化的时候不知道是函数组件还是类组件"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"HostRoot = 3"}),"\n",(0,s.jsx)(n.td,{children:"根元素，通过reactDom.render()产生的根元素"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"HostPortal = 4"}),"\n",(0,s.jsx)(n.td,{children:"ReactDOM.createPortal 产生的 Portal"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"HostComponent = 5"}),"\n",(0,s.jsxs)(n.td,{children:["dom 元素（如",(0,s.jsx)(n.code,{children:"<div>"}),"）"]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"HostText = 6"}),"\n",(0,s.jsx)(n.td,{children:"文本节点"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"Fragment = 7"}),"\n",(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"<React.Fragment>"}),"）"]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"Mode = 8"}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<React.StrictMode>"})}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"ContextConsumer = 9"}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<Context.Consumer>"})}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"ContextProvider = 10"}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<Context.Provider>"})}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"ForwardRef = 11"}),"\n",(0,s.jsx)(n.td,{children:"React.ForwardRef"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"Profiler = 12"}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<Profiler>"})}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"SuspenseComponent = 13"}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<Suspense>"})}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"MemoComponent = 14"}),"\n",(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"React.memo"})," 返回的组件"]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"SimpleMemoComponent = 15"}),"\n",(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"React.memo"})," 没有制定比较的方法，所返回的组件"]}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"LazyComponent = 16"}),"\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"<lazy />"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"fiber-中保存了什么",children:["Fiber 中保存了什么？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#fiber-中保存了什么",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"那么 Fiber 究竟保存了什么，一起来看看："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["源码位置：",(0,s.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiber.js"}),"中的",(0,s.jsx)(n.code,{children:"FiberNode"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["为了更直观地查看 ",(0,s.jsx)(n.code,{children:"FiberNode"})," 的属性，我们直接看对应的 ",(0,s.jsx)(n.strong,{children:"type"}),"（位置在同目录下的 ",(0,s.jsx)(n.code,{children:"ReactInternalTypes"}),"）。"]}),"\n",(0,s.jsxs)(n.p,{children:["将 ",(0,s.jsx)(n.strong,{children:"FiberNode"})," 内容简单化为四个部分，分别是 ",(0,s.jsx)(n.strong,{children:"Instance"}),"、",(0,s.jsx)(n.strong,{children:"Fiber"}),"、",(0,s.jsx)(n.strong,{children:"Effect"}),"、",(0,s.jsx)(n.strong,{children:"Priority"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Instance"}),"：这个部分是用来存储一些对应 ",(0,s.jsx)(n.code,{children:"element"})," 元素的属性。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type Fiber = {\n  tag: WorkTag,  // 组件的类型，判断函数式组件、类组件等（上述的tag）\n  key: null | string, // key\n  elementType: any, // 元素的类型\n  type: any, // 与fiber关联的功能或类，如<div>,指向对应的类或函数\n  stateNode: any, // 真实的DOM节点\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Fiber"}),"：这部分内容存储的是关于 ",(0,s.jsx)(n.code,{children:"Fiber"})," 链表相关的内容和相关的 ",(0,s.jsx)(n.code,{children:"props"}),"、",(0,s.jsx)(n.code,{children:"state"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export type Fiber = {\n  ...\n  return: Fiber | null, // 指向父节点的fiber\n  child: Fiber | null, // 指向第一个子节点的fiber\n  sibling: Fiber | null, // 指向下一个兄弟节点的fiber\n  index: number, // 索引，是父节点fiber下的子节点fiber中的下表\n  \n  ref:\n    | null\n    | (((handle: mixed) => void) & {_stringRef: ?string, ...})\n    | RefObject,  // ref的指向，可能为null、函数或对象\n    \n  pendingProps: any,  // 本次渲染所需的props\n  memoizedProps: any,  // 上次渲染所需的props\n  updateQueue: mixed,  // 类组件的更新队列（setState），用于状态更新、DOM更新\n  memoizedState: any, // 类组件保存上次渲染后的state，函数组件保存的hooks信息\n  dependencies: Dependencies | null,  // contexts、events（事件源） 等依赖\n\n  mode: TypeOfMode, // 类型为number，用于描述fiber的模式 \n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Effect"}),"：副作用相关的内容。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type Fiber = {\n  ...\n   flags: Flags, // 用于记录fiber的状态（删除、新增、替换等）\n   subtreeFlags: Flags, // 当前子节点的副作用状态\n   deletions: Array<Fiber> | null, // 删除的子节点的fiber\n   nextEffect: Fiber | null, // 指向下一个副作用的fiber\n   firstEffect: Fiber | null, // 指向第一个副作用的fiber\n   lastEffect: Fiber | null, // 指向最后一个副作用的fiber\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Priority"}),"：优先级相关的内容。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export type Fiber = {\n  ...\n  lanes: Lanes, // 优先级，用于调度\n  childLanes: Lanes,\n  alternate: Fiber | null,\n  actualDuration?: number,\n  actualStartTime?: number,\n  selfBaseDuration?: number,\n  treeBaseDuration?: number,\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"链表之间如何连接的",children:["链表之间如何连接的？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#链表之间如何连接的",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们知道了 Fiber 中保存的属性，那么我们要知道标签之间是如何连接的。",(0,s.jsx)(n.code,{children:"Fiber"})," 中通过 ",(0,s.jsx)(n.code,{children:"return"}),"、",(0,s.jsx)(n.code,{children:"child"}),"、",(0,s.jsx)(n.code,{children:"sibling"})," 这三个参数来进行连接，它们分别指向父级、子级、兄弟，也就是说每个 ",(0,s.jsx)(n.code,{children:"element"})," 通过这三个属性进行连接，同时通过 tag 的值来判断对应的 element 是什么。如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const Index = (props)=> {\n\n  return (\n    <div>\n      大家好，我是小杜杜，一起玩转Hooks吧！\n      <div>知悉Fiber</div>\n      <p>更好的了解Hooks</p>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"那么按照之前讲的就会转化为："}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Fiber"})," 结构的创建和更新都是",(0,s.jsx)(n.strong,{children:"深度优先遍历"}),"，遍历顺序为："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"首先会判断当前组件是类组件还是函数式组件，类组件 tag 为 1，函数式为 0；"}),"\n",(0,s.jsx)(n.li,{children:"然后发现 div 标签，标记 tag 为 5；"}),"\n",(0,s.jsxs)(n.li,{children:["发现 div 下包含三个部分，分别是，文本：",(0,s.jsx)(n.code,{children:"大家好，我是小杜杜，一起玩转hooks吧！"}),"、",(0,s.jsx)(n.code,{children:"div标签"}),"、",(0,s.jsx)(n.code,{children:"p标签"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["遍历文本：",(0,s.jsx)(n.code,{children:"大家好，我是小杜杜，一起玩转 hooks 吧！"}),"，下面无节点，标记 ",(0,s.jsx)(n.code,{children:"tag"})," 为 6；"]}),"\n",(0,s.jsxs)(n.li,{children:["在遍历 div 标签，标记 tag 为 5，此时下面有节点，所以对节点进行遍历，也就是文本 ",(0,s.jsx)(n.code,{children:"知悉 fiber"}),"，标记 ",(0,s.jsx)(n.code,{children:"tag"})," 为 6；"]}),"\n",(0,s.jsxs)(n.li,{children:["同理最后遍历",(0,s.jsx)(n.code,{children:"p标签"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["整个的流程就是这样，通过 ",(0,s.jsx)(n.code,{children:"tag"})," 标记属于哪种类型，然后通过 ",(0,s.jsx)(n.code,{children:"return"}),"、",(0,s.jsx)(n.code,{children:"child"}),"、",(0,s.jsx)(n.code,{children:"sibling"})," 这三个参数来判断节点的位置。"]}),"\n",(0,s.jsxs)(n.h1,{id:"react-v18-并发机制",children:["React v18 并发机制",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-v18-并发机制",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 React v18 中，最重要的一个概念就是",(0,s.jsx)(n.strong,{children:"并发（concurrency）"}),"。其中 ",(0,s.jsx)(n.code,{children:"useTransition"})," 、",(0,s.jsx)(n.code,{children:"useDeferredValue"})," 的内部原理都是基于并发的，可见并发的重要性。"]}),"\n",(0,s.jsxs)(n.h2,{id:"什么是并发",children:["什么是并发？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是并发",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"并发："})," 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但",(0,s.jsx)(n.strong,{children:"任一个时刻点上只有一个程序在处理机上运行"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["通俗来讲，",(0,s.jsx)(n.strong,{children:"并发是具备处理多个任务的能力，但不是同时执行，而是交替执行，每次依旧只能执行一个"}),"。比如：你此时在工作， 三体（电视剧）更新了一集，如果你："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"把工作干完，再去看三体，这种情况说明你既不支持并发也不支持并行；"}),"\n",(0,s.jsx)(n.li,{children:"把工作先扔到一边，先去看三体，再去工作，这种情况说明你支持并发，但并不支持并行；"}),"\n",(0,s.jsx)(n.li,{children:"边工作边看三体，两不耽误，这种情况说你支持并行。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"看完并发的概念后，再来看看 React 中的并发是什么，以及它的作用有什么。"}),"\n",(0,s.jsxs)(n.h2,{id:"react-中的并发",children:["React 中的并发",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-中的并发",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"首先，js 是单线程语言，也就是说 js 在同一时间只能干一件事情。但这样就会产生一个问题，如果当前的事情非常耗时，那么后续的事情就会被延后（阻塞）。"}),"\n",(0,s.jsx)(n.p,{children:"比如用户点击按钮后，先执行一个非常耗时的操作（大约 500ms），再进行其他操作，但在这 500ms 中，界面是属于卡死的状态，也就是说用户是无法进行其他操作，这种行为是非常影响用户体验的。而并发就是为了解决这类事件。"}),"\n",(0,s.jsx)(n.p,{children:"在并发的情况下，React 会先点击这个耗时任务，当其他操作发生时（如滚动），先执行滚动的任务，然后再执行耗时任务，这样既能保持耗时任务的进行，又能让用户进行交互。"}),"\n",(0,s.jsx)(n.p,{children:"虽然想法是好的，但实现起来就比较困难了。比如在更新中又触发了其他更新条件，怎么区分哪个是耗时任务？在更新的时候如何中断耗时任务？又该如何去恢复呢？..."}),"\n",(0,s.jsx)(n.p,{children:"来看看 React 官网是如何描述的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["官网描述",(0,s.jsx)(n.strong,{children:"并发属于新的一种幕后机制"}),"，它允许在同一时间内，准备多个版本的 UI，即多个版本的更新。"]}),"\n",(0,s.jsxs)(n.h2,{id:"时间分片",children:["时间分片",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#时间分片",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先，我们要知道一个前置知识点：",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback",target:"_blank",rel:"noopener noreferrer",children:"window.requestIdleCallback"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["它的作用是：",(0,s.jsx)(n.strong,{children:"插入一个函数，这个函数将在浏览器空闲时期被调用。"})," 这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 ",(0,s.jsx)(n.code,{children:"timeout"}),"，则有可能为了在超时前执行函数而打乱执行顺序。"]}),"\n",(0,s.jsx)(n.p,{children:"整个页面的内容是一帧一帧绘制出来的，通常来讲，1s 内绘制的帧数越多，就代表变现的画面更加细腻。大多数浏览器绘制一帧在 16.6ms 左右，执行步骤为："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"用户的操作：如 click、input 等；"}),"\n",(0,s.jsx)(n.li,{children:"执行 JS 代码，宏任务和微任务；"}),"\n",(0,s.jsx)(n.li,{children:"渲染前执行 resize/scroll 等操作，再执行 requestAnimationFrame 回调；"}),"\n",(0,s.jsx)(n.li,{children:"渲染页面，绘制 html、css 等；"}),"\n",(0,s.jsx)(n.li,{children:"执行 RIC（requestIdleCallback 回调函数），如果前面的步骤执行完成了，一帧还有剩余时间，就会执行该函数。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"而 React 是将任务进行拆解，然后放到 requestIdleCallback 中执行。比如一个 300ms 的更新，拆解为 6 个 50ms 的更新，然后放到 requestIdleCallback 中，如果一帧之内有剩余就会去执行，这样的话更新一直在继续，也可以达到交互的效果。"}),"\n",(0,s.jsxs)(n.p,{children:["但  requestIdleCallback  的兼容性非常差，React 团队并不打算使用，而是自己去实现一个类似 requestIdleCallback 的功能，也就是：",(0,s.jsx)(n.strong,{children:"时间分片"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"优先级",children:["优先级",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#优先级",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"优先级是 React 中非常重要的模块，分为两种方式："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"紧急更新（Urgent updates）："})," 用户的交互，如：点击、输入等，直接影响用户体验的行为都属于紧急情况；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"过渡更新（Transition updates）："})," 页面跳转等操作属于非紧急情况。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"优先级的模块非常大，这里不做过多的介绍。我们只需要知道，所有的操作都有对应优先级，React 会先执行紧急的更新，其次才会执行非紧急的更新。"}),"\n",(0,s.jsxs)(n.h2,{id:"并发模式的实现",children:["并发模式的实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#并发模式的实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"关于并发模式，整体可分为三步，分别是："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"每个更新，都会分配一个优先级（lane），用于区分紧急程度；"}),"\n",(0,s.jsx)(n.li,{children:"将不紧急的更新拆解成多段，并通过宏任务的方式将其合理分配到浏览器的帧当中，使得紧急任务可以插入进来；"}),"\n",(0,s.jsx)(n.li,{children:"优先级高的更新会打断优先级低的更新，等优先级高的更新执行完后，再执行优先级低的任务。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"concurrent-模式是否默认开启",children:["Concurrent 模式是否默认开启？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#concurrent-模式是否默认开启",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"并发机制是 React v18 中的新功能，那么很多小伙伴会产生这样的疑问，Concurrent 模式需要手动开启吗？还是说所有的代码都转化成 Concurrent 模式了呢？"}),"\n",(0,s.jsx)(n.p,{children:"实际上，在 React v18 中，Concurrent 并不需要手动开启，而是默认开启，换句话说，Concurrent 模式无法关闭，而是一直存在的。"}),"\n",(0,s.jsx)(n.p,{children:"但要注意，并不是所有的代码都执行 Concurent 模式，比如事件更新在 event、setTimeout、网络请求等，React 依旧采用 legacy （同步阻塞）模式，但如果事件更新与 Suspense、useTransition、useDeferredValue 相关，React 则会采用 Concurent 模式。"}),"\n",(0,s.jsxs)(n.p,{children:["总的来说，React 的 Concurrent 模式是否启用取决于",(0,s.jsx)(n.strong,{children:"触发更新的上下文"}),"，这点要特别注意。"]}),"\n",(0,s.jsxs)(n.h1,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章讲解了 Fiber 与并发机制的基础知识，并不涉及比较难的部分，所以阅读起来相对轻松一点。同时，相对于更高级的模块，应该先把架子搭起来，由浅入深，一点一点地慢慢啃。"}),"\n",(0,s.jsx)(n.p,{children:"下章我们将正式进入 React Hooks 的源码部分。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}let j=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F9.%E6%BA%90%E7%A0%81%E5%89%8D%E7%BD%AE%E7%AF%87%EF%BD%9C%E6%90%9E%E6%87%82%20Fiber%20%E5%92%8C%E5%B9%B6%E5%8F%91.md"]={toc:[{text:"虚拟 DOM 如何转化为 Fiber 的？",id:"虚拟-dom-如何转化为-fiber-的",depth:2},{text:"beginWork 方法",id:"beginwork-方法",depth:2},{text:"Fiber 中保存了什么？",id:"fiber-中保存了什么",depth:2},{text:"链表之间如何连接的？",id:"链表之间如何连接的",depth:2},{text:"什么是并发？",id:"什么是并发",depth:2},{text:"React 中的并发",id:"react-中的并发",depth:2},{text:"时间分片",id:"时间分片",depth:2},{text:"优先级",id:"优先级",depth:2},{text:"并发模式的实现",id:"并发模式的实现",depth:2},{text:"Concurrent 模式是否默认开启？",id:"concurrent-模式是否默认开启",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);