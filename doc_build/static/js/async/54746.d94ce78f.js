"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["54746"],{112131:function(e,n,r){e.exports=r.p+"static/image/b165c1da7b89bf93e102427529d6f16d.8b0a8763.webp"},423595:function(e,n,r){r.r(n),r.d(n,{default:()=>R});var s=r(552676),i=r(740453);let d=r.p+"static/image/6412ceeb52e69e9dfd231954ffd96f53.06e712df.webp",t=r.p+"static/image/6ef323451c886a63b6a12e335038b285.eb68d499.webp",c=r.p+"static/image/448c46ebe5eb5c200b383d2d715a9328.e8317e7d.webp",l=r.p+"static/image/118364450b2d0a85f48f8d5adaed12e4.b25ab0e3.webp",a=r.p+"static/image/e2bf2d2630cc4075ec893fe802c53b28.d9604c9d.webp";var p=r(112131);let A=r.p+"static/image/2fcdb874dddf6915cc74d55cccc6812d.c9fd6712.webp",h=r.p+"static/image/36b0f2f9576a2a1f4016042aa892b7e2.2fcaae20.webp",x=r.p+"static/image/a39163f564aeb05e1c87095f0bcfbbe0.e6407552.webp",o=r.p+"static/image/7ddc870166024565c2350027de096473.baef2eda.webp",g=r.p+"static/image/80ee84c59d33e84b2abd0417f9fb462f.7285b5f4.webp",j=r.p+"static/image/79bd9fb11d581847038675c41222dd58.f11bdf66.webp",y=r.p+"static/image/7c89d9928749f85bf946afe927f303c1.4549a2a5.webp",m=r.p+"static/image/20d7a3ed29c43bc8792a92d17c127d95.5a6fb98b.webp",B=r.p+"static/image/9013ef2c6891ae28e4f2e5caa027da71.cefd12c4.webp",u=r.p+"static/image/9fb7de4b5a02d310891270f657468b7d.f4fe16aa.webp",w=r.p+"static/image/f996f7c33fe2d71b3c607684a0b0a2fb.7b657d77.webp";function f(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",h3:"h3",pre:"pre",code:"code",img:"img"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"7套路三递归复用做循环",children:["7.套路三：递归复用做循环",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7套路三递归复用做循环",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"会做类型的提取和构造之后，我们已经能写出很多类型编程逻辑了，但是有时候提取或构造的数组元素个数不确定、字符串长度不确定、对象层数不确定。这时候怎么办呢？"}),"\n",(0,s.jsx)(n.p,{children:"其实前面的案例我们已经涉及到了一些，就是递归。"}),"\n",(0,s.jsx)(n.p,{children:"这就是第三个类型体操套路：递归复用做循环。"}),"\n",(0,s.jsxs)(n.h2,{id:"递归复用",children:["递归复用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#递归复用",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"递归是把问题分解为一系列相似的小问题，通过函数不断调用自身来解决这一个个小问题，直到满足结束条件，就完成了问题的求解。"})}),"\n",(0,s.jsx)(n.p,{children:"TypeScript 的高级类型支持类型参数，可以做各种类型运算逻辑，返回新的类型，和函数调用是对应的，自然也支持递归。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"TypeScript 类型系统不支持循环，但支持递归。当处理数量（个数、长度、层数）不固定的类型的时候，可以只处理一个类型，然后递归的调用自身处理下一个类型，直到结束条件也就是所有的类型都处理完了，就完成了不确定数量的类型编程，达到循环的效果。"})}),"\n",(0,s.jsx)(n.p,{children:"既然提到了数组、字符串、对象等类型，那么我们就来看一下这些类型的递归案例吧。"}),"\n",(0,s.jsxs)(n.h2,{id:"promise-的递归复用",children:["Promise 的递归复用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#promise-的递归复用",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"deeppromisevaluetype",children:["DeepPromiseValueType",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#deeppromisevaluetype",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"先用 Promise 热热身，实现一个提取不确定层数的 Promise 中的 value 类型的高级类型。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ttt = Promise<Promise<Promise<Record<string, any>>>>;\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里是 3 层 Promise，value 类型是索引类型。"}),"\n",(0,s.jsx)(n.p,{children:"数量不确定，一涉及到这个就要想到用递归来做，每次只处理一层的提取，然后剩下的到下次递归做，直到结束条件。"}),"\n",(0,s.jsx)(n.p,{children:"所以高级类型是这样的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepPromiseValueType<P extends Promise<unknown>> =\n    P extends Promise<infer ValueType> \n        ? ValueType extends Promise<unknown>\n            ? DeepPromiseValueType<ValueType>\n            : ValueType\n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 P 是待处理的 Promise，通过 extends 约束为 Promise 类型，value 类型不确定，设为 unknown。"}),"\n",(0,s.jsx)(n.p,{children:"每次只处理一个类型的提取，也就是通过模式匹配提取出 value 的类型到 infer 声明的局部变量 ValueType 中。"}),"\n",(0,s.jsx)(n.p,{children:"然后判断如果 ValueType 依然是 Promise类型，就递归处理。"}),"\n",(0,s.jsx)(n.p,{children:"结束条件就是 ValueType 不为 Promise 类型，那就处理完了所有的层数，返回这时的 ValueType。"}),"\n",(0,s.jsx)(n.p,{children:"这样，我们就提取到了最里层的 Promise 的 value 类型，也就是索引类型："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAIhFgAoCcD2BbAlgZwgNQEMAbAVwgBVwIAeRKCAD2AgDsATbKFDHGklgNYtUAdxYA+cVAC8AKCgKu9Jqw5c0WXNUwsAZhGRRCpClSnzFlgPxHiZSpGXN2nbpr6DhY8Rct+oNnAIbrzG9lTUYaaQPv7+AFy2Jg4Qvn6JLBAAbgYA3LKyoI5BSBq8AEoQ2CREwDKw8KU8uFEptGVaIVqVAMaoyGzU2MDIOgDmADRQBCwgkpK5QA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(n.p,{children:"其实这个类型的实现可以进一步的简化："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepPromiseValueType2<T> = \n    T extends Promise<infer ValueType> \n        ? DeepPromiseValueType2<ValueType>\n        : T;\n"})}),"\n",(0,s.jsx)(n.p,{children:"不再约束类型参数必须是 Promise，这样就可以少一层判断。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAIhFgAoCcD2BbAlgZwgNQEMAbAVwgBVwIAeRKCAD2AgDsATbKFDHGklgNYtUAdxYA+cVAC8AKCgKu9Jqw5c0WXNUwsAZhGRRCpClSnzFlgPxHiZSpGXN2nbpr6DhY8Rct+oNnAIbrzG9lTUYaaQPv7+AFy2Jg4Qvn6JLBAAbgYA3LKyoI5BSBq8AEoQ2CREwDKw8KU8uFEptGVaIVqVAMaoyGzU2MDIOgDmADRQBCwgkpL5hVQNwR34dtEQAEzU5FLSUGnkTqqua9p6BknhMYdxAStN7q1UOy8xaZaJ5ItF0CVddbJV6VTgHAFrd7bdrNGiAmHuagsEjoABGBnm4nyQA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(n.p,{children:"接下来再看下数组类型的递归复用："}),"\n",(0,s.jsxs)(n.h2,{id:"数组类型的递归",children:["数组类型的递归",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数组类型的递归",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"reversearr",children:["ReverseArr",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reversearr",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"有这样一个元组类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type arr = [1,2,3,4,5];\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们把它反过来，也就是变成："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type arr = [5,4,3,2,1];\n"})}),"\n",(0,s.jsx)(n.p,{children:"这个学完了提取和构造很容易写出来："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReverseArr<Arr extends unknown[]> = \n    Arr extends [infer One, infer Two, infer Three, infer Four, infer Five]\n        ? [Five, Four, Three, Two, One]\n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但如果数组长度不确定呢？"}),"\n",(0,s.jsx)(n.p,{children:"数量不确定，条件反射的就要想到递归。"}),"\n",(0,s.jsx)(n.p,{children:"我们每次只处理一个类型，剩下的递归做，直到满足结束条件。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReverseArr<Arr extends unknown[]> = \n    Arr extends [infer First, ...infer Rest] \n        ? [...ReverseArr<Rest>, First] \n        : Arr;\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Arr 为待处理的数组类型，元素类型不确定，也就是 unknown。"}),"\n",(0,s.jsx)(n.p,{children:"每次只处理一个元素的提取，放到 infer 声明的局部变量 First 里，剩下的放到 Rest 里。"}),"\n",(0,s.jsx)(n.p,{children:"用 First 作为最后一个元素构造新数组，其余元素递归的取。"}),"\n",(0,s.jsx)(n.p,{children:"结束条件就是取完所有的元素，也就是不再满足模式匹配的条件，这时候就返回 Arr。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAShBuEBOBnCBBJSA8mlQgA9gIA7AExSgFdSBrUgewHdSBtAXQD4oBeKAFBRhUPAWJlKUNgEtSAM2RQAYjNTAANFAB0uuYvxwUwDoJHmoAfmm7tcRKgxZsR4Fy2r1poReEAuUSwAbgEBUEhYBGQ0PCNqABtgPkiHGOc2AEYNACYNAGYNABYNAFZuIKA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsxs)(n.h3,{id:"includes",children:["Includes",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#includes",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"既然递归可以做循环用，那么像查找元素这种自然也就可以实现。"}),"\n",(0,s.jsx)(n.p,{children:"比如查找 [1, 2, 3, 4, 5] 中是否存在 4，是就返回 true，否则返回 false。"}),"\n",(0,s.jsx)(n.p,{children:"从长度不固定的数组中查找某个元素，数量不确定，这时候就应该想到递归。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type Includes<Arr extends unknown[], FindItem> = \n    Arr extends [infer First, ...infer Rest]\n        ? IsEqual<First, FindItem> extends true\n            ? true\n            : Includes<Rest, FindItem>\n        : false;\n\ntype IsEqual<A, B> = (A extends B ? true : false) & (B extends A ? true : false);\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Arr 是待查找的数组类型，元素类型任意，也就是 unknown。FindItem 待查找的元素类型。"}),"\n",(0,s.jsx)(n.p,{children:"每次提取一个元素到 infer 声明的局部变量 First 中，剩余的放到局部变量 Rest。"}),"\n",(0,s.jsx)(n.p,{children:"判断 First 是否是要查找的元素，也就是和 FindItem 相等，是的话就返回 true，否则继续递归判断下一个元素。"}),"\n",(0,s.jsx)(n.p,{children:"直到结束条件也就是提取不出下一个元素，这时返回 false。"}),"\n",(0,s.jsx)(n.p,{children:"相等的判断就是 A 是 B 的子类型并且 B 也是 A 的子类型，。"}),"\n",(0,s.jsx)(n.p,{children:"这样就完成了不确定长度的数组中的元素查找，用递归实现了循环。"}),"\n",(0,s.jsx)(n.p,{children:"当包含时："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"当不包含时："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/FAFwngDgpgBAkgOwMYBsCuATKBnAPAQQCdCYoAPEKBDbGNBAawQHsB3BAbQF0AaGAMQCW1OJQC2APhgBeGMBgKYREuUrVaHYQDMoJIYWwg+AOlPbdMAEo4QXeYocB+eNgCiARzQBDFLn2G+IRFxKVUqGhgQQjQoewd4mGcomLiExQAueGR0LDxrAIFhDFEoSVSHTK0fbCgAbmBQSFg4N08fAj4AISlZAAp8Ugpw2k7EyOjYSuqoAEoYADIYXtGw9SUx5MmYKpQamfrG6CzUTBx8tBQQGWOcnFwOAEY+ACY+AGY+ABY+AFZeGE+EgO4COiBOuXOl2e1zBtzwjxe7y+v3+ADYgUA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsxs)(n.h3,{id:"removeitem",children:["RemoveItem",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#removeitem",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"可以查找自然就可以删除，只需要改下返回结果，构造一个新的数组返回。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type RemoveItem<\n    Arr extends unknown[], \n    Item, \n    Result extends unknown[] = []\n> = Arr extends [infer First, ...infer Rest]\n        ? IsEqual<First, Item> extends true\n            ? RemoveItem<Rest, Item, Result>\n            : RemoveItem<Rest, Item, [...Result, First]>\n        : Result;\n        \ntype IsEqual<A, B> = (A extends B ? true : false) & (B extends A ? true : false);\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Arr 是待处理的数组，元素类型任意，也就是 unknown[]。类型参数 Item 为待查找的元素类型。类型参数 Result 是构造出的新数组，默认值是 []。"}),"\n",(0,s.jsx)(n.p,{children:"通过模式匹配提取数组中的一个元素的类型，如果是 Item 类型的话就删除，也就是不放入构造的新数组，直接返回之前的 Result。"}),"\n",(0,s.jsx)(n.p,{children:"否则放入构造的新数组，也就是再构造一个新的数组 [...Result, First]。"}),"\n",(0,s.jsx)(n.p,{children:"直到模式匹配不再满足，也就是处理完了所有的元素，返回这时候的 Result。"}),"\n",(0,s.jsx)(n.p,{children:"这样我们就完成了不确定元素个数的数组的某个元素的删除："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAShC2B7AbhAksBAeAggJzyggA9MA7AEwGcoBXMgazMQHcyBtAXQBooMFecKrQA2wIqQiUa9Jqw6coAXihcAfMqgAoKLqj5CJctVUBLMgDMIhAGKm8VYLwB0r81cJDgnHXr8B+PioAUQBHWgBDESw7Byc+THgNIykTYDxaCF8-HKhAuCRUfngsL15iwQhhMTVs3L0ALlgEFHRE0qr4itVXZyFReNjHTlr6qCb+sQBuLS1QSCCwyOicXgAhDRUAChwJYxo1vKh0zPGoCyiqCABKKAAyKC3DlOl9I5PoJouRK+uZufA0AKrWKk3EKmBRXa7AAjNwAEwI7gAZh4UHhaimQA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsxs)(n.h3,{id:"buildarray",children:["BuildArray",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#buildarray",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们学过数组类型的构造，如果构造的数组类型元素个数不确定，也需要递归。"}),"\n",(0,s.jsx)(n.p,{children:"比如传入 5 和元素类型，构造一个长度为 5 的该元素类型构成的数组。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type BuildArray<\n    Length extends number, \n    Ele = unknown, \n    Arr extends unknown[] = []\n> = Arr['length'] extends Length \n        ? Arr \n        : BuildArray<Length, Ele, [...Arr, Ele]>;\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Length 为数组长度，约束为 number。类型参数 Ele 为元素类型，默认值为 unknown。类型参数 Arr 为构造出的数组，默认值是 []。"}),"\n",(0,s.jsx)(n.p,{children:"每次判断下 Arr 的长度是否到了 Length，是的话就返回 Arr，否则在 Arr 上加一个元素，然后递归构造。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/FAFwngDgpgBAQgVwJYBsAmBBATlghmAHgBkoA7AcxAAsYoAPEMtAZxlIQFsAjKLAGhjAYwmAFEUsALwwEpANakA9gHdSAoSOxZaDJq1kKVpANoBdGNLMA+CxuFbjAcgkVqj8-UakWMEq5p2IsIA-DBagkFBAFzwyOha+MRklFQC4lACxgB0OVppEqZWANzAoJCwiKiYOABKUMwIKCAWsVUJhACsxUA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(n.p,{children:"学完了数组类型的递归，我们再来看下字符串类型。"}),"\n",(0,s.jsxs)(n.h2,{id:"字符串类型的递归",children:["字符串类型的递归",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#字符串类型的递归",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"replaceall",children:["ReplaceAll",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#replaceall",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"学模式匹配的时候，我们实现过一个 Replace 的高级类型："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReplaceStr<\n    Str extends string,\n    From extends string,\n    To extends string\n> = Str extends `${infer Prefix}${From}${infer Suffix}` \n    ? `${Prefix}${To}${Suffix}` : Str;\n"})}),"\n",(0,s.jsx)(n.p,{children:"它能把一个字符串中的某个字符替换成另一个："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但是如果有多个这样的字符就处理不了了。"}),"\n",(0,s.jsx)(n.p,{children:"如果不确定有多少个 From 字符，怎么处理呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"在类型体操里，遇到数量不确定的问题，就要条件反射的想到递归。"})}),"\n",(0,s.jsx)(n.p,{children:"每次递归只处理一个类型，这部分我们已经实现了，那么加上递归的调用就可以。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReplaceAll<\n    Str extends string, \n    From extends string, \n    To extends string\n> = Str extends `${infer Left}${From}${infer Right}`\n        ? `${Left}${To}${ReplaceAll<Right, From, To>}`\n        : Str;\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Str 是待处理的字符串类型，From 是待替换的字符，To 是替换到的字符。"}),"\n",(0,s.jsx)(n.p,{children:"通过模式匹配提取 From 左右的字符串到 infer 声明的局部变量 Left 和 Right 里。"}),"\n",(0,s.jsx)(n.p,{children:"用 Left 和 To 构造新的字符串，剩余的 Right 部分继续递归的替换。"}),"\n",(0,s.jsx)(n.p,{children:"结束条件是不再满足模式匹配，也就是没有要替换的元素，这时就直接返回字符串 Str。"}),"\n",(0,s.jsx)(n.p,{children:"这样就实现了任意数量的字符串替换："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/FDAuE8AcFMAICVqQDYEMDG0CCzkB4BlUAJ1mgA9RoA7AEwGdZ6SBLagcwBpZhY-YAYsQD2AWzKUaDJqw7de-ACrCJVOo2bE27AHywAvD37HYRUhTXSABgBIA3mwBm0UgBloj0AF97QsT4dqZ1J4FnYAC28rBRMTAH5YWzt3TwDlAMQUDGxcPFCI0G4-UW5lHS9o2NiALlMSAG4QCBgEJDRMHGREegBXZFADVqyO3IBydh7UDlgJqfYZyY5R7nHF9mXYUdphJZ16oA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsxs)(n.h3,{id:"stringtounion",children:["StringToUnion",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#stringtounion",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们想把字符串字面量类型的每个字符都提取出来组成联合类型，也就是把 'dong' 转为 'd' | 'o' | 'n' | 'g'。"}),"\n",(0,s.jsx)(n.p,{children:"怎么做呢？"}),"\n",(0,s.jsx)(n.p,{children:"很明显也是提取和构造："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type StringToUnion<Str extends string> = \n    Str extends `${infer One}${infer Two}${infer Three}${infer Four}`\n        ? One | Two | Three | Four\n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但如果字符串长度不确定呢？"}),"\n",(0,s.jsx)(n.p,{children:"数量不确定，在类型体操中就要条件反射的想到递归。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type StringToUnion<Str extends string> = \n    Str extends `${infer First}${infer Rest}`\n        ? First | StringToUnion<Rest>\n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Str 为待处理的字符串类型，通过 extends 约束为 string。"}),"\n",(0,s.jsx)(n.p,{children:"通过模式匹配提取第一个字符到 infer 声明的局部变量 First，其余的字符放到局部变量 Rest。"}),"\n",(0,s.jsx)(n.p,{children:"用 First 构造联合类型，剩余的元素递归的取。"}),"\n",(0,s.jsx)(n.p,{children:"这样就完成了不确定长度的字符串的提取和联合类型的构造："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAysBOBLAdgcwCoHsCqzGeQB454oIAPYCZAEwGco6EVUA+KAXigCgo-YEZStXpQABgBIA3igBmEUgDFE8JgF9pchVABKEdWN79jAfijLVwKAB8BSNFlz4iepqyPG+ALijIIANwUAbm5Q0Eg7Fkc8AlcAVwAbKy4SKJwYogByAAsIBITMTNYQoA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsxs)(n.h3,{id:"reversestr",children:["ReverseStr",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reversestr",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们实现了数组的反转，自然也可以实现字符串类型的反转。"}),"\n",(0,s.jsx)(n.p,{children:"同样是递归提取和构造。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ReverseStr<\n    Str extends string, \n    Result extends string = ''\n> = Str extends `${infer First}${infer Rest}` \n    ? ReverseStr<Rest, `${First}${Result}`> \n    : Result;\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Str 为待处理的字符串。类型参数 Result 为构造出的字符，默认值是空串。"}),"\n",(0,s.jsx)(n.p,{children:"通过模式匹配提取第一个字符到 infer 声明的局部变量 First，其余字符放到 Rest。"}),"\n",(0,s.jsx)(n.p,{children:"用 First 和之前的 Result 构造成新的字符串，把 First 放到前面，因为递归是从左到右处理，那么不断往前插就是把右边的放到了左边，完成了反转的效果。"}),"\n",(0,s.jsx)(n.p,{children:"直到模式匹配不满足，就处理完了所有的字符。"}),"\n",(0,s.jsx)(n.p,{children:"这样就完成了字符串的反转："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/FAFwngDgpgBASlAblATgZygZRCgPNlGKADxCgDsATNGNHAS3IHMAaGYGT+KNAVwBsQRUhWq0GzGAF4YAclkA+aey4wCwslRoADACQBvRgDNUMAGL10IAL4HjphHWvaVqrgH5uydFhy5HIGx6+hZWtvqOAjbaShxunABc3HyCANzAoJCwCN4YBJGCyjmoeX6yABZQ-PwA9oqpQA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(n.p,{children:"学完了字符串的递归，我们再来看下对象的。"}),"\n",(0,s.jsxs)(n.h2,{id:"对象类型的递归",children:["对象类型的递归",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象类型的递归",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"deepreadonly",children:["DeepReadonly",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#deepreadonly",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"对象类型的递归，也可以叫做索引类型的递归。"}),"\n",(0,s.jsx)(n.p,{children:"我们之前实现了索引类型的映射，给索引加上了 readonly 的修饰："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type ToReadonly<T> =  {\n    readonly [Key in keyof T]: T[Key];\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果这个索引类型层数不确定呢？"}),"\n",(0,s.jsx)(n.p,{children:"比如这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type obj = {\n    a: {\n        b: {\n            c: {\n                f: () => 'dong',\n                d: {\n                    e: {\n                        guang: string\n                    }\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"数量（层数）不确定，类型体操中应该自然的想到递归。"}),"\n",(0,s.jsx)(n.p,{children:"我们在之前的映射上加入递归的逻辑："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepReadonly<Obj extends Record<string, any>> = {\n    readonly [Key in keyof Obj]:\n        Obj[Key] extends object\n            ? Obj[Key] extends Function\n                ? Obj[Key] \n                : DeepReadonly<Obj[Key]>\n            : Obj[Key]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"类型参数 Obj 是待处理的索引类型，约束为 Record<string, any>，也就是索引为 string，值为任意类型的索引类型。"}),"\n",(0,s.jsx)(n.p,{children:"索引映射自之前的索引，也就是 Key in keyof Obj，只不过加上了 readonly 的修饰。"}),"\n",(0,s.jsx)(n.p,{children:"值要做下判断，如果是 object 类型并且还是 Function，那么就直接取之前的值 Obj[Key]。"}),"\n",(0,s.jsx)(n.p,{children:"如果是 object 类型但不是 Function，那就是说也是一个索引类型，就递归处理 DeepReadonly<Obj[Key]>。"}),"\n",(0,s.jsx)(n.p,{children:"否则，值不是 object 就直接返回之前的值 Obj[Key]。"}),"\n",(0,s.jsx)(n.p,{children:"这样就完成了任意层数的索引类型的添加 readonly 修饰："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们取处理以后的索引 a 的值看一下，发现 b 已经加上了 readonly 修饰。"}),"\n",(0,s.jsx)(n.p,{children:"测试一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAIhFgEoQIYBMD2A7ANiAPAPIBGAVlBAB7ARZoDOUyAxhgE5r73BsCWWAcwA0UFFhAA+CVAC8UAN4AoKCqhtUmXCCgBtANIRt-KAGtDGAGZQSpALoAuZauc39h2xWq0GUDGQjMwE7OIVAA-NZkbiAeVDR0jABiAK5YgbzYwaHZEa4GMVBZ2SH2sPBIGth4RFH5thJF2aV57ooAvoqKoJC+ZLIKWSilSsXEw42hzOPFxRalABQAlLLSAOSaAqtCEzNo0zMHEPsHJ1ACyWICpdx8gjunHafOjycvoW9QHR1d4NBwCMh0FUQMh6MkcMB+v8KkCtPg-KQJDpVihVrYANydbp-cqAzR4UHg4AAJihuMqcIRSJRaORxFpq2YaMxQA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsx)(n.p,{children:"为啥这里没有计算呀？"}),"\n",(0,s.jsx)(n.p,{children:"因为 ts 的类型只有被用到的时候才会做计算。"}),"\n",(0,s.jsx)(n.p,{children:"所以可以在前面加上一段 Obj extends never ? never 或者 Obj extends any 等，从而触发计算："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type DeepReadonly<Obj extends Record<string, any>> =\n    Obj extends any\n        ? {\n            readonly [Key in keyof Obj]:\n                Obj[Key] extends object\n                    ? Obj[Key] extends Function\n                        ? Obj[Key] \n                        : DeepReadonly<Obj[Key]>\n                    : Obj[Key]\n        }\n        : never;\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样就显示了计算后的类型："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而且写 Obj extends any 还有额外的好处就是能处理联合类型，这个可以看套路五，会有解释。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAIhFgEoQIYBMD2A7ANiAPAPIBGAVlBAB7ARZoDOUyAxhgE5r73BsCWWAcwA0UFFhAA+CVAC8AKCiKoJclRp1GYkAqW6A-FADeO3aahtUmXCCgBtANIQb-KAGsnGAGbKyAXQBcJmbBKg5OvhTUtAxQGGQQzMBBwSlQBqGOIBFq0YwAYgCuWIm82MmpFelkYVlQ5RUp-rDwSJbYeETVmb4S9Q2KTRnhfQC+fU1YEABuEGwA3HJyoJCxZLJGQShNxinE2326zPv9up5NABQAlLLSAORWArdCB8FoxydmEO8fKQIFYgImtw+IIXhUxj8oBCGtCzLCoXIxktwNA4AhkOh2iBkPQCjhgOs0a1MdZ8HFSBI5kA",target:"_blank",rel:"noopener noreferrer",children:"试一下"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"递归是把问题分解成一个个子问题，通过解决一个个子问题来解决整个问题。形式是不断的调用函数自身，直到满足结束条件。"}),"\n",(0,s.jsxs)(n.p,{children:["在 TypeScript 类型系统中的高级类型也同样支持递归，",(0,s.jsx)(n.strong,{children:"在类型体操中，遇到数量不确定的问题，要条件反射的想到递归。"})," 比如数组长度不确定、字符串长度不确定、索引类型层数不确定等。"]}),"\n",(0,s.jsx)(n.p,{children:"如果说学完了提取和构造可以做一些基础的类型体操，那再加上递归就可以实现各种复杂类型体操了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/PTAEAUCcHsFsEsDOBTAXAKHSUARZyAHKOJZANQEMAbAV2QBUBPAtdAF2eV3yJgRUq0GnADzhQyAB5tkAOwAmiCH1IiasgNazoAd1kA+faAC86UOYgTpcxcpIoR8WQDNkkUILpMWRsxf8A-B7UXpxWMgpKxPzIapraevp+-imgQXiE0aSewiwiOd7ISampqMFChckpZbLIAG5uANyYHCzcmSooAErIiDRUbCbtvPbkIbmxWQ5TsT0AxtCQ8iKIbJBOAOYANKAUsoyGhs1YYBkjMQWcAEzsYWczlyxXIvRGxqBV9OE2UZ2xTq53I8ih8Smlhg9xoVnsDiiUyvRjq0uPc-sCrj0lO9UaN0WI-vjRoSYiJZDRYAAjNyHfTHbCAB1NACN+gCx-zDYHoNSAoACCkEgGGRoA5bh5fJEvPcUgitnUWl0sgA2gBdN6giwS76RUAKgFuUAAMXgXLYOwAdObde5MWwlWrUkEFebTcKucgJSJrfodobjbaqv4yhKkWEXaLIJj+oN3qG3WKFQBGLZXLYAZi2ABYtgBWFV0sAASVkc1o8l6tzaheLNFLiHFfM1Mvi8uV3qc8nzMlgqqqGqlP21loNRtWZotLj11qV-osQXziAAogBHGjUEQ+kdDhQd5BdhtKNZ0af20AH5BH6qgSsl3oe3omzftztw0qgZzUFDBisL5er7k7ABCqoABTcnuoD-uCp6gGUb5UCgACUoAAGSgEBEF9lqoFBFBMHvsg8GflwV7Vr0EYDEMxE1iICY7MmoBpqAmagDmOzprSLRhJRpG9JGVwUUW161jRoB0QxTEsaAABs7EnEKO7QA026wOWXA9LACnIEpdaStYWqygkipKjsSk7GRgwYY2cp6MqQzKt2-i9rptg6uO7jrveTqDpO56zt+K5UGuw73kpRgWfukCHmCgRyepimdreG4mXJfQDM+UVlGpGladaxmdjsjrmmZra+mlAbJZGhExVlnZmUMmVxTu1GJsmyYpkZIkydg-40PAVDyBKFCMCp4E9X1A2MCIAAycgbGwAAWYFkpSbg7FU85UFw7z6fKq0OfWYWgNt1m2u8dkmD2fIKgA5BtsizXNV22gd013fNdopEEGrnmU3W9f1fKDVNM3zTs63IPlToSqDG25hxbS-WNfK1e8CP-ZAgNZp1YCAOragBk3oATHKAN4+gDR6myYA9AQVAUHMbpUFQw0U1TNPcnTIgAMprGBqzrHdu0WPqfBc2smx8+Y9DQELPMbPZJQczp0pKAABgAJAA3oO03OGwAC+asC3Auvq65QrwBsc064r57RSrquazravi4bjPU7TAVdKb5venwOzi-o2uW1FFhlHLlXO8zdPI3JlMuyzAVXRsK53aACd7BsyeJxsV07PHGdZ6AV3yNAd1XVjoBy5s4sAKqyPARfDeXd1VzXRfs5zB3c5sMvmHLYE24O7mG15d7+z5Q7GqAAA+ZfC430DV7XsgJWwpVB6AtScsc9czxsTcL5HDc73PzeL1dc3IHT0Al3mcmcigcsM-UIrIHLrfy-2He8+9tXt9vQxXSXQwqg9wOn3Y2A81ZD1WP7d60UYwvxyqAG24DVZmX9r4MEGUeIDFDo-V0ctI5wLWCIU+58qCX1LoAIl9ACo+iTVkskzg9AoIXWQVAhrDQYcgJhRdWEiAAPIUgAFZgXmIsZYH9ti7H2IYc6-h+FCIOnsIaYIgiqythYSAnDmGsO1AAaWQIwUAThQAaH0dAZwoA5FKgwIHVIciFR6MYE9JyShoCCOQHMNgajA5BDsQ4pxCsDTqA8QvLxNjzA+MEfY-RfowlhLKBwrhLCJq+OiSvWJ0ELGRL8eebW30164Mqq4oR7xVH+AoGUUpJQKQVNCXMGp6TzDODKEBRCxgjAFyLpnLYoT-DyHqQ0-waBQCVIGakFOd0yjiJ6SUXJAzZk2PmakRZoBcm5PYTwRhWjGCRwSVskQRT2JAA",target:"_blank",rel:"noopener noreferrer",children:"本文案例的合并"})}),"\n",(0,s.jsx)(n.p,{children:"(其实这节的 IsEqual 判断是不完善的，套路六里面会讲原因)"})]})}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}let R=b;b.__RSPRESS_PAGE_META={},b.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F7.%E5%A5%97%E8%B7%AF%E4%B8%89%EF%BC%9A%E9%80%92%E5%BD%92%E5%A4%8D%E7%94%A8%E5%81%9A%E5%BE%AA%E7%8E%AF.md"]={toc:[{text:"递归复用",id:"递归复用",depth:2},{text:"Promise 的递归复用",id:"promise-的递归复用",depth:2},{text:"DeepPromiseValueType",id:"deeppromisevaluetype",depth:3},{text:"数组类型的递归",id:"数组类型的递归",depth:2},{text:"ReverseArr",id:"reversearr",depth:3},{text:"Includes",id:"includes",depth:3},{text:"RemoveItem",id:"removeitem",depth:3},{text:"BuildArray",id:"buildarray",depth:3},{text:"字符串类型的递归",id:"字符串类型的递归",depth:2},{text:"ReplaceAll",id:"replaceall",depth:3},{text:"StringToUnion",id:"stringtounion",depth:3},{text:"ReverseStr",id:"reversestr",depth:3},{text:"对象类型的递归",id:"对象类型的递归",depth:2},{text:"DeepReadonly",id:"deepreadonly",depth:3},{text:"总结",id:"总结",depth:2}],title:"7.套路三：递归复用做循环",headingTitle:"7.套路三：递归复用做循环",frontmatter:{}}}}]);