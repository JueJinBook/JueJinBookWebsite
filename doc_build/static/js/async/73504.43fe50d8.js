"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["73504"],{353283:function(e,n,s){s.r(n),s.d(n,{default:()=>x});var i=s(552676),o=s(740453);let t=s.p+"static/image/e2ab5d6ee4657fb765958ba35e82f634.0d92467b.webp",a=s.p+"static/image/ee7b215c26cfa215ff4aa4dc0a319658.2484ab27.webp",r=s.p+"static/image/a74d265dbb7fa325434d9d30d9923b12.3062ae05.webp",c=s.p+"static/image/159fb88e1f3d7e45c896862008f2df32.d47d70eb.webp",d=s.p+"static/image/670ff74fae0f11b64fb52865523d8ec2.584a8cb7.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",h3:"h3",code:"code",img:"img",pre:"pre",ul:"ul",li:"li",ol:"ol"},(0,o.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"21--理解-http使用-cookie-实现会话管理",children:["21  理解 HTTP：使用 Cookie 实现会话管理",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21--理解-http使用-cookie-实现会话管理",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"上一节课中，我们了解了 Cookie 的基本工作原理，即通过在 Cookie 中设置唯一 ID 就能够让服务器识别用户的身份。给不同的用户赋予不同的 ID 之后，我们的服务器就可以根据 Cookie 识别某个请求属于哪个用户了。"}),"\n",(0,i.jsxs)(n.p,{children:["正因为具有这种特性，服务器才能够使用 Cookie 来记录状态。具体的做法是像上一节最后的例子那样，随机生成一个唯一 ID，将它作为 Cookie 发送给客户端（浏览器），然后把这个 ID，以及和这个 Cookie 相关的信息存储在持久化服务里。当用户下一次访问网站的时候，服务器就能根据客户端发送来的 Cookie 查询持久化服务，找到和这个用户相关的信息进行响应的业务处理。这个过程是一种规范的机制，在服务器端有一个专门的名字叫做 ",(0,i.jsx)(n.strong,{children:"Session"}),"，中文是会话。"]}),"\n",(0,i.jsx)(n.p,{children:"Session 机制对于复杂的互联网应用十分重要。试想一下，假设我们开发了一个电商网站，某个用户登录了我们的网站开始购物。那在他登录网站的时候，我们要用 Session 记录下他的登录状态和用户信息，这些信息在他后续挑选商品，添加购物车，发起购物请求，支付商品等一系列操作中都会被使用。如果没有 Session 机制，那为了识别这些操作都是同一个人进行的，我们就不得不在每个 HTTP 请求中始终带着他的登录状态和个人信息，这会造成不必要的复杂度和带宽浪费，也会降低安全性（敏感信息传输越多，安全性越差）。"}),"\n",(0,i.jsx)(n.p,{children:"那么 Session 究竟要如何创建呢？"}),"\n",(0,i.jsxs)(n.h2,{id:"实现-session-机制",children:["实现 Session 机制",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-session-机制",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"通常情况下，Session 的创建是发生在用户首次登录或者 Session 过期后，服务器再次要求用户登录的时候。所以，在创建 Session 之前，我们要先实现用户的登录功能。我们以 Todolist 项目为例，为它添加一个用户登录功能，让它能够支持多用户使用。"}),"\n",(0,i.jsxs)(n.h3,{id:"实现用户登录",children:["实现用户登录",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现用户登录",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["我们先在 SQLite 中创建一个 user 表，它有三个字段：",(0,i.jsx)(n.code,{children:"id"}),"、",(0,i.jsx)(n.code,{children:"name"})," 和 ",(0,i.jsx)(n.code,{children:"password"}),"。简单起见，我们不实现用户注册功能，预先在表里输入一个用户信息。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"这个用户名叫 junyux，密码是 123456。"}),"\n",(0,i.jsx)(n.p,{children:"顺便说一下，一般我们不在数据库中存储明文密码，而是存储加密过的字符串，这样可以避免用户密码泄露。在 Node.js 中，我们可以使用内置模块 crypto 将用户的密码变成加密的字符串。"}),"\n",(0,i.jsx)(n.p,{children:"像这样："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const salt = 'xypte';\nconst password = crypto.createHash('sha256').update(`${salt}123456`, 'utf8').digest().toString('hex'); // e50fa2354f33c71825411052935bd8409d91ef4f31b5ea468644baa3a2ee31c5\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这里的 salt 是一个随机字符串，这么做可以避免密码碰撞攻击，增加安全性。比如用户的密码是 123456，但是数据库中保存的是字符串",(0,i.jsx)(n.code,{children:"xypte123456"}),"经过",(0,i.jsx)(n.code,{children:"sha256"}),"加密后的结果。"]}),"\n",(0,i.jsx)(n.p,{children:"然后，我们实现一个 user 的 model："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// model/user.js\nconst crypto = require('crypto');\n\nasync function login(database, {name, passwd}) {\n  const userInfo = await database.get('SELECT * FROM user WHERE name = ?', name);\n  const salt = 'xypte';\n  const hash = crypto.createHash('sha256').update(`${salt}${passwd}`, 'utf8').digest().toString('hex'); // 将用户输入的密码用同样的方式加密\n  if(userInfo && hash === userInfo.password) {\n    // TODO: 创建Session\n    return {id: userInfo.id, name: userInfo.name};\n  }\n  return null;\n}\n\nmodule.exports = {\n  login,\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"如上面代码所示，在这个 model 中，我们从 user 表中读取用户信息，然后将 passwd 经过加密后与数据库表保存的字符串进行比对。如果相同，说明密码是正确的，那么返回用户信息（ID 和用户名）。如果字符串不相同（表示密码错误）或者  userInfo 表里没有查出记录（表示用户不存在），那么返回 null。"}),"\n",(0,i.jsx)(n.p,{children:"注意这里的 TODO 部分，用户登录后，服务器需要保存这次用户登录的 Session，这样用户下一次访问网站的时候就不需要再次登录了。"}),"\n",(0,i.jsxs)(n.h3,{id:"创建-session",children:["创建 Session",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#创建-session",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["接下来我们要实现 Session 创建的功能，将登录的状态保存下来。这样用户访问",(0,i.jsx)(n.code,{children:"/list"}),"的时候，可以根据用户信息查询对应的任务，访问",(0,i.jsx)(n.code,{children:"/add"}),"和",(0,i.jsx)(n.code,{children:"/update"}),"的时候也可以根据用户信息来进行对应的操作。"]}),"\n",(0,i.jsx)(n.p,{children:"我们在 SQLite 中创建一个 Session 表，用来存放 Session 信息："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"Session 表有六个字段："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ID 是数据表自动生成的编号；"}),"\n",(0,i.jsx)(n.li,{children:"key 是对应 Cookie 的属性值，也就是服务器随机生成的唯一 ID；"}),"\n",(0,i.jsx)(n.li,{children:"name 是要记录的 Session 的名字（比如：userInfo)；"}),"\n",(0,i.jsx)(n.li,{children:"value 是以 JSON 格式存放的值；"}),"\n",(0,i.jsx)(n.li,{children:"created 是 Session 的创建时间；"}),"\n",(0,i.jsx)(n.li,{children:"expires 是 Session 的过期时间。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"然后添加一个 Session 的model，用来新增和获得用户的 Session："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// model/session.js\nconst sessionKey = 'interceptor_js';\n\n// 根据Cookie中的ID获取用户的Session\nasync function getSession(database, ctx, name) {\n  const key = ctx.cookies[sessionKey];\n  if(key) {\n    const now = Date.now();\n    const session = await database.get('SELECT * FROM session WHERE key = ? and name = ? and expires > ?',\n      key, name, now);\n    if(session) {\n      return JSON.parse(session.value);\n    }\n  }\n  return null;\n}\n\n// 创建新的Session\nasync function setSession(database, ctx, name, data) {\n  try {\n    const key = ctx.cookies[sessionKey];\n    if(key) {\n      let result = await database.get('SELECT id FROM session WHERE key = ? AND name = ?', key, name);\n      if(!result) {\n        // 如果result不存在，那么插入这个session\n        result = await database.run(`INSERT INTO session(key, name, value, created, expires)\n          VALUES (?, ?, ?, ?, ?)`,\n        key,\n        name,\n        JSON.stringify(data),\n        Date.now(),\n        Date.now() + 7 * 86400 * 1000);\n      } else {\n        // 否则更新这个session\n        result = await database.run('UPDATE session SET value = ?, created = ?, expires = ? WHERE key = ? AND name = ?',\n          JSON.stringify(data),\n          Date.now(),\n          Date.now() + 7 * 86400 * 1000,\n          key,\n          name);\n      }\n      return {err: '', result};\n    }\n    throw new Error('invalid cookie');\n  } catch (ex) {\n    return {err: ex.message};\n  }\n}\n\nmodule.exports = {\n  getSession,\n  setSession,\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["如上代码所示，函数 ",(0,i.jsx)(n.code,{children:"setSession"})," 用于向 Session 表中插入或更新一条会话记录。这条记录中的 key 就是用户 Cookie 中的唯一 ID。在方法",(0,i.jsx)(n.code,{children:"getSession"}),"中，我们通过 key 获得这个用户的 Session 记录，如果存在这条记录，就返回 Session 的 value（即 userInfo)，否则返回 null。然后，我们在用户 model 的登录方法中加入创建 Session 的功能："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// model/user.js\nconst crypto = require('crypto');\n\nconst {setSession} = require('./session');\n\nconst sessionName = 'userInfo';\n\nasync function login(database, ctx, {name, passwd}) {\n  const userInfo = await database.get('SELECT * FROM user WHERE name = ?', name);\n  const salt = 'xypte';\n  const hash = crypto.createHash('sha256').update(`${salt}${passwd}`, 'utf8').digest().toString('hex');\n  if(userInfo && hash === userInfo.password) {\n    const data = {id: userInfo.id, name: userInfo.name};\n    setSession(database, ctx, sessionName, data); // 创建session\n    return data;\n  }\n  return null;\n}\n\nmodule.exports = {\n  login,\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"现在，我们需要实现一个用户登录的拦截切面，以响应用户的登录请求："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"app.use(async ({cookies, res}, next) => {\n  let id = cookies.interceptor_js;\n  if(!id) {\n    id = Math.random().toString(36).slice(2);\n  }\n  res.setHeader('Set-Cookie', `interceptor_js=${id}; Path=/; Max-Age=${7 * 86400}`); // 设置cookie的有效时长一周\n  await next();\n});\n\n...省略其它切面\n\napp.use(router.post('/login', async (ctx, next) => {\n  const {database, params, res} = ctx;\n  res.setHeader('Content-Type', 'application/json');\n  const {login} = require('./model/user');\n  const result = await login(database, ctx, params);\n  res.body = result || {err: 'invalid user'};\n  await next();\n}));\n"})}),"\n",(0,i.jsxs)(n.p,{children:["上面的代码有两个切面，第一个切面表示每次用户请求服务器，服务器都为该用户更新他的 Cookie。第二个切面表示用户可以通过路径",(0,i.jsx)(n.code,{children:"/login"}),"向我们的服务器发送 POST 请求登录。如果登录成功，服务器返回用户的信息。如果登录失败，则返回",(0,i.jsx)(n.code,{children:"{err: 'invalid user'}"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"⚠️注意，更新 Cookie 的切面必须放在所有切面的前面，无论用户是否进行登录操作，服务器都会为该用户更新他的 Cookie。我们启动服务器，用 postman 试一下这个接口："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:r,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"这样我们就实现了将用户信息保存到 Session，以及从 Session 中读取用户信息的功能。"}),"\n",(0,i.jsx)(n.p,{children:"现在，我们打开事先实现好的登录页面（具体的页面代码可以查看[TODO: 仓库连接]）："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"当我们点击登录后，服务器会将这个请求转发到如下拦截切面中处理：如果用户登录失败，返回 302 跳转并回到登录页面；如果登录成功，则进入 index.html 页面："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"app.use(router.post('/login', async (ctx, next) => {\n  const {database, params, res} = ctx;\n  const {login} = require('./model/user');\n  const result = await login(database, ctx, params);\n  res.statusCode = 302;\n  if(!result) { // 登录失败，跳转到login继续登录\n    res.setHeader('Location', '/login.html');\n  } else {\n    res.setHeader('Location', '/'); // 成功，跳转到 index\n  }\n  await next();\n}));\n"})}),"\n",(0,i.jsx)(n.p,{children:"上面的代码中，我们使用 HTTP 状态码 302，它表示临时跳转，设置 Location 为跳转目的地，那么浏览器就会执行跳转了。到此，Session 的实现就完成了。下面，我们来看看会话机制是如何被使用的。"}),"\n",(0,i.jsxs)(n.h2,{id:"使用-session-机制",children:["使用 Session 机制",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-session-机制",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"当我们进入 index.html（即浏览器打开 index.html 页面后），浏览器会立即执行页面上的 JavaScript 函数 —— loadItems:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"async function loadItems(list) {\n  const {err, data} = await (await fetch('/list')).json();\n  if(err) {\n    window.location.replace('/login.html');\n  } else {\n    data.forEach(({id, state, text}) => addItem(id, list, text, states[state]));\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在这段 JS 脚本中，",(0,i.jsx)(n.code,{children:"await fetch('/list')"}),"会向我们的服务器发起获取用户任务列表的请求。如果成功，则更新 UI，将数据填充到 Todolist 中；如果失败，则返回登录页面。"]}),"\n",(0,i.jsxs)(n.p,{children:["我们来看看响应路径名为 ",(0,i.jsx)(n.code,{children:"/list"})," 的拦截切面都做了什么工作："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"async function checkLogin(ctx) {\n  const {getSession} = require('./model/session');\n  const userInfo = await getSession(ctx.database, ctx, 'userInfo');\n  ctx.userInfo = userInfo;\n  return ctx.userInfo;\n}\n\napp.use(router.get('/list', async (ctx, next) => {\n  const {database, res} = ctx;\n  const userInfo = await checkLogin(ctx); // 如果session存在并有效，则返回用户信息对象\n  res.setHeader('Content-Type', 'application/json');\n  if(userInfo) {\n    const {getList} = require('./model/todolist');\n    const result = await getList(database, userInfo);\n    res.body = {data: result};\n  } else {\n    res.body = {err: 'not login'};\n  }\n  await next();\n}));\n"})}),"\n",(0,i.jsxs)(n.p,{children:["首先，处理",(0,i.jsx)(n.code,{children:"/list"}),"的拦截切面会先去检查用户的 Session 是否有效（即 checkLogin 函数）。getSession 方法根据浏览器返回来的 Cookie，从 Session 表中查询用户的 Session，如果用户的 Session 存在并有效，则返回用户的信息对象，否则返回",(0,i.jsx)(n.code,{children:"null"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"然后，根据 checkLogin 方法返回的结果，进行下一步的处理："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"如果 checkLogin 方法返回的是一个用户信息对象，说明该用户的 Session 还是有效的，那么服务器就会根据用户信息，获得和这个用户相关的任务列表，并返回给客户端；"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"如果返回 null，表示这个用户的 Session 不存在或已经过期，那么服务器返回错误对象，将用户导向登录页面。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"当然，这里我们需要给 Todo 表添加用户 ID 字段："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"这样，服务器才能根据用户 ID 来获得和该用户相关的任务数据："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"async function getList(database, userInfo) {\n  const result = await database.all(`SELECT * FROM todo WHERE state <> 2 and userid = ${userInfo.id} ORDER BY state DESC`);\n  return result;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"然后修改对应的拦截切面："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"async function checkLogin(ctx) {\n  const {getSession} = require('./model/session');\n  const userInfo = await getSession(ctx.database, ctx, 'userInfo');\n  ctx.userInfo = userInfo;\n  return ctx.userInfo;\n}\n\napp.use(router.get('/list', async (ctx, next) => {\n  const {database, res} = ctx;\n  const userInfo = await checkLogin(ctx);\n  res.setHeader('Content-Type', 'application/json');\n  if(userInfo) {\n    const {getList} = require('./model/todolist');\n    const result = await getList(database, userInfo);\n    res.body = {data: result};\n  } else {\n    res.body = {err: 'not login'};\n  }\n  await next();\n}));\n\napp.use(router.post('/add', async (ctx, next) => {\n  const {database, params, res} = ctx;\n  const userInfo = await checkLogin(ctx);\n  res.setHeader('Content-Type', 'application/json');\n  if(userInfo) {\n    const {addTask} = require('./model/todolist');\n    const result = await addTask(database, userInfo, params);\n    res.body = result;\n    await next();\n  } else {\n    res.body = {err: 'not login'};\n  }\n  await next();\n}));\n"})}),"\n",(0,i.jsx)(n.p,{children:"最后，我们改一下前端的JS代码："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"async function loadItems(list) {\n  const {err, data} = await (await fetch('/list')).json();\n  if(err) {\n    window.location.replace('/login.html');\n  } else {\n    data.forEach(({id, state, text}) => addItem(id, list, text, states[state]));\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这样，如果访问的时候没有登录，就会自动跳转到",(0,i.jsx)(n.code,{children:"/login.html"}),"进行登录了。最终完整的应用的操作流程如下："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,i.jsxs)(n.h2,{id:"总结",children:["总结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["一些初学者很可能认为 Session 和 Cookie 类似，也是浏览器的一个对象。但其实，",(0,i.jsx)(n.strong,{children:"Session 只是一个建立在 Cookie 特性上的机制，并不是浏览器的对象"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"创建 Session 一般发生在用户首次登录或者 Session 过期，或者用户需要再次登录时。创建 Session 的流程一般为："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"用户在客户端提交包含个人信息（如用户名）以及密码的表单；"}),"\n",(0,i.jsx)(n.li,{children:"服务器获取客户端发来的 Cookie，如果没有，则创建一个新 Cookie；"}),"\n",(0,i.jsx)(n.li,{children:"利用用户的信息和 Cookie，向 Session 表新增或更新用户的 Session；"}),"\n",(0,i.jsx)(n.li,{children:"Session 创建成功，返回用户信息对象。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"有了 Session 后，服务器就能跟踪用户在网站上的各种操作和请求了。当用户请求的资源需要验证用户信息的时候，服务器就根据客户端发来的 Cookie，从 Session 表中查询用户信息，确认用户身份，成功则返回该请求的响应，失败则将用户导向登录页面。"}),"\n",(0,i.jsx)(n.p,{children:"至此，我们的第一个动态 Web 应用 Todolist 的主体功能就完成了。我们的 HTTP 服务器很好地支持了整个应用的逻辑实现。当然，它还有可以改进的地方。下一节课，我们将对服务器进行最后的优化，一起期待吧！"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}let x=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F21%20%20%E7%90%86%E8%A7%A3%20HTTP%EF%BC%9A%E4%BD%BF%E7%94%A8%20Cookie%20%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86.md"]={toc:[{text:"实现 Session 机制",id:"实现-session-机制",depth:2},{text:"实现用户登录",id:"实现用户登录",depth:3},{text:"创建 Session",id:"创建-session",depth:3},{text:"使用 Session 机制",id:"使用-session-机制",depth:2},{text:"总结",id:"总结",depth:2}],title:"21  理解 HTTP：使用 Cookie 实现会话管理",headingTitle:"21  理解 HTTP：使用 Cookie 实现会话管理",frontmatter:{}}}}]);