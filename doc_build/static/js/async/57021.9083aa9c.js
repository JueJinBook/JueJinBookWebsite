"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57021"],{716954:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var r=s(552676),t=s(740453);let o=s.p+"static/image/e73769c8b07019a8719de523373f089b.98139e08.webp",c=s.p+"static/image/7ca84b81d255cb5cd1ec0ee347277e6e.f36a6b2e.webp";function a(e){let n=Object.assign({p:"p",strong:"strong",img:"img",h1:"h1",a:"a",pre:"pre",code:"code",blockquote:"blockquote",ul:"ul",li:"li",h2:"h2",ol:"ol"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["通过前几节的学习，我们已经掌握了 ",(0,r.jsx)(n.strong,{children:"React Hooks API"})," 的使用，掌握了自定义 ",(0,r.jsx)(n.strong,{children:"Hooks"})," 的开发流程，接下来将正式进行源码的学习。"]}),"\n",(0,r.jsx)(n.p,{children:"我们知道，如果 React 并没有 Hooks，那么函数式组件只能接收 props，渲染 UI，做一个展示组件，所有的逻辑就要在 Class 中书写，这样势必会导致 Class 组件内部错综复杂、代码臃肿。而函数式组件则不然，它能做 Class 组件的功能，拥有属于自己的状态，处理一些副作用，获取目标元素的属性、缓存数据等，所以有必要做一套函数式组件代替类组件的方案，Hooks 也就诞生了。"}),"\n",(0,r.jsx)(n.p,{children:"Hooks 拥有属于自己的状态，提供了 useState 和 useReducer 两个 Hook，解决自身的状态问题，取代 Class 组件的 this.setState。"}),"\n",(0,r.jsx)(n.p,{children:"在我们日常工作中最常用的就是 useState，我们就从它的源码入手，了解函数式组件是如何拥有自身的状态，如何保存数据、更新数据的。全面掌握 useState 的运行流程，就等同于掌握整个 Hooks 的运行机制。"}),"\n",(0,r.jsx)(n.p,{children:"先附上一张今天的知识图谱："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.h1,{id:"10源码篇以-usestate-的视角来看-hooks-的运行机制",children:["10.源码篇｜以 useState 的视角来看 Hooks 的运行机制",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10源码篇以-usestate-的视角来看-hooks-的运行机制",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"先举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'import { Button } from "antd";\nimport { useState } from "react";\nconst Index = () => {\n  const [count, setCount] = useState(0);\n  return (\n    <><div>大家好，我是小杜杜，一起玩转Hooks吧！</div><div>数字：{count}</div><Button onClick={() => setCount((v) => v + 1)}>点击加1</Button></>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,r.jsx)(n.p,{children:"在上述的例子中，我们引入了 useState，并存储 count 变量，通过 setCount 来控制 count。也就是说，count 是函数式组件自身的状态，setCount 是触发数据更新的函数。"}),"\n",(0,r.jsx)(n.p,{children:"在通常的开发中，当引入组件后，会从引用地址跳到对应引用的组件，查看该组件到底是如何书写的。"}),"\n",(0,r.jsx)(n.p,{children:"我们以相同的方式来看看 useState，看看它在 React 中是如何书写的。"}),"\n",(0,r.jsxs)(n.p,{children:["文件位置：",(0,r.jsx)(n.code,{children:"packages/react/src/ReactHooks.js"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看出 useState 的执行就等价于 ",(0,r.jsx)(n.code,{children:"resolveDispatcher().useState(initialState)"}),"，那么我们顺着线索看下去："]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"resolveDispatcher()"})," ："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function resolveDispatcher() {\n  const dispatcher = ReactCurrentDispatcher.current;\n  return ((dispatcher: any): Dispatcher);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ReactCurrentDispatcher"}),"："]}),"\n",(0,r.jsxs)(n.p,{children:["文件位置：",(0,r.jsx)(n.code,{children:"packages/react/src/ReactCurrentDispatcher.js"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const ReactCurrentDispatcher = {\n  current: (null: null | Dispatcher),\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["通过类型可以看到 ",(0,r.jsx)(n.code,{children:"ReactCurrentDispatcher"})," 不是 null，就是 Dispatcher，而在初始化时 ",(0,r.jsx)(n.code,{children:"ReactCurrentDispatcher.current"})," 的值必为 null，因为此时还",(0,r.jsx)(n.strong,{children:"未进行操作"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["那么此时就很奇怪了，我们并没有发现 useState 是如何进行存储、更新的，",(0,r.jsx)(n.code,{children:"ReactCurrentDispatcher.current"})," 又是何时为 ",(0,r.jsx)(n.code,{children:"Dispatcher"})," 的？"]}),"\n",(0,r.jsxs)(n.p,{children:["既然我们在 useState 自身中无法看到存储的变量，那么就只能从",(0,r.jsx)(n.strong,{children:"函数执行"}),"开始，一步一步探索 useState 是如何保存数据的。"]}),"\n",(0,r.jsxs)(n.h1,{id:"函数式组件如何执行的",children:["函数式组件如何执行的？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数式组件如何执行的",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在上节 Fiber 的讲解中，了解到我们写的 JSX 代码，是被 babel 编译成 React.createElement 的形式后，最终会走到 beginWork 这个方法中，而 beginWork 会走到 mountIndeterminateComponent 中，在这个方法中会有一个函数叫 ",(0,r.jsx)(n.strong,{children:"renderWithHooks"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"renderWithHooks 就是所有函数式组件触发函数"}),"，接下来一起看看："]}),"\n",(0,r.jsxs)(n.p,{children:["文件位置：",(0,r.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberHooks"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"export function renderWithHooks<Props, SecondArg>(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: (p: Props, arg: SecondArg) => any,\n  props: Props,\n  secondArg: SecondArg,\n  nextRenderLanes: Lanes,\n): any {\n  currentlyRenderingFiber = workInProgress;\n\n  // memoizedState: 用于存放hooks的信息，如果是类组件，则存放state信息\n  workInProgress.memoizedState = null;\n  //updateQueue：更新队列，用于存放effect list，也就是useEffect产生副作用形成的链表\n  workInProgress.updateQueue = null;\n\n  // 用于判断走初始化流程还是更新流程\n  ReactCurrentDispatcher.current =\n    current === null || current.memoizedState === null\n      ? HooksDispatcherOnMount\n      : HooksDispatcherOnUpdate;\n\n  // 执行真正的函数式组件，所有的hooks依次执行\n  let children = Component(props, secondArg);\n\n  finishRenderingHooks(current, workInProgress);\n\n  return children;\n}\n\nfunction finishRenderingHooks(current: Fiber | null, workInProgress: Fiber) {\n    \n  // 防止hooks乱用，所报错的方案\n  ReactCurrentDispatcher.current = ContextOnlyDispatcher;\n\n  const didRenderTooFewHooks =\n    currentHook !== null && currentHook.next !== null;\n\n  // current树\n  currentHook = null;\n  workInProgressHook = null;\n\n  didScheduleRenderPhaseUpdate = false;\n}\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"PS：展示的代码有稍许加工。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["我们先分析下 ",(0,r.jsx)(n.strong,{children:"renderWithHooks"})," 函数的入参。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"current："})," 即 current fiber，渲染完成时所生成的 current 树，之后在 ",(0,r.jsx)(n.strong,{children:"commit 阶段替换为真正的 DOM 树"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"workInProgress："})," 即 workInProgress fiber，当更新时，",(0,r.jsx)(n.strong,{children:"复制 current fiber，从这棵树进行更新，更新完毕后，再赋值给 current 树"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Component："})," 函数组件本身；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"props："})," 函数组件自身的 props；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"secondArg："})," 上下文；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"nextRenderLanes："})," 渲染的优先级。"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"问：Fiber 架构的三个阶段分别是什么？"}),"\n",(0,r.jsx)(n.p,{children:"答：总共分为 reconcile、schedule、commit 阶段。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"reconcile"})," 阶段： vdom 转化为 fiber 的过程。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"schedule"})," 阶段：在 fiber 中遍历的过程中，可以打断，也能再恢复的过程。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"commit"})," 阶段：fiber 更新到真实 DOM 的过程。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"renderwithhooks-的执行流程",children:["renderWithHooks 的执行流程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#renderwithhooks-的执行流程",children:"#"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["在每次函数组件执行之前，先将 workInProgress 的 memoizedState 和 updateQueue 属性进行清空，之后将新的 Hooks 信息挂载到这两个属性上，之后在 commit 阶段替换 current 树，也就是说 ",(0,r.jsx)(n.strong,{children:"current 树保存 Hooks 信息；"})]}),"\n",(0,r.jsxs)(n.li,{children:["然后通过判断 current 树是否存在来判断走初始化（ HooksDispatcherOnMount ）流程还是更新（ HooksDispatcherOnUpdate ）流程。而 ReactCurrentDispatcher.current 实际上包含所有的 Hooks，简单地讲，",(0,r.jsx)(n.strong,{children:"React 根据 current 的不同来判断对应的 Hooks，从而监控 Hooks 的调用情况；"})]}),"\n",(0,r.jsxs)(n.li,{children:["接下来调用的 ",(0,r.jsx)(n.strong,{children:"Component(props, secondArg) 就是真正的函数组件"}),"，然后依次执行里面的 Hooks；"]}),"\n",(0,r.jsxs)(n.li,{children:["最后提供整个的",(0,r.jsx)(n.strong,{children:"异常处理"}),"，防止不必要的报错，再将一些属性置空，如：currentHook、workInProgressHook 等。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["通过 renderWithHooks 的执行步骤，可以看出总共分为三个阶段，分别是：",(0,r.jsx)(n.strong,{children:"初始化阶段"}),"、",(0,r.jsx)(n.strong,{children:"更新阶段"}),"以及",(0,r.jsx)(n.strong,{children:"异常处理"}),"三个阶段，同时这三个阶段也是整个 Hooks 处理的",(0,r.jsx)(n.strong,{children:"三种策略"}),"，接下来我们逐一分析。"]}),"\n",(0,r.jsxs)(n.h1,{id:"hooksdispatcheronmount初始化阶段",children:["HooksDispatcherOnMount（初始化阶段）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hooksdispatcheronmount初始化阶段",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在初始化阶段中，调用的是 ",(0,r.jsx)(n.code,{children:"HooksDispatcherOnMount"}),"，对应的 useState 所走的是 ",(0,r.jsx)(n.code,{children:"mountState"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["文件位置：",(0,r.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberHooks.js"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:" // 包含所有的hooks，这里列举常见的\nconst HooksDispatcherOnMount = { \n    useRef: mountRef,\n    useMemo: mountMemo,\n    useCallback: mountCallback,\n    useEffect: mountEffect,\n    useState: mountState,\n    useTransition: mountTransition,\n    useSyncExternalStore: mountSyncExternalStore,\n    useMutableSource: mountMutableSource,\n    ...\n}\n\nfunction mountState(initialState){\n  // 所有的hooks都会走这个函数\n  const hook = mountWorkInProgressHook(); \n  \n  // 确定初始入参\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  \n  const queue = {\n    pending: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: (initialState),\n  };\n  hook.queue = queue;\n  \n  const dispatch = (queue.dispatch = (dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    queue,\n  ): any));\n  return [hook.memoizedState, dispatch];\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"mountworkinprogresshook",children:["mountWorkInProgressHook",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mountworkinprogresshook",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["整体的流程先走向 ",(0,r.jsx)(n.code,{children:"mountWorkInProgressHook()"})," 这个函数，它的作用尤为重要，因为这个函数的作用是将 ",(0,r.jsx)(n.strong,{children:"Hooks 与 Fiber 联系起来"}),"，并且你会发现，所有的 ",(0,r.jsx)(n.strong,{children:"Hooks 都会走这个函数，只是不同的 Hooks 保存着不同的信息"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function mountWorkInProgressHook(): Hook {\n  const hook: Hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null,\n  };\n\n  if (workInProgressHook === null) { // 第一个hooks执行\n    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;\n  } else { // 之后的hooks\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n  return workInProgressHook;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["来看看 ",(0,r.jsx)(n.strong,{children:"hook"})," 值的参数："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"memoizedState"}),"：用于保存数据，不同的 Hooks 保存的信息不同，比如 useState 保存 state 信息，useEffect 保存 effect 对象，useRef 保存 ref 对象；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"baseState"}),"：当数据发生改变时，保存最新的值；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"baseQueue"}),"：保存最新的更新队列；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"queue"}),"：保存待更新的队列或更新的函数；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"next"}),"：用于指向下一个 hook 对象。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["那么 ",(0,r.jsx)(n.code,{children:"mountWorkInProgressHook"})," 的作用就很明确了，",(0,r.jsx)(n.strong,{children:"每执行一个 Hooks 函数就会生成一个 hook 对象，然后将每个 hook 串联起来"}),"。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"特别注意：这里的 memoizedState 并不是 Fiber 链表上的 memoizedState，workInProgress 保存的是当前函数组件每个 Hooks 形成的链表。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"执行步骤",children:["执行步骤",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行步骤",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"了解完 mountWorkInProgressHook 后，再来看看之后的流程。"}),"\n",(0,r.jsxs)(n.p,{children:["首先通过 ",(0,r.jsx)(n.code,{children:"initialState"})," 初始值的类型（判断是否是函数），并将初始值赋值给 hook 的",(0,r.jsx)(n.code,{children:"memoizedState"})," 和 ",(0,r.jsx)(n.code,{children:"baseState"}),"。再之后，创建一个 ",(0,r.jsx)(n.code,{children:"queue"})," 对象，这个对象中会保存一些数据，这些数据为："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pending"}),"：用来调用 dispatch 创建时最后一个；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lanes"}),"：优先级；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"dispatch"}),"：用来负责更新的函数；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lastRenderedReducer"}),"：用于得到最新的 state；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"lastRenderedState"}),"：最后一次得到的 state。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["最后会定义一个 ",(0,r.jsx)(n.code,{children:"dispath"}),"，而这个 dispath 就应该对应最开始的 ",(0,r.jsx)(n.code,{children:"setCount"}),"，那么接下来的目的就是搞懂 dispatch 的机制。"]}),"\n",(0,r.jsxs)(n.h2,{id:"dispatchsetstate",children:["dispatchSetState",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dispatchsetstate",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["dispatch 的机制就是 ",(0,r.jsx)(n.code,{children:"dispatchSetState"}),"，在源码内部还是调用了很多函数，所以在这里对 dispatchSetState 函数做了些优化，方便我们更好地观看。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function dispatchSetState<S, A>(\n  fiber: Fiber, // 对应currentlyRenderingFiber\n  queue: UpdateQueue<S, A>, // 对应 queue\n  action: A, // 真实传入的参数\n): void {\n\n  // 优先级，不做介绍，后面也会去除有关优先级的部分\n  const lane = requestUpdateLane(fiber);\n\n  // 创建一个update\n  const update: Update<S, A> = {\n    lane,\n    action,\n    hasEagerState: false,\n    eagerState: null,\n    next: (null: any),\n  };\n\n   // 判断是否在渲染阶段\n  if (fiber === currentlyRenderingFiber || (fiber.alternate !== null && fiber.alternate === currentlyRenderingFiber)) {\n      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n      const pending = queue.pending;\n      // 判断是否是第一次更新\n      if (pending === null) {\n        update.next = update;\n      } else {\n        update.next = pending.next;\n        pending.next = update;\n      }\n      // 将update存入到queue.pending中\n      queue.pending = update;\n  } else { // 用于获取最新的state值\n    const alternate = fiber.alternate;\n    if (alternate === null && lastRenderedReducer !== null){\n      const lastRenderedReducer = queue.lastRenderedReducer;\n      let prevDispatcher;\n      const currentState: S = (queue.lastRenderedState: any);\n      // 获取最新的state\n      const eagerState = lastRenderedReducer(currentState, action);\n      update.hasEagerState = true;\n      update.eagerState = eagerState;\n      if (is(eagerState, currentState)) return;\n    }\n\n    // 将update 插入链表尾部，然后返回root节点\n    const root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n    if (root !== null) {\n      // 实现对应节点的更新\n      scheduleUpdateOnFiber(root, fiber, lane, eventTime);\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"在代码中，我已经将每段代码执行的目的标注出来，为了我们更好地理解，分析一下对应的入参，以及函数体内较重要的参数与步骤。"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"分析入参"}),"：dispatchSetState 一共有三个入参，前两个入参数被 ",(0,r.jsx)(n.code,{children:"bind"})," 分别改为 currentlyRenderingFiber 和 queue，第三个 action 则是我们实际写的函数；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"update 对象"}),"：生成一个 update 对象，用于记录更新的信息；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"判断是否处于渲染阶段"}),"：如果是渲染阶段，则将 ",(0,r.jsx)(n.code,{children:"update"})," 放入等待更新的 ",(0,r.jsx)(n.code,{children:"pending"})," 队列中，如果不是，就会获取最新的 ",(0,r.jsx)(n.code,{children:"state"})," 值，从而进行更新。"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"问：bind 的作用是什么？"}),"\n",(0,r.jsx)(n.p,{children:"答：当函数调用 bind 后，会产生一个新的函数，第一个值会作为新函数的 this，如果第一个参数为 null 或是 undefined 时，会默认指向 window，其余的参数会依次成为旧函数的参数。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["值得注意的是：在更新过程中，也会判断很多，通过调用 ",(0,r.jsx)(n.code,{children:"lastRenderedReducer"})," 获取最新的 ",(0,r.jsx)(n.code,{children:"state"}),"，然后进行",(0,r.jsx)(n.strong,{children:"比较（浅比较）"})," ，如果相等则退出，这一点就是证明 useState 渲染相同值时，组件不更新的原因。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果不相等，则会将 ",(0,r.jsx)(n.code,{children:"update"})," 插入链表的尾部，返回对应的 ",(0,r.jsx)(n.code,{children:"root"})," 节点，通过 ",(0,r.jsx)(n.strong,{children:"scheduleUpdateOnFiber 实现对应的更新"}),"，可见 ",(0,r.jsx)(n.code,{children:"scheduleUpdateOnFiber"})," 是 React 渲染更新的主要函数。"]}),"\n",(0,r.jsxs)(n.h1,{id:"hooksdispatcheronupdate更新阶段",children:["HooksDispatcherOnUpdate（更新阶段）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hooksdispatcheronupdate更新阶段",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在更新阶段时，调用 ",(0,r.jsx)(n.code,{children:"HooksDispatcherOnUpdate"}),"，对应的 ",(0,r.jsx)(n.code,{children:"useState"})," 所走的是 ",(0,r.jsx)(n.code,{children:"updateState"}),"，如："]}),"\n",(0,r.jsxs)(n.p,{children:["文件位置：",(0,r.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberHooks.js"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const HooksDispatcherOnUpdate: Dispatcher = {\n  useRef: updateRef,\n  useMemo: updateMemo,\n  useCallback: updateCallback,\n  useEffect: updateEffect,\n  useState: updateState,\n  useTransition: updateTransition,\n  useSyncExternalStore: updateSyncExternalStore,\n  useMutableSource: updateMutableSource,\n  ...\n};\n\nfunction updateState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  return updateReducer(basicStateReducer, (initialState: any));\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  return typeof action === 'function' ? action(state) : action;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"updateState"})," 有两个函数，一个是 ",(0,r.jsx)(n.code,{children:"updateReducer"}),"，另一个是 ",(0,r.jsx)(n.code,{children:"basicStateReducer"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"basicStateReducer"})," 很简单，判断是否是函数，返回对应的值即可。"]}),"\n",(0,r.jsxs)(n.p,{children:["那么下面主要看 ",(0,r.jsx)(n.code,{children:"updateReducer"})," 这个函数，在 updateReducer 函数中首先调用 ",(0,r.jsx)(n.code,{children:"updateWorkInProgressHook"}),"，我们先来看看这个函数，方便后续对 updateReducer 的理解。"]}),"\n",(0,r.jsxs)(n.h2,{id:"updateworkinprogresshook",children:["updateWorkInProgressHook",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#updateworkinprogresshook",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"updateWorkInProgressHook"})," 跟 ",(0,r.jsx)(n.code,{children:"mountWorkInProgressHook"})," 一样，",(0,r.jsx)(n.strong,{children:"当函数更新时，所有的 Hooks 都会执行"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["文件位置：",(0,r.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberHooks.js"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function updateWorkInProgressHook(): Hook {\n  let nextCurrentHook: null | Hook;\n  \n  // 判断是否是第一个更新的hook\n  if (currentHook === null) { \n    const current = currentlyRenderingFiber.alternate;\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else { // 如果不是第一个hook，则指向下一个hook\n    nextCurrentHook = currentHook.next;\n  }\n\n  let nextWorkInProgressHook: null | Hook;\n  // 第一次执行\n  if (workInProgressHook === null) { \n    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // 特殊情况：发生多次函数组件的执行\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n  } else {\n    if (nextCurrentHook === null) {\n      const currentFiber = currentlyRenderingFiber.alternate;\n      \n      const newHook: Hook = {\n        memoizedState: null,\n        baseState: null,\n        baseQueue: null,\n        queue: null,\n        next: null,\n      };\n        nextCurrentHook = newHook;\n      } else {\n        throw new Error('Rendered more hooks than during the previous render.');\n      }\n    }\n\n    currentHook = nextCurrentHook;\n\n    // 创建一个新的hook\n    const newHook: Hook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null,\n    };\n\n    if (workInProgressHook === null) { // 如果是第一个函数\n      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;\n    } else {\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n  return workInProgressHook;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"updateWorkInProgressHook 执行流程"}),"：如果是首次执行 Hooks 函数，就会从已有的 ",(0,r.jsx)(n.strong,{children:"current"})," 树中取到对应的值，然后声明 ",(0,r.jsx)(n.code,{children:"nextWorkInProgressHook"}),"，经过一系列的操作，得到更新后的 Hooks 状态。"]}),"\n",(0,r.jsxs)(n.p,{children:["在这里要注意一点，大多数情况下，",(0,r.jsx)(n.code,{children:"workInProgress"})," 上的 ",(0,r.jsx)(n.code,{children:"memoizedState"})," 会被置空，也就是 ",(0,r.jsx)(n.code,{children:"nextWorkInProgressHook"})," 应该为 null。但",(0,r.jsx)(n.strong,{children:"执行多次"}),"函数组件时，就会出现循环执行函数组件的情况，此时 ",(0,r.jsx)(n.code,{children:"nextWorkInProgressHook"})," 不为 null。"]}),"\n",(0,r.jsxs)(n.h2,{id:"updatereducer",children:["updateReducer",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#updatereducer",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["掌握了 ",(0,r.jsx)(n.code,{children:"updateWorkInProgressHook"}),"执行流程后， 再来看 ",(0,r.jsx)(n.code,{children:"updateReducer"})," 具体有哪些内容。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function updateReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n\n  // 获取更新的hook，每个hook都会走\n  const hook = updateWorkInProgressHook();\n  const queue = hook.queue;\n\n  queue.lastRenderedReducer = reducer;\n\n  const current: Hook = (currentHook: any);\n\n  let baseQueue = current.baseQueue;\n \n  // 在更新的过程中，存在新的更新，加入新的更新队列\n  const pendingQueue = queue.pending;\n  if (pendingQueue !== null) {\n    // 如果在更新过程中有新的更新，则加入新的队列，有个合并的作用，合并到 baseQueue\n    if (baseQueue !== null) {\n      const baseFirst = baseQueue.next;\n      const pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    const first = baseQueue.next;\n    let newState = current.baseState;\n\n    let newBaseState = null;\n    let newBaseQueueFirst = null;\n    let newBaseQueueLast = null;\n    let update = first;\n    \n    // 循环更新\n    do {\n      // 获取优先级\n      const updateLane = removeLanes(update.lane, OffscreenLane);\n      const isHiddenUpdate = updateLane !== update.lane;\n\n      const shouldSkipUpdate = isHiddenUpdate\n        ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane)\n        : !isSubsetOfLanes(renderLanes, updateLane);\n\n      if (shouldSkipUpdate) {\n        const clone: Update<S, A> = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: (null: any),\n        };\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n        \n        // 合并优先级（低级任务）\n        currentlyRenderingFiber.lanes = mergeLanes(\n          currentlyRenderingFiber.lanes,\n          updateLane,\n        );\n        markSkippedUpdateLanes(updateLane);\n      } else {\n         // 判断更新队列是否还有更新任务\n        if (newBaseQueueLast !== null) {\n          const clone: Update<S, A> = {\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: (null: any),\n          };\n          \n          // 将更新任务插到末尾\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        }\n\n        const action = update.action;\n        \n        // 判断更新的数据是否相等\n        if (update.hasEagerState) {\n          newState = ((update.eagerState: any): S);\n        } else {\n          newState = reducer(newState, action);\n        }\n      }\n      // 判断是否还需要更新\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    // 如果 newBaseQueueLast 为null，则说明所有的update处理完成，对baseState进行更新\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = (newBaseQueueFirst: any);\n    }\n\n    // 如果新值与旧值不想等，则触发更新流程\n    if (!is(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    // 将新值，保存在hook中\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n\n    queue.lastRenderedState = newState;\n  }\n\n  if (baseQueue === null) {\n    queue.lanes = NoLanes;\n  }\n\n  const dispatch: Dispatch<A> = (queue.dispatch: any);\n  return [hook.memoizedState, dispatch];\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"updateReducer 的作用是将待更新的队列 pendingQueue 合并到 baseQueue 上，之后进行循环更新，最后进行一次合成更新，也就是批量更新，统一更换节点。"}),"\n",(0,r.jsx)(n.p,{children:"这种行为解释了 useState 在更新的过程中为何传入相同的值，不进行更新，同时多次操作，只会执行最后一次更新的原因了。"}),"\n",(0,r.jsxs)(n.h2,{id:"更新-state-值",children:["更新 state 值",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新-state-值",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"为了更好理解更新流程，我们做一个简单的例子来说明："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function Index() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div style={{ padding: 20 }}>\n      <div>数字：{count}</div>\n      <Button\n        onClick={() => {\n          // 第一种方式\n          setCount((v) => v + 1);\n          setCount((v) => v + 2);\n          setCount((v) => v + 3);\n\n          // 第二种方式\n          setCount(count + 1);\n          setCount(count + 2);\n          setCount(count + 3);\n        }}\n      >\n        批量执行\n      </Button>\n    </div>\n  );\n}\n\nexport default Index;\n"})}),"\n",(0,r.jsx)(n.p,{children:"案例中就是普通的点击按钮，触发 count 变化的操作，那么大家可以猜想下，这两种方式点击按钮后的 count 的值究竟是多少？"}),"\n",(0,r.jsx)(n.p,{children:"答案："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["第一种 count 等于：",(0,r.jsx)(n.strong,{children:"6"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["第二种 count 等于：",(0,r.jsx)(n.strong,{children:"3"})," 。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["出现这种原因也非常简单，当 setCount 的参数为函数时，此时的返参 v 就是 ",(0,r.jsx)(n.code,{children:"baseQueue"})," 链表不断更新的值，所以为 0 + 1 + 2 + 3 = 6。"]}),"\n",(0,r.jsx)(n.p,{children:"而第二种的 count 为渲染后的值，也就是说，三个 setCount 全部执行完成，合并之后，count 才会变，在合并前为 0 + 1， 0 + 2， 0 + 3。最后一次为 3，所以 count 为 3。"}),"\n",(0,r.jsxs)(n.h1,{id:"contextonlydispatcher-异常处理阶段",children:["ContextOnlyDispatcher 异常处理阶段",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#contextonlydispatcher-异常处理阶段",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"renderWithHooks"})," 流程最后，调用了 ",(0,r.jsx)(n.code,{children:"finishRenderingHooks"})," 函数，这个函数中用到了 ",(0,r.jsx)(n.code,{children:"ContextOnlyDispatcher"}),"，那么它的作用是什么呢？看看代码："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"throwInvalidHookError："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function throwInvalidHookError() {\n  throw new Error(\n    'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n      ' one of the following reasons:\\n' +\n      '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n      '2. You might be breaking the Rules of Hooks\\n' +\n      '3. You might have more than one copy of React in the same app\\n' +\n      'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',\n  );\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到，",(0,r.jsx)(n.code,{children:"ContextOnlyDispatcher"})," 是判断所需 ",(0,r.jsx)(n.code,{children:"Hooks"})," 是否在函数组件内部，有",(0,r.jsx)(n.strong,{children:"捕获并抛出异常的作用"}),"，这也就解释了 Hooks 无法在 React 之外运行的原因。"]}),"\n",(0,r.jsxs)(n.h1,{id:"usestate-运行流程",children:["useState 运行流程",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usestate-运行流程",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们以 ",(0,r.jsx)(n.strong,{children:"useState"})," 为例，讲解了对应的初始化和更新，简单回顾一下运行流程："]}),"\n",(0,r.jsxs)(n.h1,{id:"hooks-规则时序问题",children:["Hooks 规则：时序问题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hooks-规则时序问题",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"了解完 useState 源码，以及存储、更新、异常的处理方案，我们发现其中有一个问题点，在我们多次调用 useState 的时候，React 是如何知道我们要改变的 useState 就是想要改变的 useState 呢？如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'const [name, setName] = useState("小杜杜")\nconst [age, setAge] = useState(0)\n\nuseEffect(() => {}, [])\n'})}),"\n",(0,r.jsx)(n.p,{children:"这两个 useState 只有参数上的区别，那么 React 是如何区分是 name 还是 age 呢？"}),"\n",(0,r.jsxs)(n.p,{children:["答案其实很简单，就是",(0,r.jsx)(n.strong,{children:"时序"}),"，React 相当于做了一个合并操作，当我们第一次调用 ",(0,r.jsx)(n.strong,{children:"useState"})," 时，保存了 ",(0,r.jsx)(n.strong,{children:"name"}),"，第二次调用时保存了 ",(0,r.jsx)(n.strong,{children:"age"}),"，相当于类中的结构。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'this.setState({\n    name: "小杜杜",\n    age: 7\n})\n'})}),"\n",(0,r.jsxs)(n.p,{children:["当然，在 ",(0,r.jsx)(n.code,{children:"mountWorkInProgressHook"})," 讲解中说过，所有的 Hooks 在创建时，都会产生对应的 hook 对象，当有多个 Hooks 时会以 ",(0,r.jsx)(n.code,{children:"next"})," 连接起来。"]}),"\n",(0,r.jsx)(n.p,{children:"当初始化完成后，对应的结构应该是："}),"\n",(0,r.jsxs)(n.p,{children:["同时，在 Hooks 的规则中有这么一条：",(0,r.jsx)(n.strong,{children:"只在最顶层使用 Hook，不要在循环、条件或嵌套函数中使用 Hook"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"那如果就把它放在条件中，会发生什么变化呢？"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'let age, setAge\nif(name! == "小杜杜"){\n   [age, setAge] = useState(0)\n}\n\nuseEffect(() => {}, [])\n'})}),"\n",(0,r.jsx)(n.p,{children:"在初始化中 name 为小杜杜，但当 name 改变时，便没有了 age，看看此时的报错："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["造成这样的结果，是因为在新的中缺少了 ",(0,r.jsx)(n.code,{children:"useState2"}),"，换句话说，在更新状态的时候，表的结构遭到了",(0,r.jsx)(n.strong,{children:"破坏，让原本指向 useState2 的，指向到 useEffect"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["从源码的角度来讲，",(0,r.jsx)(n.code,{children:"current"})," 树的 ",(0,r.jsx)(n.code,{children:"memoizedState"})," 缓存 ",(0,r.jsx)(n.code,{children:"hook"})," 信息，和当前的 ",(0,r.jsx)(n.code,{children:"workInProgress"})," 不一致，此时就会发生异常。这也是",(0,r.jsx)(n.strong,{children:"不能在条件语句中创建的原因。"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["注：另外可以在 Fiber 中的 ",(0,r.jsx)(n.code,{children:"_debugHookTypes"})," 属性中查看调用 Hooks 的顺序。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h1,{id:"hooks-的实现与-fiber-有必然联系吗",children:["Hooks 的实现与 Fiber 有必然联系吗？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hooks-的实现与-fiber-有必然联系吗",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"最终 Hooks 存储的数据保存在 Fiber 中，Hooks 的产生也确实在 Fiber 的基础上，那么 Hooks 与 Fiber 的关系是必然的吗？"}),"\n",(0,r.jsxs)(n.p,{children:["从 React 的角度出发，整个的渲染流程中是通过 Fiber 去进行转化的，流程为：",(0,r.jsx)(n.strong,{children:"jsx => vdom => Fiber => 真实 DOM"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["而 ",(0,r.jsx)(n.strong,{children:"Hooks 对应 Fiber 中的 memorizedState 链表，依靠 next 链接，只是不同的 hooks 对应保存的值不同而已。"})," 换言之，可以把 Fiber 当作保存 Hooks 值的容器，但这与本身是否依赖 Fiber 并没有太大的联系。"]}),"\n",(0,r.jsxs)(n.p,{children:["就好比 ",(0,r.jsx)(n.code,{children:"preact"})," 中的 Hooks，它并没有实现 Fiber 架构，但也同样实现了 Hooks，它把 Hooks 链表放在了 ",(0,r.jsx)(n.code,{children:"vnode._component._hooks"})," 属性上。"]}),"\n",(0,r.jsx)(n.p,{children:"总的来说 ：实现 Hooks 与 Fiber 并没有必然的联系，相反，只要有对应保存的地方就 ok 了。"}),"\n",(0,r.jsxs)(n.h1,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在本节中，我们首先发现在 useState 自身并不存在对应的存储关系，所以只能从函数执行的过程中去寻找答案，最终发现所有的答案都在 ",(0,r.jsx)(n.code,{children:"renderWithHooks"})," 中，并发现 React 主要通过三大策略去处理 Hooks。"]}),"\n",(0,r.jsxs)(n.p,{children:["这三大策略分别是：HooksDispatcherOnMount（",(0,r.jsx)(n.strong,{children:"初始化阶段，与 Fiber 之间产生关联"}),"）、HooksDispatcherOnUpdate（",(0,r.jsx)(n.strong,{children:"更新阶段，与 Fiber 的桥梁已建立，对桥梁的维护"}),"） 和 ContextOnlyDispatcher（",(0,r.jsx)(n.strong,{children:"异常处理阶段，判断是否在 React 内部调用，如果不是，则抛出异常"}),"）。"]}),"\n",(0,r.jsxs)(n.p,{children:["其中，初始化阶段和更新阶段分别调用：",(0,r.jsx)(n.code,{children:"mountWorkInProgressHook"})," 和 ",(0,r.jsx)(n.code,{children:"updateWorkInProgressHook"})," 函数，同时也是所有 ",(0,r.jsx)(n.code,{children:"Hooks"})," 所走的函数。"]}),"\n",(0,r.jsxs)(n.p,{children:["在文章开头提过 Hooks 是依靠 useState 或 useReducer 进行自身状态的管理，而在 useState 的更新中运用到了 ",(0,r.jsx)(n.code,{children:"updateReducer"}),"， 这是因为两者的原理非常相似，感兴趣的同学再去看看 useReducer 的源码，相信阅读起来不会有任何问题。"]}),"\n",(0,r.jsxs)(n.p,{children:["从三大策略整体来看，",(0,r.jsx)(n.strong,{children:"所有的 Hooks 都遵从上面的逻辑"}),"，只是在三大策略中执行的方法有所出入，因此从 useState 的视角来看，就是整个 Hooks 的运行机制。"]}),"\n",(0,r.jsxs)(n.p,{children:["总的来说，源码内容还是有难度的，如果你是第一次接触，建议多读几遍、沉下心，一步一步去看，不要着急，切记：",(0,r.jsx)(n.strong,{children:"一口吃不吃胖子"}),"。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let d=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F10.%E6%BA%90%E7%A0%81%E7%AF%87%EF%BD%9C%E4%BB%A5%20useState%20%E7%9A%84%E8%A7%86%E8%A7%92%E6%9D%A5%E7%9C%8B%20Hooks%20%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.md"]={toc:[{text:"renderWithHooks 的执行流程",id:"renderwithhooks-的执行流程",depth:2},{text:"mountWorkInProgressHook",id:"mountworkinprogresshook",depth:2},{text:"执行步骤",id:"执行步骤",depth:2},{text:"dispatchSetState",id:"dispatchsetstate",depth:2},{text:"updateWorkInProgressHook",id:"updateworkinprogresshook",depth:2},{text:"updateReducer",id:"updatereducer",depth:2},{text:"更新 state 值",id:"更新-state-值",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);