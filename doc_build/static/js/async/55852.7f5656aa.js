"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55852"],{692473:function(n,e,r){r.r(e),r.d(e,{default:()=>i});var h=r(552676),s=r(740453);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",h3:"h3",ul:"ul",li:"li",blockquote:"blockquote",strong:"strong",img:"img",hr:"hr"},(0,s.ah)(),n.components);return(0,h.jsxs)(h.Fragment,{children:[(0,h.jsxs)(e.h1,{id:"10实战篇-01监听文件变化并自动运行-npm-script",children:["10实战篇 01：监听文件变化并自动运行 npm script",(0,h.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10实战篇-01监听文件变化并自动运行-npm-script",children:"#"})]}),"\n",(0,h.jsx)(e.p,{children:"软件工程师做的事情基本都是在实现自动化，比如各种业务系统是为了业务运转的自动化，部署系统是为了运维的自动化，对于开发者本身，自动化也是提升效率的关键环节，在实际开发过程中也有不少事情是可以自动化的。"}),"\n",(0,h.jsx)(e.p,{children:"拥抱现代前端工作流的同学都会有代码风格检查、单元测试等环节，这样就很需要在代码变更之后立即得到反馈，如代码改动导致了那个 Case 失败，哪块不符合团队的编码规范等。"}),"\n",(0,h.jsx)(e.p,{children:"使用 gulp、grunt 的同学，可能对这种功能非常熟悉，不就是 watch 么？确实是，使用 npm script 我们也可以实现类似的功能。下面详细介绍如何改造我们的项目实现单测、代码检查的自动化。"}),"\n",(0,h.jsxs)(e.h2,{id:"单元测试自动化",children:["单元测试自动化",(0,h.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#单元测试自动化",children:"#"})]}),"\n",(0,h.jsxs)(e.p,{children:["幸运的是，mocha 本身支持 ",(0,h.jsx)(e.code,{children:"--watch"})," 参数，即在代码变化时自动重跑所有的测试，我们只需要在 scripts 对象中新增一条命令即可："]}),"\n",(0,h.jsx)(e.pre,{children:(0,h.jsx)(e.code,{className:"language-patch",children:'     "test": "cross-env NODE_ENV=test mocha tests/",\n+    "watch:test": "npm t -- --watch",\n     "cover": "node scripts/cover.js",\n'})}),"\n",(0,h.jsx)(e.p,{children:"尝试运行 npm run watch:test，我们会发现进程并没有退出，接下来尝试去修改测试代码，测试是不是自动重跑了呢？自己试试看。"}),"\n",(0,h.jsxs)(e.h2,{id:"代码检查自动化",children:["代码检查自动化",(0,h.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码检查自动化",children:"#"})]}),"\n",(0,h.jsxs)(e.p,{children:["我们使用的代码检查工具 ",(0,h.jsx)(e.a,{href:"https://stylelint.io",target:"_blank",rel:"noopener noreferrer",children:"stylelint"}),"、",(0,h.jsx)(e.a,{href:"https://eslint.org",target:"_blank",rel:"noopener noreferrer",children:"eslint"}),"、",(0,h.jsx)(e.a,{href:"https://github.com/zaach/jsonlint",target:"_blank",rel:"noopener noreferrer",children:"jsonlint"})," 不全支持 watch 模式，这里我们需要借助 ",(0,h.jsx)(e.a,{href:"https://github.com/Qard/onchange",target:"_blank",rel:"noopener noreferrer",children:"onchange"})," 工具包来实现，onchange 可以方便的让我们在文件被修改、添加、删除时运行需要的命令。"]}),"\n",(0,h.jsxs)(e.h3,{id:"1-安装项目依赖",children:["1. 安装项目依赖",(0,h.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-安装项目依赖",children:"#"})]}),"\n",(0,h.jsx)(e.p,{children:"使用如下命令安装 onchange 到项目依赖中："}),"\n",(0,h.jsx)(e.pre,{children:(0,h.jsx)(e.code,{className:"language-shell",children:"npm i onchange -D\n# npm install onchange --save-dev\n# yarn add onchange -D\n"})}),"\n",(0,h.jsxs)(e.h3,{id:"2-添加-npm-script",children:["2. 添加 npm script",(0,h.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-添加-npm-script",children:"#"})]}),"\n",(0,h.jsx)(e.p,{children:"按照如下提示添加 watch:lint 和 watch 两个子命令："}),"\n",(0,h.jsx)(e.pre,{children:(0,h.jsx)(e.code,{className:"language-patch",children:'+    "watch": "npm-run-all --parallel watch:*",\n+    "watch:lint": "onchange -i \\"**/*.js\\" \\"**/*.less\\" -- npm run lint",\n     "watch:test": "npm t -- --watch",\n'})}),"\n",(0,h.jsx)(e.p,{children:"关于改动的几点说明："}),"\n",(0,h.jsxs)(e.ul,{children:["\n",(0,h.jsxs)(e.li,{children:[(0,h.jsx)(e.code,{children:"watch:lint"})," 里面的文件匹配模式可以使用通配符，但是模式两边使用了转义的双引号，这样是跨平台兼容的；"]}),"\n",(0,h.jsxs)(e.li,{children:[(0,h.jsx)(e.code,{children:"watch:lint"})," 里面的 ",(0,h.jsx)(e.code,{children:"-i"})," 参数是让 onchange 在启动时就运行一次 ",(0,h.jsx)(e.code,{children:"--"})," 之后的命令，即代码没变化的时候，变化前后的对比大多数时候还是有价值的；"]}),"\n",(0,h.jsx)(e.li,{children:"watch 命令实际上是使用了 npm-run-all 来运行所有的 watch 子命令；"}),"\n"]}),"\n",(0,h.jsxs)(e.blockquote,{children:["\n",(0,h.jsxs)(e.p,{children:[(0,h.jsx)(e.strong,{children:"TIP#15"}),"：有没有好奇过 onchange 是怎么实现文件系统监听的？所有的魔法都藏在它的源代码里面，实际上它使用了跨平台的文件系统监听包 ",(0,h.jsx)(e.a,{href:"https://github.com/paulmillr/chokidar",target:"_blank",rel:"noopener noreferrer",children:"chokidar"}),"，基于它，你能做点什么有意思的事情呢？"]}),"\n"]}),"\n",(0,h.jsx)(e.p,{children:"onchange 有个不太醒目的特性是，文件系统发生变化之后，他在运行指定命令之前输出哪个文件发生了哪些变化，如下图红框中的内容："}),"\n",(0,h.jsx)(e.p,{children:(0,h.jsx)(e.img,{src:"https://user-gold-cdn.xitu.io/2017/12/12/160481d04f4e2aa5?w=951&h=533&f=png&s=77037",alt:""})}),"\n",(0,h.jsx)(e.p,{children:"读到这里，有没有觉得 onchange 可以和 gulp、grunt 的 watch 一样强大。"}),"\n",(0,h.jsxs)(e.blockquote,{children:["\n",(0,h.jsx)(e.p,{children:"除了上面的单测重跑和代码检查之外，你还有什么需求需要放在 onchange 里面？欢迎留言讨论。"}),"\n"]}),"\n",(0,h.jsx)(e.hr,{}),"\n",(0,h.jsxs)(e.blockquote,{children:["\n",(0,h.jsxs)(e.p,{children:["本节用到的代码见 ",(0,h.jsx)(e.a,{href:"https://github.com/wangshijun/automated-workflow-with-npm-script/tree/09-run-npm-script-with-onchange",target:"_blank",rel:"noopener noreferrer",children:"GitHub"}),"，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 ",(0,h.jsx)(e.code,{children:"09-run-npm-script-with-onchange"}),"。"]}),"\n"]}),"\n",(0,h.jsx)(e.hr,{})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,h.jsx)(e,{...n,children:(0,h.jsx)(c,{...n})}):c(n)}let i=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["%E7%94%A8%20npm%20script%20%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%2F10%E5%AE%9E%E6%88%98%E7%AF%87%2001%EF%BC%9A%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%8F%98%E5%8C%96%E5%B9%B6%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%20npm%20script.md"]={toc:[{text:"单元测试自动化",id:"单元测试自动化",depth:2},{text:"代码检查自动化",id:"代码检查自动化",depth:2},{text:"1. 安装项目依赖",id:"1-安装项目依赖",depth:3},{text:"2. 添加 npm script",id:"2-添加-npm-script",depth:3}],title:"10实战篇 01：监听文件变化并自动运行 npm script",headingTitle:"10实战篇 01：监听文件变化并自动运行 npm script",frontmatter:{}}}}]);