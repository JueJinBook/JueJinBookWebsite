"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["91564"],{745269:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var c=r(552676),i=r(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"第05章基础篇electron跨平台兼容性措施",children:["第05章—基础篇：Electron跨平台兼容性措施",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第05章基础篇electron跨平台兼容性措施",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"\uFEFF## 前言\n尽管 Electron 在跨平台方面表现出色，但不同平台间细微差异依然存在。仅仅通过单一平台下的测试无法充分证明应用的健壮性（当然，若只为特定平台开发则另当别论）。因此，在针对不同发布平台时，我们需要采取兼容性措施。"}),"\n",(0,c.jsx)(n.p,{children:"据我个人感受，macOS 支持的特性相对更丰富，其中许多是独有的。因此，某些能够在 macOS 上实现的功能并不一定能在 Windows 上完全呈现。针对 Windows 用户，在确保整体应用可用性的前提下，可能需要做出一些妥协和调整。不过，Windows 平台上的操作习惯也可以反过来服务 macOS 平台。"}),"\n",(0,c.jsxs)(n.p,{children:["因此，有必要花一小节的篇幅，为大家说明一下 ",(0,c.jsx)(n.code,{children:"Electron"})," 在不同平台下，一些常见的兼容性问题以及如何做好一些兼容性措施。"]}),"\n",(0,c.jsxs)(n.h2,{id:"electron-native-api-的平台限制",children:["Electron Native API 的平台限制",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#electron-native-api-的平台限制",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在开发 Electron 应用时，我们常常只专注于查找 API 的名称，而忽略了该 API 可用的平台限制。在官方文档中，针对一些独占的 API，通常会有标识来指明它们的适用平台，比如 macOS 下，",(0,c.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/app",target:"_blank",rel:"noopener noreferrer",children:"Electron app 模块"}),"独有的一些钩子函数："]}),"\n",(0,c.jsx)(n.p,{children:"这些钩子函数因为和操作系统底层相关，所以有些只有特殊的平台才会有。也有些是特殊平台才具有的功能性 API："}),"\n",(0,c.jsxs)(n.p,{children:["在这些特殊平台才具有的功能 API 或钩子函数中，Electron 官方都会通过 ",(0,c.jsx)(n.code,{children:"tag"})," 标签为我们标注清楚，我们只需要注意使用即可。不过需要注意的是，还有一些未有平台 ",(0,c.jsx)(n.code,{children:"tag"})," 标识的 API 里的配置项、或者通用的配置项，不同平台的值和具体表现可能也有差异："]}),"\n",(0,c.jsx)(n.p,{children:"所以，当你在使用这些 API 和钩子函数的时候，需要多多留意这些差异，避免出现不符合预期的 bug。"}),"\n",(0,c.jsxs)(n.h2,{id:"操作系统天然的差异性",children:["操作系统天然的差异性",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#操作系统天然的差异性",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["虽然 ",(0,c.jsx)(n.code,{children:"Electron"})," 的 ",(0,c.jsx)(n.code,{children:"API"})," 帮助我们解决了跨平台的绝大多数场景的问题，但是因为操作系统本身存在着天然的差异性，所以在面对一些 ",(0,c.jsx)(n.code,{children:"Electron"})," 不提供的原生 ",(0,c.jsx)(n.code,{children:"API"})," 时，我们就不得不考虑不同平台的差异性问题。"]}),"\n",(0,c.jsxs)(n.p,{children:["比如，当我们使用 ",(0,c.jsx)(n.code,{children:"C++"})," 编写原生 ",(0,c.jsx)(n.code,{children:"node addon"})," 开发的时候，为了实现不同平台的能力，需要编写兼容性代码："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'// binding.gyp\n{\n  "targets": [\n    {\n      "cflags!": ["-fno-exceptions"],\n      "cflags_cc!": ["-fno-exceptions"],\n      "defines": ["NAPI_DISABLE_CPP_EXCEPTIONS"],\n      "target_name": "addon",\n      "include_dirs": ["<!(node -p \\"require(\'node-addon-api\').include_dir\\")"],\n      "sources": ["export.cc"],\n      "conditions": [\n        [\n          \'OS=="mac"\',\n          {\n            // ...\n          }\n        ],\n        [\n          \'OS=="win"\',\n          {\n            // ...\n          }\n        ]\n      ]\n    }\n  ]\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"就算我们可能用不到底层原生模块来编写跨平台的扩展，而当我们用 js 来调用不同系统的能力时，也需要编写一些兼容性代码来进行适配："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let action;\n// 判断当前平台\nconst platform = {\n  linux() {\n    return process.platform === 'linux';\n  },\n  macOS() {\n    return process.platform === 'darwin';\n  },\n  windows() {\n    return process.platform === 'win32';\n  },\n};\n// 平台判断\nif (platform.macOS()) {\n  action = require(\"./darwin\");\n} else if (platform.windows()) {\n  action = require(\"./win\");\n} else if (platform.linux()) {\n  action = require(\"./linux\");\n}\n\nexport default action;\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"用户习惯的差异性",children:["用户习惯的差异性",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用户习惯的差异性",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们知道在桌面端，",(0,c.jsx)(n.code,{children:"macOS"})," 和 ",(0,c.jsx)(n.code,{children:"Windows"})," 有着特别多的操作差异性，比如在窗口管理上，Windows 用户习惯使用最大化、最小化和关闭窗口的按钮，而 macOS 用户则通常使用红、黄、绿色的按钮分别表示关闭、最小化和全屏。"]}),"\n",(0,c.jsxs)(n.p,{children:["除此之外，在 ",(0,c.jsx)(n.code,{children:"macOS"})," 中，即使所有窗口关闭了，应用仍然在底部的菜单栏中保持活动状态。因此，通常需要特殊处理以确保用户主动退出应用程序。而在其他平台（如 Windows 或 Linux）中，通常情况下关闭最后一个窗口也意味着退出应用程序是合理的行为。所以为了实现这个操作习惯，我们也可以增加一个情况判断："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 当窗口都被关闭了\napp.on('window-all-closed', () => { \n  // 如果不是macOS\n  if (process.platform !== 'darwin') {\n    // 应用退出\n    app.quit();\n  }\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["除此之外，我们还知道，不同操作系统对于一些常用功能的键盘快捷键可能有所不同，比如复制、粘贴、撤销等，Windows 中使用的 ",(0,c.jsx)(n.code,{children:"Ctrl"})," 作为修饰键，而 ",(0,c.jsx)(n.code,{children:"macOS"})," 中是使用的 ",(0,c.jsx)(n.code,{children:"Command"})," 作为修饰键。所以，当我们需要注册此类快捷键的时候，需要注意使用 ",(0,c.jsx)(n.code,{children:"CommandOrControl+xx"})," 关键词："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"globalShortcut.register('CommandOrControl+X', () => {\n    // todo\n});\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"文件路径的差异",children:["文件路径的差异",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#文件路径的差异",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["需要留意的是在 Electron 的通用 ",(0,c.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/app#appgetpathname",target:"_blank",rel:"noopener noreferrer",children:"app.getPath"})," API 中，获取的返回路径是有差异性的，比如："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import { app } from 'electron';\n// 获取用户的应用程序数据目录\napp.getPath('appData');\n\n// MacOS: ~/Library/Application Support/<Your App Name>\n// Windows: C:\\Users\\<you>\\AppData\\Local\\<Your App Name>\n// Linux: ~/.config/<Your App Name>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["此外，在 Windows 下，文件路径的分隔符为 ",(0,c.jsx)(n.code,{children:"\\"}),"、",(0,c.jsx)(n.code,{children:"\\\\"}),"，而在 macOS 和 Linux 下，文件路径的分隔符为 ",(0,c.jsx)(n.code,{children:"/"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["所以，如果我们在 MacOS 系统上编写了操作路径的应用程序，放到 Windows 上去运行，就有可能因为路径而出现问题。正确的做法是使用\xa0",(0,c.jsx)(n.code,{children:"path"}),"\xa0模块，帮助处理路径，比如使用 ",(0,c.jsx)(n.code,{children:"path.join"})," 方法来拼接路径："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const path = require('path')\n\n// windows __dirname = D:\\my\\folder\nconst relativePath = './image/a.png';\nconsole.log(path.join(__dirname, relativePath)); // D:\\my\\folder\\image\\a.png\n\n// macOS __dirname = /my/folder\nconst relativePath = './image/a.png';\nconsole.log(path.join(__dirname, relativePath)); // /my/folder/image/a.png\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"托盘图标的差异",children:["托盘图标的差异",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#托盘图标的差异",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 Electron 中，应用程序可以通过 ",(0,c.jsx)(n.code,{children:"Tray"})," 类来创建托盘图标。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"let icon;\nif (commonConst.macOS()) {\n  icon = './icons/iconTemplate@2x.png';\n} else if (commonConst.windows()) {\n  icon =\n    parseInt(os.release()) < 10\n      ? './icons/icon@2x.png'\n      : './icons/icon.ico';\n} else {\n  icon = './icons/icon@2x.png';\n}\nconst appIcon = new Tray(path.join(__static, icon));\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在代码中，有三种图标：",(0,c.jsx)(n.code,{children:"iconTemplate@2x.png"}),"、",(0,c.jsx)(n.code,{children:"icon.ico"})," 和 ",(0,c.jsx)(n.code,{children:"icon@2x.png"}),"。其中",(0,c.jsx)(n.code,{children:"iconTemplate@2x.png"})," 用于在 macOS 中显示模板图标，而 ",(0,c.jsx)(n.code,{children:"icon@2x.png"})," 用于在 ",(0,c.jsx)(n.code,{children:"Windows < 10"})," 以及 ",(0,c.jsx)(n.code,{children:"Linux"})," 操作系统中显示图标。",(0,c.jsx)(n.code,{children:"icon.ico"})," 用于在 ",(0,c.jsx)(n.code,{children:"Windows >= 10"})," 的操作系统中展示。"]}),"\n",(0,c.jsx)(n.p,{children:"在 macOS 使用 Template 时："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["传给托盘构造函数的图标必须是",(0,c.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/native-image#template-image",target:"_blank",rel:"noopener noreferrer",children:"图片模板"}),"\xa0。"]}),"\n",(0,c.jsxs)(n.li,{children:["为了确保你的图标在视网膜监视器不模糊，请确认你的\xa0",(0,c.jsx)(n.code,{children:"@2x"}),"\xa0图片是 144dpi 。"]}),"\n",(0,c.jsxs)(n.li,{children:["如果你正在打包你的应用程序（例如，使用 webpack 开发），请确保文件名没有被破坏或哈希。文件名需要以 Template 单词结尾，同时\xa0",(0,c.jsx)(n.code,{children:"@2x"}),"\xa0图片需要与标准图片文件名相同，否则 MacOS 不会神奇地反转图片的颜色或使用高分图片。"]}),"\n",(0,c.jsx)(n.li,{children:"16x16 (72dpi) 和 32x32@2x (144dpi) 适合大多数图标。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"在 Windows 上使用 icon 时注意："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["建议使用\xa0",(0,c.jsx)(n.code,{children:"ICO"}),"\xa0图标获取最佳视觉效果。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"应用程序上的差异",children:["应用程序上的差异",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#应用程序上的差异",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 macOS 中，未签名的应用可能会面临一些安全提示和限制。其中一个问题是在安装前需要用户确认并授权运行该应用。这是 macOS 的安全特性，用以确保用户知晓并授权运行未签名的应用程序，关于如何对 Electron 应用程序签名和公正可以在 ",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7302990019642261567/section/7304842389166751754",target:"_blank",rel:"noopener noreferrer",children:"《通用篇：Electron 应用打包》"})," 章节详细阅读。"]}),"\n",(0,c.jsx)(n.p,{children:"另一种处理方式是，在终端运行以下指令："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-shell",children:"sudo spctl --master-disable // 关闭限制，安装前运行一次即可\n"})}),"\n",(0,c.jsx)(n.p,{children:"另一个则是在 Mac M1、M2 系统架构中，安装后打开会提示文件已损坏。"}),"\n",(0,c.jsx)(n.p,{children:"该问题的处理方案并不麻烦。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-shell",children:"sudo xattr -r -d com.apple.quarantine /Applications/[your app name].app\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"申请管理员权限",children:["申请管理员权限",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#申请管理员权限",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 Windows 中，如果软件需要管理员权限运行，只需要在打包时声明",(0,c.jsx)(n.code,{children:"requestedExecutionLevel"})," 为 ",(0,c.jsx)(n.code,{children:"requireAdministrator"}),"。这将弹出一个 UAC 提示框，请求用户授予管理员权限运行软件。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"// 打包配置\nelectronBuilder: {\n  win: {\n    requestedExecutionLevel: 'requireAdministrator',\n  }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"而在 macOS 和 Linux 下，如果需要软件以 root 权限运行，需要使用 sudo 命令来获取权限。具体来说，可以使用以下命令运行软件，并输入 sudo 密码："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-shell",children:"sudo /path/to/your/app/executable\n"})}),"\n",(0,c.jsxs)(n.p,{children:["当然这种方式不是很好，推荐在需要输入指令时再调用 sudo 密码确认框。当然，如果你需要单独申请 ",(0,c.jsx)(n.code,{children:"Mac"})," 上的特定权限，比如 ",(0,c.jsx)(n.code,{children:"文件夹访问"}),"、",(0,c.jsx)(n.code,{children:"屏幕录制"})," 权限等等，也可以试试这个库：",(0,c.jsx)(n.a,{href:"https://github.com/codebytere/node-mac-permissions",target:"_blank",rel:"noopener noreferrer",children:"node-mac-permissions"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["本小节，我们可以通过管中窥豹的形式了解了 ",(0,c.jsx)(n.code,{children:"Electron"})," 在开发跨平台应用时需要注意到的一些兼容性问题，文中列举的都是一些较为常见的兼容性问题和解决方案，如果你也遇到了类似的问题，希望可以对你有启发和帮助！"]}),"\n",(0,c.jsxs)(n.p,{children:["在接下来的章节内容，你也会发现在实现很多功能的时候，都需要进行跨平台兼容性处理，我们也会针对用户使用最多的 ",(0,c.jsx)(n.code,{children:"Windows"})," 和 ",(0,c.jsx)(n.code,{children:"MacOS"})," 分别进行详细的跨平台兼容性处理方案介绍，相信你会有更加深刻的认知。"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(s,{...e})}):s(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC05%E7%AB%A0%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9AElectron%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E6%8E%AA%E6%96%BD.md"]={toc:[{text:"Electron Native API 的平台限制",id:"electron-native-api-的平台限制",depth:2},{text:"操作系统天然的差异性",id:"操作系统天然的差异性",depth:2},{text:"用户习惯的差异性",id:"用户习惯的差异性",depth:2},{text:"文件路径的差异",id:"文件路径的差异",depth:2},{text:"托盘图标的差异",id:"托盘图标的差异",depth:2},{text:"应用程序上的差异",id:"应用程序上的差异",depth:2},{text:"申请管理员权限",id:"申请管理员权限",depth:2},{text:"总结",id:"总结",depth:2}],title:"第05章—基础篇：Electron跨平台兼容性措施",headingTitle:"第05章—基础篇：Electron跨平台兼容性措施",frontmatter:{}}}}]);