"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["52399"],{114248:function(e,n,d){d.r(n),d.d(n,{default:()=>B});var s=d(552676),c=d(740453);let r=d.p+"static/image/bc15bf404fd64093bbafa18cb2c4425b.15cc10b1.webp",i=d.p+"static/image/b9731504dd7ea2f1be02aa5bcf0565c0.2fe1cc22.webp",o=d.p+"static/image/5a821a82159cd4015a66a627585c5c3c.c5d3d21d.webp",a=d.p+"static/image/7e07f785e566f9d9ffc54bff66edf104.7b8ec501.webp",p=d.p+"static/image/07ce4d65139d77521d5ae57c11ade849.4d3245b6.webp",l=d.p+"static/image/74a2d7a14813f3f1e9e123e8b71ec83b.344f0605.webp",t=d.p+"static/image/c27d3ba4f1567585f1166164db6e7694.f6b21e58.webp",h=d.p+"static/image/0cc86005009e7a4424afe2a599502149.01790f63.webp",j=d.p+"static/image/a74932bda2b0214359c09c21817ac0ff.9f7db437.webp",x=d.p+"static/image/a0bb53e65214ac1eba0adddf1548a296.ee192be1.webp",b=d.p+"static/image/927d08367fad9addf397a22af596f71c.b255b04f.webp",g=d.p+"static/image/59be167724553ab6b27fe9f90c157d52.da9a0818.webp",m=d.p+"static/image/75a52dd9ca16d2563e10a12b8ade052f.629028f8.webp",f=d.p+"static/image/c89bff097ae6458eeec8dc6560644a8d.8a3509ba.webp",u=d.p+"static/image/4d926d3fa36b3668e85f983ecf3452cd.25ffde43.webp",C=d.p+"static/image/a92caa271aef08c845c8dbc0ac7f1db1.4cb96670.webp",v=d.p+"static/image/8e7fe3f117c71102e332a15ef6b52863.e30d9e92.webp",w=d.p+"static/image/ef8d5ebc783957c0bb0490942d89aa37.66269310.webp",D=d.p+"static/image/ca540fe14a1543f7a8acc4e90b7d2c08.ab72af15.webp",N=d.p+"static/image/85ad343414bb78dd906ac472fee9c893.1c600182.webp",S=d.p+"static/image/9b4333aeca6cdbfefbc28ac54ae6b7ff.7d63e50f.webp",E=d.p+"static/image/5cb6576a4110df107e594030507a515d.b7a4125b.webp",V=d.p+"static/image/e722fcc5ea0652300bcc5f8502e52566.3e99faff.webp",k=d.p+"static/image/226187e6a3d0eb27e09aead2de843ae9.eb43bd8b.webp",P=d.p+"static/image/83c300b2bf98b1074408fb76e35aec40.eef02e94.webp",T=d.p+"static/image/92909021c1f058b11bcdba46c823a7da.c8a56a6e.webp";function A(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"13如何调试-nodejs-代码",children:["13.如何调试 Node.js 代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13如何调试-nodejs-代码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"学会了网页里 JS 的调试，我们再来学下 Node.js 代码的调试。"}),"\n",(0,s.jsx)(n.p,{children:"我们准备一段 Node.js 的代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const fs = require('fs/promises');\n\n(async function() {\n    const fileContent = await fs.readFile('./package.json', {\n        encoding: 'utf-8'\n    });\n    \n    await fs.writeFile('./package2.json', fileContent);\n})();\n"})}),"\n",(0,s.jsx)(n.p,{children:"就是简单的文件读写，先用 node index.js 跑一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后以调试模式启动，加个 --inspect-brk 参数："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"node --inspect-brk ./index.js\n"})}),"\n",(0,s.jsx)(n.p,{children:"--inspect 是以调试模式启动，--inspect-brk 是以调试模式启动并且在首行断住。"}),"\n",(0,s.jsx)(n.p,{children:"然后你就会发现它打印了 ws 的地址："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是调试的服务端。"}),"\n",(0,s.jsx)(n.p,{children:"接下来找个对接它的调试协议的客户端连上就行了。"}),"\n",(0,s.jsx)(n.p,{children:"Node.js 可以用 Chrome DevTools 来调试："}),"\n",(0,s.jsxs)(n.h2,{id:"用-chrome-devtools-调试-node-代码",children:["用 Chrome DevTools 调试 node 代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用-chrome-devtools-调试-node-代码",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["浏览器打开 ",(0,s.jsx)(n.a,{href:"/chrome://inspect/#devices",children:"chrome://inspect/#devices"})," ，下面列出的是所有可以调试的目标，也就是 ws 服务端："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你会发现这里列出了我们启动的跑的那个 node 脚本。"}),"\n",(0,s.jsx)(n.p,{children:"这是因为我在网络端口里加上了 node 的 ws 调试服务的端口："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:V,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"node 调试服务默认是跑在 9229 端口，但是也可以换："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"只要把它的端口加入到配置里就可以了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"点击 inspect 就可以调试这个 node 脚本了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但是这样也是和调试网页一样的问题，在 Chrome DevTools 里调试，在 VSCode 里写代码，这俩是分离开的，切来切去也挺不方便的。"}),"\n",(0,s.jsx)(n.p,{children:"那 VSCode 能不能调试 node 代码呢？"}),"\n",(0,s.jsx)(n.p,{children:"明显是可以的："}),"\n",(0,s.jsxs)(n.h2,{id:"用-vscode-debugger-调试-node-代码",children:["用 VSCode Debugger 调试 node 代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用-vscode-debugger-调试-node-代码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们创建 .vscode/launch.json 的调试配置文件："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"添加一个 node 类型的 attach 的调试配置："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"端口改成 ws 服务启动的端口 8888:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后点击 debug 启动："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"VSCode Debugger 就会连接上 8888 的调试端口开始调试，可以边调试边修改代码。"}),"\n",(0,s.jsx)(n.p,{children:"能调试还能修改代码，这是比 Chrome DevTools 更好用的地方，因此我们一般使用 VSCode Debugger 来调试 Node.js 代码的。"}),"\n",(0,s.jsx)(n.p,{children:"有的同学可能会说，每次都要先 node --inspect xxx.js 把调试服务跑起来，然后再手动 attach，比较麻烦。能不能自动做呢？"}),"\n",(0,s.jsx)(n.p,{children:"当然是可以的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"创建调试配置的时候选择 launch program，指定 program 的路径："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"VSCode Debugger 就会自动以调试模式跑这个 node 脚本，并且自动 attach 上："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样就方便多了。"}),"\n",(0,s.jsx)(n.p,{children:"如果你也想首行断住，可以加一个 stopOnEntry 的配置："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"和 node --inspect-brk 启动一样的效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"回过头来我们看一下，为什么 VSCode Debugger 和 Chrome DevTools 都可以调试 node 代码呢？"}),"\n",(0,s.jsx)(n.p,{children:"这是因为都对接了 node 的调试协议，只是实现了各自的 UI："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"有的同学可能会问，为啥图上画的是 Chrome Devtools Protocol 呢？node 也是用 CDP 作为调试协议么？"}),"\n",(0,s.jsx)(n.p,{children:"确实，node 也是基于 CDP 调试的。"}),"\n",(0,s.jsx)(n.p,{children:"至于为什么要用 CDP 来调试 node 代码，这就涉及到一段历史了："}),"\n",(0,s.jsxs)(n.h2,{id:"node-debugger-的历史",children:["node debugger 的历史",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#node-debugger-的历史",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们知道 Node.js 是基于 V8 的，V8 本身有调试协议 V8 Debug Protocol，所以 Node.js 最早的调试协议也就是 V8 Debug Protocol。"}),"\n",(0,s.jsx)(n.p,{children:"当时调试是这样的："}),"\n",(0,s.jsx)(n.p,{children:"通过 node debug 来跑 js 文件，会在首行断住："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后可以通过 run、cont、next、step 等命令来实现单步调试，通过 backtrace 打印调用栈，通过 setBreakPoint 等设置断点："}),"\n",(0,s.jsx)(n.p,{children:"比如用 setBreakPoint（sb）命令在第四行打个断点："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后 cont(c) 命令继续执行，backtrace(bt) 打印调用栈："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"虽然该有的调试功能都有，但是这样调试还是比较费劲的。"}),"\n",(0,s.jsx)(n.p,{children:"怎么能不用命令行调试，而是用 UI 来调试呢？"}),"\n",(0,s.jsx)(n.p,{children:"当时 Node 就瞄准了 Chrome DevTools，它的调试 UI 就很不错。"}),"\n",(0,s.jsx)(n.p,{children:"但是 Chrome DevTools 的调试协议是 Chrome DevTools Protocol，和 V8 Debug Protocol 还是有些差距的，怎么能用上 Chrome DevTools 的调试工具来调试 Node 呢？"}),"\n",(0,s.jsx)(n.p,{children:"其实还挺容易想到的，就是加一个中间的服务来做转换："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个服务是 node-inspector 这个包提供的。"}),"\n",(0,s.jsx)(n.p,{children:"所以当时 node debug 服务跑起来之后，还要要再跑一个 node-inspector 服务，这样才能用 chrome devtools 来调试 Node.js 代码。"}),"\n",(0,s.jsx)(n.p,{children:"后来维护 Node.js 的那些人觉得这样也太麻烦了，要不让 Node.js 提供的调试协议就直接就是兼容 Chrome Devtools Protocol 的吧。"}),"\n",(0,s.jsx)(n.p,{children:"当时就有了这样一个 pr，把 v8 inspector 集成到 Node.js 中："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个 v8 inspector 就是从 chrome 的内核 blink 里剥离出来的让 v8 支持 chrome devtools protocol 的部分。"}),"\n",(0,s.jsx)(n.p,{children:"很明显这需要 v8 团队的配合，所以说 Node.js 的发展还是很依赖 v8 团队的支持的。"}),"\n",(0,s.jsx)(n.p,{children:"之后 Node.js 就在 v6.3 中加入了这个功能："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"并且在成熟之后去掉了对 v8 debug protocol 的支持，也就是废弃了 node debug 命令，改为了 node inspect。"}),"\n",(0,s.jsx)(n.p,{children:"启动 ws 调试服务的方式就是 node --inspect 或者 node --inspect-brk。"}),"\n",(0,s.jsx)(n.p,{children:"当然，之前作为两个协议的中转的服务 node-inspector 也就退出了历史舞台。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"所以今天，我们可以轻易的用 Chrome DevTools 来调试 Node.js 代码。"}),"\n",(0,s.jsx)(n.p,{children:"当然，这里只是说 Chrome DevTools 调试 Node.js，在 VSCode 里调试 Node.js 的话还要做一些额外的处理："}),"\n",(0,s.jsx)(n.p,{children:"调试的原理我们已经知道了，就是 ws 客户端和服务器的通信，然后基于调试协议来完成不同的功能。Node.js 是这样，其他语言也是这样。"}),"\n",(0,s.jsx)(n.p,{children:"VSCode 是一个通用的编辑器，是要支持多种语言的，也就是它的调试 UI 要支持多种调试协议。"}),"\n",(0,s.jsx)(n.p,{children:"要同一个调试工具同时支持不同的协议有点不太现实，那怎么办呢？"}),"\n",(0,s.jsx)(n.p,{children:"可以加一个中间层，VSCode 的调试 UI 只要支持这个中间的调试协议就可以了，其余的调试协议适配到这个调试协议上来："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是 DAP 协议，debugger adpater protocol。"}),"\n",(0,s.jsx)(n.p,{children:"Node.js 在把调试工具的协议换成 Chrome Devtools Protocol 之后，只要实现个 DAP 的 adapter 就可以对接到 VSCode 的调试工具了。"}),"\n",(0,s.jsx)(n.p,{children:"这样我们就可以在 VSCode 里调试 Node.js 了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们分别用 Chrome DevTools 和 VSCode Debugger 调试了下 node 代码："}),"\n",(0,s.jsx)(n.p,{children:"用 node --inspect 或 node --inspect-brk 以调试模式跑 node 脚本，然后用调试的 UI 连接上这个调试服务就可以进行调试了。"}),"\n",(0,s.jsx)(n.p,{children:"在 VSCode Debugger 里调试 node 代码还可以边调试边修改，更方便。"}),"\n",(0,s.jsx)(n.p,{children:"除了自己启动 node 调试服务，然后手动 attach 外，还可以选择 launch 类型的调试配置，自动进行这个过程。"}),"\n",(0,s.jsx)(n.p,{children:"node 调试的协议也是用的 Chrome DevTools Protocol，就是为了能够复用 Chrome DevTools 的 UI 的，中间还有一段历史是用 node inspector 做中转。"}),"\n",(0,s.jsx)(n.p,{children:"学会了调试 node 代码，各种命令行工具、node 服务，我们就都可以调试了。"})]})}function _(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(A,{...e})}):A(e)}let B=_;_.__RSPRESS_PAGE_META={},_.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F13.%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%20Node.js%20%E4%BB%A3%E7%A0%81.md"]={toc:[{text:"用 Chrome DevTools 调试 node 代码",id:"用-chrome-devtools-调试-node-代码",depth:2},{text:"用 VSCode Debugger 调试 node 代码",id:"用-vscode-debugger-调试-node-代码",depth:2},{text:"node debugger 的历史",id:"node-debugger-的历史",depth:2},{text:"总结",id:"总结",depth:2}],title:"13.如何调试 Node.js 代码",headingTitle:"13.如何调试 Node.js 代码",frontmatter:{}}}}]);