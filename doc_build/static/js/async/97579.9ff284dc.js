"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["97579"],{638450:function(n,e,r){r.r(e),r.d(e,{default:()=>x});var s=r(552676),i=r(740453);let t=r.p+"static/image/11d77d546c456a52463ffa38f7f174be.35e1111c.webp",d=r.p+"static/image/f2722453cb26361934a6d5471dd2866e.84ce2df2.webp",l=r.p+"static/image/350d4e66b10111b01fda016fabfa4dd8.985bfc7c.webp",c=r.p+"static/image/7dcec7de4f846333596a08ad524ac675.148adf27.webp",o=r.p+"static/image/8e9a9b7bcc969abb52e66291c35662a9.b119247a.webp",h=r.p+"static/image/f547b4f15e77a161e15d162c8569cd7f.0c360a5f.webp";function a(n){let e=Object.assign({p:"p",strong:"strong",ul:"ul",li:"li",h2:"h2",a:"a",img:"img",pre:"pre",code:"code",ol:"ol"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.p,{children:["大多数低代码平台都会支持维护者用",(0,s.jsx)(e.strong,{children:"ProCode"}),"(源代码开发)的方式继续维护项目，通常这个过程是单向的，不论是",(0,s.jsx)(e.strong,{children:"WebIDE"}),"还是导出本地项目，其本质是将现有的",(0,s.jsx)(e.strong,{children:"DSL"}),"\xa0",(0,s.jsx)(e.strong,{children:"Schema"}),"转换为具体的前端工程代码，这个过程并不是特别复杂。"]}),"\n",(0,s.jsxs)(e.p,{children:["对于",(0,s.jsx)(e.strong,{children:"ProCode"}),"而言，，我们需要准备相关的一些能力的一些工具环境和开发。"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"模版工程"}),"：一个标准化的模版工程，与本地开发项目类似，提前初始化了一系列项目所需的文件内容，后续只要把低代码的内容往里面填充。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"任务执行"}),"：执行",(0,s.jsx)(e.strong,{children:"ProCode"}),"生成的执行单元，对于每个任务的构建和",(0,s.jsx)(e.strong,{children:"DSL水合"}),"都是在其完成的，这一步使用",(0,s.jsx)(e.strong,{children:"Jenkins"}),"来进行工程的水合编排。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"模板引擎"}),"：使用模板引擎，将",(0,s.jsx)(e.strong,{children:"DSL Schema"}),"渲染成前端可用的代码，其目的主要是保存的DSL协议数据填充到字符串模板引擎的坑位当中去。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"CLI"}),"：提供整个链路的",(0,s.jsx)(e.strong,{children:"代码生成"}),"，",(0,s.jsx)(e.strong,{children:"模版拉取"}),"，",(0,s.jsx)(e.strong,{children:"产物构建"}),"，",(0,s.jsx)(e.strong,{children:"产物上传"}),"等编排中必要的步骤内容。"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"模板工程",children:["模板工程",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模板工程",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"模板工程是出码过程成不可或缺的模型措施，后面协议生成的组件代码和页面代码会将其放在约定的目录当中。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"routes"}),"：每个编辑器都是一个页面，对于项目来说其实就是相当于一个路由，因此站点的目录信息会被抽象成对应的路由配置。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"pages"}),": 搭建的页面代码会根据",(0,s.jsx)(e.strong,{children:"页面Id"}),"相对应的存放在此处，与",(0,s.jsx)(e.strong,{children:"routes"}),"进行关联。运行时渲染通过Id加载不同的协议，",(0,s.jsx)(e.strong,{children:"ProCode"}),"则是生成出不同的页面。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"queries：数据源"}),"的查询接口配置会被转换成对应的本地代码存放在此处，"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"locales："})," 正常模式下多语言文案都是在远程存储的，方便维护人员进行修正，但如果项目复杂性不高，且属于短期或者临时演示工程，可以将其一起构建到工程本身进行维护。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["参考之前初始化工程的章节，部分内容和技术栈都可以沿用，其主要目的就是在",(0,s.jsx)(e.strong,{children:"Github"}),"组织上创建一个基本的模板项目，并且使用自己熟悉的",(0,s.jsx)(e.strong,{children:"脚手架CLI"}),"进行",(0,s.jsx)(e.strong,{children:"React"}),"工程的初始化。"]}),"\n",(0,s.jsx)(e.p,{children:"目录名称不固定，根据自身预期的设计可以灵活调整，其主要是为了更好的将协议转换成为本地的文件内容。"}),"\n",(0,s.jsx)(e.p,{children:"如下图所示："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(e.h2,{id:"协议转代码",children:["协议转代码",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#协议转代码",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在低代码编辑器中，我们的页面是以",(0,s.jsx)(e.strong,{children:"DSL协议"}),"存在的，如何将其转换为",(0,s.jsx)(e.strong,{children:"React TSX"}),"相关的文本内容呢？"]}),"\n",(0,s.jsx)(e.p,{children:"如下图所示："}),"\n",(0,s.jsxs)(e.p,{children:["在画布中拖放入一个组件，右侧代码板块是当前",(0,s.jsx)(e.strong,{children:"DSL"}),"映射而成的",(0,s.jsx)(e.strong,{children:"React"}),"代码，它本质上是通过模板引擎的方式把",(0,s.jsx)(e.strong,{children:"DSL"}),"通过一定的模板适配转换成为对应的字符串。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"整体的流程如下图所示："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(e.h2,{id:"模板引擎",children:["模板引擎",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模板引擎",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"在之前的章节中有提到通过nunjucks模板引擎来转换相关的数据代码。社区里面也有其他比较优秀的方案，这里做一些简单的方案罗列，本质上的使用大差不差："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"doT"}),":\xa0",(0,s.jsx)(e.a,{href:"https://olado.github.io/doT/index.html",target:"_blank",rel:"noopener noreferrer",children:"https://olado.github.io/doT/index.html"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"art-template"}),":\xa0",(0,s.jsx)(e.a,{href:"https://aui.github.io/art-template/docs/",target:"_blank",rel:"noopener noreferrer",children:"https://aui.github.io/art-template/docs/"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"mustache"}),".",(0,s.jsx)(e.strong,{children:"js"}),":\xa0\xa0",(0,s.jsx)(e.a,{href:"https://mustache.github.io/",target:"_blank",rel:"noopener noreferrer",children:"https://mustache.github.io/"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"nunjucks"}),":\xa0",(0,s.jsx)(e.a,{href:"https://mozilla.github.io/nunjucks/",target:"_blank",rel:"noopener noreferrer",children:"https://mozilla.github.io/nunjucks/"})]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"如下代码所示："}),"\n",(0,s.jsx)(e.p,{children:"当选择完成对应的模板引擎库后，以nunjucks为例子声明以下的模板块，"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"name"}),": 组件的名称，在之前components中导出的resolver模块。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"props"}),": 组件的属性，props中是通过属性面板和物料默认的一些信息内容"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"children"}),": 子组件的内容，有的话需要显示，没有的话就不需要展示了。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"nodes："})," 子节点的",(0,s.jsx)(e.strong,{children:"nodeId"}),"，如果需要渲染子节点那么就需要进行一次递归"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["这几个字段的值是",(0,s.jsx)(e.strong,{children:"React"}),"构成元素方法",(0,s.jsx)(e.strong,{children:"createElement"}),"的参数，因此可以将其显示抽象为",(0,s.jsx)(e.strong,{children:"React TSX"}),"的内容文本。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"const tpl = `\n<{{ name }} \n  {% for key, value in props -%}\n    {% if key != 'children' %}\n      {{ key }}={{ transformValue(key, value) }}\n    {% endif %}\n  {% endfor -%}\n{% if props.children %}\n>\n{{props.children}}\n</{{name}}>\n{% else %}\n/>\n{% endif %}\n`;\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在模板字符串中除了渲染的数据外，还有一个",(0,s.jsx)(e.strong,{children:"transformValue"}),"方法，在前面的一些实践中，props存在有表达式和事件通信的代码，因此需要在做一些处理，也就是在",(0,s.jsx)(e.strong,{children:"transformValue"}),"中进行一些边界条件的匹配计算。"]}),"\n",(0,s.jsx)(e.p,{children:"如下代码所示："}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"transformValue"}),"接收两个参数，分别是",(0,s.jsx)(e.strong,{children:"props"}),"的",(0,s.jsx)(e.strong,{children:"key"}),"和",(0,s.jsx)(e.strong,{children:"value"}),"。边界的处理参数以下规则："]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["字符串内容显示为：",(0,s.jsx)(e.strong,{children:'key="value"。'})]}),"\n",(0,s.jsxs)(e.li,{children:["非字符串内容显示为：",(0,s.jsx)(e.strong,{children:"key={value}，"})," 如",(0,s.jsx)(e.strong,{children:"number"}),"类型与",(0,s.jsx)(e.strong,{children:"boolean"}),"类型"]}),"\n",(0,s.jsxs)(e.li,{children:["引用类型需要转换：引用类型需要通过",(0,s.jsx)(e.strong,{children:"JSON.stringify"}),"进行转换，将一些复杂的对象和数组进行序列化。"]}),"\n",(0,s.jsxs)(e.li,{children:["表达式：表达式的内容是通过 ",(0,s.jsx)(e.strong,{children:"$$jsx"}),"特殊字段判断的，所以将其处理为直接返回。"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'transformValue: (_: string, v: any) => {\n  // 处理表达式\n  if (has(v, "$$jsx")) {\n    return `{${v.$$jsx}}`;\n  }\n\n  // 字符串处理\n  if (isString(v)) {\n    return JSON.stringify(v);\n  }\n\n  // 序列化处理\n  return `{${JSON.stringify(v, null, 2)}}`;\n},\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"模板渲染",children:["模板渲染",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模板渲染",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["首先使用",(0,s.jsx)(e.strong,{children:"pnpm"}),"将",(0,s.jsx)(e.strong,{children:"nunjucks"}),"进行安装，如下命令所示："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"# 43.项目进阶：Pro Code 开发与产物\npnpm add nunjucks\n\npnpm add @types/nunjucks -D\n"})}),"\n",(0,s.jsxs)(e.p,{children:["安装依赖完成后，可以使用",(0,s.jsx)(e.strong,{children:"nunjucks"}),"的",(0,s.jsx)(e.strong,{children:"renderString"}),"方法将",(0,s.jsx)(e.strong,{children:"useEditor"}),"中的",(0,s.jsx)(e.strong,{children:"node"}),"数据与模板字符串进行合并渲染。整体的使用如下代码所示："]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["使用",(0,s.jsx)(e.strong,{children:"import"}),"引入",(0,s.jsx)(e.strong,{children:"nunjucks"}),"依赖"]}),"\n",(0,s.jsxs)(e.li,{children:["通过",(0,s.jsx)(e.strong,{children:"nunjucks"}),"的",(0,s.jsx)(e.strong,{children:"configure"}),"方法可以配置相关的一些处理属性。"]}),"\n",(0,s.jsx)(e.li,{children:"将上面一小节创建好的模板代码赋值给变量"}),"\n",(0,s.jsxs)(e.li,{children:["使用",(0,s.jsx)(e.strong,{children:"useEditor"}),"获取当前选中节点的",(0,s.jsx)(e.strong,{children:"DSL Schema"}),"数据"]}),"\n",(0,s.jsxs)(e.li,{children:["使用",(0,s.jsx)(e.strong,{children:"nunjucks"}),"的",(0,s.jsx)(e.strong,{children:"renderString"}),"方法将",(0,s.jsx)(e.strong,{children:"DSL Schema"}),"数据与",(0,s.jsx)(e.strong,{children:"tpl模版引擎"}),"进行融合"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"renderString"}),"返回的结果就是根据当前",(0,s.jsx)(e.strong,{children:"DSL Schema"}),"转换而来的",(0,s.jsx)(e.strong,{children:"React Tsx"}),"代码。"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:'// 引入nunjucks\nimport NJ from "nunjucks";\n\n// nunjucks配置\nNJ.configure({ autoescape: false });\n\n\n// 创建模板代码\nconst tpl = `\n<{{ name }} \n  {% for key, value in props -%}\n    {% if key != \'children\' %}\n      {{ key }}={{ transformValue(key, value) }}\n    {% endif %}\n  {% endfor -%}\n{% if props.children %}\n>\n  {{props.children}}\n</{{name}}>\n{% else %}\n/>\n{% endif %}\n`;\n\n// 获取当前组件的NodeState\nconst { nodeData } = useEditor((state) => {\n  const [currentNodeId] = state.events.selected;\n\n  if (currentNodeId) {\n    const { data } = state.nodes[currentNodeId];\n\n    return {\n      id: currentNodeId,\n      nodeData: data,\n    };\n  }\n});\n\n\n// 使用nunjucks的renderString方法\nconst str = NJ.renderString(tpl, {\n  // 这是一个示例的数据结构，nodeData的具体显示\n  "name": "__AntButton__",\n  "displayName": "按钮",\n  "props": {\n    "children": "测试文案",\n    "loading": {\n      "$$jsx": "true"\n    },\n    "block": {\n      "$$jsx": "false"\n    },\n    "danger": {\n      "$$jsx": "true"\n    }\n  },\n  "custom": {\n    "useResize": false\n  },\n  "parent": "ROOT",\n  "isCanvas": false,\n  "hidden": false,\n  "nodes": [],\n  "linkedNodes": {},\n  transformValue: (_: string, v: any) => {\n    // 表达式\n    if (has(v, "$$jsx")) {\n      return `{${v.$$jsx}}`;\n    }\n    if (isString(v)) {\n      return JSON.stringify(v);\n    }\n    return `{${JSON.stringify(v, null, 2)}}`;\n  },\n});\n\n// 输出\n\nconsole.log(str, \'当前组件的代码\')\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"代码格式化",children:["代码格式化",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码格式化",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["到此为止，已经基本上可以将",(0,s.jsx)(e.strong,{children:"DSL Schema"}),"渲染成对应的组件代码，在将\xa0",(0,s.jsx)(e.strong,{children:"DSL Schema"}),"\xa0转换为组件代码的过程中，为了提升代码的可读性和遵循代码规范，我们还需要对生成的组件代码进行格式化的处理，在",(0,s.jsx)(e.strong,{children:"Vs Code"}),"的中可以直接使用",(0,s.jsx)(e.strong,{children:"Prettier"}),"直接进行操作，那么在浏览器环境中如何进行代码的格式化呢？"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Prettier"}),"\xa0是一个流行的代码格式化工具，用于帮助开发人员自动格式化其代码，以保持一致的代码风格和格式。它不仅提供了",(0,s.jsx)(e.strong,{children:"IDE"}),"与",(0,s.jsx)(e.strong,{children:"CLI"}),"的插件支持，同样也支持浏览器运行时的代码格式化。"]}),"\n",(0,s.jsx)(e.p,{children:"如下图所示："}),"\n",(0,s.jsxs)(e.p,{children:["使用",(0,s.jsx)(e.strong,{children:"Prettier"}),"\xa0",(0,s.jsx)(e.strong,{children:"Standalone"}),"\xa0的 API 能够使用format方法通过其配置的",(0,s.jsx)(e.strong,{children:"parse"}),"插件进行对应语言的格式化。接下来就来将模板引擎转换好的代码在进行格式化操作吧。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(e.p,{children:["首先，执行如下命令先",(0,s.jsx)(e.strong,{children:"安装prettier"}),"依赖包："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"# install prettier\npnpm add prettier\n"})}),"\n",(0,s.jsx)(e.p,{children:"安装依赖完成后，如下代码所示："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["首先引入",(0,s.jsx)(e.strong,{children:"prettier"}),"下的",(0,s.jsx)(e.strong,{children:"standalone"}),"，它是",(0,s.jsx)(e.strong,{children:"prettier"}),"的独立版本，能够在",(0,s.jsx)(e.strong,{children:"CommonJS"}),"与",(0,s.jsx)(e.strong,{children:"ESM"}),"当中直接使用，无需依赖于任何特定的编辑器或集成开发环境。"]}),"\n",(0,s.jsxs)(e.li,{children:["引入",(0,s.jsx)(e.strong,{children:"prettier"}),"下",(0,s.jsx)(e.strong,{children:"plugins"}),"的",(0,s.jsx)(e.strong,{children:"babel"}),"与",(0,s.jsx)(e.strong,{children:"estree"}),"插件，后面需要用到他们的解析器功能。"]}),"\n",(0,s.jsxs)(e.li,{children:["接下来就使用",(0,s.jsx)(e.strong,{children:"prettier.format"}),"方法，传递模板字符串和对应的配置，在这里是将之前引入的babel和estree插件进行注册，同时指定对饮的",(0,s.jsx)(e.strong,{children:"parse"}),"解析器为",(0,s.jsx)(e.strong,{children:"babel"}),"。"]}),"\n",(0,s.jsxs)(e.li,{children:["执行完成后就得到了",(0,s.jsx)(e.strong,{children:"format"}),"后的代码内容，接下来就是将其展现到页面上即可。"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'import prettier from "prettier/standalone";\nimport babel from "prettier/plugins/babel";\nimport estree from "prettier/plugins/estree";\n\nconst [code, setCode] = React.useState("");\n\nconst formatCode = await prettier\n  .format(str, {\n    parser: "babel",\n    plugins: [babel, estree],\n    printWidth: 50\n  })\n\nsetCode(formatCode)\n'})}),"\n",(0,s.jsxs)(e.p,{children:["整体的",(0,s.jsx)(e.strong,{children:"ComponentToCode"}),"组件的实现如下代码所示："]}),"\n",(0,s.jsx)(e.p,{children:"目前做了最基础的实现，后续根据自身的需求来完善更多的细节。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:'import NJ from "nunjucks";\nimport React from "react";\nimport prettier from "prettier/standalone";\nimport babel from "prettier/plugins/babel";\nimport estree from "prettier/plugins/estree";\nimport { useEditor } from "@craftjs/core";\nimport { isString, has } from "lodash";\nimport { useAsyncEffect } from "ahooks";\nimport { CodeEditor } from "../common/code-editor";\n\nNJ.configure({ autoescape: false });\n\nconst tpl = `\n<{{ name }} \n  {% for key, value in props -%}\n    {% if key != \'children\' %}\n      {{ key }}={{ transformValue(key, value) }}\n    {% endif %}\n  {% endfor -%}\n{% if props.children %}\n>\n  {{props.children}}\n</{{name}}>\n{% else %}\n/>\n{% endif %}\n`;\n\nexport const ComponentDoTCode = () => {\n  const [code, setCode] = React.useState("");\n\n  const { nodeData } = useEditor((state) => {\n    const [currentNodeId] = state.events.selected;\n\n    if (currentNodeId) {\n      const { data } = state.nodes[currentNodeId];\n\n      return {\n        id: currentNodeId,\n        nodeData: data,\n      };\n    }\n  });\n\n  useAsyncEffect(async () => {\n    const str = NJ.renderString(tpl, {\n      ...nodeData,\n      transformValue: (_: string, v: any) => {\n        // 表达式\n        if (has(v, "$$jsx")) {\n          return `{${v.$$jsx}}`;\n        }\n        if (isString(v)) {\n          return JSON.stringify(v);\n        }\n        return `{${JSON.stringify(v, null, 2)}}`;\n      },\n    });\n\n    const formatCode = await prettier\n      .format(str, {\n        parser: "babel",\n        plugins: [babel, estree],\n        printWidth: 50\n      })\n\n    setCode(formatCode)\n  }, [nodeData]);\n\n  return (\n    <div\n      style={{\n        height: "100%",\n        marginInline: -8,\n      }}\n    >\n      <CodeEditor value={code} language="html" height="100%" />\n    </div>\n  );\n};\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["到此已经完成了初步的协议转代码的模式，接下来的步骤就是将整个协议进行转码化完善，同时使用Jenkins的任务编排机制来完成整个",(0,s.jsx)(e.strong,{children:"ProCode"}),"出码的预览和",(0,s.jsx)(e.strong,{children:"DevOps"}),"相关的运维和部署。"]}),"\n",(0,s.jsx)(e.p,{children:"整体的流程大体上如下："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["通过",(0,s.jsx)(e.strong,{children:"Jenkins"}),"的",(0,s.jsx)(e.strong,{children:"Git"}),"插件拉取模版工程，需要配置对应的",(0,s.jsx)(e.strong,{children:"ssh地址"}),"和",(0,s.jsx)(e.strong,{children:"机器权限token"}),"。"]}),"\n",(0,s.jsxs)(e.li,{children:["执行",(0,s.jsx)(e.strong,{children:"CLI"}),"命令，需要传递对应的站点Id来获取该站点的配置与所有页面的协议内容。"]}),"\n",(0,s.jsxs)(e.li,{children:["开始构建会将获取到的页面协议进行模版引擎的代码构建，输出到各个目录下，模板工程负责使用",(0,s.jsx)(e.strong,{children:"glob"}),"全部引入。"]}),"\n",(0,s.jsxs)(e.li,{children:["构建结束后此时的工程目录就是我们需要的产物结果了，此时可以选择打成压缩包传递到对应存储当中，比如",(0,s.jsx)(e.strong,{children:"OSS"}),"或者是机器的存储磁盘里面，后续前端页面可以通过对应的地址来预览和下载对应的内容。"]}),"\n",(0,s.jsxs)(e.li,{children:["基于",(0,s.jsx)(e.strong,{children:"ProCode"}),"出码的工程，可以提供",(0,s.jsx)(e.strong,{children:"Devops"}),"相关的服务，从而支持运行时预览与源码工程的发布部署预览。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:""})})]})}function j(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(a,{...n})}):a(n)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F43.%E9%A1%B9%E7%9B%AE%E8%BF%9B%E9%98%B6%EF%BC%9APro%20Code%20%E5%BC%80%E5%8F%91%E4%B8%8E%E4%BA%A7%E7%89%A9.md"]={toc:[{text:"模板工程",id:"模板工程",depth:2},{text:"协议转代码",id:"协议转代码",depth:2},{text:"模板引擎",id:"模板引擎",depth:2},{text:"模板渲染",id:"模板渲染",depth:2},{text:"代码格式化",id:"代码格式化",depth:2},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);