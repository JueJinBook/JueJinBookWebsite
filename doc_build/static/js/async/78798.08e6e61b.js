"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["78798"],{414943:function(e,n,s){s.r(n),s.d(n,{default:()=>c});var r=s(552676),o=s(740453);let i=s.p+"static/image/b44aec9c151076281cf10566ffcc89d8.6dd16ef0.webp",a=s.p+"static/image/4cfa705ce58c0aa94be4f169a7e53df5.8e8d6a02.webp";function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",img:"img",ol:"ol",li:"li"},(0,o.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"10具体实现browser-api-调用分析",children:["10.具体实现：Browser API 调用分析",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10具体实现browser-api-调用分析",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"代码文件中的外部依赖，不论是通过 npm 安装的第三方依赖，还是大型项目中基于 Webpack 等构建工具建立起 alias 关系的项目依赖，都是通过 Import 方式引入的。对于通过 Import 引入的 API，分析工具需要对 AST 进行两轮遍历：第一轮是针对代码文件中的 Import 节点进行遍历分析，获取从目标依赖中导出的 API 信息，第二轮针对导入的 API 进行调用判定、用途分析。"}),"\n",(0,r.jsx)(n.p,{children:"举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// 示例代码\nimport { app } from 'framework';          // 项目依赖，通过webpack alia配置指向目标仓库\nimport { clone } from 'loadsh';           // 第三方依赖，一般安装在node_modules下\n\nfunction cloneInfo (info: string) {\n    clone(info);\n}\nfunction getInfos (info: string) {\n    const result = app.get(info);                  \n    return result;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["针对上述示例代码，我们分析的目标是搞清楚从 ",(0,r.jsx)(n.code,{children:"framework"})," 导入的 ",(0,r.jsx)(n.code,{children:"app"})," 这个API 在代码中真实的调用情况。"]}),"\n",(0,r.jsxs)(n.p,{children:["但前端项目中还存在一些特殊的依赖，它们不需要通过 Import 引入，也不需要显示声明，以全局变量形式在代码中直接调用。例如 Bom API、Dom API 等这些依托于浏览器环境的 API，我们可以称它们为 ",(0,r.jsx)(n.code,{children:"Browser API"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Browser API 示例代码\n\nfunction back(){\n    history.back();                                       // history API\n}\nfunction goto(){\n    location.href = 'https://iceman.well.com';            // location API\n}\nfunction getDom(){\n    return document.getElementByld('idxxx');              // document API\n}\nfunction timeOut(name: string){                            \n    window.setTimeout(()=>{                               // window API\n        console.log(name);\n    }, 500);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"这节课，我们就来学习如何分析 Browser API。"}),"\n",(0,r.jsxs)(n.h2,{id:"browser-api-分析意义",children:["Browser API 分析意义",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#browser-api-分析意义",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"微前端架构下的巨型项目，子应用如果滥用 Browser API 可能会对其它应用或基础框架造成严重影响，沙箱方案只是针对此类问题的解决方案，但并不表示子应用代码就可以无所顾忌地使用 Browser API 了，了解代码真实的依赖调用可以主动发现、预防此类问题。"}),"\n",(0,r.jsx)(n.p,{children:"举个例子，A 应用代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// 封装setCookie\nfunction setCookie(key, value, day) {     \n    let d = new Date();     \n    d.setDate(d.getDate() + day);     \n    document.cookie = key + "=" + value + ";expires=" + d; \n}\n// 封装getCookie\nfunction getCookie(key) {     \n    let str = document.cookie;     \n    let arr = str.split("; ");\n    for (let i = 0; i < arr.length; i++) {         \n        let item = arr[i].split("=");         \n        if (item[0] == key) {             \n            return item[1];         \n        }     \n    }\n    return ";" \n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"B 应用代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"//创建cookie\nfunction creatCookie(name,value,expiresDay) {\n    var oDay = new Date();\n    oDay.setDate(oDay.getDate() + expiresDay);\n    document.cookie = name + ' = ' + value + '; expires = ' + expiresDay;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"A"}),"、",(0,r.jsx)(n.code,{children:"B"})," 两个应用各自都封装了 Cookie 处理的函数，当 ",(0,r.jsx)(n.code,{children:"A"})," 应用执行自己的 ",(0,r.jsx)(n.code,{children:"setCookie"})," 方法时传入的 key 为 ‘iceman’，然后当用户切换到 ",(0,r.jsx)(n.code,{children:"B"})," 应用后，调用 ",(0,r.jsx)(n.code,{children:"creatCookie"})," 方法时传入的 name 也为 ‘iceman’。这个时候，",(0,r.jsx)(n.code,{children:"B"})," 应用已经把 ",(0,r.jsx)(n.code,{children:"A"})," 应用设置的 cookie 给覆盖了，当用户再次切回 ",(0,r.jsx)(n.code,{children:"A"})," 应用时，调用 ",(0,r.jsx)(n.code,{children:"getCookie"})," 传入 'iceman' 时获取的值就是错误的。"]}),"\n",(0,r.jsxs)(n.p,{children:["正常情况下，基础框架层会封装具有命名空间隔离特性的 cookie API 给到 A、B 应用。但正如我们第 1 节课程中所讲，",(0,r.jsx)(n.code,{children:"API 文档只能告诉开发者如何使用 API，但并不代表他们真的会按规则去使用"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"因此我们需要分析这类特殊的 API，及早发现和规避潜在风险。"}),"\n",(0,r.jsxs)(n.h2,{id:"browser-api-特征分析",children:["Browser API 特征分析",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#browser-api-特征分析",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["老样子，既然要分析 Browser API，那我们先将下面示例代码放入 ",(0,r.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/GYVwdgxgLglg9mABAIwIYQNYAoCUBvAKEWMQHcYwATOUgOgAsYBnKOAJwE9a1NcBuAgF8CoSLASIA5gFMoAETgBbXIRKI2skGyTUIIRdLBRaMqAFEANtINGAQhwCSlLAHIYlAB5eXOAYKA",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"}),"，观察一下 Browser API 调用场景中 AST 的结构及特征："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// 示例代码\nfunction back(){\n    window.history.back();\n}\nfunction getDom(){\n    return document.getElementById('idxxx');\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["我们发现 ",(0,r.jsx)(n.code,{children:"Browser API"})," 与 ",(0,r.jsx)(n.code,{children:"Import API"})," 的调用特征是一样的，包括链式调用在内，并没有什么不同。所以我们也可以通过判断 ",(0,r.jsx)(n.code,{children:"Identifier"})," 类型节点的名称与 Browser API 名称是否一致来判定 Browser API 是否被调用，而且因为没有 Import 节点的干扰，我们只需要排除局部同名变量的影响即可。"]}),"\n",(0,r.jsxs)(n.p,{children:["对于 Import API，我们通过对比 AST 节点的 ",(0,r.jsx)(n.code,{children:"Symbol"})," 与 Import API 节点的 ",(0,r.jsx)(n.code,{children:"Symbol"})," 指向是否一致来排除局部同名节点的干扰，但 Browser API 不存在显示声明，所以它的 ",(0,r.jsx)(n.code,{children:"Symbol"})," 信息比较特别。大家仔细观察一下上面两张图中右下角红框内的 ",(0,r.jsx)(n.code,{children:"pos"}),"、",(0,r.jsx)(n.code,{children:"end"})," 属性值就会发现，它们的值远大于我们整个代码字符串流的 ",(0,r.jsx)(n.code,{children:"pos"}),"、",(0,r.jsx)(n.code,{children:"end"})," 值，即它们的值在代码字符总长度之外。"]}),"\n",(0,r.jsxs)(n.p,{children:["什么意思呢？上面 AST 对应的字符串总长度为 ",(0,r.jsx)(n.code,{children:"111"}),"，正常 AST 节点 ",(0,r.jsx)(n.code,{children:"Symbol"})," 指向的声明节点 ",(0,r.jsx)(n.code,{children:"pos"}),"、",(0,r.jsx)(n.code,{children:"end"})," 属性值肯定在 ",(0,r.jsx)(n.code,{children:"0-111"})," 之间。但 Browser API 因为不存在声明，所以 ",(0,r.jsx)(n.code,{children:"pos"})," 和 ",(0,r.jsx)(n.code,{children:"end"})," 属性值都是大于 ",(0,r.jsx)(n.code,{children:"111"})," 的 ，我们可以通过这个特性来排除局部同名变量的干扰。"]}),"\n",(0,r.jsx)(n.p,{children:"下面是判定 Browser API 的代码实现，需要注意的一点是，Browser API 因为不存在显示声明，所以不需要针对 Import 节点进行 AST 遍历分析，需要分析哪些 API 直接在配置文件中的 browserApis 配置项中配置即可。"}),"\n",(0,r.jsxs)(n.p,{children:["完整代码可以参考 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"lib/analysis.js"})," ："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// AST分析\n_dealAST(importItems, ast, checker, filePath, projectName, httpRepo, baseLine = 0) {\n    const that = this;\n    \n    ......\n    // 遍历AST\n    function walk(node) {\n      // console.log(node);\n      tsCompiler.forEachChild(node, walk);\n      // 获取节点代码行信息\n      const line = ast.getLineAndCharacterOfPosition(node.getStart()).line + baseLine + 1;\n\n      // Browser API Analysis，命中Browser Api Item Name\n      if(tsCompiler.isIdentifier(node) \n        && node.escapedText \n        && that._browserApis.length>0 \n        && that._browserApis.includes(node.escapedText)) {\n        const symbol = checker.getSymbolAtLocation(node);\n        // console.log(symbol);\n        if(symbol && symbol.declarations){\n          // 在AST中找不到声明上下文信息，判定该API是 Browser API 调用\n          if(symbol.declarations.length>1 \n            || ( symbol.declarations.length==1 && symbol.declarations[0].pos >ast.end)){\n            const { baseNode, depth, apiName } = that._checkPropertyAccess(node);\n            // 执行插件记录Browser API调用信息\n            // that._runBrowserPlugins(tsCompiler, baseNode, depth, apiName, filePath, projectName, httpRepo, line);\n          }\n        }\n      }\n    }\n\n    walk(ast);\n    ......\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面的 ",(0,r.jsx)(n.code,{children:"_browserApis"})," 数组由 ",(0,r.jsx)(n.code,{children:"browserApis"})," 配置项（可选配置）初始化而来，比如 [ ",(0,r.jsx)(n.code,{children:"'window'"}),"，",(0,r.jsx)(n.code,{children:"'history'"}),"，",(0,r.jsx)(n.code,{children:"'document'"})," ] 表示工具需要分析的 Browser API 有 window.xxx，history.xxx，document.xxx，空数组则表示不需要分析 Browser API。"]}),"\n",(0,r.jsx)(n.p,{children:"如果按照上面的分析逻辑，那么在实际执行后我们会得到类似下面这样的分析结果（示例）："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"browserMap": {\n    "document.getElementById": {\n        "callNum": 1,\n        "callOrigin": null,\n        "callFiles": {\n            "Order&src/components/scrollBar/index.vue": {\n                "projectName": "Order",\n                "httpRepo": "",\n                "lines": [\n                    32\n                ]\n            }\n        }\n    },\n    "window.history.back": {\n        "callNum": 1,\n        "callOrigin": null,\n        "callFiles": {\n            "Order&src/api/people.ts": {\n                "projectName": "Order",\n                "httpRepo": "",\n                "lines": [\n                    13\n                ]\n            }\n        }\n    },\n    "history.back": {\n        "callNum": 1,\n        "callOrigin": null,\n        "callFiles": {\n            "Order&src/api/people.ts": {\n                "projectName": "Order",\n                "httpRepo": "",\n                "lines": [\n                    13\n                ]\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["我们看到 ",(0,r.jsx)(n.code,{children:"history.back"})," 与 ",(0,r.jsx)(n.code,{children:"window.history.back"})," 被当成不同的 API 调用被统计了，但这样的结果并不符合我们的预期，我们希望 ",(0,r.jsx)(n.code,{children:"window.history.back"})," 这种调用只会命中 ",(0,r.jsx)(n.code,{children:"window"})," 这个 API，而 ",(0,r.jsx)(n.code,{children:"history.back"})," 这种调用只会命中 ",(0,r.jsx)(n.code,{children:"history"})," 这个 API。"]}),"\n",(0,r.jsx)(n.p,{children:"所以分析逻辑需要区分 window.history 与 history 这两种调用方式，为了避免类似场景对分析结果的影响，我们添加一个过滤逻辑，完整代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// AST分析\n_dealAST(importItems, ast, checker, filePath, projectName, httpRepo, baseLine = 0) {\n    const that = this;\n    \n    ......\n    // 遍历AST\n    function walk(node) {\n      // console.log(node);\n      tsCompiler.forEachChild(node, walk);\n      const line = ast.getLineAndCharacterOfPosition(node.getStart()).line + baseLine + 1;\n\n      // Browser API Analysis，命中Browser Api Item Name\n      if(tsCompiler.isIdentifier(node) \n        && node.escapedText \n        && that._browserApis.length>0 \n        && that._browserApis.includes(node.escapedText)) {\n        const symbol = checker.getSymbolAtLocation(node);\n        // console.log(symbol);\n        if(symbol && symbol.declarations){\n          // 在AST中找不到声明上下文信息，判定该API是 Browser API 调用\n          if(symbol.declarations.length>1 \n            || ( symbol.declarations.length==1 && symbol.declarations[0].pos >ast.end)){\n            const { baseNode, depth, apiName } = that._checkPropertyAccess(node);\n            // 排除 window.xxx 此类场景对于统计的干扰\n            if(!(depth>0 \n              && node.parent.name \n              && node.parent.name.pos ==node.pos \n              && node.parent.name.end ==node.end)){\n              // 执行插件记录Browser API调用信息\n              // that._runBrowserPlugins(tsCompiler, baseNode, depth, apiName, filePath, projectName, httpRepo, line);\n            }\n          }\n        }\n      }\n    }\n\n    walk(ast);\n    ......\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"browser-api-分析插件",children:["Browser API 分析插件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#browser-api-分析插件",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["与 Import API 类似，在判定代码中存在 Browser API 调用后，也需要记录调用信息，所以我们内置了 browserPlugin 分析插件，完整源码请参考 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/plugins/browserPlugin.js",target:"_blank",rel:"noopener noreferrer",children:"plugins/browserPlugin.js"})," :"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"exports.browserPlugin = function (analysisContext) {\n    const mapName = 'browserMap';\n    // 在分析实例上下文挂载副作用\n    analysisContext[mapName] = {};\n\n    function isBrowserCheck (context, tsCompiler, node, depth, apiName, filePath, projectName, httpRepo, line) {\n        try{\n            if (!context[mapName][apiName]) {\n                context[mapName][apiName] = {};\n                context[mapName][apiName].callNum = 1;\n                context[mapName][apiName].callOrigin = null;\n                context[mapName][apiName].callFiles = {};\n                context[mapName][apiName].callFiles[filePath] = {};\n                context[mapName][apiName].callFiles[filePath].projectName = projectName;\n                context[mapName][apiName].callFiles[filePath].httpRepo = httpRepo;\n                context[mapName][apiName].callFiles[filePath].lines = [];\n                context[mapName][apiName].callFiles[filePath].lines.push(line);\n            } else {\n                context[mapName][apiName].callNum++;\n                if (!Object.keys(context[mapName][apiName].callFiles).includes(filePath)) {\n                    context[mapName][apiName].callFiles[filePath] = {};\n                    context[mapName][apiName].callFiles[filePath].projectName = projectName;\n                    context[mapName][apiName].callFiles[filePath].httpRepo = httpRepo;\n                    context[mapName][apiName].callFiles[filePath].lines = [];\n                    context[mapName][apiName].callFiles[filePath].lines.push(line);\n                }else{\n                    context[mapName][apiName].callFiles[filePath].lines.push(line);\n                }\n            }\n            return true;                                                                                 // true: 命中规则, 终止执行后序插件\n        }catch(e){\n            // console.log(e);\n            const info = {\n                projectName: projectName,\n                apiName: apiName,\n                httpRepo: httpRepo + filePath.split('&')[1] + '#L' + line,\n                file: filePath.split('&')[1],\n                line: line,\n                stack: e.stack\n            };\n            context.addDiagnosisInfo(info);\n            return false;                                                                                // false: 插件执行报错, 继续执行后序插件\n        }\n    }\n\n    // 返回分析Node节点的函数\n    return {\n        mapName: mapName,\n        checkFun: isBrowserCheck,\n        afterHook: null\n    };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["BrowserPlugin 的安装，执行有自己单独的插件队列，它与分析 Import API 的插件队列属于同级关系，不会干扰 Import API 的分析流程，配置文件中如果没有配置 ",(0,r.jsx)(n.code,{children:"browserApis"})," ，那么 codeAnalysis 实例不会去安装 BrowserPlugin，也不会去分析 Browser API。"]}),"\n",(0,r.jsxs)(n.p,{children:["下面是 CodeAnalysis 中关于 ",(0,r.jsx)(n.code,{children:"BrowserPlugin"})," 插件管理的简化代码，完整代码请参考 ",(0,r.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"lib/analysis.js"})," ："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class CodeAnalysis {\n    constructor(options) {\n        ......\n        // 私有属性\n        this._scanSource = options.scanSource;                // 扫描源配置信息       \n        this._analysisTarget = options.analysisTarget;        // 要分析的目标依赖配置           \n        this._browserApis = options.browserApis || [];        // 需要分析的BrowserApi配置\n        // 公共属性\n        this.browserQueue = [];                               // Browser分析插件队列\n        ......\n    }\n    // 注册插件\n    _installPlugins(plugins) {\n        ......\n        if(this._browserApis.length>0){\n          this.browserQueue.push(browserPlugin(this));        // install browserPlugin\n        }\n        ......\n    }\n    // 执行Browser分析插件队列中的检测函数\n    _runBrowserPlugins(tsCompiler, baseNode, depth, apiName, filePath, projectName, httpRepo, line) {\n        if(this.browserQueue.length>0){\n          for(let i=0; i<this.browserQueue.length; i++){\n            const checkFun = this.browserQueue[i].checkFun;\n            if(checkFun(this, tsCompiler, baseNode, depth, apiName, filePath, projectName, httpRepo, line)){\n              break;\n            }\n          }\n        }\n    }\n    // AST分析\n    _dealAST(ast, ...) {\n        ......\n        const that = this;\n        // 遍历AST\n        function walk(node) {\n            ......\n            tsCompiler.forEachChild(node, walk);\n            // 获取基础分析节点信息\n            const { baseNode, depth, apiName } = that._checkPropertyAccess(node);\n            // 执行分析插件                                                            \n            that._runBrowserPlugins(tsCompiler, baseNode, depth, apiName, filePath, projectName, httpRepo, line);         \n            ......\n        }\n    \n        walk(ast);\n        ......\n    }\n    // 扫描文件，分析代码\n    _scanCode() {\n        ......\n        this._dealAST();\n        ......\n    }\n    // 入口函数\n    analysis() {\n        ......\n        // 注册插件\n        this._installPlugins();\n        // 扫描分析TS\n        this._scanCode();\n        ......\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"小节",children:["小节",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小节",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这一小节我们学习了如何分析 Browser API，需要大家掌握以下知识点："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["微前端架构下滥用 ",(0,r.jsx)(n.code,{children:"Browser API"})," 可能会对其它应用或基础框架造成严重影响，因此我们需要分析这类特殊的 API，及早发现和规避潜在风险。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Browser API"})," 的调用特征与 ",(0,r.jsx)(n.code,{children:"Import API"})," 是一样的。但 ",(0,r.jsx)(n.code,{children:"Browser API"})," 不存在显示声明，所以 Symbol 信息比较特别，它指向的声明节点的 pos、end 属性值都远大于代码字符串总长度，我们可以通过这个特征来排除局部同名变量的干扰。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"BrowserPlugin"})," 的安装，执行有单独的插件队列来管理，它与分析 Import API 的插件队列属于同级关系，彼此互不干扰，是否分析 ",(0,r.jsx)(n.code,{children:"Browser API"})," 可以通过配置文件来控制。"]}),"\n"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F10.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9ABrowser%20API%20%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90.md"]={toc:[{text:"Browser API 分析意义",id:"browser-api-分析意义",depth:2},{text:"Browser API 特征分析",id:"browser-api-特征分析",depth:2},{text:"Browser API 分析插件",id:"browser-api-分析插件",depth:2},{text:"小节",id:"小节",depth:2}],title:"10.具体实现：Browser API 调用分析",headingTitle:"10.具体实现：Browser API 调用分析",frontmatter:{}}}}]);