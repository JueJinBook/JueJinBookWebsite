"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19504"],{599048:function(e,n,s){s.r(n),s.d(n,{default:()=>a});var l=s(552676),r=s(740453);function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",strong:"strong",h2:"h2",blockquote:"blockquote",h3:"h3",ol:"ol",li:"li"},(0,r.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{id:"6-基础篇掌握最独特的数据类型symbol",children:["6 基础篇｜掌握最独特的数据类型：Symbol",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-基础篇掌握最独特的数据类型symbol",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["前面讲到的 String 类型可以作为对象的 key，今天我们来学习另一个可以作为 key 的类型，就是 ",(0,l.jsx)(n.code,{children:"Symbol"}),"。"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Symbol"})," 是一个看起来比较奇怪的 Primitive 类型，为什么这样说呢？试问如果有 JavaScript 代码满足以下等式："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"A !== A\n"})}),"\n",(0,l.jsx)(n.p,{children:"A 是 Primitive 类型的变量或者构造表达式，那么它可以是什么呢？"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"NaN"})," 肯定是一个答案，从 ES6 开始，我们有一个新的选项，即 ",(0,l.jsx)(n.code,{children:"Symbol() !== Symbol()"}),"。"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Symbol（符号）用来生成唯一的值，确保每次调用结果不会重复"}),"。这个特性可以用在很多场景，有点类似于之前我们用 Math.random() 或者 md5 生成唯一 key，但这些基于字符串的方式都存在冲突的可能，每次实现起来也略有麻烦，",(0,l.jsx)(n.code,{children:"Symbol"})," 解决了这个问题。"]}),"\n",(0,l.jsx)(n.p,{children:"Symbol 除了可以让你生成唯一值以外，还定义了许多内置常量值，影响到了对象、字符串、正则等等的很多行为，可以说是至关重要。"}),"\n",(0,l.jsx)(n.p,{children:"本章节，我们就先来了解 Symbol 变量本身的构造、比较、类型转换，再来了解部分内置常量值的作用，能够让大家在日后的开发过程中充分发挥 Symbol 的价值。"}),"\n",(0,l.jsxs)(n.h2,{id:"symbol-创建",children:["Symbol 创建",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#symbol-创建",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["Symbol 类型可以由 ",(0,l.jsx)(n.code,{children:"Symbol()"})," 函数或者 ",(0,l.jsx)(n.code,{children:"Symbol.for()"})," 函数构造出来。"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Symbol()"})," 每次构造出一个新的变量，可以传入一个 key 参数，这样在显式转换为字符串时更方便辨认："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'Symbol("foo").toString() // "Symbol(foo)"\n'})}),"\n",(0,l.jsx)(n.p,{children:"由于每次调用都是返回新值，因此你一旦丢失了对其的引用，就不容易找回来了。比如像下面这样，就只能通过遍历来找了："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'const person = {};\n\nperson[Symbol("name")] = "Mike";\n'})}),"\n",(0,l.jsxs)(n.p,{children:["不过即便是 ",(0,l.jsx)(n.code,{children:"for...in"})," 遍历，也找不到："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"for (let key in person) console.log(key) // 找不到\n"})}),"\n",(0,l.jsxs)(n.p,{children:["像 ",(0,l.jsx)(n.code,{children:"Object.keys()"}),"、",(0,l.jsx)(n.code,{children:"Object.entries()"}),"、",(0,l.jsx)(n.code,{children:"Object.getOwnPropertyNames()"}),"，也都遍历不到，只有 ",(0,l.jsx)(n.code,{children:"Object.getOwnPropertySymbols()"})," 可以："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"console.log(Object.getOwnPropertySymbols(person)); // [Symbol(name)]\n"})}),"\n",(0,l.jsxs)(n.p,{children:["如果你希望可以轻易地找回已经创建过的值，可以使用 ",(0,l.jsx)(n.code,{children:"Symbol.for(key)"})," 方法。",(0,l.jsxs)(n.strong,{children:["Symbol 在全局会有一个注册表，",(0,l.jsx)(n.code,{children:"Symbol.for(key)"})," 会先去注册表中查找有无已经创建过的相同 key 的 Symbol，如果有，则返回，没有则创建"]}),"。"]}),"\n",(0,l.jsxs)(n.p,{children:["所以，",(0,l.jsx)(n.code,{children:"Symbol.for(key)"})," 的行为是这样的："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'Symbol.for("foo") === Symbol.for("foo") // true\n'})}),"\n",(0,l.jsx)(n.p,{children:"虽然取回更简单，但是这样创建的 Symbol 已经和字符串没有什么分别：key 冲突，则 Symbol 值也冲突。"}),"\n",(0,l.jsxs)(n.p,{children:["对于 ",(0,l.jsx)(n.code,{children:"Symbol.for(key)"})," 创建的值，可以通过 ",(0,l.jsx)(n.code,{children:"Symbol.keyFor(symbol)"})," 来获取 key，但是注意 ",(0,l.jsx)(n.code,{children:"Symbol(key)"})," 创建的却不可以："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'Symbol.keyFor(Symbol.for("foo")) // "foo"\nSymbol.keyFor(Symbol("foo")) // undefined\n'})}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Symbol 的另一特殊之处在于它不允许隐式转换为 String 或 Number："})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"+Symbol() // ❌ Uncaught TypeError: Cannot convert a Symbol value to a number\n'' + Symbol() // ❌ Uncaught TypeError: Cannot convert a Symbol value to a string\n"})}),"\n",(0,l.jsx)(n.p,{children:"如果你还是想转成字符串的话，比如打印的场景，可以有两种办法："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'String(Symbol("foo")) // "Symbol(foo)"\nSymbol("foo").toString() // "Symbol(foo)"\n'})}),"\n",(0,l.jsx)(n.p,{children:"前者可能更通用一些，能兼容 null、undefined 等空值。"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"\uD83D\uDCA1 Symbol 转换成 Number 是没有办法的，因此确保 Symbol 值不会进入数学计算中。"}),"\n"]}),"\n",(0,l.jsxs)(n.h2,{id:"常见-symbol-值",children:["常见 Symbol 值",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#常见-symbol-值",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["Symbol 作为一个函数，同样也是一个对象，它上面携带了好多静态常量，包括 ",(0,l.jsx)(n.code,{children:"Symbol.hasInstance"}),"、",(0,l.jsx)(n.code,{children:"Symbol.isConcatSpreadable"}),"、",(0,l.jsx)(n.code,{children:"Symbol.iterator"}),"、",(0,l.jsx)(n.code,{children:"Symbol.asyncIterator"}),"、",(0,l.jsx)(n.code,{children:"Symbol.match"}),"、",(0,l.jsx)(n.code,{children:"Symbol.matchAll"}),"、",(0,l.jsx)(n.code,{children:"Symbol.replace"}),"、",(0,l.jsx)(n.code,{children:"Symbol.search"}),"、",(0,l.jsx)(n.code,{children:"Symbol.species"}),"、",(0,l.jsx)(n.code,{children:"Symbol.split"}),"、",(0,l.jsx)(n.code,{children:"Symbol.toPrimitive"}),"、",(0,l.jsx)(n.code,{children:"Symbol.toStringTag"}),"、",(0,l.jsx)(n.code,{children:"Symbol.unscopables"}),"。"]}),"\n",(0,l.jsx)(n.p,{children:"今天我们来了解其中的一部分，余下的在后续的章节中也都有涉及。"}),"\n",(0,l.jsxs)(n.h3,{id:"symbolmatchmatchallreplacesearchsplit",children:["Symbol.match/matchAll/replace/search/split",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#symbolmatchmatchallreplacesearchsplit",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"从名字上就能看出来，这些值肯定和字符串的正则操作有关。在前面章节中，我们学习了在不同的需求下如何选择最合适的 API。"}),"\n",(0,l.jsxs)(n.p,{children:["先是搜索，判断有无匹配，除了 RegExp 的 test 外，还可以使用 String 的 ",(0,l.jsx)(n.code,{children:"search"}),"，传入一个正则。"]}),"\n",(0,l.jsxs)(n.p,{children:["事实上，除了正则以外，search 也可以传入自定义对象，只需要这个对象内置了 ",(0,l.jsx)(n.code,{children:"[Symbol.search]"})," 函数，比如："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'var customReg = {\n    name: "foo",\n    [Symbol.search](str) {\n        return str.indexOf(this.name);\n    }\n};\n\nconsole.log("barfoo".search(customReg)); // 3\n'})}),"\n",(0,l.jsxs)(n.p,{children:["举一反三，其余的 Symbol 也是这个用法，但是大家需要注意：",(0,l.jsx)(n.strong,{children:"ECMAScript 并没有约束这个成员函数的返回值类型"}),"。也就是说，search 可以不返回数字，match 可以不返回数组，matchAll 也可以不返回迭代器。"]}),"\n",(0,l.jsx)(n.p,{children:"显然不建议这样做，TypeScript 对此做出了类型约束，例如对于 search 函数："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"search(regexp: string | RegExp): number;\n//                                                   ⬇️⬇️ 必须返回 number\nsearch(searcher: { [Symbol.search](string: string): number; }): number;\n"})}),"\n",(0,l.jsxs)(n.p,{children:["事实上，我认为这个定义并不能准确反映 ECMAScript 的标准规范，规范里 String 的 search、match、matchAll、replace、replaceAll、split 方法并没有刻意去判断它的参数对象是否是一个 RegExp，只是看它有无 ",(0,l.jsx)(n.code,{children:"[Symbol.search]"}),"、",(0,l.jsx)(n.code,{children:"[Symbol.match]"})," 等属性。RegExp 对象作为合法的传入参数，它上面自然也携带了对应 Symbol 属性的定义，只不过在原型上："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"RegExp.prototype[Symbol.search]\nRegExp.prototype[Symbol.match]\nRegExp.prototype[Symbol.matchAll]\nRegExp.prototype[Symbol.replace]\nRegExp.prototype[Symbol.split]\n"})}),"\n",(0,l.jsxs)(n.h3,{id:"symbolhasinstance",children:["Symbol.hasInstance",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#symbolhasinstance",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["这个 Symbol 用于判断一个变量是否是一个构造函数的实例，目前用于 ",(0,l.jsx)(n.code,{children:"instanceof"})," 操作符的逻辑中。"]}),"\n",(0,l.jsxs)(n.p,{children:["事实上，在任意一个函数的原型链上，都有默认的 ",(0,l.jsx)(n.code,{children:"Symbol.hasInstance"})," 属性，下面的代码可以证明："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"function Animal() {}\n\nObject.getOwnPropertySymbols(Object.getPrototypeOf(Animal)); // [Symbol(Symbol.hasInstance)]\n"})}),"\n",(0,l.jsxs)(n.p,{children:["如果想修改其行为，不可以直接在 Animal 上赋值，因为会写到原型链上，而原型链上的这个 ",(0,l.jsx)(n.code,{children:"Symbol.hasInstance"})," 属性是只读的。只可以在 Animal 对象本身上定义："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'Object.defineProperty(Animal, Symbol.hasInstance, {\n    value(instance) {\n        return true;\n    },\n});\n\n// 修改 instanceof 行为\nconsole.log("ABC" instanceof Animal);\n'})}),"\n",(0,l.jsxs)(n.p,{children:["更简单的方法是直接用 ",(0,l.jsx)(n.code,{children:"class"})," 语法："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"class Animal {\n    static [Symbol.hasInstance](instance) {\n        return true;\n    }\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["无论如何，记得 ",(0,l.jsx)(n.strong,{children:"Symbol.hasInstance 应定义在构造函数上，而不是对象实例上"}),"。"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"关于 instanceof 的完整逻辑，我们在后面的章节中还会详细讲到。"}),"\n"]}),"\n",(0,l.jsxs)(n.h3,{id:"symbolisconcatspreadable",children:["Symbol.isConcatSpreadable",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#symbolisconcatspreadable",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["这个 Symbol 用于 Array 的 ",(0,l.jsx)(n.code,{children:"concat"})," 函数中。它的行为比较特殊，过去我们在合并两个数组的时候："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"[1,2].concat([3,4]) // [1,2,3,4]\n"})}),"\n",(0,l.jsxs)(n.p,{children:["这样的结果是毫无争议的。现在 ",(0,l.jsx)(n.code,{children:"Symbol.isConcatSpreadable"})," 的引入让上面的代码有了另一种可能，也就是不展开参数："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const arr = [3,4];\narr[Symbol.isConcatSpreadable] = false;\n[1,2].concat(arr) // [1,2,[3,4]]\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"concat"})," 也可以传入",(0,l.jsx)(n.strong,{children:"类数组"}),"："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'const obj  = {\n    0: "A",\n    1: "B",\n    length: 2,\n    [Symbol.isConcatSpreadable]: false\n}\n\nconsole.log([].concat[obj]); // [["A","B"]]\n'})}),"\n",(0,l.jsxs)(n.p,{children:["区别是：",(0,l.jsx)(n.strong,{children:"concat 传入数组的时候，默认展开；但是传入类数组的时候，默认不展开"}),"。因此，Symbol.isConcatSpreadable 更多的时候是针对传入非数组时候的行为定义。"]}),"\n",(0,l.jsxs)(n.h3,{id:"symbolspecies",children:["Symbol.species",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#symbolspecies",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["species 带有“物种”的含义。这个 Symbol 的用处有一些特殊，并不容易理解。这样说吧，假设你有一个类 A，它有一些方法，比如 clone()，正常来说也应该返回一个 A 类型的对象。但是呢，",(0,l.jsx)(n.code,{children:"Symbol.species"})," 可以声明你返回的这个对象是用 A 创建，还是用其他任意构造器来创建。"]}),"\n",(0,l.jsxs)(n.p,{children:["注意，",(0,l.jsx)(n.code,{children:"Symbol.species"})," 只是用来声明“应该”使用的构造器，具体 clone() 怎么执行，完全是另一回事了。因此可以说，",(0,l.jsx)(n.code,{children:"Symbol.species"})," 基本只会影响一些内置的类型，比如 Array、TypedArray、RegExp、Promise、Map、Set、ArrayBuffer 等等。但是原则上，如果你定义的对象，通过某些方法可以生成一个“派生（",(0,l.jsx)(n.code,{children:"derived"}),"，代表源于当前对象类型的）”对象，那么就可以通过引入 ",(0,l.jsx)(n.code,{children:"Symbol.species"})," 来决定该派生对象该如何创建。"]}),"\n",(0,l.jsx)(n.p,{children:"先来看内置的 Array 类型，它的 concat、filter、flat、flatMap、map、slice、splice 方法默认均返回 Array 类型数据。我们可以改变这一行为，但首先我们需要定义一个 Array 的子类："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"class SizableArray extends Array {\n    static get [Symbol.species]() {\n        return Array;\n    }\n\n    get size() {\n        return this.length;\n    }\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["通过将 SizableArray 的静态属性 ",(0,l.jsx)(n.code,{children:"[Symbol.species]"})," 指向 Array，那么调用上述任一方法，返回的对象将不再是 SizableArray 类型，而是 Array："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const arr = new SizableArray();\n\nconst sliced = arr.slice();\n\nconsole.log(sliced.constructor); // Array\n"})}),"\n",(0,l.jsxs)(n.p,{children:["注意，Array 上面并非所有返回 Array 的方法都具备此特性，比如 sort、reverse、copyWithin，这三个方法都返回调用数组本身，因此仍然返回当前类型的对象，也就是 SizableArray 调用它们依然返回 SizableArray。再比如 ",(0,l.jsx)(n.code,{children:"ES2023"})," 最新引入的 toSorted、toSpliced、toReversed、with 方法，虽然都返回新的数组实例，但是也不支持 ",(0,l.jsx)(n.code,{children:"[Symbol.species]"}),"。"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["和 Array 非常类似的还有 ",(0,l.jsx)(n.code,{children:"TypedArray"}),"，指那些 Int8Array、Uint8Array、Int32Array、BigInt64Array 这类对象。"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["ECMAScript 还在如下这些对象类型上也定义了 ",(0,l.jsx)(n.code,{children:"[Symbol.species]"}),"："]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Promise"}),"，它的 then、catch、finally 方法都会参考 ",(0,l.jsx)(n.code,{children:"[Symbol.species]"})," 来决定生成的新 Promise 的构造函数；"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"ArrayBuffer"}),"/",(0,l.jsx)(n.code,{children:"SharedArrayBuffer"})," 的 slice 方法，与 Array 类似；"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"RegExp"})," 原型链的 ",(0,l.jsx)(n.strong,{children:"Symbol.matchAll/split"})," 方法，用于在 String 调用 matchAll/split 时，构造指定的正则对象，举例来说："]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"class MyReg extends RegExp {\n    constructor(...args) {\n        console.log('create MyReg', ...args);\n        super(...args);\n    }\n\n    static get [Symbol.species]() {\n        return RegExp;\n    }\n}\n\n\"AB56CD78\".split(new MyReg(\"[A-Z]+\",'g'));\n"})}),"\n",(0,l.jsxs)(n.p,{children:["matchAll 和 split 的特殊之处在于，",(0,l.jsx)(n.strong,{children:"传入 String 对象的这两个方法的正则参数并没有被真正使用到，而是在内部又创建了一个新的正则对象"}),"，那么这时候就会参考到 ",(0,l.jsx)(n.code,{children:"[Symbol.species]"})," 来构造了。"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["大家不妨试一试上面的代码中，",(0,l.jsx)(n.code,{children:"[Symbol.species]"})," 返回 RegExp 或者 MyReg，console.log 都会打印几次。"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"Map"})," 和 ",(0,l.jsx)(n.code,{children:"Set"})," 也都定义了 ",(0,l.jsx)(n.code,{children:"[Symbol.species]"}),"，不过 ECMAScript 内部并没有使用到，如果你继承它们创建新的类，那么就可以考虑使用它。"]}),"\n",(0,l.jsxs)(n.h3,{id:"symbolunscopables",children:["Symbol.unscopables",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#symbolunscopables",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["这个 Symbol 是为了 ",(0,l.jsx)(n.code,{children:"with"})," 而设计的。它是一个",(0,l.jsx)(n.strong,{children:"黑名单"}),"，被标记的 key 不会从 with 的参数对象中获取，以 MDN 的例子来说明它的作用："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"var obj = {\n  foo: 1,\n  bar: 2\n};\n\nobj[Symbol.unscopables] = {\n  foo: false,\n  bar: true\n};\n\nwith(obj) {\n  console.log(foo); // 1\n  console.log(bar); // ReferenceError: bar is not defined\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["除了极少数特殊场景之外，我们很难会使用到它，况且在 strict 模式下也不允许使用 ",(0,l.jsx)(n.code,{children:"with"}),"，因此我们就不用过多篇幅讲它了。"]}),"\n",(0,l.jsxs)(n.h2,{id:"发挥-symbol-的价值",children:["发挥 Symbol 的价值",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发挥-symbol-的价值",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"上面我们学习了一部分 ECMAScript 内置的 Symbol 常量。在定义了这些值的变量或者类上，总会有不一样的行为出现。"}),"\n",(0,l.jsxs)(n.p,{children:["仔细思考的话，Symbol 常量在这里面发挥的作用，是不是类似于 ",(0,l.jsx)(n.code,{children:"Hook"})," 函数呢？如果进一步封装的话，更有类似于面向对象语言中的 ",(0,l.jsx)(n.code,{children:"interface"})," 的意味，即任何对象（类）只要实现了对应的 Symbol 属性，就可以被功能模块所消费，而不管这个对象（类）到底是什么以及怎么创建的。"]}),"\n",(0,l.jsx)(n.p,{children:"上面提到的 String 的 match/replace/split 等方法就是此场景的典型案例，它可以传入正则，也可以传入实现了制定 Symbol 属性的自定义对象。依照此思路，我们也可以设计自己的基于 Symbol 的功能拓展方式。"}),"\n",(0,l.jsx)(n.p,{children:"假设我们实现了一个 HTTP 服务器，接收到一个请求（request）后，指派给任意个处理器（handler）。处理器的逻辑通常由开发者来拓展实现。按照以往的思路，我们定义一个 Handler 类，开发者继承它实现派生类，实例化之后再传递给 HTTPServer："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:"abstract class Handler {\n    abstract handle(req: Request): void;\n}\n\nclass HTTPServer {\n    handleRequest(handler: Handler) {\n        handler.handle(new Request());\n    }\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"现在我们多了一种设计模式，使用 Symbol 来代替抽象类："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-ts",children:'const handlerSymbol = Symbol("HttpHandler");\n\nclass HTTPServer {\n    handleRequest(handler: { [handlerSymbol](req: Request): void; }) {\n        handler[handlerSymbol](new Request());\n    }\n}\n'})}),"\n",(0,l.jsx)(n.p,{children:"这样的话，开发者在实现 handler 方面会更灵活，虽然依然需要引用 HTTPServer 提供的 Symbol 值，但是消除了类的继承，可以以任意方式创建对象，也不必受到单继承的限制。"}),"\n",(0,l.jsxs)(n.p,{children:["这个设计利用的就是 Symbol ",(0,l.jsx)(n.strong,{children:"唯一值"}),"的特性，也就是说，你的自定义对象的属性再怎样，也不会和这个预设值冲突。"]}),"\n",(0,l.jsx)(n.p,{children:"这个特性也常常用在唯一性数据的存储上，比如 Map、Set 等数据结构，都支持储存 Symbol 或以 Symbol 为 key。"}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"WeakSet"}),"、",(0,l.jsx)(n.code,{children:"WeakMap"})," 对 Symbol 的支持存在浏览器上的差异性，不建议使用。"]}),"\n"]}),"\n",(0,l.jsxs)(n.h2,{id:"小结",children:["小结",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["Symbol 在",(0,l.jsx)(n.strong,{children:"值唯一"}),"这个特性上的作用能够支撑我们写出更加健壮的代码，不过也要注意它默认无法参与字符串和数字转换的的特征，作为对象的 key 也很难遍历得到，避免犯下低级错误。"]}),"\n",(0,l.jsxs)(n.p,{children:["Symbol 定义了很多",(0,l.jsx)(n.strong,{children:"静态常量"}),"，能够默默影响到许多策略，比如字符串搜索匹配、instanceof、with 等等。这种模式更像是一种钩子（Hooks）范式，能够实现不依赖类继承的能力拓展。"]}),"\n",(0,l.jsx)(n.p,{children:"希望大家能善于使用 Symbol，充分利用其唯一性和静态常量来优化所编写代码的健壮性和灵活性。"}),"\n",(0,l.jsx)(n.p,{children:"当然 Symbol 的故事还没有完，有几个静态常量如 Symbol.toStringTag、Symbol.toPrimitive、Symbol.iterator、Symbol.asyncIterator，还有更重要的任务。"}),"\n",(0,l.jsx)(n.p,{children:"下一章，我们来聊聊数组。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}let a=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F6%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E6%8E%8C%E6%8F%A1%E6%9C%80%E7%8B%AC%E7%89%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9ASymbol.md"]={toc:[{text:"Symbol 创建",id:"symbol-创建",depth:2},{text:"常见 Symbol 值",id:"常见-symbol-值",depth:2},{text:"Symbol.match/matchAll/replace/search/split",id:"symbolmatchmatchallreplacesearchsplit",depth:3},{text:"Symbol.hasInstance",id:"symbolhasinstance",depth:3},{text:"Symbol.isConcatSpreadable",id:"symbolisconcatspreadable",depth:3},{text:"Symbol.species",id:"symbolspecies",depth:3},{text:"Symbol.unscopables",id:"symbolunscopables",depth:3},{text:"发挥 Symbol 的价值",id:"发挥-symbol-的价值",depth:2},{text:"小结",id:"小结",depth:2}],title:"6 基础篇｜掌握最独特的数据类型：Symbol",headingTitle:"6 基础篇｜掌握最独特的数据类型：Symbol",frontmatter:{}}}}]);