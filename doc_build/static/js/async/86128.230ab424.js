"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["86128"],{967214:function(e,n,a){a.r(n),a.d(n,{default:()=>O});var i=a(552676),s=a(740453);let t=a.p+"static/image/e4006b02cdbef8ac7136de38a3546895.5266ad07.gif",d=a.p+"static/image/ea2ade7bbf561d77e0eb3e94defe5097.96ab9fad.webp",c=a.p+"static/image/6053aa731b26b053f1b0e9597d7d0a35.233900a3.webp",r=a.p+"static/image/d376c7d84619b9bb84eaa58fc8d486d2.95db6241.webp",o=a.p+"static/image/7b579e5f0944438329e9e1776e073d11.eb00f080.gif",l=a.p+"static/image/9b5c9bb537059548a267fb7251dc6378.4abf50b0.webp",p=a.p+"static/image/9d39f0de5bf49b0ea5c567e1366c4724.793e00c8.webp",g=a.p+"static/image/f22b74ca65ef4cce9bdd593aea166720.26239528.webp",h=a.p+"static/image/497d8a594be327de7e74b120cfb5ce01.9c2e85a8.gif",x=a.p+"static/image/f1ef71eeb0a3d60f0445ff30561f9d15.f25456c8.webp",j=a.p+"static/image/1d95cdf73205e70abe030b5d2a05e2a3.1d182461.webp",f=a.p+"static/image/b727193d31728a73dd581b0f2237267a.601f471e.webp",b=a.p+"static/image/f322c57829057e6a8ffc95429b59c914.e1417ec2.webp",m=a.p+"static/image/21f10bfae8eeae86ecdb98a1596f4611.213f4865.gif",u=a.p+"static/image/c59779d30dec75b2af18c9f3ba7def68.e8010657.webp",E=a.p+"static/image/dfca6e0fb2556e56ffd4114a24f27238.023896d9.gif",w=a.p+"static/image/0a75a87ef0f58a140001a2c1c70674d0.33bd8526.webp",y=a.p+"static/image/67a19181278db23fc52e15526b01e4f9.289a5838.webp",C=a.p+"static/image/f5ffd5420b9cd19154e280a43732bce5.e6b7637a.webp",N=a.p+"static/image/1cc1c87fc4c1362ff05f6cfc5d13eb46.5d2cd447.webp",v=a.p+"static/image/db95117c97241a3adc5e3c618fc74150.63596daa.gif",R=a.p+"static/image/c0ea52ceb301b6b31c713bebc039963e.5e4555ae.webp",P=a.p+"static/image/e9d78187510a79c3b851123be94734fa.2d9c5625.gif",B=a.p+"static/image/13d734d89c6ecedc7bf90697a0b2b9a9.3beee5b2.webp",k=a.p+"static/image/8ff4f6f5a2cf301f2acaa0a55dbb2455.c9cee4c8.webp",F=a.p+"static/image/68996a3a15c909d1dbbf63e19feb6aca.4012f028.webp",A=a.p+"static/image/a2f3bcce8f8a670d8e3714fab073585f.f7a08fea.webp",S=a.p+"static/image/762a33606157616a067e012d47115964.38ec06e7.webp",_=a.p+"static/image/13726d5256023dc3d46d3670fc87bdac.6a82d07a.webp",M=a.p+"static/image/379728f26547e378c947e48e0ac16934.2976348d.gif",H=a.p+"static/image/62676d9a0959aa934d99a8bd46c58ff6.5ca73b7d.gif",T=a.p+"static/image/10aba2dac3b71ba76dccf00b536e5cfa.6f3efc11.webp",L=a.p+"static/image/025224984c5acd9ac4f4e0a9a79302a2.04997466.webp",X=a.p+"static/image/4502b4b1d44319f4c13f60702394532b.fe92361a.webp",Y=a.p+"static/image/1fe876032c8c0384bcb7a17a612e879b.a924cdfd.gif";function z(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"第80章快速掌握reactflow画流程图",children:["第80章—快速掌握ReactFlow画流程图",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第80章快速掌握reactflow画流程图",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"\uFEFF这节我们来学下用 React Flow 来画流程图。"}),"\n",(0,i.jsx)(n.p,{children:"有同学会问，这有什么应用么？"}),"\n",(0,i.jsx)(n.p,{children:"有很多。"}),"\n",(0,i.jsx)(n.p,{children:"现在很多 AI 工具都支持通过流程图来画工作流，然后执行："}),"\n",(0,i.jsxs)(n.p,{children:["比如 ",(0,i.jsx)(n.a,{href:"https://www.coze.cn/store/workflow",target:"_blank",rel:"noopener noreferrer",children:"Coze"})," 的："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:Y,alt:"2024-08-29 00.13.25.gif"})}),"\n",(0,i.jsx)(n.p,{children:"或者 Defi 的："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:X,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["在 Defi 的",(0,i.jsx)(n.a,{href:"https://github.com/langgenius/dify/blob/main/web/package.json#L86",target:"_blank",rel:"noopener noreferrer",children:"前端代码"}),"可以看到用的 reactflow"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:L,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"工作流是 AI 工具的一个卖点，并不是所有的 AI 工具都支持："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:T,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"能作为业务卖点的功能，这技术就很有价值了。"}),"\n",(0,i.jsx)(n.p,{children:"而且低代码编辑器的事件处理也可以用流程图来做逻辑编排："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:H,alt:"2024-08-29 00.23.58.gif"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:M,alt:"2024-08-29 00.24.58.gif"})}),"\n",(0,i.jsx)(n.p,{children:"然后执行这个流程。"}),"\n",(0,i.jsx)(n.p,{children:"同样，不是所有的低代码平台都支持逻辑编排，这也是一个可以作为业务卖点的功能。"}),"\n",(0,i.jsx)(n.p,{children:"所以说，学习 React Flow 是很有价值的。"}),"\n",(0,i.jsx)(n.p,{children:"下面我们新建个项目来学习下："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"npx create-vite react-flow-test\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:_,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"进入项目，安装 reactflow 的包："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"npm install\nnpm install --save @xyflow/react\n"})}),"\n",(0,i.jsx)(n.p,{children:"把 main.tsx 里的样式和 StrictMode 去掉。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:S,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"然后改一下 App.tsx"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { ReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n \nconst initialNodes = [\n  { id: '1', position: { x: 0, y: 0 }, data: { label: '1' } },\n  { id: '2', position: { x: 0, y: 100 }, data: { label: '2' } },\n];\nconst initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];\n \nexport default function App() {\n  return (\n    <div style={{ width: '800px', height: '500px', border: '1px solid #000', margin: '50px auto' }}>\n      <ReactFlow nodes={initialNodes} edges={initialEdges} />\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"其实 React Flow 也很简单，就是指定 node（节点） 和 edge（边） 就好了。"}),"\n",(0,i.jsx)(n.p,{children:"比如我们指定了 2 个节点："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:A,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"id 是节点 id、position 是在画布中的坐标，data 是传递给节点组件的参数。"}),"\n",(0,i.jsx)(n.p,{children:"指定了一条边来连接 id 为 1 和 id 为 2 的节点。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:F,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"指定了这两部分，就是一个流程图了："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:k,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"跑起来看下效果："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"npm run dev\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:B,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:P,alt:"2024-08-29 00.45.41.gif"})}),"\n",(0,i.jsx)(n.p,{children:"可以看到，流程图绘制出来了，可以放缩画布，但不能拖动流程图。"}),"\n",(0,i.jsx)(n.p,{children:"这是因为没处理拖动的事件，加一下就好了："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:R,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"因为只有 node 和 edge，所以也就只有三种事件： node 变化、edge 变化、node 和 node 连接，也就是 onNodesChange、onEdgesChange、onConnect"}),"\n",(0,i.jsx)(n.p,{children:"onNodesChange 和 onEdgesChange 直接用 reactflow 提供的就好。"}),"\n",(0,i.jsx)(n.p,{children:"而 onConnect 就是调用 addEdge 新加一条边，然后调用 setEdges 更新。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { addEdge, Connection, OnConnect, ReactFlow, useEdgesState, useNodesState } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n \nconst initialNodes = [\n  { id: '1', position: { x: 0, y: 0 }, data: { label: '1' } },\n  { id: '2', position: { x: 0, y: 100 }, data: { label: '2' } },\n];\nconst initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];\n \nexport default function App() {\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n \n  const onConnect = (params: Connection) => {\n    setEdges((eds) => addEdge(params, eds))\n  }\n\n  return (\n    <div style={{ width: '800px', height: '500px', border: '1px solid #000', margin: '50px auto' }}>\n      <ReactFlow \n        nodes={nodes}\n        edges={edges}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        onConnect={onConnect}\n      />\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"试一下："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:v,alt:"2024-08-29 00.58.01.gif"})}),"\n",(0,i.jsx)(n.p,{children:"现在节点就可以拖拽了，并且可以删除节点、删除边、创建新的连接。"}),"\n",(0,i.jsx)(n.p,{children:"ractflow 还内置了一些工具。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:N,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"分别是控制条、缩略图、背景："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:C,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"当然，用点做背景不太明显，你可以换成线："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:y,alt:"image.png"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"<Background variant={BackgroundVariant.Lines}/>\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:w,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"你可以用鼠标滚轮放缩画布，也可以用控制条来控制："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:E,alt:"2024-08-29 01.06.32.gif"})}),"\n",(0,i.jsx)(n.p,{children:"或者可以在 MiniMap 上加上 zoomable 参数："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"这样就可以通过缩略图放缩画布了："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:m,alt:"2024-08-29 01.09.45.gif"})}),"\n",(0,i.jsx)(n.p,{children:"回到流程图本身："}),"\n",(0,i.jsx)(n.p,{children:"像这些节点明显都是自己绘制的："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"我们也实现下："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { addEdge, Background, BackgroundVariant, Connection, Controls, Handle, MiniMap, OnConnect, Position, ReactFlow, useEdgesState, useNodesState } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n \nconst initialNodes = [\n  { id: '1', position: { x: 0, y: 0 }, type: 'red', data: { label: '1' } },\n  { id: '2', position: { x: 200, y: 300 }, type: 'blue', data: { label: '2' } },\n];\nconst initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];\n \ninterface NodePorps {\n  data: {\n    label: string\n  }\n}\nfunction RedNode({ data }: NodePorps) {\n  return <div style={{background: 'red', width: '100px', height: '100px', textAlign: 'center'}}>\n    <Handle type=\"source\" position={Position.Right} />\n    <Handle type=\"target\" position={Position.Bottom} />\n\n\n    <div>{data.label}</div>\n  </div>\n}\n\nfunction BlueNode({ data }: NodePorps) {\n  return <div style={{background: 'blue', width: '50px', height: '50px', textAlign: 'center', color: '#fff'}}>\n    <Handle type=\"source\" position={Position.Bottom} />\n    <Handle type=\"target\" position={Position.Top} />\n\n    <div>{data.label}</div>\n  </div>\n}\n\nexport default function App() {\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n \n  const onConnect = (params: Connection) => {\n    setEdges((eds) => addEdge(params, eds))\n  }\n\n  return (\n    <div style={{ width: '800px', height: '500px', border: '1px solid #000', margin: '50px auto' }}>\n      <ReactFlow \n        nodes={nodes}\n        edges={edges}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        onConnect={onConnect}\n        nodeTypes={{\n          red: RedNode,\n          blue: BlueNode\n        }}\n      >\n        <Controls/>\n        <MiniMap zoomable/>\n        <Background variant={BackgroundVariant.Lines}/>\n      </ReactFlow>\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"我们增加了两个组件 RedNode 和 BlueNode："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"它的 props 里的 data 就是 node 里的 data 属性。"}),"\n",(0,i.jsx)(n.p,{children:"那渲染 node 的时候如何对应到不同的组件呢？"}),"\n",(0,i.jsx)(n.p,{children:"根据 nodeTypes 的映射："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"我们指定了 type 为 red 就渲染 RedNode，这样渲染流程图的时候就会用对应的组件来渲染。"}),"\n",(0,i.jsx)(n.p,{children:"看下效果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"可以看到，渲染的节点变成了我们自己的组件。"}),"\n",(0,i.jsx)(n.p,{children:"你可以绘制更多东西，比如这种："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"而且节点上有一个黑点可以用来连接别的节点："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:"2024-08-29 01.33.09.gif"})}),"\n",(0,i.jsx)(n.p,{children:"这个黑点叫做 Handle："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"在自定义节点里，用 Handle 来指定黑点出现的位置。"}),"\n",(0,i.jsx)(n.p,{children:"还要指定 type，可以连线从 source 的 Handle 到 source 为 target 的 Handle，不能反过来。"}),"\n",(0,i.jsx)(n.p,{children:"除了 node 外， edge 自然也是可以自定义的。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import { addEdge, Background, BackgroundVariant, BaseEdge, Connection, Controls, EdgeLabelRenderer, EdgeProps, getBezierPath, getStraightPath, Handle, MiniMap, OnConnect, Position, ReactFlow, useEdgesState, useNodesState, useReactFlow } from '@xyflow/react';\nimport '@xyflow/react/dist/style.css';\n \nconst initialNodes = [\n  { id: '1', position: { x: 0, y: 0 }, type: 'red', data: { label: '1' } },\n  { id: '2', position: { x: 200, y: 300 }, type: 'blue', data: { label: '2' } },\n];\nconst initialEdges = [{ id: 'e1-2', source: '1', target: '2', type: 'custom' }];\n \ninterface NodePorps {\n  data: {\n    label: string\n  }\n}\nfunction RedNode({ data }: NodePorps) {\n  return <div style={{background: 'red', width: '100px', height: '100px', textAlign: 'center'}}>\n    <Handle type=\"source\" position={Position.Right} />\n    <Handle type=\"target\" position={Position.Bottom} />\n\n    <div>{data.label}</div>\n  </div>\n}\n\nfunction BlueNode({ data }: NodePorps) {\n  return <div style={{background: 'blue', width: '50px', height: '50px', textAlign: 'center', color: '#fff'}}>\n    <Handle type=\"source\" position={Position.Bottom} />\n    <Handle type=\"target\" position={Position.Top} />\n\n    <div>{data.label}</div>\n  </div>\n}\n\nfunction CustomEdge({\n  id,\n  sourceX,\n  sourceY,\n  targetX,\n  targetY,\n  sourcePosition,\n  targetPosition,\n  style = {},\n  markerEnd,\n}: EdgeProps) {\n\n  const { setEdges } = useReactFlow();\n\n  const [edgePath, labelX, labelY] = getBezierPath({\n    sourceX,\n    sourceY,\n    sourcePosition,\n    targetX,\n    targetY,\n    targetPosition,\n  });\n\n  const onEdgeClick = () => {\n    setEdges((edges) => edges.filter((edge) => edge.id !== id));\n  };\n\n  return (\n    <>\n      <BaseEdge path={edgePath} markerEnd={markerEnd} style={style} />\n      <EdgeLabelRenderer>\n        <div\n          style={{\n            position: 'absolute',\n            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n            fontSize: 12,\n            // EdgeLabelRenderer 里的组件默认不处理鼠标事件，如果要处理就要声明 pointerEvents: all\n            pointerEvents: 'all',\n          }}\n        >\n          <button onClick={onEdgeClick}>\n            \xd7\n          </button>\n        </div>\n      </EdgeLabelRenderer>\n    </>\n  );\n}\n\nexport default function App() {\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n \n  const onConnect = (params: Connection) => {\n    setEdges((eds) => addEdge(params, eds))\n  }\n\n  return (\n    <div style={{ width: '800px', height: '500px', border: '1px solid #000', margin: '50px auto' }}>\n      <ReactFlow \n        nodes={nodes}\n        edges={edges}\n        onNodesChange={onNodesChange}\n        onEdgesChange={onEdgesChange}\n        onConnect={onConnect}\n        nodeTypes={{\n          red: RedNode,\n          blue: BlueNode\n        }}\n        edgeTypes={{\n          custom: CustomEdge\n        }}\n      >\n        <Controls/>\n        <MiniMap zoomable/>\n        <Background variant={BackgroundVariant.Lines}/>\n      </ReactFlow>\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"和 nodeTypes 自定义节点类似，在 edgeTypes 里配置自定义边就可以了："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"绘制边稍微复杂一些："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"主要是要根据传入的起始位置和目标位置，计算一条贝塞尔曲线，拿到 path 之后传入 BaseEdge 就可以绘制边了。"}),"\n",(0,i.jsx)(n.p,{children:"如果想绘制额外的内容，就放在 EdgeLabelRenderer 组件里。"}),"\n",(0,i.jsx)(n.p,{children:"这里 button 我们想加上点击事件，需要设置 pointerEvents: all，不然默认不响应鼠标事件。"}),"\n",(0,i.jsx)(n.p,{children:"点击的时候，删除这条边，也是调用 setEdeges，这个 API 通过 useReactFlow 的 hook 拿到。"}),"\n",(0,i.jsx)(n.p,{children:"看下效果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:"2024-08-29 01.53.27.gif"})}),"\n",(0,i.jsx)(n.p,{children:"绘制的边多了一个按钮，并且点击可以删除这条边。"}),"\n",(0,i.jsx)(n.p,{children:"有同学可能会说，如果我想绘制直线呢？"}),"\n",(0,i.jsx)(n.p,{children:"那更简单，只需要起始、结束点的坐标就能计算出路径："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const [edgePath, labelX, labelY] = getStraightPath({\n    sourceX,\n    sourceY,\n    targetX,\n    targetY\n})\n"})}),"\n",(0,i.jsx)(n.p,{children:"现在绘制的就是直线了："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"最后我们在右上角加一个按钮："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"点击的时候添加一个节点："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"<Panel position=\"top-right\">\n  <button onClick={() => {\n    setNodes([...nodes, { \n      id: Math.random().toString().slice(2,6) + '', \n      type: 'red', \n      position: { x: 0, y: 0 }, \n      data: {\n        label: '光'\n    }}])\n  }}>添加节点</button>\n</Panel>\n"})}),"\n",(0,i.jsx)(n.p,{children:"试下效果："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:"2024-08-29 02.06.12.gif"})}),"\n",(0,i.jsx)(n.p,{children:"至此，reactflow 的常用功能我们就学会了。"}),"\n",(0,i.jsxs)(n.p,{children:["案例代码上传了",(0,i.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/react-flow-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,i.jsxs)(n.h2,{id:"总结",children:["总结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这节我们学会了基于 React Flow 画流程图。"}),"\n",(0,i.jsx)(n.p,{children:"它有很多有价值的应用，比如 AI 工具的工作流编辑、低代码的逻辑编排等。"}),"\n",(0,i.jsx)(n.p,{children:"但它学起来并不难，核心就是 node（节点） 和 edge（边）。"}),"\n",(0,i.jsx)(n.p,{children:"对应三个事件： nodesChange（节点变化）、edgesChange（边变化）、connect（连接节点和节点）"}),"\n",(0,i.jsx)(n.p,{children:"每个节点可以通过 type 指定绘制用的组件，我们可以自定义节点的内容，通过 data 指定传给组件的参数。"}),"\n",(0,i.jsx)(n.p,{children:"然后通过 nodeTypes 来指定 type 和组件的映射。"}),"\n",(0,i.jsx)(n.p,{children:"同样，边也可以自定义，通过 edgeTypes 来指定映射。"}),"\n",(0,i.jsx)(n.p,{children:"在自定义 node 里，通过 Handle 来声明黑点位置。"}),"\n",(0,i.jsx)(n.p,{children:"在自定义 edge 里，通过 BaseEdge 来画线，通过 EdgeLabelRenderer 来画其他内容。"}),"\n",(0,i.jsx)(n.p,{children:"画边的时候计算贝塞尔曲线的路径、直线的路径用 reactflow 提供的 hook 就行。"}),"\n",(0,i.jsx)(n.p,{children:"此外，还可以通过 Controls、MiniMap、Background 来实现控制条、缩略图、背景等功能。通过 Panel 组件在画布上放置一些按钮之类的。"}),"\n",(0,i.jsx)(n.p,{children:"学完了这个案例，React Flow 就算入门了。"})]})}function I(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(z,{...e})}):z(e)}let O=I;I.__RSPRESS_PAGE_META={},I.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC80%E7%AB%A0%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1ReactFlow%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第80章—快速掌握ReactFlow画流程图",headingTitle:"第80章—快速掌握ReactFlow画流程图",frontmatter:{}}}}]);