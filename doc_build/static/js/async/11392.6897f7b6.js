"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11392"],{939742:function(n,e,i){i.r(e),i.d(e,{default:()=>o});var s=i(552676),r=i(740453);function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",blockquote:"blockquote",pre:"pre",code:"code",ul:"ul",li:"li"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"第23章架构升华脱离设计模式",children:["第23章—架构升华：脱离设计模式",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第23章架构升华脱离设计模式",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\uFEFF在上一章中，我们讲了三种常见的设计模式，这远远不够，设计模式有 20 多种呢，怎么学得过来呢？有没有别的法子能不学设计模式但是却能掌握设计思路呢？"}),"\n",(0,s.jsx)(e.p,{children:"醒醒，别做梦了！"}),"\n",(0,s.jsxs)(e.p,{children:["虽然没有好办法，但是却有捷径，那就是",(0,s.jsx)(e.strong,{children:"设计思想"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"在我们的高中时代，要求等差数列、等比数列的前 n 项和，有裂项相消法、错位相减法等；而立体几何中，就可以作辅助线，其实设计模式就跟这些方法一样，都是技巧，是通过经验得出来的。"}),"\n",(0,s.jsx)(e.p,{children:"那么，思想是什么呢？"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"思想就是技巧的高度总结和归纳"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"比如：分类讨论思想、数形结合思想、类比思想等，思想是你遇到问题时可以挨个去尝试的。"}),"\n",(0,s.jsxs)(e.h2,{id:"分层思想",children:["分层思想",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#分层思想",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"将逻辑分层处理，不同层次之间有不同的职责，不存在跨层访问，从而降低耦合，职责清晰，容易拓展，容易复用。"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"分层思想就是宏观的单一职责原则"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"每一层有自己的职责，也只负责自己的职责，每一层只使用上层的服务并向下层提供服务。"}),"\n",(0,s.jsxs)(e.p,{children:["最简单的例子就是我们",(0,s.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196591439428943872",target:"_blank",rel:"noopener noreferrer",children:"第 16 章"}),"讲到的五层协议，每一层协议只对下层负责，不会出现跨层访问的情况。"]}),"\n",(0,s.jsx)(e.p,{children:"那么，分层有啥好处呢？我们上代码。"}),"\n",(0,s.jsx)(e.p,{children:"假如我们要做一个语音直播间，在不分层的情况下，我们就把所有代码都梭哈到页面里面："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"calss PageVoiceLiveRoom {\n    // 存储消息\n    private List<String> msgs = new ArrayList();\n    \n    // 负责控制声音\n    private AudioEngine audioEngine;\n    // 负责控制消息\n    private SocketEngine socketEngine;\n    \n    // 绘制UI\n    void drawUI() {\n    }\n        \n    // 打开麦克风\n    void openMic() {\n       audioEngine.openMic();\n    }\n    \n    // 打开扬声器\n    void openSpeaker() {   \n        audioEngine.openSpeaker();\n    }\n    \n    // 发消息\n    void sendMsg(String msg) {\n        socketEngine.sendMsg(msg);\n    }\n    \n    // 收到消息\n    void onReceiveMsg(String msg) {\n        msgs.add(msg);\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"写完感觉美滋滋，我直接把代码全部梭哈到页面上，代码良好运行，一点问题都没有。"}),"\n",(0,s.jsx)(e.p,{children:"突然有一天，产品说要加个小窗功能，小窗的情况下页面不存在，但是声音和逻辑都在。"}),"\n",(0,s.jsx)(e.p,{children:"......"}),"\n",(0,s.jsx)(e.p,{children:"我代码都写在页面上了，你这页面都没了，声音肯定也没了，还运行个毛。"}),"\n",(0,s.jsx)(e.p,{children:"那这得改啊，不能全干在 UI 上，得拆开，UI 只处理 UI，其他的放在非 UI 上才行，这样的话，一旦页面销毁，也只是 UI 相关的销毁，声音和逻辑也都在，改吧。"}),"\n",(0,s.jsx)(e.p,{children:"于是，就有了下面的代码。"}),"\n",(0,s.jsx)(e.p,{children:"首先定义非 UI 逻辑，用来保存数据。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"class VoiceLiveRoomData {\n    // 存储消息\n    private List<String> msgs = new ArrayList();\n    // 负责控制声音\n    private AudioEngine audioEngine;\n    // 负责控制消息\n    private SocketEngine socketEngine;\n    \n    // 打开麦克风\n    void openMic() {\n       audioEngine.openMic();\n    }\n    \n    // 打开扬声器\n    void openSpeaker() {   \n        audioEngine.openSpeaker();\n    }\n    \n    // 发消息\n    void sendMsg(String msg) {\n        socketEngine.sendMsg(msg);\n    }\n    \n    // 收到消息\n    void onReceiveMsg(String msg) {\n        msgs.add(msg);\n        showMsg(msg);\n    }\n\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"然后定义 UI 逻辑，不再存储数据，只是负责展示。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"calss PageVoiceLiveRoom {\n    private VoiceLiveRoomData roomData;\n    \n    // 绘制UI\n    void drawUI() {\n    }\n        \n    // 打开麦克风\n    void openMic() {\n        roomData.openMic();\n    }\n    \n    // 打开扬声器\n    void openSpeaker() {   \n        roomData.openSpeaker();\n    }\n    \n    // 发消息\n    void sendMsg(String msg) {\n        roomData.sendMsg(msg);\n    }\n    \n    // 收到消息\n    void onReceiveMsg(String msg) {\n        showMsg(msg);\n    }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这样以来，UI 部分只负责展示数据和处理 UI 事件，不再存储数据。当 UI 销毁后，",(0,s.jsx)(e.code,{children:"VoiceLiveRoomData"}),"会继续存在，并继续处理非 UI 部分的逻辑，比如存储消息。当 UI 再建立后，直接再次获取一次",(0,s.jsx)(e.code,{children:"VoiceLiveRoomData"}),"即可，数据并没有缺失，声音也没有中断。此时",(0,s.jsx)(e.code,{children:"PageVoiceLiveRoom"}),"就叫做 ",(0,s.jsx)(e.strong,{children:"UI 层"}),"，",(0,s.jsx)(e.code,{children:"VoiceLiveRoomData"}),"就叫做",(0,s.jsx)(e.strong,{children:"数据层"}),"，这也是 MVC 思想的核心。"]}),"\n",(0,s.jsxs)(e.p,{children:["我们可以给它起名叫做：",(0,s.jsx)(e.strong,{children:"数形分离思想"}),"，数是数据，形是图形，也就是 UI。"]}),"\n",(0,s.jsx)(e.p,{children:"那么，代码这样就行了吗？"}),"\n",(0,s.jsx)(e.p,{children:"不行！这并不能完美体现分层思想的优点。"}),"\n",(0,s.jsx)(e.p,{children:"比如：现在我要做一个视频直播间，视频直播间包含了语音直播间的功能，怎么包含呢？"}),"\n",(0,s.jsxs)(e.p,{children:["很简单啊，直接新建一个",(0,s.jsx)(e.code,{children:"VideoLiveRoomData"}),"，让它继承",(0,s.jsx)(e.code,{children:"VoiceLiveRoomData"}),"就行了，子类通过继承可以复用父类功能。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"继承也是分层的一种体现。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"但是，如果我想做一个没有声音没有视频、只能打字的聊天室，要怎么办呢？"}),"\n",(0,s.jsx)(e.p,{children:"这就不能继承了，因为它的功能太少了，它的功能是语音直播间的子集，所以，只能让语音直播间继承它。"}),"\n",(0,s.jsx)(e.p,{children:"所以，我们要改代码，我们的层级应该是下述这样的。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"A：普通直播间，没有语音功能。"}),"\n",(0,s.jsx)(e.li,{children:"B：语音直播间，有语音功能，有 A 的所有功能，是 A 的下级，并且继承 A。"}),"\n",(0,s.jsx)(e.li,{children:"C：视频直播间，有视频功能，有 B 的所有功能，是 B 的下级，并且继承 B。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"好，逻辑理清了，我们就上代码。"}),"\n",(0,s.jsx)(e.p,{children:"普通直播间定义："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// 普通直播间，只有打字功能\ninterface IBaseLiveRoomContext {\n     void sendMsg(String msg);\n}\n\nclass BaseLiveRoomContextImpl implements IBaseLiveRoomContext {\n    private SocketEngine socketEngine;\n    void sendMsg(String msg) {\n        socketEngine.sendMsg(msg);\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"语音直播间定义："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// 语音直播间，有普通直播间的所有功能，并且拓展了语音相关逻辑\ninterface IVoiceLiveRoomContext extends IBaseLiveRoomContext {\n    void openMic();\n    \n    void closeMic();\n    \n    void openSpeaker();\n    \n    void closeSpeaker();\n}\n\nclass VoiceLiveRoomContextImpl extends BaseLiveRoomContextImpl implements IBaseLiveRoomContext {\n    private AudioEngine audioEngine;\n    \n    void openMic() {\n        audioEngine.openMic();\n    }\n    \n    void closeMic() {\n        audioEngine.closeMic();\n    }\n    \n    //.....\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"视频直播间定义："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"// 视频直播间，有语音直播间所有功能，并且拓展了视频相关逻辑\ninterface IVideoLiveRoomContext extends IVoiceLiveRoomContext {    \n    void startPreview();\n    \n    void stopPreview();\n}\n\nclass VideoLiveRoomContext extends VoiceLiveRoomContextImpl implements IVideoLiveRoomContext {\n    private VideoEngine videoEngine;\n    \n    // .......\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"我们看代码就知道，我们的层级关系为："}),"\n",(0,s.jsxs)(e.p,{children:["其中，下级可以使用上级的所有功能，这就是分层的另一个好处：",(0,s.jsx)(e.strong,{children:"复用"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["这类似于树形结构，如果将来出了个新直播间 D，如果 D 具有视频直播间的所有功能，那么直接让 D 继承",(0,s.jsx)(e.code,{children:"VideoLiveRoomContext"}),"即可，也就是放在",(0,s.jsx)(e.code,{children:"VideoLiveRoomContext"}),"的下面；如果 D 没有视频直播间的所有功能呢，但是有语音直播间的所有功能，那么直接让它继承",(0,s.jsx)(e.code,{children:"VoiceLiveRoomContextImpl"}),"即可。"]}),"\n",(0,s.jsx)(e.p,{children:"其实，我们的分层架构，就像是一棵树，新增的功能就是树上的一个节点，总有插入这个节点的地方。这里我们就不废话了，完整的业务代码，我们会在后面第 27 章实现。"}),"\n",(0,s.jsx)(e.p,{children:"分层就是为了每一层能各司其职，互不影响，从而降低耦合，容易拓展。"}),"\n",(0,s.jsxs)(e.h2,{id:"粒度细化思想",children:["粒度细化思想",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#粒度细化思想",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"将大功能拆成一个个的小功能，越小越好。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"一个城市可以拆分成一个个的县，一个县又能拆成一个个的乡，一个乡又能拆成一个个的村，一个村又能拆成一个个的家庭，一个家庭又能拆成一个个的人，如果把城市比喻成沙漠，那么一个个的人就像一粒粒的沙子，这就是粒度细化。"}),"\n",(0,s.jsx)(e.p,{children:"这样有啥好处呢？"}),"\n",(0,s.jsx)(e.p,{children:"比如，我有个模块 A，包含了功能 B1 和 B2，假如，我只想使用 B1 功能，如果模块 A 没有拆分的话，我必须依赖模块 A，这样就可以使用 A 里面的 B1 了，但是这样导致我也依赖了 B2 了，如果将来 B2 有改动，我就不得不跟着变化，这明显是不好的，违背了最少知识原则，也不满足开放闭合原则。"}),"\n",(0,s.jsx)(e.p,{children:"所以，我们要对模块 A 进行拆分，拆分成 B1 和 B2 两个部分，这样，我只需要依赖 B1 即可，B2 的任何改动都不会对我造成任何影响。"}),"\n",(0,s.jsxs)(e.p,{children:["所以，你看，",(0,s.jsx)(e.strong,{children:"粒度细化是不是宏观的接口隔离原则"}),"？接口隔离原则要求接口尽量小，而粒度细化要求模块尽量小。"]}),"\n",(0,s.jsx)(e.p,{children:"那么，粒度是不是越细越好呢？"}),"\n",(0,s.jsx)(e.p,{children:"不是！"}),"\n",(0,s.jsx)(e.p,{children:"比如，一个人的基本功能是吃喝拉撒，你把这四个功能定义给一个人就行，而不需要把每一个功能都单独定义，因为这样就不符合现实了。"}),"\n",(0,s.jsxs)(e.p,{children:["所以，",(0,s.jsx)(e.strong,{children:"粒度的大小要符合常规逻辑"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["而且我们会发现，",(0,s.jsx)(e.strong,{children:"粒度细化思想"}),"也是宏观的",(0,s.jsx)(e.strong,{children:"最少知识原则"}),"，因为功能拆得细，所以跟自身无关的业务就不再包含到自身，比如上述的 B1 就跟 B2 没关系，那么其他模块使用 B1 的时候，也不会跟 B2 有关联，这不正是最少知识原则的体现吗！"]}),"\n",(0,s.jsxs)(e.h2,{id:"易变性思想",children:["易变性思想",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#易变性思想",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"把我们的代码写成容易修改的。"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["还记得我们",(0,s.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196588835345465384",target:"_blank",rel:"noopener noreferrer",children:"第 5 章"}),"讲过的吗：",(0,s.jsx)(e.strong,{children:"优先选择容易变化的数据类型"}),"。其实这就是易变性思想的体现。"]}),"\n",(0,s.jsx)(e.p,{children:"我们在写代码的时候，一定要优先设计成容易变化的，优先使用接口而非对象，优先使用集合而非单一数据。"}),"\n",(0,s.jsx)(e.p,{children:"比如，现在我有个送礼接口，那么我就定义成："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"public void sendGift(long uid,Gift gift) {\n    \n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"其实没毛病，但是，将来有一天，产品要求可以多人送礼，也就是一个礼物可以送给多个人。有人说：这简单啊，遍历用户集合调用这个接口就行了啊。"}),"\n",(0,s.jsx)(e.p,{children:"……来啊，叉出去！"}),"\n",(0,s.jsx)(e.p,{children:"如果有 10000 个人呢？你遍历调用 10000 次吗？你家流量不要钱吗？"}),"\n",(0,s.jsxs)(e.p,{children:["所以，我们应该是将上述的",(0,s.jsx)(e.code,{children:"uid"}),"定义成一个集合，也就是："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:"public void sendGift(List<Long> uids,Gift gift) {\n    \n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样一来，送一个人还是多个人，都没有问题。"}),"\n",(0,s.jsx)(e.p,{children:"所以你看，采用可变的数据类型，是不是减少了工作量。"}),"\n",(0,s.jsx)(e.p,{children:"再看个例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'public void handleInput(String input) {\n    if("Java".equals(input)) {\n        doJava();\n    } else if("javascript".equals(input)) {\n        doJS();\n    } else if("python".equals(input)) {\n        doPython();\n    }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["相信大家都写过这种",(0,s.jsx)(e.code,{children:"if-else"}),'语句，如果条件非常多的话，那简直不要太酸爽；如果条件非常多并且还要加条件的时候，那简直不要太"好欢螺螺蛳粉"。']}),"\n",(0,s.jsxs)(e.p,{children:["这肯定不行啊，不满足",(0,s.jsx)(e.strong,{children:"开放闭合原则"}),"，那就改。"]}),"\n",(0,s.jsxs)(e.p,{children:["我们使用",(0,s.jsx)(e.code,{children:"map"}),"来优化下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-java",children:'\n// 定义一个map\nMap<String, Runnable> actions = new HashMap();\n\n// 将key和value存放在map中\nactions.put("Java", {doJava()})\nactions.put("javascript", {doJS()})\nactions.put("python", {doPython()})\n\npublic void handleInput(String input) {\n    if(actions.containsKey(input)) {\n        actions.get(input).run();\n    }\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["我们的函数处理是不是非常简单了，而且也很容易修改，如果将来有添加或者删除，我们只需要在",(0,s.jsx)(e.code,{children:"map"}),"中添加或者删除就行了，不需要改其他地方，这不正是",(0,s.jsx)(e.strong,{children:"开发闭合原则"}),"吗。"]}),"\n",(0,s.jsxs)(e.p,{children:["再比如，我们",(0,s.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196591861673230371",target:"_blank",rel:"noopener noreferrer",children:"第 21 章"}),"讲到的",(0,s.jsx)(e.strong,{children:"依赖倒置原则"}),"，要求我们尽量依赖接口、依赖抽象，而不是具体的对象。"]}),"\n",(0,s.jsxs)(e.p,{children:["综合上面所有的例子，",(0,s.jsx)(e.code,{children:"List"}),"、",(0,s.jsx)(e.code,{children:"Map"}),"以及接口，它们的共同点都是",(0,s.jsx)(e.code,{children:"可变"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["所以，我们要",(0,s.jsx)(e.strong,{children:"面向可变编程"}),"，这就是",(0,s.jsx)(e.strong,{children:"易变性思想"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"有人说，这跟依赖倒置原则有啥区别呢？"}),"\n",(0,s.jsxs)(e.p,{children:["依赖倒置原则只描述了对象之间的关系，而我们的代码中，除了对象还有函数，还有变量，还有模块等，而这些都可以用易变性思想来描述，或者说：",(0,s.jsx)(e.strong,{children:"易变性思想是宏观层面的依赖倒置原则"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"其实，易变性思想也可以叫做面向拓展编程，或者叫面向未来编程。"}),"\n",(0,s.jsx)(e.p,{children:"代码越容易改变，将来发生改变的时候就越容易修改甚至不需要修改，这就是易变性带来的好处。"}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"本章我们讲了 3 个设计思想，我们再来回顾下。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["分层思想：将逻辑分层处理，不同层各司其职，从而降低代码耦合性，提高拓展性。",(0,s.jsx)(e.strong,{children:"分层思想就是宏观的单一职责原则"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["粒度细化思想：将功能拆分成一个个更小的小功能，从而提高利用率，降低耦合性。",(0,s.jsx)(e.strong,{children:"粒度细化思想就是宏观的接口隔离和最少知识原则"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["易变性思想：采用易变的数据类型和接口，来将代码写成容易修改的，从而提高拓展性。",(0,s.jsx)(e.strong,{children:"易变性思想就是宏观的依赖倒置原则"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"我们发现，每一种思想都是多种设计原则的体现，我们写代码的时候就不需要纠结：到底用哪个设计模式啊？这完全没必要，符合自己的设计才是最好的设计，就像我们上述讲到的直播间架构，它是什么设计模式呢？都不是！但是它却完全符合我们的项目，这就是无招胜有招。"}),"\n",(0,s.jsxs)(e.p,{children:["设计模式只是提供了个模板，属于一种模型，是有限的，有限的模型不可能满足无限的情景，所以我们不必执着于固定的模板，只需要满足：",(0,s.jsx)(e.strong,{children:"拓展性强，影响范围小"}),"。就足够！"]}),"\n",(0,s.jsx)(e.p,{children:"真正的设计师都是先捋清逻辑，想好方案才下手写代码的，那么下一章，我们就来学习设计师必备的基本功：UML 图的绘制。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}let o=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC23%E7%AB%A0%E2%80%94%E6%9E%B6%E6%9E%84%E5%8D%87%E5%8D%8E%EF%BC%9A%E8%84%B1%E7%A6%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md"]={toc:[{text:"分层思想",id:"分层思想",depth:2},{text:"粒度细化思想",id:"粒度细化思想",depth:2},{text:"易变性思想",id:"易变性思想",depth:2},{text:"总结",id:"总结",depth:2}],title:"第23章—架构升华：脱离设计模式",headingTitle:"第23章—架构升华：脱离设计模式",frontmatter:{}}}}]);