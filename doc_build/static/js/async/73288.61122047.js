"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["73288"],{559159:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var c=r(552676),s=r(740453);let d=r.p+"static/image/2c991b494395ae0b63fb8f93f14dbac8.acf75f1f.webp",i=r.p+"static/image/04afd961525d8a247560d0ae33428954.47141007.webp",a=r.p+"static/image/e925ced180689ac3d455624ab6d30da1.2a97df0d.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",strong:"strong",code:"code",ul:"ul",li:"li",pre:"pre",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h3:"h3",ol:"ol"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"20配置篇-_-路由段配置项",children:["20.配置篇 _ 路由段配置项",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#20配置篇-_-路由段配置项",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"之前的文章中已经多次提到了路由段配置项，路由段配置选项可以配置页面、布局、路由处理程序的行为，本篇我们会详细介绍其中的配置内容。"}),"\n",(0,c.jsxs)(n.h2,{id:"1-段segment",children:["1. 段（Segment）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-段segment",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"如果大家翻阅 Next.js 的官方文档（英文），会经常发现 Segment 这个单词，其释义为："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"为了简单起见，我翻译成“段”。Segment 放到 URL 这个场景时："}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"URL Segment"})," 指的是由斜杠分隔的 URL Path 的一部分\n",(0,c.jsx)(n.strong,{children:"URL Path"})," 指的则是域名后面的 URL 部分（URL Path 由 URL Segment 组成）"]}),"\n",(0,c.jsx)(n.p,{children:"用这张图表示更清晰一些："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"Segment 放到 Route 这个场景时："}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Router Segment"}),"，我翻译为“路由段”，路由中的每个文件夹都代表一个路由段。每个路由段都映射一个对应的 URL Segment："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,c.jsxs)(n.p,{children:["在这张图中，",(0,c.jsx)(n.code,{children:"/dashboard/settings"}),"由三段组成："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"/"}),"：根段（Root Segment）"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"dashboard"}),"：段（Segment）"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"settings"}),"：叶段（Leaf Segment）"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"PS：叶段指的是没有子节点的段。"}),"\n",(0,c.jsxs)(n.h2,{id:"2-路由段配置route-segment-config",children:["2. 路由段配置（Route Segment Config）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-路由段配置route-segment-config",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"接下来我们来到本章的正题——路由段配置。"}),"\n",(0,c.jsxs)(n.p,{children:["路由段配置选项可以配置页面、布局、路由处理程序的行为。比如我们使用 fetch 的时候可以单独配置某个请求的 ",(0,c.jsx)(n.code,{children:"revalidate"})," ，借助路由段配置，我们可以配置这个路由下所有 fetch 请求的 ",(0,c.jsx)(n.code,{children:"revalidate"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"路由段配置的使用方式也很简单，导出一个约定变量名即可，比如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// layout.js | page.js | route.js\nexport const dynamic = 'auto'\nexport const dynamicParams = true\nexport const revalidate = false\nexport const fetchCache = 'auto'\nexport const runtime = 'nodejs'\nexport const preferredRegion = 'auto'\nexport const maxDuration = 5\n \nexport default function MyComponent() {}\n"})}),"\n",(0,c.jsx)(n.p,{children:"具体这些变量名和值的类型为："}),"\n",(0,c.jsxs)(n.table,{children:["\n",(0,c.jsxs)(n.thead,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.th,{children:(0,c.jsx)(n.strong,{children:"变量名"})}),"\n",(0,c.jsx)(n.th,{children:(0,c.jsx)(n.strong,{children:"类型"})}),"\n",(0,c.jsx)(n.th,{children:(0,c.jsx)(n.strong,{children:"默认值"})}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.tbody,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic",target:"_blank",rel:"noopener noreferrer",children:"dynamic"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"'auto' | 'force-dynamic' | 'error' | 'force-static'"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"'auto'"})}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams",target:"_blank",rel:"noopener noreferrer",children:"dynamicParams"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"boolean"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"true"})}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#revalidate",target:"_blank",rel:"noopener noreferrer",children:"revalidate"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"false | 'force-cache' | 0 | number"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"false"})}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#fetchcache",target:"_blank",rel:"noopener noreferrer",children:"fetchCache"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"'auto' | 'default-cache' | 'only-cache' | 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"'auto'"})}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#runtime",target:"_blank",rel:"noopener noreferrer",children:"runtime"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"'nodejs' | 'edge'"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"'nodejs'"})}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#preferredregion",target:"_blank",rel:"noopener noreferrer",children:"preferredRegion"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"'auto' | 'global' | 'home' | string | string[]"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"'auto'"})}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#maxduration",target:"_blank",rel:"noopener noreferrer",children:"maxDuration"})}),"\n",(0,c.jsx)(n.td,{children:(0,c.jsx)(n.code,{children:"number"})}),"\n",(0,c.jsx)(n.td,{children:"部署平台设置"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["注意配置选项的值目前是静态分析的，也就是说，配置",(0,c.jsx)(n.code,{children:"revalidate = 600"}),"是有效的，但是 ",(0,c.jsx)(n.code,{children:"revalidate = 60 * 10"}),"是无效的。"]}),"\n",(0,c.jsx)(n.p,{children:"我们来一一讲解这些配置选项的作用。"}),"\n",(0,c.jsxs)(n.h3,{id:"21-dynamic",children:["2.1. dynamic",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-dynamic",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"更改布局或者页面的动态行为，用例如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// layout.js | page.js | route.js\nexport const dynamic = 'auto'\n// 'auto' | 'force-dynamic' | 'error' | 'force-static'\n"})}),"\n",(0,c.jsx)(n.p,{children:"为了讲解 dynamic 参数的选项，我们先复习下基础知识："}),"\n",(0,c.jsxs)(n.p,{children:["所谓",(0,c.jsx)(n.strong,{children:"静态渲染（Static Rendering）"}),"，指的是路由在构建时渲染，或者在重新验证后后台渲染，其结果会被缓存并可以推送到 CDN。适用于未针对用户个性化且数据已知的情况，比如静态博客文章、产品介绍页面等。"]}),"\n",(0,c.jsxs)(n.p,{children:["所谓",(0,c.jsx)(n.strong,{children:"动态渲染（Dynamic Rendering）"}),"，指的是路由在请求时渲染，适用于针对用户个性化或依赖请求中的信息（如 cookie、URL 参数）的情况。"]}),"\n",(0,c.jsxs)(n.p,{children:["因为渲染模式和数据缓存是相互独立的，所以在动态渲染下，数据请求也分为缓存和不缓存（",(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching",target:"_blank",rel:"noopener noreferrer",children:"uncached data request"}),"）的。默认是缓存，这样做的好处在于，即便选择了动态渲染，也不用担心渲染时获取所有数据对性能造成影响。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"dynamic"})," 影响的不仅是渲染模式，也会影响数据缓存的方式。"]}),"\n",(0,c.jsxs)(n.p,{children:["还有一个名词叫",(0,c.jsx)(n.strong,{children:"动态函数（Dynamic Functions）"}),"，指的是获取只能在请求时才能得到的信息（如 cookie、请求头、URL 参数）的函数，在 Next.js 中，对应的就是 ",(0,c.jsx)(n.code,{children:"cookies()"}),"、",(0,c.jsx)(n.code,{children:"headers()"}),"、",(0,c.jsx)(n.code,{children:"useSearchParams()"}),"、",(0,c.jsx)(n.code,{children:"searchParams()"})," 这些函数。如果使用了这些函数的任意一个，都会导致路由进行动态渲染。"]}),"\n",(0,c.jsxs)(n.p,{children:["接下来我们讲解 ",(0,c.jsx)(n.code,{children:"dynamic"})," 的值都有哪些作用："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'auto'"}),"（默认）：自动判断"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'force-dynamic'"}),"，强制动态渲染和退出所有 fetch 请求缓存，相当于：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Page Router 下使用了 ",(0,c.jsx)(n.code,{children:"getServerSideProps()"})]}),"\n",(0,c.jsxs)(n.li,{children:["将布局或页面中每个 ",(0,c.jsx)(n.code,{children:"fetch()"})," 请求都设置为 ",(0,c.jsx)(n.code,{children:"{ cache: 'no-store', next: { revalidate: 0 } }"})]}),"\n",(0,c.jsxs)(n.li,{children:["设置了路由段配置 ",(0,c.jsx)(n.code,{children:"export const fetchCache = 'force-no-store'"})]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'error'"}),"强制静态渲染并缓存数据，如果有组件使用了动态函数或不缓存数据请求（",(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching",target:"_blank",rel:"noopener noreferrer",children:"uncached data request"}),"），就会导致错误，相当于：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["Page Router 下使用了",(0,c.jsx)(n.code,{children:"getStaticProps()"})]}),"\n",(0,c.jsxs)(n.li,{children:["将布局或页面中每个 ",(0,c.jsx)(n.code,{children:"fetch()"})," 请求都设置为 ",(0,c.jsx)(n.code,{children:"{ cache: 'force-cache' }"})]}),"\n",(0,c.jsxs)(n.li,{children:["设置了路由段配置 ",(0,c.jsx)(n.code,{children:"fetchCache = 'only-cache', dynamicParams = false"})]}),"\n",(0,c.jsxs)(n.li,{children:["设置",(0,c.jsx)(n.code,{children:"dynamic = 'error'"})," 会更改 ",(0,c.jsx)(n.code,{children:"dynamicParams"})," 的默认值 ",(0,c.jsx)(n.code,{children:"true"})," 为 ",(0,c.jsx)(n.code,{children:"false"})]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'force-static'"})," 强制静态渲染并缓存数据，强制 ",(0,c.jsx)(n.code,{children:"cookies()"}),"、",(0,c.jsx)(n.code,{children:"headers()"}),"、",(0,c.jsx)(n.code,{children:"useSearchParams()"})," 返回空值。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"22-dynamicparams",children:["2.2. dynamicParams",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-dynamicparams",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["控制当访问不是由 ",(0,c.jsx)(n.code,{children:"generateStaticParams"})," 生成的动态路由段的时候发生什么。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// layout.jsx | page.jsx\nexport const dynamicParams = true // true | false,\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"true"}),"（默认）：按需生成"]}),"\n",(0,c.jsx)(n.li,{children:"false：返回 404"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这个选项对应 Page Router 下的 ",(0,c.jsx)(n.code,{children:"getStaticPaths"})," 的 ",(0,c.jsx)(n.code,{children:"fallback: true | false | blocking"}),"选项。"]}),"\n",(0,c.jsxs)(n.p,{children:["如果使用了 ",(0,c.jsx)(n.code,{children:"dynamic = 'error'"})," 和 ",(0,c.jsx)(n.code,{children:"dynamic = 'force-static'"}),"，它会更改 ",(0,c.jsx)(n.code,{children:"dynamicParams"})," 的默认值为 ",(0,c.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"23-revalidate",children:["2.3. revalidate",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-revalidate",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["设置布局或者页面的默认验证时间。此设置不会覆盖单个 ",(0,c.jsx)(n.code,{children:"fetch"})," 请求设置的 ",(0,c.jsx)(n.code,{children:"revalidate"})," 的值。注意 ",(0,c.jsx)(n.code,{children:"revalidate"})," 选项只能用于 Nodejs Runtime，不能用于 Edge Runtime。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// layout.jsx | page.jsx | route.js\nexport const revalidate = false\n// false | 'force-cache' | 0 | number\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"false"}),"（默认），语义上相当于 ",(0,c.jsx)(n.code,{children:"revalidate: Infinity"}),"，资源无限期缓存。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"0"}),"，页面或布局总是动态渲染，即使没有使用动态函数或者不缓存数据请求（",(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching",target:"_blank",rel:"noopener noreferrer",children:"uncached data request"}),"）。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"number"})," ：设置布局或页面的默认重新验证频率，以秒为单位。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["关于重新验证频率，一个路由可能有多个布局和一个页面，此时会选择最低的 ",(0,c.jsx)(n.code,{children:"revalidate"})," 值作为路由的重新验证频率。这是为了确保子路由的重新验证时间频率和父布局保持一致。此外，单个 fetch 请求可以设置比路由默认的 ",(0,c.jsx)(n.code,{children:"revalidate"})," 值更低的 ",(0,c.jsx)(n.code,{children:"revalidate"})," 值，这会增加整个路由的重新验证频率。这允许你根据某些动态条件进行更频繁的重新验证。"]}),"\n",(0,c.jsxs)(n.h3,{id:"24-fetchcache",children:["2.4. fetchCache",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-fetchcache",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这是一个高级选项，仅当你特别需要覆盖默认行为时才应该使用。为了解释这个选项，我们先复习下 fetch 请求的 ",(0,c.jsx)(n.code,{children:"options.cache"})," 选项："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"fetch(`https://...`, { cache: 'force-cache' | 'no-store' })\n"})}),"\n",(0,c.jsxs)(n.p,{children:["其中 ",(0,c.jsx)(n.code,{children:"force-cache"}),"是默认值，表示优先从缓存中查找匹配请求，当没有匹配项或者匹配项过时时，才从服务器上获取资源并更新缓存。",(0,c.jsx)(n.code,{children:"no-store"}),"表示每次请求都从服务器上获取资源，不从缓存中查，也不更新缓存。"]}),"\n",(0,c.jsxs)(n.p,{children:["回到 Next.js，默认情况下，Next.js 会缓存在动态函数使用之前的 ",(0,c.jsx)(n.code,{children:"fetch"})," 请求，不会缓存任何动态函数之后的",(0,c.jsx)(n.code,{children:"fetch"})," 请求。而 ",(0,c.jsx)(n.code,{children:"fetchCache"})," 允许你覆盖布局或者页面中所有的 ",(0,c.jsx)(n.code,{children:"fetch"}),"请求的默认 ",(0,c.jsx)(n.code,{children:"cache"}),"选项。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// layout.jsx | page.jsx | route.js\nexport const fetchCache = 'auto'\n// 'auto' | 'default-cache' | 'only-cache'\n// 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'auto'"}),"（默认）：动态函数之前按照开发者设置的 ",(0,c.jsx)(n.code,{children:"cache"})," 选项进行缓存，动态函数之后不缓存请求"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'default-cache'"}),"：开发者可以自由设置 ",(0,c.jsx)(n.code,{children:"cache"})," 选项，但如果开发者未设置 ",(0,c.jsx)(n.code,{children:"cache"})," 选项，默认设置为 ",(0,c.jsx)(n.code,{children:"force-cache"}),"，这意味着即使是在动态函数之后的请求，也会被视为静态"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'only-cache'"}),"：如果开发者未设置 ",(0,c.jsx)(n.code,{children:"cache"})," 选项，默认设置为 ",(0,c.jsx)(n.code,{children:"force-cache"}),"，如果有请求设置成 ",(0,c.jsx)(n.code,{children:"cache: 'no-store'"}),"，则会导致报错"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'force-cache'"}),"：将所有请求的 ",(0,c.jsx)(n.code,{children:"cache"})," 选项设置为 ",(0,c.jsx)(n.code,{children:"force-cache"})," 。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'default-no-store'"}),"：开发者可以自由设置 ",(0,c.jsx)(n.code,{children:"cache"})," 选项，但如果开发者未设置 ",(0,c.jsx)(n.code,{children:"cache"})," 选项，默认设置为 ",(0,c.jsx)(n.code,{children:"no-store"}),"，这意味着即使是在动态函数之前的请求，也会被视为动态。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'only-no-store'"}),"：如果开发者未设置 ",(0,c.jsx)(n.code,{children:"cache"})," 选项，默认设置为 ",(0,c.jsx)(n.code,{children:"no-store"}),"，如果有请求设置成 ",(0,c.jsx)(n.code,{children:"cache: 'force-cache'"}),"，则会导致报错"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'force-no-store'"}),"：将所有请求的 ",(0,c.jsx)(n.code,{children:"cache"})," 选项设置为 ",(0,c.jsx)(n.code,{children:"no-store"})," 。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"一个路由可能有多个布局和一个页面，此时选项应该相互兼容："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["如何 ",(0,c.jsx)(n.code,{children:"'only-cache'"})," 和 ",(0,c.jsx)(n.code,{children:"'force-cache'"})," 同时提供，",(0,c.jsx)(n.code,{children:"'force-cache'"})," 获胜。如果 ",(0,c.jsx)(n.code,{children:"'only-no-store'"})," 和 ",(0,c.jsx)(n.code,{children:"'force-no-store'"}),"同时提供，",(0,c.jsx)(n.code,{children:"'force-no-store'"}),"获胜。带 ",(0,c.jsx)(n.code,{children:"force"})," 的选项会更改整个路由的行为，并会阻止 ",(0,c.jsx)(n.code,{children:"'only-*'"})," 引发的错误。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"'only-*'"})," 和 ",(0,c.jsx)(n.code,{children:"force-*'"}),"选项的作用就是确保整个路由要么是完全静态要么是完全动态，这意味着：","\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["在单个路由中不允许同时使用 ",(0,c.jsx)(n.code,{children:"'only-cache'"}),"和 ",(0,c.jsx)(n.code,{children:"'only-no-store'"})]}),"\n",(0,c.jsxs)(n.li,{children:["在单个路由中不允许同时使用 ",(0,c.jsx)(n.code,{children:"'force-cache'"}),"和 ",(0,c.jsx)(n.code,{children:"'force-no-store'"})]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["如果子级提供了 ",(0,c.jsx)(n.code,{children:"'auto'"}),"或  ",(0,c.jsx)(n.code,{children:"'*-cache'"}),"，父级无法使用 ",(0,c.jsx)(n.code,{children:"'default-no-store'"}),"，因为这会导致请求有不同的行为。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["Next.js 建议共享的父布局使用 ",(0,c.jsx)(n.code,{children:"'auto'"}),"，在子级中自定义不同的选项。"]}),"\n",(0,c.jsxs)(n.h3,{id:"25-runtime",children:["2.5. runtime",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-runtime",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["设置运行时环境，具体参考小册",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309076865732640818",target:"_blank",rel:"noopener noreferrer",children:"《渲染篇 | Streaming 和 Edge Runtime》"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// layout.jsx | page.jsx | route.js\nexport const runtime = 'nodejs'\n// 'edge' | 'nodejs'\n"})}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"nodejs"}),"（默认）"]}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"edge"})}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"26-preferredregion",children:["2.6. preferredRegion",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26-preferredregion",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.a,{href:"https://vercel.com/docs/functions/serverless-functions",target:"_blank",rel:"noopener noreferrer",children:"Vercel Serverless Functions"})," 中使用，搭配 ",(0,c.jsx)(n.code,{children:"export const runtime = 'edge'; "}),"，用于设置 ",(0,c.jsx)(n.a,{href:"https://vercel.com/docs/functions/configuring-functions/region",target:"_blank",rel:"noopener noreferrer",children:"Edge Functions"})," 执行的区域，默认情况下，Edge Functions 在最接近传入请求的区域中执行，但如果你的函数比较依赖数据源，你会更希望它靠近数据源所在的位置以实现快速响应，那就可以设置 preferredRegion 指定一系列首选区域。"]}),"\n",(0,c.jsxs)(n.p,{children:["指定区域的时候，传入的是区域 ID，区域列表参考 ",(0,c.jsx)(n.a,{href:"https://vercel.com/docs/edge-network/regions",target:"_blank",rel:"noopener noreferrer",children:"Vercel 的 Region List 文档"}),"，其中 iad1 表示美国东部区域，参考位置美国华盛顿地区，sfo1 表示美国西部，参考位置美国旧金山。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"// layout.jsx | page.jsx | route.js\nexport const preferredRegion = 'auto'\n// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"27-maxduration",children:["2.7. maxDuration",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#27-maxduration",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.a,{href:"https://vercel.com/docs/functions/serverless-functions",target:"_blank",rel:"noopener noreferrer",children:"Vercel Serverless Functions"})," 中使用，用于配置 ",(0,c.jsx)(n.a,{href:"https://vercel.com/docs/functions/configuring-functions/duration",target:"_blank",rel:"noopener noreferrer",children:"Vercel 函数"}),"的最大持续时间，所谓 Max duration，指的是函数在响应之前可以处理 HTTP 请求的最长时间。如果持续时间内没有响应，则会返回错误码。如果没有指定，根据不同的部署平台，默认时间会不同。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"export const maxDuration = 5\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"28-generatestaticparams",children:["2.8 generateStaticParams",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#28-generatestaticparams",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["与动态路由搭配使用，用于定义静态生成的路由段参数。具体内容参考小册",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-1",target:"_blank",rel:"noopener noreferrer",children:"《API 篇 | 路由相关的常用方法》"})]}),"\n",(0,c.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config",target:"_blank",rel:"noopener noreferrer",children:"https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://vercel.com/docs/functions/configuring-functions/region",target:"_blank",rel:"noopener noreferrer",children:"https://vercel.com/docs/functions/configuring-functions/region"})}),"\n"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(o,{...e})}):o(e)}let h=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F20.%E9%85%8D%E7%BD%AE%E7%AF%87%20_%20%E8%B7%AF%E7%94%B1%E6%AE%B5%E9%85%8D%E7%BD%AE%E9%A1%B9.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. 段（Segment）",id:"1-段segment",depth:2},{text:"2. 路由段配置（Route Segment Config）",id:"2-路由段配置route-segment-config",depth:2},{text:"2.1. dynamic",id:"21-dynamic",depth:3},{text:"2.2. dynamicParams",id:"22-dynamicparams",depth:3},{text:"2.3. revalidate",id:"23-revalidate",depth:3},{text:"2.4. fetchCache",id:"24-fetchcache",depth:3},{text:"2.5. runtime",id:"25-runtime",depth:3},{text:"2.6. preferredRegion",id:"26-preferredregion",depth:3},{text:"2.7. maxDuration",id:"27-maxduration",depth:3},{text:"2.8 generateStaticParams",id:"28-generatestaticparams",depth:3},{text:"参考链接",id:"参考链接",depth:2}],title:"20.配置篇 _ 路由段配置项",headingTitle:"20.配置篇 _ 路由段配置项",frontmatter:{}}}}]);