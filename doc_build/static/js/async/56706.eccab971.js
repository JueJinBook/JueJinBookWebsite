"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56706"],{819636:function(e,n,s){s.r(n),s.d(n,{default:()=>x});var t=s(552676),i=s(740453);let l=s.p+"static/image/3f0337154535543968e5b944f32b9282.71849df8.gif",d=s.p+"static/image/16eea4477a5ef8ea86d647c92d7f79ec.539d8e4b.webp",a=s.p+"static/image/f9190335f9fbc40a559d6d915d6ab03e.e2a4a7db.webp",r=s.p+"static/image/85cdb5769b68b6eeb282d0e9b96a392f.981deb1a.webp",c=s.p+"static/image/00e9a81d4325d10929e3866799d09861.65e2c52e.webp",o=s.p+"static/image/9f2ec59dc279fd82ac928ec09cdfb961.796301fb.webp",h=s.p+"static/image/aff39bf17e8d88b5f9a1c15e06812dfa.bf294ef4.gif",m=s.p+"static/image/4c1d7d42bbbc71169732f5c46562a2d6.dec323f4.webp";function p(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",code:"code",pre:"pre",h3:"h3",ol:"ol",li:"li",strong:"strong",ul:"ul"},(0,i.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"39实战篇-_-react-notes-_-笔记预览界面",children:["39.实战篇 _ React Notes _ 笔记预览界面",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#39实战篇-_-react-notes-_-笔记预览界面",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"本篇我们来实现右侧笔记预览部分。"}),"\n",(0,t.jsxs)(n.h2,{id:"笔记预览",children:["笔记预览",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#笔记预览",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"当点击笔记的时候，可以查看该笔记的内容："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["按照我们之前的设计，当点击左侧笔记列表的时候，会导航至对应的 ",(0,t.jsx)(n.code,{children:"/note/xxxx"}),"路由，所以我们再新建一个 ",(0,t.jsx)(n.code,{children:"app/note/[id]/page.js"}),"文件，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:"import Note from '@/components/Note'\nimport {getNote} from '@/lib/redis';\n\nexport default async function Page({ params }) {\n  // 动态路由 获取笔记 id\n  const noteId = params.id;\n  const note = await getNote(noteId)\n\n  // 为了让 Suspense 的效果更明显\n  const sleep = ms => new Promise(r => setTimeout(r, ms));\n  await sleep(5000);\n\n  if (note == null) {\n    return (\n      <div className=\"note--empty-state\">\n        <span className=\"note-text--empty-state\">\n          Click a note on the left to view something! \uD83E\uDD7A\n        </span>\n      </div>\n    )\n  }\n\n  return <Note noteId={noteId} note={note} />\n}\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["还记得上篇总结的最佳实践吗？用到数据请求的地方，考虑一下是否需要用 ",(0,t.jsx)(n.code,{children:"Suspense"})," 和 ",(0,t.jsx)(n.code,{children:"loading.js"}),"。这里就是一个很适合用 ",(0,t.jsx)(n.code,{children:"loading.js"})," 的地方，我们再添加一个 ",(0,t.jsx)(n.code,{children:"app/note/[id]/loading.js"}),"文件，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'export default function NoteSkeleton() {\n  return (\n    <div\n      className="note skeleton-container"\n      role="progressbar"\n      aria-busy="true"\n    >\n      <div className="note-header">\n        <div\n          className="note-title skeleton"\n          style={{ height: \'3rem\', width: \'65%\', marginInline: \'12px 1em\' }}\n        />\n        <div\n          className="skeleton skeleton--button"\n          style={{ width: \'8em\', height: \'2.5em\' }}\n        />\n      </div>\n      <div className="note-preview">\n        <div className="skeleton v-stack" style={{ height: \'1.5em\' }} />\n        <div className="skeleton v-stack" style={{ height: \'1.5em\' }} />\n        <div className="skeleton v-stack" style={{ height: \'1.5em\' }} />\n        <div className="skeleton v-stack" style={{ height: \'1.5em\' }} />\n        <div className="skeleton v-stack" style={{ height: \'1.5em\' }} />\n      </div>\n    </div>\n  )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["我们在 ",(0,t.jsx)(n.code,{children:"page.js"}),"中引入了",(0,t.jsx)(n.code,{children:" <Note>"})," 组件，",(0,t.jsx)(n.code,{children:"components/Note.js"}),"的代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'import dayjs from \'dayjs\';\nimport NotePreview from \'@/components/NotePreview\'\nimport EditButton from \'@/components/EditButton\'\nexport default function Note({ noteId, note }) {\n  const { title, content, updateTime } = note\n\n  return (\n    <div className="note">\n      <div className="note-header">\n        <h1 className="note-title">{title}</h1>\n        <div className="note-menu" role="menubar">\n          <small className="note-updated-at" role="status">\n            Last updated on {dayjs(updateTime).format(\'YYYY-MM-DD hh:mm:ss\')}\n          </small>\n            <EditButton noteId={noteId}>Edit</EditButton>\n        </div>\n      </div>\n      <NotePreview>{content}</NotePreview>\n    </div>\n  )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["这里我们把预览的部分又单独抽离成了一个 ",(0,t.jsx)(n.code,{children:"<NotePreview>"})," 组件，之所以抽离，是考虑到在编辑界面复用。",(0,t.jsx)(n.code,{children:"components/NotePreview.js"}),"的代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import {marked} from 'marked'\nimport sanitizeHtml from 'sanitize-html'\n\nconst allowedTags = sanitizeHtml.defaults.allowedTags.concat([\n  'img',\n  'h1',\n  'h2',\n  'h3'\n])\nconst allowedAttributes = Object.assign(\n  {},\n  sanitizeHtml.defaults.allowedAttributes,\n  {\n    img: ['alt', 'src']\n  }\n)\n\nexport default function NotePreview({ children }) {\n  return (\n    <div className=\"note-preview\">\n      <div\n        className=\"text-with-markdown\"\n        dangerouslySetInnerHTML={{\n          __html: sanitizeHtml(marked(children || ''), {\n            allowedTags,\n            allowedAttributes\n          })\n        }}\n      />\n    </div>\n  )\n}\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["其中，",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/marked",target:"_blank",rel:"noopener noreferrer",children:"marked"})," 是一个把 markdown 转换为 HTML 的库，",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/sanitize-html",target:"_blank",rel:"noopener noreferrer",children:"sanitize-html"})," 用于清理 HTML，比如删除一些不良的写法，转义特殊字符等。因为用到了这两个库，我们还需要安装一下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm i marked sanitize-html\n"})}),"\n",(0,t.jsx)(n.p,{children:"此时页面已经可以正常运行了，效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"笔记预览.gif"})}),"\n",(0,t.jsxs)(n.h2,{id:"原理解析",children:["原理解析",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原理解析",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"rsc-payload",children:["RSC Payload",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rsc-payload",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"现在让我们多点击几次左侧的笔记列表，切换查看不同的笔记。你会发现，页面的地址虽然发生了变化，但页面并没有重新加载，但是页面的内容确实发生了变化，Next.js 是怎么实现的呢？"}),"\n",(0,t.jsxs)(n.p,{children:["让我们查看下点击笔记时的请求（执行 ",(0,t.jsx)(n.code,{children:"npm run start"}),"时）："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"截屏2023-12-16 下午7.58.57.png"})}),"\n",(0,t.jsxs)(n.p,{children:["点击笔记的时候，我们请求了对应路由的地址，比如我们点击第一篇笔记的时候，这篇笔记的 ",(0,t.jsx)(n.code,{children:"noteId"})," 为 ",(0,t.jsx)(n.code,{children:"1702459188837"}),"，发出的请求地址就对应为 ",(0,t.jsx)(n.code,{children:"http://localhost:3000/note/1702459188837?_rsc=9ehs5"}),"，Chrome 标注这条请求的 Type 是 fetch，返回的数据为："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'3:I[5613,[],""]\n5:I[1778,[],""]\n4:["id","1702459188837","d"]\n0:["S5DEOJMw4dANsj-nNd4RK",[["children","note",["note",{"children":[["id","1702459188837","d"],{"children":["__PAGE__",{}]}]}],["note",{"children":[["id","1702459188837","d"],{"children":["__PAGE__",{},["$L1","$L2",null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","note","children","$4","children"],"loading":["$","div",null,{"className":"note skeleton-container","role":"progressbar","aria-busy":"true","children":[["$","div",null,{"className":"note-header","children":[["$","div",null,{"className":"note-title skeleton","style":{"height":"3rem","width":"65%","marginInline":"12px 1em"}}],["$","div",null,{"className":"skeleton skeleton--button","style":{"width":"8em","height":"2.5em"}}]]}],["$","div",null,{"className":"note-preview","children":[["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}]]}]]}],"loadingStyles":[],"loadingScripts":[],"hasLoading":true,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","note","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]],[null,"$L6"]]]]\n6:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]\n1:null\n7:I[5250,["250","static/chunks/250-3c648b94097e3c7b.js","156","static/chunks/app/note/%5Bid%5D/page-5070a024863ac55b.js"],""]\n2:["$","div",null,{"className":"note","children":[["$","div",null,{"className":"note-header","children":[["$","h1",null,{"className":"note-title","children":"ea molestias"}],["$","div",null,{"className":"note-menu","role":"menubar","children":[["$","small",null,{"className":"note-updated-at","role":"status","children":["Last updated on ","2023-12-13 05:19:48"]}],["$","$L7",null,{"href":"/note/edit/1702459188837","className":"link--unstyled","children":["$","button",null,{"className":"edit-button edit-button--outline","role":"menuitem","children":"Edit"}]}]]}]]}],["$","div",null,{"className":"note-preview","children":["$","div",null,{"className":"text-with-markdown","dangerouslySetInnerHTML":{"__html":"<p>et iusto sed quo iure</p>\\n"}}]}]]}]\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"注：如果你用 Chrome 查看数据的时候，发现无法加载响应数据，那换成其他浏览器如火狐试试。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["这个数据就被称为 ",(0,t.jsx)(n.code,{children:"React Server Components Payload"}),"，简称 ",(0,t.jsx)(n.code,{children:"RSC Payload"}),"，其实你看这个地址的参数",(0,t.jsx)(n.code,{children:"?rsc=xxxx"}),"其实就暗示了它跟 RSC 相关。查看返回的数据 ，你会发现这个数据很奇怪，既不是我们常见的 HTML、XML，也不是什么其他格式，这就是 React 定义的一种特殊的格式。"]}),"\n",(0,t.jsxs)(n.p,{children:["还记得",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-19",target:"_blank",rel:"noopener noreferrer",children:"《 缓存篇 | Caching》"}),"中讲到 RSC Payload 包含哪些信息吗："]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"服务端组件的渲染结果"}),"\n",(0,t.jsx)(n.li,{children:"客户端组件的占位位置和引用文件"}),"\n",(0,t.jsx)(n.li,{children:"从服务端组件传给客户端组件的数据"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["比如以 ",(0,t.jsx)(n.code,{children:"0:"})," 开头的那行，根据其中的内容，可以判断出渲染的是笔记加载时的骨架图。以 ",(0,t.jsx)(n.code,{children:"2:"}),"开头的那行，渲染的则是笔记的具体内容。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"使用这种格式的优势在于它针对流做了优化，数据是分行的，它们可以以流的形式逐行从服务端发送给客户端，客户端可以逐行解析 RSC Payload，渐进式渲染页面。"})}),"\n",(0,t.jsxs)(n.p,{children:["比如客户端收到 ",(0,t.jsx)(n.code,{children:"0:"}),"开头的这行，于是开始渲染骨架图。收到 ",(0,t.jsx)(n.code,{children:"7:"}),"开头的这行，发现需要下载 ",(0,t.jsx)(n.code,{children:"static/chunks/app/note/[id]/page-5070a024863ac55b.js"}),"，于是开始请求该 JS 文件，查看刚才的请求，也确实请求了该文件。收到 ",(0,t.jsx)(n.code,{children:"2:"}),"开头的这行，于是开始渲染笔记的具体内容。"]}),"\n",(0,t.jsxs)(n.p,{children:["因为我们特地设置了请求时间大于 5s，所以 ",(0,t.jsx)(n.code,{children:"2:"}),"开头的那行数据返回的时候肯定比 ",(0,t.jsx)(n.code,{children:"0:"}),"晚了 ",(0,t.jsx)(n.code,{children:"5s"}),"以上，这条请求的时长也确实大于了 5s，这也应证了 RSC Payload 服务端是逐行返回，客户端是逐行解析、渐进式渲染的。"]}),"\n",(0,t.jsxs)(n.p,{children:["注：你可能发现，还有一个 404 的 RSC Payload 请求，它请求的地址是 ",(0,t.jsx)(n.code,{children:"/note/edit/170245918883"}),"，这是因为渲染出的 Edit 按钮用的是 Link 组件，Link 组件有预获取，所以触发了请求，但因为这个路由我们还没写，所以出现了 404 错误。其实跟本篇要讲的内容无关。"]}),"\n",(0,t.jsxs)(n.p,{children:["现在我们将 ",(0,t.jsx)(n.code,{children:"http://localhost:3000/note/1702459188837?_rsc=9ehs5"}),"这个地址在新标签页中打开，你会发现还是这个请求地址，返回的却是 HTML："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"至于怎么实现的，想必你也想到了，两个请求虽然地址一样，但请求头不一样。这是返回 RSC Payload 的请求头："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:"截屏2023-12-16 下午8.45.08.png"})}),"\n",(0,t.jsx)(n.p,{children:"这是返回 HTML 的请求头："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"那在这个 HTML 中又是怎么实现初始加载骨架图，然后 5s 后加载笔记数据的呢？"}),"\n",(0,t.jsx)(n.p,{children:"这节在上一篇已经讲过了。简单的来说，该 HTML 也是流式传输，会先后返回骨架图和笔记数据："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n    <body>\n        <div class="container">\n            <div class="main">\n                <section class="col note-viewer">\n                    \x3c!-- 笔记加载时的骨架图 --\x3e\n                    <template id="B:1"></template>\n                    <div class="note skeleton-container" role="progressbar" aria-busy="true">\n                        <div class="note-header">\n                            <div class="note-title skeleton" style="height:3rem;width:65%;margin-inline:12px 1em"></div>\n                            <div class="skeleton skeleton--button" style="width:8em;height:2.5em"></div>\n                        </div>\n                        <div class="note-preview">\n                            <div class="skeleton v-stack" style="height:1.5em"></div>\n                            <div class="skeleton v-stack" style="height:1.5em"></div>\n                            <div class="skeleton v-stack" style="height:1.5em"></div>\n                            <div class="skeleton v-stack" style="height:1.5em"></div>\n                            <div class="skeleton v-stack" style="height:1.5em"></div>\n                        </div>\n                    </div>\n                    \x3c!--/$--\x3e\n                </section>\n            </div>\n        </div>\n      	// ...\n        <div hidden id="S:1">\n            <div class="note">\n                <div class="note-header">\n                    <h1 class="note-title">ea molestias</h1>\n                    <div class="note-menu" role="menubar">\n                        <small class="note-updated-at" role="status">Last updated on \n                        \x3c!-- --\x3e\n                        2023-12-13 05:19:48</small>\n                        <a class="link--unstyled" href="/note/edit/1702459188837">\n                            <button class="edit-button edit-button--outline" role="menuitem">Edit</button>\n                        </a>\n                    </div>\n                </div>\n                <div class="note-preview">\n                    <div class="text-with-markdown">\n                        <p>et iusto sed quo iure</p>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <script>\n            // 替换内容\n            $RC = function(b, c, e) { // ... }\n            $RC("B:1", "S:1")\n        <\/script>\n        // ...\n    </body>\n</html>\n\n'})}),"\n",(0,t.jsx)(n.p,{children:"我们接着讲 RSC Payload，那客户端获取到 RSC Payload 后还干了什么呢？其实就是根据 RSC Payload 重新渲染组件树，修改 DOM。但使用 RSC Payload 的好处在于组件树中的状态依然会被保持，比如左侧笔记列表的展开和收回就是一种客户端状态，当你新增笔记、删除笔记时，虽然组件树被重新渲染，但是客户端的状态依然会继续保持了。"}),"\n",(0,t.jsx)(n.p,{children:"这也被认为是 SSR 和 RSC 的最大区别，其实现的关键就在于服务端组件没有被渲染成 HTML，而是一种特殊的格式（RSC Payload）。这里让我们再复习下 SSR（传统的 SSR，想想 Pages Router 下的 SSR 实现） 和 RSC 的区别："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"RSC 的代码不会发送到客户端，但传统 SSR 所有组件的代码都会被发送到客户端"}),"\n",(0,t.jsx)(n.li,{children:"RSC 可以在组件树中任意位置获取后端，传统 SSR 只能在顶层（getServerSideProps）访问后端"}),"\n",(0,t.jsx)(n.li,{children:"服务器组件可以重新获取，而不会丢失其树内的客户端状态"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"注：这里虽然比较了 SSR 和 RSC，但并不是说明两者是冲突的，其实 SSR 和 RSC 是互补关系，是可以一起使用的，Next.js 中两者就是一起使用的。"}),"\n",(0,t.jsxs)(n.h3,{id:"路由缓存",children:["路由缓存",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由缓存",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"现在让我们再多点击几次左侧的笔记列表，切换查看不同的笔记，你会发现有一件奇怪的事情（这个 GIF 有 30 多秒）："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"路由缓存.gif"})}),"\n",(0,t.jsx)(n.p,{children:"点击切换不同的笔记，你会发现同样一条笔记，有时会触发数据的重新请求（出现了骨架图），但有的时候又没有，但有的时候又会重新出现（又出现了骨架图），这是为什么吗？"}),"\n",(0,t.jsxs)(n.p,{children:["这就是 Next.js 提供的客户端路由缓存功能，客户端会缓存 RSC Payload 数据，所以当点击笔记后很快再次点击，这时就会从缓存中获取数据，那么问题来了，缓存的失效逻辑还记得吗？具体会缓存多久呢？我们在",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-20",target:"_blank",rel:"noopener noreferrer",children:"缓存篇"}),"中和大家讲过，回忆下基础知识："]}),"\n",(0,t.jsx)(n.p,{children:"路由缓存存放在浏览器的临时缓存中，有两个因素决定了路由缓存的持续时间："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Session，缓存在导航期间会持续存在，当页面刷新的时候会被清除"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"自动失效期：单个路由段会在特定时长后自动失效，如果路由是静态渲染，持续 5 分钟，如果是动态渲染，持续 30s"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"这个例子中因为我们用的是动态路由，是动态渲染，缓存持续 30s，所以首次点击笔记获取 RSC Payload 数据 30s 后再点击就会重新获取 RSC Payload。"}),"\n",(0,t.jsx)(n.p,{children:"小问题：以这个项目为例，如果点击笔记的时间算成 0s，因为请求时长大于 5s，假设 RSC Payload 在第 5s 完全返回，下次路由缓存失效重新获取的时间是大概在 30s 后还是 35s 后呢？"}),"\n",(0,t.jsx)(n.p,{children:"答案是 30s。以 RSC Payload 的返回时间为准，RSC Payload 是逐行返回的，所以点击的时候很快就有返回了。"}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"那么今天的内容就结束了，本篇的内容并不多，主要是通过笔记预览这个例子，在实际开发中加深对 RSC Payload 和路由缓存的理解。"}),"\n",(0,t.jsxs)(n.p,{children:["本篇的代码我已经上传到",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/main",target:"_blank",rel:"noopener noreferrer",children:"代码仓库"}),"的 Day3 分支：",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day3",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day3"}),"，直接使用的时候不要忘记在本地开启 Redis。"]})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F39.%E5%AE%9E%E6%88%98%E7%AF%87%20_%20React%20Notes%20_%20%E7%AC%94%E8%AE%B0%E9%A2%84%E8%A7%88%E7%95%8C%E9%9D%A2.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"笔记预览",id:"笔记预览",depth:2},{text:"原理解析",id:"原理解析",depth:2},{text:"RSC Payload",id:"rsc-payload",depth:3},{text:"路由缓存",id:"路由缓存",depth:3},{text:"总结",id:"总结",depth:2}],title:"39.实战篇 _ React Notes _ 笔记预览界面",headingTitle:"39.实战篇 _ React Notes _ 笔记预览界面",frontmatter:{}}}}]);