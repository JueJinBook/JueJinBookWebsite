"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["40853"],{169192:function(e,n,s){s.r(n),s.d(n,{default:()=>h});var r=s(552676),a=s(740453);let d=s.p+"static/image/34aba6f14367501766c5ebc9729cdf4b.588fa774.webp",c=s.p+"static/image/95f3a06d7ac03cc3e781e86277c1a21e.9fc6815b.webp",t=s.p+"static/image/4492cd20947e23799bf8739ef3dbec70.bc6515fa.webp",l=s.p+"static/image/5530445b740b1507801ad2078ca68bd0.239d5f03.webp";function i(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",ol:"ol",li:"li",strong:"strong",h3:"h3",pre:"pre",img:"img"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"16-sveltekit--数据获取",children:["16-SvelteKit ❘ 数据获取",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16-sveltekit--数据获取",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"推荐学习指数：⭐️⭐⭐️，必学内容️"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在之前的路由篇中，我们讲到 ",(0,r.jsx)(n.code,{children:"+page(.server).js"}),"和",(0,r.jsx)(n.code,{children:"+layout(.server).js"}),"都可以导出一个名为 ",(0,r.jsx)(n.code,{children:"load"}),"的函数用于获取渲染页面或布局所需的数据。我们可以从 ",(0,r.jsx)(n.code,{children:"load"})," 函数的第一个参数中解构获得 ",(0,r.jsx)(n.code,{children:"params"}),"、",(0,r.jsx)(n.code,{children:"fetch"})," 等值。除此之外，还能够获取哪些值？",(0,r.jsx)(n.code,{children:"load"})," 函数在不同环境运行时又有什么差别？本篇我们就来详细解析一下 load 函数。"]}),"\n",(0,r.jsxs)(n.h2,{id:"2-load",children:["2. load",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-load",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"load"})," 函数分为 2 类："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"universal load："}),(0,r.jsx)(n.code,{children:"+page.js"})," 和 ",(0,r.jsx)(n.code,{children:"+layout.js"})," 导出的在服务端和浏览器都可以运行的通用 load 函数"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"server load："}),(0,r.jsx)(n.code,{children:"+page.server.js"})," 和 +",(0,r.jsx)(n.code,{children:"layout.server.js"})," 导出的仅在服务器端运行的服务端 load 函数"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"21-示例-demo",children:["2.1. 示例 Demo",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-示例-demo",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"两者在使用上很类似，但有一些重要的差别。我们可以写一个简单的例子理解两者的不同："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"routes\n└─ posts\n   ├─ +layout.js\n   ├─ +layout.server.js\n   ├─ +page.js\n   ├─ +page.server.js\n   └─ +page.svelte\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"layout.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export async function load({ data }) {\n  return {\n    ...data,\n    layout: true\n  };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"layout.server.js"}),"代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export async function load() {\n  return {\n    'layout.server': true\n  };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"+page.js"})," 代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export async function load({ data }) {\n  return {\n    ...data,\n    page: true\n  };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"+page.server.js"})," 代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export async function load() {\n  return {\n    'page.server': true\n  };\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"+page.svelte"})," 代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  let { data } = $props();\n<\/script>\n\n<div>{JSON.stringify(data, null, 2)}</div>\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["注意：像 ",(0,r.jsx)(n.code,{children:"+page.js"}),"和 ",(0,r.jsx)(n.code,{children:"+page.server.js"}),"很少会同时用到，这里为了举例才这样写。",(0,r.jsx)(n.strong,{children:"当两者同时使用的时候，"}),(0,r.jsx)(n.code,{children:"+page.server.js"}),"的返回值并不能直接传给 ",(0,r.jsx)(n.code,{children:"+page.svelte"}),"，而是会将返回值以 ",(0,r.jsx)(n.code,{children:"data"})," 属性传给 ",(0,r.jsx)(n.code,{children:"+page.js"}),"的 ",(0,r.jsx)(n.code,{children:"load"})," 函数，所以上面的代码中，我们会获取 data 属性，放到返回值中再传给 ",(0,r.jsx)(n.code,{children:"+page.svelte"}),"。",(0,r.jsx)(n.code,{children:"layout.js"})," 和 ",(0,r.jsx)(n.code,{children:"layout.server.js"}),"同理。"]}),"\n",(0,r.jsxs)(n.h3,{id:"22-运行时机不同",children:["2.2. 运行时机不同",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-运行时机不同",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["server load 始终在服务端运行。universal load 在默认情况下，首次访问的时候在服务端运行（SSR），然后在客户端水合期间再次运行（CSR），后续导航发生的 universal load 都在客户端运行。但你可以通过页面选项修改此行为，比如设置 ",(0,r.jsx)(n.code,{children:"const ssr = false"}),"，此时禁用服务端渲染，universal load 将始终在客户端运行。"]}),"\n",(0,r.jsx)(n.p,{children:"如果同一个路由包含 universal load 和 server load，server load 将首先运行。"}),"\n",(0,r.jsxs)(n.p,{children:["load 函数始终在运行时调用，除非设置了 ",(0,r.jsx)(n.code,{children:"const prerender = true"}),"，此时会在构建时调用。"]}),"\n",(0,r.jsxs)(n.h3,{id:"23-输入不同",children:["2.3. 输入不同",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-输入不同",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们打印下 server load 和 universal load 的第一个参数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"可以看出有些属性相同，又有些属性不同。"}),"\n",(0,r.jsxs)(n.p,{children:["比如 server load 和 universal load 函数都可以访问请求相关的属性（",(0,r.jsx)(n.code,{children:"params"}),"、",(0,r.jsx)(n.code,{children:"route"})," 和 ",(0,r.jsx)(n.code,{children:"url"}),"）和各种函数（",(0,r.jsx)(n.code,{children:"fetch"}),"、",(0,r.jsx)(n.code,{children:"setHeaders"}),"、",(0,r.jsx)(n.code,{children:"parent"}),"、",(0,r.jsx)(n.code,{children:"depends"})," 和 ",(0,r.jsx)(n.code,{children:"untrack"})," ）"]}),"\n",(0,r.jsxs)(n.p,{children:["server load 运行在服务端，所以还有服务端相关的属性，比如 ",(0,r.jsx)(n.code,{children:"clientAddress"}),"、",(0,r.jsx)(n.code,{children:"cookies"})," 、",(0,r.jsx)(n.code,{children:"locals"})," 、 和 ",(0,r.jsx)(n.code,{children:"request"}),"，这些继承自服务端 ",(0,r.jsx)(n.a,{href:"https://kit.svelte.dev/docs/types#public-types-requestevent",title:"https://kit.svelte.dev/docs/types#public-types-requestevent",target:"_blank",rel:"noopener noreferrer",children:"RequestEvent"})," 对象。"]}),"\n",(0,r.jsx)(n.p,{children:"universal load 有一个 data 属性，当 server load 和 universal load 一起使用的时候，server load 的返回值会以 data 属性传给 universal load。"}),"\n",(0,r.jsxs)(n.h3,{id:"24-输出不同",children:["2.4. 输出不同",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-输出不同",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"universal load 可以返回包含任何值的对象。而 server load 必须返回可被 devalue 序列化的数据，因为它要将服务端返回的数据传给客户端。"}),"\n",(0,r.jsxs)(n.h2,{id:"3-属性",children:["3. 属性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-属性",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在让我们来具体介绍下这些属性。"}),"\n",(0,r.jsxs)(n.h3,{id:"31-ur",children:["3.1. ur",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-ur",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["url 是 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/URL",title:"https://developer.mozilla.org/en-US/docs/Web/API/URL",target:"_blank",rel:"noopener noreferrer",children:"URL"})," 实例，可以获取 ",(0,r.jsx)(n.code,{children:"origin"}),"、",(0,r.jsx)(n.code,{children:"hostname"}),"、",(0,r.jsx)(n.code,{children:"pathname"}),"等属性："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:" url: URL {\n    href: 'http://localhost:5173/posts',\n    origin: 'http://localhost:5173',\n    protocol: 'http:',\n    username: '',\n    password: '',\n    host: 'localhost:5173',\n    hostname: 'localhost',\n    port: '5173',\n    pathname: '/posts',\n    search: '',\n    searchParams: URLSearchParams {},\n    hash: ''\n  },\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但是要注意：",(0,r.jsx)(n.code,{children:"url.hash"})," 在 load 中无法访问，因为 URL 中的 hash 值只是客户端的一种状态，当向服务器端发出请求时，hash 部分并不会被发送，所以无法获取该值。"]}),"\n",(0,r.jsxs)(n.h3,{id:"32-route",children:["3.2. route",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-route",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["route 是包含当前路由目录的对象。比如 ",(0,r.jsx)(n.code,{children:"src/routes/a/[b]/[...c]/+page.js"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export function load({ route }) {\n  console.log(route.id); // '/a/[b]/[...c]'\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"33-params",children:["3.3. params",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-params",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["params 是指路由动态参数，还是 ",(0,r.jsx)(n.code,{children:"src/routes/a/[b]/[...c]/+page.js"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 访问 http://localhost:5173/a/x/y/z\n\nexport function load({ params }) {\n  console.log(params); // { b: 'x', c: 'y/z' }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"params 是根据 url.pathname 和 route.id 进行判断的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"条件一：url.pathname: /a/x/y/z\n\n条件二：route.id: /a/[b]/[...c]\n\n算出：params: { b: 'x', c: 'y/z' }\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"34-fetch",children:["3.4. fetch()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34-fetch",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["fetch 函数与",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch",title:"https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch",target:"_blank",rel:"noopener noreferrer",children:"原生 fetch Web API"})," 一致，但会有一些额外的功能："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["可用于在服务端上发起凭证请求，因为继承了页面请求的 ",(0,r.jsx)(n.code,{children:"cookie"})," 和 ",(0,r.jsx)(n.code,{children:"authorization"})," 标头。"]}),"\n",(0,r.jsx)(n.li,{children:"它可以在服务端上发起相对地址请求"}),"\n",(0,r.jsxs)(n.li,{children:["在服务端运行时，内部请求（例如 ",(0,r.jsx)(n.code,{children:"+server.js"})," 路由请求）将直接进入处理程序函数，不会产生 HTTP 调用开销"]}),"\n",(0,r.jsx)(n.li,{children:"在服务端渲染期间，响应将被捕获并内联到渲染的 HTML 中。在水合期间，将从 HTML 中读取响应，从而保证数据一致性并防止额外的网络请求"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n  const res = await fetch(`/api/items/${params.id}`);\n  const item = await res.json();\n\n  return { item };\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"35-cookies",children:["3.5. cookies()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#35-cookies",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"server load 可以通过 cookies 获取和设置 cookie"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/routes/+layout.server.js\nimport * as db from "$lib/server/database";\n\nexport async function load({ cookies }) {\n  const sessionid = cookies.get("sessionid");\n\n  return {\n    user: await db.getUser(sessionid),\n  };\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["具体 Cookies 的获取和设置方法参考 ",(0,r.jsx)(n.a,{href:"https://kit.svelte.dev/docs/types#public-types-cookies",title:"https://kit.svelte.dev/docs/types#public-types-cookies",target:"_blank",rel:"noopener noreferrer",children:"SvelteKit docs"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["当在 load 函数中使用 fetch 时，只有当目标主机和 SvelteKit 应用相同时或者是更具体的子域时，fetch 请求才会携带 cookies，比如应用域名是 ",(0,r.jsx)(n.code,{children:"my.domain.com"}),"，请求 ",(0,r.jsx)(n.code,{children:"my.domain.com"}),"、",(0,r.jsx)(n.code,{children:"sub.my.domain.com"}),"都会收到 cookies，但请求 ",(0,r.jsx)(n.code,{children:"api.domain.com"}),"、",(0,r.jsx)(n.code,{children:"domain.com"}),"不会收到 cookies。"]}),"\n",(0,r.jsxs)(n.h3,{id:"36-setheaders",children:["3.6. setHeaders()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36-setheaders",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"setHeaders 用于设置标头，当在服务端运行时，此函数可以为响应设置标头。在浏览器中运行时，setHeaders 不起作用。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'export async function load({ fetch, setHeaders }) {\n  const url = `https://cms.example.com/products.json`;\n  const response = await fetch(url);\n\n  setHeaders({\n    age: response.headers.get("age"),\n    "cache-control": response.headers.get("cache-control"),\n  });\n\n  return response.json();\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"注意："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"不能多次设置同一标头"}),"\n",(0,r.jsx)(n.li,{children:"不能通过设置 set-cookie 添加 Cookies，应该使用上节的 cookies.set"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"37-parent",children:["3.7. parent()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#37-parent",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["有的时候，load 函数需要从父 load 函数获取数据，此时可以通过 ",(0,r.jsx)(n.code,{children:"await parent()"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"routes\n├─ abc\n│  ├─ +layout.js\n│  ├─ +page.js\n│  └─ +page.svelte\n└─ +layout.js\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// src/routes/+layout.js\nexport function load() {\n  return { a: 1 };\n}\n\n// src/routes/abc/+layout.js\nexport async function load({ parent }) {\n  const { a } = await parent();\n  return { b: a + 1 };\n}\n\n// src/routes/abc/+page.js\nexport async function load({ parent }) {\n  const { a, b } = await parent();\n  return { c: a + b };\n}\n\n// src/routes/abc/+page.svelte\n<script>\n  export let data;\n<\/script>\n\n<p>{data.a} + {data.b} = {data.c}</p>\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["在",(0,r.jsx)(n.code,{children:"+page.server.js"})," 和 ",(0,r.jsx)(n.code,{children:"+layout.server.js"})," 中，",(0,r.jsx)(n.code,{children:"parent()"}),"会返回父 ",(0,r.jsx)(n.code,{children:"+layout.server.js"}),"的数据。"]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"+page.js"}),"或 ",(0,r.jsx)(n.code,{children:"+layout.js"}),"中，",(0,r.jsx)(n.code,{children:"parent()"}),"会返回父 ",(0,r.jsx)(n.code,{children:"+layout.js"}),"的数据。缺失的 ",(0,r.jsx)(n.code,{children:"+layout.js"}),"会被视为 ",(0,r.jsx)(n.code,{children:"({ data }) => data"})," 函数，所以它会转发父 ",(0,r.jsx)(n.code,{children:"+layout.server.js"})," 中的数据。也就是说，将 src/routes/+layout.js 重命名为 src/routes/+layout.server.js 也是可以生效的。"]}),"\n",(0,r.jsx)(n.p,{children:"使用 await parent 注意不要造成阻塞："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export async function load({ params, parent }) {\n  // 如果数据不需要依赖 parent() 返回的数据，放在前面调用，因为所有的 load 函数是平行运行的\n  const data = await getData(params);\n  const parentData = await parent();\n\n  return {\n    ...data\n    meta: { ...parentData.meta, ...data.meta }\n  };\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"4-load-使用技巧",children:["4. load 使用技巧",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-load-使用技巧",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"41-流式加载",children:["4.1. 流式加载",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-流式加载",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"当使用 server load 的时候，可以返回一个 Promise，数据会流式传输给浏览器，适用于一些非必要的缓慢数据。"}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"src/routes/blog/[slug]/+page.server.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function sleep(time) {\n  return new Promise((resolve) => setTimeout(resolve, time));\n}\n\nasync function loadComments() {\n  await sleep(4000);\n  return [\n    { content: "This is a test comment!" },\n    { content: "This is a test comment!" },\n  ];\n}\n\nasync function loadPost(id) {\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/posts/${id}`\n  );\n  const post = await response.json();\n  return post;\n}\n\nexport async function load({ params }) {\n  return {\n    comments: loadComments(params.slug),\n    post: await loadPost(params.slug),\n  };\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"src/routes/blog/[slug]/+page.svelte"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"<script>\n  export let data;\n<\/script>\n\n<h2>{data.post.title}</h2>\n<div>{@html data.post.body}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"使用流式数据传输时要谨慎，如果你没有妥善处理 Promise reject 的情况，比如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'async function loadComments() {\n  throw new Error("error");\n  await sleep(4000);\n  return [\n    { content: "This is a test comment!" },\n    { content: "This is a test comment!" },\n  ];\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"此时会直接导致应用崩溃。"}),"\n",(0,r.jsx)(n.p,{children:"所以写的时候最好添加一个 noop-catch 函数："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export async function load({ params }) {\n  return {\n    comments: loadComments(params.slug).catch(() => {}),\n    post: await loadPost(params.slug),\n  };\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样即便抛出错误，也不会影响应用其他部分。"}),"\n",(0,r.jsxs)(n.h3,{id:"42-重新运行",children:["4.2. 重新运行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-重新运行",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["SvelteKit 会追踪每个 ",(0,r.jsx)(n.code,{children:"load"})," 函数的依赖，以避免导航时没有必要的重新运行。比如这样一个例子："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// src/routes/blog/[slug]/+page.server.js\nimport * as db from "$lib/server/database";\n\nexport async function load({ params }) {\n  return {\n    post: await db.getPost(params.slug),\n  };\n}\n\n// src/routes/blog/[slug]/+layout.server.js\nimport * as db from "$lib/server/database";\n\nexport async function load() {\n  return {\n    posts: await db.getPostSummaries(),\n  };\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"blog/xxx"}),"之间导航的时候，",(0,r.jsx)(n.code,{children:"+page.server.js"})," 会重新运行，但 ",(0,r.jsx)(n.code,{children:"+layout.server.js"})," 不会重新运行，因为 params.slug 发生了变化。"]}),"\n",(0,r.jsx)(n.p,{children:"如果你想要取消追踪某些属性："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'export async function load({ untrack, url }) {\n  // 取消追踪 url.pathname 当路径改变的时候不会触发重新运行\n  if (untrack(() => url.pathname === "/")) {\n    return { message: "Welcome!" };\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"你也可以手动失效让 load 函数重新运行，需要借助 invalidate(url) 或 invalidateAll() 函数。先声明 load 函数依赖的 url，然后再手动调用 invalidate(url)，手动使其重新运行。"}),"\n",(0,r.jsxs)(n.p,{children:["声明依赖的 url 有两种方式，一种是 ",(0,r.jsx)(n.code,{children:"fetch(url)"}),"，一种是 ",(0,r.jsx)(n.code,{children:"depends(url)"}),"，举个例子："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// src/routes/random-number/+page.js\nexport async function load({ fetch, depends }) {\n  // 当调用 fetch 的时候会自动声明依赖的 url，调用 `invalidate('https://api.example.com/random-number')` 可使其重新运行\n  const response = await fetch('https://api.example.com/random-number');\n\n  // 手动声明依赖的 url，该字符需要以 [a-z]: 开头，调用 `invalidate('app:random')` 可使其重新运行\n  depends('app:random');\n\n  return {\n    number: await response.json()\n  };\n}\n\n// src/routes/random-number/+page.svelte\n<script>\n  import { invalidate, invalidateAll } from '$app/navigation';\n\n  export let data;\n\n  function rerunLoadFunction() {\n    // 这些都可以让 load 函数重新运行\n    invalidate('app:random');\n    invalidate('https://api.example.com/random-number');\n    // 这个用法比较特殊，传入一个函数，接受 url 作为参数，判断需要重新运行的路由地址\n    invalidate(url => url.href.includes('random-number'));\n    invalidateAll();\n  }\n<\/script>\n\n<p>random number: {data.number}</p>\n<button on:click={rerunLoadFunction}>Update random number</button>\n"})}),"\n",(0,r.jsx)(n.p,{children:"所以总结一下 load 函数重新运行的规则："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["引用了 ",(0,r.jsx)(n.code,{children:"params"})," 中的属性，当其值发生更改时"]}),"\n",(0,r.jsxs)(n.li,{children:["引用了 ",(0,r.jsx)(n.code,{children:"url"}),"的属性，当其值发生更改时"]}),"\n",(0,r.jsxs)(n.li,{children:["调用 ",(0,r.jsx)(n.code,{children:"url.searchParams.get(...)"}),"、 ",(0,r.jsx)(n.code,{children:"url.searchParams.getAll(...)"})," 或",(0,r.jsx)(n.code,{children:"url.searchParams.has(...)"}),"，并且相关参数会发生变化"]}),"\n",(0,r.jsxs)(n.li,{children:["调用了 ",(0,r.jsx)(n.code,{children:"await parent()"})," 当父 load 函数重新运行"]}),"\n",(0,r.jsx)(n.li,{children:"通过 fech、depends 声明了对特定 URL 的依赖，调用 invalidate(url) 时"}),"\n",(0,r.jsx)(n.li,{children:"调用 invalidateAll()，所有激活的 load 函数都要重新运行"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"注意：重新运行 load 函数会更新对应 +layout.svelte 或 +page.svelte 的 data 属性，但不会导致组件重新创建，因为内部的状态还会继续保留。"}),"\n",(0,r.jsxs)(n.h2,{id:"5-sveltejskit-辅助函数",children:["5. @sveltejs/kit 辅助函数",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-sveltejskit-辅助函数",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"51-error",children:["5.1. error",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-error",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { error } from "@sveltejs/kit";\n\nexport function load({ locals }) {\n  if (!locals.user) {\n    error(401, "not logged in");\n  }\n\n  if (!locals.user.isAdmin) {\n    error(403, "not an admin");\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["如果在 load 函数抛出错误，会渲染最近的 ",(0,r.jsx)(n.code,{children:"+error.svelte"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"52-redirect",children:["5.2. redirect",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-redirect",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { redirect } from "@sveltejs/kit";\n\nexport function load({ locals }) {\n  if (!locals.user) {\n    redirect(307, "/login");\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"redirect 用于重定向，需要指定重定向的位置以及 3xx 状态代码。"}),"\n",(0,r.jsxs)(n.p,{children:["注意不要在 ",(0,r.jsx)(n.code,{children:"try {...}"})," 块中使用 ",(0,r.jsx)(n.code,{children:"redirect()"}),"，因为重定向会抛出错误，导致立即触发 catch 语句。"]}),"\n",(0,r.jsxs)(n.h2,{id:"6-pagedata",children:["6. $page.data",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-pagedata",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"+page.svelte"})," 和 ",(0,r.jsx)(n.code,{children:"+layout.svelte"})," 可以通过 data 属性获取父级们的所有数据。有的时候，父布局可能需要访问页面或者子布局中的数据。例子，根布局希望访问 +page.js 或 +page.server.js load 函数返回的 title 属性，此时可以通过 $page.data 完成："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"// src/routes/+layout.svelte\n<script>\n  import { page } from '$app/stores';\n<\/script>\n\n<svelte:head>\n  <title>{$page.data.title}</title>\n</svelte:head>\n"})})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let h=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F16-SvelteKit%20%E2%9D%98%20%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. load",id:"2-load",depth:2},{text:"2.1. 示例 Demo",id:"21-示例-demo",depth:3},{text:"2.2. 运行时机不同",id:"22-运行时机不同",depth:3},{text:"2.3. 输入不同",id:"23-输入不同",depth:3},{text:"2.4. 输出不同",id:"24-输出不同",depth:3},{text:"3. 属性",id:"3-属性",depth:2},{text:"3.1. ur",id:"31-ur",depth:3},{text:"3.2. route",id:"32-route",depth:3},{text:"3.3. params",id:"33-params",depth:3},{text:"3.4. fetch()",id:"34-fetch",depth:3},{text:"3.5. cookies()",id:"35-cookies",depth:3},{text:"3.6. setHeaders()",id:"36-setheaders",depth:3},{text:"3.7. parent()",id:"37-parent",depth:3},{text:"4. load 使用技巧",id:"4-load-使用技巧",depth:2},{text:"4.1. 流式加载",id:"41-流式加载",depth:3},{text:"4.2. 重新运行",id:"42-重新运行",depth:3},{text:"5. @sveltejs/kit 辅助函数",id:"5-sveltejskit-辅助函数",depth:2},{text:"5.1. error",id:"51-error",depth:3},{text:"5.2. redirect",id:"52-redirect",depth:3},{text:"6. $page.data",id:"6-pagedata",depth:2}],title:"16-SvelteKit ❘ 数据获取",headingTitle:"16-SvelteKit ❘ 数据获取",frontmatter:{}}}}]);