"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["53787"],{934801:function(n,e,i){i.r(e),i.d(e,{default:()=>h});var s=i(552676),r=i(740453);function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",blockquote:"blockquote",strong:"strong",ol:"ol",li:"li",pre:"pre",code:"code",ul:"ul"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"第12章数据结构实践选择合适的数据结构",children:["第12章—数据结构实践：选择合适的数据结构",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第12章数据结构实践选择合适的数据结构",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\uFEFF上一章，我们讲了常见数据结构的设计思路，那么本章，我们就来看下要怎么使用这些数据结构，以及面对不同场景要如何选择合适的数据结构。"}),"\n",(0,s.jsxs)(e.h2,{id:"一级数据结构案例",children:["一级数据结构案例",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一级数据结构案例",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"所谓一级数据结构，就是我们上一章讲到的几种能直接拿来实现现有需求的数据结构。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"那么，我们到底要翻谁的牌子呢？看例子："}),"\n",(0,s.jsxs)(e.p,{children:["假如现在我要做一个",(0,s.jsx)(e.strong,{children:"直播间的用户列表"}),"，我要选择哪种数据结构来存储呢？"]}),"\n",(0,s.jsx)(e.p,{children:"我们先来分析一下直播间的用户场景："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"直播间用户是个列表，点击就展示出来；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"直播间用户可能频繁地进出；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"点击列表中的一个用户，要显示出它的个人信息；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"点击列表中的一个用户，要能踢出他。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"其中，第一条等于废话，我们讲到的所有数据结构都是集合，都能展示出一个列表。"}),"\n",(0,s.jsx)(e.p,{children:"第二条：意味着数据的添加删除可能很频繁，嗯，如果是在末尾添加/删除数据，那么顺序表和链表的效率都是一样的。如果是在中间插入/删除元素，那么链表的效率就高一些。所以链表加一分。"}),"\n",(0,s.jsx)(e.p,{children:"第三条：意味着随机访问元素，这个明显是顺序表占优，顺序表加一分。"}),"\n",(0,s.jsx)(e.p,{children:"第四条：点击踢出用户，首先要找到用户，然后踢出，这就等于“随机访问+删除元素”，也就是等于第二条和第三条的复合操作。"}),"\n",(0,s.jsx)(e.p,{children:"那这就麻烦了，各有各的优势，我们要如何选择呢？"}),"\n",(0,s.jsxs)(e.p,{children:["嗯，明面上是 55 开，其实有很大的考量度，我们来分析下上述操作的",(0,s.jsx)(e.strong,{children:"权重"}),"问题，也就是哪些操作可能会比较多，哪些比较少。"]}),"\n",(0,s.jsx)(e.p,{children:"我们知道，对于一个直播间，踢出这个操作是用得最少的，毕竟是隐藏的金主，能忍就忍。其次就是查看个人信息，因为既然是直播间，我们的关注点大多都在主播身上，进直播间不看主播看别人的信息，这就是对主播的侮辱。最后就是用户的进入和退出，因为大多数场景下，每个人进入直播间都是被封面吸引的，进去之后看到实际跟预期并不符合，就会大失所望，就直接跑了，这是个很频繁的操作。而且，大多数直播间的用户列表都是有排序的，比如：金主排前面，非金主但充值的次之，排最后的才是我们这些三无人员。这就导致每次进入/退出的人不是直接从列表的最后面操作的，而可能插入到列表中间或者前面，或者从列表中间删除，这明显就是链表占优了。"}),"\n",(0,s.jsx)(e.p,{children:"综上，对于很频繁地进入/退出操作，链表是占优势，所以我们应该选择链表来存储。"}),"\n",(0,s.jsx)(e.p,{children:"当然你也可以根据你们的数据统计来给每个操作进行加权，比如：在 1 小时内，进入/退出发生了 80 次，点击个人信息发生了 20 次，那么就是进入退出占 0.8 分，点击个人信息占 0.2 分，而进入/退出是链表占优，所以就选链表。"}),"\n",(0,s.jsxs)(e.p,{children:["再比如，",(0,s.jsx)(e.strong,{children:"直播间的消息列表"}),"，我们很少对消息列表进行插入/删除，而往往是消息来了就加到最后一条，并且我们需要很频繁地点击消息去查看发送这条消息的人的信息，那这明显就是顺序表占优了。"]}),"\n",(0,s.jsx)(e.p,{children:"直播间还有啥列表呢？还有礼物。"}),"\n",(0,s.jsx)(e.p,{children:"对于直播间来说，礼物是最重要的，也是肾上腺素飙升的主要来源。现在，假如直播间有 1w 个人在 5s 内都刷了一个礼物，那么，这 1w 个礼物会同时播放吗？"}),"\n",(0,s.jsx)(e.p,{children:"不会！"}),"\n",(0,s.jsx)(e.p,{children:"为啥呢？因为我们的手机都有内存限制啊，你这 1w 个礼物呢？假如一个礼物要 1 兆内存，1w 个礼物就是 10G 内存啊，这能同时播放吗？估计卡得你又要骂安卓垃圾、iOS 垃圾了。"}),"\n",(0,s.jsx)(e.p,{children:"那怎么办呢？排队播放！"}),"\n",(0,s.jsx)(e.p,{children:"一次我播不了 1w 个，那一次我播 100 个总是可以的，100 个也就是 100M 内存，还行。这样我就每次播 100 个，播放 100 次，就可以了。"}),"\n",(0,s.jsx)(e.p,{children:"每次播放 100 个，就按照播放两秒算，总共也就 200 秒，也就是 3 分钟左右，还可以接受。这也就是为什么很多直播间礼物不断的原因了。"}),"\n",(0,s.jsx)(e.p,{children:"好，既然说到了排队，那就明显是用我们上一章设计到的队列了。我们按照收到礼物的先后顺序进入队列，监测到当前播放个数是否大于 100，如果不大于，那么就让它播放，否则就添加到等待队列里面去。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"// 等待队列\nQueue waitingQueue;\n// 播放队列\nQueue playingQueue;\n// 播放礼物\nfun playGift(Gift gift) {\n    // 如果播放队列没有满，那么就直接播放\n    if(playingQueue.size < 100) {\n        playingQueue.inQueue(gift);\n        playGiftAnim(gift);\n    }else {\n        // 如果播放队列满了，就加入到等待队列中\n        waitingQueue.inQueue(gift);\n    }\n    \n    \n}\n\n// 播放礼物动画\nfun playGiftAnim(Gift gift) {\n    // .... 播放礼物动画\n    gift.play()\n    \n    // 播放完毕就移出播放队列\n    playingQueue.outQueue(gift);\n    \n    // 检测并播放下一个\n    playGift(waitingQueue.outQueue());\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"上述代码仅供参考，但我们可以依此知道使用队列进行排队的方法，这个说白了就是当轮不到的时候，就先用一个集合把暂时轮不到的存放进去，前提是要按照先后的顺序存放，所以我们就选择使用队列。"}),"\n",(0,s.jsxs)(e.p,{children:["有人说了，我要插队怎么办？你看银行还有 vip、svip，vip 中 p 呢。这就可以用到",(0,s.jsx)(e.strong,{children:"优先级队列"}),"了，这里限于篇幅问题，就暂时不做讲解了，我们就在后面的项目实战章节来看一下它是怎么使用的。"]}),"\n",(0,s.jsx)(e.p,{children:"我们先来看一个我们用得很频繁的数据结构：哈希表，或者叫字典。"}),"\n",(0,s.jsxs)(e.h2,{id:"二级数据结构",children:["二级数据结构",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二级数据结构",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["二级数据结构是用一级数据结构组合而成的，最常见的就是",(0,s.jsx)(e.code,{children:"哈希表"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["什么是哈希表呢？它就是个数组。只不过这个数组的元素又是链表。所以我们可以称它为：",(0,s.jsx)(e.strong,{children:"链表数组"}),"。当然，在有的语言中，它也会用二叉树来实现。它大概就是这样的："]}),"\n",(0,s.jsxs)(e.p,{children:["那它可以用来干啥呢？可以",(0,s.jsx)(e.strong,{children:"存放键值对"}),"，图中的每一个元素，都不是一个数值，而是一个个的键值对，也就是我们高中学过的映射，你可以理解为：",(0,s.jsx)(e.code,{children:"f(x)=x"}),"，而图中存放的就是这个关系。"]}),"\n",(0,s.jsx)(e.p,{children:"关系？这玩意儿怎么存放呢？我们可以定义一个对象来存放："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"// 定义键值对，也就是图中的链表的元素\nclass Node {\n    int key; // 这就等价于x\n    int value; // 这就等价于f(x)\n    Node next;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"那么，怎么用呢？用在哪些场景呢？我们考虑下：如果要保存你的名字、年龄、性别，你要怎么保存呢？"}),"\n",(0,s.jsx)(e.p,{children:"用列表啊，直接按顺序放进去就行了。比如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'list.put("张三");\nlist.put("20");\nlist.put("男");\n'})}),"\n",(0,s.jsx)(e.p,{children:"这样当然可以，不过可读性太差，我还要记住下标，而且，如果有一天，你把 1 号位置删除了，那去 1 号位置拿年龄，就拿到了性别，这肯定不行。"}),"\n",(0,s.jsx)(e.p,{children:"其实这个例子中 x 就是下标，f(x) 就是下标对应的元素，但是 x 太不稳定了，所以我们需要个稳定的 x 值，来维持这个稳定的关系，我们就设计如下 API："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"fun put(String key, String value) {\n}\n\nfun getValue(String key) {\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["当你 put 的时候，就等于存放一个",(0,s.jsx)(e.strong,{children:"关系"}),"，也就是键值对，比如："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'put("name","张三"); // 等价于f(name) = "张三"\nput("age","20"); // 等价于f(age) = "20"\nput("sex","男";) // 等价于f(sex) = "男"\n'})}),"\n",(0,s.jsx)(e.p,{children:"获取的时候呢就这样："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'String name = get("name"); // 等价于 String name = f(name);\n'})}),"\n",(0,s.jsxs)(e.p,{children:["这样是不是更人性化了？完全就是在调用函数，",(0,s.jsx)(e.code,{children:"put"}),"的时候保存函数变量和函数值，",(0,s.jsx)(e.code,{children:"get"}),"的时候根据函数变量获取函数值。"]}),"\n",(0,s.jsx)(e.p,{children:"这就是在做数学题。"}),"\n",(0,s.jsxs)(e.p,{children:["所以，",(0,s.jsxs)(e.strong,{children:["当我们遇到存取",(0,s.jsx)(e.code,{children:"关系型"}),"数据时候，哈希表就是不二之选"]}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"比如，上述的直播间用户列表，我们最后是用链表存放的，访问速度很慢，那么用哈希表，就能解决这个问题。"}),"\n",(0,s.jsxs)(e.p,{children:["我们可以将用户的 id 作为哈希表的 key，也就是函数中的变量 x；将用户数据作为哈希表的 value，也就是函数中的 f(x)；这样，我们点击某个用户的时候，只要用 id 去",(0,s.jsx)(e.code,{children:"get"}),"，就能立刻获取到用户的数据，这是不是快多了呢？并且，我们的插入/删除速度也很快。"]}),"\n",(0,s.jsx)(e.p,{children:"那么，它为什么这么快呢？"}),"\n",(0,s.jsx)(e.p,{children:"因为它虽然是个数组，但是插入/删除元素的时候，数组并不进行位置移动。我们来看下元素的存放过程，假如我们要存放键值对：name=zhangsan。"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"先计算 name 的哈希码（hashcode），结果是一个 int 值，这是个很快的操作。"}),"\n",(0,s.jsx)(e.li,{children:"用 name 的哈希码对数组的长度求余，得到 a 应该存放的位置，这里假设位置是 0。"}),"\n",(0,s.jsx)(e.li,{children:"如果这个位置没有其他元素，那么就直接放在这。如果有其他元素进行第 4 步。"}),"\n",(0,s.jsx)(e.li,{children:"这里我们就得到了 0 号位的链表。我们从前往后逐个对比它们的哈希码，如果都不同，则把 name 这个键值对插入到这个链表的头部。如果有相同的则进行第 5 步。"}),"\n",(0,s.jsx)(e.li,{children:"如果哈希码相同，就对比它们的 name 的值是否相同，如果不同则插入到链表头部，如果相同则用新的 value 替换掉老的 value。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"有点懵，我们再来捋一下：先根据 name 计算 hashcode，然后用 hashcode 计算下标，然后找到下标对应的链表，没有则直接存放；有就继续对比 hashcode，都不同则插入到头部；有相同则继续对比 name 是否相等，如果不同则插入到链表头部，相同则直接替换掉原来的 value 值。"}),"\n",(0,s.jsx)(e.p,{children:"有人说，你这也太绕了，你这先计算哈希值，再计算下标，最后又对比 name 是否相同，图啥呢？"}),"\n",(0,s.jsxs)(e.p,{children:["这其实就是伟大的",(0,s.jsx)(e.strong,{children:"分页功能"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:"还记得找张三的例子吗？我们按照姓名首字母、名字笔画数等分了那么多组，就是为了找起来快一点。哈希表也是这个原理。"}),"\n",(0,s.jsx)(e.p,{children:"不同的对象，它们的哈希码可能是相同的（这叫做哈希冲突），而不同的哈希码对数组长度求余得到的结果也可能是相同的。所以，我们就借此来给它们进行分组。"}),"\n",(0,s.jsx)(e.p,{children:"把哈希码相同的分为一组，把对数组长度求余结果相同的分为一组，这样，我们的范围就逐渐缩小了。这不就是分页吗？"}),"\n",(0,s.jsx)(e.p,{children:"哈希表也是基于这个原理设计的。"}),"\n",(0,s.jsx)(e.p,{children:"在这个过程中，计算哈希码很快，计算下标也很快，就是最后对链表计算比较慢，但是，在常规情况下，链表一般都很短，所以这个速度也是很快的。"}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"本章我们介绍了一些常见的数据集合的实践方法，以及哈希表的设计原理，我们再来回顾下。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["当用到",(0,s.jsx)(e.strong,{children:"非关系集合"}),"时，我们优先考虑线性数据结构，读多写少就用顺序表，读少写多就用链表，要排队就用队列，要做对称性操作就用栈。"]}),"\n",(0,s.jsxs)(e.li,{children:["当用到",(0,s.jsx)(e.strong,{children:"关系型集合"}),"时，我们优先考虑哈希表，哈希表存放的是一个个键值对，类似于数学中的函数。"]}),"\n",(0,s.jsxs)(e.li,{children:["对于哈希表，它本身就是一个数组，只不过数组的元素是链表，它用了",(0,s.jsx)(e.strong,{children:"分页的思想"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"那么下一章，我们就来看下计算机本身是怎么设计的，它里面又是怎么灵活使用各种设计思想的。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(l,{...n})}):l(n)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC12%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E8%B7%B5%EF%BC%9A%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md"]={toc:[{text:"一级数据结构案例",id:"一级数据结构案例",depth:2},{text:"二级数据结构",id:"二级数据结构",depth:2},{text:"总结",id:"总结",depth:2}],title:"第12章—数据结构实践：选择合适的数据结构",headingTitle:"第12章—数据结构实践：选择合适的数据结构",frontmatter:{}}}}]);