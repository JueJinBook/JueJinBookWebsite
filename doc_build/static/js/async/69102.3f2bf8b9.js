"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["69102"],{297383:function(e,n,s){s.r(n),s.d(n,{default:()=>E});var t=s(552676),r=s(740453);let c=s.p+"static/image/b2e4732e7bc6655b30195f5d8929c8f0.bab9a780.webp",i=s.p+"static/image/c987e710833e444b5d06cf0ca527ba3b.59820e1f.webp",l=s.p+"static/image/f5b887abbdb8669bb733d629fec74339.172baff3.webp",a=s.p+"static/image/a0c95148e28c1b8fbc119eedf4d633df.70a4dfd6.webp",o=s.p+"static/image/74e73c6c575cda63490af3e479d59f42.72fb4bc0.webp",d=s.p+"static/image/d7b3ae60c9ebe563e9ff6e39ce89eb16.544f702b.webp",p=s.p+"static/image/3f7f7d5393a1ca4b83364d01846dab22.96d88e27.webp",h=s.p+"static/image/fe9f98cdf2a9d79b7dd415f8f1469338.beeeaa44.webp",x=s.p+"static/image/ddbbeba871ceae8831a4f64568bd9fec.baeecf18.webp",m=s.p+"static/image/3f03e3187c3aee0926ea119b3c8b81df.daa3444b.webp",j=s.p+"static/image/87d69605580f744f9a756c930dfe6550.5c47701c.webp",b=s.p+"static/image/60b7817b7be430f986156f9b90788c1e.5468b135.webp",g=s.p+"static/image/f72dd52b041f649f8479e3fa34f9ba5c.42ff29a6.webp",f=s.p+"static/image/84c4dbfe1de90ccef4fec7dc98d76f03.af5a2ca2.webp";function u(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",img:"img",pre:"pre",code:"code"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"14e2e怎么覆盖滚动等复杂交互场景的测试",children:["14.E2E：怎么覆盖滚动等复杂交互场景的测试？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14e2e怎么覆盖滚动等复杂交互场景的测试",children:"#"})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["代码仓库：",(0,t.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"上节课我们学习了 Jest 是怎么实现整个测试系统的，相信大家对“运行命令到用例执行”这个过程都有了初步的认知。现在我们已经学完了单元测试的全部内容，已经可以对我们的组件的大部分功能进行覆盖了。"}),"\n",(0,t.jsx)(n.p,{children:"不过针对一些复杂的场景，比如滚动，我们没办法通过单元测试的方式来验证，因为它并不支持滚动事件的模拟。针对这种场景，我们可以通过 E2E（端对端）测试的方式来覆盖。"}),"\n",(0,t.jsxs)(n.h2,{id:"什么是端对端测试",children:["什么是端对端测试？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是端对端测试",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们之前的测试其实都需要在项目中来编写，针对组件的单一原型来书写用例，这是为了稳固内部系统的质量和功能而展开的测试，也就是单元测试。但是除单元测试外，还有一种自动化测试方案，这种自动化测试方案通常由质量保障团队编写，也就是QA，不需要基于项目展开，从用户角度进行测试。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"端对端测试是可以覆盖滚动和跳转场景的，虽然通常由测试人员编写，但是这并不代表我们不能用~"}),"\n",(0,t.jsx)(n.p,{children:"对于 JS 技术栈的前端开发来说，通常会使用 cypress 作为端对端测试工具，它更加贴近我们的代码习惯，而且支持 npm 包安装，我们就可以把端对端代码维护到我们的项目中进行统一的覆盖率统计。"}),"\n",(0,t.jsx)(n.p,{children:"除 cypress 外，还需要有个服务来单独渲染我们的组件，便于我们进行端对端测试，可以选用 storybook 来帮助快速渲染我们的组件，这样我们就可以通过 cypress 来测试了。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"思路确定了，下面我们来就例子看看应该怎么覆盖滚动场景的用例。"}),"\n",(0,t.jsxs)(n.h2,{id:"滚动场景的覆盖",children:["滚动场景的覆盖",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#滚动场景的覆盖",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们首先来实现一个有滚动场景的组件，比如下面的例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/components/ScrollList/index.tsx\nimport { FC, useMemo, useState } from "react";\nimport "./styles.css";\n\ninterface IProps {\n  data: string[];\n  height: string | number;\n  pageSize?: number;\n}\n\n/**\n * 滚动 list, 拉到底部刷新新的一页\n * @param data\n * @param height\n * @returns\n */\nexport const ScrollList: FC<IProps> = ({ data, height, pageSize = 10 }) => {\n  const [page, setPage] = useState(1);\n\n  const currentData = useMemo(\n    () => data.slice(0, pageSize * page),\n    [pageSize, page]\n  );\n\n  return (\n    <div\n      className="scrollList"\n      style={{ height }}\n      onScroll={(e) => {\n        const { scrollTop, clientHeight, scrollHeight } = e.currentTarget;\n        if (\n          scrollTop + clientHeight >= scrollHeight &&\n          currentData.length < data.length\n        ) {\n          alert(`当前page为${page}`);\n          setPage(page + 1);\n        }\n      }}\n    >\n      {currentData.map((item, index) => {\n        return (\n          <div className="item" key={index}>\n            {item}\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n'})}),"\n",(0,t.jsx)(n.p,{children:"我们实现了一个组件，这个组件的功能是可以对一个列表进行滚动分页，每次滚到底部，就会渲染出下一页的内容，下面我们就这个组件来展开我们的端对端测试。"}),"\n",(0,t.jsx)(n.p,{children:"首先我们安装一下 cypress："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm install cypress --save-dev\n"})}),"\n",(0,t.jsxs)(n.p,{children:["安装完成后，会自动打开一个窗口，后续我们打开可以执行 ",(0,t.jsx)(n.code,{children:"npm run cypress"}),"："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"选择 E2E Testing，然后选择谷歌浏览器预览，最后会得到这样的一个页面："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"做完这一步，我们应该可以看到项目中发生了一些变更，可以暂时把 cypress 放一放，我们来继续初始化一下 storybook："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx storybook init\n"})}),"\n",(0,t.jsx)(n.p,{children:"执行下面的命令后，会进行 storybook 的初始化，启动的默认端口号是 6006， 我们可以看到会打开这样的一个页面："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"因为 cypress 测试，我们也希望测试 storybook 的页面，所以咱们也可以修改 cypress 的 baseurl 为 6006 端口，这样我们在写访问链接的时候就可以省略域名的部分了："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./cypress.config.ts\nimport { defineConfig } from "cypress";\n\nexport default defineConfig({\n  e2e: {\n    baseUrl: "http://localhost:6006/",\n    setupNodeEvents(on, config) {\n      // implement node event listeners here\n    },\n    defaultCommandTimeout: 10000,\n  },\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"这时候咱们来稍微看一看初始化了哪些内容："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"其中针对 cypress ，它帮我们初始化了一个 cypress 的目录，以及 cypress 的配置文件，其中 cypress 目录中的 e2e 文件夹存放着我们的端对端测试用例，后续如果有新增，保持 xxx.cy.ts 的格式，就可以识别到是测试文件了。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这个我不讲解大家应该都可以看懂，因为和单元测试的写法真的真的很像，只是提供了一些额外的 API 而已。Btw，如果有同学打开 e2e 发现其中的 API 会报错也不要着急，因为 tsconfig.json 并没有包括到根目录，我们可以加上："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./tsconfig.json\n{\n  "compilerOptions": {\n    // ... other\n    "types": ["cypress"]\n  },\n  "include": ["src", "cypress"]\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"大概介绍完了 cypress 的目录结构，我们再来看看 storybook。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这里它帮我们创建了一些例子，我们以 button.stories.tsx 为例看看写了点啥："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"首先是默认暴露的一些属性，这个决定了它的文档根目录，然后底下是调用这个组件以及不同场景下组件的入参，每个都会形成一个子目录，可以用于调试，我们可以看看对应 button 的效果："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"如果大家后续想写一些架构的项目，用 storybook 来书写架构文档真的是很不错的选择，我们来为滚动组件照猫画虎写一个："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./src/stories/ScrollList.stories.tsx\nimport React from "react";\nimport { ComponentStory, ComponentMeta } from "@storybook/react";\n\nimport { ScrollList } from "../components/ScrollList";\n\nexport default {\n  title: "Example/ScrollList",\n  component: ScrollList,\n  argTypes: {\n    backgroundColor: { control: "color" },\n  },\n} as ComponentMeta<typeof ScrollList>;\n\nconst Template: ComponentStory<typeof ScrollList> = (args) => (\n  <ScrollList {...args} />\n);\n\nexport const List = Template.bind({});\nList.args = {\n  data: [\n    "test1",\n    "test2",\n    "test3",\n    "test4",\n    "test5",\n    "test6",\n    "test7",\n    "test8",\n    "test9",\n    "test10",\n  ],\n  height: 80,\n  pageSize: 3,\n};\n'})}),"\n",(0,t.jsx)(n.p,{children:"咱们来看看效果， 真的很棒！"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"有可访问的页面了，就可以开始写咱们的端对端测试了~"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'// ./cypress/e2e/scrollList.cy.ts\ndescribe("tests for ScrollList", () => {\n  it("should render ", () => {\n    cy.visit("/iframe.html?id=example-scrolllist--list");\n    cy.get(".item").should("have.length", 3);\n    cy.get(".scrollList").scrollTo("bottom");\n    cy.get(".item").should("have.length", 6);\n    cy.get(".scrollList").scrollTo("bottom");\n    cy.get(".item").should("have.length", 9);\n    cy.get(".scrollList").scrollTo("bottom");\n    cy.get(".item").should("have.length", 10);\n  });\n});\n\nexport {};\n'})}),"\n",(0,t.jsx)(n.p,{children:"上面的代码相信大家都可以看得懂，查询 - 断言，端对端和单元测试一样，采用类似的链式写法，在这则用例中，我们获取了一开始列表长度，断言初始化为 3， 然后把它滚动到底部，我们希望它可以更新长度为 6，如此循环，最后长度是 10，因为已经没有更多的数据可以用于更新了。"}),"\n",(0,t.jsx)(n.p,{children:"不过比较细心的同学可能会发现，你写的访问链接好像和咱们 API 的对不上呀 ~"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["我们直接访问的链接是这个，不过呢 cypress 的测试是不会深入到 iframe 中的，而对于组件右边的部分是通过 iframe 嵌入进来的，我们写的链接就是这个 iframe 的链接，",(0,t.jsx)(n.code,{children:"/iframe.html?id=${你的组件id}"}),"，所以我们直接测试 iframe 就好，同学们也可以直接打开这个链接看看，这个页面中只包含我们的组件。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"好了，现在来尝试看看跑一下我们的端对端用例，怎么跑呢，进我们刚才打开的 cypress GUI 页面就可以了。"}),"\n",(0,t.jsx)(n.p,{children:"很棒，可以看到我们的用例全部都通过啦~我们运行测试的时候，右侧的窗口会同步地模拟我们用例中描述的过程，并与断言进行匹配。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"不过我们肯定不希望每次都需要我们自己点一遍用例，通过命令自动化执行肯定是需要的，所以我们可以加上下面的这条命令，通过执行这条命令，它就会自动帮我们完成所有的用例了~"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:' // package.json\n "cypress:run": "cypress run",\n'})}),"\n",(0,t.jsx)(n.p,{children:"当然 E2E 的功能远不只是协助我们的单元测试覆盖滚动场景这么点，它甚至可以覆盖我们整个项目中的细枝末节，感兴趣的同学也可以自行了解一下，写法上有单元测试的基础，掌握也会很快~只是一些 API 上的不同。"}),"\n",(0,t.jsxs)(n.h2,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这节课我们学习了怎么通过 cypress 和 storybook 覆盖滚动等复杂交互场景，通过端对端测试，我们可以覆盖很多单元测试难以企及的场景，虽然开发并不经常写这个，但是在整个项目质量的维稳上，端对端测试的确起到了不小的作用~"}),"\n",(0,t.jsx)(n.p,{children:"现在我们已经学了不少测试知识了，那么我们应该怎么衡量测试用例覆盖得是否完整呢？那就需要测试覆盖率登场了，下节课我们就来学习怎么对测试代码覆盖自动化测试。"})]})}function y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}let E=y;y.__RSPRESS_PAGE_META={},y.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F14.E2E%EF%BC%9A%E6%80%8E%E4%B9%88%E8%A6%86%E7%9B%96%E6%BB%9A%E5%8A%A8%E7%AD%89%E5%A4%8D%E6%9D%82%E4%BA%A4%E4%BA%92%E5%9C%BA%E6%99%AF%E7%9A%84%E6%B5%8B%E8%AF%95%EF%BC%9F.md"]={toc:[{text:"什么是端对端测试？",id:"什么是端对端测试",depth:2},{text:"滚动场景的覆盖",id:"滚动场景的覆盖",depth:2},{text:"小结",id:"小结",depth:2}],title:"14.E2E：怎么覆盖滚动等复杂交互场景的测试？",headingTitle:"14.E2E：怎么覆盖滚动等复杂交互场景的测试？",frontmatter:{}}}}]);