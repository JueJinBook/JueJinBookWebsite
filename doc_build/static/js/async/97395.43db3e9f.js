"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["97395"],{931411:function(e,n,r){e.exports=r.p+"static/image/0c7d692cad1d349d778cff66faba364f.0b71c7f8.webp"},15997:function(e,n,r){e.exports=r.p+"static/image/1233af38c04b74b02e468dd15de50555.7249e88e.webp"},883424:function(e,n,r){e.exports=r.p+"static/image/13cd9e28bed9775405c139a8bf492d38.82667e9a.webp"},899868:function(e,n,r){e.exports=r.p+"static/image/20bf632e9bd4e8e66711b27153e33136.9f3b9de4.webp"},485314:function(e,n,r){e.exports=r.p+"static/image/221eb48a744f670b1671ee114dd02aeb.6ac3deac.webp"},134673:function(e,n,r){e.exports=r.p+"static/image/3a5ee85cd4734b4a6bfb9f95dbfabbca.6262a594.webp"},323159:function(e,n,r){e.exports=r.p+"static/image/5cf02a6d46d3e1bfb71106d9949d3d6f.6262a594.webp"},959553:function(e,n,r){e.exports=r.p+"static/image/5ee4dd7517f1c877d59c97e6b94474fb.27a34686.webp"},87793:function(e,n,r){e.exports=r.p+"static/image/686254b8eeb91074c8acdaa56b2c8012.2352d5ef.webp"},470502:function(e,n,r){e.exports=r.p+"static/image/6ded903879187b1aef8e7410c6fd983e.f5457bcf.webp"},963944:function(e,n,r){e.exports=r.p+"static/image/872da7eb225c6c631dfbace556083e46.2352d5ef.webp"},251395:function(e,n,r){e.exports=r.p+"static/image/ace680fe821557e6f450717449108ad1.0b71c7f8.webp"},612768:function(e,n,r){e.exports=r.p+"static/image/b2b5a2736b21aa284c311d24090b331e.d7db3589.webp"},367008:function(e,n,r){e.exports=r.p+"static/image/bcac35361cb2a10a3c5f5d2c4882eaec.d7db3589.webp"},245375:function(e,n,r){e.exports=r.p+"static/image/c32da5b31ccbf59ae705bcd5ea21420d.7249e88e.webp"},70362:function(e,n,r){e.exports=r.p+"static/image/cf7e7f324790fa7ce1756d8faac6f8d3.27a34686.webp"},551224:function(e,n,r){e.exports=r.p+"static/image/d9172daed46585c052c0010455d5744e.6ac3deac.webp"},189807:function(e,n,r){e.exports=r.p+"static/image/de643adf997475b0d8b26b03209c25ba.0247f9fd.webp"},945330:function(e,n,r){e.exports=r.p+"static/image/efb42664888bc3a1aef15f701e11900e.27a34686.webp"},272736:function(e,n,r){e.exports=r.p+"static/image/f0c9fd4b7b5c6c0cdd55c254af5b3f5c.f5457bcf.webp"},503170:function(e,n,r){r.r(n),r.d(n,{default:()=>N});var s=r(552676),c=r(740453),d=r(899868),t=r(883424),i=r(931411),o=r(959553),l=r(251395),h=r(272736),a=r(945330),j=r(470502),p=r(87793),x=r(612768),T=r(70362),b=r(485314),P=r(323159),_=r(245375),H=r(134673),E=r(963944),f=r(367008),u=r(15997),g=r(551224),m=r(189807);function k(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",img:"img",h2:"h2",h3:"h3",pre:"pre",ul:"ul",li:"li",ol:"ol",strong:"strong"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"28-都说能写服务端下http下",children:["28-都说能写服务端（下）：http（下）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#28-都说能写服务端下http下",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上一章中我们自己基于 ",(0,s.jsx)(n.code,{children:"net"})," 模块写了个玩具的 ",(0,s.jsx)(n.code,{children:"http"})," 服务端。回过头来，我们要看看 Node.js 中的 ",(0,s.jsx)(n.code,{children:"http"})," 服务端模块是怎么写的了。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["有关 HTTP 服务端的模块，是在 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.17.1/lib/_http_server.js",title:"https://github.com/nodejs/node/blob/v18.17.1/lib/_http_server.js",target:"_blank",rel:"noopener noreferrer",children:"lib/_http_server.js"})," 路径中，就是导出的这个 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.17.1/lib/_http_server.js#L1176",title:"https://github.com/nodejs/node/blob/v18.17.1/lib/_http_server.js#L1176",target:"_blank",rel:"noopener noreferrer",children:"Server 类"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["在讲 HTTP 的 ",(0,s.jsx)(n.code,{children:"Server"})," 之前，我们先把其依赖的一些内容给讲了。"]}),"\n",(0,s.jsxs)(n.h2,{id:"前置内容",children:["前置内容",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前置内容",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"freelist简易的对象池",children:[(0,s.jsx)(n.code,{children:"FreeList"}),"——简易的对象池",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#freelist简易的对象池",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"它的代码非常简单，就三十行。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"'use strict';\n\nclass FreeList {\n  constructor(name, max, ctor) {\n    this.name = name;\n    // 用于构造对象的函数\n    this.ctor = ctor;\n    this.max = max;\n    this.list = [];\n  }\n\n  alloc() {\n    // 如果池子里尚有对象\n    return this.list.length > 0 ?\n      // 从池子中取出第一个对象\n      this.list.pop() :\n      // 否则，通过 `this.ctor()` 函数重新生成一个对象\n      Reflect.apply(this.ctor, this, arguments);\n  }\n\n  free(obj) {\n    // 如果池子没满\n    if (this.list.length < this.max) {\n      // 将对象放回池子中\n      this.list.push(obj);\n      return true;\n    }\n    \n    // 否则不做回收，等待后续被 GC\n    return false;\n  }\n}\n\nmodule.exports = FreeList;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这段代码定义了一个名为 ",(0,s.jsx)(n.code,{children:"FreeList"})," 的类，设计用于为常用的对象提供一个轻量级的对象池。这种设计模式可以提高性能，特别是在需要频繁创建和销毁对象的情况下。"]}),"\n",(0,s.jsx)(n.p,{children:"在没有“对象池”的情况下，你去饭店吃饭可能是这样的："}),"\n",(0,s.jsx)(n.p,{children:"步骤"}),"\n",(0,s.jsx)(n.p,{children:"厨师做好饭了"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["需要一个碗，开始转转转（",(0,s.jsx)(n.code,{children:"new Bowl()"}),"）"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["把菜盛到碗里（",(0,s.jsx)(n.code,{children:"bowl.init()"}),"）"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["吃完菜（",(0,s.jsx)(n.code,{children:"eat(bowl)"}),"）"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"把碗打碎，打回原形（GC）"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:H,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，在没有对象池的情况下，吃个饭需要不断地做碗、摔碗、做碗、摔碗……"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("img",{src:_,alt:""}),(0,s.jsx)("img",{src:P,alt:""})]}),"\n",(0,s.jsx)(n.p,{children:"如果有了对象池，那么这个环节就不一样了："}),"\n",(0,s.jsx)(n.p,{children:"步骤"}),"\n",(0,s.jsx)(n.p,{children:"厨师做好饭了"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["需要一个碗，从碗柜里拿一个（",(0,s.jsx)(n.code,{children:"bowlList.pop()"}),"），碗柜里没了才重新做一个"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["把菜盛到碗里（",(0,s.jsx)(n.code,{children:"bowl.init()"}),"）"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["吃完菜（",(0,s.jsx)(n.code,{children:"eat(bowl)"}),"）"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["把碗放回碗柜（",(0,s.jsx)(n.code,{children:"bowlList.push(bowl)"}),"），碗柜满了才砸碗"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，原来的不断做碗、砸碗、做碗、砸碗变成了取碗、放碗、取碗、放碗——大大节省了时间。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("img",{src:a,alt:""}),(0,s.jsx)("img",{src:h,alt:""})]}),"\n",(0,s.jsx)(n.p,{children:"当然，取碗后或者放碗前，需不需要洗碗，这个就自己决定啦。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["通过 ",(0,s.jsx)(n.code,{children:"FreeList"})," 类，我们可以为特定的对象创建对象池，从而提高性能和资源利用率。"]}),"\n",(0,s.jsxs)(n.h3,{id:"httpparserhttp-协议格式解析类",children:[(0,s.jsx)(n.code,{children:"HTTPParser"}),"——HTTP 协议格式解析类",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#httpparserhttp-协议格式解析类",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在上一章的玩具中，我们的 HTTP 请求解析非常简单，逐行分，然后再通过空格分。非常不严谨——但有用。"}),"\n",(0,s.jsxs)(n.p,{children:["Node.js 中的 HTTPParser 是基于 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/llhttp/tree/main",title:"https://github.com/nodejs/llhttp/tree/main",target:"_blank",rel:"noopener noreferrer",children:"llhttp"})," 实现的。llhttp 脱胎于 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/http-parser",title:"https://github.com/nodejs/http-parser",target:"_blank",rel:"noopener noreferrer",children:"http-parser"}),"，http-parser 是 Node.js 最开始的用于解析 HTTP 协议数据用的库，也是专为 Node.js 写的。后来由于 http-parser 难以维护，就新搞了个可维护的 llhttp，并且性能有很大的提升。"]}),"\n",(0,s.jsx)(n.p,{children:"http-parser 是直接由 C 语言写的。而 llhttp 则是 TypeScript 为源码，以 TypeScript 源码去生成 C 语言的 llhttp 源码——毕竟 TypeScript 作为更高级的语言，比 C 语言更易维护。"}),"\n",(0,s.jsxs)(n.p,{children:["llhttp 脱胎于 http-parser，所以它跟 http-parser 一样，最终也是一个状态机。还记得我们在第十九章 ",(0,s.jsx)(n.code,{children:"URL"})," 里面提到的吗？",(0,s.jsx)(n.code,{children:"URL"})," 也是基于状态机搞的。TypeScript 写用于生成 C 语言的源码，而 C 源码其实可读性比 http-parser 还低，说它便于维护是它的 TypeScript 生成源码非常好维护。既然原理差不多，这里就不讲 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/main/deps/llhttp/src/llhttp.c",title:"https://github.com/nodejs/node/blob/main/deps/llhttp/src/llhttp.c",target:"_blank",rel:"noopener noreferrer",children:"llhttp 的源码"}),"了，毕竟可读性很差，稍微提一下 http-parser 源码吧。"]}),"\n",(0,s.jsxs)(n.p,{children:["Http-parser 实际上就是一个状态机，比如收到一串数据后，最开始的状态是：请求或响应的开始（",(0,s.jsx)(n.code,{children:"s_start_req_or_res"}),"）。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"switch (CURRENT_STATE()) { // 当前状态\n  ...\n  \n  case s_start_req_or_res:\n  {\n    if (ch == CR || ch == LF)\n      break;\n    parser->flags = 0;\n    parser->uses_transfer_encoding = 0;\n    parser->content_length = ULLONG_MAX;\n\n    if (ch == 'H') {\n      UPDATE_STATE(s_res_or_resp_H);\n\n      CALLBACK_NOTIFY(message_begin);\n    } else {\n      parser->type = HTTP_REQUEST;\n      UPDATE_STATE(s_start_req);\n      REEXECUTE();\n    }\n\n    break;\n  }\n  ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们回忆一下请求行："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"GET /index.html HTTP/1.1\n"})}),"\n",(0,s.jsx)(n.p,{children:"还有响应行："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"HTTP/1.1 405 Method Not Allowed\n"})}),"\n",(0,s.jsxs)(n.p,{children:["按规范，响应行的第一个字符恒为 ",(0,s.jsx)(n.code,{children:"H"}),"，而请求行则是不同的 HTTP 方法，所以有多种可能性。在上面的状态机中，如果是请求或响应的开始，则判断当前字符是否为 ",(0,s.jsx)(n.code,{children:"H"}),"："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["若是，则将状态机的状态变更为请求或响应，且第一个字符为 ",(0,s.jsx)(n.code,{children:"H"}),"（",(0,s.jsx)(n.code,{children:"s_res_or_resp_H"}),"）——因为 ",(0,s.jsx)(n.code,{children:"HEAD"})," 请求的第一个字符也是 ",(0,s.jsx)(n.code,{children:"H"}),"；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["若不是，则将状态机的状态变更为请求行的开始（",(0,s.jsx)(n.code,{children:"s_start_req"}),"），且从第一个字符重新开始执行整个状态机（",(0,s.jsx)(n.code,{children:"REEXECUTE()"}),"）。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这就是第一个状态的转变。接下去就是 ",(0,s.jsx)(n.code,{children:"s_res_or_resp_H"})," 状态："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  case s_res_or_resp_H:\n    if (ch == 'T') {\n      parser->type = HTTP_RESPONSE;\n      UPDATE_STATE(s_res_HT);\n    } else {\n      if (UNLIKELY(ch != 'E')) {\n        SET_ERRNO(HPE_INVALID_CONSTANT);\n        goto error;\n      }\n\n      parser->type = HTTP_REQUEST;\n      parser->method = HTTP_HEAD;\n      parser->index = 2;\n      UPDATE_STATE(s_req_method);\n    }\n    break;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["也很简单，如果第一个是 ",(0,s.jsx)(n.code,{children:"H"}),"，那么后面有两种可能："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"T"}),"：说明后面可能是 ",(0,s.jsx)(n.code,{children:"HTTP"}),"，那么它有可能是个响应行；"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"E"}),"：说明后面可能是 ",(0,s.jsx)(n.code,{children:"HEAD"}),"，那么它有可能是个请求行。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["其它所有情况都是非法情况。所以上面这段代码就很好解释了，如果字符是 ",(0,s.jsx)(n.code,{children:"T"}),"，那么将状态变更为响应行，将此次解析的类型变为“响应（",(0,s.jsx)(n.code,{children:"HTTP_RESPONSE"}),"）”，且前两个字符为 ",(0,s.jsx)(n.code,{children:"HT"}),"（",(0,s.jsx)(n.code,{children:"s_req_HT"}),"）；在剩下的情况中，如果字符不是 ",(0,s.jsx)(n.code,{children:"E"}),"（",(0,s.jsx)(n.code,{children:"UNLIKELY(ch != 'E')"}),"），那么将状态机置为错误（",(0,s.jsx)(n.code,{children:"SET_ERRNO(HPE_INVALID_CONSTANT)"}),"），并进入错误逻辑（",(0,s.jsx)(n.code,{children:"goto error"}),"）；若是 ",(0,s.jsx)(n.code,{children:"E"}),"，那么将此次解析的类型变为“请求（",(0,s.jsx)(n.code,{children:"HTTP_REQUEST"}),"）”，且请求方法为 ",(0,s.jsx)(n.code,{children:"HTTP_HEAD"}),"，将状态变更为请求方法（",(0,s.jsx)(n.code,{children:"s_req_method"}),"）。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果是之前讲的 ",(0,s.jsx)(n.code,{children:"s_start_req"})," 状态，就得回到最开始第一个字符重新来一遍："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  case s_start_req:\n  {\n    if (ch == CR || ch == LF)\n      break;\n    parser->flags = 0;\n    parser->uses_transfer_encoding = 0;\n    parser->content_length = ULLONG_MAX;\n\n    if (UNLIKELY(!IS_ALPHA(ch))) {\n      SET_ERRNO(HPE_INVALID_METHOD);\n      goto error;\n    }\n\n    parser->method = (enum http_method) 0;\n    parser->index = 1;\n    switch (ch) {\n      case 'A': parser->method = HTTP_ACL; break;\n      case 'B': parser->method = HTTP_BIND; break;\n      case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;\n      case 'D': parser->method = HTTP_DELETE; break;\n      case 'G': parser->method = HTTP_GET; break;\n      case 'H': parser->method = HTTP_HEAD; break;\n      case 'L': parser->method = HTTP_LOCK; /* or LINK */ break;\n      case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH, MKCALENDAR */ break;\n      case 'N': parser->method = HTTP_NOTIFY; break;\n      case 'O': parser->method = HTTP_OPTIONS; break;\n      case 'P': parser->method = HTTP_POST;\n        /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */\n        break;\n      case 'R': parser->method = HTTP_REPORT; /* or REBIND */ break;\n      case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH, SOURCE */ break;\n      case 'T': parser->method = HTTP_TRACE; break;\n      case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE, UNBIND, UNLINK */ break;\n      default:\n        SET_ERRNO(HPE_INVALID_METHOD);\n        goto error;\n    }\n    UPDATE_STATE(s_req_method);\n\n    CALLBACK_NOTIFY(message_begin);\n\n    break;\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个很简单，就是枚举所有可能的 HTTP 方法的开始值。其中 ",(0,s.jsx)(n.code,{children:"HEAD"})," 是直接在 ",(0,s.jsx)(n.code,{children:"s_res_or_resp_H"})," 里被更新了，所以理论上这个 ",(0,s.jsx)(n.code,{children:"case"})," 中的 ",(0,s.jsx)(n.code,{children:"'H'"})," 是不会经由最开始转过来的。不过这个 http-parser 会在任意位置和任意状态会被调用，所以还是可能经由其它路径过来的。这里面包含了不同的 HTTP 方法。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"HTTP/1.0"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"HTTP/1.1"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"WebDAV 相关"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Simple Service Discovery Protocol/1.0"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"无"})," ",(0,s.jsx)(n.strong,{children:"RFC"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"GET"}),"、",(0,s.jsx)(n.code,{children:"HEAD"}),"、",(0,s.jsx)(n.code,{children:"POST"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"CONNECT"}),"、",(0,s.jsx)(n.code,{children:"DELETE"}),"、",(0,s.jsx)(n.code,{children:"OPTIONS"}),"、",(0,s.jsx)(n.code,{children:"PUT"}),"、",(0,s.jsx)(n.code,{children:"TRACE"}),"、",(0,s.jsx)(n.code,{children:"PATCH"}),"（后加的）、",(0,s.jsx)(n.code,{children:"LINK"}),"（后加的）、",(0,s.jsx)(n.code,{children:"UNLINK"}),"（后加的）"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ACL"}),"、",(0,s.jsx)(n.code,{children:"BASELINE-CONTROL"}),"、",(0,s.jsx)(n.code,{children:"BIND"}),"、",(0,s.jsx)(n.code,{children:"CHECKIN"}),"、",(0,s.jsx)(n.code,{children:"CHECKOUT"}),"、",(0,s.jsx)(n.code,{children:"COPY"}),"、",(0,s.jsx)(n.code,{children:"LABEL"}),"、",(0,s.jsx)(n.code,{children:"LOCK"}),"、",(0,s.jsx)(n.code,{children:"MERGE"}),"、",(0,s.jsx)(n.code,{children:"MKACTIVITY"}),"、",(0,s.jsx)(n.code,{children:"MKCALENDAR"}),"、",(0,s.jsx)(n.code,{children:"MKCOL"}),"、",(0,s.jsx)(n.code,{children:"MKWORKSPACE"}),"、",(0,s.jsx)(n.code,{children:"MOVE"}),"、",(0,s.jsx)(n.code,{children:"PROPFIND"}),"、",(0,s.jsx)(n.code,{children:"PROPPATCH"}),"、",(0,s.jsx)(n.code,{children:"REBIND"}),"、",(0,s.jsx)(n.code,{children:"REPORT"}),"、",(0,s.jsx)(n.code,{children:"SEARCH"}),"、",(0,s.jsx)(n.code,{children:"UNBIND"}),"、",(0,s.jsx)(n.code,{children:"UNCHECKOUT"}),"、",(0,s.jsx)(n.code,{children:"UNLOCK"}),"、",(0,s.jsx)(n.code,{children:"UNSUBSCRIBE"}),"、",(0,s.jsx)(n.code,{children:"UPDATE"}),"、",(0,s.jsx)(n.code,{children:"VERSION-CONTROL"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"M-SEARCH"}),"、",(0,s.jsx)(n.code,{children:"NOTIFY"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"PURGE"})," 、",(0,s.jsx)(n.code,{children:"SOURCE"}),"（Icecast Protocol）"]}),"\n",(0,s.jsxs)(n.p,{children:["遇到对应的开头字母，就设置成为对应的 HTTP 方法，然后进入 ",(0,s.jsx)(n.code,{children:"s_req_method"})," 状态进行合法性校验。",(0,s.jsx)(n.code,{children:"s_req_method"})," 就是去校验后面几个字符是否与设置好的 HTTP 方法的预期相符，具体就不赘述了。再接下去就是会碰到空格进入 URL 解析阶段（",(0,s.jsx)(n.code,{children:"s_req_spaces_before_url"}),"），然后持续推进到后续阶段。"]}),"\n",(0,s.jsx)(n.p,{children:"http-parser 的状态机就是以上述的方式进行轮转的。只讲最开始的几个状态有助于大家想象整个状态机的全貌——总之就是逐字扫描并记录和判断。"}),"\n",(0,s.jsx)(n.p,{children:"llhttp 原理类似，也是逐字扫描记录判断的状态机。只不过它的代码是通过更容易维护和理解的 TypeScript 生成的 C 代码，开发者只需要专注可读性高的 TypeScript 上的逻辑即可，它生成的 C 语言代码可读性很低。"}),"\n",(0,s.jsxs)(n.h2,{id:"http-的-server",children:["HTTP 的 ",(0,s.jsx)(n.code,{children:"Server"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http-的-server",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上一章中我们提到了，这个 ",(0,s.jsx)(n.code,{children:"Server"})," 就是继承自 ",(0,s.jsx)(n.code,{children:"net.Server"}),"。它构造函数里面是这么写的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function Server(options, requestListener) {\n  ...\n\n  net.Server.call(\n    this,\n    { allowHalfOpen: true, noDelay: options.noDelay,\n      keepAlive: options.keepAlive,\n      keepAliveInitialDelay: options.keepAliveInitialDelay,\n      highWaterMark: options.highWaterMark });\n\n  if (requestListener) {\n    this.on('request', requestListener);\n  }\n\n  ...\n\n  this.on('connection', connectionListener);\n\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这是古早的原型链继承的写法，",(0,s.jsx)(n.code,{children:"net.Server.call(...)"})," 相当于 ",(0,s.jsx)(n.code,{children:"super()"}),"。在调用父类构造函数后，紧接着把 ",(0,s.jsx)(n.code,{children:"request"})," 的事件监听函数加上，同时也把 ",(0,s.jsx)(n.code,{children:"connection"})," 的事件监听加上。"]}),"\n",(0,s.jsxs)(n.p,{children:["在我们上一章中，我们自己的玩具 HTTP 服务端中，就是通过 ",(0,s.jsx)(n.code,{children:"net.createServer()"})," 来创建服务端，并在其中传入 ",(0,s.jsx)(n.code,{children:"connection"})," 事件的回调函数。而 Node.js 的 ",(0,s.jsx)(n.code,{children:"http"})," 模块中，它就是构造好父类的内容后，直接监听事先写好的 ",(0,s.jsx)(n.code,{children:"connection"})," 事件监听函数 ",(0,s.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.17.1/lib/_http_server.js#L617C1-L621C2",title:"https://github.com/nodejs/node/blob/v18.17.1/lib/_http_server.js#L617C1-L621C2",target:"_blank",rel:"noopener noreferrer",children:"connectionListener"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket), connectionListenerInternal, this, socket,\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里面涉及到异步追踪的一些逻辑，",(0,s.jsx)(n.code,{children:"defaultTriggerAsyncIdScope()"})," 不用管，直接看 ",(0,s.jsx)(n.code,{children:"connectionListenerInternal()"})," 就好了，这个是真实的监听函数，Node.js 会往它里面传 ",(0,s.jsx)(n.code,{children:"this"}),"（也就是当前 ",(0,s.jsx)(n.code,{children:"server"})," 对象），以及 ",(0,s.jsx)(n.code,{children:"socket"})," 对象。"]}),"\n",(0,s.jsxs)(n.p,{children:["在我们上一章的玩具中，这个监听函数里面做的事情是，监听从 ",(0,s.jsx)(n.code,{children:"socket"})," 过来的 ",(0,s.jsx)(n.code,{children:"data"})," 事件，并在接收完数据后开始解析、处理数据，最终把需要返还给客户端的内容拼装成 HTTP 响应格式，最终写回给客户端。Node.js 的 HTTP 模块逻辑类似，主要也是监听 ",(0,s.jsx)(n.code,{children:"data"})," 事件进行解析，但是还多了各种其它的监听，比如 ",(0,s.jsx)(n.code,{children:"close"}),"、",(0,s.jsx)(n.code,{children:"end"}),"、",(0,s.jsx)(n.code,{children:"error"}),"、",(0,s.jsx)(n.code,{children:"drain"})," 等，这些都是为了健壮性、边界等方面的考虑。"]}),"\n",(0,s.jsxs)(n.p,{children:["首先，将 ",(0,s.jsx)(n.code,{children:"server"})," 对象与当前 ",(0,s.jsx)(n.code,{children:"socket"})," 绑起来，这样能把两者关系给对上。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function connectionListenerInternal(server, socket) {\n  socket.server = server;\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后做一些超时相关的逻辑，不用太关心，也不展开讲。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  if (server.timeout && typeof socket.setTimeout === 'function')\n    socket.setTimeout(server.timeout);\n  socket.on('timeout', socketOnTimeout);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["接下去为当前 ",(0,s.jsx)(n.code,{children:"socket"})," 对象分配一个 HTTP 格式的解析器。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  const parser = parsers.alloc();\n  const lenient = server.insecureHTTPParser === undefined ?\n    isLenient() : server.insecureHTTPParser;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个 ",(0,s.jsx)(n.code,{children:"parsers"})," 就是前文中提到的 ",(0,s.jsx)(n.code,{children:"FreeList"})," 实例，它池子中存的是由 Node.js 将前文中的 HTTPParser（llhttp）封装起来的对象，用于解析 HTTP 协议的数据（无论是请求还是响应）。——这个就是我们在 ",(0,s.jsx)(n.code,{children:"FreeList"})," 中提到的“拿碗阶段”。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["后面的 ",(0,s.jsx)(n.code,{children:"lenient"})," 表示此次解析 HTTP 协议数据是宽松还是严谨，这个在 HTTP 服务",(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/http.html#httpcreateserveroptions-requestlistener",title:"https://nodejs.org/dist/latest-v18.x/docs/api/http.html#httpcreateserveroptions-requestlistener",target:"_blank",rel:"noopener noreferrer",children:"初始化的时候"}),"通过 ",(0,s.jsx)(n.code,{children:"insecureHTTPParser"})," 参数决定，若未指定，则以启动 Node.js 时候的 ",(0,s.jsx)(n.code,{children:"--insecure-http-parser"})," 为准（",(0,s.jsx)(n.code,{children:"isLenient()"})," 中做的就是这个判断）。"]}),"\n",(0,s.jsx)(n.p,{children:"由于我们拿来的碗有可能是之前用剩下塞回去的，里面还有食物残留，所以拿到碗之后需要洗一遍，重置内部所有状态。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  parser.initialize(\n    HTTPParser.REQUEST,\n    new HTTPServerAsyncResource('HTTPINCOMINGMESSAGE', socket),\n    server.maxHeaderSize || 0,\n    lenient ? kLenientAll : kLenientNone,\n    server[kConnections],\n  );\n  parser.socket = socket;\n  socket.parser = parser;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["将其初始化成“请求”类型，然后将用于异步上下文追踪的 ",(0,s.jsx)(n.code,{children:"HTTPServerAsyncResource"})," 也传进去，然后就是其它一些初始化参数了。最后，把 ",(0,s.jsx)(n.code,{children:"socket"})," 与 ",(0,s.jsx)(n.code,{children:"parser"})," 相互绑定关联。这样，后续 ",(0,s.jsx)(n.code,{children:"socket"})," 收到什么内容，就直接流式传给 ",(0,s.jsx)(n.code,{children:"parser"})," 持续解析即可。"]}),"\n",(0,s.jsx)(n.p,{children:"之后是一些不重要的状态、变量声明。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  const state = {\n    onData: null,\n    onEnd: null,\n    onClose: null,\n    onDrain: null,\n    outgoing: [],\n    incoming: [],\n    // `outgoingData` is an approximate amount of bytes queued through all\n    // inactive responses. If more data than the high watermark is queued - we\n    // need to pause TCP socket/HTTP parser, and wait until the data will be\n    // sent to the client.\n    outgoingData: 0,\n    requestsCount: 0,\n    keepAliveTimeoutSet: false,\n  };\n  state.onData = socketOnData.bind(undefined,\n                                   server, socket, parser, state);\n  state.onEnd = socketOnEnd.bind(undefined,\n                                 server, socket, parser, state);\n  state.onClose = socketOnClose.bind(undefined,\n                                     socket, state);\n  state.onDrain = socketOnDrain.bind(undefined,\n                                     socket, state);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后绑定 ",(0,s.jsx)(n.code,{children:"socket"})," 的各事件。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  socket.on('data', state.onData);\n  socket.on('error', socketOnError);\n  socket.on('end', state.onEnd);\n  socket.on('close', state.onClose);\n  socket.on('drain', state.onDrain);\n  parser.onIncoming = parserOnIncoming.bind(undefined,\n                                            server, socket, state);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["篇幅原因，再之后的代码我们就不讲了。这里最重要的就是 ",(0,s.jsx)(n.code,{children:"socket"})," 的 ",(0,s.jsx)(n.code,{children:"data"})," 事件——它接受到参数的事件。这个事件主要做的事情就是把数据传给 ",(0,s.jsx)(n.code,{children:"parser"})," 进行解析，获得 HTTP 请求的信息。"]}),"\n",(0,s.jsx)(n.p,{children:"下面这个就是绑在事件上的回调函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function socketOnData(server, socket, parser, state, d) {\n  assert(!socket._paused);\n  debug('SERVER socketOnData %d', d.length);\n\n  const ret = parser.execute(d);\n  onParserExecuteCommon(server, socket, parser, state, ret, d);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["前面 4 个参数都是事先 ",(0,s.jsx)(n.code,{children:"bind"})," 好的，最后的 ",(0,s.jsx)(n.code,{children:"d"})," 就是此次接收到的数据。其实做法很简单，执行 ",(0,s.jsx)(n.code,{children:"parser"})," 的 ",(0,s.jsx)(n.code,{children:"execute()"})," 方法，进行进一步解析（也就是执行前文中讲到的状态机）。因为 HTTP 是流式传输的，所以可能这个数据不完整，那么状态机解析到最后一个字符时，会将当前的解析状态存在 ",(0,s.jsx)(n.code,{children:"parser"})," 中，等待后续有数据进入，就可以从当前状态开始继续解析了。"]}),"\n",(0,s.jsxs)(n.p,{children:["一旦 HTTP 请求行和请求头被完整解析，就会触发 ",(0,s.jsx)(n.code,{children:"parser.onIncoming"}),"，也就是我们绑定的 ",(0,s.jsx)(n.code,{children:"parserOnIncoming()"})," 函数。这个函数中会把解析完毕的 ",(0,s.jsx)(n.code,{children:"req"})," 对象传入，该对象就是我们开发者侧使用 HTTP 服务端时回调函数中的那个 ",(0,s.jsx)(n.code,{children:"req"})," 对象。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"function parserOnIncoming(server, socket, state, req, keepAlive) {\n  ...\n  const res = new server[kServerResponse](req,\n                                          {\n                                            highWaterMark: socket.writableHighWaterMark,\n                                            rejectNonStandardBodyWrites: server.rejectNonStandardBodyWrites,\n                                          });\n  ...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个函数绑定的 ",(0,s.jsx)(n.code,{children:"server"})," 就是我们所实例化的 HTTP 服务端对象，它有个私有变量是用于 HTTP 服务端的 ",(0,s.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/http.html#class-httpserverresponse",title:"https://nodejs.org/dist/latest-v18.x/docs/api/http.html#class-httpserverresponse",target:"_blank",rel:"noopener noreferrer",children:"ServerResponse"})," 类。此处我们用这个类来实例化我们的 ",(0,s.jsx)(n.code,{children:"res"})," 变量，这个变量就是后续我们开发者侧使用 HTTP 服务端时回调函数中的那个 ",(0,s.jsx)(n.code,{children:"res"})," 对象了。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"req"})," 和 ",(0,s.jsx)(n.code,{children:"res"})," 都有了，在设置了一堆其它信息后，Node.js 中就会触发 ",(0,s.jsx)(n.code,{children:"request"})," 事件。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"  ...\n  if (!handled) {\n    server.emit('request', req, res);\n  }\n\n  return 0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在我们前文中提到的 ",(0,s.jsx)(n.code,{children:"Server"})," 构造函数中，我们是监听了这个 ",(0,s.jsx)(n.code,{children:"request"})," 事件的，用的就是我们外部传进来的回调函数。但此时后续还有可能会有数据进来，毕竟触发 ",(0,s.jsx)(n.code,{children:"request"})," 事件只是在请求行和请求头解析完之后，后面还有请求体要持续流进来。"]}),"\n",(0,s.jsx)(n.p,{children:"所以这个流程框架其实很简单："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"29流程图1.png"})}),"\n",(0,s.jsxs)(n.p,{children:["而在 ",(0,s.jsx)(n.code,{children:"parser.execute()"})," 中直到 ",(0,s.jsx)(n.code,{children:"request"})," 事件前的流程大体如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"29流程图2.png"})}),"\n",(0,s.jsx)(n.p,{children:"这其实跟我们上一章的简易玩具异曲同工。都是解析完来的 HTTP 请求信息，然后把信息格式化成 JavaScript 中的对象，交给回调函数处理，最终可以让用户写回数据给浏览器。"}),"\n",(0,s.jsxs)(n.p,{children:["写 HTTP 响应的操作是在 ",(0,s.jsx)(n.code,{children:"ServerResponse"})," 类中实现的，也就是我们回调函数中的 ",(0,s.jsx)(n.code,{children:"res"})," 对象。通常我们可以调用 ",(0,s.jsx)(n.code,{children:"setHeader()"}),"、",(0,s.jsx)(n.code,{children:"writeHeader()"}),"、",(0,s.jsx)(n.code,{children:"write()"})," 以及 ",(0,s.jsx)(n.code,{children:"end()"})," 这些来做一些操作。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"setHeader()"})," 就是往 ",(0,s.jsx)(n.code,{children:"ServerResponse"})," 对象中存储好响应头的键值对；而 ",(0,s.jsx)(n.code,{children:"writeHead()"})," 则是连同响应状态码、事先存储好的响应头以及新传进来的响应头键值对一起写入——遵从上一章中我们提到的“响应行”、“响应头”的格式。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"write()"})," 则是写入响应体，也就是 body。若在写入 ",(0,s.jsx)(n.code,{children:"write()"})," 之前，尚未写入过响应行、响应头，也就是尚未调用过 ",(0,s.jsx)(n.code,{children:"writeHeader()"}),"，Node.js 在 ",(0,s.jsx)(n.code,{children:"write()"})," 中会先主动调用一下进行写入——毕竟在 HTTP 格式中，响应行和响应头都是在响应体之前的。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"end()"})," 好理解，除了写入数据之外，还要标记结束。所以 ",(0,s.jsx)(n.code,{children:"write()"})," 可以多次调用，产生流式效果，而 ",(0,s.jsx)(n.code,{children:"end()"})," 只能调用一次——调用了，此次响应就结束了。写入的最终也是通过此次建连的客户端 ",(0,s.jsx)(n.code,{children:"socket"})," 来进行的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"conn = this.socket;\n...\nconn.write(data, encoding, callback);\n"})}),"\n",(0,s.jsx)(n.p,{children:"至此，HTTP 服务端的接受 HTTP 请求、写入 HTTP 响应的逻辑框架就已经讲完了。与上一章的玩具比起来还是多了挺多内容的，但是本质上原理差不多。"}),"\n",(0,s.jsx)(n.p,{children:"HTTPS 服务端很多逻辑也跟 HTTP 是复用的，只不过中间多了 TLS 相关内容。我对密码学不熟悉，这里就不展开讲了。"}),"\n",(0,s.jsxs)(n.h2,{id:"http-服务端小结",children:["HTTP 服务端小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#http-服务端小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章通过深入剖析 Node.js 中的 HTTP 服务端模块，不仅解开了其背后运行的机制，而且展示了与简单玩具版 HTTP 服务端的异同。在这一过程中，我们探讨了几个核心点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"对象池（FreeList）："})," 通过 FreeList 类的实现，我们见识到了如何通过对象池机制优化性能，避免了频繁地创建和销毁对象。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"HTTP 协议解析（HTTPParser）："})," Node.js 采用了基于状态机的方式进行 HTTP 协议的解析，这样不仅提高了解析的效率，还能适应流式传输的需求。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Server 类与事件监听："})," 我们探究了 Node.js HTTP 服务端的 Server 类，发现它继承自 ",(0,s.jsx)(n.code,{children:"net.Server"}),"，并且是通过事件驱动的方式进行请求和响应的处理。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"请求与响应对象："})," 揭示了如何从底层 socket 数据生成更高层次的请求和响应对象（",(0,s.jsx)(n.code,{children:"req"})," 和 ",(0,s.jsx)(n.code,{children:"res"}),"），这两个对象是我们在开发者侧最常与之交互的。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"响应写入："})," 详细介绍了如何通过 ",(0,s.jsx)(n.code,{children:"ServerResponse"})," 类及其方法（例如 ",(0,s.jsx)(n.code,{children:"setHeader()"}),", ",(0,s.jsx)(n.code,{children:"write()"}),", ",(0,s.jsx)(n.code,{children:"end()"})," 等）来构造和发送 HTTP 响应。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"HTTPS 与"})," ",(0,s.jsx)(n.strong,{children:"TLS"})," ",(0,s.jsx)(n.strong,{children:"："})," 虽然本章没有深入到 HTTPS 和 TLS，但指出这部分逻辑与 HTTP 服务端大致相似，主要区别在于加密处理。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"通过以上各点的详细解读，我们不仅理解了 Node.js HTTP 服务端的内部逻辑，还为日后可能的性能优化和扩展打下了坚实的基础。与上一章的玩具服务端相比，Node.js 的 HTTP 模块虽然更为复杂，但其核心逻辑和基础原理大体相同，只是增加了更多的健壮性和灵活性。"}),"\n",(0,s.jsx)(n.p,{children:"总之，这一章不仅提升了我们对 HTTP 和 Node.js 的理解，也展示了如何从源码角度看待一个成熟的库或框架。希望大家能从中受益。"})]})}function S(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(k,{...e})}):k(e)}let N=S;S.__RSPRESS_PAGE_META={},S.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F28-%E9%83%BD%E8%AF%B4%E8%83%BD%E5%86%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9Ahttp%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"前置内容",id:"前置内容",depth:2},{text:"`FreeList`——简易的对象池",id:"freelist简易的对象池",depth:3},{text:"`HTTPParser`——HTTP 协议格式解析类",id:"httpparserhttp-协议格式解析类",depth:3},{text:"HTTP 的 `Server`",id:"http-的-server",depth:2},{text:"HTTP 服务端小结",id:"http-服务端小结",depth:2}],title:"28-都说能写服务端（下）：http（下）",headingTitle:"28-都说能写服务端（下）：http（下）",frontmatter:{}}}}]);