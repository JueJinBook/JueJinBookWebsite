"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["13558"],{118234:function(n,e,c){c.r(e),c.d(e,{default:()=>Z});var s=c(552676),r=c(740453);let i=c.p+"static/image/c884dbb7c7fccf6780d4b8aeac11c342.9766d75f.webp",a=c.p+"static/image/66d31892986ff05fa5b56a6072724d93.63787d77.webp",t=c.p+"static/image/f26423e117459a48382427f343401a43.26759345.webp",d=c.p+"static/image/3a152be7375d7c9c7d2c9a606f345778.5c42fcfd.webp",p=c.p+"static/image/d1b8345e3cc9e2327a693980c0dc92b0.baf0affd.webp",l=c.p+"static/image/264c418fcaf58a53819da04d49516882.7bae8a71.webp",j=c.p+"static/image/f9eb9bc56def74eac715ac8d29c8870e.d2ef5dbc.webp",x=c.p+"static/image/35e0d83a765798e42b2214e26b682c84.4acb8152.webp",h=c.p+"static/image/eb97437d159f787f6965bda71b1de8b5.31d29c35.webp",b=c.p+"static/image/331cfb7b537732553c1411e66385c2b8.718829ee.webp",g=c.p+"static/image/a74b89eedeae56750b0fb5042ba1f342.a64ff14d.webp",o=c.p+"static/image/434b68fca1003978771f5024fb0ee8f5.71953ca0.webp",f=c.p+"static/image/88c701b4c749f401b49b121afedecc27.1925541d.webp",m=c.p+"static/image/cd2e7d32dec671c780691798901adbdc.1bad8c4c.webp",u=c.p+"static/image/0a3368b8e96a5c0e3512c3124acfe4cd.bdfee420.webp",A=c.p+"static/image/c36780c349d43544387a890235713ce2.180b675d.webp",w=c.p+"static/image/4fcb39e62f0fbeb1c69d5c4cfb84a91a.fcecd307.webp",y=c.p+"static/image/1b28840b2a7e18658f7b17df81f1c8ff.a21301b5.webp",E=c.p+"static/image/fdf06104233ad4ade7e7c586a9ae04f2.335787b4.webp",k=c.p+"static/image/82cd9379bdc3684c9d313ebebc54fa1f.657b8433.webp",B=c.p+"static/image/5f9b3f85f666c5112b4672d117175280.892d4b66.webp",O=c.p+"static/image/9b7eea3f29423933033b82c44087444f.5913cc61.webp",M=c.p+"static/image/9d1167ac9cc449d05c05c1b1bed91141.0d69469d.webp",C=c.p+"static/image/9f1af50cb2b120d022862853d2b0b36b.aae86988.webp",F=c.p+"static/image/6d713ef9ae359e833a5c3667f7130da7.23cf5ea7.webp",R=c.p+"static/image/1807ba291772f40a0d8bbaec69957c73.0b9f0466.webp",S=c.p+"static/image/f96bb360fb123700268625a00a291245.efe067cc.webp",G=c.p+"static/image/b3278b101a44e97a60a57acef2c6ad85.93e5c2ec.webp",Q=c.p+"static/image/d0f2f6c7864a62505d3bdf42ebd7e836.01d09b8c.webp",T=c.p+"static/image/9c11efb16b905889cdeded15a11db212.3e7ec2bc.webp",z=c.p+"static/image/ecc540d3e454d26827589901c3dd2755.24f78965.webp",D=c.p+"static/image/c4674e125ab3bc28a19708be341790d4.29c77891.webp";function N(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",pre:"pre",code:"code",img:"img",h2:"h2"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"25加餐一道-3-层的-ts-面试题",children:["25.加餐：一道 3 层的 ts 面试题",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#25加餐一道-3-层的-ts-面试题",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"最近遇见一道不错的 TS 面试题，分享一下。"}),"\n",(0,s.jsx)(e.p,{children:"这道题有 3 个层次，我们一层层来看。"}),"\n",(0,s.jsx)(e.p,{children:"第一层的要求是这样的："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"实现一个 zip 函数，对两个数组的元素按顺序两两合并，比如输入 [1,2,3], [4,5,6] 时，返回 [[1,4], [2,5],[3,6]]"})}),"\n",(0,s.jsx)(e.p,{children:"这层就是每次各从两个数组取一个元素，合并之后放到数组里，然后继续处理下一个，递归进行这个流程，直到数组为空即可。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function zip(target, source) {\n  if (!target.length || !source.length) return [];\n\n  const [one, ...rest1] = target;\n  const [other, ...rest2] = source;\n\n  return [[one, other], ...zip(rest1, rest2)];\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"结果是对的："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"第一层还是比较简单的，然后我们来看第二层要求："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"给这个 zip 函数定义 ts 类型（两种写法）"})}),"\n",(0,s.jsx)(e.p,{children:"函数的定义有两种形式："}),"\n",(0,s.jsx)(e.p,{children:"直接通过 function 声明函数："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function func() {}\n"})}),"\n",(0,s.jsx)(e.p,{children:"和声明匿名函数然后赋值给变量："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const func = () => {}\n"})}),"\n",(0,s.jsx)(e.p,{children:"而参数和返回值的类型都是数组，只是具体类型不知道，可以写 unknown[]。"}),"\n",(0,s.jsx)(e.p,{children:"所以两种函数类型的定义就是这样的："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:z,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"也是直接 function 声明函数类型和 interface 声明函数类型然后加到变量类型上两种。"}),"\n",(0,s.jsx)(e.p,{children:"因为具体元素类型不知道，所以用 unknown。"}),"\n",(0,s.jsx)(e.p,{children:"这里可能会问 any 和 unknown 的区别："}),"\n",(0,s.jsx)(e.p,{children:"any 和 unknown 都可以接收任何类型："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:Q,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"但是 any 也可以赋值给任何类型，但 unknown 不行。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:G,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这里只是用来接收其他类型， 所以 unknown 比any 更合适一些，更安全。"}),"\n",(0,s.jsx)(e.p,{children:"这一层也是比较基础的 ts 语法，第三层就上了难度了："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"用类型编程实现精确的类型提示，比如参数传入 [1,2,3], [4,5,6]，那返回值的类型要提示出 [[1,4], [2,5],[3,6]]"})}),"\n",(0,s.jsx)(e.p,{children:"这里要求返回值类型是精确的，我们就要根据参数的类型来动态生成返回值类型。"}),"\n",(0,s.jsx)(e.p,{children:"也就是这样："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"声明两个类型参数 Target、Source，约束为 unknown[]，也就是元素类型任意的数组类型。"}),"\n",(0,s.jsx)(e.p,{children:"这俩类型参数分别是传入的两个参数的类型。"}),"\n",(0,s.jsx)(e.p,{children:"返回值通过 Zip 计算得出。"}),"\n",(0,s.jsx)(e.p,{children:"然后要实现 Zip 的高级类型："}),"\n",(0,s.jsx)(e.p,{children:"传入的类型参数分别是两个数组类型，我们同样要从中提取出每个元素合并到一起。"}),"\n",(0,s.jsx)(e.p,{children:"提取元素可以用模式匹配的方式："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:F,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"所以这个类型就可以这样定义："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"type Zip<One extends unknown[], Other extends unknown[]> =\n    One extends [infer OneFirst,...infer Rest1]\n      ? Other extends [infer OtherFirst, ...infer Rest2]\n        ? [[OneFirst, OtherFirst], ...Zip<Rest1, Rest2>]\n        : []\n      : [];\n"})}),"\n",(0,s.jsx)(e.p,{children:"分别提取两个数组的第一个元素，构造成新数组。然后对剩下的数组递归进行这样的处理，直到数组为空。"}),"\n",(0,s.jsx)(e.p,{children:"这样就实现了我们想要的高级类型："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"但你把它作为返回值加到函数上会报错："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"因为声明函数的时候都不知道参数是啥，自然计算不出 Zip<Target, Source> 的值，所以这里会类型不匹配："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"那怎么办呢？"}),"\n",(0,s.jsx)(e.p,{children:"可以用函数重载解决："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"ts 支持函数重载，可以写多个同名函数的类型的类型定义，最后写函数的实现，这样用到这个函数的时候会根据参数的类型来匹配函数类型。"}),"\n",(0,s.jsx)(e.p,{children:"我们用了类型编程的那个函数通过这种方式写就不会报错了。"}),"\n",(0,s.jsx)(e.p,{children:"我们使用下看看："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"咋返回值的类型不对呢？"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"其实这时候匹配的函数类型是对的，只不过推导出的不是字面量类型。"}),"\n",(0,s.jsx)(e.p,{children:"这时候可以加个 as const。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"但是加上 as const 会推导出 readonly [1,2,3]"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这样类型就不匹配了，所以要在类型参数的声明上也加上 readonly:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"但这样 Zip 函数的类型又不匹配了。"}),"\n",(0,s.jsx)(e.p,{children:"难道要把所有用到这个类型的地方都加上 readonly 么？"}),"\n",(0,s.jsx)(e.p,{children:"不用，我们 readonly 的修饰去掉不就行了？"}),"\n",(0,s.jsx)(e.p,{children:"Typescript 有内置的高级类型 readonly："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"可以把索引类型的每个索引都加上 readonly 修饰："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"但没有提供去掉 readonly 修饰的高级类型，我们可以自己实现一下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"用映射类型的语法构造个新索引类型，加上个 -readonly 就是去掉 readonly 修饰的意思。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"有的同学可能问了，数组类型也是索引类型么？"}),"\n",(0,s.jsx)(e.p,{children:"是，索引类型是聚合多个元素的类型，所以对象、数组、class 都是。"}),"\n",(0,s.jsx)(e.p,{children:"所以我们把它用在数组上自然也是可以的："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"（准确来说叫元组，元组是元素个数固定的数组）"}),"\n",(0,s.jsx)(e.p,{children:"那我们只要在传入 Zip 之前，用 Mutable 去掉 readonly 就可以了："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"再来试一下："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"大功告成！现在返回值的类型就对了。"}),"\n",(0,s.jsx)(e.p,{children:"但还有个问题，如果不是直接传入字面量，是推导不出字面量类型的，这时候貌似就不对了："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"可我们不都声明重载类型了么？"}),"\n",(0,s.jsx)(e.p,{children:"如果推导不出字面量类型，应该匹配这个呀："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"但实际上它匹配的还是第一个："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这时候其实只要调换下两个函数类型的顺序就可以了："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"这时字面量参数的情况依然也是对的："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"为什么呢？"}),"\n",(0,s.jsxs)(e.p,{children:["因为",(0,s.jsx)(e.strong,{children:"重载函数的类型是从上到下依次匹配，只要匹配到一个就应用。"})]}),"\n",(0,s.jsx)(e.p,{children:"非字面量的情况，类型是 number[]，能匹配 unknown[] 的那个类型，所以那个函数类型生效了。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(e.p,{children:"而字面量的情况，推导出的是 readonly [1,2,3]，带有 readonly 所以不匹配 unknown[]，继续往下匹配，就匹配到了带有类型参数的那个函数类型。"}),"\n",(0,s.jsx)(e.p,{children:"这样两种情况就都应用了合适的函数类型。"}),"\n",(0,s.jsx)(e.p,{children:"全部代码是这样的："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-typescript",children:"type Zip<One extends unknown[], Other extends unknown[]> = One extends [\n  infer OneFirst,\n  ...infer Rest1\n]\n  ? Other extends [infer OtherFirst, ...infer Rest2]\n    ? [[OneFirst, OtherFirst], ...Zip<Rest1, Rest2>]\n    : []\n  : [];\n\ntype Mutable<Obj> = {\n  -readonly [Key in keyof Obj]: Obj[Key];\n};\n\nfunction zip(target: unknown[], source: unknown[]): unknown[];\n\nfunction zip<Target extends readonly unknown[], Source extends readonly unknown[]>(\n  target: Target,\n  source: Source\n): Zip<Mutable<Target>, Mutable<Source>>;\n\nfunction zip(target: unknown[], source: unknown[]) {\n  if (!target.length || !source.length) return [];\n\n  const [one, ...rest1] = target;\n  const [other, ...rest2] = source;\n\n  return [[one, other], ...zip(rest1, rest2)];\n}\n\nconst result = zip([1, 2, 3] as const, [4, 5, 6] as const);\n\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, '5', 6];\n\nconst result2 = zip(arr1, arr2);\n\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.typescriptlang.org/play?#code/C4TwDgpgBAWglmAPAeQHbQgD2BVATAZygFdUBrVAewHdUBtAXQBoplgALCAJyix3yKkKNegwB8UALxQAUFFbpe2XISh04qAGbcFEAGJwuBYCwB05jdp4AlCMYCMDOfKgB+Vhx18VRdVp1snFwGRiZQ5qaWOrbGAExOLi7udHRo+obGLIHcIcbM4ebwSDHA9iwlsWIJiVAAXGrV8vWMANwyMqCQUACyxMAAhgBGADYQKIMAVhLSAN7OALRcEP14lKjDIGoA0hCbGlBku5SarJMM9ciTdDsgDG0Avm0ymqQAxsBwa1AAXggAFAMuABzCDAepCKi0RgsAiUYhcV4QcHkSGiACUyOEULu7ReqHen1QPwQiAAKv1gaClPxVEsVmsNiQUSJoVAAMpwhEYZQCKB01brTYQlniP7OQEgsFQcmUkzOWHwxH1DmKiAyDGwEm9AYjMYyyViFjaoajRAqrliMRPPEEr6-MAAimSzGo1kKrkukVoqBzeRwE5-ACEEtBplGqCBHCgAB9o1BA+7EWHcJH2N6lsB4UTWu15K81sY1GsIGZzEsHAwpFAQ8A2nmC8Ai54uKXTOXgPEq4mIE95Bms2o6MWWJRm-kIva-u2yny7B20Tj7u186hC+XiMNG9JJ3QZ7EWABmSv9IgrzJqAAsLAArCwAGzH08NtFPM+NilcexV3csfdQI9tG+UAfrE35XlAADk14QfeOIyEB66bqB27-B+M4gS+QA",target:"_blank",rel:"noopener noreferrer",children:"ts playground 地址"})}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"今天我们做了一道综合的 ts 面试题，一共有三层："}),"\n",(0,s.jsx)(e.p,{children:"第一层实现 js 的逻辑，用递归或者循环都能实现。"}),"\n",(0,s.jsx)(e.p,{children:"第二层给函数加上类型，用 function 声明类型和 interface 声明函数类型两种方式，参数和返回值都是 unknown[]。"}),"\n",(0,s.jsx)(e.p,{children:"第三层是用类型编程实现精准的类型提示，这一层需要拿到参数的类型，通过提取元素的类型并构造出新的数组类型返回。还要通过函数重载的方式来声明类型，并且要注意重载类型的声明顺序。"}),"\n",(0,s.jsx)(e.p,{children:"as const 能够让字面量推导出字面量类型，但会带有 readonly 修饰，可以自己写映射类型来去掉这个修饰。"}),"\n",(0,s.jsx)(e.p,{children:"其实这也是我们学习 ts 的顺序，我们先要能把 js 逻辑写出来，然后知道怎么给函数、class 等加 ts 类型，之后学习类型编程，知道怎么动态生成类型。"}),"\n",(0,s.jsx)(e.p,{children:"其中类型编程是 ts 最难的部分，也是最强大的部分。攻克了这一层，ts 就可以说学的差不多了。"})]})}function V(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(N,{...n})}):N(n)}let Z=V;V.__RSPRESS_PAGE_META={},V.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F25.%E5%8A%A0%E9%A4%90%EF%BC%9A%E4%B8%80%E9%81%93%203%20%E5%B1%82%E7%9A%84%20ts%20%E9%9D%A2%E8%AF%95%E9%A2%98.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"25.加餐：一道 3 层的 ts 面试题",headingTitle:"25.加餐：一道 3 层的 ts 面试题",frontmatter:{}}}}]);