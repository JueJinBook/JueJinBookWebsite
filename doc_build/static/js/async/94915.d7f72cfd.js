"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["94915"],{563763:function(e,r,n){n.r(r),n.d(r,{default:()=>h});var o=n(552676),s=n(740453);function c(e){let r=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",pre:"pre",code:"code"},(0,s.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(r.h1,{id:"实践之路在开发环境中使用服务发现",children:["实践之路：在开发环境中使用服务发现",(0,o.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#实践之路在开发环境中使用服务发现",children:"#"})]}),"\n",(0,o.jsx)(r.p,{children:"服务发现应用是很多服务化系统的组成部分，所以在开发、测试环境中也就有必要配备一套服务发现体系来配合我们的开发、测试工作。在这一小节里，我们就来谈谈如何在 Docker 环境下部署服务发现应用。"}),"\n",(0,o.jsxs)(r.h2,{id:"使用-docker-compose-模拟-zookeeper-集群",children:["使用 Docker Compose 模拟 Zookeeper 集群",(0,o.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-docker-compose-模拟-zookeeper-集群",children:"#"})]}),"\n",(0,o.jsx)(r.p,{children:"实现服务发现的方法有很多种，其中较为常见的一种是利用分布式注册中心，解决服务之间协调的问题。"}),"\n",(0,o.jsx)(r.p,{children:"在众多注册中心应用中，Zookeeper 是较为常见和常用的一款程序，这里我们就以 Zookeeper 为例，介绍如何使用 Docker 搭建 Zookeeper 的运行环境。"}),"\n",(0,o.jsxs)(r.h3,{id:"设计目录结构",children:["设计目录结构",(0,o.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#设计目录结构",children:"#"})]}),"\n",(0,o.jsx)(r.p,{children:"由于 Zookeeper 的运行并不需要太多的关注配置和调整，这里我们就以最基础的形式来设计 Docker Compose 项目的结构。"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"└─ project\n   ├─ bin\n   │  └─ compose.sh\n   └─ compose\n      └─ docker-compose.yml\n\n"})}),"\n",(0,o.jsxs)(r.p,{children:["为了方便日常操作，我们依然编写了 ",(0,o.jsx)(r.a,{href:"http://compose.sh",target:"_blank",rel:"noopener noreferrer",children:"compose.sh"})," 这个脚本来辅助我们控制 Docker Compose 项目。"]}),"\n",(0,o.jsxs)(r.h3,{id:"编写-docker-composeyml",children:["编写 docker-compose.yml",(0,o.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#编写-docker-composeyml",children:"#"})]}),"\n",(0,o.jsx)(r.p,{children:"很多读者会问到一个问题，怎么样才能通过 Docker 的虚拟化技术实现在一个机器上模拟出多台机器的效果。或者说一个我们这里会涉及的具体问题，如何只用一个 Docker 来模拟一个高可用的 Zookeeper 集群。"}),"\n",(0,o.jsx)(r.p,{children:"我们知道，要实现 Zookeeper 的高可用，至少需要三个 Zookeeper 节点进行协作，所以这里我们用三个单独的 Docker Compose 服务定义来分别定义这三个节点。"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"version: '3'\n\nservices:\n\n  zk1:\n    image: zookeeper:3.4\n    restart: always\n    hostname: zk1\n    environment:\n      ZOO_MY_ID: 1\n      ZOO_SERVERS: server.1=0.0.0.0:2888:3888 server.2=zk2:2888:3888 server.3=zk3:2888:3888\n    ports:\n      - 2181:2181\n\n  zk2:\n    image: zookeeper:3.4\n    restart: always\n    hostname: zk2\n    environment:\n      ZOO_MY_ID: 2\n      ZOO_SERVERS: server.1=zk1:2888:3888 server.2=0.0.0.0:2888:3888 server.3=zk3:2888:3888\n    ports:\n      - 2182:2181\n\n  zk3:\n    image: zookeeper:3.4\n    restart: always\n    hostname: zk3\n    environment:\n      ZOO_MY_ID: 3\n      ZOO_SERVERS: server.1=zk1:2888:3888 server.2=zk2:2888:3888 server.3=0.0.0.0:2888:3888\n    ports:\n      - 2183:2181\n\n"})}),"\n",(0,o.jsx)(r.p,{children:"在这个 Docker Compose 项目中，我们定义的三个 Zookeeper 服务都直接使用了官方制作的 zookeeper 镜像。"}),"\n",(0,o.jsx)(r.p,{children:"在这个镜像里，我们可以留意定制 ZOO_MY_ID 和 ZOO_SERVERS 这两个环境变量。这两个变量主要是用来识别 Zookeeper 集群中不同 Zookeeper 程序的。"}),"\n",(0,o.jsx)(r.p,{children:"其中 ZOO_MY_ID 是 Zookeeper 在集群中的编号，而 ZOO_SERVERS 用来定义集群中的所有 Zookeeper 及它们的连接方式。"}),"\n",(0,o.jsx)(r.p,{children:"我们以 zk1 这个服务为例来解释一下 ZOO_SERVERS 的定义方法。"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"server.1=0.0.0.0:2888:3888 server.2=zk2:2888:3888 server.3=zk3:2888:3888\n\n"})}),"\n",(0,o.jsxs)(r.p,{children:["我们可以在 ZOO_SERVERS 中定义所有处于 Zookeeper 集群中的程序，通过空格来间隔它们。而每个服务的的定义形式为 ",(0,o.jsx)(r.code,{children:"server.[id]=[host]:[port]:[port]"}),"，所以就有了上面例子中我们看到的样子。"]}),"\n",(0,o.jsx)(r.p,{children:"在这个例子里，我们描述了三个 Zookeeper 程序的连接地址。"}),"\n",(0,o.jsx)(r.p,{children:"由于每个容器都有独立的端口表，所以即使这些程序都运行在一个主机里，我们依然不需要担心，它们会造成端口的冲突。所以这里我们直接使用默认的 2888 和 3888 来进行服务间的相互通信即可。"}),"\n",(0,o.jsx)(r.p,{children:"而在进行容器互联的过程中，我们可以通过 Docker 的解析机制，直接填入对应服务的名称替代它们的 IP 地址，也就是这个例子里的 zk2 和 zk3。"}),"\n",(0,o.jsxs)(r.h3,{id:"重启机制",children:["重启机制",(0,o.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#重启机制",children:"#"})]}),"\n",(0,o.jsxs)(r.p,{children:["在项目定义中，我们还注意到了 ",(0,o.jsx)(r.code,{children:"restart: always"})," 这个配置，这个配置主要是用来控制容器的重启策略的。"]}),"\n",(0,o.jsx)(r.p,{children:"这里的 always 指的是不论任何情况，容器出现问题后都会自动重启，也包括 Docker 服务本身在启动后容器也会自动启动。"}),"\n",(0,o.jsx)(r.p,{children:"另外，restart 还支持几种配置："}),"\n",(0,o.jsx)(r.p,{children:"配置值"}),"\n",(0,o.jsx)(r.p,{children:"说明"}),"\n",(0,o.jsx)(r.p,{children:"no"}),"\n",(0,o.jsx)(r.p,{children:"不设重启机制"}),"\n",(0,o.jsx)(r.p,{children:"always"}),"\n",(0,o.jsx)(r.p,{children:"总是重启"}),"\n",(0,o.jsx)(r.p,{children:"on-failure"}),"\n",(0,o.jsx)(r.p,{children:"在异常退出时重启"}),"\n",(0,o.jsx)(r.p,{children:"unless-stopped"}),"\n",(0,o.jsx)(r.p,{children:"除非由停止命令结束，其他情况都重启"}),"\n",(0,o.jsx)(r.p,{children:"在实际使用中，我们可以根据需要选择不同的重启策略。"}),"\n",(0,o.jsx)(r.p,{children:"而这个项目里，我们希望 Zookeeper 能够一直健壮的运行，所以使用了 always 这个重启策略。"}),"\n",(0,o.jsxs)(r.h2,{id:"启动项目",children:["启动项目",(0,o.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#启动项目",children:"#"})]}),"\n",(0,o.jsx)(r.p,{children:"一切就绪，我们就可以直接通过 Docker Compose 的命令来启动开发环境了。"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"# ./bin/compose.sh up -d\n\n"})}),"\n",(0,o.jsxs)(r.h2,{id:"留言互动",children:["留言互动",(0,o.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#留言互动",children:"#"})]}),"\n",(0,o.jsx)(r.p,{children:"在这节中，我们展示了在开发中使用 Docker 部署服务发现工具的过程，下面就是大家自己动手进行实践的时候了。"}),"\n",(0,o.jsx)(r.p,{children:"本小节中的示例，已经更新到了："}),"\n",(0,o.jsx)(r.p,{children:(0,o.jsx)(r.a,{href:"https://github.com/youmingdot/docker-book-for-developer-samples",target:"_blank",rel:"noopener noreferrer",children:(0,o.jsx)(r.a,{href:"https://github.com/youmingdot/docker-book-for-developer-samples",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/youmingdot/docker-book-for-developer-samples"})})}),"\n",(0,o.jsx)(r.p,{children:"大家可以在实践过程中的用其作为参考。"}),"\n",(0,o.jsx)(r.p,{children:"欢迎大家通过留言的方式说出你的实践之路。我会选出有代表性的优质留言，推荐给大家。"}),"\n",(0,o.jsx)(r.p,{children:"同时，如果大家在实践过程中遇到困难，或者有自己的实践心得要与大家分享，可以加入到这本小册的官方微信群中，参与对相关问题的讨论。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),e.components);return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E7%9A%84%20Docker%20%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%9A%E5%9C%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.md"]={toc:[{text:"使用 Docker Compose 模拟 Zookeeper 集群",id:"使用-docker-compose-模拟-zookeeper-集群",depth:2},{text:"设计目录结构",id:"设计目录结构",depth:3},{text:"编写 docker-compose.yml",id:"编写-docker-composeyml",depth:3},{text:"重启机制",id:"重启机制",depth:3},{text:"启动项目",id:"启动项目",depth:2},{text:"留言互动",id:"留言互动",depth:2}],title:"实践之路：在开发环境中使用服务发现",headingTitle:"实践之路：在开发环境中使用服务发现",frontmatter:{}}}}]);