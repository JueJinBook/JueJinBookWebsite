"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["86003"],{672976:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var c=r(552676),s=r(740453);function o(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",ul:"ul",li:"li",strong:"strong",h3:"h3"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"15proxy",children:["15.Proxy",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15proxy",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"概述",children:["概述",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#概述",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。"}),"\n",(0,c.jsx)(n.p,{children:"Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var obj = new Proxy({}, {\n  get: function (target, propKey, receiver) {\n    console.log(`getting ${propKey}!`);\n    return Reflect.get(target, propKey, receiver);\n  },\n  set: function (target, propKey, value, receiver) {\n    console.log(`setting ${propKey}!`);\n    return Reflect.set(target, propKey, value, receiver);\n  }\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码对一个空对象架设了一层拦截，重定义了属性的读取（",(0,c.jsx)(n.code,{children:"get"}),"）和设置（",(0,c.jsx)(n.code,{children:"set"}),"）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象",(0,c.jsx)(n.code,{children:"obj"}),"，去读写它的属性，就会得到下面的结果。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"obj.count = 1\n//  setting count!\n++obj.count\n//  getting count!\n//  setting count!\n//  2\n"})}),"\n",(0,c.jsx)(n.p,{children:"上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。"}),"\n",(0,c.jsx)(n.p,{children:"ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var proxy = new Proxy(target, handler);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Proxy 对象的所有用法，都是上面这种形式，不同的只是",(0,c.jsx)(n.code,{children:"handler"}),"参数的写法。其中，",(0,c.jsx)(n.code,{children:"new Proxy()"}),"表示生成一个",(0,c.jsx)(n.code,{children:"Proxy"}),"实例，",(0,c.jsx)(n.code,{children:"target"}),"参数表示所要拦截的目标对象，",(0,c.jsx)(n.code,{children:"handler"}),"参数也是一个对象，用来定制拦截行为。"]}),"\n",(0,c.jsx)(n.p,{children:"下面是另一个拦截读取属性行为的例子。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var proxy = new Proxy({}, {\n  get: function(target, propKey) {\n    return 35;\n  }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，作为构造函数，",(0,c.jsx)(n.code,{children:"Proxy"}),"接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有",(0,c.jsx)(n.code,{children:"Proxy"}),"的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个",(0,c.jsx)(n.code,{children:"get"}),"方法，用来拦截对目标对象属性的访问请求。",(0,c.jsx)(n.code,{children:"get"}),"方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回",(0,c.jsx)(n.code,{children:"35"}),"，所以访问任何属性都得到",(0,c.jsx)(n.code,{children:"35"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，要使得",(0,c.jsx)(n.code,{children:"Proxy"}),"起作用，必须针对",(0,c.jsx)(n.code,{children:"Proxy"}),"实例（上例是",(0,c.jsx)(n.code,{children:"proxy"}),"对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。"]}),"\n",(0,c.jsxs)(n.p,{children:["如果",(0,c.jsx)(n.code,{children:"handler"}),"没有设置任何拦截，那就等同于直接通向原对象。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var target = {};\nvar handler = {};\nvar proxy = new Proxy(target, handler);\nproxy.a = 'b';\ntarget.a // \"b\"\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"handler"}),"是一个空对象，没有任何拦截效果，访问",(0,c.jsx)(n.code,{children:"proxy"}),"就等同于访问",(0,c.jsx)(n.code,{children:"target"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["一个技巧是将 Proxy 对象，设置到",(0,c.jsx)(n.code,{children:"object.proxy"}),"属性，从而可以在",(0,c.jsx)(n.code,{children:"object"}),"对象上调用。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var object = { proxy: new Proxy(target, handler) };\n"})}),"\n",(0,c.jsx)(n.p,{children:"Proxy 实例也可以作为其他对象的原型对象。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var proxy = new Proxy({}, {\n  get: function(target, propKey) {\n    return 35;\n  }\n});\n\nlet obj = Object.create(proxy);\nobj.time // 35\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"proxy"}),"对象是",(0,c.jsx)(n.code,{children:"obj"}),"对象的原型，",(0,c.jsx)(n.code,{children:"obj"}),"对象本身并没有",(0,c.jsx)(n.code,{children:"time"}),"属性，所以根据原型链，会在",(0,c.jsx)(n.code,{children:"proxy"}),"对象上读取该属性，导致被拦截。"]}),"\n",(0,c.jsx)(n.p,{children:"同一个拦截器函数，可以设置拦截多个操作。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var handler = {\n  get: function(target, name) {\n    if (name === 'prototype') {\n      return Object.prototype;\n    }\n    return 'Hello, ' + name;\n  },\n\n  apply: function(target, thisBinding, args) {\n    return args[0];\n  },\n\n  construct: function(target, args) {\n    return {value: args[1]};\n  }\n};\n\nvar fproxy = new Proxy(function(x, y) {\n  return x + y;\n}, handler);\n\nfproxy(1, 2) // 1\nnew fproxy(1, 2) // {value: 2}\nfproxy.prototype === Object.prototype // true\nfproxy.foo === \"Hello, foo\" // true\n"})}),"\n",(0,c.jsx)(n.p,{children:"对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。"}),"\n",(0,c.jsx)(n.p,{children:"下面是 Proxy 支持的拦截操作一览，一共 13 种。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"get(target, propKey, receiver)"}),"：拦截对象属性的读取，比如",(0,c.jsx)(n.code,{children:"proxy.foo"}),"和",(0,c.jsx)(n.code,{children:"proxy['foo']"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"set(target, propKey, value, receiver)"}),"：拦截对象属性的设置，比如",(0,c.jsx)(n.code,{children:"proxy.foo = v"}),"或",(0,c.jsx)(n.code,{children:"proxy['foo'] = v"}),"，返回一个布尔值。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"has(target, propKey)"}),"：拦截",(0,c.jsx)(n.code,{children:"propKey in proxy"}),"的操作，返回一个布尔值。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"deleteProperty(target, propKey)"}),"：拦截",(0,c.jsx)(n.code,{children:"delete proxy[propKey]"}),"的操作，返回一个布尔值。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"ownKeys(target)"}),"：拦截",(0,c.jsx)(n.code,{children:"Object.getOwnPropertyNames(proxy)"}),"、",(0,c.jsx)(n.code,{children:"Object.getOwnPropertySymbols(proxy)"}),"、",(0,c.jsx)(n.code,{children:"Object.keys(proxy)"}),"、",(0,c.jsx)(n.code,{children:"for...in"}),"循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而",(0,c.jsx)(n.code,{children:"Object.keys()"}),"的返回结果仅包括目标对象自身的可遍历属性。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"getOwnPropertyDescriptor(target, propKey)"}),"：拦截",(0,c.jsx)(n.code,{children:"Object.getOwnPropertyDescriptor(proxy, propKey)"}),"，返回属性的描述对象。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"defineProperty(target, propKey, propDesc)"}),"：拦截",(0,c.jsx)(n.code,{children:"Object.defineProperty(proxy, propKey, propDesc）"}),"、",(0,c.jsx)(n.code,{children:"Object.defineProperties(proxy, propDescs)"}),"，返回一个布尔值。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"preventExtensions(target)"}),"：拦截",(0,c.jsx)(n.code,{children:"Object.preventExtensions(proxy)"}),"，返回一个布尔值。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"getPrototypeOf(target)"}),"：拦截",(0,c.jsx)(n.code,{children:"Object.getPrototypeOf(proxy)"}),"，返回一个对象。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"isExtensible(target)"}),"：拦截",(0,c.jsx)(n.code,{children:"Object.isExtensible(proxy)"}),"，返回一个布尔值。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"setPrototypeOf(target, proto)"}),"：拦截",(0,c.jsx)(n.code,{children:"Object.setPrototypeOf(proxy, proto)"}),"，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"apply(target, object, args)"}),"：拦截 Proxy 实例作为函数调用的操作，比如",(0,c.jsx)(n.code,{children:"proxy(...args)"}),"、",(0,c.jsx)(n.code,{children:"proxy.call(object, ...args)"}),"、",(0,c.jsx)(n.code,{children:"proxy.apply(...)"}),"。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"construct(target, args)"}),"：拦截 Proxy 实例作为构造函数调用的操作，比如",(0,c.jsx)(n.code,{children:"new proxy(...args)"}),"。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"proxy-实例的方法",children:["Proxy 实例的方法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#proxy-实例的方法",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"下面是上面这些拦截方法的详细介绍。"}),"\n",(0,c.jsxs)(n.h3,{id:"get",children:["get()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#get",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"get"}),"方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"get"}),"方法的用法，上文已经有一个例子，下面是另一个拦截读取操作的例子。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'var person = {\n  name: "张三"\n};\n\nvar proxy = new Proxy(person, {\n  get: function(target, propKey) {\n    if (propKey in target) {\n      return target[propKey];\n    } else {\n      throw new ReferenceError("Prop name \\"" + propKey + "\\" does not exist.");\n    }\n  }\n});\n\nproxy.name // "张三"\nproxy.age // 抛出一个错误\n'})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回",(0,c.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"get"}),"方法可以继承。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"let proto = new Proxy({}, {\n  get(target, propertyKey, receiver) {\n    console.log('GET ' + propertyKey);\n    return target[propertyKey];\n  }\n});\n\nlet obj = Object.create(proto);\nobj.foo // \"GET foo\"\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，拦截操作定义在",(0,c.jsx)(n.code,{children:"Prototype"}),"对象上面，所以如果读取",(0,c.jsx)(n.code,{children:"obj"}),"对象继承的属性时，拦截会生效。"]}),"\n",(0,c.jsxs)(n.p,{children:["下面的例子使用",(0,c.jsx)(n.code,{children:"get"}),"拦截，实现数组读取负数的索引。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function createArray(...elements) {\n  let handler = {\n    get(target, propKey, receiver) {\n      let index = Number(propKey);\n      if (index < 0) {\n        propKey = String(target.length + index);\n      }\n      return Reflect.get(target, propKey, receiver);\n    }\n  };\n\n  let target = [];\n  target.push(...elements);\n  return new Proxy(target, handler);\n}\n\nlet arr = createArray('a', 'b', 'c');\narr[-1] // c\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，数组的位置参数是",(0,c.jsx)(n.code,{children:"-1"}),"，就会输出数组的倒数第一个成员。"]}),"\n",(0,c.jsxs)(n.p,{children:["利用 Proxy，可以将读取属性的操作（",(0,c.jsx)(n.code,{children:"get"}),"），转变为执行某个函数，从而实现属性的链式操作。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'var pipe = function (value) {\n  var funcStack = [];\n  var oproxy = new Proxy({} , {\n    get : function (pipeObject, fnName) {\n      if (fnName === \'get\') {\n        return funcStack.reduce(function (val, fn) {\n          return fn(val);\n        },value);\n      }\n      funcStack.push(window[fnName]);\n      return oproxy;\n    }\n  });\n\n  return oproxy;\n}\n\nvar double = n => n * 2;\nvar pow    = n => n * n;\nvar reverseInt = n => n.toString().split("").reverse().join("") | 0;\n\npipe(3).double.pow.reverseInt.get; // 63\n'})}),"\n",(0,c.jsx)(n.p,{children:"上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。"}),"\n",(0,c.jsxs)(n.p,{children:["下面的例子则是利用",(0,c.jsx)(n.code,{children:"get"}),"拦截，实现一个生成各种 DOM 节点的通用函数",(0,c.jsx)(n.code,{children:"dom"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const dom = new Proxy({}, {\n  get(target, property) {\n    return function(attrs = {}, ...children) {\n      const el = document.createElement(property);\n      for (let prop of Object.keys(attrs)) {\n        el.setAttribute(prop, attrs[prop]);\n      }\n      for (let child of children) {\n        if (typeof child === 'string') {\n          child = document.createTextNode(child);\n        }\n        el.appendChild(child);\n      }\n      return el;\n    }\n  }\n});\n\nconst el = dom.div({},\n  'Hello, my name is ',\n  dom.a({href: '//example.com'}, 'Mark'),\n  '. I like:',\n  dom.ul({},\n    dom.li({}, 'The web'),\n    dom.li({}, 'Food'),\n    dom.li({}, '…actually that\\'s it')\n  )\n);\n\ndocument.body.appendChild(el);\n"})}),"\n",(0,c.jsxs)(n.p,{children:["下面是一个",(0,c.jsx)(n.code,{children:"get"}),"方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const proxy = new Proxy({}, {\n  get: function(target, key, receiver) {\n    return receiver;\n  }\n});\nproxy.getReceiver === proxy // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"proxy"}),"对象的",(0,c.jsx)(n.code,{children:"getReceiver"}),"属性会被",(0,c.jsx)(n.code,{children:"get()"}),"拦截，得到的返回值就是",(0,c.jsx)(n.code,{children:"proxy"}),"对象。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const proxy = new Proxy({}, {\n  get: function(target, key, receiver) {\n    return receiver;\n  }\n});\n\nconst d = Object.create(proxy);\nd.a === d // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"d"}),"对象本身没有",(0,c.jsx)(n.code,{children:"a"}),"属性，所以读取",(0,c.jsx)(n.code,{children:"d.a"}),"的时候，会去",(0,c.jsx)(n.code,{children:"d"}),"的原型",(0,c.jsx)(n.code,{children:"proxy"}),"对象找。这时，",(0,c.jsx)(n.code,{children:"receiver"}),"就指向",(0,c.jsx)(n.code,{children:"d"}),"，代表原始的读操作所在的那个对象。"]}),"\n",(0,c.jsx)(n.p,{children:"如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const target = Object.defineProperties({}, {\n  foo: {\n    value: 123,\n    writable: false,\n    configurable: false\n  },\n});\n\nconst handler = {\n  get(target, propKey) {\n    return 'abc';\n  }\n};\n\nconst proxy = new Proxy(target, handler);\n\nproxy.foo\n// TypeError: Invariant check failed\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"set",children:["set()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"set"}),"方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。"]}),"\n",(0,c.jsxs)(n.p,{children:["假定",(0,c.jsx)(n.code,{children:"Person"}),"对象有一个",(0,c.jsx)(n.code,{children:"age"}),"属性，该属性应该是一个不大于 200 的整数，那么可以使用",(0,c.jsx)(n.code,{children:"Proxy"}),"保证",(0,c.jsx)(n.code,{children:"age"}),"的属性值符合要求。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"let validator = {\n  set: function(obj, prop, value) {\n    if (prop === 'age') {\n      if (!Number.isInteger(value)) {\n        throw new TypeError('The age is not an integer');\n      }\n      if (value > 200) {\n        throw new RangeError('The age seems invalid');\n      }\n    }\n\n    // 对于满足条件的 age 属性以及其他属性，直接保存\n    obj[prop] = value;\n    return true;\n  }\n};\n\nlet person = new Proxy({}, validator);\n\nperson.age = 100;\n\nperson.age // 100\nperson.age = 'young' // 报错\nperson.age = 300 // 报错\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，由于设置了存值函数",(0,c.jsx)(n.code,{children:"set"}),"，任何不符合要求的",(0,c.jsx)(n.code,{children:"age"}),"属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用",(0,c.jsx)(n.code,{children:"set"}),"方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。"]}),"\n",(0,c.jsxs)(n.p,{children:["有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合",(0,c.jsx)(n.code,{children:"get"}),"和",(0,c.jsx)(n.code,{children:"set"}),"方法，就可以做到防止这些内部属性被外部读写。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const handler = {\n  get (target, key) {\n    invariant(key, 'get');\n    return target[key];\n  },\n  set (target, key, value) {\n    invariant(key, 'set');\n    target[key] = value;\n    return true;\n  }\n};\nfunction invariant (key, action) {\n  if (key[0] === '_') {\n    throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n  }\n}\nconst target = {};\nconst proxy = new Proxy(target, handler);\nproxy._prop\n// Error: Invalid attempt to get private \"_prop\" property\nproxy._prop = 'c'\n// Error: Invalid attempt to set private \"_prop\" property\n"})}),"\n",(0,c.jsx)(n.p,{children:"上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。"}),"\n",(0,c.jsxs)(n.p,{children:["下面是",(0,c.jsx)(n.code,{children:"set"}),"方法第四个参数的例子。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n    return true;\n  }\n};\nconst proxy = new Proxy({}, handler);\nproxy.foo = 'bar';\nproxy.foo === proxy // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"set"}),"方法的第四个参数",(0,c.jsx)(n.code,{children:"receiver"}),"，指的是原始的操作行为所在的那个对象，一般情况下是",(0,c.jsx)(n.code,{children:"proxy"}),"实例本身，请看下面的例子。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n    return true;\n  }\n};\nconst proxy = new Proxy({}, handler);\nconst myObj = {};\nObject.setPrototypeOf(myObj, proxy);\n\nmyObj.foo = 'bar';\nmyObj.foo === myObj // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，设置",(0,c.jsx)(n.code,{children:"myObj.foo"}),"属性的值时，",(0,c.jsx)(n.code,{children:"myObj"}),"并没有",(0,c.jsx)(n.code,{children:"foo"}),"属性，因此引擎会到",(0,c.jsx)(n.code,{children:"myObj"}),"的原型链去找",(0,c.jsx)(n.code,{children:"foo"}),"属性。",(0,c.jsx)(n.code,{children:"myObj"}),"的原型对象",(0,c.jsx)(n.code,{children:"proxy"}),"是一个 Proxy 实例，设置它的",(0,c.jsx)(n.code,{children:"foo"}),"属性会触发",(0,c.jsx)(n.code,{children:"set"}),"方法。这时，第四个参数",(0,c.jsx)(n.code,{children:"receiver"}),"就指向原始赋值行为所在的对象",(0,c.jsx)(n.code,{children:"myObj"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，如果目标对象自身的某个属性不可写，那么",(0,c.jsx)(n.code,{children:"set"}),"方法将不起作用。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const obj = {};\nObject.defineProperty(obj, 'foo', {\n  value: 'bar',\n  writable: false\n});\n\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = 'baz';\n    return true;\n  }\n};\n\nconst proxy = new Proxy(obj, handler);\nproxy.foo = 'baz';\nproxy.foo // \"bar\"\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"obj.foo"}),"属性不可写，Proxy 对这个属性的",(0,c.jsx)(n.code,{children:"set"}),"代理将不会生效。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，",(0,c.jsx)(n.code,{children:"set"}),"代理应当返回一个布尔值。严格模式下，",(0,c.jsx)(n.code,{children:"set"}),"代理如果没有返回",(0,c.jsx)(n.code,{children:"true"}),"，就会报错。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"'use strict';\nconst handler = {\n  set: function(obj, prop, value, receiver) {\n    obj[prop] = receiver;\n    // 无论有没有下面这一行，都会报错\n    return false;\n  }\n};\nconst proxy = new Proxy({}, handler);\nproxy.foo = 'bar';\n// TypeError: 'set' on proxy: trap returned falsish for property 'foo'\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，严格模式下，",(0,c.jsx)(n.code,{children:"set"}),"代理返回",(0,c.jsx)(n.code,{children:"false"}),"或者",(0,c.jsx)(n.code,{children:"undefined"}),"，都会报错。"]}),"\n",(0,c.jsxs)(n.h3,{id:"apply",children:["apply()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#apply",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"apply"}),"方法拦截函数的调用、",(0,c.jsx)(n.code,{children:"call"}),"和",(0,c.jsx)(n.code,{children:"apply"}),"操作。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"apply"}),"方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（",(0,c.jsx)(n.code,{children:"this"}),"）和目标对象的参数数组。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var handler = {\n  apply (target, ctx, args) {\n    return Reflect.apply(...arguments);\n  }\n};\n"})}),"\n",(0,c.jsx)(n.p,{children:"下面是一个例子。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var target = function () { return 'I am the target'; };\nvar handler = {\n  apply: function () {\n    return 'I am the proxy';\n  }\n};\n\nvar p = new Proxy(target, handler);\n\np()\n// \"I am the proxy\"\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，变量",(0,c.jsx)(n.code,{children:"p"}),"是 Proxy 的实例，当它作为函数调用时（",(0,c.jsx)(n.code,{children:"p()"}),"），就会被",(0,c.jsx)(n.code,{children:"apply"}),"方法拦截，返回一个字符串。"]}),"\n",(0,c.jsx)(n.p,{children:"下面是另外一个例子。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var twice = {\n  apply (target, ctx, args) {\n    return Reflect.apply(...arguments) * 2;\n  }\n};\nfunction sum (left, right) {\n  return left + right;\n};\nvar proxy = new Proxy(sum, twice);\nproxy(1, 2) // 6\nproxy.call(null, 5, 6) // 22\nproxy.apply(null, [7, 8]) // 30\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，每当执行",(0,c.jsx)(n.code,{children:"proxy"}),"函数（直接调用或",(0,c.jsx)(n.code,{children:"call"}),"和",(0,c.jsx)(n.code,{children:"apply"}),"调用），就会被",(0,c.jsx)(n.code,{children:"apply"}),"方法拦截。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外，直接调用",(0,c.jsx)(n.code,{children:"Reflect.apply"}),"方法，也会被拦截。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"Reflect.apply(proxy, null, [9, 10]) // 38\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"has",children:["has()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#has",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"has()"}),"方法用来拦截",(0,c.jsx)(n.code,{children:"HasProperty"}),"操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是",(0,c.jsx)(n.code,{children:"in"}),"运算符。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"has()"}),"方法可以接受两个参数，分别是目标对象、需查询的属性名。"]}),"\n",(0,c.jsxs)(n.p,{children:["下面的例子使用",(0,c.jsx)(n.code,{children:"has()"}),"方法隐藏某些属性，不被",(0,c.jsx)(n.code,{children:"in"}),"运算符发现。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var handler = {\n  has (target, key) {\n    if (key[0] === '_') {\n      return false;\n    }\n    return key in target;\n  }\n};\nvar target = { _prop: 'foo', prop: 'foo' };\nvar proxy = new Proxy(target, handler);\n'_prop' in proxy // false\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，如果原对象的属性名的第一个字符是下划线，",(0,c.jsx)(n.code,{children:"proxy.has()"}),"就会返回",(0,c.jsx)(n.code,{children:"false"}),"，从而不会被",(0,c.jsx)(n.code,{children:"in"}),"运算符发现。"]}),"\n",(0,c.jsxs)(n.p,{children:["如果原对象不可配置或者禁止扩展，这时",(0,c.jsx)(n.code,{children:"has()"}),"拦截会报错。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var obj = { a: 10 };\nObject.preventExtensions(obj);\n\nvar p = new Proxy(obj, {\n  has: function(target, prop) {\n    return false;\n  }\n});\n\n'a' in p // TypeError is thrown\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"obj"}),"对象禁止扩展，结果使用",(0,c.jsx)(n.code,{children:"has"}),"拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则",(0,c.jsx)(n.code,{children:"has()"}),"方法就不得“隐藏”（即返回",(0,c.jsx)(n.code,{children:"false"}),"）目标对象的该属性。"]}),"\n",(0,c.jsxs)(n.p,{children:["值得注意的是，",(0,c.jsx)(n.code,{children:"has()"}),"方法拦截的是",(0,c.jsx)(n.code,{children:"HasProperty"}),"操作，而不是",(0,c.jsx)(n.code,{children:"HasOwnProperty"}),"操作，即",(0,c.jsx)(n.code,{children:"has()"}),"方法不判断一个属性是对象自身的属性，还是继承的属性。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外，虽然",(0,c.jsx)(n.code,{children:"for...in"}),"循环也用到了",(0,c.jsx)(n.code,{children:"in"}),"运算符，但是",(0,c.jsx)(n.code,{children:"has()"}),"拦截对",(0,c.jsx)(n.code,{children:"for...in"}),"循环不生效。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"let stu1 = {name: '张三', score: 59};\nlet stu2 = {name: '李四', score: 99};\n\nlet handler = {\n  has(target, prop) {\n    if (prop === 'score' && target[prop] < 60) {\n      console.log(`${target.name} 不及格`);\n      return false;\n    }\n    return prop in target;\n  }\n}\n\nlet oproxy1 = new Proxy(stu1, handler);\nlet oproxy2 = new Proxy(stu2, handler);\n\n'score' in oproxy1\n// 张三 不及格\n// false\n\n'score' in oproxy2\n// true\n\nfor (let a in oproxy1) {\n  console.log(oproxy1[a]);\n}\n// 张三\n// 59\n\nfor (let b in oproxy2) {\n  console.log(oproxy2[b]);\n}\n// 李四\n// 99\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"has()"}),"拦截只对",(0,c.jsx)(n.code,{children:"in"}),"运算符生效，对",(0,c.jsx)(n.code,{children:"for...in"}),"循环不生效，导致不符合要求的属性没有被",(0,c.jsx)(n.code,{children:"for...in"}),"循环所排除。"]}),"\n",(0,c.jsxs)(n.h3,{id:"construct",children:["construct()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#construct",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"construct()"}),"方法用于拦截",(0,c.jsx)(n.code,{children:"new"}),"命令，下面是拦截对象的写法。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const handler = {\n  construct (target, args, newTarget) {\n    return new target(...args);\n  }\n};\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"construct()"}),"方法可以接受三个参数。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"target"}),"：目标对象。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"args"}),"：构造函数的参数数组。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"newTarget"}),"：创造实例对象时，",(0,c.jsx)(n.code,{children:"new"}),"命令作用的构造函数（下面例子的",(0,c.jsx)(n.code,{children:"p"}),"）。"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const p = new Proxy(function () {}, {\n  construct: function(target, args) {\n    console.log('called: ' + args.join(', '));\n    return { value: args[0] * 10 };\n  }\n});\n\n(new p(1)).value\n// \"called: 1\"\n// 10\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"construct()"}),"方法返回的必须是一个对象，否则会报错。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const p = new Proxy(function() {}, {\n  construct: function(target, argumentsList) {\n    return 1;\n  }\n});\n\nnew p() // 报错\n// Uncaught TypeError: 'construct' on proxy: trap returned non-object ('1')\n"})}),"\n",(0,c.jsxs)(n.p,{children:["另外，由于",(0,c.jsx)(n.code,{children:"construct()"}),"拦截的是构造函数，所以它的目标对象必须是函数，否则就会报错。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const p = new Proxy({}, {\n  construct: function(target, argumentsList) {\n    return {};\n  }\n});\n\nnew p() // 报错\n// Uncaught TypeError: p is not a constructor\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面例子中，拦截的目标对象不是一个函数，而是一个对象（",(0,c.jsx)(n.code,{children:"new Proxy()"}),"的第一个参数），导致报错。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，",(0,c.jsx)(n.code,{children:"construct()"}),"方法中的",(0,c.jsx)(n.code,{children:"this"}),"指向的是",(0,c.jsx)(n.code,{children:"handler"}),"，而不是实例对象。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const handler = {\n  construct: function(target, args) {\n    console.log(this === handler);\n    return new target(...args);\n  }\n}\n\nlet p = new Proxy(function () {}, handler);\nnew p() // true\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"deleteproperty",children:["deleteProperty()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#deleteproperty",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"deleteProperty"}),"方法用于拦截",(0,c.jsx)(n.code,{children:"delete"}),"操作，如果这个方法抛出错误或者返回",(0,c.jsx)(n.code,{children:"false"}),"，当前属性就无法被",(0,c.jsx)(n.code,{children:"delete"}),"命令删除。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var handler = {\n  deleteProperty (target, key) {\n    invariant(key, 'delete');\n    delete target[key];\n    return true;\n  }\n};\nfunction invariant (key, action) {\n  if (key[0] === '_') {\n    throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);\n  }\n}\n\nvar target = { _prop: 'foo' };\nvar proxy = new Proxy(target, handler);\ndelete proxy._prop\n// Error: Invalid attempt to delete private \"_prop\" property\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"deleteProperty"}),"方法拦截了",(0,c.jsx)(n.code,{children:"delete"}),"操作符，删除第一个字符为下划线的属性会报错。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，目标对象自身的不可配置（configurable）的属性，不能被",(0,c.jsx)(n.code,{children:"deleteProperty"}),"方法删除，否则报错。"]}),"\n",(0,c.jsxs)(n.h3,{id:"defineproperty",children:["defineProperty()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#defineproperty",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"defineProperty()"}),"方法拦截了",(0,c.jsx)(n.code,{children:"Object.defineProperty()"}),"操作。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var handler = {\n  defineProperty (target, key, descriptor) {\n    return false;\n  }\n};\nvar target = {};\nvar proxy = new Proxy(target, handler);\nproxy.foo = 'bar' // 不会生效\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"defineProperty()"}),"方法内部没有任何操作，只返回",(0,c.jsx)(n.code,{children:"false"}),"，导致添加新属性总是无效。注意，这里的",(0,c.jsx)(n.code,{children:"false"}),"只是用来提示操作失败，本身并不能阻止添加新属性。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，如果目标对象不可扩展（non-extensible），则",(0,c.jsx)(n.code,{children:"defineProperty()"}),"不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则",(0,c.jsx)(n.code,{children:"defineProperty()"}),"方法不得改变这两个设置。"]}),"\n",(0,c.jsxs)(n.h3,{id:"getownpropertydescriptor",children:["getOwnPropertyDescriptor()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#getownpropertydescriptor",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"getOwnPropertyDescriptor()"}),"方法拦截",(0,c.jsx)(n.code,{children:"Object.getOwnPropertyDescriptor()"}),"，返回一个属性描述对象或者",(0,c.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var handler = {\n  getOwnPropertyDescriptor (target, key) {\n    if (key[0] === '_') {\n      return;\n    }\n    return Object.getOwnPropertyDescriptor(target, key);\n  }\n};\nvar target = { _foo: 'bar', baz: 'tar' };\nvar proxy = new Proxy(target, handler);\nObject.getOwnPropertyDescriptor(proxy, 'wat')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, '_foo')\n// undefined\nObject.getOwnPropertyDescriptor(proxy, 'baz')\n// { value: 'tar', writable: true, enumerable: true, configurable: true }\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"handler.getOwnPropertyDescriptor()"}),"方法对于第一个字符为下划线的属性名会返回",(0,c.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"getprototypeof",children:["getPrototypeOf()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#getprototypeof",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"getPrototypeOf()"}),"方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"Object.prototype.__proto__"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"Object.prototype.isPrototypeOf()"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"Object.getPrototypeOf()"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"Reflect.getPrototypeOf()"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"instanceof"})}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"下面是一个例子。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var proto = {};\nvar p = new Proxy({}, {\n  getPrototypeOf(target) {\n    return proto;\n  }\n});\nObject.getPrototypeOf(p) === proto // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"getPrototypeOf()"}),"方法拦截",(0,c.jsx)(n.code,{children:"Object.getPrototypeOf()"}),"，返回",(0,c.jsx)(n.code,{children:"proto"}),"对象。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，",(0,c.jsx)(n.code,{children:"getPrototypeOf()"}),"方法的返回值必须是对象或者",(0,c.jsx)(n.code,{children:"null"}),"，否则报错。另外，如果目标对象不可扩展（non-extensible）， ",(0,c.jsx)(n.code,{children:"getPrototypeOf()"}),"方法必须返回目标对象的原型对象。"]}),"\n",(0,c.jsxs)(n.h3,{id:"isextensible",children:["isExtensible()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#isextensible",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"isExtensible()"}),"方法拦截",(0,c.jsx)(n.code,{children:"Object.isExtensible()"}),"操作。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'var p = new Proxy({}, {\n  isExtensible: function(target) {\n    console.log("called");\n    return true;\n  }\n});\n\nObject.isExtensible(p)\n// "called"\n// true\n'})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码设置了",(0,c.jsx)(n.code,{children:"isExtensible()"}),"方法，在调用",(0,c.jsx)(n.code,{children:"Object.isExtensible"}),"时会输出",(0,c.jsx)(n.code,{children:"called"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。"}),"\n",(0,c.jsxs)(n.p,{children:["这个方法有一个强限制，它的返回值必须与目标对象的",(0,c.jsx)(n.code,{children:"isExtensible"}),"属性保持一致，否则就会抛出错误。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"Object.isExtensible(proxy) === Object.isExtensible(target)\n"})}),"\n",(0,c.jsx)(n.p,{children:"下面是一个例子。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var p = new Proxy({}, {\n  isExtensible: function(target) {\n    return false;\n  }\n});\n\nObject.isExtensible(p)\n// Uncaught TypeError: 'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"ownkeys",children:["ownKeys()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ownkeys",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"Object.getOwnPropertyNames()"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"Object.getOwnPropertySymbols()"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"Object.keys()"})}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"for...in"}),"循环"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["下面是拦截",(0,c.jsx)(n.code,{children:"Object.keys()"}),"的例子。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"let target = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\nlet handler = {\n  ownKeys(target) {\n    return ['a'];\n  }\n};\n\nlet proxy = new Proxy(target, handler);\n\nObject.keys(proxy)\n// [ 'a' ]\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码拦截了对于",(0,c.jsx)(n.code,{children:"target"}),"对象的",(0,c.jsx)(n.code,{children:"Object.keys()"}),"操作，只返回",(0,c.jsx)(n.code,{children:"a"}),"、",(0,c.jsx)(n.code,{children:"b"}),"、",(0,c.jsx)(n.code,{children:"c"}),"三个属性之中的",(0,c.jsx)(n.code,{children:"a"}),"属性。"]}),"\n",(0,c.jsx)(n.p,{children:"下面的例子是拦截第一个字符为下划线的属性名。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"let target = {\n  _bar: 'foo',\n  _prop: 'bar',\n  prop: 'baz'\n};\n\nlet handler = {\n  ownKeys (target) {\n    return Reflect.ownKeys(target).filter(key => key[0] !== '_');\n  }\n};\n\nlet proxy = new Proxy(target, handler);\nfor (let key of Object.keys(proxy)) {\n  console.log(target[key]);\n}\n// \"baz\"\n"})}),"\n",(0,c.jsxs)(n.p,{children:["注意，使用",(0,c.jsx)(n.code,{children:"Object.keys()"}),"方法时，有三类属性会被",(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法自动过滤，不会返回。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"目标对象上不存在的属性"}),"\n",(0,c.jsx)(n.li,{children:"属性名为 Symbol 值"}),"\n",(0,c.jsxs)(n.li,{children:["不可遍历（",(0,c.jsx)(n.code,{children:"enumerable"}),"）的属性"]}),"\n"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"let target = {\n  a: 1,\n  b: 2,\n  c: 3,\n  [Symbol.for('secret')]: '4',\n};\n\nObject.defineProperty(target, 'key', {\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: 'static'\n});\n\nlet handler = {\n  ownKeys(target) {\n    return ['a', 'd', Symbol.for('secret'), 'key'];\n  }\n};\n\nlet proxy = new Proxy(target, handler);\n\nObject.keys(proxy)\n// ['a']\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法之中，显式返回不存在的属性（",(0,c.jsx)(n.code,{children:"d"}),"）、Symbol 值（",(0,c.jsx)(n.code,{children:"Symbol.for('secret')"}),"）、不可遍历的属性（",(0,c.jsx)(n.code,{children:"key"}),"），结果都被自动过滤掉。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法还可以拦截",(0,c.jsx)(n.code,{children:"Object.getOwnPropertyNames()"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var p = new Proxy({}, {\n  ownKeys: function(target) {\n    return ['a', 'b', 'c'];\n  }\n});\n\nObject.getOwnPropertyNames(p)\n// [ 'a', 'b', 'c' ]\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"for...in"}),"循环也受到",(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法的拦截。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const obj = { hello: 'world' };\nconst proxy = new Proxy(obj, {\n  ownKeys: function () {\n    return ['a', 'b'];\n  }\n});\n\nfor (let key in proxy) {\n  console.log(key); // 没有任何输出\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"ownkeys()"}),"指定只返回",(0,c.jsx)(n.code,{children:"a"}),"和",(0,c.jsx)(n.code,{children:"b"}),"属性，由于",(0,c.jsx)(n.code,{children:"obj"}),"没有这两个属性，因此",(0,c.jsx)(n.code,{children:"for...in"}),"循环不会有任何输出。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var obj = {};\n\nvar p = new Proxy(obj, {\n  ownKeys: function(target) {\n    return [123, true, undefined, null, {}, []];\n  }\n});\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 123 is not a valid property name\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。"]}),"\n",(0,c.jsxs)(n.p,{children:["如果目标对象自身包含不可配置的属性，则该属性必须被",(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法返回，否则报错。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var obj = {};\nObject.defineProperty(obj, 'a', {\n  configurable: false,\n  enumerable: true,\n  value: 10 }\n);\n\nvar p = new Proxy(obj, {\n  ownKeys: function(target) {\n    return ['b'];\n  }\n});\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a'\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"obj"}),"对象的",(0,c.jsx)(n.code,{children:"a"}),"属性是不可配置的，这时",(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法返回的数组之中，必须包含",(0,c.jsx)(n.code,{children:"a"}),"，否则会报错。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外，如果目标对象是不可扩展的（non-extensible），这时",(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var obj = {\n  a: 1\n};\n\nObject.preventExtensions(obj);\n\nvar p = new Proxy(obj, {\n  ownKeys: function(target) {\n    return ['a', 'b'];\n  }\n});\n\nObject.getOwnPropertyNames(p)\n// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"obj"}),"对象是不可扩展的，这时",(0,c.jsx)(n.code,{children:"ownKeys()"}),"方法返回的数组之中，包含了",(0,c.jsx)(n.code,{children:"obj"}),"对象的多余属性",(0,c.jsx)(n.code,{children:"b"}),"，所以导致了报错。"]}),"\n",(0,c.jsxs)(n.h3,{id:"preventextensions",children:["preventExtensions()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#preventextensions",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"preventExtensions()"}),"方法拦截",(0,c.jsx)(n.code,{children:"Object.preventExtensions()"}),"。该方法必须返回一个布尔值，否则会被自动转为布尔值。"]}),"\n",(0,c.jsxs)(n.p,{children:["这个方法有一个限制，只有目标对象不可扩展时（即",(0,c.jsx)(n.code,{children:"Object.isExtensible(proxy)"}),"为",(0,c.jsx)(n.code,{children:"false"}),"），",(0,c.jsx)(n.code,{children:"proxy.preventExtensions"}),"才能返回",(0,c.jsx)(n.code,{children:"true"}),"，否则会报错。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var proxy = new Proxy({}, {\n  preventExtensions: function(target) {\n    return true;\n  }\n});\n\nObject.preventExtensions(proxy)\n// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"proxy.preventExtensions()"}),"方法返回",(0,c.jsx)(n.code,{children:"true"}),"，但这时",(0,c.jsx)(n.code,{children:"Object.isExtensible(proxy)"}),"会返回",(0,c.jsx)(n.code,{children:"true"}),"，因此报错。"]}),"\n",(0,c.jsxs)(n.p,{children:["为了防止出现这个问题，通常要在",(0,c.jsx)(n.code,{children:"proxy.preventExtensions()"}),"方法里面，调用一次",(0,c.jsx)(n.code,{children:"Object.preventExtensions()"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var proxy = new Proxy({}, {\n  preventExtensions: function(target) {\n    console.log('called');\n    Object.preventExtensions(target);\n    return true;\n  }\n});\n\nObject.preventExtensions(proxy)\n// \"called\"\n// Proxy {}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"setprototypeof",children:["setPrototypeOf()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#setprototypeof",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"setPrototypeOf()"}),"方法主要用来拦截",(0,c.jsx)(n.code,{children:"Object.setPrototypeOf()"}),"方法。"]}),"\n",(0,c.jsx)(n.p,{children:"下面是一个例子。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"var handler = {\n  setPrototypeOf (target, proto) {\n    throw new Error('Changing the prototype is forbidden');\n  }\n};\nvar proto = {};\nvar target = function () {};\nvar proxy = new Proxy(target, handler);\nObject.setPrototypeOf(proxy, proto);\n// Error: Changing the prototype is forbidden\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，只要修改",(0,c.jsx)(n.code,{children:"target"}),"的原型对象，就会报错。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），",(0,c.jsx)(n.code,{children:"setPrototypeOf()"}),"方法不得改变目标对象的原型。"]}),"\n",(0,c.jsxs)(n.h2,{id:"proxyrevocable",children:["Proxy.revocable()",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#proxyrevocable",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Proxy.revocable()"}),"方法返回一个可取消的 Proxy 实例。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"let target = {};\nlet handler = {};\n\nlet {proxy, revoke} = Proxy.revocable(target, handler);\n\nproxy.foo = 123;\nproxy.foo // 123\n\nrevoke();\nproxy.foo // TypeError: Revoked\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Proxy.revocable()"}),"方法返回一个对象，该对象的",(0,c.jsx)(n.code,{children:"proxy"}),"属性是",(0,c.jsx)(n.code,{children:"Proxy"}),"实例，",(0,c.jsx)(n.code,{children:"revoke"}),"属性是一个函数，可以取消",(0,c.jsx)(n.code,{children:"Proxy"}),"实例。上面代码中，当执行",(0,c.jsx)(n.code,{children:"revoke"}),"函数之后，再访问",(0,c.jsx)(n.code,{children:"Proxy"}),"实例，就会抛出一个错误。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Proxy.revocable()"}),"的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。"]}),"\n",(0,c.jsxs)(n.h2,{id:"this-问题",children:["this 问题",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#this-问题",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的",(0,c.jsx)(n.code,{children:"this"}),"关键字会指向 Proxy 代理。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const target = {\n  m: function () {\n    console.log(this === proxy);\n  }\n};\nconst handler = {};\n\nconst proxy = new Proxy(target, handler);\n\ntarget.m() // false\nproxy.m()  // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，一旦",(0,c.jsx)(n.code,{children:"proxy"}),"代理",(0,c.jsx)(n.code,{children:"target"}),"，",(0,c.jsx)(n.code,{children:"target.m()"}),"内部的",(0,c.jsx)(n.code,{children:"this"}),"就是指向",(0,c.jsx)(n.code,{children:"proxy"}),"，而不是",(0,c.jsx)(n.code,{children:"target"}),"。所以，虽然",(0,c.jsx)(n.code,{children:"proxy"}),"没有做任何拦截，",(0,c.jsx)(n.code,{children:"target.m()"}),"和",(0,c.jsx)(n.code,{children:"proxy.m()"}),"返回不一样的结果。"]}),"\n",(0,c.jsxs)(n.p,{children:["下面是一个例子，由于",(0,c.jsx)(n.code,{children:"this"}),"指向的变化，导致 Proxy 无法代理目标对象。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const _name = new WeakMap();\n\nclass Person {\n  constructor(name) {\n    _name.set(this, name);\n  }\n  get name() {\n    return _name.get(this);\n  }\n}\n\nconst jane = new Person('Jane');\njane.name // 'Jane'\n\nconst proxy = new Proxy(jane, {});\nproxy.name // undefined\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，目标对象",(0,c.jsx)(n.code,{children:"jane"}),"的",(0,c.jsx)(n.code,{children:"name"}),"属性，实际保存在外部",(0,c.jsx)(n.code,{children:"WeakMap"}),"对象",(0,c.jsx)(n.code,{children:"_name"}),"上面，通过",(0,c.jsx)(n.code,{children:"this"}),"键区分。由于通过",(0,c.jsx)(n.code,{children:"proxy.name"}),"访问时，",(0,c.jsx)(n.code,{children:"this"}),"指向",(0,c.jsx)(n.code,{children:"proxy"}),"，导致无法取到值，所以返回",(0,c.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["此外，有些原生对象的内部属性，只有通过正确的",(0,c.jsx)(n.code,{children:"this"}),"才能拿到，所以 Proxy 也无法代理这些原生对象的属性。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const target = new Date();\nconst handler = {};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate();\n// TypeError: this is not a Date object.\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面代码中，",(0,c.jsx)(n.code,{children:"getDate()"}),"方法只能在",(0,c.jsx)(n.code,{children:"Date"}),"对象实例上面拿到，如果",(0,c.jsx)(n.code,{children:"this"}),"不是",(0,c.jsx)(n.code,{children:"Date"}),"对象实例就会报错。这时，",(0,c.jsx)(n.code,{children:"this"}),"绑定原始对象，就可以解决这个问题。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const target = new Date('2015-01-01');\nconst handler = {\n  get(target, prop) {\n    if (prop === 'getDate') {\n      return target.getDate.bind(target);\n    }\n    return Reflect.get(target, prop);\n  }\n};\nconst proxy = new Proxy(target, handler);\n\nproxy.getDate() // 1\n"})}),"\n",(0,c.jsxs)(n.p,{children:["另外，Proxy 拦截函数内部的",(0,c.jsx)(n.code,{children:"this"}),"，指向的是",(0,c.jsx)(n.code,{children:"handler"}),"对象。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const handler = {\n  get: function (target, key, receiver) {\n    console.log(this === handler);\n    return 'Hello, ' + key;\n  },\n  set: function (target, key, value) {\n    console.log(this === handler);\n    target[key] = value;\n    return true;\n  }\n};\n\nconst proxy = new Proxy({}, handler);\n\nproxy.foo\n// true\n// Hello, foo\n\nproxy.foo = 1\n// true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["上面例子中，",(0,c.jsx)(n.code,{children:"get()"}),"和",(0,c.jsx)(n.code,{children:"set()"}),"拦截函数内部的",(0,c.jsx)(n.code,{children:"this"}),"，指向的都是",(0,c.jsx)(n.code,{children:"handler"}),"对象。"]}),"\n",(0,c.jsxs)(n.h2,{id:"实例web-服务的客户端",children:["实例：Web 服务的客户端",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例web-服务的客户端",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const service = createWebService('http://example.com/data');\n\nservice.employees().then(json => {\n  const employees = JSON.parse(json);\n  // \xb7\xb7\xb7\n});\n"})}),"\n",(0,c.jsx)(n.p,{children:"上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function createWebService(baseUrl) {\n  return new Proxy({}, {\n    get(target, propKey, receiver) {\n      return () => httpGet(baseUrl + '/' + propKey);\n    }\n  });\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"同理，Proxy 也可以用来实现数据库的 ORM 层。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(o,{...e})}):o(e)}let d=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F15.Proxy.md"]={toc:[{text:"概述",id:"概述",depth:2},{text:"Proxy 实例的方法",id:"proxy-实例的方法",depth:2},{text:"get()",id:"get",depth:3},{text:"set()",id:"set",depth:3},{text:"apply()",id:"apply",depth:3},{text:"has()",id:"has",depth:3},{text:"construct()",id:"construct",depth:3},{text:"deleteProperty()",id:"deleteproperty",depth:3},{text:"defineProperty()",id:"defineproperty",depth:3},{text:"getOwnPropertyDescriptor()",id:"getownpropertydescriptor",depth:3},{text:"getPrototypeOf()",id:"getprototypeof",depth:3},{text:"isExtensible()",id:"isextensible",depth:3},{text:"ownKeys()",id:"ownkeys",depth:3},{text:"preventExtensions()",id:"preventextensions",depth:3},{text:"setPrototypeOf()",id:"setprototypeof",depth:3},{text:"Proxy.revocable()",id:"proxyrevocable",depth:2},{text:"this 问题",id:"this-问题",depth:2},{text:"实例：Web 服务的客户端",id:"实例web-服务的客户端",depth:2}],title:"15.Proxy",headingTitle:"15.Proxy",frontmatter:{}}}}]);