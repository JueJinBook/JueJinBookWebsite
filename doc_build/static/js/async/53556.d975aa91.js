"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["53556"],{745656:function(n,r,e){e.r(r),e.d(r,{default:()=>t});var s=e(552676),l=e(740453);let i=e.p+"static/image/3180708d83b89190ce435e4a47720fa5.6d19337e.webp",d=e.p+"static/image/90796c377f15ed850acfec58516440fb.4169bdd2.webp";function c(n){let r=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",br:"br",code:"code",img:"img",ul:"ul",li:"li",blockquote:"blockquote",pre:"pre",h3:"h3",ol:"ol"},(0,l.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"18特殊的二叉树平衡二叉树专题",children:["18.特殊的二叉树——平衡二叉树专题",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#18特殊的二叉树平衡二叉树专题",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"二叉搜索树是二叉树的特例，平衡二叉树则是二叉搜索树的特例。"}),"\n",(0,s.jsxs)(r.h2,{id:"什么是平衡二叉树",children:["什么是平衡二叉树",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是平衡二叉树",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["在上一节的末尾，我们已经通过一道真题和平衡二叉树打过交道。正如题目中所说，平衡二叉树（又称 AVL Tree）指的",(0,s.jsx)(r.strong,{children:"是任意结点"}),"的",(0,s.jsx)(r.strong,{children:"左右子树高度差绝对值都不大于1"}),"的二叉",(0,s.jsx)(r.strong,{children:"搜索树"}),"。"]}),"\n",(0,s.jsxs)(r.h2,{id:"为什么要有平衡二叉树",children:["为什么要有平衡二叉树",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么要有平衡二叉树",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["平衡二叉树的出现，是为了降低二叉搜索树的查找时间复杂度。",(0,s.jsx)(r.br,{}),"\n","大家知道，对于同样一个遍历序列，二叉搜索树的造型可以有很多种。拿 ",(0,s.jsx)(r.code,{children:"[1,2,3,4,5]"}),"这个中序遍历序列来说，基于它可以构造出的二叉搜索树就包括以下两种造型："]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)("img",{src:i,alt:""}),"\n结合平衡二叉树的定义，我们可以看出，第一棵二叉树是平衡二叉树，第二棵二叉树是普通的二叉搜索树。",(0,s.jsx)(r.br,{}),"\n","现在，如果要你基于上一节学过的二叉搜索树查找算法，在图上两棵树上分别找出值为1的结点，问你各需要查找几次？在1号二叉树中，包括根结点在内，只需要查找3次；而在2号二叉树中，包括根结点在内，一共需要查找5次。"]}),"\n",(0,s.jsx)(r.p,{children:"我们发现，在这个例子里，对于同一个遍历序列来说，平衡二叉树比非平衡二叉树（图上的结构可以称为链式二叉树）的查找效率更高。这是为什么呢？"}),"\n",(0,s.jsxs)(r.p,{children:["大家可以仔细想想，为什么科学家们会无中生有，给二叉树的左右子树和根结点之间强加上排序关系作为约束，进而创造出二叉搜索树这种东西呢？难道只是为了装x吗？当然不是啦。",(0,s.jsx)(r.strong,{children:"二叉搜索树的妙处就在于它把“二分”这种思想以数据结构的形式表达了出来"}),"。在一个构造合理的二叉搜索树里，我们可以通过对比当前结点和目标值之间的大小关系，缩小下一步的搜索范围（比如只搜索左子树或者只搜索右子树），进而规避掉不必要的查找步骤，降低搜索过程的时间复杂度。但是如果一个二叉搜索树严重不平衡，比如说上面这棵链式搜索树：",(0,s.jsx)(r.br,{}),"\n",(0,s.jsx)("img",{src:i,alt:""})]}),"\n",(0,s.jsx)(r.p,{children:"每一个结点的右子树都是空的，这样的结构非常不合理，它会带来高达O(N)的时间复杂度。而平衡二叉树由于利用了二分思想，查找操作的时间复杂度仅为 O(logN)。因此，为了保证二叉搜索树能够确实为查找操作带来效率上的提升，我们有必要在构造二叉搜索树的过程中维持其平衡度，这就是平衡二叉树的来由。"}),"\n",(0,s.jsxs)(r.h2,{id:"命题思路解读",children:["命题思路解读",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#命题思路解读",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"平衡二叉树和二叉搜索树一样，都被归类为“特殊”的二叉树。对于这样的数据结构来说，其“特殊”之处也正是其考点所在，因此真题往往稳定地分布在以下两个方向："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"对特性的考察（本节以平衡二叉树的判定为例）"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"对操作的考察（本节以平衡二叉树的构造为例）"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"平衡二叉树的判定",children:["平衡二叉树的判定",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#平衡二叉树的判定",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["题目描述：给定一个二叉树，判断它是否是高度平衡的二叉树。",(0,s.jsx)(r.br,{}),"\n","本题中，一棵高度平衡二叉树定义为：\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"示例 1:\n给定二叉树 [3,9,20,null,null,15,7]"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"    3\n   / \\\n  9  20\n    /  \\\n   15   7\n"})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"返回 true 。"}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"示例 2:\n给定二叉树 [1,2,2,3,3,null,null,4,4]"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n"})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"返回\xa0false 。"}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"思路分析",children:["思路分析",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"来，我们复习一遍平衡二叉树的定义："}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["平衡二叉树",(0,s.jsx)(r.strong,{children:"是任意结点"}),"的",(0,s.jsx)(r.strong,{children:"左右子树高度差绝对值都不大于1"}),"的二叉",(0,s.jsx)(r.strong,{children:"搜索树"}),"。\n抓住其中的三个关键字："]}),"\n"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"任意结点"}),"\n",(0,s.jsx)(r.li,{children:"左右子树高度差绝对值都不大于1"}),"\n",(0,s.jsx)(r.li,{children:"二叉搜索树"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"注意，结合题意，上面3个关键字中的3对这道题来说是不适用的，因此我们不必对二叉搜索树的性质进行校验。现在只看 1 和 2，先给自己一分钟思考一下——你可以提取出什么线索？"}),"\n",(0,s.jsxs)(r.p,{children:["“任意结点”什么意思？每一个结点都需要符合某个条件，也就是说每一个结点在被遍历到的时候都需要重复某个校验流程，对不对？",(0,s.jsx)(r.br,{}),"\n","哎，我刚刚是不是说了什么不得了的动词了？啊，是",(0,s.jsx)(r.strong,{children:"重复"}),"！是tmd的",(0,s.jsx)(r.strong,{children:"重复啊"}),"！！！来，学到了第18节，为了向我证明你没有跳读，请大声喊出下面这两个字："]}),"\n",(0,s.jsx)(r.p,{children:"啊，真让人激动呢，解决这道题的思路竟然已经慢慢浮现出来了，那就是：从下往上递归遍历树中的每一个结点，计算其左右子树的高度并进行对比，只要有一个高度差的绝对值大于1，那么整棵树都会被判为不平衡。"}),"\n",(0,s.jsxs)(r.h3,{id:"编码实现",children:["编码实现",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现",children:"#"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"const isBalanced = function(root) {\n  // 立一个flag，只要有一个高度差绝对值大于1，这个flag就会被置为false\n  let flag = true\n  // 定义递归逻辑\n  function dfs(root) {\n      // 如果是空树，高度记为0；如果flag已经false了，那么就没必要往下走了，直接return\n      if(!root || !flag) {\n          return 0 \n      }\n      // 计算左子树的高度\n      const left = dfs(root.left)  \n      // 计算右子树的高度\n      const right = dfs(root.right)  \n      // 如果左右子树的高度差绝对值大于1，flag就破功了\n      if(Math.abs(left-right) > 1) {\n          flag = false\n          // 后面再发生什么已经不重要了，返回一个不影响回溯计算的值\n          return 0\n      }\n      // 返回当前子树的高度\n      return Math.max(left, right) + 1\n  }\n  \n  // 递归入口\n  dfs(root) \n  // 返回flag的值\n  return flag\n};\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"平衡二叉树的构造",children:["平衡二叉树的构造",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#平衡二叉树的构造",children:"#"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["题目描述：给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。",(0,s.jsx)(r.br,{}),"\n","如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是平衡的。",(0,s.jsx)(r.br,{}),"\n","如果有多种构造方法，请你返回任意一种。"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"示例："}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""}),"\n",(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["输入：root = [1,null,2,null,3,null,4,null,null]",(0,s.jsx)(r.br,{}),"\n","输出：[2,1,3,null,null,null,4]",(0,s.jsx)(r.br,{}),"\n","解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。",(0,s.jsx)(r.br,{}),"\n","\xa0"]}),"\n"]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["提示：",(0,s.jsx)(r.br,{}),"\n","树节点的数目在\xa01\xa0到\xa010^4\xa0之间。\n树节点的值互不相同，且在\xa01\xa0到\xa010^5 之间。"]}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"思路分析-1",children:["思路分析",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-1",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"这道题乍一看有点唬人，可能会直接干懵一部分同学。不过不用慌——题目再新，套路依旧。只要你对核心考点把握得足够扎实，它就难不倒你。"}),"\n",(0,s.jsx)(r.p,{children:"我们来分析一下这道题的核心诉求：要求我们构造一棵平衡的二叉搜索树。先抛开题干中各种前置条件不谈，单看这个输出结果，你会不会有一种似曾相识的感觉呢？没错，在上一节的最后一道真题中，我们也构造过这样的一棵二叉树。"}),"\n",(0,s.jsx)(r.p,{children:"那么这两道题之间会不会有什么微妙的联系呢？答案是会，不然，笔者也不会把它们放得这么近（疯狂暗示）。两道题之间唯一的差别在于输入：在我们已经做过的那道题中，输入参数是一个有序数组；而这道题中，输入参数是一个二叉搜索树。"}),"\n",(0,s.jsx)(r.p,{children:"唔，再想想！上一节那道题里的“有序数组”，和眼前这道题里的“二叉搜索树”之间，会不会有什么妙不可言的关系呢？"}),"\n",(0,s.jsxs)(r.p,{children:["别忘了，",(0,s.jsx)(r.strong,{children:"二叉搜索树的中序遍历序列是有序的"}),"！所谓有序数组，完全可以理解为二叉搜索树的中序遍历序列啊，对不对？现在树都给到咱们手里了，求它的中序遍历序列是不是非常 easy？如果能把中序遍历序列求出来，这道题是不是就跟之前做过那道是一模一样的解法了？"]}),"\n",(0,s.jsx)(r.p,{children:"没错，这道题的解题思路正是："}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"中序遍历求出有序数组"}),"\n",(0,s.jsx)(r.li,{children:"逐个将二分出来的数组子序列“提”起来变成二叉搜索树"}),"\n"]}),"\n",(0,s.jsxs)(r.h3,{id:"编码实现-1",children:["编码实现",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-1",children:"#"})]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:"/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst balanceBST = function(root) {\n    // 初始化中序遍历序列数组\n    const nums = []\n    // 定义中序遍历二叉树，得到有序数组\n    function inorder(root) {\n        if(!root) {\n            return \n        }\n        inorder(root.left)  \n        nums.push(root.val)  \n        inorder(root.right)\n    }\n    \n    // 这坨代码的逻辑和上一节最后一题的代码一模一样\n    function buildAVL(low, high) {\n        // 若 low > high，则越界，说明当前索引范围对应的子树已经构建完毕\n        if(low>high) {\n            return null\n        }\n        // 取数组的中间值作为根结点值\n        const mid = Math.floor(low + (high -low)/2)\n        // 创造当前树的根结点\n        const cur = new TreeNode(nums[mid])  \n        // 构建左子树\n        cur.left = buildAVL(low, mid-1) \n        // 构建右子树\n        cur.right = buildAVL(mid+1, high)  \n        // 返回当前树的根结点 \n        return cur\n    }\n    // 调用中序遍历方法，求出 nums\n    inorder(root)\n    // 基于 nums，构造平衡二叉树\n    return buildAVL(0, nums.length-1)\n};\n"})})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,l.ah)(),n.components);return r?(0,s.jsx)(r,{...n,children:(0,s.jsx)(c,{...n})}):c(n)}let t=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%2F18.%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E2%80%94%E2%80%94%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98.md"]={toc:[{text:"什么是平衡二叉树",id:"什么是平衡二叉树",depth:2},{text:"为什么要有平衡二叉树",id:"为什么要有平衡二叉树",depth:2},{text:"命题思路解读",id:"命题思路解读",depth:2},{text:"平衡二叉树的判定",id:"平衡二叉树的判定",depth:2},{text:"思路分析",id:"思路分析",depth:3},{text:"编码实现",id:"编码实现",depth:3},{text:"平衡二叉树的构造",id:"平衡二叉树的构造",depth:2},{text:"思路分析",id:"思路分析-1",depth:3},{text:"编码实现",id:"编码实现-1",depth:3}],title:"18.特殊的二叉树——平衡二叉树专题",headingTitle:"18.特殊的二叉树——平衡二叉树专题",frontmatter:{}}}}]);