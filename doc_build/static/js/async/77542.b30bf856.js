"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["77542"],{837920:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var t=r(552676),i=r(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",pre:"pre",code:"code",blockquote:"blockquote",h2:"h2"},(0,i.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"19类型编程新范式模板字符串工具类型进阶",children:["19.类型编程新范式：模板字符串工具类型进阶",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#19类型编程新范式模板字符串工具类型进阶",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["上一节，我们了解了模板字符串类型的基础内容，它与数个类型工具的协作，以及将作为本节核心内容的，",(0,t.jsx)(n.strong,{children:"模板字符串类型与模式匹配产生的化学反应"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"我们还是照例先复习一下，如何在模板插槽中使用 infer 关键字："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type ReverseName<Str extends string> =\n  Str extends `${infer First} ${infer Last}` ? `${Capitalize<Last>} ${First}` : Str;\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们在上一节说到，对模板字符串类型中使用模式匹配时，本质上就是在一个字符串字面量类型结构做处理。因此我们可以复刻一个字符串类型的值拥有的大部分方法，从 trim 到 split，从 startsWith 到 endsWith 等等。这些方法就是我们本节要学习的内容，从简单的 trim 、includes，到需要稍微绕一绕的 split、join ，再到较为复杂的 case 转换，我们都将一一实现。"}),"\n",(0,t.jsx)(n.p,{children:"万事开头难并不是绝对的，也可能是你的开头不一定对。模板字符串相关的工具类型既有非常简单的，也有极度复杂烧脑的。为了秉持本小册一路循序渐进的优良作风，我们当然还是从最简单的部分开始。"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["本节代码见：",(0,t.jsx)(n.a,{href:"https://github.com/linbudu599/TypeScript-Tiny-Book/tree/main/packages/16-advanced-template-string-type",target:"_blank",rel:"noopener noreferrer",children:"Advanced Template String Types"})]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"从最简单的模式匹配说起trimincludes-等",children:["从最简单的模式匹配说起：Trim、Includes 等",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从最简单的模式匹配说起trimincludes-等",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"最简单的模式匹配只有一层条件类型语句，也就意味着我们不需要对模式匹配的结果做结构转换等操作。对比到字符串类型变量的方法，也就是 trim（trimLeft、trimRight）、includes、startsWith 与 endsWith。"}),"\n",(0,t.jsxs)(n.p,{children:["我们从比较有代表性的 includes 看起，对应实现一个类型层面的版本：",(0,t.jsx)(n.strong,{children:"判断传入的字符串字面量类型中是否含有某个字符串"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type Include<\n  Str extends string,\n  Search extends string\n> = Str extends `${infer _R1}${Search}${infer _R2}` ? true : false;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在 Include 类型中，我们在 Search 前后声明了两个 infer 插槽，但实际上并不消费 R1 与 R2，而只是判断字符串是否可以被划分为",(0,t.jsx)(n.strong,{children:"要搜索的部分 + 其他部分"}),"。来验证一下实际效果："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type IncludeRes1 = Include<'linbudu', 'lin'>; // true\ntype IncludeRes2 = Include<'linbudu', '_lin'>; // false\ntype IncludeRes3 = Include<'linbudu', ''>; // true\ntype IncludeRes4 = Include<' ', ''>; // true\ntype IncludeRes5 = Include<'', ''>; // false\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在 IncludeRes4 中，我们发现对于空字符串 ",(0,t.jsx)(n.code,{children:"''"})," 需要进行特殊的处理，",(0,t.jsx)(n.code,{children:"''.includes('')"})," 也应当是成立的，就像实际字符串中进行判断一样。我们希望尽可能贴近原本字符串方法的表现，因此我们需要新增额外处理："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type _Include<\n  Str extends string,\n  Search extends string\n> = Str extends `${infer _R1}${Search}${infer _R2}` ? true : false;\n\ntype Include<Str extends string, Search extends string> = Str extends ''\n  ? Search extends ''\n    ? true\n    : false\n  : _Include<Str, Search>;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["当字符串 Str 为空字符串时，我们判断 Search 是否是空字符串来直接决定返回结果，因为很明显 ",(0,t.jsx)(n.code,{children:"''.includes('linbudu')"})," 是不成立的。在 Str 不为空字符串时，我们才会真的进行 Include 的判断。"]}),"\n",(0,t.jsx)(n.p,{children:"在 Str 与 Search 均为空字符串的情况下，我们直接返回 true，否则我们才进行模式匹配。"}),"\n",(0,t.jsx)(n.p,{children:"而提到模板字符串类型中的空字符串，我们会想到 trim 三兄弟：去除起始部分空格的 trimStart，去除结尾部分空格的 trimEnd，以及开头结尾空格一起去的 trim。基于模式匹配的思路我们还是很容易进行对应的类型实现："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// trimStart\ntype TrimLeft<V extends string> = V extends ` ${infer R}` ? R : V;\n\n// trimEnd\ntype TrimRight<V extends string> = V extends `${infer R} ` ? R : V;\n\n// trim\ntype Trim<V extends string> = TrimLeft<TrimRight<V>>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"聪明的你肯定会想到，我们的字符串边缘可能不止有一个空格！而这里的实现只能去掉一个，操作很简单，我们递归一下就好了："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type TrimLeft<Str extends string> = Str extends ` ${infer R}` ? TrimLeft<R> : Str;\n\ntype TrimRight<Str extends string> = Str extends `${infer R} ` ? TrimRight<R> : Str;\n\ntype Trim<Str extends string> = TrimLeft<TrimRight<Str>>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样，在字符串的两边不包含空格时，递归就会停止，从而返回一致“干净”的字符串。"}),"\n",(0,t.jsx)(n.p,{children:"而类型版本的 StartsWith 与 EndsWith 两个工具类型，和 Include 的实现非常接近，我们直接看其中 StartsWith 的最终实现与验证："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type _StartsWith<\n  Str extends string,\n  Search extends string\n> = Str extends `${Search}${infer _R}` ? true : false;\n\ntype StartsWith<Str extends string, Search extends string> = Str extends ''\n  ? Search extends ''\n    ? true\n    : _StartsWith<Str, Search>\n  : _StartsWith<Str, Search>;\n\ntype StartsWithRes1 = StartsWith<'linbudu', 'lin'>; // true\ntype StartsWithRes2 = StartsWith<'linbudu', ''>; // true\ntype StartsWithRes3 = StartsWith<'linbudu', ' '>; // false\ntype StartsWithRes4 = StartsWith<'', ''>; // true\ntype StartsWithRes5 = StartsWith<' ', ''>; // true\n"})}),"\n",(0,t.jsx)(n.p,{children:"和 Include 基本一致，只是我们需要确保 Search 在字符串的开头部分。"}),"\n",(0,t.jsx)(n.p,{children:"在这一部分，我们了解了字符串类型中 Include、Trim 系列、StartsWith 与 EndsWith 这几个较简单的工具类型实现。现在热身完毕，是时候开始更复杂的部分了，比如 Replace 怎么样？"}),"\n",(0,t.jsxs)(n.h2,{id:"结构转换replacesplit-与-join",children:["结构转换：Replace、Split 与 Join",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结构转换replacesplit-与-join",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["看起来 Replace 好像是挺复杂的实现？但仔细想想它和 Include 其实没有啥区别，Include 判断是",(0,t.jsx)(n.strong,{children:"否能将字符串字面量划分为目标部分与其他部分"}),"，那 Replace 不是只需要",(0,t.jsx)(n.strong,{children:"将目标部分替换为新的部分，按照原本的结构组合好"}),"就行了吗？就像我们在对象层面的集合类型中学习的那样，",(0,t.jsx)(n.strong,{children:"一切复杂的工具类型最终都可以转换为数个简单工具类型的组合"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"在 Include 实现中，我们有两个纯做结构判断的 infer 插槽，现在它们也能真正的派上用场了："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type Replace<\n  Str extends string,\n  Search extends string,\n  Replacement extends string\n> = Str extends `${infer Head}${Search}${infer Tail}`\n  ? `${Head}${Replacement}${Tail}`\n  : Str;\n"})}),"\n",(0,t.jsx)(n.p,{children:"既然这两个插槽派上了用场，我们就需要给它们正式点的名字。Head 与 Tail 这两个名字我们后面还会常常见到，它们就表示开头与结尾的匹配部分。"}),"\n",(0,t.jsx)(n.p,{children:"这里我们其实是先判断字符串字面量中是否包含 Search 部分（就像 Include 那样），在包含也就是结构符合时，将匹配得到的 Head 与 Tail 部分夹上 Replacement，我们就实现了一个类型版本的 Replace："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// \"林不渡也不是不能渡\"\ntype ReplaceRes1 = Replace<'林不渡', '不', '不渡也不是不能'>;\n// 不发生替换，仍然是\"林不渡\"\ntype ReplaceRes2 = Replace<'林不渡', '？', '？？'>; //\n"})}),"\n",(0,t.jsx)(n.p,{children:"然而，你应该遇到过需要全量替换的场景，也就是 ECMAScript 2021 的 replaceAll 方法。那我们能否在类型层面也实现一个 replaceAll？当然没问题，只需要再请出我们的老朋友——递归："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type ReplaceAll<\n  Str extends string,\n  Search extends string,\n  Replacement extends string\n> = Str extends `${infer Head}${Search}${infer Tail}`\n  ? ReplaceAll<`${Head}${Replacement}${Tail}`, Search, Replacement>\n  : Str;\n  \n// \"mmm.linbudu.top\"\ntype ReplaceAllRes1 = ReplaceAll<'www.linbudu.top', 'w', 'm'>;\n// \"www-linbudu-top\"\ntype ReplaceAllRes2 = ReplaceAll<'www.linbudu.top', '.', '-'>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"如果你更喜欢将这两个类型合并在一起，再通过选项来控制是否进行全量替换，其实也很简单，在结构工具类型中我们就试过引入类型层面的选项控制，这里也是类似："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type Replace<\n  Input extends string,\n  Search extends string,\n  Replacement extends string,\n  ShouldReplaceAll extends boolean = false\n> = Input extends `${infer Head}${Search}${infer Tail}`\n  ? ShouldReplaceAll extends true\n    ? Replace<\n        `${Head}${Replacement}${Tail}`,\n        Search,\n        Replacement,\n        ShouldReplaceAll\n      >\n    : `${Head}${Replacement}${Tail}`\n  : Input;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["除了 replace 与 replaceAll，在字符串类型值中还有一个常用的方法：split ，它会将字符串按照确定的分隔符拆分成一个数组，比如从 ",(0,t.jsx)(n.code,{children:"'lin-bu-du'"})," 按照 ",(0,t.jsx)(n.code,{children:"'-'"})," 拆分为 ",(0,t.jsx)(n.code,{children:"['lin', 'bu', 'du']"}),"。在类型层面，我们也可以实现 Split，毕竟“分隔符”这个词就在强烈暗示你，它",(0,t.jsx)(n.strong,{children:"一定是符合某种结构的字面量类型"}),"。比如最简单的，假设我们所有的字符串都是 ",(0,t.jsx)(n.code,{children:'"A-B-C"'})," 这个结构，那就可以这么拆分："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export type Split<Str extends string> =\n  Str extends `${infer Head}-${infer Body}-${infer Tail}`\n    ? [Head, Body, Tail]\n    : [];\n\ntype SplitRes1 = Split<\'lin-bu-du\'>; // ["lin", "bu", "du"]\n'})}),"\n",(0,t.jsx)(n.p,{children:"当然，真实情况肯定不会这么简单，分隔符与字符串长度都是不确定的。但有着模式匹配与递归，没什么能难得倒我们，管你多长的字符串，我直接一个递归："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export type Split<\n  Str extends string,\n  Delimiter extends string\n> = Str extends `${infer Head}${Delimiter}${infer Tail}`\n  ? [Head, ...Split<Tail, Delimiter>]\n  : Str extends Delimiter\n  ? []\n  : [Str];\n\n// ["linbudu", "599", "fe"]\ntype SplitRes1 = Split<\'linbudu,599,fe\', \',\'>;\n\n// ["linbudu", "599", "fe"]\ntype SplitRes2 = Split<\'linbudu 599 fe\', \' \'>;\n\n// ["l", "i", "n", "b", "u", "d", "u"]\ntype SplitRes3 = Split<\'linbudu\', \'\'>;\n'})}),"\n",(0,t.jsx)(n.p,{children:"这里有两种情况需要注意。第一种，存在多处分割时，Split 类型进行到最后一次，即无法再分割时，需要直接将最后一部分给返回。第二种，对于空字符串作为分隔符，其表现为将字符串字面量按字母进行拆分（SplitRes3），这同样与 Split 方法的实际表现一致。"}),"\n",(0,t.jsxs)(n.p,{children:["在实际情况中，我们的字符串可能包含了多种可能的分隔符，即这里的 Delimiter 可以是一个联合类型 ",(0,t.jsx)(n.code,{children:'"_" | "-" | " "'})," 。在这种情况下，模板字符串中的模式匹配也能够生效，它会使用这里的多个分隔符依次进行判断，并在判断到其中一种就立刻成立："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type Delimiters = '-' | '_' | ' ';\n\n// [\"lin\", \"bu\", \"du\"]\ntype SplitRes4 = Split<'lin_bu_du', Delimiters>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"但需要注意的是，我们并不能在一个字符串中混用多种分隔符，在这种情况下由于联合类型在插槽中的排列组合特性，我们会得到一个诡异的结果："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// ["lin" | "lin_bu", "du"] | ["lin" | "lin_bu", "bu", "du"]\ntype SplitRes5 = Split<\'lin_bu-du\', Delimiters>;\n'})}),"\n",(0,t.jsxs)(n.p,{children:["实际上，每次只能依据一种分隔符进行拆分才是符合预期的。在正常的变量命名中，通常只会使用一种分隔方式，如 ",(0,t.jsx)(n.code,{children:"module-my_super_module-beta"})," 这个命名中，实际上只有 ",(0,t.jsx)(n.code,{children:"-"})," 是分隔符。确实使用了多种具有实际意义的分隔符时，我们应该进行多次拆分，如  CSS 的 BEM 命名方式（",(0,t.jsx)(n.code,{children:"Block__Element--Modifier"}),"）下，我们经常会这么写类名：",(0,t.jsx)(n.code,{children:"footer__button--danger"}),"。此时，我们就应当先按照 ",(0,t.jsx)(n.code,{children:"__"})," 拆出 Block，再按照 ",(0,t.jsx)(n.code,{children:"--"})," 拆出 Modifier。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"另外，基于 Split 类型我们还可以获取字符串长度："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type StrLength<T extends string> = Split<Trim<T>, ''>['length'];\n\ntype StrLengthRes1 = StrLength<'linbudu'>; // 7\ntype StrLengthRes2 = StrLength<'lin budu'>; // 8\ntype StrLengthRes3 = StrLength<''>; // 0\ntype StrLengthRes4 = StrLength<' '>; // 0\n"})}),"\n",(0,t.jsx)(n.p,{children:"这是因为即使是在类型层面，元组类型的长度也会是一个有实际意义的值。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"我们上面介绍的许多方法之间其实存在关联，比如 TrimLeft 与 TrimEnd、StartsWith 与 EndsWith 是作用位置相反，Replace 是 Include 的进化版本，而 Split 也有这么一位伙伴：与它作用相反的 Join 。"}),"\n",(0,t.jsxs)(n.p,{children:["Split 方法是",(0,t.jsx)(n.strong,{children:"将字符串按分隔符拆分成一个数组"}),"，而 Join 方法则是",(0,t.jsx)(n.strong,{children:"将一个数组中的所有字符串按照分隔符组装成一个字符串"}),"。我们只需要通过递归依次取出每一个字符串单元，使用模板插槽组装即可："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type Join<\n  List extends Array<string | number>,\n  Delimiter extends string\n> = List extends [string | number, ...infer Rest]\n  ? // @ts-expect-error\n    `${List[0]}${Delimiter}${Join<Rest, Delimiter>}`\n  : string;\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"这里的 Rest 类型无法被正确地推导，因此使用了 // @ts-expect-error 来忽略错误。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"看起来似乎没啥问题，我们来试一下？"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// `lin-bu-du-${string}`\ntype JoinRes1 = Join<['lin', 'bu', 'du'], '-'>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"啊哦，很明显不对，我们分析一下原因。在递归进行到最后一次时，我们面对的条件类型大致是这样的："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type JoinTmp = [] extends [string | number, ...infer Rest]\n  ? // @ts-expect-error\n    `lin-bu-du-${Join<Rest, Delimiter>}`\n  : string;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这个条件很明显不会成立，因此它返回了 string 类型，而这个 string 类型我们的本义是用来兜底：",(0,t.jsx)(n.strong,{children:"如果 Join 无法拼接一个列表，那至少要返回一个 string 类型"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"要解决这种情况，我们只需要额外处理一下空数组的情况："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type Join<\n  List extends Array<string | number>,\n  Delimiter extends string\n> = List extends []\n  ? ''\n  : List extends [string | number, ...infer Rest]\n  ? // @ts-expect-error\n    `${List[0]}${Delimiter}${Join<Rest, Delimiter>}`\n  : string;\n"})}),"\n",(0,t.jsx)(n.p,{children:"但最终结果还是不太对："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// `lin-bu-du-`\ntype JoinRes2 = Join<['lin', 'bu', 'du'], '-'>;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["实际上，在进行到最后一项数组成员时（即 ",(0,t.jsx)(n.code,{children:"['du']"}),"），我们的递归过程就应当被提前阻止。这里产生一个多余的 ",(0,t.jsx)(n.code,{children:"'-'"})," 的原因，其实就是让这仅有一项的数组还进行了一次分隔符拼接。"]}),"\n",(0,t.jsx)(n.p,{children:"因此我们也需要处理只剩下最后一项的情况："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"\nexport type Join<\n  List extends Array<string | number>,\n  Delimiter extends string\n> = List extends []\n  ? ''\n  : List extends [string | number]\n  ? `${List[0]}`\n  : List extends [string | number, ...infer Rest]\n  ? // @ts-expect-error\n    `${List[0]}${Delimiter}${Join<Rest, Delimiter>}`\n  : string;\n\n// \"lin-bu-du\"\ntype JoinRes3 = Join<['lin', 'bu', 'du'], '-'>;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["看起来简单的 Join 类型，我们却连续实现了三次才完成。Split 类型其实也是，如果不提前考虑到各种情况，很难注意到在最后一次递归需要的特殊处理。这也是类型编程中常见的一个情景，",(0,t.jsx)(n.strong,{children:"一个工具类型有时需要多次改进、多种边界情况处理，才能称为“可用”，尤其是在递归的情况下"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"在模板字符串进阶类型的最后一部分，我们要来实现字符串的 Case 处理。这也是模板字符串类型中相对最为复杂的一部分，我们基本上是在对上面的模式匹配、递归、结构转换等概念做一次全面的结合应用。"}),"\n",(0,t.jsxs)(n.h2,{id:"最后一步case-转换",children:["最后一步：Case 转换",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后一步case-转换",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在上一节，我们已经了解了 TypeScript 内置的 Lowercase、Capitalize 等工具类型，知道它们是在内部实现的层面支持了字符串值的变换。其实基于这些工具类型，我们完全可以实现几乎所有常见的 Case，如 Camel Case（",(0,t.jsx)(n.code,{children:"'linBuDu'"}),"）、Snake Case（",(0,t.jsx)(n.code,{children:"'lin_bu_du'"}),"）、Delimiter Case（按照指定分隔符划分，如 ",(0,t.jsx)(n.code,{children:"'lin~bu~du'"})," ",(0,t.jsx)(n.code,{children:"'lin>bu>du'"})," 等，也包括 Snake Case）。"]}),"\n",(0,t.jsxs)(n.p,{children:["首先需要明确的一点是，对于字符串，无论是值还是字面量类型，我们并没有办法去智能拆分，比如 mynameislinbudu，在不注入判断逻辑的情况下，计算机并不知道如何进行分词。如果是已经具有了一种 case 的字符串，比如 my_name_is_linbudu，此时我们要拆分就容易多了。拆分其实就是 Case 转换的基础，我们本节介绍的 Case 转换一定是建立在 ",(0,t.jsx)(n.strong,{children:"传入字符串已经拥有了一种 case"})," 的情况。"]}),"\n",(0,t.jsx)(n.p,{children:"我们先以 CamelCase 为最终产物，了解如何从 SnakeCase 转换到 CamelCase，也就是下划线转小驼峰。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// 如何实现？\nexpectType<SnakeCase2CamelCase<'foo_bar_baz'>>('fooBarBaz');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["看这清晰明确的结构，不用模式匹配简直暴殄天物，我们需要做的就是按照 ",(0,t.jsx)(n.code,{children:"_"})," 进行结构匹配，然后将除了首个字符串单元（在这里即是 ",(0,t.jsx)(n.code,{children:"foo"})," ）以外的后续部分都转为首字母大写。至于怎么转，当然是贴心内置的 Capitalize 了。"]}),"\n",(0,t.jsx)(n.p,{children:"我们直接来看实现，由于这部分会有大量的结果验证，我们再次请出 expectType："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type SnakeCase2CamelCase<S extends string> =\n  S extends `${infer Head}${'_'}${infer Rest}`\n    ? `${Head}${SnakeCase2CamelCase<Capitalize<Rest>>}`\n    : S;\n\nexpectType<SnakeCase2CamelCase<'foo_bar_baz'>>('fooBarBaz');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["解决了 SnakeCase ，稍微举一反三，你会发现 KebabCase（中划线，如 ",(0,t.jsx)(n.code,{children:'"lin-bu-du"'}),"）其实也解决了，不就是换个分隔符的事？"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type KebabCase2CamelCase<S extends string> =\n  S extends `${infer Head}${'-'}${infer Rest}`\n    ? `${Head}${KebabCase2CamelCase<Capitalize<Rest>>}`\n    : S;\n\nexpectType<KebabCase2CamelCase<'foo-bar-baz'>>('fooBarBaz');\n"})}),"\n",(0,t.jsx)(n.p,{children:"SnakeCase 和 KebabCase 的唯一区别就是模式匹配的分隔符，身为封装工程师，我们肯定要把分隔符的能力进行抽象，支持任意的分隔符："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type DelimiterCase2CamelCase<\n  S extends string,\n  Delimiter extends string\n> = S extends `${infer Head}${Delimiter}${infer Rest}`\n  ? `${Head}${DelimiterCase2CamelCase<Capitalize<Rest>, Delimiter>}`\n  : S;\n"})}),"\n",(0,t.jsx)(n.p,{children:"来验证一下效果："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"expectType<DelimiterCase2CamelCase<'foo-bar-baz', '-'>>('fooBarBaz');\nexpectType<DelimiterCase2CamelCase<'foo~bar~baz', '~'>>('fooBarBaz');\nexpectType<DelimiterCase2CamelCase<'foo bar baz', ' '>>('fooBarBaz');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["到这里，我们支持了一个能够通过传入分隔符解决任意 Delimiter Case 转 Camel Case，看起来可以功成身退了。但这里还存在非常大的优化空间，比如我们还能让它自动处理分隔符。通常的变量命名只会使用 ",(0,t.jsx)(n.code,{children:"_"})," 和 ",(0,t.jsx)(n.code,{children:"-"})," 作为分隔符，加上字面量中可能存在的空格，也就是我们希望自动处理 ",(0,t.jsx)(n.code,{children:'"_" | "-" | " "'})," 这三个分隔符。"]}),"\n",(0,t.jsx)(n.p,{children:"你可能会想当然地写出这样的代码："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type WordDelimiter = '-' | '_' | ' ';\n\ntype DelimiterCase2CamelCaseAuto<S extends string> =\n  S extends `${infer Head}${infer Delimiter}${infer Rest}`\n    ? Delimiter extends WordDelimiter\n      ? `${Head}${DelimiterCase2CamelCaseAuto<Capitalize<Rest>>}`\n      : S\n    : S;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果你真觉得这能够工作，我的建议是再回到上一部分重新来过。对于这种连续的 infer 插槽，其匹配策略是尽可能为前面的每个插槽匹配一个字符，然后将所有剩下的部分都交给最后一个插槽。如 ",(0,t.jsx)(n.code,{children:'"lin-bu-du"'})," 在上面会匹配为 ",(0,t.jsx)(n.code,{children:"l"})," ",(0,t.jsx)(n.code,{children:"i"})," ",(0,t.jsx)(n.code,{children:"n-budu"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["因此要实现一个自动分割的版本，我们还需要一些额外的工作，但思路仍然是一致的：",(0,t.jsx)(n.strong,{children:"按照分隔符拆分"}),"，对除首个字符串以外的字符单元进行首字母大写处理以及组装。在 Delimiter Case 中，我们通过可确定的分隔符直接使用递归模式匹配拆分，如果分隔符并不确定的情况下我们应该怎么做？"]}),"\n",(0,t.jsx)(n.p,{children:"我们在上面讲到的 Split 类型，其实就能很好地满足我们的需要："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type Delimiters = '-' | '_' | ' ';\n\n// [\"lin\", \"bu\", \"du\"]\ntype SplitRes4 = Split<'lin_bu_du', Delimiters>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"也就是说，我们可以使用 Split 将字符串拆分成数组，然后在数组中去处理第一项以外的其他成员："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type CamelCase<K extends string> = CamelCaseStringArray<\n  Split<K, Delimiters>\n>;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["而 CamelCaseStringArray 这个类型，我们希望它能够将 ",(0,t.jsx)(n.code,{children:"['lin', 'bu', 'du']"})," 转化为 ",(0,t.jsx)(n.code,{children:"['lin', 'Bu', 'Du']"}),"。也就是说这个数组可以分为两个部分，无需处理的第一项和全部首字母大写的其余项："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type CamelCaseStringArray<Words extends string[]> = Words extends [\n  `${infer First}`,\n  ...infer Rest\n]\n  ? `${First}${CapitalizeStringArray<Rest>}`\n  : never;\n"})}),"\n",(0,t.jsx)(n.p,{children:"在数组中进行模式匹配时，我们为何也使用了看似多余的 infer 插槽？这是因为我们的 First 会直接传入给插槽，通过 infer 插槽匹配，能够确保最终 infer First 得到的 infer 值一定会是字符串类型。"}),"\n",(0,t.jsxs)(n.p,{children:["由于这里的 First 和 Rest 被视为两种不同的结构，因此我们需要再声明一个 CapitalizeStringArray 类型，它的作用就是将",(0,t.jsx)(n.strong,{children:"递归地将数组中所有的字符串单元转化为首字母大写形式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type CapitalizeStringArray<Words extends any[]> = Words extends [\n  `${infer First}`,\n  ...infer Rest\n]\n  ? `${Capitalize<First>}${CapitalizeStringArray<Rest>}`\n  : '';\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样我们就得到了一个初具雏形的 Camel Case 智能版："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"type Delimiters = '-' | '_' | ' ';\n\ntype CapitalizeStringArray<Words extends any[]> = Words extends [\n  `${infer First}`,\n  ...infer Rest\n]\n  ? `${Capitalize<First>}${CapitalizeStringArray<Rest>}`\n  : '';\n\ntype CamelCaseStringArray<Words extends string[]> = Words extends [\n  `${infer First}`,\n  ...infer Rest\n]\n  ? `${First}${CapitalizeStringArray<Rest>}`\n  : never;\n\nexport type Split<\n  S extends string,\n  Delimiter extends string\n> = S extends `${infer Head}${Delimiter}${infer Tail}`\n  ? [Head, ...Split<Tail, Delimiter>]\n  : S extends Delimiter\n  ? []\n  : [S];\n\ntype CamelCase<K extends string> = CamelCaseStringArray<\n  Split<K, Delimiters>\n>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"来验证一下效果："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"expectType<CamelCase<'foo-bar-baz'>>('fooBarBaz');\nexpectType<CamelCase<'foo bar baz'>>('fooBarBaz');\nexpectType<CamelCase<'foo_bar_baz'>>('fooBarBaz');\n"})}),"\n",(0,t.jsx)(n.p,{children:"CamelCase 这个类型确实有一定复杂度，但它本质上仍然是数个基础工具类型与概念的组合，包括模板字符串类型、infer 插槽与模式匹配结合、Rest infer 等等。同时，我们并没有想一口气把它实现出来，而是先整理了思路（拆分、转换、重组），确定了能够依赖的基础工具类型（Split），才一步步实现了它。"}),"\n",(0,t.jsxs)(n.p,{children:["这里的 Camel Case 其实还有一些需要改进的地方，比如首字母大写的 ",(0,t.jsx)(n.code,{children:"Foo-bar-baz"})," 和全大写的 ",(0,t.jsx)(n.code,{children:"'FOO-BAR-BAZ'"})," ，也需要转化为小驼峰形式的 ",(0,t.jsx)(n.code,{children:"fooBarBaz"})," 。"]}),"\n",(0,t.jsx)(n.p,{children:"这里我放上 Type Fest 中 Camel Case 的最终实现，基本上处理了绝大部分的边界情况："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type PlainObjectType = Record<string, any>;\n\nexport type WordSeparators = '-' | '_' | ' ';\n\nexport type Split<\n  S extends string,\n  Delimiter extends string\n> = S extends `${infer Head}${Delimiter}${infer Tail}`\n  ? [Head, ...Split<Tail, Delimiter>]\n  : S extends Delimiter\n  ? []\n  : [S];\n\ntype CapitalizeStringArray<Words extends readonly any[], Prev> = Words extends [\n  `${infer First}`,\n  ...infer Rest\n]\n  ? First extends undefined\n    ? ''\n    : First extends ''\n    ? CapitalizeStringArray<Rest, Prev>\n    : `${Prev extends '' ? First : Capitalize<First>}${CapitalizeStringArray<\n        Rest,\n        First\n      >}`\n  : '';\n\ntype CamelCaseStringArray<Words extends readonly string[]> = Words extends [\n  `${infer First}`,\n  ...infer Rest\n]\n  ? Uncapitalize<`${First}${CapitalizeStringArray<Rest, First>}`>\n  : never;\n\nexport type CamelCase<K extends string> = CamelCaseStringArray<\n  Split<K extends Uppercase<K> ? Lowercase<K> : K, WordSeparators>\n>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"另外，虽然 Camel Case 只是对一维字符串字面量进行的转换，但由于我们上一节讲到的重映射能力，它也可以被应用到对象类型层面："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type CamelCasedProperties<T extends PlainObjectType> = {\n  [K in keyof T as CamelCase<string & K>]: T[K] extends object\n    ? CamelCasedProperties<T[K]>\n    : T[K];\n};\n\nexpectType<\n  CamelCasedProperties<{ foo_bar: string; foo_baz: { nested_foo: string } }>\n>({\n  fooBar: '',\n  fooBaz: {\n    nestedFoo: '',\n  },\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"基于此，我们就完成了模板字符串工具类型的最后一步，也是其集大成者 Case 转换。除了 Camel Case 以外，其实你也可以很容易对应着实现智能版的 Delimiter Case、Snake Case 等等，只要按着思路划分、基础工具类型确定、边界情况补全这一系列路径走下来，看似繁琐的模板字符串工具类型也并不可怕。"}),"\n",(0,t.jsxs)(n.h2,{id:"总结与预告",children:["总结与预告",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结与预告",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这一节，我们完成了模板字符串类型的进阶学习，仿照着 JavaScript 中字符串变量的方法实现了 Trim、Include、Replace、Split 以及 Case 转换等工具类型。这些类型虽然在实际项目开发中使用场景有限，但却带来了访问性修饰与结构处理等类型编程范式以外的新类型编程体系。同时，我们借着模板字符串类型的灵活性，再次复习了模式匹配的应用场景，让你对它的应用有了更深刻的了解。"}),"\n",(0,t.jsx)(n.p,{children:"到这里，我们的类型能力核心篇章就告一段落了。在这数十节的内容里，我们从内置类型基础开始，一步步跨过了内置类型工具、类型系统、类型编程与模板字符串类型四座大山，现在你可以自信地说自己已经把 TypeScript 的类型能力掌握个八九不离十了。"}),"\n",(0,t.jsx)(n.p,{children:"接下来，我们就要迈入到实战环节了，包括类型声明、React 与 ESLint 中的工程实践、装饰器、TSConfig 配置、Node API 开发等等，都是我们将攻克的对象。但是，类型能力和工程实战毕竟是两个基本独立的部分，因此我更建议你在此稍微驻足，做一个阶段性总结，看看是否已经把类型能力概念都掌握了？"}),"\n",(0,t.jsx)(n.p,{children:"相比之下，实战环节的难度其实要更低，我们更多是在介绍语法、配置项、实际使用，所以你完全可以好好缓解一下被类型折磨的大脑。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(s,{...e})}):s(e)}let a=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["TypeScript%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F19.%E7%B1%BB%E5%9E%8B%E7%BC%96%E7%A8%8B%E6%96%B0%E8%8C%83%E5%BC%8F%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6.md"]={toc:[{text:"从最简单的模式匹配说起：Trim、Includes 等",id:"从最简单的模式匹配说起trimincludes-等",depth:2},{text:"结构转换：Replace、Split 与 Join",id:"结构转换replacesplit-与-join",depth:2},{text:"最后一步：Case 转换",id:"最后一步case-转换",depth:2},{text:"总结与预告",id:"总结与预告",depth:2}],title:"19.类型编程新范式：模板字符串工具类型进阶",headingTitle:"19.类型编程新范式：模板字符串工具类型进阶",frontmatter:{}}}}]);