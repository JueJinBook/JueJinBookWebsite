"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["50050"],{323523:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var t=r(552676),l=r(740453);let s=r.p+"static/image/dfad7a785180d8d62bb6a6979190f0b5.287d0e6a.webp",c=r.p+"static/image/f702582614d373b525b1f211b1a4b5b9.cabc580f.webp",d=r.p+"static/image/c066b7e06c7fbf8ff82dc9544f070e2e.a682e884.webp",i=r.p+"static/image/b6ba6a0a0f9b2142a6e47d4f466f97f3.56be8e5c.webp",a=r.p+"static/image/569a71ef91ca0274fc6ff47809892de5.c635e2c0.webp",h=r.p+"static/image/8ad3546e7aeb1c671e475698a1e425dd.3b191022.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",ul:"ul",li:"li",pre:"pre",img:"img",h3:"h3",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h4:"h4",ol:"ol"},(0,l.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"2基础篇-认识-jsx",children:["2.基础篇-认识 jsx",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2基础篇-认识-jsx",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"一-我们写的-jsx-终将变成什么",children:["一 我们写的 JSX 终将变成什么",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-我们写的-jsx-终将变成什么",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["万物始于 ",(0,t.jsx)(n.code,{children:"jsx"}),"，想要深入学习 react ，就应该从 jsx 入手。弄清楚 jsx ，方便学习掌握以下内容："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"了解常用的元素会被 React 处理成什么，有利于后续理解 react fiber 类型；"}),"\n",(0,t.jsx)(n.li,{children:"理解 jsx 的编译过程，方便操纵 children、控制 React 渲染，有利于便捷使用 React 插槽组件。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"我写了一段 react JSX 代码，接下来，我们一步步看看它最后会变成什么样子。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const toLearn = [ 'react' , 'vue' , 'webpack' , 'nodejs'  ]\n\nconst TextComponent = ()=> <div> hello , i am function component </div> \n\nclass Index extends React.Component{\n    status = false /* 状态 */\n    renderFoot=()=> <div> i am foot</div>\n    render(){\n        /* 以下都是常用的jsx元素节 */\n        return <div style={{ marginTop:'100px' }}   >\n            { /* element 元素类型 */ }\n            <div>hello,world</div>\n            { /* fragment 类型 */ }\n            <React.Fragment>\n                <div> \uD83D\uDC7D\uD83D\uDC7D </div>\n            </React.Fragment>\n            { /* text 文本类型 */ }\n            my name is alien \n            { /* 数组节点类型 */ }\n            { toLearn.map(item=> <div key={item} >let us learn { item } </div> ) }\n            { /* 组件类型 */ }\n            <TextComponent/>\n            { /* 三元运算 */  }\n            { this.status ? <TextComponent /> : <div>三元运算</div> }\n            { /* 函数执行 */ } \n            { this.renderFoot() }\n            <button onClick={ ()=> console.log( this.render() ) } >打印render后的内容</button>\n        </div>\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"jsx_02.jpg"})}),"\n",(0,t.jsxs)(n.h3,{id:"1-babel-处理后的样子",children:["1 babel 处理后的样子",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-babel-处理后的样子",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"首先，看一下上述例子中的 jsx 模版会被babel编译成什么？"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:"jsx_03.jpg"})}),"\n",(0,t.jsx)(n.p,{children:"和如上看到的一样，我写的 JSX 元素节点会被编译成 React Element 形式。那么，我们首先来看一下 React.createElement 的用法。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"React.createElement(\n  type,\n  [props],\n  [...children]\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"createElement"})," 参数："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"第一个参数：如果是组件类型，会传入组件对应的类或函数；如果是 dom 元素类型，传入 div 或者 span 之类的字符串。"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"第二个参数：一个对象，在 dom 类型中为标签属性，在组件类型中为 props 。"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"其他参数：依次为 children，根据顺序排列。"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"举个例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"<div>\n   <TextComponent />\n   <div>hello,world</div>\n   let us learn React!\n</div>\n"})}),"\n",(0,t.jsx)(n.p,{children:"上面的代码会被 babel 先编译成："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:' React.createElement("div", null,\n        React.createElement(TextComponent, null),\n        React.createElement("div", null, "hello,world"),\n        "let us learn React!"\n    )\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"｜--------问与答--------｜"})}),"\n",(0,t.jsxs)(n.p,{children:["问：老版本的 React 中，为什么写 jsx 的文件要默认引入 React?","\n如下"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import React from 'react'\nfunction Index(){\n    return <div>hello,world</div>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"答：因为 jsx 在被 babel 编译后，写的 jsx 会变成上述 React.createElement 形式，所以需要引入 React，防止找不到 React 引起报错。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"｜---------end---------｜"})}),"\n",(0,t.jsxs)(n.h3,{id:"2-createelement-处理后的样子",children:["2 createElement 处理后的样子",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-createelement-处理后的样子",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"然后点击按钮，看一下写的 demo 会被 React.createElement 变成什么:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"jsx_01.jpg"})}),"\n",(0,t.jsx)(n.p,{children:"从上面写的 jsx 结构来看，外层的 div 被 react.createElement 转换成 react element 对象，div 里面的 8 个元素分别转换成 children 子元素列表。下面就是 jsx 的转换规则，请一定要记住，以便后续能更流畅地使用 jsx 语法。"}),"\n",(0,t.jsxs)(n.table,{children:["\n",(0,t.jsxs)(n.thead,{children:["\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsxs)(n.th,{children:[(0,t.jsx)(n.code,{children:"jsx"}),"元素类型"]}),"\n",(0,t.jsxs)(n.th,{children:[(0,t.jsx)(n.code,{children:"react.createElement"})," 转换后"]}),"\n",(0,t.jsxs)(n.th,{children:[(0,t.jsx)(n.code,{children:"type"})," 属性"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.tbody,{children:["\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"element"}),"元素类型"]}),"\n",(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"react element"}),"类型"]}),"\n",(0,t.jsxs)(n.td,{children:["标签字符串，例如 ",(0,t.jsx)(n.code,{children:"div"})]}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"fragment"}),"类型"]}),"\n",(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"react element"}),"类型"]}),"\n",(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"symbol"}),"  ",(0,t.jsx)(n.code,{children:"react.fragment"}),"类型"]}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"文本类型"}),"\n",(0,t.jsx)(n.td,{children:"直接字符串"}),"\n",(0,t.jsx)(n.td,{children:"无"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"数组类型"}),"\n",(0,t.jsxs)(n.td,{children:["返回数组结构，里面元素被",(0,t.jsx)(n.code,{children:"react.createElement"}),"转换"]}),"\n",(0,t.jsx)(n.td,{children:"无"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"组件类型"}),"\n",(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"react element"}),"类型"]}),"\n",(0,t.jsx)(n.td,{children:"组件类或者组件函数本身"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"三元运算 / 表达式"}),"\n",(0,t.jsx)(n.td,{children:"先执行三元运算，然后按照上述规则处理"}),"\n",(0,t.jsx)(n.td,{children:"看三元运算返回结果"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"函数执行"}),"\n",(0,t.jsx)(n.td,{children:"先执行函数，然后按照上述规则处理"}),"\n",(0,t.jsx)(n.td,{children:"看函数执行返回结果"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"3-react-底层调和处理后终将变成什么",children:["3 React 底层调和处理后，终将变成什么？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-react-底层调和处理后终将变成什么",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"最终，在调和阶段，上述 React element 对象的每一个子节点都会形成一个与之对应的 fiber 对象，然后通过 sibling、return、child 将每一个 fiber 对象联系起来。"}),"\n",(0,t.jsx)(n.p,{children:"所以，我们有必要先来看一下 React 常用的 fiber 类型，以及 element 对象和 fiber 类型的对应关系。"}),"\n",(0,t.jsxs)(n.h4,{id:"不同种类的-fiber-tag",children:["不同种类的 fiber Tag",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#不同种类的-fiber-tag",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"React 针对不同 React element 对象会产生不同 tag (种类) 的fiber 对象。首先，来看一下 tag 与 element 的对应关系："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const FunctionComponent = 0;       // 函数组件\nexport const ClassComponent = 1;          // 类组件\nexport const IndeterminateComponent = 2;  // 初始化的时候不知道是函数组件还是类组件 \nexport const HostRoot = 3;                // Root Fiber 可以理解为根元素 ， 通过reactDom.render()产生的根元素\nexport const HostPortal = 4;              // 对应  ReactDOM.createPortal 产生的 Portal \nexport const HostComponent = 5;           // dom 元素 比如 <div>\nexport const HostText = 6;                // 文本节点\nexport const Fragment = 7;                // 对应 <React.Fragment> \nexport const Mode = 8;                    // 对应 <React.StrictMode>   \nexport const ContextConsumer = 9;         // 对应 <Context.Consumer>\nexport const ContextProvider = 10;        // 对应 <Context.Provider>\nexport const ForwardRef = 11;             // 对应 React.ForwardRef\nexport const Profiler = 12;               // 对应 <Profiler/ >\nexport const SuspenseComponent = 13;      // 对应 <Suspense>\nexport const MemoComponent = 14;          // 对应 React.memo 返回的组件\n"})}),"\n",(0,t.jsxs)(n.h4,{id:"jsx-最终形成的-fiber-结构图",children:["jsx 最终形成的 fiber 结构图",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#jsx-最终形成的-fiber-结构图",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"最终写的 jsx 会变成如下格式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"jsx7.jpg"})}),"\n",(0,t.jsx)(n.p,{children:"fiber 对应关系"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"child： 一个由父级 fiber 指向子级 fiber 的指针。"}),"\n",(0,t.jsx)(n.li,{children:"return：一个子级 fiber 指向父级 fiber 的指针。"}),"\n",(0,t.jsx)(n.li,{children:"sibling: 一个 fiber 指向下一个兄弟 fiber 的指针。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"温馨提示："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"对于上述在 jsx 中写的 map 数组结构的子节点，外层会被加上 fragment ；"}),"\n",(0,t.jsx)(n.li,{children:"map 返回数组结构，作为 fragment 的子节点。"}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"二-进阶实践-可控性-render",children:["二 进阶实践-可控性 render",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-进阶实践-可控性-render",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"上面的 demo 暴露出了如下问题："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["返回的 ",(0,t.jsx)(n.code,{children:"children"})," 虽然是一个数组，但是数组里面的数据类型却是不确定的，有对象类型( 如",(0,t.jsx)(n.code,{children:"ReactElement"})," ) ，有数组类型(如 ",(0,t.jsx)(n.code,{children:"map"})," 遍历返回的子节点)，还有字符串类型(如文本)；"]}),"\n",(0,t.jsx)(n.li,{children:"无法对 render 后的 React element 元素进行可控性操作。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"针对上述问题，我们需要对demo项目进行改造处理，具体过程可以分为4步："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"将上述children扁平化处理，将数组类型的子节点打开 ；"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"干掉children中文本类型节点；"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["向children最后插入"," say goodbye","元素；"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"克隆新的元素节点并渲染。"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["希望通过这个实践 demo ，大家可以",(0,t.jsx)(n.strong,{children:"加深对 jsx 编译后结构的认识，学会对 jsx 编译后的 React.element 进行一系列操作，达到理想化的目的，以及熟悉 React API 的使用。"})]}),"\n",(0,t.jsx)(n.p,{children:"由于，我们想要把 render 过程变成可控的，因此需要把上述代码进行改造。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"class Index extends React.Component{\n    status = false /* 状态 */\n    renderFoot=()=> <div> i am foot</div>\n    /* 控制渲染 */\n    controlRender=()=>{\n        const reactElement = (\n            <div style={{ marginTop:'100px' }} className=\"container\"  >   \n                 { /* element 元素类型 */ }\n                <div>hello,world</div>  \n                { /* fragment 类型 */ }\n                <React.Fragment>      \n                    <div> \uD83D\uDC7D\uD83D\uDC7D </div>\n                </React.Fragment>\n                { /* text 文本类型 */ }\n                my name is alien       \n                { /* 数组节点类型 */ }\n                { toLearn.map(item=> <div key={item} >let us learn { item } </div> ) } \n                { /* 组件类型 */ }\n                <TextComponent/>  \n                { /* 三元运算 */  }\n                { this.status ? <TextComponent /> :  <div>三元运算</div> }  \n                { /* 函数执行 */ } \n                { this.renderFoot() }  \n                <button onClick={ ()=> console.log( this.render() ) } >打印render后的内容</button>\n            </div>\n        )\n        console.log(reactElement)\n        const { children } = reactElement.props\n        /* 第1步 ： 扁平化 children  */\n        const flatChildren = React.Children.toArray(children)\n        console.log(flatChildren)\n        /* 第2步 ： 除去文本节点 */\n        const newChildren :any= []\n        React.Children.forEach(flatChildren,(item)=>{\n            if(React.isValidElement(item)) newChildren.push(item)\n        })\n        /* 第3步，插入新的节点 */\n        const lastChildren = React.createElement(`div`,{ className :'last' } ,`say goodbye`)\n        newChildren.push(lastChildren)\n        \n        /* 第4步：修改容器节点 */\n        const newReactElement =  React.cloneElement(reactElement,{} ,...newChildren )\n        return newReactElement\n    }\n    render(){\n        return this.controlRender()\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["第 1 步：",(0,t.jsx)(n.code,{children:"React.Children.toArray"})," 扁平化，规范化 children 数组。"]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const flatChildren = React.Children.toArray(children)\nconsole.log(flatChildren)\n"})}),"\n",(0,t.jsx)(n.p,{children:"React.Children.toArray 可以扁平化、规范化 React.element 的 children 组成的数组，只要 children 中的数组元素被打开，对遍历 children 很有帮助，而且 React.Children.toArray 还可以深层次 flat 。"}),"\n",(0,t.jsx)(n.p,{children:"打印结果："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"jsx5.jpg"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"第 2 步：遍历 children ，验证 React.element 元素节点，除去文本节点。"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const newChildren :any= []\nReact.Children.forEach(flatChildren,(item)=>{\n    if(React.isValidElement(item)) newChildren.push(item)\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"用 React.Children.forEach 去遍历子节点，如果是 react Element 元素，就添加到新的 children 数组中，通过这种方式过滤掉非 React element 节点。React.isValidElement 这个方法可以用来检测是否为 React element 元素，接收一个参数——待验证对象，如果是返回 true ， 否则返回 false 。"}),"\n",(0,t.jsx)(n.p,{children:"这里可能会有一个疑问就是如下："}),"\n",(0,t.jsx)(n.p,{children:"难道用数组本身方法 filter 过滤不行么 ？ 为什么要用 React.Children.forEach 遍历？"}),"\n",(0,t.jsxs)(n.p,{children:["这种情况下，是完全可以用数组方法过滤的，因为 React.Children.toArray 已经处理了 children ，使它变成了正常的数组结构 也就是说 ",(0,t.jsx)(n.code,{children:"React.Children.forEach"})," =  ",(0,t.jsx)(n.code,{children:"React.Children.toArray"})," + ",(0,t.jsx)(n.code,{children:"Array.prototype.forEach"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"React.Children.forEach 本身就可以把 children 扁平化了，也就是上述第一步操作多此一举了。为什么要有第一步，主要是更多的学习一下 React api。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"第 3 步：用 React.createElement ，插入到 children 最后"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:" /* 第三步，插入新的节点 */\nconst lastChildren = React.createElement(`div`,{ className :'last' } ,`say goodbye`)\nnewChildren.push(lastChildren)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上述代码实际等于用 ",(0,t.jsx)(n.code,{children:"JSX"})," 这么写："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'newChildren.push(<div className="last" >say goodbye</div>)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"第 4 步: 已经修改了 children，现在做的是，通过 cloneElement 创建新的容器元素。"})}),"\n",(0,t.jsx)(n.p,{children:"为什么要用 React.cloneElement ，createElement 把上面写的 jsx，变成 element 对象;  而 cloneElement 的作用是以 element 元素为样板克隆并返回新的 React element 元素。返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。"}),"\n",(0,t.jsx)(n.p,{children:"这里 React.cloneElement 做的事情就是，把 reactElement 复制一份，再用新的 children 属性，从而达到改变 render 结果的目的。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"/* 第 4 步：修改容器节点 */\nconst newReactElement =  React.cloneElement(reactElement,{} ,...newChildren )\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:"jsx6.jpg"})}),"\n",(0,t.jsx)(n.p,{children:"验证 ："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"① children 已经被扁平化。"}),"\n",(0,t.jsxs)(n.li,{children:["② 文本节点 ",(0,t.jsx)(n.code,{children:" my name is alien "})," 已经被删除。"]}),"\n",(0,t.jsxs)(n.li,{children:["③ ",(0,t.jsx)(n.code,{children:'<div className="last" > say goodbye</div>'})," 元素成功插入。"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"达到了预期效果。"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"｜--------问与答--------｜"})}),"\n",(0,t.jsx)(n.p,{children:"问: React.createElement 和 React.cloneElement 到底有什么区别呢?"}),"\n",(0,t.jsx)(n.p,{children:"答: 可以完全理解为，一个是用来创建 element 。另一个是用来修改 element，并返回一个新的 React.element 对象。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"｜---------end---------｜"})}),"\n",(0,t.jsxs)(n.h2,{id:"三babel-解析-jsx-流程",children:["三、Babel 解析 JSX 流程",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三babel-解析-jsx-流程",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"1-babelplugin-syntax-jsx-和-babelplugin-transform-react-jsx",children:["1 @babel/plugin-syntax-jsx 和 @babel/plugin-transform-react-jsx",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-babelplugin-syntax-jsx-和-babelplugin-transform-react-jsx",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"JSX 语法实现来源于这两个 babel 插件："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"@babel/plugin-syntax-jsx ： 使用这个插件，能够让 Babel 有效的解析 JSX 语法。"}),"\n",(0,t.jsx)(n.li,{children:"@babel/plugin-transform-react-jsx ：这个插件内部调用了 @babel/plugin-syntax-jsx，可以把 React JSX 转化成 JS 能够识别的 createElement 格式。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Automatic Runtime"})}),"\n",(0,t.jsxs)(n.p,{children:["新版本 React 已经不需要引入 createElement ，这种模式来源于 ",(0,t.jsx)(n.code,{children:" Automatic Runtime"}),"，看一下是如何编译的。"]}),"\n",(0,t.jsx)(n.p,{children:"业务代码中写的 JSX 文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function Index(){\n    return <div>\n        <h1>hello,world</h1>\n        <span>let us learn React</span>\n    </div>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"被编译后的文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import { jsx as _jsx } from "react/jsx-runtime";\nimport { jsxs as _jsxs } from "react/jsx-runtime";\nfunction Index() {\n  return  _jsxs("div", {\n            children: [\n                _jsx("h1", {\n                   children: "hello,world"\n                }),\n                _jsx("span", {\n                    children:"let us learn React" ,\n                }),\n            ],\n        });\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"plugin-syntax-jsx 已经向文件中提前注入了 _jsxRuntime api。不过这种模式下需要我们在 .babelrc 设置 runtime: automatic 。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'"presets": [    \n    ["@babel/preset-react",{\n    "runtime": "automatic"\n    }]     \n],\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Classic Runtime"})}),"\n",(0,t.jsx)(n.p,{children:"还有一个就是经典模式，在经典模式下，使用 JSX 的文件需要引入 React ，不然就会报错。"}),"\n",(0,t.jsx)(n.p,{children:"业务代码中写的 JSX 文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import React from 'react'\nfunction Index(){\n    return <div>\n        <h1>hello,world</h1>\n        <span>let us learn React</span>\n    </div>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"被编译后的文件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import React from \'react\'\nfunction Index(){\n    return  React.createElement(\n        "div",\n        null,\n        React.createElement("h1", null,"hello,world"),\n        React.createElement("span", null, "let us learn React")\n    );\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"2-api层面模拟实现",children:["2 api层面模拟实现",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-api层面模拟实现",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"接下来我们通过 api 的方式来模拟一下 Babel 处理 JSX 的流程。"}),"\n",(0,t.jsx)(n.p,{children:"第一步：创建 element.js，写下将测试的 JSX 代码。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"import React from 'react'\n\nfunction TestComponent(){\n    return <p> hello,React </p>\n}\nfunction Index(){\n    return <div>\n        <span>模拟 babel 处理 jsx 流程。</span>\n        <TestComponent />\n    </div>\n}\nexport default Index\n"})}),"\n",(0,t.jsx)(n.p,{children:"第二步：因为 babel 运行在 node 环境，所以同级目录下创建 jsx.js 文件。来模拟一下编译的效果。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const fs = require('fs')\nconst babel = require(\"@babel/core\")\n\n/* 第一步：模拟读取文件内容。 */\nfs.readFile('./element.js',(e,data)=>{ \n    const code = data.toString('utf-8')\n    /* 第二步：转换 jsx 文件 */\n    const result = babel.transformSync(code, {\n        plugins: [\"@babel/plugin-transform-react-jsx\"],\n    });\n    /* 第三步：模拟重新写入内容。 */\n    fs.writeFile('./element.js',result.code,function(){})\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"如上经过三步处理之后，再来看一下 element.js 变成了什么样子。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import React from \'react\';\n\nfunction TestComponent() {\n  return /*#__PURE__*/React.createElement("p", null, " hello,React ");\n}\n\nfunction Index() {\n  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("span", null, "\\u6A21\\u62DF babel \\u5904\\u7406 jsx \\u6D41\\u7A0B\\u3002"), /*#__PURE__*/React.createElement(TestComponent, null));\n}\nexport default Index;\n'})}),"\n",(0,t.jsx)(n.p,{children:"如上可以看到已经成功转成 React.createElement 形式，从根本上弄清楚了 Babel 解析 JSX 的大致流程。"}),"\n",(0,t.jsxs)(n.h2,{id:"四总结",children:["四、总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"本章节主要讲到了两方面的知识。"}),"\n",(0,t.jsx)(n.p,{children:"一方面，我们写的 JSX 会先转换成 React.element，再转化成 React.fiber 的过程。这里要牢牢记住 jsx 转化成 element 的处理逻辑，还有就是 element 类型与转化成 fiber 的 tag 类型的对应关系。这对后续的学习会很有帮助。"}),"\n",(0,t.jsx)(n.p,{children:"另一方面，通过学习第一个实践 demo，我们掌握了如何控制经过 render 之后的 React element 对象。"}),"\n",(0,t.jsx)(n.p,{children:"同时也搞清楚了 Babel 解析 JSX 的大致流程。"}),"\n",(0,t.jsx)(n.p,{children:"下一章节，我们将从React组件角度出发，全方面认识React组件。"}),"\n",(0,t.jsxs)(n.h3,{id:"点击即可跳转",children:[(0,t.jsx)(n.a,{href:"https://github.com/GoodLuckAlien/React-Advanced-Guide-Pro",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(n.code,{children:"案例代码的github地址"})}),"(点击即可跳转)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#点击即可跳转",children:"#"})]})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}let j=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F2.%E5%9F%BA%E7%A1%80%E7%AF%87-%E8%AE%A4%E8%AF%86%20jsx.md"]={toc:[{text:"一 我们写的 JSX 终将变成什么",id:"一-我们写的-jsx-终将变成什么",depth:2},{text:"1 babel 处理后的样子",id:"1-babel-处理后的样子",depth:3},{text:"2 createElement 处理后的样子",id:"2-createelement-处理后的样子",depth:3},{text:"3 React 底层调和处理后，终将变成什么？",id:"3-react-底层调和处理后终将变成什么",depth:3},{text:"不同种类的 fiber Tag",id:"不同种类的-fiber-tag",depth:4},{text:"jsx 最终形成的 fiber 结构图",id:"jsx-最终形成的-fiber-结构图",depth:4},{text:"二 进阶实践-可控性 render",id:"二-进阶实践-可控性-render",depth:2},{text:"三、Babel 解析 JSX 流程",id:"三babel-解析-jsx-流程",depth:2},{text:"1 @babel/plugin-syntax-jsx 和 @babel/plugin-transform-react-jsx",id:"1-babelplugin-syntax-jsx-和-babelplugin-transform-react-jsx",depth:3},{text:"2 api层面模拟实现",id:"2-api层面模拟实现",depth:3},{text:"四、总结",id:"四总结",depth:2},{text:"(点击即可跳转)",id:"点击即可跳转",depth:3}],title:"2.基础篇-认识 jsx",headingTitle:"2.基础篇-认识 jsx",frontmatter:{}}}}]);