"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["31521"],{427516:function(n,e,s){s.r(e),s.d(e,{default:()=>i});var l=s(552676),c=s(740453);function r(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",code:"code",pre:"pre",h3:"h3",ol:"ol"},(0,c.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.h1,{id:"9js-进阶知识点及常考面试题",children:["9.JS 进阶知识点及常考面试题",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#9js-进阶知识点及常考面试题",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"在这一章节中，我们将会学习到一些原理相关的知识，不会解释涉及到的知识点的作用及用法，如果大家对于这些内容还不怎么熟悉，推荐先去学习相关的知识点内容再来学习原理知识。"}),"\n",(0,l.jsxs)(e.h2,{id:"更新日志",children:["更新日志",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#更新日志",children:"#"})]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"优化「手写 call、apply 及 bind 函数」"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"手写-callapply-及-bind-函数",children:["手写 call、apply 及 bind 函数",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#手写-callapply-及-bind-函数",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"首先从以下几点来考虑如何实现这几个函数"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["不传入第一个参数，那么上下文默认为 ",(0,l.jsx)(e.code,{children:"window"})]}),"\n",(0,l.jsxs)(e.li,{children:["改变了 ",(0,l.jsx)(e.code,{children:"this"})," 指向，让新的对象可以执行该函数，并能接受参数"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["那么我们先来实现 ",(0,l.jsx)(e.code,{children:"call"})]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"Function.prototype.myCall = function(context) {\n  if (typeof context === undefined || typeof context === null) {\n    context = window\n  }\n  const symbol = Symbol()\n  context[symbol] = this\n  const args = [...arguments].slice(1)\n  const result = context[symbol](...args)\n  delete context[symbol]\n  return result\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"以下是对实现的分析："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["首先 ",(0,l.jsx)(e.code,{children:"context"})," 为可选参数，如果不传的话默认上下文为 ",(0,l.jsx)(e.code,{children:"window"})]}),"\n",(0,l.jsxs)(e.li,{children:["接下来我们通过 ",(0,l.jsx)(e.code,{children:"Symbol"})," 为 ",(0,l.jsx)(e.code,{children:"context"})," 创建一个属性，并将值设置为需要调用的函数"]}),"\n",(0,l.jsxs)(e.li,{children:["因为 ",(0,l.jsx)(e.code,{children:"call"})," 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来"]}),"\n",(0,l.jsx)(e.li,{children:"然后调用函数并将对象上的函数删除"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["以上就是实现 ",(0,l.jsx)(e.code,{children:"call"})," 的思路，",(0,l.jsx)(e.code,{children:"apply"})," 的实现也类似，区别在于对参数的处理，所以就不一一分析思路了"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"Function.prototype.myApply = function(context) {\n  if (typeof context === undefined || typeof context === null) {\n    context = window\n  }\n  const symbol = Symbol()\n  context[symbol] = this\n  let result\n  // 处理参数和 call 有区别\n  if (arguments[1]) {\n    result = context[symbol](...arguments[1])\n  } else {\n    result = context[symbol]()\n  }\n  delete context[symbol]\n  return result\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"bind"})," 的实现对比其他两个函数略微地复杂了一点，因为 ",(0,l.jsx)(e.code,{children:"bind"})," 需要返回一个函数，需要判断一些边界问题，以下是 ",(0,l.jsx)(e.code,{children:"bind"})," 的实现"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"Function.prototype.myBind = function (context) {\n  if (typeof context === undefined || typeof context === null) {\n    context = window\n  }\n  const _this = this\n  const args = [...arguments].slice(1)\n  // 返回一个函数\n  return function F() {\n    // 因为返回了一个函数，我们可以 new F()，所以需要判断\n    if (this instanceof F) {\n      return new _this(...args, ...arguments)\n    }\n    // 这边的 apply 严谨点可以自己实现\n    return _this.apply(context, args.concat(...arguments))\n  }\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"以下是对实现的分析："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"前几步和之前的实现差不多，就不赘述了"}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"bind"})," 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 ",(0,l.jsx)(e.code,{children:"new"})," 的方式，我们先来说直接调用的方式"]}),"\n",(0,l.jsxs)(e.li,{children:["对于直接调用来说，这里选择了 ",(0,l.jsx)(e.code,{children:"apply"})," 的方式实现，但是对于参数需要注意以下情况：因为 ",(0,l.jsx)(e.code,{children:"bind"})," 可以实现类似这样的代码 ",(0,l.jsx)(e.code,{children:"f.bind(obj, 1)(2)"}),"，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 ",(0,l.jsx)(e.code,{children:"args.concat(...arguments)"})]}),"\n",(0,l.jsxs)(e.li,{children:["最后来说通过 ",(0,l.jsx)(e.code,{children:"new"})," 的方式，在之前的章节中我们学习过如何判断 ",(0,l.jsx)(e.code,{children:"this"}),"，对于 ",(0,l.jsx)(e.code,{children:"new"})," 的情况来说，不会被任何方式改变 ",(0,l.jsx)(e.code,{children:"this"}),"，所以对于这种情况我们需要忽略传入的 ",(0,l.jsx)(e.code,{children:"this"})]}),"\n"]}),"\n",(0,l.jsxs)(e.h3,{id:"常见考点",children:["常见考点",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点",children:"#"})]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"以上三个函数的手写题，这几个手写题算高频出现了"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"new",children:["new",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#new",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["在调用 ",(0,l.jsx)(e.code,{children:"new"})," 的过程中会发生以上四件事情："]}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"新生成了一个对象"}),"\n",(0,l.jsx)(e.li,{children:"链接到原型"}),"\n",(0,l.jsx)(e.li,{children:"绑定 this"}),"\n",(0,l.jsx)(e.li,{children:"返回新对象"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["根据以上几个过程，我们也可以试着来自己实现一个 ",(0,l.jsx)(e.code,{children:"new"}),"："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function create() {\n  let obj = {}\n  let Con = [].shift.call(arguments)\n  obj.__proto__ = Con.prototype\n  let result = Con.apply(obj, arguments)\n  return result instanceof Object ? result : obj\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"以下是对实现的分析："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"创建一个空对象"}),"\n",(0,l.jsx)(e.li,{children:"获取构造函数"}),"\n",(0,l.jsx)(e.li,{children:"设置空对象的原型"}),"\n",(0,l.jsxs)(e.li,{children:["绑定 ",(0,l.jsx)(e.code,{children:"this"})," 并执行构造函数"]}),"\n",(0,l.jsx)(e.li,{children:"确保返回值为对象"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["对于对象来说，其实都是通过 ",(0,l.jsx)(e.code,{children:"new"})," 产生的，无论是 ",(0,l.jsx)(e.code,{children:"function Foo()"})," 还是 ",(0,l.jsx)(e.code,{children:"let a = { b : 1 }"})," 。"]}),"\n",(0,l.jsxs)(e.p,{children:["对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 ",(0,l.jsx)(e.code,{children:"new Object()"})," 的方式创建对象需要通过作用域链一层层找到 ",(0,l.jsx)(e.code,{children:"Object"}),"，但是你使用字面量的方式就没这个问题。"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function Foo() {}\n// function 就是个语法糖\n// 内部等同于 new Function()\nlet a = { b: 1 }\n// 这个字面量内部也是使用了 new Object()\n"})}),"\n",(0,l.jsxs)(e.p,{children:["更多关于 ",(0,l.jsx)(e.code,{children:"new"})," 的内容可以阅读我写的文章 ",(0,l.jsx)(e.a,{href:"https://github.com/KieSun/Dream/issues/14",target:"_blank",rel:"noopener noreferrer",children:"聊聊 new 操作符"}),"。"]}),"\n",(0,l.jsxs)(e.h3,{id:"常见考点-1",children:["常见考点",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点-1",children:"#"})]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"new 的原理是什么？"}),"\n",(0,l.jsx)(e.li,{children:"通过 new 的方式创建对象和通过字面量创建有什么区别？"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"instanceof-的原理",children:["instanceof 的原理",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#instanceof-的原理",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"instanceof"})," 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 ",(0,l.jsx)(e.code,{children:"prototype"}),"。"]}),"\n",(0,l.jsxs)(e.p,{children:["我们也可以试着实现一下 ",(0,l.jsx)(e.code,{children:"instanceof"})]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function myInstanceof(left, right) {\n  let prototype = right.prototype\n  left = left.__proto__\n  while (true) {\n    if (left === null || left === undefined)\n      return false\n    if (prototype === left)\n      return true\n    left = left.__proto__\n  }\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"以下是对实现的分析："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"首先获取类型的原型"}),"\n",(0,l.jsx)(e.li,{children:"然后获得对象的原型"}),"\n",(0,l.jsxs)(e.li,{children:["然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 ",(0,l.jsx)(e.code,{children:"null"}),"，因为原型链最终为 ",(0,l.jsx)(e.code,{children:"null"})]}),"\n"]}),"\n",(0,l.jsxs)(e.h3,{id:"常见考点-2",children:["常见考点",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点-2",children:"#"})]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"手写题"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"为什么-01--02--03",children:["为什么 0.1 + 0.2 != 0.3",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么-01--02--03",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"先说原因，因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。"}),"\n",(0,l.jsxs)(e.p,{children:["我们都知道计算机是通过二进制来存储东西的，那么 ",(0,l.jsx)(e.code,{children:"0.1"})," 在二进制中会表示为："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"// (0011) 表示循环\n0.1 = 2^-4 * 1.10011(0011)\n"})}),"\n",(0,l.jsxs)(e.p,{children:["我们可以发现，",(0,l.jsx)(e.code,{children:"0.1"})," 在二进制中是无限循环的一些数字，其实不只是 ",(0,l.jsx)(e.code,{children:"0.1"}),"，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 JS 采用的浮点数标准却会裁剪掉我们的数字。"]}),"\n",(0,l.jsx)(e.p,{children:"IEEE 754 双精度版本（64位）将 64 位分为了三段："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"第一位用来表示符号"}),"\n",(0,l.jsx)(e.li,{children:"接下去的 11 位用来表示指数"}),"\n",(0,l.jsxs)(e.li,{children:["其他的位数用来表示有效位，也就是用二进制表示 ",(0,l.jsx)(e.code,{children:"0.1"})," 中的 ",(0,l.jsx)(e.code,{children:"10011(0011)"})]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 ",(0,l.jsx)(e.code,{children:"0.1"})," 不再是 ",(0,l.jsx)(e.code,{children:"0.1"})," 了，而是变成了 ",(0,l.jsx)(e.code,{children:"0.100000000000000002"}),"。"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"0.100000000000000002 === 0.1 // true\n"})}),"\n",(0,l.jsxs)(e.p,{children:["那么同样的，",(0,l.jsx)(e.code,{children:"0.2"})," 在二进制也是无限循环的，被裁剪后也失去了精度变成了 ",(0,l.jsx)(e.code,{children:"0.200000000000000002"}),"。"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"0.200000000000000002 === 0.2 // true\n"})}),"\n",(0,l.jsxs)(e.p,{children:["所以这两者相加不等于 ",(0,l.jsx)(e.code,{children:"0.3"})," 而是 ",(0,l.jsx)(e.code,{children:"0.300000000000000004"}),"。"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"0.1 + 0.2 === 0.30000000000000004 // true\n"})}),"\n",(0,l.jsxs)(e.p,{children:["那么可能你又会有一个疑问，既然 ",(0,l.jsx)(e.code,{children:"0.1"})," 不是 ",(0,l.jsx)(e.code,{children:"0.1"}),"，那为什么 ",(0,l.jsx)(e.code,{children:"console.log(0.1)"})," 却是正确的呢？"]}),"\n",(0,l.jsx)(e.p,{children:"因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证。"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"console.log(0.100000000000000002) // 0.1\n"})}),"\n",(0,l.jsx)(e.p,{children:"那么说完了为什么，最后来说说怎么解决这个问题吧。其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题。"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true\n"})}),"\n",(0,l.jsxs)(e.h3,{id:"常见考点-3",children:["常见考点",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点-3",children:"#"})]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"为什么 0.1 + 0.2 != 0.3，如何解决这个问题？"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"垃圾回收机制",children:["垃圾回收机制",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#垃圾回收机制",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。"}),"\n",(0,l.jsxs)(e.h2,{id:"新生代算法",children:["新生代算法",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#新生代算法",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。"}),"\n",(0,l.jsx)(e.p,{children:"在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。"}),"\n",(0,l.jsxs)(e.h2,{id:"老生代算法",children:["老生代算法",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#老生代算法",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。"}),"\n",(0,l.jsx)(e.p,{children:"在讲算法前，先来说下什么情况下对象会出现在老生代空间中："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。"}),"\n",(0,l.jsx)(e.li,{children:"To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"老生代中的空间很复杂，有如下几个空间"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-c++",children:"enum AllocationSpace {\n  // TODO(v8:7464): Actually map this space's memory as read-only.\n  RO_SPACE,    // 不变的对象空间\n  NEW_SPACE,   // 新生代用于 GC 复制算法的空间\n  OLD_SPACE,   // 老生代常驻对象空间\n  CODE_SPACE,  // 老生代代码对象空间\n  MAP_SPACE,   // 老生代 map 对象\n  LO_SPACE,    // 老生代大空间对象\n  NEW_LO_SPACE,  // 新生代大空间对象\n\n  FIRST_SPACE = RO_SPACE,\n  LAST_SPACE = NEW_LO_SPACE,\n  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,\n  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE\n};\n"})}),"\n",(0,l.jsx)(e.p,{children:"在老生代中，以下情况会先启动标记清除算法："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"某一个空间没有分块的时候"}),"\n",(0,l.jsx)(e.li,{children:"空间中被对象超过一定限制"}),"\n",(0,l.jsx)(e.li,{children:"空间不能保证新生代中的对象移动到老生代中"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 ",(0,l.jsx)(e.a,{href:"https://v8project.blogspot.com/2018/06/concurrent-marking.html",target:"_blank",rel:"noopener noreferrer",children:"该博客"})," 详细阅读。"]}),"\n",(0,l.jsx)(e.p,{children:"清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。"}),"\n",(0,l.jsxs)(e.h3,{id:"常见考点-4",children:["常见考点",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#常见考点-4",children:"#"})]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"V8 下的垃圾回收机制是怎么样的？"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"小结",children:["小结",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"以上就是 JS 进阶知识点的内容了，这部分的知识相比于之前的内容更加深入也更加的理论，也是在面试中能够于别的候选者拉开差距的一块内容。如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(r,{...n})}):r(n)}let i=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%2F9.JS%20%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E5%8F%8A%E5%B8%B8%E8%80%83%E9%9D%A2%E8%AF%95%E9%A2%98.md"]={toc:[{text:"更新日志",id:"更新日志",depth:2},{text:"手写 call、apply 及 bind 函数",id:"手写-callapply-及-bind-函数",depth:2},{text:"常见考点",id:"常见考点",depth:3},{text:"new",id:"new",depth:2},{text:"常见考点",id:"常见考点-1",depth:3},{text:"instanceof 的原理",id:"instanceof-的原理",depth:2},{text:"常见考点",id:"常见考点-2",depth:3},{text:"为什么 0.1 + 0.2 != 0.3",id:"为什么-01--02--03",depth:2},{text:"常见考点",id:"常见考点-3",depth:3},{text:"垃圾回收机制",id:"垃圾回收机制",depth:2},{text:"新生代算法",id:"新生代算法",depth:2},{text:"老生代算法",id:"老生代算法",depth:2},{text:"常见考点",id:"常见考点-4",depth:3},{text:"小结",id:"小结",depth:2}],title:"9.JS 进阶知识点及常考面试题",headingTitle:"9.JS 进阶知识点及常考面试题",frontmatter:{}}}}]);