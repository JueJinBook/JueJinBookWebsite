"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["42150"],{33038:function(e,n,s){s.r(n),s.d(n,{default:()=>j});var i=s(552676),r=s(740453);let c=s.p+"static/image/78a23d5f10265846d3afba71593f67b5.4ec34a8e.webp",t=s.p+"static/image/59839f4bcf801b76424d60b7b6c922e0.fe5e1be0.webp",d=s.p+"static/image/1ea9c49a7f948f235b6acb78e077c01d.6134a711.webp",l=s.p+"static/image/7df31505d8340ba87a58a0d0ee3fa4df.40b62947.webp",a=s.p+"static/image/72b1739d9b6a2ea04e87728d9a7f3e80.7df0ad1e.webp",h=s.p+"static/image/d83f0864839eec5f7db0a251ecad6b8d.55641fe6.webp",x=s.p+"static/image/0560689a465f18968a452a8f3ddbf19f.fd3732a1.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h3:"h3",pre:"pre",img:"img",ol:"ol",li:"li",strong:"strong",ul:"ul",h4:"h4"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"29配置篇-_-typescript-和-eslint",children:["29.配置篇 _ TypeScript 和 ESLint",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#29配置篇-_-typescript-和-eslint",children:"#"})]}),"\n",(0,i.jsxs)(n.h2,{id:"前言",children:["前言",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["使用 ",(0,i.jsx)(n.code,{children:"create-next-app"}),"创建项目的时候，Next.js 会提示是否使用 TypeScript 和 ESLint，本篇会详细介绍 TypeScript 和 ESLint 的配置内容，帮助大家了解默认设置中支持的功能和逻辑。"]}),"\n",(0,i.jsxs)(n.h2,{id:"typescript",children:["TypeScript",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#typescript",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"Next.js 内置了对 TypeScript 的支持，会自动安装所需依赖以及进行合适的配置。"}),"\n",(0,i.jsxs)(n.h3,{id:"1-新项目",children:["1. 新项目",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-新项目",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["当你运行 ",(0,i.jsx)(n.code,{children:"create-next-app"})," 创建项目的时候，就会让你选择是否使用 TypeScript，默认是 ",(0,i.jsx)(n.code,{children:"Yes"}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"npx create-next-app@latest\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-现有项目",children:["2. 现有项目",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-现有项目",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["将文件重命名为 ",(0,i.jsx)(n.code,{children:".ts"}),"或者 ",(0,i.jsx)(n.code,{children:".tsx"}),"，然后运行 ",(0,i.jsx)(n.code,{children:"next dev"}),"和 ",(0,i.jsx)(n.code,{children:"next build"}),"，Next.js 会自动安装所需依赖，以及添加一个包含推荐配置项的 ",(0,i.jsx)(n.code,{children:"tsconfig.json"}),"文件。"]}),"\n",(0,i.jsxs)(n.p,{children:["如果你已经有了一个 ",(0,i.jsx)(n.code,{children:"jsconfig.json"})," 文件，那就需要你手动拷贝 ",(0,i.jsx)(n.code,{children:"jsconfig.json"}),"中的内容（比如 ",(0,i.jsx)(n.code,{children:"paths"}),"）到 ",(0,i.jsx)(n.code,{children:"tsconfig.json"}),"中，然后删除掉之前的 ",(0,i.jsx)(n.code,{children:"jsconfig.json"}),"文件。"]}),"\n",(0,i.jsxs)(n.h3,{id:"3-typescript-插件",children:["3. TypeScript 插件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-typescript-插件",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"Next.js 包含了一个自定义的 TypeScript 插件和类型检查器。VScode 和其他代码编辑器可以用其实现高级类型检查和自动补写功能。"}),"\n",(0,i.jsx)(n.p,{children:"在 VSCode 中开启："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["打开命令面板（",(0,i.jsx)(n.code,{children:"Ctrl/⌘"})," + ",(0,i.jsx)(n.code,{children:"Shift"})," + ",(0,i.jsx)(n.code,{children:"P"}),"）"]}),"\n",(0,i.jsxs)(n.li,{children:["搜索 ",(0,i.jsx)(n.code,{children:"TypeScript: Select TypeScript Version"})]}),"\n",(0,i.jsxs)(n.li,{children:["选择“",(0,i.jsx)(n.code,{children:"Use Workspace Versiion"}),"”"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["现在，当你编辑文件的时候，自定义 TypeScript 插件就会启用。当运行 ",(0,i.jsx)(n.code,{children:"next build"}),"的时候，会执行自定义类型检查器。"]}),"\n",(0,i.jsx)(n.p,{children:"插件功能介绍："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"当使用了无效的路由段配置会出现警告："}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"显示上下文文档："}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"显示可用选项："}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsxs)(n.li,{children:["确保 ",(0,i.jsx)(n.code,{children:"use client"}),"被正确使用："]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,i.jsxs)(n.ol,{start:"5",children:["\n",(0,i.jsx)(n.li,{children:"确保客户端 hooks（如 useState）只在客户端组件中使用："}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-最低-typescript-版本要求",children:["4. 最低 TypeScript 版本要求",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-最低-typescript-版本要求",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"Next.js 推荐最少要 v4.5.2 版本以获取如导入名称的 type 修饰符（type Modifiers on Import Names）等功能："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// 可以直接导入类型\nimport { someFunc, type BaseType } from "./some-module.js";\n\nexport class Thing implements BaseType {\n  someMethod() {\n    someFunc();\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"5-静态写入链接",children:["5. 静态写入链接",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-静态写入链接",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Next.js 可以静态写入链接，防止使用 ",(0,i.jsx)(n.code,{children:"next/link"})," 时出现拼写或者其他错误，从而保证页面导航地址的正确性。"]}),"\n",(0,i.jsxs)(n.p,{children:["要使用此功能，需要在项目使用 TypeScript 的前提下，在 ",(0,i.jsx)(n.code,{children:"next.config.js"})," 中使用 ",(0,i.jsx)(n.code,{children:"experimental.typedRoutes"}),"选项开启："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    typedRoutes: true,\n  },\n}\n \nmodule.exports = nextConfig\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Next.js 将会在 ",(0,i.jsx)(n.code,{children:".next/types"})," 中生成一个包含所有路由信息的链接定义，从而让 TypeScript 据此来进行链接提示。"]}),"\n",(0,i.jsxs)(n.p,{children:["目前，支持任何字符串文字，包括动态路由。对于非文字字符，目前则需要手工使用 ",(0,i.jsx)(n.code,{children:"as Route"}),"标示 ",(0,i.jsx)(n.code,{children:"href"})," :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import type { Route } from 'next';\nimport Link from 'next/link'\n \n// 如果 href 是有效路由，则不会出现 TypeScript 错误\n<Link href=\"/about\" />\n<Link href=\"/blog/nextjs\" />\n<Link href={`/blog/${slug}`} />\n<Link href={('/blog' + slug) as Route} />\n \n// 如果 href 不是有效路由，则会出现 TypeScript 错误，这里出现了拼写错误\n<Link href=\"/aboot\" />\n"})}),"\n",(0,i.jsxs)(n.p,{children:["如果要在一个使用 ",(0,i.jsx)(n.code,{children:"next/link"})," 包装的自定义组件中接收 ",(0,i.jsx)(n.code,{children:"href"})," 属性，使用泛型："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import type { Route } from 'next'\nimport Link from 'next/link'\n \nfunction Card<T extends string>({ href }: { href: Route<T> | URL }) {\n  return (\n    <Link href={href}>\n      <div>My Card</div>\n    </Link>\n  )\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"6-nextconfigjs-中的类型检查",children:["6. next.config.js 中的类型检查",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-nextconfigjs-中的类型检查",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"next.config.js"})," 必须是一个 JavaScript 文件，它不会被 TypeScript 或者 Babel 解析，但你可以使用 JSDoc 添加一些类型检查，举个例子："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// @ts-check\n \n/**\n * @type {import('next').NextConfig}\n **/\nconst nextConfig = {\n  /* config options here */\n}\n \nmodule.exports = nextConfig\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"7-忽略-typescript-错误",children:["7. 忽略 TypeScript 错误",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-忽略-typescript-错误",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["当出现 TypeScript 错误的时候，使用 ",(0,i.jsx)(n.code,{children:"next build"})," 构建生产版本会失败。但如果你希望及时有错误，也要构建出生产代码，那你可以禁用内置的类型检查。打开 ",(0,i.jsx)(n.code,{children:"next.config.js"}),"启用 ",(0,i.jsx)(n.code,{children:"typescript.ignoreBuildErrors"})," 选项："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  typescript: {\n    // !! WARN !!\n    // 其实是很危险的操作\n    // !! WARN !!\n    ignoreBuildErrors: true,\n  },\n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"eslint",children:["ESLint",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#eslint",children:"#"})]}),"\n",(0,i.jsxs)(n.h3,{id:"1-eslint-配置选项",children:["1. ESLint 配置选项",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-eslint-配置选项",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Next.js 提供了开箱即用的 ESLint 功能（如果你创建项目的时候选择了 ESLint），查看 ",(0,i.jsx)(n.code,{children:"package.json"}),"会看到："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'// package.json\n{\n  "scripts": {\n    "lint": "next lint"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["然后运行 ",(0,i.jsx)(n.code,{children:"npm run lint"})," 或者",(0,i.jsx)(n.code,{children:"yarn lint"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"yarn lint\n"})}),"\n",(0,i.jsx)(n.p,{children:"如果应用中并没有 ESLint 相关的配置，则会引导你安装和配置："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-shell",children:"? How would you like to configure ESLint?\n\n❯ Strict (recommended)\nBase\nCancel\n"})}),"\n",(0,i.jsx)(n.p,{children:"这个时候你会看到三个选项："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Strict"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["这是首次设置 ESLint 的推荐配置。包括 Next.js 基础 ESLint 配置以及更严格的核心 Web 指标规则集。查看 ",(0,i.jsx)(n.code,{children:".eslintrc.json"}),"文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'// .eslintrc.json\n{\n  "extends": "next/core-web-vitals"\n}\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Base"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["只包括 Next.js 基础 ESLint 配置，查看 ",(0,i.jsx)(n.code,{children:".eslintrc.json"}),"文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'// .eslintrc.json\n{\n  "extends": "next"\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["这个时候你可能困惑 ",(0,i.jsx)(n.code,{children:"Strict"})," 模式下不是包含了基础 ESLint 配置吗？为什么 ",(0,i.jsx)(n.code,{children:"Strict"})," 下的 ",(0,i.jsx)(n.code,{children:"extends"})," 没有 ",(0,i.jsx)(n.code,{children:'"next"'}),"呢？这是因为 ",(0,i.jsx)(n.code,{children:'"next/core-web-vitals"'})," 的规则拓展了 ",(0,i.jsx)(n.code,{children:'"next"'}),"，也就是说包含了 ",(0,i.jsx)(n.code,{children:'"next"'})," ，所以无须再次 extends 了。"]}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Cancel"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"不包括任何 ESLint 配置。当你需要自定义 ESLint 配置的时候，选择此项。"}),"\n",(0,i.jsxs)(n.p,{children:["如果选择了前两个配置项的任何一个，Next.js 都会自动安装 ",(0,i.jsx)(n.code,{children:"eslint"})," 和 ",(0,i.jsx)(n.code,{children:"eslint-config-next"})," 作为应用的依赖项，以及在项目的根目录创建一个包含你选择的配置的 ",(0,i.jsx)(n.code,{children:".eslintrc.json"})," 文件。"]}),"\n",(0,i.jsxs)(n.p,{children:["现在你就可以运行 ",(0,i.jsx)(n.code,{children:"next lint"}),"捕获错误。一般 ESLint 设置完成后，它会在每次 ",(0,i.jsx)(n.code,{children:"next build"})," 的时候自动运行。如果有错误会导致构建失败，警告则不会。"]}),"\n",(0,i.jsxs)(n.h3,{id:"2-eslint-配置",children:["2. ESLint 配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-eslint-配置",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["默认配置 ",(0,i.jsx)(n.code,{children:"eslint-config-next"}),"包含以下插件："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/eslint-plugin-react",target:"_blank",rel:"noopener noreferrer",children:"eslint-plugin-react"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/eslint-plugin-react-hooks",target:"_blank",rel:"noopener noreferrer",children:"eslint-plugin-react-hooks"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/@next/eslint-plugin-next",target:"_blank",rel:"noopener noreferrer",children:"eslint-plugin-next"})}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["初次接触 ESLint 的同学可能对 ESLint 的 ",(0,i.jsx)(n.code,{children:"config"})," 和 ",(0,i.jsx)(n.code,{children:"plugin"})," 概念有些困惑。我们简单讲一下区别。"]}),"\n",(0,i.jsxs)(n.p,{children:["现在假设你是 Next.js 的开发者，为了让用户更好的使用 Next.js，需要根据 Next.js 的用法自定义一些 ESLint 规则，就比如我们在讲 ",(0,i.jsx)(n.code,{children:"<Script>"})," 组件的时候讲到内联脚本："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"<Script id=\"show-banner\">\n  {`document.getElementById('banner').classList.remove('hidden')`}\n<\/Script>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Next.js 要求必须为内联脚本分配一个 id，以保证 Next.js 追踪和优化脚本。如果用户没有传入 id，就可以使用 ESLint 提示一个错误。为了实现这个自定义规则，我们就需要编写一个插件，名为 ",(0,i.jsx)(n.code,{children:"eslint-plugin-next"}),"，其中 ",(0,i.jsx)(n.code,{children:"eslint-plugin-"}),"这个前缀是 ESLint 要求的。它的代码结构类似于："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"module.exports = {\n  rules: {\n    'inline-script-id': require('./rules/inline-script-id'),\n    // ... 其他规则\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"开发了一堆规则还不够，正如打游戏的时候，游戏难度有简单、适中、困难、地狱，规则集合也是一样，我们也可以用这些规则建立多个分类，比如推荐、严格、宽松等，这个也可以写在插件代码中，代码结构类似于："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"module.exports = {\n  rules: {\n    'inline-script-id': require('./rules/inline-script-id'),\n    // ... 其他规则\n  },\n  configs: {\n    recommended: {\n      plugins: ['next'],\n      rules: {\n        // warnings\n        'next/inline-script-id': 'warn',\n        // errors\n        'next/other-rule': 'error',\n      },\n    },\n    strict: {\n      plugins: ['next'],\n      rules: {\n        'next/inline-script-id': 'error',\n        'next/other-rule': 'error',\n      },\n    },\n  },\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在这个示例中，我们为我们的 ",(0,i.jsx)(n.code,{children:"eslint-plugin-next"}),"插件定义了两套配置，一套名为 ",(0,i.jsx)(n.code,{children:"recommended"}),"，一套名为 ",(0,i.jsx)(n.code,{children:"strict"}),"。其中 ",(0,i.jsx)(n.code,{children:"plugins: ['next']"})," 表示加载名为 ",(0,i.jsx)(n.code,{children:"eslint-plugin-next"}),"的插件（ESLint 会自动补全名字），其实就是自己，然后 ",(0,i.jsx)(n.code,{children:"rules"}),"设定使用哪些规则和规则的提示，比如同样是 ",(0,i.jsx)(n.code,{children:"inline-script-id"})," 这条规则，在 ",(0,i.jsx)(n.code,{children:"recommended"})," 中，我们设定为 ",(0,i.jsx)(n.code,{children:"warn"}),"，但是在 ",(0,i.jsx)(n.code,{children:"strict"})," 中，既然是严格，我们就设定为 ",(0,i.jsx)(n.code,{children:"error"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["有了这个插件还不够，Next.js 是基于 React 的，关于 React 的用法，也有一些 ESLint 规则，React 的开发者对应开发了 eslint-plugin-react 插件。这个插件虽然不错，但是个别规则我不想用，又该怎么办呢？为了帮助开发者提供一个更加“成品”的配置项，你可以定义一个 ",(0,i.jsx)(n.code,{children:"eslint-config-next"}),"配置，其中 ",(0,i.jsx)(n.code,{children:"eslint-config-"}),"这个前缀是 ESLint 要求的。它的代码结构类似于："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"module.exports = {\n  extends: [\n    'plugin:next/recommended',\n  ],\n  plugins: ['react'],\n  rules: {\n    'react/no-unknown-property': 'warn',\n    'react/jsx-no-target-blank': 'off'\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在这个例子中，我们使用 extends 表示使用已有的配置，",(0,i.jsx)(n.code,{children:"'plugin:next/recommended'"}),"表示的就是 ",(0,i.jsx)(n.code,{children:"eslint-plugin-next"}),"插件中的 recommended 配置。plugins 表示加载的插件，但是这只是加载，具体使用哪些规则，你还需要写 rules 自定义。"]}),"\n",(0,i.jsxs)(n.p,{children:["这个成品的配置，我们可以在 ",(0,i.jsx)(n.code,{children:".eslintrc.json"}),"中，使用 extends 语法直接继承："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'{\n  "extends": "next"\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["因为所有的配置包都是以 ",(0,i.jsx)(n.code,{children:"eslint-config-"}),"开头，所以不需要写成 ",(0,i.jsx)(n.code,{children:'"extends": "eslint-config-next"'}),"，ESLint 会自动补全。"]}),"\n",(0,i.jsxs)(n.p,{children:["简而言之，就如它们的名字一样，",(0,i.jsx)(n.code,{children:"plugin"})," 侧重于规则的编写，",(0,i.jsx)(n.code,{children:"config"})," 侧重于规则的配置。",(0,i.jsx)(n.code,{children:"plugin"})," 使用 ",(0,i.jsx)(n.code,{children:"plugins: [xxx]"}),"的形式加载，但还需要编写 ",(0,i.jsx)(n.code,{children:"rules"})," 才能使用。",(0,i.jsx)(n.code,{children:"config"})," 可以使用 ",(0,i.jsx)(n.code,{children:"extends"}),"语法直接继承，无须再额外编写。",(0,i.jsx)(n.code,{children:"extends"})," 语法也可以继承 ",(0,i.jsx)(n.code,{children:"plugin"})," 中编写的配置，语法为 ",(0,i.jsx)(n.code,{children:"extends: ['plugin:xxxx/xxx']"}),"这种形式。"]}),"\n",(0,i.jsxs)(n.h3,{id:"3-eslint-插件",children:["3. ESLint 插件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-eslint-插件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Next.js 提供了一个 ESLint 插件 ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/@next/eslint-plugin-next",target:"_blank",rel:"noopener noreferrer",children:"eslint-plugin-next"}),"，已经绑定在基本配置（eslint-config-next）中，完整的 21 条规则可以查看 ",(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/configuring/eslint#eslint-plugin",target:"_blank",rel:"noopener noreferrer",children:"https://nextjs.org/docs/app/building-your-application/configuring/eslint#eslint-plugin"})]}),"\n",(0,i.jsxs)(n.h3,{id:"4-自定义应用目录",children:["4. 自定义应用目录",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-自定义应用目录",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["如果你正在使用 ",(0,i.jsx)(n.code,{children:"eslint-plugin-next"}),"，但是没有在根目录里安装 Next.js（比如 monorepo 项目），你可以使用 ",(0,i.jsx)(n.code,{children:".eslintrc"})," 的 ",(0,i.jsx)(n.code,{children:"settings"})," 属性告诉 ",(0,i.jsx)(n.code,{children:"eslint-plugin-next"})," 哪里找到你的 Next.js 应用："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'// .eslintrc.json\n{\n  "extends": "next",\n  "settings": {\n    "next": {\n      "rootDir": "packages/my-app/"\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rootDir"})," 可以是一个路径（相对地址或者绝对地址），也可以使用通配符，比如 ",(0,i.jsx)(n.code,{children:"packages/*/"}),"，也可以是一个包含路径或使用通配符的地址的数组。"]}),"\n",(0,i.jsxs)(n.h3,{id:"5-自定义检查目录和文件",children:["5. 自定义检查目录和文件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-自定义检查目录和文件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["默认情况下，Next.js 会为 ",(0,i.jsx)(n.code,{children:"pages/"}),"、",(0,i.jsx)(n.code,{children:"app/"}),"、",(0,i.jsx)(n.code,{children:"components/"}),"、",(0,i.jsx)(n.code,{children:"lib/"}),"和 ",(0,i.jsx)(n.code,{children:"src/"})," 目录下的所有文件运行 ESLint。不过你可以使用",(0,i.jsx)(n.code,{children:"next.config.js"})," 的 ",(0,i.jsx)(n.code,{children:"eslint.dirs"})," 选项指定检查的目录："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  eslint: {\n    dirs: ['pages', 'utils'], \n  },\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["同样，你可以使用 ",(0,i.jsx)(n.code,{children:"next lint"})," 的 ",(0,i.jsx)(n.code,{children:"--dir"})," 和 ",(0,i.jsx)(n.code,{children:"--file"})," 指定检查的目录和文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"next lint --dir pages --dir utils --file bar.js\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"6-缓存",children:["6. 缓存",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-缓存",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["为了提高性能，Next.js 默认会缓存 ESLint 处理信息，存在",(0,i.jsx)(n.code,{children:".next/cache"}),"或者构建目录下 。如果需要禁用缓存，使用 ",(0,i.jsx)(n.code,{children:"next lint"})," 的 ",(0,i.jsx)(n.code,{children:"--no-cache"}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"next lint --no-cache\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"7-禁用规则",children:["7. 禁用规则",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-禁用规则",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["如果你希望修改或者禁用插件（",(0,i.jsx)(n.code,{children:"react"}),"、",(0,i.jsx)(n.code,{children:"react-hooks"}),"、",(0,i.jsx)(n.code,{children:"next"}),"）中的规则，你可以直接在 ",(0,i.jsx)(n.code,{children:".eslintrc"})," 中使用 ",(0,i.jsx)(n.code,{children:"rules"})," 属性更改它们："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'// .eslintrc.json\n{\n  "extends": "next",\n  "rules": {\n    "react/no-unescaped-entities": "off",\n    "@next/next/no-page-custom-font": "off"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"8-core-web-vitals",children:["8. core-web-vitals",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-core-web-vitals",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["前面讲到，首次运行 ",(0,i.jsx)(n.code,{children:"next lint"}),"并选择 ",(0,i.jsx)(n.code,{children:"Strict"})," 选项，会开启使用 ",(0,i.jsx)(n.code,{children:"next/core-web-vitals"}),"规则集："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "extends": "next/core-web-vitals"\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["通过",(0,i.jsx)(n.a,{href:"https://github.com/vercel/next.js/blob/canary/packages/eslint-plugin-next/src/index.ts",target:"_blank",rel:"noopener noreferrer",children:"查看源码"}),"，可以得知目前 ",(0,i.jsx)(n.code,{children:"core-web-vitals"})," 配置相比于默认配置会更加严格："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"module.exports = {\n  rules: {\n    // ...\n  },\n  configs: {\n    recommended: {\n      plugins: ['@next/next'],\n      rules: {\n        // warnings\n        '@next/next/no-html-link-for-pages': 'warn',\n        '@next/next/no-sync-scripts': 'warn',\n         //...\n      },\n    },\n    'core-web-vitals': {\n      plugins: ['@next/next'],\n      extends: ['plugin:@next/next/recommended'],\n      rules: {\n        '@next/next/no-html-link-for-pages': 'error',\n        '@next/next/no-sync-scripts': 'error',\n      },\n    },\n  },\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["其实目前也就将 2 条规则设定的更严格了一些，一条是 ",(0,i.jsx)(n.code,{children:"no-html-link-for-pages"}),"，也就是不要用 ",(0,i.jsx)(n.code,{children:"<a>"})," 标签，而是用 Link 组件替代："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'function Home() {\n  return (\n    <div>\n      <a href="/about">About Us</a>\n    </div>\n  )\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"你应该改为使用："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"import Link from 'next/link'\n \nfunction Home() {\n  return (\n    <div>\n      <Link href=\"/about\">About Us</Link>\n    </div>\n  )\n}\n \nexport default Home\n"})}),"\n",(0,i.jsxs)(n.p,{children:["另外一条是 ",(0,i.jsx)(n.code,{children:"no-sync-scripts"}),"，不要用同步脚本，也就推荐使用 Script 组件或者为 script 添加 defer 或者 async 属性："]}),"\n",(0,i.jsx)(n.p,{children:"使用 Script 组件："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'import Script from \'next/script\'\n \nfunction Home() {\n  return (\n    <div class="container">\n      <Script src="https://third-party-script.js"><\/Script>\n      <div>Home Page</div>\n    </div>\n  )\n}\n \nexport default Home\n'})}),"\n",(0,i.jsx)(n.p,{children:"添加 async 或 defer 属性："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'<script src="https://third-party-script.js" async />\n<script src="https://third-party-script.js" defer />\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"9-搭配其他工具",children:["9. 搭配其他工具",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-搭配其他工具",children:"#"})]}),"\n",(0,i.jsxs)(n.h4,{id:"91-prettier",children:["9.1. prettier",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#91-prettier",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["ESLint 也包含代码格式化规则，可能会跟已经存在的 Prettier 配置冲突。我们推荐使用 ",(0,i.jsx)(n.code,{children:"eslint-config-prettier"})," 让 ESLint 和 Prettier 能够协同工作。"]}),"\n",(0,i.jsx)(n.p,{children:"首先安装依赖："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"npm install --save-dev eslint-config-prettier\n \nyarn add --dev eslint-config-prettier\n \npnpm add --save-dev eslint-config-prettier\n \nbun add --dev eslint-config-prettier\n"})}),"\n",(0,i.jsxs)(n.p,{children:["然后添加 ",(0,i.jsx)(n.code,{children:"prettier"}),"到 ",(0,i.jsx)(n.code,{children:".eslintrc.json"}),"中："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'// .eslintrc.json\n{\n  "extends": ["next", "prettier"]\n}\n'})}),"\n",(0,i.jsxs)(n.h4,{id:"92-lint-staged",children:["9.2. lint-staged",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#92-lint-staged",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"开发的时候，你肯定不希望修改了一个文件后，又所有文件都执行一次 ESLint 检查，那你就可以使用 lint-staged，它会在暂存的 git 文件上（git add 的那些文件）执行 ESLint 检查。"}),"\n",(0,i.jsxs)(n.p,{children:["为了搭配使用 lint-staged，你需要将以下内容添加到根目录的 ",(0,i.jsx)(n.code,{children:".lintstagedrc.js"})," 文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// .lintstagedrc.js\nconst path = require('path')\n \nconst buildEslintCommand = (filenames) =>\n  `next lint --fix --file ${filenames\n    .map((f) => path.relative(process.cwd(), f))\n    .join(' --file ')}`\n \nmodule.exports = {\n  '*.{js,jsx,ts,tsx}': [buildEslintCommand],\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"10-迁移现有配置",children:["10. 迁移现有配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-迁移现有配置",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"如果你已经有了单独的 ESLint 配置，并且想要保持原有的配置，那你可以基于目前的配置，直接从 Next.js ESLint 插件（eslint-plugin-next）中拓展规则："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"module.exports = {\n  extends: [\n    //...\n    'plugin:@next/next/recommended',\n  ],\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["或者是引入 ",(0,i.jsx)(n.code,{children:"eslint-config-next"}),"，不过确保它在其他配置项后，举个例子："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'// .eslintrc.json\n{\n  "extends": ["eslint:recommended", "next"]\n}\n'})}),"\n",(0,i.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/configuring/typescript",target:"_blank",rel:"noopener noreferrer",children:"Configuring: TypeScript | Next.js"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/configuring/eslint",target:"_blank",rel:"noopener noreferrer",children:"Configuring: ESLint | Next.js"})}),"\n"]})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}let j=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F29.%E9%85%8D%E7%BD%AE%E7%AF%87%20_%20TypeScript%20%E5%92%8C%20ESLint.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"TypeScript",id:"typescript",depth:2},{text:"1. 新项目",id:"1-新项目",depth:3},{text:"2. 现有项目",id:"2-现有项目",depth:3},{text:"3. TypeScript 插件",id:"3-typescript-插件",depth:3},{text:"4. 最低 TypeScript 版本要求",id:"4-最低-typescript-版本要求",depth:3},{text:"5. 静态写入链接",id:"5-静态写入链接",depth:3},{text:"6. next.config.js 中的类型检查",id:"6-nextconfigjs-中的类型检查",depth:3},{text:"7. 忽略 TypeScript 错误",id:"7-忽略-typescript-错误",depth:3},{text:"ESLint",id:"eslint",depth:2},{text:"1. ESLint 配置选项",id:"1-eslint-配置选项",depth:3},{text:"2. ESLint 配置",id:"2-eslint-配置",depth:3},{text:"3. ESLint 插件",id:"3-eslint-插件",depth:3},{text:"4. 自定义应用目录",id:"4-自定义应用目录",depth:3},{text:"5. 自定义检查目录和文件",id:"5-自定义检查目录和文件",depth:3},{text:"6. 缓存",id:"6-缓存",depth:3},{text:"7. 禁用规则",id:"7-禁用规则",depth:3},{text:"8. core-web-vitals",id:"8-core-web-vitals",depth:3},{text:"9. 搭配其他工具",id:"9-搭配其他工具",depth:3},{text:"9.1. prettier",id:"91-prettier",depth:4},{text:"9.2. lint-staged",id:"92-lint-staged",depth:4},{text:"10. 迁移现有配置",id:"10-迁移现有配置",depth:3},{text:"参考链接",id:"参考链接",depth:2}],title:"29.配置篇 _ TypeScript 和 ESLint",headingTitle:"29.配置篇 _ TypeScript 和 ESLint",frontmatter:{}}}}]);