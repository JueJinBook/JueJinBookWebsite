"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["36823"],{514192:function(n,e,i){n.exports=i.p+"static/image/ac074c7277d122dce78523c5e013eba5.8a08d3f8.gif"},830024:function(n,e,i){i.r(e),i.d(e,{default:()=>q});var a=i(552676),t=i(740453);let s=i.p+"static/image/80d04798aa83643326dc398c9659a269.827c7abc.gif",r=i.p+"static/image/2cd0e6d84dee54900994eae5a82e20c7.55dc320f.gif",c=i.p+"static/image/74b61da1cd767b31f6d0a1ced4919560.dd0ba62f.webp",d=i.p+"static/image/c6fa4246ea280d0948b0d6ce346353bd.859749f6.gif",p=i.p+"static/image/94d8dfe516acc1b68468ad405c2471d9.cb404387.webp",l=i.p+"static/image/9139207682d9907d5bd742966f7cbb33.6006c6c0.webp",o=i.p+"static/image/836827936c8d58ee60d27eea026add5a.5531fb5d.webp",x=i.p+"static/image/b6230354d4a80cdd1b6e08ddb70c9fe7.f4cd9d54.gif",m=i.p+"static/image/0add5b8a33475d44ab82b639ec8e6873.eafb1bd0.gif",g=i.p+"static/image/d03ed0330530035bf493a6c190904339.446eb6a6.webp",h=i.p+"static/image/4ff57bc2f23792488e8df2a53c3f613e.72a796ae.gif",j=i.p+"static/image/b5683f7a61f5ebf3998db8b7f7122a08.43abe258.gif",f=i.p+"static/image/ef881f222002ee6e89b5b989df7a0942.e8ec4a0b.webp",u=i.p+"static/image/653362e9f3692b0aea6496119b5358c9.35b45951.gif",b=i.p+"static/image/3a9ad3e15e2afbb7796a8f362b23c94f.a12aac6e.gif",v=i.p+"static/image/24dad8afcb5767ac24ccf172dce255a5.678c99a5.webp",S=i.p+"static/image/d7537534e745ce141f97d88a3d2586d1.066fe0c9.gif",w=i.p+"static/image/394275fd25fd141663d99be6393700ba.883da9c3.webp",T=i.p+"static/image/f87d61ee5511a5009032bcd5ba341b36.113c4515.webp",y=i.p+"static/image/82f89d80d118f57a04d2b53e9deb6692.575c81c7.webp",k=i.p+"static/image/a981f5a7ddd6bbe7265b12754a5d5188.5900cbde.webp",A=i.p+"static/image/9197bcf4fca2188aa444893298c09181.8266bd10.webp",N=i.p+"static/image/3c552190106469302e56822e0fb1a881.72b10edb.webp",C=i.p+"static/image/47d6aa8f0a3fc2fedaf80ff4fd827b92.d9dc1ed7.webp",E=i.p+"static/image/5a5f989f7f5ca99a2478f1642c6cd2d1.116bc09a.webp",R=i.p+"static/image/27f9e3571bf1959dc52e11f6cda4e9e6.435bbd22.webp";var _=i(514192);let P=i.p+"static/image/322d9522b5803da790428b0b78fa2b75.1db5a6c4.webp",G=i.p+"static/image/c9ecbb65c20cef5606a4aa129f4458fd.1f6c5e2b.gif",X=i.p+"static/image/bcad0e6f3e286ba13aa2f857344855fc.9ad3e5f9.webp",F=i.p+"static/image/91c8e83c954b6ea86625a9d34e518182.6bea7f2b.webp",B=i.p+"static/image/ffdd2203de1531a5bcf67ce38a90da0c.16b2e914.webp",I=i.p+"static/image/5ef72be4f7ed62a484f187a7971e87bf.ac6a6e93.webp",D=i.p+"static/image/d7f0edcf73e5f9ab266af5318a60fb32.fadc7a20.webp",M=i.p+"static/image/e87bf27dce7d99dcbf453f574a7b4e94.78a1e016.webp",O=i.p+"static/image/23e63cef1a5667f69666c82154e74f43.3cfc0385.webp",z=i.p+"static/image/4f03ce3941661f1a09b88c173810c165.2e405772.webp";function J(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li"},(0,t.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"第25章用react-transition-group和react-spring做过渡动画",children:["第25章—用react-transition-group和react-spring做过渡动画",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第25章用react-transition-group和react-spring做过渡动画",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"\uFEFF前面我们学了用 react-spring 做属性变化的动画，以及和 use-gesture 手势库结合做一些交互触发的动画。"}),"\n",(0,a.jsx)(e.p,{children:"其实还有一种动画类型没有涉及，就是过渡动画。"}),"\n",(0,a.jsx)(e.p,{children:"过渡动画是当元素进入、离开的时候（也就是添加到 dom 和从 dom 移除的时候）触发的动画。"}),"\n",(0,a.jsx)(e.p,{children:"比如这个："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:G,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"有同学说，上节不是做过这个么？"}),"\n",(0,a.jsx)(e.p,{children:"不一样，上节我们是一个列表里多个元素根据 index 计算 x，多个元素同时存在。"}),"\n",(0,a.jsx)(e.p,{children:"而这个是只存在一个，切换的时候其余元素会添加到 dom 和从 dom 中移除，从而触发进入、离开的过渡动画。"}),"\n",(0,a.jsx)(e.p,{children:"我们来写一下就知道了。"}),"\n",(0,a.jsx)(e.p,{children:"创建个项目："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:z,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"安装 react-spring 的包："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-shell",children:"npm install --save @react-spring/web\n"})}),"\n",(0,a.jsx)(e.p,{children:"改下 App.tsx："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import React, { useState, CSSProperties } from 'react'\nimport { useTransition, animated, AnimatedProps } from '@react-spring/web'\n\nimport './App.css';\n\ninterface PageItem {\n  (props: AnimatedProps<{ style: CSSProperties }>): React.ReactElement\n}\n\nconst pages: Array<PageItem> = [\n  ({ style }) => <animated.div style={{ ...style, background: 'lightpink' }}>A</animated.div>,\n  ({ style }) => <animated.div style={{ ...style, background: 'lightblue' }}>B</animated.div>,\n  ({ style }) => <animated.div style={{ ...style, background: 'lightgreen' }}>C</animated.div>,\n]\n\nexport default function App() {\n  const [index, set] = useState(0);\n\n  const onClick = () => set(state => (state + 1) % 3);\n\n  const transitions = useTransition(index, {\n    from: { transform: 'translate3d(100%,0,0)' },\n    enter: { transform: 'translate3d(0%,0,0)' },\n    leave: { transform: 'translate3d(-100%,0,0)' },\n  })\n\n\n  return (\n    <div className='container' onClick={onClick}>\n      {transitions((style, i) => {\n        const Page = pages[i]\n        return <Page style={style} />\n      })}\n    </div>\n  )\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"从上往下来看。"}),"\n",(0,a.jsx)(e.p,{children:"pages 是一个数组，接收 style 作为参数，返回 ReactElement。"}),"\n",(0,a.jsx)(e.p,{children:"这个 style 是被 react-spring 处理过后的 style，所以是 AnimatedProps 类型："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:O,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"不是都用 ReactNode 来表示 JSX 么，为什么这里用 ReactElement？"}),"\n",(0,a.jsx)(e.p,{children:"讲 react 的 ts 类型的时候，讲过 ReactNode 包括 ReactElement 类型还包括 string、number 等类型："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:M,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"但是这里要把 pages 的元素作为 ReactElement 来用，而 string、number 等都是不可以的，所以不能写 ReactNode："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:D,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"然后我们声明了一个 index 的 state，在点击的时候修改了它："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:I,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"而渲染的时候只渲染这一个，之前渲染的组件就会被销毁，从而触发过渡动画："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:B,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这是和上节那个类似效果的区别，上节那个并不是同时只保留一个，所以不是过渡动画。"}),"\n",(0,a.jsx)(e.p,{children:"然后这里用到了 useTransition，它的第一个参数就是会变化的状态，当状态变化的时候就会触发进入、离开动画："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:F,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"分别指定了初始状态（from），进入的时候（enter），离开的时候（leave）会变化的 style。"}),"\n",(0,a.jsx)(e.p,{children:"这样，当 index 变化的时候，这些 style 就会变，从而触发动画："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:X,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"在 App.css 写下样式："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:".container > div {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  color: white;\n  font-weight: 800;\n  font-size: 300px;\n}\n\n"})}),"\n",(0,a.jsx)(e.p,{children:"跑一下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"npm run start\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:G,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"没啥问题。"}),"\n",(0,a.jsx)(e.p,{children:"但这只是一个元素的过渡动画，如果多个元素呢？"}),"\n",(0,a.jsx)(e.p,{children:"新建 App2.tsx"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'import React, { useState } from "react";\nimport "./App2.css";\nimport { useTransition, animated } from \'@react-spring/web\'\n\nexport default function App() {\n  const [items, setItems] = useState([\n    { id: 1, text: "guang" },\n    { id: 2, text: "guang" },\n  ]);\n\n  const transitions = useTransition(items, {\n    from: { transform: \'translate3d(100%,0,0)\', opacity: 0 },\n    enter: { transform: \'translate3d(0%,0,0)\', opacity: 1 },\n    leave: { transform: \'translate3d(-100%,0,0)\', opacity: 0 },\n  });\n\n  return (\n    <div>\n      <div className="item-box">\n        {transitions((style, i) => {\n          return <animated.div className="item" style={style}>\n            <span\n              className="del-btn"\n              onClick={() => {\n                setItems(items.filter((item) => item.id !== i.id));\n              }}\n            >\n              x\n            </span>\n            {i.text}\n          </animated.div>\n        })}\n      </div>\n\n      <div\n        className="btn"\n        onClick={() => {\n          setItems([...items, { id: Date.now(), text:  \'guang\' }]);\n        }}\n      >\n        Add\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"还有 App2.css"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".item-box {\n    width: 300px;\n    margin: 20px auto;\n}\n\n.item {\n    margin: 4px 0;\n    padding: 10px 0;\n    border-radius: 4px;\n    background: lightblue;\n}\n\n.del-btn {\n    padding: 0 10px;\n    cursor: pointer;\n    user-select: none;\n}\n\n.btn {\n    color: #fff;\n    background-color: #0069d9;\n    border-color: #0062cc;\n    padding: 10px 20px;\n    border-radius: 4px;\n    width: fit-content;\n    cursor: pointer;\n    margin: 20px auto;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"引入这个组件跑一下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:P,alt:""})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)("img",{src:_,alt:""}),"\n可以看到，每个元素都加上了过渡动画。"]}),"\n",(0,a.jsx)(e.p,{children:"回过头来看下代码："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:R,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:E,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:C,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"列表项的增删就不详述了。"}),"\n",(0,a.jsx)(e.p,{children:"useTransition 多个元素的时候，你会发现和之前一模一样："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:N,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:A,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"useTransition 传单个数据就是单个元素的过渡动画、传数组就是多个元素的过渡动画，写法一样。"}),"\n",(0,a.jsx)(e.p,{children:"此外，现在是刚开始所有元素会做一次动画："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"如果我只是想在增删元素的时候才有动画呢？"}),"\n",(0,a.jsx)(e.p,{children:"设置下 initial 时的样式就可以了："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"const transitions = useTransition(items, {\n    initial: { transform: 'translate3d(0%,0,0)', opacity: 1 },\n    from: { transform: 'translate3d(100%,0,0)', opacity: 0 },\n    enter: { transform: 'translate3d(0%,0,0)', opacity: 1 },\n    leave: { transform: 'translate3d(-100%,0,0)', opacity: 0 },\n});\n"})}),"\n",(0,a.jsx)(e.p,{children:"这样最开始就不会做一次动画，只有在增删元素的时候会触发过渡动画："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这就是用 react-spring 的 useTransition 做过渡动画的方式。"}),"\n",(0,a.jsx)(e.p,{children:"此外，最好加上 keys，react-spring 会根据这个来添加 key，从而识别出元素的增删："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:k,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"其实提到过渡动画，还有一个老牌的库 react-transition-group。"}),"\n",(0,a.jsx)(e.p,{children:"这个库是 react 官方出的，而且用的也很多。"}),"\n",(0,a.jsx)(e.p,{children:"看 npm 包的周下载量："}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.a,{href:"https://www.npmjs.com/package/react-transition-group",target:"_blank",rel:"noopener noreferrer",children:"react-transition-group"})," 的周下载量："]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:y,alt:""})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.a,{href:"https://www.npmjs.com/package/@react-spring/web",target:"_blank",rel:"noopener noreferrer",children:"@react-spring/web"})," 的周下载量："]}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:T,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"好家伙，10 倍的差距。"}),"\n",(0,a.jsx)(e.p,{children:"这并不是说 react-transition-group 做过渡动画更优秀，只是它出现的更早更加流行。"}),"\n",(0,a.jsx)(e.p,{children:"我们来试一下："}),"\n",(0,a.jsx)(e.p,{children:"安装 react-transition-group："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-shell",children:"npm install --save react-transition-group\n\nnpm install --save-dev @types/react-transition-group\n"})}),"\n",(0,a.jsx)(e.p,{children:"不同于 react-spring 是在组件 enter、leave 的时候直接修改 style。"}),"\n",(0,a.jsx)(e.p,{children:"react-transition-group 是通过改变 className 来给组件加上的过渡效果的。"}),"\n",(0,a.jsx)(e.p,{children:"创建 App3.tsx："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react';\nimport { CSSTransition } from 'react-transition-group';\nimport './App3.css';\n \nfunction App() {\n  const [flag, setFlag] = useState(false);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setFlag(true);\n    }, 3000);\n  }, []);\n\n  return <CSSTransition\n    in={flag}\n    timeout={1000}\n  >\n    <div id=\"box\"></div>\n  </CSSTransition>\n}\n\nexport default App;\n"})}),"\n",(0,a.jsx)(e.p,{children:"App3.css"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:"#box {\n    width: 300px;\n    height: 50px;\n    background: lightblue; \n    margin: 200px auto;\n}\n\n.enter {\n    transform: translateX(-100%);\n    opacity: 0;\n}\n\n.enter-active {\n    transform: translateX(0);\n    opacity: 1;\n\n    transition: all 1s ease;\n}\n\n.enter-done {\n    border: 5px solid #000;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"参数 in 设置为 true 就是触发进入的动画，设置为 false 就是触发离开的动画。"}),"\n",(0,a.jsx)(e.p,{children:"跑一下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:w,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:S,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，当 in 变为 true 的时候，会触发进入的动画，依次给元素加上 .enter、.enter-active、.enter-done 的 className。"}),"\n",(0,a.jsx)(e.p,{children:"这样，我们就把过渡的样式加到这三个 className 里就可以了。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:v,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"而且不同于 react-spring 会自己控制动画效果，react-transition-group 只是加上 className 不负责动画效果，需要添加 transition 来实现动画。"}),"\n",(0,a.jsx)(e.p,{children:"CSSTransition 组件会先设置 enter，再设置 enter-active，这样就触发动画了。"}),"\n",(0,a.jsx)(e.p,{children:"然后到了 timeout 参数的时间，就会设置 enter-done 的 className。"}),"\n",(0,a.jsx)(e.p,{children:"反之，如果 in 的参数改为 false，就会触发离开动画："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"className 会先设置 exit，再设置 exit-active 来触发动画，到了 timeout 的时间会设置为 exit-done。"}),"\n",(0,a.jsx)(e.p,{children:"连起来，就可以实现 enter 和 exit 的动画："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react';\nimport { CSSTransition } from 'react-transition-group';\nimport './App3.css';\n \nfunction App() {\n  const [flag, setFlag] = useState(false);\n\n  return <div>\n    <CSSTransition\n      in={flag}\n      timeout={1000}\n    >\n      <div id=\"box\"></div>\n    </CSSTransition>\n    <button onClick={() => setFlag(!flag)}>{!flag ?  '进入' : '离开'}</button>\n  </div>\n}\n\nexport default App;\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:"#box {\n  width: 300px;\n  height: 50px;\n  background: lightblue; \n  margin: 100px auto;\n}\n\nbutton {\n  margin: 0 auto;\n  display: block;\n}\n\n.enter {\n  transform: translateX(-100%);\n  opacity: 0;\n}\n\n.enter-active {\n  transform: translateX(0);\n  opacity: 1;\n\n  transition: all 1s ease;\n}\n\n.enter-done {\n  border: 5px solid #000;\n}\n\n.exit {\n  transform: translateX(0%);\n  opacity: 1;\n}\n\n.exit-active {\n  transform: translateX(100%);\n  opacity: 0;\n\n  transition: all 1s ease;\n}\n\n.exit-done {\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，通过 className 从 enter 到 enter-active 到 enter-done 的变化，以及从 exit 到 exit-active 到 exit-done 的变化，就实现了进入和离开的动画。"}),"\n",(0,a.jsx)(e.p,{children:"不知道大家有没有发现，最开始出现的时候是没有动画的，之后后来切换 in 的 props 的时候，才有动画。"}),"\n",(0,a.jsx)(e.p,{children:"如果想最开始出现的时候就做一次动画呢？"}),"\n",(0,a.jsx)(e.p,{children:"这就需要设置 appear 的 props 了："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:f,alt:""})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".appear {\n  transform: scale(0);\n}\n\n.appear-active {\n  transform: scale(1);\n  transition: all 1s ease;\n}\n\n.appear-done {\n  \n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:j,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，最开始还有一个 appear、appear-active、appear-done 的 className 变化，并且还会添加 enter-done。"}),"\n",(0,a.jsx)(e.p,{children:"这个只会在刚出现的时候设置一次。"}),"\n",(0,a.jsx)(e.p,{children:"也就是一共可以有 appear、enter、exit 3 种过渡动画。"}),"\n",(0,a.jsx)(e.p,{children:"这个在 react-spring 里也是一样，它默认是有 appear 动画的："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"我们当时是设置了 initial 时的样式，然后就没有 apear 动画了："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"也就是说用 react-spring 和 react-transition-group 都能实现一样的过渡动画的功能。"}),"\n",(0,a.jsx)(e.p,{children:"而且 react-transition-group 只是添加 className 要自己用 transition 来做动画，而 react-spring 是自带动画效果。"}),"\n",(0,a.jsx)(e.p,{children:"继续看 react-transition-group，现在是我们自己设置 in 的 props 来触发进入和离开动画的，如果是列表的多个 child，都想加动画呢？"}),"\n",(0,a.jsx)(e.p,{children:"这时候就用 TransitionGrop 组件。"}),"\n",(0,a.jsx)(e.p,{children:"创建 App4.tsx"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'import React, { useState } from "react";\nimport { CSSTransition, TransitionGroup } from "react-transition-group";\nimport "./App4.css";\n\nexport default function App() {\n  const [items, setItems] = useState([\n    { id: 1, text: "guang" },\n    { id: 2, text: "guang" },\n  ]);\n\n  return (\n    <div>\n      <TransitionGroup className="item-box">\n        {items.map(({ id, text }) => (\n          <CSSTransition key={id} timeout={1000}>\n            <div className="item">\n              <span\n                className="del-btn"\n                onClick={() => {\n                  setItems(items.filter((item) => item.id !== id));\n                }}\n              >\n                x\n              </span>\n              {text}\n            </div>\n          </CSSTransition>\n        ))}\n      </TransitionGroup>\n\n      <div\n        className="btn"\n        onClick={() => {\n          setItems([...items, { id: Date.now(), text:  \'guang\' }]);\n        }}\n      >\n        Add\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(e.p,{children:"就是用 TransitionGroup 包裹下，"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".item-box {\n  width: 300px;\n  margin: 20px auto;\n}\n\n.item {\n  margin: 4px 0;\n  padding: 10px 0;\n  border-radius: 4px;\n  background: lightblue;\n}\n\n.del-btn {\n  padding: 0 10px;\n  cursor: pointer;\n  user-select: none;\n}\n\n.enter {\n  opacity: 0;\n  transform: translateX(-100%);\n  background: lightblue;\n}\n.enter-active {\n  opacity: 1;\n  transform: translateX(0%);\n  background: lightblue;\n  transition: all 1s ease;\n\n}\n.enter-done {\n}\n.exit {\n  opacity: 1;\n  transform: translateX(0%);\n  background: red;\n}\n.exit-active {\n  opacity: 0;\n  transform: translateX(100%);\n  background: red;\n  transition: all 1s ease;\n}\n\n.btn {\n  color: #fff;\n  background-color: #0069d9;\n  border-color: #0062cc;\n  padding: 10px 20px;\n  border-radius: 4px;\n  width: fit-content;\n  cursor: pointer;\n  margin: 20px auto;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"效果就是前面用 react-spring 实现过一遍的那个："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"用 CSSTransition 的时候，我们需要自己设置 in 的 props 来触发进入和离开动画。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"而现在只需要设置 key，TransitionGroup 会在 children 变化的时候对比新旧 item，来自动设置 in，触发动画。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这就是 react-transition-group 的常用功能。"}),"\n",(0,a.jsx)(e.p,{children:"此外，它还有两个组件，Transition 和 SwitchTransition："}),"\n",(0,a.jsx)(e.p,{children:"把 CSSTransition 换成 Transition，然后打印下 status："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，status 最开始是从 entering 到 entered，从 exiting 到 exited 变化，但是不会设置 className："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"我们可以根据 status 的变化自己设置 className。"}),"\n",(0,a.jsx)(e.p,{children:"其实，CSSTransition 就是基于 Transition 封装的。"}),"\n",(0,a.jsx)(e.p,{children:"一般我们用 CSSTransition 就好了。"}),"\n",(0,a.jsx)(e.p,{children:"再就是 SwithTransition，先看下效果："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"包裹一层 SwitchTransition，然后设置下 key。"}),"\n",(0,a.jsx)(e.p,{children:"当 mode 为 in-out 时："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:r,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"当 mode 为 out-in 时："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:s,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这个组件就是用来控制两个组件切换时的进入、离开动画的顺序的。"}),"\n",(0,a.jsx)(e.p,{children:"这样，react-transition-group 的 4 个组件： Transition、CSSTransition、TransitionGroup、SwitchTransition 我们就都过了一遍。"}),"\n",(0,a.jsxs)(e.p,{children:["案例代码上传了",(0,a.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/transition-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,a.jsxs)(e.h2,{id:"总结",children:["总结",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"当组件进入 dom 和从 dom 中移除的时候，发生的动画就叫做过渡动画。"}),"\n",(0,a.jsx)(e.p,{children:"react-spring 有 useTransition 这个 hook 来实现过渡动画，我们也可以用 react-trasition-group 这个包来实现。"}),"\n",(0,a.jsx)(e.p,{children:"这两个包能实现一样的功能，但是思路不同。"}),"\n",(0,a.jsx)(e.p,{children:"react-spring 有内置的动画效果，所以只要用 useTransition 设置 from、enter、leave 时的 style，它就会在数据变化的时候触发过渡动画。"}),"\n",(0,a.jsx)(e.p,{children:"而 react-transition-group 是通过 className 的修改来实现过渡动画，而且要自己用 transition 的 css 来控制动画效果："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"进入的时候会触发 enter、enter-active、enter-done 的 className 切换"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"离开的时候是 exit、exit-active、exit-done 的切换"}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["\n",(0,a.jsx)(e.p,{children:"如果设置了 appear 参数，刚出现的时候，还会有 appear、appear-active、appear-done 的切换。"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"它有 Transition、CSSTransition、TransitionGroup、SwitchTransition 这 4 个组件。"}),"\n",(0,a.jsx)(e.p,{children:"常用的就是 CSSTransition 和 TransitionGroup，这俩是用来做单个元素的过渡动画和多个元素的过渡动画的。"}),"\n",(0,a.jsx)(e.p,{children:"而在 react-spring 里，单个元素的过渡动画和多个元素的过渡动画写法没区别。"}),"\n",(0,a.jsx)(e.p,{children:"具体用哪种方案来实现过渡动画都行，都是很流行的方案。"})]})}function Q(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(J,{...n})}):J(n)}let q=Q;Q.__RSPRESS_PAGE_META={},Q.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC25%E7%AB%A0%E2%80%94%E7%94%A8react-transition-group%E5%92%8Creact-spring%E5%81%9A%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第25章—用react-transition-group和react-spring做过渡动画",headingTitle:"第25章—用react-transition-group和react-spring做过渡动画",frontmatter:{}}}}]);