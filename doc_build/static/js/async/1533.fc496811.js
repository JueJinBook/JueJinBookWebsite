"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["1533"],{808112:function(e,n,a){e.exports=a.p+"static/image/a47907e7c6907a6045b7d164f5171070.ec863777.gif"},904216:function(e,n,a){e.exports=a.p+"static/image/b6b59d20e37947ca792972d6ade9c87b.b51b6764.gif"},431218:function(e,n,a){e.exports=a.p+"static/image/dd0a7e6fdf9dfc047e391bb784dcc63f.14295757.gif"},69292:function(e,n,a){a.r(n),a.d(n,{default:()=>q});var s=a(552676),t=a(740453);let i=a.p+"static/image/3cb1d442f6b2307f9574efed78a5907c.e24a6096.gif",c=a.p+"static/image/13eb56c31b136b33603880fa167e7272.e2e21767.webp",l=a.p+"static/image/893eca0c030b4603d0e3aa1b06af47e6.f1d12027.webp",r=a.p+"static/image/b9680adaac5653dd9f3d077ee5ca28f9.2227c6cb.webp";var d=a(904216);let p=a.p+"static/image/201e010b199c61e6c4866885ca842bd5.b9cb193e.webp",o=a.p+"static/image/783e3cc7d8706a5ddfbda36a36718301.e92cd731.webp",m=a.p+"static/image/0af4d18ec09e2e8de2047799db636f24.383582df.webp",x=a.p+"static/image/952cc435ea1e79ccfd8c7539f157e937.5fbefca8.gif",f=a.p+"static/image/c07cc33d2110cdc65909607e10720ae6.c39d9658.webp",g=a.p+"static/image/0cd9822683c491ea45f7519c68c93856.66b4fc60.webp",j=a.p+"static/image/25a8f0b9cb97350509bbdf247c8bd9fb.ba14cec1.webp",h=a.p+"static/image/674c3f7e86488d14700bd68fc9816a8c.4f2acf5f.webp",u=a.p+"static/image/2334c046e91239d4cc4d39eff9c7ab19.4e0fdbf2.gif",b=a.p+"static/image/c5f20190fa2446fb4dc3f55de14d48f9.ed6ce122.webp",v=a.p+"static/image/af4e6fd112d7969f160cbaa987cc40bc.e670c489.webp",N=a.p+"static/image/90de17dc0bb0db8a07222f5d33a989c3.9b88e6f3.webp",E=a.p+"static/image/247f889404859de72a42cbe7b9065b4f.51e5f46e.gif",C=a.p+"static/image/a7010b36feec844b5576cd631fe9abdf.e796a45c.gif",F=a.p+"static/image/0a2914f9766f419258cc3616ffedf35c.ac9e0f24.gif",y=a.p+"static/image/0d7dbc9f0bf5919cc8d97f324b7875ae.a1191c43.webp",k=a.p+"static/image/bcdebf5d315b628e16feaf03b62fc0d5.9cfe53db.gif",R=a.p+"static/image/02a162f8f9f9a955f9b35f47108126a7.f6422d2f.webp",w=a.p+"static/image/418eb51c606c82d0c7c2e32d23f2b1e8.e2ae8ce9.webp",P=a.p+"static/image/1b4abea601f51bb29fd178e70af470d7.d8021291.gif",I=a.p+"static/image/045ca048c916dfb6c5c85638d6a3c898.9797ba92.webp",A=a.p+"static/image/6a1376d592a4c906a279e284cce7ba9a.440213d2.gif",S=a.p+"static/image/d1ef85c33f3671d59c9521a9c697f5e6.dd5c6d30.webp",_=a.p+"static/image/f62be8fc4a87a491de5c09e519a7e65f.563fa802.gif",T=a.p+"static/image/842d3e714cd28fabe008a3526f0ab8c1.28253f0a.webp",B=a.p+"static/image/cd256a28ff548e2ad75f5d05fa04cf16.2f53b8be.webp",M=a.p+"static/image/f8bacb43064bd3ac881107334a32d049.fd5614e0.webp",L=a.p+"static/image/ece609994e9e0336a61af13c5cd29d45.e1a458c7.gif",D=a.p+"static/image/92f1e266de208166a38f21767d1bc1db.75982d15.webp",O=a.p+"static/image/887dcef7568881a7c7b0fcee4949154e.78ebbfc4.gif",H=a.p+"static/image/a25dfe762f9f06f72bffab71800d05c2.0c762e65.webp";var G=a(808112),z=a(431218);function Y(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"第57章reactplayground项目实战文件增删改",children:["第57章—ReactPlayground项目实战：文件增删改",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第57章reactplayground项目实战文件增删改",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"\uFEFF我们实现了多个文件的编辑、编译、预览，整体流程已经跑通了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:z,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但是文件的新增、删除、文件名修改还没做："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:G,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这节来实现下。"}),"\n",(0,s.jsx)(n.p,{children:"改下 FileNameItem："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:H,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"创建一个 editing 的 state 来记录编辑状态，然后用 ref 来保存 input 的引用。"}),"\n",(0,s.jsx)(n.p,{children:"双击文件名的时候，切换到编辑状态，然后聚焦输入框。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import classnames from 'classnames'\nimport React, { useState, useRef, useEffect } from 'react'\n\nimport styles from './index.module.scss'\n\nexport interface FileNameItemProps {\n    value: string\n    actived: boolean\n    onClick: () => void\n}\n\nexport const FileNameItem: React.FC<FileNameItemProps> = (props) => {\n  const {\n    value,\n    actived = false,\n    onClick,\n  } = props\n\n  const [name, setName] = useState(value);\n  const [editing, setEditing] = useState(false)\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  const handleDoubleClick = () => {\n    setEditing(true)\n    setTimeout(() => {\n      inputRef?.current?.focus()\n    }, 0)\n  }\n\n  return (\n    <div\n      className={classnames(styles['tab-item'], actived ? styles.actived : null)}\n      onClick={onClick}\n    >\n        {\n            editing ? (\n                <input\n                    ref={inputRef}\n                    className={styles['tabs-item-input']}\n                    value={name}\n                    onChange={(e) => setName(e.target.value)}\n                />\n            ) : (\n                <span onDoubleClick={handleDoubleClick}>{name}</span>\n            )\n        }\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"试下效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后 blur 的时候，切换为非编辑状态："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const hanldeInputBlur = () => {\n    setEditing(false);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:L,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"当然，这里应该去修改 files 里的文件名。"}),"\n",(0,s.jsx)(n.p,{children:"我们在 FileNameList 组件里做这个，这里加一个回调函数："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后在 FileNameList 组件传入："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"修改文件名，并切换 selectedFileName 为新的文件名。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useContext, useEffect, useState } from "react"\nimport { PlaygroundContext } from "../../../PlaygroundContext"\n\nimport { FileNameItem } from "./FileNameItem"\nimport styles from \'./index.module.scss\'\n\nexport default function FileNameList() {\n    const { \n        files, \n        removeFile, \n        addFile, \n        updateFileName, \n        selectedFileName,\n        setSelectedFileName\n    } = useContext(PlaygroundContext)\n\n    const [tabs, setTabs] = useState([\'\'])\n\n    useEffect(() => {\n        setTabs(Object.keys(files))\n    }, [files])\n\n    const handleEditComplete = (name: string, prevName: string) => {\n        updateFileName(prevName, name);\n        setSelectedFileName(name);\n    }\n\n    return <div className={styles.tabs}>\n        {\n            tabs.map((item, index) => (\n                <FileNameItem \n                    key={item + index}  \n                    value={item} \n                    actived={selectedFileName === item} \n                    onClick={() => setSelectedFileName(item)}\n                    onEditComplete={(name: string) => handleEditComplete(name, item)}\n                >\n                </FileNameItem>\n            ))\n        }\n    </div>\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"之前我们在 context.Provider 里注入了这个方法："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"它会在 files 里查找旧的 file 信息，去掉后换成新的。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，修改完之后文件跑后面去了，这个是因为我们插入新 file 的时候就是往后面插入的。"}),"\n",(0,s.jsx)(n.p,{children:"然后修改完右面白屏了，打开 devtools 可以看到报错："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"因为 App.tsx 文件改名了，那 main.tsx 里引用的路径也得改下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样，修改文件名的功能就完成了。"}),"\n",(0,s.jsx)(n.p,{children:"我们再来写下样式:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:I,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:".tabs-item-input {\n    width: 90px;\n    padding: 4px 0 4px 10px;\n    font-size: 13px;\n\n    color: #444;\n    background-color: #ddd;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    outline: none;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"就是设置下 width、padding、背景色、border 就好了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"好看多了。"}),"\n",(0,s.jsx)(n.p,{children:"接下来实现下新增 file 功能："}),"\n",(0,s.jsx)(n.p,{children:"新增其实和修改差不多，完全可以复用之前的逻辑。"}),"\n",(0,s.jsx)(n.p,{children:"我们加一个 creating 参数："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样就可以由父组件来控制哪个 tab 是编辑状态。"}),"\n",(0,s.jsx)(n.p,{children:"props.creating 为 true 的时候让 input 聚焦"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"useEffect(() => {\n    if(creating) {\n        inputRef?.current?.focus()\n    }\n}, [creating]);\n"})}),"\n",(0,s.jsx)(n.p,{children:"比如我们让最后一个 tab 是编辑状态："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，现在不用双击也是编辑文件名的状态："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们添加一个 + 按钮"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"创建一个 creating 的 state 来保存创建状态。"}),"\n",(0,s.jsx)(n.p,{children:"点击 + 按钮的时候进入创建状态，添加一个 file，文件名随机，然后把最后一个 tab 变为编辑状态。"}),"\n",(0,s.jsx)(n.p,{children:"编辑完把 creating 变为 false。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useContext, useEffect, useState } from \"react\"\nimport { PlaygroundContext } from \"../../../PlaygroundContext\"\n\nimport { FileNameItem } from \"./FileNameItem\"\nimport styles from './index.module.scss'\n\nexport default function FileNameList() {\n    const { \n        files, \n        removeFile, \n        addFile, \n        updateFileName, \n        selectedFileName,\n        setSelectedFileName\n    } = useContext(PlaygroundContext)\n\n    const [tabs, setTabs] = useState([''])\n\n    useEffect(() => {\n        setTabs(Object.keys(files))\n    }, [files])\n\n    const handleEditComplete = (name: string, prevName: string) => {\n        updateFileName(prevName, name);\n        setSelectedFileName(name);\n\n        setCreating(false);\n    }\n\n    const [creating, setCreating] = useState(false);\n\n    const addTab = () => {\n        const newFileName = 'Comp' + Math.random().toString().slice(2,8) + '.tsx';\n        addFile(newFileName);\n        setSelectedFileName(newFileName);\n        setCreating(true)\n    }\n\n    return <div className={styles.tabs}>\n        {\n            tabs.map((item, index, arr) => (\n                <FileNameItem \n                    key={item + index}  \n                    value={item} \n                    creating={creating && index === arr.length - 1}\n                    actived={selectedFileName === item} \n                    onClick={() => setSelectedFileName(item)}\n                    onEditComplete={(name: string) => handleEditComplete(name, item)}\n                >\n                </FileNameItem>\n            ))\n        }\n        <div className={styles.add} onClick={addTab}>\n            +\n        </div>\n    </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:F,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,s.jsx)(n.p,{children:"而且 tsx、css 等语法都能正确的高亮和提示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"因为我们 addFile 的时候已经做了处理："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"最后还剩下个删除，这个比较简单。"}),"\n",(0,s.jsx)(n.p,{children:"在 FileNameItem 组件，文件名的右边用 svg 画一个 x"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"点击的时候回调 onRemove 参数"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import classnames from 'classnames'\nimport React, { useState, useRef, useEffect } from 'react'\n\nimport styles from './index.module.scss'\n\nexport interface FileNameItemProps {\n    value: string\n    actived: boolean\n    creating: boolean\n    onEditComplete: (name: string) => void\n    onRemove: MouseEventHandler\n    onClick: () => void\n}\n\nexport const FileNameItem: React.FC<FileNameItemProps> = (props) => {\n  const {\n    value,\n    actived = false,\n    creating,\n    onClick,\n    onRemove,\n    onEditComplete,\n  } = props\n\n  const [name, setName] = useState(value);\n  const [editing, setEditing] = useState(creating)\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  const handleDoubleClick = () => {\n    setEditing(true)\n    setTimeout(() => {\n      inputRef?.current?.focus()\n    }, 0)\n  }\n\n  useEffect(() => {\n    if(creating) {\n        inputRef?.current?.focus()\n    }\n  }, [creating]);\n\n  const hanldeInputBlur = () => {\n    setEditing(false);\n    onEditComplete(name);\n  }\n\n  return (\n    <div\n      className={classnames(styles['tab-item'], actived ? styles.actived : null)}\n      onClick={onClick}\n    >\n        {\n            editing ? (\n                <input\n                    ref={inputRef}\n                    className={styles['tabs-item-input']}\n                    value={name}\n                    onBlur={hanldeInputBlur}\n                    onChange={(e) => setName(e.target.value)}\n                />\n            ) : (\n                <>\n                    <span onDoubleClick={handleDoubleClick}>{name}</span>\n                    <span style={{ marginLeft: 5, display: 'flex' }} onClick={onRemove}>\n                        <svg width='12' height='12' viewBox='0 0 24 24'>\n                            <line stroke='#999' x1='18' y1='6' x2='6' y2='18'></line>\n                            <line stroke='#999' x1='6' y1='6' x2='18' y2='18'></line>\n                        </svg>\n                    </span>\n                </>\n            )\n        }\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 FileNameList 组件里处理下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"删除文件，并且把选中的文件名换成 main.tsx"}),"\n",(0,s.jsx)(n.p,{children:"注意，这里要阻止事件冒泡，不然会触发 item 的点击事件，切换 tab 到已经删除的文件。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"onRemove={(e) => {\n    e.stopPropagation();\n    handleRemove(item)\n}}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const handleRemove = (name: string) => {\n    removeFile(name)\n    setSelectedFileName(ENTRY_FILE_NAME)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,s.jsx)(n.p,{children:"这里 main.tsx 是不能被删除的，它是入口模块。"}),"\n",(0,s.jsx)(n.p,{children:"import-map.json 也是不能删除。"}),"\n",(0,s.jsx)(n.p,{children:"我们加一个 readonly 参数："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"非 readonly 状态才展示删除按钮。"}),"\n",(0,s.jsx)(n.p,{children:"同理，也是非 readonly 状态才可以双击编辑："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import classnames from 'classnames'\nimport React, { useState, useRef, useEffect, MouseEventHandler } from 'react'\n\nimport styles from './index.module.scss'\n\nexport interface FileNameItemProps {\n    value: string\n    actived: boolean\n    creating: boolean\n    readonly: boolean\n    onEditComplete: (name: string) => void\n    onRemove: MouseEventHandler\n    onClick: () => void\n}\n\nexport const FileNameItem: React.FC<FileNameItemProps> = (props) => {\n  const {\n    value,\n    actived = false,\n    readonly,\n    creating,\n    onClick,\n    onRemove,\n    onEditComplete,\n  } = props\n\n  const [name, setName] = useState(value);\n  const [editing, setEditing] = useState(creating)\n  const inputRef = useRef<HTMLInputElement>(null)\n\n  const handleDoubleClick = () => {\n    setEditing(true)\n    setTimeout(() => {\n      inputRef?.current?.focus()\n    }, 0)\n  }\n\n  useEffect(() => {\n    if(creating) {\n        inputRef?.current?.focus()\n    }\n  }, [creating]);\n\n  const hanldeInputBlur = () => {\n    setEditing(false);\n    onEditComplete(name);\n  }\n\n  return (\n    <div\n      className={classnames(styles['tab-item'], actived ? styles.actived : null)}\n      onClick={onClick}\n    >\n        {\n            editing ? (\n                <input\n                    ref={inputRef}\n                    className={styles['tabs-item-input']}\n                    value={name}\n                    onBlur={hanldeInputBlur}\n                    onChange={(e) => setName(e.target.value)}\n                />\n            ) : (\n                <>\n                    <span onDoubleClick={!readonly ? handleDoubleClick : () => {}}>{name}</span>\n                    {\n                        !readonly ? <span style={{ marginLeft: 5, display: 'flex' }} onClick={onRemove}>\n                            <svg width='12' height='12' viewBox='0 0 24 24'>\n                                <line stroke='#999' x1='18' y1='6' x2='6' y2='18'></line>\n                                <line stroke='#999' x1='6' y1='6' x2='18' y2='18'></line>\n                            </svg>\n                        </span> : null\n                    }\n                </>\n            )\n        }\n    </div>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后 main.tsx、App.tsx、import-map.json 我们就都设为 readonly 了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const readonlyFileNames = [ENTRY_FILE_NAME, IMPORT_MAP_FILE_NAME, APP_COMPONENT_FILE_NAME];\n"})}),"\n",(0,s.jsx)(n.p,{children:"试下效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，除了这三个文件外，其余文件名都是可以编辑和删除的。"}),"\n",(0,s.jsx)(n.p,{children:"然后，我们给删除加一个二次确认。"}),"\n",(0,s.jsx)(n.p,{children:"这里用 antd 的 Popconfirm 组件吧。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save antd\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"{\n    !readonly ? (\n        <Popconfirm\n            title=\"确认删除该文件吗？\"\n            okText=\"确定\"\n            cancelText=\"取消\"\n            onConfirm={(e) => {\n                e?.stopPropagation();\n                onRemove();\n            }}\n        >\n            <span style={{ marginLeft: 5, display: 'flex' }}>\n                <svg width='12' height='12' viewBox='0 0 24 24'>\n                    <line stroke='#999' x1='18' y1='6' x2='6' y2='18'></line>\n                    <line stroke='#999' x1='6' y1='6' x2='18' y2='18'></line>\n                </svg>\n            </span>\n        </Popconfirm>\n    ) : null\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"e.stopPropagation 在这里调用，父组件那里就不需要了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"（其实之前我们调用 e.stopPropagation 的位置就不对，应该是组件内处理完 stopPropagation 后再调用回调函数，而不是在父组件里 stopPropagation）"}),"\n",(0,s.jsx)(n.p,{children:"测试下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,s.jsx)(n.p,{children:"至此，我们文件增删改的功能就都完成了。"}),"\n",(0,s.jsx)(n.p,{children:"和前面实现的编译预览串联测试下："}),"\n",(0,s.jsx)(n.p,{children:"新建一个 Aaa.tsx 组件："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import './Aaa.css';\n\nfunction Aaa() {\n \n  return (\n    <>\n      <h1 id=\"guang\" onClick={() => alert(666)}>神说要有光</h1>\n    </>\n  )\n}\n\nexport default Aaa\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后创建用到的 Aaa.css"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"#guang {\n    background: pink;\n    font-size: 50px;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 App.tsx 里引入下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"看下效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,s.jsx)(n.p,{children:"和之前的编译、预览功能配合的很好。"}),"\n",(0,s.jsxs)(n.p,{children:["案例代码上传了",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/react-playground-project",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"，可以切换到这个 commit 查看："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"git reset --hard 1674a8f0021a06dd54dfdc56386928544ce609e5\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节我们实现了文件新增、修改、删除的功能。"}),"\n",(0,s.jsx)(n.p,{children:"主要是在 FileNameItem 组件里添加了 editing 的 state 来切换编辑状态，编辑状态下可以在 input 里修改名字，然后同步到 files 里。"}),"\n",(0,s.jsx)(n.p,{children:"并且还添加了 creating 的 props 来控制 editing 状态，新增的时候添加一个 file ，然后设置 creating 参数为 true 就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"删除就是从 files 里把对应文件名删除，然后切换到 main.tsx。"}),"\n",(0,s.jsx)(n.p,{children:"这些都是基于 context 里的 api 来实现的。"}),"\n",(0,s.jsx)(n.p,{children:"main.tsx、App.tsx、import-map.json 设置为 readonly，不可编辑和删除。"}),"\n",(0,s.jsx)(n.p,{children:"这样，文件增删改功能就完成了，和之前的编译、预览功能可以很好的配合。"})]})}function Q(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(Y,{...e})}):Y(e)}let q=Q;Q.__RSPRESS_PAGE_META={},Q.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC57%E7%AB%A0%E2%80%94ReactPlayground%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%9A%E6%96%87%E4%BB%B6%E5%A2%9E%E5%88%A0%E6%94%B9.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第57章—ReactPlayground项目实战：文件增删改",headingTitle:"第57章—ReactPlayground项目实战：文件增删改",frontmatter:{}}}}]);