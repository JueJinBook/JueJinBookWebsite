"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["71539"],{634755:function(e,n,c){c.r(n),c.d(n,{default:()=>a});var s=c(552676),d=c(740453);let r=c.p+"static/image/df5254d5691f21f0c5a3a31a249ed421.f90ec831.webp",l=c.p+"static/image/4708f1d9c799d79966bc36685359b1b8.bfb6195a.webp",i=c.p+"static/image/49f1479420ae25fcc3b4efa2ad050990.cbe59f5b.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h3:"h3",code:"code",img:"img",strong:"strong",pre:"pre",hr:"hr",table:"table",thead:"thead",tr:"tr",th:"th",h5:"h5",ul:"ul",li:"li",input:"input"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"18多包仓库多个仓库管理相同业务代码真让人头大啊",children:["18.多包仓库：多个仓库管理相同业务代码，真让人头大啊！",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18多包仓库多个仓库管理相同业务代码真让人头大啊",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"技术要点：Yarn、Learn"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["当一个仓库规模逐渐升级并拆分为多个模块时，使用",(0,s.jsx)(n.code,{children:"Monorepo"}),"的方式管理仓库再也适合不过了。这些模块通常在同一仓库中依赖其他不同模块, 同时不同模块间还会互相依赖, 那管理与组织这些依赖显然很重要。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"项目依赖"})}),"\n",(0,s.jsxs)(n.p,{children:["为了解决这些依赖关系，",(0,s.jsx)(n.code,{children:"lerna"}),"就此诞生。",(0,s.jsx)(n.code,{children:"lerna"}),"是一种",(0,s.jsx)(n.code,{children:"Monorepo"}),"解决方案，用于管理包括多个子包的仓库，可优化使用",(0,s.jsx)(n.code,{children:"Git"}),"与",(0,s.jsx)(n.code,{children:"Npm"}),"管理",(0,s.jsx)(n.code,{children:"多包仓库"}),"的工作流程。日常开发可在主仓库中管理多个模块，结合其他工具解决多个子包互相依赖的问题。本章将带领你",(0,s.jsx)(n.strong,{children:"基于Yarn与Lerna搭建多包仓库基建模板"}),"，将那些仓库内容出现关联的模块统一使用",(0,s.jsx)(n.code,{children:"Monorepo"}),"的方式管理起来，降低日常开发的沟通难度，提升仓库管理的便利性。"]}),"\n",(0,s.jsxs)(n.h3,{id:"背景monorepo仓库带来的收益",children:["背景：Monorepo仓库带来的收益",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#背景monorepo仓库带来的收益",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"lerna"}),"诞生于",(0,s.jsx)(n.code,{children:"babel"}),"的仓库管理模式中，因为",(0,s.jsx)(n.code,{children:"babel"}),"实在是太多模块了，甚至多到不可管理，就这样促使了",(0,s.jsx)(n.code,{children:"lerna"}),"的诞生。像平时使用的",(0,s.jsx)(n.code,{children:"angular"}),"、",(0,s.jsx)(n.code,{children:"react"}),"、",(0,s.jsx)(n.code,{children:"vue"}),"、",(0,s.jsx)(n.code,{children:"jest"}),"等，其仓库都使用",(0,s.jsx)(n.code,{children:"lerna"}),"管理。"]}),"\n",(0,s.jsx)(n.p,{children:"打开它们的仓库，无一例外都是以下目录结构。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-txt",children:"project\n├─ lib1\n│  ├─ src\n│  └─ package.json\n├─ lib2\n│  ├─ src\n│  └─ package.json\n├─ lib3\n│  ├─ src\n│  └─ package.json\n└─ package.json\n"})}),"\n",(0,s.jsxs)(n.p,{children:["使用基于",(0,s.jsx)(n.code,{children:"Monorepo"}),"的",(0,s.jsx)(n.code,{children:"lerna"}),"管理仓库，能为仓库带来更好的收益。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"节省存储空间"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["若一个仓库中多个子包都依赖",(0,s.jsx)(n.code,{children:"react"}),"与",(0,s.jsx)(n.code,{children:"react-dom"}),"，在为每个子包安装依赖时会在各自的",(0,s.jsx)(n.code,{children:"node_modules"}),"文件夹中产生大量冗余的",(0,s.jsx)(n.code,{children:"Npm模块"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["若使用",(0,s.jsx)(n.code,{children:"lerna"}),"，会将相同版本的",(0,s.jsx)(n.code,{children:"Npm模块"}),"提升到仓库根目录中的",(0,s.jsx)(n.code,{children:"node_modules"}),"文件夹，以降低模块沉积。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"解决依赖升级"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["若一个仓库中多个子包都依赖某一个或多个其他子包",(0,s.jsx)(n.code,{children:"X"}),"，当",(0,s.jsx)(n.code,{children:"X"}),"升级版本时需将它们发布到",(0,s.jsx)(n.code,{children:"Npm公有仓库"}),"，再更新依赖",(0,s.jsx)(n.code,{children:"X"}),"的子包的依赖，才能将改动的代码应用起来。"]}),"\n",(0,s.jsxs)(n.p,{children:["若使用",(0,s.jsx)(n.code,{children:"lerna"}),"，则会直接跳过将",(0,s.jsx)(n.code,{children:"X"}),"发布到",(0,s.jsx)(n.code,{children:"Npm公有仓库"}),"的流程，子包可在本地环境直接",(0,s.jsx)(n.code,{children:"link"}),"到",(0,s.jsx)(n.code,{children:"X"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"共用同一仓库"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"若一个仓库中多个子包都因为需求更新而发版，那将引起一堆重复操作，导致每个子包都要走一次提交流程。"}),"\n",(0,s.jsxs)(n.p,{children:["若使用",(0,s.jsx)(n.code,{children:"lerna"}),"，则解决了这些子包的工作流程，就可放心将它们存放到同一仓库中管理了。"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["其实",(0,s.jsx)(n.code,{children:"lerna"}),"的最终目标还是围绕着",(0,s.jsx)(n.code,{children:"统一工作流程"}),"与",(0,s.jsx)(n.code,{children:"分割通用代码"}),"，毕竟当仓库内容出现关联时，无任何一种调试方式比源码放在一起更高效，而",(0,s.jsx)(n.code,{children:"lerna"}),"就是解决源码放在一起带来的副作用，使用",(0,s.jsx)(n.code,{children:"Monorepo"}),"的方式解决这些问题，使",(0,s.jsx)(n.code,{children:"多包仓库"}),"管理起来更高效。"]}),"\n",(0,s.jsxs)(n.p,{children:["虽然",(0,s.jsx)(n.code,{children:"lerna"}),"管理仓库会导致仓库的存储空间变得更大，但其带来的优势也是常见方案不能企及的。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-txt",children:"仓库管理的工作流程包括但不限于构建、测试、打包、发布、部署等流程。\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"方案基于yarn与lerna搭建多包仓库基建模板",children:["方案：基于Yarn与Lerna搭建多包仓库基建模板",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方案基于yarn与lerna搭建多包仓库基建模板",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在使用",(0,s.jsx)(n.code,{children:"lerna"}),"前，一个",(0,s.jsx)(n.code,{children:"Multirepo仓库"}),"的组织形式可能是这样的。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"Multirepo"})}),"\n",(0,s.jsxs)(n.p,{children:["在使用",(0,s.jsx)(n.code,{children:"lerna"}),"后，",(0,s.jsx)(n.code,{children:"Multirepo仓库"}),"就会变成",(0,s.jsx)(n.code,{children:"Menorepo仓库"}),"，其组织形式就会变成这样。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:"Monorepo"})}),"\n",(0,s.jsxs)(n.p,{children:["通过上图基本可判断出使用",(0,s.jsx)(n.code,{children:"lerna"}),"前后的差异。",(0,s.jsx)(n.code,{children:"lerna"}),"显式地改变项目结构，把多个子包合并为一个仓库，然后使用",(0,s.jsx)(n.code,{children:"packages"}),"文件夹存放每个子包，以使用一个仓库管理多个子包。另外还可用",(0,s.jsx)(n.code,{children:"lerna"}),"提供的命令轻松管理",(0,s.jsx)(n.code,{children:"Menorepo仓库"}),"，掌握以下命令就能操作",(0,s.jsx)(n.code,{children:"lerna"}),"。"]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{align:"center",children:"命令"}),"\n",(0,s.jsx)(n.th,{align:"center",children:"功能"}),"\n",(0,s.jsx)(n.th,{children:"描述"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"lerna init"}),"|初始项目\n",(0,s.jsx)(n.code,{children:"lerna boostrap"}),"|安装依赖|自动解决子包间的依赖关系","子包内部互相依赖会使用软链接处理\n",(0,s.jsx)(n.code,{children:"lerna clean"}),"|卸载依赖|只能卸载每个子包的",(0,s.jsx)(n.code,{children:"node_modules"}),"不能卸载根目录的",(0,s.jsx)(n.code,{children:"node_modules"}),"\n",(0,s.jsx)(n.code,{children:"lerna create <name>"}),"|新增子包|在",(0,s.jsx)(n.code,{children:"packages"}),"文件夹中创建由",(0,s.jsx)(n.code,{children:"lerna"}),"管理的子包\n",(0,s.jsx)(n.code,{children:"lerna add <pkg>"}),"|安装模块|为所有子包安装模块","可通过",(0,s.jsx)(n.code,{children:"--scope=pkg"}),"安装指定子包模块\n",(0,s.jsx)(n.code,{children:"lerna run <script>"}),"|执行命令|为所有子包执行命令","可通过",(0,s.jsx)(n.code,{children:"--scope=pkg"}),"执行指定子包命令\n",(0,s.jsx)(n.code,{children:"lerna version"}),"|标记版本|标记存在修改行为的子包\n",(0,s.jsx)(n.code,{children:"lerna publish [bump]"}),"|发布子包|发布全部",(0,s.jsx)(n.code,{children:"private"}),"不为",(0,s.jsx)(n.code,{children:"true"}),"的子包"]}),"\n",(0,s.jsxs)(n.h5,{id:"版本管理",children:["版本管理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#版本管理",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"lerna"}),"有两种版本管理模式，分别是",(0,s.jsx)(n.code,{children:"固定模式(Fixed)"}),"与",(0,s.jsx)(n.code,{children:"独立模式(Independent)"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"固定模式"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"固定模式"}),"通过在",(0,s.jsx)(n.code,{children:"lerna.json"}),"中指定",(0,s.jsx)(n.code,{children:"version"}),"统一管理版本。该模式自动将所有子包版本捆绑在一起，迭代任何一个或多个子包都会导致所有子包版本升级。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"angular"}),"早期版本迭代使用该模式处理，导致很多无任何迭代的子包因为其他迭代的子包升级而升级。",(0,s.jsx)(n.code,{children:"固定模式"}),"的优势是统一管理版本，让开发者专注于开发而无需理会版本的迭代过程，反正每次发生迭代就统一升级所有子包版本。其劣势也很明显，那些无任何迭代的子包无缘无故被升级，不符合",(0,s.jsx)(n.code,{children:"变更就发版"}),"的开发逻辑，导致追溯源码版本时很易产生多个版本源码一样的情况。"]}),"\n",(0,s.jsxs)(n.p,{children:["执行",(0,s.jsx)(n.code,{children:"lerna init"}),"初始项目，就可生成",(0,s.jsx)(n.code,{children:"固定模式"}),"的项目结构。其中",(0,s.jsx)(n.code,{children:"package.json"}),"与",(0,s.jsx)(n.code,{children:"lerna.json"}),"的内容分别如下。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// package.json\n{\n	"name": "root",\n	"private": true,\n	"devDependencies": {\n		"lerna": "4.0.0"\n	}\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// lerna.json\n{\n	"version": "0.0.0",\n	"packages": [\n		"packages/*"\n	]\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"独立模式"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"独立模式"}),"通过在",(0,s.jsx)(n.code,{children:"lerna.json"}),"中指定",(0,s.jsx)(n.code,{children:"version"}),"为",(0,s.jsx)(n.code,{children:"independent"}),"，允许具体维护每个子包版本。子包版本由每个子包的",(0,s.jsx)(n.code,{children:"package.json"}),"的",(0,s.jsx)(n.code,{children:"version"}),"维护，每次发布时都会收到一个提示，以说明每个迭代子包是主版本(",(0,s.jsx)(n.code,{children:"major"}),")、次版本(",(0,s.jsx)(n.code,{children:"minor"}),")、修订版本(",(0,s.jsx)(n.code,{children:"patch"}),")还是自定义更改版本(",(0,s.jsx)(n.code,{children:"custom change"}),")。"]}),"\n",(0,s.jsxs)(n.p,{children:["每次发布版本时，",(0,s.jsx)(n.code,{children:"lerna.json"}),"的",(0,s.jsx)(n.code,{children:"version"}),"不会发生变化，始终保持为",(0,s.jsx)(n.code,{children:"independent"}),"。得益于",(0,s.jsx)(n.code,{children:"独立模式"}),"能更好地区分每个子包版本，所以目前很多明星项目都使用",(0,s.jsx)(n.code,{children:"独立模式"}),"处理子包版本。"]}),"\n",(0,s.jsxs)(n.p,{children:["执行",(0,s.jsx)(n.code,{children:"lerna init --independent"}),"初始项目，就可生成",(0,s.jsx)(n.code,{children:"独立模式"}),"的项目结构。其中",(0,s.jsx)(n.code,{children:"package.json"}),"与",(0,s.jsx)(n.code,{children:"lerna.json"}),"的内容分别如下。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// package.json\n{\n	"name": "root",\n	"private": true,\n	"devDependencies": {\n		"lerna": "4.0.0"\n	}\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// lerna.json\n{\n	"version": "independent",\n	"packages": [\n		"packages/*"\n	]\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["为了更好地管理每个子包版本，选择",(0,s.jsx)(n.code,{children:"独立模式"}),"会更适合仓库的发展。因为子包间可能存在依赖关系，例如",(0,s.jsx)(n.code,{children:"子包B"}),"依赖",(0,s.jsx)(n.code,{children:"子包A"}),"，因此需将",(0,s.jsx)(n.code,{children:"子包A"}),"链接到",(0,s.jsx)(n.code,{children:"子包B"}),"的",(0,s.jsx)(n.code,{children:"node_module"}),"中，一旦子包间的依赖关系很多，手动管理这些",(0,s.jsx)(n.code,{children:"link"}),"操作是很麻烦的。能不能",(0,s.jsx)(n.code,{children:"自动化"}),"执行这些",(0,s.jsx)(n.code,{children:"link操作"}),"，根据拓扑排序将各个依赖",(0,s.jsx)(n.code,{children:"link"}),"起来？"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"lerna"}),"作为一个",(0,s.jsx)(n.code,{children:"Menorepo"}),"解决方案并不提供这些依赖关系复杂化的处理，但",(0,s.jsx)(n.code,{children:"yarn"}),"的",(0,s.jsx)(n.code,{children:"Workspaces"}),"却具备这样的功能。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Workspaces"}),"顾名思义是",(0,s.jsx)(n.code,{children:"工作空间"}),"，其提供一种机制使项目作用域在一个片区产生隔离效果，使内部模块通过软链接(",(0,s.jsx)(n.code,{children:"symlink"}),")的方式产生依赖但又不影响全局依赖。其优点也不言而喻。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["开发多个互相依赖的模块时，",(0,s.jsx)(n.code,{children:"Workspaces"}),"会自动对模块的引用设置软链接，比",(0,s.jsx)(n.code,{children:"yarn link"}),"更方便且链接仅局限在当前",(0,s.jsx)(n.code,{children:"Workspaces"}),"中，不会对整个系统造成影响"]}),"\n",(0,s.jsxs)(n.li,{children:["所有模块的依赖会安装在根目录的",(0,s.jsx)(n.code,{children:"node_modules"}),"文件夹中，节省磁盘空间且给",(0,s.jsx)(n.code,{children:"yarn"}),"更大的依赖优化空间"]}),"\n",(0,s.jsxs)(n.li,{children:["所有模块使用同一个",(0,s.jsx)(n.code,{children:"yarn.lock"}),"，减少依赖冲突且易于审查"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["若使用",(0,s.jsx)(n.code,{children:"lern"}),"的",(0,s.jsx)(n.code,{children:"独立模式"}),"管理仓库，为了解决互相依赖的问题必须引用",(0,s.jsx)(n.code,{children:"yarn"}),"的",(0,s.jsx)(n.code,{children:"Workspaces"}),"。执行",(0,s.jsx)(n.code,{children:"npm i -g yarn"}),"安装",(0,s.jsx)(n.code,{children:"yarn"}),"，输出版本表示安装成功。"]}),"\n",(0,s.jsxs)(n.p,{children:["在",(0,s.jsx)(n.code,{children:"package.json"}),"中指定",(0,s.jsx)(n.code,{children:"workspaces"}),"并修改",(0,s.jsx)(n.code,{children:"name"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n	"name": "@yangzw/bruce", // 自行修改\n	"private": true,\n	"devDependencies": {\n		"lerna": "4.0.0"\n	},\n	"workspaces": [\n		"packages/*"\n	]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["在",(0,s.jsx)(n.code,{children:"lerna.json"}),"中指定以下字段并删除",(0,s.jsx)(n.code,{children:"packages"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"npmClient"}),"：模块管理工具，可选",(0,s.jsx)(n.code,{children:"npm/yarn"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"useWorkspaces"}),"：是否使用",(0,s.jsx)(n.code,{children:"yarn"}),"的",(0,s.jsx)(n.code,{children:"Workspaces"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"command"}),"：命令配置","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"publish.ignoreChanges"}),"：指定文件夹或文件在改动情况下不会被发布"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"publish.message"}),"：发布时提交消息的格式"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"publish.registry"}),"：发布到指定",(0,s.jsx)(n.code,{children:"Npm镜像"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n	"version": "independent",\n	"npmClient": "yarn", // 主要\n	"useWorkspaces": true, // 主要\n	"command": {\n		"publish": {\n			"ignoreChanges": [\n				".DS_Store",\n				"node_modules",\n				"package-lock.json",\n				"yarn.lock"\n			],\n			"message": "chore: publish release %v",\n			"registry": "https://registry.npmjs.org/"\n		}\n	} // 次要\n}\n'})}),"\n",(0,s.jsxs)(n.h5,{id:"子包管理",children:["子包管理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#子包管理",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["执行",(0,s.jsx)(n.code,{children:"lerna create <name>"}),"创建三个子包。",(0,s.jsx)(n.code,{children:"app"}),"是一个打包应用的工具，",(0,s.jsx)(n.code,{children:"ui"}),"是一个通用组件库，",(0,s.jsx)(n.code,{children:"us"}),"是一个通用工具库。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"lerna create app && lerna create ui && lerna create us\n"})}),"\n",(0,s.jsxs)(n.p,{children:["推荐手动创建每个子包的内容，这样更易掌握",(0,s.jsx)(n.code,{children:"多包仓库"}),"的项目结构。在每个子包的",(0,s.jsx)(n.code,{children:"package.json"}),"中指定",(0,s.jsx)(n.code,{children:"name"}),"为",(0,s.jsx)(n.code,{children:"范围模块"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n	"name": "@yangzw/bruce-app" // 其他子包同样处理\n}\n'})}),"\n",(0,s.jsxs)(n.h5,{id:"依赖管理",children:["依赖管理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖管理",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["三个子包都缺乏内容，演示起来有点空荡，把",(0,s.jsx)(n.code,{children:"packages"}),"文件夹中的内容删除，复制该",(0,s.jsx)(n.a,{href:"https://github.com/JowayYoung/bruce/tree/main/packages",target:"_blank",rel:"noopener noreferrer",children:"目录"}),"中的",(0,s.jsx)(n.code,{children:"app"}),"、",(0,s.jsx)(n.code,{children:"ui"}),"和",(0,s.jsx)(n.code,{children:"us"}),"到",(0,s.jsx)(n.code,{children:"packages"}),"文件夹中。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"app"}),"与",(0,s.jsx)(n.code,{children:"ui"}),"都依赖了",(0,s.jsx)(n.code,{children:"us"}),"，与上述情况保持一样。接着增加",(0,s.jsx)(n.strong,{children:"整包安装依赖"}),"与",(0,s.jsx)(n.strong,{children:"整包卸载依赖"}),"的操作。在根目录的",(0,s.jsx)(n.code,{children:"package.json"}),"中指定",(0,s.jsx)(n.code,{children:"srcipts"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n	"scripts": {\n		"clean": "lerna clean && rimraf node_modules package-lock.json yarn.lock",\n		"init": "lerna bootstrap"\n	}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["当首次克隆仓库或重装依赖时，执行",(0,s.jsx)(n.code,{children:"yarn run init"}),"。该命令会执行",(0,s.jsx)(n.code,{children:"lerna bootstrap"}),"自动处理好三个子包间的依赖关系并将部分依赖提升到根目录的",(0,s.jsx)(n.code,{children:"node_modules"}),"文件夹中。"]}),"\n",(0,s.jsxs)(n.p,{children:["当卸载依赖时，执行",(0,s.jsx)(n.code,{children:"yarn run clean"}),"。该命令会执行",(0,s.jsx)(n.code,{children:"lerna clean"}),"卸载每个子包的",(0,s.jsx)(n.code,{children:"node_modules"}),"文件夹，但会留下根目录的",(0,s.jsx)(n.code,{children:"node_modules"}),"文件夹。还记得第11章使用",(0,s.jsx)(n.code,{children:"rimraf"}),"卸载根目录的",(0,s.jsx)(n.code,{children:"node_modules"}),"文件夹吗？将这两个命令组合起来即可。"]}),"\n",(0,s.jsxs)(n.p,{children:["当依赖乱掉或工程混乱时，根据顺序执行",(0,s.jsx)(n.code,{children:"yarn run clean"}),"与",(0,s.jsx)(n.code,{children:"yarn run init"}),"，让仓库的依赖关系保持最佳状态。"]}),"\n",(0,s.jsxs)(n.p,{children:["在开发时肯定会安装某些模块。使用",(0,s.jsx)(n.code,{children:"lerna"}),"安装依赖有些特殊，需分三种情况考虑。"]}),"\n",(0,s.jsxs)(n.p,{children:["若全部子包都安装",(0,s.jsx)(n.code,{children:"semver"}),"，那执行以下命令，不带任何参数。安装好的",(0,s.jsx)(n.code,{children:"semver"}),"会存放到根目录的",(0,s.jsx)(n.code,{children:"node_modules"}),"文件夹中。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"lerna add semver\n"})}),"\n",(0,s.jsxs)(n.p,{children:["若只有",(0,s.jsx)(n.code,{children:"app"}),"安装",(0,s.jsx)(n.code,{children:"semver"}),"，执行以下命令需带上",(0,s.jsx)(n.code,{children:"--scope"}),"指定子包，子包名称以",(0,s.jsx)(n.code,{children:"package.json"}),"的",(0,s.jsx)(n.code,{children:"name"}),"为准。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"lerna add semver --scope @yangzw/bruce-app\n"})}),"\n",(0,s.jsxs)(n.p,{children:["若",(0,s.jsx)(n.code,{children:"app"}),"依赖了",(0,s.jsx)(n.code,{children:"us"}),"，为",(0,s.jsx)(n.code,{children:"app"}),"安装",(0,s.jsx)(n.code,{children:"us"}),"也通过上述方式完成。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"lerna add @yangzw/bruce-us --scope @yangzw/bruce-app\n"})}),"\n",(0,s.jsxs)(n.h5,{id:"命令管理",children:["命令管理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#命令管理",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["有些子包可能需输出编译后的",(0,s.jsx)(n.code,{children:"bundle文件"}),"，通常会在",(0,s.jsx)(n.code,{children:"package.json"}),"中指定",(0,s.jsx)(n.code,{children:"scripts"}),"，使用",(0,s.jsx)(n.code,{children:"build"}),"字段映射相关打包命令。"]}),"\n",(0,s.jsxs)(n.p,{children:["上述所有子包都存在",(0,s.jsx)(n.code,{children:"build"}),"命令，执行以下命令就会顺序为每个子包执行",(0,s.jsx)(n.code,{children:"yarn run build"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"lerna run build\n"})}),"\n",(0,s.jsxs)(n.p,{children:["为了方便控制，在根目录的",(0,s.jsx)(n.code,{children:"package.json"}),"中指定",(0,s.jsx)(n.code,{children:"srcipts"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n	"scripts": {\n		"build": "lerna run build"\n	}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["若只有",(0,s.jsx)(n.code,{children:"app"}),"执行",(0,s.jsx)(n.code,{children:"build"}),"，执行以下命令需带上",(0,s.jsx)(n.code,{children:"--scope"}),"指定子包。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"lerna run build --scope @yangzw/bruce-app\n"})}),"\n",(0,s.jsxs)(n.p,{children:["各个子包的依赖还可能存在顺序关系，例如",(0,s.jsx)(n.code,{children:"app"}),"依赖",(0,s.jsx)(n.code,{children:"us"}),"，因此必须先执行",(0,s.jsx)(n.code,{children:"yarn run build --scope @yangzw/bruce-us"}),"，再执行",(0,s.jsx)(n.code,{children:"yarn run build --scope @yangzw/bruce-app"}),"。这实际上要求命令以一种拓扑排序的规则进行。"]}),"\n",(0,s.jsxs)(n.p,{children:["很不幸",(0,s.jsx)(n.code,{children:"yarn"}),"的",(0,s.jsx)(n.code,{children:"Workspaces"}),"暂时并未支持根据拓扑排序规则执行命令，幸运的是",(0,s.jsx)(n.code,{children:"lerna"}),"支持根据拓扑排序规则执行命令，",(0,s.jsx)(n.code,{children:"--sort"}),"参数可控制以拓扑排序规则执行命令。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"lerna run --stream --sort build\n"})}),"\n",(0,s.jsxs)(n.h5,{id:"发布管理",children:["发布管理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布管理",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在发布子包前需执行",(0,s.jsx)(n.code,{children:"lerna version"}),"迭代版本，执行该命令时做了以下工作。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"标识自上个标记版本依赖有更新的子包"}),"\n",(0,s.jsx)(n.li,{children:"提示输入新版本"}),"\n",(0,s.jsx)(n.li,{children:"修改子包的元数据以反映新版本，在根目录与每个子包中运行适当的生命周期脚本"}),"\n",(0,s.jsx)(n.li,{children:"提交与标记修改记录"}),"\n",(0,s.jsxs)(n.li,{children:["推送到",(0,s.jsx)(n.code,{children:"Git"}),"远端"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"版本更新原则"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","存在",(0,s.jsx)(n.code,{children:"BREAKING CHANGE提交"}),"：需更新",(0,s.jsx)(n.code,{children:"主版本"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","存在",(0,s.jsx)(n.code,{children:"FEAT提交"}),"：需更新",(0,s.jsx)(n.code,{children:"次版本"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","存在",(0,s.jsx)(n.code,{children:"FIX提交"}),"：需更新",(0,s.jsx)(n.code,{children:"修订版本"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["发布子包需执行",(0,s.jsx)(n.code,{children:"lerna publish"}),"，该命令既可包括",(0,s.jsx)(n.code,{children:"lerna version"}),"的工作，也可只做发布操作。若子包的",(0,s.jsx)(n.code,{children:"package.json"}),"的",(0,s.jsx)(n.code,{children:"private"}),"设置为",(0,s.jsx)(n.code,{children:"true"}),"，则不会被发布出去。"]}),"\n",(0,s.jsx)(n.p,{children:"发布子包可分为以下场景。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"lerna publish"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["该命令实际封装了",(0,s.jsx)(n.code,{children:"lerna version && lerna publish from-git"}),"，用于发布自上次发布以来有更新的子包，",(0,s.jsx)(n.code,{children:"上次发布"}),"也是基于上次执行",(0,s.jsx)(n.code,{children:"lerna publish"}),"而言。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"lerna publish from-git"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["发布当前提交中已标记的子包。",(0,s.jsx)(n.code,{children:"from-git"}),"根据",(0,s.jsx)(n.code,{children:"git commit"}),"中的",(0,s.jsx)(n.code,{children:"annotaed tag"}),"发包。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"lerna publish from-package"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["发布",(0,s.jsx)(n.code,{children:"Npm镜像"}),"中不存在的最新版本的子包。",(0,s.jsx)(n.code,{children:"from-package"}),"根据",(0,s.jsx)(n.code,{children:"package.json"}),"的",(0,s.jsx)(n.code,{children:"version"}),"变动发包。"]}),"\n",(0,s.jsxs)(n.h3,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["通过",(0,s.jsx)(n.code,{children:"lerna"}),"就能很方便地管理",(0,s.jsx)(n.code,{children:"Menorepo方式"}),"的仓库了，因此当仓库达到一定规模需拆分子包时就要考虑使用",(0,s.jsx)(n.code,{children:"Menorepo方式"}),"管理仓库中所有子包了。以下情况，直接建议基于",(0,s.jsx)(n.code,{children:"yarn"}),"与",(0,s.jsx)(n.code,{children:"lerna"}),"完成一个",(0,s.jsx)(n.code,{children:"多包仓库"}),"。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["个人或团队开源的",(0,s.jsx)(n.code,{children:"框架类项目"})]}),"\n",(0,s.jsxs)(n.li,{children:["公司内部的",(0,s.jsx)(n.code,{children:"组件库项目"}),"或",(0,s.jsx)(n.code,{children:"工具库项目"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"本章内容到此为止，希望能对你有所启发，欢迎你把自己的学习心得打到评论区！"}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","示例项目：",(0,s.jsx)(n.a,{href:"https://github.com/JowayYoung/fe-engineering",target:"_blank",rel:"noopener noreferrer",children:"fe-engineering"})]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",checked:!0,disabled:!0})," ","正式项目：",(0,s.jsx)(n.a,{href:"https://github.com/JowayYoung/bruce",target:"_blank",rel:"noopener noreferrer",children:"bruce"})]}),"\n"]})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}let a=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E5%88%B0%201%20%E8%90%BD%E5%9C%B0%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%2F18.%E5%A4%9A%E5%8C%85%E4%BB%93%E5%BA%93%EF%BC%9A%E5%A4%9A%E4%B8%AA%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E7%9B%B8%E5%90%8C%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%9C%9F%E8%AE%A9%E4%BA%BA%E5%A4%B4%E5%A4%A7%E5%95%8A%EF%BC%81.md"]={toc:[{text:"前言",id:"前言",depth:3},{text:"背景：Monorepo仓库带来的收益",id:"背景monorepo仓库带来的收益",depth:3},{text:"方案：基于Yarn与Lerna搭建多包仓库基建模板",id:"方案基于yarn与lerna搭建多包仓库基建模板",depth:3},{text:"总结",id:"总结",depth:3}],title:"18.多包仓库：多个仓库管理相同业务代码，真让人头大啊！",headingTitle:"18.多包仓库：多个仓库管理相同业务代码，真让人头大啊！",frontmatter:{}}}}]);