"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58692"],{217197:function(e,n,t){t.r(n),t.d(n,{default:()=>R});var s=t(552676),r=t(740453);let i=t.p+"static/image/bac0d34575e1852b53e3382f5aedf70a.65ca6dba.webp",a=t.p+"static/image/923541f4c956cddce457f6010469a8bf.0f40ec57.webp",o=t.p+"static/image/b50acc8bc7eb6073e4aed10b676a50a0.0484a28d.webp",c=t.p+"static/image/d971d6dd9f3c4e048cccd36793d5348b.d150b79b.webp",l=t.p+"static/image/c7f8bd1ddf3560fe18d7e4d9c58fe5c8.b08962e3.webp",d=t.p+"static/image/78837270eaecbd8c36a0d83820ffc184.1cdee004.webp",p=t.p+"static/image/d611df9913339854da6dbd98a3201081.c0973a10.webp",m=t.p+"static/image/06ffa1ff027b476db9b9bf19a7f62aa2.8e32dc61.webp",h=t.p+"static/image/6e2647e65963030f67ac5e65b2d802d7.d2fa8457.webp",x=t.p+"static/image/c007478515f3f739e347bb9de25d2962.f9b91398.webp",u=t.p+"static/image/decc1316b06fd97eb7d27e2c2b844a4b.2d619e46.webp",f=t.p+"static/image/e3bc19278e9c3b387420b268e6c22663.ea7a239c.webp",g=t.p+"static/image/52777fe2b50a069a1b7625d15fd76f03.ec612676.webp";function j(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",blockquote:"blockquote",img:"img",code:"code",pre:"pre",h3:"h3",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"15业务篇-简历模版列表实现与侧边栏交互效果",children:["15.业务篇-简历模版列表实现与侧边栏交互效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15业务篇-简历模版列表实现与侧边栏交互效果",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["前面章节跟着阿宽已将简历平台搭建完毕，能实现主流程：",(0,s.jsx)(n.strong,{children:"信息录入->信息展示->信息导出"}),"，接下来我们为简历平台添加一些丰富有趣的功能。"]}),"\n",(0,s.jsxs)(n.p,{children:["本章节将带大家开发简历列表模块～ 本章节涉及的组件样式均不做讲解，所以小伙伴们可以结合",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/chapter-15",target:"_blank",rel:"noopener noreferrer",children:"chapter-15"}),"代码进行配套阅读实践。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"如果你对本章节内容兴趣不大，可以快速阅读或跳过。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"组件划分",children:["组件划分",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组件划分",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们先来简单实现一下简历模版列表的效果。以下面原型稿为主进行开发"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"当小伙伴们看到原型图之后，结合前面所说的组件化思想，想必对组件已经有了一个明确的划分。下面是阿宽的一个组件划分图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"接下来就让我们动手实现～"}),"\n",(0,s.jsxs)(n.h2,{id:"添加模版列表入口模块",children:["添加模版列表入口模块",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#添加模版列表入口模块",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["进入到 ",(0,s.jsx)(n.code,{children:"renderer/container"})," 文件夹下，我们新增一个文件夹，取名为：",(0,s.jsx)(n.code,{children:"templateList"}),"，表明这是模版列表模块，并创建入口文件 index.tsx 和 index.less"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/container/templateList/index.tsx\nimport React from 'react';\nimport './index.less';\n\nfunction TemplateList() {\n  return <div styleName=\"container\">我是模版列表模块</div>;\n}\nexport default TemplateList;\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们新增了列表模块，那么我们需要在路由常量处添加此入口，并且支持点击跳转至模块列表页面。"}),"\n",(0,s.jsxs)(n.p,{children:["我们修改 ",(0,s.jsx)(n.code,{children:"/renderer/common/constants"})," 文件夹下的 router.ts，下面是伪代码"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/common/constants/router.ts\n\nconst ROUTER = {\n  // \uD83D\uDC47 新增模版列表入口\n  templateList: '/templateList',\n};\n\nexport const ROUTER_KEY = {\n  // \uD83D\uDC47 新增模版列表入口\n  templateList: 'templateList',\n};\n\n// 入口模块\nexport const ROUTER_ENTRY = [\n  // \uD83D\uDC47 新增模版列表入口\n  {\n    url: ROUTER.templateList,\n    key: ROUTER_KEY.templateList,\n    text: '模版',\n  },\n];\n"})}),"\n",(0,s.jsx)(n.p,{children:"添加了路由入口之后，我们还需要在路由组件，编写此路由对应的页面。路由组件 router.tsx，我们稍作修改，下面是伪代码"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/router.tsx\n\nimport TemplateList from '@src/container/templateList';\nimport ROUTER from '@common/constants/router';\n\nfunction Router() {\n  return (\n    <HashRouter>\n      <Switch>\n        {/* \uD83D\uDC47 新增路由，好让我们能跳转到对应的页面 */}\n        <Route path={ROUTER.templateList} exact>\n          <TemplateList />\n        </Route>\n      </Switch>\n    </HashRouter>\n  );\n}\nexport default Router;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此时我们运行一下程序，执行 ",(0,s.jsx)(n.code,{children:"npm run start:main"})," 与 ",(0,s.jsx)(n.code,{children:"npm run start:render"}),"，可以看到，我们的首页多了一个",(0,s.jsx)(n.code,{children:"模版"}),"入口，当我们点击之后，进入到我们的模版列表页面。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"header-组件实现",children:["Header 组件实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#header-组件实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 templateList 文件夹下，新增 Header 文件夹，并新增 index.tsx 与 index.less，样式相关代码省略"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/container/templateList/Header/index.tsx\n\nimport React from 'react';\nimport './index.less';\nimport { useHistory } from 'react-router';\n\nfunction Header() {\n  const history = useHistory();\n  const goBack = () => history.push('/');\n  return (\n    <div styleName=\"header\">\n      <div styleName=\"back\" onClick={goBack}>\n        返回\n      </div>\n      <p styleName=\"title\">简历模版仓库</p>\n    </div>\n  );\n}\nexport default Header;\n"})}),"\n",(0,s.jsx)(n.p,{children:"此刻，我们将 Header 组件引入，看看效果如何"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/container/templateList/index.tsx\n\nimport React from 'react';\nimport './index.less';\n// \uD83D\uDC47 引入Header组件\nimport Header from './Header';\n\nfunction TemplateList() {\n  return (\n    <div styleName=\"container\">\n      <Header />\n    </div>\n  );\n}\nexport default TemplateList;\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"列表侧边栏组件实现",children:["列表侧边栏组件实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#列表侧边栏组件实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们期望的效果是：列表容器中陈列出所有的模版，当鼠标悬浮在图片上，如果当前悬浮的是当前模版，则显示“已使用”，否则显示“预览模版”。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["请注意：实现此组件之前，请小伙伴先去 assets 文件夹下新增 template 文件夹，添加两个模版的封面，这两个模版封面地址在此：",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/tree/chapter-15/assets/template",target:"_blank",rel:"noopener noreferrer",children:"下载封面地址"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"在添加了模版封面之后，接下来我们在 templateList 文件夹下，新增 Navigation 文件夹，并新增 index.tsx 与 index.less，由于样式代码相对较多，这里不做展示。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// renderer/container/templateList/Navigation/index.tsx\n\nimport React from \'react\';\nimport \'./index.less\';\nimport UseIcon from \'@assets/icon/use.png\';\n// \uD83D\uDC47 模版封面图\nimport TemplateCoverOne from \'@assets/template/template1.jpg\';\nimport TemplateCoverTwo from \'@assets/template/template2.jpg\';\nimport MyScrollBox from \'@common/components/MyScrollBox\';\nimport MyButton from \'@common/components/MyButton\';\n\nfunction Navigation() {\n  const height = document.body.clientHeight;\n\n  return (\n    <div styleName="navigation">\n      <MyScrollBox maxHeight={height - 60 - 32}>\n        {/* 悬浮效果一：属于当前模版 */}\n        <div styleName="template">\n          <img styleName="cover" src={TemplateCoverOne} />\n          <div styleName="mask">\n            <img styleName="use" src={UseIcon} />\n          </div>\n        </div>\n        {/* 悬浮效果二：可选择预览模版 */}\n        <div styleName="template">\n          <img styleName="cover" src={TemplateCoverTwo} />\n          <div styleName="mask">\n            <MyButton size="middle" className="view-btn" onClick={() => {}}>\n              预览模版\n            </MyButton>\n          </div>\n        </div>\n      </MyScrollBox>\n    </div>\n  );\n}\n\nexport default Navigation;\n'})}),"\n",(0,s.jsx)(n.p,{children:"我们来刷新一下页面，可以看到，我们的模版列表静态效果已经完成。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"footer-组件实现",children:["Footer 组件实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#footer-组件实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们在 templateList 文件夹下，新增 Footer 文件夹，在此文件夹中新增 index.tsx 与 index.less。"}),"\n",(0,s.jsx)(n.p,{children:"该组件的主要职责是：以当前预览的静态模版进行简历制作。"}),"\n",(0,s.jsx)(n.p,{children:"明白此组件的作用之后，我们很快就能编写出相关代码。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/container/templateList/Footer/index.tsx\n\nimport React from 'react';\nimport './index.less';\nimport MyButton from '@common/components/MyButton';\n\nfunction Footer() {\n  const onMadeResume = () => {\n    console.log('跳转前往制作页面');\n  };\n  return (\n    <div styleName=\"footer\">\n      <MyButton size=\"middle\" className=\"use-btn\" onClick={onMadeResume}>\n        以此模版前往制作简历\n      </MyButton>\n    </div>\n  );\n}\n\nexport default Footer;\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"静态模版组件展示",children:["静态模版组件展示",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#静态模版组件展示",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们在 templateList 文件夹下，新增 StaticResume 文件夹，表示此这是静态模版预览，我们新增 index.tsx 与 index.less。"}),"\n",(0,s.jsxs)(n.p,{children:["在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962895451875966989",target:"_blank",rel:"noopener noreferrer",children:"第八章节"}),"处，阿宽为大家提供了一份简历模版，所以不出意外的情况下，小伙伴们的 ",(0,s.jsx)(n.code,{children:"renderer/container"})," 文件夹下，会存在一个名为 ",(0,s.jsx)(n.code,{children:"templates"})," 的文件夹，我们直接引入里面的静态模版进行展示即可。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/container/templateList/StaticResume/index.tsx\n\nimport React from 'react';\nimport './index.less';\n// \uD83D\uDC47 引入所有的静态模版\nimport * as TemplateList from '@src/container/templates';\n// \uD83D\uDC47 引入上边写好的 Footer 组件\nimport Footer from '../Footer';\nimport MyScrollBox from '@common/components/MyScrollBox';\n\nfunction StaticResume() {\n  const HEADER_HEIGHT = 76; // 距离头部距离\n  const height = document.body.clientHeight;\n\n  return (\n    <div styleName=\"container\">\n      <MyScrollBox maxHeight={height - HEADER_HEIGHT}>\n        {/* 这里暂时先写死第一个静态模版 */}\n        <TemplateList.TemplateOne />\n        <Footer />\n      </MyScrollBox>\n    </div>\n  );\n}\n\nexport default StaticResume;\n"})}),"\n",(0,s.jsx)(n.p,{children:"刷新一下页面，看看效果是否符合我们期望。果不其然，并且滚动至底部，可以看到跳转按钮。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"至此，我们的模版列表已开发完毕，基本上能实现我们想要的样式效果。"}),"\n",(0,s.jsxs)(n.h2,{id:"-模版数据显示",children:["\uD83E\uDD14 模版数据显示",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-模版数据显示",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上面我们是以简单粗暴形式，将页面撸了出来，但细心的你会发现，",(0,s.jsx)(n.strong,{children:"几乎都是写死的数据"}),"，比如模版封面图片，我们都是通过 import 引入，假设将来有 n 张模版封面，是不是需要引入 n 次？"]}),"\n",(0,s.jsx)(n.p,{children:"我在想：能否通过读取模版封面的文件夹，以读文件夹的形式把所有封面读出来，然后进行展示呢？得益于 Electron 内置了 NodeJS，我们通过 fs 文件系统模块来试试，看看是否能读到模版封面的所有图片。"}),"\n",(0,s.jsxs)(n.h3,{id:"usereaddirassetstemplatehooks",children:["useReadDirAssetsTemplateHooks",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usereaddirassetstemplatehooks",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们在 renderer 文件夹下，新增 hooks 文件夹，下面是我们的文件目录图"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["在 hooks 文件夹下，新增自定义 hooks，暂且叫做：",(0,s.jsx)(n.code,{children:"useReadDirAssetsTemplateHooks.ts"}),"，从名称上可知，该 hooks 主要是读取模版静态文件目录。让我们来编写它"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/hooks/useReadDirAssetsTemplateHooks.ts\n\nimport fileAction from '@common/utils/file';\nimport { getAppPath } from '@common/utils/appPath';\n\nexport default function () {\n  return () => {\n    // 1. 先获取应用地址\n    getAppPath().then((appPath: string) => {\n      console.log(appPath);\n      // 2. 从assets读取模版图片信息，构造模版列表\n      fileAction\n        .readDir(`${appPath}assets/template`)\n        .then((files: string[]) => {\n          // \uD83D\uDC47 打印一下该目录下的文件\n          console.log('该目录下的文件有：\\n');\n          console.log(files);\n        })\n        .catch((err: NodeJS.ErrnoException) => {\n          throw new Error(err.message);\n        });\n    });\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["不出意外的话，此时的你会报错，原因是找不到 ",(0,s.jsx)(n.code,{children:"fileAction.readDir()"})," 方法，原来在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962906314565484551",target:"_blank",rel:"noopener noreferrer",children:"第七章节"}),"我们封装的 file.ts 文件中未支持 readDir，我们前往 ",(0,s.jsx)(n.code,{children:"@common/utils/file.ts"}),"，添加一下代码。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const fileAction = {\n  /**\n   * @description 读取目录内容\n   * @param path 路径\n   * @returns  {Promise}\n   */\n  readDir: (path: string): Promise<string[]> => {\n    return fsPromiseAPIs.readdir(path);\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"添加之后，我们需要思考什么时机执行该逻辑：阿宽希望在应用启动后，能将模版模块相关的初始化工作完成。所以阿宽选择在路由组件的 didMount 生命周期中执行初始化的相关工作。"}),"\n",(0,s.jsx)(n.p,{children:"前往路由组件 router.tsx 进行初始化"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/router.tsx\n\nimport useReadDirAssetsTemplateHooks from './hooks/useReadDirAssetsTemplateHooks';\n\nfunction Router() {\n  const readDirAssetsTemplateHooks = useReadDirAssetsTemplateHooks();\n  // \uD83D\uDC47 进行初始化工作\n  useEffect(() => {\n    readDirAssetsTemplateHooks();\n  }, []);\n\n  // 后面代码忽略\n}\nexport default Router;\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时我们将应用跑起来，打开控制台，可以看到此文件夹下存在 2 张图片"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["如上所示，我们现在只拿到文件名，那么如何读到此文件内容呢？下面我们通过 ",(0,s.jsx)(n.code,{children:"fileAction.read"})," 方法读取图片内容，构造一个模版封面列表，将其存入到 redux 中，并默认选中第一条模版"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/hooks/useReadDirAssetsTemplateHooks.ts\nimport fileAction from '@common/utils/file';\nimport { useDispatch } from 'react-redux';\nimport { getAppPath } from '@common/utils/appPath';\nimport { createUID } from '@common/utils';\n\nexport default function () {\n  const dispatch = useDispatch();\n  return () => {\n    // 1. 先获取应用地址\n    getAppPath().then((appPath: string) => {\n      // 2. 从assets读取模版图片信息，构造模版列表\n      fileAction\n        .readDir(`${appPath}assets/template`)\n        .then(async (files: string[]) => {\n          // 3. 构造模版列表\n          if (files.length > 0) {\n            let templateList: TSTemplate.Item[] = [];\n            for (const fileName of files) {\n              const base64URL = await fileAction.read(`${appPath}assets/template/${fileName}`, 'base64');\n              templateList.push({\n                templateName: fileName,\n                templateId: createUID(),\n                templateCover: `data:image/png;base64,${base64URL}`,\n              });\n            }\n            // 4. 存入到 redux 中，并默认选中第一条\n            dispatch({\n              type: 'templateModel/setStoreList',\n              payload: [\n                {\n                  key: 'templateList',\n                  values: templateList,\n                },\n                {\n                  key: 'selectTemplate',\n                  values: templateList[0],\n                },\n              ],\n            });\n          }\n        })\n        .catch((err: NodeJS.ErrnoException) => {\n          throw new Error(err.message);\n        });\n    });\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此时会看到 TSTemplate 报错，我们去 ",(0,s.jsx)(n.code,{children:"@common/types/template.d.ts"})," 中添加类型说明"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/common/types/template.d.ts\n\ndeclare namespace TSTemplate {\n  export interface Item {\n    /**\n     * @description 模版id\n     */\n    templateId: string;\n    /**\n     * @description 模版名称\n     */\n    templateName: string;\n    /**\n     * @description 模版封面\n     */\n    templateCover: string;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同时需要去 ",(0,s.jsx)(n.code,{children:"store/templateModel"})," 文件下，添加 state 值"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"//  renderer/store/templateModel.ts\n\nexport interface TStore {\n  /**\n   * @description 选中工具条模块的keys\n   */\n  resumeToolbarKeys: string[];\n  /**\n   * @description 模块列表\n   */\n  templateList: TSTemplate.Item[];\n  /**\n   * @description 当前选中的模版\n   */\n  selectTemplate: TSTemplate.Item;\n}\n\nconst templateModel: TSRcReduxModel.Props<TStore> = {\n  namespace: 'templateModel',\n  openSeamlessImmutable: true,\n  state: {\n    resumeToolbarKeys: [],\n    templateList: [],\n    selectTemplate: {\n      templateId: '',\n      templateName: '',\n      templateCover: '',\n    },\n  },\n};\n\nexport default templateModel;\n"})}),"\n",(0,s.jsx)(n.p,{children:"最后我们刷新一下页面，可以看到 redux 中已经将我们的模版数据存入。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"动态显示数据模版列表",children:["动态显示数据模版列表",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#动态显示数据模版列表",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前往 Navigation 组件中，讲静态数据改为从 redux 中读取数据。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport './index.less';\nimport UseIcon from '@assets/icon/use.png';\nimport MyScrollBox from '@common/components/MyScrollBox';\nimport MyButton from '@common/components/MyButton';\nimport { useDispatch, useSelector } from 'react-redux';\n\nfunction Navigation() {\n  const dispatch = useDispatch();\n  const HEADER_HEIGHT = 92;\n  const height = document.body.clientHeight;\n  // \uD83D\uDC47 从 redux 中读取数据\n  const templateList: TSTemplate.Item[] = useSelector((state: any) => state.templateModel.templateList);\n  const selectTemplate: TSTemplate.Item = useSelector((state: any) => state.templateModel.selectTemplate);\n\n  const onChangeTemplate = (template: TSTemplate.Item) => {\n    dispatch({\n      type: 'templateModel/setStore',\n      payload: {\n        key: 'selectTemplate',\n        values: template,\n      },\n    });\n  };\n\n  return (\n    <div styleName=\"navigation\">\n      <MyScrollBox maxHeight={height - HEADER_HEIGHT}>\n        {templateList &&\n          templateList.length > 0 &&\n          templateList.map((template: TSTemplate.Item) => {\n            return (\n              <div styleName=\"template\" key={template?.templateId}>\n                <img styleName=\"cover\" src={template?.templateCover} />\n                <div styleName=\"mask\">\n                  {selectTemplate?.templateId === template?.templateId && (\n                    <img styleName=\"use\" src={UseIcon} />\n                  )}\n                  {selectTemplate?.templateId !== template?.templateId && (\n                    <MyButton size=\"middle\" className=\"view-btn\" onClick={() => { onChangeTemplate(template) }}>\n                      预览模版\n                    </MyButton>\n                  )}\n                </div>\n              </div>\n            );\n          })}\n      </MyScrollBox>\n    </div>\n  );\n}\n\nexport default Navigation;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["至此我们实现了自定义 ",(0,s.jsx)(n.code,{children:"useReadDirAssetsTemplateHooks"}),"，",(0,s.jsx)(n.strong,{children:"通过 fs 文件系统读取文件夹内容，构造模版列表，进行动态的展示，从而解决繁琐的多次 import 多张模版封面"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"侧边栏展开收起",children:["侧边栏展开收起",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#侧边栏展开收起",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"虽然说我们是将基本功能实现完成了，但在交互体验上，总感觉有些“呆板僵硬”，我们能否通过侧边栏展开收起的交互效果，让应用看起来“年轻”一些呢？"}),"\n",(0,s.jsx)(n.p,{children:"先来看看效果图"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"侧边栏展开时"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"侧边栏收起时"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"我们来分析一下，看起来侧边栏好像通过定位进行的“位置切换”，同时我们可以看到，静态模版是居中显示在页面中的，侧边栏此刻还多了一个切换状态的“按钮”。"}),"\n",(0,s.jsx)(n.p,{children:"对于已完成的模块，我们是不期望再去动它。并且我们思考一下，这个交互效果会不会是通用的？比如将来在其他模块，是否也存在侧边栏，同时侧边栏交互与此一致？仔细品一品，是不是做成通用组件会更加合适？"}),"\n",(0,s.jsxs)(n.h3,{id:"myrectsize",children:["MyRectSize",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#myrectsize",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们在 ",(0,s.jsx)(n.code,{children:"common/components"})," 下新增一个文件夹，取名为 MyRectSize，新增 5 个文件：",(0,s.jsx)(n.code,{children:"index.ts"}),"、",(0,s.jsx)(n.code,{children:"parent.ts"}),"、",(0,s.jsx)(n.code,{children:"left.ts"}),"、",(0,s.jsx)(n.code,{children:"right.ts"}),"、",(0,s.jsx)(n.code,{children:"index.less"})]}),"\n",(0,s.jsxs)(n.p,{children:["出于代码量比较精简，就全量贴上来了，关于样式部分，小伙伴们可点击链接",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/blob/chapter-15/app/renderer/common/components/MyRectSize/index.less",target:"_blank",rel:"noopener noreferrer",children:"样式代码"}),"阅读"]}),"\n",(0,s.jsx)(n.p,{children:"下面直接贴代码并在注释中讲解，一定要看注释！！！"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// \uD83D\uDC47 定义组件的入口文件\nimport './index.less';\nimport ParentComponent from './parent';\nexport default ParentComponent;\n"})}),"\n",(0,s.jsx)(n.p,{children:"在父组件中，主要是获取获取样式，进行传递"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\n// \uD83D\uDC47 1. 引入左侧与右侧组件\nimport LeftComponent from './left';\nimport RightComponent from './right';\n\ninterface IProps {\n  /**\n   * @description 自定义样式\n   */\n  style?: React.CSSProperties;\n  children?: any;\n}\n\nclass ParentComponent extends React.Component<IProps> {\n  // \uD83D\uDC47 2. 定义类组件的静态属性\n  static Left = LeftComponent;\n  static Right = RightComponent;\n\n  defaultLeftBoxRef = React.createRef();\n\n  getParentStyle() {\n    return {\n      display: 'flex',\n      justifyContent: 'center',\n    };\n  }\n\n  getLeftStyle() {\n    return {\n      position: 'absolute',\n      left: 16,\n    };\n  }\n\n  getRightStyle() {\n    return {};\n  }\n\n  // \uD83D\uDC47 3. 获取左侧容器\n  get leftBoxRef() {\n    const { children } = this.props;\n    const leftElement = children[0];\n    return leftElement.props.boxRef || this.defaultLeftBoxRef;\n  }\n\n  getChild() {\n    const { children } = this.props;\n    const leftElement = children[0];\n    const rightElement = children[1];\n\n    return [\n      React.cloneElement(leftElement, {\n        style: { ...this.getLeftStyle(), ...(leftElement.props.style || {}) },\n        // \uD83D\uDC47 4. 一定要给左侧组件传递\n        boxRef: this.leftBoxRef,\n        key: 'componentLeft',\n      }),\n      React.cloneElement(rightElement, {\n        style: { ...this.getRightStyle(), ...(rightElement.props.style || {}) },\n        key: 'componentRight',\n      }),\n    ];\n  }\n\n  render() {\n    const { style } = this.props;\n    let finialStyle = this.getParentStyle();\n    return (\n      <div className=\"parent-box\" style={{ ...finialStyle, ...style }}>\n        {this.getChild()}\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来看看 left 组件中，做了什么事情，主要是获取侧边栏左侧自组件的真实宽度，并内置了切换的 Icon 按钮，通过展示/收起交互，进行位置偏移。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport classnames from 'classnames';\nimport { reducePX, transformStringToNumber } from '@common/utils';\n\ninterface IProps {\n  /**\n   * @description 自定义样式\n   */\n  style?: React.CSSProperties;\n  boxRef?: any;\n  key?: string;\n}\n\ninterface IState {\n  /**\n   * @description 是否显示Menu控件\n   */\n  showMenu: boolean;\n  /**\n   * @description 左侧组件DOM宽度\n   */\n  width: number;\n}\n\nclass LeftComponent extends React.Component<IProps, IState> {\n  isTransition: boolean;\n  defaultRef = React.createRef();\n\n  constructor(props: IProps) {\n    super(props);\n    this.state = {\n      showMenu: true,\n      // \uD83D\uDC47 1. 一开始时的宽度是0\n      width: 0,\n    };\n    this.isTransition = false; // 只有点击的时候才加上动画\n  }\n\n  componentDidMount() {\n    // \uD83D\uDC47 2. 这里就是获取父组件给左侧自组件传递的 boxRef\n    if (\n      this.boxRef.current &&\n      this.boxRef.current.children &&\n      this.boxRef.current.children.length > 0 &&\n      this.boxRef.current.children[0].clientWidth\n    ) {\n      // \uD83D\uDC47 3. 获取左侧侧边栏的真实宽度，然后赋值，下面在渲染时会用到\n      this.setState({ width: this.boxRef.current.children[0].clientWidth });\n    }\n  }\n\n  get boxRef() {\n    return this.props.boxRef || this.defaultRef;\n  }\n\n  onChangeMenu = () => {\n    this.setState((prev) => {\n      return {\n        showMenu: !prev.showMenu,\n      };\n    });\n  };\n\n  render() {\n    const { showMenu, width } = this.state;\n    const { key = 'componentLeft', style = {}, children } = this.props;\n    return (\n      <div key={key}>\n        <div\n          ref={this.boxRef}\n          className=\"left-box\"\n          style={{ width, ...style, left: showMenu ? style?.left : -width }}\n        >\n          {children}\n        </div>\n        <div\n          className=\"rect-menu\"\n          style={{\n            left: showMenu\n              ? width + (transformStringToNumber(reducePX(style?.left)) || 0)\n              : 0,\n            transition: this.isTransition ? 'all 0.5s' : 'none',\n          }}\n          onClick={() => {\n            this.onChangeMenu();\n            this.isTransition = true;\n          }}\n        >\n          <div\n            className={classnames('rect-icon', {\n              'rect-icon-hidden': !showMenu,\n            })}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default LeftComponent;\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\n\ninterface IProps {\n  /**\n   * @description 自定义样式\n   */\n  style?: React.CSSProperties;\n  children?: React.ReactNode;\n  key?: string;\n}\n\nclass RightComponent extends React.PureComponent<IProps> {\n  render() {\n    const { key = 'componentRight', style = {}, children } = this.props;\n    return (\n      <div key={key} className=\"right-box\" style={style}>\n        {children}\n      </div>\n    );\n  }\n}\n\nexport default RightComponent;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们的组件编写完毕，用起来试试，前往 ",(0,s.jsx)(n.code,{children:"renderer/container/templateList"})," 修改 index.tsx，我们将代码改写为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// renderer/container/templateList/index.tsx\n\nimport React from 'react';\nimport './index.less';\nimport Header from './Header';\nimport Navigation from './Navigation';\nimport StaticResume from './StaticResume';\n// \uD83D\uDC47 引入\nimport MyRectSize from '@common/components/MyRectSize';\n\nfunction TemplateList() {\n  return (\n    <div styleName=\"container\">\n      <Header />\n      <div styleName=\"content\">\n        <MyRectSize>\n          <MyRectSize.Left>\n            <Navigation />\n          </MyRectSize.Left>\n          <MyRectSize.Right>\n            <StaticResume />\n          </MyRectSize.Right>\n        </MyRectSize>\n      </div>\n    </div>\n  );\n}\nexport default TemplateList;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果你发现接入此组件之后有一些样式上的问题，你需要做一些修改。具体详情可看这里：",(0,s.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/8eddcaf6caa07a2e42f42391e54870673d87b9eb",target:"_blank",rel:"noopener noreferrer",children:"commit"})]}),"\n",(0,s.jsx)(n.p,{children:"至此，我们完成了简历模版列表的实现以及侧边栏的交互效果。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章节功能实现出发，通过初步完成静态效果，让小伙伴们快速实现此需求功能。由于每次都需要手动 import 引入模版封面，于是思考封装 hooks 实现读取模版静态文件夹的方式解决。通过对交互的打磨思考，最终实现侧边栏的动态交互效果。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"如果您在边阅读边实践时，发现代码报错或者 TS 报错，那么小伙伴们可以根据报错信息，去线上看看相应的代码。"})}),"\n",(0,s.jsx)(n.p,{children:"本章节的代码量相对较大，如果对本章节存在疑问，欢迎在评论区留言。"})]})}function y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}let R=y;y.__RSPRESS_PAGE_META={},y.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F15.%E4%B8%9A%E5%8A%A1%E7%AF%87-%E7%AE%80%E5%8E%86%E6%A8%A1%E7%89%88%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BE%A7%E8%BE%B9%E6%A0%8F%E4%BA%A4%E4%BA%92%E6%95%88%E6%9E%9C.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"组件划分",id:"组件划分",depth:2},{text:"添加模版列表入口模块",id:"添加模版列表入口模块",depth:2},{text:"Header 组件实现",id:"header-组件实现",depth:2},{text:"列表侧边栏组件实现",id:"列表侧边栏组件实现",depth:2},{text:"Footer 组件实现",id:"footer-组件实现",depth:2},{text:"静态模版组件展示",id:"静态模版组件展示",depth:2},{text:"\uD83E\uDD14 模版数据显示",id:"-模版数据显示",depth:2},{text:"useReadDirAssetsTemplateHooks",id:"usereaddirassetstemplatehooks",depth:3},{text:"动态显示数据模版列表",id:"动态显示数据模版列表",depth:2},{text:"侧边栏展开收起",id:"侧边栏展开收起",depth:2},{text:"MyRectSize",id:"myrectsize",depth:3},{text:"总结",id:"总结",depth:2}],title:"15.业务篇-简历模版列表实现与侧边栏交互效果",headingTitle:"15.业务篇-简历模版列表实现与侧边栏交互效果",frontmatter:{}}}}]);