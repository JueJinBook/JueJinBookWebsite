"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["42566"],{230522:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var s=r(552676),c=r(740453);let l=r.p+"static/image/74fb4d98fec74a9393de155853af1fe2~tplv-k3u1fbpfcp-zoom-1.image.cce6b4f9.png",d=r.p+"static/image/44e962408ffd49d487bd4f52590d236c~tplv-k3u1fbpfcp-zoom-1.image.406dec66.png",a=r.p+"static/image/2d3a88e2584e4cd4a402d55d10ba1e3b~tplv-k3u1fbpfcp-zoom-1.image.c5b5ca0e.png";function o(e){let n=Object.assign({h1:"h1",a:"a",h3:"h3",h4:"h4",p:"p",strong:"strong",blockquote:"blockquote",pre:"pre",code:"code",br:"br",del:"del",ol:"ol",li:"li",img:"img",h2:"h2"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"26-函数式思想在前端状态管理中的实践下盒子模式--rxjs-篇",children:["26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26-函数式思想在前端状态管理中的实践下盒子模式--rxjs-篇",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"rxjs-核心思想响应式编程",children:["RxJS 核心思想：响应式编程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rxjs-核心思想响应式编程",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"rxjs-是个啥",children:["RxJS 是个啥",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rxjs-是个啥",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["RxJS 是一个在 JavaScript 中实现响应式编程的库，它利用可观察序列（",(0,s.jsx)(n.strong,{children:"Observable"}),"）来表达异步数据流，并通过一系列的操作符（",(0,s.jsx)(n.strong,{children:"Operators"}),"）来对这些数据流进行转换、筛选和组合，最终实现业务逻辑。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注：可观察序列（Observable）这个东西我们下文还会展开讲解，这里大家先记住这个名字就可以了。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"下面是一个简单的 RxJS 示例代码（基于 RxJS6 编写），展示如何基于可观察序列来实现状态管理："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { fromEvent } from 'rxjs'\nimport { map, filter, debounceTime } from 'rxjs/operators'\n\n// 获取输入框 DOM \nconst searchInput = document.getElementById('search-input')\n\n// fromEvent可以将一个 DOM 转换为一个可观察的对象（Observable）\nconst input$ = fromEvent(searchInput, 'input')\n  .pipe(\n    map(event => event.target.value),\n    filter(value => value.length > 2),\n    debounceTime(500)\n  )\n\ninput$.subscribe(value => {\n  console.log(`Performing search with query \"${value}\"...`)\n  // 发起异步请求，并更新页面\n})\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注：在示例中，变量名以 $ 开头是为了表明这是一个流对象。这是 RxJS 的一种（可选的）命名约定，目的是为了帮开发者在代码中快速识别出这是一个流对象，而不是普通的变量或函数。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["上面的代码使用 RxJS 监听了一个输入框的值变化，当输入框的值变化后，我们借助 ",(0,s.jsx)(n.code,{children:"map"})," 操作符将事件对象转换为输入框的值，然后通过 ",(0,s.jsx)(n.code,{children:"filter"})," 操作符过滤掉长度小于等于 2 的输入，最后通过 ",(0,s.jsx)(n.code,{children:"debounceTime"})," 操作符确保用户停止输入一段时间后才会发出值。这样就可以避免在用户快速输入时频繁地执行搜索操作。"]}),"\n",(0,s.jsxs)(n.p,{children:["通过这个示例，我们可以看到 RxJS 中提供了强大的",(0,s.jsx)(n.strong,{children:"操作符"}),"和",(0,s.jsx)(n.strong,{children:"工具函数"}),"，使得我们能够非常方便地对数据流进行处理和转换，从而实现响应式的状态管理。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注：在 RxJS 中，操作符（",(0,s.jsx)(n.strong,{children:"operators"}),"）是用来组合 Observable 的纯函数，用于对 Observable 进行各种转换、过滤、合并等操作。RxJS 中提供了大量的操作符，例如 map、filter、mergeMap、switchMap 等等，楼上我们用到的操作符有 ",(0,s.jsx)(n.code,{children:"map"}),"和",(0,s.jsx)(n.code,{children:"filter"}),"。",(0,s.jsx)(n.br,{}),"\n","而工具函数（",(0,s.jsx)(n.strong,{children:"utility functions"}),"）则是一些不依赖于 Observable 的纯函数，用于处理 Observable 发射出来的值。RxJS 中提供了大量的工具函数，例如 tap、delay、timeout 等等。在楼上的示例中，我们用到的工具函数是 ",(0,s.jsx)(n.code,{children:"fromEvent"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"从函数式编程到响应式编程",children:["从函数式编程到响应式编程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从函数式编程到响应式编程",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["接下来我会试着讨论函数式编程和响应式编程的差异，然后你就会发现，它们",(0,s.jsx)(n.del,{children:"真的没有什么特别的差异（笑死）"})," 真的是非常相似的两个范式。"]}),"\n",(0,s.jsxs)(n.p,{children:["尽管两者的共性非常之多（都属于",(0,s.jsx)(n.strong,{children:"声明式编程"}),"，都",(0,s.jsx)(n.strong,{children:"遵循函数式编程的基本原则"}),"），但差异还是有的，那就是关注点的不同："]}),"\n",(0,s.jsxs)(n.p,{children:["函数式编程强调的是",(0,s.jsx)(n.strong,{children:"函数的组合和变换"}),"，通过将复杂的问题分解成小的函数，再将这些函数组合起来，达到解决问题的目的。函数式编程中，函数是“一等公民”。"]}),"\n",(0,s.jsxs)(n.p,{children:["响应式编程强调的是",(0,s.jsx)(n.strong,{children:"数据流的变化和响应"}),"，它将复杂的问题抽象成一个数据流，通过对数据流进行变换和响应，达到解决问题的目的。响应式编程中，函数仍然是“一等公民”，但它更强调对“数据流”的关注。"]}),"\n",(0,s.jsxs)(n.p,{children:["总之一句话：",(0,s.jsx)(n.strong,{children:"函数式编程关注函数，响应式编程关注数据流"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["话是这么说没错，但是在我看来，个人实在是不习惯去做响应式编程和函数式编程的辨析——目前业内比较广为接受的一种观点是“",(0,s.jsx)(n.strong,{children:"响应式编程是函数式编程的一种扩展和补充"}),"”，这和我个人的观点也是一致的。因此，我们可以把响应式编程视作函数式编程的一个分支流派，",(0,s.jsx)(n.strong,{children:"这个流派在函数式思想的基础上，更加强调对数据流的关注"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"rxjs-对盒子模式的运用",children:["RxJS 对“盒子模式”的运用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rxjs-对盒子模式的运用",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"作为一本函数式编程小册，这里我给大家介绍 RxJS，当然不全是为了做楼上这种老八股式的概念辨析题。我真正的目的，是为了给大家点出两件非常重要的事情："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"“盒子模式”"})," 不是花拳绣腿，它真的",(0,s.jsx)(n.strong,{children:"是可以用来写生产级别的代码的"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Monad"})," 除了可以实现数据转换、可以解决“嵌套盒子”问题，它还可以帮我们【",(0,s.jsx)(n.strong,{children:"把副作用放进盒子"}),"】"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"盒子模式生产实践rxjs-中的-monad-与-functor",children:["“盒子模式”生产实践：RxJS 中的 Monad 与 Functor",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#盒子模式生产实践rxjs-中的-monad-与-functor",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["通过",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422979646423098",target:"_blank",rel:"noopener noreferrer",children:"第 17 节"}),"-",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422691443212348",target:"_blank",rel:"noopener noreferrer",children:"第 19 节"}),"的学习，我们已经知道，Functor 是指实现了",(0,s.jsx)(n.code,{children:"map"}),"函数的盒子，而 Monad 则是指实现了",(0,s.jsx)(n.code,{children:"map"}),"和",(0,s.jsx)(n.code,{children:"flatMap"}),"函数的盒子。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"在 RxJS 中，"})," ",(0,s.jsx)(n.code,{children:"Observable"})," ",(0,s.jsx)(n.strong,{children:"既是一个 Functor，也是一个 Monad。"})]}),"\n",(0,s.jsxs)(n.p,{children:["请看下面这段代码（注意，下面代码基于 ",(0,s.jsx)(n.strong,{children:"RxJS5"})," 编写，在 RxJS6 中，",(0,s.jsx)(n.code,{children:"flatMap"}),"和",(0,s.jsx)(n.code,{children:"map"}),"仍然存在，但是写法没有 RxJS5 这么直观。为了降低大家的理解成本，这里我选择了使用 RxJS5 来写盒子模式的示例） ："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import Rx from "rxjs"\nimport { Observable } from "rxjs/Observable"\n\n// observable 是一个 Observable 类型的盒子，它既是 Functor 也是 Monad\nconst observable = Observable.from([1, 2, 3])\n\n// observable 是一个 Functor，可以调用 Functor 的 map 方法\nconst mappedBox = observable.map((x) => x * 2)\n\n// observable 是一个 Monad，可以调用 Monad 的 flatMap 方法，把嵌套的 Functor 拍平\nconst flattenObservable = observable.flatMap((x) => Observable.from([x, x * 2]))\n\n// 可以通过订阅打印出盒子的内容\n// 输出：1, 2, 3\nobservable.subscribe((val) => console.log(val))\n\n// 输出：2, 4, 6\nmappedBox.subscribe((val) => console.log(val))\n\n// 输出：1, 2, 2, 4, 3, 6\nflattenObservable.subscribe((val) => console.log(val))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["在这个例子中，我们使用 RxJS 的",(0,s.jsx)(n.code,{children:"from"}),"操作符将一个数组转换成了一个",(0,s.jsx)(n.code,{children:"Observable"}),"类型的盒子：",(0,s.jsx)(n.code,{children:"observable"}),"。由于",(0,s.jsx)(n.code,{children:"Observable"}),"盒子实现了",(0,s.jsx)(n.code,{children:"map"}),"函数，我们可以像使用数组的",(0,s.jsx)(n.code,{children:"map"}),"函数一样，对",(0,s.jsx)(n.code,{children:"observable"}),"进行变换得到一个新的",(0,s.jsx)(n.code,{children:"Observable"}),"盒子。这个过程中，",(0,s.jsx)(n.code,{children:"Observable"}),"充当了 ",(0,s.jsx)(n.strong,{children:"Functor"})," 的角色。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"flatMap"}),(0,s.jsx)(n.strong,{children:"函数则不同于"}),(0,s.jsx)(n.code,{children:"map"}),(0,s.jsx)(n.strong,{children:"函数，它不仅可以进行变换，还可以将嵌套的"}),(0,s.jsx)(n.code,{children:"Observable"}),(0,s.jsx)(n.strong,{children:"结构展平。"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["还记得我们",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422691443212348",target:"_blank",rel:"noopener noreferrer",children:"第 19 节"}),"的标题中“嵌套盒子解决方案”这个描述吗？这里就用上啦！"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们通过在 ",(0,s.jsx)(n.code,{children:"flatMap"}),"的回调函数中调用 ",(0,s.jsx)(n.code,{children:"from"}),"方法，将",(0,s.jsx)(n.code,{children:"observable"}),"中的每个元素从数字转换为了",(0,s.jsx)(n.code,{children:"Observable"}),"盒子（对应示例中的第 11 行代码，如下）："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// observable 是一个 Monad，可以调用 Monad 的 flatMap 方法，把嵌套的 Functor 拍平\nconst flattenObservable = observable.flatMap((x) => Observable.from([x, x * 2]))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["由于",(0,s.jsx)(n.code,{children:"observable"}),"本身是一个 ",(0,s.jsx)(n.code,{children:"Observable"}),"盒子，这波转换相当于是在盒子里面套了新的盒子。如果我们调用的是",(0,s.jsx)(n.code,{children:"map"}),"而不是",(0,s.jsx)(n.code,{children:"flatMap"}),"，那么映射出来的结果就会是一个嵌套的盒子。像这样："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const nestedObservable = observable.map((x) => Observable.from([x, x * 2]))\n\nconsole.log("nestedObservable", nestedObservable)\nnestedObservable.subscribe((val) => console.log("val is:", val))\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"nestedObservable"})," 本身是一个盒子，如下图："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"nestedObservable"})," 内部存储的 ",(0,s.jsx)(n.code,{children:"val"})," 也是一系列的盒子，如下图："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["但我们知道，",(0,s.jsx)(n.code,{children:"flatMap"}),"是可以处理嵌套盒子的场景的。这里使用",(0,s.jsx)(n.code,{children:"flatMap"}),"，就可以将嵌套的双层 ",(0,s.jsx)(n.code,{children:"Observable"}),"盒子展开为一个单层的",(0,s.jsx)(n.code,{children:"Observable"}),"对象："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// observable 是一个 Monad，可以调用 Monad 的 flatMap 方法，把嵌套的 Functor 拍平\nconst flattenObservable = observable.flatMap((x) => Observable.from([x, x * 2]))  \n\n// 输出一个 Observable 盒子\nconsole.log("flattenObservable", flattenObservable)    \n\n// 输出具体的 val 值：1、2、2、4、3、6\nflattenObservable.subscribe((val) => console.log("val is:", val))\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["如大家所见，由于同时具备 ",(0,s.jsx)(n.code,{children:"map"}),"能力和",(0,s.jsx)(n.code,{children:"flatMap"}),"能力，所以 ",(0,s.jsx)(n.strong,{children:"Observable 盒子既是一个 Functor，也是一个 Monad"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"monad-的另一面把副作用放进盒子",children:["Monad 的另一面：把“副作用”放进盒子。",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#monad-的另一面把副作用放进盒子",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["当使用 RxJS 时，我们经常会遇到需要在异步数据流中执行副作用的情况，这时 RxJS 就会使用 Monad 来处理这些副作用。这里也就引出了 Monad 的“另一面”：",(0,s.jsx)(n.strong,{children:"把“副作用”放进盒子——我们可以将具有副作用的操作封装在 Monad 中，以便于隔离其它函数对副作用的关注。"})]}),"\n",(0,s.jsx)(n.p,{children:"请大家看这样一个例子（仍然是基于 RxJS5 的）："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import Rx from "rxjs"\nimport { Observable } from "rxjs/Observable"\n\n// 这里我用 setTimeout 模拟一个网络请求\nfunction fetchData() {\n  return Observable.create((observer) => {\n    setTimeout(() => {\n      observer.next("data")\n      observer.complete()\n    }, 1000)\n  })\n}\n\n// 处理数据的纯函数\nfunction processData(data) {\n  return data.toUpperCase()\n}\n\n// 使用副作用放进盒子的方式处理网络请求\nconst boxedData = Observable.of(null).flatMap(() => fetchData())\n\n// 订阅处理结果\nboxedData.map(processData).subscribe((data) => {\n  console.log(data) // 输出 "DATA"\n})\n'})}),"\n",(0,s.jsxs)(n.p,{children:["在上面的例子中，我们将网络请求这个副作用包裹在一个 ",(0,s.jsx)(n.code,{children:"Observable"})," 盒子中（上面已经分析过，",(0,s.jsx)(n.code,{children:"Observable"})," 盒子是一个 Monad），并将盒子的执行结果作为一个值“发射”出去，这个值可以被后续的",(0,s.jsx)(n.code,{children:"map()"}),"操作消费和处理。",(0,s.jsx)(n.strong,{children:"这个过程中，"})," ",(0,s.jsx)(n.code,{children:"Observable"})," ",(0,s.jsx)(n.strong,{children:"就是一个专门用来消化副作用的盒子——它将异步操作封装在内部，防止了副作用的外泄。"})]}),"\n",(0,s.jsxs)(n.p,{children:["这样做有什么好处呢？我们可以注意到，",(0,s.jsx)(n.code,{children:"processData()"})," 是一个",(0,s.jsx)(n.strong,{children:"纯函数"}),"，它负责将传入的数据转换成大写字母，没有任何副作用。我们将 ",(0,s.jsx)(n.code,{children:"processData()"})," 函数传递给 ",(0,s.jsx)(n.code,{children:"map()"})," 方法，",(0,s.jsx)(n.code,{children:"map()"}),"方法就会在原有的 Observable 盒子的每个值上调用这个纯函数，并将处理结果放到新的 Observable 盒子中——",(0,s.jsx)(n.strong,{children:"这整个过程都是纯的"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["大家细品一下这个过程：在整个 ",(0,s.jsx)(n.code,{children:"boxData"}),"盒子的调用链中，",(0,s.jsx)(n.code,{children:"boxData"}),"本身作为一个 Monad 盒子，它是不纯的；末尾的 ",(0,s.jsx)(n.code,{children:"subscribe()"}),"函数涉及到了在控制台输出数据，它也是不纯的。但",(0,s.jsx)(n.strong,{children:"夹在这两者中间的所有"})," ",(0,s.jsx)(n.code,{children:" map()"}),(0,s.jsx)(n.strong,{children:"调用都是纯的"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，这种模式能够帮助我们",(0,s.jsx)(n.strong,{children:"把纯函数和副作用分离开来，保证盒子和"})," ",(0,s.jsx)(n.code,{children:" subscribe()"}),(0,s.jsx)(n.strong,{children:"回调之间的所有逻辑的纯度"}),"。此外，使用 Monad 封装副作用，也可以使代码更加模块化，可维护性更高。"]}),"\n",(0,s.jsxs)(n.h3,{id:"更进一步函数管道将生产端-消费端分离",children:["更进一步：【函数管道】将生产端-消费端分离",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更进一步函数管道将生产端-消费端分离",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 RxJS 中，",(0,s.jsx)(n.code,{children:"Observable"})," 负责生产数据，而 ",(0,s.jsx)(n.code,{children:"Observer"})," 负责消费数据。"]}),"\n",(0,s.jsxs)(n.p,{children:["在楼上的例子中，",(0,s.jsx)(n.code,{children:"boxedData"})," 是一个生产数据的 ",(0,s.jsx)(n.code,{children:"Observable"}),"，而 ",(0,s.jsx)(n.code,{children:"subscribe"})," 方法所传入的回调函数则是消费数据的 ",(0,s.jsx)(n.code,{children:"Observer"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Observable"}),"（生产端）和 ",(0,s.jsx)(n.code,{children:"Observer"}),"（消费端）都可能涉及副作用，例如异步请求、打印日志等等。因此它们都是",(0,s.jsx)(n.strong,{children:"不纯"}),"的。"]}),"\n",(0,s.jsxs)(n.p,{children:["但是，",(0,s.jsx)(n.strong,{children:"那些夹在"})," ",(0,s.jsx)(n.code,{children:"Observable"})," ",(0,s.jsx)(n.strong,{children:"和"})," ",(0,s.jsx)(n.code,{children:"Observer"})," ",(0,s.jsx)(n.strong,{children:"之间的操作，例如"})," ",(0,s.jsx)(n.code,{children:"map"})," ",(0,s.jsx)(n.strong,{children:"、"})," ",(0,s.jsx)(n.code,{children:"filter"})," ",(0,s.jsx)(n.strong,{children:"、"})," ",(0,s.jsx)(n.code,{children:"merge"})," ",(0,s.jsx)(n.strong,{children:"等等，这些操作专注于数据的计算，并不关心数据的来源和去处、不涉及外部环境"}),"，因此它们总是纯的。"]}),"\n",(0,s.jsxs)(n.p,{children:["这也就是说，",(0,s.jsx)(n.strong,{children:"RxJS 背靠函数式编程的思想，在"})," ",(0,s.jsx)(n.code,{children:"Observable"})," ",(0,s.jsx)(n.strong,{children:"和"})," ",(0,s.jsx)(n.code,{children:"Observer"})," ",(0,s.jsx)(n.strong,{children:"之间架起了一条“函数管道”"})," 。生产端 ",(0,s.jsx)(n.code,{children:"Observable"})," 将数据“发射”出去后，数据首先会经过这条“",(0,s.jsx)(n.strong,{children:"管道"}),"”，在“",(0,s.jsx)(n.strong,{children:"管道"}),"”中完成所有的计算工作后，才会抵达消费端 ",(0,s.jsx)(n.code,{children:"Observer"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["对于 RxJS 来说，想和外界发生交互，只能通过管道的首尾两端（也即生产端、消费端）。管道内部是由纯函数组成的，这就保证了整个计算过程的可靠性和可预测性。同时，通过这条“管道”，",(0,s.jsx)(n.strong,{children:"生产端"})," ",(0,s.jsx)(n.code,{children:"Observable"})," ",(0,s.jsx)(n.strong,{children:"和消费端"})," ",(0,s.jsx)(n.code,{children:"Observer"})," ",(0,s.jsx)(n.strong,{children:"被有效地分离，实现了高度的解耦"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["通过这两节的学习，相信大家不仅能够切身感受到 FP 思想对于前端状态管理这个细分领域的影响之深，也会对 FP 三大特征中“",(0,s.jsx)(n.strong,{children:"拥抱纯函数，隔离副作用"}),"”这一点有更深的感悟。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们在小册",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175420951075504188",target:"_blank",rel:"noopener noreferrer",children:"第 4 节"}),"曾经强调过，“",(0,s.jsx)(n.strong,{children:"副作用不是毒药"}),"”："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"对于我们程序员来说，实践纯函数的目的并不是消灭副作用，而是将计算逻辑与副作用做合理的分层解耦，从而提升我们的编码质量和执行效率。   ——本册第 4 节"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Monad 将副作用放进盒子这个模式，正是基于这一思想衍生出来的。RxJS 借助 Monad 将副作用放进 Observable 盒子中、将计算逻辑和副作用进行了分层，更是为我们做了一个绝佳的示范。"}),"\n",(0,s.jsx)(n.p,{children:"但这一模式并不是 RxJS 的专利——作为一个成熟的函数式模式，它在程序世界的应用是非常广泛的：比如 Haskell 中的 IO Monad、Scala 中的 Future Monad、Clojure 中的 Monadic I/O library 以及 Rust 中的 futures-rs 库等等......以这些语言和库为代表的生产级的 Monad 实现，也都会践行用 Monad 来隔离副作用的模式。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}let x=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F26%20%E5%87%BD%E6%95%B0%E5%BC%8F%E6%80%9D%E6%83%B3%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%BC%8F%20%26%20RxJS%20%E7%AF%87.md"]={toc:[{text:"RxJS 核心思想：响应式编程",id:"rxjs-核心思想响应式编程",depth:3},{text:"RxJS 是个啥",id:"rxjs-是个啥",depth:4},{text:"从函数式编程到响应式编程",id:"从函数式编程到响应式编程",depth:4},{text:"RxJS 对“盒子模式”的运用",id:"rxjs-对盒子模式的运用",depth:3},{text:"“盒子模式”生产实践：RxJS 中的 Monad 与 Functor",id:"盒子模式生产实践rxjs-中的-monad-与-functor",depth:3},{text:"Monad 的另一面：把“副作用”放进盒子。",id:"monad-的另一面把副作用放进盒子",depth:3},{text:"更进一步：【函数管道】将生产端-消费端分离",id:"更进一步函数管道将生产端-消费端分离",depth:3},{text:"小结",id:"小结",depth:2}],title:"26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇",headingTitle:"26 函数式思想在前端状态管理中的实践（下）：盒子模式 & RxJS 篇",frontmatter:{}}}}]);