"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["26604"],{889011:function(e,n,c){c.r(n),c.d(n,{default:()=>g});var s=c(552676),r=c(740453);let i=c.p+"static/image/211c77e03c9bcec36302f8950d575d3d.8346ea68.webp",d=c.p+"static/image/7e8f3c722c1eda16a7c274ce0f4e1737.9de266de.webp",l=c.p+"static/image/9340717125b1572cb86bb0b2cd7ab8bd.dd813d45.webp",p=c.p+"static/image/f7f763e06659ffc1cf2b9448e6a12f3c.f28d19ac.webp",a=c.p+"static/image/4998d9b956ae41460eb579e68f7d763c.4b7697ff.webp",h=c.p+"static/image/05bef20e2521437a74cd89853fd070b8.57bc1cec.webp",x=c.p+"static/image/a3393b4020ee851e400bab846f69f718.e9f9b71d.webp",j=c.p+"static/image/97cf8032e433be3666123fe54157dc0c.778d7cee.webp",t=c.p+"static/image/5ca5886d66ad4d1a990f2d989de16b9e.6cca7eee.webp",o=c.p+"static/image/f47de8e94b4060309a35ff96edac0454.47377666.webp",m=c.p+"static/image/2bee8e76a9c8fef9353f49653daa5624.e8da5119.webp";function b(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",ul:"ul",li:"li",h2:"h2"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"43-docker-是怎么实现的",children:["43. Docker 是怎么实现的？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-docker-是怎么实现的",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前面我们学习了 Docker 镜像、容器的各种操作，dockerfile 的编写，dockerignore 和镜像的多阶段构建。"}),"\n",(0,s.jsx)(n.p,{children:"是不是感觉 Docker 也没多少东西？"}),"\n",(0,s.jsx)(n.p,{children:"确实，Docker 用起来还是很简单的，学习成本不高。"}),"\n",(0,s.jsx)(n.p,{children:"那它是怎么实现的呢？"}),"\n",(0,s.jsx)(n.p,{children:"Docker 容器跑起来就像一个独立的系统一样，它是怎么做到的？"}),"\n",(0,s.jsx)(n.p,{children:"如果网页上有两份 aaa、bbb 变量，我们怎么保证它们不冲突呢？"}),"\n",(0,s.jsx)(n.p,{children:"namespace 呀："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"变成 xxx.aaa、xxx.bbb 和 yyy.aaa、yyy.bbb 就不冲突了。"}),"\n",(0,s.jsx)(n.p,{children:"Docker 在一个操作系统上实现多个独立的容器也是这种思路。"}),"\n",(0,s.jsx)(n.p,{children:"linux 操作系统提供了 namespace 机制，可以给进程、用户、网络等分配一个命名空间，这个命名空间下的资源都是独立命名的。"}),"\n",(0,s.jsx)(n.p,{children:"比如 PID namespace，也就是进程的命名空间，所有进程都是在命名空间内独立分配 id 的。"}),"\n",(0,s.jsx)(n.p,{children:"而 IPC namespace 能限制只有这个 namespace 内的进程可以相互通信，不能和 namespace 外的进程通信。"}),"\n",(0,s.jsx)(n.p,{children:"Mount namespace 会创建一个新的文件系统，namespace 内的文件访问都是在这个文件系统之上。"}),"\n",(0,s.jsx)(n.p,{children:"类似这样的 namespace 一共有 6 种："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"PID namespace： 进程 id 的命名空间"}),"\n",(0,s.jsx)(n.li,{children:"IPC namespace： 进程通信的命名空间"}),"\n",(0,s.jsx)(n.li,{children:"Mount namespace：文件系统挂载的命名空间"}),"\n",(0,s.jsx)(n.li,{children:"Network namespace：网络的命名空间"}),"\n",(0,s.jsx)(n.li,{children:"User namespace：用户和用户组的命名空间"}),"\n",(0,s.jsx)(n.li,{children:"UTS namespace：主机名和域名的命名空间"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"通过这 6 种命名空间，Docker 就实现了独立的容器，在容器内运行的代码就像在一个独立的系统里跑一样。"}),"\n",(0,s.jsx)(n.p,{children:"但是只有命名空间的隔离还不够，还得对资源做限制。"}),"\n",(0,s.jsx)(n.p,{children:"比如一个容器占用了太多的资源，那就会导致别的容器受影响。"}),"\n",(0,s.jsx)(n.p,{children:"怎么能限制容器的资源访问呢？"}),"\n",(0,s.jsx)(n.p,{children:"这就需要 linux 操作系统的另一种机制：Control Group。"}),"\n",(0,s.jsx)(n.p,{children:"创建一个 Control Group 可以给它指定参数，比如 cpu 用多少、内存用多少、磁盘用多少，然后加到这个组里的进程就会受到这个限制。"}),"\n",(0,s.jsx)(n.p,{children:"这样，创建容器的时候先创建一个 Control Group，指定资源的限制，然后把容器进程加到这个 Control Group 里，就不会有容器占用过多资源的问题了。"}),"\n",(0,s.jsx)(n.p,{children:"那这样就完美了么？"}),"\n",(0,s.jsx)(n.p,{children:"其实还有一个问题：每个容器都是独立的文件系统，相互独立，而这些文件系统之间可能很大部分都是一样的，同样的内容占据了很大的磁盘空间，会导致浪费。"}),"\n",(0,s.jsx)(n.p,{children:"所以 Docker 设计了一种分层机制："}),"\n",(0,s.jsx)(n.p,{children:"每一层都是不可修改的，也叫做镜像。"}),"\n",(0,s.jsx)(n.p,{children:"要修改就创建个新的层："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后通过一种叫做 UnionFS 的机制把这些层合并起来，变成一个文件系统："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样如果有多个容器内做了文件修改，只要创建不同的层即可，底层的基础镜像是一样的。"}),"\n",(0,s.jsx)(n.p,{children:"我们写的这个 Dockerfile，每一行指令都会生成一层镜像："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"点开 docker 镜像的详情可以看到："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"就上面这个 dockerfile，它对应的镜像就有 20 层。"}),"\n",(0,s.jsx)(n.p,{children:"当然，很多都是一层层通过 FROM 继承下来的。"}),"\n",(0,s.jsx)(n.p,{children:"Docker 通过这种分层的镜像存储，极大的减少了文件系统的磁盘占用。"}),"\n",(0,s.jsx)(n.p,{children:"哪里看出来的呢？"}),"\n",(0,s.jsx)(n.p,{children:"比如 nest 的镜像有 1g 多："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但是很多都是它继承的 node 镜像里的，可以看到每一层用了多少存储空间："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我本地两个 nest 镜像，它们都继承了 node 镜像，这两个合起来有 2g 的存储空间么？"}),"\n",(0,s.jsx)(n.p,{children:"没有，因为下面的镜像层是公用的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果有 10 个这种类似的镜像，之前需要 10g。现在呢？可能不到 2g 就够了。"}),"\n",(0,s.jsx)(n.p,{children:"这就是分层存储的魅力。"}),"\n",(0,s.jsx)(n.p,{children:"而且还可以把这些镜像 push 到 registry 镜像仓库，别人拉下来也可以直接用。"}),"\n",(0,s.jsx)(n.p,{children:"但镜像是不可修改的，那为啥我们可以在容器内写文件呢？"}),"\n",(0,s.jsx)(n.p,{children:"因为容器跑起来会给他多加一个可写层，或者叫容器层："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样容器就能在这里一层写文件了。"}),"\n",(0,s.jsx)(n.p,{children:"当然，再跑一个容器会创建一个新的可写层，另一个容器的可写层的数据就丢了。"}),"\n",(0,s.jsx)(n.p,{children:"所以 Docker 设计了挂载机制，可以挂载数据卷到这个可写层上去。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个数据卷是可以持久化的，再跑个新容器，依然可以把这个 volume 挂上去。"}),"\n",(0,s.jsx)(n.p,{children:"这就是数据卷的作用。"}),"\n",(0,s.jsx)(n.p,{children:"回顾一下 Docker 实现原理的三大基础技术："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Namespace：实现各种资源的隔离"}),"\n",(0,s.jsx)(n.li,{children:"Control Group：实现容器进程的资源访问限制"}),"\n",(0,s.jsx)(n.li,{children:"UnionFS：实现容器文件系统的分层存储，镜像合并"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"都是缺一不可的。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Docker 的实现原理依赖 linux 的 Namespace、Control Group、UnionFS 这三种机制。"}),"\n",(0,s.jsx)(n.p,{children:"Namespace 做资源隔离，Control Group 做容器的资源限制，UnionFS 做文件系统的分层镜像存储、镜像合并。"}),"\n",(0,s.jsx)(n.p,{children:"我们通过 dockerfile 描述镜像构建的过程，每一条指令都是一个镜像层。"}),"\n",(0,s.jsx)(n.p,{children:"镜像通过 docker run 就可以跑起来，对外提供服务，这时会添加一个可写层（容器层）。"}),"\n",(0,s.jsx)(n.p,{children:"挂载一个 volume 数据卷到 Docker 容器，就可以实现数据的持久化。"}),"\n",(0,s.jsx)(n.p,{children:"这就是 Docker 的实现原理。"})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}let g=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F43.%20Docker%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"43. Docker 是怎么实现的？",headingTitle:"43. Docker 是怎么实现的？",frontmatter:{}}}}]);