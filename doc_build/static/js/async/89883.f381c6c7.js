"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["89883"],{38468:function(e,n,c){c.r(n),c.d(n,{default:()=>j});var s=c(552676),i=c(740453);let p=c.p+"static/image/361ab5f915a446db8db433f60996bd92~tplv-k3u1fbpfcp-zoom-1.image.2a00f702.png",r=c.p+"static/image/71658f7803864aa999f8e33370b5e93f~tplv-k3u1fbpfcp-zoom-1.image.c69796f1.png",d=c.p+"static/image/bc6e25ab292b433389d99280058d169b~tplv-k3u1fbpfcp-zoom-1.image.1c8c9edc.png",l=c.p+"static/image/ae9a8c25da8e44fcab4ab393e40a6a49~tplv-k3u1fbpfcp-zoom-1.image.0802d9ce.png",a=c.p+"static/image/ad5509a0c9e04d8f8cc7a417ccb19ccc~tplv-k3u1fbpfcp-zoom-1.image.60c9f033.png",o=c.p+"static/image/9d0eed4a85a54046b0c8ee9e7ef679ed~tplv-k3u1fbpfcp-zoom-1.image.77f196c8.png",h=c.p+"static/image/6c2577e6fee64879b03dce5b053a3ddf~tplv-k3u1fbpfcp-zoom-1.image.0c1b0961.png";function u(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",blockquote:"blockquote",code:"code",strong:"strong",pre:"pre"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"14-深入函数组合composition思想composepipe-是如何实现的",children:["14 深入函数组合(Composition)思想：composepipe 是如何实现的",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14-深入函数组合composition思想composepipe-是如何实现的",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"$\\color{LightPink}{保姆式教学の}\\color{Pink}{温情提示：}$"}),"\n",(0,s.jsx)(n.p,{children:"徒手编码 compose/pipe，是当下前端面试考察函数式编程的最通用、最高频 code test 题目。"}),"\n",(0,s.jsx)(n.p,{children:"任何涉及到“函数”、“组合”、“串联”、“管道”等字眼的面试题，多少都需要大家往这方面联想一下。"}),"\n",(0,s.jsx)(n.p,{children:"相关的提问姿势包括但不限于："}),"\n",(0,s.jsx)(n.p,{children:"“如何 pipe 一系列的指定函数？”"}),"\n",(0,s.jsx)(n.p,{children:"“函数组合（compose）是一个什么样的过程？”"}),"\n",(0,s.jsx)(n.p,{children:"“rambda（或者任何一个函数式编程库）中的 compose/pipe 是如何实现的？”"}),"\n",(0,s.jsx)(n.p,{children:"“Redux 中间件是如何串联的？”"}),"\n",(0,s.jsx)(n.p,{children:"等等等等......."}),"\n",(0,s.jsx)(n.p,{children:"不夸张地说，这是一门背也要背下来的学问。"}),"\n",(0,s.jsx)(n.p,{children:"它至少可以帮你向面试官证明，你真的能够实战函数式编程，而不是只会记忆几个 lodash-fp 或 React Hook 的 API。"}),"\n",(0,s.jsx)(n.p,{children:"如果你的时间有限，不允许你细嚼慢咽整本小册覆盖的所有知识点，请你至少把握住这一节——在面试场景下，它将助你摆脱“函数式小白”的标签。"}),"\n",(0,s.jsxs)(n.h2,{id:"借助-reduce-推导函数组合",children:["借助 reduce 推导函数组合",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#借助-reduce-推导函数组合",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"事已至此，让我们重新审视一遍 reduce 的工作流示意："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422666629709884",target:"_blank",rel:"noopener noreferrer",children:"第12节"}),"的末尾，我曾经这样疯狂暗示了大家一波："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"咱就是说，有没有可能，有没有可能咱们把 pipeline 里的每一个函数也弄成不一样的呢？"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["更直白地说，你",(0,s.jsx)(n.code,{children:"  reduce()  "}),"既然都能组合参数了，你能不能帮我的 pipeline 组合一下函数呢？"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"毕竟，JS 的函数是可以作为参数传递的嘛！"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"一旦我们能做到这一点——一旦我们可以把 reduce pipeline 里的最小计算单元修改成任意不同的函数，那么这个工作流就会变成下面这样了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这个流程，恰恰就是一个函数组合的 pipeline。"}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，只要我们能够想办法",(0,s.jsx)(n.strong,{children:"让 reduce 工作流里的计算单元从一个函数转变为 N 个函数"}),"，我们",(0,s.jsx)(n.strong,{children:"就可以达到函数组合的目的"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"大家知道，在整个 reduce 的工作流中，callback 是锁死的，但每次调用 callback 时传入的参数是动态可变的（如下图）。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这些动态可变的参数，来自 reduce 的宿主数组。"}),"\n",(0,s.jsx)(n.p,{children:"之前介绍 reduce 时，我们用了一个塞满数字的数组作为示例。"}),"\n",(0,s.jsxs)(n.p,{children:["但其实，数组的元素可以是任何类型——包括",(0,s.jsx)(n.strong,{children:"函数"}),"类型。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们把",(0,s.jsx)(n.strong,{children:"待组合的函数放进一个数组里，然后调用这个函数数组的 reduce 方法"}),"，就可以创建一个多个函数组成的工作流。"]}),"\n",(0,s.jsx)(n.p,{children:"而这，正是市面上主流的函数式库实现 compose/pipe 函数的思路。"}),"\n",(0,s.jsxs)(n.h2,{id:"借助-reduce-推导-pipe",children:["借助 reduce 推导 pipe",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#借助-reduce-推导-pipe",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"顺着这个思路，我们来考虑这样一个函数数组："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const funcs = [func1, func2, func3]\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们假设三个 func 均是用于数学计算的函数，整个工作流的任务就是吃进一个数字 0 作为入参、吐出一个计算结果作为出参。"}),"\n",(0,s.jsx)(n.p,{children:"我想要逐步地组合调用 funcs 数组里的函数，得到一个这样的声明式数据流："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果我借助了 reduce，我得到的数据流乍一看和楼上是有出入的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如何通过调整 reduce 的调用，使它的工作流和声明式数据流看齐呢？"}),"\n",(0,s.jsx)(n.p,{children:"首先是入参的对齐，这个比较简单，我们只需要把 initialValue 设定为 0 就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"入参明确后，我的 reduce 调用长这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const funcs = [func1, func2, func3]  \n\nfuns.reduce(callback, 0)\n"})}),"\n",(0,s.jsx)(n.p,{children:"接下来重点在于 callback 怎么实现。其实我们只需要把楼上两张图放在一起做个对比，答案就呼之欲出了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"图中我用红笔对 reduce 流程做了拆分，用蓝笔对目标数据流做了拆分。"}),"\n",(0,s.jsx)(n.p,{children:"想要让上下两个流程等价，我们只需要确保红蓝两个圈圈的工作内容总是等价就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"从第一对红蓝圈圈开始看起，蓝色圈圈的工作内容是 func1(0)，红色圈圈的工作内容是 callback(0, func1)。"}),"\n",(0,s.jsx)(n.p,{children:"两者等价，意味着 callback(0, func1) = func1(0)。"}),"\n",(0,s.jsx)(n.p,{children:"同理，我们可以逐步推导出第二个、第三个红色圈圈的工作内容，分别应该满足："}),"\n",(0,s.jsx)(n.p,{children:"callback(value1, func2) = func2(value1)"}),"\n",(0,s.jsx)(n.p,{children:"callback(value2, func3) = func3(value2)"}),"\n",(0,s.jsx)(n.p,{children:"以此类推，对于任意的入参 (input, func），callback 都应该满足："}),"\n",(0,s.jsx)(n.p,{children:"callback(input, func) = func(input)"}),"\n",(0,s.jsx)(n.p,{children:"推导至此，我们就得到了 callback 的实现："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function callback(input, func) {\n  func(input)\n}  \n\nfuncs.reduce(callback,0)\n"})}),"\n",(0,s.jsx)(n.p,{children:"再稍微包装一下，给这坨逻辑起一个新名字："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function pipe(funcs) {\n  function callback(input, func) {\n    return func(input)\n  }  \n\n  return function(param) {\n    return funcs.reduce(callback,param)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们就得到了一个经典的 pipe 函数。"}),"\n",(0,s.jsxs)(n.h2,{id:"验证-pipe串联数字计算逻辑",children:["验证 pipe：串联数字计算逻辑",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#验证-pipe串联数字计算逻辑",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"长得帅的同学想必都还记得这三个函数："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function add4(num) {\n  return num + 4\n}  \n\nfunction multiply3(num) {\n  return num*3\n}  \n\nfunction divide2(num) {\n  return num/2\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"问：如何基于这些独立函数，构建一个多个函数串行执行的工作流？"}),"\n",(0,s.jsx)(n.p,{children:"现在有了 pipe，我们可以轻松达到这个目的。只需要把这些函数放进一个数组里，再把数组放进 pipe 里："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const compute = pipe([add4, multiply3, divide2])\n"})}),"\n",(0,s.jsx)(n.p,{children:"如此，我们便能够得到一个 compute 的函数，该函数正是 add4, multiply3, divide2 这三个函数的“合体”版本。"}),"\n",(0,s.jsx)(n.p,{children:"接下来直接调用 compute() 函数，就可以开动“传送带”，得到目标的计算结果了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 输出 21\nconsole.log(compute(10))\n"})}),"\n",(0,s.jsx)(n.p,{children:"美中不足的是手动构造数组有点麻烦，我们可以直接使用展开符来获取数组格式的 pipe 参数："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 使用展开符来获取数组格式的 pipe 参数\nfunction pipe(...funcs) {\n  function callback(input, func) {\n    return func(input)\n  }  \n\n  return function(param) {\n    return funcs.reduce(callback,param)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"由此我们就可以向 pipe 传入任意多的函数，组合任意长的函数工作流了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const funcFlow = pipe(method1, method2, method3, method4,...., methodN)\n"})}),"\n",(0,s.jsx)(n.p,{children:"至此，我们便实现了一个通用的 pipe 函数。"}),"\n",(0,s.jsxs)(n.h2,{id:"compose倒序的-pipe",children:["compose：倒序的 pipe",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compose倒序的-pipe",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"pipe 用于创建一个正序的函数传送带，而 compose 则用于创建一个倒序的函数传送带。"}),"\n",(0,s.jsx)(n.p,{children:"我们把 pipe 函数里的 reduce 替换为 reduceRight，就能够得到一个 compose："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 使用展开符来获取数组格式的 pipe 参数\nfunction compose(...funcs) {\n  function callback(input, func) {\n    return func(input)\n  }  \n\n  return function(param) {\n    return funcs.reduceRight(callback,param)\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"使用 compose 创建同样的一个函数工作流，我们需要把入参倒序传递，如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const compute = compose(divide2, multiply3, add4)\n"})}),"\n",(0,s.jsx)(n.p,{children:"组合后的流水线顺序，和传参的顺序是相反的。也就是说执行 compute 时，函数的执行顺序是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"正序是 pipe，倒序是 compose。"})}),"\n",(0,s.jsxs)(n.p,{children:["pipe 和 compose 的辨析，本身也是一个热门的考察点。在面试场景下，大家一定要听清楚面试官的要求，写代码前先确认需求是【",(0,s.jsx)(n.strong,{children:"Pipe--\x3e"})," 】一系列函数还是【",(0,s.jsx)(n.strong,{children:"Compose<--"}),"】一系列函数。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["作者注：为什么 pipe 是正序，compose 是倒序？关于这个问题，我们在 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422979646423098",target:"_blank",rel:"noopener noreferrer",children:"第17节"}),"还有更进一步的讨论，感兴趣的同学可以关注第17节的“复合运算：范畴论在编程中最核心的应用”这个section"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"知其所以然why-compose",children:["知其所以然：Why Compose?",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知其所以然why-compose",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["面向对象的核心在于继承，而",(0,s.jsx)(n.strong,{children:"函数式编程的核心则在于组合"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们常说函数式编程就像一个乐高游戏：那一个个独立内聚的函数就像一堆乐高积木方块儿。它们看似渺小到无足轻重，却可以在",(0,s.jsx)(n.strong,{children:"组合"}),"后变幻出千百种形态、最终呈现出复杂而强大的功能。"]}),"\n",(0,s.jsx)(n.p,{children:"组合这个动词，赋予了函数式编程无限的想象力和可能性。"}),"\n",(0,s.jsxs)(n.p,{children:["在函数式编程的实践中，我们正是",(0,s.jsx)(n.strong,{children:"借助 compose 来组合多个函数的功能"}),"，它",(0,s.jsx)(n.strong,{children:"是函数式编程中最有代表性的一个工具函数"}),"，所以它才会成为面试题中的常客。"]}),"\n",(0,s.jsx)(n.p,{children:"在编码层面，如果不喜欢 reduce，你还可以借助循环、递归等姿势来实现 compose。"}),"\n",(0,s.jsx)(n.p,{children:"这里我选取了 reduce，一方面是因为它足够主流（市面流行的函数式编程库 ramda 也采取了基于 reduce 的实现），另一方面也是因为它足够巧妙。"}),"\n",(0,s.jsx)(n.p,{children:"巧妙到什么程度呢？结合个人的经验来看，在实际的编码和面试中，基于 reduce 的 compose 几乎是理解成本最高、同时也是许多同学避之不及的一个版本。"}),"\n",(0,s.jsx)(n.p,{children:"许多能力是可以向下兼容的，包括 compose 的实现。"}),"\n",(0,s.jsx)(n.p,{children:"我相信对多数同学来说，读懂一段循环代码或者递归代码都不会是特别难的事情。"}),"\n",(0,s.jsx)(n.p,{children:"然而，如果你之前没有刻意练习过从 reduce 到 compose 的推导过程，那么第一次见到类似代码的时候，即便能够勉强理解代码的意图，也未必能够灵机一动把眼前的 reduce 调用和函数组合联系起来。"}),"\n",(0,s.jsx)(n.p,{children:"但经过了近几节的学习，相信大家早已对 reduce 刮目相看了。"}),"\n",(0,s.jsxs)(n.p,{children:["当你再次在别人写的代码中见到 reduce 时，脑海中闪现的关键字除了“数组、斐波那契”等等之外，不要忘了还有“",(0,s.jsx)(n.strong,{children:"函数组合"}),"”。"]}),"\n",(0,s.jsx)(n.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}let j=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F14%20%E6%B7%B1%E5%85%A5%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88(Composition)%E6%80%9D%E6%83%B3%EF%BC%9Acomposepipe%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84.md"]={toc:[{text:"借助 reduce 推导函数组合",id:"借助-reduce-推导函数组合",depth:2},{text:"借助 reduce 推导 pipe",id:"借助-reduce-推导-pipe",depth:2},{text:"验证 pipe：串联数字计算逻辑",id:"验证-pipe串联数字计算逻辑",depth:2},{text:"compose：倒序的 pipe",id:"compose倒序的-pipe",depth:2},{text:"知其所以然：Why Compose?",id:"知其所以然why-compose",depth:2}],title:"14 深入函数组合(Composition)思想：composepipe 是如何实现的",headingTitle:"14 深入函数组合(Composition)思想：composepipe 是如何实现的",frontmatter:{}}}}]);