"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56388"],{584160:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var l=r(552676),s=r(740453);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",img:"img",ol:"ol",li:"li"},(0,s.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{id:"40源码-8精益求精--lfu-vs-lru",children:["40源码 8：精益求精 —— LFU vs LRU",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#40源码-8精益求精--lfu-vs-lru",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"在第 27 小节，我们讲到了 Redis 的 LRU 模式，它可以有效的控制 Redis 占用内存大小，将冷数据从内存中淘汰出去。Antirez 在 Redis 4.0 里引入了一个新的淘汰策略 —— LFU 模式，作者认为它比 LRU 更加优秀。"}),"\n",(0,l.jsxs)(n.p,{children:["LFU 的全称是",(0,l.jsx)(n.code,{children:"Least Frequently Used"}),"，表示按最近的访问频率进行淘汰，它比 LRU 更加精准地表示了一个 key 被访问的热度。"]}),"\n",(0,l.jsx)(n.p,{children:"如果一个 key 长时间不被访问，只是刚刚偶然被用户访问了一下，那么在使用 LRU 算法下它是不容易被淘汰的，因为 LRU 算法认为当前这个 key 是很热的。而 LFU 是需要追踪最近一段时间的访问频率，如果某个 key 只是偶然被访问一次是不足以变得很热的，它需要在近期一段时间内被访问很多次才有机会被认为很热。"}),"\n",(0,l.jsxs)(n.h2,{id:"redis-对象的热度",children:["Redis 对象的热度",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#redis-对象的热度",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"Redis 的所有对象结构头中都有一个 24bit 的字段，这个字段用来记录对象的「热度」。"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"// redis 的对象头\ntypedef struct redisObject {\n    unsigned type:4; // 对象类型如 zset/set/hash 等等\n    unsigned encoding:4; // 对象编码如 ziplist/intset/skiplist 等等\n    unsigned lru:24; // 对象的「热度」\n    int refcount; // 引用计数\n    void *ptr; // 对象的 body\n} robj;\n"})}),"\n",(0,l.jsxs)(n.h2,{id:"lru-模式",children:["LRU 模式",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#lru-模式",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["在 LRU 模式下，lru 字段存储的是 Redis 时钟",(0,l.jsx)(n.code,{children:"server.lruclock"}),"，Redis 时钟是一个 24bit 的整数，默认是 Unix 时间戳对 2^24 取模的结果，大约 97 天清零一次。当某个 key 被访问一次，它的对象头的 lru 字段值就会被更新为",(0,l.jsx)(n.code,{children:"server.lruclock"}),"。"]}),"\n",(0,l.jsxs)(n.p,{children:["默认 Redis 时钟值每毫秒更新一次，在定时任务",(0,l.jsx)(n.code,{children:"serverCron"}),"里主动设置。Redis 的很多定时任务都是在",(0,l.jsx)(n.code,{children:"serverCron"}),"里面完成的，比如大型 hash 表的渐进式迁移、过期 key 的主动淘汰、触发 bgsave、bgaofrewrite 等等。"]}),"\n",(0,l.jsxs)(n.p,{children:["如果",(0,l.jsx)(n.code,{children:"server.lruclock"}),"没有折返 (对 2^24 取模)，它就是一直递增的，这意味着对象的 LRU 字段不会超过",(0,l.jsx)(n.code,{children:"server.lruclock"}),"的值。如果超过了，说明",(0,l.jsx)(n.code,{children:"server.lruclock"}),"折返了。通过这个逻辑就可以精准计算出对象多长时间没有被访问——对象的空闲时间。"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/8/6/1650e756e1ce8b9a?w=1284&h=146&f=png&s=21164",alt:""})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"// 计算对象的空闲时间，也就是没有被访问的时间，返回结果是毫秒\nunsigned long long estimateObjectIdleTime(robj *o) {\n    unsigned long long lruclock = LRU_CLOCK(); // 获取 redis 时钟，也就是 server.lruclock 的值\n    if (lruclock >= o->lru) {\n        // 正常递增\n        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION; // LRU_CLOCK_RESOLUTION 默认是 1000\n    } else {\n        // 折返了\n        return (lruclock + (LRU_CLOCK_MAX - o->lru)) * // LRU_CLOCK_MAX 是 2^24-1\n                    LRU_CLOCK_RESOLUTION;\n    }\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"有了对象的空闲时间，就可以相互之间进行比较谁新谁旧，随机 LRU 算法靠的就是比较对象的空闲时间来决定谁该被淘汰了。"}),"\n",(0,l.jsxs)(n.h2,{id:"lfu-模式",children:["LFU 模式",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#lfu-模式",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["在 LFU 模式下，lru 字段 24 个 bit 用来存储两个值，分别是",(0,l.jsx)(n.code,{children:"ldt(last decrement time)"}),"和",(0,l.jsx)(n.code,{children:"logc(logistic counter)"}),"。"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/8/6/1650e8f382f31205?w=601&h=93&f=png&s=10013",alt:""})}),"\n",(0,l.jsxs)(n.p,{children:["logc 是 8 个 bit，用来存储访问频次，因为 8 个 bit 能表示的最大整数值为 255，存储频次肯定远远不够，所以这 8 个 bit 存储的是频次的对数值，并且这个值还会随时间衰减。如果它的值比较小，那么就很容易被回收。为了确保新创建的对象不被回收，新对象的这 8 个 bit 会初始化为一个大于零的值，默认是",(0,l.jsx)(n.code,{children:"LFU_INIT_VAL=5"}),"。"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/8/6/1650e9c135644d19?w=1298&h=150&f=png&s=23124",alt:""})}),"\n",(0,l.jsx)(n.p,{children:"ldt 是 16 个位，用来存储上一次 logc 的更新时间，因为只有 16 位，所以精度不可能很高。它取的是分钟时间戳对 2^16 进行取模，大约每隔 45 天就会折返。同 LRU 模式一样，我们也可以使用这个逻辑计算出对象的空闲时间，只不过精度是分钟级别的。图中的 server.unixtime 是当前 redis 记录的系统时间戳，和 server.lruclock 一样，它也是每毫秒更新一次。"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"// nowInMinutes\n// server.unixtime 为 redis 缓存的系统时间戳\nunsigned long LFUGetTimeInMinutes(void) {\n    return (server.unixtime/60) & 65535;\n}\n\n// idle_in_minutes\nunsigned long LFUTimeElapsed(unsigned long ldt) {\n    unsigned long now = LFUGetTimeInMinutes();\n    if (now >= ldt) return now-ldt; // 正常比较\n    return 65535-ldt+now; // 折返比较\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"ldt 的值和 LRU 模式的 lru 字段不一样的是 ldt 不是在对象被访问时更新的。它在 Redis 的淘汰逻辑进行时进行更新，淘汰逻辑只会在内存达到 maxmemory 的设置时才会触发，在每一个指令的执行之前都会触发。每次淘汰都是采用随机策略，随机挑选若干个 key，更新这个 key 的「热度」，淘汰掉「热度」最低的。因为 Redis 采用的是随机算法，如果 key 比较多的话，那么 ldt 更新的可能会比较慢。不过既然它是分钟级别的精度，也没有必要更新的过于频繁。"}),"\n",(0,l.jsxs)(n.p,{children:["ldt 更新的同时也会一同衰减 logc 的值，衰减也有特定的算法。它将现有的 logc 值减去对象的空闲时间 (分钟数) 除以一个衰减系数，默认这个衰减系数",(0,l.jsx)(n.code,{children:"lfu_decay_time"}),"是 1。如果这个值大于 1，那么就会衰减的比较慢。如果它等于零，那就表示不衰减，它是可以通过配置参数",(0,l.jsx)(n.code,{children:"lfu-decay-time"}),"进行配置。"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"// 衰减 logc\nunsigned long LFUDecrAndReturn(robj *o) {\n    unsigned long ldt = o->lru >> 8; // 前 16bit\n    unsigned long counter = o->lru & 255; // 后 8bit 为 logc\n    // num_periods 为即将衰减的数量\n    unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;\n    if (num_periods)\n        counter = (num_periods > counter) ? 0 : counter - num_periods;\n    return counter;\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["logc 的更新和 LRU 模式的 lru 字段一样，都会在 key 每次被访问的时候更新，只不过它的更新不是简单的",(0,l.jsx)(n.code,{children:"+1"}),"，而是采用概率法进行递增，因为 logc 存储的是访问计数的对数值，不能直接",(0,l.jsx)(n.code,{children:"+1"}),"。"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"/* Logarithmically increment a counter. The greater is the current counter value\n * the less likely is that it gets really implemented. Saturate it at 255. */\n// 对数递增计数值\nuint8_t LFULogIncr(uint8_t counter) {\n    if (counter == 255) return 255; // 到最大值了，不能在增加了\n    double baseval = counter - LFU_INIT_VAL; // 减去新对象初始化的基数值 (LFU_INIT_VAL 默认是 5)\n    // baseval 如果小于零，说明这个对象快不行了，不过本次 incr 将会延长它的寿命\n    if (baseval < 0) baseval = 0; \n    // 当前计数越大，想要 +1 就越困难\n    // lfu_log_factor 为困难系数，默认是 10\n    // 当 baseval 特别大时，最大是 (255-5)，p 值会非常小，很难会走到 counter++ 这一步\n    // p 就是 counter 通往 [+1] 权力的门缝，baseval 越大，这个门缝越窄，通过就越艰难\n    double p = 1.0/(baseval*server.lfu_log_factor+1);\n    // 开始随机看看能不能从门缝挤进去\n    double r = (double)rand()/RAND_MAX; // 0 < r < 1\n    if (r < p) counter++;\n    return counter;\n}\n"})}),"\n",(0,l.jsxs)(n.h2,{id:"为什么-redis-要缓存系统时间戳",children:["为什么 Redis 要缓存系统时间戳？",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么-redis-要缓存系统时间戳",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["我们平时使用系统时间戳时，常常是不假思索地使用",(0,l.jsx)(n.code,{children:"System.currentTimeInMillis"}),"或者",(0,l.jsx)(n.code,{children:"time.time()"}),"来获取系统的毫秒时间戳。Redis 不能这样，因为每一次获取系统时间戳都是一次系统调用，系统调用相对来说是比较费时间的，作为单线程的 Redis 表示承受不起，所以它需要对时间进行缓存，获取时间都直接从缓存中直接拿。"]}),"\n",(0,l.jsxs)(n.h2,{id:"redis-为什么在获取-lruclock-时使用原子操作",children:["redis 为什么在获取 lruclock 时使用原子操作？",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#redis-为什么在获取-lruclock-时使用原子操作",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"我们知道 Redis 是单线程的，那为什么 lruclock 要使用原子操作 atomicGet 来获取呢？"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:"unsigned int LRU_CLOCK(void) {\n    unsigned int lruclock;\n    if (1000/server.hz <= LRU_CLOCK_RESOLUTION) {\n        // 这里原子操作，通常会走这里，我们只需要注意这里\n        atomicGet(server.lruclock,lruclock);  \n    } else {\n        // 直接通过系统调用获取时间戳，hz 配置的太低 (一般不会这么干)，lruclock 更新不及时，需要实时获取系统时间戳\n        lruclock = getLRUClock(); \n    }\n    return lruclock;\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"因为 Redis 实际上并不是单线程，它背后还有几个异步线程也在默默工作。这几个线程也要访问 Redis 时钟，所以 lruclock 字段是需要支持多线程读写的。使用 atomic 读写能保证多线程 lruclock 数据的一致性。"}),"\n",(0,l.jsxs)(n.h2,{id:"如何打开-lfu-模式",children:["如何打开 LFU 模式？",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何打开-lfu-模式",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["Redis 4.0 给淘汰策略配置参数",(0,l.jsx)(n.code,{children:"maxmemory-policy"}),"增加了 2 个选项，分别是 volatile-lfu 和 allkeys-lfu，分别是对带过期时间的 key 进行 lfu 淘汰以及对所有的 key 执行 lfu 淘汰算法。打开了这个选项之后，就可以使用 ",(0,l.jsx)(n.code,{children:"object freq"}),"指令获取对象的 lfu 计数值了。"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'> config set maxmemory-policy allkeys-lfu\nOK\n> set codehole yeahyeahyeah\nOK\n// 获取计数值，初始化为 LFU_INIT_VAL=5\n> object freq codehole\n(integer) 5\n// 访问一次\n> get codehole\n"yeahyeahyeah"\n// 计数值增加了\n> object freq codehole\n(integer) 6\n'})}),"\n",(0,l.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"你能尝试使用 py 或者 Java 写一个简单的 LFU 算法么？"}),"\n",(0,l.jsx)(n.li,{children:"如果一开始使用 LRU 模式，突然改变配置变成了 LFU 模式，想象一下 Redis 对象头的 lru 字段值，会对现有的对象产生什么影响？"}),"\n"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(i,{...e})}):i(e)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F40%E6%BA%90%E7%A0%81%208%EF%BC%9A%E7%B2%BE%E7%9B%8A%E6%B1%82%E7%B2%BE%20%E2%80%94%E2%80%94%20LFU%20vs%20LRU.md"]={toc:[{text:"Redis 对象的热度",id:"redis-对象的热度",depth:2},{text:"LRU 模式",id:"lru-模式",depth:2},{text:"LFU 模式",id:"lfu-模式",depth:2},{text:"为什么 Redis 要缓存系统时间戳？",id:"为什么-redis-要缓存系统时间戳",depth:2},{text:"redis 为什么在获取 lruclock 时使用原子操作？",id:"redis-为什么在获取-lruclock-时使用原子操作",depth:2},{text:"如何打开 LFU 模式？",id:"如何打开-lfu-模式",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"40源码 8：精益求精 —— LFU vs LRU",headingTitle:"40源码 8：精益求精 —— LFU vs LRU",frontmatter:{}}}}]);