"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["32562"],{714678:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var r=s(552676),c=s(740453);function o(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",h3:"h3",ul:"ul",li:"li"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"23class-的继承",children:["23.Class 的继承",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23class-的继承",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"简介",children:["简介",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简介",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Class 可以通过",(0,r.jsx)(n.code,{children:"extends"}),"关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Point {\n}\n\nclass ColorPoint extends Point {\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，",(0,r.jsx)(n.code,{children:"Point"}),"是父类，",(0,r.jsx)(n.code,{children:"ColorPoint"}),"是子类，它通过",(0,r.jsx)(n.code,{children:"extends"}),"关键字，继承了",(0,r.jsx)(n.code,{children:"Point"}),"类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个",(0,r.jsx)(n.code,{children:"Point"}),"类。"]}),"\n",(0,r.jsxs)(n.p,{children:["下面，我们在",(0,r.jsx)(n.code,{children:"ColorPoint"}),"内部加上代码。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，",(0,r.jsx)(n.code,{children:"constructor()"}),"方法和",(0,r.jsx)(n.code,{children:"toString()"}),"方法内部，都出现了",(0,r.jsx)(n.code,{children:"super"}),"关键字。",(0,r.jsx)(n.code,{children:"super"}),"在这里表示父类的构造函数，用来新建一个父类的实例对象。"]}),"\n",(0,r.jsxs)(n.p,{children:["ES6 规定，子类必须在",(0,r.jsx)(n.code,{children:"constructor()"}),"方法中调用",(0,r.jsx)(n.code,{children:"super()"}),"，否则就会报错。这是因为子类自己的",(0,r.jsx)(n.code,{children:"this"}),"对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用",(0,r.jsx)(n.code,{children:"super()"}),"方法，子类就得不到自己的",(0,r.jsx)(n.code,{children:"this"}),"对象。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor() {\n  }\n}\n\nlet cp = new ColorPoint(); // ReferenceError\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"ColorPoint"}),"继承了父类",(0,r.jsx)(n.code,{children:"Point"}),"，但是它的构造函数没有调用",(0,r.jsx)(n.code,{children:"super()"}),"，导致新建实例时报错。"]}),"\n",(0,r.jsxs)(n.p,{children:["为什么子类的构造函数，一定要调用",(0,r.jsx)(n.code,{children:"super()"}),"？原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用",(0,r.jsx)(n.code,{children:"super()"}),"方法，因为这一步会生成一个继承父类的",(0,r.jsx)(n.code,{children:"this"}),"对象，没有这一步就无法继承父类。"]}),"\n",(0,r.jsx)(n.p,{children:"注意，这意味着新建子类实例时，父类的构造函数必定会先运行一次。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Foo {\n  constructor() {\n    console.log(1);\n  }\n}\n\nclass Bar extends Foo {\n  constructor() {\n    super();\n    console.log(2);\n  }\n}\n\nconst bar = new Bar();\n// 1\n// 2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，子类 Bar 新建实例时，会输出1和2。原因就是子类构造函数调用",(0,r.jsx)(n.code,{children:"super()"}),"时，会执行一次父类构造函数。"]}),"\n",(0,r.jsxs)(n.p,{children:["另一个需要注意的地方是，在子类的构造函数中，只有调用",(0,r.jsx)(n.code,{children:"super()"}),"之后，才可以使用",(0,r.jsx)(n.code,{children:"this"}),"关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有",(0,r.jsx)(n.code,{children:"super()"}),"方法才能让子类实例继承父类。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，子类的",(0,r.jsx)(n.code,{children:"constructor()"}),"方法没有调用",(0,r.jsx)(n.code,{children:"super()"}),"之前，就使用",(0,r.jsx)(n.code,{children:"this"}),"关键字，结果报错，而放在",(0,r.jsx)(n.code,{children:"super()"}),"之后就是正确的。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果子类没有定义",(0,r.jsx)(n.code,{children:"constructor()"}),"方法，这个方法会默认添加，并且里面会调用",(0,r.jsx)(n.code,{children:"super()"}),"。也就是说，不管有没有显式定义，任何一个子类都有",(0,r.jsx)(n.code,{children:"constructor()"}),"方法。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class ColorPoint extends Point {\n}\n\n// 等同于\nclass ColorPoint extends Point {\n  constructor(...args) {\n    super(...args);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"有了子类的定义，就可以生成子类的实例了。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let cp = new ColorPoint(25, 8, 'green');\n\ncp instanceof ColorPoint // true\ncp instanceof Point // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，实例对象",(0,r.jsx)(n.code,{children:"cp"}),"同时是",(0,r.jsx)(n.code,{children:"ColorPoint"}),"和",(0,r.jsx)(n.code,{children:"Point"}),"两个类的实例，这与 ES5 的行为完全一致。"]}),"\n",(0,r.jsxs)(n.h2,{id:"私有属性和私有方法的继承",children:["私有属性和私有方法的继承",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#私有属性和私有方法的继承",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。"}),"\n",(0,r.jsx)(n.p,{children:"子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Foo {\n  #p = 1;\n  #m() {\n    console.log('hello');\n  }\n}\n\nclass Bar extends Foo {\n  constructor() {\n    super();\n    console.log(this.#p); // 报错\n    this.#m(); // 报错\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"上面示例中，子类 Bar 调用父类 Foo 的私有属性或私有方法，都会报错。"}),"\n",(0,r.jsx)(n.p,{children:"如果父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Foo {\n  #p = 1;\n  getP() {\n    return this.#p;\n  }\n}\n\nclass Bar extends Foo {\n  constructor() {\n    super();\n    console.log(this.getP()); // 1\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，",(0,r.jsx)(n.code,{children:"getP()"}),"是父类用来读取私有属性的方法，通过该方法，子类就可以读到父类的私有属性。"]}),"\n",(0,r.jsxs)(n.h2,{id:"静态属性和静态方法的继承",children:["静态属性和静态方法的继承",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#静态属性和静态方法的继承",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"父类的静态属性和静态方法，也会被子类继承。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  static hello() {\n    console.log('hello world');\n  }\n}\n\nclass B extends A {\n}\n\nB.hello()  // hello world\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"hello()"}),"是",(0,r.jsx)(n.code,{children:"A"}),"类的静态方法，",(0,r.jsx)(n.code,{children:"B"}),"继承",(0,r.jsx)(n.code,{children:"A"}),"，也继承了",(0,r.jsx)(n.code,{children:"A"}),"的静态方法。"]}),"\n",(0,r.jsx)(n.p,{children:"注意，静态属性是通过浅拷贝实现继承的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A { static foo = 100; }\nclass B extends A {\n  constructor() {\n    super();\n    B.foo--;\n  }\n}\n\nconst b = new B();\nB.foo // 99\nA.foo // 100\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，",(0,r.jsx)(n.code,{children:"foo"}),"是 A 类的静态属性，B 类继承了 A 类，因此也继承了这个属性。但是，在 B 类内部操作",(0,r.jsx)(n.code,{children:"B.foo"}),"这个静态属性，影响不到",(0,r.jsx)(n.code,{children:"A.foo"}),"，原因就是 B 类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此",(0,r.jsx)(n.code,{children:"A.foo"}),"和",(0,r.jsx)(n.code,{children:"B.foo"}),"是两个彼此独立的属性。"]}),"\n",(0,r.jsx)(n.p,{children:"但是，由于这种拷贝是浅拷贝，如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象，因为浅拷贝只会拷贝对象的内存地址。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  static foo = { n: 100 };\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    B.foo.n--;\n  }\n}\n\nconst b = new B();\nB.foo.n // 99\nA.foo.n // 99\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，",(0,r.jsx)(n.code,{children:"A.foo"}),"的值是一个对象，浅拷贝导致",(0,r.jsx)(n.code,{children:"B.foo"}),"和",(0,r.jsx)(n.code,{children:"A.foo"}),"指向同一个对象。所以，子类",(0,r.jsx)(n.code,{children:"B"}),"修改这个对象的属性值，会影响到父类",(0,r.jsx)(n.code,{children:"A"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"objectgetprototypeof",children:["Object.getPrototypeOf()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#objectgetprototypeof",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Object.getPrototypeOf()"}),"方法可以用来从子类上获取父类。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Point { /*...*/ }\n\nclass ColorPoint extends Point { /*...*/ }\n\nObject.getPrototypeOf(ColorPoint) === Point\n// true\n"})}),"\n",(0,r.jsx)(n.p,{children:"因此，可以使用这个方法判断，一个类是否继承了另一个类。"}),"\n",(0,r.jsxs)(n.h2,{id:"super-关键字",children:["super 关键字",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#super-关键字",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"super"}),"这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。"]}),"\n",(0,r.jsxs)(n.p,{children:["第一种情况，",(0,r.jsx)(n.code,{children:"super"}),"作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次",(0,r.jsx)(n.code,{children:"super()"}),"函数。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {}\n\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，子类",(0,r.jsx)(n.code,{children:"B"}),"的构造函数之中的",(0,r.jsx)(n.code,{children:"super()"}),"，代表调用父类的构造函数。这是必须的，否则报错。"]}),"\n",(0,r.jsxs)(n.p,{children:["调用",(0,r.jsx)(n.code,{children:"super()"}),"的作用是形成子类的",(0,r.jsx)(n.code,{children:"this"}),"对象，把父类的实例属性和方法放到这个",(0,r.jsx)(n.code,{children:"this"}),"对象上面。子类在调用",(0,r.jsx)(n.code,{children:"super()"}),"之前，是没有",(0,r.jsx)(n.code,{children:"this"}),"对象的，任何对",(0,r.jsx)(n.code,{children:"this"}),"的操作都要放在",(0,r.jsx)(n.code,{children:"super()"}),"的后面。"]}),"\n",(0,r.jsxs)(n.p,{children:["注意，这里的",(0,r.jsx)(n.code,{children:"super"}),"虽然代表了父类的构造函数，但是因为返回的是子类的",(0,r.jsx)(n.code,{children:"this"}),"（即子类的实例对象），所以",(0,r.jsx)(n.code,{children:"super"}),"内部的",(0,r.jsx)(n.code,{children:"this"}),"代表子类的实例，而不是父类的实例，这里的",(0,r.jsx)(n.code,{children:"super()"}),"相当于",(0,r.jsx)(n.code,{children:"A.prototype.constructor.call(this)"}),"（在子类的",(0,r.jsx)(n.code,{children:"this"}),"上运行父类的构造函数）。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  constructor() {\n    console.log(new.target.name);\n  }\n}\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\nnew A() // A\nnew B() // B\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，",(0,r.jsx)(n.code,{children:"new.target"}),"指向当前正在执行的函数。可以看到，在",(0,r.jsx)(n.code,{children:"super()"}),"执行时（",(0,r.jsx)(n.code,{children:"new B()"}),"），它指向的是子类",(0,r.jsx)(n.code,{children:"B"}),"的构造函数，而不是父类",(0,r.jsx)(n.code,{children:"A"}),"的构造函数。也就是说，",(0,r.jsx)(n.code,{children:"super()"}),"内部的",(0,r.jsx)(n.code,{children:"this"}),"指向的是",(0,r.jsx)(n.code,{children:"B"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["不过，由于",(0,r.jsx)(n.code,{children:"super()"}),"在子类构造方法中执行时，子类的属性和方法还没有绑定到",(0,r.jsx)(n.code,{children:"this"}),"，所以如果存在同名属性，此时拿到的是父类的属性。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  name = 'A';\n  constructor() {\n    console.log('My name is ' + this.name);\n  }\n}\n\nclass B extends A {\n  name = 'B';\n}\n\nconst b = new B(); // My name is A\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面示例中，最后一行输出的是",(0,r.jsx)(n.code,{children:"A"}),"，而不是",(0,r.jsx)(n.code,{children:"B"}),"，原因就在于",(0,r.jsx)(n.code,{children:"super()"}),"执行时，",(0,r.jsx)(n.code,{children:"B"}),"的",(0,r.jsx)(n.code,{children:"name"}),"属性还没有绑定到",(0,r.jsx)(n.code,{children:"this"}),"，所以",(0,r.jsx)(n.code,{children:"this.name"}),"拿到的是",(0,r.jsx)(n.code,{children:"A"}),"类的",(0,r.jsx)(n.code,{children:"name"}),"属性。"]}),"\n",(0,r.jsxs)(n.p,{children:["作为函数时，",(0,r.jsx)(n.code,{children:"super()"}),"只能用在子类的构造函数之中，用在其他地方就会报错。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {}\n\nclass B extends A {\n  m() {\n    super(); // 报错\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"super()"}),"用在",(0,r.jsx)(n.code,{children:"B"}),"类的",(0,r.jsx)(n.code,{children:"m"}),"方法之中，就会造成语法错误。"]}),"\n",(0,r.jsxs)(n.p,{children:["第二种情况，",(0,r.jsx)(n.code,{children:"super"}),"作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new B();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，子类",(0,r.jsx)(n.code,{children:"B"}),"当中的",(0,r.jsx)(n.code,{children:"super.p()"}),"，就是将",(0,r.jsx)(n.code,{children:"super"}),"当作一个对象使用。这时，",(0,r.jsx)(n.code,{children:"super"}),"在普通方法之中，指向",(0,r.jsx)(n.code,{children:"A.prototype"}),"，所以",(0,r.jsx)(n.code,{children:"super.p()"}),"就相当于",(0,r.jsx)(n.code,{children:"A.prototype.p()"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["这里需要注意，由于",(0,r.jsx)(n.code,{children:"super"}),"指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过",(0,r.jsx)(n.code,{children:"super"}),"调用的。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"p"}),"是父类",(0,r.jsx)(n.code,{children:"A"}),"实例的属性，",(0,r.jsx)(n.code,{children:"super.p"}),"就引用不到它。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果属性定义在父类的原型对象上，",(0,r.jsx)(n.code,{children:"super"}),"就可以取到。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {}\nA.prototype.x = 2;\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.x) // 2\n  }\n}\n\nlet b = new B();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，属性",(0,r.jsx)(n.code,{children:"x"}),"是定义在",(0,r.jsx)(n.code,{children:"A.prototype"}),"上面的，所以",(0,r.jsx)(n.code,{children:"super.x"}),"可以取到它的值。"]}),"\n",(0,r.jsxs)(n.p,{children:["ES6 规定，在子类普通方法中通过",(0,r.jsx)(n.code,{children:"super"}),"调用父类的方法时，方法内部的",(0,r.jsx)(n.code,{children:"this"}),"指向当前的子类实例。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"super.print()"}),"虽然调用的是",(0,r.jsx)(n.code,{children:"A.prototype.print()"}),"，但是",(0,r.jsx)(n.code,{children:"A.prototype.print()"}),"内部的",(0,r.jsx)(n.code,{children:"this"}),"指向子类",(0,r.jsx)(n.code,{children:"B"}),"的实例，导致输出的是",(0,r.jsx)(n.code,{children:"2"}),"，而不是",(0,r.jsx)(n.code,{children:"1"}),"。也就是说，实际上执行的是",(0,r.jsx)(n.code,{children:"super.print.call(this)"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["由于",(0,r.jsx)(n.code,{children:"this"}),"指向子类实例，所以如果通过",(0,r.jsx)(n.code,{children:"super"}),"对某个属性赋值，这时",(0,r.jsx)(n.code,{children:"super"}),"就是",(0,r.jsx)(n.code,{children:"this"}),"，赋值的属性会变成子类实例的属性。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"super.x"}),"赋值为",(0,r.jsx)(n.code,{children:"3"}),"，这时等同于对",(0,r.jsx)(n.code,{children:"this.x"}),"赋值为",(0,r.jsx)(n.code,{children:"3"}),"。而当读取",(0,r.jsx)(n.code,{children:"super.x"}),"的时候，读的是",(0,r.jsx)(n.code,{children:"A.prototype.x"}),"，所以返回",(0,r.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果",(0,r.jsx)(n.code,{children:"super"}),"作为对象，用在静态方法之中，这时",(0,r.jsx)(n.code,{children:"super"}),"将指向父类，而不是父类的原型对象。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class Parent {\n  static myMethod(msg) {\n    console.log('static', msg);\n  }\n\n  myMethod(msg) {\n    console.log('instance', msg);\n  }\n}\n\nclass Child extends Parent {\n  static myMethod(msg) {\n    super.myMethod(msg);\n  }\n\n  myMethod(msg) {\n    super.myMethod(msg);\n  }\n}\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"super"}),"在静态方法之中指向父类，在普通方法之中指向父类的原型对象。"]}),"\n",(0,r.jsxs)(n.p,{children:["另外，在子类的静态方法中通过",(0,r.jsx)(n.code,{children:"super"}),"调用父类的方法时，方法内部的",(0,r.jsx)(n.code,{children:"this"}),"指向当前的子类，而不是子类的实例。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n  constructor() {\n    this.x = 1;\n  }\n  static print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  static m() {\n    super.print();\n  }\n}\n\nB.x = 3;\nB.m() // 3\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，静态方法",(0,r.jsx)(n.code,{children:"B.m"}),"里面，",(0,r.jsx)(n.code,{children:"super.print"}),"指向父类的静态方法。这个方法里面的",(0,r.jsx)(n.code,{children:"this"}),"指向的是",(0,r.jsx)(n.code,{children:"B"}),"，而不是",(0,r.jsx)(n.code,{children:"B"}),"的实例。"]}),"\n",(0,r.jsxs)(n.p,{children:["注意，使用",(0,r.jsx)(n.code,{children:"super"}),"的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super); // 报错\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"console.log(super)"}),"当中的",(0,r.jsx)(n.code,{children:"super"}),"，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明",(0,r.jsx)(n.code,{children:"super"}),"的数据类型，就不会报错。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.valueOf() instanceof B); // true\n  }\n}\n\nlet b = new B();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"super.valueOf()"}),"表明",(0,r.jsx)(n.code,{children:"super"}),"是一个对象，因此就不会报错。同时，由于",(0,r.jsx)(n.code,{children:"super"}),"使得",(0,r.jsx)(n.code,{children:"this"}),"指向",(0,r.jsx)(n.code,{children:"B"}),"的实例，所以",(0,r.jsx)(n.code,{children:"super.valueOf()"}),"返回的是一个",(0,r.jsx)(n.code,{children:"B"}),"的实例。"]}),"\n",(0,r.jsxs)(n.p,{children:["最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用",(0,r.jsx)(n.code,{children:"super"}),"关键字。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'var obj = {\n  toString() {\n    return "MyObject: " + super.toString();\n  }\n};\n\nobj.toString(); // MyObject: [object Object]\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"类的-prototype-属性和__proto__属性",children:["类的 prototype 属性和__proto__属性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类的-prototype-属性和__proto__属性",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["大多数浏览器的 ES5 实现之中，每一个对象都有",(0,r.jsx)(n.code,{children:"__proto__"}),"属性，指向对应的构造函数的",(0,r.jsx)(n.code,{children:"prototype"}),"属性。Class 作为构造函数的语法糖，同时有",(0,r.jsx)(n.code,{children:"prototype"}),"属性和",(0,r.jsx)(n.code,{children:"__proto__"}),"属性，因此同时存在两条继承链。"]}),"\n",(0,r.jsxs)(n.p,{children:["（1）子类的",(0,r.jsx)(n.code,{children:"__proto__"}),"属性，表示构造函数的继承，总是指向父类。"]}),"\n",(0,r.jsxs)(n.p,{children:["（2）子类",(0,r.jsx)(n.code,{children:"prototype"}),"属性的",(0,r.jsx)(n.code,{children:"__proto__"}),"属性，表示方法的继承，总是指向父类的",(0,r.jsx)(n.code,{children:"prototype"}),"属性。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n}\n\nclass B extends A {\n}\n\nB.__proto__ === A // true\nB.prototype.__proto__ === A.prototype // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，子类",(0,r.jsx)(n.code,{children:"B"}),"的",(0,r.jsx)(n.code,{children:"__proto__"}),"属性指向父类",(0,r.jsx)(n.code,{children:"A"}),"，子类",(0,r.jsx)(n.code,{children:"B"}),"的",(0,r.jsx)(n.code,{children:"prototype"}),"属性的",(0,r.jsx)(n.code,{children:"__proto__"}),"属性指向父类",(0,r.jsx)(n.code,{children:"A"}),"的",(0,r.jsx)(n.code,{children:"prototype"}),"属性。"]}),"\n",(0,r.jsx)(n.p,{children:"这样的结果是因为，类的继承是按照下面的模式实现的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n}\n\nclass B {\n}\n\n// B 的实例继承 A 的实例\nObject.setPrototypeOf(B.prototype, A.prototype);\n\n// B 继承 A 的静态属性\nObject.setPrototypeOf(B, A);\n\nconst b = new B();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["《对象的扩展》一章给出过",(0,r.jsx)(n.code,{children:"Object.setPrototypeOf"}),"方法的实现。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Object.setPrototypeOf = function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"因此，就得到了上面的结果。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Object.setPrototypeOf(B.prototype, A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n\nObject.setPrototypeOf(B, A);\n// 等同于\nB.__proto__ = A;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这两条继承链，可以这样理解：作为一个对象，子类（",(0,r.jsx)(n.code,{children:"B"}),"）的原型（",(0,r.jsx)(n.code,{children:"__proto__"}),"属性）是父类（",(0,r.jsx)(n.code,{children:"A"}),"）；作为一个构造函数，子类（",(0,r.jsx)(n.code,{children:"B"}),"）的原型对象（",(0,r.jsx)(n.code,{children:"prototype"}),"属性）是父类的原型对象（",(0,r.jsx)(n.code,{children:"prototype"}),"属性）的实例。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"B.prototype = Object.create(A.prototype);\n// 等同于\nB.prototype.__proto__ = A.prototype;\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"extends"}),"关键字后面可以跟多种类型的值。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class B extends A {\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码的",(0,r.jsx)(n.code,{children:"A"}),"，只要是一个有",(0,r.jsx)(n.code,{children:"prototype"}),"属性的函数，就能被",(0,r.jsx)(n.code,{children:"B"}),"继承。由于函数都有",(0,r.jsx)(n.code,{children:"prototype"}),"属性（除了",(0,r.jsx)(n.code,{children:"Function.prototype"}),"函数），因此",(0,r.jsx)(n.code,{children:"A"}),"可以是任意函数。"]}),"\n",(0,r.jsxs)(n.p,{children:["下面，讨论两种情况。第一种，子类继承",(0,r.jsx)(n.code,{children:"Object"}),"类。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A extends Object {\n}\n\nA.__proto__ === Object // true\nA.prototype.__proto__ === Object.prototype // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这种情况下，",(0,r.jsx)(n.code,{children:"A"}),"其实就是构造函数",(0,r.jsx)(n.code,{children:"Object"}),"的复制，",(0,r.jsx)(n.code,{children:"A"}),"的实例就是",(0,r.jsx)(n.code,{children:"Object"}),"的实例。"]}),"\n",(0,r.jsx)(n.p,{children:"第二种情况，不存在任何继承。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class A {\n}\n\nA.__proto__ === Function.prototype // true\nA.prototype.__proto__ === Object.prototype // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这种情况下，",(0,r.jsx)(n.code,{children:"A"}),"作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承",(0,r.jsx)(n.code,{children:"Function.prototype"}),"。但是，",(0,r.jsx)(n.code,{children:"A"}),"调用后返回一个空对象（即",(0,r.jsx)(n.code,{children:"Object"}),"实例），所以",(0,r.jsx)(n.code,{children:"A.prototype.__proto__"}),"指向构造函数（",(0,r.jsx)(n.code,{children:"Object"}),"）的",(0,r.jsx)(n.code,{children:"prototype"}),"属性。"]}),"\n",(0,r.jsxs)(n.h3,{id:"实例的-__proto__-属性",children:["实例的 __proto__ 属性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例的-__proto__-属性",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["子类实例的",(0,r.jsx)(n.code,{children:"__proto__"}),"属性的",(0,r.jsx)(n.code,{children:"__proto__"}),"属性，指向父类实例的",(0,r.jsx)(n.code,{children:"__proto__"}),"属性。也就是说，子类的原型的原型，是父类的原型。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"var p1 = new Point(2, 3);\nvar p2 = new ColorPoint(2, 3, 'red');\n\np2.__proto__ === p1.__proto__ // false\np2.__proto__.__proto__ === p1.__proto__ // true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"ColorPoint"}),"继承了",(0,r.jsx)(n.code,{children:"Point"}),"，导致前者原型的原型是后者的原型。"]}),"\n",(0,r.jsxs)(n.p,{children:["因此，通过子类实例的",(0,r.jsx)(n.code,{children:"__proto__.__proto__"}),"属性，可以修改父类实例的行为。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"p2.__proto__.__proto__.printName = function () {\n  console.log('Ha');\n};\n\np1.printName() // \"Ha\"\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码在",(0,r.jsx)(n.code,{children:"ColorPoint"}),"的实例",(0,r.jsx)(n.code,{children:"p2"}),"上向",(0,r.jsx)(n.code,{children:"Point"}),"类添加方法，结果影响到了",(0,r.jsx)(n.code,{children:"Point"}),"的实例",(0,r.jsx)(n.code,{children:"p1"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"原生构造函数的继承",children:["原生构造函数的继承",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原生构造函数的继承",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Boolean()"}),"\n",(0,r.jsx)(n.li,{children:"Number()"}),"\n",(0,r.jsx)(n.li,{children:"String()"}),"\n",(0,r.jsx)(n.li,{children:"Array()"}),"\n",(0,r.jsx)(n.li,{children:"Date()"}),"\n",(0,r.jsx)(n.li,{children:"Function()"}),"\n",(0,r.jsx)(n.li,{children:"RegExp()"}),"\n",(0,r.jsx)(n.li,{children:"Error()"}),"\n",(0,r.jsx)(n.li,{children:"Object()"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["以前，这些原生构造函数是无法继承的，比如，不能自己定义一个",(0,r.jsx)(n.code,{children:"Array"}),"的子类。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function MyArray() {\n  Array.apply(this, arguments);\n}\n\nMyArray.prototype = Object.create(Array.prototype, {\n  constructor: {\n    value: MyArray,\n    writable: true,\n    configurable: true,\n    enumerable: true\n  }\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码定义了一个继承 Array 的",(0,r.jsx)(n.code,{children:"MyArray"}),"类。但是，这个类的行为与",(0,r.jsx)(n.code,{children:"Array"}),"完全不一致。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'var colors = new MyArray();\ncolors[0] = "red";\ncolors.length  // 0\n\ncolors.length = 0;\ncolors[0]  // "red"\n'})}),"\n",(0,r.jsxs)(n.p,{children:["之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过",(0,r.jsx)(n.code,{children:"Array.apply()"}),"或者分配给原型对象都不行。原生构造函数会忽略",(0,r.jsx)(n.code,{children:"apply"}),"方法传入的",(0,r.jsx)(n.code,{children:"this"}),"，也就是说，原生构造函数的",(0,r.jsx)(n.code,{children:"this"}),"无法绑定，导致拿不到内部属性。"]}),"\n",(0,r.jsxs)(n.p,{children:["ES5 是先新建子类的实例对象",(0,r.jsx)(n.code,{children:"this"}),"，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，",(0,r.jsx)(n.code,{children:"Array"}),"构造函数有一个内部属性",(0,r.jsx)(n.code,{children:"[[DefineOwnProperty]]"}),"，用来定义新属性时，更新",(0,r.jsx)(n.code,{children:"length"}),"属性，这个内部属性无法在子类获取，导致子类的",(0,r.jsx)(n.code,{children:"length"}),"属性行为不正常。"]}),"\n",(0,r.jsxs)(n.p,{children:["下面的例子中，我们想让一个普通对象继承",(0,r.jsx)(n.code,{children:"Error"}),"对象。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"var e = {};\n\nObject.getOwnPropertyNames(Error.call(e))\n// [ 'stack' ]\n\nObject.getOwnPropertyNames(e)\n// []\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，我们想通过",(0,r.jsx)(n.code,{children:"Error.call(e)"}),"这种写法，让普通对象",(0,r.jsx)(n.code,{children:"e"}),"具有",(0,r.jsx)(n.code,{children:"Error"}),"对象的实例属性。但是，",(0,r.jsx)(n.code,{children:"Error.call()"}),"完全忽略传入的第一个参数，而是返回一个新对象，",(0,r.jsx)(n.code,{children:"e"}),"本身没有任何变化。这证明了",(0,r.jsx)(n.code,{children:"Error.call(e)"}),"这种写法，无法继承原生构造函数。"]}),"\n",(0,r.jsxs)(n.p,{children:["ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象",(0,r.jsx)(n.code,{children:"this"}),"，然后再用子类的构造函数修饰",(0,r.jsx)(n.code,{children:"this"}),"，使得父类的所有行为都可以继承。下面是一个继承",(0,r.jsx)(n.code,{children:"Array"}),"的例子。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码定义了一个",(0,r.jsx)(n.code,{children:"MyArray"}),"类，继承了",(0,r.jsx)(n.code,{children:"Array"}),"构造函数，因此就可以从",(0,r.jsx)(n.code,{children:"MyArray"}),"生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如",(0,r.jsx)(n.code,{children:"Array"}),"、",(0,r.jsx)(n.code,{children:"String"}),"等）的子类，这是 ES5 无法做到的。"]}),"\n",(0,r.jsxs)(n.p,{children:["上面这个例子也说明，",(0,r.jsx)(n.code,{children:"extends"}),"关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class VersionedArray extends Array {\n  constructor() {\n    super();\n    this.history = [[]];\n  }\n  commit() {\n    this.history.push(this.slice());\n  }\n  revert() {\n    this.splice(0, this.length, ...this.history[this.history.length - 1]);\n  }\n}\n\nvar x = new VersionedArray();\n\nx.push(1);\nx.push(2);\nx // [1, 2]\nx.history // [[]]\n\nx.commit();\nx.history // [[], [1, 2]]\n\nx.push(3);\nx // [1, 2, 3]\nx.history // [[], [1, 2]]\n\nx.revert();\nx // [1, 2]\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"VersionedArray"}),"会通过",(0,r.jsx)(n.code,{children:"commit"}),"方法，将自己的当前状态生成一个版本快照，存入",(0,r.jsx)(n.code,{children:"history"}),"属性。",(0,r.jsx)(n.code,{children:"revert"}),"方法用来将数组重置为最新一次保存的版本。除此之外，",(0,r.jsx)(n.code,{children:"VersionedArray"}),"依然是一个普通数组，所有原生的数组方法都可以在它上面调用。"]}),"\n",(0,r.jsxs)(n.p,{children:["下面是一个自定义",(0,r.jsx)(n.code,{children:"Error"}),"子类的例子，可以用来定制报错时的行为。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class ExtendableError extends Error {\n  constructor(message) {\n    super();\n    this.message = message;\n    this.stack = (new Error()).stack;\n    this.name = this.constructor.name;\n  }\n}\n\nclass MyError extends ExtendableError {\n  constructor(m) {\n    super(m);\n  }\n}\n\nvar myerror = new MyError(\'ll\');\nmyerror.message // "ll"\nmyerror instanceof Error // true\nmyerror.name // "MyError"\nmyerror.stack\n// Error\n//     at MyError.ExtendableError\n//     ...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["注意，继承",(0,r.jsx)(n.code,{children:"Object"}),"的子类，有一个",(0,r.jsx)(n.a,{href:"https://stackoverflow.com/questions/36203614/super-does-not-pass-arguments-when-instantiating-a-class-extended-from-object",target:"_blank",rel:"noopener noreferrer",children:"行为差异"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class NewObj extends Object{\n  constructor(){\n    super(...arguments);\n  }\n}\nvar o = new NewObj({attr: true});\no.attr === true  // false\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"NewObj"}),"继承了",(0,r.jsx)(n.code,{children:"Object"}),"，但是无法通过",(0,r.jsx)(n.code,{children:"super"}),"方法向父类",(0,r.jsx)(n.code,{children:"Object"}),"传参。这是因为 ES6 改变了",(0,r.jsx)(n.code,{children:"Object"}),"构造函数的行为，一旦发现",(0,r.jsx)(n.code,{children:"Object"}),"方法不是通过",(0,r.jsx)(n.code,{children:"new Object()"}),"这种形式调用，ES6 规定",(0,r.jsx)(n.code,{children:"Object"}),"构造函数会忽略参数。"]}),"\n",(0,r.jsxs)(n.h2,{id:"mixin-模式的实现",children:["Mixin 模式的实现",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mixin-模式的实现",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const a = {\n  a: 'a'\n};\nconst b = {\n  b: 'b'\n};\nconst c = {...a, ...b}; // {a: 'a', b: 'b'}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码中，",(0,r.jsx)(n.code,{children:"c"}),"对象是",(0,r.jsx)(n.code,{children:"a"}),"对象和",(0,r.jsx)(n.code,{children:"b"}),"对象的合成，具有两者的接口。"]}),"\n",(0,r.jsx)(n.p,{children:"下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function mix(...mixins) {\n  class Mix {\n    constructor() {\n      for (let mixin of mixins) {\n        copyProperties(this, new mixin()); // 拷贝实例属性\n      }\n    }\n  }\n\n  for (let mixin of mixins) {\n    copyProperties(Mix, mixin); // 拷贝静态属性\n    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性\n  }\n\n  return Mix;\n}\n\nfunction copyProperties(target, source) {\n  for (let key of Reflect.ownKeys(source)) {\n    if ( key !== 'constructor'\n      && key !== 'prototype'\n      && key !== 'name'\n    ) {\n      let desc = Object.getOwnPropertyDescriptor(source, key);\n      Object.defineProperty(target, key, desc);\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上面代码的",(0,r.jsx)(n.code,{children:"mix"}),"函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"class DistributedEdit extends mix(Loggable, Serializable) {\n  // ...\n}\n"})})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F23.Class%20%E7%9A%84%E7%BB%A7%E6%89%BF.md"]={toc:[{text:"简介",id:"简介",depth:2},{text:"私有属性和私有方法的继承",id:"私有属性和私有方法的继承",depth:2},{text:"静态属性和静态方法的继承",id:"静态属性和静态方法的继承",depth:2},{text:"Object.getPrototypeOf()",id:"objectgetprototypeof",depth:2},{text:"super 关键字",id:"super-关键字",depth:2},{text:"类的 prototype 属性和__proto__属性",id:"类的-prototype-属性和__proto__属性",depth:2},{text:"实例的 __proto__ 属性",id:"实例的-__proto__-属性",depth:3},{text:"原生构造函数的继承",id:"原生构造函数的继承",depth:2},{text:"Mixin 模式的实现",id:"mixin-模式的实现",depth:2}],title:"23.Class 的继承",headingTitle:"23.Class 的继承",frontmatter:{}}}}]);