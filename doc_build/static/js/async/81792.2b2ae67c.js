"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["81792"],{328613:function(n,e,t){t.r(e),t.d(e,{default:()=>h});var i=t(552676),s=t(740453);let r=t.p+"static/image/c55573926bd35329adb8fa863324a509.016b2324.webp",o=t.p+"static/image/42f2911bda3a30cf3010c21536603ba3.343c304a.webp",c=t.p+"static/image/10b6f3c38873617803443fed3eb53ec5.91da62ef.webp",l=t.p+"static/image/dc304935d3142076367b240f43503f2b.a1c0fa02.webp";function d(n){let e=Object.assign({h2:"h2",a:"a",p:"p",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",img:"img",h1:"h1"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h2,{id:"前言",children:["前言",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"本章节将要介绍一下 React 对于大量数据的处理方案，对于项目中大量数据通常存在两种情况："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"第一种就是数据可视化，比如像热力图，地图，大量的数据点位的情况。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"第二种情况是长列表渲染。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"接下来将重点围绕这两点展开讨论，通过本章节，将收获 React 应用处理大量数据的解决方案。"}),"\n",(0,i.jsxs)(e.h2,{id:"实践一-时间分片",children:["实践一 时间分片",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实践一-时间分片",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["时间分片主要解决，初次加载，一次性渲染大量数据造成的卡顿现象。",(0,i.jsx)(e.strong,{children:"浏览器执 js 速度要比渲染 DOM 速度快的多。"}),"，时间分片，并没有本质减少浏览器的工作量，而是把一次性任务分割开来，给用户一种流畅的体验效果。就像造一个房子，如果一口气完成，那么会把人累死，所以可以设置任务，每次完成任务一部分，这样就能有效合理地解决问题。"]}),"\n",(0,i.jsx)(e.p,{children:"所以接下来实践一个时间分片的 demo ，一次性加载 20000 个元素块，元素块的位置和颜色是随机的。首先假设对 demo 不做任何优化处理。"}),"\n",(0,i.jsx)(e.p,{children:"色块组件："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"/* 获取随机颜色 */\nfunction getColor(){\n    const r = Math.floor(Math.random()*255);\n    const g = Math.floor(Math.random()*255);\n    const b = Math.floor(Math.random()*255);\n    return 'rgba('+ r +','+ g +','+ b +',0.8)';\n }\n/* 获取随机位置 */\nfunction getPostion(position){\n     const { width , height } = position\n     return { left: Math.ceil( Math.random() * width ) + 'px',top: Math.ceil(  Math.random() * height ) + 'px'}\n}\n/* 色块组件 */\nfunction Circle({ position }){\n    const style = React.useMemo(()=>{ //用useMemo缓存，计算出来的随机位置和色值。\n         return {  \n            background : getColor(),\n            ...getPostion(position)\n         }\n    },[])\n    return <div style={style} className=\"circle\" />\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"子组件接受父组件的位置范围信息。并通过 useMemo 缓存计算出来随机的颜色，位置，并绘制色块。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"父组件："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:'class Index extends React.Component{\n    state={\n        dataList:[],                  // 数据源列表\n        renderList:[],                // 渲染列表\n        position:{ width:0,height:0 } // 位置信息\n    }\n    box = React.createRef()\n    componentDidMount(){\n        const { offsetHeight , offsetWidth } = this.box.current\n        const originList = new Array(20000).fill(1)\n        this.setState({\n            position: { height:offsetHeight,width:offsetWidth },\n            dataList:originList,\n            renderList:originList,\n        })\n    }\n    render(){\n        const { renderList, position } = this.state\n        return <div className="bigData_index" ref={this.box}  >\n            {\n                renderList.map((item,index)=><Circle  position={ position } key={index}  /> )\n            }\n        </div>\n    }\n}\n/* 控制展示Index */\nexport default ()=>{\n    const [show, setShow] = useState(false)\n    const [ btnShow, setBtnShow ] = useState(true)\n    const handleClick=()=>{\n        setBtnShow(false)\n        setTimeout(()=>{ setShow(true) },[])\n    } \n    return <div>\n        { btnShow &&  <button onClick={handleClick} >show</button> } \n        { show && <Index />  }\n    </div>\n}\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"父组件在 componentDidMount 模拟数据交互，用ref获取真实的DOM元素容器的宽高，渲染列表。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"效果："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:l,alt:"2.gif"})}),"\n",(0,i.jsx)(e.p,{children:"可以直观看到这种方式渲染的速度特别慢，而且是一次性突然出现，体验不好，所以接下来要用时间分片做性能优化。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:'// TODO: 改造方案\nclass Index extends React.Component{\n    state={\n        dataList:[],    //数据源列表\n        renderList:[],  //渲染列表\n        position:{ width:0,height:0 }, // 位置信息\n        eachRenderNum:500,  // 每次渲染数量\n    }\n    box = React.createRef() \n    componentDidMount(){\n        const { offsetHeight , offsetWidth } = this.box.current\n        const originList = new Array(20000).fill(1)\n        const times = Math.ceil(originList.length / this.state.eachRenderNum) /* 计算需要渲染此次数*/\n        let index = 1\n        this.setState({\n            dataList:originList,\n            position: { height:offsetHeight,width:offsetWidth },\n        },()=>{\n            this.toRenderList(index,times)\n        })\n    }\n    toRenderList=(index,times)=>{\n        if(index > times) return /* 如果渲染完成，那么退出 */\n        const { renderList } = this.state\n        renderList.push(this.renderNewList(index)) /* 通过缓存element把所有渲染完成的list缓存下来，下一次更新，直接跳过渲染 */\n        this.setState({\n            renderList,\n        })\n        requestIdleCallback(()=>{ /* 用 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一批渲染 */\n            this.toRenderList(++index,times)\n        })\n    }\n    renderNewList(index){  /* 得到最新的渲染列表 */\n        const { dataList , position , eachRenderNum } = this.state\n        const list = dataList.slice((index-1) * eachRenderNum , index * eachRenderNum  )\n        return <React.Fragment key={index} >\n            {  \n                list.map((item,index) => <Circle key={index} position={position}  />)\n            }\n        </React.Fragment>\n    }\n    render(){\n         return <div className="bigData_index" ref={this.box}  >\n            { this.state.renderList }\n         </div>\n    }\n}\n\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"第一步：计算时间片，首先用 eachRenderNum 代表一次渲染多少个，那么除以总数据就能得到渲染多少次。"}),"\n",(0,i.jsxs)(e.li,{children:["第二步：开始渲染数据，通过 ",(0,i.jsx)(e.code,{children:"index>times"})," 判断渲染完成，如果没有渲染完成，那么通过 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一帧渲染。"]}),"\n",(0,i.jsx)(e.li,{children:"第三步：通过 renderList 把已经渲染的 element 缓存起来，渲染控制章节讲过，这种方式可以直接跳过下一次的渲染。实际每一次渲染的数量仅仅为 demo 中设置的 500 个。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"完美达到效果（这个是 gif 形式，会出现丢帧的情况，在真实场景，体验感更好）："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:c,alt:"3.gif"})}),"\n",(0,i.jsxs)(e.h2,{id:"实践二-虚拟列表",children:["实践二 虚拟列表",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实践二-虚拟列表",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"虚拟列表是一种长列表的解决方案，现在滑动加载是 M 端和 PC 端一种常见的数据请求加载场景，这种数据交互有一个问题就是，如果没经过处理，加载完成后数据展示的元素，都显示在页面上，如果伴随着数据量越来越大，会使页面中的 DOM 元素越来越多，即便是像 React 可以良好运用 diff 来复用老节点，但也不能保证大量的 diff 带来的性能开销。所以虚拟列表的出现，就是解决大量 DOM 存在，带来的性能问题。"}),"\n",(0,i.jsx)(e.p,{children:"何为虚拟列表，就是在长列表滚动过程中，只有视图区域显示的是真实 DOM ，滚动过程中，不断截取视图的有效区域，让人视觉上感觉列表是在滚动。达到无限滚动的效果。"}),"\n",(0,i.jsx)(e.p,{children:"虚拟列表划分可以分为三个区域：视图区 + 缓冲区 + 虚拟区。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:o,alt:"1.jpg"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"视图区：视图区就是能够直观看到的列表区，此时的元素都是真实的 DOM 元素。"}),"\n",(0,i.jsx)(e.li,{children:"缓冲区：缓冲区是为了防止用户上滑或者下滑过程中，出现白屏等效果。（缓冲区和视图区为渲染真实的 DOM ）"}),"\n",(0,i.jsx)(e.li,{children:"虚拟区：对于用户看不见的区域（除了缓冲区），剩下的区域，不需要渲染真实的 DOM 元素。虚拟列表就是通过这个方式来减少页面上 DOM 元素的数量。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"具体实现思路。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"通过 useRef 获取元素，缓存变量。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"useEffect 初始化计算容器的高度。截取初始化列表长度。这里需要 div 占位，撑起滚动条。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"通过监听滚动容器的 onScroll 事件，根据 scrollTop 来计算渲染区域向上偏移量, 这里需要注意的是，当用户向下滑动的时候，为了渲染区域，能在可视区域内，可视区域要向上滚动；当用户向上滑动的时候，可视区域要向下滚动。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"通过重新计算 end 和 start 来重新渲染列表。"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:'function VirtualList(){\n   const [ dataList,setDataList ] = React.useState([])  /* 保存数据源 */\n   const [ position , setPosition ] = React.useState([0,0]) /* 截取缓冲区 + 视图区索引 */\n   const scroll = React.useRef(null)  /* 获取scroll元素 */\n   const box = React.useRef(null)     /* 获取元素用于容器高度 */\n   const context = React.useRef(null) /* 用于移动视图区域，形成滑动效果。 */\n   const scrollInfo = React.useRef({ \n       height:500,     /* 容器高度 */\n       bufferCount:8,  /* 缓冲区个数 */\n       itemHeight:60,  /* 每一个item高度 */\n       renderCount:0,  /* 渲染区个数 */ \n    }) \n    React.useEffect(()=>{\n        const height = box.current.offsetHeight\n        const { itemHeight , bufferCount } = scrollInfo.current\n        const renderCount =  Math.ceil(height / itemHeight) + bufferCount\n        scrollInfo.current = { renderCount,height,bufferCount,itemHeight }\n        const dataList = new Array(10000).fill(1).map((item,index)=> index + 1 )\n        setDataList(dataList)\n        setPosition([0,renderCount])\n    },[])\n   const handleScroll = () => {\n       const { scrollTop } = scroll.current\n       const { itemHeight , renderCount } = scrollInfo.current\n       const currentOffset = scrollTop - (scrollTop % itemHeight) \n       const start = Math.floor(scrollTop / itemHeight)\n       context.current.style.transform = `translate3d(0, ${currentOffset}px, 0)` /* 偏移，造成下滑效果 */\n       const end = Math.floor(scrollTop / itemHeight + renderCount + 1)\n       if(end !== position[1] || start !== position[0]  ){ /* 如果render内容发生改变，那么截取  */\n            setPosition([ start , end ])\n       }\n   } \n   const { itemHeight , height } = scrollInfo.current\n   const [ start ,end ] = position\n   const renderList = dataList.slice(start,end) /* 渲染区间 */\n   console.log(\'渲染区间\',position)\n   return <div className="list_box" ref={box} >\n     <div className="scroll_box" style={{ height: height + \'px\'  }}  onScroll={ handleScroll } ref={scroll}  >\n        <div className="scroll_hold" style={{ height: `${dataList.length * itemHeight}px` }}  />\n        <div className="context" ref={context}> \n            {\n               renderList.map((item,index)=> <div className="list" key={index} >  {item + \'\' } Item </div>)\n            }  \n        </div>\n     </div>\n   </div>\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"完美达到效果："})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:r,alt:"4.gif"})}),"\n",(0,i.jsxs)(e.h1,{id:"13优化篇-处理海量数据",children:["13.优化篇-处理海量数据",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13优化篇-处理海量数据",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"对于海量的数据处理，在实际项目中，可能会更加复杂，本章节给了两个海量数据场景的处理方案，时间分片（ Time slicing ）和虚拟列表（ Virtual list ），如果真实项目中有这个场景，希望能给大家一个处理思路。纸上得来终觉浅，绝知此事须躬行。"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}let h=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F13.%E4%BC%98%E5%8C%96%E7%AF%87-%E5%A4%84%E7%90%86%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"实践一 时间分片",id:"实践一-时间分片",depth:2},{text:"实践二 虚拟列表",id:"实践二-虚拟列表",depth:2}],title:"13.优化篇-处理海量数据",headingTitle:"13.优化篇-处理海量数据",frontmatter:{}}}}]);