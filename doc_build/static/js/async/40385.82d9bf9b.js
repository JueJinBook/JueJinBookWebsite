"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["40385"],{528207:function(n,e,r){r.r(e),r.d(e,{default:()=>h});var s=r(552676),c=r(740453);let l=r.p+"static/image/517607ed8b1d7802194fd32353eacb27.35911a56.webp";function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",br:"br",h3:"h3",blockquote:"blockquote",pre:"pre",code:"code",h4:"h4",strong:"strong",ol:"ol",img:"img"},(0,c.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"16二叉树真题归纳与解读",children:["16.二叉树真题归纳与解读",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#16二叉树真题归纳与解读",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"二叉树在面试实战中，花样非常多。本节只是个开头，在后面几个专题、包括最后的大厂真题实战环节中，我们都不会停止对二叉树相关考点的学习和探讨。"}),"\n",(0,s.jsx)(e.p,{children:"在本节，有以下三个命题方向需要大家重点掌握：\xa0\xa0"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"迭代法实现二叉树的先、中、后序遍历\xa0"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"二叉树层序遍历的衍生问题"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"翻转二叉树\xa0"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"这三个方向对应的考题都比较经典。与此同时，解决这些问题涉及到的思路和编码细节，也会成为各位日后解决更加复杂的问题的基石。因此，虽然本节篇幅略长，但还是希望各位能够倾注耐心，给自己充分的时间去理解和消化这些知识。\n"}),"\n",(0,s.jsxs)(e.h2,{id:"遍历三兄弟的迭代实现",children:["“遍历三兄弟”的迭代实现\xa0\xa0",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历三兄弟的迭代实现",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"经过第5节的学习，相信各位已经将二叉树先、中、后序遍历的递归实现吃得透透的了。在使用递归实现遍历的过程中，我们明显察觉到，“遍历三兄弟”的编码实现也宛如孪生兄弟一样，彼此之间只有代码顺序上的不同，整体内容基本是一致的。这正是递归思想的一个重要的优点——简单。"}),"\n",(0,s.jsxs)(e.p,{children:["这里的“简单”并不是说学起来简单。相反，结合笔者早期的读者调研来看，大部分同学都认为递归学起来让人很难受（这也是正常的）。",(0,s.jsx)(e.br,{}),"\n","初学递归的人排斥递归，大部分是出于对“函数调用自身”这种骚操作的不适应。但只要你能克服这种不适应，并且通过反复的演练去吸收这种解题方法，你就会发现递归真的是个好东西。因为通过使用递归，我们可以把原本复杂的东西，拆解成非常简单的、符合人类惯用脑回路的逻辑。"]}),"\n",(0,s.jsx)(e.p,{children:"这样说可能还是有点抽象，不过没关系，接下来我会讲解“遍历三兄弟”对应的迭代解法。等我们学完这坨东西之后，心怀疑惑的同学不妨拿迭代法的代码和第5节中递归法的代码比较一下，相信你会毫不犹豫地回头对递归说上一句“真香！”。"}),"\n",(0,s.jsxs)(e.h3,{id:"从先序遍历说起",children:["从先序遍历说起",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#从先序遍历说起",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"\xa0\xa0"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"题目描述：给定一个二叉树，返回它的前序（先序）遍历序列。"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"示例:\n输入: [1,null,2,3]"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"1   \n \\   \n  2   \n /  \n3 \n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["输出: [1,2,3]",(0,s.jsx)(e.br,{}),"\n","进阶: 递归算法很简单，你可以通过迭代算法完成吗？"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h4,{id:"思路分析",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["注意最后那一行小字：“递归算法很简单，你可以通过迭代算法完成吗？”，对递归算法有疑问的同学，趁这个机会赶紧复习下第五小节，本节我们只讲迭代法。\xa0 \xa0","前面两个小节，我们一直在强调，递归和栈有着脱不开的干系。当一道本可以用递归做出来的题，突然不许你用递归了，此时我们本能的反应，就应该是往栈上想。\xa0 \xa0","\xa0\xa0","在基于栈来解决掉这个题之前，我要先跟平时用 ",(0,s.jsx)(e.code,{children:"leetcode"}),"\xa0刷题的各位强调一个常识。"]}),"\n",(0,s.jsxs)(e.p,{children:["现在大家回头看这道题目给我们的",(0,s.jsx)(e.strong,{children:"输入"}),"和",(0,s.jsx)(e.strong,{children:"输出"}),"：输入看似是一个数组，实则不是。大家谨记，二叉树题目的输入只要没有额外强调，那么一般来说它都是基于这样的一个对象结构嵌套而来的：\xa0 \xa0"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function TreeNode(val) {\n    this.val = val;\n    this.left = this.right = null;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"比如这样：\xa0"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'const root = {\n  val: "A",\n  left: {\n    val: "B",\n    left: {\n      val: "D"\n    },\n    right: {\n      val: "E"\n    }\n  },\n  right: {\n    val: "C",\n    right: {\n      val: "F"\n    }\n  }\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:"话说回来，为啥题上给的不是对象，而是这样的一个数组呢：\xa0"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"[1,null,2,3]\n"})}),"\n",(0,s.jsx)(e.p,{children:"这其实是一种简化的写法，性质跟咱们写伪代码差不多。它的作用主要是描述二叉树的值，至于二叉树的结构，我们以题中给出的树形结构为准：\xa0\xa0"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"1\n  \\\n   2\n  /\n3\n"})}),"\n",(0,s.jsx)(e.p,{children:"OK，了解了输入内容，现在再来看输出：\xa0\xa0"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"[1,2,3]\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这里这个输出就简单多了，它是一个",(0,s.jsx)(e.strong,{children:"真数组"}),"。为什么可以判断它是一个真数组呢？因为题目中要求你输出的是一个遍历序列，而不是一个",(0,s.jsx)(e.strong,{children:"二叉树"}),"。因此大家最后需要塞入结果数组的不是结点对象，而是结点的值。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-!",children:"注意：       \n以上的出参入参规律，是针对 leetcode 及其周边 OJ 来说的。OJ 中这样编写题目描述，是情理之中，因为 OJ 本身是支持多语言的，它只能对最通用的一部分信息进行透出。在面试场景下，不排除一些公司可能会贴心地把 JS 版本的出参和入参给出来，但更多的还是会直接复制粘贴 leetcode 或者其它一些算法书中的原题。如果你对题目的出参和入参有疑问，请大胆地对面试官说出你的困惑——没有一个正常面试官会在题目描述上为难你， 他比你更急切地想看到你刷刷写代码的英姿。    \n"})}),"\n",(0,s.jsxs)(e.p,{children:["回到题目上来。我们接着栈往下说，题目中的出参是一个数组，大家仔细看这个数组，它像不像是一个栈的出栈序列？实际上，做这道题的一个根本思路，就是通过",(0,s.jsx)(e.strong,{children:"合理地安排入栈和出栈的时机、使栈的出栈序列符合二叉树的前序遍历规则"}),"。\xa0 \xa0",(0,s.jsx)(e.br,{}),"\n","前序遍历的规则是，先遍历根结点、然后遍历左孩子、最后遍历右孩子——这正是我们所期望的出栈序列。按道理，入栈序列和出栈序列相反，我们似乎应该按照 ",(0,s.jsx)(e.code,{children:"右->左->根"}),"\xa0这样的顺序将结点入栈。不过需要注意的是，我们遍历的起点就是根结点，难道我们要假装没看到这个根结点、一鼓作气找到最右侧结点之后才开始进行入栈操作吗？答案当然是否定的，我们的出入栈顺序应该是这样的：\xa0\xa0"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"将根结点入栈\xa0"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["取出栈顶结点，将结点值 ",(0,s.jsx)(e.code,{children:"push"}),"\xa0进结果数组\xa0"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"若栈顶结点有右孩子，则将右孩子入栈"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"若栈顶结点有左孩子，则将左孩子入栈"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"这整个过程，本质上是将当前子树的根结点入栈、出栈，随后再将其对应左右子树入栈、出栈的过程。"}),"\n",(0,s.jsxs)(e.p,{children:["重复 2、3、4 步骤，直至栈空，我们就能得到一个先序遍历序列。\xa0 \xa0\xa0","\xa0\xa0\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"编码实现",children:["编码实现\xa0\xa0",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst preorderTraversal = function(root) {\n  // 定义结果数组\n  const res = []  \n  // 处理边界条件\n  if(!root) {\n      return res\n  }\n  // 初始化栈结构\n  const stack = [] \n  // 首先将根结点入栈\n  stack.push(root)  \n  // 若栈不为空，则重复出栈、入栈操作\n  while(stack.length) {\n      // 将栈顶结点记为当前结点\n      const cur = stack.pop() \n      // 当前结点就是当前子树的根结点，把这个结点放在结果数组的尾部\n      res.push(cur.val)\n      // 若当前子树根结点有右孩子，则将右孩子入栈\n      if(cur.right) {\n          stack.push(cur.right)\n      }\n      // 若当前子树根结点有左孩子，则将左孩子入栈\n      if(cur.left) {\n          stack.push(cur.left)\n      }\n  }\n  // 返回结果数组\n  return res\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:"\xa0\xa0\n"}),"\n",(0,s.jsxs)(e.h3,{id:"异曲同工的后序遍历迭代实现",children:["异曲同工的后序遍历迭代实现\xa0 \xa0 \xa0",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#异曲同工的后序遍历迭代实现",children:"#"})]}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h4,{id:"思路分析-1",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-1",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["后序遍历的出栈序列，按照规则应该是 ",(0,s.jsx)(e.code,{children:"左 -> 右 -> 根"}),"\xa0。这个顺序相对于先序遍历，最明显的变化就是根结点的位置从第一个变成了倒数第一个。\xa0 \xa0","如何做到这一点呢？与其从 ",(0,s.jsx)(e.code,{children:"stack"}),"\xa0这个栈结构上入手，不如从 ",(0,s.jsx)(e.code,{children:"res"}),"\xa0结果数组上入手：我们可以直接把 ",(0,s.jsx)(e.code,{children:"pop"}),"\xa0出来的当前结点 ",(0,s.jsx)(e.code,{children:"unshift"}),"\xa0进 ",(0,s.jsx)(e.code,{children:"res"}),"\xa0的头部，改造后的代码会变成这样：\xa0"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"while(stack.length) {\n  // 将栈顶结点记为当前结点\n  const cur = stack.pop() \n  // 当前结点就是当前子树的根结点，把这个结点放在结果数组的头部\n  res.unshift(cur.val)\n  // 若当前子树根结点有右孩子，则将右孩子入栈\n  if(cur.right) {\n    stack.push(cur.right)\n  }\n  // 若当前子树根结点有左孩子，则将左孩子入栈\n  if(cur.left) {\n    stack.push(cur.left)\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["大家可以尝试在大脑里预判一下这个代码的执行顺序：由于我们填充 ",(0,s.jsx)(e.code,{children:"res"}),"\xa0结果数组的顺序是从后往前填充（每次增加一个头部元素），因此先出栈的结点反而会位于 ",(0,s.jsx)(e.code,{children:"res"})," 数组相对靠后的位置。出栈的顺序是 ",(0,s.jsx)(e.code,{children:"当前结点 -> 当前结点的左孩子 -> 当前结点的右孩子"}),"\xa0，其对应的\xa0",(0,s.jsx)(e.code,{children:"res"}),"\xa0序列顺序就是 ",(0,s.jsx)(e.code,{children:"右 -> 左 -> 根"}),"\xa0。这样一来， 根结点就成功地被我们转移到了遍历序列的最末尾。","现在唯一让人看不顺眼的只剩下这个右孩子和左孩子的顺序了，这两个孩子结点进入结果数组的顺序与其被 ",(0,s.jsx)(e.code,{children:"pop"}),"\xa0出栈的顺序是一致的，而出栈顺序又完全由入栈顺序决定，因此只需要相应地调整两个结点的入栈顺序就好了：\xa0\xa0"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"// 若当前子树根结点有左孩子，则将左孩子入栈\nif(cur.left) {\n  stack.push(cur.left)\n}  \n// 若当前子树根结点有右孩子，则将右孩子入栈\nif(cur.right) {\n  stack.push(cur.right)\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["如此一来，右孩子就会相对于左孩子优先出栈，进而被放在 ",(0,s.jsx)(e.code,{children:"res"}),"\xa0结果数组相对靠后的位置， ",(0,s.jsx)(e.code,{children:"左 -> 右 ->根"}),"\xa0的排序规则就稳稳地实现出来了。\xa0 \xa0","\xa0\xa0","我们把以上两个改造点结合一下，就有了以下代码：\xa0 \xa0"]}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h4,{id:"编码实现-1",children:["编码实现\xa0 \xa0",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-1",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst postorderTraversal = function(root) {\n  // 定义结果数组\n  const res = []  \n  // 处理边界条件\n  if(!root) {\n      return res\n  }\n  // 初始化栈结构\n  const stack = [] \n  // 首先将根结点入栈\n  stack.push(root)  \n  // 若栈不为空，则重复出栈、入栈操作\n  while(stack.length) {\n      // 将栈顶结点记为当前结点\n      const cur = stack.pop() \n      // 当前结点就是当前子树的根结点，把这个结点放在结果数组的头部\n      res.unshift(cur.val)\n      // 若当前子树根结点有左孩子，则将左孩子入栈\n      if(cur.left) {\n        stack.push(cur.left)\n      }  \n      // 若当前子树根结点有右孩子，则将右孩子入栈\n      if(cur.right) {\n        stack.push(cur.right)\n      }\n  }\n  // 返回结果数组\n  return res\n};\n"})}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsx)(e.h3,{id:"",children:(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h3,{id:"思路清奇的中序遍历迭代实现",children:["思路清奇的中序遍历迭代实现\xa0\xa0",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路清奇的中序遍历迭代实现",children:"#"})]}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h4,{id:"思路分析-2",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-2",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["经过上面的讲解，大家会发现先序遍历和后序遍历的编码实现其实是非常相似的，它们遵循的都是同一套基本框架。那么我们能否通过对这个基本框架进行微调、从而同样轻松地实现中序遍历呢？\xa0 \xa0","答案是不能，为啥不能？因为先序遍历和后序遍历之所以可以用同一套代码框架来实现，本质上是因为两者的出栈、入栈逻辑差别不大——都是先处理根结点，然后处理孩子结点。而中序遍历中，根结点不再出现在遍历序列的边界、而是出现在遍历序列的中间。这就意味着无论如何我们不能再将根结点作为第一个被 ",(0,s.jsx)(e.code,{children:"pop"}),"\xa0出来的元素来处理了——出栈的时机被改变了，这意味着入栈的逻辑也需要调整。这一次我们不能再通过对 ",(0,s.jsx)(e.code,{children:"res"}),"\xa0动手脚来解决问题，而是需要和 ",(0,s.jsx)(e.code,{children:"stack"}),"\xa0面对面 battle。\xa0 \xa0 \xa0","\xa0\xa0","中序遍历的序列规则是 ",(0,s.jsx)(e.code,{children:"左 -> 中 -> 右"}),"\xa0，这意味着我们必须首先定位到最左的叶子结点。在这个定位的过程中，必然会途径目标结点的父结点、爷爷结点和各种辈分的祖宗结点："]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""}),"\xa0\xa0","\xa0","途径过的每一个结点，我们都要及时地把它入栈。这样当最左的叶子结点出栈时，第一个回溯到的就是它的父结点："]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)("img",{src:l,alt:""}),"\n有了父结点，就不愁找不到兄弟结点，遍历结果就变得唾手可得了~\xa0 \xa0 \xa0","基于这个思路，我们来写代码：\xa0\xa0\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"编码实现-2",children:["编码实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-2",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nconst inorderTraversal = function(root) {\n  // 定义结果数组\n  const res = []  \n  // 初始化栈结构\n  const stack = []   \n  // 用一个 cur 结点充当游标\n  let cur = root  \n  // 当 cur 不为空、或者 stack 不为空时，重复以下逻辑\n  while(cur || stack.length) {\n      // 这个 while 的作用是把寻找最左叶子结点的过程中，途径的所有结点都记录下来 \n      while(cur) {\n          // 将途径的结点入栈\n          stack.push(cur)  \n          // 继续搜索当前结点的左孩子\n          cur = cur.left  \n      }\n      // 取出栈顶元素\n      cur = stack.pop()  \n      // 将栈顶元素入栈\n      res.push(cur.val)  \n      // 尝试读取 cur 结点的右孩子\n      cur = cur.right\n  }\n  // 返回结果数组\n  return res\n};\n"})}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h4,{id:"编码复盘",children:["编码复盘",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码复盘",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["读完这段编码示范，一部分同学可能已经开始懵逼了：看着前面给出的思路分析，似乎完全写不出上面这样的代码啊！所以这段代码到底在干嘛？？？\xa0 \xa0","如果你没有这样的困惑，说明你是一位悟性比较高的同学，可以直接跳过编码复盘部分往下读了（btw给你点个赞~）。\xa0 \xa0","实不相瞒，如果你是初学者，这段代码可能确实需要大家在脑内反复运行、反复跑 demo 才能理解其中的逻辑。为了加快这个过程，我把其中看上去稍微拐弯抹角一点的逻辑摘出来，给大家点拨一下：\xa0\xa0"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["两个 ",(0,s.jsx)(e.code,{children:"while"}),"\xa0：内层的 ",(0,s.jsx)(e.code,{children:"while"}),"\xa0的作用是在寻找最左叶子结点的过程中，把途径的所有结点都记录到 ",(0,s.jsx)(e.code,{children:"stack"}),"\xa0里。记录工作完成后，才会走到外层 ",(0,s.jsx)(e.code,{children:"while"}),"\xa0的剩余逻辑里——这部分逻辑的作用是从最左的叶子结点开始，一层层回溯遍历左孩子的父结点和右侧兄弟结点，进而完成整个中序遍历任务。\xa0\xa0"]}),"\n",(0,s.jsxs)(e.li,{children:["外层 ",(0,s.jsx)(e.code,{children:"while"}),"\xa0的两个条件： ",(0,s.jsx)(e.code,{children:"cur"}),"\xa0的存在性和",(0,s.jsx)(e.code,{children:"stack.length"}),"\xa0的存在性，各自是为了限制什么？","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"stack.length"}),"\xa0的存在性比较好理解， ",(0,s.jsx)(e.code,{children:"stack"}),"\xa0中存储的是没有被推入结果数组 ",(0,s.jsx)(e.code,{children:"res"}),"\xa0的待遍历元素。只要 ",(0,s.jsx)(e.code,{children:"stack"}),"\xa0不为空，就意味着遍历没有结束， 遍历动作需要继续重复。\xa0"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"cur"}),"\xa0的存在性就比较有趣了。它对应以下几种情况：\xa0","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["初始态， ",(0,s.jsx)(e.code,{children:"cur"}),"\xa0指向 ",(0,s.jsx)(e.code,{children:"root"}),"\xa0结点，只要 ",(0,s.jsx)(e.code,{children:"root"}),"\xa0不为空， ",(0,s.jsx)(e.code,{children:"cur"}),"\xa0就不为空。此时判断了 ",(0,s.jsx)(e.code,{children:"cur"}),"\xa0存在后，就会开始最左叶子结点的寻找之旅。这趟“一路向左”的旅途中， ",(0,s.jsx)(e.code,{children:"cur"}),"\xa0始终指向当前遍历到的左孩子。\xa0"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["第一波内层 ",(0,s.jsx)(e.code,{children:"while"}),"\xa0循环结束， ",(0,s.jsx)(e.code,{children:"cur"}),"\xa0开始承担中序遍历的遍历游标职责。 ",(0,s.jsx)(e.code,{children:"cur"}),"\xa0始终会指向当前栈的栈顶元素，也就是“一路向左”过程中途径的某个左孩子，然后将这个左孩子作为中序遍历的第一个结果元素纳入结果数组。假如这个左孩子是一个叶子结点，那么尝试取其右孩子时就只能取到 ",(0,s.jsx)(e.code,{children:"null"}),"\xa0，这个 ",(0,s.jsx)(e.code,{children:"null"}),"\xa0的存在，会导致内层循环 ",(0,s.jsx)(e.code,{children:"while"}),"\xa0被跳过，接着就直接回溯到了这个左孩子的父结点，符合 ",(0,s.jsx)(e.code,{children:"左->根"}),"\xa0 的序列规则\xa0\xa0"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["假如当前取到的栈顶元素不是叶子结点，同时有一个右孩子，那么尝试取其右孩子时就会取到一个存在的结点。 ",(0,s.jsx)(e.code,{children:"cur"}),"\xa0存在，于是进入内层 ",(0,s.jsx)(e.code,{children:"while"}),"\xa0循环，重复“一路向左”的操作，去寻找这个右孩子对应的子树里最靠左的结点，然后去重复刚刚这个或回溯、或“一路向左”的过程。如果这个右孩子对应的子树里没有左孩子，那么跳出内层 ",(0,s.jsx)(e.code,{children:"while"}),"\xa0循环之后，紧接着被纳入 ",(0,s.jsx)(e.code,{children:"res"}),"\xa0结果数组的就是这个右孩子本身，符合 ",(0,s.jsx)(e.code,{children:"根->右"}),"\xa0的序列规则"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["结合上面的分析，大家会不会觉得中序遍历迭代法的这一通操作非常奇妙呢？短短的几行代码，里面竟然藏着这么广阔的乾坤，牛x、牛x。\xa0 \xa0","作为初学者，即便第一次写不出来上面的解法，也没什么好丧气的——大家谨记，关于二叉树的先、中、后序遍历，",(0,s.jsx)(e.strong,{children:"你对自己的要求应该是能够默写，也就是说要对上面这些逻辑充分熟悉、深刻记忆"}),"。\xa0 \xa0","在熟悉和记忆的过程中，你会渐渐地对这些乍一看似乎很巧妙的操作产生一种“这也很自然嘛”的感觉，这种感觉就意味着你对这个思路的充分吸收。还是那句话，千万不要以为理解就是终点，你需要做的是记忆！记忆！理解是一种感觉，记忆却能保证你在做题时一秒钟映射到具体的套路和代码——只有靠自己的双手写出来的代码，才是最可靠的伙伴。\xa0\xa0","\n"]}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h2,{id:"层序遍历的衍生问题",children:["层序遍历的衍生问题\xa0 \xa0\xa0",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#层序遍历的衍生问题",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在 ",(0,s.jsx)(e.code,{children:"DFS 和 BFS"}),"\xa0这一节，我们已经讲过了二叉树层序遍历的实现方法。层序遍历本本身难度不大，但一想到这是一个关键考点，出题这帮人就每天绞尽脑汁地想要把简单的问题复杂化。于是，就有了我们眼下这个命题方向——层序遍历的衍生问题。\xa0\xa0","对于这类问题，我们接下来会讲最有代表性的一道作为例题。各位只要能吃透这一道的基本思路，就能够轻松地在类似的变体中举一反三（例题请大家好好把握，在大厂真题训练环节，我会给出一道变体来检验各位的学习效果）。\xa0\xa0"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"题目描述：给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"示例：\n二叉树：[3,9,20,null,null,15,7],"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"  3\n / \\\n9  20\n  /  \\\n 15   7\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["返回其层次遍历结果：",(0,s.jsx)(e.br,{}),"\n","[",(0,s.jsx)(e.br,{}),"\n","\xa0[3],",(0,s.jsx)(e.br,{}),"\n","\xa0[9,20],",(0,s.jsx)(e.br,{}),"\n","\xa0[15,7]",(0,s.jsx)(e.br,{}),"\n","]"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h3,{id:"思路分析-3",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-3",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["层序遍历没有那么多幺蛾子，大家看到层序遍历就应该条件反射出 ",(0,s.jsx)(e.code,{children:"BFS+队列"}),"\xa0 这对好基友。所谓变体，不过是在 ",(0,s.jsx)(e.code,{children:"BFS"}),"\xa0的过程中围绕结果数组的内容做文章。\xa0 \xa0","拿这道题来说，相对于我们 14 节中讲过的层序遍历基本思路，它变出的花样仅仅在于要求我们对层序遍历结果进行",(0,s.jsx)(e.strong,{children:"分层"}),"。也就是说只要我们能在 ",(0,s.jsx)(e.code,{children:"BFS"}),"\xa0的过程中感知到当前层级、同时用不同的数组把不同的层级区分开，这道题就得解了。\xa0 \xa0",(0,s.jsx)(e.br,{}),"\n","如何做到这一点？大家需要知道一个非常重要的信息：我们在对二叉树进行层序遍历时，每一次 ",(0,s.jsx)(e.code,{children:"while"})," 循环其实都对应着二叉树的某一层。只要我们在进入",(0,s.jsx)(e.code,{children:"while"}),"循环之初，记录下这一层结点个数，然后将这个数量范围内的元素 ",(0,s.jsx)(e.code,{children:"push"})," 进同一个数组，就能够实现二叉树的分层。"]}),"\n",(0,s.jsx)(e.p,{}),"\n",(0,s.jsxs)(e.h3,{id:"编码实现-3",children:["编码实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-3",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nconst levelOrder = function(root) {\n    // 初始化结果数组\n    const res = []  \n    // 处理边界条件\n    if(!root) {\n        return res\n    }  \n    // 初始化队列\n    const queue = []   \n    // 队列第一个元素是根结点\n    queue.push(root)  \n    // 当队列不为空时，反复执行以下逻辑\n    while(queue.length) {\n        // level 用来存储当前层的结点\n        const level = []  \n        // 缓存刚进入循环时的队列长度，这一步很关键，因为队列长度后面会发生改变\n        const len = queue.length  \n        // 循环遍历当前层级的结点\n        for(let i=0;i<len;i++) {\n            // 取出队列的头部元素\n            const top = queue.shift()  \n            // 将头部元素的值推入 level 数组\n            level.push(top.val)\n            // 如果当前结点有左孩子，则推入下一层级\n            if(top.left) {\n                queue.push(top.left)\n            }\n            // 如果当前结点有右孩子，则推入下一层级\n            if(top.right) {\n                queue.push(top.right)\n            }\n        }\n        // 将 level 推入结果数组\n        res.push(level)\n    }\n    // 返回结果数组\n    return res\n};\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"翻转二叉树",children:["翻转二叉树",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#翻转二叉树",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["翻转二叉树是一个非常经典的问题。之前有一个关于这道题的笑话，说是",(0,s.jsx)(e.code,{children:"Homebrew"}),"的作者去面 Google，结果因为不会翻转二叉树被挂掉了。Google 在给这位大佬的拒信中写道："]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"这个故事之所以是个笑话，是因为翻转二叉树在算法面试中实在太常见了——只要你准备算法面试，你就不得不做这个题。在面试中做不出这道题的同学，会给面试官留下基础不牢的糟糕印象。"}),"\n",(0,s.jsxs)(e.p,{children:["接下来我们就一起来搞定这道翻转二叉树，成为比",(0,s.jsx)(e.code,{children:"homebrew"}),"作者更懂算法面试的人（逃"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"题目描述：翻转一棵二叉树。"}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["示例：",(0,s.jsx)(e.br,{}),"\n","输入："]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"输出："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"思路分析-4",children:["思路分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析-4",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["这道题是一道非常经典的递归应用题。",(0,s.jsx)(e.br,{}),"\n","一棵二叉树，经过翻转后会有什么特点？答案是每一棵子树的左孩子和右孩子都发生了交换。既然是“每一棵子树”，那么就意味着重复，既然涉及了重复，就没有理由不用递归。"]}),"\n",(0,s.jsx)(e.p,{children:"于是这道题解题思路就非常明确了：以递归的方式，遍历树中的每一个结点，并将每一个结点的左右孩子进行交换。"}),"\n",(0,s.jsxs)(e.h3,{id:"编码实现-4",children:["编码实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编码实现-4",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nconst invertTree = function(root) {\n    // 定义递归边界\n    if(!root) {\n        return root;\n    }\n    // 递归交换右孩子的子结点\n    let right = invertTree(root.right);\n    // 递归交换左孩子的子结点\n    let left = invertTree(root.left);\n    // 交换当前遍历到的两个左右孩子结点\n    root.left = right;\n    root.right = left;\n    return root;\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%2F16.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9C%9F%E9%A2%98%E5%BD%92%E7%BA%B3%E4%B8%8E%E8%A7%A3%E8%AF%BB.md"]={toc:[{text:"“遍历三兄弟”的迭代实现",id:"遍历三兄弟的迭代实现",depth:2},{text:"从先序遍历说起",id:"从先序遍历说起",depth:3},{text:"思路分析",id:"思路分析",depth:4},{text:"编码实现",id:"编码实现",depth:4},{text:"异曲同工的后序遍历迭代实现",id:"异曲同工的后序遍历迭代实现",depth:3},{text:"思路分析",id:"思路分析-1",depth:4},{text:"编码实现",id:"编码实现-1",depth:4},{text:"",id:"",depth:3},{text:"思路清奇的中序遍历迭代实现",id:"思路清奇的中序遍历迭代实现",depth:3},{text:"思路分析",id:"思路分析-2",depth:4},{text:"编码实现",id:"编码实现-2",depth:4},{text:"编码复盘",id:"编码复盘",depth:4},{text:"层序遍历的衍生问题",id:"层序遍历的衍生问题",depth:2},{text:"思路分析",id:"思路分析-3",depth:3},{text:"编码实现",id:"编码实现-3",depth:3},{text:"翻转二叉树",id:"翻转二叉树",depth:2},{text:"思路分析",id:"思路分析-4",depth:3},{text:"编码实现",id:"编码实现-4",depth:3}],title:"16.二叉树真题归纳与解读",headingTitle:"16.二叉树真题归纳与解读",frontmatter:{}}}}]);