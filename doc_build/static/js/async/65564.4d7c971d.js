"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["65564"],{655832:function(e,n,c){c.r(n),c.d(n,{default:()=>I});var r=c(552676),t=c(740453);let i=c.p+"static/image/41fcb43a84fca2e897736a85eaf991e3.74aa2725.webp",s=c.p+"static/image/1f6b7edda424bb2d82f3fcec592be92f.d0962072.webp",a=c.p+"static/image/ef24e5a0306073fe66c1b4d33eac776a.650395fb.webp",d=c.p+"static/image/ec9f87eb729f8745c60d301f5fd39818.ebc43e16.webp",p=c.p+"static/image/043b54991c9c7ce0a447edf9ffee0a48.874e1d74.webp",l=c.p+"static/image/d6fa47e1b8936543b3ce000dde18b1ba.4d7539e6.webp",h=c.p+"static/image/7643c2081880d11f9ae32ebecbbb2bf8.a4c029c9.webp",j=c.p+"static/image/e3d91f5718edeb1185375fe1ccd40bf9.4a156eef.webp",o=c.p+"static/image/6a4f36f8c51225c13c8bf29c94276afb.b81d3426.webp",x=c.p+"static/image/a94f7162514d7b9f09dbc5b011a19f2d.84545168.webp",m=c.p+"static/image/0254ab7ea166eb628e4301a291a949d2.4c81e7d2.webp",b=c.p+"static/image/18f07c035b423ed53d0343f96fc5d807.99bdc508.webp",f=c.p+"static/image/522f17e61db664be5a4cfa6fbaed50f0.be945043.webp",g=c.p+"static/image/ce25e5aff7ab023313085beb8453aa5e.ffd429ec.webp",S=c.p+"static/image/40086ec5a1841ef463527df145e94312.a57c1dd9.webp",u=c.p+"static/image/5f66dd3726ae9fcabf770d677d42e111.5682723f.webp",R=c.p+"static/image/e6289393e0eed9131ba862a81b1e3866.2760ac56.webp",w=c.p+"static/image/f2a6df7d8a5e02b53f873d7856f026c8.a04cb3f7.webp",E=c.p+"static/image/85900159dd987c6d8f608f3a1ec5d640.a8813e99.webp",y=c.p+"static/image/2c5e2c0a08d4f94a123453d25757837b.2aaf9638.webp",k=c.p+"static/image/a386ae093967f69599a3d62b2401a7c2.971521f5.webp",A=c.p+"static/image/e3dbbc13be342e0bbd6a787db9726294.9c52d77a.webp",C=c.p+"static/image/e1e2097de25c52a5f85709d5b047fbe7.b95527b0.webp",W=c.p+"static/image/41b3ac727ac2e281f6f6f5b7ac0823a8.14190094.webp",_=c.p+"static/image/1041b50f99e33ec092a857a697f8eab9.7d06d2e1.webp",v=c.p+"static/image/e777890e8d0c31d61e6cb2b956385ec7.294d1e1b.webp",H=c.p+"static/image/e718786a772dd61a4c2597e5e05e7691.3c1cd333.webp",B=c.p+"static/image/5b83b97c16e1f681ea4df1336535babd.d3a40c5d.webp",N=c.p+"static/image/bd5ad8df4ceb95fcc2ff6c3f26290099.c41ee0f4.webp",T=c.p+"static/image/1b093e0bb71c437132ab16a54998c907.62c09c33.webp";function P(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",strong:"strong",h2:"h2"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"第85章react服务端渲染从ssr到hydrate",children:["第85章—React服务端渲染：从SSR到hydrate",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第85章react服务端渲染从ssr到hydrate",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"\uFEFFSSR 是 Server Side Rendering，服务端渲染，服务端返回渲染出的 html，浏览器解析 html 来构建页面。"}),"\n",(0,r.jsx)(n.p,{children:"其实这是一项很古老的技术，很早之前服务端就是通过 JSP、PHP 等模版引擎，渲染填充数据的模版，产生 html 返回的。只不过这时候没有组件的概念。"}),"\n",(0,r.jsx)(n.p,{children:"有了组件之后再做服务端渲染就不一样了，你需要基于这些组件来填充数据，渲染出 html 返回。"}),"\n",(0,r.jsx)(n.p,{children:"并且在浏览器渲染出 html 后，还要把它关联到对应的组件上，添加交互逻辑和管理之后的渲染。"}),"\n",(0,r.jsx)(n.p,{children:"这时候的 SSR 服务只能是 Node.js 了，因为要服务端也要执行 JS 逻辑，也就是渲染组件。"}),"\n",(0,r.jsx)(n.p,{children:"可以看到，同样的组件在服务端渲染了一次，在客户端渲染了一次，这种可以在双端渲染的方式，叫做同构渲染。"}),"\n",(0,r.jsx)(n.p,{children:"比如这样一个组件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useState } from 'react';\n\nexport default function App() {\n  return (\n    <>\n      <h1>Hello, world!</h1>\n      <Counter />\n    </>\n  );\n}\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <button onClick={() => setCount(count + 1)}>\n      You clicked me {count} times\n    </button>\n  );\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"在服务端渲染是这样的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { renderToString } from 'react-dom/server';\nimport App from './App';\n\nconsole.log(renderToString(<App/>));\n"})}),"\n",(0,r.jsx)(n.p,{children:"结果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当然，这里应该有个 http 的 server，把组件 renderToString 的结果拼接成 html 返回。这里省略了。"}),"\n",(0,r.jsx)(n.p,{children:"假设下面就是服务端返回的 SSR 出的 html："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"现在浏览器接收到它后，要再次渲染："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import React from 'react';\nimport { hydrateRoot } from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\nhydrateRoot(document.getElementById('root'), <App/>);\n"})}),"\n",(0,r.jsx)(n.p,{children:"注意，这里执行的不是 renderRoot 的 api，而是 hydrateRoot 的 api。"}),"\n",(0,r.jsx)(n.p,{children:"因为浏览器接收到 html 就会把它渲染出来，这时候已经有标签了，只需要把它和组件关联之后，就可以更新和绑定事件了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:B,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"hydrate 会在渲染的过程中，不创建 html 标签，而是直接关联已有的。这样就避免了没必要的渲染。"}),"\n",(0,r.jsx)(n.p,{children:"这就是整个 SSR 的流程："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"服务端渲染组件为 string，拼接成 html 返回，浏览器渲染出返回的 html，然后执行 hydrate，把渲染和已有的 html 标签关联。"})}),"\n",(0,r.jsx)(n.p,{children:"那服务端是怎么 render 出字符串的，浏览器端又是怎么 hydrate 的呢？"}),"\n",(0,r.jsx)(n.p,{children:"我们分别来看一下："}),"\n",(0,r.jsx)(n.p,{children:"其实服务端渲染就是拼接 html 的过程，组件和元素分别有不同的渲染逻辑："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:H,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"组件的话就传入参数执行："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"元素的话就拼接字符串："}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:_,alt:""}),"\n",(0,r.jsx)("img",{src:W,alt:""})]}),"\n",(0,r.jsx)(n.p,{children:"这样递归渲染一遍，结果就是字符串了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"服务端渲染的部分还是挺简单的，再来看客户端渲染的 hydrate 部分："}),"\n",(0,r.jsx)(n.p,{children:"这里涉及到 react 的渲染流程，我们简单过一遍："}),"\n",(0,r.jsx)(n.p,{children:"我们组件里写的这些是 jsx 代码："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"它们编译后会变成类似 React.createElement 这种代码，叫做 render function。"}),"\n",(0,r.jsx)(n.p,{children:"render function 执行的结果是 React Element。"}),"\n",(0,r.jsx)(n.p,{children:"类似这样："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们也经常把 React Element 叫做 vdom。"}),"\n",(0,r.jsx)(n.p,{children:"react 会把 vdom 转成 fiber 的结构，这个过程叫做 reconcile："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在这样的循环里，依次处理 vdom 转 fiber："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"根据不同的类型，会做不同的处理："}),"\n",(0,r.jsx)(n.p,{children:"这个处理分为两个阶段： beginWork 和 completeWork"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"beginWork 里根据不同的 React Element（vdom）类型，做不同的处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"常见的几个，比如 FunctionComponent 是函数组件、ClassComponent 是类组件，而 HostComponent 是原生标签、HostText 是原生文本节点，HostRoot 是 fiber 树的根，是 reconcile 的处理入口。"}),"\n",(0,r.jsx)(n.p,{children:"依次处理不同 React Element 转 fiber，这是 beginWork 的部分。"}),"\n",(0,r.jsx)(n.p,{children:"转换完之后就到了 completeWork 的部分："}),"\n",(0,r.jsx)(n.p,{children:"这个阶段也是按照不同 React Element 类型做的不同处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["我们主要看 HostComponent 原生标签部分：\n",(0,r.jsx)("img",{src:S,alt:""})]}),"\n",(0,r.jsx)(n.p,{children:"在这里做的事情就是创建元素、添加子元素、更新属性、然后把这个元素放到 fiber.stateNode 属性上。"}),"\n",(0,r.jsx)(n.p,{children:"因为 beginWork 的过程是从上往下的，而 completeWork 正好反过来，那就可以按顺序创建元素，组装成一个 dom 树。"}),"\n",(0,r.jsx)(n.p,{children:"小结一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"我们在组件里写的 jsx 会被编译成 render function，执行产生 vdom（React Element），经过 reconcile 的过程转为 fiber 树。"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"reconcile 的过程分为 beginWork 和 completeWork 两个阶段，beginWork 从上往下执行不同类型的 React Element 的渲染，而 completeWork 正好反过来，依次创建元素、更新属性，并组装起来。"})}),"\n",(0,r.jsx)(n.p,{children:"这里创建的元素是挂载在 fiber.stateNode 上的，并且 dom 元素上也记录着它关联的 fiber 节点："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那如果是 hydrate 呢？还需要创建新元素么？"}),"\n",(0,r.jsx)(n.p,{children:"明显是不用的，hydrate 会在 beginWork 的时候对比当前 dom 是不是可以复用，可以复用的话就直接放到 fiber.stateNode 上了。"}),"\n",(0,r.jsx)(n.p,{children:"首先，beginWork 会从 HostRoot （fiber 的根节点）开始处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"hydrate 的时候会执行 enterHydrationState 函数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在这里会开启 isHydrating 标记，并记录当前的 dom 节点，也就是 nextHydratableInstance。"}),"\n",(0,r.jsx)(n.p,{children:"找的顺序是先找到 firstChild，然后依次找 nextSibling，很明显，这是一个深度优先搜索的过程，一层层往下遍历："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"所以在我们这个案例里，最先找到的是 h1："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后 reconcile 的过程中会处理到这个标签，也就是 HostComponent 类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这里因为 isHydrating 设置为 true 了，所以会进入 hydrate 逻辑："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这是 nextInstance 就是 h1 标签。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这里是否可以 hydrate 的逻辑很简单："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果标签名一样就可以 hydrate，也就是直接复用。"}),"\n",(0,r.jsx)(n.p,{children:"把它设置到 fiber.stateNode 上："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后找下一个可以 hydrate 的 dom 节点，就找到了文本节点："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样在 beginWork 的过程中依次 hydrate，就把 dom 和对应的 fiber 关联了起来。"}),"\n",(0,r.jsx)(n.p,{children:"然后在 completeWork 的时候，就不用再走创建标签的逻辑，因为 dom 已经有了，就可以跳过这部分。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这就是 hydrate 的原理。"}),"\n",(0,r.jsx)(n.p,{children:"fiber 树创建成功之后，之后的再次渲染就和客户端渲染没有区别了。"}),"\n",(0,r.jsx)(n.p,{children:"这样我们就把 SSR 从 renderToString 到 hydrate 的流程给串联了起来。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"SSR 是 JSP、PHP 时代就存在的古老的技术，只不过之前是通过模版引擎，而现在是通过 node 服务渲染组件成字符串，客户端再次渲染，这种叫做同构渲染的模式。"}),"\n",(0,r.jsx)(n.p,{children:"React SSR 是服务端通过 renderToString 把组件树渲染成 html 字符串，浏览器通过 hydrate 把已有的 dom 关联到 fiber 树，加上交互逻辑和再次渲染。"}),"\n",(0,r.jsx)(n.p,{children:"服务端 renderToString 就是递归拼接字符串的过程，遇到组件会传入参数执行，遇到标签会拼接对应的字符串，最终返回一段 html 给浏览器。"}),"\n",(0,r.jsx)(n.p,{children:"浏览器端 hydrate 是在 reconcile 的 beginWork 阶段，依次判断 dom 是否可以复用到当前 fiber，可以的话就设置到 fiber.stateNode，然后在 completeWork 阶段就可以跳过节点的创建。"}),"\n",(0,r.jsx)(n.p,{children:"这就是 React SSR 从服务端的 renderToString 到浏览器端的 hydrate 的全流程的原理。"})]})}function F(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(P,{...e})}):P(e)}let I=F;F.__RSPRESS_PAGE_META={},F.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC85%E7%AB%A0%E2%80%94React%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%EF%BC%9A%E4%BB%8ESSR%E5%88%B0hydrate.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第85章—React服务端渲染：从SSR到hydrate",headingTitle:"第85章—React服务端渲染：从SSR到hydrate",frontmatter:{}}}}]);