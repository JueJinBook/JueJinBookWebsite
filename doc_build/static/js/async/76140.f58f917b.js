"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["76140"],{156234:function(e,n,c){c.r(n),c.d(n,{default:()=>M});var t=c(552676),s=c(740453);let a=c.p+"static/image/b76dbf47806274aa79c81261dd4f5bbe.2af40b76.webp",r=c.p+"static/image/d21329386348c8422aa432b705cbdb4a.15bc8bf5.webp",i=c.p+"static/image/499fb53f78a5bac336ec7a4bcb9b8415.37266cba.webp",l=c.p+"static/image/7614448f8fa1036c2e567083aa599958.0663b06c.webp",d=c.p+"static/image/53273c607f37f58169eecfb5ea581b00.66500755.webp",o=c.p+"static/image/a94fff47d220643c20fa020c3ac2eb96.ad20f9e7.webp",p=c.p+"static/image/384f8227ddaaf63f32992d7737cddc18.316b6dbe.webp",h=c.p+"static/image/665ba9c4abf30415128a0ace8fe7af4e.d1ce560f.webp",g=c.p+"static/image/56d4aea26d932c1d6a45e994afded0e4.93d035d2.webp",j=c.p+"static/image/704e9d14e17361c9e4e0b2780394c0f5.24a661d6.webp",x=c.p+"static/image/ca77c6a9e5ecef74d79bcda3d899474a.126011fb.webp",b=c.p+"static/image/2a78cc8129a7cd4f3bdd3d49b7b699c7.cfd60581.webp",m=c.p+"static/image/4b763629b6bad774a9f992d77cece98b.d3f06513.webp",S=c.p+"static/image/0c54758abe2a2ba8c7cd490a998804f3.7dfe7c8e.webp",u=c.p+"static/image/bdbcab6c6680a2544a5ac0b200a087b2.e75596dc.webp",f=c.p+"static/image/2b24f101ad8b2d0ccb6fcd5a870a1f46.81ca784b.webp",C=c.p+"static/image/17a76183600fe6247b07610c40cdb744.bf18eb28.webp",v=c.p+"static/image/d5e7e8acf6bf42d5ccd59c4351611ab1.4f43beb6.webp",w=c.p+"static/image/5dfcaa706e4e3cbe1ce173541e7b7ab7.4f76ada7.webp",D=c.p+"static/image/cc2f5fc767a8e92670a56ee2061409b1.4490c4d6.webp",P=c.p+"static/image/b7a46cf544f2bf50c7f2c9f001d7665b.1a6a43ec.webp";function y(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"46实现-chrome-devtools-的-coverage-功能",children:["46.实现 Chrome DevTools 的 Coverage 功能",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#46实现-chrome-devtools-的-coverage-功能",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"上节我们把 chrome devtools frontend 跑起来，然后连上自己做的 CDP backend，实现了 network 面板、element 面板的对接，明白了 Chrome DevTools 的运行原理。"}),"\n",(0,t.jsx)(n.p,{children:"那我们能基于已有的 backend，自己实现 frontend 么？"}),"\n",(0,t.jsx)(n.p,{children:"当然也是可以的。"}),"\n",(0,t.jsx)(n.p,{children:"我们通过命令行的方式把 chrome 跑起来，通过 remote-debugging-port 指定 backend 的端口（这是 mac 下的 chrome 路径，windows 下的话大家自己找一下）："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --remote-debugging-port=9222\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后我们自己通过 WebSocket 客户端连上就可以了。"}),"\n",(0,t.jsx)(n.p,{children:"当然自己实现 CDP 的交互还是挺麻烦的，chrome 给提供了一个工具包 chrome-remote-interface，内部实现了和 CDP backend 的 WebSocket 通信，我们只需要调用它的 api 即可："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const CDP = require('chrome-remote-interface');\n\nasync function test() {\n    let client;\n    try {\n        client = await CDP({ host: '127.0.0.1', port: 9222 });\n        const { Page, DOM, Debugger } = client;\n        //...\n    } catch(err) {\n        console.error(err);\n    }\n}\ntest();\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们测试一下 DOM 部分的协议："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const CDP = require('chrome-remote-interface');\nconst fs = require('fs');\n\nasync function test() {\n    let client;\n    try {\n        client = await CDP({ host: '127.0.0.1', port: 9222 });\n        const { Page, DOM, Debugger } = client;\n\n        await Page.enable();\n        await Page.navigate({url: 'https://baidu.com'});\n\n        await DOM.enable();\n\n        const { root } = await DOM.getDocument({\n            depth: -1\n        });\n        \n    } catch(err) {\n        console.error(err);\n    }\n}\ntest();\n"})}),"\n",(0,t.jsx)(n.p,{children:"打个断点，看下 backend 返回的消息："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:P,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这就是真实的包含 DOM 信息的 CDP 数据。"}),"\n",(0,t.jsx)(n.p,{children:"接下来我们来实现一个真实的 Chrome DevTools 的功能："}),"\n",(0,t.jsx)(n.p,{children:"Chrome DevTools 有一个覆盖率检测的功能，可以检测 JS、CSS 代码里有哪些执行了，哪些没执行。并且还会在 sources 里标记出来。"}),"\n",(0,t.jsx)(n.p,{children:"如下图，绿色的部分是执行过的，而红色的部分是没执行的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:D,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"在 sources 面板里可以直接看到哪些代码没执行，比如下面的红色部分就是没有执行的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:w,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这个功能还是很有用的，可以帮助我们分析哪些代码是用不到的，可以进行延后加载或者删掉等优化。"}),"\n",(0,t.jsx)(n.p,{children:"在 More Tools 里开启："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:v,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"使用还是很简单的，但它是怎么实现的呢？"}),"\n",(0,t.jsx)(n.p,{children:"首先，我们要知道页面下载了哪些 JS 和 CSS。"}),"\n",(0,t.jsx)(n.p,{children:"这个是通过监听事件拿到的， CSS.styleSheetAdded 和 Debugger.scriptParsed 这俩事件。"}),"\n",(0,t.jsx)(n.p,{children:"我们监听下这俩事件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const CDP = require('chrome-remote-interface');\n\nasync function test() {\n    let client;\n    try {\n        client = await CDP({\n            host: '127.0.0.1',\n            port: 9222\n        });\n        const { Page, DOM, Debugger, Runtime, CSS } = client;\n\n        await Page.enable();\n        await Debugger.enable();\n        await DOM.enable();\n        await CSS.enable();\n\n        CSS.on('styleSheetAdded', async (event) => {\n            debugger;\n        })\n        Debugger.on('scriptParsed', async (event) => {\n            debugger;\n        })\n\n        await Page.navigate({url: 'http://127.0.0.1:8084'});\n\n    } catch(err) {\n        console.error(err);\n    }\n}\ntest();\n"})}),"\n",(0,t.jsx)(n.p,{children:"因为用到 DOM、CSS、Debugger、Page 域的协议，所以需要先 enable 一下，只有 enable的功能才会启用。"}),"\n",(0,t.jsx)(n.p,{children:"这个很正常，没 enable 就不启用，这样能节省性能。"}),"\n",(0,t.jsx)(n.p,{children:"执行这段代码，看下拿到的事件对象："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:C,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"事件对象里是这段 js 的 url 和行列号，再就是 scriptId。"}),"\n",(0,t.jsx)(n.p,{children:"然后再看下 CSS.styleSheetAdded 的事件对象："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"也差不多，只不过这里是 styleSheetId。"}),"\n",(0,t.jsx)(n.p,{children:"那怎么拿到 CSS 和 JS 的内容呢？"}),"\n",(0,t.jsx)(n.p,{children:"这就需要用到别的 api 了。"}),"\n",(0,t.jsx)(n.p,{children:"css 的内容是用 CSS.getStyleSheetText 来拿，传入 styeleSheetId："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const styleSheetId = event.header.styleSheetId;\nconst content = await CSS.getStyleSheetText({ styleSheetId });\n"})}),"\n",(0,t.jsx)(n.p,{children:"JS 的内容是用 Debugger.getScriptSource 来拿，传入 scriptId："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const scriptId = event.scriptId;\nconst content = await Debugger.getScriptSource({ scriptId });\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们把它们按照 id 放到 Map 里："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const cssMap = new Map();\nconst jsMap = new Map();\n\nCSS.on('styleSheetAdded', async (event) => {\n    const styleSheetId = event.header.styleSheetId;\n    const content = await CSS.getStyleSheetText({ styleSheetId });\n\n    cssMap.set(styleSheetId, {\n        meta: event.header,\n        content: content.text\n    });\n})\nDebugger.on('scriptParsed', async (event) => {\n    const scriptId = event.scriptId;\n    const content = await Debugger.getScriptSource({ scriptId });\n\n    jsMap.set(scriptId, {\n        meta: event,\n        content: content.scriptSource\n    });\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样就能把页面上所有的 js 和 css 收集起来："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:S,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"对了，测试页面的内容是这样的："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <link rel="stylesheet" href="index.css">\n    <style>\n        a {\n            color: red;\n        }\n    </style>\n</head>\n<body>\n    <script>\n        function add(a, b) {\n            return a + b;\n        }\n        function minus(a, b) {\n            return a -b;\n        }\n        function multiply(a, b) {\n            return a * b;\n        }\n    <\/script>\n    <script>\n        add(1, 3);\n        multiply(3, 4);\n    <\/script>\n</body>\n</html>\n'})}),"\n",(0,t.jsx)(n.p,{children:"有一个外部 css："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-css",children:".aaa {\n    color: red;\n}\ndiv {\n    color: blue;\n}\nbody {\n    background: pink;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"收集到了 JS 和 CSS 的数据只是第一步，要计算出覆盖率数据，还要知道哪些 JS 和 CSS 执行了。"}),"\n",(0,t.jsx)(n.p,{children:"这个也有 api："}),"\n",(0,t.jsx)(n.p,{children:"CSS 开启执行数据的收集是用 CSS.startRuleUsageTracking："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"await CSS.enable();\n\nawait CSS.startRuleUsageTracking();\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后一段时间后 stop："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// 延迟一段时间再获取数据，等页面渲染完\nawait new Promise(resolve => setTimeout(resolve, 3000));\n\nconst cssCoverage = await CSS.stopRuleUsageTracking();\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样就能获取 CSS 的执行数据："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"返回的结果显示 scriptId 为 89607.4 的 css 的 50 到 80 个字符的代码执行了。"}),"\n",(0,t.jsx)(n.p,{children:"我们在 cssMap 里看下这个 id 对应的代码："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后取出 50 到 80 个字符的代码："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"也就是说所有 css 里只有这一段代码是生效的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"你用 Chrome DevTools 的 Coverage 分析结果也是这样的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"有了所有 CSS 代码的数据，有了执行了哪些 CSS 的代码的数据，覆盖率的计算不就很简单了么？"}),"\n",(0,t.jsx)(n.p,{children:"我们再来看下 JS 的："}),"\n",(0,t.jsx)(n.p,{children:"JS 使用 Profiver 的 prociseCoverage 的 api 获取覆盖率数据："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"await Profiler.enable();\n\nawait Profiler.startPreciseCoverage();\n\n// 延迟一会再获取数据，等 js 执行完\nawait new Promise(resolve => setTimeout(resolve, 3000));\n\nconst jsCoverage = await Profiler.takePreciseCoverage();\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"可以看到返回了两个 script 的执行数据："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"因为我们页面上就两个 script 嘛："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"第一个 script 有 4 个 functions："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"有同学说，不对呀，不是 add、minus、multiply 3 个吗？"}),"\n",(0,t.jsx)(n.p,{children:"那个没有名字的代表 script 的匿名代码块。"}),"\n",(0,t.jsx)(n.p,{children:"每个 function 都记录了字符的范围，还有执行的次数："}),"\n",(0,t.jsx)(n.p,{children:"比如 add 函数执行了 1 次："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"minus 函数执行了 0 次："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"第二个 script 的匿名代码块执行了 1 次："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这不就和 Chrome DevTools 的 Coverage 结果对上了么："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"不管是覆盖率数据也好，还是在 sources 里可视化展示哪些代码没执行也好，都很容易实现。"}),"\n",(0,t.jsxs)(n.p,{children:["全部代码如下，也可以从",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/fe-debug-exercize",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"里找到。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const CDP = require('chrome-remote-interface');\n\nasync function test() {\n    let client;\n    try {\n        client = await CDP({\n            host: '127.0.0.1',\n            port: 9222\n        });\n        const { Page, DOM, Debugger, Runtime, CSS, Profiler } = client;\n\n        await Page.enable();\n        await Debugger.enable();\n        await DOM.enable();\n        await CSS.enable();\n        await Profiler.enable();\n\n        const cssMap = new Map();\n        const jsMap = new Map();\n\n        CSS.on('styleSheetAdded', async (event) => {\n            const styleSheetId = event.header.styleSheetId;\n            const content = await CSS.getStyleSheetText({ styleSheetId });\n\n            cssMap.set(styleSheetId, {\n                meta: event.header,\n                content: content.text\n            });\n        })\n        Debugger.on('scriptParsed', async (event) => {\n            const scriptId = event.scriptId;\n            const content = await Debugger.getScriptSource({ scriptId });\n\n            jsMap.set(scriptId, {\n                meta: event,\n                content: content.scriptSource\n            });\n        })\n\n        await CSS.startRuleUsageTracking();\n        await Profiler.startPreciseCoverage();\n\n        await Page.navigate({url: 'http://127.0.0.1:8084'});\n\n        await new Promise(resolve => setTimeout(resolve, 3000));\n\n        const cssCoverage = await CSS.stopRuleUsageTracking();\n        const jsCoverage = await Profiler.takePreciseCoverage();\n\n        debugger;\n    } catch(err) {\n        console.error(err);\n    }\n}\ntest();\n"})}),"\n",(0,t.jsx)(n.p,{children:"其实 lighthouse 的 cli 就是通过这种方式实现的数据收集和分析："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"如果某一天，你也要做一个网页分析工具，是不是也可以通过 CDP 的方式来获取一些网页运行数据做分析呢？"}),"\n",(0,t.jsx)(n.p,{children:"所有 Chrome DevTools 的数据，你通过 CDP 都是能拿到的，能做的事情有很多。"}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"可以自己实现 CDP backend，当然也可以实现 frontend，但自己对接 WebSocket 和 CDP 协议还是挺麻烦的，可以直接用 chrome-remote-interface  这个包。"}),"\n",(0,t.jsx)(n.p,{children:"这节我们实现了下 Coverage 功能："}),"\n",(0,t.jsx)(n.p,{children:"Chrome DevTools 有 Coverage 面板，可以分析 JS 和 CSS 代码执行的覆盖率，分析出哪些代码没执行，然后做后续优化。"}),"\n",(0,t.jsx)(n.p,{children:"这是 Chrome 通过 CDP 暴露给 Chrome DevTools 的，而 CDP 的数据我们也能自己实现 ws 客户端来拿到，那自然也可以自己实现覆盖率的计算。"}),"\n",(0,t.jsx)(n.p,{children:"我们通过 chrome-remote-interface 的不同域的 api 来进行了 CSS 和 JS 的代码的收集，代码执行数据的收集，有了这些数据就能轻松算出覆盖率。"}),"\n",(0,t.jsx)(n.p,{children:"lighthouse 的 cli 就是通过这种方式来收集 Chrome 运行时数据，做分析和展示的。如果我们想做一个调试工具，或者网页分析工具，也可以用类似的思路。"}),"\n",(0,t.jsx)(n.p,{children:"Chrome DevTools 能做的所有事情，我们都能自己实现，因为 CDP 数据是一摸一样的。"})]})}function T(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(y,{...e})}):y(e)}let M=T;T.__RSPRESS_PAGE_META={},T.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F46.%E5%AE%9E%E7%8E%B0%20Chrome%20DevTools%20%E7%9A%84%20Coverage%20%E5%8A%9F%E8%83%BD.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"46.实现 Chrome DevTools 的 Coverage 功能",headingTitle:"46.实现 Chrome DevTools 的 Coverage 功能",frontmatter:{}}}}]);