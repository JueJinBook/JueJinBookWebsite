"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["13608"],{651938:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var s=r(552676),c=r(740453);let a=r.p+"static/image/1692a9e677c0f2633678a8ba6c00f16b.7279b51a.webp",p=r.p+"static/image/9dee5c3c863458b6ca96645960f283eb.6722ee10.webp",i=r.p+"static/image/50792439cb11fb2d7121e884c1215b6c.f7254a7b.webp",o=r.p+"static/image/f10b36ec5659275f4b6683ff6d5efc4f.f3b48e39.webp",l=r.p+"static/image/4b26a6b379b02d8868ae97f2988db130.d180e63e.webp",t=r.p+"static/image/72ccc3bab3706f83f7568dc4c23b050f.bd4a5f9a.webp",d=r.p+"static/image/8035328d85b552300fb4f71073f8e625.da6bc202.webp",h=r.p+"static/image/f89b90b1f7f98c3bd3ee0276f2d80bc1.839f35fd.webp",m=r.p+"static/image/81e36255675e05dfa9601ce86d425322.d8dfe7e6.webp";function j(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",pre:"pre",code:"code",ul:"ul",li:"li",img:"img",ol:"ol"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"5sourcemap-的原理和作用",children:["5.sourcemap 的原理和作用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5sourcemap-的原理和作用",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"学习调试，sourcemap 是绕不开的概念，有了它才能直接调试源码。"}),"\n",(0,s.jsx)(n.p,{children:"这一节，我们就来探究下 sourcemap："}),"\n",(0,s.jsxs)(n.h2,{id:"什么是-sourcemap",children:["什么是 sourcemap",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是-sourcemap",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"sourcemap 是关联编译后的代码和源码的，通过一个个行列号的映射。"})}),"\n",(0,s.jsx)(n.p,{children:"比如编译后代码的第 3 行第 4 列，对应着源码里的第 8 行第 5 列这种，这叫做一个 mapping。"}),"\n",(0,s.jsx)(n.p,{children:"sourcemap 的格式如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'{\n　　　　version : 3,\n　　　　file: "out.js",\n　　　　sourceRoot : "",\n　　　　sources: ["foo.js", "bar.js"],\n　　　　names: ["a", "b"],\n　　　　mappings: "AAgBC,SAAQ,CAAEA;AAAEA",\n      sourcesContent: [\'const a = 1; console.log(a)\', \'const b = 2; console.log(b)\']\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"version：sourcemap 的版本，一般为 3"}),"\n",(0,s.jsx)(n.li,{children:"file：编译后的文件名"}),"\n",(0,s.jsx)(n.li,{children:"sourceRoot：源码根目录"}),"\n",(0,s.jsx)(n.li,{children:"names：转换前的变量名"}),"\n",(0,s.jsx)(n.li,{children:"sources：源码文件名"}),"\n",(0,s.jsx)(n.li,{children:"sourcesContent：每个 sources 对应的源码的内容"}),"\n",(0,s.jsx)(n.li,{children:"mappings：一个个位置映射"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"为什么 sources 可以有多个呢？"}),"\n",(0,s.jsx)(n.p,{children:"因为可能编译产物是多个源文件合并的，比如打包，一个 bundle.js 就对应了 n 个 sources 源文件。"}),"\n",(0,s.jsx)(n.p,{children:"重点是 mappings 部分："}),"\n",(0,s.jsxs)(n.p,{children:["mappings 部分是通过分号",(0,s.jsx)(n.code,{children:";"})," 和逗号 ",(0,s.jsx)(n.code,{children:","})," 分隔的："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'mappings:"AAAAA,BBBBB;CCCCC"\n'})}),"\n",(0,s.jsx)(n.p,{children:"一个分号就代表一行，这样就免去了行的映射。"}),"\n",(0,s.jsxs)(n.p,{children:["然后每一行可能有多个位置的映射，用 ",(0,s.jsx)(n.code,{children:","})," 分隔。"]}),"\n",(0,s.jsx)(n.p,{children:"那具体的每一个 mapping 都是啥呢？"}),"\n",(0,s.jsx)(n.p,{children:"比如 AAAAA 一共五位，分别有不同的含义："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"转换后代码的第几列（行数通过分号 ; 来确定）"}),"\n",(0,s.jsx)(n.li,{children:"转换前的哪个源码文件，保存在 sources 里的，这里通过下标索引"}),"\n",(0,s.jsx)(n.li,{children:"转换前的源码的第几行"}),"\n",(0,s.jsx)(n.li,{children:"转换前的源码的第几列"}),"\n",(0,s.jsx)(n.li,{children:"转换前的源码的哪个变量名，保存在 names 里的，这里通过下标索引"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"然后经过编码之后，就成了 AAAAA 这种，这种编码方式叫做 VLQ 编码。"}),"\n",(0,s.jsx)(n.p,{children:"sourcemap 的格式还是很容易理解的，就是一一映射编译后代码的位置和源码的位置。"}),"\n",(0,s.jsx)(n.p,{children:"各种调试工具一般都支持 sourcemap 的解析，只要在文件末尾加上这样一行："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"//# sourceMappingURL=/path/to/source.js.map\n"})}),"\n",(0,s.jsx)(n.p,{children:"运行时就会关联到源码："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"除了调试的时候会使用 sourcemap，线上报错定位源码也需要用到："}),"\n",(0,s.jsx)(n.p,{children:"开发时会使用 sourcemap 来调试，但是生产可不会，但是线上报错的时候确实也需要定位到源码，这种情况一般都是单独上传 sourcemap 到错误收集平台。"}),"\n",(0,s.jsxs)(n.p,{children:["比如 sentry 就提供了一个\xa0",(0,s.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40sentry%2Fwebpack-plugin",title:"https://www.npmjs.com/package/@sentry/webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"@sentry/webpack-plugin"}),"\xa0支持在打包完成后把 sourcemap 自动上传到 sentry 后台，然后把本地 sourcemap 删掉。还提供了\xa0",(0,s.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40sentry%2Fcli",title:"https://www.npmjs.com/package/@sentry/cli",target:"_blank",rel:"noopener noreferrer",children:"@sentry/cli"}),"\xa0让用户可以手动上传。"]}),"\n",(0,s.jsxs)(n.p,{children:["平时我们至少在这两个场景（",(0,s.jsx)(n.strong,{children:"开发时调试源码，生产时定位错误的源码位置"}),"）下会用到 sourcemap。"]}),"\n",(0,s.jsx)(n.p,{children:"sourcemap 只是位置的映射，可以用在任何代码上，比如 JS、TS、CSS 等，而且 TS 的类型也支持 sourcemap："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"指定了 declaration 会生成 d.ts 的声明文件，还可以指定 declarationMap 来生成 sourcemap："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样在 VSCode 里我们就可以直接点击某个类型来跳转到源码里对应的地方了。"}),"\n",(0,s.jsxs)(n.p,{children:["这也算 sourcemap 应用的另一个场景，用于",(0,s.jsx)(n.strong,{children:"生成的类型和源码中定义的关联"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"知道了什么是 sourcemap，那 sourcemap 是怎么生成的呢？"}),"\n",(0,s.jsxs)(n.h2,{id:"sourcemap-的生成",children:["sourcemap 的生成",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#sourcemap-的生成",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"编译工具在生成代码的时候也会生成 sourcemap："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"其实 sourcemap 就是由一个个位置的映射组成的，关键就是要知道源码的哪个位置对应到了编译后代码的哪个位置："}),"\n",(0,s.jsxs)(n.p,{children:["通过 ",(0,s.jsx)(n.a,{href:"https://astexplorer.net/#/gist/19042bfa06784d0e1b2dcb2ecd3559d5/50898c658d8129dbe520cc515af169331082036b",target:"_blank",rel:"noopener noreferrer",children:"astexplorer.net"})," 可以看到，AST 中保留了源码中的位置，这是 parser 在 parse 源码的时候记录的。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后进行 AST 的各种转换之后会打印成目标代码，打印的时候是一行行一列列的拼接字符串，这时候就有了目标代码中的位置。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这两个位置一关联，那不就是一个 mapping 么？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样就生成了 sourcemap。"}),"\n",(0,s.jsxs)(n.p,{children:["当然 sourcemap 有对应的格式和编码，自己生成还是挺麻烦的，我们会用 ",(0,s.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsource-map",target:"_blank",rel:"noopener noreferrer",children:"source-map"})," 这个包："]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsource-map",title:"https://www.npmjs.com/package/source-map",target:"_blank",rel:"noopener noreferrer",children:"source-map"}),"\xa0可以用于生成和解析 sourcemap，它暴露了 SourceMapConsumer、SourceMapGenerator、SourceNode 3个类，分别用于消费 sourcemap、生成 sourcemap、创建源码节点。"]}),"\n",(0,s.jsx)(n.p,{children:"生成 sourcemap 的流程是："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"创建一个 SourceMapGenerator 对象"}),"\n",(0,s.jsx)(n.li,{children:"通过 addMapping 方法添加一个映射"}),"\n",(0,s.jsx)(n.li,{children:"通过 toString 转为 sourcemap 字符串"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const { SourceMapGenerator } = require(\'source-map\');\n\nconst map = new SourceMapGenerator({\n    file: "source-mapped.js"\n});\n  \nmap.addMapping({\n    generated: {\n        line: 10,\n        column: 35\n    },\n    source: "foo.js",\n    original: {\n        line: 33,\n        column: 2\n    },\n    name: "christopher"\n});\n  \nconsole.log(map.toString());\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"消费 sourcemap 用 SourceMapConsumer 的 api。"}),"\n",(0,s.jsx)(n.p,{children:"可以调用 originalPositionFor 和 generatedPositionFor 分别用目标代码位置查源码位置和用源码位置查目标代码位置"}),"\n",(0,s.jsx)(n.p,{children:"还可以通过 eachMapping 遍历所有 mapping，对每个进行处理。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const { SourceMapConsumer } = require(\'source-map\');\n\nconst rawSourceMap = {\n    version: 3,\n    file: "min.js",\n    names: ["bar", "baz", "n"],\n    sources: ["one.js", "two.js"],\n    sourceRoot: "http://example.com/www/js/",\n    mappings: "CAAC,IAAI,IAAM,SAAUA,GAClB,OAAOC,IAAID;CCDb,IAAI,IAAM,SAAUE,GAClB,OAAOA"\n};\n\n(async function() {\n    await SourceMapConsumer.with(rawSourceMap, null, consumer => {\n        // 目标代码位置查询源码位置\n        consumer.originalPositionFor({\n            line: 2,\n            column: 28\n        })\n        // { source: \'http://example.com/www/js/two.js\',\n        //   line: 2,\n        //   column: 10,\n        //   name: \'n\' }\n    \n        // 源码位置查询目标代码位置\n        consumer.generatedPositionFor({\n            source: "http://example.com/www/js/two.js",\n            line: 2,\n            column: 10\n        })\n        // { line: 2, column: 28 }\n    \n        // 遍历 mapping\n        consumer.eachMapping(function(m) {\n            console.log(m);\n        });    \n    });\n})();\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这些 api 还是很容易理解的。"}),"\n",(0,s.jsx)(n.p,{children:"知道了位置从哪里来，知道了怎么用 source-map 的包生成 sourcemap，那就知道了平时我们用的 sourcemap 是怎么来的了。"}),"\n",(0,s.jsxs)(n.p,{children:["我们用到的 webpack、babel 等等工具的 sourcemap 的生成和消费都是用的 source-map 这个包，大家也可以把",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/fe-debug-exercize",target:"_blank",rel:"noopener noreferrer",children:"小册仓库的代码"}),"下下来跑跑试试。"]}),"\n",(0,s.jsxs)(n.p,{children:["更详细的介绍可以看 source-map 这个包的",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/source-map#consuming-a-source-map",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这节我们学习了 sourcemap，它是通过一个个行列号的映射来关联编译后的代码和源码的。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"调试的时候会使用 sourcemap，这样可以直接在源码打断点调试。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"线上报错的时候会使用 sourcemap 来映射到源码，我们会把 sourcemap 单独上传 sentry 等错误收集平台。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"生成的类型也可以通过 sourcemap 关联到对应的源码中的定义"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"sourcemap 是挺常见的，并且用途也很多。"}),"\n",(0,s.jsx)(n.p,{children:"它的生成可以通过 source-map 包的 api，而 mapping 的位置来源可能是源码 parse 后的 AST 中的位置信息和打印代码时计算出的位置信息的关联。"}),"\n",(0,s.jsx)(n.p,{children:"理解了 sourcemap 的作用，就知道为什么调试离不开 sourcemap 了。"})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}let x=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F5.sourcemap%20%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%9C%E7%94%A8.md"]={toc:[{text:"什么是 sourcemap",id:"什么是-sourcemap",depth:2},{text:"sourcemap 的生成",id:"sourcemap-的生成",depth:2},{text:"总结",id:"总结",depth:2}],title:"5.sourcemap 的原理和作用",headingTitle:"5.sourcemap 的原理和作用",frontmatter:{}}}}]);