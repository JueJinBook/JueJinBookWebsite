"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19790"],{132670:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var t=s(552676),l=s(740453);let r=s.p+"static/image/b0090b119639921635fa5140cf10a6ad.b15408da.webp";function o(e){let n=Object.assign({p:"p",code:"code",img:"img",h1:"h1",a:"a",h2:"h2",pre:"pre",strong:"strong",blockquote:"blockquote",h3:"h3",ol:"ol",li:"li",ul:"ul",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,l.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["在 React Hooks 中，有专门针对优化的两个 Hooks，它们分别是 ",(0,t.jsx)(n.code,{children:"useMemo"})," 和 ",(0,t.jsx)(n.code,{children:"useCallback"}),"。同时，它们哥俩也是最具争议的 Hooks，因为如果使用不当，非但达不到优化的效果，还有可能降低性能，让人头大。"]}),"\n",(0,t.jsx)(n.p,{children:"通过本章的阅读，将彻底搞懂 useMemo 和 useCallback，同时了解 React 中其他性能优化的方法。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:"useMemo和useCallback.png"})}),"\n",(0,t.jsxs)(n.h1,{id:"12源码篇彻底搞懂-usememo-和-usecallback",children:["12.源码篇｜彻底搞懂 useMemo 和 useCallback",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12源码篇彻底搞懂-usememo-和-usecallback",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"从源码角度上来看，useMemo 和 useCallback 并不复杂，甚至两者的源码十分相似，所以这里我们直接放到一起观看。"}),"\n",(0,t.jsxs)(n.h2,{id:"mountmemomountcallback初始化",children:["mountMemo/mountCallback（初始化）",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mountmemomountcallback初始化",children:"#"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// mountMemo\nfunction mountMemo<T>(\n  nextCreate: () => T, \n  deps: Array<mixed> | void | null,\n): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\n// mountCallback\nfunction mountCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null\n): T {\n  const hook = mountWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在初始化中，useMemo 首先创建一个 hook，然后判断 deps 的类型，执行 nextCreate，这个参数是需要缓存的值，然后将",(0,t.jsx)(n.strong,{children:"值与 deps 保存到 memoizedState 上"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["而 useCallback 更加简单，",(0,t.jsx)(n.strong,{children:"直接将 callback和 deps 存入到 memoizedState 里。"})]}),"\n",(0,t.jsxs)(n.h2,{id:"updatememoupdatecallback更新",children:["updateMemo/updateCallback（更新）",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#updatememoupdatecallback更新",children:"#"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// updateMemo\nfunction updateMemo<T>(\n  nextCreate: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const hook = updateWorkInProgressHook();\n  // 判断新值\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      //之前保存的值\n      const prevDeps: Array<mixed> | null = prevState[1];\n      // 与useEffect判断deps一致\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\n// updateCallback\nfunction updateCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n        //之前保存的值\n      const prevDeps: Array<mixed> | null = prevState[1];\n      // 与useEffect判断deps一致\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在更新过程中，useMemo 实际上只做了一件事，就是通过判断两次的 deps 是否发生改变，如果发生改变，则重新执行 ",(0,t.jsx)(n.code,{children:"nextCreate()"}),"，将得到的新值重新复制给 memoizedState；如果没发生改变，则直接返回缓存的值。"]}),"\n",(0,t.jsx)(n.p,{children:"而 useCallBack 也是同理。通过判断 deps 是否相等的 areHookInputsEqual，与 useEffect 中的一致，所以这里不做过多赘述。"}),"\n",(0,t.jsx)(n.p,{children:"useMemo 和 useCallback 的关系："}),"\n",(0,t.jsxs)(n.p,{children:["从源码角度上来看，无论初始化，亦或者更新，useMemo 比 useCallback 多了一步，即执行 ",(0,t.jsx)(n.code,{children:"nextCreate()"})," 的步骤，那么说明 ",(0,t.jsx)(n.code,{children:"useCallback(fn, deps)"})," 等价于  ",(0,t.jsx)(n.code,{children:"useMemo(() => fn, deps)"}),"。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"注意：useMemo 中的 nextCreate() 中如果引用了 useState 等信息，无法被垃圾机制回收（闭包问题），那么访问的属性有可能不是最新的值，所以需要将引用的值传递给  deps，则重新执行 nextCreate()。"}),"\n"]}),"\n",(0,t.jsxs)(n.h1,{id:"性能优化的几种方案",children:["性能优化的几种方案",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能优化的几种方案",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们知道 useMemo、 useCallback 是函数组件提供的优化方案，除此之外，React 还提供其余两种优化方案，接下来一起来看看，有何异同。"}),"\n",(0,t.jsxs)(n.h2,{id:"1类组件的性能优化",children:["1.类组件的性能优化",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1类组件的性能优化",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在类组件中主要包含两种方式，分别是 ",(0,t.jsx)(n.code,{children:"shouldComponentUpdate"})," 和",(0,t.jsx)(n.code,{children:"PureComponent"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"shouldComponentUpdate(nextProps, nextState)"}),"：生命周期函数，通过比较",(0,t.jsx)(n.code,{children:"nextProps（当前组件的 this.props）"})," 和 ",(0,t.jsx)(n.code,{children:"nextState（当前组件的 this.state）"}),"，来判断当前组件是否有必要继续执行更新过程。"]}),"\n",(0,t.jsx)(n.p,{children:"如果 shouldComponentUpdate 返回的结果为 true，则继续执行对应的更新；如果为 false，则代表停止更新，用于减少组件的不必要渲染，从而优化性能。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"PureComponent"}),"：与 Component 的用法基本一致，但 PureComponent 会对props 和 state 进行浅比较，从而跳过不必要的更新（减少 render 的次数），提高组件性能。"]}),"\n",(0,t.jsx)(n.p,{children:"那么浅比较是什么呢？先举个例子来看看："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { PureComponent } from "react";\nimport { Button } from "antd";\n\nclass Index extends PureComponent<any, any> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      data: {\n        number: 0,\n      },\n    };\n  }\n\n  render() {\n    const { data } = this.state;\n    return (\n      <>\n        <div>大家好，我是小杜杜，一起玩转Hooks吧！</div>\n        <div> 数字： {data.number}</div>\n        <Button\n          type="primary"\n          onClick={() => {\n            const { data } = this.state;\n            data.number++;\n            this.setState({ data });\n          }}\n        >\n          数字加1\n        </Button>\n      </>\n    );\n  }\n}\n\nexport default Index;\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsx)(n.p,{children:"当点击按钮时，对应的数字并没有变化，这是因为 PureComponent 会比较两次的 data 对象，它会认为这种写法并没有改变原先的 data，所以不会改变。"}),"\n",(0,t.jsx)(n.p,{children:"解决方法："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"this.setState({ data: {...data} })\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"对比-shouldcomponentupdate-和-purecomponent",children:["对比 shouldComponentUpdate 和 PureComponent",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对比-shouldcomponentupdate-和-purecomponent",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["首先要特别明确 ",(0,t.jsx)(n.strong,{children:"shouldComponentUpdate 是生命周期的方法，而 PureComponent 是组件。"})]}),"\n",(0,t.jsxs)(n.p,{children:["换言之，在 PureComponent 也可以调取 shouldComponentUpdate 函数，如果调取，则会对新旧 props、state 进行 ",(0,t.jsx)(n.code,{children:"shallowEqual"})," 浅比较，另外 ",(0,t.jsx)(n.strong,{children:"shouldComponentUpdate 的权重要高于 PureComponent"}),"。"]}),"\n",(0,t.jsxs)(n.h3,{id:"shallowequal-浅比较",children:["shallowEqual 浅比较",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#shallowequal-浅比较",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["我们可以简单地看下对应的源码，其中有一个专门检查是否更新的函数：",(0,t.jsx)(n.code,{children:"checkShouldComponentUpdate"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["文件位置：",(0,t.jsx)(n.code,{children:"packages/react-reconciler/src/ReactFiberClassComponent.js"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  const instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    // shouldComponentUpdate 更新\n    let shouldUpdate = instance.shouldComponentUpdate(\n      newProps,\n      newState,\n      nextContext,\n    );\n    return shouldUpdate;\n  }\n\n   // 判断原型链是否存在isPureReactComponent\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return (\n      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n    );\n  }\n\n  return true;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在 PureComponent 组件的原型链包含 ",(0,t.jsx)(n.code,{children:"isPureReactComponent"})," 属性，同时也是通过这个属性来判断是否要进行浅比较。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"shallowEqual："})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"function shallowEqual(objA: mixed, objB: mixed): boolean {\n  // 这里的is和useEffect源码中的is一致，不做过多的介绍\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false;\n  }\n\n  const keysA = Object.keys(objA);\n  const keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    const currentKey = keysA[i];\n    if (\n      !hasOwnProperty.call(objB, currentKey) ||\n      !is(objA[currentKey], objB[currentKey])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"shallowEqual 浅比较流程："})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["首先比较新旧 ",(0,t.jsx)(n.code,{children:"props/state"})," 是否相等，如果相等，则返回 true，不更新组件；"]}),"\n",(0,t.jsxs)(n.li,{children:["接下来判断新旧 ",(0,t.jsx)(n.code,{children:"props/state"})," 是否为对象，如果不是对象或为 ",(0,t.jsx)(n.code,{children:"null"})," 的情况，则返回 false，更新组件；"]}),"\n",(0,t.jsxs)(n.li,{children:["然后将新旧 ",(0,t.jsx)(n.code,{children:"props/state"})," 通过 ",(0,t.jsx)(n.code,{children:"Object.keys"})," 转化为数组，如果不相等，则证明有新增或减少，返回 false，更新组件；"]}),"\n",(0,t.jsx)(n.li,{children:"最后进行遍历（浅比较），如果有不相同的话，则返回 false 更新组件。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"总的来说，PureComponent 通过自带的 props 和 state 的浅比较实现了 shouldComponentUpdate() ，这点是 Component 所不具备的。"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"注意：PureComponent 可能会因深层的数据不一致而产生错误的否定判断，从而导致 shouldComponentUpdate 结果返回 false，界面得不到更新，要谨慎使用。"}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"2reactmemo-高阶组件",children:["2.React.memo 高阶组件",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2reactmemo-高阶组件",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"React.memo"}),"：结合了 pureComponent 和 componentShouldUpdate 功能，会对传入的 props 进行一次对比，然后根据第二个函数返回值来进一步判断哪些 props 需要更新。"]}),"\n",(0,t.jsxs)(n.p,{children:["要注意 React.memo 是一个",(0,t.jsx)(n.strong,{children:"高阶组件"}),"，函数式组件和类组件都可以使用。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"React.memo"}),"接收两个参数"]}),"："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"第一个参数：组件本身，也就是要优化的组件；"}),"\n",(0,t.jsxs)(n.li,{children:["第二个参数：(pre, next) => boolean， pre：之前的数据，next：现在的数据，返回一个",(0,t.jsx)(n.code,{children:"布尔值"}),"，若为 true 则不更新，为 false 更新。"]}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"注意：如果 React.memo 的第二个参数不存在时，则按照浅比较的方式进行比较。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"举个例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { Component, memo } from "react";\nimport { Button } from "antd";\n\nconst Child = ({ number, msg = "" }: any) => {\n  return (\n    <>\n      {console.log(`${msg}子组件渲染`)}\n      <p>\n        {msg}数字：{number}\n      </p>\n    </>\n  );\n};\n\nconst HOCChild = memo(Child, (pre, next) => {\n  if (pre.number === next.number) return true;\n  if (next.number < 7) return false;\n  return true;\n});\n\nclass Index extends Component<any, any> {\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      flag: true,\n      number: 1,\n    };\n  }\n\n  render() {\n    const { flag, number } = this.state;\n    return (\n      <div>\n        大家好，我是小杜杜，一起玩转Hooks吧！\n        <Child number={number} />\n        <HOCChild number={number} msg="被memo包的" />\n        <Button type="primary" onClick={() => this.setState({ flag: !flag })}>\n          状态切换{JSON.stringify(flag)}\n        </Button>\n        <Button\n          type="primary"\n          style={{ marginLeft: 8 }}\n          onClick={() => this.setState({ number: number + 1 })}\n        >\n          数字加一：{number}\n        </Button>\n      </div>\n    );\n  }\n}\n\nexport default Index;\n'})}),"\n",(0,t.jsxs)(n.p,{children:["例子很简单，在 ",(0,t.jsx)(n.strong,{children:"Index"})," 中，我们定义了 number 和 flag 两个变量，number 传入对应的 Child，而 flag 与 Child 并没有直接的关联，接下来看看效果："]}),"\n",(0,t.jsx)(n.p,{children:"从图中可以看到，当我们变更无关变量：flag 时，没有被 memo 包裹的子组件 Child 也会进行渲染，而包裹的则不会。同时 memo 的第二个参数可以主动控制是否渲染，当数字大于等于 7 时，则对包裹的组件停止渲染。"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["注意：memo 的第二个参数的返回值与 ",(0,t.jsx)(n.code,{children:"shouldComponentUpdate"})," 的返回值是相反的。这点要注意下。"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"3优化方案的区别",children:["3.优化方案的区别",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3优化方案的区别",children:"#"})]}),"\n",(0,t.jsxs)(n.table,{children:["\n",(0,t.jsxs)(n.thead,{children:["\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.th,{children:"优化方式"}),"\n",(0,t.jsx)(n.th,{children:"服务对象"}),"\n",(0,t.jsx)(n.th,{children:"返回结果"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.tbody,{children:["\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"PureComponent"}),"\n",(0,t.jsx)(n.td,{children:"类组件"}),"\n",(0,t.jsx)(n.td,{children:"true：不渲染，false：渲染"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"memo"}),"\n",(0,t.jsx)(n.td,{children:"类组件或函数组件"}),"\n",(0,t.jsx)(n.td,{children:"true：渲染，false：不渲染"}),"\n"]}),"\n",(0,t.jsxs)(n.tr,{children:["\n",(0,t.jsx)(n.td,{children:"useMemo"}),"\n",(0,t.jsx)(n.td,{children:"函数组件"}),"\n",(0,t.jsx)(n.td,{children:"-"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h1,{id:"usecallback-的性能问题",children:["useCallback 的性能问题",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecallback-的性能问题",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在所有的 Hooks 中，useCallback 可能是最具争议的一个 hook，根本原因还是性能问题。"}),"\n",(0,t.jsx)(n.p,{children:"首先 useCallback 可以记住函数，避免函数的重复生成，缓存后的函数传递给子组件时，可以避免子组件的重复渲染，从而提升性能。"}),"\n",(0,t.jsx)(n.p,{children:"那是不是说只要是函数，都加入 useCallback，性能都会得到提升呢？"}),"\n",(0,t.jsxs)(n.p,{children:["实际不然，性能的提升还有一个前提：",(0,t.jsx)(n.strong,{children:"其子组件必须通过 React.memo 包裹，或者必须使用 shouldComponentUpdate 处理"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"那么如果不进行配套使用，单独使用 useCallback，这种情况下性能不但没有提升，反而还会影响性能。"}),"\n",(0,t.jsx)(n.p,{children:"这是因为当一个函数执行完毕后，就会从调用函数的栈中被弹出，里面的内存也会被回收，即便在函数的内部再创建多个函数，最终也会被释放掉。"}),"\n",(0,t.jsxs)(n.p,{children:["而",(0,t.jsx)(n.strong,{children:"函数式组件的性能本身是非常快的"}),"，它不同于 Class 组件，本身并没有",(0,t.jsx)(n.code,{children:"renderProps"})," 等额外层级技术，所以相对轻量，而我们使用 useCallack 的时候，这本身就有一定的代价，相当于在原本的基础上增加了",(0,t.jsx)(n.strong,{children:"闭包的使用"}),"、",(0,t.jsx)(n.strong,{children:"deps 对比的逻辑"}),"，因此，盲目的使用反而会造成组件的负担。"]}),"\n",(0,t.jsx)(n.p,{children:"来看看这个例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { useState, useCallback, memo } from "react";\nimport { Button } from "antd";\n\nconst Index: React.FC<any> = () => {\n  let [count, setCount] = useState(0);\n  let [number, setNumber] = useState(0);\n  let [flag, setFlag] = useState(true);\n\n  const add = useCallback(() => {\n    setCount(count + 1);\n  }, [count]);\n\n  return (\n    <>\n      <div>数字number：{number}</div>\n      <div>数字count：{count}</div>\n      <TestButton onClick={() => setNumber((v) => v + 1)}>普通点击</TestButton>\n      <TestButton onClick={add}>useCallback点击</TestButton>\n      <Button\n        style={{ marginLeft: 10 }}\n        type="primary"\n        onClick={() => setFlag((v) => !v)}\n      >\n        切换{JSON.stringify(flag)}\n      </Button>\n    </>\n  );\n};\n\nconst TestButton = memo(({ children, onClick = () => {} }: any) => {\n  console.log(children);\n  return (\n    <Button\n      type="primary"\n      onClick={onClick}\n      style={children === "useCallback点击" ? { marginLeft: 10 } : undefined}\n    >\n      {children}\n    </Button>\n  );\n});\n\nexport default Index;\n'})}),"\n",(0,t.jsx)(n.p,{children:"在父组件（ Index ）中共有三个变量：number、count、flag，子组件（TestButton）封装了一个按钮，控制 number 和 count 的变化，其中 count 的变化 add 被 useCallback 包裹，那么看下效果："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsx)(n.p,{children:"简要地分析下：flag 这个变量与 count 和 number 没有关系，同时也和 TestButton 没有关系，但它的更改，却能让没有被 useCallBack 包裹的组件刷新。"}),"\n",(0,t.jsx)(n.p,{children:"这是因为子组件认为两个函数并非相等，所以会触发更新；相反，用 usecallBack 包裹的组件传递的 onClick 还是之前缓存的 add，没有发生改变，所以不会触发更新。"}),"\n",(0,t.jsxs)(n.p,{children:["同理，如果没有 ",(0,t.jsx)(n.code,{children:"memo/shouldComponentUpdate"})," 的协助，就没有浅比较的逻辑，不管有没有 useCallck 的缓存，都会重新执行子组件。"]}),"\n",(0,t.jsxs)(n.p,{children:["所以说，useCallback 一定要配合 ",(0,t.jsx)(n.strong,{children:"memo/shouldComponentUpdate"})," 的协助，才能起到优化作用。"]}),"\n",(0,t.jsxs)(n.h2,{id:"usecallback-不推荐使用",children:["useCallback 不推荐使用",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecallback-不推荐使用",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["对于 useCallback，我的建议是：",(0,t.jsx)(n.strong,{children:"绝大部分场景不使用"}),"。原因有以下几点："]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"很难看到优化后的效果"}),"：从效果上来讲，useCallBack 配合 ",(0,t.jsx)(n.code,{children:"memo/shouldComponentUpdate"})," 确实能够阻止子组件的无关渲染，但这个渲染是 ",(0,t.jsx)(n.strong,{children:"render 的渲染，并非浏览器渲染，"})," 但 js 的运行要远远快于浏览器的 ",(0,t.jsx)(n.code,{children:"Rendering"})," 和 ",(0,t.jsx)(n.code,{children:"Painting"}),"，再加上 React 本身提供 diff 算法，所以很难看到优化后的价值。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用起来较为麻烦："})," 当判断是否使用时，要先考虑其价值是否值得，如果是案例中的场景，那么使用 useCallback 就完全没有必要。除非是特别复杂的组件，才会考虑单独使用。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"对新手不友好："})," 要让 useCallback 起到优化作用，必须配合",(0,t.jsx)(n.code,{children:"memo/shouldComponentUpdate"}),"，也就是说你要了解对应的 API，否则很容易出现 bug，其次 useCallback 本身存在闭包问题，很容易入坑。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"代码可读性变差"}),"：使用 useCallback 的时候很容易出现“无限套娃”的情况，引用维护依赖关系时要变得小心翼翼，修改时要考虑的要素很多，一点没考虑到，就会出现 bug。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"usecallback-使用场景",children:["useCallback 使用场景",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecallback-使用场景",children:"#"})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["当设计一个",(0,t.jsx)(n.strong,{children:"极其复杂的组件"}),"，其函数体非常复杂时，优先考虑 ",(0,t.jsx)(n.strong,{children:"useCallback"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"自定义 Hooks 的设计"}),"，因为在自定义 Hooks 里面的函数，不会依赖于引用它的组件里面的数据，同时如果函数传递给第三方使用，可以规避第三方组件的重复渲染。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h1,{id:"usememo-适当使用",children:["useMemo 适当使用",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usememo-适当使用",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"相对于 useCallback，useMemo 的收益就显而易见了，但 useMemo 也并不是无限制使用，在简单的场景下同样也不建议使用，比如："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"a = 1\nb = 2\n\nc = a + b;\nd = useMemo(() => a + b, [a, b])\n"})}),"\n",(0,t.jsxs)(n.p,{children:["很明显 c 是只计算 ",(0,t.jsx)(n.code,{children:"a + b"}),"，而 d 还要记录 a 和 b 的值，还要比较是否更改，这种情况下，c 的消耗明显小于 d 的消耗。"]}),"\n",(0,t.jsxs)(n.p,{children:["综上所述，",(0,t.jsx)(n.strong,{children:"useMemo 推荐适当使用"}),"。"]}),"\n",(0,t.jsxs)(n.h1,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在本小节中，我们首先学习了 useMemo 和 useCallback 的源码，两者的源码可以说是一模一样，只是 useMemo 比 useCallback 多了执行了 ",(0,t.jsx)(n.code,{children:"nextCreate()"})," 函数，可以说 ",(0,t.jsx)(n.strong,{children:"useMemo 是 useCallback 的语法糖"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"学习完源码后，我们继续深究 React 的其他性能优化的方案，搞懂在类组件中的 shouldComponentUpdate 生命周期和 PureComponent 组件的优化原理，同时弄懂 React.memo 高阶组件，要注意它本身就支持 Class 组件和函数式组件。"}),"\n",(0,t.jsxs)(n.p,{children:["最后，我们知道了为什么 useCallback 一定要配合 ",(0,t.jsx)(n.strong,{children:"memo/shouldComponentUpdate"})," 的协助，明确了 useMemo 和 useCallBack 的使用场景。"]}),"\n",(0,t.jsx)(n.p,{children:"总的来说，useMemo 和 useCallBack 是两个非常重要的 Hooks，我们一定不要乱用它们，合理地使用才会让项目事半功倍。"}),"\n",(0,t.jsx)(n.p,{children:"下一章，我们一起走进 useRef 的世界，探索 Ref 的奥秘。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F12.%E6%BA%90%E7%A0%81%E7%AF%87%EF%BD%9C%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%20useMemo%20%E5%92%8C%20useCallback.md"]={toc:[{text:"mountMemo/mountCallback（初始化）",id:"mountmemomountcallback初始化",depth:2},{text:"updateMemo/updateCallback（更新）",id:"updatememoupdatecallback更新",depth:2},{text:"1.类组件的性能优化",id:"1类组件的性能优化",depth:2},{text:"对比 shouldComponentUpdate 和 PureComponent",id:"对比-shouldcomponentupdate-和-purecomponent",depth:3},{text:"shallowEqual 浅比较",id:"shallowequal-浅比较",depth:3},{text:"2.React.memo 高阶组件",id:"2reactmemo-高阶组件",depth:2},{text:"3.优化方案的区别",id:"3优化方案的区别",depth:2},{text:"useCallback 不推荐使用",id:"usecallback-不推荐使用",depth:2},{text:"useCallback 使用场景",id:"usecallback-使用场景",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);