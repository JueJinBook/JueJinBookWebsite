"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["14293"],{103649:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var d=r(552676),s=r(740453);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",h2:"h2",pre:"pre",blockquote:"blockquote",ol:"ol",li:"li",ul:"ul"},(0,s.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"7如何管控应用的窗口下",children:["7.如何管控应用的窗口（下）？",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7如何管控应用的窗口下",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在上一节中，我们向大家展示了一个困扰业界很久的问题：",(0,d.jsx)(n.code,{children:"窗口加载过慢"}),"的问题，并且介绍了解决这个问题的一种方案（",(0,d.jsx)(n.strong,{children:"窗口池方案"}),"），然而这个方案存在几个缺点，所以本节我们将详细分析另外一种方案。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们知道 Electron 是允许使用 ",(0,d.jsx)(n.code,{children:"window.open"})," 的方式打开一个子窗口，",(0,d.jsx)(n.strong,{children:"通过这种方式打开的子窗口不会创建新的进程，效率非常高，可以在几百毫秒内就为用户呈现窗口内容"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"虽然这个方案可以应对一般的多窗口应用的需求，但对于一些复杂的需求却需要很多额外的处理才能满足需求，比如：系统设置子窗口，当用户完成某一项设置之后，要通知父窗口做出相应的改变。这是常见的父子窗口通信的需求。"}),"\n",(0,d.jsx)(n.p,{children:"本节我们就讲解如何实现 window.open 创建子窗口的方案，以及如何解决这个方案带来的窗口间通信的问题。"}),"\n",(0,d.jsxs)(n.h2,{id:"windowopen-解决方案",children:["window.open 解决方案",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#windowopen-解决方案",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["Electron 允许渲染进程通过",(0,d.jsx)(n.code,{children:"window.open"}),"打开一个新窗口，但这需要做一些额外的设置。"]}),"\n",(0,d.jsxs)(n.p,{children:["首先需要为主窗口的",(0,d.jsx)(n.code,{children:"webContents"}),"注册",(0,d.jsx)(n.code,{children:"setWindowOpenHandler"}),"方法。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:'//src\\main\\CommonWindowEvent.ts\nmainWindow.webContents.setWindowOpenHandler((param) => {\n  return { action: "allow", overrideBrowserWindowOptions: yourWindowConfig };\n});\n'})}),"\n",(0,d.jsxs)(n.p,{children:["我们在上面的代码中使用",(0,d.jsx)(n.code,{children:"setWindowOpenHandler"}),"方法的回调函数返回一个对象，这个对象中",(0,d.jsx)(n.code,{children:'action: "allow"'}),"代表允许窗口打开，如果你想阻止窗口打开，那么只要返回",(0,d.jsx)(n.code,{children:'{action: "deny"}'}),"即可。"]}),"\n",(0,d.jsxs)(n.p,{children:["返回对象的",(0,d.jsx)(n.code,{children:"overrideBrowserWindowOptions"}),"属性的值是被打开的新窗口的配置对象。"]}),"\n",(0,d.jsx)(n.p,{children:"在渲染进程中打开子窗口的代码如下所示:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"//src\\renderer\\Component\\BarLeft.vue\nwindow.open(`/WindowSetting/AccountSetting`);\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"window.open"}),"打开新窗口之所以速度非常快，是因为用这种方式创建的新窗口不会创建新的进程。这也就意味着一个窗口崩溃会拖累其他窗口跟着崩溃（主窗口不受影响）。"]}),"\n",(0,d.jsxs)(n.p,{children:["使用",(0,d.jsx)(n.code,{children:"window.open"}),"打开的新窗口还有一个问题，这类窗口在关闭之后虽然会释放掉大部分内存，但有一小部分内存无法释放（无论你打开多少个子窗口，全部关闭之后总会有那么固定的一小块内存无法释放），这与窗口池方案的内存损耗相当。"]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["这个问题可能与 Electron 的这个 Issue 有关：",(0,d.jsx)(n.a,{href:"https://github.com/electron/electron/issues/12634",target:"_blank",rel:"noopener noreferrer",children:"window.open with nativeWindowOpen option causes memory leak"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["同样使用这个方案也无法优化应用的第一个窗口的创建速度。而且",(0,d.jsx)(n.code,{children:"<webview>"}),"和",(0,d.jsx)(n.code,{children:"BrowserView"}),"慢的问题无法使用这个方案解决（这类需求还是应该考虑“池”方案）。"]}),"\n",(0,d.jsxs)(n.p,{children:["但是通过",(0,d.jsx)(n.code,{children:"window.open"}),"打开的新窗口更容易控制，这是这个方案最大的优点。接下来我们就介绍如何使用这个方案控制子窗口。"]}),"\n",(0,d.jsxs)(n.h2,{id:"子窗口的标题栏消息",children:["子窗口的标题栏消息",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#子窗口的标题栏消息",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在上一节中，我们自定义了主窗口的标题栏",(0,d.jsx)(n.code,{children:"BarTop.vue"}),"，我们知道标题栏组件需要监听主进程发来的",(0,d.jsx)(n.code,{children:"windowMaximized"}),"消息和",(0,d.jsx)(n.code,{children:"windowUnmaximized"}),"消息，子窗口当然也希望复用这个组件，然而子窗口的窗口对象是在 Electron 内部创建的，不是我们开发者创建的，没有子窗口的窗口对象，我们该如何使用上一节介绍的",(0,d.jsx)(n.code,{children:"regWinEvent"}),"方法为子窗口注册最大化和还原事件呢？"]}),"\n",(0,d.jsxs)(n.p,{children:["这就需要用到 ",(0,d.jsx)(n.code,{children:"app"})," 对象的",(0,d.jsx)(n.code,{children:"browser-window-created"}),"事件，代码如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:'//src\\main\\mainEntry.ts\napp.on("browser-window-created", (e, win) => {\n  CommonWindowEvent.regWinEvent(win);\n});\n'})}),"\n",(0,d.jsxs)(n.p,{children:["每当有一个窗口被创建成功后，这个事件就会被触发，主窗口和使用",(0,d.jsx)(n.code,{children:"window.open"}),"创建的子窗口都一样，所以之前我们为主窗口注册事件的代码",(0,d.jsx)(n.code,{children:"CommonWindowEvent.regWinEvent(mainWindow)"}),"也可以删掉了。这个事件的第二个参数就是窗口对象。"]}),"\n",(0,d.jsxs)(n.h2,{id:"动态设置子窗口的配置",children:["动态设置子窗口的配置",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#动态设置子窗口的配置",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["虽然我们可以在渲染进程中用",(0,d.jsx)(n.code,{children:"window.open"}),"方法打开一个子窗口，但这个子窗口的配置信息目前还是在主进程中设置的（",(0,d.jsx)(n.code,{children:"overrideBrowserWindowOptions"}),"），大部分时候我们要根据渲染进程的要求来改变子窗口的配置，所以最好的办法是由渲染进程来设置这些配置信息。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们为上一节介绍的",(0,d.jsx)(n.code,{children:"CommonWindowEvent"}),"类的",(0,d.jsx)(n.code,{children:"regWinEvent"}),"方法增加一段逻辑，代码如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:'//src\\main\\CommonWindowEvent.ts\n//注册打开子窗口的回调函数\nwin.webContents.setWindowOpenHandler((param) => {\n  //基础窗口配置对象\n  let config = {\n    frame: false,\n    show: true,\n    webPreferences: {\n      nodeIntegration: true,\n      webSecurity: false,\n      allowRunningInsecureContent: true,\n      contextIsolation: false,\n      webviewTag: true,\n      spellcheck: false,\n      disableHtmlFullscreenWindowResize: true,\n      nativeWindowOpen: true,\n    },\n  };\n  //开发者自定义窗口配置对象\n  let features = JSON.parse(param.features);\n  for (let p in features) {\n    if (p === "webPreferences") {\n      for (let p2 in features.webPreferences) {\n        config.webPreferences[p2] = features.webPreferences[p2];\n      }\n    } else {\n      config[p] = features[p];\n    }\n  }\n  if (config["modal"] === true) config.parent = win;\n  //允许打开窗口，并传递窗口配置对象\n  return { action: "allow", overrideBrowserWindowOptions: config };\n});\n'})}),"\n",(0,d.jsxs)(n.p,{children:["在这段代码中，",(0,d.jsx)(n.code,{children:"config"}),"对象和主窗口的",(0,d.jsx)(n.code,{children:"config"}),"对象基本上是一样的，所以最好把它抽象出来，我们这里为了演示方便没做这个工作。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"param"}),"参数的",(0,d.jsx)(n.code,{children:"features"}),"属性是由渲染进程传过来的，是一个字符串，这里我们把它当作一个 JSON 字符串使用，这个字符串里包含着渲染进程提供的窗口配置项，这些配置项与 ",(0,d.jsx)(n.code,{children:"config"})," 对象提供的基础配置项结合，最终形成了子窗口的配置项。"]}),"\n",(0,d.jsxs)(n.p,{children:["如果配置项中",(0,d.jsx)(n.code,{children:"modal"}),"属性的值为",(0,d.jsx)(n.code,{children:"true"}),"的话，说明渲染进程希望子窗口为一个模态窗口，这时我们要为子窗口提供父窗口配置项：",(0,d.jsx)(n.code,{children:"parent"}),"，这个配置项的值就是当前窗口。"]}),"\n",(0,d.jsxs)(n.p,{children:["之所以把这段逻辑放置在",(0,d.jsx)(n.code,{children:"CommonWindowEvent"}),"类的",(0,d.jsx)(n.code,{children:"regWinEvent"}),"方法中，就是希望更方便地为应用内的所有窗口提供这项能力，如果你不希望这么做，也可以把这段逻辑放置在一个独立的方法中。"]}),"\n",(0,d.jsx)(n.p,{children:"现在渲染进程中打开子窗口的代码可以变成这样了："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:'//src\\renderer\\Component\\BarLeft.vue\nlet openSettingWindow = () => {\n  let config = { modal: true, width: 2002, webPreferences: { webviewTag: false } };\n  window.open(`/WindowSetting/AccountSetting`, "_blank", JSON.stringify(config));\n};\n'})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"window.open"}),"方法的第三个参数官方定义为一个逗号分割的 key-value 列表，但这里我们把它变成了一个 JSON 字符串，这样做主要是为了方便地控制子窗口的配置对象。"]}),"\n",(0,d.jsxs)(n.p,{children:["使用",(0,d.jsx)(n.code,{children:"window.open"}),"打开新窗口速度非常快，所以这里我们直接让新窗口显示出来了",(0,d.jsx)(n.code,{children:"config.show = true"}),"。如果你需要在新窗口初始化时完成复杂耗时的业务逻辑，那么你也应该手动控制新窗口的显示时机。就像我们控制主窗口一样。"]}),"\n",(0,d.jsxs)(n.h2,{id:"封装子窗口加载成功的事件",children:["封装子窗口加载成功的事件",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#封装子窗口加载成功的事件",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["现在我们遇到了一个问题：不知道子窗口何时加载成功了，注意这里不能单纯地使用",(0,d.jsx)(n.code,{children:"window"}),"对象的",(0,d.jsx)(n.code,{children:"onload"}),"事件或者 document 对象的",(0,d.jsx)(n.code,{children:"DOMContentLoaded"}),"事件来判断子窗口是否加载成功了。因为这个时候你的业务代码（比如从数据库异步读取数据的逻辑）可能尚未执行完成。"]}),"\n",(0,d.jsx)(n.p,{children:"所以，我们要自己封装一个事件，在我们的业务代码真正执行完成时，手动发射这个事件，告知主窗口：“现在子窗口已经加载成功啦，你可以给我发送消息了！”"}),"\n",(0,d.jsxs)(n.p,{children:["在封装这个事件前，我们先来把",(0,d.jsx)(n.code,{children:"window.open"}),"打开子窗口的逻辑封装到一个",(0,d.jsx)(n.code,{children:"Promise"}),"对象中，如下代码所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:'//src\\renderer\\common\\Dialog.ts\nexport let createDialog = (url: string, config: any): Promise<Window> => {\n  return new Promise((resolve, reject) => {\n    let windowProxy = window.open(url, "_blank", JSON.stringify(config));\n    let readyHandler = (e) => {\n      let msg = e.data;\n      if (msg["msgName"] === `__dialogReady`) {\n        window.removeEventListener("message", readyHandler);\n        resolve(windowProxy);\n      }\n    };\n    window.addEventListener("message", readyHandler);\n  });\n};\n'})}),"\n",(0,d.jsxs)(n.p,{children:["在这段代码中，我们把渲染进程的一些工具方法和类放置在",(0,d.jsx)(n.code,{children:"src\\renderer\\common\\"}),"目录下（注意，有别于",(0,d.jsx)(n.code,{children:"src\\common\\"}),"目录）。"]}),"\n",(0,d.jsxs)(n.p,{children:["当渲染进程的某个组件需要打开子窗口时，可以使用",(0,d.jsx)(n.code,{children:"Dialog.ts"}),"提供的",(0,d.jsx)(n.code,{children:"createDialog"}),"方法。"]}),"\n",(0,d.jsxs)(n.p,{children:["在这段代码中，我们把",(0,d.jsx)(n.code,{children:"window.open"}),"的逻辑封装到一个",(0,d.jsx)(n.code,{children:"Promise"}),"对象中， 通过",(0,d.jsx)(n.code,{children:"window.open"}),"打开子窗口后，当前窗口马上监听",(0,d.jsx)(n.code,{children:"message"}),"事件，子窗口有消息发送给当前窗口时，这个事件将被触发。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们在",(0,d.jsx)(n.code,{children:"message"}),"事件的处理函数中完成了下面三个工作。"]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsx)(n.li,{children:"e.data 里存放着具体的消息内容，我们把它格式化成一个 JSON 对象。"}),"\n",(0,d.jsxs)(n.li,{children:["如果这个 JSON 对象的",(0,d.jsx)(n.code,{children:"msgName"}),"属性为",(0,d.jsx)(n.code,{children:"__dialogReady"}),"字符串，我们就成功",(0,d.jsx)(n.code,{children:"resolve"}),"。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"Promise"}),"对象成功",(0,d.jsx)(n.code,{children:"resolve"}),"之前要移除掉",(0,d.jsx)(n.code,{children:"message"}),"事件的监听函数，避免内存泄漏（如果不这么做，用户每打开一个子窗口，就会注册一次",(0,d.jsx)(n.code,{children:"message"}),"事件）。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"window.open"}),"方法返回的是目标窗口的引用，我们可以使用这个引用对象向目标窗口发送消息，或执行其他相关操作。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Dialog.ts"}),"并非只导出了",(0,d.jsx)(n.code,{children:"createDialog"}),"这么一个方法，它还导出了",(0,d.jsx)(n.code,{children:"dialogReady"}),"方法，代码如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:"//src\\renderer\\common\\Dialog.ts\nexport let dialogReady = () => {\n  let msg = { msgName: `__dialogReady` };\n  window.opener.postMessage(msg);\n};\n"})}),"\n",(0,d.jsx)(n.p,{children:"这个方法是为子窗口服务的，当子窗口完成了必要的业务逻辑之后，就可以执行这个方法，通知父窗口自己已经加载成功。"}),"\n",(0,d.jsxs)(n.p,{children:["这个方法通过",(0,d.jsx)(n.code,{children:"window.opener"}),"对象的",(0,d.jsx)(n.code,{children:"postMessage"}),"方法向父窗口发送了一个消息，这个消息的内容是一个 JSON 对象，这个 JSON 对象的",(0,d.jsx)(n.code,{children:"msgName"}),"属性为",(0,d.jsx)(n.code,{children:"__dialogReady"}),"字符串。"]}),"\n",(0,d.jsxs)(n.p,{children:["父窗口收到子窗口发来的这个消息后，将触发",(0,d.jsx)(n.code,{children:"message"}),"事件，也就会执行我们在",(0,d.jsx)(n.code,{children:"createDialog"}),"方法中撰写的逻辑了。"]}),"\n",(0,d.jsxs)(n.h2,{id:"父子窗口互相通信",children:["父子窗口互相通信",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#父子窗口互相通信",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["我们可以使用 ",(0,d.jsx)(n.code,{children:"createDialog"})," 方法返回的对象向子窗口发送消息，代码如下所示："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:'//src\\renderer\\Component\\BarLeft.vue\nlet config = { modal: true, width: 800, webPreferences: { webviewTag: false } };\nlet dialog = await createDialog(`/WindowSetting/AccountSetting`, config);\nlet msg = { msgName: "hello", value: "msg from your parent" };\ndialog.postMessage(msg);\n'})}),"\n",(0,d.jsx)(n.p,{children:"想要接收子窗口发来的消息，只要监听 window 对象的 message 事件即可，代码如下所示："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:'//src\\renderer\\Component\\BarLeft.vue\nwindow.addEventListener("message", (e) => {\n  console.log(e.data);\n});\n'})}),"\n",(0,d.jsx)(n.p,{children:"子窗口发送消息给父窗口的代码如下所示："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-ts",children:'window.opener.postMessage({ msgName: "hello", value: "I am your son." });\n'})}),"\n",(0,d.jsx)(n.p,{children:"子窗口接收父窗口发来的消息的代码，与父窗口接收消息的代码相同，我们就不再赘述了。"}),"\n",(0,d.jsx)(n.p,{children:"相对于使用 ipcRender 和 ipcMain 的方式完成窗口间通信来说，使用这种方式完成跨窗口通信有以下几项优势："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"消息传递与接收效率都非常高，均为毫秒级；"}),"\n",(0,d.jsx)(n.li,{children:"开发更加简单，代码逻辑清晰，无需跨进程中转消息。"}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"总结",children:["总结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"我们通过本节内容详细介绍了如何使用 window.open 方案管控子窗口。"}),"\n",(0,d.jsx)(n.p,{children:"本节一共分为五部分：首先我们介绍了如何使用 window.open 创建子窗口（同时还介绍了 window.open 方案的一些不足），接着我们介绍了如何为子窗口注册标题栏事件（实际上系统中所有的窗口都可以这种方式注册标题栏事件），然后我们介绍了如何动态设置子窗口的配置（开发者可以根据不同的业务创建不同的子窗口），再然后我们介绍了如何封装子窗口加载成功的事件（为父子窗口通信奠定了基础），最后我们介绍了父子窗口间如何通信（以及这种通信方式的优势）。"}),"\n",(0,d.jsx)(n.p,{children:"学会了如何管控应用的窗口，我就要学习如何管控应用的数据了，接下来我们将讲解如何为应用引入 pinia 库并使用它管控应用的数据状态。"}),"\n",(0,d.jsxs)(n.h2,{id:"源码",children:["源码",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#源码",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"本节示例代码请通过如下地址自行下载："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.a,{href:"https://gitee.com/horsejs_admin/electron-jue-jin/tree/window",target:"_blank",rel:"noopener noreferrer",children:"源码仓储"})})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(i,{...e})}):i(e)}let c=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["Electron%20%2B%20Vue%203%20%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%2F7.%E5%A6%82%E4%BD%95%E7%AE%A1%E6%8E%A7%E5%BA%94%E7%94%A8%E7%9A%84%E7%AA%97%E5%8F%A3%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9F.md"]={toc:[{text:"window.open 解决方案",id:"windowopen-解决方案",depth:2},{text:"子窗口的标题栏消息",id:"子窗口的标题栏消息",depth:2},{text:"动态设置子窗口的配置",id:"动态设置子窗口的配置",depth:2},{text:"封装子窗口加载成功的事件",id:"封装子窗口加载成功的事件",depth:2},{text:"父子窗口互相通信",id:"父子窗口互相通信",depth:2},{text:"总结",id:"总结",depth:2},{text:"源码",id:"源码",depth:2}],title:"7.如何管控应用的窗口（下）？",headingTitle:"7.如何管控应用的窗口（下）？",frontmatter:{}}}}]);