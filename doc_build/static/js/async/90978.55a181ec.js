"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["90978"],{714605:function(e,n,a){a.r(n),a.d(n,{default:()=>t});var l=a(552676),i=a(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",code:"code",pre:"pre",ol:"ol",li:"li",h4:"h4",blockquote:"blockquote"},(0,i.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{id:"50照片文件管理",children:["50.照片文件管理",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#50照片文件管理",children:"#"})]}),"\n",(0,l.jsxs)(n.h2,{id:"78-照片文件管理",children:["7.8 照片文件管理",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#78-照片文件管理",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"当用户在小程序端随机选择一个相册/文件夹，在程序的处理上用户是怎样就能看到这与之相应的照片/文件列表页面？而当用户在这个列表的页面上传照片/文件时，又是怎么将照片/文件上传到指定的这个列表里的并保存文件名的？维系用户（含权限）、相册/文件夹、照片/文件三者之间关系的核心仍然是数据库，这些看似复杂功能的背后也同样只是JavaScript对不同数据类型的操作。"}),"\n",(0,l.jsxs)(n.h3,{id:"781-数组的index与交互",children:["7.8.1 数组的index与交互",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#781-数组的index与交互",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"页面交互里的点击某个相册/文件夹链接，就能打开与之相应的照片/文件的列表页，首先需要让链接携带包含该相册/文件夹唯一id的参数，然后在列表页能够获取这个参数，再根据这个唯一id来查找相应的照片/文件的数据并渲染到页面上。"}),"\n",(0,l.jsx)(n.p,{children:"不过由于我们在设计数据库时，并没有给每个相册/文件夹设置id这个字段，但是我们可以借助于数组的index，userData的里的folders、albums就是数组，而每个相册/文件夹的index值都是按照顺序且唯一的。"}),"\n",(0,l.jsxs)(n.p,{children:["我们再来回顾一下链接携带参数以及提取参数的知识，在folder.wxml页面的组件的链接里添加",(0,l.jsx)(n.code,{children:"/pages/file/file?index={{idx}}"}),"，再在file.js的生命周期函数onLoad的options将参数提取出来："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-javascript",children:'//在folder.wxml通过链接携带index的参数，注意这个index与列表渲染相关\n<block wx:for="{{userData[0].folders}}" wx:for-index="idx" wx:for-item="folder" wx:key="item">\n    <mp-cell link hover url="/pages/file/file?index={{idx}}" value="{{folder.folderName}}"\n        footer="{{folder.files.length}}">\n    </mp-cell>\n</block>\n\n//在file.js生命周期函数onLoad的options，我们可以提取链接携带的index\nconst app = getApp()\nPage({\n  data: {\n    folderIndex: null,\n    folerData:[]\n  },\n\n  onLoad: function (options) {\n    this.setData({  //将获取到的index赋值给folderIndex\n      folderIndex: parseInt(options.index),  //将字符串转为Number类型\n    })\n\n    const index = parseInt(options.index) \n    this.setData({  //根据获取到的index，将指定（该index）的folders数据赋值给folerData\n      folderData: app.globalData.userData[0].folders[index]\n    })\n    console.log("赋值了一个啥", this.data.folderData)\n  },\n\n})\n\n//从这里我们可以判断我们打开的到底是列表里的第几个相册/文件夹，因为数组是从0开始计数，所以+1\n<text>你打开的是第{{folderIndex+1}}个文件夹</text>\n\n//渲染数据指定id的文件夹内的文件列表到页面\n<block wx:for="{{folderData.files}}" wx:for-index="idx" wx:for-item="file" wx:key="item">\n  <mp-cell hover value="{{file.name}}"></mp-cell>\n</block>\n'})}),"\n",(0,l.jsxs)(n.h3,{id:"782-上传单个文件到文件夹",children:["7.8.2 上传单个文件到文件夹",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#782-上传单个文件到文件夹",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"相信大家都应该在其他小程序体验过文件上传的功能，在交互上这个功能虽然看起来简单，但是在代码的逻辑上却包含着四个步骤："}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"首先把文件上传到小程序的临时文件，并获取临时文件地址以及文件的名称；"}),"\n",(0,l.jsx)(n.li,{children:"将临时文件上传到云存储指定云文件里，并取到文件的FileID；"}),"\n",(0,l.jsx)(n.li,{children:"将文件在云存储的FileID和文件的名称更新到数据库；"}),"\n",(0,l.jsx)(n.li,{children:"获取文件夹内所有文件的信息。"}),"\n"]}),"\n",(0,l.jsxs)(n.h4,{id:"1上传文件到小程序的临时文件",children:["1、上传文件到小程序的临时文件",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1上传文件到小程序的临时文件",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"使用开发者工具在file.wxml里输入以下代码："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-xml",children:'<form bindsubmit="uploadFiles"> \n   <button type="primary" bindtap="chooseMessageFile">选择文件</button>\n   <button type="primary" formType="submit">上传文件</button>\n</form>\n'})}),"\n",(0,l.jsx)(n.p,{children:"然后在file.js里输入以下代码："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-javascript",children:"chooseMessageFile(){\n  const files = this.data.files\n  wx.chooseMessageFile({\n    count: 5,\n    success: res => {\n      console.log('选择文件之后的res',res)\n      let tempFilePaths = res.tempFiles\n      for (const tempFilePath of tempFilePaths) {\n        files.push({\n          src: tempFilePath.path,\n          name: tempFilePath.name\n        })\n      }\n      this.setData({ files: files })\n      console.log('选择文件之后的files', this.data.files)\n    }\n  })\n},\n"})}),"\n",(0,l.jsxs)(n.h4,{id:"2将临时文件上传到云存储",children:["2、将临时文件上传到云存储",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2将临时文件上传到云存储",children:"#"})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-javascript",children:'uploadFiles(e) {\n  const filePath = this.data.files[0].src\n  const cloudPath = `cloudbase/${Date.now()}-${Math.floor(Math.random(0, 1) * 1000)}` + filePath.match(/.[^.]+?$/)\n  wx.cloud.uploadFile({   \n    cloudPath,filePath\n  }).then(res => {\n    this.setData({\n      fileID:res.fileID\n    })      \n  }).catch(error => {\n    console.log("文件上传失败",error)\n  })\n},\n'})}),"\n",(0,l.jsxs)(n.h4,{id:"3将文件信息存储到数据库",children:["3、将文件信息存储到数据库",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3将文件信息存储到数据库",children:"#"})]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-javascript",children:'addFiles(fileID) {\n  const name = this.data.files[0].name\n  const _id= this.data.userData.data[0]._id\n  db.collection(\'clouddisk\').doc(_id).update({\n    data: {\n      \'folders.0.files\': _.push({\n        "name":name,\n        "fileID":fileID\n      })\n    }\n  }).then(result => {\n    console.log("写入成功", result)\n    wx.navigateBack()\n  }\n  )\n}\n'})}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"尽管我们已经往文件夹里上传了文件，但是这个文件却并没有及时的渲染出来，这是因为为了减少页面对数据库的请求，我们只在folder页面的onLoad生命周期函数里查询了一次数据库，其他页面都是通过app.globalData来获取数据，也就是如果不重新加载folder页面，数据就不会及时更新。要将用户上传的文件及时渲染出来，有两种方式，一是通过页面的生命周期函数触发数据库的get查询；二是将新上传的文件数据使用concat到app.globalData里或放到缓存里，不去请求数据库，在UI交互上，用户同样可以及时看到新文件被及时渲染，但是事实上这个数据并不来自数据库，也不是真正最终的查询结果。这种“假象”非常适用于一些对交互、性能有一定要求的场景。"}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(s,{...e})}):s(e)}let t=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%2F50.%E7%85%A7%E7%89%87%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.md"]={toc:[{text:"7.8 照片文件管理",id:"78-照片文件管理",depth:2},{text:"7.8.1 数组的index与交互",id:"781-数组的index与交互",depth:3},{text:"7.8.2 上传单个文件到文件夹",id:"782-上传单个文件到文件夹",depth:3},{text:"1、上传文件到小程序的临时文件",id:"1上传文件到小程序的临时文件",depth:4},{text:"2、将临时文件上传到云存储",id:"2将临时文件上传到云存储",depth:4},{text:"3、将文件信息存储到数据库",id:"3将文件信息存储到数据库",depth:4}],title:"50.照片文件管理",headingTitle:"50.照片文件管理",frontmatter:{}}}}]);