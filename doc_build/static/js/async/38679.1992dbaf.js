"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["38679"],{69682:function(e,n,s){s.r(n),s.d(n,{default:()=>t});var i=s(552676),r=s(740453);function d(e){let n=Object.assign({p:"p",h3:"h3",a:"a",pre:"pre",code:"code",img:"img"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"我们天天都在使用 Redis 内置的命令行工具 redis-cli，久而久之以为它就是一个简单的交互式 Redis 数据结构手工操作程序，但是它背后强大的功能绝大多数同学可能闻所未闻。本节我们一起来挖掘这些鲜为人知的有趣用法。"}),"\n",(0,i.jsxs)(n.h3,{id:"执行单条命令",children:["执行单条命令",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行单条命令",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"平时在访问 Redis 服务器，一般都会使用 redis-cli 进入交互模式，然后一问一答来读写服务器，这种情况下我们使用的是它的「交互模式」。还有另外一种「直接模式」，通过将命令参数直接传递给 redis-cli 来执行指令并获取输出结果。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ redis-cli incrby foo 5\n(integer) 5\n$ redis-cli incrby foo 5\n(integer) 10\n"})}),"\n",(0,i.jsx)(n.p,{children:"如果输出的内容较大，还可以将输出重定向到外部文件"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ redis-cli info > info.txt\n$ wc -l info.txt\n\xa0 \xa0 \xa0120 info.txt\n"})}),"\n",(0,i.jsx)(n.p,{children:"上面的命令指向的服务器是默认服务器地址，如果想指向特定的服务器可以这样"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// -n 2 表示使用第2个库，相当于 select 2\n$ redis-cli -h localhost -p 6379 -n 2 ping\nPONG\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"批量执行命令",children:["批量执行命令",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#批量执行命令",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在平时线上的开发过程中，有时候我们免不了要手工造数据，然后导入 Redis。通常我们会编写脚本程序来做这件事。不过还有另外一种比较便捷的方式，那就是直接使用 redis-cli 来批量执行一系列指令。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ cat cmds.txt\nset foo1 bar1\nset foo2 bar2\nset foo3 bar3\n......\n$ cat cmds.txt | redis-cli\nOK\nOK\nOK\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"上面的指令使用了 Unix 管道将 cat 指令的标准输出连接到 redis-cli 的标准输入。其实还可以直接使用输入重定向来批量执行指令。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ redis-cli < cmds.txt\nOK\nOK\nOK\n...\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"set-多行字符串",children:["set 多行字符串",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set-多行字符串",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"如果一个字符串有多行，你希望将它传入 set 指令，redis-cli 要如何做？可以使用 -x 选项，该选项会使用标准输入的内容作为最后一个参数。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'$ cat str.txt\nErnest Hemingway once wrote,\n"The world is a fine place and worth fighting for."\nI agree with the second part.\n$ redis-cli -x set foo < str.txt\nOK\n$ redis-cli get foo\n"Ernest Hemingway once wrote,\\n\\"The world is a fine place and worth fighting for.\\"\\nI agree with the second part.\\n"\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"重复执行指令",children:["重复执行指令",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重复执行指令",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"redis-cli 还支持重复执行指令多次，每条指令执行之间设置一个间隔时间，如此便可以观察某条指令的输出内容随时间变化。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// 间隔1s，执行5次，观察qps的变化\n$ redis-cli -r 5 -i 1 info | grep ops\ninstantaneous_ops_per_sec:43469\ninstantaneous_ops_per_sec:47460\ninstantaneous_ops_per_sec:47699\ninstantaneous_ops_per_sec:46434\ninstantaneous_ops_per_sec:47216\n"})}),"\n",(0,i.jsx)(n.p,{children:"如果将次数设置为 -1 那就是重复无数次永远执行下去。如果不提供 -i 参数，那就没有间隔，连续重复执行。在交互模式下也可以重复执行指令，形式上比较怪异，在指令前面增加次数"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"127.0.0.1:6379> 5 ping\nPONG\nPONG\nPONG\nPONG\nPONG\n# 32拓展 11：短小精悍 —— 命令行工具的妙用\n127.0.0.1:6379> 10000 info\n.......\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"导出-csv",children:["导出 csv",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#导出-csv",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"redis-cli 不能一次导出整个库的内容为 csv，但是可以导出单条指令的输出为 csv 格式。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'$ redis-cli rpush lfoo a b c d e f g\n(integer) 7\n$ redis-cli --csv lrange lfoo 0 -1\n"a","b","c","d","e","f","g"\n$ redis-cli hmset hfoo a 1 b 2 c 3 d 4\nOK\n$ redis-cli --csv hgetall hfoo\n"a","1","b","2","c","3","d","4"\n'})}),"\n",(0,i.jsx)(n.p,{children:"当然这种导出功能比较弱，仅仅是一堆字符串用逗号分割开来。不过你可以结合命令的批量执行来看看多个指令的导出效果。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'$ redis-cli --csv -r 5 hgetall hfoo\n"a","1","b","2","c","3","d","4"\n"a","1","b","2","c","3","d","4"\n"a","1","b","2","c","3","d","4"\n"a","1","b","2","c","3","d","4"\n"a","1","b","2","c","3","d","4"\n'})}),"\n",(0,i.jsx)(n.p,{children:"看到这里读者应该明白 --csv 参数的效果就是对输出做了一次转换，用逗号分割，仅此而已。"}),"\n",(0,i.jsxs)(n.h3,{id:"执行-lua-脚本",children:["执行 lua 脚本",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行-lua-脚本",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在 lua 脚本小节，我们使用 eval 指令来执行脚本字符串，每次都是将脚本内容压缩成单行字符串再调用 eval 指令，这非常繁琐，而且可读性很差。redis-cli 考虑到了这点，它可以直接执行脚本文件。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'127.0.0.1:6379> eval "return redis.pcall(\'mset\', KEYS[1], ARGV[1], KEYS[2], ARGV[2])" 2 foo1 foo2 bar1 bar2\nOK\n127.0.0.1:6379> eval "return redis.pcall(\'mget\', KEYS[1], KEYS[2])" 2 foo1 foo2\n1) "bar1"\n2) "bar2"\n'})}),"\n",(0,i.jsx)(n.p,{children:"下面我们以脚本的形式来执行上面的指令，参数形式有所不同，KEY 和 ARGV 之间需要使用逗号分割，并且不需要提供 KEY 的数量参数"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ cat mset.txt\nreturn redis.pcall('mset', KEYS[1], ARGV[1], KEYS[2], ARGV[2])\n$ cat mget.txt\nreturn redis.pcall('mget', KEYS[1], KEYS[2])\n$ redis-cli --eval mset.txt foo1 foo2 , bar1 bar2\nOK\n$ redis-cli --eval mget.txt foo1 foo2\n1) \"bar1\"\n2) \"bar2\"\n"})}),"\n",(0,i.jsx)(n.p,{children:"如果你的 lua 脚本太长，--eval 将大有用处。"}),"\n",(0,i.jsxs)(n.h3,{id:"监控服务器状态",children:["监控服务器状态",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#监控服务器状态",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"我们可以使用 --stat 参数来实时监控服务器的状态，间隔 1s 实时输出一次。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ redis-cli --stat\n------- data ------ --------------------- load -------------------- - child -\nkeys\xa0 \xa0 \xa0 \xa0mem\xa0 \xa0 \xa0 clients blocked requests\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 connections\n2\xa0 \xa0 \xa0 \xa0 \xa0 6.66M\xa0 \xa0 100\xa0 \xa0 \xa00\xa0 \xa0 \xa0 \xa011591628 (+0)\xa0 \xa0 \xa0 \xa0335\n2\xa0 \xa0 \xa0 \xa0 \xa0 6.66M\xa0 \xa0 100\xa0 \xa0 \xa00\xa0 \xa0 \xa0 \xa011653169 (+61541)\xa0 \xa0335\n2\xa0 \xa0 \xa0 \xa0 \xa0 6.66M\xa0 \xa0 100\xa0 \xa0 \xa00\xa0 \xa0 \xa0 \xa011706550 (+53381)\xa0 \xa0335\n2\xa0 \xa0 \xa0 \xa0 \xa0 6.54M\xa0 \xa0 100\xa0 \xa0 \xa00\xa0 \xa0 \xa0 \xa011758831 (+52281)\xa0 \xa0335\n2\xa0 \xa0 \xa0 \xa0 \xa0 6.66M\xa0 \xa0 100\xa0 \xa0 \xa00\xa0 \xa0 \xa0 \xa011803132 (+44301)\xa0 \xa0335\n2\xa0 \xa0 \xa0 \xa0 \xa0 6.66M\xa0 \xa0 100\xa0 \xa0 \xa00\xa0 \xa0 \xa0 \xa011854183 (+51051)\xa0 \xa0335\n"})}),"\n",(0,i.jsx)(n.p,{children:"如果你觉得间隔太长或是太短，可以使用 -i 参数调整输出间隔。"}),"\n",(0,i.jsxs)(n.h3,{id:"扫描大-key",children:["扫描大 KEY",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扫描大-key",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这个功能太实用了，我已经在线上试过无数次了。每次遇到 Redis 偶然卡顿问题，第一个想到的就是实例中是否存在大 KEY，大 KEY的内存扩容以及释放都会导致主线程卡顿。如果知道里面有没有大 KEY，可以自己写程序扫描，不过这太繁琐了。redis-cli 提供了 --bigkeys 参数可以很快扫出内存里的大 KEY，使用 -i 参数控制扫描间隔，避免扫描指令导致服务器的 ops 陡增报警。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ ./redis-cli --bigkeys -i 0.01\n# Scanning the entire keyspace to find biggest keys as well as\n# average sizes per key type.\xa0 You can use -i 0.1 to sleep 0.1 sec\n# per 100 SCAN commands (not usually needed).\n\n[00.00%] Biggest zset\xa0 \xa0found so far 'hist:aht:main:async_finish:20180425:17' with 1440 members\n[00.00%] Biggest zset\xa0 \xa0found so far 'hist:qps:async:authorize:20170311:27' with 2465 members\n[00.00%] Biggest hash\xa0 \xa0found so far 'job:counters:6ya9ypu6ckcl' with 3 fields\n[00.01%] Biggest string found so far 'rt:aht:main:device_online:68:{-4}' with 4 bytes\n[00.01%] Biggest zset\xa0 \xa0found so far 'machine:load:20180709' with 2879 members\n[00.02%] Biggest string found so far '6y6fze8kj7cy:{-7}' with 90 bytes\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"redis-cli 对于每一种对象类型都会记录长度最大的 KEY，对于每一种对象类型，刷新一次最高记录就会立即输出一次。它能保证输出长度为 Top1 的 KEY，但是 Top2、Top3等 KEY 是无法保证可以扫描出来的。一般的处理方法是多扫描几次，或者是消灭了 Top1 的 KEY 之后再扫描确认还有没有次大的 KEY。"}),"\n",(0,i.jsxs)(n.h3,{id:"采样服务器指令",children:["采样服务器指令",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#采样服务器指令",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"现在线上有一台 Redis 服务器的 OPS 太高，有很多业务模块都在使用这个 Redis，如何才能判断出来是哪个业务导致了 OPS 异常的高。这时可以对线上服务器的指令进行采样，观察采样的指令大致就可以分析出 OPS 占比高的业务点。这时就要使用 monitor 指令，它会将服务器瞬间执行的指令全部显示出来。不过使用的时候要注意即使使用 ctrl+c 中断，否则你的显示器会噼里啪啦太多的指令瞬间让你眼花缭乱。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'$ redis-cli --host 192.168.x.x --port 6379 monitor\n1539853410.458483 [0 10.100.90.62:34365] "GET" "6yax3eb6etq8:{-7}"\n1539853410.459212 [0 10.100.90.61:56659] "PFADD" "growth:dau:20181018" "2klxkimass8w"\n1539853410.462938 [0 10.100.90.62:20681] "GET" "6yax3eb6etq8:{-7}"\n1539853410.467231 [0 10.100.90.61:40277] "PFADD" "growth:dau:20181018" "2kei0to86ps1"\n1539853410.470319 [0 10.100.90.62:34365] "GET" "6yax3eb6etq8:{-7}"\n1539853410.473927 [0 10.100.90.61:58128] "GET" "6yax3eb6etq8:{-7}"\n1539853410.475712 [0 10.100.90.61:40277] "PFADD" "growth:dau:20181018" "2km8sqhlefpc"\n1539853410.477053 [0 10.100.90.62:61292] "GET" "6yax3eb6etq8:{-7}"\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"诊断服务器时延",children:["诊断服务器时延",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#诊断服务器时延",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"平时我们诊断两台机器的时延一般是使用 Unix 的 ping 指令。Redis 也提供了时延诊断指令，不过它的原理不太一样，它是诊断当前机器和 Redis 服务器之间的指令(PING指令)时延，它不仅仅是物理网络的时延，还和当前的 Redis 主线程是否忙碌有关。如果你发现 Unix 的 ping 指令时延很小，而 Redis 的时延很大，那说明 Redis 服务器在执行指令时有微弱卡顿。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ redis-cli --host 192.168.x.x --port 6379 --latency\nmin: 0, max: 5, avg: 0.08 (305 samples)\n"})}),"\n",(0,i.jsx)(n.p,{children:"时延单位是 ms。redis-cli 还能显示时延的分布情况，而且是图形化输出。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ redis-cli --latency-dist\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/10/24/166a3cac25bdb6fb?w=518&h=193&f=png&s=30452",alt:""})}),"\n",(0,i.jsx)(n.p,{children:"这个图形的含义作者没有描述，读者们可以尝试破解一下。"}),"\n",(0,i.jsxs)(n.h3,{id:"远程-rdb-备份",children:["远程 rdb 备份",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#远程-rdb-备份",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"执行下面的命令就可以将远程的 Redis 实例备份到本地机器，远程服务器会执行一次bgsave操作，然后将 rdb 文件传输到客户端。远程 rdb 备份让我们有一种“秀才不出门，全知天下事”的感觉。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ ./redis-cli --host 192.168.x.x --port 6379 --rdb ./user.rdb\nSYNC sent to master, writing 2501265095 bytes to './user.rdb'\nTransfer finished with success.\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"模拟从库",children:["模拟从库",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模拟从库",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"如果你想观察主从服务器之间都同步了那些数据，可以使用 redis-cli 模拟从库。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ ./redis-cli --host 192.168.x.x --port 6379 --slave\nSYNC with master, discarding 51778306 bytes of bulk transfer...\nSYNC done. Logging commands from master.\n...\n"})}),"\n",(0,i.jsx)(n.p,{children:"从库连上主库的第一件事是全量同步，所以看到上面的指令卡顿这很正常，待首次全量同步完成后，就会输出增量的 aof 日志。"})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}let t=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F32%E6%8B%93%E5%B1%95%2011%EF%BC%9A%E7%9F%AD%E5%B0%8F%E7%B2%BE%E6%82%8D%20%E2%80%94%E2%80%94%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%9A%84%E5%A6%99%E7%94%A8.md"]={toc:[{text:"执行单条命令",id:"执行单条命令",depth:3},{text:"批量执行命令",id:"批量执行命令",depth:3},{text:"set 多行字符串",id:"set-多行字符串",depth:3},{text:"重复执行指令",id:"重复执行指令",depth:3},{text:"导出 csv",id:"导出-csv",depth:3},{text:"执行 lua 脚本",id:"执行-lua-脚本",depth:3},{text:"监控服务器状态",id:"监控服务器状态",depth:3},{text:"扫描大 KEY",id:"扫描大-key",depth:3},{text:"采样服务器指令",id:"采样服务器指令",depth:3},{text:"诊断服务器时延",id:"诊断服务器时延",depth:3},{text:"远程 rdb 备份",id:"远程-rdb-备份",depth:3},{text:"模拟从库",id:"模拟从库",depth:3}],title:"",headingTitle:"",frontmatter:{}}}}]);