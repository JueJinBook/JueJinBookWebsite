"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11972"],{150039:function(e,s,n){n.r(s),n.d(s,{default:()=>h});var d=n(552676),r=n(740453);function i(e){let s=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",img:"img",ol:"ol",li:"li",ul:"ul"},(0,r.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(s.h1,{id:"27拓展-6平波缓进--懒惰删除",children:["27拓展 6：平波缓进 —— 懒惰删除",(0,d.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#27拓展-6平波缓进--懒惰删除",children:"#"})]}),"\n",(0,d.jsx)(s.p,{children:"一直以来我们认为 Redis 是单线程的，单线程为 Redis 带来了代码的简洁性和丰富多样的数据结构。不过Redis内部实际上并不是只有一个主线程，它还有几个异步线程专门用来处理一些耗时的操作。"}),"\n",(0,d.jsxs)(s.h2,{id:"redis-为什么要懒惰删除lazy-free",children:["Redis 为什么要懒惰删除(lazy free)？",(0,d.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#redis-为什么要懒惰删除lazy-free",children:"#"})]}),"\n",(0,d.jsxs)(s.p,{children:["删除指令 ",(0,d.jsx)(s.code,{children:"del"})," 会直接释放对象的内存，大部分情况下，这个指令非常快，没有明显延迟。不过如果删除的 key 是一个非常大的对象，比如一个包含了千万元素的 hash，那么删除操作就会导致单线程卡顿。"]}),"\n",(0,d.jsxs)(s.p,{children:["Redis 为了解决这个卡顿问题，在 4.0 版本引入了 ",(0,d.jsx)(s.code,{children:"unlink"})," 指令，它能对删除操作进行懒处理，丢给后台线程来异步回收内存。"]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{children:"> unlink key\nOK\n"})}),"\n",(0,d.jsx)(s.p,{children:"如果有多线程的开发经验，你肯定会担心这里的线程安全问题，会不会出现多个线程同时并发修改数据结构的情况存在。"}),"\n",(0,d.jsxs)(s.p,{children:["关于这点，我打个比方。可以将整个 Redis 内存里面所有有效的数据想象成一棵大树。当 ",(0,d.jsx)(s.code,{children:"unlink"})," 指令发出时，它只是把大树中的一个树枝别断了，然后扔到旁边的火堆里焚烧 (异步线程池)。树枝离开大树的一瞬间，它就再也无法被主线程中的其它指令访问到了，因为主线程只会沿着这颗大树来访问。"]}),"\n",(0,d.jsxs)(s.h2,{id:"flush",children:["flush",(0,d.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#flush",children:"#"})]}),"\n",(0,d.jsxs)(s.p,{children:["Redis 提供了 ",(0,d.jsx)(s.code,{children:"flushdb"})," 和 ",(0,d.jsx)(s.code,{children:"flushall"})," 指令，用来清空数据库，这也是极其缓慢的操作。Redis 4.0 同样给这两个指令也带来了异步化，在指令后面增加 ",(0,d.jsx)(s.code,{children:"async"})," 参数就可以将整棵大树连根拔起，扔给后台线程慢慢焚烧。"]}),"\n",(0,d.jsx)(s.pre,{children:(0,d.jsx)(s.code,{children:"> flushall async\nOK\n"})}),"\n",(0,d.jsxs)(s.h2,{id:"异步队列",children:["异步队列",(0,d.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#异步队列",children:"#"})]}),"\n",(0,d.jsx)(s.p,{children:"主线程将对象的引用从「大树」中摘除后，会将这个 key 的内存回收操作包装成一个任务，塞进异步任务队列，后台线程会从这个异步队列中取任务。任务队列被主线程和异步线程同时操作，所以必须是一个线程安全的队列。"}),"\n",(0,d.jsx)(s.p,{children:(0,d.jsx)(s.img,{src:"https://user-gold-cdn.xitu.io/2018/8/2/164fa17ba5f2d88e?w=771&h=138&f=png&s=18045",alt:""})}),"\n",(0,d.jsxs)(s.p,{children:["不是所有的 ",(0,d.jsx)(s.code,{children:"unlink"})," 操作都会延后处理，如果对应 key 所占用的内存很小，延后处理就没有必要了，这时候 Redis 会将对应的 key 内存立即回收，跟 ",(0,d.jsx)(s.code,{children:"del"})," 指令一样。"]}),"\n",(0,d.jsxs)(s.h2,{id:"aof-sync也很慢",children:["AOF Sync也很慢",(0,d.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#aof-sync也很慢",children:"#"})]}),"\n",(0,d.jsx)(s.p,{children:"Redis需要每秒一次(可配置)同步AOF日志到磁盘，确保消息尽量不丢失，需要调用sync函数，这个操作会比较耗时，会导致主线程的效率下降，所以Redis也将这个操作移到异步线程来完成。执行AOF Sync操作的线程是一个独立的异步线程，和前面的懒惰删除线程不是一个线程，同样它也有一个属于自己的任务队列，队列里只用来存放AOF Sync任务。"}),"\n",(0,d.jsxs)(s.h2,{id:"更多异步删除点",children:["更多异步删除点",(0,d.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#更多异步删除点",children:"#"})]}),"\n",(0,d.jsxs)(s.p,{children:["Redis 回收内存除了 ",(0,d.jsx)(s.code,{children:"del"})," 指令和 ",(0,d.jsx)(s.code,{children:"flush"})," 之外，还会存在于在 key 的过期、LRU 淘汰、rename 指令以及从库全量同步时接受完 rdb 文件后会立即进行的 flush 操作。"]}),"\n",(0,d.jsx)(s.p,{children:"Redis4.0 为这些删除点也带来了异步删除机制，打开这些点需要额外的配置选项。"}),"\n",(0,d.jsxs)(s.ol,{children:["\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.code,{children:"slave-lazy-flush"}),"  从库接受完 rdb 文件后的 flush 操作"]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.code,{children:"lazyfree-lazy-eviction"})," 内存达到 maxmemory 时进行淘汰"]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.code,{children:"lazyfree-lazy-expire key"})," 过期删除"]}),"\n",(0,d.jsxs)(s.li,{children:[(0,d.jsx)(s.code,{children:"lazyfree-lazy-server-del"})," rename 指令删除 destKey"]}),"\n"]}),"\n",(0,d.jsxs)(s.h2,{id:"扩展阅读",children:["扩展阅读",(0,d.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"})]}),"\n",(0,d.jsxs)(s.ul,{children:["\n",(0,d.jsx)(s.li,{children:(0,d.jsx)(s.a,{href:"https://yq.aliyun.com/articles/205504",target:"_blank",rel:"noopener noreferrer",children:"Redis 懒惰处理的细节"})}),"\n"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,r.ah)(),e.components);return s?(0,d.jsx)(s,{...e,children:(0,d.jsx)(i,{...e})}):i(e)}let h=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F27%E6%8B%93%E5%B1%95%206%EF%BC%9A%E5%B9%B3%E6%B3%A2%E7%BC%93%E8%BF%9B%20%E2%80%94%E2%80%94%20%E6%87%92%E6%83%B0%E5%88%A0%E9%99%A4.md"]={toc:[{text:"Redis 为什么要懒惰删除(lazy free)？",id:"redis-为什么要懒惰删除lazy-free",depth:2},{text:"flush",id:"flush",depth:2},{text:"异步队列",id:"异步队列",depth:2},{text:"AOF Sync也很慢",id:"aof-sync也很慢",depth:2},{text:"更多异步删除点",id:"更多异步删除点",depth:2},{text:"扩展阅读",id:"扩展阅读",depth:2}],title:"27拓展 6：平波缓进 —— 懒惰删除",headingTitle:"27拓展 6：平波缓进 —— 懒惰删除",frontmatter:{}}}}]);