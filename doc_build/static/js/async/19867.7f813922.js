"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19867"],{484618:function(e,n,c){c.r(n),c.d(n,{default:()=>o});var l=c(552676),d=c(740453);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",ol:"ol",li:"li",blockquote:"blockquote",h2:"h2",h3:"h3",strong:"strong"},(0,d.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{id:"15编译器编译过程中的优化细节",children:["15.编译器：编译过程中的优化细节",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15编译器编译过程中的优化细节",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"在开启本篇章之前，我们先来思考一个问题，假设有以下模板："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>hello world</p>\n  <p>{{ msg }}</p>\n</template>>\n"})}),"\n",(0,l.jsxs)(n.p,{children:["其中一个 ",(0,l.jsx)(n.code,{children:"p"})," 标签的节点是一个静态的节点，第二个 ",(0,l.jsx)(n.code,{children:"p"})," 标签的节点是一个动态的节点，如果当 ",(0,l.jsx)(n.code,{children:"msg"})," 的值发生了变化，那么理论上肉眼可见最优的更新方案应该是只做第二个动态节点的 ",(0,l.jsx)(n.code,{children:"diff"}),"，而无需进行第一个 ",(0,l.jsx)(n.code,{children:"p"})," 标签节点的 ",(0,l.jsx)(n.code,{children:"diff"}),"。"]}),"\n",(0,l.jsxs)(n.p,{children:["如果熟悉 ",(0,l.jsx)(n.code,{children:"Vue 2.x"})," 的小伙伴可能会知道，在 ",(0,l.jsx)(n.code,{children:"Vue 2.x"})," 版本中在编译过程中有一个叫做 ",(0,l.jsx)(n.code,{children:"optimize"})," 的阶段，会进行标记静态根节点的操作，被标记为静态根节点的节点，一方面会生成一个 ",(0,l.jsx)(n.code,{children:"staticRenderFns"}),"，首次渲染会以这个静态根节点 ",(0,l.jsx)(n.code,{children:"vnode"})," 进行缓存，后续渲染会直接取缓存中的，从而避免重复渲染；另一方面生成的 ",(0,l.jsx)(n.code,{children:"vnode"})," 会带有 ",(0,l.jsx)(n.code,{children:"isStatic = true"})," 的属性，将会在 ",(0,l.jsx)(n.code,{children:"diff"})," 过程中被跳过。但 ",(0,l.jsx)(n.code,{children:"Vue 2.x"})," 对静态节点进行缓存就是一种空间换时间的优化策略，为了避免过度优化，在 ",(0,l.jsx)(n.code,{children:"Vue 2.x"})," 中，识别静态根节点是需要满足："]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"子节点是静态节点；"}),"\n",(0,l.jsx)(n.li,{children:"子节点不是只有一个静态文本节点的节点。"}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["所以，上面的示例第一个 ",(0,l.jsx)(n.code,{children:"p"})," 标签在 ",(0,l.jsx)(n.code,{children:"Vue 2.x"})," 中不会被判定位静态根节点，也就无法进行优化。"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["关于 ",(0,l.jsx)(n.code,{children:"Vue 2.x"})," 如何做的编译时优化，这里只是简单进行了介绍，想了解更多的小伙伴可以参考这里：",(0,l.jsx)(n.a,{href:"https://github.com/muwoo/blogs/blob/master/src/Vue/8.md",target:"_blank",rel:"noopener noreferrer",children:"入口开始，解读 Vue2 源码（七）—— $mount 内部实现 --- compile optimize标记节点"}),"。"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["那么 ",(0,l.jsx)(n.code,{children:"Vue 3"})," 呢？还是和 ",(0,l.jsx)(n.code,{children:"Vue 2"})," 一样吗？答案显然是否定的，首先我们前面介绍了对于静态的节点，",(0,l.jsx)(n.code,{children:"Vue 3"})," 首先会进行静态提升，也就是相当于缓存了静态节点的 ",(0,l.jsx)(n.code,{children:"vnode"}),"，那 ",(0,l.jsx)(n.code,{children:"diff"})," 过程呢？会跳过吗？本小节我们来一探究竟。"]}),"\n",(0,l.jsxs)(n.h2,{id:"patchflags",children:["PatchFlags",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#patchflags",children:"#"})]}),"\n",(0,l.jsxs)(n.h3,{id:"是什么",children:["是什么？",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#是什么",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["首先，我们需要认识一个 ",(0,l.jsx)(n.code,{children:"PatchFlags"})," 这个属性，它是一个枚举类型，里面是一些二进制操作的值，用来标记在节点的 ",(0,l.jsx)(n.code,{children:"patch"})," 类型。具体的枚举内容如下："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"export const enum PatchFlags {\n  // 动态文本的元素\n  TEXT = 1,\n  \n  // 动态 class 的元素\n  CLASS = 1 << 1,\n  \n  // 动态 style 的元素\n  STYLE = 1 << 2,\n  \n  // 动态 props 的元素\n  PROPS = 1 << 3,\n  \n  // 动态 props 和有 key 值绑定的元素\n  FULL_PROPS = 1 << 4,\n  \n  // 有事件绑定的元素\n  HYDRATE_EVENTS = 1 << 5,\n  \n  // children 顺序确定的 fragment\n  STABLE_FRAGMENT = 1 << 6,\n  \n  // children 中有带有 key 的节点的 fragment\n  KEYED_FRAGMENT = 1 << 7,\n  \n  // 没有 key 的 children 的 fragment\n  UNKEYED_FRAGMENT = 1 << 8,\n  \n  // 带有 ref、指令的元素\n  NEED_PATCH = 1 << 9,\n  \n  // 动态的插槽\n  DYNAMIC_SLOTS = 1 << 10,\n  \n  // 静态节点\n  HOISTED = -1,\n  \n  // 不是 render 函数生成的元素，如 renderSlot\n  BAIL = -2,\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["这些二进制的值是通过左移操作符 ",(0,l.jsx)(n.code,{children:"<<"})," 生成的，关于左移操作符，我们在",(0,l.jsx)(n.a,{href:"https://juejin.cn/book/7146465352120008743/section/7147530994017370127",target:"_blank",rel:"noopener noreferrer",children:"《响应式原理：副作用函数探秘》"}),"篇章中已经介绍过了，在这里也是一种二进制操作的体现："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"TEXT = 0000000001; \nCLASS = 0000000010; \nSTYLE = 0000000100;\n"})}),"\n",(0,l.jsxs)(n.p,{children:["这里通过二进制来表示 ",(0,l.jsx)(n.code,{children:"PatchFlags"})," 可以方便我们做很多属性的判断，比如 ",(0,l.jsx)(n.code,{children:"TEXT | STYLE"})," 来得到 ",(0,l.jsx)(n.code,{children:"0000000101"}),"，表示 ",(0,l.jsx)(n.code,{children:"patchFlag"})," 既有 ",(0,l.jsx)(n.code,{children:"TEXT"})," 属性也有 ",(0,l.jsx)(n.code,{children:"STYLE"})," 属性，当需要进行判断有没有 ",(0,l.jsx)(n.code,{children:"STYLE"})," 属性时，只需要 ",(0,l.jsx)(n.code,{children:"FLAG & STYLE > 0"}),"就行。"]}),"\n",(0,l.jsxs)(n.h3,{id:"什么时候生成的",children:["什么时候生成的？",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么时候生成的",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["在搞清楚 ",(0,l.jsx)(n.code,{children:"patchFlags"})," 的一些定义和使用基础后，那它是什么时候被赋值到 ",(0,l.jsx)(n.code,{children:"vnode"})," 节点上的呢？前言中的模板字符串在 ",(0,l.jsx)(n.code,{children:"compiler"})," 阶段会被转成一个 ",(0,l.jsx)(n.code,{children:"render"})," 函数的字符串代码："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, "hello world", -1 /* HOISTED */)\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(_Fragment, null, [\n    _hoisted_1,\n    _createElementVNode("p", null, _toDisplayString(msg), 1 /* TEXT */)\n  ], 64 /* STABLE_FRAGMENT */))\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["这里可以看出，",(0,l.jsx)(n.code,{children:"render"})," 函数内是通过 ",(0,l.jsx)(n.code,{children:"createElementVNode"})," 方法来创建 ",(0,l.jsx)(n.code,{children:"vnode"})," 的，该函数的第四个参数就代表着 ",(0,l.jsx)(n.code,{children:"patchFlag"}),"。对于我们上面的示例，其中 ",(0,l.jsx)(n.code,{children:"<p>hello world</p>"})," 是 ",(0,l.jsx)(n.code,{children:"hoisted"}),"，对应的 ",(0,l.jsx)(n.code,{children:"patchFlag = -1"}),"，",(0,l.jsx)(n.code,{children:"<p>{{ msg }}</p>"})," 是动态文字节点，对应的 ",(0,l.jsx)(n.code,{children:"patchFlag = 1"}),"。"]}),"\n",(0,l.jsxs)(n.h3,{id:"有什么用",children:["有什么用？",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#有什么用",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["接下来看看其实际使用案例，还是拿之前的 ",(0,l.jsx)(n.code,{children:"patchElement"})," 函数来说："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {\n  let { patchFlag, dynamicChildren, dirs } = n2\n  // 如果 patchFlag 不存在，那么就设置成 FULL_PROPS，意味着要全量 props 比对\n  patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS\n  const oldProps = n1.props || EMPTY_OBJ\n  const newProps = n2.props || EMPTY_OBJ\n\n  const areChildrenSVG = isSVG && n2.type !== 'foreignObject'\n  if (dynamicChildren) {\n    patchBlockChildren(\n      n1.dynamicChildren!,\n      dynamicChildren,\n      el,\n      parentComponent,\n      parentSuspense,\n      areChildrenSVG,\n      slotScopeIds\n    )\n  } else if (!optimized) {\n    // full diff\n    patchChildren(\n      n1,\n      n2,\n      el,\n      null,\n      parentComponent,\n      parentSuspense,\n      areChildrenSVG,\n      slotScopeIds,\n      false\n    )\n  }\n\n  if (patchFlag > 0) {\n    if (patchFlag & PatchFlags.FULL_PROPS) {\n      // 如果元素的 props 中含有动态的 key，则需要全量比较\n      patchProps(\n        el,\n        n2,\n        oldProps,\n        newProps,\n        parentComponent,\n        parentSuspense,\n        isSVG\n      )\n    } else {\n      // class\n      if (patchFlag & PatchFlags.CLASS) {\n        if (oldProps.class !== newProps.class) {\n          hostPatchProp(el, 'class', null, newProps.class, isSVG)\n        }\n      }\n      // style\n      if (patchFlag & PatchFlags.STYLE) {\n        hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG)\n      }\n\n      // props\n      if (patchFlag & PatchFlags.PROPS) {\n        const propsToUpdate = n2.dynamicProps!\n        for (let i = 0; i < propsToUpdate.length; i++) {\n          const key = propsToUpdate[i]\n          const prev = oldProps[key]\n          const next = newProps[key]\n          // #1471 force patch value\n          if (next !== prev || key === 'value') {\n            hostPatchProp(\n              el,\n              key,\n              prev,\n              next,\n              isSVG,\n              n1.children as VNode[],\n              parentComponent,\n              parentSuspense,\n              unmountChildren\n            )\n          }\n        }\n      }\n    }\n\n    // text\n    if (patchFlag & PatchFlags.TEXT) {\n      if (n1.children !== n2.children) {\n        hostSetElementText(el, n2.children as string)\n      }\n    }\n  } else if (!optimized && dynamicChildren == null) {\n    patchProps(\n      el,\n      n2,\n      oldProps,\n      newProps,\n      parentComponent,\n      parentSuspense,\n      isSVG\n    )\n  }\n  \n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["这里涉及到两个比较重点的事儿，一个是和 ",(0,l.jsx)(n.code,{children:"dynamicChildren"})," 相关，另一个是和动态 ",(0,l.jsx)(n.code,{children:"props"})," 相关。我们先看和动态 ",(0,l.jsx)(n.code,{children:"props"})," 相关的内容。"]}),"\n",(0,l.jsxs)(n.p,{children:["之前的章节我们跳过了对 ",(0,l.jsx)(n.code,{children:"PatchFlags"})," 内容的理解，到了这里，我们通过代码可以知道 ",(0,l.jsx)(n.code,{children:"Vue"})," 在更新子节点时，首先也是利用 ",(0,l.jsx)(n.code,{children:"patchFlag"})," 的能力，对子节点进行分类做出不同的处理，比如针对以下例子："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-html",children:"<template>\n  <div :class=\"classNames\" id='test'>\n    hello world\n  </div> \n</template>\n"})}),"\n",(0,l.jsx)(n.p,{children:"得到的编译结果："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:'import { normalizeClass as _normalizeClass, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock("div", {\n    class: _normalizeClass(classNames),\n    id: "test"\n  }, " hello world ", 2 /* CLASS */))\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["此时 ",(0,l.jsx)(n.code,{children:"patchFlag & PatchFlags.CLASS > 0"})," 则在 ",(0,l.jsx)(n.code,{children:"diff"})," 过程中，需要进行 ",(0,l.jsx)(n.code,{children:"class"})," 属性的 ",(0,l.jsx)(n.code,{children:"diff"}),"， 从而减少了对 ",(0,l.jsx)(n.code,{children:"id"})," 属性的不必要 ",(0,l.jsx)(n.code,{children:"diff"}),"，提升了 ",(0,l.jsx)(n.code,{children:"props diff"})," 过程中的性能。"]}),"\n",(0,l.jsxs)(n.h2,{id:"dynamicchildren",children:["dynamicChildren",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dynamicchildren",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["另外，我们注意到，在编译后的 ",(0,l.jsx)(n.code,{children:"render"})," 函数中会有一个 ",(0,l.jsx)(n.code,{children:"_openBlock()"})," 函数的执行，我们来一起看一下其实现："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"export const blockStack = []\nexport let currentBlock = null\n\nexport function openBlock(disableTracking = false) {\n  blockStack.push((currentBlock = disableTracking ? null : []))\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"openBlock"})," 实现比较通俗易懂，就是向 ",(0,l.jsx)(n.code,{children:"blockStack"})," 中 ",(0,l.jsx)(n.code,{children:"push"})," ",(0,l.jsx)(n.code,{children:"currentBlock"}),"。其中 ",(0,l.jsx)(n.code,{children:"currentBlock"})," 是一个数组，用于存储动态节点。",(0,l.jsx)(n.code,{children:"blockStack"})," 则是存储 ",(0,l.jsx)(n.code,{children:"currentBlock"})," 的一个 ",(0,l.jsx)(n.code,{children:"Block tree"}),"。"]}),"\n",(0,l.jsxs)(n.p,{children:["然后我们接着看 ",(0,l.jsx)(n.code,{children:"createElementBlock"})," 的实现："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"export function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(\n    createBaseVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      shapeFlag,\n      true /* isBlock */\n    )\n  )\n}\n\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : ShapeFlags.ELEMENT, isBlockNode = false, needFullChildrenNormalization = false) {\n  // ...\n  // 添加动态 vnode 节点到 currentBlock 中\n  if (\n    isBlockTreeEnabled > 0 &&\n    !isBlockNode &&\n    currentBlock &&\n    (vnode.patchFlag > 0 || shapeFlag & ShapeFlags.COMPONENT) &&\n    vnode.patchFlag !== PatchFlags.HYDRATE_EVENTS\n  ) {\n    currentBlock.push(vnode)\n  }\n  \n  return vnode\n}\n\n\nfunction setupBlock(vnode) {\n  // 在 vnode 上保留当前 Block 收集的动态子节点\n  vnode.dynamicChildren =\n    isBlockTreeEnabled > 0 ? currentBlock || (EMPTY_ARR) : null\n  // 当前 Block 恢复到父 Block\n  closeBlock()\n  // 节点本身作为父 Block 收集的子节点\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode)\n  }\n  return vnode\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"createElementBlock"})," 内部首先通过 ",(0,l.jsx)(n.code,{children:"createBaseVNode"})," 创建 ",(0,l.jsx)(n.code,{children:"vnode"})," 节点，在创建的过程中，会根据 ",(0,l.jsx)(n.code,{children:"patchFlag"})," 的值进行判断是否是动态节点，如果发现 ",(0,l.jsx)(n.code,{children:"vnode"})," 是一个动态节点，那么会被添加到 ",(0,l.jsx)(n.code,{children:"currentBlock"})," 当中，然后在执行 ",(0,l.jsx)(n.code,{children:"setupBlock"})," 函数的时候，将 ",(0,l.jsx)(n.code,{children:"currentBlock"})," 赋值给 ",(0,l.jsx)(n.code,{children:"vnode.dynamicChildren"})," 属性。"]}),"\n",(0,l.jsxs)(n.p,{children:["我们前面看 ",(0,l.jsx)(n.code,{children:"patchElement"})," 的时候，有注意到函数体内部会进行是否有 ",(0,l.jsx)(n.code,{children:"dynamicChildren"})," 属性进行不同的逻辑执行，前面的章节，我们只介绍了 ",(0,l.jsx)(n.code,{children:"patchChildren"})," 完整的子节点 ",(0,l.jsx)(n.code,{children:"diff"})," 算法，当 ",(0,l.jsx)(n.code,{children:"dynamicChildren"})," 存在时，这里只会进行 ",(0,l.jsx)(n.code,{children:"patchBlockChildren"})," 的动态节点 ",(0,l.jsx)(n.code,{children:"diff"}),"："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG) => {\n  for (let i = 0; i < newChildren.length; i++) {\n    const oldVNode = oldChildren[i]\n    const newVNode = newChildren[i]\n    // 确定待更新节点的容器\n    const container =\n      // 对于 Fragment，我们需要提供正确的父容器\n      oldVNode.type === Fragment ||\n      // 在不同节点的情况下，将有一个替换节点，我们也需要正确的父容器\n      !isSameVNodeType(oldVNode, newVNode) ||\n      // 组件的情况，我们也需要提供一个父容器\n      oldVNode.shapeFlag & 6 /* COMPONENT */\n        ? hostParentNode(oldVNode.el)\n        :\n        // 在其他情况下，父容器实际上并没有被使用，所以这里只传递 Block 元素即可\n        fallbackContainer\n    patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, true)\n  }\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"patchBlockChildren"})," 的实现很简单，遍历新的动态子节点数组，拿到对应的新旧动态子节点，并执行 ",(0,l.jsx)(n.code,{children:"patch"})," 更新子节点即可。"]}),"\n",(0,l.jsxs)(n.p,{children:["这样一来，更新的复杂度就变成和动态节点的数量正相关，而不与模板大小正相关。这也是 ",(0,l.jsx)(n.code,{children:"Vue 3"})," 做的一个重要的编译时优化的一部分。"]}),"\n",(0,l.jsxs)(n.h2,{id:"总结",children:["总结",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"有了上面的一些介绍，我们还是回到前言的例子中："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"<template>\n  <p>hello world</p>\n  <p>{{ msg }}</p>\n</template>\n"})}),"\n",(0,l.jsxs)(n.p,{children:["转成 ",(0,l.jsx)(n.code,{children:"vnode"})," 后的结果大致为："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-js",children:"const vnode = {\n  type: Symbol(Fragment),\n  children: [\n    { type: 'p', children: 'hello world' },\n    { type: 'p', children: ctx.msg, patchFlag: 1 /* 动态的 text */ },\n  ],\n  dynamicChildren: [\n    { type: 'p', children: ctx.msg, patchFlag: 1 /* 动态的 text */ },\n  ]\n}\n"})}),"\n",(0,l.jsxs)(n.p,{children:["此时组件内存在了一个静态的节点 ",(0,l.jsx)(n.code,{children:"<p>hello world</p>"}),"，在传统的 ",(0,l.jsx)(n.code,{children:"diff"})," 算法里，还是需要对该静态节点进行不必要的 ",(0,l.jsx)(n.code,{children:"diff"}),"。所以 ",(0,l.jsx)(n.code,{children:"Vue3"})," 先通过 ",(0,l.jsx)(n.code,{children:"patchFlag"})," 来标记动态节点 ",(0,l.jsx)(n.code,{children:"<p>{{ msg }}</p>"}),"， 然后配合 ",(0,l.jsx)(n.code,{children:"dynamicChildren"})," 将动态节点进行收集，从而完成在 ",(0,l.jsx)(n.code,{children:"diff"})," 阶段只做",(0,l.jsx)(n.strong,{children:"靶向更新"}),"的目的。"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(r,{...e})}):r(e)}let o=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F15.%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9A%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96%E7%BB%86%E8%8A%82.md"]={toc:[{text:"PatchFlags",id:"patchflags",depth:2},{text:"是什么？",id:"是什么",depth:3},{text:"什么时候生成的？",id:"什么时候生成的",depth:3},{text:"有什么用？",id:"有什么用",depth:3},{text:"dynamicChildren",id:"dynamicchildren",depth:2},{text:"总结",id:"总结",depth:2}],title:"15.编译器：编译过程中的优化细节",headingTitle:"15.编译器：编译过程中的优化细节",frontmatter:{}}}}]);