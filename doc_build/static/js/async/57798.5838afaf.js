"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57798"],{924972:function(e,n,s){s.r(n),s.d(n,{default:()=>o});var c=s(552676),r=s(740453);let d=s.p+"static/image/274fd0e2e3bc1aedf23c0ccb23b9c224.227f1fd0.webp";function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",img:"img",ol:"ol",li:"li",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"10-基础篇最常见的对象操作方法",children:["10 基础篇｜最常见的对象操作方法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-基础篇最常见的对象操作方法",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"前面我们已经了解了对象和属性的基本结构，以及原型链/继承的原理。"}),"\n",(0,c.jsx)(n.p,{children:"基于这些基础知识，本章节我们来学习对象的各种常见操作，涉及对类型判断、对象锁定、对象合并、对象比较等等，是日常非常常用的。"}),"\n",(0,c.jsxs)(n.h2,{id:"类型判断",children:["类型判断",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型判断",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们判断一个对象 o 是否是类 C 的实例，通常会用到 ",(0,c.jsx)(n.code,{children:"instanceof"})," 运算符："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"o instanceof C\n"})}),"\n",(0,c.jsxs)(n.p,{children:["它具体是怎么工作的呢？随着 ECMAScript 的版本迭代，",(0,c.jsx)(n.code,{children:"instanceof"})," 的逻辑也在逐渐趋于复杂，不过总体上来看还是分成了 ",(0,c.jsx)(n.code,{children:"Symbol.hasInstance"})," 和",(0,c.jsx)(n.code,{children:"原型链"}),"两个分支。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Symbol.hasInstance"})," 是一个预定义的 Symbol 常量，我们之前提到过，但是没有讲它是怎么使用的。今天才轮到它上场。"]}),"\n",(0,c.jsxs)(n.p,{children:["第一步，判断 C 是否有 ",(0,c.jsx)(n.code,{children:"[Symbol.hasInstance]"})," 这个函数，注意，它应该定义在构造函数本身上，而不是实例上："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class MyString {\n    static [Symbol.hasInstance](instance) {\n      return 'string' === typeof instance;\n    }\n  }\n  \nconsole.log('abc' instanceof MyString); // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["如果存在这个函数，那么调用它，传入 ",(0,c.jsx)(n.code,{children:"instanceof"})," 左边的值。像上面那样，我们声明了一个自定义类型，在 ",(0,c.jsx)(n.code,{children:"instanceof"})," 下成功利用 ",(0,c.jsx)(n.code,{children:"Symbol.hasInstance"})," 把字符串伪装成了其实例。"]}),"\n",(0,c.jsx)(n.p,{children:"有同学可能认为这样做也太草率了，岂不是很容易实现类型攻击。我之前也这样想，但是在充分掌握了类型结构的知识后，大家不觉得，在 JavaScript 中，对象和构造函数之间的关系不是本来就很脆弱么？"}),"\n",(0,c.jsxs)(n.p,{children:["如果不认同，我们继续往下看在引入 ",(0,c.jsx)(n.code,{children:"Symbol"})," 之前的 ",(0,c.jsx)(n.code,{children:"instanceof"})," 工作方式。"]}),"\n",(0,c.jsxs)(n.p,{children:["第二步，先来判断 C 是不是一个 ",(0,c.jsx)(n.code,{children:"bind"})," 之后的函数，像这样 ",(0,c.jsx)(n.code,{children:"C = Foo.bind(ko)"}),"。这一步怎么实现的呢？我们前面提到过，一个函数在经过 ",(0,c.jsx)(n.code,{children:"bind"})," 后，它的 ",(0,c.jsx)(n.code,{children:"name"})," 属性会有 ",(0,c.jsx)(n.code,{children:"bound"})," 字样："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'function Foo() {}\n\nconst C = Foo.bind("this", 1, 2, 3);\nC.name // "bound Foo"\n'})}),"\n",(0,c.jsxs)(n.p,{children:["但是却无法获取原始函数。对于规范来说却并非难事。",(0,c.jsx)(n.code,{children:"bind"})," 后的函数会把原始函数记录在 ",(0,c.jsx)(n.code,{children:"[[BoundTargetFunction]]"})," 内部属性中，也有其他属性，其结构大概是这样："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'// C 的额外内部属性\n{\n    [[BoundTargetFunction]]: Foo,\n    [[BoundThis]]: "this",\n    [[BoundArguments]]: [1, 2, 3]\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["拿到原始函数 F 后，问题就转化为 ",(0,c.jsx)(n.code,{children:"o instanceof F"})," 了，接下来就是",(0,c.jsx)(n.code,{children:"原型链"}),"的舞场了，一句话概括就是，",(0,c.jsx)(n.code,{children:"顺着 o 的原型链查找，如果能找到 F.prototype，就返回 true，否则 false"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,c.jsx)(n.p,{children:"用一行伪代码表示就是："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"o.__proto__.__proto__.__proto__... === F.prototype\n"})}),"\n",(0,c.jsxs)(n.p,{children:["甚至我们真的可以写出能运行的 ",(0,c.jsx)(n.code,{children:"instanceof"})," 实现："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function myInstanceof(o, C) {\n    const current  = o;\n    while(current)\n        const proto = Object.getPrototypeOf(current);\n        if (proto && proto === C.prototype) {\n            return true;\n        }\n        current = proto;\n    }\n    return false;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"其实就是一个递归的过程，逻辑并不复杂。不过需要注意一些边界条件："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:'C 如果不是对象，会抛出异常，这里的对象指的是非 Primitive 类型，像 null、undefined、true、5、"abc"、Symbol("x") 都不允许；'}),"\n",(0,c.jsxs)(n.li,{children:["除非命中 ",(0,c.jsx)(n.code,{children:"[Symbol.hasInstance]"})," 逻辑，否则 C 还必须是一个函数；"]}),"\n",(0,c.jsxs)(n.li,{children:["如果 o 不是对象，返回 false，这里的对象也指的是非 Primitive 类型，比如 ",(0,c.jsx)(n.code,{children:'"string" instanceof String === false'}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:["如果 C 没有对象类型的 ",(0,c.jsx)(n.code,{children:"prototype"}),"，抛出异常。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"根据以上规则，下列 instanceof 表达式都会抛出异常："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"({}) instanceof null\n({}) instanceof undefined\n({}) instanceof true\n({}) instanceof 5\n({}) instanceof \"abc\"\n({}) instanceof Symbol()\n({}) instanceof {}\n({}) instanceof Object.create(null)\n\nfunction Foo (){}\n  \nObject.defineProperty(Foo, 'prototype', {\n    value: 6, // 非对象格式\n})\n\n({}) instanceof Foo\n"})}),"\n",(0,c.jsxs)(n.p,{children:["以上就是 ",(0,c.jsx)(n.code,{children:"instanceof"})," 的全部工作原理。大家有没有发现什么呢？因为原型链本身就是易被操控的，因此 ",(0,c.jsx)(n.code,{children:"instanceof"})," 的结果严格来讲也不能客观反映对象 o 和构造函数 C 之间的关系。即便不使用 ",(0,c.jsx)(n.code,{children:"Symbol.hasInstance"})," 这种后门，我们也可以通过简单的操作，让 o 看上去是 C 的实例："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var o = {};\nfunction Foo() {}\n\nObject.setPrototypeOf(o, Foo.prototype);\n\no instanceof Foo // true\n"})}),"\n",(0,c.jsxs)(n.p,{children:["因此，",(0,c.jsx)(n.code,{children:"instanceof"})," 代表的只是一种判定规则，并不能真的就代表对象 o 就是 C 的实例。而关于这句",(0,c.jsx)(n.code,{children:"对象 o 是 C 的实例"}),"本身，其实也是一种伪命题，没有触及问题的本质，我们将在后面的章节中深入讲解。"]}),"\n",(0,c.jsxs)(n.h2,{id:"对象的结构锁定",children:["对象的结构锁定",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象的结构锁定",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在上一章节的属性结构学习中，我们了解到使用 ",(0,c.jsx)(n.code,{children:"configurable"})," 配合 ",(0,c.jsx)(n.code,{children:"writable"})," 可以在一定程度上锁定对象的结构。但是操作麻烦，并且也有一定的漏洞，比如不能阻止新增属性。"]}),"\n",(0,c.jsxs)(n.p,{children:["因此，ECMAScript 还提供了另外三个静态函数，",(0,c.jsx)(n.code,{children:"Object.preventExtensions()"}),"、",(0,c.jsx)(n.code,{children:"Object.seal()"}),"、",(0,c.jsx)(n.code,{children:"Object.freeze()"}),"，用于提供不同级别的对象锁定能力。"]}),"\n",(0,c.jsxs)(n.h3,{id:"阻止对象扩展",children:["阻止对象扩展",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#阻止对象扩展",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Object.preventExtensions()"})," 用于禁止给对象新增属性。它的本质是在调用对象内部的 ",(0,c.jsx)(n.code,{children:"[[PreventExtensions]]"})," 函数，这个我们讲过。因此，具体效果是由对象自身来决定的。"]}),"\n",(0,c.jsxs)(n.p,{children:["JavaScript 普通对象的 ",(0,c.jsx)(n.code,{children:"[[PreventExtensions]]"})," 逻辑，仅仅是讲对象内部的 ",(0,c.jsx)(n.code,{children:"[[Extensible]]"})," 标志位设成 true。"]}),"\n",(0,c.jsxs)(n.p,{children:["这个属性我们之前没有涉及过，但是提到过 ",(0,c.jsx)(n.code,{children:"[[IsExtensible]]"})," 函数，这个函数返回的就是 ",(0,c.jsx)(n.code,{children:"[[Extensible]]"})," 的值。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"[[Extensible]]"})," 影响到多种操作的结构，以下这些行为都是不允许的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var o = {};\n\nObject.preventExtensions(o);\n\n// 不允许设置原型\nObject.setPrototypeOf(o, null);\n\n// 不允许定义新属性\nObject.defineProperty(o, 'foo', {\n    value: 2\n});\n\n// 不允许创建新属性\no.bar = 3\n"})}),"\n",(0,c.jsxs)(n.p,{children:["是不是这样就不能让对象访问到新的属性了呢？并不是，我们有原型啊，原型对象如果没有被 ",(0,c.jsx)(n.code,{children:"preventExtensions"})," 的话，可以在原型对象上新增属性，也算是个投机的办法。"]}),"\n",(0,c.jsxs)(n.p,{children:["判断一个对象是否可扩展，可以使用 ",(0,c.jsx)(n.code,{children:"Object.isExtensible(o)"})," 静态函数。"]}),"\n",(0,c.jsxs)(n.h3,{id:"密封对象",children:["密封对象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#密封对象",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Object.seal()"})," 用来密封对象。什么是密封呢？就是不可扩展的升级版，除了不能新增属性之外，所有现有属性都需要变成不可配置的。"]}),"\n",(0,c.jsxs)(n.p,{children:["所以，",(0,c.jsx)(n.code,{children:"Object.seal()"})," 的执行原理可以分成两步："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["执行 ",(0,c.jsx)(n.code,{children:"preventExtensions"}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:["遍历所有属性，修改 ",(0,c.jsx)(n.code,{children:"configurable"})," 为 false。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["判断一个对象是否被密封，可以使用 ",(0,c.jsx)(n.code,{children:"Object.isSealed(o)"})," 静态函数。"]}),"\n",(0,c.jsxs)(n.h3,{id:"冻结对象",children:["冻结对象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#冻结对象",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Object.freeze()"})," 用来冻结对象。冻结又密封的升级版，除了不能新增属性、现有属性都需要变成不可配置之外，对于数据属性，",(0,c.jsx)(n.code,{children:"writable"})," 还需要变成 false。"]}),"\n",(0,c.jsxs)(n.p,{children:["判断一个对象是否被密封，可以使用 ",(0,c.jsx)(n.code,{children:"Object.isFrozen(o)"})," 静态函数。"]}),"\n",(0,c.jsx)(n.p,{children:"所以，我们总结一下这三种对象锁定操作，层级逐渐加深，限制逐渐增多，可以用下面这张表格来形容："}),"\n",(0,c.jsxs)(n.table,{children:["\n",(0,c.jsxs)(n.thead,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.th,{children:"操作"}),"\n",(0,c.jsx)(n.th,{children:"状态判断"}),"\n",(0,c.jsx)(n.th,{children:"可新增属性"}),"\n",(0,c.jsx)(n.th,{children:"现有属性可配置"}),"\n",(0,c.jsx)(n.th,{children:"数据属性可写"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.tbody,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"preventExtensions"}),"\n",(0,c.jsx)(n.td,{children:"isExtensible()"}),"\n",(0,c.jsx)(n.td,{children:"❌"}),"\n",(0,c.jsx)(n.td,{children:"✅"}),"\n",(0,c.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"seal"}),"\n",(0,c.jsx)(n.td,{children:"isSealed()"}),"\n",(0,c.jsx)(n.td,{children:"❌"}),"\n",(0,c.jsx)(n.td,{children:"❌"}),"\n",(0,c.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"freeze"}),"\n",(0,c.jsx)(n.td,{children:"isFrozen()"}),"\n",(0,c.jsx)(n.td,{children:"❌"}),"\n",(0,c.jsx)(n.td,{children:"❌"}),"\n",(0,c.jsx)(n.td,{children:"❌"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["\uD83D\uDCA1 大家需要注意一个事实，即便最严格的 ",(0,c.jsx)(n.code,{children:"freeze"})," 操作，在面对存取器属性时，也无法让属性变成“只读”。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["对象的 ",(0,c.jsx)(n.code,{children:"isExtensible"}),"、",(0,c.jsx)(n.code,{children:"isSealed"}),"、",(0,c.jsx)(n.code,{children:"isFrozen"})," 状态会让我们的对象操作变得更不安全。但归根到底，",(0,c.jsx)(n.code,{children:"isSealed"})," 和 ",(0,c.jsx)(n.code,{children:"isFrozen"})," 对于存量属性的影响仍然只是",(0,c.jsx)(n.code,{children:"属性描述符"}),"层面的，并无其他参量需要考量。对于新属性，除了属性描述符（一定是 undefined）之外，还必须额外关注 ",(0,c.jsx)(n.code,{children:"isExtensible"})," 的状态，增加了判断的成本。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"isExtensible"}),"、",(0,c.jsx)(n.code,{children:"isSealed"}),"、",(0,c.jsx)(n.code,{children:"isFrozen"})," 依次是子集-超集的关系，也就是说，当你调用 ",(0,c.jsx)(n.code,{children:"freeze"})," 后，",(0,c.jsx)(n.code,{children:"isExtensible"})," 一定返回 false，",(0,c.jsx)(n.code,{children:"isSealed"})," 一定返回 true；当你只调用 seal 后，",(0,c.jsx)(n.code,{children:"isExtensible"})," 也会是 false。"]}),"\n",(0,c.jsxs)(n.p,{children:["从原理上来看，",(0,c.jsx)(n.code,{children:"isExtensible"})," 由于只是获取对象的一个内部属性，成本很小，但是对于 ",(0,c.jsx)(n.code,{children:"isSealed"})," 和 ",(0,c.jsx)(n.code,{children:"isFrozen"})," 来说，需要遍历所有属性的描述符，判断参数，成本可能会比较高，大家注意这一点。"]}),"\n",(0,c.jsxs)(n.h2,{id:"对象合并",children:["对象合并",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#对象合并",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"对象是属性的集合，那么就一定存在集合的合并操作。我把这一部分放在对象锁定之后，是因为锁定会明显影响到合并能否成功。"}),"\n",(0,c.jsxs)(n.p,{children:["严格来讲，从熟悉完了对象的属性结构之后，我们完全可以自行实现任意规则的对象合并。但一般来讲，用现成的 API 和语法就能满足绝大部分需求。我们这节来聊一聊 ",(0,c.jsx)(n.code,{children:"Object.assign()"})," 和 ",(0,c.jsx)(n.code,{children:"Object Spread（对象展开）"})," 这两种方式。"]}),"\n",(0,c.jsx)(n.p,{children:"我相信很大部分同学会把这两种做通用处理，使用哪一种，很多时候取决于个人习惯。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"class System {\n    #options = {};\n    constructor(options) {\n        // this.#options = Object.assign(this.#options, options);\n        this.#options = {\n            ...this.#options,\n            ...options,\n        }\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["然而事实上，它们的原理完全不同，在某些情况下，也会产生不一样的结果。一句话描述就是：",(0,c.jsx)(n.code,{children:"Object.assign 以 set 的方式赋值属性，而 Object Spread 以 defineProperty 的方式定义属性"}),"。可能用代码模拟更能说明问题："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function assign(dest, src) {\n    for (let key in src) {\n        // 跳过非自身属性\n        if (!src.hasOwnProperty(key)) continue;\n        // set\n        dest[key] = src[key];\n    }\n}\n\nfunction spread(dest, src) {\n    for (let key in src) {\n        // 跳过非自身属性\n        if (!src.hasOwnProperty(key)) continue;\n        // defineProperty\n        Object.defineProperty(dest, key, {\n            value: src[key],\n            writable: true,\n            enumerable: true,\n            configurable: true,\n        })\n    }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这里的 ",(0,c.jsx)(n.code,{children:"set"}),"，并非指一定要调用属性的 set 方法，毕竟属性也不都是存取器属性。这里指的是",(0,c.jsx)(n.code,{children:"赋值"}),"操作，在 ECMAScript 规范中叫做 ",(0,c.jsx)(n.code,{children:"PutValue"}),"，在语法上有 ",(0,c.jsx)(n.code,{children:"foo.bar"})," 和 ",(0,c.jsx)(n.code,{children:'foo["bar"]'})," 两种。看上去非常普通的操作，其实也不见得所有同学都掌握了细节。"]}),"\n",(0,c.jsxs)(n.p,{children:["注意，虽然读取 bar 会遍历 foo 的原型链，但是如果是",(0,c.jsx)(n.code,{children:"赋值"}),"的话，并不一定会修改 foo 的原型对象的属性值，要看原型对象上的属性类型。如果是存取器类型，那么确实会调用其 set；如果是数据，那么则会折返到 foo 对象上创建新属性。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"Object.assign()"})," 将源对象的可枚举属性都取出来，直接赋值给目标对象；",(0,c.jsx)(n.code,{children:"Object Spread"})," 语法也是将源对象的可枚举属性都取出来，不过是在目标对象上定义一个数据属性。"]}),"\n",(0,c.jsx)(n.p,{children:"这里面体现出了几个细节，需要特别说明："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Object.assign()"})," 可能会将数据赋值到目标对象的原型上，如果原型上有这个 key 的",(0,c.jsx)(n.code,{children:"存取器属性"}),"的话；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"Object Spread"})," 抛弃了源对象属性的描述符，无论它是数据属性还是存取器属性，无论是可配置的还是不可配置的，也无论是可枚举的还是不可枚举的，",(0,c.jsx)(n.code,{children:"最终都转换为目标对象上的一个可枚举、可配置、可写的数据属性"}),"。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"我们写几个例子验证一下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var _name = null;\n\nvar dest = Object.create({\n    set name(n){\n        _name = n;\n    },\n    get name(){\n        return _name;\n    },\n\n});\n\nObject.assign(dest, {\n    name: 'bar'\n});\nconsole.log(dest.name); // \"bar\"\n// Object.assign 赋值到了对象的原型上而非对象本身\nconsole.log(Object.getOwnPropertyDescriptor(dest, 'name')); // undefined\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var source = Object.create(null, {\n    name: {\n        get() {\n            return 'foo';\n        },\n        set(){},\n        enumerable: true,\n        configurable: false,\n    },\n});\n\nconst dest = { ...source };\n// Object Spread 在目标对象上定义可配置的数据属性\nconsole.log(Object.getOwnPropertyDescriptor(dest, 'name')); // { value: 'foo', writable: true, enumerable: true, configurable: true }\n"})}),"\n",(0,c.jsx)(n.p,{children:"既然我们了解到了这两种写法的原理，那么就能在适当的时机判断该使用哪一种，一般来说，只操作简单的对象的话，没什么差异。如果你的合并对象目标是未知来源，你需要知道可能引起报错的场景："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"如果目标对象现存属性是只读的，Object 可能会失败；"}),"\n",(0,c.jsx)(n.li,{children:"如果目标对象现存属性是不可配置的，或者对象不可扩展，那么 Object Spread 可能会失败。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这两种方法都是操作批量属性的，如果其中某一属性合并失败，那么之前已经合并的属性会保留，不会回滚，因此，",(0,c.jsx)(n.code,{children:"合并失败是可能产生未知的对象污染的"}),"。举一个例子："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"var dest = Object.create(null, {\n    a: {\n        value: 'a',\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n    b: {\n        value: 'b',\n        // 合并b会报错\n        writable: false,\n        enumerable: true,\n        configurable: true,\n    }\n});\n\ntry {\n    Object.assign(dest, {\n        a: 'aa',\n        b: 'bb'\n    });\n} catch {}\n\nconsole.log(dest.a, dest.b); // aa b\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这一章我们着重讨论了 ",(0,c.jsx)(n.code,{children:"instanceof"})," 的原理、不同对象锁定级别的方法和两种对象合并方法。"]}),"\n",(0,c.jsxs)(n.p,{children:["从本质上来讲，",(0,c.jsx)(n.code,{children:"各种对象操作只不过是针对属性和原型链的元操作的封装"}),"。只要掌握了属性和原型这两个概念，就可以应对各种需求。比如，",(0,c.jsx)(n.code,{children:"instanceof"})," 就是原型链查找算法；对象锁定是对内部属性 ",(0,c.jsx)(n.code,{children:"[[Extensible]]"})," 和自定义属性描述符的状态追踪；而对象合并也不过是不同的属性的复制而已。"]}),"\n",(0,c.jsxs)(n.p,{children:["然而我们日常使用时不可能每次都从最基础的",(0,c.jsx)(n.code,{children:"元操作"}),"开始，那样太过于低效和繁琐，因此才有这样或那样的封装实现。仍然需要我们记住常用操作的原理和特例。"]}),"\n",(0,c.jsx)(n.p,{children:"给大家留一个小作业，写一个拷贝指定属性的函数，要求前后属性的各种特征完全一致："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function copyProperties(obj, properties) {}\n\ncopyProperties({ a: 1, b: 2, c: 3 }, ['a', 'c']);\n"})}),"\n",(0,c.jsx)(n.p,{children:"下一讲，我们将主攻对象的遍历操作，但它仍然主要由基本的属性、原型操作所组成。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(i,{...e})}):i(e)}let o=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F10%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95.md"]={toc:[{text:"类型判断",id:"类型判断",depth:2},{text:"对象的结构锁定",id:"对象的结构锁定",depth:2},{text:"阻止对象扩展",id:"阻止对象扩展",depth:3},{text:"密封对象",id:"密封对象",depth:3},{text:"冻结对象",id:"冻结对象",depth:3},{text:"对象合并",id:"对象合并",depth:2},{text:"小结",id:"小结",depth:2}],title:"10 基础篇｜最常见的对象操作方法",headingTitle:"10 基础篇｜最常见的对象操作方法",frontmatter:{}}}}]);