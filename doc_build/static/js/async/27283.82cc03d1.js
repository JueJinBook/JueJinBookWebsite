"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["27283"],{881761:function(e,n,r){r.r(n),r.d(n,{default:()=>t});var o=r(552676),s=r(740453);let d=r.p+"static/image/3-2.8859f9b8.png",i=r.p+"static/image/3-1.1810d16e.png";function l(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",pre:"pre",code:"code",p:"p",img:"img",h2:"h2",ul:"ul",li:"li",ol:"ol"},(0,s.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h3,{id:"",children:(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,o.jsxs)(n.h1,{id:"3案例二-视频时长统计-node-的模块机制commonjs与包管理",children:["3案例二： [视频时长统计] Node 的模块机制（CommonJS）与包管理",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3案例二-视频时长统计-node-的模块机制commonjs与包管理",children:"#"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-!",children:"本节目标：【实现一个视频时长统计工具】，你包我包他的包，依赖加载怎么搞，模块关系的组织与加载是 Node 中 JS 动态语言处理的一大利器。\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:i,alt:"image.png | left | 826x336"})}),"\n",(0,o.jsx)(n.p,{children:"Node 世界，一切（独立 JS 文件）皆模块，模块之间互相隔离互不影响，通过引用来互相调用。"}),"\n",(0,o.jsx)(n.p,{children:"一个模块本质是一个模块对象，通过 module.exports（exports 只是 module.exports 的一个引用）对外暴露接口，比如创建一个 step.js："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const pad = '.'\n\nexports.step = (t) => `|${pad.repeat(t)}》`\n// console.log(module)\n"})}),"\n",(0,o.jsx)(n.p,{children:"再创建一个 race.js:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const { step } = require('./step')\nconst steps = step(10)\n\nmodule.exports = { steps }\nconsole.log(steps)\n// console.log(module)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["打印的结果：",(0,o.jsx)(n.code,{children:"|..........》"}),"，step.js 暴露一个拼接字符串的能力，race 把这个接口拎过来直接用，我们把代码中注释去掉，通过日志打印下 module："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# 模块对象 step\nModule {\n  id: '/Users/c/d/node-10.x/demo/step.js',\n  exports: { step: [Function] },\n  parent:\n   Module {\n     id: '.', exports: {}, parent: null, loaded: false,\n     filename: '/Users/c/d/node-10.x/demo/race.js',\n     children: [ [Circular] ],\n     paths: [ '.../node_modules' ] },\n  filename: '/Users/c/d/node-10.x/demo/step.js',\n  loaded: false, children: [],\n  # 查找模块的方式，就是一级级往上查，直到根目录\n  paths: [ '/Users/c/d/node-10.x/demo/node_modules',\n     '/Users/c/d/node-10.x/node_modules',\n     '/Users/c/d/node_modules',\n     '/Users/c/node_modules',\n     '/Users/node_modules',\n     '/node_modules' ] }\n"})}),"\n",(0,o.jsx)(n.p,{children:"这是第一个模块 step.js 的模块内部信息，下面是第二个，两个模块结构都是一样的，大家可以比对下有哪些不同？"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# 模块对象 race\nModule {\n  id: '.', parent: null, loaded: false,\n  exports: { steps: '|..........》' },\n  filename: '/Users/c/d/node-10.x/demo/race.js',\n  children:\n   [ Module {\n       id: '/Users/c/d/node-10.x/demo/step.js',\n       exports: [Object], parent: [Circular],\n       loaded: true, children: [], paths: [Array]\n       filename: '/Users/c/d/node-10.x/demo/step.js' ],\n  paths: [ '.../node_modules' ] }\n"})}),"\n",(0,o.jsx)(n.p,{children:"打印出来的是 module 对象，有 id/loaded/paths/filename 这些基本信息外，被引用的模块会有一个 parent，里面是引用它的父亲模块的信息，反过来，引用了别的接口的模块，它里面则会有 children，里面包含了被它引用的模块信息，一个模块既可以被引用也可以引用别人。"}),"\n",(0,o.jsx)(n.p,{children:"我们来看下 step.js 的 module.exports，它也是一个对象，包含一个 step 的函数，race.js 里面的 module.exports 也是一个对象，里面包含的是 steps 这个字符串，那么 step 函数和 steps 都是这两个模块对外暴露的接口，暴露的方式，都是通过 module.exports 或 exports，它俩作用等价，而引用很简单，require 就够了。"}),"\n",(0,o.jsx)(n.p,{children:"那这个 module 和 require 又是怎么来的，我们就得结合前面 Node 源码分析启动流程来接着讲了，同时要先回忆下 CommonJS 规范。"}),"\n",(0,o.jsxs)(n.h2,{id:"commonjs-是模块管理的规范",children:["CommonJS 是模块管理的规范",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs-是模块管理的规范",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/CommonJS",target:"_blank",rel:"noopener noreferrer",children:"CommonJS"})," 的前身是 ",(0,o.jsx)(n.a,{href:"https://wiki.mozilla.org/ServerJS",target:"_blank",rel:"noopener noreferrer",children:"ServerJS"}),"。Node 在采用 CommonJS 规范来管理模块关系后，如日中天，拿下了服务端 JavaScript 市场的几乎全部江山，所谓青出于蓝而更胜于蓝，Node 在 CommonJS 的基础上继续衍化，加上 CommonJS 脱离群众太久，最终大家愿意买单的竟然是 Node Modules。再看下浏览器端，既有对 CommonJS 实现的前端模块加载框架 SeaJS/KISSY 等，也有基于 CommonJS 继续演进的 RequireJS，AMD 规范也应运而生，无论是 CommonJS 还是 AMD，基于他们所实现的模块加载库的背后也都有各自的构建工具，花开各家几年后，Webpack 横空出世，以 Webpack 为代表的构建工具，把不同模块理念下的模块代码全部收拢进来，彻底一统江湖。"]}),"\n",(0,o.jsxs)(n.p,{children:["关于模块的历史大家可以看 ",(0,o.jsx)(n.a,{href:"https://www.cyj.me/programming/2018/05/22/about-module-i/",target:"_blank",rel:"noopener noreferrer",children:"前端模块的历史沿革"}),"，我们今天只关注 Node 里面的 CommonJS。"]}),"\n",(0,o.jsx)(n.p,{children:"我们首先问自己这样一个问题，Node 里面的模块规范还是 CommonJS 么？问题先放这儿，我们先去寻找文章开头提到的： module 和 require 又是怎么来的这个问题的答案。"}),"\n",(0,o.jsxs)(n.h2,{id:"node-中的模块加载机制",children:["Node 中的模块加载机制",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#node-中的模块加载机制",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"我们已经知道 CommonJS 是一套模块规范，约定了模块如何定义、加载与执行等等，那在 Node 里面是如何实现的呢？带着这样的问题，我们回到 Node 源码中找寻答案。"}),"\n",(0,o.jsxs)(n.p,{children:["首先，我们把 ",(0,o.jsx)(n.a,{href:"https://juejin.im/book/5bc1bf3e5188255c3272e315/section/5bc21303f265da0aca333271",target:"_blank",rel:"noopener noreferrer",children:"源码解读：Node 程序架构和启动流程"}),"  这一节，我们分析 Node 程序架构和启动流程所学习到的知识，也就是我们的纸篓子先拎过来，这是结论部分，我们先从这个结论部分直接跳到 CommonJS 这里来学习："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"纸篓子 = [\n  '1. Node 源码有一坨依赖，大部分是 C/C++ 底层',\n  '2. Node 启动入口是 node_main.cc 的 main 函数',\n  '3. 入口函数找到 node.cc 的 3 个 Start，依次调用',\n  '4. node.cc 的第一个 Start 初始化了 v8，调用第二个 Start',\n  '5. 第二个 Start 让 v8 准备了引擎实例，调用第三个 Start',\n  '6. 第三个 Start：',\n  '   6.1 首先准备了 v8 的上下文 Context',\n  '   6.2 其次准备了 Node 的启动环境，对各种需要的变量做整理',\n  '   6.3 再把 Node 原生模块和我们的 JS 代码都加载进来运行',\n  '   6.4 最后把主持人 libuv 请上场，执行 JS 里的各种任务',\n  '7. libuv 没活干了，就一层层来退出进程、收拾场地，退出程序',\n]\n"})}),"\n",(0,o.jsx)(n.p,{children:"以上就是 Node 的简要启动过程，从 6.3 这里，Node 正式进入了 JS 的语言世界，那 6.3 里面应该有我们希望看到的答案，它到底做了哪些事呢？"}),"\n",(0,o.jsx)(n.p,{children:"我们再声明一个纸箱子："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"let 纸箱子 = [\n  '6.3.1 Node 底层环境均已 Ready，准备装载 JS 模块'\n]\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"加载内部模块的-loader",children:["加载内部模块的 Loader",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载内部模块的-loader",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["首先回到 6.3 的 ",(0,o.jsx)(n.code,{children:"LoadEnvironment"}),"，在 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L2115",target:"_blank",rel:"noopener noreferrer",children:"src/node.cc 2115 行"}),"，精简如下："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-C++",children:'void LoadEnvironment(Environment* env) {\n  // 1. 首先载入 loader.js 和 node.js 拿到 JS 文件内容（字符串），通过 GetBootstrapper 解析\n  // 注意这两个 JS 是会被 node_js2c 编译成字符串数组，存储到 node_javascript.cc 里面，这里只是源码而已\n  <String> loaders_name = FIXED_STRING(env->isolate(), "internal/bootstrap/loaders.js");\n  <Function> loaders_bootstrapper = GetBootstrapper(env, LoadersBootstrapperSource(env), loaders_name);\n  Local<String> node_name = FIXED_STRING(env->isolate(), "internal/bootstrap/node.js");\n  <Function> node_bootstrapper = GetBootstrapper(env, NodeBootstrapperSource(env), node_name);\n  // 2. 创建各种 bindings，后面会丢到 JS 函数中用\n  // ...\n  // 3. 拼装 loaders 的函数参数数组，分别是 process 和后面的 binding function\n  // 注意这里的几个参数跟下文的 loaders.js 是有对应关系的\n  Local<Value> loaders_bootstrapper_args[] = {\n      env->process_object(),\n      get_binding_fn,\n      get_linked_binding_fn,\n      get_internal_binding_fn\n  };\n  // 4. 通过 ExecuteBootstrapper 来陆续启动内部模块的 loader 和 node.js\n  // 其中启动的时候，会传入环境参数、loader 函数体，以及上面拼好的参数数组\n  ExecuteBootstrapper(env, loaders_bootstrapper.ToLocalChecked(),\n                           arraysize(loaders_bootstrapper_args),\n                           loaders_bootstrapper_args,\n                           &bootstrapped_loaders)\n  \n  // 5. 拼装 node.js 的函数参数数组，分别是 process 和后面的 bootstrapper\n  Local<Value> node_bootstrapper_args[] = {\n    env->process_object(),\n    bootstrapper,\n    bootstrapped_loaders\n  };\n  // 6. 启动 node.js\n  ExecuteBootstrapper(env, node_bootstrapper.ToLocalChecked(),\n                           arraysize(node_bootstrapper_args),\n                           node_bootstrapper_args,\n                           &bootstrapped_node)\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"在注释 1 的位置，JS 源码经过 GetBootstrapper 后，会定义成一个可以执行的 C++ 函数，也就是 loaders_bootstrapper，它是 Local 类型的 Function，在 v8 引擎里面，可以通过 call 直接执行它对应的 JS 函数，可以理解为 v8 里面调用 C++ 函数，来运行一段 JS 代码，另外在执行这个 JS 代码的时候，可以对 JS 里面的函数传入 C++ 构造的一些对象或者函数，这样就达到让被执行的 JS 函数，它里面也能调用到 C++ 层面的函数的目的。"}),"\n",(0,o.jsxs)(n.p,{children:["也就是到了注释 4，通过执行 JS 代码来启动模块的 loader，我们看下 ExecuteBootstrapper 的代码，在 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L2094",target:"_blank",rel:"noopener noreferrer",children:"src/node.cc 2094 行"}),"，精简如下："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-C++",children:"static bool ExecuteBootstrapper(Environment* env, Local<Function> bootstrapper, int argc, Local<Value> argv[], Local<Value>* out) {\n  bootstrapper->Call(\n      env->context(), Null(env->isolate()), argc, argv).ToLocal(out);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["核心就是 ",(0,o.jsx)(n.code,{children:"bootstrapper->Call()"}),"，来执行 bootstrapper 函数，实际上就是执行 ",(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"})," 的 JS 函数表达式 ",(0,o.jsx)(n.code,{children:"(function(){ })"}),"，同时对它传入 C++ 生成的 process 对象和 bindings 函数，也就是 ",(0,o.jsx)(n.code,{children:"loaders_bootstrapper_args"})," 里面的："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-C++",children:"{\n  env->process_object(),  # 对应 process\n  get_binding_fn,         # 对应 GetBinding\n  get_linked_binding_fn,  # 对应 GetLinkedBinding\n  get_internal_binding_fn # 对应 GetInternalBinding\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["在 ",(0,o.jsx)(n.code,{children:"GetBinding"})," ",(0,o.jsx)(n.code,{children:"GetLinkedBinding"})," 和 ",(0,o.jsx)(n.code,{children:"GetInternalBinding"})," 里面，又是各自通过 ",(0,o.jsx)(n.code,{children:"get_builtin_module"})," ",(0,o.jsx)(n.code,{children:"get_internal_module"})," 和 ",(0,o.jsx)(n.code,{children:"get_linked_module"})," 来找到对应的模块以及进行一些初始化工作，这些代码都在 ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v10.x/src/node.cc#L1546",target:"_blank",rel:"noopener noreferrer",children:"src/node.cc"})," 里面，可以发现它们也都是通过 ",(0,o.jsx)(n.code,{children:"FindModule"})," 函数来遍历查找的，关于模块注册和查找我们不再往上面继续深究，继续回来到 ",(0,o.jsx)(n.code,{children:"loaders_bootstrapper_args"})," 的几个参数，我们此时执行 ",(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"}),"，对它传入这 4 个参数，看下简版的 loaders.js 代码："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"(function bootstrapInternalLoaders(process,\n getBinding, getLinkedBinding, getInternalBinding) {\n function NativeModule(id) {}\n\n return loaderExports;\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["发现它所接收的参数刚好是 4 个，跟 ",(0,o.jsx)(n.code,{children:"loaders_bootstrapper_args"})," 里的参数一一对应，同时这个函数里面，有一个 NativeModule 的函数对应，望名生义，应该就是原生模块了，整个 Loaders 函数执行后，还会返回一个 loaderExports 对象，这个对 ",(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"})," 是有用的。"]}),"\n",(0,o.jsx)(n.p,{children:"大白话翻译下，node.cc 里面从 C++ 层面把 loader.js 的源码拎过来解析执行，同时对它传入几个 C++ 对象，这样就可以从 loaders.js 里面以 getBinding 的形式获取原生模块了，费了这么大力气，终于可以来更新下纸箱子了："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"纸箱子 = [\n  '6.3.1 Node 底层环境均已 Ready，准备装载 JS 模块',\n  '6.3.2 node.cc 加载 loaders.js，对 JS 函数传入 process、binding 等 C++ 接口',\n]\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"})," 的文档非常详实，我简单翻译下："]}),"\n",(0,o.jsx)(n.p,{children:"首先它是 Node 启动的前置条件："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"loaders 的作用是创建内部模块，以及用来 binding 的 loaders，来给 built-in 模块使用"}),"\n",(0,o.jsx)(n.li,{children:"我们自己写的代码，包括 node_modules 下的三方模块，都由 lib/internal/modules/cjs/loader.js\n和 lib/internal/modules/esm/* (ES Modules) 接管处理"}),"\n",(0,o.jsx)(n.li,{children:"loaders.js 本身最终会被编译，编译后被 node.cc 所调用，等到它生效后，才会去继续调用 bootstrap/node.js\n也就是说，要等到 loaders 启动之后 Nodejs 才算是真正启动"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"其次，它把 C++ binding 能力挂载到了 process 对象上："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"process.binding(): 是 C++ binding loader, 从用户这可以直接访问"}),"\n",(0,o.jsx)(n.li,{children:"process._linkedBinding(): 目的是让 C++ 作为扩展被项目嵌入进来引用，本质是 C++ binding"}),"\n",(0,o.jsx)(n.li,{children:"internalBinding(): 私有内部（internal） C++ binding loader, 用户无权访问，只给 NativeModule.require() 使用"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"再次，它提供了内部原生模块的 loader 能力："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["NativeModule: 一个迷你的模块系统，用来加载 Node 的核心 JS 模块","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["这些模块在 ",(0,o.jsx)(n.code,{children:"lib/**/*.js"})," ",(0,o.jsx)(n.code,{children:"deps/**/*.js"})," 里面"]}),"\n",(0,o.jsx)(n.li,{children:"这些核心模块会被 node_javascript.cc 编译成 node 二进制文件，这样没有 I/O 开销，加载更快"}),"\n",(0,o.jsxs)(n.li,{children:["这个类还允许核心模块访问 ",(0,o.jsx)(n.code,{children:"lib/internal/*"})," ",(0,o.jsx)(n.code,{children:"deps/internal/*"})," 里的模块和 internalBinding()，也允许核心模块通过 require 加载它，即便它不是一个 CommonJS 的模块"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"process.moduleLoadList 则是按照加载顺序，记录了 bindings 和已经 load 的模块"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"最后，binding 和 loader 的能力，都被放到了 loaderExports 里面，作为函数执行的返回值，以 CommonJS 的方式暴露出去，可以这样理解："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"module.exports = { internalBinding, NativeModule }\n"})}),"\n",(0,o.jsx)(n.p,{children:"再来更新下纸箱子："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"纸箱子 = [\n  '6.3.1 Node 底层环境均已 Ready，准备装载 JS 模块',\n  '6.3.2 node.cc 加载 loaders.js，对 JS 函数传入 process、binding 等 C++ 接口',\n    '6.3.2.1 loaders.js 封装了原生模块的加载，同时把加载能力和 internalBinding 也暴露出去',\n]\n"})}),"\n",(0,o.jsxs)(n.p,{children:["我们再稍微的看下 ",(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"})," 的源码，它里面一共分为三部分："]}),"\n",(0,o.jsx)(n.p,{children:"首先是往 process 上挂 binding:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"process.binding = function binding(module) {\n  mod = bindingObj[module] = getBinding(module);\n};\nprocess._linkedBinding = function _linkedBinding(module) {\n  mod = bindingObj[module] = getLinkedBinding(module);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["然后就是声明 ",(0,o.jsx)(n.code,{children:"NativeModule"}),"，实现代码编译等操作："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"function NativeModule(id) {\n  this.filename = `${id}.js`;\n  this.id = id;\n  this.exports = {};\n  this.script = null;\n}\n\n// require 时代码拎过来组装编译，再把 exports 丢出去，缓存代码都略去不表\nNativeModule.require = function (id) {\n  const nativeModule = new NativeModule(id);\n  nativeModule.compile();\n  return nativeModule.exports;\n};\n\n// contextify 这个模块的作用就是执行 JS 代码\nconst { ContextifyScript } = process.binding('contextify');\n\nNativeModule.prototype.compile = function () {\n  // 拿到传入模块的源码，包裹成 CommonJS 的样子\n  let source = NativeModule.getSource(id);\n  source = NativeModule.wrap(source);\n\n  // ContextifyScript 类上面主要有 RunInContext、RunInThisContext 两个方法\n  const script = new ContextifyScript(\n    source, this.filename, 0, 0,\n    cache, false, undefined\n  );\n  const fn = script.runInThisContext(-1, true, false);\n  const requireFn = this.id.startsWith('internal/deps/') ?\n    NativeModule.requireForDeps :\n    NativeModule.require;\n  fn(this.exports, requireFn, this, process);\n};\n\n// internal 这些内部模块不会暴露给用户使用，代码略去不表\nNativeModule.requireForDeps = function (id) {\n  return NativeModule.require(`internal/deps/${id}`);\n};\nNativeModule.wrapper = ['(function (exports, require, module, process) {', '\\n});'];\nNativeModule.wrap = (script) => (NativeModule.wrapper[0] + script + NativeModule.wrapper[1])\nNativeModule._source = getBinding('natives');\nNativeModule.getSource = function (id) {\n  return NativeModule._source[id];\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:"最后，来把 loaderExports 暴露出去："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"let internalBinding = function internalBinding(module) {\n  let mod = bindingObj[module];\n  if (typeof mod !== 'object') {\n    mod = bindingObj[module] = getInternalBinding(module);\n    moduleLoadList.push(`Internal Binding ${module}`);\n  }\n  return mod;\n};\n\nconst loaderExports = { internalBinding, NativeModule }\n\nreturn loaderExports\n"})}),"\n",(0,o.jsxs)(n.p,{children:["NativeModule 的工作产出，我们来举个简单例子，比如加载 ",(0,o.jsx)(n.code,{children:"internal/steam.js"}),"，源码大概是："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const { Buffer } = require('buffer');\nconst Stream = module.exports = require('internal/streams/legacy');\nStream.Readable = require('_stream_readable');\nStream.Writable = require('_stream_writable');\nStream.Duplex = require('_stream_duplex');\nStream.Transform = require('_stream_transform');\nStream.PassThrough = require('_stream_passthrough');\n"})}),"\n",(0,o.jsxs)(n.p,{children:["那么通过 ",(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"})," 的 loaderExports 中 NativeModule 加载之后，实际是这样的代码在 v8 里面运行："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"(function (exports, require, module, process) {\n  const { Buffer } = require('buffer');\n  const Stream = module.exports = require('internal/streams/legacy');\n  Stream.Readable = require('_stream_readable');\n  Stream.Writable = require('_stream_writable');\n  Stream.Duplex = require('_stream_duplex');\n  Stream.Transform = require('_stream_transform');\n  Stream.PassThrough = require('_stream_passthrough');\n})\n"})}),"\n",(0,o.jsx)(n.p,{children:"运行时，里面的 require，在 NativeModule 里面是有区分的，对于 internal 走 requireForDeps，其他模块就是 require："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const requireFn = this.id.startsWith('internal/deps/') ?\n    NativeModule.requireForDeps :\n    NativeModule.require;\nfn(this.exports, requireFn, this, process)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["总而言之，作为 native 模块的 loader，",(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"})," 依然可以看做是准备工作，主要负责原生模块的加载，那我们在项目中写的 JS 是怎么加载进来的呢？比如 server.js 是怎么被加载进去的呢？"]}),"\n",(0,o.jsxs)(n.p,{children:["真正要让 JS 代码运行起来，还需要 ",(0,o.jsx)(n.code,{children:"internal/bootstrap/node.js"})," 的赞助："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"(function bootstrapNodeJSCore(process,\n  { _setupProcessObject, _setupNextTick, _setupPromises, ... },\n  { internalBinding, NativeModule }) {\n  startup();\n});\n"})}),"\n",(0,o.jsxs)(n.p,{children:["先忽略它第二个通过解构拿到的一坨参数组成的参数对象，我们看第三个参数 ",(0,o.jsx)(n.code,{children:"{ internalBinding, NativeModule }"})," 其实就是我们之前 ",(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"})," 的 loaderExports 所传下来的参数，也就是 binding 能力和 NativeModule 的加载能力，有了这两个能力，我们看下它 startup() 所做的主要事情："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"function startup() {\n  // 通过 NativeModule 拿到 cjs/loader 这个用来加载外部（用户）的 JS loader\n  const CJSModule = NativeModule.require('internal/modules/cjs/loader');\n  preloadModules();\n  // 调用 CJSModule 的 runMain 方法，让代码运行起来\n  CJSModule.runMain();\n}\n\nfunction preloadModules() {\n  const {\n    _preloadModules\n  } = NativeModule.require('internal/modules/cjs/loader');\n  _preloadModules(process._preload_modules);\n}\n\nstartup();\n"})}),"\n",(0,o.jsxs)(n.p,{children:["那么接下来的事情，自然就发生在了 ",(0,o.jsx)(n.code,{children:"internal/modules/cjs/loader"})," 里面了，其实我们可以这样来测试下调用栈，在本地写一个 test.js，里面放上："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"require('./notexist.js')\n"})}),"\n",(0,o.jsxs)(n.p,{children:["我们调用一个不存在的 JS 模块， ",(0,o.jsx)(n.code,{children:"node test.js"})," 跑一下，会报错如下："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# 代码终止在了 583 行，抛出错误\ninternal/modules/cjs/loader.js:583\n  throw err;\n  ^\n\nError: Cannot find module './notexist.js'\n  at Function.Module._resolveFilename (internal/modules/cjs/loader.js:581:15)\n  at Function.Module._load (internal/modules/cjs/loader.js:507:25)\n  at Module.require (internal/modules/cjs/loader.js:637:17)\n  at require (internal/modules/cjs/helpers.js:20:18)\n  at Object.<anonymous> (/Users/black/Downloads/node-10.x/bind.js:1:75)\n  at Module._compile (internal/modules/cjs/loader.js:689:30)\n  at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)\n  at Module.load (internal/modules/cjs/loader.js:599:32)\n  at tryModuleLoad (internal/modules/cjs/loader.js:538:12)\n  at Function.Module._load (internal/modules/cjs/loader.js:530:3)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["调用栈由下向上，依次调用，比如 require('./notexist.js') 就是调用到了",(0,o.jsx)(n.code,{children:"internal/modules/cjs/loader"})," _load 方法，我们一一对应整理下来就是："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"|- loader.js 530 行 _load\n |- loader.js 538 行 tryModuleLoad\n  |- loader.js 599 行 load\n   |- loader.js 700 行 _extensions\n    |- loader.js 275 行 _compile\n     |- bind.js 1 行 匿名函数\n      |- helpers.js 20 行 require\n       |- loader.js 637 行 require\n        |- loader.js 507 行 _load\n         |- loader.js 581 行 _resolveFilename\n"})}),"\n",(0,o.jsxs)(n.p,{children:["具体代码的行数大家不用计较，因为 Node 版本不同，跟我们读的源码不一定能对上，但是函数名基本是可以对上的，来把 ",(0,o.jsx)(n.code,{children:"internal/modules/cjs/loader"})," 代码精简一下，删减到了 50 行，其实跟 NativeModule 差不多，我们找到 Module.runMain 从上向下看："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"function Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n}\n\nModule.wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\nModule.wrapper = [\n  '(function (exports, require, module, __filename, __dirname) { ',\n  '\\n});'\n];\n\nModule.runMain = function() {\n  Module._load(process.argv[1], null, true);\n};\n\nModule._load = function(request, parent, isMain) {\n  var module = new Module(filename, parent);\n\n  tryModuleLoad(module, filename);\n};\n\nfunction tryModuleLoad(module, filename) {\n  module.load(filename);\n}\n\nModule.prototype.load = function(filename) {\n  Module._extensions['.js'](this, filename);\n};\n\nModule._extensions['.js'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  module._compile(stripBOM(content), filename);\n};\n\nModule.prototype._compile = function(content, filename) {\n  var wrapper = Module.wrap(content);\n  var compiledWrapper = vm.runInThisContext(wrapper, {\n    filename: filename,\n    lineOffset: 0,\n    displayErrors: true\n  });\n  var require = makeRequireFunction(this);\n  \n  compiledWrapper.call(this.exports, this.exports, require, this, filename, dirname);\n};\n\nModule.prototype.require = function(id) {\n  return Module._load(id, this, /* isMain */ false);\n};\n\nModule._resolveFilename = function(request, parent, isMain, options) {};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["那么我们平时手写的 JS 代码，包括 node_modules 下的代码，就会被这个 CJS Loader 给接管了，拿到代码后的第一件事就是对它包裹一个函数表达式，传入一些变量，我们可以在 node 命令行模式下，输入 ",(0,o.jsx)(n.code,{children:"require('module').wrap.toString()"})," 和 ",(0,o.jsx)(n.code,{children:"require('module').wrapper"})," 来查看到包裹的方法："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:d,alt:""})}),"\n",(0,o.jsx)(n.p,{children:"我们可以拿一段 webpack 源代码举例："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"// ChunkRenderError.js\nconst WebpackError = require('./WebpackError')\n\nclass ChunkRenderError extends WebpackError {\n  constructor(chunk, file, error) {\n    super()\n\n    this.name = 'ChunkRenderError'\n    this.error = error\n    this.message = error.message\n    this.details = error.stack\n    this.file = file\n    this.chunk = chunk\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n\nmodule.exports = ChunkRenderError\n"})}),"\n",(0,o.jsx)(n.p,{children:"在 require 的时候，经过 CJS Loader 的编译，就编程了这样子："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"(function (exports, require, module, __filename, __dirname) {\n  const WebpackError = require('./WebpackError')\n\n  class ChunkRenderError extends WebpackError {\n    constructor(chunk, file, error) {\n      super()\n\n      this.name = 'ChunkRenderError'\n      this.error = error\n      this.message = error.message\n      this.details = error.stack\n      this.file = file\n      this.chunk = chunk\n      Error.captureStackTrace(this, this.constructor)\n    }\n  }\n\n  module.exports = ChunkRenderError\n})\n"})}),"\n",(0,o.jsx)(n.p,{children:"于是我们很直观的得到两个结论："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"internal/bootstrap/loaders.js"})," 和 ",(0,o.jsx)(n.code,{children:"internal/modules/cjs/loader"})," 都是 Loader，但作用不同，前者是加载 Native 模块，后者加载我们项目中的 JS 模块，且后者依赖前者"]}),"\n",(0,o.jsx)(n.li,{children:"前者是非 CommonJS 的 Loader，后者是 CommonJS 的 Loader"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"扒了这一圈，我们就可以来回答文章开头的问题了：Node 里面的模块规范还是 CommonJS 么？"}),"\n",(0,o.jsxs)(n.h2,{id:"commonjs-与-node-modules",children:["CommonJS 与 Node Modules",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs-与-node-modules",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["上面提到，虽然基于 CommonJS 来实现模块管理，但 Node 的 modules 体系演化至今，已经自成一套，跟 CommonJS 虽有大量血缘关系，但也确实有不同之处，最明显的，Node 里面 ",(0,o.jsx)(n.code,{children:"require('./index')"})," 的依赖查找有后缀名的优先级，分别是 .js > .json > .node，同时一个模块的入口文件路径，是在 package.json 的 main 里面定义，以及 Node 里面依赖的模块统一在 node_modules 下面管理，这也是 Node 所独有的，还有其他比较大的差异之处，比如："]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["CommonJS 为 require 定义了 main 和 paths 两个静态属性，而 Node 不支持 require.paths， 且暴露了额外的 cache 属性和 resolve() 方法，可以 node 命令行打印 ",(0,o.jsx)(n.code,{children:"require"}),"。"]}),"\n",(0,o.jsx)(n.li,{children:"CommonJS 的 module 对象有 id 和 uri，而 Node 里面增加了 children/exports/filename/loaded/parent 属性，以及 require() 方法，它的接口通过 exports 和 module.exports 对外暴露，而在 CommonJS 里面，暴露模块 API 的唯一办法就是对 exports 对象增加方法或者属性，module.exports 在 CommonJS 里面不存在。"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"总而言之，就像 Node 社区所说，CommonJS is dead，Node 里的 modules 体系已经不再是严格意义的 CommonJS，只是大家对这个叫法习惯了，现在依然用 CommonJS 来代指 Node 里面的模块规范，而事实上，Node 社区的开发者已经抛弃 CommonJS 而去，只不过里面的大量血液仍源于 CommonJS。"}),"\n",(0,o.jsxs)(n.h3,{id:"编程练习---实现视频数量与时长统计小工具",children:["编程练习 - 实现视频数量与时长统计小工具",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编程练习---实现视频数量与时长统计小工具",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"最后，我们来实现一个小工具，可以检查当前目录里面，所有的 mp4 文件的总时长，我自己平时有下载一些抖音视频，存了一大堆，有时候想要统计下每一类视频，平均是多少时长之类的数据，是个小玩具，简单实现如下："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"// 这里会有 1.mp4 2.mp4 等几十上百个视频\n// 可以用 promise 并发计算时长，最后汇总叠加\n// 叠加总时长如果不超过 1 个小时，比如 55 分钟，那就打印 55 分钟\n// 如果超过 1 个小时，比如 65 分钟，打印 1 小时 5 分钟\nconst fs = require('fs')\nconst path = require('path')\nconst moment = require('moment')\nconst util = require('util')\nconst open = util.promisify(fs.open)\nconst read = util.promisify(fs.read)\n\nfunction getTime (buffer) {\n  const start = buffer.indexOf(Buffer.from('mvhd')) + 17\n  const timeScale = buffer.readUInt32BE(start)\n  const duration = buffer.readUInt32BE(start + 4)\n  const movieLength = Math.floor(duration / timeScale)\n  return movieLength\n}\n\nfunction getLocaleTime (seconds) {\n  return moment\n    .duration(seconds, 'seconds')\n    .toJSON()\n    .replace(/[PTHMS]/g, str => {\n      switch (str) {\n        case 'H': return '小时'\n        case 'M': return '分钟'\n        case 'S': return '秒'\n        default: return ''\n      }\n    })\n}\n\n;(async function () {\n  const dir = path.resolve(__dirname + '/video')\n  const files = fs.readdirSync(dir).map(file => path.resolve(dir, file))\n  const videos = await Promise.all(\n    files.map(async file => {\n      const fd = await open(file, 'r')\n      const buff = Buffer.alloc(100)\n      const { buffer } = await read(fd, buff, 0, 100, 0)\n      const time = getTime(buffer)\n      return { file, time }\n    })\n  )\n  const res = {\n    '视频总数': videos.length,\n    '视频总时长': getLocaleTime(\n      videos.reduce((prev, e) => {\n        return prev + e.time\n      }, 0)\n    )\n  }\n  \n  console.log(res)\n  return res\n})()\n\n"})})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F3%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%20%5B%E8%A7%86%E9%A2%91%E6%97%B6%E9%95%BF%E7%BB%9F%E8%AE%A1%5D%20Node%20%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%EF%BC%88CommonJS%EF%BC%89%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86.md"]={toc:[{text:"",id:"",depth:3},{text:"CommonJS 是模块管理的规范",id:"commonjs-是模块管理的规范",depth:2},{text:"Node 中的模块加载机制",id:"node-中的模块加载机制",depth:2},{text:"加载内部模块的 Loader",id:"加载内部模块的-loader",depth:3},{text:"CommonJS 与 Node Modules",id:"commonjs-与-node-modules",depth:2},{text:"编程练习 - 实现视频数量与时长统计小工具",id:"编程练习---实现视频数量与时长统计小工具",depth:3}],title:"3案例二： [视频时长统计] Node 的模块机制（CommonJS）与包管理",headingTitle:"3案例二： [视频时长统计] Node 的模块机制（CommonJS）与包管理",frontmatter:{}}}}]);