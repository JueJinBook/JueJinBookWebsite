"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55289"],{626e3:function(e,n,r){r.r(n),r.d(n,{default:()=>B});var s=r(552676),l=r(740453);let a=r.p+"static/image/3c2be26e31854b805acebb9ad196f5f6.75c3409f.png",c=r.p+"static/image/6e2049f611bc9c8d06559818b2ec80a3.fd0e4b66.png",i=r.p+"static/image/4468c5d893aff6e052f637496e3570f2.e16eac3c.png",p=r.p+"static/image/7f272934c7fda0e47f7252b278467c28.3d80bbb3.png",t=r.p+"static/image/d70c85bbc877f9376941401a39e61191.00f609da.png",d=r.p+"static/image/903287695189a60c35cd78758d7c2ccf.bb98fd83.png",h=r.p+"static/image/793e19a893220da54791760c5bf216cf.9a79acf8.png",j=r.p+"static/image/e5b298dcff8314d3f65988a5f0f1937c.5053c6ba.png",b=r.p+"static/image/438fa1dc2aa9b5f79e26879c6cf6f438.ddaf7e26.png",x=r.p+"static/image/aabf4d7d04c594cc34d8341757efeb8b.588e681f.png",g=r.p+"static/image/62082331d0c851fa79ab853c71b54c8f.453e1d30.png",o=r.p+"static/image/4cc900a5090f98fd5365e415b59c5a05.a3db2655.png",u=r.p+"static/image/023c39adbd4eb7f686c2d6a33f35ef34.ac891dd1.png",m=r.p+"static/image/93467eb23ef212d71dca42f6043dc467.4453e5bc.png",f=r.p+"static/image/b88b357ed6a329361983e3059409e786.086cb38a.png",v=r.p+"static/image/b19d21e813a1c4b7767a3db5df4f938d.c0c9b7d0.png";function y(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",strong:"strong"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"14babel-配置的原理",children:["14.Babel 配置的原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14babel-配置的原理",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"觉得之前写的 babel 内置功能不是很好，所以补充一节 babel 配置的原理，常用的配置也就这些。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"babel 是一个 JS、TS 的编译器，它能把新语法写的代码转换成目标环境支持的语法的代码，并且对目标环境不支持的 api 自动 polyfill。"}),"\n",(0,s.jsx)(n.p,{children:"babel 基本每个项目都用，大家可能对 @babel/preset-env 和 @babel/plugin-transform-runtime 都很熟悉了，但是你真的理解它们么？"}),"\n",(0,s.jsx)(n.p,{children:"相信很多同学只是知道它能干什么，但不知道它是怎么实现的，这篇文章我们就来深入下它们的实现原理吧。"}),"\n",(0,s.jsx)(n.p,{children:"首先，我们先来试一下 preset-env 和 plugin-transform-runtime 的功能："}),"\n",(0,s.jsxs)(n.h2,{id:"功能测试",children:["功能测试",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能测试",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"@babel/preset-env 的作用是根据 targets 的配置引入对应插件来实现编译和 polyfill。"}),"\n",(0,s.jsx)(n.p,{children:"比如这段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class Dong {\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在低版本浏览器不支持，会做语法转换。"}),"\n",(0,s.jsx)(n.p,{children:"我们把 targets 指定成比较低版本的浏览器，比如 chrome 30，并且打开 debug 选项，它的作用是会打印用到的 plugin。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"{\n    presets: [\n        ['@babel/preset-env', {\n            targets: 'chrome 30',\n            debug: true,\n            useBuiltIns: 'usage',\n            corejs: 3\n        }]\n    ]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"执行 babel 就会发现它用到了这些插件："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是 @babel/preset-env 的意义，自动根据 targets 来引入需要的插件，不然要是手动写这么一堆插件不得麻烦死。"}),"\n",(0,s.jsx)(n.p,{children:"开启 polyfill 功能要指定它的引入方式，也就是 useBuiltIns。设置为 usage 是在每个模块引入用到的，设置为 entry 是统一在入口处引入 targets 需要的。"}),"\n",(0,s.jsx)(n.p,{children:"polyfill 的实现就是 core-js，需要再指定下 corejs 版本，一般是指定 3，这个会 polyfill 实例方法，而 corejs2 不会。"}),"\n",(0,s.jsx)(n.p,{children:"上面一段代码会转换成这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"注入了 3 个 helper，也就是 _createClass 这种以下划线开头的辅助方法。"}),"\n",(0,s.jsx)(n.p,{children:"因为 helper 方法里用到了 Object.defineProperty 的 api，这里也会从 core-js 里引入。"}),"\n",(0,s.jsx)(n.p,{children:"我们再测试一下这样一段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"async function func() {\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"会被转换成这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"除了注入 core-js、helper 代码外，还注入了 regenerator 代码，这个是 async await 的实现。"}),"\n",(0,s.jsxs)(n.p,{children:["综上，",(0,s.jsx)(n.strong,{children:"babel runtime 包含的代码就 core-js、helper、regenerator 这三种。"})]}),"\n",(0,s.jsx)(n.p,{children:"@babel/preset-env 的处理方式是 helper 代码直接注入、regenerator、core-js 代码全局引入。"}),"\n",(0,s.jsx)(n.p,{children:"这样就会导致多个模块重复注入同样的代码，会污染全局环境。"}),"\n",(0,s.jsx)(n.p,{children:"解决这个问题就要使用 @babel/plugin-transform-runtime 插件了。"}),"\n",(0,s.jsx)(n.p,{children:"我们在配置文件里引入这个插件："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"{\n    presets: [\n        ['@babel/preset-env', {\n            targets: 'chrome 30',\n            debug: true,\n            useBuiltIns: 'usage',\n            corejs: 3\n        }]\n    ],\n    plugins: [\n        ['@babel/plugin-transform-runtime', {\n            corejs: 3\n        }]\n    ]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"注意，这个插件也是处理 polyfill ，也就同样需要指定 corejs 的版本。"}),"\n",(0,s.jsx)(n.p,{children:"然后测试下引入之后有什么变化："}),"\n",(0,s.jsx)(n.p,{children:"先测试 class 那个案例："}),"\n",(0,s.jsx)(n.p,{children:"之前是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"现在变成了这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"变成了从 @babel/runtime-corejs3 引入的形式，这样就不会多个模块重复注入同样的实现代码了，而且 core-js 的 api 也不是全局引入了，变成了模块化引入。"}),"\n",(0,s.jsx)(n.p,{children:"这样就解决了 corejs 的重复注入和全局引入 polyfill 的两个问题。"}),"\n",(0,s.jsx)(n.p,{children:"再测试 async function 那个案例："}),"\n",(0,s.jsx)(n.p,{children:"之前是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"同样有全局引入和重复注入的问题。"}),"\n",(0,s.jsx)(n.p,{children:"引入 transform-runtime 插件之后是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"也是同样的方式解决了那两个问题。"}),"\n",(0,s.jsx)(n.p,{children:"再来测试一个 api 的，用这样一段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"new WeakMap();\n"})}),"\n",(0,s.jsx)(n.p,{children:"当只配置 preset-env 时："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"{\n    presets: [\n        ['@babel/preset-env', {\n            targets: 'chrome 30',\n            debug: true,\n            useBuiltIns: 'usage',\n            corejs: 3\n        }]\n    ]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"结果是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"再加上 @babel/plugin-transform-runtime 后："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"{\n    presets: [\n        ['@babel/preset-env', {\n            targets: 'chrome 30',\n            debug: true,\n            useBuiltIns: 'usage',\n            corejs: 3\n        }]\n    ],\n    plugins: [\n        ['@babel/plugin-transform-runtime',\n            {\n                corejs: 3\n            }\n        ]\n    ]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"结果是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样我们就清楚了 @babel/plugin-transform-runtime 的功能，把注入的代码和 core-js 全局引入的代码转换成从 @babel/runtime-corejs3 中引入的形式。"}),"\n",(0,s.jsx)(n.p,{children:"@babel/runtime-corejs3 就包含了 helpers、core-js、regenerator 这 3 部分。"}),"\n",(0,s.jsx)(n.p,{children:"功能我们都清楚了，那它们是怎么实现的呢？"}),"\n",(0,s.jsxs)(n.h2,{id:"实现原理",children:["实现原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现原理",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"preset-env 的原理之前讲过，就是根据 targets 的配置查询内部的 @babe/compat-data 的数据库，过滤出目标环境不支持的语法和 api，引入对应的转换插件。"}),"\n",(0,s.jsx)(n.p,{children:"targets 使用 browserslist 来解析成具体的浏览器和版本："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后根据 @babel/compact-data 的数据来过滤出这些浏览器支持的语法和 api："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后去掉这些已经支持的语法和 api 对应的插件，剩下的就是需要用的转换插件："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是 preset-env 的根据 targtes 来按需转换语法和 polyfill 的原理。"}),"\n",(0,s.jsx)(n.p,{children:"那 @babel/plugin-transform-runtime 呢？它是怎么实现的？"}),"\n",(0,s.jsx)(n.p,{children:"这个插件的原理是因为 babel 插件和 preset 生效的顺序是这样的（下面是官网文档的截图）："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"先插件后 preset，插件从左往右，preset 从右往左。"}),"\n",(0,s.jsx)(n.p,{children:"这就导致了 @babel/plugin-transform-runtime 是在 @babel/preset-env 之前调用的，提前做了 api 的转换，那到了 @babel/preset-env 就没什么可转了，也就实现了 polyfill 的抽取。"}),"\n",(0,s.jsx)(n.p,{children:"它的源码是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"会根据配置来引入 corejs、regenerator 的转换插件，实现 polyfill 注入的功能。"}),"\n",(0,s.jsx)(n.p,{children:"并且还设置了一个 helperGenerator 的函数到全局上下文 file，这样后面 @babel/preset-env 就可以用它来生成 helper 代码。那自然也就是抽离的了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是 @babel/plugin-transform-runtime 的原理："}),"\n",(0,s.jsx)(n.p,{children:"因为插件在 preset 之前调用，所以可以提前把 polyfill 转换了，而且注入了 helpGenerator 来修改 @babel/preset-env 生成 helper 代码的行为。"}),"\n",(0,s.jsx)(n.p,{children:"原理我们理清了，但是大家有没有发现其中的问题："}),"\n",(0,s.jsxs)(n.h2,{id:"现有方案的问题",children:["现有方案的问题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#现有方案的问题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们通过 @babel/plugin-transform-runtime  提前把 polyfill 转换了，但是这个插件里没有 targets 的设置呀，不是按需转换的，那就会多做一些没必要的转换。"}),"\n",(0,s.jsxs)(n.p,{children:["这个其实是已知问题，可以在 babel 的项目里找到这个 ",(0,s.jsx)(n.a,{href:"https://github.com/babel/babel/issues/10008",target:"_blank",rel:"noopener noreferrer",children:"issue"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"当然官方也提出了解决的方案，只不过这个得等 babel 新版本更新再用了，等 babel8 吧。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"babel7 以后，我们只需要使用 @babel/preset-env，指定目标环境的 targets，babel 就会根据内部的兼容性数据库查询出该环境不支持的语法和 api，进行对应插件的引入，从而实现按需的语法转换和 polyfill 引入。"}),"\n",(0,s.jsx)(n.p,{children:"但是 @babel/preset-env 转换用到的一些辅助代码（helper）是直接注入到模块里的，没有做抽离，多个模块可能会重复注入。并且用到的 polyfill 代码也是全局引入的，可能污染全局环境。为了解决这两个问题我们会使用 @babel/plugin-transform-runtime 插件来把注入的代码抽离，把全局的引入改为从 @babel/runtime-corejs3 引入的方式。"}),"\n",(0,s.jsx)(n.p,{children:"runtime 包包含 core-js、regenerator、helper 三部分。"}),"\n",(0,s.jsx)(n.p,{children:"@babel/plugin-transform-runtime 能生效的原理是因为插件先于 preset 被调用，提前把那些 api 做了转换，并且设置了 preset-env 生成 helper 的方式。"}),"\n",(0,s.jsx)(n.p,{children:"但是这个转换和 preset-env 是独立的，它没有 targets 的配置，这就导致了不能按需 polyfill，会进行一些不必要的转换。这个是已知的 issue，等 babel 版本更新吧。"}),"\n",(0,s.jsx)(n.p,{children:"看到这里，你对 babel 的配置和这些配置的原理是否有更深的理解了呢。"})]})}function E(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(y,{...e})}):y(e)}let B=E;E.__RSPRESS_PAGE_META={},E.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F14.Babel%20%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8E%9F%E7%90%86.md"]={toc:[{text:"功能测试",id:"功能测试",depth:2},{text:"实现原理",id:"实现原理",depth:2},{text:"现有方案的问题",id:"现有方案的问题",depth:2},{text:"总结",id:"总结",depth:2}],title:"14.Babel 配置的原理",headingTitle:"14.Babel 配置的原理",frontmatter:{}}}}]);