"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["599"],{869880:function(n,e,l){l.r(e),l.d(e,{default:()=>h});var i=l(552676),r=l(740453);let s=l.p+"static/image/3ee4079c071fc0321c7b804e7c49097a.528a2288.webp";function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ul:"ul",li:"li",img:"img",h3:"h3",h4:"h4",br:"br",pre:"pre",strong:"strong",blockquote:"blockquote",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,r.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"7初级入门-----纹理贴图为形体穿上外衣",children:["7.初级入门 --- 纹理贴图：为形体穿上外衣",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#7初级入门-----纹理贴图为形体穿上外衣",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["之前章节我们学习了绘制单一和渐变颜色的三角形，但是在实际的建模中（游戏居多），模型表面往往都是丰富生动的图片。这就需要有一种机制，能够让我们把图片素材渲染到模型的一个或者多个表面上，这种机制叫做",(0,i.jsx)(e.code,{children:"纹理贴图"}),"，本节我们学习如何使用 WebGL 进行纹理贴图。"]}),"\n",(0,i.jsxs)(e.h2,{id:"目标",children:["目标",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#目标",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"本节我们的目标是要学会纹理贴图的步骤以及注意事项。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"http://ifanqi.top/webgl/pages/lesson13.html",target:"_blank",rel:"noopener noreferrer",children:"演示地址"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://github.com/lucefer/webgl/blob/master/pages/lesson13.html",target:"_blank",rel:"noopener noreferrer",children:"源码地址"})}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"通过本节学习，你将掌握如下内容："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"为什么需要贴图？"}),"\n",(0,i.jsx)(e.li,{children:"贴图的步骤？"}),"\n",(0,i.jsx)(e.li,{children:"注意事项。"}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"为什么我们需要贴图",children:["为什么我们需要贴图？",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么我们需要贴图",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"之前章节的示例中，为图形增加色彩仅仅是用了简单的单色和渐变色，但是实际应用中往往需要一些丰富多彩的图案，我们不可能用代码来生成这些图案，费时费力，效果也不好。通常我们会借助一些图形软硬件（比如照相机、手机、PS等）准备好图片素材，然后在 WebGL 中把图片应用到图形表面。"}),"\n",(0,i.jsxs)(e.h2,{id:"纹理图片格式",children:["纹理图片格式",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#纹理图片格式",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"WebGL 对图片素材是有严格要求的，图片的宽度和高度必须是 2 的 N 次幂，比如 16 x 16，32 x 32，64 x 64 等。实际上，不是这个尺寸的图片也能进行贴图，但是这样会使得贴图过程更复杂，从而影响性能，所以我们在提供图片素材的时候最好参照这个规范。"}),"\n",(0,i.jsxs)(e.h2,{id:"纹理坐标系统",children:["纹理坐标系统",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#纹理坐标系统",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["纹理也有一套自己的坐标系统，为了和顶点坐标加以区分，通常把纹理坐标称为 ",(0,i.jsx)(e.code,{children:"UV"}),"，",(0,i.jsx)(e.code,{children:"U"})," 代表横轴坐标，",(0,i.jsx)(e.code,{children:"V"})," 代表纵轴坐标。"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"图片坐标系统的特点是："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"左上角为原点(0, 0)。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"向右为横轴正方向，横轴最大值为 1，即横轴坐标范围【1，0】。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"向下为纵轴正方向，纵轴最大值为 1，即纵轴坐标范围【0，1】。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"纹理坐标系统不同于图片坐标系统，它的特点是："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"左下角为原点(0, 0)。"}),"\n",(0,i.jsx)(e.li,{children:"向右为横轴正方向，横轴最大值为 1，即横轴坐标范围【1，0】。"}),"\n",(0,i.jsx)(e.li,{children:"向上为纵轴正方向，纵轴最大值为 1，即纵轴坐标范围【0，1】。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"如下图所示："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:s,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"纹理坐标系统可以理解为一个边长为 1 的正方形。"}),"\n",(0,i.jsxs)(e.h3,{id:"贴图练习",children:["贴图练习",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#贴图练习",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"接下来，我们学习一下贴图过程。"}),"\n",(0,i.jsxs)(e.h4,{id:"准备图片",children:["准备图片",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#准备图片",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"按照规范所讲，我们首先准备一张符合要求的图片，这里自己制作一个尺寸为宽高分别是 2 的 7 次方，即 128 x 128 的图片。"}),"\n",(0,i.jsxs)(e.h4,{id:"着色器",children:["着色器",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#着色器",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"本节片元着色器中，不再是接收单纯的颜色了，而是接收纹理图片对应坐标的颜色值，所以我们的着色器要能够做到如下几点："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["顶点着色器接收顶点的 ",(0,i.jsx)(e.code,{children:"UV"})," 坐标，并将",(0,i.jsx)(e.code,{children:"UV"}),"坐标传递给片元着色器。"]}),"\n",(0,i.jsxs)(e.li,{children:["片元着色器要能够接收顶点插值后的",(0,i.jsx)(e.code,{children:"UV"}),"坐标，同时能够在纹理资源找到对应坐标的颜色值。"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"我们看下如何修改才能满足这两点："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"顶点着色器"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["首先，增加一个名为 v_Uv 的 attribute 变量，接收 JavaScript 传递过来的 UV 坐标。",(0,i.jsx)(e.br,{}),"\n","其次，增加一个 varying 变量 v_Uv，将 UV 坐标插值化，并传递给片元着色器。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-glsl",children:"    precision mediump float;\n   // 接收顶点坐标 (x, y)\n   attribute vec2 a_Position;\n   // 接收 canvas 尺寸(width, height)\n   attribute vec2 a_Screen_Size;\n   // 接收JavaScript传递过来的顶点 uv 坐标。\n   attribute vec2 a_Uv;\n   // 将接收的uv坐标传递给片元着色器\n   varying vec2 v_Uv;\n   void main(){\n     vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0;\n     position = position * vec2(1.0,-1.0);\n     gl_Position = vec4(position, 0, 1);\n     // 将接收到的uv坐标传递给片元着色器\n     v_Uv = a_Uv;\n   }\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["片元着色器\n首先，增加一个 ",(0,i.jsx)(e.code,{children:"varying"})," 变量 ",(0,i.jsx)(e.code,{children:"v_Uv"}),"，接收顶点着色器插值过来的 ",(0,i.jsx)(e.code,{children:"UV"})," 坐标。",(0,i.jsx)(e.br,{}),"\n","其次，增加一个 ",(0,i.jsx)(e.code,{children:"sampler2D"})," 类型的全局变量 ",(0,i.jsx)(e.code,{children:"texture"}),"，用来接收 JavaScript 传递过来的纹理资源（图片数据）。"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-glsl",children:"	precision mediump float;\n	// 接收顶点着色器传递过来的 uv 值。\n	varying vec2 v_Uv;\n	// 接收 JavaScript 传递过来的纹理\n	uniform sampler2D texture;\n	void main(){\n		// 提取纹理对应uv坐标上的颜色，赋值给当前片元（像素）。\n  		gl_FragColor = texture2D(texture, vec2(v_Uv.x, v_Uv.y));\n	}\n"})}),"\n",(0,i.jsxs)(e.h4,{id:"javascript-部分",children:["JavaScript 部分",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-部分",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"我们首先要将纹理图片加载到内存中："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'    var img = new Image();\n    img.onload = textureLoadedCallback;\n    img.src = "";\n'})}),"\n",(0,i.jsxs)(e.p,{children:["图片加载完成之后才能执行纹理的操作，我们将纹理操作放在图片加载完成后的回调函数中，即",(0,i.jsx)(e.code,{children:"textureLoadedCallback"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"需要注意的是，我们使用 canvas 读取图片数据是受浏览器跨域限制的，所以首先要解决跨域问题。"}),"\n",(0,i.jsx)(e.p,{children:"那么，针对图片跨域问题我们可以采用三种方式来解决："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"第一种方法：设置允许 Chrome 跨域加载资源"})}),"\n",(0,i.jsx)(e.p,{children:"在本地开发阶段，我们可以设置 Chrome 浏览器允许加载跨域资源，这样就可以使用磁盘地址来访问页面了。"}),"\n",(0,i.jsx)(e.p,{children:"mac 设置方法如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-bash",children:"open -n /Applications/Google\\ Chrome.app/ --args --disable-web-security --user-data-dir(指定目录,例如 = /user/Documents)\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"第二种方法：图片资源和页面资源放在同一个域名下"})}),"\n",(0,i.jsx)(e.p,{children:"除了设置 Chrome，我们还可以将图片资源和页面资源部署在同一域名下，这样就不存在跨域问题了。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"第三种方法：为图片资源设置跨域响应头"})}),"\n",(0,i.jsx)(e.p,{children:"实际生产环境中，图片资源往往部署在 CDN 上，图片和页面分属不同域，这种情况的跨域访问我们就需要正面解决了。"}),"\n",(0,i.jsxs)(e.p,{children:["假设我们的图片资源所属域名为：",(0,i.jsx)(e.code,{children:"https://cdn-pic.com"}),"，页面所属域名为 ",(0,i.jsx)(e.code,{children:"https://test.com"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"解决方法如下："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"首先：为图片资源设置跨域响应头："}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-glsl",children:"Access-Control-Allow-Origin：`https://test.com`\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"其次：在图片加载时，为 img 设置 crossOrigin 属性。"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"var img = new Image();\nimg.crossOrigin = '';\nimg.src = 'https://cdn-pic.com/test.jpg'\n"})}),"\n",(0,i.jsx)(e.p,{children:"做完这两步，我们就可以真正的加载跨域图片了。\n解决了图片加载跨域问题，我们就可以开始纹理贴图了。"}),"\n",(0,i.jsx)(e.p,{children:"我们定义六个顶点，这六个顶点能够组成一个矩形，并为顶点指定纹理坐标。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"    var positions = [\n      30, 30, 0, 0,    //V0\n      30, 300, 0, 1,   //V1\n      300, 300, 1, 1,  //V2\n      30, 30, 0, 0,    //V0\n      300, 300, 1, 1,  //V2\n      300, 30, 1, 0    //V3\n    ]\n"})}),"\n",(0,i.jsx)(e.p,{children:"按照惯例，我们该为着色器传递数据了。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"经历过前面几个小节的练习，相信大家对操作 WebGL 的代码已经很熟悉了。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"加载图片"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:'	var img  = new Image();\n	img.onload = textureLoadedCallback;\n	img.src="";\n'})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:["您或许看到我并没有为 img 设置 ",(0,i.jsx)(e.code,{children:"crossOrigin"})," 属性，原因是在我本地，图片和页面在同一个域名下，所以不需要额外设置。"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"图片加载完成后，我们进行如下操作："}),"\n",(0,i.jsxs)(e.p,{children:["首先：激活 0 号纹理通道",(0,i.jsx)(e.code,{children:"gl.TEXTURE0"}),"，0 号纹理通道是默认值，本例也可以不设置。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"	gl.activeTexture(gl.TEXTURE0);\n"})}),"\n",(0,i.jsx)(e.p,{children:"然后创建一个纹理对象："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"	var texture = gl.createTexture();\n"})}),"\n",(0,i.jsxs)(e.p,{children:["之后将创建好的纹理对象",(0,i.jsx)(e.code,{children:"texture"}),"绑定 到",(0,i.jsx)(e.code,{children:"当前纹理绑定点"}),"上，即 ",(0,i.jsx)(e.code,{children:"gl.TEXTURE_2D"}),"。绑定完之后对当前纹理对象的所有操作，都将基于 ",(0,i.jsx)(e.code,{children:"texture"})," 对象，直到重新绑定。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"	gl.bindTexture(gl.TEXTURE_2D, texture);\n"})}),"\n",(0,i.jsx)(e.p,{children:"为片元着色器传递图片数据："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);\n"})}),"\n",(0,i.jsx)(e.p,{children:"gl.texImage2D 方法是一个重载方法，其中有一些参数可以省略："}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, glsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);"}),"\n"]}),"\n",(0,i.jsxs)(e.table,{children:["\n",(0,i.jsxs)(e.thead,{children:["\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.th,{children:"参数"}),"\n",(0,i.jsx)(e.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.tbody,{children:["\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"target"}),"\n",(0,i.jsx)(e.td,{children:"纹理类型，TEXTURE_2D代表2维纹理"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"level"}),"\n",(0,i.jsx)(e.td,{children:"表示多级分辨率的纹理图像的级数，若只有一种分辨率，则 level 设为 0，通常我们使用一种分辨率"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"components"}),"\n",(0,i.jsx)(e.td,{children:"纹理通道数，通常我们使用 RGBA 和 RGB 两种通道"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"width"}),"\n",(0,i.jsx)(e.td,{children:"纹理宽度，可省略"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"height"}),"\n",(0,i.jsx)(e.td,{children:"纹理高度，可省略"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"border"}),"\n",(0,i.jsx)(e.td,{children:"边框，通常设置为0，可省略"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"format"}),"\n",(0,i.jsx)(e.td,{children:"纹理映射的格式"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"type"}),"\n",(0,i.jsx)(e.td,{children:"纹理映射的数据类型"}),"\n"]}),"\n",(0,i.jsxs)(e.tr,{children:["\n",(0,i.jsx)(e.td,{children:"pixels"}),"\n",(0,i.jsx)(e.td,{children:"纹理图像的数据"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"上面这段代码的意思是，我们将 img 变量指向的图片数据传递给片元着色器，取对应纹理坐标的 RGBA 四个通道值，赋给片元，每个通道的数据格式是无符号单字节整数。"}),"\n",(0,i.jsxs)(e.p,{children:["接下来，我们设置图片在放大或者缩小时采用的算法",(0,i.jsx)(e.code,{children:"gl.LINEAR"}),"。"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"gl.LINEAR 代表采用最靠近象素中心的四个象素的加权平均值，这种效果表现的更加平滑自然。\ngl.NEAREST 采用最靠近象素中心的纹素，该算法可能使图像走样，但是执行效率高，不需要额外的计算。"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\ngl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n"})}),"\n",(0,i.jsx)(e.p,{children:"之后为片元着色器传递 0 号纹理单元："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"gl.uniform1i(uniformTexture, 0);\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"这里，我们为片元着色器的 texture 属性传递 0，此处应该与激活纹理时的通道值保持一致。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"图片作为纹理的渲染效果如下："}),"\n",(0,i.jsx)(e.p,{children:"可以看到，我们绘制的矩形表面贴上了纹理。"}),"\n",(0,i.jsx)(e.p,{children:"您或许有疑问，为什么我只是指定了三角形的顶点对应的 UV 坐标，GPU 就能够将纹理图片的其他坐标的颜色贴到三角形表面呢？"}),"\n",(0,i.jsxs)(e.p,{children:["这其实，就回归到了",(0,i.jsx)(e.code,{children:"渲染管线"}),"这个概念上，在第一节我画了个图，大致阐述了渲染管线的工作方式，但其实在光栅化环节上有些细节没有说到。\n在光栅化阶段，GPU 处理两件事情："]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"计算图元覆盖了哪些像素。"}),"\n",(0,i.jsx)(e.li,{children:"根据顶点着色器的顶点位置计算每个像素的纹理坐标的插值。"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"注：片元可以理解为像素。"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["光栅化结束后，来到片元着色器，片元着色器此时知道每个像素对应的 ",(0,i.jsx)(e.code,{children:"UV"})," 坐标，根据当前像素的 ",(0,i.jsx)(e.code,{children:"UV"})," 坐标，找到纹理资源对应坐标的颜色信息，赋值给当前像素，从而能够为图元表面的每个像素贴上正确的纹理颜色。"]}),"\n",(0,i.jsxs)(e.h2,{id:"注意事项",children:["注意事项",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#注意事项",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"我们总结一下贴图的注意点："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"图片最好满足 2^m x 2^n 的尺寸要求。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"图片数据首先加载到内存中，才能够在纹理中使用。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"图片资源加载前要先解决跨域问题。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"回顾",children:["回顾",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"至此，我们使用 WebGL 绘制平面的课程就结束了，总结一下之前章节所学的知识点："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["GLSL：着色器","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["数据类型","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"vec2：2 维向量容器。"}),"\n",(0,i.jsx)(e.li,{children:"vec4：4 维向量容器。"}),"\n",(0,i.jsx)(e.li,{children:"运算法则：向量与向量、向量与浮点数的运算法则。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["修饰符","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"attribute：属性修饰符。"}),"\n",(0,i.jsx)(e.li,{children:"uniform：全局变量修饰符。"}),"\n",(0,i.jsx)(e.li,{children:"varying：顶点着色器传递给片元着色器的属性修饰符。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["precision：设置精度","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"highp：高精度。"}),"\n",(0,i.jsx)(e.li,{children:"mediump：中等精度。"}),"\n",(0,i.jsx)(e.li,{children:"lowp：低精度。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["内置变量","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl_Position：顶点坐标。"}),"\n",(0,i.jsx)(e.li,{children:"gl_FragColor：片元颜色。"}),"\n",(0,i.jsx)(e.li,{children:"gl_PointSize：顶点大小。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["屏幕坐标系到设备坐标系的转换。","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"屏幕坐标系左上角为原点，X 轴坐标向右为正，Y 轴坐标向下为正。"}),"\n",(0,i.jsxs)(e.li,{children:["坐标范围：","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"X轴：【0, canvas.width】"}),"\n",(0,i.jsx)(e.li,{children:"Y轴：【0, canvas.height】"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.li,{children:"设备坐标系以屏幕中心为原点，X 轴坐标向右为正，Y 轴向上为正。"}),"\n",(0,i.jsxs)(e.li,{children:["坐标范围是","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"X轴：【-1, 1】。"}),"\n",(0,i.jsx)(e.li,{children:"Y轴：【-1, 1】。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["WebGL API","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["shader：着色器对象","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.createShader：创建着色器。"}),"\n",(0,i.jsx)(e.li,{children:"gl.shaderSource：指定着色器源码。"}),"\n",(0,i.jsx)(e.li,{children:"gl.compileShader：编译着色器。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["program：着色器程序","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.createProgram：创建着色器程序。"}),"\n",(0,i.jsx)(e.li,{children:"gl.attachShader：链接着色器对象。"}),"\n",(0,i.jsx)(e.li,{children:"gl.linkProgram：链接着色器程序。"}),"\n",(0,i.jsx)(e.li,{children:"gl.useProgram：使用着色器程序。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["attribute：着色器属性","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.getAttribLocation：获取顶点着色器中的属性位置。"}),"\n",(0,i.jsx)(e.li,{children:"gl.enableVertexAttribArray：启用着色器属性。"}),"\n",(0,i.jsx)(e.li,{children:"gl.vertexAttribPointer：设置着色器属性读取 buffer 的方式。"}),"\n",(0,i.jsx)(e.li,{children:"gl.vertexAttrib2f：给着色器属性赋值，值为两个浮点数。"}),"\n",(0,i.jsx)(e.li,{children:"gl.vertexAttrib3f：给着色器属性赋值，值为三个浮点数。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["uniform：着色器全局属性","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.getUniformLocation：获取全局变量位置。"}),"\n",(0,i.jsx)(e.li,{children:"gl.uniform4f：给全局变量赋值 4 个浮点数。"}),"\n",(0,i.jsx)(e.li,{children:"gl.uniform1i：给全局变量赋值 1 个整数。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["buffer：缓冲区","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.createBuffer：创建缓冲区对象。"}),"\n",(0,i.jsx)(e.li,{children:"gl.bindBuffer：将缓冲区对象设置为当前缓冲。"}),"\n",(0,i.jsx)(e.li,{children:"gl.bufferData：向当前缓冲对象复制数据。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["clear：清屏","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.clearColor：设置清除屏幕的背景色。"}),"\n",(0,i.jsx)(e.li,{children:"gl.clear：清除屏幕。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["draw：绘制","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.drawArrays：数组绘制方式。"}),"\n",(0,i.jsx)(e.li,{children:"gl.drawElements：索引绘制方式。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["图元","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.POINTS：点。"}),"\n",(0,i.jsx)(e.li,{children:"gl.LINE：基本线段。"}),"\n",(0,i.jsx)(e.li,{children:"gl.LINE_STRIP：连续线段。"}),"\n",(0,i.jsx)(e.li,{children:"gl.LINE_LOOP：闭合线段。"}),"\n",(0,i.jsx)(e.li,{children:"gl.TRIANGLES：基本三角形。"}),"\n",(0,i.jsx)(e.li,{children:"gl.TRIANGLE_STRIP：三角带。"}),"\n",(0,i.jsx)(e.li,{children:"gl.TRIANGLE_FAN：三角扇。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["纹理","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl.createTexture：创建纹理对象。"}),"\n",(0,i.jsx)(e.li,{children:"gl.activeTexture：激活纹理单元。"}),"\n",(0,i.jsx)(e.li,{children:"gl.bindTexture：绑定纹理对象到当前纹理。"}),"\n",(0,i.jsx)(e.li,{children:"gl.texImage2D：将图片数据传递给 GPU。"}),"\n",(0,i.jsx)(e.li,{children:"gl.texParameterf：设置图片放大缩小时的过滤算法。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"以上是截止到目前所涉及的知识点，大家可以按照自己的想法做些小例子，熟练掌握它们。"}),"\n",(0,i.jsx)(e.p,{children:"接下来我们开始学习如何使用基本图元构建 3D 模型。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}let h=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F7.%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%20---%20%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE%EF%BC%9A%E4%B8%BA%E5%BD%A2%E4%BD%93%E7%A9%BF%E4%B8%8A%E5%A4%96%E8%A1%A3.md"]={toc:[{text:"目标",id:"目标",depth:2},{text:"为什么我们需要贴图？",id:"为什么我们需要贴图",depth:2},{text:"纹理图片格式",id:"纹理图片格式",depth:2},{text:"纹理坐标系统",id:"纹理坐标系统",depth:2},{text:"贴图练习",id:"贴图练习",depth:3},{text:"准备图片",id:"准备图片",depth:4},{text:"着色器",id:"着色器",depth:4},{text:"JavaScript 部分",id:"javascript-部分",depth:4},{text:"注意事项",id:"注意事项",depth:2},{text:"回顾",id:"回顾",depth:2}],title:"7.初级入门 --- 纹理贴图：为形体穿上外衣",headingTitle:"7.初级入门 --- 纹理贴图：为形体穿上外衣",frontmatter:{}}}}]);