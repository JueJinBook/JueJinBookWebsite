"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["80340"],{932969:function(e,n,r){e.exports=r.p+"static/image/11ba82886736549f9e9da0b112e524f9.9cea7520.webp"},593534:function(e,n,r){e.exports=r.p+"static/image/12f3bf48777fd5dacec56381b79dd64e.5dc1768c.webp"},785137:function(e,n,r){e.exports=r.p+"static/image/4a88f2d4939fa04bdb8ca8a50d218e13.081a5355.webp"},820064:function(e,n,r){e.exports=r.p+"static/image/73783dae1c08d11df0d52af38abe35b3.0b982da3.webp"},107194:function(e,n,r){e.exports=r.p+"static/image/73f1aac62d6fec28a0bb23e2e9191cca.43508e7c.webp"},524562:function(e,n,r){e.exports=r.p+"static/image/76ae831d9d1bf75367489726a6bff2d8.b5a47e1c.webp"},996684:function(e,n,r){e.exports=r.p+"static/image/97641a5daba0d9e5ba76ecd24ab0310e.6192c90a.webp"},618497:function(e,n,r){e.exports=r.p+"static/image/9aae602c8e7f7e30f9c09abe9bb0b25c.9803c803.webp"},410852:function(e,n,r){e.exports=r.p+"static/image/c832b74a851b629367a73fd9e9e3fd50.58ec3d4e.webp"},605727:function(e,n,r){e.exports=r.p+"static/image/e4571559e75d1a7eb5339da3a8fd0ece.8e29789c.webp"},815664:function(e,n,r){r.r(n),r.d(n,{default:()=>v});var c=r(552676),s=r(740453),o=r(932969),t=r(820064),i=r(107194),d=r(785137),l=r(996684),a=r(618497),h=r(524562),x=r(605727),p=r(410852),j=r(593534);function u(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",code:"code",p:"p",ol:"ol",li:"li",h3:"h3",h4:"h4",pre:"pre",ul:"ul",h5:"h5",strong:"strong",img:"img",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"14-系统与进程-apiosprocess中",children:["14-系统与进程 API：os、process（中）",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14-系统与进程-apiosprocess中",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"续process",children:["（续）",(0,c.jsx)(n.code,{children:"process"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#续process",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["说到做到，上一章 ",(0,c.jsx)(n.code,{children:"process"})," 还剩俩货没讲。"]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"process.env"}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"uncaughtException"}),"。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"processenv",children:[(0,c.jsx)(n.code,{children:"process.env"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#processenv",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这是很常用的内容——环境变量。首先，我能直接上结论，Node.js 的环境变量能力来自 libuv。libuv 有一系列 API 叫 ",(0,c.jsx)(n.code,{children:"uv_os_getenv()"}),"、",(0,c.jsx)(n.code,{children:"uv_os_setenv()"}),"、",(0,c.jsx)(n.code,{children:"uv_os_unsetenv()"}),"。明明系统直接有获取环境变量的 API，为什么 libuv 要自己包一层呢？因为它要跨平台。"]}),"\n",(0,c.jsxs)(n.p,{children:["在 UNIX 类的系统（包括 macOS）中，获取环境变量的 API 是 ",(0,c.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man3/getenv.3.html",title:"https://man7.org/linux/man-pages/man3/getenv.3.html",target:"_blank",rel:"noopener noreferrer",children:"getenv()"}),"；在 Windows 下，该 API 则是 ",(0,c.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentvariablew",title:"https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getenvironmentvariablew",target:"_blank",rel:"noopener noreferrer",children:"GetEnvironmentVariableW()"}),"。"]}),"\n",(0,c.jsxs)(n.h4,{id:"uv_os_getenv",children:[(0,c.jsx)(n.code,{children:"uv_os_getenv()"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#uv_os_getenv",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在 libuv 中，获取环境变量的 API 分为成功和失败两种状态。如果是因为传进来的 Buffer 长度不足以盘下对应环境变量值，则返回“长度不够”的错误。这么设计是为了 Node.js 获取的时候，可以先“快速获取”，获取失败了再用慢速模式。"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"int uv_os_getenv(const char* name, char* buffer, size_t* size) {\n  char* var;\n  size_t len;\n\n  if (name == NULL || buffer == NULL || size == NULL || *size == 0)\n    return UV_EINVAL;\n\n  var = getenv(name);\n\n  if (var == NULL)\n    return UV_ENOENT;\n\n  len = strlen(var);\n\n  if (len >= *size) {\n    *size = len + 1;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, var, len + 1);\n  *size = len;\n\n  return 0;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["很好理解，先判断各参数是否合法，即 ",(0,c.jsx)(n.code,{children:"if (name == NULL ...)"}),"，不合法则返回 ",(0,c.jsx)(n.code,{children:"UV_EINVAL"}),"。然后就是直接通过 ",(0,c.jsx)(n.code,{children:"getenv(name)"})," 获取环境变量复制给 ",(0,c.jsx)(n.code,{children:"var"}),"。如果得到的是 ",(0,c.jsx)(n.code,{children:"NULL"}),"，则说明该环境变量不存在，返回 ",(0,c.jsx)(n.code,{children:"UV_ENOENT"}),"；然后判断对应环境变量值的长度是否能被 ",(0,c.jsx)(n.code,{children:"buffer"})," 的长度吃下，不够长则返回 ",(0,c.jsx)(n.code,{children:"UV_ENOBUFS"}),"，且把应该的长度通过修改 ",(0,c.jsx)(n.code,{children:"size"})," 指针对应的值传回外面；最后，将获取的环境变量的值拷贝到 ",(0,c.jsx)(n.code,{children:"buffer"})," 中，返回 ",(0,c.jsx)(n.code,{children:"0"})," 以代表成功。"]}),"\n",(0,c.jsxs)(n.h4,{id:"processenv-获取环境变量的核心科技",children:[(0,c.jsx)(n.code,{children:"process.env"})," 获取环境变量的核心科技",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#processenv-获取环境变量的核心科技",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们看到，",(0,c.jsx)(n.code,{children:"uv_os_getenv()"})," 的返回值中分四种："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"UV_EINVAL"}),"：参数不合法；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"UV_ENOENT"}),"：没有该环境变量；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"UV_ENOBUFS"}),"：Buffer 长度不够；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"0"}),"：成功。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["前面两种错误不用解释了，第三个错误 ",(0,c.jsx)(n.code,{children:"UV_ENOBUFS"})," 在 Node.js 的获取变量中有妙用。在这里要给大家讲解一下堆内存与栈内存。"]}),"\n",(0,c.jsxs)(n.h5,{id:"堆内存与栈内存",children:["堆内存与栈内存",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#堆内存与栈内存",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在 C++ 中，堆内存和栈内存都是用来分配存储空间的。但是它们的分配和释放方式不同，因此它们的性能也有所不同。"}),"\n",(0,c.jsx)(n.p,{children:"栈内存分配和释放是由编译器自动完成的，开发者无需手动管理。栈是一段连续的内存空间，通常是在程序运行时就已经被分配好了，栈中的变量通常是以静态方式分配的，所以它们的分配和释放速度非常快，几乎是瞬间完成的。"}),"\n",(0,c.jsxs)(n.p,{children:["相比之下，堆内存需要开发者手动管理。堆内存的分配和释放需要调用相应的函数，例如 ",(0,c.jsx)(n.code,{children:"new"})," 和 ",(0,c.jsx)(n.code,{children:"delete"}),"。堆内存的分配和释放速度通常比栈内存慢，因为它们涉及到动态内存分配和释放，需要一定的时间来完成。"]}),"\n",(0,c.jsx)(n.p,{children:"另外，堆内存的分配和释放还可能会导致内存碎片问题，因为堆内存中分配的空间通常是不连续的，这可能会导致分配失败或者降低分配速度。"}),"\n",(0,c.jsx)(n.p,{children:"综上所述，在分配和释放相同大小的内存块时，栈内存的分配和释放速度通常比堆内存快。但是，在处理大量或者动态大小的数据时，堆内存的动态分配和释放能够提供更好的灵活性和效率。"}),"\n",(0,c.jsxs)(n.h5,{id:"maybestackbuffer",children:[(0,c.jsx)(n.code,{children:"MaybeStackBuffer"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#maybestackbuffer",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这是个在 Node.js 中比较基本的类，直译过来就是“可能是栈上的 Buffer”。为什么是可能呢？我们前面介绍了堆内存和栈内存。栈内存的分配和释放是自动的，且高效，但缺点是长度固定，且不宜过长；而堆内存则相反，效率没那么高，但是可变长。"}),"\n",(0,c.jsx)(n.p,{children:"它的常用用法就是，先在栈上分配小而定长的 Buffer，高效。一旦发现长度不够了，就再分配一块够长的堆内存兜底。"}),"\n",(0,c.jsxs)(n.p,{children:["给 ",(0,c.jsx)(n.code,{children:"MaybeStackBuffer"})," 几种通俗的比喻就是："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"可能没放大招的奥特曼："})," 打怪兽的时候，赤手空拳打打就好了，省体力，能打死最好；如果打不死了，彩色计时器变红了，才放个大招兜个底；"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsxs)(n.ol,{start:"2",children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"可能是主角成长路上的经验宝宝："})," 通常反派打主角的时候，都是随便叫个阿猫阿狗来打，反派 Boss 也是很忙的，先叫个低成本的人来打打，能打死主角最好了；如果被主角反杀了，才派个更高级别的人来。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsxs)(n.ol,{start:"3",children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"增程式绿牌车："})," 日常时候先开电，便宜；在高速上没电，又来不及充电的时候，增程器顶上，就是油贵了点。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["这几种比喻，加上 ",(0,c.jsx)(n.code,{children:"MaybeStackBuffer"})," 本身，都有一个共性，就是先用低成本的方案上；低成本方案行不通再用高成本方案。虽然这种做法在奥特曼和反派身上经常不奏效，但是 ",(0,c.jsx)(n.code,{children:"MaybeStackBuffer"})," 却挺管用的。"]}),"\n",(0,c.jsxs)(n.p,{children:["篇幅原因，代码就不上了，有兴趣可自行",(0,c.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.15.0/src/util.h#L368-L494",title:"https://github.com/nodejs/node/blob/v18.15.0/src/util.h#L368-L494",target:"_blank",rel:"noopener noreferrer",children:"阅读源码"}),"。这是一个 C++ 模板类，实现原理是，成员变量中有一个指定长度的数组，它就是一个栈内存，以及一个指针，该指针默认情况下为栈内存首地址。当需要变更长度时，用 ",(0,c.jsx)(n.code,{children:"realloc"})," 分配一块新长度的堆内存，赋值给指针。使用这个 ",(0,c.jsx)(n.code,{children:"Buffer"})," 的时候，只要返回指针即可。"]}),"\n",(0,c.jsxs)(n.h5,{id:"赤手空拳打不过上斯派修姆光线",children:["赤手空拳打不过，上斯派修姆光线",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#赤手空拳打不过上斯派修姆光线",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["讲了 ",(0,c.jsx)(n.code,{children:"MaybeStackBuffer"}),"，我们看看它在 ",(0,c.jsx)(n.code,{children:"process.env"})," 中究竟怎么起作用吧。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"Maybe<std::string> RealEnvStore::Get(const char* key) const {\n  Mutex::ScopedLock lock(per_process::env_var_mutex);\n\n  size_t init_sz = 256;\n  MaybeStackBuffer<char, 256> val;\n  int ret = uv_os_getenv(key, *val, &init_sz);\n\n  if (ret == UV_ENOBUFS) {\n    // Buffer is not large enough, reallocate to the updated init_sz\n    // and fetch env value again.\n    val.AllocateSufficientStorage(init_sz);\n    ret = uv_os_getenv(key, *val, &init_sz);\n  }\n\n  if (ret >= 0) {  // Env key value fetch success.\n    return Just(std::string(*val, init_sz));\n  }\n\n  return Nothing<std::string>();\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["前面的代码不重要，我们从第五行开始看。它声明了一个 ",(0,c.jsx)(n.code,{children:"MaybeStackBuffer<char, 256>"}),"，意为初始 Buffer 的栈内存大小为 ",(0,c.jsx)(n.code,{children:"256"})," 个字符。我们之前说奥特曼的赤手空拳通常不管用，但是这里的 ",(0,c.jsx)(n.code,{children:"256"})," 基本上可以满足大部分环境变量长度需求了。有了这个 Buffer 后，我们将其传入 ",(0,c.jsx)(n.code,{children:"uv_os_getenv()"})," 去获取对应环境变量的值。"]}),"\n",(0,c.jsxs)(n.p,{children:["然后第八行代码，如果取值失败且错误码为 ",(0,c.jsx)(n.code,{children:"UV_ENOBUFS"}),"，则说明刚才的赤手空拳不管用了。此时 ",(0,c.jsx)(n.code,{children:"init_sz"})," 被 ",(0,c.jsx)(n.code,{children:"uv_os_getenv()"})," 函数内部改成了真正够长的长度——比如 ",(0,c.jsx)(n.code,{children:"4000"})," 厘米。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["这个时候就需要这个 ",(0,c.jsx)(n.code,{children:"MaybeStackBuffer"})," 变量通过 ",(0,c.jsx)(n.code,{children:"AllocateSufficientStorage()"})," 来重新申请一块 ",(0,c.jsx)(n.code,{children:"4000"})," 长度的堆内存，性能稍微慢了点。内存申请好了之后，通过 ",(0,c.jsx)(n.code,{children:"uv_os_getenv()"})," 再来一遍。这里的 ",(0,c.jsx)(n.code,{children:"AllocateSufficientStorage()"})," 就相当于开始释放斯派修姆光线了。"]}),"\n",(0,c.jsx)(n.p,{children:"最后，该返回什么返回什么。"}),"\n",(0,c.jsxs)(n.h4,{id:"processenv-这个对象",children:[(0,c.jsx)(n.code,{children:"process.env"})," 这个对象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#processenv-这个对象",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["说到 ",(0,c.jsx)(n.code,{children:"process.env"}),"，不得不说 V8 里面的一个概念——拦截器（Interceptor），它会为一整个对象的任意字段访问进行拦截。V8 里面有两类拦截器："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"映射型拦截器（Named Property Interceptor）"})," ：当对于一个对象内成员的访问方式是字符串型的属性名时，映射型拦截器就会生效。举个例子，在 Chrome 浏览器中，文档中的一些访问就是映射型拦截器，如：",(0,c.jsx)(n.code,{children:"document.theFormName.elementName"}),"；"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"索引型拦截器（Inedexed Property Interceptor）"})," ：与映射型拦截器不同，索引型拦截器的访问与数组类似，通过整型下标来对内容进行访问。还是例子，在 Chrome 浏览器中，",(0,c.jsx)(n.code,{children:"document.forms.elements[0]"})," 这种形式的访问就是索引型拦截器的一种体现。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["更多关于拦截器的概念，可以阅读 ",(0,c.jsx)(n.a,{href:"https://v8.dev/docs/embed#interceptors",title:"https://v8.dev/docs/embed#interceptors",target:"_blank",rel:"noopener noreferrer",children:"V8 的文档"}),"，也可以买一本《Node.js：来一打 C++ 扩展》支持下小可怜。"]}),"\n",(0,c.jsxs)(n.p,{children:["拦截器就像是一个 JavaScript 的 ",(0,c.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",title:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",target:"_blank",rel:"noopener noreferrer",children:"Proxy"}),"。在 V8 中对一个拦截器来说，我们需要实现它的："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Getter：获取，类似 ",(0,c.jsx)(n.code,{children:"foo.bar"}),"；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Setter：设置，类似 ",(0,c.jsx)(n.code,{children:"foo.bar = baz"}),"；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"Query：得到某字段是否只读、不可删除；"}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Deleter：删除，类似 ",(0,c.jsx)(n.code,{children:"delete foo.bar"}),"；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Enumerator：迭代时得到的 ",(0,c.jsx)(n.code,{children:"key"})," 数组，类似 ",(0,c.jsx)(n.code,{children:"for...in"}),"；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Definer：定义，类似 ",(0,c.jsx)(n.code,{children:"Object.defineProperty()"}),"；"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["Descriptor：获取 descriptor，类似 ",(0,c.jsx)(n.code,{children:"Object.etOwnPropertyDescriptor()"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["后面几项是可选的。而 Node.js 的 ",(0,c.jsx)(n.code,{children:"process.env"})," 中，则实现了 1-6。举个例子，它的 Getter 是这么写的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"static void EnvGetter(Local<Name> property,\n                      const PropertyCallbackInfo<Value>& info) {\n  Environment* env = Environment::GetCurrent(info);\n  CHECK(env->has_run_bootstrapping_code());\n  if (property->IsSymbol()) {\n    return info.GetReturnValue().SetUndefined();\n  }\n  CHECK(property->IsString());\n  MaybeLocal<String> value_string =\n      env->env_vars()->Get(env->isolate(), property.As<String>());\n  if (!value_string.IsEmpty()) {\n    info.GetReturnValue().Set(value_string.ToLocalChecked());\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["前面的代码不重要，主要就是 ",(0,c.jsx)(n.code,{children:"MaybeLocal<String> value_string"})," 被赋的值。它是从 ",(0,c.jsx)(n.code,{children:"env->env_vars()->Get()"})," 赋值的，最终流转到前面讲的 ",(0,c.jsx)(n.code,{children:"RealEnvStore::Get()"}),"。所以 ",(0,c.jsx)(n.code,{children:"process.env"})," 拦截器的 Getter 做的事就是，拿到对应的 ",(0,c.jsx)(n.code,{children:"name"}),"，并通过 ",(0,c.jsx)(n.code,{children:"RealEnvStore::Get()"})," 获取对应 ",(0,c.jsx)(n.code,{children:"name"})," 的环境变量值，返回。"]}),"\n",(0,c.jsxs)(n.p,{children:["Setter 最终则是通过 ",(0,c.jsx)(n.code,{children:"uv_os_setenv()"})," 来达到 ",(0,c.jsx)(n.code,{children:"process.env.foo = bar"})," 设置环境变量的效果。Deleter 通过 ",(0,c.jsx)(n.code,{children:"uv_os_unsetenv()"})," 来达到 ",(0,c.jsx)(n.code,{children:"delete process.env.foo"})," 删除环境变量的效果；Enumerator 则是通过 ",(0,c.jsx)(n.a,{href:"https://docs.libuv.org/en/v1.x/misc.html#c.uv_os_environ",title:"https://docs.libuv.org/en/v1.x/misc.html#c.uv_os_environ",target:"_blank",rel:"noopener noreferrer",children:"uv_os_environ()"})," 获取每个环境变量的键名；Definer 则通过前面这几个函数来做一些描述符定义操作。具体代码就补贴了，有兴趣可自行阅读一下 ",(0,c.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.15.0/src/node_env_var.cc",title:"https://github.com/nodejs/node/blob/v18.15.0/src/node_env_var.cc",target:"_blank",rel:"noopener noreferrer",children:"node_env_var.cc"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后，Node.js 将这些实现好的拦截相关函数一并给到这个 ",(0,c.jsx)(n.code,{children:"process.env"})," “对象”的映射型拦截器中。"]}),"\n",(0,c.jsxs)(n.h3,{id:"uncaughtexception",children:[(0,c.jsx)(n.code,{children:"uncaughtException"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#uncaughtexception",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这是 Node.js 中很重要的两个错误处理事件。虽然我经常不大建议大家使用，但毕竟万事无绝对嘛。"}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"业界有一种“let it crash”思想，很多编程语言中，都会将其奉行为设计哲学，其源于 Erlang/Elixir。 Let it crash 是指工程师不必过分担心未知的错误，而去进行面面俱到的防御性编码。"}),"\n",(0,c.jsxs)(n.p,{children:["在未知状态下，通过这个事件捕获 ",(0,c.jsx)(n.code,{children:"uncaughtException"}),"，从而让进程继续执行，很有可能让进程跑在一个不可预估的状态中。还不如直接让它挂掉，让守护进程重启一个。"]}),"\n",(0,c.jsx)(n.p,{children:"不过这仅代表我个人观点。就跟诡秘一样，虽然刀了一点，但是受污染的超凡者只能是被毁灭，否则它处于一个失控状态，可能带来更严重的后果。——“原来,原来我已经变成了怪物……”“我们既是守护者，也是一群时刻对抗着疯狂与失控的可怜虫。”"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["> ",(0,c.jsx)("img",{src:l,alt:""})]}),"\n",(0,c.jsxs)(n.h4,{id:"v8isolateaddmessagelistenerwitherrorlevel",children:[(0,c.jsx)(n.code,{children:"v8::Isolate::AddMessageListenerWithErrorLevel()"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v8isolateaddmessagelistenerwitherrorlevel",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["虽然不建议大家在生产环境使用，但原理还是可以说一下的。这一切都源自于 V8 里 ",(0,c.jsx)(n.code,{children:"Isolate"})," 的一个方法——",(0,c.jsx)(n.code,{children:"AddMessageListenerWithErrorLevel()"}),"。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["在 Node.js v16.x 的时候，用的还是 ",(0,c.jsx)(n.code,{children:"AddMessageListener()"}),"，但作用差不多。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["我们可以通过这个函数往 ",(0,c.jsx)(n.code,{children:"Isolate"})," 中添加回调函数，用于在 JavaScript 代码中捕获和处理错误消息。Node.js 在初始化的时候，为",(0,c.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.15.0/src/api/environment.cc#L238-L241",title:"https://github.com/nodejs/node/blob/v18.15.0/src/api/environment.cc#L238-L241",target:"_blank",rel:"noopener noreferrer",children:"其添加了回调函数"}),"。而这个回调函数最终会调用一个",(0,c.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.15.0/src/node_errors.cc#L1060-L1152",title:"https://github.com/nodejs/node/blob/v18.15.0/src/node_errors.cc#L1060-L1152",target:"_blank",rel:"noopener noreferrer",children:"叫 TriggerUncaughtException() 的函数"}),"，这里就会触发对应事件了。"]}),"\n",(0,c.jsxs)(n.p,{children:["当 V8 捕获到一个没有被处理的错误时（如当前作用域下没有 ",(0,c.jsx)(n.code,{children:"try-catch"}),"），就会触发上面的 ",(0,c.jsx)(n.code,{children:"TriggerUncaughtException"})," 回调。所以这个语义上就是一个 Node.js 中的 Uncaught Exception。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"下面代码不重要，扫一眼就好。"})," 重要的是注释，放代码是为了让大家更有体感，没必要本末倒置。不放么，可能大家又会觉得太抽象。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"void TriggerUncaughtException(Isolate* isolate,\n                              Local<Value> error,\n                              Local<Message> message,\n                              bool from_promise) {\n  // 代码看不懂不重要，看注释。\n  ...\n\n  // 下面几行意思是拿到 `process._fatalException` 函数。\n  Local<Object> process_object = env->process_object();\n  Local<String> fatal_exception_string = env->fatal_exception_string();\n  Local<Value> fatal_exception_function =\n      process_object->Get(env->context(),\n                          fatal_exception_string).ToLocalChecked();\n\n  // 如果 `process._fatalException` 不是个函数，直接崩溃。\n  if (!fatal_exception_function->IsFunction()) {\n    ReportFatalException(\n        env, error, message, EnhanceFatalException::kDontEnhance);\n    env->Exit(6);\n    return;\n  }\n\n  MaybeLocal<Value> maybe_handled;\n  if (env->can_call_into_js()) {\n    // 为下面几行代码进行 `try-catch`，模式为 `kFatal`，也就是说，如果有错误被 `catch` 了，\n    // 则在 `catch` 代码块里直接崩溃。类似：\n    //\n    // ```\n    //  try {\n    //    // ...\n    //  } catch (e) {\n    //    报错;\n    //    崩溃;\n    //  }\n    errors::TryCatchScope try_catch(env,\n                                    errors::TryCatchScope::CatchMode::kFatal);\n    // 在 `try` 中执行 `process._fatalException(error, <错误是否来自 Promise>)`.\n    try_catch.SetVerbose(false);\n    Local<Value> argv[2] = { error,\n                             Boolean::New(env->isolate(), from_promise) };\n\n    maybe_handled = fatal_exception_function.As<Function>()->Call(\n        env->context(), process_object, arraysize(argv), argv);\n  }\n\n  Local<Value> handled;\n  if (!maybe_handled.ToLocal(&handled)) {\n    return;\n  }\n\n  // 如果 `process._fatalException()` 返回结果为非 `false`，则不做任何处理。\n  if (!handled->IsFalse()) {\n    return;\n  }\n\n  // 否则，报告错误，并崩溃。\n  ReportFatalException(env, error, message, EnhanceFatalException::kEnhance);\n  RunAtExit(env);\n\n  Local<String> exit_code = env->exit_code_string();\n  Local<Value> code;\n  if (process_object->Get(env->context(), exit_code).ToLocal(&code) &&\n      code->IsInt32()) {\n    env->Exit(code.As<Int32>()->Value());\n  } else {\n    env->Exit(1);\n  }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"把注释提取出来，翻译成 JavaScript 伪代码，大概就是："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"function triggerUncaughtException(error, fromPromise) {\n  const fatalExceptionFunction = process._fatalException;\n  if (typeof fatalExceptionFunction !== 'function') {\n    reportFatalException(error);\n    process.exit(6);\n  }\n\n  let handled;\n  try {\n    handled = fatalExceptionFunction(error, fromPromise);\n  } catch (e) {\n    reportFatalException(e);\n    process.exit(7);\n  }\n  \n  if (handled !== false) return;\n  \n  reportFatalException(error);\n  runAtExit();\n  process.exit(process.exitCode);\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"这里面分三种情况："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsx)(n.li,{children:"“异常”崩溃；"}),"\n",(0,c.jsx)(n.li,{children:"“正常”崩溃；"}),"\n",(0,c.jsx)(n.li,{children:"正常执行。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["其中，",(0,c.jsx)(n.code,{children:"process._fatalException"})," 被恶作剧替换成非函数了，或者 ",(0,c.jsx)(n.code,{children:"process._fatalException"})," 自身出问题了，就是“异常崩溃”；若是 ",(0,c.jsx)(n.code,{children:"process._fatalException()"})," 函数执行结果告知要崩溃，即该函数返回 ",(0,c.jsx)(n.code,{children:"false"})," 值，就是“正常崩溃”；剩下的就是正常执行了。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:"15流程图1.png"})}),"\n",(0,c.jsxs)(n.p,{children:["至于“输出异常”所对应的 ",(0,c.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.15.0/src/node_errors.cc#L319-L468",title:"https://github.com/nodejs/node/blob/v18.15.0/src/node_errors.cc#L319-L468",target:"_blank",rel:"noopener noreferrer",children:"ReportFatalException()"}),"，篇幅不够，我就不拉出来讲了。它大概得作用就是，从 V8 给的信息中把错误对象的错误对象产生的文件地址、行号、列号拿出来，并输出文件地址和错误行所在的代码，根据列号算出上箭头的位置，并输出这几行，就像这样："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"/foo/bar.js:2\n  throw new Error('123');\n  ^\n"})}),"\n",(0,c.jsx)(n.p,{children:"接着输出错误信息，就像这样："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"Error: 123\n"})}),"\n",(0,c.jsx)(n.p,{children:"最后，输出错误堆栈："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"    at Object.<anonymous> (/foo/bar.js:2:9)\n    at Module._compile (node:internal/modules/cjs/loader:1155:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1209:10)\n    at Module.load (node:internal/modules/cjs/loader:1033:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:868:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n"})}),"\n",(0,c.jsxs)(n.h4,{id:"process_fatalexception",children:[(0,c.jsx)(n.code,{children:"process._fatalException"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#process_fatalexception",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["从上一节中，我们能看到，最终处理 Uncaught Exception 的是 ",(0,c.jsx)(n.code,{children:"process._fatalException"})," 函数。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["这个函数本该是一个私有函数的，但由于早期 Node.js 版本未做充分设计和考虑，仅将其以下划线为开头命名挂在了 ",(0,c.jsx)(n.code,{children:"process"})," 下。虽然文档中未提及这个“私有变量”，但总有调皮的开发者拿它做一些 Hack 的事情。如果后续版本的 Node.js 中将它藏起来，那么，可能很多业务就没法正常跑了——考虑到向下兼容性。所以，",(0,c.jsx)(n.code,{children:"process._fatalException"})," 便一直保留下来了。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"process._fatalException"})," 是在 Node.js 的 ",(0,c.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.15.0/lib/internal/bootstrap/node.js#L315-L333",title:"https://github.com/nodejs/node/blob/v18.15.0/lib/internal/bootstrap/node.js#L315-L333",target:"_blank",rel:"noopener noreferrer",children:"Bootstrap 阶段"}),"设置的。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"process._fatalException = onGlobalUncaughtException;\n"})}),"\n",(0,c.jsxs)(n.p,{children:["而这个 ",(0,c.jsx)(n.code,{children:"onGlobalUncaughtException"})," 是被 ",(0,c.jsx)(n.code,{children:"createOnGlobalUncaughtException"})," 创建出来的。看看这里面是什么吧。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"function createOnGlobalUncaughtException() {\n  return (er, fromPromise) => {\n    ...\n\n    const type = fromPromise ? 'unhandledRejection' : 'uncaughtException';\n    ...\n    if (exceptionHandlerState.captureFn !== null) {\n      exceptionHandlerState.captureFn(er);\n    } else if (!process.emit('uncaughtException', er, type)) {\n      // If someone handled it, then great. Otherwise, die in C++ land\n      // since that means that we'll exit the process, emit the 'exit' event.\n      try {\n        if (!process._exiting) {\n          process._exiting = true;\n          process.exitCode = 1;\n          process.emit('exit', 1);\n        }\n      } catch {\n        // Nothing to be done about it at this point.\n      }\n      return false;\n    }\n\n    ...\n\n    return true;\n  };\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["看！参数对上了！第一个是 ",(0,c.jsx)(n.code,{children:"er"}),"，第二个就是 ",(0,c.jsx)(n.code,{children:"fromPromise"})," 了。这个函数里面，错误类型根据 ",(0,c.jsx)(n.code,{children:"fromPromise"})," 而定，若是从 ",(0,c.jsx)(n.code,{children:"Promise"})," 而来，则触发 ",(0,c.jsx)(n.code,{children:"unhandledRejection"}),"，否则触发 ",(0,c.jsx)(n.code,{children:"uncaughtException"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:"15流程图2.png"})}),"\n",(0,c.jsxs)(n.p,{children:["当你没有手动监听 ",(0,c.jsx)(n.code,{children:"unhandledrejection"})," 时，若触发了对应的 rejection，那么 V8 一样会触发这个函数。这个时候 ",(0,c.jsx)(n.code,{children:"fromPomise"})," 就为 ",(0,c.jsx)(n.code,{children:"true"})," 了。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"process.on('unhandledRejection', (reason, p) => {\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"  console.log('Unhandled Rejection at: Promise', p, 'reason:', reason);\n});\n\nprocess.on('uncaughtException', (err, type) => {\n  console.log('Uncaught Exception thrown');\n  console.log(err.stack, type);\n});\n\nPromise.reject(new Error('Explosion!'));\n"})}),"\n",(0,c.jsxs)(n.p,{children:["比如上面这段代码，我们执行的时候，会走到 ",(0,c.jsx)(n.code,{children:"unhandledRejection"})," 事件。但当我们删掉这三行代码，再执行的时候，Node.js 就会走进 ",(0,c.jsx)(n.code,{children:"uncaughtException"})," 事件，并且对应的 ",(0,c.jsx)(n.code,{children:"type"})," 是 ",(0,c.jsx)(n.code,{children:"unhandledRejection"}),"。至于上面三行的 ",(0,c.jsx)(n.code,{children:"unhandledRejection"})," 事件是怎么触发的，篇幅原因就不讲了，通过 V8 的 ",(0,c.jsx)(n.code,{children:"Isolate::SetPromiseRejectCallback"}),"，反正大同小异。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["然后就是判断 ",(0,c.jsx)(n.code,{children:"exceptionHandlerState.captureFn"}),"。这是会在 ",(0,c.jsx)(n.code,{children:"process.setUncaughtExceptionCaptureCallback()"})," 中被设置的内容。这个 API 不是很常用，我也是第一次看到\uD83E\uDD23。"]}),"\n",(0,c.jsxs)(n.p,{children:["总之多看",(0,c.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/process.html#processsetuncaughtexceptioncapturecallbackfn",title:"https://nodejs.org/dist/latest-v18.x/docs/api/process.html#processsetuncaughtexceptioncapturecallbackfn",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"没坏处：If such a function is set, the ",(0,c.jsx)(n.code,{children:"'uncaughtException'"})," event will not be emitted. If ",(0,c.jsx)(n.code,{children:"--abort-on-uncaught-exception"})," was passed from the command line or set through ",(0,c.jsx)(n.code,{children:"v8.setFlagsFromString()"}),", the process will not abort. Actions configured to take place on exceptions such as report generations will be affected too."]}),"\n",(0,c.jsx)(n.p,{children:"如果没有这玩意儿作祟，那就进入正题："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"if (!process.emit('uncaughtException', er, type)) {\n  try {\n    if (!process._exiting) {\n      process._exiting = true;\n      process.exitCode = 1;\n      process.emit('exit', 1);\n    }\n  } catch {\n    // Nothing to be done about it at this point.\n  }\n  return false;\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["通过 ",(0,c.jsx)(n.code,{children:"process.emit"})," 触发 ",(0,c.jsx)(n.code,{children:"uncaughtException"}),"，将 ",(0,c.jsx)(n.code,{children:"er"})," 和刚才得到的 ",(0,c.jsx)(n.code,{children:"type"})," 传进去。我们来看看，",(0,c.jsx)(n.code,{children:"EventEmitter.prototype.emit"})," 的返回值吧：Returns ",(0,c.jsx)(n.code,{children:"true"})," if the event had listeners, ",(0,c.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,c.jsxs)(n.p,{children:["也就是说，当我们有监听 ",(0,c.jsx)(n.code,{children:"uncaughtException"})," 事件时，返回 ",(0,c.jsx)(n.code,{children:"true"}),"，否则返回 ",(0,c.jsx)(n.code,{children:"false"}),"。是不是跟上一节的 ",(0,c.jsx)(n.code,{children:"handled"})," 值是否非 ",(0,c.jsx)(n.code,{children:"false"})," 对上了？如果我们有监听处理，就返回 ",(0,c.jsx)(n.code,{children:"true"}),"，则后面不做任何事了；如果我们没有监听，那么这里会返回 ",(0,c.jsx)(n.code,{children:"false"}),"，后面就会输出异常，然后“正常”崩溃。"]}),"\n",(0,c.jsxs)(n.p,{children:["这里值得一提的是，",(0,c.jsx)(n.code,{children:"process.emit()"})," 是裸执行的，并没有在这一句上进行 ",(0,c.jsx)(n.code,{children:"try-catch"}),"，也就是用户监听的回调有抛错，那么会直接反映到上层函数去。这又跟之前对上了，如果在这个函数里面有任何抛错，则直接进入“异常”崩溃逻辑。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后，",(0,c.jsx)(n.code,{children:"process._fatalException"})," 都执行完走到最后一步逻辑时，就返回 ",(0,c.jsx)(n.code,{children:"true"})," 了，说明我们正常处理了 ",(0,c.jsx)(n.code,{children:"uncaughtException"})," 事件，并且未产生新的异常。这个时候在上层函数表现就是——继续执行。"]}),"\n",(0,c.jsxs)(n.h2,{id:"本章小结",children:["本章小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章小结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["本节为大家介绍了 ",(0,c.jsx)(n.code,{children:"process.env"})," 与 ",(0,c.jsx)(n.code,{children:"uncaughtException"})," 的实现。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"process.env"})," 对象实际上是一个类似于 ",(0,c.jsx)(n.code,{children:"Proxy"})," 的劫持对象，每次获取字段时都通过 libuv 从系统中获取一遍，每次设置的时候，实际上都是通过 libuv 把为当前 Node.js 进程设置上对应环境变量。而获取环境变量值的时候，顺带着讲了一遍 ",(0,c.jsx)(n.code,{children:"MaybeStackBuffer"})," 这个精神小伙，帮大家浅浅复习了一下堆内存和栈内存。",(0,c.jsx)(n.code,{children:"MaybeStackBuffer"})," 就跟奥特曼一样，不到被打惨的时候不放射线。但有时候这种方法还真挺有效的。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"uncaughtException"})," 则是通过 V8 的 ",(0,c.jsx)(n.code,{children:"Isolate::AddMessageListenerWithErrorLevel()"})," 来做的。它将真正处理 Uncaught Exception 的函数通过 ",(0,c.jsx)(n.code,{children:"AddMessageListenerWithErrorLevel"})," 加到 V8 获得对应错误的回调中。当有相关错误触发时，自动会触发该回调，然后逐步最终调用到 ",(0,c.jsx)(n.code,{children:"process.emit('uncaughtException', ...)"})," 上。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"留一个实操题，大家可以写一个 JavaScript 文件，在里面可以："}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["把 ",(0,c.jsx)(n.code,{children:"process._fatalException"})," 赋值成任意内容，然后尝试触发一个 Uncaught Exception 看看 Node.js 的退出码是多少；"]}),"\n",(0,c.jsxs)(n.li,{children:["把 ",(0,c.jsx)(n.code,{children:"process._fatalException"})," 替换成一个抛错的函数，再尝试触发一个 Uncaught Exception 看看 Node.js 退出码是多少；"]}),"\n",(0,c.jsxs)(n.li,{children:["把 ",(0,c.jsx)(n.code,{children:"process._fatalException"})," 替换成一个恒为 ",(0,c.jsx)(n.code,{children:"true"})," 或 ",(0,c.jsx)(n.code,{children:"false"})," 的函数，看看 Node.js 行为是什么。"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["下一章在 ",(0,c.jsx)(n.code,{children:"process"})," 里，我会尝试向大家解释一下 Node.js 错误对象的堆栈样式是怎么来的，它为什么跟 Chrome 长得不大一样。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(u,{...e})}):u(e)}let v=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F14-%E7%B3%BB%E7%BB%9F%E4%B8%8E%E8%BF%9B%E7%A8%8B%20API%EF%BC%9Aos%E3%80%81process%EF%BC%88%E4%B8%AD%EF%BC%89.md"]={toc:[{text:"（续）`process`",id:"续process",depth:2},{text:"`process.env`",id:"processenv",depth:3},{text:"`uv_os_getenv()`",id:"uv_os_getenv",depth:4},{text:"`process.env` 获取环境变量的核心科技",id:"processenv-获取环境变量的核心科技",depth:4},{text:"`process.env` 这个对象",id:"processenv-这个对象",depth:4},{text:"`uncaughtException`",id:"uncaughtexception",depth:3},{text:"`v8::Isolate::AddMessageListenerWithErrorLevel()`",id:"v8isolateaddmessagelistenerwitherrorlevel",depth:4},{text:"`process._fatalException`",id:"process_fatalexception",depth:4},{text:"本章小结",id:"本章小结",depth:2}],title:"14-系统与进程 API：os、process（中）",headingTitle:"14-系统与进程 API：os、process（中）",frontmatter:{}}}}]);