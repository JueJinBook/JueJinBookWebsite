"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["83263"],{122958:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var l=r(552676),i=r(740453);let s=r.p+"static/image/d597660e3f486393545b4834f961f78b.b7e50198.webp",t=r.p+"static/image/3191a4a0fb6ea0f6e63a56a4a1c04874.822f6d20.webp",c=r.p+"static/image/4eaf41e169165ae138f71d76f47c4452.e18b5e5c.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",img:"img",ul:"ul",li:"li",h2:"h2",pre:"pre"},(0,i.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{id:"10polyfill-垫片思想在前端的应用",children:["10.Polyfill 垫片思想在前端的应用",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10polyfill-垫片思想在前端的应用",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"前面章节中，我们讲了什么是构建、为什么需要构建、然后对比了几种常见的构建工具。在构建中，很重要的一个过程就是通过语法降级来兼容低版本浏览器。在前端领域中，用来为旧浏览器提供其没有的最新原生支持的代码片段，我们将其称之为“polyfill” ，翻译过来就是“垫片”，也就是打补丁的意思。"}),"\n",(0,l.jsxs)(n.p,{children:["比如说我们想使用 ",(0,l.jsx)(n.code,{children:"fetch"})," 发请求，我们在 ",(0,l.jsx)(n.a,{href:"https://caniuse.com/?search=promise",target:"_blank",rel:"noopener noreferrer",children:"can i use 网站"})," 上查询到，很多低版本的浏览器是不支持该 API 的，所以我们就需要使用 polyfill 比如 ",(0,l.jsx)(n.code,{children:"whatwg-fetch"})," 来让这些低版本的浏览器支持该 API。",(0,l.jsx)(n.code,{children:"whatwg-fetch"})," 会首先判断浏览器是否原生支持 fetch，如果不支持，则结合 Promise 使用 ",(0,l.jsx)(n.code,{children:"XMLHttpRequest"})," 的方式来实现 fetch。"]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)("img",{src:c,alt:""})}),"\n",(0,l.jsx)(n.p,{children:"不得不说，你永远不知道用你产品的用户还在使用多么古老的浏览器，为了少数用户的体验，我们还是要支持低版本浏览器(/□＼*)，作为一个前端开发工程师，必备的一项技能就是处理兼容性问题，本篇文章就带你一起看下前端 polyfill 方案。"}),"\n",(0,l.jsx)(n.p,{children:"目前，前端 polyfill 的实现主要有以下几种方案："}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"手动打补丁"}),"\n",(0,l.jsx)(n.li,{children:"根据覆盖率动态打补丁"}),"\n",(0,l.jsx)(n.li,{children:"在线动态打补丁"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"接下来，我们就来看下这几种方法分别是怎么实现的并且分析下其优缺点。"}),"\n",(0,l.jsxs)(n.h2,{id:"手动打补丁",children:["手动打补丁",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#手动打补丁",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["最方便的解决兼容性问题，首先想到的应该是手动写一个转换函数，将新语法转换为旧语法实现降级。比如 ",(0,l.jsx)(n.code,{children:"Object.assign()"}),"，我们如果要自己写一个 ",(0,l.jsx)(n.code,{children:"Object.assign()"})," 的话，应该怎么实现呢？"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["首先需要判断原生 ",(0,l.jsx)(n.code,{children:"Object"})," 中是否存在该函数，如果不存在的话创建一个 ",(0,l.jsx)(n.code,{children:"assign"})," 函数，并使用",(0,l.jsx)(n.code,{children:"Object.defineProperty"})," 将该函数绑定到 ",(0,l.jsx)(n.code,{children:"Object"})," 上。"]}),"\n",(0,l.jsx)(n.li,{children:"然后需要对传参进行判断，处理异常情况。"}),"\n",(0,l.jsxs)(n.li,{children:["之后我们需要将传入的对象转换为 ",(0,l.jsx)(n.code,{children:"Object"})," 对象，保存并返回。"]}),"\n",(0,l.jsx)(n.li,{children:"最后我们循环遍历出上一步返回对象的所有可枚举的自有属性，并复制给新的目标对象。"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"具体代码如下："}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  // Must be writable: true, enumerable: false, configurable: true\n  Object.defineProperty(Object, \"assign\", {\n    value: function assign(target, varArgs) { // .length of function is 2\n      'use strict';\n      if (target === null || target === undefined) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource !== null && nextSource !== undefined) {\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    },\n    writable: true,\n    configurable: true\n  });\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:'上面的过程是不是让你想起来了面试时常见题型"手撕xxx代码"，确实如此。如果我们采用手动打补丁的方式，需要模拟浏览器原生语法，不只是将功能实现出来就好，我们还需要处理各种各样的边界情况和异常处理，这对开发者的编程基本功有一定的要求。'}),"\n",(0,l.jsx)(n.p,{children:"但是其优点是，直接简单，并且天然的支持“按需”使用，不会有其他冗余代码，在性能上比较友好，但是缺点就是这不是一种工程化的解决方案，不易管理和维护，且复用性低。"}),"\n",(0,l.jsxs)(n.h2,{id:"根据覆盖率自动打补丁",children:["根据覆盖率自动打补丁",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#根据覆盖率自动打补丁",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["我们都知道，",(0,l.jsx)(n.code,{children:"babel"})," 是将 ",(0,l.jsx)(n.code,{children:"ECMAScript 2015+"})," 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中的工具链。",(0,l.jsx)(n.code,{children:"@babel/preset-env"})," 会根据目标环境来进行编译和打补丁，如果想在最近 3个 浏览器版本和 安卓4.4 版本以及 iOS 9.0 以上版本运行我们的代码，那么我们可以这样配置 babel："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'...\n   presets: [\n     [\n       \'@babel/preset-env\',\n       {\n         targets: {\n           "browsers": [\n             "last 3 versions",\n             "Android >= 4.4",\n             "iOS >= 9.0"\n           ],\n         }\n       },\n     ],\n   ]\n...\n'})}),"\n",(0,l.jsx)(n.p,{children:"这样就可以实现根据我们设置的 target ，按需加载加载需要使用的插件。"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"babel-preset-env"})," 的实现原理也很简单，大致步骤如下："]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["首先需要检测浏览器对 JS 的支持程度，可以通过 ",(0,l.jsx)(n.a,{href:"https://github.com/browserslist/browserslist",target:"_blank",rel:"noopener noreferrer",children:"browserslist"}),", ",(0,l.jsx)(n.a,{href:"https://github.com/kangax/compat-table",target:"_blank",rel:"noopener noreferrer",children:"compat-table"}),", ",(0,l.jsx)(n.a,{href:"https://github.com/Kilian/electron-to-chromium",target:"_blank",rel:"noopener noreferrer",children:"electron-to-chromium"})," 这些开源项目来获取数据。"]}),"\n",(0,l.jsx)(n.li,{children:"然后利用上一步获取到的数据来维护一个 JS 特性 跟 特定的 babel插件的映射。"}),"\n",(0,l.jsx)(n.li,{children:"最后根据开发者的配置信息确定需要哪些插件。"}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["更多关于 ",(0,l.jsx)(n.code,{children:"babel"})," 的细节我会在下一章再着重给你介绍。"]}),"\n",(0,l.jsxs)(n.h2,{id:"在线动态打补丁",children:["在线动态打补丁",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在线动态打补丁",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"除了上面的两种方式之外，我们还可以“在线动态打补丁”。上面两种方式都有一个弊端是：如果该浏览器支持该特性的话，那么针对该特性的 polyfill 就不需要引入。那么如何减少这种冗余呢？在线动态打补丁就是一个方案。"}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.a,{href:"https://polyfill.io/v3/",target:"_blank",rel:"noopener noreferrer",children:"https://polyfill.io/v3/"})," 就是实现该方案的服务，其提供 CDN 资源，会根据浏览器的 UA 不同，返回不同的内容。"]}),"\n",(0,l.jsxs)(n.p,{children:["比如我们可以打开 ",(0,l.jsx)(n.a,{href:"https://polyfill.io/v3/url-builder/",target:"_blank",rel:"noopener noreferrer",children:"polyfill.io"})," 网站，比如我选择了需要 es2015 的 polyfill，就会生成一个 polyfill bundle，也会生成一个链接：",(0,l.jsx)(n.a,{href:"https://polyfill.io/v3/polyfill.min.js?features=default%2Ces2015",target:"_blank",rel:"noopener noreferrer",children:"https://polyfill.io/v3/polyfill.min.js?features=default%2Ces2015"})]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)("img",{src:t,alt:""})}),"\n",(0,l.jsx)(n.p,{children:"在我们的业务中，可以直接引入该 polyfill bundle，如果是在低版本的浏览器中，将会得到该 polyfills bundle"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:'<script src="https://polyfill.io/v3/polyfill.min.js?features=default%2Ces2015"><\/script>\n'})}),"\n",(0,l.jsxs)(n.p,{children:["我们也可以直接在现代浏览器上打开看下这个文件的内容，因为我的浏览器版本已经是挺高的了，所以直接返回了 ",(0,l.jsx)(n.code,{children:"No polyfills needed for current settings and browser"}),"。\n",(0,l.jsx)("img",{src:s,alt:""})]}),"\n",(0,l.jsx)(n.p,{children:"在线打补丁的方案的有点是在高版本浏览器的情况下，会减少冗余 polyfill 的加载。其缺点就是多引入了资源会导致额外的资源加载。"}),"\n",(0,l.jsxs)(n.h2,{id:"总结",children:["总结",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"随着前端的发展，尤其是 ECMAScript 的迅速成长以及浏览器的频繁更新换代，前端在越来越多的地方会使用都 polyfill。那么如何在工程中，侵入性更小，工程化、自动化成都更高、对业务的影响最低的使用 polyfill 呢？我们一般会在项目中使用 babel 来进行处理，我们会在下面的章节中介绍具体的使用方法。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}let h=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E5%88%9D%E6%8E%A2%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%2F10.Polyfill%20%E5%9E%AB%E7%89%87%E6%80%9D%E6%83%B3%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8.md"]={toc:[{text:"手动打补丁",id:"手动打补丁",depth:2},{text:"根据覆盖率自动打补丁",id:"根据覆盖率自动打补丁",depth:2},{text:"在线动态打补丁",id:"在线动态打补丁",depth:2},{text:"总结",id:"总结",depth:2}],title:"10.Polyfill 垫片思想在前端的应用",headingTitle:"10.Polyfill 垫片思想在前端的应用",frontmatter:{}}}}]);