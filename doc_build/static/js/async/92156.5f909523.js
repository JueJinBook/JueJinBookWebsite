"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["92156"],{778755:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var a=t(552676),i=t(740453);let r=t.p+"static/image/c7dae95047d94b912304a50d0954db5e.7b49af32.png",s=t.p+"static/image/df49e47583e74c63d8825718d2ae75b2.495a1606.png";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",pre:"pre",code:"code",h3:"h3",h4:"h4"},(0,i.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"29手写-babel-traverse----path篇",children:["29.手写 Babel： traverse -- path篇",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#29手写-babel-traverse----path篇",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"path 记录了遍历路径，并且还实现了一系列增删改的 api，会在遍历 ast 的时候传递给 visitor 的回调函数。"}),"\n",(0,a.jsx)(n.p,{children:"这节我们来实现下 path。"}),"\n",(0,a.jsxs)(n.h2,{id:"思路分析",children:["思路分析",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"path 是节点之间的关联，每一个 path 记录了当前节点和父节点，并且 path 和 path 之间也有关联。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:s,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"通过 path 我们可以找到父节点、父节点的父节点，一直到根节点。"}),"\n",(0,a.jsx)(n.p,{children:"path 的实现就是在 traverse 的时候创建一个对象来保存当前节点和父节点，并且能够拿到节点也就能对节点进行操作，可以基于节点来提供一系列增删改的 api。"}),"\n",(0,a.jsxs)(n.h2,{id:"代码实现",children:["代码实现",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"首先我们创建一个 path 的类，记录当前节点 node，父节点 parent 以及父节点的 path。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"class NodePath {\n    constructor(node, parent, parentPath) {\n        this.node = node;\n        this.parent = parent;\n        this.parentPath = parentPath;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"然后在遍历的时候创建 path 对象，传入 visitor。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function traverse(node, visitors, parent, parentPath) {\n    const defination = astDefinationsMap.get(node.type);\n\n    let visitorFuncs = visitors[node.type] || {};\n\n    if(typeof visitorFuncs === 'function') {\n        visitorFuncs = {\n            enter: visitorFuncs\n        }\n    }\n    const path = new NodePath(node, parent, parentPath);\n\n    visitorFuncs.enter && visitorFuncs.enter(path);\n\n    if (defination.visitor) {\n        defination.visitor.forEach(key => {\n            const prop = node[key];\n            if (Array.isArray(prop)) { // 如果该属性是数组\n                prop.forEach(childNode => {\n                    traverse(childNode, visitors, node, path);// 改动\n                })\n            } else {\n                traverse(prop, visitors, node, path);// 改动\n            }\n        })\n    }\n    visitorFuncs.exit && visitorFuncs.exit(path);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"之后 visitor 里面就可以拿到 path 了。"}),"\n",(0,a.jsx)(n.p,{children:"比如我们可以在 visotor 里从当前节点一直查找到根节点："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"traverse(ast, {\n    Identifier: {\n        exit(path) {\n            path.node.name = 'b';\n            let curPath = path;\n            while (curPath) {\n                console.log(curPath.node.type);\n                curPath = curPath.parentPath;\n            }\n        }\n    }\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"接下来是实现 api，path 的 api 就是对 AST 的增删改，我们实现下 replaceWith、remove、findParent、find、traverse、skip 这些 api。"}),"\n",(0,a.jsxs)(n.h3,{id:"实现-path-api",children:["实现 path api",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-path-api",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"replaceWith 就是在父节点替换当前节点为另一个节点。但是我们现在并不知道当前节点在父节点的什么属性上，所以在遍历的时候要记录属性名的信息。"}),"\n",(0,a.jsx)(n.p,{children:"这里要记录两个属性 key 和 listkey，比如如果属性是数组的话就要记录 key 是啥属性、listkey 是啥下标。"}),"\n",(0,a.jsx)(n.p,{children:"比如 params 下的 Identifier 节点，key 是 params，listkey 是 1、2、3。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"如果不是数组的话，listkey 为空。"}),"\n",(0,a.jsx)(n.p,{children:"在讲 path 的那一节，我们讲过 key 和 listkey，很多同学都不明白为什么要记录这个，现在就知道了，是为了实现对 AST 增删改的 api 用的。"}),"\n",(0,a.jsx)(n.p,{children:"我们对 traverse 的实现做下改动，传入 key 和数组下标（有改动标识的那两行）："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"module.exports = function traverse(node, visitors, parent, parentPath, key, listKey) {\n\n    const defination = visitorKeys.get(node.type);\n    let visitorFuncs = visitors[node.type] || {};\n\n    if(typeof visitorFuncs === 'function') {\n        visitorFuncs = {\n            enter: visitorFuncs\n        }\n    }\n    const path = new NodePath(node, parent, parentPath, key, listKey);\n    visitorFuncs.enter && visitorFuncs.enter(path);\n\n    if (defination.visitor) {\n        defination.visitor.forEach(key => {\n            const prop = node[key];\n            if (Array.isArray(prop)) { // 如果该属性是数组\n                prop.forEach((childNode, index) => {\n                    traverse(childNode, visitors, node, path, key, index);// 改动\n                })\n            } else {\n                traverse(prop, visitors, node, path, key);// 改动\n            }\n        })\n    }\n    visitorFuncs.exit && visitorFuncs.exit(path);\n}\n\n"})}),"\n",(0,a.jsx)(n.p,{children:"path 也要做相应的改动，加上 key 和 listkey："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"class NodePath {\n    constructor(node, parent, parentPath, key, listKey) {\n        this.node = node;\n        this.parent = parent;\n        this.parentPath = parentPath;\n        this.key = key;\n        this.listKey = listKey;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"然后基于 key 和 listkey 实现 replaceWith 的 api："}),"\n",(0,a.jsxs)(n.h4,{id:"pathreplacewith",children:["path.replaceWith",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pathreplacewith",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"replaceWith 是替换节点，如果是数组的话，就替换 key 属性的 listkey 个元素的节点，用数组的 splice 方法。"}),"\n",(0,a.jsx)(n.p,{children:"不是数组的话，那就直接替换改 key 属性对应的节点。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"replaceWith(node) {\n    if (this.listKey != undefined) {\n        this.parent[this.key].splice(this.listKey, 1, node);\n    } else {\n        this.parent[this.key] = node\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"pathremove",children:["path.remove",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pathremove",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"同理，remove 也是一样的思路："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"remove () {\n    if (this.listKey != undefined) {\n        this.parent[this.key].splice(this.listKey, 1);\n    } else {\n        this.parent[this.key] = null;\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"pathfindpathfindparent",children:["path.find、path.findParent",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pathfindpathfindparent",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"find 和 findParent 是顺着 path 链向上查找 AST，并且把节点传入回调函数，如果找到了就返回节点的 path。区别是 find 包含当前节点，findParent 不包含。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"findParent(callback) {\n    let curPath = this.parentPath;\n    while (curPath && !callback(curPath)) {\n        curPath = curPath.parentPath; \n    }\n    return curPath;\n}\nfind(callback) {\n    let curPath = this;\n    while (curPath && !callback(curPath)) {\n        curPath = curPath.parentPath; \n    }\n    return curPath;\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"pathtraverse",children:["path.traverse",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pathtraverse",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"traverse 的 api 是基于上面实现的 traverse，但是有一点不同，path.traverse 不需要再遍历当前节点，直接遍历子节点即可。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"traverse(visitors) {\n    const traverse = require('../index');\n    const defination = types.visitorKeys.get(this.node.type);\n\n    if (defination.visitor) {\n        defination.visitor.forEach(key => {\n            const prop = this.node[key];\n            if (Array.isArray(prop)) { // 如果该属性是数组\n                prop.forEach((childNode, index) => {\n                    traverse(childNode, visitors, this.node, this);\n                })\n            } else {\n                traverse(prop, visitors, this.node, this);\n            }\n        })\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"pathskip",children:["path.skip",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pathskip",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"skip 的实现可以给节点加个标记，遍历的过程中如果发现了这个标记就跳过子节点遍历。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"skip() {\n    this.node.__shouldSkip = true;\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"module.exports = function traverse(node, visitors, parent, parentPath, key, listKey) {\n\n    const defination = visitorKeys.get(node.type);\n    let visitorFuncs = visitors[node.type] || {};\n\n    if(typeof visitorFuncs === 'function') {\n        visitorFuncs = {\n            enter: visitorFuncs\n        }\n    }\n    const path = new NodePath(node, parent, parentPath, key, listKey);\n    visitorFuncs.enter && visitorFuncs.enter(path);\n\n    if(node.__shouldSkip) {\n        delete node.__shouldSkip;\n        return;\n    }\n\n    if (defination.visitor) {\n        defination.visitor.forEach(key => {\n            const prop = node[key];\n            if (Array.isArray(prop)) { // 如果该属性是数组\n                prop.forEach((childNode, index) => {\n                    traverse(childNode, visitors, node, path, key, index);\n                })\n            } else {\n                traverse(prop, visitors, node, path, key);\n            }\n        })\n    }\n    visitorFuncs.exit && visitorFuncs.exit(path);\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"pathtostring",children:["path.toString",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pathtostring",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"toString 是把当前节点打印成目标代码，会调用 generator，generator 的实现在后面的章节会讲。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"toString() {\n    return generate(this.node).code;\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"pathisxxx",children:["path.isXxx",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pathisxxx",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"我们记录了不同 ast 怎么遍历，那么也可以基于这些数据实现各种判断 AST 类型的 api："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const validations = {};\n\nfor (let name of astDefinationsMap.keys()) {\n    validations['is' + name] = function (node) {\n        return node.type === name;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"这些会抽离到 types 包里面，然后在 path 中做相应的封装，通过 bind 给方法添加一个参数。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const types = require('../../types');\n\nclass NodePath {\n    constructor(node, parent, parentPath, key, listKey) {\n        this.node = node;\n        this.parent = parent;\n        this.parentPath = parentPath;\n        this.key = key;\n        this.listKey = listKey;\n\n        Object.keys(types).forEach(key => {\n            if (key.startsWith('is')) {\n                this[key] = types[key].bind(this, node);\n            }\n        })\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"实现了这些 API 之后我们就可以在 visitor 里使用 path 的 api 来操作 ast 了。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"traverse(ast, {\n    Identifier(path) {\n        if(path.findParent(p => p.isCallExpression())) {\n            path.replaceWith({ type: 'Identifier', name: 'bbbbbbb' });\n        }\n    }\n})\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"path 的 api 就是对 AST 进行增删改，我们记录了 node（当前节点）、parent（父节点）、parentPath（父 path） 等信息，还会记录 key（父节点属性） 和 listkey（节点在数组中的下标）。基于这些就可以实现 replaceWith、remove、find、findParent、skip 等 api。"}),"\n",(0,a.jsxs)(n.p,{children:["（代码在",(0,a.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}let d=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F29.%E6%89%8B%E5%86%99%20Babel%EF%BC%9A%20traverse%20--%20path%E7%AF%87.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"实现 path api",id:"实现-path-api",depth:3},{text:"path.replaceWith",id:"pathreplacewith",depth:4},{text:"path.remove",id:"pathremove",depth:4},{text:"path.find、path.findParent",id:"pathfindpathfindparent",depth:4},{text:"path.traverse",id:"pathtraverse",depth:4},{text:"path.skip",id:"pathskip",depth:4},{text:"path.toString",id:"pathtostring",depth:4},{text:"path.isXxx",id:"pathisxxx",depth:4},{text:"总结",id:"总结",depth:2}],title:"29.手写 Babel： traverse -- path篇",headingTitle:"29.手写 Babel： traverse -- path篇",frontmatter:{}}}}]);