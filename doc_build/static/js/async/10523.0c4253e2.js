"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["10523"],{714894:function(n,e,i){i.r(e),i.d(e,{default:()=>c});var t=i(552676),r=i(740453);let s=i.p+"static/image/9d2ae54c71da56c8014add453c8e7029.770299a7.webp";function o(n){let e=Object.assign({p:"p",ul:"ul",li:"li",h3:"h3",a:"a",pre:"pre",code:"code",h2:"h2",img:"img",ol:"ol",strong:"strong",blockquote:"blockquote"},(0,r.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:"组件库会包含几十甚至上百个组件，但是应用的时候往往只使用其中的一部分。这个时候如果全部引入到项目中，就会使输出产物体积变大。按需加载的支持是组件库中必须考虑的问题。"}),"\n",(0,t.jsx)(e.p,{children:"目前组件的按需引入会分成两个方法："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"经典方法：组件单独分包 + 按需导入 + babel-plugin-component ( 自动化按需引入)；"}),"\n",(0,t.jsx)(e.li,{children:"次时代方法：ESModule + Treeshaking + 自动按需 import（unplugin-vue-components 自动化配置）。"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"分包与树摇treeshaking",children:["分包与树摇（Treeshaking）",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#分包与树摇treeshaking",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"传统的解决方案就是将组件库分包导出，比如将组件库分为 List、Button、Card，用到哪个加载哪个，简单粗暴。这样写有两个弊端："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:'需要了解软件包内部构造 例： import "ui/xxx" or import "ui/package/xxx"；'}),"\n",(0,t.jsx)(e.li,{children:"需要不断手工调整组件加载预注册。"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'// 全部导入\nconst SmartyUI = require("smarty-ui-vite")\n\n// 单独导入\nconst Button = require("smarty-ui-vite/button")\n'})}),"\n",(0,t.jsx)(e.p,{children:"好在后面有 babel-plugin-component，解决了需要了解软件包构造的问题。当然你需要按照约定规则导出软件包。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'// 转换前\nconst { Button } = require("smarty-ui-vite")\n// 转换后\nconst Button = require("smarty-ui-vite/button")\n'})}),"\n",(0,t.jsx)(e.p,{children:"随着时代的发展，esmodule 已经成为了前端开发的主流。esmodule 带来好处是静态编译，也就是说，在编译阶段就可以判断需要导入哪些包。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'// 动态引入的不可确定性\nconst m = (Math.random() > 0.5) ? require("a") : require("b")\n'})}),"\n",(0,t.jsx)(e.p,{children:"这样就给 Treeshaking 提供了可能。Treeshaking 是一种通过语法分析去除无用代码的方法。目前，Treeshaking 逐渐成为了构建工具的标配，Rollup、Vite、新版本的 Webpack 都支持了这个功能。"}),"\n",(0,t.jsx)(e.p,{children:"比如：组件库只使用了 Button。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"import { Button } from 'smarty-ui-vite'\n"})}),"\n",(0,t.jsx)(e.p,{children:"使用 ES 模块并且只引用了 Button，编译器会自动将其他组件的代码去掉。"}),"\n",(0,t.jsxs)(e.h3,{id:"自动导入黑科技",children:["自动导入黑科技",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自动导入黑科技",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"unplugin-vue-components 的 auto importing 支持。"}),"\n",(0,t.jsxs)(e.h2,{id:"用户故事userstory",children:["用户故事(UserStory)",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#用户故事userstory",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"为组件库添加按组件分包导出功能，适配按需加载需要。"}),"\n",(0,t.jsxs)(e.h2,{id:"任务分解task",children:["任务分解(Task)",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#任务分解task",children:"#"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"实现分包导出脚本；"}),"\n",(0,t.jsx)(e.li,{children:"测试按需加载。"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"实现分包导出",children:["实现分包导出",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现分包导出",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"分包导出相当于将组件库形成无数各子软件包，软件包必须满足一下要求："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"文件名即组件名；"}),"\n",(0,t.jsx)(e.li,{children:"独立的 package.json 定义，包含 esm 和 umd 的入口定义；"}),"\n",(0,t.jsx)(e.li,{children:"每个组件必须以 Vue 插件形式进行加载；"}),"\n",(0,t.jsx)(e.li,{children:"每个软件包还需要有单独的 css 导出。"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:s,alt:"img"})}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"重构代码结构"})}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"首先需要在原有代码上进行重构："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"首先将组件目录由 【button】 改为 【Button】"}),"\n"]}),"\n",(0,t.jsxs)(e.blockquote,{children:["\n",(0,t.jsx)(e.p,{children:"特别提醒：git 提交的时候注意，默认 git 修改的时候是忽略大小写的。需要修改一下 git 配置才可以提交。"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-base",children:"# 13.按需引入_ 实现组件库的按需引入功能\ngit config core.ignorecase false\n"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Button 组件入口 index.ts 默认作为插件导出。"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"重构前："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'import Button from "./Button";\nimport { App } from "vue";\n\n// 导出 Button 组件\nexport default Button\n'})}),"\n",(0,t.jsx)(e.p,{children:"重构后："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'import Button from "./Button";\nimport { App } from "vue";\n\n// 导出Button组件\nexport { Button };\n\n// 导出Vue插件\nexport default {\n \xa0install(app: App) {\n \xa0 \xa0app.component(Button.name, Button);\n  },\n};\n'})}),"\n",(0,t.jsx)(e.p,{children:"另外要注意的是，原 uno.css 是在 entry.ts 中引入的，在子组件包中将不会以 entry.ts 为入口。如果希望 uno.css 能够正常 build，需要在子组件包入口 index.ts 引入 uno.css。"}),"\n",(0,t.jsxs)(e.ol,{start:"2",children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"编写分包导出脚本"})}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"默认导出方式是通过配置 vite.config.ts 的 build 属性完成。但是在分包导出的时候需要每个组件都分别配置自己的配置文件，而且需要由程序自动读取组件文件夹，根据文件夹的名字遍历打包，还需要为每个子组件包配上一个 package.json 文件。"}),"\n",(0,t.jsx)(e.p,{children:"新建一个 scripts/build.ts 文件。"}),"\n",(0,t.jsx)(e.p,{children:"首先需要学会的是如何使用代码让 vite 打包。"}),"\n",(0,t.jsx)(e.p,{children:"导入 vite.config.ts中的配置，然后调用 vite 的 build api 打包。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'// 读取 vite 配置\nimport { config } from "../vite.config";\nimport { build, InlineConfig, defineConfig, UserConfig } from "vite";\n\n// 全量打包\nbuild(defineConfig(config as UserConfig) as InlineConfig);\n'})}),"\n",(0,t.jsx)(e.p,{children:"读取组件文件夹遍历组件库文件夹。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'const srcDir = path.resolve(__dirname, "../src/");\n \xa0fs.readdirSync(srcDir)\n \xa0  .filter((name) => {\n \xa0 \xa0 \xa0// 过滤文件只保留包含index.ts\n \xa0 \xa0 \xa0const componentDir = path.resolve(srcDir, name);\n \xa0 \xa0 \xa0const isDir = fs.lstatSync(componentDir).isDirectory();\n \xa0 \xa0 \xa0return isDir && fs.readdirSync(componentDir).includes("index.ts");\n \xa0  })\n \xa0  .forEach(async (name) => {\n \xa0 \xa0 \xa0// 文件夹遍历\n \xa0 \xa0 });\n'})}),"\n",(0,t.jsx)(e.p,{children:"为每个模块定制不同的编译规则。编译规则如下："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"导出文件夹为 dist/ <组件名>/ 例： dist/Button；"}),"\n",(0,t.jsx)(e.li,{children:"导出模块名为： index.es.js、index.umd.js；"}),"\n",(0,t.jsx)(e.li,{children:"导出模块名为： <组件名> iffe 中绑定到全局的名字。"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"  const outDir = path.resolve(config.build.outDir, name);\n  const custom = {\n    lib: {\n      entry: path.resolve(srcDir, name),\n      name, // 导出模块名\n      fileName: `index`,\n      formats: [`esm`, `umd`],\n    },\n    outDir,\n  };\n\n  Object.assign(config.build, custom);\n  await build(defineConfig(config as UserConfig) as InlineConfig);\n"})}),"\n",(0,t.jsx)(e.p,{children:"最后还需要为每个子组件包定制一个自己的 package.json。因为根据 npm 软件包规则，当你 import 子组件包的时候，会根据子包中的 package.json 文件找到对应的模块。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'// 读取\nimport Button from "smarty-ui-vite/Button"\n'})}),"\n",(0,t.jsx)(e.p,{children:"子包的 package.json。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'{\n      "name": "smarty-ui-vite/Button",\n      "main": "index.umd.js",\n      "module": "index.umd.js"\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"生成 package.json 使用模版字符串实现。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'      fs.outputFile(\n        path.resolve(outDir, `package.json`),\n        `{\n          "name": "smarty-ui-vite/${name}",\n          "main": "index.umd.js",\n          "module": "index.umd.js",\n        }`,\n        `utf-8`\n      );\n'})}),"\n",(0,t.jsx)(e.p,{children:"最后把上面的代码组合一下就可以了。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'import fs from "fs-extra";\nimport path from "path";\nimport { config } from "../vite.config";\nimport { build, InlineConfig, defineConfig, UserConfig } from "vite";\nconst buildAll = async () => {\n \xa0// const inline: InlineConfig =\n \xa0// \xa0 viteConfig;\n\n \xa0// 全量打包\n \xa0await build(defineConfig(config as UserConfig) as InlineConfig);\n \xa0// await build(defineConfig({}))\n\n \xa0const srcDir = path.resolve(__dirname, "../src/");\n \xa0fs.readdirSync(srcDir)\n \xa0  .filter((name) => {\n \xa0 \xa0 \xa0// 只要目录不要文件，且里面包含index.ts\n \xa0 \xa0 \xa0const componentDir = path.resolve(srcDir, name);\n \xa0 \xa0 \xa0const isDir = fs.lstatSync(componentDir).isDirectory();\n \xa0 \xa0 \xa0return isDir && fs.readdirSync(componentDir).includes("index.ts");\n \xa0  })\n \xa0  .forEach(async (name) => {\n \xa0 \xa0 \xa0const outDir = path.resolve(config.build.outDir, name);\n \xa0 \xa0 \xa0const custom = {\n \xa0 \xa0 \xa0 \xa0lib: {\n \xa0 \xa0 \xa0 \xa0 \xa0entry: path.resolve(srcDir, name),\n \xa0 \xa0 \xa0 \xa0 \xa0name, // 导出模块名\n \xa0 \xa0 \xa0 \xa0 \xa0fileName: `index`,\n \xa0 \xa0 \xa0 \xa0 \xa0formats: [`es`, `umd`],\n \xa0 \xa0 \xa0  },\n \xa0 \xa0 \xa0 \xa0outDir,\n \xa0 \xa0  };\n\n \xa0 \xa0 \xa0Object.assign(config.build, custom);\n \xa0 \xa0 \xa0await build(defineConfig(config as UserConfig) as InlineConfig);\n\n \xa0 \xa0 \xa0fs.outputFile(\n \xa0 \xa0 \xa0 \xa0path.resolve(outDir, `package.json`),\n \xa0 \xa0 \xa0 \xa0`{\n \xa0 \xa0 \xa0 \xa0 \xa0"name": "smarty-ui-vite/${name}",\n \xa0 \xa0 \xa0 \xa0 \xa0"main": "index.umd.js",\n \xa0 \xa0 \xa0 \xa0 \xa0"module": "index.umd.js",\n \xa0 \xa0 \xa0 \xa0}`,\n \xa0 \xa0 \xa0 \xa0`utf-8`\n \xa0 \xa0  );\n \xa0  });\n};\n\nbuildAll();\n'})}),"\n",(0,t.jsx)(e.p,{children:"由于脚本是使用typescript编写的所以需要使用 esno 运行。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"pnpm i esno -D\n"})}),"\n",(0,t.jsx)(e.p,{children:"在package.json中添加脚本"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-json",children:'  "scripts": {\n    "build": "pnpm build:components",\n    "build:all": "vite build",\n    "build:components": "esno ./scripts/build.ts",\n    }\n'})}),"\n",(0,t.jsx)(e.p,{children:"运行代码"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"pnpm build\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"测试按需加载",children:["测试按需加载",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#测试按需加载",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"假设页面中只使用 Button 按钮，那么只调用Button子包中的 js、css 就可以了。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:'<h1>Demo IFFE OnDemand</h1>\n<div id="app"></div>\n<link rel="stylesheet" href="../../dist/style.css">\n<script src="../../node_modules/vue/dist/vue.global.js"><\/script>\n<script src="../../dist/button/index.iife.js"><\/script>\n<script>\n \xa0  const { createApp } = Vue\n \xa0  console.log(\'vue\', Vue)\n \xa0  console.log(\'SmartyUI\', Button)\n \xa0  createApp({\n \xa0 \xa0 \xa0  template: `\n \xa0 \xa0 \xa0  <div style="margin-bottom:20px;">\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="blue">主要按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="green">绿色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="gray">灰色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="yellow">黄色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="red">红色按钮</SButton>\n \xa0 \xa0 \xa0  </div>\n \xa0 \xa0 \xa0  <div style="margin-bottom:20px;"\n \xa0 \xa0 \xa0  >\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="blue" plain>朴素按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="green" plain>绿色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="gray" plain>灰色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="yellow" plain>黄色按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="red" plain>红色按钮</SButton>\n \xa0 \xa0 \xa0  </div>\n \xa0 \xa0 \xa0  <div style="margin-bottom:20px;">\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton size="small" plain>小按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton size="medium" plain>中按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton size="large" plain>大按钮</SButton>\n \xa0 \xa0 \xa0  </div>\n \xa0 \xa0 \xa0  <div style="margin-bottom:20px;">\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="blue" round plain icon="search">搜索按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="green" round plain icon="edit">编辑按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="gray" round plain icon="check">成功按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="yellow" round plain icon="message">提示按钮</SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="red" round plain icon="delete">删除按钮</SButton>\n \xa0 \xa0 \xa0  </div>\n \xa0 \xa0 \xa0  <div style="margin-bottom:20px;">\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="blue" round plain icon="search"></SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="green" round plain icon="edit"></SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="gray" round plain icon="check"></SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="yellow" round plain icon="message"></SButton>\n \xa0 \xa0 \xa0 \xa0 \xa0  <SButton color="red" round plain icon="delete"></SButton>\n \xa0 \xa0 \xa0  </div>\n \xa0 \xa0`\n \xa0  })\n \xa0 \xa0 \xa0  .use(Button.default)\n \xa0 \xa0 \xa0  .mount(\'#app\')\n\n<\/script>\n'})}),"\n",(0,t.jsxs)(e.h2,{id:"复盘",children:["复盘",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#复盘",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"这节课的主要内容是为组件库添加分包导出功能，使组件库提供按需加载。组件库具备良好的按需加载能力，可以使提高页面性能。虽然目前 ESM Treeshaking 已经非常流行，但是还是有很多场合需要分包按需引入的支持。"}),"\n",(0,t.jsx)(e.p,{children:"另外，分包引入需要每个子组件包都分别使用不同的配置调用 vite 导出。这需要编写相对较为复杂的脚本完成。工程化中很重要的一部分就是要根据实际需求编写自动化的脚本。"}),"\n",(0,t.jsx)(e.p,{children:"这节课已进行了一个简单的实践，在编写的时候特别要注意配置的复用性。比如：子包与主包是在一个一个配置文件下做的不同的配置，这个然叔都是动了一番脑筋才实现的。"}),"\n",(0,t.jsx)(e.p,{children:"最后留一些思考题帮助大家复习，也欢迎在留言区讨论。"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"组件如何才能实现按需引入？"}),"\n",(0,t.jsx)(e.li,{children:"如何实现组件分包导出？"}),"\n",(0,t.jsx)(e.li,{children:"如何批量生成 package.json 文件？"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"下节课，我们将给大家讲解如何将开发文档发布上线，下节课见。"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(o,{...n})}):o(n)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Vite%20%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E6%88%98%2F13.%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5_%20%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E5%8A%9F%E8%83%BD.md"]={toc:[{text:"分包与树摇（Treeshaking）",id:"分包与树摇treeshaking",depth:3},{text:"自动导入黑科技",id:"自动导入黑科技",depth:3},{text:"用户故事(UserStory)",id:"用户故事userstory",depth:2},{text:"任务分解(Task)",id:"任务分解task",depth:2},{text:"实现分包导出",id:"实现分包导出",depth:3},{text:"测试按需加载",id:"测试按需加载",depth:3},{text:"复盘",id:"复盘",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);