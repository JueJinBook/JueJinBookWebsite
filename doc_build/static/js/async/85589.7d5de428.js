"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["85589"],{565416:function(e,n,c){c.r(n),c.d(n,{default:()=>t});var r=c(552676),l=c(740453);let s=c.p+"static/image/934b8b2ba77e141d150541e42cc49209.20bb0570.webp",a=c.p+"static/image/7bdd9bfe1247499c05305f43d079d1ec.459adace.webp",d=c.p+"static/image/a6488cfac8a7411af1f831ad8ce750ba.e0105069.webp",i=c.p+"static/image/5a092b72bcdea406b4ba4a146ee33fb4.6a6e4249.webp",h=c.p+"static/image/9ef8837e397988397b6f28984fd7f646.b4b0ca60.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",img:"img",code:"code",pre:"pre",ul:"ul",li:"li",ol:"ol"},(0,l.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"13如何使用-webpack-持久化缓存大幅提升构建性能",children:["13.如何使用 Webpack 持久化缓存大幅提升构建性能？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13如何使用-webpack-持久化缓存大幅提升构建性能",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"缓存是一种应用非常广泛性能优化技术，在计算机领域几乎无处不在，例如：操作系统层面 CPU 高速缓存、磁盘缓存，网路世界中的 DNS 缓存、HTTP 缓存，以及业务应用中的数据库缓存、分布式缓存等等。"}),"\n",(0,r.jsxs)(n.p,{children:["那自然而然的，我们也可以在 Webpack 使用各式各样的缓存技术，通过牺牲空间来提升构建过程的时间效率，在这篇文章中，我将从 Webpack5 的 ",(0,r.jsx)(n.strong,{children:"持久化缓存"})," 开始介绍用法、性能收益、基本原理；之后再过渡到 Webpack4 中如何借助第三方组件(Loader、Plugin)实现持久化缓存。"]}),"\n",(0,r.jsxs)(n.h2,{id:"webpack5-中的持久化缓存",children:["Webpack5 中的持久化缓存",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack5-中的持久化缓存",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/cache/#cache",target:"_blank",rel:"noopener noreferrer",children:"持久化缓存"})," 算得上是 Webpack 5 最令人振奋的特性之一，它能够将首次构建的过程与结果数据持久化保存到本地文件系统，在下次执行构建时跳过解析、链接、编译等一系列非常消耗性能的操作，直接复用上次的 Module/ModuleGraph/Chunk 对象数据，迅速构建出最终产物。"]}),"\n",(0,r.jsx)(n.p,{children:"持久化缓存的性能提升效果非常出众！以 Three.js 为例，该项目包含 362 份 JS 文件，合计约 3w 行代码，算得上中大型项目："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["配置 ",(0,r.jsx)(n.code,{children:"babel-loader"}),"、",(0,r.jsx)(n.code,{children:"eslint-loader"})," 后，在我机器上测试，未使用 ",(0,r.jsx)(n.code,{children:"cache"})," 特性时构建耗时大约在 11000ms 到 18000ms 之间；启动 ",(0,r.jsx)(n.code,{children:"cache"})," 功能后，第二次构建耗时降低到 500ms 到 800ms 之间，两者相差接近 ",(0,r.jsx)(n.strong,{children:"50"})," 倍！"]}),"\n",(0,r.jsxs)(n.p,{children:["而这接近 50 倍的性能提升，仅仅需要在 Webpack5 中设置 ",(0,r.jsx)(n.code,{children:"cache.type = 'filesystem'"})," 即可开启："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"module.exports = {\n    //...\n    cache: {\n        type: 'filesystem'\n    },\n    //...\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"执行效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["此外，",(0,r.jsx)(n.code,{children:"cache"})," 还提供了若干用于配置缓存效果、缓存周期的配置项，包括："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cache.type"}),"：缓存类型，支持 ",(0,r.jsx)(n.code,{children:"'memory' | 'filesystem'"}),"，需要设置为 ",(0,r.jsx)(n.code,{children:"filesystem"})," 才能开启持久缓存；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cache.cacheDirectory"}),"：缓存文件路径，默认为 ",(0,r.jsx)(n.code,{children:"node_modules/.cache/webpack"})," ；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cache.buildDependencies"}),"：额外的依赖文件，当这些文件内容发生变化时，缓存会完全失效而执行完整的编译构建，通常可设置为各种配置文件，如："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = {\n  cache: {\n    type: 'filesystem',\n    buildDependencies: {\n      config: [\n        path.join(__dirname, 'webpack.dll_config.js'),\n        path.join(__dirname, '.babelrc')\n      ],\n    },\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cache.managedPaths"}),"：受控目录，Webpack 构建时会跳过新旧代码哈希值与时间戳的对比，直接使用缓存副本，默认值为 ",(0,r.jsx)(n.code,{children:"['./node_modules']"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cache.profile"}),"：是否输出缓存处理过程的详细日志，默认为 ",(0,r.jsx)(n.code,{children:"false"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cache.maxAge"}),"：缓存失效时间，默认值为 ",(0,r.jsx)(n.code,{children:"5184000000"})," 。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["使用时通常关注上述配置项即可，其它如 ",(0,r.jsx)(n.code,{children:"idleTimeout"}),"、",(0,r.jsx)(n.code,{children:"idleTimeoutAfterLargeChanges"})," 等项均与 Webpack 内部实现算法有关，与缓存效果关系不大，此处不展开介绍。"]}),"\n",(0,r.jsxs)(n.h2,{id:"缓存原理",children:["缓存原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存原理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"那么，为什么开启持久化缓存之后，构建性能会有如此巨大的提升呢？"}),"\n",(0,r.jsx)(n.p,{children:"一言蔽之，Webpack5 会将首次构建出的 Module、Chunk、ModuleGraph 等对象序列化后保存到硬盘中，后面再运行的时候，就可以跳过许多耗时的编译动作，直接复用缓存数据。"}),"\n",(0,r.jsx)(n.p,{children:"回过头来看看 Webpack 的构建过程，大致上可划分为三个阶段。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"初始化，主要是根据配置信息设置内置的各类插件。"}),"\n",(0,r.jsxs)(n.li,{children:["Make - 构建阶段，从 ",(0,r.jsx)(n.code,{children:"entry"})," 模块开始，执行：","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"读入文件内容；"}),"\n",(0,r.jsx)(n.li,{children:"调用 Loader 转译文件内容；"}),"\n",(0,r.jsxs)(n.li,{children:["调用 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/acorn",target:"_blank",rel:"noopener noreferrer",children:"acorn"})," 生成 AST 结构；"]}),"\n",(0,r.jsx)(n.li,{children:"分析 AST，确定模块依赖列表；"}),"\n",(0,r.jsx)(n.li,{children:"遍历模块依赖列表，对每一个依赖模块重新执行上述流程，直到生成完整的模块依赖图 —— ModuleGraph 对象。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Seal - 生成阶段，过程：","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["遍历模块依赖图，对每一个模块执行：","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["代码转译，如 ",(0,r.jsx)(n.code,{children:"import"})," 转换为 ",(0,r.jsx)(n.code,{children:"require"})," 调用；"]}),"\n",(0,r.jsx)(n.li,{children:"分析运行时依赖。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"合并模块代码与运行时代码，生成 chunk；"}),"\n",(0,r.jsx)(n.li,{children:"执行产物优化操作，如 Tree-shaking；"}),"\n",(0,r.jsx)(n.li,{children:"将最终结果写出到产物文件。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["过程中存在许多 CPU 密集型操作，例如调用 Loader 链加载文件时，遇到 babel-loader、eslint-loader、ts-loader 等工具时可能需要重复生成 AST；分析模块依赖时则需要遍历 AST，执行大量运算；Seal 阶段也同样存在大量 AST 遍历，以及代码转换、优化操作，等等。假设业务项目中有 1000 个文件，则每次执行 ",(0,r.jsx)(n.code,{children:"npx webpack"})," 命令时，都需要从 0 开始执行 1000 次构建、生成逻辑。"]}),"\n",(0,r.jsx)(n.p,{children:"而 Webpack5 的持久化缓存功能则将构建结果保存到文件系统中，在下次编译时对比每一个文件的内容哈希或时间戳，未发生变化的文件跳过编译操作，直接使用缓存副本，减少重复计算；发生变更的模块则重新执行编译流程。缓存执行时机如下图："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"如图，Webpack 在首次构建完毕后将 Module、Chunk、ModuleGraph 三类对象的状态序列化并记录到缓存文件中；在下次构建开始时，尝试读入并恢复这些对象的状态，从而跳过执行 Loader 链、解析 AST、解析依赖等耗时操作，提升编译性能。"}),"\n",(0,r.jsxs)(n.h2,{id:"webpack4使用-cache-loader",children:["Webpack4：使用 ",(0,r.jsx)(n.code,{children:"cache-loader"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack4使用-cache-loader",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Webpack5 的持久化缓存用法简单，效果出众，但可惜在 Webpack4 及之前版本原生还没有相关实现，只能借助一些第三方组件实现类似效果，包括："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["使用 ",(0,r.jsx)(n.code,{children:"[cache-loader](https://www.npmjs.com/package/cache-loader)"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["使用 ",(0,r.jsx)(n.code,{children:"[hard-source-webpack-plugin](https://github.com/mzgoddard/hard-source-webpack-plugin)"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["使用 Loader（如 ",(0,r.jsx)(n.code,{children:"babel-loader"}),"、",(0,r.jsx)(n.code,{children:"eslint-loader"}),")）自带的缓存能力。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["先从 ",(0,r.jsx)(n.code,{children:"cache-loader"})," 说起，",(0,r.jsx)(n.code,{children:"cache-loader"})," 能够将 Loader 处理结果保存到硬盘，下次运行时若文件内容没有发生变化则直接返回缓存结果，用法："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"安装依赖："}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-Bash",children:"yarn add -D cache\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["修改配置，注意必须将 ",(0,r.jsx)(n.code,{children:"cache-loader"})," 放在 ",(0,r.jsx)(n.code,{children:"loader"})," 数组首位，例如："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = {\n    // ...\n    module: {\n        rules: [{\n            test: /\\.js$/,\n            use: ['cache-loader', 'babel-loader', 'eslint-loader']\n        }]\n    },\n    // ...\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"cache-loader"})," 只缓存了 Loader 执行结果，缓存范围与精度不如 Webpack5 内置的缓存功能，所以性能效果相对较低，以 ThreeJS 为例，",(0,r.jsx)(n.code,{children:"production"})," 模式下构建耗时从 10602ms 降低到 1540ms；",(0,r.jsx)(n.code,{children:"development"})," 模式从 11130ms 降低到 4247ms，多次测试性能提升稳定在 60% ~ 80% 之间。虽然比不上 Webpack5 的持久化缓存，但在 Webpack4 中不失为一种简单而有效的性能优化手段。"]}),"\n",(0,r.jsxs)(n.p,{children:["此外，",(0,r.jsx)(n.code,{children:"cache-loader"})," 还提供了一系列控制缓存逻辑的配置属性，特别是 ",(0,r.jsx)(n.code,{children:"read/write"})," 可以用于改变缓存数据的持久化逻辑，借助这两个属性我们甚至能够实现多台机器间的缓存共享："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:'const redis = require("redis");\nconst client = redis.createClient();\n\n// 读数据\nasync function read(key, callback) {\n  // ...\n  const result = await client.get(key);\n  const data = JSON.parse(result);\n  callback(null, data);\n}\n\n// 写数据\nasync function write(key, data, callback) {\n  // ...\n  await client.set(key, JSON.stringify(data));\n  callback();\n}\n\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: "cache-loader",\n            // 传入 read、write 函数\n            options: { read, write },\n          },\n          "babel-loader",\n        ],\n      },\n    ],\n  },\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"借助这种能力，我们可以打通本地与线上 CI/CD 环境，实现开发与生产环境构建的构建性能优化。"}),"\n",(0,r.jsxs)(n.h2,{id:"webpack4使用-hard-source-webpack-plugin",children:["Webpack4：使用 ",(0,r.jsx)(n.code,{children:"hard-source-webpack-plugin"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack4使用-hard-source-webpack-plugin",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/mzgoddard/hard-source-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"hard-source-webpack-plugin"})," 也是一种实现缓存功能的第三方组件，与 ",(0,r.jsx)(n.code,{children:"cache-loader"})," 不同的是，它并不仅仅缓存了 Loader 运行结果，还保存了 Webpack 构建过程中许多中间数据，包括：模块、模块关系、模块 Resolve 结果、Chunks、Assets 等，效果几乎与 Webpack5 自带的 Cache 对齐。用法："]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"安装依赖："}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-Bash",children:"yarn add -D hard-source-webpack-plugin\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"添加配置："}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:'const HardSourceWebpackPlugin = require("hard-source-webpack-plugin");\n\nmodule.exports = {\n  // ...\n  plugins: [\n    new HardSourceWebpackPlugin(),\n  ],\n};\n'})}),"\n",(0,r.jsxs)(n.p,{children:["首次运行时，",(0,r.jsx)(n.code,{children:"hard-source-webpack-plugin"})," 会在缓存文件夹 ",(0,r.jsx)(n.code,{children:"node_module/.cache"})," 写入一系列日志文件："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["下次运行时，",(0,r.jsx)(n.code,{children:"hard-source-webpack-plugin"})," 插件会复用缓存中记录的数据，跳过一系列构建步骤，从而提升构建性能。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"hard-source-webpack-plugin"})," 插件的底层逻辑与 Webpack5 的持久化缓存很相似，但优化效果稍微差一些，以 ThreeJS 为例，",(0,r.jsx)(n.code,{children:"production"})," 模式下构建耗时从 10602ms 降低到 1740ms；",(0,r.jsx)(n.code,{children:"development"})," 模式构建从 11130ms 降低到 3280ms，多次测试性能提升稳定在 62% ~ 88% 之间。"]}),"\n",(0,r.jsxs)(n.h2,{id:"使用组件自带的缓存功能",children:["使用组件自带的缓存功能",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用组件自带的缓存功能",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["除了上面介绍的持久化缓存、",(0,r.jsx)(n.code,{children:"cache-loader"}),"、",(0,r.jsx)(n.code,{children:"hard-source-webpack-plugin"})," 方案外，我们还可以使用 Webpack 组件自带的缓存能力提升特定领域的编译性能，这一类组件有："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/babel-loader",target:"_blank",rel:"noopener noreferrer",children:"babel-loader"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/eslint-loader",target:"_blank",rel:"noopener noreferrer",children:"eslint-loader"}),"：旧版本 ESLint Webpack 组件，官方推荐使用 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/eslint-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"eslint-webpack-plugin"})," 代替；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/eslint-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"eslint-webpack-plugin"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/stylelint-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"stylelint-webpack-plugin"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["例如使用 ",(0,r.jsx)(n.code,{children:"babel-loader"})," 时，只需设置 ",(0,r.jsx)(n.code,{children:"cacheDirectory = true"})," 即可开启缓存功能，例如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"module.exports = {\n    // ...\n    module: {\n        rules: [{\n            test: /\\.m?js$/,\n            loader: 'babel-loader',\n            options: {\n                cacheDirectory: true,\n            },\n        }]\n    },\n    // ...\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"以 Three.js 为例，开启缓存后生产环境构建耗时从 3500ms 降低到 1600ms；开发环境构建从 6400ms 降低到 4500ms，性能提升约 30% ~ 50% 。"}),"\n",(0,r.jsxs)(n.p,{children:["默认情况下，缓存内容会被保存到 ",(0,r.jsx)(n.code,{children:"node_modules/.cache/babel-loader"})," 目录，你也可以通过 ",(0,r.jsx)(n.code,{children:"cacheDirectory = 'dir'"})," 属性设置缓存路径。"]}),"\n",(0,r.jsxs)(n.p,{children:["此外，ESLint 与 Stylelint 这一类耗时较长的 Lint 工具也贴心地提供了相应的缓存能力，只需设置 ",(0,r.jsx)(n.code,{children:"cache = true"})," 即可开启，如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-JavaScript",children:"// webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ESLintPlugin({ cache: true }),\n    new StylelintPlugin({ files: '**/*.css', cache: true }),\n  ],\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"依然以 Three.js 为例，开启 ESLint 缓存后生产环境构建耗时从 6400ms 降低到 1400ms；开发环境构建从 7000ms 降低到 2100ms，性能提升达到 70% ~ 80%。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Webpack5 持久化缓存用法简单，且优化效果非常出色，确实是一个特别让人振奋的新功能，甚至特定情况下能够让构建性能达到 Unbundle 方案的量级，妥妥的 Webpack 性能优化利器！"}),"\n",(0,r.jsx)(n.p,{children:"而在 Webpack4 中，我们还可以借助下述组件实现缓存优化："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"cache-loader"}),"：针对 Loader 运行结果的通用缓存方案；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"hard-source-webpack-plugin"}),"：针对 Webpack 全生命周期的通用缓存方案；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"babel-loader"}),"：针对 Babel 工具的专用缓存能力；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"eslint-loader"}),"/",(0,r.jsx)(n.code,{children:"eslint-webpack-plugin"}),"：针对 ESLint 的专用缓存方案；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"stylelint-webpack-plugin"}),"：针对 StyleLint 的专用缓存方案。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"这些方案各有特色，但都无可置疑地能有效提升编译性能，建议你在尝试做性能优化时优先选用。"}),"\n",(0,r.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"除“缓存”外，计算机领域中还有哪些常见、可被复用的性能优化方案？与缓存相比，它们都有怎么样的特色，优缺点？"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}let t=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F13.%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20Webpack%20%E6%8C%81%E4%B9%85%E5%8C%96%E7%BC%93%E5%AD%98%E5%A4%A7%E5%B9%85%E6%8F%90%E5%8D%87%E6%9E%84%E5%BB%BA%E6%80%A7%E8%83%BD%EF%BC%9F.md"]={toc:[{text:"Webpack5 中的持久化缓存",id:"webpack5-中的持久化缓存",depth:2},{text:"缓存原理",id:"缓存原理",depth:2},{text:"Webpack4：使用 `cache-loader`",id:"webpack4使用-cache-loader",depth:2},{text:"Webpack4：使用 `hard-source-webpack-plugin`",id:"webpack4使用-hard-source-webpack-plugin",depth:2},{text:"使用组件自带的缓存功能",id:"使用组件自带的缓存功能",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"13.如何使用 Webpack 持久化缓存大幅提升构建性能？",headingTitle:"13.如何使用 Webpack 持久化缓存大幅提升构建性能？",frontmatter:{}}}}]);