"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["9742"],{201128:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var r=t(552676),s=t(740453);let o=t.p+"static/image/10-4.6ffb6dec.png",a=t.p+"static/image/10-3.30881435.png",i=t.p+"static/image/10-2.3d09a643.png",c=t.p+"static/image/10-1.ee000331.png";function l(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",pre:"pre",code:"code",p:"p",img:"img"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"",children:(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,r.jsxs)(n.h1,{id:"10案例九-实现-n-个-api-网页爬虫-node-的-http-处理---请求与响应",children:["10案例九： [实现 N 个 API 网页爬虫] Node 的 HTTP 处理 - 请求与响应",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10案例九-实现-n-个-api-网页爬虫-node-的-http-处理---请求与响应",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-!",children:"本节目标：[各种手段请求爬取网页内容] 你请求，我应答，网络两头乐开花，Node 之所以成为服务器方案，离不开 HTTP 模块的能力之帆。\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在 Node 里面，起一个 HTTP Server 非常简单，如官网示例："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 加载 http 模块\nconst http = require('http')\n// 定义服务运行的主机名和端口号\nconst hostname = '127.0.0.1'\nconst port = 3000\n\n// 通过 http.createServer 方法创建一个服务实例\n// 同时传入回调函数，以接管后面进来的请求\n// 后面请求进来时，这个回调函数会被调用执行，同时会拿到两个参数，分别是 req 和 res\n// req 是可读流（通过 data 事件接收数据），res 是可写流（通过 write 写数据，end 结束输出）\nconst server = http.createServer((req, res) => {\n  // 设置返回的状态码 200 表示成功\n  res.statusCode = 200\n  // 设置返回的请求头类型 text/plain 表示普通文本\n  res.setHeader('Content-Type', 'text/plain')\n  // 对响应写入内容后，关闭可写流\n  res.end('Hello World\\n')\n})\n// 调用实例的 listen 方法把服务正式启动\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`)\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"HTTP 作为整个互联网数据通信中几乎最主流的协议，它本身就是巨大的知识库，无论是工作 1 年还是 10 年的工程师，每一次重温 HTTP 的整体知识相信都会有很多收获，从 HTTP/1.1 到 HTTP/2，从 HTTP 到 HTTPS，从 TCP 的握手到 cookie/session 的状态保持...，我们在接触和 HTTP 的时候，一开始很容易被吓唬到，扎进去学习的时候也确实枯燥乏味，比较好的办法，就是在工作中不断的使用它，不断的练习，随着使用中的一点点深入，我们会对 HTTP 越来越熟悉。"}),"\n",(0,r.jsx)(n.p,{children:"那么这一节，我们就挑 HTTP 模块在 Node 中的几个应用知识来学习，以代码练习为主，主要学习 HTTP 模块在 Node 中的使用。"}),"\n",(0,r.jsxs)(n.h3,{id:"简单的-http-头常识",children:["简单的 HTTP 头常识",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简单的-http-头常识",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"一个请求，通常会建立在两个角色之间，一个是客户端，一个是服务端，而且两者的身份可以互换的，比如一台服务器 A 向 服务器 B 发请求，那么 A 就是客户端，B 是服务端，反过来身份就变了，甚至如果 A 这台服务器自己向自己发一个请求，那么 A 里面发请求的程序就是客户端，响应请求的程序就是服务端了，所以大家可以打开思路，不用局限在端的形态上面。"}),"\n",(0,r.jsx)(n.p,{children:"我们简单的看下一个请求从浏览器发出，以及服务器返回，它们的头信息，我们去实现爬虫的时候，有时候需要构造假的请求头，或者解析响应头，这在特定场景下会有一定的参考作用，比如打开掘金的首页，我们针对这个网页 HTML 的 GET 请求，简单学习它里面的头信息知识："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// 请求由 A 请求行、B 请求头组成\n// A 请求行由 3 端组成，HTTP Verb/URL Path/HTTP Version\n// 1. 标明请求方法是 GET，往往用作获取资源（图片、视频、文档等等）\n// 2. /timeline 是请求的资源路径，由服务器来决定如何响应该地址\n// 3. HTTP 协议版本是 1.1\nGET /timeline HTTP/1.1\n// B 如下都是请求头\n// 去往哪个域名（服务器）去获取资源\nHost: juejin.im\n// 保持连接，避免连接重新建立，减少通信开销提高效率\nConnection: keep-alive\n// HTTP 1.0 时代产物，no-cache 禁用缓存\nPragma: no-cache\n// HTTP 1.1 时代产物，与 Pragma 一样控制缓存行为\nCache-Control: no-cache\n// 浏览器自动升级请求，告诉服务器后续会使用 HTTPS 协议请求\nUpgrade-Insecure-Requests: 1\n// 上报用户代理的版本信息\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36\n// 声明接收哪种格式的数据内容\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\n// 声明所接受编码压缩的格式\nAccept-Encoding: gzip, deflate, br\n// 声明所接受的地区语言\nAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7\n// 捎带过去用户之前访问时候存储在客户端的 Cookie 信息，方便服务器识别记录\nCookie: gr_user_id=1fa5e8a7b7c90; _ga=GA1.2.787252639.1488193773; ab={}; _gat=1; gr_session_id_89669d96c88aefbc_a009fcc=true\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"当然还有 POST，HEAD, PUT, DELETE 等这些请求方法，他们甚至可以多传一些数据包，比如 POST 会多一个请求体，我们继续看下上面的这个请求头给到服务端，服务器返回的头是如何的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// 整体上， response header 跟 request header 格式都是类似的\n// 响应由 3 部分组成，A 响应行； B 响应头；C 响应体\n// A 响应行依然是 HTTP 协议与响应状态码，200 是响应成功\nHTTP/1.1 200 OK\n// 响应的服务器类型\nServer: nginx\n// 当前响应的时间\nDate: Wed, 21 Nov 2018 05:45:21 GMT\n// 返回的数据类型，字符编码集\nContent-Type: text/html; charset=utf-8\n// 数据传输模式\nTransfer-Encoding: chunked\n// 保持连接\nConnection: keep-alive\n// HTTP 协议的内容协商，比如如何响应缓存\nVary: Accept-Encoding\n// 内容安全策略，检测和削弱恶意共计，学问很深\nContent-Security-Policy: default-src * blob: data:;script-src 'self' 'unsafe-eval' *.xitu.io *.juejin.im *.baidu.com *.google-analytics.com *.meiqia.com dn-growing.qbox.me *.growingio.com *.guard.qcloud.com *.gtimg.com;style-src 'self' 'unsafe-inline' *.xitu.io *.juejin.im  *.growingio.com *.guard.qcloud.com *.gtimg.com;\n// 设置各种 Cookie 以及何时失效，这些 cookie 会存储在发出请求的客户端本地\nSet-Cookie: ab={}; path=/; expires=Thu, 21 Nov 2019 05:45:21 GMT; secure; httponly\nSet-Cookie: auth=eyJ0b2tlbiI6...; path=/; expires=Wed, 28 Nov 2018 05:45:21 GMT; secure; httponly\nSet-Cookie: QINGCLOUDELB=165e4274d60907...; path=/; HttpOnly\n// 控制该网页在浏览器的 frame 中展示，如果是 DENY 则同域名页面中也不允许嵌套\nX-Frame-Options: SAMEORIGIN\n// 控制预检请求的结果缓存时长\nAccess-Control-Max-Age: 86400\n// 在规定时间内，网站请求都会重定向走 HTTPS 协议，也属于安全策略\nStrict-Transport-Security: max-age=31536000\n// 编码压缩格式的约定，gzip 是一种比较节省资源的压缩格式\nContent-Encoding: gzip\n// 告诉所有的缓存机制是否可以缓存及哪种类型\nCache-control: private\n// 服务器输出的标识，不同服务器不同，可以从服务器上关闭不输出\nX-Powered-By-Defense:  from pon-wyxm-tel-qs-qssec-kd55\n"})}),"\n",(0,r.jsx)(n.p,{children:"关于头还有很多的知识大家可以自行学习，具体场景中我们甚至会定义自己特定业务域的请求头和响应头，我们继续回到 Node 的 HTTP 模块中。"}),"\n",(0,r.jsxs)(n.h3,{id:"向别的服务器请求数据---httpget",children:["向别的服务器请求数据 - http.get",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#向别的服务器请求数据---httpget",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们在 Node 里面，向另外一台服务器发请求，这个请求可能是域名/IP，请求的内容也可能五花八门，那这个请求该怎么构造呢？"}),"\n",(0,r.jsxs)(n.p,{children:["这时候可以使用简单 http.get/https.get 方法，比如我们去请求一个 ",(0,r.jsx)(n.a,{href:"https://nodejs.org/dist/index.json",target:"_blank",rel:"noopener noreferrer",children:"Node LTS JSON 文件"}),"，从浏览器里直接打开就可以自动下载，在 Node 里面就可以这样做："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 加载 https 模块，https 的底层依然是 http\nconst https = require('https')\n// 请求的目标资源\nconst url = 'https://nodejs.org/dist/index.json'\n// 发起 GET 请求，回调函数中会拿到一个来自服务器的响应可读流 res\nhttps.get(url, (res) => {\n  // 声明一个 字符串\n  let data = ''\n  // 每次可读流数据搬运过来，都是一个 buffer 数据块，每次通过 data 事件触发\n  res.on('data', (chunk) => {\n    // 把所有的 buffer 都拼一起\n    data += chunk\n  })\n  res.on('end', () => {\n    // 等待可读流接收完毕，就拿到了完整的 buffer\n    // 通过 toString 把 buffer 转成字符串打印出来\n    console.log(data.toString())\n  })\n}).on('error', (e) => {\n  console.log(e)\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"会拿到这样的一坨 JSON 字符串："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'[{"version":"v11.2.0","date":"2018-11-15","files":..},...]\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"通过-promise-包装一个-httpget-请求",children:["通过 Promise 包装一个 http.get 请求",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#通过-promise-包装一个-httpget-请求",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面的这个请求，比较简单也比较硬，是通过回调和事件的形式来完成数据的接收，一旦有多个存在依赖关系的异步请求，就会写着难受一点，如果想让这个代码更友好一些，我们可以这样做："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const https = require('https')\nconst url = 'https://nodejs.org/dist/index.json'\n\n// 声明一个普通函数，它接收 url 参数，执行后返回一个 Promise 实例\nconst request = (url) => {\n  return new Promise((resolve, reject) => {\n    https.get(url, (res) => {\n      let data = ''\n      res.on('data', (chunk) => {\n        data += chunk\n      })\n      res.on('end', () => {\n        // 通过 Promise 的 resolve 来回调结果\n        resolve(data.toString())\n      })\n    }).on('error', (e) => {\n      reject(e)\n    })\n  })\n}\n// 在执行时候，可以使用 .then() 方法来链式调用，避免回调嵌套\nrequest(url)\n  .then(data => {\n    console.log(data)\n  })\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"通过-async-function-来替代请求的链式传递",children:["通过 async function 来替代请求的链式传递",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#通过-async-function-来替代请求的链式传递",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面有了 Promise 的封装后，我们可以直接用 async function 继续完善下这个 Promise，进一步避免 then 的回调包裹，比如改成这样子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const https = require('https')\nconst url = 'https://nodejs.org/dist/index.json'\n\n// 改成一个 async 异步函数\nconst request = async (url) => {\n  return new Promise((resolve, reject) => {\n    https.get(url, (res) => {\n      let data = ''\n      res.on('data', (chunk) => {\n        data += chunk\n      })\n      res.on('end', () => {\n        resolve(data.toString())\n      })\n    }).on('error', (e) => {\n      reject(e)\n    })\n  })\n}\n\n// 声明一个异步函数，await 和 async 要配对使用\nasync function run () {\n  // 以同步的方式来写异步逻辑\n  const data = await request(url)\n  console.log(data)\n}\n\n// run 方法执行后本身也是一个 Promise，可以通过 then 链式调用\nrun()\n"})}),"\n",(0,r.jsx)(n.p,{children:"写法稍微改了一下，整个调用链就清晰了很多，而且 async function 的执行性能也要比 Promise 好的。"}),"\n",(0,r.jsxs)(n.h3,{id:"通过三方库-axiosrequest-来替代-httpget",children:["通过三方库 axios/request 来替代 http.get",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#通过三方库-axiosrequest-来替代-httpget",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"以上都是用原生的 API 来直接实现，优点是不依赖三方库，拿到的响应就是天然的 Stream 流，那么一点点不方便的地方是，它回调中的响应 res 是 http.ClientRequest 流对象，需要自己监听 data 事件来手动组装 bufer 块，甚至还需要自己解析 JSON 数据格式，处理解析异常等，另外还不能原生支持 Promise，需要自己包装。在实际的工作场景中，我们为了开发效率，会考虑不深入这么底层的细节，直接采用三方库，比如 request/axios 等，我们通过 request 来实现一下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// 首先 npm i request\nconst request = require('request')\nconst url = 'https://nodejs.org/dist/index.json'\n\n// 直接通过 request 提供的 get 方法发起请求，从回调函数中拿到结果\nrequest.get(url, (error, response, body) => {\n  const json = JSON.parse(body)\n  console.log(body)\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["request 库可以让整个请求变得更简单，只不过它只支持回调形式，不支持 Promise，会有一点不方便，当然也可以用基于它封装的其他三方库，比如 ",(0,r.jsx)(n.a,{href:"https://github.com/request/request-promise",target:"_blank",rel:"noopener noreferrer",children:"request-promise"})," 来实现 Promise，或者 ",(0,r.jsx)(n.a,{href:"https://github.com/request/request-promise-native",target:"_blank",rel:"noopener noreferrer",children:"request-promise-native"})," 这样的原生 Promise，我们同样可以选择另外一个也有流行的库 - ",(0,r.jsx)(n.a,{href:"https://github.com/axios/axios",target:"_blank",rel:"noopener noreferrer",children:"axios"}),"，这个库的优点是浏览器和 Node 服务端都可以通用，另外也不需要关心 JSON 化的处理，它向下依赖的包也很少，同时支持 Promise："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"const axios = require('axios')\nconst url = 'https://nodejs.org/dist/index.json'\n\nconst run = async url => {\n  try {\n    const res = await axios.get(url)\n    console.log(res.data)\n  } catch (error) {}\n}\n\nrun(url)\n"})}),"\n",(0,r.jsx)(n.p,{children:"拿到的结果是一个 JSON 化后的数据格式，更加易用友好，简单了解下 API 和三方库，我们来做一些稍微复杂点的练习，比如爬取网页源码。"}),"\n",(0,r.jsxs)(n.h3,{id:"结合-httpget-和-cheerio-来爬取分析网页源码",children:["结合 http.get 和 cheerio 来爬取分析网页源码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结合-httpget-和-cheerio-来爬取分析网页源码",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["请求一个网页就是获取一个远程 HTML 文件内容，跟上面我们获取 JSON 没有本质区别，拿到网页源码后，可以通过 cheerio 来加载源码遍历 DOM 节点，选择目标的 HTML 元素，从而获得期望的内容，比如文本或者链接，我们拿 ",(0,r.jsx)(n.a,{href:"https://nodejs.org/en/get-involved/code-and-learn/",target:"_blank",rel:"noopener noreferrer",children:"Node 的 Code + Learn"})," 页面为例，分析页面的 DOM 节点，左侧的菜单都是 aside 元素里的 li，每个 li 是一个 a 标签，我们只需要获取 a 标签就行了，这个通过 cheerio 可以很轻松的做到："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们拿到源码后，可以从 DOM 中拿到左侧的菜单内容，那么代码可以这样写："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const https = require('https')\nconst $ = require('cheerio')\nconst url = 'https://nodejs.org/en/get-involved/code-and-learn/'\n\n// 这里可以借助 request 三方库实现\nconst request = async (url) => {\n  return new Promise((resolve, reject) => {\n    https.get(url, (res) => {\n      let html = ''\n      res.on('data', (chunk) => {\n        html += chunk\n      })\n      res.on('end', () => {\n        resolve(html.toString())\n      })\n    }).on('error', (e) => {\n      reject(e)\n    })\n  })\n}\n\nasync function run () {\n  // 拿到网页源码内容\n  const html = await request(url)\n  // 遍历查找出目标元素节点\n  const items = $('aside a', html)\n  const menus = []\n  // 遍历节点对象，调用 text 方法取出文本内容\n  items.each(function() {\n    menus.push($(this).text())\n  })\n  console.log(menus)\n}\n\nrun()\n"})}),"\n",(0,r.jsx)(n.p,{children:"打印结果应该就是一个数组了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[ 'Get Involved',\n  'Code + Learn',\n  'Collab Summit',\n  'Contribute',\n  'Code of Conduct' ]\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"编程练习-1---实现-node-api-对比工具",children:["编程练习 1 - 实现 Node API 对比工具",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编程练习-1---实现-node-api-对比工具",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"有了上面的准备工作，我们可以挑战下难一点的任务，Node 版本之间有差异这个我们是知道的，即便是对于同一个模块的同一个 API，也会随着版本而发生变化，甚至有的 API 是逐渐废弃掉不再使用，我们实现一个爬虫，来指定某些 Node 版本，爬取它们里面会逐步废弃的 API 都有哪些，先来看下效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"代码我们可以这样实现："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const https = require('https')\nconst Table = require('cli-table')\nconst cheerio = require('cheerio')\nconst link = (v, p) => `https://nodejs.org/dist/${v}/docs/api/${p}`\n\nasync function crawlPage (version, path = '') {\n  const url = link(version, path) \n  return new Promise(function(resolve, reject) {\n    https.get(url, (res) => {\n      let buffer = ''\n\n      res.on('data', (chunk) => {\n        buffer += chunk\n      })\n      res.on('end', () => {\n        resolve(buffer.toString())\n      })\n    }).on('error', function(e) {\n      reject(e)\n    })\n  })\n}\n\nfunction findApiList (html) {\n  const $ = cheerio.load(html)\n  const items = $('#column2 ul').eq(1).find('a')\n  const list = []\n\n  items.each(function(item) {\n    list.push({\n      api: $(this).text(),\n      path: $(this).attr('href')\n    })\n  })\n\n  return list\n}\n\nfunction findDeprecatedList (html) {\n  const $ = cheerio.load(html)\n  const items = $('.stability_0')\n  const list = []\n\n  items.each(function(item) {\n    list.push($(this).text().slice(0, 30))\n  })\n\n  return list\n}\n\nasync function crawlNode (version) {\n  const homePage = await crawlPage(version)\n  const apiList = findApiList(homePage)\n  let deprecatedMap = {\n    // 'Command Line Options': ['']\n  }\n  const promises = apiList.map(async item => {\n    const apiPage = await crawlPage(version, item.path)\n    const list = findDeprecatedList(apiPage)\n\n    return { api: item.api, list: list }\n  })\n\n  const deprecatedList = await Promise.all(promises)\n\n  deprecatedList.forEach(item => {\n    deprecatedMap[item.api] = item.list\n  })\n\n  return deprecatedMap\n}\n\nasync function runTask (v1, v2, v3, v4) {\n  const results = await Promise.all([\n    crawlNode(v1),\n    crawlNode(v2),\n    crawlNode(v3),\n    crawlNode(v4)\n  ])\n\n  const table = new Table({\n    head: ['API Version', v1, v2, v3, v4]\n  })\n  const v1Map = results[0]\n  const v2Map = results[1]\n  const v3Map = results[2]\n  const v4Map = results[3]\n  const keys = Object.keys(v4Map)\n\n  keys.forEach(key => {\n    if ((v1Map[key] && v1Map[key].length)\n      || (v2Map[key] && v2Map[key].length)\n      || (v3Map[key] && v3Map[key].length)\n      || (v4Map[key] && v4Map[key].length)) {\n      table.push([\n        key,\n        (v1Map[key] || []).join('\\n'),\n        (v2Map[key] || []).join('\\n'),\n        (v3Map[key] || []).join('\\n'),\n        (v4Map[key] || []).join('\\n')\n      ])\n    }\n  })\n\n  console.log(table.toString())\n}\n\nrunTask('v4.9.1', 'v6.14.4', 'v8.11.4', 'v10.13.0')\n"})}),"\n",(0,r.jsx)(n.p,{children:"给大家布置个作业，可以把代码再升级一下，看如何一次性拿到所有的 Node LTS 版本，同时把它们的 API 废弃清单都打印出来。"}),"\n",(0,r.jsxs)(n.h3,{id:"借助-puppeteer-来爬取有状态或者异步数据页面",children:["借助 puppeteer 来爬取有状态或者异步数据页面",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#借助-puppeteer-来爬取有状态或者异步数据页面",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"有了上面的训练，我们知道了一些信心，只要我想要爬取的内容，都可以写一个工具快速拿过来分析，然而有时候会事与愿违，有的目标网站会有异步的内容，甚至会有反爬策略，我们甚至拿不到正确的 HTML 源码，甚至更高级的策略中，我们即便拿到正确的 HTML，却未必能正确解析出来，比如用雪碧图错位来表示数字等等，这个要具体问题具体分析，我们打开掘金的小册页面，试下爬取这个页面内容，然后统计下一共现在上架了多少本册子，线上销售额有多少，掘金小册开创了知识分享的一种新形势，在技术圈非常流行，通过爬取这些数据，我们应该能更感同身受，大家也可以多帮掘金来宣传小册子，帮助掘金团队和平台越做越好。"}),"\n",(0,r.jsx)(n.p,{children:"那我们可以写这样一段代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// juejin-book.js\n// 在 node juejin-book.js 执行代码之前\n// 先 npm i cheerio request-promise 安装依赖模块\nconst $ = require('cheerio')\nconst rp = require('request-promise')\nconst url = 'https://juejin.im/books'\n\n// 通过 request-promise 来爬取网页\nrp(url)\n  .then(function(html) {\n    // 利用 cheerio 来分析网页内容，拿到所有小册子的描述\n    const books = $('.info', html)\n    let totalSold = 0\n    let totalSale = 0\n    let totalBooks = books.length\n    // 遍历册子节点，分别统计它的购买人数，和销售额总和\n    books.each(function() {\n      const book = $(this\xa0)\n      const price = $(book.find('.price-text')).text().replace('￥', '')\n      const count = book.find('.message').last().find('span').text().split('人')[0]\n      totalSale += Number(price) * Number(count)\n      totalSold += Number(count)\n    })\n\n    // 最后打印出来\n    console.log(\n      `共 ${totalBooks} 本小册子`, \n      `共 ${totalSold} 人次购买`,\n      `约 ${Math.round(totalSale / 10000)} 万`\n    )\n  })\n"})}),"\n",(0,r.jsxs)(n.p,{children:["最后打印的结果是：",(0,r.jsx)(n.code,{children:"共 0 本小册子  共 0 人次购买  约 0 万"}),"，What? 小册子怎么可能数据都是 0 呢，一定是我爬的姿势不对，我们是可以通过分析请求头和响应头来模拟一次真实的网页访问，我们也可以通过网页爬取神器 - puppeteer 来获取网页内容，puppeteer 是谷歌开源的，可以通过命令行来启动一个 chrome 实例，从而真实访问网页，并且具备与网页的交互的能力，包括不限于点击，滚动，截屏等操作。"]}),"\n",(0,r.jsx)(n.p,{children:"我们来写一个小例子，来截取下掘金的首页头部，在执行之前，首先安装 puppeteer："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i puppeteer -S\n> puppeteer@1.10.0 install /Users/black/Downloads/node_modules/puppeteer\n> node install.js\nDownloading Chromium r599821 - 82.9 Mb [                    ] 1% 1287.3s\n# 安装可能会比较耗时，大家可以多尝试几次\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 把之前安装到 node_modules 下的 puppeteer 模块加载进来\nconst puppeteer = require('puppeteer')\n\n// 在 getHomePage 函数里面，定制一系列任务，让他们顺序执行\nasync function getHomePage (link) {\n  // 启动一个 Chrome 引擎实例，加上 await 会一直等待它启动完成\n  // 加上 headless: false 会打开一个浏览器，可以眼睁睁看这一切发生，如果是 true 则静默执行\n  // const browser = await puppeteer.launch({headless: false})\n  const browser = await puppeteer.launch()\n  // 启动成功后，打开一个新页面\n  const page = await browser.newPage()\n  // 新页面里面输入目标网址，跳到这个网页，一直等待页面加载完成\n  await page.goto(link)\n  // 设置网页视窗的宽高\n  await page.setViewport({width: 1080, height: 250})\n  // 告诉 puppeteer 开始截图，直到截图完成，存储图片到当前目录\n  await page.screenshot({path: Date.now() + '.png'})\n  // 最后关闭浏览器，销毁所有变量\n  await browser.close()\n\n  return 'done!'\n}\n\n// 调用这个异步函数 getHomePage，传入待截图网站，任务开始执行\ngetHomePage('https://juejin.im/books').then(v => {})\n"})}),"\n",(0,r.jsx)(n.p,{children:"会得到这样的一个截图："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"编程练习-2---实现掘金小册的统计工具",children:["编程练习 2 - 实现掘金小册的统计工具",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编程练习-2---实现掘金小册的统计工具",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"了解 puppeteer 后，我们就可以借助它来获取小册子页面内容了，代码可以这样写："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const $ = require('cheerio')\nconst puppeteer = require('puppeteer')\nconst url = 'https://juejin.im/books'\n\nasync function run () {\n  const browser = await puppeteer.launch()\n  const page = await browser.newPage()\n  await page.goto(url, {waitUntil: 'networkidle2'})\n  const html = await page.content()\n  const books = $('.info', html)\n  let totalSold = 0\n  let totalSale = 0\n  let totalBooks = books.length\n  books.each(function() {\n    const book = $(this)\n    const price = $(book.find('.price-text')).text().replace('￥', '')\n    const count = book.find('.message').last().find('span').text().split('人')[0]\n    totalSale += Number(price) * Number(count)\n    totalSold += Number(count)\n  })\n\n  console.log(\n    `共 ${totalBooks} 本小册子`, \n    `共 ${totalSold} 人次购买`,\n    `约 ${Math.round(totalSale / 10000)} 万`\n  )\n\n  await browser.close()\n}\n\nrun()\n"})}),"\n",(0,r.jsxs)(n.p,{children:["打印的结果是：",(0,r.jsx)(n.code,{children:"共 20 本小册子 共 60800 人次购买 约 101 万"}),"，哇！截止 11 月下旬，小册的总销量已经破 100 万了，恭喜掘金，恭喜各位开发者，同时我们也期待掘金继续加油，销售额早日破千万，早日把知识传递给更多更多的开发者。"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}let d=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F10%E6%A1%88%E4%BE%8B%E4%B9%9D%EF%BC%9A%20%5B%E5%AE%9E%E7%8E%B0%20N%20%E4%B8%AA%20API%20%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%5D%20Node%20%E7%9A%84%20HTTP%20%E5%A4%84%E7%90%86%20-%20%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94.md"]={toc:[{text:"",id:"",depth:3},{text:"简单的 HTTP 头常识",id:"简单的-http-头常识",depth:3},{text:"向别的服务器请求数据 - http.get",id:"向别的服务器请求数据---httpget",depth:3},{text:"通过 Promise 包装一个 http.get 请求",id:"通过-promise-包装一个-httpget-请求",depth:3},{text:"通过 async function 来替代请求的链式传递",id:"通过-async-function-来替代请求的链式传递",depth:3},{text:"通过三方库 axios/request 来替代 http.get",id:"通过三方库-axiosrequest-来替代-httpget",depth:3},{text:"结合 http.get 和 cheerio 来爬取分析网页源码",id:"结合-httpget-和-cheerio-来爬取分析网页源码",depth:3},{text:"编程练习 1 - 实现 Node API 对比工具",id:"编程练习-1---实现-node-api-对比工具",depth:3},{text:"借助 puppeteer 来爬取有状态或者异步数据页面",id:"借助-puppeteer-来爬取有状态或者异步数据页面",depth:3},{text:"编程练习 2 - 实现掘金小册的统计工具",id:"编程练习-2---实现掘金小册的统计工具",depth:3}],title:"10案例九： [实现 N 个 API 网页爬虫] Node 的 HTTP 处理 - 请求与响应",headingTitle:"10案例九： [实现 N 个 API 网页爬虫] Node 的 HTTP 处理 - 请求与响应",frontmatter:{}}}}]);