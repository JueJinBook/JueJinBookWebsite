"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["67875"],{275956:function(n,e,i){n.exports=i.p+"static/image/66aca542bd1bcafed12b6517093fb8e8.879bf77c.webp"},364458:function(n,e,i){i.r(e),i.d(e,{default:()=>m});var s=i(552676),r=i(740453);let l=i.p+"static/image/bb2e161e3743f49b5dc8197b4d6fa972.831d08a4.webp",d=i.p+"static/image/dc48c0b585ddee625b8824e06bd646f9.b38a0e6a.webp",c=i.p+"static/image/53a0e99d745d0138cdddb4f81286f74e.347b30e3.webp",o=i.p+"static/image/a72d66286ab3dcfdbce966433ec2a7f3.09edb8ca.webp",t=i.p+"static/image/d314aa21a59dd9d8197c30cc7536007d.15fb2cb8.webp",a=i.p+"static/image/739d988aa0aac312a2aec97132df4e5d.c91aa6d7.webp",h=i.p+"static/image/c4bf2a88fe353085cf341e65b0e10a70.2c4e1d02.webp",x=i.p+"static/image/caceb10f0a98f5683df5432825a92621.9c0c0fcc.webp",p=i.p+"static/image/72e9bc35e280d033fa76994a5dbc92a9.cd8fd011.webp";var u=i(275956);function g(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",code:"code",h2:"h2",pre:"pre",blockquote:"blockquote",h3:"h3",img:"img",ul:"ul",li:"li",h4:"h4",ol:"ol"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"12插件开发与实战_-如何开发一个完整的-vite-插件",children:["12.插件开发与实战_ 如何开发一个完整的 Vite 插件？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12插件开发与实战_-如何开发一个完整的-vite-插件",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["前面的几个小节，我们从 Vite 双引擎的角度了解了 Vite 的整体架构，也系统学了双引擎本身的基础知识。从本小节开始，我们正式学习 ",(0,s.jsx)(e.strong,{children:"Vite 高级应用"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["这一模块中，我们将深入应用 Vite 的各项高级能力，遇到更多有挑战的开发场景。你不仅能学会一系列有难度的",(0,s.jsx)(e.strong,{children:"解决方案"}),"，直接运用到实际项目中，还能系统提高自己的",(0,s.jsx)(e.strong,{children:"知识深度"}),"，体会复杂项目场景中构建工具如何提供高度自定义的能力，以及如何对项目进行性能优化。"]}),"\n",(0,s.jsxs)(e.p,{children:["说到自定义的能力，你肯定很容易想到",(0,s.jsx)(e.code,{children:"插件机制"}),"，利用一个个插件来扩展构建工具自身的能力。没错，这一节中我们将系统学习 Vite 的插件机制，带你掌握 Vite 插件开发的基本知识以及实战开发技巧。"]}),"\n",(0,s.jsxs)(e.p,{children:["虽然 Vite 的插件机制是基于 Rollup 来设计的，并且上一小节我们也已经对 Rollup 的插件机制进行了详细的解读，但实际上 Vite 的插件机制也包含了自己独有的一部分，与 Rollup 的各个插件 Hook 并非完全兼容，因此本节我们将重点关注 Vite 独有的部分以及和 Rollup 所区别的部分，而对于 Vite 和 Rollup 中相同的 Hook (如",(0,s.jsx)(e.code,{children:"resolveId"}),"、",(0,s.jsx)(e.code,{children:"load"}),"、",(0,s.jsx)(e.code,{children:"transform"}),")只是稍微提及，就不再展开赘述了。"]}),"\n",(0,s.jsx)(e.p,{children:"让我们先从一个简单的例子入手吧！"}),"\n",(0,s.jsxs)(e.h2,{id:"一个简单的插件示例",children:["一个简单的插件示例",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一个简单的插件示例",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["Vite 插件与 Rollup 插件结构类似，为一个",(0,s.jsx)(e.code,{children:"name"}),"和各种插件 Hook 的对象:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"{\n  // 插件名称\n  name: 'vite-plugin-xxx',\n  load(code) {\n    // 钩子逻辑\n  },\n}\n"})}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["如果插件是一个 npm 包，在",(0,s.jsx)(e.code,{children:"package.json"}),"中的包命名也推荐以",(0,s.jsx)(e.code,{children:"vite-plugin"}),"开头"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["一般情况下因为要考虑到外部传参，我们不会直接写一个对象，而是实现一个返回插件对象的",(0,s.jsx)(e.code,{children:"工厂函数"}),"，如下代码所示:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// myPlugin.js\nexport function myVitePlugin(options) {\n  console.log(options)\n  return {\n    name: 'vite-plugin-xxx',\n    load(id) {\n      // 在钩子逻辑中可以通过闭包访问外部的 options 传参\n    }\n  }\n}\n\n// 使用方式\n// vite.config.ts\nimport { myVitePlugin } from './myVitePlugin';\nexport default {\n  plugins: [myVitePlugin({ /* 给插件传参 */ })]\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"插件-hook-介绍",children:["插件 Hook 介绍",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#插件-hook-介绍",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"1-通用-hook",children:["1. 通用 Hook",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-通用-hook",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在",(0,s.jsx)(e.a,{href:"https://juejin.cn/book/7050063811973218341/section/7060398408430780431",target:"_blank",rel:"noopener noreferrer",children:"双引擎架构"}),"这一节中介绍过，Vite ",(0,s.jsx)(e.strong,{children:"开发阶段"}),"会模拟 Rollup 的行为:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"其中 Vite 会调用一系列与 Rollup 兼容的钩子，这个钩子主要分为三个阶段:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"服务器启动阶段"}),": ",(0,s.jsx)(e.code,{children:"options"}),"和",(0,s.jsx)(e.code,{children:"buildStart"}),"钩子会在服务启动时被调用。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"请求响应阶段"}),": 当浏览器发起请求时，Vite 内部依次调用",(0,s.jsx)(e.code,{children:"resolveId"}),"、",(0,s.jsx)(e.code,{children:"load"}),"和",(0,s.jsx)(e.code,{children:"transform"}),"钩子。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"服务器关闭阶段"}),": Vite 会依次执行",(0,s.jsx)(e.code,{children:"buildEnd"}),"和",(0,s.jsx)(e.code,{children:"closeBundle"}),"钩子。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["除了以上钩子，其他 Rollup 插件钩子(如",(0,s.jsx)(e.code,{children:"moduleParsed"}),"、",(0,s.jsx)(e.code,{children:"renderChunk"}),")均不会在 Vite ",(0,s.jsx)(e.strong,{children:"开发阶段"}),"调用。而生产环境下，由于 Vite 直接使用 Rollup，Vite 插件中所有 Rollup 的插件钩子都会生效。"]}),"\n",(0,s.jsxs)(e.h3,{id:"2-独有-hook",children:["2. 独有 Hook",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-独有-hook",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"接下来给大家介绍 Vite 中特有的一些 Hook，这些 Hook 只会在 Vite 内部调用，而放到 Rollup 中会被直接忽略。"}),"\n",(0,s.jsxs)(e.h4,{id:"21-给配置再加点料-config",children:["2.1 给配置再加点料: config",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#21-给配置再加点料-config",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["Vite 在读取完配置文件（即",(0,s.jsx)(e.code,{children:"vite.config.ts"}),"）之后，会拿到用户导出的配置对象，然后执行 config 钩子。在这个钩子里面，你可以对配置文件导出的对象进行自定义的操作，如下代码所示:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// 返回部分配置（推荐）\nconst editConfigPlugin = () => ({\n  name: 'vite-plugin-modify-config',\n  config: () => ({\n    alias: {\n      react: require.resolve('react')\n    }\n  })\n})\n"})}),"\n",(0,s.jsx)(e.p,{children:"官方推荐的姿势是在 config 钩子中返回一个配置对象，这个配置对象会和 Vite 已有的配置进行深度的合并。不过你也可以通过钩子的入参拿到 config 对象进行自定义的修改，如下代码所示:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const mutateConfigPlugin = () => ({\n  name: 'mutate-config',\n  // command 为 `serve`(开发环境) 或者 `build`(生产环境)\n  config(config, { command }) {\n    // 生产环境中修改 root 参数\n    if (command === 'build') {\n      config.root = __dirname;\n    }\n  }\n})\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在一些比较深层的对象配置中，这种直接修改配置的方式会显得比较麻烦，如 ",(0,s.jsx)(e.code,{children:"optimizeDeps.esbuildOptions.plugins"}),"，需要写很多的样板代码，类似下面这样:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// 防止出现 undefined 的情况\nconfig.optimizeDeps = config.optimizeDeps || {}\nconfig.optimizeDeps.esbuildOptions = config.optimizeDeps.esbuildOptions || {}\nconfig.optimizeDeps.esbuildOptions.plugins = config.optimizeDeps.esbuildOptions.plugins || []\n"})}),"\n",(0,s.jsx)(e.p,{children:"因此这种情况下，建议直接返回一个配置对象，这样会方便很多:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"config() {\n  return {\n    optimizeDeps: {\n      esbuildOptions: {\n        plugins: []\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.h4,{id:"22-记录最终配置-configresolved",children:["2.2 记录最终配置: configResolved",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#22-记录最终配置-configresolved",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["Vite 在解析完配置之后会调用",(0,s.jsx)(e.code,{children:"configResolved"}),"钩子，这个钩子一般用来记录最终的配置信息，而不建议再修改配置，用法如下图所示:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const exmaplePlugin = () => {\n  let config\n\n  return {\n    name: 'read-config',\n\n    configResolved(resolvedConfig) {\n      // 记录最终配置\n      config = resolvedConfig\n    },\n\n    // 在其他钩子中可以访问到配置\n    transform(code, id) {\n      console.log(config)\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.h4,{id:"23-获取-dev-server-实例-configureserver",children:["2.3 获取 Dev Server 实例: configureServer",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#23-获取-dev-server-实例-configureserver",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["这个钩子仅在",(0,s.jsx)(e.strong,{children:"开发阶段"}),"会被调用，用于扩展 Vite 的 Dev Server，一般用于增加自定义 server 中间件，如下代码所示:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const myPlugin = () => ({\n  name: 'configure-server',\n  configureServer(server) {\n    // 姿势 1: 在 Vite 内置中间件之前执行\n    server.middlewares.use((req, res, next) => {\n      // 自定义请求处理逻辑\n    })\n    // 姿势 2: 在 Vite 内置中间件之后执行 \n    return () => {\n      server.middlewares.use((req, res, next) => {\n        // 自定义请求处理逻辑\n      })\n    }\n  }\n})\n"})}),"\n",(0,s.jsxs)(e.h4,{id:"24-转换-html-内容-transformindexhtml",children:["2.4 转换 HTML 内容: transformIndexHtml",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#24-转换-html-内容-transformindexhtml",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"这个钩子用来灵活控制 HTML 的内容，你可以拿到原始的 html 内容后进行任意的转换:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const htmlPlugin = () => {\n  return {\n    name: 'html-transform',\n    transformIndexHtml(html) {\n      return html.replace(\n        /<title>(.*?)</title>/,\n        `<title>换了个标题</title>`\n      )\n    }\n  }\n}\n// 也可以返回如下的对象结构，一般用于添加某些标签\nconst htmlPlugin = () => {\n  return {\n    name: 'html-transform',\n    transformIndexHtml(html) {\n      return {\n        html,\n        // 注入标签\n        tags: [\n          {\n            // 放到 body 末尾，可取值还有`head`|`head-prepend`|`body-prepend`，顾名思义\n            injectTo: 'body',\n            // 标签属性定义\n            attrs: { type: 'module', src: './index.ts' },\n            // 标签名\n            tag: 'script',\n          },\n        ],\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.h4,{id:"25-热更新处理-handlehotupdate",children:["2.5 热更新处理: handleHotUpdate",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#25-热更新处理-handlehotupdate",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"关于热更新的概念和原理，我们会在下一节具体讲解。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"这个钩子会在 Vite 服务端处理热更新时被调用，你可以在这个钩子中拿到热更新相关的上下文信息，进行热更模块的过滤，或者进行自定义的热更处理。下面是一个简单的例子:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"const handleHmrPlugin = () => {\n  return {\n    async handleHotUpdate(ctx) {\n      // 需要热更的文件\n      console.log(ctx.file)\n      // 需要热更的模块，如一个 Vue 单文件会涉及多个模块\n      console.log(ctx.modules)\n      // 时间戳\n      console.log(ctx.timestamp)\n      // Vite Dev Server 实例\n      console.log(ctx.server)\n      // 读取最新的文件内容\n      console.log(await read())\n      // 自行处理 HMR 事件\n      ctx.server.ws.send({\n        type: 'custom',\n        event: 'special-update',\n        data: { a: 1 }\n      })\n      return []\n    }\n  }\n}\n\n// 前端代码中加入\nif (import.meta.hot) {\n  import.meta.hot.on('special-update', (data) => {\n    // 执行自定义更新\n    // { a: 1 }\n    console.log(data)\n    window.location.reload();\n  })\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"以上就是 Vite 独有的五个钩子，我们来重新梳理一下:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"config"}),": 用来进一步修改配置。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"configResolved"}),": 用来记录最终的配置信息。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"configureServer"}),": 用来获取 Vite Dev Server 实例，添加中间件。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"transformIndexHtml"}),": 用来转换 HTML 的内容。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"handleHotUpdate"}),": 用来进行热更新模块的过滤，或者进行自定义的热更新处理。"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"3-插件-hook-执行顺序",children:["3. 插件 Hook 执行顺序",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-插件-hook-执行顺序",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"好，现在我们学习到了 Vite 的通用钩子和独有钩子，估计你现在脑子里面一点乱: 这么多的钩子，到底谁先执行、谁后执行呢？"}),"\n",(0,s.jsxs)(e.p,{children:["下面，我们就来复盘一下上述的两类钩子，并且通过一个具体的代码示例来汇总一下所有的钩子。我们可以在 Vite 的脚手架工程中新建 ",(0,s.jsx)(e.code,{children:"test-hooks-plugin.ts"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// test-hooks-plugin.ts\n// 注: 请求响应阶段的钩子\n// 如 resolveId, load, transform, transformIndexHtml在下文介绍\n// 以下为服务启动和关闭的钩子\nexport default function testHookPlugin () {\n  return {\n    name: 'test-hooks-plugin', \n    // Vite 独有钩子\n    config(config) {\n      console.log('config');\n    },\n    // Vite 独有钩子\n    configResolved(resolvedCofnig) {\n      console.log('configResolved');\n    },\n    // 通用钩子\n    options(opts) {\n      console.log('options');\n      return opts;\n    },\n    // Vite 独有钩子\n    configureServer(server) {\n      console.log('configureServer');\n      setTimeout(() => {\n        // 手动退出进程\n        process.kill(process.pid, 'SIGTERM');\n      }, 3000)\n    },\n    // 通用钩子\n    buildStart() {\n      console.log('buildStart');\n    },\n    // 通用钩子\n    buildEnd() {\n      console.log('buildEnd');\n    },\n    // 通用钩子\n    closeBundle() {\n      console.log('closeBundle');\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"将插件加入到 Vite 配置文件中，然后启动，你可以观察到各个 Hook 的执行顺序:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"由此我们可以梳理出 Vite 插件的执行顺序:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["服务启动阶段: ",(0,s.jsx)(e.code,{children:"config"}),"、",(0,s.jsx)(e.code,{children:"configResolved"}),"、",(0,s.jsx)(e.code,{children:"options"}),"、",(0,s.jsx)(e.code,{children:"configureServer"}),"、",(0,s.jsx)(e.code,{children:"buildStart"})]}),"\n",(0,s.jsxs)(e.li,{children:["请求响应阶段: 如果是 ",(0,s.jsx)(e.code,{children:"html"})," 文件，仅执行",(0,s.jsx)(e.code,{children:"transformIndexHtml"}),"钩子；对于非 HTML 文件，则依次执行",(0,s.jsx)(e.code,{children:"resolveId"}),"、",(0,s.jsx)(e.code,{children:"load"}),"和",(0,s.jsx)(e.code,{children:"transform"}),"钩子。相信大家学过 Rollup 的插件机制，已经对这三个钩子比较熟悉了。"]}),"\n",(0,s.jsxs)(e.li,{children:["热更新阶段: 执行",(0,s.jsx)(e.code,{children:"handleHotUpdate"}),"钩子。"]}),"\n",(0,s.jsxs)(e.li,{children:["服务关闭阶段: 依次执行",(0,s.jsx)(e.code,{children:"buildEnd"}),"和",(0,s.jsx)(e.code,{children:"closeBundle"}),"钩子。"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"插件应用位置",children:["插件应用位置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#插件应用位置",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["梳理完 Vite 的各个钩子函数之后，接下来让我们来了解一下 Vite 插件的",(0,s.jsx)(e.strong,{children:"应用情景"}),"和",(0,s.jsx)(e.strong,{children:"应用顺序"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["默认情况下 Vite 插件同时被用于开发环境和生产环境，你可以通过",(0,s.jsx)(e.code,{children:"apply"}),"属性来决定应用场景:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"{\n  // 'serve' 表示仅用于开发环境，'build'表示仅用于生产环境\n  apply: 'serve'\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"apply"}),"参数还可以配置成一个函数，进行更灵活的控制:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts![plugin.png](./images/a0d98c1044391817ad5853c5eaf818b2.webp",meta:")",children:"apply(config, { command }) {\n  // 只用于非 SSR 情况下的生产环境构建\n  return command === 'build' && !config.build.ssr\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["同时，你也可以通过",(0,s.jsx)(e.code,{children:"enforce"}),"属性来指定插件的执行顺序:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"{\n  // 默认为`normal`，可取值还有`pre`和`post`\n  enforce: 'pre'\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"Vite 中插件的执行顺序如下图所示:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:h,alt:"plugin.png"})}),"\n",(0,s.jsx)(e.p,{children:"Vite 会依次执行如下的插件:"}),"\n",(0,s.jsx)(e.blockquote,{children:"\n"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Alias (路径别名)相关的插件。"}),"\n",(0,s.jsxs)(e.li,{children:["⭐️ 带有\xa0",(0,s.jsx)(e.code,{children:"enforce: 'pre'"}),"\xa0的用户插件。"]}),"\n",(0,s.jsx)(e.li,{children:"Vite 核心插件。"}),"\n",(0,s.jsxs)(e.li,{children:["⭐️ 没有 enforce 值的用户插件，也叫",(0,s.jsx)(e.code,{children:"普通插件"}),"。"]}),"\n",(0,s.jsx)(e.li,{children:"Vite 生产环境构建用的插件。"}),"\n",(0,s.jsxs)(e.li,{children:["⭐️ 带有\xa0",(0,s.jsx)(e.code,{children:"enforce: 'post'"}),"\xa0的用户插件。"]}),"\n",(0,s.jsx)(e.li,{children:"Vite 后置构建插件(如压缩插件)。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"插件开发实战",children:["插件开发实战",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#插件开发实战",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["接下来我们进入插件开发的实战环节中，在这个部分我们将一起编写两个 Vite 插件，分别是",(0,s.jsx)(e.code,{children:"虚拟模块加载插件"}),"和",(0,s.jsx)(e.code,{children:"Svgr 插件"}),"，你将学会从插件开发的常见套路和各种开发技巧。话不多说，让我们现在开始实战吧。"]}),"\n",(0,s.jsxs)(e.h3,{id:"实战案例-1-虚拟模块加载",children:["实战案例 1: 虚拟模块加载",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实战案例-1-虚拟模块加载",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"首先我们来实现一个虚拟模块的加载插件，可能你会有疑问: 什么是虚拟模块呢？"}),"\n",(0,s.jsxs)(e.p,{children:["作为构建工具，一般需要处理两种形式的模块，一种存在于真实的磁盘文件系统中，另一种并不在磁盘而在内存当中，也就是",(0,s.jsx)(e.code,{children:"虚拟模块"}),"。通过虚拟模块，我们既可以把自己手写的一些代码字符串作为单独的模块内容，又可以将内存中某些经过计算得出的",(0,s.jsx)(e.strong,{children:"变量"}),"作为模块内容进行加载，非常灵活和方便。接下来让我们通过一些具体的例子来实操一下，首先通过脚手架命令初始化一个",(0,s.jsx)(e.code,{children:"react + ts"}),"项目:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"npm init vite\n"})}),"\n",(0,s.jsxs)(e.p,{children:["然后通过",(0,s.jsx)(e.code,{children:"pnpm i"}),"安装依赖，接着新建",(0,s.jsx)(e.code,{children:"plugins"}),"目录，开始插件的开发:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// plugins/virtual-module.ts\nimport { Plugin } from 'vite';\n\n// 虚拟模块名称\nconst virtualFibModuleId = 'virtual:fib';\n// Vite 中约定对于虚拟模块，解析后的路径需要加上`\\0`前缀\nconst resolvedFibVirtualModuleId = '\\0' + virtualFibModuleId;\n\nexport default function virtualFibModulePlugin(): Plugin {\n  let config: ResolvedConfig | null = null;\n  return {\n    name: 'vite-plugin-virtual-module',\n    resolveId(id) {\n      if (id === virtualFibModuleId) { \n        return resolvedFibVirtualModuleId;\n      }\n    },\n    load(id) {\n      // 加载虚拟模块\n      if (id === resolvedFibVirtualModuleId) {\n        return 'export default function fib(n) { return n <= 1 ? n : fib(n - 1) + fib(n - 2); }';\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"接着我们在项目中来使用这个插件:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// vite.config.ts\nimport virtual from './plugins/virtual-module.ts'\n\n// 配置插件\n{\n  plugins: [react(), virtual()]\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["然后在",(0,s.jsx)(e.code,{children:"main.tsx"}),"中加入如下的代码:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import fib from 'virtual:fib';\n\nalert(`结果: ${fib(10)}`)\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这里我们使用了 ",(0,s.jsx)(e.code,{children:"virtual:fib"})," 这个虚拟模块，虽然这个模块不存在真实的文件系统中，但你打开浏览器后可以发现这个模块导出的函数是可以正常执行的:"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["接着我们来尝试一下如何通过虚拟模块来读取内存中的变量，在",(0,s.jsx)(e.code,{children:"virtual-module.ts"}),"中增加如下代码:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"import { Plugin, ResolvedConfig } from 'vite';\n\nconst virtualFibModuleId = 'virtual:fib';\nconst resolvedFibVirtualModuleId = '\\0' + virtualFibModuleId;\n\n+ const virtualEnvModuleId = 'virtual:env';\n+ const resolvedEnvVirtualModuleId = '\\0' + virtualEnvModuleId;\n\nexport default function virtualFibModulePlugin(): Plugin {\n+   let config: ResolvedConfig | null = null;\n  return {\n    name: 'vite-plugin-virtual-fib-module',\n+     configResolved(c: ResolvedConfig) {\n+       config = c;\n+     },\n    resolveId(id) {\n      if (id === virtualFibModuleId) { \n        return resolvedFibVirtualModuleId;\n      }\n+       if (id === virtualEnvModuleId) { \n+        return resolvedEnvVirtualModuleId;\n+      }\n    },\n    load(id) {\n      if (id === resolvedFibVirtualModuleId) {\n        return 'export default function fib(n) { return n <= 1 ? n : fib(n - 1) + fib(n - 2); }';\n      }\n+      if (id === resolvedEnvVirtualModuleId) {\n+        return `export default ${JSON.stringify(config!.env)}`;\n+      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["在新增的这些代码中，我们注册了一个新的虚拟模块",(0,s.jsx)(e.code,{children:"virtual:env"}),"，紧接着我们去项目去使用:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// main.tsx\nimport env from 'virtual:env';\nconsole.log(env)\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"virtual:env"}),"一般情况下会有类型问题，我们需要增加一个类型声明文件来声明这个模块:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// types/shim.d.ts\ndeclare module 'virtual:*' {\n  export default any;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样就解决了类型报错的问题。接着你可以去浏览器观察一下输出的情况:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["Vite 环境变量能正确地在浏览器中打印出来，说明在内存中计算出来的",(0,s.jsx)(e.code,{children:"virtual:env"}),"模块的确被成功地加载了。从中你可以看到，虚拟模块的内容完全能够被动态计算出来，因此它的灵活性和可定制程度非常高，实用性也很强，在 Vite 内部的插件被深度地使用，社区当中也有不少知名的插件(如 ",(0,s.jsx)(e.code,{children:"vite-plugin-windicss"}),"、",(0,s.jsx)(e.code,{children:"vite-plugin-svg-icons"}),"等)也使用了虚拟模块的技术。"]}),"\n",(0,s.jsxs)(e.h3,{id:"实战案例-2-svg-组件形式加载",children:["实战案例 2: Svg 组件形式加载",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实战案例-2-svg-组件形式加载",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在一般的项目开发过程中，我们有时候希望能将 svg 当做一个组件来引入，这样我们可以很方便地修改 svg 的各种属性，相比于",(0,s.jsx)(e.code,{children:"img"}),"标签的引入方式也更加优雅。但 Vite 本身并不支持将 svg 转换为组件的代码，需要我们通过插件来实现。"]}),"\n",(0,s.jsx)(e.p,{children:"接下来我们就来写一个 Vite 插件，实现在 React 项目能够通过组件方式来使用 svg 资源。首先安装一下需要的依赖:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pnpm i resolve @svgr/core -D\n"})}),"\n",(0,s.jsxs)(e.p,{children:["接着在",(0,s.jsx)(e.code,{children:"plugins"}),"目录新建 ",(0,s.jsx)(e.code,{children:"svgr.ts"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import { Plugin } from 'vite';\nimport * as fs from 'fs';\nimport * as resolve from 'resolve';\n\ninterface SvgrOptions {\n  // svg 资源模块默认导出，url 或者组件\n  defaultExport: 'url' | 'component';\n}\n\nexport default function viteSvgrPlugin(options: SvgrOptions) {\n  const { defaultExport='url' } = options;\n  return {\n    name: 'vite-plugin-svgr',\n    async transform(code ,id) {\n      // 转换逻辑: svg -> React 组件\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["让我们先来梳理一下开发需求，用户通过传入",(0,s.jsx)(e.code,{children:"defaultExport"}),"可以控制 svg 资源的默认导出:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["当 ",(0,s.jsx)(e.code,{children:"defaultExport"}),"为 ",(0,s.jsx)(e.code,{children:"component"}),"，默认当做组件来使用，即:"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import Logo from './Logo.svg'\n\n// 在组件中直接使用\n<Logo />\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["当",(0,s.jsx)(e.code,{children:"defaultExports"}),"为",(0,s.jsx)(e.code,{children:"url"}),"，默认当做 url 使用，如果需要用作组件，可以通过",(0,s.jsx)(e.code,{children:"具名导入"}),"的方式来支持:"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import logoUrl, { ReactComponent as Logo } from './logo.svg';\n\n// url 使用\n<img src={logoUrl} />\n// 组件方式使用\n<Logo />\n"})}),"\n",(0,s.jsxs)(e.p,{children:["明确了需求之后，接下来让我们来整理一下插件开发的整体思路，主要逻辑在 ",(0,s.jsx)(e.code,{children:"transform"}),"钩子中完成，流程如下:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"根据 id 入参过滤出 svg 资源；"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsx)(e.li,{children:"读取 svg 文件内容；"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.ol,{start:"3",children:["\n",(0,s.jsxs)(e.li,{children:["利用 ",(0,s.jsx)(e.code,{children:"@svgr/core"})," 将 svg 转换为 React 组件代码;"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.ol,{start:"4",children:["\n",(0,s.jsx)(e.li,{children:"处理默认导出为 url 的情况；"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.ol,{start:"5",children:["\n",(0,s.jsx)(e.li,{children:"将组件的 jsx 代码转译为浏览器可运行的代码。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"下面是插件的完整的代码，你可以参考学习:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import { Plugin } from 'vite';\nimport * as fs from 'fs';\nimport * as resolve from 'resolve';\n\ninterface SvgrOptions {\n  defaultExport: 'url' | 'component';\n}\n\nexport default function viteSvgrPlugin(options: SvgrOptions): Plugin {\n  const { defaultExport='component' } = options;\n\n  return {\n    name: 'vite-plugin-svgr',\n    async transform(code, id) {\n      // 1. 根据 id 入参过滤出 svg 资源；\n      if (!id.endsWith('.svg')) {\n        return code;\n      }\n      const svgrTransform = require('@svgr/core').transform;\n      // 解析 esbuild 的路径，后续转译 jsx 会用到，我们这里直接拿 vite 中的 esbuild 即可\n      const esbuildPackagePath = resolve.sync('esbuild', { basedir: require.resolve('vite') });\n      const esbuild = require(esbuildPackagePath);\n      // 2. 读取 svg 文件内容；\n      const svg = await fs.promises.readFile(id, 'utf8');\n      // 3. 利用 `@svgr/core` 将 svg 转换为 React 组件代码\n      const svgrResult = await svgrTransform(\n        svg,\n        {},\n        { componentName: 'ReactComponent' }\n      );\n      // 4. 处理默认导出为 url 的情况\n      let componentCode = svgrResult;\n      if (defaultExport === 'url') {\n        // 加上 Vite 默认的 `export default 资源路径`\n        componentCode += code;\n        componentCode = componentCode.replace('export default ReactComponent', 'export { ReactComponent }');\n      }\n      // 5. 利用 esbuild，将组件中的 jsx 代码转译为浏览器可运行的代码;\n      const result = await esbuild.transform(componentCode, {\n        loader: 'jsx',\n      });\n      return {\n        code: result.code,\n        map: null // TODO\n      };\n    },\n  };\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"接下来让我们在项目中使用这个插件:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// vite.config.ts\nimport svgr from './plugins/svgr';\n\n// 返回的配置\n{\n  plugins: [\n    // 省略其它插件\n    svgr()\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"接着我们在项目中用组件的方式引入 svg:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// App.tsx\nimport Logo from './logo.svg'\n\nfunction App() {\n  return (\n    <>\n      <Logo />\n    </>\n  )\n}\n\nexport default App;\n"})}),"\n",(0,s.jsx)(e.p,{children:"打开浏览器，可以看到组件已经正常显示:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(e.h3,{id:"调试技巧",children:["调试技巧",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#调试技巧",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["另外，在开发调试插件的过程，我推荐大家在本地装上",(0,s.jsx)(e.code,{children:"vite-plugin-inspect"}),"插件，并在 Vite 中使用它:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"// vite.config.ts\nimport inspect from 'vite-plugin-inspect';\n\n// 返回的配置\n{\n  plugins: [\n    // 省略其它插件\n    inspect()\n  ]\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样当你再次启动项目时，会发现多出一个调试地址:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"你可以通过这个地址来查看项目中各个模块的编译结果："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"点击特定的文件后，你可以看到这个模块经过各个插件处理后的中间结果，如下图所示:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"通过这个面板，我们可以很清楚地看到相应模块经过插件处理后变成了什么样子，让插件的调试更加方便。"}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["好，本节的内容到这里就接近尾声了。本节你需要重点掌握 Vite ",(0,s.jsx)(e.strong,{children:"插件钩子的含义"}),"、",(0,s.jsx)(e.strong,{children:"作用顺序"}),"以及",(0,s.jsx)(e.strong,{children:"插件的实战开发"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["首先我通过一个最简单的示例让你对 Vite 插件的结构有了初步的印象，然后对 Vite 中的各种钩子函数进行了介绍，主要包括",(0,s.jsx)(e.code,{children:"通用钩子"}),"和",(0,s.jsx)(e.code,{children:"独有钩子"}),"，通用钩子与 Rollup 兼容，而独有钩子在 Rollup 中会被忽略。而由于上一节已经详细介绍了 Rollup 的插件机制，对于通用钩子我们没有继续展开，而是详细介绍了 5 个独有钩子，分别是: ",(0,s.jsx)(e.code,{children:"config"}),"、",(0,s.jsx)(e.code,{children:"configResolved"}),"、",(0,s.jsx)(e.code,{children:"configureServer"}),"、",(0,s.jsx)(e.code,{children:"transformIndexHtml"}),"和",(0,s.jsx)(e.code,{children:"handleHotUpdate"}),"。不仅如此，我还给你从宏观角度分析了 Vite 插件的作用场景和作用顺序，你可以分别通过",(0,s.jsx)(e.code,{children:"apply"}),"和",(0,s.jsx)(e.code,{children:"enforce"}),"两个参数来进行手动的控制。"]}),"\n",(0,s.jsxs)(e.p,{children:["接下来我们正式进入插件开发实战的环节，实现了",(0,s.jsx)(e.code,{children:"虚拟模块加载插件"}),"和",(0,s.jsx)(e.code,{children:"Svg 组件加载插件"}),"，相信你已经对虚拟模块的概念和使用有了直观的了解，也能通过后者的开发过程了解到如何在 Vite 中集成其它的前端编译工具。总体来说，Vite  插件的设计秉承了 Rollup 的插件设计理念，通过一个个语义化的 Hook 来组织，十分简洁和灵活，上手难度并不大，但真正难的地方在于如何利用 Vite 插件去解决实际开发过程的问题，由于篇幅所限，本文的示例并不能覆盖所有的开发场景，你也不必着急，我们会在后面的几个小节中接触到更加高级的开发场景，你也将接触过越来越多的插件，当然，你的插件开发技能也能越来越纯熟。大家继续加油\uD83D\uDCAA\uD83C\uDFFB！"]})]})}function j(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(g,{...n})}):g(n)}let m=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F12.%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%9E%E6%88%98_%20%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%20Vite%20%E6%8F%92%E4%BB%B6%EF%BC%9F.md"]={toc:[{text:"一个简单的插件示例",id:"一个简单的插件示例",depth:2},{text:"插件 Hook 介绍",id:"插件-hook-介绍",depth:2},{text:"1. 通用 Hook",id:"1-通用-hook",depth:3},{text:"2. 独有 Hook",id:"2-独有-hook",depth:3},{text:"2.1 给配置再加点料: config",id:"21-给配置再加点料-config",depth:4},{text:"2.2 记录最终配置: configResolved",id:"22-记录最终配置-configresolved",depth:4},{text:"2.3 获取 Dev Server 实例: configureServer",id:"23-获取-dev-server-实例-configureserver",depth:4},{text:"2.4 转换 HTML 内容: transformIndexHtml",id:"24-转换-html-内容-transformindexhtml",depth:4},{text:"2.5 热更新处理: handleHotUpdate",id:"25-热更新处理-handlehotupdate",depth:4},{text:"3. 插件 Hook 执行顺序",id:"3-插件-hook-执行顺序",depth:3},{text:"插件应用位置",id:"插件应用位置",depth:2},{text:"插件开发实战",id:"插件开发实战",depth:2},{text:"实战案例 1: 虚拟模块加载",id:"实战案例-1-虚拟模块加载",depth:3},{text:"实战案例 2: Svg 组件形式加载",id:"实战案例-2-svg-组件形式加载",depth:3},{text:"调试技巧",id:"调试技巧",depth:3},{text:"小结",id:"小结",depth:2}],title:"12.插件开发与实战_ 如何开发一个完整的 Vite 插件？",headingTitle:"12.插件开发与实战_ 如何开发一个完整的 Vite 插件？",frontmatter:{}}}}]);