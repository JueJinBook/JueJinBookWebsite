"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["17959"],{328013:function(e,n,s){s.r(n),s.d(n,{default:()=>v});var r=s(552676),i=s(740453);let c=s.p+"static/image/d9466df28660ec2f71ffd25a089fb30d.d43f2a0f.webp",l=s.p+"static/image/89a81b5b32e58bba48a443cad3d5a871.b3c0aa08.webp",d=s.p+"static/image/a2035b80e71f119e5d77aee7832899cd.fc2da452.webp",a=s.p+"static/image/8e65c31564321ee3a8d8e39234bfbf60.c9d0aa50.webp",t=s.p+"static/image/ed07adceffc5ec5e669eee21a3107484.aab4235a.webp",o=s.p+"static/image/289fdd7f6215a731542d347f8ce51ac5.3eeeed73.webp",p=s.p+"static/image/cfdc2a49611df813fcbd9281a9a25219.48c65d87.webp",h=s.p+"static/image/f9a760592e1d1b15be209756a1811fd1.47812139.webp",x=s.p+"static/image/67cf7d5e468178088bb3a574b4305275.821a463f.webp",j=s.p+"static/image/38f9b9e1f741305833e5acdf5071b2e4.89bbc968.webp",m=s.p+"static/image/c2fc8c6b4fc7fe596021841a6f5b4114.80865b4e.webp",u=s.p+"static/image/784c9df9e4bde673cb22dff8554cad5b.182ccc22.webp";function g(e){let n=Object.assign({p:"p",code:"code",blockquote:"blockquote",h2:"h2",a:"a",pre:"pre",img:"img",h4:"h4"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["这一章节中讲解的知识点，我认为是前端开发工作中非常重要的一环，没有从 0 到 1 搭建前端项目经验的同学，跟着我把搭建项目架子的环节好好捋一捋，相信在日后的工作中会有很大的帮助。项目搭建采用全新的构建工具 ",(0,r.jsx)(n.code,{children:"Vite 2"}),"，虽然在生态上它没有 ",(0,r.jsx)(n.code,{children:"Webpack"})," 那么丰富，但是从打包速度上你能切实的体验到快感。"]}),"\n",(0,r.jsx)(n.p,{children:"之后的实战文章，都会在文末提供当前章节的源码。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意：当前作者的 Node 版本为 16.13.2，npm 为 8.1.2。如果下面的操作出现一些诡异的指令报错，请同步版本。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"初始化-vite-项目",children:["初始化 Vite 项目",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化-vite-项目",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先找一个自己习惯放置代码的目录，通过如下指令新建一个项目："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 31.Vite 2 + Vue 3 + Element-Plus 搭建管理后台项目\nnpm init @vitejs/app newbee-admin --template vue\n\n# npm 7+, 需要额外的双横线：\nnpm init @vitejs/app newbee-admin -- --template vue\n\n# yarn\nyarn create @vitejs/app newbee-admin --template vue\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意，此章节搭建的项目将用于后续的实战环节。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"成功之后项目目录如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"安装依赖包，并且启动项目："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install\nnpm run dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器打开如下所示代表初始化项目成功。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"安装路由插件",children:["安装路由插件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#安装路由插件",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["打开命令行工具，在项目根目录安装 ",(0,r.jsx)(n.code,{children:"vue-router"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i vue-router@next\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"这里加一个 @next 代表的是安装最新的版本，目前最新版本是 4.0.13"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["安装成功之后，在 ",(0,r.jsx)(n.code,{children:"src"})," 目录下新建 ",(0,r.jsx)(n.code,{children:"router/index.js"}),"，并添加路由配置项："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// router/index.js\nimport { createRouter, createWebHashHistory } from 'vue-router'\nimport Index from '@/views/Index.vue'\n\nconst router = createRouter({\n  history: createWebHashHistory(), // hash 模式\n  routes: [\n    {\n      path: '/',\n      component: Index\n    }\n  ]\n})\n\nexport default router\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时我们顺带着在 ",(0,r.jsx)(n.code,{children:"src"})," 目录下新增 ",(0,r.jsx)(n.code,{children:"views"})," 目录，用于放置页面组件。之后在该目录下添加 ",(0,r.jsx)(n.code,{children:"Index.vue"})," 组件，在 ",(0,r.jsx)(n.code,{children:"template"})," 模板下随意添加一些内容："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<template>\n  Index\n</template>\n\n<script>\nexport default {\n\n}\n<\/script>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们注意到上述获取文件路径是通过 ",(0,r.jsx)(n.code,{children:"@/"})," 的形式。这需要我们在 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 下添加 ",(0,r.jsx)(n.code,{children:"resolve.alias"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport path from 'path'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  resolve: {\n    alias: {\n      '~': path.resolve(__dirname, './'),\n      '@': path.resolve(__dirname, 'src')\n    },\n  }\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"@"})," 代表 ",(0,r.jsx)(n.code,{children:"src"})," 目录下的别名；",(0,r.jsx)(n.code,{children:"~"})," 代表根目录下的别名，这样我们在项目中使用路径的时候，就不用写一长串。"]}),"\n",(0,r.jsxs)(n.p,{children:["配置完之后，我们需要在 ",(0,r.jsx)(n.code,{children:"src/main.js"})," 中引入路由实例，如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { createApp } from 'vue'\nimport App from './App.vue'\nimport router from '@/router'\n\nconst app = createApp(App) // 生成 Vue 实例 app\n\napp.use(router) // 引用路由实例\n\napp.mount('#app') // 挂载到 #app\n"})}),"\n",(0,r.jsxs)(n.p,{children:["别忘了将路由展示出来，修改 ",(0,r.jsx)(n.code,{children:"src/App.vue"})," 如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<template>\n  \x3c!--路径匹配到的组件，将会展示在这里--\x3e\n  <router-view></router-view>\n</template>\n\n<script>\nexport default {\n  name: 'App'\n}\n<\/script>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm run dev"})," 启动项目，如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["如上图所示，",(0,r.jsx)(n.code,{children:"/"})," 路径下，展示的就是 ",(0,r.jsx)(n.code,{children:"Index.vue"})," 组件的内容，你改变组件的内容，视图将会跟着变化，这便是 ",(0,r.jsx)(n.code,{children:"Vite"})," 的热更新能力，并且速度非常快，提高开发体验。"]}),"\n",(0,r.jsxs)(n.h2,{id:"环境变量配置",children:["环境变量配置",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#环境变量配置",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"环境变量是当你打包或运行项目的时候，能告诉你当前处于哪一个环境。就目前而言，我们开发分项目几种环境，开发环境、测试环境、正式环境。不同的环境我们配置的资源可能都不同，如服务端接口、统计相关代码、日志的打印等等。"}),"\n",(0,r.jsxs)(n.p,{children:["用 ",(0,r.jsx)(n.code,{children:"Vue CLI"})," 启动的 ",(0,r.jsx)(n.code,{children:"Vue"})," 项目，你可以在项目中使用 ",(0,r.jsx)(n.code,{children:"process.env"})," 获取相关的环境变量。到了 ",(0,r.jsx)(n.code,{children:"Vite"})," 这儿，就不能通过 ",(0,r.jsx)(n.code,{children:"process.env"})," 来获取环境变量。"]}),"\n",(0,r.jsxs)(n.h4,{id:"打包时",children:["打包时",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#打包时",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["打包时，指的是在运行打包过程的时候，",(0,r.jsx)(n.code,{children:"vite.config.js"})," 内如何获取环境变量，配置静态资源路径需要它。"]}),"\n",(0,r.jsxs)(n.p,{children:["首先我们将 ",(0,r.jsx)(n.code,{children:"package.json"})," 的 ",(0,r.jsx)(n.code,{children:"scripts"})," 属性做如下改动："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'"scripts": {\n  "dev": "vite --mode development",\n  "build:beta": "vite build --mode beta",\n  "build:release": "vite build --mode release",\n  "serve": "vite preview"\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["通过在 ",(0,r.jsx)(n.code,{children:"--mode"})," 后面添加相应的环境变量值。然后我们在 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 内通过如下代码获取变量："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export default ({ mode }) => defineConfig({\n  ...\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["当你打包代码的时候，",(0,r.jsx)(n.code,{children:"index.html"})," 文件内的静态资源引用路径是根据 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 的 ",(0,r.jsx)(n.code,{children:"base"})," 属性配置的。如果我在发布的时候，使用的是在线静态资源 ",(0,r.jsx)(n.code,{children:"CDN"})," 的形式，则需要做如下改动："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport path from 'path'\n\n// https://vitejs.dev/config/\nexport default ({ mode }) => defineConfig({\n  plugins: [vue()],\n  resolve: {\n    alias: {\n      '~': path.resolve(__dirname, './'),\n      '@': path.resolve(__dirname, 'src')\n    },\n    extensions: ['.vue', '.js', 'jsx', '.json']\n  },\n  base: mode == 'development' ? './' : (mode == 'beta' ? '//s.baidu.com/beta/xxx' : '//s.baidu.com/release/xxx') // 静态资源路径配置\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"尝试打包项目，运行指令："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm run build:beta\n"})}),"\n",(0,r.jsxs)(n.p,{children:["查看 ",(0,r.jsx)(n.code,{children:"dist"})," 目录下的文件，如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["静态资源前缀变成了我们配置好的 ",(0,r.jsx)(n.code,{children:"//s.baidu.com/beta/xxx"}),"，同理运行 ",(0,r.jsx)(n.code,{children:"npm run build:release"})," 也会变成相应的前缀。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果不需要配置的同学，直接修改 ",(0,r.jsx)(n.code,{children:"base"})," 属性为 ",(0,r.jsx)(n.code,{children:"./"})," 即可。打完包后如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["直接加载相对路径下 ",(0,r.jsx)(n.code,{children:"assets"})," 文件夹。"]}),"\n",(0,r.jsxs)(n.h4,{id:"运行时",children:["运行时",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#运行时",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上述分析的是在打包时做的配置，我们的代码在运行时，如何获取环境变量呢？答案是 ",(0,r.jsx)(n.code,{children:"import.meta.env"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["它是 ",(0,r.jsx)(n.code,{children:"Vite"})," 专门为项目提供的环境变量参数，通过它能获取到我们在 ",(0,r.jsx)(n.code,{children:"scripts"})," 设置的 ",(0,r.jsx)(n.code,{children:"mode"})," 环境变量。我们不妨在 ",(0,r.jsx)(n.code,{children:"src/views/Index.vue"})," 内打印一下这个变量："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>Index</div>\n</template>\n\n<script>\nconst ENV = import.meta.env\nexport default {\n  name: 'Index',\n  setup() {\n    console.log('ENV', ENV)\n  }\n}\n<\/script>\n"})}),"\n",(0,r.jsx)(n.p,{children:"如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["肉眼可见，",(0,r.jsx)(n.code,{children:"MODE"})," 属性便是我们需要的环境变量，我们可以通过它去做一些有趣的事情，比如二次封装 ",(0,r.jsx)(n.code,{children:"axios"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"二次封装-axios",children:["二次封装 axios",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二次封装-axios",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先我们需要先安装 ",(0,r.jsx)(n.code,{children:"axios"}),"，通过 ",(0,r.jsx)(n.code,{children:"npm i axios"})," 安装成功之后，我们在 ",(0,r.jsx)(n.code,{children:"src"})," 目录下新建 ",(0,r.jsx)(n.code,{children:"utils/axios.js"}),"，添加如下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import axios from 'axios'\nimport router from '@/router/index'\nimport config from '~/config'\n\n\n// 这边由于后端没有区分测试和正式，姑且都写成一个接口。\naxios.defaults.baseURL = config[import.meta.env.MODE].baseUrl\n// 携带 cookie，对目前的项目没有什么作用，因为我们是 token 鉴权\naxios.defaults.withCredentials = true\n// 请求头，headers 信息\naxios.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'\naxios.defaults.headers['token'] = localStorage.getItem('token') || ''\n// 默认 post 请求，使用 application/json 形式\naxios.defaults.headers.post['Content-Type'] = 'application/json'\n\n// 请求拦截器，内部根据返回值，重新组装，统一管理。\naxios.interceptors.response.use(res => {\n  if (typeof res.data !== 'object') {\n    alert('服务端异常！')\n    return Promise.reject(res)\n  }\n  if (res.data.resultCode != 200) {\n    if (res.data.message) alert(res.data.message)\n    if (res.data.resultCode == 419) {\n      router.push({ path: '/login' })\n    }\n    return Promise.reject(res.data)\n  }\n\n  return res.data.data\n})\n\nexport default axios\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时我们需要在根目录下新增 ",(0,r.jsx)(n.code,{children:"config/index.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// config/index.js\nexport default {\n  development: {\n    baseUrl: '/api' // 开发代理地址\n  },\n  beta: {\n    baseUrl: '//backend-api-02.newbee.ltd/manage-api/v1' // 测试接口域名\n  },\n  release: {\n    baseUrl: '//backend-api-02.newbee.ltd/manage-api/v1' // 正式接口域名\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["分别配置相应环境的域名地址。开发环境配置 ",(0,r.jsx)(n.code,{children:"/api"}),"，是为了后续配置 ",(0,r.jsx)(n.code,{children:"proxy"})," 代理接口所用，下面我们就要讲解这块内容。"]}),"\n",(0,r.jsxs)(n.h2,{id:"配置-proxy-代理接口",children:["配置 proxy 代理接口",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置-proxy-代理接口",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在开发前端项目的时候，经常会遇到跨域问题，此时我们可以在 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 下作如下配置："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// vite.config.js\n...\nserver: {\n  proxy: {\n    '/api': {\n      target: 'http://backend-api-02.newbee.ltd/manage-api/v1', // 凡是遇到 /api 路径的请求，都映射到 target 属性\n      changeOrigin: true,\n      rewrite: path => path.replace(/^\\/api/, '') // 重写 api 为 空，就是去掉它\n    }\n  }\n}\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"跨域问题一直是个头疼的事情，但是就目前看来，我们可以通过上述方式解决掉它。"}),"\n",(0,r.jsxs)(n.h2,{id:"引入-ui-组件库-element-plus",children:["引入 UI 组件库 element-plus",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#引入-ui-组件库-element-plus",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"element-ui"})," 大家应该都不陌生，几乎做过 ",(0,r.jsx)(n.code,{children:"Vue"})," 开发的同学都接触过这款组件库，不过它没有直接作 ",(0,r.jsx)(n.code,{children:"Vue3"})," 的适配版本，而是重新推出一个组件库叫 ",(0,r.jsx)(n.code,{children:"element-plus"}),"，这款组件是适配了 ",(0,r.jsx)(n.code,{children:"Vue3"}),"，且使用习惯贴合 ",(0,r.jsx)(n.code,{children:"element-ui"}),"。咱们这套课程便是使用它来完成后台管理系统的制作。"]}),"\n",(0,r.jsx)(n.p,{children:"话不多说我们先安装它："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i element-plus@2.2.16\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"这里要提醒大家，一定要看官方文档，遇到问题的话，就尝试去他们的 Github 仓库，看看 issue 里有没有人已经提出了类似的问题。"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["官方文档：",(0,r.jsx)(n.a,{href:"https://element-plus.gitee.io/#/zh-CN",target:"_blank",rel:"noopener noreferrer",children:"https://element-plus.gitee.io/#/zh-CN"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"文档中告诉我们，全局引入的方式如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["我们便按照它的方式修改 ",(0,r.jsx)(n.code,{children:"src/main.js"}),"，如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { createApp } from 'vue'\nimport App from './App.vue'\nimport ElementPlus from 'element-plus'\nimport router from '@/router'\n\nimport 'element-plus/lib/theme-chalk/index.css';\n\nconst app = createApp(App)\n\napp.use(router)\n\napp.use(ElementPlus)\n\napp.mount('#app')\n"})}),"\n",(0,r.jsxs)(n.p,{children:["打开 ",(0,r.jsx)(n.code,{children:"src/views/Index.vue"})," 稍作修改："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<template>\n  <div><el-button type=\"primary\">主要按钮</el-button></div>\n</template>\n\n<script>\nexport default {\n  name: 'Index'\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["启动项目 ",(0,r.jsx)(n.code,{children:"npm run dev"}),"，如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"恭喜你，组件引入已经成功了，你可以随便使用官方文档内给出的任意组件，进行页面的编排和制作。"}),"\n",(0,r.jsxs)(n.p,{children:["但是我不希望全局引入，因为有些组件我并不需要，我只想引入我需要使用的组件，这时候向大家推荐一款插件 ",(0,r.jsx)(n.code,{children:"vite-plugin-babel-import"}),"，它能实现 ",(0,r.jsx)(n.code,{children:"element-plus"})," 的按需引入，我们安装它："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i vite-plugin-babel-import -D\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"...\nimport vitePluginImport from 'vite-plugin-babel-import'\n... \nplugins: [\n  vue(),\n  vitePluginImport([\n    {\n      libraryName: 'element-plus',\n      libraryDirectory: 'es',\n      style(name) {\n        return `element-plus/lib/theme-chalk/${name}.css`;\n      },\n    }\n  ])\n]\n... \n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后我们修改 ",(0,r.jsx)(n.code,{children:"main.js"}),"，如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { createApp } from 'vue'\nimport App from './App.vue'\nimport { ElButton } from 'element-plus'\nimport router from '@/router'\n\nimport 'element-plus/lib/theme-chalk/index.css';\n\nconst app = createApp(App)\n\napp.use(router)\n\napp.use(ElButton)\n\napp.mount('#app')\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时，你想要什么组件，只需通过 ",(0,r.jsx)(n.code,{children:"ES6"})," 解构的形式，将其引入便可。"]}),"\n",(0,r.jsxs)(n.p,{children:["解决问题还是需要大家去网上查询，特别是现在你用了 ",(0,r.jsx)(n.code,{children:"Vite"})," 的架子，遇到问题直接先去 ",(0,r.jsx)(n.code,{children:"Vite"})," 的仓库看看 ",(0,r.jsx)(n.code,{children:"issue"})," 里有没有类似的问题，已经提供解决方案了。"]}),"\n",(0,r.jsxs)(n.h2,{id:"element-plus-自定义主题色配置",children:["element-plus 自定义主题色配置",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#element-plus-自定义主题色配置",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"element-plus"})," 升级为正式版之后，官方在自定义主题上也增加了通过 sass 变量去控制主题样式，具体文档链接：",(0,r.jsx)(n.a,{href:"https://element-plus.gitee.io/zh-CN/guide/theming.html%E3%80%82",target:"_blank",rel:"noopener noreferrer",children:"https://element-plus.gitee.io/zh-CN/guide/theming.html。"})]}),"\n",(0,r.jsx)(n.p,{children:"回到本项目配置，首先需要先安装几个必要的插件，如下所示："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install sass unplugin-element-plus unplugin-vue-components -D\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"sass"})," 的作用不言而喻，",(0,r.jsx)(n.code,{children:"element-plus"})," 基于 ",(0,r.jsx)(n.code,{children:"sass"})," 编写样式，所以需要通过它去覆盖主题变量。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"unplugin-vue-components"})," 插件用于按需加载组件。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"unplugin-element-plus"})," 用于解决组件库内部方法调用时，丢掉样式的问题，比如 ElMessage 等。"]}),"\n",(0,r.jsxs)(n.p,{children:["安装完后，修改 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 文件，如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// vite.config.js\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport path from 'path'\nimport Components from 'unplugin-vue-components/vite'\nimport { ElementPlusResolver } from 'unplugin-vue-components/resolvers'\nimport ElementPlus from 'unplugin-element-plus/vite' // 不加这个配置，ElMessage出不来\n\n// https://vitejs.dev/config/\nexport default ({ mode }) => defineConfig({\n  plugins: [\n    vue(),\n    // 按需引入，主题色的配置，需要加上 importStyle: 'sass'\n    Components({\n      resolvers: [ElementPlusResolver({\n        importStyle: 'sass'\n      })],\n    }),\n    // 用于内部方法调用，样式缺失的现象，如 ElMessage 等\n    ElementPlus()\n  ],\n  resolve: {\n    alias: {\n      '~': path.resolve(__dirname, './'),\n      '@': path.resolve(__dirname, 'src')\n    },\n  },\n  base: './',\n  server: {\n    proxy: {\n      '/api': {\n        target: 'http://backend-api-02.newbee.ltd/manage-api/v1', // 凡是遇到 /api 路径的请求，都映射到 target 属性\n        changeOrigin: true,\n        rewrite: path => path.replace(/^\\/api/, '') // 重写 api 为 空，就是去掉它\n      }\n    }\n  },\n  css: {\n    preprocessorOptions: {\n      // 覆盖掉element-plus包中的主题变量文件\n      scss: {\n        additionalData: `@use \"@/styles/element/index.scss\" as *;`,\n      },\n    },\n  },\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上述代码中，通过 ",(0,r.jsx)(n.code,{children:"additionalData"})," 属性值所对应的 ",(0,r.jsx)(n.code,{children:"sass"})," 文件，可以覆盖掉 ",(0,r.jsx)(n.code,{children:"element-plus"})," 包中的主题变量文件。"]}),"\n",(0,r.jsxs)(n.p,{children:["接下来，需要在 ",(0,r.jsx)(n.code,{children:"src"}),"下新建 ",(0,r.jsx)(n.code,{children:"styles/element/index.scss"})," 文件，添加如下内容："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:'// styles/element/index.scss\n/* just override what you need */\n@forward "element-plus/theme-chalk/src/common/var.scss" with (\n  $colors: (\n    "primary": (\n      "base": #1baeae\n    ),\n  ),\n);\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["这里要注意，",(0,r.jsx)(n.code,{children:"element-plus/theme-chalk/src/common/var.scss"})," 这个文件路径需要你去查看当前安装的 ",(0,r.jsx)(n.code,{children:"element-plus"})," 包内是否存在，如果路径名称有出入，请自行修改。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"重新启动项目之后，如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"引入图标库",children:["引入图标库",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#引入图标库",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"element-plus"})," 升级后，组件库内图标的使用需要单独下载工具包 ",(0,r.jsx)(n.code,{children:"@element-plus/icons-vue"}),"，执行如下指令安装："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install @element-plus/icons-vue\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后打开 ",(0,r.jsx)(n.code,{children:"main.js"}),"，全局注册图标组件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// main.js\nimport * as ElementPlusIconsVue from '@element-plus/icons-vue'\n\nconst app = createApp(App)\nfor (const [key, component] of Object.entries(ElementPlusIconsVue)) {\n app.component(key, component)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["完成上述操作之后，可以打开 ",(0,r.jsx)(n.code,{children:"element-plus"})," 官方文档，直接点击就能复制 ",(0,r.jsx)(n.code,{children:"icon"})," 组件，如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["打开 ",(0,r.jsx)(n.code,{children:"views/Index.vue"})," 添加如下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<template>\n <div><el-button type="primary">主要按钮</el-button></div>\n <el-icon><Aim /></el-icon>\n</template>\n...\n'})}),"\n",(0,r.jsx)(n.p,{children:"重启项目，浏览器展示如下图所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"公用方法封装",children:["公用方法封装",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#公用方法封装",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先我们要在 ",(0,r.jsx)(n.code,{children:"src/utils"})," 目录下新建 ",(0,r.jsx)(n.code,{children:"index.js"})," 文件，内容如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export function localGet (key) {\n  const value = window.localStorage.getItem(key)\n  try {\n    return JSON.parse(window.localStorage.getItem(key))\n  } catch (error) {\n    return value\n  }\n}\n\nexport function localSet (key, value) {\n  window.localStorage.setItem(key, JSON.stringify(value))\n}\n\nexport function localRemove (key) {\n  window.localStorage.removeItem(key)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["先设置一个本地数据获取的封装，我们修改 ",(0,r.jsx)(n.code,{children:"src/axios.js"})," 的 ",(0,r.jsx)(n.code,{children:"token"})," 获取，顺便把错误提示的组件也加上，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { ElMessage } from 'element-plus'\nimport { localGet } from './index'\n...\n\naxios.defaults.headers['token'] = localGet('token') || ''\n...\nElMessage.error('服务端异常！')\n...\nElMessage.error(res.data.message)\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"vue-devtools",children:["vue-devtools",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-devtools",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["最新的插件已经支持 ",(0,r.jsx)(n.code,{children:"Vue 3"})," 和 ",(0,r.jsx)(n.code,{children:"Vite 2"})," 的开发模式，这边大家可以前往 ",(0,r.jsx)(n.code,{children:"Github"})," 官网下载插件。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/vuejs/vue-devtools/releases/tag/v6.0.0-beta.7",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/vuejs/vue-devtools/releases/tag/v6.0.0-beta.7"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"这里就不赘述安装的过程了。"}),"\n",(0,r.jsx)(n.p,{children:"安装完之后，开发模式下，才能看到组件的结构，如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["到此，我们已经基本上完成了一个项目的搭建工作，当然你可以给项目配置 ",(0,r.jsx)(n.code,{children:"TS"}),"、",(0,r.jsx)(n.code,{children:"css moduls"}),"，我认为这些都是锦上添花，上述文章中提到的都是一个项目必须的内容，同学们可以自由拓展，把架子搭建好了，后面的编码步骤才会如鱼得水。"]}),"\n",(0,r.jsxs)(n.p,{children:["本章源码地址：",(0,r.jsx)(n.a,{href:"https://s.yezgea02.com/1663209581507/admin00.zip",target:"_blank",rel:"noopener noreferrer",children:"点击下载"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"文档最近更新时间：2022 年 9 月 20 日。"}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}let v=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F31.Vite%202%20%2B%20Vue%203%20%2B%20Element-Plus%20%E6%90%AD%E5%BB%BA%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE.md"]={toc:[{text:"初始化 Vite 项目",id:"初始化-vite-项目",depth:2},{text:"安装路由插件",id:"安装路由插件",depth:2},{text:"环境变量配置",id:"环境变量配置",depth:2},{text:"打包时",id:"打包时",depth:4},{text:"运行时",id:"运行时",depth:4},{text:"二次封装 axios",id:"二次封装-axios",depth:2},{text:"配置 proxy 代理接口",id:"配置-proxy-代理接口",depth:2},{text:"引入 UI 组件库 element-plus",id:"引入-ui-组件库-element-plus",depth:2},{text:"element-plus 自定义主题色配置",id:"element-plus-自定义主题色配置",depth:2},{text:"引入图标库",id:"引入图标库",depth:2},{text:"公用方法封装",id:"公用方法封装",depth:2},{text:"vue-devtools",id:"vue-devtools",depth:4},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);