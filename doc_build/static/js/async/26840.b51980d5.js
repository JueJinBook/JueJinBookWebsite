"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["26840"],{185739:function(e,n,c){c.r(n),c.d(n,{default:()=>g});var s=c(552676),i=c(740453);let r=c.p+"static/image/59560fe7c5044fd1edc3b7726fc20014.9602171f.webp",d=c.p+"static/image/fe9288b4dee94b5cbd533c3aee945471.81d4362d.webp",t=c.p+"static/image/512450f4ea19fe891c18014fbaf87a34.b1c69cbb.webp",l=c.p+"static/image/ba7e40e81f4bd00462eac387eb97b0fd.b85ae4a6.webp",a=c.p+"static/image/152b31f52943ca8b9cfe9743b2bc7624.c032441b.webp",h=c.p+"static/image/29dafaf4d177beb9250b3b41b1717318.a403ab28.webp",o=c.p+"static/image/19e29a30d72c02752bb9b16d4ea86977.dd211c53.webp",p=c.p+"static/image/da68b3a18843abd71d549140ba655e6e.010a1826.webp",j=c.p+"static/image/2a538ce74f7ba1f4d1da8b00ef3fad11.5694e6c4.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",pre:"pre",img:"img",ul:"ul",li:"li",ol:"ol",strong:"strong"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"3快速上手_-如何用-vite-从零搭建前端项目",children:["3.快速上手_ 如何用 Vite 从零搭建前端项目？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3快速上手_-如何用-vite-从零搭建前端项目",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过前面的学习，我们已经知道了前端构建工具的意义，也明确了 Vite 相比于传统构建工具 Webpack 的优势。相信对于为什么要学习和使用 Vite 这个问题，你已经有了自己的答案。"}),"\n",(0,s.jsx)(n.p,{children:"回到实际的应用场景当中，我们应该如何使用 Vite 来搭建前端工程项目呢？这一节，我将和你一起近距离接触 Vite，学完本节你不仅能学会前端开发环境的搭建，更重要的是，你能上手使用 Vite 来初始化一个脚手架项目，并理解这个项目究竟是如何运行起来的。"}),"\n",(0,s.jsxs)(n.h2,{id:"环境搭建",children:["环境搭建",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#环境搭建",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先需要的是代码编辑器和浏览器，我推荐安装",(0,s.jsx)(n.code,{children:"VSCode"}),"和",(0,s.jsx)(n.code,{children:"Chrome"}),"浏览器。"]}),"\n",(0,s.jsxs)(n.p,{children:["其次是安装 Node.js，如果你的系统中还没有安装 ",(0,s.jsx)(n.a,{href:"http://nodejs.cn/download/current/",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"Node.js"})})," ，可以进入 Nodejs 官网下载相应的安装包进行手动安装；如果已经安装了 ",(0,s.jsx)(n.code,{children:"Node.js"}),"，你可以使用这个命令检查一下 Node.js 版本:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"node -v\n"})}),"\n",(0,s.jsxs)(n.p,{children:["推荐 ",(0,s.jsx)(n.code,{children:"12.0.0"})," 及以上版本，如果低于这个版本，推荐使用 ",(0,s.jsx)(n.a,{href:"https://github.com/nvm-sh/nvm",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"nvm"})})," 工具切换 Nodejs 版本。"]}),"\n",(0,s.jsxs)(n.p,{children:["安装完 Nodejs 之后，包管理器",(0,s.jsx)(n.code,{children:"npm"}),"也会被自动安装，你可以执行下面的命令来验证:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm -v\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当然，在现代的前端项目中，我非常不推荐使用 npm 作为项目的包管理器，甚至也不再推荐",(0,s.jsx)(n.code,{children:"yarn"}),"(",(0,s.jsx)(n.code,{children:"npm"})," 的替代方案)，因为两者都存在比较严重的性能和安全问题，而这些问题在 pnpm 中得到了很好的解决，更多细节可以参考我的这篇博客: ",(0,s.jsx)(n.a,{href:"https://juejin.cn/post/6932046455733485575",target:"_blank",rel:"noopener noreferrer",children:"关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?\n"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"因此，包管理器方面我推荐使用 pnpm，安装方式非常简单，输入如下命令即可:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"npm i -g pnpm\n"})}),"\n",(0,s.jsxs)(n.p,{children:["由于默认的镜像源在国外，包下载速度和稳定性都不太好，因此我建议你换成国内的镜像源，这样",(0,s.jsx)(n.code,{children:"pnpm install"}),"命令的体验会好很多，命令如下:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pnpm config set registry https://registry.npmmirror.com/\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"项目初始化",children:["项目初始化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#项目初始化",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在搭建了基本的开发环境之后，我们进入到",(0,s.jsx)(n.code,{children:"项目初始化"}),"阶段。你可以在终端命令行中输入如下的命令:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"pnpm create vite\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在执行完这个命令后，pnpm 首先会自动下载 ",(0,s.jsx)(n.code,{children:"create-vite"})," 这个第三方包，然后执行这个包中的项目初始化逻辑。因此，你很快就可以看到这样的交互界面:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"后续的交互流程梳理如下:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"输入项目名称；"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"选择前端框架；"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"选择开发语言。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["首先是输入项目名称，这里你可以输入",(0,s.jsx)(n.code,{children:"vite-project"}),"，然后按下回车，进入",(0,s.jsx)(n.code,{children:"选择前端框架"}),"的部分:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"✔ Project name: vite-project\n? Select a framework: › - Use arrow-keys. Return to submit.\n    vanilla // 无前端框架\n    vue     // 基于 Vue \n >  react   // 基于 React\n    preact  // 基于 Preact（一款精简版的类 React 框架）\n    lit     // 基于 lit（一款 Web Components 框架） \n    svelte  // 基于 Svelte\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Vite 内置了以上不同前端框架的脚手架模板，这里我们以其中的",(0,s.jsx)(n.code,{children:"react"}),"框架为例来讲解，选择",(0,s.jsx)(n.code,{children:"react"}),"并按回车，紧接着选择",(0,s.jsx)(n.code,{children:"react-ts"}),"完成命令交互。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"好，现在脚手架的模板已经生成完毕。你可以执行如下命令在本地启动项目:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 进入项目目录\ncd vite-project\n// 安装依赖\npnpm install\n// 启动项目\npnpm run dev\n"})}),"\n",(0,s.jsxs)(n.p,{children:["执行",(0,s.jsx)(n.code,{children:"pnpm run dev"}),"之后你可以看到如下界面，表示项目已经成功启动啦。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["紧接着，我们立马去浏览器中打开",(0,s.jsx)(n.code,{children:"http://localhost:3000"}),"页面，你可以看到："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["至此，我们成功搭建起了一个 React 前端项目。怎么样？利用 Vite 来初始化一个前端项目是不是非常简单？经过初步尝试，Vite 给人的第一感觉就是简洁、轻量、快速。我曾经拿 react 官方基于 Webpack 的脚手架",(0,s.jsx)(n.code,{children:"create-react-app"}),"，也就是大家常说的",(0,s.jsx)(n.code,{children:"cra"}),"来测试过，从项目初始化到依赖安装所花的时间与 Vite 对比如下:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"Vite 已经比 cra 快了接近 6 倍，并且一开始就甩了 cra 一大截，显而易见地提升了初始化速度和开发体验。"}),"\n",(0,s.jsxs)(n.h2,{id:"项目入口加载",children:["项目入口加载",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#项目入口加载",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"言归正传，我们继续学习 Vite 初始化后的项目。项目的目录结构如下:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:".\n├── index.html\n├── package.json\n├── pnpm-lock.yaml\n├── src\n│   ├── App.css\n│   ├── App.tsx\n│   ├── favicon.svg\n│   ├── index.css\n│   ├── logo.svg\n│   ├── main.tsx\n│   └── vite-env.d.ts\n├── tsconfig.json\n└── vite.config.ts\n"})}),"\n",(0,s.jsxs)(n.p,{children:["值得注意的是，在项目根目录中有一个",(0,s.jsx)(n.code,{children:"index.html"}),"文件，这个文件十分关键，因为 Vite 默认会把项目根目录下的",(0,s.jsx)(n.code,{children:"index.html"}),"作为入口文件。也就是说，当你访问",(0,s.jsx)(n.code,{children:"http://localhost:3000"}),"的时候，Vite 的 Dev Server 会自动返回这个 HTML 文件的内容。我们来看看这个 HTML 究竟写了什么:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite App</title>\n  </head>\n  <body>\n    <div id="root"></div>\n    <script type="module" src="/src/main.tsx"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到这个 HTML 文件的内容非常简洁，在 ",(0,s.jsx)(n.code,{children:"body"})," 标签中除了 id 为 root 的根节点之外，还包含了一个声明了",(0,s.jsx)(n.code,{children:'type="module"'}),"的 ",(0,s.jsx)(n.code,{children:"script"})," 标签:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<script type="module" src="/src/main.tsx"><\/script>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["由于现代浏览器原生支持了 ES 模块规范，因此原生的 ES 语法也可以直接放到浏览器中执行，只需要在 script 标签中声明 ",(0,s.jsx)(n.code,{children:'type="module"'}),' 即可。比如上面的 script 标签就声明了 type="module"，同时 src 指向了',(0,s.jsx)(n.code,{children:"/src/main.tsx"}),"文件，此时相当于请求了",(0,s.jsx)(n.code,{children:"http://localhost:3000/src/main.tsx"}),"这个资源，Vite 的 Dev Server 此时会接受到这个请求，然后读取对应的文件内容，进行一定的中间处理，最后将处理的结果返回给浏览器。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["我们可以来看看 ",(0,s.jsx)(n.code,{children:"main.tsx"})," 的内容:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"})}),"\n",(0,s.jsx)(n.p,{children:"到这里可能你会诧异: 浏览器并不识别 tsx 语法，也无法直接 import css 文件，上面这段代码究竟是如何被浏览器正常执行的呢？"}),"\n",(0,s.jsxs)(n.p,{children:["这就归功了 Vite Dev Server 所做的“中间处理”了，也就是说，在读取到 ",(0,s.jsx)(n.code,{children:"main.tsx"}),"文件的内容之后，Vite 会对文件的内容进行编译，大家可以从 Chrome 的网络调试面板看到编译后的结果:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"当然，大家不用纠结每句代码的含义，因为这涉及 Vite 内部的编译流程，我们会在后面的章节深入分析。这里你只需要知道，Vite 会将项目的源代码编译成浏览器可以识别的代码，与此同时，一个 import 语句即代表了一个 HTTP 请求，如下面两个 import 语句:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import "/src/index.css";\nimport App from "/src/App.tsx";\n'})}),"\n",(0,s.jsxs)(n.p,{children:["需要注意的是，在 Vite 项目中，一个",(0,s.jsx)(n.code,{children:"import 语句即代表一个 HTTP 请求"}),"。上述两个语句则分别代表了两个不同的请求，Vite Dev Server 会读取本地文件，返回浏览器可以解析的代码。当浏览器解析到新的 import 语句，又会发出新的请求，以此类推，直到所有的资源都加载完成。"]}),"\n",(0,s.jsxs)(n.p,{children:["现在，你应该知道了 Vite 所倡导的",(0,s.jsx)(n.code,{children:"no-bundle"}),"理念的真正含义: ",(0,s.jsx)(n.strong,{children:"利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载"}),"，而不是",(0,s.jsx)(n.strong,{children:"先整体打包再进行加载"}),"。相比 Webpack 这种必须打包再加载的传统构建模式，Vite 在开发阶段省略了繁琐且耗时的打包过程，这也是它为什么快的一个重要原因。"]}),"\n",(0,s.jsxs)(n.h2,{id:"初识配置文件",children:["初识配置文件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初识配置文件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在使用 Vite 的过程，我们需要对 Vite 做一些配置，以满足日常开发的需要。你可以通过两种方式来对 Vite 进行配置，一是通过命令行参数，如",(0,s.jsx)(n.code,{children:"vite --port=8888"}),"，二是通过配置文件，一般情况下，大多数的配置都通过配置文件的方式来声明。"]}),"\n",(0,s.jsxs)(n.p,{children:["Vite 当中支持多种配置文件类型，包括",(0,s.jsx)(n.code,{children:".js"}),"、",(0,s.jsx)(n.code,{children:".ts"}),"、",(0,s.jsx)(n.code,{children:".mjs"}),"三种后缀的文件，实际项目中一般使用",(0,s.jsx)(n.code,{children:"vite.config.ts"}),"作为配置文件，以脚手架项目中的配置为例，具体的配置代码如下:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()]\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以看到配置文件中默认在 ",(0,s.jsx)(n.code,{children:"plugins"})," 数组中配置了官方的 react 插件，来提供 React 项目编译和热更新的功能。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来，我们可以基于这个文件完成更加丰富的配置。之前我就遇到过这样一个需求: 页面的入口文件",(0,s.jsx)(n.code,{children:"index.html"}),"并不在项目根目录下，而需要放到 ",(0,s.jsx)(n.code,{children:"src"})," 目录下，如何在访问",(0,s.jsx)(n.code,{children:"localhost:3000"}),"的时候让 Vite 自动返回 src 目录下的",(0,s.jsx)(n.code,{children:"index.html"}),"呢？我们可以通过",(0,s.jsx)(n.code,{children:"root"}),"参数配置项目根目录的位置:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// vite.config.ts\nimport { defineConfig } from 'vite'\n// 引入 path 包注意两点:\n// 1. 为避免类型报错，你需要通过 `pnpm i @types/node -D` 安装类型\n// 2. tsconfig.node.json 中设置 `allowSyntheticDefaultImports: true`，以允许下面的 default 导入方式\nimport path from 'path'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  // 手动指定项目根目录位置\n  root: path.join(__dirname, 'src')\n  plugins: [react()]\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当手动指定",(0,s.jsx)(n.code,{children:"root"}),"参数之后，Vite 会自动从这个路径下寻找",(0,s.jsx)(n.code,{children:"index.html"}),"文件，也就是说当我直接访问 ",(0,s.jsx)(n.code,{children:"localhost:3000"}),"的时候，Vite 从",(0,s.jsx)(n.code,{children:"src"}),"目录下读取入口文件，这样就成功实现了刚才的需求。"]}),"\n",(0,s.jsx)(n.p,{children:"当然，这只是让你体验了一个简单的配置案例，在 Vite 中还有非常多的配置，由于篇幅所限，本文就不再逐个进行演示了，对于一些经常使用或者比较难理解的配置，后面的文章中会给大家一一介绍。"}),"\n",(0,s.jsxs)(n.h2,{id:"生产环境构建",children:["生产环境构建",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#生产环境构建",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["有人说",(0,s.jsx)(n.code,{children:"Vite"}),"因为其不打包的特性而不能上生产环境，其实这种观点是相当有误的。在开发阶段 Vite 通过 Dev Server 实现了不打包的特性，而在生产环境中，Vite 依然会基于 Rollup 进行打包，并采取一系列的打包优化手段。从脚手架项目的",(0,s.jsx)(n.code,{children:"package.json"}),"中就可见一斑："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'"scripts": {\n  // 开发阶段启动 Vite Dev Server\n  "dev": "vite",\n  // 生产环境打包\n  "build": "tsc && vite build",\n  // 生产环境打包完预览产物\n  "preview": "vite preview"\n},\n'})}),"\n",(0,s.jsxs)(n.p,{children:["相信你已经注意到其中的",(0,s.jsx)(n.code,{children:"build"}),"命令了，没错，这个命令就是 Vite 专门用来进行生产环境打包的。但可能你会有点疑惑，为什么在",(0,s.jsx)(n.code,{children:"vite build"}),"命令执行之前要先执行",(0,s.jsx)(n.code,{children:"tsc"}),"呢？"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"tsc"})," 作为 TypeScript 的官方编译命令，可以用来编译 TypeScript 代码并进行类型检查，而这里的作用主要是用来做类型检查，我们可以从项目的",(0,s.jsx)(n.code,{children:"tsconfig.json"}),"中注意到这样一个配置:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'{\n  "compilerOptions": {\n    // 省略其他配置\n    // 1. noEmit 表示只做类型检查，而不会输出产物文件\n    // 2. 这行配置与 tsc --noEmit 命令等效\n    "noEmit": true,\n  },\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["虽然 Vite 提供了开箱即用的 TypeScript 以及 JSX 的编译能力，但实际上底层并没有实现 TypeScript 的类型校验系统，因此需要借助 ",(0,s.jsx)(n.code,{children:"tsc"})," 来完成类型校验(在 Vue 项目中使用 ",(0,s.jsx)(n.code,{children:"vue-tsc"})," 这个工具来完成)，在打包前提早暴露出类型相关的问题，保证代码的健壮性。"]}),"\n",(0,s.jsx)(n.p,{children:"接下来你可以试着执行一下这个打包命令:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["此时 Vite 已经生成了最终的打包产物，我们可以通过 ",(0,s.jsx)(n.code,{children:"pnpm run preview"})," 命令预览一下打包产物的执行效果。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["在浏览器中打开",(0,s.jsx)(n.code,{children:"http://localhost:5000"}),"地址，你将看到和开发阶段一样的页面内容，证明我们成功完成第一个 Vite 项目的生产环境构建。"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"恭喜你完成了本节的学习！在这一小节中，我们正式地开始近距离接触 Vite，使用它来初始化第一个 Vite 项目。"}),"\n",(0,s.jsx)(n.p,{children:"在最开始，我们一起搭建了基本的前端开发环境，安装常用的编辑器、浏览器、Node.js 环境及包管理器 pnpm，接着我和你使用 Vite 的初始化命令创建一个 React 项目并成功启动，让你真切地体验到 Vite 的快速和轻量。"}),"\n",(0,s.jsxs)(n.p,{children:["项目启动之后我也与你分析了项目背后的启动流程，强调了",(0,s.jsx)(n.code,{children:"一个 import 语句代表一个 HTTP 请求"}),"，而正是 Vite 的 Dev Server 来接收这些请求、进行文件转译以及返回浏览器可以运行的代码，从而让项目正常运行。"]}),"\n",(0,s.jsx)(n.p,{children:"不仅如此，我还带你一起初步接触了 Vite 的配置文件，并尝试进行生产环境的打包，为下一节的学习作下了铺垫。在下一小节中，我们将通过 Vite 搭建起一个相对完整的工程化项目框架，你也将会面临更多的开发场景和挑战，逐渐对 Vite 的使用轻车熟路，让我们下一节再见！"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}let g=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F3.%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B_%20%E5%A6%82%E4%BD%95%E7%94%A8%20Vite%20%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%EF%BC%9F.md"]={toc:[{text:"环境搭建",id:"环境搭建",depth:2},{text:"项目初始化",id:"项目初始化",depth:2},{text:"项目入口加载",id:"项目入口加载",depth:2},{text:"初识配置文件",id:"初识配置文件",depth:2},{text:"生产环境构建",id:"生产环境构建",depth:2},{text:"小结",id:"小结",depth:2}],title:"3.快速上手_ 如何用 Vite 从零搭建前端项目？",headingTitle:"3.快速上手_ 如何用 Vite 从零搭建前端项目？",frontmatter:{}}}}]);