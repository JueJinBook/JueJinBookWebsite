"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["80351"],{390495:function(e,n,t){t.r(n),t.d(n,{default:()=>C});var r=t(552676),s=t(740453);let o=t.p+"static/image/72ddd1930978098e31274f0c1737e652.4cedbd2d.webp",c=t.p+"static/image/0916395a1fbe27751c5e4680d59b81ec.ae6dd0b7.webp",l=t.p+"static/image/ae575a9dc560c5fc45ef7c56a035ae67.240b641a.webp",i=t.p+"static/image/306d260bfc115c8278414e359c8148c1.4a3e4131.webp",d=t.p+"static/image/e41b509b99c69b47783941e6b244a767.fb358a47.webp",a=t.p+"static/image/366c583a71e05c54d720616b3a4236cb.36f4914c.webp",h=t.p+"static/image/8d969b8af58cd85d816d38c0f4da4702.bd2bf642.webp",p=t.p+"static/image/45c5d7fc778c0cadd8928bd47862a8c7.59f67e3f.webp",x=t.p+"static/image/a795ef23f4a178df2bc3052caea7f5fd.b5190fb6.webp",u=t.p+"static/image/b23665f37f469003bf14513002e3cfd6.9d47589c.webp",v=t.p+"static/image/eca247a5f5a4fca39e942b0f27f36fb5.f96764d8.webp",j=t.p+"static/image/f7df6a513c6bf4bc9871b48b2d2109d2.ebdb75c3.webp",b=t.p+"static/image/d61a5c87abcf8727ca58a86896e45663.cf5350b3.webp",m=t.p+"static/image/39f296822b97300886ef3f239a067158.04fcc3f1.webp",f=t.p+"static/image/1482c61183d3769baed17c96ae61e04b.b30d9b26.webp";function g(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",ol:"ol",li:"li",strong:"strong",h3:"h3"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"8-语法篇--context-与-store",children:["8-语法篇 ❘ Context 与 Store",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-语法篇--context-与-store",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"推荐学习指数：⭐️⭐"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本篇我们讲解 Svelte 中的重要概念 —— Context 和 Store。Context 负责数据传递，Store 是 Svelte 内置的状态管理方案。在实际开发中，两者可以独自使用，也可以搭配在一起使用。"}),"\n",(0,r.jsx)(n.p,{children:"那就让我们来看看怎么使用吧！"}),"\n",(0,r.jsxs)(n.h2,{id:"2-context",children:["2. Context",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-context",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Svelte 的 Context 概念类似于 React 的 Context，可以让组件向它的子孙组件们发送数据。举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Parent1 from './Parent1.svelte';\n  import Parent2 from './Parent2.svelte';\n<\/script>\n\n<Parent1 />\n<Parent2 />\n\n\x3c!-- Parent1.svelte --\x3e\n<script>\n  import Child from './Child.svelte';\n\n  import { setContext } from 'svelte';\n\n  setContext('color', 'red')\n<\/script>\n\n<Child />\n\n\x3c!-- Parent2.svelte --\x3e\n<script>\n  import Child from './Child.svelte';\n\n  import { setContext } from 'svelte';\n\n  setContext('color', 'blue')\n<\/script>\n\n<Child />\n\n\x3c!-- Child.svelte --\x3e\n<script>\n  import GrandChild from './GrandChild.svelte';\n<\/script>\n\n<GrandChild />\n\n\x3c!-- GrandChild.svelte --\x3e\n<script>\n  import { getContext } from 'svelte';\n  const color = getContext('color')\n<\/script>\n\n<div style=\"color: {color}\">GrandChild {color}</div>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Context 核心就两个 API，父组件 ",(0,r.jsx)(n.code,{children:"setContext()"}),"，子孙组件 ",(0,r.jsx)(n.code,{children:"getContext()"}),"。在这段代码中，虽然",(0,r.jsx)(n.code,{children:"<GrandChild>"})," 组件都是",(0,r.jsx)(n.code,{children:"getContext('color')"}),"，但因为我们在 ",(0,r.jsx)(n.code,{children:"<Parent>"})," 组件 ",(0,r.jsx)(n.code,{children:"setContext()"})," 设置的值不同，所以最终取的值也不同。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/6ad5c97f65fd4feb9042c620aaf47811?version=4.2.18",title:"https://svelte.dev/repl/6ad5c97f65fd4feb9042c620aaf47811?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"使用 Context 时要注意："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"与生命周期函数一样，setContext 和 getContext 要在组件初始化的时候调用"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'// ❌ 这样写是会报错的\n<button\n  on:click={() => {\n    setContext("color", "green");\n  }}\n>\n  Set New Color\n</button>\n'})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Context 并不是响应式的，也就是说修改 context 的值，子组件并不会重新渲染"})}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"// ❌ 这样写是不会生效的\n<script>\n  import Child from './Child.svelte';\n  let color = 'red'\n  import { setContext } from 'svelte';\n\n  setContext('color', color)\n<\/script>\n\n<Child />\n\n<button on:click={() => {\n  color = 'green'\n}}>Set New Color</button>\n"})}),"\n",(0,r.jsx)(n.p,{children:"Context 既不能修改，又不是响应式，功能好像立刻就显得“鸡肋”了些。先不要着急，如果要实现修改和响应式，可以搭配接下来要讲的 Store 一起实现。"}),"\n",(0,r.jsxs)(n.h2,{id:"3-stores",children:["3. Stores",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-stores",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"31-store-示例",children:["3.1. Store 示例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-store-示例",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果要使用 Store，首先要进行声明："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'// stores.js\nimport { writable } from "svelte/store";\n\nexport const count = writable(0);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这里我们就创建了一个 ",(0,r.jsx)(n.code,{children:"Store"}),"，",(0,r.jsx)(n.code,{children:"writable(0)"})," 表示可读可写，初始值为 ",(0,r.jsx)(n.code,{children:"0"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果有组件想要监听 Store 中值的变化，需要调用 Store 的 ",(0,r.jsx)(n.code,{children:"subscribe()"})," 函数订阅 ",(0,r.jsx)(n.code,{children:"count"})," 值的更新："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"// App.svelte\n<script>\n  import { count } from './stores.js';\n  import Incrementer from './Incrementer.svelte';\n  import Decrementer from './Decrementer.svelte';\n  import Resetter from './Resetter.svelte';\n\n  let countValue;\n\n  const unsubscribe = count.subscribe((value) => {\n    countValue = value;\n  });\n<\/script>\n\n<h1>The count is {countValue}</h1>\n\n<Incrementer />\n<Decrementer />\n<Resetter />\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如果要更改 Store 中的值，需要调用 Store 的 ",(0,r.jsx)(n.code,{children:"update()"})," 方法："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Decrementer.svelte --\x3e\n<script>\n  import { count } from './stores.js';\n\n  function decrement() {\n    count.update((n) => n - 1);\n  }\n<\/script>\n\n<button on:click={decrement}> - </button>\n\n\x3c!-- Incrementer.svelte --\x3e\n<script>\n  import { count } from './stores.js';\n\n  function increment() {\n    count.update((n) => n + 1);\n  }\n<\/script>\n\n<button on:click={increment}> + </button>\n\n\n\x3c!-- Resetter.svelte --\x3e\n<script>\n  import { count } from './stores.js';\n\n  function reset() {\n    count.set(0);\n  }\n<\/script>\n\n<button on:click={reset}> reset </button>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/examples/writable-stores",title:"https://svelte.dev/examples/writable-stores",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"32-store-实现原理",children:["3.2. Store 实现原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-store-实现原理",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["从 ",(0,r.jsx)(n.code,{children:"subscribe()"})," 和 ",(0,r.jsx)(n.code,{children:"update()"})," 函数名想必大家已经想到了，Store 本质就是一个发布订阅模式，就算不用 Svelte 提供的 Store，我们自己也可以写一个。"]}),"\n",(0,r.jsxs)(n.p,{children:["依然是用刚才的示例代码，我们将 ",(0,r.jsx)(n.code,{children:"stores.js"})," 的代码改为："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"let subscribes = [];\n\nexport const count = {\n  value: 0,\n  set: function (newValue) {\n    this.update(() => newValue);\n  },\n  update: function (fn) {\n    this.value = fn(this.value);\n    subscribes.forEach((fn) => {\n      fn(this.value);\n    });\n  },\n  subscribe: function (fn) {\n    subscribes.push(fn);\n    this.update(() => this.value);\n\n    return function unsubscribe(fn) {\n      subscribes.splice(subscribes.indexOf(fn), 1);\n    };\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/9d6eb40deb784100ae93fbcccd8792d8?version=4.2.18",title:"https://svelte.dev/repl/9d6eb40deb784100ae93fbcccd8792d8?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果不变"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们自己就实现了一个简易的 Store！"}),"\n",(0,r.jsxs)(n.h3,{id:"33-自动订阅auto-subscriptions",children:["3.3. 自动订阅（Auto-subscriptions）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-自动订阅auto-subscriptions",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"但想必你也发现了，使用 Store 有些麻烦……每次监听 Store 值的变化，还要调用订阅函数。举个例子，这是原本要写的代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n   import Input from './Input.svelte'\n   import Title from './Title.svelte'\n<\/script>\n\n<Input />\n<Title />\n\n\x3c!-- Input.svelte --\x3e\n<script>\n  import { count } from './stores';\n<\/script>\n\n<input on:input={(e) => { count.set(e.currentTarget.value) }} />\n\n\x3c!-- Title.svelte --\x3e\n<script>\n  import { count } from './stores';\n  import { onMount } from 'svelte';\n\n  let count_value;\n\n  onMount(() => {\n    return count.subscribe(value => {\n      count_value = value;\n    })\n  });\n<\/script>\n\n<h1>{count_value}</h1>\n\n\x3c!-- stores.js --\x3e\nimport { writable } from 'svelte/store';\n\nexport const count = writable('');\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，为了获取 Store 中的 ",(0,r.jsx)(n.code,{children:"count"})," 值，需要先声明一个 ",(0,r.jsx)(n.code,{children:"count_value"}),"，然后在 ",(0,r.jsx)(n.code,{children:"onMount"})," 的时候调用 Store 的 ",(0,r.jsx)(n.code,{children:"subscribe()"})," 函数，修改 ",(0,r.jsx)(n.code,{children:"count_value"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/d7c2c685bb114cafa4fe0d5239e8b3b2?version=4.2.18",title:"https://svelte.dev/repl/d7c2c685bb114cafa4fe0d5239e8b3b2?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["每次这样写着实有些麻烦，Svelte 提供了自动订阅语法，在 Store 变量前添加 ",(0,r.jsx)(n.code,{children:"$"})," 前缀即可。还是刚才的例子，使用自动订阅语法后："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-diff",children:"// Input.svelte\n<script>\n  import { count } from './stores';\n<\/script>\n\n-<input on:input={(e) => { count.set(e.currentTarget.value) }} />\n+<input on:input={(e) => { $count = e.currentTarget.value }} />\n\n// Title.svelte\n<script>\n  import { count } from './stores';\n  import { onMount } from 'svelte';\n\n- let count_value;\n\n- onMount(() => {\n-      return count.subscribe(value => {\n-            count_value = value;\n-      })\n- });\n\n<\/script>\n\n-<h1>{count_value}</h1>\n\n+<h1>{$count}</h1>\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/b90f26dddb3a4ef9af1e9c234e406a26?version=4.2.18",title:"https://svelte.dev/repl/b90f26dddb3a4ef9af1e9c234e406a26?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果不变"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["使用 ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"$"})}),"，可以自动建立订阅、自动注销订阅，set 值的时候也更加简洁"]}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"34-store-contract",children:["3.4. Store contract",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34-store-contract",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["初学的时候，可能会以为 ",(0,r.jsx)(n.code,{children:"$"}),"就是专门用于为 Svelte 的 Store 实现自动订阅，但实际上，",(0,r.jsx)(n.code,{children:"$"}),"也可以用于符合规范的 Store，这个规范就叫做 “Store contract”。"]}),"\n",(0,r.jsx)(n.p,{children:"这个规范内容很简单："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"store = { subscribe: (subscription: (value: any) => void) => (() => void), set?: (value: any) => void }\n"})}),"\n",(0,r.jsx)(n.p,{children:"简单来说就是 3 点要求："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Store 必须包含一个 ",(0,r.jsx)(n.code,{children:"subscribe()"})," 函数，该函数接收一个订阅函数作为参数"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"subscribe()"})," 函数必须返回一个取消订阅函数"]}),"\n",(0,r.jsxs)(n.li,{children:["此条可选，包含一个 ",(0,r.jsx)(n.code,{children:"set"}),"方法"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["只要你的 Store 符合这个规范，那就可以使用 ",(0,r.jsx)(n.code,{children:"$"}),"自动订阅。"]}),"\n",(0,r.jsxs)(n.p,{children:["比如刚才的例子，我们把 ",(0,r.jsx)(n.code,{children:"stores.js"})," 中的代码换成我们手写的 Store，同样可以使用 ",(0,r.jsx)(n.code,{children:"$"}),"。",(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/d809e6a0c8b1448eb3df1726c73729dc?version=4.2.18",title:"https://svelte.dev/repl/d809e6a0c8b1448eb3df1726c73729dc?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["掌握 Store contract 和 ",(0,r.jsx)(n.code,{children:"$"}),"的使用很重要。"]})," 我给大家举一个实际开发中可能会遇到的例子，比如监听鼠标移动，正常你会这样写："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<script>\n  import { onMount } from \'svelte\';\n  let x = 0, y = 0;\n\n  onMount(() => {\n    function move({clientX, clientY}) {\n        x = clientX\n        y = clientY\n    }\n    window.addEventListener("mousemove", move)\n    return () => {\n      window.removeEventListener("mousemove", move)\n    }\n  })\n<\/script>\n\n<h1>x: {x} y: {y}</h1>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/8525d5883064421b920e59a03fa91adc?version=4.2.18",title:"https://svelte.dev/repl/8525d5883064421b920e59a03fa91adc?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但如果多个组件都需要用到这个值呢？如果是 React，我们很可能会写一个 useMousemove Hook，在 Svelte 中该怎么办呢？"}),"\n",(0,r.jsx)(n.p,{children:"让我们再细看上面的这段代码，你会发现，其实它跟 Store 的逻辑很像！都是监听值的变化。都是组件初始化的时候，注册一个事件，这个例子中是 addEventListener，Store 中是 subscribe。组件注销的时候，都要取消，这个例子中是 removeEventListener，Store 中是调用 subscribe 返回的 unsubscribe 函数。"}),"\n",(0,r.jsx)(n.p,{children:"这个时候就可以按照 Store contract 创建一个自己的 Store！"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- App.svelte --\x3e\n<script>\n  import mousePostion from \'./useMousemove.js\'\n<\/script>\n\n<h1>x: {$mousePostion.x} y: {$mousePostion.y}</h1>\n\n\x3c!-- useMousemove.js --\x3e\nconst store = {\n  subscribe(fn) {\n    fn({ x:0, y:0 })\n\n    function move({clientX, clientY}) {\n      fn({ x:clientX, y:clientY })\n    }\n    window.addEventListener("mousemove", move)\n    return () => {\n      window.removeEventListener("mousemove", move)\n    }\n  }\n}\n\nexport default store\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/bc0afebde86e44a18895ace79f6d0b9a?version=4.2.18",title:"https://svelte.dev/repl/bc0afebde86e44a18895ace79f6d0b9a?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"35-readable-store",children:["3.5. Readable Store",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#35-readable-store",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Svelte 的 Store 有 Writable 的，也有 Readable 的。它们的差别顾名思义，那就是 Readable 的值无法从外部修改，也就是没有 set 方法。"}),"\n",(0,r.jsx)(n.p,{children:"文档中举的例子都是在内部设置定时器，外部读取。这可能让开发者觉得 readable Store 有些鸡肋。其实监听鼠标移动的这个例子就很适合用 Readable，我们用 Readable Store 重新实现下刚才的例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import mousePostion from './useMousemove.js'\n<\/script>\n\n<h1>x: {$mousePostion.x} y: {$mousePostion.y}</h1>\n\n\x3c!-- useMousemove.js --\x3e\nimport { readable } from 'svelte/store';\n\nexport default readable({ x:0, y:0 }, (set) => {\n  window.addEventListener(\"mousemove\", move);\n\n  function move({ clientX, clientY }) {\n    set({\n      x: clientX,\n      y: clientY,\n    });\n  }\n\n  return () => {\n    window.removeEventListener(\"mousemove\", move);\n  }\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/981d2cd12d5643f7a2bf4680a0a44bc9?version=4.2.18",title:"https://svelte.dev/repl/981d2cd12d5643f7a2bf4680a0a44bc9?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"36-derived-store",children:["3.6. Derived Store",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36-derived-store",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Derived Store 类似于响应式声明，相当于响应式声明的 Store 版。我们举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { writable, derived } from 'svelte/store';\n  const count = writable(0);\n  const doubled = derived(count, ($count) => $count * 2);\n<\/script>\n\n<input type=\"number\" bind:value={$count}>\n<p>{$count} * 2 = {$doubled}</p>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["响应式声明是监听值的变化，Derived Store 是监听 Store 值的变化。",(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/40860b7fdab245a081818309d868d622?version=4.2.18",title:"https://svelte.dev/repl/40860b7fdab245a081818309d868d622?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["其实 Tutorial 中介绍的有些单薄，如果查看 ",(0,r.jsx)(n.a,{href:"https://svelte.dev/docs/svelte-store#derived",title:"https://svelte.dev/docs/svelte-store#derived",target:"_blank",rel:"noopener noreferrer",children:"derived Store 的 API 文档"}),"，介绍更加全面，它支持单个值，也支持多个值，支持同步，也支持异步。我们举个更复杂的例子："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  import { writable, derived } from 'svelte/store';\n  const count1 = writable(0);\n  const count2 = writable(0);\n  // const doubled = derived([count1, count2], ([$count1, $count2]) => $count1 * $count2);\n  const doubled = derived([count1, count2], ([$count1, $count2], set) => {\n    const timeout = setInterval(() => {\n      set($count1 * $count2);\n    }, 1000);\n\n    return () => {\n      console.log('cancel')\n      clearTimeout(timeout);\n    };\n  }, 'loading');\n<\/script>\n\n<input type=\"number\" bind:value={$count1}> * <input type=\"number\" bind:value={$count2}>\n<p>{$count1} * {$count2} = {$doubled}</p>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，我们使用 ",(0,r.jsx)(n.code,{children:"derived()"})," 监听了 ",(0,r.jsx)(n.code,{children:"count1"})," 和 ",(0,r.jsx)(n.code,{children:"count2"})," 值的变化。",(0,r.jsx)(n.code,{children:"derived()"})," 函数的第二个参数是一个函数，我们可以直接返回一个值，表示计算的最终值。但如果要在异步函数中设置计算的最终值，则要使用 ",(0,r.jsx)(n.code,{children:"set()"}),"函数 。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/b827aac00dd74573863f4597671c8c98?version=4.2.18",title:"https://svelte.dev/repl/b827aac00dd74573863f4597671c8c98?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"37-high-order-store",children:["3.7. High Order Store",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#37-high-order-store",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Svelte 提供了一个 ",(0,r.jsx)(n.a,{href:"https://svelte.dev/docs/svelte-store#readonly",title:"https://svelte.dev/docs/svelte-store#readonly",target:"_blank",rel:"noopener noreferrer",children:"readonly"})," 辅助函数，可以将 Store 的值变为只读："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { readonly, writable } from "svelte/store";\n\nconst writableStore = writable(1);\nconst readableStore = readonly(writableStore);\n\nreadableStore.subscribe(console.log);\n\nwritableStore.set(2); // console: 2\nreadableStore.set(2); // ERROR\n'})}),"\n",(0,r.jsx)(n.p,{children:"重点不在于 readonly 的作用，而是 readonly 怎么实现的。其实我们自己也可以实现一个 readonly 辅助函数："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import {writable} from 'svelte/store'; import readonly from './readonly';\n  const writableStore = writable(1); let readableStore =\n  readonly(writableStore); readableStore.subscribe(console.log);\n  writableStore.set(2); // console: 2 readableStore.set(2); // ERROR\n<\/script>;\n\n\x3c!-- readonly.js --\x3e\nexport default function readonly(store) {\n  return {\n    subscribe: store.subscribe,\n    set() {\n      throw new Error(\"Unable to set value of a readonly store\");\n    },\n  };\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/8b3be76e1fe94dfe8b73d8e6e8c68ab8?version=4.2.18",title:"https://svelte.dev/repl/8b3be76e1fe94dfe8b73d8e6e8c68ab8?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下："})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个 readonly 的实现就是我们要介绍的内容。我们知道 High Order Component 是返回组件的组件，High Order Store 与之类似，是返回 Store 的 Store，作用在于加强 Store 的功能。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注意：当然 Svelte 官方文档里并没有 High Order Store 的介绍。只不过是借鉴了 High Order Component 取了这个名字。你可以把它理解为一种 Svelte 小技巧。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"比如我们之前实现过一个监听鼠标值的 useMousemove，但它会频繁的触发更新，如果我们想要加一个节流的效果呢？"}),"\n",(0,r.jsx)(n.p,{children:"我们当然可以直接在原代码里加上，但更好的做法是写一个专门实现节流的 Store，这样“关注点分离”，代码更加清晰合理："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import mousePostion from './useMousemove.js'\n  import withThrottle from './withThrottle.js'\n\n  const postion = withThrottle(mousePostion)\n<\/script>\n\n<h1>x: {$postion.x} y: {$postion.y}</h1>\n\n\x3c!-- useMousemove.js --\x3e\nimport { readable } from 'svelte/store';\n\nexport default readable({ x:0, y:0 }, (set) => {\n  window.addEventListener(\"mousemove\", move);\n\n  function move({ clientX, clientY }) {\n    set({\n      x: clientX,\n      y: clientY,\n    });\n  }\n\n  return () => {\n    window.removeEventListener(\"mousemove\", move);\n  }\n})\n\n\x3c!-- withThrottle.js --\x3e\nimport { derived } from 'svelte/store';\n\nexport default function (store) {\n  let previous = 0;\n  return derived(store, (value, set) => {\n    let now = Date.now();\n    if (now - previous > 1000) {\n      set(value);\n      previous = now;\n    }\n  });\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，我们实现了一个 ",(0,r.jsx)(n.code,{children:"useMousemove"})," 获取鼠标的值，又实现了一个 ",(0,r.jsx)(n.code,{children:"withThrottle"})," 实现节流。当调用 ",(0,r.jsx)(n.code,{children:"withThrottle(mousePostion)"}),"的时候，它会返回一个名为 ",(0,r.jsx)(n.code,{children:"position"})," 的 Store，我们使用 ",(0,r.jsx)(n.code,{children:"$postion"}),"就可以获取节流后的鼠标位置。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/f9057c03d2da401184c777a10fbaf6fb?version=4.2.18",title:"https://svelte.dev/repl/f9057c03d2da401184c777a10fbaf6fb?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"38-get",children:["3.8. get()",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#38-get",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Svelte Store 提供了 ",(0,r.jsx)(n.code,{children:"get()"})," 方法用于获取 Store 的值："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { get } from "svelte/store";\n\nconst value = get(store);\n'})}),"\n",(0,r.jsxs)(n.p,{children:["正如",(0,r.jsx)(n.a,{href:"https://svelte.dev/docs/svelte-store#get",title:"https://svelte.dev/docs/svelte-store#get",target:"_blank",rel:"noopener noreferrer",children:"官方文档"}),"里说明的那样，",(0,r.jsx)(n.code,{children:"get()"})," 是通过创建订阅、读取值，然后取消订阅来实现的。所以它相当于："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function get(store) {\n  let _value;\n  const unsubscribe = store.subscribe((value) => {\n    _value = value;\n  });\n  unsubscribe();\n  return _value;\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"4-context-与-store",children:["4. Context 与 Store",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-context-与-store",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"41-context-vs-store",children:["4.1. Context vs Store",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-context-vs-store",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"那么你可能要问了，Context 和 Store 的区别是什么呢？"}),"\n",(0,r.jsx)(n.p,{children:"Context 解决的是组件和所有子组件共享数据的问题，比如一个博客组件，它需要将 BlogId 传给博客组件下的评论组件、点赞组件，这些组件才能知道评论点赞的是哪篇博客，这个时候就需要 Context。"}),"\n",(0,r.jsx)(n.p,{children:"Store 通过发布订阅实现响应式，所有引入 Store 的组件都可以获取其值，修改其值，从而实现了数据共享。比如页面的主题色，如果修改了，所有组件的样式都应该随之修改。"}),"\n",(0,r.jsx)(n.p,{children:"我个人认为非要用 Store 替代 Context 也不是不可以，但很多时候没有必要。比如当我们使用双向绑定："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<input type="number" bind:value={$data}>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["如果 ",(0,r.jsx)(n.code,{children:"$data"})," 来自于 Store，修改输入框的值会修改所有用到这个 Store 的组件。但如果 ",(0,r.jsx)(n.code,{children:"$data"})," 来自于 Context，则不会产生任何影响。"]}),"\n",(0,r.jsx)(n.p,{children:"实际上，Context 和 Store 使用上并不冲突，完全可以一起使用，这就是 Reactive Context。它结合了两者的优点，Context 控制了组件的影响范围，Store 将状态共享。"}),"\n",(0,r.jsxs)(n.h3,{id:"42-reactive-context",children:["4.2. Reactive Context",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-reactive-context",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"之前讲 Context 的时候讲到目前 Context 的实现并不是响应式的，举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import Parent from './Parent.svelte';\n  import { setContext } from 'svelte';\n\n  let count = 0;\n  setContext('count', count)\n<\/script>\n\nFrom App.svelte: {count}\n<button on:click={() => {count += 1}}>\n  Increment\n</button>\n\n<Parent />\n\n\x3c!-- Parent.svelte --\x3e\n<script>\n  import Child from './Child.svelte';\n<\/script>\n\n<Child />\n\n\x3c!-- Child.svelte --\x3e\n<script>\n  import { getContext } from 'svelte';\n\n  let count = getContext('count');\n<\/script>\n\n<div>\n  From Child.svelte: { count }\n</div>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["当顶层的 count 值发生改变的时候，子组件中的 count 值并不会改变。",(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/eb00d4a2711e4bf7b87d90beaae37d44?version=4.2.18",title:"https://svelte.dev/repl/eb00d4a2711e4bf7b87d90beaae37d44?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如何让子组件的 count 值也随之变化呢？Context + Store 就可以成为 Reactive Context。修改代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\x3c!-- App.svelte --\x3e\n<script>\n  import { setContext } from 'svelte';\n  import { writable } from 'svelte/store';\n\n  import Parent from './Parent.svelte';\n  let count = writable(0);\n  setContext('count', count)\n<\/script>\n\nFrom App.svelte: {$count}\n<button on:click={() => {$count += 1}}>\n  Increment\n</button>\n\n<Parent />\n\n\x3c!-- Parent.svelte --\x3e\n<script>\n  import Child from './Child.svelte';\n<\/script>\n\n<Child />\n\n\x3c!-- Child.svelte --\x3e\n<script>\n  import { getContext } from 'svelte';\n\n  let count = getContext('count');\n<\/script>\n\n<div>\n  From Child.svelte: { $count }\n</div>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["当顶层的 count 值发生改变的时候，子组件中的 count 值也会随之改变。",(0,r.jsx)(n.a,{href:"https://svelte.dev/repl/d3f4ee2660e24163bd7c278fa6891961?version=4.2.18",title:"https://svelte.dev/repl/d3f4ee2660e24163bd7c278fa6891961?version=4.2.18",target:"_blank",rel:"noopener noreferrer",children:"浏览器效果如下"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"43-context-or-store",children:["4.3. Context or Store",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-context-or-store",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"那么在我们的实际开发中，什么时候使用 Context、什么时候使用 Store、什么时候使用 Context + Store 呢？这取决于很多情况，但我们可以简单的讨论一下。"}),"\n",(0,r.jsx)(n.p,{children:"这要看你所需要的数据是静态的还是动态的，以及数据的影响范围，是全局的还是部分的。"}),"\n",(0,r.jsxs)(n.p,{children:["如果是静态数据 + 影响全局，那相当于配置文件，你甚至都不需要 Context、Store。正如我们项目开发中经常会建立一个 ",(0,r.jsx)(n.code,{children:"consts.js"})," 用于声明常量，需要的时候直接引入该文件即可。"]}),"\n",(0,r.jsx)(n.p,{children:"如果是静态数据 + 影响部分，Context 是一个不错的选择，比如博客组件将博客 ID 发送给评论组件、点赞组件等。"}),"\n",(0,r.jsx)(n.p,{children:"如果是动态数据 + 影响全局，Store 是一个不错的选择，比如页面的主题色。"}),"\n",(0,r.jsx)(n.p,{children:"如果是动态数据 + 影响部分，Store + Context 是一个不错的选择。Store 负责状态管理，Context 负责影响范围，组件在各自的范围内实现数据共享。"}),"\n",(0,r.jsxs)(n.h2,{id:"5-最后",children:["5. 最后",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-最后",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"恭喜您完成了第二篇内容的学习！Context 和 Store 是 Svelte 的内置状态管理工具，需要学习掌握其用法。"})]})}function S(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}let C=S;S.__RSPRESS_PAGE_META={},S.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F8-%E8%AF%AD%E6%B3%95%E7%AF%87%20%E2%9D%98%20Context%20%E4%B8%8E%20Store.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. Context",id:"2-context",depth:2},{text:"3. Stores",id:"3-stores",depth:2},{text:"3.1. Store 示例",id:"31-store-示例",depth:3},{text:"3.2. Store 实现原理",id:"32-store-实现原理",depth:3},{text:"3.3. 自动订阅（Auto-subscriptions）",id:"33-自动订阅auto-subscriptions",depth:3},{text:"3.4. Store contract",id:"34-store-contract",depth:3},{text:"3.5. Readable Store",id:"35-readable-store",depth:3},{text:"3.6. Derived Store",id:"36-derived-store",depth:3},{text:"3.7. High Order Store",id:"37-high-order-store",depth:3},{text:"3.8. get()",id:"38-get",depth:3},{text:"4. Context 与 Store",id:"4-context-与-store",depth:2},{text:"4.1. Context vs Store",id:"41-context-vs-store",depth:3},{text:"4.2. Reactive Context",id:"42-reactive-context",depth:3},{text:"4.3. Context or Store",id:"43-context-or-store",depth:3},{text:"5. 最后",id:"5-最后",depth:2}],title:"8-语法篇 ❘ Context 与 Store",headingTitle:"8-语法篇 ❘ Context 与 Store",frontmatter:{}}}}]);