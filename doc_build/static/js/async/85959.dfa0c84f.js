"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["85959"],{272383:function(n,e,i){i.r(e),i.d(e,{default:()=>c});var r=i(552676),t=i(740453);let a=i.p+"static/image/efeb6c253b0c6ceba6d9a54d02ab62fa.cbad20a7.png",s=i.p+"static/image/1b64e70dabc47b02039644f48f5c1621.cdcc7a3d.png",o=i.p+"static/image/f20f4efee86bc437e98f696c64630fa4.d28a4d66.png";function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",img:"img",pre:"pre",code:"code"},(0,t.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"31手写-babel-generator篇",children:["31.手写 Babel： generator篇",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#31手写-babel-generator篇",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"generator 是打印 AST 为目标代码，并生成 sourcemap。"}),"\n",(0,r.jsx)(e.p,{children:"这节我们实现一下 generator。"}),"\n",(0,r.jsxs)(e.h2,{id:"思路分析",children:["思路分析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"generator 会遍历 AST 进行打印，对于每种 AST 我们是知道如何打印的，比如 while 语句："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"先打印 while、再打印空格，再打印 ( ，然后打印 test 部分，之后打印 ），最后打印 block 部分。"}),"\n",(0,r.jsx)(e.p,{children:"那么实现了每种 AST 的打印就可以拼接出目标代码。"}),"\n",(0,r.jsx)(e.p,{children:"而 sourcemap 是记录源码位置和目标代码位置的关联，在打印的记录下当前打印的行列，就是目标代码位置，而源码位置 parse 的时候就有了，这样就生成了一个 mapping。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"sourcemap 就是由一个个 mapping 组成的，打印每个 AST 节点的时候添加一下 mapping，最终就生成了 sourcemap。"}),"\n",(0,r.jsxs)(e.h2,{id:"代码实现",children:["代码实现",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们定义一个 Printer 类做打印，实现每种 AST 的打印逻辑："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class Printer {\n    constructor (source, fileName) {\n        this.buf = '';\n        this.printLine = 1;\n        this.printColumn = 0;\n    }\n\n    addMapping(node) {\n        // 待实现\n    }\n\n    space() {\n        this.buf += ' ';\n        this.printColumn ++;\n    }\n\n    nextLine() {\n        this.buf += '\\n';\n        this.printLine ++;\n        this.printColumn = 0;\n    }\n\n    Program (node) {\n        this.addMapping(node);\n        node.body.forEach(item => {\n            this[item.type](item) + ';';\n            this.printColumn ++;\n            this.nextLine();\n        });\n    }\n\n    VariableDeclaration(node) {\n        if(!node.declarations.length) {\n            return;\n        }\n        this.addMapping(node);\n\n        this.buf += node.kind;\n        this.space();\n        node.declarations.forEach((declaration, index) => {\n            if (index != 0) {\n                this.buf += ',';\n                this.printColumn ++;\n            }\n            this[declaration.type](declaration);\n        });\n        this.buf += ';';\n        this.printColumn ++;\n\n    }\n    VariableDeclarator(node) {\n        this.addMapping(node);\n        this[node.id.type](node.id);\n        this.buf += '=';\n        this.printColumn ++;\n        this[node.init.type](node.init);\n    }\n    Identifier(node) {\n        this.addMapping(node);\n        this.buf += node.name;\n    }\n    FunctionDeclaration(node) {\n        this.addMapping(node);\n\n        this.buf += 'function ';\n        this.buf += node.id.name;\n        this.buf += '(';\n        this.buf += node.params.map(item => item.name).join(',');\n        this.buf += '){';\n        this.nextLine();\n        this[node.body.type](node.body);\n        this.buf += '}';\n        this.nextLine();\n    }\n    CallExpression(node) {\n        this.addMapping(node);\n\n        this[node.callee.type](node.callee);\n        this.buf += '(';\n        node.arguments.forEach((item, index) => {\n            if(index > 0 ) this.buf += ', ';\n            this[item.type](item);\n        })\n        this.buf += ')';\n\n    }\n    ExpressionStatement(node) {\n        this.addMapping(node);\n\n        this[node.expression.type](node.expression);\n\n    }\n    ReturnStatement(node) {\n       this.addMapping(node);\n\n        this.buf += 'return ';\n        this[node.argument.type](node.argument); \n\n    }\n    BinaryExpression(node) {\n       this.addMapping(node);\n\n        this[node.left.type](node.left);\n        this.buf += node.operator;\n        this[node.right.type](node.right);\n\n    }\n    BlockStatement(node) {\n       this.addMapping(node);\n\n        node.body.forEach(item => {\n            this.buf += '    ';\n            this.printColumn += 4;\n            this[item.type](item);\n            this.nextLine();\n        });\n\n    }\n    NumericLiteral(node) {\n       this.addMapping(node);\n\n        this.buf += node.value;\n\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样递归进行打印就可以生成完整的目标代码，我们把它记录到了 this.buf 属性。"}),"\n",(0,r.jsx)(e.p,{children:"同时，我们在打印的时候记录了 printLine、printColumn 的信息，也就是当前打印到了第几行，这样在 addMapping 里面就可以拿到 AST 在目标代码中的位置，而源码位置是在 parse 的时候记录到 loc 属性的，有了这两个位置就可以生成一个 mapping。"}),"\n",(0,r.jsx)(e.p,{children:"sourcemap 的生成是使用 source-map 包，这个 mozilla 维护的，因为 sourcemap 的标准也是他们提出来的。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"const { SourceMapGenerator } = require('source-map');\n\nclass Printer {\n    constructor (source, fileName) {\n        this.buf = '';\n  \n        this.sourceMapGenerator = new SourceMapGenerator({\n            file: fileName + \".map.json\",\n        });\n        this.fileName = fileName;\n        this.sourceMapGenerator.setSourceContent(fileName, source);\n\n        this.printLine = 1;\n        this.printColumn = 0;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"sourcemap 需要指定源文件名，这也是为什么我们要传入 fileName。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"之后实现 addMapping 方法："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"addMapping(node) {\n    if (node.loc) {\n        this.sourceMapGenerator.addMapping({\n            generated: {\n              line: this.printLine,\n              column: this.printColumn\n            },\n            source: this.fileName,\n            original: node.loc && node.loc.start\n        })\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"最后，我们定义 Generator 类，在 generate 方法里面调用 printer 的打印逻辑来生成目标代码，并且调用 this.sourceMapGenerator.toString() 来生成 sourcemap。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"class Generator extends Printer{\n\n    constructor(source, fileName) {\n        super(source, fileName);\n    }\n\n    generate(node) {\n        this[node.type](node);\n\n        return {\n            code: this.buf,\n            map: this.sourceMapGenerator.toString()\n        }\n    }\n}\n\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后暴露出 generate 的 api："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function generate (node, source, fileName) {\n    return new Generator(source, fileName).generate(node);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样，我们就实现了 babel generator 的功能，也就是打印目标代码和生成 sourcemap。"}),"\n",(0,r.jsx)(e.p,{children:"可以在生成的代码中添加 sourceMappingURL 就可以映射回源码，可以通过打断点或者运行代码 throw error 的方式来测试 测试 sourcemap的功能。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"//# sourceMappingURL=./xxx.map.json\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"generator 是打印 AST 为目标代码，我们知道每种 AST 是如何打印的，那么递归打印 AST，拼接字符串，就可以生成目标代码。"}),"\n",(0,r.jsx)(e.p,{children:"sourcemap 是调试代码和线上报错定位源码必不可少的功能，我们基于 source-map 包来生成，记录一个个 mapping。"}),"\n",(0,r.jsx)(e.p,{children:"具体的 mapping 就是源代码位置和目标代码位置的关联，AST 在源码的位置记录在 loc 属性，而在目标代码的位置位置可以计算出来。这样就可以生成 sourcemap。"}),"\n",(0,r.jsxs)(e.p,{children:["（代码在",(0,r.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function p(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}let c=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F31.%E6%89%8B%E5%86%99%20Babel%EF%BC%9A%20generator%E7%AF%87.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"总结",id:"总结",depth:2}],title:"31.手写 Babel： generator篇",headingTitle:"31.手写 Babel： generator篇",frontmatter:{}}}}]);