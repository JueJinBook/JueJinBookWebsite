"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75108"],{984186:function(n,e,s){s.r(e),s.d(e,{default:()=>h});var i=s(552676),c=s(740453);let t=s.p+"static/image/577e22168c199d9800ee42b96ffa7c32.34ec3ffe.webp",r=s.p+"static/image/9ec8c0199cb6f30d85d5eb596727b552.3c0c2c4f.webp",a=s.p+"static/image/105a486c44f91d49d3da7fc397927dac.554dd385.webp",l=s.p+"static/image/12d43eb8e9ea545c741253dced5c1819.b39db70e.webp";function d(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",pre:"pre",code:"code",img:"img",ol:"ol",li:"li",h3:"h3"},(0,c.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"3第三日代码的封装性可读性和正确性",children:["3.第三日：代码的封装性、可读性和正确性",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3第三日代码的封装性可读性和正确性",children:"#"})]}),"\n",(0,i.jsxs)(e.h2,{id:"第一个故事函数的封装性",children:["第一个故事：函数的封装性",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第一个故事函数的封装性",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"函数的封装性"}),"是指把函数相关的数据和行为结合在一起，对调用者隐藏内部处理过程。这句话听上去很容易理解，但是实际操作起来却又很容易被忽略。所以，今天的故事，我们将带你看看在实际开发中，函数的封装性是多么容易被破坏的。我们又是如何重构以实现函数的封装性的。"]}),"\n",(0,i.jsxs)(e.p,{children:["我们的任务是用JavaScript实现一个",(0,i.jsx)(e.strong,{children:"异步状态切换的模块"}),"。由于这个模块过于抽象和涉及过多细节，我们在这里将它简化一下，类似于实现一个“交通灯”系统。"]}),"\n",(0,i.jsx)(e.p,{children:"先来看看它的页面HTML结构和CSS设置："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <meta http-equiv="X-UA-Compatible" content="ie=edge">\n  <title>模拟交通灯</title>\n  <style>\n    html, body {\n      width: 100%;\n      height: 100%;\n      padding: 0;\n      margin: 0;\n      overflow: hidden;\n\n      /*设置html和body元素的布局为弹性布局*/\n      display: flex;\n      flex-direction: column;\n      justify-content: center;\n      align-items: center;\n    }\n    header {\n      line-height: 2rem;\n      font-size: 1.2rem;\n      margin-bottom: 20px;\n    }\n    .traffic { /*将class=traffic元素设置为弹性布局，它的子元素按照从上面到下排列*/\n      padding: 10px;\n      display: flex;\n      flex-direction: column;\n    }\n    .traffic .light {\n      width: 100px;\n      height: 100px;\n      background-color: #999;\n      border-radius: 50%;\n    }\n\n    /*将class=traffic & class=pass元素下的第一个class=light的元素的背景色设置为绿色*/\n    .traffic.pass .light:nth-child(1) {\n      background-color: #0a6; /*绿灯*/\n    }\n    .traffic.wait .light:nth-child(2) {\n      background-color: #cc0; /*黄灯*/\n    }\n    .traffic.stop .light:nth-child(3) {\n      background-color: #c00; /*红灯*/\n    }\n  </style>\n</head>\n<body>\n  <header>模拟交通灯</header>\n  <main>\n    <div class="traffic pass">\n      <div class="light"></div>\n      <div class="light"></div>\n      <div class="light"></div>\n    </div>\n  </main>\n</body>\n</html>\n'})}),"\n",(0,i.jsxs)(e.p,{children:["上面代码在浏览器上的效果如下图所示：\n",(0,i.jsx)("img",{src:l,alt:""})]}),"\n",(0,i.jsx)(e.p,{children:"这个例子的具体需求是，模拟交通灯信号，分别以5秒、1.5秒、3.5秒来循环切换绿灯（pass状态）、黄灯（wait状态）和红灯（stop状态）。也就是，默认是绿灯，过5秒后显示黄灯，过1.5秒后显示红灯，再过3.5秒后又回到绿灯，然后以这样的方式继续循环下去。"}),"\n",(0,i.jsx)(e.p,{children:"这个需求实现起来很简单，我们的代码如下所示："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index1-v1.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"const traffic = document.querySelector('.traffic');\n\nfunction loop() {\n  traffic.className = 'traffic pass';\n  setTimeout(() => {\n    traffic.className = 'traffic wait';\n    setTimeout(() => {\n      traffic.className = 'traffic stop';\n      setTimeout(loop, 3500);\n    }, 1500);\n  }, 5000);\n}\n\nloop();\n"})}),"\n",(0,i.jsx)(e.p,{children:"首先，我们来分析一下这段代码："}),"\n",(0,i.jsxs)(e.p,{children:["这段代码的一开始就获取了",(0,i.jsx)(e.code,{children:"class=traffic"}),"的元素，然后又声明了一个",(0,i.jsx)(e.code,{children:"loop"}),"函数。这个函数的功能是：默认情况下，将这个",(0,i.jsx)(e.code,{children:"traffic"}),"元素的",(0,i.jsx)(e.code,{children:"class"}),"属性设置为",(0,i.jsx)(e.code,{children:"traffic pass"}),"。 这样设置后，它就命中了下面这个CSS设置，使得第一个div元素的背景变成了绿色："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-css",children:".traffic.pass .light:nth-child(1) {\n  background-color: #0a6; /*绿灯*/\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["然后是三个",(0,i.jsx)(e.code,{children:"setTimeout"}),"方法嵌套。第一层的",(0,i.jsx)(e.code,{children:"setTimeout"}),"方法的回调在5000毫秒（也就是5秒）后触发，使得",(0,i.jsx)(e.code,{children:"traffic"}),"元素的",(0,i.jsx)(e.code,{children:"class"}),"属性变成了",(0,i.jsx)(e.code,{children:"tranffic wait"}),"。 这时命中了下面这条CSS规则，让第二个",(0,i.jsx)(e.code,{children:"div"}),"元素变成黄色："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-css",children:".traffic.wait .light:nth-child(2) {\n  background-color: #cc0; /*黄灯*/\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"接着是过了1.5秒，变成红灯，然后又过了3.5秒，又回到绿灯。周而复始。"}),"\n",(0,i.jsxs)(e.p,{children:["上面的这段代码虽然实现了我们的需求，但是它在设计上有很大的缺陷 —— ",(0,i.jsx)(e.code,{children:"loop"}),"函数访问了外部环境",(0,i.jsx)(e.code,{children:"traffic"}),"。这么做有两个问题："]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["如果我们修改了HTML代码，元素不叫做",(0,i.jsx)(e.code,{children:"traffic"}),"了，这个函数就不work了。"]}),"\n",(0,i.jsxs)(e.li,{children:["如果我们想把这个函数复用到其他地方，我们还得在那个地方重建这个",(0,i.jsx)(e.code,{children:"traffic"}),"对象。"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["这两个问题的本质都是因为，在我们的这个设计中，函数的",(0,i.jsx)(e.strong,{children:"封装性"}),"完全被破坏，这是新人常常犯的错误。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsxs)(e.p,{children:["所以，我们不能直接将",(0,i.jsx)(e.code,{children:"traffic"}),"这个对象直接写在",(0,i.jsx)(e.code,{children:"loop"}),"函数中。你可能很容易就想到了，让",(0,i.jsx)(e.code,{children:"traffic"}),"对象作为这个函数的参数传入："]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index1-v2.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"const traffic = document.querySelector('.traffic');\n\nfunction loop(subject) {\n  subject.className = 'traffic pass';\n  setTimeout(() => {\n    subject.className = 'traffic wait';\n    setTimeout(() => {\n      subject.className = 'traffic stop';\n      setTimeout(loop.bind(null, subject), 3500);\n    }, 1500);\n  }, 5000);\n}\n\nloop(traffic);\n"})}),"\n",(0,i.jsx)(e.p,{children:"这样修改我们解决了第一个问题，就是函数体内部不应该有完全来自外部环境的变量，除非这个函数不打算复用，比如是一个函数内部的函数："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function foo(arg) {\n  function bar() {\n    // 使用 arg\n    arg...\n  }\n  ...\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"上面的代码，bar使用arg是可以的，因为它只在foo内部存在，不会用在其他地方。"}),"\n",(0,i.jsx)(e.p,{children:"不过，我们将traffic作为参数传给loop，只解决了外部变量的封装这一个问题，但是，在这个loop过程中，还有其他的数据我们是写“死”在代码里面的，如果不把它们提取出来，这段代码的可复用性依然很差。"}),"\n",(0,i.jsxs)(e.h2,{id:"第二个故事实现异步状态切换函数的封装",children:["第二个故事：实现异步状态切换函数的封装",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第二个故事实现异步状态切换函数的封装",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"继续上一个故事的问题，我们如何封装一个函数让它具备适应各种subject的状态切换的功能呢？函数简单来说，是一个处理数据的最小单元。它包含了两个部分：数据和处理过程。要让我们设计的函数具有通用性，那么我们可以抽象数据，也可以抽象过程。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:r,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"通常，抽象数据比较直观，也更常用，我们先来看看如何抽象数据。至于抽象过程，在后续的课程中我们会深入讨论。"}),"\n",(0,i.jsxs)(e.h3,{id:"第一步数据抽象",children:["第一步：数据抽象",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第一步数据抽象",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"数据抽象就是把数据定义并聚合成能被过程处理的对象，交由特定的过程处理。"})," 简单来说就是数据的结构化。"]}),"\n",(0,i.jsxs)(e.p,{children:["对于第一个故事中的异步状态切换的任务来说，首先要找到它需要处理的数据，也就是：状态",(0,i.jsx)(e.code,{children:"pass, wait 和 stop"}),"，以及切换的时间",(0,i.jsx)(e.code,{children:"5秒、1.5秒和3.5秒"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:["我们将数据从",(0,i.jsx)(e.code,{children:"loop"}),"函数剥离出来："]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index1-v3.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"const traffic = document.querySelector('.traffic');\n\nfunction signalLoop(subject, signals = []) {\n  const signalCount = signals.length;\n  function updateState(i) {\n    const {signal, duration} = signals[i % signalCount];\n    subject.className = signal;\n    setTimeout(updateState.bind(null, i + 1), duration);\n  }\n  updateState(0);\n}\n\n// 数据抽象\nconst signals = [\n  {signal: 'traffic pass', duration: 5000},\n  {signal: 'traffic wait', duration: 3500},\n  {signal: 'traffic stop', duration: 1500},\n];\nsignalLoop(traffic, signals);\n"})}),"\n",(0,i.jsxs)(e.p,{children:["我们将状态和时间抽象成一个包含3个对象的数组，并将这个结构化的数据传递到",(0,i.jsx)(e.code,{children:"signalLoop"}),"方法中。利用",(0,i.jsx)(e.code,{children:"updateState"}),"方法的递归调用实现了状态的切换。"]}),"\n",(0,i.jsxs)(e.p,{children:["经过数据抽象的代码可以适应不同状态和时间的业务需求，我们只需要修改数据抽象即可，而不需要修改",(0,i.jsx)(e.code,{children:"signalLoop"}),"方法。"]}),"\n",(0,i.jsxs)(e.p,{children:["但是，采用数据抽象重构后，我们的",(0,i.jsx)(e.code,{children:"signalLoop"}),"方法还未达到完全封装。因为",(0,i.jsx)(e.code,{children:"signalLoop"}),"函数中存在一部分改变外部状态的代码。我们把改变外部状态的部分叫做代码的",(0,i.jsx)(e.strong,{children:"副作用(side-effect)"}),"。通常情况下，我们可以考虑",(0,i.jsx)(e.strong,{children:"把函数体内部有副作用的代码剥离出来"}),"，这往往能提升函数的通用性、稳定性和可测试性。"]}),"\n",(0,i.jsxs)(e.h3,{id:"第二步去副作用化",children:["第二步：去副作用化",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第二步去副作用化",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["那么，在",(0,i.jsx)(e.code,{children:"signalLoop"}),"方法中，哪个部分的代码改变了外部的状态呢？"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"subject.className = `traffic ${signal}`;"})," 因为subject是外部变量，这条语句改变了这个变量的className状态。所以，我们需要将这部分也从函数中剥离出去："]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index1-v4.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"const traffic = document.querySelector('.traffic');\n\nfunction signalLoop(subject, signals = [], onSignal) {\n  const signalCount = signals.length;\n  function updateState(i) {\n    const {signal, duration} = signals[i % signalCount];\n    onSignal(subject, signal);\n    setTimeout(updateState.bind(null, i + 1), duration);\n  }\n  updateState(0);\n}\n\nconst signals = [\n  {signal: 'pass', duration: 5000},\n  {signal: 'wait', duration: 3500},\n  {signal: 'stop', duration: 1500},\n];\nsignalLoop(traffic, signals, (subject, signal) => {\n  subject.className = `traffic ${signal}`;\n});\n"})}),"\n",(0,i.jsxs)(e.p,{children:["如上代码所示，我们将改变外部变量的操作用回调的方法传给",(0,i.jsx)(e.code,{children:"singalLoop"}),"。这样修改提升了",(0,i.jsx)(e.code,{children:"signalLoop"}),"函数的通用性，使得这个函数也可以用于操作其他的DOM元素的状态切换。"]}),"\n",(0,i.jsxs)(e.p,{children:["像上面这样的封装，提高了",(0,i.jsx)(e.code,{children:"signalLoop"}),"函数的‘纯度’。关于什么是函数的“纯度”，我们会在第5日中详细解释。"]}),"\n",(0,i.jsxs)(e.p,{children:["完成了",(0,i.jsx)(e.code,{children:"signalLoop"}),"函数的封装，我们感觉得无论是采用第一版的3个",(0,i.jsx)(e.code,{children:"setTimeout"}),"方法嵌套，还是使用",(0,i.jsx)(e.code,{children:"updateState"}),"异步递归，虽然都能实现业务需求，但是代码的可读性不是很高。那么如何修改可以提高代码的可读性呢？"]}),"\n",(0,i.jsxs)(e.h2,{id:"第三个故事代码的语义与可读性",children:["第三个故事：代码的“语义”与可读性",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第三个故事代码的语义与可读性",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"为了提高异步状态切换代码的可读性，我们可以采用ES6异步规范 —— Promise，重构一下我们的代码："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function wait(ms) {\n  return new Promise((resolve) => {\n    setTimetout(resolve, ms);\n  });\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["这段代码将",(0,i.jsx)(e.code,{children:"setTimeout"}),"方法封装成",(0,i.jsx)(e.code,{children:"wait"}),"函数。这个函数将",(0,i.jsx)(e.code,{children:"setTimeout"}),"方法用Promise包裹起来，并返回这个Promise对象。"]}),"\n",(0,i.jsxs)(e.p,{children:["有了这个",(0,i.jsx)(e.code,{children:"wait"}),"函数之后，原本有些晦涩的",(0,i.jsx)(e.code,{children:"setTimeout"}),"嵌套，可以很容易改写成一个",(0,i.jsx)(e.code,{children:"async"}),"函数中的",(0,i.jsx)(e.code,{children:"await"}),"循环："]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index1-v5.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function wait(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nconst traffic = document.querySelector('.traffic');\n\n(async function () {\n  while(1) {\n    await wait(5000);\n    traffic.className = 'traffic wait';\n    await wait(1500);\n    traffic.className = 'traffic stop';\n    await wait(3500);\n    traffic.className = 'traffic pass';\n  }\n}());\n"})}),"\n",(0,i.jsxs)(e.p,{children:["如上代码所示，我们将原来的",(0,i.jsx)(e.code,{children:"loop"}),"方法改为立即调用函数的方式，并将3个",(0,i.jsx)(e.code,{children:"setTimeout"}),"部分修改为",(0,i.jsx)(e.code,{children:"while"}),"死循环。循环体中的部分很容易理解：等待5秒 -> 将",(0,i.jsx)(e.code,{children:"traffic"}),"元素的",(0,i.jsx)(e.code,{children:"className"}),"属性修改为",(0,i.jsx)(e.code,{children:"traffic wait"})," -> 等1.5秒 -> 将",(0,i.jsx)(e.code,{children:"traffic"}),"元素的",(0,i.jsx)(e.code,{children:"className"}),"属性修改为",(0,i.jsx)(e.code,{children:"traffic stop"})," -> 等待3.5秒 -> 将",(0,i.jsx)(e.code,{children:"traffic"}),"元素的",(0,i.jsx)(e.code,{children:"className"}),"属性修改为",(0,i.jsx)(e.code,{children:"traffic pass"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"这段代码与之前的代码相比，它的可读性是不是提高了很多？"}),"\n",(0,i.jsxs)(e.p,{children:["同样，我们也用Promise修改",(0,i.jsx)(e.code,{children:"signalLoop"}),"的版本，同样也很容易阅读："]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index1-v6.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function wait(ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nconst traffic = document.querySelector('.traffic');\n\nasync function signalLoop(subject, signals = [], onSignal) {\n  const signalCount = signals.length;\n  for(let i = 0; ;i++) {\n    const {signal, duration} = signals[i % signalCount];\n    await onSignal(subject, signal);\n    await wait(duration);\n  }\n}\n\nconst signals = [\n  {signal: 'pass', duration: 5000},\n  {signal: 'wait', duration: 3500},\n  {signal: 'stop', duration: 1500},\n];\nsignalLoop(traffic, signals, (subject, signal) => {\n  subject.className = `traffic ${signal}`;\n});\n"})}),"\n",(0,i.jsxs)(e.p,{children:["与上一次考虑封装性不同，这次的重构主要是在代码的内部，使用",(0,i.jsx)(e.code,{children:"async/await"}),"能够把异步的递归简化为更容易让人阅读和理解的循环，而且，修改后的代码，还允许",(0,i.jsx)(e.code,{children:"onSignal"}),"回调本身也是一个异步过程，这进一步增加了",(0,i.jsx)(e.code,{children:"signalLoop"}),"函数的用途。"]}),"\n",(0,i.jsxs)(e.p,{children:["在ES6之后，JavaScript比之前的版本有了许多改进，但如果要说最重要的改进，那么Promise规范和",(0,i.jsx)(e.code,{children:"async/await"}),"语法绝对可以列于其中。Promsie和",(0,i.jsx)(e.code,{children:"async/await"}),"创造不仅仅是语法，而是一种新的语义，有了它们，JavaScript这一种异步非阻塞语言，才真正能够将异步的特性发挥到极致。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"代码是人阅读的，只是偶尔让计算机执行一下。"})}),"\n",(0,i.jsxs)(e.h2,{id:"第四个故事函数的正确性和效率",children:["第四个故事：函数的正确性和效率",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第四个故事函数的正确性和效率",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"代码的封装性和可读性固然重要，但是代码的正确性更为重要。如果你是一个初级工程师，可能你无法写出高封装性的代码，但是你也必须保证你所提交的代码是正确的，否则就会造成业务逻辑失败。可能你会觉的这个话题很滑稽，我怎么可能将错误的代码提交呢？但在实际开发中，我们可能会写出错误的代码而不自知。比如：洗牌算法的陷阱。"}),"\n",(0,i.jsx)(e.p,{children:"考虑这样一个抽奖场景：给定一组生成好的抽奖号码，然后我们需要实现一个模块。这个模块的功能是将这组号码打散（即，洗牌）然后输出一个中奖的号码。"}),"\n",(0,i.jsx)(e.p,{children:"那这个打散号码的JS片段如下："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function shuffle(items) {\n  return [...items].sort((a, b) => Math.random() > 0.5 ? -1 : 1);\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"这段代码被用在一个用户抽奖的页面上，大致是这样的："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsx)(e.p,{children:"为了便于描述，此处做了很大的简化，真实项目要比这复杂的得多，且抽奖代码不是运行在客户端，而是在服务端完成的。"}),"\n",(0,i.jsx)(e.p,{children:"这段代码看似可以实现目的，但是实际上却是有很大问题的。因为这个随机方法根本就不够随机。"}),"\n",(0,i.jsx)(e.p,{children:"我们可以写一个程序来测试一下。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function shuffle(items) {\n  return items.sort((a, b) => Math.random() > 0.5 ? -1 : 1);\n}\n\nconst weights = Array(9).fill(0);\n\nfor(let i = 0; i < 10000; i++) {\n  const testItems = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n  shuffle(testItems);\n  testItems.forEach((item, idx) => weights[idx] += item);\n}\n\nconsole.log(weights);\n\n// [45071, 45016, 49406, 50455, 50727, 50205, 50981, 52346, 55793]\n// 每次结果有变化，但总的来说前面的数字小，后面的数字大\n"})}),"\n",(0,i.jsx)(e.p,{children:"我们把1到9数字经过shuffle函数随机10000次，然后把每一位出现的数字相加，得到总和。经过多次检验，发现总和数组前面的数字总是较小，后面的数字较大。"}),"\n",(0,i.jsx)(e.p,{children:"这就意味着，越大的数字出现在数组后面的概率要大一些。"}),"\n",(0,i.jsxs)(e.p,{children:["造成这个结果的原因是，数组的",(0,i.jsx)(e.code,{children:"sort"}),"方法内部是一个排序算法，我们不知道它的具体实现，但一般来说，排序算法用某种规则依次选取两个元素比较它们的大小，然后根据比较结果交换位置。"]}),"\n",(0,i.jsxs)(e.p,{children:["这个算法给排序过程一个随机的比较算子",(0,i.jsx)(e.code,{children:"(a, b) => Math.random() > 0.5 ? -1 : 1"}),"，从而让数组元素的交换过程代码随机性，但是交换过程的随机性，并不能保证数学上让每个元素出现在每个位置都具有相同的几率，因为排序算法对每个位置的元素和其他元素交换的次序、次数都是有区别的。"]}),"\n",(0,i.jsx)(e.p,{children:"要实现比较公平的随机算法，其实也并不难。我们只要每次从数组中随机取出一个元素来，将它放到新的队列中，这样直至所有的元素都取完，我们就得到了我们要的随机排列，而且可以严格保证数组元素出现在每个位置的几率都是相同的（这里不考虑JavaScript引擎内置的Math.random函数本身的随机性问题）。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function shuffle(items) {\n  items = [...items];\n  const ret = [];\n  while(items.length) {\n    const idx = Math.floor(Math.random() * items.length);\n    const item = items.splice(idx, 1)[0];\n    ret.push(item);\n  }\n  return ret;\n}\n\nlet items = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nitems = shuffle(items);\nconsole.log(items);\n"})}),"\n",(0,i.jsx)(e.p,{children:"上面的代码，每次从数组中随机挑选元素，将这个元素从原数组的副本中删除（为了不影响原素组，我们创建了副本），放入新的数组，这样就可以保证每一个数在每个位置的概率是相同的。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index2-v1.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.p,{children:"这个算法是没有问题的，但是效率上还有提升空间。因为存在splice方法，它的时间复杂度是O(n^2)。"}),"\n",(0,i.jsx)(e.p,{children:"如果要更快一些，我们不必用splice将元素从原数组副本中一一抽取，只要在每次抽取的时候，直接将随机到的位置的元素与数组的第“i”个元素交换即可。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function shuffle(items) {\n  items = [...items];\n  for(let i = items.length; i > 0; i--) {\n    const idx = Math.floor(Math.random() * i);\n    [items[idx], items[i - 1]] = [items[i - 1], items[idx]];\n  }\n  return items;\n}\n\nlet items = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nitems = shuffle(items);\nconsole.log(items);\n"})}),"\n",(0,i.jsx)(e.p,{children:"如上面代码所示，我们每次从数组的前i个元素（第0~i-1个元素）中随机挑选一个，将它和第i个元素（下标为i-1）进行交换，然后把i的值减1，直到i的值小于1。"}),"\n",(0,i.jsx)(e.p,{children:"这个算法的时间复杂度是O(n)，所以性能上应该更好，如果随机排列的数组很大，我们应该选择这种实现。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index2-v2.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.p,{children:"这个洗牌算法基本没有问题了，但是我们还可以进一步改进它。因为根据需求，用户抽奖的次数是有限制的，而且如果在次数允许的情况下，已经抽到了幸运数字，就不必再抽取下去，所以其实我们不必对整个数组进行完全的随机排列。"}),"\n",(0,i.jsx)(e.p,{children:"这个时候，我们其实可以改用生成器。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function* shuffle(items) {\n  items = [...items];\n  for(let i = items.length; i > 0; i--) {\n    const idx = Math.floor(Math.random() * i);\n    [items[idx], items[i - 1]] = [items[i - 1], items[idx]];\n    yield items[i - 1];\n  }\n}\n\nlet items = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nitems = shuffle(items);\nconsole.log(...items);\n"})}),"\n",(0,i.jsxs)(e.p,{children:["我们只要做一个很小的改动，将函数改成生成器，将",(0,i.jsx)(e.code,{children:"return"}),"改成",(0,i.jsx)(e.code,{children:"yield"}),"，就能够实现部分洗牌，或者用作抽奖："]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.a,{href:"https://junyux.github.io/FE-Advance/day03/index2-v3.html",target:"_blank",rel:"noopener noreferrer",children:"在线演示"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-js",children:"function *shuffle(items) {\n  items = [...items];\n  for(let i = items.length; i > 0; i--) {\n    const idx = Math.floor(Math.random() * i);\n    [items[idx], items[i - 1]] = [items[i - 1], items[idx]];\n    yield items[i - 1];\n  }\n}\n\nlet items = [...new Array(100).keys()];\n\nlet n = 0;\n// 100个号随机抽取5个\nfor(let item of shuffle(items)) {\n  console.log(item);\n  if(n++ >= 5) break;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"最后，我们总结一下，代码的封装性、可读性和正确性，都是程序开发中必须要关注问题。有时候，一些小细节看似微不足道，但是小问题积累起来，会变成大问题，甚至最终导致一个大系统的崩溃和不可维护。所以，要重视细节，尽量设计好每一个函数，严格保证它们的封装性、可读性和正确性，这是成为一名优秀工程师的前提。"})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}let h=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%BF%9B%E9%98%B6%2010%20%E6%97%A5%E8%B0%88%2F3.%E7%AC%AC%E4%B8%89%E6%97%A5%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7%E3%80%81%E5%8F%AF%E8%AF%BB%E6%80%A7%E5%92%8C%E6%AD%A3%E7%A1%AE%E6%80%A7.md"]={toc:[{text:"第一个故事：函数的封装性",id:"第一个故事函数的封装性",depth:2},{text:"第二个故事：实现异步状态切换函数的封装",id:"第二个故事实现异步状态切换函数的封装",depth:2},{text:"第一步：数据抽象",id:"第一步数据抽象",depth:3},{text:"第二步：去副作用化",id:"第二步去副作用化",depth:3},{text:"第三个故事：代码的“语义”与可读性",id:"第三个故事代码的语义与可读性",depth:2},{text:"第四个故事：函数的正确性和效率",id:"第四个故事函数的正确性和效率",depth:2}],title:"3.第三日：代码的封装性、可读性和正确性",headingTitle:"3.第三日：代码的封装性、可读性和正确性",frontmatter:{}}}}]);