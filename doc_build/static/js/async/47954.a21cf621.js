"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["47954"],{113362:function(e,n,s){e.exports=s.p+"static/image/e761dac4d92b7bd3459a1ef4041770f0.b23673ad.webp"},277559:function(e,n,s){s.r(n),s.d(n,{default:()=>j});var d=s(552676),c=s(740453);let o=s.p+"static/image/255b1663e417287e26e4229878e14a7e.d16236ee.webp";var r=s(113362);function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",code:"code",ol:"ol",li:"li",h2:"h2",pre:"pre",em:"em",img:"img"},(0,c.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"2-nodejs-的模块管理上",children:["2 Node.js 的模块管理（上）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-nodejs-的模块管理上",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["第一次接触 Node.js 的同学可能会觉得，",(0,d.jsx)(n.strong,{children:"Node.js 和浏览器的 JavaScript 最大的不同就在于 Node.js 是模块化"}),"的。那真的是这样吗？模块化又是什么呢？让我们一起往下看。"]}),"\n",(0,d.jsxs)(n.p,{children:["所谓模块化，就是指代码具有模块结构，",(0,d.jsx)(n.strong,{children:"整个应用可以自顶向下划分为若干个模块，每个模块彼此独立，代码不会相互影响"}),"。模块化的目的是使代码可以更好地复用，从而支持更大规模的应用开发。"]}),"\n",(0,d.jsx)(n.p,{children:"早期的浏览器 JavaScript 本身不是模块化的，表现为浏览器加载的多个 JS 文件内容没有彼此隔离，顶层的 var 变量声明和函数声明在不同的文件之间可以互相访问，在语言核心层面上也没有提供任何模块封装机制。"}),"\n",(0,d.jsx)(n.p,{children:"Node.js 诞生的时候，Web 已经发展到了一定的规模，而且 Node.js 本身也设计为要能够解决更大规模和更复杂的问题。因此，对于 Node.js 来说，模块化就成为必须要有的特性。"}),"\n",(0,d.jsxs)(n.p,{children:["Node.js 诞生之初，JavaScript 还没有标准的模块机制，因此 Node.js 一开始采用了",(0,d.jsx)(n.a,{href:"http://www.commonjs.org/",target:"_blank",rel:"noopener noreferrer",children:"CommonJS 规范"}),"。随后，JavaScript 标准的模块机制",(0,d.jsx)(n.code,{children:"ES Modules"}),"诞生，浏览器开始逐步支持",(0,d.jsx)(n.code,{children:"ES Modules"}),"。Node.js 从",(0,d.jsx)(n.code,{children:"v13.2.0"}),"之后也引入了规范的",(0,d.jsx)(n.code,{children:"ES Modules"}),"机制，同时兼容早期的",(0,d.jsx)(n.code,{children:"CommonJS"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["早在 Node.js 支持",(0,d.jsx)(n.code,{children:"ES Modules"}),"之前，像",(0,d.jsx)(n.code,{children:"Babel"}),"这样的编译工具和",(0,d.jsx)(n.code,{children:"Webpack"}),"这类打包器，已经能够将规范的",(0,d.jsx)(n.code,{children:"ES Modules"}),"模块机制编译成",(0,d.jsx)(n.code,{children:"Node.js"}),"的",(0,d.jsx)(n.code,{children:"CommonJS"}),"模块机制了。而现在，Node.js 自身对",(0,d.jsx)(n.code,{children:"ES Modules"}),"的支持也越发成熟。"]}),"\n",(0,d.jsx)(n.p,{children:"所以，现在我们写 Node.js 模块的时候，可以有 3 种方式："}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["直接采用最新的",(0,d.jsx)(n.code,{children:"ES Modules"}),"，在",(0,d.jsx)(n.code,{children:"Node.js v13.2.0"}),"以后的版本中可行，但是使用上有些条件，稍后我们会详细说明。"]}),"\n",(0,d.jsxs)(n.li,{children:["采用",(0,d.jsx)(n.code,{children:"ES Modules"}),"，通过 Babel 编译。在",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/6891929939616989188/section/6891951392114606094",target:"_blank",rel:"noopener noreferrer",children:"《前端进阶十日谈》"}),"课程的最后一天中，我们介绍了前端工程化，其中就讨论了 Babel，感兴趣的同学可以去看一下那个课程。不看也没关系，本课程后续的章节中，也会有 Babel 更深入的介绍。"]}),"\n",(0,d.jsxs)(n.li,{children:["仍然使用旧的",(0,d.jsx)(n.code,{children:"CommonJS"}),"规范，预计未来 Node.js 在很长一段时间内依然会同时兼容",(0,d.jsx)(n.code,{children:"ES Modules"}),"和",(0,d.jsx)(n.code,{children:"CommonJS"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["在这一节课里，我们先通过例子简单介绍一下",(0,d.jsx)(n.code,{children:"ES Modules"}),"规范的语法，然后在下一节课我们介绍",(0,d.jsx)(n.code,{children:"CommonJS"}),"规范的使用方法。在后续课程中，我们会经常用到它们。"]}),"\n",(0,d.jsxs)(n.h2,{id:"第一个-es-modules-模块",children:["第一个 ES-Modules 模块",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一个-es-modules-模块",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"接下来，我们先封装一个模块。还记得上一节课我们写的那个例子吗？我们重新回顾一下它的代码："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const template = (text) => `\n                 __._                                   \n                / ___)_                                 \n               (_/Y ===\\\\                            __ \n               |||.==. =).                            | \n               |((| o |p|      |  ${text}\n            _./| \\\\(  /=\\\\ )     |__                    \n          /  |@\\\\ ||||||||.                             \n         /    \\\\@\\\\ ||||||||\\\\                          \n        /   \\\\  \\\\@\\\\ ||||||//\\\\                        \n       (     Y  \\\\@\\\\|||| // _\\\\                        \n       |    -\\\\   \\\\@\\\\ \\\\\\\\//    \\\\                    \n       |     -\\\\__.-./ //\\\\.---.^__                        \n       | \\\\    /  |@|__/\\\\_|@|  |  |                         \n       \\\\__\\\\      |@||| |||@|     |                    \n       <@@@|     |@||| |||@|    /                       \n      / ---|     /@||| |||@|   /                                 \n     |    /|    /@/ || |||@|  /|                        \n     |   //|   /@/  ||_|||@| / |                        \n     |  // \\\\ ||@|   /|=|||@| | |                       \n     \\\\ //   \\\\||@|  / |/|||@| \\\\ |                     \n     |//     ||@| /  ,/|||@|   |                        \n     //      ||@|/  /|/||/@/   |                        \n    //|   ,  ||//  /\\\\|/\\\\/@/  / /                      \n   //\\\\   /   \\\\|/  /H\\\\|/H\\\\/  /_/                     \n  // |\\\\_/     |__/|H\\\\|/H|\\\\_/                         \n |/  |\\\\        /  |H===H| |                            \n     ||\\\\      /|  |H|||H| |                            \n     ||______/ |  |H|||H| |                             \n      \\\\_/ _/  _/  |L|||J| \\\\_                          \n      _/  ___/   ___\\\\__/___ '-._                       \n     /__________/===\\\\__/===\\\\---'                      \n                                                        \n`;\n\nconst argv = process.argv;\nconsole.log(template(argv[2] || '巧言令色，鮮矣仁！'));\n"})}),"\n",(0,d.jsx)(n.p,{children:"在这里，我们定义了一个 template 方法，然后直接接受命令行输入，最后将内容输出。现在，我们要将这个 template 方法给封装成一个模块。"}),"\n",(0,d.jsxs)(n.p,{children:["我们用",(0,d.jsx)(n.code,{children:"ES Modules"}),"的方式对它进行封装，先在项目目录下创建一个",(0,d.jsx)(n.code,{children:"ziyue.mjs"}),"文件（",(0,d.jsxs)(n.em,{children:["注意，这里的文件后缀名是",(0,d.jsx)(n.code,{children:".mjs"})]}),"），然后编辑它的内容："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// ziyue.mjs\nconst ziyue = (text) => `\n                 __._                                   \n                / ___)_                                 \n               (_/Y ===\\\\                            __ \n               |||.==. =).                            | \n               |((| o |p|      |  ${text}\n            _./| \\\\(  /=\\\\ )     |__                    \n          /  |@\\\\ ||||||||.                             \n         /    \\\\@\\\\ ||||||||\\\\                          \n        /   \\\\  \\\\@\\\\ ||||||//\\\\                        \n       (     Y  \\\\@\\\\|||| // _\\\\                        \n       |    -\\\\   \\\\@\\\\ \\\\\\\\//    \\\\                    \n       |     -\\\\__.-./ //\\\\.---.^__                        \n       | \\\\    /  |@|__/\\\\_|@|  |  |                         \n       \\\\__\\\\      |@||| |||@|     |                    \n       <@@@|     |@||| |||@|    /                       \n      / ---|     /@||| |||@|   /                                 \n     |    /|    /@/ || |||@|  /|                        \n     |   //|   /@/  ||_|||@| / |                        \n     |  // \\\\ ||@|   /|=|||@| | |                       \n     \\\\ //   \\\\||@|  / |/|||@| \\\\ |                     \n     |//     ||@| /  ,/|||@|   |                        \n     //      ||@|/  /|/||/@/   |                        \n    //|   ,  ||//  /\\\\|/\\\\/@/  / /                      \n   //\\\\   /   \\\\|/  /H\\\\|/H\\\\/  /_/                     \n  // |\\\\_/     |__/|H\\\\|/H|\\\\_/                         \n |/  |\\\\        /  |H===H| |                            \n     ||\\\\      /|  |H|||H| |                            \n     ||______/ |  |H|||H| |                             \n      \\\\_/ _/  _/  |L|||J| \\\\_                          \n      _/  ___/   ___\\\\__/___ '-._                       \n     /__________/===\\\\__/===\\\\---'                      \n                                                        \n`;\n\nexport {ziyue}; //将ziyue函数对象导出\n"})}),"\n",(0,d.jsxs)(n.p,{children:["这里，我们将",(0,d.jsx)(n.code,{children:"template"}),"变量名修改为",(0,d.jsx)(n.code,{children:"ziyue"}),"，在代码的最后一行加上一行",(0,d.jsx)(n.code,{children:"export {ziyue}"}),"，就把模块中的",(0,d.jsx)(n.code,{children:"ziyue"}),"对象给导出了。这就是我们的 ES-Modues 规范的模块了。我们可以把",(0,d.jsx)(n.code,{children:"export { ... }"}),"称为这个模块的",(0,d.jsx)(n.strong,{children:"公共 API"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["创建好模块后，我们如何将这个模块的公共API导入到其它模块呢？可以创建一个",(0,d.jsx)(n.code,{children:"index.mjs"}),"文件，通过",(0,d.jsx)(n.code,{children:"import"}),"语法将",(0,d.jsx)(n.code,{children:"ziyue"}),"导进来："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import {ziyue} from './ziyue.mjs'; // 引入ziyue模块\n\nconst argv = process.argv;\nconsole.log(ziyue(argv[2] || '有朋自远方来，不亦乐乎！'));\n"})}),"\n",(0,d.jsxs)(n.p,{children:["然后运行",(0,d.jsx)(n.code,{children:"node index.mjs"}),"，可以得到和上一节课一样的输出："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,d.jsxs)(n.p,{children:["通过例子，我们可以看出",(0,d.jsx)(n.code,{children:"ES Modules"}),"的基本使用方法。"]}),"\n",(0,d.jsx)(n.p,{children:"导出对象："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"export { 模块的公共API }\n"})}),"\n",(0,d.jsx)(n.p,{children:"从模块中引入导出的API："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import { API名字 } from 模块名\n"})}),"\n",(0,d.jsxs)(n.p,{children:["上面我们导出的对象",(0,d.jsx)(n.code,{children:"ziyue"}),"是一个函数对象。实际上，我们不止可以导出函数，还可以导出模块中任何类型的数据。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// foo.mjs\nconst a = 10;\nconst b = 'hello';\nconst c = () => {\n  return 'greeting';\n};\n\nexport {a, b, c}; // 导出 a、b、c\n"})}),"\n",(0,d.jsx)(n.p,{children:"然后在另一个模块中引用它们的全部或一部分。"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// bar.mjs\nimport {a, c} from './foo.mjs';\nconsole.log(a); // 10\nconsole.log(c()); // greeting\n"})}),"\n",(0,d.jsxs)(n.p,{children:["可能你觉得",(0,d.jsx)(n.code,{children:"export {a, b, c}"}),"这样的形式是导出了一个对象，认为可以将export写成如下形式："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"export {foo: 'bar'}; // 错误的语法\n"})}),"\n",(0,d.jsx)(n.p,{children:"但实际上这是不对的，我们只能写成："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const foo = 'bar';\nexport {foo};\n"})}),"\n",(0,d.jsx)(n.p,{children:"或者我们可以简写成："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"export const foo = 'bar';\n"})}),"\n",(0,d.jsxs)(n.p,{children:["但",(0,d.jsx)(n.strong,{children:"不能"}),"写成 ",(0,d.jsx)(n.code,{children:"export {foo: 'bar'}"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"如果我们需要在 export 的时候重新命名导出的 API 名字，可以这么写："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// foo.mjs\nconst a = 10;\nconst b = 'hello';\nconst c = () => {\n  return 'greeting';\n};\n\nexport {\n  a as d,\n  b as e,\n  c as f\n}; // 导出 a、b、c 三个数据，重新命名为 d、e、f\n"})}),"\n",(0,d.jsxs)(n.p,{children:["另外，ES Modules 还可以用",(0,d.jsx)(n.code,{children:"export default"}),"导出一个默认模块，默认模块可以在",(0,d.jsx)(n.code,{children:"import"}),"的时候用任意名字引入，比如我们把前面例子的",(0,d.jsx)(n.code,{children:"export {ziyue};"}),"修改成",(0,d.jsx)(n.code,{children:"export default ziyue"}),"："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const ziyue = (text) => { ... };\nexport default ziyue;\n"})}),"\n",(0,d.jsx)(n.p,{children:"那么我们就可以用如下语法引入："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import ziyue /* 或其他名字 */ from './ziyue.mjs';\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.em,{children:"注意：一个模块的 export default 只能导出一个默认 API。如果这个模块还有其他的 API 需要导出，那么只能使用 export了。"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// ziyue.mjs\n\nconst ziyue = (text) => { ... } ;\nconst a = 10;\nconst b = '君喻学堂';\n\nexport default ziyue;\nexport {a, b};\n"})}),"\n",(0,d.jsx)(n.p,{children:"在使用 ziyue 模块的时候，我们可以这样引入它的 API："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// index.j\nimport ziyue from './ziyue.mjs';\nimport {a, b} from './ziyue.mjs';\n  ...\n"})}),"\n",(0,d.jsx)(n.p,{children:"我们可以任意命名导出的 API 名字，同样，我们也可以在引入的时候给其它模块的 API 命名。比如："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import {a as c, b as d} from './ziyue.mjs';\n"})}),"\n",(0,d.jsxs)(n.p,{children:["如果是用",(0,d.jsx)(n.code,{children:"export default"}),"导出的",(0,d.jsx)(n.code,{children:"ziyue"}),"API，我们可以这样命名："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import foobar from `./ziyue.mjs`; // 将ziyue重新命名为foobar\n"})}),"\n",(0,d.jsx)(n.p,{children:"我们也可以在导入的时候，将这些导出的 API 声明成一个任意名字的对象的属性："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import * as foo from './ziyue.mjs';\n\nconsole.log(foo.a); // 10\nconsole.log(foo.b); // 君喻学堂\nconsole.log(foo.default); // [Object Function]\n"})}),"\n",(0,d.jsxs)(n.p,{children:["\uD83D\uDCA1这里需要注意的是第三行",(0,d.jsx)(n.code,{children:"foo.default"}),"，为什么这里是",(0,d.jsx)(n.code,{children:"default"}),"而不是",(0,d.jsx)(n.code,{children:"ziyue"}),"呢？因为我们的",(0,d.jsx)(n.code,{children:"ziyue"}),"API 是用",(0,d.jsx)(n.code,{children:"export default"}),"方式导出的，所以当我们将",(0,d.jsx)(n.code,{children:"foo"}),"打印出来的时候，结果是这样的："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import * as foo from './ziyue.mjs';\nconsole.log(foo) // {a, b, default}\n"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ziyue"}),"在 foo 对象中对应的属性名是",(0,d.jsx)(n.code,{children:"default"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["以上基本就是 ESModule 的全部规则了。关于这一部分完整的语法，你可以查看",(0,d.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export",target:"_blank",rel:"noopener noreferrer",children:"MDN文档"}),"和",(0,d.jsx)(n.a,{href:"https://nodejs.org/docs/latest/api/esm.html",target:"_blank",rel:"noopener noreferrer",children:"Node.js的API文档"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["这里还有一点需要注意，我们命名 js 模块文件不是用 .js 扩展名，而是用 .mjs 扩展名。这是因为 Node.js 目前默认用",(0,d.jsx)(n.code,{children:"CommonJS"}),"规范定义 .js 文件的模块，用",(0,d.jsx)(n.code,{children:"ES Modules"}),"定义 .mjs 文件的模块。如果我们直接将",(0,d.jsx)(n.code,{children:"index.mjs"}),"文件改成",(0,d.jsx)(n.code,{children:"index.js"}),"，然后运行",(0,d.jsx)(n.code,{children:"node index.js"}),"，控制台上将报告错误信息。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:o,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["如果要用",(0,d.jsx)(n.code,{children:"ES Modules"}),"定义 .js 文件的模块，可以在 Node.js 的配置文件",(0,d.jsx)(n.code,{children:"package.json"}),"中设置参数",(0,d.jsx)(n.code,{children:"type: module"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"package.json"}),"可以手动创建，也可以通过命令行创建。如果你安装了 NPM 包管理工具，用 NPM 命令行",(0,d.jsx)(n.code,{children:"npm init -y"}),"可以快速创建一个 package.json 文件；如果你还未安装，也没关系，我们先手工创建一个文件，在后续课程中，我们会介绍 NPM。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-json",children:'{\n  "type": "module"\n}\n'})}),"\n",(0,d.jsxs)(n.p,{children:["我们创建了 package.json 文件，只添加一项配置：",(0,d.jsx)(n.code,{children:'"type": "module"'}),"，然后我们将",(0,d.jsx)(n.code,{children:"ziyue.mjs"}),"和",(0,d.jsx)(n.code,{children:"index.mjs"}),"文件名修改为",(0,d.jsx)(n.code,{children:"ziyue.js"}),"和",(0,d.jsx)(n.code,{children:"index.js"}),"，运行",(0,d.jsx)(n.code,{children:"node index.js"}),"，就可以得到正确的输出结果了。"]}),"\n",(0,d.jsxs)(n.h2,{id:"总结",children:["总结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"Node.js 运行时环境和浏览器运行时环境，除了提供的 API 存在差异外，另一个重要的区别在于 Node.js 为 JavaScript 提供了模块化的管理特性。"}),"\n",(0,d.jsx)(n.p,{children:"Node.js 的模块管理遵循两种规范：ES Module 和 CommonJS。本节课主要介绍了 ES Module 规范下模块的创建和引入的语法。"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}let j=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F2%20Node.js%20%E7%9A%84%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{text:"第一个 ES-Modules 模块",id:"第一个-es-modules-模块",depth:2},{text:"总结",id:"总结",depth:2}],title:"2 Node.js 的模块管理（上）",headingTitle:"2 Node.js 的模块管理（上）",frontmatter:{}}}}]);