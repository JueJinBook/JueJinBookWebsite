"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["48417"],{983542:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var a=t(552676),r=t(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",h3:"h3",blockquote:"blockquote",p:"p",code:"code",pre:"pre"},(0,r.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"6创建型单例模式面试真题手把手教学",children:["6.创建型：单例模式——面试真题手把手教学",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6创建型单例模式面试真题手把手教学",children:"#"})]}),"\n",(0,a.jsxs)(n.h2,{id:"实现一个-storage",children:["实现一个 Storage",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现一个-storage",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"描述",children:["描述",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#描述",children:"#"})]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"实现Storage，使得该对象为单例，基于 localStorage 进行封装。实现方法 setItem(key,value) 和 getItem(key)。"}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"思路",children:["思路",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思路",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["拿到单例模式相关的面试题，大家首先要做的是回忆我们上个小节的“基本思路”部分——至少要记起来",(0,a.jsx)(n.code,{children:"getInstance"}),"方法和",(0,a.jsx)(n.code,{children:"instance"}),"这个变量是干啥的。"]}),"\n",(0,a.jsx)(n.p,{children:"具体实现上，把判断逻辑写入静态方法或者构造函数里都没关系，最好能把闭包的版本也写出来，多多益善。"}),"\n",(0,a.jsx)(n.p,{children:"总之有了上节的基础，这个题简直是默写！"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"实现：静态方法版"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 定义Storage\nclass Storage {\n    static getInstance() {\n        // 判断是否已经new过1个实例\n        if (!Storage.instance) {\n            // 若这个唯一的实例不存在，那么先创建它\n            Storage.instance = new Storage()\n        }\n        // 如果这个唯一的实例已经存在，则直接返回\n        return Storage.instance\n    }\n    getItem (key) {\n        return localStorage.getItem(key)\n    }\n    setItem (key, value) {\n        return localStorage.setItem(key, value)\n    }\n}\n\nconst storage1 = Storage.getInstance()\nconst storage2 = Storage.getInstance()\n\nstorage1.setItem('name', '李雷')\n// 李雷\nstorage1.getItem('name')\n// 也是李雷\nstorage2.getItem('name')\n\n// 返回true\nstorage1 === storage2\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"实现： 闭包版"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 先实现一个基础的StorageBase类，把getItem和setItem方法放在它的原型链上\nfunction StorageBase () {}\nStorageBase.prototype.getItem = function (key){\n    return localStorage.getItem(key)\n}\nStorageBase.prototype.setItem = function (key, value) {\n    return localStorage.setItem(key, value)\n}\n\n// 以闭包的形式创建一个引用自由变量的构造函数\nconst Storage = (function(){\n    let instance = null\n    return function(){\n        // 判断自由变量是否为null\n        if(!instance) {\n            // 如果为null则new出唯一实例\n            instance = new StorageBase()\n        }\n        return instance\n    }\n})()\n\n// 这里其实不用 new Storage 的形式调用，直接 Storage() 也会有一样的效果 \nconst storage1 = new Storage()\nconst storage2 = new Storage()\n\nstorage1.setItem('name', '李雷')\n// 李雷\nstorage1.getItem('name')\n// 也是李雷\nstorage2.getItem('name')\n\n// 返回true\nstorage1 === storage2\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"实现一个全局的模态框",children:["实现一个全局的模态框",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现一个全局的模态框",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"描述-1",children:["描述",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#描述-1",children:"#"})]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"实现一个全局唯一的Modal弹框"}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"思路-1",children:["思路",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思路-1",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"这道题比较经典，基本上所有讲单例模式的文章都会以此为例，同时它也是早期单例模式在前端领域的最集中体现。"}),"\n",(0,a.jsxs)(n.p,{children:["万变不离其踪，记住",(0,a.jsx)(n.code,{children:"getInstance"}),"方法、记住",(0,a.jsx)(n.code,{children:"instance"}),"变量、记住闭包和静态方法，这个题除了要多写点 HTML 和 CSS 之外，对大家来说完全不成问题。"]}),"\n",(0,a.jsxs)(n.h3,{id:"实现",children:["实现",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"完整代码如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>单例模式弹框</title>\n</head>\n<style>\n    #modal {\n        height: 200px;\n        width: 200px;\n        line-height: 200px;\n        position: fixed;\n        left: 50%;\n        top: 50%;\n        transform: translate(-50%, -50%);\n        border: 1px solid black;\n        text-align: center;\n    }\n</style>\n<body>\n	<button id='open'>打开弹框</button>\n	<button id='close'>关闭弹框</button>\n</body>\n<script>\n    // 核心逻辑，这里采用了闭包思路来实现单例模式\n    const Modal = (function() {\n    	let modal = null\n    	return function() {\n            if(!modal) {\n            	modal = document.createElement('div')\n            	modal.innerHTML = '我是一个全局唯一的Modal'\n            	modal.id = 'modal'\n            	modal.style.display = 'none'\n            	document.body.appendChild(modal)\n            }\n            return modal\n    	}\n    })()\n    \n    // 点击打开按钮展示模态框\n    document.getElementById('open').addEventListener('click', function() {\n        // 未点击则不创建modal实例，避免不必要的内存占用;此处不用 new Modal 的形式调用也可以，和 Storage 同理\n    	const modal = new Modal()\n    	modal.style.display = 'block'\n    })\n    \n    // 点击关闭按钮隐藏模态框\n    document.getElementById('close').addEventListener('click', function() {\n    	const modal = new Modal()\n    	if(modal) {\n    	    modal.style.display = 'none'\n    	}\n    })\n<\/script>\n</html>\n"})}),"\n",(0,a.jsx)(n.p,{children:"是不是发现又是熟悉的套路？又可以默写了？（ES6 版本的实现大家自己尝试默写一下，相信对现在的你来说已经非常简单了）。"}),"\n",(0,a.jsx)(n.p,{children:"这就是单例模式面试题的特点，准确地说，是所有设计模式相关面试题的特点——牢记核心思路，就能举一反三。所以说设计模式的学习是典型的一分耕耘一分收获，性价比极高。"}),"\n",(0,a.jsx)(n.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(s,{...e})}):s(e)}let d=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["JavaScript%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F6.%E5%88%9B%E5%BB%BA%E5%9E%8B%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%A6.md"]={toc:[{text:"实现一个 Storage",id:"实现一个-storage",depth:2},{text:"描述",id:"描述",depth:3},{text:"思路",id:"思路",depth:3},{text:"实现一个全局的模态框",id:"实现一个全局的模态框",depth:2},{text:"描述",id:"描述-1",depth:3},{text:"思路",id:"思路-1",depth:3},{text:"实现",id:"实现",depth:3}],title:"6.创建型：单例模式——面试真题手把手教学",headingTitle:"6.创建型：单例模式——面试真题手把手教学",frontmatter:{}}}}]);