"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["8648"],{563044:function(e,n,c){c.r(n),c.d(n,{default:()=>t});var d=c(552676),o=c(740453);let s=c.p+"static/image/4d045ba285534effbabf1e1a9d18efaa~tplv-k3u1fbpfcp-zoom-1.image.0b37d491.png",r=c.p+"static/image/93a8bc31891e4b84bc9191185a92106e~tplv-k3u1fbpfcp-zoom-1.image.5da13eaa.png",i=c.p+"static/image/0d64b4bd8375473eb22e94311e84b9e0~tplv-k3u1fbpfcp-zoom-1.image.2a586d6b.png",l=c.p+"static/image/ecc54367df754726addbebc84c708e8a~tplv-k3u1fbpfcp-zoom-1.image.72b77573.png";function a(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",code:"code",strong:"strong",h2:"h2",pre:"pre",img:"img",br:"br",h3:"h3",h4:"h4",em:"em"},(0,o.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"21-从数学理论到函数组合monoidcompose-中的复合本质",children:["21 从数学理论到函数组合：Monoid、Compose 中的复合本质",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-从数学理论到函数组合monoidcompose-中的复合本质",children:"#"})]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["通过上一节的学习，我们已经清楚地知道：",(0,d.jsx)(n.code,{children:" concat() "}),(0,d.jsx)(n.strong,{children:"接口是对数学中的二元运算符的抽象。"})," ",(0,d.jsx)(n.code,{children:"concat()"}),"接口宛如一条【线】，它能够将链式调用中前后相邻的两个【点】（也就是“盒子”）串联起来，进行盒子间的二元运算。"]}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"concat-与-reduce-从二元运算到-n-元运算",children:[(0,d.jsx)(n.code,{children:"concat()"})," 与 ",(0,d.jsx)(n.code,{children:"reduce()"})," ：从二元运算到 n 元运算",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#concat-与-reduce-从二元运算到-n-元运算",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["这“连点成线”般的二元运算，可不是 ",(0,d.jsx)(n.code,{children:"concat()"}),"的专利。在遇到 ",(0,d.jsx)(n.code,{children:"concat()"}),"之前，我们其实已经和具备“二元运算符”特征的函数打过不少交道了。"]}),"\n",(0,d.jsxs)(n.p,{children:["没错，我说的就是 ",(0,d.jsx)(n.code,{children:"Array.prototype.reduce(callback, initialValue)"})," 里的那个 ",(0,d.jsx)(n.code,{children:"callback()"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"callback()"}),"和 ",(0,d.jsx)(n.code,{children:"concat()"}),"的工作流是极为相似的。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们首先来看 ",(0,d.jsx)(n.code,{children:"concat()"}),"接口组织起来的二元运算工作流，考虑这样一个链式的 ",(0,d.jsx)(n.code,{children:"concat()"})," 调用："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 定义一个类型为 Add 的 Monoid 盒子\nconst Add = (value) => ({\n  value,  \n  // concat 接收一个类型为 Add 的 Monoid 盒子作为入参\n  concat: (box) => Add(value + box.value)\n})   \n\n\n// 这个 empty() 函数就是加法运算的单位元\nAdd.empty = () => Add(0)  \n\nconst res = Add(1)\n              .concat(Add(2))\n              .concat(Add(3))\n              .concat(Add(4))\n\n// 输出 10\nconsole.log(res.value)\n"})}),"\n",(0,d.jsx)(n.p,{children:"它拉起来的二元运算工作流如下图所示："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:l,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"接着我们考虑这样一个 reduce 调用："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const callback = (x, y) =>  x + y   \n\nconst res = [1, 2, 3, 4].reduce(callback, 0) \n\n// 输出 10\nconsole.log(res)\n"})}),"\n",(0,d.jsx)(n.p,{children:"它拉起来的二元运算工作流如下图所示："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:i,alt:""})}),"\n",(0,d.jsx)(n.p,{children:"这两张图不能说是一模一样吧，只能说是十分相似。"}),"\n",(0,d.jsxs)(n.p,{children:["别的不说，就“",(0,d.jsx)(n.strong,{children:"两两组合，循环往复"}),"”这个流程特征来说，两者是高度一致的。"]}),"\n",(0,d.jsxs)(n.p,{children:["主要的区别在于，",(0,d.jsx)(n.code,{children:"concat()"}),"方法的宿主可以是任意一个 ",(0,d.jsx)(n.code,{children:"Semigroup/Monoid"})," 盒子，而 ",(0,d.jsx)(n.code,{children:"callback()"}),"和 ",(0,d.jsx)(n.code,{children:"reduce()"}),"一起，依附于数组数据结构而存在。"]}),"\n",(0,d.jsxs)(n.p,{children:["最重要的是，",(0,d.jsx)(n.code,{children:"reduce()"}),"还能够通过反复地调用",(0,d.jsx)(n.code,{children:"callback()"}),"，来",(0,d.jsx)(n.strong,{children:"将有限的二元运算延伸至无限的 n 元运算"}),"。",(0,d.jsx)(n.br,{}),"\n",(0,d.jsx)(n.code,{children:"concat()"})," 和 ",(0,d.jsx)(n.code,{children:"callback()"})," 这么相似，",(0,d.jsx)(n.code,{children:"concat()"}),"是不是也能和 ",(0,d.jsx)(n.code,{children:"reduce()"}),"打配合呢？"]}),"\n",(0,d.jsxs)(n.p,{children:["到这里，图穷匕见，华点也呼之欲出： 在实践中，",(0,d.jsx)(n.strong,{children:"Monoid 常常被放在"})," ",(0,d.jsx)(n.code,{children:"reduce"})," ",(0,d.jsx)(n.strong,{children:"的"})," ",(0,d.jsx)(n.code,{children:"callback"})," ",(0,d.jsx)(n.strong,{children:"中参与计算。"})]}),"\n",(0,d.jsx)(n.p,{children:"以加法运算为例，我们重新审视一下 Monoid 做加法的姿势："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 定义一个类型为 Add 的 Monoid 盒子\nconst Add = (value) => ({\n  value,  \n  // concat 接收一个类型为 Add 的 Monoid 盒子作为入参\n  concat: (box) => Add(value + box.value)\n})   \n\n\n// 这个 empty() 函数就是加法运算的单位元\nAdd.empty = () => Add(0)  \n\nconst res = Add(1)\n              .concat(Add(2))\n              .concat(Add(3))\n              .concat(Add(4))\n\n// 输出 10\nconsole.log(res.value)\n"})}),"\n",(0,d.jsxs)(n.p,{children:["一个 ",(0,d.jsx)(n.code,{children:"concat()"}),"函数一次只能求和两个数字，一旦数字多起来，我们就不得不重复执行许多次“将数字放进 Add 盒子，再调用 Add 盒子上的 ",(0,d.jsx)(n.code,{children:"concat()"}),"方法”这个过程。"]}),"\n",(0,d.jsxs)(n.p,{children:["如果能把 ",(0,d.jsx)(n.code,{children:"Add"})," 盒子放进 ",(0,d.jsx)(n.code,{children:"reduce()"})," 的 ",(0,d.jsx)(n.code,{children:"callback()"}),"里，就可以省去这类重复的操作。顺着这个思路，我们可以将楼上的链式调用改造如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 定义一个类型为 Add 的 Monoid 盒子\nconst Add = (value) => ({\n  value,  \n  // concat 接收一个类型为 Add 的 Monoid 盒子作为入参\n  concat: (box) => Add(value + box.value)\n})   \nAdd.empty = () => Add(0)     \n\n\n// 把 Add 盒子放进 reduce 的 callback 里去\nconst res = [1, 2, 3, 4].reduce((monoid, num) => monoid.concat(Add(num)), Add(0))\n"})}),"\n",(0,d.jsxs)(n.p,{children:["如此，我们便能够借助 ",(0,d.jsx)(n.code,{children:"reduce()"}),"方法，写出更加简洁的盒子代码。"]}),"\n",(0,d.jsxs)(n.h2,{id:"empty函数解决了什么问题",children:[(0,d.jsx)(n.code,{children:"empty()"}),"函数解决了什么问题",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#empty函数解决了什么问题",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"empty()"}),"函数能够解决 n 元运算中的计算起点（也即“初始值”）不存在的问题，这一点我们可以结合楼上的例子来看。请大家关注到 ",(0,d.jsx)(n.code,{children:"reduce()"}),"调用这一行："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 把 Add 盒子放进 reduce 的 callback 里去\nconst res = [1, 2, 3, 4].reduce((monoid, num) => monoid.concat(Add(num)), Add(0))\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在编写小册之前，我在线下也组织过几次函数式编程的分享会。“如何把 Monoid 盒子放进 ",(0,d.jsx)(n.code,{children:"reduce()"}),"”这个问题，我曾经把它作为白板编程题给到过现场的同学。在没有控制台辅助 debug 的情况下，不少同学都会给出这样的答案："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 把 Add 盒子放进 reduce 的 callback 里去\nconst res = [1, 2, 3, 4].reduce((monoid, num) => monoid.concat(Add(num)))\n"})}),"\n",(0,d.jsxs)(n.p,{children:["这里大家在打开上帝视角的情况下，一眼就能看出这段代码的问题所在——",(0,d.jsx)(n.code,{children:"reduce()"}),"接口缺少了初始值，会导致第一次的 ",(0,d.jsx)(n.code,{children:"monoid.concat()"}),"调用失败。"]}),"\n",(0,d.jsxs)(n.p,{children:["我在加法 Monoid 的代码里，使用 ",(0,d.jsx)(n.code,{children:"Add(0)"}),"作为计算起点，顺利地规避掉了这个问题。那么如果我们的 Monoid 从加法 ",(0,d.jsx)(n.code,{children:"Add"}),"变为了乘法 ",(0,d.jsx)(n.code,{children:"Multi"}),"，计算起点的值又该如何调整呢？"]}),"\n",(0,d.jsxs)(n.p,{children:["其实，无论是 Add 还是 Multi，无论是求和还是求积，我们对计算起点的预期总是一致的——",(0,d.jsx)(n.strong,{children:"它得是一个 Monoid/Semigroup 盒子（能够提供"})," ",(0,d.jsx)(n.code,{children:" concat()  "}),(0,d.jsx)(n.strong,{children:"接口），并且它的值不应该对计算结果产生任何影响"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["也就是说，",(0,d.jsx)(n.strong,{children:"计算起点和任何运算数结合的时候，都不应该改变那个运算数。"})," 细品一下，这说的不就是 Monoid 的单位元——",(0,d.jsx)(n.code,{children:"empty()"}),"函数么？"]}),"\n",(0,d.jsxs)(n.p,{children:["循着这个思路，我们不难想到，乘法盒子的计算起点应该是 Multi(1)，也就是 ",(0,d.jsx)(n.code,{children:"Multi.empty()"})," 的返回值："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 定义一个类型为 Multi 的 Monoid 盒子\nconst Multi = (value) => ({\n  value,  \n  // concat 接收一个类型为 Multi Monoid 盒子作为入参\n  concat: (box) => Multi(value * box.value)\n})     \nMulti.empty = () => Multi(1)     \n\n\n// n 元运算的计算起点是单位元函数 empty()\nconst res = [1, 2, 3, 4].reduce((monoid, num) => monoid.concat(Multi(num)), Multi.empty())\n"})}),"\n",(0,d.jsxs)(n.p,{children:["到这里，",(0,d.jsx)(n.code,{children:"empty()"}),"在实践中的作用就非常清晰了——当二元运算被拓展为 n 元运算时，我们需要 ",(0,d.jsx)(n.code,{children:"Monoid.empty()"}),"作为计算起点，进而规避空值的问题。"]}),"\n",(0,d.jsxs)(n.h2,{id:"concat--reduce-推导-foldmap-函数",children:[(0,d.jsx)(n.code,{children:"concat()"})," + ",(0,d.jsx)(n.code,{children:"reduce()"})," 推导 ",(0,d.jsx)(n.code,{children:"foldMap()"})," 函数",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#concat--reduce-推导-foldmap-函数",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["这里我用 Monoid 来表示一个任意的 Monoid 盒子，用 arr 来表示一个任意的数组，",(0,d.jsx)(n.code,{children:"concat()"}),"+",(0,d.jsx)(n.code,{children:"reduce()"}),"的组合代码就可以抽象如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"arr.reduce((monoid, value) => monoid.concat(Monoid(value)), Monoid.empty())\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在实践中，这段代码还有另一种写法，那就是先调用 ",(0,d.jsx)(n.code,{children:"map()"}),"，将数组中的所有元素都包装成 Monoid，然后再进行 ",(0,d.jsx)(n.code,{children:"reduce()"}),"调用，像这样："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"arr\n  .map((value)=> Monoid(value))\n  .reduce((monoid, currentMonoid) => monoid.concat(currentMonoid)), Monoid.empty())\n"})}),"\n",(0,d.jsxs)(n.p,{children:["这两段代码的功能是一猫一样的。这里我以 ",(0,d.jsx)(n.code,{children:"Multi"}),"盒子为例，分别尝试两种代码写法，得到的计算结果也是一致的："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 定义一个类型为 Multi 的 Monoid 盒子\nconst Multi = (value) => ({\n  value,  \n  // concat 接收一个类型为 Multi Monoid 盒子作为入参\n  concat: (box) => Multi(value * box.value)\n})     \nMulti.empty = () => Multi(1)     \n\nconst arr = [1, 2, 3, 4]  \n\n\nconst resV1 = arr\n              .reduce((monoid, value) => monoid.concat(Multi(value)), Multi.empty())  \n\nconst resV2 = arr\n              .map((value)=> Multi(value))\n              .reduce((prevMonoid, currentMonoid) => prevMonoid.concat(currentMonoid), Multi.empty())\n\n// true\nresV1.value === resV2.value\n"})}),"\n",(0,d.jsxs)(n.p,{children:["无论是直接 ",(0,d.jsx)(n.code,{children:"reduce()"}),"，还是先 ",(0,d.jsx)(n.code,{children:"map()"}),"再 ",(0,d.jsx)(n.code,{children:"reduce()"}),"，它们最终的目的都是“",(0,d.jsx)(n.strong,{children:"实现 n 元的 Monoid 盒子运算"}),"”。"]}),"\n",(0,d.jsxs)(n.p,{children:["在实际的项目中，一旦我们用到了盒子模式，“实现 n 元的 Monoid 盒子运算”就总是会成为一个非常高频的操作。正因为如此，我们一般不会等到使用的时候再去手动实现这些代码，而是会把这坨逻辑提取到一个工具函数里，以备不时之需。这个工具函数的名字，就叫做",(0,d.jsx)(n.code,{children:"foldMap()"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["对于",(0,d.jsx)(n.code,{children:"foldMap()"}),"来说，“实现 n 元的 Monoid 盒子运算”这个功能是固定的，而“运算符（也即 Monoid 盒子的类型）”以及“运算数（也即数组的内容）”则是动态的。动态信息总是以函数参数的形式传入。也就是说，",(0,d.jsx)(n.code,{children:"foldMap()"}),"函数的入参，就是楼上模板代码中的 ",(0,d.jsx)(n.code,{children:"Monoid"})," 和 ",(0,d.jsx)(n.code,{children:"arr"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["分析至此，",(0,d.jsx)(n.code,{children:"foldMap()"}),"的代码也就写完了："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// 这里我以 map+reduce 的写法为例，抽象 foldMap() 函数\nconst foldMap = (Monoid, arr) => \n                  arr\n                    .map(Monoid)\n                    .reduce(\n                      (prevMonoid, currentMonoid) => prevMonoid.concat(currentMonoid),\n                      Monoid.empty()\n                    )  \n\n// 定义 Multi 盒子\nconst Multi = (value) => ({\n  value,  \n  concat: (box) => Multi(value * box.value)\n})     \nMulti.empty = () => Multi(1)   \n\n// 使用 foldMap 实现 Multi 盒子求积功能   \nconst res = foldMap(Multi, [1, 2, 3, 4])   \n\n// 输出 24， 求积成功\nconsole.log(res.value)\n"})}),"\n",(0,d.jsxs)(n.h2,{id:"从-monoid-到函数组合",children:["从 Monoid 到函数组合",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从-monoid-到函数组合",children:"#"})]}),"\n",(0,d.jsxs)(n.h3,{id:"compose-特征两两组合循环往复",children:["compose 特征：两两组合、循环往复",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compose-特征两两组合循环往复",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["compose 的过程，也是一个“",(0,d.jsx)(n.strong,{children:"两两组合、循环往复"}),"”的过程，是一个",(0,d.jsx)(n.strong,{children:"由二元运算拓展至 n 元运算的过程"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"一个大的 compose，可以看作是无数个小的 compose 单元的组合。每个 compose 单元，都只会组合两个函数。这个最小的 compose 单元，用代码表示如下："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const compose = (func1, func2) => arg => func1(func2(arg))\n"})}),"\n",(0,d.jsxs)(n.p,{children:["读到这里，一些同学可能会有这样的疑虑：这里修言敢说 ",(0,d.jsx)(n.code,{children:"compose()"})," 是“两两组合、循环往复”的过程，是因为在",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422922192846907",target:"_blank",rel:"noopener noreferrer",children:"第14节"}),"实现 ",(0,d.jsx)(n.code,{children:"compose()"})," 函数的时候，修言【故意】使用了具备二元运算回调的 ",(0,d.jsx)(n.code,{children:"reduce()"}),"来实现 ",(0,d.jsx)(n.code,{children:"compose()"}),"，这才使得两个章节的逻辑互洽了——哈，修勾果然鸡贼！"]}),"\n",(0,d.jsxs)(n.p,{children:["绝非如此啊，家人们！ “两两组合，循环往复”其实是对 ",(0,d.jsx)(n.code,{children:"compose()"}),"逻辑特征的描述，而不是对",(0,d.jsx)(n.code,{children:"compose()"}),"编码实现的描述。 换言之，就算我们不用",(0,d.jsx)(n.code,{children:"reduce()"}),"来实现",(0,d.jsx)(n.code,{children:"compose()"}),"函数，这个特征也仍然成立。"]}),"\n",(0,d.jsxs)(n.p,{children:["为了深刻理解这一点，大家不妨回忆一下加法、乘法等运算符，这些运算符实现 n 元运算的思路，其实就是",(0,d.jsx)(n.strong,{children:"反复去做二元运算"}),"。以加法运算为例："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"1 + 2 + 3 + 4  \n"})}),"\n",(0,d.jsx)(n.p,{children:"4 个数字相加的过程，需要先把 1 和 2 相加，得到第一个求和结果 3，然后再把这个求和结果3和下一个数字3相加，得到第二个求和结果6；然后再把第二个求和结果6和下一个数字4相加，得到第三个求和结果10。（如下图所示）"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:r,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["相似的，”compose(组合)“这个动作，其实也是一个运算符。在数学中，我们用 ",(0,d.jsx)(n.code,{children:"f \xb7 g"}),"来描述函数 ",(0,d.jsx)(n.code,{children:"f"})," 和函数 ",(0,d.jsx)(n.code,{children:"g"})," 之间的组合关系。考虑以下 4 个待组合的函数："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"[func1, func2, func3, func4]\n"})}),"\n",(0,d.jsx)(n.p,{children:"把这 4 个函数组合成一个函数的过程，仍然是一个反复去做二元运算的过程（如下图所示）。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:s,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["开篇我们就说过，“两两组合、循环往复”是",(0,d.jsx)(n.code,{children:"Monoid.concat()"}),"的工作流特征。分析至此，我们又意识到，它同时也是 ",(0,d.jsx)(n.code,{children:"compose()"}),"的工作特征。"]}),"\n",(0,d.jsxs)(n.p,{children:["在意识到 ",(0,d.jsx)(n.code,{children:"Monoid"}),"和",(0,d.jsx)(n.code,{children:"compose()"}),"之间的相似性的同时，大家不妨做一些更大胆的假设，比如——用 ",(0,d.jsx)(n.code,{children:"Monoid"}),"的规则去理解 ",(0,d.jsx)(n.code,{children:"compose()"}),"。"]}),"\n",(0,d.jsxs)(n.h3,{id:"compose-与-monoid-的共性",children:["compose 与 Monoid 的共性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compose-与-monoid-的共性",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"这里我想要讨论的 compose，是“组合”这个动作本身，也就是“最小的 compose 单元”，也就是这个函数："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const compose = (func1, func2) => arg => func1(func2(arg))\n"})}),"\n",(0,d.jsxs)(n.p,{children:["我们重新回顾一下“什么是 Monoid”这个问题：Monoid = Semigroup + ",(0,d.jsx)(n.code,{children:"empty()"}),"函数。"]}),"\n",(0,d.jsxs)(n.p,{children:["我把 Semigroup 的特征代入这个公式，就能得到 Monoid 的特征：Monoid = 闭合 + 结合律 + 二元运算 + ",(0,d.jsx)(n.code,{children:"empty()"})," 函数"]}),"\n",(0,d.jsx)(n.p,{children:"Monoid 所具备的这些特征，compose 全中。"}),"\n",(0,d.jsxs)(n.h4,{id:"compose-是闭合的二元运算",children:["compose 是闭合的二元运算",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compose-是闭合的二元运算",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"我们不妨把“组合（compose）”这个动作看作一个运算符，把参与组合的函数看作是运算数，那么总是有："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"func1 compose func2 = func3\n"})}),"\n",(0,d.jsx)(n.p,{children:"一个函数 compose 另一个函数，总是能得到一个新的函数。运算符没有改变运算数的类型，因此 compose 运算是一个闭合的运算。"}),"\n",(0,d.jsx)(n.p,{children:"同时，compose 运算是一个“两两组合”的运算，也符合二元运算的特征。"}),"\n",(0,d.jsxs)(n.h4,{id:"compose-是符合结合律的",children:["compose 是符合结合律的",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compose-是符合结合律的",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"对于任意的三个函数 func1、func2、func3，总是有这样的规律："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"compose(\n  compose(func1, func2),\n  func3\n)= compose(\n  func1,\n  compose(func2, func3)\n)\n"})}),"\n",(0,d.jsx)(n.p,{children:"这个规律不是我说的，是数学家说的，他们是这样说的："}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:['All properties of composition of relations are true of composition of functions, such as the property of associativity. ——wikipedia "Function Composition"词条',(0,d.jsx)(n.br,{}),"\n","修言直译：所有“关系组合”的属性都是适用于函数组合的，比如结合律。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"他们也曾这样说过："}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["The composition of functions is always associative—a property inherited from the composition of relations.That is, if ",(0,d.jsx)(n.em,{children:"f"}),", ",(0,d.jsx)(n.em,{children:"g"}),", and ",(0,d.jsx)(n.em,{children:"h"})," are composable, then ",(0,d.jsx)(n.em,{children:"f"})," ∘ (",(0,d.jsx)(n.em,{children:"g"})," ∘ ",(0,d.jsx)(n.em,{children:"h"}),") = (",(0,d.jsx)(n.em,{children:"f"})," ∘ ",(0,d.jsx)(n.em,{children:"g"}),") ∘ ",(0,d.jsx)(n.em,{children:"h"}),". Since the parentheses do not change the result, they are generally omitted. ——mathresearch.utsa.edu/wiki",(0,d.jsx)(n.br,{}),"\n","修言直译：函数组合总是符合结合律的--这是从“关系组合”中继承下来的属性。具体来说，如果f、g和h是可以组合的，那么f∘（g∘h）=（f∘g）∘h。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"函数组合符合结合律这回事儿，也就轮不到我来证明了。"}),"\n",(0,d.jsxs)(n.h3,{id:"compose-的单位元如何实现",children:["compose 的单位元如何实现",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#compose-的单位元如何实现",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["分析至此，",(0,d.jsx)(n.code,{children:"compose()"}),"已经命中了 Semigroup 的全部特征：闭合、结合律、二元运算。它与 Monoid，只差一个 ",(0,d.jsx)(n.code,{children:"empty()"}),"单位元函数了。"]}),"\n",(0,d.jsxs)(n.p,{children:["其实，",(0,d.jsx)(n.code,{children:"compose()"}),"的单位元函数，咱们早在",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175423056620290103",target:"_blank",rel:"noopener noreferrer",children:"第18节"}),"就见过啦。没错，我说的就是 ",(0,d.jsx)(n.code,{children:"Identity Function"}),"（恒等函数）："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const identity = x => x\n"})}),"\n",(0,d.jsx)(n.p,{children:"恒等函数本身不包含任何的计算修改逻辑，它所做的仅仅是吃进一个入参，然后把它原封不动地吐出来，俗称“透传”。 一个“透传”函数和任何函数结合，都不会改变那个函数的运算结果。因此，恒等函数就是函数组合的“单位元”。"}),"\n",(0,d.jsxs)(n.p,{children:["至此我们发现，当我们把 ",(0,d.jsx)(n.code,{children:"compose()"}),"的最小计算单元视作一个运算符、把函数组合视作一个代数运算后，我们竟能从中挖掘出 ",(0,d.jsx)(n.code,{children:"Monoid"}),"的所有特征。"]}),"\n",(0,d.jsxs)(n.p,{children:["这也使我忍不住联想起了前几年在社区听到过的一种声音——“函数组合是一种 Monoid”。那之后我查了很多的资料，始终也没能为这个观点找到什么强有力的学术理论支撑。因此，上文的推导，并不是为了佐证这个观点，而是为了凸显我们在",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422979646423098",target:"_blank",rel:"noopener noreferrer",children:"第17节"}),"就阐述过的一个思路——",(0,d.jsx)(n.strong,{children:"范畴的本质是复合。"})]}),"\n",(0,d.jsxs)(n.h2,{id:"范畴的本质是复合",children:["范畴的本质是复合",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#范畴的本质是复合",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"范畴的本质是复合。 从实践的角度看，范畴论在 JS 中的应用，本质上还是为了解决函数组合的问题。"})}),"\n",(0,d.jsx)(n.p,{children:"这里说“函数组合”其实还不是特别严谨，通过本节的学习，相信大家都能够感受到，“组合”是一个更加泛的概念。除了函数的组合，还有“盒子”的组合。"}),"\n",(0,d.jsx)(n.p,{children:"那么如果更进一步地问：组合（Composition）是一个什么样的过程？"}),"\n",(0,d.jsxs)(n.p,{children:["截止目前，我们已经掌握了两个有代表性的 Composition 工具：",(0,d.jsx)(n.code,{children:"compose()"}),"函数和 ",(0,d.jsx)(n.code,{children:"foldMap()"}),"函数。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"compose()"}),"函数组合的是函数本身，而 ",(0,d.jsx)(n.code,{children:"foldMap()"}),"函数组合的则是不同的 Monoid 盒子。"]}),"\n",(0,d.jsxs)(n.p,{children:["这两种函数消化的入参类型不同，函数体的编码实现不同，但它们的逻辑特征却高度一致：",(0,d.jsx)(n.strong,{children:"通过多次执行二元运算，将有限的二元运算拓展为无限的 n 元运算。"})]}),"\n",(0,d.jsx)(n.p,{children:"两两结合，循环往复，聚沙成塔——这，就是“组合”过程。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}let t=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F21%20%E4%BB%8E%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA%E5%88%B0%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88%EF%BC%9AMonoid%E3%80%81Compose%20%E4%B8%AD%E7%9A%84%E5%A4%8D%E5%90%88%E6%9C%AC%E8%B4%A8.md"]={toc:[{text:"`concat()` 与 `reduce()` ：从二元运算到 n 元运算",id:"concat-与-reduce-从二元运算到-n-元运算",depth:2},{text:"`empty()`函数解决了什么问题",id:"empty函数解决了什么问题",depth:2},{text:"`concat()` + `reduce()` 推导 `foldMap()` 函数",id:"concat--reduce-推导-foldmap-函数",depth:2},{text:"从 Monoid 到函数组合",id:"从-monoid-到函数组合",depth:2},{text:"compose 特征：两两组合、循环往复",id:"compose-特征两两组合循环往复",depth:3},{text:"compose 与 Monoid 的共性",id:"compose-与-monoid-的共性",depth:3},{text:"compose 是闭合的二元运算",id:"compose-是闭合的二元运算",depth:4},{text:"compose 是符合结合律的",id:"compose-是符合结合律的",depth:4},{text:"compose 的单位元如何实现",id:"compose-的单位元如何实现",depth:3},{text:"范畴的本质是复合",id:"范畴的本质是复合",depth:2}],title:"21 从数学理论到函数组合：Monoid、Compose 中的复合本质",headingTitle:"21 从数学理论到函数组合：Monoid、Compose 中的复合本质",frontmatter:{}}}}]);