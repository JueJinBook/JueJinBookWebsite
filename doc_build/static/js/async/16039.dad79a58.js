"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16039"],{659263:function(e,r,n){n.r(r),n.d(r,{default:()=>c});var a=n(552676),s=n(740453);let i=n.p+"static/image/2128fcab187207ac326831536a0ad2ed.b7eb2a78.png";function l(e){let r=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",pre:"pre",code:"code"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(r.h1,{id:"27手写-babel-parser-篇",children:["27.手写 Babel： parser 篇",(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#27手写-babel-parser-篇",children:"#"})]}),"\n",(0,a.jsx)(r.p,{children:"parser 的功能是把源码转成 AST，支持各种语法的 parse。"}),"\n",(0,a.jsxs)(r.p,{children:["babel 的 parser 并不是从零自己实现的，而是基于 acron 做了扩展。在 ",(0,a.jsx)(r.a,{href:"https://juejin.cn/book/6946117847848321055/section/6947682728200372232",target:"_blank",rel:"noopener noreferrer",children:"《js parser 的历史》"}),"那一节大部分讲过 js parser 都是 estree 标准的，acorn 也是 estree 标准的实现，支持插件，"]}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(r.p,{children:"babel 就是基于 acorn，然后实现了 jsx、typescript、flow 等语法插件的扩展，并且修改了一些 AST，比如 Literal 扩展为了 StringLitreal、NumericLiteral 等。"}),"\n",(0,a.jsx)(r.p,{children:"所以，我们也不会从零实现 parser，也会采用基于 acron 扩下扩展的方式。"}),"\n",(0,a.jsxs)(r.h2,{id:"思路分析",children:["思路分析",(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,a.jsx)(r.p,{children:"acorn 插件的实现方式是继承之前的 Parser 返回新的 Parser，重写一些方法来做 AST 修改和扩充。"}),"\n",(0,a.jsx)(r.p,{children:"比如："}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"module.exports = function(Parser) {\n    return class extends Parser {\n        parseLiteral (...args) {\n            const node = super.parseLiteral(...args);\n            switch(typeof node.value) {\n                case 'number':\n                    node.type = 'NumericLiteral';\n                    break;\n                case 'string':\n                    node.type = 'StringLiteral';\n                    break;\n            }\n            return  node;\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(r.p,{children:"这是我们之前实现过的，把 Literal 扩展为 StringLiteral、NumericLiteral 等的一个插件。"}),"\n",(0,a.jsx)(r.p,{children:"之前还实现过扩展一个 guang 的关键字的插件。"}),"\n",(0,a.jsx)(r.p,{children:"我们希望提供这种 api："}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"const ast = parser.parse(sourceCode, {\n    plugins: ['literal', 'guangKeyword']\n});\n"})}),"\n",(0,a.jsx)(r.p,{children:"也就是根据传入的 plugins 来确定使用什么插件，然后返回扩展以后的 parser。实现方式就是保存一个插件的 map，按照传入的插件名使用就行。"}),"\n",(0,a.jsxs)(r.h2,{id:"代码实现",children:["代码实现",(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,a.jsx)(r.p,{children:"我们把插件放到不同的模块中，然后通过 map 来维护："}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"const syntaxPlugins = {\n    'literal': require('./plugins/literal'),\n    'guangKeyword': require('./plugins/guangKeyword')\n}\n"})}),"\n",(0,a.jsx)(r.p,{children:"之后实现 parse 的时候，先把 options 做合并，之后根据 plugin 来依此启用不同的插件。"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-javascript",children:"const defaultOptions = {\n    plugins: []\n}\n\nfunction parse(code, options) {\n    const resolvedOptions  = Object.assign({}, defaultOptions, options);\n\n    const newParser = resolvedOptions.plugins.reduce((Parser, pluginName) => {\n        let plugin = syntaxPlugins[pluginName]\n        return plugin ? Parser.extend(plugin) : Parser; \n    }, acorn.Parser);\n\n    return newParser.parse(code, {\n        locations: true\n    });\n}\n"})}),"\n",(0,a.jsx)(r.p,{children:"这里要指定 locations 为 true，也就是保留 AST 在源码中的位置信息，这个在生成 sourcemap 的时候会用的。"}),"\n",(0,a.jsx)(r.p,{children:"这样就实现了 parse 和语法插件功能。"}),"\n",(0,a.jsxs)(r.h2,{id:"总结",children:["总结",(0,a.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(r.p,{children:"parser 负责把源码转成 AST，js parser 大多是符合 estree 的标准的，acorn 也是对它的实现。"}),"\n",(0,a.jsx)(r.p,{children:"acorn 支持插件，可以扩展语法，babel parser 就是 fork 了 acorn 做了扩展，我们也通过类似的方式，实现了两个语法插件，然后通过 options 启用。"}),"\n",(0,a.jsx)(r.p,{children:"当然，我们没有实现类似 jsx、typescript 这种复杂语法插件。我们的目的只是理清 babel 实现思路，而不是做一个完善的 babel。"}),"\n",(0,a.jsxs)(r.p,{children:["（代码在",(0,a.jsx)(r.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),e.components);return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}let c=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F27.%E6%89%8B%E5%86%99%20Babel%EF%BC%9A%20parser%20%E7%AF%87.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"总结",id:"总结",depth:2}],title:"27.手写 Babel： parser 篇",headingTitle:"27.手写 Babel： parser 篇",frontmatter:{}}}}]);