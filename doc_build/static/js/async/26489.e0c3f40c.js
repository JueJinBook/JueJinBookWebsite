"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["26489"],{427181:function(e,n,c){c.r(n),c.d(n,{default:()=>h});var o=c(552676),s=c(740453);let t=c.p+"static/image/2a575f5d01df2c9b859e8ec3c2aa221c.8654655e.webp",r=c.p+"static/image/aab92c5d4d4faa5fa4f9ed2b7b2c0f76.ea7d4263.webp",i=c.p+"static/image/a5a862336ec374839070b10e49a06281.96ce06a4.webp",d=c.p+"static/image/e0eedf68de6d5a2b964d6a6283fbcc30.d2ad7d60.webp",a=c.p+"static/image/45c4f70608964331246142147313f374.2401fcfa.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",code:"code",pre:"pre",h2:"h2",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",img:"img",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.h1,{id:"10mock怎么替代不需要关注的逻辑",children:["10.Mock：怎么替代不需要关注的逻辑？",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10mock怎么替代不需要关注的逻辑",children:"#"})]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["代码仓库：",(0,o.jsx)(n.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["上节课我们学习了 Jest 提供的 FakeTimer，通过它我们可以“快进”定时任务用例，不再需要等待同样的定时时长来获取最终的结果了。在上节课的最后的一则用例中，我们使用了 ",(0,o.jsx)(n.code,{children:"jest.fn()"}),"来作为 ",(0,o.jsx)(n.code,{children:"asyncSleep"}),"函数的入参。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'import React from "react";\nimport { sleep, loopSleep, asyncSleep } from "../components/FakeTimer";\n\n// 9 | FakeTimer：如何"快进"测试定时任务？\ndescribe("examples for fakeTimers", () => {\n  beforeAll(() => {\n    jest.useFakeTimers();\n  });\n\n  // ... other content\n  test("a test for a setTimeout with async function", async () => {\n    const fn = jest.fn();\n    asyncSleep(6000, fn);\n    jest.runOnlyPendingTimers();\n    await Promise.resolve();\n    expect(fn).toBeCalled();\n  });\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"在上面这则例子中，因为我们并不关心传入 asyncSleep 的回调函数逻辑，我们只希望它可以在指定时间执行回调，所以我们这里使用了 jest 提供的 mock 函数作为它的入参。"}),"\n",(0,o.jsx)(n.p,{children:"因为我们之前的场景并不那么复杂，在实际的业务场景中，我们一个文件中往往穿插着各种引用。其中包含一些测试环境没有的 API 或者全局变量，或者不在我们测试范围内的外部文件，这都是很常见的现象，这些情况我们都需要使用 mock 来模拟它们进行测试。"}),"\n",(0,o.jsx)(n.p,{children:"所以在实际的业务单测中，mock 是很重要的测试手段，这节课我们就来结合场景捋捋，怎么通过 mock 来模拟一些不需要关注的逻辑。"}),"\n",(0,o.jsxs)(n.h2,{id:"全局-mock",children:["全局 mock",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局-mock",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"在业务场景中，我们可能会导入一些外部依赖进行测试，针对这些外部依赖，我们可能并不关心它的内部逻辑是怎么样的，我们只需要它可以返回预期的结果就好，对于这种场景，我们可以采取全局 mock 的方式，jest 为我们提供了一个 全局 mock 的 API。"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"jest.mock(path, moduleFactory)\n"})}),"\n",(0,o.jsx)(n.p,{children:"它接受两个参数，path 和 moduleFactory，其中 path 是需要 mock 的文件路径，moduleFactory 是这个模块的工厂函数，类型与模块保持一致就行，可以进行更自定义的 mock。"}),"\n",(0,o.jsx)(n.p,{children:"这个 mock 的执行会被提升到 import 之前，也就是对于这个文件而言，mock 的内容会替代原有的模块，我们以需求中最常见的场景请求（axios）为例子，看下如何通过全局的方式来测试请求。"}),"\n",(0,o.jsx)(n.p,{children:"首先我们来安装一下 axios 的依赖："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"npm install axios\n"})}),"\n",(0,o.jsx)(n.p,{children:"然后我们加上下面的用例："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'// ./src/__test__/mock.test.ts\nimport React from "react";\nimport axios from "axios";\n\njest.mock("axios");\n\n// 10 | Mock: 怎么替代不那么重要的逻辑？\ndescribe("examples for mock", () => {\n  test("a test for global mock", async () => {\n    const res = "this is a test for global mock";\n    axios.get.mockResolvedValue(res);\n    const data = await axios.get("/");\n    expect(data).toBe("this is a test for global mock");\n  });\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"在上面的例子中，我们用 mock 替代了 axios 的原生模块，其中 axios.get 会返回 jest 的 mockFn，mockResolvedValue 是 mockFn 提供的一个 API，通过它，我们可以模拟 mockFn 的异步返回值，除这个之外，我们还会经常用到以下几种:"}),"\n",(0,o.jsxs)(n.table,{children:["\n",(0,o.jsxs)(n.thead,{children:["\n",(0,o.jsxs)(n.tr,{children:["\n",(0,o.jsx)(n.th,{children:"mockFn 提供的 API"}),"\n",(0,o.jsx)(n.th,{children:"能力"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.tbody,{children:["\n",(0,o.jsxs)(n.tr,{children:["\n",(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"mockFn.mockReturnValue(value)"})}),"\n",(0,o.jsx)(n.td,{children:"Mock 返回值，同步"}),"\n"]}),"\n",(0,o.jsxs)(n.tr,{children:["\n",(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"mockFn.mockReturnValueOnce(value)"})}),"\n",(0,o.jsx)(n.td,{children:"Mock 返回值，同步，只生效一次"}),"\n"]}),"\n",(0,o.jsxs)(n.tr,{children:["\n",(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"mockFn.mockResolvedValue(value)"})}),"\n",(0,o.jsx)(n.td,{children:"Mock resolve 返回值，异步"}),"\n"]}),"\n",(0,o.jsxs)(n.tr,{children:["\n",(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"mockFn.mockResolvedValueOnce(value)"})}),"\n",(0,o.jsx)(n.td,{children:"Mock resolve 返回值，异步，只生效一次"}),"\n"]}),"\n",(0,o.jsxs)(n.tr,{children:["\n",(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"mockFn.mockRejectedValue(value)"})}),"\n",(0,o.jsx)(n.td,{children:"Mock reject 返回值，异步"}),"\n"]}),"\n",(0,o.jsxs)(n.tr,{children:["\n",(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"mockFn.mockRejectedValueOnce(value)"})}),"\n",(0,o.jsx)(n.td,{children:"Mock reject 返回值，异步, 只生效一次"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"现在我们可以来执行一下这个用例。用例执行的过程中大家可能会遇到下面的报错。"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:a,alt:""})}),"\n",(0,o.jsxs)(n.p,{children:["这是因为 axios1.x 现在只发出一个 ESM 模块，而不再是一个 CJS 模块，这会导致 Jest 出现解析错误，这是一个已知 ",(0,o.jsx)(n.a,{href:"https://github.com/axios/axios/issues/5026",target:"_blank",rel:"noopener noreferrer",children:"issue"}),"，目前还没得到解决。针对这个问题有两个解决方案。"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"我们可以降级 axios 版本到 0.27.2，这是 0.x 中最新的版本。"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:d,alt:""})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"仍然选择延用 1.x 的同学可以修改 jest.config.js 的配置，把 axios 移除测试编译范围。以我们当前项目为例子，因为我们使用的是 CRA，不通过 jest.config.js 配置，我们可以直接在 package.json 加上下面的配置，默认 node_modules jest 是不走 babel 编译的，现在我们把 axios 引入编译范围。"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'// ./package.json\n{\n  // ...\n  "jest": {\n    "transformIgnorePatterns": [\n      "node_modules/(?!axios)"\n    ]\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"直接使用 jest.config.js 配置的同学可以直接在 jest.config.js 中加上同样的配置："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'module.exports = {\n  // ...\n  transformIgnorePatterns: ["node_modules/(?!axios)"],\n};\n'})}),"\n",(0,o.jsx)(n.p,{children:"这两种方案都可以解决这个问题，大家可以根据自己对 axios 的需求自行选用："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:i,alt:""})}),"\n",(0,o.jsx)(n.p,{children:"不过因为 mock 是在 import 之前覆写的缘故，类型并没有得到修改，所以我们会有下面的类型报错："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:r,alt:""})}),"\n",(0,o.jsx)(n.p,{children:"这个问题我们可以通过 jest-mock 提供的 mocked 函数来解决，它会帮我们补充全局 mock 对应的 mockFn 类型，首先我们来安装一下依赖："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"npm install jest-mock\n"})}),"\n",(0,o.jsx)(n.p,{children:"然后我们来调整一下用例："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'// ./src/__test__/mock.test.ts\nimport React from "react";\nimport axios from "axios";\nimport { mocked } from "jest-mock";\n\njest.mock("axios");\n\n// 10 | Mock: 怎么替代不那么重要的逻辑？\ndescribe("examples for mock", () => {\n  test("a test for global mock", async () => {\n    const res = "this is a test for global mock";\n    // axios.get.mockResolvedValue(res);\n    mocked(axios.get).mockResolvedValue(res);\n    const data = await axios.get("/");\n    expect(data).toBe("this is a test for global mock");\n  });\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"可以看到现在就没有类型的报错了~"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:t,alt:""})}),"\n",(0,o.jsxs)(n.h2,{id:"单次-mock",children:["单次 mock",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单次-mock",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"上面我们提到针对 jest 的 mock API 会提升到 import 之前，也就是 import 的内容不再是原有的模块，除全局的 mock 外，我们还可以进行单次的 mock，jest 对于单次的 mock 提供了一个与 mock 对应的方法 —— doMock"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"jest.doMock(moduleName, factory, options)\n"})}),"\n",(0,o.jsx)(n.p,{children:"doMock 的使用与 mock 略有不同，我们可以先来看下下面的例子："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'// ./src/components/Mock/index.ts\nconst mock = {\n  getMockData: () => {\n    return "oldMockData";\n  },\n};\n\nexport default mock;\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'// ./src/__test__/mock.test.ts\nimport React from "react";\nimport axios from "axios";\nimport mock from "../components/Mock";\n\njest.mock("axios");\n\n// 10 | Mock: 怎么替代不那么重要的逻辑？\ndescribe("examples for mock", () => {\n  // ...other\n\n  test("a test for single mock", () => {\n    jest.doMock("../components/Mock", () => ({\n      __esModule: true,\n      getMockData: () => {\n        return "newMockData";\n      },\n    }));\n    // expect(mock.getMockData()).toBe("newMockData");\n    const mock = require("../components/Mock");\n    expect(mock.getMockData()).toBe("newMockData");\n  });\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"在这个例子中，有几个大家需要关注的点。"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"doMock 的第二个入参：也就是我们之前提到的 factory，我们可以通过这个参数来覆写原模块的属性和属性函数，让它们可以返回固定的逻辑或者值。"}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"__esModule: true"}),"：因为我们定义的 mock 模块是通过 esModule 导出的，所以需要加上这个属性帮助 jest 进行 mock。"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:'require("../components/Mock")'}),": 如果我们直接在全局定义，然后调用可以吗？当然不可以~ 因为 doMock 只会对我们这个 test 生效，而不会提升到 import 之前去覆写原有模块，所以需要采用在用例内 require 的方式导入，直接 import 的模块还会是原来的文件，并不会生效 mock。"]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"mock-函数",children:["mock 函数",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#mock-函数",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"除了 mock 和 doMock 外，jest 还提供了两个常用的 function 帮助我们进行函数的 mock："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"jest.fn(implementation?)\njest.spyOn(object, methodName)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["其中 ",(0,o.jsx)(n.code,{children:"jest.fn"})," 用于 mock 一个空函数，它会默认返回 undefined，当然我们也可以传入两个类型来控制它的入参和回参内容，例如",(0,o.jsx)(n.code,{children:"jest.fn<string, string>()"}),"就对应一个入参和回参都为 string 的 mock 函数了~"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"jest.spyon"}),"也可以创建一个和",(0,o.jsx)(n.code,{children:"jest.fn"}),"类似的 mock 函数，不同的是它可以追踪目标函数的调用，使得它的入参和回参与需要 mock 的函数是自动匹配的，对于全局 mock 中的那个类型问题，我们就可以使用",(0,o.jsx)(n.code,{children:"jest.spyon"}),"来解决。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'// ./src/__test__/mock.test.ts\nimport React from "react";\nimport axios from "axios";\n\njest.mock("axios");\n\n// 10 | Mock: 怎么替代不那么重要的逻辑？\ndescribe("examples for mock", () => {\n  test("a test for global mock", async () => {\n    const res = "this is a test for global mock";\n    // axios.get.mockResolvedValue(res);\n    jest.spyOn(axios, "get").mockResolvedValue(res);\n    const data = await axios.get("/");\n    expect(data).toBe("this is a test for global mock");\n  });\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"这样就不会有类型的问题了，不仅如此，单次 mock 中的例子我们也可以尝试使用它来覆盖："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'import React from "react";\nimport axios from "axios";\nimport mock from "../components/Mock";\n\njest.mock("axios");\n\n// 10 | Mock: 怎么替代不那么重要的逻辑？\ndescribe("examples for mock", () => {\n  // ...other\n\n  test("other ways for single mock", () => {\n    jest.spyOn(mock, "getMockData").mockReturnValue("newMockData");\n    expect(mock.getMockData()).toBe("newMockData");\n  });\n});\n'})}),"\n",(0,o.jsxs)(n.p,{children:["其实，通过 ",(0,o.jsx)(n.code,{children:"jest.spyOn"})," 足够覆盖我们需要的大部分场景，不过它一次只能 mock 一个对应的函数，如果需要对整体模块覆写，那我们还是需要 mock 和 doMock 来协助实现的。"]}),"\n",(0,o.jsxs)(n.h2,{id:"小结",children:["小结",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"这节课我们学习了怎么使用 mock 来替代不需要关注的逻辑，在我们的业务场景中，经常会引用一些外部或者全局逻辑，这些逻辑和我们需要测试的组件内容其实不那么相关，我们可能只需要这些逻辑能有预期的输入输出，通过这种场景我们都会使用 mock来解决。"}),"\n",(0,o.jsxs)(n.p,{children:["我们分别介绍了全局 mock，单次 mock 和 mock 函数三种场景，在全局 mock 中我们使用了 jest 的 ",(0,o.jsx)(n.code,{children:"mock"})," API，这个会被提升到文件的 import 之前，使得整个文件引用的对应模块都会采用我们进行的 mock，不过这个可能会有类型的问题，我们可以通过 jest-mock 提供的 ",(0,o.jsx)(n.code,{children:"mocked"})," 函数解决。"]}),"\n",(0,o.jsx)(n.p,{children:"紧接着我们还学习了单次 mock，与全局 mock 不同的是，它只会对单次的用例生效，我们需要采用 require 的方式来动态导入我们需要 mock 的模块。"}),"\n",(0,o.jsxs)(n.p,{children:["除了这些，我们还学习了 mock 函数中的 ",(0,o.jsx)(n.code,{children:"fn"})," 和 ",(0,o.jsx)(n.code,{children:"spyon"})," API，fn 需要自己定义入参和回参的类型，我们通常用它来定义一些简单、好定义类型的函数，而 spyon 自动追踪需要调用的函数类型进行 mock，通过它我们可以实现我们需要的大部分场景，不过它一次只能 mock 一个函数，针对一个模块，我们还是需要使用 ",(0,o.jsx)(n.code,{children:"mock"})," 和 ",(0,o.jsx)(n.code,{children:"doMock"})," 来完成。"]}),"\n",(0,o.jsx)(n.p,{children:"到这里，其实相信大部分的场景同学们都可以完成了，但是在 React 中还有一个很特殊而且使用广泛的模块 —— hook，与常规函数不同，hook 只能在组件中使用，我们并不能像测试函数一样直接去验证它的输入输出，不过也是有解决的办法的。下节课我们就来学习怎么对我们业务中的 hook 覆盖单测。"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}let h=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F10.Mock%EF%BC%9A%E6%80%8E%E4%B9%88%E6%9B%BF%E4%BB%A3%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%9F.md"]={toc:[{text:"全局 mock",id:"全局-mock",depth:2},{text:"单次 mock",id:"单次-mock",depth:2},{text:"mock 函数",id:"mock-函数",depth:2},{text:"小结",id:"小结",depth:2}],title:"10.Mock：怎么替代不需要关注的逻辑？",headingTitle:"10.Mock：怎么替代不需要关注的逻辑？",frontmatter:{}}}}]);