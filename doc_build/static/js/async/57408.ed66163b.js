"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57408"],{12410:function(e,n,t){t.r(n),t.d(n,{default:()=>f});var s=t(552676),i=t(740453);let r=t.p+"static/image/b0ea3de8390c3d0f8a69ff45fb0287e7.a0c2616c.webp",d=t.p+"static/image/a104a67ce67f629e00b673733f5292a0.89568135.webp",a=t.p+"static/image/fe8a730cd1900064873396f716f846ff.b2a58980.webp",o=t.p+"static/image/c99e8e7c8a7a0649a9e1a89d72171e61.48262175.gif",l=t.p+"static/image/51e53037033a0eddc6a00ac25575513b.56408ccd.gif",c=t.p+"static/image/2e4c0ce564f36696f21796711698db7f.2f3e5776.gif",h=t.p+"static/image/952f515093f09ea1e3d899b9feaf4a45.26bd69e1.gif",p=t.p+"static/image/493181572b4fd8af1209f23d0f71c1a6.6d1a1785.webp",m=t.p+"static/image/f3de5f2e934c9bc63d34e1f16ffb1e7b.d5d4adb7.webp",x=t.p+"static/image/b0962e0852935148bb58486a27382ee6.c9e9c9b5.webp",j=t.p+"static/image/d0f5dbc750d9bf3b41d5ed07ef7687e5.ad242a7f.webp",u=t.p+"static/image/c2a88bbd23b83a5e5ae9a609f9a3355a.adcdd868.gif",b=t.p+"static/image/e809347d6078109427da17d8ebdd7f06.807ad07d.gif";function g(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",code:"code",pre:"pre",h3:"h3",ol:"ol",li:"li",strong:"strong"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"38实战篇-_-react-notes-_-侧边栏笔记列表",children:["38.实战篇 _ React Notes _ 侧边栏笔记列表",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#38实战篇-_-react-notes-_-侧边栏笔记列表",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本篇我们来实现 React Notes 的左侧侧边栏部分。"}),"\n",(0,s.jsxs)(n.h2,{id:"sidebarnotelist",children:["SidebarNoteList",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#sidebarnotelist",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"现在我们接着完善笔记列表，毕竟笔记列表这里还要实现展开和收回功能："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:"展开收回.gif"})}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"components/SidebarNoteList.js"}),"代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import SidebarNoteItem from '@/components/SidebarNoteItem';\n\nexport default async function NoteList({ notes }) {\n\n  const arr = Object.entries(notes);\n\n  if (arr.length == 0) {\n    return <div className=\"notes-empty\">\n      {'No notes created yet!'}\n    </div>\n  }\n\n  return <ul className=\"notes-list\">\n    {arr.map(([noteId, note]) => {\n    return <li key={noteId}>\n      <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />\n    </li>\n  })}\n  </ul>\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里我们将具体的每条笔记抽离成单独的 ",(0,s.jsx)(n.code,{children:"SidebarNoteItem"})," 组件，",(0,s.jsx)(n.code,{children:"components/SidebarNoteItem.js"}),"代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import dayjs from 'dayjs';\nimport SidebarNoteItemContent from '@/components/SidebarNoteItemContent';\n\nexport default function SidebarNoteItem({ noteId, note}) {\n\n  const { title, content = '', updateTime } = note;\n  return (\n    <SidebarNoteItemContent\n      id={noteId}\n      title={note.title}\n      expandedChildren={\n        <p className=\"sidebar-note-excerpt\">\n          {content.substring(0, 20) || <i>(No content)</i>}\n        </p>\n      }>\n      <header className=\"sidebar-note-header\">\n        <strong>{title}</strong>\n        <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>\n      </header>\n    </SidebarNoteItemContent>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里我们又抽离了一个 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"})," 组件，用来实现展开和收回功能，我们将笔记的标题和时间的 JSX 作为 children 传递给了 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"}),"，",(0,s.jsx)(n.code,{children:"components/SidebarNoteItemContent.js"}),"代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"'use client';\n\nimport { useState, useRef, useEffect, useTransition } from 'react';\nimport { useRouter, usePathname } from 'next/navigation'\n\nexport default function SidebarNoteContent({\n  id,\n  title,\n  children,\n  expandedChildren,\n}) {\n  const router = useRouter()\n  const pathname = usePathname()\n  const selectedId = pathname?.split('/')[1] || null\n\n  const [isPending] = useTransition()\n  const [isExpanded, setIsExpanded] = useState(false)\n  const isActive = id === selectedId\n\n  // Animate after title is edited.\n  const itemRef = useRef(null);\n  const prevTitleRef = useRef(title);\n\n  useEffect(() => {\n    if (title !== prevTitleRef.current) {\n      prevTitleRef.current = title;\n      itemRef.current.classList.add('flash');\n    }\n  }, [title]);\n\n  return (\n    <div\n      ref={itemRef}\n      onAnimationEnd={() => {\n        itemRef.current.classList.remove('flash');\n      }}\n      className={[\n        'sidebar-note-list-item',\n        isExpanded ? 'note-expanded' : '',\n      ].join(' ')}>\n      {children}\n      <button\n        className=\"sidebar-note-open\"\n        style={{\n          backgroundColor: isPending\n            ? 'var(--gray-80)'\n            : isActive\n              ? 'var(--tertiary-blue)'\n              : '',\n          border: isActive\n            ? '1px solid var(--primary-border)'\n            : '1px solid transparent',\n        }}\n        onClick={() => {\n          const sidebarToggle = document.getElementById('sidebar-toggle')\n          if (sidebarToggle) {\n            sidebarToggle.checked = true\n          }\n          router.push(`/note/${id}`)\n        }}>\n        Open note for preview\n      </button>\n      <button\n        className=\"sidebar-note-toggle-expand\"\n        onClick={(e) => {\n          e.stopPropagation();\n          setIsExpanded(!isExpanded);\n        }}>\n        {isExpanded ? (\n          <img\n            src=\"/chevron-down.svg\"\n            width=\"10px\"\n            height=\"10px\"\n            alt=\"Collapse\"\n          />\n        ) : (\n          <img src=\"/chevron-up.svg\" width=\"10px\" height=\"10px\" alt=\"Expand\" />\n        )}\n      </button>\n      {isExpanded && expandedChildren}\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"})," 具体的实现其实并不重要，你只要知道这是一个客户端组件就行了。在这个客户端组件里我们用了 ",(0,s.jsx)(n.code,{children:"useState"})," 来控制展开和收回的状态，然后添加了一些动画效果，仅此而已。如果步骤正确的话，此时的页面效果为："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:"展开收回2.gif"})}),"\n",(0,s.jsx)(n.p,{children:"我们成功的实现了组件的展开和收回功能！"}),"\n",(0,s.jsxs)(n.h2,{id:"服务端组件和客户端组件",children:["服务端组件和客户端组件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务端组件和客户端组件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"现在让我们回顾下此时的侧边栏组件结构情况："}),"\n",(0,s.jsxs)(n.p,{children:["我们声明了一个 ",(0,s.jsx)(n.code,{children:"Sidebar"})," 组件用于实现侧边栏，其中有一个子组件 ",(0,s.jsx)(n.code,{children:"SidebarNoteList"})," 用于实现侧边栏的笔记列表部分，针对每一条笔记，我们抽离了一个 ",(0,s.jsx)(n.code,{children:"SidebarNoteItem"})," 组件来实现，在 ",(0,s.jsx)(n.code,{children:"SidebarNoteItem"})," 中，我们又抽离了一个名为 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"})," 的客户端组件用于实现展开和收回功能，然后我们在 ",(0,s.jsx)(n.code,{children:"SidebarNoteItem"})," 这个服务端组件中将笔记的标题和时间这段 JSX 作为 ",(0,s.jsx)(n.code,{children:"children"})," 传递给 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["这个时候你可能会有个疑问：为什么要这样做呢？为什么不直接把 ",(0,s.jsx)(n.code,{children:"SidebarNoteItem"})," 声明为客户端组件，然后直接在这个组件里全部实现呢？还要用传递 ",(0,s.jsx)(n.code,{children:"children"})," 这么复杂的方式？"]}),"\n",(0,s.jsxs)(n.h3,{id:"使用指南",children:["使用指南",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用指南",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["倒不着急回答这个问题。因为这段功能的实现涉及到我们开发 Next.js 项目常用的服务端组件和客户端组件导入，所以先让我们回顾下",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-31",target:"_blank",rel:"noopener noreferrer",children:"相关的使用知识"}),"（这很重要，开发的时候要谨记）："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"服务端组件可以导入客户端组件，但客户端组件并不能导入服务端组件"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"从服务端组件到客户端组件传递的数据需要可序列化"}),"，以刚才的例子为例："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// components/SidebarNoteItem.js\n\nexport default function SidebarNoteItem({ noteId, note}) {\n	// ...\n  return (\n    <SidebarNoteItemContent\n      id={noteId}\n      title={note.title}\n			fun={() => {}}\n      expandedChildren={\n        <p className="sidebar-note-excerpt">\n          {content.substring(0, 20) || <i>(No content)</i>}\n        </p>\n      }>\n      <header className="sidebar-note-header">\n        <strong>{title}</strong>\n        <small>{dayjs(updateTime).format(\'YYYY-MM-DD hh:mm:ss\')}</small>\n      </header>\n    </SidebarNoteItemContent>\n  );\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["所谓可序列化，简单的理解就是 JSON.stringify() 这段数据不会出现错误，如果我们在这里传递一个函数 ",(0,s.jsx)(n.code,{children:"fun={() => {}}"}),"，就会出现错误提示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"但 JSX 对象是可以正常传递的，正如这个例子中展示的那样。"}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"但你可以将服务端组件以 props 的形式传给客户端组件"}),"，其实刚才的实现里就展现了两种传递服务端组件的形式："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// components/SidebarNoteItem.js\n\nexport default function SidebarNoteItem({ noteId, note}) {\n\n  const { title, content = '', updateTime } = note;\n  return (\n    <SidebarNoteItemContent\n      id={noteId}\n      title={note.title}\n      // 第一种方式\n      expandedChildren={\n        <p className=\"sidebar-note-excerpt\">\n          {content.substring(0, 20) || <i>(No content)</i>}\n        </p>\n      }>\n      // 第二种方式\n      <header className=\"sidebar-note-header\">\n        <strong>{title}</strong>\n        <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>\n      </header>\n    </SidebarNoteItemContent>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"服务端组件特性",children:["服务端组件特性",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务端组件特性",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"现在让我们重新审视一下 SidebarNoteItem 的代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// components/SidebarNoteItem.js\nimport dayjs from 'dayjs';\n\nimport SidebarNoteItemContent from '@/components/SidebarNoteItemContent';\n\nexport default function SidebarNoteItem({ noteId, note}) {\n\n  const { title, content = '', updateTime } = note;\n  return (\n    <SidebarNoteItemContent\n      id={noteId}\n      title={note.title}\n      expandedChildren={\n        <p className=\"sidebar-note-excerpt\">\n          {content.substring(0, 20) || <i>(No content)</i>}\n        </p>\n      }>\n      <header className=\"sidebar-note-header\">\n        <strong>{title}</strong>\n        <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>\n      </header>\n    </SidebarNoteItemContent>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"考验你是否认真学习了之前的知识到了！"}),"\n",(0,s.jsxs)(n.p,{children:["在这段代码中，",(0,s.jsx)(n.code,{children:"SidebarNoteItem"})," 是一个服务端组件，在这个组件中我们引入了 dayjs 这个库，然而我们却是在 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"})," 这个客户端组件中使用的 dayjs。请问最终客户端的 bundle 中是否会打包 dayjs 这个库？"]}),"\n",(0,s.jsx)(n.p,{children:"关于这个结果，反正效果我们都实现了，直接去查看一下就知道了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["所以答案是不会。",(0,s.jsx)(n.strong,{children:"在服务端组件中使用 JSX 作为传递给客户端组件的 prop，JSX 会先进行服务端组件渲染，再发送到客户端组件中"}),"。也就是说，发送给客户端组件的并不是："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<header className=\"sidebar-note-header\">\n  <strong>{title}</strong>\n  <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>\n</header>\n"})}),"\n",(0,s.jsx)(n.p,{children:"而是编译后的如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<header class="sidebar-note-header">\n  <strong>ea molestias</strong>\n  <small>2023-12-13 05:19:48</small>\n</header>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["其实这里我们也完全可以把 header 抽离成一个 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemHeader"})," 服务端组件，这样效果会更明显："]}),"\n",(0,s.jsxs)(n.p,{children:["新建 ",(0,s.jsx)(n.code,{children:"/components/SidebarNoteItemHeader.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import dayjs from 'dayjs';\n\nexport default function SidebarNoteItemHeader({title, updateTime}) {\n  return (\n      <header className=\"sidebar-note-header\">\n          <strong>{title}</strong>\n          <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>\n      </header>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"SidebarNoteItem.js"}),"文件代码为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import SidebarNoteItemContent from '@/components/SidebarNoteItemContent';\nimport SidebarNoteItemHeader from '@/components/SidebarNoteItemHeader';\n\nexport default function SidebarNoteItem({ noteId, note}) {\n\n  const { title, content = '', updateTime } = note;\n  return (\n    <SidebarNoteItemContent\n      id={noteId}\n      title={note.title}\n      expandedChildren={\n        <p className=\"sidebar-note-excerpt\">\n          {content.substring(0, 20) || <i>(No content)</i>}\n        </p>\n      }>\n        <SidebarNoteItemHeader title={title} updateTime={updateTime} />\n    </SidebarNoteItemContent>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"现在我们查看下开发者工具中的的 Source 选项："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:"截屏2023-12-15 下午8.45.30.png"})}),"\n",(0,s.jsxs)(n.p,{children:["你会发现 ",(0,s.jsx)(n.code,{children:"components"})," 下并没有我们刚建立的 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemHeader"})," 组件，只有一个客户端组件 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"}),"，node_modules 下也没有 dayjs（如果你把 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemHeader"})," 声明为客户端组件就有了）。"]}),"\n",(0,s.jsx)(n.p,{children:"最后让我们查看下 localhost 这个文件的 HTML："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"截屏2023-12-15 下午4.06.39.png"})}),"\n",(0,s.jsx)(n.p,{children:"传给客户端组件的 JSX 这些内容也会直接渲染到 HTML 中，当然这里跟客户端组件还是服务端组件无关，是客户端组件也会预渲染，只是提一下而已。"}),"\n",(0,s.jsxs)(n.h3,{id:"最佳实践客户端组件下移",children:["最佳实践：客户端组件下移",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最佳实践客户端组件下移",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们在 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-29",target:"_blank",rel:"noopener noreferrer",children:"《渲染篇 | 服务端组件和客户端组件》"}),"中讲到 ",(0,s.jsx)(n.strong,{children:"“尽可能将客户端组件在组件树中下移”"}),"，这里就是一个很好的例子。我们本可以直接把 ",(0,s.jsx)(n.code,{children:"SidebarNoteItem"})," 声明为客户端组件，然后直接在这个组件里全部实现，但是却抽离了一个名为 ",(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"})," 的客户端组件用于实现展开和收回功能。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"SidebarNoteItemContent"})," 的内容原本是 ",(0,s.jsx)(n.code,{children:"SidebarNoteList"})," 的子组件，现在却是 ",(0,s.jsx)(n.code,{children:"SidebarNoteItem"})," 的子组件。虽然在组件树中的位置下移了，但我们却因此避免了 dayjs 这个库被打包到客户端 bundle 中。在开发的时候，应该尽可能缩减客户端组件的范围。"]}),"\n",(0,s.jsxs)(n.h2,{id:"editbutton",children:["EditButton",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#editbutton",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"New"})," 和 ",(0,s.jsx)(n.code,{children:"Edit"})," 按钮考虑到复用，我们单独抽离成一个 ",(0,s.jsx)(n.code,{children:"EditButton"}),"组件："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// components/EditButton.js\nimport Link from 'next/link'\n\nexport default function EditButton({noteId, children}) {\n  const isDraft = noteId == null;\n  return (\n    <Link href={`/note/edit/${noteId || ''}`} className=\"link--unstyled\">\n      <button\n        className={[\n          'edit-button',\n          isDraft ? 'edit-button--solid' : 'edit-button--outline',\n        ].join(' ')}\n        role=\"menuitem\">\n        {children}\n      </button>\n    </Link>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Sidebar 组件引入一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// ...\nimport EditButton from \'@/components/EditButton\';\n\nexport default async function Sidebar() {\n  const notes = await getAllNotes()\n  return (\n    <>\n      	// ...\n        <section className="sidebar-menu" role="menubar">\n          <EditButton noteId={null}>New</EditButton>\n        </section>\n        <nav>\n          <SidebarNoteList notes={notes} />\n        </nav>\n      </section>\n    </>\n  )\n}\n\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"suspense",children:["Suspense",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#suspense",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"原 Demo 中当笔记列表加载的时候是有骨架图的效果的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"suspense2.gif"})}),"\n",(0,s.jsxs)(n.p,{children:["这说明肯定用了 ",(0,s.jsx)(n.code,{children:"Suspense"}),"。因为我们现在将笔记列表数据的获取放在了顶层，所以直接为 ",(0,s.jsx)(n.code,{children:"SidebarNoteList"})," 添加 ",(0,s.jsx)(n.code,{children:"Suspense"})," 是没有效果的，我们需要将数据获取改为在 ",(0,s.jsx)(n.code,{children:"SidebarNoteList"})," 组件内部。"]}),"\n",(0,s.jsxs)(n.p,{children:["修改",(0,s.jsx)(n.code,{children:"Sidebar.js"})," 代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import React, { Suspense } from \'react\'\nimport Link from \'next/link\'\n\nimport SidebarNoteList from \'@/components/SidebarNoteList\';\nimport EditButton from \'@/components/EditButton\';\nimport NoteListSkeleton from \'@/components/NoteListSkeleton\';\n\n// // 移除数据请求部分，为 SidebarNoteList 添加 Suspense 以及 fallback UI NoteListSkeleton\nexport default async function Sidebar() {\n\n  return (\n    <>\n      <section className="col sidebar">\n        <Link href={\'/\'} className="link--unstyled">\n          <section className="sidebar-header">\n            <img\n              className="logo"\n              src="/logo.svg"\n              width="22px"\n              height="20px"\n              alt=""\n              role="presentation"\n              />\n            <strong>React Notes</strong>\n          </section>\n        </Link>\n        <section className="sidebar-menu" role="menubar">\n          <EditButton noteId={null}>New</EditButton>\n        </section>\n        <nav>\n          <Suspense fallback={<NoteListSkeleton />}>\n            <SidebarNoteList />\n          </Suspense>\n        </nav>\n      </section>\n    </>\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["添加 ",(0,s.jsx)(n.code,{children:"/components/NoteListSkeleton.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'export default function NoteListSkeleton() {\n  return (\n    <div>\n      <ul className="notes-list skeleton-container">\n        <li className="v-stack">\n          <div\n            className="sidebar-note-list-item skeleton"\n            style={{height: \'5em\'}}\n          />\n        </li>\n        <li className="v-stack">\n          <div\n            className="sidebar-note-list-item skeleton"\n            style={{height: \'5em\'}}\n          />\n        </li>\n        <li className="v-stack">\n          <div\n            className="sidebar-note-list-item skeleton"\n            style={{height: \'5em\'}}\n          />\n        </li>\n      </ul>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"/components/SidebarNoteList.js"}),"代码如下，为了让效果更加明显，我们添加了一个 sleep 函数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import SidebarNoteItem from '@/components/SidebarNoteItem';\nimport { getAllNotes } from '@/lib/redis';\n\nexport default async function NoteList() {\n  const sleep = ms => new Promise(r => setTimeout(r, ms));\n  await sleep(10000);\n  const notes = await getAllNotes()\n\n  const arr = Object.entries(notes);\n\n  if (arr.length == 0) {\n    return <div className=\"notes-empty\">\n      {'No notes created yet!'}\n    </div>\n  }\n\n  return <ul className=\"notes-list\">\n    {arr.map(([noteId, note]) => {\n      return <li key={noteId}>\n        <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />\n      </li>\n    })}\n  </ul>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时页面效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"suspense3.gif"})}),"\n",(0,s.jsx)(n.p,{children:"我们成功实现了骨架图效果！"}),"\n",(0,s.jsxs)(n.p,{children:["那么问题来了，",(0,s.jsx)(n.code,{children:"SidebarNoteList"})," 用 ",(0,s.jsx)(n.code,{children:"Suspense"})," 和不用 ",(0,s.jsx)(n.code,{children:"Suspense"}),"，具体有什么改变呢？比如，使用 ",(0,s.jsx)(n.code,{children:"Suspense"})," 会带来新的请求吗？"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以自己测试一下，",(0,s.jsx)(n.strong,{children:"答案是不会。"})," 之前是那 10 个请求，使用后还是那 10 个请求。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么使用 ",(0,s.jsx)(n.code,{children:"Suspense"})," 和不使用 ",(0,s.jsx)(n.code,{children:"Suspense"}),"，到底有什么差别呢？其实我们看下用和不用的效果就知道了。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们把 sleep 的时间设置为 5s。这是不使用 Suspense 的效果，我们从掘金页面输入地址 ",(0,s.jsx)(n.code,{children:"http://localhost:3000/"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"use suspense.gif"})}),"\n",(0,s.jsx)(n.p,{children:"输入地址后，我们等待了大概 5s 后，页面突然完全展现。"}),"\n",(0,s.jsxs)(n.p,{children:["这是使用 Suspense 的效果，我们还是从掘金页面输入地址 ",(0,s.jsx)(n.code,{children:"http://localhost:3000/"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"use suspense2.gif"})}),"\n",(0,s.jsx)(n.p,{children:"输入地址后，我们立刻就跳转到了页面，笔记列表部分等待了 5s 后，开始展现。除此之外，使用 Suspense，数据加载不会阻塞页面，也就是说在笔记列表还在加载的时候，用户依然可以与页面其他部分进行交互，比如点击 New 按钮新建笔记。"}),"\n",(0,s.jsx)(n.p,{children:"那么问题又来了，页面请求数没有变化，也没有新的请求，这些又都是服务端组件，数据请求都在服务端，到底谁等待了那 5s 呢，然后把数据返回的呢？"}),"\n",(0,s.jsxs)(n.p,{children:["答案在于 ",(0,s.jsx)(n.code,{children:"localhost"})," 这个 HTML 页面，查看网络请求，刚开始页面加载的时候，localhost 的 Time 为 126ms："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"加载完成后，localhost 的 Time 变成了 5s："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["之所以这样，正如",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309076865732640818",target:"_blank",rel:"noopener noreferrer",children:"《渲染篇 | Streaming 和 Edge Runtime》"}),"中介绍的那样，答案在于 HTML 是通过 stream 格式进行传输的，查看 HTML 文件的响应头："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:"截屏2023-12-15 下午7.42.29.png"})}),"\n",(0,s.jsxs)(n.p,{children:["其 ",(0,s.jsx)(n.code,{children:"Transfer-Encoding"})," 标头的值为 ",(0,s.jsx)(n.code,{children:"chunked"}),"，表示数据将以一系列分块的形式进行发送。HTML 首先收到骨架图的 HTML 进行渲染，再收到渲染完成的笔记列表 HTML 进行渲染，查看一下 localhost HTML 文件的返回："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n\n  </head>\n  <body>\n    <div class="container">\n      <div class="main">\n        // ...\n        <nav>\n          \x3c!--$?--\x3e\n          <template id="B:0"></template>\n          \x3c!--这里是骨架图 NoteListSkeleton 的 HTML--\x3e\n          <div>\n            <ul class="notes-list skeleton-container">\n              <li class="v-stack">\n                <div class="sidebar-note-list-item skeleton" style="height:5em"></div>\n              </li>\n              <li class="v-stack">\n                <div class="sidebar-note-list-item skeleton" style="height:5em"></div>\n              </li>\n              <li class="v-stack">\n                <div class="sidebar-note-list-item skeleton" style="height:5em"></div>\n              </li>\n            </ul>\n          </div>\n          \x3c!--/$--\x3e\n        </nav>\n      </div>\n    </div>\n    // ...\n    <div hidden id="S:0">\n      \x3c!--这里是笔记列表 SidebarNoteList 的 HTML--\x3e\n      <ul class="notes-list">\n        <li>\n          <div class="sidebar-note-list-item ">\n            <header class="sidebar-note-header">\n              <strong>ea molestias</strong>\n              <small>2023-12-13 05:19:48</small>\n            </header>\n            <button class="sidebar-note-open" style="border:1px solid transparent">Open note for preview</button>\n            <button class="sidebar-note-toggle-expand">\n              <img src="/chevron-up.svg" width="10px" height="10px" alt="Expand"/>\n            </button>\n          </div>\n        </li>\n        <li>\n          <div class="sidebar-note-list-item ">\n            <header class="sidebar-note-header">\n              <strong>qui est</strong>\n              <small>2023-12-13 05:19:48</small>\n            </header>\n            <button class="sidebar-note-open" style="border:1px solid transparent">Open note for preview</button>\n            <button class="sidebar-note-toggle-expand">\n              <img src="/chevron-up.svg" width="10px" height="10px" alt="Expand"/>\n            </button>\n          </div>\n        </li>\n        <li>\n          <div class="sidebar-note-list-item ">\n            <header class="sidebar-note-header">\n              <strong>sunt aut</strong>\n              <small>2023-12-13 05:19:48</small>\n            </header>\n            <button class="sidebar-note-open" style="border:1px solid transparent">Open note for preview</button>\n            <button class="sidebar-note-toggle-expand">\n              <img src="/chevron-up.svg" width="10px" height="10px" alt="Expand"/>\n            </button>\n          </div>\n        </li>\n      </ul>\n    </div>\n    <script>\n      $RC = function(b, c, e) {\n         // ... 	\n      }\n      $RC("B:0", "S:0")\n    <\/script>\n  </body>\n</html>\n\n'})}),"\n",(0,s.jsx)(n.p,{children:"因为代码比较多，所以做了一点精简，你会发现在这个 HTML 里，骨架图的 HTML 和笔记列表的 HTML 都返回了，所以使用 Suspense 和 Streaming 不用担心会对 SEO 造成影响。"}),"\n",(0,s.jsxs)(n.h3,{id:"最佳实践使用-suspense",children:["最佳实践：使用 Suspense",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最佳实践使用-suspense",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Suspense 的效果就是允许你推迟渲染某些内容，直到满足某些条件（例如数据加载完毕）。在开发 Next.js 项目的时候，有数据加载的地方多考虑是否可以使用 ",(0,s.jsx)(n.code,{children:"Suspense"})," 或者 ",(0,s.jsx)(n.code,{children:"loading.js"}),"带来更好的体验。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"那么今天的内容就结束了，本篇我们完善了侧边栏笔记列表的效果，了解了在 Next.js 中使用服务端组件和客户端组件的注意事项，学习到了两个最佳实践："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"客户端组件下移"}),"\n",(0,s.jsx)(n.li,{children:"使用 Suspense"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["本篇的代码我已经上传到",(0,s.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/main",target:"_blank",rel:"noopener noreferrer",children:"代码仓库"}),"的 Day2 分支：",(0,s.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day2",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-react-notes-demo/tree/day2"}),"，直接使用的时候不要忘记在本地开启 Redis。"]})]})}function N(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}let f=N;N.__RSPRESS_PAGE_META={},N.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F38.%E5%AE%9E%E6%88%98%E7%AF%87%20_%20React%20Notes%20_%20%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%AC%94%E8%AE%B0%E5%88%97%E8%A1%A8.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"SidebarNoteList",id:"sidebarnotelist",depth:2},{text:"服务端组件和客户端组件",id:"服务端组件和客户端组件",depth:2},{text:"使用指南",id:"使用指南",depth:3},{text:"服务端组件特性",id:"服务端组件特性",depth:3},{text:"最佳实践：客户端组件下移",id:"最佳实践客户端组件下移",depth:3},{text:"EditButton",id:"editbutton",depth:2},{text:"Suspense",id:"suspense",depth:2},{text:"最佳实践：使用 Suspense",id:"最佳实践使用-suspense",depth:3},{text:"总结",id:"总结",depth:2}],title:"38.实战篇 _ React Notes _ 侧边栏笔记列表",headingTitle:"38.实战篇 _ React Notes _ 侧边栏笔记列表",frontmatter:{}}}}]);