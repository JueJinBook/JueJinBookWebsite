"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["8291"],{744670:function(e,n,r){r.r(n),r.d(n,{default:()=>u});var a=r(552676),s=r(740453);let o=r.p+"static/image/86b0e5087f5f22e1ce5025172607b0a7.65d7821e.png",c=r.p+"static/image/4ab3d167e8f831a8c5cc426e3e7975d1.883ce8d6.png",t=r.p+"static/image/869bf3bbbb262c749c68daf886a6e646.86201705.png",l=r.p+"static/image/410255b06f12a84d7a0e456c8eeb74e0.c3c1ec79.png",i=r.p+"static/image/d846ad566cb2d839545344950f96622e.7c962104.png",d=r.p+"static/image/6a25442874c7851a934a12d5ed7221bd.3cf18a07.png";function p(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",img:"img",h3:"h3",pre:"pre",code:"code",h4:"h4"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"22实战案例_-js-解释器",children:["22.实战案例_ JS 解释器",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22实战案例_-js-解释器",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"代码 parse 成 AST 之后，可以对 AST 进行 transform，然后 generate 成目标代码，这是转译器（transpiler）的流程，也可以对 AST 进行解释执行，这是解释器（interpreter）的流程。这一节，我们来基于 babel parser 来实现一个简单的 js 解释器。"}),"\n",(0,a.jsxs)(n.h2,{id:"v8-的编译流水线",children:["v8 的编译流水线",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#v8-的编译流水线",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"v8 包括 4 部分，parser、ignation 解释器，JIT 编译器，还有 garbage collector（垃圾回收器）。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"parser 负责把源码 parse 成 AST。"}),"\n",(0,a.jsx)(n.li,{children:"ignation 解释器负责把 AST 转成字节码，然后解释执行"}),"\n",(0,a.jsx)(n.li,{children:"turbofan 可以把代码编译成机器码，直接执行"}),"\n",(0,a.jsx)(n.li,{children:"gc 负责堆内存的垃圾回收"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"其实最早期的 v8 是没有字节码的，就是直接解释执行 AST:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"这种直接解释执行 AST 的解释器叫做 tree walker 解释器，这一节，我们来实现一下这种 js 解释器。"}),"\n",(0,a.jsxs)(n.h2,{id:"实现-js-解释器",children:["实现 JS 解释器",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-js-解释器",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"思路分析",children:["思路分析",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"当 parser 把 源码 parse 成 AST 之后，其实已经能够拿到源码的各部分信息了，比如"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const a = 1 + 2;\n"})}),"\n",(0,a.jsx)(n.p,{children:"对应的 AST 是这样的"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"当我们处理到 BinarayExpression 节点，operator 是 +，会做加法运算，取左右两边的值相加。"}),"\n",(0,a.jsx)(n.p,{children:"当我们处理到 NumercLiteral 节点，是数字字面量，直接返回它的值（value）。"}),"\n",(0,a.jsx)(n.p,{children:"当我们处理到 Identifier 节点，是标识符，直接返回名字（name）。"}),"\n",(0,a.jsx)(n.p,{children:"当我们处理到 VariableDeclarator，我们就知道是一个变量声明语句，要在作用域 （scope）中放一个属性，属性名为 id 的值， 属性值为 init 的值。而 id 和 init 可以求出来。"}),"\n",(0,a.jsx)(n.p,{children:"就这样，我们就完成了这段代码的解释执行。"}),"\n",(0,a.jsxs)(n.h4,{id:"代码实现",children:["代码实现",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"先搭一个基本的结构："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const  parser = require('@babel/parser');\nconst { codeFrameColumns } = require('@babel/code-frame');\n\nconst sourceCode = `\n   const a = 1 + 2;\n`;\n\nconst ast = parser.parse(sourceCode, {\n    sourceType: 'unambiguous'\n});\n\nconst evaluator = (function() {\n\n    const astInterpreters = {\n        Program (node, scope) {\n            node.body.forEach(item => {\n                evaluate(item, scope);\n            })\n        }\n    }\n\n    const evaluate = (node, scope) => {\n        try {\n            return astInterpreters[node.type](node, scope);\n        } catch(e) {\n            if (e && e.message && e.message.indexOf('astInterpreters[node.type] is not a function') != -1) {\n                console.error('unsupported ast type: ' + node.type);\n                console.error(codeFrameColumns(sourceCode, node.loc, {\n                    highlightCode: true\n                }));\n            } else {\n                console.error(e.message);\n                console.error(codeFrameColumns(sourceCode, node.loc, {\n                    highlightCode: true\n                }));                \n            }\n        }\n    }\n    return {\n        evaluate\n    }\n})();\n\nconst globalScope = {};\nevaluator.evaluate(ast.program, globalScope);\n"})}),"\n",(0,a.jsx)(n.p,{children:"我们定义了一个 evaluator，这个就是 AST 解释器。从根节点来执行，最外层是 File 节点，取 program 属性，Program 有 body 属性，是 AST 的数组，遍历执行。如果有不支持的节点类型，通过 code frame 来打印 AST 对应的代码，并且提示不支持。"}),"\n",(0,a.jsx)(n.p,{children:"创建一个全局作用域传入每个 evaluate 方法，用于作用域中变量的声明和取值。"}),"\n",(0,a.jsx)(n.p,{children:"然后我们来实现一下 VariableDeclarator 节点的解释，在 astInterpreters 添加一下节点的支持："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"VariableDeclaration(node, scope) {\n    node.declarations.forEach((item) => {\n        evaluate(item, scope);\n    });\n},\nVariableDeclarator(node, scope) {\n    const declareName = evaluate(node.id);\n    if (scope[declareName]) {\n        throw Error('duplicate declare variable：' + declareName);\n    } else {\n        scope[declareName] = evaluate(node.init, scope);\n    }\n},\nExpressionStatement(node, scope) {\n    return evaluate(node.expression, scope);\n},\nBinaryExpression(node, scope) {\n    const leftValue = evaluate(node.left, scope);\n    const rightValue = evaluate(node.right, scope);;\n    switch(node.operator) {\n        case '+':\n            return leftValue + rightValue;\n        case '-':\n            return leftValue - rightValue;\n        case '*':\n            return leftValue * rightValue;\n        case '/':\n            return leftValue / rightValue;\n        default: \n            throw Error('upsupported operator：' + node.operator);\n    }\n},\nIdentifier(node, scope) {\n    return node.name;\n},\nNumericLiteral(node, scope) {\n    return node.value;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["因为声明语句可能有 ",(0,a.jsx)(n.code,{children:"const a = 1, b=2;"})," 的一条语句多个声明的情况在，所以这里是 VariableDeclaration 包含多个 VariableDeclarator 的结构。每一个声明要检查下作用域中有没有，如果有的话就报错，没有的话才可以声明。（这里是按照严格模式的规定来解释的）"]}),"\n",(0,a.jsx)(n.p,{children:"BinaryExpression 根据 operator 的不同做不同的求值，只支持了 +、-、*、/ 四种运算。"}),"\n",(0,a.jsx)(n.p,{children:"执行完成后，我们打印一下 globalScope 看下效果。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"发现 globalScope 中已经声明了一个变量 a，值为 3。"}),"\n",(0,a.jsx)(n.p,{children:"但我们肯定不能这样来查看结果，需要支持 console.log 的全局 api 和函数调用逻辑。"}),"\n",(0,a.jsxs)(n.p,{children:["这个阶段的全部代码（也可以从 ",(0,a.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"github 上"}),"下载下来看）："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const  parser = require('@babel/parser');\nconst { codeFrameColumns } = require('@babel/code-frame');\n\nconst sourceCode = `\n   const a = 1 + 2;\n`;\n\nconst ast = parser.parse(sourceCode, {\n    sourceType: 'unambiguous'\n});\n\nconst evaluator = (function() {\n\n    const astInterpreters = {\n        Program (node, scope) {\n            node.body.forEach(item => {\n                evaluate(item, scope);\n            })\n        },\n        VariableDeclaration(node, scope) {\n            node.declarations.forEach((item) => {\n                evaluate(item, scope);\n            });\n        },\n        VariableDeclarator(node, scope) {\n            const declareName = evaluate(node.id);\n            if (scope[declareName]) {\n                throw Error('duplicate declare variable：' + declareName);\n            } else {\n                scope[declareName] = evaluate(node.init, scope);\n            }\n        },\n        ExpressionStatement(node, scope) {\n            return evaluate(node.expression, scope);\n        },\n        BinaryExpression(node, scope) {\n            const leftValue = evaluate(node.left, scope);\n            const rightValue = evaluate(node.right, scope);;\n            switch(node.operator) {\n                case '+':\n                    return leftValue + rightValue;\n                case '-':\n                    return leftValue - rightValue;\n                case '*':\n                    return leftValue * rightValue;\n                case '/':\n                    return leftValue / rightValue;\n                default: \n                    throw Error('upsupported operator：' + node.operator);\n            }\n        },\n        Identifier(node, scope) {\n            return node.name;\n        },\n        NumericLiteral(node, scope) {\n            return node.value;\n        }\n    }\n\n    const evaluate = (node, scope) => {\n        try {\n            return astInterpreters[node.type](node, scope);\n        } catch(e) {\n            if (e && e.message && e.message.indexOf('astInterpreters[node.type] is not a function') != -1) {\n                console.error('unsupported ast type: ' + node.type);\n                console.error(codeFrameColumns(sourceCode, node.loc, {\n                    highlightCode: true\n                }));\n            } else {\n                console.error(e.message);\n                console.error(codeFrameColumns(sourceCode, node.loc, {\n                    highlightCode: true\n                }));                \n            }\n        }\n    }\n    return {\n        evaluate\n    }\n})();\n\nconst globalScope = {};\nevaluator.evaluate(ast.program, globalScope);\n\nconsole.log(globalScope);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"",children:(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,a.jsx)(n.p,{children:"要支持函数调用，首先要支持作用域链，因为函数执行会生成一个新的作用域，并且会按照作用域链查找变量。"}),"\n",(0,a.jsx)(n.p,{children:"我们定义一个 scope 类："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"class Scope {\n    constructor(parentScope) {\n        this.parent = parentScope;\n        this.declarations = [];\n    }\n\n    set(name, value) {\n        this.declarations[name] = value;\n    }\n\n    getLocal(name) {\n        return this.declarations[name];\n    }\n\n    get(name) {\n        let res = this.getLocal(name);\n        if (res === undefined && this.parent) {\n            res = this.parent.get(name);\n        }\n        return res;\n    }\n\n    has(name) {\n        return !!this.getLocal(name);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Scope 有 declarations 属性，代表这个 scope 中声明的变量，并且还有 parentScope 属性指向父 scope，通过 set 方法在作用域中声明变量，通过 getLocal 查找本作用域的变量，通过 get 方法支持按照作用域链不断向上查找变量。"}),"\n",(0,a.jsx)(n.p,{children:"有了这个方法以后，我们全局 scope 就变成了："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const globalScope = new Scope();\n\nevaluator.evaluate(ast.program, globalScope);\n"})}),"\n",(0,a.jsx)(n.p,{children:"我们往其中注入全局变量："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const globalScope = new Scope();\nglobalScope.set('console', {\n    log: function (...args) {\n        console.log(chalk.green(...args));\n    },\n    error: function (...args) {\n        console.log(chalk.red(...args));\n    },\n    warn: function (...args) {\n        console.log(chalk.orange(...args));\n    },\n});\nevaluator.evaluate(ast.program, globalScope);\n"})}),"\n",(0,a.jsx)(n.p,{children:"这里我们通过 chalk 做了不同颜色的打印。"}),"\n",(0,a.jsx)(n.p,{children:"然后需要支持 CallExpression 的函数调用："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"MemberExpression(node, scope) {\n    const obj = scope.get(evaluate(node.object));\n    return obj[evaluate(node.property)]\n},\nCallExpression(node, scope) {\n    const fn = evaluate(node.callee, scope);\n    const args = node.arguments.map(item => {\n        if (item.type === 'Identifier') {\n            return scope.get(item.name);\n        }\n        return evaluate(item, scope);\n    });\n    if(node.callee.type === 'MemberExpression') {\n        const obj = evaluate(node.callee.object, scope);\n        return fn.apply(obj, args);\n    } else {\n        return fn.apply(null, args);\n    }\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"console.log 是一个 MemberExpression，先从 scope 中把 object 属性对应的值取出来，然后再取改值的 property 对应的属性。"}),"\n",(0,a.jsx)(n.p,{children:"函数调用 CallExpression 需要先从 scope 取出 callee 对应的函数，然后处理参数，如果是标识符 Identifier 的话要从 scope 中取出对应的值，之后调用这个函数，传入参数。如果是 obj.xxx 的形式也就是调用部分是 MemberExpresion 的话则要绑定 this 为该 obj。"}),"\n",(0,a.jsx)(n.p,{children:"执行下看下效果："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,a.jsx)(n.p,{children:"能够打印正确的结果，我们的 JS 解释器已经支持函数调用了。"}),"\n",(0,a.jsxs)(n.h3,{id:"函数调用",children:["函数调用",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数调用",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"现在我们只是在全局注入函数，如果用户想自定义函数呢，我们还需要支持函数声明语句 FunctionDeclaration 的解释。"}),"\n",(0,a.jsx)(n.p,{children:"FunctionDeclaration 其实也是往作用域中放了一个值，只不过这个值是一个函数，流程和变量声明 VariableDeclarator 的解释类似。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"FunctionDeclaration(node, scope) {\n    const declareName = evaluate(node.id);\n    if (scope.get(declareName)) {\n        throw Error('duplicate declare variable：' + declareName);\n    } else {\n        scope.set(declareName, function(...args) {\n            const funcScope = new Scope();\n            funcScope.parent = scope;\n\n            node.params.forEach((item, index) => {\n                funcScope.set(item.name, args[index]);\n            });\n            funcScope.set('this', this);\n            return evaluate(node.body, funcScope);\n        });\n    }\n},\n"})}),"\n",(0,a.jsx)(n.p,{children:"函数会生成一个新的 scope，我们把函数接收到的参数按照声明的 params 的名字，依次设置在 scope 中，this 也设置到作用域中（其实作用域和 this 是平行的关系，都在执行上下文中，这里简单实现下），然后调用这个函数的时候，就可以在作用域中查找到这个函数，并传入参数执行了。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"前面的章节，我们学习了 AST，知道 AST 可以进行 transform 然后生成代码，这一节，我们解释执行了 AST，实现了一个简单的 JS 解释器，可以定义函数、变量，有作用域链，可以注入全局 api。"}),"\n",(0,a.jsx)(n.p,{children:"v8 最早的实现方式也是直接解释执行 AST，但是现在多了一层，会先转成字节码，然后再解释执行。但是解释执行的思路和 AST 的方式类似。"}),"\n",(0,a.jsx)(n.p,{children:"我们是用 js 解释的 js，所以 funciton 的 apply 方法、全局 api 等都可以直接用，实际上一般 js 引擎都是 c++ 写的，没有这些东西，所有的都要自己去实现，包括内存分配（堆、调用栈）、全局 api等。"}),"\n",(0,a.jsx)(n.p,{children:"搞懂这个案例之后，你会对 JS 代码的执行原理有更深入的认识。"}),"\n",(0,a.jsxs)(n.p,{children:["（代码在",(0,a.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}let u=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F22.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B_%20JS%20%E8%A7%A3%E9%87%8A%E5%99%A8.md"]={toc:[{text:"v8 的编译流水线",id:"v8-的编译流水线",depth:2},{text:"实现 JS 解释器",id:"实现-js-解释器",depth:2},{text:"思路分析",id:"思路分析",depth:3},{text:"代码实现",id:"代码实现",depth:4},{text:"",id:"",depth:3},{text:"函数调用",id:"函数调用",depth:3},{text:"总结",id:"总结",depth:2}],title:"22.实战案例_ JS 解释器",headingTitle:"22.实战案例_ JS 解释器",frontmatter:{}}}}]);