"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["51759"],{283478:function(n,e,s){s.r(e),s.d(e,{default:()=>b});var d=s(552676),r=s(740453);let i=s.p+"static/image/1cf2fbb7c351dab27e0f73add257f92e.be6d18d8.webp",l=s.p+"static/image/6b99011b58a1ac30e55c2103093a8df0.450f6334.webp",c=s.p+"static/image/fc39900ff090aa7465bf1d18041da854.deccd5a5.webp",t=s.p+"static/image/5d124695f4606715e523988774367e42.defd5fe0.webp",a=s.p+"static/image/ab81da0f0ef77f07e6275ecf5668d3a8.0157a161.webp",o=s.p+"static/image/b4223fe3d54843d82eb4c4a7ad9ae232.39326e5a.webp",h=s.p+"static/image/efb4291719b90dd7ecbcf1e6c0d67b4e.3ef7998e.webp",u=s.p+"static/image/138349afefa315226c1bf0992aa8742d.5ef39188.webp",p=s.p+"static/image/1b0690be89a5e777b75f0576afab21a2.da3545ee.webp",x=s.p+"static/image/96ce2feb47391c210266a3098fa5babc.befa1e42.webp";function j(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ol:"ol",li:"li",strong:"strong",pre:"pre",h3:"h3",img:"img",h4:"h4",blockquote:"blockquote"},(0,r.ah)(),n.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.h1,{id:"9得力的性能推手_-esbuild-功能使用与插件开发实战",children:["9.得力的性能推手_ Esbuild 功能使用与插件开发实战",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#9得力的性能推手_-esbuild-功能使用与插件开发实战",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["上一小节，我们介绍了 Vite 的双引擎架构。不可否认，作为 Vite 的双引擎之一，Esbuild 在很多关键的构建阶段(如",(0,d.jsx)(e.code,{children:"依赖预编译"}),"、",(0,d.jsx)(e.code,{children:"TS 语法转译"}),"、",(0,d.jsx)(e.code,{children:"代码压缩"}),")让 Vite 获得了相当优异的性能，是 Vite 高性能的得力助手。无论是在 Vite 的配置项还是源码实现中，都包含了不少 Esbuild 本身的基本概念和高阶用法。因此，要深入掌握 Vite，学习 Esbuild 必不可少。"]}),"\n",(0,d.jsx)(e.p,{children:"本小节，我们将专注于 Esbuild 本身，一起学习它的基本概念和功能使用，同时实战开发一个完整的 Esbuild 插件。"}),"\n",(0,d.jsxs)(e.h2,{id:"为什么-esbuild-性能极高",children:["为什么 Esbuild 性能极高？",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么-esbuild-性能极高",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["Esbuild 是由 Figma 的 CTO 「Evan Wallace」基于 Golang 开发的一款打包工具，相比传统的打包工具，主打性能优势，在构建速度上可以比传统工具快 ",(0,d.jsx)(e.code,{children:"10~100"})," 倍。那么，它是如何达到这样超高的构建性能的呢？主要原因可以概括为 4 点。"]}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.strong,{children:"使用 Golang 开发"}),"，构建逻辑代码直接被编译为原生机器码，而不用像 JS 一样先代码解析为字节码，然后转换为机器码，大大节省了程序运行时间。"]}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.strong,{children:"多核并行"}),"。内部打包算法充分利用多核 CPU 优势，所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势。"]}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.strong,{children:"从零造轮子"}),"。 几乎没有使用任何第三方库，所有逻辑自己编写，大到 AST 解析，小到字符串的操作，保证极致的代码性能。"]}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.strong,{children:"高效的内存利用"}),"。Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据（如 string -> TS -> JS -> string)，造成内存的大量浪费。"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h2,{id:"esbuild-功能使用",children:["Esbuild 功能使用",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#esbuild-功能使用",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["接下来我们正式学习 Esbuild 的功能使用。首先我们执行",(0,d.jsx)(e.code,{children:"pnpm init"}),"新建一个项目, 然后通过如下的命令完成 Esbuild 的安装:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:"pnpm i esbuild@0.14.18\n"})}),"\n",(0,d.jsxs)(e.p,{children:["使用 Esbuild 有 2 种方式，分别是 ",(0,d.jsx)(e.strong,{children:"命令行调用"}),"和",(0,d.jsx)(e.strong,{children:"代码调用"}),"。"]}),"\n",(0,d.jsxs)(e.h3,{id:"1-命令行调用",children:["1. 命令行调用",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-命令行调用",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["命令行方式调用也是最简单的使用方式。我们先来写一些示例代码，新建",(0,d.jsx)(e.code,{children:"src/index.jsx"}),"文件，内容如下:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:'// src/index.jsx\nimport Server from "react-dom/server";\n\nlet Greet = () => <h1>Hello, juejin!</h1>;\nconsole.log(Server.renderToString(<Greet />));\n'})}),"\n",(0,d.jsx)(e.p,{children:"注意安装一下所需的依赖，在终端执行如下的命令:"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:"pnpm install react react-dom\n"})}),"\n",(0,d.jsxs)(e.p,{children:["接着到",(0,d.jsx)(e.code,{children:"package.json"}),"中添加",(0,d.jsx)(e.code,{children:"build"}),"脚本:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-json",children:' "scripts": {\n    "build": "./node_modules/.bin/esbuild src/index.jsx --bundle --outfile=dist/out.js"\n },\n'})}),"\n",(0,d.jsxs)(e.p,{children:["现在，你可以在终端执行",(0,d.jsx)(e.code,{children:"pnpm run build"}),"，可以发现如下的日志信息:"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,d.jsx)(e.p,{children:"说明我们已经成功通过命令行完成了 Esbuild 打包！但命令行的使用方式不够灵活，只能传入一些简单的命令行参数，稍微复杂的场景就不适用了，所以一般情况下我们还是会用代码调用的方式。"}),"\n",(0,d.jsxs)(e.h3,{id:"2-代码调用",children:["2. 代码调用",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-代码调用",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["Esbuild 对外暴露了一系列的 API，主要包括两类: ",(0,d.jsx)(e.code,{children:"Build API"}),"和",(0,d.jsx)(e.code,{children:"Transform API"}),"，我们可以在 Nodejs 代码中通过调用这些 API 来使用 Esbuild 的各种功能。"]}),"\n",(0,d.jsxs)(e.h4,{id:"项目打包build-api",children:["项目打包——Build API",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#项目打包build-api",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.code,{children:"Build API"}),"主要用来进行项目打包，包括",(0,d.jsx)(e.code,{children:"build"}),"、",(0,d.jsx)(e.code,{children:"buildSync"}),"和",(0,d.jsx)(e.code,{children:"serve"}),"三个方法。"]}),"\n",(0,d.jsxs)(e.p,{children:["首先我们来试着在 Node.js 中使用",(0,d.jsx)(e.code,{children:"build"})," 方法。你可以在项目根目录新建",(0,d.jsx)(e.code,{children:"build.js"}),"文件，内容如下:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:'const { build, buildSync, serve } = require("esbuild");\n\nasync function runBuild() {\n  // 异步方法，返回一个 Promise\n  const result = await build({\n    // ----  如下是一些常见的配置  --- \n    // 当前项目根目录\n    absWorkingDir: process.cwd(),\n    // 入口文件列表，为一个数组\n    entryPoints: ["./src/index.jsx"],\n    // 打包产物目录\n    outdir: "dist",\n    // 是否需要打包，一般设为 true\n    bundle: true,\n    // 模块格式，包括`esm`、`commonjs`和`iife`\n    format: "esm",\n    // 需要排除打包的依赖列表\n    external: [],\n    // 是否开启自动拆包\n    splitting: true,\n    // 是否生成 SourceMap 文件\n    sourcemap: true,\n    // 是否生成打包的元信息文件\n    metafile: true,\n    // 是否进行代码压缩\n    minify: false,\n    // 是否开启 watch 模式，在 watch 模式下代码变动则会触发重新打包\n    watch: false,\n    // 是否将产物写入磁盘\n    write: true,\n    // Esbuild 内置了一系列的 loader，包括 base64、binary、css、dataurl、file、js(x)、ts(x)、text、json\n    // 针对一些特殊的文件，调用不同的 loader 进行加载\n    loader: {\n      \'.png\': \'base64\',\n    }\n  });\n  console.log(result);\n}\n\nrunBuild();\n'})}),"\n",(0,d.jsxs)(e.p,{children:["随后，你在命令行执行",(0,d.jsx)(e.code,{children:"node build.js"}),"，就能在控制台发现如下日志信息:"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,d.jsx)(e.p,{children:"以上就是 Esbuild 打包的元信息，这对我们编写插件扩展 Esbuild 能力非常有用。"}),"\n",(0,d.jsx)(e.p,{children:"接着，我们再观察一下 dist 目录，发现打包产物和相应的 SourceMap 文件也已经成功写入磁盘:"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:"data:image/webp;base64,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",alt:"image.png"})}),"\n",(0,d.jsxs)(e.p,{children:["其实",(0,d.jsx)(e.code,{children:"buildSync"}),"方法的使用几乎相同，如下代码所示:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:"function runBuild() {\n  // 同步方法\n  const result = buildSync({\n    // 省略一系列的配置\n  });\n  console.log(result);\n}\n\nrunBuild();\n"})}),"\n",(0,d.jsxs)(e.p,{children:["但我并不推荐大家使用 ",(0,d.jsx)(e.code,{children:"buildSync"})," 这种同步的 API，它们会导致两方面不良后果。一方面容易使 Esbuild 在当前线程阻塞，丧失",(0,d.jsx)(e.code,{children:"并发任务处理"}),"的优势。另一方面，Esbuild 所有插件中都不能使用任何异步操作，这给",(0,d.jsx)(e.code,{children:"插件开发"}),"增加了限制。"]}),"\n",(0,d.jsxs)(e.p,{children:["因此我更推荐大家使用",(0,d.jsx)(e.code,{children:"build"}),"这个异步 API，它可以很好地避免上述问题。"]}),"\n",(0,d.jsxs)(e.p,{children:["在项目打包方面，除了",(0,d.jsx)(e.code,{children:"build"}),"和",(0,d.jsx)(e.code,{children:"buildSync"}),"，Esbuild 还提供了另外一个比较强大的 API——",(0,d.jsx)(e.code,{children:"serve"}),"。这个 API 有 3 个特点。"]}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsxs)(e.li,{children:["开启 serve 模式后，将在指定的端口和目录上搭建一个",(0,d.jsx)(e.code,{children:"静态文件服务"}),"，这个服务器用原生 Go 语言实现，性能比 Nodejs 更高。"]}),"\n",(0,d.jsx)(e.li,{children:"类似 webpack-dev-server，所有的产物文件都默认不会写到磁盘，而是放在内存中，通过请求服务来访问。"}),"\n",(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.strong,{children:"每次请求"}),"到来时，都会进行重新构建(",(0,d.jsx)(e.code,{children:"rebuild"}),")，永远返回新的产物。"]}),"\n"]}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"值得注意的是，触发 rebuild 的条件并不是代码改动，而是新的请求到来。"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"下面，我们通过一个具体例子来感受一下。"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:'// build.js\nconst { build, buildSync, serve } = require("esbuild");\n\nfunction runBuild() {\n  serve(\n    {\n      port: 8000,\n      // 静态资源目录\n      servedir: \'./dist\'\n    },\n    {\n      absWorkingDir: process.cwd(),\n      entryPoints: ["./src/index.jsx"],\n      bundle: true,\n      format: "esm",\n      splitting: true,\n      sourcemap: true,\n      ignoreAnnotations: true,\n      metafile: true,\n    }\n  ).then((server) => {\n    console.log("HTTP Server starts at port", server.port);\n  });\n}\n\nrunBuild();\n'})}),"\n",(0,d.jsxs)(e.p,{children:["我们在浏览器访问",(0,d.jsx)(e.code,{children:"localhost:8000"}),"可以看到 Esbuild 服务器返回的编译产物如下所示："]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:u,alt:"image.png"})}),"\n",(0,d.jsx)(e.p,{children:"后续每次在浏览器请求都会触发 Esbuild 重新构建，而每次重新构建都是一个增量构建的过程，耗时也会比首次构建少很多(一般能减少 70% 左右)。"}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"Serve API 只适合在开发阶段使用，不适用于生产环境。"}),"\n"]}),"\n",(0,d.jsxs)(e.h4,{id:"单文件转译transform-api",children:["单文件转译——Transform API",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#单文件转译transform-api",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["除了项目的打包功能之后，Esbuild 还专门提供了单文件编译的能力，即",(0,d.jsx)(e.code,{children:"Transform API"}),"，与 ",(0,d.jsx)(e.code,{children:"Build API"})," 类似，它也包含了同步和异步的两个方法，分别是",(0,d.jsx)(e.code,{children:"transformSync"}),"和",(0,d.jsx)(e.code,{children:"transform"}),"。下面，我们具体使用下这些方法。"]}),"\n",(0,d.jsxs)(e.p,{children:["首先，在项目根目录新建",(0,d.jsx)(e.code,{children:"transform.js"}),"，内容如下:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:'// transform.js\nconst { transform, transformSync } = require("esbuild");\n\nasync function runTransform() {\n  // 第一个参数是代码字符串，第二个参数为编译配置\n  const content = await transform(\n    "const isNull = (str: string): boolean => str.length > 0;",\n    {\n      sourcemap: true,\n      loader: "tsx",\n    }\n  );\n  console.log(content);\n}\n\nrunTransform();\n'})}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.code,{children:"transformSync"})," 的用法类似，换成同步的调用方式即可。"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:"function runTransform {\n  const content = await transformSync(/* 参数和 transform 相同 */)\n  console.log(content);\n}\n"})}),"\n",(0,d.jsxs)(e.p,{children:["不过由于同步的 API 会使 Esbuild 丧失",(0,d.jsx)(e.code,{children:"并发任务处理"}),"的优势（",(0,d.jsx)(e.code,{children:"Build API"}),"的部分已经分析过），我同样也不推荐大家使用",(0,d.jsx)(e.code,{children:"transformSync"}),"。出于性能考虑，Vite 的底层实现也是采用 ",(0,d.jsx)(e.code,{children:"transform"}),"这个异步的 API 进行 TS 及 JSX 的单文件转译的。"]}),"\n",(0,d.jsxs)(e.h2,{id:"esbuild-插件开发",children:["Esbuild 插件开发",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#esbuild-插件开发",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"我们在使用 Esbuild 的时候难免会遇到一些需要加上自定义插件的场景，并且 Vite 依赖预编译的实现中大量应用了 Esbuild 插件的逻辑。因此，插件开发是 Esbuild 中非常重要的内容，"}),"\n",(0,d.jsx)(e.p,{children:"接下来，我们就一起来完成 Esbuild 的插件开发，带你掌握若干个关键的钩子使用。"}),"\n",(0,d.jsxs)(e.h3,{id:"基本概念",children:["基本概念",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#基本概念",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["插件开发其实就是基于原有的体系结构中进行",(0,d.jsx)(e.code,{children:"扩展"}),"和",(0,d.jsx)(e.code,{children:"自定义"}),"。 Esbuild 插件也不例外，通过 Esbuild 插件我们可以扩展 Esbuild 原有的路径解析、模块加载等方面的能力，并在 Esbuild 的构建过程中执行一系列自定义的逻辑。"]}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.code,{children:"Esbuild"}),"\xa0插件结构被设计为一个对象，里面有",(0,d.jsx)(e.code,{children:"name"}),"和",(0,d.jsx)(e.code,{children:"setup"}),"两个属性，",(0,d.jsx)(e.code,{children:"name"}),"是插件的名称，",(0,d.jsx)(e.code,{children:"setup"}),"是一个函数，其中入参是一个 ",(0,d.jsx)(e.code,{children:"build"})," 对象，这个对象上挂载了一些钩子可供我们自定义一些钩子函数逻辑。以下是一个简单的",(0,d.jsx)(e.code,{children:"Esbuild"}),"插件示例:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"let envPlugin = {\n  name: 'env',\n  setup(build) {\n    build.onResolve({ filter: /^env$/ }, args => ({\n      path: args.path,\n      namespace: 'env-ns',\n    }))\n\n    build.onLoad({ filter: /.*/, namespace: 'env-ns' }, () => ({\n      contents: JSON.stringify(process.env),\n      loader: 'json',\n    }))\n  },\n}\n\nrequire('esbuild').build({\n  entryPoints: ['src/index.jsx'],\n  bundle: true,\n  outfile: 'out.js',\n  // 应用插件\n  plugins: [envPlugin],\n}).catch(() => process.exit(1))\n\n"})}),"\n",(0,d.jsx)(e.p,{children:"使用插件后效果如下:"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:"// 应用了 env 插件后，构建时将会被替换成 process.env 对象\nimport { PATH } from 'env'\n\nconsole.log(`PATH is ${PATH}`)\n"})}),"\n",(0,d.jsxs)(e.p,{children:["那么，",(0,d.jsx)(e.code,{children:"build"}),"对象上的各种钩子函数是如何使用的呢？"]}),"\n",(0,d.jsxs)(e.h3,{id:"钩子函数的使用",children:["钩子函数的使用",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#钩子函数的使用",children:"#"})]}),"\n",(0,d.jsxs)(e.h4,{id:"1-onresolve-钩子-和-onload钩子",children:["1. ",(0,d.jsx)(e.code,{children:"onResolve"})," 钩子 和 ",(0,d.jsx)(e.code,{children:"onLoad"}),"钩子",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-onresolve-钩子-和-onload钩子",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["在 Esbuild 插件中，",(0,d.jsx)(e.code,{children:"onResolve"})," 和 ",(0,d.jsx)(e.code,{children:"onload"}),"是两个非常重要的钩子，分别控制路径解析和模块内容加载的过程。"]}),"\n",(0,d.jsx)(e.p,{children:"首先，我们来说说上面插件示例中的两个钩子该如何使用。"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"// build 对象在上文的 setup 钩子已经引入，这里不再重复引入\n\nbuild.onResolve({ filter: /^env$/ }, args => ({\n  path: args.path,\n  namespace: 'env-ns',\n}));\nbuild.onLoad({ filter: /.*/, namespace: 'env-ns' }, () => ({\n  contents: JSON.stringify(process.env),\n  loader: 'json',\n}));\n"})}),"\n",(0,d.jsxs)(e.p,{children:["可以发现这两个钩子函数中都需要传入两个参数: ",(0,d.jsx)(e.code,{children:"Options"}),"  和 ",(0,d.jsx)(e.code,{children:"Callback"}),"。"]}),"\n",(0,d.jsxs)(e.p,{children:["先说说",(0,d.jsx)(e.code,{children:"Options"}),"。它是一个对象，对于",(0,d.jsx)(e.code,{children:"onResolve"})," 和 ",(0,d.jsx)(e.code,{children:"onload"})," 都一样，包含",(0,d.jsx)(e.code,{children:"filter"}),"和",(0,d.jsx)(e.code,{children:"namespace"}),"两个属性，类型定义如下:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:"interface Options {\n  filter: RegExp;\n  namespace?: string;\n}\n"})}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.code,{children:"filter"})," 为必传参数，是一个正则表达式，它决定了要过滤出的特征文件。"]}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsxs)(e.p,{children:["\uD83D\uDCE2 注意: 插件中的\xa0",(0,d.jsx)(e.code,{children:"filter"}),"\xa0正则是使用 Go 原生正则实现的，为了不使性能过于劣化，规则应该尽可能严格。同时它本身和 JS 的正则也有所区别，不支持前瞻(?<=)、后顾(?=)和反向引用(\\1)这三种规则。"]}),"\n"]}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.code,{children:"namespace"})," 为选填参数，一般在 ",(0,d.jsx)(e.code,{children:"onResolve"})," 钩子中的回调参数返回",(0,d.jsx)(e.code,{children:"namespace"}),"属性作为标识，我们可以在",(0,d.jsx)(e.code,{children:"onLoad"}),"钩子中通过 ",(0,d.jsx)(e.code,{children:"namespace"})," 将模块过滤出来。如上述插件示例就在",(0,d.jsx)(e.code,{children:"onLoad"}),"钩子通过",(0,d.jsx)(e.code,{children:"env-ns"}),"这个 namespace 标识过滤出了要处理的",(0,d.jsx)(e.code,{children:"env"}),"模块。"]}),"\n",(0,d.jsxs)(e.p,{children:["除了 Options 参数，还有一个回调参数 ",(0,d.jsx)(e.code,{children:"Callback"}),"，它的类型根据不同的钩子会有所不同。相比于 Options，Callback 函数入参和返回值的结构复杂得多，涉及很多属性。不过，我们也不需要看懂每个属性的细节，先了解一遍即可，常用的一些属性会在插件实战部分讲解来讲。"]}),"\n",(0,d.jsx)(e.p,{children:"在 onResolve 钩子中函数参数和返回值梳理如下:"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"build.onResolve({ filter: /^env$/ }, (args: onResolveArgs): onResolveResult => {\n  // 模块路径\n  console.log(args.path)\n  // 父模块路径\n  console.log(args.importer)\n  // namespace 标识\n  console.log(args.namespace)\n  // 基准路径\n  console.log(args.resolveDir)\n  // 导入方式，如 import、require\n  console.log(args.kind)\n  // 额外绑定的插件数据\n  console.log(args.pluginData)\n  \n  return {\n      // 错误信息\n      errors: [],\n      // 是否需要 external\n      external: false;\n      // namespace 标识\n      namespace: 'env-ns';\n      // 模块路径\n      path: args.path,\n      // 额外绑定的插件数据\n      pluginData: null,\n      // 插件名称\n      pluginName: 'xxx',\n      // 设置为 false，如果模块没有被用到，模块代码将会在产物中会删除。否则不会这么做\n      sideEffects: false,\n      // 添加一些路径后缀，如`?xxx`\n      suffix: '?xxx',\n      // 警告信息\n      warnings: [],\n      // 仅仅在 Esbuild 开启 watch 模式下生效\n      // 告诉 Esbuild 需要额外监听哪些文件/目录的变化\n      watchDirs: [],\n      watchFiles: []\n  }\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"在 onLoad 钩子中函数参数和返回值梳理如下:"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"build.onLoad({ filter: /.*/, namespace: 'env-ns' }, (args: OnLoadArgs): OnLoadResult => {\n  // 模块路径\n  console.log(args.path);\n  // namespace 标识\n  console.log(args.namespace);\n  // 后缀信息\n  console.log(args.suffix);\n  // 额外的插件数据\n  console.log(args.pluginData);\n  \n  return {\n      // 模块具体内容\n      contents: '省略内容',\n      // 错误信息\n      errors: [],\n      // 指定 loader，如`js`、`ts`、`jsx`、`tsx`、`json`等等\n      loader: 'json',\n      // 额外的插件数据\n      pluginData: null,\n      // 插件名称\n      pluginName: 'xxx',\n      // 基准路径\n      resolveDir: './dir',\n      // 警告信息\n      warnings: [],\n      // 同上\n      watchDirs: [],\n      watchFiles: []\n  }\n});\n"})}),"\n",(0,d.jsxs)(e.h4,{id:"2-其他钩子",children:["2. 其他钩子",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-其他钩子",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["在 build 对象中，除了",(0,d.jsx)(e.code,{children:"onResolve"}),"和",(0,d.jsx)(e.code,{children:"onLoad"}),"，还有",(0,d.jsx)(e.code,{children:"onStart"}),"和",(0,d.jsx)(e.code,{children:"onEnd"}),"两个钩子用来在构建开启和结束时执行一些自定义的逻辑，使用上比较简单，如下面的例子所示:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:"let examplePlugin = {\n  name: 'example',\n  setup(build) {\n    build.onStart(() => {\n      console.log('build started')\n    });\n    build.onEnd((buildResult) => {\n      if (buildResult.errors.length) {\n        return;\n      }\n      // 构建元信息\n      // 获取元信息后做一些自定义的事情，比如生成 HTML\n      console.log(buildResult.metafile)\n    })\n  },\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"在使用这些钩子的时候，有 2 点需要注意。"}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsxs)(e.li,{children:["onStart 的执行时机是在每次 build 的时候，包括触发 ",(0,d.jsx)(e.code,{children:"watch"})," 或者 ",(0,d.jsx)(e.code,{children:"serve"}),"模式下的重新构建。"]}),"\n",(0,d.jsxs)(e.li,{children:["onEnd 钩子中如果要拿到 ",(0,d.jsx)(e.code,{children:"metafile"}),"，必须将 Esbuild 的构建配置中",(0,d.jsx)(e.code,{children:"metafile"}),"属性设为 ",(0,d.jsx)(e.code,{children:"true"}),"。"]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"接下来我们进入插件实战，通过编写一些特定功能的插件来熟悉 Esbuild 插件的开发流程和技巧。"}),"\n",(0,d.jsxs)(e.h3,{id:"实战-1-cdn-依赖拉取插件",children:["实战 1: CDN 依赖拉取插件",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实战-1-cdn-依赖拉取插件",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"Esbuild 原生不支持通过 HTTP 从 CDN 服务上拉取对应的第三方依赖资源，如下代码所示:"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:'// src/index.jsx\n// react-dom 的内容全部从 CDN 拉取\n// 这段代码目前是无法运行的\nimport { render } from "https://cdn.skypack.dev/react-dom";\nimport React from \'https://cdn.skypack.dev/react\'\n\nlet Greet = () => <h1>Hello, juejin!</h1>;\n\nrender(<Greet />, document.getElementById("root"));\n'})}),"\n",(0,d.jsxs)(e.p,{children:["示例代码中我们用到了 ",(0,d.jsx)(e.code,{children:"Skypack"})," 这个提供 npm 第三方包 ESM 产物的 ",(0,d.jsx)(e.code,{children:"CDN 服务"}),"，我们可以通过 url 访问第三方包的资源，如下图所示:"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,d.jsxs)(e.p,{children:["现在我们需要通过 Esbuild 插件来识别这样的 url 路径，然后从网络获取模块内容并让 Esbuild 进行加载，甚至不再需要",(0,d.jsx)(e.code,{children:"npm install"}),"安装依赖了，这看上去是不是很酷呢？"]}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsxs)(e.p,{children:["顺便提一句，ESM CDN 作为面向未来的前端基础设施，对 Vite 的影响也至关重大，可以极大提升 Vite 在生产环境下的构建性能。这部分内容我们将在",(0,d.jsx)(e.strong,{children:"高级应用"}),"这一章展开介绍。"]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"我们先从最简单的版本开始写起:"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:'// http-import-plugin.js\nmodule.exports = () => ({\n  name: "esbuild:http",\n  setup(build) {\n    let https = require("https");\n    let http = require("http");\n\n    // 1. 拦截 CDN 请求\n    build.onResolve({ filter: /^https?:\\/\\// }, (args) => ({\n      path: args.path,\n      namespace: "http-url",\n    }));\n\n    // 2. 通过 fetch 请求加载 CDN 资源\n    build.onLoad({ filter: /.*/, namespace: "http-url" }, async (args) => {\n      let contents = await new Promise((resolve, reject) => {\n        function fetch(url) {\n          console.log(`Downloading: ${url}`);\n          let lib = url.startsWith("https") ? https : http;\n          let req = lib\n            .get(url, (res) => {\n              if ([301, 302, 307].includes(res.statusCode)) {\n                // 重定向\n                fetch(new URL(res.headers.location, url).toString());\n                req.abort();\n              } else if (res.statusCode === 200) {\n                // 响应成功\n                let chunks = [];\n                res.on("data", (chunk) => chunks.push(chunk));\n                res.on("end", () => resolve(Buffer.concat(chunks)));\n              } else {\n                reject(\n                  new Error(`GET ${url} failed: status ${res.statusCode}`)\n                );\n              }\n            })\n            .on("error", reject);\n        }\n        fetch(args.path);\n      });\n      return { contents };\n    });\n  },\n});\n'})}),"\n",(0,d.jsxs)(e.p,{children:["然后我们新建",(0,d.jsx)(e.code,{children:"build.js"}),"文件，内容如下:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:'const { build } = require("esbuild");\nconst httpImport = require("./http-import-plugin");\nasync function runBuild() {\n  build({\n    absWorkingDir: process.cwd(),\n    entryPoints: ["./src/index.jsx"],\n    outdir: "dist",\n    bundle: true,\n    format: "esm",\n    splitting: true,\n    sourcemap: true,\n    metafile: true,\n    plugins: [httpImport()],\n  }).then(() => {\n    console.log("\uD83D\uDE80 Build Finished!");\n  });\n}\n\nrunBuild();\n'})}),"\n",(0,d.jsxs)(e.p,{children:["通过",(0,d.jsx)(e.code,{children:"node build.js"}),"执行打包脚本，发现插件不能 work，抛出了这样一个错误:"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,d.jsx)(e.p,{children:"这是为什么呢？你可以回过头观察一下第三方包的响应内容:"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"export * from '/-/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/dist=es2019,mode=imports/optimized/react-dom.js';\nexport {default} from '/-/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/dist=es2019,mode=imports/optimized/react-dom.js';\n"})}),"\n",(0,d.jsx)(e.p,{children:"进一步查看还有更多的模块内容:"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,d.jsx)(e.p,{children:"因此我们可以得出一个结论：除了要解析 react-dom 这种直接依赖的路径，还要解析它依赖的路径，也就是间接依赖的路径。"}),"\n",(0,d.jsxs)(e.p,{children:["那如何来实现这个效果呢？我们不妨加入这样一段",(0,d.jsx)(e.code,{children:"onResolve"}),"钩子逻辑:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:'// 拦截间接依赖的路径，并重写路径\n// tip: 间接依赖同样会被自动带上 `http-url`的 namespace\nbuild.onResolve({ filter: /.*/, namespace: "http-url" }, (args) => ({\n  // 重写路径\n  path: new URL(args.path, args.importer).toString(),\n  namespace: "http-url",\n}));\n'})}),"\n",(0,d.jsx)(e.p,{children:"加了这段逻辑后，Esbuild 路径解析的流程如下:"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,d.jsxs)(e.p,{children:["现在我们再次执行",(0,d.jsx)(e.code,{children:"node build.js"}),"，发现依赖已经成功下载并打包了。"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,d.jsxs)(e.h3,{id:"实战-2-实现-html-构建插件",children:["实战 2: 实现 HTML 构建插件",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实战-2-实现-html-构建插件",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"Esbuild 作为一个前端打包工具，本身并不具备 HTML 的构建能力。也就是说，当它把 js/css 产物打包出来的时候，并不意味着前端的项目可以直接运行了，我们还需要一份对应的入口 HTML 文件。而这份 HTML 文件当然可以手写一个，但手写显得比较麻烦，尤其是产物名称带哈希值的时候，每次打包完都要替换路径。那么，我们能不能通过 Esbuild 插件的方式来自动化地生成 HTML 呢？"}),"\n",(0,d.jsxs)(e.p,{children:["刚才我们说了，在 Esbuild 插件的 ",(0,d.jsx)(e.code,{children:"onEnd"})," 钩子中可以拿到 ",(0,d.jsx)(e.code,{children:"metafile"})," 对象的信息。那么，这个对象究竟什么样呢？"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-json",children:"{\n  \"inputs\": { /* 省略内容 */ },\n  \"output\": {\n    \"dist/index.js\": {\n      imports: [],\n      exports: [],\n      entryPoint: 'src/index.jsx',\n      inputs: {\n        'http-url:https://cdn.skypack.dev/-/object-assign@v4.1.1-LbCnB3r2y2yFmhmiCfPn/dist=es2019,mode=imports/optimized/object-assign.js': { bytesInOutput: 1792 },\n        'http-url:https://cdn.skypack.dev/-/react@v17.0.1-yH0aYV1FOvoIPeKBbHxg/dist=es2019,mode=imports/optimized/react.js': { bytesInOutput: 10396 },\n        'http-url:https://cdn.skypack.dev/-/scheduler@v0.20.2-PAU9F1YosUNPKr7V4s0j/dist=es2019,mode=imports/optimized/scheduler.js': { bytesInOutput: 9084 },\n        'http-url:https://cdn.skypack.dev/-/react-dom@v17.0.1-oZ1BXZ5opQ1DbTh7nu9r/dist=es2019,mode=imports/optimized/react-dom.js': { bytesInOutput: 183229 },\n        'http-url:https://cdn.skypack.dev/react-dom': { bytesInOutput: 0 },\n        'src/index.jsx': { bytesInOutput: 178 }\n      },\n      bytes: 205284\n    },\n    \"dist/index.js.map\": { /* 省略内容 */ }\n  }\n}\n"})}),"\n",(0,d.jsxs)(e.p,{children:["从",(0,d.jsx)(e.code,{children:"outputs"}),"属性中我们可以看到产物的路径，这意味着我们可以在插件中拿到所有 js 和 css 产物，然后自己组装、生成一个 HTML，实现自动化生成 HTML 的效果。"]}),"\n",(0,d.jsxs)(e.p,{children:["我们接着来实现一下这个插件的逻辑，首先新建",(0,d.jsx)(e.code,{children:"html-plugin.js"}),"，内容如下:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:'const fs = require("fs/promises");\nconst path = require("path");\nconst { createScript, createLink, generateHTML } = require(\'./util\');\n\nmodule.exports = () => {\n  return {\n    name: "esbuild:html",\n    setup(build) {\n      build.onEnd(async (buildResult) => {\n        if (buildResult.errors.length) {\n          return;\n        }\n        const { metafile } = buildResult;\n        // 1. 拿到 metafile 后获取所有的 js 和 css 产物路径\n        const scripts = [];\n        const links = [];\n        if (metafile) {\n          const { outputs } = metafile;\n          const assets = Object.keys(outputs);\n\n          assets.forEach((asset) => {\n            if (asset.endsWith(".js")) {\n              scripts.push(createScript(asset));\n            } else if (asset.endsWith(".css")) {\n              links.push(createLink(asset));\n            }\n          });\n        }\n        // 2. 拼接 HTML 内容\n        const templateContent = generateHTML(scripts, links);\n        // 3. HTML 写入磁盘\n        const templatePath = path.join(process.cwd(), "index.html");\n        await fs.writeFile(templatePath, templateContent);\n      });\n    },\n  };\n}\n  \n// util.js\n// 一些工具函数的实现\nconst createScript = (src) => `<script type="module" src="${src}"><\/script>`;\nconst createLink = (src) => `<link rel="stylesheet" href="${src}"></link>`;\nconst generateHTML = (scripts, links) => `\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n  <meta charset="UTF-8" />\n  <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n  <title>Esbuild App</title>\n  ${links.join("\\n")}\n</head>\n\n<body>\n  <div id="root"></div>\n  ${scripts.join("\\n")}\n</body>\n\n</html>\n`;\n\nmodule.exports = { createLink, createScript, generateHTML };\n'})}),"\n",(0,d.jsxs)(e.p,{children:["现在我们在 ",(0,d.jsx)(e.code,{children:"build.js"})," 中引入 html 插件:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:'const html = require("./html-plugin");\n\n// esbuild 配置\nplugins: [\n  // 省略其它插件\n  html()\n],\n'})}),"\n",(0,d.jsxs)(e.p,{children:["然后执行",(0,d.jsx)(e.code,{children:"node build.js"}),"对项目进行打包，你就可以看到 ",(0,d.jsx)(e.code,{children:"index.html"})," 已经成功输出到根目录。接着，我们通过 ",(0,d.jsx)(e.code,{children:"serve"})," 起一个本地静态文件服务器:"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-ts",children:"// 1. 全局安装 serve\nnpm i -g serve\n// 2. 在项目根目录执行\nserve .\n"})}),"\n",(0,d.jsx)(e.p,{children:"可以看到如下的界面:"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,d.jsxs)(e.p,{children:["再访问",(0,d.jsx)(e.code,{children:"localhost:3000"}),"，会默认访问到 index.html 的内容："]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,d.jsxs)(e.p,{children:["这样一来，应用的内容就成功显示了，也说明 HTML 插件正常生效了。当然，如果要做一个足够通用的 HTML 插件，还需要考虑诸多的因素，比如",(0,d.jsx)(e.code,{children:"自定义 HTML 内容"}),"、",(0,d.jsx)(e.code,{children:"自定义公共前缀(publicPath)"}),"、",(0,d.jsx)(e.code,{children:"自定义 script 标签类型"}),"以及 ",(0,d.jsx)(e.code,{children:"多入口打包"}),"等等，大家感兴趣的话可以自行扩展。(可参考",(0,d.jsx)(e.a,{href:"https://github.com/sanyuan0704/ewas/blob/main/packages/esbuild-plugin-html/src/index.ts",target:"_blank",rel:"noopener noreferrer",children:"这个开源插件"}),")"]}),"\n",(0,d.jsxs)(e.h2,{id:"小结",children:["小结",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"恭喜你，学习完了本节的内容！这一节，我们要重点掌握 Esbuild 的基础使用和插件开发。"}),"\n",(0,d.jsxs)(e.p,{children:["首先你可以通过",(0,d.jsx)(e.code,{children:"命令行方式"}),"和",(0,d.jsx)(e.code,{children:"代码调用方式"}),"两种方式来使用 Esbuild。对后者而言，我们需要使用到 Esbuild 中两个重要的 API，分别是",(0,d.jsx)(e.code,{children:"Build API"}),"和",(0,d.jsx)(e.code,{children:"Transform API"}),"，为了避免同步方法所导致的性能问题，我推荐你使用异步方式进行调用。"]}),"\n",(0,d.jsxs)(e.p,{children:["其次，我用一个简单的",(0,d.jsx)(e.code,{children:"env"}),"插件示例带你学习了 Esbuild 插件的代码结构和基本概念，并进行了插件开发实战，开发了两个复杂度比较高的插件，分别是\xa0",(0,d.jsx)(e.code,{children:"CDN 依赖拉取插件"}),"和",(0,d.jsx)(e.code,{children:"HTML 构建插件"}),"。希望你能通过这些经典的例子好好体会插件的编写方式，并多多实践，提升自己对 Esbuild 的理解。"]}),"\n",(0,d.jsx)(e.p,{children:"本文的内容到此就结束了，感谢你的阅读，我们下一节再见！"})]})}function m(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(j,{...n})}):j(n)}let b=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Vite%2F9.%E5%BE%97%E5%8A%9B%E7%9A%84%E6%80%A7%E8%83%BD%E6%8E%A8%E6%89%8B_%20Esbuild%20%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98.md"]={toc:[{text:"为什么 Esbuild 性能极高？",id:"为什么-esbuild-性能极高",depth:2},{text:"Esbuild 功能使用",id:"esbuild-功能使用",depth:2},{text:"1. 命令行调用",id:"1-命令行调用",depth:3},{text:"2. 代码调用",id:"2-代码调用",depth:3},{text:"项目打包——Build API",id:"项目打包build-api",depth:4},{text:"单文件转译——Transform API",id:"单文件转译transform-api",depth:4},{text:"Esbuild 插件开发",id:"esbuild-插件开发",depth:2},{text:"基本概念",id:"基本概念",depth:3},{text:"钩子函数的使用",id:"钩子函数的使用",depth:3},{text:"1. `onResolve` 钩子 和 `onLoad`钩子",id:"1-onresolve-钩子-和-onload钩子",depth:4},{text:"2. 其他钩子",id:"2-其他钩子",depth:4},{text:"实战 1: CDN 依赖拉取插件",id:"实战-1-cdn-依赖拉取插件",depth:3},{text:"实战 2: 实现 HTML 构建插件",id:"实战-2-实现-html-构建插件",depth:3},{text:"小结",id:"小结",depth:2}],title:"9.得力的性能推手_ Esbuild 功能使用与插件开发实战",headingTitle:"9.得力的性能推手_ Esbuild 功能使用与插件开发实战",frontmatter:{}}}}]);