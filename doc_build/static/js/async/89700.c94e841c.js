"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["89700"],{622234:function(e,n,t){e.exports=t.p+"static/image/01a80b0082bdf1ef01026cd928e8e453.4e954017.webp"},817412:function(e,n,t){e.exports=t.p+"static/image/1a6c80f37f7b8419e1c4e4f51c67e8ac.76b4f659.webp"},142094:function(e,n,t){e.exports=t.p+"static/image/51143ec805b46a4740730e2fa5d96cf3.03575bca.webp"},442612:function(e,n,t){e.exports=t.p+"static/image/5c065fa00f30790f802b33d2a3b91512.1a18a711.webp"},407168:function(e,n,t){e.exports=t.p+"static/image/7bb84ea9128a5184d50e019a2cb1df62.8903c3e7.webp"},178847:function(e,n,t){t.r(n),t.d(n,{default:()=>u});var s=t(552676),r=t(740453),c=t(407168),a=t(142094),i=t(442612),o=t(817412),l=t(622234);function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",img:"img",h3:"h3",h4:"h4"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"30实践篇-自定义-hooks-实践",children:["30.实践篇-自定义 Hooks 实践",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#30实践篇-自定义-hooks-实践",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上章节讲到了自定义 hooks 的特性和设计原则，本章节将记录自定义 hooks 一些具体的应用场景。"}),"\n",(0,s.jsxs)(n.h2,{id:"二-实践一自动上报pvclick的埋点hooks-uselog",children:["二 实践一：自动上报pv/click的埋点hooks—— useLog",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-实践一自动上报pvclick的埋点hooks-uselog",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来实现一个能够自动上报 点击事件 | pv 的自定义 hooks 。通过这个自定义 hooks ，将带来的收获是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"通过自定义 hooks 控制监听 DOM 元素。"}),"\n",(0,s.jsx)(n.li,{children:"分清自定义 hooks 依赖关系。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"编写"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export const LogContext = React.createContext({})\n\nexport default function useLog(){\n    /* 一些公共参数 */\n    const message = React.useContext(LogContext)\n    const listenDOM = React.useRef(null)\n\n    /* 分清依赖关系 -> message 改变，   */\n    const reportMessage = React.useCallback(function(data,type){\n        if(type==='pv'){ // pv 上报\n            console.log('组件 pv 上报',message)\n        }else if(type === 'click'){  // 点击上报\n            console.log('组件 click 上报',message,data)\n        }\n    },[ message ])\n\n    React.useEffect(()=>{\n        const handleClick = function (e){\n            reportMessage(e.target,'click')\n        }\n        if(listenDOM.current){\n            listenDOM.current.addEventListener('click',handleClick)\n        }\n\n        return function (){\n            listenDOM.current && listenDOM.current.removeEventListener('click',handleClick)\n        }\n    },[ reportMessage  ])\n\n    return [ listenDOM , reportMessage  ]\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["用 ",(0,s.jsx)(n.code,{children:"useContext"})," 获取埋点的公共信息。当公共信息改变，会统一更新。"]}),"\n",(0,s.jsxs)(n.li,{children:["用 ",(0,s.jsx)(n.code,{children:"useRef"})," 获取 DOM 元素。"]}),"\n",(0,s.jsxs)(n.li,{children:["用 ",(0,s.jsx)(n.code,{children:"useCallback"})," 缓存上报信息 reportMessage 方法，里面获取 useContext 内容。把 context 作为依赖项。当依赖项改变，重新声明 reportMessage 函数。"]}),"\n",(0,s.jsxs)(n.li,{children:["用 ",(0,s.jsx)(n.code,{children:"useEffect"}),"监听 DOM 事件，把 reportMessage 作为依赖项，在 useEffect 中进行事件绑定，返回的销毁函数用于解除绑定。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"依赖关系："}),"  context 改变 -> 让引入 context 的 reportMessage 重新声明 -> 让绑定 DOM 事件监听的 useEffect 里面能够绑定最新的 reportMessage 。"]}),"\n",(0,s.jsx)(n.p,{children:"如果上述没有分清楚依赖项关系，那么 context 改变，会让 reportMessage 打印不到最新的 context 值。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"使用"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:" function Home(){\n    const [ dom , reportMessage  ] = useLog()\n    return <div>\n        {/* 监听内部点击 */}\n        <div ref={dom} >\n            <p> 《React进阶实践指南》</p>\n            <button> 按钮 one   (内部点击) </button>\n            <button> 按钮 two   (内部点击) </button>\n            <button> 按钮 three (内部点击)  </button>\n        </div>\n        {/* 外部点击 */}\n        <button  onClick={()=>{ console.log(reportMessage)  }} > 外部点击 </button>\n    </div>\n}\nconst Index = React.memo(Home) /*  阻断 useState 的更新效应  */\nexport default function Root(){\n    const [ value , setValue ] = useState({})\n    return  <LogContext.Provider value={value} >\n        <Index />\n        <button onClick={()=> setValue({ name:'《React进阶实践指南》' , author:'我不是外星人'  })} >点击</button>\n    </LogContext.Provider>\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上当 context 改变，能够达到正常上报的效果。有一个小细节，就是用 ",(0,s.jsx)(n.code,{children:"React.memo"})," 来阻断 Root 组件改变 state 给 Home 组件带来的更新效应。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"4.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"三-实践二带查询的分页加载长列表-usequerytable",children:["三 实践二：带查询的分页加载长列表—— useQueryTable",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-实践二带查询的分页加载长列表-usequerytable",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["saas 管理系统中，大概率会存在带查询的表格场景，那么可不可以把整个表单和表格的数据逻辑层交给一个自定义 hooks 来搞定，这样的好处是接下来所有类似该功能的页面，只需要",(0,s.jsx)(n.strong,{children:"一个自定义 hooks + 公共组件 + 配置项"}),"就能搞定了。"]}),"\n",(0,s.jsxs)(n.p,{children:["接下来实现一个带查询分页的功能，把",(0,s.jsx)(n.strong,{children:"所有的逻辑"}),"都交给一个自定义 hooks 去处理，组件只负责接收自定义 hooks 的状态。"]}),"\n",(0,s.jsxs)(n.h3,{id:"设计原则",children:["设计原则",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计原则",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"useQueryTable 的设计主要分为两部分，分别为表格和查询表单。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"表格设计：表格的数据状态层，改变分页方法，请求数据的方法。"}),"\n",(0,s.jsx)(n.li,{children:"表单设计：表单的状态层，以及改变表单单元项的方法，重置表单重新请求数据。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"设计模型图",children:["设计模型图",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计模型图",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"自定义 hooks —— useQueryTable 的设计模型图如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"5.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"代码实现",children:["代码实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"编写："})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n *\n * @param {*} defaultQuery  表单查询默认参数\n * @param {*} api           biaog\n */\nfunction useQueryTable(defaultQuery = {},api){\n   /* 保存查询表格表单信息 */\n   const formData = React.useRef({})\n   /* 保存查询表格分页信息 */\n   const pagination = React.useRef({\n       page:defaultQuery.page || 1,\n       pageSize:defaultQuery.pageSize || 10\n   })\n\n   /* 强制更新 */\n   const [, forceUpdate] = React.useState(null)\n\n   /* 请求表格数据 */\n   const [tableData, setTableData] = React.useState({\n     data: [],\n     total: 0,\n     current: 1\n  })\n\n   /* 请求列表数据 */\n   const getList = React.useCallback(async function(payload={}){\n        if(!api) return\n        const data = await api({ ...defaultQuery, ...payload, ...pagination.current,...formData.current}) || {}\n        if (data.code == 200) {\n            setTableData({ list:data.list,current:data.current,total:data.total })\n        } else {}\n   },[ api ]) /* 以api作为依赖项，当api改变，重新声明getList */\n\n    /* 改变表单单元项 */\n    const setFormItem = React.useCallback(function (key,value){\n        const form = formData.current\n        form[key] = value\n        forceUpdate({}) /* forceUpdate 每一次都能更新，不会造成 state 相等的情况 */\n   },[])\n\n   /* 重置表单 */\n   const reset = React.useCallback(function(){\n        const current = formData.current\n        for (let name in current) {\n            current[name] = ''\n        }\n        pagination.current.page = defaultQuery.page || 1\n        pagination.current.pageSize = defaultQuery.pageSize || 10\n        /* 请求数据  */\n        getList()\n   },[ getList ]) /* getList 作为 reset 的依赖项  */\n\n   /* 处理分页逻辑 */\n   const handerChange = React.useCallback(async function(page,pageSize){\n        pagination.current = {\n            page,\n            pageSize\n        }\n        getList()\n   },[ getList ]) /* getList 作为 handerChange 的依赖项  */\n\n   /* 初始化请求数据 */\n   React.useEffect(()=>{\n       getList()\n   },[])\n\n   /* 组合暴露参数 */\n   return [\n        {  /* 组合表格状态 */\n           tableData,\n           handerChange,\n           getList,\n           pagination:pagination.current\n        },\n        {  /* 组合搜索表单状态 */\n            formData:formData.current,\n            setFormItem,\n            reset\n        }\n    ]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"设计分析："})}),"\n",(0,s.jsx)(n.p,{children:"接收参数 ：编写的自定义 hooks 接收两个参数。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"defaultQuery"}),"：表格的默认参数，有些业务表格，除了查询和分页之外，有一些独立的请求参数。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"api"})," ： api 为请求数据方法，内部用 ",(0,s.jsx)(n.code,{children:"Promise"})," 封装处理。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"数据层："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"用第一个 useRef 保存查询表单信息 formData 。 第二个 useRef 保存表格的分页信息 pagination 。"}),"\n",(0,s.jsxs)(n.li,{children:["用第一个 useState 做",(0,s.jsx)(n.strong,{children:"受控表单组件更新视图"}),"的渲染函数。第二个 useState 保存并负责更新表格的状态。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["控制层：控制层为",(0,s.jsx)(n.strong,{children:"控制表单表格整体联动"}),"的方法。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["编写内部和对外公共方法 ",(0,s.jsx)(n.code,{children:"getList"}),"，方法内部使用 api 函数发起请求，通过 ",(0,s.jsx)(n.code,{children:"setTableData"})," 改变表格数据层状态，用 ",(0,s.jsx)(n.code,{children:"useCallback"})," 做优化缓存处理 。"]}),"\n",(0,s.jsxs)(n.li,{children:["编写改变表单单元项的方法 ",(0,s.jsx)(n.code,{children:"setFormItem"}),"，这个方法主要给查询表单控件使用，内部改变 formData 属性，并通过 useState 更新组件，改变表单控件视图，用 ",(0,s.jsx)(n.code,{children:"useCallback"})," 做优化缓存处理。"]}),"\n",(0,s.jsxs)(n.li,{children:["编写重置表单的方法 ",(0,s.jsx)(n.code,{children:"reset"})," ，reset 会清空 formData 属性和重置分页的信息。然后重新调用 getList 请求数据，用 ",(0,s.jsx)(n.code,{children:"useCallback"})," 做优化缓存处理。"]}),"\n",(0,s.jsxs)(n.li,{children:["编写给表格分页器提供的接口 ",(0,s.jsx)(n.code,{children:"handerChange"})," 内部改变分页信息，然后重新请求数据，用 ",(0,s.jsx)(n.code,{children:"useCallback"})," 做优化缓存处理。。"]}),"\n",(0,s.jsx)(n.li,{children:"用 useEffect 作为初始化请求表格数据的副作用。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"返回状态："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"通过数组把表单和表格的聚合状态暴露出去。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"注意事项："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"请求方法要与后端进行对齐，包括返回的参数结构，成功状态码等。"}),"\n",(0,s.jsx)(n.li,{children:"属性的声明要与 UI 组件对齐，这里统一用的是 antd 里面的表格和表单控件。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"使用："})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'/* 模拟数据请求 */\nfunction getTableData(payload){\n    return new Promise((resolve)=>{\n        Promise.resolve().then(()=>{\n            const { list } = listData\n            const arr = threeNumberRandom()  // 生成三个随机数 模拟数据交互\n            console.log(\'请求参数：\',payload)\n            resolve({\n                ...listData,\n                list:[ list[arr[0]],list[arr[1]],list[arr[2]] ],\n                total:list.length,\n                current:payload.page || 1\n            })\n        })\n    })\n}\nfunction Index (){\n    const [ table,form ] = useQueryTable({ pageSize:3 },getTableData)\n    const { formData ,setFormItem , reset  } = form\n    const { pagination , tableData , getList  , handerChange } = table\n    return <div style={{ margin:\'30px\' }} >\n        <div style={{ marginBottom:\'24px\' }} >\n            <Input onChange={(e)=> setFormItem(\'name\',e.target.value)}\n                placeholder="请输入名称"\n                style={inputStyle}\n                value={formData.name || \'\'}\n            />\n             <Input onChange={(e)=> setFormItem(\'price\',e.target.value)}\n                 placeholder="请输入价格"\n                 style={inputStyle}\n                 value={formData.price || \'\'}\n             />\n             <Select onChange={(value) => setFormItem(\'type\',value)}\n                 placeholder="请选择"\n                 style={inputStyle}\n                 value={formData.type}\n             >\n                 <Option value="1" >家电</Option>\n                 <Option value="2" >生活用品</Option>\n             </Select>\n            <button className="searchbtn"\n                onClick={() => getList()}\n            >提交</button>\n             <button className="concellbtn"\n                 onClick={reset}\n             >重置</button>\n        </div>\n        {useCallback( <Table\n            columns={columns}\n            dataSource={tableData.list}\n            height="300px"\n            onChange={(res)=>{ handerChange(res.current,res.pageSize) }}\n            pagination={{ ...pagination, total: tableData.total ,current:tableData.current }}\n            rowKey="id"\n                      />,[tableData])}\n    </div>\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"6.gif"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["整个查询表格逻辑层基本就一个自定义 hooks —— ",(0,s.jsx)(n.code,{children:"useQueryTable"})," 就搞定了。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"getTableData"})," 模拟了数据交互过程 ，其内部的代码逻辑不必纠结 。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useCallback"})," 对 Table 的 React element 做缓存处理，这样频繁的表单控件更新，不会让 Table 组件重新渲染。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"四-实践三实现react-redux功能-usecreatestore--useconnect",children:["四 实践三：实现React-Redux功能—— useCreateStore | useConnect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-实践三实现react-redux功能-usecreatestore--useconnect",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["下面我将用",(0,s.jsxs)(n.strong,{children:["两个自定义 hooks 实现 ",(0,s.jsx)(n.code,{children:"React-Redux"})," 基本功能"]}),"。 一个是注入 Store 的 ",(0,s.jsx)(n.code,{children:"useCreateStore"})," ，另外一个是负责订阅更新的 ",(0,s.jsx)(n.code,{children:"useConnect"})," ，通过这个实践 demo ，将收获以下知识点："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"如何将不同组件的自定义 hooks 建立通信，共享状态。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"合理编写自定义 hooks ， 分析 hooks 之间的依赖关系。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"首先，看一下要实现的两个自定义 hooks 具体功能。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useCreateStore"})," 用于产生一个状态 Store ，通过 context 上下文传递 ，为了让每一个自定义 hooks ",(0,s.jsx)(n.code,{children:"useConnect"})," 都能获取 context 里面的状态属性。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useConnect"})," 使用这个自定义 hooks 的组件，可以获取改变状态的 dispatch 方法，还可以订阅 state ，被订阅的 state 发生变化，组件更新。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-设计思路",children:["1 设计思路",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-设计思路",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"如何让不同组件的自定义 hooks 共享状态并实现通信呢？"})}),"\n",(0,s.jsxs)(n.p,{children:["首先不同组件的自定义 hooks ，可以通过 ",(0,s.jsx)(n.code,{children:"useContext"})," 获得共有状态，而且还需要实现状态管理和组件通信，那么就需要一个状态调度中心来统一做这些事，可以称之为 ",(0,s.jsx)(n.code,{children:"ReduxHooksStore"})," ，它具体做的事情如下："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"全局管理 state， state 变化，通知对应组件更新。"}),"\n",(0,s.jsxs)(n.li,{children:["收集使用 ",(0,s.jsx)(n.code,{children:"useConnect"})," 组件的信息。组件销毁还要清除这些信息。"]}),"\n",(0,s.jsxs)(n.li,{children:["维护并传递负责更新的 ",(0,s.jsx)(n.code,{children:"dispatch"})," 方法。"]}),"\n",(0,s.jsxs)(n.li,{children:["一些重要 api 要暴露给 context 上下文，传递给每一个 ",(0,s.jsx)(n.code,{children:"useConnect"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"usecreatestore-设计",children:["useCreateStore 设计",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecreatestore-设计",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先 ",(0,s.jsx)(n.code,{children:"useCreateStore"})," 是在靠近根部组件的位置的， 而且全局只需要一个，目的就是创建一个 ",(0,s.jsx)(n.code,{children:"Store"})," ，并通过 ",(0,s.jsx)(n.code,{children:"Provider"})," 传递下去。"]}),"\n",(0,s.jsx)(n.p,{children:"使用："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const store = useCreateStore( reducer , initState )\n"})}),"\n",(0,s.jsx)(n.p,{children:"参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reducer"})," ：全局 reducer，纯函数，传入 state 和 action ，返回新的 state 。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"initState"})," ： 初始化 state 。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"返回值：为 store 暴露的主要功能函数。"}),"\n",(0,s.jsxs)(n.h4,{id:"store设计",children:["Store设计",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#store设计",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Store 为上述所说的调度中心，接收全局 reducer ，内部维护状态 state ，负责通知更新 ，收集用 useConnect 的组件。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const Store = new ReduxHooksStore(reducer,initState).exportStore()\n"})}),"\n",(0,s.jsx)(n.p,{children:"参数：接收两个参数，透传 useCreateStore 的参数。"}),"\n",(0,s.jsxs)(n.h4,{id:"useconnect设计",children:["useConnect设计",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useconnect设计",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"使用 useConnect 的组件，将获得 dispatch 函数，用于更新 state ，还可以通过第一个参数订阅 state ，被订阅的 state 改变 ，会让组件更新。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 订阅 state 中的 number \nconst mapStoreToState = (state)=>({ number: state.number  })\nconst [ state , dispatch ] = useConnect(mapStoreToState)\n"})}),"\n",(0,s.jsx)(n.p,{children:"参数："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mapStoreToState"}),"：将 Store 中 state ，映射到组件的 state 中，可以做视图渲染使用。"]}),"\n",(0,s.jsxs)(n.li,{children:["如果没有第一个参数，那么只提供 ",(0,s.jsx)(n.code,{children:"dispatch"})," 函数，不会订阅 state 变化带来的更新。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"返回值：返回值是一个数组。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"数组第一项：为映射的 state 的值。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["数组第二项：为改变 state 的 ",(0,s.jsx)(n.code,{children:"dispatch"})," 函数。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"原理图",children:["原理图",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原理图",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"7.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-usecreatestore",children:["2 useCreateStore",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-usecreatestore",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export const ReduxContext = React.createContext(null)\n/* 用于产生 reduxHooks 的 store */\nexport function useCreateStore(reducer,initState){\n   const store = React.useRef(null)\n   /* 如果存在——不需要重新实例化 Store */\n   if(!store.current){\n       store.current  = new ReduxHooksStore(reducer,initState).exportStore()\n   }\n   return store.current\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useCreateStore"})," 主要做的是："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["接收 ",(0,s.jsx)(n.code,{children:"reducer"})," 和 ",(0,s.jsx)(n.code,{children:"initState"})," ，通过 ReduxHooksStore 产生一个 store ，不期望把 store 全部暴露给使用者，只需要暴露核心的方法，所以调用实例下的 ",(0,s.jsx)(n.code,{children:"exportStore"}),"抽离出核心方法。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["使用一个 ",(0,s.jsx)(n.code,{children:"useRef"})," 保存核心方法，传递给 ",(0,s.jsx)(n.code,{children:"Provider"})," 。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-状态管理者--reduxhooksstore",children:["3 状态管理者 —— ReduxHooksStore",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-状态管理者--reduxhooksstore",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来看一下核心状态 ReduxHooksStore 。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { unstable_batchedUpdates } from 'react-dom'\nclass ReduxHooksStore {\n    constructor(reducer,initState){\n       this.name = '__ReduxHooksStore__'\n       this.id = 0\n       this.reducer = reducer\n       this.state = initState\n       this.mapConnects = {}\n    }\n    /* 需要对外传递的接口 */\n    exportStore=()=>{\n        return {\n            dispatch:this.dispatch.bind(this),\n            subscribe:this.subscribe.bind(this),\n            unSubscribe:this.unSubscribe.bind(this),\n            getInitState:this.getInitState.bind(this)\n        }\n    }\n    /* 获取初始化 state */\n    getInitState=(mapStoreToState)=>{\n        return mapStoreToState(this.state)\n    }\n    /* 更新需要更新的组件 */\n    publicRender=()=>{\n        unstable_batchedUpdates(()=>{ /* 批量更新 */\n            Object.keys(this.mapConnects).forEach(name=>{\n                const { update } = this.mapConnects[name]\n                update(this.state)\n            })\n        })\n    }\n    /* 更新 state  */\n    dispatch=(action)=>{\n       this.state = this.reducer(this.state,action)\n       // 批量更新\n       this.publicRender()\n    }\n    /* 注册每个 connect  */\n    subscribe=(connectCurrent)=>{\n        const connectName = this.name + (++this.id)\n        this.mapConnects[connectName] =  connectCurrent\n        return connectName\n    }\n    /* 解除绑定 */\n    unSubscribe=(connectName)=>{\n        delete this.mapConnects[connectName]\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"状态",children:["状态",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#状态",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"reducer"}),"：这个 reducer 为全局的 reducer ，由 useCreateStore 传入。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"state"}),"：全局保存的状态 state ，每次执行 reducer 会得到新的 state 。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mapConnects"}),"：里面保存每一个 useConnect 组件的更新函数。用于派发 state 改变带来的更新。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"方法",children:["方法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"负责初始化："})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getInitState"}),"：这个方法给自定义 hooks 的 useConnect 使用，用于获取初始化的 state 。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exportStore"}),"：这个方法用于把 ReduxHooksStore 提供的核心方法传递给每一个 useConnect 。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"负责绑定｜解绑："})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"subscribe"}),"： 绑定每一个自定义 hooks useConnect 。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"unSubscribe"}),"：解除绑定每一个 hooks 。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"负责更新："})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"dispatch"}),"：这个方法提供给业务组件层，每一个使用 useConnect 的组件可以通过 dispatch 方法改变 state ，内部原理是通过调用 reducer 产生一个新的 state 。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"publicRender"}),"：当 state 改变需要通知每一个使用 useConnect 的组件，这个方法就是通知更新，至于组件需不需要更新，那是 useConnect  内部需要处理的事情，这里还有一个细节，就是考虑到 dispatch 的触发场景可以是异步状态下，所以用 React-DOM 中 unstable_batchedUpdates 开启批量更新原则。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-useconnect",children:["4 useConnect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-useconnect",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["useConnect 是整个功能的核心部分，它要做的事情是获取最新的 ",(0,s.jsx)(n.code,{children:"state"})," ，然后通过订阅函数 ",(0,s.jsx)(n.code,{children:"mapStoreToState"})," 得到订阅的 state ，判断订阅的 state 是否发生变化。如果发生变化渲染最新的 state 。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function useConnect(mapStoreToState=()=>{}){\n    /* 获取 Store 内部的重要函数 */\n   const contextValue = React.useContext(ReduxContext)\n   const { getInitState , subscribe ,unSubscribe , dispatch } = contextValue\n   /* 用于传递给业务组件的 state  */\n   const stateValue = React.useRef(getInitState(mapStoreToState))\n\n   /* 渲染函数 */\n   const [ , forceUpdate ] = React.useState()\n   /* 产生 */\n   const connectValue = React.useMemo(()=>{\n       const state =  {\n           /* 用于比较一次 dispatch 中，新的 state 和 之前的state 是否发生变化  */\n           cacheState: stateValue.current,\n           /* 更新函数 */\n           update:function (newState) {\n               /* 获取订阅的 state */\n               const selectState = mapStoreToState(newState)\n               /* 浅比较 state 是否发生变化，如果发生变化， */\n               const isEqual = shallowEqual(state.cacheState,selectState)\n               state.cacheState = selectState\n               stateValue.current  = selectState\n               if(!isEqual){\n                   /* 更新 */\n                   forceUpdate({})\n               }\n           }\n       }\n       return state\n   },[ contextValue ]) // 将 contextValue 作为依赖项。\n\n   React.useEffect(()=>{\n       /* 组件挂载——注册 connect */\n       const name =  subscribe(connectValue)\n       return function (){\n            /* 组件卸载 —— 解绑 connect */\n           unSubscribe(name)\n       }\n   },[ connectValue ]) /* 将 connectValue 作为 useEffect 的依赖项 */\n\n   return [ stateValue.current , dispatch ]\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"初始化"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"用 useContext 获取上下文中， ReduxHooksStore 提供的核心函数。"}),"\n",(0,s.jsx)(n.li,{children:"用 useRef 来保存得到的最新的 state 。"}),"\n",(0,s.jsxs)(n.li,{children:["用 useState 产生一个更新函数 ",(0,s.jsx)(n.code,{children:"forceUpdate"})," ，这个函数只是更新组件。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"注册｜解绑流程"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["注册： 通过 ",(0,s.jsx)(n.code,{children:"useEffect"})," 来向 ReduxHooksStore 中注册当前 useConnect 产生的 connectValue ，connectValue 是什么马上会讲到。subscribe 用于注册，会返回当前 connectValue 的唯一标识 name 。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"解绑：在 useEffect 的销毁函数中，可以用调用 unSubscribe 传入 name 来解绑当前的 connectValue"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"connectValue是否更新组件"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["connectValue ：真正地向 ReduxHooksStore 注册的状态，首先用 ",(0,s.jsx)(n.code,{children:"useMemo"})," 来对 connectValue 做缓存，connectValue 为一个对象，里面的 cacheState 保留了上一次的 mapStoreToState 产生的 state ，还有一个负责更新的 update 函数。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"更新流程"})," ： 当触发 ",(0,s.jsx)(n.code,{children:"dispatch"})," 在 ReduxHooksStore 中，会让每一个 connectValue 的 update 都执行， update 会触发映射函数 ",(0,s.jsx)(n.code,{children:"mapStoreToState"})," 来得到当前组件想要的 state 内容。然后通过 ",(0,s.jsx)(n.code,{children:"shallowEqual"})," 浅比较新老 state 是否发生变化，如果发生变化，那么更新组件。完成整个流程。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"shallowEqual ： 这个浅比较就是 React 里面的浅比较，在第 11 章已经讲了其流程，这里就不讲了。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"分清依赖关系"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["首先自定义 hooks useConnect 的依赖关系是上下文 contextValue 改变，那么说明 store 发生变化，所以重新通过 useMemo 产生新的 connectValue 。",(0,s.jsx)(n.strong,{children:"所以 useMemo 依赖 contextValue。"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["connectValue 改变，那么需要解除原来的绑定关系，重新绑定。",(0,s.jsx)(n.strong,{children:"useEffect 依赖 connectValue。"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"局限性"})}),"\n",(0,s.jsx)(n.p,{children:"整个 useConnect 有一些局限性，比如："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"没有考虑 mapStoreToState 可变性，无法动态传入 mapStoreToState 。"}),"\n",(0,s.jsx)(n.li,{children:"浅比较，不能深层次比较引用数据类型。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"5-使用与验证效果",children:["5 使用与验证效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-使用与验证效果",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来就是验证效果环节，我模拟了组件通信的场景。"}),"\n",(0,s.jsxs)(n.h4,{id:"根部组件注入-store",children:["根部组件注入 Store",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#根部组件注入-store",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { ReduxContext , useConnect , useCreateStore } from './hooks/useRedux'\nfunction  Index(){\n    const [ isShow , setShow ] =  React.useState(true)\n    console.log('index 渲染')\n    return <div>\n        <CompA />\n        <CompB />\n        <CompC />\n        {isShow &&  <CompD />}\n        <button onClick={() => setShow(!isShow)} >点击</button>\n    </div>\n}\n\nfunction Root(){\n    const store = useCreateStore(function(state,action){\n        const { type , payload } =action\n        if(type === 'setA' ){\n            return {\n                ...state,\n                mesA:payload\n            }\n        }else if(type === 'setB'){\n            return {\n                ...state,\n                mesB:payload\n            }\n        }else if(type === 'clear'){ //清空\n            return  { mesA:'',mesB:'' }\n        }\n        else{\n            return state\n        }\n    },\n    { mesA:'111',mesB:'111' })\n    return <div>\n        <ReduxContext.Provider value={store} >\n            <Index/>\n        </ReduxContext.Provider>\n    </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Root根组件"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["通过 useCreateStore 创建一个 store ，传入 reducer 和 初始化的值 ",(0,s.jsx)(n.code,{children:"{ mesA:'111',mesB:'111' }"})]}),"\n",(0,s.jsx)(n.li,{children:"用 Provider 传递 store。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Index组件"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"有四个子组件 CompA ， CompB ，CompC ，CompD 。其中 CompD 是 动态挂载的。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"业务组件使用",children:["业务组件使用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#业务组件使用",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function CompA(){\n    const [ value ,setValue ] = useState('')\n    const [state ,dispatch ] = useConnect((state)=> ({ mesB : state.mesB }) )\n    return <div className=\"component_box\" >\n        <p> 组件A</p>\n        <p>组件B对我说 ： {state.mesB} </p>\n        <input onChange={(e)=>setValue(e.target.value)}\n            placeholder=\"对B组件说\"\n        />\n        <button onClick={()=> dispatch({ type:'setA' ,payload:value })} >确定</button>\n    </div>\n}\n\nfunction CompB(){\n    const [ value ,setValue ] = useState('')\n    const [state ,dispatch ] = useConnect((state)=> ({ mesA : state.mesA }) )\n    return <div className=\"component_box\" >\n        <p> 组件B</p>\n        <p>组件A对我说 ： {state.mesA} </p>\n        <input onChange={(e)=>setValue(e.target.value)}\n            placeholder=\"对A组件说\"\n        />\n        <button onClick={()=> dispatch({ type:'setB' ,payload:value })} >确定</button>\n    </div>\n}\n\nfunction CompC(){\n    const [state  ] = useConnect((state)=> ({ mes1 : state.mesA,mes2 : state.mesB }) )\n    return <div className=\"component_box\" >\n        <p>组件A ： {state.mes1} </p>\n        <p>组件B ： {state.mes2} </p>\n    </div>\n}\n\nfunction CompD(){\n    const [ ,dispatch  ] = useConnect( )\n    console.log('D 组件更新')\n    return <div className=\"component_box\" >\n        <button onClick={()=> dispatch({ type:'clear' })} > 清空 </button>\n    </div>\n}\n\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CompA 和 CompB 模拟组件双向通信。"}),"\n",(0,s.jsxs)(n.li,{children:["CompC 组件接收 CompA 和 CompB 通信内容，并映射到 ",(0,s.jsx)(n.code,{children:"mes1 ，mes2"})," 属性上。"]}),"\n",(0,s.jsx)(n.li,{children:"CompD 没有 mapStoreToState ，没有订阅 state ，state 变化组件不会更新，只是用 dispatch 清空状态。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"效果",children:["效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#效果",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"8.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"五-持续更新中",children:["五 持续更新中～",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-持续更新中",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章节，第二十六章节，第十四章节为持续维护章节，会有更多精彩的自定义 hooks 实践场景。"}),"\n",(0,s.jsxs)(n.h2,{id:"六-总结",children:["六 总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#六-总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本章节为实践章节，记录了真实工作中使用的自定义 hooks 场景，还有一些自定义 hooks 巧妙设计思路。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let u=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F30.%E5%AE%9E%E8%B7%B5%E7%AF%87-%E8%87%AA%E5%AE%9A%E4%B9%89%20Hooks%20%E5%AE%9E%E8%B7%B5.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 实践一：自动上报pv/click的埋点hooks—— useLog",id:"二-实践一自动上报pvclick的埋点hooks-uselog",depth:2},{text:"三 实践二：带查询的分页加载长列表—— useQueryTable",id:"三-实践二带查询的分页加载长列表-usequerytable",depth:2},{text:"设计原则",id:"设计原则",depth:3},{text:"设计模型图",id:"设计模型图",depth:3},{text:"代码实现",id:"代码实现",depth:3},{text:"四 实践三：实现React-Redux功能—— useCreateStore | useConnect",id:"四-实践三实现react-redux功能-usecreatestore--useconnect",depth:2},{text:"1 设计思路",id:"1-设计思路",depth:3},{text:"useCreateStore 设计",id:"usecreatestore-设计",depth:4},{text:"Store设计",id:"store设计",depth:4},{text:"useConnect设计",id:"useconnect设计",depth:4},{text:"原理图",id:"原理图",depth:4},{text:"2 useCreateStore",id:"2-usecreatestore",depth:3},{text:"3 状态管理者 —— ReduxHooksStore",id:"3-状态管理者--reduxhooksstore",depth:3},{text:"状态",id:"状态",depth:4},{text:"方法",id:"方法",depth:4},{text:"4 useConnect",id:"4-useconnect",depth:3},{text:"5 使用与验证效果",id:"5-使用与验证效果",depth:3},{text:"根部组件注入 Store",id:"根部组件注入-store",depth:4},{text:"业务组件使用",id:"业务组件使用",depth:4},{text:"效果",id:"效果",depth:4},{text:"五 持续更新中～",id:"五-持续更新中",depth:2},{text:"六 总结",id:"六-总结",depth:2}],title:"30.实践篇-自定义 Hooks 实践",headingTitle:"30.实践篇-自定义 Hooks 实践",frontmatter:{}}}}]);