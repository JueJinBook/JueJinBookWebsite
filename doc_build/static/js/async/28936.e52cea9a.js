"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["28936"],{768547:function(e,n,s){s.r(n),s.d(n,{default:()=>r});var a=s(552676),c=s(740453);function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",h4:"h4",code:"code",pre:"pre",img:"img",ul:"ul",li:"li",blockquote:"blockquote"},(0,c.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"65canvas制作海报",children:["65.Canvas制作海报",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#65canvas制作海报",children:"#"})]}),"\n",(0,a.jsxs)(n.h2,{id:"104-canvas制作海报",children:["10.4 Canvas制作海报",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#104-canvas制作海报",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Canvas是一个可以使用JavaScript来绘制图表、图片以及动画的组件，在小程序里广泛用于生成分享海报、交互动画、数据可视化、小游戏的开发等。如果说Canvas组件是一个空白的画板，那JavaScript脚本就是画笔。"}),"\n",(0,a.jsxs)(n.h3,{id:"1041-设备信息与节点信息",children:["10.4.1 设备信息与节点信息",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1041-设备信息与节点信息",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"1获取设备的宽高与像素比",children:["1、获取设备的宽高与像素比",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1获取设备的宽高与像素比",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["在不少场景下我们需要获取设备屏幕的宽高，以让canvas绘制的图片可以全屏以及方便图片上的元素的定位。而pixelRatio设备像素比指的是手机、PC等设备显示器的物理像素分辨率与CSS逻辑像素分辨率之比，普通显示器这个值为1，而现在大多数的手机为2以上（高清显示屏一个CSS逻辑像素对应多个物理像素）。我们可以调用",(0,a.jsx)(n.code,{children:"wx.getSystemInfoSync()"}),"来获取当前设备屏幕的宽高、像素比。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const res = wx.getSystemInfoSync()\nconsole.log(res)\nconsole.log("屏幕的宽",res.screenWidth)\nconsole.log("屏幕的高",res.screenHeight)\nconsole.log("可使用窗口的宽",res.windowWidth)\nconsole.log("可使用窗口的高",res.windowHeight)\nconsole.log("状态栏的高度",res.statusBarHeight)\nconsole.log("设备像素比",res.pixelRatio)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["开发者工具模拟器就有一些常见机型的CSS分辨率和设备的像素比Dpr的值，比如在iphone X上使用canvas绘制的图片大小为",(0,a.jsx)(n.code,{children:"375 \xd7 812"}),"，全屏就会很模糊，宽高都要乘以设备像素比3，即为",(0,a.jsx)(n.code,{children:"1125 \xd7 2436"}),"才合理。\n",(0,a.jsx)(n.img,{src:"https://i.hackweek.org/img//10/WX20200829-175748@2x.png",alt:"开发者工具模拟机型的css分辨率与Dpr"})]}),"\n",(0,a.jsxs)(n.h4,{id:"2获取节点信息",children:["2、获取节点信息",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2获取节点信息",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["要建立canvas组件与JavaScript的联系，需要了解一些WXML节点以及获取节点的知识。节点信息查询 API ",(0,a.jsx)(n.code,{children:"wx.createSelectorQuery()"}),"可以用于获取节点属性、样式、在界面上的位置等信息。制作交互动画、小游戏、Canvas、编辑器等这些功能时，就经常需要获取页面上每个节点（元素）的具体信息。"]}),"\n",(0,a.jsx)(n.p,{children:"使用开发者工具新建一个页面，比如canvas，然后再在canvas.wxml里输入以下代码，"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<view class="books" id="book001" data-book="book001" hover-class="red" style="background:#fadc4a;color:#fff;margin:20px;padding:20px">\n  <view class="title">小程序云开发入门与实战</view>\n  <view class="author">李东bbsky</view>\n  <view class="desc">零基础也能快速上手学会小程序的云开发</view>\n</view>\n'})}),"\n",(0,a.jsx)(n.p,{children:"然后再在canvas.js的onload生命周期函数或控制台输入以下代码来了解节点信息所包含的内容，"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const query = wx.createSelectorQuery()\nquery.select('#book001').fields({\n  dataset: true, //返回节点的dataset，这里为data-book\n  size: true, //返回节点的宽与高的像素\n  scrollOffset: true,\n  properties: ['hover-class'], //返回指定属性名hover-class里的值，这里值为red\n  computedStyle: ['margin', 'backgroundcolor','color','padding'],//返回节点指定style的对应值\n  rect:true,  //返回节点的绝对布局位置，top,left,bottom,right\n}).exec(res=>{\n  console.log(\"节点的信息\",res)\n})\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"SelectorQuery.select()"}),"返回当前页面下选择器匹配到的第一个节点，与css选择器类似，这里为选择id为book001的节点；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"NodesRef.fields()"}),"返回节点的信息，比如节点的dataset、宽高尺寸size、属性名列表、指定样式名列表、滚动信息以及对应的Context上下文对象，我们可以从console.log了解到；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"SelectorQuery.exec()"}),"执行节点信息操作的所有请求，请求结果按请求次序构成数组。"]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"1042-canvas快速入门",children:["10.4.2 Canvas快速入门",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1042-canvas快速入门",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"1创建一个空白画板",children:["1、创建一个空白画板",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1创建一个空白画板",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"使用开发者工具新建一个页面，比如canvas，然后再在canvas.wxml里输入以下代码，这里创建了一个canvas的组件（相当于创建了一个画板）："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-xml",children:'<canvas type="2d" id="myCanvas"></canvas>\n'})}),"\n",(0,a.jsx)(n.p,{children:"canvas组件默认宽度300px、高度150px，这里的type是渲染方式，支持2D和webgl（一般简单的开发推荐2D）;id为canvas的属性，与之前学过CSS的选择器是一样的。"}),"\n",(0,a.jsxs)(n.h4,{id:"2建立画板与画笔的联系",children:["2、建立画板与画笔的联系",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2建立画板与画笔的联系",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["然后再在canvas.js里输入以下代码，我们通过",(0,a.jsx)(n.code,{children:"wx.createSelectorQuery().select('#myCanvas')"}),"就获取到了指定的节点（找到画板），在返回的res对象里通过",(0,a.jsx)(n.code,{children:"Canvas.getContext"}),"获取Canvas节点的绘图上下文和它的绘画功能，通过exec()可以执行操作节点的请求，这就相当于画笔："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const query = wx.createSelectorQuery()\nquery.select('#myCanvas')\n  .fields({ node: true, size: true })\n  .exec((res) => {\n    //通过打印来了解节点信息\n    console.log(\"节点的相关信息\",res)\n    const canvas = res[0].node\n    const ctx = canvas.getContext('2d')\n\n    //canvas绘图区域大小，如果设备像素比不为1，就放大；比如高清显示屏为2，绘制时就放大2倍\n    const dpr = wx.getSystemInfoSync().pixelRatio\n    canvas.width = res[0].width * dpr\n    canvas.height = res[0].height * dpr\n    ctx.scale(dpr, dpr)\n\n    //在下面区域绘制canvas，比如下面是绘制一个填充矩形\n    ctx.fillRect(5,5,100,50)    \n  })\n"})}),"\n",(0,a.jsx)(n.p,{children:"后面我们就不用写整个函数了，只需要把代码放置在上面备注的区域，编译之后就能在模拟器里看到Canvas绘图的效果了。"}),"\n",(0,a.jsxs)(n.h3,{id:"1043-canvas绘制图形",children:["10.4.3 Canvas绘制图形",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1043-canvas绘制图形",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Canvas绘制图形的方法有很多，可以用于绘制矩形、路径、线、圆弧、贝塞尔曲线等，下面对这些方法进行了归类整理，只需要把案例的代码放置到节点执行请求的方法exec()里即可。这里元素的位置是相对于左上角的原点定位，坐标（x,y）是相对于左上角的坐标为距离左边x像素，距离上边y像素。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{src:"https://i.hackweek.org/img//10/WX20201026-094110@2x.png",alt:"坐标x,y的含义"})}),"\n",(0,a.jsxs)(n.h4,{id:"1绘制矩形",children:["1、绘制矩形",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1绘制矩形",children:"#"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"fillRect(x, y, width, height)绘制一个填充的矩形"}),"\n",(0,a.jsx)(n.li,{children:"strokeRect(x, y, width, height)绘制一个矩形的边框"}),"\n",(0,a.jsx)(n.li,{children:"clearRect(x, y, width, height)清除指定矩形区域，让清除部分完全透明。"}),"\n",(0,a.jsx)(n.li,{children:"rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'ctx.fillStyle = "#FFA500" //填充矩形的颜色\nctx.fillRect(5,5,100,50)   \nctx.strokeRect(5,70,100,50)\n\nctx.fillStyle = "#fadc4a"; //按照请求的次序可以反复绘制\nctx.fillRect(5,125,100,50)\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"2绘制路径与绘制直线",children:["2、绘制路径与绘制直线",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2绘制路径与绘制直线",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"图形的基本元素是路径，通过路径能够绘制非常复杂的图形（包括实心矩形、空心矩形），路径是通过不同颜色和宽度的线段或曲线（如圆弧，贝塞尔曲线）相连形成的不同形状的点的集合。生成路径的第一步是beginPath()，然后通过移动笔触或画图命令来绘制路径，最后选择fill填充、stroke轮廓、clip裁剪。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"beginPath()新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径；"}),"\n",(0,a.jsx)(n.li,{children:"closePath()闭合路径之后图形绘制命令又重新指向到上下文中；"}),"\n",(0,a.jsx)(n.li,{children:"stroke()通过线条来绘制图形轮廓，可以绘制边框；"}),"\n",(0,a.jsx)(n.li,{children:"fill()通过填充路径的内容区域生成实心的图形；"}),"\n",(0,a.jsx)(n.li,{children:"clip()将当前创建的路径设置为当前剪切路径，比如可以用于抠图；"}),"\n",(0,a.jsx)(n.li,{children:"moveTo(x, y)将笔触移动到指定的坐标(x,y)上；"}),"\n",(0,a.jsx)(n.li,{children:"lineTo(x, y)绘制一条从当前位置到指定x到y位置的直线。"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'ctx.fillStyle = "#7fe787" //填充矩形的颜色\nctx.beginPath()\nctx.moveTo(75, 50)\nctx.lineTo(100, 75)\nctx.lineTo(100, 25)\nctx.fill()  \n'})}),"\n",(0,a.jsxs)(n.h4,{id:"3绘制圆弧",children:["3、绘制圆弧",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3绘制圆弧",children:"#"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"arc(x, y, radius, startAngle, endAngle, anticlockwise)画一个以（x,y）为圆心的以radius为半径的圆弧（圆）；"}),"\n",(0,a.jsx)(n.li,{children:"arcTo(x1, y1, x2, y2, radius)根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'ctx.fillStyle = "#2870f6" //填充矩形的颜色\nctx.beginPath();\nctx.arc(100, 75, 50, 0, 2 * Math.PI)\nctx.fill()\n\nctx.beginPath()\nctx.arc(150, 75, 70, Math.PI, 2 * Math.PI, false)\nctx.stroke()\n\nctx.beginPath()\nctx.moveTo(20, 20)          \nctx.lineTo(100, 20)\nctx.arcTo(150, 20, 150, 70, 50)\nctx.lineTo(150, 120)\nctx.stroke()   \n'})}),"\n",(0,a.jsxs)(n.h4,{id:"4绘制贝塞尔曲线",children:["4、绘制贝塞尔曲线",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4绘制贝塞尔曲线",children:"#"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"quadraticCurveTo(cp1x, cp1y, x, y)绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，(x,y)为结束点；"}),"\n",(0,a.jsx)(n.li,{children:"bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)绘制三次贝塞尔曲线，(cp1x,cp1y)为控制点一，(cp2x,cp2y)为控制点二，(x,y)为结束点。"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"ctx.beginPath();\nctx.moveTo(20, 20);\nctx.quadraticCurveTo(20, 100, 200, 20);\nctx.stroke();\n\nctx.beginPath();\nctx.moveTo(20, 20);\nctx.bezierCurveTo(20, 100, 200, 100, 200, 20);\nctx.stroke();\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["canvas还可以通过save将当前状态放入绘制栈中，通过restrore将canvas恢复到最近的保存状态；在使用时，我们可以根据实际情况在绘制了一段图形之后使用",(0,a.jsx)(n.code,{children:"ctx.save()"}),"来保存当前状态。"]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"1044-使用样式和颜色",children:["10.4.4 使用样式和颜色",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1044-使用样式和颜色",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"1填充图形与轮廓的颜色",children:["1、填充图形与轮廓的颜色",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1填充图形与轮廓的颜色",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"前面我们提过图形的基本元素是路径，而路径有两种填充形式，填充与轮廓，这些都有对应的颜色填充方式，当我们要开始绘制图形时，可以先确定画笔的颜色："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"fillStyle = color"})," 设置图形的填充颜色；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"strokeStyle = color"}),"设置图形轮廓的颜色。"]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'ctx.fillStyle = "#2870f6"\nctx.strokeStyle = "#cd5a4c"\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"3线型",children:["3、线型",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3线型",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"图形是由点、线以及填充方式构成，可见线与线的样式的重要性，可以通过以下属性来设置线的样式："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"lineWidth = value"}),"设置线条宽度；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"lineCap = type"}),"设置线条末端样式。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"lineJoin = type"}),"设定线条与线条间接合处的样式。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"miterLimit = value"}),"限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"getLineDash()"}),"返回一个包含当前虚线样式，长度为非负偶数的数组。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"setLineDash(segments)"}),"设置当前虚线样式。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"lineDashOffset = value"}),"设置虚线样式的起始偏移量。"]}),"\n"]}),"\n",(0,a.jsxs)(n.h4,{id:"2透明度渐变阴影",children:["2、透明度、渐变、阴影",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2透明度渐变阴影",children:"#"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"globalAlpha = transparencyValue"}),"这个属性会影响canvas里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明）；"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"createLinearGradient(x1, y1, x2, y2)绘制线性渐变，渐变的起点 (x1,y1) 与终点 (x2,y2)；"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"createRadialGradient(x1, y1, r1, x2, y2, r2)绘制径向渐变会绘制两个圆，一是以 (x1,y1) 为原点，半径为r1的圆；二是以 (x2,y2) 为原点，半径为 r2 的圆。"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"shadowOffsetX = float"}),"和",(0,a.jsx)(n.code,{children:"shadowOffsetY = float"}),"用来设定阴影在X和Y轴的延伸距离；"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"shadowBlur = float"}),"用于设定阴影的模糊程度；"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"shadowColor = color"}),"用于设定阴影颜色效果，默认是全透明的黑色。"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"1045-使用canvas绘制文本",children:["10.4.5 使用Canvas绘制文本",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1045-使用canvas绘制文本",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"1绘制文本",children:["1、绘制文本",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1绘制文本",children:"#"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"font = value"}),"绘制文本的样式，语法与CSS font属性相同，默认的字体是",(0,a.jsx)(n.code,{children:"10px sans-serif"}),"；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"textAlign = value"}),"，文本对齐选项，如start, end, left, right,center；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"textBaseline = value"}),"，基线对齐选项，如top, hanging, middle, alphabetic, ideographic, bottom。默认值为alphabetic；"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"direction = value"}),"，文本方向，如ltr, rtl, inherit。默认值是 inherit；"]}),"\n",(0,a.jsx)(n.li,{children:"fillText(text, x, y [, maxWidth])在指定的(x,y)位置填充指定的文本；"}),"\n",(0,a.jsx)(n.li,{children:"strokeText(text, x, y [, maxWidth])在指定的(x,y)位置绘制文本边框。"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'ctx.font = "48px serif";\nctx.textAlign = "center"\nctx.strokeText("李东",50,50);\nctx.fillText("bbsky",150,50)\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"2测量文本宽度与多行文字处理",children:["2、测量文本宽度与多行文字处理",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2测量文本宽度与多行文字处理",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"canvas不能像css一样对多行文本进行自动换行，但是我们可以使用measureText()来预测量所输入的文本的每一个字符的宽度。measureText()返回一个TextMetrics对象，里面包含每一个字符的宽度、所在像素等体现文本特性的属性。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'ctx.font = "48px serif";\nconst text = ctx.measureText("李东bbsky"); // TextMetrics object\nconsole.log(text)\n'})}),"\n",(0,a.jsx)(n.p,{children:"文本的宽度受font设置的文字大小和字体的影响，打印的结果如下:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"width: 47.01994323730469  //7个字符整体宽度\nactualBoundingBoxLeft: -0.4899999797344208\nactualBoundingBoxRight: 46.96995162963867\nactualBoundingBoxAscent: 8.270000457763672\nactualBoundingBoxDescent: 1.9800004959106445\nadvances: (7) [0, 10, 20, 25.8599853515625, 31.719970703125, 36.76995849609375, 42.05995178222656]\nemHeightAscent: 8.59375\nemHeightDescent: 1.40625\nfontBoundingBoxAscent: 11\nfontBoundingBoxDescent: 3\n"})}),"\n",(0,a.jsx)(n.p,{children:"然后在canvas.js里输入以下代码，我们需要先计算所有文字的宽度，根据给定的绘图区域的宽度maxWidth来进行文本的换行："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"onShow: function () {\n  const that = this\n  const query = wx.createSelectorQuery()\n  query.select('#myCanvas')\n    .fields({ node: true, size: true })\n    .exec((res) => {\n      const canvas = res[0].node\n      const ctx = canvas.getContext('2d')\n      const dpr = wx.getSystemInfoSync().pixelRatio\n\n      canvas.width = res[0].width * dpr\n      canvas.height = res[0].height * dpr\n      ctx.scale(dpr, dpr)\n\n      ctx.fillStyle = \"#FFA500\";\n      // ctx.fillRect(0,0,canvas.width ,canvas.height)\n      ctx.font = \"16px serif\";\n      ctx.textAlign = \"base\"\n      ctx.textBaseline = \"top\"\n\n      let maxWidth = 100;\n      let lineHeight = 25;\n\n      let text1 = \"我们用来绘制文本的样式，这个字符串使用和CSS font属性相同的语法\"\n      that.wrapText(ctx,text1,10,20,maxWidth,lineHeight)    \n      // ctx.fillText(\"我们用来绘制文本的样式，这个字符串使用和CSS font属性相同的语法\",10,20)\n    })\n\n},\n\nwrapText(context, text, x, y, maxWidth, lineHeight) {\n  let words = text.split('');\n  console.log(words)\n  let line = '';\n\n  for(let n = 0; n < text.length; n++) {\n    let testLine = line + words[n] + '';\n    let metrics = context.measureText(testLine);\n    console.log(metrics)\n    let testWidth = metrics.width;\n    if (testWidth > maxWidth && n > 0) {\n      console.log(line)\n      console.log(x)\n      console.log(y)\n      context.fillText(line, x, y);\n      line = words[n] + '';\n      y += lineHeight;\n    }\n    else {\n      line = testLine;\n    }\n  }\n  context.fillText(line, x, y);\n},\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"1046-使用canvas操作图片",children:["10.4.6 使用Canvas操作图片",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1046-使用canvas操作图片",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"1图片的来源与装载",children:["1、图片的来源与装载",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1图片的来源与装载",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["我们可以使用",(0,a.jsx)(n.code,{children:"Canvas.createImage()"}),"来创建一个图片对象，或使用",(0,a.jsx)(n.code,{children:"Canvas.createImageData()"}),"来创建一个ImageData 对象。",(0,a.jsx)(n.code,{children:"img.onload"}),"保证在调用drawImage时图片加载完成："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const img = canvas.createImage()\nimg.onload = function(){\n\n}\nimg.src = 'myImage.png'; // 设置图片源地址\n"})}),"\n",(0,a.jsx)(n.p,{children:"这里图片的来源可以是外部链接，也可以是来自于云存储，还可以是来自小程序的本地文件。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"drawImage(image, x, y)这里的image是image或canvas对象；"}),"\n",(0,a.jsx)(n.li,{children:"drawImage(image, x, y, width, height)相比于上个方法多了width和height，用来控制当向canvas画入时应该缩放的大小"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["我们可以在canvas.js里的onLoad生命周期函数里使用",(0,a.jsx)(n.code,{children:"this.createCanvas()"}),"调用如下函数，下面是将两张图片给绘制到一起："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'createCanvas(){\n  const imgurl = "https://tcb-1251009918.cos.ap-guangzhou.myqcloud.com/demo/canvas.jpg" //真机上需要将图片链接列入安全名单或将图片下载下来\n  const qrcode = "https://tcb-1251009918.cos.ap-guangzhou.myqcloud.com/demo/qrcode.jpg"\n\n  const query = wx.createSelectorQuery()\n  query.select(\'#myCanvas\')\n    .fields({ node: true, size: true })\n    .exec((res) => {\n      console.log("节点的相关信息",res)\n      const canvas = res[0].node\n      const ctx = canvas.getContext(\'2d\')\n      const dpr = wx.getSystemInfoSync().pixelRatio\n\n      canvas.width = res[0].width * dpr\n      canvas.height = res[0].height * dpr\n      ctx.scale(dpr, dpr)\n\n\n      const img1 = canvas.createImage()\n      const img2 = canvas.createImage()\n\n      img1.onload = function() { \n          img2.src = qrcode; \n      }; \n      img2.onload = function() { \n        ctx.drawImage(img1, 0, 0,res[0].width,res[0].height); \n        ctx.drawImage(img2, 35, 100,150,195); \n      }; \n      img1.src = imgurl\n\n    })\n},\n'})}),"\n",(0,a.jsxs)(n.p,{children:["canvas绘制图片还支持变形（移动translate，旋转rotate和缩放scale、变形transform）、遮罩（Compositing）、裁剪（clip），具体的内容大家可以参考",(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial",target:"_blank",rel:"noopener noreferrer",children:"Canvas MDN技术文档"}),"。"]}),"\n",(0,a.jsxs)(n.h4,{id:"2保存图片",children:["2、保存图片",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2保存图片",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["使用Canvas绘制完成后，可以通过",(0,a.jsx)(n.code,{children:"wx.canvasToTempFilePath"}),"将canvas指定位置(x,y)的指定宽高(width,height)输出为指定大小(destWidth,destHeight)并指定类型fileType（支持jpg和png）的图片到小程序临时文件，而通过",(0,a.jsx)(n.code,{children:"wx.saveImageToPhotosAlbum"}),"可以将临时文件的图片保存到用户的手机相册。"]}),"\n",(0,a.jsxs)(n.p,{children:["在将图片保存到相册之前首先要使用",(0,a.jsx)(n.code,{children:"wx.authorize()"}),"来获取scope.writePhotosAlbum的权限，具体的方法在录音与播放的章节已经提到过。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"createCanvas(){\n  const that = this\n  query.select('#myCanvas')\n    .fields({ node: true, size: true })\n    .exec((res) => {\n      const canvas = res[0].node\n      this.setData({  //将绘制好的canvas对象赋值给data对象里的canvasObj\n        canvasObj:canvas\n        })\n    })\n}\n\n\nsaveCanvas(canvasimg) {\n  //注意要先获取权限\n  const that = this\n  wx.canvasToTempFilePath({\n    canvas:that.data.canvasObj, //注意这里是canvas，不是canvasId\n    success(res) {\n      console.log(res.tempFilePath)\n      wx.saveImageToPhotosAlbum({\n        filePath: res.tempFilePath,\n        success(res) {\n          console.log(res)  //可以使用一些交互式的反馈\n        }\n      })\n    }\n  })\n},\n"})}),"\n",(0,a.jsx)(n.p,{children:"如果是渲染高性能的交互式2D和3D图形，比如小游戏，webVR等，可以使用WebGL的模式渲染Canvas，而对于一些简单的动画、GUI等内容类的渲染建议仍然使用Canvas 2D的模式。WebGL的模式和Canvas 2D的API有比较大的差异，建议有需求的童鞋可以查阅MDN文档进一步学习。"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Canvas的功能非常强大，使用也比较复杂，借助于一些开源的项目会大大提升我们的开发效率，比如小程序拓展能力里的wxml-to-canvas、threejs-miniprogram、lottie-miniprogram等都是基于Canvas的。"}),"\n"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(i,{...e})}):i(e)}let r=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%2F65.Canvas%E5%88%B6%E4%BD%9C%E6%B5%B7%E6%8A%A5.md"]={toc:[{text:"10.4 Canvas制作海报",id:"104-canvas制作海报",depth:2},{text:"10.4.1 设备信息与节点信息",id:"1041-设备信息与节点信息",depth:3},{text:"1、获取设备的宽高与像素比",id:"1获取设备的宽高与像素比",depth:4},{text:"2、获取节点信息",id:"2获取节点信息",depth:4},{text:"10.4.2 Canvas快速入门",id:"1042-canvas快速入门",depth:3},{text:"1、创建一个空白画板",id:"1创建一个空白画板",depth:4},{text:"2、建立画板与画笔的联系",id:"2建立画板与画笔的联系",depth:4},{text:"10.4.3 Canvas绘制图形",id:"1043-canvas绘制图形",depth:3},{text:"1、绘制矩形",id:"1绘制矩形",depth:4},{text:"2、绘制路径与绘制直线",id:"2绘制路径与绘制直线",depth:4},{text:"3、绘制圆弧",id:"3绘制圆弧",depth:4},{text:"4、绘制贝塞尔曲线",id:"4绘制贝塞尔曲线",depth:4},{text:"10.4.4 使用样式和颜色",id:"1044-使用样式和颜色",depth:3},{text:"1、填充图形与轮廓的颜色",id:"1填充图形与轮廓的颜色",depth:4},{text:"3、线型",id:"3线型",depth:4},{text:"2、透明度、渐变、阴影",id:"2透明度渐变阴影",depth:4},{text:"10.4.5 使用Canvas绘制文本",id:"1045-使用canvas绘制文本",depth:3},{text:"1、绘制文本",id:"1绘制文本",depth:4},{text:"2、测量文本宽度与多行文字处理",id:"2测量文本宽度与多行文字处理",depth:4},{text:"10.4.6 使用Canvas操作图片",id:"1046-使用canvas操作图片",depth:3},{text:"1、图片的来源与装载",id:"1图片的来源与装载",depth:4},{text:"2、保存图片",id:"2保存图片",depth:4}],title:"65.Canvas制作海报",headingTitle:"65.Canvas制作海报",frontmatter:{}}}}]);