"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["349"],{78877:function(e,r,n){n.r(r),n.d(r,{default:()=>a});var i=n(552676),s=n(740453);function l(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",ul:"ul",li:"li",blockquote:"blockquote",p:"p",code:"code",ol:"ol",pre:"pre",strong:"strong"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.h1,{id:"16进阶-3给-api-命令增加版本功能",children:["16进阶 3：给 API 命令增加版本功能",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#16进阶-3给-api-命令增加版本功能",children:"#"})]}),"\n",(0,i.jsxs)(r.h2,{id:"本节核心内容",children:["本节核心内容",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#本节核心内容",children:"#"})]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"如何给 apiserver 增加版本功能"}),"\n"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsxs)(r.p,{children:["本小节源码下载路径：",(0,i.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo12",target:"_blank",rel:"noopener noreferrer",children:"demo12"})]}),"\n",(0,i.jsx)(r.p,{children:"可先下载源码到本地，结合源码理解后续内容，边学边练。"}),"\n",(0,i.jsxs)(r.p,{children:["本小节的代码是基于 ",(0,i.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo11",target:"_blank",rel:"noopener noreferrer",children:"demo11"})," 来开发的。"]}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"为什么需要版本",children:["为什么需要版本",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么需要版本",children:"#"})]}),"\n",(0,i.jsxs)(r.p,{children:["在实际开发中，当开发完一个 apiserver 特性后，会编译 apiserver 二进制文件并发布到生产环境，很多时候为了定位问题和出于安全目的（不能发错版本），我们需要知道当前 apiserver 的版本，以及一些编译时候的信息，如编译时 Go 的版本、Git 目录是否 clean，以及基于哪个 git commmit 来编译的。在一个编译好的可执行程序中，我们通常可以用类似 ",(0,i.jsx)(r.code,{children:"./app_name -v"})," 的方式来获取版本信息。"]}),"\n",(0,i.jsxs)(r.p,{children:["我们可以将这些信息写在配置文件中，程序运行时从配置文件中取得这些信息进行显示。但是在部署程序时，除了二进制文件还需要额外的配置文件，不是很方便。或者将这些信息写入代码中，这样不需要额外的配置，但要在每次编译时修改代码文件，也比较麻烦。Go 官方提供了一种更好的方式：通过 ",(0,i.jsx)(r.code,{children:"-ldflags -X importpath.name=value"}),"（详见 ",(0,i.jsx)(r.a,{href:"https://golang.org/cmd/link/",target:"_blank",rel:"noopener noreferrer",children:"-ldflags -X importpath.name=value"}),"）来给程序自动添加版本信息。"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"在实际开发中，绝大部分都是用 Git 来做源码版本管理的，所以 apiserver 的版本功能也基于 Git。"}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"给-apiserver-添加版本功能",children:["给 ",(0,i.jsx)(r.code,{children:"apiserver"})," 添加版本功能",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#给-apiserver-添加版本功能",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"假设我们程序发布的流程是这样："}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"编码完成，提交测试工程师测试"}),"\n",(0,i.jsx)(r.li,{children:"测试工程师测试代码，提交 bug，更改 bug 并重新测试后验证通过"}),"\n",(0,i.jsxs)(r.li,{children:["开发人员把验证通过的代码合并到 master 分支，并打上版本号：",(0,i.jsx)(r.code,{children:"git tag -a v1.0.0"})]}),"\n",(0,i.jsxs)(r.li,{children:["开发人员将 ",(0,i.jsx)(r.code,{children:"v1.0.0"})," 版本发布到生产环境"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["最终发布后，我们希望通过 ",(0,i.jsx)(r.code,{children:"./apiserver -v"})," 参数提供如下版本信息："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"版本号"}),"\n",(0,i.jsx)(r.li,{children:"git commit"}),"\n",(0,i.jsx)(r.li,{children:"git tree 在编译时的状态"}),"\n",(0,i.jsx)(r.li,{children:"构建时间"}),"\n",(0,i.jsx)(r.li,{children:"go 版本"}),"\n",(0,i.jsx)(r.li,{children:"go 编译器"}),"\n",(0,i.jsx)(r.li,{children:"运行平台"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["为了实现这些功能，我们首先要在 ",(0,i.jsx)(r.code,{children:"main"})," 函数中添加用于接收 ",(0,i.jsx)(r.code,{children:"-v"})," 参数的入口（详见 ",(0,i.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo12/main.go",target:"_blank",rel:"noopener noreferrer",children:"demo12/main.go"}),"）："]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'package main\r\n\r\nimport (\r\n	"encoding/json"\r\n	"fmt"\r\n	"os"\r\n	...\r\n	v "apiserver/pkg/version"\r\n	...\r\n)\r\n\r\nvar (\r\n	version = pflag.BoolP("version", "v", false, "show version info.")\r\n)\r\n\r\nfunc main() {\r\n	pflag.Parse()\r\n	if *version {\r\n		v := v.Get()\r\n		marshalled, err := json.MarshalIndent(&v, "", "  ")\r\n		if err != nil {\r\n			fmt.Printf("%v\\n", err)\r\n			os.Exit(1)\r\n		}\r\n\r\n		fmt.Println(string(marshalled))\r\n		return\r\n	}\r\n	...\r\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["通过 ",(0,i.jsx)(r.code,{children:"pflag"})," 来解析命令行上传入的 ",(0,i.jsx)(r.code,{children:"-v"})," 参数。"]}),"\n",(0,i.jsxs)(r.p,{children:["通过 ",(0,i.jsx)(r.code,{children:"pkg/version"})," 的 ",(0,i.jsx)(r.code,{children:"Get()"})," 函数来获取 apiserver 的版本信息。"]}),"\n",(0,i.jsxs)(r.p,{children:["通过 ",(0,i.jsx)(r.code,{children:"json.MarshalIndent"})," 来格式化打印版本信息。"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"pkg/version"})," 的 ",(0,i.jsx)(r.code,{children:"Get()"})," 函数实现为（详见 ",(0,i.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo12/pkg/version",target:"_blank",rel:"noopener noreferrer",children:"demo12/pkg/version"}),"）："]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'func Get() Info {\r\n	return Info{\r\n		GitTag:       gitTag,\r\n		GitCommit:    gitCommit,\r\n		GitTreeState: gitTreeState,\r\n		BuildDate:    buildDate,\r\n		GoVersion:    runtime.Version(),\r\n		Compiler:     runtime.Compiler,\r\n		Platform:     fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),\r\n	}\r\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["其中 ",(0,i.jsx)(r.code,{children:"gitTag"}),"、",(0,i.jsx)(r.code,{children:"gitCommit"}),"、",(0,i.jsx)(r.code,{children:"gitTreeState"})," 等变量的值是通过 ",(0,i.jsx)(r.code,{children:"-ldflags -X importpath.name=value"})," 在编译时传到程序中的。为此我们需要在编译时传入这些信息，在 Makefile 中添加如下信息（详见 ",(0,i.jsx)(r.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo12/Makefile",target:"_blank",rel:"noopener noreferrer",children:"demo12/Makefile"}),"）："]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-makefile",children:'SHELL := /bin/bash \r\nBASEDIR = $(shell pwd)\r\n \r\n# build with verison infos\r\nversionDir = "apiserver/pkg/version"\r\ngitTag = $(shell if [ "`git describe --tags --abbrev=0 2>/dev/null`" != "" ];then git describe --tags --abbrev=0; else git log --pretty=format:\'%h\' -n 1; fi)\r\nbuildDate = $(shell TZ=Asia/Shanghai date +%FT%T%z)\r\ngitCommit = $(shell git log --pretty=format:\'%H\' -n 1)\r\ngitTreeState = $(shell if git status|grep -q \'clean\';then echo clean; else echo dirty; fi)\r\n \r\nldflags="-w -X ${versionDir}.gitTag=${gitTag} -X ${versionDir}.buildDate=${buildDate} -X ${versionDir}.gitCommit=${gitCommit} -X ${versionDir}.gitTreeState=${gitTreeState}"\n'})}),"\n",(0,i.jsxs)(r.p,{children:["并在 ",(0,i.jsx)(r.code,{children:"go build"})," 中添加这些 flag："]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-makefile",children:"go build -v -ldflags ${ldflags} .\n"})}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.code,{children:"-w"})," 为去掉调试信息（无法使用 gdb 调试），这样可以使编译后的二进制文件更小。"]}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"编译并测试",children:["编译并测试",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#编译并测试",children:"#"})]}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"下载 apiserver_demos 源码包（如前面已经下载过，请忽略此步骤）"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"$ git clone https://github.com/lexkong/apiserver_demos\n"})}),"\n",(0,i.jsxs)(r.ol,{start:"2",children:["\n",(0,i.jsxs)(r.li,{children:["将 ",(0,i.jsx)(r.code,{children:"apiserver_demos/demo12"})," 复制为 ",(0,i.jsx)(r.code,{children:"$GOPATH/src/apiserver"})]}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"$ cp -a apiserver_demos/demo12/ $GOPATH/src/apiserver\n"})}),"\n",(0,i.jsxs)(r.ol,{start:"3",children:["\n",(0,i.jsx)(r.li,{children:"在 apiserver 目录下编译源码"}),"\n"]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"$ cd $GOPATH/src/apiserver\r\n$ make\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"查看 apiserver 版本"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:'$ ./apiserver -v\r\n\r\n{\r\n  "gitTag": "7322949",\r\n  "gitCommit": "732294928b3c4dff5b898fde0bb5313752e1173e",\r\n  "gitTreeState": "dirty",\r\n  "buildDate": "2018-06-05T07:43:26+0800",\r\n  "goVersion": "go1.10.2",\r\n  "compiler": "gc",\r\n  "platform": "linux/amd64"\r\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["可以看到 ",(0,i.jsx)(r.code,{children:"./apiserver -v"})," 输出了我们需要的版本信息。"]}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsxs)(r.p,{children:["在上一小节中我们已经给 ",(0,i.jsx)(r.code,{children:"apiserver"})," 添加过 Makefile 文件。"]}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"小结",children:["小结",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(r.p,{children:["本小节主要介绍如何用 Makefile 以及 Go 本身所支持的编译特性，实现编译时自动生成版本号的功能。后续小节编译 API 源码均会通过 ",(0,i.jsx)(r.code,{children:"make"})," 来编译。"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),e.components);return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Go%20%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84%20RESTful%20API%20%E6%9C%8D%E5%8A%A1%2F16%E8%BF%9B%E9%98%B6%203%EF%BC%9A%E7%BB%99%20API%20%E5%91%BD%E4%BB%A4%E5%A2%9E%E5%8A%A0%E7%89%88%E6%9C%AC%E5%8A%9F%E8%83%BD.md"]={toc:[{text:"本节核心内容",id:"本节核心内容",depth:2},{text:"为什么需要版本",id:"为什么需要版本",depth:2},{text:"给 `apiserver` 添加版本功能",id:"给-apiserver-添加版本功能",depth:2},{text:"编译并测试",id:"编译并测试",depth:2},{text:"小结",id:"小结",depth:2}],title:"16进阶 3：给 API 命令增加版本功能",headingTitle:"16进阶 3：给 API 命令增加版本功能",frontmatter:{}}}}]);