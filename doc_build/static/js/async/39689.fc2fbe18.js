"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["39689"],{31541:function(e,n,s){s.r(n),s.d(n,{default:()=>X});var c=s(552676),i=s(740453);let r=s.p+"static/image/86444e4d2627addafafc70f1cdc7f620.6c42f11e.webp",a=s.p+"static/image/4e8e4bc0bbf42c4c432a8d0e4d65715e.99d2b274.webp",p=s.p+"static/image/c04d3ad771bba683816433b511781114.98e1cc5c.webp",d=s.p+"static/image/c86c6a4bb5c6966196bf000a4936d125.7c3ccbb0.webp",l=s.p+"static/image/d9b15c2af903d01a84157dc921b937b6.41b824ae.webp",t=s.p+"static/image/d299dcad15a92254063c7fe88cf449e9.09e489e4.webp",x=s.p+"static/image/a1ab0d40bee0c96f7b98d3591bbb67b1.00007eef.webp",h=s.p+"static/image/fb214494afe7bb9d8cfe9eee5b6a992a.39a9b3a8.webp",j=s.p+"static/image/b13e9405d32993b159b65272c850e02b.cf538819.webp",b=s.p+"static/image/689e65ffcf8e66acefc42466a31054ee.df0881e6.webp",m=s.p+"static/image/e5594f74aa355feb24426b47b7d15984.20b989c9.webp",o=s.p+"static/image/23a2a62b5cb9e92b050308f22c30aadd.d103610a.webp",g=s.p+"static/image/0082db5c9993182ab77535a65dbbf77b.db732969.webp",f=s.p+"static/image/7961405da6814bf2aac08dfdb3c86fb1.b1b18209.webp",u=s.p+"static/image/3ee15e6e3854731126e3c13362151a8f.ee5922e4.webp",y=s.p+"static/image/3918983cbf7b0bf6dc3e968ab1f6c43a.9ef2fce9.webp",A=s.p+"static/image/20a8bc0cc55fa061eee7b8ed5a751cfe.9db12b2a.webp",S=s.p+"static/image/c521d1de1a0bfe62e65b7ab299076a19.2238b86f.webp",E=s.p+"static/image/582c2e54b76620c343ca8b8af8ccc097.831ed224.webp",T=s.p+"static/image/d75d36225dbc9d418db52eca3e30200f.737fc5fe.webp",w=s.p+"static/image/3e1beee2341f90f19cb0e0aad44b330d.e7500069.webp",B=s.p+"static/image/36c86839944aa1c7a4732e2a176382cf.0e068bd4.webp",J=s.p+"static/image/cd9bd7fc8600a94f6787576e581b0c6d.0e9b9879.webp",v=s.p+"static/image/837806e0036b71c040020151649ef3a7.b1d37bf6.webp",R=s.p+"static/image/59418c8129d550d5695d66d9c873b8c6.ce9ce85b.webp",k=s.p+"static/image/c1d6abd18b01c2ad693a85ac6a797d3a.55c1b372.webp",D=s.p+"static/image/60e3a3d309a901061d6be4ad7b0e772f.7a1a21f4.webp",H=s.p+"static/image/c4e5352b2b12ef4d34037ba0f7d711c4.163c2c8e.webp",N=s.p+"static/image/eddefd48b7acdc2d817c08d1e6a9ccb8.ae05563a.webp";function O(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2",strong:"strong",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"23加餐3-种类型来源和-3-种模块语法",children:["23.加餐：3 种类型来源和 3 种模块语法",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23加餐3-种类型来源和-3-种模块语法",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"TypeScript 给 JavaScript 添加了一套类型语法，我们声明变量的时候可以给变量加上类型信息，这样编译阶段就可以检查出变量使用的对不对，也就是类型检查。"}),"\n",(0,c.jsx)(n.p,{children:"给变量添加类型，很自然可以想到时在声明的时候指定："}),"\n",(0,c.jsx)(n.p,{children:"比如对象："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"interface Person {\n    name: string;\n    age?: number;\n}\n\nconst guang: Person = {\n    name: 'guang'\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"比如函数："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"function add(num1: number, num2: number): number {\n    return num1 + num2;\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"这样当使用它们的时候，比如变量赋值、函数调用，就可以通过类型信息检查出使用的对不对："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:N,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:H,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"TypeScript 这样设计类型语法没啥问题，但是只是这样还不够。"}),"\n",(0,c.jsx)(n.p,{children:"我们自己写的代码可以这样声明类型，但不是我们写的呢？"}),"\n",(0,c.jsx)(n.p,{children:"比如 JS 引擎提供的 Number、String、Date、RegExp，浏览器环境的 HTMLElement、Event 等 api。"}),"\n",(0,c.jsx)(n.p,{children:"这些 api 是执行引擎内置的实现，但我们代码里会用到它们，也同样需要检查使用的对不对，也就是类型检查。怎么给这些 api 加上类型呢？"}),"\n",(0,c.jsxs)(n.h2,{id:"typescript-类型声明的三种来源",children:["TypeScript 类型声明的三种来源",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#typescript-类型声明的三种来源",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"TypeScript 设计了 declare 的语法，可以单独声明变量的类型："}),"\n",(0,c.jsx)(n.p,{children:"比如对象："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"interface Person {\n    name: string;\n    age?: number;\n}\n\ndeclare const guang: Person;\n"})}),"\n",(0,c.jsx)(n.p,{children:"比如函数："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"declare function add(num1: number, num2: number): number;\n"})}),"\n",(0,c.jsx)(n.p,{children:"这样单独声明了类型，使用这些 api 的时候也就能做类型检查。"}),"\n",(0,c.jsx)(n.p,{children:"像 JS 引擎那些 api，还有浏览器提供的 api，这些基本是必用的，而且都有标准的。所以 TypeScript 给内置了它们的类型声明。"}),"\n",(0,c.jsx)(n.p,{children:"TypeScript 包下有个 lib 目录，里面有一堆 lib.xx.d.ts 的类型声明文件，这就是 TS 内置的一些类型声明。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:D,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"因为这些只是声明类型，而没有具体的 JS 实现，TS 就给单独设计了一种文件类型，也就是 d.ts， d 是 declare 的意思。"}),"\n",(0,c.jsx)(n.p,{children:"比如 lib.dom.d.ts 里的类型声明："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:k,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"因为是 ts 内置的，所以配置一下就可以用了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:R,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"tsconfig.json 里配置下 compilerOptions.lib，就可以引入对应的 d.ts 的类型声明文件。"}),"\n",(0,c.jsx)(n.p,{children:"有的同学可能会说，可是内置的类型声明也不多呀，只有 dom 和 es 的。"}),"\n",(0,c.jsx)(n.p,{children:"确实，因为 JS 的 api 还有浏览器的 api 都是有标准的，那自然可以按照标准来定义类型。其余的环境的 api 可能没有标准，经常变，那自然就没法内置了，比如 node。所以 lib 里只有 dom 和 es 的类型声明。"}),"\n",(0,c.jsx)(n.p,{children:"那 node 环境，还有其他环境里的内置 api 怎么配置类型声明呢？"}),"\n",(0,c.jsx)(n.p,{children:"node 等环境的 api 因为没有标准而没有被 TS 内置，但 TS 同样也支持了这些环境的类型声明的配置。"}),"\n",(0,c.jsx)(n.p,{children:"方式是通过 @types/xxx 的包："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:v,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"TS 会先加载内置的 lib 的类型声明，然后再去查找 @types 包下的类型声明。"}),"\n",(0,c.jsx)(n.p,{children:"这样，其他环境的类型声明就可以通过这种方式来扩展。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:J,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["@types 包是在 ",(0,c.jsx)(n.a,{href:"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/README.zh.md",target:"_blank",rel:"noopener noreferrer",children:"DefinitelyTyped"})," 这个项目下统一管理的，想创建一个 @types 包的话要去看一下他们的文档。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:B,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"一般来说，很快就可以发到 npm 的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:w,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"我们知道，TS 内置的那些 lib 是可以配置的，扩展的这些 @types/xx 的包自然也可以配置："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:T,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"可以指定加载 @types 目录下的哪些包，还可以修改查找 @types 包的目录（默认是 node_modules/@types)："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:E,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"除了给 node 等环境的 api 加上类型声明外，@types 包还有一种用途，就是给一些 JS 的包加上类型声明："}),"\n",(0,c.jsx)(n.p,{children:"如果代码本身是用 ts 写的，那编译的时候就可以开启 compilerOptions.declaration，来生成 d.ts 文件："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:S,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"然后在 package.json 里配置 types 来指定 dts 的位置："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:A,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这样就不需要单独的 @types 包了。"}),"\n",(0,c.jsx)(n.p,{children:"但如果代码不是用 ts 写的，那可能既需要单独写一个 @types/xxx 的包来声明 ts 类型，然后在 tsconfig.json 里配置下，加载进来。"}),"\n",(0,c.jsx)(n.p,{children:"比如常用的 vue3 就不需要 @types/vue 包，因为本身是用 ts 写的，npm 包里也包含了 dts 文件。"}),"\n",(0,c.jsx)(n.p,{children:"但是 react 不是 ts 写的，是用的 facebook 自己的 flow，自然就需要 @types/react 的包来加上 ts 类型声明。"}),"\n",(0,c.jsx)(n.p,{children:"至此，ts 内置的 dom 和 es 的类型声明，其他环境还有一些包的类型声明我们都知道怎么加载了。"}),"\n",(0,c.jsx)(n.p,{children:"那自己写的 ts 代码呢？"}),"\n",(0,c.jsx)(n.p,{children:"这些其实我们经常配置，就是配置下编译的入口文件，通过 includes 指定一堆，然后通过 excludes 去掉一部分。还可以通过 files 再单独包含一些："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:y,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"tsc 在编译的时候，会分别加载 lib 的，@types 下的，还有 include 和 files 的文件，进行类型检查。"}),"\n",(0,c.jsx)(n.p,{children:"这就是 ts 类型声明的三种来源。"}),"\n",(0,c.jsx)(n.p,{children:"现在还有一个问题，有的 api 是全局的，有的 api 是某个模块的，ts 是怎么声明全局 api 的类型，怎么声明模块内的 api 的类型呢？"}),"\n",(0,c.jsxs)(n.h2,{id:"全局类型声明-vs-模块类型声明",children:["全局类型声明 vs 模块类型声明",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全局类型声明-vs-模块类型声明",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我们写的 JS 代码就是有的 api 是全局的，有的 api 是模块内的，所以 TS 需要支持这个也很正常。"}),"\n",(0,c.jsx)(n.p,{children:"但 JS 的模块规范不是一开始就有的，最开始是通过在全局挂一个对象，然后这个对象上再挂一些 api 的方式，也就是命名空间 namespace。"}),"\n",(0,c.jsx)(n.p,{children:"所以 TS 最早支持的模块化方案自然也就是 namespace："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"namespace Guang {\n    export interface Person {\n        name: string;\n        age?: number;\n    }\n\n    const name = 'guang';\n    const age = 20;\n\n    export const guang: Person = {\n        name,\n        age\n    }\n    export function add(a: number, b: number):number {\n        return a + b;\n    }\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"理解 namespace 的话可以看一下编译后的代码："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"就是全局上放一个对象，然后对象上再挂几个暴露出去的属性。"}),"\n",(0,c.jsx)(n.p,{children:"看了编译后的代码，是不是 namespace 瞬间就学会了～"}),"\n",(0,c.jsx)(n.p,{children:"后来，出现了 CommonJS 的规范，那种不能叫 namespace 了，所以 TS 支持了 module，"}),"\n",(0,c.jsx)(n.p,{children:"很容易想到，@types/node 的 api 定义就是一堆的 module："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这个 module 和 namespace 有什么区别呢？"}),"\n",(0,c.jsx)(n.p,{children:"其实真没什么区别，只不过 module 后一般接一个路径，而 namespace 后一般是一个命名空间名字。其他的语法都一样的。"}),"\n",(0,c.jsx)(n.p,{children:"而且这个结论是有依据的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["用 ",(0,c.jsx)(n.a,{href:"https://astexplorer.net",target:"_blank",rel:"noopener noreferrer",children:"astexplorer.net"})," 看一下 parse 后的 AST，两者的 AST类型都是一样的。也就是说编译器后续的处理都一样，那不是一种东西是什么。"]}),"\n",(0,c.jsx)(n.p,{children:"再后来的故事大家都知道了，JS 有了 es module 规范，所以现在推荐直接用 import export 的方式来声明模块和导入导出了。"}),"\n",(0,c.jsx)(n.p,{children:"额外多了的，只不过有一个 import type 的语法，可以单独引入类型："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"import type {xxx} from 'yyy';\n"})}),"\n",(0,c.jsx)(n.p,{children:"所以现在声明模块不咋推荐用 namespace 和 module，还是尽量用 es module 吧。"}),"\n",(0,c.jsx)(n.p,{children:"那全局的类型声明呢？"}),"\n",(0,c.jsx)(n.p,{children:"有了 es module 之后，TS 有了一个单独的设计："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"dts 中，如果没有 import、export 语法，那所有的类型声明都是全局的，否则是模块内的。"})}),"\n",(0,c.jsx)(n.p,{children:"我们试验一下："}),"\n",(0,c.jsx)(n.p,{children:"include 配置 src 下的 ts 文件，然后再用 files 引入 global.d.ts 文件："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"在 global.d.ts 里声明一个 func 函数："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"在 src/index.ts 里是有提示的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"编译也不报错："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"加上一个 import 语句："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["编译就报错了，说是找不到 func：\n",(0,c.jsx)("img",{src:t,alt:""})]}),"\n",(0,c.jsx)(n.p,{children:"这说明 func 就不再是全局的类型了。"}),"\n",(0,c.jsx)(n.p,{children:"这时候可以手动 declare global："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"再试一下，编译就通过了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"而且不止是 es module 的模块里可以用 global 声明全局类型，module 的方式声明的 CommonJS 模块也是可以的："}),"\n",(0,c.jsx)(n.p,{children:"比如 @types/node 里就有不少这种全局类型声明："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这就是 3 种 typescript 声明模块的语法，以及声明全局类型的方式。"}),"\n",(0,c.jsx)(n.p,{children:"那么如果就是需要引入模块，但是也需要全局声明类型，有什么更好的方式呢？"}),"\n",(0,c.jsx)(n.p,{children:"有，通过编译器指令 reference。这样既可以引入类型声明，又不会导致所有类型声明都变为模块内的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"可以看到很多 dts 都这样引入别的 dts 的，就是为了保证引入的类型声明依然是全局的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"TypeScript 给 JavaScript 添加了类型信息，在编译时做类型检查。"}),"\n",(0,c.jsx)(n.p,{children:"除了在变量声明时定义类型外，TS 也支持通过 declare 单独声明类型。只存放类型声明的文件后缀是 d.ts。"}),"\n",(0,c.jsx)(n.p,{children:"TypeScript 有三种存放类型声明的地方："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"lib： 内置的类型声明，包含 dom 和 es 的，因为这俩都是有标准的。"}),"\n",(0,c.jsx)(n.li,{children:"@types/xx： 其他环境的 api 类型声明，比如 node，还有 npm 包的类型声明"}),"\n",(0,c.jsx)(n.li,{children:"开发者写的代码：通过 include + exclude 还有 files 指定"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"其中，npm 包也可以同时存放 ts 类型，通过 packages.json 的 types 字段指定路径即可。"}),"\n",(0,c.jsx)(n.p,{children:"常见的是 vue 的类型是存放在 npm 包下的，而 react 的类型是在 @types/react 里的。因为源码一个是 ts 写的，一个不是。"}),"\n",(0,c.jsx)(n.p,{children:"巧合的是，TS 声明模块的方式也是三种："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"namespace：最早的实现模块的方式，编译为声明对象和设置对象的属性的 JS 代码，很容易理解"}),"\n",(0,c.jsx)(n.li,{children:"module：和 namespace 的 AST 没有任何区别，只不过一般用来声明 CommonJS 的模块，在 @types/node 下有很多"}),"\n",(0,c.jsx)(n.li,{children:"es module：es 标准的模块语法，ts 额外扩展了 import type"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"dts 的类型声明默认是全局的，除非有 es module 的 import、export 的声明，这时候就要手动 declare global 了。为了避免这种情况，可以用 reference 的编译器指令。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"学习类型定义是怎么给 JS 加上类型，学习类型编程是怎么动态生成类型和对类型做修改，这些类型可能会通过模块或全局的方式来组织，所以还需要学习模块语法，而且可能会放在 lib、@types/xxx、用户目录等位置，还要学习不同来源的类型的查找机制。"})}),"\n",(0,c.jsx)(n.p,{children:"深入掌握 TypeScript 的话，除了学习类型定义以及类型编程，这三种类型声明的来源（lib、@types、用户目录），以及三种模块声明的方式（namespace、module、es module），还有全局类型的声明（global、reference），也都是要掌握的。"})]})}function Q(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(O,{...e})}):O(e)}let X=Q;Q.__RSPRESS_PAGE_META={},Q.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F23.%E5%8A%A0%E9%A4%90%EF%BC%9A3%20%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%9D%A5%E6%BA%90%E5%92%8C%203%20%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95.md"]={toc:[{text:"TypeScript 类型声明的三种来源",id:"typescript-类型声明的三种来源",depth:2},{text:"全局类型声明 vs 模块类型声明",id:"全局类型声明-vs-模块类型声明",depth:2},{text:"总结",id:"总结",depth:2}],title:"23.加餐：3 种类型来源和 3 种模块语法",headingTitle:"23.加餐：3 种类型来源和 3 种模块语法",frontmatter:{}}}}]);