"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["93533"],{358920:function(e,n,s){s.r(n),s.d(n,{default:()=>i});var o=s(552676),c=s(740453);let t=s.p+"static/image/43a904df7ea5e7be6917c9fb41f8261d.f18c78e5.webp",d=s.p+"static/image/fba50d46ed72696262767d2cf8348eb1.b494dc8f.webp";function r(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",pre:"pre",code:"code",ol:"ol",li:"li",img:"img"},(0,c.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.h1,{id:"14编译器js-ast-是如何生成渲染函数的",children:["14.编译器：JS AST 是如何生成渲染函数的？",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14编译器js-ast-是如何生成渲染函数的",children:"#"})]}),"\n",(0,o.jsxs)(n.h2,{id:"前言",children:["前言",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["本小节，我们将进入模版编译的最后一步：",(0,o.jsx)(n.strong,{children:"代码生成器 genetate"}),"。"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"generate(\n  ast,\n  extend({}, options, {\n    prefixIdentifiers\n  })\n)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["一起来看一下 ",(0,o.jsx)(n.code,{children:"generate"})," 的核心实现："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export function generate(ast, options = {}) {\n  // 创建代码生成上下文\n  const context = createCodegenContext(ast, options)\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context\n\n  const hasHelpers = ast.helpers.length > 0\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\n  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'\n  const isSetupInlined = !__BROWSER__ && !!options.inline\n  \n  // 生成预设代码\n  const preambleContext = isSetupInlined\n    ? createCodegenContext(ast, options)\n    : context\n  // 不在浏览器的环境且 mode 是 module   \n  if (!__BROWSER__ && mode === 'module') {\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\n  } else {\n    genFunctionPreamble(ast, preambleContext)\n  }\n  // 进入 render 函数构造\n  const functionName = `render`\n  const args = ['_ctx', '_cache']\n \n  const signature = args.join(', ')\n  \n  push(`function ${functionName}(${signature}) {`)\n  \n  indent()\n\n  if (useWithBlock) {\n    // 处理带 with 的情况，Web 端运行时编译\n    push(`with (_ctx) {`)\n    indent()\n    if (hasHelpers) {\n      push(`const { ${ast.helpers.map(aliasHelper).join(', ')} } = _Vue`)\n      push(`\\n`)\n      newline()\n    }\n  }\n  \n  // 生成自定义组件声明代码\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context)\n    if (ast.directives.length || ast.temps > 0) {\n      newline()\n    }\n  }\n  // 生成自定义指令声明代码\n  if (ast.directives.length) {\n    genAssets(ast.directives, 'directive', context)\n    if (ast.temps > 0) {\n      newline()\n    }\n  }\n  // 生成临时变量代码\n  if (ast.temps > 0) {\n    push(`let `)\n    for (let i = 0; i < ast.temps; i++) {\n      push(`${i > 0 ? `, ` : ``}_temp${i}`)\n    }\n  }\n  if (ast.components.length || ast.directives.length || ast.temps) {\n    push(`\\n`)\n    newline()\n  }\n\n  if (!ssr) {\n    push(`return `)\n  }\n  \n  // 生成创建 VNode 树的表达式\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context)\n  } else {\n    push(`null`)\n  }\n\n  if (useWithBlock) {\n    deindent()\n    push(`}`)\n  }\n\n  deindent()\n  push(`}`)\n\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    map: context.map ? (context.map as any).toJSON() : undefined\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["这个函数看起来有点复杂，我们先来简单了解一下：",(0,o.jsx)(n.code,{children:"generate"})," 函数，接收两个参数，分别是经过转换器处理的 ",(0,o.jsx)(n.code,{children:"ast"})," 抽象语法树，以及 ",(0,o.jsx)(n.code,{children:"options"})," 代码生成选项。最终返回一个 ",(0,o.jsx)(n.code,{children:"CodegenResult"})," 类型的对象："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"return {\n  ast, // 抽象语法树\n  code, // render 函数代码字符串\n  preamble, // 代码字符串的前置部分\n  map, //可选的 sourceMap\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"接下来开始深入了解一下该函数的核心功能。"}),"\n",(0,o.jsxs)(n.h2,{id:"1-创建代码生成上下文",children:["1. 创建代码生成上下文",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-创建代码生成上下文",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"generate"})," 函数的第一步是通过 ",(0,o.jsx)(n.code,{children:"createCodegenContext"})," 来创建 ",(0,o.jsx)(n.code,{children:"CodegenContext"})," 上下文对象。一起来看一下其核心实现："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeBindings = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {\n  const context = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    scopeId,\n    optimizeBindings,\n    runtimeGlobalName,\n    runtimeModuleName,\n    ssr,\n    source: ast.loc.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n    pure: false,\n    map: undefined,\n    helper(key) {\n      return `_${helperNameMap[key]}`\n    },\n    push(code) {\n      context.code += code\n      // ... 省略 非浏览器环境下的 addMapping\n    },\n    indent() {\n      newline(++context.indentLevel)\n    },\n    deindent(withoutNewLine = false) {\n      if (withoutNewLine) {\n        --context.indentLevel\n      }\n      else {\n        newline(--context.indentLevel)\n      }\n    },\n    newline() {\n      newline(context.indentLevel)\n    }\n  }\n  function newline(n) {\n    context.push('\\n' + `  `.repeat(n))\n  }\n  return context\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["可以看出 ",(0,o.jsx)(n.code,{children:"createCodegenContext"})," 创建的 ",(0,o.jsx)(n.code,{children:"context"})," 中，核心维护了一些基础配置变量和一些工具函数，我们来看几个比较常用的函数："]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"push"}),"：该函数的功能是将传入的字符串拼接入上下文中的 ",(0,o.jsx)(n.code,{children:"code"})," 属性中。并且会生成对应的 ",(0,o.jsx)(n.code,{children:"sourceMap"}),"。"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"indent"}),": 作用是缩进"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"deindent"}),": 回退缩进"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"newline"}),": 插入新的一行"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["其中，",(0,o.jsx)(n.code,{children:"index"}),"、",(0,o.jsx)(n.code,{children:"deindent"}),"、",(0,o.jsx)(n.code,{children:"newline"})," 是用来辅助生成的代码字符串，用来格式化结构，让生成的代码字符串非常直观，就像在 ",(0,o.jsx)(n.code,{children:"ide"})," 中敲入的制表符、换行、格式化代码块一样。"]}),"\n",(0,o.jsx)(n.p,{children:"在创建上下文变量完成后，接着进入生成预设代码的流程："}),"\n",(0,o.jsxs)(n.h2,{id:"2-生成预设代码",children:["2. 生成预设代码",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-生成预设代码",children:"#"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"// 不在浏览器的环境且 mode 是 module\nif (!__BROWSER__ && mode === 'module') {\n  // 使用 ES module 标准的 import 来导入 helper 的辅助函数，处理生成代码的前置部分\n  genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\n} else {\n  // 否则生成的代码前置部分是一个单一的 const { helpers... } = Vue 处理代码前置部分\n  genFunctionPreamble(ast, preambleContext)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"mode"})," 有两个选项:"]}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"module"}),": 会通过 ",(0,o.jsx)(n.code,{children:"ES module"})," 的 ",(0,o.jsx)(n.code,{children:"import"})," 来导入 ",(0,o.jsx)(n.code,{children:"ast"})," 中的 ",(0,o.jsx)(n.code,{children:"helpers"})," 辅助函数，并用 ",(0,o.jsx)(n.code,{children:"export"})," 默认导出 ",(0,o.jsx)(n.code,{children:"render"})," 函数。"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"function"})," 时，就会生成一个单一的\xa0",(0,o.jsx)(n.code,{children:"const { helpers... } = Vue"}),"\xa0声明，并且 ",(0,o.jsx)(n.code,{children:"return"})," 返回 ",(0,o.jsx)(n.code,{children:"render"})," 函数。"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["先看一下 ",(0,o.jsx)(n.code,{children:"genModulePreamble"})," 的实现："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"function genModulePreamble(ast, context, genScopeId, inline) {\n  const {\n    push,\n    newline,\n    optimizeImports,\n    runtimeModuleName,\n    ssrRuntimeModuleName\n  } = context\n  \n  // ...\n\n  if (ast.helpers.length) {\n    if (optimizeImports) {\n      // 生成 import 声明代码\n      push(\n        `import { ${ast.helpers\n          .map(s => helperNameMap[s])\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\n      )\n      push(\n        `\\n// Binding optimization for webpack code-split\\nconst ${ast.helpers\n          .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)\n          .join(', ')}\\n`\n      )\n    } else {\n      push(\n        `import { ${ast.helpers\n          .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\n      )\n    }\n  }\n  // 提升静态节点\n  genHoists(ast.hoists, context)\n  newline()\n\n  if (!inline) {\n    push(`export `)\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["其中 ",(0,o.jsx)(n.code,{children:"ast.helpers"})," 是在 ",(0,o.jsx)(n.code,{children:"transform"})," 阶段通过 ",(0,o.jsx)(n.code,{children:"context.helper"})," 方法添加的，它的值如下："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"[\n  Symbol(resolveComponent),\n  Symbol(createVNode),\n  Symbol(createCommentVNode),\n  Symbol(toDisplayString),\n  Symbol(openBlock),\n  Symbol(createBlock)\n]\n"})}),"\n",(0,o.jsx)(n.p,{children:"所以这一步结束后，得到的代码为"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n'})}),"\n",(0,o.jsxs)(n.p,{children:["然后执行 ",(0,o.jsx)(n.code,{children:"genHoists"})," ："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function genHoists(hoists, context) {\n  if (!hoists.length) {\n    return\n  }\n  context.pure = true\n  const { push, newline } = context\n  \n  newline()\n  hoists.forEach((exp, i) => {\n    if (exp) {\n      push(`const _hoisted_${i + 1} = `)\n      genNode(exp, context)\n      newline()\n    }\n  })\n  \n  context.pure = false\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["核心功能就是遍历 ",(0,o.jsx)(n.code,{children:"ast.hoists"})," 数组，该数组是我们在 ",(0,o.jsx)(n.code,{children:"transfrom"})," 的时候构造的，然生成静态提升变量定义的方法。在进行 ",(0,o.jsx)(n.code,{children:"hoists"})," 数组遍历的时候，这里有个 ",(0,o.jsx)(n.code,{children:"geNode"})," 函数，是用来生成节点的创建字符串的，一起来看一下其实现："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function genNode(node, context) {\n  if (isString(node)) {\n    context.push(node)\n    return\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node))\n    return\n  }\n  // 根据 node 节点类型不同，调用不同的生成函数\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      genNode(node.codegenNode!, context)\n      break\n    case NodeTypes.TEXT:\n      genText(node, context)\n      break\n    case NodeTypes.SIMPLE_EXPRESSION:\n      genExpression(node, context)\n      break\n    case NodeTypes.INTERPOLATION:\n      genInterpolation(node, context)\n      break\n    case NodeTypes.TEXT_CALL:\n      genNode(node.codegenNode, context)\n      break\n    case NodeTypes.COMPOUND_EXPRESSION:\n      genCompoundExpression(node, context)\n      break\n    case NodeTypes.COMMENT:\n      genComment(node, context)\n      break\n    case NodeTypes.VNODE_CALL:\n      genVNodeCall(node, context)\n      break\n\n    case NodeTypes.JS_CALL_EXPRESSION:\n      genCallExpression(node, context)\n      break\n    case NodeTypes.JS_OBJECT_EXPRESSION:\n      genObjectExpression(node, context)\n      break\n    case NodeTypes.JS_ARRAY_EXPRESSION:\n      genArrayExpression(node, context)\n      break\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\n      genFunctionExpression(node, context)\n      break\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\n      genConditionalExpression(node, context)\n      break\n    case NodeTypes.JS_CACHE_EXPRESSION:\n      genCacheExpression(node, context)\n      break\n    case NodeTypes.JS_BLOCK_STATEMENT:\n      genNodeList(node.body, context, true, false)\n      break\n\n    /* istanbul ignore next */\n    case NodeTypes.IF_BRANCH:\n      // noop\n      break\n    default:\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["根据上一小节的 ",(0,o.jsx)(n.code,{children:"demo"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>hello world</p>\n  <p>{{ msg }}</p>\n</template>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["我们经过 ",(0,o.jsx)(n.code,{children:"transform"})," 后得到的 ",(0,o.jsx)(n.code,{children:"AST"})," 内容大致如下："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,o.jsxs)(n.p,{children:["其中 ",(0,o.jsx)(n.code,{children:"hoists"})," 内容中存储的是 ",(0,o.jsx)(n.code,{children:"<p>hello world</p>"})," 节点的信息，其中 ",(0,o.jsx)(n.code,{children:"type = 13"})," 表示的是 ",(0,o.jsx)(n.code,{children:"VNODE_CALL"})," 类型，进入 ",(0,o.jsx)(n.code,{children:"genVNodeCall"})," 函数中："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function genVNodeCall(node, context) {\n  const { push, helper, pure } = context\n  const {\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent\n  } = node\n  if (directives) {\n    push(helper(WITH_DIRECTIVES) + `(`)\n  }\n  if (isBlock) {\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)\n  }\n  if (pure) {\n    push(PURE_ANNOTATION)\n  }\n  const callHelper = isBlock\n    ? getVNodeBlockHelper(context.inSSR, isComponent)\n    : getVNodeHelper(context.inSSR, isComponent)\n  push(helper(callHelper) + `(`, node)\n  genNodeList(\n    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),\n    context\n  )\n  push(`)`)\n  if (isBlock) {\n    push(`)`)\n  }\n  if (directives) {\n    push(`, `)\n    genNode(directives, context)\n    push(`)`)\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["在执行 ",(0,o.jsx)(n.code,{children:"genVNodeCall"})," 函数时，因为 ",(0,o.jsx)(n.code,{children:"directives"})," 不存在，",(0,o.jsx)(n.code,{children:"isBlock = false"})," 此时我们生成的代码内容如下"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, "hello world", -1 /* HOISTED */)\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"genModulePreamble"})," 函数的最后，执行 ",(0,o.jsx)(n.code,{children:"push('export')"})," 完成 ",(0,o.jsx)(n.code,{children:"genModulePreamble"})," 的所有逻辑，得到以下内容："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, "hello world", -1 /* HOISTED */)\n\nexport\n'})}),"\n",(0,o.jsxs)(n.p,{children:["然后再看一下 ",(0,o.jsx)(n.code,{children:"genFunctionPreamble"})," 函数，该函数的功能和 ",(0,o.jsx)(n.code,{children:"genModulePreamble"})," 类似，就不再赘述，直接来看一下生成的结果："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'const _Vue = Vue\nconst { createElementVNode: _createElementVNode } = _Vue\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, "hello world", -1 /* HOISTED */)\n\nreturn \n'})}),"\n",(0,o.jsxs)(n.p,{children:["要注意以上代码仅仅是代码前置部分，还没有开始解析其他资源和节点，所以仅仅是到了 ",(0,o.jsx)(n.code,{children:"export"})," 或者 ",(0,o.jsx)(n.code,{children:"return"})," 就结束了。"]}),"\n",(0,o.jsxs)(n.h2,{id:"2-生成渲染函数",children:["2. 生成渲染函数",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-生成渲染函数",children:"#"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// 进入 render 函数构造\nconst functionName = `render`\nconst args = ['_ctx', '_cache']\n\nconst signature = args.join(', ')\n\npush(`function ${functionName}(${signature}) {`)\n\nindent()\n"})}),"\n",(0,o.jsxs)(n.p,{children:["这些代码还是比较好理解的，核心也是在通过 ",(0,o.jsx)(n.code,{children:"push"})," 函数，继续生成 ",(0,o.jsx)(n.code,{children:"code"})," 字符串，看一下经过这个步骤后，我们的代码字符串变成的内容："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, "hello world", -1 /* HOISTED */)\n\nexport function render(_ctx, _cache) {\n'})}),"\n",(0,o.jsxs)(n.p,{children:["到这里，后面的内容也就不言而喻了，就是生成 ",(0,o.jsx)(n.code,{children:"render"})," 函数的主题内容代码，我们先忽略对 ",(0,o.jsx)(n.code,{children:"components"}),"、",(0,o.jsx)(n.code,{children:"directives"}),"、",(0,o.jsx)(n.code,{children:"temps"})," 代码块的生成，有兴趣的可以在源码里面调试打印。"]}),"\n",(0,o.jsxs)(n.p,{children:["我们知道之前的 ",(0,o.jsx)(n.code,{children:"transform"})," 在处理节点内容时，会生成 ",(0,o.jsx)(n.code,{children:"codegenNode"})," 对象，这个对象就是在这里被使用转换成代码字符串的："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"if (ast.codegenNode) {\n  genNode(ast.codegenNode, context)\n} else {\n  push(`null`)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["上面的例子中，我们生产的模版节点的 ",(0,o.jsx)(n.code,{children:"codegenNode"})," 内容如下："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,o.jsxs)(n.p,{children:["其中 ",(0,o.jsx)(n.code,{children:"type = 13"})," 表示的是 ",(0,o.jsx)(n.code,{children:"VNODE_CALL"})," 类型，也进入 ",(0,o.jsx)(n.code,{children:"genVNodeCall"})," 函数中，这里需要注意的是，因为我们 ",(0,o.jsx)(n.code,{children:"template"})," 下包含了 2 个同级的标签，所以在 ",(0,o.jsx)(n.code,{children:"transform"})," 阶段会创建一个 ",(0,o.jsx)(n.code,{children:"patchFlag = STABLE_FRAGMENT"})," 这样一个根 ",(0,o.jsx)(n.code,{children:"fragment"})," 的 ",(0,o.jsx)(n.code,{children:"ast"})," 节点来包含 2 个 ",(0,o.jsx)(n.code,{children:"p"})," 标签节点。"]}),"\n",(0,o.jsxs)(n.p,{children:["针对我们上面的示例，",(0,o.jsx)(n.code,{children:"directives"})," 没有，",(0,o.jsx)(n.code,{children:"isBlock"})," 是 ",(0,o.jsx)(n.code,{children:"true"}),"。那么经过 ",(0,o.jsx)(n.code,{children:"genVNodeCall"})," 后生成的代码如下："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, "hello world", -1 /* HOISTED */)\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(_Fragment, null, [\n    _hoisted_1,\n    _createElementVNode("p", null, _toDisplayString(msg), 1 /* TEXT */)\n  ], 64 /* STABLE_FRAGMENT */))\n'})}),"\n",(0,o.jsxs)(n.p,{children:["那么至此，根节点 ",(0,o.jsx)(n.code,{children:"vnode"})," 树的表达式就创建好了。我们再回到 ",(0,o.jsx)(n.code,{children:"generate"})," 函数，",(0,o.jsx)(n.code,{children:"generate"})," 函数的最后就是添加右括号 ",(0,o.jsx)(n.code,{children:"}"})," 来闭合渲染函数，最终生成如下代码："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:'import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nconst _hoisted_1 = /*#__PURE__*/_createElementVNode("p", null, "hello world", -1 /* HOISTED */)\n\nexport function render(_ctx, _cache) {\n  return (_openBlock(), _createElementBlock(_Fragment, null, [\n    _hoisted_1,\n    _createElementVNode("p", null, _toDisplayString(msg), 1 /* TEXT */)\n  ], 64 /* STABLE_FRAGMENT */))\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["通过上述流程我们大致清楚了 ",(0,o.jsx)(n.code,{children:"generate"})," 是 ",(0,o.jsx)(n.code,{children:"compile"})," 阶段的最后一步，它的作用是将 ",(0,o.jsx)(n.code,{children:"transform"})," 转换后的 ",(0,o.jsx)(n.code,{children:"AST"})," 生成对应的可执行代码，从而在之后 ",(0,o.jsx)(n.code,{children:"Runtime"})," 的 ",(0,o.jsx)(n.code,{children:"Render"})," 阶段时，就可以通过可执行代码生成对应的 ",(0,o.jsx)(n.code,{children:"VNode Tree"}),"，然后最终映射为真实的 ",(0,o.jsx)(n.code,{children:"DOM Tree"})," 在页面上。其中我们也省略了一些细节的介绍，但整体流程还是很容易理解的。"]}),"\n",(0,o.jsxs)(n.h2,{id:"总结",children:["总结",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["这里我们花了三个小节，为大家整体介绍了一个模版字符串是如何一步步的编译成 ",(0,o.jsx)(n.code,{children:"render"})," 函数的。"]}),"\n",(0,o.jsxs)(n.p,{children:["我们知道 ",(0,o.jsx)(n.code,{children:"Vue"})," 相对于 ",(0,o.jsx)(n.code,{children:"React"})," 的不同之处也是其支持 ",(0,o.jsx)(n.code,{children:"<template>"})," 模版字符串的写法，虽然最终也是会被编译成渲染函数，也正是因为这个特性，可以让 ",(0,o.jsx)(n.code,{children:"Vue"})," 可以在编译成渲染函数的期间做很多优化的事情。那到底做了哪些优化呢？我们下一章节接着介绍！"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(r,{...e})}):r(e)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F14.%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9AJS%20AST%20%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. 创建代码生成上下文",id:"1-创建代码生成上下文",depth:2},{text:"2. 生成预设代码",id:"2-生成预设代码",depth:2},{text:"2. 生成渲染函数",id:"2-生成渲染函数",depth:2},{text:"总结",id:"总结",depth:2}],title:"14.编译器：JS AST 是如何生成渲染函数的？",headingTitle:"14.编译器：JS AST 是如何生成渲染函数的？",frontmatter:{}}}}]);