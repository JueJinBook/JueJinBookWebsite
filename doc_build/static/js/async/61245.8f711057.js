"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["61245"],{655035:function(e,n,i){i.r(n),i.d(n,{default:()=>a});var r=i(552676),s=i(740453);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"5应用-4四两拨千斤--hyperloglog",children:["5应用 4：四两拨千斤 —— HyperLogLog",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5应用-4四两拨千斤--hyperloglog",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在开始这一节之前，我们先思考一个常见的业务问题：如果你负责开发维护一个大型的网站，有一天老板找产品经理要网站每个网页每天的 UV 数据，然后让你来开发这个统计模块，你会如何实现？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/12/1648f065e38200cb?w=400&h=128&f=gif&s=250971",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果统计 PV 那非常好办，给每个网页一个独立的 Redis 计数器就可以了，这个计数器的 key 后缀加上当天的日期。这样来一个请求，incrby 一次，最终就可以统计出所有的 PV 数据。"}),"\n",(0,r.jsx)(n.p,{children:"但是 UV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 ID，无论是登陆用户还是未登陆用户都需要一个唯一 ID 来标识。"}),"\n",(0,r.jsx)(n.p,{children:"你也许已经想到了一个简单的方案，那就是为每一个页面一个独立的 set 集合来存储所有当天访问过此页面的用户 ID。当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可以了。通过 scard 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。没错，这是一个非常简单的方案。"}),"\n",(0,r.jsx)(n.p,{children:"但是，如果你的页面访问量非常大，比如一个爆款页面几千万的 UV，你需要一个很大的 set 集合来统计，这就非常浪费空间。如果这样的页面很多，那所需要的存储空间是惊人的。为这样一个去重功能就耗费这样多的存储空间，值得么？其实老板需要的数据又不需要太精确，105w 和 106w 这两个数字对于老板们来说并没有多大区别，So，有没有更好的解决方案呢？"}),"\n",(0,r.jsx)(n.p,{children:"这就是本节要引入的一个解决方案，Redis 提供了 HyperLogLog 数据结构就是用来解决这种统计问题的。HyperLogLog 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是 0.81%，这样的精确度已经可以满足上面的 UV 统计需求了。"}),"\n",(0,r.jsx)(n.p,{children:"HyperLogLog 数据结构是 Redis 的高级数据结构，它非常有用，但是令人感到意外的是，使用过它的人非常少。"}),"\n",(0,r.jsxs)(n.h2,{id:"使用方法",children:["使用方法",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用方法",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"HyperLogLog 提供了两个指令 pfadd 和 pfcount，根据字面意义很好理解，一个是增加计数，一个是获取计数。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用户 ID 塞进去就是。pfcount 和 scard 用法是一样的，直接获取计数值。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"127.0.0.1:6379> pfadd codehole user1\n(integer) 1\n127.0.0.1:6379> pfcount codehole\n(integer) 1\n127.0.0.1:6379> pfadd codehole user2\n(integer) 1\n127.0.0.1:6379> pfcount codehole\n(integer) 2\n127.0.0.1:6379> pfadd codehole user3\n(integer) 1\n127.0.0.1:6379> pfcount codehole\n(integer) 3\n127.0.0.1:6379> pfadd codehole user4\n(integer) 1\n127.0.0.1:6379> pfcount codehole\n(integer) 4\n127.0.0.1:6379> pfadd codehole user5\n(integer) 1\n127.0.0.1:6379> pfcount codehole\n(integer) 5\n127.0.0.1:6379> pfadd codehole user6\n(integer) 1\n127.0.0.1:6379> pfcount codehole\n(integer) 6\n127.0.0.1:6379> pfadd codehole user7 user8 user9 user10\n(integer) 1\n127.0.0.1:6379> pfcount codehole\n(integer) 10\n"})}),"\n",(0,r.jsx)(n.p,{children:"简单试了一下，发现还蛮精确的，一个没多也一个没少。接下来我们使用脚本，往里面灌更多的数据，看看它是否还可以继续精确下去，如果不能精确，差距有多大。人生苦短，我用 Python！Python 脚本走起来！\uD83D\uDE04"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:'# coding: utf-8\n\nimport redis\n\nclient = redis.StrictRedis()\nfor i in range(1000):\n    client.pfadd("codehole", "user%d" % i)\n    total = client.pfcount("codehole")\n    if total != i+1:\n        print total, i+1\n        break\n'})}),"\n",(0,r.jsx)(n.p,{children:"当然 Java 也不错，大同小异，下面是 Java 版本："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class PfTest {\n  public static void main(String[] args) {\n    Jedis jedis = new Jedis();\n    for (int i = 0; i < 1000; i++) {\n      jedis.pfadd("codehole", "user" + i);\n      long total = jedis.pfcount("codehole");\n      if (total != i + 1) {\n        System.out.printf("%d %d\\n", total, i + 1);\n        break;\n      }\n    }\n    jedis.close();\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"我们来看下输出："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> python pftest.py\n99 100\n"})}),"\n",(0,r.jsx)(n.p,{children:"当我们加入第 100 个元素时，结果开始出现了不一致。接下来我们将数据增加到 10w 个，看看总量差距有多大。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'# coding: utf-8\n\nimport redis\n\nclient = redis.StrictRedis()\nfor i in range(100000):\n    client.pfadd("codehole", "user%d" % i)\nprint 100000, client.pfcount("codehole")\n'})}),"\n",(0,r.jsx)(n.p,{children:"Java 版："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class JedisTest {\n  public static void main(String[] args) {\n    Jedis jedis = new Jedis();\n    for (int i = 0; i < 100000; i++) {\n      jedis.pfadd("codehole", "user" + i);\n    }\n    long total = jedis.pfcount("codehole");\n    System.out.printf("%d %d\\n", 100000, total);\n    jedis.close();\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"跑了约半分钟，我们看输出："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"> python pftest.py\n100000 99723\n"})}),"\n",(0,r.jsx)(n.p,{children:"差了 277 个，按百分比是 0.277%，对于上面的 UV 统计需求来说，误差率也不算高。然后我们把上面的脚本再跑一边，也就相当于将数据重复加入一边，查看输出，可以发现，pfcount 的结果没有任何改变，还是 99723，说明它确实具备去重功能。"}),"\n",(0,r.jsxs)(n.h2,{id:"pfadd-这个-pf-是什么意思",children:["pfadd 这个 pf 是什么意思？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pfadd-这个-pf-是什么意思",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"它是 HyperLogLog 这个数据结构的发明人 Philippe Flajolet 的首字母缩写，老师觉得他发型很酷，看起来是个佛系教授。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/12/1648f09fa1a77152?w=300&h=242&f=jpeg&s=24061",alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"pfmerge-适合什么场合用",children:["pfmerge 适合什么场合用？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pfmerge-适合什么场合用",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"HyperLogLog 除了上面的 pfadd 和 pfcount 之外，还提供了第三个指令 pfmerge，用于将多个 pf 计数值累加在一起形成一个新的 pf 值。"}),"\n",(0,r.jsx)(n.p,{children:"比如在网站中我们有两个内容差不多的页面，运营说需要这两个页面的数据进行合并。其中页面的 UV 访问量也需要合并，那这个时候 pfmerge 就可以派上用场了。"}),"\n",(0,r.jsxs)(n.h2,{id:"注意事项",children:["注意事项",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#注意事项",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"HyperLogLog 这个数据结构不是免费的，不是说使用这个数据结构要花钱，它需要占据一定 12k 的存储空间，所以它不适合统计单个用户相关的数据。如果你的用户上亿，可以算算，这个空间成本是非常惊人的。但是相比 set 存储方案，HyperLogLog 所使用的空间那真是可以使用千斤对比四两来形容了。"}),"\n",(0,r.jsx)(n.p,{children:"不过你也不必过于担心，因为 Redis 对 HyperLogLog 的存储进行了优化，在计数比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，才会占用 12k 的空间。"}),"\n",(0,r.jsxs)(n.h2,{id:"hyperloglog-实现原理",children:["HyperLogLog 实现原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#hyperloglog-实现原理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"HyperLogLog 的使用非常简单，但是实现原理比较复杂，如果读者没有特别的兴趣，下面的内容暂时可以跳过不看。"}),"\n",(0,r.jsx)(n.p,{children:"为了方便理解 HyperLogLog 的内部实现原理，我画了下面这张图"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/12/1648f0af2621881b?w=1102&h=692&f=png&s=53467",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这张图的意思是，给定一系列的随机整数，我们记录下低位连续零位的最大长度 k，通过这个 k 值可以估算出随机数的数量。\n首先不问为什么，我们编写代码做一个实验，观察一下随机整数的数量和 k 值的关系。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"import math\nimport random\n\n# 算低位零的个数\ndef low_zeros(value):\n    for i in xrange(1, 32):\n        if value >> i << i != value:\n            break\n    return i - 1\n\n\n# 通过随机数记录最大的低位零的个数\nclass BitKeeper(object):\n\n    def __init__(self):\n        self.maxbits = 0\n\n    def random(self):\n        value = random.randint(0, 2**32-1)\n        bits = low_zeros(value)\n        if bits > self.maxbits:\n            self.maxbits = bits\n\n\nclass Experiment(object):\n\n    def __init__(self, n):\n        self.n = n\n        self.keeper = BitKeeper()\n\n    def do(self):\n        for i in range(self.n):\n            self.keeper.random()\n\n    def debug(self):\n        print self.n, '%.2f' % math.log(self.n, 2), self.keeper.maxbits\n\n\nfor i in range(1000, 100000, 100):\n    exp = Experiment(i)\n    exp.do()\n    exp.debug()\n"})}),"\n",(0,r.jsx)(n.p,{children:"Java 版："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class PfTest {\n\n  static class BitKeeper {\n    private int maxbits;\n\n    public void random() {\n      long value = ThreadLocalRandom.current().nextLong(2L << 32);\n      int bits = lowZeros(value);\n      if (bits > this.maxbits) {\n        this.maxbits = bits;\n      }\n    }\n\n    private int lowZeros(long value) {\n      int i = 1;\n      for (; i < 32; i++) {\n        if (value >> i << i != value) {\n          break;\n        }\n      }\n      return i - 1;\n    }\n  }\n\n  static class Experiment {\n    private int n;\n    private BitKeeper keeper;\n\n    public Experiment(int n) {\n      this.n = n;\n      this.keeper = new BitKeeper();\n    }\n\n    public void work() {\n      for (int i = 0; i < n; i++) {\n        this.keeper.random();\n      }\n    }\n\n    public void debug() {\n      System.out.printf("%d %.2f %d\\n", this.n, Math.log(this.n) / Math.log(2), this.keeper.maxbits);\n    }\n  }\n\n  public static void main(String[] args) {\n    for (int i = 1000; i < 100000; i += 100) {\n      Experiment exp = new Experiment(i);\n      exp.work();\n      exp.debug();\n    }\n  }\n\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"运行观察输出："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"36400 15.15 13\n36500 15.16 16\n36600 15.16 13\n36700 15.16 14\n36800 15.17 15\n36900 15.17 18\n37000 15.18 16\n37100 15.18 15\n37200 15.18 13\n37300 15.19 14\n37400 15.19 16\n37500 15.19 14\n37600 15.20 15\n"})}),"\n",(0,r.jsx)(n.p,{children:"通过这实验可以发现 K 和 N 的对数之间存在显著的线性相关性："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"N=2^K  # 约等于\n"})}),"\n",(0,r.jsx)(n.p,{children:"如果 N 介于 2^K 和 2^(K+1) 之间，用这种方式估计的值都等于 2^K，这明显是不合理的。这里可以采用多个 BitKeeper，然后进行加权估计，就可以得到一个比较准确的值。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-py",children:"import math\nimport random\n\ndef low_zeros(value):\n    for i in xrange(1, 32):\n        if value >> i << i != value:\n            break\n    return i - 1\n\n\nclass BitKeeper(object):\n\n    def __init__(self):\n        self.maxbits = 0\n\n    def random(self, m):\n        bits = low_zeros(m)\n        if bits > self.maxbits:\n            self.maxbits = bits\n\n\nclass Experiment(object):\n\n    def __init__(self, n, k=1024):\n        self.n = n\n        self.k = k\n        self.keepers = [BitKeeper() for i in range(k)]\n\n    def do(self):\n        for i in range(self.n):\n            m = random.randint(0, 1<<32-1)\n            # 确保同一个整数被分配到同一个桶里面，摘取高位后取模\n            keeper = self.keepers[((m & 0xfff0000) >> 16) % len(self.keepers)]\n            keeper.random(m)\n\n    def estimate(self):\n        sumbits_inverse = 0  # 零位数倒数\n        for keeper in self.keepers:\n            sumbits_inverse += 1.0/float(keeper.maxbits)\n        avgbits = float(self.k)/sumbits_inverse  # 平均零位数\n        return 2**avgbits * self.k  # 根据桶的数量对估计值进行放大\n\n\nfor i in range(100000, 1000000, 100000):\n    exp = Experiment(i)\n    exp.do()\n    est = exp.estimate()\n    print i, '%.2f' % est, '%.2f' % (abs(est-i) / i)\n"})}),"\n",(0,r.jsx)(n.p,{children:"下面是 Java 版："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class PfTest {\n\n  static class BitKeeper {\n    private int maxbits;\n\n    public void random(long value) {\n      int bits = lowZeros(value);\n      if (bits > this.maxbits) {\n        this.maxbits = bits;\n      }\n    }\n\n    private int lowZeros(long value) {\n      int i = 1;\n      for (; i < 32; i++) {\n        if (value >> i << i != value) {\n          break;\n        }\n      }\n      return i - 1;\n    }\n  }\n\n  static class Experiment {\n    private int n;\n    private int k;\n    private BitKeeper[] keepers;\n\n    public Experiment(int n) {\n      this(n, 1024);\n    }\n\n    public Experiment(int n, int k) {\n      this.n = n;\n      this.k = k;\n      this.keepers = new BitKeeper[k];\n      for (int i = 0; i < k; i++) {\n        this.keepers[i] = new BitKeeper();\n      }\n    }\n\n    public void work() {\n      for (int i = 0; i < this.n; i++) {\n        long m = ThreadLocalRandom.current().nextLong(1L << 32);\n        BitKeeper keeper = keepers[(int) (((m & 0xfff0000) >> 16) % keepers.length)];\n        keeper.random(m);\n      }\n    }\n\n    public double estimate() {\n      double sumbitsInverse = 0.0;\n      for (BitKeeper keeper : keepers) {\n        sumbitsInverse += 1.0 / (float) keeper.maxbits;\n      }\n      double avgBits = (float) keepers.length / sumbitsInverse;\n      return Math.pow(2, avgBits) * this.k;\n    }\n  }\n\n  public static void main(String[] args) {\n    for (int i = 100000; i < 1000000; i += 100000) {\n      Experiment exp = new Experiment(i);\n      exp.work();\n      double est = exp.estimate();\n      System.out.printf("%d %.2f %.2f\\n", i, est, Math.abs(est - i) / i);\n    }\n  }\n\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"代码中分了 1024 个桶，计算平均数使用了调和平均 (倒数的平均)。普通的平均法可能因为个别离群值对平均结果产生较大的影响，调和平均可以有效平滑离群值的影响。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/7/12/1648f0fa8841ceb1?w=565&h=171&f=png&s=14049",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"观察脚本的输出，误差率控制在百分比个位数："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"100000 97287.38 0.03\n200000 189369.02 0.05\n300000 287770.04 0.04\n400000 401233.52 0.00\n500000 491704.97 0.02\n600000 604233.92 0.01\n700000 721127.67 0.03\n800000 832308.12 0.04\n900000 870954.86 0.03\n1000000 1075497.64 0.08\n"})}),"\n",(0,r.jsx)(n.p,{children:"真实的 HyperLogLog 要比上面的示例代码更加复杂一些，也更加精确一些。上面的这个算法在随机次数很少的情况下会出现除零错误，因为 maxbits=0 是不可以求倒数的。"}),"\n",(0,r.jsxs)(n.h2,{id:"pf-的内存占用为什么是-12k",children:["pf 的内存占用为什么是 12k？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pf-的内存占用为什么是-12k",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们在上面的算法中使用了 1024 个桶进行独立计数，不过在 Redis 的 HyperLogLog 实现中用到的是 16384 个桶，也就是 2^14，每个桶的 maxbits 需要 6 个 bits 来存储，最大可以表示 maxbits=63，于是总共占用内存就是",(0,r.jsx)(n.code,{children:"2^14 * 6 / 8 = 12k"}),"字节。"]}),"\n",(0,r.jsxs)(n.h2,{id:"思考--作业",children:["思考 & 作业",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考--作业",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"尝试将一堆数据进行分组，分别进行计数，再使用 pfmerge 合并到一起，观察 pfcount 计数值，与不分组的情况下的统计结果进行比较，观察有没有差异。"}),"\n",(0,r.jsxs)(n.h2,{id:"扩展阅读",children:["扩展阅读",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["HyperLogLog 复杂的公式推导请阅读 ",(0,r.jsx)(n.a,{href:"https://www.slideshare.net/KaiZhang130/countdistinct-problem-88329470",target:"_blank",rel:"noopener noreferrer",children:"Count-Distinct Problem"}),"，如果你的概率论基础不好，那就建议不要看了（另，这个 PPT 需要翻墙观看）。"]}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F5%E5%BA%94%E7%94%A8%204%EF%BC%9A%E5%9B%9B%E4%B8%A4%E6%8B%A8%E5%8D%83%E6%96%A4%20%E2%80%94%E2%80%94%20HyperLogLog.md"]={toc:[{text:"使用方法",id:"使用方法",depth:2},{text:"pfadd 这个 pf 是什么意思？",id:"pfadd-这个-pf-是什么意思",depth:2},{text:"pfmerge 适合什么场合用？",id:"pfmerge-适合什么场合用",depth:2},{text:"注意事项",id:"注意事项",depth:2},{text:"HyperLogLog 实现原理",id:"hyperloglog-实现原理",depth:2},{text:"pf 的内存占用为什么是 12k？",id:"pf-的内存占用为什么是-12k",depth:2},{text:"思考 & 作业",id:"思考--作业",depth:2},{text:"扩展阅读",id:"扩展阅读",depth:2}],title:"5应用 4：四两拨千斤 —— HyperLogLog",headingTitle:"5应用 4：四两拨千斤 —— HyperLogLog",frontmatter:{}}}}]);