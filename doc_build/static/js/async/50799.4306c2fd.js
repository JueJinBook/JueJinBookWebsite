"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["50799"],{431039:function(e,d,c){c.r(d),c.d(d,{default:()=>E});var s=c(552676),n=c(740453);let i=c.p+"static/image/1dfcd43dc068fb829f9cd66e54f20595.b9b9a4f7.webp",r=c.p+"static/image/a0a7623500a0fa4587f43c0fc78fdf20.5af4bc52.webp",h=c.p+"static/image/a14c7e0a278ad5bb97916eed5032d8de.032712a9.webp",l=c.p+"static/image/1815dea767e693b07a03b465e2bcac2b.ed3029fa.webp",j=c.p+"static/image/e3d23069baa65d3d2fb5ebfe3e7312e4.a1ca5ebb.webp",x=c.p+"static/image/d4c7c24c8e4755998669cb8346a26cb4.fcab420c.webp",a=c.p+"static/image/714470f021dc024e2d2e95654bf871e8.9f275373.webp",o=c.p+"static/image/d4e00cf42cd04b531f4437e7cdca33ba.b925a484.webp",t=c.p+"static/image/479146cf313634924ed081fd366fa202.6771c130.webp",p=c.p+"static/image/f16933e55368e45712608035d83cb8fb.19385448.webp",m=c.p+"static/image/9373573588d84264a863100470ce6c77.3e431fc8.webp",u=c.p+"static/image/c733e68cfbfd7452f575186229064e84.d7076532.webp";function b(e){let d=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h4:"h4",ul:"ul",li:"li",img:"img",pre:"pre"},(0,n.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(d.h1,{id:"12前端预备vite-20-下一代前度开发构建工具",children:["12.前端预备：Vite 2.0 下一代前度开发构建工具",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#12前端预备vite-20-下一代前度开发构建工具",children:"#"})]}),"\n",(0,s.jsxs)(d.h2,{id:"前言",children:["前言",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(d.p,{children:["我还是那句话，工具永远是服务于需求的。纵观整个前端生态的项目构建工具，有服务于 ",(0,s.jsx)(d.code,{children:"React"})," 生态的 ",(0,s.jsx)(d.code,{children:"create-react-app"}),"、",(0,s.jsx)(d.code,{children:"umi"}),"、",(0,s.jsx)(d.code,{children:"Next.js"})," 等。服务于 ",(0,s.jsx)(d.code,{children:"Vue"})," 生态的 ",(0,s.jsx)(d.code,{children:"Vue CLI"}),"、",(0,s.jsx)(d.code,{children:"Vite"}),"、",(0,s.jsx)(d.code,{children:"Nuxt.js"})," 等。它们都是耳熟能详的团队和大佬，为了解决各自需求而研发出来的前端构建工具。而我们要做的其实就是根据项目的需求，进行合理的选择和学习。说白了，在你没有决定权的时候，公司用什么，你就学什么。在你有话语权，能自己抉择的时候，哪个让你开发起来比较舒服，就用哪个。"]}),"\n",(0,s.jsxs)(d.p,{children:["这些构建工具中，有一个比较特殊，那就是 ",(0,s.jsx)(d.code,{children:"Vite"}),"，它是尤雨溪在发布 ",(0,s.jsx)(d.code,{children:"Vue 3.0"})," 时，同步推出的一款前端构建工具。它不光服务于 ",(0,s.jsx)(d.code,{children:"Vue"}),"，同时也对其他的框架如 ",(0,s.jsx)(d.code,{children:"React"}),"、",(0,s.jsx)(d.code,{children:"Svelte"}),"、",(0,s.jsx)(d.code,{children:"Preact"})," 都有一定的支持，我们本着学新不学旧的理念，在项目中引进了 ",(0,s.jsx)(d.code,{children:"Vite"})," 作为构建工具。"]}),"\n",(0,s.jsxs)(d.p,{children:["在开始使用 ",(0,s.jsx)(d.code,{children:"Vite"})," 之前，我们来认识一下它。"]}),"\n",(0,s.jsxs)(d.h4,{id:"知识点",children:["知识点",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点",children:"#"})]}),"\n",(0,s.jsxs)(d.ul,{children:["\n",(0,s.jsxs)(d.li,{children:["\n",(0,s.jsxs)(d.p,{children:[(0,s.jsx)(d.code,{children:"Vite"})," 是什么。"]}),"\n"]}),"\n",(0,s.jsxs)(d.li,{children:["\n",(0,s.jsxs)(d.p,{children:[(0,s.jsx)(d.code,{children:"Vite"})," 与 ",(0,s.jsx)(d.code,{children:"Webpack"})," 相比优势在哪里。"]}),"\n"]}),"\n",(0,s.jsxs)(d.li,{children:["\n",(0,s.jsxs)(d.p,{children:[(0,s.jsx)(d.code,{children:"Vite"})," 的构建原理。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(d.h2,{id:"vite-是什么",children:["Vite 是什么",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#vite-是什么",children:"#"})]}),"\n",(0,s.jsx)(d.p,{children:"我们引用官方的一句话来介绍它，“下一代前端开发与构建工具”。"}),"\n",(0,s.jsx)(d.p,{children:"它有以下几个特点："}),"\n",(0,s.jsxs)(d.p,{children:["1、 快速启动，",(0,s.jsx)(d.code,{children:"Vite"})," 会在本地启动一个开发服务器，来管理开发环境的资源请求。"]}),"\n",(0,s.jsxs)(d.p,{children:["2、相比 ",(0,s.jsx)(d.code,{children:"Webpack"})," 的开发环境打包构建，它在开发环境下是无需打包的，热更新相比 ",(0,s.jsx)(d.code,{children:"Webpack"})," 会快很多。"]}),"\n",(0,s.jsxs)(d.p,{children:["3、原生 ",(0,s.jsx)(d.code,{children:"ES Module"}),"，要什么就当场给你什么。而 ",(0,s.jsx)(d.code,{children:"Webpack"})," 则是先将资源构建好之后，再根据你的需要，分配给你想要的资源。"]}),"\n",(0,s.jsxs)(d.p,{children:["尤雨溪在发布 ",(0,s.jsx)(d.code,{children:"Vite"})," 前，发过这么一条微博。"]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(d.p,{children:"从话语间可以看出，尤雨溪团队对该打包工具也是报以厚望，所以这里大家可以不必担心后续它们会放弃维护这个项目，当然也不能打包票。"}),"\n",(0,s.jsxs)(d.h2,{id:"vite-与-webpack-相比优势在哪里",children:["Vite 与 Webpack 相比优势在哪里",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#vite-与-webpack-相比优势在哪里",children:"#"})]}),"\n",(0,s.jsx)(d.p,{children:"接下来我们来聊聊，为什么说它是下一代前端开发与构建工具。是不是当代构建工具出了什么问题？"}),"\n",(0,s.jsxs)(d.p,{children:["我们知道当代的前端构建工具有很多，比较受欢迎的有 ",(0,s.jsx)(d.code,{children:"Webpack"}),"、",(0,s.jsx)(d.code,{children:"Rollup"}),"、",(0,s.jsx)(d.code,{children:"Parcel"}),"等，绝大多数脚手架工具都是使用 ",(0,s.jsx)(d.code,{children:"Webpack"})," 作为构建工具，如 ",(0,s.jsx)(d.code,{children:"Vue-CLI"}),"。"]}),"\n",(0,s.jsxs)(d.p,{children:["在利用 ",(0,s.jsx)(d.code,{children:"Webpack"})," 作为构建工具时，开发过程中，每次修改代码，都会导致重新编译，随着项目代码量的增多，热更新的速度也随之变慢，甚至要几秒钟才能看到视图的更新。"]}),"\n",(0,s.jsxs)(d.p,{children:["生产环境下，它将各个模块之间通过编码的方式联系在一起，最终生成一个庞大的 ",(0,s.jsx)(d.code,{children:"bundle"})," 文件。"]}),"\n",(0,s.jsx)(d.p,{children:"导致这些问题出现的原因，有以下几点："}),"\n",(0,s.jsxs)(d.p,{children:["1、",(0,s.jsx)(d.code,{children:"HTTP 1.1"})," 时代，各个浏览器资源请求并发是有上限的（如谷歌浏览器为 6 个，这导致你必须要减少资源请求数）。"]}),"\n",(0,s.jsxs)(d.p,{children:["2、浏览器并不支持 ",(0,s.jsx)(d.code,{children:"CommonJS"})," 模块化系统（它不能直接运行在浏览器环境下，它是 ",(0,s.jsx)(d.code,{children:"Node"})," 提出的模块化规范，所以需要经过 ",(0,s.jsx)(d.code,{children:"Webpack"})," 的打包，编译成浏览器可识别的 JS 脚本）"]}),"\n",(0,s.jsxs)(d.p,{children:["3、模块与模块之间的依赖顺序和管理问题（文件依赖层级越多，静态资源也就变得越多，如果一个资源有 100 个依赖关系，可能需要加载 100 个网络请求，这对生产环境可能是灾难，所以在生产环境最终会打包成一个 ",(0,s.jsx)(d.code,{children:"bundle"})," 脚本，会提前进行资源按需加载的配置。）"]}),"\n",(0,s.jsxs)(d.h4,{id:"那么为什么现在又出现了不打包的构建趋势",children:["那么为什么现在又出现了不打包的构建趋势？",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#那么为什么现在又出现了不打包的构建趋势",children:"#"})]}),"\n",(0,s.jsx)(d.p,{children:"1、工程越来越庞大，热更新变得缓慢，十分影响开发体验。推动着我们不断地去创新，不断地尝试着去突破瓶颈。"}),"\n",(0,s.jsxs)(d.p,{children:["2、各大浏览器已经开始慢慢的支持原生 ",(0,s.jsx)(d.code,{children:"ES Module"})," (谷歌、火狐、",(0,s.jsx)(d.code,{children:"Safari"}),"、",(0,s.jsx)(d.code,{children:"Edge"})," 的最新版本，都已支持。这让我们看到了希望)。"]}),"\n",(0,s.jsxs)(d.p,{children:["3、",(0,s.jsx)(d.code,{children:"HTTP 2.0"})," 采用的多路复用。不用太担心请求并发量的问题。"]}),"\n",(0,s.jsxs)(d.p,{children:["4、越来越多的 ",(0,s.jsx)(d.code,{children:"npm"})," 包开始采用了原生 ",(0,s.jsx)(d.code,{children:"ESM"})," 的开发形式。虽然还有很多包不支持，但是我相信这将会是趋势。"]}),"\n",(0,s.jsxs)(d.p,{children:["我们通过表格的形式，对比一下 ",(0,s.jsx)(d.code,{children:"bundle"})," 和 ",(0,s.jsx)(d.code,{children:"bundleless"})," 的区别。"]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsxs)(d.h2,{id:"vite-构建原理",children:["Vite 构建原理",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#vite-构建原理",children:"#"})]}),"\n",(0,s.jsxs)(d.p,{children:["众所周知，",(0,s.jsx)(d.code,{children:"Vite"})," 的生产模式和开发模式是不同的概念。我们先聊聊，",(0,s.jsx)(d.code,{children:"Vite"})," 的开发模式。"]}),"\n",(0,s.jsxs)(d.p,{children:["首先要明确一点，",(0,s.jsx)(d.code,{children:"Vite"})," 在开发模式下，有一个 ","依赖预构建"," 的概念。"]}),"\n",(0,s.jsxs)(d.h4,{id:"什么是依赖预构建",children:["什么是依赖预构建",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是依赖预构建",children:"#"})]}),"\n",(0,s.jsxs)(d.p,{children:["在 ",(0,s.jsx)(d.code,{children:"Vite"})," 启动开发服务器之后，它将第三方依赖的多个静态资源整合为一个，比如 ",(0,s.jsx)(d.code,{children:"lodash"}),"、",(0,s.jsx)(d.code,{children:"qs"}),"、",(0,s.jsx)(d.code,{children:"axios"})," 等这类资源包，存入 \xb7node_modules/.vite 文件下。"]}),"\n",(0,s.jsxs)(d.h4,{id:"为什么需要依赖预构建",children:["为什么需要依赖预构建",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么需要依赖预构建",children:"#"})]}),"\n",(0,s.jsxs)(d.p,{children:["如果直接采用 ",(0,s.jsx)(d.code,{children:"ES Module"})," 的形式开发代码，会产生一大串依赖，就好像俄罗斯套娃一样，一层一层的嵌套，在浏览器资源有限的情况下，同时请求大量的静态资源，会造成浏览器的卡顿，并且资源响应的时间也会变慢。"]}),"\n",(0,s.jsxs)(d.p,{children:["我们先不通过 ",(0,s.jsx)(d.code,{children:"Vite"}),"，而是手动搭建原生 ",(0,s.jsx)(d.code,{children:"ES Module"})," 开发形式，通过引入 ",(0,s.jsx)(d.code,{children:"lodash-es"})," 包，实现一个数组去重的小例子，来详细分析为什么需要依赖预构建。"]}),"\n",(0,s.jsxs)(d.p,{children:["新建 ",(0,s.jsx)(d.code,{children:"test1"})," 文件夹，通过 ",(0,s.jsx)(d.code,{children:"npm init -y"})," 初始化了一个前端工程："]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:["手动新建 ",(0,s.jsx)(d.code,{children:"index.html"}),"，通过 ",(0,s.jsx)(d.code,{children:"script"})," 标签，引入 ",(0,s.jsx)(d.code,{children:"main.js"}),"。这里注意，需要将 ",(0,s.jsx)(d.code,{children:"type"})," 属性设置为 ",(0,s.jsx)(d.code,{children:"module"}),"，这样才能支持 ",(0,s.jsx)(d.code,{children:"ES Module"})," 模块化开发。"]}),"\n",(0,s.jsxs)(d.p,{children:["通过 ",(0,s.jsx)(d.code,{children:"npm"})," 安装 ",(0,s.jsx)(d.code,{children:"lodash-es"}),"，这里我们之所以不使用 ",(0,s.jsx)(d.code,{children:"lodash"}),"，是因为 ",(0,s.jsx)(d.code,{children:"lodash"})," 不是通过 ",(0,s.jsx)(d.code,{children:"ES Module"})," 形式开发的，直接通过相对路径引入会报错，需要通过 ",(0,s.jsx)(d.code,{children:"Webpack"})," 打包构建。"]}),"\n",(0,s.jsx)(d.pre,{children:(0,s.jsx)(d.code,{className:"language-bash",children:"npm i lodash-es\n"})}),"\n",(0,s.jsxs)(d.p,{children:["新建 ",(0,s.jsx)(d.code,{children:"main.js"})," 添加去重逻辑："]}),"\n",(0,s.jsx)(d.pre,{children:(0,s.jsx)(d.code,{className:"language-js",children:"import uniq from './node_modules/lodash-es/uniq.js'\n\nconst arr = [1, 2, 3, 3, 4]\n\nconsole.log(uniq(arr))\n"})}),"\n",(0,s.jsxs)(d.p,{children:["这里我们采用 ",(0,s.jsx)(d.code,{children:"VSCode"})," 的插件，",(0,s.jsx)(d.code,{children:"Live Server"}),"，来启动项目。"]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:["安装完之后，在项目中双击 ",(0,s.jsx)(d.code,{children:"index.html"}),"，找到右下角的 「Go Live」，如下所示："]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:["点击后，自动启动一个 ",(0,s.jsx)(d.code,{children:"Web"})," 服务，浏览器自动打开，如下所示："]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:["结果正确，数组中的 3 被去除了，接下来关键的一个点，我们点击  ",(0,s.jsx)(d.code,{children:"Network"})," 查看，资源引入情况："]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(d.p,{children:"我们只是获取去重方法，却意外引入了 59 资源，这是为什么呢？"}),"\n",(0,s.jsxs)(d.p,{children:["我们先查看 ",(0,s.jsx)(d.code,{children:"main.js"})," 内的代码，如下所示："]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:["代码中只有在首行通过 ",(0,s.jsx)(d.code,{children:"import"})," 引入了 ",(0,s.jsx)(d.code,{children:"./node_modules/lodash-es/uniq.js"}),"，所以 ",(0,s.jsx)(d.code,{children:"uniq.js"})," 被作为资源引入进来，我们再看 ",(0,s.jsx)(d.code,{children:"uniq.js"})," 的情况："]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:[(0,s.jsx)(d.code,{children:"uniq.js"})," 中，首行通过 ",(0,s.jsx)(d.code,{children:"import"})," 引入了 ",(0,s.jsx)(d.code,{children:"_baseUniq.js"}),"，我们继续："]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:[(0,s.jsx)(d.code,{children:"_baseUniq.js"})," 中，引入了上图箭头中的一些脚本，不用往下看，我盲猜这种俄罗斯套娃的模式，会一直引用到 ",(0,s.jsx)(d.code,{children:"uniq.js"})," 相关的所有脚本代码。"]}),"\n",(0,s.jsxs)(d.p,{children:["这只是一个 ",(0,s.jsx)(d.code,{children:"uniq"})," 方法，足足就引入了 59 个资源，这仿佛是在军训浏览器，也就是谷歌能跟它博弈几个回合，引入的包再多几个，我估计也是顶不住的。"]}),"\n",(0,s.jsxs)(d.p,{children:["所以这时候 ",(0,s.jsx)(d.code,{children:"Vite"})," 便引入了「依赖预构建」的概念。"]}),"\n",(0,s.jsxs)(d.h4,{id:"依赖现预构建浅析",children:["依赖现预构建浅析",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖现预构建浅析",children:"#"})]}),"\n",(0,s.jsxs)(d.p,{children:["同样的，再通过 ",(0,s.jsx)(d.code,{children:"Vite"})," 构建出一个 ",(0,s.jsx)(d.code,{children:"React"})," 项目，去实现上述逻辑，我们观察 ",(0,s.jsx)(d.code,{children:"Vite"})," 是怎么作的。"]}),"\n",(0,s.jsxs)(d.p,{children:["首先通过 ",(0,s.jsx)(d.code,{children:"Vite"})," 指令生成项目："]}),"\n",(0,s.jsx)(d.pre,{children:(0,s.jsx)(d.code,{className:"language-bash",children:"npm init @vitejs/app test2 --template react\n"})}),"\n",(0,s.jsxs)(d.p,{children:["并安装 ",(0,s.jsx)(d.code,{children:"lodash-es"}),"，修改入口脚本 ",(0,s.jsx)(d.code,{children:"main.jsx"}),"："]}),"\n",(0,s.jsx)(d.pre,{children:(0,s.jsx)(d.code,{className:"language-js",children:"import uniq from 'lodash-es/uniq.js'\n\nconst arr = [1, 2, 3, 3, 4]\n\nconsole.log(uniq(arr))\n"})}),"\n",(0,s.jsxs)(d.p,{children:["我们观察浏览器的 ",(0,s.jsx)(d.code,{children:"Network"}),"，如下所示："]}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:["注意上图，执行 ",(0,s.jsx)(d.code,{children:"npm run dev"})," 后，脚本中引用 ",(0,s.jsx)(d.code,{children:"lodash-es/uniq"})," 的路径是在 ",(0,s.jsx)(d.code,{children:"/node_modules/.vite"})," 文件夹下，并且左下角的请求资源数，也没有我们之前原生 ",(0,s.jsx)(d.code,{children:"ES Module"})," 时的多，少了足足 3/4 还多。"]}),"\n",(0,s.jsx)(d.p,{children:"再观察文件目录："}),"\n",(0,s.jsx)(d.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(d.p,{children:[(0,s.jsx)(d.code,{children:"lodash-es/uniq"})," 已经被 ",(0,s.jsx)(d.code,{children:"Vite"})," 提前预编译到了 ",(0,s.jsx)(d.code,{children:".vite"})," 文件夹下，这样代码中直接去这个文件夹拿现成的包，就不必再递归地去加载很多静态资源脚本。"]}),"\n",(0,s.jsxs)(d.h2,{id:"总结",children:["总结",(0,s.jsx)(d.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(d.p,{children:["本章节，通过实例分析，对 ",(0,s.jsx)(d.code,{children:"Vite"})," 有了初步的了解。那么下一章节，我将带大家通过 ",(0,s.jsx)(d.code,{children:"Vite"})," 去搭建一个 ",(0,s.jsx)(d.code,{children:"React"})," 的完整开发环境。"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:d}=Object.assign({},(0,n.ah)(),e.components);return d?(0,s.jsx)(d,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}let E=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F12.%E5%89%8D%E7%AB%AF%E9%A2%84%E5%A4%87%EF%BC%9AVite%202.0%20%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%89%8D%E5%BA%A6%E5%BC%80%E5%8F%91%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"知识点",id:"知识点",depth:4},{text:"Vite 是什么",id:"vite-是什么",depth:2},{text:"Vite 与 Webpack 相比优势在哪里",id:"vite-与-webpack-相比优势在哪里",depth:2},{text:"那么为什么现在又出现了不打包的构建趋势？",id:"那么为什么现在又出现了不打包的构建趋势",depth:4},{text:"Vite 构建原理",id:"vite-构建原理",depth:2},{text:"什么是依赖预构建",id:"什么是依赖预构建",depth:4},{text:"为什么需要依赖预构建",id:"为什么需要依赖预构建",depth:4},{text:"依赖现预构建浅析",id:"依赖现预构建浅析",depth:4},{text:"总结",id:"总结",depth:2}],title:"12.前端预备：Vite 2.0 下一代前度开发构建工具",headingTitle:"12.前端预备：Vite 2.0 下一代前度开发构建工具",frontmatter:{}}}}]);