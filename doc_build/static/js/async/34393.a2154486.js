"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["34393"],{983442:function(n,e,s){s.r(e),s.d(e,{default:()=>j});var r=s(552676),i=s(740453);let l=s.p+"static/image/bc2a21b8f633ae146ef751cd4abf40fa.a5dc07dd.webp",a=s.p+"static/image/9a9ea9c62eb145079734ccb4c697cf5f.1e646a15.webp",d=s.p+"static/image/504f4c6ecc3ab0eae9869202623ec555.ef8fdfe5.webp",c=s.p+"static/image/0f9756e0461cfbe1ddb2eb7188a7c918.71e0d3a9.webp";function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",br:"br",strong:"strong",h2:"h2",h3:"h3",pre:"pre",code:"code",img:"img",h4:"h4",ol:"ol"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"2快速上手从0到1掌握算法面试需要的数据结构一",children:["2.快速上手——从0到1掌握算法面试需要的数据结构（一）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2快速上手从0到1掌握算法面试需要的数据结构一",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"数据结构层面，大家需要掌握以下几种："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"数组"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"栈"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"队列"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"链表"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"树（这里我们着重讲二叉树）"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"对于这些数据结构，各位如果没有大量的可支配时间可以投入，那么其实不建议找厚厚的大学教材来刷。此时此刻，时间为王，我们追求的是效率的最大化。"}),"\n",(0,r.jsx)(e.p,{children:"不同的数据结构教材，对数据结构有着不同的划分、不同的解读、不同的编码实现。在这里，我们面向 JavaScript，面向前端面试，只针对大家后续做题、答题时会用到的最贴合实战的数据结构特性&编码技能作讲解。"}),"\n",(0,r.jsxs)(e.p,{children:["$\\color{LightPink}{保姆式教学の}\\color{Pink}{温情提示：}$",(0,r.jsx)(e.br,{}),"\n","这两节我们所提及的基础知识细节，很可能会成为你后面写代码的关键线索。",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.strong,{children:"不要因为乍一看觉得简单，就急着跳读急着做题"}),"。",(0,r.jsx)(e.br,{}),"\n","不然你很可能做题做到一半，会不知道自己到底为什么就卡了壳。",(0,r.jsx)(e.br,{}),"\n","到时候万一又因为懒得回头看，而原地卡死，那就更做不下去了orz。"]}),"\n",(0,r.jsx)(e.p,{children:"注：由于 JavaScript 中字符串和数组关联紧密，关键知识点重复度较高，故我们在数据结构部分，不再单独为字符串保留篇幅。字符串相关的知识点，我们直接带到后续的解题技巧归纳专题里去看。"}),"\n",(0,r.jsxs)(e.h2,{id:"数组",children:["数组",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数组",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["数组是各位要认识的第一个数据结构。",(0,r.jsx)(e.br,{}),"\n","作为最简单、最基础的数据结构，大多数的语言都天然地对数组有着原生的表达，JavaScript 亦然。这意味着我们可以对数组做到“开箱即用”，而不必自行模拟实现，非常方便。"]}),"\n",(0,r.jsxs)(e.p,{children:["考虑到日常开发过程中，数组的出镜率本身已经很高，相信它也是大多数同学最熟悉的数据结构。 即便如此，这里仍然需要提醒各位：",(0,r.jsx)(e.strong,{children:"要对数组格外走点心，毕竟后面需要它帮忙的地方会非常多"}),"。"]}),"\n",(0,r.jsxs)(e.h3,{id:"数组的创建",children:["数组的创建",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数组的创建",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"大家平时用的最多的创建方式想必就是直接方括号+元素内容这种形式："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const arr = [1, 2, 3, 4]   \n"})}),"\n",(0,r.jsx)(e.p,{children:"不过在算法题中，很多时候我们初始化一个数组时，并不知道它内部元素的情况。这种场景下，要给大家推荐的是构造函数创建数组的方法："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const arr = new Array()\n"})}),"\n",(0,r.jsx)(e.p,{children:"当我们以构造函数的形式创建数组时，若我们像楼上这样，不传任何参数，得到的就会是一个空数组。等价于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const arr = []\n"})}),"\n",(0,r.jsxs)(e.p,{children:["不过咱们使用构造函数，可不是为了创建空数组这么无聊。",(0,r.jsx)(e.br,{}),"\n","我们需要它的时候，往往是因为我们有“创造指定长度的空数组”这样的需求。需要多长的数组，就给它传多大的参数："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const arr = new Array(7)\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样的写法就可以得到一个长度为7的数组："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"在一些场景中，这个需求会稍微变得有点复杂——\n“创建一个长度确定、同时每一个元素的值也都确定的数组”。这时我们可以调用 fill 方法，假设需求是每个坑里都填上一个1，只需给它 fill 一个1："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const arr = (new Array(7)).fill(1)\n"})}),"\n",(0,r.jsx)(e.p,{children:"如此便可以得到一个长度为7，且每个元素都初始化为1的数组："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsxs)(e.h4,{id:"数组的访问和遍历",children:["数组的访问和遍历",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数组的访问和遍历",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"访问数组中的元素，我们直接在中括号中指定其索引即可："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"arr[0] // 访问索引下标为0的元素\n"})}),"\n",(0,r.jsx)(e.p,{children:"而遍历数组，这个方法就多了，不过目的往往都是一致的——访问到数组中的每个元素，并且知道当前元素的索引。这里我们讲三个方法："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"for 循环"}),(0,r.jsx)(e.br,{}),"\n","这个是最最基础的操作。我们可以通过循环数组的下标，来依次访问每个值："]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// 获取数组的长度\nconst len = arr.length\nfor(let i=0;i<len;i++) {\n    // 输出数组的元素值，输出当前索引\n    console.log(arr[i], i)\n}\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"forEach 方法"}),(0,r.jsx)(e.br,{}),"\n","通过取 forEach 方法中传入函数的第一个入参和第二个入参，我们也可以取到数组每个元素的值及其对应索引："]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"arr.forEach((item, index)=> {\n    // 输出数组的元素值，输出当前索引\n    console.log(item, index)\n})\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"3",children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"map 方法"}),(0,r.jsx)(e.br,{}),"\n","map 方法在调用形式上与 forEach 无异，区别在于 map 方法会根据你传入的函数逻辑对数组中每个元素进行处理、进而返回一个全新的数组。",(0,r.jsx)(e.br,{}),"\n","所以其实 map 做的事情不仅仅是遍历，而是在遍历的基础上“再加工”。当我们需要对数组内容做批量修改、同时修改的逻辑又高度一致时，就可以调用 map 来达到我们的目的："]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const newArr = arr.map((item, index)=> {\n    // 输出数组的元素值，输出当前索引\n    console.log(item, index)\n    // 在当前元素值的基础上加1\n    return item+1\n})\n"})}),"\n",(0,r.jsx)(e.p,{children:"这段代码就通过 map 来返回了一个全新的数组，数组中每个元素的值都是在其现有元素值的基础上+1后的结果。"}),"\n",(0,r.jsxs)(e.p,{children:["这里给个小建议：个人推荐如果没有特殊的需要，那么统一使用 for 循环来实现遍历。因为",(0,r.jsx)(e.strong,{children:"从性能上看，for 循环遍历起来是最快的"}),"。"]}),"\n",(0,r.jsxs)(e.h3,{id:"二维数组",children:["二维数组",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二维数组",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["初学编程的同学基础如果比较薄弱，会对二维数组完全没有概念。这里咱们先简单介绍下：二维数组其实就是数组套数组，也就是每个元素都是数组的数组。",(0,r.jsx)(e.br,{}),"\n","说起来有点绕口，咱们直接上图来看："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const arr = [1,2,3,4,5]\n"})}),"\n",(0,r.jsx)(e.p,{children:"这个数组在逻辑上的分布就是这样式儿的："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,UklGRsgNAABXRUJQVlA4ILwNAAAQdACdASpyAwoBPp1Iok0lo6ciIPQpYOATiWVu/HyZp70HDTmgx/VPzC6Bznabc5j8S/Ov+j/aPyx+B39A9hv5x9gD9M/EA92X7ZeoD+Z/4D9sPdT/qv6q+4j0AP7Z/qOsA9AD9vfTD/dz4Qv7T/0fSk//+s5+GP6r2v/3Xwp8hnqaX6YZ+3P3nhZ+MmoF+Jfx3/Jb5qAD8p/tv/M42vsB7AHk3/qvC1+weoH/K/8V6D3/V5d/zj/Uewd/L/7Tvwwg6oh4xAPPGLL+ZfzL+ZfzL+ZfzL+ZfzL+ZfzL+ZfzL+ZfzL+ZfzL+ZfzL+ZfzL+ZfzL+ZfzLAsR8nCFrNamw5FO4noA4N94bWqDY1i5HyKJXxZX4ecDud/84FtJ2fRFVSy/l+gx2D/vOonmw5tsCWa7/6ohyGcqZgEF7F6/5DJfFINmnwpQOn8e5kDcFiuWrC22FlUFT/nk/bNdwc7bNDqSzXb7QNKhXTGunbXf/NhUnOuvr4XnW0B8De35rOFuEIuY67vAdUTzxiy+jvPBEditf90aSzTNDLH/iAfB124L2/nw+6W49K/VEDGSfEmu/el4xAPPGLL+aHhl/Mv5l/Mv5l/Mv5l/138y/mX8y/mX8y/mX0i8ylZXmqyJxJMXVh/Oa5e0GCL0qdic9aDSTETQPYIvSp2GjZd//D9V5E4kmLqw9/dmp2J0Xa6DBFKhw+l4xAPPGLLLzu076WcoNZx/OFjEYjELDecF7T8Xt1dHByoeMWX8y/mCqbfiyy8ke6ZeKBrv/D8p7EAuV6onm47k88Ysv5l9UwNGInXpGxCG4CLaiP8RN3FSRgcHwH8E/ZXM7zGOeMuc3fVxUTyzyA675rv/qiHjD96ROepUEMNs8pB/SNrWyohXECYkTQsdUUiPzRjtstgWssbz3ufkwVNKeLi67/NJR9MOpNypEEsCG6uoWJ5HuT1lBnzta75rv/qiHjD96RSBnJHM8Ap0/K2mydvoVNLC8q1zFxF1QpBIeMQDzxiwVTb8WWXkj3TLxR5/9SiECYgFyxNc/MFSn5l/Mv5l9UwPVE71rUMv4eZ3x9znQAoogpA+vGGxA4xAPPGLL5lwkHQDP7F2ugwRehQHyRgPYIvSp2Jz0bpyo4u10GCL0qYVu6rN8icSTF2ugt5X1Xj9V5E4kmLtcrdfcZLiy/mX8y/8BrvJd+qIeMQDzxiy/mX8y/mX8y/mX8y/mX8y/mX8y/mX8y/mX8y/mX8y/mX8y/mV4AAP7/etAAAAAAADgPAQEzRnmq0QO+z6bl/c9VJ19LzL6bPNR1cnOyuLjdncK/sC+hHrla/0bk+IiOu5YDGYzatWNwyeFfuAIG0WL5NTTKAPiN5iwIEm9EHxdxaGtrG9wiP4hx5reCnrTEfMr1Gl4fblt1e7IYAyXy3TqJN0cdT+xwBzMJ8LbW7ilPxdK0TtKOO4Fvu88+MllP3oLvv//KIkv/S2OdoN2xqCeRR4PuAN/DhJ36+qnfkxTgt7nBNwowWoor8AC638/Kk/mqKE0WEfeqA6tsuPSBcX3hUja433A4tKiMj+vqCrfaNNpEI/ohan0UsnJssqDU2LyJG/jqv4sSzmhd9zeIF+pb+b6MRwPP7SQZ7YFB9Sl+BXnSQcxiln6gvh+5UJFrPfq9igV6n84FEgROB8xRyfLIUCi3DV8d4WqZtbBQ1qBcx6KQCuR3EfSGqidIEaV++FthLvohtm4BscG1Uhh5+lO7mvL+muLaA/m/+N9hp+9am0pR8qGUBjUp1Myp10bszdVtiJP75RXPtI3y9XYyGqvD9/zoQVQnyOCBvU49N+v7u5pZR0X4jXQoHJwySj+y/PiAg5H3ee9WgMJagRsAHONpYS/IVDNZvlnsO5Sp3/yS7pjr8NX5HvLujuGvF5GwIodhcLZcHVnxCou19600Hrj/NGL7smZAgMH5s/yiIZXGKYqt63Vx+yY9GS3iopSo3wjBN38DdeX/asBdYMulvr17KDZKhoqZufd/1ZndCZp6Ks0LG4REIAh1g2J/Gwor/t+/Cyfw0Ck/FRfjmECZ/ryvzjw+PYk96GXneQwbfbt8Ds1WiCiZEcLKjujbKT6twTO0yMV7ry9V+tfmLcwnne1uPendclbxvXn7iO9QymrY1fWbtfwu0ssrLuNRFou6mnTWbod6HUwf0u5c2/O0z3T/1IcR6kWry5B7BBcnXxMvdzo3HVUlGZI8UeOkmcq7UPwvDJN8WFybY8VxaYJ90AIQi9GTLIlkl6DgbYt/Sov06W2u/DeEhtt3BvK1QX386bpSbWINBsDmnLLb65SA3mjwo7/n4VnJa4dzasala3eksjpxgtMUeHR9QHOOlYqx63n4RNFmZeIn9EzAEePHpTZpvho01ETKrniKfWQ0+7MLwuBOypQkHIRunJekE0AMI/pxVru9/hphiQMtiZSuRA4b82zTuro6HwrPi01DRxpLcl94adFX4LEFhnNdWK+uPk8j+ZU/jOXFdHQ2yQBMCY0pNVAQijvj2YpVVTqY7xqGU+BNiNyMuCfwz3e+rg8rFA6G56158vMI8X8q7CD/LL2Puyhv/M/xq7GQGx5Og/WJwprAVDbYdh/WMkkfQSrq2MENoORN+vGMk1hvgouNhRq+MizpG58LWQHPRfLAIKwGAe/6ZYwY2ARxoxl//6XhZaV9EDRArmPqxiE0ctfpvEG48D14q5f1ow/Y82aL6rCmeXOuQQqH3cSDRCyrIVwG+tjAACxLbNmiFJNoAAAAAMamVW4b/LmKBQvvb0Wg5e/8MhYDfJveZV8Mco3wb1IYMq+hvri/4I8+WlunULIuk9r++pv3gPI3qu9xz24PeVQNW8qgWDgvSp7vdH4UxWXHMkYG1J3hvOdBd64dYPNE1fIW0fyNVGd2OUUD69HE2jcbV2qp0T4bPokU0dkx/Zi7hTBgGyrNNiH9zMHQ+6ATVomvtp4VR/ifdfUE9p5pnkCqYyNFUxkaKpjI0ULwDeaQuZM+D5NzBm12IZvlXFMhWLRn7nXxFzJPYWpgsveYDRi5SiMbZH4zkTqNsQwiGCZP75A0faLQsZ40KbTKFeqKcovN4mMDSDNpxmS+wih6gHXZWbeE2nsskbJ8JaYnPMFVYDEPvWlmK/V5iAgXwjEy43+LkWmgC4w0Xe7/Z+oC63Q6NVPjxOdCdJsiuotoAS4YhsRkchQ5JikjYgLYGHus37ySbBgyPN1g/qm11xfQpeQjB08GgmeLUoDqBXrjGfjAyMfeSnaNbH2c2XhtoscpZwJonepVZ0Y5Thl9z+EXWXungxlEXwbg9cx+ZeUda3L8rzJg922FlSZtzCrcf+U2CBvf9fTFvkn/ako/R8b9m8I1ZXBbtgxc0ujSSC2hRft28nH7LtpVIkmVfmcrxqxWZx5Zf+0fa6IH/deZ+86UkX7BmjtadVb/GraqA59ej9sIInAoN+0pEIC/Qib6qDOY/LEYBTsp0v9hCeYaLgP/eaAzp+9rf/5l+7KLLarv47bv7+PhcYu/xn7YTq4/92e/iAuE8nrqBvV6aBXNMUt4Fj0XbE8dq3MKfvZlt21hhPviTKtRGrIa//cRP/7h0pGHmuHMDthbzUZzJuzVdbhmON0XGVYTgBkGI/PPQqbAtHUfjesNCz+ilDQs4IdoCwepST96qejLuOKL/io63abjBq984u+xd2vLMU+ucOyw9EZrRmGs7RyEU5/2MhwDXimMRefu0xF8b1cluCXH2oXyiKnaAFtiNdx3/wJGCQQ98uGmoRyuNMikYrziX++ottdoGBmCiOKxOIshTqPV9iW4bFPKesLEp7z5nfRhhZgS+VTT1+l4lOIh1D2mAw3KRONLpCxigypXFMX+Zaw/6mV2y7zkv3vlx2qfalxRUqaMcAbuR9kOZvH4vOAr7UVw8FtGcS4vGnCovlP7FTRtucgan8FWfP/kaDQgXVrBT5s4rYgZxadR3vJvqisisZccwK/gJFrijKMxucD8dEthqF3QcfuDjE4S6EDvtXwyE+468y+2+3KMOPOYY2hf12+SWq3PB2KcEtqedaM5PKcAVMRklBBs5SZx1/qTh697HwazzQJ9cfpu31XxcAYlD7xaTv7WMUMNHcDnf03MNB7Us3GTanEQEejlvsVGJjxCjozimGLY54pBo5D0mT1vgmvpHBxdtV6I87uIGtQBu+OqHdfxhmKpkcHLgt291xRc7Dg4Kl4uxDeZKhfPesGZTkEEy6SHn+3ZrkIAlt2N0Yzw4TykCzBYCU8X7y54V6qZQi5Lh4gMt9gyvqc4yIMdjzBhBlbTxF7iTBegT02CZtI7Zqefk8cjVPct2nAA+pmqbs4AH7KnwfbraTWcl1G36oM8mxZRbvGcj71p7eDt/8g57bMd1DKayQIkz8bCn4wE1/rK9lknAKNMjEm9kg9cXHAHXBKNzpPUPrq4kcnxkv9O5Xd+STLy/VIwEsDUNHil9Kw/ot8v+ik3JdersseeaYGvk3LAul187i0zjAuaCsu5eGdN2N9EOrbefO1fJbZoNdl0ZwUldMnrWfDw4+uqRS7wp8dajjAli94UpQvfQHJfDUDaOZvB0CPGAlGpwYD5iMNQfVP8XTEC7KbNiAa3simn7fTyNUTOxzTbbHT6GGg++KnzlDRvE3IUd9D118/x8vYkHoCwf7n83jznJfU48HCtRYGCWBAAAAAAAAAAAAA=",alt:""})}),"\n",(0,r.jsxs)(e.p,{children:["像图上这样，数组的元素是数字而非数组。整个数组的结构看上去宛如一条“线”，这就是一维数组。",(0,r.jsx)(e.br,{}),"\n","而“每个元素都是数组的数组”，代码里看是这样："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const arr = [\n  [1,2,3,4,5],\n  [1,2,3,4,5],\n  [1,2,3,4,5],\n  [1,2,3,4,5],\n  [1,2,3,4,5]\n]\n"})}),"\n",(0,r.jsx)(e.p,{children:"直接把它的逻辑结构画出来看，是这样："}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)("img",{src:d,alt:""}),(0,r.jsx)(e.br,{}),"\n","图中的每一行，就代表着一个数组元素。比如第 0 行，就代表着数组中 arr[0] 这个数组元素，其内容是 [1,2,3,4,5]。",(0,r.jsx)(e.br,{}),"\n","每一行中的每一列，则代表一个确切的“坑”。比如第 0 行第 1 列，就代表着数组中 arr[0][1] 这个元素，其值为2，是一个确切的 number。"]}),"\n",(0,r.jsx)(e.p,{children:"明白了二维数组的索引规律，现在我们来看一下二维数组的特点：从形状上看，相对于一维数组一条“线”一般的布局，二维数组更像是一个“面”。拿咱们这个例子来说，这里的二维数组逻辑分布图就宛如一个正方形。当然啦，如果我们稍微延长一下其中的一边，它也可以是一个矩形。"}),"\n",(0,r.jsxs)(e.p,{children:["在数学中，形如这样",(0,r.jsx)(e.strong,{children:"长方阵列排列的复数或实数集合"}),"，被称为“矩阵”。因此",(0,r.jsx)(e.strong,{children:"二维数组的别名就叫“矩阵”"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["讲到这里，如果有对“矩阵”的定义一脸懵逼的同学，也不用怕——不知道“矩阵”是啥，一点不打紧（所以快停下你复制粘贴到 Google 的手哈哈），但你必须要",(0,r.jsx)(e.strong,{children:"记住“矩阵”和“二维数组”之间的等价关系"}),"。在算法题目中，见到“矩阵”时，能够立刻反射出它说的是二维数组，不被别名整懵逼，这就够了。"]}),"\n",(0,r.jsxs)(e.h3,{id:"二维数组的初始化",children:["二维数组的初始化",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二维数组的初始化",children:"#"})]}),"\n",(0,r.jsxs)(e.h4,{id:"fill-的局限性",children:["fill 的局限性",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#fill-的局限性",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"有同学用 fill 方法用顺了手，就本能地想用 fill 解决所有的问题，比如初始化一个二维数组："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const arr =(new Array(7)).fill([])\n"})}),"\n",(0,r.jsx)(e.p,{children:"乍一看没啥毛病，7个坑都被乖乖地填上了数组元素："}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)("img",{src:l,alt:""}),(0,r.jsx)(e.br,{}),"\n","但是当你想修改某一个坑里的数组的值的时候："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"arr[0][0] = 1\n"})}),"\n",(0,r.jsx)(e.p,{children:"你会发现一整列的元素都被设为了 1："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(e.p,{children:["这是什么骚操作？？？",(0,r.jsx)(e.br,{}),"\n","这就要从 fill 的工作机制讲起了。各位要清楚，当你给 fill 传递一个入参时，",(0,r.jsx)(e.strong,{children:"如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用"}),"。也就是说下图中虽然看似我们给7个坑位各初始化了一个数组：",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)("img",{src:l,alt:""}),(0,r.jsx)(e.br,{}),"\n","其实这7个数组对应了同一个引用、指向的是同一块内存空间，",(0,r.jsx)(e.strong,{children:"它们本质上是同一个数组"}),"。因此当你修改第0行第0个元素的值时，第1-6行的第0个元素的值也都会跟着发生改变。"]}),"\n",(0,r.jsxs)(e.h4,{id:"初始化一个二维数组",children:["初始化一个二维数组",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化一个二维数组",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本着安全的原则，这里我推荐大家采纳的二维数组初始化方法非常简单（而且性能也不错）。直接用一个 for 循环来解决："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const len = arr.length\nfor(let i=0;i<len;i++) {\n    // 将数组的每一个坑位初始化为数组\n    arr[i] = []\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"for 循环中，每一次迭代我们都通过“[]”来创建一个新的数组，这样便不会有引用指向问题带来的尴尬。"}),"\n",(0,r.jsxs)(e.h4,{id:"二维数组的访问",children:["二维数组的访问",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二维数组的访问",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"访问二维数组和访问一维数组差别不大，区别在于我们现在需要的是两层循环："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"// 缓存外部数组的长度\nconst outerLen = arr.length\nfor(let i=0;i<outerLen;i++) {\n    // 缓存内部数组的长度\n    const innerLen = arr[i].length\n    for(let j=0;j<innerLen;j++) {\n        // 输出数组的值，输出数组的索引\n        console.log(arr[i][j],i,j)\n    }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["一维数组用 for 循环遍历只需一层循环，二维数组是两层，三维数组就是三层。依次类推，",(0,r.jsx)(e.strong,{children:"N 维数组需要 N 层循环来完成遍历"}),"。"]}),"\n",(0,r.jsxs)(e.h2,{id:"数组小结",children:["数组小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数组小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"关于数组的基础知识，咱们整整用掉了一节的篇幅来介绍，可见其重要性。"}),"\n",(0,r.jsx)(e.p,{children:"在本节，我们仅仅围绕数组最基本的操作进行介绍，这远不是数组的全部。关于数组，还有太多太多的故事要讲——实际上，单就其重要的方法的使用：如concat、some、slice、join、sort、pop、push 等等这些，就足以说上个把钟头。"}),"\n",(0,r.jsx)(e.p,{children:"本节暂时不对数组 API 作集中讲解，因为罗列 API 没有意义——脱离场景去记忆 API 实在是一件太痛苦的事情，这会挫伤各位继续走下去的积极性。"}),"\n",(0,r.jsx)(e.p,{children:"关于数组的更多特性和技巧，会被打散到后续的章节中去。各位在真题解读的环节、包括在其它数据结构的讲解中，都会不可避免地再见到数组的身影。彼时数组的每一个方法都会和它对应的应用场景一起出现，相信你会有更深刻的记忆。"}),"\n",(0,r.jsx)(e.p,{children:"事实上，在 JavaScript 数据结构中，数组几乎是“基石”一般的存在。这一点，大家在下一节就会有所感触。"}),"\n",(0,r.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function x(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(h,{...n})}):h(n)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%EF%BC%9A%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98%E8%AE%AD%E7%BB%83%2F2.%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E2%80%94%E2%80%94%E4%BB%8E0%E5%88%B01%E6%8E%8C%E6%8F%A1%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89.md"]={toc:[{text:"数组",id:"数组",depth:2},{text:"数组的创建",id:"数组的创建",depth:3},{text:"数组的访问和遍历",id:"数组的访问和遍历",depth:4},{text:"二维数组",id:"二维数组",depth:3},{text:"二维数组的初始化",id:"二维数组的初始化",depth:3},{text:"fill 的局限性",id:"fill-的局限性",depth:4},{text:"初始化一个二维数组",id:"初始化一个二维数组",depth:4},{text:"二维数组的访问",id:"二维数组的访问",depth:4},{text:"数组小结",id:"数组小结",depth:2}],title:"2.快速上手——从0到1掌握算法面试需要的数据结构（一）",headingTitle:"2.快速上手——从0到1掌握算法面试需要的数据结构（一）",frontmatter:{}}}}]);