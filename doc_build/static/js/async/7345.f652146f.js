"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["7345"],{463814:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var s=r(552676),c=r(740453);let t=r.p+"static/image/0b037d14bf1c1cc7eae764fab4c81f5c.9fefbe53.webp";function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",blockquote:"blockquote",h4:"h4",code:"code",pre:"pre",img:"img",ul:"ul",li:"li",ol:"ol"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"31配置篇-_-草稿模式和内容安全策略",children:["31.配置篇 _ 草稿模式和内容安全策略",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31配置篇-_-草稿模式和内容安全策略",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本篇我们介绍草稿模式和内容安全策略，两者都是特殊场景下会用到的解决方案。草稿模式用于针对特定情况切换到动态渲染，正如它的名字一样，适用于内容系统的草稿展示。内容安全策略用于阻止脚本恶意加载。现在让我们开始学习吧。"}),"\n",(0,s.jsxs)(n.h2,{id:"1-草稿模式draft-mode",children:["1. 草稿模式（Draft Mode）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-草稿模式draft-mode",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"11-介绍",children:["1.1. 介绍",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-介绍",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"草稿模式一般是结合 headless CMS 使用。先说说 CMS，所谓 CMS，Content Management System，中文译为内容管理系统。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"内容管理系统的定义可以很狭窄，通常是指门户或商业网站的发布和管理系统；定义也可以很宽泛，个人网站系统也可归入其中。Wiki也是一种内容管理系统，Blog也算是一种内容管理系统。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"比如常用于搭建博客的 Wordpress 就是一个知名的内容管理系统。这些年来，headless CMS 也流行了起来。所谓 headless CMS，简单的来说，CMS 不再负责内容的展现，只提供内容存储库以及 API，这使得开发人员可以自定义展示内容，虽然带来了一定的工作量，但也让开发更加灵活自由。"}),"\n",(0,s.jsx)(n.p,{children:"现在说回 Next.js，当你从 headless CMS 中获取数据展示内容的时候，通常静态渲染（编译成 HTML，然后直接展现）就可以了，但如果你是在 headless CMS 中编写草稿，并希望能在页面立即查看到草稿内容时，静态渲染就不合适了，你会希望 Next.js 在请求时而非在构建时渲染页面，获取的是草稿内容而非发布的内容。这个时候就需要草稿模式了。它会让 Next.js 针对特定情况切换到动态渲染。让我们来看看怎么实现的吧。"}),"\n",(0,s.jsxs)(n.h3,{id:"12-实现",children:["1.2. 实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-实现",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"121-创建并访问路由处理程序",children:["1.2.1. 创建并访问路由处理程序",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#121-创建并访问路由处理程序",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先，创建一个路由处理程序，名字无所谓，就比如 ",(0,s.jsx)(n.code,{children:"app/api/draft/route.js"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["然后，从 ",(0,s.jsx)(n.code,{children:"next/headers"}),"中导入 ",(0,s.jsx)(n.code,{children:"draftMode"}),"，调用 ",(0,s.jsx)(n.code,{children:"enable()"})," 方法。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/api/draft/route.js\nimport { draftMode } from 'next/headers'\n \nexport async function GET(request) {\n  draftMode().enable()\n  return new Response('Draft mode is enabled')\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这将设置一个 cookie 用于开启草稿模式，后续包含这个 cookie 的请求都会触发草稿模式，从而改变静态生成页面的行为。"}),"\n",(0,s.jsxs)(n.p,{children:["关于这个 cookie，现在通过浏览器开发工具查看 ",(0,s.jsx)(n.code,{children:"/api/draft"}),"请求，你会在 ",(0,s.jsx)(n.code,{children:"Set-Cookie"})," 响应头中发现一个名为 ",(0,s.jsx)(n.code,{children:"__prerender_bypass"}),"的 cookie，就是此 cookie 控制了页面的展现方式。此外，每次运行 ",(0,s.jsx)(n.code,{children:"next build"}),"的时候都会生成一个新的 cookie 值以确保该值不会被猜到。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"如果你想要更加安全的使用草稿模式，这是一个建议的使用方式："}),"\n",(0,s.jsx)(n.p,{children:"首先，创建一个秘密的 token 字符串，此密钥只有你的 Next.js 应用程序和 headless CMS 知道，这个密钥可以防止无权访问 CMS 的用户访问草稿 URL。"}),"\n",(0,s.jsxs)(n.p,{children:["然后，设置类似下面这样的草稿 URL，假设路由处理程序的地址是 ",(0,s.jsx)(n.code,{children:"app/api/draft/route.js"}),"，对应的草稿 URL 为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"https://<your-site>/api/draft?secret=<token>&slug=<path>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中 ",(0,s.jsx)(n.code,{children:"<path>"})," 表示你想要查看的页面路径，比如你想要查看 ",(0,s.jsx)(n.code,{children:"/posts/foo"}),"，这里就是 ",(0,s.jsx)(n.code,{children:"&slug=/posts/foo"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"最后你就可以在路由处理程序中，进行各种判断比如密钥是否匹配，参数是否存在，然后再开启 Draft Mode，重定向到预览的路径，示例代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/api/draft/route.js\nimport { draftMode } from 'next/headers'\nimport { redirect } from 'next/navigation'\n \nexport async function GET(request) {\n  const { searchParams } = new URL(request.url)\n  const secret = searchParams.get('secret')\n  const slug = searchParams.get('slug')\n \n  if (secret !== 'MY_SECRET_TOKEN' || !slug) {\n    return new Response('Invalid token', { status: 401 })\n  }\n \n  const post = await getPostBySlug(slug)\n \n  if (!post) {\n    return new Response('Invalid slug', { status: 401 })\n  }\n \n  draftMode().enable()\n \n  redirect(post.slug)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如果成功的话，浏览器就会重定向到你想要查看的路径。"}),"\n",(0,s.jsxs)(n.h4,{id:"122-更新页面",children:["1.2.2. 更新页面",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#122-更新页面",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["第二步就是通过检查 ",(0,s.jsx)(n.code,{children:"draftMode().isEnabled"}),"的值来更新页面。如果请求的页面有设置 cookie，此时 ",(0,s.jsx)(n.code,{children:"isEnabled"})," 的值就会是 ",(0,s.jsx)(n.code,{children:"true"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nimport { draftMode } from 'next/headers'\n \nasync function getData() {\n  const { isEnabled } = draftMode()\n \n  const url = isEnabled\n    ? 'https://draft.example.com'\n    : 'https://production.example.com'\n \n  const res = await fetch(url)\n \n  return res.json()\n}\n \nexport default async function Page() {\n  const { title, desc } = await getData()\n \n  return (\n    <main>\n      <h1>{title}</h1>\n      <p>{desc}</p>\n    </main>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样，当你从 headless CMS 或者手动带 secret 和 slug 访问路由处理程序的时候，你应该能成功的看到草稿内容。"}),"\n",(0,s.jsxs)(n.h4,{id:"123-其他",children:["1.2.3. 其他",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#123-其他",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["默认情况下，草稿模式的 session 会在浏览器关闭时结束。如果你想要手动清理草稿模式的 cookie，你可以创建一个路由处理程序，在此程序中调用 ",(0,s.jsx)(n.code,{children:"draftMode().disable()"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/api/disable-draft/route.js\nimport { draftMode } from 'next/headers'\n \nexport async function GET(request) {\n  draftMode().disable()\n  return new Response('Draft mode is disabled')\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后，发送一个请求到 ",(0,s.jsx)(n.code,{children:"/api/disalbe-draft"})," 调用路由处理程序，如果你使用 ",(0,s.jsx)(n.code,{children:"next/link"})," 来调用这个路由，你必须传递 ",(0,s.jsx)(n.code,{children:"prefetch={false}"}),"来防止 prefetch 时意外删除 cookie。"]}),"\n",(0,s.jsxs)(n.h2,{id:"2-内容安全策略content-security-policy",children:["2. 内容安全策略（Content Security Policy）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-内容安全策略content-security-policy",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"21-http-csp",children:["2.1. HTTP CSP",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-http-csp",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["介绍 Next.js 的 CSP 实现方式前，我们先说下 HTTP 请求中的 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP",target:"_blank",rel:"noopener noreferrer",children:"CSP"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"所谓 CSP，Content Security Policy，中文译为“内容安全策略”。CSP 用于检测并削弱某些特定类型的攻击，包括跨站脚本（XSS）和数据注入攻击等。"}),"\n",(0,s.jsxs)(n.p,{children:["该安全策略的实现基于一个叫做 Content-Security-Policy 的 HTTP 首部。除此之外，"," 元素也可以被用来配置该策略，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"<meta\n  http-equiv=\"Content-Security-Policy\"\n  content=\"default-src 'self'; img-src https://*; child-src 'none';\" />\n"})}),"\n",(0,s.jsx)(n.p,{children:"CSP 到底是怎么缓解攻击的呢？以 XSS 攻击为例："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。"}),"\n",(0,s.jsx)(n.p,{children:"CSP 通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除 XSS 攻击所依赖的载体。一个 CSP 兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本（包括内联脚本和 HTML 的事件处理属性）。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["你可以使用 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy",target:"_blank",rel:"noopener noreferrer",children:"Content-Security-Policy"})," HTTP 标头来指定你的策略，像这样："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"Content-Security-Policy: policy\n"})}),"\n",(0,s.jsxs)(n.p,{children:["policy 表示策略，是一个包含了各种描述你的 CSP 策略指令的字符串。对于不同类型的项目都有特定的指令，因此每种类型都可以有自己的指令，包括字体、frame、图像、音频和视频媒体、script 和 worker。比如我们要限制图片的加载需要用 ",(0,s.jsx)(n.code,{children:"img-src"}),"，限制多媒体文件的加载需要用 ",(0,s.jsx)(n.code,{children:"media-src"}),"，限制脚本的加载需要用 ",(0,s.jsx)(n.code,{children:"script-src"}),"，举个例子："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com\n"})}),"\n",(0,s.jsx)(n.p,{children:"在这个例子里，各种内容默认仅允许从文档所在的源获取，但存在如下例外："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"图片可以从任何地方加载 (注意“*”通配符)"}),"\n",(0,s.jsx)(n.li,{children:"多媒体文件仅允许从 media1.com 和 media2.com 加载（不允许从这些站点的子域名）"}),"\n",(0,s.jsx)(n.li,{children:"可运行脚本仅允许来自于 userscripts.example.com"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["具体有哪些指令（",(0,s.jsx)(n.code,{children:"*-src"}),"这种）可以查看 MDN 的 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/base-uri",target:"_blank",rel:"noopener noreferrer",children:"CSP 指令文档"}),"，我数了一下，具体有 29 种指令。而具体的指令内容的书写方式除了 ",(0,s.jsx)(n.code,{children:"'self'"})," 这种表示自身域，",(0,s.jsx)(n.code,{children:"media1.com"}),"这种表示具体的域名之外，还有总共 13 种类型写法，具体可以查看 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources",target:"_blank",rel:"noopener noreferrer",children:"CSP source values"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们举一个后面讲解会用到的—— ",(0,s.jsx)(n.code,{children:"'nonce-<base64-value>'"}),"，使用示例如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"Content-Security-Policy: default-src 'self'; script-src 'nonce-rBcd2m'\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"'nonce-<base64-value>'"}),"表示允许使用加密随机数的特定内联脚本。还记得 ",(0,s.jsx)(n.code,{children:"<script>"})," 有一个 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/nonce",target:"_blank",rel:"noopener noreferrer",children:"nonce"})," 属性吗？就是搭配 CSP 来使用："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<script nonce="rBcd2m">\n	//...\n<\/script>\n'})}),"\n",(0,s.jsx)(n.p,{children:"如果脚本 nonce 的值跟 CSP 中的值一致，该脚本的内容就可以得到执行。"}),"\n",(0,s.jsxs)(n.h3,{id:"22-nextjs-csp",children:["2.2. Next.js CSP",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-nextjs-csp",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"回到 Next.js，尽管 CSP 可以阻止恶意脚本，不过有的时候，使用内联脚本是必需的。在这种情况下，就需要借助随机数来保证脚本正确执行，为此我们需要借助 Next.js 中间件来实现，举个例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// middleware.js\nimport { NextResponse } from 'next/server'\n \nexport function middleware(request) {\n  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')\n  const cspHeader = `\n    default-src 'self';\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\n    style-src 'self' 'nonce-${nonce}';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    block-all-mixed-content;\n    upgrade-insecure-requests;\n`\n  const contentSecurityPolicyHeaderValue = cspHeader\n    .replace(/\\s{2,}/g, ' ')\n    .trim()\n \n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set('x-nonce', nonce)\n  requestHeaders.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  const response = NextResponse.next({\n    request: {\n      headers: requestHeaders,\n    },\n  })\n  response.headers.set(\n    'Content-Security-Policy',\n    contentSecurityPolicyHeaderValue\n  )\n \n  return response\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"中间件可以让你能够在页面渲染之前添加标题和随机数。每次查看页面时，都会生成一个新的随机数。这也意味着你必须使用动态渲染来添加随机数。"}),"\n",(0,s.jsxs)(n.p,{children:["默认情况下，中间件会在所有请求上运行，如果要运行在特定路径上，使用 matcher，具体参考小册",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7308914343129645065",target:"_blank",rel:"noopener noreferrer",children:"《路由篇 | 路由处理程序和中间件》"}),"。Next.js 建议忽略匹配 prefetch（来自 ",(0,s.jsx)(n.code,{children:"next/link"}),"）和静态资源，它们也不需要 CSP header。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// middleware.js\nexport const config = {\n  matcher: [\n    /*\n     * 匹配所有的请求路径，除了以这些开头的\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    {\n      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',\n      missing: [\n        { type: 'header', key: 'next-router-prefetch' },\n        { type: 'header', key: 'purpose', value: 'prefetch' },\n      ],\n    },\n  ],\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后你就可以在服务端组件中读取随机数，从而脚本组件正确执行："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// app/page.jsx\nimport { headers } from 'next/headers'\nimport Script from 'next/script'\n \nexport default function Page() {\n  const nonce = headers().get('x-nonce')\n \n  return (\n    <Script\n      src=\"https://www.googletagmanager.com/gtag/js\"\n      strategy=\"afterInteractive\"\n      nonce={nonce}\n    />\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP",target:"_blank",rel:"noopener noreferrer",children:"内容安全策略（CSP） - HTTP | MDN"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/configuring/draft-mode",target:"_blank",rel:"noopener noreferrer",children:"Configuring: Draft Mode | Next.js"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/configuring/content-security-policy",target:"_blank",rel:"noopener noreferrer",children:"Configuring: Content Security Policy | Next.js"})}),"\n"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F31.%E9%85%8D%E7%BD%AE%E7%AF%87%20_%20%E8%8D%89%E7%A8%BF%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. 草稿模式（Draft Mode）",id:"1-草稿模式draft-mode",depth:2},{text:"1.1. 介绍",id:"11-介绍",depth:3},{text:"1.2. 实现",id:"12-实现",depth:3},{text:"1.2.1. 创建并访问路由处理程序",id:"121-创建并访问路由处理程序",depth:4},{text:"1.2.2. 更新页面",id:"122-更新页面",depth:4},{text:"1.2.3. 其他",id:"123-其他",depth:4},{text:"2. 内容安全策略（Content Security Policy）",id:"2-内容安全策略content-security-policy",depth:2},{text:"2.1. HTTP CSP",id:"21-http-csp",depth:3},{text:"2.2. Next.js CSP",id:"22-nextjs-csp",depth:3},{text:"参考链接",id:"参考链接",depth:2}],title:"31.配置篇 _ 草稿模式和内容安全策略",headingTitle:"31.配置篇 _ 草稿模式和内容安全策略",frontmatter:{}}}}]);