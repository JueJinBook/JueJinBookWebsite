"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["91732"],{255181:function(e,n,s){e.exports=s.p+"static/image/6002649e0928cd38534a51ac9f6cb0ab.db79eba1.webp"},466290:function(e,n,s){e.exports=s.p+"static/image/e48918fff1784c1b08032e901f670d25.86326746.webp"},894872:function(e,n,s){s.r(n),s.d(n,{default:()=>X});var r=s(552676),a=s(740453);let t=s.p+"static/image/e4d09b8a699199492bdec6a366ba72ae.6b20b64f.webp",c=s.p+"static/image/81119a6fe56636db7af2a14b7a613260.2ef976e6.webp",i=s.p+"static/image/917a44eede6c9cafbec63a869ece5ad9.3404dc8e.webp",o=s.p+"static/image/afaccb3bb622a2ea077ed10a3223f1be.998e5381.webp",p=s.p+"static/image/ad4905b7a0e4b1d16db4e08b1fb16d21.1252b8d7.webp",d=s.p+"static/image/a5300033d975bd5d37f692bf86ba7d46.f4d8a76c.webp",l=s.p+"static/image/30cddf019189c558b2e9de6dea6c5e2e.84632f21.webp",h=s.p+"static/image/0935bff14af3b6b17fc5c2a02f9cd0bd.6f8f7233.webp",j=s.p+"static/image/3355bb6ca5c64ab408229ff4ce095304.95d5974a.webp",x=s.p+"static/image/58bb953863aec849a4d7aec65be23470.43f11433.webp",b=s.p+"static/image/f514a1b0fb5df479c1064f71aefbc412.4b8f42a8.webp",f=s.p+"static/image/0f073653a0ea48da553a0f8828ef7709.0dba8894.webp",g=s.p+"static/image/00b15619e44c6ddebb7670bab10bb147.1861acef.webp",m=s.p+"static/image/dfa1a3da446630894fd85233f7b48305.2ec12d96.webp",u=s.p+"static/image/90bb8527e66024a393973ceb6248b41c.245d47a0.webp",k=s.p+"static/image/96fba70491a27b4824973277c657f34b.a73d4a5a.webp",w=s.p+"static/image/9e1056f59dfb871ce8af7f16cfb2b26a.4006c28a.webp",A=s.p+"static/image/56b29bfd40222e849eba80a6c249e6ec.249a71ec.webp",v=s.p+"static/image/f5234e4b54564a8a3d7db7238a2a84c8.8f26b21b.webp",y=s.p+"static/image/8d37cbb595a27e804ed5f514e5d62f0f.5e0ee9da.webp",S=s.p+"static/image/2f47b51945f2b6acc73e41a55d18acd0.cd6308a6.webp",I=s.p+"static/image/c26b2038a20b1b798265b57ab7ceb660.406bd711.webp",_=s.p+"static/image/49df33573b6f34bd47aa1e6f15dbec1a.438bf8fd.webp",E=s.p+"static/image/f1bc4a4a4fdfc26cf00c05e6cc4a825a.a6d85e63.webp",B=s.p+"static/image/7843371b1770fbf7c46d80dd3044845b.f81f9b48.webp",M=s.p+"static/image/8faf9ecd4d151f5009bff0b7adac94fc.c7b847d3.webp",U=s.p+"static/image/047e17527e00e478bb05d51c030b5f31.f856ed63.webp",C=s.p+"static/image/cfc31f052a5b59323be531b7abefb3b4.5a08eeae.webp",P=s.p+"static/image/80acbd28d0517728b33932236bfb83eb.cfc1a500.webp",N=s.p+"static/image/402968e097f712c4c0896c72a54134ff.b6242647.webp",T=s.p+"static/image/d829c6bf4d060121a5fe787462c496d0.9ae65ece.webp",Y=s.p+"static/image/c59f0d722660d3b17a6caf803bb5ec7d.225b00d9.webp",D=s.p+"static/image/8dd0d3f549b3abb6cfaab31f6ede8cc4.bce297a4.webp",q=s.p+"static/image/f2ca3ebdd17ad17aa05e96003d341784.92629e76.webp",z=s.p+"static/image/75ffe75a7a7add2d61b4f6c58a59906d.64bfbd51.webp",J=s.p+"static/image/a430c041452d78dc63539ea06882e35a.d9dcb142.webp",G=s.p+"static/image/cd99878a814c4db16abd3366ca27b63c.237fd96b.webp",O=s.p+"static/image/11604cc4e22b880e5870bb5b619f87a1.ba4d59fb.webp",R=s.p+"static/image/15d578b1d0843037b858c760215f484e.08757699.webp",F=s.p+"static/image/7b11580ace351d37b2d3b71456d2e7ab.ae963c29.webp",L=s.p+"static/image/9bfc15decd1996fc98ed6bbd6aa92e8b.8fc9fa89.webp",V=s.p+"static/image/47816d0bd0df07e9b63f33d80d6267fc.cbfa1386.webp",K=s.p+"static/image/7c07f394c037b47bdb6328570061c073.346af702.webp";var Q=s(255181),H=s(466290);function W(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"71-基于-access_token-和-refresh_token-实现登录状态无感刷新",children:["71. 基于 access_token 和 refresh_token 实现登录状态无感刷新",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71-基于-access_token-和-refresh_token-实现登录状态无感刷新",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面我们实现了基于 JWT 的登录，流程是这样的："}),"\n",(0,r.jsx)(n.p,{children:"登录认证通过之后，把用户信息放到 jwt 里返回："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:H,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"访问接口的时候带上 jwt，在 Guard 里取出来判断是否有效，有效的话才能继续访问："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:Q,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但是这样有个问题："}),"\n",(0,r.jsx)(n.p,{children:"jwt 是有有效期的，我们设置的是 7 天，实际上为了安全考虑会设置的很短，比如 30 分钟。"}),"\n",(0,r.jsx)(n.p,{children:"这时候用户可能还在访问系统的某个页面，结果访问某个接口返回 token 失效了，让重新登录。"}),"\n",(0,r.jsx)(n.p,{children:"体验是不是就很差？"}),"\n",(0,r.jsx)(n.p,{children:"为了解决这个问题，服务端一般会返回两个 token：access_token 和 refresh_token"}),"\n",(0,r.jsx)(n.p,{children:"access_token 就是用来认证用户身份的，之前我们返回的就是这个 token。"}),"\n",(0,r.jsx)(n.p,{children:"而 refresh_token 是用来刷新 token 的，服务端会返回新的 access_token 和 refresh_token"}),"\n",(0,r.jsx)(n.p,{children:"也就是这样的流程："}),"\n",(0,r.jsx)(n.p,{children:"登录成功之后，返回两个 token："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:K,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"access_token 用来做登录鉴权："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:V,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而 refresh_token 用来刷新，拿到新 token："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:L,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"access_token 设置 30 分钟过期，而 refresh_token 设置 7 天过期。"}),"\n",(0,r.jsx)(n.p,{children:"这样 7 天内，如果 access_token 过期了，那就可以用 refresh_token 刷新下，拿到新 token。、"}),"\n",(0,r.jsx)(n.p,{children:"只要不超过 7 天未访问系统，就可以一直是登录状态，可以无限续签，不需要登录。"}),"\n",(0,r.jsx)(n.p,{children:"如果超过 7 天未访问系统，那 refresh_token 也就过期了，这时候就需要重新登录了。"}),"\n",(0,r.jsx)(n.p,{children:"想想你常用的 app，登录过几次？"}),"\n",(0,r.jsx)(n.p,{children:"是不是常用的 app 基本不用重新登录？"}),"\n",(0,r.jsx)(n.p,{children:"如果你超过一段时间没使用这个 app，是不是又会让你重新登录了？"}),"\n",(0,r.jsx)(n.p,{children:"一般 app 里用的就是这种双 token 来做登录鉴权。"}),"\n",(0,r.jsx)(n.p,{children:"下面我们也来实现下这种机制。"}),"\n",(0,r.jsx)(n.p,{children:"创建个 nest 项目："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest new access_token_and_refresh_token -p npm\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:F,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"添加 user 模块："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g resource user --no-spec\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"安装 typeorm 的依赖："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save @nestjs/typeorm typeorm mysql2\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 AppModule 引入 TypeOrmModule："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\n\n@Module({\n  imports: [ \n    TypeOrmModule.forRoot({\n      type: \"mysql\",\n      host: \"localhost\",\n      port: 3306,\n      username: \"root\",\n      password: \"guang\",\n      database: \"refresh_token_test\",\n      synchronize: true,\n      logging: true,\n      entities: [],\n      poolSize: 10,\n      connectorPackage: 'mysql2',\n      extra: {\n          authPlugin: 'sha256_password',\n      }\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 mysql workbench 里创建用到的 database："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"CREATE DATABASE refresh_token_test DEFAULT CHARACTER SET utf8mb4;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:O,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:G,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后新建 User 的 entity："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";\n\n@Entity()\nexport class User {\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column({\n        length: 50\n    })\n    username: string;\n\n    @Column({\n        length: 50\n    })\n    password: string;\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"在 entities 里添加 User："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:J,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后把服务跑起来："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run start:dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"会生成建表 sql："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:z,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在 mysql workbench 里可以看到 user 表："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:q,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后在 UserController 添加 login 的 post 接口："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Post('login')\nlogin(@Body() loginUser: LoginUserDto) {\n    console.log(loginUser);\n    return 'success';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"创建 src/user/dto/login-user.dto.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export class LoginUserDto {\n    username: string;\n    password: string;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:Y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后实现下登录逻辑。"}),"\n",(0,r.jsx)(n.p,{children:"在 UserService 里添加 login 方法："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { HttpException, HttpStatus, Injectable } from '@nestjs/common';\nimport { InjectEntityManager } from '@nestjs/typeorm';\nimport { EntityManager } from 'typeorm';\nimport { LoginUserDto } from './dto/login-user.dto';\nimport { User } from './entity/user.entity';\n\n@Injectable()\nexport class UserService {\n\n    @InjectEntityManager()\n    private entityManager: EntityManager;\n\n    async login(loginUserDto: LoginUserDto) {\n        const user = await this.entityManager.findOne(User, {\n            where: {\n                username: loginUserDto.username\n            }\n        });\n\n        if(!user) {\n            throw new HttpException('用户不存在', HttpStatus.OK);\n        }\n\n        if(user.password !== loginUserDto.password) {\n            throw new HttpException('密码错误', HttpStatus.OK);\n        }\n\n        return user;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后登录成功之后要返回两个 token"}),"\n",(0,r.jsx)(n.p,{children:"我们引入下 jwt 的包："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save @nestjs/jwt\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 AppModule 引入 JwtModule，设置为全局模块，指定默认过期时间和密钥："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"JwtModule.register({\n  global: true,\n  signOptions: {\n    expiresIn: '30m'\n  },\n  secret: 'guang'\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后在 UserController 生成两个 token 返回："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Inject(JwtService)\nprivate jwtService: JwtService;\n\n@Post('login')\nasync login(@Body() loginUser: LoginUserDto) {\n    const user = await this.userService.login(loginUser);\n\n    const access_token = this.jwtService.sign({\n      userId: user.id,\n      username: user.username,\n    }, {\n      expiresIn: '30m'\n    });\n\n    const refresh_token = this.jwtService.sign({\n      userId: user.id\n    }, {\n      expiresIn: '7d'\n    });\n\n    return {\n      access_token,\n      refresh_token\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"access_token 里存放 userId、username，refresh_token 里只存放 userId 就好了。"}),"\n",(0,r.jsx)(n.p,{children:"过期时间一个 30 分钟，一个 7 天。"}),"\n",(0,r.jsx)(n.p,{children:"访问下试试："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"接下来再实现 LoginGuard 来做登录鉴权："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g guard login --flat --no-spec\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"登录鉴权逻辑和之前一样："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { JwtService } from '@nestjs/jwt';\nimport { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';\nimport { Request } from 'express';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class LoginGuard implements CanActivate {\n\n  @Inject(JwtService)\n  private jwtService: JwtService;\n\n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n\n    const request: Request = context.switchToHttp().getRequest();\n\n    const authorization = request.headers.authorization;\n\n    if(!authorization) {\n      throw new UnauthorizedException('用户未登录');\n    }\n\n    try{\n      const token = authorization.split(' ')[1];\n      const data = this.jwtService.verify(token);\n\n      return true;\n    } catch(e) {\n      throw new UnauthorizedException('token 失效，请重新登录');\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"取出 authorization header 中的 jwt token，这个就是 access_token，对它做校验。"}),"\n",(0,r.jsx)(n.p,{children:"jwt 有效就可以继续访问，否则返回 token 失效，请重新登录。"}),"\n",(0,r.jsx)(n.p,{children:"然后在 AppController 添加个接口加上登录鉴权："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@Get('aaa')\naaa() {\n    return 'aaa';\n}\n\n@Get('bbb')\n@UseGuards(LoginGuard)\nbbb() {\n    return 'bbb';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"aaa 接口可以直接访问，bbb 接口需要登录后才能访问。"}),"\n",(0,r.jsx)(n.p,{children:"在 user 表添加条记录："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"INSERT INTO `refresh_token_test`.`user` (`id`, `username`, `password`)\n  VALUES ('1', 'guang', '123456');\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们测试一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:U,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"鉴权逻辑生效了。"}),"\n",(0,r.jsx)(n.p,{children:"然后我们登录下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:M,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"把 access_token 复制下来，加到 header 里再访问："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:B,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样就能访问了。"}),"\n",(0,r.jsx)(n.p,{children:"现在的 access_token 是 30 分钟过期，30分钟之后就需要重新登录了。"}),"\n",(0,r.jsx)(n.p,{children:"这样显然体验不好，接下来实现用 refresh_token 来刷新的逻辑："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"  @Get('refresh')\n  async refresh(@Query('refresh_token') refreshToken: string) {\n    try {\n      const data = this.jwtService.verify(refreshToken);\n\n      const user = await this.userService.findUserById(data.userId);\n\n      const access_token = this.jwtService.sign({\n        userId: user.id,\n        username: user.username,\n      }, {\n        expiresIn: '30m'\n      });\n\n      const refresh_token = this.jwtService.sign({\n        userId: user.id\n      }, {\n        expiresIn: '7d'\n      });\n\n      return {\n        access_token,\n        refresh_token\n      }\n    } catch(e) {\n      throw new UnauthorizedException('token 已失效，请重新登录');\n    }\n  }\n"})}),"\n",(0,r.jsx)(n.p,{children:"取出 refresh_token 里的 userId，从数据库中把 user 信息查出来，然后生成新的 access_token 和 refresh_token 返回。"}),"\n",(0,r.jsx)(n.p,{children:"如果 jwt 校验失败，就返回 token 已失效，请重新登录。"}),"\n",(0,r.jsx)(n.p,{children:"在 UserService 实现下这个 findUserById 的方法："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"async findUserById(userId: number) {\n    return await this.entityManager.findOne(User, {\n        where: {\n            id: userId\n        }\n    });\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:"带上有效的 refresh_token，能够拿到新的 access_token 和 refresh_token："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"refresh_token 失效或者错误时，会返回 401 的响应码，提示需要重新登录："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:_,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样，我们就实现了双 token 的登录鉴权机制。"}),"\n",(0,r.jsx)(n.p,{children:"只要 7 天内带上 refresh_token 来拿到新的 token，就可以一直保持登录状态。"}),"\n",(0,r.jsx)(n.p,{children:"那前端代码里访问接口的时候怎么用这俩 token 呢？"}),"\n",(0,r.jsx)(n.p,{children:"我们新建个 react 项目试一下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npx create-react-app --template=typescript refresh_token_test\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:I,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"安装 axios："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save axios\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 App.tsx 里访问下 /aaa、/bbb 接口："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\nfunction App() {\n  const [aaa, setAaa] = useState();\n  const [bbb, setBbb] = useState();\n\n  async function query() {\n    const { data: aaaData } = await axios.get('http://localhost:3000/aaa');\n    const { data: bbbData } = await axios.get('http://localhost:3000/bbb');\n\n    setAaa(aaaData);\n    setBbb(bbbData);\n  }\n  useEffect(() => {\n    query();\n  }, [])\n  \n\n  return (\n    <div>\n      <p>{aaa}</p>\n      <p>{bbb}</p>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(n.p,{children:"在服务端开启跨域支持："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"把开发服务跑起来："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run start\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到 /aaa 访问成功，返回了数据，/bbb 返回了 401"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这里请求两次是因为 index.tsx 里面有个 React.StrictMode，把它去掉就好了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们先登录一下，拿到 access_token，然后在请求的时候带上："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import axios from 'axios';\nimport { useEffect, useState } from 'react';\n\nfunction App() {\n  const [aaa, setAaa] = useState();\n  const [bbb, setBbb] = useState();\n\n  async function login() {\n    const res = await axios.post('http://localhost:3000/user/login', {\n        username: 'guang',\n        password: '123456'\n    });\n    localStorage.setItem('access_token', res.data.access_token);\n    localStorage.setItem('refresh_token', res.data.refresh_token);\n  }\n\n  async function query() {\n    await login();\n\n    const { data: aaaData } = await axios.get('http://localhost:3000/aaa');\n    const { data: bbbData } = await axios.get('http://localhost:3000/bbb', {\n      headers: {\n        Authorization: 'Bearer ' + localStorage.getItem('access_token') \n      }\n    });\n\n    setAaa(aaaData);\n    setBbb(bbbData);\n  }\n  useEffect(() => {\n    query();\n  }, [])\n  \n\n  return (\n    <div>\n      <p>{aaa}</p>\n      <p>{bbb}</p>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,r.jsx)(n.p,{children:"刷新下，可以看到现在请求了 3 个接口，bbb 也正确拿到了数据："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:k,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果很多接口都要添加这个 header，可以把它放在 interceptors 里做："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"axios.interceptors.request.use(function (config) {\n  const accessToken = localStorage.getItem('access_token');\n\n  if(accessToken) {\n    config.headers.authorization = 'Bearer ' + accessToken;\n  }\n  return config;\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"效果是一样的。"}),"\n",(0,r.jsx)(n.p,{children:"再就是当 token 失效的时候，要自动刷新，这个也可以在 interceptors 里做："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"\nasync function refreshToken() {\n  const res = await axios.get('http://localhost:3000/user/refresh', {\n      params: {\n        refresh_token: localStorage.getItem('refresh_token')\n      }\n  });\n  localStorage.setItem('access_token', res.data.access_token || '');\n  localStorage.setItem('refresh_token', res.data.refresh_token || '');\n  return res;\n}\n\naxios.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  async (error) => {\n    let { data, config } = error.response;\n\n    if (data.statusCode === 401 && !config.url.includes('/user/refresh')) {\n        \n      const res = await refreshToken();\n\n      if(res.status === 200) {\n        return axios(config);\n      } else {\n        alert('登录过期，请重新登录');\n        return Promise.reject(res.data)\n      }\n        \n    } else {\n      return error.response;\n    }\n  }\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:"如果返回的错误是 401 就刷新 token，这里要排除掉刷新的 url，刷新失败不继续刷新。"}),"\n",(0,r.jsx)(n.p,{children:"如果刷新接口返回的是 200，就用新 token 调用之前的接口"}),"\n",(0,r.jsx)(n.p,{children:"如果返回的是 401，那就返回这个错误。"}),"\n",(0,r.jsx)(n.p,{children:"判断下如果没有 access_token 才登录："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"if(!localStorage.getItem('access_token')) {\n  await login();\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后手动改下 access_token 的值，让它失效："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"刷新下页面："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"访问了 aaa、bbb 接口，bbb 接口 401 了，于是 refresh token，之后再次访问 bbb。"}),"\n",(0,r.jsx)(n.p,{children:"这样，我们就实现了 access_token 的无感刷新。"}),"\n",(0,r.jsx)(n.p,{children:"但这样还不完美，比如当并发多个请求的时候，如果都失效了，是不是要刷新多次?"}),"\n",(0,r.jsx)(n.p,{children:"我们加个并发请求试一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"await [\n  axios.get('http://localhost:3000/bbb'),\n  axios.get('http://localhost:3000/bbb'),\n  axios.get('http://localhost:3000/bbb')\n];\n"})}),"\n",(0,r.jsx)(n.p,{children:"手动让 access_token 失效，然后刷新页面："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"确实刷新了多次，并发的 3 次，还有后面又访问了一次："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"其实这样不处理也行，多刷几次也不影响功能。"}),"\n",(0,r.jsx)(n.p,{children:"但做的完美点还是要处理下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"加一个 refreshing 的标记，如果在刷新，那就返回一个 promise，并且把它的 resolve 方法还有 config 加到队列里。"}),"\n",(0,r.jsx)(n.p,{children:"当 refresh 成功之后，修改 refreshing 的值，重新发送队列中的请求，并且把结果通过 resolve 返回。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"interface PendingTask {\n  config: AxiosRequestConfig\n  resolve: Function\n}\nlet refreshing = false;\nconst queue: PendingTask[] = [];\n\naxios.interceptors.response.use(\n  (response) => {\n    return response;\n  },\n  async (error) => {\n    let { data, config } = error.response;\n\n    if(refreshing) {\n      return new Promise((resolve) => {\n          queue.push({\n              config,\n              resolve\n          });\n      });\n    }\n\n    if (data.statusCode === 401 && !config.url.includes('/user/refresh')) {\n        refreshing = true;\n\n        const res = await refreshToken();\n\n        refreshing = false;\n\n        if(res.status === 200) {\n\n          queue.forEach(({config, resolve}) => {\n              resolve(axios(config))\n          })\n  \n          return axios(config);\n        } else {\n          alert('登录过期，请重新登录');\n          return Promise.reject(res.data);\n        }\n        \n    } else {\n      return error.response;\n    }\n  }\n)\n"})}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:"手动让 access_token 失效然后刷新："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"现在就只刷新一次 token 了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"最后，为什么说双 token 会更安全呢？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"案例代码在小册仓库："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/access_token_and_refresh_token",target:"_blank",rel:"noopener noreferrer",children:"后端代码"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/refresh_token_test",target:"_blank",rel:"noopener noreferrer",children:"前端代码"})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节我们实现了基于 access_token 和 refresh_token 的无感刷新登录状态，也就是无感续签。"}),"\n",(0,r.jsx)(n.p,{children:"access_token 用于身份认证，refresh_token 用于刷新 token，也就是续签。"}),"\n",(0,r.jsx)(n.p,{children:"在登录接口里同时返回 access_token 和 refresh_token，access_token 设置较短的过期时间，比如 30 分钟，refresh_token 设置较长的过期时间，比如 7 天。"}),"\n",(0,r.jsx)(n.p,{children:"当 access_token 失效的时候，可以用 refresh_token 去刷新，服务端会根据其中的 userId 查询用户数据，返回新 token。"}),"\n",(0,r.jsx)(n.p,{children:"在前端代码里，可以在登录之后，把 token 放在 localstorage 里。"}),"\n",(0,r.jsx)(n.p,{children:"然后用 axios 的 interceptors.request 给请求时自动带上 authorization 的 header。"}),"\n",(0,r.jsx)(n.p,{children:"用 intercetpors.response 在响应是 401 的时候，自动访问 refreshToken 接口拿到新 token，然后再次访问失败的接口。"}),"\n",(0,r.jsx)(n.p,{children:"我们还支持了并发请求时，如果 token 过期，会把请求放到队列里，只刷新一次，刷新完批量重发请求。"}),"\n",(0,r.jsx)(n.p,{children:"这就是 token 无感刷新的前后端实现，是用的特别多的一种方案。"})]})}function Z(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(W,{...e})}):W(e)}let X=Z;Z.__RSPRESS_PAGE_META={},Z.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F71.%20%E5%9F%BA%E4%BA%8E%20access_token%20%E5%92%8C%20refresh_token%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"71. 基于 access_token 和 refresh_token 实现登录状态无感刷新",headingTitle:"71. 基于 access_token 和 refresh_token 实现登录状态无感刷新",frontmatter:{}}}}]);