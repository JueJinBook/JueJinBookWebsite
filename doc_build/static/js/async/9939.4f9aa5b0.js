"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["9939"],{736004:function(e,n,r){r.r(n),r.d(n,{default:()=>u});var s=r(552676),c=r(740453);let i=r.p+"static/image/fe486792780991693141e8bbbeda26b4.3a310a6c.webp",a=r.p+"static/image/9f3e23dde111b46a9d027c4e3be8d475.773e42ef.gif",d=r.p+"static/image/44845917a14c614c3095a7587bf43708.572a150a.gif",t=r.p+"static/image/6d812387ddf7c5117b905893f115fb79.27e2d269.webp",h=r.p+"static/image/d788edf0eb69816d5e21d0c5ea076a41.ed1ee178.gif",l=r.p+"static/image/3750ba7d6a7173aa834f735d20ac518f.b3fb1983.webp",j=r.p+"static/image/0a907c1560faf1b9fbcdfd9b977cbbac.e6bf4599.gif",x=r.p+"static/image/409d322a8353e0687ee4931d92062098.75f5281b.webp",o=r.p+"static/image/c9ce5726ade464bd8f5f4c22d2aade28.ef47413f.gif",p=r.p+"static/image/da9cd9695cf345f29a4e94a1c731e751.387fde93.gif";function g(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",img:"img",ul:"ul",li:"li",h3:"h3",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h4:"h4"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"12渲染篇-_-服务端渲染策略",children:["12.渲染篇 _ 服务端渲染策略",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12渲染篇-_-服务端渲染策略",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["现在让我们新建一个 ",(0,s.jsx)(n.code,{children:"app/server/page.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'export default async function Page() {\n  const url = (await (await fetch(\'https://api.thecatapi.com/v1/images/search\')).json())[0].url\n  \n  return (\n    <img src={url} width="300" alt="cat" />\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["其中，",(0,s.jsx)(n.a,{href:"https://api.thecatapi.com/v1/images/search",target:"_blank",rel:"noopener noreferrer",children:"https://api.thecatapi.com/v1/images/search"})," 是一个返回猫猫图片的接口，每次调用都会返回一张随机的猫猫图片数据。"]}),"\n",(0,s.jsxs)(n.p,{children:["现在让我们运行 ",(0,s.jsx)(n.code,{children:"npm run dev"}),"，开发模式下，每次刷新都会返回一张新的图片："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"strage.gif"})}),"\n",(0,s.jsxs)(n.p,{children:["现在让我们运行 ",(0,s.jsx)(n.code,{children:"npm run build && npm run start"}),"，然而此时每次刷新都还是这张 emo 的猫猫："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"strage-1.gif"})}),"\n",(0,s.jsx)(n.p,{children:"这是为什么呢？"}),"\n",(0,s.jsx)(n.p,{children:"让我们看下构建时的输出结果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:"截屏2024-03-06 18.18.43.png"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"/server"})," 被标记为 ",(0,s.jsx)(n.code,{children:"Static"}),"，表示被预渲染为静态内容。也就是说，",(0,s.jsx)(n.code,{children:"/server"}),"的返回内容其实在构建的时候就已经决定了。页面返回的图片正是构建时调用猫猫接口返回的那张图片。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么问题来了，如何让 ",(0,s.jsx)(n.code,{children:"/server"})," 每次都返回新的图片呢？"]}),"\n",(0,s.jsx)(n.p,{children:"这就要说到 Next.js 的服务端渲染策略了。"}),"\n",(0,s.jsxs)(n.h2,{id:"服务端渲染策略",children:["服务端渲染策略",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务端渲染策略",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Next.js 存在三种不同的服务端渲染策略："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"静态渲染"}),"\n",(0,s.jsx)(n.li,{children:"动态渲染"}),"\n",(0,s.jsx)(n.li,{children:"Streaming"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"我们来一一介绍。"}),"\n",(0,s.jsxs)(n.h3,{id:"1-静态渲染static-rendering",children:["1. 静态渲染（Static Rendering）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-静态渲染static-rendering",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"这是默认渲染策略"}),"，",(0,s.jsx)(n.strong,{children:"路由在构建时渲染，或者在重新验证后后台渲染"}),"，其结果会被缓存并且可以推送到 CDN。适用于未针对用户个性化且数据已知的情况，比如静态博客文章、产品介绍页面等。"]}),"\n",(0,s.jsx)(n.p,{children:"开头中的例子就是构建时渲染。那么如何在重新验证后后台渲染呢？"}),"\n",(0,s.jsxs)(n.p,{children:["具体重新验证的方法我们会在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-9",target:"_blank",rel:"noopener noreferrer",children:"《缓存篇 | Caching》"}),"中详细介绍。这里为了举例说一种 —— 使用路由段配置项 ",(0,s.jsx)(n.code,{children:"revalidate"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"app/server/page.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'export const revalidate = 10\n\nexport default async function Page() {\n\n  const url = (await (await fetch(\'https://api.thecatapi.com/v1/images/search\')).json())[0].url\n  \n  return (\n    <img src={url} width="300" alt="cat" />\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["此时虽然在 ",(0,s.jsx)(n.code,{children:"npm run build"}),"的输出中，",(0,s.jsx)(n.code,{children:"/server"}),"依然是标记为静态渲染，但图片已经可以更新了，虽然每隔一段时间才更新："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:"strage-3.gif"})}),"\n",(0,s.jsxs)(n.p,{children:["其中 ",(0,s.jsx)(n.code,{children:"revalidate=10"}),"表示设置重新验证频率为 10s，但是要注意："]}),"\n",(0,s.jsxs)(n.p,{children:["这句代码的效果并不是设置服务器每 10s 会自动更新一次 ",(0,s.jsx)(n.code,{children:"/server"}),"。而是至少 10s 后进行重新验证。"]}),"\n",(0,s.jsxs)(n.p,{children:["举个例子，假设你现在访问了 ",(0,s.jsx)(n.code,{children:"/server"}),"，此时时间设为 0s，10s 内持续访问，",(0,s.jsx)(n.code,{children:"/server"})," 返回的都是之前缓存的结果。当 10s 过后，假设你第 12s 又访问了一次 ",(0,s.jsx)(n.code,{children:"/server"}),"，此时虽然超过了 10s，但依然会返回之前缓存的结果，但同时会触发服务器更新缓存，当你第 13s 再次访问的时候，就是更新后的结果。"]}),"\n",(0,s.jsx)(n.p,{children:"简单来说，超过 revalidate 设置时间的首次访问会触发缓存更新，如果更新成功，后续的返回就都是新的内容，直到下一次触发缓存更新。"}),"\n",(0,s.jsxs)(n.h3,{id:"2-动态渲染dynamic-rendering",children:["2. 动态渲染（Dynamic Rendering）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-动态渲染dynamic-rendering",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"路由在请求时渲染，适用于针对用户个性化或依赖请求中的信息（如 cookie、URL 参数）的情况。"}),"\n",(0,s.jsxs)(n.p,{children:["在渲染过程中，",(0,s.jsx)(n.strong,{children:"如果使用了动态函数（Dynamic functions）或者未缓存的数据请求（uncached data request），Next.js 就会切换为动态渲染"}),"："]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"动态函数"}),"\n",(0,s.jsx)(n.th,{children:"数据缓存"}),"\n",(0,s.jsx)(n.th,{children:"渲染策略"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"否"}),"\n",(0,s.jsx)(n.td,{children:"缓存"}),"\n",(0,s.jsx)(n.td,{children:"静态渲染"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"是"}),"\n",(0,s.jsx)(n.td,{children:"缓存"}),"\n",(0,s.jsx)(n.td,{children:"动态渲染"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"否"}),"\n",(0,s.jsx)(n.td,{children:"未缓存"}),"\n",(0,s.jsx)(n.td,{children:"动态渲染"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:"是"}),"\n",(0,s.jsx)(n.td,{children:"未缓存"}),"\n",(0,s.jsx)(n.td,{children:"动态渲染"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"注意：作为开发者，无须选择静态还是动态渲染，Next.js 会自动根据使用的功能和 API 为每个路由选择最佳的渲染策略"}),"\n",(0,s.jsxs)(n.h4,{id:"21-使用动态函数dynamic-functions",children:["2.1. 使用动态函数（Dynamic functions）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-使用动态函数dynamic-functions",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"动态函数指的是获取只有在请求时才能得到信息（如 cookie、请求头、URL 参数）的函数"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"在 Next.js 中这些动态函数是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-7",target:"_blank",rel:"noopener noreferrer",children:"cookies()"})," 和 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-20",target:"_blank",rel:"noopener noreferrer",children:"headers()"})," ：获取 cookie 和 header"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"searchParams"}),"：页面查询参数"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"使用这些函数的任意一个，都会导致路由转为动态渲染。"}),"\n",(0,s.jsxs)(n.p,{children:["第一个例子，修改 ",(0,s.jsx)(n.code,{children:"app/server/page.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { cookies } from 'next/headers'\n\nexport default async function Page() {\n\n  const cookieStore = cookies()\n  const theme = cookieStore.get('theme')\n\n  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search')).json())[0].url\n  \n  return (\n    <img src={url} width=\"300\" alt=\"cat\" />\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["运行 ",(0,s.jsx)(n.code,{children:"npm run build && npm run start"}),"，此时 ",(0,s.jsx)(n.code,{children:"/server"}),"显示为动态渲染："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"截屏2024-03-06 19.09.30.png"})}),"\n",(0,s.jsx)(n.p,{children:"访问效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"strage-4.gif"})}),"\n",(0,s.jsxs)(n.p,{children:["第二个例子，使用 searchParams，修改 ",(0,s.jsx)(n.code,{children:"app/server/page.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'export default async function Page({ searchParams }) {\n  const url = (await (await fetch(\'https://api.thecatapi.com/v1/images/search\')).json())[0].url\n  return (\n    <>\n      <img src={url} width="300" alt="cat" />\n      {new Date().toLocaleTimeString()}\n      {JSON.stringify(searchParams)}\n    </>\n  )\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["运行 ",(0,s.jsx)(n.code,{children:"npm run build && npm run start"}),"，此时 ",(0,s.jsx)(n.code,{children:"/server"}),"显示为动态渲染："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"截屏2024-03-06 20.57.25.png"})}),"\n",(0,s.jsx)(n.p,{children:"但是图片却没有在页面刷新的时候改变（此时又是一只 emo 的猫猫）："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"strage-5.gif"})}),"\n",(0,s.jsx)(n.p,{children:"页面确实是动态渲染，因为每次刷新时间都发生了改变。但为什么图片没有更新呢？"}),"\n",(0,s.jsx)(n.p,{children:"这是因为动态渲染和数据请求缓存是两件事情，页面动态渲染并不代表页面涉及的请求一定不被缓存。正是因为 fetch 接口的返回数据被缓存了，这才导致了图片每次都是这一张。"}),"\n",(0,s.jsxs)(n.p,{children:["修改 ",(0,s.jsx)(n.code,{children:"app/server/page.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export default async function Page({ searchParams }) {\n  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search', { cache: 'no-store' })).json())[0].url\n  return (\n    <>\n      <img src={url} width=\"300\" alt=\"cat\" />\n      {new Date().toLocaleTimeString()}\n      {JSON.stringify(searchParams)}\n    </>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们为 fetch 请求添加了 ",(0,s.jsx)(n.code,{children:"{ cache: 'no-store' }"}),"，使 fetch 请求退出了缓存。此时运行生产版本，图片和时间在刷新的时候都会改变："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"strage-6.gif"})}),"\n",(0,s.jsx)(n.p,{children:"注：同样是转为动态渲染，为什么使用 cookies 的时候，fetch 请求没有被缓存呢？这就是接下来要讲的内容。"}),"\n",(0,s.jsxs)(n.p,{children:["当你在 ",(0,s.jsx)(n.code,{children:"headers"})," 或 ",(0,s.jsx)(n.code,{children:"cookies"})," 方法之后使用 fetch 请求会导致请求退出缓存，这是 Next.js 的自动逻辑，但还有哪些情况导致 fetch 请求自动退出缓存呢？让我们往下看。"]}),"\n",(0,s.jsxs)(n.h4,{id:"22-使用未缓存的数据请求uncached-data-request",children:["2.2. 使用未缓存的数据请求（uncached data request）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-使用未缓存的数据请求uncached-data-request",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 Next.js 中，fetch 请求的结果默认会被缓存，但你可以设置退出缓存，一旦你设置了退出缓存，就意味着使用了未缓存的数据请求（uncached data request），会导致路由进入动态渲染，如："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetch"})," 请求添加了 ",(0,s.jsx)(n.code,{children:"cache: 'no-store'"}),"选项"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetch"})," 请求添加了 ",(0,s.jsx)(n.code,{children:"revalidate: 0"}),"选项"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetch"})," 请求在路由处理程序中并使用了 ",(0,s.jsx)(n.code,{children:"POST"})," 方法"]}),"\n",(0,s.jsxs)(n.li,{children:["在",(0,s.jsx)(n.code,{children:"headers"})," 或 ",(0,s.jsx)(n.code,{children:"cookies"})," 方法之后使用 ",(0,s.jsx)(n.code,{children:"fetch"}),"请求"]}),"\n",(0,s.jsxs)(n.li,{children:["配置了路由段选项 ",(0,s.jsx)(n.code,{children:"const dynamic = 'force-dynamic'"})]}),"\n",(0,s.jsxs)(n.li,{children:["配置了路由段选项",(0,s.jsx)(n.code,{children:"fetchCache"})," ，默认会跳过缓存"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fetch"})," 请求使用了 ",(0,s.jsx)(n.code,{children:"Authorization"}),"或者 ",(0,s.jsx)(n.code,{children:"Cookie"}),"请求头，并且在组件树中其上方还有一个未缓存的请求"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["注：关于数据请求，具体我们还会在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309076949182709811",target:"_blank",rel:"noopener noreferrer",children:"《数据获取篇 | 数据获取、缓存与重新验证》"}),"中详细介绍。"]}),"\n",(0,s.jsxs)(n.p,{children:["举个例子，修改 ",(0,s.jsx)(n.code,{children:"app/server/page.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export default async function Page() {\n  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search', { cache: 'no-store' })).json())[0].url\n  return (\n    <>\n      <img src={url} width=\"300\" alt=\"cat\" />\n      {new Date().toLocaleTimeString()}\n    </>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时页面会转为动态渲染，每次刷新页面都会出现新的图片。"}),"\n",(0,s.jsx)(n.p,{children:"关于动态渲染再重申一遍：数据缓存和渲染策略是分开的。假如你选择了动态渲染，Next.js 会在请求的时候再渲染 RSC Payload 和 HTML，但其中涉及的数据请求，依然是可以从缓存中获取的。"}),"\n",(0,s.jsxs)(n.h3,{id:"3-streaming",children:["3. Streaming",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-streaming",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"loading.js"})," 或者 React Suspense 组件会开启 Streaming。具体参考小册",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7342436717142409242",target:"_blank",rel:"noopener noreferrer",children:"《渲染篇 | Suspense 与 Streaming》"})]}),"\n",(0,s.jsxs)(n.h2,{id:"其他术语防混淆",children:["其他术语防混淆",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其他术语防混淆",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"除了静态渲染、动态渲染、动态函数、未缓存数据请求等术语，阅读官方文档的时候，你还可能遇到局部渲染、动态路由等这些与“渲染”、“动态”、“静态”有关的词，所以我们在这里列出来帮助大家区分。"}),"\n",(0,s.jsxs)(n.h3,{id:"1-局部渲染partial-rendering",children:["1. 局部渲染（Partial rendering）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-局部渲染partial-rendering",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["局部渲染指的是仅在客户端重新渲染导航时更改的路由段，共享段的内容的继续保留。举个例子，当在两个相邻的路由间导航的时候, ",(0,s.jsx)(n.code,{children:"/dashboard/settings"})," 和 ",(0,s.jsx)(n.code,{children:"/dashboard/analytics"}),"，",(0,s.jsx)(n.code,{children:"settings"})," 和 ",(0,s.jsx)(n.code,{children:"analytics"})," 页面会重新渲染，共享的 ",(0,s.jsx)(n.code,{children:"dashboard"})," 布局会保留。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"局部渲染的目的也是为了减少路由切换时的传输数据量和执行时间，从而提高性能。"}),"\n",(0,s.jsxs)(n.h3,{id:"2-动态路由dynamic-routes",children:["2. 动态路由（Dynamic Routes）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-动态路由dynamic-routes",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["动态路由我们在小册",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7308693561648611379",target:"_blank",rel:"noopener noreferrer",children:"《路由篇 | 动态路由、路由组、平行路由和拦截路由》"}),"中讲过："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export default function Page({ params }) {\n  return <div>My Post: {params.slug}</div>\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["动态路由并不一定是动态渲染，你也可以用 ",(0,s.jsx)(n.code,{children:"generateStaticParams"}),"静态生成路由。"]}),"\n",(0,s.jsx)(n.p,{children:"但有的时候，动态路由（Dynamic Routes）会用来表达“动态渲染的路由”（dynamically rendered routes）这个意思。在官网中，很少用到静态路由（Static Routes）这个词，用到的时候是用来表达“静态渲染的路由”（statically rendered routes）。"}),"\n",(0,s.jsxs)(n.h3,{id:"3-动态段dynamic-segment",children:["3. 动态段（Dynamic Segment）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-动态段dynamic-segment",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["路由中的动态段，举个例子，",(0,s.jsx)(n.code,{children:"app/blog/[slug]/page.js"}),"中 ",(0,s.jsx)(n.code,{children:"[slug]"}),"就是动态段。"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"恭喜你，完成了本篇内容的学习！"}),"\n",(0,s.jsx)(n.p,{children:"这篇我们介绍了服务端渲染的三种策略。至此，渲染篇基本介绍完毕，我们开始进入数据获取篇！"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(g,{...e})}):g(e)}let u=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F12.%E6%B8%B2%E6%9F%93%E7%AF%87%20_%20%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%AD%96%E7%95%A5.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"服务端渲染策略",id:"服务端渲染策略",depth:2},{text:"1. 静态渲染（Static Rendering）",id:"1-静态渲染static-rendering",depth:3},{text:"2. 动态渲染（Dynamic Rendering）",id:"2-动态渲染dynamic-rendering",depth:3},{text:"2.1. 使用动态函数（Dynamic functions）",id:"21-使用动态函数dynamic-functions",depth:4},{text:"2.2. 使用未缓存的数据请求（uncached data request）",id:"22-使用未缓存的数据请求uncached-data-request",depth:4},{text:"3. Streaming",id:"3-streaming",depth:3},{text:"其他术语防混淆",id:"其他术语防混淆",depth:2},{text:"1. 局部渲染（Partial rendering）",id:"1-局部渲染partial-rendering",depth:3},{text:"2. 动态路由（Dynamic Routes）",id:"2-动态路由dynamic-routes",depth:3},{text:"3. 动态段（Dynamic Segment）",id:"3-动态段dynamic-segment",depth:3},{text:"小结",id:"小结",depth:2}],title:"12.渲染篇 _ 服务端渲染策略",headingTitle:"12.渲染篇 _ 服务端渲染策略",frontmatter:{}}}}]);