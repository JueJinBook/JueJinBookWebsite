"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["90765"],{909424:function(e,s,n){n.r(s),n.d(s,{default:()=>t});var r=n(552676),l=n(740453);let c=n.p+"static/image/919fe40a5d46edf006f6974782db314c.63b04ea2.webp",d=n.p+"static/image/1daf2e83e5afc3510f734f69f02e7137.e76b78d7.webp",i=n.p+"static/image/638a8c880593fc04d43fccbe3a5dc903.fe47c908.webp";function o(e){let s=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",h2:"h2",img:"img",blockquote:"blockquote",pre:"pre",ol:"ol",strong:"strong"},(0,l.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(s.h1,{id:"4如何借助预处理器postcss-等构建现代-css-工程环境",children:["4.如何借助预处理器、PostCSS 等构建现代 CSS 工程环境？",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#4如何借助预处理器postcss-等构建现代-css-工程环境",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"在开发 Web 应用时，我们通常需要编写大量 JavaScript 代码 —— 用于控制页面逻辑；编写大量 CSS 代码 —— 用于调整页面呈现形式。问题在于，CSS 语言在过去若干年中一直在追求样式表现力方面的提升，工程化能力薄弱，例如缺乏成熟的模块化机制、依赖处理能力、逻辑判断能力等。为此，在开发现代大型 Web 应用时，通常会使用 Webpack 配合其它预处理器编写样式代码。"}),"\n",(0,r.jsx)(s.p,{children:"本章主要介绍 Webpack 中如何使用 CSS 代码处理工具，包括："}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["如何使用 ",(0,r.jsx)(s.code,{children:"css-loader"}),"、",(0,r.jsx)(s.code,{children:"style-loader"}),"、",(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})," 处理原生 CSS 文件？"]}),"\n",(0,r.jsx)(s.li,{children:"如何使用 Less/Sass/Stylus 预处理器？"}),"\n",(0,r.jsx)(s.li,{children:"如何使用 PostCSS ？"}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"webpack-如何处理-css-资源",children:["Webpack 如何处理 CSS 资源？",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#webpack-如何处理-css-资源",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["原生 Webpack 并不能识别 CSS 语法，假如不做额外配置直接导入 ",(0,r.jsx)(s.code,{children:".css"})," 文件，会导致编译失败："]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(s.p,{children:"为此，在 Webpack 中处理 CSS 文件，通常需要用到："}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://webpack.js.org/loaders/css-loader/",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(s.code,{children:"css-loader"})}),"：该 Loader 会将 CSS 等价翻译为形如 ",(0,r.jsx)(s.code,{children:'module.exports = "${css}"'})," 的JavaScript 代码，使得 Webpack 能够如同处理 JS 代码一样解析 CSS 内容与资源依赖；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://webpack.js.org/loaders/style-loader/",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(s.code,{children:"style-loader"})}),"：该 Loader 将在产物中注入一系列 runtime 代码，这些代码会将 CSS 内容注入到页面的 ",(0,r.jsx)(s.code,{children:"<style>"})," 标签，使得样式生效；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://webpack.js.org/plugins/mini-css-extract-plugin",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})}),"：该插件会将 CSS 代码抽离到单独的 ",(0,r.jsx)(s.code,{children:".css"})," 文件，并将文件通过 ",(0,r.jsx)(s.code,{children:"<link>"})," 标签方式插入到页面中。"]}),"\n"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["PS：当 Webpack 版本低于 5.0 时，请使用 ",(0,r.jsx)(s.a,{href:"https://www.npmjs.com/package/extract-text-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(s.code,{children:"extract-text-webpack-plugin"})})," 代替 ",(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["三种组件各司其职：",(0,r.jsx)(s.code,{children:"css-loader"})," 让 Webpack 能够正确理解 CSS 代码、分析资源依赖；",(0,r.jsx)(s.code,{children:"style-loader"}),"、",(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})," 则通过适当方式将 CSS 插入到页面，对页面样式产生影响："]}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(s.p,{children:["下面我们先从 ",(0,r.jsx)(s.code,{children:"css-loader"})," 聊起，",(0,r.jsx)(s.code,{children:"css-loader"})," 提供了很多处理 CSS 代码的基础能力，包括 CSS 到 JS 转译、依赖解析、Sourcemap、css-in-module 等，基于这些能力，Webpack 才能像处理 JS 模块一样处理 CSS 模块代码。接入时首先需要安装依赖："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"yarn add -D css-loader\n"})}),"\n",(0,r.jsxs)(s.p,{children:["之后修改 Webpack 配置，定义 ",(0,r.jsx)(s.code,{children:".css"})," 规则："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: ["css-loader"],\n      },\n    ],\n  },\n};\n'})}),"\n",(0,r.jsxs)(s.p,{children:["此后，执行 ",(0,r.jsx)(s.code,{children:"npx webpack"})," 或其它构建命令即可。经过 ",(0,r.jsx)(s.code,{children:"css-loader"})," 处理后，样式代码最终会被转译成一段 JS 字符串："]}),"\n",(0,r.jsx)(s.p,{children:"但这段字符串只是被当作普通 JS 模块处理，并不会实际影响到页面样式，后续还需要："}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"开发环境"}),"：使用 ",(0,r.jsx)(s.code,{children:"style-loader"})," 将样式代码注入到页面 ",(0,r.jsx)(s.code,{children:"<style>"})," 标签；"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"生产环境"}),"：使用 ",(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})," 将样式代码抽离到单独产物文件，并以 ",(0,r.jsx)(s.code,{children:"<link>"})," 标签方式引入到页面中。"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["经过 ",(0,r.jsx)(s.code,{children:"css-loader"})," 处理后，CSS 代码会被转译为等价 JS 字符串，但这些字符串还不会对页面样式产生影响，需要继续接入 ",(0,r.jsx)(s.code,{children:"style-loader"})," 加载器。"]}),"\n",(0,r.jsxs)(s.p,{children:["与其它 Loader 不同，",(0,r.jsx)(s.code,{children:"style-loader"})," 并不会对代码内容做任何修改，而是简单注入一系列运行时代码，用于将 ",(0,r.jsx)(s.code,{children:"css-loader"})," 转译出的 JS 字符串插入到页面的 ",(0,r.jsx)(s.code,{children:"style"})," 标签。接入时同样需要安装依赖："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"yarn add -D style-loader css-loader\n"})}),"\n",(0,r.jsxs)(s.p,{children:["之后修改 Webpack 配置，定义 ",(0,r.jsx)(s.code,{children:".css"})," 规则："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: ["style-loader", "css-loader"],\n      },\n    ],\n  },\n};\n'})}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsxs)(s.p,{children:["PS：注意保持 ",(0,r.jsx)(s.code,{children:"style-loader"})," 在前，",(0,r.jsx)(s.code,{children:"css-loader"})," 在后"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["上述配置语义上相当于 ",(0,r.jsx)(s.code,{children:"style-loader(css-loader(css))"})," 链式调用，执行后样式代码会被转译为类似下面这样的代码："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:'// Part1: css-loader 处理结果，对标到原始 CSS 代码\nconst __WEBPACK_DEFAULT_EXPORT__ = (\n"body {\\n    background: yellow;\\n    font-weight: bold;\\n}"\n);\n// Part2: style-loader 处理结果，将 CSS 代码注入到 `style` 标签\ninjectStylesIntoStyleTag(\n __WEBPACK_DEFAULT_EXPORT__\n)\n'})}),"\n",(0,r.jsxs)(s.p,{children:["至此，运行页面触发 ",(0,r.jsx)(s.code,{children:"injectStylesIntoStyleTag"})," 函数将 CSS 代码注入到 ",(0,r.jsx)(s.code,{children:"<style>"})," 标签，样式才真正开始生效。例如："]}),"\n",(0,r.jsx)(s.p,{children:"页面运行效果："}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(s.p,{children:["经过 ",(0,r.jsx)(s.code,{children:"style-loader"})," + ",(0,r.jsx)(s.code,{children:"css-loader"})," 处理后，样式代码最终会被写入 Bundle 文件，并在运行时通过 ",(0,r.jsx)(s.code,{children:"style"})," 标签注入到页面。这种将 JS、CSS 代码合并进同一个产物文件的方式有几个问题："]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"JS、CSS 资源无法并行加载，从而降低页面性能；"}),"\n",(0,r.jsx)(s.li,{children:"资源缓存粒度变大，JS、CSS 任意一种变更都会致使缓存失效。"}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["因此，生产环境中通常会用 ",(0,r.jsx)(s.a,{href:"https://webpack.js.org/plugins/mini-css-extract-plugin",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})})," 插件替代 ",(0,r.jsx)(s.code,{children:"style-loader"}),"，将样式代码抽离成单独的 CSS 文件。使用时，首先需要安装依赖："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"yarn add -D mini-css-extract-plugin\n"})}),"\n",(0,r.jsx)(s.p,{children:"之后，添加配置信息："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:"const MiniCssExtractPlugin = require('mini-css-extract-plugin')\nconst HTMLWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    module: {\n        rules: [{\n            test: /\\.css$/,\n            use: [\n                // 根据运行环境判断使用那个 loader\n                (process.env.NODE_ENV === 'development' ?\n                    'style-loader' :\n                    MiniCssExtractPlugin.loader),\n                'css-loader'\n            ]\n        }]\n    },\n    plugins: [\n        new MiniCssExtractPlugin(),\n        new HTMLWebpackPlugin()\n    ]\n}\n"})}),"\n",(0,r.jsx)(s.p,{children:"这里需要注意几个点："}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})," 库同时提供 Loader、Plugin 组件，需要同时使用"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})," 不能与 ",(0,r.jsx)(s.code,{children:"style-loader"})," 混用，否则报错，所以上述示例中第 9 行需要判断 ",(0,r.jsx)(s.code,{children:"process.env.NODE_ENV"})," 环境变量决定使用那个 Loader"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})," 需要与 ",(0,r.jsx)(s.code,{children:"html-webpack-plugin"})," 同时使用，才能将产物路径以 ",(0,r.jsx)(s.code,{children:"link"})," 标签方式插入到 html 中"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"至此，运行 Webpack 后将同时生成 JS、CSS、HTML 三种产物文件，如："}),"\n",(0,r.jsx)(s.p,{children:"可以看到，样式代码会被抽离到单独的 CSS 文件，并且在最终生成的 html 中包含了指向 JS、CSS 两种资源的标签："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-html",children:'<script defer src="main.js"><\/script>\n<link href="main.css" rel="stylesheet">\n'})}),"\n",(0,r.jsxs)(s.p,{children:["综上，在 Webpack 中处理 CSS，通常需要使用 ",(0,r.jsx)(s.code,{children:"css-loader + style-loader"})," 或 ",(0,r.jsx)(s.code,{children:"css-loader + mini-css-extract-plugin"})," 组合，两种方式最终都能实现加载样式代码的效果。但鉴于原生 CSS 语言的种种缺陷，我们还可以在此基础上增加更多 Webpack 组件，更优雅、高效地编写页面样式，下面一一展开介绍。"]}),"\n",(0,r.jsxs)(s.h2,{id:"使用预处理器",children:["使用预处理器",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#使用预处理器",children:"#"})]}),"\n",(0,r.jsx)(s.p,{children:"CSS —— Cascading Style Sheet-级联样式表，最初设计用于描述 Web 界面样式的描述性语言，经过这么多年的发展其样式表现力已经突飞猛进，但核心功能、基本语法没有发生太大变化，至今依然没有提供诸如循环、分支判断、扩展复用、函数、嵌套之类的特性，以至于原生 CSS 已经难以应对当代复杂 Web 应用的开发需求。"}),"\n",(0,r.jsxs)(s.p,{children:["为此，社区在 CSS 原生语法基础上扩展出一些更易用，功能更强大的 CSS 预处理器(Preprocessor)，比较知名的有 ",(0,r.jsx)(s.a,{href:"https://lesscss.org/",target:"_blank",rel:"noopener noreferrer",children:"Less"}),"、",(0,r.jsx)(s.a,{href:"https://sass-lang.com/",target:"_blank",rel:"noopener noreferrer",children:"Sass"}),"、",(0,r.jsx)(s.a,{href:"https://stylus-lang.com/",target:"_blank",rel:"noopener noreferrer",children:"Stylus"})," 。这些工具各有侧重，但都在 CSS 之上补充了扩展了一些逻辑判断、数学运算、嵌套封装等特性，基于这些特性，我们能写出复用性、可读性、可维护性更强，条理与结构更清晰的样式代码，以 Less 为例："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-less",children:"// 变量\n@size: 12px;\n@color: #006633;\n\n// 混合\n.mx-bordered() {\n    border: 1px solid #000;\n}\n\n// 嵌套\nbody {\n    // 函数计算\n    background: spin(lighten(@color, 25%), 8);\n    font-weight: bold;\n    padding: @size;\n\n    .main {\n        // 数学运算\n        font-size: @size * 2;\n        .mx-bordered;\n        color: darken(@color, 10%);\n        padding: @size * 0.6;\n    }\n}\n"})}),"\n",(0,r.jsx)(s.p,{children:"在 Webpack 中只需使用适当 Loader 即可接入预处理器，以 Less 为例，首先安装依赖："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"yarn add -D less less-loader\n"})}),"\n",(0,r.jsxs)(s.p,{children:["其次，修改 Webpack 配置，添加 ",(0,r.jsx)(s.code,{children:".less"})," 处理规则："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:"module.exports = {\n    module: {\n        rules: [{\n            test: /\\.less$/,\n            use: [\n                'style-loader',\n                'css-loader',\n                'less-loader'\n            ]\n        }]\n    }\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["可以看到这里需要同时使用三种 Loader，其中 ",(0,r.jsx)(s.code,{children:"less-loader"})," 用于将 Less 代码转换为 CSS 代码，上述示例转换结果："]}),"\n",(0,r.jsxs)(s.p,{children:["这段 CSS 随后会被 ",(0,r.jsx)(s.code,{children:"css-loader"})," 与 ",(0,r.jsx)(s.code,{children:"style-loader"})," 处理，最终在页面生效。"]}),"\n",(0,r.jsx)(s.p,{children:"目前，社区比较流行的预处理器框架有：Less、Sass、Stylus，它们接入 Webpack 的方式非常相似："}),"\n",(0,r.jsx)(s.p,{children:"大家可根据项目背景选择接入适当的预处理器框架。"}),"\n",(0,r.jsxs)(s.h2,{id:"使用-post-css",children:["使用 post-css",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-post-css",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["与上面介绍的 Less/Sass/Stylus 这一类预处理器类似，PostCSS 也能在原生 CSS 基础上增加更多表达力、可维护性、可读性更强的语言特性。两者主要区别在于预处理器通常定义了一套 CSS 之上的超集语言；PostCSS 并没有定义一门新的语言，而是与 ",(0,r.jsx)(s.code,{children:"@babel/core"})," 类似，只是实现了一套将 CSS 源码解析为 AST 结构，并传入 PostCSS 插件做处理的流程框架，具体功能都由插件实现。"]}),"\n",(0,r.jsxs)(s.blockquote,{children:["\n",(0,r.jsx)(s.p,{children:"预处理器之于 CSS，就像 TypeScript 与 JavaScript 的关系；而 PostCSS 之于 CSS，则更像 Babel 与 JavaScript。"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"PostCSS 的接入步骤也很简单，首先安装依赖："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"yarn add -D postcss postcss-loader\n"})}),"\n",(0,r.jsx)(s.p,{children:"之后添加 Webpack 配置："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          "style-loader", \n          "css-loader", \n          "postcss-loader"\n        ],\n      },\n    ],\n  }\n};\n'})}),"\n",(0,r.jsxs)(s.p,{children:["不过，这个时候的 PostCSS 还只是个空壳，下一步还需要使用适当的 PostCSS 插件进行具体的功能处理，例如我们可以使用 ",(0,r.jsx)(s.a,{href:"https://github.com/postcss/autoprefixer",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(s.code,{children:"autoprefixer"})})," 插件自动添加浏览器前缀，首先安装依赖："]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"yarn add -D autoprefixer\n"})}),"\n",(0,r.jsx)(s.p,{children:"之后，修改 Webpack 配置："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          "style-loader", \n          {\n            loader: "css-loader",            \n            options: {\n              importLoaders: 1\n            }\n          }, \n          {\n            loader: "postcss-loader",\n            options: {\n              postcssOptions: {\n                // 添加 autoprefixer 插件\n                plugins: [require("autoprefixer")],\n              },\n            },\n          }\n        ],\n      },\n    ],\n  }\n};\n'})}),"\n",(0,r.jsx)(s.p,{children:"之后，再次运行 Webpack 即可为 CSS 代码自动添加浏览器前缀，例如："}),"\n",(0,r.jsxs)(s.p,{children:["此外，还可以选择将 PostCSS 相关配置抽离保存到 ",(0,r.jsx)(s.code,{children:"postcss.config.js"})," 文件："]}),"\n",(0,r.jsx)(s.p,{children:"值得一提的是，PostCSS 与预处理器并非互斥关系，我们完全可以在同一个项目中同时使用两者，例如："}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-js",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: [\n          "style-loader", \n          {\n            loader: "css-loader",            \n            options: {\n              importLoaders: 1\n            }\n          }, \n          "postcss-loader",\n          "less-loader"\n        ],\n      },\n    ],\n  }\n};\n'})}),"\n",(0,r.jsx)(s.p,{children:"基于这一特性，我们既能复用预处理语法特性，又能应用 PostCSS 丰富的插件能力处理诸如雪碧图、浏览器前缀等问题。"}),"\n",(0,r.jsx)(s.p,{children:"PostCSS 最大的优势在于其简单、易用、丰富的插件生态，基本上已经能够覆盖样式开发的方方面面。实践中，经常使用的插件有："}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://github.com/postcss/autoprefixer",target:"_blank",rel:"noopener noreferrer",children:"autoprefixer"}),"：基于 ",(0,r.jsx)(s.a,{href:"https://caniuse.com/",target:"_blank",rel:"noopener noreferrer",children:"Can I Use"})," 网站上的数据，自动添加浏览器前缀"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://github.com/jonathantneal/postcss-preset-env",target:"_blank",rel:"noopener noreferrer",children:"postcss-preset-env"}),"：一款将最新 CSS 语言特性转译为兼容性更佳的低版本代码的插件"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://github.com/shellscape/postcss-less",target:"_blank",rel:"noopener noreferrer",children:"postcss-less"}),"：兼容 Less 语法的 PostCSS 插件，类似的还有：",(0,r.jsx)(s.a,{href:"https://github.com/AleshaOleg/postcss-sass",target:"_blank",rel:"noopener noreferrer",children:"postcss-sass"}),"、",(0,r.jsx)(s.a,{href:"https://github.com/madeleineostoja/poststylus",target:"_blank",rel:"noopener noreferrer",children:"poststylus"})]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"https://github.com/stylelint/stylelint",target:"_blank",rel:"noopener noreferrer",children:"stylelint"}),"：一个现代 CSS 代码风格检查器，能够帮助识别样式代码中的异常或风格问题"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"大家可按需扩展学习。"}),"\n",(0,r.jsxs)(s.h2,{id:"总结",children:["总结",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:["本文介绍 ",(0,r.jsx)(s.code,{children:"css-loader"}),"、",(0,r.jsx)(s.code,{children:"style-loader"}),"、",(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"}),"、",(0,r.jsx)(s.code,{children:"less-loader"}),"、",(0,r.jsx)(s.code,{children:"postcss-loader"})," 等组件的功能特点与接入方法，内容有点多，重点在于："]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Webpack 不能理解 CSS 代码，所以需要使用 ",(0,r.jsx)(s.code,{children:"css-loader"}),"、",(0,r.jsx)(s.code,{children:"style-loader"}),"、",(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})," 三种组件处理样式资源；"]}),"\n",(0,r.jsx)(s.li,{children:"Less/Sass/Stylus/PostCSS 等工具可弥补原生 CSS 语言层面的诸多功能缺失，例如数值运算、嵌套、代码复用等。"}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"这些工具几乎已经成为现代 Web 应用开发的标配，能够帮助我们写出更清晰简洁、可复用的样式代码，帮助我们解决诸多与样式有关的工程化问题。"}),"\n",(0,r.jsxs)(s.h2,{id:"思考题",children:["思考题",(0,r.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.code,{children:"style-loader"})," 与 ",(0,r.jsx)(s.code,{children:"mini-css-extract-plugin"})," 实现的效果有什么区别？对页面性能会产生什么影响？"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,l.ah)(),e.components);return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F4.%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E3%80%81PostCSS%20%E7%AD%89%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%20CSS%20%E5%B7%A5%E7%A8%8B%E7%8E%AF%E5%A2%83%EF%BC%9F.md"]={toc:[{text:"Webpack 如何处理 CSS 资源？",id:"webpack-如何处理-css-资源",depth:2},{text:"使用预处理器",id:"使用预处理器",depth:2},{text:"使用 post-css",id:"使用-post-css",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"4.如何借助预处理器、PostCSS 等构建现代 CSS 工程环境？",headingTitle:"4.如何借助预处理器、PostCSS 等构建现代 CSS 工程环境？",frontmatter:{}}}}]);