"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["30700"],{301273:function(e,n,i){i.r(n),i.d(n,{default:()=>o});var s=i(552676),t=i(740453);let a=i.p+"static/image/3f6e65003a33f866c8269d16deea2903.f35e9717.webp",r=i.p+"static/image/8579d36e998c8d94a8a242dbf6ddeca1.607b2420.webp",h=i.p+"static/image/69082907ef2f4a68e1e80cc47a6196f3.abfb9811.webp",c=i.p+"static/image/f9d875040586c4bf5b93231cb2de8c85.3073e014.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h3:"h3",img:"img",pre:"pre",ul:"ul",li:"li"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"10代码整理",children:["10.代码整理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10代码整理",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"概述",children:["概述",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#概述",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本来只凑了九小节，但是有小伙伴反馈代码写的很烂，而且自己在扩展",(0,s.jsx)(n.code,{children:"变阶"}),"功能的时候感觉确实如此。"]}),"\n",(0,s.jsxs)(n.h2,{id:"整理",children:["整理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#整理",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"自我审视了一下代码，感觉主要问题在以下几点："}),"\n",(0,s.jsxs)(n.h3,{id:"1逻辑冗余",children:["1、逻辑冗余",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1逻辑冗余",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"简易三阶魔方的 27 个小方块是一样的，每个小方块存在六个面，那么只需要六个 Canvas 素材生成六种不同颜色的材质即可；"}),"\n",(0,s.jsx)(n.p,{children:"但是在实际代码中每创建一个方块就创建了六个 Canvas 素材生成了六种不同颜色的材质；"}),"\n",(0,s.jsx)(n.p,{children:"问题代码截图如下（注意红框中的部分）："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["优化后",(0,s.jsx)(n.code,{children:"Rubik.js"}),"中的",(0,s.jsx)(n.code,{children:"SimpleCube"}),"方法如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function SimpleCube(x, y, z, num, len, colors) {\n    //魔方左上角坐标\n    var leftUpX = x - num / 2 * len;\n    var leftUpY = y + num / 2 * len;\n    var leftUpZ = z + num / 2 * len;\n    \n    //根据颜色生成材质\n    var materialArr = [];\n    for (var i = 0; i < BasicParams.colors.length; i++) {\n        var texture = new THREE.Texture(faces(BasicParams.colors[i]));\n        texture.needsUpdate = true;\n        var material = new THREE.MeshLambertMaterial({ map: texture });\n        materialArr.push(material);\n    }\n    \n    var cubes = [];\n    for (var i = 0; i < num; i++) {\n        for (var j = 0; j < num * num; j++) {\n            var cubegeo = new THREE.BoxGeometry(len, len, len);\n            var cube = new THREE.Mesh(cubegeo, materialArr);\n            \n            //依次计算各个小方块中心点坐标\n            cube.position.x = (leftUpX + len / 2) + (j % num) * len;\n            cube.position.y = (leftUpY - len / 2) - parseInt(j / num) * len;\n            cube.position.z = (leftUpZ - len / 2) - i * len;\n            cubes.push(cube);\n        }\n    }\n    return cubes;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"优化点在于在创建小方块之前就根据颜色创建 Canvas 素材并生成好需要的材质保存起来，后续只是对这六种材质的复用。"}),"\n",(0,s.jsxs)(n.h3,{id:"2逻辑重复",children:["2、逻辑重复",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2逻辑重复",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"代码中的各个按钮对象除了素材图片及其尺寸、空间位置不一样以外，其它都大同小异，但是我们并没有对这些相似逻辑进行封装；"}),"\n",(0,s.jsxs)(n.p,{children:["其实可以把重复逻辑抽象出来，封装成",(0,s.jsx)(n.code,{children:"UIComponent"}),"对象，用来处理小游戏中的自定义UI组件；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import * as THREE from '../threejs/three.js'\n\nexport default class UIComponentt {\n\n    constructor() {}\n    \n    /**\n     * 加载纹理背景\n     */\n    loadBackground(){}\n    \n    /**\n     * 在场景中显示和隐藏\n     */\n    showInScene(){}\n    hideInScene(){}\n    \n    /**\n     * 设置尺寸\n     */\n    setSize(){}\n    \n    /**\n     * 设置位置\n     */\n    setPosition() {}\n    \n    /**\n     * 获取位置\n     */\n    getPosition() {}\n    \n    /**\n     * 判断是否在范围内\n     */\n    isHover() {}\n    \n    /**\n     * 状态切换\n     */\n    enable() {}\n    disable() {}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"构造"}),"函数接受主游戏逻辑对象中的一些和 UI 相关的参数；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"constructor(main) {\n    this.main = main;\n    this.isActive = false;\n    this.radio = this.main.originWidth / 750;\n    this.uiRadio = this.main.uiRadio;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"设置尺寸"}),"函数接受实际尺寸，然后根据 UI 缩放比率等参数，推算出逻辑尺寸和屏幕尺寸；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"setSize(width,height){\n    //实际尺寸\n    this.realWidth = width;\n    this.realHeight = height;\n    \n    //逻辑尺寸\n    this.width = this.realWidth * this.radio;\n    this.height = this.realHeight * this.radio;\n    \n    //屏幕尺寸\n    this.screenRect = {\n        width: this.width / this.main.uiRadio,\n        height: this.height / this.main.uiRadio\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"获取位置"}),"函数会返回 UI 元素对象的中心点在空间中的坐标；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"getPosition() {\n    return this.plane.position.clone();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"激活状态切换"}),"函数会切换状态属性",(0,s.jsx)(n.code,{children:"isActive"}),"的值；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"enable() {\n    this.isActive = true;\n}\ndisable() {\n    this.isActive = false;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"设置位置"}),"函数接受 UI 元素在 3D 空间坐标系中的坐标值，然后更新其在 3D 空间以及投影到屏幕的位置；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"setPosition(x,y,z) {\n    if (x) {\n      this.plane.position.x = x;\n    }\n    if (y) {\n      this.plane.position.y = y;\n    }\n    if (z) {\n      this.plane.position.z = z;\n    }\n\n    this.screenRect.left = (this.main.originWidth / 2 + this.plane.position.x - this.width / 2) / this.main.uiRadio;\n    this.screenRect.top = (this.main.originHeight / 2 - this.plane.position.y - this.height / 2) / this.main.uiRadio;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"判断是否在 UI 元素范围内"}),"函数接受触摸点屏幕坐标，然后根据 UI 元素的屏幕位置以及屏幕尺寸判断；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"isHover(touch) {\n    var isHover = false;\n    if (touch.clientY >= this.screenRect.top && touch.clientY <= this.screenRect.top + this.screenRect.height && touch.clientX >= this.screenRect.left && touch.clientX <= this.screenRect.left + this.screenRect.width) {\n      isHover = true;\n    }\n    return isHover;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"显示状态切换"}),"函数会把 UI 对象加入到场景中或者将其从场景中删除；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"showInScene(){\n    this.main.scene.add(this.plane);\n}\nhideInScene(){\n    this.main.scene.remove(this.plane);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"加载纹理背景"}),"函数接受图片素材的 url 路径以及回调方法，使用纹理加载器加载图片素材，然后创建平面对象用于绘制 UI 元素；当加载完成且绘制成功之后再执行回调函数；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"loadBackground(url, callback){\n    var self = this;\n    var loader = new THREE.TextureLoader();\n    loader.load(url, function (texture) {\n        var geometry = new THREE.PlaneBufferGeometry(self.width, self.height);\n        var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });\n        self.plane = new THREE.Mesh(geometry, material);\n        self.plane.position.set(0, 0, 0);\n        self.showInScene();\n        if (callback) {\n            callback();\n        }\n    }, function (xhr) {\n        console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n    }, function (xhr) {\n        console.log('An error happened');\n    });\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["有了",(0,s.jsx)(n.code,{children:"UIComponent"}),"对象，我们再创建 UI 元素时，就只需要在其构造函数中设置尺寸以及加载图片素材即可；以还原按钮",(0,s.jsx)(n.code,{children:"ResetBtn"}),"对象为例，代码可以优化如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import * as THREE from '../threejs/three.js'\nimport UIComponent from './UIComponent.js'\n\nexport default class ResetBtn extends UIComponent {\n\n    constructor(main) {\n        super(main);\n        this.setSize(64, 64);\n    \n        var self = this;\n        this.loadBackground('images/reset-btn.jpg', function () {\n            self.defaultPosition();\n        });\n    }\n\n    /**\n     * 默认位置\n     */\n    defaultPosition() {\n        this.plane.position.x = -this.main.originWidth / 2 + this.width / 2 + 45 * this.radio;\n        this.plane.position.y = this.main.originHeight / 2 - this.height * 3 / 2 - 35 * this.radio;\n        \n        this.screenRect.left = (this.main.originWidth / 2 + this.plane.position.x - this.width / 2) / this.main.uiRadio;\n        this.screenRect.top = (this.main.originHeight / 2 - this.plane.position.y - this.height / 2) / this.main.uiRadio;\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"3逻辑混乱",children:["3、逻辑混乱",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3逻辑混乱",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["没有整理代码之前在游戏主逻辑文件",(0,s.jsx)(n.code,{children:"main.js"}),"中存在两个方法，分别是创建圆角矩形的",(0,s.jsx)(n.code,{children:"radiusRect"}),"方法和生成半透明背景的",(0,s.jsx)(n.code,{children:"background"}),"，这两个和 UI 相关的方法出现在游戏主逻辑文件中很明显有点混乱了；"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["我们需要把它们封装到",(0,s.jsx)(n.code,{children:"UIComponnet"}),"对象中才算合理，而且状态魔方的灰色半透明圆角矩形背景本身就算是 UI 相关元素；"]}),"\n",(0,s.jsxs)(n.p,{children:["之前",(0,s.jsx)(n.code,{children:"UIComponnet"}),"对象只支持加载图片素材生成 UI 元素，这里新增一个",(0,s.jsx)(n.code,{children:"loadStyle"}),"方法，让其可以根据简单的",(0,s.jsx)(n.code,{children:"类 CSS 样式"}),"规则生成 UI 元素；"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"loadStyle(uiParams) {\n    this.uiParams = uiParams;\n    this.uiParams.pixelRatio = this.uiParams.pixelRatio ? this.uiParams.pixelRatio : 1;//设备像素比默认为1\n    this.setSize(this.uiParams.width, this.uiParams.height);\n    var geometry = new THREE.PlaneGeometry(this.width, this.height);\n    var texture = new THREE.CanvasTexture(this._background());\n    var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });\n    this.plane = new THREE.Mesh(geometry, material);\n    this.showInScene();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"uiParams"}),"目前支持以下属性："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["宽度",(0,s.jsx)(n.code,{children:"width"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["高度",(0,s.jsx)(n.code,{children:"height"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["圆角",(0,s.jsx)(n.code,{children:"radius"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["背景颜色",(0,s.jsx)(n.code,{children:"backgroundColor"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["边框",(0,s.jsx)(n.code,{children:"borderTop"}),"、",(0,s.jsx)(n.code,{children:"borderRight"}),"、",(0,s.jsx)(n.code,{children:"borderBottom"}),"、",(0,s.jsx)(n.code,{children:"borderLeft"}),"、",(0,s.jsx)(n.code,{children:"borderColor"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["文字",(0,s.jsx)(n.code,{children:"fontSize"}),"、",(0,s.jsx)(n.code,{children:"fontColor"}),"、",(0,s.jsx)(n.code,{children:"fontFamily"}),"、",(0,s.jsx)(n.code,{children:"fontWeight"}),"、",(0,s.jsx)(n.code,{children:"content"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["设备像素比",(0,s.jsx)(n.code,{children:"pixelRatio"}),"（主要用于处理 Canvas 文字模糊问题）。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"loadStyle"}),"和",(0,s.jsx)(n.code,{children:"loadBackground"}),"的主要区域在于前者在",(0,s.jsx)(n.code,{children:"_background"}),"方法中根据类 CSS 样式规则生成 Canvas 素材充当 UI 元素的背景，后者直接加载图片素材充当 UI 元素的背景；"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"_background"}),"方法具体实现如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"_background() {\n    var canvas = document.createElement('canvas');\n    canvas.width = this.realWidth * this.uiParams.pixelRatio;\n    canvas.height = this.realHeight * this.uiParams.pixelRatio;\n    this._radiusRect(canvas, this.uiParams.radius * this.uiParams.pixelRatio, canvas.width, canvas.height, this.uiParams.backgroundColor);\n    if (!this.uiParams.radius) {//暂时不支持圆角边框\n        this._border(canvas, this.uiParams.borderTop * this.uiParams.pixelRatio, this.uiParams.borderRight * this.uiParams.pixelRatio, this.uiParams.borderBottom * this.uiParams.pixelRatio, this.uiParams.borderLeft * this.uiParams.pixelRatio, this.uiParams.borderColor)\n    }\n    if (this.uiParams.content) {\n        this._text(canvas, this.uiParams.fontSize * this.uiParams.pixelRatio, this.uiParams.fontFamily, this.uiParams.fontColor, this.uiParams.content, this.uiParams.fontWeight);\n    }\n    return canvas;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"UIComponent"}),"对象中的",(0,s.jsx)(n.code,{children:"_background"}),"方法也就是未优化之前在",(0,s.jsx)(n.code,{children:"main.js"}),"中的",(0,s.jsx)(n.code,{children:"background"}),"方法了；在此方法中先创建 Canvas 元素然后依次执行",(0,s.jsx)(n.code,{children:"_radiusRect"}),"、",(0,s.jsx)(n.code,{children:"_border"}),"、",(0,s.jsx)(n.code,{children:"_text"}),"等方法处理对应的类 CSS 样式规则；"]}),"\n",(0,s.jsxs)(n.p,{children:["而",(0,s.jsx)(n.code,{children:"_radiusRect"}),"方法则是未优化之前在",(0,s.jsx)(n.code,{children:"main.js"}),"中的",(0,s.jsx)(n.code,{children:"radiusRect"}),"方法；"]}),"\n",(0,s.jsx)(n.p,{children:"这些方法中都是些 Canvas API 的使用，比如使用 textAlign 属性可以实现 Canvas 绘制文字水平居中；使用 textBaseline 属性可以实现 Canvas 绘制文字垂直居中等。"}),"\n",(0,s.jsxs)(n.p,{children:["扩展",(0,s.jsx)(n.code,{children:"UIComponent"}),"对象的能力之后，就可以把",(0,s.jsx)(n.code,{children:"main.js"}),"中的存储魔方",(0,s.jsx)(n.code,{children:"saveRubik"}),"方法中生成状态魔方半透明背景的代码封装成直接使用",(0,s.jsx)(n.code,{children:"UIComponent"}),"对象实现；"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"图片中红色部分为未优化代码，绿色部分为优化后的代码；"}),"\n",(0,s.jsxs)(n.p,{children:["优化后",(0,s.jsx)(n.code,{children:"main.js"}),"的",(0,s.jsx)(n.code,{children:"saveRubik"}),"方法完整代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"saveRubik(){\n    wx.showLoading({\n      title: '存档中...',\n      mask:true\n    })\n\n    if (!this.tagRubik) {\n      this.tagRubik = new BasicRubik(this);\n      this.tagRubik.model();\n    }\n    var tagPosition = this.saveBtn.getPosition();\n    tagPosition.y -= this.saveBtn.height / 2 + 15;\n    this.tagRubik.save(this.frontRubik, tagPosition, 0.05);\n    this.scene.add(this.tagRubik.group);\n\n    //添加灰色半透明背景\n    if (!this.tagRubikBg) {\n      this.tagRubikBg = new UIComponent(this);\n      this.tagRubikBg.loadStyle({\n        width: 64,\n        height: 64,\n        backgroundColor: 'rgba(0,0,0,0.1)',\n        radius: 8\n      });\n    } else {\n      this.tagRubikBg.showInScene();\n    }\n    this.tagRubikBg.setPosition(tagPosition.x, tagPosition.y, tagPosition.z);\n\n    setTimeout(function(){\n      wx.hideLoading()\n    },500)\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"4逻辑晦涩",children:["4、逻辑晦涩",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4逻辑晦涩",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["另外在",(0,s.jsx)(n.code,{children:"魔方转动分析"}),"那里的逻辑有点晦涩，转动方向使用了",(0,s.jsx)(n.code,{children:"1.1"}),"、",(0,s.jsx)(n.code,{children:"2.3"}),"这种不太容易理解的数字常量区分方法；不过对于这个问题目前我并没有想到太好的优化方案，大家可以思考一下。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["整理之后的完整代码在",(0,s.jsx)(n.a,{href:"https://github.com/newbieYoung/Threejs_rubik/tree/master/lesson/demo8",target:"_blank",rel:"noopener noreferrer",children:"Threejs_rubik"})," 项目中；"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"因为水平有限，代码中或大或小的问题，肯定不仅仅只有上边那些，大家可以自由发挥，随意吐槽。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let o=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20ThreeJS%20%E6%A1%86%E6%9E%B6%E7%9A%84%E9%AD%94%E6%96%B9%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%AE%9E%E8%B7%B5%2F10.%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86.md"]={toc:[{text:"概述",id:"概述",depth:2},{text:"整理",id:"整理",depth:2},{text:"1、逻辑冗余",id:"1逻辑冗余",depth:3},{text:"2、逻辑重复",id:"2逻辑重复",depth:3},{text:"3、逻辑混乱",id:"3逻辑混乱",depth:3},{text:"4、逻辑晦涩",id:"4逻辑晦涩",depth:3},{text:"总结",id:"总结",depth:2}],title:"10.代码整理",headingTitle:"10.代码整理",frontmatter:{}}}}]);