"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["76338"],{695611:function(e,n,r){r.r(n),r.d(n,{default:()=>h});var s=r(552676),d=r(740453);function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",ul:"ul",li:"li",blockquote:"blockquote",p:"p",pre:"pre",code:"code",strong:"strong",img:"img",ol:"ol"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"4基础-1启动一个最简单的-restful-api-服务器",children:["4基础 1：启动一个最简单的 RESTful API 服务器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4基础-1启动一个最简单的-restful-api-服务器",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"本节核心内容",children:["本节核心内容",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本节核心内容",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"启动一个最简单的 RESTful API 服务器"}),"\n",(0,s.jsx)(n.li,{children:"设置 HTTP Header"}),"\n",(0,s.jsx)(n.li,{children:"API 服务器健康检查和状态查询"}),"\n",(0,s.jsx)(n.li,{children:"编译并测试 API"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["本小节源码下载路径：",(0,s.jsx)(n.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo01",target:"_blank",rel:"noopener noreferrer",children:"demo01"})]}),"\n",(0,s.jsx)(n.p,{children:"可先下载源码到本地，结合源码理解后续内容，边学边练。"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-!",children:"如无特别说明，本小册的操作和编译目录均是 API 源码的根目录，并且本 API 服务器名字（也是二进制命令的名字）小册中统一叫作 apiserver。\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"rest-web-框架选择",children:["REST Web 框架选择",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#rest-web-框架选择",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["要编写一个 RESTful 风格的 API 服务器，首先需要一个 RESTful Web 框架，笔者经过调研选择了 GitHub star 数最多的 ",(0,s.jsx)(n.a,{href:"https://github.com/gin-gonic/gin",target:"_blank",rel:"noopener noreferrer",children:"Gin"}),"。采用轻量级的 Gin 框架，具有如下优点：高性能、扩展性强、稳定性强、相对而言比较简洁（查看 ",(0,s.jsx)(n.a,{href:"https://github.com/gin-gonic/gin/blob/master/BENCHMARKS.md",target:"_blank",rel:"noopener noreferrer",children:"性能对比"}),"）。关于 Gin 的更多介绍可以参考 ",(0,s.jsx)(n.a,{href:"https://www.jianshu.com/p/a31e4ee25305",target:"_blank",rel:"noopener noreferrer",children:"Golang 微框架 Gin 简介"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"加载路由并启动-http-服务",children:["加载路由，并启动 HTTP 服务",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载路由并启动-http-服务",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["main.go 中的 ",(0,s.jsx)(n.code,{children:"main()"})," 函数是 Go 程序的入口函数，在 ",(0,s.jsx)(n.code,{children:"main()"})," 函数中主要做一些配置文件解析、程序初始化和路由加载之类的事情，最终调用 ",(0,s.jsx)(n.code,{children:"http.ListenAndServe()"})," 在指定端口启动一个 HTTP 服务器。本小节是一个简单的 HTTP 服务器，仅初始化一个 Gin 实例，加载路由并启动 HTTP 服务器。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"编写入口函数"})}),"\n",(0,s.jsxs)(n.p,{children:["编写 ",(0,s.jsx)(n.code,{children:"main()"})," 函数，main.go 代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"log"\n	"net/http"\n\n	"apiserver/router"\n\n	"github.com/gin-gonic/gin"\n)\n\nfunc main() {\n	// Create the Gin engine.\n	g := gin.New()\n    \n    // gin middlewares\n	middlewares := []gin.HandlerFunc{}\n\n	// Routes.\n	router.Load(\n		// Cores.\n		g,\n\n		// Middlewares.\n		middlewares...,\n	)\n\n	log.Printf("Start to listening the incoming requests on http address: %s", ":8080")\n	log.Printf(http.ListenAndServe(":8080", g).Error())\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"加载路由"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"main()"})," 函数通过调用 ",(0,s.jsx)(n.code,{children:"router.Load"})," 函数来加载路由（函数路径为 router/router.go，具体函数实现参照 ",(0,s.jsx)(n.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo01/router/router.go",target:"_blank",rel:"noopener noreferrer",children:"demo01/router/router.go"}),"）："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'    "apiserver/handler/sd"\n    \n    ....\n    \n    // The health check handlers\n    svcd := g.Group("/sd")\n    {   \n        svcd.GET("/health", sd.HealthCheck)\n        svcd.GET("/disk", sd.DiskCheck)\n        svcd.GET("/cpu", sd.CPUCheck)\n        svcd.GET("/ram", sd.RAMCheck)\n    }   \n'})}),"\n",(0,s.jsxs)(n.p,{children:["该代码块定义了一个叫 sd 的分组，在该分组下注册了 ",(0,s.jsx)(n.code,{children:"/health"}),"、",(0,s.jsx)(n.code,{children:"/disk"}),"、",(0,s.jsx)(n.code,{children:"/cpu"}),"、",(0,s.jsx)(n.code,{children:"/ram"})," HTTP 路径，分别路由到 ",(0,s.jsx)(n.code,{children:"sd.HealthCheck"}),"、",(0,s.jsx)(n.code,{children:"sd.DiskCheck"}),"、",(0,s.jsx)(n.code,{children:"sd.CPUCheck"}),"、",(0,s.jsx)(n.code,{children:"sd.RAMCheck"})," 函数。sd 分组主要用来检查 API Server 的状态：健康状况、服务器硬盘、CPU 和内存使用量。具体函数实现参照 ",(0,s.jsx)(n.a,{href:"https://github.com/lexkong/apiserver_demos/blob/master/demo01/handler/sd/check.go",target:"_blank",rel:"noopener noreferrer",children:"demo01/handler/sd/check.go"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"设置 HTTP Header"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"router.Load"})," 函数通过 ",(0,s.jsx)(n.code,{children:"g.Use()"})," 来为每一个请求设置 Header，在 router/router.go 文件中设置 Header："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:"    g.Use(gin.Recovery())\n    g.Use(middleware.NoCache)\n    g.Use(middleware.Options)\n    g.Use(middleware.Secure)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"gin.Recovery()"}),"：在处理某些请求时可能因为程序 bug 或者其他异常情况导致程序 panic，这时候为了不影响下一次请求的调用，需要通过 ",(0,s.jsx)(n.code,{children:"gin.Recovery()"}),"来恢复 API 服务器"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"middleware.NoCache"}),"：强制浏览器不使用缓存"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"middleware.Options"}),"：浏览器跨域 OPTIONS 请求设置"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"middleware.Secure"}),"：一些安全设置"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"middleware"}),"包的实现见 ",(0,s.jsx)(n.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo01/router/middleware",target:"_blank",rel:"noopener noreferrer",children:"demo01/router/middleware"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"api-服务器健康状态自检",children:["API 服务器健康状态自检",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#api-服务器健康状态自检",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["有时候 API 进程起来不代表 API 服务器正常，笔者曾经就遇到过这种问题：API 进程存在，但是服务器却不能对外提供服务。因此在启动 API 服务器时，如果能够最后做一个自检会更好些。笔者在 apiserver 中也添加了自检程序，在启动 HTTP 端口前 go 一个 ",(0,s.jsx)(n.code,{children:"pingServer"})," 协程，启动 HTTP 端口后，该协程不断地 ping ",(0,s.jsx)(n.code,{children:"/sd/health"})," 路径，如果失败次数超过一定次数，则终止 HTTP 服务器进程。通过自检可以最大程度地保证启动后的 API 服务器处于健康状态。自检部分代码位于 main.go 中："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'func main() {\n    ....\n       \n    // Ping the server to make sure the router is working.\n    go func() {\n        if err := pingServer(); err != nil {\n            log.Fatal("The router has no response, or it might took too long to start up.", err)\n        }   \n        log.Print("The router has been deployed successfully.")\n    }()\n    ....\n}\n\n// pingServer pings the http server to make sure the router is working.\nfunc pingServer() error {\n    for i := 0; i < 10; i++ {\n        // Ping the server by sending a GET request to `/health`.\n        resp, err := http.Get("http://127.0.0.1:8080" + "/sd/health")\n        if err == nil && resp.StatusCode == 200 {\n            return nil \n        }   \n       \n        // Sleep for a second to continue the next ping.\n        log.Print("Waiting for the router, retry in 1 second.")\n        time.Sleep(time.Second)\n    }  \n    return errors.New("Cannot connect to the router.")\n}   \n'})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"pingServer()"})," 函数中，",(0,s.jsx)(n.code,{children:"http.Get"})," 向 ",(0,s.jsx)(n.code,{children:"http://127.0.0.1:8080/sd/health"})," 发送 HTTP GET 请求，如果函数正确执行并且返回的 HTTP StatusCode 为 200，则说明 API 服务器可用，",(0,s.jsx)(n.code,{children:"pingServer"})," 函数输出部署成功提示；如果超过指定次数，",(0,s.jsx)(n.code,{children:"pingServer"})," 直接终止 API Server 进程，如下图所示。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/5/30/163b007651a5d35f?w=1698&h=409&f=png&s=57328",alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"/sd/health"})," 路径会匹配到 ",(0,s.jsx)(n.code,{children:"handler/sd/check.go"})," 中的 ",(0,s.jsx)(n.code,{children:"HealthCheck"})," 函数，该函数只返回一个字符串：OK。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"编译源码",children:["编译源码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译源码",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"下载 apiserver_demos 源码包"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"$ git clone https://github.com/lexkong/apiserver_demos\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["将 ",(0,s.jsx)(n.code,{children:"apiserver_demos/demo01"})," 复制为 ",(0,s.jsx)(n.code,{children:"$GOPATH/src/apiserver"})]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"$ cp -a apiserver_demos/demo01/ $GOPATH/src/apiserver\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["首次编译需要下载 ",(0,s.jsx)(n.code,{children:"vendor"})," 包"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"因为 apiserver 功能比较丰富，需要用到很多 Go package，统计了下需要用到 60 个非标准 Go 包。为了让读者更容易地上手编写代码，这里将这些依赖用 go vendor 进行管理，并放在 GitHub 上供读者下载安装，安装方法为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"$ cd $GOPATH/src\n$ git clone https://github.com/lexkong/vendor\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"进入 apiserver 目录编译源代码"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"$ cd $GOPATH/src/apiserver\n$ gofmt -w .   \n$ go tool vet .\n$ go build -v .\n"})}),"\n",(0,s.jsxs)(n.p,{children:["编译后的二进制文件存放在当前目录，名字跟目录名相同：",(0,s.jsx)(n.code,{children:"apiserver"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"笔者建议每次编译前对 Go 源码进行格式化和代码静态检查，以发现潜在的 Bug 或可疑的构造。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"curl-工具测试-api",children:["cURL 工具测试 API",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#curl-工具测试-api",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"cURL 工具简介"})}),"\n",(0,s.jsxs)(n.p,{children:["本小册采用 cURL 工具来测试 RESTful API，标准的 Linux 发行版都安装了 cURL 工具。cURL 可以很方便地完成对 REST API 的调用场景，比如：设置 Header，指定 HTTP 请求方法，指定 HTTP 消息体，指定权限认证信息等。通过 ",(0,s.jsx)(n.code,{children:"-v"})," 选项也能输出 REST 请求的所有返回信息。cURL 功能很强大，有很多参数，这里列出 REST 测试常用的参数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"-X/--request [GET|POST|PUT|DELETE|…]  指定请求的 HTTP 方法\n-H/--header                           指定请求的 HTTP Header\n-d/--data                             指定请求的 HTTP 消息体（Body）\n-v/--verbose                          输出详细的返回信息\n-u/--user                             指定账号、密码\n-b/--cookie                           读取 cookie  \n"})}),"\n",(0,s.jsx)(n.p,{children:"典型的测试命令为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'$ curl -v -XPOST -H "Content-Type: application/json" http://127.0.0.1:8080/user -d\'{"username":"admin","password":"admin1234"}\'\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"启动 API Server"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'$ ./apiserver\n[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.\n - using env:   export GIN_MODE=release\n - using code:  gin.SetMode(gin.ReleaseMode)\n\n[GIN-debug] GET    /sd/health                --\x3e apiserver/handler/sd.HealthCheck (5 handlers)\n[GIN-debug] GET    /sd/disk                  --\x3e apiserver/handler/sd.DiskCheck (5 handlers)\n[GIN-debug] GET    /sd/cpu                   --\x3e apiserver/handler/sd.CPUCheck (5 handlers)\n[GIN-debug] GET    /sd/ram                   --\x3e apiserver/handler/sd.RAMCheck (5 handlers)\nStart to listening the incoming requests on http address: :8080\nThe router has been deployed successfully.\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"发送 HTTP GET 请求"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ curl -XGET http://127.0.0.1:8080/sd/health\nOK\n\n$ curl -XGET http://127.0.0.1:8080/sd/disk\nOK - Free space: 16321MB (15GB) / 51200MB (50GB) | Used: 31%\n\n$ curl -XGET http://127.0.0.1:8080/sd/cpu\nCRITICAL - Load average: 2.39, 2.13, 1.97 | Cores: 2\n\n$ curl -XGET http://127.0.0.1:8080/sd/ram\nOK - Free space: 455MB (0GB) / 8192MB (8GB) | Used: 5%\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以看到 HTTP 服务器均能正确响应请求。"}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:'本小节通过具体的例子教读者快速启动一个 API 服务器，这只是一个稍微复杂点的 "Hello World"。读者可以先通过该 Hello World 熟悉 Go API 开发流程，后续小节会基于这个简单的 API 服务器，一步步构建一个企业级的 API 服务器。'})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let h=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Go%20%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84%20RESTful%20API%20%E6%9C%8D%E5%8A%A1%2F4%E5%9F%BA%E7%A1%80%201%EF%BC%9A%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%20RESTful%20API%20%E6%9C%8D%E5%8A%A1%E5%99%A8.md"]={toc:[{text:"本节核心内容",id:"本节核心内容",depth:2},{text:"REST Web 框架选择",id:"rest-web-框架选择",depth:2},{text:"加载路由，并启动 HTTP 服务",id:"加载路由并启动-http-服务",depth:2},{text:"API 服务器健康状态自检",id:"api-服务器健康状态自检",depth:2},{text:"编译源码",id:"编译源码",depth:2},{text:"cURL 工具测试 API",id:"curl-工具测试-api",depth:2},{text:"小结",id:"小结",depth:2}],title:"4基础 1：启动一个最简单的 RESTful API 服务器",headingTitle:"4基础 1：启动一个最简单的 RESTful API 服务器",frontmatter:{}}}}]);