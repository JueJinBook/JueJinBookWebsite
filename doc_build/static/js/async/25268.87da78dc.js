"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["25268"],{569529:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var c=r(552676),s=r(740453);let d=r.p+"static/image/184f1ff1dbb9442fa1b30170e245697c~tplv-k3u1fbpfcp-zoom-1.image.f066b843.png";function i(e){let n=Object.assign({h1:"h1",a:"a",h4:"h4",p:"p",h2:"h2",code:"code",strong:"strong",pre:"pre",img:"img"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"10-拓展剖析-immerjs-工作原理与设计模式",children:["10 拓展：剖析 Immer.js 工作原理与设计模式",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-拓展剖析-immerjs-工作原理与设计模式",children:"#"})]}),"\n",(0,c.jsxs)(n.h4,{id:"colorlightpink保姆式教学の温馨提示",children:["$\\color{lightPink}保姆式教学の温馨提示$",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#colorlightpink保姆式教学の温馨提示",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"本节内容包含两部分，前半部分是对上一节的剖析和拓展（话题核心仍然是 Immer.js），后半部分则是对整个 Immutability 知识模块的总结。"}),"\n",(0,c.jsx)(n.p,{children:"其中，前半部分属于选学内容，跳过它，并不影响你理解函数式编程。"}),"\n",(0,c.jsx)(n.p,{children:"如果你时间有限，希望尽快地构建函数式编程的整体知识脉络，那么你可以直接跳到本节的“总结”部分。"}),"\n",(0,c.jsx)(n.p,{children:"如果你对 Immer.js 很感兴趣，又不小心跳读到了这里，那么你需要往回再跳一节，以此来获取阅读本节所需的知识上下文。"}),"\n",(0,c.jsxs)(n.h2,{id:"produce-工作原理将拷贝操作精准化",children:["Produce 工作原理：将拷贝操作精准化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#produce-工作原理将拷贝操作精准化",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["结合上一节的源码提取+解析，我们不难看出，",(0,c.jsx)(n.code,{children:"produce"})," 可以像 Immutable.js 一样，精准打击那些需要执行写操作的数据。",(0,c.jsx)(n.strong,{children:"将“变与不变”分离，确保只有变化的部分被处理，而不变的部分则将继续留在原地。"})]}),"\n",(0,c.jsxs)(n.p,{children:["但 ",(0,c.jsx)(n.code,{children:"produce"})," 并没有像 Immutable.js 一样打数据结构的主意，而是将火力集中对准了“拷贝”这个动作。"]}),"\n",(0,c.jsx)(n.p,{children:"它严格地控制了“拷贝”发生的时机：当且仅当写操作确实发生时，拷贝动作才会被执行。"}),"\n",(0,c.jsxs)(n.p,{children:["具体到我们在上一节讨论过的用例来说，在我们调用 ",(0,c.jsx)(n.code,{children:"produce"})," 执行读操作前后，",(0,c.jsx)(n.code,{children:"baseObj"})," 和 ",(0,c.jsx)(n.code,{children:"doNothingObj"})," 是严格相等的："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'// 这是我的源对象\nconst baseObj = {\n  a: 1,\n  b: {\n    name: "修言"\n  }\n}\n\n// 这是一个执行写操作的 recipe\nconst changeA = (draft) => {\n  draft.a = 2\n}\n\n\n// 这是一个不执行写操作、只执行读操作的 recipe\nconst doNothing = (draft) => {\n  console.log("doNothing function is called, and draft is", draft)\n}\n\n// 借助 produce，对源对象应用写操作，修改源对象里的 a 属性\nconst changedObjA = produce(baseObj, changeA)\n\n// 借助 produce，对源对象应用读操作\nconst doNothingObj = produce(baseObj, doNothing)\n\n// 顺序输出3个对象，确认写操作确实生效了\nconsole.log(baseObj)\nconsole.log(changedObjA)\nconsole.log(doNothingObj)\n\n// 【源对象】 和 【借助 produce 对源对象执行过读操作后的对象】 还是同一个对象吗？\n// 答案为 true\nconsole.log(baseObj === doNothingObj)\n// 【源对象】 和 【借助 produce 对源对象执行过写操作后的对象】 还是同一个对象吗？\n// 答案为 false\nconsole.log(baseObj === changedObjA)\n// 源对象里没有被执行写操作的 b 属性，在 produce 执行前后是否会发生变化？\n// 输出为 true，说明不会发生变化\nconsole.log(baseObj.b === changedObjA.b)\n'})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"只要写操作没执行，拷贝动作就不会发生"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["只有当写操作确实执行，也就是当我们试图修改 ",(0,c.jsx)(n.code,{children:"baseObj"})," 的 ",(0,c.jsx)(n.code,{children:"a"})," 属性时，",(0,c.jsx)(n.code,{children:"produce"})," 才会去执行拷贝动作：先浅拷贝一个 ",(0,c.jsx)(n.code,{children:"baseObj"})," 的副本对象（",(0,c.jsx)(n.code,{children:"changedObjA"}),"）出来，然后再修改 ",(0,c.jsx)(n.code,{children:"changedObjA"})," 里的 ",(0,c.jsx)(n.code,{children:"a"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["这一步对应的是 ",(0,c.jsx)(n.code,{children:"produce"})," 函数对 ",(0,c.jsx)(n.code,{children:"setter"})," 的代理逻辑："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"const baseHandler = {\n  set(obj, key, value) {\n    // 先检查 copy 是否存在，如果不存在，创建 copy\n    if (!copy) {\n      copy = { ...base }\n    }\n    // 如果 copy 存在，修改 copy，而不是 base\n    copy[key] = value\n    return true\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这样一来，",(0,c.jsx)(n.code,{children:"changedObjA"})," 和 ",(0,c.jsx)(n.code,{children:"baseObj"})," 显然是两个不同的对象，",(0,c.jsx)(n.strong,{children:"数据内容的变化和引用的变化同步发生了"}),"，这",(0,c.jsx)(n.strong,{children:"符合我们对 Immutability 的预期"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["与此同时，",(0,c.jsx)(n.code,{children:"changedObjA.b"})," 和 ",(0,c.jsx)(n.code,{children:"baseObj.b"})," 是严格相等的，说明两个引用不同的对象，仍然",(0,c.jsx)(n.strong,{children:"共享着那些没有实际被修改到的数据"}),"。由此也就实现了数据共享，避免了暴力拷贝带来的各种问题。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"produce"})," 借助 Proxy，将拷贝动作发生的时机和 ",(0,c.jsx)(n.code,{children:"setter"})," 函数的触发时机牢牢绑定，确保了拷贝动作的精确性。 而逐层的浅拷贝，则间接地实现了数据在新老对象间的共享。"]}),"\n",(0,c.jsxs)(n.h2,{id:"拓展知其所止的逐层拷贝",children:["拓展：“知其所止”的“逐层拷贝”",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#拓展知其所止的逐层拷贝",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"这里我想要给大家展开说明一下这个“逐层的”浅拷贝。"}),"\n",(0,c.jsxs)(n.p,{children:["在我们的极简版 ",(0,c.jsx)(n.code,{children:"produce"})," 里，着重突出了 ",(0,c.jsx)(n.code,{children:"setter"})," 函数的写逻辑，也就是对“拷贝时机”的描述，淡化了其它执行层面的细节。"]}),"\n",(0,c.jsxs)(n.p,{children:["而在 Immer.js 中，完整版 ",(0,c.jsx)(n.code,{children:"produce"})," 的浅拷贝其实是",(0,c.jsx)(n.strong,{children:"可递归"}),"的。"]}),"\n",(0,c.jsxs)(n.p,{children:["举例来说，在本文的案例中，",(0,c.jsx)(n.code,{children:"baseObj"})," 是一个嵌套对象，一共有两层（如下图红圈所示）："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["外面的圈圈表示第一层，里面的圈圈表示第二层（也就是 ",(0,c.jsx)(n.code,{children:"b"})," 属性指向的对象）。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"无论对象嵌套了多少层，每一层对于写操作的反应是一致的，都会表现为“修改时拷贝”。"})}),"\n",(0,c.jsxs)(n.p,{children:["我继续用 ",(0,c.jsx)(n.code,{children:"baseObj"})," 举个例子，这次我们来看 ",(0,c.jsx)(n.code,{children:"b"})," 属性（它是一个对象）。"]}),"\n",(0,c.jsxs)(n.p,{children:["如果我对 ",(0,c.jsx)(n.code,{children:"b"})," 属性执行了写操作，结果会是怎样的呢？"]}),"\n",(0,c.jsx)(n.p,{children:"请看下面这段代码（注意看解析）："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'import produce from "immer";\n\n// 这是一个执行引用类型写操作的 recipe\nconst changeB = (draft) => {\n  draft.b.name = " 修个锤子"\n}\n\n// 借助 produce 调用 changeB\nconst changedObjB = produce(baseObj, changeB)\n// 【源对象】 和 【借助 produce 对源对象执行过写操作后的对象】 还是同一个对象吗？\n// 答案为 false\nconsole.log(baseObj === changedObjB)\n// 【b 属性】 和 【借助 produce 修改过的 b 属性】 还是同一个对象吗？\n// 答案为 false\nconsole.log(baseObj.b === changedObjB.b)\n'})}),"\n",(0,c.jsxs)(n.p,{children:["从结果上来看， 即便对于嵌套的对象来说，",(0,c.jsx)(n.strong,{children:"数据内容的变化和引用的变化也能同步发生"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["这是因为 ",(0,c.jsx)(n.code,{children:"produce"})," ",(0,c.jsx)(n.strong,{children:"不仅会拦截"})," ",(0,c.jsx)(n.code,{children:"setter"})," ",(0,c.jsx)(n.strong,{children:"，也会拦截"})," ",(0,c.jsx)(n.code,{children:"getter"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["通过对 ",(0,c.jsx)(n.code,{children:"getter"})," 的拦截，",(0,c.jsx)(n.code,{children:"produce"})," 能够按需地对被访问到的属性进行“懒代理”：你访问得有多深，代理逻辑就能走多深；而所有被代理的属性，都会具备新的 ",(0,c.jsx)(n.code,{children:"setter"})," 方法。"]}),"\n",(0,c.jsxs)(n.p,{children:["当写操作发生时，",(0,c.jsx)(n.code,{children:"setter"})," 方法就会被逐层触发，呈现“逐层浅拷贝”的效果。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"“逐层浅拷贝”是 Immer 实现数据共享的关键。"})}),"\n",(0,c.jsx)(n.p,{children:"假设我的对象嵌套层级为 10 层，而我对它的属性修改只会触达第 2 层，“逐层的浅拷贝”就能够帮我们确保拷贝只会进行到第 2 层。"}),"\n",(0,c.jsx)(n.p,{children:"“逐层的浅拷贝”如果递归到最后一层，就会变成深拷贝。"}),"\n",(0,c.jsx)(n.p,{children:"对于引用类型数据来说，“暴力拷贝”指的也就是深拷贝。"}),"\n",(0,c.jsxs)(n.p,{children:["“暴力拷贝”之所以会带来大量的时间空间上的浪费，本质上是因为它在拷贝的过程中不能够“",(0,c.jsx)(n.strong,{children:"知其所止"}),"”。"]}),"\n",(0,c.jsxs)(n.p,{children:["而“逐层的浅拷贝”之所以能够实现数据共享，正是因为它借助 Proxy 做到了“",(0,c.jsx)(n.strong,{children:"知其所止"}),"”。"]}),"\n",(0,c.jsxs)(n.p,{children:["（注：实际 produce 源码中递归的实现会复杂得多，Immer.js 在性能方面的各种处理也复杂得多。本文扣题函数式思想，仅提取 produce 中与不可变数据强相关的逻辑进行了选讲，对完整源码感兴趣的同学请狠狠地点击",(0,c.jsx)(n.a,{href:"https://github.com/immerjs/immer",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"）"]}),"\n",(0,c.jsxs)(n.h2,{id:"思考知其所止的软件设计表达",children:["思考：“知其所止”的软件设计表达",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考知其所止的软件设计表达",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"无论是“精准拷贝”、“修改时拷贝”，还是“逐层拷贝”，其背后体现的都是同一个思想——“按需”。"}),"\n",(0,c.jsx)(n.p,{children:"“知其所止”的软件设计表达，就是“按需”。"}),"\n",(0,c.jsx)(n.p,{children:"对于 Immutable.js 来说，它通过构建一套原生 JS 无法支持的 Trie 数据结构，最终实现了树节点的按需创建。"}),"\n",(0,c.jsx)(n.p,{children:"对于 Immer.js 来说，它借助 Proxy 的 getter 函数实现了按需代理，借助 Proxy 的 setter 函数实现了对象属性的按需拷贝。"}),"\n",(0,c.jsx)(n.p,{children:"可见，想要实现高效的 Immutability，“按需变化”是一个不错的切入点。"}),"\n",(0,c.jsxs)(n.h2,{id:"总结-immutability-的实践演进",children:["总结： Immutability 的实践演进",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结-immutability-的实践演进",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"至此，关于 Immutability ，我们已经讨论了 5 节。"}),"\n",(0,c.jsx)(n.p,{children:"现在请大家回顾一下：对于 JS 来说，Immutability 实践的直接目的是什么？"}),"\n",(0,c.jsxs)(n.p,{children:["简单来说，是为了解决",(0,c.jsx)(n.strong,{children:"数据内容变化与数据引用变化不同步的问题"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["我拿到一个引用类型数据（",(0,c.jsx)(n.code,{children:"A"}),")，修改了其中的一个 ",(0,c.jsx)(n.code,{children:"a"})," 属性，然后所有依赖 ",(0,c.jsx)(n.code,{children:"A.a"})," 进行计算的函数逻辑全炸了，牵一发而动全身，这不是我们想要的结局。"]}),"\n",(0,c.jsxs)(n.p,{children:["我们希望一旦引用类型数据（",(0,c.jsx)(n.code,{children:"A"}),"）的内容改变了，我们就能获取到一个新的引用，这个引用指向一套已经发生改变的数据（",(0,c.jsx)(n.code,{children:"A'"}),")， ",(0,c.jsx)(n.code,{children:"A"})," 和 ",(0,c.jsx)(n.code,{children:"A'"})," 应该是泾渭分明的。"]}),"\n",(0,c.jsx)(n.p,{children:"暴力拷贝，可以做到“泾渭分明”，但是对于规模较大的数据来说，它太低效了。"}),"\n",(0,c.jsx)(n.p,{children:"于是，社区的 Immutability 解决方案百花齐放，Immer.js 和 Immutable.js 就是其中的佼佼者。"}),"\n",(0,c.jsx)(n.p,{children:"Immutable.js 底层是持久化数据结构，而 Immer.js 的底层是 Proxy 代理模式。"}),"\n",(0,c.jsx)(n.p,{children:"两者虽然在具体的工作原理上大相径庭，但最终指向的目的却是一致的：使数据的引用与数据内容的变化同步发生；并且在这个过程中，按需处理具体的变化点，提升不可变数据的执行效率。"}),"\n",(0,c.jsx)(n.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(i,{...e})}):i(e)}let l=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F10%20%E6%8B%93%E5%B1%95%EF%BC%9A%E5%89%96%E6%9E%90%20Immer.js%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md"]={toc:[{text:"$\\color{lightPink}保姆式教学の温馨提示$",id:"colorlightpink保姆式教学の温馨提示",depth:4},{text:"Produce 工作原理：将拷贝操作精准化",id:"produce-工作原理将拷贝操作精准化",depth:2},{text:"拓展：“知其所止”的“逐层拷贝”",id:"拓展知其所止的逐层拷贝",depth:2},{text:"思考：“知其所止”的软件设计表达",id:"思考知其所止的软件设计表达",depth:2},{text:"总结： Immutability 的实践演进",id:"总结-immutability-的实践演进",depth:2}],title:"10 拓展：剖析 Immer.js 工作原理与设计模式",headingTitle:"10 拓展：剖析 Immer.js 工作原理与设计模式",frontmatter:{}}}}]);