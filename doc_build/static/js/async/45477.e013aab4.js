"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["45477"],{326901:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var t=r(552676),c=r(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",strong:"strong",code:"code",pre:"pre",h2:"h2",h3:"h3",ol:"ol",li:"li",em:"em",h4:"h4",ul:"ul"},(0,c.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"25装饰器与反射元数据了解装饰器基本原理与应用",children:["25.装饰器与反射元数据：了解装饰器基本原理与应用",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25装饰器与反射元数据了解装饰器基本原理与应用",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"上一节我们了解了 TypeScript 与 ECMAScript 的关系，以及可选链与空值合并这两个 TypeScript 中的 ECMAScript 提案。其实，还有一个 ECMAScript 提案也已经成为 TypeScript 中相当重要的一部分，它就是装饰器。"}),"\n",(0,t.jsx)(n.p,{children:"装饰器语法在 Python、Java 等语言中都能见到，但在 JavaScript 中并没有被大量使用。一方面是由于语法提案迟迟没有落地，装饰器甚至还不能被称为 JavaScript 的一部分，另一方面则是它对应用场景有着一定要求，比如只能使用在 Class 上，而 Class 并不是 JavaScript 中大量使用的语法。"}),"\n",(0,t.jsx)(n.p,{children:"在这一节，我们来介绍的是 TypeScript 中的装饰器，包括基础语法、不同种类的装饰器、反射、反射元数据等等，在了解完毕这些概念后，下一节我们就可以着手基于这些概念来实现依赖注入、IoC 容器等高阶玩法了。"}),"\n",(0,t.jsx)(n.p,{children:"另外需要注意的是，TypeScript 中的装饰器在 5.0 版本之前与之后是完全不同的两个概念，本小册介绍的所有装饰器内容均是基于 5.0 版本之前的装饰器。在新版装饰器提案（即 5.0 版本之后的装饰器）正式落地后，我们才会新增章节来进行解析。"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["本节代码见：",(0,t.jsx)(n.a,{href:"https://github.com/linbudu599/TypeScript-Tiny-Book/tree/main/packages/21-decorators",target:"_blank",rel:"noopener noreferrer",children:"Decorators"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["首先我们需要明确的是，",(0,t.jsx)(n.strong,{children:"装饰器的本质其实就是一个函数"}),"，只不过它的入参是提前确定好的。同时，TypeScript 中的装饰器目前同样",(0,t.jsx)(n.strong,{children:"只能在类以及类成员上使用"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["装饰器通过 ",(0,t.jsx)(n.code,{children:"@"})," 语法来使用："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function Deco() { }\n\n@Deco\nclass Foo {}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样的装饰器只能起到固定的功能，因为它并不能动态接受入参。而我们实际上使用更多的是 Decorator Factory 的形式，即让 Deco 返回实际作为装饰器的函数，而不是本身作为装饰器。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function Deco() { \n  return () => {}\n}\n\n@Deco()\nclass Foo {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在这种情况下，程序执行时会先执行 ",(0,t.jsx)(n.code,{children:"Deco()"})," ，再用内部返回的函数作为装饰器的实际逻辑。这样，我们就可以通过入参来灵活地调整装饰器的作用。接下来，我们就来学习一下 TypeScript 中的装饰器是如何使用的，它们分别有什么作用？"]}),"\n",(0,t.jsxs)(n.h2,{id:"装饰器大起底",children:["装饰器大起底",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#装饰器大起底",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["TypeScript 中的装饰器可以分为",(0,t.jsx)(n.strong,{children:"类装饰器"}),"、",(0,t.jsx)(n.strong,{children:"方法装饰器"}),"、",(0,t.jsx)(n.strong,{children:"访问符装饰器"}),"、",(0,t.jsx)(n.strong,{children:"属性装饰器"}),"以及",(0,t.jsx)(n.strong,{children:"参数装饰器"}),"五种，最常见的主要还是类装饰器、方法装饰器以及属性装饰器。接下来，我们会依次介绍这几种装饰器的具体使用。"]}),"\n",(0,t.jsxs)(n.h3,{id:"类装饰器",children:["类装饰器",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类装饰器",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"类装饰器是直接作用在类上的装饰器，它在执行时的入参只有一个，那就是这个类本身（而不是类的原型对象）。因此，我们可以通过类装饰器来覆盖类的属性与方法，如果你在类装饰器中返回一个新的类，它甚至可以篡改掉整个类的实现。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@AddProperty('linbudu')\n@AddMethod()\nclass Foo {\n  a = 1;\n}\n\nfunction AddMethod(): ClassDecorator {\n  return (target: any) => {\n    target.prototype.newInstanceMethod = () => {\n      console.log(\"Let's add a new instance method!\");\n    };\n    target.newStaticMethod = () => {\n      console.log(\"Let's add a new static method!\");\n    };\n  };\n}\n\nfunction AddProperty(value: string): ClassDecorator {\n  return (target: any) => {\n    target.prototype.newInstanceProperty = value;\n    target.newStaticProperty = `static ${value}`;\n  };\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里，我们通过 TypeScript 内置的 ClassDecorator 类型定义来进行类型标注，由于类装饰器只有一个参数，我们也不想使用过多的类型代码，这里我就直接 any 了。我们的函数返回了一个 ClassDecorator ，因此这个装饰器就是一个 Decorator Factory，在实际执行时需要以 ",(0,t.jsx)(n.code,{children:"@Deco()"})," 的形式调用。"]}),"\n",(0,t.jsxs)(n.p,{children:["在 AddMethod 与 AddProperty 方法中，我们分别在 target、",(0,t.jsx)(n.code,{children:"target.prototype"})," 上添加了方法与属性，还记得 ES6 中 Class 的本质仍然是基于原型的吗？在这里 target 上的属性实际上是",(0,t.jsx)(n.strong,{children:"静态成员"}),"，也就是其实例上不会获得的方法，而 ",(0,t.jsx)(n.code,{children:"target.prototype"})," 上的属性才是会随着继承与实例化过程被传递的",(0,t.jsx)(n.strong,{children:"实例成员"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"我们来调用一下看看："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const foo: any = new Foo();\n\nfoo.newInstanceMethod();\n(<any>Foo).newStaticMethod();\n\nconsole.log(foo.newInstanceProperty);\nconsole.log((<any>Foo).newStaticProperty);\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Let's add a new instance method!\nLet's add a new static method!\nlinbudu\nstatic linbudu\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们在这里调用的方法并没有直接在 Foo 中定义，而是通过装饰器来强行添加！我们也可以在装饰中返回一个子类："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const OverrideBar = (target: any) => {\n  return class extends target {\n    print() {}\n    overridedPrint() {\n      console.log('This is Overrided Bar!');\n    }\n  };\n};\n\n@OverrideBar\nclass Bar {\n  print() {\n    console.log('This is Bar!');\n  }\n}\n\n// 被覆盖了，现在是一个空方法\nnew Bar().print();\n\n// This is Overrided Bar!\n(<any>new Bar()).overridedPrint();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在 React Class 组件时代，其实你会发现有许多功能也是通过装饰器实现的。如 Mobx 的 ",(0,t.jsx)(n.code,{children:"@observer"})," 与 ",(0,t.jsx)(n.code,{children:"@observable"}),"，React-Redux 的 ",(0,t.jsx)(n.code,{children:"@connect"})," 等。"]}),"\n",(0,t.jsxs)(n.h3,{id:"方法装饰器",children:["方法装饰器",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方法装饰器",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["方法装饰器的入参包括",(0,t.jsx)(n.strong,{children:"类的原型"}),"、",(0,t.jsx)(n.strong,{children:"方法名"}),"以及",(0,t.jsx)(n.strong,{children:"方法的属性描述符"}),"（PropertyDescriptor），而通过属性描述符你可以控制这个方法的内部实现（即 value）、可变性（即 writable）等信息。"]}),"\n",(0,t.jsx)(n.p,{children:"能拿到原本实现，也就意味着，我们可以在执行原本方法的同时，插入一段新的逻辑，比如计算这个方法的执行耗时："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class Foo {\n  @ComputeProfiler()\n  async fetch() {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve('RES');\n      }, 3000);\n    });\n  }\n}\n\nfunction ComputeProfiler(): MethodDecorator {\n  return (\n    _target,\n    methodIdentifier,\n    descriptor: TypedPropertyDescriptor<any>\n  ) => {\n    const originalMethodImpl = descriptor.value!;\n    descriptor.value = async function (...args: unknown[]) {\n      const start = new Date();\n      const res = await originalMethodImpl.apply(this, args); // 执行原本的逻辑\n      const end = new Date();\n      console.log(\n        `${String(methodIdentifier)} Time: `,\n        end.getTime() - start.getTime()\n      );\n      return res;\n    };\n  };\n}\n\n(async () => {\n  console.log(await new Foo().fetch());\n})();\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"fetch Time:  3003\nRES\n"})}),"\n",(0,t.jsxs)(n.p,{children:["需要注意的是，方法装饰器的 target 是",(0,t.jsx)(n.strong,{children:"类的原型而非类本身"}),"。"]}),"\n",(0,t.jsxs)(n.h3,{id:"访问符装饰器",children:["访问符装饰器",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#访问符装饰器",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["访问符装饰器并不常见，甚至访问符对于部分同学来说也是陌生的，但它其实就是 ",(0,t.jsx)(n.code,{children:"get value(){}"})," 与 ",(0,t.jsx)(n.code,{children:"set value(v)=>{}"})," 这样的方法，其中 getter 在你访问这个属性 ",(0,t.jsx)(n.code,{children:"value"})," 时触发，而 setter 在你对 ",(0,t.jsx)(n.code,{children:"value"})," 进行赋值时触发。访问符装饰器本质上仍然是方法装饰器，它们使用的类型定义也相同。"]}),"\n",(0,t.jsx)(n.p,{children:"需要注意的是，访问符装饰器只能同时应用在一对 getter / setter 的其中一个，即要么装饰 getter 要么装饰 setter 。这是因为，不论你是装饰哪一个，装饰器入参中的属性描述符都会包括 getter 与setter 方法："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class Foo {\n  _value!: string;\n\n  get value() {\n    return this._value;\n  }\n\n  @HijackSetter('LIN_BU_DU')\n  set value(input: string) {\n    this._value = input;\n  }\n}\n\nfunction HijackSetter(val: string): MethodDecorator {\n  return (target, methodIdentifier, descriptor: any) => {\n    const originalSetter = descriptor.set;\n    descriptor.set = function (newValue: string) {\n      const composed = `Raw: ${newValue}, Actual: ${val}-${newValue}`\n      originalSetter.call(this, composed);\n      console.log(`HijackSetter: ${composed}`);\n    };\n    // 篡改 getter，使得这个值无视 setter 的更新，返回一个固定的值\n    // descriptor.get = function () {\n    //   return val;\n    // };\n  };\n}\n\nconst foo = new Foo();\nfoo.value = 'LINBUDU'; // HijackSetter: Raw: LINBUDU, Actual: LIN_BU_DU-LINBUDU\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在这个例子中，我们通过装饰器劫持了 setter ，在执行原本的 setter 方法修改了其参数。同时，我们也可以在这里去劫持 getter（",(0,t.jsx)(n.code,{children:"descriptor.get"}),"），这样一来在读取这个值时，会直接返回一个我们固定好的值，而非其实际的值（如被 setter 更新过的）。"]}),"\n",(0,t.jsxs)(n.h3,{id:"属性装饰器",children:["属性装饰器",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#属性装饰器",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["属性装饰器在独立使用时能力非常有限，它的入参只有",(0,t.jsx)(n.strong,{children:"类的原型"}),"与",(0,t.jsx)(n.strong,{children:"属性名称"}),"，返回值会被忽略，但你仍然可以通过",(0,t.jsx)(n.strong,{children:"直接在类的原型上赋值"}),"来修改属性："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class Foo {\n  @ModifyNickName()\n  nickName!: string;\n  constructor() {}\n}\n\nfunction ModifyNickName(): PropertyDecorator {\n  return (target: any, propertyIdentifier) => {\n    target[propertyIdentifier] = '林不渡!';\n    target['otherName'] = '别名林不渡!';\n  };\n}\n\nconsole.log(new Foo().nickName);\n// @ts-expect-error\nconsole.log(new Foo().otherName);\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"林不渡!\n别名林不渡!\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们在原型对象上强行写入了属性，但这种方法实际上过于 hack，在后面我们会了解如何通过委托的方式来为一个属性注入值。"}),"\n",(0,t.jsxs)(n.h3,{id:"参数装饰器",children:["参数装饰器",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参数装饰器",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["参数装饰器包括了构造函数的参数装饰器与方法的参数装饰器，它的入参包括",(0,t.jsx)(n.strong,{children:"类的原型"}),"、",(0,t.jsx)(n.strong,{children:"参数所在的方法名"}),"与",(0,t.jsx)(n.strong,{children:"参数在函数参数中的索引值（即第几个参数）"}),"，如果只是单独使用，它的作用同样非常有限。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class Foo {\n  handler(@CheckParam() input: string) {\n    console.log(input);\n  }\n}\n\nfunction CheckParam(): ParameterDecorator {\n  return (target, methodIdentifier, index) => {\n    console.log(target, methodIdentifier, index);\n  };\n}\n\n// {} handler 0\nnew Foo().handler('linbudu');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["后面我们会了解如何基于参数装饰器进行参数的默认值注入与校验，现在就先到这儿，思考另一个问题：一个类中可以同时拥有这几种装饰器，那么这些",(0,t.jsx)(n.strong,{children:"不同装饰器的执行时机与顺序是如何的"}),"？"]}),"\n",(0,t.jsxs)(n.h3,{id:"装饰器的执行机制",children:["装饰器的执行机制",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#装饰器的执行机制",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["装饰器的执行机制中主要包括",(0,t.jsx)(n.strong,{children:"执行时机"}),"、",(0,t.jsx)(n.strong,{children:"执行原理"}),"以及",(0,t.jsx)(n.strong,{children:"执行顺序"}),"这三个概念。"]}),"\n",(0,t.jsx)(n.p,{children:"首先是执行时机，还记得我们在最开始说的吗？装饰器的本质就是一个函数，因此只要在类上定义了它，即使不去实例化这个类或者读取静态成员，它也会正常执行。很多时候，其实我们也并不会实例化具有装饰器的类，而是通过反射元数据的能力来消费，这一点我们后面会讲到。而装饰器的执行原理，我们可以通过编译后的代码来了解："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@Cls()\nclass Foo {\n  constructor(@Param() init?: string) { }\n\n  @Prop()\n  prop!: string\n\n  @Method()\n  handler(@Param() input: string) {\n\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这一段代码编译的产物会是这样的（经过简化）："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'"use strict";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n   // ...\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\n\nlet Foo = class Foo {\n    constructor(init) { }\n    handler(input) {\n    }\n};\n__decorate([\n    Prop(),\n], Foo.prototype, "prop", void 0);\n__decorate([\n    Method(),\n    __param(0, Param()),\n], Foo.prototype, "handler", null);\nFoo = __decorate([\n    Cls(),\n    __param(0, Param()),\n], Foo);\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["完整的代码见：",(0,t.jsx)(n.a,{href:"https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAYQDYGcAUBKAXC1AQ3XQBEBTCOAJ0KhsQG8AoRRa8qEapTKQ6gHNO2RAF4AfE0QBfZnOahIsBIgCynABZwAJjnwao2nRSq161Jq3aduvfkJHipjWfOaLw0eEgAK1OAAHfUR-IPJqKABPUxo6BhY2Di4eRD4BYShRSSs2OQUlb1VfAUIAWxCS2jLOCNjzBOtkuzSHTOyXNwUAATQsbGYIIhJEADE4OFzEKjB0KGoQaBpMbqrynEQYMBgoAH58OeotwVFXBTZVgOCBtkCrg-nj8UQAclQtgCMQHRAXjwuwtdrHM6DAIIgQbAIICHkcwIJni9IWDEO8wF8fn9rN1DMYcNZNIQwDpUBEVmsKqItoEQFBYcdTv83Njcbp8WxkeDOQAJIkksmrUqUzZgGl0iGPeGM6z5DyDBBzRDACbPMDkADuYwmOAA3EA",target:"_blank",rel:"noopener noreferrer",children:"Playground"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["这里的 ",(0,t.jsx)(n.code,{children:"__decorate"})," 方法，其实就是通过实际入参来判断当前到底执行的是哪种装饰器，然后执行对应的装饰逻辑。而观察这个方法调用时的入参，我们会再次观察到这些装饰器的不同入参：",(0,t.jsx)(n.strong,{children:"方法与属性装饰器是类的原型对象"}),"，而",(0,t.jsx)(n.strong,{children:"类装饰器才能获得这个类本身作为入参"}),"。而属性装饰器应用时，这个属性还未被初始化（属性需要实例化才会有值），这也是为什么它无法像方法装饰器那样获取到值。"]}),"\n",(0,t.jsxs)(n.p,{children:["可以看到，上面的装饰器顺序依次是",(0,t.jsx)(n.strong,{children:"实例上的属性、方法、方法参数"}),"，然后是",(0,t.jsx)(n.strong,{children:"静态的属性、方法、方法参数"}),"，最后是",(0,t.jsx)(n.strong,{children:"类以及类构造函数参数"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["而从这一编译结果中，我们还能观察到不同类型装饰器的",(0,t.jsx)(n.strong,{children:"执行顺序"}),"。首先是实例上的属性、方法、方法参数，然后是静态的属性、方法、方法参数，最后是类以及类构造函数参数。而装饰器的",(0,t.jsx)(n.strong,{children:"应用顺序"}),"则略有不同，",(0,t.jsx)(n.strong,{children:"方法参数装饰器会先于方法装饰器应用"}),"（",(0,t.jsx)(n.code,{children:"__param(0, Param())"}),"）。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["关于执行顺序与应用顺序，执行是",(0,t.jsx)(n.strong,{children:"装饰器求值得到最终装饰器表达式"}),"的过程，而应用则是",(0,t.jsx)(n.strong,{children:"最终装饰器逻辑代码执行"}),"的过程："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function deco() {\n  // 执行\n  return () => {\n    // 应用\n  }\n}\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["实际上，对于实例与静态的属性、方法装饰器而言，它们的执行与应用顺序其实",(0,t.jsx)(n.strong,{children:"取决于它们定义的位置"}),"，你可以在上面的例子里把方法定义在属性之前，就会发现执行顺序变成了",(0,t.jsx)(n.strong,{children:"方法"}),"-",(0,t.jsx)(n.strong,{children:"方法参数"}),"-",(0,t.jsx)(n.strong,{children:"属性"}),"，即先定义先执行。"]}),"\n",(0,t.jsx)(n.p,{children:"在 TypeScript 官方文档中对应用顺序给出了详细的定义："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"参数装饰器"}),"，然后依次是",(0,t.jsx)(n.em,{children:"方法装饰器"}),"，",(0,t.jsx)(n.em,{children:"访问符装饰器"}),"，或",(0,t.jsx)(n.em,{children:"属性装饰器"}),"应用到每个实例成员。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"参数装饰器"}),"，然后依次是",(0,t.jsx)(n.em,{children:"方法装饰器"}),"，",(0,t.jsx)(n.em,{children:"访问符装饰器"}),"，或",(0,t.jsx)(n.em,{children:"属性装饰器"}),"应用到每个静态成员。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"参数装饰器"}),"应用到构造函数。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"类装饰器"}),"应用到类。"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"最后，我们再看一个例子，来更深刻地了解执行顺序与应用顺序："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function Deco(identifier: string): any {\n  console.log(`${identifier} 执行`);\n  return function () {\n    console.log(`${identifier} 应用`);\n  };\n}\n\n@Deco('类装饰器')\nclass Foo {\n  constructor(@Deco('构造函数参数装饰器') name: string) {}\n\n  @Deco('实例属性装饰器')\n  prop?: number;\n\n  @Deco('实例方法装饰器')\n  handler(@Deco('实例方法参数装饰器') args: any) {}\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"以上的代码输出是这样的："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"实例属性装饰器 执行\n实例属性装饰器 应用\n实例方法装饰器 执行\n实例方法参数装饰器 执行\n实例方法参数装饰器 应用\n实例方法装饰器 应用\n类装饰器 执行\n构造函数参数装饰器 执行\n构造函数参数装饰器 应用\n类装饰器 应用\n"})}),"\n",(0,t.jsxs)(n.p,{children:["执行顺序就不再赘述，这里我们主要关注应用顺序。顺序大致是",(0,t.jsx)(n.strong,{children:"实例属性-实例方法参数-构造函数参数-类"}),"，好像不对，不是说参数装饰器先应用吗？这是因为在这个例子中，我们是先定义属性和属性装饰器的，因此属性装饰器会先应用。如果方法在前，可不就是方法参数装饰器先应用？"]}),"\n",(0,t.jsxs)(n.p,{children:["你会发现，类装饰器是最后应用的。也就是说，如果我们在方法装饰器中标记某些信息，最终的类装饰器是可以消费到，并且基于此信息对类或类的实例进行某些操作的。如标记为 ",(0,t.jsx)(n.code,{children:"@Deprecated"})," 的方法，我们在最终的类装饰器中可以将这些方法实现替换为一个报错！而标记这些信息的方法则有很多，最简单的如，在全局声明一个 Map，类作为 Key，这些信息作为 Value 也是可以的。当然，后面我们会说到如何使用更好的方式实现。"]}),"\n",(0,t.jsxs)(n.h4,{id:"多个同类装饰器的执行顺序",children:["多个同类装饰器的执行顺序",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#多个同类装饰器的执行顺序",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"另外，我们也可以使用多个同种装饰器，比如一个类上可以有好多个类装饰器："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@Deprecated()\n@User()\n@Internal\n@Provide()\nclass Foo {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这种情况下，这些装饰器的执行顺序又是怎样的？其顺序分为两步。首先，",(0,t.jsx)(n.strong,{children:"由上至下"}),"依次对装饰器的表达式求值，得到装饰器的实现，",(0,t.jsx)(n.code,{children:"@Internal"})," 中实现即为 Internal 方法，而 ",(0,t.jsx)(n.code,{children:"@Provide()"})," 中实现则需要进行一次求值。"]}),"\n",(0,t.jsxs)(n.p,{children:["然后，这些装饰器的具体实现才会",(0,t.jsx)(n.strong,{children:"从下往上"}),"调用，如这里是 Provide、Internal、User、Deprecated 的顺序。从这个角度来看，甚至有点像洋葱模型："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function Foo(): MethodDecorator {\n  console.log('foo in');\n  return (target, propertyKey, descriptor) => {\n    console.log('foo out');\n  };\n}\n\nfunction Bar(): MethodDecorator {\n  console.log('bar in');\n  return (target, propertyKey, descriptor) => {\n    console.log('bar out');\n  };\n}\n\nconst Baz: MethodDecorator = () => {\n  console.log('baz apply');\n};\n\nclass User {\n  @Foo()\n  @Bar()\n  @Baz\n  method() {}\n}\n\n// foo in\n// bar in\n// baz apply\n// bar out\n// foo out\n"})}),"\n",(0,t.jsxs)(n.p,{children:["类似的，如果一个方法中的多个参数均存在装饰器，那么同样是 ",(0,t.jsx)(n.code,{children:"Parma1 in"})," - ",(0,t.jsx)(n.code,{children:"Param2 in "})," - ",(0,t.jsx)(n.code,{children:"Param2 out"})," - ",(0,t.jsx)(n.code,{children:"Param1 out"})," 的顺序，也就是",(0,t.jsx)(n.strong,{children:"后面参数的装饰器逻辑"}),"反而先执行。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"但我们通常不会在同种装饰器中进行存在依赖关系的操作。"})," 对于属性、参数装饰器来说，我们通常只进行信息注册，委托别人处理。对于方法装饰器来说，我们最多只进行方法执行前后的逻辑注入。而这些过程都应当是彼此独立的。"]}),"\n",(0,t.jsxs)(n.p,{children:["那么，这里的委托又如何实现呢？这时候我们就要介绍一位新朋友了：",(0,t.jsx)(n.strong,{children:"反射（Reflect）"}),"。你可能很早就认识，但没怎么接触过。"]}),"\n",(0,t.jsxs)(n.h2,{id:"反射-reflect",children:["反射 Reflect",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#反射-reflect",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["Reflect 是在 ES6 中引入的全局对象，它仅仅是用于作为一个命名空间来存放顶级方法，比如 ",(0,t.jsx)(n.code,{children:"Reflect.ownKeys"}),"、",(0,t.jsx)(n.code,{children:"Reflect.defineProperty"})," 等等。你可能会感到疑惑，不是已经有了个 ",(0,t.jsx)(n.code,{children:"Object.defineProperty"})," 吗？"]}),"\n",(0,t.jsxs)(n.p,{children:["这就是引入 Reflect 的目的之一了，我们知道 JavaScript 的早期有相当多比较“赶工”的部分，比如 ",(0,t.jsx)(n.code,{children:"Object.defineProperty"})," 其实不应该放在 Object 命名空间下，它其实是整个语言层面的顶级方法，比如我们并不是只能用它来给对象定义属性："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function foo() {}\n\nObject.defineProperty(foo, 'validator', {\n  value: function () {\n    throw new Error('Validation Failed');\n  },\n});\n\nfoo.validator();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在上面的例子里，我们就使用 ",(0,t.jsx)(n.code,{children:"Object.defineProperty"})," 给函数 foo 定义了一个属性方法 validator，那这不就显得怪怪的了，怎么用对象下的顶级方法来处理函数了？"]}),"\n",(0,t.jsxs)(n.p,{children:["在引入 Reflect 后，后续再有这一类语言层面的顶级方法，就可以把它放置在 Reflect 命名空间下了。另外，此前某些 Object 下的顶级方法可能存在一些不合理的行为，比如 ",(0,t.jsx)(n.code,{children:"Object.defineProperty"})," 用于为一个不可扩展的对象定义属性时，会抛出一个错误，这种语言的历史债务已经无法再修改，那么，正好我们现在在 Reflect 下也提供了一个同名实现，就可以趁此机会把这些方法的表现修改得更合理一些。"]}),"\n",(0,t.jsx)(n.p,{children:"除此以外，Reflect 还有一个比较特殊的作用场景是配合 Proxy。比如下面的例子里，我们通过 Proxy 修改了 target 对象的赋值行为 set，那假设我们只是想在赋值行为前后做点事情，还是想进行赋值操作的，此时应该咋办？假如你这么写："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const target = {};\n\nconst proxiedTarget = new Proxy(target, {\n  set: function (target, name, value, receiver) {\n    proxiedTarget.name = value;\n    console.log('property ' + name + ' set to ' + value);\n  },\n});\n\nproxiedTarget.name = 'foo';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["执行这段代码，恭喜你得到了一个 ",(0,t.jsx)(n.code,{children:"Maximum call stack size exceeded"})," 错误。这是因为此时 proxiedTarget 的 set 方法已经被代理了，在 set 方法内去赋值又会再进入 set 方法...。"]}),"\n",(0,t.jsxs)(n.p,{children:["此时，我们需要使用 ",(0,t.jsx)(n.code,{children:"Reflect.set"})," 方法来实现赋值逻辑："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const target = {};\n\nconst proxiedTarget = new Proxy(target, {\n  set: function (target, name, value, receiver) {\n    const success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' set to ' + value);\n    }\n    return success;\n  },\n});\n\nproxiedTarget.name = 'foo';\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样就行了！Proxy 上的这些方法会一一对应到 Reflect 中，如 defineProperty、deleteProperty、apply、get、set、has 等等，这样一来，无论你在 Proxy 中覆盖了哪个方法，都可以使用 Reflect 来获取到其原本的实现。"}),"\n",(0,t.jsx)(n.p,{children:"总结一下，Reflect 方法主要有这么些功能："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"整理语言层面的顶级方法，让它们待在更合理的命名空间下。"}),"\n",(0,t.jsx)(n.li,{children:"修正部分方法的表现。"}),"\n",(0,t.jsx)(n.li,{children:"配合 Proxy，提供一份不会被覆盖的方法实现。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["在上面例子里， ",(0,t.jsx)(n.code,{children:"Reflect.set"})," 方法是运行时才实际执行的，也就是说我们通过反射，在",(0,t.jsx)(n.strong,{children:"运行时去修改了程序的行为"}),"。这就是反射的核心要素：",(0,t.jsx)(n.strong,{children:"在程序运行时去检查、修改程序行为"}),"，比如除了赋值以外，我们还可以在运行时通过 ",(0,t.jsx)(n.code,{children:"Reflect.construct"})," 实例化一个类，通过 ",(0,t.jsx)(n.code,{children:"Reflect.setPrototypeOf"})," 修改对象原型指向等等。"]}),"\n",(0,t.jsx)(n.p,{children:"虽然我们的主要内容和反射并没有太大的关系，下面要介绍的反射元数据才是本节的重量级角色，但是，了解「运行时修改程序行为」这个关键，能够帮助你更好地理解反射元数据的概念。"}),"\n",(0,t.jsxs)(n.h2,{id:"反射元数据-reflect-metadata",children:["反射元数据 Reflect Metadata",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#反射元数据-reflect-metadata",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["不同于反射，",(0,t.jsx)(n.strong,{children:"反射元数据（Reflect Metadata）"})," 这一提案虽然同样很早就被提出，但至今都未真正的成为 ECMAScript 的一部分，原因在于，元数据和装饰器提案的联系非常紧密，随着装饰器提案迟迟不能推进，元数据当然也无法独自向前。目前，想要使用反射元数据，你还需要安装 ",(0,t.jsx)(n.a,{href:"https://github.com/rbuckton/reflect-metadata",target:"_blank",rel:"noopener noreferrer",children:"reflect-metadata"})," ，并在入口文件中的顶部 ",(0,t.jsx)(n.code,{children:'import "reflect-metadata"'})," 。"]}),"\n",(0,t.jsxs)(n.p,{children:["反射元数据提案（即 ",(0,t.jsx)(n.code,{children:'"reflect-metadata"'})," 包）为 Reflect 新增了一批专用于元数据读写的 API，如 ",(0,t.jsx)(n.code,{children:"Reflect.defineMetadata"}),"、",(0,t.jsx)(n.code,{children:"Reflect.getMetadata"})," 等。"]}),"\n",(0,t.jsx)(n.p,{children:"那么，元数据又是什么？想想我们在上面介绍的反射的概念——「在程序运行时修改程序行为」，在想想「反射元数据」这个名词，会不会有点灵感？"}),"\n",(0,t.jsxs)(n.p,{children:["你可以将元数据理解为，",(0,t.jsx)(n.strong,{children:"用于描述程序自身特性的数据"}),"，比如，某个方法的参数信息、返回值信息可以称为该方法的元数据，某个类的实例化参数、内部的方法可以称之为这个类的元数据。"]}),"\n",(0,t.jsx)(n.p,{children:"因此我们可以知道，Reflect 中新增的元数据读写方法，其实也还是用于运行时的各种操作。先来简单使用下元数据的注册与提取："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import 'reflect-metadata';\n\nclass Foo {\n  handler() {}\n}\n\nReflect.defineMetadata('class:key', 'class metadata', Foo);\nReflect.defineMetadata('method:key', 'handler metadata', Foo, 'handler');\nReflect.defineMetadata(\n  'proto:method:key',\n  'proto handler metadata',\n  Foo.prototype,\n  'handler'\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:"defineMetadata 的入参包括元数据 Key、元数据 Value、目标类 Target 以及一个可选的属性，上面的三处调用分别代表了："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"在 Foo 这个类上，注册一个 key 为 class:key，值为 class metadata 的元数据"}),"\n",(0,t.jsx)(n.li,{children:"在 Foo 这个类的方法 handler 上，注册一个 key 为 method:key，值为 handler metadata 的元数据"}),"\n",(0,t.jsx)(n.li,{children:"在 Foo 这个类的原型的方法 handler 上，注册一个 key 为 proto:method:key，值为 proto handler metadata 的元数据"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"而提取则可以通过 getMetadata 方法："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// class metadata\nconsole.log(Reflect.getMetadata('class:key', Foo));\n// handler metadata\nconsole.log(Reflect.getMetadata('method:key', Foo, 'handler'));\n// proto handler metadata\nconsole.log(Reflect.getMetadata('proto:method:key', Foo.prototype, 'handler'));\n"})}),"\n",(0,t.jsx)(n.p,{children:"实际上，反射元数据正是我们实现属性装饰器中提到的“委托”能力的基础。现在我们可以使用元数据进一步完善它了："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import 'reflect-metadata';\n\nclass Foo {\n\n  @ModifyNickName()\n  nickName!: string;\n  constructor() {}\n}\n\nfunction ModifyNickName(): PropertyDecorator {\n  return (target: any, propertyIdentifier) => {\n    Reflect.defineMetadata('prop', propertyIdentifier, target)\n  };\n}\n\nconst foo = new Foo();\n\nconst propToInject = Reflect.getMetadata('prop', foo);\n\nconst propProvider = {\n  nickName: '林不渡',\n  otherName: '别名林不渡'\n}\n\nfoo[propToInject] = propProvider[propToInject];\n\nconsole.log(foo); // { nickName: '林不渡' }\n"})}),"\n",(0,t.jsx)(n.p,{children:"来解释一下上面的代码："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["在属性装饰器中 ",(0,t.jsx)(n.code,{children:"ModifyNickName"})," ，为这个类注册一个元数据，名为 prop，值为 nickName 属性名。也就是告知后续调用方，这个类型上的 nickName 属性名需要被修改。"]}),"\n",(0,t.jsx)(n.li,{children:"在实例化这个类后，拿到实例上的元数据，获得 nickName 这个属性名。"}),"\n",(0,t.jsx)(n.li,{children:"从 propProvider 中，将 nickName 这个属性名对应的值取出，赋值给实例 foo 上的同名属性。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"相比于开始的简单粗暴的注入方式，使用元数据实现的委托要更加标准与灵活。我们只需要实现一个 propProvider 这样的集中式注入中心，再按照需要注入元数据，就能够完成各种基于元数据的修改行为了。"}),"\n",(0,t.jsx)(n.p,{children:"而实际上，某些时候我们使用装饰器就仅仅只是为了注入元数据而已。考虑到这一点，反射元数据中直接就内置了基于装饰器的调用方式："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"@Reflect.metadata('class:key', 'METADATA_IN_CLASS')\nclass Foo {\n  @Reflect.metadata('prop:key', 'METADATA_IN_PROPERTY')\n  public prop: string = 'linbudu';\n\n  @Reflect.metadata('method:key', 'METADATA_IN_METHOD')\n  public handler(): void {}\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"@Reflect.metadata"})," 装饰器会基于应用的位置进行实际的逻辑调用，如在类上装饰时以类作为 target 进行注册，而在静态成员与实例成员中分别使用构造函数、构造函数原型。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const foo = new Foo();\n\n// METADATA_IN_CLASS\nconsole.log(Reflect.getMetadata('class:key', Foo));\n// undefined\nconsole.log(Reflect.getMetadata('class:key', Foo.prototype));\n\n// METADATA_IN_METHOD\nconsole.log(Reflect.getMetadata('method:key', Foo.prototype, 'handler'));\n// METADATA_IN_METHOD\nconsole.log(Reflect.getMetadata('method:key', foo, 'handler'));\n\n// METADATA_IN_PROPERTY\nconsole.log(Reflect.getMetadata('prop:key', Foo.prototype, 'prop'));\n// METADATA_IN_PROPERTY\nconsole.log(Reflect.getMetadata('prop:key', foo, 'prop'));\n"})}),"\n",(0,t.jsx)(n.p,{children:"看起来我们现在拥有了实现委托的基本能力，但实际上这还不够。所有的元数据都需要我们提前定义好，如果我们希望直接用一些已有的信息作为元数据呢？比如下面这个例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class UserService {\n  @InjectModel()\n  userModel: UserModel;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["我希望将 userModel 属性的类型 UserModel 作为一个元数据信息注入，同时我不会为 ",(0,t.jsx)(n.code,{children:"@InjectModel()"})," 装饰器提供任何信息，那我们就束手无策了吗？"]}),"\n",(0,t.jsxs)(n.p,{children:["还记得我们在介绍反射概念时说的，",(0,t.jsx)(n.strong,{children:"反射允许程序去检视自身"}),"，而属性类型作为程序的一部分，也应当是能被反射收集的。为了实现这一目的，TypeScript 内的反射元数据中还内置了基于类型的元数据信息，你可以通过 ",(0,t.jsx)(n.code,{children:"design:type"}),"、",(0,t.jsx)(n.code,{children:"design:paramtypes"})," 以及 ",(0,t.jsx)(n.code,{children:"design:returntype"})," 这三个内置的元数据 Key，获取到类与类成员的类型、参数类型、返回值类型："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import 'reflect-metadata';\n\nfunction Inject() {\n  return () => { }\n}\n\n@Inject()\nclass Foo {\n\n  @Inject()\n  name: string;\n\n  @Inject()\n  add(source: number, input: number): number {\n    return source + input;\n  }\n}\n\nconst foo = new Foo();\n\nconsole.log(Reflect.getMetadata('design:type', foo, 'name')); // [Function String]\nconsole.log(Reflect.getMetadata('design:type', foo, 'add')); // [Function Function]\nconsole.log(Reflect.getMetadata('design:paramtypes', foo, 'add')); // [[Function Number], [Function Number]]\nconsole.log(Reflect.getMetadata('design:returntype', foo, 'add')); // [Function Number]\n"})}),"\n",(0,t.jsx)(n.p,{children:"实际上，这些内置的元数据信息是由 TypeScript 在编译时提供的。我们来看一个简单点的例子与它的编译结果："}),"\n",(0,t.jsx)(n.p,{children:"需要注意的是，这些类型信息是来自于运行时，而非我们的类型标注。同时这些内置元数据取出的值是装箱类型对象，如 String、Number 等。"}),"\n",(0,t.jsx)(n.p,{children:"TypeScript 为其进行了额外的支持，然后我们才可以获取到类型标注所对应的元数据，如："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import 'reflect-metadata';\n\nfunction Inject() {\n  return () => { }\n}\n\nclass Foo {}\n\nclass Bar {\n  @Inject()\n  prop!: Foo;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这段代码的编译结果大概长这样："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'var __decorate = /* ... */\n\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, "__esModule", { value: true });\nrequire("reflect-metadata");\n\nfunction Inject() {\n    return () => { };\n}\nclass Foo {\n}\nclass Bar {\n}\n__decorate([\n    Inject(),\n    __metadata("design:type", Foo)\n], Bar.prototype, "prop", void 0);\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["可以看到，",(0,t.jsx)(n.code,{children:"design:type"})," 这个元数据实际上是通过 ",(0,t.jsx)(n.code,{children:'__metadata("design:type", Foo)'})," 这段调用注入的。其实这也是为什么我们需要启用 ",(0,t.jsx)(n.code,{children:"emitDecoratorMetadata"})," 配置的原因之一，比如我们关掉这个配置再编译一遍："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'var __decorate = /* ... */\n\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, "__esModule", { value: true });\nrequire("reflect-metadata");\nfunction Inject() {\n    return () => { };\n}\nclass Foo {\n}\nclass Bar {\n}\n__decorate([\n    Inject()\n], Bar.prototype, "prop", void 0);\n'})}),"\n",(0,t.jsx)(n.p,{children:"这个对比是不是就一目了然了？"}),"\n",(0,t.jsx)(n.p,{children:"有了装饰器、反射元数据以及内置的基于类型的元数据信息，我们就可以实现“委托”的能力了。以看似平平无奇的属性装饰器为例，我们使用元数据来实现基于装饰器的属性校验。"}),"\n",(0,t.jsx)(n.p,{children:"在这个例子里，我们会实现两种校验逻辑，对必填属性（Required）与属性类型的校验（String / Number / Boolean），其基本使用方式如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class User {\n \xa0@Required()\n \xa0name!: string;\n\n \xa0@ValueType(TypeValidation.Number)\n \xa0age!: number;\n}\n\nconst user = new User();\n// @ts-expect-error\nuser.age = '18';\n"})}),"\n",(0,t.jsx)(n.p,{children:"我们会将 user 实例传递给校验方法，在这里应当给出两处错误："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"没有提供必填属性 name"}),"\n",(0,t.jsx)(n.li,{children:"age 属性的类型不符。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"如果理解了元数据的作用，那我们的思路就很明确了，装饰器将元数据附加到属性或类上，然后校验方法中遍历属性读取这些元数据，再对比类型是否匹配即可。"}),"\n",(0,t.jsx)(n.p,{children:"首先是 Required ，我们肯定下意识是这么写："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'function Required(): PropertyDecorator {\n \xa0return (target, prop) => {\n \xa0 \xa0Reflect.defineMetadata("required", true, target, prop);\n  };\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"也就是在这个属性上定义了一个名为 required 的元数据。但你是否想过，如果实例中根本就没有这个属性呢？就像上面的 user 一样，那这里的元数据不就丢失了？"}),"\n",(0,t.jsx)(n.p,{children:"要解决这一问题，其实只需要将元数据定义在类上即可。我们用一个专门描述必填属性的元数据，存储这个类内部所有的必填属性即可："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const requiredMetadataKey = Symbol('requiredKeys');\n\nfunction Required(): PropertyDecorator {\n \xa0return (target, prop) => {\n \xa0 \xa0const existRequiredKeys: string[] =\n \xa0 \xa0 \xa0Reflect.getMetadata(requiredMetadataKey, target) ?? [];\n\n \xa0 \xa0Reflect.defineMetadata(\n \xa0 \xa0 \xa0requiredMetadataKey,\n \xa0 \xa0  [...existRequiredKeys, prop],\n \xa0 \xa0 \xa0target\n \xa0  );\n  };\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["而对于属性的校验其实就简单了，由于对类型的校验逻辑可以归到一起，我们就使用",(0,t.jsx)(n.strong,{children:"装饰器工厂 + 入参"}),"的形式来注入对应的元数据信息，这次我们只需要在属性层面注入元数据即可："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"enum TypeValidation {\n \xa0String = 'string',\n \xa0Number = 'number',\n \xa0Boolean = 'boolean',\n}\n\nconst validationMetadataKey = Symbol('expectedType');\n\nfunction ValueType(type: TypeValidation): PropertyDecorator {\n \xa0return (target, prop) => {\n \xa0 \xa0Reflect.defineMetadata(validationMetadataKey, type, target, prop);\n  };\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"然后就是校验逻辑了，我们需要一个额外的 validator 方法："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function validator(entity: any) {}\n\nconsole.log(validator(user));\n"})}),"\n",(0,t.jsx)(n.p,{children:"如果校验完全通过，那这一方法的返回值则是一个空数组，否则的话内部会存有报错信息。首先是对于必填属性的校验，我们需要取出注册在类上的，描述必填属性的元数据，再检查这些必填属性是否都存在了："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function validator(entity: any) {\n \xa0const clsName = entity.constructor.name;\n \xa0const messages: string[] = [];\n \xa0// 先检查所有必填属性\n \xa0const requiredKeys: string[] = Reflect.getMetadata(\n \xa0 \xa0requiredMetadataKey,\n \xa0 \xa0entity\n  );\n\n \xa0// 基于反射拿到所有存在的属性\n \xa0const existKeys = Reflect.ownKeys(entity);\n\n \xa0for (const key of requiredKeys) {\n \xa0 \xa0if (!existKeys.includes(key)) {\n \xa0 \xa0 \xa0messages.push(`${clsName}.${key} should be required.`);\n \xa0 \xa0 \xa0// throw new Error(`${key} is required!`);\n \xa0  }\n  }\n\n \xa0return messages;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后是对属性类型的校验，我们的 TypeValidation 枚举中，枚举值就是 ",(0,t.jsx)(n.code,{children:"typeof"})," 的返回值，因此这里直接使用即可："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"function validator(entity: any) {\n \xa0// ...\n \xa0// 接着基于定义在属性上的元数据校验属性类型\n \xa0for (const key of existKeys) {\n \xa0 \xa0const expectedType: string = Reflect.getMetadata(\n \xa0 \xa0 \xa0validationMetadataKey,\n \xa0 \xa0 \xa0entity,\n \xa0 \xa0 \xa0key\n \xa0  );\n\n \xa0 \xa0if (!expectedType) continue;\n\n \xa0 \xa0// 枚举也是对象，因此 Object.values 同样可以生效（只不过也会包括键名）\n \xa0 \xa0// @ts-expect-error\n \xa0 \xa0if (Object.values(TypeValidation).includes(expectedType)) {\n \xa0 \xa0 \xa0const actualType = typeof entity[key];\n \xa0 \xa0 \xa0if (actualType !== expectedType) {\n \xa0 \xa0 \xa0 \xa0messages.push(\n \xa0 \xa0 \xa0 \xa0 \xa0`expect ${entity.constructor.name}.${String(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0key\n \xa0 \xa0 \xa0 \xa0  )} to be ${expectedType}, but got ${actualType}.`\n \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0// throw new Error(`${String(key)} is not ${expectedType}!`);\n \xa0 \xa0  }\n \xa0  }\n  }\n \xa0return messages;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"最终的输出会是这样的："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[\n \xa0'User.name should be required.',\n \xa0'expect User.age to be number, but got string.'\n]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["除了这两种校验，你也可以通过元数据的帮助来实现更复杂的校验逻辑。如 MinLength、MaxLength、Min、Max 甚至 Email、IP 这样，对属性值内容的校验。思路仍然还是那么简单明了：",(0,t.jsx)(n.strong,{children:"注册元数据，消费元数据"}),"。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["那么元数据又存储在哪里？提案中专门说明了这一点，为类或类属性添加了元数据后，构造函数（或是构造函数的原型，根据静态成员还是实例成员决定）会具有 ",(0,t.jsx)(n.code,{children:"[[Metadata]]"})," 属性，该属性内部包含一个 Map 结构，键为属性键，值为元数据键值对。也就是说，",(0,t.jsx)(n.strong,{children:"静态成员的元数据信息存储于构造函数"}),"，而",(0,t.jsx)(n.strong,{children:"实例成员的元数据信息存储于构造函数的原型上"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结与预告",children:["总结与预告",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结与预告",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这一节，我们了解了装饰器的基本概念，包括 TypeScript 中的五种装饰器，以及这些装饰器的入参、使用场景、执行顺序等等。另外我们还掌握了反射元数据的使用，目前看起来它好像并没有什么特别之处？那么在下一节，我们就会在反射元数据的基础上，去了解一个新的概念：控制反转。"}),"\n",(0,t.jsxs)(n.h2,{id:"扩展阅读",children:["扩展阅读",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"装饰器的坎坷进历程",children:["装饰器的坎坷进历程",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#装饰器的坎坷进历程",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"正如我们在开头提到的，装饰器从被作为一个提案提出开始，很是经历了一番风雨，下面我们就来具体介绍一下它到底都经历了些什么。"}),"\n",(0,t.jsxs)(n.p,{children:["首先需要明确的是，目前 JavaScript（ECMAScript）中的装饰器，和我们这节学习的 TypeScript 装饰器基本是两件完全不同的事物。",(0,t.jsx)(n.a,{href:"https://github.com/tc39/proposal-decorators",target:"_blank",rel:"noopener noreferrer",children:"装饰器提案"})," 距离最开始提出已经过去了数年，在这期间提案内容，也就是语法、作用与运行时机制等，已经迭代了四个版本。"]}),"\n",(0,t.jsxs)(n.p,{children:["第四个版本在 2022 年 3 月份的 TC39 会议中终于如愿进入 Stage 3，也就意味着这一版本的实现基本上就是未来最终落地的版本。此前的版本都在 Stage 2 就胎死腹中，而 TypeScript 与 Babel 中的装饰器则是基于第一版的提案实现的，虽然语法都还是 ",(0,t.jsx)(n.code,{children:"@"})," ，但这两个版本的装饰器实际上差异非常之大。"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["如果你有兴趣了解新版装饰器的具体语义，可以阅读我此前发表的 ",(0,t.jsx)(n.a,{href:"https://mp.weixin.qq.com/s/6PTcjJQTED3WpJH8ToXInw",target:"_blank",rel:"noopener noreferrer",children:"2022 年 3 月 TC39 会议报告"})," 来了解更多。另外，在 ECMAScript 装饰器进入 Stage 4，或已经有可用的编译支持（Babel / TypeScript ）后，我也会更新关于新版装饰器的使用说明。"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"通常来说， TypeScript 只会对已经到达 Stage 3 的提案进行提前的支持，如可选链、空值合并、逻辑赋值等。当 TypeScript 最初引入装饰器时大概是在 2015 年，此时装饰器提案位于 Stage 1 阶段。"}),"\n",(0,t.jsxs)(n.p,{children:["促使 TS 提前引入的一个重要原因是，当时存在一门 TS 的超集语言（也就是 JS 的超集的超集？）  ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/AtScript",target:"_blank",rel:"noopener noreferrer",children:"AtScript"}),"，它在 TS 的基础上去支持了装饰器语法，来供 Angular 框架使用。TS 团队与 Angular 团队在某种契机下达成一致，决定将装饰器以及相关的注解能力直接引入 TypeScript 中，而 Angular 团队不再维护 AtScript ，这实际上避免了未来可能出现的竞争与社区生态分裂问题。"]}),"\n",(0,t.jsx)(n.p,{children:"虽然这两个版本的装饰器确实差异很大，但你其实无需担心出现未来需要面对断崖式的更新，目前新版装饰器的能力基本上能完全覆盖旧版所能提供的能力，因此升级成本对于用户或者框架开发者来说都不会太高。而如果还想继续使用旧版装饰器怎么办？我猜 TypeScript 会通过引入一个新的 Compiler Option 来控制实际表现与编译产物。"}),"\n",(0,t.jsxs)(n.h3,{id:"reflectdecorate",children:["Reflect.decorate",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectdecorate",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["如果你去观察了装饰器的编译代码，会发现 ",(0,t.jsx)(n.code,{children:"__decorate"})," 方法中有一段代码是检查 ",(0,t.jsx)(n.code,{children:"Reflect.decorate"})," 方法是否存在。这一方法其实也来自于 Reflect Metadata，见 ",(0,t.jsx)(n.a,{href:"https://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L115",target:"_blank",rel:"noopener noreferrer",children:"L115"}),"。这一方法的作用就是，通过反射的方式来进行装饰，如："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"class Foo {}\n\nReflect.decorate([/** ...一组装饰器 */], Foo)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这也就意味着，你甚至可以",(0,t.jsx)(n.strong,{children:"在方法内部去装饰某一个类或其成"}),"员，而不是仅仅只能依赖需要提前定义好的装饰器。"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(s,{...e})}):s(e)}let o=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["TypeScript%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F25.%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%9A%E4%BA%86%E8%A7%A3%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8.md"]={toc:[{text:"装饰器大起底",id:"装饰器大起底",depth:2},{text:"类装饰器",id:"类装饰器",depth:3},{text:"方法装饰器",id:"方法装饰器",depth:3},{text:"访问符装饰器",id:"访问符装饰器",depth:3},{text:"属性装饰器",id:"属性装饰器",depth:3},{text:"参数装饰器",id:"参数装饰器",depth:3},{text:"装饰器的执行机制",id:"装饰器的执行机制",depth:3},{text:"多个同类装饰器的执行顺序",id:"多个同类装饰器的执行顺序",depth:4},{text:"反射 Reflect",id:"反射-reflect",depth:2},{text:"反射元数据 Reflect Metadata",id:"反射元数据-reflect-metadata",depth:2},{text:"总结与预告",id:"总结与预告",depth:2},{text:"扩展阅读",id:"扩展阅读",depth:2},{text:"装饰器的坎坷进历程",id:"装饰器的坎坷进历程",depth:3},{text:"Reflect.decorate",id:"reflectdecorate",depth:3}],title:"25.装饰器与反射元数据：了解装饰器基本原理与应用",headingTitle:"25.装饰器与反射元数据：了解装饰器基本原理与应用",frontmatter:{}}}}]);