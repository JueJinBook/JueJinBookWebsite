"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["45008"],{221954:function(e,n,t){t.r(n),t.d(n,{default:()=>l});var s=t(552676),r=t(740453);let a=t.p+"static/image/bff257467f67ebf1488d5fc86dfc93a1.5a5f32ed.webp",c=t.p+"static/image/1846b8c71d2b3edf913e76ab20119759.de710244.webp",d=t.p+"static/image/e6c78abaffc7f4b4c69a842d4292d665.8ea84ff5.webp";function i(e){let n=Object.assign({p:"p",strong:"strong",img:"img",h1:"h1",a:"a",ul:"ul",li:"li",blockquote:"blockquote",h2:"h2",pre:"pre",code:"code",ol:"ol",h3:"h3"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["我们知道 React 之间的通信方式有 props 和 callback、context（跨层级）、event bus 事件总线、ref 传递、状态管理五种方式。其中，状态管理可以",(0,s.jsx)(n.strong,{children:"无视组件之间的层级关系"}),"，通过",(0,s.jsx)(n.strong,{children:"集中式存储"}),"管理应用的状态，使数据流更加清晰，以此来解决大型复杂应用中的组件通信问题。如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"状态管理的方式有很多种，如：redux、mobx、recoil 等，除了这些三方库之外，我们是否可以使用自定义 Hooks 去帮助我们实现呢？"}),"\n",(0,s.jsx)(n.p,{children:"答案是肯定的。我们可以通过 useCreateStore、useConnect 两个自定义 Hooks，再配合 createContext 就可以实现一个简易版的状态库。"}),"\n",(0,s.jsx)(n.p,{children:"在状态管理的库中，redux 是我们在工作中最常用库，所以我们先来熟悉下 redux，然后再用自定义 Hooks 去模拟对应的功能，以此帮助我们更深层次地理解自定义 Hooks 的实践。"}),"\n",(0,s.jsxs)(n.h1,{id:"16实践篇实现简易版的-react-redux",children:["16.实践篇｜实现简易版的 react-redux",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16实践篇实现简易版的-react-redux",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"提到 redux，就不得不提及到 react-redux 库，它的作用是将 redux 接入到 React 中，实现在 React 中使用 redux 进行状态管理。"}),"\n",(0,s.jsx)(n.p,{children:"整个渲染的流程共有三个部分，分别是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Store：所有的状态存储在一个单一的 store （JavaScript 对象）中，并且对应的状态不允许改变；"}),"\n",(0,s.jsx)(n.li,{children:"Action：用于更新状态，当我们要改变 store 的值，就需要通过 dispatch 函数来帮助我们完成更新操作，通常而言 dispatch 中包含一个 type 属性，type 的值决定我们要执行的操作；"}),"\n",(0,s.jsx)(n.li,{children:"Reducer：用于更新状态的纯函数，它接收先前的状态和一个 action，然后返回最新的状态。"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"在网上找到了这张图，很形象，可帮助我们迅速了解 redux 的数据流。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.h2,{id:"具体使用",children:["具体使用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#具体使用",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"首先，在 react-redux 中提供了一个名为 Provider 的组件，它接收一个 store，用于将 store 传递给应用程序的所有组件，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"   <Provider store={store}>\n      <View /> // 视图组件\n   </Provider>\n"})}),"\n",(0,s.jsx)(n.p,{children:"其中 store 需要通过 redux 库提供的 createStore 方法来创建，createStore 接收一个参数：reducers，也就是对应的 action，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const store = createStore(reducers);\n\n// reducers 对应 action，多个 action 可用 combineReducers 处理\n// initialState 为默认值\nexport default function action(state = initialState, action: any) {\n\n  // 通过 type 去判断\n  switch (action.type) {\n    case xxx:\n    ...\n    default:\n      return state;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"之后，我们需要通过 react-redux 库中的 connect 函数去将组件与 redux store 连接起来，去使用即可。"}),"\n",(0,s.jsx)(n.p,{children:"在 connect 函数中接收两个参数，分别是：mapStateToProps 和 mapDispatchToProps。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"mapStateToProps："})," 用于更新 props，返回 store 中的值，作为 props，传入对应的组件中。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"mapDispatchToProps："})," 用于更新 action，会返回一个 dispatch，用来触发 action，如果没有第二个参数，则将 dispatch 作为 props 传入对应的组件中。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["在这里，我们简单写下示例，具体的代码可在 ",(0,s.jsx)(n.a,{href:"https://github.com/DomeSy/domesy-hooks",target:"_blank",rel:"noopener noreferrer",children:"GitHub"})," 中查看。"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// 文件位置：example/ReduxView/view\n\n// Father\nconst Index = ({ count, msg, onAdd, onSub }: any) => {\n  return (\n     ...\n  );\n};\n\n// 第一个用于传递 props， 第二个参数用于传递 action, 如果 第二个参数不传，会把 dispatch 当作 props 传递过去\nexport default connect(\n  (state: any) => ({ count: state.count, msg: state.msg }),\n  (dispatch: any) => {\n    return {\n      onAdd: () => dispatch({ type: "add" }),\n      onSub: () => dispatch({ type: "sub" }),\n    };\n  }\n)(Index);\n\n// Clear\nconst Index = ({ count, dispatch }: any) => {\n  return (\n      ...\n      <Button\n        style={{ marginLeft: 8 }}\n        onClick={() => dispatch({ type: "clear" })}\n      >\n        清除\n      </Button>\n    ... \n  );\n};\n\nexport default connect((state) => state)(Index);\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"效果展示",children:["效果展示",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#效果展示",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在这个案例中，有父组件：Father，以及它的子组件 Child 和孙组件 Son，此外还有 Father 的兄弟组件 Sibling，和毫无关联的清除组件 Clear。"}),"\n",(0,s.jsx)(n.p,{children:"其中 Child 组件内有一个输入框，用于改变 msg 的值，其他组件用于接收 msg，Clear 组件接收 count 值，同时可以将 store 中的值还原为初始状态和控制 Son 组件的展示状态。"}),"\n",(0,s.jsxs)(n.h1,{id:"设计揣摩实现跨层级通信",children:["设计揣摩：实现跨层级通信",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计揣摩实现跨层级通信",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在我们了解完 react-redux 后，简单从使用维度上做下总结：",(0,s.jsx)(n.strong,{children:"随时存，随时取。"})]}),"\n",(0,s.jsx)(n.p,{children:"这六个字非常简单，其意义是：可以在任意组件中使用 store 中的值，也可以在任意的组件中存储对应的值，无视对应的层级关系，实现状态共享。"}),"\n",(0,s.jsxs)(n.p,{children:["想要实现 react-redux 的功能，首先就要解决",(0,s.jsx)(n.strong,{children:"通信问题"}),"，让状态得到共享，使每个组件都能获得 store 中的状态，并且可以去改变它。"]}),"\n",(0,s.jsx)(n.p,{children:"所以，我们可以利用 context（跨层级）来实现跨层级的通信方式，也就是通过 useContext 来获取共有状态，所以我们需要 createContext 的帮助，用它来替代 Provider。"}),"\n",(0,s.jsx)(n.p,{children:"然后需要去实现以下两个自定义 Hooks 来实现 react-redux。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"useCreateStore："})," 类比 createStore，用于生成一个 Store，并提供对应的实例方法，帮助 useConnect 获取状态属性；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"useConnect："})," 类比 connect，让每个组件都能获取到 store 中的状态，并且提供 dispatch 方法，以此来订阅 state，如果 state 发生改变，被订阅的组件发生更新。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"参照 react-redux 的流程来一起看看实现的思路："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"存储一个公共的 store，用于全局管理 state，当 state 发生变化，通知对应的组件更新；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"收集使用 useConnect 的组件信息，用于后续的更新和销毁；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"维护负责更新的 dispatch，当值发生更新的时候，更新对应的组件；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"当组件销毁时，对应 store 内的数据也应当清除。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"明确思路后，我们接下来围绕以上四点去实现 useCreateStore 和 useConnect 即可。"}),"\n",(0,s.jsxs)(n.h1,{id:"实现步骤",children:["实现步骤",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现步骤",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"usecreatestore-实现",children:["useCreateStore 实现",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecreatestore-实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"首先，我利用 createContext 来替代 Provider，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'// createRedux.ts\nimport { createContext } from "react";\nconst ReduxContext = createContext(null);\nexport default ReduxContext;\n\n// index.ts\nconst Index = () => {\n  const store = useCreateStore(reducers, initialState);\n\n  return (\n    <ReduxContext.Provider value={store}>\n      <View />\n    </ReduxContext.Provider>\n  );\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"那么，ReduxContext.Provider 所接收的 store 需要 useCreateStore 进行处理即可。我们进行如下设计："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// useCreateStore.ts\nconst useCreateStore = (reducer: any, initState: any) => {\n  let store = useRef<any>(null);\n\n  if (!store.current) {\n    store.current = new ReduxHooksStore(reducer, initState);\n  }\n\n  return store.current;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"useCreateStore 的入参数分为两个："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"reducer："})," 对应 createStore 的 reducers，也就是 action；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"initState："})," 初始值，这里将初始化的值拆分出来，方便后续的操作。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"跟以往的自定义 Hooks 一样，我们需要通过 useRef 取存储对应的值，用于保存对应的实例帮助我们处理这些事，也就是 ReduxHooksStore。"}),"\n",(0,s.jsx)(n.p,{children:"至于 ReduxHooksStore 具体内部的实现，我们一步一步根据场景去实现。"}),"\n",(0,s.jsxs)(n.h2,{id:"useconnect",children:["useConnect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useconnect",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"useConnect 是模拟 connect 方法，可以让任意组件做到随时存，随时取。所以，它涉及两个功能："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"初始化：可以拿到 store 中的任意数据，提供给视图；"}),"\n",(0,s.jsx)(n.li,{children:"更新：提供 dispatch 方法，如果 store 中的数据发生改变，则通知对应的视图组件发生更新。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["所以，useConnect 返回的参数应当为 ",(0,s.jsx)(n.code,{children:"[state, dispatch]"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"初始化场景",children:["初始化场景",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化场景",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在整个案例中，共有 3 个初始化变量，分别是 count（数字）、msg（Child 中的消息）和 flag（控制 Son 组件展示的条件）。"}),"\n",(0,s.jsx)(n.p,{children:"在初始化的场景中，我们什么都没处理，所以 useConnect 对应的第一个参数 state 就应该是 useCreteStore 中的 initState，所以在 ReduxHooksStore 中只需要提供一个初始化方法即可，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class ReduxHooksStore {\n  reducer: any;\n  state: any;\n\n  constructor(reducer: any, initState: any) {\n    this.reducer = reducer;\n    this.state = initState;\n  }\n\n  // 初始化方法\n  getInitState = () => {\n    return this.state;\n  };\n }\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后，通过 useContext 获取到实例方法，用 useRef 存储即可。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import ReduxContext from "./createRedux";\n\nconst useConnect = () => {\n  // 获取对应的值\n  const contextValue: any = useContext(ReduxContext);\n  const { getInitState } = contextValue;\n\n  const stateValue = useRef(getInitState());\n  return [stateValue.current, dispatch];\n};\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"定制化入参",children:["定制化入参",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定制化入参",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过上述的处理，我们拿到的 state 为全量的数据，要想拿到特定的数据，只需要给 useConnect 一个入参即可，让用户手动获取状态。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const useConnect = (mapStoreToState?: (data: any) => void) => {\n  ...\n  const stateValue = useRef(getInitState(mapStoreToState));\n  ...\n};\n\n// useCreateStore.ts\nclass ReduxHooksStore{\n  ...\n  getInitState = (mapStoreToState?: (data: any) => void) => {\n    return mapStoreToState ? mapStoreToState(this.state) : this.state;\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时，useConnect 就支持以下两种方式："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// 全量\nconst [state, dispatch] = useConnect();\n\n//  定制化\nconst [state, dispatch] = useConnect((data) => ({ count: data.count }));\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"更新场景",children:["更新场景",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新场景",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在更新场景中，我们希望通过 dispatch 触发改变 store 中的值，以及刷新使用 useConnect 的组件。"}),"\n",(0,s.jsx)(n.p,{children:"所以在更新场景中存在两个步骤："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"统计组件：统计使用 useConnect 的组件个数，当 store 发生变化时，更新对应的组件，组件销毁时，移除该组件；"}),"\n",(0,s.jsx)(n.li,{children:"更新组件：驱动组件更新的一定是 Hooks 所创建的变量，所以与 useReactive 中的更新一样，直接使用 useUpdate 即可。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"统计组件",children:["统计组件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#统计组件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"统计组件的个数，我们通过一个对象去存储，然后保持每个存储的组件唯一即可，所以我们在 ReduxHooksStore 设置 components_connect，然后比较旧值（oldState）与新值（newState）是否 相等（用 id 区分组件）， 来帮助我们实现功能。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"class ReduxHooksStore {\n  id: number;\n  components_connect: any;\n\n  // 注册\n  subscribe = (connectCurrent: any) => {\n    const connectName = `domesy_redux_` + ++this.id;\n    this.components_connect[connectName] = connectCurrent;\n    return connectName;\n  };\n\n  // 卸载\n  unSubscribe = (connectName: any) => {\n    delete this.components_connect[connectName];\n  };\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 subscribe 中接收一个参数 connectCurrent，connectCurrent 是保存信息，同时我们返回对应的组件名称，方便后续的卸载即可。"}),"\n",(0,s.jsx)(n.p,{children:"当使用 useConnect 的时候触发注册，所以触发的条件为保存的值 connectValue，而 connectValue 的变化取决于 contextValue（ useContext(ReduxContext)），这里我们直接使用 useCreation 即可。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const useConnect = () => {\n  ...\n  const connectValue = useCreation(() => {\n    const state = {\n      oldState: stateValue.current,\n      mapStoreToState,\n      /* 更新函数 */\n      update: (newState: any) => {\n        state.oldState = newState;\n        stateValue.current = newState;\n      },\n    };\n    return state;\n  }, [contextValue]); // 将 contextValue 作为依赖项。\n\n  useEffect(() => {\n    const name = subscribe(connectValue);\n    return function () {\n      // 卸载\n      unSubscribe(name);\n    };\n  }, [connectValue]);\n\n  ...\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"关于保存的数据，我们需要一个旧值（oldState），以及更新函数（update），而 mapStoreToState 则是针对定制化入参的兼容处理。"}),"\n",(0,s.jsxs)(n.h3,{id:"更新组件",children:["更新组件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新组件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"当我们统计完组件的个数时，我们只需要触发 dispatch 时，去遍历 components_connect，然后比较旧值（oldState）与新值（newState）是否发生改变即可，如果发生改变，则触发对应的 update 方法，刷新视图即可。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"  dispatch = (action: any) => {\n    this.state = this.reducer(this.state, action);\n\n    /* 批量更新 */\n    Object.keys(this.components_connect).forEach((name) => {\n      const { update, oldState, mapStoreToState } =\n        this.components_connect[name];\n      const newState = mapStoreToState\n        ? mapStoreToState(this.state)\n        : this.state;\n\n      // 如果不一致，则触发更新函数\n      if (!shallowEqual(oldState, newState)) update(newState);\n    });\n  };\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["其中 shallowEqual 用来比较旧值和新值是否相等的方法。这里偷了个懒，把之前的 shallowEqual（",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7230622711905517605/section/7231328469697691704",target:"_blank",rel:"noopener noreferrer",children:"源码篇｜彻底搞懂 useMemo 和 useCallback"})," ） 直接复制过来～"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"最后，我们在 update 的方法使用 useUpdate 即可。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const useConnect = () => {\n  ...\n  const {  dispatch } = contextValue;\n  \n  const update = useUpdate();\n\n  const connectValue = useCreation(() => {\n    const state = {\n      ...\n      update: (newState: any) => {\n        ...\n        // 更新\n        update();\n      },\n    };\n    return state;\n  }, [contextValue]); // 将 contextValue 作为依赖项。\n\n  ...\n  return [stateValue.current, dispatch];\n};\n\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"整体效果",children:["整体效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#整体效果",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"img2.gif"})}),"\n",(0,s.jsx)(n.p,{children:"此时，我们就用两个自定义 Hooks，实现了一个简易版的 react-redux。"}),"\n",(0,s.jsxs)(n.h1,{id:"扩展批量更新",children:["扩展：批量更新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展批量更新",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在更新的步骤中，我们通常会使用 unstable_batchedUpdates 去优化更新的流程，它的作用是优化异步场景。"}),"\n",(0,s.jsx)(n.p,{children:"unstable_batchedUpdates 是 react-dom 提供的方法，它一般用于状态库，并非是日常的开发中使用。"}),"\n",(0,s.jsx)(n.p,{children:"但在这里我们并不需要用 unstable_batchedUpdates 单独处理更新流程，原因是 React v18 中将会自动进行批处理，而 v18 版本以下，则不会进行批处理，需要依靠 unstable_batchedUpdates 去实现。"}),"\n",(0,s.jsxs)(n.h2,{id:"unstable_batchedupdates-使用示例",children:["unstable_batchedUpdates 使用示例",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#unstable_batchedupdates-使用示例",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"为了更好的理解，我们模拟一下对应的场景，来看看具体效果："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'export default class Index extends React.Component {\n  state = {\n    number: 0,\n  };\n\n  render() {\n    return (\n      <>\n        <div>number: {this.state.number}</div>\n        <Button color="primary" onClick={() => {\n          this.setState({\n            number: this.state.number + 1,\n          });\n          this.setState({\n            number: this.state.number + 2,\n          });\n          this.setState({\n            number: this.state.number + 3,\n          });\n\n          setTimeout(() => {\n            this.setState({\n              number: this.state.number + 4,\n            });\n            this.setState({\n              number: this.state.number + 5,\n            });\n            this.setState({\n              number: this.state.number + 6,\n            });\n          });\n        }}>\n          点击\n        </Button>\n      <>\n    );\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"当你看到这种面试题时，一定要注意 React 的环境，React v18 和 v17 完全是两个答案，所以这里需要特别注意～"}),"\n",(0,s.jsx)(n.p,{children:"问：点击一次按钮，number 是多少？"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"React v17 答案"}),"：18。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,UklGRkwFAABXRUJQVlA4IEAFAABQJwCdASowAbkAPp1MoE2lpCMiITIJGLATiWdu4XX50mC2cA20HPI+hjnbvYA3kvIwPDWm8+c5NRJ2/DKRMpcRnzM+c5xvvmXqQ/zj/sepb/t+X36n9gz9ad9rDGfwIJKqzd/m8rKZNXn9jqPKuxP3+ehGBA0tLuhpworlOEd2S/D/9D36pQPNx/MFQgy+d8UNPZdoZTJqyrEgCArWu6GtybpZawJnbtvZWJ6SeAwnyOSO0gEDS0u6FdzKbmaCOZb/9dUti9MMMea6sNHb9IvfM6prffAwoXr0JZtN2UPuhEvAEDS0u7sOdWqEa9Pa0HBC+i0uvAIGlpd0Nbkgu1tzuw1uTk7oa3Jyd0Nbk5O6GtycndDW5OTuhrcnJ3Q1uTk7oa3JydznW/8pK6j02i1PPLVho7k5O2mL0gH1RiiWomrdgAD+/BEedDcTo1KVMZg8JpUbECZPR2CtTFLoumfPr22may54r5CLT+qSG6wbelGsfkj+iahmppyTJ/GXFB7zcVMVmB7WEJzkCCVv//C2SaBD158YbjJrDrQKjS60tfx8On7p/5Fy+htEG2/U/9cr3mctF2WUUB42SPSrdRzxMVz1Vuz1t88hAbnHm3Ls8sY9dC3FXQgx49YOgCYU12kwN8BYPyqNyES0d30ZfhsC2MG1E3RsE1iR8bNvNLqfc/CB2FBHZALdPA13iR++NnHQEqAf7pNW7CadUvM/2zlynCOmTJ/rpPRUmvd+ub7/8FOT6MExIZoTFb1QiN2duEjrRUg+7/02RMgaMqqdS/cxfjPWPyNXIV7ynGdis7fzf/jvPzM/1J3iV37IM+SxCyoR3O1d2vgpx8Nqud433eqhWQc6sIAQ/+m1sJibfExU/w9g/ns8S27/CcqI4sMfJ8kbuotDtSrfEkO2MdJOGORhhjgInU0X3qu3h00Aa8Pdc/Q5Bu5M6oz4VZwMedq38eQpNlbTO8blN6qzErdKZSYPK6jRyTGHhvMi6fOKGE5ARZ+fI24PbdmP4N9l58P0upGB81fp6oywEgroJ0NzfXNoSWvLFpov4SjD33lTKcfBWj9kWDwFaPu5fkuCoStL8uG7QDWPoBXCQtbo78j/uJ78gI9ORc7jbbhknFZx/Sm8s9xo6Uk4LDbABvKxxPtRb3MssGEEUft6kZvZGOiM3KRJFl4Z2lOBypZ5NHilGQbLi/DNH8AEhDvt2nCMW/lBczEB/kUlQPt5hqBvNatJkUezV19yeOFANX7oGNdQmNHqOwBbIXYZ9tCt04j7Yoz79JBbM1Z6zYqheY0gvFYfM4+RphVpm1fDX/Js7l6cn6j7nqCsGd6nQVA7ruoxkklGEhSgg5Ag3EvtlLbmbt8T1Q/zhi89d3NldKPiz1XQN4x75yZIyL8+Ud9B4F632B9QYgsBz4wgpNfmh8ytoeQTd4y0LW5beHUt7btrZ8jJY6zeoqVPf4E+qu9TaUq3dhGJKbSQQMYVPLBXLvEX4p19L/0q5rdm3/Jt8CieR/gnJ0IsolvZu8Dq5u6zPnivc0FITwUD9xxpw8+fFwTBQDGyex/6U6OI7e88ei/QJHzYi6k3jSF+UDqxq5ArUPmyDtSgqdziuxuPLz+inPKtuDMAH4rtngUj8GcXCaAxc+H6j6GAAAAAAOt7dRGEcw3R/ROVZoCnlfsn4FcNjtVYu+Q4Ln2cUUFABrWGUp9Fs66DRl/TNKpI7m/F63VVZSQiKBDEr5DriKE7jbx3UB7ALlwow5UY7wgYlx9f2nDz78/BSbi2FahdZEJuUGqUp+mSLYAAAAA=",alt:"img3.gif"})}),"\n",(0,s.jsx)(n.p,{children:"原因：3 + 4 + 5 + 6 = 18；"}),"\n",(0,s.jsx)(n.p,{children:"在正常情况下会进行批量处理，所以只会执行最后一个，因此是 3；\n而在异步（定时器）下，每个 state 都会进行，因此为：4 + 5 + 6."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"React v18 答案"}),"：9。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,UklGRqgFAABXRUJQVlA4IJwFAACQJgCdASowAbkAPp1MoE2lpCMiIXZosLATiWdu4XYBGxgaqVEdHvcA9We2W56f0gby56AHSy5Eenn0kIY89QNssVfO+ancX/7nxZvIQoAfy/+mf8r08f+bzE/TPsD/qh/yeBO/bAKhYcrFO3L5VSS5YHaGiHhTUScIbbilZ4NyO/0r4H2Jo4q5V8UJlEWBDW05D7jGQBX9Ap+za+POg83ohbHyEiz5ygb8ImjjHiIa1AZVRz9M9GcsJaew/4eOarj8V5q08rzQkW71WPgdup04XdCkqadooD17phFCI/y7YVF4Hlp5XmvW2YmjjHiNHGPEaOMeI0cY8Ro4x4jRxjxGjjHiNHGPEaOMeI0cY8Ro4x4jRxjxGjjHiNHGPEaOMeIyyFf8tYiKfRHkDRxjxGjjFU916AQRkkd05N7AgAD+/v+3a2lVZhJYoZFAhb+7AB+LeQPOm0DHDvLEBU8E+deaBkLVW1ted4wGf+Ok3+QdCeqc9t9te1Jhf4MKBCr3/GH34huy8KZM6597kssJvNGtj/yP+ylA7sNs/nPo0PtUpmXrBeoJ/SqEf2qqD26AL2XWD07K7/fotw6yRpl9vhRDoJO3ov0+gGEkdP0ZuJgHJ1Ifs5E8eS1M/MDIdtJ0fAGPZ4OmSxZNsJIbqANFoYgr92bY9b1VCqa98843HrVKT9RZSw4fh6BfQ+gWHaaTtl8DpMUMrlZTeTKGlx9c6tQm7j8BZY9lmOUwWb8PY9m3OEp/I5z969+37ZYKIY6/EUpdsON0QVtY8HY/NOLSq5a9k/wR9EbyeAfxf9vKQT0djfSpFkiKhuDgQl8Ke1VYcy96gZ8PMigjMXa7UaB9PszHF8fJQBIfD7dRAnU714erXzF1aBvDyQyZutcXUjWpXnSMTfxf4Q0KNqv3ccoM140SKYdn5hViFATm7PxoejU4bXPtsF10dVpEX/16KFncUNiFegx+92DuKg4dfIG3It7PBh1p+iNfXKiH8hlpLY5dket7ucvoax4nH64pFJ/lit5UXPE3XYa7cQ8N0rs7NSN18w03tTOXO15Q2PwDlUvCWWL9on0kMYRCXOZIo2Zk+IRd36SpH39Xhk3Ncei1OvWsVgvA7YcFIuDuULgoQZWQWhuK9/2FXWDGqhDOH89WA8gWczShv8m5SF8LU5mgffhLi1Jux5Q4IgsG2ENOhIrqckuFEiVwX793Q11DvwBkWeZxyhmfqc8EH7bGCfZN6tRKpa2x8KBGhzRDcMMt53v9AfTu72H0M9sTGlYtiKXcZgzBU0VWoxeEe+kq9VInLS9t8vQJLF2VnNVmR68orgxuQSnUX3YT/bzJP4XZhTcvhvoZFLCA1EdeLBD6QSqZRAiISJjaH4+a7udAHRYZIU7s8pfwoh7jI/VPWzhO6xRnNCCBnxkSWkRJ6vnMaYudMkNnjofw3JX8ZDBuyzIWDXSbuARUP0e/JmAvxiJn03Vz3Lwdn5I3KG/PfL/FzvH+afg5CV3q4CrX8mHDNWQVxiNg9kfXpEtd2bnRKRUs9h9UtCbax/ZezHPZvINQBVYDg34dXPb016Tp8F9eXnYb8rfYbwjfrddL8PawvEmK/7Axck0Z0XqeK00/AuU3fetZvdZTlBH4KvSk19d15EYLxRL7VUpiN6yoZjzhLcgndTOaa2jkjj3PjhmhRCgDBC/7k1mA8L6+3Tv29EacIQkPgWq1raSlDUetI57io57Uem6VKbOZdfiFzXjfqSDsNMOk+G9v5lQAAAAAOzY4od+2AqLmjypMRlKCxQbyNyd9xkuhX2/e41cz2KCVHf5d8XoejHBtOumz08mU7EQC805PxO7LBaVkE474UduoX0Qz+aHczZVIKnDt9j0fr5or/i0+wqR0EMhBsb/BvGXfAqr6VgvYOA2XWA5z08ZrIAAAAA==",alt:"img4.gif"})}),"\n",(0,s.jsx)(n.p,{children:"原因： 3 + 6 = 9"}),"\n",(0,s.jsx)(n.p,{children:"而在 v18 中，异步环境下也会自动合并，也就是执行最后一次，因此第一次执行为 3，第二次为 6。"}),"\n",(0,s.jsx)(n.p,{children:"要想在 v17 中的异步场景中具有批量更新的效果，此时只需要用 unstable_batchedUpdates 包裹一下。"}),"\n",(0,s.jsxs)(n.h2,{id:"flushsync",children:["flushSync",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#flushsync",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"那么可能会有小伙伴好奇，如果我不想在 v18 的异步场景下合并批量操作该怎么办？"}),"\n",(0,s.jsx)(n.p,{children:"为此，官方提供 flushSync 方法，如果处理的函数被它包裹，则不会进行批量更新。"}),"\n",(0,s.jsxs)(n.h2,{id:"函数组件中的影响",children:["函数组件中的影响",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数组件中的影响",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上述我们举的例子是类组件，但我们的 Hooks 是运用在函数组件中，那么还有必要加上 unstable_batchedUpdates 吗？"}),"\n",(0,s.jsx)(n.p,{children:"实际上，在异步场景中并不会影响函数组件中的值，但会造成多次渲染的问题，我们直接来看看在 v17 中的效果："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const Index = () => {\n  const [flag, setFlag] = useState(false);\n  \n  console.log('触发渲染')\n\n  return (\n    <>\n      <div>flag: {JSON.stringify(flag)}</div>\n      <Button\n        color='primary'\n        onClick={() => {\n          setTimeout(() => {\n            // unstable_batchedUpdates(() => {\n            //   setCount(count + 1);\n            //   setCount(count + 1);\n            //   setFlag(v => !v)\n            // })\n\n            setFlag(v => !v)\n            setFlag(v => !v)\n            setFlag(v => !v)\n          });\n        }}\n      >\n        点击\n      </Button>\n    </>\n  );\n};\n\nexport default Index;\n"})}),"\n",(0,s.jsx)(n.p,{children:"正常效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:"img5.gif"})}),"\n",(0,s.jsx)(n.p,{children:"使用 unstable_batchedUpdates 的效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:"img6.gif"})}),"\n",(0,s.jsx)(n.p,{children:"可见，使用 unstable_batchedUpdates 后每次只会更新一次，如果是未使用的话，则会触发三次。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"要特别注意：unstable_batchedUpdates 虽然在 v18 中并未移除，但它本身并不算一个正式的 API，同时在工作中并不需要使用，所以这里只是增加个扩展知识（面试～），在日常工作中，我们并不需要它。"}),"\n"]}),"\n",(0,s.jsxs)(n.h1,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本节课，我们学习了 react-redux 的基本使用，并且用两个自定义 Hooks 去实现 react-redux 的基本功能，通过具体场景去实现 useCreateStore 和 useConnect。"}),"\n",(0,s.jsx)(n.p,{children:"下节我们继续学习如用自定义 Hooks 设计表单。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let l=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F16.%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BD%9C%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84%20react-redux.md"]={toc:[{text:"具体使用",id:"具体使用",depth:2},{text:"效果展示",id:"效果展示",depth:2},{text:"useCreateStore 实现",id:"usecreatestore-实现",depth:2},{text:"useConnect",id:"useconnect",depth:2},{text:"初始化场景",id:"初始化场景",depth:2},{text:"定制化入参",id:"定制化入参",depth:3},{text:"更新场景",id:"更新场景",depth:2},{text:"统计组件",id:"统计组件",depth:3},{text:"更新组件",id:"更新组件",depth:3},{text:"整体效果",id:"整体效果",depth:2},{text:"unstable_batchedUpdates 使用示例",id:"unstable_batchedupdates-使用示例",depth:2},{text:"flushSync",id:"flushsync",depth:2},{text:"函数组件中的影响",id:"函数组件中的影响",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);