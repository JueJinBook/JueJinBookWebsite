"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["10163"],{296545:function(e,s,n){n.r(s),n.d(s,{default:()=>c});var i=n(552676),r=n(740453);function d(e){let s=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",pre:"pre",code:"code",ol:"ol",li:"li"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.h1,{id:"30拓展-9隔墙有耳--redis-安全通信",children:["30拓展 9：隔墙有耳 —— Redis 安全通信",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#30拓展-9隔墙有耳--redis-安全通信",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"想象这样一个应用场景，公司有两个机房。因为一个紧急需求，需要跨机房读取 Redis 数据。应用部署在 A 机房，存储部署在 B 机房。如果使用普通 tcp 直接访问，因为跨机房所以传输数据会暴露在公网，这非常不安全，客户端服务器交互的数据存在被窃听的风险。"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://user-gold-cdn.xitu.io/2018/7/24/164cb8fec86c373c?w=813&h=336&f=png&s=34055",alt:""})}),"\n",(0,i.jsx)(s.p,{children:"Redis 本身并不支持 SSL 安全链接，不过有了 SSL 代理软件，我们可以让通信数据透明地得到加密，就好像 Redis 穿上了一层隐身外套一样。spiped 就是这样的一款 SSL 代理软件，它是 Redis 官方推荐的代理软件。"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://user-gold-cdn.xitu.io/2018/7/24/164cbbfbafa6f005?w=783&h=377&f=png&s=41300",alt:""})}),"\n",(0,i.jsxs)(s.h2,{id:"spiped-原理",children:["spiped 原理",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#spiped-原理",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"让我们放大细节，仔细观察 spiped 实现原理。spiped 会在客户端和服务器各启动一个 spiped 进程。"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://user-gold-cdn.xitu.io/2018/7/24/164cbb6b2ce179eb?w=844&h=319&f=png&s=38059",alt:""})}),"\n",(0,i.jsx)(s.p,{children:"左边的 spiped 进程 A 负责接受来自 Redis Client 发送过来的请求数据，加密后传送到右边的 spiped 进程 B。spiped B 将接收到的数据解密后传递到 Redis Server。然后 Redis Server 再走一个反向的流程将响应回复给 Redis Client。"}),"\n",(0,i.jsx)(s.p,{children:"每一个 spiped 进程都会有一个监听端口 (server socket) 用来接收数据，同时还会作为一个客户端 (socket client) 将数据转发到目标地址。"}),"\n",(0,i.jsx)(s.p,{children:"spiped 进程需要成对出现，相互之间需要使用相同的共享密钥来加密消息。"}),"\n",(0,i.jsxs)(s.h2,{id:"spiped-使用入门",children:["spiped 使用入门",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#spiped-使用入门",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"安装 spiped，我用的是 Mac。"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"> brew install spiped\n"})}),"\n",(0,i.jsx)(s.p,{children:"如果是 Linux，可以使用 apt-get 或者 yum 安装："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"> apt-get install spiped\n> yum install spiped\n"})}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["使用 Docker 启动 redis-server，注意要绑定本机的回环",(0,i.jsx)(s.code,{children:"127.0.0.1"}),"；"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'> docker run -d -p127.0.0.1:6379:6379 --name redis-server-6379 redis\n12781661ec47faa8a8a967234365192f4da58070b791262afb8d9f64fce61835\n> docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS              PORTS                      NAMES\n12781661ec47        redis               "docker-entrypoint.s…"   Less than a second ago   Up 1 second         127.0.0.1:6379->6379/tcp   redis-server-6379\n'})}),"\n",(0,i.jsxs)(s.ol,{start:"2",children:["\n",(0,i.jsx)(s.li,{children:"生成随机的密钥文件；"}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"# 随机的 32 个字节\n> dd if=/dev/urandom bs=32 count=1 of=spiped.key\n1+0 records in\n1+0 records out\n32 bytes transferred in 0.000079 secs (405492 bytes/sec)\n> ls -l\nrw-r--r--  1 qianwp  staff  32  7 24 18:13 spiped.key\n"})}),"\n",(0,i.jsxs)(s.ol,{start:"3",children:["\n",(0,i.jsxs)(s.li,{children:["使用密钥文件启动服务器 spiped 进程，",(0,i.jsx)(s.code,{children:"172.16.128.81"}),"是我本机的公网 IP 地址；"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"# -d 表示 decrypt(对输入数据进行解密)，-s 为源监听地址，-t 为转发目标地址\n> spiped -d -s '[172.16.128.81]:6479' -t '[127.0.0.1]:6379' -k spiped.key\n> ps -ef|grep spiped\n501 30673     1   0  7:29 下午 ??         0:00.04 spiped -d -s [172.16.128.81]:6479 -t [127.0.0.1]:6379 -k spiped.key\n"})}),"\n",(0,i.jsx)(s.p,{children:"这个 spiped 进程监听公网 IP 的 6479 端口接收公网上的数据，将数据解密后转发到本机回环地址的 6379 端口，也就是 redis-server 监听的端口。"}),"\n",(0,i.jsxs)(s.ol,{start:"4",children:["\n",(0,i.jsxs)(s.li,{children:["使用密钥文件启动客户端 spiped 进程，",(0,i.jsx)(s.code,{children:"172.16.128.81"}),"是我本机的公网 IP 地址；"]}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:"# -e 表示 encrypt，对输入数据进行加密\n> spiped -e -s '[127.0.0.1]:6579' -t '[172.16.128.81]:6479' -k spiped.key\n> ps -ef|grep spiped\n501 30673     1   0  7:29 下午 ??         0:00.04 spiped -d -s [172.16.128.81]:6479 -t [127.0.0.1]:6379 -k spiped.key\n501 30696     1   0  7:30 下午 ??         0:00.03 spiped -e -s [127.0.0.1]:6579 -t [172.16.128.81]:6479 -k spiped.key\n"})}),"\n",(0,i.jsx)(s.p,{children:"客户端 spiped 进程监听了本地回环地址的 6579 端口，将该端口上收到的数据加密转发到服务器 spiped 进程。"}),"\n",(0,i.jsxs)(s.ol,{start:"5",children:["\n",(0,i.jsx)(s.li,{children:"启动客户端链接，因为 Docker 里面的客户端不好访问宿主机的回环地址，所以 Redis 的客户端我们使用 Python 代码来启动；"}),"\n"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-py",children:">> import redis\n>> c=redis.StrictRedis(host=\"localhost\", port=6579)\n>> c.ping()\n>> c.info('cpu')\n{'used_cpu_sys': 4.83,\n 'used_cpu_sys_children': 0.0,\n 'used_cpu_user': 0.93,\n 'used_cpu_user_children': 0.0}\n"})}),"\n",(0,i.jsx)(s.p,{children:"可以看出客户端和服务器已经通了，如果我们尝试直接链接服务器 spiped 进程 (加密的端口 6379)，看看会发生什么。"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'>>> import redis\n>>> c=redis.StrictRedis(host="172.16.128.81", port=6479)\n>>> c.ping()\nTraceback (most recent call last):\n  File "<stdin>", line 1, in <module>\n  File "/Users/qianwp/source/animate/juejin-redis/.py/lib/python2.7/site-packages/redis/client.py", line 777, in ping\n    return self.execute_command(\'PING\')\n  File "/Users/qianwp/source/animate/juejin-redis/.py/lib/python2.7/site-packages/redis/client.py", line 674, in execute_command\n    return self.parse_response(connection, command_name, **options)\n  File "/Users/qianwp/source/animate/juejin-redis/.py/lib/python2.7/site-packages/redis/client.py", line 680, in parse_response\n    response = connection.read_response()\n  File "/Users/qianwp/source/animate/juejin-redis/.py/lib/python2.7/site-packages/redis/connection.py", line 624, in read_response\n    response = self._parser.read_response()\n  File "/Users/qianwp/source/animate/juejin-redis/.py/lib/python2.7/site-packages/redis/connection.py", line 284, in read_response\n    response = self._buffer.readline()\n  File "/Users/qianwp/source/animate/juejin-redis/.py/lib/python2.7/site-packages/redis/connection.py", line 216, in readline\n    self._read_from_socket()\n  File "/Users/qianwp/source/animate/juejin-redis/.py/lib/python2.7/site-packages/redis/connection.py", line 191, in _read_from_socket\n    (e.args,))\nredis.exceptions.ConnectionError: Error while reading from socket: (\'Connection closed by server.\',)\n'})}),"\n",(0,i.jsx)(s.p,{children:"从输出中可以看出来请求是发送过去了，但是却出现了读超时，要么是服务器在默认的超时时间内没有返回数据，要么是服务器没有返回客户端想要的数据。"}),"\n",(0,i.jsx)(s.p,{children:"spiped 可以同时支持多个客户端链接的数据转发工作，它还可以通过参数来限定允许的最大客户端连接数。但是对于服务器 spiped，它不能同时支持多个服务器之间的转发。意味着在集群环境下，需要为每一个 server 节点启动一个 spiped 进程来代收消息，在运维实践上这可能会比较繁琐。"}),"\n",(0,i.jsxs)(s.h2,{id:"作业",children:["作业",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#作业",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"请读者将 Redis 替换成 MySQL 来体验一下 spiped 的神奇魔力。"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,r.ah)(),e.components);return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}let c=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F30%E6%8B%93%E5%B1%95%209%EF%BC%9A%E9%9A%94%E5%A2%99%E6%9C%89%E8%80%B3%20%E2%80%94%E2%80%94%20Redis%20%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1.md"]={toc:[{text:"spiped 原理",id:"spiped-原理",depth:2},{text:"spiped 使用入门",id:"spiped-使用入门",depth:2},{text:"作业",id:"作业",depth:2}],title:"30拓展 9：隔墙有耳 —— Redis 安全通信",headingTitle:"30拓展 9：隔墙有耳 —— Redis 安全通信",frontmatter:{}}}}]);