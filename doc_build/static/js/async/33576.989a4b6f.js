"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["33576"],{86132:function(e,n,s){e.exports=s.p+"static/image/27cb39b89b01cdbd1184062d08e404cb.0b8691f6.webp"},858738:function(e,n,s){s.r(n),s.d(n,{default:()=>U});var a=s(552676),c=s(740453),i=s(86132);let t=s.p+"static/image/60f01e5d3af4c263a7bd302b5e56937c.25f76e7d.webp",l=s.p+"static/image/edbf49f47afb1bb793218c113c1cbb32.5bca7963.gif",r=s.p+"static/image/07a7137b11320d3de31f8dea3f297f7c.0c76acd7.webp",d=s.p+"static/image/ec0b3c9a0bc8d7ddd384e0372113a2d5.0e345a26.webp",p=s.p+"static/image/5e0a53457341c690365f03ff8c0c4546.fae62359.webp",h=s.p+"static/image/0a174c1a65ed25ab24389c553ac1a0d7.9f5d5ed3.webp",o=s.p+"static/image/1a145b3543826717d5ee7c1857c733e0.b0136712.webp",m=s.p+"static/image/1f2167a61fd7137cc6d1a60995d507b7.5c17689c.webp",x=s.p+"static/image/867d0e3f2a12985e49ca56a63f0d287a.ee952eee.webp",j=s.p+"static/image/bd5b837f81b496f1a583964ec637bfb5.3793f938.webp",f=s.p+"static/image/ea930566dcca4506ae578c412132ff34.6f491ea3.webp",u=s.p+"static/image/b02216522f26c5f4e0aec5fb75a42f53.1796c41d.gif",g=s.p+"static/image/03ca0a1199a48fbc117027f4ce50d924.d5050d1b.webp",b=s.p+"static/image/1151a2b831241e82f9e033c50edcea27.28585fb8.webp",k=s.p+"static/image/ee7385a6d989156b118b74858356d878.02dcf4b8.webp",w=s.p+"static/image/c5a4dc4cbeacc91333b00f19c129bcb8.237bbf10.webp",y=s.p+"static/image/fa0e26d52f40baa45a8bdbbb86855d78.7f9e3d32.gif",P=s.p+"static/image/81940d26ca65d7172e46268663c04525.b88658ed.webp",E=s.p+"static/image/690c9a529ee39b4c05acc38edc30ce16.e014586f.webp",S=s.p+"static/image/9802b1542eff769a44875b0e54a5b58f.c8bcbaf3.webp",_=s.p+"static/image/6c2fd415f6051b6575cb6ccbca829f29.c06a45ce.webp",D=s.p+"static/image/076f0e297f1f085336fd98c4f3d4cf1f.4971cf41.webp",F=s.p+"static/image/db544a4e780fd2b066d4ea871269dc05.21670af5.webp",A=s.p+"static/image/c04a2c214bcd3b896b8e6c60f6e58eb3.caebe2c4.webp",v=s.p+"static/image/d6e238f92e2f985839532c02376116a7.88ad9322.webp",I=s.p+"static/image/6ac7ac8c318cacecef712e331caac351.4d64e4df.webp",N=s.p+"static/image/a2546535c72936a87e7985b1dacb3e3d.dc472d42.webp",B=s.p+"static/image/ef677fa897f6e78151a5476f2a4496f7.f452b0c8.webp";function C(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,c.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"34-大文件分片上传",children:["34. 大文件分片上传",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34-大文件分片上传",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"文件上传是常见需求，只要指定 content-type 为 multipart/form-data，内容就会以这种格式被传递到服务端："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:B,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"服务端再按照 multipart/form-data 的格式提取数据，就能拿到其中的文件。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:N,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"但当文件很大的时候，事情就变得不一样了。"}),"\n",(0,a.jsx)(n.p,{children:"假设传一个 100M 的文件需要 3 分钟，那传一个 1G 的文件就需要 30 分钟。"}),"\n",(0,a.jsx)(n.p,{children:"这样是能完成功能，但是产品的体验会很不好。"}),"\n",(0,a.jsx)(n.p,{children:"所以大文件上传的场景，需要做专门的优化。"}),"\n",(0,a.jsx)(n.p,{children:"把 1G 的大文件分割成 10 个 100M 的小文件，然后这些文件并行上传，不就快了？"}),"\n",(0,a.jsx)(n.p,{children:"然后等 10 个小文件都传完之后，再发一个请求把这 10 个小文件合并成原来的大文件。"}),"\n",(0,a.jsx)(n.p,{children:"这就是大文件分片上传的方案。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:I,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"那如何拆分和合并呢？"}),"\n",(0,a.jsx)(n.p,{children:"浏览器里 Blob 有 slice 方法，可以截取某个范围的数据，而 File 就是一种 Blob："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:v,alt:""})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:A,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"所以可以在 input 里选择了 file 之后，通过 slice 对 File 分片。"}),"\n",(0,a.jsx)(n.p,{children:"那合并呢？"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:F,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"fs 的 createWriteStream 方法支持指定 start，也就是从什么位置开始写入。"}),"\n",(0,a.jsx)(n.p,{children:"这样把每个分片按照不同位置写入文件里，不就完成合并了么。"}),"\n",(0,a.jsx)(n.p,{children:"思路理清了，接下来我们实现一下。"}),"\n",(0,a.jsx)(n.p,{children:"创建个 Nest 项目："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"npm install -g @nestjs/cli\n\nnest new large-file-sharding-upload\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:D,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"在 AppController 添加一个路由："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:_,alt:""})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"@Post('upload')\n@UseInterceptors(FilesInterceptor('files', 20, {\n  dest: 'uploads'\n}))\nuploadFiles(@UploadedFiles() files: Array<Express.Multer.File>, @Body() body) {\n  console.log('body', body);\n  console.log('files', files);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"这是一个 post 接口，会读取请求体里的 files 文件字段传入该方法。"}),"\n",(0,a.jsx)(n.p,{children:"这里还需要安装用到的 multer 包的类型："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"npm install -D @types/multer\n"})}),"\n",(0,a.jsx)(n.p,{children:"然后我们在网页里试一下："}),"\n",(0,a.jsx)(n.p,{children:"首先在 main.ts 里开启跨域支持："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:S,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"然后添加一个 index.html："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"><\/script>\n</head>\n<body>\n    <input id="fileInput" type="file" multiple/>\n    <script>\n        const fileInput = document.querySelector(\'#fileInput\');\n\n        fileInput.onchange =  async function () {\n            const data = new FormData();\n            data.set(\'name\',\'光\');\n            data.set(\'age\', 20);\n\n            [...fileInput.files].forEach(item => {\n                data.append(\'files\', item)\n            })\n\n            const res = await axios.post(\'http://localhost:3000/upload\', data);\n            console.log(res);\n        }\n    <\/script>\n</body>\n</html>\n'})}),"\n",(0,a.jsx)(n.p,{children:"input 指定 multiple，可以选择多个文件。"}),"\n",(0,a.jsx)(n.p,{children:"选择文件之后，通过 post 请求 upload 接口，携带 FormData。FormData 里保存着 files 和其它字段。"}),"\n",(0,a.jsx)(n.p,{children:"起个静态服务："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"npx http-server .\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:E,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"浏览器访问下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:P,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"选择几个文件："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:y,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"这时候，Nest 服务端就接收到了上传的文件和其他字段："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:w,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"当然，我们并不是想上传多个文件，而是一个大文件的多个分片。"}),"\n",(0,a.jsx)(n.p,{children:"所以是这样写："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"><\/script>\n</head>\n<body>\n    <input id="fileInput" type="file"/>\n    <script>\n        const fileInput = document.querySelector(\'#fileInput\');\n\n        const chunkSize = 20 * 1024;\n\n        fileInput.onchange =  async function () {\n\n            const file = fileInput.files[0];\n\n            console.log(file);\n\n            const chunks = [];\n            let startPos = 0;\n            while(startPos < file.size) {\n                chunks.push(file.slice(startPos, startPos + chunkSize));\n                startPos += chunkSize;\n            }\n\n            chunks.map((chunk, index) => {\n                const data = new FormData();\n                data.set(\'name\', file.name + \'-\' + index)\n                data.append(\'files\', chunk);\n                axios.post(\'http://localhost:3000/upload\', data);\n            })\n        \n        }\n\n    <\/script>\n</body>\n</html>\n'})}),"\n",(0,a.jsx)(n.p,{children:"对拿到的文件进行分片，然后单独上传每个分片，分片名字为文件名 + index。"}),"\n",(0,a.jsx)(n.p,{children:"这里我们测试用的图片是 80k："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:k,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"所以每 20k 一个分片，一共是 4 个分片。"}),"\n",(0,a.jsx)(n.p,{children:"测试下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"服务端接收到了这 4 个分片:"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"然后我们把它们移动到单独的目录："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"@Post('upload')\n@UseInterceptors(FilesInterceptor('files', 20, {\n  dest: 'uploads'\n}))\nuploadFiles(@UploadedFiles() files: Array<Express.Multer.File>, @Body() body: { name: string }) {\n  console.log('body', body);\n  console.log('files', files);\n\n  const fileName = body.name.match(/(.+)\\-\\d+$/)[1];\n  const chunkDir = 'uploads/chunks_'+ fileName;\n\n  if(!fs.existsSync(chunkDir)){\n    fs.mkdirSync(chunkDir);\n  }\n  fs.cpSync(files[0].path, chunkDir + '/' + body.name);\n  fs.rmSync(files[0].path);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"用正则匹配出文件名："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"在 uploads 下创建 chunks_文件名 的目录，把文件复制过去，然后删掉原始文件。"}),"\n",(0,a.jsx)(n.p,{children:"测试下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:f,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"分片文件移动成功了。"}),"\n",(0,a.jsx)(n.p,{children:"不过直接以 chunks_文件名 做为目录名，太容易冲突了。"}),"\n",(0,a.jsx)(n.p,{children:"我们可以在上传文件的时候给文件名加一个随机的字符串。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:j,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"这样就不会冲突了："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"接下来，就是在全部分片上传完之后，发送合并分片的请求。"}),"\n",(0,a.jsx)(n.p,{children:"添加一个 merge 的接口："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"@Get('merge')\nmerge(@Query('name') name: string) {\n    const chunkDir = 'uploads/chunks_'+ name;\n\n    const files = fs.readdirSync(chunkDir);\n\n    let startPos = 0;\n    files.map(file => {\n      const filePath = chunkDir + '/' + file;\n      const stream = fs.createReadStream(filePath);\n      stream.pipe(fs.createWriteStream('uploads/' + name, {\n        start: startPos\n      }))\n\n      startPos += fs.statSync(filePath).size;\n    })\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"接收文件名，然后查找对应的 chunks 目录，把下面的文件读取出来，按照不同的 start 位置写入到同一个文件里。"}),"\n",(0,a.jsx)(n.p,{children:"浏览器访问下这个接口："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，合并成功了："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"再测试一个："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"也没啥问题。"}),"\n",(0,a.jsx)(n.p,{children:"然后我们在合并完成之后把 chunks 目录删掉。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"@Get('merge')\nmerge(@Query('name') name: string) {\n    const chunkDir = 'uploads/chunks_'+ name;\n\n    const files = fs.readdirSync(chunkDir);\n\n    let count = 0;\n    let startPos = 0;\n    files.map(file => {\n      const filePath = chunkDir + '/' + file;\n      const stream = fs.createReadStream(filePath);\n      stream.pipe(fs.createWriteStream('uploads/' + name, {\n        start: startPos\n      })).on('finish', () => {\n        count ++;\n\n        if(count === files.length) {\n          fs.rm(chunkDir, {\n            recursive: true\n          }, () =>{});\n        }\n      })\n\n      startPos += fs.statSync(filePath).size;\n    });\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"然后在前端代码里，当分片全部上传完之后，调用 merge 接口："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:r,alt:""})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const tasks = [];\nchunks.map((chunk, index) => {\n    const data = new FormData();\n\n    data.set('name', randomStr + '_' + file.name + '-' + index)\n    data.append('files', chunk);\n    tasks.push(axios.post('http://localhost:3000/upload', data));\n})\nawait Promise.all(tasks);\naxios.get('http://localhost:3000/merge?name=' + randomStr + '_' + file.name);\n"})}),"\n",(0,a.jsx)(n.p,{children:"连起来测试下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"因为文件比较小，开启 network 的 slow 3g 网速来测。"}),"\n",(0,a.jsx)(n.p,{children:"可以看到，分片上传和最后的合并都没问题。"}),"\n",(0,a.jsx)(n.p,{children:"当然，你还可以加一个进度条，这个用 axios 很容易实现："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:t,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"至此，大文件分片上传就完成了。"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://help.aliyun.com/zh/oss/user-guide/multipart-upload",target:"_blank",rel:"noopener noreferrer",children:"阿里云的大文件分片上传"}),"也是这样实现的："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsxs)(n.p,{children:["案例代码上传里 github：",(0,a.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/large-file-sharding-upload",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/large-file-sharding-upload"})]}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"当文件比较大的时候，文件上传会很慢，这时候一般我们会通过分片的方式来优化。"}),"\n",(0,a.jsx)(n.p,{children:"原理就是浏览器里通过 slice 来把文件分成多个分片，并发上传。"}),"\n",(0,a.jsx)(n.p,{children:"服务端把这些分片文件保存在一个目录下。"}),"\n",(0,a.jsx)(n.p,{children:"当所有分片传输完成时，发送一个合并请求，服务端通过 fs.createWriteStream 指定 start 位置，来把这些分片文件写入到同一个文件里，完成合并。"}),"\n",(0,a.jsx)(n.p,{children:"这样，我们就实现了大文件分片上传。"})]})}function G(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(C,{...e})}):C(e)}let U=G;G.__RSPRESS_PAGE_META={},G.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F34.%20%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"34. 大文件分片上传",headingTitle:"34. 大文件分片上传",frontmatter:{}}}}]);