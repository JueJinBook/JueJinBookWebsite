"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["71264"],{286070:function(e,n,s){s.r(n),s.d(n,{default:()=>E});var r=s(552676),i=s(740453);let c=s.p+"static/image/444f69dad3ce631ee62ee9fba596048d.70b28140.webp",t=s.p+"static/image/665af2028152e84058998e1f0dff5fdd.e82c4e1c.gif",a=s.p+"static/image/c9474f06dd8fa544b346ed0f4b833ed9.b180f7ac.gif",p=s.p+"static/image/a616045bfe3f96de206f66f94fc782ab.6831cf36.webp",d=s.p+"static/image/64ee736ac72ff839c02a7a42eb8abe3e.e804503d.gif",l=s.p+"static/image/b34f7447e4447385b5c26961d21a2d40.2dad2796.webp",h=s.p+"static/image/7f31d8e7a62a9d92ade0829d78230e44.4495da3d.webp",o=s.p+"static/image/6a63ff334e1dd3fed445482f6b9d9de4.52fa2442.webp",x=s.p+"static/image/7f3a6f4f2f9880ea56d8dff89adf163e.8e95aa04.webp",g=s.p+"static/image/3054df17c1d1edc428cdc637318144b4.43481c45.webp",j=s.p+"static/image/ecd781d9328a1306c84d642b60040294.6178c832.webp",m=s.p+"static/image/03a498340b40a1e85e6690108763c647.50109281.webp",u=s.p+"static/image/3237c3b66668639bdfecfc6d4d0001c2.0fe4bb94.gif",f=s.p+"static/image/2484360c6d66cbdaca5fe5e962dc9dac.1ff069f6.webp",b=s.p+"static/image/3776e91803aaf2ff9d7689bd9aab7803.81ffd158.webp";function w(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"第24章react-spring结合use-gesture手势库实现交互动画",children:["第24章—react-spring结合use-gesture手势库实现交互动画",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第24章react-spring结合use-gesture手势库实现交互动画",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"\uFEFF上节我们学了用 react-spring 做动画。"}),"\n",(0,r.jsx)(n.p,{children:"其实也简单，就是指定某些属性的开始值、结束值，动画的时长或者弹簧动画的一些参数，react-spring 就会实现这些属性的动画。"}),"\n",(0,r.jsx)(n.p,{children:"再就是多个元素可以设置并行、依次执行或者间隔一段时间执行的顺序。"}),"\n",(0,r.jsx)(n.p,{children:"但是很多情况下，动画不是直接触发的，而是由 drag、hover、scroll 等事件触发。"}),"\n",(0,r.jsx)(n.p,{children:"这节我们就结合事件来实现一些交互动画。"}),"\n",(0,r.jsx)(n.p,{children:"我们会用到一个手势库 @use-gesture/react"}),"\n",(0,r.jsx)(n.p,{children:"可能很多同学都没用过手势库，其实手势库里就是对 drag、hover、scroll 这些事件的封装："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"直接给元素绑定事件不行么，为啥还要加一个手势库呢？"}),"\n",(0,r.jsx)(n.p,{children:"那如果我想知道移动的方向、移动的距离、移动的速率呢？"}),"\n",(0,r.jsx)(n.p,{children:"自己算这些就很麻烦，而用了手势库，这些就都有了。"}),"\n",(0,r.jsx)(n.p,{children:"新建个项目来试下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"npx create-react-app --template=typescript use-gesture-test\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我们来实现这样一个案例："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"拖拽的时候触发动画，通过 use-gesture 实现拖动，拿到方向、距离等信息，然后用 react-spring 做属性变化的动画。"}),"\n",(0,r.jsx)(n.p,{children:"安装这两个包："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"npm install --save @react-spring/web @use-gesture/react\n"})}),"\n",(0,r.jsx)(n.p,{children:"改下 App.tsx"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useSprings, animated } from '@react-spring/web'\n\nimport './App.css';\n\nconst pages = [\n  'https://images.pexels.com/photos/62689/pexels-photo-62689.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  'https://images.pexels.com/photos/733853/pexels-photo-733853.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  'https://images.pexels.com/photos/4016596/pexels-photo-4016596.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  'https://images.pexels.com/photos/351265/pexels-photo-351265.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  'https://images.pexels.com/photos/924675/pexels-photo-924675.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n]\n\nfunction Viewpager() {\n  const width = window.innerWidth;\n\n  const [props, api] = useSprings(pages.length, i => ({\n    x: i * width,\n    scale: 1\n  }));\n\n  return (\n    <div className='wrapper'>\n      {props.map(({ x, scale }, i) => (\n        <animated.div className='page' key={i} style={{ x }}>\n          <animated.div style={{ scale, backgroundImage: `url(${pages[i]})` }} />\n        </animated.div>\n      ))}\n    </div>\n  )\n}\n\nexport default Viewpager;\n"})}),"\n",(0,r.jsx)(n.p,{children:"这里是多个元素并行的动画，用 useSprings。"}),"\n",(0,r.jsx)(n.p,{children:"然后改变 x 和 scale 属性。"}),"\n",(0,r.jsx)(n.p,{children:"x 的初始值是 width * i，也就是依次平铺。"}),"\n",(0,r.jsx)(n.p,{children:"所有接收动画属性的地方都要用 <animated.div> ，这里用到 x 和 scale 属性的两个 div 换成 <animated.div>"}),"\n",(0,r.jsx)(n.p,{children:"然后是 App.css："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:"html,body,#root {\n  height: 100%;\n  width: 100%;\n}\n\n.wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\n.page {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  touch-action: none;\n}\n\n.page > div {\n  touch-action: none;\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-position: center center;\n  width: 100%;\n  height: 100%;\n  box-shadow: 0 0 50px #000;\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"这里图片要充满屏幕，从 html、body、#root 到 .wrapper、.page 都要设置宽高 100%："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"touch-action 设置为 none 是禁止移动端的默认 touch 处理。"}),"\n",(0,r.jsx)(n.p,{children:"不然默认会导致页面的缩放和滑动："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，渲染的结果是对的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这里我们设置的 x，但是 react-spring 用 translate3d 来实现的，这是它内部做的性能优化。"}),"\n",(0,r.jsx)(n.p,{children:"接下来用 use-gesture 来加上手势的处理："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { useRef } from 'react'\nimport { useSprings, animated } from '@react-spring/web'\nimport { useDrag } from '@use-gesture/react';\n\nimport './App.css';\n\nconst pages = [\n  'https://images.pexels.com/photos/62689/pexels-photo-62689.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  'https://images.pexels.com/photos/733853/pexels-photo-733853.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  'https://images.pexels.com/photos/4016596/pexels-photo-4016596.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  'https://images.pexels.com/photos/351265/pexels-photo-351265.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n  'https://images.pexels.com/photos/924675/pexels-photo-924675.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260',\n]\n\nfunction Viewpager() {\n  const index = useRef(0);\n  const width = window.innerWidth;\n\n  const [props, api] = useSprings(pages.length, i => ({\n    x: i * width,\n    scale: 1\n  }));\n\n  const bind = useDrag(({ active, movement: [mx], direction: [xDir], cancel }) => {\n  \n  });\n\n  return (\n    <div className='wrapper'>\n      {props.map(({ x, scale }, i) => (\n        <animated.div className='page' {...bind()} key={i} style={{ x }}>\n          <animated.div style={{ scale, backgroundImage: `url(${pages[i]})` }} />\n        </animated.div>\n      ))}\n    </div>\n  )\n}\n\nexport default Viewpager;\n"})}),"\n",(0,r.jsx)(n.p,{children:"用 useRef 保存当前的 index，初始值是 0。"}),"\n",(0,r.jsx)(n.p,{children:"用 use-gesture 也很简单，绑定啥事件就用 useXxx，比如 useDrag、useHover、useScroll 等。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"或者用 useGesture 同时绑定多种事件："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"手势库最大的好处是可以拿到移动的方向、速率、距离等信息。"}),"\n",(0,r.jsx)(n.p,{children:"这里我们拿到的这几个参数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"movement 是拖动距离 [x, y]"}),"\n",(0,r.jsx)(n.p,{children:"direction 是拖动方向 [x, y]，1 代表向左（向上）、-1 代表向右（向下）。"}),"\n",(0,r.jsx)(n.p,{children:"active 是当前是否在拖动。"}),"\n",(0,r.jsx)(n.p,{children:"cancel 方法可以中止事件。"}),"\n",(0,r.jsx)(n.p,{children:"拖动时的处理如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const bind = useDrag(({ active, movement: [mx], direction: [xDir], cancel }) => {\n  if (active && Math.abs(mx) > width / 2) {\n    let newIndex = index.current + (xDir > 0 ? -1 : 1);\n\n    if(newIndex < 0) {\n      newIndex = 0;\n    }\n\n    if(newIndex > pages.length - 1) {\n      newIndex = pages.length - 1;\n    }\n\n    index.current =  newIndex;\n    \n    cancel()\n  }\n  api.start(i => {\n    const x = (i - index.current) * width + (active ? mx : 0)\n    const scale = active ? 1 - Math.abs(mx) / width : 1\n    return { x, scale }\n  })\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"当正在拖动并且拖动的距离超过了宽度的一半，就改变 index。"}),"\n",(0,r.jsx)(n.p,{children:"改变 index 之后调用 cancel，就不再处理后续 drag 事件了。"}),"\n",(0,r.jsx)(n.p,{children:"index 根据移动的方向来计算，xDir 大于 0，就是向左，index 减一，反之加一"}),"\n",(0,r.jsx)(n.p,{children:"然后根据拖动距离来计算每个元素的 x 和 scale："}),"\n",(0,r.jsx)(n.p,{children:"x 根据和当前 index 的差值 * width 计算，然后加上拖动的距离。"}),"\n",(0,r.jsx)(n.p,{children:"比如当前 index 为 1，那 index 为 2 的 x 就是 (2 - 1) * width，而 index 为 0 的就是 (0 - 1) * width"}),"\n",(0,r.jsx)(n.p,{children:"而 scale 则是用拖动的距离除以 width 算一个比值，然后用 1 减去它，因为刚开始拖动的时候 scale 大。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"但是现在 scale 的变化范围有点大。"}),"\n",(0,r.jsx)(n.p,{children:"可以调整下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"计算出来的比值除以 2  或者除以 3 就好了"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样我们就完成了 use-gesture 手势库和 react-spring 动画库的结合使用的案例。"}),"\n",(0,r.jsx)(n.p,{children:"用 use-gesture 手势库处理拖拽等事件，拿到移动距离、方向、速率等信息，然后再根据这些信息用 react-spring 做动画。"}),"\n",(0,r.jsxs)(n.p,{children:["use-gesture 文档里还有个案例也很有意思：\n",(0,r.jsx)("img",{src:t,alt:""})]}),"\n",(0,r.jsx)(n.p,{children:"如果拖动速度慢了，牌会回到原位置，只有快速拖动，牌才会移到一边。"}),"\n",(0,r.jsx)(n.p,{children:"它的实现就是用了 velocity 速率，也就是每 ms 移动的距离，如果大于 0.2 就算移到一边，设置对应的 x，否则就设置 0："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["具体流程都差不多，也是 use-gesture 和 react-spring 的结合使用，感兴趣可以",(0,r.jsx)(n.a,{href:"https://codesandbox.io/p/sandbox/cards-stack-to6uf?file=%2Fsrc%2FApp.tsx%3A36%2C83-36%2C91",target:"_blank",rel:"noopener noreferrer",children:"看看"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["案例代码上传了",(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/use-gesture-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这节我们学了手势库 use-gesture。"}),"\n",(0,r.jsx)(n.p,{children:"手势库也是处理 drag、scroll、hover 等事件，但是它封装了额外的信息，比如移动方向、距离、速率等。"}),"\n",(0,r.jsx)(n.p,{children:"用这些信息结合 react-spring 就可以实现各种交互动画。"})]})}function v(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(w,{...e})}):w(e)}let E=v;v.__RSPRESS_PAGE_META={},v.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC24%E7%AB%A0%E2%80%94react-spring%E7%BB%93%E5%90%88use-gesture%E6%89%8B%E5%8A%BF%E5%BA%93%E5%AE%9E%E7%8E%B0%E4%BA%A4%E4%BA%92%E5%8A%A8%E7%94%BB.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第24章—react-spring结合use-gesture手势库实现交互动画",headingTitle:"第24章—react-spring结合use-gesture手势库实现交互动画",frontmatter:{}}}}]);