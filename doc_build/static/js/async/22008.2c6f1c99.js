"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["22008"],{486459:function(e,c,s){s.r(c),s.d(c,{default:()=>o});var i=s(552676),n=s(740453);let d=s.p+"static/image/3.7.d7efcd86.png",h=s.p+"static/image/3.6.b4f9b85c.png",l=s.p+"static/image/3.5.7b6ca421.png",r=s.p+"static/image/3.4.ca749759.png",t=s.p+"static/image/3.3.6a8f48a4.png",x=s.p+"static/image/3.2.073fe0f7.png",j=s.p+"static/image/3.1.053a488e.png";function p(e){let c=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",code:"code",pre:"pre",img:"img",ol:"ol",li:"li",blockquote:"blockquote",strong:"strong"},(0,n.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(c.h1,{id:"3上手-2团队工作的基本工作模型",children:["3上手 2：团队工作的基本工作模型",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#3上手-2团队工作的基本工作模型",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"对于 Git 来说，团队合作和个人独立工作最大的不同在于，你会提交代码，别人也会提交；你会 push，别人也会 push，因此除了把代码上传，每个人还需要把别人最新的代码下载到自己的电脑。而且，这些工作都是并行进行的。"}),"\n",(0,i.jsx)(c.p,{children:"这就很复杂了！"}),"\n",(0,i.jsx)(c.p,{children:"这节的内容，就是简单阐述一下团队合作中 Git 的基本工作模型。"}),"\n",(0,i.jsxs)(c.h2,{id:"把别人的新提交拿到本地",children:["把别人的新提交拿到本地",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#把别人的新提交拿到本地",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"先说一种简单的情况：你的同事刚把他写的几个提交 push 到了中央仓库，你怎么把它们取下来。"}),"\n",(0,i.jsxs)(c.h3,{id:"假装同事",children:["假装同事",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#假装同事",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["除非你能要求同事陪你练习 Git，否则，你只能一人分饰两角：时不时地模拟一下同事的操作，来达到独自一人做多人项目练习的效果。而为了模拟同事的操作，你需要在你的 ",(0,i.jsx)(c.code,{children:"/git-practice"})," 目录旁再 clone 一次中央仓库到本地，来当做你的模拟同事的本地仓库："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git clone https://github.com/rengwuxian/git-practice.git git-practice-another\n"})}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-!",children:"注意！执行这条之前别忘了先 `cd ..` 切换到父目录，不然你会把新的本地仓库创建在原先的本地仓库的工作目录内。\n"})}),"\n",(0,i.jsxs)(c.p,{children:["为了目录名称不冲突，这次的 ",(0,i.jsx)(c.code,{children:"clone"})," 需要加一个额外参数（上面那行代码最后的 ",(0,i.jsx)(c.code,{children:"git-practice-another"}),"）来手动指定本地仓库的根目录名称。在这条指令执行完成后，你就有了两个内容相同的本地仓库.\n现在，你就可以假装 ",(0,i.jsx)(c.code,{children:"/git-practice"})," 这个目录是你的电脑上的工作目录，而那个新建的 ",(0,i.jsx)(c.code,{children:"/git-practice-another"})," 是你同事的电脑上的工作目录。"]}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:j,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["如果你对这样的操作有担心，大可不必，这种操作不会有任何问题。因为 Git 的管理是目录级别，而不是设备级别的。也就是说，",(0,i.jsx)(c.code,{children:"/git-practice"})," 目录内的 ",(0,i.jsx)(c.code,{children:".git"})," 只管理 ",(0,i.jsx)(c.code,{children:"/git-practice"})," 里的内容，",(0,i.jsx)(c.code,{children:"/git-practice-another"})," 目录内的 ",(0,i.jsx)(c.code,{children:".git"})," 也只管理 ",(0,i.jsx)(c.code,{children:"/git-practice-another"})," 里的内容，它们之间互不知晓，也互不影响。"]}),"\n",(0,i.jsxs)(c.h3,{id:"帮同事提交代码并-push-到中央仓库",children:["帮同事提交代码并 push 到中央仓库",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#帮同事提交代码并-push-到中央仓库",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"要在你的电脑上把同事的代码取下来，首先 GitHub 上要有你同事的新代码，也就是说，你首先要把同事的代码 push 到中央仓库去。所以第一步，切换到同事的目录："}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"cd git-practice-another\n"})}),"\n",(0,i.jsxs)(c.p,{children:["现在，到了同事的工作目录，你的身份就是你的同事了。帮他写点代码吧！嗯……写点什么好呢？\n",(0,i.jsx)("img",{src:x,alt:""})]}),"\n",(0,i.jsx)(c.p,{children:"嗯，看起来不错，帮他提交吧："}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git add shopping\\ list-colleague.txt\ngit commit\n"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsxs)(c.p,{children:["提交完成以后，",(0,i.jsx)(c.code,{children:"push"})," 到 GitHub："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git push\n"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:r,alt:""})}),"\n",(0,i.jsxs)(c.h2,{id:"把同事-push-的新代码取下来",children:["把同事 push 的新代码取下来",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#把同事-push-的新代码取下来",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["GitHub 上有了同事的新代码以后，你就可以变回自己，把「他」刚 push 上去的代码取到你的仓库了。首先，切回 ",(0,i.jsx)(c.code,{children:"/git-practice"})," 目录："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"cd ../git-practice\n"})}),"\n",(0,i.jsxs)(c.p,{children:["然后，把同事的代码取下来吧！从远程仓库更新内容，用的是一个新的指令：",(0,i.jsx)(c.code,{children:"pull"}),"。"]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git pull\n"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:l,alt:"用 git pull 把代码从远程仓库取下来"})}),"\n",(0,i.jsxs)(c.p,{children:["这时候再看看你的本地目录，可以看到，同事提交的 ",(0,i.jsx)(c.code,{children:"shopping list-colleagure.txt"})," 已经同步到本地了。也就是说，现在你的本地仓库和同事的又一致了。"]}),"\n",(0,i.jsxs)(c.h2,{id:"多人合作的基本工作模型",children:["多人合作的基本工作模型",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#多人合作的基本工作模型",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"这就完成了一次简单的合作流程："}),"\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsxs)(c.li,{children:["同事 ",(0,i.jsx)(c.code,{children:"commit"})," 代码到他的本地，并 ",(0,i.jsx)(c.code,{children:"push"})," 到 GitHub 中央仓库"]}),"\n",(0,i.jsxs)(c.li,{children:["你把 GitHub 的新提交通过 ",(0,i.jsx)(c.code,{children:"pull"})," 指令来取到你的本地"]}),"\n"]}),"\n",(0,i.jsxs)(c.p,{children:["通过这个流程，你和同事就可以简单地合作了：你写了代码，",(0,i.jsx)(c.code,{children:"commit"}),"，",(0,i.jsx)(c.code,{children:"push"})," 到 GitHub，然后他 ",(0,i.jsx)(c.code,{children:"pull"})," 到他的本地；他再写代码，",(0,i.jsx)(c.code,{children:"commit"}),", ",(0,i.jsx)(c.code,{children:"push"})," 到 GitHub，然后你再 ",(0,i.jsx)(c.code,{children:"pull"})," 到你的本地。你来我往，配合得不亦乐乎。"]}),"\n",(0,i.jsxs)(c.p,{children:["但是，这种合作有一个严重的问题：同一时间内，只能有一个人在工作。你和同事其中一个人写代码的时候，另一个人不能做事，必须等着他把工作做完，代码 ",(0,i.jsx)(c.code,{children:"push"})," 到 GitHub 以后，自己才能把 ",(0,i.jsx)(c.code,{children:"push"})," 上去的代码 ",(0,i.jsx)(c.code,{children:"pull"})," 到自己的本地。而如果同时做事，就会发生冲突：当一个人先于另一个人 ",(0,i.jsx)(c.code,{children:"push"})," 代码（这种情况必然会发生），那么后 ",(0,i.jsx)(c.code,{children:"push"})," 的这个人就会由于中央仓库上含有本地没有的提交而导致 ",(0,i.jsx)(c.code,{children:"push"})," 失败。\xa0"]}),"\n",(0,i.jsxs)(c.blockquote,{children:["\n",(0,i.jsx)(c.p,{children:"为什么会失败？"}),"\n",(0,i.jsxs)(c.p,{children:["因为 Git 的",(0,i.jsx)(c.code,{children:" push"})," 其实是用本地仓库的 commits 记录去覆盖远端仓库的 commits 记录（注：这是简化概念后的说法，push 的实质和这个说法略有不同），而如果在远端仓库含有本地没有的 commits 的时候，",(0,i.jsx)(c.code,{children:"push"})," （如果成功）将会导致远端的 commits 被擦掉。这种结果当然是不可行的，因此 Git 会在 ",(0,i.jsx)(c.code,{children:"push"})," 的时候进行检查，如果出现这样的情况，push 就会失败。"]}),"\n"]}),"\n",(0,i.jsx)(c.p,{children:"怎么办？下面就说。"}),"\n",(0,i.jsxs)(c.h2,{id:"push-发生冲突",children:["push 发生冲突",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#push-发生冲突",children:"#"})]}),"\n",(0,i.jsxs)(c.p,{children:["在现实的团队开发中，全队是同时并行开发的，所以必然会出现当一人 ",(0,i.jsx)(c.code,{children:"push"})," 代码时，中央仓库已经被其他同事先一步 ",(0,i.jsx)(c.code,{children:"push"})," 了的情况。为了不让文段显得太过混乱，这里我就不带着你一步步模拟这个过程了。如果你希望模拟的话，这里是步骤："]}),"\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsxs)(c.li,{children:["切到 ",(0,i.jsx)(c.code,{children:"git-practice-another"})," 去，假扮成你的同事做一个 ",(0,i.jsx)(c.code,{children:"commit"}),"，然后 ",(0,i.jsx)(c.code,{children:"push"})," 到 GitHub"]}),"\n",(0,i.jsxs)(c.li,{children:["切回 ",(0,i.jsx)(c.code,{children:"git-practice"})," 变回你自己，做一个不一样的 ",(0,i.jsx)(c.code,{children:"commit"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(c.p,{children:["这个时候，远端中央仓库已经有了别人 ",(0,i.jsx)(c.code,{children:"push"})," 的 ",(0,i.jsx)(c.code,{children:"commit"}),"，现在你如果 ",(0,i.jsx)(c.code,{children:"push"})," 的话："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git push\n"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:h,alt:"push 被拒绝"})}),"\n",(0,i.jsxs)(c.p,{children:["从上图中的提示语可以看出来（好吧这么长的提示语有人表示不想看），由于 GitHub 的远端仓库上含有本地仓库没有的内容，所以这次 ",(0,i.jsx)(c.code,{children:"push"})," 被拒绝了。这种冲突的解决方式其实很简单：",(0,i.jsxs)(c.strong,{children:["先用 ",(0,i.jsx)(c.code,{children:"pull"})," 把远端仓库上的新内容取回到本地和本地合并，然后再把合并后的本地仓库向远端仓库推送"]}),"。"]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git pull\n"})}),"\n",(0,i.jsxs)(c.p,{children:["在上面的文段里，我已经举过一次 ",(0,i.jsx)(c.code,{children:"git pull"})," 的例子，但这次的 ",(0,i.jsx)(c.code,{children:"git pull"})," 操作并没有像之前的那样直接结束，而是进入了上图这样的一个输入提交信息的界面。这是因为当 ",(0,i.jsx)(c.code,{children:"pull"})," 操作发现不仅远端仓库包含本地没有的 ",(0,i.jsx)(c.code,{children:"commit"}),"s，而且本地仓库也包含远端没有的 ",(0,i.jsx)(c.code,{children:"commit"}),"s 时，它就会把远端和本地的独有 ",(0,i.jsx)(c.code,{children:"commit"}),"s 进行合并，自动生成一个新的 ",(0,i.jsx)(c.code,{children:"commit"})," ，而上图的这个界面，就是这个自动生成的 ",(0,i.jsx)(c.code,{children:"commit"})," 的提交信息界面。另外，和手动的 ",(0,i.jsx)(c.code,{children:"commit"})," 不同，这种 ",(0,i.jsx)(c.code,{children:"commit"})," 会自动填入一个默认的提交信息，简单说明了这条 ",(0,i.jsx)(c.code,{children:"commit"})," 的来由。你可以直接退出界面来使用这个自动填写的提交信息，也可以修改它来填入自己提交信息。"]}),"\n",(0,i.jsxs)(c.blockquote,{children:["\n",(0,i.jsxs)(c.p,{children:["这种「把不同的内容进行合并，生成新的提交」的操作，叫做合并（呵呵呵哈哈），它所对应的 Git 指令是 ",(0,i.jsx)(c.code,{children:"merge"}),"。事实上，",(0,i.jsx)(c.code,{children:"git pull"})," 这个指令的内部实现就是把远程仓库使用 ",(0,i.jsx)(c.code,{children:"git fetch"})," 取下来以后再进行 ",(0,i.jsx)(c.code,{children:"merge"})," 操作的。关于更多 ",(0,i.jsx)(c.code,{children:"merge"})," 的介绍，我会在后面说，这节先不讲了。"]}),"\n"]}),"\n",(0,i.jsxs)(c.p,{children:["在退出提交信息的界面后，这次 ",(0,i.jsx)(c.code,{children:"pull"})," 就完成了：远端仓库被取到了本地，并和本地仓库进行了合并。在这个时候，就可以再 ",(0,i.jsx)(c.code,{children:"push"})," 一次了。由于现在本地仓库已经包含了所有远端仓库的 commits，所以这次 ",(0,i.jsx)(c.code,{children:"push"})," 不会再失败："]}),"\n",(0,i.jsx)(c.pre,{children:(0,i.jsx)(c.code,{className:"language-shell",children:"git push\n"})}),"\n",(0,i.jsx)(c.p,{children:(0,i.jsx)("img",{src:d,alt:"push 成功"})}),"\n",(0,i.jsxs)(c.p,{children:["这样，就把 ",(0,i.jsx)(c.code,{children:"push"})," 时本地仓库和远端仓库内容冲突的问题解决了。"]}),"\n",(0,i.jsxs)(c.h2,{id:"小结多人合作的基本工作模型-20",children:["小结：多人合作的基本工作模型 2.0",(0,i.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#小结多人合作的基本工作模型-20",children:"#"})]}),"\n",(0,i.jsx)(c.p,{children:"这样，就把刚才的那个「多人合作的基本工作模型」进行了改良："}),"\n",(0,i.jsxs)(c.ol,{children:["\n",(0,i.jsxs)(c.li,{children:["写完所有的 ",(0,i.jsx)(c.code,{children:"commit"})," 后，不用考虑中央仓库是否有新的提交，直接 ",(0,i.jsx)(c.code,{children:"push"})," 就好"]}),"\n",(0,i.jsxs)(c.li,{children:["如果 ",(0,i.jsx)(c.code,{children:"push"})," 失败，就用 ",(0,i.jsx)(c.code,{children:"pull"})," 把本地仓库的提交和中央仓库的提交进行合并，然后再 ",(0,i.jsx)(c.code,{children:"push"})," 一次"]}),"\n"]}),"\n",(0,i.jsx)(c.p,{children:"到此为止，这个工作模型已经是一个最简单的可用的工作模型了。一个小团队如果对版本管理没有什么要求的话，这个工作模型已经可以让团队用来合作开发了。"}),"\n",(0,i.jsx)(c.p,{children:"但是，这种模型由于过于简单，所以只能适用于对代码管理没太大需求的开发团队。接下来，我将介绍一种基于 branch 的工作模型，很多中小型团队的代码开发都是采用的这种工作模型。不过……需要花 4 节的时间，因为它涉及到了 Git 的一些核心理论，一些许多 Git 老手都没有真正掌握的理论。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,n.ah)(),e.components);return c?(0,i.jsx)(c,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}let o=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["Git%20%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%2F3%E4%B8%8A%E6%89%8B%202%EF%BC%9A%E5%9B%A2%E9%98%9F%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%9E%8B.md"]={toc:[{text:"把别人的新提交拿到本地",id:"把别人的新提交拿到本地",depth:2},{text:"假装同事",id:"假装同事",depth:3},{text:"帮同事提交代码并 push 到中央仓库",id:"帮同事提交代码并-push-到中央仓库",depth:3},{text:"把同事 push 的新代码取下来",id:"把同事-push-的新代码取下来",depth:2},{text:"多人合作的基本工作模型",id:"多人合作的基本工作模型",depth:2},{text:"push 发生冲突",id:"push-发生冲突",depth:2},{text:"小结：多人合作的基本工作模型 2.0",id:"小结多人合作的基本工作模型-20",depth:2}],title:"3上手 2：团队工作的基本工作模型",headingTitle:"3上手 2：团队工作的基本工作模型",frontmatter:{}}}}]);