"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16901"],{745739:function(e,n,s){s.r(n),s.d(n,{default:()=>_});var r=s(552676),t=s(740453);let a=s.p+"static/image/93dd8b61f9f16497b2f87da2a9215d95.2a45b593.webp",c=s.p+"static/image/88ceaa0477db46211b7b2f01f7df6e0e.5d601105.webp",i=s.p+"static/image/19e64cbe6c8b8ef9c128faa5d97b8fd1.c2fdaf9c.webp",p=s.p+"static/image/ff73454a48c89271aab5c3fdda18fbb6.64228392.webp",l=s.p+"static/image/c718f3186bbbc0ab9e56b1adaf72adb7.c23757a2.webp",d=s.p+"static/image/a3b561bf48418414b58a91b483c870a0.66f093f4.webp",o=s.p+"static/image/997582f9d59f8410bec2d2be291b811d.a07d1dae.webp",j=s.p+"static/image/b2699fc36151ecea7be8f5f26938b87f.fa01d9b6.webp",u=s.p+"static/image/5882f80931ccabb3ed821399e04cc7d4.25f26a0f.webp",h=s.p+"static/image/2d42611cfe2aa89829e5791b4487de36.1e1638af.webp",x=s.p+"static/image/f19130bedfc46bc79a93730b8733fc5e.d7c29349.webp",m=s.p+"static/image/2647b172e722bafbd0f36db99ddc8db9.b8bf7d86.webp",b=s.p+"static/image/f648bc977f0495811f6caf1e87172f58.370f3fab.webp",g=s.p+"static/image/977fb725b187a4d32d1a8102abed4515.01e70272.webp",f=s.p+"static/image/a4a6b8e2dd5df9b541a55bb8193c7880.bc60d3d1.webp",w=s.p+"static/image/78c29d0dfb0105ca4252c1368b427219.13b5e683.webp",v=s.p+"static/image/a9913026c3f2c530c9133614a48af003.b264fecf.webp",A=s.p+"static/image/80c6ad32b5b8d1661e5a405bccec53c0.725dc3d2.webp",S=s.p+"static/image/44865d2fdbb0f14f68cca4d026d1ad68.1cd6ce7c.webp",q=s.p+"static/image/6f479fbdb8b74c8913fd226358acbb30.897d1a29.webp",y=s.p+"static/image/14e65f902efffd84eced57b68f288210.2935af61.webp",G=s.p+"static/image/f835078e71a83e1b4dc600d4e7b938fe.65295b24.webp",E=s.p+"static/image/753f820d4e029dbe2f0ced2cfc1a5b5a.f160f62d.webp",I=s.p+"static/image/bd636c783c517aae625d980e1d2b7760.bd064857.webp";function P(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",h2:"h2"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"73-使用-passport-做身份认证",children:["73. 使用 passport 做身份认证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#73-使用-passport-做身份认证",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们实现过登录和身份认证，登录的时候基于用户名密码，后续基于 jwt。"}),"\n",(0,r.jsx)(n.p,{children:"像这种身份认证逻辑其实很通用，每个项目都会有，自然可以抽取成一个库。"}),"\n",(0,r.jsx)(n.p,{children:"先不看第三方库是怎么做的，思考下，如果让你做一个身份认证的库，你会怎么设计呢？"}),"\n",(0,r.jsx)(n.p,{children:"首先，身份认证有多种方式，比如用户名密码、jwt、google 登录、github 登录等。"}),"\n",(0,r.jsx)(n.p,{children:"这多种方式都可以实现身份认证，那我们就可以用策略模式把它们封装成一个个策略类（Strategy）。"}),"\n",(0,r.jsx)(n.p,{children:"简单看下策略模式的介绍："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:I,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"其实它就是实现了一个接口的多个类，这些类可以相互替换。"}),"\n",(0,r.jsx)(n.p,{children:"这里我们就可以用策略模式来做。"}),"\n",(0,r.jsx)(n.p,{children:"然后每个策略类里封装什么呢？"}),"\n",(0,r.jsx)(n.p,{children:"其实不同的认证方式虽然逻辑不同，但做的事情很类似："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"用户名密码登录就是从 request 的 body 里取出 username、password 来认证。"}),"\n",(0,r.jsx)(n.li,{children:"jwt 是从 request 的 Authorization 的 header 取出 token 来认证。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"不同策略都会从 request 中取出一些东西来认证，如果认证就在 request.user 上存放认证后的 user 信息"}),"，这就是它们的共同点。"]}),"\n",(0,r.jsx)(n.p,{children:"比如身份认证库 passport 的两种策略："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:G,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，不管是用户名密码的身份认证，还是 jwt 的身份认证，都会从 request 的 body 或者 header 中取出一些信息来，然后认证通过之后返回 user 的信息，passport 会设置到 request.user 上。"}),"\n",(0,r.jsx)(n.p,{children:"这个封装思路你理解了，那 passport 这个库也就差不多掌握了。"}),"\n",(0,r.jsx)(n.p,{children:"然后我们在 nest 里用一下 passport 这个库："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest new nest-passport\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:y,alt:"2.3.png"}),"\n进入项目，安装 passport："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save @nestjs/passport passport\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后我们首先实现用户名密码的认证。"}),"\n",(0,r.jsx)(n.p,{children:"这用到 passport-local 的策略，安装下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save passport-local\nnpm install --save-dev @types/passport-local\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后创建一个认证模块："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g module auth\nnest g service auth --no-spec\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:q,alt:""}),"\n添加用户名密码认证的策略："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Strategy } from 'passport-local';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { AuthService } from './auth.service';\n\n@Injectable()\nexport class LocalStrategy extends PassportStrategy(Strategy) {\n  constructor(private authService: AuthService) {\n    super();\n  }\n\n  async validate(username: string, password: string) {\n    const user = await this.authService.validateUser(username, password);\n    return user;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 AuthModule 引入下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个 LocalStrategy 的逻辑就像前面分析的："}),"\n",(0,r.jsx)(n.p,{children:"从 reqeust 的 body 中取出 username 和 password 交给你去认证，认证过了之后返回 user，它会把 user 放到 request.user 上，如果认证不通过，就抛异常，由 exception filter 处理。"}),"\n",(0,r.jsx)(n.p,{children:"我们在 AuthService 里实现这个 validateUser 方法："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Inject, Injectable, UnauthorizedException } from '@nestjs/common';\nimport { UserService } from 'src/user/user.service';\n\n@Injectable()\nexport class AuthService {\n\n    @Inject()\n    private userService: UserService;\n\n    async validateUser(username: string, pass: string) {\n        const user = await this.userService.findOne(username);\n\n        if(!user) {\n            throw new UnauthorizedException('用户不存在');\n        }\n        if(user.password !== pass) {\n            throw new UnauthorizedException('密码错误');\n        }\n\n        const { password, ...result } = user;\n        return result;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"AuthService 里根据用户名密码去校验，但是查询用户的逻辑应该在 UserModule 里，我们写一下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g module user\nnest g service user --no-spec\n"})}),"\n",(0,r.jsx)(n.p,{children:"UserService："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class UserService {\n    private readonly users = [\n        {\n            userId: 1,\n            username: '神说要有光',\n            password: 'guang',\n        },\n        {\n            userId: 2,\n            username: '东东东',\n            password: 'dong',\n        },\n    ];\n\n    async findOne(username: string) {\n        return this.users.find(user => user.username === username);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 UserModule 里导出 UserService："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后在 AuthModule 里引入下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样，passport 的流程就完成了，它会从 request 中取出 body 的 username 和 password 交给我们的 validate 方法去认证，认证完会返回 user 信息，放到 request.user 上。"}),"\n",(0,r.jsx)(n.p,{children:"那怎么应用这个策略呢？"}),"\n",(0,r.jsx)(n.p,{children:"很明显，这里适合用 Guard。"}),"\n",(0,r.jsx)(n.p,{children:"@nestjs/passport 已经做了封装了。"}),"\n",(0,r.jsx)(n.p,{children:"我们在 AppController 里加个 login 方法："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Controller, Get, Post, Req, UseGuards } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { AuthGuard } from '@nestjs/passport';\nimport { Request } from 'express';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @UseGuards(AuthGuard('local'))\n  @Post('login')\n  async login(@Req() req: Request) {\n    console.log(req.user);\n    return req.user;\n  }\n\n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"把服务跑起来："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run start:dev\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"postman 里测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样，基于 passport 的登录就完成了。"}),"\n",(0,r.jsx)(n.p,{children:"不用我们自己从 request 取 body 中的 username 和 password，也不用我们把查询结果放到 request.user 上，更不用自己实现 Guard。"}),"\n",(0,r.jsx)(n.p,{children:"确实减少了不少代码。"}),"\n",(0,r.jsx)(n.p,{children:"接下来继续做 JWT 的认证："}),"\n",(0,r.jsx)(n.p,{children:"登录的时候通过用户名、密码认证，这时候登录认证成功会返回 jwt，然后再次访问会在 Authorization 的 header 携带 jwt，然后通过 header 的 jwt 来认证。"}),"\n",(0,r.jsx)(n.p,{children:"这是一种新的认证方式，需要用新的策略。"}),"\n",(0,r.jsx)(n.p,{children:"我们首先在登录成功之后返回 jwt。"}),"\n",(0,r.jsx)(n.p,{children:"安装用到的包："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save @nestjs/jwt\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 AppModule 里引入下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'JwtModule.register({\n    secret: "guang"\n}),\n'})}),"\n",(0,r.jsx)(n.p,{children:"然后在 AppController 里 login 接口返回 jwt 的 token："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这里需要扩展下 express 的 request.user 的类型。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Controller, Get, Inject, Post, Req, UseGuards } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { AuthGuard } from '@nestjs/passport';\nimport { Request } from 'express';\nimport { JwtService } from '@nestjs/jwt';\n\ninterface JwtUserData {\n  userId: number;\n  username: string;\n}\n\ndeclare module 'express' {\n  interface Request {\n    user: JwtUserData\n  }\n}\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService) {}\n\n  @Inject()\n  jwtService: JwtService;\n\n  @UseGuards(AuthGuard('local'))\n  @Post('login')\n  async login(@Req() req: Request) {\n    console.log(req.user);\n    const token = this.jwtService.sign({\n      userId: req.user.userId,\n      username: req.user.username\n    }, {\n      expiresIn: '0.5h'\n    });\n\n    return {\n      token\n    }\n  }\n\n  @Get()\n  getHello(): string {\n    return this.appService.getHello();\n  }\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"试一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样，登录之后返回 jwt 就完成了。"}),"\n",(0,r.jsx)(n.p,{children:"然后添加 jwt.strategy.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { ExtractJwt, Strategy } from 'passport-jwt';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: 'guang',\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.userId, username: payload.username };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"指定从 request 的 header 里提取 token，然后取出 payload 之后会传入 validate 方法做验证，返回的值同样会设置到 request.user。"}),"\n",(0,r.jsx)(n.p,{children:"安装用到的包："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install --save passport-jwt\nnpm install --save-dev @types/passport-jwt\n"})}),"\n",(0,r.jsx)(n.p,{children:"在 AuthModule 引入下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在 AppController 里添加一个新的需要登录认证的接口："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@UseGuards(AuthGuard('jwt'))\n@Get(\"list\")\nlist(@Req() req: Request) {\n    console.log(req.user);\n    return ['111', '222', '333', '444', '555']\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"首先不带 token 访问下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后通过 Authorization 的 header 带上 Bearer xxx 的 token 访问下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，jwt 的认证生效了。"}),"\n",(0,r.jsx)(n.p,{children:"对比下用 passport 和不用有啥区别呢？"}),"\n",(0,r.jsx)(n.p,{children:"不用我们自己从 request 的 header 里取 token 了，也不用自己从 token 提取的信息放到 request.user 里了，也不用自己写 Guard 了。"}),"\n",(0,r.jsx)(n.p,{children:"确实方便了很多。"}),"\n",(0,r.jsx)(n.p,{children:"这样，我们就用了两个 local 和 jwt 两个策略了。"}),"\n",(0,r.jsx)(n.p,{children:"其他策略也是类似的流程，从 request 取一些信息，交给 validate 方法去验证，返回 user 放到 request.user 里。"}),"\n",(0,r.jsx)(n.p,{children:"那如果我想对 Guard 的流程做一些扩展呢？"}),"\n",(0,r.jsx)(n.p,{children:"比如 jwt 的 Guard，现在需要在每个 controller 上手动应用，我想通过一个 @IsPublic 的装饰器来标识，如果有 @IsPublic 的装饰器就不需要身份认证，否则就需要。"}),"\n",(0,r.jsx)(n.p,{children:"这就需要继承 AuthGuard('jwt') 做一些扩展了："}),"\n",(0,r.jsx)(n.p,{children:"首先，生成一个自定义装饰器："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g decorator is-public --flat --no-spec\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:l,alt:""}),"\n它的实现就是给被装饰对象添加一个 metadata："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { SetMetadata } from '@nestjs/common';\n\nexport const IS_PUBLIC_KEY = 'isPublic';\nexport const IsPublic = () => SetMetadata(IS_PUBLIC_KEY, true);\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后在 AppController 里加几个路由："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"@IsPublic()\n@Get('aaa')\naaa() {\n    return 'aaa';\n}\n\n@Get('bbb')\nbbb() {\n    return 'bbb';\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"aaa 是 public 的，不需要身份认证，而 bbb 需要。"}),"\n",(0,r.jsx)(n.p,{children:"这时就需要对 AuthGuard('jwt') 做下扩展。"}),"\n",(0,r.jsx)(n.p,{children:"新建 auth/JwtAuthGuard.ts"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { ExecutionContext, Injectable } from "@nestjs/common";\nimport { Reflector } from "@nestjs/core";\nimport { AuthGuard } from "@nestjs/passport";\nimport { IS_PUBLIC_KEY } from "src/is-public.decorator";\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard(\'jwt\') {\n  constructor(private reflector: Reflector) {\n    super();\n  }\n\n  canActivate(context: ExecutionContext) {\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n\n    if (isPublic) {\n      return true;\n    }\n    return super.canActivate(context);\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"实现就是从目标 controller、handler 上取 public 的 meatadata，如果有就直接放行，否则才做认证。"}),"\n",(0,r.jsx)(n.p,{children:"然后在 AppModule 里注册为全局 Guard："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{\n    provide: APP_GUARD,\n    useClass: JwtAuthGuard\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"测试下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"没啥问题，这样，对 AuthGuard('jwt') 的扩展就完成了。"}),"\n",(0,r.jsxs)(n.p,{children:["案例代码上传了",(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-passport",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"之前我们都是自己实现身份认证，比如基于用户名密码的认证，基于 jwt 的认证，今天我们基于 passport 库来实现了一遍。"}),"\n",(0,r.jsx)(n.p,{children:"passport 把不同的认证逻辑封装成了不同 Strategy，每个 Stategy 都有 validate 方法来验证。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"每个 Strategy 都是从 request 取出一些东西，交给 validate 方法验证，validate 方法返回 user 信息，自动放到 request.user 上。"})}),"\n",(0,r.jsx)(n.p,{children:"并且 @nestjs/passport 提供了 Guard 可以直接用，如果你想扩展，继承 AuthGuard('xxx')  然后重写下 canActivate 方法就好了。"}),"\n",(0,r.jsx)(n.p,{children:"细想一下，你做各种认证的时候，是不是也在做同样的事情呢？"}),"\n",(0,r.jsx)(n.p,{children:"那既然每次都是做这些事情，那为啥不用 passport 库来简化呢？"})]})}function U(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(P,{...e})}):P(e)}let _=U;U.__RSPRESS_PAGE_META={},U.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F73.%20%E4%BD%BF%E7%94%A8%20passport%20%E5%81%9A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"73. 使用 passport 做身份认证",headingTitle:"73. 使用 passport 做身份认证",frontmatter:{}}}}]);