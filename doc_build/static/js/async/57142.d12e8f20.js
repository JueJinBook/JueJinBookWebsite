"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["57142"],{18259:function(e,n,r){r.r(n),r.d(n,{default:()=>p});var s=r(552676),l=r(740453);let a=r.p+"static/image/39cfe6eff0da62101fd25e3851f77f3c.a39d539a.webp",c=r.p+"static/image/996ce46caaa4fa0da0e0e00bb0309aca.f6630ce8.webp",i=r.p+"static/image/2a8e0c931fb41524c2680a28d2b80340.07ce9fbc.webp",o=r.p+"static/image/c8de5b2aa3077ecb585910bc378c1eec.7a89563b.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",ul:"ul",li:"li",h2:"h2",pre:"pre",img:"img",blockquote:"blockquote",strong:"strong"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"10深入理解图像加载原理与最佳实践",children:["10.深入理解图像加载原理与最佳实践",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10深入理解图像加载原理与最佳实践",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"图形图像资源是当代 Web 应用的最常用、实惠的内容、装饰元素之一，但在 Webpack 出现之前对图像资源的处理复杂度特别高，需要借助一系列工具(甚至 Photoshop)完成压缩、雪碧图、hash、部署等操作。"}),"\n",(0,s.jsxs)(n.p,{children:["而在 Webpack 中，图像以及其它多媒体资源都被提升为一等公民 —— 能够像引用普通 JavaScript 模块一样通过 ",(0,s.jsx)(n.code,{children:"import/require"})," 语句导入资源模块，这种开发模式允许我们将图像相关的处理合入统一的心智模型中，提升开发效率。"]}),"\n",(0,s.jsx)(n.p,{children:"本文将集中介绍 Webpack 体系下处理图像资源的常见方法，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如何使用适当的 Loader 处理图像资源；"}),"\n",(0,s.jsx)(n.li,{children:"如何借助 Loader 或插件实现图像优化，包括压缩、雪碧图、响应式图片。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"在-webpack-4-中导入图像",children:["在 Webpack 4 中导入图像",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在-webpack-4-中导入图像",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["原生 Webpack 4 只能处理标准 JavaScript 模块，因此需要借助 Loader —— 例如 ",(0,s.jsx)(n.code,{children:"file-loader"}),"、",(0,s.jsx)(n.code,{children:"url-loader"}),"、",(0,s.jsx)(n.code,{children:"raw-loader"})," 等完成图像加载操作，实践中我们通常需要按资源类型选择适当加载器，简单介绍："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://v4.webpack.js.org/loaders/file-loader/",target:"_blank",rel:"noopener noreferrer",children:"file-loader"}),"：将图像引用转换为 url 语句并生成相应图片文件，例如使用如下配置："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [{\n      test: /\\.(png|jpg)$/,\n      use: ['file-loader']\n    }],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["经过 ",(0,s.jsx)(n.code,{children:"file-loader"})," 处理后，原始图片会被重命名并复制到产物文件夹，同时在代码中插入图片 URL 地址，形如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://v4.webpack.js.org/loaders/url-loader/",target:"_blank",rel:"noopener noreferrer",children:"url-loader"}),"：有两种表现，对于小于阈值 ",(0,s.jsx)(n.code,{children:"limit"})," 的图像直接转化为 base64 编码；大于阈值的图像则调用 ",(0,s.jsx)(n.code,{children:"file-loader"})," 进行加载，例如如下配置："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  module: {\n    rules: [{\n      test: /\\.(png|jpg)$/,\n      use: [{\n        loader: 'url-loader',\n        options: {\n          limit: 1024\n        }\n      }]\n    }],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["经过 ",(0,s.jsx)(n.code,{children:"url-loader"})," 处理后，小于 ",(0,s.jsx)(n.code,{children:"limit"})," 参数即 1024B 的图片会被转译为 Base64 编码，如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["对于超过 ",(0,s.jsx)(n.code,{children:"limit"})," 值的图片则直接调用 ",(0,s.jsx)(n.code,{children:"file-loader"})," 完成加载。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"url-loader"})," 同样适用于大多数图片格式，且能将许多细小的图片直接内嵌进产物中，减少页面运行时需要发出的网络请求数，在 HTTP 1.1 及之前版本中能带来正向的性能收益。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://v4.webpack.js.org/loaders/raw-loader",target:"_blank",rel:"noopener noreferrer",children:"raw-loader"}),"：不做任何转译，只是简单将文件内容复制到产物中，适用于 SVG 场景，例如如下配置："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.svg$/i,\n        use: ['raw-loader'],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["经过 ",(0,s.jsx)(n.code,{children:"raw-loader"})," 处理后，SVG 资源会被直接复制成字符串形式："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：除 ",(0,s.jsx)(n.code,{children:"raw-loader"})," 外，我们还可以使用如下 Loader 加载 SVG 资源："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/svg-inline-loader",target:"_blank",rel:"noopener noreferrer",children:"svg-inline-loader"}),"：能够自动删除 SVG 图片中与显式无关的各种原信息，达到压缩效果；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/svg-url-loader",target:"_blank",rel:"noopener noreferrer",children:"svg-url-loader"}),"：以 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs",target:"_blank",rel:"noopener noreferrer",children:"DataURL"})," 方式导入 SVG 图片，相比于 Base64 更节省空间；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/react-svg-loader",target:"_blank",rel:"noopener noreferrer",children:"react-svg-loader"}),"：导入 SVG 图片并自动转化为 React 组件形态，效果类似 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@svgr/webpack",target:"_blank",rel:"noopener noreferrer",children:"@svgr/webpack"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/vue-svg-loader",target:"_blank",rel:"noopener noreferrer",children:"vue-svg-loader"}),"：导入 SVG 图片并自动转化为 Vue 组件形态。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"在-webpack-5-中导入图像",children:["在 Webpack 5 中导入图像",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在-webpack-5-中导入图像",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上述 ",(0,s.jsx)(n.code,{children:"file-loader"}),"、",(0,s.jsx)(n.code,{children:"url-loader"}),"、",(0,s.jsx)(n.code,{children:"raw-loader"})," 都并不局限于处理图片，它们还可以被用于加载任意类型的多媒体或文本文件，使用频率极高，几乎已经成为标配组件！所以 Webpack5 直接内置了这些能力，开箱即可使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["用法上，原本需要安装、导入 Loader，Webpack5 之后只需要通过 ",(0,s.jsx)(n.code,{children:"module.rules.type"})," 属性指定",(0,s.jsx)(n.a,{href:"https://webpack.js.org/guides/asset-modules/",target:"_blank",rel:"noopener noreferrer",children:"资源类型"}),"即可，对比来看："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"file-loader"})," 对标到 ",(0,s.jsx)(n.code,{children:'type = "asset/resource"\''}),"："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nmodule.exports = {\n  // ...\n  module: {\n    rules: [{\n      test: /\\.(png|jpg)$/,\n-     use: ['file-loader']\n+     type: 'asset/resource'\n    }],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：默认情况下，",(0,s.jsx)(n.code,{children:"asset/resource"})," 生成的文件会以 ",(0,s.jsx)(n.code,{children:"[hash][ext][query]"})," 方式重命名，可以通过 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputassetmodulefilename",target:"_blank",rel:"noopener noreferrer",children:"output.assetModuleFilename"})," 属性控制。"]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"url-loader"})," 对标到 ",(0,s.jsx)(n.code,{children:'type = "asset"'})," 或 ",(0,s.jsx)(n.code,{children:'type = "asset/inline"'}),"："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  module: {\n    rules: [{\n      test: /\\.(png|jpg)$/,\n-     use: [{\n-       loader: 'url-loader',\n-       options: {\n-         limit: 1024\n-       }\n-     }]\n+     type: \"asset\",\n+     parser: {\n+        dataUrlCondition: {\n+          maxSize: 1024 // 1kb\n+        }\n+     }\n    }],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中，",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/module/#ruleparserdataurlcondition",target:"_blank",rel:"noopener noreferrer",children:"module.rules.parser.dataUrlCondition"})," 用于限定文件大小阈值，对标 ",(0,s.jsx)(n.code,{children:"url-loader"})," 的 ",(0,s.jsx)(n.code,{children:"limit"})," 属性。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"raw-loader"})," 对标到 ",(0,s.jsx)(n.code,{children:'type = "asset/source"'}),"："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  module: {\n    rules: [\n      {\n        test: /\\.svg$/i,\n-       use: ['raw-loader']\n+       type: \"asset/source\"\n      },\n    ],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["补充一下，引入 ",(0,s.jsx)(n.code,{children:"module.rules.type"})," 并不只是为了取代 Loader 那么简单，更重要的目的是在 JavaScript Module 之外增加对其它资源 —— ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/guides/asset-modules/",target:"_blank",rel:"noopener noreferrer",children:"Asset Module"})," 的原生支持，让 Webpack 有机会介入这些多媒体资源的解析、生成过程，从而有机会实现更标准、高效的资源处理模型。"]}),"\n",(0,s.jsxs)(n.p,{children:["目前 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/module/#ruletype",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"module.rules.type"})})," 已经支持 JSON、WebAssemsbly、二进制、文本等资源类型，相信在下一个 Webpack 版本中，必然会基于 Asset Module 实现更丰富的资源处理能力。"]}),"\n",(0,s.jsxs)(n.h2,{id:"图像优化压缩",children:["图像优化：压缩",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图像优化压缩",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"前面介绍的 Loader 与 Asset Modules 都只是解决了图像资源加载 —— 也就是让 Webpack 能够理解、处理图像资源，现实中我们还需要为 Web 页面中的图片做各种优化，提升页面性能，常见的优化方法包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"图像压缩"}),"：减少网络上需要传输的流量；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"雪碧图"}),"：减少 HTTP 请求次数；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"响应式图片"}),"：根据客户端设备情况下发适当分辨率的图片，有助于减少网络流量；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CDN"}),"：减少客户端到服务器之间的物理链路长度，提升传输效率；"]}),"\n",(0,s.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这其中有不少可以在开发、构建阶段借助 Webpack 搭建自动优化工作流，例如：图像压缩。"}),"\n",(0,s.jsxs)(n.p,{children:["在 Webpack 生态中有不少优秀的图像压缩组件，包括：",(0,s.jsx)(n.a,{href:"https://github.com/tcoopman/image-webpack-loader",target:"_blank",rel:"noopener noreferrer",children:"image-webpack-loader"}),"、",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/imagemin-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"imagemin-webpack-plugin"}),"、",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/image-minimizer-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"image-minimizer-webpack-plugin"})," 等，以我的使用经验来看，",(0,s.jsx)(n.a,{href:"https://github.com/tcoopman/image-webpack-loader",target:"_blank",rel:"noopener noreferrer",children:"image-webpack-loader"})," 组件功能齐全且用法简单，更推荐使用。基本用法首先安装依赖："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"yarn add -D image-webpack-loader\n"})}),"\n",(0,s.jsx)(n.p,{children:"之后配置 Loader："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  module: {\n    rules: [{\n      test: /\\.(gif|png|jpe?g|svg)$/i,\n      // type 属性适用于 Webpack5，旧版本可使用 file-loader\n      type: \"asset/resource\",\n      use: [{\n        loader: 'image-webpack-loader',\n        options: {\n          // jpeg 压缩配置\n          mozjpeg: {\n            quality: 80\n          },\n        }\n      }]\n    }],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/tcoopman/image-webpack-loader",target:"_blank",rel:"noopener noreferrer",children:"image-webpack-loader"})," 底层依赖于 ",(0,s.jsx)(n.a,{href:"https://github.com/imagemin/imagemin",target:"_blank",rel:"noopener noreferrer",children:"imagemin"})," 及一系列的图像优化工具："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/imagemin/imagemin-mozjpeg",target:"_blank",rel:"noopener noreferrer",children:"mozjpeg"}),"：用于压缩 JPG(JPEG) 图片；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/kevva/imagemin-optipng",target:"_blank",rel:"noopener noreferrer",children:"optipng"}),"：用于压缩 PNG 图片；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/imagemin/imagemin-pngquant",target:"_blank",rel:"noopener noreferrer",children:"pngquant"}),"：同样用于压缩 PNG 图片；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/kevva/imagemin-svgo",target:"_blank",rel:"noopener noreferrer",children:"svgo"}),"：用于压缩 SVG 图片；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/kevva/imagemin-gifsicle",target:"_blank",rel:"noopener noreferrer",children:"gifsicle"}),"：用于压缩 Gif 图；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/imagemin/imagemin-webp",target:"_blank",rel:"noopener noreferrer",children:"webp"}),"：用于将 JPG/PNG 图压缩并转化为 WebP 图片格式。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"基本上已经覆盖 Web 页面常用的图片格式，具体用法可点击上述链接查阅，此处不再赘述。最后补充一点，图像压缩是一种非常耗时的操作，建议只在生产环境下开启："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  module: {\n    rules: [{\n      // ...\n      use: [{\n        loader: 'image-webpack-loader',\n        options: {\n+         disable: process.env.NODE_ENV === 'development'\n          // ...\n        }\n      }]\n    }],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"图像优化雪碧图",children:["图像优化：雪碧图",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图像优化雪碧图",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 HTTP 2 之前，HTTP 请求-响应是一种性能低下的通讯模型，即使是为了请求一个非常少的数据，也可能需要完整经历：建立 TCP 连接 => 发送 HTTP 请求 => 服务端处理 => 返回响应数据整个过程，加之 HTTP 协议的队首阻塞、浏览器并发请求数限制等原因，迫使我们必须尽量减少 HTTP 请求数以提升网络通讯效率。"}),"\n",(0,s.jsxs)(n.p,{children:["例如，我们可以将许多细小的图片合并成一张大图 —— 从而将复数次请求合并为一次请求，之后配合 CSS 的 ",(0,s.jsx)(n.code,{children:"background-position"})," 控制图片的可视区域，这种技术被称作“",(0,s.jsx)(n.strong,{children:"雪碧图"}),"”。在 Webpack 中，我们可以使用 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/webpack-spritesmith",target:"_blank",rel:"noopener noreferrer",children:"webpack-spritesmith"})," 插件自动实现雪碧图效果，首先安装依赖："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"yarn add -D webpack-spritesmith\n"})}),"\n",(0,s.jsx)(n.p,{children:"之后添加配置："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  // ...\n  resolve: {\n    modules: [\"node_modules\", \"assets\"]\n  },\n  plugins: [\n    new SpritesmithPlugin({\n      // 需要\n      src: {\n        cwd: path.resolve(__dirname, 'src/icons'),\n        glob: '*.png'\n      },\n      target: {\n        image: path.resolve(__dirname, 'src/assets/sprite.png'),\n        css: path.resolve(__dirname, 'src/assets/sprite.less')\n      }\n    })\n  ]\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["关键在于，",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/webpack-spritesmith",target:"_blank",rel:"noopener noreferrer",children:"webpack-spritesmith"})," 插件会将 ",(0,s.jsx)(n.code,{children:"src.cwd"})," 目录内所有匹配 ",(0,s.jsx)(n.code,{children:"src.glob"})," 规则的图片合并成一张大图并保存到 ",(0,s.jsx)(n.code,{children:"target.image"})," 指定的文件路径，同时生成兼容 SASS/LESS/Stylus 预处理器的 mixins 代码，例如对于下面文件结构："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"load-img\n├─ src\n│  ├─ icons\n│  │  ├─ grunt.png\n│  │  ├─ gulp-js.png\n│  │  └─ webpack.png\n│  └─ index.js\n├─ webpack.config.js\n└─ package.json\n"})}),"\n",(0,s.jsx)(n.p,{children:"按照上述配置运行后会生成如下产物："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：示例代码已上传到",(0,s.jsx)(n.a,{href:"https://github1s.com/Tecvan-fe/webpack-book-samples/blob/HEAD/load-img/webpack.config.js",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["之后，我们就可以使用 ",(0,s.jsx)(n.code,{children:"sprite.less"})," 提供的 ",(0,s.jsx)(n.code,{children:".sprite"})," mixin 添加背景图："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'@import (less) "./assets/sprite.less";\n\n#main {\n    // 参数为原始图片文件名\n    .sprite(@webpack);\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"提示：雪碧图曾经是一种使用广泛的性能优化技术，但 HTTP2 实现 TCP 多路复用之后，雪碧图的优化效果已经微乎其微 —— 甚至是反优化，可以预见随 HTTP2 普及率的提升，未来雪碧图的必要性会越来越低，因此建议读者们了解作用与基本原理即可，不必深究。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"图像优化响应式图片",children:["图像优化：响应式图片",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图像优化响应式图片",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"移动互联网时代，我们需要面对的客户端设备越来越多样复杂，分辨率从 PC 到平板电脑再到移动终端跨度极大："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["这会带来一个问题：同一张图片(主要是位图)在不同设备中，如果显示尺寸大于原始尺寸，最终效果会有明显颗粒感；而如果显示尺寸小于原始尺寸，又会造成带宽浪费。理想的解决方案是为不同设备提供不同的分辨率、不同尺寸的图片 —— 也就是所谓的",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images",target:"_blank",rel:"noopener noreferrer",children:"响应式图片"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 中有不少能够自动生成响应式图片的组件，例如： ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/resize-image-loader",target:"_blank",rel:"noopener noreferrer",children:"resize-image-loader"}),"、",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/html-loader-srcset",target:"_blank",rel:"noopener noreferrer",children:"html-loader-srcset"}),"、",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/responsive-loader",target:"_blank",rel:"noopener noreferrer",children:"responsive-loader"})," 等，以 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/responsive-loader",target:"_blank",rel:"noopener noreferrer",children:"responsive-loader"})," 为例，首先安装依赖："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"yarn add -D responsive-loader sharp\n"})}),"\n",(0,s.jsx)(n.p,{children:"之后，修改配置："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  // ...\n  module: {\n    rules: [{\n      test: /\\.(png|jpg)$/,\n      oneOf: [{\n        type: "javascript/auto",\n        resourceQuery: /sizes?/,\n        use: [{\n          loader: "responsive-loader",\n          options: {\n            adapter: require("responsive-loader/sharp"),\n          },\n        }],\n      }, {\n        type: "asset/resource",\n      }],\n    }],\n  }\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["注意，实践中我们通常没必要对项目里所有图片都施加响应式特性，因此这里使用 ",(0,s.jsx)(n.code,{children:"resourceQuery"})," 过滤出带 ",(0,s.jsx)(n.code,{children:"size/sizes"})," 参数的图片引用，使用方法："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// 引用图片，并设置响应式参数\nimport responsiveImage from \'./webpack.jpg?sizes[]=300,sizes[]=600,sizes[]=1024\';\n\nconst Picture = function () {\n  return (\n    <img\n      srcSet={responsiveImage.srcSet}\n      src={responsiveImage.src}\n      sizes="(min-width: 1024px) 1024px, 100vw"\n      loading="lazy"\n    />\n  );\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["上例的引用参数 ",(0,s.jsx)(n.code,{children:"'./webpack.jpg?sizes[]=300,sizes[]=600,sizes[]=1024';"})," 最终将生成宽度分别为 300、600、1024 三张图片，之后设置 ",(0,s.jsx)(n.code,{children:"img"})," 标签的 ",(0,s.jsx)(n.a,{href:"https://www.w3schools.com/tags/att_source_srcset.asp",target:"_blank",rel:"noopener noreferrer",children:"srcset"})," 属性即可实现图片响应式功能。"]}),"\n",(0,s.jsxs)(n.p,{children:["此外，我们还能简单地通过 ",(0,s.jsx)(n.code,{children:"size"})," 参数精确控制不同条件下的图像尺寸："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:'.foo {\n    background: url("./webpack.jpg?size=1024");\n}\n\n@media (max-width: 480px) {\n    .foo {\n        background: url("./webpack.jpg?size=300");\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：除本文提及的基本功能外，",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/responsive-loader",target:"_blank",rel:"noopener noreferrer",children:"responsive-loader"})," 还提供了许多用于控制产物、压缩比等特性的配置项，有需要的同学可到 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/responsive-loader",target:"_blank",rel:"noopener noreferrer",children:"官网"})," 展开阅读。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 Webpack 5 之前，我们需要使用 ",(0,s.jsx)(n.code,{children:"file-loader"}),"、",(0,s.jsx)(n.code,{children:"url-loader"})," 等 Loader 加载图片或其它多媒体资源文件，这些加载器各有侧重点，需要根据实际场景择优选用；而 Webpack 5 之后引入了 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/guides/asset-modules/",target:"_blank",rel:"noopener noreferrer",children:"Asset Module"})," 模型，自此我们只需要设置适当的 ",(0,s.jsx)(n.code,{children:"module.rules.type"})," 配置即可，不需要为多媒体资源专门引入 Loader。"]}),"\n",(0,s.jsxs)(n.p,{children:["在加载之外，我们还可以借助 Webpack 生态一系列组件低成本实现图像压缩、雪碧图、响应式图片等优化措施，相关样例实现已汇总到 ",(0,s.jsx)(n.a,{href:"https://github1s.com/Tecvan-fe/webpack-book-samples/blob/HEAD/load-img/webpack.config.js",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"，建议拉下来体验运行效果。"]}),"\n",(0,s.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"除了文章提及的各项优化措施外，我们还能借助 Webpack 实现哪些图像优化？"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let p=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F10.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%9B%BE%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.md"]={toc:[{text:"在 Webpack 4 中导入图像",id:"在-webpack-4-中导入图像",depth:2},{text:"在 Webpack 5 中导入图像",id:"在-webpack-5-中导入图像",depth:2},{text:"图像优化：压缩",id:"图像优化压缩",depth:2},{text:"图像优化：雪碧图",id:"图像优化雪碧图",depth:2},{text:"图像优化：响应式图片",id:"图像优化响应式图片",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"10.深入理解图像加载原理与最佳实践",headingTitle:"10.深入理解图像加载原理与最佳实践",frontmatter:{}}}}]);