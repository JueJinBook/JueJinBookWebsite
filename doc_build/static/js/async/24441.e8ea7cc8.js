"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["24441"],{358899:function(e,n,s){s.r(n),s.d(n,{default:()=>t});var a=s(552676),r=s(740453);function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",h3:"h3",p:"p",code:"code",pre:"pre",ul:"ul",li:"li",strong:"strong"},(0,r.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"14set-和-map-数据结构",children:["14.Set 和 Map 数据结构",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14set-和-map-数据结构",children:"#"})]}),"\n",(0,a.jsxs)(n.h2,{id:"set",children:["Set",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"基本用法",children:["基本用法",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本用法",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Set"}),"本身是一个构造函数，用来生成 Set 数据结构。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码通过",(0,a.jsx)(n.code,{children:"add()"}),"方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Set()"}),"函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 例一\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n\n// 例二\nconst items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);\nitems.size // 5\n\n// 例三\nconst set = new Set(document.querySelectorAll('div'));\nset.size // 56\n\n// 类似于\nconst set = new Set();\ndocument\n .querySelectorAll('div')\n .forEach(div => set.add(div));\nset.size // 56\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，例一和例二都是",(0,a.jsx)(n.code,{children:"Set"}),"函数接受数组作为参数，例三是接受类似数组的对象作为参数。"]}),"\n",(0,a.jsx)(n.p,{children:"上面代码也展示了一种去除数组重复成员的方法。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 去除数组的重复成员\n[...new Set(array)]\n"})}),"\n",(0,a.jsx)(n.p,{children:"上面的方法也可以用于，去除字符串里面的重复字符。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"[...new Set('ababbc')].join('')\n// \"abc\"\n"})}),"\n",(0,a.jsxs)(n.p,{children:["向 Set 加入值的时候，不会发生类型转换，所以",(0,a.jsx)(n.code,{children:"5"}),"和",(0,a.jsx)(n.code,{children:'"5"'}),"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（",(0,a.jsx)(n.code,{children:"==="}),"），主要的区别是向 Set 加入值时认为",(0,a.jsx)(n.code,{children:"NaN"}),"等于自身，而精确相等运算符认为",(0,a.jsx)(n.code,{children:"NaN"}),"不等于自身。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set {NaN}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码向 Set 实例添加了两次",(0,a.jsx)(n.code,{children:"NaN"}),"，但是只会加入一个。这表明，在 Set 内部，两个",(0,a.jsx)(n.code,{children:"NaN"}),"是相等的。"]}),"\n",(0,a.jsx)(n.p,{children:"另外，两个对象总是不相等的。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let set = new Set();\n\nset.add({});\nset.size // 1\n\nset.add({});\nset.size // 2\n"})}),"\n",(0,a.jsx)(n.p,{children:"上面代码表示，由于两个空对象不相等，所以它们被视为两个值。"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Array.from()"}),"方法可以将 Set 结构转为数组。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const items = new Set([1, 2, 3, 4, 5]);\nconst array = Array.from(items);\n"})}),"\n",(0,a.jsx)(n.p,{children:"这就提供了去除数组重复成员的另一种方法。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function dedupe(array) {\n  return Array.from(new Set(array));\n}\n\ndedupe([1, 1, 2, 3]) // [1, 2, 3]\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"set-实例的属性和方法",children:["Set 实例的属性和方法",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#set-实例的属性和方法",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Set 结构的实例有以下属性。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.constructor"}),"：构造函数，默认就是",(0,a.jsx)(n.code,{children:"Set"}),"函数。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.size"}),"：返回",(0,a.jsx)(n.code,{children:"Set"}),"实例的成员总数。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.add(value)"}),"：添加某个值，返回 Set 结构本身。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.delete(value)"}),"：删除某个值，返回一个布尔值，表示删除是否成功。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.has(value)"}),"：返回一个布尔值，表示该值是否为",(0,a.jsx)(n.code,{children:"Set"}),"的成员。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.clear()"}),"：清除所有成员，没有返回值。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"上面这些属性和方法的实例如下。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"s.add(1).add(2).add(2);\n// 注意2被加入了两次\n\ns.size // 2\n\ns.has(1) // true\ns.has(2) // true\ns.has(3) // false\n\ns.delete(2) // true\ns.has(2) // false\n"})}),"\n",(0,a.jsxs)(n.p,{children:["下面是一个对比，判断是否包括一个键，",(0,a.jsx)(n.code,{children:"Object"}),"结构和",(0,a.jsx)(n.code,{children:"Set"}),"结构写法的不同。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 对象的写法\nconst properties = {\n  'width': 1,\n  'height': 1\n};\n\nif (properties[someName]) {\n  // do something\n}\n\n// Set的写法\nconst properties = new Set();\n\nproperties.add('width');\nproperties.add('height');\n\nif (properties.has(someName)) {\n  // do something\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"遍历操作",children:["遍历操作",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历操作",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Set 结构的实例有四个遍历方法，可以用于遍历成员。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.keys()"}),"：返回键名的遍历器"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.values()"}),"：返回键值的遍历器"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.entries()"}),"：返回键值对的遍历器"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Set.prototype.forEach()"}),"：使用回调函数遍历每个成员"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["需要特别指出的是，",(0,a.jsx)(n.code,{children:"Set"}),"的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["（1）",(0,a.jsx)(n.code,{children:"keys()"}),"，",(0,a.jsx)(n.code,{children:"values()"}),"，",(0,a.jsx)(n.code,{children:"entries()"})]})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"keys"}),"方法、",(0,a.jsx)(n.code,{children:"values"}),"方法、",(0,a.jsx)(n.code,{children:"entries"}),"方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以",(0,a.jsx)(n.code,{children:"keys"}),"方法和",(0,a.jsx)(n.code,{children:"values"}),"方法的行为完全一致。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'let set = new Set([\'red\', \'green\', \'blue\']);\n\nfor (let item of set.keys()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.values()) {\n  console.log(item);\n}\n// red\n// green\n// blue\n\nfor (let item of set.entries()) {\n  console.log(item);\n}\n// ["red", "red"]\n// ["green", "green"]\n// ["blue", "blue"]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"entries"}),"方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。"]}),"\n",(0,a.jsxs)(n.p,{children:["Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的",(0,a.jsx)(n.code,{children:"values"}),"方法。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"Set.prototype[Symbol.iterator] === Set.prototype.values\n// true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["这意味着，可以省略",(0,a.jsx)(n.code,{children:"values"}),"方法，直接用",(0,a.jsx)(n.code,{children:"for...of"}),"循环遍历 Set。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let set = new Set(['red', 'green', 'blue']);\n\nfor (let x of set) {\n  console.log(x);\n}\n// red\n// green\n// blue\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["（2）",(0,a.jsx)(n.code,{children:"forEach()"})]})}),"\n",(0,a.jsxs)(n.p,{children:["Set 结构的实例与数组一样，也拥有",(0,a.jsx)(n.code,{children:"forEach"}),"方法，用于对每个成员执行某种操作，没有返回值。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let set = new Set([1, 4, 9]);\nset.forEach((value, key) => console.log(key + ' : ' + value))\n// 1 : 1\n// 4 : 4\n// 9 : 9\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码说明，",(0,a.jsx)(n.code,{children:"forEach"}),"方法的参数就是一个处理函数。该函数的参数与数组的",(0,a.jsx)(n.code,{children:"forEach"}),"一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。"]}),"\n",(0,a.jsxs)(n.p,{children:["另外，",(0,a.jsx)(n.code,{children:"forEach"}),"方法还可以有第二个参数，表示绑定处理函数内部的",(0,a.jsx)(n.code,{children:"this"}),"对象。"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（3）遍历的应用"})}),"\n",(0,a.jsxs)(n.p,{children:["扩展运算符（",(0,a.jsx)(n.code,{children:"..."}),"）内部使用",(0,a.jsx)(n.code,{children:"for...of"}),"循环，所以也可以用于 Set 结构。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let set = new Set(['red', 'green', 'blue']);\nlet arr = [...set];\n// ['red', 'green', 'blue']\n"})}),"\n",(0,a.jsx)(n.p,{children:"扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let arr = [3, 5, 2, 2, 5, 5];\nlet unique = [...new Set(arr)];\n// [3, 5, 2]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["而且，数组的",(0,a.jsx)(n.code,{children:"map"}),"和",(0,a.jsx)(n.code,{children:"filter"}),"方法也可以间接用于 Set 了。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let set = new Set([1, 2, 3]);\nset = new Set([...set].map(x => x * 2));\n// 返回Set结构：{2, 4, 6}\n\nlet set = new Set([1, 2, 3, 4, 5]);\nset = new Set([...set].filter(x => (x % 2) == 0));\n// 返回Set结构：{2, 4}\n"})}),"\n",(0,a.jsx)(n.p,{children:"因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// （a 相对于 b 的）差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用",(0,a.jsx)(n.code,{children:"Array.from"}),"方法。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 方法一\nlet set = new Set([1, 2, 3]);\nset = new Set([...set].map(val => val * 2));\n// set的值是2, 4, 6\n\n// 方法二\nlet set = new Set([1, 2, 3]);\nset = new Set(Array.from(set, val => val * 2));\n// set的值是2, 4, 6\n"})}),"\n",(0,a.jsx)(n.p,{children:"上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。"}),"\n",(0,a.jsxs)(n.h3,{id:"集合运算",children:["集合运算",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#集合运算",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/tc39/proposal-set-methods",target:"_blank",rel:"noopener noreferrer",children:"ES2025"})," 为 Set 结构添加了以下集合运算方法。"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Set.prototype.intersection(other)：交集"}),"\n",(0,a.jsx)(n.li,{children:"Set.prototype.union(other)：并集"}),"\n",(0,a.jsx)(n.li,{children:"Set.prototype.difference(other)：差集"}),"\n",(0,a.jsx)(n.li,{children:"Set.prototype.symmetricDifference(other)：对称差集"}),"\n",(0,a.jsx)(n.li,{children:"Set.prototype.isSubsetOf(other)：判断是否为子集"}),"\n",(0,a.jsx)(n.li,{children:"Set.prototype.isSupersetOf(other)：判断是否为超集"}),"\n",(0,a.jsx)(n.li,{children:"Set.prototype.isDisjointFrom(other)：判断是否不相交"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["以上方法的参数都必须是 Set 结构，或者是一个类似于 Set 的结构（拥有",(0,a.jsx)(n.code,{children:"size"}),"属性，以及",(0,a.jsx)(n.code,{children:"keys()"}),"和",(0,a.jsx)(n.code,{children:"has()"}),"方法。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:".union()"}),"是并集运算，返回包含两个集合中存在的所有成员的集合。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const frontEnd = new Set(["JavaScript", "HTML", "CSS"]);\nconst backEnd = new Set(["Python", "Java", "JavaScript"]);\n\nconst all = frontEnd.union(backEnd);\n// Set {"JavaScript", "HTML", "CSS", "Python", "Java"}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:".intersection()"}),"是交集运算，返回同时包含在两个集合中的成员的集合。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const frontEnd = new Set(["JavaScript", "HTML", "CSS"]);\nconst backEnd = new Set(["Python", "Java", "JavaScript"]);\n\nconst frontAndBackEnd = frontEnd.intersection(backEnd);\n// Set {"JavaScript"}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:".difference()"}),"是差集运算，返回第一个集合中存在但第二个集合中不存在的所有成员的集合。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const frontEnd = new Set(["JavaScript", "HTML", "CSS"]);\nconst backEnd = new Set(["Python", "Java", "JavaScript"]);\n\nconst onlyFrontEnd = frontEnd.difference(backEnd);\n// Set {"HTML", "CSS"}\n\nconst onlyBackEnd = backEnd.difference(frontEnd);\n// Set {"Python", "Java"}\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:".symmetryDifference()"}),"是对称差集，返回两个集合的所有独一无二成员的集合，即去除了重复的成员。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const frontEnd = new Set(["JavaScript", "HTML", "CSS"]);\nconst backEnd = new Set(["Python", "Java", "JavaScript"]);\n\nconst onlyFrontEnd = frontEnd.symmetricDifference(backEnd);\n// Set {"HTML", "CSS", "Python", "Java"} \n\nconst onlyBackEnd = backEnd.symmetricDifference(frontEnd);\n// Set {"Python", "Java", "HTML", "CSS"}\n'})}),"\n",(0,a.jsx)(n.p,{children:"注意，返回结果中的成员顺序，由添加到集合的顺序决定。"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:".isSubsetOf()"}),"返回一个布尔值，判断第一个集合是否为第二个集合的子集，即第一个集合的所有成员都是第二个集合的成员。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const frontEnd = new Set(["JavaScript", "HTML", "CSS"]);\nconst declarative = new Set(["HTML", "CSS"]);\n\ndeclarative.isSubsetOf(frontEnd);\n// true\n\nfrontEndLanguages.isSubsetOf(declarativeLanguages);\n// false\n'})}),"\n",(0,a.jsx)(n.p,{children:"任何集合都是自身的子集。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"frontEnd.isSubsetOf(frontEnd);\n// true\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"isSupersetOf()"}),"返回一个布尔值，表示第一个集合是否为第二个集合的超集，即第二个集合的所有成员都是第一个集合的成员。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const frontEnd = new Set(["JavaScript", "HTML", "CSS"]);\nconst declarative = new Set(["HTML", "CSS"]);\n\ndeclarative.isSupersetOf(frontEnd);\n// false\n\nfrontEnd.isSupersetOf(declarative);\n// true\n'})}),"\n",(0,a.jsx)(n.p,{children:"任何集合都是自身的超集。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"frontEnd.isSupersetOf(frontEnd);\n// true\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:".isDisjointFrom()"}),"判断两个集合是否不相交，即没有共同成员。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const frontEnd = new Set(["JavaScript", "HTML", "CSS"]);\nconst interpreted = new Set(["JavaScript", "Ruby", "Python"]);\nconst compiled = new Set(["Java", "C++", "TypeScript"]);\n\ninterpreted.isDisjointFrom(compiled);\n// true\n\nfrontEnd.isDisjointFrom(interpreted);\n// false\n'})}),"\n",(0,a.jsxs)(n.h2,{id:"weakset",children:["WeakSet",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#weakset",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"含义",children:["含义",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#含义",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。"}),"\n",(0,a.jsx)(n.p,{children:"首先，WeakSet 的成员只能是对象和 Symbol 值，而不能是其他类型的值。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const ws = new WeakSet();\nws.add(1) // 报错\nws.add(Symbol()) // 不报错\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码试图向 WeakSet 添加一个数值和",(0,a.jsx)(n.code,{children:"Symbol"}),"值，结果前者报错了，因为 WeakSet 只能放置对象和 Symbol 值。"]}),"\n",(0,a.jsx)(n.p,{children:"其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。"}),"\n",(0,a.jsx)(n.p,{children:"这是因为垃圾回收机制根据对象的可达性（reachability）来判断回收，如果对象还能被访问到，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。"}),"\n",(0,a.jsx)(n.p,{children:"由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。"}),"\n",(0,a.jsx)(n.p,{children:"这些特点同样适用于本章后面要介绍的 WeakMap 结构。"}),"\n",(0,a.jsxs)(n.h3,{id:"语法",children:["语法",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#语法",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["WeakSet 是一个构造函数，可以使用",(0,a.jsx)(n.code,{children:"new"}),"命令，创建 WeakSet 数据结构。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const ws = new WeakSet();\n"})}),"\n",(0,a.jsx)(n.p,{children:"作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const a = [[1, 2], [3, 4]];\nconst ws = new WeakSet(a);\n// WeakSet {[1, 2], [3, 4]}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"a"}),"是一个数组，它有两个成员，也都是数组。将",(0,a.jsx)(n.code,{children:"a"}),"作为 WeakSet 构造函数的参数，",(0,a.jsx)(n.code,{children:"a"}),"的成员会自动成为 WeakSet 的成员。"]}),"\n",(0,a.jsxs)(n.p,{children:["注意，是",(0,a.jsx)(n.code,{children:"a"}),"数组的成员成为 WeakSet 的成员，而不是",(0,a.jsx)(n.code,{children:"a"}),"数组本身。这意味着，数组的成员只能是对象。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const b = [3, 4];\nconst ws = new WeakSet(b);\n// Uncaught TypeError: Invalid value used in weak set(…)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，数组",(0,a.jsx)(n.code,{children:"b"}),"的成员不是对象，加入 WeakSet 就会报错。"]}),"\n",(0,a.jsx)(n.p,{children:"WeakSet 结构有以下三个方法。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WeakSet.prototype.add(value)"}),"：向 WeakSet 实例添加一个新成员，返回 WeakSet 结构本身。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WeakSet.prototype.delete(value)"}),"：清除 WeakSet 实例的指定成员，清除成功返回",(0,a.jsx)(n.code,{children:"true"}),"，如果在 WeakSet 中找不到该成员或该成员不是对象，返回",(0,a.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"WeakSet.prototype.has(value)"}),"：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"下面是一个例子。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const ws = new WeakSet();\nconst obj = {};\nconst foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo); // false\n\nws.delete(window); // true\nws.has(window); // false\n"})}),"\n",(0,a.jsxs)(n.p,{children:["WeakSet 没有",(0,a.jsx)(n.code,{children:"size"}),"属性，没有办法遍历它的成员。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"ws.size // undefined\nws.forEach // undefined\n\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n// TypeError: undefined is not a function\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码试图获取",(0,a.jsx)(n.code,{children:"size"}),"和",(0,a.jsx)(n.code,{children:"forEach"}),"属性，结果都不能成功。"]}),"\n",(0,a.jsx)(n.p,{children:"WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。"}),"\n",(0,a.jsx)(n.p,{children:"下面是 WeakSet 的另一个例子。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const foos = new WeakSet()\nclass Foo {\n  constructor() {\n    foos.add(this)\n  }\n  method () {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');\n    }\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码保证了",(0,a.jsx)(n.code,{children:"Foo"}),"的实例方法，只能在",(0,a.jsx)(n.code,{children:"Foo"}),"的实例上调用。这里使用 WeakSet 的好处是，",(0,a.jsx)(n.code,{children:"foos"}),"对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑",(0,a.jsx)(n.code,{children:"foos"}),"，也不会出现内存泄漏。"]}),"\n",(0,a.jsxs)(n.h2,{id:"map",children:["Map",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#map",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"含义和基本用法",children:["含义和基本用法",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#含义和基本用法",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const data = {};\nconst element = document.getElementById('myDiv');\n\ndata[element] = 'metadata';\ndata['[object HTMLDivElement]'] // \"metadata\"\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码原意是将一个 DOM 节点作为对象",(0,a.jsx)(n.code,{children:"data"}),"的键，但是由于对象只接受字符串作为键名，所以",(0,a.jsx)(n.code,{children:"element"}),"被自动转为字符串",(0,a.jsx)(n.code,{children:"[object HTMLDivElement]"}),"。"]}),"\n",(0,a.jsx)(n.p,{children:"为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const m = new Map();\nconst o = {p: 'Hello World'};\n\nm.set(o, 'content')\nm.get(o) // \"content\"\n\nm.has(o) // true\nm.delete(o) // true\nm.has(o) // false\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码使用 Map 结构的",(0,a.jsx)(n.code,{children:"set"}),"方法，将对象",(0,a.jsx)(n.code,{children:"o"}),"当作",(0,a.jsx)(n.code,{children:"m"}),"的一个键，然后又使用",(0,a.jsx)(n.code,{children:"get"}),"方法读取这个键，接着使用",(0,a.jsx)(n.code,{children:"delete"}),"方法删除了这个键。"]}),"\n",(0,a.jsx)(n.p,{children:"上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const map = new Map([\n  ['name', '张三'],\n  ['title', 'Author']\n]);\n\nmap.size // 2\nmap.has('name') // true\nmap.get('name') // \"张三\"\nmap.has('title') // true\nmap.get('title') // \"Author\"\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码在新建 Map 实例时，就指定了两个键",(0,a.jsx)(n.code,{children:"name"}),"和",(0,a.jsx)(n.code,{children:"title"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"Map"}),"构造函数接受数组作为参数，实际上执行的是下面的算法。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const items = [\n  ['name', '张三'],\n  ['title', 'Author']\n];\n\nconst map = new Map();\n\nitems.forEach(\n  ([key, value]) => map.set(key, value)\n);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作",(0,a.jsx)(n.code,{children:"Map"}),"构造函数的参数。这就是说，",(0,a.jsx)(n.code,{children:"Set"}),"和",(0,a.jsx)(n.code,{children:"Map"}),"都可以用来生成新的 Map。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const set = new Set([\n  ['foo', 1],\n  ['bar', 2]\n]);\nconst m1 = new Map(set);\nm1.get('foo') // 1\n\nconst m2 = new Map([['baz', 3]]);\nconst m3 = new Map(m2);\nm3.get('baz') // 3\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，我们分别使用 Set 对象和 Map 对象，当作",(0,a.jsx)(n.code,{children:"Map"}),"构造函数的参数，结果都生成了新的 Map 对象。"]}),"\n",(0,a.jsx)(n.p,{children:"如果对同一个键多次赋值，后面的值将覆盖前面的值。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码对键",(0,a.jsx)(n.code,{children:"1"}),"连续赋值两次，后一次的值覆盖前一次的值。"]}),"\n",(0,a.jsxs)(n.p,{children:["如果读取一个未知的键，则返回",(0,a.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"new Map().get('asfddfsasadf')\n// undefined\n"})}),"\n",(0,a.jsx)(n.p,{children:"注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码的",(0,a.jsx)(n.code,{children:"set"}),"和",(0,a.jsx)(n.code,{children:"get"}),"方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此",(0,a.jsx)(n.code,{children:"get"}),"方法无法读取该键，返回",(0,a.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,a.jsx)(n.p,{children:"同理，同样的值的两个实例，在 Map 结构中被视为两个键。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，变量",(0,a.jsx)(n.code,{children:"k1"}),"和",(0,a.jsx)(n.code,{children:"k2"}),"的值是一样的，但是它们在 Map 结构中被视为两个键。"]}),"\n",(0,a.jsx)(n.p,{children:"由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。"}),"\n",(0,a.jsxs)(n.p,{children:["如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如",(0,a.jsx)(n.code,{children:"0"}),"和",(0,a.jsx)(n.code,{children:"-0"}),"就是一个键，布尔值",(0,a.jsx)(n.code,{children:"true"}),"和字符串",(0,a.jsx)(n.code,{children:"true"}),"则是两个不同的键。另外，",(0,a.jsx)(n.code,{children:"undefined"}),"和",(0,a.jsx)(n.code,{children:"null"}),"也是两个不同的键。虽然",(0,a.jsx)(n.code,{children:"NaN"}),"不严格相等于自身，但 Map 将其视为同一个键。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let map = new Map();\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n\nmap.set(true, 1);\nmap.set('true', 2);\nmap.get(true) // 1\n\nmap.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"实例的属性和操作方法",children:["实例的属性和操作方法",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例的属性和操作方法",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Map 结构的实例有以下属性和操作方法。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（1）size 属性"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"size"}),"属性返回 Map 结构的成员总数。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（2）Map.prototype.set(key, value)"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"set"}),"方法设置键名",(0,a.jsx)(n.code,{children:"key"}),"对应的键值为",(0,a.jsx)(n.code,{children:"value"}),"，然后返回整个 Map 结构。如果",(0,a.jsx)(n.code,{children:"key"}),"已经有值，则键值会被更新，否则就新生成该键。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const m = new Map();\n\nm.set('edition', 6)        // 键是字符串\nm.set(262, 'standard')     // 键是数值\nm.set(undefined, 'nah')    // 键是 undefined\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"set"}),"方法返回的是当前的",(0,a.jsx)(n.code,{children:"Map"}),"对象，因此可以采用链式写法。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let map = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（3）Map.prototype.get(key)"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"get"}),"方法读取",(0,a.jsx)(n.code,{children:"key"}),"对应的键值，如果找不到",(0,a.jsx)(n.code,{children:"key"}),"，返回",(0,a.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const m = new Map();\n\nconst hello = function() {console.log('hello');};\nm.set(hello, 'Hello ES6!') // 键是函数\n\nm.get(hello)  // Hello ES6!\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（4）Map.prototype.has(key)"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"has"}),"方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const m = new Map();\n\nm.set('edition', 6);\nm.set(262, 'standard');\nm.set(undefined, 'nah');\n\nm.has('edition')     // true\nm.has('years')       // false\nm.has(262)           // true\nm.has(undefined)     // true\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（5）Map.prototype.delete(key)"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"delete()"}),"方法删除某个键，返回",(0,a.jsx)(n.code,{children:"true"}),"。如果删除失败，返回",(0,a.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const m = new Map();\nm.set(undefined, 'nah');\nm.has(undefined)     // true\n\nm.delete(undefined)\nm.has(undefined)       // false\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（6）Map.prototype.clear()"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"clear()"}),"方法清除所有成员，没有返回值。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let map = new Map();\nmap.set('foo', true);\nmap.set('bar', false);\n\nmap.size // 2\nmap.clear()\nmap.size // 0\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"遍历方法",children:["遍历方法",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历方法",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"Map 结构原生提供三个遍历器生成函数和一个遍历方法。"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Map.prototype.keys()"}),"：返回键名的遍历器。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Map.prototype.values()"}),"：返回键值的遍历器。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Map.prototype.entries()"}),"：返回所有成员的遍历器。"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Map.prototype.forEach()"}),"：遍历 Map 的所有成员。"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"需要特别注意的是，Map 的遍历顺序就是插入顺序。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const map = new Map([\n  [\'F\', \'no\'],\n  [\'T\',  \'yes\'],\n]);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n// "F"\n// "T"\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n// "no"\n// "yes"\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// "F" "no"\n// "T" "yes"\n\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// "F" "no"\n// "T" "yes"\n\n// 等同于使用map.entries()\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n// "F" "no"\n// "T" "yes"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（",(0,a.jsx)(n.code,{children:"Symbol.iterator"}),"属性），就是",(0,a.jsx)(n.code,{children:"entries"}),"方法。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"map[Symbol.iterator] === map.entries\n// true\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Map 结构转为数组结构，比较快速的方法是使用扩展运算符（",(0,a.jsx)(n.code,{children:"..."}),"）。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const map = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\n[...map.keys()]\n// [1, 2, 3]\n\n[...map.values()]\n// ['one', 'two', 'three']\n\n[...map.entries()]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n\n[...map]\n// [[1,'one'], [2, 'two'], [3, 'three']]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["结合数组的",(0,a.jsx)(n.code,{children:"map"}),"方法、",(0,a.jsx)(n.code,{children:"filter"}),"方法，可以实现 Map 的遍历和过滤（Map 本身没有",(0,a.jsx)(n.code,{children:"map"}),"和",(0,a.jsx)(n.code,{children:"filter"}),"方法）。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const map0 = new Map()\n  .set(1, 'a')\n  .set(2, 'b')\n  .set(3, 'c');\n\nconst map1 = new Map(\n  [...map0].filter(([k, v]) => k < 3)\n);\n// 产生 Map 结构 {1 => 'a', 2 => 'b'}\n\nconst map2 = new Map(\n  [...map0].map(([k, v]) => [k * 2, '_' + v])\n    );\n// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["此外，Map 还有一个",(0,a.jsx)(n.code,{children:"forEach"}),"方法，与数组的",(0,a.jsx)(n.code,{children:"forEach"}),"方法类似，也可以实现遍历。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'map.forEach(function(value, key, map) {\n  console.log("Key: %s, Value: %s", key, value);\n});\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"forEach"}),"方法还可以接受第二个参数，用来绑定",(0,a.jsx)(n.code,{children:"this"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const reporter = {\n  report: function(key, value) {\n    console.log("Key: %s, Value: %s", key, value);\n  }\n};\n\nmap.forEach(function(value, key, map) {\n  this.report(key, value);\n}, reporter);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"forEach"}),"方法的回调函数的",(0,a.jsx)(n.code,{children:"this"}),"，就指向",(0,a.jsx)(n.code,{children:"reporter"}),"。"]}),"\n",(0,a.jsxs)(n.h3,{id:"与其他数据结构的互相转换",children:["与其他数据结构的互相转换",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#与其他数据结构的互相转换",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（1）Map 转为数组"})}),"\n",(0,a.jsxs)(n.p,{children:["前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（",(0,a.jsx)(n.code,{children:"..."}),"）。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const myMap = new Map()\n  .set(true, 7)\n  .set({foo: 3}, ['abc']);\n[...myMap]\n// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（2）数组 转为 Map"})}),"\n",(0,a.jsx)(n.p,{children:"将数组传入 Map 构造函数，就可以转为 Map。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"new Map([\n  [true, 7],\n  [{foo: 3}, ['abc']]\n])\n// Map {\n//   true => 7,\n//   Object {foo: 3} => ['abc']\n// }\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（3）Map 转为对象"})}),"\n",(0,a.jsx)(n.p,{children:"如果所有 Map 的键都是字符串，它可以无损地转为对象。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst myMap = new Map()\n  .set('yes', true)\n  .set('no', false);\nstrMapToObj(myMap)\n// { yes: true, no: false }\n"})}),"\n",(0,a.jsx)(n.p,{children:"如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（4）对象转为 Map"})}),"\n",(0,a.jsxs)(n.p,{children:["对象转为 Map 可以通过",(0,a.jsx)(n.code,{children:"Object.entries()"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'let obj = {"a":1, "b":2};\nlet map = new Map(Object.entries(obj));\n'})}),"\n",(0,a.jsx)(n.p,{children:"此外，也可以自己实现一个转换函数。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'function objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n// Map {"yes" => true, "no" => false}\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（5）Map 转为 JSON"})}),"\n",(0,a.jsx)(n.p,{children:"Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function strMapToJson(strMap) {\n  return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n// '{\"yes\":true,\"no\":false}'\n"})}),"\n",(0,a.jsx)(n.p,{children:"另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function mapToArrayJson(map) {\n  return JSON.stringify([...map]);\n}\n\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"（6）JSON 转为 Map"})}),"\n",(0,a.jsx)(n.p,{children:"JSON 转为 Map，正常情况下，所有键名都是字符串。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function jsonToStrMap(jsonStr) {\n  return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n// Map {'yes' => true, 'no' => false}\n"})}),"\n",(0,a.jsx)(n.p,{children:"但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function jsonToMap(jsonStr) {\n  return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// Map {true => 7, Object {foo: 3} => ['abc']}\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"weakmap",children:["WeakMap",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#weakmap",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"含义-1",children:["含义",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#含义-1",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"WeakMap"}),"结构与",(0,a.jsx)(n.code,{children:"Map"}),"结构类似，也是用于生成键值对的集合。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// WeakMap 可以使用 set 方法添加成员\nconst wm1 = new WeakMap();\nconst key = {foo: 1};\nwm1.set(key, 2);\nwm1.get(key) // 2\n\n// WeakMap 也可以接受一个数组，\n// 作为构造函数的参数\nconst k1 = [1, 2, 3];\nconst k2 = [4, 5, 6];\nconst wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);\nwm2.get(k2) // \"bar\"\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"WeakMap"}),"与",(0,a.jsx)(n.code,{children:"Map"}),"的区别有两点。"]}),"\n",(0,a.jsxs)(n.p,{children:["首先，",(0,a.jsx)(n.code,{children:"WeakMap"}),"只接受对象（",(0,a.jsx)(n.code,{children:"null"}),"除外）和 ",(0,a.jsx)(n.a,{href:"https://github.com/tc39/proposal-symbols-as-weakmap-keys",target:"_blank",rel:"noopener noreferrer",children:"Symbol 值"}),"作为键名，不接受其他类型的值作为键名。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const map = new WeakMap();\nmap.set(1, 2) // 报错\nmap.set(null, 2) // 报错\nmap.set(Symbol(), 2) // 不报错\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，如果将数值",(0,a.jsx)(n.code,{children:"1"}),"和",(0,a.jsx)(n.code,{children:"null"}),"作为 WeakMap 的键名，都会报错，将 Symbol 值作为键名不会报错。"]}),"\n",(0,a.jsxs)(n.p,{children:["其次，",(0,a.jsx)(n.code,{children:"WeakMap"}),"的键名所指向的对象，不计入垃圾回收机制。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"WeakMap"}),"的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const e1 = document.getElementById('foo');\nconst e2 = document.getElementById('bar');\nconst arr = [\n  [e1, 'foo 元素'],\n  [e2, 'bar 元素'],\n];\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"e1"}),"和",(0,a.jsx)(n.code,{children:"e2"}),"是两个对象，我们通过",(0,a.jsx)(n.code,{children:"arr"}),"数组对这两个对象添加一些文字说明。这就形成了",(0,a.jsx)(n.code,{children:"arr"}),"对",(0,a.jsx)(n.code,{children:"e1"}),"和",(0,a.jsx)(n.code,{children:"e2"}),"的引用。"]}),"\n",(0,a.jsxs)(n.p,{children:["一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放",(0,a.jsx)(n.code,{children:"e1"}),"和",(0,a.jsx)(n.code,{children:"e2"}),"占用的内存。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 不需要 e1 和 e2 的时候\n// 必须手动删除引用\narr [0] = null;\narr [1] = null;\n"})}),"\n",(0,a.jsx)(n.p,{children:"上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。"}),"\n",(0,a.jsx)(n.p,{children:"WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。"}),"\n",(0,a.jsxs)(n.p,{children:["基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用",(0,a.jsx)(n.code,{children:"WeakMap"}),"结构。当该 DOM 元素被清除，其所对应的",(0,a.jsx)(n.code,{children:"WeakMap"}),"记录就会自动被移除。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const wm = new WeakMap();\n\nconst element = document.getElementById('example');\n\nwm.set(element, 'some information');\nwm.get(element) // \"some information\"\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，先新建一个 WeakMap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对",(0,a.jsx)(n.code,{children:"element"}),"的引用就是弱引用，不会被计入垃圾回收机制。"]}),"\n",(0,a.jsx)(n.p,{children:"也就是说，上面的 DOM 节点对象除了 WeakMap 的弱引用外，其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放。WeakMap 保存的这个键值对，也会自动消失。"}),"\n",(0,a.jsxs)(n.p,{children:["总之，",(0,a.jsx)(n.code,{children:"WeakMap"}),"的专用场合就是，它的键所对应的对象，可能会在将来消失。",(0,a.jsx)(n.code,{children:"WeakMap"}),"结构有助于防止内存泄漏。"]}),"\n",(0,a.jsx)(n.p,{children:"注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const wm = new WeakMap();\nlet key = {};\nlet obj = {foo: 1};\n\nwm.set(key, obj);\nobj = null;\nwm.get(key)\n// Object {foo: 1}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，键值",(0,a.jsx)(n.code,{children:"obj"}),"是正常引用。所以，即使在 WeakMap 外部消除了",(0,a.jsx)(n.code,{children:"obj"}),"的引用，WeakMap 内部的引用依然存在。"]}),"\n",(0,a.jsxs)(n.h3,{id:"weakmap-的语法",children:["WeakMap 的语法",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#weakmap-的语法",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有",(0,a.jsx)(n.code,{children:"keys()"}),"、",(0,a.jsx)(n.code,{children:"values()"}),"和",(0,a.jsx)(n.code,{children:"entries()"}),"方法），也没有",(0,a.jsx)(n.code,{children:"size"}),"属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持",(0,a.jsx)(n.code,{children:"clear"}),"方法。因此，",(0,a.jsx)(n.code,{children:"WeakMap"}),"只有四个方法可用：",(0,a.jsx)(n.code,{children:"get()"}),"、",(0,a.jsx)(n.code,{children:"set()"}),"、",(0,a.jsx)(n.code,{children:"has()"}),"、",(0,a.jsx)(n.code,{children:"delete()"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const wm = new WeakMap();\n\n// size、forEach、clear 方法都不存在\nwm.size // undefined\nwm.forEach // undefined\nwm.clear // undefined\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"weakmap-的示例",children:["WeakMap 的示例",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#weakmap-的示例",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。"}),"\n",(0,a.jsxs)(n.p,{children:["贺师俊老师",(0,a.jsx)(n.a,{href:"https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104",target:"_blank",rel:"noopener noreferrer",children:"提示"}),"，如果引用所指向的值占用特别多的内存，就可以通过 Node 的",(0,a.jsx)(n.code,{children:"process.memoryUsage"}),"方法看出来。根据这个思路，网友",(0,a.jsx)(n.a,{href:"https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925",target:"_blank",rel:"noopener noreferrer",children:"vtxf"}),"补充了下面的例子。"]}),"\n",(0,a.jsx)(n.p,{children:"首先，打开 Node 命令行。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"$ node --expose-gc\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"--expose-gc"}),"参数表示允许手动执行垃圾回收机制。"]}),"\n",(0,a.jsx)(n.p,{children:"然后，执行下面的代码。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// 手动执行一次垃圾回收，保证获取的内存使用状态准确\n> global.gc();\nundefined\n\n// 查看内存占用的初始状态，heapUsed 为 4M 左右\n> process.memoryUsage();\n{ rss: 21106688,\n  heapTotal: 7376896,\n  heapUsed: 4153936,\n  external: 9059 }\n\n> let wm = new WeakMap();\nundefined\n\n// 新建一个变量 key，指向一个 5*1024*1024 的数组\n> let key = new Array(5 * 1024 * 1024);\nundefined\n\n// 设置 WeakMap 实例的键名，也指向 key 数组\n// 这时，key 数组实际被引用了两次，\n// 变量 key 引用一次，WeakMap 的键名引用了第二次\n// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1\n> wm.set(key, 1);\nWeakMap {}\n\n> global.gc();\nundefined\n\n// 这时内存占用 heapUsed 增加到 45M 了\n> process.memoryUsage();\n{ rss: 67538944,\n  heapTotal: 7376896,\n  heapUsed: 45782816,\n  external: 8945 }\n\n// 清除变量 key 对数组的引用，\n// 但没有手动清除 WeakMap 实例的键名对数组的引用\n> key = null;\nnull\n\n// 再次执行垃圾回收\n> global.gc();\nundefined\n\n// 内存占用 heapUsed 变回 4M 左右，\n// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收\n> process.memoryUsage();\n{ rss: 20639744,\n  heapTotal: 8425472,\n  heapUsed: 3979792,\n  external: 8956 }\n"})}),"\n",(0,a.jsx)(n.p,{children:"上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。"}),"\n",(0,a.jsx)(n.p,{children:"Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。"}),"\n",(0,a.jsxs)(n.h3,{id:"weakmap-的用途",children:["WeakMap 的用途",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#weakmap-的用途",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let myWeakmap = new WeakMap();\n\nmyWeakmap.set(\n  document.getElementById('logo'),\n  {timesClicked: 0})\n;\n\ndocument.getElementById('logo').addEventListener('click', function() {\n  let logoData = myWeakmap.get(document.getElementById('logo'));\n  logoData.timesClicked++;\n}, false);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"document.getElementById('logo')"}),"是一个 DOM 节点，每当发生",(0,a.jsx)(n.code,{children:"click"}),"事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。"]}),"\n",(0,a.jsx)(n.p,{children:"WeakMap 的另一个用处是部署私有属性。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const _counter = new WeakMap();\nconst _action = new WeakMap();\n\nclass Countdown {\n  constructor(counter, action) {\n    _counter.set(this, counter);\n    _action.set(this, action);\n  }\n  dec() {\n    let counter = _counter.get(this);\n    if (counter < 1) return;\n    counter--;\n    _counter.set(this, counter);\n    if (counter === 0) {\n      _action.get(this)();\n    }\n  }\n}\n\nconst c = new Countdown(2, () => console.log('DONE'));\n\nc.dec()\nc.dec()\n// DONE\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"Countdown"}),"类的两个内部属性",(0,a.jsx)(n.code,{children:"_counter"}),"和",(0,a.jsx)(n.code,{children:"_action"}),"，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。"]}),"\n",(0,a.jsxs)(n.h2,{id:"weakref",children:["WeakRef",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#weakref",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["WeakSet 和 WeakMap 是基于弱引用的数据结构，",(0,a.jsx)(n.a,{href:"https://github.com/tc39/proposal-weakrefs",target:"_blank",rel:"noopener noreferrer",children:"ES2021"})," 更进一步，提供了 WeakRef 对象，用于直接创建对象的弱引用。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let target = {};\nlet wr = new WeakRef(target);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面示例中，",(0,a.jsx)(n.code,{children:"target"}),"是原始对象，构造函数",(0,a.jsx)(n.code,{children:"WeakRef()"}),"创建了一个基于",(0,a.jsx)(n.code,{children:"target"}),"的新对象",(0,a.jsx)(n.code,{children:"wr"}),"。这里，",(0,a.jsx)(n.code,{children:"wr"}),"就是一个 WeakRef 的实例，属于对",(0,a.jsx)(n.code,{children:"target"}),"的弱引用，垃圾回收机制不会计入这个引用，也就是说，",(0,a.jsx)(n.code,{children:"wr"}),"的引用不会妨碍原始对象",(0,a.jsx)(n.code,{children:"target"}),"被垃圾回收机制清除。"]}),"\n",(0,a.jsxs)(n.p,{children:["WeakRef 实例对象有一个",(0,a.jsx)(n.code,{children:"deref()"}),"方法，如果原始对象存在，该方法返回原始对象；如果原始对象已经被垃圾回收机制清除，该方法返回",(0,a.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"let target = {};\nlet wr = new WeakRef(target);\n\nlet obj = wr.deref();\nif (obj) { // target 未被垃圾回收机制清除\n  // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面示例中，",(0,a.jsx)(n.code,{children:"deref()"}),"方法可以判断原始对象是否已被清除。"]}),"\n",(0,a.jsx)(n.p,{children:"弱引用对象的一大用处，就是作为缓存，未被清除时可以从缓存取值，一旦清除缓存就自动失效。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function makeWeakCached(f) {\n  const cache = new Map();\n  return key => {\n    const ref = cache.get(key);\n    if (ref) {\n      const cached = ref.deref();\n      if (cached !== undefined) return cached;\n    }\n\n    const fresh = f(key);\n    cache.set(key, new WeakRef(fresh));\n    return fresh;\n  };\n}\n\nconst getImageCached = makeWeakCached(getImage);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面示例中，",(0,a.jsx)(n.code,{children:"makeWeakCached()"}),"用于建立一个缓存，缓存里面保存对原始文件的弱引用。"]}),"\n",(0,a.jsxs)(n.p,{children:["注意，标准规定，一旦使用",(0,a.jsx)(n.code,{children:"WeakRef()"}),"创建了原始对象的弱引用，那么在本轮事件循环（event loop），原始对象肯定不会被清除，只会在后面的事件循环才会被清除。"]}),"\n",(0,a.jsxs)(n.h2,{id:"finalizationregistry",children:["FinalizationRegistry",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#finalizationregistry",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/tc39/proposal-weakrefs#finalizers",target:"_blank",rel:"noopener noreferrer",children:"ES2021"})," 引入了清理器注册表功能 FinalizationRegistry，用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数。"]}),"\n",(0,a.jsx)(n.p,{children:"首先，新建一个注册表实例。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const registry = new FinalizationRegistry(heldValue => {\n  // ....\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"FinalizationRegistry()"}),"是系统提供的构造函数，返回一个清理器注册表实例，里面登记了所要执行的回调函数。回调函数作为",(0,a.jsx)(n.code,{children:"FinalizationRegistry()"}),"的参数传入，它本身有一个参数",(0,a.jsx)(n.code,{children:"heldValue"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:["然后，注册表实例的",(0,a.jsx)(n.code,{children:"register()"}),"方法，用来注册所要观察的目标对象。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'registry.register(theObject, "some value");\n'})}),"\n",(0,a.jsxs)(n.p,{children:["上面示例中，",(0,a.jsx)(n.code,{children:"theObject"}),"就是所要观察的目标对象，一旦该对象被垃圾回收机制清除，注册表就会在清除完成后，调用早前注册的回调函数，并将",(0,a.jsx)(n.code,{children:"some value"}),"作为参数（前面的",(0,a.jsx)(n.code,{children:"heldValue"}),"）传入回调函数。"]}),"\n",(0,a.jsxs)(n.p,{children:["注意，注册表不对目标对象",(0,a.jsx)(n.code,{children:"theObject"}),"构成强引用，属于弱引用。因为强引用的话，原始对象就不会被垃圾回收机制清除，这就失去使用注册表的意义了。"]}),"\n",(0,a.jsxs)(n.p,{children:["回调函数的参数",(0,a.jsx)(n.code,{children:"heldValue"}),"可以是任意类型的值，字符串、数值、布尔值、对象，甚至可以是",(0,a.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:["最后，如果以后还想取消已经注册的回调函数，则要向",(0,a.jsx)(n.code,{children:"register()"}),"传入第三个参数，作为标记值。这个标记值必须是对象，一般都用原始对象。接着，再使用注册表实例对象的",(0,a.jsx)(n.code,{children:"unregister()"}),"方法取消注册。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'registry.register(theObject, "some value", theObject);\n// ...其他操作...\nregistry.unregister(theObject);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["上面代码中，",(0,a.jsx)(n.code,{children:"register()"}),"方法的第三个参数就是标记值",(0,a.jsx)(n.code,{children:"theObject"}),"。取消回调函数时，要使用",(0,a.jsx)(n.code,{children:"unregister()"}),"方法，并将标记值作为该方法的参数。这里",(0,a.jsx)(n.code,{children:"register()"}),"方法对第三个参数的引用，也属于弱引用。如果没有这个参数，则回调函数无法取消。"]}),"\n",(0,a.jsxs)(n.p,{children:["由于回调函数被调用以后，就不再存在于注册表之中了，所以执行",(0,a.jsx)(n.code,{children:"unregister()"}),"应该是在回调函数还没被调用之前。"]}),"\n",(0,a.jsxs)(n.p,{children:["下面使用",(0,a.jsx)(n.code,{children:"FinalizationRegistry"}),"，对前一节的缓存函数进行增强。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function makeWeakCached(f) {\n  const cache = new Map();\n  const cleanup = new FinalizationRegistry(key => {\n    const ref = cache.get(key);\n    if (ref && !ref.deref()) cache.delete(key);\n  });\n\n  return key => {\n    const ref = cache.get(key);\n    if (ref) {\n      const cached = ref.deref();\n      if (cached !== undefined) return cached;\n    }\n\n    const fresh = f(key);\n    cache.set(key, new WeakRef(fresh));\n    cleanup.register(fresh, key);\n    return fresh;\n  };\n}\n\nconst getImageCached = makeWeakCached(getImage);\n"})}),"\n",(0,a.jsx)(n.p,{children:"上面示例与前一节的例子相比，就是增加一个清理器注册表，一旦缓存的原始对象被垃圾回收机制清除，会自动执行一个回调函数。该回调函数会清除缓存里面已经失效的键。"}),"\n",(0,a.jsx)(n.p,{children:"下面是另一个例子。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'class Thingy {\n  #file;\n  #cleanup = file => {\n    console.error(\n      `The \\`release\\` method was never called for the \\`Thingy\\` for the file "${file.name}"`\n    );\n  };\n  #registry = new FinalizationRegistry(this.#cleanup);\n\n  constructor(filename) {\n    this.#file = File.open(filename);\n    this.#registry.register(this, this.#file, this.#file);\n  }\n\n  release() {\n    if (this.#file) {\n      this.#registry.unregister(this.#file);\n      File.close(this.#file);\n      this.#file = null;\n    }\n  }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["上面示例中，如果由于某种原因，",(0,a.jsx)(n.code,{children:"Thingy"}),"类的实例对象没有调用",(0,a.jsx)(n.code,{children:"release()"}),"方法，就被垃圾回收机制清除了，那么清理器就会调用回调函数",(0,a.jsx)(n.code,{children:"#cleanup()"}),"，输出一条错误信息。"]}),"\n",(0,a.jsx)(n.p,{children:"由于无法知道清理器何时会执行，所以最好避免使用它。另外，如果浏览器窗口关闭或者进程意外退出，清理器则不会运行。"}),"\n",(0,a.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://www.sonarsource.com/blog/union-intersection-difference-javascript-sets/",target:"_blank",rel:"noopener noreferrer",children:"Union, intersection, difference, and more are coming to JavaScript Sets"})}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}let t=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F14.Set%20%E5%92%8C%20Map%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md"]={toc:[{text:"Set",id:"set",depth:2},{text:"基本用法",id:"基本用法",depth:3},{text:"Set 实例的属性和方法",id:"set-实例的属性和方法",depth:3},{text:"遍历操作",id:"遍历操作",depth:3},{text:"集合运算",id:"集合运算",depth:3},{text:"WeakSet",id:"weakset",depth:2},{text:"含义",id:"含义",depth:3},{text:"语法",id:"语法",depth:3},{text:"Map",id:"map",depth:2},{text:"含义和基本用法",id:"含义和基本用法",depth:3},{text:"实例的属性和操作方法",id:"实例的属性和操作方法",depth:3},{text:"遍历方法",id:"遍历方法",depth:3},{text:"与其他数据结构的互相转换",id:"与其他数据结构的互相转换",depth:3},{text:"WeakMap",id:"weakmap",depth:2},{text:"含义",id:"含义-1",depth:3},{text:"WeakMap 的语法",id:"weakmap-的语法",depth:3},{text:"WeakMap 的示例",id:"weakmap-的示例",depth:3},{text:"WeakMap 的用途",id:"weakmap-的用途",depth:3},{text:"WeakRef",id:"weakref",depth:2},{text:"FinalizationRegistry",id:"finalizationregistry",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"14.Set 和 Map 数据结构",headingTitle:"14.Set 和 Map 数据结构",frontmatter:{}}}}]);