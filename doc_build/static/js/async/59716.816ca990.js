"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["59716"],{297412:function(n,e,r){r.r(e),r.d(e,{default:()=>d});var i=r(552676),l=r(740453);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",h2:"h2",img:"img",h3:"h3",pre:"pre",blockquote:"blockquote",br:"br",h4:"h4"},(0,l.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"2初级入门-----从一个点开始掌握-webgl-的编程要素",children:["2.初级入门 --- 从一个点开始：掌握 WebGL 的编程要素",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2初级入门-----从一个点开始掌握-webgl-的编程要素",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"本节内容涉及一些术语，为了便于大家理解，在讲解之前，我对相关术语做个简单解释："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["图元：WebGL 能够绘制的基本图形元素，包含三种：",(0,i.jsx)(e.code,{children:"点"}),"、",(0,i.jsx)(e.code,{children:"线段"}),"、",(0,i.jsx)(e.code,{children:"三角形"}),"。"]}),"\n",(0,i.jsx)(e.li,{children:"片元：可以理解为像素，像素着色阶段是在片元着色器中。"}),"\n",(0,i.jsxs)(e.li,{children:["裁剪坐标系：裁剪坐标系是顶点着色器中的 ",(0,i.jsx)(e.code,{children:"gl_Position"})," 内置变量接收到的坐标所在的坐标系。"]}),"\n",(0,i.jsx)(e.li,{children:"设备坐标系：又名 NDC 坐标系，是裁剪坐标系各个分量对 w 分量相除得到的坐标系，特点是 x、y、z 坐标分量的取值范围都在 【-1，1】之间，可以将它理解为边长为 2 的正方体，坐标系原点在正方体中心。"}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"目标",children:["目标",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#目标",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"本节实现一个最简单的 WebGL 程序：鼠标点击一次，就会在点击位置处绘制一个随机颜色的点。"}),"\n",(0,i.jsx)(e.p,{children:"效果如下："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,UklGRqQDAABXRUJQVlA4IJgDAADQOwCdASpUAiYBPp1Ook2lpKMiIdm4CLATiWlu4XdhGxo6vxeGNP18T0ttFztum2egBZSgJhRJjVGg92YoC4Y6QX4qsaD3ZigLhjpBfiqxoPdmKAuGOkF+KrGg92YoC4Y6QX4qsaD3ZigLhjpBfiqxoPdmH503YnjIqYv7GOkF+KrGg92YoC4Y6QX4C/15XEbTOTw1OVY0HuzFAXDGm235T9gRbfpJHaThjpBgO7QWpBfiqxoPdmH5gZfxyJfP6pvRWNB7sw/HVTWsAC1IL8VWNCAkAUBcMdIL8TpLAlLxVY0HuzFAXDHSC/FVjQblp5zyxG8kg92YoC4Y6QX4A73LwzDqHrbINsydNBBG+lYKMXnW9eKgLhjpBfiqrOeqwtCK4NOj0IQZ3tZRVYiGQFa9Zj35yAYoC4Y6QX4qsQqaSNIMjFEhB/gtA6t3OgH/OpHwaigLhjpBfiqxn9SBz1uif0Tz7mKd7PEFGO8AtJ5wX4qsaD3ZigLhjpBfiqx2hB7suEJ2pseAeMuVqQX4qsaD3ZigLhjpBficQy1MZ1g2YWVY0HuzFAXDHSC/FVjQe7MUBcMdIL8VWNB7sxQFwx0gvxVY0HuzFAXDHSC/FVjQe7MUBcMdIL8VWNB7sxQFwx0gvxVY0G4AAP7+aQAAAAAGWnK30l1IefP9J2CN+Qw3UpsjRlka6HoQJ6fAcGEen7iTF+ueCEOzY8LpQXqCv67MYLGmuzLoJxOGtOSwreK8JjolQLYB+ICBg64OOAABFnzZhE/+jqn1nfmyJxNpXgDSgL4XQeiIgRXQfXhaIf5mfuNw3VNCu2Z0VRGntQLYXaEdH/BNbLoqyji8DxGeVvUSW9cNlIT1R1TfPntbujHLUXGVrANQFsoDT7dDjifhfoEDqL2GmhB0GKQHjW0gPFQbEsAzjCwj7grPo21wuNXv3u4RHHhKVe+ezgQmwv4r9RSRF3WUIAnZx1l3tDpl/derF94uD6gTwUtoGOq06ZH97I9QED+NWOA1rwKTbDlA1wC9tyozr9yuj2hXkaimIeubI5erSTdt/7CEG3YtTxLBKVh39zdXd8ctQ9INqnIfXDihaiGioAAz4AM+2a+PfY6dnazNCKI96oOvUM5wyhWGlXPw8FO08Q7PKY2EieeMR0AYmvUllyDqJf0Z71xzzYc6Y2fiaYxfKss36n6qECqAEHQ18P80Gkym4pOjqcwGYQDgAAAAAAAAAA==",alt:""})}),"\n",(0,i.jsx)(e.p,{children:"希望通过这个例子，能够让大家掌握 WebGL 的绘制过程。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"http://ifanqi.top/webgl/pages/lesson1.1.html",target:"_blank",rel:"noopener noreferrer",children:"演示地址"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:"https://github.com/lucefer/webgl/blob/master/pages/lesson1.1.html",target:"_blank",rel:"noopener noreferrer",children:"源码地址"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"编写第一个-webgl-程序",children:["编写第一个 WebGL 程序",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#编写第一个-webgl-程序",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["上节我们讲到 WebGL 应用包含两个要素：",(0,i.jsx)(e.code,{children:"JavaScript程序"}),"和",(0,i.jsx)(e.code,{children:"着色器程序"}),"。本节我们通过绘制一个点来演示这个过程，麻雀虽小，但五脏俱全。使用 WebGL 绘制一个点虽然简单，但是它仍需要 JavaScript 程序和着色器程序共同完成。"]}),"\n",(0,i.jsx)(e.p,{children:"我们的目标是绘制一个在屏幕中心，大小为 10，颜色是红色的点。"}),"\n",(0,i.jsxs)(e.h3,{id:"1准备着色器源码",children:["1、准备着色器源码",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1准备着色器源码",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["我们从",(0,i.jsx)(e.code,{children:"着色器程序"}),"开始入手，先用GLSL编写",(0,i.jsx)(e.code,{children:"顶点着色器"}),"和",(0,i.jsx)(e.code,{children:"片元着色器"}),"。"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"顶点着色器"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["顶点着色器的主要任务是告诉 GPU 在",(0,i.jsx)(e.code,{children:"裁剪坐标系"}),"的原点（也就是屏幕中心）画一个大小为 10 的点。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-glsl",children:"void main(){\n    //声明顶点位置\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    //声明待绘制的点的大小。\n    gl_PointSize = 10.0;\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"片元着色器"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["顶点着色器中的数据经过",(0,i.jsx)(e.code,{children:"图元装配"}),"和",(0,i.jsx)(e.code,{children:"光栅化"}),"之后，来到了",(0,i.jsx)(e.code,{children:"片元着色器"}),"，在本例中，片元着色器的任务是通知 GPU 将光栅化后的像素渲染成红色，所以片元着色器要对内置变量 ",(0,i.jsx)(e.code,{children:"gl_FragColor"})," （代表像素要填充的颜色）进行赋值。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-glsl",children:"void main(){\n    //设置像素的填充颜色为红色。\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"至此，我们完成了着色器的开发，是不是很简单呢？"}),"\n",(0,i.jsx)(e.p,{children:"但是我相信会有一部分细心的同学产生了疑问："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl_Position、gl_PointSize、gl_FragColor 代表什么？为什么没有声明就可以赋值？"}),"\n",(0,i.jsx)(e.li,{children:"vec4 的含义？"}),"\n",(0,i.jsxs)(e.li,{children:["在 CSS 语法中或者一些制图软件中，",(0,i.jsx)(e.code,{children:"RGBA"})," 模式下红色用（255, 0, 0, 1）来表示，为什么片元着色器中颜色用 ",(0,i.jsx)(e.code,{children:"vec4(1.0, 0.0, 0.0, 1.0)"})," 来表示呢？"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"这些是 GLSL 的语法细节，后面章节我会对 GLSL 语法作详细介绍，但在这之前，我们先要认识一下它们。"}),"\n",(0,i.jsx)(e.p,{children:"那么，解释一下上面列出的三个疑问："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"gl_Position、gl_PointSize、gl_FragColor 是 GLSL 的内置属性。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["gl_Position：顶点的",(0,i.jsx)(e.code,{children:"裁剪坐标系坐标"}),"，包含 X, Y, Z，W 四个坐标分量，顶点着色器接收到这个坐标之后，对它进行透视除法，即将各个分量同时除以 W，转换成 ",(0,i.jsx)(e.code,{children:"NDC 坐标"}),"，NDC 坐标每个分量的取值范围都在【-1, 1】之间，GPU 获取这个属性值作为顶点的最终位置进行绘制。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"gl_FragColor：片元（像素）颜色，包含 R, G, B, A 四个颜色分量，且每个分量的取值范围在【0,1】之间，GPU 获取这个值作为像素的最终颜色进行着色。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["gl_PointSize：绘制到屏幕的点的大小，需要注意的是，gl_PointSize只有在绘制图元是",(0,i.jsx)(e.code,{children:"点"}),"的时候才会生效。当我们绘制线段或者三角形的时候，gl_PointSize是不起作用的。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["vec4：包含四个浮点元素的",(0,i.jsx)(e.code,{children:"容器类型"}),"，vec 是 vector（向量）的单词简写，vec4 代表包含 4 个浮点数的向量。此外，还有 ",(0,i.jsx)(e.code,{children:"vec2"}),"、",(0,i.jsx)(e.code,{children:"vec3"})," 等类型，代表包含",(0,i.jsx)(e.code,{children:"2个"}),"或者",(0,i.jsx)(e.code,{children:"3个"}),"浮点数的容器。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"GLSL 中 gl_Position 所接收的坐标所在坐标系是裁剪坐标系 ，不同于我们的浏览器窗口坐标系。所以当我们赋予 gl_Position 位置信息的时候，需要对其进行转换才能正确显示。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["gl_FragColor，属于 GLSL 内置属性，用来设置片元颜色，包含 4 个分量 (R, G, B, A)，各个颜色分量的取值范围是【0，1】，也不同于我们常规颜色的【0，255】取值范围，所以当我们给 gl_FragColor 赋值时，也需要对其进行转换。平常我们所采用的颜色值（R, G, B, A），对应的转换公式为： (R值/255，G值/255，B值/255，A值/1）。拿红色举例，在CSS中，红色用 ",(0,i.jsx)(e.code,{children:"RGBA"})," 形式表示是（255，0，0，1），那么转换成 GLSL 形式就是(255 / 255, 0 / 255, 0 / 255, 1 / 1)，转换后的值为（1.0, 0.0, 0.0, 1.0)。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsxs)(e.p,{children:["注意，GLSL 是强类型语言，定义变量时，数据类型和值一定要匹配正确，比如我们给浮点数 a 赋值 1，我们需要这样写：",(0,i.jsx)(e.code,{children:"float a = 1.0;"})," 如果用 ",(0,i.jsx)(e.code,{children:"float a = 1;"})," 的话会报错。"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"至此，着色器源码部分编写好了，那么着色器源码该如何使用呢？"}),"\n",(0,i.jsxs)(e.p,{children:["着色器源码本质是字符串，所以我们既可以把着色器源码存储在 JavaScript 变量里，也可以放在 script  标签里，甚至存储在数据库中并通过 ajax 请求获取。之后的章节，为了使用方便，我们把着色器源码放在 ",(0,i.jsx)(e.code,{children:"script"})," 标签中。"]}),"\n",(0,i.jsxs)(e.h3,{id:"2准备-html-文件",children:["2、准备 HTML 文件",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2准备-html-文件",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["HTML 文件至少需要包含一个 ",(0,i.jsx)(e.code,{children:"canvas"})," 标签，另外需要两个存储",(0,i.jsx)(e.code,{children:"着色器源码"}),"的 script 标签。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<body>\n	\x3c!-- 顶点着色器源码 --\x3e\n	<script type="shader-source" id="vertexShader">\n	 void main(){\n  		//声明顶点位置\n  		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n  		//声明要绘制的点的大小。\n  		gl_PointSize = 10.0;\n  	}\n	<\/script>\n	\n	\x3c!-- 片元着色器源码 --\x3e\n	<script type="shader-source" id="fragmentShader">\n	 void main(){\n	 	//设置像素颜色为红色\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); \n	}\n	<\/script>\n	\n	<canvas id="canvas"></canvas>\n</body>\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"3javascript-程序",children:["3、JavaScript 程序",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3javascript-程序",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"准备好了 HTML 文件，我们接着编写 JavaScript 部分。"}),"\n",(0,i.jsx)(e.p,{children:"首先，获取 WebGL 绘图环境："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"var canvas = document.querySelector('#canvas');\nvar gl = canvas.getContext('webgl') || canvas.getContext(\"experimental-webgl\");\n"})}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"在某些浏览器中，我们还需要做下兼容处理，加上实验前缀。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"创建顶点着色器对象："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// 获取顶点着色器源码\nvar vertexShaderSource = document.querySelector('#vertexShader').innerHTML;\n// 创建顶点着色器对象\nvar vertexShader = gl.createShader(gl.VERTEX_SHADER);\n// 将源码分配给顶点着色器对象\ngl.shaderSource(vertexShader, vertexShaderSource);\n// 编译顶点着色器程序\ngl.compileShader(vertexShader);\n"})}),"\n",(0,i.jsxs)(e.p,{children:["接下来，创建片元着色器，该过程和顶点着色器的创建过程类似，区别在于",(0,i.jsx)(e.code,{children:"着色器源码"}),"和",(0,i.jsx)(e.code,{children:"着色器类型"}),"。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// 获取片元着色器源码\nvar fragmentShaderSource = document.querySelector('#fragmentShader').innerHTML;\n// 创建片元着色器程序\nvar fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n// 将源码分配给片元着色器对象\ngl.shaderSource(fragmentShader, fragmentShaderSource);\n// 编译片元着色器\ngl.compileShader(fragmentShader);\n"})}),"\n",(0,i.jsx)(e.p,{children:"着色器对象创建完毕，接下来我们开始创建着色器程序"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"//创建着色器程序\nvar program = gl.createProgram();\n//将顶点着色器挂载在着色器程序上。\ngl.attachShader(program, vertexShader); \n//将片元着色器挂载在着色器程序上。\ngl.attachShader(program, fragmentShader);\n//链接着色器程序\ngl.linkProgram(program);\n"})}),"\n",(0,i.jsx)(e.p,{children:"有时候一个 WebGL 应用包含多个 program，所以在使用某个 program 绘制之前，我们要先启用它。"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"// 使用刚创建好的着色器程序。\ngl.useProgram(program);\n"})}),"\n",(0,i.jsx)(e.p,{children:"准备工作做好了，接下来开始绘制："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"//设置清空画布颜色为黑色。\ngl.clearColor(0.0, 0.0, 0.0, 1.0);\n\n//用上一步设置的清空画布颜色清空画布。\ngl.clear(gl.COLOR_BUFFER_BIT);\n\n//绘制点。\ngl.drawArrays(gl.POINTS, 0, 1);\n"})}),"\n",(0,i.jsxs)(e.p,{children:["gl.drawArrays 的语法简单介绍如下，详细介绍参见",(0,i.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/drawArrays",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"。"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"void gl.drawArrays(mode, first, count);"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["参数：","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"mode，代表图元类型。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"first，代表从第几个点开始绘制。"}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"count，代表绘制的点的数量。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"gl.drawArrays"})," 是执行绘制的 API，上面示例中的第一个参数 ",(0,i.jsx)(e.code,{children:"gl.POINTS"})," 代表我们要绘制的是",(0,i.jsx)(e.code,{children:"点图元"}),"，第二个参数代表要绘制的顶点的起始位置，第三个参数代表顶点绘制个数。"]}),"\n",(0,i.jsx)(e.p,{children:"至此，着色器部分和 JavaScript 程序都写完了，运行看下效果："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,UklGRuQBAABXRUJQVlA4INgBAADwLACdASpUAiQBPp1OpE4lpCOiIF24ALATiWlu4XdhHOICwAAAdhRJjTS2i4QZBDVUmu20XCDIIaqk122i4QZBDVUmu20XCDIIaqk122i4QZBDVUmu20XCDIIaqk122i4QZBDVUmu20XCDIIaqk122i4QZBDVUmu20XCDIIaqk122i4QZBDVUmu20XCDIIaqk122i4QZBDVUmu20XCDIIaqk122i4QZBDVUmu20XCDIIaqj8FwCI6s6AotzJkENVSa7bRcIMghqqTXQD8V4sLwr7dZvXCDIIaqk122i4QZBDVUxwFaKuEGQQ1VJrttFwgyCGqpNdtouEGQQ1VJrttFwgyCGqpNdtouEGQQ1VJrttFwgyCGqpNdtouEGQQ1VJrttFwgyCGqpNdtouEGQQ1VJrttFwgyCGqpNdtouEGQQ1VJrttFwgyCGqpNdtouEGQQ1VJrttFwgyCGqpNdtouEGQQ1VJrttFwgyCGqpNdpgAD++2UAAAAAAAAAAAOvNJNEw98g8/+z/cb9f8iVNe1STe1X6UnYZnUoiRgK/+G8fBl+v+AADnf31Mwf8Lx+/n/nAT6AWCmAoufDijg4eeMuEKkAVNt/T/n/T8D8AAAAAAAAAAAAAAAA",alt:""})}),"\n",(0,i.jsxs)(e.p,{children:["上面这些代码实现了点的绘制。大家应该发现了，在 ",(0,i.jsx)(e.code,{children:"gl.drawArrays"})," 方法之前有很多重复的代码，这些重复代码是我们实现每个 WebGL 应用都要编写的，为了避免重复工作，我们把这些代码封装一下，封装出的函数库放在 webgl-helper.js 文件中，优化过后的代码如下："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"//获取canvas\nvar canvas = getCanvas(id);\n\n//获取webgl绘图环境\nvar gl = getWebGLContext(canvas);\n\n//创建顶点着色器\nvar vertexShader = createShaderFromScript(gl, gl.VERTEX_SHADER,'vertexShader');\n//创建片元着色器\nvar fragmentShader = createShaderFromScript(gl, gl.FRAGMENT_SHADER,'fragmentShader');\n\n//创建着色器程序\nvar program = createProgram(gl ,vertexShader, fragmentShader);\n//告诉 WebGL 运行哪个着色器程序\ngl.useProgram(program);\n\n//设置清空画布颜色为黑色。\ngl.clearColor(0.0, 0.0, 0.0, 1.0);\n//用上一步设置的清空画布颜色清空画布。\ngl.clear(gl.COLOR_BUFFER_BIT);\n//绘制点\ngl.drawArrays(gl.POINTS, 0, 1);\n"})}),"\n",(0,i.jsx)(e.p,{children:"九行代码就实现了绘制点的程序，是不是简洁了很多？"}),"\n",(0,i.jsxs)(e.h2,{id:"点的动态绘制",children:["点的动态绘制",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#点的动态绘制",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"上例只是实现了一个静态点的绘制，但是真正的 WebGL 应用总是需要通过网页和用户进行交互，进而改变画面的。所以接下来，我们要实现一个简单交互程序：在鼠标点击过的位置绘制一个点，而且这个点的颜色是随机的。"}),"\n",(0,i.jsx)(e.p,{children:"这要求我们有能力通过 JavaScript 往着色器程序中传入顶点位置和颜色数据，从而改变点的位置和颜色。"}),"\n",(0,i.jsxs)(e.h3,{id:"着色器程序",children:["着色器程序",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#着色器程序",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"我们修改一下着色器程序，修改后的着色器程序要能够接收 JavaScript 传递过来的数据："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"顶点着色器"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-glsl",children:"//设置浮点数精度为中等精度\nprecision mediump float;\n//接收点在 canvas 坐标系上的坐标 (x, y)\nattribute vec2 a_Position;\n//接收 canvas 的宽高尺寸\nattribute vec2 a_Screen_Size;\nvoid main(){\n    //start 将屏幕坐标系转化为裁剪坐标（裁剪坐标系）\n   vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0; \n   position = position * vec2(1.0, -1.0);\n   gl_Position = vec4(position, 0, 1);\n   //end 将屏幕坐标系转化为裁剪坐标（裁剪坐标系）\n   //声明要绘制的点的大小。\n   gl_PointSize = 10.0;\n}\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"片元着色器"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-glsl",children:"//设置浮点数精度为中等精度\nprecision mediump float;\n//接收 JavaScript 传过来的颜色值（RGBA）。\nuniform vec4 u_Color;\nvoid main(){\n    //将普通的颜色表示转化为 WebGL 需要的表示方式，即将【0-255】转化到【0,1】之间。\n   vec4 color = u_Color / vec4(255, 255, 255, 1);\n   gl_FragColor = color; \n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["这次的着色器和上例中的着色器有很大不同，大家可以发现，顶点着色器中在给 ",(0,i.jsx)(e.code,{children:"gl_Position"})," 赋值之前，进行了一系列运算。片元着色器中给 ",(0,i.jsx)(e.code,{children:"gl_FragColor"})," 赋值之前，也进行了一系列运算。代码注释大家应该能看懂，我简单讲一下："]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"顶点着色器"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["我们在顶点着色器中定义两个 attribute 变量： ",(0,i.jsx)(e.code,{children:"a_Position"})," 和 ",(0,i.jsx)(e.code,{children:"a_Screen_Size"}),"，a_Position 接收 ",(0,i.jsx)(e.code,{children:"canvas 坐标系"}),"下的点击坐标。",(0,i.jsx)(e.br,{}),"\n",(0,i.jsx)(e.code,{children:"vec2"})," 代表存储两个浮点数变量的容器，因本节不涉及",(0,i.jsx)(e.code,{children:"深度计算"}),"，所以我们只接收顶点的 x 和 y 坐标。",(0,i.jsx)(e.br,{}),"\n","a_Screen_Size 变量用来接收 JavaScript 传递过来的 canvas 的宽高尺寸。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-glsl",children:"vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0\n"})}),"\n",(0,i.jsxs)(e.p,{children:["上面这句代码用来将浏览器窗口坐标转换成裁剪坐标，之后通过透视除法，除以 w 值（此处为 1 ）转变成设备坐标（NDC坐标系）。这个算法首先将(x,y) 转化到【0, 1】区间，再将 【0, 1】之间的值乘以 2 转化到 【0, 2】区间，之后再减去 1 ，转化到 【-1, 1】之间的值，即 ",(0,i.jsx)(e.code,{children:"NDC 坐标"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:"事实上，这是我们第一次接触坐标系变换: 从 Canvas 坐标系转变到 NDC 坐标系（即设备坐标系），这个变换比较简单，我们用基本运算就可以实现。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"在中级进阶阶段，我会给大家介绍一种更通用的转换方法：矩阵变换。"}),"\n"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"片元着色器"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["片元着色器定义了一个",(0,i.jsx)(e.code,{children:"全局变量"})," (被 uniform 修饰的变量) ，用来接收 JavaScript 传递过来的随机颜色。"]}),"\n",(0,i.jsx)(e.p,{children:"大家应该注意到了，到目前为止，我们定义变量采用过两种形式，一种是通过 attribute 修饰，一种是通过 uniform 修饰。同样都是用来接收 JavaScript 传递过来的信息，它们有什么区别呢？"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["attribue 变量：只能在",(0,i.jsx)(e.code,{children:"顶点着色器"}),"中定义。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["uniform 变量：既可以在",(0,i.jsx)(e.code,{children:"顶点着色器"}),"中定义，也可以在",(0,i.jsx)(e.code,{children:"片元着色器中"}),"定义。"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:["最后一种变量类型 ",(0,i.jsx)(e.code,{children:"varing"})," 变量：它用来从",(0,i.jsx)(e.code,{children:"顶点着色器"}),"中往",(0,i.jsx)(e.code,{children:"片元着色器"}),"传递数据。使用它我们可以在顶点着色器中声明一个变量并对其赋值，经过插值处理后，在片元着色器中取出插值后的值来使用。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"html-部分",children:["HTML 部分",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#html-部分",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-html",children:'<script type="shader-source" id="vertexShader">\n    precision mediump float;\n	//接收点在 canvas 坐标系上的坐标 (x, y)\n    attribute vec2 a_Position;\n	//接收 canvas 窗口尺寸(width, height)\n    attribute vec2 a_Screen_Size;\n    void main(){\n	    //将屏幕坐标系转化为 GLSL 限定的坐标值（NDC坐标系）\n   	    vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0; \n   	    position = position * vec2(1.0, -1.0);\n   	    gl_Position = vec4(position, 0, 1);\n   	    //声明要绘制的点的大小。\n   	    gl_PointSize = 10.0;\n    }  \n <\/script>\n\n  \x3c!-- 片元着色器源码 --\x3e\n  <script type="shader-source" id="fragmentShader">\n    precision mediump float;\n    //接收 JavaScript 传过来的颜色值（rgba）。\n    uniform vec4 u_Color;\n    void main(){\n   	    vec4 color = u_Color / vec4(255, 255, 255, 1);\n   	    gl_FragColor = color; \n    }\n   <\/script>\n\n  <canvas id="canvas"></canvas>\n\n'})}),"\n",(0,i.jsxs)(e.h3,{id:"javascript-程序",children:["JavaScript 程序",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-程序",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"JavaScript 部分的实现与静态点的绘制大致相同，只是增加了为着色器中变量进行赋值的代码。"}),"\n",(0,i.jsx)(e.p,{children:"动态绘制点的逻辑是："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["声明一个数组变量 ",(0,i.jsx)(e.code,{children:"points"}),"，存储点击位置的坐标。"]}),"\n",(0,i.jsx)(e.li,{children:"绑定 canvas 的点击事件。"}),"\n",(0,i.jsxs)(e.li,{children:["触发点击操作时，把点击坐标添加到数组     ",(0,i.jsx)(e.code,{children:"points"})," 中。"]}),"\n",(0,i.jsxs)(e.li,{children:["遍历每个点执行 ",(0,i.jsx)(e.code,{children:"drawArrays(gl.Points, 0, 1)"})," 绘制操作。"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-javascript",children:"...省略着色器创建部分。\n//找到顶点着色器中的变量a_Position\nvar a_Position = gl.getAttribLocation(program, 'a_Position');\n//找到顶点着色器中的变量a_Screen_Size\nvar a_Screen_Size = gl.getAttribLocation(program, 'a_Screen_Size');\n//找到片元着色器中的变量u_Color\nvar u_Color = gl.getUniformLocation(program, 'u_Color');\n//为顶点着色器中的 a_Screen_Size 传递 canvas 的宽高信息\ngl.vertexAttrib2f(a_Screen_Size, canvas.width, canvas.height);\n//存储点击位置的数组。\nvar points = [];\ncanvas.addEventListener('click', e => {\n   var x = e.pageX;\n   var y = e.pageY;\n   var color = randomColor();\n   points.push({ x: x, y: y, color: color })\n   gl.clearColor(0, 0, 0, 1.0);\n   //用上一步设置的清空画布颜色清空画布。\n  	gl.clear(gl.COLOR_BUFFER_BIT);\n   for (let i = 0; i < points.length; i++) {\n     var color = points[i].color;\n     //为片元着色器中的 u_Color 传递随机颜色\n     gl.uniform4f(u_Color, color.r, color.g, color.b, color.a);\n     //为顶点着色器中的 a_Position 传递顶点坐标。\n     gl.vertexAttrib2f(a_Position, points[i].x, points[i].y);\n     //绘制点\n     gl.drawArrays(gl.POINTS, 0, 1);\n   }\n })\n // 设置清屏颜色\n gl.clearColor(0, 0, 0, 1.0);\n // 用上一步设置的清空画布颜色清空画布。\n gl.clear(gl.COLOR_BUFFER_BIT);\n\n"})}),"\n",(0,i.jsx)(e.p,{children:"至此，我们实现了在 canvas 上进行点击，在点击位置处绘制一个随机颜色的点的程序。"}),"\n",(0,i.jsxs)(e.h4,{id:"不足之处",children:["不足之处：",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#不足之处",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["本示例我们采用 ",(0,i.jsx)(e.code,{children:"gl.vertexAttrib2f "})," 直接给 a_Position 赋值，所以每绘制一个点，都要给着色器变量赋值一次，并且绘制一次，效率比较低。后面我们会介绍一种更快速的方式：利用缓冲区传递多个顶点数据。"]}),"\n",(0,i.jsxs)(e.h2,{id:"回顾",children:["回顾",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"本小节通过演示如何使用 WebGL 绘制一个动态位置、随机颜色的点，向大家介绍 WebGL 程序的组成要素，以及一些简单的 GLSL 语法。\n总结一下本节所学内容："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"GLSL"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"gl_Position： 内置变量，用来设置顶点坐标。"}),"\n",(0,i.jsx)(e.li,{children:"gl_PointSize： 内置变量，用来设置顶点大小。"}),"\n",(0,i.jsx)(e.li,{children:"vec2：2 维向量容器，可以存储 2 个浮点数。"}),"\n",(0,i.jsx)(e.li,{children:"gl_FragColor： 内置变量，用来设置像素颜色。"}),"\n",(0,i.jsx)(e.li,{children:"vec4：4 维向量容器，可以存储 4 个浮点数。"}),"\n",(0,i.jsx)(e.li,{children:"precision：精度设置限定符，使用此限定符设置完精度后，之后所有该数据类型都将沿用该精度，除非单独设置。"}),"\n",(0,i.jsxs)(e.li,{children:["运算符：向量的对应位置进行运算，得到一个新的向量。","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"vec * 浮点数： vec2(x, y) * 2.0 = vec(x * 2.0, y * 2.0)。"}),"\n",(0,i.jsx)(e.li,{children:"vec2 * vec2：vec2(x1, y1) * vec2(x2, y2) = vec2(x1 * x2, y1 * y2)。"}),"\n",(0,i.jsx)(e.li,{children:"加减乘除规则基本一致。但是要注意一点，如果参与运算的是两个 vec  向量，那么这两个 vec 的维数必须相同。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"JavaScript 程序如何连接着色器程序"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"createShader：创建着色器对象"}),"\n",(0,i.jsx)(e.li,{children:"shaderSource：提供着色器源码"}),"\n",(0,i.jsx)(e.li,{children:"compileShader：编译着色器对象"}),"\n",(0,i.jsx)(e.li,{children:"createProgram：创建着色器程序"}),"\n",(0,i.jsx)(e.li,{children:"attachShader：绑定着色器对象"}),"\n",(0,i.jsx)(e.li,{children:"linkProgram：链接着色器程序"}),"\n",(0,i.jsx)(e.li,{children:"useProgram：启用着色器程序"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"JavaScript 如何往着色器中传递数据"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["getAttribLocation：找到着色器中的 ",(0,i.jsx)(e.code,{children:"attribute 变量"}),"地址。"]}),"\n",(0,i.jsxs)(e.li,{children:["getUniformLocation：找到着色器中的 ",(0,i.jsx)(e.code,{children:"uniform 变量"}),"地址。"]}),"\n",(0,i.jsxs)(e.li,{children:["vertexAttrib2f：给 ",(0,i.jsx)(e.code,{children:"attribute 变量"}),"传递两个浮点数。"]}),"\n",(0,i.jsxs)(e.li,{children:["uniform4f：给",(0,i.jsx)(e.code,{children:"uniform变量"}),"传递四个浮点数。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"WebGL 绘制函数"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"drawArrays: 用指定的图元进行绘制。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsx)(e.p,{children:"WebGL 图元"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["gl.POINTS: 将绘制图元类型设置成",(0,i.jsx)(e.code,{children:"点图元"}),"。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["另外需要注意，本节例子的坐标系转换我们是在着色器阶段完成的，事实上，我们通常在 JavaScript 上计算出",(0,i.jsx)(e.code,{children:"转换矩阵"}),"，然后将",(0,i.jsx)(e.code,{children:"转换矩阵"}),"连同",(0,i.jsx)(e.code,{children:"顶点信息"}),"一并传递给着色器。大家可以尝试把这部分坐标转换算法移到 JavaScript 中试试，效果是一样的。"]}),"\n",(0,i.jsx)(e.p,{children:"好好消化一下本节内容，之后的章节仍然会用到这些知识。"}),"\n",(0,i.jsx)(e.p,{children:"接下来让我们进入下一环节，学习三角形图元的绘制吧~"})]})}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}let d=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F2.%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%20---%20%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%82%B9%E5%BC%80%E5%A7%8B%EF%BC%9A%E6%8E%8C%E6%8F%A1%20WebGL%20%E7%9A%84%E7%BC%96%E7%A8%8B%E8%A6%81%E7%B4%A0.md"]={toc:[{text:"目标",id:"目标",depth:2},{text:"编写第一个 WebGL 程序",id:"编写第一个-webgl-程序",depth:2},{text:"1、准备着色器源码",id:"1准备着色器源码",depth:3},{text:"2、准备 HTML 文件",id:"2准备-html-文件",depth:3},{text:"3、JavaScript 程序",id:"3javascript-程序",depth:3},{text:"点的动态绘制",id:"点的动态绘制",depth:2},{text:"着色器程序",id:"着色器程序",depth:3},{text:"HTML 部分",id:"html-部分",depth:3},{text:"JavaScript 程序",id:"javascript-程序",depth:3},{text:"不足之处：",id:"不足之处",depth:4},{text:"回顾",id:"回顾",depth:2}],title:"2.初级入门 --- 从一个点开始：掌握 WebGL 的编程要素",headingTitle:"2.初级入门 --- 从一个点开始：掌握 WebGL 的编程要素",frontmatter:{}}}}]);