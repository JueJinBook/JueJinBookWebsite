"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["44896"],{497490:function(e,n,t){t.r(n),t.d(n,{default:()=>h});var r=t(552676),l=t(740453);let c=t.p+"static/image/5471d49badc1365bfb09f5b45101936e.89168e4f.webp",a=t.p+"static/image/627ecbeb1fc066aa26994f0d0fa77283.85f8f963.webp",s=t.p+"static/image/d48ad8f3424c9a5f9b540315f8ad1cff.e006cf90.webp",o=t.p+"static/image/25cc525abc86997a0108231253ff94e5.4b5890c1.webp",d=t.p+"static/image/b51e8bfdfd94bfc438e9d546c1eedcf7.77cc5bd1.webp",i=t.p+"static/image/c6003b22b18830c84b2efcfc6f1b38cd.dfef2ca7.webp";function f(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",pre:"pre",img:"img",ol:"ol",li:"li"},(0,l.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"39-原理篇--svelte-5-运行时实现",children:["39-原理篇 ❘ Svelte 5 运行时实现",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#39-原理篇--svelte-5-运行时实现",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"推荐学习指数：⭐️️⭐️️"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"1-前言",children:["1. 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Svelte 5 之于 Svelte 4，并不是在 Svelte 4 上新增了一个符文功能，而是基于 Signals 的彻底重写。本篇我们讲讲 Svelte 5 编译后的代码运行原理。我们先从最基础的代码开始说起。"}),"\n",(0,r.jsxs)(n.h2,{id:"2-hello-world",children:["2. Hello World!",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-hello-world",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["最基础的代码莫过于 ",(0,r.jsx)(n.code,{children:'"Hello World!"'})," 了："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"<h1>Hello world!</h1>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["查看 ",(0,r.jsx)(n.a,{href:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEy3IMQqAMAwF0KvonwvuRQQ3b-AgDmpTKERT2lQQ8e4iOL53wwemDDvdOJadYNHHCAO94od8EivBIEtJ2zftWlTl6AZilmqUxK5umz9hsIsLPpCD1VTomZ8XwTP8TmMAAAA=",title:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEy3IMQqAMAwF0KvonwvuRQQ3b-AgDmpTKERT2lQQ8e4iOL53wwemDDvdOJadYNHHCAO94od8EivBIEtJ2zftWlTl6AZilmqUxK5umz9hsIsLPpCD1VTomZ8XwTP8TmMAAAA=",target:"_blank",rel:"noopener noreferrer",children:"REPL 生成的代码"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import * as $ from "svelte/internal/client";\n\nvar root = $.template(`<button>Hello World!</button>`);\n\nexport default function App($$anchor) {\n  var button = root();\n\n  $.append($$anchor, button);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$.template"}),"、",(0,r.jsx)(n.code,{children:"$.append"})," 到底做了什么呢？"]}),"\n",(0,r.jsxs)(n.p,{children:["从 ",(0,r.jsx)(n.code,{children:"svelte/internal/client"}),"这个导入文件目录对应 ",(0,r.jsx)(n.a,{href:"https://github.com/sveltejs/svelte/tree/main",title:"https://github.com/sveltejs/svelte/tree/main",target:"_blank",rel:"noopener noreferrer",children:"Svelte GitHub 源码"}),"，可以查找到 ",(0,r.jsx)(n.code,{children:"$"})," 的",(0,r.jsx)(n.a,{href:"https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/internal/client/index.js",title:"https://github.com/sveltejs/svelte/blob/main/packages/svelte/src/internal/client/index.js",target:"_blank",rel:"noopener noreferrer",children:"源码文件"}),"："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["作为汇总的导出函数文件，像 ",(0,r.jsx)(n.code,{children:"$.xxx"}),"这样的方法都可以在这个文件查找到对应的源码目录。"]}),"\n",(0,r.jsxs)(n.p,{children:["所以我们找到 ",(0,r.jsx)(n.code,{children:"$.template"}),"和 ",(0,r.jsx)(n.code,{children:"$.append"}),"的源码，然后写一个极简版的实现："]}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"index.html"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>svelte-under-the-hood</title>\n  </head>\n  <body>\n    <script src="./svelte5-1.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"svelte5-1.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const $ = {};\n\n$.template = template;\n$.append = append;\n\nfunction template(content, flags) {\n  var node;\n  return () => {\n    if (node === undefined) {\n      node = create_fragment_from_html(content);\n      node = node.firstChild;\n    }\n\n    var clone = node.cloneNode(true);\n    return clone;\n  };\n}\n\nfunction create_fragment_from_html(html) {\n  var elem = document.createElement("template");\n  elem.innerHTML = html;\n  return elem.content;\n}\n\nfunction append(anchor, dom) {\n  anchor.before(dom);\n}\n\nfunction mount(Component, { target, anchor }) {\n  var anchor_node = anchor ?? target.appendChild(document.createTextNode(""));\n  Component(anchor_node);\n}\n\n/**\n * 编译后的代码\n */\nvar root = $.template(`<button>Hello World!</button>`);\n\nfunction App($$anchor) {\n  var button = root();\n  $.append($$anchor, button);\n}\n\n/**\n * 挂载 DOM\n */\nmount(App, {\n  target: document.body,\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这段代码并不复杂，",(0,r.jsx)(n.code,{children:"$.template"}),"返回一个函数 ",(0,r.jsx)(n.code,{children:"root"}),"，",(0,r.jsx)(n.code,{children:"root()"})," 函数运行时会创建 DOM 节点，",(0,r.jsx)(n.code,{children:"$.append"}),"将其插入到 ",(0,r.jsx)(n.code,{children:"$$anchor"}),"前。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"3-加入变量",children:["3. 加入变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-加入变量",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在代码改为："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  let name = $state('World');\n<\/script>\n\n<button>Hello {name}!</button>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["查看 ",(0,r.jsx)(n.a,{href:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEz2LwQoCIRQAf8UewRYIezdb6LZ_0CE7bOtbEN6q6DMI8d9DiI4zzFTYHGEG9ajglx1BwS1GkMCf2CG_kRhBQg4lrd3ovCYXeTJeCEIW_RJXccy8MJ6Ge0hkh_PFeD3-S-P1qzAHP81IFETtUzvo8WdBwh6s2xxaUJwKtmf7Ajf-ANKaAAAA",title:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEz2LwQoCIRQAf8UewRYIezdb6LZ_0CE7bOtbEN6q6DMI8d9DiI4zzFTYHGEG9ajglx1BwS1GkMCf2CG_kRhBQg4lrd3ovCYXeTJeCEIW_RJXccy8MJ6Ge0hkh_PFeD3-S-P1qzAHP81IFETtUzvo8WdBwh6s2xxaUJwKtmf7Ajf-ANKaAAAA",target:"_blank",rel:"noopener noreferrer",children:"REPL 生成的代码"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'import * as $ from "svelte/internal/client";\n\nvar root = $.template(`<button> </button>`);\n\nexport default function App($$anchor) {\n  let name = \'World\';\n  var button = root();\n  var text = $.child(button);\n\n  $.reset(button);\n  $.template_effect(() => $.set_text(text, `Hello ${name ?? ""}!`));\n  $.append($$anchor, button);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["这次主要多了一个 ",(0,r.jsx)(n.code,{children:"$.template_effect"}),"函数，我们提供一个极简版的代码："]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"svelte.html"}),"，改下脚本引入地址，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<html>\n  <head>\n    <meta charset="utf-8" />\n    <title>svelte-under-the-hood</title>\n  </head>\n  <body>\n    <script src="./svelte5-2.js"><\/script>\n  </body>\n</html>\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"svelte5-2.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const $ = {};\n\n$.template = template;\n$.append = append;\n$.child = child;\n$.reset = reset;\n$.template_effect = template_effect;\n$.set_text = set_text;\n\nfunction template(content, flags) {\n  var node;\n  return () => {\n    if (node === undefined) {\n      node = create_fragment_from_html(content);\n      node = node.firstChild;\n    }\n\n    var clone = node.cloneNode(true);\n    return clone;\n  };\n}\n\nfunction create_fragment_from_html(html) {\n  var elem = document.createElement("template");\n  elem.innerHTML = html;\n  return elem.content;\n}\n\nfunction append(anchor, dom) {\n  anchor.before(dom);\n}\n\nfunction child(node) {\n  return node.firstChild;\n}\n\nlet hydrating = false;\nfunction reset(node) {\n  if (!hydrating) return;\n}\n\nconst RENDER_EFFECT = 1 << 3;\nconst ROOT_EFFECT = 1 << 6;\nconst DIRTY = 1 << 10;\n\nfunction template_effect(fn) {\n  return render_effect(fn);\n}\nfunction render_effect(fn) {\n  return create_effect(RENDER_EFFECT, fn, true);\n}\n\nlet component_context = null;\n\nfunction create_effect(type, fn, sync) {\n  var effect = {\n    ctx: component_context,\n    deps: null,\n    nodes_start: null,\n    nodes_end: null,\n    f: type | DIRTY,\n    first: null,\n    fn,\n    last: null,\n    next: null,\n    prev: null,\n    teardown: null,\n    transitions: null,\n    version: 0,\n  };\n\n  if (sync) {\n    update_effect(effect);\n  }\n\n  return effect;\n}\n\nfunction update_effect(effect) {\n  update_reaction(effect);\n}\n\nfunction update_reaction(reaction) {\n  var result = reaction.fn();\n  return result;\n}\n\nfunction set_text(text, value) {\n  if (value !== (text.__t ??= text.nodeValue)) {\n    text.__t = value;\n    text.nodeValue = value == null ? "" : value + "";\n  }\n}\n\nfunction mount(Component, { target, anchor }) {\n  var anchor_node = anchor ?? target.appendChild(document.createTextNode(""));\n  Component(anchor_node);\n}\n\n/**\n * 编译后的代码\n */\nvar root = $.template(`<button> </button>`);\n\nfunction App($$anchor) {\n  let name = "World";\n  var button = root();\n  var text = $.child(button);\n\n  $.reset(button);\n  $.template_effect(() => $.set_text(text, `Hello ${name ?? ""}!`));\n  $.append($$anchor, button);\n}\n\n/**\n * 挂载 DOM\n */\nmount(App, {\n  target: document.body,\n});\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"$.template_effect"}),"创建了一个 effect 对象，effect 对象会保存 ",(0,r.jsx)(n.code,{children:"effect"}),"函数以及各种信息。"]}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"4-更新变量",children:["4. 更新变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-更新变量",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在我们将代码改为："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  let name = $state('World');\n  function update() {\n    name = 'Svelte';\n  }\n\n  setTimeout(update, 1000)\n<\/script>\n<button>Hello {name}</button>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["查看 ",(0,r.jsx)(n.a,{href:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEz2NwQrCMAyGX6UEoRsMNq-zCt68K3iwHuaWQaFrS5sKUvru0jk8hXx_vj8JZqUxQP9IYIYFoYezc9AAfVxZwhs1ITQQbPRjISKMXjk6SSNJI7FisSPbBRoIK363Xk-8PpR4jmYkZQ2LbiphzVLBkjaHX9d2vh5nacoISDe1oI1U_ayG7buuq6UR7f-zeEUia04X1NqyVOqyaDcIDSx2UrPCCXryEfMzfwGGUpqX5wAAAA==",title:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEz2NwQrCMAyGX6UEoRsMNq-zCt68K3iwHuaWQaFrS5sKUvru0jk8hXx_vj8JZqUxQP9IYIYFoYezc9AAfVxZwhs1ITQQbPRjISKMXjk6SSNJI7FisSPbBRoIK363Xk-8PpR4jmYkZQ2LbiphzVLBkjaHX9d2vh5nacoISDe1oI1U_ayG7buuq6UR7f-zeEUia04X1NqyVOqyaDcIDSx2UrPCCXryEfMzfwGGUpqX5wAAAA==",target:"_blank",rel:"noopener noreferrer",children:"REPL 生成的代码"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import * as $ from \"svelte/internal/client\";\n\nvar root = $.template(`<button> </button>`);\n\nexport default function App($$anchor) {\n  let name = $.state('World');\n\n  function update() {\n    $.set(name, 'Svelte');\n  }\n\n  setTimeout(update, 1000);\n\n  var button = root();\n  var text = $.child(button);\n\n  $.reset(button);\n  $.template_effect(() => $.set_text(text, `Hello ${$.get(name) ?? \"\"}`));\n  $.append($$anchor, button);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"这里就涉及 Signals 和 Effect 的代码了。为了方便大家快速理解，依然提供一个极简版的实现："}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"svelte5-3.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const $ = {};\n\n$.template = template;\n$.append = append;\n$.child = child;\n$.reset = reset;\n$.template_effect = template_effect;\n$.set_text = set_text;\n$.state = state;\n$.get = get;\n$.set = set;\n\nfunction state(v) {\n  return {\n    f: 0,\n    v,\n    reactions: null,\n    equals: (value) => value === this.v,\n    version: 0,\n  };\n}\n\nfunction template(content, flags) {\n  var node;\n  return () => {\n    if (node === undefined) {\n      node = create_fragment_from_html(content);\n      node = node.firstChild;\n    }\n\n    var clone = node.cloneNode(true);\n    return clone;\n  };\n}\n\nfunction create_fragment_from_html(html) {\n  var elem = document.createElement("template");\n  elem.innerHTML = html;\n  return elem.content;\n}\n\nfunction append(anchor, dom) {\n  anchor.before(dom);\n}\n\nfunction child(node) {\n  return node.firstChild;\n}\n\nlet hydrating = false;\nfunction reset(node) {\n  if (!hydrating) return;\n}\n\nconst RENDER_EFFECT = 1 << 3;\nconst ROOT_EFFECT = 1 << 6;\nconst DIRTY = 1 << 10;\n\nfunction template_effect(fn) {\n  return render_effect(fn);\n}\nfunction render_effect(fn) {\n  return create_effect(RENDER_EFFECT, fn, true);\n}\n\nlet component_context = null;\nlet active_effect = null;\nfunction create_effect(type, fn, sync, push = true) {\n  var effect = {\n    ctx: component_context,\n    deps: null,\n    nodes_start: null,\n    nodes_end: null,\n    f: type | DIRTY,\n    first: null,\n    fn,\n    last: null,\n    next: null,\n    prev: null,\n    teardown: null,\n    transitions: null,\n    version: 0,\n  };\n\n  if (sync) {\n    update_effect(effect);\n  }\n\n  return effect;\n}\n\nfunction update_effect(effect) {\n  update_reaction(effect);\n}\n\nlet new_deps = null;\n\nfunction update_reaction(reaction) {\n  new_deps = null;\n\n  // 这个函数会触发 get 函数，从而触发 new_deps 的赋值\n  var result = reaction.fn();\n  var deps = reaction.deps;\n\n  if (new_deps !== null) {\n    if (deps == null) {\n      reaction.deps = deps = new_deps;\n    }\n\n    // 这里建立了 signals 和 effect 的依赖关系\n    for (var i = 0; i < deps.length; i++) {\n      (deps[i].reactions ??= []).push(reaction);\n    }\n  }\n\n  return result;\n}\n\nfunction set_text(text, value) {\n  if (value !== (text.__t ??= text.nodeValue)) {\n    text.__t = value;\n    text.nodeValue = value == null ? "" : value + "";\n  }\n}\n\nconst all_registered_events = new Set();\nconst root_event_handles = new Set();\n\nfunction get(signal) {\n  if (new_deps === null) {\n    new_deps = [signal];\n  }\n  return signal.v;\n}\n\nfunction set(source, value) {\n  if (!source.equals(value)) {\n    source.v = value;\n    mark_reactions(source, DIRTY);\n  }\n\n  return value;\n}\n\nfunction mark_reactions(signal, status) {\n  signal.f |= status;\n  var reactions = signal.reactions;\n  if (reactions === null) return;\n\n  for (var i = 0; i < reactions.length; i++) {\n    var reaction = reactions[i];\n    schedule_effect(reaction);\n  }\n}\n\nlet queued_root_effects = [];\nfunction schedule_effect(signal) {\n  queueMicrotask(process_deferred);\n  var effect = signal;\n  queued_root_effects.push(effect);\n}\n\nfunction process_deferred() {\n  const previous_queued_root_effects = queued_root_effects;\n  queued_root_effects = [];\n  flush_queued_root_effects(previous_queued_root_effects);\n}\n\nfunction flush_queued_root_effects(root_effects) {\n  var length = root_effects.length;\n  if (length === 0) {\n    return;\n  }\n\n  for (var i = 0; i < length; i++) {\n    var effect = root_effects[i];\n    process_effects(effect);\n  }\n}\n\nfunction process_effects(effect) {\n  update_effect(effect);\n}\n\nfunction mount(Component, { target, anchor }) {\n  var anchor_node = anchor ?? target.appendChild(document.createTextNode(""));\n  Component(anchor_node);\n}\n\n// 编译后代码：\n\nvar root = $.template(`<button> </button>`);\n\nfunction App($$anchor) {\n  let name = $.state("World");\n\n  function update() {\n    $.set(name, "Svelte");\n  }\n\n  setTimeout(update, 1000);\n\n  var button = root();\n  var text = $.child(button);\n\n  $.reset(button);\n  $.template_effect(() => $.set_text(text, `Hello ${$.get(name) ?? ""}`));\n  $.append($$anchor, button);\n}\n\nmount(App, {\n  target: document.body,\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"页面刷新后，1s 后更改了 DOM 内容。"}),"\n",(0,r.jsxs)(n.p,{children:["在这段代码中，当我们使用 ",(0,r.jsx)(n.code,{children:"$.state()"}),"的时候，就会创建一个 Signal，在 Svelte 中，它本质是一个这样的对象（查看 ",(0,r.jsx)(n.code,{children:"state"})," 函数）："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{\n  f: 0,\n  v,\n  reactions: null,\n  equals: (value) => value === this.v,\n  version: 0,\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其中 ",(0,r.jsx)(n.code,{children:"f"})," 是 ",(0,r.jsx)(n.code,{children:"flags"})," 的缩写，依然采用了位掩码来标记 Signals 的状态。",(0,r.jsx)(n.code,{children:"v"}),"是 ",(0,r.jsx)(n.code,{children:"value"}),"的缩写，表示 Signal 的值，",(0,r.jsx)(n.code,{children:"reactions"})," 表示副作用，当 Signals 的值发生修改时，会执行这些 reactions。"]}),"\n",(0,r.jsxs)(n.p,{children:["而在 Svelte 中，effect 本质是这样一个对象（查看 ",(0,r.jsx)(n.code,{children:"create_effect"}),"函数）："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"var effect = {\n  ctx: component_context,\n  deps: null,\n  nodes_start: null,\n  nodes_end: null,\n  f: type | DIRTY,\n  first: null,\n  fn,\n  last: null,\n  next: null,\n  prev: null,\n  teardown: null,\n  transitions: null,\n  version: 0,\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其中 ",(0,r.jsx)(n.code,{children:"f"}),"是 ",(0,r.jsx)(n.code,{children:"flags"}),"的缩写，也是位掩码形式。",(0,r.jsx)(n.code,{children:"fn"}),"是具体执行的函数，",(0,r.jsx)(n.code,{children:"deps"})," 是依赖的 Signals，是一个数组形式。"]}),"\n",(0,r.jsxs)(n.p,{children:["当运行 ",(0,r.jsx)(n.code,{children:"template_effect"}),"的时候，会调用 ",(0,r.jsx)(n.code,{children:"create_effect"}),"创建 effect，在调用 ",(0,r.jsx)(n.code,{children:"update_reaction"}),"的时候："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function update_reaction(reaction) {\n  new_deps = null;\n\n  // 这个函数会触发 get 函数，从而触发 new_deps 的赋值\n  var result = reaction.fn();\n  var deps = reaction.deps;\n\n  if (new_deps !== null) {\n    if (deps == null) {\n      reaction.deps = deps = new_deps;\n    }\n\n    // 这里建立了 signals 和 effect 的依赖关系\n    for (var i = 0; i < deps.length; i++) {\n      (deps[i].reactions ??= []).push(reaction);\n    }\n  }\n\n  return result;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["执行 ",(0,r.jsx)(n.code,{children:"reaction.fn()"}),"即调用 ",(0,r.jsx)(n.code,{children:"$.set_text(text,"}),'Hello {.get(name) ?? ""}',(0,r.jsx)(n.code,{children:")"}),"，此时会触发 ",(0,r.jsx)(n.code,{children:"$.get"}),"，此时会触发 reaction 对应 Signals 的收集，也就是 ",(0,r.jsx)(n.code,{children:"new_deps"}),"这个数组。"]}),"\n",(0,r.jsxs)(n.p,{children:["当 ",(0,r.jsx)(n.code,{children:"reaction.fn()"}),"执行完毕后，我们会将 ",(0,r.jsx)(n.code,{children:"new_deps"}),"赋值到 ",(0,r.jsx)(n.code,{children:"reaction.deps"}),"中。然后我们遍历 ",(0,r.jsx)(n.code,{children:"reaction.deps"}),"再将 reaction 添加到这些 Signals 的 reactions 中，这样我们就建立了一个 signals 和 effect 之间的循环依赖："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"当然我们的目的并不是要建立循环依赖，只是要知道用到 Signals 的 Reactions 有哪些，Reactions 依赖的 Signals 有哪些。"}),"\n",(0,r.jsxs)(n.p,{children:["当 1s 后调用 ",(0,r.jsx)(n.code,{children:"update"})," 函数的时候，会调用："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'$.set(name, "Svelte");\n'})}),"\n",(0,r.jsxs)(n.p,{children:["name 就是 ",(0,r.jsx)(n.code,{children:"Signals"}),"，Svelte 会标记该 Signals 为 dirty，并且会调用该 Signals 对应的 Reactions。但 Svelte 并不会直接执行，而是调用了 ",(0,r.jsx)(n.code,{children:"schedule_effect"}),"，在该函数中："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function schedule_effect(signal) {\n  queueMicrotask(process_deferred);\n  var effect = signal;\n  queued_root_effects.push(effect);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["关键在于 ",(0,r.jsx)(n.code,{children:"queueMicrotask(process_deferred)"}),"，",(0,r.jsx)(n.code,{children:"queueMicrotask"})," 是 JavaScript 提供的使用微任务的 API。"]}),"\n",(0,r.jsxs)(n.p,{children:["再看 ",(0,r.jsx)(n.code,{children:"process_deferred"}),"函数，最终会调用 ",(0,r.jsx)(n.code,{children:"update_reaction"}),"，在 ",(0,r.jsx)(n.code,{children:"update_reaction"})," 函数中，我们会执行 ",(0,r.jsx)(n.code,{children:"reaction.fn()"}),"，也就是 ",(0,r.jsx)(n.code,{children:"$.set_text(text,"}),'Hello {.get(name) ?? ""}',(0,r.jsx)(n.code,{children:")"}),"，此时调用 ",(0,r.jsx)(n.code,{children:"$.get"}),"会获取到最新的值，也就是 ",(0,r.jsx)(n.code,{children:"Svelte"}),"，所以成功更新 DOM。"]}),"\n",(0,r.jsxs)(n.h2,{id:"5-绑定事件",children:["5. 绑定事件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-绑定事件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在我们加入事件，将代码改为："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"<script>\n  let name = $state('World');\n  function update() {\n    name = 'Svelte';\n  }\n<\/script>\n<button onclick={update}>Hello {name}</button>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["查看 ",(0,r.jsx)(n.a,{href:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEz2MwQrCMBBEfyUsQiwUeq9pwZt3Dx6sh5psIZgmIdkIEvLvklY8zsybl2HRBiP09wx2XhF6OHsPLdDH1xDfaAihhehSkLURUQbtaZzsRAaJ1Rcb2CHSTHjkNxeM4s2pzkuykrSzLHlVx4blWk_0-_DrZucbXCYrur9bPBORs8xZabR8DXlXlPGCxjiWq6GIbqdGaGF1Si8aFfQUEpZH-QIEI7Uk2gAAAA==",title:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAEz2MwQrCMBBEfyUsQiwUeq9pwZt3Dx6sh5psIZgmIdkIEvLvklY8zsybl2HRBiP09wx2XhF6OHsPLdDH1xDfaAihhehSkLURUQbtaZzsRAaJ1Rcb2CHSTHjkNxeM4s2pzkuykrSzLHlVx4blWk_0-_DrZucbXCYrur9bPBORs8xZabR8DXlXlPGCxjiWq6GIbqdGaGF1Si8aFfQUEpZH-QIEI7Uk2gAAAA==",target:"_blank",rel:"noopener noreferrer",children:"REPL 生成的代码"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import * as $ from "svelte/internal/client";\n\nfunction update(_, name) {\n  $.set(name, \'Svelte\');\n}\n\nvar root = $.template(`<button> </button>`);\n\nexport default function App($$anchor) {\n  let name = $.state(\'World\');\n  var button = root();\n\n  button.__click = [update, name];\n\n  var text = $.child(button);\n\n  $.reset(button);\n  $.template_effect(() => $.set_text(text, `Hello ${$.get(name) ?? ""}`));\n  $.append($$anchor, button);\n}\n\n$.delegate(["click"]);\n'})}),"\n",(0,r.jsx)(n.p,{children:"这个事件注册看起来有些奇怪，我们在 《Svelte5 | Snippets、事件处理程序以及其他更新》篇讲到："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["如果要为元素添加事件，不要使用 addEventListener，而是使用 Svelte 提供的 ",(0,r.jsx)(n.code,{children:"on"}),"事件："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { on } from 'svelte/events';\n\nconst off = on(element, 'click', () => {\n  console.log('element was clicked');\n});\n\n// 如果需要删除的话\noff();\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["这是因为当我们使用 ",(0,r.jsx)(n.code,{children:"onclick"}),"的时候，其实并没有为元素本身创建事件处理程序，而是为了提升性能在根 DOM 元素上创建，所以如果你通过 ",(0,r.jsx)(n.code,{children:"addEventListener"}),"添加的事件一定比通过 ",(0,r.jsx)(n.code,{children:"onclick"}),"添加的事件早执行。可以查看这个 ",(0,r.jsx)(n.a,{href:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE41Sy2rDMBD8lUUXJxDiu-sYeugt_YK6h8RaN6LyykgrQzH6965shxJooQc_RhrNzA6aVW8sBlW9zYouA6pKPY-jOij-GjMIE1pGwcFF3-WVOnTejNy01LIZRucZZnD06iIxJOi9G6BYjxVPmZQfiwzaTBkL2ti73R5ODcwLiftIHRtHcLuQtuhlc9tpuSyBbyZAuLloNfhIELBzpO8E-Q_O4tG6j13hIqO_y0BvPOpiv0bhtJ1Y3pLoeNH6ZULiswmMJLZFZ033WRzuAvstdMseOXqCh9SriMfBTfgPnZxg-aYM6_KnS6pFCK6GdJVHPc0C01JyfY0slUnHi-JpfgjwSzUycdgmfOjFEP3RS1qdhJ8dYMDFt1yNmxxU0jRyCwanTW9Qq4p9xPSevgHI3m43QAIAAA==",title:"https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE41Sy2rDMBD8lUUXJxDiu-sYeugt_YK6h8RaN6LyykgrQzH6965shxJooQc_RhrNzA6aVW8sBlW9zYouA6pKPY-jOij-GjMIE1pGwcFF3-WVOnTejNy01LIZRucZZnD06iIxJOi9G6BYjxVPmZQfiwzaTBkL2ti73R5ODcwLiftIHRtHcLuQtuhlc9tpuSyBbyZAuLloNfhIELBzpO8E-Q_O4tG6j13hIqO_y0BvPOpiv0bhtJ1Y3pLoeNH6ZULiswmMJLZFZ033WRzuAvstdMseOXqCh9SriMfBTfgPnZxg-aYM6_KnS6pFCK6GdJVHPc0C01JyfY0slUnHi-JpfgjwSzUycdgmfOjFEP3RS1qdhJ8dYMDFt1yNmxxU0jRyCwanTW9Qq4p9xPSevgHI3m43QAIAAA==",target:"_blank",rel:"noopener noreferrer",children:"Demo"}),"。为了保持相对顺序，使用 ",(0,r.jsx)(n.code,{children:"on"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["所以当你添加了 ",(0,r.jsx)(n.code,{children:"onclick"}),"这样的时间处理程序，会使用事件委托技术，为根 DOM 元素上的每个事件类型创建一个处理程序，而不是为每个元素创建一个处理程序，这是为了更好的性能和内存使用率。所以你通过",(0,r.jsx)(n.code,{children:"addEventListener"}),"添加的事件一定比通过 ",(0,r.jsx)(n.code,{children:"onclick"}),"添加的事件更早执行，无论在 DOM 中的位置如何。"]}),"\n",(0,r.jsx)(n.p,{children:"让我们提供一个完整可运行的极简版代码，可以看到它背后的实现机制："}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"svelte5-4.js"}),"，完整可运行代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const $ = {};\n\n$.template = template;\n$.append = append;\n$.child = child;\n$.reset = reset;\n$.template_effect = template_effect;\n$.set_text = set_text;\n$.state = state;\n$.get = get;\n$.set = set;\n$.delegate = delegate;\n\nfunction state(v) {\n  return {\n    f: 0,\n    v,\n    reactions: null,\n    equals: (value) => value === this.v,\n    version: 0,\n  };\n}\n\nfunction template(content, flags) {\n  var node;\n  return () => {\n    if (node === undefined) {\n      node = create_fragment_from_html(content);\n      node = node.firstChild;\n    }\n\n    var clone = node.cloneNode(true);\n    return clone;\n  };\n}\n\nfunction create_fragment_from_html(html) {\n  var elem = document.createElement("template");\n  elem.innerHTML = html;\n  return elem.content;\n}\n\nfunction append(anchor, dom) {\n  anchor.before(dom);\n}\n\nfunction child(node) {\n  return node.firstChild;\n}\n\nlet hydrating = false;\nfunction reset(node) {\n  if (!hydrating) return;\n}\n\nconst RENDER_EFFECT = 1 << 3;\nconst ROOT_EFFECT = 1 << 6;\nconst DIRTY = 1 << 10;\n\nfunction template_effect(fn) {\n  return render_effect(fn);\n}\nfunction render_effect(fn) {\n  return create_effect(RENDER_EFFECT, fn, true);\n}\n\nlet component_context = null;\nlet active_effect = null;\nfunction create_effect(type, fn, sync, push = true) {\n  var effect = {\n    ctx: component_context,\n    deps: null,\n    nodes_start: null,\n    nodes_end: null,\n    f: type | DIRTY,\n    first: null,\n    fn,\n    last: null,\n    next: null,\n    prev: null,\n    teardown: null,\n    transitions: null,\n    version: 0,\n  };\n\n  if (sync) {\n    update_effect(effect);\n  }\n\n  return effect;\n}\n\nfunction update_effect(effect) {\n  update_reaction(effect);\n}\n\nlet new_deps = null;\n\nfunction update_reaction(reaction) {\n  new_deps = null;\n\n  // 这个函数会触发 get 函数，从而触发 new_deps 的赋值\n  var result = reaction.fn();\n  var deps = reaction.deps;\n\n  if (new_deps !== null) {\n    if (deps == null) {\n      reaction.deps = deps = new_deps;\n    }\n\n    // 这里建立了 signals 和 effect 的依赖关系\n    for (var i = 0; i < deps.length; i++) {\n      (deps[i].reactions ??= []).push(reaction);\n    }\n  }\n\n  return result;\n}\n\nfunction set_text(text, value) {\n  if (value !== (text.__t ??= text.nodeValue)) {\n    text.__t = value;\n    text.nodeValue = value == null ? "" : value + "";\n  }\n}\n\nfunction get(signal) {\n  if (new_deps === null) {\n    new_deps = [signal];\n  }\n  return signal.v;\n}\n\nfunction set(source, value) {\n  if (!source.equals(value)) {\n    source.v = value;\n    mark_reactions(source, DIRTY);\n  }\n\n  return value;\n}\n\nfunction mark_reactions(signal, status) {\n  signal.f |= status;\n  var reactions = signal.reactions;\n  if (reactions === null) return;\n\n  for (var i = 0; i < reactions.length; i++) {\n    var reaction = reactions[i];\n    schedule_effect(reaction);\n  }\n}\n\nlet queued_root_effects = [];\nfunction schedule_effect(signal) {\n  queueMicrotask(process_deferred);\n  var effect = signal;\n  queued_root_effects.push(effect);\n}\n\nfunction process_deferred() {\n  const previous_queued_root_effects = queued_root_effects;\n  queued_root_effects = [];\n  flush_queued_root_effects(previous_queued_root_effects);\n}\n\nfunction flush_queued_root_effects(root_effects) {\n  var length = root_effects.length;\n  if (length === 0) {\n    return;\n  }\n\n  for (var i = 0; i < length; i++) {\n    var effect = root_effects[i];\n    process_effects(effect);\n  }\n}\n\nfunction process_effects(effect) {\n  update_effect(effect);\n}\n\nconst all_registered_events = new Set();\nconst root_event_handles = new Set();\nfunction delegate(events) {\n  for (var i = 0; i < events.length; i++) {\n    all_registered_events.add(events[i]);\n  }\n\n  for (var fn of root_event_handles) {\n    fn(events);\n  }\n}\n\nfunction handle_event_propagation(event) {\n  var handler_element = this;\n  var owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n  var event_name = event.type;\n  var path = event.composedPath?.() || [];\n  var current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n  // composedPath contains list of nodes the event has propagated through.\n  // We check __root to skip all nodes below it in case this is a\n  // parent of the __root node, which indicates that there\'s nested\n  // mounted apps. In this case we don\'t want to trigger events multiple times.\n  var path_idx = 0;\n\n  // @ts-expect-error is added below\n  var handled_at = event.__root;\n\n  current_target = /** @type {Element} */ (path[path_idx] || event.target);\n  // there can only be one delegated event per element, and we either already handled the current target,\n  // or this is the very first target in the chain which has a non-delegated listener, in which case it\'s safe\n  // to handle a possible delegated event on it later (through the root delegation listener for example).\n  if (current_target === handler_element) return;\n\n  var define_property = Object.defineProperty;\n  var is_array = Array.isArray;\n  // Proxy currentTarget to correct target\n  define_property(event, "currentTarget", {\n    configurable: true,\n    get() {\n      return current_target || owner_document;\n    },\n  });\n\n  try {\n    var throw_error;\n    var other_errors = [];\n\n    while (current_target !== null) {\n      /** @type {null | Element} */\n      var parent_element =\n        current_target.assignedSlot ||\n        current_target.parentNode ||\n        /** @type {any} */ (current_target).host ||\n        null;\n\n      try {\n        // @ts-expect-error\n        var delegated = current_target["__" + event_name];\n        if (\n          delegated !== undefined &&\n          !(/** @type {any} */ (current_target).disabled)\n        ) {\n          if (is_array(delegated)) {\n            var [fn, ...data] = delegated;\n            fn.apply(current_target, [event, ...data]);\n          } else {\n            delegated.call(current_target, event);\n          }\n        }\n      } catch (error) {\n        if (throw_error) {\n          other_errors.push(error);\n        } else {\n          throw_error = error;\n        }\n      }\n      if (\n        event.cancelBubble ||\n        parent_element === handler_element ||\n        parent_element === null\n      ) {\n        break;\n      }\n      current_target = parent_element;\n    }\n\n    if (throw_error) {\n      for (let error of other_errors) {\n        // Throw the rest of the errors, one-by-one on a microtask\n        queueMicrotask(() => {\n          throw error;\n        });\n      }\n      throw throw_error;\n    }\n  } finally {\n    // @ts-expect-error is used above\n    event.__root = handler_element;\n    // @ts-ignore remove proxy on currentTarget\n    delete event.currentTarget;\n  }\n}\n\nfunction mount(Component, { target, anchor }) {\n  var anchor_node = anchor ?? target.appendChild(document.createTextNode(""));\n  Component(anchor_node);\n  document.addEventListener("click", handle_event_propagation, {\n    passive: false,\n  });\n}\n\n// 编译后代码：\nfunction update(_, name) {\n  $.set(name, "Svelte");\n}\n\nvar root = $.template(`<button> </button>`);\n\nfunction App($$anchor) {\n  let name = $.state("World");\n  var button = root();\n\n  button.__click = [update, name];\n\n  var text = $.child(button);\n\n  $.reset(button);\n  $.template_effect(() => $.set_text(text, `Hello ${$.get(name) ?? ""}`));\n  $.append($$anchor, button);\n}\n\n$.delegate(["click"]);\n\nmount(App, {\n  target: document.body,\n});\n'})}),"\n",(0,r.jsx)(n.p,{children:"浏览器效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["主要的实现代码在 ",(0,r.jsx)(n.code,{children:"handle_event_propagation"}),"函数中，当点击的时候，获取点击元素，从该元素的 ",(0,r.jsx)(n.code,{children:"__click"}),"属性中获取处理程序和数据，然后调用 ",(0,r.jsx)(n.code,{children:"update"}),"函数，剩下的流程与上节相同。"]}),"\n",(0,r.jsxs)(n.h2,{id:"6-最后",children:["6. 最后",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-最后",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"至此我们就完成了 Svelte5 一个最基本的例子的源码流程分析。如果对细节不太清楚，可以使用提供的极简版代码调试查看运行流程，或者参考《原理篇 | 如何调试 Svelte5 的代码》调试完整的源码。极简版被我删减了非常多的地方，部分地方可能看起来有些多余，如果不清楚作用，可以参照源码对比。"}),"\n",(0,r.jsx)(n.p,{children:"可以看到 Svelte 5 就是基于 Signals 的设计思路进行实现，会在组件首次运行的时候收集 Signals 依赖的 Reactions，在 Signals 的值发生更改的时候，就会运行这些 Reactions，从而直接完成 DOM 更新。"}),"\n",(0,r.jsx)(n.p,{children:"可是 Svelte 4 不也是直接更新 DOM 吗？所以到底有什么改变呢？"}),"\n",(0,r.jsx)(n.p,{children:"从表面上看，Svelte4 是在编译的时候分析依赖项，而 Svelte5 允许 Svelte 在运行时跟踪依赖项，这会带来性能上的优化，可以参考《Svelte5 | Runes 初识 》中关于细粒度响应式的例子。"}),"\n",(0,r.jsxs)(n.p,{children:["而在更深层面，Svelte4 实现响应式是通过覆盖 JavaScript 原生行为来实现的，也就是通过劫持 ",(0,r.jsx)(n.code,{children:"let"})," 和 ",(0,r.jsx)(n.code,{children:"$"}),"，让开发者写着原生 JavaScript 的语法，但却能实现响应式更新。本质写的并不是 JavaScript，而是一种类似于 JavaScript 的语言，所以那些 let 声明只能放在 ",(0,r.jsx)(n.code,{children:".svelte"}),"组件顶层，放在其他地方 Svelte 就不会做特殊处理了。"]}),"\n",(0,r.jsxs)(n.p,{children:["但 Svelte5 虽然使用符文，让原本的代码稍微长了一点，但并没有覆盖 JavaScript 的原生行为，所以 Svelte 5 的代码看起来不像 JavaScript，但行为上却是 JavaScript，所以你写的符文代码可以在 ",(0,r.jsx)(n.code,{children:".svelte"}),"文件中使用，也可以在 ",(0,r.jsx)(n.code,{children:".svelte.js"}),"、",(0,r.jsx)(n.code,{children:".svelte.ts"}),"文件中使用，所以创建状态可以在一个单独的 js 文件中，然后通过导入的方式使用，这让 Svelte 的代码更加灵活。 这是两个版本非常大的不同之处。"]}),"\n",(0,r.jsxs)(n.h2,{id:"恭喜你",children:["恭喜你！",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#恭喜你",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"最后的最后，恭喜你完成了第四阶段 —— Svelte 原理的学习："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"第一阶段：Svelte 5 \uD83C\uDF89"}),"\n",(0,r.jsx)(n.li,{children:"第二阶段：SvelteKit \uD83C\uDF89"}),"\n",(0,r.jsx)(n.li,{children:"第三阶段：项目实战 \uD83C\uDF89"}),"\n",(0,r.jsx)(n.li,{children:"第四阶段：Svelte 原理 \uD83C\uDF89"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"靡不有初，鲜克有终。我相信绝大部分的读者应该都没有完整阅读完小册内容，但没有关系，因为也没有必要完全看完，我们学习技术的目的在于应用，正确的学习方式应该是边学边用，边用边学，在实际项目开发中解决问题才会帮助你真正理解掌握，所以对于这本小册大部分的内容只用了解即可，知道有这么个东西，真正用到的时候再来这本小册细查用法即可。"}),"\n",(0,r.jsx)(n.p,{children:"感谢阅读这本小册的你，通过文字建立交流本身就是一种缘分，感谢你的阅读和支持。由于作者水平有限，书中难免有错误或不妥之处，欢迎广大读者批评指正。"})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(f,{...e})}):f(e)}let h=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F39-%E5%8E%9F%E7%90%86%E7%AF%87%20%E2%9D%98%20Svelte%205%20%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AE%9E%E7%8E%B0.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. Hello World!",id:"2-hello-world",depth:2},{text:"3. 加入变量",id:"3-加入变量",depth:2},{text:"4. 更新变量",id:"4-更新变量",depth:2},{text:"5. 绑定事件",id:"5-绑定事件",depth:2},{text:"6. 最后",id:"6-最后",depth:2},{text:"恭喜你！",id:"恭喜你",depth:2}],title:"39-原理篇 ❘ Svelte 5 运行时实现",headingTitle:"39-原理篇 ❘ Svelte 5 运行时实现",frontmatter:{}}}}]);