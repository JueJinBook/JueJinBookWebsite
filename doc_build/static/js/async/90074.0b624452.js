"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["90074"],{58162:function(n,e,s){s.r(e),s.d(e,{default:()=>c});var r=s(552676),i=s(740453);function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",h2:"h2",ol:"ol",li:"li",blockquote:"blockquote",ul:"ul",pre:"pre"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"第13章系统的基元进程和线程",children:["第13章—系统的基元：进程和线程",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第13章系统的基元进程和线程",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["\uFEFF\n在前面",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196589491266519080",target:"_blank",rel:"noopener noreferrer",children:"第 6 章"}),"我们提到过计算机的组成元件，那都是些冷冰冰的硬件而已，就像人体的躯干一样，而软件才是计算机的",(0,r.jsx)(e.code,{children:"灵魂"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们把软件分为",(0,r.jsx)(e.strong,{children:"系统软件"}),"和",(0,r.jsx)(e.strong,{children:"应用软件"}),"，操作系统就是系统软件的一种，只不过它是最基础的软件，其他所有软件都要运行在操作系统上。"]}),"\n",(0,r.jsxs)(e.p,{children:["那软件是什么呢？简言之，",(0,r.jsx)(e.strong,{children:"软件就是程序的载体"}),"。我们写的",(0,r.jsx)(e.code,{children:"hello world"}),"等代码，打包出来就是软件，就能安装在各种设备上，然后运行在操作系统上。"]}),"\n",(0,r.jsx)(e.p,{children:"那操作系统又是啥呢？凭什么让它管理我写的软件呢？我们就来了解下。"}),"\n",(0,r.jsxs)(e.h2,{id:"进程和线程的概念",children:["进程和线程的概念",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#进程和线程的概念",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"操作系统是啥？是软件，只不过它是专门管理软件的软件。"}),"\n",(0,r.jsxs)(e.p,{children:["操作系统有",(0,r.jsx)(e.code,{children:"两个作用"}),"："]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"负责跟系统硬件打交道，把用户的各种操作（比如鼠标点击、键盘输入等）翻译给计算机硬件，然后将结果告诉用户；"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"管理其他软件。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"那操作系统是怎么管理软件呢？通过管理进程！"}),"\n",(0,r.jsx)(e.p,{children:"我们知道，软件是程序的载体，而每一个程序都是一个进程。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"每一个程序都有一个进程。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"我们可以把一个软件理解为一个家庭，那么这个家庭就是一个进程。"}),"\n",(0,r.jsx)(e.p,{children:"那么，我们家就是一个进程，在这个进程中，有三口人：我、我爸、我妈。"}),"\n",(0,r.jsx)(e.p,{children:"那照这个意思来说，村长就是操作系统了？"}),"\n",(0,r.jsx)(e.p,{children:"虽然不太合适，不过也可以这么理解。如果这样的话，那是不是意味着村长每次下命令，都只能指挥一个家庭？因为一个家庭是一个进程，村长又是管理家庭的。"}),"\n",(0,r.jsxs)(e.p,{children:["这听着不太对啊，难道村长不能让我单独去做一件事吗？必须让我们整个家庭一起去做一件事吗？一家人一起去做一件事，是不是有点",(0,r.jsx)(e.strong,{children:"浪费资源"}),"？"]}),"\n",(0,r.jsxs)(e.p,{children:["确实浪费资源，实际上，村长是可以指挥单独一个人去做一件事的，那么这个人就叫做一个",(0,r.jsx)(e.strong,{children:"线程"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["那么，村长能单独调动的最小单位就不是一个家庭了，而是一个人。也就是说：",(0,r.jsx)(e.strong,{children:"线程是操作系统能调度的最小单元"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["到这里，我们就知道了：",(0,r.jsx)(e.strong,{children:"每个程序都有一个进程，线程是进程的一部分，线程是操作系统能调度的最小单元"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"那么，为啥要这么干呢？这么做村长不累吗？"}),"\n",(0,r.jsxs)(e.h2,{id:"线程的优点",children:["线程的优点",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#线程的优点",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"使用线程可以提高程序的运行速度，节省时间和成本。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"首先，村长肯定累，虽然比不过生产队的驴，不过也差不多了。"}),"\n",(0,r.jsx)(e.p,{children:"但是，人家操作系统是计算机，是拥有光速的男人，你就不要操心人家了。"}),"\n",(0,r.jsx)(e.p,{children:"举个例子，假如没有线程，村长让我家去挨家挨户发个开放三胎的通知，我们会怎么办呢？"}),"\n",(0,r.jsx)(e.p,{children:"嗯，三个人一起挨家挨户地去烦他们，全村 1000 户，每家 2 分钟，一共 2000 分钟，大概 33.333 小时（其中 3 无限循环），这不吃不喝一天都干不完。"}),"\n",(0,r.jsx)(e.p,{children:"那有人就纳闷了，你这就发个通知，也就嘴炮两句的事，用得着拖家带口一起上阵吗？如果你有爷爷奶奶是不是准备 5 个一起上？5 个人一起去通知一个只有两口人的家庭？发通知的比接通知的人都多，何苦呢？"}),"\n",(0,r.jsx)(e.p,{children:"所以我们就要上线程啊。"}),"\n",(0,r.jsx)(e.p,{children:"上了线程后，我们每个人都是一个线程，就可以三个人一起上，这样时间直接变为原来的 1/3，一天就搞定了，从而节省了时间。"}),"\n",(0,r.jsx)(e.p,{children:"而且原来 33 小时搞定的事情，现在 11 小时搞定，等价于白白增加了 22 小时的寿命，等价于节省了成本。"}),"\n",(0,r.jsxs)(e.p,{children:["所以，引入线程，就等价于",(0,r.jsx)(e.strong,{children:"变串行为并行，能提高速度，节省时间"}),"。"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"串行：一件事同一时刻只有一个人做。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"并行：一件事同一时刻有多个人做。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"有人说，这样的话，岂不是线程越多越好吗？越多就等于同时有更多的人去做，这样肯定更快啊。"}),"\n",(0,r.jsx)(e.p,{children:"大谬！"}),"\n",(0,r.jsxs)(e.p,{children:["还是刚刚的例子，全村 1000 家，你能用 1001 个人去通知吗？显然不能。最重要的是：",(0,r.jsx)(e.strong,{children:"计算机无法让那么多线程同时工作"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"这是啥意思呢？"}),"\n",(0,r.jsx)(e.p,{children:"比如说，一个 16 核的 CPU，最多只能让 16 个线程同时工作。即使开了 100 个线程，同一个时刻也是只有 16 个线程同时工作。"}),"\n",(0,r.jsx)(e.p,{children:"有人说，不对啊，我开了 100 个线程打印数字，发现它们都同时打印了。"}),"\n",(0,r.jsx)(e.p,{children:"那只是你以为而已。其实这里面是有个调度算法的，计算机通过一定的调度算法，让你这 100 个线程看起来像是每个都在执行，这个我们在后面第 15 章会细讲。"}),"\n",(0,r.jsx)(e.p,{children:"再举个例子，大家都用迅雷下载过电影，其实每个下载流都是一个线程，是不是越多越好呢？"}),"\n",(0,r.jsx)(e.p,{children:"不是！"}),"\n",(0,r.jsx)(e.p,{children:"因为网速就 100k/s，你开一个线程下载，就是 100k/s，你开两个线程下载，那么网速就均分，就变成每个 50k\n/s，这有啥意义呢？原来 100k/s 的还能先下载个看着，然后等另一部下载呢。"}),"\n",(0,r.jsx)(e.p,{children:"但是，如果你是在计算数学题，比如 100 道题目，你就可以开启 10 个线程，每个线程计算 10 道题目，然后把结果合并即可。"}),"\n",(0,r.jsxs)(e.p,{children:["其实，说白了：",(0,r.jsx)(e.strong,{children:"如果你的程序存在着资源竞争，开启多线程是无益的；如果你的程序不存在资源竞争，开启多线程是有益的"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"比如上面的下载，都在争着用网络，你即使开启 250 个线程，也 no egg use。你多开线程能增加网速吗？而上面的数学题，彼此都是独立的，就可以多开几个线程来同时完成。但是如果上面 100 道题目的下一题需要依赖上一题的结果，那就别开多线程了，没用！"}),"\n",(0,r.jsx)(e.p,{children:"上述说到的资源竞争，就是多线程的缺点，那这个咋避免呢？"}),"\n",(0,r.jsxs)(e.h2,{id:"多线程的问题",children:["多线程的问题",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#多线程的问题",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"资源冲突：多个线程在同一时刻操作同一个资源。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"还是上面的例子，假如三个人都同时通知到同一家，这个算不算资源冲突呢？"}),"\n",(0,r.jsx)(e.p,{children:"不算，因为这个只是访问资源，不是操作资源，操作资源指的是对资源进行了修改。比如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"// 定义资源i\nint i = 10;\n// 访问资源，没有修改i\nprintln(i);\n// 操作资源，对i进行了修改\ni = 1;\n"})}),"\n",(0,r.jsxs)(e.p,{children:["发生冲突的资源，就叫",(0,r.jsx)(e.strong,{children:"临界资源"}),"。比如，如果发生了冲突，上述的",(0,r.jsx)(e.code,{children:"i"}),"就是临界资源。"]}),"\n",(0,r.jsxs)(e.p,{children:["上述我们说了，",(0,r.jsx)(e.strong,{children:"线程是进程的一部分，是操作系统调度的最小单位"}),"。是调度的最小单位，不是持有资源的最小单位。也就是说，资源都是在进程中的，",(0,r.jsx)(e.strong,{children:"进程是持有资源的最小单位"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["还是我家，我们每个人都可以自由行动，但是我家的粮仓却只能放在我家，不可能每个人都持有一个粮仓，粮仓就是资源，所以",(0,r.jsx)(e.strong,{children:"进程是持有资源的最小单位"}),"。线程可以使用资源，却不能持有资源。"]}),"\n",(0,r.jsxs)(e.p,{children:["其实，我们",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196589491266519080",target:"_blank",rel:"noopener noreferrer",children:"第 6 章"}),"讲过，控制器控制程序流按顺序执行，程序流指的就是线程，每个线程内部都有一个缓存，用来存放自己需要的数据，当每个线程被执行的时候，CPU 就会把这个线程需要的数据读入缓存中，等到执行完毕，就再把缓存的数据写回到内存中。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["每一个进程都有一块",(0,r.jsx)(e.code,{children:"内存"}),"，这个内存是所有线程共享的。每一个线程都有一个",(0,r.jsx)(e.code,{children:"缓存"}),"，这个缓存是自己独占的。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"假如我们有个进程 P，进程 P 有个线程 A。那么，A 的执行逻辑就是这样的："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"CPU 将 A 需要的数据从进程 P 的内存读入线程 A 的缓存，比如读入了 i。"}),"\n",(0,r.jsx)(e.li,{children:"A 对自己缓存的数据执行一顿猛如虎的操作，比如 i++。"}),"\n",(0,r.jsx)(e.li,{children:"A 执行完毕，CPU 将 A 缓存的数据 i 写回到进程 P 的内存中。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"这就是 A 的执行流程。嗯，懂了。"}),"\n",(0,r.jsx)(e.p,{children:"不，你不懂！"}),"\n",(0,r.jsx)(e.p,{children:"假如，在线程 A 执行的同时，进程 P 的另一个线程 B 也在执行，并且也用到了 P 内存中的 i，那么，等线程 B 执行完毕之后，i 是多少呢？是以线程 A 执行的为准，还是以线程 B 执行的为准呢？"}),"\n",(0,r.jsxs)(e.p,{children:["此时就发生了资源冲突，",(0,r.jsx)(e.code,{children:"i"}),"就叫做临界资源。线程 A 和线程 B 对",(0,r.jsx)(e.code,{children:"i"}),"进行修改的代码就叫",(0,r.jsx)(e.code,{children:"临界区"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"有人说，你这不是没事找事吗？你直接把线程 A 和线程 B 的缓存砍了，都直接对进程 P 的内存中的 i 进行操作不就行了？"}),"\n",(0,r.jsxs)(e.p,{children:["这样它们修改的就是同一个",(0,r.jsx)(e.code,{children:"i"}),"，就不临界了，直接就避免了问题。"]}),"\n",(0,r.jsxs)(e.p,{children:["不行！",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196589491266519080",target:"_blank",rel:"noopener noreferrer",children:"第 6 章"}),"我们说过，从内存中读数据是一个耗时操作，很慢很慢，效率很低，所以我们才在线程中开启了一个高速缓存，执行时，先把数据读入高速缓存，等到执行完毕再把数据从高速缓存写回内存。"]}),"\n",(0,r.jsx)(e.p,{children:"你这个馊主意肯定是不行的。那有别的办法吗？有！"}),"\n",(0,r.jsxs)(e.p,{children:["其实我们的问题核心就是：有多个人同时操作了同一个东西。充分必要条件就是：",(0,r.jsx)(e.strong,{children:"同一时刻、同一个目标"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"那么解决方案就是：不同时，或者不同目标即可。"}),"\n",(0,r.jsxs)(e.p,{children:["怎么不同时呢？",(0,r.jsx)(e.strong,{children:"排队！变并行为串行"}),"。我们可以在",(0,r.jsx)(e.code,{children:"i"}),"被读入线程 A 的内存中时，加个标记，其他线程来看到这个标记就等着，等到线程 A 执行完把",(0,r.jsx)(e.code,{children:"i"}),"写回到内存中时，再把标记清除，并通知其他线程，其他线程再开始执行，这就是最基本的解决方法。"]}),"\n",(0,r.jsx)(e.p,{children:"那这也太挫了，合着你多线程半天了最后还是排队，有啥用？"}),"\n",(0,r.jsxs)(e.p,{children:["当然，我们有更高级的解决方案，就是",(0,r.jsx)(e.strong,{children:"分离目标"}),"，不过这是有使用条件的，我们下一节会仔细讲解。"]}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本章我们从操作系统角度讲解了进程和线程，我们再来回顾下。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"进程是持有资源的最小单位，线程是系统调度的最小单位。"}),"\n",(0,r.jsx)(e.li,{children:"引入线程可以提高执行速度，节省时间。"}),"\n",(0,r.jsx)(e.li,{children:"多线程会引发资源冲突，我们解决资源冲突就是破坏“同一时间”和“同一目标”这两个条件。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"下一节，我们就用具体的代码、具体的例子，来看下怎么解决多线程引起的资源冲突问题。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC13%E7%AB%A0%E2%80%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E5%85%83%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.md"]={toc:[{text:"进程和线程的概念",id:"进程和线程的概念",depth:2},{text:"线程的优点",id:"线程的优点",depth:2},{text:"多线程的问题",id:"多线程的问题",depth:2},{text:"总结",id:"总结",depth:2}],title:"第13章—系统的基元：进程和线程",headingTitle:"第13章—系统的基元：进程和线程",frontmatter:{}}}}]);