"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["84239"],{307828:function(n,e,r){r.r(e),r.d(e,{default:()=>x});var d=r(552676),l=r(740453);let s=r.p+"static/image/4f80c9aab8c663e30aecfa26c9e56a6c.d3e41f55.webp";function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",strong:"strong",code:"code",h2:"h2",pre:"pre",blockquote:"blockquote",h4:"h4",br:"br",img:"img",ol:"ol",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,l.ah)(),n.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.h1,{id:"第06章基础语法二指针和运算符",children:["第06章—基础语法二｜指针和运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第06章基础语法二指针和运算符",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"\uFEFF本节继续介绍Go语言的基础语法知识，具体包括以下内容："}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"指针类型"}),"\n",(0,d.jsx)(e.li,{children:"运算符及优先级"}),"\n",(0,d.jsx)(e.li,{children:"类型转换"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"在上一讲中，我们介绍了Go语言的基本数据类型，学会了如何对变量进行声明和赋值，也知道了在这个过程中会在内存开辟空间方便它们“安家”。那如何才能找到这个“家”呢？这就涉及到了指针。"}),"\n",(0,d.jsx)(e.p,{children:"通过使用指针，开发者可以直接访问内存中的数据，从而可以实现对数据的精准管理以及运算。"}),"\n",(0,d.jsxs)(e.p,{children:["如果说变量名是数据的“代号”，那么指针存放的则是数据的“",(0,d.jsx)(e.strong,{children:"实际地址"}),"”，我们可以通过这个地址获取或修改存放于这个地址的变量的值。"]}),"\n",(0,d.jsx)(e.p,{children:"存放整数值的变量称为整型变量，存放布尔值的变量称为布尔变量……类似地，存放指针值的变量称为指针变量。"}),"\n",(0,d.jsxs)(e.p,{children:["那么问题来了，想要获取或改变某个变量的值，直接通过变量名就可以实现了。而且像Java之类的编程语言几乎不会用到指针，",(0,d.jsx)(e.strong,{children:"那Go为何还要用指针呢？"})]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.code,{children:"❗️ 注意： 实际上，Java中的指针操作封装在JDK中，普通开发者一般不会接触到，所以会误认为Java没有指针。 "})}),"\n",(0,d.jsxs)(e.h2,{id:"指针类型",children:["指针类型",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#指针类型",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["我们不妨先了解一下Go语言中的指针，它主要由两大核心概念构成：",(0,d.jsx)(e.strong,{children:"类型指针"}),"和",(0,d.jsx)(e.strong,{children:"切片指针"}),"。"]}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:["类型指针：在",(0,d.jsx)(e.strong,{children:"传递数据"}),"时直接使用指针，可以避免创建数据的副本，节约内存开销。类型指针不能进行偏移和运算，可以",(0,d.jsx)(e.strong,{children:"避免非法修改"}),"为其它数据的风险，也更",(0,d.jsx)(e.strong,{children:"有利于垃圾回收"}),"机制及时找到并回收它们；"]}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsxs)(e.p,{children:["切片指针：切片由",(0,d.jsx)(e.strong,{children:"指向起始元素的指针"}),"、元素数量和总容量构成。当访问切片发生越界时，会发生宕机并输出堆栈信息。宕机是",(0,d.jsx)(e.strong,{children:"可以恢复"}),"的，而崩溃只能导致程序停止运行。"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.p,{children:["可见，",(0,d.jsx)(e.strong,{children:"使用指针更有利于程序运行的性能和稳定性"}),"。另外，在某些操作中，如使用反射修改变量的值，必须使用可寻址的变量（通过指针）。"]}),"\n",(0,d.jsx)(e.p,{children:"在实际应用中，最为常用的便是获取变量的内存地址，以及获取某个地址对应的值。在Go语言中，前者使用“&”运算符，后者使用“*”运算符。它们互为反向操作，操作的对象也不同。具体请看下面的示例："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"//exampleNumberA变量（整数型变量）声明和赋值\r\nvar exampleNumberA int = 10\r\n//获取exampleNumberA的地址，并赋值给exampleNumberAPtr变量（exampleNumberAPtr的类型是指针类型）\r\nexampleNumberAPtr := &exampleNumberA\r\n//输出exampleNumberAPtr变量的值（将输出内存地址）\r\nfmt.Println(exampleNumberAPtr)\r\n//获取exampleNumberAPtr（指针变量）表示的实际数据值，并赋值给exampleNumberAPtrValue变量（整数型变量）\r\nexampleNumberAPtrValue := *exampleNumberAPtr\r\n//输出exampleNumberAPtrValue变量（整数型变量）的值\r\nfmt.Println(exampleNumberAPtrValue)\n"})}),"\n",(0,d.jsx)(e.p,{children:"运行后，控制台输出："}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"0xc00001a088 10"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.code,{children:"\uD83D\uDCA1 提示： 在练习时，如果内存地址输出与上述结果不符，或者即使是相同的程序，每次运行结果也不同，都是正常现象。因为内存的分配并不是固定的。 "})}),"\n",(0,d.jsxs)(e.p,{children:["上面的代码示例演示了如何使用已有的变量创建指针类型变量。我们还可以使用new()函数直接创建指针变量，相当于在内存中创建了",(0,d.jsx)(e.strong,{children:"没有变量名"}),"的",(0,d.jsx)(e.strong,{children:"某种类型"}),"的",(0,d.jsx)(e.strong,{children:"变量"}),"。"]}),"\n",(0,d.jsx)(e.p,{children:"这样做无需产生新的数据“代号”，取值和赋值转而通过指针变量完成。常用在无需变量名或必须要传递指针变量值的场景中。"}),"\n",(0,d.jsx)(e.p,{children:"new()函数的使用格式如下："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"new(type)\n"})}),"\n",(0,d.jsx)(e.p,{children:"其中，type是所在地址存放的数据类型。一旦完成创建，便会在内存中“安家”，完成内存分配，即使没有赋值。"}),"\n",(0,d.jsx)(e.p,{children:"具体代码示例如下："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"//使用new()函数创建名为exampleNumberAPtr指针类型变量，表示int64型值\r\nexampleNumberAPtr := new(int64)\r\n//修改exampleNumberAPtr表示的实际数据值\r\n*exampleNumberAPtr = 100\r\n//获取exampleNumberAPtr表示的实际数据值\r\nfmt.Println(*exampleNumberAPtr)\n"})}),"\n",(0,d.jsx)(e.p,{children:"程序运行后，控制台将输出："}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"100"}),"\n"]}),"\n",(0,d.jsxs)(e.h2,{id:"运算符与优先级",children:["运算符与优先级",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#运算符与优先级",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"有了数据，下一步便是使用这些数据进行运算了。Go语言总共提供了6种常用的运算符，分别为算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符以及指针运算符。我们先从最易懂的算术运算符开始。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.code,{children:" \uD83D\uDCA1 提示： 附录一详细列出了Go语言中所有的运算符及其含义，以及运算符的优先级顺序。各位在学习时应对照参考，尝试每一种运算符的使用。 "})}),"\n",(0,d.jsxs)(e.h4,{id:"算术运算符",children:["算术运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#算术运算符",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"算术运算符的意义和使用和数学上的概念很类似，比如："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"var exampleNumA int = 10\r\nvar exampleNumB int = 20\r\nvar exampleNumC int = 30\r\nvar exampleNumD = exampleNumA + exampleNumB*exampleNumC\r\nfmt.Println(exampleNumD)\n"})}),"\n",(0,d.jsx)(e.p,{children:"上述代码运行后，控制台输出610。显然，exampleNumD的值就是10+20*30，即610。"}),"\n",(0,d.jsx)(e.p,{children:"需要注意的是，在做除法时，对于int类别结果只保留整数。即使无法整除，余数也会被丢弃。如："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"var exampleNumA int = 10\r\nvar exampleNumB int = 3\r\nfmt.Println(exampleNumA / exampleNumB)\n"})}),"\n",(0,d.jsx)(e.p,{children:"运行后，控制台的输出为："}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"3"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"若要获取余数，需要用到取余（%）运算符，请参考下面的代码："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"var exampleNumA int = 10\r\nvar exampleNumB int = 3\r\nfmt.Println(exampleNumA / exampleNumB)\r\nfmt.Println(exampleNumA % exampleNumB)\n"})}),"\n",(0,d.jsx)(e.p,{children:"运行后，控制台将输出："}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsxs)(e.p,{children:["3",(0,d.jsx)(e.br,{}),"\n","1"]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"上述结果中，3仍然是除法的结果，1是余数。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.code,{children:"❗️ 注意： 和数学中的除法限制一样，0不能作为被除数，否则将引发宕机。当我们误将0作为除数时，GoLand会以波浪线的形式给出警告提示。 "})}),"\n",(0,d.jsx)(e.p,{children:"另外，还有一种较为精简的自增（++）和自减（--）运算符，它们相当于加1和减1，然后再将计算结果赋值给自身变量，如："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"var exampleNumA int = 10\r\n//exampleNumA = exampleNumA + 1\r\nexampleNumA++\r\nfmt.Println(exampleNumA)\n"})}),"\n",(0,d.jsx)(e.p,{children:"这段代码的运行结果为："}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"11"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"exampleNumA++与被注释的代码作用相同。"}),"\n",(0,d.jsxs)(e.h4,{id:"关系运算符",children:["关系运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#关系运算符",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"关系运算符则用来判断二者的关系，当结果与判断条件一致时，返回true，反之则返回false。例如："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"var exampleNumA int = 10\r\nvar exampleNumB int = 20\r\nfmt.Println(exampleNumA <= exampleNumB)\n"})}),"\n",(0,d.jsx)(e.p,{children:"这段代码中，最后一行的 <= 便是关系运算符之一，表示小于或等于。显然，10比20要小，因此这段代码最终将输出："}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"true"}),"\n"]}),"\n",(0,d.jsxs)(e.h4,{id:"逻辑运算符",children:["逻辑运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑运算符",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"逻辑运算符通常用来将两个条件组合，获得组合后的关系，最终将输出布尔类型值。其组合方式包括与“&&”、或“||”、非“!”。使用示例如下："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"var exampleBoolA bool = true\r\nvar exampleBoolB bool = false\r\n//逻辑与运算。当exampleBoolA和exampleBoolB均为true时，结果为true；其他情况均为false。\r\nfmt.Println(exampleBoolA && exampleBoolB)\r\n//逻辑或运算。当exampleBoolA或exampleBoolB有一个为true时，结果为true；当exampleBoolA和exampleBoolB都是false时，结果为false。\r\nfmt.Println(exampleBoolA || exampleBoolB)\r\n//逻辑非运算。将某个布尔类型的值取反。\r\nfmt.Println(!exampleBoolB)\n"})}),"\n",(0,d.jsx)(e.p,{children:"程序运行后，控制台将输出："}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsxs)(e.p,{children:["false",(0,d.jsx)(e.br,{}),"\n","true",(0,d.jsx)(e.br,{}),"\n","true"]}),"\n"]}),"\n",(0,d.jsxs)(e.h4,{id:"位运算符",children:["位运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#位运算符",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"位运算符运用在整数型变量，在进行运算时，会首先将其它进制的数值转换为二进制的数值，然后使用二进制数值进行运算，最后以原始进制类型返回计算结果。例如："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"//十进制7转二进制结果为0111\r\nvar exampleNumA int = 7\r\n//十进制5转二进制结果为0101\r\nvar exampleNumB int = 5\r\nfmt.Println(exampleNumA & exampleNumB)\n"})}),"\n",(0,d.jsx)(e.p,{children:"在这段代码中，&就是位运算符中的一个，表示按位与运算。由注释中的内容可知，7和5的按位与运算实际上就是0111和0101的按位与运算。当前后两个数对应位的数字都是1时，计算结果对应位的数字为1，否则为0。具体请看下图："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:s,alt:"image-20220118072931563.png"})}),"\n",(0,d.jsxs)(e.h4,{id:"赋值运算符",children:["赋值运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#赋值运算符",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"赋值运算符其实我们一直都在用，在为某个变量赋初值时使用的“=”便是最为简单的赋值运算符了。此外，还有一些更为简便的经过运算的赋值运算符，如："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"var exampleNumA int = 10\r\n//exampleNumA = exampleNumA + 20\r\nexampleNumA += 20\r\nfmt.Println(exampleNumA)\n"})}),"\n",(0,d.jsx)(e.p,{children:"在这段代码中，exampleNumA += 20与被注释掉的语句含义相同。"}),"\n",(0,d.jsxs)(e.h4,{id:"指针运算符",children:["指针运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#指针运算符",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"指针运算符包含 & 和 * 两个运算符，已经在本讲前面的“指针类型”介绍过了，有疑惑的朋友请学习“指针类型”部分。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.code,{children:"❗️ 注意： 请大家结合本讲最后附录一的内容，亲自动手尝试每一种运算符的使用。"})}),"\n",(0,d.jsxs)(e.h4,{id:"运算符的优先级",children:["运算符的优先级",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#运算符的优先级",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"在实际开发中，通常会处理较为复杂的运算，通常会将多个变量与多种运算符一齐使用，如此便不可避免地出现先后次序地问题。"}),"\n",(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.strong,{children:"对于算术运算符，遵循数学上的运算顺序。"})," 比如在既有乘法又有加法的情况下，会先进行乘法运算，再进行加法运算。当然，如果我们希望先进行加法运算，可以使用成对的小括号将加法部分包裹起来。这些做法在Go语言中也是相同的。"]}),"\n",(0,d.jsx)(e.p,{children:"完整的运算符优先级顺序请参考文末附录一的相关内容。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.code,{children:"\uD83D\uDCA1 提示： 成对的小括号在Go语言中优先级最高，且可以嵌套使用。在日后的开发中，当不太明确运算符的优先级时，最为稳妥的方法就是加小括号来限定计算顺序。"})}),"\n",(0,d.jsxs)(e.h2,{id:"类型转换",children:["类型转换",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#类型转换",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["在某些特定的场景下，我们需要对数据进行类型转换才能继续后面的逻辑（如某个函数需要float64类型参数，需要将现有int64类型值传入其中时）。",(0,d.jsx)(e.strong,{children:"在Go语言中，进行类型转换有两个要注意的地方"}),"，分别是："]}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"只能进行相同类别的转换，如将int32转换为int64。不同类别的转换将引发编译时错误，如将bool转换为string；"}),"\n"]}),"\n",(0,d.jsxs)(e.li,{children:["\n",(0,d.jsx)(e.p,{children:"若将取值范围较大的类型转换为取值范围较小的类型，且实际值超过取值范围较小的类型时，将发生精度丢失的情况。"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.p,{children:["有关不同类型的取值范围，请参考",(0,d.jsx)(e.a,{href:"https://juejin.cn/book/7039174186522116131/section/7047596606715068430",target:"_blank",rel:"noopener noreferrer",children:"上一讲"}),"的附录三。"]}),"\n",(0,d.jsx)(e.p,{children:"举例来说，下面的代码实现了将float32类型值转换为float64与int32类型值："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-Go",children:"//声明float32型变量exampleFloat32并赋值\r\nvar exampleFloat32 float32 = 150.25\r\n//将exampleFloat32转换为float64类型，并将结果赋值给exampleFloat64\r\nexampleFloat64 := float64(exampleFloat32)\r\n//输出exampleFloat64的类型和值\r\nfmt.Println(reflect.TypeOf(exampleFloat64), exampleFloat64)\r\n//将exampleFloat32转换为int32类型，exampleInt32\r\nexampleInt32 := int32(exampleFloat32)\r\n//输出exampleInt32的类型和值\r\nfmt.Println(reflect.TypeOf(exampleInt32), exampleInt32)\n"})}),"\n",(0,d.jsx)(e.p,{children:"运行后，控制台如下输出："}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsx)(e.p,{children:"float64 150.25 int32 150"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"显然，由于float64比float32的取值范围更广，因此转换后不会损失精度；由于int32不包含小数位，因此原值的.25部分被丢弃。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.code,{children:"\uD83D\uDCA1 提示： reflect.TypeOf()是使用反射获取变量类型的函数；fmt.Print``ln``()函数支持同时输出多个值，每个值之间使用英文的逗号（,）隔开。"})}),"\n",(0,d.jsxs)(e.h2,{id:"小结",children:["小结",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,d.jsx)(e.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,d.jsxs)(e.ol,{children:["\n",(0,d.jsx)(e.li,{children:"指针类型"}),"\n",(0,d.jsx)(e.li,{children:"运算符及优先级"}),"\n",(0,d.jsx)(e.li,{children:"类型转换"}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"借助指针，我们可以轻松且精准地直接访问和修改内存中的数据，还学会了使用new()函数创建“匿名”的变量。虽然现在看上去并没有什么具体的使用场景，在后面的数组、切片等内容中，便能体会到指针的妙用了。"}),"\n",(0,d.jsx)(e.p,{children:"有了数据，下一步便是数据的运算了。本讲介绍了Go语言中的常用运算符及它们的结合顺序（优先级），在实际开发中使用很常用。"}),"\n",(0,d.jsx)(e.p,{children:"最后，在向某些函数传递数据时，需要按照参数列表的要求传入正确的类型。此时，借助类型转换，可以将数据类型转换为所要求的类型。当然，要充分考虑数据精度丢失的风险。"}),"\n",(0,d.jsx)(e.p,{children:"学习这一讲时，我特别建议大家动手实践，尤其对于编程0基础的同学来说，练习更为重要，切勿停留在理解层面。如果有问题的话，欢迎各位随时在微信群里发问。"}),"\n",(0,d.jsx)(e.p,{children:"➡️ 在下次课程中，我们会阐述如下内容："}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:["Go语言基础语法之流程控制结构，包括：","\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsx)(e.li,{children:"循环结构"}),"\n",(0,d.jsx)(e.li,{children:"流程控制语句"}),"\n",(0,d.jsx)(e.li,{children:"条件分支结构"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h2,{id:"附录一-go语言中的运算符含义及优先级",children:["附录一 Go语言中的运算符、含义及优先级",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#附录一-go语言中的运算符含义及优先级",children:"#"})]}),"\n",(0,d.jsxs)(e.h3,{id:"算术运算符-1",children:["算术运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#算术运算符-1",children:"#"})]}),"\n",(0,d.jsxs)(e.table,{children:["\n",(0,d.jsxs)(e.thead,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.th,{children:"算术运算符"}),"\n",(0,d.jsx)(e.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.tbody,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"+"}),"\n",(0,d.jsx)(e.td,{children:"相加"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"-"}),"\n",(0,d.jsx)(e.td,{children:"相减"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"*"}),"\n",(0,d.jsx)(e.td,{children:"相乘"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"/"}),"\n",(0,d.jsx)(e.td,{children:"相除"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"%"}),"\n",(0,d.jsx)(e.td,{children:"求余数"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"++"}),"\n",(0,d.jsx)(e.td,{children:"自增1"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"--"}),"\n",(0,d.jsx)(e.td,{children:"自减1"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h3,{id:"关系运算符-1",children:["关系运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#关系运算符-1",children:"#"})]}),"\n",(0,d.jsxs)(e.table,{children:["\n",(0,d.jsxs)(e.thead,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.th,{children:"关系运算符"}),"\n",(0,d.jsx)(e.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.tbody,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"=="}),"\n",(0,d.jsx)(e.td,{children:"相等"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"!="}),"\n",(0,d.jsx)(e.td,{children:"不相等"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"<"}),"\n",(0,d.jsx)(e.td,{children:"小于"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"<="}),"\n",(0,d.jsx)(e.td,{children:"小于或等于"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:">"}),"\n",(0,d.jsx)(e.td,{children:"大于"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"> ="}),"\n",(0,d.jsx)(e.td,{children:"大于或等于"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h3,{id:"逻辑运算符-1",children:["逻辑运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑运算符-1",children:"#"})]}),"\n",(0,d.jsxs)(e.table,{children:["\n",(0,d.jsxs)(e.thead,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.th,{children:"逻辑运算符"}),"\n",(0,d.jsx)(e.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.tbody,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"&&"}),"\n",(0,d.jsx)(e.td,{children:"逻辑与（AND），当运算符前后两个条件均为true时，运算结果为true"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"||"}),"\n",(0,d.jsx)(e.td,{children:"逻辑或（OR），当运算符前后两个条件其中有一个为true时，运算结果为true"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"!"}),"\n",(0,d.jsx)(e.td,{children:"逻辑非（NOT），对运算符后面的条件结果取反，当条件结果为true时，整体运算结果为false；反之则为true。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h3,{id:"位运算符-1",children:["位运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#位运算符-1",children:"#"})]}),"\n",(0,d.jsxs)(e.table,{children:["\n",(0,d.jsxs)(e.thead,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.th,{children:"位运算符"}),"\n",(0,d.jsx)(e.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.tbody,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"&"}),"\n",(0,d.jsx)(e.td,{children:"按位与（AND）操作，其结果是运算符前后的两数各对应的二进位相与后的结果。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"|"}),"\n",(0,d.jsx)(e.td,{children:"按位或（OR）操作，其结果是运算符前后的两数各对应的二进位相或后的结果。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"^"}),"\n",(0,d.jsx)(e.td,{children:"按位异或（XOR）操作，当运算符前后的两数各对应的二进位相等时，返回0；反之，返回1。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"&^"}),"\n",(0,d.jsx)(e.td,{children:"按位清空（AND NOT）操作，当运算符右侧某位为1时，运算结果中的相应位值为0；反之，则为运算符左侧相应位的值。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"<<"}),"\n",(0,d.jsx)(e.td,{children:"按位左移操作，该操作本质上是将某个数值乘以2的n次方，n即为左移位数。更直观地来看，其结果就是将某个数值的二进制每个位向左移了n个位置。超限的高位丢弃，低位补0。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:">>"}),"\n",(0,d.jsx)(e.td,{children:"按位右移操作，该操作本质上是将某个数值除以2的n次方，n即为左移位数。更直观地来看，其结果就是将某个数值的二进制每个位向右移了n个位置。超限的低位丢弃，高位补0。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h3,{id:"赋值运算符-1",children:["赋值运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#赋值运算符-1",children:"#"})]}),"\n",(0,d.jsxs)(e.table,{children:["\n",(0,d.jsxs)(e.thead,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.th,{children:"赋值运算符"}),"\n",(0,d.jsx)(e.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.tbody,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"="}),"\n",(0,d.jsx)(e.td,{children:"直接将运算符后面的值赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"+="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值与右侧的值相加，再将相加和赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"-="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值与右侧的值相减，再将相减差赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"*="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值与右侧的值相乘，再将相乘结果赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"/="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值与右侧的值相除，再将相除结果赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"%="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值与右侧的值相除取余数，再将余数赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"<<="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值按位左移右侧数值个位置，再将位移后的结果赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:">>="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值按位右移右侧数值个位置，再将位移后的结果赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"&="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值与右侧的值按位与，再将位运算后的结果赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"^="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值与右侧的值按位异或，再将位运算后的结果赋给左侧。"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"|="}),"\n",(0,d.jsx)(e.td,{children:"先将运算符左侧的值与右侧的值按位或，再将位运算后的结果赋给左侧。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h3,{id:"指针运算符-1",children:["指针运算符",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#指针运算符-1",children:"#"})]}),"\n",(0,d.jsxs)(e.table,{children:["\n",(0,d.jsxs)(e.thead,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.th,{children:"指针运算符"}),"\n",(0,d.jsx)(e.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.tbody,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"&"}),"\n",(0,d.jsx)(e.td,{children:"获取某个变量在内存中的实际地址"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"*"}),"\n",(0,d.jsx)(e.td,{children:"用于声明一个指针变量"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.h3,{id:"运算符优先级",children:["运算符优先级",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#运算符优先级",children:"#"})]}),"\n",(0,d.jsxs)(e.table,{children:["\n",(0,d.jsxs)(e.thead,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.th,{children:"优先级"}),"\n",(0,d.jsx)(e.th,{children:"运算符"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(e.tbody,{children:["\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"1"}),"\n",(0,d.jsx)(e.td,{children:","}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"2"}),"\n",(0,d.jsx)(e.td,{children:"=、+=、-=、*=、/=、 %=、 >=、 <<=、&=、^=、|="}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"3"}),"\n",(0,d.jsx)(e.td,{children:"||"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"4"}),"\n",(0,d.jsx)(e.td,{children:"&&"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"5"}),"\n",(0,d.jsx)(e.td,{children:"|"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"6"}),"\n",(0,d.jsx)(e.td,{children:"^"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"7"}),"\n",(0,d.jsx)(e.td,{children:"&"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"8"}),"\n",(0,d.jsx)(e.td,{children:"==、!="}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"9"}),"\n",(0,d.jsx)(e.td,{children:"<、<=、>、>="}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"10"}),"\n",(0,d.jsx)(e.td,{children:"<<、>>"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"11"}),"\n",(0,d.jsx)(e.td,{children:"+、-"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"12"}),"\n",(0,d.jsx)(e.td,{children:"*（乘号）、/、%"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"13"}),"\n",(0,d.jsx)(e.td,{children:"!、*（指针）、& 、++、--、+（正号）、-（负号）"}),"\n"]}),"\n",(0,d.jsxs)(e.tr,{children:["\n",(0,d.jsx)(e.td,{children:"14"}),"\n",(0,d.jsx)(e.td,{children:"( )、[ ]、->"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"上表中，优先级值越大，优先级越高。"})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(h,{...n})}):h(n)}let x=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC06%E7%AB%A0%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BA%8C%EF%BD%9C%E6%8C%87%E9%92%88%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6.md"]={toc:[{text:"指针类型",id:"指针类型",depth:2},{text:"运算符与优先级",id:"运算符与优先级",depth:2},{text:"算术运算符",id:"算术运算符",depth:4},{text:"关系运算符",id:"关系运算符",depth:4},{text:"逻辑运算符",id:"逻辑运算符",depth:4},{text:"位运算符",id:"位运算符",depth:4},{text:"赋值运算符",id:"赋值运算符",depth:4},{text:"指针运算符",id:"指针运算符",depth:4},{text:"运算符的优先级",id:"运算符的优先级",depth:4},{text:"类型转换",id:"类型转换",depth:2},{text:"小结",id:"小结",depth:2},{text:"附录一 Go语言中的运算符、含义及优先级",id:"附录一-go语言中的运算符含义及优先级",depth:2},{text:"算术运算符",id:"算术运算符-1",depth:3},{text:"关系运算符",id:"关系运算符-1",depth:3},{text:"逻辑运算符",id:"逻辑运算符-1",depth:3},{text:"位运算符",id:"位运算符-1",depth:3},{text:"赋值运算符",id:"赋值运算符-1",depth:3},{text:"指针运算符",id:"指针运算符-1",depth:3},{text:"运算符优先级",id:"运算符优先级",depth:3}],title:"第06章—基础语法二｜指针和运算符",headingTitle:"第06章—基础语法二｜指针和运算符",frontmatter:{}}}}]);