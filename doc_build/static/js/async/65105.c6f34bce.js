"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["65105"],{540564:function(n,e,t){n.exports=t.p+"static/image/74aa81a419badfaf34a03e2ebbdba274.faa2e5d4.gif"},92299:function(n,e,t){n.exports=t.p+"static/image/89665eeceef801428231ab09c9a8b0d4.e52a5b7d.webp"},459903:function(n,e,t){n.exports=t.p+"static/image/ed156d131758af0eb7aae541c5c8519e.faeec5b5.gif"},343109:function(n,e,t){t.r(e),t.d(e,{default:()=>R});var a=t(552676),s=t(740453);let c=t.p+"static/image/dc3e21ab013c9668e8425537c6c9824c.a4984e5d.webp",i=t.p+"static/image/195ae64e1cb23b9c217938853118ef9f.2d6766cd.gif",r=t.p+"static/image/eac51cffe5561b5e24db6bbf60ff9e93.813986b8.webp",o=t.p+"static/image/1f1b4722372887a4d6aa2799f74ab22a.2f5bb9a0.gif",d=t.p+"static/image/920a9a187b0fe8b0cdedcc078df4466b.9f37c92c.webp";var b=t(92299);let l=t.p+"static/image/63fddd4ef29aaf2c0c9795c29c23c669.a042bac9.gif",p=t.p+"static/image/34a86669a2905530f602484af40f3972.1d10eb5d.webp",x=t.p+"static/image/7f59e8a0c0d0cc14619f40c233bbca3d.b768fa3d.gif",u=t.p+"static/image/95601aef8ab52c90ea593039bf2280a6.9b1118b3.webp",m=t.p+"static/image/945a12b558969f2362993f1b1b2ecffe.4aa145e2.gif",j=t.p+"static/image/305519e948a0f656605e1c59b6225771.4c2f49be.webp",h=t.p+"static/image/72f79cade265a99f247ca7908854b7fb.356a9551.webp",f=t.p+"static/image/e2f2c096779cfe07806ee511d3ea3779.e54a6cf0.webp",A=t.p+"static/image/89fd9b6ee8682f69db2cc8008c7b0249.f110ec30.webp",g=t.p+"static/image/9c35f72aa5126d20c1caccb28e5aaa14.54dd8326.webp",v=t.p+"static/image/9af61b98ebba0900ded38cc99fa29417.1fd1d761.gif",C=t.p+"static/image/e6ac1e9b8fde00caa377b3c407e5422e.cbb52426.gif",B=t.p+"static/image/978e908599de68625f167b7681d314b4.49972323.webp",P=t.p+"static/image/9a86a38254700a73b7351d6849edb753.80baff09.gif",k=t.p+"static/image/6542963b7cbf288acaac4205ebba8894.5d60da18.webp",w=t.p+"static/image/cef518783cdbfd1e069ef24cc1ae3c6d.0b782e14.gif",z=t.p+"static/image/c153c56fa46591152b4c8fd5ab06cae6.314360a5.webp",S=t.p+"static/image/22d081f7133a53a9abb5760a9f746fac.5dc23f36.webp",E=t.p+"static/image/9de4714fb543eaec8d9f231a84ef5788.d44a9fd0.gif",y=t.p+"static/image/6d7f441ff48d70def66aef12b8267f77.33ecd98e.webp";var D=t(540564),V=t(459903);let F=t.p+"static/image/00fa4e769a3b9f40cdc36d520e244729.91916177.webp";function T(n){let e=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",strong:"strong",h2:"h2"},(0,s.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"第48章原子化状态管理库jotai",children:["第48章—原子化状态管理库Jotai",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第48章原子化状态管理库jotai",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"\uFEFFJotai 是一个 react 的状态管理库，主打原子化。"}),"\n",(0,a.jsx)(e.p,{children:"提到原子化，你可能会想到原子化 CSS 框架 tailwind。"}),"\n",(0,a.jsx)(e.p,{children:"比如这样的 css："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:'<div class="aaa"></div>\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".aaa {\n    font-size: 16px;\n    border: 1px solid #000;\n    padding: 4px;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"用 tailwind 这样写："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-html",children:'<div class="text-base p-1 border border-black border-solid"></div>\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-css",children:".text-base {\n    font-size: 16px;\n}\n.p-1 {\n    padding: 4px;\n}\n.border {\n    border-width: 1px;\n}\n.border-black {\n    border-color: black;\n}\n.border-solid {\n    border-style: solid;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"定义一系列原子 class，用到的时候组合这些 class。"}),"\n",(0,a.jsx)(e.p,{children:"jotai 也是这个思想："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:F,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,a.jsx)(e.p,{children:"通过 atom 定义一个原子状态，可以把它组合起来成为新的状态。"}),"\n",(0,a.jsx)(e.p,{children:"那状态为什么要原子化呢？"}),"\n",(0,a.jsx)(e.p,{children:"来看个例子："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'import { FC, PropsWithChildren, createContext, useContext, useState } from "react";\n\ninterface ContextType {\n  aaa: number;\n  bbb: number;\n  setAaa: (aaa: number) => void;\n  setBbb: (bbb: number) => void;\n}\n\nconst context = createContext<ContextType>({\n  aaa: 0,\n  bbb: 0,\n  setAaa: () => {},\n  setBbb: () => {}\n});\n\nconst Provider: FC<PropsWithChildren> = ({ children }) => {\n  const [aaa, setAaa] = useState(0);\n  const [bbb, setBbb] = useState(0);\n\n  return (\n    <context.Provider\n      value={{\n        aaa,\n        bbb,\n        setAaa,\n        setBbb\n      }}\n    >\n      {children}\n    </context.Provider>\n  );\n};\n\nconst App = () => (\n  <Provider>\n    <Aaa />\n    <Bbb />\n  </Provider>\n);\n\nconst Aaa = () => {\n  const { aaa, setAaa } = useContext(context);\n  \n  console.log(\'Aaa render...\')\n\n  return <div>\n    aaa: {aaa}\n    <button onClick={() => setAaa(aaa + 1)}>加一</button>\n  </div>;\n};\n\nconst Bbb = () => {\n  const { bbb, setBbb } = useContext(context);\n  \n  console.log("Bbb render...");\n  \n  return <div>\n    bbb: {bbb}\n    <button onClick={() => setBbb(bbb + 1)}>加一</button>\n  </div>;\n};\n\nexport default App;\n\n'})}),"\n",(0,a.jsx)(e.p,{children:"用 createContext 创建了 context，其中保存了 2 个useState 的 state 和 setState 方法。"}),"\n",(0,a.jsx)(e.p,{children:"用 Provider 向其中设置值，在 Aaa、Bbb 组件里用 useContext 取出来渲染。"}),"\n",(0,a.jsx)(e.p,{children:"浏览器访问下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:V,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，修改 aaa 的时候，会同时触发 bbb 组件的渲染，修改 bbb 的时候，也会触发 aaa 组件的渲染。"}),"\n",(0,a.jsx)(e.p,{children:"因为不管修改 aaa 还是 bbb，都是修改 context 的值，会导致所有用到这个 context 的组件重新渲染。"}),"\n",(0,a.jsx)(e.p,{children:"这就是 Context 的问题。"}),"\n",(0,a.jsx)(e.p,{children:"解决方案也很容易想到：拆分成两个 context 不就不会互相影响了？"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:'import { FC, PropsWithChildren, createContext, useContext, useState } from "react";\n\ninterface AaaContextType {\n  aaa: number;\n  setAaa: (aaa: number) => void;\n}\n\nconst aaaContext = createContext<AaaContextType>({\n  aaa: 0,\n  setAaa: () => {}\n});\n\ninterface BbbContextType {\n  bbb: number;\n  setBbb: (bbb: number) => void;\n}\n\nconst bbbContext = createContext<BbbContextType>({\n  bbb: 0,\n  setBbb: () => {}\n});\n\nconst AaaProvider: FC<PropsWithChildren> = ({ children }) => {\n  const [aaa, setAaa] = useState(0);\n\n  return (\n    <aaaContext.Provider\n      value={{\n        aaa,\n        setAaa\n      }}\n    >\n      {children}\n    </aaaContext.Provider>\n  );\n};\n\nconst BbbProvider: FC<PropsWithChildren> = ({ children }) => {\n  const [bbb, setBbb] = useState(0);\n\n  return (\n    <bbbContext.Provider\n      value={{\n        bbb,\n        setBbb\n      }}\n    >\n      {children}\n    </bbbContext.Provider>\n  );\n};\n\nconst App = () => (\n  <AaaProvider>\n    <BbbProvider>\n      <Aaa />\n      <Bbb />\n    </BbbProvider>\n  </AaaProvider>\n);\n\nconst Aaa = () => {\n  const { aaa, setAaa } = useContext(aaaContext);\n  \n  console.log(\'Aaa render...\')\n\n  return <div>\n    aaa: {aaa}\n    <button onClick={() => setAaa(aaa + 1)}>加一</button>\n  </div>;\n};\n\nconst Bbb = () => {\n  const { bbb, setBbb } = useContext(bbbContext);\n  \n  console.log("Bbb render...");\n  \n  return <div>\n    bbb: {bbb}\n    <button onClick={() => setBbb(bbb + 1)}>加一</button>\n  </div>;\n};\n\nexport default App;\n'})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:D,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这样就好了。"}),"\n",(0,a.jsx)(e.p,{children:"这种把状态放到不同的 context 中管理，也是一种原子化的思想。"}),"\n",(0,a.jsx)(e.p,{children:"虽然说这个与 jotai 没啥关系，因为状态管理库不依赖于 context 实现，自然也没那些问题。"}),"\n",(0,a.jsx)(e.p,{children:"但是 jotai 在介绍原子化思想时提到了这个："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:y,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可能你用过 redux、zustand 这些状态管理库，jotai 和它们是完全两种思路。"}),"\n",(0,a.jsx)(e.p,{children:"用 zustand 是这样写："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { create } from 'zustand'\n\nconst useStore = create((set) => ({\n  aaa: 0,\n  bbb: 0,\n  setAaa: (value) => set({ aaa: value}),\n  setBbb: (value) => set({ bbb: value})\n}))\n\nfunction Aaa() {\n    const aaa = useStore(state => state.aaa);\n    const setAaa = useStore((state) => state.setAaa);\n    \n    console.log('Aaa render...')\n    return <div>\n        aaa: {aaa}\n        <button onClick={() => setAaa(aaa + 1)}>加一</button>\n    </div>\n}\n\nfunction Bbb() {\n    const bbb = useStore(state => state.bbb);\n    const setBbb = useStore((state) => state.setBbb);\n\n    console.log('Bbb render...')\n\n    return <div>\n        bbb: {bbb}\n        <button onClick={() => setBbb(bbb + 1)}>加一</button>\n    </div>\n}\n\nexport default function App() {\n    return <div>\n        <Aaa></Aaa>\n        <Bbb></Bbb>\n    </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:E,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"store 里定义全部的 state，然后在组件里选出一部分来用。"}),"\n",(0,a.jsx)(e.p,{children:"这个叫做 selector："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:S,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"状态变了之后，zustand 会对比 selector 出的状态的新旧值，变了才会触发组件重新渲染。"}),"\n",(0,a.jsx)(e.p,{children:"此外，这个 selector 还可以起到派生状态的作用，对原始状态做一些修改："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:z,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"而在 jotai 里，每个状态都是独立的原子："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { atom, useAtom } from 'jotai'; \n\nconst aaaAtom = atom (0);\n\nconst bbbAtom = atom(0);\n\nfunction Aaa() {\n    const [aaa, setAaa]= useAtom(aaaAtom);\n    \n    console.log('Aaa render...')\n    return <div>\n        aaa: {aaa}\n        <button onClick={() => setAaa(aaa + 1)}>加一</button>\n    </div>\n}\n\nfunction Bbb() {\n    const [bbb, setBbb]= useAtom(bbbAtom);\n\n    console.log('Bbb render...')\n\n    return <div>\n        bbb: {bbb}\n        <button onClick={() => setBbb(bbb + 1)}>加一</button>\n    </div>\n}\n\nexport default function App() {\n    return <div>\n        <Aaa></Aaa>\n        <Bbb></Bbb>\n    </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:w,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"状态可以组合，产生派生状态："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:k,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:P,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"而在 zustand 里是通过 selector 来做："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:B,alt:""})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:C,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"不知道大家有没有感受到这两种方式的区别："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"zustand 是所有 state 放在全局 store 里，然后用到的时候 selector 取需要的部分。"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"jotai 是每个 state 单独声明原子状态，用到的时候单独用或者组合用。"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"一个自上而下，一个自下而上，算是两种思路。"})}),"\n",(0,a.jsx)(e.p,{children:"此外，异步逻辑，比如请求服务端接口来拿到数据，这种也是一个放在全局 store，一个单独放在原子状态里："}),"\n",(0,a.jsx)(e.p,{children:"在 zustand 里是这样："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { create } from 'zustand'\n\nasync function getListById(id) {\n    const data = {\n        1: ['a1', 'a2', 'a3'],\n        2: ['b1', 'b2', 'b3', 'b4']\n    }\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(data[id]);\n        }, 2000);\n    });\n}\n\nconst useStore = create((set) => ({\n  list: [],\n  fetchData: async (param) => {\n    const data = await getListById(param);\n    set({ list: data });\n  },\n}))\n\nexport default function App() {\n    const list = useStore(state => state.list);\n    const fetchListData = useStore((state) => state.fetchData);\n\n    return <div>\n        <button onClick={() => fetchListData(1)}>列表111</button>\n        <ul>\n            {\n                list.map(item => {\n                    return <li key={item}>{item}</li>\n                })\n            }\n        </ul>\n    </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"在 store 里添加一个 fetchData 的 async 方法，组件里取出来用就行。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:v,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，2s 后拿到了数据设置到 list，并且触发了组件渲染。"}),"\n",(0,a.jsx)(e.p,{children:"而在 jotai 里，也是单独放在 atom 里的："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { atom, useAtom } from 'jotai'; \n\nasync function getListById(id) {\n    const data = {\n        1: ['a1', 'a2', 'a3'],\n        2: ['b1', 'b2', 'b3', 'b4']\n    }\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(data[id]);\n        }, 2000);\n    });\n}\n\nconst listAtom = atom([]);\n\nconst fetchDataAtom = atom(null, async (get, set, param) => {\n    const data = await getListById(param);\n    set(listAtom, data);\n});\n\nexport default function App() {\n    const [,fetchListData] = useAtom(fetchDataAtom);\n    const [list] = useAtom(listAtom);\n\n    return <div>\n        <button onClick={() => fetchListData(2)}>列表222</button>\n        <ul>\n            {\n                list.map(item => {\n                    return <li key={item}>{item}</li>\n                })\n            }\n        </ul>\n    </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"atom 除了可以直接传值外，也可以分别传入 get、set 函数。"}),"\n",(0,a.jsx)(e.p,{children:"之前的派生状态就是只传入了 get 函数："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:g,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"这样，状态是只读的。"}),"\n",(0,a.jsx)(e.p,{children:"这里我们只传入了 set 函数："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:A,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"所以状态是只能写。"}),"\n",(0,a.jsx)(e.p,{children:"用的时候要取第二个参数："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:f,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"当然，这么写有点费劲，所以 atom 对于只读只写的状态多了两个 hook："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"useAtomValue 是读取值，useSetAtom 是拿到写入函数。"}),"\n",(0,a.jsx)(e.p,{children:"而常用的 useAtom 就是拿到这两者返回值的数组。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:j,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"效果一样："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:m,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"当然，这里没必要用两个 atom，合并成一个就行："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:u,alt:""})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { atom, useAtom, useAtomValue, useSetAtom } from 'jotai'; \n\nasync function getListById(id) {\n    const data = {\n        1: ['a1', 'a2', 'a3'],\n        2: ['b1', 'b2', 'b3', 'b4']\n    }\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(data[id]);\n        }, 2000);\n    });\n}\n\nconst listAtom = atom([]);\n\nconst dataAtom = atom((get) => {\n    return get(listAtom);\n}, async (get, set, param) => {\n    const data = await getListById(param);\n    set(listAtom, data);\n});\n\nexport default function App() {\n    const [list, fetchListData] = useAtom(dataAtom);\n    \n    return <div>\n        <button onClick={() => fetchListData(2)}>列表222</button>\n        <ul>\n            {\n                list.map(item => {\n                    return <li key={item}>{item}</li>\n                })\n            }\n        </ul>\n    </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"此外，用 useSetAtom 有时候可以起到性能优化的作用。"}),"\n",(0,a.jsx)(e.p,{children:"比如这段代码："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { atom, useAtom, useAtomValue, useSetAtom } from 'jotai'; \n\nconst aaaAtom = atom(0);\n\nfunction Aaa() {\n    const [aaa] = useAtom(aaaAtom);\n\n    console.log('Aaa render...');\n\n    return <div>\n        {aaa}\n    </div>\n}\n\nfunction Bbb() {\n    const [, setAaa] = useAtom(aaaAtom);\n\n    console.log('Bbb render...');\n\n    return <div>\n        <button onClick={() => setAaa(Math.random())}>按钮</button>\n    </div>\n}\n\nexport default function App() {\n    return <div>\n        <Aaa></Aaa>\n        <Bbb></Bbb>\n    </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"在 Aaa 组件里读取状态，在 Bbb 组件里修改状态。"}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:x,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"可以看到，点击按钮 Aaa、Bbb 组件都重新渲染了。"}),"\n",(0,a.jsx)(e.p,{children:"而其实 Bbb 组件不需要重新渲染。"}),"\n",(0,a.jsx)(e.p,{children:"这时候可以改一下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"换成 useSetAtom，也就是不需要读取状态值。"}),"\n",(0,a.jsx)(e.p,{children:"这样状态变了就不如触发这个组件的重新渲染了："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"上面 Aaa 组件里也可以简化成 useAtomValue："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { atom, useAtom, useAtomValue, useSetAtom } from 'jotai'; \n\nconst aaaAtom = atom(0);\n\nfunction Aaa() {\n    const aaa = useAtomValue(aaaAtom);\n\n    console.log('Aaa render...');\n\n    return <div>\n        {aaa}\n    </div>\n}\n\nfunction Bbb() {\n    const setAaa = useSetAtom(aaaAtom);\n\n    console.log('Bbb render...');\n\n    return <div>\n        <button onClick={() => setAaa(Math.random())}>按钮</button>\n    </div>\n}\n\nexport default function App() {\n    return <div>\n        <Aaa></Aaa>\n        <Bbb></Bbb>\n    </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"至此，jotai 的核心功能就讲完了："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"通过 atom 创建原子状态，定义的时候还可以单独指定 get、set 函数（或者叫 read、write 函数），用来实现状态派生、异步状态修改。"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"组件里可以用 useAtom 来拿到 get、set 函数，也可以通过 useAtomValue、useSetAtom 分别拿。"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.strong,{children:"不需要读取状态的，用 useSetAtom 还可以避免不必要的渲染。"})}),"\n",(0,a.jsx)(e.p,{children:"那 zustand 支持的中间件机制在 jotai 里怎么实现呢？"}),"\n",(0,a.jsx)(e.p,{children:"zustand 支持通过中间件来修改 get、set 函数："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:b,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"比如在 set 的时候打印日志。"}),"\n",(0,a.jsx)(e.p,{children:"或者用 persist 中间件把状态存储到 localStorage 中："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"zustand 中间件的原理很简单，就是修改了 get、set 函数，做一些额外的事情。"}),"\n",(0,a.jsx)(e.p,{children:"试一下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { create } from 'zustand'\nimport { persist } from 'zustand/middleware'\n\nconst useStore = create(persist((set) => ({\n    count: 0,\n    setCount: (value) => set({ count: value})\n}), {\n    name: 'count-key'\n}))\n\nexport default function App() {\n    const count = useStore(state => state.count);\n    const setCount = useStore((state) => state.setCount);\n    \n    return <div>\n        count: {count}\n        <button onClick={() => setCount(count + 1)}>加一</button>\n    </div>\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"jotai 里是用 utils 包的 atomWithStorage："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:r,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"试一下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"import { useAtom } from 'jotai'\nimport { atomWithStorage } from 'jotai/utils'\n\nconst countAtom = atomWithStorage('count-key2', 0)\n\nexport default function App() {\n    const [count, setCount] = useAtom(countAtom);\n    \n    return <div>\n        count: {count}\n        <button onClick={() => setCount(count + 1)}>加一</button>\n    </div>\n}\n\n"})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"它是怎么实现的呢？和 zustand 的中间件有啥区别么？"}),"\n",(0,a.jsx)(e.p,{children:"看下源码："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"声明一个 atom 来存储状态值，然后又声明了一个 atom 来 get、set 它。"}),"\n",(0,a.jsx)(e.p,{children:"其实和 zustand 中间件修改 get、set 方法的原理是一样的，只不过 atom 本来就支持自定义 get、set 方法。"}),"\n",(0,a.jsxs)(e.h2,{id:"总结",children:["总结",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"今天我们学了状态管理库 jotai，以及它的原子化的思路。"}),"\n",(0,a.jsx)(e.p,{children:"声明原子状态，然后组合成新的状态，和 tailwind 的思路类似。"}),"\n",(0,a.jsx)(e.p,{children:"提到原子化状态管理，都会提到 context 的性能问题，也就是 context 里通过对象存储了多个值的时候，修改一个值，会导致依赖其他值的组件也跟着重新渲染。"}),"\n",(0,a.jsx)(e.p,{children:"所以要拆分 context，这也是原子化状态管理的思想。"}),"\n",(0,a.jsx)(e.p,{children:"zustand 是所有 state 放在全局 store 里，然后用到的时候 selector 取需要的部分。"}),"\n",(0,a.jsx)(e.p,{children:"jotai 是每个 state 单独声明原子状态，用到的时候单独用或者组合用。"}),"\n",(0,a.jsx)(e.p,{children:"一个自上而下，一个自下而上，这是两种思路。"}),"\n",(0,a.jsx)(e.p,{children:"jotai 通过 atom 创建原子状态，定义的时候还可以单独指定 get、set 函数（或者叫 read、write 函数），用来实现状态派生、异步状态修改。"}),"\n",(0,a.jsx)(e.p,{children:"组件里可以用 useAtom 来拿到 get、set 函数，也可以通过 useAtomValue、useSetAtom 分别拿。"}),"\n",(0,a.jsx)(e.p,{children:"不需要读取状态的，用 useSetAtom 还可以避免不必要的渲染。"}),"\n",(0,a.jsx)(e.p,{children:"zustand 的中间件是通过包一层然后修改 get、set 实现的，而 jotai 天然支持 get、set 的修改。"}),"\n",(0,a.jsx)(e.p,{children:"不管是状态、派生状态、异步修改状态、中间件等方面，zustand 和 jotai 都是一样的。"}),"\n",(0,a.jsx)(e.p,{children:"区别只是一个是全局 store 里存储所有 state，一个是声明原子 state，然后组合。"}),"\n",(0,a.jsx)(e.p,{children:"这只是两种思路，没有好坏之分，看你业务需求，适合哪个就用那个，或者你习惯哪种思路就用哪个。"})]})}function L(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(T,{...n})}):T(n)}let R=L;L.__RSPRESS_PAGE_META={},L.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC48%E7%AB%A0%E2%80%94%E5%8E%9F%E5%AD%90%E5%8C%96%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93Jotai.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第48章—原子化状态管理库Jotai",headingTitle:"第48章—原子化状态管理库Jotai",frontmatter:{}}}}]);