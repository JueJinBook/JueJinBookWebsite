"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["21477"],{931204:function(e,n,r){r.r(n),r.d(n,{default:()=>eo});var d=r(552676),i=r(740453);let c=r.p+"static/image/6f164ea3692bb30afd709a09526172a1.45071379.webp",s=r.p+"static/image/0e74c4681b90540582af0aea23990540.7c865c17.webp",l=r.p+"static/image/9e40562b85a1a45acf2b45eec8fe64a0.88ddd9f0.webp",o=r.p+"static/image/3bf7fd0faacb07af27a403964bbe6780.88ddd9f0.webp",h=r.p+"static/image/e81f15d642b4e53d2c70385603101208.f7694310.webp",t=r.p+"static/image/d8028c10c80930ff3ebefb40af19aa10.7fca4f0f.webp",x=r.p+"static/image/1404151daca5ec652211aa2905102ecd.f596697c.webp",a=r.p+"static/image/87d7279ccd13c4cc184968ee800e6dcc.a39482cc.webp",j=r.p+"static/image/c77e3c3885ea50c507635ca14ee8983e.346c8bab.webp",b=r.p+"static/image/4f1a36d36bf7fe20600a0001bef528d0.f6078b41.webp",p=r.p+"static/image/00824ba5aec7f11c13b2b6c58db62ba7.ba6251d6.webp",g=r.p+"static/image/939e0da8f4698a64d633b5e85e5ad0f1.d55bcd8b.webp",m=r.p+"static/image/77eaeaafe6a2fd209aeef10d365ba55b.b737903c.webp",f=r.p+"static/image/9bb8916d2ae6fd0454e6dccf3400f581.439e263a.webp",S=r.p+"static/image/7a19ef757ac82a8680be1f7fc65fe678.50fe9d40.webp",u=r.p+"static/image/abdb4c75de2dd7c80fca0706b378d341.0257ac34.webp",k=r.p+"static/image/57ea0bca1087dbe308fa5c690d7fe6f3.9f94ec03.webp",C=r.p+"static/image/ac23a1515b3e0d9c3f1ffdeee3589120.0e70a38e.webp",w=r.p+"static/image/38bc81ae19748f167b57c09819f15efb.5f6f0b4f.webp",N=r.p+"static/image/0747b7ff1012313ae3adc9f11309cb21.fe90b7ba.webp",L=r.p+"static/image/fd9aeb3504617c0af69cb027ecf879f9.f6078b41.webp",v=r.p+"static/image/46b8eabeefa9a4f443d5467aa0744510.b8e1d789.webp",y=r.p+"static/image/0417cc4af940b10996e1701636344eeb.6de73e59.webp",T=r.p+"static/image/65dac1261d3fa9f987b83afab08c4049.4eceb907.webp",R=r.p+"static/image/66e8b61ec1ad8c753a48397c595429f0.7073c5d8.webp",_=r.p+"static/image/93e37d8242b52f328498d7f3722a7b56.202bfe74.webp",z=r.p+"static/image/5f68bff1d9b7235ffef66b8c47b446ca.8edaed65.webp",W=r.p+"static/image/917c2d9df90671c733d6afa0a242a4aa.ee225ded.webp",E=r.p+"static/image/a5ab0e4fa94f22bb53990326bb4d7b07.22dec36c.webp",q=r.p+"static/image/0e97860c6e1fb4b41d3efb7329c2ec79.ed2c7f90.webp",B=r.p+"static/image/17167d08fee00acecf6fcdb78a766c7a.5c6f6341.webp",Q=r.p+"static/image/bb72bd7efb1f02c3da90a070242379c5.c92423b0.webp",D=r.p+"static/image/66e8e2ea0828bde155d1b36e119e0cd7.74714af9.webp",G=r.p+"static/image/0336834a91a4748ea037707a45e821ed.88070ea6.webp",M=r.p+"static/image/b01e00f107bc013cb65ec3aadebc9fd7.b65e9f79.webp",F=r.p+"static/image/193eea23f29df1562d97905835e85192.3533241e.webp",A=r.p+"static/image/533c36ebcb635316dd07cb75d605a992.bcfe3697.webp",H=r.p+"static/image/7eafd37b312ebf37c3e4644eb6f170bd.5e334411.webp",O=r.p+"static/image/dd347b01cdbae1ce4f055e91dfcefd62.45e26efe.webp",J=r.p+"static/image/911171c475d947282e716a4e70812774.7e23a3c2.webp",Y=r.p+"static/image/3d9bcc04a2967573e37f3b8fa64d89f9.65bdfb52.webp",P=r.p+"static/image/b73da4bd64cd7c10a72adc1d0997b545.fedb5ade.webp",K=r.p+"static/image/97f5a3cc5d78e6487c038e2e1f616b88.3fb9e75f.webp",V=r.p+"static/image/53f8c096b07546dab2264245f48be372.0a5fce60.webp",X=r.p+"static/image/54c314dc14f8c79a0db4093508b34514.178c133e.webp",Z=r.p+"static/image/cb415dd486b893e670262005ff0cbcd8.3981b687.webp",I=r.p+"static/image/0193b7aab3d82bf77d8239cb4f0a4756.e9074348.webp",U=r.p+"static/image/c83fe1889d13559750a83b4b505a9714.2253246d.webp",$=r.p+"static/image/af6456f426b53a93a20f397429ce5727.5fb36090.webp",ee=r.p+"static/image/1688298c96d1da8483b6aae6378b6949.6b621ad8.webp",en=r.p+"static/image/af13c10e7681c8aa620ade9d9f951e87.4ac934ad.webp",er=r.p+"static/image/059165cb4c2a9a6f0271c94c7c4704f1.ed1ceb22.webp",ed=r.p+"static/image/c4da8df27a70ed0420cd1d7fb01be76e.5c132303.webp",ei=r.p+"static/image/caf74350316f2bb23485fdf0ff8f1dea.c663cc48.webp",ec=r.p+"static/image/da46c34d74d05bc61b0d5096372f4db4.f76b3f8e.webp";function es(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",strong:"strong",blockquote:"blockquote",img:"img",pre:"pre",h3:"h3",ul:"ul",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h4:"h4"},(0,i.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"第27章css逻辑属性和逻辑值",children:["第27章—CSS逻辑属性和逻辑值",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第27章css逻辑属性和逻辑值",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["\uFEFF多年来，我们一直用物理关键词来标识 CSS 位置：",(0,d.jsx)(n.code,{children:"top"})," 、",(0,d.jsx)(n.code,{children:"right"})," 、",(0,d.jsx)(n.code,{children:"bottom"})," 和 ",(0,d.jsx)(n.code,{children:"left"})," 。这些词与浏览器视窗本身的物理尺寸有关。任何包含 ",(0,d.jsx)(n.code,{children:"left"})," 的属性都表示位置位于浏览器窗口的左侧。许多属性使用物理位置语法，例如 ",(0,d.jsx)(n.code,{children:"padding"})," 、",(0,d.jsx)(n.code,{children:"margin"})," 、",(0,d.jsx)(n.code,{children:"border"})," 和与位置相关的属性。"]}),"\n",(0,d.jsx)(n.p,{children:"我们已经像这样写了这么多年的 CSS，很难想象改变我们对位置标识的看法。然而，我们在 CSS 中识别位置和方向有了新的发展，它允许我们用更少的代码创建更健壮的 Web 布局！这就是 CSS 逻辑属性和逻辑值。"}),"\n",(0,d.jsxs)(n.p,{children:["随着时间的推移，主流浏览器对 CSS 的逻辑属性和逻辑值的支持越来越好。然而，每当我们想在项目中使用它们时，仍然很难记住它们。",(0,d.jsx)(n.code,{children:"start"})," 是什么意思？",(0,d.jsx)(n.code,{children:"end"})," 意味着什么？不试错就掌握所有细节有点棘手。在这节课中，我将从不同的语言体系（例如汉语体系、拉丁语体系和阿拉伯语体系等）出发，让你开始使用逻辑属性和逻辑值。我将试着用一种直观的方式来思考逻辑属性和逻辑值，希望大家能更好的理解和掌握它们。你准备好了吗？让我们开始吧。"]}),"\n",(0,d.jsxs)(n.h2,{id:"逻辑属性和逻辑值描述了什么",children:["逻辑属性和逻辑值描述了什么？",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑属性和逻辑值描述了什么",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["CSS 的逻辑属性和逻辑值的基本思想是",(0,d.jsx)(n.strong,{children:"我们不会在 CSS 属性和值中使用物理方向"}),"。相反，我们将使用依赖 HTML 文档方向的属性，例如 ",(0,d.jsx)(n.code,{children:'dir="ltr"'})," 或 ",(0,d.jsx)(n.code,{children:'dir="rtl"'})," 。因为，CSS 的逻辑属性和逻辑值能自动响应文本方向和书写模式。这也意味着以前由左和右标识的位置将自动反转为 RTL 布局，水平和垂直属性将自动旋转为垂直书写模式。"]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["如果你不熟悉 ",(0,d.jsx)(n.code,{children:"LTR"})," （从左到右）和 ",(0,d.jsx)(n.code,{children:"RTL"})," （从右到左）或垂直书写模式，我建议你花一点时间阅读 ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.a,{href:"https://s.juejin.cn/ds/iD8fc3g/",target:"_blank",rel:"noopener noreferrer",children:"现代 Web 布局"})})," 中的《",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7161370789680250917/section/7161625525763440647",target:"_blank",rel:"noopener noreferrer",children:"Web 中的向左向右：Flexbox 和 Grid 布局中的 LTR 与 RTL"}),"》和《",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7161370789680250917/section/7161625415935590436",target:"_blank",rel:"noopener noreferrer",children:"Web 中的向左向右：Web 布局中 LTR 切换到 RTL 常见错误"}),"》相关课程。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"我们一起先来看一个最基本的例子："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:ec,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/oNQoBQd",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/oNQoBQd"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"正如你所看到的，上图是 Web 中很常见的卡片组件，它包含了一张缩略图，标题和描述文本，并且卡片缩略图与卡片内容（标题和描述文本）之间有一个间距。其中，英文内容的卡片是一个 LTR （从左到右）的布局，间距位于缩略图的右侧；阿拉伯内容的卡片是一个 RTL （从右到左）的布局，间距位于缩略图的左侧，刚好与英文内容的间距相反。"}),"\n",(0,d.jsx)(n.p,{children:"在还没有 CSS 逻辑属性的情况之下，我们需要像下面这样写 CSS ："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'.card img {\n \xa0 \xa0margin-right: 1.5rem;\n}\n​\n.card[dir="rtl"] img {\n \xa0 \xa0margin-left: 1.5rem;\n \xa0 \xa0margin-right: 0;\n}\n'})}),"\n",(0,d.jsxs)(n.p,{children:["注意，对于 RTL 布局，",(0,d.jsx)(n.code,{children:"margin-right"})," 被重置为 ",(0,d.jsx)(n.code,{children:"0"})," ，因为那里不需要它。想象一下，如果在一个大型项目中这样做，你的 CSS 代码将会变得非常臃肿，而且难于维护，并且在下次更新的过程中也很容易出错。"]}),"\n",(0,d.jsx)(n.p,{children:"要是使用 CSS 逻辑属性的话，这一切就显得很方便，你只需要一行 CSS 代码即可实现："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".card img {\n \xa0 \xa0margin-inline-end: 1.5rem;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:ei,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/KKryaYz",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/KKryaYz"})]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["CSS 的 ",(0,d.jsx)(n.code,{children:"margin-inline-end"})," 属性将会将根据 HTML 文档的方向自动调整外边距的位置。这就是 CSS 逻辑属性的强大之处。"]}),"\n",(0,d.jsxs)(n.p,{children:["当然，你可能会对 ",(0,d.jsx)(n.code,{children:"margin-inline-end"})," 属性中的 ",(0,d.jsx)(n.code,{children:"inline"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 感到好奇，它们分别表示什么意思？又应该如何使用？要回答这些个问题，我们就有必要花点时间来了解一些基础理论知识。"]}),"\n",(0,d.jsxs)(n.h2,{id:"需要理解和掌握的术语",children:["需要理解和掌握的术语",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#需要理解和掌握的术语",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"top"})," 、",(0,d.jsx)(n.code,{children:"right"})," 、",(0,d.jsx)(n.code,{children:"bottom"})," 和 ",(0,d.jsx)(n.code,{children:"left"})," 等物理属性指的是浏览器视窗的物理方向。你可以把它们想象成地图上的罗盘："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:ed,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"另一方面，逻辑属性指的是与内容流相关的框的边缘。因此，如果文本方向或书写方式发生变化，它们也会发生变化。这是方向性样式的一大转变，它给了我们在设计界面样式时更多的灵活性。"}),"\n",(0,d.jsxs)(n.h3,{id:"文档流",children:["文档流",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#文档流",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"任何语言都有自身的书写模式和阅读模式。比如，在拉丁语体系（例如英文、德文和法文），字母和单词从左到右流动，而段落从上到下堆叠。在阿拉伯语系（例如阿拉伯语和希伯来语），字母和单词从右到左流动，而段落从上到下堆叠。在繁体中文中，字母和单词从上到下排列，而段落从右到左排列。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:er,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["也就是说，页面的内容会根据语言的书写模式和阅读模式有所不同。映射到 Web 页面中，那就是页面内容根据文档方向变化而更新时，布局及其元素也会发生变化。我们时常把这种变化（即页面内容根据文档方向变化而更新时，布局及元素也发生变化）视为流（Flow），即文档流（有时也称为正常流）。也意味着方向、字母、单词和内容需要沿着方向移动。这就引出流的另外两个概念，即",(0,d.jsx)(n.strong,{children:"块流"})," （Block Flow）和",(0,d.jsx)(n.strong,{children:"内联流"})," （Inline Flow）。"]}),"\n",(0,d.jsxs)(n.h3,{id:"块流",children:["块流",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#块流",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"块流是文档中内容块放置的方向。例如，如果有两个段落，那么块流就是第二段的位置。在英文文档中，块流是从上到下的。把它想象成一段又一段的文本，从上到下。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:en,alt:"img"})}),"\n",(0,d.jsxs)(n.h3,{id:"内联流",children:["内联流",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内联流",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["内联流是文本在句子中的流动方式。在英文文档中，内联流是从左到右的。如果将 Web 的文档语言更改为阿拉伯语(",(0,d.jsx)(n.code,{children:'<html lang="ar">'}),")，则内联流将从右向左。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:ee,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"注意，内联流也常称为文本流。"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["文本的流动方向由文档的书写模式决定。可以使用 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 属性更改文本布局的方向。这可以应用于整个文档，也可以应用于单个元素。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:$,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/qBQVryv",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/qBQVryv"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"这里所说的块流和文本流，主要指的是 HTML 块元素的流动方向和文本内容的流动方向，其中文本流也常称“内联方向”："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:U,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"在 Web 中除了文档有流方向一说之外，对于文本同样有流的概念，比如说英文，一般是从左到右，阿拉伯文是从右到左，而日文（古代的中文）从上到下，从右到左："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:I,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["不管是文档流还是文本流，它们都具有相应的物理特性，比如从左到右，从右到左，从上到下，从下到上。即，它们都没有离开 ",(0,d.jsx)(n.code,{children:"top"}),"、",(0,d.jsx)(n.code,{children:"right"}),"、",(0,d.jsx)(n.code,{children:"bottom"})," 和 ",(0,d.jsx)(n.code,{children:"left"})," 方向。这也是 CSS 中为什么有那么多属性和值都与方向有着紧密联系的原因所在。比如："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"text-align"})," 属性：用于指定文本的对齐方式，属性值包括 ",(0,d.jsx)(n.code,{children:"left"}),"（左对齐）、",(0,d.jsx)(n.code,{children:"right"}),"（右对齐）和 ",(0,d.jsx)(n.code,{children:"center"}),"（居中对齐）。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"vertical-align"})," 属性：用于指定元素内容的垂直对齐方式，属性值包括 ",(0,d.jsx)(n.code,{children:"top"}),"（顶端对齐）、",(0,d.jsx)(n.code,{children:"bottom"}),"（底端对齐）和 ",(0,d.jsx)(n.code,{children:"middle"}),"（居中对齐）。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"position"})," 属性：用来设置元素的定位方式，取值 ",(0,d.jsx)(n.code,{children:"relative"}),"、",(0,d.jsx)(n.code,{children:"absolute"}),"、",(0,d.jsx)(n.code,{children:"fixed"}),"、",(0,d.jsx)(n.code,{children:"sticky"}),"，配合 ",(0,d.jsx)(n.code,{children:"top"})," 、",(0,d.jsx)(n.code,{children:"right"})," 、",(0,d.jsx)(n.code,{children:"bottom"})," 和 ",(0,d.jsx)(n.code,{children:"left"})," 值，可以对元素进行精确定位。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"margin-top"}),"、",(0,d.jsx)(n.code,{children:"margin-right"}),"、",(0,d.jsx)(n.code,{children:"margin-bottom"}),"、",(0,d.jsx)(n.code,{children:"margin-left"})," 属性：用于设置元素的外边距，四个方向的值可以单独设置。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"padding-top"}),"、",(0,d.jsx)(n.code,{children:"padding-right"}),"、",(0,d.jsx)(n.code,{children:"padding-bottom"}),"、",(0,d.jsx)(n.code,{children:"padding-left"})," 属性：用于设置元素的内边距，四个方向的值可以单独设置。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"border-top"}),"、",(0,d.jsx)(n.code,{children:"border-right"}),"、",(0,d.jsx)(n.code,{children:"border-bottom"}),"、",(0,d.jsx)(n.code,{children:"border-left"})," 属性：用于设置元素的边框，四个方向的值可以单独设置，还可以结合 ",(0,d.jsx)(n.code,{children:"border-style"}),"（边框样式）、",(0,d.jsx)(n.code,{children:"border-width"}),"（边框宽度）等属性一起使用。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"border-top-left-radius"})," 、",(0,d.jsx)(n.code,{children:"border-top-right-radius"})," 、",(0,d.jsx)(n.code,{children:"border-bottom-right-radius"})," 、",(0,d.jsx)(n.code,{children:"border-bottom-left-radius"})," 属性：用于设置元素的圆角，四个顶点的值可以单独设置。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"linear-gradient()"})," 和 ",(0,d.jsx)(n.code,{children:"repeating-linear-gradient()"})," 属性：",(0,d.jsx)(n.code,{children:"to right"})," 、",(0,d.jsx)(n.code,{children:"to left"})," 、",(0,d.jsx)(n.code,{children:"to top"})," 和 ",(0,d.jsx)(n.code,{children:"to bottom"})," 可以设定渐变的方向、起点和终点颜色。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"float"})," 属性的值可以设置为 ",(0,d.jsx)(n.code,{children:"left"}),"、",(0,d.jsx)(n.code,{children:"right"})," ，分别表示浮动在左边、右边。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"clear"})," 属性的值可以设置为 ",(0,d.jsx)(n.code,{children:"left"}),"、 ",(0,d.jsx)(n.code,{children:"right"}),"，分别表示清除浮动元素在左边、右边。"]}),"\n",(0,d.jsxs)(n.li,{children:["CSS Flexbox 布局中的 ",(0,d.jsx)(n.code,{children:"flex-direction"})," 和 CSS Grid 布局中的 ",(0,d.jsx)(n.code,{children:"grid-auto-flow"})," 。"]}),"\n",(0,d.jsx)(n.li,{children:"CSS 框对齐相关的属性。"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["这些与 ",(0,d.jsx)(n.code,{children:"top"})," 、",(0,d.jsx)(n.code,{children:"right"})," 、",(0,d.jsx)(n.code,{children:"bottom"})," 和 ",(0,d.jsx)(n.code,{children:"left"})," 方向有关联的属性和值，都被统称为 ",(0,d.jsx)(n.strong,{children:"CSS 物理属性或值"}),"，它们最终在浏览器的呈现都会受到 HTML 的 ",(0,d.jsx)(n.code,{children:"dir"})," 、CSS 的 ",(0,d.jsx)(n.code,{children:"direction"})," （指定文本方向）、",(0,d.jsx)(n.code,{children:"writing-mode"})," （控制文本排列方式）、",(0,d.jsx)(n.code,{children:"text-orientation"})," （控制文本方向）和 ",(0,d.jsx)(n.code,{children:"unicode-bidi"})," （设置双向文本的方向）等属性的影响。"]}),"\n",(0,d.jsxs)(n.h3,{id:"内联和块的区别",children:["内联和块的区别",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内联和块的区别",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在默认情况下，CSS 元素的内容是从左到右排列。但是对于某些语言或特定的排版需求，需要从右到左排列，或从上到下排列等。通常这种从左到右、从上到下的排列方向分别是沿着 Web 坐标轴的 ",(0,d.jsx)(n.code,{children:"x"})," 轴（水平方向）和 ",(0,d.jsx)(n.code,{children:"y"})," 轴（垂直方向）排列的。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们都知道，在 Web 中有一个坐标系统，它分为 ",(0,d.jsx)(n.code,{children:"x"})," 轴和 ",(0,d.jsx)(n.code,{children:"y"})," 轴："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:Z,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["CSS 中的任一元素可以在这个坐标系统中沿着 ",(0,d.jsx)(n.code,{children:"x"})," 轴向左或向右移动位置，也可以沿着 ",(0,d.jsx)(n.code,{children:"y"})," 轴向上或向下移动位置。它们具有明确的物理方向："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"x"})," 轴方向有 ",(0,d.jsx)(n.code,{children:"left"})," 和 ",(0,d.jsx)(n.code,{children:"right"})," ；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"y"})," 轴方向有 ",(0,d.jsx)(n.code,{children:"top"})," 和 ",(0,d.jsx)(n.code,{children:"bottom"})," 。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["除此之外，CSS 中还有一个",(0,d.jsx)(n.strong,{children:"流"}),"的概念，也就是我们常说的",(0,d.jsx)(n.strong,{children:"文档流（Document Flow）"})," ，它指的是元素在 HTML 文档中的流动方向。在 HTML 文档中，元素通常从上到下（块元素）、从左到右（内联元素）依次排列。而且 Web 布局也是基于这个顺序进行排列的。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:X,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["如果你想改变元素在文档流中的位置，就需要使用一些 ",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7161370789680250917?utm_source=profile_book",target:"_blank",rel:"noopener noreferrer",children:"Web 布局技巧"}),"，例如浮动（",(0,d.jsx)(n.code,{children:"float"}),"）、定位（",(0,d.jsx)(n.code,{children:"position"}),"）、Flexbox 和 Grid 布局等。"]}),"\n",(0,d.jsx)(n.p,{children:"同样的，Web 中的文本也存在流的概念。在拉丁语体系中（比如英文），字母和单词从左到右流动，而段落从上到下垂直排列；在阿拉伯语体系中（比如阿拉伯语），字母和单词从右到左流动，而段落从上到下垂直排列；在传统的汉语体系中（比如中文和日文），字和词从上到下排列，而段落从右到左水平排列。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:V,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["正如上图所示，在一个多语言 Web 应用或网站中，页面的内容和布局应该能随着 HTML 文档方向更改而自动更新。换句话说，CSS 中的流意味着",(0,d.jsx)(n.strong,{children:"方向"}),"，字母、单词和内容以及布局都需要沿着流移动。这将引导我们进入块和内联逻辑方向。"]}),"\n",(0,d.jsxs)(n.p,{children:["也就是说，随着 CSS 的逻辑属性的出现，CSS 的坐标系就不再以 ",(0,d.jsx)(n.code,{children:"x"})," 轴 和 ",(0,d.jsx)(n.code,{children:"y"})," 轴来定义，而是以 ",(0,d.jsx)(n.strong,{children:"内联"})," （Inline）和 ",(0,d.jsx)(n.strong,{children:"块"})," （Block）来区分："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"内联维度是在使用的书写模式中运行的文本行（文本流）所在的维度。即，对应于文本流（阅读方式）的轴线。例如，英文是从左到右的文本流（或阿拉伯文从右到左），因此内联轴是水平的；对于日文，它的阅读方式是自上而下，因此内联轴是垂直的。"}),"\n",(0,d.jsx)(n.li,{children:"块维度是另一个维度，以及块（如段落）相继显示的方向。在英语和阿拉伯语中，这些是垂直的，而在任何垂直书写模式中，这些是水平的。"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"它们随着 CSS 的书写模式改变，如下图所示："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:K,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"我们可以换过一种方式来理解："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"块轴"})," ：主要定义网站文档（元素块）流，CSS 的书写模式 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 会影响块轴的方向；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"内联轴"})," ：主要定义网站的文本流方向，也就是文本的阅读方式，CSS 的 ",(0,d.jsx)(n.code,{children:"direction"})," 或 HTML 的",(0,d.jsx)(n.code,{children:"dir"})," 会影响内联轴的方向。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["简单地说，",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"writing-mode"})})," ",(0,d.jsx)(n.strong,{children:"能很好地和块轴、行内轴、阅读模式以及书写模式结合起来"})," ："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:P,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"为了更好地匹配书写模式或者说多语言的 Web 布局，我们需要从一些理念上做出改变。"}),"\n",(0,d.jsxs)(n.p,{children:["换句话说，在使用 CSS 逻辑属性时，你经常会看到关键词 ",(0,d.jsx)(n.code,{children:"inline"})," 或 ",(0,d.jsx)(n.code,{children:"block"})," 。根据书写方式的不同，内联或块的含义会发生变化。对于像英语这样的语言，内联是水平方向（",(0,d.jsx)(n.code,{children:"x"})," 轴），块是垂直方向（",(0,d.jsx)(n.code,{children:"y"})," 轴）。对于像日语这样的语言，内联是垂直方向（",(0,d.jsx)(n.code,{children:"y"})," 轴），块是水平方向（",(0,d.jsx)(n.code,{children:"x"}),"）。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:Y,alt:"img"})}),"\n",(0,d.jsxs)(n.h3,{id:"开始与结束",children:["开始与结束",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#开始与结束",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在逻辑属性中除了能经常看到 ",(0,d.jsx)(n.code,{children:"inline"})," 和 ",(0,d.jsx)(n.code,{children:"block"})," 之外，还能经常看到另外两个关键词，即 ",(0,d.jsx)(n.code,{children:"start"})," （开始）和 ",(0,d.jsx)(n.code,{children:"end"})," （结束），它们代表着流的开始和结束位置。即："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"block-start"})," 表示块流的开始位置"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"block-end"})," 表示块流的结束位置"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"inline-start"})," 表示内联流的开始位置"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"inline-end"})," 表示内联流的结束位置"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["更为有意思的是，它们与 HTML 的 ",(0,d.jsx)(n.code,{children:"dir"})," 属性以及 CSS 的 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 和 ",(0,d.jsx)(n.code,{children:"direction"})," 属性有一定的关联。这些特性都将影响 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 的位置。拿内联流的 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 为例，在 HTML 中，我们可以在元素标签上使用 ",(0,d.jsx)(n.code,{children:"dir"})," 属性来指定它们："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:'dir="ltr"'})," ：对应着 LTR 模式，汉语体系和拉丁语体系都是这种模式；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:'dir="rtl"'})," ：对应着 RTL 模式，阿拉伯语体系都是该模式。"]}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-HTML",children:'\x3c!-- RTL --\x3e\n<html lang="ar" dir="rtl">\n \xa0 \xa0<body>\n \xa0 \xa0 \xa0 \xa0<h1>مياه للجميع، مستقبل مشترك</h1>\n \xa0 \xa0</body>\n</html>\n​\n\x3c!-- LTR --\x3e\n<html lang="zh" dir="ltr">\n \xa0 \xa0<body>\n \xa0 \xa0 \xa0 \xa0<h1>人人有水、共享未来</h1>\n \xa0 \xa0</body>\n</html>\n'})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:J,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["CSS 中的 ",(0,d.jsx)(n.code,{children:"direction"})," 和 HTML 的 ",(0,d.jsx)(n.code,{children:"dir"})," 是完全相同的。我们可以在 CSS 中使用 ",(0,d.jsx)(n.code,{children:"direction"})," 来改为阅读模式："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"ltr"})," ：对应着 LTR 模式，汉语体系和拉丁语体系都是这种模式；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"rtl"})," ：对应着 RTL 模式，阿拉伯语体系都是该模式。"]}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'[lang="ar"] {\n \xa0 \xa0direction: rtl;\n}\n​\n[lange="zh"] {\n \xa0 \xa0direction: ltr;\n}\n'})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:O,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"汉语、日语、韩语和蒙古语既可以从左到右水平书写，也可以从上到下垂直书写。大多数这些语言的网站都是水平的，和英语一样。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:H,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"相比之下，垂直书写在日本网站上更为常见。有些网站同时使用垂直和水平文本。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:A,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["对于垂直书写（从上到下且从右到左或从上到下且从左到右）模式，HTML 的 ",(0,d.jsx)(n.code,{children:"dir"})," 和 CSS 的 ",(0,d.jsx)(n.code,{children:"direction"})," 是无法实现的。庆幸的是，CSS 中有一个名为书写模式的模块，即 ",(0,d.jsx)(n.code,{children:"writting-mode"})," ，它可以做到："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"horizontal-tb"})})," ：定义了内容从左到右水平流动（内联流），从上到下垂直流动（块流）。下一条水平线位于上一条线下方；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"vertical-rl"})})," ：定义了内容从上到下垂直流动（内联流），从右到左水平流动（块流）。下一条垂直线位于上一行的左侧；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"vertical-lr"})})," ：定义了内容从上到下垂直流动（内联流），从左到右水平流动 （块流）。下一条垂直线位于上一行的右侧；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"sideways-rl"})})," ：定义了内容从上到下垂直流动，所有字形，甚至是垂直脚本中的字形，都设置在右侧；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"sideways-lr"})})," ：内容从上到下垂直流动，所有字形，甚至是垂直脚本中的字形，都设置在左侧。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["也就是说，在使用 CSS 逻辑属性或逻辑值时，我们将会使用 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 来替代以往的 TRBL（即 ",(0,d.jsx)(n.code,{children:"top"})," 、",(0,d.jsx)(n.code,{children:"right"})," 、",(0,d.jsx)(n.code,{children:"bottom"})," 和 ",(0,d.jsx)(n.code,{children:"left"})," ）："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsxs)(n.strong,{children:["开始（",(0,d.jsx)(n.code,{children:"start"}),"）"]})," 这对应于文本的方向，并反映了文本的侧边，你将从哪里开始阅读。对于英文，开始对应于左。对于阿位伯文来说，对应于右。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsxs)(n.strong,{children:["结束（",(0,d.jsx)(n.code,{children:"end"}),"）"]})," 这也对应于文本的方向，并反映了文本的侧边，你将在哪里结束阅读。对于英文，结束对应于右。对于阿拉伯文来说，对应于左。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:F,alt:"img"})}),"\n",(0,d.jsxs)(n.h3,{id:"逻辑维度",children:["逻辑维度",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑维度",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在使用 CSS 逻辑属性或值时，是基于逻辑维度进行的，即使用“逻辑维度”替代“物理维度”。前面的内联轴、块轴、开始和结束结合起来可以构建 CSS 逻辑属性中的流相对值。即 ",(0,d.jsx)(n.code,{children:"block-start"})," 、",(0,d.jsx)(n.code,{children:"block-end"})," 、 ",(0,d.jsx)(n.code,{children:"inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"inline-end"})," 。这几个属性也被称为",(0,d.jsx)(n.strong,{children:"逻辑维度"})," ，其实就是用来指定在对应轴上的开始和结束位置。它们对应的就是我们熟悉的 ",(0,d.jsx)(n.code,{children:"top"})," 、",(0,d.jsx)(n.code,{children:"right"})," 、 ",(0,d.jsx)(n.code,{children:"bottom"})," 和 ",(0,d.jsx)(n.code,{children:"left"})," 几个物理方向。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:M,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["换句话说，在 CSS 逻辑中，使用流相对值来代替相应的物理值。正如前面所述，流相对值（逻辑维度）和 CSS 的书写模式 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 或阅读方式 ",(0,d.jsx)(n.code,{children:"direction"})," 有关。"]}),"\n",(0,d.jsxs)(n.p,{children:["接下来，我们通过几种典型的语言为例，来向大家阐述逻辑维度和物理维度的映射关系。 首先来看英文，英文的阅读方式一般是从左往右（即 ",(0,d.jsx)(n.code,{children:"dirction: ltr"})," 和 ",(0,d.jsx)(n.code,{children:"writing-mode:horizontal-tb"})," ），这种模式常称为 ",(0,d.jsx)(n.strong,{children:"LTR"})," （Left-To-Right）。它的内联轴是水平的，块轴是垂直的，相应的逻辑维度和物理维度映射关系如下："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:G,alt:"img"})}),"\n",(0,d.jsxs)(n.table,{children:["\n",(0,d.jsxs)(n.thead,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"逻辑维度"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"物理维度"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.tbody,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-start"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"left"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-end"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"right"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block-start"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"top"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block-end"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"bottom"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["接着来看阿拉伯文，它的阅读方式是从右往左（即 ",(0,d.jsx)(n.code,{children:"direction: rtl"})," 和 ",(0,d.jsx)(n.code,{children:"writing-mode:horizontal-tb"}),"），这种模式常称为 ",(0,d.jsx)(n.strong,{children:"RTL"})," （Right-To-Left）。它的内联轴是水平的，块轴是垂直的，相应的逻辑维度和物理维度映射关系如下："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:D,alt:"img"})}),"\n",(0,d.jsxs)(n.table,{children:["\n",(0,d.jsxs)(n.thead,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"逻辑维度"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"物理维度"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.tbody,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-start"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"right"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-end"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"left"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block-start"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"top"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block-end"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"bottom"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["再来看日文，竖排（有点类似中国古代的汉字书写模式），对应的 ",(0,d.jsx)(n.code,{children:"writing-mode: vertical-rl"})," 。它的内联轴是垂直的，块轴是水平的，相应的逻辑维度和物理维度映射关系如下："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:Q,alt:"img"})}),"\n",(0,d.jsxs)(n.table,{children:["\n",(0,d.jsxs)(n.thead,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"逻辑维度"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"物理维度"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.tbody,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-start"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"top"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-end"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"bottom"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block-start"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"right"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block-end"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"left"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["最后再来看蒙文，也是竖排，和日文不同的是 ",(0,d.jsx)(n.code,{children:"writing-mode: vertical-lr"})," 。它的内联轴是垂直的，块轴是水平的，相应的逻辑维度和物理维度映射关系如下："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:B,alt:"img"})}),"\n",(0,d.jsxs)(n.table,{children:["\n",(0,d.jsxs)(n.thead,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"逻辑维度"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"物理维度"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.tbody,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-start"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"top"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-end"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"bottom"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block-start"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"left"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block-end"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"right"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"css-逻辑属性和逻辑值",children:["CSS 逻辑属性和逻辑值",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑属性和逻辑值",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在 CSS 中有许多 CSS 属性和值都有逻辑替代语法。",(0,d.jsx)(n.a,{href:"https://codepen.io/aardrian/full/bGGxrvM",target:"_blank",rel:"noopener noreferrer",children:"@Adrian Roselli 在 CodePen 上提供了一个 Demo"}),"，可视化展示常用 CSS 属性和值对应的逻辑属性和逻辑值。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:q,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/wvQpqya",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/wvQpqya"})]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["示仅展示了 ",(0,d.jsx)(n.code,{children:"direction"})," 为 ",(0,d.jsx)(n.code,{children:"ltr"})," 和 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 为 ",(0,d.jsx)(n.code,{children:"horizontal-tb"})," 时，物理属性和值所映射的逻辑属性和逻辑值。"]}),"\n",(0,d.jsxs)(n.p,{children:["我们来进一步分解所有 CSS 逻辑属性和逻辑值，但请记住，",(0,d.jsx)(n.strong,{children:"逻辑属性和逻辑值的关键在于它们会根据上下文而变化"}),"！"]}),"\n",(0,d.jsxs)(n.h3,{id:"css-逻辑属性",children:["CSS 逻辑属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑属性",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"先从 CSS 逻辑属性开始！"}),"\n",(0,d.jsxs)(n.h4,{id:"css-逻辑尺寸",children:["CSS 逻辑尺寸",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑尺寸",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["元素的宽度（",(0,d.jsx)(n.code,{children:"width"}),"）和高度（",(0,d.jsx)(n.code,{children:"height"}),"）属性有相对应的逻辑属性。一旦我们理解了内联和块的概念，就更容易理解 CSS 的逻辑尺寸。"]}),"\n",(0,d.jsxs)(n.p,{children:["在水平书写模式下（例如 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 的值为 ",(0,d.jsx)(n.code,{children:"horizontal-tb"})," ），",(0,d.jsx)(n.code,{children:"inline-size"})," 用来设置元素的宽度（",(0,d.jsx)(n.code,{children:"width"}),"），而 ",(0,d.jsx)(n.code,{children:"block-size"})," 用来设置元素的高度（",(0,d.jsx)(n.code,{children:"height"}),"）。在垂直书写模式下（例如 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 的值为 ",(0,d.jsx)(n.code,{children:"vertical-rl"})," 或 ",(0,d.jsx)(n.code,{children:"vertical-lr"}),"），情况正好相反：",(0,d.jsx)(n.code,{children:"inline-size"})," 用来设置元素的高度（",(0,d.jsx)(n.code,{children:"height"}),"），",(0,d.jsx)(n.code,{children:"block-size"})," 用来设置元素的宽度（",(0,d.jsx)(n.code,{children:"width"}),"）。"]}),"\n",(0,d.jsx)(n.p,{children:"例如，在英文（LTR）和阿拉伯文（RTL）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"width = inline-size\nheight = block-size\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在自上而下（阅读模式）的语言中，比如日语（",(0,d.jsx)(n.code,{children:"writing-mode:vertical-rl"})," ），我们看到的情况是相反的："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"width = block-size\nheight = inline-size\n"})}),"\n",(0,d.jsx)(n.p,{children:"来看一个具体的示例："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'.card {\n \xa0 \xa0inline-size: 300px;\n \xa0 \xa0block-size: 100px;\n}\n​\n.card[lang="jp"] {\n \xa0 \xa0writing-mode: vertical-rl;\n}\n'})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:E,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/jOQYLom",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/jOQYLom"})]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["需要知道的是，上面所述的逻辑属性也适用于 ",(0,d.jsx)(n.code,{children:"max-*"})," 和 ",(0,d.jsx)(n.code,{children:"min-*"})," 对应的属性。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:W,alt:"img"})}),"\n",(0,d.jsxs)(n.h4,{id:"css-逻辑边框",children:["CSS 逻辑边框",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑边框",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在 CSS 中，我们一般使用 ",(0,d.jsx)(n.code,{children:"border"})," 以及它的子属性 ",(0,d.jsx)(n.code,{children:"border-top"})," 、",(0,d.jsx)(n.code,{children:"border-right"})," 、",(0,d.jsx)(n.code,{children:"border-bottom"})," 和 ",(0,d.jsx)(n.code,{children:"border-left"})," 来设置元素的边框，它们也有相应的逻辑属性。比如 ",(0,d.jsx)(n.code,{children:"border-inline-start"})," 、",(0,d.jsx)(n.code,{children:"border-inline-end"})," 、 ",(0,d.jsx)(n.code,{children:"border-block-start"})," 和 ",(0,d.jsx)(n.code,{children:"border-block-end"})," 等。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'.card {\n \xa0 \xa0border-inline-start: 2px solid red;\n \xa0 \xa0border-inline-end: 4px solid blue;\n \xa0 \xa0border-block-start: 6px solid green;\n \xa0 \xa0border-block-end: 8px solid lime;\n}\n​\n.card[lang="jp"] {\n \xa0 \xa0writing-mode: vertical-rl;\n}\n'})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:z,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/ZEmvaEN",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/ZEmvaEN"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"在英文（LTR）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"border-top \xa0  = border-block-start\nborder-right  = border-inline-end\nborder-bottom = border-block-end\nborder-left \xa0 = border-inline-start\n"})}),"\n",(0,d.jsx)(n.p,{children:"在阿拉伯文（RTL）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"border-top \xa0  = border-block-start\nborder-right  = border-inline-start\nborder-bottom = border-block-end\nborder-left \xa0 = border-inline-end\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在自上而下（阅读模式）的语言中，比如日语（",(0,d.jsx)(n.code,{children:"writing-mode:vertical-rl"})," ）："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"border-top \xa0  = border-inline-start\nborder-right  = border-block-start\nborder-bottom = border-inline-end\nborder-left \xa0 = border-block-end\n"})}),"\n",(0,d.jsxs)(n.p,{children:["CSS 的边框（",(0,d.jsx)(n.code,{children:"border"}),"）子属性还可以根据方向来单独设置边框颜色（",(0,d.jsx)(n.code,{children:"border-color"}),"）、边框粗细（",(0,d.jsx)(n.code,{children:"border-width"}),"）和边框样式（",(0,d.jsx)(n.code,{children:"border-style"}),"）。它们是 ",(0,d.jsx)(n.code,{children:"border-top-width"}),"、",(0,d.jsx)(n.code,{children:"border-right-width"})," 、",(0,d.jsx)(n.code,{children:"border-bottom-width"})," 、",(0,d.jsx)(n.code,{children:"border-left-width"})," 、",(0,d.jsx)(n.code,{children:"border-top-style"})," 、",(0,d.jsx)(n.code,{children:"border-right-style"})," 、",(0,d.jsx)(n.code,{children:"border-bottom-style"})," 、",(0,d.jsx)(n.code,{children:"border-left-style"})," 、",(0,d.jsx)(n.code,{children:"border-top-color"})," 、",(0,d.jsx)(n.code,{children:"border-right-color"})," 、",(0,d.jsx)(n.code,{children:"border-bottom-color"})," 和 ",(0,d.jsx)(n.code,{children:"border-left-color"})," 等物理属性。在 CSS 中，这些与边框相关的物理属性也有相应的逻辑属性。即在 ",(0,d.jsx)(n.code,{children:"-width"})," 、",(0,d.jsx)(n.code,{children:"-color"})," 和 ",(0,d.jsx)(n.code,{children:"-style"})," 前面加上 ",(0,d.jsx)(n.code,{children:"border-inline-start"})," 、",(0,d.jsx)(n.code,{children:"border-inline-end"})," 、",(0,d.jsx)(n.code,{children:"border-block-start"})," 和 ",(0,d.jsx)(n.code,{children:"border-block-end"})," ，例如逻辑边框颜色，",(0,d.jsx)(n.code,{children:"border-inline-start-color"})," 、",(0,d.jsx)(n.code,{children:"border-inline-end-color"})," 、",(0,d.jsx)(n.code,{children:"border-block-start-color"})," 和 ",(0,d.jsx)(n.code,{children:"border-block-end-color"})," 等。"]}),"\n",(0,d.jsxs)(n.p,{children:["注意，我们还可以使用 ",(0,d.jsx)(n.code,{children:"border-block"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline"})," 来设置逻辑边框。当 ",(0,d.jsx)(n.code,{children:"direction"})," 为 ",(0,d.jsx)(n.code,{children:"ltr"})," 或 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 为 ",(0,d.jsx)(n.code,{children:"horizontal-tb"})," 时，",(0,d.jsx)(n.code,{children:"border-block"})," 相当于 ",(0,d.jsx)(n.code,{children:"border-top"})," 和 ",(0,d.jsx)(n.code,{children:"border-bottom"})," ，",(0,d.jsx)(n.code,{children:"border-inline"})," 相当于 ",(0,d.jsx)(n.code,{children:"border-left"})," 和 ",(0,d.jsx)(n.code,{children:"border-right"})," 。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:_,alt:"img"})}),"\n",(0,d.jsxs)(n.h4,{id:"css-逻辑外边距",children:["CSS 逻辑外边距",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑外边距",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["CSS 的外边距 ",(0,d.jsx)(n.code,{children:"margin"})," 有四个子属性，分别为 ",(0,d.jsx)(n.code,{children:"margin-top"})," 、",(0,d.jsx)(n.code,{children:"margin-right"})," 、",(0,d.jsx)(n.code,{children:"margin-bottom"})," 和 ",(0,d.jsx)(n.code,{children:"margin-left"})," 。也可以使用 ",(0,d.jsx)(n.code,{children:"margin-block-start"})," 、",(0,d.jsx)(n.code,{children:"margin-block-end"})," 、",(0,d.jsx)(n.code,{children:"margin-inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"margin-inline-end"})," 来设置逻辑外边距。"]}),"\n",(0,d.jsx)(n.p,{children:"例如，在英文（LTR）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"margin-top = margin-block-start\nmargin-right = margin-inline-end\nmargin-bottom = margin-block-end\nmargin-left = margin-inline-start\n"})}),"\n",(0,d.jsx)(n.p,{children:"在阿拉伯文（RTL）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"margin-top = margin-block-start\nmargin-right = margin-inline-start\nmargin-bottom = margin-block-end\nmargin-left = margin-inline-end\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在自上而下（阅读模式）的语言中，比如日语（",(0,d.jsx)(n.code,{children:"writing-mode:vertical-rl"})," ），我们看到的情况是："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"margin-top = margin-inline-start\nmargin-right = margin-block-start\nmargin-bottom = margin-inline-end\nmargin-left = margin-block-end\n"})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'h3 + p {\n \xa0  margin-block-start: 1rem;\n \xa0  margin-block-end: 2rem;\n \xa0  margin-inline-start: 3rem;\n \xa0  margin-inline-end: 4rem;\n}\n​\n.card[lang="jp"] {\n \xa0  writing-mode: vertical-rl;\n}\n'})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:R,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/gOQoXZB",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/gOQoXZB"})]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["注意，我们还可以使用 ",(0,d.jsx)(n.code,{children:"margin-block"})," 和 ",(0,d.jsx)(n.code,{children:"margin-inline"})," 给元素设置逻辑外距。如果 ",(0,d.jsx)(n.code,{children:"direction"})," 的值为 ",(0,d.jsx)(n.code,{children:"ltr"})," 或 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 的值为 ",(0,d.jsx)(n.code,{children:"horizontal-tb"})," ，那么 ",(0,d.jsx)(n.code,{children:"margin-block"})," 相当于 ",(0,d.jsx)(n.code,{children:"margin-top"})," 和 ",(0,d.jsx)(n.code,{children:"margin-bottom"})," ，而 ",(0,d.jsx)(n.code,{children:"margin-inline"})," 相当于 ",(0,d.jsx)(n.code,{children:"margin-left"})," 和 ",(0,d.jsx)(n.code,{children:"margin-right"})," 。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:T,alt:"img"})}),"\n",(0,d.jsxs)(n.h4,{id:"css-逻辑内距",children:["CSS 逻辑内距",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑内距",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"CSS 的逻辑内距和 CSS 逻辑外距相似："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:y,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["同样的，我们还可以使用 ",(0,d.jsx)(n.code,{children:"padding-block"})," 和 ",(0,d.jsx)(n.code,{children:"padding-inline"})," 给元素设置逻辑外距。如果 ",(0,d.jsx)(n.code,{children:"direction"})," 的值为 ",(0,d.jsx)(n.code,{children:"ltr"})," 或 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 的值为 ",(0,d.jsx)(n.code,{children:"horizontal-tb"})," ，那么 ",(0,d.jsx)(n.code,{children:"padding-block"})," 相当于 ",(0,d.jsx)(n.code,{children:"padding-top"})," 和 ",(0,d.jsx)(n.code,{children:"padding-bottom"})," ，而 ",(0,d.jsx)(n.code,{children:"padding-inline"})," 相当于 ",(0,d.jsx)(n.code,{children:"padding-left"})," 和 ",(0,d.jsx)(n.code,{children:"padding-right"})," 。"]}),"\n",(0,d.jsxs)(n.p,{children:["将逻辑尺寸、逻辑边框、逻辑外距和逻辑内距组合在一起，我们以往熟悉的 CSS 盒模型也分为物理盒模型和逻辑盒模型。在 ",(0,d.jsx)(n.code,{children:"direction"})," 属性值为 ",(0,d.jsx)(n.code,{children:"ltr"})," 和 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 属性值为 ",(0,d.jsx)(n.code,{children:"horizontal-tb"})," 时，物理盒模型和逻辑盒模型映射关系如下图所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:v,alt:"img"})}),"\n",(0,d.jsxs)(n.h4,{id:"css-逻辑圆角",children:["CSS 逻辑圆角",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑圆角",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"CSS 的逻辑圆角相对来说要复杂一点。"}),"\n",(0,d.jsxs)(n.p,{children:["了解 CSS 的同学都知道，",(0,d.jsx)(n.code,{children:"border-radius"})," 拆分为下面这几个子属性："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["左上角圆角：",(0,d.jsx)(n.code,{children:"border-top-left-radius"})]}),"\n",(0,d.jsxs)(n.li,{children:["右上角圆角：",(0,d.jsx)(n.code,{children:"border-top-right-radius"})]}),"\n",(0,d.jsxs)(n.li,{children:["右下角圆角：",(0,d.jsx)(n.code,{children:"border-bottom-right-radius"})]}),"\n",(0,d.jsxs)(n.li,{children:["左下角圆角：",(0,d.jsx)(n.code,{children:"border-bottom-left-radius"})]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["需要知道的是，简写属性 ",(0,d.jsx)(n.code,{children:"border-radius"})," 并没有相对应的逻辑属性，但它的子属性却有相对应的逻辑属性。比如，",(0,d.jsx)(n.code,{children:"direction"})," 属性值为 ",(0,d.jsx)(n.code,{children:"ltr"})," 和 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 属性值为 ",(0,d.jsx)(n.code,{children:"horizontal-tb"})," 时，物理圆角和逻辑圆角相对应的关系如下图所示："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:L,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["它和其他逻辑属性略有不同，大多数逻辑属性中同时会包含轴的方向（例如 ",(0,d.jsx)(n.code,{children:"block"})," 和 ",(0,d.jsx)(n.code,{children:"inline"}),"）和起始与结束位置（例如 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"}),"），而逻辑圆角中只有起始和结束位置 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 。其中出现在前面的 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 代表块轴方向，出现在后面的 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 代表内联轴方向："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:N,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"来看一个具体的示例："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'.card {\n \xa0 \xa0border-start-start-radius: 1rem;\n \xa0 \xa0border-start-end-radius: 2rem;\n \xa0 \xa0border-end-end-radius: 3rem;\n \xa0 \xa0border-end-start-radius: 4rem;\n}\n​\n.card[lang="jp"] {\n \xa0 \xa0writing-mode: vertical-rl;\n}\n'})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:w,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/ExOoQdB",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/ExOoQdB"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"在英文（LTR）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"border-top-left-radius \xa0 \xa0 = border-start-start-radius\nborder-top-right-radius \xa0  = border-start-end-radius\nborder-bottom-right-radius = border-end-end-radius\nborder-bottom-left-radius  = border-end-start-radius\n"})}),"\n",(0,d.jsx)(n.p,{children:"在阿拉伯文（RTL）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"border-top-left-radius \xa0 \xa0 = border-start-end-radius\nborder-top-right-radius \xa0  = border-start-start-radius\nborder-bottom-right-radius = border-end-start-radius\nborder-bottom-left-radius  = border-end-end-radius\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在自上而下（阅读模式）的语言中，比如日语（",(0,d.jsx)(n.code,{children:"writing-mode:vertical-rl"})," ）："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"border-top-left-radius = border-end-start-radius\nborder-top-right-radius = border-start-start-radius\nborder-bottom-right-radius = border-start-end-radius\nborder-bottom-left-radius = border-end-end-radius\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:C,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"CSS 逻辑圆角相关属性和物理圆角相关属性是类似的，也可以接受两个值，例如："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0border-start-start-radius: 2rem 4rem;\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["其中第一个值是内联轴方向的半径值，第二个值是块轴方向的半径值。这就有点令人感到困惑了，前面我们说过，逻辑圆角属性中的第一个 ",(0,d.jsx)(n.code,{children:"start"})," 或 ",(0,d.jsx)(n.code,{children:"end"})," 指的是块轴方向，第二个 ",(0,d.jsx)(n.code,{children:"start"})," 或 ",(0,d.jsx)(n.code,{children:"end"})," 才是内联轴方向，但半径值却先写内联轴方向半径，再写块轴方向半径。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:k,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/xxQpWqO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/xxQpWqO"})]}),"\n"]}),"\n",(0,d.jsxs)(n.h4,{id:"css-逻辑偏移",children:["CSS 逻辑偏移",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑偏移",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在 CSS 中，我们可以使用 ",(0,d.jsx)(n.code,{children:"top"})," 、",(0,d.jsx)(n.code,{children:"right"})," 、",(0,d.jsx)(n.code,{children:"bottom"})," 、",(0,d.jsx)(n.code,{children:"left"})," 或它们的简写属性 ",(0,d.jsx)(n.code,{children:"inset"})," 对定位元素（",(0,d.jsx)(n.code,{children:"position"})," 的值不是 ",(0,d.jsx)(n.code,{children:"static"}),"）设置偏移量。例如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".popup{\n \xa0 \xa0position:fixed; \xa0\n \xa0 \xa0top:0;\n \xa0 \xa0bottom:0;\n \xa0 \xa0left:0;\n \xa0 \xa0right:0;\n \xa0 \xa0\n \xa0 \xa0/* 或者 */\n \xa0 \xa0inset: 0;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"同样的，它们也有相应的逻辑偏移量。例如："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".card {\n \xa0 \xa0position: relative;\n}\n​\n.card[lang=\"jp\"] {\n \xa0 \xa0writing-mode: vertical-rl;\n}\n​\n.card::after {\n \xa0 \xa0content: '';\n \xa0 \xa0position: absolute;\n​\n \xa0 \xa0inset-block-start: 10px;\n \xa0 \xa0inset-block-end: 20px;\n \xa0 \xa0inset-inline-start: 30px;\n \xa0 \xa0inset-inline-end: 40px;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:u,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/BaGJgbv",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/BaGJgbv"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"在英文（LTR）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"top \xa0  = inset-block-start\nright  = inset-inline-end\nbottom = inset-block-end\nleft \xa0 = inset-inline-start\n"})}),"\n",(0,d.jsx)(n.p,{children:"在阿拉伯文（RTL）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"top \xa0  = inset-block-start\nright  = inset-inline-start\nbottom = inset-block-end\nleft \xa0 = inset-inline-end\n"})}),"\n",(0,d.jsxs)(n.p,{children:["在自上而下（阅读模式）的语言中，比如日语（",(0,d.jsx)(n.code,{children:"writing-mode:vertical-rl"})," ）："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"top \xa0  = inset-inline-start\nright  = inset-block-start\nbottom = inset-inline-end\nleft \xa0 = inset-block-end\n"})}),"\n",(0,d.jsxs)(n.p,{children:["我们还可以使用 ",(0,d.jsx)(n.code,{children:"inset-block"})," 和 ",(0,d.jsx)(n.code,{children:"inset-inline"})," 给元素设置逻辑偏移量。如果 ",(0,d.jsx)(n.code,{children:"direction"})," 的值为 ",(0,d.jsx)(n.code,{children:"ltr"})," 或 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 的值为 ",(0,d.jsx)(n.code,{children:"horizontal-tb"})," ，那么 ",(0,d.jsx)(n.code,{children:"inset-block"})," 相当于 ",(0,d.jsx)(n.code,{children:"top"})," 和 ",(0,d.jsx)(n.code,{children:"bottom"})," ，而 ",(0,d.jsx)(n.code,{children:"inset-inline"})," 相当于 ",(0,d.jsx)(n.code,{children:"left"})," 和 ",(0,d.jsx)(n.code,{children:"right"})," 。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:S,alt:"img"})}),"\n",(0,d.jsxs)(n.h4,{id:"其他-css-逻辑属性",children:["其他 CSS 逻辑属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其他-css-逻辑属性",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["除了上述所介绍的 CSS 逻辑属性之外，CSS 还有其逻辑属性，比如 ",(0,d.jsx)(n.code,{children:"overflow-inline"})," 、",(0,d.jsx)(n.code,{children:"overflow-block"})," 、",(0,d.jsx)(n.code,{children:"overscroll-behavior-block"})," 和 ",(0,d.jsx)(n.code,{children:"overscroll-behavior-inline"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"下图是较为完整的 CSS 逻辑属性清单列表，并且提供了相应的物理属性清单："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:f,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"来看一个简单地示例："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".button {\n \xa0 \xa0--writing-mode: horizontal-tb;\n \xa0 \xa0writing-mode: var(--writing-mode);\n \xa0 \xa0\n \xa0 \xa0display: inline-flex;\n \xa0 \xa0align-items: center;\n \xa0 \xa0justify-content: center;\n \xa0 \xa0place-self: center;\n \xa0\n \xa0 \xa0transition: all .2s linear;\n \xa0\n \xa0 \xa0padding-block: .8rem;\n \xa0 \xa0padding-inline: 2rem;\n \xa0 \xa0border-start-start-radius: .2em;\n \xa0 \xa0border-start-end-radius: .2em;\n \xa0 \xa0border-end-start-radius: .2em;\n \xa0 \xa0border-end-end-radius: .2em;\n}\n​\n.button:hover {\n \xa0 \xa0border-start-start-radius: 2em 4em;\n \xa0 \xa0border-start-end-radius: 2em 4em;\n \xa0 \xa0border-end-start-radius: 4em 2em;\n \xa0 \xa0border-end-end-radius: 4em 2em;\n}\n​\n.button svg {\n \xa0 \xa0margin-inline-end: 0.5em;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:m,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/poQaoEG",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/poQaoEG"})]}),"\n"]}),"\n",(0,d.jsxs)(n.h3,{id:"css-的简写逻辑属性",children:["CSS 的简写逻辑属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-的简写逻辑属性",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在 CSS 中有很多属性具有简写属性（子属性），比如我们熟悉的 ",(0,d.jsx)(n.code,{children:"margin"})," 、",(0,d.jsx)(n.code,{children:"padding"})," 、",(0,d.jsx)(n.code,{children:"border"})," 、",(0,d.jsx)(n.code,{children:"border-radius"})," 、",(0,d.jsx)(n.code,{children:"overflow"})," 和 ",(0,d.jsx)(n.code,{children:"overscroll-behavior"})," 等。拿 ",(0,d.jsx)(n.code,{children:"margin"})," 为例吧，它可以拆分出 ",(0,d.jsx)(n.code,{children:"margin-top"})," 、",(0,d.jsx)(n.code,{children:"margin-right"})," 、",(0,d.jsx)(n.code,{children:"margin-bottom"})," 和 ",(0,d.jsx)(n.code,{children:"margin-left"})," 四个子属性。"]}),"\n",(0,d.jsx)(n.p,{children:"其实，在 CSS 逻辑属性中也有这样的概念。"}),"\n",(0,d.jsxs)(n.h4,{id:"margin-和-padding-简写属性",children:["margin 和 padding 简写属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#margin-和-padding-简写属性",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["CSS 逻辑属性中 ",(0,d.jsx)(n.code,{children:"margin"})," 的简写属性有 ",(0,d.jsx)(n.code,{children:"margin-block"})," 和 ",(0,d.jsx)(n.code,{children:"margin-inline"})," ："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".margin--logical {\n \xa0 \xa0margin-block: 4ch 2ch;\n \xa0 \xa0margin-inline: 2ch 4ch;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0margin-block-start: 4ch;\n \xa0 \xa0margin-block-end: 2ch;\n \xa0 \xa0\n \xa0 \xa0margin-inline-start: 2ch;\n \xa0 \xa0margin-inline-end: 4ch;\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["如果 ",(0,d.jsx)(n.code,{children:"-start"})," 和 ",(0,d.jsx)(n.code,{children:"-end"})," 对应的属性值相同，那么使用简写属性时，可以只设置一个值，比如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".margin--logical {\n \xa0 \xa0margin-block: 2ch;\n \xa0 \xa0margin-inline: 4ch;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0margin-block-start: 2ch;\n \xa0 \xa0margin-block-end: 2ch;\n \xa0 \xa0\n \xa0 \xa0margin-inline-start: 4ch;\n \xa0 \xa0margin-inline-end: 4ch;\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["逻辑属性 ",(0,d.jsx)(n.code,{children:"padding"})," 和 ",(0,d.jsx)(n.code,{children:"margin"})," 类似："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"padding-inline"})," 是 ",(0,d.jsx)(n.code,{children:"padding-inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"padding-inline-end"})," 的简写属性；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"padding-block"})," 是 ",(0,d.jsx)(n.code,{children:"padding-block-start"})," 和 ",(0,d.jsx)(n.code,{children:"padding-block-end"})," 的简写属性。"]}),"\n"]}),"\n",(0,d.jsxs)(n.h4,{id:"border-简写属性",children:["border 简写属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#border-简写属性",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["我们知道物理属性 ",(0,d.jsx)(n.code,{children:"border"})," 可以拆分为："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["边框粗细：",(0,d.jsx)(n.code,{children:"border-width"})," ，它又可以拆分为 ",(0,d.jsx)(n.code,{children:"border-top-width"})," 、",(0,d.jsx)(n.code,{children:"border-right-width"})," 、",(0,d.jsx)(n.code,{children:"border-bottom-width"})," 和 ",(0,d.jsx)(n.code,{children:"border-left-width"}),"。"]}),"\n",(0,d.jsxs)(n.li,{children:["边框颜色：",(0,d.jsx)(n.code,{children:"border-color"})," ，它又可以拆分为 ",(0,d.jsx)(n.code,{children:"border-top-color"})," 、",(0,d.jsx)(n.code,{children:"border-right-color"})," 、",(0,d.jsx)(n.code,{children:"border-bottom-color"})," 和 ",(0,d.jsx)(n.code,{children:"border-left-color"}),"。"]}),"\n",(0,d.jsxs)(n.li,{children:["边框样式：",(0,d.jsx)(n.code,{children:"border-style"})," ，它又可拆分为 ",(0,d.jsx)(n.code,{children:"border-top-style"})," 、",(0,d.jsx)(n.code,{children:"border-right-style"})," 、",(0,d.jsx)(n.code,{children:"border-bottom-style"})," 和 ",(0,d.jsx)(n.code,{children:"border-left-style"})," 。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["它相对于 ",(0,d.jsx)(n.code,{children:"padding"})," 和 ",(0,d.jsx)(n.code,{children:"margin"})," 要复杂得多。"]}),"\n",(0,d.jsxs)(n.p,{children:["逻辑属性 ",(0,d.jsx)(n.code,{children:"border"})," 也可以根据颜色（",(0,d.jsx)(n.code,{children:"color"}),"）、粗细（",(0,d.jsx)(n.code,{children:"width"}),"）和样式（",(0,d.jsx)(n.code,{children:"style"}),"）进行拆分，即："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["边框粗细：",(0,d.jsx)(n.code,{children:"border-block-width"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline-width"})," ，它们又分别可以拆分出 ",(0,d.jsx)(n.code,{children:"border-block-start-width"})," 和 ",(0,d.jsx)(n.code,{children:"border-block-end-width"})," ；",(0,d.jsx)(n.code,{children:"border-inline-start-width"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline-end-width"}),"。"]}),"\n",(0,d.jsxs)(n.li,{children:["边框颜色：",(0,d.jsx)(n.code,{children:"border-block-color"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline-color"})," ，它们又分别可以拆分出 ",(0,d.jsx)(n.code,{children:"border-block-start-color"})," 和 ",(0,d.jsx)(n.code,{children:"border-block-end-color"})," ；",(0,d.jsx)(n.code,{children:"border-inline-start-color"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline-end-color"}),"。"]}),"\n",(0,d.jsxs)(n.li,{children:["边框样式：",(0,d.jsx)(n.code,{children:"border-block-style"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline-style"})," ，它们又分别可以拆分出 ",(0,d.jsx)(n.code,{children:"border-block-start-style"})," 和 ",(0,d.jsx)(n.code,{children:"border-block-end-style"})," ；",(0,d.jsx)(n.code,{children:"border-inline-start-style"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline-end-style"}),"。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"来看一个边框颜色的示例："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".border-color--logical {\n \xa0 \xa0border-block-color: #09f #f36;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0border-block-start: #09f;\n \xa0 \xa0border-block-end: #f36;\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["但需要注意的是，逻辑边框和逻辑内外、逻辑外边距有一点不同，使用逻辑边框 ",(0,d.jsx)(n.code,{children:"border-block"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline"})," 子属性设置元素边框时，只能设置同一方向相同的边框样式。例如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".border--logical {\n \xa0 \xa0border-block: 2px solid orange;\n \xa0 \xa0border-inline: 4px dashed;\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["如果每条边框样式规则不同，则需要分别使用 ",(0,d.jsx)(n.code,{children:"border-block-start"})," 、",(0,d.jsx)(n.code,{children:"border-block-end"})," 、",(0,d.jsx)(n.code,{children:"border-inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline-end"})," 。例如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".border--logical {\n \xa0 \xa0border-block-start: 4ch solid red;\n \xa0 \xa0border-block-end: 3ch dashed yellow;\n \xa0 \xa0border-inline-start: 4ch double;\n \xa0 \xa0border-inline-end: 3ch groove orange;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:g,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址： ",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/vYQdYzp",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/vYQdYzp"})]}),"\n"]}),"\n",(0,d.jsxs)(n.h4,{id:"简写的-border-radius-属性",children:["简写的 border-radius 属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简写的-border-radius-属性",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"border-radius"})," 的子属性有："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["左上角：",(0,d.jsx)(n.code,{children:"border-top-left-radius"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:["右上角：",(0,d.jsx)(n.code,{children:"border-top-right-radius"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:["右下角：",(0,d.jsx)(n.code,{children:"border-bottom-right-radius"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:["左下角：",(0,d.jsx)(n.code,{children:"border-bottom-left-radius"}),"。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"例如："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".border-radius {\n \xa0 \xa0border-radius: 30px 50px 50px 100px;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0border-top-left-radius: 30px;\n \xa0 \xa0border-top-right-radius: 50px;\n \xa0 \xa0border-bottom-right-radius: 50px;\n \xa0 \xa0border-bottom-left-radius: 100px;\n}\n​\n.border-radius {\n \xa0 \xa0border-radius: 30px 50px 100px 50px / 100px 50px 50px 50px;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0border-top-left-radius: 30px 100px;\n \xa0 \xa0border-top-right-radius: 50px 50px;\n \xa0 \xa0border-bottom-right-radius: 100px 50px;\n \xa0 \xa0border-bottom-left-radius: 50px 50px;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:p,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["但对于逻辑属性 ",(0,d.jsx)(n.code,{children:"border-radius"})," 的子属性，并不像 ",(0,d.jsx)(n.code,{children:"margin"})," 、",(0,d.jsx)(n.code,{children:"padding"})," 和 ",(0,d.jsx)(n.code,{children:"border"})," 等属性，它没有 ",(0,d.jsx)(n.code,{children:"border-block-radius"})," 和 ",(0,d.jsx)(n.code,{children:"border-inline-radius"})," 子属性。逻辑属性 ",(0,d.jsx)(n.code,{children:"border-radius"})," 的子属性："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"border-start-start-radius"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"border-start-end-radius"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"border-end-end-radius"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"border-end-start-radius"}),"。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:b,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["你可能会对 ",(0,d.jsx)(n.code,{children:"-start-start"})," 和 ",(0,d.jsx)(n.code,{children:"-start-end"})," 等感到困惑。其实它和物理属性中的 ",(0,d.jsx)(n.code,{children:"-top-left"})," 、",(0,d.jsx)(n.code,{children:"-top-right"})," 等是相似的：出现在前面的 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 是指块轴（Block Axis）的起始和结束位置；出现在后面的 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 是指内联轴（Inline Axis）的起始和结束位置。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:"/* 物理 CSS border-radius */\n.border-radius--physical {\n \xa0border-top-left-radius: 5rem 10rem;\n \xa0border-top-right-radius: 2rem 1rem;\n \xa0border-bottom-right-radius: 4rem 2rem;\n \xa0border-bottom-left-radius: 3rem 5rem;\n}\n​\n/* 逻辑 CSS border-radius */\n.border-radius--logical {\n \xa0border-start-start-radius: 5rem 10rem;\n \xa0border-start-end-radius: 2rem 1rem;\n \xa0border-end-end-radius: 4rem 2rem;\n \xa0border-end-start-radius: 3rem 5rem;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:j,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/OJaQJaB",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/OJaQJaB"}),"、"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["需要注意的是，在 CSS 中逻辑属性 ",(0,d.jsx)(n.code,{children:"border-radius"})," 并没有简写属性。因此，在开发多语言 Web 应用或网站时，最好是使用拆分后的逻辑 ",(0,d.jsx)(n.code,{children:"border-radius"})," 属性，尤其是四个角的圆角半径不同之时。不然，你将遇到意想不到的效果。比如下面这个示例，你在按钮默认状态使用的是 ",(0,d.jsx)(n.code,{children:"border-radius"})," （物理属性），而在悬浮状态下却使用的是逻辑属性："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:"button {\n \xa0 \xa0border-radius: 2rem;\n}\n​\nbutton:hover {\n \xa0 \xa0border-start-start-radius: 2rem 4rem;\n \xa0 \xa0border-start-end-radius: 4rem 2rem;\n \xa0 \xa0border-end-start-radius: 2rem 4rem;\n \xa0 \xa0border-end-end-radius: 4rem 2rem;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:a,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/GRwQRzG",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/GRwQRzG"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"从浏览器开发者调试工具中不难发现，按钮悬浮状态下的逻辑圆角并没有覆盖初始化状态下的物理圆角，可浏览器实际渲染还是以逻辑圆角的值进行，这难免会令人感到困惑。"}),"\n",(0,d.jsxs)(n.h4,{id:"inset-简写属性",children:["inset 简写属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#inset-简写属性",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["对于定位元素（即 ",(0,d.jsx)(n.code,{children:"position"})," 设置非 ",(0,d.jsx)(n.code,{children:"static"})," 的元素）可以使用 ",(0,d.jsx)(n.code,{children:"top"})," 、",(0,d.jsx)(n.code,{children:"right"})," 、",(0,d.jsx)(n.code,{children:"bottom"})," 和 ",(0,d.jsx)(n.code,{children:"left"})," 来设置偏移量。这四个属性有一个简写属性 ",(0,d.jsx)(n.code,{children:"inset"})," ："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".inset {\n \xa0 \xa0position: absolute;\n \xa0 \xa0inset: 10px 20px 30px 40px;\n \xa0 \xa0\n \xa0 \xa0/* inset 等同于 */\n \xa0 \xa0top: 10px;\n \xa0 \xa0right: 20px;\n \xa0 \xa0bottom: 20px;\n \xa0 \xa0left: 40px;\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["看起来很方便。只不过，",(0,d.jsx)(n.code,{children:"inset"})," 属性是一个物理属性。相应的 CSS 逻辑属性是："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"top"})," 映射 ",(0,d.jsx)(n.code,{children:"inset-block-start"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"right"})," 映射 ",(0,d.jsx)(n.code,{children:"inset-inline-end"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"bottom"})," 映射 ",(0,d.jsx)(n.code,{children:"inset-block-end"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"left"})," 映射 ",(0,d.jsx)(n.code,{children:"inset-inline-start"}),"。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:x,alt:"img"})}),"\n",(0,d.jsxs)(n.p,{children:["不过，CSS 逻辑属性中可以使用 ",(0,d.jsx)(n.code,{children:"inset-block"})," 和 ",(0,d.jsx)(n.code,{children:"inset-inline"})," 来设置偏移量，它们分别是："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"inset-block"})," 是 ",(0,d.jsx)(n.code,{children:"inset-block-start"})," 和 ",(0,d.jsx)(n.code,{children:"inset-block-end"})," 的简写属性；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"inset-inline"})," 是 ",(0,d.jsx)(n.code,{children:"inset-inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"inset-inline-end"})," 的简写属性。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"例如："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".inset {\n \xa0 \xa0position: absolute;\n \xa0 \xa0\n \xa0 \xa0inset-block: 20px 30px;\n \xa0 \xa0inset-inline: 40px 50px;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0inset-block-start: 20px;\n \xa0 \xa0inset-block-end: 30px;\n \xa0 \xa0inset-inline-start: 40px;\n \xa0 \xa0inset-inline-end: 50px;\n}\n"})}),"\n",(0,d.jsxs)(n.h4,{id:"避免使用简写属性",children:["避免使用简写属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#避免使用简写属性",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["如果你正在开发一个多语言 Web 应用或网站，那么应该尽可能地在代码中不使用 CSS 的简写属性，尤其是四个方向的值不相等的情况下。比如 ",(0,d.jsx)(n.code,{children:"border"})," 、",(0,d.jsx)(n.code,{children:"margin"})," 、",(0,d.jsx)(n.code,{children:"padding"})," 、",(0,d.jsx)(n.code,{children:"border-radius"})," 等属性。因为它们始终会代表着物理方向，例如下面这段代码："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0border: 1px solid #f36;\n \xa0 \xa0border-width: 1ch 2ch 3ch 4ch;\n \xa0 \xa0margin: 1rem 2rem 3rem 4rem;\n \xa0 \xa0padding: 1rem 2rem 3rem 4rem;\n \xa0 \xa0border-radius: 1rem 2rem 3rem 4rem;\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:t,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/QWJQWee",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/QWJQWee"})]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["你会发现，改变 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 时，元素的 ",(0,d.jsx)(n.code,{children:"border"})," 、",(0,d.jsx)(n.code,{children:"border-radius"})," 、",(0,d.jsx)(n.code,{children:"margin"})," 和 ",(0,d.jsx)(n.code,{children:"padding"})," 并不会受到任何影响。这对于多语言 Web 应用或网站是非常危险的。反之，如果换成拆分后的子属性（逻辑属性），结果就完全不一样："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".element--physical {\n \xa0 \xa0border: 1px solid #f36;\n \xa0 \xa0border-width: 1ch 2ch 3ch 4ch;\n \xa0 \xa0margin: 1rem 2rem 3rem 4rem;\n \xa0 \xa0padding: 1rem 2rem 3rem 4rem;\n \xa0 \xa0border-radius: 1rem 2rem 3rem 4rem;\n}\n​\n.element--logical {\n \xa0 \xa0border: 1px solid #f36;\n \xa0 \xa0border-block-width: 1ch 3ch;\n \xa0 \xa0border-inline-width: 4rem 2rem;\n \xa0 \xa0margin-block: 1rem 3rem; \n \xa0 \xa0margin-inline: 4rem 2rem;\n \xa0 \xa0padding-block: 1rem 3rem;\n \xa0 \xa0padding-inline: 4rem 2rem;\n \xa0 \xa0border-start-start-radius: 1rem;\n \xa0 \xa0border-start-end-radius: 2rem;\n \xa0 \xa0border-end-end-radius: 3rem;\n \xa0 \xa0border-end-start-radius: 4rem; \n}\n"})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:h,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/NWEyPKV",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/NWEyPKV"})]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["简而言之，",(0,d.jsx)(n.strong,{children:"在开发多语言 Web 应用或网站时，虽然简写的 CSS 属性的使用能使你的代码更干净，但不建议直接使用，因为我们所熟悉的简写 CSS 属性都是物理属性，它和相对应的简写逻辑属性是完全不同的"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["换句话说，在开发多语言 Web 应用或网站时，请尽量不要使用盒模型相关的简写属性，即 ",(0,d.jsx)(n.code,{children:"border"})," 、",(0,d.jsx)(n.code,{children:"padding"})," 、",(0,d.jsx)(n.code,{children:"margin"})," 和 ",(0,d.jsx)(n.code,{children:"border-radius"})," 等，同时也包括 ",(0,d.jsx)(n.code,{children:"inset"})," 属性。"]}),"\n",(0,d.jsxs)(n.h4,{id:"未来简写逻辑属性的变化",children:["未来简写逻辑属性的变化",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#未来简写逻辑属性的变化",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["默认情况之下，",(0,d.jsx)(n.code,{children:"padding"})," 、",(0,d.jsx)(n.code,{children:"margin"})," 和 ",(0,d.jsx)(n.code,{children:"border"})," 的简写属性为物理属性设置值。但在未来，Web 开发者可以在这些属性的值前面指定一个名为 ",(0,d.jsx)(n.code,{children:"logical"})," 的关键词，它将告诉浏览器，这些值将映射到逻辑属性，而不是物理属性。例如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0margin: logical 1rem 2rem 3rem 4rem;\n}\n​\n/* 等同于 */\n.element {\n \xa0 \xa0margin-block-start: 1rem;\n \xa0 \xa0margin-inline-start: 2rem;\n \xa0 \xa0margin-block-end: 3rem;\n \xa0 \xa0margin-inline-end: 4rem;\n}\n"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["需要注意，",(0,d.jsx)(n.a,{href:"https://github.com/w3c/csswg-drafts/issues/1282",target:"_blank",rel:"noopener noreferrer",children:"目前这种方案还在讨论中"}),"，并不代表是最终方案。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["到目前为止，W3C 规范指定 ",(0,d.jsx)(n.code,{children:"inset"})," 、",(0,d.jsx)(n.code,{children:"margin"})," 、",(0,d.jsx)(n.code,{children:"padding"})," 、",(0,d.jsx)(n.code,{children:"border-width"})," 、",(0,d.jsx)(n.code,{children:"border-style"})," 、",(0,d.jsx)(n.code,{children:"border-color"})," 、",(0,d.jsx)(n.code,{children:"scoll-padding"})," 和 ",(0,d.jsx)(n.code,{children:"scroll-margin"})," 简写属性在设置值时，可以接受 ",(0,d.jsx)(n.code,{children:"logical"})," 关键词。当这些简写属性的值中存在 ",(0,d.jsx)(n.code,{children:"logical"})," 关键词时，后面的值将被分配到相应的逻辑属性上，但需要知道的是，取值数量不同时，所映射的逻辑属性也略有差异："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["如果只设置一个值，则该值适用于",(0,d.jsx)(n.code,{children:"block-start"})," 、",(0,d.jsx)(n.code,{children:"block-end"})," 、",(0,d.jsx)(n.code,{children:"inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"inline-end"})]}),"\n",(0,d.jsxs)(n.li,{children:["如果设置了两个值，则第一个值会用于 ",(0,d.jsx)(n.code,{children:"block-start"})," 和 ",(0,d.jsx)(n.code,{children:"block-end"})," ，第二个值会用于 ",(0,d.jsx)(n.code,{children:"inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"inline-end"})]}),"\n",(0,d.jsxs)(n.li,{children:["如果设置了三个值，则第一个值会用于 ",(0,d.jsx)(n.code,{children:"block-start"})," ，第二个值将会用于 ",(0,d.jsx)(n.code,{children:"inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"inline-end"})," ，第三个值将会用于 ",(0,d.jsx)(n.code,{children:"block-end"})]}),"\n",(0,d.jsxs)(n.li,{children:["如果设置了四个值，则第一个值会用于 ",(0,d.jsx)(n.code,{children:"block-start"})," ，第二个值将会用于 ",(0,d.jsx)(n.code,{children:"inline-end"})," ，第三个值将会用于 ",(0,d.jsx)(n.code,{children:"block-end"})," ，第四个值将会用于 ",(0,d.jsx)(n.code,{children:"inline-start"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"例如："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0margin: logical 1rem;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0margin-block-start: 1rem;\n \xa0 \xa0margin-inline-end: 1rem;\n \xa0 \xa0margin-block-end: 1rem;\n \xa0 \xa0margin-inline-start: 1rem;\n}\n​\n.element {\n \xa0 \xa0margin: logical 1rem 2rem;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0margin-block-start: 1rem;\n \xa0 \xa0margin-inline-end: 2rem;\n \xa0 \xa0margin-block-end: 1rem;\n \xa0 \xa0margin-inline-start: 2rem;\n}\n​\n.element {\n \xa0 \xa0margin: logical 1rem 2rem 3rem;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0margin-block-start: 1rem;\n \xa0 \xa0margin-inline-end: 2rem;\n \xa0 \xa0margin-block-end: 3rem;\n \xa0 \xa0margin-inline-start: 2rem;\n}\n​\n.element {\n \xa0 \xa0margin: logical 1rem 2rem 3rem 4rem;\n \xa0 \xa0\n \xa0 \xa0/* 等同于 */\n \xa0 \xa0margin-block-start: 1rem;\n \xa0 \xa0margin-inline-end: 2rem;\n \xa0 \xa0margin-block-end: 3rem;\n \xa0 \xa0margin-inline-start: 4rem;\n}\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"css-逻辑值",children:["CSS 逻辑值",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-逻辑值",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"在 CSS 中有些属性的值也具有逻辑值。"}),"\n",(0,d.jsxs)(n.h4,{id:"css-浮动",children:["CSS 浮动",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-浮动",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["CSS 的 ",(0,d.jsx)(n.code,{children:"float"})," 属性的物理值有 ",(0,d.jsx)(n.code,{children:"left"})," 、",(0,d.jsx)(n.code,{children:"center"})," 和 ",(0,d.jsx)(n.code,{children:"right"})," ，它相应的逻辑值只有 ",(0,d.jsx)(n.code,{children:"inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"inline-end"})," ，分别映射了物理值中的 ",(0,d.jsx)(n.code,{children:"left"})," 和 ",(0,d.jsx)(n.code,{children:"right"})," 。"]}),"\n",(0,d.jsxs)(n.table,{children:["\n",(0,d.jsxs)(n.thead,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"CSS 属性"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"物理值"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"逻辑值"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.tbody,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"float"})})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"left"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-start"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"center"})}),"\n",(0,d.jsx)(n.td,{}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"right"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-end"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"用在英文（LTR）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"float: left  = float: inline-start\nfloat: right = float: inline-end \n"})}),"\n",(0,d.jsx)(n.p,{children:"用在阿拉伯文（RTL）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"float: left  = float: inline-end\nfloat: right = float: inline-start\n"})}),"\n",(0,d.jsxs)(n.h4,{id:"css-清除浮动",children:["CSS 清除浮动",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-清除浮动",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["CSS 的 ",(0,d.jsx)(n.code,{children:"clear"})," 属性和 ",(0,d.jsx)(n.code,{children:"float"})," 属性相似，它也具有 ",(0,d.jsx)(n.code,{children:"inline-start"})," 和 ",(0,d.jsx)(n.code,{children:"inline-end"})," 两个逻辑值，分别映射了物理值中的 ",(0,d.jsx)(n.code,{children:"left"})," 和 ",(0,d.jsx)(n.code,{children:"right"})," ："]}),"\n",(0,d.jsxs)(n.table,{children:["\n",(0,d.jsxs)(n.thead,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"CSS 属性"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"物理值"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"逻辑值"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.tbody,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"clear"})})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"left"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-start"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"both"})}),"\n",(0,d.jsx)(n.td,{}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"right"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline-end"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.h4,{id:"文本对齐",children:["文本对齐",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#文本对齐",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["文本对齐属性 ",(0,d.jsx)(n.code,{children:"text-align"})," 要比 ",(0,d.jsx)(n.code,{children:"float"})," 和 ",(0,d.jsx)(n.code,{children:"clear"})," 简单，",(0,d.jsx)(n.code,{children:"left"})," 和 ",(0,d.jsx)(n.code,{children:"right"})," 被 ",(0,d.jsx)(n.code,{children:"start"})," 和 ",(0,d.jsx)(n.code,{children:"end"})," 替代："]}),"\n",(0,d.jsxs)(n.table,{children:["\n",(0,d.jsxs)(n.thead,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"CSS 属性"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"物理值"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"逻辑值"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.tbody,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"text-align"})})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"left"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"start"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"right"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"end"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"用英语（LTR）中:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"text-align: left = text-align: start;\ntext-align: right = text-align: end;\n"})}),"\n",(0,d.jsx)(n.p,{children:"用在阿拉伯文（RTL）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"text-align: left  = text-align: end;\ntext-align: right = text-align: start\n"})}),"\n",(0,d.jsxs)(n.h4,{id:"resize",children:["resize",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#resize",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"resize"})," 属性主要使用 ",(0,d.jsx)(n.code,{children:"inline"})," 和 ",(0,d.jsx)(n.code,{children:"block"})," 替代了 ",(0,d.jsx)(n.code,{children:"horizontal"})," 和 ",(0,d.jsx)(n.code,{children:"vertical"})," ："]}),"\n",(0,d.jsxs)(n.table,{children:["\n",(0,d.jsxs)(n.thead,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"CSS 属性"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"物理值"})}),"\n",(0,d.jsx)(n.th,{children:(0,d.jsx)(n.strong,{children:"逻辑值"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.tbody,{children:["\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"resize"})})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"horizontal"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"inline"})}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"both"})}),"\n",(0,d.jsx)(n.td,{}),"\n"]}),"\n",(0,d.jsxs)(n.tr,{children:["\n",(0,d.jsx)(n.td,{}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"vertical"})}),"\n",(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"block"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"在英文（LTR）中："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"resize: horizontal = resize: inline;\nresize: vertical \xa0 = resize: block;\n"})}),"\n",(0,d.jsxs)(n.h2,{id:"默认就是逻辑属性的-css-属性",children:["默认就是逻辑属性的 CSS 属性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#默认就是逻辑属性的-css-属性",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7161370789680250917?utm_source=profile_book",target:"_blank",rel:"noopener noreferrer",children:"CSS Flexbox 或 Grid 特性已然是现代 Web 布局中的主流技术了"}),"。更为有意思的是，CSS Flexbox 和 Grid 特性默认都是逻辑的。这意味着，它们将根据文档的方向自动翻转。通过使用 CSS Flexbox 和 Grid 布局技术，你可以最大限度的减少构建多语言 Web 应用或组件所需的工作量。"]}),"\n",(0,d.jsx)(n.p,{children:"下面是一个 CSS Grid 布局相关的示例，请注意这些网格项目是如何根据文档的方向排列的："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'.card {\n \xa0 \xa0inline-size: 300px;\n \xa0 \xa0display: grid;\n \xa0 \xa0grid-template-columns: repeat(3, minmax(0, 1fr));\n \xa0 \xa0gap: 1rem;\n}\n​\n.card[lang="mn"] {\n \xa0writing-mode: vertical-lr;\n}\n​\n.card[lang="jp"] {\n \xa0writing-mode: vertical-rl;\n}\n'})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:o,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/qBQxdOg",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/qBQxdOg"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"CSS Flexbox 具有同等的功能，比如把上面示例改成 CSS Flexbox 布局，得到的效果将是相似的："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'.card {\n \xa0 \xa0inline-size: 300px;\n \xa0 \xa0display: flex;\n \xa0 \xa0flex-wrap: wrap;\n \xa0 \xa0gap: 1rem;\n  }\n​\n.item {\n \xa0 \xa0flex: 1 1 25%;\n}\n​\n.card[lang="mn"] {\n \xa0 \xa0writing-mode: vertical-lr;\n}\n​\n.card[lang="jp"] {\n \xa0 \xa0writing-mode: vertical-rl;\n}\n'})}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:l,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/oNQEXyN",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/oNQEXyN"})]}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"逻辑属性和逻辑值用例",children:["逻辑属性和逻辑值用例",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑属性和逻辑值用例",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"现在我们对 CSS 的逻辑属性和逻辑值有了一个全面的认识。接下来，来看看一些实际用例，以确保你对 CSS 逻辑属性和逻辑值有一个更全面的理解。"}),"\n",(0,d.jsx)(n.p,{children:"先来看一个卡片相关的示例："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:s,alt:"img"})}),"\n",(0,d.jsx)(n.p,{children:"上图是一个简单而又经典的卡片组件，但它包含了英文、阿拉伯文、日文和蒙古文。这四种语言有着典型的特征："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"英文阅读模式是从左向右，即 LTR"}),"\n",(0,d.jsx)(n.li,{children:"阿拉伯文阅读模式是从右向左，即 RTL"}),"\n",(0,d.jsxs)(n.li,{children:["日文自上而下，但从右向左，即 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 的值为 ",(0,d.jsx)(n.code,{children:"vertical-rl"})]}),"\n",(0,d.jsxs)(n.li,{children:["蒙古文也是自上而下，但从左向右，即 ",(0,d.jsx)(n.code,{children:"writing-mode"})," 的值为 ",(0,d.jsx)(n.code,{children:"vertical-lr"})]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"为了阐述 CSS 逻辑属性的重要性，卡片组件特意做了额外的设计："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"卡片左侧有一个蓝色边框"}),"\n",(0,d.jsx)(n.li,{children:"卡片左右两侧的距不相等"}),"\n",(0,d.jsx)(n.li,{children:"缩略图右侧有一个外边距"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"在没有 CSS 逻辑属性之前，要实现这样具有多语的卡片组件是件不易的事情，最起码代码会比较冗余。就拿英文（LTR）和阿拉伯文（RTL）为例："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-HTML",children:'<div class="card" lang="en" dir="ltr">\n \xa0 \xa0<img src="https://picsum.photos/200/200/?random=11" alt="">\n \xa0 \xa0<div class="card__content">\n \xa0 \xa0 \xa0 \xa0<h3>Modern CSS</h3>\n \xa0 \xa0 \xa0 \xa0<p>Logical Properties and Logical Values in Modern CSS</p>\n \xa0 \xa0</div>\n</div>\n​\n<div class="card" lang="ar" dir="rtl">\n \xa0 \xa0<img src="https://picsum.photos/200/200/?random=11" alt="">\n \xa0 \xa0<div class="card__content">\n \xa0 \xa0 \xa0 \xa0<h3>CSS الحديثة</h3>\n \xa0 \xa0 \xa0 \xa0<p>الخصائص المنطقية والقيم المنطقية في CSS الحديث</p>\n \xa0 \xa0</div>\n</div>\n'})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:'/* 默认是 LTR 模式样式 */\n.card {\n \xa0  border-left: 6px solid #09f;\n \xa0  padding-left: 2rem;\n \xa0  padding-right: 1rem;\n}\n​\n.card img {\n \xa0  margin-right: 2rem;\n}\n​\n/* RTL 模式下重置样式 */\n.card[lang="ar"] {\n \xa0  border-left: none;\n \xa0  border-right: 6px solid #09f;\n \xa0  padding-left: 1rem;\n \xa0  padding-right: 2rem;\n}\n​\n.card[lang="ar"] img {\n \xa0  margin-left: 2rem;\n \xa0  margin-right: 0;\n}\n'})}),"\n",(0,d.jsx)(n.p,{children:"想象一下，如果你还需要加上日文和蒙文，甚至更多的语言时，那是多么的痛苦。"}),"\n",(0,d.jsx)(n.p,{children:"如果使用 CSS 逻辑属性的话，这一切都变得是那么的容易："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-CSS",children:".card {\n \xa0 \xa0inline-size: 360px;\n \xa0 \xa0border-inline-start: 6px solid #09f;\n \xa0 \xa0padding-block: 1rem;\n \xa0 \xa0padding-inline-start: 2rem;\n \xa0 \xa0padding-inline-end: 1rem;\n }\n​\n.card img {\n \xa0 \xa0margin-inline-end: 2rem;\n}\n"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/qBQxdLB",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/qBQxdLB"})]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["有了这些基础，你就可以使用 CSS 逻辑属性来开发一个多语言的 Web 应用或网站，例如 ",(0,d.jsx)(n.a,{href:"https://codepen.io/Alaa_AbdElrahim/full/XWaBBoq",target:"_blank",rel:"noopener noreferrer",children:"@Alaa Abd El-Rahim 在 Codepen 分享的一个示例"}),"。我在他的基础上 Fork 了一份，并在该示例的“英文”、“日文”、“阿拉伯文”的基础上新增了“中文”。这样就构建了一个四国语言的 Web 页面："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:c,alt:"img"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["Demo 地址：",(0,d.jsx)(n.a,{href:"https://codepen.io/airen/full/LYJoGQd",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/LYJoGQd"})," （详细解读可以阅读《",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7161370789680250917/section/7161625415935590436",target:"_blank",rel:"noopener noreferrer",children:"Web 中的向左向右：Web 布局中 LTR 切换到 RTL 常见错误"}),"》一文！）"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"示例代码就不在这里展示了，感兴趣的同学可以查看 Demo 的源码！"}),"\n",(0,d.jsxs)(n.h2,{id:"小结",children:["小结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"如果在构建 Web 应用或页面时，面对的仅是单一语言，那么使用 CSS 物理属性并无大碍，而且也不会影响整个 Web 应用的布局。你使用 CSS 逻辑属性来替代物理属性也可以实现同等效果。如果你构建的 Web 应用是要处理多语言，那么物理属性带来的局限性就非常的明显，而且也会造成阅读上的不便，这个时候 CSS 逻辑属性和逻辑值起到的作用就非常大。"}),"\n",(0,d.jsx)(n.p,{children:"逻辑属性和逻辑值的主要优点是，它是一组用于根据文本流方向动态处理布局的属性和值，它们使得在不同的书写模式之间切换更加容易，并且它们是相对于流而不是固定方向来工作的，这使得布局更具灵活性和可重用性。但它们也可能会给开发者带来一定的学习曲线和混淆。"}),"\n",(0,d.jsx)(n.p,{children:"总之，CSS 逻辑属性和逻辑值是一种强大的工具，可以帮助开发者轻松处理国际化网站的布局，并保持代码的简洁和易读性。"})]})}function el(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(es,{...e})}):es(e)}let eo=el;el.__RSPRESS_PAGE_META={},el.__RSPRESS_PAGE_META["%E7%8E%B0%E4%BB%A3CSS%2F%E7%AC%AC27%E7%AB%A0%E2%80%94CSS%E9%80%BB%E8%BE%91%E5%B1%9E%E6%80%A7%E5%92%8C%E9%80%BB%E8%BE%91%E5%80%BC.md"]={toc:[{text:"逻辑属性和逻辑值描述了什么？",id:"逻辑属性和逻辑值描述了什么",depth:2},{text:"需要理解和掌握的术语",id:"需要理解和掌握的术语",depth:2},{text:"文档流",id:"文档流",depth:3},{text:"块流",id:"块流",depth:3},{text:"内联流",id:"内联流",depth:3},{text:"内联和块的区别",id:"内联和块的区别",depth:3},{text:"开始与结束",id:"开始与结束",depth:3},{text:"逻辑维度",id:"逻辑维度",depth:3},{text:"CSS 逻辑属性和逻辑值",id:"css-逻辑属性和逻辑值",depth:2},{text:"CSS 逻辑属性",id:"css-逻辑属性",depth:3},{text:"CSS 逻辑尺寸",id:"css-逻辑尺寸",depth:4},{text:"CSS 逻辑边框",id:"css-逻辑边框",depth:4},{text:"CSS 逻辑外边距",id:"css-逻辑外边距",depth:4},{text:"CSS 逻辑内距",id:"css-逻辑内距",depth:4},{text:"CSS 逻辑圆角",id:"css-逻辑圆角",depth:4},{text:"CSS 逻辑偏移",id:"css-逻辑偏移",depth:4},{text:"其他 CSS 逻辑属性",id:"其他-css-逻辑属性",depth:4},{text:"CSS 的简写逻辑属性",id:"css-的简写逻辑属性",depth:3},{text:"margin 和 padding 简写属性",id:"margin-和-padding-简写属性",depth:4},{text:"border 简写属性",id:"border-简写属性",depth:4},{text:"简写的 border-radius 属性",id:"简写的-border-radius-属性",depth:4},{text:"inset 简写属性",id:"inset-简写属性",depth:4},{text:"避免使用简写属性",id:"避免使用简写属性",depth:4},{text:"未来简写逻辑属性的变化",id:"未来简写逻辑属性的变化",depth:4},{text:"CSS 逻辑值",id:"css-逻辑值",depth:3},{text:"CSS 浮动",id:"css-浮动",depth:4},{text:"CSS 清除浮动",id:"css-清除浮动",depth:4},{text:"文本对齐",id:"文本对齐",depth:4},{text:"resize",id:"resize",depth:4},{text:"默认就是逻辑属性的 CSS 属性",id:"默认就是逻辑属性的-css-属性",depth:2},{text:"逻辑属性和逻辑值用例",id:"逻辑属性和逻辑值用例",depth:2},{text:"小结",id:"小结",depth:2}],title:"第27章—CSS逻辑属性和逻辑值",headingTitle:"第27章—CSS逻辑属性和逻辑值",frontmatter:{}}}}]);