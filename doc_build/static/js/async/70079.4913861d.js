"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["70079"],{818948:function(e,a,r){r.r(a),r.d(a,{default:()=>o});var n=r(552676),c=r(740453);function s(e){let a=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li"},(0,c.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(a.h1,{id:"24babel-macros",children:["24.Babel Macros",(0,n.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#24babel-macros",children:"#"})]}),"\n",(0,n.jsx)(a.p,{children:"babel macro 是修改 AST 的一种新的方式，其实和 babel plugin 差别不大，会了 plugin，macro 也就会了。"}),"\n",(0,n.jsx)(a.p,{children:"这节我们来学习一下 babel macro。"}),"\n",(0,n.jsxs)(a.h2,{id:"babel-macro-介绍",children:["babel macro 介绍",(0,n.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#babel-macro-介绍",children:"#"})]}),"\n",(0,n.jsx)(a.p,{children:"babel macro 是通过在源码中引入 macro 模块，在要转换的地方调用相应的 api，macro 内部会拿到相应的 ast，然后进行转换的一种方式。"}),"\n",(0,n.jsx)(a.p,{children:"比如源码为："}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-javascript",children:"const files = require('../macros/files.macro');\n\nconsole.log('src files:');\nconsole.log(files('../src'));\nconsole.log('macro files:');\nconsole.log(files('../macros'));\n"})}),"\n",(0,n.jsx)(a.p,{children:"编译后的代码为："}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-javascript",children:'console.log(\'src files:\');\nconsole.log(["index.js", "sourceCode.js"]);\nconsole.log(\'macro files:\');\nconsole.log(["files.macro.js"]);\n'})}),"\n",(0,n.jsx)(a.p,{children:"如果我们写插件，那么就是通过 visitor 找到 files 的函数调用，然后执行 fs.readdirSync 查询出文件列表，之后替换该处的 ast 为 StringLiteral 的数组。"}),"\n",(0,n.jsx)(a.p,{children:"那如果用 macro 怎么写呢？"}),"\n",(0,n.jsx)(a.p,{children:"也是一样的思路，只不过 macro 不需要 visitor，而是直接能找到调用 macro 的对应的 ast，之后进行修改。"}),"\n",(0,n.jsx)(a.p,{children:"下面我们来实现一下上面的 macro。"}),"\n",(0,n.jsxs)(a.h2,{id:"babel-macro-实例",children:["babel macro 实例",(0,n.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#babel-macro-实例",children:"#"})]}),"\n",(0,n.jsx)(a.p,{children:"babel macro 的功能是通过插件实现的，所以要启用 macro，要先引入 babel-plugin-macros 插件。"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-javascript",children:"const { transformFileSync } = require('@babel/core');\nconst path = require('path');\n\nconst sourceFilePath = path.resolve(__dirname, './sourceCode.js');\n\nconst { code } = transformFileSync(sourceFilePath, {\n    plugins: [\n        [\n            'babel-plugin-macros'\n        ]\n    ]\n});\n\nconsole.log(code);\n"})}),"\n",(0,n.jsx)(a.p,{children:"之后，我们在源码中引入了 macro，约定 .macro 结尾的就是 macro。"}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-javascript",children:"const files = require('../macros/files.macro');\n\nconsole.log('src files:');\nconsole.log(files('../src'));\nconsole.log('macro files:');\nconsole.log(files('../macros'));\n"})}),"\n",(0,n.jsx)(a.p,{children:"编译的时候就会调用到我们定义的 macro："}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-javascript",children:"const { createMacro } = require('babel-plugin-macros')\nconst path = require('path');\nconst fs = require('fs');\n\nfunction logMacro({ references, state, babel}) {\n\n}\n\nmodule.exports = createMacro(logMacro);\n"})}),"\n",(0,n.jsx)(a.p,{children:"macro 的形式是一个函数，之后调用 createMacro 的 api，来创建 macro。"}),"\n",(0,n.jsx)(a.p,{children:"当 babel 编译时，会执行 babel macro plugin 插件，而插件里实现了调用 macro 的逻辑，就会把相应的 ast 作为参数传入到 macro，也就是 references 参数。"}),"\n",(0,n.jsx)(a.p,{children:"references 参数是所有调用该 macro 的 ast 的 path 数组，有了 path 之后后面的我们就会了，就是通过 path 的 api 进行 ast 的增删改。"}),"\n",(0,n.jsx)(a.p,{children:"这里的修改 ast 的逻辑就是读取目录下的所有文件，然后用文件列表替换 macro 的 ast。"}),"\n",(0,n.jsx)(a.p,{children:"macro 第一个参数有三个属性："}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"references： 所有引用 macro 的 path"}),"\n",(0,n.jsx)(a.li,{children:"state： macro 之间传递数据的方式，能拿到 filename"}),"\n",(0,n.jsx)(a.li,{children:"babel：各种 api，和 babel plugin 的第一个参数一样。"}),"\n"]}),"\n",(0,n.jsx)(a.pre,{children:(0,n.jsx)(a.code,{className:"language-javascript",children:"const { createMacro } = require('babel-plugin-macros')\nconst path = require('path');\nconst fs = require('fs');\n\nfunction logMacro({ references, state, babel}) {\n  const { default: referredPaths = [] } = references;\n\n  referredPaths.forEach(referredPath => {\n    const dirPath =path.join(path.dirname(state.filename), referredPath.parentPath.get('arguments.0').node.value);\n    \n    const fileNames = fs.readdirSync(dirPath);\n\n    const ast = babel.types.arrayExpression(fileNames.map(fileName => babel.types.stringLiteral(fileName)));\n\n    referredPath.parentPath.replaceWith(ast);\n  });\n}\n\nmodule.exports = createMacro(logMacro);\n"})}),"\n",(0,n.jsx)(a.p,{children:"这样，我们就实现了一个 macro。"}),"\n",(0,n.jsxs)(a.h2,{id:"优缺点",children:["优缺点",(0,n.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#优缺点",children:"#"})]}),"\n",(0,n.jsx)(a.p,{children:"babel macro 优点是不用再通过 visitor 查找 ast 了，只需要在需要转换的地方调用下 macro 的 api，就可以找到对应 ast。"}),"\n",(0,n.jsx)(a.p,{children:"但简化的代价就是查找其他 ast 就不是那么方便了，因为是从一个点的 ast 逐步向上查找的过程。"}),"\n",(0,n.jsxs)(a.h2,{id:"总结",children:["总结",(0,n.jsx)(a.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,n.jsx)(a.p,{children:"babel macro 是基于 babel plugin 封装出来的，不再是通过 visitor 来查找 ast，而是在源码调用 macro 的 api，然后在 macro 的实现里就能拿到所有调用 macro 的 path，之后就可以对 ast 做修改了。"}),"\n",(0,n.jsx)(a.p,{children:"macro 的使用需要引入 babel-plugin-macros 来启用 macro 功能，在源码中引入 .macro结尾的模块，之后在 macro 实现里面调用 crateMacro 来创建 macro。"}),"\n",(0,n.jsx)(a.p,{children:"macro 会传入一个参数，包含 references、state、babel 3个属性，分别是 path 数组、macro 之间传递数据的 state，以及各种 api。"}),"\n",(0,n.jsx)(a.p,{children:"macro 只是一种封装出来的新的修改 ast 的方式，优点是不需要使用 visitor 查找，但缺点是查找其他 ast 不方便。"}),"\n",(0,n.jsxs)(a.p,{children:["（代码在",(0,n.jsx)(a.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:a}=Object.assign({},(0,c.ah)(),e.components);return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(s,{...e})}):s(e)}let o=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F24.Babel%20Macros.md"]={toc:[{text:"babel macro 介绍",id:"babel-macro-介绍",depth:2},{text:"babel macro 实例",id:"babel-macro-实例",depth:2},{text:"优缺点",id:"优缺点",depth:2},{text:"总结",id:"总结",depth:2}],title:"24.Babel Macros",headingTitle:"24.Babel Macros",frontmatter:{}}}}]);