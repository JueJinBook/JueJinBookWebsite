"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["87905"],{762902:function(e,n,r){r.r(n),r.d(n,{default:()=>g});var s=r(552676),i=r(740453);let o=r.p+"static/image/27bd2dd6315f7402d3f28b666c844bf6.83fa5c35.webp",t=r.p+"static/image/d2fe7beea75359a56339aff8a9969b85.1eba6637.webp",a=r.p+"static/image/29a3f04e5778c1efed12223495ac1546.3ff0717a.webp",c=r.p+"static/image/d3ab384e444b30e9f3d1e8d59baa190a.429063b4.webp",p=r.p+"static/image/260dad5107783743f26bd7e050d60379.cf185773.webp",l=r.p+"static/image/fef338141df2a85913d037eef8911fa4.a1be61b7.webp",h=r.p+"static/image/368b956c5999c40f5bfbd93e0e432a4c.27b63068.webp",d=r.p+"static/image/7f523fb59f7777150660a5787a41d926.e6a1e0c5.webp",m=r.p+"static/image/1be2877ea752da32dbed6001b81069b6.da6c6cdb.webp",u=r.p+"static/image/69caafe1669d190cc3f38bc681c9855a.106f0e54.webp";function j(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",strong:"strong",h2:"h2"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"48基于-cdp-实现-puppeteer上",children:["48.基于 CDP 实现 Puppeteer（上）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#48基于-cdp-实现-puppeteer上",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Puppeteer 是一个网页的自动化测试工具，它支持写一些 JS 脚本来控制浏览器执行一些行为，可以用来跑测试用例，或者用来做爬虫。"}),"\n",(0,s.jsx)(n.p,{children:"它的脚本类似这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const puppeteer = require('puppeteer');\nconst fs = require('fs/promises');\n\n(async () => {\n  const browser = await puppeteer.launch({\n    headless: false\n  });\n\n  const page = await browser.newPage();\n\n  await page.goto('https://baidu.com');\n\n  const $input = await page.$('#kw');\n  await $input.type('guangguangguang');\n\n  const $button = await page.$('#su');\n  await $button.click();\n\n  await page.waitForSelector('#container');\n  const screenshot = await page.screenshot();\n  await fs.writeFile('./screenshot.png', screenshot);\n\n  await browser.close();\n})();\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们 launch 了一个浏览器，打开一个标签页，访问 baidu，在输入框输入一些内容，然后点击搜索按钮，等页面出现结果就截下图存到本地文件，然后关闭浏览器。"}),"\n",(0,s.jsx)(n.p,{children:"跑起来是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"其实跑这种脚本不需要看到界面，所以 puppeteer 默认是 headless 的，也就是无界面的。（上面是我把 headless 给关掉了）"}),"\n",(0,s.jsx)(n.p,{children:"这种脚本写起来还是很简单的，就是按照你操作的步骤一步步写对应的脚本就好了，甚至还有录制你的行为来生成 puppeteer 脚本的工具。"}),"\n",(0,s.jsx)(n.p,{children:"今天我们不讲它的应用，而是来探究下它的实现原理。我们能不能自己实现一个呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"puppeteer 是基于 Chrome DevTools Protocol 实现的，会以调试模式跑一个 chromium 的实例，然后通过 WebSocket 连接上它，之后通过 CDP 协议来远程控制。"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"我们写的脚本最终都会转成 CDP 协议来发送给 Chrome 浏览器，这就是它的实现原理。"})}),"\n",(0,s.jsx)(n.p,{children:"接下来我们尝试自己实现一个简易版 puppeteer 来深入理解它。"}),"\n",(0,s.jsxs)(n.p,{children:["要想控制 Chromium，总得先把他下下来吧，所以这一节我们来实现 Chromium 的自动下载（",(0,s.jsx)(n.strong,{children:"这节不涉及 CDP，大家简单看下就行，重点在下一节"}),"）。"]}),"\n",(0,s.jsx)(n.p,{children:"google 有个网站存储了所有版本、所有平台的 chromium，它的 url 是这样的："}),"\n",(0,s.jsx)(n.p,{children:"mac 的 url："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://storage.googleapis.com/chromium-browser-snapshots/Mac/%E7%89%88%E6%9C%AC%E5%8F%B7/chrome-mac.zip",target:"_blank",rel:"noopener noreferrer",children:"https://storage.googleapis.com/chromium-browser-snapshots/Mac/版本号/chrome-mac.zip"})}),"\n",(0,s.jsx)(n.p,{children:"linux 的 url："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://storage.googleapis.com/chromium-browser-snapshots/Linux_x64/%E7%89%88%E6%9C%AC%E5%8F%B7/chrome-linux.zip",target:"_blank",rel:"noopener noreferrer",children:"https://storage.googleapis.com/chromium-browser-snapshots/Linux_x64/版本号/chrome-linux.zip"})}),"\n",(0,s.jsx)(n.p,{children:"win32 的 url："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://storage.googleapis.com/chromium-browser-snapshots/Win/%E7%89%88%E6%9C%AC%E5%8F%B7/chrome-win32.zip",target:"_blank",rel:"noopener noreferrer",children:"https://storage.googleapis.com/chromium-browser-snapshots/Win/版本号/chrome-win32.zip"})}),"\n",(0,s.jsx)(n.p,{children:"win64 的 url："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/%E7%89%88%E6%9C%AC%E5%8F%B7/chrome-win32.zip",target:"_blank",rel:"noopener noreferrer",children:"https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/版本号/chrome-win32.zip"})}),"\n",(0,s.jsx)(n.p,{children:"你可以把 url 换成具体的版本号试试，比如 468266、546920"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"所有的版本号可以在国内的一个镜像网站看到："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://registry.npmmirror.com/binary.html?path=chromium-browser-snapshots/",target:"_blank",rel:"noopener noreferrer",children:"https://registry.npmmirror.com/binary.html?path=chromium-browser-snapshots/"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"把下载下来的 zip 包解压，这个不就是我们要的 chromium 浏览器么？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"流程是这么个流程，但我们肯定不能手动搞，要做成自动化的。"}),"\n",(0,s.jsx)(n.p,{children:"因为安装 puppeteer 之后是要下载这个 chromium 的，不能让开发者手动去下吧。"}),"\n",(0,s.jsx)(n.p,{children:"所以接下来我们就把这个流程给自动化了。"}),"\n",(0,s.jsx)(n.p,{children:"我们一步步来，首先是下载 chromium 到本地的一个目录："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const os = require('os');\nconst path = require('path');\nconst extract = require('extract-zip');\nconst util = require('util');\n\nconst CHROMIUM_PATH = path.join(__dirname, '..', '.local-chromium');\n\nconst downloadURLs = {\n    linux: 'https://storage.googleapis.com/chromium-browser-snapshots/Linux_x64/%d/chrome-linux.zip',\n    darwin: 'https://storage.googleapis.com/chromium-browser-snapshots/Mac/%d/chrome-mac.zip',\n    win32: 'https://storage.googleapis.com/chromium-browser-snapshots/Win/%d/chrome-win32.zip',\n    win64: 'https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/%d/chrome-win32.zip',\n};\n\nasync function downloadChromium(revision, progressCallback) {\n    let url = null;\n\n    const platform = os.platform();\n    if (platform === 'darwin')\n        url = downloadURLs.darwin;\n    else if (platform === 'linux')\n        url = downloadURLs.linux;\n    else if (platform === 'win32')\n        url = os.arch() === 'x64' ? downloadURLs.win64 : downloadURLs.win32;\n\n    console.assert(url, `Unsupported platform: ${platform}`);\n\n    url = util.format(url, revision);\n    \n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"首先，下载到的本地目录是 .local-chromium，我们根据输入的版本号，以及从 os.platform() 拿到的系统信息来确定下载的 url。"}),"\n",(0,s.jsx)(n.p,{children:"有两个 node 的 api 要解释下："}),"\n",(0,s.jsx)(n.p,{children:"console.assert 就是第一个参数的值为 false 的时候，才输出第二个参数的信息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"util.format 是格式化字符串用的，有一些占位符，%d 是数字、%s 是字符串、%j 是 JSON 等："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"到了这里，就拿到了下载 chromium 的 url。"}),"\n",(0,s.jsx)(n.p,{children:"那么接下来就是用 https 访问这个 url，下载到本地的目录了。"}),"\n",(0,s.jsx)(n.p,{children:"我们接下来实现下载到本地的功能："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const https = require('https');\n\nfunction downloadFile(url, destinationPath, progressCallback) {\n    let resolve , reject;\n    const promise = new Promise((x, y) => { resolve = x; reject = y; });\n\n    const request = https.get(url, response => {\n        if (response.statusCode !== 200) {\n            const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);\n            response.resume();\n            reject(error);\n            return;\n        }\n\n        const file = fs.createWriteStream(destinationPath);\n\n        file.on('finish', () => resolve ());\n        file.on('error', error => reject(error));\n\n        response.pipe(file);\n    });\n    request.on('error', error => reject(error));\n    return promise;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"因为这个下载过程是异步的，我们希望返回一个 promise。"}),"\n",(0,s.jsx)(n.p,{children:"很多人写返回 promsie 的方法都是这么写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function func() {\n    return new Promise((resolve, reject) => {\n\n        // resolve();\n\n        // reject()\n    });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"其实也可以这么写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function func() {\n    let resolve , reject;\n    const promise = new Promise((x, y) => { resolve = x; reject = y; });\n\n    // resolve();\n    // reject();\n\n    return promise;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"中间的部分就是用 https.get 下载 url 的数据了，不过这个回调函数的 response 参数是一个流。"}),"\n",(0,s.jsx)(n.p,{children:"为什么呢？"}),"\n",(0,s.jsx)(n.p,{children:"因为如果数据很多，需要等好久才能传完，那要等全部传完再处理么？"}),"\n",(0,s.jsx)(n.p,{children:"不用，可以每传一部分就处理一部分。这就是流的思想。"}),"\n",(0,s.jsx)(n.p,{children:"基本所有语言处理网络和文件 IO 的 api 都是基于流的。"}),"\n",(0,s.jsx)(n.p,{children:"我们创建了一个写入流，写入到本地的文件的，然后把响应流 pipe 到文件流，也就是直接写入到文件里了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const file = fs.createWriteStream(destinationPath);\n\nfile.on('finish', () => resolve ());\nfile.on('error', error => reject(error));\n\nresponse.pipe(file);\n"})}),"\n",(0,s.jsx)(n.p,{children:"失败的时候，流中的数据就不需要了，所以要调用 response.resume() 来消费掉。"}),"\n",(0,s.jsx)(n.p,{children:"这样就实现了下载功能。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"接下来实现第二步，解压缩："}),"\n",(0,s.jsx)(n.p,{children:"这个自己处理就比较麻烦了，直接用第三方的包就行，比如 extract-zip："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const extract = require('extract-zip');\n\nfunction extractZip(zipPath, folderPath) {\n    return new Promise(resolve  => extract(zipPath, {dir: folderPath}, resolve ));\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在处理完下载的 url 之后，调用下这两步："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const zipPath = path.join(CHROMIUM_PATH, `download-${revision}.zip`);\nconst folderPath = path.join(CHROMIUM_PATH, revision);\n\nif (fs.existsSync(folderPath)) {\n    return;\n}\n\ntry {\n    if (!fs.existsSync(CHROMIUM_PATH)) {\n        fs.mkdirSync(CHROMIUM_PATH);\n    }\n\n    await downloadFile(url, zipPath, progressCallback);\n    await extractZip(zipPath, folderPath);\n} catch(e) {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"首先确定 zip 包的路径和解压到的目录的路径，如果目录已经存在了，那就不下载了。"}),"\n",(0,s.jsx)(n.p,{children:"否则调用刚才实现的两个方法来下载 zip 和解压缩。"}),"\n",(0,s.jsx)(n.p,{children:"chromium 下载还是比较慢的，我们给它加个进度条："}),"\n",(0,s.jsx)(n.p,{children:"也就是给 response 流的 data 事件加个回调，把从 content-length 拿到的数据的总大小，还有当前 chunk 的数据大小传过去："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const totalBytes = parseInt(response.headers['content-length'], 10);\nif (progressCallback)\n    response.on('data', onData.bind(null, totalBytes));\n    \nfunction onData(totalBytes, chunk) {\n    progressCallback(totalBytes, chunk.length);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"那用的时候就可以在这个回调里显示个进度条了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const Downloader = require('./lib/Downloader');\nconst revision = require('./package').puppeteer.chromium_revision;\nconst ProgressBar = require('progress');\n\nDownloader.downloadChromium(revision, onProgress)\n    .catch(error => {\n        console.error('Download failed: ' + error.message);\n    });\n\nlet progressBar = null;\nfunction onProgress(bytesTotal, delta) {\n    if (!progressBar) {\n        progressBar = new ProgressBar(`Downloading Chromium - ${toMegabytes(bytesTotal)} [:bar] :percent :etas `, {\n            complete: '=',\n            incomplete: ' ',\n            width: 20,\n            total: bytesTotal,\n        });\n    }\n    progressBar.tick(delta);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Downloader 就是我们刚刚实现的下载解压的逻辑，revision 是版本号，这个在 package.json 里配置。"}),"\n",(0,s.jsx)(n.p,{children:"progress 是一个第三方的控制台进度条，传入宽度、总大小和显示的字符，每次调用 tick 更新下长度就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"我们来整体试一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"下载、解压、进度条都没问题，下载下来的 chromium 也能正常跑起来："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"至此，我们就实现了 chromium 的自动下载，只要在 package.json 里配一个版本号，就能自动下载。"}),"\n",(0,s.jsx)(n.p,{children:"当然，现在还不算完全自动，还要手动执行 node install.js"}),"\n",(0,s.jsx)(n.p,{children:"可以把它配在 postinstall 的 npm scripts 里，安装完依赖之后触发下载："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["这一节的完整代码在",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/fe-debug-exercize",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"里，大家可以下下来跑跑"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"puppeteer 是一个基于 CDP 实现的网页自动化测试工具，可以用来跑测试用例，也可以用来做爬虫等。"}),"\n",(0,s.jsx)(n.p,{children:"为了深入理解它的实现原理，我们会从 0 实现一个 mini puppeteer。"}),"\n",(0,s.jsx)(n.p,{children:"这节我们实现了自动下载 chromium："}),"\n",(0,s.jsx)(n.p,{children:"chromium 所有平台和版本的 zip 包都在 google 的一个网站上存着，通过 os 模块拿到系统信息，再根据传入的版本号就能确定 url。"}),"\n",(0,s.jsx)(n.p,{children:"确定了 url 之后通过 https 模块就可以下载，通过流的方式写入本地文件，并且在每次有 data 的时候更新下进度条。"}),"\n",(0,s.jsx)(n.p,{children:"最后通过第三方的 extract-zip 包实现了解压缩。"}),"\n",(0,s.jsx)(n.p,{children:"并且把这个脚本配到了 postinstall 的 npm scripts 里，只要安装完依赖就会自动下载。"}),"\n",(0,s.jsx)(n.p,{children:"下载 Chromium 只是第一步，下一节我们把 Chromium 跑起来实现远程控制。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(j,{...e})}):j(e)}let g=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F48.%E5%9F%BA%E4%BA%8E%20CDP%20%E5%AE%9E%E7%8E%B0%20Puppeteer%EF%BC%88%E4%B8%8A%EF%BC%89.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"48.基于 CDP 实现 Puppeteer（上）",headingTitle:"48.基于 CDP 实现 Puppeteer（上）",frontmatter:{}}}}]);