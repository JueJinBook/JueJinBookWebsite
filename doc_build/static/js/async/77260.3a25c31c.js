"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["77260"],{476250:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var d=r(552676),s=r(740453);let i=r.p+"static/image/af2dc3152346a1e7932a43403d0507fd.0342b0c2.png";function o(e){let n=Object.assign({p:"p",code:"code",h2:"h2",a:"a",ul:"ul",li:"li",pre:"pre",h3:"h3",h4:"h4",strong:"strong",blockquote:"blockquote",img:"img"},(0,s.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.p,{children:["前面的章节，我们提到了 ",(0,d.jsx)(n.code,{children:"Electron"})," 的原生能力中包含一些 Electron 所提供的原生 API，以及 Node.js 提供的一些底层能力，还可以通过 Node.js 调用一些原生模块以及通过 Node.js 调用一些操作系统的 OS 脚本。"]}),"\n",(0,d.jsx)(n.p,{children:"这个小节，我们将详细介绍这几种原生能力的使用方式，帮助你更好地使用一些原生功能。"}),"\n",(0,d.jsxs)(n.h2,{id:"electron-的原生-gui-能力",children:["Electron 的原生 GUI 能力",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#electron-的原生-gui-能力",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"我们知道，Electron 通过集成浏览器内核，使用 Web 技术来实现不同平台下的渲染，并结合了 Chromium、Node.js 和用于调用系统本地功能的 API 三大板块。但是 Chromium 并不具备原生 GUI（图形用户界面，Graphical User Interface） 的操作能力，因此 Electron 内部集成一些原生 GUI 的 API，编写 UI 的同时也能够调用操作系统的底层 API。"}),"\n",(0,d.jsx)(n.p,{children:"在 Electron 中，涉及到原生 GUI 的 API 主要有以下几个："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/browser-window",target:"_blank",rel:"noopener noreferrer",children:"BrowserWindow 应用窗口"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/tray",target:"_blank",rel:"noopener noreferrer",children:"Tray 托盘"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/notification",target:"_blank",rel:"noopener noreferrer",children:"Notification 通知"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/menu",target:"_blank",rel:"noopener noreferrer",children:"Menu 菜单"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/dialog",target:"_blank",rel:"noopener noreferrer",children:"dialog 原生弹窗"})}),"\n",(0,d.jsx)(n.li,{children:"……"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["对于开发者而言，这些原生 GUI API 都是可以跨平台的，比如 ",(0,d.jsx)(n.code,{children:"Notification"})," 模块，对于开发者的使用方式："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// main process\nconst notify = new Notification({\n  title: '标题',\n  body: '这是内容',\n});\nnotify.show();\n"})}),"\n",(0,d.jsx)(n.p,{children:"Electron 底层会根据操作系统的不同，调用不同的原生 API，进而展示出不同的交互样式。"}),"\n",(0,d.jsx)(n.p,{children:"MacOS："}),"\n",(0,d.jsx)(n.p,{children:"Windows："}),"\n",(0,d.jsxs)(n.h2,{id:"electron-操作系统底层能力的-api",children:["Electron 操作系统底层能力的 API",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#electron-操作系统底层能力的-api",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["除了上面介绍的一些原生 ",(0,d.jsx)(n.code,{children:"GUI"})," 能力外，Electron 还提供了一些对操作系统底层能力的封装 API。常用的有："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/clipboard",target:"_blank",rel:"noopener noreferrer",children:"clipboard 剪贴板"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/global-shortcut",target:"_blank",rel:"noopener noreferrer",children:"globalShortcut 全局快捷键"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/screen",target:"_blank",rel:"noopener noreferrer",children:"screen 屏幕"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/zh/docs/latest/api/desktop-capturer",target:"_blank",rel:"noopener noreferrer",children:"desktopCapturer 音视频捕捉"})}),"\n",(0,d.jsx)(n.li,{children:"……"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"使用对应模块也是非常方便，比如需要跨平台的向系统剪贴板中读写文本："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import { clipboard } from 'electron';\n  \nclipboard.writeText('Example string', 'selection');  \nconsole.log(clipboard.readText('selection'));\n"})}),"\n",(0,d.jsxs)(n.h2,{id:"nodejs-的-api",children:["Node.js 的 API",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-的-api",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["前面的章节，我们提到了 ",(0,d.jsx)(n.code,{children:"Electron"})," 架构中使用了 ",(0,d.jsx)(n.code,{children:"Chromium"})," 的 ",(0,d.jsx)(n.code,{children:"Renderer Process"})," 渲染界面，",(0,d.jsx)(n.code,{children:"Renderer Process"})," 可以有多个，并且 ",(0,d.jsx)(n.code,{children:"Electron"})," 为其集成了 ",(0,d.jsx)(n.code,{children:"Node"})," 运行时。但每个应用程序只能有一个主线程，主线程位于\xa0",(0,d.jsx)(n.code,{children:"Node.js"}),"\xa0下运行。"]}),"\n",(0,d.jsxs)(n.p,{children:["因此，在 Electron 中，我们可以在渲染进程和主进程中使用 ",(0,d.jsx)(n.code,{children:"Node.js"}),"。既然我们可以使用 Node 能力，那么 ",(0,d.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v20.x/docs/api/",target:"_blank",rel:"noopener noreferrer",children:"Node.js"})," 中所有的 ",(0,d.jsx)(n.code,{children:"API"})," 我们都可以直接使用。"]}),"\n",(0,d.jsxs)(n.p,{children:["比如：我们使用 ",(0,d.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v20.x/docs/api/fs.html",target:"_blank",rel:"noopener noreferrer",children:"fs"})," 模块进行文件的读写操作，使用 ",(0,d.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v20.x/docs/api/os.html",target:"_blank",rel:"noopener noreferrer",children:"OS"})," 模块来提供操作系统相关的实用方法和属性。可以使用 Node npm 包进行一些额外的功能集成。"]}),"\n",(0,d.jsxs)(n.p,{children:["需要注意的是，不同 Electron 版本集成的 Node.js 版本不一样，所以在使用 Node.js API 的时候要注意版本问题，可以通过 ",(0,d.jsx)(n.a,{href:"https://releases.electronjs.org/",target:"_blank",rel:"noopener noreferrer",children:"Electron release 记录"}),"查询到对应的 Node 版本。"]}),"\n",(0,d.jsxs)(n.h2,{id:"nodejs-调用原生能力",children:["Node.js 调用原生能力",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-调用原生能力",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"虽然 Electron 已经为我们提供了大量的跨平台的 Native APIs，但是依然不能涵盖到桌面端应用开发的方方面面，接下来的内容将会简要介绍 node 调用原生能力的几种方式和方法。"}),"\n",(0,d.jsxs)(n.h3,{id:"1-使用-c-构建-node-原生模块",children:["1. 使用 C++ 构建 node 原生模块",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-使用-c-构建-node-原生模块",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["作为前端开发者而言，都或多或少依赖一些 native addon。在前端中比较常见的比如\xa0",(0,d.jsx)(n.code,{children:"node-sass"}),"、\xa0",(0,d.jsx)(n.code,{children:"node-canvas"}),"、\xa0",(0,d.jsx)(n.code,{children:"sharp"}),"\xa0等。在介绍使用 C++ 构建原生模块前，我们需要先储备一些基础知识。"]}),"\n",(0,d.jsxs)(n.h4,{id:"11-原生模块的本质",children:["1.1 原生模块的本质",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-原生模块的本质",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"在介绍使用 C++ 构建 node 原生模块之前，我们需要先了解一下原生模块本质。"}),"\n",(0,d.jsxs)(n.p,{children:["当一个 Node.js 的 C++ 模块在 OSX 下编译会得到一个后缀是\xa0 *",(0,d.jsx)(n.strong,{children:".node"}),"\xa0的模块，本质上是\xa0 *",(0,d.jsx)(n.strong,{children:".dylib"}),"\xa0的动态链接库；而在 Windows 上本质上是\xa0 *",(0,d.jsx)(n.strong,{children:".dll"}),"\xa0的动态链接库。在 Linux 下则是 ",(0,d.jsx)(n.strong,{children:".so"})," 的动态链接库。"]}),"\n",(0,d.jsxs)(n.h4,{id:"12-node-gyp",children:["1.2 node-gyp",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-node-gyp",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"node-gyp"})," 是一个 Node.js 包，它用于构建 Node.js C++ 扩展。这个工具允许你编译和构建需要 C++ 代码的 Node.js 模块。它是一个使用 Python 和 C++ 构建 Node.js 扩展的构建系统。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"node-gyp"})," 是基于 Google 的 gyp 构建系统实现的构建工具，它会识别包或者项目中的\xa0",(0,d.jsx)(n.strong,{children:"binding.gyp"})," 文件，然后根据该配置文件生成各系统下能进行编译的项目，如 ",(0,d.jsx)(n.code,{children:"Windows"})," 下生成 ",(0,d.jsx)(n.code,{children:"Visual Studio"})," 项目文件（ *",(0,d.jsx)(n.strong,{children:".sln"}),"\xa0等），",(0,d.jsx)(n.code,{children:"Unix"})," 下生成 ",(0,d.jsx)(n.code,{children:"Makefile"}),"。在生成这些项目文件之后，",(0,d.jsx)(n.code,{children:"node-gyp"})," 还能调用各系统的编译工具（如 GCC）来将项目进行编译，得到最后的动态链接库\xa0 *",(0,d.jsx)(n.strong,{children:".node"}),"\xa0文件。"]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["从上面的描述，可以知道，在使用 node-gyp 前需要安装\xa0",(0,d.jsx)(n.strong,{children:"python"}),"\xa0环境和\xa0",(0,d.jsx)(n.strong,{children:"C++"})," \xa0环境。Windows 下编译 C++ 原生模块是依赖 Visual Studio 的，但不是必须的，也可以只安装它的编译器 ",(0,d.jsx)(n.a,{href:"https://visualstudio.microsoft.com/zh-hans/thank-you-downloading-visual-studio/?sku=BuildTools",target:"_blank",rel:"noopener noreferrer",children:"Visual Studio Build Tools"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["更多在 Windows 下安装 ",(0,d.jsx)(n.code,{children:"node-gyp"})," 构建环境的教程可以参考这篇文章：",(0,d.jsx)(n.a,{href:"https://juejin.cn/post/7118412140582535175",target:"_blank",rel:"noopener noreferrer",children:"windows 下 node-gyp 的环境配置"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.h4,{id:"13-编写-c-扩展的几种方式",children:["1.3 编写 C++ 扩展的几种方式",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-编写-c-扩展的几种方式",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"NAN（Native Abstractions for Node.js）"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.a,{href:"https://github.com/nodejs/nan",target:"_blank",rel:"noopener noreferrer",children:"NAN"}),"（Node.js 的原生抽象）是一个库，提供了一组跨不同版本的 Node.js API 的抽象层。它的目标是帮助开发者编写跨版本兼容的 Node.js C++ 插件。由于 Node.js 的 API 在不同版本之间可能会变化，NAN 提供了一种方式来编写稳定的跨版本插件。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"N-API（Node-API）"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node-addon-api",target:"_blank",rel:"noopener noreferrer",children:"NAPI"}),"\xa0是\xa0Node\xa0在\xa08.x\xa0版本提出的一个新特性，主要为开发者编写\xa0Node.js\xa0原生\xa0C/C++\xa0插件提供了一个更为便捷和易于理解的方式。它提供了一个稳定的、应对 Node.js 版本变化的抽象层，允许开发者编写与 Node.js 引擎解耦的代码。这意味着，即使 Node.js 更新版本，使用 ",(0,d.jsx)(n.code,{children:"N-API"})," 编写的插件也可以继续在新版本上运行。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)(n.strong,{children:"node-addon-api"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node-addon-api",target:"_blank",rel:"noopener noreferrer",children:"Node-addon-api"})," 是 Node.js 提供的另一个 C++ 扩展 API。它是一个用于编写跨平台的 Node.js C++ 扩展的库。Node-addon-api 是构建在 NAPI 之上的，提供了更加简单的 API，使得扩展开发者可以更加容易地编写跨版本、跨平台的扩展。它还提供了一些方便的功能，如自动内存管理、V8 值的类型转换等。"]}),"\n",(0,d.jsx)(n.p,{children:"这三个工具或 API 都是为了帮助开发者编写可移植、跨平台的 Node.js C++ 插件，但它们的定位和功能略有不同。N-API 是官方提供的稳定接口，而 NAN 则是它的前身，node-addon-api 则是基于 N-API 的高级封装。"}),"\n",(0,d.jsxs)(n.h4,{id:"14-bindinggyp",children:["1.4 binding.gyp",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14-bindinggyp",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"binding.gyp"})," 是一个用于描述 Node.js 插件构建过程的配置文件。这个文件使用 JSON 格式，但它实际上是为了描述构建系统（例如 Node-gyp）所需的构建配置和元数据。"]}),"\n",(0,d.jsxs)(n.p,{children:["下面是一个使用 node-addon-api 编写的模块的 ",(0,d.jsx)(n.code,{children:"binding.gyp"})," 文件示例："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:'// binding.gyp\n{\n  "targets": [\n    {\n      // 链接目标,链接之后，生成 "hello.node"\n      "target_name": "hello",\n      "cflags!": [ "-fno-exceptions" ],\n      "cflags_cc!": [ "-fno-exceptions" ],\n      \n      // C++ 源文件\n      "sources": [\n        "./src/hello.cpp",\n        "./src/index.cpp"\n      ],\n      \n      // C++ 头文件目录  \n      "include_dirs": ["<!(node -p \\"require(\'node-addon-api\').include_dir\\")"],\n \n      // 预编译宏\n      "defines": [ \n        "NAPI_DISABLE_CPP_EXCEPTIONS"\n      ],\n      // 静态库\n      "libraries":[]\n    }\n  ]\n}\n'})}),"\n",(0,d.jsxs)(n.h4,{id:"15-开发一个-c-扩展",children:["1.5 开发一个 C++ 扩展",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15-开发一个-c-扩展",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"有了上面的知识，我们来介绍一下如何开发一个简单的 C++ 扩展。先来看看目录结构："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-shell",children:".\n├── binding.gyp\n├── hello.cc\n├── index.js\n└── package.json\n"})}),"\n",(0,d.jsx)(n.p,{children:"然后，创建一个原生模块的配置文件 binding.gyp，如下代码所示："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-json",children:'{\n  "targets": [\n    {\n      "target_name": "hello",\n      "cflags!": [ "-fno-exceptions" ],\n      "defines": ["NAPI_DISABLE_CPP_EXCEPTIONS"],\n      "cflags_cc!": [ "-fno-exceptions" ],\n      "sources": [ "hello.cc" ],\n      "include_dirs": ["<!(node -p "require(\'node-addon-api\').include_dir")"],\n    }\n  ]\n}\n'})}),"\n",(0,d.jsxs)(n.p,{children:["接下来编写 ",(0,d.jsx)(n.code,{children:"hello.cc"})," 文件："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-C++",children:'#include <napi.h>\n\nNapi::String Method(const Napi::CallbackInfo& info) {\n  Napi::Env env = info.Env();\n  return Napi::String::New(env, "world");\n}\n\nNapi::Object Init(Napi::Env env, Napi::Object exports) {\n  exports.Set(Napi::String::New(env, "hello"),\n              Napi::Function::New(env, Method));\n  return exports;\n}\n\nNODE_API_MODULE(NODE_GYP_MODULE_NAME, Init)\n'})}),"\n",(0,d.jsxs)(n.p,{children:["其中通过\xa0",(0,d.jsx)(n.code,{children:"Napi::CallbackInfo&"}),"\xa0来获取函数参数，例如\xa0",(0,d.jsx)(n.code,{children:"info[0]"}),"\xa0代表第一个参数。",(0,d.jsx)(n.code,{children:"info.Env()"})," 返回一个 ",(0,d.jsx)(n.code,{children:"Napi::Env"})," 对象，代表了当前的 Node.js 环境。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Napi::Env"}),"\xa0是对 napi_env 的封装，代表一个 JavaScript 上下文，大部分和 JavaScript 交互的场景都需要这个上下文，可以保存起来以供下次使用（但是不要跨线程使用）。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Napi::String::New"})," 用来构建 JavaScript 值，比如 ",(0,d.jsx)(n.code,{children:' Napi::String::New(env, "hello")'})," 就是创建了一个字符串 ",(0,d.jsx)(n.code,{children:'"hello"'}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Napi::Object exports"}),"\xa0则是这个模块的 exports 对象，可以把想要给 JavaScript 暴露的值和函数通过 ",(0,d.jsx)(n.code,{children:"exports.Set"})," 设置到这个上面。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"NODE_API_MODULE"}),"\xa0这个宏方法定义此原生模块的入口函数，一旦 Node.js 加载该模块时，将执行 Init 方法，",(0,d.jsx)(n.code,{children:"NODE_GYP_MODULE_NAME"}),"\xa0宏展开后为编译配置文件 ",(0,d.jsx)(n.code,{children:"binding.gyp"})," 中的 ",(0,d.jsx)(n.code,{children:"target_name"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["接着，使用 ",(0,d.jsx)(n.code,{children:"node-gyp"})," 来构建项目："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-shell",children:"$ node-gyp configure build\n"})}),"\n",(0,d.jsxs)(n.p,{children:["关于 ",(0,d.jsx)(n.code,{children:"node-gyp"})," 常用的命令："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"node-gyp configure"}),"： 这个命令用于配置构建环境。它会检查你的系统环境并生成相应的构建文件，例如在 Windows 上会生成 Visual Studio 的项目文件或在 macOS 上生成 Xcode 的项目文件。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"node-gyp build"}),"： 使用这个命令来执行实际的构建过程。它会根据 ",(0,d.jsx)(n.code,{children:"binding.gyp"})," 文件中的配置进行编译和构建，生成可加载的 Node.js 模块。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"node-gyp clean"}),"： 清理构建产生的中间文件和输出目录。这个命令会删除构建生成的文件，以便重新开始构建过程。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"node-gyp rebuild"}),"： 这个命令相当于执行了 ",(0,d.jsx)(n.code,{children:"clean"})," 后再进行 ",(0,d.jsx)(n.code,{children:"configure"})," 和 ",(0,d.jsx)(n.code,{children:"build"}),"。它会重新构建你的模块，无论是否已经构建过。"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"node-gyp install"}),"： 用于安装 Node.js 模块的依赖。它会查找 ",(0,d.jsx)(n.code,{children:"binding.gyp"})," 文件中列出的依赖，并尝试安装所需的组件。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["最后，编写一个 ",(0,d.jsx)(n.code,{children:"index.js"})," 来引用编译好的 ",(0,d.jsx)(n.code,{children:"hello.node"})," 文件"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const addon = require('./build/Release/hello.node');\n\nmodule.exports = addon;\n"})}),"\n",(0,d.jsxs)(n.h4,{id:"16-使用-node-bindings-包",children:["1.6 使用 node-bindings 包",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16-使用-node-bindings-包",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在上面的例子中，我们在 ",(0,d.jsx)(n.code,{children:"index.js"})," 文件中，直接通过相对路径的方式引用了编译好的 ",(0,d.jsx)(n.code,{children:".node"})," 文件。但是在大多数情况下，由于 Node.js Addon 存在各种不同的方案、构建配置，那 .node 文件产物的位置可能也会因此不同，所以我们需要借助一个 ",(0,d.jsx)(n.a,{href:"https://github.com/TooTallNate/node-bindings",target:"_blank",rel:"noopener noreferrer",children:"node-bindings"})," 包来自动为我们寻找 .node 文件的位置："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const addon = require('bindings')('hello.node');\n\nmodule.exports = addon;\n"})}),"\n",(0,d.jsxs)(n.h4,{id:"17-使用-node-pre-gyp",children:["1.7 使用 node-pre-gyp",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17-使用-node-pre-gyp",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["由于使用安装包的用户可能存在着不同的操作系统和 node ABI 版本，为了可以自动编译当前系统架构所对应的产物，我们大多数情况下不得不让用户在安装 C++ 扩展包时使用用户设备进行 Addon 的编译，那么这个时候就需要修改一下我们扩展包的 ",(0,d.jsx)(n.code,{children:"package.json"})," 文件："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "install": "prebuild-install || node-gyp rebuild --release"\n  }\n}\n'})}),"\n",(0,d.jsxs)(n.p,{children:["这里我们添加了一个 ",(0,d.jsx)(n.code,{children:"install"})," 钩子，来确保用户在执行 ",(0,d.jsx)(n.code,{children:"npm install"})," 时执行 ",(0,d.jsx)(n.code,{children:"node-gyp rebuild"})," 命令来进行本地编译。"]}),"\n",(0,d.jsxs)(n.p,{children:["但这对没有 C++ 编译环境的用户来说，使用这个扩展是个非常头疼的问题，因为会各种报错。因此，如果你希望让用户无需具备编译环境即可安装 Addon，那么你可以使用 ",(0,d.jsx)(n.a,{href:"https://github.com/mapbox/node-pre-gyp",target:"_blank",rel:"noopener noreferrer",children:"node-pre-gyp"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"node-pre-gyp"})," 允许开发者将预编译的 Node.js 插件发布到各种平台（Windows、macOS、Linux 等）。这样，用户可以在安装时直接获取预编译的二进制文件，而不需要在他们的机器上进行编译。"]}),"\n",(0,d.jsxs)(n.p,{children:["这个时候，你的 ",(0,d.jsx)(n.code,{children:"package.json"})," 需要指定对应编译好的 ",(0,d.jsx)(n.code,{children:".node"})," 文件下载地址，并添加一个 ",(0,d.jsx)(n.code,{children:"install"})," 钩子，让用户在执行 ",(0,d.jsx)(n.code,{children:"npm install"})," 的时候，通过 ",(0,d.jsx)(n.code,{children:"node-pre-gyp install"})," 寻找预编译好的二进制 ",(0,d.jsx)(n.code,{children:".node"})," 文件。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"node-pre-gyp"})," 会先检查项目本地是否已经存在二进制构建文件，当不存在时进入用户本地查找，当用户本地也不存在时会执行 http 下载。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-json",children:'"dependencies"  : {\n  "@mapbox/node-pre-gyp": "1.x"\n},\n"devDependencies": {\n  "aws-sdk": "2.x"\n}\n"scripts": {\n  "install": "node-pre-gyp install --fallback-to-build"\n},\n"binary": {\n  "module_name": "your_module",\n  "module_path": "./lib/binding/",\n  "host": "https://your_module.s3-us-west-1.amazonaws.com"\n}\n'})}),"\n",(0,d.jsxs)(n.h4,{id:"18-electron-上引入原生模块",children:["1.8 Electron 上引入原生模块",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18-electron-上引入原生模块",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"如果你使用的 C++ 扩展是通过安装时编译而不是预编译的方式实现的，那么 Electron 在引入包进行本地编译时，编译出的原生模块不一定能在 Electron 应用中正常工作，有可能会报以下错误："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-bash",children:"Error: The module '/path/to/native/hello.node'\nwas compiled against a different Node.js version using\nNODE_MODULE_VERSION 51. This version of Node.js requires\nNODE_MODULE_VERSION 57. Please try re-compiling or re-installing\nthe module (for instance, using `npm rebuild` or `npm install`).\n"})}),"\n",(0,d.jsxs)(n.p,{children:["原因就是我们前面提到了，Electron 自己内部集成了一个 ",(0,d.jsx)(n.code,{children:"Node.js"})," 环境，那么就有可能出现 ",(0,d.jsx)(n.strong,{children:"Electron 内置的 Node.js 的版本可能与你编译原生模块使用的 Node.js 的版本不同"})," 的情况。"]}),"\n",(0,d.jsxs)(n.p,{children:["遇到这种情况，建议开发者使用 Electron 团队提供的\xa0",(0,d.jsx)(n.a,{href:"https://github.com/electron/rebuild",target:"_blank",rel:"noopener noreferrer",children:"electron-rebuild"}),"\xa0工具来进行重新编译，因为 electron-rebuild 会帮我们确定 Electron 的版本号、Electron 内置的 Node.js 的版本号、以及 Node.js 使用的 ABI 的版本号，并根据这些版本号下载不同的头文件和类库："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-bash",children:"npm install --save-dev electron-rebuild\n\n# 第04章—基础篇：Electron的原生能力\n./node_modules/.bin/electron-rebuild --force --module-dir=xxx\n\n# 在 windows 下如果上述命令遇到了问题，尝试这个：\n.\\node_modules.bin\\electron-rebuild.cmd --force --module-dir=xxx\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"2-使用-node-ffi-napi-调用动态链接库",children:["2. 使用 node-ffi-napi 调用动态链接库",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-使用-node-ffi-napi-调用动态链接库",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.a,{href:"https://github.com/node-ffi-napi/node-ffi-napi",target:"_blank",rel:"noopener noreferrer",children:" node-ffi-napi"})," 是一个用于使用纯 JavaScript 加载和调用动态库的 Node.js 插件。它可以用来在不编写任何 C++ 代码的情况下创建与本地 DLL 库的绑定。同时它负责处理跨 JavaScript 和 C 的类型转换。"]}),"\n",(0,d.jsx)(n.p,{children:"但是，它的性能可能较低，并且不适用于需要较高性能或对 V8 引擎更深层次控制的情况。"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"node-ffi-napi"})," 通过 ",(0,d.jsx)(n.code,{children:"Buffer"})," 类，在 C 代码和 JS 代码之间实现了内存共享，类型转换则是通过 ",(0,d.jsx)(n.a,{href:"https://github.com/node-ffi-napi/ref-napi",target:"_blank",rel:"noopener noreferrer",children:"ref-napi"}),"、",(0,d.jsx)(n.a,{href:"https://github.com/Janealter/ref-array-napi",target:"_blank",rel:"noopener noreferrer",children:"ref-array-napi"})," 实现。由于 ",(0,d.jsx)(n.code,{children:"node-ffi-napi"})," / ",(0,d.jsx)(n.code,{children:"ref-napi"})," 包含 C 原生代码，所以安装需要配置 Node 原生插件编译环境。"]}),"\n",(0,d.jsxs)(n.h4,{id:"一个简单的示例",children:["一个简单的示例",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一个简单的示例",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在 Windows 平台上，动态链接库指的是 ",(0,d.jsx)(n.code,{children:".dll"})," 文件，关于如何开发一个 ",(0,d.jsx)(n.code,{children:".dll"})," 文件，不在本小册的主题之内，有兴趣的可以阅读这篇文章：",(0,d.jsx)(n.a,{href:"https://juejin.cn/post/6854573212341108749",target:"_blank",rel:"noopener noreferrer",children:"Electron9.x +Vue +ffi-napi 调用DLL库"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["接下来，我们来实现调用 Windows 系统 ",(0,d.jsx)(n.code,{children:"user32.dll"})," 中的消息对话框 MessageBoxW。那么，我们就可以使用 ",(0,d.jsx)(n.code,{children:"node-ffi-napi"})," 来进行调用："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"import ffi from 'ffi-napi';\n\nfunction showText(text) {\n  return new Buffer(text, 'ucs2').toString('binary');\n};\n\n// 通过ffi加载user32.dll\nconst myUser32 = new ffi.Library('user32', {\n\xa0 // MessageBoxW 是 dll 中定义的函数，两者名称需要一致\n\xa0 // [a, [b，c....]] a是函数出参类型，[b，c]是dll函数的入参类型\n  MessageBoxW:\n    [\n      'int32', ['int32', 'string', 'string', 'int32'],\n    ],\n});\n\n// 调用 user32.dll 中的MessageBoxW()函数, 弹出一个对话框\nmyUser32.MessageBoxW(0, showText('my windows DLL'), showText('DLL dialog'), 0);\n"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["注意，如果你使用的 Electron 版本 > 20.3.8。那么你在使用 ",(0,d.jsx)(n.code,{children:"ffi-napi"})," 或 ",(0,d.jsx)(n.code,{children:"ref-napi"})," 时，可能会遇到报错："]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)("img",{src:i,alt:"image.png"}),"\n这是因为 Electron 21 及更高版本启用了 V8 内存隔离区(也称 V8\xa0",(0,d.jsx)(n.a,{href:"https://so.csdn.net/so/search?q=%E6%B2%99%E7%AE%B1&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer",children:"沙箱"}),")。\n相关的文档和 issue 可以参考这里："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://github.com/electron/electron/issues/35801",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/electron/electron/issues/35801"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.electronjs.org/blog/v8-memory-cage",target:"_blank",rel:"noopener noreferrer",children:"https://www.electronjs.org/blog/v8-memory-cage"})}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["一个解决方案是使用 fork 版本的 ",(0,d.jsx)(n.code,{children:"ffi-napi"})," 和 ",(0,d.jsx)(n.code,{children:"ref-napi"}),"："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.npmjs.com/package/@lwahonen/ffi-napi",target:"_blank",rel:"noopener noreferrer",children:"https://www.npmjs.com/package/@lwahonen/ffi-napi"})}),"\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.a,{href:"https://www.npmjs.com/package/@lwahonen/ref-napi",target:"_blank",rel:"noopener noreferrer",children:"https://www.npmjs.com/package/@lwahonen/ref-napi"})}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.h3,{id:"3-使用-rust-构建-node-原生模块",children:["3. 使用 Rust 构建 Node 原生模块",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-使用-rust-构建-node-原生模块",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["除了使用 C++ 构建 Node 原生模块以及 ",(0,d.jsx)(n.code,{children:"node-ffi-napi"})," 调用动态链接库以外，我们还可以使用 ",(0,d.jsx)(n.code,{children:"Rust"})," 来构建 Node 的原生扩展，关于这部分内容比较体系，因此我单独拎出来一个章节进行介绍：",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7302990019642261567/section/7317079096541282341",target:"_blank",rel:"noopener noreferrer",children:"《通用篇：使用 Rust 开发 Electron 原生扩展》"}),"。"]}),"\n",(0,d.jsxs)(n.h2,{id:"node-调用-os-脚本",children:["Node 调用 OS 脚本",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#node-调用-os-脚本",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"我们也可以使用 Node.js 调用系统集成好的一些能力，接下来我们将分别介绍不同平台的一些 OS 脚本能力。"}),"\n",(0,d.jsxs)(n.h3,{id:"1-winrt",children:["1. WinRT",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-winrt",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"WinRT（Windows Runtime）"})," 是 Microsoft 开发的一种应用程序框架，用于创建 Windows 平台上的通用应用程序。它提供了一系列 API，允许开发者使用多种编程语言（如 C++、C#、JavaScript）编写适用于 Windows 8 及更新版本的应用程序。"]}),"\n",(0,d.jsx)(n.p,{children:"WinRT 提供了许多功能，包括用户界面、文件访问、网络通信、设备访问等。它旨在支持不同类型的 Windows 应用程序开发。"}),"\n",(0,d.jsxs)(n.p,{children:["在 Windows 中，我们可以使用 ",(0,d.jsx)(n.a,{href:"https://github.com/NodeRT/NodeRT",target:"_blank",rel:"noopener noreferrer",children:"NodeRT"})," 来调用 WinRT 的能力，比如使用 ",(0,d.jsx)(n.code,{children:"Windows.Devices.Geolocation"})," 命名空间，在 Node.js 中定位用户的位置："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const { Geolocator } = require('windows.devices.geolocation')\nconst locator = new Geolocator()\n\nlocator.getGeopositionAsync((error, result) => {\n  if (error) {\n    console.error(error)\n    return\n  }\n\n  const { coordinate } = result\n  const { longitude, latitude } = coordinate\n\n  console.info(longitude, latitude)\n})\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"2-applescript",children:["2. AppleScript",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-applescript",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"AppleScript"})," 是 macOS 和 Mac OS Classic 中的脚本语言，用于自动化和控制 Mac 系统上的各种操作和应用程序。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"AppleScript"})," 允许用户编写脚本来执行诸如文件操作、应用程序控制、系统设置更改等操作。它与 macOS 紧密集成，可用于操作系统本身以及许多应用程序。"]}),"\n",(0,d.jsxs)(n.p,{children:["通常，我们可以使用 ",(0,d.jsx)(n.a,{href:"https://github.com/TooTallNate/node-applescript",target:"_blank",rel:"noopener noreferrer",children:"node-applescript"})," 来执行一些 ",(0,d.jsx)(n.code,{children:"AppScript"})," 脚本："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const applescript = require('applescript');\n\n// 非常基本的 AppleScript 命令。以 'Array' 形式返回 iTunes 中当前选定音轨的歌曲名称。\nconst script = 'tell application \"iTunes\" to get name of selection';\n\napplescript.execString(script, (err, rtn) => {\n  if (err) {\n    // Something went wrong!\n  }\n  if (Array.isArray(rtn)) {\n    for (const songName of rtn) {\n      console.log(songName);\n    }\n  }\n});\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"3-shell-脚本",children:["3. Shell 脚本",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-shell-脚本",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["Shell 提供了与操作系统交互的命令行界面，允许用户执行文件操作、进程管理、系统设置等。通常我们可以使用 node 的 ",(0,d.jsx)(n.code,{children:"child_process"})," 模块来调用和执行一些命令行脚本。比如，我们想调用 windows 中的一个 ",(0,d.jsx)(n.code,{children:".exe"})," 可执行文件："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const { execFile } = require('child_process');\n\nconst exeRes = execFile('C:\\\\xxx.exe');\n\nexeRes.on('exit', () => {\n  if (code) {\n    //  todo\n  }\n});\n"})}),"\n",(0,d.jsxs)(n.h2,{id:"总结",children:["总结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["本小节，我们详细介绍了 ",(0,d.jsx)(n.code,{children:"Electron"})," 中调用原生能力的几种方式，除了使用 ",(0,d.jsx)(n.code,{children:"Electron Native APIs"})," 外，依托于 ",(0,d.jsx)(n.code,{children:"Node"})," 的能力，我们还可以使用 ",(0,d.jsx)(n.code,{children:"Node APIs"})," 以及 ",(0,d.jsx)(n.code,{children:"Node addon"})," 和 ",(0,d.jsx)(n.code,{children:"OS"})," 脚本的能力。"]}),"\n",(0,d.jsx)(n.p,{children:"希望通过本小节的介绍，可以让你在遇到需要原生能力才能解决的问题的时候，选择适合自己的工具和方法。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(o,{...e})}):o(e)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC04%E7%AB%A0%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9AElectron%E7%9A%84%E5%8E%9F%E7%94%9F%E8%83%BD%E5%8A%9B.md"]={toc:[{text:"Electron 的原生 GUI 能力",id:"electron-的原生-gui-能力",depth:2},{text:"Electron 操作系统底层能力的 API",id:"electron-操作系统底层能力的-api",depth:2},{text:"Node.js 的 API",id:"nodejs-的-api",depth:2},{text:"Node.js 调用原生能力",id:"nodejs-调用原生能力",depth:2},{text:"1. 使用 C++ 构建 node 原生模块",id:"1-使用-c-构建-node-原生模块",depth:3},{text:"1.1 原生模块的本质",id:"11-原生模块的本质",depth:4},{text:"1.2 node-gyp",id:"12-node-gyp",depth:4},{text:"1.3 编写 C++ 扩展的几种方式",id:"13-编写-c-扩展的几种方式",depth:4},{text:"1.4 binding.gyp",id:"14-bindinggyp",depth:4},{text:"1.5 开发一个 C++ 扩展",id:"15-开发一个-c-扩展",depth:4},{text:"1.6 使用 node-bindings 包",id:"16-使用-node-bindings-包",depth:4},{text:"1.7 使用 node-pre-gyp",id:"17-使用-node-pre-gyp",depth:4},{text:"1.8 Electron 上引入原生模块",id:"18-electron-上引入原生模块",depth:4},{text:"2. 使用 node-ffi-napi 调用动态链接库",id:"2-使用-node-ffi-napi-调用动态链接库",depth:3},{text:"一个简单的示例",id:"一个简单的示例",depth:4},{text:"3. 使用 Rust 构建 Node 原生模块",id:"3-使用-rust-构建-node-原生模块",depth:3},{text:"Node 调用 OS 脚本",id:"node-调用-os-脚本",depth:2},{text:"1. WinRT",id:"1-winrt",depth:3},{text:"2. AppleScript",id:"2-applescript",depth:3},{text:"3. Shell 脚本",id:"3-shell-脚本",depth:3},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);