"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["9491"],{236568:function(n,e,r){r.r(e),r.d(e,{default:()=>x});var s=r(552676),i=r(740453);let c=r.p+"static/image/74202f708b0c7997caeab23a4a1b8e53.24316528.webp",l=r.p+"static/image/2b7f64acf09cb5fb4d9555eb14292d31.428d586b.webp",o=r.p+"static/image/2d8de1955dbb281f83b195a3e5a5536f.f5182704.webp",p=r.p+"static/image/ee0108e5b4247ac139441cf924ef9c6e.fe2ace1a.webp",d=r.p+"static/image/f94e17d719621a93922b8cfbda6e8481.79f92b55.webp",t=r.p+"static/image/20acb872fd57b96b40c3dc2289d7e185.ef8a4ac7.webp",a=r.p+"static/image/cf4056c186fcd9e9e6a086a0ab015f33.5be796cd.webp";function h(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",code:"code",pre:"pre",strong:"strong",ul:"ul",li:"li",img:"img",h4:"h4"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"5基础篇-深入-props",children:["5.基础篇-深入 props",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5基础篇-深入-props",children:"#"})]}),"\n",(0,s.jsxs)(e.h2,{id:"一-前言",children:["一 前言",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"React 中的 props 想必大家并不陌生。如果从 React 的组件设计思想出发，组件的作用是什么呢？"}),"\n",(0,s.jsx)(e.p,{children:"一方面，它可以作为渲染UI视图的容器。"}),"\n",(0,s.jsx)(e.p,{children:"另一方面，组件之间就像发动机的各个零件，想要让 React 这台机器运作起来，就要处理好各个零件，也就是各个组件之间的联系，而props 担任的角色就是将每个组件联系起来。"}),"\n",(0,s.jsx)(e.p,{children:"props 是 React 组件通信最重要的手段，它在 React 的世界中充当的角色是十分重要的。有一点必须明确，就是通过第二章节的学习，弄清楚一次 render 的过程，就是调用 React.createElement 形成新的 element 过程，新的 element 上就会有新的 props 属性，这个新 props 就是重新渲染视图的关键所在。所以学好 props，有助于打通 React 组件脉络。"}),"\n",(0,s.jsx)(e.p,{children:"本章节将介绍 React 中 props，学好 props 可以使组件间通信更加灵活，同时文中会介绍一些 props 的操作技巧，和学会如何编写嵌套组件。"}),"\n",(0,s.jsxs)(e.h2,{id:"二-理解props",children:["二 理解props",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二-理解props",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"1-props是什么",children:["1 props是什么？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-props是什么",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["首先应该明确一下什么是 props ，对于在 React 应用中写的子组件，无论是函数组件 ",(0,s.jsx)(e.code,{children:"FunComponent"})," ，还是类组件 ",(0,s.jsx)(e.code,{children:"ClassComponent"})," ，父组件绑定在它们标签里的属性/方法，最终会变成 props 传递给它们。但是这也不是绝对的，对于一些特殊的属性，比如说 ref 或者 key ，React 会在底层做一些额外的处理。首先来看一下 React 中 props 可以是些什么东西？"]}),"\n",(0,s.jsx)(e.p,{children:"React 中的 props ，还是很灵活的，接下来先来看一个 demo ："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"/* children 组件 */\nfunction ChidrenComponent(){\n    return <div> In this chapter, let's learn about react props ! </div>\n}\n/* props 接受处理 */\nclass PropsComponent extends React.Component{\n    componentDidMount(){\n        console.log(this,'_this')\n    }\n    render(){\n        const {  children , mes , renderName , say ,Component } = this.props\n        const renderFunction = children[0]\n        const renderComponent = children[1]\n        /* 对于子组件，不同的props是怎么被处理 */\n        return <div>\n            { renderFunction() }\n            { mes }\n            { renderName() }\n            { renderComponent }\n            <Component />\n            <button onClick={ () => say() } > change content </button>\n        </div>\n    }\n}\n/* props 定义绑定 */\nclass Index extends React.Component{\n    state={  \n        mes: \"hello,React\"\n    }\n    node = null\n    say= () =>  this.setState({ mes:'let us learn React!' })\n    render(){\n        return <div>\n            <PropsComponent  \n               mes={this.state.mes}  // ① props 作为一个渲染数据源\n               say={ this.say  }     // ② props 作为一个回调函数 callback\n               Component={ ChidrenComponent } // ③ props 作为一个组件\n               renderName={ ()=><div> my name is alien </div> } // ④ props 作为渲染函数\n            >\n                { ()=> <div>hello,world</div>  } { /* ⑤render props */ }\n                <ChidrenComponent />             { /* ⑥render component */ }\n            </PropsComponent>\n        </div>\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果"})}),"\n",(0,s.jsx)(e.p,{children:"如上看一下 props 可以是什么？"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"① props 作为一个子组件渲染数据源。"}),"\n",(0,s.jsx)(e.li,{children:"② props 作为一个通知父组件的回调函数。"}),"\n",(0,s.jsx)(e.li,{children:"③ props 作为一个单纯的组件传递。"}),"\n",(0,s.jsx)(e.li,{children:"④ props 作为渲染函数。"}),"\n",(0,s.jsx)(e.li,{children:"⑤ render props ， 和④的区别是放在了 children 属性上。"}),"\n",(0,s.jsx)(e.li,{children:"⑥ render component 插槽组件。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"那么如上 props 在组件实例上是什么样子："}),"\n",(0,s.jsx)(e.p,{children:"PropsComponent 如果是一个类组件，那么可以直接通过 this.props 访问到它："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:"prop1.jpg"})}),"\n",(0,s.jsx)(e.p,{children:"在标签内部的属性和方法会直接绑定在 props 对象的属性上，对于组件的插槽会被绑定在 props 的 Children 属性中。"}),"\n",(0,s.jsxs)(e.h3,{id:"2-react如何定义的props",children:["2 React如何定义的props？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-react如何定义的props",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"接下来一起总结一下 props 究竟能做些什么？"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"在 React 组件层级 props 充当的角色"})}),"\n",(0,s.jsx)(e.p,{children:"一方面父组件 props 可以把数据层传递给子组件去渲染消费。另一方面子组件可以通过 props 中的 callback ，来向父组件传递信息。还有一种可以将视图容器作为 props 进行渲染。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"从 React 更新机制中 props 充当的角色"})}),"\n",(0,s.jsx)(e.p,{children:"在 React 中，props 在组件更新中充当了重要的角色，在 fiber 调和阶段中，diff 可以说是 React 更新的驱动器，熟悉 vue 的同学都知道 vue 中基于响应式，数据的变化，就会颗粒化到组件层级，通知其更新，但是在 React 中，无法直接检测出数据更新波及到的范围，props 可以作为组件是否更新的重要准则，变化即更新，于是有了 PureComponent ，memo 等性能优化方案。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"从React插槽层面props充当的角色"}),"\nReact 可以把组件的闭合标签里的插槽，转化成 Children 属性，一会将详细介绍这个模式。"]}),"\n",(0,s.jsxs)(e.h3,{id:"3-监听props改变",children:["3 监听props改变",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-监听props改变",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"类组件中"})}),"\n",(0,s.jsx)(e.p,{children:"① componentWillReceiveProps 可以作为监听props的生命周期，但是 React 已经不推荐使用 componentWillReceiveProps ，未来版本可能会被废弃，因为这个生命周期超越了 React 的可控制的范围内，可能引起多次执行等情况发生。于是出现了这个生命周期的替代方案 getDerivedStateFromProps ，在下一章节，会详细介绍 React 生命周期。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"函数组件中"})}),"\n",(0,s.jsx)(e.p,{children:"② 函数组件中同理可以用 useEffect 来作为 props 改变后的监听函数。(不过有一点值得注意, useEffect 初始化会默认执行一次)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"React.useEffect(()=>{\n    // props 中number 改变，执行这个副作用。\n    console.log('props改变：' ，props.number  )\n},[ props.number ])\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"4-props-children模式",children:["4 props children模式",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-props-children模式",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"props + children 模式 在 React 中非常常用，尤其对一些优秀开源组件库。比如 react-router 中的 Switch 和  Route ，  antd  中的 Form  和  FormItem。"}),"\n",(0,s.jsx)(e.p,{children:"首先来看看 prop + children 的几个基本情况。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"① props 插槽组件"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"<Container>\n    <Children>\n</Container>\n"})}),"\n",(0,s.jsx)(e.p,{children:"上述可以在 Container 组件中，通过 props.children 属性访问到 Children 组件，为 React element 对象。"}),"\n",(0,s.jsx)(e.p,{children:"作用："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"1 可以根据需要控制 Children 是否渲染。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"2 像上一节所说的， Container 可以用 React.cloneElement 强化 props (混入新的 props )，或者修改 Children 的子元素。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"② render props模式"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"<Container>\n   { (ContainerProps)=> <Children {...ContainerProps}  /> }\n</Container>\n"})}),"\n",(0,s.jsx)(e.p,{children:"这种情况，在 Container 中， props.children 属性访问到是函数，并不是 React element 对象，针对这种情况，像下面这种情况下 children 是不能直接渲染的，直接渲染会报错。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function  Container(props) {\n     return  props.children\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"如果上述直接这么写，会报如下的错误："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:"comp3.jpg"})}),"\n",(0,s.jsx)(e.p,{children:"改成如下方式，就可以了。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function  Container(props) {\n    const  ContainerProps = {\n        name: 'alien',\n        mes:'let us learn react'\n    }\n     return  props.children(ContainerProps)\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这种方式作用是："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"1 根据需要控制 Children 渲染与否。"}),"\n",(0,s.jsx)(e.li,{children:"2 可以将需要传给 Children 的 props 直接通过函数参数的方式传递给执行函数 children 。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"混合模式"})}),"\n",(0,s.jsx)(e.p,{children:"如果 Container 的 Children  既有函数也有组件，这种情况应该怎么处理呢？"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"<Container>\n    <Children />\n    { (ContainerProps)=> <Children {...ContainerProps} name={'haha'}  />  }\n</Container>\n"})}),"\n",(0,s.jsx)(e.p,{children:"首先在 Container 里打印 Children 看看是什么？"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:"comp2.jpg"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"const Children = (props)=> (<div>\n    <div>hello, my name is {  props.name } </div>\n    <div> { props.mes } </div>\n</div>)\n\nfunction  Container(props) {\n    const ContainerProps = {\n        name: 'alien',\n        mes:'let us learn react'\n    }\n     return props.children.map(item=>{\n        if(React.isValidElement(item)){ // 判断是 react elment  混入 props\n            return React.cloneElement(item,{ ...ContainerProps },item.props.children)\n        }else if(typeof item === 'function'){\n            return item(ContainerProps)\n        }else return null\n     })\n}\n\nconst Index = ()=>{\n    return <Container>\n        <Children />\n        { (ContainerProps)=> <Children {...ContainerProps} name={'haha'}  />  }\n    </Container>\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:"comp4.jpg"})}),"\n",(0,s.jsx)(e.p,{children:"这种情况需要先遍历 children ，判断 children 元素类型："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"针对 element 节点，通过 cloneElement 混入 props ；"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"针对函数，直接传递参数，执行函数。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"5-操作-props-小技巧",children:["5 操作 props 小技巧",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5-操作-props-小技巧",children:"#"})]}),"\n",(0,s.jsxs)(e.h4,{id:"抽象-props",children:["抽象 props",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#抽象-props",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"抽象 props 一般用于跨层级传递 props ，一般不需要具体指出 props 中某个属性，而是将 props 直接传入或者是抽离到子组件中。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"混入 props"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function Son(props){\n    console.log(props)\n    return <div> hello,world </div>\n}\nfunction Father(props){\n    const fatherProps={\n        mes:'let us learn React !'\n    }\n    return <Son {...props} { ...fatherProps }  />\n}\nfunction Index(){\n    const indexProps = {\n        name:'alien',\n        age:'28',\n    }\n    return <Father { ...indexProps }  />\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"打印"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:"prop3.jpg"})}),"\n",(0,s.jsx)(e.p,{children:"Father 组件一方面直接将 Index 组件 indexProps 抽象传递给 Son，一方面混入 fatherProps 。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"抽离props"})}),"\n",(0,s.jsx)(e.p,{children:"有的时候想要做的恰恰和上面相反，比如想要从父组件 props 中抽离某个属性，再传递给子组件，那么应该怎么做呢？"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function Son(props){\n    console.log(props)\n    return <div> hello,world </div>\n}\n\nfunction Father(props){\n    const { age,...fatherProps  } = props\n    return <Son  { ...fatherProps }  />\n}\nfunction Index(){\n    const indexProps = {\n        name:'alien',\n        age:'28',\n        mes:'let us learn React !'\n    }\n    return <Father { ...indexProps }  />\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"打印"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:"prop4.jpg"})}),"\n",(0,s.jsx)(e.p,{children:"成功的将 indexProps 中的 age 属性抽离出来。"}),"\n",(0,s.jsxs)(e.h4,{id:"注入props",children:["注入props",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#注入props",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"显式注入props"})}),"\n",(0,s.jsx)(e.p,{children:"显式注入 props ，就是能够直观看见标签中绑定的 props 。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'function Son(props){\n     console.log(props) // {name: "alien", age: "28"}\n     return <div> hello,world </div>\n}\nfunction Father(prop){\n    return prop.children\n}\nfunction Index(){\n    return <Father>\n        <Son  name="alien"  age="28"  />\n    </Father>\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"如上向 Son 组件绑定的 name 和 age 是能直观被看见的。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"隐式注入 props"})}),"\n",(0,s.jsxs)(e.p,{children:["这种方式，一般通过 ",(0,s.jsx)(e.code,{children:"React.cloneElement"})," 对 props.chidren 克隆再混入新的 props 。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'function Son(props){\n     console.log(props) // {name: "alien", age: "28", mes: "let us learn React !"}\n     return <div> hello,world </div>\n}\nfunction Father(prop){\n    return React.cloneElement(prop.children,{  mes:\'let us learn React !\' })\n}\nfunction Index(){\n    return <Father>\n        <Son  name="alien"  age="28"  />\n    </Father>\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"如上所示，将 mes 属性，隐式混入到了 Son 的 props 中。"}),"\n",(0,s.jsxs)(e.h2,{id:"三-进阶实践-实现一个简单的-form-formitem嵌套组件",children:["三 进阶实践-实现一个简单的 ",(0,s.jsx)(e.code,{children:"<Form> <FormItem>"}),"嵌套组件",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#三-进阶实践-实现一个简单的-form-formitem嵌套组件",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["接下来到实践环节了。需要编写一个实践 demo ，",(0,s.jsxs)(e.strong,{children:["用于表单状态管理的",(0,s.jsx)(e.code,{children:"<Form>"})," 和 ",(0,s.jsx)(e.code,{children:"<FormItem>"})," 组件"]})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<Form>"}),"用于管理表单状态；"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"<FormItem>"}),"用于管理",(0,s.jsx)(e.code,{children:"<Input>"}),"输入框组件。,"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"编写的组件能够实现的功能是："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["①",(0,s.jsx)(e.code,{children:"Form"})," 组件可以被 ref 获取实例。然后可以调用实例方法 ",(0,s.jsx)(e.code,{children:"submitForm"})," 获取表单内容，用于提交表单，",(0,s.jsx)(e.code,{children:"resetForm"})," 方法用于重置表单。"]}),"\n",(0,s.jsxs)(e.li,{children:["②",(0,s.jsx)(e.code,{children:"Form"}),"组件自动过滤掉除了",(0,s.jsx)(e.code,{children:"FormItem"}),"之外的其他React元素"]}),"\n",(0,s.jsxs)(e.li,{children:["③",(0,s.jsx)(e.code,{children:"FormItem"})," 中 name 属性作为表单提交时候的 key ，还有展示的 label 。"]}),"\n",(0,s.jsxs)(e.li,{children:["④ ",(0,s.jsx)(e.code,{children:"FormItem"})," 可以自动收集 ",(0,s.jsx)(e.code,{children:"<Input/>"})," 表单的值。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"目的："}),"\n",(0,s.jsx)(e.p,{children:"希望通过这实践 demo 让大家学习到："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"① props 基本使用"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"② 学会操作 props.children ，隐式注入 props"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.strong,{children:"③ 掌握表单嵌套原理(现实情况要比这个复杂)"})}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"组件使用"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:'export default  () => {\n    const form =  React.useRef(null)\n    const submit =()=>{\n        /* 表单提交 */\n        form.current.submitForm((formValue)=>{\n            console.log(formValue)\n        })\n    }\n    const reset = ()=>{\n        /* 表单重置 */\n        form.current.resetForm()\n    }\n    return <div className=\'box\' >\n        <Form ref={ form } >\n            <FormItem name="name" label="我是"  >\n                <Input   />\n            </FormItem>\n            <FormItem name="mes" label="我想对大家说"  >\n                <Input   />\n            </FormItem>\n            <input  placeholder="不需要的input" />\n            <Input/>\n        </Form>\n        <div className="btns" >\n            <button className="searchbtn"  onClick={ submit } >提交</button>\n            <button className="concellbtn" onClick={ reset } >重置</button>\n        </div>\n    </div>\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"效果"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:"comp5.gif"})}),"\n",(0,s.jsxs)(e.h3,{id:"1-编写-form",children:["1 编写 ",(0,s.jsx)(e.code,{children:"<Form>"}),(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-编写-form",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"class Form extends React.Component{\n    state={\n        formData:{}\n    }\n    /* 用于提交表单数据 */\n    submitForm=(cb)=>{\n        cb({ ...this.state.formData })\n    } \n    /* 获取重置表单数据 */\n    resetForm=()=>{\n       const { formData } = this.state\n       Object.keys(formData).forEach(item=>{\n           formData[item] = ''\n       })\n       this.setState({\n           formData\n       })\n    }\n    /* 设置表单数据层 */\n    setValue=(name,value)=>{\n        this.setState({\n            formData:{\n                ...this.state.formData,\n                [name]:value\n            }\n        })\n    }\n    render(){\n        const { children } = this.props\n        const renderChildren = []\n        React.Children.forEach(children,(child)=>{\n            if(child.type.displayName === 'formItem'){\n                const { name } = child.props\n                /* 克隆`FormItem`节点，混入改变表单单元项的方法 */\n                const Children = React.cloneElement(child,{ \n                    key:name ,                             /* 加入key 提升渲染效果 */\n                    handleChange:this.setValue ,           /* 用于改变 value */\n                    value:this.state.formData[name] ||  '' /* value 值 */\n                },child.props.children)\n                renderChildren.push(Children)\n            }\n        })\n        return renderChildren\n    }\n}\n/* 增加组件类型type  */\nForm.displayName = 'form'\n"})}),"\n",(0,s.jsx)(e.p,{children:"设计思想："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["首先考虑到 ",(0,s.jsx)(e.code,{children:"<Form>"})," 在不使用 ",(0,s.jsx)(e.code,{children:"forwardRef"})," 前提下，最好是类组件，因为只有类组件才能获取实例。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"创建一个 state 下的 formData属性，用于收集表单状态。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["要封装 ",(0,s.jsx)(e.strong,{children:"重置表单"}),"，",(0,s.jsx)(e.strong,{children:"提交表单"}),"，",(0,s.jsx)(e.strong,{children:"改变表单单元项"}),"的方法。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["要过滤掉除了 ",(0,s.jsx)(e.code,{children:"FormItem"})," 元素之外的其他元素，那么怎么样知道它是不是",(0,s.jsx)(e.code,{children:"FormItem"}),"，这里教大家一种方法，可以给函数组件或者类组件绑定静态属性来证明它的身份，然后在遍历 props.children 的时候就可以在 React element 的 type 属性(类或函数组件本身)上，验证这个身份，在这个 demo 项目，给函数绑定的 displayName 属性，证明组件身份。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["要克隆 ",(0,s.jsx)(e.code,{children:"FormItem"})," 节点，将改变表单单元项的方法 handleChange 和表单的值 value 混入 props 中。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"2-编写-formitem",children:["2 编写 ",(0,s.jsx)(e.code,{children:"<FormItem>"}),(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-编写-formitem",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function FormItem(props){\n    const { children , name  , handleChange , value , label  } = props\n    const onChange = (value) => {\n        /* 通知上一次value 已经改变 */\n        handleChange(name,value)\n    }\n   return <div className='form' >\n       <span className=\"label\" >{ label }:</span>\n       {\n            React.isValidElement(children) && children.type.displayName === 'input' \n            ? React.cloneElement(children,{ onChange , value })\n            : null\n       }\n   </div>    \n}\nFormItem.displayName = 'formItem'\n"})}),"\n",(0,s.jsx)(e.p,{children:"设计思想："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"FormItem"}),"一定要绑定 displayName 属性，用于让 ",(0,s.jsx)(e.code,{children:"<Form>"})," 识别",(0,s.jsx)(e.code,{children:"<FormItem />"})]}),"\n",(0,s.jsxs)(e.li,{children:["声明 ",(0,s.jsx)(e.code,{children:"onChange"})," 方法，通过 props 提供给",(0,s.jsx)(e.code,{children:"<Input>"}),"，作为改变 value 的回调函数。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"FormItem"}),"过滤掉除了 ",(0,s.jsx)(e.code,{children:"input"})," 以外的其他元素。"]}),"\n"]}),"\n",(0,s.jsxs)(e.h3,{id:"3-编写-input-",children:["3 编写 ",(0,s.jsx)(e.code,{children:"<Input />"}),(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-编写-input-",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"/* Input 组件, 负责回传value值 */\nfunction Input({ onChange , value }){\n    return  <input className=\"input\"  onChange={ (e)=>( onChange && onChange(e.target.value) ) } value={value}  />\n}\n/* 给Component 增加标签 */\nInput.displayName = 'input'\n"})}),"\n",(0,s.jsx)(e.p,{children:"设计思想："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["绑定 displayName 标识",(0,s.jsx)(e.code,{children:"input"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"input"})," DOM 元素，绑定 onChange 方法，用于传递 value 。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"四-总结",children:["四 总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#四-总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"通过本章节，系统学习了 props ，总结一下这节课的内容："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"系统学习 props ，props是什么，props的作用。"}),"\n",(0,s.jsx)(e.li,{children:"操作 props 小技巧。"}),"\n",(0,s.jsx)(e.li,{children:"掌握了插槽组件的使用与编写。"}),"\n",(0,s.jsxs)(e.li,{children:["实践一个 demo ，",(0,s.jsx)(e.code,{children:"<Form> <FormItem>"})," 嵌套插槽组件协调管理表单状态。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"下一节，将走进 React 的生命周期，去探索生命周期的奥秘。"})]})}function m(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}let x=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F5.%E5%9F%BA%E7%A1%80%E7%AF%87-%E6%B7%B1%E5%85%A5%20props.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 理解props",id:"二-理解props",depth:2},{text:"1 props是什么？",id:"1-props是什么",depth:3},{text:"2 React如何定义的props？",id:"2-react如何定义的props",depth:3},{text:"3 监听props改变",id:"3-监听props改变",depth:3},{text:"4 props children模式",id:"4-props-children模式",depth:3},{text:"5 操作 props 小技巧",id:"5-操作-props-小技巧",depth:3},{text:"抽象 props",id:"抽象-props",depth:4},{text:"注入props",id:"注入props",depth:4},{text:"三 进阶实践-实现一个简单的 `<Form> <FormItem>`嵌套组件",id:"三-进阶实践-实现一个简单的-form-formitem嵌套组件",depth:2},{text:"1 编写 `<Form>`",id:"1-编写-form",depth:3},{text:"2 编写 `<FormItem>`",id:"2-编写-formitem",depth:3},{text:"3 编写 `<Input />`",id:"3-编写-input-",depth:3},{text:"四 总结",id:"四-总结",depth:2}],title:"5.基础篇-深入 props",headingTitle:"5.基础篇-深入 props",frontmatter:{}}}}]);