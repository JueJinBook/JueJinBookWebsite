"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["9645"],{315858:function(e,n,t){t.r(n),t.d(n,{default:()=>c});var r=t(552676),a=t(740453);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"27-加餐利用-babel-插件来化简向量运算下",children:["27 加餐：利用 Babel 插件来化简向量运算（下）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#27-加餐利用-babel-插件来化简向量运算下",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这一节，我们继续讨论 Babel 插件机制，完善我们的向量运算插件。"}),"\n",(0,r.jsxs)(n.h2,{id:"测试先行",children:["测试先行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试先行",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"类似于 Babel 插件这类应用，有明确的输入和期望输出，我们可以以测试先行的方式来实现代码。也就是说，我们先写好测试用例，然后再实现代码。根据测试用例，可以知道代码应该怎么写，还能反过来通过测试用例来验证我们的代码是否正确。"}),"\n",(0,r.jsx)(n.p,{children:"我们的测试用例如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"const { vec2 } = require('gl-matrix');\n​\nconst a = vec2(1, 2);\nconst b = vec2(3, 4);\nconst c = vec2(a) + vec2(b);\n​\nconst d = vec2(a) + 1.0;\nconst e = vec2(a) + vec2(b) + vec2(c);\nconst f = 2.0 + vec2(a);\nconst g = -vec2(a);\n"})}),"\n",(0,r.jsx)(n.p,{children:"在上一节，我们已经实现了测试用例中 a、b、c 的转换，现在我们需要实现 d、e、f、g 的转换。"}),"\n",(0,r.jsxs)(n.h2,{id:"实现",children:["实现",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["首先是 d，我们要将",(0,r.jsx)(n.code,{children:"vec2(a) + 1.0"}),"转换为",(0,r.jsx)(n.code,{children:"vec2.add(vec2.create(), a, vec2.fromValues(1.0, 0))"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["这个实现相对简单一些，我们只需要在",(0,r.jsx)(n.code,{children:"BinaryExpression"}),"节点中，判断左右两边的节点类型，如果左边是",(0,r.jsx)(n.code,{children:"vec2"}),"，右边是",(0,r.jsx)(n.code,{children:"NumberLiteral"}),"，就进行转换。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" \xa0...\n \xa0 \xa0 \xa0BinaryExpression: {\n \xa0 \xa0 \xa0 \xa0exit(path) {\n \xa0 \xa0 \xa0 \xa0 \xa0const { left, right } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(left) && left.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(right) && right.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.add`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0left.arguments[0],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0right.arguments[0]],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0  } else if (t.isNumericLiteral(right)) {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.add`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0left.arguments[0],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.fromValues`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [right, t.numericLiteral(0)],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  )],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0  },\n \xa0 \xa0  },\n \xa0...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["如上面代码所示，在",(0,r.jsx)(n.code,{children:"BinaryExpression"}),"节点中，我们判断左边是",(0,r.jsx)(n.code,{children:"vec2"}),"，右边是",(0,r.jsx)(n.code,{children:"NumberLiteral"}),"，然后进行转换。"]}),"\n",(0,r.jsxs)(n.p,{children:["接着是 e，我们要将",(0,r.jsx)(n.code,{children:"vec2(a) + vec2(b) + vec2(c)"}),"转换为",(0,r.jsx)(n.code,{children:"vec2.add(vec2.create(), vec2.add(vec2.create(), a, b), c)"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["这个实现相对复杂一些，我们需要在",(0,r.jsx)(n.code,{children:"BinaryExpression"}),"节点中，判断左右两边的节点类型，如果左边是",(0,r.jsx)(n.code,{children:"vec2.add"}),"，右边是",(0,r.jsx)(n.code,{children:"vec2"}),"，就进行转换。"]}),"\n",(0,r.jsx)(n.p,{children:"代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:" \xa0...\n \xa0 \xa0 \xa0BinaryExpression: {\n \xa0 \xa0 \xa0 \xa0exit(path) {\n \xa0 \xa0 \xa0 \xa0 \xa0const { left, right } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(left) && left.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(right) && right.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.add`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0left.arguments[0],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0right.arguments[0]],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0  } else if (t.isNumericLiteral(right)) {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.add`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0left.arguments[0],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.fromValues`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [right, t.numericLiteral(0)],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  )],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0  } else if (t.isCallExpression(left) && left.callee.name === 'vec2.add') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(right) && right.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(left.callee.name),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${right.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0left,\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0right.arguments[0]],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0  },\n \xa0 \xa0  },\n \xa0  },\n \xa0...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这样我们就实现了 e 的转换，那么同样的道理，f 的转换是判断 left 为",(0,r.jsx)(n.code,{children:"NumericLiteral"}),"，right 为",(0,r.jsx)(n.code,{children:"vec2"}),"，然后进行转换。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"...\nelse if (t.isNumericLiteral(left) && t.isCallExpression(right) && right.callee.name === 'vec2') {\n \xa0const { operator } = path.node;\n \xa0if (operator === '+') {\n \xa0 \xa0// https://babeljs.io/docs/en/babel-types\n \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0t.identifier(`${right.callee.name}.add`),\n \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${right.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${right.callee.name}.fromValues`),\n \xa0 \xa0 \xa0 \xa0  [left, t.numericLiteral(0)],\n \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0right.arguments[0],\n \xa0 \xa0  ],\n \xa0  );\n \xa0 \xa0path.replaceWith(node);\n  }\n}\n...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这样就实现了 f 的转换。最后一个规则是 g，g 是一个一元表达式，我们只需要判断节点类型为",(0,r.jsx)(n.code,{children:"UnaryExpression"}),"，然后进行转换即可。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们需要将 g 的转换为",(0,r.jsx)(n.code,{children:"vec2.negate(vec2.create(), a)"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"...\nUnaryExpression: {\n \xa0exit(path) {\n \xa0 \xa0const { operator, argument } = path.node;\n \xa0 \xa0if (operator === '-') {\n \xa0 \xa0 \xa0if (t.isCallExpression(argument) && argument.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${argument.callee.name}.negate`),\n \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${argument.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0argument.arguments[0]],\n \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0  }\n \xa0  }\n  },\n},\n...\n"})}),"\n",(0,r.jsx)(n.p,{children:"最终，我们完整的插件代码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"module.exports = function ({ types: t }) {\n \xa0// plugin contents\n​\n \xa0return {\n \xa0 \xa0visitor: {\n \xa0 \xa0 \xa0CallExpression: {\n \xa0 \xa0 \xa0 \xa0exit(path) {\n \xa0 \xa0 \xa0 \xa0 \xa0const funcName = path.node.callee.name;\n \xa0 \xa0 \xa0 \xa0 \xa0if (funcName === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const args = path.node.arguments;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (args.length === 2) {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.node.callee.name = 'vec2.fromValues';\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0  },\n \xa0 \xa0  },\n \xa0 \xa0 \xa0UnaryExpression: {\n \xa0 \xa0 \xa0 \xa0exit(path) {\n \xa0 \xa0 \xa0 \xa0 \xa0const { operator, argument } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '-') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(argument) && argument.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${argument.callee.name}.negate`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${argument.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0argument.arguments[0]],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0  },\n \xa0 \xa0  },\n \xa0 \xa0 \xa0BinaryExpression: {\n \xa0 \xa0 \xa0 \xa0exit(path) {\n \xa0 \xa0 \xa0 \xa0 \xa0const { left, right } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(left) && left.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(right) && right.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0// https://babeljs.io/docs/en/babel-types\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.add`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0left.arguments[0],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0right.arguments[0]],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0  } else if (t.isNumericLiteral(right)) {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0// https://babeljs.io/docs/en/babel-types\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.add`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0left.arguments[0],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${left.callee.name}.fromValues`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [right, t.numericLiteral(0)],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  )],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0  } else {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0// console.log(right);\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0  } else if (t.isCallExpression(left) && left.callee.name === 'vec2.add') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (t.isCallExpression(right) && right.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0// https://babeljs.io/docs/en/babel-types\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(left.callee.name),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${right.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0left,\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0right.arguments[0]],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0  } else if (t.isNumericLiteral(left) && t.isCallExpression(right) && right.callee.name === 'vec2') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const { operator } = path.node;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0if (operator === '+') {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0// https://babeljs.io/docs/en/babel-types\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0const node = t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${right.callee.name}.add`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${right.callee.name}.create`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.callExpression(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0t.identifier(`${right.callee.name}.fromValues`),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  [left, t.numericLiteral(0)],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0right.arguments[0],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  ],\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0  );\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0path.replaceWith(node);\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0  },\n \xa0 \xa0  },\n \xa0  },\n  };\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"测试代码运行出来的转换结果如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\"use strict\";\n​\nvar _require = require('gl-matrix'),\n \xa0vec2 = _require.vec2;\nvar a = vec2.fromValues(1, 2);\nvar b = vec2.fromValues(3, 4);\nvar c = vec2.add(vec2.create(), a, b);\nvar d = vec2.add(vec2.create(), a, vec2.fromValues(1.0, 0));\nvar e = vec2.add(vec2.create(), vec2.add(vec2.create(), a, b), c);\nvar e2 = vec2.add(vec2.create(), vec2.add(vec2.create(), vec2.add(vec2.create(), a, b), c), d);\nvar f = vec2.add(vec2.create(), vec2.fromValues(2.0, 0), a);\nvar g = vec2.negate(vec2.create(), a);\n"})}),"\n",(0,r.jsx)(n.p,{children:"以上代码能符合我们的转换需求。不过，如果我们都是一条一条规则去写，就要实现 gl-matrix 库的所有规则，工作量会非常庞大，这肯定也不是最佳的办法，因为我们几乎未考虑代码复用。如果要考虑复用，我们应该整体考虑 gl-matrix 的数据类型，把 vec2、vec3、vec4、mat2、mat3、mat4、quat 等数据类型抽象出来，再去写规则，而不是像现在这样一条一条去写。"}),"\n",(0,r.jsxs)(n.p,{children:["再则，可以考虑一下，我们确实需要",(0,r.jsx)(n.code,{children:"vec2(a) + vec2(b)"}),"来指定标识符 a 和标识符 b 的变量类型吗？实际上并非如此，如果我们做的更加复杂一些，我们可以通过 path.scope 来跟踪变量，通过赋值表达式（",(0,r.jsx)(n.code,{children:"AssignmentExpress"}),"）来推断变量的类型，这样就可以不用在代码中强制指定变量的类型了。"]}),"\n",(0,r.jsx)(n.p,{children:"如此我们就可以实现类似下面的版本："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"const a = vec2(1, 2);\nconst b = vec2(3, 4);\nconst c = a + b;\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样的超级简化版本，可以真正让我们的插件在几何计算的时候发挥更大的价值！"}),"\n",(0,r.jsx)(n.p,{children:"如果要把这个插件的实现原理展开来讲，可以作为单独一门课来学了，所以这里就不再继续展开了，我的目的只是通过简单的例子让大家直观了解基本的 Babel 插件开发原理和部分 API，如果想要深入了解，可以参考 Babel 官方文档。"}),"\n",(0,r.jsxs)(n.p,{children:["这是我之前实现的 ",(0,r.jsx)(n.a,{href:"https://github.com/akira-cn/babel-plugin-transform-gl-matrix",target:"_blank",rel:"noopener noreferrer",children:"babel-plugin-transform-gl-matrix"}),"，代码在 GitHub 仓库里，有兴趣的同学可以下载下来自行研究。我的图形库 ",(0,r.jsx)(n.a,{href:"https://spritejs.com/#/",target:"_blank",rel:"noopener noreferrer",children:"SpriteJS"}),"依赖了这个插件，它在几何运算的时候表现良好。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上一章节和这一章节，我们主要介绍了 Babel 插件的基本原理，以及如何通过 Babel 插件来实现一些代码转换的功能。Babel 插件的开发并不复杂，只要理解了 Babel 插件的基本原理，熟悉一下基础的 API，就可以很容易的开发出自己想要的插件了。"}),"\n",(0,r.jsx)(n.p,{children:"期待大家在实际项目中使用 Babel 插件，让我们的代码更加简洁、高效、易读。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F27%20%E5%8A%A0%E9%A4%90%EF%BC%9A%E5%88%A9%E7%94%A8%20Babel%20%E6%8F%92%E4%BB%B6%E6%9D%A5%E5%8C%96%E7%AE%80%E5%90%91%E9%87%8F%E8%BF%90%E7%AE%97%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"测试先行",id:"测试先行",depth:2},{text:"实现",id:"实现",depth:2},{text:"总结",id:"总结",depth:2}],title:"27 加餐：利用 Babel 插件来化简向量运算（下）",headingTitle:"27 加餐：利用 Babel 插件来化简向量运算（下）",frontmatter:{}}}}]);