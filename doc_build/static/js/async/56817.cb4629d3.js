"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56817"],{164404:function(e,n,c){c.r(n),c.d(n,{default:()=>A});var s=c(552676),d=c(740453);let r=c.p+"static/image/763e6669298b0da4aadfe86654b0cf73.d940d338.webp",l=c.p+"static/image/872deedb49c13b874a1f07466abcd0c4.96df1ed0.webp",i=c.p+"static/image/fc08633343b35965de4ced597cae011d.3cb4336e.webp",o=c.p+"static/image/968d8e57c8bae9df1f9cb719fb6ddc97.7745040d.webp",h=c.p+"static/image/bb4057895e79807fa3c698b50b1343cb.c1477356.webp",j=c.p+"static/image/67c1bd908682e7f2557d9c9bf4dfacb7.9bafd535.webp",x=c.p+"static/image/950fa187d35f932f4a95c574e0d11a3a.3b7bc924.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",code:"code",h2:"h2",ul:"ul",li:"li",pre:"pre",strong:"strong",blockquote:"blockquote",ol:"ol"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"29sourcemap源码映射原理与应用技巧",children:["29.Sourcemap：源码映射原理与应用技巧",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#29sourcemap源码映射原理与应用技巧",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.qz3o9nc69um5",target:"_blank",rel:"noopener noreferrer",children:"Sourcemap 协议"})," 最初由 Google 设计并率先在 Closure Inspector 实现，它的主要作用就是将经过压缩、混淆、合并的产物代码还原回未打包的原始形态，帮助开发者在生产环境中精确定位问题发生的行列位置，例如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["在 Webpack 内部，这段生成 Sourcemap 映射数据的逻辑并不复杂，一句话总结：在 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/compilation-hooks/#processassets",target:"_blank",rel:"noopener noreferrer",children:"processAssets"})," 钩子遍历产物文件 ",(0,s.jsx)(n.code,{children:"assets"})," 数组，调用 ",(0,s.jsx)(n.code,{children:"webpack-sources"})," 提供的 ",(0,s.jsx)(n.code,{children:"map"})," 方法，最终计算出 ",(0,s.jsx)(n.code,{children:"asset"})," 与源码 ",(0,s.jsx)(n.code,{children:"originSource"})," 之间的映射关系。"]}),"\n",(0,s.jsxs)(n.p,{children:["这个过程真正的难点在于 「如何计算映射关系」，因此本文会展开详细讲解 Sourcemap 映射结构与 VLQ 编码规则，以及 Webpack 提供的 ",(0,s.jsx)(n.code,{children:"devtool"})," 配置项的详细用法。"]}),"\n",(0,s.jsxs)(n.h2,{id:"sourcemap-映射结构",children:["Sourcemap 映射结构",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#sourcemap-映射结构",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Sourcemap 最初版本生成的 ",(0,s.jsx)(n.code,{children:".map"})," 文件非常大，体积大概为编译产物的 10 倍；V2 之后引入 Base64 编码等算法，将之减少 20% ~ 30%；而最新版本 V3 又在 V2 基础上引入 VLQ 算法，体积进一步压缩了 50%。"]}),"\n",(0,s.jsxs)(n.p,{children:["这一系列进化造就了一个效率极高的 Sourcemap 体系，但伴随而来的则是较为复杂的 ",(0,s.jsx)(n.code,{children:"mappings"})," 编码规则。V3 版本 Sourcemap 文件由三部分组成:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"开发者编写的原始代码；"}),"\n",(0,s.jsxs)(n.li,{children:["经过 Webpack 压缩、转化、合并后的产物，且产物中必须包含指向 Sourcemap 文件地址的 ",(0,s.jsx)(n.code,{children:"//# sourceMappingURL=https://xxxx/bundle.js.map"})," 指令；"]}),"\n",(0,s.jsx)(n.li,{children:"记录原始代码与经过工程化处理代码之间位置映射关系 Map 文件。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["页面初始运行时只会加载编译构建产物，直到特定事件发生 —— 例如在 Chrome 打开 Devtool 面板时，才会根据 ",(0,s.jsx)(n.code,{children:"//# sourceMappingURL"})," 内容自动加载 Map 文件，并按 Sourcemap 协议约定的映射规则将代码重构还原回原始形态，这既能保证终端用户的性能体验，又能帮助开发者快速还原现场，提升线上问题的定位与调试效率。"]}),"\n",(0,s.jsxs)(n.p,{children:["例如，在 Webpack 中设置 ",(0,s.jsx)(n.code,{children:"devtool = 'source-map'"})," 即可同时打包出代码产物 ",(0,s.jsx)(n.code,{children:"xxx.js"})," 文件与同名 ",(0,s.jsx)(n.code,{children:"xxx.js.map"})," 文件，Map 文件通常为 JSON 格式，内容如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "version": 3,\n    "sources": [\n        "webpack:///./src/index.js"\n    ],\n    "names": ["name", "console", "log"],\n    "mappings": ";;;;;AAAA,IAAMA,IAAI,GAAG,QAAb;AAEAC,OAAO,CAACC,GAAR,CAAYF,IAAZ,E",\n    "file": "main.js",\n    "sourcesContent": [\n        "const name = \'tecvan\';\\n\\nconsole.log(name)"\n    ],\n    "sourceRoot": ""\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"各字段含义分别为："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"version"}),"： 指代 Sourcemap 版本，目前最新版本为 ",(0,s.jsx)(n.code,{children:"3"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"names"}),"：字符串数组，记录原始代码中出现的变量名；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"file"}),"：字符串，该 Sourcemap 文件对应的编译产物文件名；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sourcesContent"}),"：字符串数组，原始代码的内容；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sourceRoot"}),"：字符串，源文件根目录；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"sources"}),"：字符串数组，原始文件路径名，与 ",(0,s.jsx)(n.code,{children:"sourcesContent"})," 内容一一对应；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mappings"}),"：字符串数组，记录打包产物与原始代码的位置映射关系。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["使用时，浏览器会按照 ",(0,s.jsx)(n.code,{children:"mappings"})," 记录的数值关系，将产物代码映射回 ",(0,s.jsx)(n.code,{children:"sourcesContent"})," 数组所记录的原始代码文件、行、列位置，这里面最复杂难懂的点就在于 ",(0,s.jsx)(n.code,{children:"mappings"})," 字段的规则。"]}),"\n",(0,s.jsx)(n.p,{children:"举个例子，对于下面的代码："}),"\n",(0,s.jsxs)(n.p,{children:["当 ",(0,s.jsx)(n.code,{children:"devtool = 'source-map'"})," 时，Webpack 生成的 ",(0,s.jsx)(n.code,{children:"mappings"})," 字段为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:";;;;;AAAA,IAAMA,IAAI,GAAG,QAAb;AAEAC,OAAO,CAACC,GAAR,CAAYF,IAAZ,E\n"})}),"\n",(0,s.jsx)(n.p,{children:"字段内容包含三层结构："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["以 ",(0,s.jsx)(n.code,{children:";"})," 分割的",(0,s.jsx)(n.strong,{children:"行映射"}),"，每一个 ",(0,s.jsx)(n.code,{children:";"})," 对应编译产物每一行到源码的映射，上例经过分割后："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"[\n  // 产物第 1-5 行内容为 Webpack 生成的 runtime，不需要记录映射关系\n  '', '', '', '', '', \n  // 产物第 6 行的映射信息\n  'AAAA,IAAMA,IAAI,GAAG,QAAb', \n  // 产物第 7 行的映射信息\n  'AAEAC,OAAO,CAACC,GAAR,CAAYF,IAAZ,E'\n]\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["以 ",(0,s.jsx)(n.code,{children:","})," 分割的",(0,s.jsx)(n.strong,{children:"片段映射"}),"，每一个 ",(0,s.jsx)(n.code,{children:","})," 对应该行中每一个代码片段到源码的映射，上例经过分割后："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"[\n  // 产物第 1-5 行内容为 Webpack 生成的 runtime，不需要记录映射关系\n  '', '', '', '', '', \n  // 产物第 6 行的映射信息\n  [\n    // 片段 `var` 到 `const` 的映射\n    'AAAA', \n    // 片段 `name` 到 `name` 的映射\n    'IAAMA', \n    // 等等\n    'IAAI', 'GAAG', 'QAAb'], \n  // 产物第 7 行的映射信息\n  ['AAEAC', 'OAAO', 'CAACC', 'GAAR', 'CAAYF', 'IAAZ', 'E']\n]\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第三层逻辑为片段映射到源码的具体位置，以上例 ",(0,s.jsx)(n.code,{children:"IAAMA"})," 为例：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第一位 ",(0,s.jsx)(n.code,{children:"I"})," 代表该代码片段在产物中列数；"]}),"\n",(0,s.jsxs)(n.li,{children:["第二位 ",(0,s.jsx)(n.code,{children:"A"})," 代表源码文件的索引，即该片段对标到 ",(0,s.jsx)(n.code,{children:"sources"})," 数组的元素下标；"]}),"\n",(0,s.jsxs)(n.li,{children:["第三位 ",(0,s.jsx)(n.code,{children:"A"})," 代表片段在源码文件的行数；"]}),"\n",(0,s.jsxs)(n.li,{children:["第四位 ",(0,s.jsx)(n.code,{children:"M"})," 代表片段在源码文件的列数；"]}),"\n",(0,s.jsxs)(n.li,{children:["第五位 ",(0,s.jsx)(n.code,{children:"A"})," 代表该片段对应的名称索引，即该片段对标到 ",(0,s.jsx)(n.code,{children:"names"})," 数组的元素下标。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["上述第1、2层逻辑比较简单，唯一需要注意的是片段之间是一种相对偏移关系，例如对于上例第六行映射值：",(0,s.jsx)(n.code,{children:"AAAA,IAAMA,IAAI,GAAG,QAAb"}),"，每一个片段的第一位 —— 即片段列数为 ",(0,s.jsx)(n.code,{children:"A,I,I,G,Q"}),"，分别代表："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"A"})," ：第 ",(0,s.jsx)(n.code,{children:"A"})," 列；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"I"})," ：第 ",(0,s.jsx)(n.code,{children:"A + I"})," 列；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"I"})," ：第 ",(0,s.jsx)(n.code,{children:"A + I + I"})," 列；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"G"})," ：第 ",(0,s.jsx)(n.code,{children:"A + I + I + G"})," 列；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Q"})," ：第 ",(0,s.jsx)(n.code,{children:"A + I + I + G + Q"})," 列。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这种相对偏移能减少 Sourcemap 产物的体积，提升整体性能。注意，第三层逻辑中的片段位置映射则用到了一种比较高效数值编码算法 —— VLQ(Variable-length Quantity)。"}),"\n",(0,s.jsxs)(n.h2,{id:"vlq-编码",children:["VLQ 编码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vlq-编码",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Variable-lengsth_quantity",target:"_blank",rel:"noopener noreferrer",children:"VLQ"})," 是一种将整数数值转换为 Base64 的编码算法，它先将任意大的整数转换为一系列六位字节码，再按 Base64 规则转换为一串可见字符。VLQ 使用六位比特存储一个编码分组，例如："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["数字 7 经过 VLQ 编码后，结果为 ",(0,s.jsx)(n.code,{children:"001110"}),"，其中："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第一位为连续标志位，标识后续分组是否为同一数字；"}),"\n",(0,s.jsx)(n.li,{children:"第六位表示该数字的正负符号，0为正整数，1为负整数；"}),"\n",(0,s.jsx)(n.li,{children:"中间第 2-5 为实际数值。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这样一个六位编码分组，就可以按照 Base64 的映射规则转换为 ",(0,s.jsx)(n.code,{children:"ABC"})," 等可见字符，例如上述数字 7 编码结果 ",(0,s.jsx)(n.code,{children:"001110"}),"，等于十进制的 14，按 Base64 字码表可映射为字母 ",(0,s.jsx)(n.code,{children:"O"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["但是，分组中只有中间的 4 个字节用于表示数值，因此单个分组只能表达 ",(0,s.jsx)(n.strong,{children:"-15 ~ 15"})," 之间的数值范围，对于超过这个范围的整数，需要组合多个分组，共同表达同一数字，具体规则："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第一个分组的最后一位为符号位，其它分组从 2-6 均为数值位；"}),"\n",(0,s.jsx)(n.li,{children:"取二进制值最后四位为第一个分组值，之后从后到前，每 5 位划分为一个分组；"}),"\n",(0,s.jsx)(n.li,{children:"除最后一个分组外，其余分组的连续标志位都设置为 1。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["例如，对于十进制 -17，其二进制为 ",(0,s.jsx)(n.code,{children:"10001"})," (取 17 的二进制) 共 5 位，首先从后到前拆分为两组，后四位 ",(0,s.jsx)(n.code,{children:"0001"})," 为第一组，连续标志位为 1，符号位为 1，结果为 ",(0,s.jsx)(n.code,{children:"1,0001,1"}),"；剩下的 ",(0,s.jsx)(n.code,{children:"1"})," 分配到第二个 —— 也是最后一个分组，连续标志位为 0，结果为 ",(0,s.jsx)(n.code,{children:"0,00001"}),"。按 Base64 规则 ",(0,s.jsx)(n.code,{children:"[100011, 000001]"})," 最终映射为 ",(0,s.jsx)(n.code,{children:"jA"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"十进制     二进制               VLQ    Base64\n  -17 => 1,0001 => 100011, 000001 =>     jA\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同样的，对于更大的数字，例如 1200，其二进制为 ",(0,s.jsx)(n.code,{children:"10010110000"}),"，分组为 ",(0,s.jsx)(n.code,{children:"[10, 01011, 0000]"}),"，从后到前编码，第一个分组为 ",(0,s.jsx)(n.code,{children:"1,0000,0"}),"；第二个分组为 ",(0,s.jsx)(n.code,{children:"1,01011"}),"；最后一个分组为 ",(0,s.jsx)(n.code,{children:"0,00010"}),"。按 Base64 映射为 ",(0,s.jsx)(n.code,{children:"grC"}),"。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"十进制            二进制                     VLQ    Base64\n 1200 => 10;01011;0000 => 100000,101011,000010 =>    grC\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"结合 VLQ 编码规则，我们再回过头来解读本章开头的例子，对于代码："}),"\n",(0,s.jsxs)(n.p,{children:["编译生成 ",(0,s.jsx)(n.code,{children:"mappings"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:";;;;;AAAA,IAAMA,IAAI,GAAG,QAAb;AAEAC,OAAO,CAACC,GAAR,CAAYF,IAAZ,E\n"})}),"\n",(0,s.jsx)(n.p,{children:"按行、片段规则分割后，得出如下片段："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[\n  // 产物第 1-5 行内容为 Webpack 生成的 runtime，不需要记录映射关系\n  '', '', '', '', '', \n  // 产物第 6 行的映射信息\n  ['AAAA', 'IAAMA', 'IAAI', 'GAAG', 'QAAb'], \n  // 产物第 7 行的映射信息\n  ['AAEAC', 'OAAO', 'CAACC', 'GAAR', 'CAAYF', 'IAAZ', 'E']\n]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["以第 6 行 ",(0,s.jsx)(n.code,{children:"['AAAA', 'IAAMA', 'IAAI', 'GAAG', 'QAAb']"})," 为例："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"AAAA"})," 解码结果为 ",(0,s.jsx)(n.code,{children:"[000000, 000000, 000000, 000000]"}),"，即产物第 6 行",(0,s.jsx)(n.strong,{children:"第"}),"  ",(0,s.jsx)(n.strong,{children:"0"}),"  ",(0,s.jsx)(n.strong,{children:"列"}),"映射到 ",(0,s.jsx)(n.code,{children:"sources[0]"})," 文件的",(0,s.jsx)(n.strong,{children:"第"}),"  ",(0,s.jsx)(n.strong,{children:"0"}),"  ",(0,s.jsx)(n.strong,{children:"行"}),"，",(0,s.jsx)(n.strong,{children:"第"}),"  ",(0,s.jsx)(n.strong,{children:"0"}),"  ",(0,s.jsx)(n.strong,{children:"列"}),"，实际对应 ",(0,s.jsx)(n.code,{children:"var"})," 到 ",(0,s.jsx)(n.code,{children:"const"})," 的位置映射；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IAAMA"})," 解码结果为 ",(0,s.jsx)(n.code,{children:"[001000, 000000, 000000, 001100, 000000]"}),"，即产物第 6 行第 4 列映射到 ",(0,s.jsx)(n.code,{children:"sources[0]"})," 文件的",(0,s.jsx)(n.strong,{children:"第"}),"  ",(0,s.jsx)(n.strong,{children:"0"}),"  ",(0,s.jsx)(n.strong,{children:"行"}),"，",(0,s.jsx)(n.strong,{children:"第"}),"  ",(0,s.jsx)(n.strong,{children:"6"}),"  ",(0,s.jsx)(n.strong,{children:"列"}),"，实际对应产物 ",(0,s.jsx)(n.code,{children:"name"})," 到源码 ",(0,s.jsx)(n.code,{children:"name"})," 的位置映射。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["其它片段以此类推，Webpack 生成 ",(0,s.jsx)(n.code,{children:".map"})," 文件时，只需要在 ",(0,s.jsx)(n.code,{children:"webpack-sources"})," 中，按照这个编码规则计算好编译前后的代码映射关系即可。"]}),"\n",(0,s.jsxs)(n.h2,{id:"devtool-规则详解",children:[(0,s.jsx)(n.code,{children:"devtool"})," 规则详解",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#devtool-规则详解",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 提供了两种设置 Sourcemap 的方式，一是通过 ",(0,s.jsx)(n.code,{children:"devtool"})," 配置项设置 Sourcemap 规则短语；二是直接使用 ",(0,s.jsx)(n.code,{children:"SourceMapDevToolPlugin"})," 或 ",(0,s.jsx)(n.code,{children:"EvalSourceMapDevToolPlugin"})," 插件深度定制 Sourcemap 的生成逻辑。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/devtool/",target:"_blank",rel:"noopener noreferrer",children:"devtool"})," 支持 25 种字符串枚举值，包括 ",(0,s.jsx)(n.code,{children:"eval"}),"、",(0,s.jsx)(n.code,{children:"source-map"}),"、",(0,s.jsx)(n.code,{children:"eval-source-map"})," 等："]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：内容摘抄自 Webpack ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/devtool/",target:"_blank",rel:"noopener noreferrer",children:"官网"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["分开来看都特别晦涩，但这些枚举值内在有一个潜规则：都是由 ",(0,s.jsx)(n.code,{children:"inline"}),"、",(0,s.jsx)(n.code,{children:"eval"}),"、",(0,s.jsx)(n.code,{children:"source-map"}),"、",(0,s.jsx)(n.code,{children:"nosources"}),"、",(0,s.jsx)(n.code,{children:"hidden"}),"、",(0,s.jsx)(n.code,{children:"cheap"}),"、",(0,s.jsx)(n.code,{children:"module"})," 七种关键字组合而成，这些关键词各自代表一项 Sourcemap 规则，拆开来看："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"eval"})," 关键字"]}),"：当 ",(0,s.jsx)(n.code,{children:"devtool"})," 值包含 ",(0,s.jsx)(n.code,{children:"eval"})," 时，生成的模块代码会被包裹进一段 ",(0,s.jsx)(n.code,{children:"eval"})," 函数中，且模块的 Sourcemap 信息通过 ",(0,s.jsx)(n.code,{children:"//# sourceURL"})," 直接挂载在模块代码内。例如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"eval(\"var foo = 'bar'\\n\\n\\n//# sourceURL=webpack:///./src/index.ts?\")\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"eval"})," 模式编译速度通常比较快，但产物中直接包含了 Sourcemap 信息，因此只推荐在开发环境中使用。"]}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"source-map"})," 关键字"]}),"：当 ",(0,s.jsx)(n.code,{children:"devtool"})," 包含 ",(0,s.jsx)(n.code,{children:"source-map"})," 时，Webpack 才会生成 Sourcemap 内容。例如，对于 ",(0,s.jsx)(n.code,{children:"devtool = 'source-map'"}),"，产物会额外生成 ",(0,s.jsx)(n.code,{children:".map"})," 文件，形如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "version": 3,\n    "sources": [\n        "webpack:///./src/index.ts"\n    ],\n    "names": [\n        "console",\n        "log"\n    ],\n    "mappings": "AACAA,QAAQC,IADI",\n    "file": "bundle.js",\n    "sourcesContent": [\n        "const foo = \'bar\';\\nconsole.log(foo);"\n    ],\n    "sourceRoot": ""\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["实际上，除 ",(0,s.jsx)(n.code,{children:"eval"})," 之外的其它枚举值都包含该字段。"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"cheap"})," 关键字"]}),"：当 ",(0,s.jsx)(n.code,{children:"devtool"})," 包含 ",(0,s.jsx)(n.code,{children:"cheap"})," 时，生成的 Sourcemap 内容会抛弃",(0,s.jsx)(n.strong,{children:"列"}),"维度的信息，这就意味着浏览器只能映射到代码行维度。例如 ",(0,s.jsx)(n.code,{children:"devtool = 'cheap-source-map'"})," 时，产物："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n    "version": 3,\n    "file": "bundle.js",\n    "sources": [\n        "webpack:///bundle.js"\n    ],\n    "sourcesContent": [\n        "console.log(\\"bar\\");"\n    ],\n    // 带 cheap 效果：\n    "mappings": "AAAA",\n    // 不带 cheap 效果：\n    // "mappings": "AACAA,QAAQC,IADI",\n    "sourceRoot": ""\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"浏览器映射效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["虽然 Sourcemap 提供的映射功能可精确定位到文件、行、列粒度，但有时在",(0,s.jsx)(n.strong,{children:"行"}),"级别已经足够帮助我们达到调试定位的目的，此时可选择使用 ",(0,s.jsx)(n.code,{children:"cheap"})," 关键字，简化 Sourcemap 内容，减少 Sourcemap 文件体积。"]}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"module"})," 关键字"]}),"：",(0,s.jsx)(n.code,{children:"module"})," 关键字只在 ",(0,s.jsx)(n.code,{children:"cheap"})," 场景下生效，例如 ",(0,s.jsx)(n.code,{children:"cheap-module-source-map"}),"、",(0,s.jsx)(n.code,{children:"eval-cheap-module-source-map"}),"。当 ",(0,s.jsx)(n.code,{children:"devtool"})," 包含 ",(0,s.jsx)(n.code,{children:"cheap"})," 时，Webpack 根据 ",(0,s.jsx)(n.code,{children:"module"})," 关键字判断按 loader 联调处理结果作为 source，还是按处理之前的代码作为 source。例如："]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["注意观察上例 ",(0,s.jsx)(n.code,{children:"sourcesContent"})," 字段，左边 ",(0,s.jsx)(n.code,{children:"devtool"})," 带 ",(0,s.jsx)(n.code,{children:"module"})," 关键字，因此此处映射的，是包含 ",(0,s.jsx)(n.code,{children:"class Person"})," 的最原始代码；而右边生成的 ",(0,s.jsx)(n.code,{children:"sourcesContent"})," ，则是经过 babel-loader 编译处理的内容。"]}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"nosources"})," 关键字"]}),"：当 ",(0,s.jsx)(n.code,{children:"devtool"})," 包含 ",(0,s.jsx)(n.code,{children:"nosources"})," 时，生成的 Sourcemap 内容中不包含源码内容 —— 即 ",(0,s.jsx)(n.code,{children:"sourcesContent"})," 字段。例如 ",(0,s.jsx)(n.code,{children:"devtool = 'nosources-source-map'"})," 时，产物："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "version": 3,\n    "sources": [\n        "webpack:///./src/index.ts"\n    ],\n    "names": [\n        "console",\n        "log"\n    ],\n    "mappings": "AACAA,QAAQC,IADI",\n    "file": "bundle.js",\n    "sourceRoot": ""\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["虽然没有带上源码，但 ",(0,s.jsx)(n.code,{children:".map"})," 产物中还带有文件名、 ",(0,s.jsx)(n.code,{children:"mappings"})," 字段、变量名等信息，依然能够帮助开发者定位到代码对应的原始位置，配合 ",(0,s.jsx)(n.code,{children:"sentry"})," 等工具提供的源码映射功能，可在异地还原诸如错误堆栈之类的信息。"]}),"\n",(0,s.jsxs)(n.ol,{start:"6",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"inline"})," 关键字"]}),"：当 ",(0,s.jsx)(n.code,{children:"devtool"})," 包含 ",(0,s.jsx)(n.code,{children:"inline"})," 时，Webpack 会将 Sourcemap 内容编码为 Base64 DataURL，直接追加到产物文件中。例如对于 ",(0,s.jsx)(n.code,{children:"devtool = 'inline-source-map'"}),"，产物："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'console.log("bar");\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOlsiY29uc29sZSIsImxvZyJdLCJtYXBwaW5ncyI6IkFBQ0FBLFFBQVFDLElBREkiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZm9vID0gJ2Jhcic7XG5jb25zb2xlLmxvZyhmb28pOyJdLCJzb3VyY2VSb290IjoiIn0=\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"inline"})," 模式编译速度较慢，且产物体积非常大，只适合开发环境使用。"]}),"\n",(0,s.jsxs)(n.ol,{start:"7",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"hidden"})," 关键字"]}),"：通常，产物中必须携带 ",(0,s.jsx)(n.code,{children:"//# sourceMappingURL="})," 指令，浏览器才能正确找到 Sourcemap 文件，当 ",(0,s.jsx)(n.code,{children:"devtool"})," 包含 ",(0,s.jsx)(n.code,{children:"hidden"})," 时，编译产物中不包含 ",(0,s.jsx)(n.code,{children:"//# sourceMappingURL="})," 指令。例如："]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["两者区别仅在于编译产物最后一行的 ",(0,s.jsx)(n.code,{children:"//# sourceMappingURL="})," 指令，当你需要 Sourcemap 功能，又不希望浏览器 Devtool 工具自动加载时，可使用此选项。需要打开 Sourcemap 时，可在浏览器中手动加载："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:"f412b094-f908-42a3-9b51-a3f3622a71c0.gif"})}),"\n",(0,s.jsxs)(n.p,{children:["总结一下，Webpack 的 ",(0,s.jsx)(n.code,{children:"devtool"})," 值都是由以上七种关键字的一个或多个组成，虽然提供了 27 种候选项，但逻辑上都是由上述规则叠加而成，例如："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cheap-source-map"}),"：代表 ",(0,s.jsx)(n.strong,{children:"不带列映射"})," 的 Sourcemap ；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eval-nosources-cheap-source-map"}),"：代表 ",(0,s.jsxs)(n.strong,{children:["以 ",(0,s.jsx)(n.code,{children:"eval"})," 包裹模块代码"]})," ，且 ",(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:".map"})," 映射文件中不带源码"]}),"，且 ",(0,s.jsx)(n.strong,{children:"不带列映射"})," 的 Sourcemap。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"其它选项以此类推。最后再总结一下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["对于开发环境，适合使用：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eval"}),"：速度极快，但只能看到原始文件结构，看不到打包前的代码内容；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cheap-eval-source-map"}),"：速度比较快，可以看到打包前的代码内容，但看不到 loader 处理之前的源码；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"cheap-module-eval-source-map"}),"：速度比较快，可以看到 loader 处理之前的源码，不过定位不到列级别；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"eval-source-map"}),"：初次编译较慢，但定位精度最高；"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["对于生产环境，则适合使用：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"source-map"}),"：信息最完整，但安全性最低，外部用户可轻易获取到压缩、混淆之前的源码，慎重使用；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"hidden-source-map"}),"：信息较完整，安全性较低，外部用户获取到 ",(0,s.jsx)(n.code,{children:".map"})," 文件地址时依然可以拿到源码；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"nosources-source-map"}),"：源码信息缺失，但安全性较高，需要配合 Sentry 等工具实现完整的 Sourcemap 映射。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-source-map-插件",children:["使用 ",(0,s.jsx)(n.code,{children:"source-map"})," 插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-source-map-插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上面介绍的 ",(0,s.jsx)(n.code,{children:"devtool"})," 配置项，本质上只是一种方便记忆、使用的规则缩写短语，Sourcemap 的底层处理逻辑实际由 ",(0,s.jsx)(n.code,{children:"SourceMapDevToolPlugin"})," 与 ",(0,s.jsx)(n.code,{children:"EvalSourceMapDevToolPlugin"})," 插件实现。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"devtool"})," 基础上，插件还提供了更多、更细粒度的配置项，用于满足更复杂的需求场景，包括："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"test"}),"、",(0,s.jsx)(n.code,{children:"include"}),"、",(0,s.jsx)(n.code,{children:"exclude"})," 配置项过滤需要生成 Sourcemap 的 Bundle；"]}),"\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"append"}),"、",(0,s.jsx)(n.code,{children:"filename"}),"、",(0,s.jsx)(n.code,{children:"moduleFilenameTemplate"}),"、",(0,s.jsx)(n.code,{children:"publicPath"})," 配置项设定 Sourcemap 文件的文件名、URL 。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"使用方法与其它插件无异，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const webpack = require('webpack');\nmodule.exports = {\n  // ...\n  devtool: false,\n  plugins: [new webpack.SourceMapDevToolPlugin({\n      exclude: ['vendor.js']\n  })],\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"插件配置规则较简单，此处不赘述。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["综上，Sourcemap 是一种高效的位置映射算法，它将产物到源码之间的位置关系表达为 ",(0,s.jsx)(n.code,{children:"mappings"})," 分层设计与 VLQ 编码，再通过 Chrome、Safari、VS Code、Sentry 等工具异地还原为接近开发状态的源码形式。"]}),"\n",(0,s.jsxs)(n.p,{children:["在 Webpack 中，通常只需要选择适当的 ",(0,s.jsx)(n.code,{children:"devtool"})," 短语即可满足大多数场景需求，特殊情况下也可以直接使用 ",(0,s.jsx)(n.code,{children:"SourceMapDevToolPlugin"})," 做更深度的定制化。"]}),"\n",(0,s.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"为什么 Sourcemap 要设计分层结构 + VLQ 编码做行列映射？假设直接记录行列号，会有什么问题？"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let A=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F29.Sourcemap%EF%BC%9A%E6%BA%90%E7%A0%81%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7.md"]={toc:[{text:"Sourcemap 映射结构",id:"sourcemap-映射结构",depth:2},{text:"VLQ 编码",id:"vlq-编码",depth:2},{text:"`devtool` 规则详解",id:"devtool-规则详解",depth:2},{text:"使用 `source-map` 插件",id:"使用-source-map-插件",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"29.Sourcemap：源码映射原理与应用技巧",headingTitle:"29.Sourcemap：源码映射原理与应用技巧",frontmatter:{}}}}]);