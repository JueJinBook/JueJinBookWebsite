"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["10129"],{883027:function(e,n,s){s.r(n),s.d(n,{default:()=>j});var r=s(552676),t=s(740453);let a=s.p+"static/image/fd5b17746ee5dc6873486aa52209134f.a2887cee.gif",i=s.p+"static/image/317e5260276eec61a5b774b82636c193.a06e8a82.gif",c=s.p+"static/image/01af2396d129be933617c26932d7517a.2a8b171e.webp",d=s.p+"static/image/85392a460038ea1afe883ecf1cac8ba8.9242a919.webp",o=s.p+"static/image/da4afb921a03c54280cc3e95be59a2e5.c7ee7239.webp",l=s.p+"static/image/9ae0bb87ee2b253b1256b4186d4f690a.604ead00.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",strong:"strong",code:"code",pre:"pre",img:"img",ol:"ol",li:"li"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"8渲染篇-_-从-csrssrssgisr-开始说起",children:["8.渲染篇 _ 从 CSR、SSR、SSG、ISR 开始说起",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8渲染篇-_-从-csrssrssgisr-开始说起",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"以前学习 Next.js 可能是听说了 Next.js 一个框架就可以实现 CSR、SSR、SSG、ISR 这些功能，但在 Next.js v13 之后，Next.js 推出了基于 React Server Component 的 App Router。"}),"\n",(0,r.jsx)(n.p,{children:"SSR、SSG 等名词也在最新的文档中被弱化、少有提及（这些功能当然还在的），但理解这些名词背后的原理和区别，依然有助于我们理解和使用 Next.js。"}),"\n",(0,r.jsxs)(n.h2,{id:"1-csr",children:["1. CSR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-csr",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"11-概念介绍",children:["1.1. 概念介绍",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-概念介绍",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们先从传统的 CSR 开始说起。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"CSR，英文全称“Client-side Rendering”，中文翻译“客户端渲染”。顾名思义，渲染工作主要在客户端执行。"})}),"\n",(0,r.jsx)(n.p,{children:"像我们传统使用 React 的方式，就是客户端渲染。浏览器会先下载一个非常小的 HTML 文件和所需的  JavaScript 文件。在 JavaScript 中执行发送请求、获取数据、更新 DOM 和渲染页面等操作。"}),"\n",(0,r.jsx)(n.p,{children:"这样做最大的问题就是不够快。（SEO 问题是其次，现在的爬虫已经普遍能够支持 CSR 渲染的页面）"}),"\n",(0,r.jsx)(n.p,{children:"在下载、解析、执行 JavaScript以及请求数据没有返回前，页面不会完全呈现。"}),"\n",(0,r.jsxs)(n.h3,{id:"12-nextjs-实现-csr",children:["1.2. Next.js 实现 CSR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-nextjs-实现-csr",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Next.js 支持 CSR，在 Next.js Pages Router 下有两种方式实现客户端渲染。"}),"\n",(0,r.jsxs)(n.p,{children:["一种是在页面中使用 React ",(0,r.jsx)(n.code,{children:"useEffect"})," hook，而不是服务端的渲染方法（比如 ",(0,r.jsx)(n.code,{children:"getStaticProps"}),"和 ",(0,r.jsx)(n.code,{children:"getServerSideProps"}),"，这两个方法后面会讲到），举个例子："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// pages/csr.js\nimport React, { useState, useEffect } from 'react'\n \nexport default function Page() {\n  const [data, setData] = useState(null)\n \n  useEffect(() => {\n    const fetchData = async () => {\n      const response = await fetch('https://jsonplaceholder.typicode.com/todos/1')\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`)\n      }\n      const result = await response.json()\n      setData(result)\n    }\n \n    fetchData().catch((e) => {\n      console.error('An error occurred while fetching the data: ', e)\n    })\n  }, [])\n \n  return <p>{data ? `Your data: ${JSON.stringify(data)}` : 'Loading...'}</p>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"可以看到，请求由客户端发出，同时页面显示 loading 状态，等数据返回后，主要内容在客户端进行渲染。"}),"\n",(0,r.jsxs)(n.p,{children:["当访问 ",(0,r.jsx)(n.code,{children:"/csr"}),"的时候，渲染的 HTML 文件为："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"JavaScript 获得数据后，最终更新为："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["第二种方法是在客户端使用数据获取的库比如 ",(0,r.jsx)(n.a,{href:"https://swr.vercel.app/",target:"_blank",rel:"noopener noreferrer",children:"SWR"}),"（也是 Next.js 团队开发的）或 ",(0,r.jsx)(n.a,{href:"https://tanstack.com/query/latest/",target:"_blank",rel:"noopener noreferrer",children:"TanStack Query"}),"，举个例子："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// pages/csr2.js\nimport useSWR from 'swr'\nconst fetcher = (...args) => fetch(...args).then((res) => res.json())\n\nexport default function Page() {\n  const { data, error, isLoading } = useSWR(\n    'https://jsonplaceholder.typicode.com/todos/1',\n    fetcher\n  )\n \n  if (error) return <p>Failed to load.</p>\n  if (isLoading) return <p>Loading...</p>\n \n  return <p>Your Data: {data.title}</p>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"效果同上"}),"\n",(0,r.jsxs)(n.h2,{id:"2-ssr",children:["2. SSR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-ssr",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"21-概念介绍",children:["2.1. 概念介绍",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-概念介绍",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"SSR，英文全称“Server-side Rendering”，中文翻译“服务端渲染”。顾名思义，渲染工作主要在服务端执行。"})}),"\n",(0,r.jsx)(n.p,{children:"比如打开一篇博客文章页面，没有必要每次都让客户端请求，万一客户端网速不好呢，那干脆由服务端直接请求接口、获取数据，然后渲染成静态的 HTML 文件返回给用户。"}),"\n",(0,r.jsx)(n.p,{children:"虽然同样是发送请求，但通常服务端的环境（网络环境、设备性能）要好于客户端，所以最终的渲染速度（首屏加载时间）也会更快。"}),"\n",(0,r.jsx)(n.p,{children:"虽然总体速度是更快的，但因为 CSR 响应时只用返回一个很小的 HTML，SSR 响应还要请求接口，渲染 HTML，所以其响应时间会更长，对应到性能指标 TTFB (Time To First Byte)，SSR 更长。"}),"\n",(0,r.jsxs)(n.h3,{id:"22-nextjs-实现-ssr",children:["2.2. Next.js 实现 SSR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-nextjs-实现-ssr",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Next.js 支持 SSR，我们使用 Pages Router 写个 demo："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// pages/ssr.js\nexport default function Page({ data }) {\n  return <p>{JSON.stringify(data)}</p>\n}\n \nexport async function getServerSideProps() {\n  const res = await fetch(`https://jsonplaceholder.typicode.com/todos`)\n  const data = await res.json()\n \n  return { props: { data } }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["使用 SSR，你需要导出一个名为 ",(0,r.jsx)(n.code,{children:"getServerSideProps"}),"的 async 函数。这个函数会在每次请求的时候被调用。返回的数据会通过组件的 props 属性传递给组件。"]}),"\n",(0,r.jsx)(n.p,{children:"效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"服务端会在每次请求的时候编译 HTML 文件返回给客户端。查看 HTML，这些数据可以直接看到："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"3-ssg",children:["3. SSG",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-ssg",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"31-概念介绍",children:["3.1. 概念介绍",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-概念介绍",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"SSG，英文全称“Static Site Generation”，中文翻译“静态站点生成”。"})}),"\n",(0,r.jsx)(n.p,{children:"SSG 会在构建阶段，就将页面编译为静态的 HTML 文件。"}),"\n",(0,r.jsx)(n.p,{children:"比如打开一篇博客文章页面，既然所有人看到的内容都是一样的，没有必要在用户请求页面的时候，服务端再请求接口。干脆先获取数据，提前编译成 HTML 文件，等用户访问的时候，直接返回 HTML 文件。这样速度会更快。再配上 CDN 缓存，速度就更快了。"}),"\n",(0,r.jsx)(n.p,{children:"所以能用 SSG 就用 SSG。“在用户访问之前是否能预渲染出来？”如果能，就用 SSG。"}),"\n",(0,r.jsxs)(n.h3,{id:"32-nextjs-实现-ssg",children:["3.2. Next.js 实现 SSG",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-nextjs-实现-ssg",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Next.js 支持 SSG。当不获取数据时，默认使用的就是 SSG。我们使用 Pages Router 写个 demo："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// pages/ssg1.js\nfunction About() {\n  return <div>About</div>\n}\n \nexport default About\n"})}),"\n",(0,r.jsx)(n.p,{children:"像这种没有数据请求的页面，Next.js 会在构建的时候生成一个单独的 HTML 文件。"}),"\n",(0,r.jsxs)(n.p,{children:["不过 Next.js 默认没有导出该文件。如果你想看到构建生成的 HTML 文件，修改 ",(0,r.jsx)(n.code,{children:"next.config.js"})," 文件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const nextConfig = {\n  output: 'export'\n}\n \nmodule.exports = nextConfig\n"})}),"\n",(0,r.jsxs)(n.p,{children:["再执行 ",(0,r.jsx)(n.code,{children:"npm run build"}),"，你就会在根目录下看到生成的 ",(0,r.jsx)(n.code,{children:"out"})," 文件夹，里面存放了构建生成的 HTML 文件。"]}),"\n",(0,r.jsx)(n.p,{children:"那如果要获取数据呢？这分两种情况。"}),"\n",(0,r.jsxs)(n.p,{children:["第一种情况，页面内容需要获取数据。就比如博客的文章内容需要调用 API 获取。Next.js 提供了 ",(0,r.jsx)(n.code,{children:"getStaticProps"}),"。写个 demo："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// pages/ssg2.js\nexport default function Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nexport async function getStaticProps() {\n  const res = await fetch('https://jsonplaceholder.typicode.com/posts')\n  const posts = await res.json()\n  return {\n    props: {\n      posts,\n    },\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getStaticProps"}),"会在构建的时候被调用，并将数据通过 props 属性传递给页面。"]}),"\n",(0,r.jsxs)(n.p,{children:["（还记得 ",(0,r.jsx)(n.code,{children:"getServerSideProps"})," 吗？两者在用法上类似，不过 ",(0,r.jsx)(n.code,{children:"getServerSideProps"})," 是在每次请求的时候被调用，",(0,r.jsx)(n.code,{children:"getStaticProps"})," 在每次构建的时候）"]}),"\n",(0,r.jsx)(n.p,{children:"第二种情况，是页面路径需要获取数据。"}),"\n",(0,r.jsxs)(n.p,{children:["这是什么意思呢？就比如数据库里有 100 篇文章，我肯定不可能自己手动定义 100 个路由，然后预渲染 100 个 HTML 吧。Next.js 提供了 ",(0,r.jsx)(n.code,{children:"getStaticPaths"}),"用于定义预渲染的路径。它需要搭配动态路由使用。写个 demo："]}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"/pages/post/[id].js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// /pages/post/[id].js\nexport default function Blog({ post }) {\n  return (\n    <>\n      <header>{post.title}</header>\n      <main>{post.body}</main>\n    </>\n  )\n}\n\nexport async function getStaticPaths() {\n  const res = await fetch('https://jsonplaceholder.typicode.com/posts')\n  const posts = await res.json()\n \n  const paths = posts.map((post) => ({\n    params: { id: String(post.id) },\n  }))\n\n  // { fallback: false } 意味着当访问其他路由的时候返回 404\n  return { paths, fallback: false }\n}\n\nexport async function getStaticProps({ params }) {\n  // 如果路由地址为 /posts/1, params.id 为 1\n  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`)\n  const post = await res.json()\n \n  return { props: { post } }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其中，",(0,r.jsx)(n.code,{children:"getStaticPaths"})," 和 ",(0,r.jsx)(n.code,{children:"getStaticProps"}),"都会在构建的时候被调用，",(0,r.jsx)(n.code,{children:"getStaticPaths"})," 定义了哪些路径被预渲染，",(0,r.jsx)(n.code,{children:"getStaticProps"}),"获取路径参数，请求数据传给页面。"]}),"\n",(0,r.jsxs)(n.p,{children:["当你执行 ",(0,r.jsx)(n.code,{children:"npm run build"}),"的时候，就会看到 post 文件下生成了一堆 HTML 文件："]}),"\n",(0,r.jsxs)(n.h2,{id:"4-isr",children:["4. ISR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-isr",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"41-概念介绍",children:["4.1. 概念介绍",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-概念介绍",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ISR，英文全称“Incremental Static Regeneration”，中文翻译“增量静态再生”。"})}),"\n",(0,r.jsx)(n.p,{children:"还是打开一篇博客文章页面，博客的主体内容也许是不变的，但像比如点赞、收藏这些数据总是在变化的吧。使用 SSG 编译成 HTML 文件后，这些数据就无法准确获取了，那你可能就退而求其次改为 SSR 或者 CSR 了。"}),"\n",(0,r.jsx)(n.p,{children:"考虑到这种情况，Next.js 提出了 ISR。当用户访问了这个页面，第一次依然是老的 HTML 内容，但是 Next.js 同时静态编译成新的 HTML 文件，当你第二次访问或者其他用户访问的时候，就会变成新的 HTML 内容了。"}),"\n",(0,r.jsxs)(n.p,{children:["Next.js v9.5 就发布了稳定的 ISR 功能，这是当时提供的 ",(0,r.jsx)(n.a,{href:"https://reactions-demo.vercel.app/",target:"_blank",rel:"noopener noreferrer",children:"demo"})," 效果："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"reactions-demo.gif"})}),"\n",(0,r.jsxs)(n.p,{children:["不过目前 demo 失效中。你可以在",(0,r.jsx)(n.a,{href:"https://on-demand-isr.vercel.app/",target:"_blank",rel:"noopener noreferrer",children:"新 demo"})," 中测试 ISR 效果。"]}),"\n",(0,r.jsxs)(n.h3,{id:"42-nextjs-实现-isr",children:["4.2. Next.js 实现 ISR",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-nextjs-实现-isr",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Next.js 支持 ISR，并且使用的方式很简单。你只用在 ",(0,r.jsx)(n.code,{children:"getStaticProps"})," 中添加一个 ",(0,r.jsx)(n.code,{children:"revalidate"}),"即可。我们基于 SSG 的示例代码上进行修改："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// pages/post/[id].js\n// 保持不变\nexport default function Blog({ post }) {\n  return (\n    <>\n      <header>{post.title}</header>\n      <main>{post.body}</main>\n    </>\n  )\n}\n\n// fallback 的模式改为 'blocking'\nexport async function getStaticPaths() {\n  const res = await fetch('https://jsonplaceholder.typicode.com/posts')\n  const posts = await res.json()\n \n  const paths = posts.slice(0, 10).map((post) => ({\n    params: { id: String(post.id) },\n  }))\n \n  return { paths, fallback: 'blocking' }\n}\n\n// 使用这种随机的方式模拟数据改变\nfunction getRandomInt(max) {\n  return Math.floor(Math.random() * max);\n}\n\n// 多返回了 revalidata 属性\nexport async function getStaticProps({ params }) {\n  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${getRandomInt(100)}`)\n  const post = await res.json()\n \n  return { \n    props: { post }, \n    revalidate: 10\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"revalidate"}),"表示当发生请求的时候，至少间隔多少秒才更新页面。"]}),"\n",(0,r.jsxs)(n.p,{children:["这听起来有些抽象，以 ",(0,r.jsx)(n.code,{children:"revalidate: 10"})," 为例，在初始请求后和接下来的 10 秒内，页面都会使用之前构建的 HTML。10s 后第一个请求发生的时候，依然使用之前编译的 HTML。但 Next.js 会开始构建更新 HTML，从下个请求起就会使用新的 HTML。（如果构建失败了，就还是用之前的，等下次再触发更新）"]}),"\n",(0,r.jsxs)(n.p,{children:["当你在本地使用 ",(0,r.jsx)(n.code,{children:"next dev"}),"运行的时候，",(0,r.jsx)(n.code,{children:"getStaticProps"}),"会在每次请求的时候被调用。所以如果你要测试 ISR 功能，先构建出生产版本，再运行生产服务。也就是说，测试 ISR 效果，用这俩命令："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"next build // 或 npm run build\nnext start // 或 npm run start\n"})}),"\n",(0,r.jsx)(n.p,{children:"最终示例代码的效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"isr.gif"})}),"\n",(0,r.jsx)(n.p,{children:"你可以看到，页面刷新后，文章内容发生变化。然后 10s 内的刷新，页面内容都没有变化。10s 后的第一次刷新触发了更新，10s 后的第二次刷新内容发生了变化。"}),"\n",(0,r.jsxs)(n.p,{children:["注意这次 ",(0,r.jsx)(n.code,{children:"getStaticPaths"})," 函数的返回为",(0,r.jsx)(n.code,{children:"return { paths, fallback: 'blocking' }"}),"。它表示构建的时候就渲染 ",(0,r.jsx)(n.code,{children:"paths"})," 里的这些路径。如果请求其他的路径，那就执行服务端渲染。在上节 SSG 的例子中，我们设置 ",(0,r.jsx)(n.code,{children:"fallback"}),"为 false，它表示如果请求其他的路径，就会返回 404 错误。"]}),"\n",(0,r.jsx)(n.p,{children:"所以在这个 ISR demo 中，如果请求了尚未生成的路径，Next.js 会在第一次请求的时候就执行服务端渲染，编译出 HTML 文件，再请求时就从缓存里返回该 HTML 文件。SSG 优雅降级到 SSR。"}),"\n",(0,r.jsxs)(n.h2,{id:"5-支持混合使用",children:["5. 支持混合使用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-支持混合使用",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在写 demo 的时候，想必你已经发现了，其实每个页面你并没有专门声明使用哪种渲染模式，Next.js 是自动判断的。所以一个 Next.js 应用里支持混合使用多种渲染模式。"}),"\n",(0,r.jsxs)(n.p,{children:["当页面有 ",(0,r.jsx)(n.code,{children:"getServerSideProps"}),"的时候，Next.js 切成 SSR 模式。没有 ",(0,r.jsx)(n.code,{children:"getServerSideProps"})," 则会预渲染页面为静态的 HTML。那你可能会问，CSR 呢？就算用 CSR 模式，Next.js 也要提供一个静态的 HTML，所以还是要走预渲染这步的，只不过相比 SSG，渲染的内容少了些。"]}),"\n",(0,r.jsx)(n.p,{children:"页面可以是 SSG + CSR 的混合，由 SSG 提供初始的静态页面，提高首屏加载速度。CSR 动态填充内容，提供交互能力。举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// pages/postList.js\nimport React, { useState } from 'react'\n\nexport default function Blog({ posts }) {\n  const [data, setData] = useState(posts)\n  return (\n    <>\n      <button onClick={async () => {\n          const res = await fetch('https://jsonplaceholder.typicode.com/posts')\n          const posts = await res.json()\n          setData(posts.slice(10, 20))\n      }}>换一批</button>\n      <ul>\n        {data.map((post) => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n    </>\n  )\n}\n\nexport async function getStaticProps() {\n  const res = await fetch('https://jsonplaceholder.typicode.com/posts')\n  const posts = await res.json()\n  return {\n    props: {\n      posts: posts.slice(0, 10),\n    },\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"初始的文章列表数据就是在构建的时候写入 HTML 里的，在点击换一批按钮的时候，则是在客户端发送请求重新渲染内容。"}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"恭喜你，完成了本篇内容的学习！"}),"\n",(0,r.jsx)(n.p,{children:"这一篇我们简单回顾了 Next.js Pages Router 下的的 4 种渲染模式，但是在 App Router 下，因为改为使用 React  Server Component，所以弱化了这些概念，转而使用“服务端组件、客户端组件”等概念。那这些渲染模式跟所谓“服务端组件、客户端组件”又有什么联系和区别呢？欢迎继续学习。"}),"\n",(0,r.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/blog/next-9-5",target:"_blank",rel:"noopener noreferrer",children:"Next.js 9.5"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/deploying/static-exports",target:"_blank",rel:"noopener noreferrer",children:"Deploying: Static Exports"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering",target:"_blank",rel:"noopener noreferrer",children:"Rendering: Server-side Rendering (SSR)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation",target:"_blank",rel:"noopener noreferrer",children:"Rendering: Static Site Generation (SSG)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/pages/building-your-application/rendering/incremental-static-regeneration",target:"_blank",rel:"noopener noreferrer",children:"Rendering: Incremental Static Regeneration (ISR)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization",target:"_blank",rel:"noopener noreferrer",children:"Rendering: Automatic Static Optimization"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/pages/building-your-application/rendering/client-side-rendering",target:"_blank",rel:"noopener noreferrer",children:"Rendering: Client-side Rendering (CSR)"})}),"\n"]})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}let j=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F8.%E6%B8%B2%E6%9F%93%E7%AF%87%20_%20%E4%BB%8E%20CSR%E3%80%81SSR%E3%80%81SSG%E3%80%81ISR%20%E5%BC%80%E5%A7%8B%E8%AF%B4%E8%B5%B7.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. CSR",id:"1-csr",depth:2},{text:"1.1. 概念介绍",id:"11-概念介绍",depth:3},{text:"1.2. Next.js 实现 CSR",id:"12-nextjs-实现-csr",depth:3},{text:"2. SSR",id:"2-ssr",depth:2},{text:"2.1. 概念介绍",id:"21-概念介绍",depth:3},{text:"2.2. Next.js 实现 SSR",id:"22-nextjs-实现-ssr",depth:3},{text:"3. SSG",id:"3-ssg",depth:2},{text:"3.1. 概念介绍",id:"31-概念介绍",depth:3},{text:"3.2. Next.js 实现 SSG",id:"32-nextjs-实现-ssg",depth:3},{text:"4. ISR",id:"4-isr",depth:2},{text:"4.1. 概念介绍",id:"41-概念介绍",depth:3},{text:"4.2. Next.js 实现 ISR",id:"42-nextjs-实现-isr",depth:3},{text:"5. 支持混合使用",id:"5-支持混合使用",depth:2},{text:"小结",id:"小结",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"8.渲染篇 _ 从 CSR、SSR、SSG、ISR 开始说起",headingTitle:"8.渲染篇 _ 从 CSR、SSR、SSG、ISR 开始说起",frontmatter:{}}}}]);