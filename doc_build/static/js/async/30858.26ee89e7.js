"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["30858"],{716796:function(e,n,r){r.r(n),r.d(n,{default:()=>R});var c=r(552676),s=r(740453);let l=r.p+"static/image/d9d8e873c395c56c897bde25daae09bc.5e991a90.gif",i=r.p+"static/image/bb9bec71eca34262f372e588b0578383.57f63d4f.gif",d=r.p+"static/image/ca6defa28bc406727bcae6296ae3b9c0.25f9c5f1.gif",h=r.p+"static/image/ba1203bbcfe841719a5fc1db3214dda5.57f63d4f.gif",a=r.p+"static/image/807a291e9f90418dd24eda7f293af821.3f23960e.gif",t=r.p+"static/image/d27df9ac143e380c180507756913ef13.342f1c8f.gif",o=r.p+"static/image/e86e09dd4dab7d99d3878f76f69a7350.3f23960e.gif",x=r.p+"static/image/c09fff7fe0d79ae49f24e2a32de9eec1.7f744247.gif",p=r.p+"static/image/94cb5ebb42365f9ed65a4147d30775a8.5a6278bd.webp",j=r.p+"static/image/0065f9057aa34410bbba2e741588ed85.701df68f.gif",f=r.p+"static/image/158cb7dfcf9ca71fe5d33b668703b60a.21aad44b.webp",g=r.p+"static/image/c01a8f8b18eb76bed9ac88aaaf2b9969.e0ebfaeb.webp",b=r.p+"static/image/203da55e6c3086ce65686a42d079d762.ef1de54f.gif",m=r.p+"static/image/ec7f5f0c89c045fd5ff6834225b2f945.96392bc1.webp",u=r.p+"static/image/b75cf4064e2e6ff791c27227318e9e18.5aac1ff3.gif",y=r.p+"static/image/399c32d720ad279ea34c94f9dd99bb88.726905c4.webp",S=r.p+"static/image/d53f3cfd4782ccdf183a3dcd9681c10a.cc5c0c93.webp",G=r.p+"static/image/6ea74e538ee0c089d371639adbb328d7.d1b31a5a.webp",M=r.p+"static/image/0c59f7dededb4fda4dde8b5ab950639e.953b5a7e.webp",C=r.p+"static/image/c1ad97e585186fa06e1c898ff01be5f6.f597a959.webp",E=r.p+"static/image/a264d98dea349f7dd23cc9c34684b1bc.deee9f03.webp",A=r.p+"static/image/ebbc87adb0b531ba9ff35107fceec0e9.582e9ef6.webp",w=r.p+"static/image/162b1cff1f67a2e365aca1ae83f6f3e6.a44d6d28.webp",k=r.p+"static/image/012b008b8e8c412408b8366c34a3c8b7.e62d8941.webp",v=r.p+"static/image/e4cbc8fb3eb0884f35f8fc700a57eb73.3f596672.webp",D=r.p+"static/image/653ff24654e7b12ec7b7ab68dbc6052d.ee00b501.gif",B=r.p+"static/image/96a7b189ad3620ba2e03d2af7b34311c.57f63d4f.gif";function N(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",img:"img",blockquote:"blockquote",ul:"ul",li:"li",pre:"pre",strong:"strong"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"39-高级篇svg-滤镜的进阶之奇妙的位移滤镜",children:["39-高级篇：SVG 滤镜的进阶之奇妙的位移滤镜",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#39-高级篇svg-滤镜的进阶之奇妙的位移滤镜",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"通过之前几节课的学习，我相信你和我有着同样的感受。SVG 滤镜效果既神奇又奇特，还有许多东西需要我们继续探索。学习和使用 SVG 滤镜需要勇气，敢于进入这个充满未知和不确定性的世界。你的探索精神将不断受到意想不到效果的考验，必须学习复杂的知识和技巧。然而，一旦掌握了它，你将获得前所未有的力量——只需几行代码就能改变 Web UI 和整个应用的视觉效果。"}),"\n",(0,c.jsxs)(n.p,{children:["在这节课中，我将和大家一起探讨 SVG 滤镜中的位移滤镜，即 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜基元。我会结合理论和实际操作，用最简单的方式，通过实际案例来讲解 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜的功能和使用方法。通过这次学习，我们将掌握 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜的工作原理，以及如何使用它创建酷炫的位移效果。此外，我们还会学习一些动画滤镜的技巧，以创造出更具戏剧性的视觉效果。"]}),"\n",(0,c.jsxs)(n.h2,{id:"位移滤镜简介",children:["位移滤镜简介",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#位移滤镜简介",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在开始介绍位移滤镜（",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"}),"）之前，我们先来看两个 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜的效果："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:B,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/wvbrzOg",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/wvbrzOg"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["按钮和用户头像都是 Web 中的常见 UI，应用了位移滤镜之后的，UI 效果是不是立马显得高大上了。位移滤镜效果除了可以应用于常见的 UI 元素上之外，还可以制作一些酷炫的动画效果。例如下面这个效果，",(0,c.jsx)(n.a,{href:"https://codepen.io/yoksel/full/MLVjoB",target:"_blank",rel:"noopener noreferrer",children:"由 @yoksel 在 Codepen 上提供"}),"："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:D,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/yoksel/full/MLVjoB",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/yoksel/full/MLVjoB"})," （来源于 @yoksel ）"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["是不是很酷炫！这两个案例的效果都离不开位移滤镜 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 的功劳。那么，什么是位移滤镜呢？"]}),"\n",(0,c.jsxs)(n.p,{children:["简单地说，位移滤镜实际上是一个置换滤镜，通过改变图像的像素位置来实现诸如 ",(0,c.jsx)(n.a,{href:"https://helpx.adobe.com/photoshop-elements/using/distort-filters.html",target:"_blank",rel:"noopener noreferrer",children:"Photoshop 扭曲滤镜"}),"那样的变形、旋转或波纹等各种有趣的视觉效果。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:v,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["以 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜实现扭曲效果为例，它需要两个图像作为输入："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["实际需要被扭曲的源图像，由 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜基元的 ",(0,c.jsx)(n.code,{children:"in"})," 属性指定"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["“位移图像”，由 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜基元的 ",(0,c.jsx)(n.code,{children:"in2"})," 属性指定，它可以是噪声图像或任何其他图像。该图像的像素值决定了源图像像素的偏移量"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"例如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-HTML",children:'\x3c!-- 源图像，需要被扭曲的图像 --\x3e\n<img src="https://picsum.photos/id/823/600/600" alt="" class="filtered" />\n\n\n<svg class="sr-only">\n    <defs>\n        <filter id="filter" x="-20%" y="-20%" width="140%" height="140%" color-interpolation-filters="sRGB">\n            \x3c!-- 位移图像 --\x3e\n            <feImage href="https://picsum.photos/id/41/600/600" result="IMAGE" />\n            \x3c!-- 位移滤镜 --\x3e\n            <feDisplacementMap id="fedisplacementmap" in="SourceGraphic" in2="IMAGE" xChannelSelector="R" yChannelSelector="B" scale="50" />\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["使用 CSS 的 ",(0,c.jsx)(n.code,{children:"filter"})," 属性，将 SVG 的 ",(0,c.jsx)(n.code,{children:"<filter>"})," 定义的滤镜（",(0,c.jsx)(n.code,{children:"#filter"}),"）应用到源图像 ",(0,c.jsx)(n.code,{children:".filtered"})," 上："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:'.filtered {\n    filter: url("#filter");\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"你将在浏览器中看到，源图像被扭曲了，看上去就像一个水波形状："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:k,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/bGyogwO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/bGyogwO"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"示例中的滤镜构建如下图所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:w,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["首先，使用了 ",(0,c.jsx)(n.code,{children:"<feImage> 滤镜基元"}),"引入一张图像，这个滤镜的结果被命名为 ",(0,c.jsx)(n.code,{children:"IMAGE"})," ，它被 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜基元的 ",(0,c.jsx)(n.code,{children:"in2"})," 属性引用，用作位移图。而实际扭曲是在这里发生："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["正负的 ",(0,c.jsx)(n.code,{children:"scale"})," 属性定义了扭曲的强度。在这个示例中，设置了 ",(0,c.jsx)(n.code,{children:'scale="50"'})]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"xChannelSelector"})," 和 ",(0,c.jsx)(n.code,{children:"yChannelSelector"})," 属性用于确定输入图像的颜色通道（R、G、B 和 A）中哪一个应用该用于哪个轴进行扭曲。两个属性默认使用位移图的透明通道（",(0,c.jsx)(n.code,{children:"A"}),"），这意味着，如果你使用了没有透明通道的位移图，并且省略了这些属性（未显式设置），那么你只会看到源图像的对象线偏移。在这个示例中，设置 了",(0,c.jsx)(n.code,{children:'xChannelSelector="R"'})," 和 ",(0,c.jsx)(n.code,{children:'yChannelSelector="B"'})," ，它们会告诉浏览器，用位移图的红色通道控制水平方向位移，用蓝色通道控制垂直方向位移"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"以这种方式扭曲图像可能会很有趣，但结果是不可预测的，而且大多数情况下，视觉效果并不美观。那么，有没有办法对输出进行像素级的精确控制呢？"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://drafts.fxtf.org/filter-effects/#elementdef-fedisplacementmap",target:"_blank",rel:"noopener noreferrer",children:"SVG 规范"}),"是这么说的："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:A,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["SVG 规范：",(0,c.jsx)(n.a,{href:"https://drafts.fxtf.org/filter-effects/#elementdef-fedisplacementmap",target:"_blank",rel:"noopener noreferrer",children:"https://drafts.fxtf.org/filter-effects/#elementdef-fedisplacementmap"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["简单地说，",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜基元使用来自 ",(0,c.jsx)(n.code,{children:"in2"})," 图像（位移图）的像素值来空间上位移 ",(0,c.jsx)(n.code,{children:"in"})," 图像（源图像）。在这个位移过程中，会通过下面这个公式来执行变换："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:E,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["也就是说，",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜基元对图像进行位置映射时，会通过上面这个公式来来进行映射。这意味着，只要我们理解了这个映射公式，就能对输出进行像素级的精确控制。"]}),"\n",(0,c.jsx)(n.p,{children:"简单解释一下："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"P'(x,y)"})," 表示结果图像中一个像素的 ",(0,c.jsx)(n.code,{children:"x,y"})," 坐标"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"P(x,y)"})," 表示输入图像 ",(0,c.jsx)(n.code,{children:"in"})," （源图像）中该像素的 ",(0,c.jsx)(n.code,{children:"x,y"})," 坐标"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"XC"})," 和 ",(0,c.jsx)(n.code,{children:"YC"})," 是位移图中给定像素的归一化（",(0,c.jsx)(n.code,{children:"1 \xf7 255"}),"）RGB 颜色值，即由 ",(0,c.jsx)(n.code,{children:"xChannelSelector"})," 和 ",(0,c.jsx)(n.code,{children:"yChannelSelector"})," 指定的通道的分量值。"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"XC(x,y)"}),"表示当前 ",(0,c.jsx)(n.code,{children:"x,y"})," 坐标像素点其 ",(0,c.jsx)(n.code,{children:"X"})," 轴方向上设置的对应通道的计算值，范围是 ",(0,c.jsx)(n.code,{children:"0~1"})]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"YC(x,y)"}),"表示当前 ",(0,c.jsx)(n.code,{children:"x,y"})," 坐标像素点其 ",(0,c.jsx)(n.code,{children:"Y"})," 轴方向上设置的对应通道的计算值，范围是 ",(0,c.jsx)(n.code,{children:"0~1"})]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"x + scale \xd7 (XC(x,y) - 0.5), y + scale \xd7 (YC(x,y) - 0.5)"})," 指的是具体的转换规则"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"-0.5"})," 是偏移值，因此",(0,c.jsx)(n.code,{children:"XC(x,y) - 0.5"})," 范围是 ",(0,c.jsx)(n.code,{children:"-0.5~0.5"}),"，",(0,c.jsx)(n.code,{children:"YC(x,y) - 0.5"})," 范围也是 ",(0,c.jsx)(n.code,{children:"-0.5~0.5"})]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"scale"})," 表示计算后的偏移值相乘的比例，",(0,c.jsx)(n.code,{children:"scale"})," 越大，则偏移越大"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["最后，操作结果必须取反（基本上就是公式中的每个 ",(0,c.jsx)(n.code,{children:"+"})," 号都需要替换成 ",(0,c.jsx)(n.code,{children:"-"})," 号），即每个加法都变成减法，那么公式将变成："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:C,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这样做的目的是为了反向应用位移效果，使得每个像素的位置变成其原始位置的相反方向上的相应位置。这通常是在处理特定图像效果时所需要的。"}),"\n",(0,c.jsx)(n.p,{children:"接下来，我们将通过一些简单的小实验，通过将原始位移图输入到滤镜中来验证上面这个公式。注意，这些原始位移图只包含一种颜色。例如："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="filter" x="-20%" y="-20%" width="140%" height="140%" color-interpolation-filters="sRGB">\n            <feImage href="https://assets.codepen.io/100347/fedm_rgb515151.png" result="IMAGE" width="600" height="600" />\n            <feDisplacementMap id="fedisplacementmap" in="SourceGraphic" in2="IMAGE" xChannelSelector="R" yChannelSelector="B" scale="100" />\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["上位代码中 ",(0,c.jsx)(n.code,{children:"<feImage>"})," 引入的位移图是具有 ",(0,c.jsx)(n.code,{children:"rgb(51 51 51)"})," 的纯色图像，当 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜的 ",(0,c.jsx)(n.code,{children:"scale"})," 值为 ",(0,c.jsx)(n.code,{children:"100"})," 时，如何预期源图像在 ",(0,c.jsx)(n.code,{children:"x = 100"})," 和 ",(0,c.jsx)(n.code,{children:"y=100"})," 处的像素坐标会被转换？"]}),"\n",(0,c.jsxs)(n.p,{children:["我们把 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜基元中的相关参数值套入上面公式进行计算："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"scale = 100\nx = 100\ny = 100\nXC = 51 \xf7 255\nYC = 51 \xf7 255\n\nX = x - scale \xd7 （XC - 0.5） = 100 - 100 \xd7 (51 \xf7 255 - 0.5) = 130\nY = y - scale \xd7 （YC - 0.5） = 100 - 100 \xd7 (51 \xf7 255 - 0.5) = 130\n"})}),"\n",(0,c.jsxs)(n.p,{children:["结果就是 ",(0,c.jsx)(n.code,{children:"P'(x,y) = P'(130,130)"})," ，即结果像素被移动到 ",(0,c.jsx)(n.code,{children:"(130,130)"})," 坐标点。这意味着它将向右移动 ",(0,c.jsx)(n.code,{children:"30px"})," ，并向下移动 ",(0,c.jsx)(n.code,{children:"30px"})," ："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:M,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/WNBZpjx",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/WNBZpjx"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["现在，我们将 ",(0,c.jsx)(n.code,{children:"<feImage>"})," 引入的位移图调整 ",(0,c.jsx)(n.code,{children:"rgb(127 127 127)"})," 纯色图像（大概是 ",(0,c.jsx)(n.code,{children:"50%"})," 的灰色）。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="filter" x="-20%" y="-20%" width="140%" height="140%" color-interpolation-filters="sRGB">\n            <feImage href="https://assets.codepen.io/100347/fedm_grey.png" result="IMAGE" width="600" height="600" />\n            <feDisplacementMap id="fedisplacementmap" in="SourceGraphic" in2="IMAGE" xChannelSelector="R" yChannelSelector="B" scale="100" />\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,c.jsx)(n.p,{children:"和之前一样，将相关参数套入公式进行计算："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"scale = 100\nx = 100\ny = 100\nXC = 127 \xf7 255\nYC = 127 \xf7 255\n\nX = x - scale \xd7 （XC - 0.5） = 100 - 100 \xd7 (127 \xf7 255 - 0.5) = 100.196 ≈ 100\nY = y - scale \xd7 （YC - 0.5） = 100 - 100 \xd7 (127 \xf7 255 - 0.5) = 100.196 ≈ 100\n"})}),"\n",(0,c.jsxs)(n.p,{children:["很显然，中性色（",(0,c.jsx)(n.code,{children:"rgb(127 127 127)"}),"）对图像不会产生明显的变化。肉眼之下，目标结果像素将保持不变："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:G,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/WNBZjZz",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/WNBZjZz"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["请继续，这次我们把 ",(0,c.jsx)(n.code,{children:"<feImage>"})," 引入的图像调得更亮一些，例如 ",(0,c.jsx)(n.code,{children:"rgb(204 204 204)"})," ，颜色通道的值大于 ",(0,c.jsx)(n.code,{children:"127"})," ："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="filter" x="-20%" y="-20%" width="140%" height="140%" color-interpolation-filters="sRGB">\n            <feImage href="https://assets.codepen.io/100347/fedm_rgb204204204.png" result="IMAGE" width="600" height="600" />\n            <feDisplacementMap id="fedisplacementmap" in="SourceGraphic" in2="IMAGE" xChannelSelector="R" yChannelSelector="B" scale="100" />\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,c.jsx)(n.p,{children:"同样根据公式计算出最终值："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"scale = 100\nx = 100\ny = 100\nXC = 204 \xf7 255\nYC = 204 \xf7 255\n\nX = x - scale \xd7 （XC - 0.5） = 100 - 100 \xd7 (204 \xf7 255 - 0.5) = 70\nY = y - scale \xd7 （YC - 0.5） = 100 - 100 \xd7 (204 \xf7 255 - 0.5) = 70\n"})}),"\n",(0,c.jsxs)(n.p,{children:["最终坐标 ",(0,c.jsx)(n.code,{children:"P'(70,70)"})," 与初始坐标 ",(0,c.jsx)(n.code,{children:"P(100,100)"})," 相比，很明显它会向左移动 ",(0,c.jsx)(n.code,{children:"30px"})," ，并向上移动 ",(0,c.jsx)(n.code,{children:"30px"})," ："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:S,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/NWVajOz",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/NWVajOz"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"通过这三个简单的小实验（示例），我们可以得到一个初浅的结论："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["任何大于 ",(0,c.jsx)(n.code,{children:"127"})," 的颜色值都会将相应像素向缩放值（",(0,c.jsx)(n.code,{children:"scale"}),"）的方向移动"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["任何小于 ",(0,c.jsx)(n.code,{children:"127"})," 的颜色值都会将相应像素向缩放值（",(0,c.jsx)(n.code,{children:"scale"}),"）相反的方向移动"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["颜色值为 ",(0,c.jsx)(n.code,{children:"127"})," 图像像素几乎不会有任何移动"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["凭直觉，大家可能会认为黑色不会有任何效果，但现在应该很清楚，事实并非如此。实际上，黑色和白色将导致最大可能的向缩放值（",(0,c.jsx)(n.code,{children:"scale"}),"）方向或相反方向的移动。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:y,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/abrLwzN",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/abrLwzN"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["正如你所看到，纯黑色位移图使图像向右并向下移动移动 ",(0,c.jsx)(n.code,{children:"50px"})," ，而白色位移图使图像向左并向上移动 ",(0,c.jsx)(n.code,{children:"50px"})," 。"]}),"\n",(0,c.jsxs)(n.p,{children:["上面我们展示的都是纯色的位移图对源图像颜色像素位置的影响。接下来，我们再来看一个示例，进一步加深大家对 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜的 ",(0,c.jsx)(n.code,{children:"xChannelSelector"}),"，",(0,c.jsx)(n.code,{children:"yChannelSelector"})," 和 ",(0,c.jsx)(n.code,{children:"scale"})," 属性的理解。"]}),"\n",(0,c.jsx)(n.p,{children:"我们把前面的纯色位移图换成像下面这样的一张图："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,UklGRsYBAABXRUJQVlA4ILoBAACwGwCdASoAAQABPp1EnUolo6KhsBKIALATiWlu4XUjynU8A+wH4AdAr/U3+6/8/LP+6+80N+CfwD8AP3//gDUAABRxEpmhjYbhG4WiT360pGQZ1/smZdCaF+5EXa+9NfZK0pmlx7J9NfTmcXxEpGQZBN/N6JTNL8lVMLqAvaX7kmkcuZl4hhSmaX7dewRuEbov3JNOcLHGvpsMzQv3Ii7X3pr7JWlM0uPZPpr6czi+IlIyDIJv5vRKZpfkqphdQF7S/ck0jlzMvEMKUzS/br2CNwjdF+5JpzhY413tT8pH74ytqHQKAAD+/d3p/qffwXf//jePAryXY6xxCHaW9/sprdZh+UPT+UPT+UPT+UPT+UPT+UPT+SCOS4FjlG6IFSagaUS8PKrMqqTY0M6Y9fmryDS6x5Shs7rHlVl31w46fjp5gacjwpsFqBnsVxXWF9hv8dPxzhspYlM6dyc6DYOmPVOik6Y9f4Dl4eVWZVU+w3+On45w2UsUFofeY0sAAOVXz7Un3iqvc31n0uvP/fIFf1MXjxv79Xk7AL6aIKs9GTAGac92jYf//493t7FXqXfWfX77+TsNgAAA",alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["左半边是 ",(0,c.jsx)(n.code,{children:"rgb(255 127 127)"})," ，该颜色的 R 通道的计算值是 ",(0,c.jsx)(n.code,{children:"1"})," ，G 和 B 通道的计算值是 ",(0,c.jsx)(n.code,{children:"0.5"})," ；右半边则是完全透明 ",(0,c.jsx)(n.code,{children:" rgb(255 255 255  ``/ 0``)"})," 。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="filter" x="-20%" y="-20%" width="140%" height="140%" color-interpolation-filters="sRGB">\n              <feImage href="data:image/png;base64,..." result="IMAGE" width="600" height="600" />\n              <feDisplacementMap id="fedisplacementmap" in="SourceGraphic" in2="IMAGE" xChannelSelector="R" yChannelSelector="G" scale="100" />\n              <feComposite in="SourceGraphic" operator="in" in2="IMAGE"  />\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["尝试着调整 ",(0,c.jsx)(n.code,{children:"scale"})," 的值，你看到的效果如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/GRaMEPP",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/GRaMEPP"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["并不难发现，应用滤镜的图片只是单纯的沿着水平方向（",(0,c.jsx)(n.code,{children:"x"})," 轴）移动。为什么呢？"]}),"\n",(0,c.jsxs)(n.p,{children:["这是因为",(0,c.jsx)(n.code,{children:'xChannelSelector="R"'}),"，",(0,c.jsx)(n.code,{children:'yChannelSelector="G"'}),"，水平方向基于图像颜色的 R 通道进行位移，垂直方向基于图像颜色的 G 通道进行位移。我们应用的位移图颜色（",(0,c.jsx)(n.code,{children:"rgb(255 127 127)"}),"），其 R 通道的计算值是 ",(0,c.jsx)(n.code,{children:"1"})," ，G 通道的计算值是 ",(0,c.jsx)(n.code,{children:"0.5"})," 。套用公式："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"XC(x,y) = 1\nYC(x,y) = 0.5\n\nP′(x,y) ← P(x + scale \xd7 (XC(x,y) − 0.5),y + scale \xd7 (YC(x,y) − 0.5))\nP′(x,y) ← P(x + scale \xd7 (1 − 0.5),y + scale \xd7 (0.5 − 0.5))\nP′(x,y) ← P(x + scale \xd7 0.5,y + 0)\nP′(x,y) ← P(x + scale \xd7 0.5,y)\n"})}),"\n",(0,c.jsxs)(n.p,{children:["最终结果的坐标是 ",(0,c.jsx)(n.code,{children:"P(x + scale \xd7 0.5,y)"})," 。因此，调整 ",(0,c.jsx)(n.code,{children:"scale"})," 的值，最终坐标只是 ",(0,c.jsx)(n.code,{children:"x"})," 轴的值在变化。所以，你看到的图片只在水平方向发生了移动。"]}),"\n",(0,c.jsx)(n.p,{children:"我想，通过这些简单的小实验，你对位移滤镜有所了解了。但问题是，到目前为止，还是不知道如何使用位移滤镜实现扭曲和水波纹等有趣的视觉效果。"}),"\n",(0,c.jsxs)(n.p,{children:["在具体讲解如何制作水波纹 UI 效果之前，有一个概念需要与大家一起探讨——",(0,c.jsx)(n.strong,{children:"绝对图像映射"}),"！这对于位移滤镜而言，是一个非常重要的东西，因为它是所有后续效果的基础。这意味着，只有了解和掌握了这个概念，才能使用位移滤镜制作引人注目的 UI 效果。"]}),"\n",(0,c.jsxs)(n.h2,{id:"绝对图像映射",children:["绝对图像映射",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#绝对图像映射",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"绝对图像映射（Absolute Map）又称为恒等图像映射（Identity Map）。它既是一张特殊图像，将成为我们接下来所见所有效果的基础。这种映射执行一个非常简单的扭曲操作：按比例缩放图像。通过这种映射，我们可以实现多种视觉效果，并且它非常容易理解和应用。"}),"\n",(0,c.jsx)(n.p,{children:"为了在所有方向上等比缩放图像，颜色值必须从一边的最大值逐渐减少到对边的最小值。例如："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"x"})," 轴使用红色，那么它的颜色值应该从最大值 ",(0,c.jsx)(n.code,{children:"rgb(255 0 0)"})," （左侧）逐渐减少到最小值 ",(0,c.jsx)(n.code,{children:" rgb(255 0 0  ``/ 0``)"})," （右侧）"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"y"})," 轴使用蓝色，那么它的颜色值也应该从最大值 ",(0,c.jsx)(n.code,{children:"rgb(0 0 255)"})," （顶部）逐渐减少到最小值 ",(0,c.jsx)(n.code,{children:" rgb(0 0 255  ``/ 0``)"})," （底部）"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"这张利用红色和蓝色通道制作的绝对映射图，看起来大致像下图这样："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["正如你所看到的，上图将使用红色表示 ",(0,c.jsx)(n.code,{children:"x"})," 轴（水平方向），蓝色表示 ",(0,c.jsx)(n.code,{children:"y"})," 轴（垂直方向）。但最终 ",(0,c.jsx)(n.code,{children:"xChannelSelector"})," 和 ",(0,c.jsx)(n.code,{children:"yChannelSelector"})," 选择哪种颜色都无关紧要。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/LYozOEb",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/LYozOEb"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"通常这个绝对映射图可以按照下面几个步骤来制作："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["注意，上图中第一矩形填充了一个从左（",(0,c.jsx)(n.code,{children:"rgb(255 0 0)"}),"）到右（",(0,c.jsx)(n.code,{children:" rgb(255 0 0  ``/ 0``)"}),"）的线性渐变；第二个矩形填充了一个从上（",(0,c.jsx)(n.code,{children:"rgb(0 0 255)"}),"）到下（",(0,c.jsx)(n.code,{children:" rgb(0 0 255  ``/ 0``)"}),"）的线性渐变，并将该矩形（它的图层）的混合模式设置为 ",(0,c.jsx)(n.code,{children:"screen"})," 。请记住这个制作过程，稍后在 SVG 中制作绝对映射图像步骤与在 Figma 中制作步骤相同。"]}),"\n",(0,c.jsx)(n.p,{children:"从 Figma 导出这个图形，这样你就创建了一个绝对映射图像！这个图像将作为各种图像扭曲的基础。换句话说，你可以在这个图像上制作图其他的位移图像："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"看到上图，你是否产生了新的疑惑，“绝对”图像映射难道不是唯一的？不是的，这里所说的绝对图像映射并不指唯一性，而是指一种特定的图像变换技术，用于对图像进行比例缩放。这个技术确保每个像素点都按比例进行移动，但图像的整体形状和相对位置保持不变。你可以将其理解为一种怛等变换，即不引入复杂的扭曲或变形。"}),"\n",(0,c.jsxs)(n.p,{children:["为了更好地理解这个过程，我写了一个小示例，给 ",(0,c.jsx)(n.code,{children:"<feImage>"})," 滤镜基元提供了多种不同的位移图像。而且这些位移图像并不都是红蓝渐变或扭曲的，还提供了黑白渐变以及其他形状。请尝试选择下面 Demo 中的位移图像，查看 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜对源图像产生的效果："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Dem 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/RwmLxyX",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/RwmLxyX"})]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"svg-位移图映射",children:["SVG 位移图映射",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#svg-位移图映射",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["上面案例所展示的位移图（",(0,c.jsx)(n.code,{children:"<feImage>"})," 引用的图片）基本上都是传统的位图格式，例如 PNG 和 JPG 等。其实，我们还可以直接使用 SVG 创建位移图。"]}),"\n",(0,c.jsx)(n.p,{children:"使用 SVG 创建位移图与之前在 Figma 中创建位移图步骤是相似的："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["1️⃣：使用 ",(0,c.jsx)(n.code,{children:"<rect>"})," 创建两个矩形"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["2️⃣：使用 ",(0,c.jsx)(n.code,{children:"<linearGradient>"})," 创建两个线性渐变，其中一个水平渐变，从 ",(0,c.jsx)(n.code,{children:"rgb(255 0 0 )"})," 到 ",(0,c.jsx)(n.code,{children:" rgb(255 0 0  ``/ 0``)"})," ，另一个中垂直渐变，从 ",(0,c.jsx)(n.code,{children:"rgb(0 0 255)"})," 到 ",(0,c.jsx)(n.code,{children:" rgb(0 0 255  ``/ 0``)"})," 。将它们应用到 ",(0,c.jsx)(n.code,{children:"<rect>"})," 创建的矩形元素上"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:["3️⃣：在第二个矩形上应用 CSS 的 ",(0,c.jsx)(n.code,{children:"mix-blend-mode: screen"})," ，将它们合并"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"上面步骤对应的 SVG 代码如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-XML",children:'<svg viewBox="0 0 512 512" width="512" height="512">\n    <defs>\n        \x3c!-- 创建水平渐变：rgb(255 0 0) \uD83D\uDC49 rgb(255 0 0 / 0) --\x3e\n        <linearGradient id="red-gradient" x1="0%" y1="0%" x2="100%" y2="0%">\n            <stop offset="0%" stop-color="rgb(255 0 0)" />\n            <stop offset="100%" stop-color="rgb(255 0 0 / 0)" />\n        </linearGradient>\n        \x3c!-- 创建垂直渐变： rgb(0 0 255) \uD83D\uDC49 rgb(0 0 255 / 0) --\x3e\n        <linearGradient id="blue-gradient" x1="0%" y1="0%" x2="0%" y2="100%">\n            <stop offset="0%" stop-color="rgb(0 0 255)" />\n            <stop offset="100%" stop-color="rgb(0 0 255 / 0)" />\n        </linearGradient>\n        \n        <symbol id="image" viewBox="0 0 512 512">\n            <g>\n                <rect id="black-rect" x="0" y="0" width="100%" height="100%" fill="#000" class="black" />\n                <rect id="red-rect" x="0" y="0" width="100%" height="100%" fill="url(#red-gradient)" class="rect--red" />\n                <rect id="blue-rect" x="0" y="0" width="100%" height="100%" fill="url(#blue-gradient)" class="rect--blue" style="mix-blend-mode: screen;"/>\n            </g>\n        </symbol>\n    </defs>\n    \n</svg>\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/ZENXmJY",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/ZENXmJY"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"SVG 位移图准备好了，但是将其应用到滤镜中效果，并不如你所期望的那样："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-XML",children:'<svg viewBox="0 0 512 512" width="512" height="512">\n    <defs>\n        \x3c!-- 创建水平渐变：rgb(255 0 0) \uD83D\uDC49 rgb(255 0 0 / 0) --\x3e\n        <linearGradient id="red-gradient" x1="0%" y1="0%" x2="100%" y2="0%">\n            <stop offset="0%" stop-color="rgb(255 0 0)" />\n            <stop offset="100%" stop-color="rgb(255 0 0 / 0)" />\n        </linearGradient>\n        \x3c!-- 创建垂直渐变： rgb(0 0 255) \uD83D\uDC49 rgb(0 0 255 / 0) --\x3e\n        <linearGradient id="blue-gradient" x1="0%" y1="0%" x2="0%" y2="100%">\n            <stop offset="0%" stop-color="rgb(0 0 255)" />\n            <stop offset="100%" stop-color="rgb(0 0 255 / 0)" />\n        </linearGradient>\n    \n        <symbol id="image" viewBox="0 0 512 512">\n            <g>\n                <rect id="black-rect" x="0" y="0" width="512" height="512" fill="#000" class="black" />\n                <rect id="red-rect" x="0" y="0" width="512" height="512" fill="url(#red-gradient)" class="rect--red" />\n                <rect id="blue-rect" x="0" y="0" width="512" height="512" fill="url(#blue-gradient)" class="rect--blue" style="mix-blend-mode: screen;" />\n            </g>\n        </symbol>\n        <filter id="filter" color-interpolation-filters="sRGB">\n            <feImage href="#image" result="IMAGE__10" />\n            <feDisplacementMap in="SourceGraphic" in2="IMAGE__10" xChannelSelector="R" yChannelSelector="B" scale="100" result="DISPLACEMENT__MAP__10" />\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-JavaScript",children:'const feImage = document.querySelector("feImage");\nconst url = feImage.getAttribute("href");\n\nfetch(url)\n    .then((response) => {\n        return response.text();\n    })\n    .then((svgText) => {\n        const uri = encodeURIComponent(svgText);\n        feImage.setAttribute("href", `data:image/svg+xml;charset=utf-8,${uri}`);\n    })\n    .catch((error) => {\n        feImage.setAttribute("href", someFallbackURI);\n    });\n'})}),"\n",(0,c.jsx)(n.p,{children:"非常遗憾的是，到写这节课内容的时候，也仅能在 Safari 浏览器中看到效果："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/JjqreNE",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/JjqreNE"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"因此，针对 SVG 位移图映射，我们就不展开阐述了！"}),"\n",(0,c.jsxs)(n.p,{children:["其实，除了使用位图和 SVG 图形制作位移图之外，还可以使用 SVG 的滤镜来制作，例如 ",(0,c.jsx)(n.code,{children:"<feTurbulence>"})," 滤镜。就我个人而言，我更倾向于使用其他滤镜来制作的位移图。接下来的示例，主要会围绕着其他滤镜制作位移图展开。"]}),"\n",(0,c.jsxs)(n.h2,{id:"案例一故障效果",children:["案例一：故障效果",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#案例一故障效果",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7341630791099383835/section/7368318225756454962#heading-6",target:"_blank",rel:"noopener noreferrer",children:"通过上一节课的学习"}),"，我们知道如何使用 ",(0,c.jsx)(n.code,{children:"<feComponentTransfer>"})," 和 ",(0,c.jsx)(n.code,{children:"<feColorMatrix>"})," 等滤镜制作故障图效果。在这里，我们来看看，位移滤镜 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 是如何基于其他 SVG 滤镜来制作一个像下面这样的文本故障效果："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/pen/yLWzGPb",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/pen/yLWzGPb"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"这是一个简单的文本故障效果，直接上代码："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="filter" color-interpolation-filters="sRGB" >\n            <feFlood flood-color="rgb(128 0 128)" result="BASE-COLOR" />\n            <feFlood flood-color="rgb(255 0 128)" result="X-TRANSFORM">\n                <animate attributeName="y" values="0; 150; 40; 110; 0" dur="2.5s" repeatCount="indefinite" begin="0" />\n                <animate attributeName="height" values="10; 30; 15; 40; 10;" dur="4s" repeatCount="indefinite" begin="0" />\n            </feFlood>\n            <feMerge result="MERGE">\n                <feMergeNode in="BASE-COLOR" />\n                <feMergeNode in="X-TRANSFORM" />\n            </feMerge>\n            <feDisplacementMap in="SourceGraphic" in2="MERGE" scale="8" xChannelSelector="R" yChannelSelector="B">\n                <animate attributeName="scale" values="-8; 5.5; 0; 8; 4.5; 7; -4; -9; 5; -5.5; 19; -8" dur="6s" repeatCount="indefinite" begin="0" />\n            </feDisplacementMap>\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,c.jsx)(n.p,{children:"简单解释一下上面的代码。"}),"\n",(0,c.jsxs)(n.p,{children:["首先使用了 ",(0,c.jsx)(n.code,{children:"<feFlood>"})," 滤镜基元，甚至源图像（",(0,c.jsx)(n.code,{children:"SourceGraphic"}),"）创建了两个填充效果，其中第一个填充的颜色是 ",(0,c.jsx)(n.code,{children:"rgb(128 0 128)"})," ，第二个填充的颜色是 ",(0,c.jsx)(n.code,{children:"rgb(255 0 128)"})," 。同时使用 ",(0,c.jsx)(n.code,{children:"<animate>"})," 元素动态化改变第二个 ",(0,c.jsx)(n.code,{children:"<feFlood>"})," 填充物的 ",(0,c.jsx)(n.code,{children:"y"})," 和 ",(0,c.jsx)(n.code,{children:"height"})," 值。"]}),"\n",(0,c.jsxs)(n.p,{children:["接着使用 ",(0,c.jsx)(n.code,{children:"<feMerge>"})," 将前面定义的两个填充物合并在一起，并且命名为 ",(0,c.jsx)(n.code,{children:"MERGE"})," 。这相当于使用 ",(0,c.jsx)(n.code,{children:"<feFlood>"})," 和 ",(0,c.jsx)(n.code,{children:"<feMerge>"})," 创建了一个动画化的位移图像。它看起来像下面这样："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["最后，将 ",(0,c.jsx)(n.code,{children:"MERGE"})," 作为位移图像，被 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜引用，从而产生扭曲效果。其中 ",(0,c.jsx)(n.code,{children:"scale"})," 属性指定了位移的程度，",(0,c.jsx)(n.code,{children:"xChannelSelector"})," 和 ",(0,c.jsx)(n.code,{children:"yChannelSelector"})," 属性分别指定了 ",(0,c.jsx)(n.code,{children:"X"})," 和 ",(0,c.jsx)(n.code,{children:"Y"})," 通道的颜色值的选择方式。同时，使用 ",(0,c.jsx)(n.code,{children:"<animate>"})," 元素为位移映射效果添加了动画效果，改变了 ",(0,c.jsx)(n.code,{children:"scale"})," 属性的值。最终使实现了一个文本障碍的效果。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/pen/yLWzGPb",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/pen/yLWzGPb"})]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"案例二给按钮添加云雾效果",children:["案例二：给按钮添加云雾效果",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#案例二给按钮添加云雾效果",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在课程开始的时候，向大家展示了一个按钮和用户头像悬浮的动画效果。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/wvbrzOg",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/wvbrzOg"})]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"这是一个 CSS 和 SVG 滤镜相互结合产生的一个交互动画效果。我们以上图中的按钮效果为例："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-HTML",children:'<button class="button">Hover Me</button>\n'})}),"\n",(0,c.jsx)(n.p,{children:"按钮基本样式就不在这里展示了，但按钮悬浮状态的云雾效果相关的 CSS 代码还是有必要贴一下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-CSS",children:'.button {\n    --height: 100px;\n    --width: 200px;\n    width: calc(0.8 * var(--width));\n    height: calc(0.7 * var(--height));\n    transition: all 0.3s cubic-bezier(0, 0.22, 0.3, 1);\n    transform: translateZ(0);\n    overflow: hidden;\n\n    &::after {\n        content: "";\n        position: absolute;\n        width: 0;\n        height: 0;\n        filter: url(#filter);\n        border-radius: 50%;\n        z-index: -1;\n        transition: all 1.5s cubic-bezier(0.1, 0.22, 0.3, 1);\n    }\n    \n    &:hover::after {\n        width: calc(2 * var(--width));\n        height: calc(2 * var(--height));\n    }\n\n    &:nth-child(1):hover::after {\n        left: -50%;\n        top: -50%;\n        background: #27ae60;\n    }\n\n    &:nth-child(2):hover::after {\n          right: -50%;\n          top: -50%;\n          background: #c0392b;\n    }\n\n    &:nth-child(3):hover::after {\n          left: -50%;\n          bottom: -50%;\n          background: #34495e;\n    }\n \n    &:nth-child(4):hover::after {\n          right: -50%;\n          bottom: -50%;\n          background: #2980b9;\n    }\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["注意，我们使用 CSS 伪元素 ",(0,c.jsx)(n.code,{children:"::after"})," 添加了一个层，这个层应用了 ",(0,c.jsx)(n.code,{children:"#filter"})," 滤镜，这个滤镜的主要效果是由 ",(0,c.jsx)(n.code,{children:"<feTurbulence>"})," 和 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜制作， 根据 ",(0,c.jsx)(n.code,{children:"<feTurbulence>"})," 生成的噪声图像对源图形进行位移，产生扭曲效果。使 ",(0,c.jsx)(n.code,{children:"::after"})," 在视觉上具有一种类似波纹、水波或云雾等效果。具体代码如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="filter"  color-interpolation-filters="sRGB">\n            <feTurbulence type="fractalNoise" baseFrequency=".01" numOctaves="6" in="SourceGraphic" result="TURBULENCE"/>\n            <feDisplacementMap in="SourceGraphic" in2="TURBULENCE" result="DISPLACEMENT_MAP" scale="100" />\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["其中 ",(0,c.jsx)(n.code,{children:"<feTurbulence>"})," 生成一个具彩色效果的纹理图，它还没有应用到 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜上时，按钮悬浮状态的效果如下："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"像不像七彩云朵的效果。"}),"\n",(0,c.jsxs)(n.p,{children:["注意，在我们这个示例中，",(0,c.jsx)(n.code,{children:"<feTurbulence>"})," 生成的彩色纹理图只是作为位移图像，",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 根据位移图像对伪元素 ",(0,c.jsx)(n.code,{children:"::after"})," 自身（源图形）进行位移，产生扭曲效果。再结合 CSS 位置的变化，从而实现我们所需要的按钮效果："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/wvbrzOg",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/wvbrzOg"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["在这个基础上，我们可以演变出其他扭曲效果。例如，下面这个示例，我们分别给 ",(0,c.jsx)(n.code,{children:"<feTurbulence>"})," 滤镜的 ",(0,c.jsx)(n.code,{children:"baseFrequency"})," 和 ",(0,c.jsx)(n.code,{children:"numOctaves"})," 以及 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜的 ",(0,c.jsx)(n.code,{children:"xChannelSelector"})," 、 ",(0,c.jsx)(n.code,{children:"yChannelSelector"})," 和 ",(0,c.jsx)(n.code,{children:"scale"})," 等属性的值提供调节器，你可以通过调整相关的参数查看最终的效果："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["Demo 地址：",(0,c.jsx)(n.a,{href:"https://codepen.io/airen/full/GRaMzwE",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/GRaMzwE"})]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"小结",children:["小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"有关于位移滤镜我们就介绍到这里了。简单回顾一下这节课的内容。"}),"\n",(0,c.jsxs)(n.p,{children:["在这节课中，我们主要探讨了 SVG 滤镜中 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 滤镜基元。首先，介绍了位移滤镜的基本原理，即通过位移图像的像素值移动源图像的像素，产生扭曲效果。然后，详细讲解了如何定义和应用滤镜，包括使用 ",(0,c.jsx)(n.code,{children:"<feTurbulence>"})," 生成噪声图像，并将其与 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 结合来实现位移效果。"]}),"\n",(0,c.jsxs)(n.p,{children:["小册后续的课程中还会继续应用到位移滤镜 ",(0,c.jsx)(n.code,{children:"<feDisplacementMap>"})," 相关特性。你将在后续的课程中进一步的了解该滤镜，并通过与其他滤镜相结合，创作出更多有趣的 UI 视觉效果！"]})]})}function I(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(N,{...e})}):N(e)}let R=I;I.__RSPRESS_PAGE_META={},I.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20SVG%2F39-%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%9ASVG%20%E6%BB%A4%E9%95%9C%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%A5%87%E5%A6%99%E7%9A%84%E4%BD%8D%E7%A7%BB%E6%BB%A4%E9%95%9C.md"]={toc:[{text:"位移滤镜简介",id:"位移滤镜简介",depth:2},{text:"绝对图像映射",id:"绝对图像映射",depth:2},{text:"SVG 位移图映射",id:"svg-位移图映射",depth:2},{text:"案例一：故障效果",id:"案例一故障效果",depth:2},{text:"案例二：给按钮添加云雾效果",id:"案例二给按钮添加云雾效果",depth:2},{text:"小结",id:"小结",depth:2}],title:"39-高级篇：SVG 滤镜的进阶之奇妙的位移滤镜",headingTitle:"39-高级篇：SVG 滤镜的进阶之奇妙的位移滤镜",frontmatter:{}}}}]);