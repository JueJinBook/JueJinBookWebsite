"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["17769"],{339874:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var i=r(552676),s=r(740453);let c=r.p+"static/image/09dc6671d94ef0e1a5b98838755958f2.1e4fa436.webp",l=r.p+"static/image/e3c6c61ba53b38e4d656ffc53a3a191e.5b9063bc.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",strong:"strong",pre:"pre",h2:"h2",img:"img",blockquote:"blockquote",ol:"ol",li:"li"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"3-基础篇如何合理地判断变量的类型",children:["3 基础篇｜如何合理地判断变量的类型？",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-基础篇如何合理地判断变量的类型",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["作为动态语言，JavaScript 在变量声明时无需指定类型，因此你可以编写非常灵活的代码。但“不需要”不代表“没有”，在使用时肯定免不了要判断变量的类型，比如实现一个加法函数 ",(0,i.jsx)(n.code,{children:"add(a, b)"}),"，变量是数字还是字符串，显然最后的结果就很不一样。更多的时候我们要做的是对输入数据的合法性校验，不合法直接抛出错误。"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"类型判断"}),"在面试活动中，很可能影响到面试官对你表现的判断，比如一些题目的边界问题、健壮性问题等加分项；在日常开发中，影响到的是你编写业务代码的质量，最终体现的是你的 Bug 数量，甚至是领导对你能力高低的判断。"]}),"\n",(0,i.jsx)(n.p,{children:"大家可能觉得危言耸听，既然如此，是不是用 TypeScript 就变成强类型语言了呢？"}),"\n",(0,i.jsxs)(n.p,{children:["这显然是一个误解。没错，TypeScript 是带有类型系统，其实不仅仅 TypeScript，Facebook 也有一个更早实现的类型注解系统：",(0,i.jsx)(n.a,{href:"https://flow.org/",target:"_blank",rel:"noopener noreferrer",children:"flow"}),"，用在 React 项目中。无论哪一个，都没有把 JavaScript 变成强类型语言，它们只是对变量做一个约束，提醒你应该处理哪些种类型，比如 TypeScript 中的一个变量，依然可以声明成多类型混合的："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"let foo: string | number;\n"})}),"\n",(0,i.jsx)(n.p,{children:"在运行时仍然需要判断它是 string 还是 number 的，如果是 string，那么就可以调用 concat 方法；如果是 number，就可以调用 toFixed 方法。"}),"\n",(0,i.jsxs)(n.p,{children:["本章我们就来探讨 JavaScript 中如何判断变量的类型，大家一定先想到了 ",(0,i.jsx)(n.code,{children:"typeof"}),"，不过不要着急，我们先来明确一共有哪些类型需要判断，然后再去看 typeof 是不是我们期望的判断方法。"]}),"\n",(0,i.jsxs)(n.h2,{id:"ecma262-中的类型",children:["ECMA262 中的类型",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ecma262-中的类型",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["到 ES2023 为止，规范一共定义了 7 种变量类型：",(0,i.jsx)(n.strong,{children:"Undefined、Null、Boolean、String、Symbol、Numeric 和 Object"}),"。除了 Object 之外，其他都称为 ",(0,i.jsx)(n.code,{children:"Primitive"})," 类型。"]}),"\n",(0,i.jsx)(n.p,{children:'怎么理解 Primitive 呢？简单来说就是可以用字面量一眼能看出其值的，比如 null、undefined、100、"中国"、false。虽然 Object 有的可以用 JSON 结构来表示，但是稍微复杂一点，比如函数、原型链、循环引用等这些特性是无法表述的。另一种理解 Primitive 的方式是值与引用。在作为函数参数传递时，Primitive 变量都是通过拷贝的方式传递的，修改一处，另一处不会被影响；而 Object 类型是传递引用的，一处修改，全局可见。'}),"\n",(0,i.jsxs)(n.p,{children:["Numeric 又可以向下划分成 ",(0,i.jsx)(n.code,{children:"Number"})," 和 ",(0,i.jsx)(n.code,{children:"BigInt"}),"，所以我们也可以说 ECMA262 定义了 8 种类型，如下图所示："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"这可能和大家的印象中的认知有冲突，一定有人会问：“我经常要判断的函数 Function 不是一种类型吗？”"}),"\n",(0,i.jsx)(n.p,{children:"答案是，ECMA262 规范中的函数确实不是独立的类型，而是一类特殊的 Object，能执行（execute）。不但函数不是一种独立类型，我们经常使用的数组 Array、日期 Date、参数 Arguments、正则 RegExp 等都不是，它们通通都只是 Object。"}),"\n",(0,i.jsxs)(n.p,{children:["所以，这里就引出了一个矛盾：",(0,i.jsx)(n.code,{children:"规范中定义的类型不一定是我们想要的，而我们想要的，规范中也并不一定做了区分"}),"。这就需要我们开发者来自行实现，本章的重点就是",(0,i.jsx)(n.strong,{children:"通过理论联系实践，面向日常的真正需求来实现尽可能可靠的类型判断逻辑，提升大家编写更安全、更健壮代码的能力"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"一般来说，我们最常需要做类型判断的是未定义 undefined、空 null、字符串 string、数字 number 或 bigint、布尔 boolean、符号 symbol、数组 Array、函数 Function、正则 RegExp，除此之外，都可归类为普通对象。"}),"\n",(0,i.jsxs)(n.h2,{id:"typeof-的能力",children:["typeof 的能力",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#typeof-的能力",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"typeof 是做类型判断绝对避不开的一个概念，应该说大家在入门 JavaScript 最开始都会接触到它。然而我相信还有很多同学都对它有误解，把它当作一个函数，写作："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"typeof(foo)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["这样在语法虽然是合法的，不过 ",(0,i.jsx)(n.strong,{children:"typeof 却不是函数，而是一个操作符"}),"，你不可以声明一个叫做 typeof 的变量："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"var typeof = 3 // ❌ Uncaught SyntaxError: Unexpected token 'typeof'\ntypeof typeof  // ❌ Uncaught SyntaxError: Unexpected end of input\n"})}),"\n",(0,i.jsx)(n.p,{children:'typeof 返回值一定是这 8 种字符串之一："undefined"、"string"、"boolean"、"number"、"bigint"、"symbol"、"object" 或 "function"。'}),"\n",(0,i.jsx)(n.p,{children:"可见这 8 种类型和前面我们讲到的规范定义的 8 种类型并不是一一对应的。"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"首先是空类型 null 用 typeof 判断不出来，这是 Primitive 类型中唯一一种 typeof 不支持"})," ",(0,i.jsx)(n.strong,{children:"的"}),"。据说这是 JavaScript 当年的设计者引入的一个 Bug，由于兼容性的考虑一代代传承了下来，以至于 20 多年后我们编写下面的代码仍然是不安全的："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'if ("object" === typeof variable) {}\n'})}),"\n",(0,i.jsx)(n.p,{children:"好在不使用 typeof 也可以安全、简单地判断 null："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:" if (foo === null) {}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"其次，函数 Function 类型得到了 typeof 的单独支持，极大方便了我们日常使用。"})}),"\n",(0,i.jsx)(n.p,{children:"明确了以上两点之后，我们就可以清晰地得到下面这张图，牢记这张图，你可以非常灵活地运用 typeof。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"总体来说，除了 null 有点特殊以外，typeof 在判断 Primitive 类型变量上的能力还是可圈可点的。其实，在日常使用中，undefined 也有一些额外的故事。"}),"\n",(0,i.jsxs)(n.h2,{id:"undefined-的特殊之处",children:["undefined 的特殊之处",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#undefined-的特殊之处",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["一般来说，在我们的认知当中，只有",(0,i.jsx)(n.code,{children:"typeof undefined"}),"才会返回",(0,i.jsx)(n.code,{children:'"undefined"'}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'if ("undefined" === typeof variable) {}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["有人可能会问到，和",(0,i.jsx)(n.code,{children:"undefined"}),"做全等判断岂不是更简单："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"if (undefined === variable) {}\n"})}),"\n",(0,i.jsx)(n.p,{children:"大部分场景下是可以的，但有例外。"}),"\n",(0,i.jsxs)(n.p,{children:["在 ES5 之前的 ES3 时代，全局的 undefined 是能被重写的，比如",(0,i.jsx)(n.code,{children:"undefined=1"}),"是可以被正确执行的。"]}),"\n",(0,i.jsxs)(n.p,{children:["这一现象从 ES5 开始得到了改进，你现在可以打开 Chrome 的开发者工具，在控制台中输入",(0,i.jsx)(n.code,{children:"undefined=1"}),"，然后用",(0,i.jsx)(n.code,{children:"console.log(undefined)"}),"打印出来，会发现 undefined 的值并没有变化。事实上，在 strict 模式（后面章节会讲到）下，下面的代码会直接抛出 TypeError 错误，告诉你 undefined 是只读的："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"\"use strict\";\nundefined = 1; // ❌ Uncaught TypeError: Cannot assign to read only property 'undefined' of object '#<Window>'\n"})}),"\n",(0,i.jsx)(n.p,{children:"虽然现代浏览器已经没有了这个顾虑，但是 undefined 还不是关键字，它依然可以作为变量名在局部上下文中声明："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'{\n    const undefined = 1;\n    console.log(typeof undefined); // "number"\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["显然在这个上下文中用全等",(0,i.jsx)(n.code,{children:"==="}),"来判断，是不可以得出期望的结果的。因此，为了保守起见，我们在判断一个变量是否是 undefined 的时候，推荐的写法还是",(0,i.jsx)(n.code,{children:'"undefined" === typeof variable'}),"。ESLint 有一条规则 ",(0,i.jsx)(n.a,{href:"https://eslint.org/docs/latest/rules/no-undefined",target:"_blank",rel:"noopener noreferrer",children:"no-undefined"})," 就是应对这件事的。"]}),"\n",(0,i.jsx)(n.p,{children:"戏剧性的是，在这个例外之中，还有例外。"}),"\n",(0,i.jsx)(n.p,{children:"ECMA262 自 1999 年发布 ES3 到 2009 年发布 ES5 一共有接近 10 年时间的断层，在这期间微软的 IE 浏览器占据了绝大部分市场份额，其 JavaScript 的 API 实现了很多标准之外的特性，现在我们就遇到了这样一个例子。"}),"\n",(0,i.jsxs)(n.p,{children:["IE 在",(0,i.jsx)(n.code,{children:"document"}),"对象上有一个属性",(0,i.jsx)(n.code,{children:"all"}),"，会返回当前页面中的所有元素，它是可遍历的："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"for (const element of document.all) {\n    console.log(element.tagName);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"然而它在早年间却有着更重要的使命——判断是否是 IE 浏览器："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"if (document.all) {\n    // IE\n} else {\n    // not IE\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["因为只有 IE 浏览器实现了这样一个非 W3C 标准的 API。后面的浏览器虽然实现了",(0,i.jsx)(n.code,{children:"document.all"}),"的数据结构，但是却有着完全不一样的 typeof 表现和布尔值表现："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'typeof document.all // "undefined"\n\nif (document.all) {\n    // never enter\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["是的，虽然 document.all 不是 undefined，但它在 typeof 下却表现得像 undefined，而且在逻辑上是假值。这一切都是为了不破坏过去编写的网站代码，ECMA262 专门为其抽象了一个叫做 ",(0,i.jsx)(n.a,{href:"https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot",target:"_blank",rel:"noopener noreferrer",children:"[[IsHTMLDDA]]"})," 的概念。"]}),"\n",(0,i.jsxs)(n.h2,{id:"典型对象的判断",children:["典型对象的判断",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#典型对象的判断",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"typeof 基本能解决 Primitive 变量的判断，我们还有几个典型对象类型的判断需求，比如数组 Array 和正则 RegExp。"}),"\n",(0,i.jsx)(n.p,{children:"先来看数组。"}),"\n",(0,i.jsxs)(n.p,{children:["在早年间，由于 IE 环境下跨 iframe 调用时，",(0,i.jsx)(n.code,{children:"[] instanceof Array"}),"不成立，所以业界普遍推荐的判断方法是",(0,i.jsx)(n.code,{children:'Object.prototype.toString.call(variable) === "[object Array]"'}),"，其实你也可以使用",(0,i.jsx)(n.code,{children:"variable.constructor === Array"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["后面，ES5 引入了 ",(0,i.jsx)(n.code,{children:"Array.isArray"})," 静态方法，如果不考虑 IE 环境的话，它又有什么优势呢？"]}),"\n",(0,i.jsxs)(n.p,{children:["答案是 ",(0,i.jsx)(n.strong,{children:"Array.isArray 比 instanceof 或者 constructor 能胜任对 Proxy 的判定工作"}),"。我们不妨看下面一段代码："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const proxy = new Proxy([], {\n    get(target, p) {\n        if ('constructor' === p) return String;\n        return Reflect.get(target, p);\n    },\n    getPrototypeOf() {\n        return null;\n    }\n});\n\nconsole.log(`Array.isArray(proxy)`, Array.isArray(proxy)); // true\nconsole.log(`proxy instanceof Array`, proxy instanceof Array); // false\nconsole.log(`proxy.constructor === Array`, proxy.constructor === Array); // false\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Proxy 的知识在后面的章节中还会讲到。在上面的例子中，我们篡改了 Proxy 对象的 constructor 和原型链，这使得通过 constructor 或者 instanceof 的方式判断类型的尝试都失效了，唯独 ",(0,i.jsx)(n.code,{children:"Array.isArray"})," 仍然能正常工作，这就是它的优势。"]}),"\n",(0,i.jsxs)(n.p,{children:["因此，",(0,i.jsxs)(n.strong,{children:["无论是从使用便利性上来说，还是从能力范围上来讲，都更建议使用 ",(0,i.jsx)(n.code,{children:"Array.isArray"})," 来判断数组类型"]}),"。"]}),"\n",(0,i.jsx)(n.p,{children:"其他对象类型就没有这种待遇了，比如我们常用的正则 RegExp。除了它有自己独立的字面量语法之外，RegExp 没有其他任何特别之处。假设我们声明一个自定义类："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"class Animal {}\n"})}),"\n",(0,i.jsx)(n.p,{children:"那么，实现 isAnimal 的原理和实现 isRegExp 的原理是等价的。那我这里使用 Animal 来代指任意对象类型，包括 RegExp、Date、Arguments，也包括 Window、Document。"}),"\n",(0,i.jsx)(n.p,{children:"通常有两种方法来做判断。"}),"\n",(0,i.jsx)(n.p,{children:"第一种办法，判别其构造函数，不过对象的 constructor 属性一般是可以被覆写的，因此有被伪造的可能："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function isAnimal(variable) {\n    return variable?.constructor === Animal;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"第二种办法，用 instanceof 做原型链判别，不过对象的原型链也是可以被篡改的："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"function isAnimal(variable) {\n    return variable instanceof Animal;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"如果你在类中定义了这样一个特殊属性："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"class Animal {\n    get [Symbol.toStringTag]() {\n        return 'Animal';\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"那么也有第三种办法，使用对象基类的 toString 方法："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'function isAnimal(variable) {\n    return Object.prototype.toString.call(variable) === "[object Animal]";\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Array、RegExp、Date、Arguments、Window、Document 甚至 undefined、null 都可以应用这种办法。不过显然字符串对比的方式更容易被篡改，你可以轻松定义一个伪装类来骗过这个判断。"}),"\n",(0,i.jsx)(n.p,{children:"以上三种办法都可以被骗过，那是不是没有完美的办法来判断对象变量类型呢？我认为是的，“animal 是 Animal 类型”这句话本身就是需要被定义的，什么样叫做是，一定是需要条件的，是被 Animal 构造出来就是，还是原型链相关就是呢？"}),"\n",(0,i.jsx)(n.p,{children:"遗憾的是，JavaScript 中的构造函数，甚至 class 语法本身都是语法糖，原型链基本上可以被任意修改，因此可以说，在对象类型的判断上，本身就没有严格的定义，只要不涉及安全攻防，按照你自己认可的方式实现即可，不必在完备性上过于执着。"}),"\n",(0,i.jsx)(n.p,{children:"这种不完美也会传导到 Primitive 类型的变量上。"}),"\n",(0,i.jsxs)(n.h2,{id:"primitive-的对象封装",children:["Primitive 的对象封装",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#primitive-的对象封装",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"除了 null 和 undefined 外，其余的 Primitive 类型都可以封装成 Object："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'Object(123)             // 等价于 new Number(123)\nObject(123n)            // 等价于 new BigInt(123n)\nObject("str")           // 等价于 new String("str")\nObject(true)            // 等价于 new Boolean(true)\nObject(Symbol("sym"))\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"有 Java 语言背景的同学应该对装箱/拆箱的概念不陌生，和这相比是极其类似的。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"虽然这些值在 typeof 下一定都返回 “object”，但是却仍然有着原本的语义，比如："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'new Number(3) + new Number(4) // 7\nnew String("a") + new String("b") // "ab"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["如果你想实现一个 ",(0,i.jsx)(n.code,{children:"concatString(a, b)"})," 函数，a 和 b 除了应该是 string 类型之外，也许你也想兼容一下字符串对象，这是非常常见的需求，那么 ",(0,i.jsx)(n.code,{children:"isString"})," 函数的逻辑就应该分成两个部分："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'function isString(str) {\n    return "string" === typeof str || Object.prototype.toString.call(str) === "[object String]";\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"这也是著名的 lodash.isString 实现的主要原理。同样的道理，对于 number、boolean、symbol 也是适用的，唯一需要特别关注的是，布尔对象在逻辑语义上始终为真："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"if (new Boolean(false)) {\n    // enter\n}\n\nif (new Boolean(true)) {\n    // enter\n}\n\nnew Boolean(new Boolean(false)).valueOf() // true\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"到此为止，我们了解了 JavaScript 类型系统的关键知识，ECMA262 定义的 8 种变量类型，和我们日常开发常常需要分辨的并不完全一致，typeof 也不能满足，所以必须增加对特定对象类型的判定。"}),"\n",(0,i.jsx)(n.p,{children:"总结来看，根据不同的目标类型，可以采取如下的判定方法："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["用全等",(0,i.jsx)(n.code,{children:"==="}),"来判断 null 类型；"]}),"\n",(0,i.jsxs)(n.li,{children:["用 ",(0,i.jsx)(n.code,{children:"typeof"})," 来判断其他 Primitive 类型，注意 ",(0,i.jsx)(n.code,{children:"document.all"})," 的例外；"]}),"\n",(0,i.jsxs)(n.li,{children:["用 ",(0,i.jsx)(n.code,{children:"Array.isArray"}),"来判断数组类型；"]}),"\n",(0,i.jsx)(n.li,{children:"没有完美的特定对象类型判断方法，可以酌情选择 constructor、instanceof 或者 toString。"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Primitive 的对象封装类型也可以被使用，以增加代码的兼容性和能力范畴，但是也需要额外添加像上面第 4 点的对象类型判断逻辑才行，注意这个逻辑是可以被绕过的。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F3%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%9C%B0%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9F.md"]={toc:[{text:"ECMA262 中的类型",id:"ecma262-中的类型",depth:2},{text:"typeof 的能力",id:"typeof-的能力",depth:2},{text:"undefined 的特殊之处",id:"undefined-的特殊之处",depth:2},{text:"典型对象的判断",id:"典型对象的判断",depth:2},{text:"Primitive 的对象封装",id:"primitive-的对象封装",depth:2},{text:"小结",id:"小结",depth:2}],title:"3 基础篇｜如何合理地判断变量的类型？",headingTitle:"3 基础篇｜如何合理地判断变量的类型？",frontmatter:{}}}}]);