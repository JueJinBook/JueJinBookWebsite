"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["26241"],{223857:function(n,e,i){i.r(e),i.d(e,{default:()=>l});var o=i(552676),c=i(740453);let r=i.p+"static/image/329911dd9ee38e29d80b930b5b2e1c86.a7f2b0f2.png",s=i.p+"static/image/05fbd88f14eb62d344e8b4c926258bda.f196b218.png",d=i.p+"static/image/35d481dd15744ee76e1e3736dfa0e0cd.d50000a1.png";function a(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",img:"img",pre:"pre",ul:"ul",li:"li",blockquote:"blockquote"},(0,c.ah)(),n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.h1,{id:"14原理解析快照隔离",children:["14.原理解析：快照隔离",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#14原理解析快照隔离",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"iframe 隔离方案是一种非常彻底的隔离实现，本课程接下来会简单讲解一个纯前端基于 JS 设计的快照隔离方案，该隔离方案用于简单实现全局对象属性的隔离。"}),"\n",(0,o.jsxs)(e.h2,{id:"隔离思路",children:["隔离思路",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#隔离思路",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["在 V8 隔离中我们知道如果想要真正做到 JS 运行时环境的隔离，本质上需要在底层利用 V8 创建不同的 Isolate 或者 Context 进行隔离，例如 iframe 和 Worker 线程都可以做到这一点。利用 iframe 实现隔离已经在上一节课程中进行了讲解，而 Worker 线程因为和 Renderer UI 线程在 Web API 能力上存在差异，不适合作为微应用的 JS 运行环境。本课程接下来讲解的 JS 运行时隔离本质上并不是利用 V8 来创建不同的 Context 实现隔离，而是简单将主应用执行环境中的 ",(0,o.jsx)(e.code,{children:"window"})," 全局对象进行隔离，微应用仍然运行在主应用的全局执行环境中，具体如下所示："]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:d,alt:""})}),"\n",(0,o.jsx)(e.p,{children:"为了实现快照隔离功能，首先需要讲解一些 JavaScript 的语言特性，从而帮助大家更好的理解方案设计。"}),"\n",(0,o.jsxs)(e.h2,{id:"自执行的匿名函数",children:["自执行的匿名函数",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#自执行的匿名函数",children:"#"})]}),"\n",(0,o.jsx)(e.p,{children:"在动态 Script 的方案中，我们讲解了可以使用自执行的匿名函数来隔绝变量声明的作用域。除此之外，jQuery 为了隔绝外部声明的变量和函数也采用了该特性，具体如下所示："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// 自执行的匿名函数（模拟微应用环境）\n(function(){\n    //局部函数\n    function a() {\n        alert('inner a');\n    }\n})();\n\n// 全局函数（主应用环境）\nfunction a() {\n    alert('out a');\n}\n\na(); // out a\nconsole.log(window.a); // out a 对应的函数\n"})}),"\n",(0,o.jsxs)(e.p,{children:["从上述示例可以发现自执行匿名函数创建了自己的函数作用域，该作用域内的函数不会和匿名函数外部的同名函数冲突。除此之外，为了加速访问全局对象 ",(0,o.jsx)(e.code,{children:"window"}),"，可以进行如下处理："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"window.a = 1;\n\n// 访问局部变量 window, 不需要向上遍历作用域链, 缩短查找时间, 同时在压缩代码时局部变量 window 可被压缩\n(function(window){\n    alert(a);\n})(window);\n\n// 向上遍历到顶层作用域, 访问速度变慢, 全局变量 window 不能被压缩\n(function(){\n    alert(a);\n})();\n"})}),"\n",(0,o.jsx)(e.p,{children:"有了上述知识后，我们可以模仿微应用的执行作用域，具体如下所示："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// 主应用\nlet a = 0;\n\n// 微应用 A\n(function (window) {\n    let a = 1;\n    console.log(a); // 1，相对于独立运行的微应用 A 而言符合预期\n})(window);\n\n// 微应用 B\n(function (window) {\n    let a = 2;\n    console.log(a); // 2，相对于独立运行的微应用 B 而言符合预期\n})(window);\n\nconsole.log(a); // 0\nconsole.log(window.a); // undefined，符合预期，let 不会在全局声明时（在最顶层的作用域）创建 window 对象的属性\n"})}),"\n",(0,o.jsxs)(e.p,{children:["此时因为自执行匿名函数有自己的作用域，在内部声明的 ",(0,o.jsx)(e.code,{children:"let"})," 变量可以被作用域隔离，因为 ",(0,o.jsx)(e.code,{children:"let"})," 声明的变量不会在作用域中被提升。如果我们将 ",(0,o.jsx)(e.code,{children:"let"})," 替换成 ",(0,o.jsx)(e.code,{children:"var"})," 进行尝试："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'// 主应用\nvar a = 0;\nconsole.log("主应用: ", window.a); // 0\n\n// 微应用 A\n(function (window) {\n    var a = 1;\n    console.log("微应用 A: ", window.a); // 0，相对于独立运行的微应用 A 而言不符合预期\n})(window);\n\n// 微应用 B\n(function (window) {\n    var a = 2;\n    console.log("微应用 B: ", window.a); // 0，相对于独立运行的微应用 B 而言不符合预期\n})(window);\n\nconsole.log("主应用: ", window.a); // 0，符合预期，主应用中的 window.a 不受微应用执行代码的影响\n'})}),"\n",(0,o.jsxs)(e.p,{children:["我们知道使用 ",(0,o.jsx)(e.code,{children:"var"})," 在全局作用域中声明的变量将作为全局对象 ",(0,o.jsx)(e.code,{children:"window"})," 的不可配置属性被添加，因此在全局作用域声明的变量 ",(0,o.jsx)(e.code,{children:"a"})," 同时也是 ",(0,o.jsx)(e.code,{children:"window"})," 对象的属性。但是如果将 ",(0,o.jsx)(e.code,{children:"var"})," 放入函数中执行（注意不是块级作用域），那么变量的作用域将被限定在函数内部，此时并不会在全局对象 ",(0,o.jsx)(e.code,{children:"window"})," 上添加属性。因此执行上述代码后，微应用中的 ",(0,o.jsx)(e.code,{children:"var"})," 声明不会影响主应用的 ",(0,o.jsx)(e.code,{children:"window"})," 属性，起到了隔离的效果。虽然主应用本身的执行没有受到影响，但是微应用的执行并不符合预期，因为微应用本质上可以独立运行，如果将微应用 A 的代码单独拿出来执行："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:' // 微应用独立运行时下述代码是在全局作用域中执行，var 的声明可以添加到 window 对象的属性上\n // 微应用在主应用中运行时下述代码是在立即执行的匿名函数中执行，var 的声明只能在函数内部生效\n var a = 1;\n console.log("微应用 A: ", window.a); // 1\n'})}),"\n",(0,o.jsx)(e.p,{children:"可以发现微应用 A 单独执行和在自执行的匿名函数中执行的结果是不一样的，因为一个是在全局作用域内执行，另外一个则是放入了函数作用域进行执行。除此之外，在 JavaScript 中使用变量时也可以不限定标识符，此时微应用的执行会污染全局属性，例如："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'// 主应用\nvar a = 0;\nconsole.log("主应用: ", window.a); // 0\n\n// 微应用 A\n(function (window) {\n    // 非严格模式下不限定 let、const 或者 var 标识符，此时会在全局对象下创建同名属性\n    a = 1;\n    console.log("微应用 A: ", window.a); // 1，相对于独立运行的微应用 A 而言符合预期\n})(window);\n\n// 微应用 B\n(function (window) {\n    a = 2;\n    console.log("微应用 B: ", window.a); // 2，相对于独立运行的微应用 B 而言符合预期\n})(window);\n\nconsole.log("主应用: ", window.a); // 2，不符合预期，主应用中的 window.a 受到了微应用执行代码的影响\n'})}),"\n",(0,o.jsxs)(e.p,{children:["当然，在对 ",(0,o.jsx)(e.code,{children:"this"})," 进行属性赋值时，也会污染全局属性，例如："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'// 主应用\nvar a = 0;\nconsole.log("主应用: ", window.a); // 0\n\n// 微应用 A\n(function (window) {\n    // 非严格模式下 this 指向 window 全局对象\n    this.a = 1;\n    console.log("微应用 A: ", window.a); // 1，相对于独立运行的微应用 A 而言符合预期\n})(window);\n\n// 微应用 B\n(function (window) {\n    this.a = 2;\n    console.log("微应用 B: ", window.a); // 2，相对于独立运行的微应用 B 而言符合预期\n})(window);\n\nconsole.log("主应用: ", window.a); // 2，不符合预期，主应用中的 window.a 受到了微应用执行代码的影响\n'})}),"\n",(0,o.jsx)(e.p,{children:"从上述几个测试示例可以发现，仅仅将微应用封装在匿名函数中进行执行："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["可以解决 ",(0,o.jsx)(e.code,{children:"let"})," 或者 ",(0,o.jsx)(e.code,{children:"const"})," 声明变量的隔离问题"]}),"\n",(0,o.jsx)(e.li,{children:"未限定标识符声明变量时，无法实现全局属性隔离问题"}),"\n",(0,o.jsxs)(e.li,{children:["使用 ",(0,o.jsx)(e.code,{children:"this"})," 时访问的仍然是主应用的 ",(0,o.jsx)(e.code,{children:"window"})," 对象，无法实现全局属性隔离问题"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"采用立即执行的匿名函数可以限定微应用的作用域，从而在创建局部变量时有很好的隔离效果。当然，由于将微应用封装在函数中执行，一些在全局作用域中运行的特性丢失，并且也无法解决全局属性隔离的问题。"}),"\n",(0,o.jsxs)(e.h2,{id:"js-文本执行方式",children:["JS 文本执行方式",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#js-文本执行方式",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["有了立即执行的匿名函数后，我们可以将微应用的 JS 包装在立即执行的匿名函数中运行，这个包装动作需要在主应用的环境中执行，因为微应用可能有很多的 JS 脚本需要被包装处理，并且可能还需要支持原有的独立运行能力。为此，通过 Script 标签设置 ",(0,o.jsx)(e.code,{children:"src"})," 进行远程请求外部脚本的方式无法满足手动包装 JS 脚本执行的诉求，此时需要手动请求获取 JS 文本并进行手动执行。在 iframe 隔离的方案中，通过 ",(0,o.jsx)(e.code,{children:"window.fetch"})," 手动请求 JS 文本内容（也可以通过 ",(0,o.jsx)(e.code,{children:"XMLHttpRequest"})," 进行请求），如果主应用和微应用的服务跨域，那么请求需要服务端额外支持跨域："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// 获取 JS 文本（微应用服务需要支持跨域请求获取 JS 文件）\nasync fetchScript(src) {\n  try {\n    const res = await window.fetch(src);\n    return await res.text();\n  } catch (err) {\n    console.error(err);\n  }\n}\n"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsxs)(e.p,{children:["温馨提示： qiankun 框架底层默认使用了 ",(0,o.jsx)(e.code,{children:"fetch"})," 进行微应用静态资源的请求，如果是开发态启动的应用，需要额外配置跨域能力。"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"获取到微应用 JS 的文本字符串后，需要具备手动执行 JS 文本的能力。在 Web 应用中执行 JS 文本字符串的方式有如下几种："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"通过 Script 标签加载内嵌的 JS 文本"}),"\n",(0,o.jsxs)(e.li,{children:["通过 ",(0,o.jsx)(e.code,{children:"eval"})," 执行 JS 文本"]}),"\n",(0,o.jsxs)(e.li,{children:["通过 ",(0,o.jsx)(e.code,{children:"Function"})," 执行 JS 文本"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"在 iframe 隔离中，我们使用了 Script 标签请求获取 JS 文本进行运行，实现的方式如下所示："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"// 在 document 中创建一个 script 元素\nconst scriptElement = document.createElement('script');\n// 指定 Script 元素的文本内容\n// scriptText 是通过请求获取的 JS 文本字符串，可以对该内容进行立即执行的匿名函数封装处理\nscriptElement.textContent = scriptText;\n// 将元素添加到 document 的 head 标签下（添加成功后代码会自动解析执行）\ndocument.head.appendChild(scriptElement);\n"})}),"\n",(0,o.jsxs)(e.p,{children:["除此之外，也可以使用 ",(0,o.jsx)(e.code,{children:"eval"})," 和 ",(0,o.jsx)(e.code,{children:"Function"})," 进行执行，如下所示："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'eval("let a =1, b = 2; console.log(a + b);");\n\n// 等同于 function(a, b) { return  a + b; }\n// 前面几项是函数的入参，最后一项是函数的执行体\nconst fn = new Function("a", "b", "return a + b;");\nconsole.log(fn(1, 2));\n'})}),"\n",(0,o.jsx)(e.p,{children:"当然两者是存在差异的，例如生效的作用域不同："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"var hello = 10;\nfunction createFunction1() {\n    var hello = 20;\n    return new Function('return hello;'); // 这里的 hello 指向全局作用域内的 hello\n}\nvar f1 = createFunction1();\nconsole.log(f1());   // 10\n\n\nvar world = 10;\nfunction createFunction2() {\n    var world = 20;\n    return eval('world;'); // 这里的 world 指向函数作用域内的 world\n}\nconsole.log(createFunction2()); // 20\n"})}),"\n",(0,o.jsxs)(e.p,{children:["从上述的执行示例可以看出，使用 ",(0,o.jsx)(e.code,{children:"Function"})," 的安全性更高。例如在具备模块化开发环境的 Vue 或者 React 项目中，开发者可能习惯性的在文件顶部使用 ",(0,o.jsx)(e.code,{children:"var"})," 进行变量声明，此时变量被声明在模块的作用域内，而不是全局的作用域（不会被添加到 ",(0,o.jsx)(e.code,{children:"window"})," 上），因此上述代码在模块化的环境中使用 ",(0,o.jsx)(e.code,{children:"Function"})," 执行会报错，而 ",(0,o.jsx)(e.code,{children:"eval"})," 不会。理论上在开发时应该避免上述这种依赖执行的情况出现，如果 ",(0,o.jsx)(e.code,{children:"hello"})," 和 ",(0,o.jsx)(e.code,{children:"world"})," 两个变量在构建时被压缩，那么代码执行就会产生意想不到的错误。当然也可以使得 ",(0,o.jsx)(e.code,{children:"eval"})," 在全局作用域内生效，例如："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"var world = 10;\nfunction createFunction2() {\n    var world = 20;\n    // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval\n    // 使用间接调用 (0,eval) 或者 var geval = eval; 可以达到相同的效果\n    return window.eval('world;'); // 这里的 world 指向全局作用域内的 world\n}\nconsole.log(createFunction2()); // 10\n"})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsxs)(e.p,{children:["温馨提示：感兴趣的同学还可以了解一下 ",(0,o.jsx)(e.code,{children:"Function"})," 和 ",(0,o.jsx)(e.code,{children:"eval"})," 的执行性能差异。在 qiankun 框架中使用了 ",(0,o.jsx)(e.code,{children:"(0,eval)"})," 来执行微应用的 JS 文本，在 icestark 中优先使用 ",(0,o.jsx)(e.code,{children:"Function"})," 执行 JS 文本。"]}),"\n"]}),"\n",(0,o.jsxs)(e.h2,{id:"隔离方案设计",children:["隔离方案设计",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#隔离方案设计",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["Window 快照会完全复用主应用的 Context，本质上没有形成隔离，仅仅是在主应用 Context 的基础上记录运行时需要的差异属性，每一个微应用内部都需要维护一个和主应用 ",(0,o.jsx)(e.code,{children:"window"})," 对象存在差异的对象。不管是调用 Web API 还是设置 ",(0,o.jsx)(e.code,{children:"window"})," 属性值，本质上仍然是在主应用的 ",(0,o.jsx)(e.code,{children:"window"})," 对象上进行操作，只是会在微应用切换的瞬间恢复主应用的 ",(0,o.jsx)(e.code,{children:"window"})," 对象，此方案无法做到真正的 Context 隔离，并且在一个时刻只能运行一个微应用，无法实现多个微应用同时运行，具体方案如下所示："]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:s,alt:""})}),"\n",(0,o.jsx)(e.p,{children:"大致实现的思路如下所示："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"通过请求获取后端的微应用列表数据，动态创建主导航"}),"\n",(0,o.jsx)(e.li,{children:"根据导航切换微应用，切换时会跨域请求微应用 JS 的文本内容并进行缓存处理"}),"\n",(0,o.jsx)(e.li,{children:"切换微应用时需要先失活已经激活的微应用，确保一个时刻只有一个微应用运行"}),"\n",(0,o.jsxs)(e.li,{children:["运行微应用前需要将微应用之前运行记录的 DIFF 对象和主应用的 ",(0,o.jsx)(e.code,{children:"window"})," 快照进行合并，从而恢复微应用之前运行的 window 对象"]}),"\n",(0,o.jsxs)(e.li,{children:["失活微应用前需要先通过当前运行时的 ",(0,o.jsx)(e.code,{children:"window"})," 对象和主应用 ",(0,o.jsx)(e.code,{children:"window"})," 快照进行对比，计算出本次运行时的 DIFF 差异对象，为下一次恢复微应用的 ",(0,o.jsx)(e.code,{children:"window"})," 对象做准备，同时通过快照恢复主应用的 ",(0,o.jsx)(e.code,{children:"window"})," 对象"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"实现效果如下所示，图中的两个按钮（微应用导航）根据后端数据动态渲染，点击按钮后会跨域请求微应用的 JS 静态资源并进行快照隔离执行："}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:r,alt:""})}),"\n",(0,o.jsxs)(e.blockquote,{children:["\n",(0,o.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,o.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/snapshot-sandbox",target:"_blank",rel:"noopener noreferrer",children:"demo/snapshot-sandbox"})," 分支获取。"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"快照隔离实现的文件的结构目录如下所示："}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"├── public                   # 托管的静态资源目录\n│   ├── main/                # 主应用资源目录                               \n│   │   └── index.html                                        \n│   └── micro/               # 微应用资源目录\n│        ├── micro1.js        \n│        └── micro2.js      \n├── config.js                # 公共配置\n├── main-server.js           # 主应用服务\n└── micro-server.js          # 微应用服务\n"})}),"\n",(0,o.jsxs)(e.p,{children:["其中 ",(0,o.jsx)(e.code,{children:"micro1.js"})," 和 ",(0,o.jsx)(e.code,{children:"micro2.js"})," 是需要被隔离执行的微应用 JS 脚本，它们的设计如下所示："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'// public/micro/micro1.js\nlet root = document.createElement("h1");\nroot.textContent = "微应用1";\nroot.id = \'micro1-dom\';\nroot.onclick = () => {\n  console.log("微应用1 的 window.a: ", window.a);\n};\ndocument.body.appendChild(root);\n\nwindow.a = 1;\n\n// public/micro/micro2.js\nlet root = document.createElement("h1");\nroot.textContent = "微应用2";\nroot.id = \'micro2-dom\';\nroot.onclick = () => {\n  console.log("微应用2 的 window.a: ", window.a);\n};\ndocument.body.appendChild(root);\n\nwindow.a = 2;\n'})}),"\n",(0,o.jsx)(e.p,{children:"上述代码如果直接使用动态 Script 的方案进行请求和执行，会产生如下错误："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"root"})," 变量会重复声明报错，在本示例中会使用立即执行的匿名函数进行作用域隔离处理"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"window.a"})," 不会被隔离，微应用会因为共用 ",(0,o.jsx)(e.code,{children:"window.a"})," 而产生意想不到的结果"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["接下来我们可以利用立即执行的匿名函数将微应用的 JS 文本进行包装，并使用 ",(0,o.jsx)(e.code,{children:"eval"})," 进行手动执行。在这里，我们可以将之前 iframe 隔离中的 ",(0,o.jsx)(e.code,{children:"MicroAppSandbox"})," 类进行改造，如下所示："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:" class MicroAppSandbox {\n    // 配置信息\n    options = null;\n    // 是否执行过 JS\n    exec = false;\n    // 微应用 JS 运行之前的主应用 window 快照\n    mainWindow = {};\n    // 微应用 JS 运行之后的 window 对象（用于理解）\n    microWindow = {};\n    // 微应用失活后和主应用的 window 快照存在差异的属性集合\n    diffPropsMap = {};\n\n    constructor(options) {\n      this.options = options;\n      // 重新包装需要执行的微应用 JS 脚本\n      this.wrapScript = this.createWrapScript();\n    }\n\n    createWrapScript() {\n      // 微应用的代码运行在立即执行的匿名函数中，隔离作用域\n      return `;(function(window){\n        ${this.options.scriptText}\n      })(window)`;\n    }\n\n    execWrapScript() {\n      // 在全局作用域内执行微应用代码\n      (0, eval)(this.wrapScript);\n    }\n\n    // 微应用 JS 运行之前需要记录主应用的 window 快照（用于微应用失活后的属性差异对比）\n    recordMainWindow() {\n      for (const prop in window) {\n        if (window.hasOwnProperty(prop)) {\n          this.mainWindow[prop] = window[prop];\n        }\n      }\n    }\n\n    // 微应用 JS 运行之前需要恢复上一次微应用执行后的 window 对象\n    recoverMicroWindow() {\n      // 如果微应用和主应用的 window 对象存在属性差异\n      // 上一次微应用 window = 主应用 window + 差异属性（在微应用失活前会记录运行过程中涉及到更改的 window 属性值，再次运行之前需要恢复修改的属性值）\n      Object.keys(this.diffPropsMap).forEach((p) => {\n        // 更改 JS 运行之前的微应用 window 对象，注意微应用本质上共享了主应用的 window 对象，因此一个时刻只能运行一个微应用\n        window[p] = this.diffPropsMap[p];\n      });\n      // 用于课程理解\n      this.microWindow = window;\n    }\n\n    recordDiffPropsMap() {\n      // 这里的 microWindow 是微应用失活之前的 window（在微应用执行期间修改过 window 属性的 window）\n      for (const prop in this.microWindow) {\n        // 如果微应用运行期间存在和主应用快照不一样的属性值\n        if (\n          window.hasOwnProperty(prop) &&\n          this.microWindow[prop] !== this.mainWindow[prop]\n        ) {\n          // 记录微应用运行期间修改或者新增的差异属性（下一次运行微应用之前可用于恢复微应用这一次运行的 window 属性）\n          this.diffPropsMap[prop] = this.microWindow[prop];\n          // 恢复主应用的 window 属性值\n          window[prop] = this.mainWindow[prop];\n        }\n      }\n    }\n\n    active() {\n      // 记录微应用 JS 运行之前的主应用 window 快照\n      this.recordMainWindow();\n      // 恢复微应用需要的 window 对象\n      this.recoverMicroWindow();\n      if (this.exec) {\n        return;\n      }\n      this.exec = true;\n      // 执行微应用（注意微应用的 JS 代码只需要被执行一次）\n      this.execWrapScript();\n    }\n\n    inactive() {\n      // 清空上一次记录的属性差异\n      this.diffPropsMap = {};\n      // 记录微应用运行后和主应用 Window 快照存在的差异属性\n      this.recordDiffPropsMap();\n      console.log(\n        `${this.options.appId} diffPropsMap: `,\n        this.diffPropsMap\n      );\n    }\n  }\n"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:"MicroApps"}),"和 ",(0,o.jsx)(e.code,{children:"MicroApp"})," 和 iframe 隔离方案设计基本一致（注释部分是差异部分）："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'  class MicroApp {\n   \n    scriptText = "";\n\n    sandbox = null;\n\n    rootElm = null;\n\n    constructor(rootElm, app) {\n      this.rootElm = rootElm;\n      this.app = app;\n    }\n\n\n    async fetchScript(src) {\n      try {\n        const res = await window.fetch(src);\n        return await res.text();\n      } catch (err) {\n        console.error(err);\n      }\n    }\n\n\n    async active() {\n\n      if (!this.scriptText) {\n        this.scriptText = await this.fetchScript(this.app.script);\n      }\n\n      if (!this.sandbox) {\n        this.sandbox = new MicroAppSandbox({\n          scriptText: this.scriptText,\n          appId: this.app.id,\n        });\n      }\n\n      this.sandbox.active();\n\n      // 获取元素并进行展示，这里先临时约定微应用往 body 下新增 id 为 `${this.app.id}-dom` 的元素\n      const microElm = document.getElementById(`${this.app.id}-dom`);\n      if (microElm) {\n        microElm.style = "display: block";\n      }\n    }\n\n    inactive() {\n    \n     // 获取元素并进行隐藏，这里先临时约定微应用往 body 下新增 id 为 `${this.app.id}-dom` 的元素\n      const microElm = document.getElementById(`${this.app.id}-dom`);\n      if (microElm) {\n        microElm.style = "display: none";\n      }\n      this.sandbox?.inactive();\n    }\n  }\n\n\n  class MicroApps {\n\n    appsMap = new Map();\n\n    rootElm = null;\n\n    constructor(rootElm, apps) {\n      this.rootElm = rootElm;\n      this.setAppMaps(apps);\n    }\n\n    setAppMaps(apps) {\n      apps.forEach((app) => {\n        this.appsMap.set(app.id, new MicroApp(this.rootElm, app));\n      });\n    }\n\n\n    prefetchApps() {}\n\n\n    activeApp(id) {\n      const app = this.appsMap.get(id);\n      app?.active();\n    }\n\n\n    inactiveApp(id) {\n      const app = this.appsMap.get(id);\n      app?.inactive();\n    }\n  }\n'})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:"MainApp"})," 中需要确保一个时刻只能运行一个微应用，因此在微应用激活之前，需要先失活已经激活运行的微应用，如下所示："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:'\n  class MainApp {\n    microApps = [];\n    microAppsManager = null;\n\n    constructor() {\n      this.init();\n    }\n\n    async init() {\n      this.microApps = await this.fetchMicroApps();\n      this.createNav();\n      this.navClickListener();\n      this.hashChangeListener();\n      this.microAppsManager = new MicroApps(\n        document.getElementById("container"),\n        this.microApps\n      );\n    }\n\n    async fetchMicroApps() {\n      try {\n        const res = await window.fetch("/microapps", {\n          method: "post",\n        });\n        return await res.json();\n      } catch (err) {\n        console.error(err);\n      }\n    }\n    \n    createNav(microApps) {\n      const fragment = new DocumentFragment();\n      this.microApps?.forEach((microApp) => {\n        const button = document.createElement("button");\n        button.textContent = microApp.name;\n        button.id = microApp.id;\n        fragment.appendChild(button);\n      });\n      nav.appendChild(fragment);\n    }\n\n    navClickListener() {\n      const nav = document.getElementById("nav");\n      nav.addEventListener("click", (e) => {\n        // 此时有一个微应用已经被激活运行\n        console.log("主应用 window.a: ", window.a);\n        window.location.hash = event?.target?.id;\n      });\n    }\n\n    hashChangeListener() {\n      window.addEventListener("hashchange", () => {\n      \n        // 需要失活应用，为了确保一个时刻只能激活一个应用（这里可以设计微应用的运行状态，根据状态进行处理）\n        this.microApps?.forEach(async ({ id }) => {\n          if (id !== window.location.hash.replace("#", "")) {\n            this.microAppsManager.inactiveApp(id);\n          }\n        });\n\n        // 没有微应用被激活时，主应用的 window 对象会被恢复\n        console.log("恢复主应用的 window.a: ", window.a);\n\n        // 激活应用\n        this.microApps?.forEach(async ({ id }) => {\n          if (id === window.location.hash.replace("#", "")) {\n            this.microAppsManager.activeApp(id);\n          }\n        });\n\n      });\n    }\n  }\n\n  new MainApp();\n'})}),"\n",(0,o.jsx)(e.p,{children:"具备了上述快照隔离能力后："}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["可以解决 ",(0,o.jsx)(e.code,{children:"let"})," 或者 ",(0,o.jsx)(e.code,{children:"const"})," 声明变量的隔离问题"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["可以解决微应用之间的全局属性隔离问题，包括使用未限定标识符的变量、",(0,o.jsx)(e.code,{children:"this"})]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:"无法实现主应用和微应用同时运行时的全局属性隔离问题"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.h2,{id:"小结",children:["小结",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["本课程主要讲解了基于 JS 设计的快照隔离方案，并给出了具体的设计示例。快照隔离是是一种相对简单的隔离方案，如果微应用在运行时仅仅需要隔离 ",(0,o.jsx)(e.code,{children:"window"})," 对象的属性冲突，那么快照隔离是一个非常不错的隔离方案。当然，快照隔离无法解决主子应用同时运行时的 ",(0,o.jsx)(e.code,{children:"window"})," 对象属性冲突问题，也无法解决多个微应用同时运行的问题。"]})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(a,{...n})}):a(n)}let l=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F14.%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%9A%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB.md"]={toc:[{text:"隔离思路",id:"隔离思路",depth:2},{text:"自执行的匿名函数",id:"自执行的匿名函数",depth:2},{text:"JS 文本执行方式",id:"js-文本执行方式",depth:2},{text:"隔离方案设计",id:"隔离方案设计",depth:2},{text:"小结",id:"小结",depth:2}],title:"14.原理解析：快照隔离",headingTitle:"14.原理解析：快照隔离",frontmatter:{}}}}]);