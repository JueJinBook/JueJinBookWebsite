"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["27615"],{983810:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var c=s(552676),d=s(740453);function r(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",blockquote:"blockquote",strong:"strong",ol:"ol",li:"li",h3:"h3"},(0,d.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"8响应式原理vue-3-的-nexttick-",children:["8.响应式原理：Vue 3 的 nextTick ？",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8响应式原理vue-3-的-nexttick-",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["通过前面的几个章节的学习，我们大致了解了对于 ",(0,c.jsx)(n.code,{children:"Vue 3"})," 中的响应式原理：我们通过对 ",(0,c.jsx)(n.code,{children:"state"})," 数据的响应式拦截，当触发 ",(0,c.jsx)(n.code,{children:"proxy setter"})," 的时候，执行对应状态的 ",(0,c.jsx)(n.code,{children:"effect"})," 函数。接下来看一个经典的例子："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{number}}</div>\n  <button @click=\"handleClick\">click</button>\n</template>\n<script>\nimport { ref } from 'vue';\nexport default {\n  setup() {\n    const number = ref(0)\n    function handleClick() {\n      for (let i = 0; i < 1000; i++) {\n        number.value ++;\n      }\n    }\n    return {\n      number,\n      handleClick\n    }\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["当我们按下 ",(0,c.jsx)(n.code,{children:"click"})," 按钮的时候，",(0,c.jsx)(n.code,{children:"number"}),"\xa0会被循环增加 ",(0,c.jsx)(n.code,{children:"1000"})," 次。那么 ",(0,c.jsx)(n.code,{children:"Vue"})," 的视图会在点击按钮的时候，从 ",(0,c.jsx)(n.code,{children:"1 -> 1000"})," 刷新 ",(0,c.jsx)(n.code,{children:"1000"})," 次吗？这一小节，我们将一起探探究竟。"]}),"\n",(0,c.jsxs)(n.h2,{id:"queuejob",children:["queueJob",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#queuejob",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们小册",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7146465352120008743/section/7146510212571070471",target:"_blank",rel:"noopener noreferrer",children:"第四节"}),"介绍关于“组件更新策略”的时候，提到了 ",(0,c.jsx)(n.code,{children:"setupRenderEffect"})," 函数："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    if (!instance.isMounted) {\n      // 初始化组件\n    }\n    else {\n      // 更新组件\n    }\n  }\n  // 创建响应式的副作用渲染函数\n  instance.update = effect(componentUpdateFn, prodEffectOptions)\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["当时这里为了方便介绍组件的更新策略，我们简写了 ",(0,c.jsx)(n.code,{children:"instance.update"})," 的函数创建过程，现在我们来详细看一下 ",(0,c.jsx)(n.code,{children:"instance.update"})," 这个函数的创建："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {\n  function componentUpdateFn() {\n    // ...\n  }\n  // 创建响应式的副作用渲染函数\n  const effect = (instance.effect = new ReactiveEffect(\n    componentUpdateFn,\n    () => queueJob(update),\n    instance.scope\n  ))\n  \n  // 生成 instance.update 函数\n  const update = (instance.update = () => effect.run())\n  update.id = instance.uid\n  \n  // 组件允许递归更新\n  toggleRecurse(instance, true)\n\n  // 执行更新\n  update()\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到在创建 ",(0,c.jsx)(n.code,{children:"effect"})," 副作用函数的时候，会给 ",(0,c.jsx)(n.code,{children:"ReactiveEffect"})," 传入一个 ",(0,c.jsx)(n.code,{children:"scheduler"})," 调度函数，这样生成的 ",(0,c.jsx)(n.code,{children:"effect"})," 中就包含了 ",(0,c.jsx)(n.code,{children:"scheduler"})," 属性。同时为组件实例生成了一个 ",(0,c.jsx)(n.code,{children:"update"})," 属性，该属性的值就是执行 ",(0,c.jsx)(n.code,{children:"effect.run"})," 的函数，另外需要注意的一点是 ",(0,c.jsx)(n.code,{children:"update"})," 中包含了一个 ",(0,c.jsx)(n.code,{children:"id"})," 信息，该值是一个初始值为 ",(0,c.jsx)(n.code,{children:"0"})," 的自增数字，下文我们再详细介绍其作用。"]}),"\n",(0,c.jsxs)(n.p,{children:["当我们触发 ",(0,c.jsx)(n.code,{children:"proxy setter"})," 的时候，触发执行了 ",(0,c.jsx)(n.code,{children:"triggerEffect"})," 函数，这次，我们补全 ",(0,c.jsx)(n.code,{children:"triggerEffect"})," 函数的实现："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function triggerEffect(effect, debuggerEventExtraInfo) {\n  if (effect !== activeEffect || effect.allowRecurse) {\n    // effect 上存在 scheduler\n    if (effect.scheduler) {\n      effect.scheduler()\n    } else {\n      effect.run()\n    }\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，如果 ",(0,c.jsx)(n.code,{children:"effect"})," 上有 ",(0,c.jsx)(n.code,{children:"scheduler"})," 属性时，执行的是 ",(0,c.jsx)(n.code,{children:"effect.scheduler"})," 函数，否则执行 ",(0,c.jsx)(n.code,{children:"effect.run"})," 进行视图更新。而这里显然我们需要先执行调度函数 ",(0,c.jsx)(n.code,{children:"scheduler"}),"。通过上面的信息，我们也清楚地知道 ",(0,c.jsx)(n.code,{children:"scheduler"})," 函数的本质就是执行了 ",(0,c.jsx)(n.code,{children:"queueJob(update)"})," 函数，一起来看一下 ",(0,c.jsx)(n.code,{children:"queueJob"})," 的实现："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export function queueJob(job) {\n  // 去重判断\n  if (\n    !queue.length ||\n    !queue.includes(\n      job,\n      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex\n    )\n  ) {\n    // 添加到队列尾部\n    if (job.id == null) {\n      queue.push(job)\n    } else {\n      // 按照 job id 自增的顺序添加\n      queue.splice(findInsertionIndex(job.id), 0, job)\n    }\n    queueFlush()\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"queueJob"})," 就是维护了一个 ",(0,c.jsx)(n.code,{children:"queue"})," 队列，目的是向 ",(0,c.jsx)(n.code,{children:"queue"})," 队列中添加 ",(0,c.jsx)(n.code,{children:"job"})," 对象，这里的 ",(0,c.jsx)(n.code,{children:"job"})," 就是我们前面的 ",(0,c.jsx)(n.code,{children:"update"})," 对象。"]}),"\n",(0,c.jsx)(n.p,{children:"这里有几点需要说明一下。"}),"\n",(0,c.jsxs)(n.p,{children:["第一个是该函数会有一个 ",(0,c.jsx)(n.code,{children:"isFlushing && job.allowRecurse"})," 判断，这个作用是啥呢？简单点说就是当队列正处于更新状态中（",(0,c.jsx)(n.code,{children:"isFlushing = true"}),"） 且允许递归调用（\xa0",(0,c.jsx)(n.code,{children:"job.allowRecurse = true"}),"）时，将搜索起始位置加一，无法搜索到自身，也就是允许递归调用了。什么情况下会出现递归调用？"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:'\x3c!-- 父组件 --\x3e\n<template>\n  <div>{{msg}}</div>\n  <Child />\n</template>\n<script>\nimport { ref, provide } from \'vue\';\nimport Child from \'./components/Child.vue\';\nexport default {\n  setup() {\n    const msg = ref("initial");\n    provide("CONTEXT", { msg });\n    return {\n      msg\n    };\n  },\n  components: {\n    Child\n  }\n}\n<\/script>\n\n\x3c!-- 子组件 Child --\x3e\n<template>\n  <div>child</div>\n</template>\n<script>\nimport { inject } from \'vue\';\nexport default {\n  setup() {\n    const ctx = inject("CONTEXT");\n    ctx.msg.value = "updated";\n  }\n}\n<\/script>\n'})}),"\n",(0,c.jsxs)(n.p,{children:["对于这种情况，首先是父组件进入 ",(0,c.jsx)(n.code,{children:"job"})," 然后渲染父组件，接着进入子组件渲染，但是子组件内部修改了父组件的状态 ",(0,c.jsx)(n.code,{children:"msg"}),"。此时父组件需要支持递归渲染，也就是递归更新。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["注意，这里的更新已经不属于单选数据流了，",(0,c.jsx)(n.strong,{children:"如果过多地打破单向数据流，会导致多次递归执行更新，可能会导致性能下降。"})]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["第二个是，",(0,c.jsx)(n.code,{children:"queueJob"})," 函数向 ",(0,c.jsx)(n.code,{children:"queue"})," 队列中添加的 ",(0,c.jsx)(n.code,{children:"job"})," 是按照 ",(0,c.jsx)(n.code,{children:"id"})," 排序的，",(0,c.jsx)(n.code,{children:"id"})," 小的 ",(0,c.jsx)(n.code,{children:"Job"})," 先被推入 ",(0,c.jsx)(n.code,{children:"queue"})," 中执行，这保证了，",(0,c.jsx)(n.strong,{children:"父组件永远比子组件先更新"}),"（因为先创建父组件，再创建子组件，子组件可能依赖父组件的数据）。"]}),"\n",(0,c.jsxs)(n.p,{children:["再回到函数的本身来说，当我们执行 ",(0,c.jsx)(n.code,{children:"for"})," 循环 ",(0,c.jsx)(n.code,{children:"1000"})," 次 ",(0,c.jsx)(n.code,{children:"setter"})," 的时候，因为在第一步进行了去重判断，所以 ",(0,c.jsx)(n.code,{children:"update"})," 函数只会被添加一次到 ",(0,c.jsx)(n.code,{children:"queue"})," 中。",(0,c.jsxs)(n.strong,{children:["这里的 ",(0,c.jsx)(n.code,{children:"update"})," 函数就是组件的渲染函数"]}),"。所以无论这里执行多少次循环，渲染更新函数只会被执行一次。"]}),"\n",(0,c.jsxs)(n.h2,{id:"queueflush",children:["queueFlush",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#queueflush",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["上面说到了无论循环多少次 ",(0,c.jsx)(n.code,{children:"setter"}),"，这里相同 ",(0,c.jsx)(n.code,{children:"id"})," 的 ",(0,c.jsx)(n.code,{children:"update"})," 只会被添加一次到 ",(0,c.jsx)(n.code,{children:"queue"})," 中。"]}),"\n",(0,c.jsxs)(n.p,{children:["细心的小伙伴可能会有这样的疑问：",(0,c.jsxs)(n.strong,{children:["那么为什么视图不是从 ",(0,c.jsx)(n.code,{children:"0 -> 1"})," 而是直接从 ",(0,c.jsx)(n.code,{children:"0 -> 1000"})," 了呢？"]})]}),"\n",(0,c.jsxs)(n.p,{children:["要回答上面的问题，就得了解一下 ",(0,c.jsx)(n.code,{children:"queue"})," 的执行更新相关的内容了，也就是 ",(0,c.jsx)(n.code,{children:"queueJob"})," 的最后一步 ",(0,c.jsx)(n.code,{children:"queueFlush"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function queueFlush() {\n  // 是否正处于刷新状态\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true\n    currentFlushPromise = resolvedPromise.then(flushJobs)\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到这里，",(0,c.jsx)(n.code,{children:"vue 3"})," 完全抛弃了除了 ",(0,c.jsx)(n.code,{children:"promise"})," 之外的异步方案，不再支持",(0,c.jsx)(n.code,{children:"vue 2"})," 的 ",(0,c.jsx)(n.code,{children:"Promise > MutationObserver > setImmediate > setTimeout"})," 其他三种异步操作了。"]}),"\n",(0,c.jsxs)(n.p,{children:["所以这里，",(0,c.jsx)(n.code,{children:"vue 3"})," 直接通过 ",(0,c.jsx)(n.code,{children:"promise"})," 创建了一个微任务 ",(0,c.jsx)(n.code,{children:"flushJobs"})," 进行异步调度更新，只要在浏览器当前 ",(0,c.jsx)(n.code,{children:"tick"})," 内的所有更新任务都会被推入 ",(0,c.jsx)(n.code,{children:"queue"})," 中，然后在下一个 ",(0,c.jsx)(n.code,{children:"tick"})," 中统一执行更新。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function flushJobs(seen) {\n  // 是否正在等待执行\n  isFlushPending = false\n  // 正在执行\n  isFlushing = true\n\n  // 在更新前，重新排序好更新队列 queue 的顺序\n  // 这确保了:\n  // 1. 组件都是从父组件向子组件进行更新的。（因为父组件都在子组件之前创建的\n  // 所以子组件的渲染的 effect 的优先级比较低）\n  // 2. 如果父组件在更新前卸载了组件，这次更新将会被跳过。\n  queue.sort(comparator)\n  \n  try {\n    // 遍历主任务队列，批量执行更新任务\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex]\n      if (job && job.active !== false) {\n        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)\n      }\n    }\n  } finally {\n    // 队列任务执行完，重置队列索引\n    flushIndex = 0\n    // 清空队列\n    queue.length = 0\n    // 执行后置队列任务\n    flushPostFlushCbs(seen)\n    // 重置队列执行状态\n    isFlushing = false\n    // 重置当前微任务为 Null\n    currentFlushPromise = null\n    // 如果主任务队列、后置任务队列还有没被清空，就继续递归执行\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen)\n    }\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["在详细介绍 ",(0,c.jsx)(n.code,{children:"flushJobs"})," 之前，我想先简单介绍一下 ",(0,c.jsx)(n.code,{children:"Vue"})," 的更新任务执行机制中的一个重要概念：",(0,c.jsx)(n.strong,{children:"更新时机。"})," ",(0,c.jsx)(n.code,{children:"Vue"})," 整个更新过程分成了三个部分："]}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["更新前，称之为 ",(0,c.jsx)(n.code,{children:"pre"})," 阶段；"]}),"\n",(0,c.jsxs)(n.li,{children:["更新中，也就是 ",(0,c.jsx)(n.code,{children:"flushing"})," 中，执行 ",(0,c.jsx)(n.code,{children:"update"})," 更新；"]}),"\n",(0,c.jsxs)(n.li,{children:["更新后，称之为 ",(0,c.jsx)(n.code,{children:"flushPost"})," 阶段。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"更新前",children:["更新前",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新前",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["什么是 ",(0,c.jsx)(n.code,{children:"pre"})," 阶段呢？拿组件更新举例，就是在 ",(0,c.jsx)(n.code,{children:"Vue"})," 组件更新",(0,c.jsx)(n.strong,{children:"之前"}),"被调用执行的阶段。默认情况下，",(0,c.jsx)(n.code,{children:"Vue"})," 的 ",(0,c.jsx)(n.code,{children:"watch"})," 和 ",(0,c.jsx)(n.code,{children:"watchEffect"})," 函数中的 ",(0,c.jsx)(n.code,{children:"callback"})," 函数都是在这个阶段被执行的，我们简单看一下 ",(0,c.jsx)(n.code,{children:"watch"})," 中的源码实现："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"function watch(surce, cb, {immediate, deep, flush, onTrack, onTrigger} = {}) {\n  // ...\n  if (flush === 'sync') {\n    scheduler = job\n  } else if (flush === 'post') {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)\n  } else {\n    // 默认会给 job 打上 pre 的标记\n    job.pre = true\n    if (instance) job.id = instance.uid\n    scheduler = () => queueJob(job)\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到 ",(0,c.jsx)(n.code,{children:"watch"})," 的 ",(0,c.jsx)(n.code,{children:"job"})," 会被默认打上 ",(0,c.jsx)(n.code,{children:"pre"})," 的标签。而带 ",(0,c.jsx)(n.code,{children:"pre"})," 标签的 ",(0,c.jsx)(n.code,{children:"job"})," 则会在渲染前被执行："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"const updateComponent = () => {\n  // ... 省略 n 行代码\n  updateComponentPreRender(instance, n2, optimized)\n}\n\nfunction updateComponentPreRender() {\n  // ... 省略 n 行代码\n  flushPreFlushCbs()\n}\n\nexport function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {\n  for (; i < queue.length; i++) {\n    const cb = queue[i]\n    if (cb && cb.pre) {\n      queue.splice(i, 1)\n      i--\n      cb()\n    }\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，在执行 ",(0,c.jsx)(n.code,{children:"updateComponent"})," 更新组件之前，会调用 ",(0,c.jsx)(n.code,{children:"flushPreFlushCbs"})," 函数，执行所有带上 ",(0,c.jsx)(n.code,{children:"pre"})," 标签的 ",(0,c.jsx)(n.code,{children:"job"}),"。"]}),"\n",(0,c.jsxs)(n.h3,{id:"更新中",children:["更新中",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新中",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["更新中的过程就是 ",(0,c.jsx)(n.code,{children:"flushJobs"})," 函数体前面的部分，首先会通过一个 ",(0,c.jsx)(n.code,{children:"comparator"})," 函数对 ",(0,c.jsx)(n.code,{children:"queue"})," 队列进行排序，这里排序的目的主要是保证父组件优先于子组件执行，另外在执行后续循环执行 ",(0,c.jsx)(n.code,{children:"job"})," 任务的时候，通过判断 ",(0,c.jsx)(n.code,{children:"job.active !== false"})," 来剔除被 ",(0,c.jsx)(n.code,{children:"unmount"})," 卸载的组件，卸载的组件会有 ",(0,c.jsx)(n.code,{children:"active = false"})," 的标记。"]}),"\n",(0,c.jsxs)(n.p,{children:["最后即通过 ",(0,c.jsx)(n.code,{children:"callWithErrorHandling"})," 函数执行 ",(0,c.jsx)(n.code,{children:"queue"})," 队列中的每一个 ",(0,c.jsx)(n.code,{children:"job"}),":"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"export function callWithErrorHandling(fn, instance, type, args) {\n  let res\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    handleError(err, instance, type)\n  }\n  return res\n}\n"})}),"\n",(0,c.jsxs)(n.h3,{id:"更新后",children:["更新后",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新后",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["当页面更新后，需要执行的一些回调函数都存储在 ",(0,c.jsx)(n.code,{children:"pendingPostFlushCbs"})," 中，通过 ",(0,c.jsx)(n.code,{children:"flushPostFlushCbs"})," 函数来进行回调执行："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"export function flushPostFlushCbs(seen) {\n  // 存在 job 才执行\n  if (pendingPostFlushCbs.length) {\n    // 去重\n    const deduped = [...new Set(pendingPostFlushCbs)]\n    pendingPostFlushCbs.length = 0\n    \n    // #1947 already has active queue, nested flushPostFlushCbs call\n    // 已经存在activePostFlushCbs，嵌套flushPostFlushCbs调用，直接return\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped)\n      return\n    }\n    \n    activePostFlushCbs = deduped\n\n    // 按job.id升序\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b))\n    \n    // 循环执行job\n    for (\n      postFlushIndex = 0;\n      postFlushIndex < activePostFlushCbs.length;\n      postFlushIndex++\n    ) {\n      activePostFlushCbs[postFlushIndex]()\n    }\n    activePostFlushCbs = null\n    postFlushIndex = 0\n  }\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["一些需要渲染完成后再执行的钩子函数都会在这个阶段执行，比如 ",(0,c.jsx)(n.code,{children:"mounted hook"})," 等等。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["通过上面的一些介绍，我们可以了解到本小节开头的示例中，",(0,c.jsx)(n.code,{children:"number"})," 的更新函数只会被同步地添加一次到更新队列 ",(0,c.jsx)(n.code,{children:"queue"})," 中，但更新是异步的，会在 ",(0,c.jsx)(n.code,{children:"nextTick"})," 也就是 ",(0,c.jsx)(n.code,{children:"Promise.then"})," 的微任务中执行 ",(0,c.jsx)(n.code,{children:"update"}),"，所以更新会直接从 ",(0,c.jsx)(n.code,{children:"0 -> 1000"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["另外，需要注意的是一个组件内的相同 ",(0,c.jsx)(n.code,{children:"update"})," 只会有一个被推入 ",(0,c.jsx)(n.code,{children:"queue"})," 中。比如下面的例子："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>{{number}}</div>\n  <div>{{msg}}</div>\n  <button @click=\"handleClick\">click</button>\n</template>\n<script>\nimport { ref } from 'vue'\nexport default {\n  setup() {\n    const number = ref(0)\n    const msg = ref('init')\n    function handleClick() {\n      for (let i = 0; i < 1000; i++) {\n        number.value ++;\n      }\n      msg.value = 'hello world'\n    }\n    return {\n      number,\n      msg,\n      handleClick\n    }\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["当点击按钮时，因为 ",(0,c.jsx)(n.code,{children:"update"})," 内部执行的是当前组件的同一个 ",(0,c.jsx)(n.code,{children:"componentUpdateFn"})," 函数，状态 ",(0,c.jsx)(n.code,{children:"msg"})," 和 ",(0,c.jsx)(n.code,{children:"number"})," 的 ",(0,c.jsx)(n.code,{children:"update"})," 的 ",(0,c.jsx)(n.code,{children:"id"})," 是一致的，所以 ",(0,c.jsx)(n.code,{children:"queue"})," 中，只有一个 ",(0,c.jsx)(n.code,{children:"update"})," 函数，只会进行一次统一的更新。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(r,{...e})}):r(e)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F8.%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%9AVue%203%20%E7%9A%84%20nextTick%20%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"queueJob",id:"queuejob",depth:2},{text:"queueFlush",id:"queueflush",depth:2},{text:"更新前",id:"更新前",depth:3},{text:"更新中",id:"更新中",depth:3},{text:"更新后",id:"更新后",depth:3},{text:"总结",id:"总结",depth:2}],title:"8.响应式原理：Vue 3 的 nextTick ？",headingTitle:"8.响应式原理：Vue 3 的 nextTick ？",frontmatter:{}}}}]);