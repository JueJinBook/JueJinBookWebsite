"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55508"],{872167:function(e,n,a){a.r(n),a.d(n,{default:()=>m});var r=a(552676),s=a(740453);let c=a.p+"static/image/32c16bcba754a5249987660f8d685e78.36d79114.webp",t=a.p+"static/image/605e1df31e74866bd75e0bef42f4f8cd.4fa037b4.webp",i=a.p+"static/image/fb35cd3ac346b01039787043961a22ab.2821129d.gif",d=a.p+"static/image/38ae0d02cf48f7827ea2e547b4a27e69.f1eee5b4.gif",h=a.p+"static/image/0bc29337727925e7b29ade2998bcec8a.4977705d.gif",l=a.p+"static/image/f69a0ce0cb914ca4c675b1582bb0e7b0.1b14e49e.gif",o=a.p+"static/image/35c48e961ce91e1d861401ba8caed86d.9c84bb66.gif",j=a.p+"static/image/b1ebf4f0714ed4a3f841631950285c3a.b584727c.gif",x=a.p+"static/image/bfbad3356e45b3caf81a88e3e58b3e4e.bc004cf8.gif",p=a.p+"static/image/b3b36e2512e8e17cfb89895fba910a6b.f940243f.webp";function g(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",strong:"strong",code:"code",pre:"pre",ol:"ol",li:"li",h4:"h4",img:"img",h5:"h5",ul:"ul"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"13数据获取篇-_-数据获取缓存与重新验证",children:["13.数据获取篇 _ 数据获取、缓存与重新验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13数据获取篇-_-数据获取缓存与重新验证",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 Next.js 中如何获取数据呢？"}),"\n",(0,r.jsx)(n.p,{children:"Next.js 优先推荐使用原生的 fetch 方法，因为 Next.js 拓展了原生的 fetch 方法，为其添加了缓存和更新缓存(重新验证)的机制。"}),"\n",(0,r.jsx)(n.p,{children:"这样做的好处在于可以自动复用请求数据，提高性能。坏处在于如果你不熟悉，经常会有一些“莫名奇妙”的状况出现……"}),"\n",(0,r.jsx)(n.p,{children:"让我们来看看具体如何使用吧。"}),"\n",(0,r.jsxs)(n.h2,{id:"1-服务端使用-fetch",children:["1. 服务端使用 fetch",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-服务端使用-fetch",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"11-基本用法",children:["1.1. 基本用法",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-基本用法",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Next.js 拓展了原生的 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API",target:"_blank",rel:"noopener noreferrer",children:"fetch Web API"}),"，可以为",(0,r.jsx)(n.strong,{children:"服务端的每个请求"}),"配置缓存（caching）和重新验证（ revalidating）行为。"]}),"\n",(0,r.jsxs)(n.p,{children:["你可以在",(0,r.jsx)(n.strong,{children:"服务端组件、路由处理程序、Server Actions"})," 中搭配 ",(0,r.jsx)(n.code,{children:"async"}),"/",(0,r.jsx)(n.code,{children:"await"})," 语法使用 fetch。"]}),"\n",(0,r.jsx)(n.p,{children:"举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nasync function getData() {\n  const res = await fetch('https://jsonplaceholder.typicode.com/todos')\n  if (!res.ok) {\n    // 由最近的 error.js 处理\n    throw new Error('Failed to fetch data')\n  }\n  return res.json()\n}\n\nexport default async function Page() {\n  const data = await getData()\n  return <main>{JSON.stringify(data)}</main>\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"12--默认缓存",children:["1.2.  默认缓存",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12--默认缓存",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["默认情况下，Next.js 会自动缓存服务端 ",(0,r.jsx)(n.code,{children:"fetch"})," 请求的返回值（背后用的是",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-6",target:"_blank",rel:"noopener noreferrer",children:"数据缓存（Data Cache）"}),"）。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// fetch 的 cache 选项用于控制该请求的缓存行为\n// 默认就是 'force-cache', 平时写的时候可以省略\nfetch('https://...', { cache: 'force-cache' })\n"})}),"\n",(0,r.jsx)(n.p,{children:"但这些情况默认不会自动缓存："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"在 Server Action 中使用的时候"}),"\n",(0,r.jsx)(n.li,{children:"在定义了非 GET 方法的路由处理程序中使用的时候"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"简单的来说，在服务端组件和只有 GET 方法的路由处理程序中使用 fetch，返回结果会自动缓存。"})}),"\n",(0,r.jsxs)(n.h4,{id:"121-logging-配置项",children:["1.2.1. logging 配置项",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#121-logging-配置项",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["让我们分别举个例子演示下。但在写代码之前，先让我们修改下 ",(0,r.jsx)(n.code,{children:"next.config.mjs"})," 的配置："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const nextConfig = {\n  logging: {\n    fetches: {\n      fullUrl: true\n    }\n  }\n};\n\nexport default nextConfig;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["目前 logging 只有这一个配置，用于",(0,r.jsx)(n.strong,{children:"在开发模式下"}),"显示 fetch 请求和缓存日志："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"上图日志的意思是："}),"\n",(0,r.jsxs)(n.p,{children:["访问 ",(0,r.jsx)(n.code,{children:"/api/cache"})," 路由，其中 GET 请求了 ",(0,r.jsx)(n.a,{href:"https://dog.ceo/api/breeds/image/random",target:"_blank",rel:"noopener noreferrer",children:"https://dog.ceo/api/breeds/image/random"})," 这个接口，接口 20ms 返回，状态码 200，此次请求命中了缓存（HIT）。"]}),"\n",(0,r.jsx)(n.p,{children:"这个日志会帮助我们查看缓存情况（实际用的时候有的日志结果不是很准，还有待改进）。"}),"\n",(0,r.jsxs)(n.h4,{id:"122-服务端组件",children:["1.2.2. 服务端组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#122-服务端组件",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["第一种在服务端组件中使用，修改 ",(0,r.jsx)(n.code,{children:"app/page.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async function getData() {\n  // 接口每次调用都会返回一个随机的猫猫图片数据\n  const res = await fetch('https://api.thecatapi.com/v1/images/search')\n  if (!res.ok) {\n    throw new Error('Failed to fetch data')\n  }\n \n  return res.json()\n}\n\nexport default async function Page() {\n  const data = await getData()\n  \n  return <img src={data[0].url} width=\"300\" />\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm run dev"}),"，开启开发模式："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:"cache-4.gif"})}),"\n",(0,r.jsx)(n.p,{children:"在开发模式下，为了方便调试，可以使用浏览器的硬刷新（Command + Shift + R）清除缓存，此时数据会发生更改（cache: SKIP）。普通刷新时因为会命中缓存（cache: HIT），数据会保持不变。"}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm run build && npm run start"})," 开启生产版本："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:"cache.gif"})}),"\n",(0,r.jsx)(n.p,{children:"因为 fetch 请求的返回结果被缓存了，无论是否硬刷新，图片数据都会保持不变。"}),"\n",(0,r.jsxs)(n.h4,{id:"123-路由处理程序-get-请求",children:["1.2.3. 路由处理程序 GET 请求",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#123-路由处理程序-get-请求",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["第二种在路由处理程序中使用，新建 ",(0,r.jsx)(n.code,{children:"app/api/cache/route.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export async function GET() {\n  const res = await fetch('https://dog.ceo/api/breeds/image/random')\n  \n  const data = await res.json()\n  return Response.json({ data })\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm run dev"}),"，开启开发模式："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"cache-5.gif"})}),"\n",(0,r.jsx)(n.p,{children:"开发模式下，浏览器硬刷新的时候会跳过缓存，普通刷新的时候则会命中缓存。可以看到第一次硬刷新的时候，请求接口时间为 912ms，后面普通刷新的时候，因为使用缓存中的数据，数据返回时间都是 1ms 左右。"}),"\n",(0,r.jsxs)(n.p,{children:["运行 ",(0,r.jsx)(n.code,{children:"npm run build && npm run start"})," 开启生产版本："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"cache-6.gif"})}),"\n",(0,r.jsx)(n.p,{children:"因为 fetch 请求的返回结果被缓存了，无论是否硬刷新，接口数据都会保持不变。"}),"\n",(0,r.jsxs)(n.h3,{id:"13-重新验证",children:["1.3. 重新验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-重新验证",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"在 Next.js 中，清除数据缓存并重新获取最新数据的过程就叫做重新验证（Revalidation）。"})}),"\n",(0,r.jsx)(n.p,{children:"Next.js 提供了两种方式重新验证："}),"\n",(0,r.jsxs)(n.p,{children:["一种是",(0,r.jsx)(n.strong,{children:"基于时间的重新验证（Time-based revalidation）"}),"，即经过一定时间并有新请求产生后重新验证数据，适用于不经常更改且新鲜度不那么重要的数据。"]}),"\n",(0,r.jsxs)(n.p,{children:["一种是",(0,r.jsx)(n.strong,{children:"按需重新验证（On-demand revalidation）"}),"，根据事件手动重新验证数据。按需重新验证又可以使用基于标签（tag-based）和基于路径（path-based）两种方法重新验证数据。适用于需要尽快展示最新数据的场景。"]}),"\n",(0,r.jsxs)(n.h4,{id:"基于时间的重新验证",children:["基于时间的重新验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基于时间的重新验证",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["使用基于时间的重新验证，你需要在使用 fetch 的时候设置 ",(0,r.jsx)(n.code,{children:"next.revalidate"})," 选项（以秒为单位）："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"fetch('https://...', { next: { revalidate: 3600 } })\n"})}),"\n",(0,r.jsxs)(n.p,{children:["或者通过",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079033223446554",target:"_blank",rel:"noopener noreferrer",children:"路由段配置项"}),"进行配置，使用这种方法，它会重新验证该路由段所有的 ",(0,r.jsx)(n.code,{children:"fetch"})," 请求。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// layout.jsx | page.jsx | route.js\nexport const revalidate = 3600\n"})}),"\n",(0,r.jsxs)(n.p,{children:["注：在一个静态渲染的路由中，如果你有多个请求，每个请求设置了不同的重新验证时间，将会使用最短的时间用于所有的请求。而对于动态渲染的路由，每一个 ",(0,r.jsx)(n.code,{children:"fetch"}),"请求都将独立重新验证。"]}),"\n",(0,r.jsxs)(n.h4,{id:"按需重新验证",children:["按需重新验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#按需重新验证",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["使用按需重新验证，在",(0,r.jsx)(n.strong,{children:"路由处理程序或者 Server Action"})," 中通过路径（ ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-12",target:"_blank",rel:"noopener noreferrer",children:"revalidatePath"}),"） 或缓存标签 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-23",target:"_blank",rel:"noopener noreferrer",children:"revalidateTag"})," 实现。"]}),"\n",(0,r.jsxs)(n.h5,{id:"revalidatepath",children:["revalidatePath",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#revalidatepath",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"app/api/revalidatePath/route.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { revalidatePath } from 'next/cache'\n \nexport async function GET(request) {\n  const path = request.nextUrl.searchParams.get('path')\n \n  if (path) {\n    revalidatePath(path)\n    return Response.json({ revalidated: true, now: Date.now() })\n  }\n \n  return Response.json({\n    revalidated: false,\n    now: Date.now(),\n    message: 'Missing path to revalidate',\n  })\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时访问 ",(0,r.jsx)(n.code,{children:"/api/revalidatePath?path=/"})," 就会更新 ",(0,r.jsx)(n.code,{children:"/"})," 的 fetch 请求返回数据，交互效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"cache-7.gif"})}),"\n",(0,r.jsxs)(n.p,{children:["此时访问 ",(0,r.jsx)(n.code,{children:"/api/revalidatePath?path=/api/cache"})," 就会更新 ",(0,r.jsx)(n.code,{children:"/api/cache"})," 的 fetch 请求返回数据，交互效果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"cache-8.gif"})}),"\n",(0,r.jsx)(n.p,{children:"注意：这两张图演示的是开发模式下的情况，用 revalidatePath 确实更新了对应路径上的 fetch 缓存结果。但如果大家部署到生产版本，你是发现 revalidatePath 只对页面生效，对路由处理程序并不生效。"}),"\n",(0,r.jsxs)(n.p,{children:["这是因为 ",(0,r.jsx)(n.code,{children:"/api/cache"})," 被静态渲染了，首先你要将 ",(0,r.jsx)(n.code,{children:"/api/cache"})," 转为动态渲染，然后才能测试 revalidatePath 的效果。但是转为动态渲染，比如使用 cookies 等函数，又会触发 Next.js 的自动逻辑，让 fetch 请求退出缓存。"]}),"\n",(0,r.jsx)(n.p,{children:"简而言之，如果你想在生产环境测试 revalidatePath 对路由处理程序的影响，你需要多做一些配置："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 路由动态渲染\nexport const revalidate = 0\n// fetch 强制缓存\nexport const fetchCache = 'force-cache'\nexport async function GET() {\n  const res = await fetch('https://dog.ceo/api/breeds/image/random')\n  \n  const data = await res.json()\n  return Response.json({ data, now: Date.now() })\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样的代码在生产环境下，是可以被 revalidatePath 重新验证的。效果同开发模式下的截图。"}),"\n",(0,r.jsxs)(n.h5,{id:"revalidatetag",children:["revalidateTag",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#revalidatetag",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Next.js 有一个路由标签系统，可以跨路由实现多个 fetch 请求重新验证。具体这个过程为："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"使用 fetch 的时候，设置一个或者多个标签标记请求"}),"\n",(0,r.jsx)(n.li,{children:"调用 revalidateTag 方法重新验证该标签对应的所有请求"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// app/page.js\nexport default async function Page() {\n  const res = await fetch('https://...', { next: { tags: ['collection'] } })\n  const data = await res.json()\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这个例子中，为 ",(0,r.jsx)(n.code,{children:"fetch"})," 请求添加了一个 ",(0,r.jsx)(n.code,{children:"collection"}),"标签。在 Server Action 中调用 ",(0,r.jsx)(n.code,{children:"revalidateTag"}),"，就可以让所有带 ",(0,r.jsx)(n.code,{children:"collection"})," 标签的 fetch 请求重新验证。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// app/actions.js\n'use server'\n \nimport { revalidateTag } from 'next/cache'\n \nexport default async function action() {\n  revalidateTag('collection')\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["让我们真的写个例子。修改 ",(0,r.jsx)(n.code,{children:"app/page.js"})," 代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"async function getData() {\n  const res = await fetch('https://api.thecatapi.com/v1/images/search', { next: { tags: ['collection'] } })\n  if (!res.ok) {\n    throw new Error('Failed to fetch data')\n  }\n \n  return res.json()\n}\n\nexport default async function Page() {\n  const data = await getData()\n  \n  return <img src={data[0].url} width=\"300\" />\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"app/api/cache/route.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"export const revalidate = 0\nexport const fetchCache = 'force-cache'\n\nexport async function GET() {\n  const res = await fetch('https://dog.ceo/api/breeds/image/random', { next: { tags: ['collection'] } })\n  \n  const data = await res.json()\n  return Response.json({ data, now: Date.now() })\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["新建 ",(0,r.jsx)(n.code,{children:"app/api/revalidateTag/route.js"}),"，代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { revalidateTag } from 'next/cache'\n \nexport async function GET(request) {\n  const tag = request.nextUrl.searchParams.get('tag')\n  revalidateTag(tag)\n  return Response.json({ revalidated: true, now: Date.now() })\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时访问 ",(0,r.jsx)(n.code,{children:"/api/revalidateTag?tag=collection"})," 就会让 ",(0,r.jsx)(n.code,{children:"/"})," 页面和 ",(0,r.jsx)(n.code,{children:"/api/cache"})," 接口的数据都重新验证："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"cache-9.gif"})}),"\n",(0,r.jsxs)(n.h4,{id:"错误处理和重新验证",children:["错误处理和重新验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#错误处理和重新验证",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果在尝试重新验证的过程中出现错误，缓存会继续提供上一个重新生成的数据，而在下一个后续请求中，Next.js 会尝试再次重新验证数据。"}),"\n",(0,r.jsxs)(n.h3,{id:"14-退出数据缓存",children:["1.4. 退出数据缓存",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14-退出数据缓存",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["当 ",(0,r.jsx)(n.code,{children:"fetch"})," 请求满足这些条件时都会退出数据缓存："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fetch"})," 请求添加了 ",(0,r.jsx)(n.code,{children:"cache: 'no-store'"})," 选项"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fetch"})," 请求添加了 ",(0,r.jsx)(n.code,{children:"revalidate: 0"})," 选项"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fetch"})," 请求在路由处理程序中并使用了 ",(0,r.jsx)(n.code,{children:"POST"})," 方法"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["使用",(0,r.jsx)(n.code,{children:"headers"})," 或 ",(0,r.jsx)(n.code,{children:"cookies"})," 的方法之后使用 ",(0,r.jsx)(n.code,{children:"fetch"}),"请求"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["配置了路由段选项 ",(0,r.jsx)(n.code,{children:"const dynamic = 'force-dynamic'"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["配置了路由段选项 ",(0,r.jsx)(n.code,{children:"fetchCache"})," ，默认会跳过缓存"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"fetch"})," 请求使用了 ",(0,r.jsx)(n.code,{children:"Authorization"}),"或者 ",(0,r.jsx)(n.code,{children:"Cookie"}),"请求头，并且在组件树中其上方还有一个未缓存的请求"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"在具体使用的时候，如果你不想缓存某个单独请求："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// layout.js | page.js\nfetch('https://...', { cache: 'no-store' })\n"})}),"\n",(0,r.jsxs)(n.p,{children:["不缓存多个请求，可以借助",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079033223446554",target:"_blank",rel:"noopener noreferrer",children:"路由段配置项"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// layout.js | page.js\nexport const dynamic = 'force-dynamic'\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Next.js 推荐单独配置每个请求的缓存行为，这可以让你更精细化的控制缓存行为。"})}),"\n",(0,r.jsxs)(n.h2,{id:"2服务端使用三方请求库",children:["2.服务端使用三方请求库",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2服务端使用三方请求库",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["也不是所有时候都能使用 fetch 请求，如果你使用了不支持或者暴露 fetch 方法的三方库（如数据库、CMS 或 ORM 客户端），但又想实现数据缓存机制，那你可以使用 React 的 ",(0,r.jsx)(n.code,{children:"cache"})," 函数和路由段配置项来实现请求的缓存和重新验证。"]}),"\n",(0,r.jsx)(n.p,{children:"举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// app/utils.js\nimport { cache } from 'react'\n \nexport const getItem = cache(async (id) => {\n  const item = await db.item.findUnique({ id })\n  return item\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["现在我们调用两次 ",(0,r.jsx)(n.code,{children:"getItem"})," ："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// app/item/[id]/layout.js\nimport { getItem } from '@/utils/get-item'\n \nexport const revalidate = 3600\n \nexport default async function Layout({ params: { id } }) {\n  const item = await getItem(id)\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// app/item/[id]/page.js\nimport { getItem } from '@/utils/get-item'\n \nexport const revalidate = 3600\n \nexport default async function Page({ params: { id } }) {\n  const item = await getItem(id)\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这个例子中，尽管 ",(0,r.jsx)(n.code,{children:"getItem"})," 被调用两次，但只会产生一次数据库查询。"]}),"\n",(0,r.jsxs)(n.p,{children:["注：这里的代码并不是完整可运行的，如果想要细致了解 React Cache 函数的特性，可以查看： ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7348643498117038099#heading-5",target:"_blank",rel:"noopener noreferrer",children:"（技巧）当 Next.js 遇到频繁重复的数据库操作时，记住使用 React 的 cache 函数"})]}),"\n",(0,r.jsxs)(n.h2,{id:"3-客户端使用路由处理程序",children:["3. 客户端使用路由处理程序",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-客户端使用路由处理程序",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果你需要在客户端组件中获取数据，可以在客户端调用路由处理程序。路由处理程序会在服务端被执行，然后将数据返回给客户端，适用于不想暴露敏感信息给客户端（比如 API tokens）的场景。"}),"\n",(0,r.jsx)(n.p,{children:"如果你使用的是服务端组件，无须借助路由处理程序，直接获取数据即可。"}),"\n",(0,r.jsxs)(n.h2,{id:"4-客户端使用三方请求库",children:["4. 客户端使用三方请求库",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-客户端使用三方请求库",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["你也可以在客户端使用三方的库如 ",(0,r.jsx)(n.a,{href:"https://swr.vercel.app/",target:"_blank",rel:"noopener noreferrer",children:"SWR"})," 或 ",(0,r.jsx)(n.a,{href:"https://tanstack.com/query/latest",target:"_blank",rel:"noopener noreferrer",children:"React Query"})," 来获取数据。这些库都有提供自己的 API 实现记忆请求、缓存、重新验证和更改数据。"]}),"\n",(0,r.jsxs)(n.h2,{id:"5-建议与最佳实践",children:["5. 建议与最佳实践",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-建议与最佳实践",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"有一些在 React 和 Next.js 中获取数据的建议和最佳实践，本节来介绍一下："}),"\n",(0,r.jsxs)(n.h3,{id:"51-尽可能在服务端获取数据",children:["5.1. 尽可能在服务端获取数据",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-尽可能在服务端获取数据",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"尽可能在服务端获取数据，这样做有很多好处，比如："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"可以直接访问后端资源（如数据库）"}),"\n",(0,r.jsx)(n.li,{children:"防止敏感信息泄漏"}),"\n",(0,r.jsx)(n.li,{children:"减少客户端和服务端之间的来回通信，加快响应时间"}),"\n",(0,r.jsx)(n.li,{children:"..."}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"52-在需要的地方就地获取数据",children:["5.2. 在需要的地方就地获取数据",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-在需要的地方就地获取数据",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如果组件树中的多个组件使用相同的数据，无须先全局获取，再通过 props 传递，你可以直接在需要的地方使用 ",(0,r.jsx)(n.code,{children:"fetch"})," 或者 React ",(0,r.jsx)(n.code,{children:"cache"})," 获取数据，不用担心多次请求造成的性能问题，因为 ",(0,r.jsx)(n.code,{children:"fetch"})," 请求会自动被记忆化。这也同样适用于布局，毕竟本来父子布局之间也不能传递数据。"]}),"\n",(0,r.jsxs)(n.h3,{id:"53-适当的时候使用-streaming",children:["5.3. 适当的时候使用 Streaming",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#53-适当的时候使用-streaming",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["Streaming 和 ",(0,r.jsx)(n.code,{children:"Suspense"}),"都是 React 的功能，允许你增量传输内容以及渐进式渲染 UI 单元。页面可以直接渲染部分内容，剩余获取数据的部分会展示加载态，这也意味着用户不需要等到页面完全加载完才能与其交互。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["注：关于 Suspense 和 Streaming，我们会在 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7342436717142409242",target:"_blank",rel:"noopener noreferrer",children:"《渲染篇 | Suspense 与 Streaming》"})," 中详细讲解。"]}),"\n",(0,r.jsxs)(n.h3,{id:"54-串行获取数据",children:["5.4. 串行获取数据",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#54-串行获取数据",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 React 组件内获取数据时，有两种数据获取模式，并行和串行。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"所谓串行数据获取，数据请求相互依赖，形成瀑布结构，这种行为有的时候是必要的，但也会导致加载时间更长。"}),"\n",(0,r.jsx)(n.p,{children:"所谓并行数据获取，请求同时发生并加载数据，这会减少加载数据所需的总时间。"}),"\n",(0,r.jsx)(n.p,{children:"我们先说说串行数据获取，直接举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// app/artist/page.js\n// ...\n \nasync function Playlists({ artistID }) {\n  // 等待 playlists 数据\n  const playlists = await getArtistPlaylists(artistID)\n \n  return (\n    <ul>\n      {playlists.map((playlist) => (\n        <li key={playlist.id}>{playlist.name}</li>\n      ))}\n    </ul>\n  )\n}\n \nexport default async function Page({ params: { username } }) {\n  // 等待 artist 数据\n  const artist = await getArtist(username)\n \n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Playlists artistID={artist.id} />\n      </Suspense>\n    </>\n  )\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这个例子中，",(0,r.jsx)(n.code,{children:"Playlists"})," 组件只有当 ",(0,r.jsx)(n.code,{children:"Artist"})," 组件获得数据才会开始获取数据，因为 ",(0,r.jsx)(n.code,{children:"Playlists"})," 组件依赖 ",(0,r.jsx)(n.code,{children:"artistId"})," 这个 prop。这也很容易理解，毕竟只有先知道了是哪位艺术家，才能获取这位艺术家对应的曲目。"]}),"\n",(0,r.jsxs)(n.p,{children:["在这种情况下，你可以使用 ",(0,r.jsx)(n.code,{children:"loading.js"})," 或者 React 的 ",(0,r.jsx)(n.code,{children:"<Suspense>"})," 组件，展示一个即时加载状态，防止整个路由被数据请求阻塞，而且用户还可以与未被阻塞的部分进行交互。"]}),"\n",(0,r.jsx)(n.p,{children:"关于阻塞数据请求："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"一种防止出现串行数据请求的方法是在应用程序根部全局获取数据，但这会阻塞其下所有路由段的渲染，直到数据加载完毕。"}),"\n",(0,r.jsxs)(n.li,{children:["任何使用 ",(0,r.jsx)(n.code,{children:"await"})," 的 ",(0,r.jsx)(n.code,{children:"fetch"})," 请求都会阻塞渲染和下方所有组件的数据请求，除非它们使用了 ",(0,r.jsx)(n.code,{children:"<Suspense>"})," 或者 ",(0,r.jsx)(n.code,{children:"loading.js"}),"。另一种替代方式就是使用并行数据请求或者预加载模式。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"55-并行数据请求",children:["5.5. 并行数据请求",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#55-并行数据请求",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"要实现并行请求数据，你可以在使用数据的组件外定义请求，然后在组件内部调用，举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import Albums from './albums'\n\n// 组件外定义\nasync function getArtist(username) {\n  const res = await fetch(`https://api.example.com/artist/${username}`)\n  return res.json()\n}\n \nasync function getArtistAlbums(username) {\n  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n  return res.json()\n}\n \nexport default async function Page({ params: { username } }) {\n  // 组件内调用，这里是并行的\n  const artistData = getArtist(username)\n  const albumsData = getArtistAlbums(username)\n \n  // 等待 promise resolve\n  const [artist, albums] = await Promise.all([artistData, albumsData])\n \n  return (\n    <>\n      <h1>{artist.name}</h1>\n      <Albums list={albums}></Albums>\n    </>\n  )\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在这个例子中，",(0,r.jsx)(n.code,{children:"getArtist"})," 和 ",(0,r.jsx)(n.code,{children:"getArtistAlbums"})," 函数都是在 ",(0,r.jsx)(n.code,{children:"Page"})," 组件外定义，然后在 ",(0,r.jsx)(n.code,{children:"Page"})," 组件内部调用。用户需要等待两个 promise 都 resolve 后才能看到结果。"]}),"\n",(0,r.jsx)(n.p,{children:"为了提升用户体验，可以使用 Suspense 组件来分解渲染工作，尽快展示出部分结果。"}),"\n",(0,r.jsxs)(n.h3,{id:"56-预加载数据",children:["5.6. 预加载数据",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#56-预加载数据",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"防止出现串行请求的另外一种方式是使用预加载。举个例子："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// app/article/[id]/page.js\nimport Article, { preload, checkIsAvailable } from './components/Article'\n \nexport default async function Page({ params: { id } }) {\n  // 获取文章数据\n  preload(id)\n  // 执行另一个异步任务，这里是伪代码，比如判断文章是否有权限访问\n  const isAvailable = await checkIsAvailable()\n \n  return isAvailable ? <Article id={id} /> : null\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"而在具体的 preload 函数中，则要搭配 React 的 cache 函数一起使用："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// components/Article.js\nimport { getArticle } from '@/utils/get-article'\nimport { cache } from 'react'\n\nexport const getArticle = cache(async (id) => {\n  // ...\n})\n\nexport const preload = (id) => {\n	void getArticle(id)\n}\n\nexport const checkIsAvailable = (id) => {\n	// ...\n}\n\nexport default async function Article({ id }) {\n  const result = await getArticle(id)\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"57-使用-react-cache-server-only-和预加载模式",children:["5.7. 使用 React ",(0,r.jsx)(n.code,{children:"cache"})," ",(0,r.jsx)(n.code,{children:"server-only"})," 和预加载模式",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#57-使用-react-cache-server-only-和预加载模式",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["你可以将 ",(0,r.jsx)(n.code,{children:"cache"})," 函数，",(0,r.jsx)(n.code,{children:"preload"})," 模式和 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-15",target:"_blank",rel:"noopener noreferrer",children:"server-only"})," 包一起使用，创建一个可在整个应用使用的数据请求工具函数。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// utils/get-article.js\nimport { cache } from 'react'\nimport 'server-only'\n \nexport const preloadArticle = (id) => {\n  void getArticle(id)\n}\n \nexport const getArticle = cache(async (id) => {\n  // ...\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:["现在，你可以提前获取数据、缓存返回结果，并保证数据获取只发生在服务端。此外，布局、页面、组件都可以使用 ",(0,r.jsx)(n.code,{children:"utils/get-article.js"})]}),"\n",(0,r.jsxs)(n.p,{children:["注：如果想要细致了解 preload 函数和 server-only 以及 cache 的特性，可以查看： ",(0,r.jsx)(n.a,{href:"https://juejin.cn/post/7348643498117038099#heading-5",target:"_blank",rel:"noopener noreferrer",children:"（技巧）当 Next.js 遇到频繁重复的数据库操作时，记住使用 React 的 cache 函数"})]}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"恭喜你，完成了本篇内容的学习！"}),"\n",(0,r.jsx)(n.p,{children:"这一节我们介绍了请求数据的四种方式，重点介绍了服务端使用 fetch 的方式，这是因为 Next.js 拓展了原生的 fetch，增加了数据缓存和重新验证的逻辑。在 Next.js 中，为了提高性能，应该尽可能的使用缓存，但为了保证数据的时效性，也应该设置合理的重新验证逻辑。Next.js 推荐单独配置每个请求的缓存行为，这可以让你更精细化的控制缓存行为。"}),"\n",(0,r.jsx)(n.p,{children:"介绍完四种数据请求方式后，Next.js 提供了一些获取数据的建议和最佳实践，正是因为有了强大的缓存功能，所以在书写代码的时候可以就地获取数据，而不用担心相同请求多次发送造成的性能影响。"}),"\n",(0,r.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating",target:"_blank",rel:"noopener noreferrer",children:"Data Fetching: Fetching, Caching, and Revalidating | Next.js"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/data-fetching/patterns",target:"_blank",rel:"noopener noreferrer",children:"Data Fetching: Data Fetching Patterns | Next.js"})}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}let m=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F13.%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E7%AF%87%20_%20%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%8E%E9%87%8D%E6%96%B0%E9%AA%8C%E8%AF%81.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. 服务端使用 fetch",id:"1-服务端使用-fetch",depth:2},{text:"1.1. 基本用法",id:"11-基本用法",depth:3},{text:"1.2.  默认缓存",id:"12--默认缓存",depth:3},{text:"1.2.1. logging 配置项",id:"121-logging-配置项",depth:4},{text:"1.2.2. 服务端组件",id:"122-服务端组件",depth:4},{text:"1.2.3. 路由处理程序 GET 请求",id:"123-路由处理程序-get-请求",depth:4},{text:"1.3. 重新验证",id:"13-重新验证",depth:3},{text:"基于时间的重新验证",id:"基于时间的重新验证",depth:4},{text:"按需重新验证",id:"按需重新验证",depth:4},{text:"错误处理和重新验证",id:"错误处理和重新验证",depth:4},{text:"1.4. 退出数据缓存",id:"14-退出数据缓存",depth:3},{text:"2.服务端使用三方请求库",id:"2服务端使用三方请求库",depth:2},{text:"3. 客户端使用路由处理程序",id:"3-客户端使用路由处理程序",depth:2},{text:"4. 客户端使用三方请求库",id:"4-客户端使用三方请求库",depth:2},{text:"5. 建议与最佳实践",id:"5-建议与最佳实践",depth:2},{text:"5.1. 尽可能在服务端获取数据",id:"51-尽可能在服务端获取数据",depth:3},{text:"5.2. 在需要的地方就地获取数据",id:"52-在需要的地方就地获取数据",depth:3},{text:"5.3. 适当的时候使用 Streaming",id:"53-适当的时候使用-streaming",depth:3},{text:"5.4. 串行获取数据",id:"54-串行获取数据",depth:3},{text:"5.5. 并行数据请求",id:"55-并行数据请求",depth:3},{text:"5.6. 预加载数据",id:"56-预加载数据",depth:3},{text:"5.7. 使用 React `cache` `server-only` 和预加载模式",id:"57-使用-react-cache-server-only-和预加载模式",depth:3},{text:"小结",id:"小结",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"13.数据获取篇 _ 数据获取、缓存与重新验证",headingTitle:"13.数据获取篇 _ 数据获取、缓存与重新验证",frontmatter:{}}}}]);