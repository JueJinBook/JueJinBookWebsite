"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["33940"],{893447:function(e,n,s){e.exports=s.p+"static/image/75c4e673bff203a4688f2427eee3905c.94821e42.webp"},434424:function(e,n,s){s.r(n),s.d(n,{default:()=>h});var r=s(552676),l=s(740453),i=s(893447);let c=s.p+"static/image/54085dddd3190750948d28b6cce3a557.2389e766.webp",a=s.p+"static/image/afd8ffe34dc70d66aa799969f27e0678.ebf5c49c.webp",d=s.p+"static/image/4188c1673f5fa885fb62c3feff694fb0.b66e3437.webp";function t(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",ul:"ul",li:"li",h3:"h3",code:"code",pre:"pre",img:"img",blockquote:"blockquote"},(0,l.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"17原理篇-调度与时间片",children:["17.原理篇-调度与时间片",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#17原理篇-调度与时间片",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来的两个章节，我将重点介绍 React 的两大核心模块：调度（ Scheduler ）和调和（ Reconciler ）。"}),"\n",(0,r.jsx)(n.p,{children:"通过本章节学习，你将理解 React 异步调度的原理，以及 React 调度流程，从而解决面试中遇到的调度问题。"}),"\n",(0,r.jsx)(n.p,{children:"在正式讲解调度之前，有个问题可能大家都清楚，那就是 GUI 渲染线程和 JS 引擎线程是相互排斥的，比如开发者用 js 写了一个遍历大量数据的循环，在执行 js 时候，会阻塞浏览器的渲染绘制，给用户直观的感受就是卡顿。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"请带着这些问题，在本章节中找答案，收获更佳"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"异步调度原理？"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"React 为什么不用 settimeout ？"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"说一说React 的时间分片？"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"React 如何模拟 requestIdleCallback？"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"简述一下调度流程？"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"二-何为异步调度",children:["二 何为异步调度",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-何为异步调度",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"为什么采用异步调度",children:["为什么采用异步调度？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么采用异步调度",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"v15"})," 版本的 React 同样面临着如上的问题，由于对于大型的 React 应用，会存在一次更新，递归遍历大量的虚拟 DOM ，造成占用 js 线程，使得浏览器没有时间去做一些动画效果，伴随项目越来越大，项目会越来越卡。"]}),"\n",(0,r.jsx)(n.p,{children:"如何解决以上的问题呢，首先对比一下 vue 框架，vue 有这 template 模版收集依赖的过程，轻松构建响应式，使得在一次更新中，vue 能够迅速响应，找到需要更新的范围，然后以组件粒度更新组件，渲染视图。但是在 React 中，一次更新 React 无法知道此次更新的波及范围，所以 React 选择从根节点开始 diff ，查找不同，更新这些不同。"}),"\n",(0,r.jsx)(n.p,{children:"React 似乎无法打破从 root 开始‘找不同’的命运，但是还是要解决浏览器卡顿问题，那怎么办，解铃还须系铃人，既然更新过程阻塞了浏览器的绘制，那么把 React 的更新，交给浏览器自己控制不就可以了吗，如果浏览器有绘制任务那么执行绘制任务，在空闲时间执行更新任务，就能解决卡顿问题了。与 vue 更快的响应，更精确的更新范围，React 选择更好的用户体验。而今天即将讲的调度（ Scheduler ）就是具体的实现方式。"}),"\n",(0,r.jsxs)(n.h3,{id:"时间分片",children:["时间分片",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#时间分片",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"React 如何让浏览器控制 React 更新呢，首先浏览器每次执行一次事件循环（一帧）都会做如下事情：处理事件，执行 js ，调用 requestAnimation ，布局 Layout ，绘制 Paint ，在一帧执行后，如果没有其他事件，那么浏览器会进入休息时间，那么有的一些不是特别紧急 React 更新，就可以执行了。"}),"\n",(0,r.jsxs)(n.p,{children:["那么首先就是",(0,r.jsx)(n.strong,{children:"如何知道浏览器有空闲时间？"})]}),"\n",(0,r.jsx)(n.p,{children:"requestIdleCallback 是谷歌浏览器提供的一个 API， 在浏览器有空余的时间，浏览器就会调用 requestIdleCallback 的回调。首先看一下 requestIdleCallback的基本用法："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"requestIdleCallback(callback,{ timeout })\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"callback 回调，浏览器空余时间执行回调函数。"}),"\n",(0,r.jsx)(n.li,{children:"timeout 超时时间。如果浏览器长时间没有空闲，那么回调就不会执行，为了解决这个问题，可以通过 requestIdleCallback 的第二个参数指定一个超时时间。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"React 为了防止 requestIdleCallback 中的任务由于浏览器没有空闲时间而卡死，所以设置了 5 个优先级。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Immediate"}),"     -1      需要立刻执行。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"UserBlocking"}),"  250ms   超时时间250ms，一般指的是用户交互。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Normal"}),"        5000ms  超时时间5s，不需要直观立即变化的任务，比如网络请求。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Low"}),"           10000ms 超时时间10s，肯定要执行的任务，但是可以放在最后处理。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Idle"}),"                  一些没有必要的任务，可能不会执行。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"React 的异步更新任务就是通过类似 requestIdleCallback 去向浏览器做一帧一帧请求，等到浏览器有空余时间，去执行 React 的异步更新任务，这样保证页面的流畅。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"4.jpg"})}),"\n",(0,r.jsxs)(n.h3,{id:"模拟requestidlecallback",children:["模拟requestIdleCallback",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模拟requestidlecallback",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"但是 requestIdleCallback 目前只有谷歌浏览器支持 ，为了兼容每个浏览器，React需要自己实现一个 requestIdleCallback ，那么就要具备两个条件："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"1 实现的这个 requestIdleCallback ，可以主动让出主线程，让浏览器去渲染视图。"}),"\n",(0,r.jsx)(n.li,{children:"2 一次事件循环只执行一次，因为执行一个以后，还会请求下一次的时间片。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["能够满足上述条件的，就只有 ",(0,r.jsx)(n.strong,{children:"宏任务"}),"，宏任务是在下次事件循环中执行，不会阻塞浏览器更新。而且浏览器一次只会执行一个宏任务。首先看一下两种满足情况的宏任务。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"setTimeout(fn, 0)"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"setTimeout(fn, 0)"})," 可以满足创建宏任务，让出主线程，为什么 React 没选择用它实现 Scheduler 呢？原因是递归执行 setTimeout(fn, 0) 时，最后间隔时间会变成 4 毫秒左右，而不是最初的 1 毫秒。所以 React 优先选择的并不是 setTimeout 实现方案。"]}),"\n",(0,r.jsx)(n.p,{children:"接下来模拟一下 setTimeout 4毫秒延时的真实场景："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"let time = 0 \nlet nowTime = +new Date()\nlet timer\nconst poll = function(){\n    timer = setTimeout(()=>{\n        const lastTime = nowTime\n        nowTime = +new Date()\n        console.log( '递归setTimeout(fn,0)产生时间差：' , nowTime -lastTime )\n        poll()\n    },0)\n    time++\n    if(time === 20) clearTimeout(timer)\n}\npoll()\n"})}),"\n",(0,r.jsx)(n.p,{children:"效果："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"5.jpg"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"MessageChannel"})}),"\n",(0,r.jsxs)(n.p,{children:["为了让视图流畅地运行，可以按照人类能感知到最低限度每秒 60 帧的频率划分时间片，这样每个时间片就是 16ms 。也就是这 16 毫秒要完成如上 js 执行，浏览器绘制等操作，而上述 setTimeout 带来的浪费就足足有 4ms，react 团队应该是注意到这 4ms 有点过于铺张浪费，所以才采用了一个新的方式去实现，那就是 ",(0,r.jsx)(n.code,{children:"MessageChannel"})," 。"]}),"\n",(0,r.jsx)(n.p,{children:"MessageChannel 接口允许开发者创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"MessageChannel.port1 只读返回 channel 的 port1 。"}),"\n",(0,r.jsx)(n.li,{children:"MessageChannel.port2 只读返回 channel 的 port2 。\n下面来模拟一下 MessageChannel 如何触发异步宏任务的。"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  let scheduledHostCallback = null \n  /* 建立一个消息通道 */\n  var channel = new MessageChannel();\n  /* 建立一个port发送消息 */\n  var port = channel.port2;\n\n  channel.port1.onmessage = function(){\n      /* 执行任务 */\n      scheduledHostCallback() \n      /* 执行完毕，清空任务 */\n      scheduledHostCallback = null\n  };\n  /* 向浏览器请求执行更新任务 */\n  requestHostCallback = function (callback) {\n    scheduledHostCallback = callback;\n    if (!isMessageLoopRunning) {\n      isMessageLoopRunning = true;\n      port.postMessage(null);\n    }\n  };\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"在一次更新中，React 会调用 requestHostCallback ，把更新任务赋值给 scheduledHostCallback ，然后 port2 向 port1 发起 postMessage 消息通知。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"port1 会通过 onmessage ，接受来自 port2 消息，然后执行更新任务 scheduledHostCallback ，然后置空 scheduledHostCallback ，借此达到异步执行目的。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"三-异步调度原理",children:["三 异步调度原理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-异步调度原理",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上面说到了时间片的感念和 Scheduler 实现原理。接下来，来看一下调度任务具体的实现细节。React 发生一次更新，会统一走 ensureRootIsScheduled（调度应用）。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["对于正常更新会走 performSyncWorkOnRoot 逻辑，最后会走 ",(0,r.jsx)(n.code,{children:"workLoopSync"})," 。"]}),"\n",(0,r.jsxs)(n.li,{children:["对于低优先级的异步更新会走 performConcurrentWorkOnRoot 逻辑，最后会走 ",(0,r.jsx)(n.code,{children:"workLoopConcurrent"})," 。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"如下看一下workLoopSync，workLoopConcurrent。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.js"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function workLoopSync() {\n  while (workInProgress !== null) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    workInProgress = performUnitOfWork(workInProgress);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"在一次更新调度过程中，workLoop 会更新执行每一个待更新的 fiber 。他们的区别就是异步模式会调用一个 shouldYield() ，如果当前浏览器没有空余时间， shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历，从而达到终止渲染的目的。这样就解决了一次性遍历大量的 fiber ，导致浏览器没有时间执行一些渲染任务，导致了页面卡顿。"}),"\n",(0,r.jsxs)(n.h3,{id:"schedulecallback",children:["scheduleCallback",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#schedulecallback",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["无论是上述正常更新任务 ",(0,r.jsx)(n.code,{children:"workLoopSync"})," 还是低优先级的任务 ",(0,r.jsx)(n.code,{children:"workLoopConcurrent"})," ，都是由调度器 ",(0,r.jsx)(n.code,{children:"scheduleCallback"})," 统一调度的，那么两者在进入调度器时候有什么区别呢？"]}),"\n",(0,r.jsx)(n.p,{children:"对于正常更新任务，最后会变成类似如下结构："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"scheduleCallback(Immediate,workLoopSync)\n"})}),"\n",(0,r.jsx)(n.p,{children:"对于异步任务："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/* 计算超时等级，就是如上那五个等级 */\nvar priorityLevel = inferPriorityFromExpirationTime(currentTime, expirationTime);\nscheduleCallback(priorityLevel,workLoopConcurrent)\n"})}),"\n",(0,r.jsx)(n.p,{children:"低优先级异步任务的处理，比同步多了一个超时等级的概念。会计算上述那五种超时等级。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"scheduleCallback 到底做了些什么呢？"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"scheduler/src/Scheduler.js"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function scheduleCallback(){\n   /* 计算过期时间：超时时间  = 开始时间（现在时间） + 任务超时的时间（上述设置那五个等级）     */\n   const expirationTime = startTime + timeout;\n   /* 创建一个新任务 */\n   const newTask = { ... }\n  if (startTime > currentTime) {\n      /* 通过开始时间排序 */\n      newTask.sortIndex = startTime;\n      /* 把任务放在timerQueue中 */\n      push(timerQueue, newTask);\n      /*  执行setTimeout ， */\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n  }else{\n    /* 通过 expirationTime 排序  */\n    newTask.sortIndex = expirationTime;  \n    /* 把任务放入taskQueue */\n    push(taskQueue, newTask);\n    /*没有处于调度中的任务， 然后向浏览器请求一帧，浏览器空闲执行 flushWork */\n     if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n         requestHostCallback(flushWork)\n     }\n    \n  }\n  \n} \n"})}),"\n",(0,r.jsx)(n.p,{children:"对于调度本身，有几个概念必须掌握。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"taskQueue"}),"，里面存的都是过期的任务，依据任务的过期时间( ",(0,r.jsx)(n.code,{children:"expirationTime"})," ) 排序，需要在调度的 ",(0,r.jsx)(n.code,{children:"workLoop"})," 中循环执行完这些任务。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"timerQueue"})," 里面存的都是没有过期的任务，依据任务的开始时间( ",(0,r.jsx)(n.code,{children:"startTime"})," )排序，在调度 workLoop 中 会用",(0,r.jsx)(n.code,{children:"advanceTimers"}),"检查任务是否过期，如果过期了，放入 ",(0,r.jsx)(n.code,{children:"taskQueue"})," 队列。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"scheduleCallback 流程如下。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"创建一个新的任务 newTask。"}),"\n",(0,r.jsx)(n.li,{children:"通过任务的开始时间( startTime ) 和 当前时间( currentTime ) 比较:当 startTime > currentTime, 说明未过期, 存到 timerQueue，当 startTime <= currentTime, 说明已过期, 存到 taskQueue。"}),"\n",(0,r.jsx)(n.li,{children:"如果任务过期，并且没有调度中的任务，那么调度 requestHostCallback。本质上调度的是 flushWork。"}),"\n",(0,r.jsx)(n.li,{children:"如果任务没有过期，用 requestHostTimeout 延时执行 handleTimeout。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"requesthosttimeout",children:["requestHostTimeout",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#requesthosttimeout",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上述当一个任务，没有超时，那么 React 把它放入 timerQueue中了，但是它什么时候执行呢 ？这个时候 Schedule 用 requestHostTimeout 让一个未过期的任务能够到达恰好过期的状态， 那么需要延迟 startTime - currentTime 毫秒就可以了。requestHostTimeout 就是通过 setTimeout 来进行延时指定时间的。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"scheduler/src/Scheduler.js"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"requestHostTimeout = function (cb, ms) {\n_timeoutID = setTimeout(cb, ms);\n};\n\ncancelHostTimeout = function () {\nclearTimeout(_timeoutID);\n};\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"requestHostTimeout 延时执行 handleTimeout，cancelHostTimeout  用于清除当前的延时器。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"handletimeout",children:["handleTimeout",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#handletimeout",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"延时指定时间后，调用的 handleTimeout 函数， handleTimeout 会把任务重新放在 requestHostCallback 调度。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"scheduler/src/Scheduler.js"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function handleTimeout(){\n  isHostTimeoutScheduled = false;\n  /* 将 timeQueue 中过期的任务，放在 taskQueue 中 。 */\n  advanceTimers(currentTime);\n  /* 如果没有处于调度中 */\n  if(!isHostCallbackScheduled){\n      /* 判断有没有过期的任务， */\n      if (peek(taskQueue) !== null) {   \n      isHostCallbackScheduled = true;\n      /* 开启调度任务 */\n      requestHostCallback(flushWork);\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"通过 advanceTimers 将 timeQueue 中过期的任务转移到 taskQueue 中。"}),"\n",(0,r.jsx)(n.li,{children:"然后调用 requestHostCallback 调度过期的任务。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"advancetimers",children:["advanceTimers",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#advancetimers",children:"#"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"scheduler/src/Scheduler.js advanceTimers"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function advanceTimers(){\n   var timer = peek(timerQueue);\n   while (timer !== null) {\n      if(timer.callback === null){\n        pop(timerQueue);\n      }else if(timer.startTime <= currentTime){ /* 如果任务已经过期，那么将 timerQueue 中的过期任务，放入taskQueue */\n         pop(timerQueue);\n         timer.sortIndex = timer.expirationTime;\n         push(taskQueue, timer);\n      }\n   }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"如果任务已经过期，那么将 timerQueue 中的过期任务，放入 taskQueue。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"flushwork和workloop",children:["flushWork和workloop",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#flushwork和workloop",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"综上所述要明白两件事："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"第一件是 React 的更新任务最后都是放在 taskQueue 中的。"}),"\n",(0,r.jsx)(n.li,{children:"第二件是 requestHostCallback ，放入 MessageChannel 中的回调函数是flushWork。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"flushWork"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"scheduler/src/Scheduler.js flushWork"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function flushWork(){\n  if (isHostTimeoutScheduled) { /* 如果有延时任务，那么先暂定延时任务*/\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n  try{\n     /* 执行 workLoop 里面会真正调度我们的事件  */\n     workLoop(hasTimeRemaining, initialTime)\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"flushWork 如果有延时任务执行的话，那么会先暂停延时任务，然后调用 workLoop ，去真正执行超时的更新任务。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"workLoop"})}),"\n",(0,r.jsx)(n.p,{children:"这个 workLoop 是调度中的 workLoop，不要把它和调和中的 workLoop 弄混淆了。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function workLoop(){\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n  /* 获取任务列表中的第一个 */\n  currentTask = peek();\n  while (currentTask !== null){\n      /* 真正的更新函数 callback */\n      var callback = currentTask.callback;\n      if(callback !== null ){\n         /* 执行更新 */\n         callback()\n        /* 先看一下 timeQueue 中有没有 过期任务。 */\n        advanceTimers(currentTime);\n      }\n      /* 再一次获取任务，循环执行 */ \n      currentTask = peek(taskQueue);\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["workLoop 会依次更新过期任务队列中的任务。",(0,r.jsx)(n.strong,{children:"到此为止，完成整个调度过程。"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"shouldyield-中止-workloop",children:["shouldYield 中止 workloop",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#shouldyield-中止-workloop",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在 fiber 的异步更新任务 workLoopConcurrent 中，每一个 fiber 的 workloop 都会调用 shouldYield 判断是否有超时更新的任务，如果有，那么停止 workLoop。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"scheduler/src/Scheduler.js unstable_shouldYield"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function unstable_shouldYield() {\n  var currentTime = exports.unstable_now();\n  advanceTimers(currentTime);\n  /* 获取第一个任务 */\n  var firstTask = peek(taskQueue);\n  return firstTask !== currentTask && currentTask !== null && firstTask !== null && firstTask.callback !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"如果存在第一个任务，并且已经超时了，那么 shouldYield 会返回 true，那么会中止 fiber 的 workloop。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"调度流程图",children:["调度流程图",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#调度流程图",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"整个调度流程，用一个流程图表示:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"2.jpg"})}),"\n",(0,r.jsxs)(n.h3,{id:"调和--异步调度-流程总图",children:["调和 + 异步调度 流程总图",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#调和--异步调度-流程总图",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"异步调度过程，如下图所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"3.jpeg"})}),"\n",(0,r.jsxs)(n.h2,{id:"四-总结",children:["四 总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章节学习了 React 调度原理和流程，下一节，将学习 React Reconciler 调和流程。"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let h=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F17.%E5%8E%9F%E7%90%86%E7%AF%87-%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%97%B6%E9%97%B4%E7%89%87.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二 何为异步调度",id:"二-何为异步调度",depth:2},{text:"为什么采用异步调度？",id:"为什么采用异步调度",depth:3},{text:"时间分片",id:"时间分片",depth:3},{text:"模拟requestIdleCallback",id:"模拟requestidlecallback",depth:3},{text:"三 异步调度原理",id:"三-异步调度原理",depth:2},{text:"scheduleCallback",id:"schedulecallback",depth:3},{text:"requestHostTimeout",id:"requesthosttimeout",depth:3},{text:"handleTimeout",id:"handletimeout",depth:3},{text:"advanceTimers",id:"advancetimers",depth:3},{text:"flushWork和workloop",id:"flushwork和workloop",depth:3},{text:"shouldYield 中止 workloop",id:"shouldyield-中止-workloop",depth:3},{text:"调度流程图",id:"调度流程图",depth:3},{text:"调和 + 异步调度 流程总图",id:"调和--异步调度-流程总图",depth:3},{text:"四 总结",id:"四-总结",depth:2}],title:"17.原理篇-调度与时间片",headingTitle:"17.原理篇-调度与时间片",frontmatter:{}}}}]);