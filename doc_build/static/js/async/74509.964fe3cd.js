"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["74509"],{236549:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var d=r(552676),a=r(740453);let i=r.p+"static/image/a1125592ecda6d74445630d024223ae0.c74c3a27.webp",s=r.p+"static/image/d9c80870ee6e2f092baee0d251da16cf.8b21d928.webp",c=r.p+"static/image/6abc136f2abe21a46abaaff72de8ade9.24f3da83.webp",t=r.p+"static/image/64044891e4884a8d0948267e4a7049d3.1ff4ea0e.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",img:"img",h3:"h3",pre:"pre"},(0,a.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"26-到达目的地-应用程序发布",children:["26.\uD83C\uDFC6 到达目的地-应用程序发布",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#26-到达目的地-应用程序发布",children:"#"})]}),"\n",(0,d.jsxs)(n.h2,{id:"前言",children:["前言",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["至此，我们的工作已经完成了 ",(0,d.jsx)(n.code,{children:"100%"}),"，只要你保证不做更改，那么自动更新就没必要。但，你能确保真不做任何修改吗？"]}),"\n",(0,d.jsx)(n.p,{children:"如果有一天，你期望如下图一样，发布了最新版本，用户能收到更新提示，那自动更新就必须得整了。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:t,alt:"企业微信截图_080a4572-001b-4240-b96a-a75b01523317.png"})}),"\n",(0,d.jsxs)(n.h2,{id:"流程",children:["流程",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#流程",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"按照我的理解，应用程序的安装包存放在某台云服务器上，里面存放的是新版本的应用程序。"}),"\n",(0,d.jsx)(n.p,{children:"当我安装的应用程序运行时，会进行自动检测，检测到本地的应用程序与线上服务器的应用程序，版本不一致时，发现有新版本，那么就需要提示，告知有新版本，是否进行更新。"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,d.jsx)(n.p,{children:"那么如何实现自动更新呢？"}),"\n",(0,d.jsxs)(n.h3,{id:"1-纯云端化",children:["1. 纯云端化",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-纯云端化",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"可能有人不太理解，我来细说一哈～"}),"\n",(0,d.jsxs)(n.p,{children:["我说 electron 就是套个壳，应该没人反驳我吧？假设我们现在不需要用到任何原生能力，就纯粹的使用 electron 套个壳，通过 ",(0,d.jsx)(n.code,{children:"webview"})," 的方式加载一个云端链接。如果你想实现内容最新，那么只需要保证云端服务器上的代码是最新的即可，不需要进行应用发版。"]}),"\n",(0,d.jsxs)(n.p,{children:["说的通俗点，我在 electron 中通过 webview 的方式加载 ",(0,d.jsx)(n.code,{children:"https://juejin.cn"}),"，这时候排版有些问题，更改了一小部分代码，讲道理我需要应用程序发版吗？不需要！"]}),"\n",(0,d.jsxs)(n.h3,{id:"2-electron-updater",children:["2. electron-updater",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-electron-updater",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["网上很多自动更新配置的文章，大家可以自行前往查询一下，下面给大家摘抄一部分组内项目的自动更新的代码（脱敏过的），或者小伙伴们可以看看 ",(0,d.jsx)(n.a,{href:"https://www.electron.build/auto-update",target:"_blank",rel:"noopener noreferrer",children:"electron-builder"})," 文档"]}),"\n",(0,d.jsxs)(n.p,{children:["在 package.json 中，我们配置一下 ",(0,d.jsx)(n.code,{children:"publish"})]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:'{\n  "build": {\n    "publish": [\n      {\n        "provider": "generic",\n        "url": "http://xxxxxx/download/",\n      }\n    ]\n  }\n}\n'})}),"\n",(0,d.jsxs)(n.p,{children:["然后我们去应用程序主进程代码中，调用 ",(0,d.jsx)(n.code,{children:"electron-updater"})," 模块检测更新"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"const { autoUpdater } = require('electron-updater');\n\nfunction checkVersionUpdate() {\n  autoUpdater.autoDownload = false; // 将自动下载包设置为false\n\n  //检测更新\n  autoUpdater.checkForUpdates();\n\n  //监听'error'事件\n  autoUpdater.on('error', (err) => {});\n\n  // 检查更新是否已开始时发出\n  autoUpdater.on('checking-for-update', () => {});\n\n  // 检测有可更新的应用包\n  autoUpdater.on('update-available', (info) => {});\n\n  // 检测没有可用更新时发出\n  autoUpdater.on('update-not-available', (info) => {});\n\n  // 下载可更新的安装包\n  autoUpdater.on('update-downloaded', (info) => {});\n\n  // 监听下载进度\n  autoUpdater.on('download-progress', (info) => {});\n}\n\napp.on('ready', () => {\n  checkVersionUpdate();\n});\n"})}),"\n",(0,d.jsxs)(n.p,{children:["应用更新的依据是 ",(0,d.jsx)(n.code,{children:".yml"})," 文件，由于 ",(0,d.jsx)(n.code,{children:"autoUpdater"})," 的一些方法是只能在打包 release 时才会触发，也就是你想调试一下样式或者自测，你每次改完代码都需要 ",(0,d.jsx)(n.code,{children:"build"})," 一下，极度蛋疼，所以我们可以在本地建一个测试用的 ",(0,d.jsx)(n.code,{children:".yml"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"这也就是为什么你常会看到这样的一段代码"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"export function isDev() {\n  return process.env.NODE_ENV === 'development';\n}\n\napp.on('ready', () => {\n  if (isDev()) {\n    autoUpdater.updateConfigPath = path.join(__dirname, '../dev-update.yml');\n  }\n  checkVersionUpdate();\n});\n"})}),"\n",(0,d.jsxs)(n.p,{children:["这里的 ",(0,d.jsx)(n.code,{children:"dev-update.yml"})," 就是我们默认创建用于调试的 ",(0,d.jsx)(n.code,{children:".yml"})]}),"\n",(0,d.jsx)(n.p,{children:"自动更新的方式有许多种，你可以自己搭一个服务器放安装包，也可以基于 github 方案实现，小伙伴可以私下研究一波，有问题可在群里提问～"}),"\n",(0,d.jsxs)(n.h2,{id:"本地化云端化结合",children:["本地化+云端化结合",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本地化云端化结合",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"一般来讲，我们的应用很复杂，模块很多，那么势必会存在一些模块不常更新，一些模块经常更新。"}),"\n",(0,d.jsx)(n.p,{children:"怎么理解呢，我举个小例子，你现在在做一个音乐播放器应用。你的用户模块不常变化，而歌单模块经常迭代更新。每次更新，意味着要发版本，发版本意味着用户又要更新，用户频繁更新应用，就会吐槽，吐槽多了，你就被骂，被骂多了，你上班就不快乐，上班不快乐你就没心思打工..."}),"\n",(0,d.jsx)(n.p,{children:"那么如何解决呢？其实可以采用本地化+云端化的方式，将频繁更改迭代的模块找出来，做成云端化，也就是将歌单模块，做成 web 端，部署在云端，在 electron 中，通过 iframe / webview 的形式加载歌单模块的链接。如下图所示"}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,d.jsx)(n.p,{children:"A、B、C、用户模块都是不常变的，而歌单模块是频繁迭代的，所以我们将它抽离出去，变成一个独立的应用，开发完毕之后，部署在服务器上，我们在应用中通过 iframe / webview 的形式加载进来。"}),"\n",(0,d.jsx)(n.p,{children:"在下次迭代更新时，我们只需要开发歌单模块，然后部署线上即可，应用加载的始终是线上链接，这样就不需要发版了。"}),"\n",(0,d.jsxs)(n.p,{children:["你可能会疑惑，如果歌单模块需要用到 electron 本地原生能力呢？比如你用的是 iframe，那么你可以通过 ",(0,d.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage",target:"_blank",rel:"noopener noreferrer",children:"postMessage"})," 进行通信。总之都有方法能够解决。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,d.jsxs)(n.h2,{id:"最后",children:["最后",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#最后",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"本章节更多的是讲解自动更新的思路和核心步骤，还是希望小伙伴们能结合文档和自行查询文章去动手操作。"}),"\n",(0,d.jsx)(n.p,{children:"如果对本章节存在疑问，欢迎在评论区留言。如果觉得阿宽哪里表达错误，可指出，虚心请教～"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}let o=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F26.%F0%9F%8F%86%20%E5%88%B0%E8%BE%BE%E7%9B%AE%E7%9A%84%E5%9C%B0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"流程",id:"流程",depth:2},{text:"1. 纯云端化",id:"1-纯云端化",depth:3},{text:"2. electron-updater",id:"2-electron-updater",depth:3},{text:"本地化+云端化结合",id:"本地化云端化结合",depth:2},{text:"最后",id:"最后",depth:2}],title:"26.\uD83C\uDFC6 到达目的地-应用程序发布",headingTitle:"26.\uD83C\uDFC6 到达目的地-应用程序发布",frontmatter:{}}}}]);