"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["21953"],{565384:function(n,r,e){e.r(r),e.d(r,{default:()=>t});var i=e(552676),l=e(740453);function s(n){let r=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ol:"ol",li:"li",h2:"h2",pre:"pre",code:"code",ul:"ul",blockquote:"blockquote",br:"br"},(0,l.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.h1,{id:"第10章函数一构建轮子",children:["第10章—函数一｜构建“轮子”",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#第10章函数一构建轮子",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"\uFEFF在编程领域，我们经常听到一个词——“轮子”，也经常听到一句话——“不要重复造轮子”。这其中的“轮子”在一定程度上就是指本讲以及后续几讲中介绍的“函数”。"}),"\n",(0,i.jsx)(r.p,{children:"实际上，在前面的几讲内容中，我们已经或多或少地用过函数了。比如获取容器内元素个数的len()，用于在控制台输出字符串的fmt.println()等等。这些都是Go SDK中内置的函数，通过这些内置的函数，可以实现一些需求，但并不是全部。有些时候还需要我们实现自定义的函数，以满足项目的独特性需求。"}),"\n",(0,i.jsx)(r.p,{children:"举个例子，还记得我们一直使用的查找素数示例吗？如果要更改查找范围，一直以来的方法是修改最外层循环的终止条件。实际上，更“聪明”的做法是将查找素数的逻辑封装为函数，将循环终止的条件设置为函数的参数。调用这个函数时，只要传入不同的参数，即可实现对查找范围的控制了。是不是很方便呢？"}),"\n",(0,i.jsxs)(r.p,{children:["像这种做一次即可反复使用的函数、库等等，就可以称其为“轮子”。它们的共同特点便是：",(0,i.jsx)(r.strong,{children:"直接拿来就能用，塞进项目中就能实现想要的一个或多个功能"}),"。因此，对于已经存在且足够好用的轮子，就“不要重复造轮子”了。"]}),"\n",(0,i.jsx)(r.p,{children:"本讲就来介绍如何定义、调用函数及相关的技巧和注意事项，具体如下："}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"普通函数的定义和调用"}),"\n",(0,i.jsx)(r.li,{children:"函数的延迟调用"}),"\n"]}),"\n",(0,i.jsxs)(r.h2,{id:"普通函数的定义和调用",children:["普通函数的定义和调用",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#普通函数的定义和调用",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"现在，我们就来逐步将查找素数的逻辑封装为函数。"}),"\n",(0,i.jsx)(r.p,{children:"在Go语言中，定义一个普通函数的格式如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"func function_name([params_list])([return_values_list]){\r\n    // 函数体\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"其中，func关键字表示定义一个函数；function_name是函数名；params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。"}),"\n",(0,i.jsx)(r.p,{children:"先举个简单的例子，下面的函数实现了将参数（即传入的string类型字符串）作为返回值（类型也为string）输出。"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"func stringLoop(content string) string {\r\n   return content\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"这段代码一共有三行，我们逐行拆解："}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"第一行定义了名为stringLoop的函数，参数列表中，content是参数名，string是参数的类型。当需要多个参数是，使用英文的逗号（,）隔开。再往后表示该函数运行后将返回string类型的结果；"}),"\n",(0,i.jsx)(r.li,{children:"第二行是函数体，return表示返回函数运行的结果。本例是直接将传入的参数——content变量的值返回；"}),"\n",(0,i.jsx)(r.li,{children:"第三行是函数的结尾。"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.code,{children:"❗️ 注意： return语句一般在函数结尾处出现，在该语句后的代码不会被执行。"})}),"\n",(0,i.jsx)(r.p,{children:"下面，尝试调用这个函数，整个函数定义与调用的示例如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'func main() {\r\n   result := stringLoop("字符串回环测试")\r\n   fmt.Println(result)\r\n}\r\n\r\n// 用于测试的自定义函数\r\nfunc stringLoop(content string) string {\r\n   return content\r\n}\n'})}),"\n",(0,i.jsx)(r.p,{children:"显然，整个程序代码由两个函数组成：main()和stringLoop()。程序运行后，main()函数被调用，声明了result变量，该变量的值来自stringLoop()函数的运行结果。在调用stringLoop()函数时，向其中传入了“字符串回环测试”的字样，因此这个函数运行后，也将原样返回这些文字。并将这些文字赋值到result变量。最后，调用了fmt.Println()函数，输出了result的值。因此，甚至无需真的运行，我们便可得知程序的运行输出结果应该是："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"字符串回环测试"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.code,{children:"❗️ 注意： main()函数和stringLoop()函数时两个不同的函数，Go语言不允许函数的嵌套，因此两个函数应独立定义和实现。"})}),"\n",(0,i.jsx)(r.p,{children:"接下来，我们依葫芦画瓢，改造查找素数的案例，使其用起来更加自由，成为可靠的“轮子”。"}),"\n",(0,i.jsx)(r.p,{children:"为了方便对比，我先将原有的代码搬过来："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"func main() {\r\n   var resultSlice []int\r\n   for i := 2; i < 10; i++ {\r\n      //假定i为素数\r\n      flag := true\r\n      for j := 2; j < i; j++ {\r\n         if i%j == 0 {\r\n            //当i能被某个整数整除时，不是素数\r\n            flag = false\r\n         }\r\n      }\r\n      //如果依旧为true，则i为素数\r\n      if flag {\r\n         //将素数存放到resultSlice数组中\r\n         resultSlice = append(resultSlice, i)\r\n      }\r\n   }\r\n   fmt.Println(resultSlice)\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"要做的只有一件事：将参数作为查找范围实现更自由地调用。"}),"\n",(0,i.jsx)(r.p,{children:"我们已经知道，上述代码中查找素数的逻辑实际上就是从头开始，直到输出resultSlice变量为止。因此，我们便可将这部分代码提取出来，封装为一个函数，我们将这个函数起名为findPrimeNumber（查找素数）。显然，该函数需要一个int型的参数，表示查找的最大范围；还需要切片类型的返回值，表示查找的结果。因此，该函数的定义和实现代码如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"func findPrimeNumber(max int) []int {\r\n   var resultSlice []int\r\n   for i := 2; i < max; i++ {\r\n      //假定i为素数\r\n      flag := true\r\n      for j := 2; j < i; j++ {\r\n         if i%j == 0 {\r\n            //当i能被某个整数整除时，不是素数\r\n            flag = false\r\n         }\r\n      }\r\n      //如果依旧为true，则i为素数\r\n      if flag {\r\n         //将素数存放到resultSlice数组中\r\n         resultSlice = append(resultSlice, i)\r\n      }\r\n   }\r\n   return resultSlice\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"接着，继续改动main()函数，调用findPrimeNumber()，并输出查询结果。"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"func main() {\r\n   var resultSlice []int\r\n   resultSlice = findPrimeNumber(10)\r\n   fmt.Println(resultSlice)\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"运行整个程序，如无意外，则可在控制台中看到如下输出："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"[2 3 5 7]"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"到此，findPrimeNumber()函数便成为了一个合格的“轮子”。通过传入不同的int值，可实现查找特定范围内的素数之功能。"}),"\n",(0,i.jsx)(r.p,{children:"接下来抛出一个思考题：在这段代码中，main()函数中的resultSlice和findPrimeNumber()中的resultSlice有何关系呢？"}),"\n",(0,i.jsx)(r.p,{children:"答案是：这二者之间没有任何关系！因为main()函数和findPrimeNumber()函数是两个函数，互相独立，互不影响。各自的resultSlice变量都是在各自的函数体内声明和使用的，无法共用，只是凑巧名称和类型都一样而已。大家不要将它俩混为一谈。"}),"\n",(0,i.jsx)(r.p,{children:"如果理解了这一点，我们再来看看下面这段代码。不要在GoLand中运行，先猜猜它的运行结果："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"func main() {\r\n   var resultSlice []int\r\n   findPrimeNumber(resultSlice, 10)\r\n   fmt.Println(resultSlice)\r\n}\r\n\r\nfunc findPrimeNumber(result []int, max int) {\r\n   for i := 2; i < max; i++ {\r\n      //假定i为素数\r\n      flag := true\r\n      for j := 2; j < i; j++ {\r\n         if i%j == 0 {\r\n            //当i能被某个整数整除时，不是素数\r\n            flag = false\r\n         }\r\n      }\r\n      //如果依旧为true，则i为素数\r\n      if flag {\r\n         //将素数存放到result数组中\r\n         result = append(result, i)\r\n      }\r\n   }\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"答案揭晓：这段程序的运行结果为："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"[]"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"相信不少人看到这里会一脸懵。为什么我把main()函数中的resultSlice传入findPrimeNumber()了，并且在findPrimeNumber()中对其做了修改，却并没有使resultSlice发生变化呢？"}),"\n",(0,i.jsx)(r.p,{children:"要解开这个谜团，我们不妨输出 main()函数中resultSlice和findPrimeNumber()中，result的内存地址。因为只有这二者的地址相同，才能证明这两个变量是“一回事”。"}),"\n",(0,i.jsx)(r.p,{children:"输出内存地址的代码示例如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"ptr := &variable\r\nfmt.Println(&ptr)\n"})}),"\n",(0,i.jsx)(r.p,{children:"其中，variable表示变量名，对应本例为main()中的resultSlice和findPrimeNumber()中的result。"}),"\n",(0,i.jsx)(r.p,{children:"这一对比的结果是显而易见的，main()中的resultSlice和findPrimeNumber()中的result，二者内存地址是不同的！这也就意味着，无论result变量在findPrimeNumber()中作出如何改变，都无法作用到main()中的resultSlice变量上。问题也就跟着来了：在函数间传值的过程中，到底发生了什么呢？"}),"\n",(0,i.jsxs)(r.p,{children:["实际上，这里涉及到两个容易混淆的传递概念——",(0,i.jsx)(r.strong,{children:"值传递"}),"和",(0,i.jsx)(r.strong,{children:"引用传递"}),"。"]}),"\n",(0,i.jsxs)(r.p,{children:["像上述示例当中的做法，即直接传递一个变量名到另一个函数中，属于",(0,i.jsx)(r.strong,{children:"值传递"}),"。按照Go代码的执行策略，发生值传递时，将在另一个函数中自动生成一个值的副本。所以我们才会看到main()中的resultSlice和findPrimeNumber()中的result的内存地址是不同的，因为后者完全是前者的“替身”，我们在findPrimeNumber()函数中只是对替身做了改变，“真身”根本就没有收到影响！"]}),"\n",(0,i.jsxs)(r.p,{children:["与值传递相对的便是",(0,i.jsx)(r.strong,{children:"引用传递"}),"，这种方式在函数间传递的是指针，而指针恰恰是内存地址。这样的传值，无论发生在多少个函数之间，改变将始终作用于相同地址的数据上。"]}),"\n",(0,i.jsx)(r.p,{children:"了解过值传递和引用传递后，便很清楚如何修改我们的代码了——只需将原有的值传递改为引用传递，即向findPrimeNumber()函数传递resultSlice的内存地址就行了。当然，还要适当修改findPrimeNumber()函数的定义和逻辑。修改后的完整代码如下："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:"func main() {\r\n   var resultSlice []int\r\n   findPrimeNumber(&resultSlice, 10)\r\n   fmt.Println(resultSlice)\r\n}\r\n\r\nfunc findPrimeNumber(result *[]int, max int) {\r\n   for i := 2; i < max; i++ {\r\n      //假定i为素数\r\n      flag := true\r\n      for j := 2; j < i; j++ {\r\n         if i%j == 0 {\r\n            //当i能被某个整数整除时，不是素数\r\n            flag = false\r\n         }\r\n      }\r\n      //如果依旧为true，则i为素数\r\n      if flag {\r\n         //将素数存放到result数组中\r\n         *result = append(*result, i)\r\n      }\r\n   }\r\n}\n"})}),"\n",(0,i.jsx)(r.p,{children:"再次运行程序，将输出："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsx)(r.p,{children:"[2 3 5 7]"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["除了将值传递改为引用传递外，还有一种“",(0,i.jsx)(r.strong,{children:"偷懒式"}),"”修改方法也可使程序正常输出——直接把resultSlice变量声明在函数外，改为",(0,i.jsx)(r.strong,{children:"全局变量"}),"，即可在所有函数中访问和修改这个变量了。"]}),"\n",(0,i.jsx)(r.p,{children:"之所以称这种方法是“偷懒式”，是因为所有函数都能修改这个全局变量，数据存在一定的安全风险。若不慎错误地修改了变量的值，修复起来也会相对更困难一些了。"}),"\n",(0,i.jsxs)(r.h2,{id:"函数的延迟调用",children:["函数的延迟调用",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#函数的延迟调用",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"接下来，我们保持findPrimeNumber()函数不变，在main()函数伊始添加两行神奇的代码："}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-go",children:'func main() {\r\n   defer fmt.Print("素数")\r\n   defer fmt.Print("查找")\r\n   var resultSlice []int\r\n   findPrimeNumber(&resultSlice, 10)\r\n   fmt.Println(resultSlice)\r\n}\n'})}),"\n",(0,i.jsxs)(r.p,{children:["很明显，main()函数开头的两行代码和普通的代码不同，前面有个“defer”。",(0,i.jsx)(r.strong,{children:"“defer”的作用是让整句代码延迟执行，且多个defer存在时，它们的顺序是反向的。"})]}),"\n",(0,i.jsx)(r.p,{children:"根据这一规律，我们便可推测上述代码运行的结果将是："}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsxs)(r.p,{children:["[2 3 5 7]",(0,i.jsx)(r.br,{}),"\n","查找素数"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["defer的典型应用场景是执行一些",(0,i.jsx)(r.strong,{children:"收尾工作"}),"，通常是在常规逻辑执行结束后释放系统资源。如文件读写、网络IO等等。也用于程序在",(0,i.jsx)(r.strong,{children:"发生宕机时的恢复"}),"。"]}),"\n",(0,i.jsx)(r.p,{children:"在这里，大家先对defer做到了解、会用即可。后续到了相应的章节处，我们还会和它再次相遇。"}),"\n",(0,i.jsxs)(r.h2,{id:"小结",children:["小结",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsx)(r.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,i.jsx)(r.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsx)(r.li,{children:"普通函数的定义和调用"}),"\n",(0,i.jsx)(r.li,{children:"函数的延迟调用"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"Go SDK中提供了大量实用的函数，我们可以随时调用它们完成项目所需要的功能。此外，我们还可以通过自定义函数，实现项目的独特性需求。"}),"\n",(0,i.jsxs)(r.p,{children:["在自定义函数时，我们要掌握",(0,i.jsx)(r.strong,{children:"定义函数的格式"}),"以及",(0,i.jsx)(r.strong,{children:"调用函数的方法"}),"。无论函数是自用还是提供给团队中的其他成员，甚至是日后作为库发布，都要注意",(0,i.jsx)(r.strong,{children:"函数的命名"}),"，并为其添加必要的",(0,i.jsx)(r.strong,{children:"注释"}),"。"]}),"\n",(0,i.jsxs)(r.p,{children:["在调用函数时，要特别留意",(0,i.jsx)(r.strong,{children:"值传递"}),"和",(0,i.jsx)(r.strong,{children:"引用传递"}),"的区别。值传递会在被调用函数中自动生成一份传入参数的“",(0,i.jsx)(r.strong,{children:"副本"}),"”，改动不会影响“真身”；引用传递是在传递",(0,i.jsx)(r.strong,{children:"地址"}),"，被调用函数中对其的改变会对传入的参数产生影响。"]}),"\n",(0,i.jsx)(r.p,{children:"➡️ 在下次课程中，我们会继续介绍Go语言中的函数，具体内容是："}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"递归算法"}),"\n"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,l.ah)(),n.components);return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(s,{...n})}):s(n)}let t=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC10%E7%AB%A0%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%80%EF%BD%9C%E6%9E%84%E5%BB%BA%E2%80%9C%E8%BD%AE%E5%AD%90%E2%80%9D.md"]={toc:[{text:"普通函数的定义和调用",id:"普通函数的定义和调用",depth:2},{text:"函数的延迟调用",id:"函数的延迟调用",depth:2},{text:"小结",id:"小结",depth:2}],title:"第10章—函数一｜构建“轮子”",headingTitle:"第10章—函数一｜构建“轮子”",frontmatter:{}}}}]);