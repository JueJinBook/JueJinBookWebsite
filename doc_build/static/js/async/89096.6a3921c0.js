"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["89096"],{739704:function(e,c,n){e.exports=n.p+"static/image/09cc318918787b8dc0fe91e645bee4e8.44f229da.webp"},212216:function(e,c,n){e.exports=n.p+"static/image/8c259ff00eff37eba9d80ccb7bbd19d5.7d6f46c8.webp"},993752:function(e,c,n){e.exports=n.p+"static/image/e78eb481977706babe9f90311ae0a57b.e4225f9c.webp"},94526:function(e,c,n){n.r(c),n.d(c,{default:()=>V});var s=n(552676),r=n(740453);let a=n.p+"static/image/27709ef6f8475293ca014c7d688a34f9.7eb5ecd0.webp",i=n.p+"static/image/349dc259ede0838b7708a4acefc9e7f4.bb278fd9.webp",d=n.p+"static/image/33fbd55ccfb87c3fae162b05a3733b86.ffa9c3df.webp";var p=n(993752);let l=n.p+"static/image/01affc53464223255afcbc7b7bc9d548.fd73cf3c.webp",t=n.p+"static/image/ed1729452e463c303f6f68984ce8b715.a0f56715.webp",u=n.p+"static/image/905630e78bd0c247d40694ddae48c797.81110e2d.webp",h=n.p+"static/image/3a0b5a33c0d15942995a4b2eb9a96ca3.88019f82.webp",j=n.p+"static/image/9a0beeda7b231b14bfe472d490b082df.cc84e221.webp",o=n.p+"static/image/7e59df81673a6017df963d6ba4e46810.76f7ab4e.webp",m=n.p+"static/image/a3aaa0dfdab208d79b326a44cdf99c9e.e6eb2917.webp",x=n.p+"static/image/851585d4abc1ed1de7a307ef5e2f688c.21fdab51.webp",b=n.p+"static/image/cf36fc9a5aa738b318653d5b5a97e1d5.e36a39f9.webp",f=n.p+"static/image/c7745f1b26cfb26442815873794d793f.42c27dd9.webp",g=n.p+"static/image/eff9a494d376b1599a1549957ed43de2.07604d3f.webp",v=n.p+"static/image/392b83e0a1442861d4dca7cdd67d5de3.5c5515e0.webp",w=n.p+"static/image/5c8b0e2542845d25e063fb5c9ab4f807.b0413085.webp";var E=n(739704);let _=n.p+"static/image/8767c3a8d8e2a28de05bf866cbe1b14f.6514f06c.webp",A=n.p+"static/image/f92edc4498c856dc68eadbc3cac7a64c.83f8b315.webp",P=n.p+"static/image/5c9db9281a1cd17b8298a68777ff66aa.06b35f84.webp";var S=n(212216);function k(e){let c=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(c.h1,{id:"11实战案例调试-vue-源码",children:["11.实战案例：调试 Vue 源码",(0,s.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#11实战案例调试-vue-源码",children:"#"})]}),"\n",(0,s.jsx)(c.p,{children:"知道了如何调试 React 源码，这节我们再来调试下 Vue 源码。"}),"\n",(0,s.jsx)(c.p,{children:"首先，还是通过 vue cli 创建项目（要用 5.0 以上的 cli）："}),"\n",(0,s.jsx)(c.p,{children:"安装 @vue/cli 后执行 vue create vue-demo 创建 vue 项目："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"选择 vue3 的模版。"}),"\n",(0,s.jsx)(c.p,{children:"安装完之后进入到 vue-demo 目录，执行 npm run serve 把开发服务跑起来。"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"浏览器访问，会看到渲染出的页面："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"修改下 vue.config.js，把 devtool 改成 source-map："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"然后我们进行调试："}),"\n",(0,s.jsx)(c.p,{children:"点击调试窗口的 create a launch.json file 来创建调试配置文件："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"修改调试配置如下："}),"\n",(0,s.jsx)(c.pre,{children:(0,s.jsx)(c.code,{className:"language-json",children:'{\n    "type": "chrome",\n    "request": "launch",\n    "name": "调试 Vue 项目",\n    "runtimeExecutable": "canary",\n    "runtimeArgs": [\n        "--auto-open-devtools-for-tabs",\n    ],\n    "userDataDir": false,\n    "url": "http://localhost:8081"\n}\n'})}),"\n",(0,s.jsx)(c.p,{children:"这样就可以在 VSCode 里打断点调试了。"}),"\n",(0,s.jsx)(c.p,{children:"但是这样调试 Vue 源码的话还不够，你会发现调用栈里的路径是 node_modules 下的 runtime-core.esm-bundler.js："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这明显是经过编译打包之后的，而我们想要调试的是 Vue 最初的源码。"}),"\n",(0,s.jsx)(c.p,{children:"这就需要用到 sourcemap 了。"}),"\n",(0,s.jsx)(c.p,{children:"从 npm 下载的 vue 包是不带 sourcemap 的，我们需要把源码下载下来自己 build。"}),"\n",(0,s.jsx)(c.pre,{children:(0,s.jsx)(c.code,{children:"git clone https://github.com/vuejs/core vue3\n"})}),"\n",(0,s.jsx)(c.p,{children:"下载 vue3 的代码，用 pnpm install 安装依赖（这是 vue3 指定的依赖管理工具）。"}),"\n",(0,s.jsx)(c.p,{children:"执行 pnpm run build，就会在每个包下产生 dist 目录："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这时候的产物肯定是不带 sourcemap 的。"}),"\n",(0,s.jsx)(c.p,{children:"那难道也要像调试 React 源码那样改造 build 脚本么？"}),"\n",(0,s.jsx)(c.p,{children:"这个倒不用，vue3 源码里贴心的为需要生成 sourcemap 的情况做了支持。"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"只要配置下这个环境变量就行。"}),"\n",(0,s.jsx)(c.p,{children:"执行 export SOURCE_MAP=true 然后再跑 pnpm run build："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"build 完成后，再去看包下的 dist 产物，你就会发现有 sourcemap 了："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"相比 react 源码生成 sourcemap 简单了很多。"}),"\n",(0,s.jsx)(c.p,{children:"把 runtime-core 包下的 dist 复制出来，覆盖 vue-demo 项目的 node_modules 下的 dist 目录："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"重新跑 npm run serve，并且重新 debug："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这时候你会发现调试的就是源码了，很明显是 src 下的 ts 文件。"}),"\n",(0,s.jsx)(c.p,{children:"对比下之前的："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"是不是瞬间就懂了为什么要用 sourcemap 了？"}),"\n",(0,s.jsx)(c.p,{children:"当然，这里把 sourcemap 应用到项目里也没有 create-react-app 里那么费劲，明显是 vue-cli 对 node_modules 下的 sourcemap 做了支持，简单了很多。"}),"\n",(0,s.jsx)(c.p,{children:"只不过现在 sourcemap 到的路径不大对，没有 runtime-core 的包名，不能编辑："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这种情况有两种处理方式，一种是配置下 sourceMapPathOverrides，把这段路径再做一次映射，映射到源码目录就可以了。"}),"\n",(0,s.jsx)(c.p,{children:"另一种方式就是改造下 vue3 的 build 脚本，让生成的 sourcemap 就直接是正确的路径。"}),"\n",(0,s.jsx)(c.p,{children:"我们采用第二种方式。"}),"\n",(0,s.jsx)(c.p,{children:"再次打开 vue3 源码目录，找到 rollup.config.js 里 sourcemap 配置的地方，添加一段配置:"}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(c.pre,{children:(0,s.jsx)(c.code,{className:"language-javascript",children:"output.sourcemapPathTransform = (relativeSourcePath, sourcemapPath) => {\n    const newSourcePath = path.join(path.dirname(sourcemapPath), relativeSourcePath);\n    return newSourcePath;\n}\n"})}),"\n",(0,s.jsx)(c.p,{children:"这里的两个参数，sourcemapPath 就是 sourcemap 的绝对路径，比如这样 /Users/guang/code/vue3/packages/runtime-core/dist/runtime-core.cjs.js.map，而 relativeSourcePath 是 sourcemap 的路径到源码路径的相对路径，比如这样 ../src/errorHandling.ts"}),"\n",(0,s.jsx)(c.p,{children:"那要计算出源码的绝对路径，就可以先取 sourcemapPath 的目录路径，然后再根据相对路径查找到源码文件，这样就是源码的绝对路径了。"}),"\n",(0,s.jsx)(c.p,{children:"加了这个配置之后，重新 build 一下："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这时候生成的 sourcemap 里的源码路径就是绝对路径。"}),"\n",(0,s.jsx)(c.p,{children:"用新的 dist 目录覆盖 vue-demo 的 node_modules 下的 @vue/runtime-core 的 dist 目录，然后重新 npm run serve："}),"\n",(0,s.jsx)(c.p,{children:"这时候调用栈中的 vue 代码就是源码的绝对路径了，能找到文件，自然也就不再是只读："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"如果你重新跑 npm run serve，那可能是有 babel loader 的缓存："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"手动 rm -rf ./node_modules/.cache/babel-loader 就可以了。"}),"\n",(0,s.jsx)(c.p,{children:"当然，更好的体验还是像调试 React 代码那样，把 vue 源码和 vue-demo 项目放到同一个 workspace 下："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"这里因为移动了 vue3 源码的位置，那 sourcemap 到的路径变了，所以还要进入 vue3 源码路径重新 build 依次，再把 sourcemap 复制到 vue-demo 目录的 node_modules 下。"}),"\n",(0,s.jsx)(c.p,{children:"再次调试，点击调用栈中的源码，就能直接在 workspace 里打开："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"之后就能愉快的调试 vue 源码了。"}),"\n",(0,s.jsx)(c.p,{children:"对比下之前的调用栈："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"再看下现在的调用栈："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(c.p,{children:"点击就可以打开源码目录下的对应文件。"}),"\n",(0,s.jsx)(c.p,{children:"你平时开发的项目也可以这样把 node_modules 下 的 @vue/runtime-core 的 dist 目录替换掉，这样调试项目之余，还可以看看源码。把 vue 也加到 workspace 那一步倒不是必须的。"}),"\n",(0,s.jsx)(c.p,{children:"有的同学用 vite 调试 vue3 源码，也可以，但要把 vue 的预加载禁用，不然路径就变了："}),"\n",(0,s.jsx)(c.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(c.h2,{id:"总结",children:["总结",(0,s.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(c.p,{children:"这节我们调试了下 vue 源码，它同样也需要 sourcemap，我们下载了 vue 源码，然后 build 出了带有 sourcemap 的代码，覆盖 demo 项目的 node_modules 下的包，之后再次调试就可以直接调试源码了。"}),"\n",(0,s.jsx)(c.p,{children:"但是这时候 sourcemap 到的路径不对，所以源码文件是只读的。我们修改了 build 配置，通过 output.sourcemapPathTransform 修改了 sourcemap 到的源码地址，再次调试就能找到源码的绝对路径，这样内容就是可修改的了。"}),"\n",(0,s.jsx)(c.p,{children:"如果想点击调用栈直接在 workspace 打开对应的文件，这需要把 demo 项目和 vue3 源码项目放到一个 workspace 下，再次调试就可以了。"}),"\n",(0,s.jsx)(c.p,{children:"vue3 源码的调试整体比 react 源码调试简单不少，因为不管是生成 sourcemap 还是把 sourcemap 加到项目里，vue 都做了不错的支持。"})]})}function B(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,r.ah)(),e.components);return c?(0,s.jsx)(c,{...e,children:(0,s.jsx)(k,{...e})}):k(e)}let V=B;B.__RSPRESS_PAGE_META={},B.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F11.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%B0%83%E8%AF%95%20Vue%20%E6%BA%90%E7%A0%81.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"11.实战案例：调试 Vue 源码",headingTitle:"11.实战案例：调试 Vue 源码",frontmatter:{}}}}]);