"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["42400"],{2493:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var t=r(552676),o=r(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",strong:"strong"},(0,o.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"18内置组件teleport-是如何实现选择性挂载的",children:["18.内置组件：Teleport 是如何实现选择性挂载的？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18内置组件teleport-是如何实现选择性挂载的",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Teleport"})," 内置组件的功能是可以将一个组件内部的一部分 ",(0,t.jsx)(n.code,{children:"vnode"})," 元素 “传送” 到该组件的 ",(0,t.jsx)(n.code,{children:"DOM"})," 结构外层的位置去挂载。那什么情况下可能会用到该组件呢？如果开发过组件库的小伙伴可能深有体会，当我们开发全局 ",(0,t.jsx)(n.code,{children:"Dialog"})," 组件来说，我们希望 ",(0,t.jsx)(n.code,{children:"Dialog"})," 的组件可以渲染到全局 ",(0,t.jsx)(n.code,{children:"<body>"})," 标签上，这个时候我们写的 ",(0,t.jsx)(n.code,{children:"Dialog"})," 组件的源代码可能是这样的："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>\n    \x3c!-- 这里是 dialog 组件的容器逻辑 --\x3e\n  </div>\n</template>\n<script>\n  export default {\n    mounted() {\n      // 在 dom 被挂载完成后，再转移到 body 上\n      document.body.appendChild(this.$el);\n    },\n    destroyed() {\n      // 在组件被销毁之前，移除 DOM\n      this.$el.parentNode.removeChild(this.$el);\n    }\n  }\n<\/script>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这么做确实可是实现挂载到特定容器中，但这样一方面让 ",(0,t.jsx)(n.code,{children:"Dialog"})," 组件内部需要维护复杂的 ",(0,t.jsx)(n.code,{children:"DOM"})," 节点转换的逻辑，另一方面导致了浏览器需要进行 ",(0,t.jsx)(n.code,{children:"2"})," 次刷新操作，一次初始化挂载，一次迁移。"]}),"\n",(0,t.jsxs)(n.p,{children:["所以 ",(0,t.jsx)(n.code,{children:"Vue 3"})," 很贴心的为我们了提供了 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件，帮助我们以简便的方式",(0,t.jsx)(n.strong,{children:"高性能"}),"的完成节点的转移工作:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<Teleport to="body">\n  <div class="modal">\n    <p>Hello from the modal!</p>\n  </div>\n</Teleport>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["接下来我们将一起探秘 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件是如何实现 “传送” 挂载的。"]}),"\n",(0,t.jsxs)(n.h2,{id:"teleport-的挂载",children:["Teleport 的挂载",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#teleport-的挂载",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["先来看看 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件的源码定义："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const TeleportImpl = {\n  // 组件标记\n  __isTeleport: true,\n  \n  process(...) { \n    // ... \n    // 初始化的逻辑\n    if (n1 === null) {\n      // ...\n    } else {\n      // ...\n      // 更新逻辑\n    }\n  },\n  \n  // 卸载的逻辑\n  remove(...) {\n    // ...\n  },\n\n  // 移动的逻辑\n  move: moveTeleport,\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["接下来，我们看一下这个内部组件是如何实现组件挂载的，这块的逻辑集中在组件的 ",(0,t.jsx)(n.code,{children:"process"})," 函数中，",(0,t.jsx)(n.code,{children:"process"})," 函数是在渲染器 ",(0,t.jsx)(n.code,{children:"renderer"})," 的 ",(0,t.jsx)(n.code,{children:"patch"})," 函数中被调用的，在前面渲染器章节中，我们提到过 ",(0,t.jsx)(n.code,{children:"patch"})," 函数内部会根据 ",(0,t.jsx)(n.code,{children:"vnode"})," 的 ",(0,t.jsx)(n.code,{children:"type"})," 和 ",(0,t.jsx)(n.code,{children:"shapeFlag"})," 的类型调用不同的处理函数，而 ",(0,t.jsx)(n.code,{children:"<Teleport>"})," 组件的 ",(0,t.jsx)(n.code,{children:"process"})," 正是在这里被判断调用的："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const patch = (n1, n2, container, anchor, ...) => {\n  // ...\n  const { type, ref, shapeFlag } = n2\n  switch (type) {\n    // 根据 type 类型处理\n    case Text:\n      // 对文本节点的处理\n      processText(n1, n2, container, anchor)\n      break\n    // 这里省略了一些其他节点处理，比如注释、Fragment 节点等等\n    // ...\n    default:\n      // 根据 shapeFlag 来处理\n      // ...\n      else if (shapeFlag & ShapeFlags.TELEPORT) {\n        // 对 Teleport 节点进行处理\n        type.process(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized,\n          internals\n        );\n      }\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后一起来看看 ",(0,t.jsx)(n.code,{children:"process"})," 中是如何完成对 ",(0,t.jsx)(n.code,{children:"Teleport"})," 中的节点进行挂载的，这里我们先只关注挂载逻辑，对于更新逻辑后面再介绍："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const TeleportImpl = {\n  // 组件标记\n  __isTeleport: true,\n  \n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\n    // 从内在对象上结构关键功能函数\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: {insert, querySelector, createText, createComment}\n    } = internals\n    \n    // 是否禁用\n    const disabled = isTeleportDisabled(n2.props)\n    let {shapeFlag, children, dynamicChildren} = n2\n    // 初始化的逻辑\n    if (n1 == null) {\n      // 向主视图中插入锚点\n      const placeholder = (n2.el = __DEV__\n        ? createComment('teleport start')\n        : createText(''))\n      const mainAnchor = (n2.anchor = __DEV__\n        ? createComment('teleport end')\n        : createText(''))\n      insert(placeholder, container, anchor)\n      insert(mainAnchor, container, anchor)\n      // 获取需要挂载的位置元素，如果目标元素不存在于DOM中，则返回 null\n      const target = (n2.target = resolveTarget(n2.props, querySelector))\n      // 目标挂载节点的锚点\n      const targetAnchor = (n2.targetAnchor = createText(''))\n      // 如果存在目标元素\n      if (target) {\n        // 将锚点插入到目标元素当中\n        insert(targetAnchor, target)\n        isSVG = isSVG || isTargetSVG(target)\n      }\n      \n      const mount = (container: RendererElement, anchor: RendererNode) => {\n        // teleport 子节点需要是个数组\n        // 挂载子节点\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n          mountChildren(\n            children,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        }\n      }\n      // 如果禁用 teleport 则直接挂载到当前渲染节点中\n      if (disabled) {\n        mount(container, mainAnchor)\n      } else if (target) {\n        // 否则，以 targetAnchor 为参照物进行挂载\n        mount(target, targetAnchor)\n      }\n    } else {\n      // 进入更新逻辑\n    }\n  },\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里，我们先不着急着看源码，我们先看看一个 ",(0,t.jsx)(n.code,{children:"teleport"})," 节点在开发环境会被渲染成什么样子："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<template>\n  <Teleport to="body">\n    <div class="modal">\n      <p>Hello from the modal!</p>\n    </div>\n  </Teleport>\n</template>\n'})}),"\n",(0,t.jsx)(n.p,{children:"上述的模版，的渲染结果如下："}),"\n",(0,t.jsxs)(n.p,{children:["可以看到，已经被渲染到 ",(0,t.jsx)(n.code,{children:"body"})," 元素当中，除了这个变化外，之前的容器中，还多了两个额外的注释符："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"\x3c!--teleport start--\x3e\n\x3c!--teleport end--\x3e\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这下我们再来看看源码，或许就能更好的理解这些变化了。首先，在初始化中，会先创建两个占位符，分别是 ",(0,t.jsx)(n.code,{children:"placeholder"})," 和 ",(0,t.jsx)(n.code,{children:"mainAnchor"})," 然后再讲这两个占位符挂载到组件容器中，这两个占位符也就是上文中的注释节点。"]}),"\n",(0,t.jsxs)(n.p,{children:["接着又创建了一个目标节点的占位符 ",(0,t.jsx)(n.code,{children:"targetAnchor"})," 这个则会被挂载到目标容器中，只不过这里是个文本节点，所以在 ",(0,t.jsx)(n.code,{children:"DOM"})," 上没有体现出来，我们把这里稍微改一下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const targetAnchor = (n2.targetAnchor = createComment('teleport target'))\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这样再看一下 ",(0,t.jsx)(n.code,{children:"DOM"})," 的渲染结果："]}),"\n",(0,t.jsxs)(n.p,{children:["最后再根据 ",(0,t.jsx)(n.code,{children:"disabled"})," 这个 ",(0,t.jsx)(n.code,{children:"props"})," 属性来判断当前的节点需要采用哪种方式渲染，如果 ",(0,t.jsx)(n.code,{children:"disabled = true"})," 则会以 ",(0,t.jsx)(n.code,{children:"mainAnchor"})," 为参考节点进行挂载，也就是挂载到主容器中，否则会以 ",(0,t.jsx)(n.code,{children:"targetAnchor"})," 为参考节点进行挂载，挂载到目标元素容器中。至此，完成节点的初始化挂载逻辑。"]}),"\n",(0,t.jsxs)(n.h2,{id:"teleport-的更新",children:["Teleport 的更新",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#teleport-的更新",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["如果 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件需要进行更新，则会进入更新的逻辑："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const TeleportImpl = {\n  // 组件标记\n  __isTeleport: true,\n  \n  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {\n    // 从内在对象上结构关键功能函数\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: {insert, querySelector, createText, createComment}\n    } = internals\n    \n    // 是否禁用\n    const disabled = isTeleportDisabled(n2.props)\n    let {shapeFlag, children, dynamicChildren} = n2\n    // 初始化的逻辑\n    if (n1 == null) {\n      // ...\n    } else {\n      // 从老节点上获取相关参照系等属性\n      n2.el = n1.el\n      const mainAnchor = (n2.anchor = n1.anchor)!\n      const target = (n2.target = n1.target)!\n      const targetAnchor = (n2.targetAnchor = n1.targetAnchor)!\n      // 之前是不是禁用态  \n      const wasDisabled = isTeleportDisabled(n1.props)\n      // 当前的渲染容器\n      const currentContainer = wasDisabled ? container : target\n      // 参照节点\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor\n      isSVG = isSVG || isTargetSVG(target)\n      // 通过 dynamicChildren 更新节点\n      if (dynamicChildren) {\n        // fast path when the teleport happens to be a block root\n        patchBlockChildren(\n          n1.dynamicChildren!,\n          dynamicChildren,\n          currentContainer,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds\n        )\n        traverseStaticChildren(n1, n2, true)\n      } else if (!optimized) {\n        // 全量更新\n        patchChildren(\n          n1,\n          n2,\n          currentContainer,\n          currentAnchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          false\n        )\n      }\n  \n      if (disabled) {\n        if (!wasDisabled) {\n          // enabled -> disabled\n          // 移动回主容器\n          moveTeleport(\n            n2,\n            container,\n            mainAnchor,\n            internals,\n            TeleportMoveTypes.TOGGLE\n          )\n        }\n      } else {\n        // 目标元素被改变\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          // 获取新的目标元素\n          const nextTarget = (n2.target = resolveTarget(\n            n2.props,\n            querySelector\n          ))\n          // 移动到新的元素当中\n          if (nextTarget) {\n            moveTeleport(\n              n2,\n              nextTarget,\n              null,\n              internals,\n              TeleportMoveTypes.TARGET_CHANGE\n            )\n          }\n        } else if (wasDisabled) {\n          // disabled -> enabled\n          // 移动到目标元素中\n          moveTeleport(\n            n2,\n            target,\n            targetAnchor,\n            internals,\n            TeleportMoveTypes.TOGGLE\n          )\n        }\n      }\n    }\n  },\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["代码量虽然挺多的，但所做的事情是特别明确的，首先 ",(0,t.jsx)(n.code,{children:"Teleprot"})," 组件的更新需要和普通节点更新一样进行子节点的 ",(0,t.jsx)(n.code,{children:"diff"}),"。然后会判断 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件的 ",(0,t.jsx)(n.code,{children:"props"})," 是否有变更，主要就是 ",(0,t.jsx)(n.code,{children:"disabled"})," 和 ",(0,t.jsx)(n.code,{children:"to"})," 这两个参数。"]}),"\n",(0,t.jsxs)(n.p,{children:["如果 ",(0,t.jsx)(n.code,{children:"disabled"})," 变化，无非就是从 ",(0,t.jsx)(n.code,{children:"可用 -> 不可用"})," 或者从 ",(0,t.jsx)(n.code,{children:"不可用 -> 可用"}),"。从 ",(0,t.jsx)(n.code,{children:"可用 -> 不可用"})," 就是将原来挂在在 ",(0,t.jsx)(n.code,{children:"target"})," 容器中的节点重新移动到主容器中，而从 ",(0,t.jsx)(n.code,{children:"不可用 -> 可用"})," 就是将主容器中的节点再挂载到 ",(0,t.jsx)(n.code,{children:"target"})," 中。"]}),"\n",(0,t.jsxs)(n.p,{children:["如果 ",(0,t.jsx)(n.code,{children:"to"})," 这个参数变化了，那么就需要重新寻找目标节点，再进行挂载。"]}),"\n",(0,t.jsxs)(n.h2,{id:"teleport-的移除",children:["Teleport 的移除",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#teleport-的移除",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["当组件卸载时，我们需要移除 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件，一起再看看卸载重对于 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件的处理："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const unmount = (vnode, parentComponent, parentSuspense, doRemove, optiomized) => {\n  // ...\n  \n  if (shapeFlag & ShapeFlags.TELEPORT) {\n    vnode.type.remove(\n      vnode,\n      parentComponent,\n      parentSuspense,\n      optimized,\n      internals,\n      doRemove\n    )\n  }\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"unmount"})," 卸载函数对于 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件的处理就是直接调用 ",(0,t.jsx)(n.code,{children:"remove"})," 方法："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const TeleportImpl = {\n  // 组件标记\n  __isTeleport: true,\n  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {\n    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode\n    // 如果存在 target，移除 targetAnchor\n    if (target) {\n      hostRemove(targetAnchor!)\n    }\n    \n    // 在未禁用状态下，需要卸载 teleport 的子元素\n    if (doRemove || !isTeleportDisabled(props)) {\n      hostRemove(anchor!)\n      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i]\n          unmount(\n            child,\n            parentComponent,\n            parentSuspense,\n            true,\n            !!child.dynamicChildren\n          )\n        }\n      }\n    }\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"remove"})," 方法的操作，看起来也比较好理解，首先先移除掉 ",(0,t.jsx)(n.code,{children:"targetAnchor"})," 锚点内容，然后再调用 ",(0,t.jsx)(n.code,{children:"unmount"})," 函数挨个卸载子组件，从而完成卸载功能。"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["本小节，我们分析了 ",(0,t.jsx)(n.code,{children:"Teleport"})," 组件的核心实现原理，",(0,t.jsx)(n.code,{children:"Teleport"})," 相比于之前的那种挂载方式他的性能优势就在于 ",(0,t.jsx)(n.code,{children:"Teleport"})," 节点的挂载是在 ",(0,t.jsx)(n.code,{children:"patch"})," 阶段进行的，也就是在 ",(0,t.jsx)(n.code,{children:"patch"})," 阶段就确定了需要挂载到哪里，而不会出现先挂在到主容器再迁移到目标容器的情况。"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(s,{...e})}):s(e)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F18.%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%EF%BC%9ATeleport%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%80%89%E6%8B%A9%E6%80%A7%E6%8C%82%E8%BD%BD%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"Teleport 的挂载",id:"teleport-的挂载",depth:2},{text:"Teleport 的更新",id:"teleport-的更新",depth:2},{text:"Teleport 的移除",id:"teleport-的移除",depth:2},{text:"总结",id:"总结",depth:2}],title:"18.内置组件：Teleport 是如何实现选择性挂载的？",headingTitle:"18.内置组件：Teleport 是如何实现选择性挂载的？",frontmatter:{}}}}]);