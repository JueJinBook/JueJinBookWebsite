"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["17645"],{739474:function(e,n,c){c.r(n),c.d(n,{default:()=>t});var s=c(552676),r=c(740453);let h=c.p+"static/image/8b322966cfa4af43ea45a1c4e8072c14.9e93de3b.webp",d=c.p+"static/image/9df3c1c44fdcf480b1a5affac3bfc39d.15b7b59b.webp",i=c.p+"static/image/a100559bac565e0ea40fd4f7084950b0.4ca59071.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",code:"code",strong:"strong",ol:"ol",li:"li",img:"img",pre:"pre",blockquote:"blockquote"},(0,r.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"9浏览器缓存1珠联璧合熟悉而又陌生的-memory-cache-与-disk-cache",children:["9.浏览器缓存1：珠联璧合——熟悉而又陌生的 Memory Cache 与 Disk Cache",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9浏览器缓存1珠联璧合熟悉而又陌生的-memory-cache-与-disk-cache",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"从本文开始，我们将进入浏览器缓存的话题，但是我们尚且不能抛开 HTTP 缓存不管，相反我们需要建立在其基础之上。只有扎实了前面部分的知识，后面的学习之路才能走的更加平坦和顺畅，切勿邯郸学步。正所谓“学而不思则罔，思而不学则殆”，大家最终还是要产生自己的见解和认知，提出疑惑，寻找答案。"}),"\n",(0,s.jsx)(n.p,{children:"在前面章节介绍 HTTP 缓存的过程中，笔者多次提到了浏览器的 Memory Cache 与 Disk Cache 这两种缓存，但因当时它们并不是“主角”，生怕介绍起来喧宾夺主，因此并没有进行详细的阐述。而从本文开始我们已经步入了浏览器缓存的篇章，笔者将以此作为起点，发挥其承上启下的效果。"}),"\n",(0,s.jsxs)(n.h2,{id:"memory-cache-与-disk-cache-介绍",children:["Memory Cache 与 Disk Cache 介绍",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#memory-cache-与-disk-cache-介绍",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在了解它们之前，我们不妨先来段“自我介绍”。"}),"\n",(0,s.jsxs)(n.h3,{id:"memory-cache",children:["Memory Cache",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#memory-cache",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Memory Cache"})," 翻译过来便是“内存缓存”，顾名思义，它是存储在浏览器内存中的。其优点为获取速度快、优先级高，从内存中获取资源耗时为 0 ms，而其缺点也显而易见，比如生命周期短，当网页关闭后内存就会释放，同时虽然内存非常高效，但它也受限制于计算机内存的大小，是有限的。"]}),"\n",(0,s.jsx)(n.p,{children:"那么如果要存储大量的资源，这是还得用到磁盘缓存。"}),"\n",(0,s.jsxs)(n.h3,{id:"disk-cache",children:["Disk Cache",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#disk-cache",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Disk Cache"})," 翻译过来是“磁盘缓存”的意思，它是存储在计算机硬盘中的一种缓存，它的优缺点与 Memory Cache 正好相反，比如优点是生命周期长，不触发删除操作则一直存在，而缺点则是获取资源的速度相对内存缓存较慢。"]}),"\n",(0,s.jsx)(n.p,{children:"Disk Cache 会根据保存下来的资源的 HTTP 首部字段来判断它们是否需要重新请求，如果重新请求那便是强缓存的失效流程，否则便是生效流程。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"从两者的优缺点中我们可以发现，Memory Cache 与 Disk Cache 珠联璧合，优势互补，共同构成了浏览器本地缓存的左右手。"})}),"\n",(0,s.jsx)(n.p,{children:"介绍完这两位“老朋友”，接下来我们继续来了解下浏览器的缓存机制，因为目前市面上浏览器众多，不同浏览器的缓存机制都可能不同，笔者还是以主流的 Chrome 为例进行介绍。"}),"\n",(0,s.jsxs)(n.h2,{id:"浏览器缓存机制",children:["浏览器缓存机制",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器缓存机制",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"浏览器缓存机制包含了 Http 缓存中强缓存、协商缓存的知识点，这里就不再进行赘述，下面主要介绍与 Memory Cache、 Disk Cache 相关的机制。"}),"\n",(0,s.jsxs)(n.h3,{id:"缓存获取顺序",children:["缓存获取顺序",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存获取顺序",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["按照缓存顺序来讲，当一个资源准备加载时，浏览器会根据其",(0,s.jsx)(n.strong,{children:"三级缓存原理"}),"进行判断。"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"浏览器会率先查找内存缓存，如果资源在内存中存在，那么直接从内存中加载"}),"\n",(0,s.jsx)(n.li,{children:"如果内存中没找到，接下去会去磁盘中查找，找到便从磁盘中获取"}),"\n",(0,s.jsx)(n.li,{children:"如果磁盘中也没有找到，那么就进行网络请求，并将请求后符合条件的资源存入内存和磁盘中"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"按照以上顺序，浏览器缓存与 HTTP 缓存才得以相辅相成，在有效的沟通和判断中尽可能的减少不必要的资源浪费。"}),"\n",(0,s.jsxs)(n.h3,{id:"缓存存储优先级",children:["缓存存储优先级",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存存储优先级",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上述我们讲解了缓存资源的获取顺序，那么在获取之前，浏览器又是按照什么优先级来存储资源的？这一问题也可以直接换成“浏览器判断一个资源是存入内存缓存还是磁盘缓存的依据是什么？”。"}),"\n",(0,s.jsx)(n.p,{children:"其实答案在介绍内存缓存和磁盘缓存时已经有所涉及，我们以掘金首页为例子进行介绍。"}),"\n",(0,s.jsx)(n.p,{children:"当我们打开开发者工具并在浏览器输入 url 访问后，发现除了 base64 的图片永远从内存加载外，其他大部分资源会从磁盘加载。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"20210914175010.jpg"})}),"\n",(0,s.jsx)(n.p,{children:"磁盘缓存会将命中强缓存的 js、css、图片等资源都收入囊中，也省去我们担心它“挑食”的问题。"}),"\n",(0,s.jsx)(n.p,{children:"而内存缓存不这样，为了保持“苗条的身材”，它不得不控制“饮食”，尽可能的去挑选适合自己的“食物”。此时我们刷新下页面让内存缓存生效："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"20210914220039.jpg"})}),"\n",(0,s.jsx)(n.p,{children:"我们先过滤下只看 JS 资源的加载情况，发现有些被内存缓存了，有些则没有，这是为什么？"}),"\n",(0,s.jsxs)(n.p,{children:["有些读者可能会猜测是不是没有被缓存的是因为资源比较大，其实不然，上方图片笔者圈出了 ",(0,s.jsx)(n.code,{children:"Initiator"})," 列，通过该列便可以找到答案。"]}),"\n",(0,s.jsx)(n.p,{children:"Initiator 列表示资源加载发起的位置，我们点击从内存获取资源的该列值后可以发现资源是在 HTML 渲染阶段就被加载的，如以下代码所示："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="zh-CN">\n    <head>\n        <title>Demo</title>\n        <script src="https://i.snssdk.com/slardar/sdk.js"><\/script>\n    </head>\n    <body>\n        <div id="cache">加载的 JS 资源大概率会存储到内存中</div>\n    </body>\n</html>\n'})}),"\n",(0,s.jsx)(n.p,{children:"而被内存抛弃的资源我们也可以发现其都是异步加载的资源，这些资源没有被内存缓存，比如像这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="zh-CN">\n    <head>\n        <title>Demo</title>\n    </head>\n    <body>\n        <div id="cache">异步加载的 JS 资源没有存储到内存中</div>\n        <script>\n            window.onload = function () {\n                setTimeout(function () {\n                    var s = document.createElement("script");\n                    s.type = "text/javascript";\n                    s.async = true;\n                    s.src = "https://i.snssdk.com/slardar/sdk.js";\n                    var x = document.getElementsByTagName("script")[0];\n                    x.parentNode.insertBefore(s, x);\n                }, 2000);\n            };\n        <\/script>\n    </body>\n</html>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["根据以上测试代码很容易产生",(0,s.jsx)(n.strong,{children:"错误的"}),"判断结论：异步加载的 JS 资源不会存储到内存中。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"其实这里异步函数只是起到了协助性的作用，并不是造成不存内存的根本性原因，就好比“羚羊遇见了狼，羚羊没有被狼吃了并不是因为羚羊会跑，而是因为其跑过了狼”。"})}),"\n",(0,s.jsx)(n.p,{children:"我们可以把 JS 资源看作是“羚羊”，把浏览器内存看作是“狼”，“羚羊没有被狼吃了”便可以理解为异步加载的 JS 资源没有存储到内存中，此时“羚羊跑过了狼”就可以看作是异步资源的加载晚于浏览器内存的生效时间，最终笔者得出的结论便很好理解："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"浏览器内存缓存生效的前提下，JS 资源的执行加载时间会影响其是否被内存缓存"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以修改上述的 ",(0,s.jsx)(n.code,{children:"setTimeout"})," 时间为 1 秒后再次进行验证，大家会发现即使异步了，JS 资源还是很容易被内存缓存，原因便是异步 JS 资源加载时浏览器渲染进程可能还没有结束，而进程没结束就有被存入内存的可能。"]}),"\n",(0,s.jsx)(n.p,{children:"此外图片资源（非 base64）也有和 JS 资源同样的现象，而 CSS 资源比较与众不同，其被磁盘缓存的概率远大于被内存缓存。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"20210915153932.jpg"})}),"\n",(0,s.jsx)(n.p,{children:"这一现象目前还没有找到标准的答案，网上给出的非标准解释是："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"因为 CSS 文件加载一次就可渲染出来，我们不会频繁读取它，所以它不适合缓存到内存中，但是 JS 之类的脚本却随时可能会执行，如果脚本在磁盘当中，我们在执行脚本的时候需要从磁盘取到内存中来，这样 IO 开销就很大了，有可能导致浏览器失去响应。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"以上所述的内存缓存（Memory Cache）在浏览器标准中并没有详尽的描述，笔者也是根据自身实践及总结得出的一些结论，不同的浏览器在加载资源时可能会所有差异，读者还需根据自己的理解和实践进行进一步探索。"}),"\n",(0,s.jsxs)(n.h3,{id:"preload-与-prefetch",children:["Preload 与 Prefetch",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#preload-与-prefetch",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["基于上述现象的前提下，笔者还发现了与资源加载相关的两个功能（",(0,s.jsx)(n.code,{children:"Preload"})," 与 ",(0,s.jsx)(n.code,{children:"Prefetch"}),"）也会潜移默化的影响着浏览器缓存。"]}),"\n",(0,s.jsx)(n.p,{children:"preload 也被称为预加载，其用于 link 标签中，可以指明哪些资源是在页面加载完成后即刻需要的，浏览器会在主渲染机制介入前预先加载这些资源，并不阻塞页面的初步渲染。例如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<link rel="preload" href="https://i.snssdk.com/slardar/sdk.js" as="script" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"而当使用 preload 预加载资源后，笔者发现该资源一直会从磁盘缓存中读取，JS、CSS 及图片资源都有同样的表现，这主要还是和资源的渲染时机有关，在渲染机制还没有介入前的资源加载不会被内存缓存。"}),"\n",(0,s.jsx)(n.p,{children:"相反 prefetch 则表示预提取，告诉浏览器加载下一页面可能会用到的资源，浏览器会利用空闲状态进行下载并将资源存储到缓存中。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<link rel="prefetch" href="https://i.snssdk.com/slardar/sdk.js" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"使用 prefetch 加载的资源，刷新页面时大概率会从磁盘缓存中读取，如果跳转到使用它的页面，则直接会从磁盘中加载该资源。"}),"\n",(0,s.jsx)(n.p,{children:"利用好 preload 和 prefetch 这“两员大将”，我们可以优化浏览器资源加载的顺序和时机，在页面性能优化环节至关重要。"}),"\n",(0,s.jsxs)(n.h2,{id:"结语",children:["结语",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#结语",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"相信阅读完本节内容，你会对 Memory Cache 与 Disk Cache 有了新的认识，虽然本文从异步资源的角度阐述了不同资源的缓存优先级，但至于资源到底会被存储在内存还是磁盘，浏览器有它自己的考量，而这一衡量标准并没有官方的文档说明，但“实践出真知”，只有亲自动手实操，才能体会浏览器的“良苦用心”。"})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let t=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90%2F9.%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%981%EF%BC%9A%E7%8F%A0%E8%81%94%E7%92%A7%E5%90%88%E2%80%94%E2%80%94%E7%86%9F%E6%82%89%E8%80%8C%E5%8F%88%E9%99%8C%E7%94%9F%E7%9A%84%20Memory%20Cache%20%E4%B8%8E%20Disk%20Cache.md"]={toc:[{text:"Memory Cache 与 Disk Cache 介绍",id:"memory-cache-与-disk-cache-介绍",depth:2},{text:"Memory Cache",id:"memory-cache",depth:3},{text:"Disk Cache",id:"disk-cache",depth:3},{text:"浏览器缓存机制",id:"浏览器缓存机制",depth:2},{text:"缓存获取顺序",id:"缓存获取顺序",depth:3},{text:"缓存存储优先级",id:"缓存存储优先级",depth:3},{text:"Preload 与 Prefetch",id:"preload-与-prefetch",depth:3},{text:"结语",id:"结语",depth:2}],title:"9.浏览器缓存1：珠联璧合——熟悉而又陌生的 Memory Cache 与 Disk Cache",headingTitle:"9.浏览器缓存1：珠联璧合——熟悉而又陌生的 Memory Cache 与 Disk Cache",frontmatter:{}}}}]);