"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["45570"],{33427:function(e,n,t){t.r(n),t.d(n,{default:()=>w});var c=t(552676),r=t(740453);let s=t.p+"static/image/d426207b4cb5069ad0efe17f2e8eb50c.b7e64e0f.webp",i=t.p+"static/image/db0090af3085ffbb4f172c423c910b68.9f95baf7.gif",a=t.p+"static/image/2c64952763ddaa7e8167c26d432e5c47.5dbaa018.webp",l=t.p+"static/image/1257750bd58bc0128073b6dda0f109bb.702001a3.webp",d=t.p+"static/image/181dd668b69a6dc385e62e18e7da8bc4.59a16c60.webp",p=t.p+"static/image/cb4ca62ff3adaddbc08a64e6433cb14c.39531d07.webp",o=t.p+"static/image/553169cc37794e53b6528ac28e475cfd.063db5d8.webp",h=t.p+"static/image/b472b0a1b59f2587d449ccd02c286a39.e61418f3.webp",j=t.p+"static/image/4a132d4c501fccdbf50d94fd3080cfcd.f62cdd3e.webp",x=t.p+"static/image/fe0b8bc3ea0b60a813a90854e5bf9843.038b5757.webp",m=t.p+"static/image/3f8c85930b245f25c305530e88cde370.87676782.webp",u=t.p+"static/image/383bf6315661412977822cd561181c7c.ca56ff4a.webp",g=t.p+"static/image/7397dc8e6bfde8da08210ddecf256fc3.c467df91.webp",b=t.p+"static/image/7a654811e0c60bf0d57d497a7ddd3393.73e38540.webp",f=t.p+"static/image/a684a9d0583a9091ea810583d372308d.895ef638.webp",k=t.p+"static/image/924bbb3b30a7042d2912eff128d59458.b3d28b17.webp",v=t.p+"static/image/0069c44b14ccd7896f6c3df25e8c022d.1fde5616.webp",S=t.p+"static/image/a9d9412d1a5f32f0ecfb532d3e9493a1.ebcc340f.webp";function A(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",pre:"pre",code:"code",img:"img",h2:"h2",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"第11章react组件如何写单测",children:["第11章—React组件如何写单测",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第11章react组件如何写单测",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"\uFEFF当你写完一个 React 组件，如何保证它的功能是正常的呢？"}),"\n",(0,c.jsx)(n.p,{children:"在浏览器里渲染出来，手动测试一遍就好了啊。"}),"\n",(0,c.jsx)(n.p,{children:"那如果这个组件交给别人维护了，他并不知道这个组件的功能应该是什么样的，怎么保证他改动代码之后，组件功能依然正常？"}),"\n",(0,c.jsx)(n.p,{children:"这种情况就需要单元测试了。"}),"\n",(0,c.jsx)(n.p,{children:"单元测试可以测试函数、类的方法等细粒度的代码单元，保证功能正常。"}),"\n",(0,c.jsx)(n.p,{children:"有了单元测试之后，后续代码改动只需要跑一遍单元测试就知道功能是否正常。"}),"\n",(0,c.jsx)(n.p,{children:"但很多同学觉得单元测试没意义，因为代码改动比较频繁，单元测试也跟着需要频繁改动。"}),"\n",(0,c.jsx)(n.p,{children:"确实，如果代码改动特别频繁，就没必要单测了，手动测试就好。"}),"\n",(0,c.jsx)(n.p,{children:"因为如果手动测试一遍需要 5 分钟，写单元测试可能需要一个小时。"}),"\n",(0,c.jsx)(n.p,{children:"但如果代码比较稳定，那单测还是很有必要的，比如组件库里的组件、hooks 库里的 hooks、一些工具函数等。"}),"\n",(0,c.jsx)(n.p,{children:"手动测试 5 分钟，每次都要手动测试，假设 20 次，那就是 100 分钟的成本，而且还不能保证测试是可靠的。"}),"\n",(0,c.jsx)(n.p,{children:"写单测要一个小时，每次直接跑单测自动化测试，跑 100 次也是一个小时的成本，而且还是测试结果很可靠。"}),"\n",(0,c.jsxs)(n.p,{children:["综上，",(0,c.jsx)(n.strong,{children:"单元测试能保证函数、类的方法等代码单元的功能正常，把手动测试变成自动化测试。"})]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"但是写单元测试成本还是挺高的，如果代码改动频繁，那手动测试更合适。一些比较稳定的代码，还是有必要写单测的，写一次，自动测试 n 次，收益很大。"})}),"\n",(0,c.jsx)(n.p,{children:"那 React 的组件和 hooks 怎么写单测呢？"}),"\n",(0,c.jsx)(n.p,{children:"这节我们一起来写几个单测试试。"}),"\n",(0,c.jsx)(n.p,{children:"用 create-react-app 创建个 react 项目："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npx create-react-app --template=typescript react-unit-test\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:S,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"测试 react 组件和 hooks 可以使用 @testing-library/react 这个包，然后测试用例使用 jest 来组织。"}),"\n",(0,c.jsx)(n.p,{children:"这两个包 cra 都给引入了，我们直接跑下 npm run test 就可以看到单测结果。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:v,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"App 组件是这样的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:k,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"它的单测是这么写的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"通过 @testing-library/react 的 render 函数把组件渲染出来。"}),"\n",(0,c.jsx)(n.p,{children:"通过 screen 来查询 dom，查找文本内容匹配正则 /learn react/ 的 a 标签。"}),"\n",(0,c.jsx)(n.p,{children:"然后断言它在 document 内。"}),"\n",(0,c.jsx)(n.p,{children:"你也可以这么写："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"test('renders learn react link 2', () => {\n  const { container } = render(<App />);\n  const linkElement = container.querySelector('.App-link');\n\n  expect(linkElement?.textContent).toMatch(/learn react/i)\n});\n"})}),"\n",(0,c.jsx)(n.p,{children:"render 会返回组件挂载的容器 dom，它是一个 HTMLElement 的对象，有各种 dom 方法。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"可以用 querySelector 查找到那个 a 标签，然后判断它的内容是否匹配正则。"}),"\n",(0,c.jsx)(n.p,{children:"这两种写法都可以。"}),"\n",(0,c.jsx)(n.p,{children:"第二种方法更容易理解，就是拿到渲染容器的 dom，再用 dom api 来查找 dom。"}),"\n",(0,c.jsx)(n.p,{children:"第一种方法的 screen 是 @testing-library/react 提供的 api，是从全局查找 dom，可以直接根据文本查（getByText），根据标签名和属性查（getByRole） 等。"}),"\n",(0,c.jsx)(n.p,{children:"antd 组件的测试也是用的第二种来查找 dom 的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"那如果有 onClick、onChange 等事件监听器的组件，怎么测试呢？"}),"\n",(0,c.jsx)(n.p,{children:"我们写个组件 Toggle.tsx："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { useCallback, useState } from 'react';\n\nfunction Toggle() {\n\n    const [status, setStatus] = useState(false);\n\n    const clickHandler = useCallback(() => {\n        setStatus((prevStatus) => !prevStatus);\n    }, []);\n\n    return (\n        <div>\n            <button onClick={clickHandler}>切换</button>\n            <p>{status ? 'open' : 'close' }</p>\n        </div>\n    );\n}\n\nexport default Toggle;\n"})}),"\n",(0,c.jsx)(n.p,{children:"有个 state 来存储 open、close 的状态，点击按钮切换。"}),"\n",(0,c.jsx)(n.p,{children:"渲染出来是这样的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这个组件如何测试呢？"}),"\n",(0,c.jsx)(n.p,{children:"单测里触发事件需要用到 fireEvent 方法了。"}),"\n",(0,c.jsx)(n.p,{children:"改下 App.test.tsx"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { render, fireEvent } from '@testing-library/react';\nimport Toggle from './Toggle';\n\ntest('toggle', () => {\n  const { container } = render(<Toggle/>);\n\n  expect(container.querySelector('p')?.textContent).toBe('close');\n\n  fireEvent.click(container.querySelector('button')!)\n  \n  expect(container.querySelector('p')?.textContent).toBe('open');\n})\n"})}),"\n",(0,c.jsx)(n.p,{children:"用 render 方法把组件渲染出来。"}),"\n",(0,c.jsx)(n.p,{children:"用 container 节点的 dom api 查询 p 标签的文本，断言是 close。"}),"\n",(0,c.jsx)(n.p,{children:"然后用 fireEvent.click 触发 button 的点击事件。"}),"\n",(0,c.jsx)(n.p,{children:"断言 p 标签的文本是 open。"}),"\n",(0,c.jsx)(n.p,{children:"跑一下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm run test\n"})}),"\n",(0,c.jsx)(n.p,{children:"测试通过了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"fireEvent 可以触发任何元素的任何事件："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"那如何触发 change 事件呢？"}),"\n",(0,c.jsx)(n.p,{children:"这样写："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"第二个参数传入 target 的 value 值。"}),"\n",(0,c.jsx)(n.p,{children:"此外，如果我有段异步逻辑，过段时间才会渲染内容，这时候怎么测呢？"}),"\n",(0,c.jsx)(n.p,{children:"比如 Toggle 组件里点击按钮之后，过了 2s 才改状态："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"setTimeout(() => {\n    setStatus((prevStatus) => !prevStatus);\n}, 2000);\n"})}),"\n",(0,c.jsx)(n.p,{children:"这时候测试用例就报错了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这种用 waitFor 包裹下，设置 timeout 的时间就好了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"await waitFor(() => expect(container.querySelector('p')?.textContent).toBe('open'), {\n    timeout: 3000\n});\n"})}),"\n",(0,c.jsx)(n.p,{children:"测试通过了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"除了这些之外，还有一个 api 比较常用，就是 act"}),"\n",(0,c.jsx)(n.p,{children:"它是\xa0react-dom 包里的，@testing-library/react 对它做了一层包装。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"就是可以把所有浏览器里跑的代码都包一层 act，这样行为会和在浏览器里一样。"}),"\n",(0,c.jsx)(n.p,{children:"文档里的例子是这样的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"把单测里的 fireEvent 用 act 包一层："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { render, fireEvent, waitFor } from '@testing-library/react';\nimport { act } from 'react-dom/test-utils';\nimport Toggle from './Toggle';\n\ntest('toggle', async () => {\n  const { container } = render(<Toggle/>);\n  expect(container.querySelector('p')?.textContent).toBe('close');\n\n  act(() => {\n    fireEvent.click(container.querySelector('button')!)\n  })\n\n  await waitFor(() => expect(container.querySelector('p')?.textContent).toBe('open'), {\n    timeout: 3000\n  });\n})\n"})}),"\n",(0,c.jsx)(n.p,{children:"结果一样："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"组件测试我们学会了，那如果我想单独测试 hooks 呢？"}),"\n",(0,c.jsx)(n.p,{children:"这就要用到 renderHook 的 api 了。"}),"\n",(0,c.jsx)(n.p,{children:"我们写个 useCounter 的 hook："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { useState } from 'react';\n\ntype UseCounterReturnType = [\n  count: number, \n  increment: (delta: number) => void, \n  decrement: (delta: number) => void\n];\n\nexport default function useCounter(initialCount: number = 0): UseCounterReturnType {\n  \n  const [count, setCount] = useState(initialCount);\n\n  const increment = (delta: number) => {\n    setCount(count => count + delta);\n  };\n\n  const decrement = (delta: number) => {\n    setCount(count => count - delta);\n  };\n\n  return [count, increment, decrement];\n}\n"})}),"\n",(0,c.jsx)(n.p,{children:"先在 App.tsx 里用一下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import useCounter from './useCounter';\n\nfunction App() {\n\n  const [count, increment, decrement] = useCounter();\n\n  return (\n    <div>\n      <div>\n        {count}\n      </div>\n      <div>\n        <button onClick={() => increment(1)}>加一</button>\n        <button onClick={() => decrement(2)}>减二</button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n"})}),"\n",(0,c.jsx)(n.p,{children:"跑一下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm run start\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"没啥问题。"}),"\n",(0,c.jsx)(n.p,{children:"然后来写下这个 hook 的单测："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"test('useCounter', async () => {\n  const hook = renderHook(() => useCounter(0));\n  \n  const [count, increment, decrement]  = hook.result.current;\n\n  act(() => {\n    increment(2);\n  });\n  expect(hook.result.current[0]).toBe(2);\n\n  act(() => {\n    decrement(3);\n  });\n  expect(hook.result.current[0]).toBe(-1);\n\n  hook.unmount();\n});\n"})}),"\n",(0,c.jsx)(n.p,{children:"renderHook 返回的 result.current 就是 hook 的返回值。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这就是 hook 的单测写法。"}),"\n",(0,c.jsxs)(n.p,{children:["案例代码上传了",(0,c.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/react-unit-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"单元测试能保证函数、类的方法等代码单元的功能正常，把手动测试变成自动化测试。"}),"\n",(0,c.jsx)(n.p,{children:"变更不频繁的代码，还是有必要写单测的，写一次，自动测试 n 次，收益很大。"}),"\n",(0,c.jsx)(n.p,{children:"我们学了 react 组件和 hook 的单测写法。"}),"\n",(0,c.jsx)(n.p,{children:"主要是用 @testing-library/react 这个库，它有一些 api："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"render：渲染组件，返回 container 容器 dom 和其他的查询 api"}),"\n",(0,c.jsx)(n.li,{children:"fireEvent：触发某个元素的某个事件"}),"\n",(0,c.jsx)(n.li,{children:"createEvent：创建某个事件（一般不用这样创建）"}),"\n",(0,c.jsx)(n.li,{children:"waitFor：等待异步操作完成再断言，可以指定 timeout"}),"\n",(0,c.jsx)(n.li,{children:"act：包裹的代码会更接近浏览器里运行的方式"}),"\n",(0,c.jsx)(n.li,{children:"renderHook：执行 hook，可以通过 result.current 拿到 hook 返回值"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"其实也没多少东西。"}),"\n",(0,c.jsx)(n.p,{children:"jest 的 api 加上 @testing-libary/react 的这些 api，就可以写任何组件、hook 的单元测试了。"})]})}function E(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(A,{...e})}):A(e)}let w=E;E.__RSPRESS_PAGE_META={},E.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC11%E7%AB%A0%E2%80%94React%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%95%E6%B5%8B.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第11章—React组件如何写单测",headingTitle:"第11章—React组件如何写单测",frontmatter:{}}}}]);