"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["79890"],{137086:function(e,n,c){c.r(n),c.d(n,{default:()=>x});var d=c(552676),s=c(740453);let r=c.p+"static/image/d1ae41325e0190c04782d84a29340c10.9fdc8749.webp",l=c.p+"static/image/71b7802cb7a49c7927842da680171ff2.186e99c1.webp",i=c.p+"static/image/fa046d1718c2f7c914321ceb644f3b70.b9c97dc0.webp",o=c.p+"static/image/0bfc819e009025861b3084c3c0cce120.1328e14e.webp",h=c.p+"static/image/b9915a1c200a1ee1c22333b2c32cbc84.0048c57c.webp",a=c.p+"static/image/22453568cbf7e2d2fa84792ead0b2a85.67433127.webp";function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ul:"ul",li:"li",h2:"h2",ol:"ol",code:"code",pre:"pre",img:"img",blockquote:"blockquote"},(0,s.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"30hmr如何动态替换页面代码",children:["30.HMR：如何动态替换页面代码？",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#30hmr如何动态替换页面代码",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["HMR 全称 Hot Module Replacement，可以翻译为「",(0,d.jsx)(n.strong,{children:"模块热更新"}),"」，最初由 Webpack 设计实现，至今已几乎成为现代工程化必备工具之一，它能够在保持页面状态不变的情况下动态替换、删除、添加代码模块，提供超级丝滑顺畅的 Web 页面开发体验。"]}),"\n",(0,d.jsx)(n.p,{children:"在 HMR 之前，应用的加载、更新都是一种页面级别的原子操作，即使只是单个代码文件发生变更，都需要刷新整个页面，才能将最新代码映射到浏览器上，这会丢失之前在页面执行过的所有交互与状态，例如："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"对于复杂表单场景，这意味着你可能需要重新填充非常多字段信息；"}),"\n",(0,d.jsx)(n.li,{children:"弹框消失，你必须重新执行交互动作才会重新弹出。"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"再小的改动，例如更新字体大小，改变备注信息都会需要整个页面重新加载执行，整体开发效率偏低。而引入 HMR 后，虽然无法覆盖所有场景，但大多数小改动都可以通过模块热替换方式更新到页面上，从而确保连续、顺畅的开发调试体验，极大提升开发效率。"}),"\n",(0,d.jsxs)(n.h2,{id:"使用-hmr",children:["使用 HMR",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-hmr",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"Webpack 生态下，只需要经过简单的配置，即可启动 HMR 功能，大致分两步："}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["设置 ",(0,d.jsx)(n.code,{children:"devServer.hot"})," 属性为 true："]}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nmodule.exports = {\n  // ...\n  devServer: {\n    // 必须设置 devServer.hot = true，启动 HMR 功能\n    hot: true\n  }\n};\n"})}),"\n",(0,d.jsxs)(n.ol,{start:"2",children:["\n",(0,d.jsxs)(n.li,{children:["之后，还需要在代码调用 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 接口，声明如何将模块安全地替换为最新代码，如："]}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:'import component from "./component";\nlet demoComponent = component();\n\ndocument.body.appendChild(demoComponent);\n// HMR interface\nif (module.hot) {\n  // Capture hot update\n  module.hot.accept("./component", () => {\n    const nextComponent = component();\n\n    // Replace old content with the hot loaded one\n    document.body.replaceChild(nextComponent, demoComponent);\n\n    demoComponent = nextComponent;\n  });\n}\n'})}),"\n",(0,d.jsxs)(n.p,{children:["后面这个 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 逻辑比较复杂，需要根据资源类型 Case By Case 地实现，下面我们先展开讲解 HMR 的主要流程，之后重点聊聊 ",(0,d.jsx)(n.code,{children:"accept"})," 函数的作用与实现。"]}),"\n",(0,d.jsxs)(n.h2,{id:"实现原理",children:["实现原理",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现原理",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"Webpack HMR 特性的执行过程并不复杂，核心："}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["使用 ",(0,d.jsx)(n.code,{children:"webpack-dev-server"})," （后面简称 WDS）托管静态资源，同时以 Runtime 方式注入一段处理 HMR 逻辑的客户端代码；"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"浏览器加载页面后，与 WDS 建立 WebSocket 连接；"}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["Webpack 监听到文件变化后，增量构建发生变更的模块，并通过 WebSocket 发送 ",(0,d.jsx)(n.code,{children:"hash"})," 事件；"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["浏览器接收到 ",(0,d.jsx)(n.code,{children:"hash"})," 事件后，请求 ",(0,d.jsx)(n.code,{children:"manifest"})," 资源文件，确认增量变更范围；"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"浏览器加载发生变更的增量模块；"}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["Webpack 运行时触发变更模块的 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 回调，执行代码变更逻辑；"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"done。"}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,d.jsxs)(n.p,{children:["首先是 ",(0,d.jsx)(n.strong,{children:"注入 HMR 客户端运行时"}),"：在前面章节《",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119036016274440192",target:"_blank",rel:"noopener noreferrer",children:"Runtime：模块编译打包及运行时逻辑"}),"》中，我们已经详细介绍了 Webpack 运行时概念与底层实现逻辑，在 HMR 场景下，执行 ",(0,d.jsx)(n.code,{children:"npx webpack serve"})," 命令后，",(0,d.jsx)(n.code,{children:"webpack-dev-server"})," 首先会调用 ",(0,d.jsx)(n.code,{children:"HotModuleReplacementPlugin"})," 插件向应用的主 Chunk 注入一系列 HMR Runtime，包括："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["用于建立 WebSocket 连接，处理 ",(0,d.jsx)(n.code,{children:"hash"})," 等消息的运行时代码；"]}),"\n",(0,d.jsxs)(n.li,{children:["用于加载热更新资源的 ",(0,d.jsx)(n.code,{children:"RuntimeGlobals.hmrDownloadManifest"})," 与 ",(0,d.jsx)(n.code,{children:"RuntimeGlobals.hmrDownloadUpdateHandlers"})," 接口；"]}),"\n",(0,d.jsxs)(n.li,{children:["用于处理模块更新策略的 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 接口；"]}),"\n",(0,d.jsx)(n.li,{children:"……"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["经过 ",(0,d.jsx)(n.code,{children:"HotModuleReplacementPlugin"})," 处理后，构建产物中即包含了所有运行 HMR 所需的客户端运行时与接口。这些 HMR 运行时会在浏览器执行一套基于 WebSocket 消息的时序框架，如图："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"其次，实现增量构建"}),"：除注入客户端代码外，",(0,d.jsx)(n.code,{children:"HotModuleReplacementPlugin"})," 插件还会借助 Webpack 的 ",(0,d.jsx)(n.code,{children:"watch"})," 能力，在代码文件发生变化后执行增量构建，生成："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"manifest"})," 文件：JSON 格式文件，包含所有发生变更的模块列表，命名为 ",(0,d.jsx)(n.code,{children:"[hash].hot-update.json"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:["模块变更文件：js 格式，包含编译后的模块代码，命名为 ",(0,d.jsx)(n.code,{children:"[hash].hot-update.js"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["增量构建完毕后，Webpack 将触发 ",(0,d.jsx)(n.code,{children:"compilation.hooks.done"})," 钩子，并传递本次构建的统计信息对象 ",(0,d.jsx)(n.code,{children:"stats"}),"。WDS 则监听 ",(0,d.jsx)(n.code,{children:"done"})," 钩子，在回调中通过 WebSocket 发送模块更新消息："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:'{"type":"hash","data":"${stats.hash}"}\n'})}),"\n",(0,d.jsx)(n.p,{children:"实际效果："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"再次，加载更新"}),"：客户端通过 WebSocket 接收到 ",(0,d.jsx)(n.code,{children:"hash"})," 消息后，首先发出 ",(0,d.jsx)(n.code,{children:"manifest"})," 请求获取本轮热更新涉及的 chunk，如："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["注意：在 Webpack 4 及之前，热更新文件以模块为单位，即所有发生变化的模块都会生成对应的热更新文件； Webpack 5 之后热更新文件以 chunk 为单位，如上例中，",(0,d.jsx)(n.code,{children:"main"})," chunk 下任意文件的变化都只会生成 ",(0,d.jsx)(n.code,{children:"main.[hash].hot-update.js"})," 更新文件。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"manifest"})," 请求完成后，客户端 HMR 运行时开始下载发生变化的 chunk 文件，将最新模块代码加载到本地。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsxs)(n.strong,{children:["最后，执行 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 回调"]}),"：经过上述步骤，浏览器加载完最新模块代码后，HMR 运行时会继续触发 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 回调，将最新代码替换到运行环境中。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"module.hot.accept"})," 是 HMR 运行时暴露给用户代码的重要接口之一，它在 Webpack HMR 体系中开了一个口子，让用户能够自定义模块热替换的逻辑，接口签名："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"module.hot.accept(path?: string, callback?: function);\n"})}),"\n",(0,d.jsx)(n.p,{children:"它接受两个参数："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"path"}),"：指定需要拦截变更行为的模块路径；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"callback"}),"：模块更新后，将最新模块代码应用到运行环境的函数。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"例如，对于如下代码："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// src/bar.js\nexport const bar = 'bar'\n\n// src/index.js\nimport { bar } from './bar';\nconst node = document.createElement('div')\nnode.innerText = bar;\ndocument.body.appendChild(node)\n\nmodule.hot.accept('./bar.js', function () {\n    node.innerText = bar;\n})\n"})}),"\n",(0,d.jsxs)(n.p,{children:["示例中，",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 函数监听 ",(0,d.jsx)(n.code,{children:"./bar.js"})," 模块的变更事件，一旦代码发生变动，就触发回调，将 ",(0,d.jsx)(n.code,{children:"./bar.js"})," 导出的值替换到页面上，从而实现热更新效果。"]}),"\n",(0,d.jsxs)(n.p,{children:["回顾整个 HMR 过程，所有的状态流转均由 WebSocket 消息驱动，这部分逻辑由 HMR 运行时控制，开发者几乎无感，唯一需要关注的就是是为每一个需要支持 HMR 特性的文件注册 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 回调。"]}),"\n",(0,d.jsxs)(n.h2,{id:"accept-函数注意事项",children:[(0,d.jsx)(n.code,{children:"accept"})," 函数注意事项",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#accept-函数注意事项",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["从应用视角看，",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 是 Webpack 开放出来，由用户自定义模块更新逻辑的重要函数，因此有必要单独拎出来，聊聊几个开发技巧："]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.strong,{children:"处理失败兜底逻辑"})}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"module.hot.accept"})," 函数只接受具体路径的 ",(0,d.jsx)(n.code,{children:"path"})," 参数，也就是说，我们无法通过 ",(0,d.jsx)(n.code,{children:"glob"})," 或类似风格的方式批量注册热更新回调。"]}),"\n",(0,d.jsxs)(n.p,{children:["一旦某个模块没有注册对应的 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 函数后，HMR 运行时会执行兜底策略，通常是刷新页面，确保页面上运行的始终是最新的代码，因此有时候你可能明明已经注册了 ",(0,d.jsx)(n.code,{children:"accept"})," 回调，但热更新无法生效，此时可以检查一下文件路径是否真的命中资源。"]}),"\n",(0,d.jsxs)(n.ol,{start:"2",children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.strong,{children:"更新事件冒泡"})}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"module.hot.accept"})," 函数只能捕获当前模块对应子孙模块的更新事件，例如对于下面的模块依赖树："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,d.jsxs)(n.p,{children:["示例中，更新事件会沿着模块依赖树自底向上逐级传递，从 ",(0,d.jsx)(n.code,{children:"foo"})," 到 ",(0,d.jsx)(n.code,{children:"index"})," ，从 ",(0,d.jsx)(n.code,{children:"bar-1"})," 到 ",(0,d.jsx)(n.code,{children:"bar"})," 再到 ",(0,d.jsx)(n.code,{children:"index"}),"，但不支持反向或跨子树传递，也就是说："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["在 ",(0,d.jsx)(n.code,{children:"foo.js"})," 中无法捕获 ",(0,d.jsx)(n.code,{children:"bar.js"})," 及其子模块的变更事件；"]}),"\n",(0,d.jsxs)(n.li,{children:["在 ",(0,d.jsx)(n.code,{children:"bar-1.js"})," 中无法捕获 ",(0,d.jsx)(n.code,{children:"bar.js"})," 的变更事件。"]}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"这一特性与 DOM 事件规范中的冒泡过程极为相似，使用时如果摸不准模块的依赖关系，建议直接在应用的入口文件中编写热更新函数。"}),"\n",(0,d.jsxs)(n.ol,{start:"3",children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.strong,{children:"使用无参数调用风格"})}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["除上述调用方式外，",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 函数还支持无参数调用风格，作用是捕获当前文件的变更事件，并从模块第一行开始重新运行该模块的代码，例如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:"// src/bar.js\nconsole.log('bar');\n\nmodule.hot.accept();\n"})}),"\n",(0,d.jsxs)(n.p,{children:["示例模块发生变动之后，会从头开始重复执行 ",(0,d.jsx)(n.code,{children:"console.log"})," 语句。"]}),"\n",(0,d.jsxs)(n.h2,{id:"vue-loader-如何实现-hmr-",children:[(0,d.jsx)(n.code,{children:"vue-loader"})," 如何实现 HMR ？",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-loader-如何实现-hmr-",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["最后，我们来看一个实际案例 —— ",(0,d.jsx)(n.code,{children:"vue-loader"}),"，这是一个用于处理 Vue ",(0,d.jsx)(n.a,{href:"https://vue-loader.vuejs.org/zh/spec.html#%E7%AE%80%E4%BB%8B",target:"_blank",rel:"noopener noreferrer",children:"Single File Component"})," 的 Webpack 加载器，它能够将如下格式的内容转译为可在浏览器运行的等价代码："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,d.jsxs)(n.p,{children:["除常规的代码转译外，在 HMR 模式下，",(0,d.jsx)(n.code,{children:"vue-loader"})," 还会为每一个 Vue 文件注入一段处理模块替换的逻辑，如："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-js",children:'"./src/a.vue":\n/*!*******************!*\\\n    !*** ./src/a.vue ***!\n    \\*******************/\n/***/\n((module, __webpack_exports__, __webpack_require__) => {\n    // 模块代码\n    // ...\n    /* hot reload */\n    if (true) {\n    var api = __webpack_require__( /*! ../node_modules/vue-hot-reload-api/dist/index.js */ "../node_modules/vue-hot-reload-api/dist/index.js")\n    api.install(__webpack_require__( /*! vue */ "../node_modules/vue/dist/vue.runtime.esm.js"))\n    if (api.compatible) {\n        module.hot.accept()\n        if (!api.isRecorded(\'45c6ab58\')) {\n        api.createRecord(\'45c6ab58\', component.options)\n        } else {\n        api.reload(\'45c6ab58\', component.options)\n        }\n        module.hot.accept( /*! ./a.vue?vue&type=template&id=45c6ab58& */ "./src/a.vue?vue&type=template&id=45c6ab58&", __WEBPACK_OUTDATED_DEPENDENCIES__ => {\n        /* harmony import */\n        _a_vue_vue_type_template_id_45c6ab58___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./a.vue?vue&type=template&id=45c6ab58& */ "./src/a.vue?vue&type=template&id=45c6ab58&");\n        (function () {\n            api.rerender(\'45c6ab58\', {\n            render: _a_vue_vue_type_template_id_45c6ab58___WEBPACK_IMPORTED_MODULE_0__.render,\n            staticRenderFns: _a_vue_vue_type_template_id_45c6ab58___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns\n            })\n        })(__WEBPACK_OUTDATED_DEPENDENCIES__);\n        })\n    }\n    }\n    // ...\n\n    /***/\n}),\n'})}),"\n",(0,d.jsx)(n.p,{children:"这段被注入用于处理模块热替换的代码，主要步骤有："}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:["首次执行时，调用 ",(0,d.jsx)(n.code,{children:"api.createRecord"})," 记录组件配置，",(0,d.jsx)(n.code,{children:"api"})," 为 ",(0,d.jsx)(n.code,{children:"vue-hot-reload-api"})," 库暴露的接口；"]}),"\n",(0,d.jsxs)(n.li,{children:["执行 ",(0,d.jsx)(n.code,{children:"module.hot.accept()"})," 语句，监听当前模块变更事件，当模块发生变化时调用 ",(0,d.jsx)(n.code,{children:"api.reload"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:["执行 ",(0,d.jsx)(n.code,{children:'module.hot.accept("xxx.vue?vue&type=template&xxxx", fn)'})," ，监听 Vue 文件 template 代码的变更事件，当 template 模块发生变更时调用 ",(0,d.jsx)(n.code,{children:"api.rerender"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["可以看到，",(0,d.jsx)(n.code,{children:"vue-loader"})," 对 HMR 的支持，基本上围绕 ",(0,d.jsx)(n.code,{children:"vue-hot-reload-api"})," 展开，当代码文件发生变化触发 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 回调时，会根据情况执行 ",(0,d.jsx)(n.code,{children:"vue-hot-reload-api"})," 暴露的 ",(0,d.jsx)(n.code,{children:"reload"})," 与 ",(0,d.jsx)(n.code,{children:"rerender"})," 函数，两者最终都会触发组件实例的 ",(0,d.jsx)(n.code,{children:"$forceUpdate"})," 函数强制执行重新渲染。"]}),"\n",(0,d.jsxs)(n.p,{children:["另外，为什么这里需要调用两次 ",(0,d.jsx)(n.code,{children:"module.hot.accept"}),"？这是因为 ",(0,d.jsx)(n.code,{children:"vue-loader"})," 在做转译时，会将 SFC 不同板块拆解成多个 module，例如 ",(0,d.jsx)(n.code,{children:"template"})," 对应生成 ",(0,d.jsx)(n.code,{children:"xxx.vue?vue&type=template"})," ；",(0,d.jsx)(n.code,{children:"script"})," 对应生成 ",(0,d.jsx)(n.code,{children:"xxx.vue?vue&type=script"}),"。因此，",(0,d.jsx)(n.code,{children:"vue-loader"})," 必须为这些不同的 module 分别调用 ",(0,d.jsx)(n.code,{children:"accept"})," 接口，才能处理好不同代码块的变更事件，更多实现细节，可翻阅《",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035564862472233",target:"_blank",rel:"noopener noreferrer",children:"Loader 开发进阶：如何用好 Loader 扩展开发工具？"}),"》一章。"]}),"\n",(0,d.jsxs)(n.h2,{id:"总结",children:["总结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["综上，Webpack 的 HMR 特性底层有两个重点，一是监听文件变化并通过 WebSocket 发送变更消息；二是需要客户端配合，通过 ",(0,d.jsx)(n.code,{children:"module.hot.accept"})," 接口定制特定模块的热替换规则。"]}),"\n",(0,d.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"Webpack HMR 这种模块粒度的更新规则，真的能完美适配所有代码更新场景吗？什么情况下，什么类型文件的更新可能并不能实现热更效果，而不得不回退到整页更新？"})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(t,{...e})}):t(e)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F30.HMR%EF%BC%9A%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E6%9B%BF%E6%8D%A2%E9%A1%B5%E9%9D%A2%E4%BB%A3%E7%A0%81%EF%BC%9F.md"]={toc:[{text:"使用 HMR",id:"使用-hmr",depth:2},{text:"实现原理",id:"实现原理",depth:2},{text:"`accept` 函数注意事项",id:"accept-函数注意事项",depth:2},{text:"`vue-loader` 如何实现 HMR ？",id:"vue-loader-如何实现-hmr-",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"30.HMR：如何动态替换页面代码？",headingTitle:"30.HMR：如何动态替换页面代码？",frontmatter:{}}}}]);