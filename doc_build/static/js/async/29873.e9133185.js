"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["29873"],{32128:function(n,e,s){s.r(e),s.d(e,{default:()=>o});var r=s(552676),c=s(740453);let i=s.p+"static/image/a773f492ff11d410433913f4652ee4b2.9f867ce5.webp";function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",code:"code",h2:"h2",pre:"pre",blockquote:"blockquote",img:"img",em:"em"},(0,c.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"14-进阶篇你不知道的-json-那些事",children:["14 进阶篇｜你不知道的 JSON 那些事",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#14-进阶篇你不知道的-json-那些事",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"现在我们开启进阶篇的课程，这一部分我们主要掌握一些高级对象的使用，在涉及比较专业的场合中往往它们是不可代替的。本章节我们就从 JavaScript 中内置的最简单结构化数据 JSON 开始。"}),"\n",(0,r.jsxs)(e.p,{children:["结构化数据是指按照特定格式和规则组织的数据，每个数据字段都有明确的定义和类型。结构化数据的特点是易于处理、存储和分析，因为数据的结构和关系已经明确。在 JavaScript 诞生的初期，常见的文本形式的结构化数据通常是 ",(0,r.jsx)(e.strong,{children:"XML"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"但是 XML 需要大量的“<>”标签来描述结构关系，因此体积浪费上比较严重，对于解析和网络传输上要明显逊色于 JSON。"}),"\n",(0,r.jsxs)(e.p,{children:["JSON 全称叫做 ",(0,r.jsx)(e.code,{children:"JavaScript Object Notation"}),"，可见它一开始就与 JavaScript 脱不开关系。大神 ",(0,r.jsx)(e.strong,{children:"Douglas Crockford"})," 在 2002 年就发布了第一版 JSON 规范，但微软在 IE8 才开始内置对 JSON API 的支持，在此之前，都需要引用第三方库来实现。ECMAScript 规范引入 JSON 要到 ES5。"]}),"\n",(0,r.jsxs)(e.p,{children:["事实上，JSON 在 ECMA 是有独立规范的，那就是 ",(0,r.jsx)(e.code,{children:"ECMA-404"}),"。它只有十几页，里面定义了各种语法相关的符号，比如大括号、中括号、逗号、分号，都是有明确的 Unicode 值的。同时它也定义了 JSON 支持的 7 种取值，分别是 ",(0,r.jsx)(e.strong,{children:"object"}),"、",(0,r.jsx)(e.strong,{children:"array"}),"、",(0,r.jsx)(e.strong,{children:"number"}),"、",(0,r.jsx)(e.strong,{children:"string"}),"、",(0,r.jsx)(e.strong,{children:"true"}),"、",(0,r.jsx)(e.strong,{children:"false"})," 和 ",(0,r.jsx)(e.strong,{children:"null"}),"。"]}),"\n",(0,r.jsxs)(e.h2,{id:"json-的解析",children:["JSON 的解析",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#json-的解析",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"单单一个数字、一个双引号字符串、一个 true 或 false，以及一个 null 都是合法的 JSON 数据，并非只有大括号（{}）、中括号（[]）包起来的结构才算。于是像下列解析都能够成功："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'JSON.parse("8")\nJSON.parse(`"Hello"`)\nJSON.parse("true")\nJSON.parse("false")\nJSON.parse("null")\n'})}),"\n",(0,r.jsxs)(e.p,{children:["但是需要注意，JSON 只支持十进制的数字，像 ",(0,r.jsx)(e.code,{children:'JSON.parse("0x01")'})," 甚至 ",(0,r.jsx)(e.code,{children:'JSON.parse("01")'})," 这样都是不可以被成功解析的。从这张图就可以看得出来 JSON 支持的数字格式："]}),"\n",(0,r.jsxs)(e.p,{children:["同时，对于 JavaScript 中的特殊数字，比如 ",(0,r.jsx)(e.code,{children:"Infinity"}),"、",(0,r.jsx)(e.code,{children:"NaN"}),"，JSON 都是不支持的，解析会报错。此外，",(0,r.jsx)(e.code,{children:"undefined"})," 也不属于 JSON 的合法类型。"]}),"\n",(0,r.jsxs)(e.p,{children:["以上是 ",(0,r.jsx)(e.code,{children:"JSON.parse"})," 对于一些不常见数据格式的解析策略。如果你给它传入了一个非字符串类型的参数，那么会通过 ",(0,r.jsx)(e.code,{children:"ToString()"})," 函数来转换。"]}),"\n",(0,r.jsxs)(e.p,{children:["应该有很多人不知道，",(0,r.jsx)(e.code,{children:"JSON.parse"})," 还支持第二个参数 ",(0,r.jsx)(e.code,{children:"reviver"}),"，用来精确控制解析后的值。举一个例子："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'JSON.parse(`{\n    "name": "Mike",\n    "education": {\n        "college": "MIT",\n        "major": "computer"\n    },\n    "experiences": [{\n        "from": "2017-08-20",\n        "to": "2018-03-05",\n        "employer": "Google"\n    },\n    {\n        "from": "2018-03-17",\n        "to": "2020-07-28",\n        "employer": "Microsoft"\n    }]\n}`, function(key, value) {\n    console.log(this, key, value);\n    return value;\n})\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"reviver"})," 内部有三个变量可以利用，分别是 ",(0,r.jsx)(e.code,{children:"this"}),"、",(0,r.jsx)(e.code,{children:"key"})," 和 ",(0,r.jsx)(e.code,{children:"value"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"key 不用多说，自然是某一层级下某一字段的键，需要注意的是，最外层这个结构也被包含在了一个虚拟对象中："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"{\n  '': {\n    name: 'Mike',\n    education: { college: 'MIT', major: 'computer' },\n    experiences: [ [Object], [Object] ]\n  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"并且 key 为空字符串。大家可以专门打印一下所有的 key，它们形成下面这种顺序："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'"name"\n"college"\n"major"\n"education"\n"from"\n"to"\n"employer"\n"0"\n"from"\n"to"\n"employer"\n"1"\n"experiences"\n""\n'})}),"\n",(0,r.jsxs)(e.p,{children:["可见这是一个",(0,r.jsx)(e.code,{children:"深度优先遍历"}),"的顺序，最后一个一定是空串。",(0,r.jsx)(e.code,{children:"this"})," 即指向当前这个 key 所在的对象结构，因此不要用箭头函数来声明 ",(0,r.jsx)(e.code,{children:"reviver"}),"，否则会篡改 this。"]}),"\n",(0,r.jsxs)(e.p,{children:["即便有 this 和 key，",(0,r.jsx)(e.code,{children:"reviver"})," 参数在实际使用中仍然面临着比较大的限制，因为 key 会重复，这时候你就只能用 this 来辨别当前 key-value 的位置，但是 this 作为一个数据结构，同样不方便用来定位。因此，建议在被解析的 JSON 数据有明确、简单的结构时，可以考虑使用 ",(0,r.jsx)(e.code,{children:"reviver"}),"。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["你可以试试用 ",(0,r.jsx)(e.code,{children:"reviver"})," 来生成 JSON 本来不支持的数据类型，比如 Symbol、BigInt。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"序列化成-json",children:["序列化成 JSON",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#序列化成-json",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["与解析相对应的就是序列化：",(0,r.jsx)(e.code,{children:"JSON.stringify"}),"。大家应该可以理解被序列化的对象",(0,r.jsx)(e.code,{children:"不可以包含环形引用"}),"，否则无法展开为树形平面的 JSON 格式，不信的话可以试试："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"JSON.stringify(document)\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后我们来瞧一瞧一些特殊格式的变量在被序列化后是什么："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"JSON.stringify(null)               // 'null'\nJSON.stringify(undefined)          // undefined\nJSON.stringify(true)               // 'true'\nJSON.stringify(false)              // 'false'\nJSON.stringify(\"abc\")              // '\"abc\"'\nJSON.stringify(123)                // '123'\nJSON.stringify(Symbol(\"sym\"))      // undefined\nJSON.stringify([2, 3, 4])          // '[2,3,4]'\nJSON.stringify(function foo(){})   // undefined\n"})}),"\n",(0,r.jsxs)(e.p,{children:["我们遍历这些不同类型数据的目的是想提醒大家，在向 ",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 传递参数的时候，要对类型有预期，要知道传错类型的后果是什么。大家已经看到了，这个函数并不是始终都返回一个字符串，还可能是 undefined，因此像下面这种代码，你应该可以猜到可能报什么错吧："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function toJSON(variable) {\n    return JSON.strinify(variable).trim(); // ⚠️\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["总结一下 ",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 只能正常处理 JSON 所支持的类型：字符串、数字、布尔、对象和 null。对象中的函数不被支持，会返回 undefined，而 undefined 又会被丢弃。即便是数字也有例外："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"JSON.stringify(Infinity) // 'null'\nJSON.stringify(NaN) // 'null'\nJSON.stringify(1n) // ❌ VM1315:1 Uncaught TypeError: Do not know how to serialize a BigInt\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Infinity"})," 和 ",(0,r.jsx)(e.code,{children:"NaN"})," 都会序列化成 “null”，而 ",(0,r.jsx)(e.code,{children:"BigInt"})," 压根就直接抛出异常了。"]}),"\n",(0,r.jsxs)(e.p,{children:["从这一点上来看，我们就知道这样一种对象深克隆（clone）办法：先序列化成 JSON 字符串，再 parse 成对象，会存在明显的",(0,r.jsx)(e.strong,{children:"失真"}),"问题。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\n\nclone({ m: () => {}, s: Symbol('s') }) // {}\nclone([1, Infinity, NaN]) // [1, null, null]\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样显然是不可取的，建议你还是老老实实地手动遍历属性去实现克隆。"}),"\n",(0,r.jsx)(e.p,{children:"即便目的不是克隆，序列化一个对象也是常见的操作，比如 POST 接口提交，就要把对象变成 JSON 文本，塞入到 body 中去。"}),"\n",(0,r.jsxs)(e.p,{children:["一般来说，对于对象而言，",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 会递归遍历自身的",(0,r.jsx)(e.strong,{children:"可枚举的、以字符串为 key 的属性"}),"。根据我们前面学习过的遍历对象的知识，这正好是 ",(0,r.jsx)(e.code,{children:"Object.keys/values/entries"})," 的逻辑。于是，",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 在普通对象上的遍历过程大致是："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function stringify(obj) {\n    for (const [key, value] of Object.entries(obj)) {\n        if (isObject(value)) {\n            stringify(value) // 递归\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["但是，重点来了，如果你的对象有一个叫做 ",(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"toJSON"})})," 的函数，在自身也好，在原型链上也好，那么 ",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 就调用这个函数而不再去遍历对象属性。"]}),"\n",(0,r.jsxs)(e.p,{children:["当然 toJSON 的返回值并不会直接作为 ",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 的输出，更像是递归传入 ",(0,r.jsx)(e.code,{children:"JSON.stringify"}),"。我把 ",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 的关键逻辑画成下面的图："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["目前在 ECMAScript 内置的对象类型中，只有 ",(0,r.jsx)(e.strong,{children:"Date"})," 定义了 toJSON，它返回了等价于调用 ",(0,r.jsx)(e.strong,{children:"toISOString"})," 的字符串："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'JSON.stringify({now: new Date}) // {"now":"2023-07-10T13:11:15.960Z"}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["本质上来说，",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 就是一套映射函数，对于对象（包括数组）这种结构化数据进行递归调用。toJSON 就如同开了一个后门，能够更简单地让对象决定自己的 JSON 表述是什么样子的。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["\uD83D\uDCA1 ECMAScript 最早在 ES5 引入 JSON API 时，就支持了 ",(0,r.jsx)(e.code,{children:"toJSON"})," 的功能，现在回想起来，那个时候还不支持 Symbol，否则的话，会不会更有可能预设一个 ",(0,r.jsx)(e.em,{children:"Symbol.toJSON"})," 来实现同样的能力呢？"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["如果你的对象中有一些属性不想被序列化，那么可以考虑定义成不可枚举的，或者以 Symbol 而不是 String 为 key。如果这样不方便，我们也有办法，那就需要使用 ",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 的第二个参数 ",(0,r.jsx)(e.code,{children:"replacer"})," 了。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"replacer"})," 可以是一个函数也可以是一个数组，TypeScript 是这样定义的："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-ts",children:"stringify(value: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;\nstringify(value: any, replacer?: (number | string)[] | null, space?: string | number): string;\n"})}),"\n",(0,r.jsxs)(e.p,{children:["当作为函数的时候，它和 ",(0,r.jsx)(e.code,{children:"JSON.parse"})," 中的 ",(0,r.jsx)(e.code,{children:"reviver"})," 有异曲同工之妙，只不过 ",(0,r.jsx)(e.code,{children:"reviver"})," 先遍历到最底层的节点，而 ",(0,r.jsx)(e.code,{children:"replacer"})," 先遍历最上层的节点。我们还是以前面的数据为例："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'JSON.stringify({\n    "name": "Mike",\n    "education": {\n        "college": "MIT",\n        "major": "computer"\n    },\n    "experiences": [{\n        "from": "2017-08-20",\n        "to": "2018-03-05",\n        "employer": "Google"\n    },\n    {\n        "from": "2018-03-17",\n        "to": "2020-07-28",\n        "employer": "Microsoft"\n    }]\n}, function(key, value) {\n    console.log(key);\n    return value;\n})\n'})}),"\n",(0,r.jsx)(e.p,{children:"console.log 的打印结果是："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'""\n"name"\n"education"\n"college"\n"major"\n"experiences"\n"0"\n"from"\n"to"\n"employer"\n"1"\n"from"\n"to"\n"employer"\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"replacer"})," 函数的作用就是“篡改”序列化之后的数据，举个简单的例子："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"JSON.stringify({\n    name: 'Tom'\n}, function(key ,val) {\n    if (key === 'name') return 'Mike';\n    return val;\n});\n"})}),"\n",(0,r.jsxs)(e.p,{children:["其结果就是 ",(0,r.jsx)(e.code,{children:'{"name":"Mike"}'}),"。当然了，和 ",(0,r.jsx)(e.code,{children:"reviver"})," 一样，",(0,r.jsx)(e.code,{children:"replacer"})," 也有 key 冲突等问题，不再多说。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"replacer"})," 还可以是一个数组，不过这个时候它就只能发挥一个白名单的作用，并不能实现值的替换。"]}),"\n",(0,r.jsxs)(e.p,{children:["数组的成员只能是数字或者字符串。数字会被 ",(0,r.jsx)(e.code,{children:"ToString"})," 转换成字符串，当数字作为一个对象的属性名时也会这样做。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"replacer"})," 也会认可 String 对象和 Number 对象，甚至它们的子类，比如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'class MyString extends String {}\n\nJSON.stringify({\n    name: \'Tom\',\n    age: 15\n}, [new MyString("name")]); // {"name": "Tom"}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["根据遍历的顺序，我们知道，如果上层的 key 没有出现在 ",(0,r.jsx)(e.code,{children:"replacer"})," 数组中，那么其 value 会被直接丢弃，即便里面有 key 在 ",(0,r.jsx)(e.code,{children:"replacer"})," 中："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'JSON.stringify({\n    name: \'Tom\',\n    education: {\n        college: "MIT",\n        major: "computer"\n    }\n}, ["name", "major"]); // {"name": "Tom"}\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["\uD83D\uDCA1 如果要序列化的对象有不同层级、语义的同名 key，那么要更小心地使用 ",(0,r.jsx)(e.code,{children:"replacer"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["另外，如果要序列化一个数组，那么数组形式的 ",(0,r.jsx)(e.code,{children:"replacer"})," 是无效的："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'JSON.stringify(\n    [1,2,3,4,5],\n    [0,3] // ❌ 参数无效\n) // "[1,2,3,4,5]"\n'})}),"\n",(0,r.jsxs)(e.p,{children:["到目前为止，",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 输出的字符串还都是单行的，为了更好地阅读，我们习惯于使用它的第三个参数 ",(0,r.jsx)(e.code,{children:"space"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"space"})," 可以是数字也可以是字符串（包括它们的对象形式），语义上代表缩进的字符或者空白的个数。如果是数字，比如 N，那么格式化后的 JSON 字符串每层级就会缩进 N 个空格（0x20）："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'JSON.stringify(\n    {\n        name: "Mike",\n        education: {\n            college: "MIT",\n            major: "computer",\n        },\n    },\n    null,\n    8\n);\n'})}),"\n",(0,r.jsx)(e.p,{children:"8 空格缩进："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'{\n        "name": "Mike",\n        "education": {\n                "college": "MIT",\n                "major": "computer"\n        }\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["如果我们想缩进 Tab（0x9） 而不是空格，那么就需要把 ",(0,r.jsx)(e.code,{children:"space"})," 设置成字符串："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'JSON.stringify(\n    {\n        name: "Mike",\n        education: {\n            college: "MIT",\n            major: "computer",\n        },\n    },\n    null,\n    \'\\u0009\' // Tab\n);\n'})}),"\n",(0,r.jsxs)(e.p,{children:["需要注意的是，缩进字符不能超过 10 个，",(0,r.jsx)(e.code,{children:"space"})," 如果是数字，超过 10 会被当作 10；如果是字符串，超过 10 的码元会被截断，比如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"JSON.stringify({ name: 'Mike' },null, new Array(12).fill('/').join('')) // 12\n"})}),"\n",(0,r.jsx)(e.p,{children:"得到的是："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:'{\n//////////"name": "Mike"\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"你可以数一数，缩进只有 10 个 “/”，而不是传入的 12。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"\uD83D\uDCA1 注意多码元字符可能会被在中间截断，造成字符破坏。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"以上就是 JSON 的解析和序列化的细节知识，掌握它们能够增强你所写代码的健壮性和简洁性。在实际开发中，还有一些涉及到 JSON 的场景。"}),"\n",(0,r.jsxs)(e.h2,{id:"json-的常见场景",children:["JSON 的常见场景",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#json-的常见场景",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["JSON 的文本特征，最适合用来做网络传输。在 fetch 之前，我们使用 ",(0,r.jsx)(e.code,{children:"XMLHttpRequest"})," 也可以直接解析 JSON 格式的响应内容："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const xhr = new XMLHttpRequest();\n\nxhr.responseType = 'json';\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这样最后 ",(0,r.jsx)(e.strong,{children:"xhr.response"})," 就直接是 JSON 对象。如果服务端可以返回多种格式，但是期望它返回 JSON，那么就需要主动设置 HTTP 的 ",(0,r.jsx)(e.strong,{children:"Accept"})," 请求头："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"xhr.setRequestHeader('Accept', 'application/json');\n"})}),"\n",(0,r.jsx)(e.p,{children:"如果发送出去的数据也是 JSON，那么："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"xhr.setRequestHeader('Content-Type', 'application/json');\n\nxhr.open('POST', '/submit');\n\nxhr.send(JSON.stringify({ name: 'Mike' }));\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样发送出去的 HTTP 请求大概就是："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-http",children:'POST /submit HTTP/1.1\nAccept: application/json\nContentType: application/json\n\n{"name":"Mike"}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["以上等价的 ",(0,r.jsx)(e.code,{children:"fetch"})," 写法就是："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:'fetch("/submit", {\n    headers: {\n        accept: "application/json",\n        "content-type": "application/json",\n    },\n    body: JSON.stringify{name: "Mike"},\n    method: "POST",\n});\n'})}),"\n",(0,r.jsxs)(e.p,{children:["一些网络封装库，如 ",(0,r.jsx)(e.strong,{children:"jQuery"}),"、",(0,r.jsx)(e.strong,{children:"axios"})," 等等为了简化使用，都已经将以上 JSON 细节隐藏了起来，但大家都应该知道其原理，该操作什么。"]}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本文作为进阶篇的首篇，为大家展现了即便是最常见的 JSON API，也隐藏了大量足以影响代码健壮性的细节，有时候往往就是对代码细节的把握，才能体现一个人能力水平的高低。"}),"\n",(0,r.jsxs)(e.p,{children:["简短总结，掌握 JSON 规范中定义的那几种有限数据类型，就能判断 ",(0,r.jsx)(e.code,{children:"JSON.parse"})," 能工作的范围。相比之下，",(0,r.jsx)(e.code,{children:"JSON.stringify"})," 有更多的策略，比如什么样的 JavaScript 类型会被映射到什么样的 JSON 类型。再加上 ",(0,r.jsx)(e.code,{children:"toJSON"})," “后门”的影响，导致一个对象转换成 JSON 字符串再解析回来，往往和原来有较大差别。"]}),"\n",(0,r.jsx)(e.p,{children:"它们各自的额外参数，都能在解析和序列化过程中发挥作用，影响最后的结果。在数据结构清晰可预测的条件下，往往可以作为一种高级用法，简化业务的实现。"}),"\n",(0,r.jsxs)(e.p,{children:["JSON 常常用作网络通信的格式，但作为线下的配置文件，比如 package.json，也存在着诸如不支持注释的不便之处，这时候可能是一些社区拓展方案，比如 ",(0,r.jsx)(e.a,{href:"https://json5.org/",target:"_blank",rel:"noopener noreferrer",children:"json5"})," 的用武之处，大家可以进一步了解。"]}),"\n",(0,r.jsx)(e.p,{children:"下一节，我们来掌握一些常用的内存数据结构。"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,c.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F14%20%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BD%9C%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20JSON%20%E9%82%A3%E4%BA%9B%E4%BA%8B.md"]={toc:[{text:"JSON 的解析",id:"json-的解析",depth:2},{text:"序列化成 JSON",id:"序列化成-json",depth:2},{text:"JSON 的常见场景",id:"json-的常见场景",depth:2},{text:"小结",id:"小结",depth:2}],title:"14 进阶篇｜你不知道的 JSON 那些事",headingTitle:"14 进阶篇｜你不知道的 JSON 那些事",frontmatter:{}}}}]);