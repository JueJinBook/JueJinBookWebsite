"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["79616"],{313469:function(e,n,s){s.r(n),s.d(n,{default:()=>_});var c=s(552676),i=s(740453);let r=s.p+"static/image/66bad9a3f68e61fb99c9772905a76091.4217c8c0.webp",t=s.p+"static/image/29f37828104fb997a1a97d75dfb9aeaf.12886040.webp",p=s.p+"static/image/5e31f23ae9f616dbff55275955e9f828.81b25b94.webp",d=s.p+"static/image/537cc3c93fe8c7f611deaaf1bb957fa3.bda4f32d.webp",a=s.p+"static/image/233d8481aed42c88676befb3101f648f.cbbb5394.webp",l=s.p+"static/image/822d07602ddd8cb9734c6491c54e723b.9a640814.webp",h=s.p+"static/image/0f9612829f0adfdadd5b09c0b00dc6a2.fafcc05f.webp",o=s.p+"static/image/94ba27d4b5c9369aaf8369f555d61590.ac2d3866.webp",j=s.p+"static/image/ca688aff9068c85055f5a0813e3b6ee5.67a547b2.webp",x=s.p+"static/image/3c734c69ffebcfae1677e976854452eb.beed9330.webp",b=s.p+"static/image/19ac68312560a13cff3f660c6815a58f.f54c36d9.webp",m=s.p+"static/image/d4522fb78f26f97e910ddae6387a3b51.7213c127.webp",f=s.p+"static/image/251d5e8fa9c13cc1c9ac66e3285dbb92.f583f03c.webp",g=s.p+"static/image/915dea037128fcbcb23d7477e490a563.bc153f54.webp",y=s.p+"static/image/4702b72e276524d46e09b5cfc02aa8f1.e8e031e9.webp",T=s.p+"static/image/1d4f17d9d85212e02045b517ed3598e8.dc33b950.webp",u=s.p+"static/image/5da39a843d40c769c848f850d922f298.caaac237.webp",k=s.p+"static/image/cd4584519e64ff6f4d5a52e344d9faf4.ba008028.webp",v=s.p+"static/image/0eb74b31791b0a5368c83cc66ebd243c.02e47e3b.webp",N=s.p+"static/image/42e29c3cc7992a677d3e85768b025c85.cf91482d.webp",w=s.p+"static/image/88f5615bd34bec52f77f1b0fbb043d85.3c434c3f.webp",E=s.p+"static/image/abde769f87f221a6f316ef1b977d96a2.b86c70a0.webp",C=s.p+"static/image/60420aa2a78d1cb8834759049a6da977.3d38e73f.webp",S=s.p+"static/image/b845b9c249223773bef32c11d880057b.4c65294c.webp";function F(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",ul:"ul",li:"li",code:"code",h2:"h2",pre:"pre",h3:"h3"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"20原理篇如何阅读-typescript-源码",children:["20.原理篇：如何阅读 TypeScript 源码",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#20原理篇如何阅读-typescript-源码",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"讲类型编程的时候，分布式条件类型是比较麻烦的一个点："}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)("img",{src:S,alt:""}),"\n",(0,c.jsx)("img",{src:C,alt:""})]}),"\n",(0,c.jsx)(n.p,{children:"Test<T> 这个高级类型，有一个泛型参数 T，当 T 传入的类型为联合类型的时候，有两种情况："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"如果 checkType（extends 左边的类型） 是 T，则把联合类型拆开后解析类型，最后合并成一个联合类型返回。"}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:"如果 checkType 不是 T，把联合类型整体作为 T 来解析，返回解析后的类型。"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["这个语法叫 Distributive Condition Type，分布式条件类型。设计的目的就是为了简化 ",(0,c.jsx)(n.code,{children:"Test<number> | Test<boolean>"})," 的情况。"]}),"\n",(0,c.jsx)(n.p,{children:"我们通过这个语法的实现作为抓手，来探究一下 ts 源码应该怎么读。"}),"\n",(0,c.jsxs)(n.h2,{id:"类型的表示法类型对象",children:["类型的表示法：类型对象",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型的表示法类型对象",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"ts 会把源码进行 parse，生成 AST，然后从 AST 中解析出类型信息。"}),"\n",(0,c.jsxs)(n.p,{children:["ts 的类型信息是通过类型对象来存储的，我们来看几个例子。（可视化的查看 AST 可以使用 ",(0,c.jsx)(n.a,{href:"https://astexplorer.net/#/gist/bd6031c7ab25e3d33e8899b3914e9357/f36b635cedba9a6939953631e66868ab322f65d2",target:"_blank",rel:"noopener noreferrer",children:"astexplorer.net"})," 这个网站。）"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:E,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"上面定义了四个类型："}),"\n",(0,c.jsxs)(n.p,{children:["a 类型是 ",(0,c.jsx)(n.code,{children:"LiteralType"}),"，字面量类型，literal 属性保存具体的字面量，这里是 NumericLiteral，数字字面量。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:w,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["b 类型是 ",(0,c.jsx)(n.code,{children:"UnionType"}),"，联合类型，types 属性保存了它所包含的类型，这里是两个 LiteralType"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:N,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["T extends boolean 这部分是一个 ",(0,c.jsx)(n.code,{children:"ConditionType"}),"，有 checkType、extendsType、trueType、falseType 四个属性分别代表不同的部分。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:v,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:k,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["可以看到，T 是一个 ",(0,c.jsx)(n.code,{children:"TypeReference"})," 类型，也就是它只是一个变量引用，具体的值还是泛型参数传入的类型。"]}),"\n",(0,c.jsxs)(n.p,{children:["Test<number | boolean> 也是一个 ",(0,c.jsx)(n.code,{children:"TypeReference"}),"，类型引用。有 typeName 和 typeArguments 两个属性，typeName 就是它引用的类型 Test，typeArguments 就是泛型参数的值，这里是 UnionType。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"所以说，类型在 ts 里面都是通过类型对象来表示的。"}),"\n",(0,c.jsxs)(n.p,{children:["比较特别的是 ",(0,c.jsx)(n.code,{children:"TypeReference"})," 类型，它只是一个引用，具体的类型还得把类型参数传入所引用的类型，然后求出最终类型。比如这里的 Test<number | boolean> 的类型，最终的类型是把参数 number | boolean 传入定义的那个 ConditionType 来求出的。这就是 ts 的",(0,c.jsx)(n.code,{children:"高级类型"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"理解了类型是怎么表示的，高级类型和泛型参数都是什么，接下来我们就可以正式通过调试 ts 源码来看下 ConditionType 的解析过程了。"}),"\n",(0,c.jsxs)(n.h2,{id:"vscode-调试-typescript-源码",children:["VSCode 调试 Typescript 源码",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vscode-调试-typescript-源码",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"首先，我们要把 ts 源码下载下来："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-shell",children:"git clone git@github.com:microsoft/TypeScript.git\n"})}),"\n",(0,c.jsx)(n.p,{children:"reset 到我当时看的 commit："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"git reset --hard df673f74f5cf4fa1948ad2f8c25e6a0290d212ea\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后可以看到 lib 目录下有 tsc.js 和 typescript.js，这两个分别是 ts 的命令行和 api 的入口。"}),"\n",(0,c.jsx)(n.p,{children:"但是，这些是编译以后的 js 代码，源码在 src 下，是用 ts 写的。"}),"\n",(0,c.jsx)(n.p,{children:"怎么把编译后的 js 代码和 ts 源码关联起来呢？ sourcemap！"}),"\n",(0,c.jsx)(n.p,{children:"编译源码："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"yarn \nyarn run build:compiler\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后就可以看到多了一个 built 目录，下面有 tsc.js、typescript.js 这两个入口文件，而且也有了 sourcemap："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:T,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:y,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"接下来就可以直接调试 ts 源码，而不是编译后的 js 代码了。"}),"\n",(0,c.jsx)(n.p,{children:"我们来试试："}),"\n",(0,c.jsxs)(n.h3,{id:"vscode-直接调试-ts",children:["vscode 直接调试 ts",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vscode-直接调试-ts",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"vscode 在项目根目录下的 .vscode/launch.json 下保存调试配置："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"我们添加一个调试配置："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'{\n    "name": "调试 ts 源码",\n    "program": "${workspaceFolder}/built/local/tsc.js",\n    "request": "launch",\n    "skipFiles": [\n        "<node_internals>/**"\n    ],\n    "args": [\n        "./input.ts"\n    ],\n    "stopOnEntry": true,\n    "type": "node"\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"含义如下："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"name： 调试配置的名字"}),"\n",(0,c.jsx)(n.li,{children:"program：调试的目标程序的地址"}),"\n",(0,c.jsx)(n.li,{children:"request：有 launch 和 attch 两个取值，代表启动新的还是连上已有的"}),"\n",(0,c.jsx)(n.li,{children:"skipFiles：调试的时候跳过一些文件，这里配置的是跳过 node 内部的那些文件，调用栈会更简洁"}),"\n",(0,c.jsx)(n.li,{children:"args：命令行参数"}),"\n",(0,c.jsx)(n.li,{children:"stopOnEntry：是否在首行加个断点"}),"\n",(0,c.jsx)(n.li,{children:"type：调试的类型，这里是用 node 来跑"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"保存之后就可以在调试面板看到该调试选项："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这里我们设计的 input.ts 是这样的："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'type Test<T> = T extends boolean ? "Y" : "N";\n\ntype res = Test<number | boolean>;\n'})}),"\n",(0,c.jsx)(n.p,{children:"在 ts 的 checker.ts 部分打个断点，然后点击启动调试。"}),"\n",(0,c.jsx)(n.p,{children:"然后，看，这断住的地方，就是 ts 源码啊，不是编译后的 js 文件。这就是 sourcemap 的作用。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"还可以在左边文件树看到源码的目录结构，这比调试编译后的 js 代码爽多了。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"会了通过 sourcemap 调试源码之后，我们该进入主题了： 通过源码探究分布式条件类型的实现原理。"}),"\n",(0,c.jsx)(n.p,{children:"其实我们上面使用的是 tsc.js 的命令行入口来调试的，这样其实代码比较多，很难理清要看哪部分代码。怎么办呢？"}),"\n",(0,c.jsx)(n.p,{children:"接下来就是我的秘密武器了，用 typescript compiler api。"}),"\n",(0,c.jsxs)(n.h2,{id:"typescript-compiler-api",children:["typescript compiler api",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#typescript-compiler-api",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"ts 除了命令行工具的入口外，也提供了 api 的形式，只是我们很少用。但它对于探究 ts 源码实现有很大的帮助。"}),"\n",(0,c.jsx)(n.p,{children:"我们定义个 test.js 文件，引入 typescript 的包："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'const ts = require("./built/local/typescript");\n'})}),"\n",(0,c.jsx)(n.p,{children:"然后用 ts 的 api 传入编译配置，并 parse 源码成 ast："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'const filename = "./input.ts";\nconst program = ts.createProgram([filename], {\n    allowJs: false\n});\nconst sourceFile = program.getSourceFile(filename);\n'})}),"\n",(0,c.jsx)(n.p,{children:"这里的 createProgram 第二个参数是编译配置，就是 compilerOptions。"}),"\n",(0,c.jsx)(n.p,{children:"program.getSourceFile 返回的就是 ts 的 AST。"}),"\n",(0,c.jsx)(n.p,{children:"并且还可以拿到 typeChecker："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"const typeChecker = program.getTypeChecker();\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后呢？typeChecker 是类型检查的 api，我们可以遍历 AST 找到检查的 node，然后调用 checker 的 api 进行检查："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"function visitNode(node) {\n    if (node.kind === ts.SyntaxKind.TypeReference)  {\n        const type = typeChecker.getTypeFromTypeNode(node);\n\n        debugger;\n    }\n\n    node.forEachChild(child =>\n        visitNode(child)\n    );\n}\n\nvisitNode(sourceFile);\n"})}),"\n",(0,c.jsx)(n.p,{children:"我们判断了如果 AST 是 TypeReference 类型，则用 typeChecker.getTypeFromTypeNode 来解析类型。"}),"\n",(0,c.jsx)(n.p,{children:"接下来就可以精准的调试该类型解析的逻辑了，相比命令行的方式来说，更方便理清逻辑。"}),"\n",(0,c.jsx)(n.p,{children:"完整代码如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'const ts = require("./built/local/typescript");\n\nconst filename = "./input.ts";\nconst program = ts.createProgram([filename], {\n    allowJs: false\n});\nconst sourceFile = program.getSourceFile(filename);\nconst typeChecker = program.getTypeChecker();\n\nfunction visitNode(node) {\n    if (node.kind === ts.SyntaxKind.TypeReference)  {\n        const type = typeChecker.getTypeFromTypeNode(node);\n\n        debugger;\n    }\n\n    node.forEachChild(child =>\n        visitNode(child)\n    );\n}\n\nvisitNode(sourceFile);\n'})}),"\n",(0,c.jsx)(n.p,{children:"我们改下调试配置，然后开始调试："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:'{\n    "name": "调试 ts 源码",\n    "program": "${workspaceFolder}/test.js",\n    "request": "launch",\n    "skipFiles": [\n        "<node_internals>/**"\n    ],\n    "args": [\n    ],\n    "type": "node"\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"在 typeChecker.getTypeFromTypeNode 这行打个断点，我们去看下具体的类型解析过程。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"然后，XDM，打起精神，本文的高潮部分来了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"我们进入了 getTypeFromTypeNode 方法，这个方法就是根据 AST 的类型来做不同的解析，返回类型对象的。各种类型解析的逻辑都是从这里进入的，这是一个重要的交通枢纽。"}),"\n",(0,c.jsx)(n.p,{children:"然后我们进入了 TypeReference 的分支，因为 Test<number | boolean> 就是一个类型引用嘛。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"TypeReference 的类型就是它引用的类型，它引用了 ConditionType，所以会再解析 T extends boolean 这个 ConditionType 的类型："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"所有的类型都是按照 ast node 的 id 存入一个 nodeLinks 的 map 中来缓存，只有第一次需要解析，之后直接拿结果。比如上图的 resolvedType 就存入了 nodeLinks 来缓存。"}),"\n",(0,c.jsx)(n.p,{children:"然后，XDM，看到闪闪发光的那行代码了么？"}),"\n",(0,c.jsx)(n.p,{children:"解析 ConditionType 的类型的时候会根据 checkType 部分是否是类型参数（TypeParameter，也就是泛型）来设置 isDistributive 属性。"}),"\n",(0,c.jsx)(n.p,{children:"之后解析 TypeReference 类型的时候，会传入具体的类型来实例化："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这里就判断了 conditionType 的 isDistributive 属性，如果是，则把 unionType 的每个类型分别传入来解析，最后合并返回。"}),"\n",(0,c.jsx)(n.p,{children:"如图，我们走到了 isDistributive 为 true 的这个分支。"}),"\n",(0,c.jsx)(n.p,{children:"那么解析出的类型就是 'Y' | 'N' 的联合类型。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"那我们把 input.ts 代码改一下呢："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'type Test<T> = [T] extends [boolean] ? "Y" : "N";\n\ntype res = Test<number | boolean>;\n'})}),"\n",(0,c.jsx)(n.p,{children:"checkType 不直接写类型参数 T 了。"}),"\n",(0,c.jsx)(n.p,{children:"再跑一次："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这次没进去了。"}),"\n",(0,c.jsx)(n.p,{children:"难道说？"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"确实，这样的结果就是 N。"}),"\n",(0,c.jsxs)(n.p,{children:["说明了什么？说明了 ",(0,c.jsx)(n.code,{children:"ConditionType 是根据 checkType 是否是类型参数来设置了 isDistributive 属性，之后解析 TypeReference 的时候根据 isDistributive 的值分别做了不同的解析。"})]}),"\n",(0,c.jsx)(n.p,{children:"那么只要 checkType 不是 T 就行了。"}),"\n",(0,c.jsx)(n.p,{children:"所以这样也行："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这样也行："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"我们经常用 [T] 来避免 distributive 只不过这样比较简洁，看完源码我们知道了，其实别的方式也行。"}),"\n",(0,c.jsx)(n.p,{children:"就这样，我们通过源码理清了这个语法的实现原理。"}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我们以探究 distributive condition type 的实现原理为目的来阅读了 typescript 源码。"}),"\n",(0,c.jsx)(n.p,{children:"首先把 typescript 源码下载下来，执行编译，生成带有 sourcemap 的代码，之后在 vscode 里调试，这样可以直接调试编译前的源码，信息更多。"}),"\n",(0,c.jsx)(n.p,{children:"typescript 有 cli 和 api 两种入口，用 cli 的方式无关代码太多，比较难理清，所以我们用 api 的方式来写了一段测试代码，之后打断点来调试。"}),"\n",(0,c.jsxs)(n.p,{children:["ts 的类型信息保存在类型对象中，这个可以用 ",(0,c.jsx)(n.a,{href:"https://astexplorer.net/#/gist/bd6031c7ab25e3d33e8899b3914e9357/f36b635cedba9a6939953631e66868ab322f65d2",target:"_blank",rel:"noopener noreferrer",children:"astexplorer.net"})," 来可视化的查看。"]}),"\n",(0,c.jsx)(n.p,{children:"用 typeChecker.getTypeFromTypeNode 可以拿到某个类型的具体值，我们就是通过这个作为入口来探究各种类型的解析逻辑。"}),"\n",(0,c.jsx)(n.p,{children:"源码中比较重要的有这么几点："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"getTypeFromTypeNode 方法是通过 node 获取类型的入口方法，所有 AST 的类型对象都是通过这个方法拿到"}),"\n",(0,c.jsx)(n.li,{children:"nodeLinks 保存了解析后的类型，key 为 node id，这样解析一遍就好了，下次拿缓存。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"之后我们看了 ConditionType 的解析逻辑会根据 checkType 是否为类型参数来设置 isDistributive 属性，然后 TypeReference 实例化该类型的时候会根据 isDistributive 的值进入不同的处理逻辑，这就是它的实现原理。"}),"\n",(0,c.jsx)(n.p,{children:"理解了原理之后，我们再使用 distributive condition type 就心里有底了，还可以创造很多变形使用，不局限于 [T]。"}),"\n",(0,c.jsx)(n.p,{children:"本文以调试一个类型解析逻辑的原理为抓手探究了 ts 源码阅读方式，调试 ts 别的部分的代码，或者调试其他的库也是类似的。"}),"\n",(0,c.jsx)(n.p,{children:"大家想探究某个类型语法实现原理的时候，可以通过源码层面来彻底搞清楚。"})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(F,{...e})}):F(e)}let _=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F20.%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%9A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%20TypeScript%20%E6%BA%90%E7%A0%81.md"]={toc:[{text:"类型的表示法：类型对象",id:"类型的表示法类型对象",depth:2},{text:"VSCode 调试 Typescript 源码",id:"vscode-调试-typescript-源码",depth:2},{text:"vscode 直接调试 ts",id:"vscode-直接调试-ts",depth:3},{text:"typescript compiler api",id:"typescript-compiler-api",depth:2},{text:"总结",id:"总结",depth:2}],title:"20.原理篇：如何阅读 TypeScript 源码",headingTitle:"20.原理篇：如何阅读 TypeScript 源码",frontmatter:{}}}}]);