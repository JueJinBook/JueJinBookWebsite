"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["63630"],{765022:function(e,n,o){e.exports=o.p+"static/image/07e5ba83eea3d63d9a55f652deacd472.08869bef.webp"},265737:function(e,n,o){e.exports=o.p+"static/image/c4e21775cd78b04cae494f90b75810d9.c1591a01.webp"},700894:function(e,n,o){e.exports=o.p+"static/image/f818cadfa75c673045a20f9c801837f7.6c8d43d1.webp"},123808:function(e,n,o){o.r(n),o.d(n,{default:()=>h});var d=o(552676),s=o(740453),r=o(700894),l=o(265737),c=o(765022);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",code:"code",blockquote:"blockquote",h2:"h2",img:"img",h3:"h3",pre:"pre",ul:"ul",li:"li",h4:"h4",ol:"ol",h5:"h5"},(0,s.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"5-模块机制详解cjs-与-esm下",children:["5-模块机制详解：CJS 与 ESM（下）",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-模块机制详解cjs-与-esm下",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsxs)(n.strong,{children:["我摊牌了，我对 ESM 不熟，对 ",(0,d.jsx)(n.code,{children:"import"})," 不熟。本章大家就看个乐呵吧，我先去翻一遍源码。"]})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"这让我想起了我的高中电脑老师。高中我爱去机房，有一次第二天是电脑课，好像是教一些基础的 Photoshop 操作。当天我去老师办公室，看见老师正捧着一本 Photoshop 的入门书在学呢。"}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"作为对比的工具人commonjs",children:["作为对比的工具人：CommonJS",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#作为对比的工具人commonjs",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"在讲 ECMAScript modules 之前，作为对比，我还是再点一下 CommonJS。"}),"\n",(0,d.jsx)(n.p,{children:"我们在上一章中讲了，在 Node.js 中，CommonJS 的加载过程是由路径到源码，再到函数，最后通过执行函数注入灵魂，这某种意义上其实是返璞归真——IIFE。由“五步画马”可得："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:c,alt:""})}),"\n",(0,d.jsxs)(n.p,{children:["从源码到函数这一步就是画马的灵魂了。上一章中没有细讲，也别指望本章细讲\uD83E\uDD2A，后面自然会讲到的。这里提一下，此处没有用 ",(0,d.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval",title:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval",target:"_blank",rel:"noopener noreferrer",children:"eval()"}),"，也没有用 ",(0,d.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function",title:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function",target:"_blank",rel:"noopener noreferrer",children:"new Function()"}),"。它用的是 ",(0,d.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/vm.html",title:"https://nodejs.org/dist/latest-v18.x/docs/api/vm.html",target:"_blank",rel:"noopener noreferrer",children:"vm 模块"}),"。"]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.p,{children:["此处默认大家知道 ",(0,d.jsx)(n.code,{children:"vm"})," 模块是做什么用的。若暂时还不知道，先去看一眼",(0,d.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/vm.html",title:"https://nodejs.org/dist/latest-v18.x/docs/api/vm.html",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"吧。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["在用户模块代码加上前后缀后，早年间是通过 ",(0,d.jsx)(n.code,{children:"vm"})," 中的 ",(0,d.jsx)(n.code,{children:"Script"})," 类生成了脚本对象，然后通过执行它得到对应的函数。但这有个问题，会影响到错误堆栈，毕竟错误堆栈中展示的行号可能会多出一行，或者首行会变成前缀内容（详见",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/issues/17396",title:"https://github.com/nodejs/node/issues/17396",target:"_blank",rel:"noopener noreferrer",children:"此 Issue"}),"）。聪明的人们学会了通过其他方式来编译这么个函数——不走 ",(0,d.jsx)(n.code,{children:"Script"}),"，而是用 C++ 侧的对应函数 ",(0,d.jsx)(n.code,{children:"compileFunction()"}),"（详见",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/commit/5f8ccecaa2e44c4a04db95ccd278a7078c14dd77",title:"https://github.com/nodejs/node/commit/5f8ccecaa2e44c4a04db95ccd278a7078c14dd77",target:"_blank",rel:"noopener noreferrer",children:"此 PR"}),"），并在",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1149-L1162",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/cjs/loader.js#L1149-L1162",target:"_blank",rel:"noopener noreferrer",children:"编译的过程"}),"中，把 ",(0,d.jsx)(n.code,{children:"importModuleDynamically()"})," 给注入进去，让 CommonJS 模块也拥有了 ",(0,d.jsx)(n.code,{children:"await import()"})," 的能力。在 C++ 侧的 ",(0,d.jsx)(n.code,{children:"CompileFunction()"}),"，直接调用了 V8 的 ",(0,d.jsx)(n.code,{children:"ScriptCompiler::CompileFunction()"})," 等能力去生成对应的函数，定义好参数就好，不会影响堆栈信息；而 ",(0,d.jsx)(n.code,{children:"vm"})," 中的 ",(0,d.jsx)(n.code,{children:"Script"})," 原理类似，只不过是调用 V8 的 ",(0,d.jsx)(n.code,{children:"ScriptCompiler::CompileUnboundScript()"}),"，前者直接编译成函数，后者需要编译成一段脚本，需要通过 IIFE 的方式再立马执行它。",(0,d.jsx)(n.strong,{children:"上面这一段废话话看也可以，不看也不用细究，鉴于二者原理近似，只要记住"})," ",(0,d.jsx)(n.strong,{children:"Node.js"})," ",(0,d.jsx)(n.strong,{children:"的 CommonJS 模块是通过类似"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"vm"})})," ",(0,d.jsx)(n.strong,{children:"模块的方式编译的函数，再像泡芙一样被注入就好了。"})]}),"\n",(0,d.jsxs)(n.h2,{id:"nodejs-中的-ecmascript-modulesmodulewrap",children:["Node.js 中的 ECMAScript modules：",(0,d.jsx)(n.code,{children:"ModuleWrap"}),(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-中的-ecmascript-modulesmodulewrap",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["知道了 CommonJS 模块本质是 ",(0,d.jsx)(n.code,{children:"vm"})," 模块下对于用户代码的 IIFE 泡芙，接下去再看看 Node.js 中 ECMAScript modules 是什么吧。"]}),"\n",(0,d.jsxs)(n.p,{children:["CommonJS 下，一个模块是 ",(0,d.jsx)(n.code,{children:"Module"})," 实例，在这里面发生了上面讲的化学变化。而 ECMAScript modules 本质是一个 C++ 侧实现的 JavaScript 对象 ",(0,d.jsx)(n.code,{children:"ModuleWrap"}),"，再往下翻一番，是 V8 中一个叫 ",(0,d.jsx)(n.code,{children:"Module"})," 的概念。"]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.h3,{children:"小知识"}),"\n",(0,d.jsxs)(n.p,{children:["在 V8 中，每一种内置 JavaScript 类型，在 C++ 侧都有对应的类去承载。像数字类型，就是 ",(0,d.jsx)(n.code,{children:"Number"}),"；对象类型就是 ",(0,d.jsx)(n.code,{children:"Object"}),"……而又根据其生命周期（局部变量、全局变量），又被不同句柄所表示。比如一个局部变量的 ",(0,d.jsx)(n.code,{children:"Number"})," 类型，就是 ",(0,d.jsx)(n.code,{children:"Local<Number>"}),"；一个全局变量的 ",(0,d.jsx)(n.code,{children:"Object"}),"，则是 ",(0,d.jsx)(n.code,{children:"Global<Number>"}),"。此全局非彼全局，篇幅所限，点到为止，大家意会一下即可，真想了解，自卖自夸《Node.js：来一打 C++ 扩展》，或者去网上翻阅关于 V8 的 ",(0,d.jsx)(n.code,{children:"Local"}),"、",(0,d.jsx)(n.code,{children:"Global"}),"、",(0,d.jsx)(n.code,{children:"Persistent"})," 等句柄的文章。"]}),"\n",(0,d.jsxs)(n.p,{children:["由于 ECMAScript modules 是 ECMAScript 规范中的概念，在 V8 中，也有对象去展示它，就是 ",(0,d.jsx)(n.code,{children:"Module"}),"。",(0,d.jsx)(n.strong,{children:"此处指的是 V8 概念里的"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"Module"})})," ",(0,d.jsx)(n.strong,{children:"，不是"})," ",(0,d.jsx)(n.strong,{children:"Node.js"})," ",(0,d.jsx)(n.strong,{children:"中 CommonJS 对应的"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"Module"})})," ",(0,d.jsx)(n.strong,{children:"类。"})," ",(0,d.jsx)(n.code,{children:"Local<Module>"})," 指的是在当前闭包作用域中有效的模块对象；",(0,d.jsx)(n.code,{children:"Global<Module>"})," 则指的是长生命周期的模块对象。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"ModuleWrap"})," 与 ",(0,d.jsx)(n.code,{children:"Module"})," 的关系是，每个 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 对象中，都隐含了一个 ",(0,d.jsx)(n.code,{children:"Module"})," 对象，供其操作。用大家比较好理解的 JavaScript 写伪代码，大概就像这样："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"class ModuleWrap {\n  #module;\n  ModuleWrap(<参数>) {\n    this.#module = new Module(<参数>);\n  }\n  \n  foo() {\n    this.#module.bar();\n  }\n}\n"})}),"\n",(0,d.jsxs)(n.p,{children:["这里面的 ",(0,d.jsx)(n.code,{children:"#module"}),"，就是 V8 的 ",(0,d.jsx)(n.code,{children:"Module"})," 对象了，该对象有形如 ",(0,d.jsx)(n.code,{children:"InstantiateModule()"}),"、",(0,d.jsx)(n.code,{children:"Evaluate()"})," 等方法，它们会在 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 中被使用。如果大家对于 ",(0,d.jsx)(n.code,{children:"Module"})," 感兴趣，可以看看它的 ",(0,d.jsx)(n.a,{href:"https://v8.github.io/api/head/classv8_1_1Module.html",title:"https://v8.github.io/api/head/classv8_1_1Module.html",target:"_blank",rel:"noopener noreferrer",children:"API 文档"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["而一个 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 实例，则有如下一些方法："]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"link"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"instantiate"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"evaluate"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"setExport"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"createCachedData"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"getNamespace"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"getStatus"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"getError"}),"；"]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"getStaticDependencySpecifiers"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["所以，ECMAScript modules 的本质就是一个套着 ",(0,d.jsx)(n.code,{children:"Module"})," 的 ",(0,d.jsx)(n.code,{children:"ModuleWrap"}),"，里面封装了一些 V8 对 ECMAScript 模块的方法。"]}),"\n",(0,d.jsxs)(n.h2,{id:"加载一个-ecmascript-module",children:["加载一个 ECMAScript module",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载一个-ecmascript-module",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在加载 ECMAScript modules 之前，Node.js 会先初始化一个 ",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#L181",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#L181",target:"_blank",rel:"noopener noreferrer",children:"ESM Loader"}),"。用官方注释来讲："]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"An ESMLoader instance is used as the main entry point for loading ES modules. Currently, this is a singleton -- there is only one used for loading the main module and everything in its dependency graph."}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["它是用于加载主 ESM 及其鸡犬的，Node.js 会通过调用 ",(0,d.jsx)(n.code,{children:"ESMLoader"})," 的 ",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#L509",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#L509",target:"_blank",rel:"noopener noreferrer",children:"import() 方法"}),"来完成这一操作，里面会把主入口作为一个 ",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#LL525C30-L525C30",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#LL525C30-L525C30",target:"_blank",rel:"noopener noreferrer",children:"ModuleJob"})," 去执行加载任务。绕了半天，终于要回归正轨了——这个 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 就是用来加载一个前面讲到的 ",(0,d.jsx)(n.code,{children:"ModuleWrap"}),"。篇幅有限，这里面关系错综复杂，我就不一步步溯源了。"]}),"\n",(0,d.jsxs)(n.h3,{id:"模块加载任务",children:["模块加载任务",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块加载任务",children:"#"})]}),"\n",(0,d.jsxs)(n.h4,{id:"任务构造函数",children:["任务构造函数",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#任务构造函数",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 构造函数中，会为其创建一个 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 对象。由于 ",(0,d.jsx)(n.code,{children:"import"})," 的整体流程是异步的，所以这个创建过程也是异步的。构造函数触发“创建”操作后，会将其 ",(0,d.jsx)(n.code,{children:"Promise"})," 保存起来，供后续使用。如果后续我需要使用 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 对象，就先 ",(0,d.jsx)(n.code,{children:"await"})," 该 ",(0,d.jsx)(n.code,{children:"Promise"})," 以确保创建完成。"]}),"\n",(0,d.jsxs)(n.h4,{id:"依赖树--需加载的模块集合",children:["依赖树 → 需加载的模块集合",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖树--需加载的模块集合",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["执行 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 任务的时候，先会做一个初始化的操作。这个初始化操作看起来是一个 ",(0,d.jsx)(n.code,{children:"ModuleJob"}),"，实际上会拔出萝卜带出泥，递归将所有依赖的子模块都遍历一遍，去重后生成新的 ",(0,d.jsx)(n.code,{children:"ModuleJob"}),"。如下："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"const jobsInGraph = new SafeSet();\nconst addJobsToDependencyGraph = async (moduleJob) => {\n  if (jobsInGraph.has(moduleJob)) {\n    return;\n  }\n  jobsInGraph.add(moduleJob);\n  const dependencyJobs = await moduleJob.linked;\n  return SafePromiseAllReturnVoid(dependencyJobs, addJobsToDependencyGraph);\n};\nawait addJobsToDependencyGraph(this);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["递归以 ",(0,d.jsx)(n.code,{children:"await addJobsToDependencyGraph(this)"})," 为始，以重复（",(0,d.jsx)(n.code,{children:"jobsInGraph.has(moduleJob)"}),"）作为递归边界，并在将任务加入去重集合（",(0,d.jsx)(n.code,{children:"jobsInGraph"}),"）后，通过 ",(0,d.jsx)(n.code,{children:".linked"})," 这个 ",(0,d.jsx)(n.code,{children:"Promise"})," 解析出其依赖造出新的 ",(0,d.jsx)(n.code,{children:"moduleJob"}),"。最终得到一个各自包含 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 的最终集合。相当于把树状依赖拍平，然后去重。"]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,d.jsxs)(n.p,{children:["这一套操作下来，原来“",(0,d.jsx)(n.strong,{children:"一整棵模块依赖树"}),"”被变成了“",(0,d.jsx)(n.strong,{children:"需要加载 A、B、C、D 四个模块的集合"}),"”。而这一套操作的海克斯核心科技就是 ",(0,d.jsx)(n.code,{children:"moduleJob.linked"}),"。这个 ",(0,d.jsx)(n.code,{children:"linked"})," 是在 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 执行构造函数时候，通过调用 ",(0,d.jsx)(n.code,{children:"link()"})," 函数得到的 ",(0,d.jsx)(n.code,{children:"Promise"}),"，其主要用途有两个："]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["等待 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 创建完成；"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["通过 ",(0,d.jsx)(n.code,{children:"ModuleWrap.prototype.link()"})," 方法得到当前模块的依赖信息（有哪些 ",(0,d.jsx)(n.code,{children:"import"}),"），遍历所有依赖并生成新的 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 对象，并通过 ",(0,d.jsx)(n.code,{children:"await"})," 新任务对象的 ",(0,d.jsx)(n.code,{children:"Promise"})," 等待新 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 创建完成。"]}),"\n",(0,d.jsx)(n.p,{children:"// 下方代码为了便于理解，一些 primordial 元素被我改成易于理解的不严谨方式\nconst link = async () => {\nthis.module = await this.modulePromise;\nassert(this.module instanceof ModuleWrap);"}),"\n",(0,d.jsxs)(n.p,{children:["// Explicitly keeping track of dependency jobs is needed in order\n// to flatten out the dependency graph below in ",(0,d.jsx)(n.code,{children:"_instantiate()"}),",\n// so that circular dependencies can't cause a deadlock by two of\n// these ",(0,d.jsx)(n.code,{children:"link"})," callbacks depending on each other.\nconst dependencyJobs = [];\nconst promises = this.module.link(async (specifier, assertions) => {\nconst jobPromise = this.loader.getModuleJob(specifier, url, assertions);\ndependencyJobs.push(jobPromise);\nconst job = await jobPromise;\nreturn job.modulePromise;\n});"]}),"\n",(0,d.jsx)(n.p,{children:"if (promises !== undefined)\nawait Promise.all(promises);"}),"\n",(0,d.jsx)(n.p,{children:"return Promise.all(dependencyJobs);\n};"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.h5,{id:"modulewrapprototypelink",children:[(0,d.jsx)(n.code,{children:"ModuleWrap.prototype.link()"}),(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#modulewrapprototypelink",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["为什么我在介绍 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 的时候要列举它有哪些 API，以及 V8 的 ",(0,d.jsx)(n.code,{children:"Module"})," 有什么？因为上面那块代码就用到了这个 ",(0,d.jsx)(n.code,{children:".link()"})," 方法。我们之前提到，它的作用是分析一个 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 的模块依赖并返回相关信息。"]}),"\n",(0,d.jsxs)(n.p,{children:["在 V8 中，",(0,d.jsx)(n.code,{children:"Module"})," 类有一个方法，叫 ",(0,d.jsx)(n.a,{href:"https://v8.github.io/api/head/classv8_1_1Module.html",title:"https://v8.github.io/api/head/classv8_1_1Module.html",target:"_blank",rel:"noopener noreferrer",children:"GetModuleRequests()"}),"，它的作用就是提取一个模块的依赖信息，返回 ",(0,d.jsx)(n.a,{href:"https://v8.github.io/api/head/classv8_1_1ModuleRequest.html",title:"https://v8.github.io/api/head/classv8_1_1ModuleRequest.html",target:"_blank",rel:"noopener noreferrer",children:"ModuleRequest 对象"}),"的数组，以 ",(0,d.jsx)(n.code,{children:"Local"})," 句柄的形式。"]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/src/module_wrap.cc#L270-L332",title:"https://github.com/nodejs/node/blob/v18.14.0/src/module_wrap.cc#L270-L332",target:"_blank",rel:"noopener noreferrer",children:"ModuleWrap.prototype.link()"})," 就是通过调用 ",(0,d.jsx)(n.code,{children:"GetModuleRequest()"})," 方法得到其依赖信息。",(0,d.jsx)(n.code,{children:".link()"})," 的参数是一个 ",(0,d.jsx)(n.code,{children:"async"})," 回调函数，它会在得到依赖信息后，逐一调用回调函数做一些事情，并等所有回调函数都被 ",(0,d.jsx)(n.code,{children:"resolve"})," 之后，整个 ",(0,d.jsx)(n.code,{children:".link()"})," 才算被 ",(0,d.jsx)(n.code,{children:"resolve"})," 了。Node.js 中，这段逻辑是用 C++ 写的，整个 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 都是用 C++ 写的。为了便于理解，我用不严谨的、简易的 JavaScript 伪代码说明一遍。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"ModuleWrap.prototype.link = async function link(callback) {\n  if (this._linked) return;\n  this._linked = true;\n  \n  const moduleRequests = GetModuleRequests();\n  const promises = moduleRequests.map(moduleRequest => {\n    const { specifier, ... } = moduleRequest;\n    return callback(specifier, ...);\n  });\n  return Promise.all(promises);\n};\n"})}),"\n",(0,d.jsxs)(n.p,{children:["现在再回过头去看之前的 ",(0,d.jsx)(n.code,{children:"this.module.link()"}),"，应该就更好理解了。"]}),"\n",(0,d.jsxs)(n.h5,{id:"完成初始化",children:["完成初始化",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#完成初始化",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["分析依赖并创建新的 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 是其初始化的逻辑，意在去重。每个 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 都有一个“已初始化（",(0,d.jsx)(n.code,{children:"instantiated"}),"）”的 ",(0,d.jsx)(n.code,{children:"Promise"})," 状态。"]}),"\n",(0,d.jsxs)(n.p,{children:["若是根模块，其初始化 ",(0,d.jsx)(n.code,{children:"Promise"})," 状态会在做完整个依赖分析、创建新的 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 并生成拍平的集合后被 ",(0,d.jsx)(n.code,{children:"resolve"}),"；剩下的在集合中的其他模块，由于不用单独解析其依赖树（在 ",(0,d.jsx)(n.code,{children:"link()"})," 中已经做过了），所以无需单独初始化，只要在根模块初始化完成后，它们也就自然“初始化完成”了。事实上，根模块的初始化过程的最后，会手动直接将集合中的所有 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 的初始化状态设为已完成。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"const resolvedPromise = Promise.resolve();\n\nModuleJob.prototype._instantiate = async function _instantiate() {\n  // 前面一坨“依赖树 → 需加载的模块集合”逻辑\n  ...\n\n  // 一些其他逻辑\n  ...\n  \n  for (const dependencyJob of jobsInGraph) {\n    // Calling `this.module.instantiate()` instantiates not only the\n    // ModuleWrap in this module, but all modules in the graph.\n    dependencyJob.instantiated = resolvedPromise;\n  }\n};\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"模块类型映射",children:["模块类型映射",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块类型映射",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["在 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 中，Node.js 会根据不同的文件类型，去执行不同的代码逻辑。还记得在 CommonJS 中，这一块的逻辑是通过在 ",(0,d.jsx)(n.code,{children:"Module._extensions"})," 对象的映射来的（可返回上一章，Ctrl+F，搜 ",(0,d.jsx)(n.code,{children:"_extensions"}),"）。而 ECMAScript modules 也类似，它有个 ",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/translators.js#L114-L125",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/translators.js#L114-L125",target:"_blank",rel:"noopener noreferrer",children:"translators 的 Map"}),"，里面分别存了："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"translators.set('module', ...);\ntranslators.set('commonjs', ...);\ntranslators.set('builtin', ...);\ntranslators.set('json', ...);\ntranslators.set('wasm', ...);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["根据目标模块类型不同，会走不同的逻辑，最终返回不同的 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 实例。这个判断同样是在 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 的初始化函数中触发的。在创建 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 的时候，是通过一个叫 ",(0,d.jsx)(n.code,{children:"moduleProvider"})," 的函数来做的。该",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#L452-L469",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#L452-L469",target:"_blank",rel:"noopener noreferrer",children:"函数内部"}),"会根据加载路径判断出其模块类型，然后从 ",(0,d.jsx)(n.code,{children:"translators"})," 中获取对应类型的逻辑供其使用。而 ",(0,d.jsx)(n.code,{children:"ModuleJob"})," 就是",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/module_job.js#L64",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/module_job.js#L64",target:"_blank",rel:"noopener noreferrer",children:"调用 moduleProvider"})," 来拿到 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 的 ",(0,d.jsx)(n.code,{children:"Promise"}),"。"]}),"\n",(0,d.jsxs)(n.p,{children:["这里我们简单介绍一下 ",(0,d.jsx)(n.code,{children:"module"})," 和 ",(0,d.jsx)(n.code,{children:"commonjs"})," 的模块在 ECMAScript modules 里面是如何加载的。"]}),"\n",(0,d.jsxs)(n.h4,{id:"module",children:["module",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#module",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"module"})," 的加载比较简单。拿着源码，尝试做一些 SourceMap 的逻辑之后，直接正儿八经实例化 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 就好了。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"const module = new ModuleWrap(url, undefined, source, 0, 0);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["创建完之后，设置两个 ",(0,d.jsx)(n.code,{children:"callback"})," 函数到一个 ",(0,d.jsx)(n.code,{children:"Map"})," 中与该 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 关联起来："]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["当 ",(0,d.jsx)(n.code,{children:"import.meta"})," 好了之后会触发的回调，由 V8 控制时机；"]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["当在模块里面执行动态导入 ",(0,d.jsx)(n.code,{children:"await import()"})," 时候会触发的回调。"]}),"\n",(0,d.jsx)(n.p,{children:"moduleWrap.callbackMap.set(module, {\ninitializeImportMeta: (meta, wrap) => this.importMetaInitialize(meta, { url }),\nimportModuleDynamically,\n});"}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["Node.js 会设置这两类回调的整体回调函数到 V8 的 ",(0,d.jsx)(n.code,{children:"Isolate"})," 对象中，V8 会在相应时机触发。而这两个整体回调中则又会通过 ",(0,d.jsx)(n.code,{children:"Map"})," 的关联信息调用到对应的真实回调中。",(0,d.jsx)(n.code,{children:"import.meta"})," 那个就不细讲了，这个 ",(0,d.jsx)(n.code,{children:"importModuleDynamically"})," 就是对于 ",(0,d.jsx)(n.code,{children:"esmLoader.import()"})," 的透传。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"async function importModuleDynamically(specifier, { url }, assertions) {\n  return asyncESM.esmLoader.import(specifier, url, assertions);\n}\n"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsxs)(n.h5,{children:["CommonJS 中的动态加载 ",(0,d.jsx)(n.code,{children:"await import()"})]}),"\n",(0,d.jsxs)(n.p,{children:["还记得在模块机制详解（上）中所提到的吗？CommonJS 无法通过 ",(0,d.jsx)(n.code,{children:"import"})," 语法加载 ESM 模块，但是可以通过 ",(0,d.jsx)(n.code,{children:"import()"})," 语法来加载。"]}),"\n",(0,d.jsxs)(n.p,{children:["在通过 ",(0,d.jsx)(n.code,{children:"ScriptCompiler"})," 编译函数的时候，也是可以通过往里面传入动态加载模块的回调函数来让 CommonJS 模块支持 ESM 模块的。类似这样："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"const script = new Script(wrapper, {\n  filename,\n  lineOffset: 0,\n  importModuleDynamically: async (specifier, _, importAssertions) => {\n    const loader = asyncESM.esmLoader;\n    return loader.import(specifier, normalizeReferrerURL(filename),\n                         importAssertions);\n  },\n});\n"})}),"\n",(0,d.jsxs)(n.p,{children:["此处的 ",(0,d.jsx)(n.code,{children:"importModuleDynamically"})," 就是传回调的字段，里面的 ",(0,d.jsx)(n.code,{children:"asyncESM.esmLoader.import()"})," 就是上面代码里面一样的函数。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["做完这些事后，直接返回 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 实例就好了。",(0,d.jsx)(n.strong,{children:"在"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"ModuleWrap"})})," ",(0,d.jsx)(n.strong,{children:"构造中，若是"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"module"})})," ",(0,d.jsx)(n.strong,{children:"模式，会通过"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"ScriptCompiler::CompileModule()"})})," ",(0,d.jsx)(n.strong,{children:"来编译得到一个"})," ",(0,d.jsx)(n.strong,{children:"V8"})," ",(0,d.jsx)(n.strong,{children:"的"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"Module"})})," ",(0,d.jsx)(n.strong,{children:"实例。"})]}),"\n",(0,d.jsxs)(n.h4,{id:"commonjs",children:["commonjs",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#commonjs",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["如果目标模块是个 CommonJS 模块（特定模式下的 ",(0,d.jsx)(n.code,{children:"*.js"})," 文件等），那事情就变得不一样了。首先我们先删减掉跟模块缓存相关的逻辑。"]}),"\n",(0,d.jsxs)(n.p,{children:["在 ",(0,d.jsx)(n.code,{children:"commonjs"})," 加载逻辑中，",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/translators.js#L193-L249",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/translators.js#L193-L249",target:"_blank",rel:"noopener noreferrer",children:"第一步"}),"是先通过文件名直接实例化一个 CommonJS 的 ",(0,d.jsx)(n.code,{children:"Module"})," 对象，并分析出目标模块的导出名是什么。我对 ",(0,d.jsx)(n.code,{children:"import"})," 真心不熟，看到 ",(0,d.jsx)(n.code,{children:"export default"}),"、",(0,d.jsx)(n.code,{children:"export xxx"})," 就头大。这里所谓的导出名（也许也根本不是这个术语）就是 ",(0,d.jsx)(n.code,{children:"export"})," 后面的那货，一般默认情况下 ESM 的默认导出名是 ",(0,d.jsx)(n.code,{children:"default"}),"。在这个分析中，用到的是 ",(0,d.jsx)(n.a,{href:"https://www.npmjs.com/package/cjs-module-lexer",title:"https://www.npmjs.com/package/cjs-module-lexer",target:"_blank",rel:"noopener noreferrer",children:"cjs-module-lexer"})," 包。这个“第一步”流程如下："]}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.p,{children:"图中我用红色来标记耗时操作，用紫色标记冗余操作。"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["若模块已加载，有缓存，那么流程图的第一步不用重新编译执行了，直接拿缓存即可。得到 ",(0,d.jsx)(n.code,{children:"Module"})," 实例后，再读一次目标模块代码，供后续解析，这一步是冗余代码，但 ",(0,d.jsx)(n.code,{children:"Module"})," 中并不存在模块源码，所以只能多读一次。接下去就是通过 cjs-module-lexer 进行语法分析，解析出 ",(0,d.jsx)(n.code,{children:"module.exports"})," 了哪些内容。如果直接 ",(0,d.jsx)(n.code,{children:"exports"})," 了另一个模块的内容，还得解析出 re-export 出了哪些模块。",(0,d.jsx)(n.strong,{children:"这是一个重 CPU 计算的过程，并且至少目前还是用"})," ",(0,d.jsx)(n.strong,{children:"JavaScript"})," ",(0,d.jsx)(n.strong,{children:"写的。"})]}),"\n",(0,d.jsxs)(n.p,{children:["然后若至少存在一个 re-export 的情况，还需要递归目标模块，以同样的方式解析出它及其子模块的 ",(0,d.jsx)(n.code,{children:"Module"})," 对象及 ",(0,d.jsx)(n.code,{children:"exports"})," 内容。唧唧复唧唧。不过递归过程中，一样是会存在一些缓存的逻辑的。"]}),"\n",(0,d.jsx)(n.p,{children:"最终，遍历完整棵依赖树之后，我们就得到了该 CommonJS 模块的导出名了。"}),"\n",(0,d.jsx)(n.p,{children:"这里就是 CommonJS 与 ECMAScript modules 的不同。原生 CommonJS 很随意，给我泡芙，给你注入。而 ECMAScript modules 则需要静态分析出它所有的导出内容，自然就需要涉及到模块树。哪怕是在 ECMAScript module 的模块加载中，也是存在解析模块树并拍平的逻辑。只不过 CommonJS 在这棵树遍历的过程中，多了一步静态分析。"}),"\n",(0,d.jsx)(n.p,{children:"这种 patch 式的兼容，是以性能为代价换取的。而且这种“兼容方式”也存在一定桎梏——毕竟 CommonJS 是无法被完全静态分析的。想想上面的这一整段逻辑，哪怕我们不知道 cjs-module-lexer 里面的具体逻辑，也能随意构造出一个它无法识别的场景。比如："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"// ./temp/foo.js\nmodule.exports = {\n  foo: 'bar',\n};\n\n// ./cjs.js\nmodule.exports = {};\n\nconst files = require('fs').readdirSync(__dirname + '/temp');\nfor (const filename of files) {\n  const name = './temp/' + filename;\n  module.exports = {\n    ...module.exports,\n    ...require(name),\n  };\n}\n\n// ./esm.mjs\nimport { foo } from './cjs.js';\n"})}),"\n",(0,d.jsxs)(n.p,{children:["上面三个代码文件中，你去执行 ",(0,d.jsx)(n.code,{children:"$ node esm.mjs"})," 就会挂掉。看吧，Node.js 在错误堆栈中认怂了。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"file:///esm.mjs:1\nimport { foo } from './cjs.js';\n         ^^^\nSyntaxError: Named export 'foo' not found. The requested module './cjs.js' is a CommonJS module, which may not support all module.exports as named exports.\nCommonJS modules can always be imported via the default export, for example using:\n\nimport pkg from './cjs.js';\nconst { foo } = pkg;\n\n    at ModuleJob._instantiate (node:internal/modules/esm/module_job:123:21)\n    at async ModuleJob.run (node:internal/modules/esm/module_job:189:5)\n    at async Promise.all (index 0)\n    at async ESMLoader.import (node:internal/modules/esm/loader:526:24)\n    at async loadESM (node:internal/process/esm_loader:91:5)\n    at async handleMainPromise (node:internal/modules/run_main:65:12)\n"})}),"\n",(0,d.jsxs)(n.p,{children:["它没法通过静态分析出 ",(0,d.jsx)(n.code,{children:"cjs.js"})," 中有导出 ",(0,d.jsx)(n.code,{children:"foo"})," 字段，毕竟它是动态扫目录搞到的。不过，它也给我们提供了个方案，使用 ",(0,d.jsx)(n.code,{children:"default"}),"。这个我没在流程图中展示出来，其实 ",(0,d.jsx)(n.code,{children:"exports"})," 名里面默认都存在一个 ",(0,d.jsx)(n.code,{children:"default"}),"，然后再是去静态分析。"]}),"\n",(0,d.jsxs)(n.p,{children:["在得到导出名后，Node.js 会尝试走 CommonJS 的 ",(0,d.jsx)(n.code,{children:"Module"})," 实例的加载模块操作，将其模块通过读取源码、编译、执行、注入等上一章说的步骤去拿到模块对应的 ",(0,d.jsx)(n.code,{children:"module.exports"}),"。若有缓存了另当别论。"]}),"\n",(0,d.jsxs)(n.p,{children:["构造出 ECMAScript modules 的 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 时，传入刚才解析出来的导出名，也传入为 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 赋值实际导出对象的回调函数。在 ",(0,d.jsx)(n.code,{children:"import"})," 时会识别该导出名，对应的内容会在后面那个回调函数中赋值给 ",(0,d.jsx)(n.code,{children:"ModuleWrap"}),"。",(0,d.jsx)(n.strong,{children:"这个情况下，"})," ",(0,d.jsx)(n.strong,{children:"Node.js"})," ",(0,d.jsx)(n.strong,{children:"调用的是"})," ",(0,d.jsx)(n.strong,{children:"V8"})," ",(0,d.jsx)(n.strong,{children:"的"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.a,{href:"https://v8.github.io/api/head/classv8_1_1Module.html#ae0e40dbfc536ec53aca1a0135d788a52",title:"https://v8.github.io/api/head/classv8_1_1Module.html#ae0e40dbfc536ec53aca1a0135d788a52",target:"_blank",rel:"noopener noreferrer",children:"Module::CreateSyntheticModule()"})})," ",(0,d.jsx)(n.strong,{children:"来得到 V8 的"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"Module"})})," ",(0,d.jsx)(n.strong,{children:"对象。里面所需要的信息刚好就是"})," ",(0,d.jsx)(n.strong,{children:(0,d.jsx)(n.code,{children:"exports"})})," ",(0,d.jsx)(n.strong,{children:"名，以及一个映射的函数。"})]}),"\n",(0,d.jsxs)(n.blockquote,{children:["\n",(0,d.jsx)(n.h5,{children:"JSON？"}),"\n",(0,d.jsxs)(n.p,{children:["JSON 我就不细讲了，大家可以根据 commonjs 的加载过程推导出来 JSON 是如何加载的。最终也是通过 ",(0,d.jsx)(n.code,{children:"Module::CreateSyntheticModule()"}),"，以及类似的逻辑。大家自己思考一下吧，若想求证，也可自行翻阅",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/translators.js#L266-L319",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/translators.js#L266-L319",target:"_blank",rel:"noopener noreferrer",children:"源码"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.h3,{id:"执行模块",children:["执行模块",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行模块",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["主模块是要执行的。在通过 ESMLoader 加载模块后，只是生成了 ",(0,d.jsx)(n.code,{children:"ModuleWrap"})," 对象，执行它才会出效果。在 Node.js 中，执行一个 ESM 是通过 ",(0,d.jsx)(n.code,{children:"ModuleWrap.prototype.evaluate()"})," 来完成的。它的第一个参数是 ",(0,d.jsx)(n.code,{children:"timeout"}),"，后面参数我们就不提了。主模块的执行 ",(0,d.jsx)(n.code,{children:"timeout"})," 是 ",(0,d.jsx)(n.code,{children:"-1"}),"，即死循环了也没不会有问题。这个参数的主要作用是在 ",(0,d.jsx)(n.code,{children:"vm.Module"})," 中来限制执行时间的。它的限时原理我们在事件循环的相关章节中有提——WatchDog 限时打骨折。"]}),"\n",(0,d.jsxs)(n.p,{children:["在 ",(0,d.jsx)(n.code,{children:"evaluate()"})," 中，主要有三种逻辑："]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["限时 WatchDog 相关逻辑，仅在 ",(0,d.jsx)(n.code,{children:"vm.Module"})," 中被使用；"]}),"\n",(0,d.jsxs)(n.li,{children:["通过 V8 的 ",(0,d.jsx)(n.code,{children:"Module::Evaluate()"})," 去执行模块得到结果；"]}),"\n",(0,d.jsxs)(n.li,{children:["若该模块的运行时上下文（",(0,d.jsx)(n.code,{children:"vm.Context"}),"）非主环境上下文，则手动触发微任务——",(0,d.jsx)(n.code,{children:"microtask_queue->PerformCheckpoint(isolate)"}),"。"]}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["其实如果没有 ",(0,d.jsx)(n.code,{children:"vm"})," 那茬子事，整个 ",(0,d.jsx)(n.code,{children:"evaluate()"})," 实际上就是透传调用 V8 的 ",(0,d.jsx)(n.code,{children:"Module::Evaluate()"})," 执行模块得到结果。"]}),"\n",(0,d.jsxs)(n.h2,{id:"ecmascript-modules-的寻径",children:["ECMAScript modules 的寻径",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ecmascript-modules-的寻径",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"篇幅又超长了啊，模块机制详解我已经从一章拆成上中下了，不能再拆了，不然得涨价了\uD83D\uDE44。明明是个自己不熟悉的东西，怎么还能写得跟裹脚布一样。反正寻径就是个规则，我这里就长话短说了，反正规则在 Node.js 文档里面有。"}),"\n",(0,d.jsxs)(n.p,{children:["寻径源码在 ",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#L789-L896",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/loader.js#L789-L896",target:"_blank",rel:"noopener noreferrer",children:"ESMLoader 中"}),"。我们知道，Node.js 现在是可以自定义寻径规则和自定义加载器，这样就可以支持类似 URL 的方式了。所有的自定义寻径都以参数形式加载，以 Hook 函数的形式存在 Node.js 中。在寻径第一步，先过一遍自定义寻径 Hook 链，然后再走默认寻径逻辑（同理，自定义加载器也是在加载过程中会先过一遍自定义加载 Hook 链）。"]}),"\n",(0,d.jsxs)(n.p,{children:["默认的寻径 Hook 叫 ",(0,d.jsx)(n.a,{href:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/resolve.js#L1063-L1190",title:"https://github.com/nodejs/node/blob/v18.14.0/lib/internal/modules/esm/resolve.js#L1063-L1190",target:"_blank",rel:"noopener noreferrer",children:"defaultResolve"}),"，其规则在 Node.js 文档中",(0,d.jsx)(n.a,{href:"https://nodejs.org/dist/latest-v18.x/docs/api/esm.html#resolver-algorithm",title:"https://nodejs.org/dist/latest-v18.x/docs/api/esm.html#resolver-algorithm",target:"_blank",rel:"noopener noreferrer",children:"一步步有列举"}),"。我就不详解啦。"]}),"\n",(0,d.jsxs)(n.h2,{id:"模块机制小结",children:["模块机制小结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块机制小结",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["Node.js 的模块分为两种：CommonJS 模块与 ECMAScript modules。前者是一个被封装得很好的 IIFE 伪装成 CommonJS 规范，通过 ",(0,d.jsx)(n.code,{children:"vm"})," 模块执行得到，后者则用的 V8 中的 ",(0,d.jsx)(n.code,{children:"Module"})," 概念。"]}),"\n",(0,d.jsxs)(n.p,{children:["除了它们自身的加载之外，CommonJS 与 ECMAScript modules 在 Node.js 中相爱相杀，相互兼容，你中有我、我中有你，甚至很多代码都没解耦，直接互调。CommonJS 模块通过在 V8 中的 ",(0,d.jsx)(n.code,{children:"ScriptCompiler"})," 中传入动态 ",(0,d.jsx)(n.code,{children:"import"})," 的 ",(0,d.jsx)(n.code,{children:"callback"})," 来达到支持 ",(0,d.jsx)(n.code,{children:"import()"})," 语法的目的；ECMAScript modules 则通过静态分析的方式，为 CommonJS 模块的命名导入提供兼容，这是以性能为代价换来的。"]}),"\n",(0,d.jsxs)(n.p,{children:["CommonJS 的内容比较随意，导出不管你是什么，加载是同步的（就连读代码用的都是 ",(0,d.jsx)(n.code,{children:"fs.readFileSync()"}),"）；而 ECMAScript modules 则更严谨，所有的导入导出都在语法层面限定死，可被静态分析，所以在 V8 加载它的时候就需要把整个模块树都分析出来，这样才能层层递进，每个导出项都能被定向列举，它的加载是异步的（读代码也是用的 ",(0,d.jsx)(n.code,{children:"fs/promises"})," 中的 ",(0,d.jsx)(n.code,{children:"readFile()"}),"）。"]}),"\n",(0,d.jsxs)(n.p,{children:["无论是哪种模块机制，",(0,d.jsx)(n.strong,{children:"其最本质都是闭包的体现"}),"。就是这两种模块机制，作为 Node.js 中代码的执行单位，聚合成 npm 包，才有了今日 Node.js 庞大的生态。"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(i,{...e})}):i(e)}let h=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["%E8%B6%A3%E5%AD%A6%20Node.js%2F5-%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9ACJS%20%E4%B8%8E%20ESM%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"作为对比的工具人：CommonJS",id:"作为对比的工具人commonjs",depth:2},{text:"Node.js 中的 ECMAScript modules：`ModuleWrap`",id:"nodejs-中的-ecmascript-modulesmodulewrap",depth:2},{text:"加载一个 ECMAScript module",id:"加载一个-ecmascript-module",depth:2},{text:"模块加载任务",id:"模块加载任务",depth:3},{text:"任务构造函数",id:"任务构造函数",depth:4},{text:"依赖树 → 需加载的模块集合",id:"依赖树--需加载的模块集合",depth:4},{text:"模块类型映射",id:"模块类型映射",depth:3},{text:"module",id:"module",depth:4},{text:"commonjs",id:"commonjs",depth:4},{text:"执行模块",id:"执行模块",depth:3},{text:"ECMAScript modules 的寻径",id:"ecmascript-modules-的寻径",depth:2},{text:"模块机制小结",id:"模块机制小结",depth:2}],title:"5-模块机制详解：CJS 与 ESM（下）",headingTitle:"5-模块机制详解：CJS 与 ESM（下）",frontmatter:{}}}}]);