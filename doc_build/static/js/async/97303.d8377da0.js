"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["97303"],{818483:function(n,r,e){e.r(r),e.d(r,{default:()=>t});var l=e(552676),c=e(740453);function i(n){let r=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",strong:"strong",h2:"h2",pre:"pre",code:"code",blockquote:"blockquote"},(0,c.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(r.h1,{id:"第18章接口二空接口与泛型类型中的万能牌",children:["第18章—接口二｜空接口与泛型，类型中的“万能牌”",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#第18章接口二空接口与泛型类型中的万能牌",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"\uFEFF从上一讲开始，开始了接口专题的学习，具体来说是Go语言中接口的定义和使用。本讲继续针对接口进行深入讲解，包含以下内容："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"空接口与泛型"}),"\n",(0,l.jsx)(r.li,{children:"类型断言"}),"\n"]}),"\n",(0,l.jsx)(r.p,{children:"什么是空接口，什么又是泛型呢？"}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)(r.strong,{children:"所谓泛型，可以简单地理解为数据类型中的“万能牌”，它能存放任何类型的数据。Go语言中的空接口正是为了实现泛型所采用的手段。"})}),"\n",(0,l.jsxs)(r.h2,{id:"泛型初体验",children:["泛型初体验",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#泛型初体验",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"什么时候该使用泛型呢？举个例子，如果我们想要封装一个函数，该函数的作用便是实现传入参数数据的原样输出，该如何做呢？"}),"\n",(0,l.jsx)(r.p,{children:"利用我们已经掌握的知识，写出的代码可能会是这样："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:'func main() {\r\n   dataOutput("Hello")\r\n}\r\n\r\nfunc dataOutput(data string) {\r\n   fmt.Println(data)\r\n}\n'})}),"\n",(0,l.jsx)(r.p,{children:"直接运行这段程序，控制台会输出："}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"Hello"}),"\n"]}),"\n",(0,l.jsx)(r.p,{children:"看似没有问题，但如果传入的参数不是string类型，而是数字型、布尔型呢？显然，程序是无法编译通过的，因为类型不匹配。"}),"\n",(0,l.jsx)(r.p,{children:"当然，我们也可以编写多个函数，来匹配不同的参数类型，比如："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:'func main() {\r\n   stringDataOutput("Hello")\r\n   intDataOutput(123)\r\n}\r\n\r\nfunc stringDataOutput(data string) {\r\n   fmt.Println(data)\r\n}\r\n\r\nfunc intDataOutput(data int) {\r\n   fmt.Println(data)\r\n}\n'})}),"\n",(0,l.jsx)(r.p,{children:"如此确实可以实现，但代码整体不够优雅。况且这还只是两种类型，要是更多，日后的代码维护成本就会直线飙升了。"}),"\n",(0,l.jsx)(r.p,{children:"细心的朋友会发现，尽管类型不同，但函数体内实际执行的逻辑都是相通的。那么，有没有一种办法使函数的参数不再受限呢？当然有，那就是使用泛型。"}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.strong,{children:"泛型是类型中的“万能牌”"}),"，使用泛型作为函数参数，实际上就相当于告诉调用者：“我能兼容任何类型的参数，尽管将数据传给我就是了。”泛型以超级宽广的胸怀接纳所有类型的数据。",(0,l.jsx)(r.strong,{children:"在Go语言中的泛型，则使用空接口来实现。"})," 而所谓的“空接口”，使用代码表示非常简单，就是："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:"interface{}\n"})}),"\n",(0,l.jsx)(r.p,{children:"和普通接口的定义格式不同，空接口内部无需填写任何方法。"}),"\n",(0,l.jsxs)(r.p,{children:[(0,l.jsx)(r.strong,{children:"空接口能接纳所有类型的数据，因此可以将任何类型的数据赋值给它的变量"}),"，请大家阅读下面这段代码："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:'var anyTypeValue interface{}\r\n\r\nfunc main() {\r\n   anyTypeValue = 123\r\n   anyTypeValue = true\r\n   anyTypeValue = "Hello"\r\n}\n'})}),"\n",(0,l.jsx)(r.p,{children:"这段代码完全合法，可以编译、运行。"}),"\n",(0,l.jsxs)(r.p,{children:["另一方面，",(0,l.jsx)(r.strong,{children:"在函数参数中使用空接口，可以使其能接受所有类型的数据传入。"})," 以本讲一开始的示例举例，若要编写一个函数，实现传入参数数据的原样输出，只需按如下编写代码即可："]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:'func main() {\r\n   dataOutput("Hello")\r\n   dataOutput(123)\r\n   dataOutput(true)\r\n}\r\n\r\nfunc dataOutput(data interface{}) {\r\n   fmt.Println(data)\r\n}\n'})}),"\n",(0,l.jsx)(r.p,{children:"程序运行结果为："}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"Hello"}),"\n",(0,l.jsx)(r.p,{children:"123"}),"\n",(0,l.jsx)(r.p,{children:"true"}),"\n"]}),"\n",(0,l.jsx)(r.p,{children:"如此编码，是不是比写一堆类似的函数要方便、简洁很多呢？还能节省开发和维护的时间。"}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)(r.code,{children:"\uD83D\uDCA1 提示： 猜一猜，如果在dataOutput()函数中输出data变量的类型，将会如何输出呢？各位朋友不妨亲自动手一试，获取数据类型的函数是reflect.TypeOf(i interface{})。注意到了吗？这个函数所需的参数类型也是空接口类型，即泛型。"})}),"\n",(0,l.jsxs)(r.h2,{id:"货车容量计算器",children:["货车容量计算器",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#货车容量计算器",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"品尝到空接口的“甜头”之后，我们来实战空接口的使用，进一步体会使用它带来的好处。"}),"\n",(0,l.jsx)(r.p,{children:"现在，我们计划进行一次搬家，正在预估需要多大容量的货车来存放全部家当。"}),"\n",(0,l.jsx)(r.p,{children:"为了讲解方便，本例将简化各种家具家电的体积计算方式。把它们简单粗暴地分为正方体、长方体和圆柱体三种体积形式，这三种形状的物品分别对应代码中的三种结构体类型。"}),"\n",(0,l.jsx)(r.p,{children:"此外，还需实现为这三种形状的物品编写体积计算的方法。如此一来，我们便可通过调用这个体积计算的方法，将其计算结果累加在一起，便可得知需要至少多大容量的货车了。"}),"\n",(0,l.jsx)(r.p,{children:"还记得如何定义一个结构体吧？以正方体为例，计算体积仅需要知道边长就可以了。所以我们定义一个名为cube的结构体，其中包含float64类型的length变量，表示边长，具体代码如下："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:"// 正方体\r\ntype cube struct {\r\n   // 边长\r\n   length float64\r\n}\n"})}),"\n",(0,l.jsx)(r.p,{children:"接着，定义一个方法，名为cubeVolume，表示计算正方体的体积。作用于*cube类型，返回float64类型值，具体代码为："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:"// 正方体的体积计算\r\nfunc (c *cube) cubeVolume() float64 {\r\n   return c.length * c.length * c.length\r\n}\n"})}),"\n",(0,l.jsx)(r.p,{children:"如上，关于正方体的结构体和体积计算方法已经全部实现完成。依葫芦画瓢，继续实现长方体和圆柱体对应的结构体和体积计算方法。以下是具体的代码片段："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:"// 长方体\r\ntype cuboid struct {\r\n   // 长\r\n   length float64\r\n   // 宽\r\n   width float64\r\n   // 高\r\n   height float64\r\n}\r\n\r\n// 长方体的体积计算\r\nfunc (c *cuboid) cuboidVolume() float64 {\r\n   return c.length * c.width * c.height\r\n}\r\n\r\n// 圆柱体\r\ntype cylinder struct {\r\n   // 直径\r\n   diameter float64\r\n   // 高度\r\n   height float64\r\n}\r\n\r\n// 圆柱体的体积计算\r\nfunc (c *cylinder) cylinderVolume() float64 {\r\n   return math.Pi * (c.diameter / 2) * (c.diameter / 2) * c.height\r\n}\n"})}),"\n",(0,l.jsx)(r.p,{children:"接下来是本讲的另一个重点知识。如果我们想用同样一个函数来计算所有类型物体的体积，那么“认清”家具的种类就是非常必要的一环。换言之，当传入这个函数的参数是正方体，则需要调用cubeVolume()函数进行计算；当传入这个函数的参数是长方体，则需要调用cuboidVolume()函数进行计算；当传入这个函数的参数是正方体，则需要调用cylinderVolume()函数进行计算。"}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)(r.strong,{children:"在Go语言中，用来判断某个数据是否属于某种类型的方法被称为“类型断言”。"})}),"\n",(0,l.jsx)(r.p,{children:"类型断言的使用格式为："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{children:"value, ok := x.(T)\n"})}),"\n",(0,l.jsx)(r.p,{children:"其中，x是指某个变量，T表示类型，value是将x变量转换为T类型之后的值，ok是布尔类型，表示x是否属于T类型。"}),"\n",(0,l.jsx)(r.p,{children:"看上去有些绕口，我们用实际的例子来做演示。"}),"\n",(0,l.jsx)(r.p,{children:"前面说过，我们要实现一个函数，传入空接口类型的参数以便接收不同类型形状的家具，然后在这个函数中计算体积并返回最终的计算值。我们先以正方体为例，具体代码如下："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:"// 计算某个物体的体积\r\nfunc calcSize(material interface{}) float64 {\r\n   cubeMaterial, cubeOk := material.(cube)\r\n   if cubeOk {\r\n      return cubeMaterial.cubeVolume()\r\n   } else {\r\n      return 0\r\n   }\r\n}\n"})}),"\n",(0,l.jsx)(r.p,{children:"请大家仔细阅读这段代码，函数体内首行便进行了类型断言。material是传入该函数的参数，material.(cube)表示要判断material变量是否属于cube（正方体）类型。这种判断最终将返回两个结果，一个是cubeOk，它时布尔类型的值，当该值为true时，表示material是cube类型，反之则不是。另一个是cubeMaterial，它是将material变量转换为cube类型之后的变量，以便后续用它参与运算。"}),"\n",(0,l.jsx)(r.p,{children:"理解了函数中的首行代码，后面的代码便很好理解了。当cubeOK为true，即material属于cube时，使用转换后的cubeMaterial变量执行cubeVolume()方法，最终返回正方体的体积。"}),"\n",(0,l.jsx)(r.p,{children:"接下来，请大家自行编码实现长方体和圆柱体的类型断言和体积计算。"}),"\n",(0,l.jsx)(r.p,{children:"最后，整个程序完整的代码如下："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-go",children:'package main\r\n\r\nimport (\r\n   "fmt"\r\n   "math"\r\n)\r\n\r\nfunc main() {\r\n   truckSize := 0.0\r\n   // 声明空接口类型变量materials，存放各种不同体积的家具\r\n   var materials []interface{}\r\n   materials = append(materials, cube{12.5})\r\n   materials = append(materials, cuboid{25, 13, 60})\r\n   materials = append(materials, cylinder{5, 25.3})\r\n   // 遍历materials切片，依次计算每个家具的体积，并相加求和\r\n   for _, singleMaterial := range materials {\r\n      truckSize += calcSize(singleMaterial)\r\n   }\r\n   fmt.Println(truckSize)\r\n}\r\n\r\n// 计算某个物体的体积\r\nfunc calcSize(material interface{}) float64 {\r\n   cubeMaterial, cubeOk := material.(cube)\r\n   cuboidMaterial, cuboidOk := material.(cuboid)\r\n   cylinderMaterial, cylinderOk := material.(cylinder)\r\n   if cubeOk {\r\n      return cubeMaterial.cubeVolume()\r\n   } else if cuboidOk {\r\n      return cuboidMaterial.cuboidVolume()\r\n   } else if cylinderOk {\r\n      return cylinderMaterial.cylinderVolume()\r\n   } else {\r\n      return 0\r\n   }\r\n}\r\n\r\n// 正方体\r\ntype cube struct {\r\n   // 边长\r\n   length float64\r\n}\r\n\r\n// 正方体的体积计算\r\nfunc (c *cube) cubeVolume() float64 {\r\n   return c.length * c.length * c.length\r\n}\r\n\r\n// 长方体\r\ntype cuboid struct {\r\n   // 长\r\n   length float64\r\n   // 宽\r\n   width float64\r\n   // 高\r\n   height float64\r\n}\r\n\r\n// 长方体的体积计算\r\nfunc (c *cuboid) cuboidVolume() float64 {\r\n   return c.length * c.width * c.height\r\n}\r\n\r\n// 圆柱体\r\ntype cylinder struct {\r\n   // 直径\r\n   diameter float64\r\n   // 高度\r\n   height float64\r\n}\r\n\r\n// 圆柱体的体积计算\r\nfunc (c *cylinder) cylinderVolume() float64 {\r\n   return math.Pi * (c.diameter / 2) * (c.diameter / 2) * c.height\r\n}\n'})}),"\n",(0,l.jsx)(r.p,{children:"程序运行的结果为："}),"\n",(0,l.jsxs)(r.blockquote,{children:["\n",(0,l.jsx)(r.p,{children:"21949.889338348887"}),"\n"]}),"\n",(0,l.jsx)(r.p,{children:"如此，我们便可有依据地选择货车了。"}),"\n",(0,l.jsxs)(r.p,{children:["你注意到了吗？在main()函数中，我",(0,l.jsx)(r.strong,{children:"将空接口类型作为切片中的元素"}),"放在了名为materials的切片中。这在实际开发中是非常巧妙的使用空接口的方式，它可以规避数据类型的不同，将不同类型的数据存放于同一个切片/数组中，对于组织大量具有不同类型的数据是非常有效的做法。"]}),"\n",(0,l.jsxs)(r.h2,{id:"总结",children:["总结",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,l.jsx)(r.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"空接口与泛型"}),"\n",(0,l.jsx)(r.li,{children:"类型断言"}),"\n"]}),"\n",(0,l.jsx)(r.p,{children:"本讲是接口系列专题的第二篇。在本讲中，我们首先了解到泛型到底是什么，以及Go语言中将使用空接口实现泛型。接着，我们使用了一个数据原样输出的例子演示了空接口的简单使用。"}),"\n",(0,l.jsx)(r.p,{children:"接着，以搬家选货车为示例，进一步强化了空接口的使用方法，并介绍了Go语言中的类型断言，使用分支的方式实现判断空接口中变量的类型。"}),"\n",(0,l.jsx)(r.p,{children:"在实际开发中，空接口和类型断言往往同时出现，配套使用。"}),"\n",(0,l.jsx)(r.p,{children:"好了，本讲就到这里。"}),"\n",(0,l.jsx)(r.p,{children:"➡️ 在下次课程中，我们会介绍Go语言中接口的更多使用技巧，具体内容是："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"接口使用的注意事项"}),"\n"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,c.ah)(),n.components);return r?(0,l.jsx)(r,{...n,children:(0,l.jsx)(i,{...n})}):i(n)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC18%E7%AB%A0%E2%80%94%E6%8E%A5%E5%8F%A3%E4%BA%8C%EF%BD%9C%E7%A9%BA%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%B3%9B%E5%9E%8B%EF%BC%8C%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E2%80%9C%E4%B8%87%E8%83%BD%E7%89%8C%E2%80%9D.md"]={toc:[{text:"泛型初体验",id:"泛型初体验",depth:2},{text:"货车容量计算器",id:"货车容量计算器",depth:2},{text:"总结",id:"总结",depth:2}],title:"第18章—接口二｜空接口与泛型，类型中的“万能牌”",headingTitle:"第18章—接口二｜空接口与泛型，类型中的“万能牌”",frontmatter:{}}}}]);