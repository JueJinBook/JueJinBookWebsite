"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["16874"],{694465:function(n,e,r){r.r(e),r.d(e,{default:()=>c});var s=r(552676),d=r(740453);function t(n){let e=Object.assign({h2:"h2",a:"a",p:"p",code:"code",ul:"ul",li:"li",strong:"strong",blockquote:"blockquote",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",ol:"ol",pre:"pre",h3:"h3",h4:"h4"},(0,d.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h2,{id:"前言",children:["前言",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["我们在",(0,s.jsx)(e.a,{href:"https://juejin.cn/book/7302990019642261567/section/7304830272770408498",target:"_blank",rel:"noopener noreferrer",children:"《基础篇：Electron 的原生能力》"})," 章节介绍了关于如何使用 ",(0,s.jsx)(e.code,{children:"C++"})," 来开发 Electron 应用程序的 Node\n扩展。其实除了 ",(0,s.jsx)(e.code,{children:"C++"})," 以外，我们还可以使用 ",(0,s.jsx)(e.code,{children:"Rust"})," 来开发 ",(0,s.jsx)(e.code,{children:"Node"})," 扩展。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"Rust"})," 和 ",(0,s.jsx)(e.code,{children:"C++"})," 虽然都可以用于开发 Node 的原生扩展，但它们有一些不同之处，其中 ",(0,s.jsx)(e.code,{children:"Rust"})," 相对于 ",(0,s.jsx)(e.code,{children:"C++"})," 有一些优势："]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"内存安全性"}),"：",(0,s.jsx)(e.code,{children:"Rust"})," 在语言级别提供了内存安全性，通过借用检查器（Borrow Checker）可以避免常见的内存安全问题，如空指针引用、内存泄漏等。这意味着在编写 ",(0,s.jsx)(e.code,{children:"Rust"})," 扩展时，更容易避免许多常见的安全漏洞。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"性能"}),"：",(0,s.jsx)(e.code,{children:"Rust"})," 以及其所提供的内存安全性和零成本抽象，可以带来出色的性能。它可以通过其强大的编译器优化产生高效的机器码，这在某些情况下可能比 ",(0,s.jsx)(e.code,{children:"C++"})," 更高效。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"生态系统"}),"：虽然 ",(0,s.jsx)(e.code,{children:"C++"})," 有着长期的历史和庞大的生态系统，但 ",(0,s.jsx)(e.code,{children:"Rust"})," 作为一门新兴语言，拥有逐渐壮大的社区和生态系统。它的包管理器 ",(0,s.jsx)(e.code,{children:"Cargo"})," 提供了便捷的依赖管理和构建工具。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["为了使用 ",(0,s.jsx)(e.code,{children:"Rust"})," 开发 ",(0,s.jsx)(e.code,{children:"Nodejs Addon"}),"，你需要使用到 ",(0,s.jsx)(e.a,{href:"https://napi.rs/cn",target:"_blank",rel:"noopener noreferrer",children:"NAPI-RS"})," 这个库。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"NAPI-RS 是一个用于 Node.js Addon API（N-API）的 Rust 绑定库。通过使用 NAPI-RS，开发者可以充分利用 Rust 强大的性能和安全性，并与 Node.js 生态系统无缝集成，为 Node.js 应用程序编写高性能、高质量的原生扩展。"}),"\n",(0,s.jsx)(e.p,{children:"N-API 是 Node.js 提供的一个稳定的原生 API，允许开发者用 C、C++ 或 Rust 等编程语言编写 Node.js 的原生插件，而不会受到 Node.js 版本变化的影响。NAPI-RS 充分利用了 Rust 的特性，并提供了一种在 Rust 中编写 Node.js 原生插件的简洁而强大的方式。"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"https://napi.rs/cn",target:"_blank",rel:"noopener noreferrer",children:"NAPI-RS"})," 目前支持（来自 ",(0,s.jsx)(e.a,{href:"https://napi.rs/cn",target:"_blank",rel:"noopener noreferrer",children:"NAPI-RS"})," 官网）："]}),"\n",(0,s.jsxs)(e.table,{children:["\n",(0,s.jsxs)(e.thead,{children:["\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.th,{}),"\n",(0,s.jsx)(e.th,{children:"node12"}),"\n",(0,s.jsx)(e.th,{children:"node14"}),"\n",(0,s.jsx)(e.th,{children:"node16"}),"\n",(0,s.jsx)(e.th,{children:"node18"}),"\n",(0,s.jsx)(e.th,{children:"node20"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.tbody,{children:["\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Windows x64"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Windows x86"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Windows arm64"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"macOS x64"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"macOS aarch64"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Linux x64 gnu"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Linux x64 musl"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Linux aarch64 gnu"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Linux aarch64 musl"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Linux arm gnueabihf"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Linux riscv64 gnu"}),"\n",(0,s.jsx)(e.td,{children:"N/A"}),"\n",(0,s.jsx)(e.td,{children:"N/A"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Linux aarch64 android"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"Linux armv7 android"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n",(0,s.jsxs)(e.tr,{children:["\n",(0,s.jsx)(e.td,{children:"FreeBSD x64"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n",(0,s.jsx)(e.td,{children:"✓"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["以上看到其平台支持是很完备的，你编写的功能甚至能移植到 Android 设备上，此外还支持编译到 ",(0,s.jsx)(e.code,{children:"WASM"})," ，在浏览器等环境中使用。"]}),"\n",(0,s.jsxs)(e.p,{children:["接下来，我们来一起了解一下如何通过 ",(0,s.jsx)(e.code,{children:"Rust"})," 来开发一个可以在 ",(0,s.jsx)(e.code,{children:"Electron"})," 中使用的 ",(0,s.jsx)(e.code,{children:"Nodejs"})," 原生扩展程序。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["相信大多数人都一样，对于 ",(0,s.jsx)(e.code,{children:"Rust"})," 并没有过多接触，但是请放心，本节不涉及 ",(0,s.jsx)(e.code,{children:"Rust"})," 的任何高级特性，我会确保你读懂这里的每一段代码。"]}),"\n",(0,s.jsxs)(e.p,{children:["本小节的实例代码都源自 Rubick 的 Rust 原生扩展：",(0,s.jsx)(e.a,{href:"https://github.com/rubickCenter/rubick-native",target:"_blank",rel:"noopener noreferrer",children:"Rubick-Native"})]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"工具链安装",children:["工具链安装",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#工具链安装",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["这里已经默认你安装了 ",(0,s.jsx)(e.code,{children:"Node.js"})," 和 ",(0,s.jsx)(e.code,{children:"Electron"})," 。"]}),"\n"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"首先我们要安装 Rustup，使用 Rustup 官方的安装器即可："}),"\n"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"rustup 是 rust 的版本管理器，类似于 nodejs 下的 nvm。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://www.rust-lang.org/zh-CN/tools/install",target:"_blank",rel:"noopener noreferrer",children:"安装 Rust - 点击跳转官网"})}),"\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsx)(e.li,{children:"安装 Rust。命令行输入以下命令即可："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"rustup install nightly\n"})}),"\n",(0,s.jsx)(e.p,{children:"自动下载安装后，命令行输入 cargo ，可以看到 Rust 开发工具链已经安装完毕。"}),"\n",(0,s.jsxs)(e.ol,{start:"3",children:["\n",(0,s.jsx)(e.li,{children:"安装 NAPI-RS："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pnpm add -g @napi-rs/cli\n# 第18章—通用篇：使用Rust开发Electron原生扩展\nnpm install -g @napi-rs/cli\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"制作一个原生拓展",children:["制作一个原生拓展",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#制作一个原生拓展",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"创建一个原生拓展",children:["创建一个原生拓展",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#创建一个原生拓展",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"命令行输入："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"napi new\n"})}),"\n",(0,s.jsx)(e.p,{children:"输入你的拓展名称，并选择需要支持的平台："}),"\n",(0,s.jsx)(e.p,{children:"完成导航后，NAPI-RS 会自动写入项目文件："}),"\n",(0,s.jsx)(e.p,{children:"我们查看目录后发现，实际上这就是一个 NPM 包："}),"\n",(0,s.jsxs)(e.p,{children:["唯一不同的是，",(0,s.jsx)(e.code,{children:"src"})," 目录下是 ",(0,s.jsx)(e.code,{children:".rs"})," 后辍的文件。"]}),"\n",(0,s.jsxs)(e.p,{children:["这里 ",(0,s.jsx)(e.code,{children:".rs"})," 后辍的文件，就是 rust 的源代码文件。"]}),"\n",(0,s.jsxs)(e.p,{children:["默认生成的代码我已为你简化了，这里所实现的是一个简单的加和功函数，用 ",(0,s.jsx)(e.code,{children:"#[napi]"})," 进行标记，以暴露给 JS 调用："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rs",children:"// 导入依赖\nuse napi_derive::napi;\n\n#[napi] // 标记该函数需要暴露给 JS 调用\npub fn sum(a: i32, b: i32) -> i32 {\n  return a + b;\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"在-javascript-世界中使用原生拓展",children:["在 JavaScript 世界中使用原生拓展",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#在-javascript-世界中使用原生拓展",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"以上我们已经在 Rust 世界里创建了一个“高效”的加和函数，那么如何在 JavaScript 世界中使用呢？"}),"\n",(0,s.jsx)(e.p,{children:"很简单，我们尝试运行编译命令："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"pnpm build\n"})}),"\n",(0,s.jsx)(e.p,{children:"我们发现项目目录下多了三个文件："}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:".node"})," 结尾的文件名会因平台架构和操作系统而异，这是原生拓展的",(0,s.jsx)(e.code,{children:"“本体”"}),"，一个二进制文件。"]}),"\n",(0,s.jsx)(e.p,{children:"我们在项目目录下运行 Nodejs ，并尝试直接引入该原生拓展："}),"\n",(0,s.jsx)(e.p,{children:"刚刚在 Rust 世界里创建的“高效”的加和函数，现在能在 JS 的世界里为我们所用了。"}),"\n",(0,s.jsxs)(e.p,{children:["该二进制文件无法逆向出代码，也就是说你可以将需要保护的代码例如用户认证、数据加密等逻辑“",(0,s.jsx)(e.strong,{children:"藏"}),"”在原生模块中。"]}),"\n",(0,s.jsx)(e.p,{children:"那另外两个文件呢？"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"index.js"}),"：提供跨平台兼容性，识别系统架构并加载正确的二进制原生拓展。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"index.d.ts"}),"：这个文件是 NAPI-RS 基于 Rust 代码生成的 TS 类型定义文件。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"export function sum(a: number, b: number): number\n"})}),"\n",(0,s.jsx)(e.p,{children:"这样你在使用原生拓展时，体验就和使用 TypeScirpt 库一样舒畅，相关类型会在编译时自动映射并生成："}),"\n",(0,s.jsx)(e.p,{children:"接下来，你就可以在任意 Node.js 项目或是 Electron 项目中以以上方式导入并使用该原生模块。"}),"\n",(0,s.jsxs)(e.h3,{id:"实战场",children:["实战场",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实战场",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["接下来，我们基于 ",(0,s.jsx)(e.a,{href:"https://github.com/rubickCenter/rubick-native",target:"_blank",rel:"noopener noreferrer",children:"Rubick-Native"})," 代码库进行实战操练，该代码库已发布于 NPM，你可以使用 ",(0,s.jsx)(e.code,{children:"pnpm add rubick-native"})," 下载并使用。"]}),"\n",(0,s.jsx)(e.p,{children:"我们以两个实用的功能为例："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"剪切板读取文件文本"}),"\n",(0,s.jsx)(e.li,{children:"键鼠监听"}),"\n"]}),"\n",(0,s.jsxs)(e.h4,{id:"1-为我们的原生拓展添加剪切板读取文件文本功能",children:["1. 为我们的原生拓展添加“剪切板读取文件文本”功能",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-为我们的原生拓展添加剪切板读取文件文本功能",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Rust 生态中有以下两个涉及剪切板读取的包，且都是跨平台的："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/betamos/clipboard-files",target:"_blank",rel:"noopener noreferrer",children:"clipboard-files"})," 读取剪切板文件"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://github.com/alacritty/copypasta",target:"_blank",rel:"noopener noreferrer",children:"copypasta"})," 读写剪切板文本"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["我们要做的，就是把以上两个包的功能整合，封装成统一的函数 ",(0,s.jsx)(e.code,{children:"getClipboardContent()"})," ，并暴露在 JS 环境中，以下是我们预想的该函数的出参描述。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"出参 eg"}),"："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// type: file\n{\n  type: 'file',\n  content: [\n    'C:/Download/test.txt',\n    'C:/Download/mywork',\n  ]\n}\n// type: text\n{\n  type: 'text',\n  content: 'hello world'\n}\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"type: 'file' | 'text'"}),"\n",(0,s.jsx)(e.li,{children:"content: Array | string"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["我们希望在 Rust 端能判断剪切版中的数据类型，如果是文件则输出 ",(0,s.jsx)(e.code,{children:"type"})," 为 ",(0,s.jsx)(e.code,{children:"file"}),"，",(0,s.jsx)(e.code,{children:"content"})," 为文件路径列表，文本则输出 ",(0,s.jsx)(e.code,{children:"type"})," 为 ",(0,s.jsx)(e.code,{children:"text"}),"，",(0,s.jsx)(e.code,{children:"content"})," 为剪切板文本内容。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"第一步"}),"，我们根据以上涉及定义数据对象类型，在 Rust 中被称为 “结构体”："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rs",children:"#[napi(object)] // 标记此类型为需要与 JS “互动”的对象\npub struct ClipBoardContentJson { // 定义公开的，名称1为 ClipBoardContentJson 的结构体\n  #[napi(ts_type = \"'file' | 'text'\")] // 这里指定编译出的 TS 类型文件中 type 的类型为 'file' | 'text'\n  pub r#type: String, // 由于 type 是关键字，前面加上 r# 标记为字段\n  pub content: Vec<String>, // Vec<String> 会转换为 JS 中的 string[]\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"第二步"}),"，我们在 Rust 中实现该函数："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rs",children:'// 获取剪切板文件或者文本\n#[napi]\n// Option<ClipBoardContentJson> 的意思是 get_clipboard_content 输出 ClipBoardContentJson 类型的数据或是空值（毕竟有的时候剪切板是空的）\npub fn get_clipboard_content() -> Option<ClipBoardContentJson> { \n  // 读取剪切板文件\n  let files = clipboard_files::read();\n  // 创建剪切板对象\n  let mut ctx = ClipboardContext::new().unwrap();\n  // Rust 中的匹配语句，可以简单理解为 JS 中的 switch 语句\n  match files {\n    // 文件读取成功了，就返回文件类型的结果给 JS 端\n    Ok(f) => Some(ClipBoardContentJson {\n      r#type: "file".to_string(),\n      // 这里是将 f 转换为 string[] 类型，实际编码中，代码分析器会提示你怎么写\n      content: f\n        .into_iter()\n        .map(|c| c.to_str().unwrap().to_string())\n        .collect::<Vec<String>>(),\n    }),\n    // 文件读取失败了，说明剪切板中是文本或是空值\n    Err(_) => {\n      // 读取剪切板中的内容\n      let content = ctx.get_contents();\n      match content {\n        // 如果是文本，那么返回结果\n        Ok(text) => Some(ClipBoardContentJson {\n          r#type: "text".to_string(),\n          content: vec![text],\n        }),\n        // 如果不是文本，返回空值\n        Err(_) => None,\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"最终完全的代码如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rs",children:'// 导入上面提到的两个依赖\nuse clipboard_files;\nuse copypasta::{ClipboardContext, ClipboardProvider};\n\n#[napi(object)]\npub struct ClipBoardContentJson {\n  #[napi(ts_type = "\'file\' | \'text\'")]\n  pub r#type: String,\n  pub content: Vec<String>,\n}\n\n#[napi]\npub fn get_clipboard_content() -> Option<ClipBoardContentJson> {\n  let files = clipboard_files::read();\n  let mut ctx = ClipboardContext::new().unwrap();\n  match files {\n    Ok(f) => Some(ClipBoardContentJson {\n      r#type: "file".to_string(),\n      content: f\n        .into_iter()\n        .map(|c| c.to_str().unwrap().to_string())\n        .collect::<Vec<String>>(),\n    }),\n    Err(_) => {\n      let content = ctx.get_contents();\n      match content {\n        Ok(text) => Some(ClipBoardContentJson {\n          r#type: "text".to_string(),\n          content: vec![text],\n        }),\n        Err(_) => None,\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"接下来，编译后，就可以在 JS 中使用该函数："}),"\n",(0,s.jsxs)(e.h4,{id:"2-为我们的原生拓展添加键鼠监听功能",children:["2. 为我们的原生拓展添加“键鼠监听”功能",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-为我们的原生拓展添加键鼠监听功能",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["键鼠监听，就是在 JS 中能够获取到鼠标或是键盘的“事件通知”，我们知道 Nodejs 的事件驱动模型中，事件是通过“回调函数”进行处理的，所以如果我们有一个键盘对象 ",(0,s.jsx)(e.code,{children:"keyboard"}),"，那么我们预想中监听键盘输入事件的代码应该是这样："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"keyboard.onevent(event => {\n    // 对键盘输入事件进行处理\n})\n"})}),"\n",(0,s.jsx)(e.p,{children:"其中，以下部分就是键盘被敲击时，在 Rust 端需要被调用的“回调函数”："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"event => {\n    // 对键盘输入事件进行处理\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"那么，我们如何在 Rust 世界中主动调用 JS 世界中的“函数”呢？"}),"\n",(0,s.jsxs)(e.p,{children:["实现代码如下，完整代码见 ",(0,s.jsx)(e.a,{href:"https://github.com/rubickCenter/rubick-native/blob/main/src/monitor/mod.rs#L12",target:"_blank",rel:"noopener noreferrer",children:"rubick-native/src/monitor/mod.rs"}),"，我们使用 NAPI-RS 对 ",(0,s.jsx)(e.a,{href:"https://github.com/Narsil/rdev",target:"_blank",rel:"noopener noreferrer",children:"rdev"})," 库进行了包装，便使 Node.js 获得了键鼠事件监听的功能。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rs",children:'#[napi(ts_args_type = "callback: (event: string) => void")] // 自定义回调函数类型\npub fn on_input_event(callback: JsFunction) -> Result<()> {\n  // 将 JS 传入的函数转换为 Rust 中的函数\n  let jsfn: ThreadsafeFunction<String, ErrorStrategy::Fatal> =\n    callback.create_threadsafe_function(0, |ctx| Ok(vec![ctx.value]))?;\n\n  // 在另一个线程中运行键鼠事件监听\n  spawn(|| {\n    if let Err(error) = listen(move |event| {\n      // 将事件序列化为 JSON，并作为参数传递给 JS 中的回调函数\n      jsfn.call(\n        serde_json::to_string(&event).unwrap(),\n        ThreadsafeFunctionCallMode::NonBlocking,\n      );\n    }) {\n      // 如果有错误打印在控制台\n      println!("Error: {:?}", error)\n    }\n  });\n  Ok(())\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["其中，我们用到了 Rust 中 ",(0,s.jsx)(e.a,{href:"https://github.com/Narsil/rdev",target:"_blank",rel:"noopener noreferrer",children:"rdev"})," 库，该库可以在 Windows、Macos、Linux 下对键鼠事件进行监听。"]}),"\n",(0,s.jsx)(e.p,{children:"之后，在 JS 中，我们可以这样对该函数进行调用："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"onInputEvent((event => {\n    // 处理键鼠输入事件\n}))\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"本小节我们介绍了如何开发原生拓展来打破 Node.js/Electron 世界的“次元壁”，让你的应用获得以下能力："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"操作系统底层指令"}),"\n",(0,s.jsx)(e.li,{children:"用极致性能解决计算密集型任务"}),"\n",(0,s.jsx)(e.li,{children:"保护关键代码的知识产权"}),"\n",(0,s.jsx)(e.li,{children:"功能高可移植性"}),"\n"]})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(t,{...n})}):t(n)}let c=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Electron%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F%E7%AC%AC18%E7%AB%A0%E2%80%94%E9%80%9A%E7%94%A8%E7%AF%87%EF%BC%9A%E4%BD%BF%E7%94%A8Rust%E5%BC%80%E5%8F%91Electron%E5%8E%9F%E7%94%9F%E6%89%A9%E5%B1%95.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"工具链安装",id:"工具链安装",depth:2},{text:"制作一个原生拓展",id:"制作一个原生拓展",depth:2},{text:"创建一个原生拓展",id:"创建一个原生拓展",depth:3},{text:"在 JavaScript 世界中使用原生拓展",id:"在-javascript-世界中使用原生拓展",depth:3},{text:"实战场",id:"实战场",depth:3},{text:"1. 为我们的原生拓展添加“剪切板读取文件文本”功能",id:"1-为我们的原生拓展添加剪切板读取文件文本功能",depth:4},{text:"2. 为我们的原生拓展添加“键鼠监听”功能",id:"2-为我们的原生拓展添加键鼠监听功能",depth:4},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);