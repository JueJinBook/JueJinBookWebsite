"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11430"],{852815:function(n,e,r){r.r(e),r.d(e,{default:()=>x});var d=r(552676),s=r(740453);let c=r.p+"static/image/a6c8688db3364d3db3b15b5e583cf629~tplv-k3u1fbpfcp-zoom-1.image.eb2096c5.png",h=r.p+"static/image/247d321f34a84826b2b36531b7e8879c~tplv-k3u1fbpfcp-zoom-1.image.4e98a350.png",i=r.p+"static/image/ef5aa7d1109b458db46605162ba52797~tplv-k3u1fbpfcp-zoom-1.image.3cc49dcf.png";function l(n){let e=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",h2:"h2",h3:"h3",strong:"strong",img:"img",pre:"pre",code:"code",em:"em"},(0,s.ah)(),n.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.h1,{id:"4-思考函数为何非纯不可",children:["4 思考：函数为何非“纯”不可？",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-思考函数为何非纯不可",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"函数为何非“纯”不可？这我们就要从函数式编程的数学背景说起了。"}),"\n",(0,d.jsx)(e.p,{children:"若我们试着对“函数式编程”思想追根溯源，会发现它最早正是从数学理论中推导出来的。"}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsxs)(e.p,{children:["其中一个最关键的理论叫做“范畴论”，它也是本册的一个重点，我把它放在 ",(0,d.jsx)(e.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422979646423098",target:"_blank",rel:"noopener noreferrer",children:"第17节"})," - ",(0,d.jsx)(e.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175421412075634725",target:"_blank",rel:"noopener noreferrer",children:"21"})," 节进行讲解。"]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"数学家的工作和计算机工程师的工作其实是很相似的。数学家们同样需要处理大量的抽象、以及抽象与抽象之间的关系。"}),"\n",(0,d.jsx)(e.p,{children:"而数学和计算机科学的发展，总是相互影响、相互成就的。"}),"\n",(0,d.jsx)(e.p,{children:"在漫长的相互影响的过程中，它们之间重叠出了许多有趣的交集，其中一个关键的交集，就是“函数”。"}),"\n",(0,d.jsxs)(e.h2,{id:"非纯不可的数学背景",children:["非“纯“不可的数学背景",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#非纯不可的数学背景",children:"#"})]}),"\n",(0,d.jsxs)(e.h3,{id:"数学世界的函数-vs-程序世界的函数",children:["数学世界的函数 VS 程序世界的函数",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数学世界的函数-vs-程序世界的函数",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"众所周知，数学中的函数，和计算机语言中的函数之间，并不能简单地画上等号。"}),"\n",(0,d.jsxs)(e.p,{children:["数学中的函数总是遵循着这样的原则：",(0,d.jsx)(e.strong,{children:"同一个输入，同一个输出。"})]}),"\n",(0,d.jsx)(e.p,{children:"不管是长这样的函数："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:i,alt:""})}),"\n",(0,d.jsx)(e.p,{children:"还是长这样的函数："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:h,alt:""})}),"\n",(0,d.jsx)(e.p,{children:"抑或是长这样的函数："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:c,alt:""})}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"对于一个给定的自变量 x，总是会有且仅有一个因变量 y 与它对应。"})}),"\n",(0,d.jsx)(e.p,{children:"而计算机科学中的函数，相比之下要灵活的多。"}),"\n",(0,d.jsx)(e.p,{children:"以 JS 为例，如下的函数在 JS 看来是极度正常的："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"let a = 1  \n\nfunction add(x) {\n  return a + x\n}    \n\n// 输出 3\nadd(2)   \n\na = 10\n\n// 输出 12\nadd(2)\n"})}),"\n",(0,d.jsxs)(e.p,{children:["对于 add 函数来说，给定一个指定的自变量 ",(0,d.jsx)(e.code,{children:"x = 1"}),"，JS 并不能给你保证 ",(0,d.jsx)(e.code,{children:"add(x)"})," 每次的输出都是一致的。"]}),"\n",(0,d.jsx)(e.p,{children:"再看一个获取当天日期的函数："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"function getToday() {\n  return (new Date()).getDate()\n}\n"})}),"\n",(0,d.jsxs)(e.p,{children:["今天是 22 号，我调用 ",(0,d.jsx)(e.code,{children:"getToday()"}),"，它自然会返回 22 给我。"]}),"\n",(0,d.jsxs)(e.p,{children:["如果我明天、后天、大后天再来分别调用一次 ",(0,d.jsx)(e.code,{children:"getToday()"}),"，尽管输入都是 ",(0,d.jsx)(e.code,{children:"void"}),"，但输出却分别是 23、24、25。"]}),"\n",(0,d.jsxs)(e.p,{children:["如果人在洛杉矶、刚下飞机的同事赵二狗在他的电脑上运行了这个函数，那么由于时区不同，即便我们都在同一个时刻执行 ",(0,d.jsx)(e.code,{children:"getToday()"}),"，两台电脑的输出也是截然不同的。"]}),"\n",(0,d.jsx)(e.p,{children:"由此我们可以看出，能够影响 JS 函数输出的因素太多了，函数入参只是众多因素中的一个。"}),"\n",(0,d.jsx)(e.p,{children:"执行上下文中某个外部变量的变化、函数执行宿主的变化、系统时区的变化......甚至空气中温度、湿度的变化（JS 是可以调用传感器 API 的），都会影响 JS 函数的输出。"}),"\n",(0,d.jsx)(e.p,{children:"程序相对于数学来说，是个实实在在的“花花世界”。"}),"\n",(0,d.jsx)(e.p,{children:"JS 允许函数读写外部变量，允许函数引入副作用。这强化了程序的能力，却弱化了程序的数学性。"}),"\n",(0,d.jsxs)(e.h3,{id:"数学化的-js-函数--纯函数",children:["数学化的 JS 函数 === 纯函数",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数学化的-js-函数--纯函数",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["既然函数式编程起源于数学，那要想实践函数式编程，咱的函数自然得先能表现出一种“",(0,d.jsx)(e.strong,{children:"类似数学"}),"”的行为。"]}),"\n",(0,d.jsx)(e.p,{children:"“类似数学”的函数行为是什么样的？就如我们上文所说的，对于一个给定的的输入，它总是给到你相同的输出。"}),"\n",(0,d.jsxs)(e.p,{children:["说白了，就是",(0,d.jsx)(e.strong,{children:"函数除了纯纯的计算，啥也不干"}),"。"]}),"\n",(0,d.jsx)(e.p,{children:"而这，恰恰就是我们对纯函数的预期。"}),"\n",(0,d.jsx)(e.p,{children:"“纯函数”本质上是一套规则，是一种约束。"}),"\n",(0,d.jsx)(e.p,{children:"这层约束存在的背景，就是为了让 JS 函数和数学函数的行为对齐。"}),"\n",(0,d.jsx)(e.p,{children:"在这个基础上，JS 语言就可以站在“巨人”的肩膀上，充分汲取数学世界的养分了。"}),"\n",(0,d.jsxs)(e.h2,{id:"非纯不可的现实意义",children:["非“纯”不可的现实意义",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#非纯不可的现实意义",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"如果你打开搜索引擎，检索“纯函数的好处/优势”，然后将所能够检索到结果一一罗列，你会发现这东西的好处似乎有巨大的一箩筐，仿佛它能解决所有的问题——难道纯函数就是传说中的“银弹”吗？"}),"\n",(0,d.jsx)(e.p,{children:"答案当然是否定的。"}),"\n",(0,d.jsx)(e.p,{children:"社区对纯函数优势的见解存在多样性，更多是因为人们看待它的视角不同。"}),"\n",(0,d.jsx)(e.p,{children:"从不同的视角出发，我们确实会发现纯函数能够解决不少具体的小问题。"}),"\n",(0,d.jsxs)(e.p,{children:["而它之所以能够解决这些小问题，归根结底还是因为它解决了两个大问题，那就是“",(0,d.jsx)(e.strong,{children:"不确定性"}),"”和“",(0,d.jsx)(e.strong,{children:"副作用"}),"”。"]}),"\n",(0,d.jsxs)(e.h3,{id:"纯函数高度确定的函数",children:["纯函数，高度确定的函数",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#纯函数高度确定的函数",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"不纯的函数（Impure function）最直接的问题，就是不确定性——Impure function 的行为是难以预测的；对于同样的输入，Impure function 不能够保证同样的输出。"}),"\n",(0,d.jsx)(e.p,{children:"以测试过程为例：单元测试的主要判断的依据就是函数的输入和输出。如果对于同样的输入，函数不能够给到确定的输出，测试的难度将会陡然上升。"}),"\n",(0,d.jsx)(e.p,{children:"不确定性也会导致我们的代码难以被调试、数据变化难以被追溯、计算结果难以被复用等等。"}),"\n",(0,d.jsx)(e.p,{children:"总而言之一句话：不确定性意味着风险，而风险是万恶之源。"}),"\n",(0,d.jsxs)(e.h3,{id:"纯函数没有副作用的函数",children:["纯函数，没有副作用的函数",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#纯函数没有副作用的函数",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"消除副作用，足以解决函数中大多数的不确定性。"}),"\n",(0,d.jsx)(e.p,{children:"此外，副作用的消除还解决了并行计算带来的竞争问题。"}),"\n",(0,d.jsx)(e.p,{children:"因为不纯的函数有可能访问同一块资源，进而相互影响，引发意想不到的混乱结果。"}),"\n",(0,d.jsx)(e.p,{children:"试想这样一种场景，A函数和B函数都需要向某个文件写入信息，一旦我们先后调用了A、B两个函数，就将触发两个并行的写入过程，进入混乱的竞争态。"}),"\n",(0,d.jsx)(e.p,{children:"而纯函数则不存在这种问题，纯函数的计算完全发生在函数的内部，它不会对外部资源产生任何影响，因此纯函数的并行计算总是安全的。"}),"\n",(0,d.jsxs)(e.h3,{id:"纯函数更加灵活的函数",children:["纯函数，更加灵活的函数",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#纯函数更加灵活的函数",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["无论是引入了外部变量的 ",(0,d.jsx)(e.code,{children:"add()"}),"函数，还是依赖了 JS 内置对象的 ",(0,d.jsx)(e.code,{children:"getToday()"})," 函数，它们的执行都严重地依赖了函数的运行环境。"]}),"\n",(0,d.jsxs)(e.p,{children:["更确切地说，这些函数是被",(0,d.jsx)(e.strong,{children:"困在了特定的上下文"}),"里。"]}),"\n",(0,d.jsxs)(e.p,{children:["假如我们将 ",(0,d.jsx)(e.code,{children:"add()"})," 函数导出到一个没有 ",(0,d.jsx)(e.code,{children:"a"})," 变量，或者 ",(0,d.jsx)(e.code,{children:"a"})," 变量类型不为数字的上下文里，那么这个函数将当场失控。"]}),"\n",(0,d.jsxs)(e.p,{children:["同理，假如我想调用 ",(0,d.jsx)(e.code,{children:"getToday()"}),"函数，那我必须先确认当前上下文里的 ",(0,d.jsx)(e.code,{children:"Date"})," 类没有被篡改过。"]}),"\n",(0,d.jsx)(e.p,{children:"（当然啦，正常的业务开发里，侵入式地篡改 JS 内置 Class 是非常罕见、也极不推荐大家做的事情）。"}),"\n",(0,d.jsx)(e.p,{children:"这里我想要强调的是，这些不纯的函数是不灵活的。"}),"\n",(0,d.jsx)(e.p,{children:"它们只能在某一个特定的上下文里运行，一旦脱离了这个上下文，就会失去预期中的效用。"}),"\n",(0,d.jsx)(e.p,{children:"纯函数则完全不存在这个弊端，因为它太简单了，它除了入参谁也不认，除了计算啥也不干。"}),"\n",(0,d.jsxs)(e.p,{children:["因此，",(0,d.jsx)(e.strong,{children:"纯函数是高度灵活的函数，它的计算逻辑在任何上下文里都是成立的。"})]}),"\n",(0,d.jsxs)(e.h3,{id:"纯函数可以改善代码质量",children:["纯函数可以改善代码质量",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#纯函数可以改善代码质量",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"从研发效率上来看，纯函数的实践，实际上是将程序的“外部影响”和“内部计算”解耦了。"}),"\n",(0,d.jsx)(e.p,{children:"这间接地促成了程序逻辑的分层，将会使得模块的功能更加内聚。"}),"\n",(0,d.jsx)(e.p,{children:"作为程序员，我们在开发的过程中，不再需要去关注函数可能会造成的外部影响，只需要关注函数本身的运算逻辑。"}),"\n",(0,d.jsxs)(e.p,{children:["这和我们之前在《设计模式》中提及的“单一职责”原则有异曲同工之妙——设计模式中，我们强调将“",(0,d.jsx)(e.strong,{children:"变与不变"}),"”分离，而纯函数强调将",(0,d.jsx)(e.strong,{children:"计算与副作用"}),"分离。"]}),"\n",(0,d.jsx)(e.p,{children:"计算是确定性的行为，而副作用则充满了不确定性。这一实践，本质上也是在贯彻“变与不变分离”的设计原则。"}),"\n",(0,d.jsx)(e.p,{children:"这样的逻辑分层将会使得我们的程序更加健壮和灵活，也会促成更加专注、高效的协作。"}),"\n",(0,d.jsxs)(e.h2,{id:"副作用不是毒药",children:["副作用不是毒药",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#副作用不是毒药",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"对于纯函数来说，副作用无疑是地雷、是毒药。"}),"\n",(0,d.jsx)(e.p,{children:"但对于一个完整的程序来说，副作用却至关重要。"}),"\n",(0,d.jsx)(e.p,{children:"函数生产的是数据，这些数据要想作用于外部世界、创造一些真正的改变，就必须借助副作用。"}),"\n",(0,d.jsx)(e.p,{children:"试想，公司为什么要花钱雇程序员？"}),"\n",(0,d.jsx)(e.p,{children:"因为要做网页，这需要程序员操作DOM；因为要 CRUD，这需要程序员操作DB；因为要读写文件，这需要程序员执行 IO…… 如果我们试图把一个业务程序员的简历用一句话概括，那无外乎“精通实现各种副作用”。"}),"\n",(0,d.jsx)(e.p,{children:"老板和客户不会关心你的代码是否优雅，只会关心那些肉眼可见的副作用——页面渲染、网络请求、数据读写等等是否符合预期。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)(e.strong,{children:"会关注代码本身的，有且仅有我们程序员自己。"})}),"\n",(0,d.jsx)(e.p,{children:"对于我们程序员来说，实践纯函数的目的并不是消灭副作用，而是将计算逻辑与副作用做合理的分层解耦，从而提升我们的编码质量和执行效率。"}),"\n",(0,d.jsxs)(e.h2,{id:"总结",children:["总结",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"纯函数是函数式编程的一个最大的前提，也是这坨知识体系的根基。"}),"\n",(0,d.jsx)(e.p,{children:"学习至此，你已经明白了纯函数机制的内涵，也理解了这套机制存在的要义——纯函数的这些规则并不是为了约束而约束，而是为了追求更高的确定性；同时引导我们做更加合理的逻辑分层，写出更加清晰、更善于应对变化的代码。"}),"\n",(0,d.jsx)(e.p,{children:"小册开篇我们讲过，认识函数式编程，需要从特征入手。"}),"\n",(0,d.jsx)(e.p,{children:"函数式编程的三大特征，我们到现在认识了第一个，这一个也是最重要、最容易劝退新手的一个。征服了这座小山包之后，相信足以建立起你对函数式编程的学习自信。"}),"\n",(0,d.jsxs)(e.blockquote,{children:["\n",(0,d.jsxs)(e.p,{children:["作者注：如果你读到这里，惊觉自己还不知道”三大特征“是啥，想必你是跳过了本册的导读部分啦！请狠狠地",(0,d.jsx)(e.a,{href:"https://juejin.cn/book/7173591403639865377/section/7173990352116776992",target:"_blank",rel:"noopener noreferrer",children:"戳这里"}),"补齐上下文吧！(",(0,d.jsx)(e.em,{children:"^▽^"}),")"]}),"\n"]}),"\n",(0,d.jsx)(e.p,{children:"下一节我们仍将延续对特征的分析，解读“函数是一等公民”这一特征的内涵。"}),"\n",(0,d.jsx)(e.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function j(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(l,{...n})}):l(n)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F4%20%E6%80%9D%E8%80%83%EF%BC%9A%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BD%95%E9%9D%9E%E2%80%9C%E7%BA%AF%E2%80%9D%E4%B8%8D%E5%8F%AF%EF%BC%9F.md"]={toc:[{text:"非“纯“不可的数学背景",id:"非纯不可的数学背景",depth:2},{text:"数学世界的函数 VS 程序世界的函数",id:"数学世界的函数-vs-程序世界的函数",depth:3},{text:"数学化的 JS 函数 === 纯函数",id:"数学化的-js-函数--纯函数",depth:3},{text:"非“纯”不可的现实意义",id:"非纯不可的现实意义",depth:2},{text:"纯函数，高度确定的函数",id:"纯函数高度确定的函数",depth:3},{text:"纯函数，没有副作用的函数",id:"纯函数没有副作用的函数",depth:3},{text:"纯函数，更加灵活的函数",id:"纯函数更加灵活的函数",depth:3},{text:"纯函数可以改善代码质量",id:"纯函数可以改善代码质量",depth:3},{text:"副作用不是毒药",id:"副作用不是毒药",depth:2},{text:"总结",id:"总结",depth:2}],title:"4 思考：函数为何非“纯”不可？",headingTitle:"4 思考：函数为何非“纯”不可？",frontmatter:{}}}}]);