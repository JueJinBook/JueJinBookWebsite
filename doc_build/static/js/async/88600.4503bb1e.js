"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["88600"],{244197:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var d=s(552676),r=s(740453);let i=s.p+"static/image/bfab6386601fbd52eea0dc1d4b5e4bf4.988234e4.webp";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",code:"code",strong:"strong",img:"img",ul:"ul",li:"li",ol:"ol"},(0,r.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"第29章复盘代码的review与评估",children:["第29章—复盘：代码的Review与评估",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第29章复盘代码的review与评估",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"\uFEFF前两章，我们已经把直播间的需求搞完了，那么本章节，我们就来 Review 下我们项目中的问题，我们主要反思做得不好的地方，次要反思做得好的地方。"}),"\n",(0,d.jsx)(n.p,{children:"对于做得不好的地方，我们重点分析原因，到底是因为理性还是因为感性，是因为时间问题还是因为性格问题，最后反思出解决方法；对于做得好的地方，我们主要记录下结果和心得，以便下次还这么做。"}),"\n",(0,d.jsx)(n.p,{children:"且把闲话休提，只说正话，我们的复盘就开始了。"}),"\n",(0,d.jsx)(n.p,{children:"我们先说做得不好的地方（减分点），后说加分点，这样就能有个好结尾，也就能给人留个好印象。"}),"\n",(0,d.jsxs)(n.h2,{id:"减分点",children:["减分点",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#减分点",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"成大事者，不虑胜先虑败。"}),"\n",(0,d.jsx)(n.p,{children:"我们就首当其冲地来痛定思痛，看一下我们哪里做得不够好。"}),"\n",(0,d.jsxs)(n.h3,{id:"1-数据安全问题",children:["1. 数据安全问题",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-数据安全问题",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["我们第一个做得不好的地方就是数据安全问题，我们的所有数据都是通过",(0,d.jsx)(n.code,{children:"json"}),"传递的，不够安全，别人很容易通过我们传递的数据推测出我们的意图，然后自己去模仿数据向服务器发送，这样以来，我们的直播间就有了安全隐患。"]}),"\n",(0,d.jsx)(n.p,{children:"那么怎么办呢？"}),"\n",(0,d.jsx)(n.p,{children:"嗯，加密！"}),"\n",(0,d.jsx)(n.p,{children:"用什么加密呢？MD5？"}),"\n",(0,d.jsx)(n.p,{children:"算了洗洗睡吧，你这加密加的连你们自己服务器都不认识了。"}),"\n",(0,d.jsx)(n.p,{children:"我们肯定要选个可逆的加密，对称加密还是非对称加密就看你们自己怎么定的了，加密这个事情一般都是服务器出策略的。客户端照着接上就行。"}),"\n",(0,d.jsx)(n.p,{children:"假如，我们采用了 RSA 加密，我们岂不是在所有发送数据的地方都要包装一下吗？"}),"\n",(0,d.jsx)(n.p,{children:"非也！"}),"\n",(0,d.jsxs)(n.p,{children:["其实，我们发送数据的地方就一个，就是",(0,d.jsx)(n.code,{children:"socke.sendMsg(json)"}),"，我们完全可以在这里直接将 json 数据用加密算法包装一下，然后发送给服务器。"]}),"\n",(0,d.jsx)(n.p,{children:"好，我知道了，那你一开始为啥不做呢？"}),"\n",(0,d.jsx)(n.p,{children:"因为我们 app 目前不出名，而且加了代码混淆。技术差的人反编译不了，技术好的人不屑于反编译。等我们 app 用户起来了之后，再做加密这件事也不迟，不然就等于给一个 100 块钱的手机买了个 200 块钱的保护套，不值！"}),"\n",(0,d.jsx)(n.p,{children:"......行吧。"}),"\n",(0,d.jsx)(n.p,{children:"接着说说第二点吧。"}),"\n",(0,d.jsxs)(n.h3,{id:"2-并发问题",children:["2. 并发问题",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-并发问题",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["第二点值得我们反思的就是并发问题，我们目前的解决方案很简单粗暴，",(0,d.jsx)(n.strong,{children:"在非 UI 线程中去解析数据，在 UI 线程中去分发事件来处理 UI"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"这是没问题，但是，不够细化。"}),"\n",(0,d.jsx)(n.p,{children:"如果有其他耗时操作，比如读取文件，网络请求，要放在哪里呢？"}),"\n",(0,d.jsx)(n.p,{children:"嗯，统一放在非 UI 线程中吗？肯定不行。这样可能就导致数据解析变慢，而 UI 的更新又是在数据解析之后的，这明显就会影响 UI 的更新，让户看起来可能就会卡顿。"}),"\n",(0,d.jsx)(n.p,{children:"所以，我们应该有个细化操作，可以将非 UI 线程细分为：网络请求线程，文件读取线程，数据解析线程等。"}),"\n",(0,d.jsx)(n.p,{children:"对应的操作就放在对应的线程中去做，这样达到各司其职，避免拥堵，让逻辑更合理。"}),"\n",(0,d.jsx)(n.p,{children:"当然有的语言可以采用线程池技术去处理，其实，不用也没问题，但是前提是自己维护好、管理好这些线程，只要能达到目标，采用什么方式都是可以的。"}),"\n",(0,d.jsx)(n.p,{children:"那这个为什么当初没做呢？"}),"\n",(0,d.jsx)(n.p,{children:"还是因为时间太紧急了，而这个又属于低优先级任务，不算是功能点，算是优化点，所以，后面再加也是可以的。毕竟，我们是先保证功能能用、有人用，然后再去优化功能点的。如果一次做到最好很浪费时间，那就先做成，再做好从而让时间分配灵活些。"}),"\n",(0,d.jsx)(n.p,{children:"接下来，再说说频控问题吧。"}),"\n",(0,d.jsxs)(n.h3,{id:"3-频控问题",children:["3. 频控问题",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-频控问题",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"啥是频控问题呢？"}),"\n",(0,d.jsx)(n.p,{children:"嗯，你有没有想过这样一个问题：假如我点击一个按钮请求一次数据，那么，当我第一次点下按钮的时，到第一次数据过来时，这期间我们的按钮时应该让点击呢，还是不让点击呢？"}),"\n",(0,d.jsx)(n.p,{children:"如果不让点击，用户就会觉得：这是不是卡了？如果让点击，那就会频繁地请求数据，导致出现一些无用的请求。"}),"\n",(0,d.jsx)(n.p,{children:"那怎么办呢？"}),"\n",(0,d.jsx)(n.p,{children:"我们可以让按钮可以点击，一直都可以点击，但是请求数据的时候就要做个判断了，如果当前正在请求 A 这个数据，后续如果还有请求 A 这个数据的动作，我们就直接忽略这个请求。"}),"\n",(0,d.jsx)(n.p,{children:"这样以来，用户自己也点了，他觉得自己请求了，他的心理得到了满足；而实际上，我们也只请求了一次，我们的心理也得到了满足，双赢！也就是赢两次！"}),"\n",(0,d.jsx)(n.p,{children:"那这样是不是太费劲了？"}),"\n",(0,d.jsx)(n.p,{children:"每个接口我都得加个标记来判断吗？烦死了。"}),"\n",(0,d.jsxs)(n.p,{children:["其实也不用，我们考虑一下，如果网络正常的情况下，一个数据请求大概都是几百毫秒，我们就取 500ms 吧，然后，我们就对可点击的控件，比如",(0,d.jsx)(n.code,{children:"Button"}),"，它的点击事件加个拦截，让其 500ms 内只响应一次点击事件，但是点击效果还是有的，只是拦截了点击事件。"]}),"\n",(0,d.jsxs)(n.p,{children:["这样以来，所有使用",(0,d.jsx)(n.code,{children:"Button"}),"的地方，他们点击事件在 500ms 只会响应一次，那么点击请求数据的场景，也就是 500ms 内最多请求一次了。"]}),"\n",(0,d.jsx)(n.p,{children:"有人说，如果网络不好，500ms 内数据还没请求过来呢？"}),"\n",(0,d.jsxs)(n.p,{children:["那也没问题啊，那就多一次请求呗，假如你的网络卡得要死，请求一次数据需要的时间是 T，那么你最多请求这个数据的次数就是",(0,d.jsx)(n.code,{children:"T/500"}),"，假如 5000ms 才请求过来数据，那最多就是 10 个请求这个数据的调用，这还是发生在用户疯狂连点的情况下，用户的单身时间要足够长，手速要足够快、心态要足够爆炸，网络还要卡，这是多小小概率事件啊，比谷歌收购微软 还 腾讯收购阿里，真是离谱他妈给离谱开门，离谱到家了，我们就不用咸吃箩卜淡操心了，多干点有用的事吧。"]}),"\n",(0,d.jsxs)(n.p,{children:["上述这个，就是频控问题，也就是",(0,d.jsx)(n.strong,{children:"我们要控制某个事件发生的频率"}),"，从而减少无效事件的发生次数，这样能节省流量，节省 CPU，各种节省，简直美滋滋。"]}),"\n",(0,d.jsx)(n.p,{children:"那这为啥一开始不做呢？"}),"\n",(0,d.jsx)(n.p,{children:"嗯，还是没时间，要不是项目急着上线，产品经理猴急猴急地催，谁都想把代码写到最好。"}),"\n",(0,d.jsx)(n.p,{children:"......好吧。"}),"\n",(0,d.jsx)(n.p,{children:"好，接下来就该吹吹我的加分点了，我都迫不及待了。"}),"\n",(0,d.jsxs)(n.h2,{id:"加分点",children:["加分点",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加分点",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"终于到了加分点了，这个我可要往死里吹，先把优点列出来，然后该扩句的扩句，往死里写，不解释。"}),"\n",(0,d.jsxs)(n.h3,{id:"1-生命周期的控制",children:["1. 生命周期的控制",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-生命周期的控制",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["首先，第一个，就是我用了逻辑转移，也就是把直播间的逻辑处理从全局转移到了局部，在代码里就是从",(0,d.jsx)(n.code,{children:"Socket"}),"中转移到了自己创建的",(0,d.jsx)(n.code,{children:"RoomContext"}),"中，大家都知道，",(0,d.jsx)(n.code,{children:"Socket"}),"是",(0,d.jsx)(n.code,{children:"App"}),"一级的，就是全局的，它的生命周期跟",(0,d.jsx)(n.code,{children:"App"}),"一样长，这样的话，就算直播间销毁了，这一块的逻辑还会有，可读性差，不利于维护。"]}),"\n",(0,d.jsxs)(n.p,{children:["所以，我就自己创建了个",(0,d.jsx)(n.code,{children:"RoomContex"}),"来处理直播间逻辑，这样一来，直播间的生命周期就跟着",(0,d.jsx)(n.code,{children:"RoomContext"}),"走，生命周期就比",(0,d.jsx)(n.code,{children:"App"}),"短，直播间没了，房间处理的逻辑也没了，有效控制了房间的生命周期，可读性好，容易维护。"]}),"\n",(0,d.jsxs)(n.h3,{id:"2-代码的设计优先原则",children:["2. 代码的设计优先原则",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-代码的设计优先原则",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"这一块功能我用了大量的设计模式以及设计思想，代码完全解耦，拓展性强，后面如果有其他改动，就会非常容易。"}),"\n",(0,d.jsxs)(n.p,{children:["比如，我在消息分发的时候，使用了",(0,d.jsx)(n.code,{children:"Map"}),"来存储事件，而不是用",(0,d.jsx)(n.code,{children:"if-esle"}),"跳转，这样后续有新事件添加或者删除，就只需要添加/删除一个键值对就行，非常方便，且不会有其他影响。"]}),"\n",(0,d.jsxs)(n.p,{children:["而且，项目的整体架构我采用的是分层模式，顶层是基础房间，第二层才是我们的语音直播间，如果将来要扩展其他类型的房间，直接在适合的层级添加一个对应的",(0,d.jsx)(n.code,{children:"RoomContext"}),"即可，逻辑完全能够复用。"]}),"\n",(0,d.jsxs)(n.p,{children:["我在房间层级的实现是采用的 MVC 模式，数据放在",(0,d.jsx)(n.code,{children:"RoomContext"}),"中，完全和 UI 分离，即使将来要换皮，换 UI，完全不会影响到数据部分。"]}),"\n",(0,d.jsx)(n.p,{children:"最后，我设计了直播间的相关类图，将来如果有其他同学要参与到项目中，可以看下这个类图，逻辑应该就会清晰很多："}),"\n",(0,d.jsx)(n.p,{children:(0,d.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,d.jsxs)(n.p,{children:["大家应该还记得对象的 UML 图，如果不记得的话，就去复习下第 ",(0,d.jsx)(n.a,{href:"https://juejin.cn/book/7196580339181944872/section/7196592243296501794",target:"_blank",rel:"noopener noreferrer",children:"24 章"}),"。"]}),"\n",(0,d.jsx)(n.p,{children:"我们光看代码很容易迷失，看类图是不是清晰多了？我们看这个就知道谁继承谁，谁持有谁，当然，这个类图并不完善，因为只是列出了类名和它们之间的关系，并没有列出它们的函数和变量，所以看不到它们的功能，这个就要靠你去实现了，你可以看下相关的书籍，然后把这个类图补全，等到补全之后，你光看类图就大概知道整个项目的代码是怎么设计的了，这就是软件工程的必修本领——UML 图——的强大之处。"}),"\n",(0,d.jsx)(n.p,{children:"等你看完本小册时，你再回来看下这个类图，看看它是不是和你补完的一样吧。"}),"\n",(0,d.jsxs)(n.h2,{id:"总结",children:["总结",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"本章，我们讲解了一个项目的复盘实战，总结来说就是这么几点。"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"反思自己的缺点，以及为什么会犯，要怎么改。"}),"\n",(0,d.jsx)(n.li,{children:"总结自己的优点，哪里做得好，值得大家学习。"}),"\n",(0,d.jsx)(n.li,{children:"给自己打分，建议不要太高，但是也别太低。"}),"\n"]}),"\n",(0,d.jsx)(n.p,{children:"项目复盘必不可少，且是大公司的最爱。一般来说，我们要做到以下几点，那么就能从容应对各种复盘。"}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsx)(n.li,{children:"提前列出自己的缺点，并想好应对措施和答词。应对措施是让自己反思的，答词是给别人听的。"}),"\n",(0,d.jsx)(n.li,{children:"反思缺点时候一定要认真，态度要真诚。其中认真是为自己考虑的，态度是给别人看的。"}),"\n",(0,d.jsx)(n.li,{children:"说优点时一定要放大，这里面有多少水分自己知道就行。放大是为了别人看得懂、看得清，知道其中的利害。"}),"\n",(0,d.jsx)(n.li,{children:"打分时，不要太高，也别太低，太低会让人觉得自己不够自信，太高会让别人觉得自己自大，别人心里都清楚的。"}),"\n"]}),"\n",(0,d.jsxs)(n.p,{children:["相信，看到这里，你应该比油条“",(0,d.jsx)(n.strong,{children:"老"}),"”那么一点了吧。"]}),"\n",(0,d.jsxs)(n.p,{children:["好，那么关于技术的，我们到这里就结束了，后面的两章，我们就开始学习程序员必须掌握的基本功能——",(0,d.jsx)(n.strong,{children:"版本控制"}),"，我们就一起来看看",(0,d.jsx)(n.code,{children:"Git"}),"是怎么使用的吧，我们下一章见。"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE%2F%E7%AC%AC29%E7%AB%A0%E2%80%94%E5%A4%8D%E7%9B%98%EF%BC%9A%E4%BB%A3%E7%A0%81%E7%9A%84Review%E4%B8%8E%E8%AF%84%E4%BC%B0.md"]={toc:[{text:"减分点",id:"减分点",depth:2},{text:"1. 数据安全问题",id:"1-数据安全问题",depth:3},{text:"2. 并发问题",id:"2-并发问题",depth:3},{text:"3. 频控问题",id:"3-频控问题",depth:3},{text:"加分点",id:"加分点",depth:2},{text:"1. 生命周期的控制",id:"1-生命周期的控制",depth:3},{text:"2. 代码的设计优先原则",id:"2-代码的设计优先原则",depth:3},{text:"总结",id:"总结",depth:2}],title:"第29章—复盘：代码的Review与评估",headingTitle:"第29章—复盘：代码的Review与评估",frontmatter:{}}}}]);