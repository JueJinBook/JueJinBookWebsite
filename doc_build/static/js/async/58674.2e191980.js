"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["58674"],{24874:function(n,e,t){t.r(e),t.d(e,{default:()=>i});var s=t(552676),r=t(740453);let l=t.p+"static/image/dcb85f7b298ab23864678688330c3049.24315f6d.webp";function o(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",h3:"h3",pre:"pre",code:"code",strong:"strong",img:"img",ol:"ol",li:"li"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"38-原理篇--前端框架的未来--signals",children:["38-原理篇 ❘ 前端框架的未来 —— Signals",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#38-原理篇--前端框架的未来--signals",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"推荐学习指数：⭐️️⭐️️⭐️️"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"1-前言",children:["1. 前言",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前言",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"最近大家提起 Signals，都在说：“Signals 是前端框架的未来”。从使用情况来说，还真是这样。Angular、Ember、Preact、Qwik、Solid、Svelte、Vue，甚至 Mobx、Tailwind 都已使用 Signals，甚至已经有了关于 Signals 的 TC39 提案，未来可能直接在 JavaScript 中使用 Signals。然而，Signals 并不是一个新概念，早在 2010 年的 Knockout.js 就有使用。"}),"\n",(0,s.jsx)(e.p,{children:"所以 Signals 到底是什么？又是因为什么流行起来？背后的实现原理是什么？带来了哪些好处，解决了哪些问题？为什么会受到大家的喜欢和推崇？"}),"\n",(0,s.jsx)(e.p,{children:"因为 Svelte 5 的符文功能正是基于 Signals，所以本篇就带大家探究一下 Signals。"}),"\n",(0,s.jsxs)(e.h2,{id:"2-signals",children:["2. Signals",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-signals",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"什么是 Signals 呢？在我看来，它是一种实现细粒度响应式的技术称呼。在学术论文中经常被称为“ Signals”，也会被称为：Observables、Atoms、Subjects、Refs（想想 Vue 的 Ref）。因为是一种技术名称，所以它没有具体的 API，每个框架都有自己的实现方式。"}),"\n",(0,s.jsxs)(e.h3,{id:"21-响应式",children:["2.1. 响应式",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#21-响应式",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"关于“细粒度响应式”，让我们来慢慢解释。"}),"\n",(0,s.jsx)(e.p,{children:"首先是什么是响应式？"}),"\n",(0,s.jsx)(e.p,{children:"JavaScript 的响应式是有限制的，举个例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"let count = 1;\nlet doubled = count * 2;\n\ncount = 2;\nconsole.log(doubled);\n"})}),"\n",(0,s.jsxs)(e.p,{children:["此时 ",(0,s.jsx)(e.code,{children:"doubled"}),"的打印结果为 ",(0,s.jsx)(e.code,{children:"2"}),"，但我们想要的是 ",(0,s.jsx)(e.code,{children:"4"}),"，为此我们可以这样做："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"let count = 1;\nlet doubled = () => count * 2;\n\ncount = 2;\nconsole.log(doubled());\n\ncount = 3;\nconsole.log(doubled());\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这当然能解决问题，但实际项目开发中，我们还想要在 ",(0,s.jsx)(e.code,{children:"count"}),"值发生修改的时候做一些事情（这就是我们常说的 effect），我们很容易想到使用观察者模式："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function observable(value) {\n  const subscribers = new Set();\n  return {\n    subscribe(fn) {\n      subscribers.add(fn);\n    },\n    update(value) {\n      subscribers.forEach((fn) => fn(value));\n    },\n  };\n}\n\nlet count = observable(0);\n\ncount.subscribe((count) => {\n  console.log(count);\n});\n\ncount.update(2);\n"})}),"\n",(0,s.jsx)(e.p,{children:"这当然能解决问题，但每次都要手动进行订阅会让代码更加复杂，而且我们该如何处理像 doubled 这种衍生状态呢？我们或许会这样做："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'let count = observable(0);\nlet doubled;\n\ncount.subscribe((count) => {\n  console.log("count =", count);\n});\n\ncount.subscribe((count) => {\n  doubled = count * 2;\n  console.log("count * 2 =", doubled);\n});\n\ncount.update(2);\n'})}),"\n",(0,s.jsx)(e.p,{children:"可以看出：对于衍生状态以及其修改时的副作用订阅，这些都会增加代码的复杂度。"}),"\n",(0,s.jsx)(e.p,{children:"为了统一解决这些问题，在不断地实践中便有了“Signals”，它本质还是基于观察者模式，但是借助了 getter 和 setter，所以它解决了手动订阅的问题。"}),"\n",(0,s.jsx)(e.p,{children:"它的使用方式如下："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'let subscriber = null;\n\nfunction signal(value) {\n  const subscribers = new Set();\n  return {\n    get value() {\n      if (subscriber) {\n        subscribers.add(subscriber);\n      }\n      return value;\n    },\n    set value(newValue) {\n      value = newValue;\n      subscribers.forEach((fn) => fn());\n    },\n  };\n}\n\nfunction effect(fn) {\n  subscriber = fn;\n  fn();\n  subscriber = null;\n}\n\nfunction derived(fn) {\n  const derived = signal();\n  effect(() => {\n    derived.value = fn();\n  });\n  return derived;\n}\n\nlet count = signal(0);\nlet doubled = derived(() => count.value * 2);\n\neffect(() => {\n  console.log("count =", count.value);\n});\n\neffect(() => {\n  console.log("count * 2 =", doubled.value);\n});\n\ncount.value = 2;\n'})}),"\n",(0,s.jsx)(e.p,{children:"这是我们自己定义的 Signals 函数和使用方式，但已经接近主流框架 Signals 的使用方式了。单看 Signals 其实是没有什么特别的，搭配 Reactions（也被称为 Effects、Autoruns、 Watches 或 Computed）和衍生状态的处理会让 Signals 的功能更加强大。其中 Reactions 会监听 Signals 的改变，在其发生更新时重新运行。"}),"\n",(0,s.jsx)(e.p,{children:"所以再看这段代码，其实还是很神奇的，因为修改 count 的值和 effect 表面上没有什么直接关联的地方，但在底层的实现中，effect 的回调函数会调用 count，因为调用了 count，所以自动订阅了 effect 函数。当 count 的值发生修改时，就会重新运行 effect 函数。"}),"\n",(0,s.jsx)(e.p,{children:"这就是 Signals 所带来的响应式，其实很多框架都已经实现了。"}),"\n",(0,s.jsx)(e.p,{children:"比如这是 2010 年的 Knockout："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const count = ko.observable(0);\n\nconst doubleCount = ko.pureComputed(() => count() * 2);\n\n// logs whenever doubleCount updates\nko.computed(() => console.log(doubleCount()));\n"})}),"\n",(0,s.jsx)(e.p,{children:"Vue："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import { ref, watchEffect } from "vue";\n\nconst count = ref(0);\n\nwatchEffect(() => {\n  document.body.innerHTML = `Count is: ${count.value}`;\n});\n\n// 更新 DOM\ncount.value++;\n'})}),"\n",(0,s.jsx)(e.p,{children:"Solid.js："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'import { createSignal } from "solid-js";\n\nconst [count, setCount] = createSignal(0);\n\nfunction Counter() {\n  return (\n    <div\n      onClick={() => {\n        setCount((c) => c + 1);\n      }}\n    >\n      Count: {count()}\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"https://eisenbergeffect.medium.com/a-tc39-proposal-for-signals-f0bedd37a335",title:"https://eisenbergeffect.medium.com/a-tc39-proposal-for-signals-f0bedd37a335",target:"_blank",rel:"noopener noreferrer",children:"Signals TC39 草案"}),"："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const counter = new Signal.State(0);\nconsole.log(counter.get()); // 0\ncounter.set(1);\nconsole.log(counter.get()); // 1\nconst isEven = new Signal.Computed(() => (counter.get() & 1) == 0);\nconsole.log(isEven.get()); // false\ncounter.set(2);\nconsole.log(isEven.get()); // true\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"22-细粒度",children:["2.2. 细粒度",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#22-细粒度",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"那细粒度又是指什么呢？这就不得不提 React 了，我们举个例子："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:"export function Counter() {\n  const [count, setCount] = useState(0);\n  return <button onClick={() => setCount(count + 1)}>{count}</button>;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"在 React 中，useState() 返回一个状态值和修改状态值的方法，当你调用 setCount 告诉 React 有状态修改的时候，React 必须重新渲染整个组件。"}),"\n",(0,s.jsx)(e.p,{children:"但使用 Signals 是不会的，我们以 Solid.js 为例："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:'import { createSignal } from "solid-js";\n\nfunction Counter() {\n  const [count, setCount] = createSignal(0);\n  return <button onClick={() => setCount(count() + 1)}>{count()}</button>;\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"在 Solid.js 中，虽然代码看起来极其相似，但当你调用 setCount 更新状态的时候，组件并不会重新渲染，它会直接更新 DOM 内容。"}),"\n",(0,s.jsx)(e.p,{children:"让我们举个更明显的例子："}),"\n",(0,s.jsx)(e.p,{children:"这是 React："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:'import { useState, useEffect } from "react";\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setCount((c) => c + 1);\n    }, 1000);\n    return () => clearInterval(intervalId);\n  }, []);\n\n  console.log(count);\n  return <h1>{count}</h1>;\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"你可以想到，React 每秒都会打印一次 count，因为 setCount 会触发组件重新渲染。"}),"\n",(0,s.jsx)(e.p,{children:"但如果是在 Solid.js 中："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:'import { render } from "solid-js/web";\nimport { createSignal, onCleanup } from "solid-js";\n\nfunction Counter() {\n  const [count, setCount] = createSignal(0);\n\n  const timer = setInterval(() => setCount((c) => c + 1), 1000);\n  onCleanup(() => clearInterval(timer));\n  console.log(count());\n  return <h1>{count()}</h1>;\n}\n\nrender(() => <Counter />, document.getElementById("app"));\n'})}),"\n",(0,s.jsx)(e.p,{children:"count 只会打印一次，如果你想每秒都打印，可以这样写："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-jsx",children:'import { render } from "solid-js/web";\nimport { createSignal, onCleanup } from "solid-js";\n\nfunction Counter() {\n  const [count, setCount] = createSignal(0);\n\n  const timer = setInterval(() => setCount((c) => c + 1), 1000);\n  onCleanup(() => clearInterval(timer));\n  return <h1>{console.log(count())}</h1>;\n}\n\nrender(() => <Counter />, document.getElementById("app"));\n'})}),"\n",(0,s.jsx)(e.p,{children:"那么问题来了，为什么两者的效果截然不同呢？"}),"\n",(0,s.jsxs)(e.p,{children:["这是因为 React 返回的是",(0,s.jsx)(e.strong,{children:"状态值（StateValue）"}),"，而 Solid.js 返回的是",(0,s.jsx)(e.strong,{children:"状态引用（StateReference）"}),"。"]}),"\n",(0,s.jsxs)(e.p,{children:["对于 React 而言，useState 是不知道状态值在组件中是如何使用的，当你通过 ",(0,s.jsx)(e.code,{children:"setCount"}),"通知 React 发生状态更改，因为 React 不知道页面的哪一部分发生了变化，因此必须重新渲染整个组件，这个计算代价是高昂的。"]}),"\n",(0,s.jsxs)(e.p,{children:["而对于 Solid.js 而言，为了能够做出反应，信号会在状态被调用时（",(0,s.jsx)(e.code,{children:"count()"}),"）收集上下文信息，换句话说，使用 ",(0,s.jsx)(e.code,{children:"count()"})," 时会自动创建一个 subscription，所以当 count 的值发生修改的时候，Solid.js 已经知道哪里要发生修改，所以无须渲染整个组件，只更改对应部分的值即可。"]}),"\n",(0,s.jsxs)(e.p,{children:["这就是 Signals 带来的细粒度。介绍 Svelte 5 的文档经常会有 ",(0,s.jsx)(e.strong,{children:"“Fine-grained reactivity”"})," 这个名词，其实说的就是细粒度响应式。Svelte 5 正是基于 Signals 对代码进行了重构。"]}),"\n",(0,s.jsxs)(e.h2,{id:"3-signals-的简单历史",children:["3. Signals 的简单历史",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-signals-的简单历史",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Signals 为什么逐渐火起来呢？这离不开各个框架的支持以及一些关键节点事件的发生。所以简单说一下（权当八卦听了）："}),"\n",(0,s.jsx)(e.p,{children:"最早是被追溯到 2010 年的 Knockout.js："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"const count = ko.observable(0);\n\nconst doubleCount = ko.pureComputed(() => count() * 2);\n\nko.computed(() => console.log(doubleCount()));\n"})}),"\n",(0,s.jsx)(e.p,{children:"后来 React 流行，这种响应式成为小众。"}),"\n",(0,s.jsxs)(e.p,{children:["2014 年，Vue 一开始就采用了响应式，但只是将其作为内部的实现机制。Vue 现在的官网上有",(0,s.jsx)(e.a,{href:"https://cn.vuejs.org/guide/extras/reactivity-in-depth",title:"https://cn.vuejs.org/guide/extras/reactivity-in-depth",target:"_blank",rel:"noopener noreferrer",children:"《与信号 (signal) 的联系》"}),"章节，与主流框架的 Signals 做了对比。"]}),"\n",(0,s.jsx)(e.p,{children:"2019 年，Svelte3 展示了编译器的能力，从编译的角度实现了响应式，这让大家更加注重编译所带来的优化效果在，这也将成为未来框架的趋势。"}),"\n",(0,s.jsxs)(e.p,{children:["正式火起来应该是 Solid.js 的诞生以及它将 Signals 这个概念推出来，这也是 Solid.js 的基础。Solid.js 的作者 ",(0,s.jsx)(e.a,{href:"https://dev.to/ryansolid",title:"https://dev.to/ryansolid",target:"_blank",rel:"noopener noreferrer",children:"Ryan Carniato"})," 发布了很多介绍响应式和 Signals 的文章，受到大家的欢迎。"]}),"\n",(0,s.jsxs)(e.p,{children:["2023 年，Builder.io 的 CTO、Angular、Qwik 的作者 Miško Hevery 发文",(0,s.jsx)(e.a,{href:"https://www.builder.io/blog/usesignal-is-the-future-of-web-frameworks",title:"https://www.builder.io/blog/usesignal-is-the-future-of-web-frameworks",target:"_blank",rel:"noopener noreferrer",children:"《useSignal() is the Future of Web Frameworks》"}),"。这应该就是“Signals 是前端框架的未来”这种说法的来源了。它的主要观点就是 React 的 useState 返回的响应值在改变时会导致组件重新渲染，基于 Signals 会自动创建订阅，通知改变，带来更高的性能。加上随着这么多年各个框架的实践，Signals 的开发者使用体验已经很好了，不比传统框架差。所以未来应该是基于 Signals 的。"]}),"\n",(0,s.jsx)(e.p,{children:"随着 Signals 的概念逐渐深入人心，Angular、Ember、Preact、Qwik、Solid、Svelte、Vue，甚至 Mobx、Tailwind 都已使用 Signals，现在已经有了关于 Signals 的 TC39 提案，未来可能直接在 JavaScript 中使用 Signals。"}),"\n",(0,s.jsx)(e.p,{children:"React 考虑在底层使用："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(e.h2,{id:"4-参考链接",children:["4. 参考链接",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-参考链接",children:"#"})]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf",title:"https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf",target:"_blank",rel:"noopener noreferrer",children:"A Hands-on Introduction to Fine-Grained Reactivity"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob",title:"https://dev.to/this-is-learning/the-evolution-of-signals-in-javascript-8ob",target:"_blank",rel:"noopener noreferrer",children:"The Evolution of Signals in JavaScript"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://dev.to/ratiu5/implementing-signals-from-scratch-3e4c",title:"https://dev.to/ratiu5/implementing-signals-from-scratch-3e4c",target:"_blank",rel:"noopener noreferrer",children:"Implementing Signals from Scratch"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://frontendmasters.com/blog/vanilla-javascript-reactivity/#toc-11",title:"https://frontendmasters.com/blog/vanilla-javascript-reactivity/#toc-11",target:"_blank",rel:"noopener noreferrer",children:"Patterns for Reactivity with Modern Vanilla JavaScript – Frontend Masters Boost"})}),"\n"]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(o,{...n})}):o(n)}let i=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["Svelte%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F38-%E5%8E%9F%E7%90%86%E7%AF%87%20%E2%9D%98%20%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9A%84%E6%9C%AA%E6%9D%A5%20%E2%80%94%E2%80%94%20Signals.md"]={toc:[{text:"1. 前言",id:"1-前言",depth:2},{text:"2. Signals",id:"2-signals",depth:2},{text:"2.1. 响应式",id:"21-响应式",depth:3},{text:"2.2. 细粒度",id:"22-细粒度",depth:3},{text:"3. Signals 的简单历史",id:"3-signals-的简单历史",depth:2},{text:"4. 参考链接",id:"4-参考链接",depth:2}],title:"38-原理篇 ❘ 前端框架的未来 —— Signals",headingTitle:"38-原理篇 ❘ 前端框架的未来 —— Signals",frontmatter:{}}}}]);