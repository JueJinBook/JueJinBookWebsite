"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["38817"],{974635:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var t=r(552676),c=r(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",ul:"ul",li:"li",h3:"h3"},(0,c.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"16reflect",children:["16.Reflect",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16reflect",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"概述",children:["概述",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#概述",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect"}),"对象与",(0,t.jsx)(n.code,{children:"Proxy"}),"对象一样，也是 ES6 为了操作对象而提供的新 API。",(0,t.jsx)(n.code,{children:"Reflect"}),"对象的设计目的有这样几个。"]}),"\n",(0,t.jsxs)(n.p,{children:["（1） 将",(0,t.jsx)(n.code,{children:"Object"}),"对象的一些明显属于语言内部的方法（比如",(0,t.jsx)(n.code,{children:"Object.defineProperty"}),"），放到",(0,t.jsx)(n.code,{children:"Reflect"}),"对象上。现阶段，某些方法同时在",(0,t.jsx)(n.code,{children:"Object"}),"和",(0,t.jsx)(n.code,{children:"Reflect"}),"对象上部署，未来的新方法将只部署在",(0,t.jsx)(n.code,{children:"Reflect"}),"对象上。也就是说，从",(0,t.jsx)(n.code,{children:"Reflect"}),"对象上可以拿到语言内部的方法。"]}),"\n",(0,t.jsxs)(n.p,{children:["（2） 修改某些",(0,t.jsx)(n.code,{children:"Object"}),"方法的返回结果，让其变得更合理。比如，",(0,t.jsx)(n.code,{children:"Object.defineProperty(obj, name, desc)"}),"在无法定义属性时，会抛出一个错误，而",(0,t.jsx)(n.code,{children:"Reflect.defineProperty(obj, name, desc)"}),"则会返回",(0,t.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// 老写法\ntry {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n\n// 新写法\nif (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["（3） 让",(0,t.jsx)(n.code,{children:"Object"}),"操作都变成函数行为。某些",(0,t.jsx)(n.code,{children:"Object"}),"操作是命令式，比如",(0,t.jsx)(n.code,{children:"name in obj"}),"和",(0,t.jsx)(n.code,{children:"delete obj[name]"}),"，而",(0,t.jsx)(n.code,{children:"Reflect.has(obj, name)"}),"和",(0,t.jsx)(n.code,{children:"Reflect.deleteProperty(obj, name)"}),"让它们变成了函数行为。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// 老写法\n'assign' in Object // true\n\n// 新写法\nReflect.has(Object, 'assign') // true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["（4）",(0,t.jsx)(n.code,{children:"Reflect"}),"对象的方法与",(0,t.jsx)(n.code,{children:"Proxy"}),"对象的方法一一对应，只要是",(0,t.jsx)(n.code,{children:"Proxy"}),"对象的方法，就能在",(0,t.jsx)(n.code,{children:"Reflect"}),"对象上找到对应的方法。这就让",(0,t.jsx)(n.code,{children:"Proxy"}),"对象可以方便地调用对应的",(0,t.jsx)(n.code,{children:"Reflect"}),"方法，完成默认行为，作为修改行为的基础。也就是说，不管",(0,t.jsx)(n.code,{children:"Proxy"}),"怎么修改默认行为，你总可以在",(0,t.jsx)(n.code,{children:"Reflect"}),"上获取默认行为。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Proxy(target, {\n  set: function(target, name, value, receiver) {\n    var success = Reflect.set(target, name, value, receiver);\n    if (success) {\n      console.log('property ' + name + ' on ' + target + ' set to ' + value);\n    }\n    return success;\n  }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上面代码中，",(0,t.jsx)(n.code,{children:"Proxy"}),"方法拦截",(0,t.jsx)(n.code,{children:"target"}),"对象的属性赋值行为。它采用",(0,t.jsx)(n.code,{children:"Reflect.set"}),"方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。"]}),"\n",(0,t.jsx)(n.p,{children:"下面是另一个例子。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var loggedObj = new Proxy(obj, {\n  get(target, name) {\n    console.log('get', target, name);\n    return Reflect.get(target, name);\n  },\n  deleteProperty(target, name) {\n    console.log('delete' + name);\n    return Reflect.deleteProperty(target, name);\n  },\n  has(target, name) {\n    console.log('has' + name);\n    return Reflect.has(target, name);\n  }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上面代码中，每一个",(0,t.jsx)(n.code,{children:"Proxy"}),"对象的拦截操作（",(0,t.jsx)(n.code,{children:"get"}),"、",(0,t.jsx)(n.code,{children:"delete"}),"、",(0,t.jsx)(n.code,{children:"has"}),"），内部都调用对应的",(0,t.jsx)(n.code,{children:"Reflect"}),"方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。"]}),"\n",(0,t.jsxs)(n.p,{children:["有了",(0,t.jsx)(n.code,{children:"Reflect"}),"对象以后，很多操作会更易读。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// 老写法\nFunction.prototype.apply.call(Math.floor, undefined, [1.75]) // 1\n\n// 新写法\nReflect.apply(Math.floor, undefined, [1.75]) // 1\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"静态方法",children:["静态方法",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#静态方法",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect"}),"对象一共有 13 个静态方法。"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reflect.apply(target, thisArg, args)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.construct(target, args)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.get(target, name, receiver)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.set(target, name, value, receiver)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.defineProperty(target, name, desc)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.deleteProperty(target, name)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.has(target, name)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.ownKeys(target)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.isExtensible(target)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.preventExtensions(target)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.getOwnPropertyDescriptor(target, name)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.getPrototypeOf(target)"}),"\n",(0,t.jsx)(n.li,{children:"Reflect.setPrototypeOf(target, prototype)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["上面这些方法的作用，大部分与",(0,t.jsx)(n.code,{children:"Object"}),"对象的同名方法的作用都是相同的，而且它与",(0,t.jsx)(n.code,{children:"Proxy"}),"对象的方法是一一对应的。下面是对它们的解释。"]}),"\n",(0,t.jsxs)(n.h3,{id:"reflectgettarget-name-receiver",children:["Reflect.get(target, name, receiver)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectgettarget-name-receiver",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.get"}),"方法查找并返回",(0,t.jsx)(n.code,{children:"target"}),"对象的",(0,t.jsx)(n.code,{children:"name"}),"属性，如果没有该属性，则返回",(0,t.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var myObject = {\n  foo: 1,\n  bar: 2,\n  get baz() {\n    return this.foo + this.bar;\n  },\n}\n\nReflect.get(myObject, 'foo') // 1\nReflect.get(myObject, 'bar') // 2\nReflect.get(myObject, 'baz') // 3\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果",(0,t.jsx)(n.code,{children:"name"}),"属性部署了读取函数（getter），则读取函数的",(0,t.jsx)(n.code,{children:"this"}),"绑定",(0,t.jsx)(n.code,{children:"receiver"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var myObject = {\n  foo: 1,\n  bar: 2,\n  get baz() {\n    return this.foo + this.bar;\n  },\n};\n\nvar myReceiverObject = {\n  foo: 4,\n  bar: 4,\n};\n\nReflect.get(myObject, 'baz', myReceiverObject) // 8\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果第一个参数不是对象，",(0,t.jsx)(n.code,{children:"Reflect.get"}),"方法会报错。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Reflect.get(1, 'foo') // 报错\nReflect.get(false, 'foo') // 报错\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reflectsettarget-name-value-receiver",children:["Reflect.set(target, name, value, receiver)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectsettarget-name-value-receiver",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.set"}),"方法设置",(0,t.jsx)(n.code,{children:"target"}),"对象的",(0,t.jsx)(n.code,{children:"name"}),"属性等于",(0,t.jsx)(n.code,{children:"value"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var myObject = {\n  foo: 1,\n  set bar(value) {\n    return this.foo = value;\n  },\n}\n\nmyObject.foo // 1\n\nReflect.set(myObject, 'foo', 2);\nmyObject.foo // 2\n\nReflect.set(myObject, 'bar', 3)\nmyObject.foo // 3\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果",(0,t.jsx)(n.code,{children:"name"}),"属性设置了赋值函数，则赋值函数的",(0,t.jsx)(n.code,{children:"this"}),"绑定",(0,t.jsx)(n.code,{children:"receiver"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var myObject = {\n  foo: 4,\n  set bar(value) {\n    return this.foo = value;\n  },\n};\n\nvar myReceiverObject = {\n  foo: 0,\n};\n\nReflect.set(myObject, 'bar', 1, myReceiverObject);\nmyObject.foo // 4\nmyReceiverObject.foo // 1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["注意，如果 ",(0,t.jsx)(n.code,{children:"Proxy"}),"对象和 ",(0,t.jsx)(n.code,{children:"Reflect"}),"对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了",(0,t.jsx)(n.code,{children:"receiver"}),"，那么",(0,t.jsx)(n.code,{children:"Reflect.set"}),"会触发",(0,t.jsx)(n.code,{children:"Proxy.defineProperty"}),"拦截。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"let p = {\n  a: 'a'\n};\n\nlet handler = {\n  set(target, key, value, receiver) {\n    console.log('set');\n    Reflect.set(target, key, value, receiver)\n  },\n  defineProperty(target, key, attribute) {\n    console.log('defineProperty');\n    Reflect.defineProperty(target, key, attribute);\n  }\n};\n\nlet obj = new Proxy(p, handler);\nobj.a = 'A';\n// set\n// defineProperty\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上面代码中，",(0,t.jsx)(n.code,{children:"Proxy.set"}),"拦截里面使用了",(0,t.jsx)(n.code,{children:"Reflect.set"}),"，而且传入了",(0,t.jsx)(n.code,{children:"receiver"}),"，导致触发",(0,t.jsx)(n.code,{children:"Proxy.defineProperty"}),"拦截。这是因为",(0,t.jsx)(n.code,{children:"Proxy.set"}),"的",(0,t.jsx)(n.code,{children:"receiver"}),"参数总是指向当前的 ",(0,t.jsx)(n.code,{children:"Proxy"}),"实例（即上例的",(0,t.jsx)(n.code,{children:"obj"}),"），而",(0,t.jsx)(n.code,{children:"Reflect.set"}),"一旦传入",(0,t.jsx)(n.code,{children:"receiver"}),"，就会将属性赋值到",(0,t.jsx)(n.code,{children:"receiver"}),"上面（即",(0,t.jsx)(n.code,{children:"obj"}),"），导致触发",(0,t.jsx)(n.code,{children:"defineProperty"}),"拦截。如果",(0,t.jsx)(n.code,{children:"Reflect.set"}),"没有传入",(0,t.jsx)(n.code,{children:"receiver"}),"，那么就不会触发",(0,t.jsx)(n.code,{children:"defineProperty"}),"拦截。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"let p = {\n  a: 'a'\n};\n\nlet handler = {\n  set(target, key, value, receiver) {\n    console.log('set');\n    Reflect.set(target, key, value)\n  },\n  defineProperty(target, key, attribute) {\n    console.log('defineProperty');\n    Reflect.defineProperty(target, key, attribute);\n  }\n};\n\nlet obj = new Proxy(p, handler);\nobj.a = 'A';\n// set\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果第一个参数不是对象，",(0,t.jsx)(n.code,{children:"Reflect.set"}),"会报错。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Reflect.set(1, 'foo', {}) // 报错\nReflect.set(false, 'foo', {}) // 报错\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reflecthasobj-name",children:["Reflect.has(obj, name)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflecthasobj-name",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.has"}),"方法对应",(0,t.jsx)(n.code,{children:"name in obj"}),"里面的",(0,t.jsx)(n.code,{children:"in"}),"运算符。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var myObject = {\n  foo: 1,\n};\n\n// 旧写法\n'foo' in myObject // true\n\n// 新写法\nReflect.has(myObject, 'foo') // true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果",(0,t.jsx)(n.code,{children:"Reflect.has()"}),"方法的第一个参数不是对象，会报错。"]}),"\n",(0,t.jsxs)(n.h3,{id:"reflectdeletepropertyobj-name",children:["Reflect.deleteProperty(obj, name)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectdeletepropertyobj-name",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.deleteProperty"}),"方法等同于",(0,t.jsx)(n.code,{children:"delete obj[name]"}),"，用于删除对象的属性。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myObj = { foo: 'bar' };\n\n// 旧写法\ndelete myObj.foo;\n\n// 新写法\nReflect.deleteProperty(myObj, 'foo');\n"})}),"\n",(0,t.jsxs)(n.p,{children:["该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回",(0,t.jsx)(n.code,{children:"true"}),"；删除失败，被删除的属性依然存在，返回",(0,t.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["如果",(0,t.jsx)(n.code,{children:"Reflect.deleteProperty()"}),"方法的第一个参数不是对象，会报错。"]}),"\n",(0,t.jsxs)(n.h3,{id:"reflectconstructtarget-args",children:["Reflect.construct(target, args)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectconstructtarget-args",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.construct"}),"方法等同于",(0,t.jsx)(n.code,{children:"new target(...args)"}),"，这提供了一种不使用",(0,t.jsx)(n.code,{children:"new"}),"，来调用构造函数的方法。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function Greeting(name) {\n  this.name = name;\n}\n\n// new 的写法\nconst instance = new Greeting('张三');\n\n// Reflect.construct 的写法\nconst instance = Reflect.construct(Greeting, ['张三']);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果",(0,t.jsx)(n.code,{children:"Reflect.construct()"}),"方法的第一个参数不是函数，会报错。"]}),"\n",(0,t.jsxs)(n.h3,{id:"reflectgetprototypeofobj",children:["Reflect.getPrototypeOf(obj)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectgetprototypeofobj",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.getPrototypeOf"}),"方法用于读取对象的",(0,t.jsx)(n.code,{children:"__proto__"}),"属性，对应",(0,t.jsx)(n.code,{children:"Object.getPrototypeOf(obj)"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myObj = new FancyThing();\n\n// 旧写法\nObject.getPrototypeOf(myObj) === FancyThing.prototype;\n\n// 新写法\nReflect.getPrototypeOf(myObj) === FancyThing.prototype;\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.getPrototypeOf"}),"和",(0,t.jsx)(n.code,{children:"Object.getPrototypeOf"}),"的一个区别是，如果参数不是对象，",(0,t.jsx)(n.code,{children:"Object.getPrototypeOf"}),"会将这个参数转为对象，然后再运行，而",(0,t.jsx)(n.code,{children:"Reflect.getPrototypeOf"}),"会报错。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Object.getPrototypeOf(1) // Number {[[PrimitiveValue]]: 0}\nReflect.getPrototypeOf(1) // 报错\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reflectsetprototypeofobj-newproto",children:["Reflect.setPrototypeOf(obj, newProto)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectsetprototypeofobj-newproto",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.setPrototypeOf"}),"方法用于设置目标对象的原型（prototype），对应",(0,t.jsx)(n.code,{children:"Object.setPrototypeOf(obj, newProto)"}),"方法。它返回一个布尔值，表示是否设置成功。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myObj = {};\n\n// 旧写法\nObject.setPrototypeOf(myObj, Array.prototype);\n\n// 新写法\nReflect.setPrototypeOf(myObj, Array.prototype);\n\nmyObj.length // 0\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果无法设置目标对象的原型（比如，目标对象禁止扩展），",(0,t.jsx)(n.code,{children:"Reflect.setPrototypeOf"}),"方法返回",(0,t.jsx)(n.code,{children:"false"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Reflect.setPrototypeOf({}, null)\n// true\nReflect.setPrototypeOf(Object.freeze({}), null)\n// false\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果第一个参数不是对象，",(0,t.jsx)(n.code,{children:"Object.setPrototypeOf"}),"会返回第一个参数本身，而",(0,t.jsx)(n.code,{children:"Reflect.setPrototypeOf"}),"会报错。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Object.setPrototypeOf(1, {})\n// 1\n\nReflect.setPrototypeOf(1, {})\n// TypeError: Reflect.setPrototypeOf called on non-object\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果第一个参数是",(0,t.jsx)(n.code,{children:"undefined"}),"或",(0,t.jsx)(n.code,{children:"null"}),"，",(0,t.jsx)(n.code,{children:"Object.setPrototypeOf"}),"和",(0,t.jsx)(n.code,{children:"Reflect.setPrototypeOf"}),"都会报错。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Object.setPrototypeOf(null, {})\n// TypeError: Object.setPrototypeOf called on null or undefined\n\nReflect.setPrototypeOf(null, {})\n// TypeError: Reflect.setPrototypeOf called on non-object\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reflectapplyfunc-thisarg-args",children:["Reflect.apply(func, thisArg, args)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectapplyfunc-thisarg-args",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.apply"}),"方法等同于",(0,t.jsx)(n.code,{children:"Function.prototype.apply.call(func, thisArg, args)"}),"，用于绑定",(0,t.jsx)(n.code,{children:"this"}),"对象后执行给定函数。"]}),"\n",(0,t.jsxs)(n.p,{children:["一般来说，如果要绑定一个函数的",(0,t.jsx)(n.code,{children:"this"}),"对象，可以这样写",(0,t.jsx)(n.code,{children:"fn.apply(obj, args)"}),"，但是如果函数定义了自己的",(0,t.jsx)(n.code,{children:"apply"}),"方法，就只能写成",(0,t.jsx)(n.code,{children:"Function.prototype.apply.call(fn, obj, args)"}),"，采用",(0,t.jsx)(n.code,{children:"Reflect"}),"对象可以简化这种操作。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const ages = [11, 33, 12, 54, 18, 96];\n\n// 旧写法\nconst youngest = Math.min.apply(Math, ages);\nconst oldest = Math.max.apply(Math, ages);\nconst type = Object.prototype.toString.call(youngest);\n\n// 新写法\nconst youngest = Reflect.apply(Math.min, Math, ages);\nconst oldest = Reflect.apply(Math.max, Math, ages);\nconst type = Reflect.apply(Object.prototype.toString, youngest, []);\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reflectdefinepropertytarget-propertykey-attributes",children:["Reflect.defineProperty(target, propertyKey, attributes)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectdefinepropertytarget-propertykey-attributes",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.defineProperty"}),"方法基本等同于",(0,t.jsx)(n.code,{children:"Object.defineProperty"}),"，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用",(0,t.jsx)(n.code,{children:"Reflect.defineProperty"}),"代替它。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function MyDate() {\n  /*…*/\n}\n\n// 旧写法\nObject.defineProperty(MyDate, 'now', {\n  value: () => Date.now()\n});\n\n// 新写法\nReflect.defineProperty(MyDate, 'now', {\n  value: () => Date.now()\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果",(0,t.jsx)(n.code,{children:"Reflect.defineProperty"}),"的第一个参数不是对象，就会抛出错误，比如",(0,t.jsx)(n.code,{children:"Reflect.defineProperty(1, 'foo')"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["这个方法可以与",(0,t.jsx)(n.code,{children:"Proxy.defineProperty"}),"配合使用。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const p = new Proxy({}, {\n  defineProperty(target, prop, descriptor) {\n    console.log(descriptor);\n    return Reflect.defineProperty(target, prop, descriptor);\n  }\n});\n\np.foo = \'bar\';\n// {value: "bar", writable: true, enumerable: true, configurable: true}\n\np.foo // "bar"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["上面代码中，",(0,t.jsx)(n.code,{children:"Proxy.defineProperty"}),"对属性赋值设置了拦截，然后使用",(0,t.jsx)(n.code,{children:"Reflect.defineProperty"}),"完成了赋值。"]}),"\n",(0,t.jsxs)(n.h3,{id:"reflectgetownpropertydescriptortarget-propertykey",children:["Reflect.getOwnPropertyDescriptor(target, propertyKey)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectgetownpropertydescriptortarget-propertykey",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.getOwnPropertyDescriptor"}),"基本等同于",(0,t.jsx)(n.code,{children:"Object.getOwnPropertyDescriptor"}),"，用于得到指定属性的描述对象，将来会替代掉后者。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var myObject = {};\nObject.defineProperty(myObject, 'hidden', {\n  value: true,\n  enumerable: false,\n});\n\n// 旧写法\nvar theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');\n\n// 新写法\nvar theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden');\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.getOwnPropertyDescriptor"}),"和",(0,t.jsx)(n.code,{children:"Object.getOwnPropertyDescriptor"}),"的一个区别是，如果第一个参数不是对象，",(0,t.jsx)(n.code,{children:"Object.getOwnPropertyDescriptor(1, 'foo')"}),"不报错，返回",(0,t.jsx)(n.code,{children:"undefined"}),"，而",(0,t.jsx)(n.code,{children:"Reflect.getOwnPropertyDescriptor(1, 'foo')"}),"会抛出错误，表示参数非法。"]}),"\n",(0,t.jsxs)(n.h3,{id:"reflectisextensible-target",children:["Reflect.isExtensible (target)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectisextensible-target",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.isExtensible"}),"方法对应",(0,t.jsx)(n.code,{children:"Object.isExtensible"}),"，返回一个布尔值，表示当前对象是否可扩展。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const myObject = {};\n\n// 旧写法\nObject.isExtensible(myObject) // true\n\n// 新写法\nReflect.isExtensible(myObject) // true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果参数不是对象，",(0,t.jsx)(n.code,{children:"Object.isExtensible"}),"会返回",(0,t.jsx)(n.code,{children:"false"}),"，因为非对象本来就是不可扩展的，而",(0,t.jsx)(n.code,{children:"Reflect.isExtensible"}),"会报错。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Object.isExtensible(1) // false\nReflect.isExtensible(1) // 报错\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reflectpreventextensionstarget",children:["Reflect.preventExtensions(target)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectpreventextensionstarget",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.preventExtensions"}),"对应",(0,t.jsx)(n.code,{children:"Object.preventExtensions"}),"方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var myObject = {};\n\n// 旧写法\nObject.preventExtensions(myObject) // Object {}\n\n// 新写法\nReflect.preventExtensions(myObject) // true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果参数不是对象，",(0,t.jsx)(n.code,{children:"Object.preventExtensions"}),"在 ES5 环境报错，在 ES6 环境返回传入的参数，而",(0,t.jsx)(n.code,{children:"Reflect.preventExtensions"}),"会报错。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// ES5 环境\nObject.preventExtensions(1) // 报错\n\n// ES6 环境\nObject.preventExtensions(1) // 1\n\n// 新写法\nReflect.preventExtensions(1) // 报错\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"reflectownkeys-target",children:["Reflect.ownKeys (target)",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reflectownkeys-target",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reflect.ownKeys"}),"方法用于返回对象的所有属性，基本等同于",(0,t.jsx)(n.code,{children:"Object.getOwnPropertyNames"}),"与",(0,t.jsx)(n.code,{children:"Object.getOwnPropertySymbols"}),"之和。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"var myObject = {\n  foo: 1,\n  bar: 2,\n  [Symbol.for('baz')]: 3,\n  [Symbol.for('bing')]: 4,\n};\n\n// 旧写法\nObject.getOwnPropertyNames(myObject)\n// ['foo', 'bar']\n\nObject.getOwnPropertySymbols(myObject)\n//[Symbol(baz), Symbol(bing)]\n\n// 新写法\nReflect.ownKeys(myObject)\n// ['foo', 'bar', Symbol(baz), Symbol(bing)]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["如果",(0,t.jsx)(n.code,{children:"Reflect.ownKeys()"}),"方法的第一个参数不是对象，会报错。"]}),"\n",(0,t.jsxs)(n.h2,{id:"实例使用-proxy-实现观察者模式",children:["实例：使用 Proxy 实现观察者模式",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例使用-proxy-实现观察者模式",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const person = observable({\n  name: '张三',\n  age: 20\n});\n\nfunction print() {\n  console.log(`${person.name}, ${person.age}`)\n}\n\nobserve(print);\nperson.name = '李四';\n// 输出\n// 李四, 20\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上面代码中，数据对象",(0,t.jsx)(n.code,{children:"person"}),"是观察目标，函数",(0,t.jsx)(n.code,{children:"print"}),"是观察者。一旦数据对象发生变化，",(0,t.jsx)(n.code,{children:"print"}),"就会自动执行。"]}),"\n",(0,t.jsxs)(n.p,{children:["下面，使用 Proxy 写一个观察者模式的最简单实现，即实现",(0,t.jsx)(n.code,{children:"observable"}),"和",(0,t.jsx)(n.code,{children:"observe"}),"这两个函数。思路是",(0,t.jsx)(n.code,{children:"observable"}),"函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const queuedObservers = new Set();\n\nconst observe = fn => queuedObservers.add(fn);\nconst observable = obj => new Proxy(obj, {set});\n\nfunction set(target, key, value, receiver) {\n  const result = Reflect.set(target, key, value, receiver);\n  queuedObservers.forEach(observer => observer());\n  return result;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["上面代码中，先定义了一个",(0,t.jsx)(n.code,{children:"Set"}),"集合，所有观察者函数都放进这个集合。然后，",(0,t.jsx)(n.code,{children:"observable"}),"函数返回原始对象的代理，拦截赋值操作。拦截函数",(0,t.jsx)(n.code,{children:"set"}),"之中，会自动执行所有观察者。"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(s,{...e})}):s(e)}let o=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["ECMAScript%206%20%E5%85%A5%E9%97%A8%2F16.Reflect.md"]={toc:[{text:"概述",id:"概述",depth:2},{text:"静态方法",id:"静态方法",depth:2},{text:"Reflect.get(target, name, receiver)",id:"reflectgettarget-name-receiver",depth:3},{text:"Reflect.set(target, name, value, receiver)",id:"reflectsettarget-name-value-receiver",depth:3},{text:"Reflect.has(obj, name)",id:"reflecthasobj-name",depth:3},{text:"Reflect.deleteProperty(obj, name)",id:"reflectdeletepropertyobj-name",depth:3},{text:"Reflect.construct(target, args)",id:"reflectconstructtarget-args",depth:3},{text:"Reflect.getPrototypeOf(obj)",id:"reflectgetprototypeofobj",depth:3},{text:"Reflect.setPrototypeOf(obj, newProto)",id:"reflectsetprototypeofobj-newproto",depth:3},{text:"Reflect.apply(func, thisArg, args)",id:"reflectapplyfunc-thisarg-args",depth:3},{text:"Reflect.defineProperty(target, propertyKey, attributes)",id:"reflectdefinepropertytarget-propertykey-attributes",depth:3},{text:"Reflect.getOwnPropertyDescriptor(target, propertyKey)",id:"reflectgetownpropertydescriptortarget-propertykey",depth:3},{text:"Reflect.isExtensible (target)",id:"reflectisextensible-target",depth:3},{text:"Reflect.preventExtensions(target)",id:"reflectpreventextensionstarget",depth:3},{text:"Reflect.ownKeys (target)",id:"reflectownkeys-target",depth:3},{text:"实例：使用 Proxy 实现观察者模式",id:"实例使用-proxy-实现观察者模式",depth:2}],title:"16.Reflect",headingTitle:"16.Reflect",frontmatter:{}}}}]);