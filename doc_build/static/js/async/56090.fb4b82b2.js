"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56090"],{829372:function(e,n,r){r.r(n),r.d(n,{default:()=>o});var s=r(552676),c=r(740453);let d=r.p+"static/image/956a445fe60da2aa15545bb482df803b.e6504766.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",pre:"pre",blockquote:"blockquote",img:"img",strong:"strong",h3:"h3",ol:"ol",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"11-基础篇对象遍历的不同方法和适用场景",children:["11 基础篇｜对象遍历的不同方法和适用场景",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-基础篇对象遍历的不同方法和适用场景",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["属性和原型链操作是对象操作中最为关键的组成部分，但只有补齐",(0,s.jsx)(n.code,{children:"遍历"}),"这一环才能实现对象的完整访问能力。大家可以这样理解，对象就像一个拥有很多把锁的黑盒，你用相应的钥匙（key）就能打开相应的锁（value），但是你连用哪些钥匙都不知道，那么只能俩眼一抹黑，啥也做不了。"]}),"\n",(0,s.jsxs)(n.p,{children:["单纯依靠暴露出来的属性访问语法和 API，我们是无法遍历对象的，只有引擎的底层才知道对象的结构。前面曾经提到过对象的内部属性中有这么一个 ",(0,s.jsx)(n.code,{children:"[[OwnPropertyKeys]]"}),"，它可理解为一个数组，记录了对象的所有键（key）。"]}),"\n",(0,s.jsxs)(n.p,{children:["对象的遍历实际上是对键的遍历，因此都离不开对 ",(0,s.jsx)(n.code,{children:"[[OwnPropertyKeys]]"})," 的访问，只不过策略有所不同。"]}),"\n",(0,s.jsx)(n.p,{children:"我们把遍历需求分为 4 个层次："}),"\n",(0,s.jsxs)(n.h2,{id:"遍历对象自身的可枚举数据",children:["遍历对象自身的可枚举数据",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历对象自身的可枚举数据",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Object.keys"}),"、",(0,s.jsx)(n.code,{children:"Object.values"})," 和 ",(0,s.jsx)(n.code,{children:"Object.entries"})," 是遍历对象自身属性的常用方法。原型链上的属性不会被纳入最终结果："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const obj = Object.create({\n    // 原型链不会被遍历\n    age: 12\n}, {\n    name: {\n        value: 'foo',\n        enumerable: true,\n    }\n});\n\nObject.keys(obj); // [\"name\"]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这三个函数的筛选逻辑本质上是一致的，都是调用了一个叫做 ",(0,s.jsx)(n.code,{children:"EnumerableOwnProperties()"})," 的内部方法，只不过输出的数据不同，一个是所有的键，一个是所有的值，最后一个是键值。"]}),"\n",(0,s.jsxs)(n.p,{children:["从这个方法的名字上就能看到，它只会遍历到",(0,s.jsx)(n.code,{children:"可枚举"}),"的属性，因此，要想使得某个键不出现在其结果中，可以设置 ",(0,s.jsx)(n.code,{children:"enumerable"})," 为 false："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const obj = Object.create(null, {\n    name: {\n        value: 'foo',\n        enumerable: true,\n    },\n    age: {\n        value: 'foo',\n        // 不可枚举\n        enumerable: false,\n    }\n});\n\nObject.keys(obj); // [\"name\"]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["还有一个特征没有明显体现出来，就是它不会遍历到 ",(0,s.jsx)(n.code,{children:"Symbol"})," 类型的键："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const obj = {\n    name: 'foo',\n    // Symbol 不输出\n    [Symbol('age')]: 16,\n};\n\nObject.keys(obj); // [\"name\"]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["因此，我们可以总结出 ",(0,s.jsx)(n.code,{children:"Object.keys/values/entries 只会遍历出对象自身的、可枚举的、以字符串类型为键的属性"}),"，这三个条件，缺一不可。"]}),"\n",(0,s.jsx)(n.p,{children:"现在我们放松部分条件，希望不可枚举的，以及 Symbol 类型的也会被遍历到，该怎么办呢？"}),"\n",(0,s.jsxs)(n.h2,{id:"遍历对象自身的所有数据",children:["遍历对象自身的所有数据",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历对象自身的所有数据",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["问题归结为遍历对象自身的所有数据，等价于获取 ",(0,s.jsx)(n.code,{children:"[[OwnPropertyKeys]]"})," 的内容。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Object.getOwnPropertyNames"})," 可以用来获取其中的字符串键，",(0,s.jsx)(n.code,{children:"Object.getOwnPropertySymbols"})," 用来获取其中的 ",(0,s.jsx)(n.code,{children:"Symbol"})," 键，把它们合起来，就相当于得到 ",(0,s.jsx)(n.code,{children:"[[OwnPropertyKeys]]"})," 完整内容："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var obj = Object.create(null, {\n    [Symbol('b')]: {\n        value: 'b',\n        writable: false,\n        enumerable: true,\n        configurable: true,\n    },\n    a: {\n        value: 'a',\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n});\nconsole.log([\n    ...Object.getOwnPropertyNames(obj),\n    ...Object.getOwnPropertySymbols(obj),\n]); // [\"a\", Symbol(b)]\n"})}),"\n",(0,s.jsx)(n.p,{children:"至于说为什么这样设计，要把字符串和 Symbol 分开，其实是一个历史问题。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Object.getOwnPropertyNames"})," 是 ES5 引入的，当时还没有 Symbol 类型，因此它只会返回一个字符串数组。ES6 引入 Symbol 之后，如果要求 ",(0,s.jsx)(n.code,{children:"Object.getOwnPropertyNames"})," 也返回 Symbol 类型的话，那么恐怕很多代码都会出错。所以为了向后兼容的考量，又引入了一个 ",(0,s.jsx)(n.code,{children:"Object.getOwnPropertySymbols"})," 专门返回 Symbol 类型的键。"]}),"\n",(0,s.jsxs)(n.p,{children:["但话说回来，ES6 同时又引入了一个 ",(0,s.jsx)(n.code,{children:"Reflect.ownKeys"})," 函数，实打实地返回的就是 ",(0,s.jsx)(n.code,{children:"[[OwnPropertyKeys]]"})," 的完整内容，免去了需要拼接的麻烦："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'console.log(Reflect.ownKeys(obj)); // ["a", Symbol(b)]\n'})}),"\n",(0,s.jsxs)(n.p,{children:["能提供和 ",(0,s.jsx)(n.code,{children:"Reflect.ownKeys"})," 类似效果的还有 ",(0,s.jsx)(n.code,{children:"Object.getOwnPropertyDescriptors"}),"，它提供的也是 ",(0,s.jsx)(n.code,{children:"[[OwnPropertyKeys]]"})," 的全部内容，外加各个键的属性描述符："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// {\n//   a: { value: 'a', writable: true, enumerable: true, configurable: true },\n//   [Symbol(b)]: { value: 'b', writable: false, enumerable: true, configurable: true }\n// }\nconsole.log(Object.getOwnPropertyDescriptors(obj));\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["\uD83D\uDCA1 ",(0,s.jsx)(n.code,{children:"Object.getOwnPropertyDescriptors"})," 是 ",(0,s.jsx)(n.code,{children:"Object.getOwnPropertyDescriptor"})," 的批量版本。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"总体而言，这几个 API 相较于前面的，提供的信息量更加全面。至于使用哪个，很大程度上取决于需求。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"接下来，我们突破对象自有属性的限制，来把原型链也考虑进去。"}),"\n",(0,s.jsxs)(n.h2,{id:"遍历对象及原型链的所有可枚举数据",children:["遍历对象及原型链的所有可枚举数据",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#遍历对象及原型链的所有可枚举数据",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["能够实现遍历原型链的现成方法，目前只有 ",(0,s.jsx)(n.code,{children:"for...in"})," 一种，然而，它一是只能遍历可枚举属性，二是只能遍历字符串键的属性："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var obj = Object.create(\n    Object.create(null, {\n        // 原型链上的属性会被遍历\n        d: {\n            value: 'd',\n            writable: true,\n            enumerable: true,\n            configurable: true,\n        },\n    }), {\n        // Symbol 不会被遍历\n        [Symbol('b')]: {\n            value: 'b',\n            writable: false,\n            enumerable: true,\n            configurable: true,\n        },\n        a: {\n            value: 'a',\n            writable: true,\n            enumerable: true,\n            configurable: true,\n        },\n        // 不可枚举的属性不会被遍历\n        c: {\n            value: 'c',\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    }\n);\n\nfor (let key in obj) {\n    console.log(key); // a d\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如果想把 ",(0,s.jsx)(n.code,{children:"Symbol"})," 包括进来，甚至和那些不可枚举的属性，我们只能自己实现。下面就是一种未经过优化的代码，仅代表其可能性，大家看看能不能读得懂："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function getExtendedKeys(obj) {\n    const visitedKeys = new Set();\n    let current = obj;\n    \n    // 向上遍历原型链\n    while (current) {\n        // 遍历当前属性\n        const keys = Reflect.ownKeys(current);\n        keys.forEach(key => {\n            // 去重\n            if (visitedKeys.has(key)) return;\n            visitedKeys.add(key);\n        });\n\n        current = Object.getPrototypeOf(current);\n    }\n\n    return Array.from(visitedKeys);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"核心原理仍然是原型链遍历和属性遍历。"}),"\n",(0,s.jsxs)(n.p,{children:["可以这样说，上面我们讲到的所有遍历方法，无论是 ",(0,s.jsx)(n.code,{children:"Object.keys/values/entries/getOwnPropertyNames/getOwnPropertySymbols/getOwnPropertyDescriptors"}),"，还是 ",(0,s.jsx)(n.code,{children:"Reflect.ownKeys"}),"，亦或是 ",(0,s.jsx)(n.code,{children:"for...in"}),"，都是基于对象属性的，不可能遍历出属性之外的东西。如果我们想实现遍历数据的动态性，那就必须先把它写入到对象中才行。"]}),"\n",(0,s.jsxs)(n.p,{children:["现在，我们有了更加强大的语法，",(0,s.jsx)(n.code,{children:"for...of"}),"，它真正实现了突破对象属性圈子的能力。"]}),"\n",(0,s.jsxs)(n.h2,{id:"完全自定义遍历数据",children:["完全自定义遍历数据",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#完全自定义遍历数据",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"for...of"})," 不绑定任何对象属性，每次遍历出什么数据，完全是自定义的。从这一点上来说，",(0,s.jsx)(n.code,{children:"for...in"})," 的功能是其子集。在如今的 ECMAScript 规范中，",(0,s.jsx)(n.code,{children:"for...in"})," 依赖的是内部的一种特殊迭代器。而 ",(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"迭代器（iterator）"}),"，正是 ",(0,s.jsx)(n.code,{children:"for...of"})," 工作原理的本质所在"]}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"什么是迭代器",children:["什么是迭代器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#什么是迭代器",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["可以认为迭代器就是一个接口（interface），实现了该接口的对象，就可以被 ",(0,s.jsx)(n.code,{children:"for...of"})," 遍历。"]}),"\n",(0,s.jsx)(n.p,{children:"有多种方式可以实现迭代器。"}),"\n",(0,s.jsx)(n.p,{children:"第一种是利用生成器函数。前面函数那一章我们讲过，生成器函数始终返回一个迭代器对象："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function* range(start, end) {\n    for (let i = start; i <= end; ++i) {\n        yield i;\n    }\n}\n\nfor (const i of range(3, 6)) {\n    console.log(i); // 3 4 5 6\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["简单理解的话，",(0,s.jsx)(n.code,{children:"yield"})," 指令的右侧值就是遍历时每次得到的值。显然这里返回的数据和对象的属性没有任何关系。"]}),"\n",(0,s.jsxs)(n.p,{children:["迭代器也可以不通过 ",(0,s.jsx)(n.code,{children:"for...of"})," 调用，它主要就包含一个 ",(0,s.jsx)(n.code,{children:"next"})," 函数，返回格式是："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n    value?: any;\n    done?: boolean;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["所谓的遍历过程，本质上就是一直调用 ",(0,s.jsx)(n.code,{children:"next"})," 函数，直到 ",(0,s.jsx)(n.code,{children:"done"})," 为 true："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let it = range(3,6), value, done;\n\nwhile(1) {\n    const ret = it.next();\n    done = ret.done;\n    value = ret.value;\n    if (done) break;\n    console.log(value); // 3 4 5 6\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["第二种定义迭代器的方法是第一种的变种，需要使用到前面曾经提到过的 ",(0,s.jsx)(n.code,{children:"Symbol"})," 常量： ",(0,s.jsx)(n.code,{children:"Symbolt.iterator"}),"，定义了这个键的对象，且值为一个生成器，那么该对象就可以被遍历："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class Range {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    *[Symbol.iterator]() {\n        for (let i = this.start; i <= this.end; ++i) {\n            yield i;\n        }\n    }\n}\n\nfor (const i of new Range(3, 6)) {\n    console.log(i); // 3 4 5 6\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["\uD83D\uDCA1 之所以字符串、数组、Map、Set 都可以在 ",(0,s.jsx)(n.code,{children:"for...of"})," 中使用，就是因为它们在原型上都定义了 ",(0,s.jsx)(n.code,{children:"[Symbol.iterator]"})," 属性。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这个特性给了我们自定义遍历数据的很大灵活性，大家可以自己试一试，把前面我们写的那个 ",(0,s.jsx)(n.code,{children:"getExtendedKeys"})," 函数改写为一个迭代器，进而能用 ",(0,s.jsx)(n.code,{children:"for...of"})," 遍历。"]}),"\n",(0,s.jsx)(n.p,{children:"如果你不熟悉或者不喜欢生成器，那么第三种定义迭代器的方法就很适合你："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function createRanger(start, end) {\n    let current = start;\n    return {\n        next() {\n            const nextValue = current++;\n            return {\n                value: nextValue,\n                done: nextValue > end,\n            };\n        },\n        // 返回自身\n        [Symbol.iterator]() {\n            return this;\n        },\n    };\n}\n\nfor (const i of createRanger(3,6)) {\n    console.log(i); // 3 4 5 6\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["本质上它在模拟迭代器的结构。",(0,s.jsx)(n.code,{children:"next"})," 函数遵照协议，必须返回一个 ",(0,s.jsx)(n.code,{children:"{ value, done }"})," 结构的对象，你自己来决定其中的字段值。但这还不够，",(0,s.jsx)(n.code,{children:"for...of"})," 会发现被遍历的对象依旧不是迭代器，这就需要靠 ",(0,s.jsx)(n.code,{children:"[Symbol.iterator]()"})," 函数的返回值了。"]}),"\n",(0,s.jsxs)(n.p,{children:["前面的例子中，生成器函数一定返回迭代器对象，那么在这里，我们就强行返回自身，这样就“骗过”了 ",(0,s.jsx)(n.code,{children:"for...of"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"以上就是三种迭代器的定义方法。比较来说，它们适合不同的场景："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"第一种，生成器函数，适合简单入参的、无额外数据字段的场景；"}),"\n",(0,s.jsx)(n.li,{children:"第二种，对象，适合需要进一步封装额外数据、增加内聚性的场景；"}),"\n",(0,s.jsx)(n.li,{children:"第三种，迭代器模拟，是第二种的变种，适合不想用生成器的场景。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["无论哪一种，当我们遍历的时候，数据都是立即输出的，也就是说它们都是",(0,s.jsx)(n.code,{children:"同步遍历"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"假设有这么一个场景，我们需要遍历一个很大的数据库，不可能一次性把数据全都加载过来，因此需要一边遍历，一边读取，而读取是异步的，怎么办？"}),"\n",(0,s.jsxs)(n.h3,{id:"异步遍历",children:["异步遍历",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步遍历",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"很多人对异步迭代有一定的误解，认为在 for 循环中调用异步过程，就算异步遍历了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"for (const item of datas) {\n    await Promise.resolve(item).then(...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"但事实上这只是同步迭代、异步消费。我们所说的异步遍历，指的是从数据集合中取出的过程就是异步的，不关心消费过程是否异步。用 Promise 来描述异步的话， 大概是这样的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class AsyncProducer {\n    constructor(size) {\n        this.current = size;\n    }\n    async produce() {\n        return this.current--;\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们过去怎么做的呢？",(0,s.jsx)(n.code,{children:"异步递归"}),"，本质上还是 Promise 首尾相连："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const producer = new AsyncProducer(5);\n\nasync function process() {\n    const num = await producer.produce();\n    if (0 === num) {\n        return;\n    }\n\n    console.log(num); // 5 4 3 2 1\n\n    await process();\n}\n\nprocess().finally(() => console.log('all done'));\n"})}),"\n",(0,s.jsxs)(n.p,{children:["但这样的代码阅读起来稍微有一些吃力，现在我们有更好的办法，就是使用异步迭代语法：",(0,s.jsx)(n.code,{children:"for await...of"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"await"})," 字样代表其必须在一个异步函数内部才能运行，而且还与 ",(0,s.jsx)(n.code,{children:"Promise"})," 脱不开干系，是 ",(0,s.jsx)(n.code,{children:"for...of"})," 的超集。",(0,s.jsx)(n.code,{children:"for...of"})," 能用的地方，",(0,s.jsx)(n.code,{children:"for await...of"})," 也能用，比如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"for await (const num of [1, 2, 3]) {\n    console.log(num); // 1 2 3\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["不过两者有一个很大的不同，",(0,s.jsx)(n.code,{children:"for await...of"})," 会把迭代器返回的值用 ",(0,s.jsx)(n.code,{children:"Promise"})," 包裹进去，然后再 ",(0,s.jsx)(n.code,{children:"resolve"})," 出来，因此上面代码中的三次打印动作之间并不是同步的，也正因为多了这两步操作，它要比 ",(0,s.jsx)(n.code,{children:"for...of"})," 慢一点点。"]}),"\n",(0,s.jsxs)(n.p,{children:["所以说，在同步迭代器上，虽然可以，但没有理由使用 ",(0,s.jsx)(n.code,{children:"for await...of"})," 语法。它真正能体现价值的，是",(0,s.jsx)(n.code,{children:"异步迭代器"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["同步迭代器的三种定义方法也适用于异步迭代器，只不过需要把同步的生成器函数改成异步生成器函数，",(0,s.jsx)(n.code,{children:"Symbol.iterator"})," 改成 ",(0,s.jsx)(n.code,{children:"Symbol.asyntIterator"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 第一种，异步生成器函数\nasync function* range(start, end) {\n    for (let i = start; i <= end; ++i) {\n        yield i;\n    }\n}\n\n// 第二种，Symbol.iterator => Symbol.asyncIterator，注意这里虽然同步和异步都能工作，但是只有异步才有实际意义\nclass Range {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    async *[Symbol.asyncIterator]() {\n        for (let i = this.start; i <= this.end; ++i) {\n            yield i;\n        }\n    }\n}\n\n// 第三种，Symbol.iterator => Symbol.asyncIterator，注意，这里的函数必须是同步的\n// 同时 next 返回的是 Promise 格式\nfunction createRanger(start, end) {\n    let current = start;\n    return {\n        next() {\n            const nextValue = current++;\n            return Promise.resolve({\n                value: nextValue,\n                done: nextValue > end,\n            });\n        },\n        // 必须同步返回自身\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["现在我们改写一下上面那个",(0,s.jsx)(n.code,{children:"异步递归"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const producer = {\n    current: 5,\n    // 异步生成器函数\n    async * [Symbol.asyncIterator]() {\n        for(let i = this.current; i > 0;i--) {\n            yield await Promise.resolve(i);\n        }\n    }\n};\n\n// 必须在异步函数内部执行\n(async() => {\n    for await(const num of producer) {\n        console.log(num); // 5 4 3 2 1\n    }\n})();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这么遍历是不是更容易阅读呢？大家用这么一句话理解就行了：",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"异步迭代 = 同步迭代 + Promise"})}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["遍历是对象这样的属性集合的常见操作，除了大家耳熟能详的 ",(0,s.jsx)(n.code,{children:"for...in"})," 之外，还有 ",(0,s.jsx)(n.code,{children:"Object.keys/values/entries/getOwnPropertyNames/getOwnPropertySymbols/getOwnPropertyDescriptors"}),"、",(0,s.jsx)(n.code,{children:"Reflect.ownKeys"}),"、",(0,s.jsx)(n.code,{children:"for...of"}),"、",(0,s.jsx)(n.code,{children:"for await...of"})," 这么多种，本章节一共“遍历”了这 10 种方式。肯定有些同学已经眼花缭乱了，感觉更加迷惑。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以分成两类来看待这 10 个方法，最独特的莫过于 ",(0,s.jsx)(n.code,{children:"for...of"})," 和 ",(0,s.jsx)(n.code,{children:"for await...of"}),"，它们本质上和对象的属性无关，而剩下的 8 种则全部是在对象属性这个范围内工作的。我制作了下面这张表格，来体现它们的异同点："]}),"\n",(0,s.jsxs)(n.table,{children:["\n",(0,s.jsxs)(n.thead,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.th,{children:"遍历方法"}),"\n",(0,s.jsxs)(n.th,{children:["包括自身 ",(0,s.jsx)(n.code,{children:"String"})," 属性"]}),"\n",(0,s.jsxs)(n.th,{children:["包括自身 ",(0,s.jsx)(n.code,{children:"Symbol"})," 属性"]}),"\n",(0,s.jsxs)(n.th,{children:["包括",(0,s.jsx)(n.code,{children:"原型链"}),"属性"]}),"\n",(0,s.jsxs)(n.th,{children:["包括",(0,s.jsx)(n.code,{children:"不可枚举"}),"属性"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.tbody,{children:["\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"for...in"})}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Object.keys/values/entries"})}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Object.getOwnPropertyNames"})}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Object.getOwnPropertySymbols"})}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Object.getOwnPropertyDescriptors"})}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n"]}),"\n",(0,s.jsxs)(n.tr,{children:["\n",(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Reflect.ownKeys"})}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n",(0,s.jsx)(n.td,{children:"❌"}),"\n",(0,s.jsx)(n.td,{children:"✅"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"有两条关键特征需要关注："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["只有 ",(0,s.jsx)(n.code,{children:"for...in"})," 能遍历原型链；"]}),"\n",(0,s.jsxs)(n.li,{children:["带 ",(0,s.jsx)(n.code,{children:"own"})," 字样的都不关心是否可枚举。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["除了遍历范围之外，它们返回的信息量也有不同，比如 ",(0,s.jsx)(n.code,{children:"Object.values/entries/getOwnPropertyDescriptors"}),"，在有些场景可能必须要用到某些 API，特别是 ",(0,s.jsx)(n.code,{children:"Object.getOwnPropertyDescriptors"}),"，它提供的的信息量几乎是最完备的。再加上原型链的相关知识，我们可以实现任意逻辑的遍历操作，当上面这些现成的遍历方法不满足的时候，你就可以自己去实现了。"]}),"\n",(0,s.jsxs)(n.p,{children:["到这里为止，我们在对象上的各种操作基本就都了解完毕了，三要素：",(0,s.jsx)(n.code,{children:"属性"}),"、",(0,s.jsx)(n.code,{children:"原型"}),"和",(0,s.jsx)(n.code,{children:"遍历"}),"，大家要记牢。"]}),"\n",(0,s.jsxs)(n.p,{children:["下一节，我们回过头来看 ES6 以后创建对象的新语法 ",(0,s.jsx)(n.code,{children:"class"}),"，看它到底是如何工作的，以作为对象操作的高级案例来巩固相关知识。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["JavaScript%20%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%2F11%20%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95%E5%92%8C%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF.md"]={toc:[{text:"遍历对象自身的可枚举数据",id:"遍历对象自身的可枚举数据",depth:2},{text:"遍历对象自身的所有数据",id:"遍历对象自身的所有数据",depth:2},{text:"遍历对象及原型链的所有可枚举数据",id:"遍历对象及原型链的所有可枚举数据",depth:2},{text:"完全自定义遍历数据",id:"完全自定义遍历数据",depth:2},{text:"什么是迭代器",id:"什么是迭代器",depth:3},{text:"异步遍历",id:"异步遍历",depth:3},{text:"小结",id:"小结",depth:2}],title:"11 基础篇｜对象遍历的不同方法和适用场景",headingTitle:"11 基础篇｜对象遍历的不同方法和适用场景",frontmatter:{}}}}]);