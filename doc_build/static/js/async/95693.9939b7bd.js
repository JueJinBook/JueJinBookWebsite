"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["95693"],{983462:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var l=r(552676),i=r(740453);function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",ul:"ul",li:"li",blockquote:"blockquote",p:"p",code:"code",strong:"strong",pre:"pre"},(0,i.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{id:"15进阶-2用-makefile-管理-api-项目",children:["15进阶 2：用 Makefile 管理 API 项目",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15进阶-2用-makefile-管理-api-项目",children:"#"})]}),"\n",(0,l.jsxs)(n.h2,{id:"本节核心内容",children:["本节核心内容",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本节核心内容",children:"#"})]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"介绍 Makefile"}),"\n",(0,l.jsx)(n.li,{children:"介绍如何使用 Makefile"}),"\n"]}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsxs)(n.p,{children:["本小节源码下载路径：",(0,l.jsx)(n.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo11",target:"_blank",rel:"noopener noreferrer",children:"demo11"})]}),"\n",(0,l.jsx)(n.p,{children:"可先下载源码到本地，结合源码理解后续内容，边学边练。"}),"\n",(0,l.jsxs)(n.p,{children:["本小节的代码是基于 ",(0,l.jsx)(n.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo10",target:"_blank",rel:"noopener noreferrer",children:"demo10"})," 来开发的。"]}),"\n"]}),"\n",(0,l.jsxs)(n.h2,{id:"为什么需要-makefile",children:["为什么需要 Makefile",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么需要-makefile",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["Go 语言的 ",(0,l.jsx)(n.code,{children:"go"})," 命令自带源码管理功能，比如通过 ",(0,l.jsx)(n.code,{children:"go build"})," 可以实现对源码的编译，但是 Go 自带的源码管理功能在实际项目中还是满足不了需求，有时候执行 ",(0,l.jsx)(n.code,{children:"go build"})," 时，会附带很多编译参数，直接执行 ",(0,l.jsx)(n.code,{children:"go build"})," 命令也会很麻烦。这时候一般是通过更专业的 Makefile 来管理源码，通过 Makefile 可以实现诸如：编译、安装、清理等功能，其实需要的管理功能都可以通过 Makefile 来添加，Makefile 生来就是做这些的。"]}),"\n",(0,l.jsxs)(n.h2,{id:"makefile-简介",children:["Makefile 简介",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#makefile-简介",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令（摘自百度百科）。"}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"makefile 的规则"})}),"\n",(0,l.jsx)(n.p,{children:"Makefile 基本格式如下:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-makefile",children:"target ... : prerequisites ...\r\n    command\r\n    ...\n"})}),"\n",(0,l.jsx)(n.p,{children:"其中："}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"target        - 编译文件要生成的目标"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"prerequisites - 编译文件需要的依赖"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"command       - 依赖生成目标所需要执行的命令（任意的 shell 命令），Makefile 中的命令必须以 [tab] 开头"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["比如我们平时使用的 ",(0,l.jsx)(n.code,{children:"gcc a.c b.c -o test"})," 这里的 test 就是我们要生成的目标， a.c、b.c就是我们生成目标需要的依赖，而 ",(0,l.jsx)(n.code,{children:"gcc a.c b.c -o test"})," 则是命令。将这行命令用 Makefile 的方式来写就是："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-makefile",children:"test: a.c b.c\r\n    gcc a.c b.c -o test\n"})}),"\n",(0,l.jsxs)(n.h2,{id:"api-server-添加-makefile",children:["API Server 添加 Makefile",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#api-server-添加-makefile",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["在 apiserver 根目录下新建文件 ",(0,l.jsx)(n.code,{children:"Makefile"}),"，内容为："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-makefile",children:'all: gotool\r\n	@go build -v .\r\nclean:\r\n	rm -f apiserver\r\n	find . -name "[._]*.s[a-w][a-z]" | xargs -i rm -f {}\r\ngotool:\r\n	gofmt -w .\r\n	go tool vet . |& grep -v vendor;true\r\nca:\r\n	openssl req -new -nodes -x509 -out conf/server.crt -keyout conf/server.key -days 3650 -subj "/C=DE/ST=NRW/L=Earth/O=Random Company/OU=IT/CN=127.0.0.1/emailAddress=xxxxx@qq.com"\r\n\r\nhelp:\r\n	@echo "make - compile the source code"\r\n	@echo "make clean - remove binary file and vim swp files"\r\n	@echo "make gotool - run go tool \'fmt\' and \'vet\'"\r\n	@echo "make ca - generate ca files"\r\n\r\n.PHONY: clean gotool ca help\n'})}),"\n",(0,l.jsxs)(n.p,{children:["上面的 Makefile 文件中，",(0,l.jsx)(n.code,{children:".PHONY"})," 是个伪目标，形式上是一个目标，但是不需要依赖，伪目标一般只是为了执行目标下面的命令（比如 clean 就是伪目标）。",(0,l.jsx)(n.code,{children:"@"})," 放在行首，表示不打印此行。默认在编译的过程中，会把此行的展开效果字符串打印出来。"]}),"\n",(0,l.jsx)(n.p,{children:"上面的 Makefile 实现了如下功能："}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"make"}),"：执行 ",(0,l.jsx)(n.code,{children:"go build -v ."})," 生成 Go 二进制文件"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"make gotool"}),"：执行 ",(0,l.jsx)(n.code,{children:"gofmt -w ."})," 和 ",(0,l.jsx)(n.code,{children:"go tool vet ."}),"（格式化代码和源码静态检查）"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"make clean"}),"：做一些清理工作：删除二进制文件、删除 vim swp 文件"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"make ca"}),"：生成证书"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"make help"}),"：打印 help 信息"]}),"\n"]}),"\n",(0,l.jsxs)(n.h2,{id:"编译",children:["编译",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译",children:"#"})]}),"\n",(0,l.jsxs)(n.p,{children:["在前面各小节中编译二进制均是通过 ",(0,l.jsx)(n.code,{children:"go build -v ."})," 的方式，添加 Makefile 后可以通过如下方式来编译："]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"$ make\n"})}),"\n",(0,l.jsxs)(n.h2,{id:"小结",children:["小结",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,l.jsx)(n.p,{children:"本小节简单介绍了 Makefile，并介绍了 apiserver 所使用的 Makefile 文件，通过该小节，展示了如何通过 Makefile 来管理和编译 API 源码。"}),"\n",(0,l.jsxs)(n.p,{children:["本小册不是专门介绍 Makefile 的，想要了解更多 Makefile 知识，请参考 ",(0,l.jsx)(n.a,{href:"https://www.cnblogs.com/wang_yb/p/3990952.html",target:"_blank",rel:"noopener noreferrer",children:"Makefile使用总结"}),"。"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(a,{...e})}):a(e)}let c=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Go%20%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84%20RESTful%20API%20%E6%9C%8D%E5%8A%A1%2F15%E8%BF%9B%E9%98%B6%202%EF%BC%9A%E7%94%A8%20Makefile%20%E7%AE%A1%E7%90%86%20API%20%E9%A1%B9%E7%9B%AE.md"]={toc:[{text:"本节核心内容",id:"本节核心内容",depth:2},{text:"为什么需要 Makefile",id:"为什么需要-makefile",depth:2},{text:"Makefile 简介",id:"makefile-简介",depth:2},{text:"API Server 添加 Makefile",id:"api-server-添加-makefile",depth:2},{text:"编译",id:"编译",depth:2},{text:"小结",id:"小结",depth:2}],title:"15进阶 2：用 Makefile 管理 API 项目",headingTitle:"15进阶 2：用 Makefile 管理 API 项目",frontmatter:{}}}}]);