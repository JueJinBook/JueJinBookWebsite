"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56100"],{28489:function(e,n,r){e.exports=r.p+"static/image/19c1fec5c80f18f3a945b7a145445566.cd562fd0.webp"},643895:function(e,n,r){e.exports=r.p+"static/image/4e228820d57cc0be9ed05536615c16a3.c021cae3.webp"},592125:function(e,n,r){e.exports=r.p+"static/image/79c4a1bbfefc79047cfd2d733a237935.575297ff.webp"},983691:function(e,n,r){r.r(n),r.d(n,{default:()=>B});var s=r(552676),t=r(740453);let i=r.p+"static/image/bc04b109a86ddd28a5ec6ebf2d2c0d57.7f70c497.webp",a=r.p+"static/image/451ebfdc3ff1bb1e1110cfa74d625408.a3de8f9a.webp",c=r.p+"static/image/aea7a7c67261b8ba3b58bc2913e8d1ff.5d25f027.webp",p=r.p+"static/image/74fc117ca7d7649f51f8f276d9e74e03.0cf675c5.webp",d=r.p+"static/image/fa2acfa98b90fc4e782801fa3a590a48.ff8d7cdf.webp",l=r.p+"static/image/75dba437236c7d71f6029bf835d98eeb.f8e6e6b4.webp",o=r.p+"static/image/16edc5df320f5d817ff2d188644f73ca.6743beef.webp",m=r.p+"static/image/8d8acc21e75c8ce7151ee441022fc18c.e7468f77.webp",j=r.p+"static/image/ae70a21232de16903133ae5216972b6f.e55274d2.webp",x=r.p+"static/image/84b3de4bd292224e4d884a20ff31ca2b.410b0ab8.webp",h=r.p+"static/image/0c6a1ab60194bccffd798387669bf0f9.aef15159.webp",f=r.p+"static/image/aec384ce387f3b7f341c6e09b4f072a1.a60d9477.webp",g=r.p+"static/image/38d74f8362a0da405d869768a70ffb58.d6ca9675.webp",b=r.p+"static/image/993099bd21b0d7223637cea8360d70fd.63308450.webp",y=r.p+"static/image/f5ccd2239b796efbe3552b35d9a75305.20d8187a.webp",u=r.p+"static/image/ca12854c68da05d6c53fd9cdb11817fc.4e1fbf4b.webp",M=r.p+"static/image/48c1e540ce95eb632177881f9e1182c2.619ebf12.webp",E=r.p+"static/image/923afffb39842ce937b0beaf90dd15ff.3f7790c5.webp",R=r.p+"static/image/04d23b7dab0328486fdf53ccf458168a.6cc3ecb1.webp",w=r.p+"static/image/8b3c8ee5eb92226bad8c7a6ba51040d7.e267fce1.webp",U=r.p+"static/image/de934ecde74dca11b36a9fe99588f7f0.3523310d.webp",O=r.p+"static/image/68e0e908087f8a33ce58b0fb5a7971dc.0d94d8f7.webp",T=r.p+"static/image/1ad8035839ef13fb2d07bbf256c4a0fd.28d2cdab.webp",v=r.p+"static/image/4923114bcf3e66c47a2fd57d3ba3bfe0.9cb411c1.webp",S=r.p+"static/image/be9dc971d4537195b09873ba9ed47a8a.d95429f1.webp",N=r.p+"static/image/5549887d6265009f5465b3599865f506.e2121fd7.webp",D=r.p+"static/image/8f2427881c79b4a8d7e958338941363c.582554b4.webp";var C=r(28489),_=r(592125);let A=r.p+"static/image/6946534a24ab049525e2ec5158ea1860.4f508b88.webp",q=r.p+"static/image/d97da45e9955f11d81433b0df2007416.b121488e.webp",F=r.p+"static/image/a188ce83fccb0378e004e1d8a3234f4d.b0d100f5.webp",P=r.p+"static/image/c61c3498143cf8b3db2933e0f12bade1.3ea98eb8.webp";var k=r(643895);function G(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"58-在-nest-里集成-typeorm",children:["58. 在 Nest 里集成 TypeORM",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#58-在-nest-里集成-typeorm",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"TypeORM 怎么用我们已经学会了，在 Nest 里用那不就是再封装一层的事情么？"}),"\n",(0,s.jsx)(n.p,{children:"那怎么封装呢？"}),"\n",(0,s.jsx)(n.p,{children:"先回忆下 TypeORM 的流程："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"DataSource 里存放着数据库连接的配置，比如用户名、密码、驱动包、连接池配置等等。"}),"\n",(0,s.jsx)(n.p,{children:"而 Entity 里通过 @Entity、@PrimaryGeneratedColumn、@Column 等装饰器来建立数据库表的映射关系。"}),"\n",(0,s.jsx)(n.p,{children:"同时还有 Entity 之间的 @OneToOne、@OneToMany、@ManyToMany 的关系，这些会映射成数据库表通过外键、中间表来建立的关系。"}),"\n",(0,s.jsx)(n.p,{children:"DataSource.initialize 的时候，会和数据库服务建立连接，如果配置了 synchronize，还会生成建表 sql 语句来创建表。"}),"\n",(0,s.jsx)(n.p,{children:"DataSource 初始化之后就可以拿到 EntityManager 了，由它负责对各种 Entity 进行增删改查，比如 find、delete、save 等方法，还可以通过 query builder 来创建复杂的查询。"}),"\n",(0,s.jsx)(n.p,{children:"如果你只是想做对单个 Entity 的 CRUD，那可以拿到这个 Entity 的 Repository 类，它同样有上面的那些方法，只是只能用来操作单个 Entity。"}),"\n",(0,s.jsx)(n.p,{children:"这就是 TypeORM 的流程。"}),"\n",(0,s.jsx)(n.p,{children:"那如果让你把 TypeORM 的 api 封装一层，做成一个 TypeOrmModule，你会怎么封装呢？"}),"\n",(0,s.jsx)(n.p,{children:"很明显，这里的 datasource 的配置是需要手动传入的，也就是说需要做成动态模块，支持根据传入的配置来动态产生模块内容。"}),"\n",(0,s.jsx)(n.p,{children:"而动态模块的规范里就 3 种方法名： register、forRoot、forFeature。"}),"\n",(0,s.jsx)(n.p,{children:"这里很明显要用 forRoot，也就是只需要注册一次，然后这个模块会在各处被使用。"}),"\n",(0,s.jsx)(n.p,{children:"类似这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from 'xxx';\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'mysql',\n      host: 'localhost',\n      port: 3306,\n      username: 'root',\n      password: 'root',\n      database: 'test',\n      entities: [],\n      synchronize: true,\n    }),\n  ],\n})\nexport class AppModule {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后内部就根据传入的配置来创建 DataSource，调用 intialize 方法，之后就拿到 EntityManager，可以做 CRUD 了。"}),"\n",(0,s.jsx)(n.p,{children:"但是 Entity 肯定会分散在各个业务模块，每个模块都通过 forRoot 引入那个模块太麻烦，我们干脆把它用 @Global 声明成全局的。"}),"\n",(0,s.jsx)(n.p,{children:"这样每个模块里就都可以注入 EntityManager 来用了，不需要 imports。"}),"\n",(0,s.jsx)(n.p,{children:"那如果我想用 Repository 的方式来 CRUD 呢？"}),"\n",(0,s.jsx)(n.p,{children:"那可以先注入 EntityManager，然后再通过 EntityManager.getRepository(XxxEntity) 来拿呀。"}),"\n",(0,s.jsx)(n.p,{children:"或者可以再做一个动态模块，传入 Entity，返回它的 Repository。"}),"\n",(0,s.jsx)(n.p,{children:"这种局部的动态模块，一般都是用 forFeature 的名字："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from 'xxxx';\nimport { UsersService } from './users.service';\nimport { User } from './user.entity';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  providers: [UsersService],\n  controllers: [],\n})\nexport class UsersModule {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"比如传入 User，内部通过 EntityManager.getRepository(User) 来拿到 UserEntity。"}),"\n",(0,s.jsx)(n.p,{children:"这样 UserService 里就可以通过 UserRepository 来实现增删改查了。"}),"\n",(0,s.jsx)(n.p,{children:"这个封装思路貌似挺完美。"}),"\n",(0,s.jsx)(n.p,{children:"那我们来看看 @nestjs/typeorm 是怎么封装的吧。"}),"\n",(0,s.jsx)(n.p,{children:"创建个 Nest 项目："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"nest new nest-typeorm -p npm\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后创建一个 crud 的模块："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"nest g resource user\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:F,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"生成的 service 里的 crud 并没有真正实现："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:q,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"我们引入 typeorm 来实现下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install --save @nestjs/typeorm typeorm mysql2\n"})}),"\n",(0,s.jsx)(n.p,{children:"typeorm、mysql2 的包我们很熟悉了，而 @nestjs/typeorm 就是把 typeorm api 封装了一层的包。"}),"\n",(0,s.jsx)(n.p,{children:"它提供了一个模块，我们在入口引入下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"连接配置和前几节一样，引入 User 的 Entity。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { User } from './user/entities/user.entity';\nimport { UserModule } from './user/user.module';\n\n@Module({\n  imports: [UserModule, \n    TypeOrmModule.forRoot({\n      type: \"mysql\",\n      host: \"localhost\",\n      port: 3306,\n      username: \"root\",\n      password: \"guang\",\n      database: \"typeorm_test\",\n      synchronize: true,\n      logging: true,\n      entities: [User],\n      poolSize: 10,\n      connectorPackage: 'mysql2',\n      extra: {\n          authPlugin: 'sha256_password',\n      }\n    }),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后在 User 的 Entity 里加一些映射的信息："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Column, Entity, PrimaryGeneratedColumn } from \"typeorm\";\n\n@Entity({\n    name: 'aaa_user'\n})\nexport class User {\n\n    @PrimaryGeneratedColumn()\n    id: number;\n\n\n    @Column({\n        name: 'aaa_name',\n        length: 50\n    })\n    name: string;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"给映射的表给个名字叫 aaa_user，然后有两个字段，分别是 id 和 name。"}),"\n",(0,s.jsx)(n.p,{children:"我们跑一下试试："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm run start:dev\n"})}),"\n",(0,s.jsx)(n.p,{children:"看到建表 sql 了没："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这部分和我们单独跑 typeorm 没啥区别："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后是增删改查，我们可以注入 EntityManager："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"用它来做增删改查："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Injectable } from '@nestjs/common';\nimport { InjectEntityManager } from '@nestjs/typeorm';\nimport { EntityManager } from 'typeorm';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { User } from './entities/user.entity';\n\n@Injectable()\nexport class UserService {\n  \n  @InjectEntityManager()\n  private manager: EntityManager;\n\n  create(createUserDto: CreateUserDto) {\n    this.manager.save(User, createUserDto);\n  }\n\n  findAll() {\n    return this.manager.find(User)\n  }\n\n  findOne(id: number) {\n    return this.manager.findOne(User, {\n      where: { id }\n    })\n  }\n\n  update(id: number, updateUserDto: UpdateUserDto) {\n    this.manager.save(User, {\n      id: id,\n      ...updateUserDto\n    })\n  }\n\n  remove(id: number) {\n    this.manager.delete(User, id);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里的 save、findOne、delete 方法我们都用过。"}),"\n",(0,s.jsx)(n.p,{children:"然后我们用 postman 来试一下："}),"\n",(0,s.jsx)(n.p,{children:"发个 post 请求，带上要添加的数据："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"服务端打印了 insert 的 sql 语句："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"表里也可以看到这条数据了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"对应的是这个 handler："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后再试下查询："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:U,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"单个查询和全部查询都是可以的。"}),"\n",(0,s.jsx)(n.p,{children:"再就是修改："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在 controller 里是接受 patch 的请求。"}),"\n",(0,s.jsxs)(n.p,{children:["在 postman 里发一下：\n",(0,s.jsx)("img",{src:E,alt:""})]}),"\n",(0,s.jsx)(n.p,{children:"可以看到生成了 update 的 sql 语句："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"数据库中的数据也被修改了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"再试试删除："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在 postman 里发送 delete 的请求："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到生成了 delete 的 sql 语句："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"数据库里的数据确实被删除了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"至此，我们就正式打通了从请求到数据库的整个流程！"}),"\n",(0,s.jsx)(n.p,{children:"这里的 CRUD 部分用到的 api 我们都用过好多遍了。"}),"\n",(0,s.jsx)(n.p,{children:"只不过现在是通过 TypeOrm.forRoot 来传入的数据源的配置，通过 @InjectEntityManager 来注入的 entityManager 对象。"}),"\n",(0,s.jsx)(n.p,{children:"直接用 EntityManager 的缺点是每个 api 都要带上对应的 Entity："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"简便方法就是先 getRepository(User) 拿到 user 对应的 Repository 对象，再调用这些方法。"}),"\n",(0,s.jsx)(n.p,{children:"比如这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"那还不如直接注入 User 对应的 Respository 就好了。"}),"\n",(0,s.jsx)(n.p,{children:"Nest 对这个做了封装，在 user 模块引入 TypeOrmModule.forFeature 对应的动态模块，传入 User 的 Entity："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"就可以在模块里注入 Repository 了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"它有的方法和 EntityManager 一样，只是只能用来操作当前 Entity。"}),"\n",(0,s.jsx)(n.p,{children:"此外，你还可以注入 DataSource："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"不过这个不常用。"}),"\n",(0,s.jsx)(n.p,{children:"这就是 Nest 里集成 TypeOrm 的方式。"}),"\n",(0,s.jsx)(n.p,{children:"有了 TypeOrm 的使用基础之后，学起来还是非常简单的。"}),"\n",(0,s.jsx)(n.p,{children:"那它是怎么实现的呢？"}),"\n",(0,s.jsx)(n.p,{children:"我们来看下源码："}),"\n",(0,s.jsx)(n.p,{children:"首先，我们通过引入 TypeOrmModule.forRoot 的动态模块的时候："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"它会引入 TypeOrmCoreModule.forRoot 的动态模块："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这里面根据 options 创建 DataSource 和 EntityManager 放到模块的 provider 里，并放到了 exports 里。"}),"\n",(0,s.jsx)(n.p,{children:"而且，更重要的是这个模块是 @Global 的全局模块。"}),"\n",(0,s.jsx)(n.p,{children:"因此，dataSource 和 entityManager 就可以在任意的地方注入了。"}),"\n",(0,s.jsx)(n.p,{children:"上面那两个方法里，创建 DataSource 的过程就是传入参数，调用 intialize 方法："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而创建 entityManager，则是注入 dataSource 取 manager 属性就好了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"然后 TypeOrmModule.forFeature 则是通过全局的 dataSource.getRepository 拿到参数对应的 Repository 对象，作为模块内的 provider。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样引入这个动态模块的模块内就可以注入这些 Entity 对应的 Repository 了。"}),"\n",(0,s.jsx)(n.p,{children:"这就是 @nestjs/typeorm 的 TypeOrmModule.forRoot 和 TypeOrmModule.forFeature 的实现原理。"}),"\n",(0,s.jsxs)(n.p,{children:["案例代码在",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-typeorm",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们会了用 TypeOrm 来连接和增删改查数据库表，在 Nest 里集成只是对 TyprOrm 的 api 封装了一层。"}),"\n",(0,s.jsx)(n.p,{children:"使用方式是在根模块 TypeOrmModule.forRoot 传入数据源配置。"}),"\n",(0,s.jsx)(n.p,{children:"然后就可以在各处注入 DataSource、EntityManager 来做增删改查了。"}),"\n",(0,s.jsx)(n.p,{children:"如果想用 Repository 来简化操作，还可以在用到的模块引入 TypeOrmModule.forFeature 的动态模块，传入 Entity，会返回对应的 Repository。"}),"\n",(0,s.jsx)(n.p,{children:"这样就可以在模块内注入该 Repository 来用了。"}),"\n",(0,s.jsx)(n.p,{children:"它的原理是 TypeOrmModule.forRoot 对应的动态模块是全局的，导出了 dataSource、entityManager，所以才可以到处注入。"}),"\n",(0,s.jsx)(n.p,{children:"而 TypeOrmModule.forFeature 则会根据吧传入 Entity 对应的 Repository 导出，这样就可以在模块内注入了。"}),"\n",(0,s.jsx)(n.p,{children:"这就是 Nest 里集成 TypeOrm 的方式和实现原理。"}),"\n",(0,s.jsx)(n.p,{children:"至此，我们就可以打通从请求到数据库的流程了。"})]})}function z(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(G,{...e})}):G(e)}let B=z;z.__RSPRESS_PAGE_META={},z.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F58.%20%E5%9C%A8%20Nest%20%E9%87%8C%E9%9B%86%E6%88%90%20TypeORM.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"58. 在 Nest 里集成 TypeORM",headingTitle:"58. 在 Nest 里集成 TypeORM",frontmatter:{}}}}]);