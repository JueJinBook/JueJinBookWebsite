"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["77626"],{89431:function(e,n,s){s.r(n),s.d(n,{default:()=>r});var t=s(552676),l=s(740453);let o=s.p+"static/image/8733285dc1f9c2e79f8cbb8a914e56b9.d975d90a.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",strong:"strong",img:"img",blockquote:"blockquote"},(0,l.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"21特殊元素指令slot-插槽元素是如何实现的",children:["21.特殊元素&指令：slot 插槽元素是如何实现的？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21特殊元素指令slot-插槽元素是如何实现的",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Vue"})," 提供了一个 ",(0,t.jsx)(n.code,{children:"<slot>"})," 插槽的内置特殊元素，用来实现为子组件传递一些模板片段，然后由子组件完成对这些模版的渲染工作。一个简单的例子，这里有一个父组件，写入了一段插槽模版内容："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<ChildComponent>\n  \x3c!-- 插槽内容 --\x3e\n  hello world\n</ChildComponent>\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在子组件 ",(0,t.jsx)(n.code,{children:"<ChildComponent>"})," 中则通过 ",(0,t.jsx)(n.code,{children:"<slot>"})," 元素来实现对插槽内容的出口渲染："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<div>\n  \x3c!-- 插槽出口 --\x3e\n  <slot></slot>\n</div>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"<slot>"}),"\xa0元素是一个",(0,t.jsx)(n.strong,{children:"插槽出口"}),"\xa0(slot outlet)，标示了父元素提供的",(0,t.jsx)(n.strong,{children:"插槽内容"}),"\xa0(slot content) 将在哪里被渲染。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"接下来，我们将一起探索，插槽内容是如何被渲染到指定出口的。"}),"\n",(0,t.jsxs)(n.h2,{id:"插槽内容渲染",children:["插槽内容渲染",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插槽内容渲染",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["一个组件如果携带一些插槽内容，那么这个组件在渲染的时候，会有哪些变化。先来看一个较为常规的 ",(0,t.jsx)(n.code,{children:"<slot>"})," 插槽内容用法："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<ChildComponent>\n  <template #header>header</template>\n  <template #content>content</template>\n  <template #footer>footer</template>\n</ChildComponent>\n"})}),"\n",(0,t.jsx)(n.p,{children:"经过编译器转换后，生成的渲染函数如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import { createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from "vue"\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_ChildComponent = _resolveComponent("ChildComponent")\n\n  return (_openBlock(), _createBlock(_component_ChildComponent, null, {\n    header: _withCtx(() => [\n      _createTextVNode("header")\n    ]),\n    content: _withCtx(() => [\n      _createTextVNode("content")\n    ]),\n    footer: _withCtx(() => [\n      _createTextVNode("footer")\n    ]),\n    _: 1 /* STABLE */\n  }))\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["可以看到，",(0,t.jsx)(n.code,{children:"createBlock"})," 的第三个参数 ",(0,t.jsx)(n.code,{children:"children"})," 相对于普通父子节点来说，由一个数组变成一个对象的形式，这个对象包含了以插槽内容名称命名的函数，以及一个 ",(0,t.jsx)(n.code,{children:"_"})," 属性，这个属性的含义是 ",(0,t.jsx)(n.code,{children:"slotFlag"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["下面我们再详细看一下 ",(0,t.jsx)(n.code,{children:"createBlock"})," 这个函数的实现，前面的章节中，我们提到 ",(0,t.jsx)(n.code,{children:"createBlock"})," 函数本质就是调用了 ",(0,t.jsx)(n.code,{children:"createVNode"})," 函数创建 ",(0,t.jsx)(n.code,{children:"vnode"})," 节点，不过会增加一些和编译时优化相关的属性 ",(0,t.jsx)(n.code,{children:"dynamicChildren"})," 罢了。那么核心看一下在创建 ",(0,t.jsx)(n.code,{children:"vnode"})," 的时候产生的一些变化："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"function _createVNode(type, props, children, patchFlag, dynamicProps = null, isBlockNode = false) {\n  // ...\n  if (isVNode(type)) {\n    // clone vnode\n    const cloned = cloneVNode(type, props, true /* mergeRef: true */)\n    if (children) {\n      // 标准化子节点\n      normalizeChildren(cloned, children)\n    }\n    return cloned\n  }\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"createVNode"})," 函数在执行的时候，针对 ",(0,t.jsx)(n.code,{children:"vnode"})," 节点如果存在子节点的话，会调用 ",(0,t.jsx)(n.code,{children:"normalizeChildren"})," 函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export function normalizeChildren(vnode, children) {\n  let type = 0\n  const { shapeFlag } = vnode\n  if (children == null) {\n    children = null\n  } else if (isArray(children)) {\n    //  子节点是数组的情况\n    type = ShapeFlags.ARRAY_CHILDREN\n  } else if (typeof children === 'object') {\n    // 针对 children 是对象的处理内容\n    // 对于 ELEMENT 或者 TELEPORT slot 的处理\n    if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.TELEPORT)) {\n      const slot = (children as any).default\n      if (slot) {\n        slot._c && (slot._d = false)\n        normalizeChildren(vnode, slot())\n        slot._c && (slot._d = true)\n      }\n      return\n    } else {\n      // 标记子节点类型为 SLOTS_CHILDREN\n      type = ShapeFlags.SLOTS_CHILDREN\n      const slotFlag = (children as RawSlots)._\n      if (!slotFlag && !(InternalObjectKey in children!)) {\n        // 如果 slots 还没有被标准化，添加上下文实例\n        ;(children as RawSlots)._ctx = currentRenderingInstance\n      } else if (slotFlag === SlotFlags.FORWARDED && currentRenderingInstance) {\n        // 处理 slotFlag 为 FORWARDED 的情况\n        // 处理 STABLE slot\n        if (\n          (currentRenderingInstance.slots as RawSlots)._ === SlotFlags.STABLE\n        ) {\n          ;(children as RawSlots)._ = SlotFlags.STABLE\n        } else {\n          // 添加 DYNAMIC slot\n          ;(children as RawSlots)._ = SlotFlags.DYNAMIC\n          vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        }\n      }\n    }\n  }\n  // ...\n  vnode.children = children\n  vnode.shapeFlag |= type\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里我们只需要关注，如果传入的子节点类型是个 ",(0,t.jsx)(n.code,{children:"Object"})," 的情况下，会为 ",(0,t.jsx)(n.code,{children:"vnode.shapeFlag"})," 属性添加 ",(0,t.jsx)(n.code,{children:"SLOTS_CHILDREN"})," 类型。那这个 ",(0,t.jsx)(n.code,{children:"shapeFlag"})," 在哪里会被用到了？再回到我们之前的组件挂载过程中的 ",(0,t.jsx)(n.code,{children:"setupComponent"})," 函数中："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export function setupComponent(instance) {\n  // 1. 处理 props\n  // 取出存在 vnode 里面的 props\n  const { props, children } = instance.vnode;\n  initProps(instance, props);\n  // 2. 处理 slots\n  initSlots(instance, children);\n\n  // 3. 调用 setup 并处理 setupResult\n  setupStatefulComponent(instance);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这里我们重点看一下是如何处理 ",(0,t.jsx)(n.code,{children:"slots"})," 的："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export const initSlots = (instance, children) => {\n  // shapeFlag 有 SLOTS_CHILDREN 类型\n  if (instance.vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\n    // 对于我们的示例中，slotFlag 类型是 STABLE\n    const type = (children as RawSlots)._\n    if (type) {\n      // 用户可以使用 this.$slots 来获取 slots 对象的浅拷贝内部实例上的 slots\n      // 所以这里应该避免 proxy 对象污染\n      // 为 instance slots 属性赋值 children\n      instance.slots = toRaw(children)\n      // 标记不可枚举\n      def(children, '_', type)\n    }\n    // ...\n  } else {\n    instance.slots = {}\n    // ...\n  }\n  def(instance.slots, InternalObjectKey, 1)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["针对我们上面的示例，首先 ",(0,t.jsx)(n.code,{children:"slots"})," 渲染的 ",(0,t.jsx)(n.code,{children:"slotFlag"})," 类型为 ",(0,t.jsx)(n.code,{children:"STABLE"}),"，所以这里的 ",(0,t.jsx)(n.code,{children:"initSlot"})," 所做的操作就是为 ",(0,t.jsx)(n.code,{children:"instance.slots"})," 赋值为 ",(0,t.jsx)(n.code,{children:"toRaw(children)"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["到这里，我们可以认为，对于一个组件中如果包含 ",(0,t.jsx)(n.code,{children:"slot"})," 内容，那么这个组件实例在被渲染的时候，这些内容将会被添加到当前组件实例的 ",(0,t.jsx)(n.code,{children:"instance.slots"})," 属性上："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'// ChildComponent 组件实例\n{\n  type: {\n    name: "ChildComponent",\n    render: render(_ctx, _cache) { ... },\n    // ...\n  },\n  slots: {\n    header: _withCtx(() => [\n      _createTextVNode("header")\n    ]),\n    content: _withCtx(() => [\n      _createTextVNode("content")\n    ]),\n    footer: _withCtx(() => [\n      _createTextVNode("footer")\n    ]),\n  },\n  vnode: {...}\n  // ...\n}\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["注意，",(0,t.jsx)(n.code,{children:"slots"})," 是被挂载到了子组件实例 ",(0,t.jsx)(n.code,{children:"ChildComponent"})," 中，而非父组件中。"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"插槽出口渲染",children:["插槽出口渲染",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#插槽出口渲染",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"插槽除了有内容外，还需要制定对象的出口，我们再一起看一下上述示例中对应的出口内容："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<div>\n  <slot name="header"></slot>\n  <slot name="content"></slot>\n  <slot name="footer"></slot>\n</div>\n'})}),"\n",(0,t.jsx)(n.p,{children:"上面的模版会被编译器编译成如下渲染函数："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import { renderSlot as _renderSlot, openBlock as _openBlock, createElementBlock as _createElementBlock } from "vue"\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return (_openBlock(), _createElementBlock("div", null, [\n    _renderSlot(_ctx.$slots, "header"),\n    _renderSlot(_ctx.$slots, "content"),\n    _renderSlot(_ctx.$slots, "footer")\n  ]))\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["可以看到，带有 ",(0,t.jsx)(n.code,{children:"<slot>"})," 内容的元素，会被 ",(0,t.jsx)(n.code,{children:"renderSlot"})," 函数进行包裹，一起来看一下这个函数的实现："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export function renderSlot(slots, name, props, fallback, noSlotted) {\n  // ...\n  // 根据 name 获取 slot 内容\n  let slot = slots[name]\n  openBlock()\n  const validSlotContent = slot && ensureValidVNode(slot(props))\n  // 创建 slot vnode\n  const rendered = createBlock(\n    Fragment,\n    {\n      key:\n        props.key ||\n        (validSlotContent && (validSlotContent as any).key) ||\n        `_${name}`\n    },\n    validSlotContent || (fallback ? fallback() : []),\n    validSlotContent && (slots as RawSlots)._ === SlotFlags.STABLE\n      ? PatchFlags.STABLE_FRAGMENT\n      : PatchFlags.BAIL\n  )\n  // ...\n  // 返回 slot vnode\n  return rendered\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["可以看到，",(0,t.jsx)(n.code,{children:"renderSlot"})," 函数核心功能就是根据 ",(0,t.jsx)(n.code,{children:"slot"})," 的 ",(0,t.jsx)(n.code,{children:"name"})," 属性去子组件实例上的 ",(0,t.jsx)(n.code,{children:"slots"})," 中查找对应的执行函数，然后创建一个以 ",(0,t.jsx)(n.code,{children:"slot"})," 为子节点的 ",(0,t.jsx)(n.code,{children:"Fragment"})," 类型的 ",(0,t.jsx)(n.code,{children:"vnode"})," 节点。"]}),"\n",(0,t.jsxs)(n.p,{children:["上述 ",(0,t.jsx)(n.code,{children:"slot"})," 容器中的内容是通过 ",(0,t.jsx)(n.code,{children:"withCtx(...)"})," 函数进行封装执行的，那么这个函数的作用是什么呢？先来看一下这个函数的实现："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"export function withCtx(fn, ctx= currentRenderingInstance, isNonScopedSlot) {\n  // ...\n  const renderFnWithContext: ContextualRenderFn = (...args: any[]) => {\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1)\n    }\n    // 暂存子组件实例\n    const prevInstance = setCurrentRenderingInstance(ctx)\n    let res\n    try {\n      // 运行创建 vnode 的函数\n      res = fn(...args)\n    } finally {\n      // 重置回子组件实例\n      setCurrentRenderingInstance(prevInstance)\n    }\n    return res\n  }\n  // ...\n  return renderFnWithContext\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"withCtx"})," 函数巧妙的利用了闭包的特性，在运行父组件的时候，通过 ",(0,t.jsx)(n.code,{children:"withCtx"})," 保存了父组件的实例到 ",(0,t.jsx)(n.code,{children:"currentRenderingInstance"})," 变量上，然后在子组件执行 ",(0,t.jsx)(n.code,{children:"renderFnWithContext"})," 函数时，先恢复父组件的实例上下文，再执行生成 ",(0,t.jsx)(n.code,{children:"vnode"})," 函数，执行完成后，再重置回子组件的实例。这样做的好处是在做 ",(0,t.jsx)(n.code,{children:"<slot>"})," 渲染内容的时候，让 ",(0,t.jsx)(n.code,{children:"slot"})," 的内容可以访问到父组件的实例，因为 ",(0,t.jsx)(n.code,{children:"slot"})," 内容本身也是在父组件中定义的，只是被渲染到了指定的子组件中而已。"]}),"\n",(0,t.jsxs)(n.h2,{id:"dynamic-slots",children:["Dynamic Slots",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dynamic-slots",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["什么是 ",(0,t.jsx)(n.code,{children:"dynamic slots"})," ? 我们之前还有一种动态类型叫做 ",(0,t.jsx)(n.code,{children:"dynamic children"})," 在 ",(0,t.jsx)(n.code,{children:"DOM"})," 更新时做靶向更新。而 ",(0,t.jsx)(n.code,{children:"dynamic slots"})," 则是用于判断 ",(0,t.jsx)(n.code,{children:"slot"})," 内容是否需要更新。"]}),"\n",(0,t.jsxs)(n.p,{children:["那么 ",(0,t.jsx)(n.code,{children:"Vue 3"})," 会为哪些组价添加 ",(0,t.jsx)(n.code,{children:"dynamic slots"})," 属性呢？"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Vue 3"})," 中，对于动态的插槽名、条件判断、循环等场景的 ",(0,t.jsx)(n.code,{children:"<slot>"}),"，则会被标记为 ",(0,t.jsx)(n.code,{children:"dynamic slots"}),"，拿动态的插槽名举例："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<child-component>\n  <template #[dynamicSlotName]>header</template>\n</child-component>\n"})}),"\n",(0,t.jsx)(n.p,{children:"则会被渲染成："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'import { createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from "vue"\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_child_component = _resolveComponent("child-component")\n\n  return (_openBlock(), _createBlock(_component_child_component, null, {\n    [_ctx.dynamicSlotName]: _withCtx(() => [\n      _createTextVNode("header")\n    ]),\n    _: 2 /* DYNAMIC */\n  }, 1024 /* DYNAMIC_SLOTS */))\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["可以看到，对于动态的插槽名，组件渲染函数会为 ",(0,t.jsx)(n.code,{children:"patchFlag"})," 标记为 ",(0,t.jsx)(n.code,{children:"DYNAMIC_SLOTS"}),"。在执行组件更新时，则会根据这个标记来判断当前组件是否需要更新："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const updateComponent = (n1, n2, vnode) => {\n  if (shouldUpdateComponent(n1, n2, optimized)) {\n    // ...\n    //  执行更新逻辑\n  }\n}\n\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  // ...\n  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode\n  // patchFlag 是 DYNAMIC_SLOTS 的情况，shouldUpdateComponent 返回 true\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & PatchFlags.DYNAMIC_SLOTS) {\n      return true\n    }\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["这里我们介绍了关于 ",(0,t.jsx)(n.code,{children:"<slot>"})," 内置元素的实现原理，本质上就是父组件在渲染的时候，如果遇到了 ",(0,t.jsx)(n.code,{children:"<slot>"})," 内容，则会暂时将其缓存到组件实例上，然后在组件实例化的过程中，从父组件中取出对应的 ",(0,t.jsx)(n.code,{children:"slots"})," 按照名称进行渲染到指定位置。"]}),"\n",(0,t.jsxs)(n.p,{children:["同时配合 ",(0,t.jsx)(n.code,{children:"PatchFlags"})," 属性，可以做到只有在 ",(0,t.jsx)(n.code,{children:"DYNAMIC_SLOTS"})," 的情况下，才去更新含有 ",(0,t.jsx)(n.code,{children:"slot"})," 的组件，减少了不必要的渲染性能负担。"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}let r=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F21.%E7%89%B9%E6%AE%8A%E5%85%83%E7%B4%A0%26%E6%8C%87%E4%BB%A4%EF%BC%9Aslot%20%E6%8F%92%E6%A7%BD%E5%85%83%E7%B4%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"插槽内容渲染",id:"插槽内容渲染",depth:2},{text:"插槽出口渲染",id:"插槽出口渲染",depth:2},{text:"Dynamic Slots",id:"dynamic-slots",depth:2},{text:"总结",id:"总结",depth:2}],title:"21.特殊元素&指令：slot 插槽元素是如何实现的？",headingTitle:"21.特殊元素&指令：slot 插槽元素是如何实现的？",frontmatter:{}}}}]);