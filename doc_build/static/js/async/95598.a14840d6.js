"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["95598"],{433675:function(e,n,s){s.r(n),s.d(n,{default:()=>i});var r=s(552676),c=s(740453);let d=s.p+"static/image/585e72657a861da09deaae60fa7b55ee.c4a1281b.webp",t=s.p+"static/image/a94e5e6dde7962dcd5e6ce6d51bf2d79.abd8e1aa.webp",o=s.p+"static/image/bc6fed993e37c99f6d701d721c569133.ad6f8140.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",img:"img",code:"code",pre:"pre",h3:"h3"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"12-理解-http用-net-模块实现一个-tcp-服务器",children:["12 理解 HTTP：用 net 模块实现一个 TCP 服务器",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-理解-http用-net-模块实现一个-tcp-服务器",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"作为前端工程师，少不了要和 Web 打交道。通常情况下，前端工程师主要负责“端”的部分，也就是浏览器这一头的功能实现，后端工程师负责另一头，也就是服务器上的逻辑实现。"}),"\n",(0,r.jsx)(n.p,{children:"当我们打开一个网页的时候，浏览器会向服务器发送 HTTP 请求，服务器根据请求的内容处理数据，将正确的数据返回。可以说，HTTP 协议将浏览器与服务器连接在了一起。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"因为 Web 开发中的许多问题既与客户端有关也与服务端有关，所以前端工程师很有必要了解 HTTP 协议"}),"。比如要优化性能，加快页面的打开速度，就需要理解 TCP 协议和 HTTP 协议，理解连接是如何建立的，数据是如何传输的。"]}),"\n",(0,r.jsx)(n.p,{children:"而全栈工程师的工作范围则更广，既要实现客户端的逻辑，也要处理服务器端的逻辑，那么理解HTTP协议，了解服务器就更是非常有必要。"}),"\n",(0,r.jsx)(n.p,{children:"所以在接下来的课程中，我们就由浅入深地来了解用 Node.js 进行服务端编程的方法。首先，我们从最基础的网络协议开始。"}),"\n",(0,r.jsxs)(n.h2,{id:"网络-osi-模型与网络协议",children:["网络 OSI 模型与网络协议",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#网络-osi-模型与网络协议",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["我们知道，标准的开放式互联网模型（Open System Interconnection Model）是七层结构，从下到上分别是",(0,r.jsx)(n.strong,{children:"物理层、数据链路层、网络层、传输层、会话层、表示层和应用层"}),"。而万维网（World Wide Web）模型把物理层和数据链路层合并为物理层，把会话层、表示层和应用层合并为应用层，所以是四层结构。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在我们编写 Web 应用时，通常很少和物理层打交道，基本上是和网络层、传输层和应用层打交道。网络层主要是 IP 协议，也就是 IP 地址的解析；传输层主要是 TCP 协议；应用层主要是 HTTP 协议。"}),"\n",(0,r.jsx)(n.p,{children:"HTTP 协议是基于传输层 TCP 协议建立在 TCP 协议之上的文本协议，因此 TCP 服务可以处理 HTTP 请求和响应。"}),"\n",(0,r.jsx)(n.p,{children:"这一节课，我们来看一下如何用 Node.js 创建底层 TCP 服务并处理 HTTP 请求。"}),"\n",(0,r.jsxs)(n.h2,{id:"用-tcp-服务处理-http-请求",children:["用 TCP 服务处理 HTTP 请求",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用-tcp-服务处理-http-请求",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Node.js 的内置模块 net 模块，可以方便地创建 TCP 服务，监听端口，接受远程客户端的连接。"}),"\n",(0,r.jsxs)(n.p,{children:["我们先来创建一个简单的 TCP 服务 —— ",(0,r.jsx)(n.code,{children:"tcp-server.js"}),"模块："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// tcp-server.js\n\nconst net = require('net');\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    console.log(`DATA:\\n\\n${data}`);\n  });\n\n  socket.on('close', () => {\n    console.log('connection closed, goodbye!\\n\\n\\n');\n  });\n}).on('error', (err) => {\n  // handle errors here\n  throw err;\n});\n\nserver.listen({\n  host: '0.0.0.0',\n  port: 8080,\n}, () => {\n  console.log('opened server on', server.address());\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"net.createServer"}),"表示创建并返回一个 server 对象，它的参数是一个回调函数，这个回调函数会在连接建立的时候被调用。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"net.createServer"}),"创建的 server 对象需要调用 listen 方法才能够与客户端建立连接。listen 方法的第一个参数是一个配置项，host表示校验服务器名或 IP 地址。"]}),"\n",(0,r.jsxs)(n.p,{children:["如果设置为",(0,r.jsx)(n.code,{children:"0.0.0.0"}),"，则表示不校验名称及 IP 地址。也就是说只要能访问到运行",(0,r.jsx)(n.code,{children:"tcp-server.js"}),"的这台服务器，不管是通过哪个 IP 地址或者服务器名访问的，都允许建立连接。",(0,r.jsx)(n.code,{children:"port"}),"表示要连接的端口号。"]}),"\n",(0,r.jsx)(n.p,{children:"我们在项目目录下运行这个模块："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"$ node tcp-server.js\n"})}),"\n",(0,r.jsx)(n.p,{children:"如果看到控制台打印以下信息，表示服务启动成功。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"opened server on { address: '0.0.0.0', family: 'IPv4', port: 8080 }\n"})}),"\n",(0,r.jsx)(n.p,{children:"此时脚本没有结束，而是保持在监听来自 8080 端口的 TCP 请求状态，所以控制台没有返回。"}),"\n",(0,r.jsxs)(n.h2,{id:"用浏览器连接-tcp-服务",children:["用浏览器连接 TCP 服务",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用浏览器连接-tcp-服务",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"现在，我们让 TCP 服务器和客户端建立连接，最简单的方法是通过浏览器访问："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"http://localhost:8080\n"})}),"\n",(0,r.jsxs)(n.p,{children:["浏览器建立的是应用层协议 HTTP 连接，而它是基于传输层的 TCP 协议，所以 HTTP 是建立在 TCP 协议之上的，底层仍然是 TCP 协议，那么",(0,r.jsx)(n.strong,{children:"我们的 TCP 服务器就可以和浏览器建立连接"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"我们在浏览器输入网址后，网页请求一直保持在加载状态，而运行 Server 的命令行终端里可以看到一些输出信息："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"DATA:\n\nGET / HTTP/1.1\nHost: localhost:8080\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\n...\n（这里是两行空行）\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"这些信息就是浏览器通过 HTTP 请求向我们的服务器发送的数据，它们是通过 createServer 的回调函数返回的网络连接套接字 socket 对象的 data 事件获取："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  socket.on('data', (data) => {\n    console.log(`DATA:\\n\\n${data}`);\n  });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们看到，浏览器给 TCP 服务器发送的数据是一段文本内容。它的第一行是：",(0,r.jsx)(n.code,{children:"GET / HTTP/1.1"}),"，表示浏览器向服务器发起了 HTTP GET 请求，HTTP的版本是 1.1，请求的路径是",(0,r.jsx)(n.code,{children:"/"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["从第二行开始是键/值的形式，表示 HTTP 的请求头。浏览器会发送给服务器许多的请求头。最后是两个空行。第一个空行是 HTTP 请求头（HTTP Header）和 HTTP 内容（HTTP Body）的分隔；第二个空行是因为浏览器发送的是",(0,r.jsx)(n.code,{children:"GET"}),"请求，HTTP 协议规定",(0,r.jsx)(n.code,{children:"GET"}),"请求的 HTTP Body 为空时，它就是一个空行。"]}),"\n",(0,r.jsx)(n.p,{children:"由于我们的服务器没有返回给浏览器任何内容，因此浏览器一直处于等待响应状态，表现为网页一直在加载中的状态。这时候，如果我们关闭网页，在 Server 的命令行终端上会看到输出内容为："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"connection closed, goodbye!\n\n\n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这是因为我们关闭网页，连接终止，socket对象的",(0,r.jsx)(n.code,{children:"close"}),"事件被触发，执行了以下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  socket.on('close', () => {\n    console.log('connection closed, goodbye!\\n\\n\\n');\n  });\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"给浏览器返回-http-内容",children:["给浏览器返回 HTTP 内容",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#给浏览器返回-http-内容",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"要让浏览器结束等待，我们可以给它返回内容。内容的返回是通过调用 socket.write 方法来实现。"}),"\n",(0,r.jsx)(n.p,{children:"我们修改一下代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const net = require('net');\n\nfunction responseData(str) {\n  return `HTTP/1.1 200 OK\nConnection: keep-alive\nDate: ${new Date()}\nContent-Length: ${str.length}\nContent-Type: text/html\n\n${str}`;\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    if(/^GET \\/ HTTP/.test(data)) {\n      socket.write(responseData('<h1>Hello world</h1>'));\n    }\n    console.log(`DATA:\\n\\n${data}`);\n  });\n\n  socket.on('close', () => {\n    console.log('connection closed, goodbye!\\n\\n\\n');\n  });\n}).on('error', (err) => {\n  // handle errors here\n  throw err;\n});\n\nserver.listen({\n  host: '0.0.0.0',\n  port: 8080,\n}, () => {\n  console.log('opened server on', server.address());\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在上面的代码中，我们判断如果请求的数据以",(0,r.jsx)(n.code,{children:"GET / HTTP"}),"开头，就返回给请求的客户端（即浏览器）一段文本。这段文本通过模板字符串定义在",(0,r.jsx)(n.code,{children:"responseData"}),"函数里，形式如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"HTTP/1.1 200 OK\nConnection: keep-alive\nDate: ${new Date()}\nContent-Length: ${str.length}\nContent-Type: text/html\n\n${str}\n"})}),"\n",(0,r.jsx)(n.p,{children:"上面的模版字符串定义了 HTTP 响应报文的基础格式。"}),"\n",(0,r.jsxs)(n.p,{children:["第一行",(0,r.jsx)(n.code,{children:"HTTP/1.1 200 OK"}),"表示这是一个 HTTP 协议的返回内容，版本是1.1，200 是状态码表示请求成功完成，OK 是状态码对应的描述符。"]}),"\n",(0,r.jsxs)(n.p,{children:["第二行开始一直到空行前面，和请求的报文一样是键/值形式的字符串，表示 HTTP 响应头。HTTP 协议规定：HTTP 响应头要带上",(0,r.jsx)(n.code,{children:"Content-Type"}),"和",(0,r.jsx)(n.code,{children:"Content-Length"}),"。其中，",(0,r.jsx)(n.code,{children:"Content-Type"}),"指定了响应的类型。这里设置为",(0,r.jsx)(n.code,{children:"text/html"}),"，告诉浏览器这个返回内容是一段 HTML，要去解析其中的 HTML 标签。",(0,r.jsx)(n.code,{children:"Content-Length"}),"指定了响应内容中",(0,r.jsx)(n.code,{children:"HTTP Body"}),"的字符数。浏览器读到",(0,r.jsx)(n.code,{children:"Content-Length"}),"指定的字符数后，就会认为响应的内容已经传输完成。"]}),"\n",(0,r.jsxs)(n.p,{children:["除了这两个HTTP响应头字段之外，我们还发送了另外两个响应头字段，一个",(0,r.jsx)(n.code,{children:"Connection"}),"字段，内容是",(0,r.jsx)(n.code,{children:"keep-alive"}),"，告诉浏览器可以不断开 TCP 连接，直到网页关闭。这是 HTTP/1.1 中支持的机制，在同一个会话期间能够复用 TCP 连接，以免每次请求的时候都要创建一个新的 TCP 连接，那样会比较耗性能。"]}),"\n",(0,r.jsxs)(n.p,{children:["另外，我们发送了一个",(0,r.jsx)(n.code,{children:"Date"}),"字段，用来存放服务器响应请求的日期时间。这个可以提供给页面，方便页面获取服务器时间，对于一些时间依赖的应用（比如秒杀购物）比较有用。"]}),"\n",(0,r.jsxs)(n.p,{children:["响应头之后是一个空行，这个也是",(0,r.jsx)(n.code,{children:"HTTP Header"}),"和",(0,r.jsx)(n.code,{children:"HTTP Body"}),"的分隔，然后是实际的响应内容。在这个例子中，我们发送的是一段 HTML 片段，内容是",(0,r.jsx)(n.code,{children:"<h1>Hello World</h1>"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["这样，浏览器中显示出来的结果就是正常",(0,r.jsx)(n.code,{children:"<H1>"}),"标题的 Hello World 内容。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"服务器可以给浏览器返回不同的响应内容和状态码，浏览器会根据响应内容、状态码执行不同的动作。比如我们再修改一下代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function responseData(str, status = 200, desc = 'OK') {\n  return `HTTP/1.1 ${status} ${desc}\nConnection: keep-alive\nDate: ${new Date()}\nContent-Length: ${str.length}\nContent-Type: text/html\n\n${str}`;\n}\n\nconst server = net.createServer((socket) => {\n  socket.on('data', (data) => {\n    const matched = data.toString('utf-8').match(/^GET ([/\\w]+) HTTP/);\n    if(matched) {\n      const path = matched[1];\n      if(path === '/') { //如果路径是'/'，返回hello world、状态是200\n        socket.write(responseData('<h1>Hello world</h1>'));\n      } else { // 否则返回404状态\n        socket.write(responseData('<h1>Not Found</h1>', 404, 'NOT FOUND'));\n      }\n    }\n    console.log(`DATA:\\n\\n${data}`);\n  });\n\n  socket.on('close', () => {\n    console.log('connection closed, goodbye!\\n\\n\\n');\n  });\n}).on('error', (err) => {\n  // handle errors here\n  throw err;\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们修改了上面代码的 responseData 函数，让它能够支持传入 status 状态码和 desc 状态描述。然后我们判断浏览器请求的 URL 地址，如果路径是",(0,r.jsx)(n.code,{children:"/"}),"，则返回 200，否则返回 404。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["所以如果我们请求一个非",(0,r.jsx)(n.code,{children:"/"}),"的地址，比如",(0,r.jsx)(n.code,{children:"/abc"}),"，那么浏览器就会返回 404。"]}),"\n",(0,r.jsxs)(n.h3,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这一节课，我们使用 net 模块的 createServer 实现了一个 TCP 服务器，并使用这个服务器来处理简单的 HTTP 请求。通过这个过程，我们了解了 HTTP 协议的基本结构。HTTP 协议是建立在 TCP 协议之上的应用层协议，它的请求、响应格式分别如下："}),"\n",(0,r.jsx)(n.p,{children:"请求格式："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"动作 路径 HTTP/1.1\nKey1: Value1\nKey2: Value2\n...\n\nBody\n"})}),"\n",(0,r.jsx)(n.p,{children:"这里的动作可以是 GET、POST、PUT、DELETE 和 OPTION，我们在后续课程中会继续介绍。"}),"\n",(0,r.jsx)(n.p,{children:"Body 可以为空，比如在 GET 请求时，规定的 Body 就是为空。"}),"\n",(0,r.jsx)(n.p,{children:"响应格式："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"HTTP/1.1 状态码 状态描述\nKey1: Value1\nKey2: Value2\n...\n\nBody\n"})}),"\n",(0,r.jsx)(n.p,{children:"这里的状态码可以是 1xx、2xx、3xx、4xx、5xx，分别表示不同的状态，在后续课程中会继续介绍。"}),"\n",(0,r.jsx)(n.p,{children:"浏览器通过 HTTP 请求头与服务器进行内容协商，根据响应头执行对应的动作，将响应内容（HTTP Body）渲染出来。"}),"\n",(0,r.jsx)(n.p,{children:"我们直接使用 TCP 协议建立连接虽然可以实现 HTTP 协议通讯，但是我们需要自己去解析 HTTP 请求内容，并按照 HTTP 协议的规范组织响应内容。这显然很麻烦。"}),"\n",(0,r.jsx)(n.p,{children:"幸运的是，Node.js 提供了更加简单的创建 HTTP 服务的模块 —— http 模块。在下一节课里，我们就来讨论如何用 http 模块实现基础的 HTTP 服务。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}let i=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F12%20%E7%90%86%E8%A7%A3%20HTTP%EF%BC%9A%E7%94%A8%20net%20%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20TCP%20%E6%9C%8D%E5%8A%A1%E5%99%A8.md"]={toc:[{text:"网络 OSI 模型与网络协议",id:"网络-osi-模型与网络协议",depth:2},{text:"用 TCP 服务处理 HTTP 请求",id:"用-tcp-服务处理-http-请求",depth:2},{text:"用浏览器连接 TCP 服务",id:"用浏览器连接-tcp-服务",depth:2},{text:"给浏览器返回 HTTP 内容",id:"给浏览器返回-http-内容",depth:2},{text:"总结",id:"总结",depth:3}],title:"12 理解 HTTP：用 net 模块实现一个 TCP 服务器",headingTitle:"12 理解 HTTP：用 net 模块实现一个 TCP 服务器",frontmatter:{}}}}]);