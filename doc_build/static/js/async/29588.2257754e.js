"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["29588"],{195065:function(e,s,n){n.r(s),n.d(s,{default:()=>h});var i=n(552676),r=n(740453);function l(e){let s=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",pre:"pre",code:"code",ol:"ol",h3:"h3",strong:"strong",blockquote:"blockquote",img:"img",hr:"hr"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.h1,{id:"13实战篇-04用-npm-script-实现构建流水线",children:["13实战篇 04：用 npm script 实现构建流水线",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#13实战篇-04用-npm-script-实现构建流水线",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"在现代前端项目的交付工作流中，部署前最关键的环节就是构建，构建环节要完成的事情通常包括："}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"源代码预编译：比如 less、sass、typescript；"}),"\n",(0,i.jsx)(s.li,{children:"图片优化、雪碧图生成；"}),"\n",(0,i.jsx)(s.li,{children:"JS、CSS 合并、压缩；"}),"\n",(0,i.jsx)(s.li,{children:"静态资源加版本号和引用替换；"}),"\n",(0,i.jsx)(s.li,{children:"静态资源传 CDN 等。"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"现在大多数同学所接触的项目构建过程可能都是别人配置好的，但是对于构建过程中的某些考量可能并不是很清楚。"}),"\n",(0,i.jsx)(s.p,{children:"接下来，我们将组合 npm script 和简单的命令行工具为实际项目添加构建过程，以加深对构建过程的理解，同时也会用到前面很多章节的知识点。"}),"\n",(0,i.jsxs)(s.h2,{id:"项目目录结构",children:["项目目录结构",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#项目目录结构",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"对之前的示例项目做简单改造，让目录结构包括典型的前端项目资源引用情况："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"client\n├── images\n│\xa0\xa0 └── schedule.png\n├── index.html\n├── scripts\n│\xa0\xa0 └── main.js\n└── styles\n    └── main.css\n"})}),"\n",(0,i.jsx)(s.p,{children:"可能的资源依赖关系如下："}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"css、html 文件中引用了图片；"}),"\n",(0,i.jsx)(s.li,{children:"html 文件中引用了 css、js；"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"显而易见，我们的构建过程必须遵循下面的步骤才能不出错："}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"压缩图片；"}),"\n",(0,i.jsx)(s.li,{children:"编译 less、压缩 css；"}),"\n",(0,i.jsx)(s.li,{children:"编译、压缩 js；"}),"\n",(0,i.jsx)(s.li,{children:"给图片加版本号并替换 js、css 中的引用；"}),"\n",(0,i.jsx)(s.li,{children:"给 js、css 加版本号并替换 html 中的引用；"}),"\n"]}),"\n",(0,i.jsxs)(s.h2,{id:"添加构建过程",children:["添加构建过程",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#添加构建过程",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"下面介绍如何结合 npm script 正确的给这样的项目结构加上构建过程。"}),"\n",(0,i.jsxs)(s.h3,{id:"1-准备构建目录",children:["1. 准备构建目录",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#1-准备构建目录",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"我们约定构建产生的结果代码，放在 dist 目录下，与 client 的结构完全相同，每次构建前，清空之前的构建目录，利用 npm 的钩子机制添加 prebuild 命令如下："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-patch",children:'-    "client:static-server": "http-server client/"\n+    "client:static-server": "http-server client/",\n+    "prebuild": "rm -rf dist && mkdir -p dist/{images,styles,scripts}",\n'})}),"\n",(0,i.jsxs)(s.h3,{id:"2-准备脚本目录",children:["2. 准备脚本目录",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#2-准备脚本目录",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"构建过程需要的命令稍长，我们可以使用 scripty 来把这些脚本剥离到单独的文件中，为此需要准备单独的目录，并且我们的构建过程分为：images、styles、scripts、hash 四个步骤，每个步骤准备单独的文件。"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"mkdir scripts/build\ntouch scripts/build.sh\ntouch scripts/build/{images,styles,scripts}.sh\nchmod -R a+x scripts\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"脚本文件的可执行权限必须添加正确，否则 scripty 会直接报错"}),"，上面命令执行完之后，scripts 目录包含如下内容："]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"scripts\n├── build\n│\xa0\xa0 ├── hash.sh\n│\xa0\xa0 ├── images.sh\n│\xa0\xa0 ├── scripts.sh\n│\xa0\xa0 └── styles.sh\n├── build.sh\n"})}),"\n",(0,i.jsxs)(s.h3,{id:"3-图片构建过程",children:["3. 图片构建过程",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#3-图片构建过程",children:"#"})]}),"\n",(0,i.jsxs)(s.p,{children:["图片构建的经典工具是 ",(0,i.jsx)(s.a,{href:"https://github.com/imagemin/imagemin",target:"_blank",rel:"noopener noreferrer",children:"imagemin"}),"，它也提供了命令行版本 ",(0,i.jsx)(s.a,{href:"https://github.com/imagemin/imagemin-cli",target:"_blank",rel:"noopener noreferrer",children:"imagemin-cli"}),"，首先安装依赖："]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"npm i imagemin-cli -D\n# npm install imagemin-cli --save-dev\n# yarn add imagemin-cli -D\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后在 scripts/build/images.sh 中添加如下内容："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"imagemin client/images/* --out-dir=dist/images\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后在 package.json 中添加 build:images 命令："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-patch",children:'+    "build:images": "scripty",\n'})}),"\n",(0,i.jsx)(s.p,{children:"尝试运行 npm run prebuild && npm run build:images，然后观察 dist 目录的变化。"}),"\n",(0,i.jsxs)(s.h3,{id:"4-样式构建过程",children:["4. 样式构建过程",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#4-样式构建过程",children:"#"})]}),"\n",(0,i.jsxs)(s.p,{children:["我们使用 ",(0,i.jsx)(s.a,{href:"http://lesscss.org/usage/",target:"_blank",rel:"noopener noreferrer",children:"less"})," 编写样式，所以需要预编译样式代码，可以使用 less 官方库自带的命令行工具 lessc，使用 sass 的同学可以直接使用 ",(0,i.jsx)(s.a,{href:"https://github.com/sass/node-sass",target:"_blank",rel:"noopener noreferrer",children:"node-sass"}),"。此外，样式预编译完成之后，我们需要使用 ",(0,i.jsx)(s.a,{href:"https://www.npmjs.com/package/cssmin",target:"_blank",rel:"noopener noreferrer",children:"cssmin"})," 来完成代码预压缩。首先安装依赖："]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"npm i cssmin -D\n# npm install cssmin --save-dev\n# yarn add cssmin -D\n"})}),"\n",(0,i.jsxs)(s.p,{children:["然后在 scripts/build/styles.sh 中添加如下内容，这里我们使用到了 shell 里面的管道操作符 ",(0,i.jsx)(s.code,{children:"|"})," 和输出重定向 ",(0,i.jsx)(s.code,{children:">"}),"："]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"for file in client/styles/*.css\ndo\n  lessc $file | cssmin > dist/styles/$(basename $file)\ndone\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后在 package.json 中添加 build:styles 命令："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-patch",children:'+    "build:styles": "scripty",\n'})}),"\n",(0,i.jsx)(s.p,{children:"尝试运行 npm run prebuild && npm run build:styles，然后观察 dist 目录的变化，应该能看到 less 编译之后再被压缩的 css 代码。"}),"\n",(0,i.jsxs)(s.h3,{id:"4-js-构建过程",children:["4. JS 构建过程",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#4-js-构建过程",children:"#"})]}),"\n",(0,i.jsxs)(s.p,{children:["我们使用 ES6 编写 JS 代码，所以需要 ",(0,i.jsx)(s.a,{href:"https://github.com/mishoo/UglifyJS2/tree/harmony",target:"_blank",rel:"noopener noreferrer",children:"uglify-es"})," 来进行代码压缩，如果你不使用 ES6，可以直接使用 ",(0,i.jsx)(s.a,{href:"https://github.com/mishoo/UglifyJS2",target:"_blank",rel:"noopener noreferrer",children:"uglify-js"})," 来压缩代码，首先安装依赖："]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"npm i uglify-es -D\n# npm install uglify-es --save-dev\n# yarn add uglify-es -D\n"})}),"\n",(0,i.jsxs)(s.p,{children:["然后在 scripts/build/scripts.sh 中添加如下内容，",(0,i.jsx)(s.strong,{children:"需要额外注意的是，这里我们需要手动指定 uglify-es 目录下的 bin 文件，否则识别不了 ES6 语法"}),"，因为 uglify-es 在 npm install 过程自动创建的软链是错误的。"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"for file in client/scripts/*.js\ndo\n  ./node_modules/uglify-es/bin/uglifyjs $file --mangle > dist/scripts/$(basename $file)\ndone\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后在 package.json 中添加 build:scripts 命令："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-patch",children:'+    "build:scripts": "scripty",\n'})}),"\n",(0,i.jsx)(s.p,{children:"尝试运行 npm run prebuild && npm run build:scripts，然后观察 dist 目录的变化，应该能看到被 uglify-es 压缩后的代码。"}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"TIP#19"}),"：uglify-es 支持很多其他的选项，以及 sourcemap，对 JS 代码做极致的优化，详细",(0,i.jsx)(s.a,{href:"https://github.com/mishoo/UglifyJS2/tree/harmony#command-line-options",target:"_blank",rel:"noopener noreferrer",children:"参考"})]}),"\n"]}),"\n",(0,i.jsxs)(s.h3,{id:"4-资源版本号和引用替换",children:["4. 资源版本号和引用替换",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#4-资源版本号和引用替换",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"给静态资源加版本号的原因是线上环境的静态资源通常都放在 CDN 上，或者设置了很长时间的缓存，或者两者兼有，如果资源更新了但没有更新版本号，浏览器端是拿不到最新内容的，手动加版本号的过程很繁琐并且容易出错，为此自动化这个过程就显得非常\b有价值，通常的做法是利用文件内容做哈希，比如 md5，然后以这个哈希值作为版本号，版本号附着在文件名里面，线上环境的资源引用全部是带版本号的。"}),"\n",(0,i.jsx)(s.p,{children:"为了\b实现这个过程，我们需要引入两个小工具："}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://github.com/keithamus/hashmark",target:"_blank",rel:"noopener noreferrer",children:"hashmark"}),"，自动添加版本号；"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"https://github.com/songkick/replaceinfiles",target:"_blank",rel:"noopener noreferrer",children:"replaceinfiles"}),"，自动完成引用替换，它需要将版本号过程的输出作为输入；"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"首先安装\b依赖："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"npm i hashmark replaceinfiles -D\n# npm install hashmark replaceinfiles --save-dev\n# yarn add hashmark replaceinfiles -D\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后在 scripts/build/hash.sh 中添加如下内容："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"# 给图片资源加上版本号，并且替换引用\nhashmark -c dist -r -l 8 '**/*.{png,jpg}' '{dir}/{name}.{hash}{ext}' | replaceinfiles -S -s 'dist/**/*.css' -d '{dir}/{base}'\n\n# 给 js、css 资源加上版本号，并且替换引用\nhashmark -c dist -r -l 8 '**/*.{css,js}' '{dir}/{name}.{hash}{ext}' | replaceinfiles -S -s 'client/index.html' -d 'dist/index.html'\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后在 package.json 中添加 build:hash 命令："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-patch",children:'+    "build:hash": "scripty",\n'})}),"\n",(0,i.jsx)(s.p,{children:"这个步骤需要依赖前几个步骤，不能单独运行，接下来我们需要增加完整的 build 命令把上面几个步骤串起来。"}),"\n",(0,i.jsxs)(s.h3,{id:"5-完整的构建步骤",children:["5. 完整的构建步骤",(0,i.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#5-完整的构建步骤",children:"#"})]}),"\n",(0,i.jsx)(s.p,{children:"最后我们在 package.json 中添加 build 命令把所有的步骤串起来，完整的 diff 如下："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-patch",children:'-    "client:static-server": "http-server client/"\n+    "client:static-server": "http-server client/",\n+    "prebuild": "rm -rf dist && mkdir -p dist/{images,styles,scripts}",\n+    "build": "scripty",\n+    "build:images": "scripty",\n+    "build:scripts": "scripty",\n+    "build:styles": "scripty",\n+    "build:hash": "scripty"\n'})}),"\n",(0,i.jsx)(s.p,{children:"其中 scripts/build.sh 的内容如下："}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"for step in 'images' 'scripts' 'styles' 'hash'\ndo\n  npm run build:$step\ndone\n"})}),"\n",(0,i.jsx)(s.p,{children:"然后我们尝试运行 npm run build，完整的过程输出如下："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://user-gold-cdn.xitu.io/2017/12/18/16066e5912427543?w=984&h=1290&f=png&s=171783",alt:""})}),"\n",(0,i.jsx)(s.p,{children:"构建完成的 dist 目录内容如下："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://user-gold-cdn.xitu.io/2017/12/18/16066e5b824399a7?w=698&h=240&f=png&s=25460",alt:""})}),"\n",(0,i.jsx)(s.p,{children:"可以看到，所有的静态资源都加上了版本号。"}),"\n",(0,i.jsx)(s.p,{children:"构建完成的 dist/index.html 内容如下："}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://user-gold-cdn.xitu.io/2017/12/18/16066e5e1a91e46c?w=875&h=416&f=png&s=74207",alt:""})}),"\n",(0,i.jsxs)(s.p,{children:["可以看到，静态资源的版本号被正确替换了，为了验证构建出来的页面是否正常运行，可以运行 ",(0,i.jsx)(s.code,{children:"./node_modules/.bin/http-server dist"}),"，然后浏览器打开：",(0,i.jsx)(s.code,{children:"http://127.0.0.1:8080"}),"，不出意外的话，浏览器显示如下："]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://user-gold-cdn.xitu.io/2017/12/18/16066e60258d8eeb?w=865&h=688&f=png&s=192586",alt:""})}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"好了，到这里，我们给简单但是五脏俱全的前端项目加上了构建过程，这些环节你是否都清楚？你觉得还缺失些什么环节？欢迎留言交流"})}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["本节用到的代码见 ",(0,i.jsx)(s.a,{href:"https://github.com/wangshijun/automated-workflow-with-npm-script/tree/12-use-npm-script-as-build-pipeline",target:"_blank",rel:"noopener noreferrer",children:"GitHub"}),"，想边看边动手练习的同学可以拉下来自己改，注意切换到正确的分支 ",(0,i.jsx)(s.code,{children:"12-use-npm-script-as-build-pipeline"}),"。"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,r.ah)(),e.components);return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}let h=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%94%A8%20npm%20script%20%E6%89%93%E9%80%A0%E8%B6%85%E6%BA%9C%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%2F13%E5%AE%9E%E6%88%98%E7%AF%87%2004%EF%BC%9A%E7%94%A8%20npm%20script%20%E5%AE%9E%E7%8E%B0%E6%9E%84%E5%BB%BA%E6%B5%81%E6%B0%B4%E7%BA%BF.md"]={toc:[{text:"项目目录结构",id:"项目目录结构",depth:2},{text:"添加构建过程",id:"添加构建过程",depth:2},{text:"1. 准备构建目录",id:"1-准备构建目录",depth:3},{text:"2. 准备脚本目录",id:"2-准备脚本目录",depth:3},{text:"3. 图片构建过程",id:"3-图片构建过程",depth:3},{text:"4. 样式构建过程",id:"4-样式构建过程",depth:3},{text:"4. JS 构建过程",id:"4-js-构建过程",depth:3},{text:"4. 资源版本号和引用替换",id:"4-资源版本号和引用替换",depth:3},{text:"5. 完整的构建步骤",id:"5-完整的构建步骤",depth:3}],title:"13实战篇 04：用 npm script 实现构建流水线",headingTitle:"13实战篇 04：用 npm script 实现构建流水线",frontmatter:{}}}}]);