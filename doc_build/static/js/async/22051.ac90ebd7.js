"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["22051"],{443594:function(n,e,r){r.r(e),r.d(e,{default:()=>o});var t=r(552676),s=r(740453);let i=r.p+"static/image/c1f75f1c39dc71215d56ed96e96a706c.5284c476.webp";function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ol:"ol",li:"li",h2:"h2",code:"code",pre:"pre",img:"img",ul:"ul"},(0,s.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"第24章包五持久化存储之数据库",children:["第24章—包五｜持久化存储之数据库",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第24章包五持久化存储之数据库",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"\uFEFF从上一讲开始，我们介绍了 Go 语言中的持久化存储技巧。所谓的“持久化”，其本质就是文件。所以我们一开始就介绍了 os 和 io 包中的某些函数实现了文件的读写。"}),"\n",(0,t.jsx)(e.p,{children:"那么既然已经有了文件，为何还要提及数据库呢？"}),"\n",(0,t.jsxs)(e.p,{children:["这是因为数据库是自带",(0,t.jsx)(e.strong,{children:"结构化属性"}),"的。就拿上一讲中的示例来说，简单的追加内容和输出全部内容，直接使用文件存取已经足够满足。但如果要想精准地查找某个人的留言，或者某个人想要修改自己的留言，显然是很棘手的。更重要的是，在现代网络应用中，这类查询、修改和删除的应用场景比比皆是。"]}),"\n",(0,t.jsx)(e.p,{children:"本讲我将介绍如何使用 Go 语言进行数据库操作，选择的数据库引擎是较为流行的 MySQL。在讲解的过程中，还会介绍如何在源码中集成第三方支持库（Go SDK 中并未自带操作 MySQL 数据库的包）。"}),"\n",(0,t.jsx)(e.p,{children:"在正式开始之前，需要各位朋友对以下内容有个大致的了解。篇幅所限，本讲对以下内容不再过多展开阐述。"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["什么是",(0,t.jsx)(e.strong,{children:"关系型数据库"}),"；"]}),"\n",(0,t.jsxs)(e.li,{children:["什么是",(0,t.jsx)(e.strong,{children:"数据库"}),"和数据表，二者的",(0,t.jsx)(e.strong,{children:"关系"}),"又是什么；"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"表头"}),"、",(0,t.jsx)(e.strong,{children:"行"}),"、",(0,t.jsx)(e.strong,{children:"列"}),"、",(0,t.jsx)(e.strong,{children:"（主）键"}),"、",(0,t.jsx)(e.strong,{children:"值"}),"分别指什么；"]}),"\n",(0,t.jsxs)(e.li,{children:["SQL 语句的使用，包括",(0,t.jsx)(e.strong,{children:"建表"}),"以及",(0,t.jsx)(e.strong,{children:"CRUD操作"}),"；"]}),"\n",(0,t.jsx)(e.li,{children:"安装和配置 MySQL 8.0 社区版；"}),"\n",(0,t.jsx)(e.li,{children:"如何使用命令行或类似 MySQL Workbench 软件查看数据库表结构和表数据。"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"本讲将手把手教大家完成一个在线记事本服务端应用程序，使用 MySQL 8.0 社区版作为数据库引擎。连接数据库的用户名是 root，密码是 123456，数据库名称为 go_learn。"}),"\n",(0,t.jsxs)(e.p,{children:["源码地址位于",(0,t.jsx)(e.a,{href:"https://gitee.com/wh1990xiao2005/go-juejin-note-book-server",target:"_blank",rel:"noopener noreferrer",children:(0,t.jsx)(e.a,{href:"https://gitee.com/wh1990xiao2005/go-juejin-note-book-server",target:"_blank",rel:"noopener noreferrer",children:"https://gitee.com/wh1990xiao2005/go-juejin-note-book-server"})}),"。"]}),"\n",(0,t.jsxs)(e.h2,{id:"集成包",children:["集成包",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#集成包",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"现在开始动手！"}),"\n",(0,t.jsxs)(e.p,{children:["前文已经说到，Go SDK中并未附带连接数据库的包，因此需要我们自己去找合适的包来使用。幸运的是，我们很快就能找到相应的包：",(0,t.jsx)(e.a,{href:"https://pkg.go.dev/github.com/go-sql-driver/mysql",target:"_blank",rel:"noopener noreferrer",children:"go-sql-driver/mysql"}),"。"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"\uD83D\uDCA1 提示：还记得去哪里搜索源码包吗？当然是Go语言官方提供的package库首页：https://pkg.go.dev/ ，只需在搜索框中输入 mysql，就会看到很多搜索结果。通过查看包详情，可以得知包的作用、发布时间、使用人数、使用方法等等，由此便可做出选择。"})}),"\n",(0,t.jsx)(e.p,{children:"找到合适的包后，使用命令行将该包集成到项目中。创建一个工程，名为 go-juejin-note-book-server。启动 GoLand 中的 Terminal 视图，使用 go get 命令集成库："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-shell",children:"go get -u github.com/go-sql-driver/mysql\n"})}),"\n",(0,t.jsx)(e.p,{children:"在执行这条命令的时候，很有可能会受到网络错误的提示。解决办法很简单，只需将获取包的 GOPROXY 环境变量指向国内镜像源即可，具体如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-shell",children:"$ go env -w GO111MODULE=on\r\n$ go env -w GOPROXY=https://goproxy.cn,direct\n"})}),"\n",(0,t.jsxs)(e.p,{children:["其实，国内的镜像源网站不止一个，阿里云同样也支持（",(0,t.jsx)(e.a,{href:"http://mirrors.aliyun.com/goproxy/",target:"_blank",rel:"noopener noreferrer",children:"阿里云 Go Module代理服务 "}),"）。在学习本讲内容时，若刚好上述镜像源均已失效，您还可以自行查找，完全不用担心。"]}),"\n",(0,t.jsx)(e.p,{children:"集成成功后，再次回到 GoLand，打开 Project 视图，然后打开 External Libraries，可以在其中找到github.com/go-sql-driver/mysql，如下图所示："}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)("img",{src:i,alt:"image-20220412144953560.png"})}),"\n",(0,t.jsxs)(e.h2,{id:"实现网络请求的响应",children:["实现网络请求的响应",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现网络请求的响应",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"本例将响应用户的5类请求，对应5个接口地址，具体如下："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"根路径（/）：接受 POST/GET 请求，均返回欢迎信息和接口调用地址的含义；"}),"\n",(0,t.jsx)(e.li,{children:"添加一条记事本数据（/add）：仅接受 POST 请求，传入标题、正文和日期时间，添加成功后返回添加的标题；"}),"\n",(0,t.jsx)(e.li,{children:"根据 id 删除一条记事本数据（/delete）：接受 POST/GET 请求，传入 id，删除该 id 所属的数据，删除成功后返回成功结果；"}),"\n",(0,t.jsx)(e.li,{children:"根据id更新一条记事本数据（/update）：接受 POST/GET 请求，传入 id 和新的标题、正文和日期时间，用新传入的数据覆盖已有的数据，更新成功后返回成功结果；"}),"\n",(0,t.jsx)(e.li,{children:"查询记事本数据，可传入 id 进行精准查找（/query）：接受 POST/GET 请求，支持根据 id 进行单条数据的查找或查找全部数据，执行成功后返回查询结果集。"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["有关这部分的实现不是本讲的重点，如果您对这部分有疑问，请回看学习",(0,t.jsx)(e.a,{href:"https://juejin.cn/book/7039174186522116131/section/7080160787712442376",target:"_blank",rel:"noopener noreferrer",children:"包 三 ｜ 实现一个服务器软件"}),"。以下是完整的代码："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'package main\r\nimport (\r\n   "fmt"\r\n   "net/http"\r\n   "time"\r\n)\r\ntype notebook struct {\r\n   Id       int\r\n   Title    string `json:"title"`\r\n   Content  string `json:"content"`\r\n   DateTime string `json:"dateTime"`\r\n}\r\nfunc main() {\r\n   launchServer()\r\n}\r\n// 添加数据到数据库\r\nfunc add(data notebook) {\r\n}\r\n// 删除一条数据\r\nfunc del(id string) {\r\n}\r\n// 更新数据到数据库\r\nfunc update(id string, data notebook) {\r\n}\r\n// 从数据库获取数据\r\nfunc query(id string) []notebook {\r\n   var notebooks []notebook\r\n   return notebooks\r\n}\r\n// 启动服务器\r\nfunc launchServer() {\r\n   //响应/\r\n   http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {\r\n      fmt.Fprintf(w, "欢迎使用在线记事本\\n")\r\n      fmt.Fprintf(w, "▶▶ /add 添加新的数据\\n")\r\n      fmt.Fprintf(w, "▶▶ /delete 根据ID删除数据\\n")\r\n      fmt.Fprintf(w, "▶▶ /update 根据ID更新数据\\n")\r\n      fmt.Fprintf(w, "▶▶ /query 获取全部数据或根据ID获取单条数据\\n")\r\n   })\r\n   //响应/add，从传入的参数新增一条记事本\r\n   http.HandleFunc("/add", func(w http.ResponseWriter, r *http.Request) {\r\n      if r.Method == "POST" {\r\n         err := r.ParseForm()\r\n         if err != nil {\r\n            fmt.Fprintln(w, "错误的请求")\r\n         } else {\r\n            title := r.FormValue("title")\r\n            content := r.FormValue("content")\r\n            dateTime := r.FormValue("dateTime")\r\n            add(notebook{Title: title, Content: content, DateTime: dateTime})\r\n            fmt.Fprintln(w, "添加了："+title)\r\n         }\r\n      }\r\n   })\r\n   //响应/delete，从传入的参数删除一条记事本\r\n   http.HandleFunc("/delete", func(w http.ResponseWriter, r *http.Request) {\r\n      err := r.ParseForm()\r\n      if err != nil {\r\n         fmt.Fprintln(w, "错误的请求")\r\n      } else {\r\n         id := r.FormValue("id")\r\n         del(id)\r\n         fmt.Fprintln(w, "删除成功")\r\n      }\r\n   })\r\n   //响应/update，更新一条数据\r\n   http.HandleFunc("/update", func(w http.ResponseWriter, r *http.Request) {\r\n      err := r.ParseForm()\r\n      if err != nil {\r\n         fmt.Fprintln(w, "错误的请求")\r\n      } else {\r\n         id := r.FormValue("id")\r\n         title := r.FormValue("title")\r\n         content := r.FormValue("content")\r\n         dateTime := r.FormValue("dateTime")\r\n         update(id, notebook{Title: title, Content: content, DateTime: dateTime})\r\n         fmt.Fprintln(w, "更新成功")\r\n      }\r\n   })\r\n   //响应/query，从传入的参数删除一条记事本\r\n   http.HandleFunc("/query", func(w http.ResponseWriter, r *http.Request) {\r\n      err := r.ParseForm()\r\n      if err != nil {\r\n         fmt.Fprintln(w, "错误的请求")\r\n      } else {\r\n         id := r.FormValue("id")\r\n         fmt.Fprintln(w, query(id))\r\n      }\r\n   })\r\n   //启动本地服务器（localhost）\r\n   err := http.ListenAndServe(":80", nil)\r\n   if err != nil {\r\n      fmt.Println("启动服务失败，错误信息：", err)\r\n   }\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"显然，这段代码中的 add()、del()、update() 和 query() 函数就是真正操作数据库的函数了！不过别急，如果要进行数据库的CRUD操作，首先要做的是要成功地连接到数据库，检查并创建相应的数据表，最后才是针对表的数据操作。当然，这一切的操作均要使用 mysql 包中的函数。"}),"\n",(0,t.jsxs)(e.h2,{id:"建立连接",children:["建立连接",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#建立连接",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["根据 mysql 包的",(0,t.jsx)(e.a,{href:"https://github.com/go-sql-driver/mysql",target:"_blank",rel:"noopener noreferrer",children:"说明"}),"，首先需要import。具体如下："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'import (\r\n   "database/sql"\r\n\r\n   _ "github.com/go-sql-driver/mysql"\r\n)\n'})}),"\n",(0,t.jsxs)(e.p,{children:["请大家留意，这里在 import 时，使用了下划线（“_”）开头。",(0,t.jsx)(e.strong,{children:"“_”是一个特殊标识符，它表示仅执行包内的init()函数，不做其它之用。"})]}),"\n",(0,t.jsx)(e.p,{children:"接着，创建一个名为 connectToDb() 的函数，用来与 MySQL 数据库建立连接，并返回 *sql.DB 类型值。在后续的建表以及 CRUD 操作时会频繁用到这个值。"}),"\n",(0,t.jsxs)(e.p,{children:["看到这，有些朋友或许会感到好奇：“才刚到连接的步骤，你怎么知道后续的步骤该用什么呢？”实际上，",(0,t.jsx)(e.strong,{children:"在编码之前，如果我们使用了其它的包（在实际开发中，这是非常常见的场景），务必要先了解这个包的用法。而要了解某个包的用法，最靠谱的办法就是看官方文档。"})]}),"\n",(0,t.jsxs)(e.p,{children:["mysql 包的官方文档就给出了有关建表和 CRUD 操作的具体示例：",(0,t.jsx)(e.a,{href:"https://github.com/go-sql-driver/mysql/wiki/Examples",target:"_blank",rel:"noopener noreferrer",children:"Examples \xb7 go-sql-driver/mysql Wiki (github.com)"}),"。从中我们便可得知，建立连接后返回的 *sql.DB 类型值将频繁用于后续步骤。"]}),"\n",(0,t.jsx)(e.p,{children:"根据官方指导文档中所述的内容，建立连接的函数是 sql.Open()，其中需要传入数据库连接凭据。此外，我们还可以根据实际情况设置最大连接数等参数。具体代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'var db *sql.DB\r\n// 连接到数据库\r\nfunc connectToDb() *sql.DB {\r\n   db, _ := sql.Open("mysql", "root:123456@/go_learn")\r\n   // 设置可重用链接的最长时间（0为不限制）\r\n   db.SetConnMaxLifetime(time.Hour * 1)\r\n   // 设置连接到数据库的最大数量（默认值为0，即不限制）\r\n   db.SetMaxOpenConns(5)\r\n   // 设置空闲连接的最大数量（默认值为2）\r\n   db.SetMaxIdleConns(5)\r\n   fmt.Println("连接成功！！")\r\n   return db\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"执行 sql.Open() 函数后，它将返回两个参数：一个是 *sql.DB 类型值，我还声明了一个全局变量，以便后续使用；另一个则是包含错误信息的 error 类型值，上述代码忽略了针对连接错误的处理。"}),"\n",(0,t.jsxs)(e.h2,{id:"创建数据表",children:["创建数据表",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#创建数据表",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"一旦数据库连接成功，就可以检查所需的数据表是否存在了，如果不存在则创建。"}),"\n",(0,t.jsx)(e.p,{children:"对于本例中的记事本应用，需要创建的数据表头为自增长的 id、标题（title）、内容（content）和时间（dateTime）。除了 id 是数值型外，其它均为字符串类型。"}),"\n",(0,t.jsx)(e.p,{children:"mysql 包提供了 db.Exec() 方法，用来执行 SQL 语句，它的方法定义格式如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"func (db *DB) Exec(query string, args ...interface{}) (Result, error)\n"})}),"\n",(0,t.jsx)(e.p,{children:"在创建数据表时，需要传入的参数则是建表的 SQL 语句。因此，整个创建数据表的函数实现如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'// 创建数据表\r\nfunc createTable() {\r\n   db.Exec("CREATE TABLE IF NOT EXISTS `notebook` (" +\r\n      "`id` bigint(20) NOT NULL AUTO_INCREMENT," +\r\n      "`title` varchar(45) DEFAULT \'\'," +\r\n      "`content` varchar(45) DEFAULT \'\'," +\r\n      "`dateTime` varchar(45) DEFAULT \'\'," +\r\n      "PRIMARY KEY (`id`)" +\r\n      ") ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;")\r\n   fmt.Println("表存在或成功创建")\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"这段 SQL 语句将检查名为 notebook 的数据表是否存在，如果不存在则执行建表操作。表头信息和值类型均描述得非常清晰。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.code,{children:"❗️ 注意：考虑到数据量的增长，id 列的数据类型设置为 bigint 是较为妥善的处理方式。int 的取值范围受限于 4 个字节，bigint 则是 8 个字节。更大的范围意味着该数据表能容纳更多的数据，除非十分确定数据量的大小，否则建议大家将id列的类型设置为 bigint。"})}),"\n",(0,t.jsx)(e.p,{children:"数据库的连接和表的创建可以看作是完成本例的“准备工作”，完成了准备工作后，用户的请求才有可能得到正确的响应，main() 函数也可以随之得到完善了："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"func main() {\r\n   db = connectToDb()\r\n   createTable()\r\n   launchServer()\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"main() 函数的函数体首先执行了数据库的连接，然后进行了数据表的检查，准备工作完成。最后执行 launchServer() 函数，启动 Http 服务。"}),"\n",(0,t.jsxs)(e.h2,{id:"数据的增删改操作",children:["数据的增、删、改操作",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据的增删改操作",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["对于 mysql 包而言，实现数据的增、删、改都遵循相同的模式：都是",(0,t.jsx)(e.strong,{children:"先执行 db.Prepare() 方法，将完整的 SQL 语句作为参数传入。再通过该函数的返回值调用 Exec() 方法，将对应的值依次传入"})," ，即可完成整个过程。"]}),"\n",(0,t.jsx)(e.p,{children:"db.Prepare() 和 Stmt.Exet() 的定义格式如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"func (db *DB) Prepare(query string) (*Stmt, error)\r\nfunc (s *Stmt) Exec(args ...interface{}) (Result, error)\n"})}),"\n",(0,t.jsx)(e.p,{children:"以增加一条数据（add()函数）为例，具体代码片段如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'// 添加数据到数据库\r\nfunc add(data notebook) {\r\n   stmtInsert, _ := db.Prepare("INSERT INTO notebook SET title=?,content=?,dateTime=?")\r\n   res, _ := stmtInsert.Exec(data.Title, data.Content, data.DateTime)\r\n   idValue, _ := res.LastInsertId()\r\n   fmt.Printf("添加了id值为%d的数据\\n", idValue)\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"请大家观察 db.Prepare() 方法和 stmtInsert.Exec() 方法中的对应关系，前者中每个问号（“?”）对应后者中的一个参数值。至于具体是如何匹配的，我们便无需关心了。"}),"\n",(0,t.jsxs)(e.p,{children:["res 变量是执行 SQL 语句后的结果，它同样是 Result 类型的。该类型提供了两个方法：",(0,t.jsx)(e.strong,{children:"LastInsertId() 和 RowsAffected()，前者表示最新一条数据新增的 id 值，后者表示执行完 SQL 语句后受影响的行数。"})," 在 add() 函数中，调用了 LastInsertId() 方法，返回被添加数据的 id 值。"]}),"\n",(0,t.jsx)(e.p,{children:"接下来，依葫芦画瓢，实现删除一条数据（del()）和更新一条数据（update()）函数。具体代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'// 删除一条数据\r\nfunc del(id string) {\r\n   stmtDelete, _ := db.Prepare("DELETE FROM notebook WHERE id=?")\r\n   res, _ := stmtDelete.Exec(id)\r\n   rawsCount, _ := res.RowsAffected()\r\n   fmt.Printf("删除了%d条数据\\n", rawsCount)\r\n}\r\n\r\n// 更新数据到数据库\r\nfunc update(id string, data notebook) {\r\n   stmtInsert, _ := db.Prepare("UPDATE notebook SET title=?, content=?, dateTime=? WHERE id=?")\r\n   res, _ := stmtInsert.Exec(data.Title, data.Content, data.DateTime, id)\r\n   rawsCount, _ := res.RowsAffected()\r\n   fmt.Printf("更新了%d条数据\\n", rawsCount)\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"如上代码所示，del() 和 update() 函数均向控制台输出了受影响的行数。由于删除和更新是通过 id 来检索的，因此受影响的行数应为 1。"}),"\n",(0,t.jsxs)(e.h2,{id:"数据的查询操作",children:["数据的查询操作",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据的查询操作",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"在 mysql 包中有一个专门用于数据查询的方法，它就是db.Query()。该方法的定义格式如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:"func (db *DB) Query(query string, args ...interface{}) (*Rows, error) \n"})}),"\n",(0,t.jsx)(e.p,{children:"在执行查询时，需要将 SQL 语句传入其中，通过遍历 *Rows 类型值来获取查询结果。"}),"\n",(0,t.jsx)(e.p,{children:"本例中，要求服务端根据请求参数响应两种结果。当存在id参数时，进行 id 列条件查找；反之则返回全部数据。具体实现如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-go",children:'// 从数据库获取数据\r\nfunc query(id string) []notebook {\r\n   var notebooks []notebook\r\n   var rows *sql.Rows\r\n   if id == "" {\r\n      rows, _ = db.Query("SELECT * FROM notebook")\r\n   } else {\r\n      rows, _ = db.Query("SELECT * FROM notebook WHERE id=" + id)\r\n   }\r\n   for rows.Next() {\r\n      var singleNote notebook\r\n      rows.Scan(&singleNote.Id, &singleNote.Title, &singleNote.Content, &singleNote.DateTime)\r\n      notebooks = append(notebooks, singleNote)\r\n   }\r\n   return notebooks\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"此外，当仅需要检索第一条与查找条件相匹配的数据时，还可调用 db.QueryRow()，该函数返回 *Row 类型，表示单条数据。"}),"\n",(0,t.jsxs)(e.h2,{id:"总结",children:["总结",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,t.jsx)(e.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"集成包；"}),"\n",(0,t.jsx)(e.li,{children:"Go 语言操作 MySQL 数据库。"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"在实际开发中，集成包是非常常用的技能。使用包可以简化开发成本，在一定程度上减少产品缺陷。另一方面，对于某些能力的支持，只能使用特定的包才能实现。因此，集成包是每个 Go 语言开发者都必须要掌握的能力。"}),"\n",(0,t.jsx)(e.p,{children:"一旦学会了包的集成方法，很多看似毫无思路或很难实现的需求便迎刃而解了，操作 MySQL 数据库便是其中之一。想象一下，如果没有mysql 包，要我们自己实现一套与数据库引擎通信的代码该有多难。"}),"\n",(0,t.jsx)(e.p,{children:"当然，除了 MySQL 数据库外，还有 SQL Server 等传统数据库，还有 Redis 等非关系型数据库。不过无需担心，对于这些数据库的支持包都可以在 Go 语言官方的 Package 网站上找到。"}),"\n",(0,t.jsx)(e.p,{children:"最后，非常建议大家去 Go 官方的 Package 网站上浏览一番。很快便会发现，除了数据库外，还有很多已经打包好的可供使用的包。当我们日后开发时，不妨先搜索一下，或许已有现成的方案，直接集成即可。"}),"\n",(0,t.jsx)(e.p,{children:"好了，本讲就到这里。"}),"\n",(0,t.jsx)(e.p,{children:"➡️ 在下次课程中，我们会介绍Go语言中的并发，具体内容是："}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Go 语言并发初探"}),"\n"]})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}let o=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC24%E7%AB%A0%E2%80%94%E5%8C%85%E4%BA%94%EF%BD%9C%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93.md"]={toc:[{text:"集成包",id:"集成包",depth:2},{text:"实现网络请求的响应",id:"实现网络请求的响应",depth:2},{text:"建立连接",id:"建立连接",depth:2},{text:"创建数据表",id:"创建数据表",depth:2},{text:"数据的增、删、改操作",id:"数据的增删改操作",depth:2},{text:"数据的查询操作",id:"数据的查询操作",depth:2},{text:"总结",id:"总结",depth:2}],title:"第24章—包五｜持久化存储之数据库",headingTitle:"第24章—包五｜持久化存储之数据库",frontmatter:{}}}}]);