"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["32511"],{674730:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var t=r(552676),s=r(740453);let i=r.p+"static/image/54d2cbab5a974ea5b178b7f6c875d636.8133c475.webp",c=r.p+"static/image/dc1013d0a6af7c88ee277c71d8efe471.17abe04b.gif",a=r.p+"static/image/da53498bac82ab4e2ae65bac49376709.0b3f5f1c.webp",l=r.p+"static/image/a6c40f3257d7c8f2744ded069e713678.b0f5abc5.webp",o=r.p+"static/image/b49c3c592b58968cb854581e09b3c5ad.6a900df3.webp",d=r.p+"static/image/9ec5a2fb6742c06e1aa7870f6b726a8e.0c73d661.webp",h=r.p+"static/image/237997712c6340b2dfb94e24305b7541.3bd9ec99.gif";function p(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",blockquote:"blockquote",img:"img",ol:"ol",li:"li"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"66源码篇-_-手写-rsc下",children:["66.源码篇 _ 手写 RSC（下）",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#66源码篇-_-手写-rsc下",children:"#"})]}),"\n",(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["在",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309116337833148454",target:"_blank",rel:"noopener noreferrer",children:"《源码篇 | 手写 RSC（上）》"}),"中，我们实现了 React SSR 并添加了路由跳转，最终的效果如下："]}),"\n",(0,t.jsxs)(n.p,{children:["当我们点击 ",(0,t.jsx)(n.code,{children:"hello"}),"链接的时候，页面从 ",(0,t.jsx)(n.code,{children:"/"}),"跳转到 ",(0,t.jsx)(n.code,{children:"/hello"}),"，两个页面都是 SSR 加载。"]}),"\n",(0,t.jsxs)(n.p,{children:["但理想情况下，我们想要的效果是，仅更改需要更改的地方，而其他的地方继续保持原本的状态。不过当前的例子中并无所谓“状态”，为了演示状态的保持，我们在 ",(0,t.jsx)(n.code,{children:"<Layout>"})," 组件中添加一个 ",(0,t.jsx)(n.code,{children:"<input />"})," 标签，修改 ",(0,t.jsx)(n.code,{children:"components.ts"}),"下的 ",(0,t.jsx)(n.code,{children:"<Layout>"})," 组件代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'export function Layout({ children }) {\n  const author = "YaYu";\n  return (\n    <html>\n      <head>\n        <title>My blog</title>\n        <script src="https://cdn.tailwindcss.com"><\/script>\n      </head>\n      <body className="p-5">\n        <nav className="flex items-center justify-center gap-10 text-blue-600">\n          <a href="/">Home</a>\n        </nav>\n        <input required className="block w-full rounded-md border-0 px-1.5 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6" />\n        <main>{children}</main>\n        <Footer author={author} />\n      </body>\n    </html>\n  );\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"我们先在输入框输入一些数据再点击链接跳转，交互效果如下："}),"\n",(0,t.jsx)(n.p,{children:"结果很容易想到，页面跳转后，输入框被重置。对于两次 SSR 来说，因为每次都是重新渲染，所以状态无法保持。"}),"\n",(0,t.jsx)(n.p,{children:"但为了更好的用户体验，我们想要的效果是，在发生页面跳转的时候，仅更改需要更改的地方，其他的地方继续保持原本的状态。也就是说，在这个例子中，输入框的内容应该继续保持不变。"}),"\n",(0,t.jsx)(n.p,{children:"那你可能会问，这不就是 CSR？如果还要控制页面跳转，这不一个就是基于 CSR 的 SPA 应用吗？"}),"\n",(0,t.jsx)(n.p,{children:"单论这个效果而言，传统 SPA 确实也能实现，RSC 也能实现，而 CSR 和 RSC 的区别就在于 CSR 组件的渲染在客户端，RSC 组件的渲染在服务端。"}),"\n",(0,t.jsx)(n.p,{children:"那用 RSC 该怎么实现呢？"}),"\n",(0,t.jsxs)(n.h2,{id:"实现思路",children:["实现思路",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现思路",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["我们在",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309116396511133705",target:"_blank",rel:"noopener noreferrer",children:"《源码篇 | 手写 React SSR》"}),"介绍过 React 的 ",(0,t.jsx)(n.a,{href:"https://react.dev/reference/react-dom/client/hydrateRoot",target:"_blank",rel:"noopener noreferrer",children:"hydrateRoot"})," 函数："]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"hydrateRoot 允许您在浏览器 DOM 节点内显示 React 组件，该节点的 HTML 内容先前由 react-dom/server 生成。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"简单的来就是，先通过 react-dom/server 将 JSX 渲染成 HTML，再调用 hydrateRoot 将其水合，添加事件。基本用法如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { hydrateRoot } from 'react-dom/client';\n\nconst domNode = document.getElementById('root');\nconst root = hydrateRoot(domNode, reactNode);\n"})}),"\n",(0,t.jsx)(n.p,{children:"当调用 hydrateRoot 后就会由 React 接管 DOM，而 React 又提供了 root.render 方法来更新 DOM："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"react-rsc-4.gif"})}),"\n",(0,t.jsx)(n.p,{children:"在上图中，我们每秒都调用了一次 root.render，但输入框中的状态并未遭到破坏，这就是我们实现 React Server Component 的关键。"}),"\n",(0,t.jsx)(n.p,{children:"那我们具体该怎么实现呢？简单的来说，可以分为 3 个步骤："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"拦截客户端跳转，实现客户端 JS 导航"}),"\n",(0,t.jsx)(n.li,{children:"导航的时候，获取目标路由的 JSX 对象"}),"\n",(0,t.jsx)(n.li,{children:"客户端获取返回的 JSX 对象调用 root.render 进行重新渲染"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"如果这样说还是有点抽象，那就让我们直接上代码吧！"}),"\n",(0,t.jsxs)(n.h2,{id:"步骤-1实现客户端导航",children:["步骤 1：实现客户端导航",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤-1实现客户端导航",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们先拦截传统的页面跳转，将其转为客户端导航。"}),"\n",(0,t.jsxs)(n.p,{children:["新建 ",(0,t.jsx)(n.code,{children:"client.js"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'let currentPathname = window.location.pathname;\n\nasync function navigate(pathname) {\n  currentPathname = pathname;\n  // 获取导航页面的 HTML\n  const response = await fetch(pathname);\n  const html = await response.text();\n\n  if (pathname === currentPathname) {\n    //  获取其中的 body 标签内容\n    const res = /<body(.*?)>/.exec(html);\n    const bodyStartIndex = res.index + res[0].length\n    const bodyEndIndex = html.lastIndexOf("</body>");\n    const bodyHTML = html.slice(bodyStartIndex, bodyEndIndex);\n    // 简单粗暴的直接替换 HTML\n    document.body.innerHTML = bodyHTML;\n  }\n}\n\nwindow.addEventListener("click", (e) => {\n  // 忽略非 <a> 标签点击事件\n  if (e.target.tagName !== "A") {\n    return;\n  }\n  // 忽略 "open in a new tab".\n  if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {\n    return;\n  }\n  // 忽略外部链接\n  const href = e.target.getAttribute("href");\n  if (!href.startsWith("/")) {\n    return;\n  }\n  // 组件浏览器重新加载页面\n  e.preventDefault();\n  // 但是 URL 还是要更新\n  window.history.pushState(null, null, href);\n  // 调用我们自己的导航逻辑\n  navigate(href);\n}, true);\n\nwindow.addEventListener("popstate", () => {\n  // 处理浏览器前进后退事件\n  navigate(window.location.pathname);\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["在这段代码中，我们监听了 ",(0,t.jsx)(n.code,{children:"<a>"})," 标签的点击事件，当发生点击的时候，调用我们自己的 navigate 函数，在 navigate 中，我们 fetch 了目标路由的 HTML，提取 ",(0,t.jsx)(n.code,{children:"<body>"}),"标签中内容，替换当前页面。"]}),"\n",(0,t.jsxs)(n.p,{children:["可是页面怎么引入这个 ",(0,t.jsx)(n.code,{children:"client.js"}),"呢？简单的来说，就是直接拼进去，修改 ",(0,t.jsx)(n.code,{children:"generator.tsx"}),"的 htmlGenerator 函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'export async function htmlGenerator(url) {\n  let html = await renderJSXToHTML(<Router url={url} />);\n  // 直接拼虽然有些错误，但浏览器会纠正，并正确解析\n  html += `<script type="module" src="/client.js"><\/script>`;\n  return html;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"index.ts"}),"，保证服务器正确返回 client.js 的内容，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'app.get("/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n\n  // 匹配 client.js\n  if (url.pathname === "/client.js") {\n    const content = await readFile("./client.js", "utf8");\n    res.setHeader("Content-Type", "text/javascript");\n    res.end(content);\n  } \n  else {\n    const html = await htmlGenerator(url);\n    res.setHeader("Content-Type", "text/html");\n    res.end(html);\n  }\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"此时交互效果如下："}),"\n",(0,t.jsx)(n.p,{children:"因为我们是直接替换的 HTML，所以状态的保持依然没有实现，但是页面已经转为了客户端导航，当我们点击链接跳转的时候，页面并没有刷新。"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"功能实现：React RSC 实现"}),"\n",(0,t.jsxs)(n.li,{children:["源码地址：",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-6",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-6"})]}),"\n",(0,t.jsxs)(n.li,{children:["下载代码：",(0,t.jsx)(n.code,{children:"git clone -b react-rsc-6 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"步骤-2获取客户端-jsx",children:["步骤 2：获取客户端 JSX",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤-2获取客户端-jsx",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["按照我们的思路，当点击跳转的时候，应该获取目标路由的 JSX 对象，然后在客户端重新渲染。为了区分是获取目标路由的 HTML 还是 JSX 对象，我们可以在链接上添加一个 ",(0,t.jsx)(n.code,{children:"jsx"})," 参数作为区分。"]}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"client.js"}),"，更改 navigate 函数的代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'async function navigate(pathname) {\n  currentPathname = pathname;\n  // 添加 jsx 参数表示获取目标路由的 jsx 对象\n  const response = await fetch(pathname + "?jsx");\n  const jsonString = await response.text();\n  if (pathname === currentPathname) {\n    console.log(jsonString);\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"index.ts"}),"，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { htmlGenerator, jsxGenerator } from "./generator";\n\napp.get("/:route(*)", async (req, res) => {\n  const url = new URL(req.url, `http://${req.headers.host}`);\n\n  if (url.pathname === "/client.js") {\n    const content = await readFile("./client.js", "utf8");\n    res.setHeader("Content-Type", "text/javascript");\n    res.end(content);\n  }\n  // 如果网址有 jsx 参数，那就说明要获取 JSX 对象，我们改为调用 jsxGenerator 函数\n  else if (url.searchParams.has("jsx")) {\n    url.searchParams.delete("jsx");\n    const clientJSXString = await jsxGenerator(url);\n    res.setHeader("Content-Type", "application/json");\n    res.end(clientJSXString);\n  } \n  else {\n    const html = await htmlGenerator(url);\n    res.setHeader("Content-Type", "text/html");\n    res.end(html);\n  }\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["在 ",(0,t.jsx)(n.code,{children:"generator.tsx"})," 添加 jsxGenerator 函数，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export async function jsxGenerator(url) {\n  let jsx = <Router url={url} />;\n  // 查看服务段的打印结果\n  console.dir(jsx)\n  return JSON.stringify(jsx)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"然而此时，当点击跳转的时候，获取目标路径的  JSX 对象，但返回的数据却不如人意："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"我们再查看下命令行中的打印结果："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"这里存在两个问题："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["我们渲染的是 ",(0,t.jsx)(n.code,{children:"<Router url={url} />"}),"，这个 JSX 节点是一个函数类型，只有运行这个函数才会返回最终的 JSX 对象"]}),"\n",(0,t.jsxs)(n.li,{children:["使用 JSON.stringify 会丢失部分属性，就比如 ",(0,t.jsx)(n.code,{children:'$$typeof: Symbol.for("react.element")'}),"，而客户端 React 正是根据这个属性判断是否是有效的 JSX 节点"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["为了解决第一个问题，我们需要再写一个 renderJSXToClientJSX 函数，将 JSX 对象转为最终的 JSX 对象。修改 ",(0,t.jsx)(n.code,{children:"utils.ts"}),"，添加 renderJSXToClientJSX 函数，其代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'export async function renderJSXToClientJSX(jsx) {\n  if (\n    typeof jsx === "string" ||\n    typeof jsx === "number" ||\n    typeof jsx === "boolean" ||\n    jsx == null\n  ) {\n    return jsx;\n  } else if (Array.isArray(jsx)) {\n    return Promise.all(jsx.map((child) => renderJSXToClientJSX(child)));\n  } else if (jsx != null && typeof jsx === "object") {\n    if (jsx.$$typeof === Symbol.for("react.element")) {\n      if (typeof jsx.type === "string") {\n        return {\n          ...jsx,\n          props: await renderJSXToClientJSX(jsx.props),\n        };\n      } else if (typeof jsx.type === "function") {\n        const Component = jsx.type;\n        const props = jsx.props;\n        const returnedJsx = await Component(props);\n        return renderJSXToClientJSX(returnedJsx);\n      } else throw new Error("Not implemented.");\n    } else {\n      return Object.fromEntries(\n        await Promise.all(\n          Object.entries(jsx).map(async ([propName, value]) => [\n            propName,\n            await renderJSXToClientJSX(value),\n          ])\n        )\n      );\n    }\n  } else throw new Error("Not implemented");\n}\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"generate.ts"}),"，引入 renderJSXToClientJSX，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { renderJSXToHTML, renderJSXToClientJSX } from './utils'\n\nexport async function jsxGenerator(url) {\n  let clientJSX = await renderJSXToClientJSX(<Router url={url} />);\n  const clientJSXString = JSON.stringify(clientJSX);\n  return clientJSXString\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"此时返回的结果看起来正确多了："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"现在我们来解决第二个问题，解决的方式也很简单，那就是我们在 JSON.stringify 的时候将特殊的对象使用特殊的字符串进行替换，客户端 JSON.parse 的时候再转过来。正好 JSON.stringify 接收一个替换器函数，该函数允许我们自定义 JSON 的生成方式。在服务端，我们将 Symbol.for('react.element') 用一个特殊的字符串来替换，例如\"$RE\"。"}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"utils.ts"}),"，添加 stringifyJSX 函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'export function stringifyJSX(key, value) {\n  if (value === Symbol.for("react.element")) {\n    // We can\'t pass a symbol, so pass our magic string instead.\n    return "$RE"; // Could be arbitrary. I picked RE for React Element.\n  } else if (typeof value === "string" && value.startsWith("$")) {\n    // To avoid clashes, prepend an extra $ to any string already starting with $.\n    return "$" + value;\n  } else {\n    return value;\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"generator.tsx"}),"，引入 stringifyJSX，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"\nimport { renderJSXToHTML, renderJSXToClientJSX, stringifyJSX } from './utils'\n\nexport async function jsxGenerator(url) {\n  let clientJSX = await renderJSXToClientJSX(<Router url={url} />);\n  const clientJSXString = JSON.stringify(clientJSX, stringifyJSX);\n  return clientJSXString\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"此时我们点击链接，已经能够正常的获取客户端 JSX 对象："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"功能实现：React RSC 实现"}),"\n",(0,t.jsxs)(n.li,{children:["源码地址：",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-7",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-7"})]}),"\n",(0,t.jsxs)(n.li,{children:["下载代码：",(0,t.jsx)(n.code,{children:"git clone -b react-rsc-7 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"步骤-3客户端更新",children:["步骤 3：客户端更新",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤-3客户端更新",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"现在我们就需要在导航的时候，调用 root.render 来更新应用。"}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"client.js"}),"，添加代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { hydrateRoot } from \'react-dom/client\';\n\nlet currentPathname = window.location.pathname;\nconst root = hydrateRoot(document, getInitialClientJSX());\n\nfunction getInitialClientJSX() {\n  // 暂时先返回 null\n  return null\n}\n\nasync function navigate(pathname) {\n  currentPathname = pathname;\n  const clientJSX = await fetchClientJSX(pathname);\n  if (pathname === currentPathname) {\n    root.render(clientJSX);\n  }\n}\n\nasync function fetchClientJSX(pathname) {\n  const response = await fetch(pathname + "?jsx");\n  const clientJSXString = await response.text();\n  const clientJSX = JSON.parse(clientJSXString, parseJSX);\n  return clientJSX;\n}\n\nfunction parseJSX(key, value) {\n  if (value === "$RE") {\n    return Symbol.for("react.element");\n  } else if (typeof value === "string" && value.startsWith("$$")) {\n    return value.slice(1);\n  } else {\n    return value;\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["我们在客户端代码中引用了 react-dom/client，为了能够正常运行，我们修改 ",(0,t.jsx)(n.code,{children:"generator.tsx"})," 的 htmlGenerator 函数，代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-jsx",children:'export async function htmlGenerator(url) {\n  let html = await renderJSXToHTML(<Router url={url} />);\n  html += `\n  <script type="importmap">\n    {\n      "imports": {\n        "react": "https://esm.sh/react@18.2.0",\n        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"\n      }\n    }\n  <\/script>\n  <script type="module" src="/client.js"><\/script>\n`;\n  return html;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["注：关于 ",(0,t.jsx)(n.code,{children:'<script type="importmap">'}),"，可以参考 ",(0,t.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script/type/importmap",target:"_blank",rel:"noopener noreferrer",children:"MDN"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"此时交互效果如下："}),"\n",(0,t.jsx)(n.p,{children:"交互效果可以说是十分奇怪，但主要是 2 个问题："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"首次导航的时候，状态无法保持，后续可以正常保持"}),"\n",(0,t.jsx)(n.li,{children:"导航的时候，样式丢失了"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"我们先解决第一个问题。这是因为我们首次水合页面的时候，并未传入当前页面的客户端 JSX 对象，导致首次水合的时候，React 的组件树其实是空的，点击跳转的时候，获取了新的组件树，因为完全不同，所以页面重新渲染，状态也没有保持。调用 root.render，React 会保留该状态，也要建立在组件树结构与之前渲染的结构匹配的基础上。所以后续导航的时候，都保持了状态。"}),"\n",(0,t.jsx)(n.p,{children:"那么如何获取当前页面的客户端 JSX 对象呢？最简单的方法就是写入到脚本代码中，然后渲染的时候直接读取。"}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"generator.tsx"}),"的 htmlGenerator 函数："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'export async function htmlGenerator(url) {\n  let jsx = <Router url={url} />\n  let html = await renderJSXToHTML(jsx);\n  // 获取当前页面的客户端 JSX 对象\n  const clientJSX = await renderJSXToClientJSX(jsx);\n  // 拼接到脚本代码中\n  const clientJSXString = JSON.stringify(clientJSX, stringifyJSX);\n  html += `<script>window.__INITIAL_CLIENT_JSX_STRING__ = `;\n  html += JSON.stringify(clientJSXString).replace(/</g, "\\\\u003c");\n  html += `<\/script>`;\n  html += `\n  <script type="importmap">\n    {\n      "imports": {\n        "react": "https://esm.sh/react@18.2.0",\n        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"\n      }\n    }\n  <\/script>\n  <script type="module" src="/client.js"><\/script>\n`;\n  return html;\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"client.js"}),"，在水合的时候获取页面的客户端 JSX 对象："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const root = hydrateRoot(document, getInitialClientJSX());\n\nfunction getInitialClientJSX() {\n  const clientJSX = JSON.parse(window.__INITIAL_CLIENT_JSX_STRING__, parseJSX);\n  return clientJSX;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["修改 ",(0,t.jsx)(n.code,{children:"utils.ts"}),"中的 renderJSXToHTML 函数，做了一点字符节点的处理，为了保持客户端和服务端渲染一致，以便进行水合："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'export async function renderJSXToHTML(jsx) {\n  if (typeof jsx === "string" || typeof jsx === "number") {\n    return escapeHtml(jsx);\n  } else if (jsx == null || typeof jsx === "boolean") {\n    return "";\n  } else if (Array.isArray(jsx)) {\n    const childHtmls = await Promise.all(\n      jsx.map((child) => renderJSXToHTML(child))\n    );\n    // 字符之间拼接 "\x3c!-- --\x3e"\n    let html = "";\n    let wasTextNode = false;\n    let isTextNode = false;\n    for (let i = 0; i < jsx.length; i++) {\n      isTextNode = typeof jsx[i] === "string" || typeof jsx[i] === "number";\n      if (wasTextNode && isTextNode) {\n        html += "\x3c!-- --\x3e";\n      }\n      html += childHtmls[i];\n      wasTextNode = isTextNode;\n    }\n    return html;\n    // return childHtmls.join("");\n  } else if (typeof jsx === "object") {\n    if (jsx.$$typeof === Symbol.for("react.element")) {\n      // 普通 HTML 标签\n      if (typeof jsx.type === "string") {\n        let html = "<" + jsx.type;\n        for (const propName in jsx.props) {\n          if (jsx.props.hasOwnProperty(propName) && propName !== "children") {\n            html += " ";\n            html += propName;\n            html += "=";\n            html += `"${escapeHtml(jsx.props[propName])}"`;\n          }\n        }\n        html += ">";\n        html += await renderJSXToHTML(jsx.props.children);\n        html += "</" + jsx.type + ">";\n        html = html.replace(/className/g, "class")\n        return html;\n      }\n      // 组件类型如 <BlogPostPage> \n      else if (typeof jsx.type === "function") {\n        const Component = jsx.type;\n        const props = jsx.props;\n        const returnedJsx = await Component(props);\n        return renderJSXToHTML(returnedJsx); \n      } else throw new Error("Not implemented.");\n    } else throw new Error("Cannot render an object.");\n  } else throw new Error("Not implemented.");\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"此时状态已经能够正常保持，不仅如此，页面样式也正常了："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"react-rsc-7.gif"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"功能实现：React RSC 实现"}),"\n",(0,t.jsxs)(n.li,{children:["源码地址：",(0,t.jsx)(n.a,{href:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-8",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-8"})]}),"\n",(0,t.jsxs)(n.li,{children:["下载代码：",(0,t.jsx)(n.code,{children:"git clone -b react-rsc-8 git@github.com:mqyqingfeng/next-app-demo.git"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"现在我们已经实现了 RSC 和状态保持，其实现的主要思路是监听客户端跳转，改为获取目标路由的客户端 JSX 对象，然后调用 root.render 进行更新，在前后组件树匹配的基础上，状态会继续保持。"}),"\n",(0,t.jsxs)(n.p,{children:["不过为什么之前样式会丢失呢？这是因为我们的 tailwind.css 用的是 ",(0,t.jsx)(n.code,{children:'<script src="https://cdn.tailwindcss.com"><\/script>'}),"的方式直接引入的，它会在 ",(0,t.jsx)(n.code,{children:"<head>"})," 中生成 ",(0,t.jsx)(n.code,{children:"<style>"})," 标签："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"之前首次导航的时候，前后组件树不匹配，React 使用新的组件树重新渲染了 DOM，导致 style 标签中的内容消失，这才丢失了样式。"}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["至此，我们已经实现了 RSC，想想我们的 Next.js 应用，是不是也是客户端导航，虽然 Next.js 内置 ",(0,t.jsx)(n.code,{children:"<Link>"}),"的标签被渲染为 ",(0,t.jsx)(n.code,{children:"<a>"}),"标签，但并不会触发页面重新加载，而是会获取对应页面的 RSC Payload，只不过我们的实现，获取的是目标路由的客户端 JSX 对象，而 Next.js 获取的是基于 JSX 对象生成的、对流做过特殊适配的二进制格式，但基本原理是类似的。"]}),"\n",(0,t.jsxs)(n.p,{children:["感谢 Dan 的这篇文章 ",(0,t.jsx)(n.a,{href:"https://github.com/reactwg/server-components/discussions/5",target:"_blank",rel:"noopener noreferrer",children:"《RSC From Scratch. Part 1: Server Components》 "}),"，其实这 2 篇实现就是参考了 Dan 的实现,用 express 和 tsx 来实现了一遍。希望对大家理解 React 和 Next.js 的 RSC 有所帮助。"]})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F66.%E6%BA%90%E7%A0%81%E7%AF%87%20_%20%E6%89%8B%E5%86%99%20RSC%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"实现思路",id:"实现思路",depth:2},{text:"步骤 1：实现客户端导航",id:"步骤-1实现客户端导航",depth:2},{text:"步骤 2：获取客户端 JSX",id:"步骤-2获取客户端-jsx",depth:2},{text:"步骤 3：客户端更新",id:"步骤-3客户端更新",depth:2},{text:"总结",id:"总结",depth:2}],title:"66.源码篇 _ 手写 RSC（下）",headingTitle:"66.源码篇 _ 手写 RSC（下）",frontmatter:{}}}}]);