"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["45367"],{864581:function(e,n,s){s.r(n),s.d(n,{default:()=>o});var a=s(552676),t=s(740453);function r(e){let n=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",code:"code",pre:"pre",ul:"ul",li:"li",br:"br"},(0,t.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"15-memory实现自定义-memory-存储",children:["15-Memory：实现自定义 Memory 存储",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#15-memory实现自定义-memory-存储",children:"#"})]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsxs)(n.p,{children:["本章对应源代码：",(0,a.jsx)(n.a,{href:"https://github.com/RealKai42/langchainjs-juejin/blob/main/memory-3.ipynb",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/RealKai42/langchainjs-juejin/blob/main/memory-3.ipynb"})]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"这一章，让我们走的更深一点，首先我们会讲解目前处于 beta 阶段的 memory 如何跟 LCEL 开发范式结合，让大家更方便的复用 langchain 内置的 memory。"}),"\n",(0,a.jsx)(n.p,{children:"同时，这一章我们将学习如何持久化 chat history，langchain 提供了跟各种数据库和云数据库的集成方案，但因为真实业务中的种种限制，我们需要自己实现跟业务数据库契合的持久化方案，我们会带大家写一个简单的 customized chat history，给大家参考。"}),"\n",(0,a.jsxs)(n.h2,{id:"在-lcel-中集成-memory",children:["在 LCEL 中集成 memory",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#在-lcel-中集成-memory",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["如果我们想在 LCEL 中集成 memory，我们先看 ",(0,a.jsx)(n.code,{children:"BaseMemory"})," 的接口定义，在源码中的定义文件在：",(0,a.jsx)(n.a,{href:"https://github.com/langchain-ai/langchainjs/blob/main/langchain-core/src/memory.ts",target:"_blank",rel:"noopener noreferrer",children:"memory.ts"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"export abstract class BaseMemory {\n  abstract get memoryKeys(): string[];\n\n  /**\n   * Abstract method that should take an object of input values and return a\n   * Promise that resolves with an object of memory variables. The\n   * implementation of this method should load the memory variables from the\n   * provided input values.\n   * @param values An object of input values.\n   * @returns Promise that resolves with an object of memory variables.\n   */\n  abstract loadMemoryVariables(values: InputValues): Promise<MemoryVariables>;\n\n  /**\n   * Abstract method that should take two objects, one of input values and\n   * one of output values, and return a Promise that resolves when the\n   * context has been saved. The implementation of this method should save\n   * the context based on the provided input and output values.\n   * @param inputValues An object of input values.\n   * @param outputValues An object of output values.\n   * @returns Promise that resolves when the context has been saved.\n   */\n  abstract saveContext(\n    inputValues: InputValues,\n    outputValues: OutputValues\n  ): Promise<void>;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"可以看到其核心就是就是两个方法，并且有非常详细的注释："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"loadMemoryVariables"}),"，返回当前记忆的内容，如果有些记忆是依赖于输入的，例如 ",(0,a.jsx)(n.code,{children:"EntityMemory"}),"，就需要传入一些输入，让 memory 返回对应输入的记忆。 在 ",(0,a.jsx)(n.code,{children:"EntityMemory"})," 的场景下，就是 memory 需要根据传入的信息提取输入中的实体，并且返回实体中相关的记忆"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"saveContext"}),"，就是将对话存入到 memory 中，也就是需要传入用户的输入 ",(0,a.jsx)(n.code,{children:"inputValues"}),"，和模型的输出 ",(0,a.jsx)(n.code,{children:"OutputValues"})]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"BaseMemory"})," 是所有 memory 都需要继承的接口，也就是我们参考这个接口去在 LCEL 中引入 memory，就能保证引入的方式对所有 memory 有效。"]}),"\n",(0,a.jsxs)(n.p,{children:["如果大家对 ",(0,a.jsx)(n.code,{children:"ConversationChain"})," 是如何使用 memory 的，可以参考:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"langchain/src/chains/conversation.ts"}),"\n",(0,a.jsx)(n.li,{children:"langchain/src/chains/llm_chain.ts"}),"\n",(0,a.jsx)(n.li,{children:"langchain/src/chains/base.ts"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["这里我们就不展开讲解了，我们直接看如何在 LCEL 中使用 memory，我们这里以 ",(0,a.jsx)(n.code,{children:"BufferMemory"})," 举例，其他的 memory 也是类似的机制："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const chatModel = new ChatOpenAI({\n    verbose:true\n});\nconst memory = new BufferMemory();\n\nconst TEMPLATE = `\n你是一个乐于助人的 ai 助手。尽你所能回答所有问题。\n\n这是跟人类沟通的聊天历史:\n{history}\n\n据此回答人类的问题:\n{input}\n`\nconst prompt = ChatPromptTemplate.fromTemplate(TEMPLATE);\n"})}),"\n",(0,a.jsx)(n.p,{children:"这里我们创建了基础 chatModal、memory 和 prompt，然后："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'let tempInput = ""\n\nconst chain =  RunnableSequence.from([\n    {\n        input: new RunnablePassthrough(),\n        memoryObject: async (input) => {\n            const history = await memory.loadMemoryVariables({\n                input\n            })\n            tempInput = input\n            return history\n        }\n    },\n    RunnablePassthrough.assign({\n        history: (input) => input.memoryObject.history\n    }),\n    prompt,\n    chatModel,\n    new StringOutputParser(),\n    new RunnablePassthrough({\n        func: async (output) => {\n            await memory.saveContext({\n                input: tempInput\n            }, {\n                output\n            })\n        }\n    }),\n]);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["这里我们使用 ",(0,a.jsx)(n.code,{children:"tempInput"})," 去临时存储用户的 input 输入，这是因为在 LCEL 整个链条中， prompt 之后的中间值是单独的 PromptValue、chatModel 之后就是单纯的 AIMessage，很难在这一部分将用户初始的 input 传递到后面，所以我们还是用临时变量去进行存储比较方便。"]}),"\n",(0,a.jsxs)(n.p,{children:["在 chain 中的第一个对象，我们首先是使用 ",(0,a.jsx)(n.code,{children:"new RunnablePassthrough()"})," 对 input 进行透传，然后创建一个函数（函数也是 Runnable 对象），以用户的 input 作为输入，使用 ",(0,a.jsx)(n.code,{children:"loadMemoryVariables"})," 去加载出 memory 中的数据，并将用户的输入保存到 ",(0,a.jsx)(n.code,{children:"tempInput"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:["这里加载出来的 history 对象是一个 object，其中是 memory 根据用户这次 input 返回的数据，如果是 ",(0,a.jsx)(n.code,{children:"BufferMemory"}),"，则里面只有只有一个 ",(0,a.jsx)(n.code,{children:"history"})," key。其他的 memory 就要根据不同的类型，返回的数据也是不一样的，例如 ",(0,a.jsx)(n.code,{children:"EntityMemory"})," 就会有 ",(0,a.jsx)(n.code,{children:"history"})," 和 ",(0,a.jsx)(n.code,{children:"entities"})," 两个 key。"]}),"\n",(0,a.jsxs)(n.p,{children:["所以，在 chain 的第二个节点，我们就 ",(0,a.jsx)(n.code,{children:"RunnablePassthrough.assign()"})," 提取出来 ",(0,a.jsx)(n.code,{children:"memoryObject"})," 中的 ",(0,a.jsx)(n.code,{children:"history"})," 值。 assign 会在上一个节点输入的基础上，再添加新的数据。 这样后面的 prompt 就接收到了 history 和 input 两个输入值。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"prompt"}),"、",(0,a.jsx)(n.code,{children:"chatModel"}),"、",(0,a.jsx)(n.code,{children:"new StringOutputParser()"})," 就是基础的使用 prompt 激发 llm 输出内容，然后使用 ",(0,a.jsx)(n.code,{children:"StringOutputParser"})," 去提取出纯文本的内容。"]}),"\n",(0,a.jsxs)(n.p,{children:["最后一个节点，我们使用 ",(0,a.jsx)(n.code,{children:"RunnablePassthrough"})," 去执行一个函数，将用户的输入和输出使用 ",(0,a.jsx)(n.code,{children:"saveContext"})," 存储到 memory 中。"]}),"\n",(0,a.jsxs)(n.p,{children:["至此，我们通过查看 langchain 源代码中 ",(0,a.jsx)(n.code,{children:"BaseMemory"})," 的定义，去理解 memory 应该如何存储和读取数据，并通过对 LCEL 中 RunnablePassthrough 的灵活使用，去将 memory 融合到 LCEL 中。"]}),"\n",(0,a.jsx)(n.p,{children:"LCEL 编程范式是一种链式的编程范式，可能刚上手跟我们传统的编程有些区别，但自己多写一些 LCEL chain，感受一下节点之间传递的内容，就能逐渐学会其中的思想。"}),"\n",(0,a.jsx)(n.p,{children:"如果是在学习 LCEL 中，可以使用下面这个技巧去打印 chain 中间传递的内容，去慢慢理解数据是在 chain 中是如何流动的。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"[\n...\nprompt,\nnew RunnablePassthrough({\n    func: (input) => console.log(input)\n}),\nchatModel,\n...\n]\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"实现自定义的-chat-history",children:["实现自定义的 chat history",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现自定义的-chat-history",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["Memory 的底层是 chat history，所有的 memory 都支持在创建的时候传入任意的 chathistory，如果我们没有传入，则 memory 会自己创建一个存储在内存的 chat history。",(0,a.jsx)(n.br,{}),"\n","我们再回忆一下，chat history 是原封不动的记录用户和 llm 的聊天记录，memory 是基于内部的 chat history 进行一些处理形成的记忆，所以任何 memory 内部都会有一个记录所有 history 的 chat history。"]}),"\n",(0,a.jsx)(n.p,{children:"langchain 内部提供跟很多数据库集成的 chat history，例如常见的 MongoDB、Redis 都有，但在真实业务中我们有时候很难随意选择后端的数据库，大多数需要存储在现有的基建中，而这些基建 langchain 并没有提供对应的集成，或者集成有一些小问题跟现有基建集成在一起。"}),"\n",(0,a.jsx)(n.p,{children:"所以这一节中，我们会带大家实现一个基础的 customized chat history，并把文件存储在本地的 json 文件中。既可以让大家在测试和开发的时候将多次聊天存储在本地，也可以作为范例让大家学习如何集成到自己当前的数据库中。"}),"\n",(0,a.jsxs)(n.p,{children:["我们先看 BaseListChatMessageHistory 的源码：",(0,a.jsx)(n.a,{href:"https://github.com/langchain-ai/langchainjs/blob/d26233d89148c123540ed93af63ab3fb1f0ac1ac/langchain-core/src/chat_history.ts",target:"_blank",rel:"noopener noreferrer",children:"code"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"export declare abstract class BaseListChatMessageHistory extends Serializable {\n    /** Returns a list of messages stored in the store. */\n    abstract getMessages(): Promise<BaseMessage[]>;\n    /**\n     * Add a message object to the store.\n     */\n    abstract addMessage(message: BaseMessage): Promise<void>;\n    /**\n     * This is a convenience method for adding a human message string to the store.\n     * Please note that this is a convenience method. Code should favor the\n     * bulk addMessages interface instead to save on round-trips to the underlying\n     * persistence layer.\n     * This method may be deprecated in a future release.\n     */\n    addUserMessage(message: string): Promise<void>;\n    /** @deprecated Use addAIMessage instead */\n    addAIChatMessage(message: string): Promise<void>;\n    /**\n     * This is a convenience method for adding an AI message string to the store.\n     * Please note that this is a convenience method. Code should favor the bulk\n     * addMessages interface instead to save on round-trips to the underlying\n     * persistence layer.\n     * This method may be deprecated in a future release.\n     */\n    addAIMessage(message: string): Promise<void>;\n    /**\n     * Add a list of messages.\n     *\n     * Implementations should override this method to handle bulk addition of messages\n     * in an efficient manner to avoid unnecessary round-trips to the underlying store.\n     *\n     * @param messages - A list of BaseMessage objects to store.\n     */\n    addMessages(messages: BaseMessage[]): Promise<void>;\n    /**\n     * Remove all messages from the store.\n     */\n    clear(): Promise<void>;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，addUserMessage、addAIChatMessage、addAIMessage 都是将要 deprecated 的函数，真正我们需要实现的就是："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"getMessages：获取存储在 history 中所有聊天记录"}),"\n",(0,a.jsx)(n.li,{children:"addMessage：添加单条 message"}),"\n",(0,a.jsx)(n.li,{children:"addMessages：添加 message 数组"}),"\n",(0,a.jsx)(n.li,{children:"clear：清空聊天记录"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"是比较好理解的结构，让我们看完整的代码："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'import { BaseListChatMessageHistory } from "@langchain/core/chat_history";\nimport {\n  BaseMessage,\n  StoredMessage,\n  mapChatMessagesToStoredMessages,\n  mapStoredMessagesToChatMessages,\n} from "@langchain/core/messages";\nimport fs from "node:fs";\nimport path from "node:path";\n\nexport interface JSONChatHistoryInput {\n  sessionId: string;\n  dir: string;\n}\n\nexport class JSONChatHistory extends BaseListChatMessageHistory {\n  lc_namespace = ["langchain", "stores", "message"];\n\n  sessionId: string;\n  dir: string;\n\n  constructor(fields: JSONChatHistoryInput) {\n    super(fields);\n    this.sessionId = fields.sessionId;\n    this.dir = fields.dir;\n  }\n\n  async getMessages(): Promise<BaseMessage[]> {\n    const filePath = path.join(this.dir, `${this.sessionId}.json`);\n    try {\n      if (!fs.existsSync(filePath)) {\n        this.saveMessagesToFile([]);\n        return [];\n      }\n\n      const data = fs.readFileSync(filePath, { encoding: "utf-8" });\n      const storedMessages = JSON.parse(data) as StoredMessage[];\n      return mapStoredMessagesToChatMessages(storedMessages);\n    } catch (error) {\n      console.error(`Failed to read chat history from ${filePath}`, error);\n      return [];\n    }\n  }\n\n  async addMessage(message: BaseMessage): Promise<void> {\n    const messages = await this.getMessages();\n    messages.push(message);\n    await this.saveMessagesToFile(messages);\n  }\n\n  async addMessages(messages: BaseMessage[]): Promise<void> {\n    const existingMessages = await this.getMessages();\n    const allMessages = existingMessages.concat(messages);\n    await this.saveMessagesToFile(allMessages);\n  }\n\n  async clear(): Promise<void> {\n    const filePath = path.join(this.dir, `${this.sessionId}.json`);\n    try {\n      fs.unlinkSync(filePath);\n    } catch (error) {\n      console.error(`Failed to clear chat history from ${filePath}`, error);\n    }\n  }\n\n  private async saveMessagesToFile(messages: BaseMessage[]): Promise<void> {\n    const filePath = path.join(this.dir, `${this.sessionId}.json`);\n    const serializedMessages = mapChatMessagesToStoredMessages(messages);\n    try {\n      fs.writeFileSync(filePath, JSON.stringify(serializedMessages, null, 2), {\n        encoding: "utf-8",\n      });\n    } catch (error) {\n      console.error(`Failed to save chat history to ${filePath}`, error);\n    }\n  }\n}\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"然后我们开始逐步解析其中大家可能会有疑惑的点："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"export interface JSONChatHistoryInput { \n    sessionId: string; \n    dir: string; \n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"这里 sessionId 是区别于不同对话的 id，在工程中一般使用 uuid，dir 是存储聊天记录 json 文件的目录。"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:'lc_namespace = ["langchain", "stores", "message"];'}),(0,a.jsx)(n.br,{}),"\n","是因为 ",(0,a.jsx)(n.code,{children:"BaseListChatMessageHistory"})," 继承了 ",(0,a.jsx)(n.code,{children:"Serializable"}),"，声明 lc_namespace 是方便 langchain 在序列化和反序列化时，找到 json 中对象对应的内置类，例如当我们把 message 序列化，再反序列化后，打印出来依旧是对应 langchain 内部的类的实例化对象，依靠的就是这个。"]}),"\n",(0,a.jsxs)(n.p,{children:["我们先看 ",(0,a.jsx)(n.code,{children:"saveMessagesToFile"})," 部分，这部分原理很简单，就是使用 ",(0,a.jsx)(n.code,{children:"mapChatMessagesToStoredMessages"})," 去对 messages 进行序列化，然后用写文件到 json 文件中。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"getMessages"})," 从对应的文件中读取 json 内容，然后使用 ",(0,a.jsx)(n.code,{children:"mapStoredMessagesToChatMessages"})," 序列化成对应的 message 对象。"]}),"\n",(0,a.jsx)(n.p,{children:"addMessage、addMessages、clear 都是比较正常的业务逻辑。"}),"\n",(0,a.jsx)(n.p,{children:"让我们测试一下"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { JSONChatHistory } from "./JSONChatHistory/index.ts"\nimport { AIMessage, HumanMessage } from "@langchain/core/messages";\n\nconst history = new JSONChatHistory({\n    dir: "chat_data",\n    sessionId: "test"\n})\n\n\nawait history.addMessages([\n  new HumanMessage("Hi, 我叫小明"),\n  new AIMessage("你好"),\n]);\n\nconst messages = await history.getMessages();\nconsole.log(messages)\n'})}),"\n",(0,a.jsx)(n.p,{children:"输出："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'[\n  HumanMessage {\n    lc_serializable: true,\n    lc_kwargs: {\n      content: "Hi, 我叫小明",\n      additional_kwargs: {},\n      response_metadata: {}\n    },\n    lc_namespace: [ "langchain_core", "messages" ],\n    content: "Hi, 我叫小明",\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {}\n  },\n  AIMessage {\n    lc_serializable: true,\n    lc_kwargs: { content: "你好", additional_kwargs: {}, response_metadata: {} },\n    lc_namespace: [ "langchain_core", "messages" ],\n    content: "你好",\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {}\n  }\n]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["可以看到，因为我们正确的设置了 ",(0,a.jsx)(n.code,{children:"lc_namespace"}),"，序列化和反序列化可以很正确的处理 langchain 中的对象，例如 ",(0,a.jsx)(n.code,{children:"HumanMessage"})," 和 ",(0,a.jsx)(n.code,{children:"AIMessage"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:["让我们看看如何应用在 memory 中，这里为了方便，我们依旧使用 ",(0,a.jsx)(n.code,{children:"ConversationChain"}),"："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'import { ChatOpenAI } from "@langchain/openai";\nimport { BufferMemory } from "langchain/memory";\nimport { ConversationChain } from "langchain/chains";\n\n\nconst chatModel = new ChatOpenAI();\nconst memory = new BufferMemory({\n    chatHistory: history\n});\nconst chain = new ConversationChain({ llm: chatModel, memory: memory });\nconst res1 = await chain.call({ input: "我叫什么？" });\n'})}),"\n",(0,a.jsx)(n.p,{children:"返回："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'{ response: "你叫小明。" }\n'})}),"\n",(0,a.jsx)(n.p,{children:"然后我们看一下 chat history 中存储的 message："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const messages = await history.getMessages()\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:'[\n  HumanMessage {\n    lc_serializable: true,\n    lc_kwargs: {\n      content: "Hi, 我叫小明",\n      additional_kwargs: {},\n      response_metadata: {}\n    },\n    lc_namespace: [ "langchain_core", "messages" ],\n    content: "Hi, 我叫小明",\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {}\n  },\n  AIMessage {\n    lc_serializable: true,\n    lc_kwargs: { content: "你好", additional_kwargs: {}, response_metadata: {} },\n    lc_namespace: [ "langchain_core", "messages" ],\n    content: "你好",\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {}\n  },\n  HumanMessage {\n    lc_serializable: true,\n    lc_kwargs: { content: "我叫什么？", additional_kwargs: {}, response_metadata: {} },\n    lc_namespace: [ "langchain_core", "messages" ],\n    content: "我叫什么？",\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {}\n  },\n  AIMessage {\n    lc_serializable: true,\n    lc_kwargs: { content: "你叫小明。", additional_kwargs: {}, response_metadata: {} },\n    lc_namespace: [ "langchain_core", "messages" ],\n    content: "你叫小明。",\n    name: undefined,\n    additional_kwargs: {},\n    response_metadata: {}\n  }\n]\n'})}),"\n",(0,a.jsx)(n.p,{children:"然后我们打开对应的 test.json，其中内容是："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "type": "human",\n    "data": {\n      "content": "Hi, 我叫小明",\n      "additional_kwargs": {},\n      "response_metadata": {}\n    }\n  },\n  {\n    "type": "ai",\n    "data": {\n      "content": "你好",\n      "additional_kwargs": {},\n      "response_metadata": {}\n    }\n  },\n  {\n    "type": "human",\n    "data": {\n      "content": "我叫什么？",\n      "additional_kwargs": {},\n      "response_metadata": {}\n    }\n  },\n  {\n    "type": "ai",\n    "data": {\n      "content": "你叫小明。",\n      "additional_kwargs": {},\n      "response_metadata": {}\n    }\n  }\n]\n'})}),"\n",(0,a.jsx)(n.p,{children:"至此，我们通过自定义 chat history 实现把历史记录存储到本地文件和从本地文件中读取到 chat history中，并且将自定义的 chat history 作为 memory 内置使用的 chatHistory 成功将 memory 接入了我们的存储中。"}),"\n",(0,a.jsx)(n.p,{children:"可以看到，得益于 langchain 良好的抽象和模块化，我们可以非常容易根据我们的需求接入到 langchain 现有的基建中。"}),"\n",(0,a.jsxs)(n.h2,{id:"小结",children:["小结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"这一小节的干货比较多，我们希望不是重复的造轮子，而是尽可能利用 langchain 的现有基建，从而把我们更多的精力放在更加重要的业务逻辑中。"}),"\n",(0,a.jsxs)(n.p,{children:["在本章，我们通过使用 LCEL 中灵活利用 ",(0,a.jsx)(n.code,{children:"RunnablePassthrough"}),"，让 LCEL 也能使用到丰富的 memory 基建，我们不需要重复的去在 LCEL 中造 ",(0,a.jsx)(n.code,{children:"EntityMemory"})," 这种基建。"]}),"\n",(0,a.jsxs)(n.p,{children:["然后通过把聊天记录存储在 json 文件中的 ",(0,a.jsx)(n.code,{children:"JSONChatHistory"})," 讲解了如何实现自定义的 chat history，并接入到现有的 memory 中。虽然 langchain 提供了跟各种数据库的集成工具，但因为业务的特殊性，我们需要使用自己定义存储方式，借鉴 ",(0,a.jsx)(n.code,{children:"JSONChatHistory"})," 的思路，你可以非常方便的把用户的聊天记录存储到任意数据库中，更丝滑的集成到业务现有的基建中。"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(r,{...e})}):r(e)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%20AI%EF%BC%9ALangChain.js%20%E5%85%A5%E9%97%A8%E5%92%8C%E5%AE%9E%E6%88%98_online%2F15-Memory%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%20Memory%20%E5%AD%98%E5%82%A8.md"]={toc:[{text:"在 LCEL 中集成 memory",id:"在-lcel-中集成-memory",depth:2},{text:"实现自定义的 chat history",id:"实现自定义的-chat-history",depth:2},{text:"小结",id:"小结",depth:2}],title:"15-Memory：实现自定义 Memory 存储",headingTitle:"15-Memory：实现自定义 Memory 存储",frontmatter:{}}}}]);