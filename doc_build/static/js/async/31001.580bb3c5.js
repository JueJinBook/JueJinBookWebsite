"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["31001"],{447316:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r(552676),i=r(740453);let t=r.p+"static/image/b8f2420e06f71618bebdc318e460468e.c58009dc.webp",c=r.p+"static/image/3b59193c7b2f51881d9626810244b19f.b2d35eda.gif",d=r.p+"static/image/3af6ed3387f28c7f33e7883d15e590cf.1a878d68.gif";function a(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",img:"img",h3:"h3",strong:"strong",ul:"ul",li:"li",h4:"h4",ol:"ol"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"7路由篇-_-中间件",children:["7.路由篇 _ 中间件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7路由篇-_-中间件",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"中间件（Middleware），一个听起来就很高级、很强大的功能。实际上也确实如此。使用中间件，你可以拦截并控制应用里的所有请求和响应。"}),"\n",(0,s.jsx)(n.p,{children:"比如你可以基于传入的请求，重写、重定向、修改请求或响应头、甚至直接响应内容。一个比较常见的应用就是鉴权，在打开页面渲染具体的内容前，先判断用户是否登录，如果未登录，则跳转到登录页面。"}),"\n",(0,s.jsxs)(n.h2,{id:"定义",children:["定义",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定义",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["写中间件，你需要在项目的根目录定义一个名为 ",(0,s.jsx)(n.code,{children:"middleware.js"}),"的文件："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// middleware.js\nimport { NextResponse } from 'next/server'\n \n// 中间件可以是 async 函数，如果使用了 await\nexport function middleware(request) {\n  return NextResponse.redirect(new URL('/home', request.url))\n}\n\n// 设置匹配路径\nexport const config = {\n  matcher: '/about/:path*',\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["注意：这里说的项目根目录指的是和 ",(0,s.jsx)(n.code,{children:"pages"})," 或 ",(0,s.jsx)(n.code,{children:"app"})," 同级。但如果项目用了 ",(0,s.jsx)(n.code,{children:"src"}),"目录，则放在 ",(0,s.jsx)(n.code,{children:"src"}),"下。"]}),"\n",(0,s.jsxs)(n.p,{children:["在这个例子中，我们通过 ",(0,s.jsx)(n.code,{children:"config.matcher"}),"设置中间件生效的路径，在 ",(0,s.jsx)(n.code,{children:"middleware"}),"函数中设置中间件的逻辑，作用是将 ",(0,s.jsx)(n.code,{children:"/about"}),"、",(0,s.jsx)(n.code,{children:"/about/xxx"}),"、",(0,s.jsx)(n.code,{children:"/about/xxx/xxx"})," 这样的的地址统一重定向到 ",(0,s.jsx)(n.code,{children:"/home"}),"，效果如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"middleware.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"设置匹配路径",children:["设置匹配路径",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设置匹配路径",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"了解了大致用途，现在让我们看下具体用法。"}),"\n",(0,s.jsx)(n.p,{children:"先说说如何设置匹配路径。有两种方式可以指定中间件匹配的路径。"}),"\n",(0,s.jsxs)(n.h3,{id:"matcher-配置项",children:["matcher 配置项",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#matcher-配置项",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["第一种是使用 ",(0,s.jsx)(n.code,{children:"matcher"}),"配置项，示例代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export const config = {\n  matcher: '/about/:path*',\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"matcher"})," 不仅支持字符串形式，也支持数组形式，用于匹配多个路径："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export const config = {\n  matcher: ['/about/:path*', '/dashboard/:path*'],\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["初次接触的同学可能会对 ",(0,s.jsx)(n.code,{children:":path*"})," 这样的用法感到奇怪，这个用法来自于  ",(0,s.jsx)(n.a,{href:"https://github.com/pillarjs/path-to-regexp",target:"_blank",rel:"noopener noreferrer",children:"path-to-regexp"})," 这个库，它的作用就是将 ",(0,s.jsx)(n.code,{children:"/user/:name"}),"这样的路径字符串转换为正则表达式。Next.js 背后用的正是 path-to-regexp 解析地址。作为一个有着十年历史的开源库，path-to-regexp 还被 express、react-router、vue-router 等多个知名库引用。所以不妨让我们多多了解一下。"]}),"\n",(0,s.jsxs)(n.p,{children:["path-to-regexp 通过在参数名前加一个冒号来定义",(0,s.jsx)(n.strong,{children:"命名参数"}),"（Named Parameters），matcher 支持命名参数，比如 ",(0,s.jsx)(n.code,{children:"/about/:path"}),"匹配 ",(0,s.jsx)(n.code,{children:"/about/a"}),"和 ",(0,s.jsx)(n.code,{children:"/about/b"}),"，但是不匹配 ",(0,s.jsx)(n.code,{children:"/about/a/c"})]}),"\n",(0,s.jsxs)(n.p,{children:["注：实际测试的时候，",(0,s.jsx)(n.code,{children:"/about/:path"})," 并不能匹配 ",(0,s.jsx)(n.code,{children:"/about/xxx"}),"，只能匹配 ",(0,s.jsx)(n.code,{children:"/about"}),"，如果要匹配 ",(0,s.jsx)(n.code,{children:"/about/xxx"}),"，需要写成 ",(0,s.jsx)(n.code,{children:"/about/:path/"})]}),"\n",(0,s.jsxs)(n.p,{children:["命名参数的默认匹配逻辑是 ",(0,s.jsx)(n.code,{children:"[^/]+"}),"，但你也可以在命名参数后加一个括号，在其中自定义命名参数的匹配逻辑，比如 ",(0,s.jsx)(n.code,{children:"/about/icon-:foo(\\\\d+).png"})," 匹配 ",(0,s.jsx)(n.code,{children:"/about/icon-1.png"}),"，但不匹配 ",(0,s.jsx)(n.code,{children:"/about/icon-a.png"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["命名参数可以使用修饰符，其中 ",(0,s.jsx)(n.code,{children:"*"})," 表示 0 个或 1 个或多个，",(0,s.jsx)(n.code,{children:"?"}),"表示 0 个或 1 个，",(0,s.jsx)(n.code,{children:"+"}),"表示 1 个或多个，比如"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/about/:path*"})," 匹配 ",(0,s.jsx)(n.code,{children:"/about"}),"、",(0,s.jsx)(n.code,{children:"/about/xxx"}),"、",(0,s.jsx)(n.code,{children:"/about/xxx/xxx"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/about/:path?"})," 匹配 ",(0,s.jsx)(n.code,{children:"/about"}),"、",(0,s.jsx)(n.code,{children:"/about/xxx"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"/about/:path+"})," 匹配 ",(0,s.jsx)(n.code,{children:"/about/xxx"}),"、",(0,s.jsx)(n.code,{children:"/about/xxx/xxx"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["也可以在圆括号中使用标准的正则表达式，比如",(0,s.jsx)(n.code,{children:"/about/(.*)"})," 等同于 ",(0,s.jsx)(n.code,{children:"/about/:path*"}),"，比如 ",(0,s.jsx)(n.code,{children:"/(about|settings)"})," 匹配 ",(0,s.jsx)(n.code,{children:"/about"})," 和 ",(0,s.jsx)(n.code,{children:"/settings"}),"，不匹配其他的地址。",(0,s.jsx)(n.code,{children:"/user-(ya|yu)"}),"匹配 ",(0,s.jsx)(n.code,{children:"/user-ya"}),"和 ",(0,s.jsx)(n.code,{children:"/user-yu"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"一个较为复杂和常用的例子是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export const config = {\n  matcher: [\n    /*\n     * 匹配所有的路径除了以这些作为开头的：\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    '/((?!api|_next/static|_next/image|favicon.ico).*)',\n  ],\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["除此之外，还要注意，路径必须以 ",(0,s.jsx)(n.code,{children:"/"}),"开头。",(0,s.jsx)(n.code,{children:"matcher"})," 的值必须是常量，这样可以在构建的时候被静态分析。使用变量之类的动态值会被忽略。"]}),"\n",(0,s.jsx)(n.p,{children:"matcher 的强大可远不止正则表达式，matcher 还可以判断查询参数、cookies、headers："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export const config = {\n  matcher: [\n    {\n      source: '/api/*',\n      has: [\n        { type: 'header', key: 'Authorization', value: 'Bearer Token' },\n        { type: 'query', key: 'userId', value: '123' },\n      ],\n      missing: [{ type: 'cookie', key: 'session', value: 'active' }],\n    },\n  ],\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在这个例子中，不仅匹配了路由地址，还要求 header 的 Authorization 必须是 Bearer Token，查询参数的 userId 为 123，且 cookie 里的 session 值不是 active。"}),"\n",(0,s.jsxs)(n.p,{children:["注：关于 has 和 missing，可以参考 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079234708766746#heading-10",target:"_blank",rel:"noopener noreferrer",children:" API 篇 | next.config.js（上）"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"条件语句",children:["条件语句",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#条件语句",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"第二种方法是使用条件语句："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\n \nexport function middleware(request) {\n  if (request.nextUrl.pathname.startsWith('/about')) {\n    return NextResponse.rewrite(new URL('/about-2', request.url))\n  }\n \n  if (request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.rewrite(new URL('/dashboard/user', request.url))\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"matcher 很强大，可有的时候不会写真的让人头疼，那就在具体的逻辑里写！"}),"\n",(0,s.jsxs)(n.h2,{id:"中间件逻辑",children:["中间件逻辑",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#中间件逻辑",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们看看中间件具体该怎么写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export function middleware(request) {\n  // 如何读取和设置 cookies ？\n  // 如何读取 headers ？\n  // 如何直接响应?\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"如何读取和设置-cookies",children:["如何读取和设置 cookies？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何读取和设置-cookies",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"用法跟路由处理程序一致，使用 NextRequest 和 NextResponse 快捷读取和设置 cookies。"}),"\n",(0,s.jsxs)(n.p,{children:["对于传入的请求，NextRequest 提供了 ",(0,s.jsx)(n.code,{children:"get"}),"、",(0,s.jsx)(n.code,{children:"getAll"}),"、",(0,s.jsx)(n.code,{children:"set"}),"和 ",(0,s.jsx)(n.code,{children:"delete"}),"方法处理 cookies，你也可以用 ",(0,s.jsx)(n.code,{children:"has"}),"检查 cookie 或者 ",(0,s.jsx)(n.code,{children:"clear"}),"删除所有的 cookies。"]}),"\n",(0,s.jsxs)(n.p,{children:["对于返回的响应，NextResponse 同样提供了 ",(0,s.jsx)(n.code,{children:"get"}),"、",(0,s.jsx)(n.code,{children:"getAll"}),"、",(0,s.jsx)(n.code,{children:"set"}),"和 ",(0,s.jsx)(n.code,{children:"delete"}),"方法处理 cookies。示例代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\n \nexport function middleware(request) {\n  // 假设传入的请求 header 里 \"Cookie:nextjs=fast\"\n  let cookie = request.cookies.get('nextjs')\n  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }\n  const allCookies = request.cookies.getAll()\n  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]\n \n  request.cookies.has('nextjs') // => true\n  request.cookies.delete('nextjs')\n  request.cookies.has('nextjs') // => false\n \n  // 设置 cookies\n  const response = NextResponse.next()\n  response.cookies.set('vercel', 'fast')\n  response.cookies.set({\n    name: 'vercel',\n    value: 'fast',\n    path: '/',\n  })\n  cookie = response.cookies.get('vercel')\n  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }\n  \n  // 响应 header 为 `Set-Cookie:vercel=fast;path=/test`\n  return response\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在这个例子中，我们调用了 ",(0,s.jsx)(n.code,{children:"NextResponse.next()"})," 这个方法，这个方法专门用在 middleware 中，毕竟我们写的是中间件，中间件进行一层处理后，返回的结果还要在下一个逻辑中继续使用，此时就需要返回 ",(0,s.jsx)(n.code,{children:"NextResponse.next()"}),"。当然如果不需要再走下一个逻辑了，可以直接返回一个 Response 实例，接下来的例子中会演示其写法。"]}),"\n",(0,s.jsxs)(n.h3,{id:"如何读取和设置-headers",children:["如何读取和设置 headers？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何读取和设置-headers",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"用法跟路由处理程序一致，使用 NextRequest 和 NextResponse 快捷读取和设置 headers。示例代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// middleware.js \nimport { NextResponse } from 'next/server'\n \nexport function middleware(request) {\n  //  clone 请求标头\n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set('x-hello-from-middleware1', 'hello')\n \n  // 你也可以在 NextResponse.rewrite 中设置请求标头\n  const response = NextResponse.next({\n    request: {\n      // 设置新请求标头\n      headers: requestHeaders,\n    },\n  })\n \n  // 设置新响应标头 `x-hello-from-middleware2`\n  response.headers.set('x-hello-from-middleware2', 'hello')\n  return response\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个例子比较特殊的地方在于调用 NextResponse.next 的时候传入了一个对象用于转发 headers，根据 ",(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/functions/next-response",target:"_blank",rel:"noopener noreferrer",children:"NextResponse"})," 的官方文档，目前也就这一种用法。"]}),"\n",(0,s.jsxs)(n.h4,{id:"cors",children:["CORS",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#cors",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这是一个在实际开发中会用到的设置 CORS 的例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\n \nconst allowedOrigins = ['https://acme.com', 'https://my-app.org']\n \nconst corsOptions = {\n  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n}\n \nexport function middleware(request) {\n  // Check the origin from the request\n  const origin = request.headers.get('origin') ?? ''\n  const isAllowedOrigin = allowedOrigins.includes(origin)\n \n  // Handle preflighted requests\n  const isPreflight = request.method === 'OPTIONS'\n \n  if (isPreflight) {\n    const preflightHeaders = {\n      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),\n      ...corsOptions,\n    }\n    return NextResponse.json({}, { headers: preflightHeaders })\n  }\n \n  // Handle simple requests\n  const response = NextResponse.next()\n \n  if (isAllowedOrigin) {\n    response.headers.set('Access-Control-Allow-Origin', origin)\n  }\n \n  Object.entries(corsOptions).forEach(([key, value]) => {\n    response.headers.set(key, value)\n  })\n \n  return response\n}\n \nexport const config = {\n  matcher: '/api/:path*',\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"如何直接响应",children:["如何直接响应?",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何直接响应",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"用法跟路由处理程序一致，使用 NextResponse 设置返回的 Response。示例代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\nimport { isAuthenticated } from '@lib/auth'\n\nexport const config = {\n  matcher: '/api/:function*',\n}\n \nexport function middleware(request) {\n  // 鉴权判断\n  if (!isAuthenticated(request)) {\n    // 返回错误信息\n    return new NextResponse(\n      JSON.stringify({ success: false, message: 'authentication failed' }),\n      { status: 401, headers: { 'content-type': 'application/json' } }\n    )\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"执行顺序",children:["执行顺序",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行顺序",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 Next.js 中，有很多地方都可以设置路由的响应，比如 next.config.js 中可以设置，中间件中可以设置，具体的路由中可以设置，所以要注意它们的执行顺序："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"headers"}),"（",(0,s.jsx)(n.code,{children:"next.config.js"}),"）"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"redirects"}),"（",(0,s.jsx)(n.code,{children:"next.config.js"}),"）"]}),"\n",(0,s.jsxs)(n.li,{children:["中间件 (",(0,s.jsx)(n.code,{children:"rewrites"}),", ",(0,s.jsx)(n.code,{children:"redirects"})," 等)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"beforeFiles"})," (",(0,s.jsx)(n.code,{children:"next.config.js"}),"中的",(0,s.jsx)(n.code,{children:"rewrites"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["基于文件系统的路由 (",(0,s.jsx)(n.code,{children:"public/"}),", ",(0,s.jsx)(n.code,{children:"_next/static/"}),", ",(0,s.jsx)(n.code,{children:"pages/"}),", ",(0,s.jsx)(n.code,{children:"app/"})," 等)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"afterFiles"})," (",(0,s.jsx)(n.code,{children:"next.config.js"}),"中的",(0,s.jsx)(n.code,{children:"rewrites"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["动态路由 (",(0,s.jsx)(n.code,{children:"/blog/[slug]"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"fallback"}),"中的 (",(0,s.jsx)(n.code,{children:"next.config.js"}),"中的",(0,s.jsx)(n.code,{children:"rewrites"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["注： ",(0,s.jsx)(n.code,{children:"beforeFiles"})," 顾名思义，在基于文件系统的路由之前，",(0,s.jsx)(n.code,{children:"afterFiles"}),"顾名思义，在基于文件系统的路由之后，",(0,s.jsx)(n.code,{children:"fallback"}),"顾名思义，垫底执行。"]}),"\n",(0,s.jsx)(n.p,{children:"执行顺序具体是什么作用呢？其实我们写个 demo 测试一下就知道了，文件目录如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"next-app             \n├─ app                      \n│  ├─ blog                  \n│  │  ├─ [id]               \n│  │  │  └─ page.js         \n│  │  ├─ yayu               \n│  │  │  └─ page.js         \n│  │  └─ page.js                                    \n├─ middleware.js            \n└─ next.config.js\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"next.config.js"})," 中声明 ",(0,s.jsx)(n.code,{children:"redirects"}),"、",(0,s.jsx)(n.code,{children:"rewrites"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"module.exports = {\n  async redirects() {\n    return [\n      {\n        source: '/blog/yayu',\n        destination: '/blog/yayu_redirects',\n        permanent: true,\n      },\n    ]\n  },\n  async rewrites() {\n    return {\n      beforeFiles: [\n        {\n          source: '/blog/yayu',\n          destination: '/blog/yayu_beforeFiles',\n        },\n      ],\n      afterFiles: [\n        {\n          source: '/blog/yayu',\n          destination: '/blog/yayu_afterFiles',\n        },\n      ],\n      fallback: [\n        {\n          source: '/blog/yayu',\n          destination: `/blog/yayu_fallback`,\n        },\n      ],\n    }\n  },\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"middleware.js"})," 的代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\n \nexport function middleware(request) {\n  return NextResponse.redirect(new URL('/blog/yayu_middleware', request.url))\n}\n\nexport const config = {\n  matcher: '/blog/yayu',\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"app/blog/page.js"}),"代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { redirect } from 'next/navigation'\n\nexport default function Page() {\n  redirect('/blog/yayu_page')\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"app/blog/[id]/page.js"}),"代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { redirect } from 'next/navigation'\n\nexport default function Page() {\n  redirect('/blog/yayu_slug')\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["现在我们在多个地方都配置了重定向和重写，那么问题来了，现在访问 ",(0,s.jsx)(n.code,{children:"/blog/yayu"}),"，最终浏览器地址栏里呈现的 URL 是什么？"]}),"\n",(0,s.jsxs)(n.p,{children:["答案是 ",(0,s.jsx)(n.code,{children:"/blog/yayu_slug"}),"。按照执行顺序，访问 ",(0,s.jsx)(n.code,{children:"/blog/yayu"}),"，先根据 ",(0,s.jsx)(n.code,{children:"next.config.js"})," 的 ",(0,s.jsx)(n.code,{children:"redirects"}),"重定向到 ",(0,s.jsx)(n.code,{children:"/blog/yayu_redirects"}),"，于是走到动态路由的逻辑，重定向到 ",(0,s.jsx)(n.code,{children:"/blog/yayu_slug"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"中间件相关配置项",children:["中间件相关配置项",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#中间件相关配置项",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Next.js v13.1 为中间件增加了两个新的配置项，",(0,s.jsx)(n.code,{children:"skipMiddlewareUrlNormalize"}),"和",(0,s.jsx)(n.code,{children:"skipTrailingSlashRedirect"}),"，用来处理一些特殊的情况。"]}),"\n",(0,s.jsxs)(n.h3,{id:"skiptrailingslashredirect",children:["skipTrailingSlashRedirect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#skiptrailingslashredirect",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先解释一下 \xa0",(0,s.jsx)(n.strong,{children:"Trailing Slashes"}),"，中文翻译为“尾部斜杠”，它指的是放在 URL 末尾的正斜杠，举个例子: ",(0,s.jsx)(n.code,{children:"www.yauyjs.com/users/"}),"地址中最后一个斜杠就是尾部斜杠。"]}),"\n",(0,s.jsx)(n.p,{children:"一般来说，尾部斜杠用于区分目录还是文件，有尾部斜杠，表示目录，没有尾部斜杠，表示文件。当然这只是一个建议，具体你想怎么处理都行。"}),"\n",(0,s.jsxs)(n.p,{children:["从 URL 的角度来看，",(0,s.jsx)(n.code,{children:"www.yauyjs.com/users/"}),"和 ",(0,s.jsx)(n.code,{children:"www.yayujs.com/users"}),"是两个地址，不过通常我们都会做重定向。比如你在 Next.js 中访问 ",(0,s.jsx)(n.code,{children:"/about/"}),"它会自动重定向到 ",(0,s.jsx)(n.code,{children:"/about"}),"，URL 也会变为 ",(0,s.jsx)(n.code,{children:"/about"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"skipTrailingSlashRedirect"})," 顾名思义，跳过尾部斜杠重定向，当你设置 ",(0,s.jsx)(n.code,{children:"skipTrailingSlashRedirect"}),"为 true 后，假设再次访问 ",(0,s.jsx)(n.code,{children:"/about/"}),"，URL 依然会是 ",(0,s.jsx)(n.code,{children:"/about/"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"skipTrailingSlashRedirect"}),"的示例代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  skipTrailingSlashRedirect: true,\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// middleware.js\nconst legacyPrefixes = ['/docs', '/blog']\n \nexport default async function middleware(req) {\n  const { pathname } = req.nextUrl\n \n  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {\n    return NextResponse.next()\n  }\n \n  // 应用尾部斜杠\n  if (\n    !pathname.endsWith('/') &&\n    !pathname.match(/((?!\\.well-known(?:\\/.*)?)(?:[^/]+\\/)*[^/]+\\.\\w+)/)\n  ) {\n    req.nextUrl.pathname += '/'\n    return NextResponse.redirect(req.nextUrl)\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在这个例子中，这里我们实现了除 ",(0,s.jsx)(n.code,{children:"/docs"})," 和 ",(0,s.jsx)(n.code,{children:"/blog"})," 作为前缀的路由之外，其他路由都自动添加上尾部斜杠。"]}),"\n",(0,s.jsxs)(n.h3,{id:"skipmiddlewareurlnormalize",children:["skipMiddlewareUrlNormalize",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#skipmiddlewareurlnormalize",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["关于 ",(0,s.jsx)(n.strong,{children:"skipMiddlewareUrlNormalize"}),"，让我们直接看一个例子："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = {\n  skipMiddlewareUrlNormalize: true,\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// middleware.js\nexport default async function middleware(req) {\n  const { pathname } = req.nextUrl\n \n  // GET /_next/data/build-id/hello.json\n \n  console.log(pathname)\n  // 如果设置为 true，值为：/_next/data/build-id/hello.json\n  // 如果没有配置，值为： /hello\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["设置 ",(0,s.jsx)(n.strong,{children:"skipMiddlewareUrlNormalize"})," 为 true 后，可以获取路由原始的地址，常用于国际化场景中。"]}),"\n",(0,s.jsxs)(n.h2,{id:"运行时",children:["运行时",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#运行时",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"使用 Middleware 的时候还要注意一点，那就是目前 Middleware 只支持 Edge runtime，并不支持 Node.js runtime。这意味着写 Middleware 的时候，尽可能使用 Web API，避免使用 Node.js API"}),"\n",(0,s.jsxs)(n.h3,{id:"实战控制请求数",children:["实战：控制请求数",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实战控制请求数",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["需求：如果大家调用过 openai 的接口，常用的 ChatGPT v3.5 接口会有每分钟最多 3 次的调用限制。现在你也开发了一个 ",(0,s.jsx)(n.code,{children:"/api/chat"})," 的接口，为了防止被恶意调用，限制每分钟最多调用 3 次。使用 Next.js 该怎么实现呢？"]}),"\n",(0,s.jsxs)(n.p,{children:["让我们来实现吧！为此我们需要安装一个依赖包 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/limiter",target:"_blank",rel:"noopener noreferrer",children:"limiter"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install limiter\n"})}),"\n",(0,s.jsxs)(n.p,{children:["新建 ",(0,s.jsx)(n.code,{children:"app/api/chat/route.js"}),"，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"\nimport { NextResponse } from 'next/server'\nimport { RateLimiter } from \"limiter\";\nconst limiter = new RateLimiter({ tokensPerInterval: 3, interval: \"min\", fireImmediately: true });\n\nexport async function GET() {\n  const remainingRequests = await limiter.removeTokens(1);\n  if (remainingRequests < 0) {\n    return new NextResponse(\n      JSON.stringify({ success: false, message: 'Too Many Requests' }),\n      { status: 429, headers: { 'content-type': 'application/json' } }\n    )\n  }\n \n  return NextResponse.json({ data: \"你好！\" })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时成功运行，效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"middleware-1.gif"})}),"\n",(0,s.jsx)(n.p,{children:"我们将控制次数的逻辑写在了具体的路由里，现在让我们尝试写在中间件里："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\nimport { RateLimiter } from \"limiter\";\nconst limiter = new RateLimiter({ tokensPerInterval: 3, interval: \"min\", fireImmediately: true });\n\nexport async function middleware(request) {\n\n  const remainingRequests = await limiter.removeTokens(1);\n  if (remainingRequests < 0) {\n    return new NextResponse(\n      JSON.stringify({ success: false, message: 'Too Many Requests' }),\n      { status: 429, headers: { 'content-type': 'application/json' } }\n    )\n  }\n\n  return NextResponse.next()\n}\n\n// 设置匹配路径\nexport const config = {\n  matcher: '/api/chat',\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"然而此时你会发现："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"代码是报错的，这是为什么呢？"}),"\n",(0,s.jsx)(n.p,{children:"这就是初学者写中间件常犯的一个错误。之所以出错，是因为 limiter 其实是一个用在 node.js 环境的库，然而目前 Middleware 只支持 Edge runtime，并不支持 Node.js runtime，所以才会报错。举这个项目作为例子，只是为了提醒大家注意运行时问题。"}),"\n",(0,s.jsxs)(n.h2,{id:"中间件的代码维护",children:["中间件的代码维护",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#中间件的代码维护",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"如果项目比较简单，中间件的代码通常不会写很多，将所有代码写在一起倒也不是什么太大问题。可当项目复杂了，比如在中间件里又要鉴权、又要控制请求、又要国际化等等，各种逻辑写在一起，中间件很快就变得难以维护。如果我们要在中间件里实现多个需求，该怎么合理的拆分代码呢？"}),"\n",(0,s.jsx)(n.p,{children:"一种简单的方式是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\n\nasync function middleware1(request) {\n  console.log(request.url)\n  return NextResponse.next()\n}\n\nasync function middleware2(request) {\n  console.log(request.url)\n  return NextResponse.next()\n}\n\nexport async function middleware(request) {\n  await middleware1(request)\n  await middleware2(request)\n}\n\nexport const config = {\n  matcher: '/api/:path*',\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"一种更为优雅的方式是借助高阶函数："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\n\nfunction withMiddleware1(middleware) {\n  return async (request) => {\n    console.log('middleware1 ' + request.url)\n    return middleware(request)\n  }\n}\n\nfunction withMiddleware2(middleware) {\n  return async (request) => {\n    console.log('middleware2 ' + request.url)\n    return middleware(request)\n  }\n}\n\nasync function middleware(request) {\n  console.log('middleware ' + request.url)\n  return NextResponse.next()\n}\n\nexport default withMiddleware2(withMiddleware1(middleware))\n\nexport const config = {\n  matcher: '/api/:path*',\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"请问此时的执行顺序是什么？试着打印一下吧。是不是感觉回到了学 redux 的时候？"}),"\n",(0,s.jsx)(n.p,{children:"但这样写起来还是有点麻烦，让我们写一个工具函数帮助我们："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { NextResponse } from 'next/server'\n\nfunction chain(functions, index = 0) {\n  const current = functions[index];\n  if (current) {\n    const next = chain(functions, index + 1);\n    return current(next);\n  }\n  return () => NextResponse.next();\n}\n\nfunction withMiddleware1(middleware) {\n  return async (request) => {\n    console.log('middleware1 ' + request.url)\n    return middleware(request)\n  }\n}\n\nfunction withMiddleware2(middleware) {\n  return async (request) => {\n    console.log('middleware2 ' + request.url)\n    return middleware(request)\n  }\n}\n\nexport default chain([withMiddleware1, withMiddleware2])\n\nexport const config = {\n  matcher: '/api/:path*',\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"请问此时的执行顺序是什么？答案是按数组的顺序，middleware1、middleware2。"}),"\n",(0,s.jsx)(n.p,{children:"如果使用这种方式，实际开发的时候，代码类似于："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { chain } from "@/lib/utils";\nimport { withHeaders } from "@/middlewares/withHeaders";\nimport { withLogging } from "@/middlewares/withLogging";\n\nexport default chain([withLogging, withHeaders]);\n\nexport const config = {\n  matcher: \'/api/:path*\',\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"具体写中间件时："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"export const withHeaders = (next) => {\n  return async (request) => {\n    // ...\n    return next(request);\n  };\n};\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/app/building-your-application/routing/middleware",target:"_blank",rel:"noopener noreferrer",children:"https://nextjs.org/docs/app/building-your-application/routing/middleware"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/pillarjs/path-to-regexp",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/pillarjs/path-to-regexp"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://nextjs.org/docs/messages/invalid-route-source",target:"_blank",rel:"noopener noreferrer",children:"https://nextjs.org/docs/messages/invalid-route-source"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=fmFYH_Xu3d0&ab_channel=HamedBahram",target:"_blank",rel:"noopener noreferrer",children:"https://www.youtube.com/watch?v=fmFYH_Xu3d0&ab_channel=HamedBahram"})}),"\n"]})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let l=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F7.%E8%B7%AF%E7%94%B1%E7%AF%87%20_%20%E4%B8%AD%E9%97%B4%E4%BB%B6.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"定义",id:"定义",depth:2},{text:"设置匹配路径",id:"设置匹配路径",depth:2},{text:"matcher 配置项",id:"matcher-配置项",depth:3},{text:"条件语句",id:"条件语句",depth:3},{text:"中间件逻辑",id:"中间件逻辑",depth:2},{text:"如何读取和设置 cookies？",id:"如何读取和设置-cookies",depth:3},{text:"如何读取和设置 headers？",id:"如何读取和设置-headers",depth:3},{text:"CORS",id:"cors",depth:4},{text:"如何直接响应?",id:"如何直接响应",depth:3},{text:"执行顺序",id:"执行顺序",depth:2},{text:"中间件相关配置项",id:"中间件相关配置项",depth:2},{text:"skipTrailingSlashRedirect",id:"skiptrailingslashredirect",depth:3},{text:"skipMiddlewareUrlNormalize",id:"skipmiddlewareurlnormalize",depth:3},{text:"运行时",id:"运行时",depth:2},{text:"实战：控制请求数",id:"实战控制请求数",depth:3},{text:"中间件的代码维护",id:"中间件的代码维护",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"7.路由篇 _ 中间件",headingTitle:"7.路由篇 _ 中间件",frontmatter:{}}}}]);