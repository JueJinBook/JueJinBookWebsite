"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["95640"],{842918:function(e,n,r){r.r(n),r.d(n,{default:()=>T});var t=r(552676),a=r(740453);let s=r.p+"static/image/c0a6532ef9c6b799abaf4b218c510550.055c38ca.webp",i=r.p+"static/image/99090e11ef899e5364576985783d0672.5709e5f0.webp",p=r.p+"static/image/306e2aab29c285ca52194eeaf1d2eec3.a8fdd9e2.webp",c=r.p+"static/image/7bfe6f0e97468581cf5ec3b27ef13004.39f76185.webp",l=r.p+"static/image/7f7ac58441eebce49c64f91eb0818209.3d1d2880.webp",d=r.p+"static/image/de45e8a3f6fe7762c1914f7c70a5a2fd.f6884fb5.webp",o=r.p+"static/image/46369ea126578973b4884332e022b8bb.6bd9e9e2.webp",h=r.p+"static/image/f5642fa977c587ed631e182da8e60bc8.5815e855.webp",m=r.p+"static/image/51b183a6d8e6fca27fbf4ce0ad2d37da.c876171a.webp",g=r.p+"static/image/d73077a3dda0b7dd5f1151638cbaa3f3.87630041.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",h3:"h3",h4:"h4",pre:"pre",code:"code",img:"img",h5:"h5",ul:"ul",li:"li"},(0,a.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"19原理篇实现简易-typescript-类型检查",children:["19.原理篇：实现简易 TypeScript 类型检查",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#19原理篇实现简易-typescript-类型检查",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"不自己实现 ts 类型检查，怎么能叫“通关”呢？"}),"\n",(0,t.jsx)(n.p,{children:"这一节我们基于 babel 来实现类型检查，也就是 Checker 的功能。\n当然，只是简易版本，帮助大家理清类型检查的实现原理。"}),"\n",(0,t.jsxs)(n.p,{children:["这节是从 ",(0,t.jsx)(n.a,{href:"https://juejin.cn/book/6946117847848321055",target:"_blank",rel:"noopener noreferrer",children:"babel 插件小册"}),"拿过来的，因为这本不是讲 babel 插件的，所以大家不用看细节，理清下思路就行。"]}),"\n",(0,t.jsxs)(n.p,{children:["代码在 ",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"github"}),"，可以下下来跑一下类型检查部分。"]}),"\n",(0,t.jsxs)(n.h2,{id:"如何检查类型",children:["如何检查类型",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#如何检查类型",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们知道，babel 能够解析 typescript 语法，那么能不能基于 babel 实现类型检查呢？"}),"\n",(0,t.jsx)(n.p,{children:"我们经常用 tsc 来做类型检查，有没有想过，类型检查具体做了什么？"}),"\n",(0,t.jsxs)(n.p,{children:["源码是字符串，是没法直接处理的，我们会先把代码 parse 成 AST，这是计算机能理解的格式。之后的",(0,t.jsx)(n.strong,{children:"类型检查就是对 AST 结构的检查"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"比如一个变量声明为了 number，那么给它赋值的是一个 string 就是有类型错误。"}),"\n",(0,t.jsx)(n.p,{children:"再复杂一点，如果类型有泛型，也就是有类型参数，那么需要传入具体的参数来确定类型，确定了类型之后再去和实际的 AST 对比。"}),"\n",(0,t.jsx)(n.p,{children:"typescript 还支持高级类型，也就是类型可以做各种运算，这种就需要传入类型参数求出具体的类型再去和 AST 对比。"}),"\n",(0,t.jsx)(n.p,{children:"我们来写代码实现一下："}),"\n",(0,t.jsxs)(n.h2,{id:"代码实现",children:["代码实现",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,t.jsxs)(n.h3,{id:"实现简单类型的类型检查",children:["实现简单类型的类型检查",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现简单类型的类型检查",children:"#"})]}),"\n",(0,t.jsxs)(n.h4,{id:"赋值语句的类型检查",children:["赋值语句的类型检查",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#赋值语句的类型检查",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"比如这样一段代码，声明的值是一个 string，但是赋值为了 number，明显是有类型错误的，我们怎么检查出它的错误的。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"let name: string;\n\nname = 111;\n"})}),"\n",(0,t.jsx)(n.p,{children:"首先我们使用 babel 把这段代码 parse 成 AST："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const  parser = require('@babel/parser');\n\nconst sourceCode = `\n    let name: string;\n\n    name = 111;\n`;\n\nconst ast = parser.parse(sourceCode, {\n    plugins: ['typescript']\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"使用 babel parser 来 parse，启用 typescript 语法插件。"}),"\n",(0,t.jsxs)(n.p,{children:["可以使用 ",(0,t.jsx)(n.a,{href:"https://astexplorer.net/#/gist/fbe3aa6468083e790076830c48a4725c/9573eca6e0bc15dfdaf341eda5a2afc2906875e6",target:"_blank",rel:"noopener noreferrer",children:"astexplerer.net"})," 来查看它的 AST："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsxs)(n.h5,{id:"实现类型检查",children:["实现类型检查",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现类型检查",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们需要检查的是这个赋值语句 AssignmentExpression，左右两边的类型是否匹配。"}),"\n",(0,t.jsx)(n.p,{children:"右边是一个数字字面量 NumericLiteral，很容易拿到类型，而左边则是一个引用，要从作用域中拿到它声明的类型，之后才能做类型对比。"}),"\n",(0,t.jsx)(n.p,{children:"babel 提供了 scope 的 api 可以用于查找作用域中的类型声明（binding），并且还可以通过 path.getTypeAnnotation 获得声明时的类型。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:" AssignmentExpression(path, state) {\n    const leftBinding = path.scope.getBinding(path.get('left'));\n    const leftType = leftBinding.path.get('id').getTypeAnnotation();// 左边的值声明的类型\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这个返回的类型是 TSTypeAnnotation 的一个对象，我们需要做下处理，转为类型字符串，也就是 string、number 这种。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"封装一个方法，传入类型对象，返回 number、string 等类型字符串"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function resolveType(targetType) {\n    const tsTypeAnnotationMap = {\n        'TSStringKeyword': 'string'\n    }\n    switch (targetType.type) {\n        case 'TSTypeAnnotation':\n            return tsTypeAnnotationMap[targetType.typeAnnotation.type];\n        case 'NumberTypeAnnotation': \n            return 'number';\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样我们拿到了左右两边的类型，接下来就简单了，对比下就知道了类型是否匹配："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"AssignmentExpression(path, state) {\n    const rightType = resolveType(path.get('right').getTypeAnnotation());\n    const leftBinding = path.scope.getBinding(path.get('left'));\n    const leftType = resolveType(leftBinding.path.get('id').getTypeAnnotation());\n    if (leftType !== rightType ) {\n        // error: 类型不匹配\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.h5,{id:"错误打印优化",children:["错误打印优化",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#错误打印优化",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"报错信息怎么打印呢？可以使用 @babel/code-frame，它支持打印某一片段的高亮代码。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"path.get('right').buildCodeFrameError(`${rightType} can not assign to ${leftType}`, Error)\n"})}),"\n",(0,t.jsx)(n.p,{children:"效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"这个错误堆栈也太丑了，我们把它去掉，设置 Error.stackTraceLimit 为 0 就行了"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"Error.stackTraceLimit = 0;\npath.get('right').buildCodeFrameError(`${rightType} can not assign to ${leftType}`, Error));\n"})}),"\n",(0,t.jsx)(n.p,{children:"但是这里改了之后还要改回来，也就是:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const tmp = Error.stackTraceLimit;\nError.stackTraceLimit = 0;\nconsole.log(path.get('right').buildCodeFrameError(`${rightType} can not assign to ${leftType}`, Error));\nError.stackTraceLimit = tmp;\n"})}),"\n",(0,t.jsx)(n.p,{children:"再来跑一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"好看多了！"}),"\n",(0,t.jsxs)(n.h5,{id:"错误收集",children:["错误收集",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#错误收集",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"还有一个问题，现在是遇到类型错误就报错，但我们希望是在遇到类型错误时收集起来，最后统一报错。"}),"\n",(0,t.jsx)(n.p,{children:"怎么实现呢？错误放在哪？"}),"\n",(0,t.jsx)(n.p,{children:"babel 插件中可以拿到 file 对象，有 set 和 get 方法用来存取一些全局的信息。可以在插件调用前后，也就是 pre 和 post 阶段拿到 file 对象。"}),"\n",(0,t.jsx)(n.p,{children:"所以我们可以这样做："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"pre(file) {\n    file.set('errors', []);\n},\nvisitor: {\n    AssignmentExpression(path, state) {\n        const errors = state.file.get('errors');\n\n        const rightType = resolveType(path.get('right').getTypeAnnotation());\n        const leftBinding = path.scope.getBinding(path.get('left'));\n        const leftType = resolveType(leftBinding.path.get('id').getTypeAnnotation());\n        if (leftType !== rightType ) {\n            const tmp = Error.stackTraceLimit;\n            Error.stackTraceLimit = 0;\n            errors.push(path.get('right').buildCodeFrameError(`${rightType} can not assign to ${leftType}`, Error));\n            Error.stackTraceLimit = tmp;\n        } \n    }\n},\npost(file) {\n    console.log(file.get('errors'));\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样就可以做到过程中收集错误，最后统一打印："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这样，我们就实现了简单的赋值语句的类型检查！"}),"\n",(0,t.jsxs)(n.h4,{id:"函数调用的类型检查",children:["函数调用的类型检查",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数调用的类型检查",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"赋值语句的检查比较简单，我们来进阶一下，实现函数调用参数的类型检查"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function add(a: number, b: number): number{\n    return a + b;\n}\nadd(1, '2');\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里我们要检查的就是函数调用语句 CallExpression 的参数和它声明的是否一致。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"CallExpression 有 callee 和 arguments 两部分，我们需要根据 callee 从作用域中查找函数声明，然后再把 arguments 的类型和函数声明语句的 params 的类型进行逐一对比，这样就实现了函数调用参数的类型检查。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"pre(file) {\n    file.set('errors', []);\n},\nvisitor: {\n    CallExpression(path, state) {\n        const errors = state.file.get('errors');\n        // 调用参数的类型\n        const argumentsTypes = path.get('arguments').map(item => {\n            return resolveType(item.getTypeAnnotation());\n        });\n        const calleeName = path.get('callee').toString();\n        // 根据 callee 查找函数声明\n        const functionDeclarePath = path.scope.getBinding(calleeName).path;\n        // 拿到声明时参数的类型\n        const declareParamsTypes = functionDeclarePath.get('params').map(item => {\n            return resolveType(item.getTypeAnnotation());\n        })\n\n        argumentsTypes.forEach((item, index) => {\n            if (item !== declareParamsTypes[index]) {\n                // 类型不一致，报错\n            }\n        });\n    }\n},\npost(file) {\n    console.log(file.get('errors'));\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"运行一下，效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们实现了函数调用参数的类型检查！实际上思路还是挺清晰的，检查别的 AST 也是类似的思路。"}),"\n",(0,t.jsxs)(n.h3,{id:"实现带泛型的类型检查",children:["实现带泛型的类型检查",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现带泛型的类型检查",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"泛型是什么，其实就是类型参数，使得类型可以根据传入的参数动态确定，类型定义更加灵活。"}),"\n",(0,t.jsx)(n.p,{children:"比如这样一段代码："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function add<T>(a: T, b: T) {\n    return a + b;\n}\nadd<number>(1, '2');\n"})}),"\n",(0,t.jsx)(n.p,{children:"怎么做类型检查呢？"}),"\n",(0,t.jsx)(n.p,{children:"这还是函数调用语句的类型检查，我们上面实现过了，区别不过是多了个参数，那么我们取出类型参数来传过去就行了。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"CallExpression(path, state) {\n    // 先拿到类型参数的值，也就是真实类型\n    const realTypes = path.node.typeParameters.params.map(item => {\n        return resolveType(item);\n    });\n    //实参的类型\n    const argumentsTypes = path.get('arguments').map(item => {\n        return resolveType(item.getTypeAnnotation());\n    });\n    const calleeName = path.get('callee').toString();\n    // 根据函数名查找函数声明\n    const functionDeclarePath = path.scope.getBinding(calleeName).path;\n    const realTypeMap = {};\n\n  // 把类型参数的值赋值给函数声明语句的泛型参数\n   functionDeclarePath.node.typeParameters.params.map((item, index) => {\n        realTypeMap[item.name] = realTypes[index];\n    });\n    const declareParamsTypes = functionDeclarePath.get('params').map(item => {\n        return resolveType(item.getTypeAnnotation(), realTypeMap);\n    })\n    // 做类型检查的时候取具体的类型来对比\n    argumentsTypes.forEach((item, index) => { \n        if (item !== declareParamsTypes[index]) {\n            // 报错，类型不一致\n        }\n    });\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"多了一步确定泛型参数的具体类型的过程。"}),"\n",(0,t.jsx)(n.p,{children:"执行看下效果："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们成功支持了带泛型的函数调用语句的类型检查！"}),"\n",(0,t.jsxs)(n.h3,{id:"实现带高级类型的函数调用语句的类型检查",children:["实现带高级类型的函数调用语句的类型检查",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现带高级类型的函数调用语句的类型检查",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"typescript 支持高级类型，也就是支持对类型参数做各种运算然后返回最终类型"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"type Res<Param> = Param extends 1 ? number : string;\nfunction add<T>(a: T, b: T) {\n    return a + b;\n}\nadd<Res<1>>(1, '2');\n"})}),"\n",(0,t.jsx)(n.p,{children:"比如这段代码中，Res 就是一个高级类型，对传入的类型参数 Param 进行处理之后返回新类型。"}),"\n",(0,t.jsx)(n.p,{children:"这个函数调用语句的类型检查，比泛型参数传具体的类型又复杂了一些，需要先求出具体的类型，然后再传入参数，之后再去对比参数的类型。"}),"\n",(0,t.jsx)(n.p,{children:"那么这个 Res 的高级类型怎么求值呢？"}),"\n",(0,t.jsx)(n.p,{children:"我们来看一下这个 Res 类型的 AST："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["它有类型参数部分（typeParameters），和具体的类型计算逻辑部分（typeAnnotation），右边的 ",(0,t.jsx)(n.code,{children:"Param extends 1 ? number : string;"})," 是一个 condition 语句，有 Params 和 1 分别对应 checkType、extendsType，number 和 string 则分别对应 trueType、falseType。"]}),"\n",(0,t.jsx)(n.p,{children:"我们只需要对传入的 Param 判断下是否是 1，就可以求出具体的类型是 trueType 还是 falseType。"}),"\n",(0,t.jsx)(n.p,{children:"具体类型传参的逻辑和上面一样，就不赘述了，我们看一下根据类型参数求值的逻辑："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function typeEval(node, params) {\n    let checkType;\n    // 如果参数是泛型，则从传入的参数取值\n    if(node.checkType.type === 'TSTypeReference') {\n        checkType = params[node.checkType.typeName.name];\n    } else {// 否则直接取字面量参数\n        checkType = resolveType(node.checkType); \n    }\n    const extendsType = resolveType(node.extendsType);\n    if (checkType === extendsType || checkType instanceof extendsType) { // 如果 extends 逻辑成立\n        return resolveType(node.trueType);\n    } else {\n        return resolveType(node.falseType);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这样，我们就可以求出这个 Res 的高级类型当传入 Params 为 1 时求出的最终类型。"}),"\n",(0,t.jsx)(n.p,{children:"有了最终类型之后，就和直接传入具体类型的函数调用的类型检查一样了。（上面我们实现过）"}),"\n",(0,t.jsx)(n.p,{children:"执行一下，效果如下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"完整代码如下（有些长，可以先跳过往后看）："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const { declare } = require('@babel/helper-plugin-utils');\n\n// 解析高级类型的值，传入泛型参数的值\nfunction typeEval(node, params) {\n    let checkType;\n    if(node.checkType.type === 'TSTypeReference') {\n        checkType = params[node.checkType.typeName.name];\n    } else {\n        checkType = resolveType(node.checkType);\n    }\n    const extendsType = resolveType(node.extendsType);\n    // 如果 condition 表达式 的 check 部分为 true，则返回 trueType，否则返回 falseType\n    if (checkType === extendsType || checkType instanceof extendsType) {\n        return resolveType(node.trueType);\n    } else {\n        return resolveType(node.falseType);\n    }\n}\n\nfunction resolveType(targetType, referenceTypesMap = {}, scope) {\n    const tsTypeAnnotationMap = {\n        TSStringKeyword: 'string',\n        TSNumberKeyword: 'number'\n    }\n    switch (targetType.type) {\n        case 'TSTypeAnnotation':\n            if (targetType.typeAnnotation.type === 'TSTypeReference') {\n                return referenceTypesMap[targetType.typeAnnotation.typeName.name]\n            }\n            return tsTypeAnnotationMap[targetType.typeAnnotation.type];\n        case 'NumberTypeAnnotation': \n            return 'number';\n        case 'StringTypeAnnotation':\n            return 'string';\n        case 'TSNumberKeyword':\n            return 'number';\n        case 'TSTypeReference':\n            const typeAlias = scope.getData(targetType.typeName.name);\n            const paramTypes = targetType.typeParameters.params.map(item => {\n                return resolveType(item);\n            });\n            const params = typeAlias.paramNames.reduce((obj, name, index) => {\n                obj[name] = paramTypes[index]; \n                return obj;\n            },{});\n            return typeEval(typeAlias.body, params);\n        case 'TSLiteralType':\n            return targetType.literal.value;\n    }\n}\n\nfunction noStackTraceWrapper(cb) {\n    const tmp = Error.stackTraceLimit;\n    Error.stackTraceLimit = 0;\n    cb && cb(Error);\n    Error.stackTraceLimit = tmp;\n}\n\nconst noFuncAssignLint = declare((api, options, dirname) => {\n    api.assertVersion(7);\n\n    return {\n        pre(file) {\n            file.set('errors', []);\n        },\n        visitor: {\n            TSTypeAliasDeclaration(path) {\n                path.scope.setData(path.get('id').toString(), {\n                    paramNames: path.node.typeParameters.params.map(item => {\n                        return item.name;\n                    }),\n                    body: path.getTypeAnnotation()\n                });\n                path.scope.setData(path.get('params'))\n            },\n            CallExpression(path, state) {\n                const errors = state.file.get('errors');\n                // 泛型参数\n                const realTypes = path.node.typeParameters.params.map(item => {\n                    return resolveType(item, {}, path.scope);\n                });\n                // 实参类型\n                const argumentsTypes = path.get('arguments').map(item => {\n                    return resolveType(item.getTypeAnnotation());\n                });\n                const calleeName = path.get('callee').toString();\n                // 根据函数名查找到函数声明\n                const functionDeclarePath = path.scope.getBinding(calleeName).path;\n                const realTypeMap = {};\n                functionDeclarePath.node.typeParameters.params.map((item, index) => {\n                    realTypeMap[item.name] = realTypes[index];\n                });\n                // 把泛型参数传递给具体的泛型\n                const declareParamsTypes = functionDeclarePath.get('params').map(item => {\n                    return resolveType(item.getTypeAnnotation(), realTypeMap);\n                })\n\n                // 声明类型和具体的类型的对比（类型检查）\n                argumentsTypes.forEach((item, index) => {\n                    if (item !== declareParamsTypes[index]) {\n                        noStackTraceWrapper(Error => {\n                            errors.push(path.get('arguments.' + index ).buildCodeFrameError(`${item} can not assign to ${declareParamsTypes[index]}`,Error));\n                        });\n                    }\n                });\n            }\n        },\n        post(file) {\n            console.log(file.get('errors'));\n        }\n    }\n});\n\nmodule.exports = noFuncAssignLint;\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"就这样，我们实现了 typescript 高级类型！"}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"类型代表了变量的内容和能对它进行的操作，静态类型让检查可以在编译期间做，随着前端项目越来越重，越来越需要  typescript 这类静态类型语言。"}),"\n",(0,t.jsx)(n.p,{children:"类型检查就是做 AST 的对比，判断声明的和实际的是否一致："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"简单类型就直接对比，相当于 if else"}),"\n",(0,t.jsx)(n.li,{children:"带泛型的要先把类型参数传递过去才能确定类型，之后对比，相当于函数调用包裹 if else"}),"\n",(0,t.jsx)(n.li,{children:"带高级类型的泛型的类型检查，多了一个对类型求值的过程，相当于多级函数调用之后再判断 if else"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"实现一个完整的 typescript type cheker 还是很复杂的，不然 typescript checker 部分的代码也不至于好几万行了。但是思路其实没有那么难，按照我们文中的思路来，是可以实现一个完整的 type checker 的。"}),"\n",(0,t.jsx)(n.p,{children:"这一节主要是用到了 path.getTypeAnnotation 的 api 来获取声明的类型，然后进行 AST 的检查，希望能够帮助你理解 type checker 的实现原理。"}),"\n",(0,t.jsx)(n.p,{children:"（当然，文中只是实现了独立的一个个类型的检查，tsc 会递归地做多个文件的全文的类型检查，但是具体的每一部分都是类似的思路。）"}),"\n",(0,t.jsxs)(n.p,{children:["（代码在",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function y(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}let T=y;y.__RSPRESS_PAGE_META={},y.__RSPRESS_PAGE_META["TypeScript%20%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F19.%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%20TypeScript%20%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5.md"]={toc:[{text:"如何检查类型",id:"如何检查类型",depth:2},{text:"代码实现",id:"代码实现",depth:2},{text:"实现简单类型的类型检查",id:"实现简单类型的类型检查",depth:3},{text:"赋值语句的类型检查",id:"赋值语句的类型检查",depth:4},{text:"函数调用的类型检查",id:"函数调用的类型检查",depth:4},{text:"实现带泛型的类型检查",id:"实现带泛型的类型检查",depth:3},{text:"实现带高级类型的函数调用语句的类型检查",id:"实现带高级类型的函数调用语句的类型检查",depth:3},{text:"总结",id:"总结",depth:2}],title:"19.原理篇：实现简易 TypeScript 类型检查",headingTitle:"19.原理篇：实现简易 TypeScript 类型检查",frontmatter:{}}}}]);