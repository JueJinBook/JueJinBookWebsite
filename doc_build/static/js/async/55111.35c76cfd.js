"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55111"],{301424:function(n,e,s){s.r(e),s.d(e,{default:()=>a});var r=s(552676),i=s(740453);let d=s.p+"static/image/7f37978e4512ce67b7a98e4bf8208270.e3252c19.webp",c=s.p+"static/image/0a0bef89c75e3292160792141f6d7cea.fe5852fe.webp",l=s.p+"static/image/96f520d78d16b1babee34b6ecbd05046.0c50e746.webp",t=s.p+"static/image/521cd39e60b5d1a1b29b993a727e5ea5.8fddf997.webp";function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li",img:"img",blockquote:"blockquote"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"10架构组件通信设计",children:["10.架构：组件通信设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10架构组件通信设计",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["通信是一个应用中不可或缺的一个功能，现如今前端视图类框架大多数都是由数据驱动，通过数据来进行视图层的展示渲染。举个简单的例子如下，这是一个常见的 ",(0,r.jsx)(e.strong,{children:"React"})," 列表渲染："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"// each\nconst numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) =>\n  <li>{number}</li>\n);\n\n// render\n<ul>{ listItems }</ul>\n"})}),"\n",(0,r.jsxs)(e.p,{children:["在实际开发场景下，",(0,r.jsx)(e.strong,{children:"numbers"})," 的值往往是动态变化的，通过 ",(0,r.jsx)(e.strong,{children:"setState"})," 可以进行数据的更新从而带动页面视图的渲染，以此来达到数据驱动的结果。"]}),"\n",(0,r.jsxs)(e.p,{children:["一款通用的低代码成品也一定会具备不同的物料组件交互和联动以及",(0,r.jsx)(e.strong,{children:"数据共享"}),"、",(0,r.jsx)(e.strong,{children:"函数执行"}),"等功能。"]}),"\n",(0,r.jsx)(e.p,{children:"因此组件通信是实现低代码平台模块化、提高扩展性和任务连接的关键手段。"}),"\n",(0,r.jsxs)(e.h2,{id:"状态管理设计",children:["状态管理设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#状态管理设计",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["前端应用程序的数据状态通常包括用户输入、服务端返回的数据、组件之间的数据传递等，这些数据状态的变化会影响到前端应用程序的展示和交互。\n在实际应用中，大多数的状态(",(0,r.jsx)(e.strong,{children:"State"}),")都是以下几种形式存在的："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"局部状态管理"}),": 将状态存储在组件的本地状态中，没有通过实例或者是属性向外传递，这种状态适用于简单的区块组件，其特点就是完全内部独立，无需进行共享；"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"全局状态管理"}),"：将状态存储在一个上层容器中，通过向下注入的方式来统一收集状态管理流，统一管理状态的变化的事件的触发，只需要在应用程序中用到的地方进行订阅即可获取最新的状态内容。通常在一些大型应用和复杂的区块模板中会经常使用到。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.strong,{children:"React"})," 中，实现状态管理的方案有很多，其中比较知名的就是 ",(0,r.jsx)(e.strong,{children:"Mobx"})," 与 ",(0,r.jsx)(e.strong,{children:"Redux"}),"，这是早期流行的解决方案，分别是单向数据流与双向数据流的典型代表作品，除此之外，也有 ",(0,r.jsx)(e.strong,{children:"recoil"}),"、",(0,r.jsx)(e.strong,{children:"zustand"}),"、",(0,r.jsx)(e.strong,{children:"xState"})," 等方案都可以实现 ",(0,r.jsx)(e.strong,{children:"React"})," 的状态管理。"]}),"\n",(0,r.jsxs)(e.p,{children:["在低代码平台中，后续实现也会基于 ",(0,r.jsx)(e.strong,{children:"Redux"})," 来实现组件通信的状态管理，选择 ",(0,r.jsx)(e.strong,{children:"Redux"})," 的原因有几下几个方面的考量："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"使用足够简单，应用程序的全局状态都在存储区内的对象树里面，通过派发事件可以来进行对应的状态修改；"}),"\n",(0,r.jsx)(e.li,{children:"扁平化状态管理，可以自顶向下的管理自身的状态引用，能够将应用复杂的状态变得可预测和可维护；"}),"\n",(0,r.jsxs)(e.li,{children:["与框架无关，",(0,r.jsx)(e.strong,{children:"Redux"})," 本身就是一种状态容器，可以在不同的 ",(0,r.jsx)(e.strong,{children:"JS"})," 环境下运行；"]}),"\n",(0,r.jsxs)(e.li,{children:["使用 ",(0,r.jsx)(e.strong,{children:"Redux"})," 的中间件可以让我们在核心层中对状态做一些魔法改造，比如",(0,r.jsx)(e.strong,{children:"日志"}),"、数据处理、错误兜底等一些通用类的处理；"]}),"\n",(0,r.jsxs)(e.li,{children:["调试，借用 ",(0,r.jsx)(e.strong,{children:"redux-tool"})," 可以在开发时更好地理解应用程序中发生的事件和状态的变化，增强错误排查的能力和开发调试的体验。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["以上都是一些使用 ",(0,r.jsx)(e.strong,{children:"Redux"})," 的原因，在低代码平台中也不需要开发者来维护一个非常规范的 ",(0,r.jsx)(e.strong,{children:"Store"})," 目录，减少了很多使用 ",(0,r.jsx)(e.strong,{children:"Redux"})," 时代码组织的烦恼。"]}),"\n",(0,r.jsxs)(e.h2,{id:"数据流",children:["数据流",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据流",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"数据流是指在应用程序中数据传递的方向和路径。在前端开发中，数据流通常是单向的。"}),"\n",(0,r.jsxs)(e.p,{children:["如果在页面的 ",(0,r.jsx)(e.strong,{children:"Text"})," 组件中，我需要来获取一个动态的数据变量(",(0,r.jsx)(e.strong,{children:"root"}),")。此时，会进行一次向上路径树的寻址最终来获取到相关的变量。也可以通过具体的 ",(0,r.jsx)(e.strong,{children:"NamePath"})," 获取对应的状态数据，最终来完成页面的显示。"]}),"\n",(0,r.jsx)(e.p,{children:"如下图所示，是前期对平台一个基本数据链空间的状态流转："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["但在我们的产品设计中，最终还是将状态链的方案给摒弃掉了，而是使用了最基础的 ",(0,r.jsx)(e.strong,{children:"Redux"})," 数据流模式来进行工作，",(0,r.jsx)(e.strong,{children:"通过一个中间件来完成整个状态的调度"}),"。这么做的原因是大部分框架都是由数据来驱动的，",(0,r.jsx)(e.strong,{children:"对于低代码平台的数据流而言，应尽可能的简单，便于预测和集中化统一调度"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["如下图，是一个 ",(0,r.jsx)(e.strong,{children:"Redux"})," 的基本数据流的过程，在平台中，页面组件属性都可以绑定一个 ",(0,r.jsx)(e.strong,{children:"store"})," 层中声明的状态，一旦绑定后，这个属性将会成为一个受控内容，组件的操作往往会引起应用程序状态的改变，而状态的改变又会反过来影响组件的状态和行为。"]}),"\n",(0,r.jsx)(e.p,{children:"这就是组件通信数据流的概念与作用。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(e.h2,{id:"组件联动与操作",children:["组件联动与操作",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#组件联动与操作",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"组件操作是指页面中组件的一些行为和交互，通过这些操作来实现页面的功能。"}),"\n",(0,r.jsx)(e.p,{children:"在设计数据流的时候也提到了受控属性会因为状态发生改变而改变。也就是说一个组件的状态会随着另外一个组件或者本身的操作而发生变化，在组件操作的设计中，大体上分为以下几种："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"事件绑定"}),"：通过绑定事件处理函数来响应用户操作，例如点击、鼠标悬停、拖拽等。事件绑定通常通过 ",(0,r.jsx)(e.strong,{children:"React"})," 的事件系统或其他库来实现，它们可以使得页面变得更加动态和交互性；"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"表达式"}),"： 通过表达式来计算和展示页面的内容和样式。表达式可以是简单的变量、函数调用或复杂的逻辑运算，它们可以使得页面的内容更加灵活和可定制。除此之外，也有类似于 ",(0,r.jsx)(e.strong,{children:"amis"})," 的后端公式法则，也属于是表达式相关的一种；"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"循环遍历&条件判断"}),"：循环遍历和条件判断可以使得页面的结构和内容根据数据来进行相应的显示，往往会随着状态数据改变而重新进行视图的渲染，展示动态变化的页面；"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"属性绑定"}),"：将组件属性变更为可控属性，从而来实现状态与内容的一致和灵活，也是日常开发中最常见的功能之一。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["基于设计好的事件流，后续组件的联动就无需将组件与组件挂钩了，而是与状态关系之间相关联，也就是常见的 ",(0,r.jsx)(e.strong,{children:"UI"}),"(",(0,r.jsx)(e.strong,{children:"State"}),")解法。"]}),"\n",(0,r.jsxs)(e.p,{children:["如下图所示：在逻辑块中创建了",(0,r.jsx)(e.code,{children:"onBtnClick"}),"保存后，此时就创建了一个可执行的函数，在函数内部操作了 ",(0,r.jsx)(e.strong,{children:"Redux"})," 的 ",(0,r.jsx)(e.code,{children:"Dispatch"})," 来派发 ",(0,r.jsx)(e.code,{children:"UPDATE Reducer"})," 更新内容。"]}),"\n",(0,r.jsx)(e.p,{children:"保存函数后，在对应的属性面板点击事件绑定将其进行关联。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:["需要注意的是，所有的表达式在存储的时候都会会进行一个类型的标记。比如上述事例中的 ",(0,r.jsx)(e.code,{children:"onBtnClick"}),"，在协议中会进行如下转换一个简单的数据结构进行存储，参考如下代码："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"...\nonBtnClick: {\n  type: 'Function',\n  source: \"onBtnClick = () => {\\n  __store__.dispatch({\\n    type: 'UPDATE',\\n    payload: {\\n      data: __props__.value + 1\\n    }\\n  })\\n}\"\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"那么这串协议怎么用呢？"}),"\n",(0,r.jsxs)(e.p,{children:["那就需要使用 ",(0,r.jsx)(e.strong,{children:"BrowserCodeExecVM"})," 来进行处理了。如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"BrowserCodeExecVM"})," 是一个代码执行的虚拟容器，它能够动态的解析代码字符串并解析，当绑定事件执行的时候，会被 ",(0,r.jsx)(e.strong,{children:"BrowserCodeExecVM"})," 进行执行，然后将结果返回给触发器的源头，以此来实现一个中继闭环。"]}),"\n",(0,r.jsxs)(e.p,{children:["在本章节中，主要是对其有一个基本的认识了解，在后续动态逻辑执行实现中，会详细的来刨析 ",(0,r.jsx)(e.strong,{children:"BrowserCodeExecVM"})," 的设计与实现过程。"]}),"\n",(0,r.jsxs)(e.h2,{id:"ast与未来",children:["AST与未来",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#ast与未来",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["协议是整个低代码平台的基石，随着对低代码平台的要求越来越高的情况下，那么承载与底层的协议必然会随之迭代的非常复杂。如何使用协议来描述一个组件树，其最终形态能够满足用户将状态、",(0,r.jsx)(e.strong,{children:"props"}),"、表达式等大部分功能可以像 ",(0,r.jsx)(e.strong,{children:"React"})," 一样快速的进行开发。"]}),"\n",(0,r.jsxs)(e.p,{children:["基于此，有部分的同学脑海中立马就浮现了 ",(0,r.jsx)(e.strong,{children:"AST"})," 的身影，基于 ",(0,r.jsx)(e.strong,{children:"AST"})," 方案的抽象协议可以很好的满足用户对大部分状态和组件的交互操作。就目前而言，",(0,r.jsx)(e.strong,{children:"AST"})," 是代码最真实抽象的存在，但是同样的本身结构也非常复杂，相比于搭建平台抽象的协议而言，两者的等级相差还是非常大的。"]}),"\n",(0,r.jsx)(e.p,{children:"在社区中看到一片文章感觉非常有意思，如下代码所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-tsx",children:"{\n    type: 'Component',\n    name: 'Test',\n    props: [\n      {\n        type: 'ComponentProp',\n        name: 'initalValue',\n        init: { type: 'Literal', value: 0 },\n      },\n    ],\n    state: [\n      {\n        type: 'Val',\n        name: 'counter',\n        init: { type: 'Identifier', name: 'initialValue' },\n      },\n    ],\n  }\n\nconst Test = ({ initialValue = 0 }) => {\n  const [counter, setCounter] = useState(initialValue);\n  // ....其他\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这样的设计是 ",(0,r.jsx)(e.strong,{children:"reka.js"})," 的解法，基于 ",(0,r.jsx)(e.strong,{children:"AST"})," 来为搭建页面构建复杂的状态管理。用户可以无负担的将自己搭建的应用呈现在用户面前，这一切的背后工作都是解释器在完成。解释器会根据协议处理好属性，状态，逻辑表达式等一系列的问题。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["但是就目前而言，",(0,r.jsx)(e.strong,{children:"AST"})," 的方案会更加的完善和智能，同样的解析成本和对编辑器的工作要求也是相当之高的。所以说是未来解决方案的一种考量。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在本章节，主要的内容是来设计一个低代码平台的通用化状态管理的过程方案以及组件联动的过程，在接下来的实战当中，会主要使用 ",(0,r.jsx)(e.strong,{children:"Redux"})," 来完成低代码平台状态的管理和事件派发相关。"]}),"\n",(0,r.jsxs)(e.p,{children:["在未来不久，通过动态逻辑执行与在线代码执行 ",(0,r.jsx)(e.strong,{children:"Vm"})," 的帮助，一举来打通整个",(0,r.jsx)(e.strong,{children:"事件 + 状态 = 视图变化"}),"的一个完整体系，真正意义上做到低代码级别的搭建效果。"]}),"\n",(0,r.jsxs)(e.h2,{id:"资源推荐",children:["资源推荐",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#资源推荐",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.a,{href:"https://medium.com/dailyjs/when-do-i-know-im-ready-for-redux-f34da253c85f",target:"_blank",rel:"noopener noreferrer",children:"https://medium.com/dailyjs/when-do-i-know-im-ready-for-redux-f34da253c85f"}),"\n",(0,r.jsx)(e.a,{href:"https://github.com/prevwong/reka.js",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/prevwong/reka.js"}),"\n",(0,r.jsx)(e.a,{href:"https://juejin.cn/post/7204636361197076537",target:"_blank",rel:"noopener noreferrer",children:"https://juejin.cn/post/7204636361197076537"}),"\n",(0,r.jsx)(e.a,{href:"https://zhuanlan.zhihu.com/p/373545726",target:"_blank",rel:"noopener noreferrer",children:"https://zhuanlan.zhihu.com/p/373545726"})]}),"\n",(0,r.jsxs)(e.h2,{id:"写在最后",children:["写在最后",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#写在最后",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"如果你有什么疑问或者更好的建议，欢迎在评论区提出或者加群沟通。 \uD83D\uDC4F"})]})}function x(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(h,{...n})}):h(n)}let a=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F10.%E6%9E%B6%E6%9E%84%EF%BC%9A%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E8%AE%BE%E8%AE%A1.md"]={toc:[{text:"状态管理设计",id:"状态管理设计",depth:2},{text:"数据流",id:"数据流",depth:2},{text:"组件联动与操作",id:"组件联动与操作",depth:2},{text:"AST与未来",id:"ast与未来",depth:2},{text:"总结",id:"总结",depth:2},{text:"资源推荐",id:"资源推荐",depth:2},{text:"写在最后",id:"写在最后",depth:2}],title:"10.架构：组件通信设计",headingTitle:"10.架构：组件通信设计",frontmatter:{}}}}]);