"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["31732"],{553886:function(n,e,r){r.r(e),r.d(e,{default:()=>c});var s=r(552676),d=r(740453);function i(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",ol:"ol",li:"li",strong:"strong",pre:"pre"},(0,d.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"12原理-2交头接耳--通信协议",children:["12原理 2：交头接耳 —— 通信协议",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12原理-2交头接耳--通信协议",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Redis 的作者认为数据库系统的瓶颈一般不在于网络流量，而是数据库自身内部逻辑处理上。所以即使 Redis 使用了浪费流量的文本协议，依然可以取得极高的访问性能。Redis 将所有数据都放在内存，用一个单线程对外提供服务，单个节点在跑满一个 CPU 核心的情况下可以达到了 10w/s 的超高 QPS。"}),"\n",(0,s.jsxs)(e.h2,{id:"respredis-serialization-protocol",children:["RESP(Redis Serialization Protocol)",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#respredis-serialization-protocol",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"RESP 是 Redis 序列化协议的简写。它是一种直观的文本协议，优势在于实现异常简单，解析性能极好。"}),"\n",(0,s.jsxs)(e.p,{children:["Redis 协议将传输的结构数据分为 5 种最小单元类型，单元结束时统一加上回车换行符号",(0,s.jsx)(e.code,{children:"\\r\\n"}),"。"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["单行字符串 以 ",(0,s.jsx)(e.code,{children:"+"})," 符号开头。"]}),"\n",(0,s.jsxs)(e.li,{children:["多行字符串 以 ",(0,s.jsx)(e.code,{children:"$"})," 符号开头，后跟字符串长度。"]}),"\n",(0,s.jsxs)(e.li,{children:["整数值 以 ",(0,s.jsx)(e.code,{children:":"})," 符号开头，后跟整数的字符串形式。"]}),"\n",(0,s.jsxs)(e.li,{children:["错误消息 以 ",(0,s.jsx)(e.code,{children:"-"})," 符号开头。"]}),"\n",(0,s.jsxs)(e.li,{children:["数组 以 ",(0,s.jsx)(e.code,{children:"*"})," 号开头，后跟数组的长度。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"单行字符串"})," hello world"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"+hello world\\r\\n\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"多行字符串"})," hello world"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"$11\\r\\nhello world\\r\\n\n"})}),"\n",(0,s.jsx)(e.p,{children:"多行字符串当然也可以表示单行字符串。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"整数"})," 1024"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:":1024\\r\\n\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"错误"})," 参数类型错误"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"-WRONGTYPE Operation against a key holding the wrong kind of value\\r\\n\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"数组"})," [1,2,3]"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"*3\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"NULL"})," 用多行字符串表示，不过长度要写成-1。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"$-1\\r\\n\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"空串"})," 用多行字符串表示，长度填 0。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"$0\\r\\n\\r\\n\n"})}),"\n",(0,s.jsxs)(e.p,{children:["注意这里有两个",(0,s.jsx)(e.code,{children:"\\r\\n"}),"。为什么是两个?因为两个",(0,s.jsx)(e.code,{children:"\\r\\n"}),"之间,隔的是空串。"]}),"\n",(0,s.jsxs)(e.h2,{id:"客户端---服务器",children:["客户端 -> 服务器",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#客户端---服务器",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["客户端向服务器发送的指令只有一种格式，多行字符串数组。比如一个简单的 set 指令",(0,s.jsx)(e.code,{children:"set author codehole"}),"会被序列化成下面的字符串。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"*3\\r\\n$3\\r\\nset\\r\\n$6\\r\\nauthor\\r\\n$8\\r\\ncodehole\\r\\n\n"})}),"\n",(0,s.jsx)(e.p,{children:"在控制台输出这个字符串如下，可以看出这是很好阅读的一种格式。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"*3\n$3\nset\n$6\nauthor\n$8\ncodehole\n\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"服务器---客户端",children:["服务器 -> 客户端",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#服务器---客户端",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"服务器向客户端回复的响应要支持多种数据结构，所以消息响应在结构上要复杂不少。不过再复杂的响应消息也是以上 5 中基本类型的组合。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"单行字符串响应"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"127.0.0.1:6379> set author codehole\nOK\n"})}),"\n",(0,s.jsx)(e.p,{children:"这里的 OK 就是单行响应，没有使用引号括起来。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"+OK\n\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"错误响应"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"127.0.0.1:6379> incr author\n(error) ERR value is not an integer or out of range\n"})}),"\n",(0,s.jsx)(e.p,{children:"试图对一个字符串进行自增，服务器抛出一个通用的错误。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"-ERR value is not an integer or out of range\n\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"整数响应"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"127.0.0.1:6379> incr books\n(integer) 1\n"})}),"\n",(0,s.jsxs)(e.p,{children:["这里的",(0,s.jsx)(e.code,{children:"1"}),"就是整数响应"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:":1\n\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"多行字符串响应"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'127.0.0.1:6379> get author\n"codehole"\n'})}),"\n",(0,s.jsx)(e.p,{children:"这里使用双引号括起来的字符串就是多行字符串响应"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"$8\ncodehole\n\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"数组响应"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'127.0.0.1:6379> hset info name laoqian\n(integer) 1\n127.0.0.1:6379> hset info age 30\n(integer) 1\n127.0.0.1:6379> hset info sex male\n(integer) 1\n127.0.0.1:6379> hgetall info\n1) "name"\n2) "laoqian"\n3) "age"\n4) "30"\n5) "sex"\n6) "male"\n'})}),"\n",(0,s.jsx)(e.p,{children:"这里的 hgetall 命令返回的就是一个数组，第 0|2|4 位置的字符串是 hash 表的 key，第 1|3|5 位置的字符串是 value，客户端负责将数组组装成字典再返回。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"*6\n$4\nname\n$6\nlaoqian\n$3\nage\n$2\n30\n$3\nsex\n$4\nmale\n\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"嵌套"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'127.0.0.1:6379> scan 0\n1) "0"\n2) 1) "info"\n   2) "books"\n   3) "author"\n'})}),"\n",(0,s.jsx)(e.p,{children:"scan 命令用来扫描服务器包含的所有 key 列表，它是以游标的形式获取，一次只获取一部分。"}),"\n",(0,s.jsx)(e.p,{children:"scan 命令返回的是一个嵌套数组。数组的第一个值表示游标的值，如果这个值为零，说明已经遍历完毕。如果不为零，使用这个值作为 scan 命令的参数进行下一次遍历。数组的第二个值又是一个数组，这个数组就是 key 列表。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"*2\n$1\n0\n*3\n$4\ninfo\n$5\nbooks\n$6\nauthor\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"Redis 协议里有大量冗余的回车换行符，但是这不影响它成为互联网技术领域非常受欢迎的一个文本协议。有很多开源项目使用 RESP 作为它的通讯协议。在技术领域性能并不总是一切，还有简单性、易理解性和易实现性，这些都需要进行适当权衡。"}),"\n",(0,s.jsxs)(e.h2,{id:"扩展阅读",children:["扩展阅读",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展阅读",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["如果你想自己实现一套Redis协议的解码器，请阅读老钱的另一篇文章",(0,s.jsx)(e.a,{href:"https://juejin.im/post/5aaf1e0af265da2381556c0e",target:"_blank",rel:"noopener noreferrer",children:"《基于Netty实现Redis协议的编码解码器》"})]})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(i,{...n})}):i(n)}let c=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F12%E5%8E%9F%E7%90%86%202%EF%BC%9A%E4%BA%A4%E5%A4%B4%E6%8E%A5%E8%80%B3%20%E2%80%94%E2%80%94%20%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.md"]={toc:[{text:"RESP(Redis Serialization Protocol)",id:"respredis-serialization-protocol",depth:2},{text:"客户端 -> 服务器",id:"客户端---服务器",depth:2},{text:"服务器 -> 客户端",id:"服务器---客户端",depth:2},{text:"小结",id:"小结",depth:2},{text:"扩展阅读",id:"扩展阅读",depth:2}],title:"12原理 2：交头接耳 —— 通信协议",headingTitle:"12原理 2：交头接耳 —— 通信协议",frontmatter:{}}}}]);