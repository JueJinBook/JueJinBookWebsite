"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["66021"],{133747:function(r,e,n){n.r(e),n.d(e,{default:()=>s});var t=n(552676),i=n(740453);function h(r){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",code:"code",pre:"pre",ol:"ol",li:"li"},(0,i.ah)(),r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"42源码-10跋山涉水--深入字典遍历",children:["42源码 10：跋山涉水 —— 深入字典遍历",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#42源码-10跋山涉水--深入字典遍历",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"Redis 字典的遍历过程逻辑比较复杂，互联网上对这一块的分析讲解非常少。我也花了不少时间对源码的细节进行了整理，将我个人对字典遍历逻辑的理解呈现给各位读者。也许读者们对字典的遍历过程有比我更好的理解，还请不吝指教。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"https://user-gold-cdn.xitu.io/2018/8/15/1653bd1a8cbe5f4d?w=485&h=370&f=png&s=31214",alt:""})}),"\n",(0,t.jsxs)(e.h2,{id:"一边遍历一边修改",children:["一边遍历一边修改",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一边遍历一边修改",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["我们知道 Redis 对象树的主干是一个字典，如果对象很多，这个主干字典也会很大。当我们使用 ",(0,t.jsx)(e.code,{children:"keys"})," 命令搜寻指定模式的 key 时，它会遍历整个主干字典。值得注意的是，在遍历的过程中，如果满足模式匹配条件的 key 被找到了，还需要判断 key 指向的对象是否已经过期。如果过期了就需要从主干字典中将该 key 删除。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-c",children:"void keysCommand(client *c) {\r\n    dictIterator *di; // 迭代器\r\n    dictEntry *de; // 迭代器当前的entry\r\n    sds pattern = c->argv[1]->ptr; // keys的匹配模式参数\r\n    int plen = sdslen(pattern);\r\n    int allkeys; // 是否要获取所有key，用于keys *这样的指令\r\n    unsigned long numkeys = 0;\r\n    void *replylen = addDeferredMultiBulkLength(c);\r\n\r\n    // why safe? \r\n    di = dictGetSafeIterator(c->db->dict);\r\n    allkeys = (pattern[0] == '*' && pattern[1] == '\\0');\r\n    while((de = dictNext(di)) != NULL) {\r\n        sds key = dictGetKey(de);\r\n        robj *keyobj;\r\n\r\n        if (allkeys || stringmatchlen(pattern,plen,key,sdslen(key),0)) {\r\n            keyobj = createStringObject(key,sdslen(key));\r\n            // 判断是否过期，过期了要删除元素\r\n            if (expireIfNeeded(c->db,keyobj) == 0) {\r\n                addReplyBulk(c,keyobj);\r\n                numkeys++;\r\n            }\r\n            decrRefCount(keyobj);\r\n        }\r\n    }\r\n    dictReleaseIterator(di);\r\n    setDeferredMultiBulkLength(c,replylen,numkeys);\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"那么，你是否想到了其中的困难之处，在遍历字典的时候还需要修改字典，会不会出现指针安全问题？"}),"\n",(0,t.jsxs)(e.h2,{id:"重复遍历",children:["重复遍历",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#重复遍历",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"字典在扩容的时候要进行渐进式迁移，会存在新旧两个 hashtable。遍历需要对这两个 hashtable 依次进行，先遍历完旧的 hashtable，再继续遍历新的 hashtable。如果在遍历的过程中进行了 rehashStep，将已经遍历过的旧的 hashtable 的元素迁移到了新的 hashtable 中，那么遍历会不会出现元素的重复？这也是遍历需要考虑的疑难之处，下面我们来看看 Redis 是如何解决这个问题的。"}),"\n",(0,t.jsxs)(e.h2,{id:"迭代器的结构",children:["迭代器的结构",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#迭代器的结构",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"Redis 为字典的遍历提供了 2 种迭代器，一种是安全迭代器，另一种是不安全迭代器。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-c",children:"typedef struct dictIterator {\r\n    dict *d; // 目标字典对象\r\n    long index; // 当前遍历的槽位置，初始化为-1\r\n    int table; // ht[0] or ht[1]\r\n    int safe; // 这个属性非常关键，它表示迭代器是否安全\r\n    dictEntry *entry; // 迭代器当前指向的对象\r\n    dictEntry *nextEntry; // 迭代器下一个指向的对象\r\n    long long fingerprint; // 迭代器指纹，放置迭代过程中字典被修改\r\n} dictIterator;\r\n\r\n// 获取非安全迭代器，只读迭代器，允许rehashStep\r\ndictIterator *dictGetIterator(dict *d)\r\n{\r\n    dictIterator *iter = zmalloc(sizeof(*iter));\r\n\r\n    iter->d = d;\r\n    iter->table = 0;\r\n    iter->index = -1;\r\n    iter->safe = 0;\r\n    iter->entry = NULL;\r\n    iter->nextEntry = NULL;\r\n    return iter;\r\n}\r\n\r\n// 获取安全迭代器，允许触发过期处理，禁止rehashStep\r\ndictIterator *dictGetSafeIterator(dict *d) {\r\n    dictIterator *i = dictGetIterator(d);\r\n\r\n    i->safe = 1;\r\n    return i;\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"迭代器的「安全」指的是在遍历过程中可以对字典进行查找和修改，不用感到担心，因为查找和修改会触发过期判断，会删除内部元素。「安全」的另一层意思是迭代过程中不会出现元素重复，为了保证不重复，就会禁止 rehashStep。"}),"\n",(0,t.jsx)(e.p,{children:"而「不安全」的迭代器是指遍历过程中字典是只读的，你不可以修改，你只能调用 dictNext 对字典进行持续遍历，不得调用任何可能触发过期判断的函数。不过好处是不影响 rehash，代价就是遍历的元素可能会出现重复。"}),"\n",(0,t.jsx)(e.p,{children:"安全迭代器在刚开始遍历时，会给字典打上一个标记，有了这个标记，rehashStep 就不会执行，遍历时元素就不会出现重复。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-c",children:"typedef struct dict {\r\n    dictType *type;\r\n    void *privdata;\r\n    dictht ht[2];\r\n    long rehashidx;\r\n    // 这个就是标记，它表示当前加在字典上的安全迭代器的数量\r\n    unsigned long iterators;\r\n} dict;\r\n\r\n// 如果存在安全的迭代器，就禁止rehash\r\nstatic void _dictRehashStep(dict *d) {\r\n    if (d->iterators == 0) dictRehash(d,1);\r\n}\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"迭代过程",children:["迭代过程",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#迭代过程",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"安全的迭代器在遍历过程中允许删除元素，意味着字典第一维数组下面挂接的链表中的元素可能会被摘走，元素的 next 指针就会发生变动，这是否会影响迭代过程呢？下面我们仔细研究一下迭代函数的代码逻辑。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"dictEntry *dictNext(dictIterator *iter)\r\n{\r\n    while (1) {\r\n        if (iter->entry == NULL) {\r\n            // 遍历一个新槽位下面的链表，数组的index往前移动了\r\n            dictht *ht = &iter->d->ht[iter->table];\r\n            if (iter->index == -1 && iter->table == 0) {\r\n                // 第一次遍历，刚刚进入遍历过程\r\n                // 也就是ht[0]数组的第一个元素下面的链表\r\n                if (iter->safe) {\r\n                  // 给字典打安全标记，禁止字典进行rehash\r\n                  iter->d->iterators++;\r\n                } else {\r\n                  // 记录迭代器指纹，就好比字典的md5值\r\n                  // 如果遍历过程中字典有任何变动，指纹就会改变\r\n                  iter->fingerprint = dictFingerprint(iter->d);\r\n                }      \r\n            }\r\n            iter->index++; // index=0，正式进入第一个槽位\r\n            if (iter->index >= (long) ht->size) {\r\n                // 最后一个槽位都遍历完了\r\n                if (dictIsRehashing(iter->d) && iter->table == 0) {\r\n                    // 如果处于rehash中，那就继续遍历第二个 hashtable\r\n                    iter->table++;\r\n                    iter->index = 0;\r\n                    ht = &iter->d->ht[1];\r\n                } else {\r\n                    // 结束遍历\r\n                    break;\r\n                }\r\n            }\r\n            // 将当前遍历的元素记录到迭代器中\r\n            iter->entry = ht->table[iter->index];\r\n        } else {\r\n            // 直接将下一个元素记录为本次迭代的元素\r\n            iter->entry = iter->nextEntry;\r\n        }\r\n        if (iter->entry) {\r\n            // 将下一个元素也记录到迭代器中，这点非常关键\r\n            // 防止安全迭代过程中当前元素被过期删除后，找不到下一个需要遍历的元素\r\n            \r\n            // 试想如果后面发生了rehash，当前遍历的链表被打散了，会发生什么\r\n            // 这里要使劲发挥自己的想象力来理解\r\n            // 旧的链表将一分为二，打散后重新挂接到新数组的两个槽位下\r\n            // 结果就是会导致当前链表上的元素会重复遍历\r\n            \r\n            // 如果rehash的链表是index前面的链表，那么这部分链表也会被重复遍历\r\n            iter->nextEntry = iter->entry->next;\r\n            return iter->entry;\r\n        }\r\n    }\r\n    return NULL;\r\n}\r\n\r\n// 遍历完成后要释放迭代器，安全迭代器需要去掉字典的禁止rehash的标记\r\n// 非安全迭代器还需要检查指纹，如果有变动，服务器就会奔溃(failfast)\r\nvoid dictReleaseIterator(dictIterator *iter)\r\n{\r\n    if (!(iter->index == -1 && iter->table == 0)) {\r\n        if (iter->safe)\r\n            iter->d->iterators--; // 去掉禁止rehash的标记\r\n        else\r\n            assert(iter->fingerprint == dictFingerprint(iter->d));\r\n    }\r\n    zfree(iter);\r\n}\r\n\r\n// 计算字典的指纹，就是将字典的关键字段进行按位糅合到一起\r\n// 这样只要有任意的结构变动，指纹都会发生变化\r\n// 如果只是某个元素的value被修改了，指纹不会发生变动\r\nlong long dictFingerprint(dict *d) {\r\n    long long integers[6], hash = 0;\r\n    int j;\r\n\r\n    integers[0] = (long) d->ht[0].table;\r\n    integers[1] = d->ht[0].size;\r\n    integers[2] = d->ht[0].used;\r\n    integers[3] = (long) d->ht[1].table;\r\n    integers[4] = d->ht[1].size;\r\n    integers[5] = d->ht[1].used;\r\n\r\n    for (j = 0; j < 6; j++) {\r\n        hash += integers[j];\r\n        hash = (~hash) + (hash << 21);\r\n        hash = hash ^ (hash >> 24);\r\n        hash = (hash + (hash << 3)) + (hash << 8);\r\n        hash = hash ^ (hash >> 14);\r\n        hash = (hash + (hash << 2)) + (hash << 4);\r\n        hash = hash ^ (hash >> 28);\r\n        hash = hash + (hash << 31);\r\n    }\r\n    return hash;\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"值得注意的是在字典扩容时进行 rehash，将旧数组中的链表迁移到新的数组中。某个具体槽位下的链表只可能会迁移到新数组的两个槽位中。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"hash mod 2^n = k\r\nhash mod 2^(n+1) = k or k+2^n\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"迭代器的选择",children:["迭代器的选择",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#迭代器的选择",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["除了 ",(0,t.jsx)(e.code,{children:"keys"})," 指令使用了安全迭代器，因为结果不允许重复。那还有其它的地方使用了安全迭代器么，什么情况下遍历适合使用非安全迭代器呢？"]}),"\n",(0,t.jsxs)(e.p,{children:["简单一点说，那就是如果遍历过程中不允许出现重复，那就使用 ",(0,t.jsx)(e.code,{children:"SafeIterator"}),"，比如下面的两种情况"]}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"bgaofrewrite"})," 需要遍历所有对象转换称操作指令进行持久化，绝对不允许出现重复"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"bgsave"})," 也需要遍历所有对象来持久化，同样不允许出现重复"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:["如果遍历过程中需要处理元素过期，需要对字典进行修改，那也必须使用 ",(0,t.jsx)(e.code,{children:"SafeIterator"}),"，因为非安全的迭代器是只读的。"]}),"\n",(0,t.jsx)(e.p,{children:"其它情况下，也就是允许遍历过程中出现个别元素重复，不需要对字典进行结构性修改的情况下一律使用非安全迭代器。"}),"\n",(0,t.jsxs)(e.h2,{id:"思考",children:["思考",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思考",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["请继续思考 ",(0,t.jsx)(e.code,{children:"rehash"})," 对非安全遍历过程的影响，会重复哪些元素，重复的元素会非常多么还是只是少量重复？"]})]})}function d(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),r.components);return e?(0,t.jsx)(e,{...r,children:(0,t.jsx)(h,{...r})}):h(r)}let s=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Redis%20%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F42%E6%BA%90%E7%A0%81%2010%EF%BC%9A%E8%B7%8B%E5%B1%B1%E6%B6%89%E6%B0%B4%20%E2%80%94%E2%80%94%20%E6%B7%B1%E5%85%A5%E5%AD%97%E5%85%B8%E9%81%8D%E5%8E%86.md"]={toc:[{text:"一边遍历一边修改",id:"一边遍历一边修改",depth:2},{text:"重复遍历",id:"重复遍历",depth:2},{text:"迭代器的结构",id:"迭代器的结构",depth:2},{text:"迭代过程",id:"迭代过程",depth:2},{text:"迭代器的选择",id:"迭代器的选择",depth:2},{text:"思考",id:"思考",depth:2}],title:"42源码 10：跋山涉水 —— 深入字典遍历",headingTitle:"42源码 10：跋山涉水 —— 深入字典遍历",frontmatter:{}}}}]);