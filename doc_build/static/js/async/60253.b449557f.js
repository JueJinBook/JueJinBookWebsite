"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["60253"],{869089:function(n,e,s){s.r(e),s.d(e,{default:()=>v});var r=s(552676),i=s(740453);let t=s.p+"static/image/c7e31d24bcf4336ffd84d5edbca891d2.5f002b26.webp",a=s.p+"static/image/3b8e4487a856f8620739b09be7ac6df7.fd3bec0f.webp",c=s.p+"static/image/03cbbf0cfc1a8a022cfb7e863d0e02e1.3f0c1746.webp",d=s.p+"static/image/a927c5acd654d0e3ca47120f215052ae.8a418ca4.webp",l=s.p+"static/image/c90c0fceaa39695f02c122cb64cbada0.e8528e8a.webp",h=s.p+"static/image/acc22fae85c28b2a1a42b10f89bbfd6d.424cab5e.webp",o=s.p+"static/image/d1e9d31437c464865ec820b073cb11c4.23b25f26.webp",x=s.p+"static/image/908d7ee51ff83ac67bfb700a595900bb.4432db71.webp",j=s.p+"static/image/64f94b4819ab55d2bedd7c67390594a5.fda9e9ac.webp",u=s.p+"static/image/6d43dddeeafb31277dd944a20391e735.9d9ff2cb.webp",p=s.p+"static/image/ee63e6e3389aaf591a7c321d68d70a57.bcfbfae7.webp",g=s.p+"static/image/1f551666c66cbb09fd1b84f48549d828.339d2479.webp",f=s.p+"static/image/7ec4e79cbb0b51eb1f962793782b9456.cdc0d0e8.webp",m=s.p+"static/image/b70a07fff71710ad25b08562bd5b85c5.aca0a9f1.webp";function T(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",ul:"ul",li:"li",strong:"strong",blockquote:"blockquote",h2:"h2",h3:"h3",pre:"pre",img:"img",h4:"h4"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"34v18特性篇-transition",children:["34.V18特性篇-transition",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#34v18特性篇-transition",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在 React 18 中，引进了一个新的 API —— ",(0,r.jsx)(e.code,{children:"startTransition"})," 还有二个新的 hooks —— ",(0,r.jsx)(e.code,{children:"useTransition"})," 和 ",(0,r.jsx)(e.code,{children:"useDeferredValue"}),"，本质上它们离不开一个概念 ",(0,r.jsx)(e.code,{children:"transition"})," 。"]}),"\n",(0,r.jsx)(e.p,{children:"通过本章节学习，你将收获以下内容："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Transition"})," 产生初衷，解决了什么问题。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"startTransition"})," 的用法和原理。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"useTranstion"})," 的用法和原理。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"useDeferredValue"})," 的用法和原理。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["什么叫做 ",(0,r.jsx)(e.code,{children:"transition"})," 英文翻译为 ",(0,r.jsx)(e.strong,{children:"‘过渡’"}),"，那么这里的过渡指的就是在一次更新中，数据展现从无到有的过渡效果。用 ",(0,r.jsx)(e.a,{href:"https://github.com/reactwg/react-18/discussions/41",target:"_blank",rel:"noopener noreferrer",children:"ReactWg"})," 中的一句话描述 startTransition 。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["在大屏幕视图更新的时，startTransition 能够保持页面有响应，这个 api 能够把 React 更新标记成一个特殊的更新类型 ",(0,r.jsx)(e.code,{children:"transitions"})," ，在这种特殊的更新下，React 能够保持视觉反馈和浏览器的正常响应。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["单单从上述对 ",(0,r.jsx)(e.code,{children:"startTransition"})," 的描述，我们很难理解这个新的 api 到底解决什么问题。不过不要紧，接下来让我逐步分析这个 api 到底做了什么，以及它的应用场景。"]}),"\n",(0,r.jsxs)(e.h2,{id:"二-transition-使命",children:["二 transition 使命",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二-transition-使命",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"1-transition-的诞生",children:["1 transition 的诞生",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-transition-的诞生",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"为什么会出现 Transition 呢？ Transition 本质上解决了渲染并发的问题，在 React 18 关于 startTransition 描述的时候，多次提到 ‘大屏幕’ 的情况，这里的大屏幕并不是单纯指的是尺寸，而是一种数据量大，DOM 元素节点多的场景，比如数据可视化大屏情况，在这一场景下，一次更新带来的变化可能是巨大的，所以频繁的更新，执行 js 事务频繁调用，浏览器要执行大量的渲染工作，所以给用户感觉就是卡顿。"}),"\n",(0,r.jsxs)(e.p,{children:["Transition 本质上是用于一些不是很急迫的更新上，在 React 18 之前，所有的更新任务都被视为急迫的任务，在 React 18 诞生了 ",(0,r.jsx)(e.code,{children:"concurrent Mode"})," 模式，在这个模式下，渲染是可以中断，低优先级任务，可以让高优先级的任务先更新渲染。可以说 React 18 更青睐于良好的用户体验。从  ",(0,r.jsx)(e.code,{children:"concurrent Mode"})," 到 ",(0,r.jsx)(e.code,{children:"susponse"})," 再到 ",(0,r.jsx)(e.code,{children:"startTransition"})," 无疑都是围绕着更优质的用户体验展开。"]}),"\n",(0,r.jsxs)(e.p,{children:["startTransition 依赖于 ",(0,r.jsx)(e.code,{children:"concurrent Mode"})," 渲染并发模式。也就是说在 React 18 中使用 ",(0,r.jsx)(e.code,{children:"startTransition"})," ，那么要先开启并发模式，也就是需要通过 ",(0,r.jsx)(e.code,{children:"createRoot"})," 创建 Root 。我们先来看一下两种模式下，创建 Root 区别。"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"传统 legacy 模式"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"import ReactDOM from 'react-dom'\n/* 通过 ReactDOM.render  */\nReactDOM.render(\n    <App />,\n    document.getElementById('app')\n)\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"v18 concurrent Mode并发模式"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"import ReactDOM from 'react-dom'\n/* 通过 createRoot 创建 root */\nconst root =  ReactDOM.createRoot(document.getElementById('app'))\n/* 调用 root 的 render 方法 */\nroot.render(<App/>)\n\n"})}),"\n",(0,r.jsx)(e.p,{children:"上面说了 startTransition 使用条件，接下来探讨一下 startTransition 到底应用于什么场景。 前面说了 React 18 确定了不同优先级的更新任务，为什么会有不同优先级的任务。世界上本来没有路，走的人多了就成了路，优先级产生也是如此，React 世界里本来没有优先级，场景多了就出现了优先级。"}),"\n",(0,r.jsxs)(e.p,{children:["如果一次更新中，都是同样的任务，那么也就无任务优先级可言，统一按批次处理任务就可以了，可现实恰好不是这样子。举一个很常见的场景：",(0,r.jsxs)(e.strong,{children:["就是有一个 ",(0,r.jsx)(e.code,{children:"input"})," 表单。并且有一个大量数据的列表，通过表单输入内容，对列表数据进行搜索，过滤。那么在这种情况下，就存在了多个并发的更新任务。分别为"]})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"第一种：input 表单要实时获取状态，所以是受控的，那么更新 input 的内容，就要触发更新任务。"}),"\n",(0,r.jsx)(e.li,{children:"第二种：input 内容改变，过滤列表，重新渲染列表也是一个任务。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"第一种类型的更新，在输入的时候，希望是的视觉上马上呈现变化，如果输入的时候，输入的内容延时显示，会给用户一种极差的视觉体验。第二种类型的更新就是根据数据的内容，去过滤列表中的数据，渲染列表，这个种类的更新，和上一种比起来优先级就没有那么高。那么如果 input 搜索过程中用户更优先希望的是输入框的状态改变，那么正常情况下，在 input 中绑定 onChange 事件用来触发上述的两种类的更新。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const handleChange=(e)=>{\n   /* 改变搜索条件 */ \n   setInputValue(e.target.value)\n   /* 改变搜索过滤后列表状态 */\n   setSearchQuery(e.target.value)\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上述这种写法，那么 ",(0,r.jsx)(e.code,{children:"setInputValue"})," 和 ",(0,r.jsx)(e.code,{children:"setSearchQuery"})," 带来的更新就是一个相同优先级的更新。而前面说道，",(0,r.jsx)(e.strong,{children:"输入框状态改变更新优先级要大于列表的更新的优先级。"})," ，这个时候我们的主角就登场了。用 ",(0,r.jsx)(e.code,{children:"startTransition"})," 把两种更新区别开。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const handleChange=()=>{\n    /* 高优先级任务 —— 改变搜索条件 */\n    setInputValue(e.target.value)\n    /* 低优先级任务 —— 改变搜索过滤后列表状态  */\n    startTransition(()=>{\n        setSearchQuery(e.target.value)\n    })\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"如上通过 startTransition 把不是特别迫切的更新任务 setSearchQuery  隔离出来。这样在真实的情景效果如何呢？我们来测试一下。"}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"2-模拟场景",children:["2 模拟场景",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-模拟场景",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"接下来我们模拟一下上述场景。流程大致是这样的："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"有一个搜索框和一个 10000 条数据的列表，列表中每一项有相同的文案。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"input 改变要实时改变 input 的内容（第一种更新），然后高亮列表里面的相同的搜索值（第二种更新）。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["用一个按钮控制 常规模式 ｜ ",(0,r.jsx)(e.code,{children:"transition"})," 模式。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"/*  模拟数据  */\nconst mockDataArray = new Array(10000).fill(1)\n/* 高量显示内容 */\nfunction ShowText({ query }){\n   const text = 'asdfghjk'\n   let children\n   if(text.indexOf(query) > 0 ){\n       /* 找到匹配的关键词 */\n       const arr = text.split(query)\n       children = <div>{arr[0]}<span style={{ color:'pink' }} >{query}</span>{arr[1]} </div>\n   }else{\n      children = <div>{text}</div>\n   }\n   return <div>{children}</div>\n}\n/* 列表数据 */\nfunction List ({ query }){\n    console.log('List渲染')\n    return <div>\n        {\n           mockDataArray.map((item,index)=><div key={index} >\n              <ShowText query={query} />\n           </div>)\n        }\n    </div>\n}\n/* memo 做优化处理  */\nconst NewList = memo(List)\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"List"})," 组件渲染一万个 ",(0,r.jsx)(e.code,{children:"ShowText"})," 组件。在 ShowText 组件中会通过传入的 query 实现动态高亮展示。"]}),"\n",(0,r.jsxs)(e.li,{children:["因为每一次改变 ",(0,r.jsx)(e.code,{children:"query"})," 都会让 10000 个重新渲染更新，并且还要展示 query 的高亮内容，所以满足",(0,r.jsx)(e.strong,{children:"并发渲染"}),"的场景。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"接下来就是 App 组件编写。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"export default function App(){\n    const [ value ,setInputValue ] = React.useState('')\n    const [ isTransition , setTransion ] = React.useState(false)\n    const [ query ,setSearchQuery  ] = React.useState('')\n    const handleChange = (e) => {\n        /* 高优先级任务 —— 改变搜索条件 */\n        setInputValue(e.target.value)\n        if(isTransition){ /* transition 模式 */\n            React.startTransition(()=>{\n                /* 低优先级任务 —— 改变搜索过滤后列表状态  */\n                setSearchQuery(e.target.value)\n            })\n        }else{ /* 不加优化，传统模式 */\n            setSearchQuery(e.target.value)\n        }\n    }\n    return <div>\n        <button onClick={()=>setTransion(!isTransition)} >{isTransition ? 'transition' : 'normal'} </button>\n        <input onChange={handleChange}\n            placeholder=\"输入搜索内容\"\n            value={value}\n        />\n       <NewList  query={query} />\n    </div>\n}\n\n"})}),"\n",(0,r.jsx)(e.p,{children:"我们看一下 App 做了哪些事情。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"首先通过 handleChange 事件来处理 onchange 事件。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"button"}),"按钮用来切换 ",(0,r.jsx)(e.strong,{children:"transition"})," （设置优先级） 和 ",(0,r.jsx)(e.strong,{children:"normal"})," （正常模式）。接下来就是见证神奇的时刻。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"常规模式下效果："})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:m,alt:"1.gif"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"可以清楚的看到在常规模式下，输入内容，内容呈现都变的异常卡顿，给人一种极差的用户体验。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"transtion 模式下效果："})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:f,alt:"2.gif"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"把大量并发任务通过 startTransition 处理之后，可以清楚看到，input 会正常的呈现，更新列表任务变得滞后，不过用户体验大幅度提升，"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"整体效果："})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:g,alt:"3.gif"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"来感受一些 startTransition 的魅力。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"总结："})," 通过上面可以直观的看到 startTransition 在处理过渡任务，优化用户体验上起到了举足轻重的作用。"]}),"\n",(0,r.jsxs)(e.h3,{id:"3-为什么不是-settimeout",children:["3 为什么不是 setTimeout",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-为什么不是-settimeout",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["上述的问题能够把 ",(0,r.jsx)(e.code,{children:"setSearchQuery"})," 的更新包装在 ",(0,r.jsx)(e.code,{children:"setTimeout"})," 内部呢，像如下这样。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const handleChange=()=>{\n    /* 高优先级任务 —— 改变搜索条件 */\n    setInputValue(e.target.value)\n    /* 把 setSearchQuery 通过延时器包裹  */\n    setTimeout(()=>{\n        setSearchQuery(e.target.value)\n    },0)\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"这里通过 setTimeout ，把更新放在 setTimeout 内部，那么我们都知道 setTimeout 是属于延时器任务，它不会阻塞浏览器的正常绘制，浏览器会在下次空闲时间之行 setTimeout 。那么效果如何呢？我们来看一下："}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:"4.gif"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"如上可以看到，通过 setTimeout 确实可以让输入状态好一些，但是由于 setTimeout 本身也是一个宏任务，而每一次触发 onchange 也是宏任务，所以 setTimeout 还会影响页面的交互体验。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"综上所述，startTransition 相比 setTimeout 的优势和异同是："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["一方面：startTransition 的处理逻辑和 setTimeout 有一个",(0,r.jsx)(e.strong,{children:"很重要的区别"}),"，setTimeout 是异步延时执行，而 startTransition 的回调函数是同步执行的。在 startTransition 之中任何更新，都会标记上 ",(0,r.jsx)(e.code,{children:"transition"}),"，React 将在更新的时候，判断这个标记来决定是否完成此次更新。所以 Transition 可以理解成比 setTimeout 更早的更新。但是同时要保证 ui 的正常响应，在性能好的设备上，transition 两次更新的延迟会很小，但是在慢的设备上，延时会很大，但是不会影响 UI 的响应。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["另一方面，就是通过上面例子，可以看到，对于渲染并发的场景下，setTimeout 仍然会使页面卡顿。因为超时后，还会执行 setTimeout 的任务，它们与用户交互同样属于宏任务，所以仍然会阻止页面的交互。那么 ",(0,r.jsx)(e.code,{children:"transition"})," 就不同了，在 conCurrent mode 下，",(0,r.jsx)(e.code,{children:"startTransition"})," 是可以中断渲染的 ，所以它不会让页面卡顿，React 让这些任务，在浏览器空闲时间执行，所以上述输入 input 内容时，startTransition 会优先处理 input 值的更新，而之后才是列表的渲染。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"4-为什么不是节流防抖",children:["4 为什么不是节流防抖",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-为什么不是节流防抖",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["那么我们再想一个问题，为什么不是节流和防抖。首先节流和防抖能够解决卡顿的问题吗？答案是一定的，在没有 transition 这样的 api 之前，就只能通过",(0,r.jsx)(e.strong,{children:"防抖"}),"和",(0,r.jsx)(e.strong,{children:"节流"}),"来处理这件事，接下来用防抖处理一下。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const SetSearchQueryDebounce = useMemo(()=> debounce((value)=> setSearchQuery(value),1000)  ,[])\nconst handleChange = (e) => {\n    setInputValue(e.target.value)\n    /* 通过防抖处理后的 setSearchQuery 函数。  */\n    SetSearchQueryDebounce(e.target.value)\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"如上将 setSearchQuery 防抖处理。然后我们看一下效果。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:u,alt:"5.gif"})}),"\n",(0,r.jsxs)(e.p,{children:["通过上面可以直观感受到通过防抖处理后，基本上已经不影响 input 输入了。但是面临一个问题就是 list 视图改变的延时时间变长了。那么 transition 和",(0,r.jsx)(e.strong,{children:"节流防抖"})," 本质上的区别是："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"一方面，节流防抖 本质上也是 setTimeout ，只不过控制了执行的频率，那么通过打印的内容就能发现，原理就是让 render 次数减少了。而 transitions 和它相比，并没有减少渲染的次数。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["另一方面，节流和防抖需要有效掌握 ",(0,r.jsx)(e.code,{children:"Delay Time"})," 延时时间，如果时间过长，那么给人一种渲染滞后的感觉，如果时间过短，那么就类似于 setTimeout(fn,0) 还会造成前面的问题。而 startTransition 就不需要考虑这么多。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"5-受到计算机性能影响",children:["5 受到计算机性能影响",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5-受到计算机性能影响",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["transition 在处理慢的计算机上效果更加明显，我们来看一下 ",(0,r.jsx)(e.a,{href:"https://github.com/reactwg/react-18/discussions/65",target:"_blank",rel:"noopener noreferrer",children:"Real world example"})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"注意看滑块速度"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"处理性能高，更快速的设备上。不使用 startTransition 。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:j,alt:"12.gif"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"处理性能高，更快速的设备上。使用 startTransition。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:x,alt:"13.gif"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"处理性能差，慢速的设备上，不使用 startTransition。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:"14.gif"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"处理性能差，慢速的设备上，使用 startTransition。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:"15.gif"})}),"\n",(0,r.jsxs)(e.h2,{id:"三-transition-特性",children:["三 transition 特性",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#三-transition-特性",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"既然已经讲了 transition 的产生初衷，接下来看 transition 的功能介绍 。"}),"\n",(0,r.jsxs)(e.h3,{id:"1-什么是过渡任务",children:["1 什么是过渡任务。",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-什么是过渡任务",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"一般会把状态更新分为两类："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"第一类紧急更新任务。比如一些用户交互行为，按键，点击，输入等。"}),"\n",(0,r.jsx)(e.li,{children:"第二类就是过渡更新任务。比如 UI 从一个视图过渡到另外一个视图。"}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"2-什么是-starttransition",children:["2 什么是 startTransition",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-什么是-starttransition",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["上边已经用了 ",(0,r.jsx)(e.code,{children:"startTransition"})," 开启过度任务，对于 startTransition 的用法，相信很多同学已经清楚了。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"startTransition(scope)\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["scope 是一个回调函数，里面的更新任务都会被标记成",(0,r.jsx)(e.strong,{children:"过渡更新任务"}),"，过渡更新任务在渲染并发场景下，会被降级更新优先级，中断更新。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"使用"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"startTransition(()=>{\n   /* 更新任务 */\n   setSearchQuery(value)\n})\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"3-什么是-usetranstion",children:["3 什么是 useTranstion",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-什么是-usetranstion",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["上面介绍了 startTransition ，又讲到了过渡任务，本质上过渡任务有一个过渡期，在这个期间当前任务本质上是被中断的，那么在过渡期间，应该如何处理呢，或者说告诉用户什么时候过渡任务处于 ",(0,r.jsx)(e.code,{children:"pending"})," 状态，什么时候 ",(0,r.jsx)(e.code,{children:"pending"})," 状态完毕。"]}),"\n",(0,r.jsx)(e.p,{children:"为了解决这个问题，React 提供了一个带有 isPending 状态的 hooks —— useTransition 。useTransition 执行返回一个数组。数组有两个状态值："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"第一个是，当处于过渡状态的标志——isPending。"}),"\n",(0,r.jsx)(e.li,{children:"第二个是一个方法，可以理解为上述的 startTransition。可以把里面的更新任务变成过渡任务。"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"import { useTransition } from 'react' \n\n/* 使用 */\nconst  [ isPending , startTransition ] = useTransition ()\n"})}),"\n",(0,r.jsxs)(e.p,{children:["那么当任务处于悬停状态的时候，",(0,r.jsx)(e.code,{children:"isPending"})," 为 ",(0,r.jsx)(e.code,{children:"true"}),"，可以作为用户等待的 UI 呈现。比如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"{ isPending  &&  < Spinner  / > }\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"usetranstion-实践",children:["useTranstion 实践",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usetranstion-实践",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"接下来我们做一个 useTranstion 的实践，还是复用上述 demo 。对上述 demo 改造。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"export default function App(){\n    const [ value ,setInputValue ] = React.useState('')\n    const [ query ,setSearchQuery  ] = React.useState('')\n    const [ isPending , startTransition ] = React.useTransition()\n    const handleChange = (e) => {\n        setInputValue(e.target.value)\n        startTransition(()=>{\n            setSearchQuery(e.target.value)\n        })\n    }\n    return  <div>\n    {isPending && <span>isTransiton</span>}\n    <input onChange={handleChange}\n        placeholder=\"输入搜索内容\"\n        value={value}\n    />\n   <NewList  query={query} />\n</div>\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["如上用 ",(0,r.jsx)(e.code,{children:"useTransition"})," ， ",(0,r.jsx)(e.code,{children:"isPending"})," 代表过渡状态，当处于过渡状态时候，显示 ",(0,r.jsx)(e.code,{children:"isTransiton"})," 提示。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"接下来看一下效果："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:"6.gif"})}),"\n",(0,r.jsx)(e.p,{children:"可以看到能够准确捕获到过渡期间的状态。"}),"\n",(0,r.jsxs)(e.h3,{id:"4-什么是-usedeferredvalue",children:["4 什么是 useDeferredValue",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-什么是-usedeferredvalue",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["如上场景我们发现，本质上 query 也是 value ，不过 query 的更新要滞后于 value 的更新。那么 React 18 提供了 ",(0,r.jsx)(e.code,{children:"useDeferredValue"})," 可以让状态滞后派生。useDeferredValue 的实现效果也类似于 ",(0,r.jsx)(e.code,{children:"transtion"}),"，当迫切的任务执行后，再得到新的状态，而这个新的状态就称之为 DeferredValue 。"]}),"\n",(0,r.jsx)(e.p,{children:"useDeferredValue 和上述 useTransition 本质上有什么异同呢？"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"相同点："})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"useDeferredValue 本质上和内部实现与 useTransition  一样都是标记成了过渡更新任务。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"不同点："})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.strong,{children:["useTransition 是把 startTransition 内部的更新任务变成了过渡任务",(0,r.jsx)(e.code,{children:"transtion"}),",而 useDeferredValue 是把原值通过过渡任务得到新的值，这个值作为延时状态。"]})," 一个是处理一段逻辑，另一个是生产一个新的状态。"]}),"\n",(0,r.jsxs)(e.li,{children:["useDeferredValue 还有一个不同点就是这个任务，本质上在 useEffect 内部执行，而 useEffect 内部逻辑是异步执行的 ，所以它一定程度上更滞后于 ",(0,r.jsx)(e.code,{children:"useTransition"}),"。 ",(0,r.jsxs)(e.strong,{children:[(0,r.jsx)(e.code,{children:"useDeferredValue"})," = ",(0,r.jsx)(e.code,{children:"useEffect"})," + ",(0,r.jsx)(e.code,{children:"transtion"})]})]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"那么回到 demo 上来，似乎 query 变成 DeferredValue 更适合现实情况，那么对 demo 进行修改。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"export default function App(){\n    const [ value ,setInputValue ] = React.useState('')\n    const query = React.useDeferredValue(value)\n    const handleChange = (e) => {\n        setInputValue(e.target.value)\n    }\n    return  <div>\n     <button>useDeferredValue</button>\n    <input onChange={handleChange}\n        placeholder=\"输入搜索内容\"\n        value={value}\n    />\n   <NewList  query={query} />\n   </div>\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"如上可以看到 query 是 value 通过 useDeferredValue 产生的。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"效果："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:"7.gif"})}),"\n",(0,r.jsxs)(e.h2,{id:"四-原理",children:["四 原理",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#四-原理",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"接下来又到了原理环节，从 startTransition 到 useTranstion 再到 useDeferredValue 原理本质上很简单，"}),"\n",(0,r.jsxs)(e.h3,{id:"1-starttransition",children:["1 startTransition",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-starttransition",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"首先看一下最基础的 startTransition 是如何实现的。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"react/src/ReactStartTransition.js -> startTransition"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"export function startTransition(scope) {\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  /* 通过设置状态 */\n  ReactCurrentBatchConfig.transition = 1;\n  try {  \n      /* 执行更新 */\n    scope();\n  } finally {\n    /* 恢复状态 */  \n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"startTransition"})," 原理特别简单，有点像 React v17 中 batchUpdate 的批量处理逻辑。就是通过设置开关的方式，而开关就是 ",(0,r.jsx)(e.code,{children:"transition = 1"})," ，然后执行更新，里面的更新任务都会获得 ",(0,r.jsx)(e.code,{children:"transtion"})," 标志。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["接下来在 concurrent mode 模式下会单独处理 ",(0,r.jsx)(e.code,{children:"transtion"})," 类型的更新。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"其原理图如下所示。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:"9.jpg"})}),"\n",(0,r.jsxs)(e.h3,{id:"2-usetranstion",children:["2 useTranstion",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-usetranstion",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["接下来看一下 ",(0,r.jsx)(e.code,{children:"useTranstion"})," 的内部实现。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"react-reconciler/src/ReactFiberHooks.new.js -> useTranstion"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function mountTransition(){\n    const [isPending, setPending] = mountState(false);\n    const start = (callback)=>{\n        setPending(true);\n        const prevTransition = ReactCurrentBatchConfig.transition;\n        ReactCurrentBatchConfig.transition = 1;\n        try {\n            setPending(false);\n            callback();\n        } finally {\n            ReactCurrentBatchConfig.transition = prevTransition;\n        }\n    }\n     return [isPending, start];\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这段代码不是源码，我把源码里面的内容进行组合，压缩。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["从上面可以看到，useTranstion 本质上就是 ",(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"useState"})})," +  ",(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"startTransition"})})," 。"]}),"\n",(0,r.jsxs)(e.li,{children:["通过 useState 来改变 pending 状态。在 mountTransition 执行过程中，会触发两次 ",(0,r.jsx)(e.code,{children:"setPending"})," ，一次在 ",(0,r.jsx)(e.code,{children:"transition = 1"})," 之前，一次在之后。一次会正常更新 ",(0,r.jsx)(e.code,{children:"setPending(true)"})," ，一次会作为 ",(0,r.jsx)(e.code,{children:"transition"})," 过渡任务更新 ",(0,r.jsx)(e.code,{children:"setPending(false);"})," ，所以能够精准捕获到过渡时间。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"其原理图如下所示。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:"10.jpg"})}),"\n",(0,r.jsxs)(e.h3,{id:"3-usedeferredvalue",children:["3 useDeferredValue",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-usedeferredvalue",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["最后，让我们看一下 ",(0,r.jsx)(e.code,{children:"useDeferredValue"})," 的内部实现原理。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"react-reconciler/src/ReactFiberHooks.new.js -> useTranstion"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"function updateDeferredValue(value){\n  const [prevValue, setValue] = updateState(value);\n  updateEffect(() => {\n    const prevTransition = ReactCurrentBatchConfig.transition;\n    ReactCurrentBatchConfig.transition = 1;\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"useDeferredValue 处理流程是这样的。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["从上面可以看到 useDeferredValue 本质上是 ",(0,r.jsx)(e.code,{children:"useDeferredValue"})," = ",(0,r.jsx)(e.code,{children:"useState"})," + ",(0,r.jsx)(e.code,{children:"useEffect"})," + ",(0,r.jsx)(e.code,{children:"transition"})]}),"\n",(0,r.jsx)(e.li,{children:"通过传入 useDeferredValue 的 value 值，useDeferredValue 通过 useState 保存状态。"}),"\n",(0,r.jsxs)(e.li,{children:["然后在 useEffect 中通过 ",(0,r.jsx)(e.code,{children:"transition"})," 模式来更新 value 。 这样保证了 DeferredValue 滞后于 state 的更新，并且满足 ",(0,r.jsx)(e.code,{children:"transition"}),"  过渡更新原则。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"其原理图如下所示。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:t,alt:"11.jpg"})}),"\n",(0,r.jsxs)(e.h2,{id:"四-总结",children:["四 总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#四-总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本章节讲到的知识点如下："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"Transition"})," 产生初衷，解决了什么问题。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"startTransition"})," 的用法和原理。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"useTranstion"})," 的用法和原理。"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"useDeferredValue"})," 的用法和原理。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"参考文档",children:["参考文档",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参考文档",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://github.com/reactwg/react-18/discussions/41",target:"_blank",rel:"noopener noreferrer",children:"New feature: startTransition"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://github.com/reactwg/react-18/discussions/65",target:"_blank",rel:"noopener noreferrer",children:"Real world example: adding startTransition for slow renders"})}),"\n"]}),"\n"]})]})}function b(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(T,{...n})}):T(n)}let v=b;b.__RSPRESS_PAGE_META={},b.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F34.V18%E7%89%B9%E6%80%A7%E7%AF%87-transition.md"]={toc:[{text:"二 transition 使命",id:"二-transition-使命",depth:2},{text:"1 transition 的诞生",id:"1-transition-的诞生",depth:3},{text:"2 模拟场景",id:"2-模拟场景",depth:3},{text:"3 为什么不是 setTimeout",id:"3-为什么不是-settimeout",depth:3},{text:"4 为什么不是节流防抖",id:"4-为什么不是节流防抖",depth:3},{text:"5 受到计算机性能影响",id:"5-受到计算机性能影响",depth:3},{text:"三 transition 特性",id:"三-transition-特性",depth:2},{text:"1 什么是过渡任务。",id:"1-什么是过渡任务",depth:3},{text:"2 什么是 startTransition",id:"2-什么是-starttransition",depth:3},{text:"3 什么是 useTranstion",id:"3-什么是-usetranstion",depth:3},{text:"useTranstion 实践",id:"usetranstion-实践",depth:4},{text:"4 什么是 useDeferredValue",id:"4-什么是-usedeferredvalue",depth:3},{text:"四 原理",id:"四-原理",depth:2},{text:"1 startTransition",id:"1-starttransition",depth:3},{text:"2 useTranstion",id:"2-usetranstion",depth:3},{text:"3 useDeferredValue",id:"3-usedeferredvalue",depth:3},{text:"四 总结",id:"四-总结",depth:2},{text:"参考文档",id:"参考文档",depth:3}],title:"34.V18特性篇-transition",headingTitle:"34.V18特性篇-transition",frontmatter:{}}}}]);