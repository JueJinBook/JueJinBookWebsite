"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["46041"],{794207:function(n,e,i){i.r(e),i.d(e,{default:()=>o});var r=i(552676),d=i(740453);let s=i.p+"static/image/86df7ea84265d8d5711f6504d869ab73.c3f511bc.webp",c=i.p+"static/image/05f90dc118889e9c22d8e35febff67a6.07bf54e4.webp",l=i.p+"static/image/0fac2bd16c3df6f969e3c2b27ada4b17.d24ce587.webp",a=i.p+"static/image/f05fca8522fd2d39dfc9f22dae89fdbc.4bd60bfb.webp";function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ul:"ul",li:"li",img:"img",h3:"h3",blockquote:"blockquote",h4:"h4",pre:"pre",h5:"h5"},(0,d.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"11中级进阶-----冯氏光照模型为物体增加漫反射效果",children:["11.中级进阶 --- 冯氏光照模型：为物体增加漫反射效果",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11中级进阶-----冯氏光照模型为物体增加漫反射效果",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们已经学会了给物体增加环境光，但现实世界中一个物体展示出来的颜色除了受环境光的影响，还要看该物体是否被光源直接照射，以及物体本身的材质。如果物体被光源直接照射，它会比没有光源直接照射的物体更亮一些。物体本身如果是光滑的，那么在被光源照射时会显得更加亮，甚至刺眼，比如一面镜子，不锈钢等。假设物体粗糙不平，那么它给人的感觉就平和一些。"}),"\n",(0,r.jsx)(e.p,{children:"除了物体本身的因素会对最终进入人眼的颜色产生影响，人眼、物体、光源之间的位置也会决定进入人眼的颜色。一个很常见的例子就是光线照射在镜面时，当反射出来的光线没有进入人眼的时候，人眼看到的镜子是正常的。当我们移动自身位置，正好能够让镜子的反射光线进入人眼，此时看到的镜面就会很刺眼。"}),"\n",(0,r.jsxs)(e.p,{children:["现实生活中的光照效果如此复杂，而且受到很多因素的影响，即使在计算机硬件飞速发展的今天，也依然会消耗很大的算力，无法精确模拟这种效果，所以需要一种能够近似现实光照效果的简化模型。业界比较著名的是",(0,r.jsx)(e.code,{children:"冯氏光照模型"}),"（Phong Lighting Model）。"]}),"\n",(0,r.jsxs)(e.h2,{id:"冯氏光照模型",children:["冯氏光照模型",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#冯氏光照模型",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"冯氏光照模型模拟现实生活中的三种情况，分别是环境光(Ambient)、漫反射(Diffuse)和镜面高光(Specular)。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["环境光：环境光在上节已经讲过了，主要用来模拟晚上或者阴天时，在没有光源直接照射的情况下，我们仍然能够看到物体，只是偏暗一些，通常情况我们使用一个",(0,r.jsx)(e.code,{children:"较小的光线因子乘以光源颜色"}),"来模拟。"]}),"\n",(0,r.jsxs)(e.li,{children:["漫反射：漫反射是为了模拟",(0,r.jsx)(e.code,{children:"平行光源"}),"对物体的方向性影响，我们都知道，如果光源正对着物体，那么物体正对着光源的部分会更明亮，反之，背对光源的部分会暗一些。在冯氏光照模型中，漫反射分量占主要比重。"]}),"\n",(0,r.jsxs)(e.li,{children:["镜面高光：为了模拟光线照射在",(0,r.jsx)(e.code,{children:"比较光滑"}),"的物体时，物体正对光源的部分会产生",(0,r.jsx)(e.code,{children:"高亮效果"}),"。该分量颜色会和光源颜色更接近。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"有了冯氏光照模型，我们就可以通过这三个分量模拟出相对真实的光照效果了。"}),"\n",(0,r.jsx)(e.p,{children:"环境光分量我们上节已经讲过了，本节将跳过，不再赘述，本节主要讲解漫反射分量。"}),"\n",(0,r.jsxs)(e.h2,{id:"计算漫反射光照",children:["计算漫反射光照",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#计算漫反射光照",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们知道，当一束光线照射到物体表面时，光线的入射角越小，该表面的亮度就越大，看上去也就越亮。反之，该表面的亮度就越小，看上去越暗。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"这种现象我们该如何在计算机中表示呢？"}),"\n",(0,r.jsxs)(e.p,{children:["关键在于",(0,r.jsx)(e.code,{children:"入射角的表示"}),"与",(0,r.jsx)(e.code,{children:"光线强度的计算"}),"。"]}),"\n",(0,r.jsxs)(e.h3,{id:"入射角的表示与计算",children:["入射角的表示与计算",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#入射角的表示与计算",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们需要定义一个类似",(0,r.jsx)(e.code,{children:"法线"}),"的概念，即",(0,r.jsx)(e.code,{children:"法向量"}),"，法向量垂直于物体表面，并且朝向平面外部，如下图："]}),"\n",(0,r.jsx)(e.p,{children:"有了法向量，我们还需要光线照射方向，光线照射方向根据光源的不同有两种表示方法："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["平行光线","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"光线方向是全局一致的，与照射点的位置无关，不会随着照射点的不同而不同，不是很真实。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["点光源。","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"向四周发射光线，光线方向与照射点的位置有关，越靠近光源的部分越亮，光照效果比较真实。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"接下来我们用这二种方式来演示。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"有了法向量以及光线照射方向，我们也就知道了入射角，有了入射角，那么反射光强度的计算就轻而易举了。"}),"\n",(0,r.jsxs)(e.h4,{id:"计算反射光强度",children:["计算反射光强度",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#计算反射光强度",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["因为入射角的大小与反射光的亮度成",(0,r.jsx)(e.code,{children:"反比"}),"，所以我们使用",(0,r.jsx)(e.code,{children:"入射角的余弦值"}),"来表示漫反射的",(0,r.jsx)(e.code,{children:"光线强"}),"度。"]}),"\n",(0,r.jsxs)(e.h4,{id:"法向量",children:["法向量",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#法向量",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"法向量是垂直于顶点所在平面，指向平面外部的向量，只有方向，没有大小，类比光学现象中的法线，如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"法向量存储在顶点属性中，为了便于计算入射角的余弦值，法向量的长度通常设置为 1。"}),"\n",(0,r.jsxs)(e.p,{children:["除了",(0,r.jsx)(e.code,{children:"法向量"}),"，我们还需要知道",(0,r.jsx)(e.code,{children:"光线的入射角"}),"，即光源的照射方向向量和法向量的夹角，上图中 $\\theta$ 即是入射角。"]}),"\n",(0,r.jsxs)(e.h4,{id:"光源照射方向向量的计算",children:["光源照射方向向量的计算",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#光源照射方向向量的计算",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"光源位置坐标是基于世界坐标系的，所以我们在计算光源入射方向向量的时候，需要将照射点的坐标也转换到世界坐标系中。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"在世界坐标系中，假设有一光源 p0 (x0, y0, z0)。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"vec3 p0 = vec3(10, 10, 10);\n"})}),"\n",(0,r.jsx)(e.p,{children:"光线照射到物体表面上的一点 p1 (x1, y1, z1)。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"vec3 p1 = vec3(20, 25, 30);\n"})}),"\n",(0,r.jsx)(e.p,{children:"那么光线照射在该点的方向向量为："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"vec3 light_Direction = p1 - p0。\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["GLSL中的 ",(0,r.jsx)(e.code,{children:"+"}),"、",(0,r.jsx)(e.code,{children:"-"}),"、",(0,r.jsx)(e.code,{children:"*"}),"、",(0,r.jsx)(e.code,{children:"/"})," 操作符的左右两个数如果是向量的话，得出的新向量的各个分量等于原有向量逐分量的相减结果。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"这样我们就得出了光源的照射方向向量。"}),"\n",(0,r.jsxs)(e.h4,{id:"计算漫反射光照-1",children:["计算漫反射光照",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#计算漫反射光照-1",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"有了入射角，我们的漫反射光照分量就可以求出来了。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"漫反射光照 = 光源颜色 * 漫反射光照强度因子"}),"\n",(0,r.jsx)(e.li,{children:"漫反射光照强度因子 = 入射角的余弦值"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["通常我们如果要求入射角的余弦值，需要首先知道入射角，然后再求入射角的余弦值。不过由于我们使用的是向量，根据向量的运算规则，我们可以使用向量之间的",(0,r.jsx)(e.code,{children:"点积"}),"，再除以向量的长度之积，就可以得出余弦值。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们首先将两个向量",(0,r.jsx)(e.code,{children:"归一化"}),"，转换成单位向量，然后进行点积计算求出夹角余弦。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"归一化向量的实质是将向量的长度转换成 1，得出的一个单位向量。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"所以我们需要两个数学方法来操作他们"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["dot","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"求出两个向量的点积。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["normalize","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"将向量转化为长度为 1 的向量。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"所幸的是，GLSL 内置了这两个函数方便我们计算，一些有名的 3D 框架中也包含这两个方法。"}),"\n",(0,r.jsx)(e.p,{children:"所以，我们的入射角余弦值就可以这样求出了："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"//light_Direction表示光源照射方向向量。\n//normal 代表当前入射点的法向量\nvec3 light_Color = vec3(1, 1, 1);\nfloat diffuseFactor = dot(normalize(light_Direction), normalize(normal))\nvec4 lightColor = vec4(light_Color * diffuseFactor, 1);\n"})}),"\n",(0,r.jsx)(e.p,{children:"这样我们就求出了漫反射光照的分量，接下来我们实际操作一下，比较一下物体在加入光照前后的效果。"}),"\n",(0,r.jsxs)(e.h4,{id:"平行光漫反射",children:["平行光漫反射",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#平行光漫反射",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"前面讲了那么多理论，是时候上手实践一下了。我们按照 WebGL 的编码流程，看看各个阶段需要做何处理。"}),"\n",(0,r.jsxs)(e.h5,{id:"顶点着色器",children:["顶点着色器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#顶点着色器",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["顶点着色器需要接收顶点法向量，",(0,r.jsx)(e.code,{children:"插值化"}),"后传递给片元着色器，所以我们需要定义一个",(0,r.jsx)(e.code,{children:"varying"}),"类型的 3 维向量来表示法向量，完整的顶点着色器如下："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"// 顶点坐标\nattribute vec4 a_Position;\n// 顶点颜色\nattribute vec4 a_Color;\n// 顶点法向量\nattribute vec3 a_Normal;\n// 传递给片元着色器的法向量\nvarying vec3 v_Normal;\n// 传递给片元着色器的颜色\nvarying vec4 v_Color;\n// 模型视图投影变换矩阵。\nuniform mat4 u_Matrix;\n\nvoid main(){\n	// 将顶点坐标转化成裁剪坐标系下的坐标。\n	gl_Position = u_Matrix * vec4(a_Position, 1);\n	// 将顶点颜色传递给片元着色器\n	v_Color = a_Color;\n	// 将顶点法向量传递给片元着色器\n	v_Normal = a_Normal;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["细心的读者已经看到了，着色器中我们使用了 GLSL 中的矩阵容器类型 ",(0,r.jsx)(e.code,{children:"mat4"}),"，4 * 4 矩阵，用来表示模型视图投影变换。我们将 4 阶矩阵左乘 4 维向量，即可表示对 4 维向量所表示的点执行 4 阶矩阵所表示的变换。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"关于矩阵和向量的运算意义，我会在之后的章节讲解。这里大家只要了解了矩阵左乘向量的意义，并且学会使用就可以了。"}),"\n"]}),"\n",(0,r.jsxs)(e.h5,{id:"片元着色器",children:["片元着色器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#片元着色器",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["漫反射光照分量在片元着色器中计算，按照上面的计算公式，我们需要接收顶点着色器传递过来的插值后的法向量",(0,r.jsx)(e.code,{children:"v_Normal"}),"和全局光源位置 ",(0,r.jsx)(e.code,{children:"u_LightPosition"}),"，以及光线的颜色",(0,r.jsx)(e.code,{children:"u_LightColor"}),"。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"// 片元法向量\nvarying vec3 v_Normal;\n// 片元颜色\nvarying vec4 v_Color;\n// 光线颜色\nuniform vec3 u_LightColor;\n// 光源位置\nuniform vec3 u_LightPosition;\nvoid main(){\n      // 环境光分量\n      vec3 ambient = u_AmbientFactor * u_LightColor; \n      // 光源照射方向向量\n      vec3 lightDirection = u_LightPosition - vec3(0, 0, 0);\n      // 漫反射因子\n      float diffuseFactor = dot(normalize(lightDirection), normalize(v_Normal));\n      // 如果是负数，说明光线与法向量夹角大于 90 度，此时照不到平面上，所以没有光照，即黑色。\n      diffuseFactor = max(diffuseFactor, 0.0);\n      // 漫反射光照 = 光源颜色 * 漫反射因子。\n      vec3 diffuseLightColor = u_LightColor * diffuseFactor;\n      // 物体在光照下的颜色 = （环境光照 + 漫反射光照） * 物体颜色。\n      gl_FragColor = v_Color * vec4((ambient + diffuseLightColor),1); 	\n}\n"})}),"\n",(0,r.jsxs)(e.h5,{id:"javascript部分",children:["JavaScript部分",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript部分",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["着色器的程序完成了，接下来我们需要给着色器传递数据了。和之前的例子相比，我们多了两个全局变量",(0,r.jsx)(e.code,{children:"光照颜色"}),"、",(0,r.jsx)(e.code,{children:"光照位置"}),"，以及一个顶点属性",(0,r.jsx)(e.code,{children:"法向量"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"首先我们给顶点增加法向量："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"var normalInput = [\n    [0, 0, 1],  //前平面\n    [0, 0, -1], //后平面\n    [-1, 0, 0], //左平面\n    [1, 0, 0], //右平面\n    [0, 1, 0], //上平面\n    [0, -1, 0] //下平面\n];\n"})}),"\n",(0,r.jsxs)(e.p,{children:["各个平面的法向量准备好后，我们就可以为组成平面的顶点设置法向量属性了，限于篇幅，此处不再展示源码，大家可以在此处查看完整源代码 ",(0,r.jsx)(e.a,{href:"/",children:"光照演示源码"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"接下来，创建立方体的顶点数据："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"var cube = createCube(10, 10, 10);\n"})}),"\n",(0,r.jsx)(e.p,{children:"此处创建一个长、宽、高各位 10 的立方体，坐标原点在立方体中心。"}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们设置光源位置，我们希望将光源放在立方体前面 z 轴坐标正方向 10 的位置。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"gl.uniform3f(u_LightPosition, 0, 0, 10);\n"})}),"\n",(0,r.jsx)(e.p,{children:"设置光源颜色为白色："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"gl.uniform3f(u_LightColor, 1, 1, 1);\n"})}),"\n",(0,r.jsx)(e.p,{children:"按照这种放置，光源在立方体的正前方，它始终照亮前面。我们看下演示效果："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,UklGRm4CAABXRUJQVlA4IGICAABQIgCdASpoAfAAPp1Oo0ylpKMiIr3JQLATiWdu4XExBDPXDHCHRVSopDd4Nu8G3eDbtCz+A1/p77CxsMCdGBOiRj65J02ShpqXa8UaFMIvBHSyGhsJGPrknTa9M6pG0NlIUWIiK899hLQhEWNfZZOIEG8yBSCPeCIsRJ5EBfJEwO8EdVC7RUTR0XqDQIOnECnlMsLnFjMfJm2xPIgL5ImB3gdLUw8R+5owyRAZp5GR87/nM68RMbtIWAk4gQbzIFIClBvVQnY72+W+I94ONdJrYdoXaM93EfEe8HGuk1sO8qdGWxoI3mwivPfYR4VXE5plCO8qcxrlyakPEFEMwcLepU+5ow2EC/xZEMJIIx9ck6cUiBOjGNu7kzgAAP7+nRF3//x3D/9vnBDM/fp/5IJ/+0kWm1gxiQWqB49o38m49N5RK/V0fBg4jTs97gwht9mfaFRp87yQpB1Yd/NYAAmEMAbcQwE+AIRQJkYBuRHH8SUAU0xsO46+g2ZwlqgsUm7T0c3EkJqo1z41uRa9vnqL6SHiNirLfZCsc3jKpv/t8ffpwO1tFRjdf//nv/B7/+/+P+//UZ2k19qN/Nv+MC3Zr/d4RocxYvcW1bazxOw62rmc/8T7Zt0vMbrXuRqYafc66QiabBVj/TOvIJsfMBdliYkWTR8KO32vsaEPg3mblQpBr20tlfqm4J5L4N3lMoN2MXKdYNTO43EvNZBcQVoDFw2a5cuXsok/wPGc1WrsfgDqPgBAxC1CothyrOHnmO85wM5kDFoeu95ukR9Tv2NUA4S9RJIqXoX2n5/i91iAAAAA",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"可以看到我们设置的白色光源把立方体的前平面（红色面）照亮了。"}),"\n",(0,r.jsx)(e.p,{children:"等等，好像有些不对劲。"}),"\n",(0,r.jsx)(e.p,{children:"一个很大的问题是：立方体在转动时，转动到正对光源方向的平面并没有被照亮。"}),"\n",(0,r.jsx)(e.p,{children:"大家考虑下为什么？"}),"\n",(0,r.jsxs)(e.h4,{id:"动态计算法向量",children:["动态计算法向量",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#动态计算法向量",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"其实是因为在转动的时候，各个顶点的法向量还是初始值，并没有随着物体的转动而更新，所以即使有平面转动到正对光源的位置，它的法向量还是原先的法向量，计算出来的漫反射光照仍然是 0。所以，我们需要在物体发生变换的时候，让法向量也跟着发生变换。"}),"\n",(0,r.jsxs)(e.p,{children:["我们来修正这个问题，解决办法很简单，只要将立方体的",(0,r.jsx)(e.code,{children:"模型变换矩阵"}),"传递给",(0,r.jsx)(e.code,{children:"顶点着色器"}),"，然后与",(0,r.jsx)(e.code,{children:"顶点的法向量"}),"相乘，即可得到变换后的法向量。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"此处又提到了矩阵，可见矩阵的重要性非同一般，在后面的矩阵章节大家一定要认真学习。"}),"\n"]}),"\n",(0,r.jsxs)(e.h5,{id:"顶点着色器-1",children:["顶点着色器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#顶点着色器-1",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"顶点着色器需要做些改动，用来接收模型矩阵，然后将模型矩阵与法向量相乘，得到变换后的法向量，传递给片元着色器。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"// 顶点坐标\nattribute vec4 a_Position;\n// 顶点颜色\nattribute vec4 a_Color;\n// 顶点法向量\nattribute vec3 a_Normal;\n// 传递给片元着色器的法向量\nvarying vec3 v_Normal;\n// 传递给片元着色器的颜色\nvarying vec4 v_Color;\n// 模型视图投影变换矩阵。\nuniform mat4 u_Matrix;\n// 模型变换矩阵。\nuniform mat4 u_ModelMatrix;\n\nvoid main(){\n	gl_Position = u_Matrix * vec4(a_Position, 1);\n	v_Color = a_Color;\n	v_Normal = mat3(u_ModelMatrix) * a_Normal;\n}\n"})}),"\n",(0,r.jsxs)(e.h5,{id:"片元着色器不需要修改",children:["片元着色器不需要修改。",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#片元着色器不需要修改",children:"#"})]}),"\n",(0,r.jsxs)(e.h5,{id:"javascript部分-1",children:["JavaScript部分",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript部分-1",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["JavaScript 部分需要为顶点着色器传入模型矩阵",(0,r.jsx)(e.code,{children:"u_ModelMatrix"}),"的值，那么，模型矩阵如何计算呢？还好矩阵库为我们解决了这个问题。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"var modelMatirx = matrix.identity();\nmodelMatrix = matrix.rotateX(modelMatrix, Math.PI / 180 * (uniforms['xRotation']));\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这里利用了矩阵库的两个方法",(0,r.jsx)(e.code,{children:"identity"})," 和 ",(0,r.jsx)(e.code,{children:"rotateX"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"identity 用来初始化一个 4 维矩阵，对角线分量均为1。"}),"\n",(0,r.jsx)(e.li,{children:"rotateX 将原来的矩阵沿着 X 轴旋转，得到一个新的矩阵。"}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"关于矩阵的变换细节在后面章节有详细介绍，此处只讲如何使用。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"改造完成，我们看下效果："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,UklGRqoCAABXRUJQVlA4IJ4CAAAQIwCdASpoAfAAPp1Oo02lpCOiICj4sBOJZ27hc/ERnN/ndAtTRfKbOAzgHnC9EB1AH8r6MX2hiIbBj7hXsqygZPvZkjnUNTvqg3apW+PK81aeV5q08rzVOoePxnk/olNrVjM429m6HT6iaOMeIhcNkexQEgto4x4jRxWa/XmhueaHqJo4x4S5YO5GubWrGYb38ZWFQcaABNfCOMeI0cYrCdjWGtqF8GaeV5q08ppCwDVCdi9xwAeWnleaqFS566Qa2H5Ibp5El3z+lb48rzQ3DXRUeRGjyvNWnldAMImijS68tPK81abuuLqT13z+lb48rzQTxBHziiWT+iU2tVnCUsUH8ox4jRxjxGjjHiNHGPAo6xFBvg2UDJ97Mkc6hqZQAP78EnPxVAAAE2nWV2QpXN9FNNeXV+50neSaHOfmIbwfN14iWfpYTyceiomoQ3g45CzYfpRXnMLJRfyuMxyxzTvRlmPlKntFDzDU0DDtpGy55oIu7Ex7f2xyI9+nfridkd+hrTpk1S7Hs7Jgx+YJZAoBuG5MQADdxzgASvgATEt8sZG3tWWWPGf8/ppANUOeWTWDRpyd+90sYdVpBXKBOGWqlLzPyaYC68HK8oF6IXg+9t4Sq4mAJIe5o0kTXnR36ZP/vOjanoXR+R1cQlhsh+Q3V0Mlv16VijY1vC4RLE/G3TkWCmMgdbdoT5a130nV3NYfqwW1Ej4EnycIwOgGGdN/ACl11BI+wHCmcO3bMPyHAGAp2muNJuj+nx7SP7Lq1FJ9ZPvQIsXB4+LUM+8eqOha2TBfgA0SJWVywLfUmbAIgJBdSrxO+cmkfeWJEd5g/5V/651imTf+enWvrGcGhB0WJhSuokTBKqUs1YVOH7HQtCYAACr/6+wAAAAA",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"可以看到，立方体正对光源的平面都能够被照亮了。"}),"\n",(0,r.jsxs)(e.h4,{id:"点光源的漫反射",children:["点光源的漫反射",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#点光源的漫反射",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"前面的平行光漫反射可以模拟遥远的光源，比如太阳光，由于太阳距离地球过于遥远，所以光线照射在物体各个点的方向还是可以近似平行的。"}),"\n",(0,r.jsx)(e.p,{children:"但现实生活中还有很多人造光源，这些光源距离物体比较近，照在物体不同点时，入射角也会不一样，所以光照强度也有差别，在一个平面上产生距离光源近的部分比较亮，距离光源远的部分比较暗的效果。"}),"\n",(0,r.jsx)(e.p,{children:"接下来我们模拟这种情况。"}),"\n",(0,r.jsxs)(e.p,{children:["我们在之前平行光漫反射的基础上进行改造，大家可以看到，之前的平行光漫反射计算入射角余弦时，是根据",(0,r.jsx)(e.code,{children:"光源位置"}),"和世界坐标系的",(0,r.jsx)(e.code,{children:"原点"}),"计算的入射角，只要我们不改变光源位置，那么光线方向就始终一致。"]}),"\n",(0,r.jsx)(e.p,{children:"但是，点光源需要根据光源位置和入射点位置计算入射角，所以我们需要计算出入射点的世界坐标系坐标。"}),"\n",(0,r.jsx)(e.p,{children:"入射点的世界坐标系坐标的求法也比较简单，只需要左乘模型矩阵就可以了。"}),"\n",(0,r.jsx)(e.p,{children:"我们对上面的例子加以升级。"}),"\n",(0,r.jsxs)(e.h5,{id:"顶点着色器-2",children:["顶点着色器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#顶点着色器-2",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"顶点着色器需要定义一个入射点位置，插值化后传给片元着色器计算入射角的余弦。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"...略\nvarying vec3 v_Position;\nvoid main(){\n	...略\n	v_Position = vec3(u_ModelMatrix * vec4(a_Position, 1));\n}\n\n"})}),"\n",(0,r.jsxs)(e.h5,{id:"片元着色器-1",children:["片元着色器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#片元着色器-1",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"片元着色器部分的改变只有在计算光源入射方向时，用光源位置减去入射点位置："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"...略\n// 光源照射方向向量\nvec3 lightDirection = u_LightPosition - v_Position;\n...略\n"})}),"\n",(0,r.jsx)(e.p,{children:"JavaScript部分不需要改动，我们看下演示效果："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,UklGRjADAABXRUJQVlA4ICQDAACwJACdASpoAfAAPp1Mok0wrCOloZQJchATiWdu4XPxDu0le7oYwO2PAXtdIeFyY+oA6GmdnSTpDwuTH1AHQ09t6z9QAoyeEfCjG2sQiphroae29Z+n9OiWlO+b27+c/BFooNM7hvg0l86ZMBZGgjDVBfgx3DdHnbFWQy2gToCIaCtE6g3j9BYERN6X4o1H5wZx1WiyfHyk3iLHnRIXPg1WG39C9TOd2THo/VuzuUUDyveTZvcg6QHRdyQBTToFRJqHkk5Cl0tv7BG4IiI1z4+eHqUoHQiyH1dOhp7b1n6f2Gur37WWa2Fhii4d+yIaCtE6g3jx/am5DI1g+P/VrjprA5DDhogCZkCBCvhCJzsoWewnLhE1m8x50XhcmPqAOhp7b1n6gDpDwuTH000QIAD+/znCL//Bwf+MX+dAkrv//MY+AAcvvPWD2m4T4UhB2ieZOkeJ4A+YXnblkpC5seRFwuT9RLYAH6cII4nQCelpelaLIYM7z3/8TFNHhi1aZ1RdsZ0TTi5iRMynwBjFvAmW1XrUM7eO1Wj73b5zirjr1pw4mbnFO3jPoAB4gAYapB4m4EY5vnjrUYk/oNOi1h9zkED0xdJsOr+VaJkvCZ8dSV2w3CY3cgf8fRXDNcL6+dvvta02xEh4gk4Dz8c/DcVSE0IQNN3gZX7bW6/GO/pZ+bTyJ2Dq4TdeAIlNxsQ+M8Gvb8/0ibn2qxBBtmQv0do/azmex+C4hn7RcBR+1RTwls5KJ9O17av3zM9/hbZ/B51xQm15r//YThR7UpbH6afsUv6h6QSNl+wQc2q/XTUaVYiOADQ9EpIzzxxHQ8iHLwdC8d4w/yk7NgNVhTdu+H+/M4PwtmRkvmZeMZxIGTeqGvSx/a/XQld+amq2y+8dGgmo/18vja/f6z9cUJO+P9xepuKHzzlOPGI0tMbWX3QzyAvTV1Zq/4Xwfvz6EjSRUSIbK4oqGmyBGV3sNhjrzRXfKtVIMq1IMMdxccRGQ2EoStF7RQktZFzdz6x8hikJrgziQ32XkQjHeeZpr/twwxVXiGSQYBS4OmapQUvAIAH5+AAAAAA=",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"可以看到，在点光源的作用下，平面上的不同点也产生了明暗效果。"}),"\n",(0,r.jsxs)(e.h4,{id:"物体缩放时的表现",children:["物体缩放时的表现。",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#物体缩放时的表现",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"结束了吗？当然没有，我们还有一个问题没有解决。"}),"\n",(0,r.jsx)(e.p,{children:"假设有一物体表面被光线照射："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"当对物体执行非等比缩放时，顶点法向量也会执行非等比缩放，但是执行缩放后的法向量却不再垂直于顶点所在平面了，如下图："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"法向量不正确带来的后果是光照计算不准，表现如下："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,UklGRqQCAABXRUJQVlA4IJgCAAAQKACdASpoAfAAPp1On0wwqCoiJpQYahATiWdu4XPxERffeGNkHnr4ZSHBnwpLzhSXD99B11RC0GTPhSXnCkvJdNdHVRe1WsHSG2IcZNYMzH7kvJwRJ0jPg7DkzcHdw2IAAH1j+hUIZQk8l9vnS3ohsKxGp7Ta0dU3o78YsBw28wQ1DFxi3Y9lljzWSzT0SEVp4s09VfC1GFDfE4uUZS0OqVg5xn08rYpRdg63DuIAi9Uk/DVNQCR1aJX27zBUUQtBkzniHOC0HG/KTLquq3zV38Vi9HAUm+lwGIJb70UuWC3Ii58I+N/6E4mn/egn3rCORTJdrREIGkRjHRtTVnYttu9pj5IY1MbxIWgyZ8ZGa0mtbLGQue5nxFGasF6MuwggqiiFoMmfClIBMI0BDjJrBmY/cl5wpLzhQvjX5bF0ExEhtiJDYVROgAD+/wZr/8p/le/9p+e28iGsP/rHf9p/NAAAAVTR0vAR6kPkgadYW8EYDH63t8fvIfUT/OjEBIJVAMH1hm5DUbN4GqjfpNGK4nSqzVzLNIBAWt9AE+bHwdQBcIzhvBy/odk0oRfTQwzXpWDybJMk7S7WUNflo5/UhoJEa4HMxYApxKpB2NjWjIhSOe/rno1pL1xaIQArSwOFs8mq36ojefhXTJlAaLxoiLVn6/ZHckynlglMQL5yhUzwUKpPXFNlxCXJkC9qUbCfCAjXpn1wzkMaN+NI+PiWyxWuUIXiuWg0ocq31qT5uugUwdbT44WIGlXgr0h/sCQv6Iet1KtBTUBVVt5iaEOPSNxXJCYaUrbIIq5YE85hKQce/0KgXrnBIKRJqHlTHNRLWs0fFgBX8HZRNJSeqKxTMXAsFdj8kLUgPmGNnhqmgAAAAAAAAAAA",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"可以看到，当我们队球体执行纵向放大的时候，放大的部分虽然正对着光源，但是没有光照。"}),"\n",(0,r.jsxs)(e.p,{children:["因此，我们不能使用简单的模型矩阵来变换顶点法向量了。为了解决这个问题，我们需要专门为法向量的变换定义一个单独的矩阵",(0,r.jsx)(e.code,{children:"法线矩阵"}),"，法线矩阵可以用「模型矩阵左上角的3维矩阵的逆矩阵的转置矩阵」来代替。听起来比较复杂，其实很简单。"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"1、对模型矩阵执行逆矩阵操作。"}),"\n",(0,r.jsx)(e.li,{children:"2、对上一步得出的矩阵执行转置矩阵。"}),"\n",(0,r.jsx)(e.li,{children:"3、取上一步得出的矩阵的前三阶矩阵。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"我们修改一下程序，顶点着色器和片元着色器部分不用改变，我们需要修改 JavaScript 部分。"}),"\n",(0,r.jsx)(e.p,{children:"我们使用矩阵库的两个方法 transpose 和 inverse 来对模型矩阵执行转置操作和求逆操作。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"var normalMatrix = matrix.transpose(matrix.inverse(modelMatrix));\n"})}),"\n",(0,r.jsx)(e.p,{children:"然后将该矩阵传递给顶点着色器即可，我们看下修改后的效果："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,UklGRqYDAABXRUJQVlA4IJoDAADwKQCdASpoAfAAPp1Oo0ywqCeloxaJchATiWdu4XOAZrToJG3L0aFjIhCwC3gOV4WvdyV6L8mFRfkwqL8lQZrcKYzDkVUsciqljkVLFGlF+TCovyYVF+SqR4ckkVFwRVF8QuyyqlMGsVUsbtkxRTr612gKd4L0vy1eOnZZMrlQLKl8di+UjGCdu9dc7KnuookkVB0BHsf+Pg5Pbcp6AJEPRvlhPqqjveSwvyVSPDkkgbkW0fD0HuIzHRQmr+W90lHaTlnogA3PtYqpYb86TWURVZxw5jTMoC7Ws3gqxBVuIxGABufaxVSw4NTiazyU368bvTjEdrGUOnfii6dldaO+FRhThuWdsIvCt7Xta36tq1yHs4lYFkAG/S6U/OHH9fJHStJdM7qnYprDYTyLFG/sfeuVAsqpbIoWbYAN/Y+9cqBZVSxyKqWORVQINOKqWORVSxyKqWHxAAD+/qWR/8HB8NaFUVg1f7jnulfhrqkDFAP8gACxS1fUt/SNCQtbAYy0dwfvrXZIGA1GFS/slCIdbKjvP7n+yxhDxWBlRHhx+e2SkvxT7vrF3B7vdGGcoyKdeRkmp/FSUYck8rAYOlAYYYlIFgLKiDyoCBfKH/khH/0GHo8p57/ZHG+YcUNOc/rqDz0qQfi/nHMiUsyUuGMgZ4Mm3va+oHB2khvTrBFs8W5MOJgjPBAAaAg2nYYPPsaHglt8sM8h65DSiUGSqNdOmXJ/MyG2Pm/h/TmNzv5TeuYWUoVUAynFQkwX1Y9im5npodnMqGame3G6vWUJDJhY8YLOhT6etrKJVdj89j6R7oJu6dv6+WrJxsRfvOgjaysI2ei9MZL237KsFn+///Vdn/IQMxZlHqWvZANNmS52VVqd709juaA1iTBLGmrx9f7N6no4Tts2MWI040ccNRiFcDUguJQ8pHZe0bAYLpaGRnr3X0tMvEAKLSN330YH8xsYErjFgoA/uJRK/kDT9AVQL2VcR3OYI9FzU7Jxzdm/5uwfz/bybJI7sNESg/RoKVmNSq2B51Hz5KKsXOBtW5R9z5YuiKSoPYajCPmWBdaUd2fhvbOCi/m3m4lD3sbSgLMITIFhFqric4rya0lchvp07aWoq5Nj+4zDk9yCpwcFqzB6Cr2yz2KaBAOPWqk9BHwO3fGv6HspDtJgL1LW/jAJfpmIFfSG+P5oKo78DAovoAAGNVgN36XB1JLXhL9u1OjuDEDMAAAAAAAA",alt:""})}),"\n",(0,r.jsxs)(e.h2,{id:"回顾",children:["回顾",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"至此，冯氏光照模型的漫反射部分就讲解完了，原理比较简单，但是计算量比较多，尤其是涉及到的一些矩阵运算知识，大家可能有些蒙，这是正常现象。大家只要会使用矩阵就可以了，至于为什么要用矩阵表示变换，之后的章节再向大家揭开这个谜团。"}),"\n",(0,r.jsxs)(e.p,{children:["下一节，我们学习冯氏光照模型的第三个分量，",(0,r.jsx)(e.code,{children:"镜面高光"}),"。"]})]})}function x(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(h,{...n})}):h(n)}let o=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F11.%E4%B8%AD%E7%BA%A7%E8%BF%9B%E9%98%B6%20---%20%E5%86%AF%E6%B0%8F%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E7%89%A9%E4%BD%93%E5%A2%9E%E5%8A%A0%E6%BC%AB%E5%8F%8D%E5%B0%84%E6%95%88%E6%9E%9C.md"]={toc:[{text:"冯氏光照模型",id:"冯氏光照模型",depth:2},{text:"计算漫反射光照",id:"计算漫反射光照",depth:2},{text:"入射角的表示与计算",id:"入射角的表示与计算",depth:3},{text:"计算反射光强度",id:"计算反射光强度",depth:4},{text:"法向量",id:"法向量",depth:4},{text:"光源照射方向向量的计算",id:"光源照射方向向量的计算",depth:4},{text:"计算漫反射光照",id:"计算漫反射光照-1",depth:4},{text:"平行光漫反射",id:"平行光漫反射",depth:4},{text:"动态计算法向量",id:"动态计算法向量",depth:4},{text:"点光源的漫反射",id:"点光源的漫反射",depth:4},{text:"物体缩放时的表现。",id:"物体缩放时的表现",depth:4},{text:"回顾",id:"回顾",depth:2}],title:"11.中级进阶 --- 冯氏光照模型：为物体增加漫反射效果",headingTitle:"11.中级进阶 --- 冯氏光照模型：为物体增加漫反射效果",frontmatter:{}}}}]);