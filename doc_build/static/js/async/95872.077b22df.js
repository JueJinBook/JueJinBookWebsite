"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["95872"],{133945:function(n,e,r){r.r(e),r.d(e,{default:()=>A});var i=r(552676),s=r(740453);let t=r.p+"static/image/27e4685fe0a05887f45f3dacc1b83ef1.7a99a257.webp",a=r.p+"static/image/ba7d10ede7899c94c1d15f76e3fbea61.5fc460f2.webp",d=r.p+"static/image/f38c8e16f9722a41f9438a9bb29b0d87.422b329c.webp",o=r.p+"static/image/588fcfcf5e2f79c7811de5811abe11c3.ed2d3e0b.webp",c=r.p+"static/image/1dedea8600d0d62ec3b1c75e30f0f63c.4e96d989.webp",l=r.p+"static/image/66366ba3ab9253d7f1e8588fab3b9467.f1c6f45a.webp";function u(n){let e=Object.assign({p:"p",strong:"strong",img:"img",ul:"ul",li:"li",code:"code",blockquote:"blockquote",ol:"ol",h1:"h1",a:"a",pre:"pre",h2:"h2",h3:"h3"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:["在 React v18 中，引入了 useTransition 和 useDeferredValue 两个  Hooks，它们都是用来处理",(0,i.jsx)(e.strong,{children:"数据量大"}),"的数据，比如百度的搜索框、散点图等。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:l,alt:"useTransition 和  useDeferredValue.png"})}),"\n",(0,i.jsx)(e.p,{children:"我们先回顾一下什么是过渡更新任务和紧急更新任务？"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"紧急更新任务：用户立马能够看到效果的任务，如输入框、按钮等操作，在视图上产生效果的任务。"}),"\n",(0,i.jsxs)(e.li,{children:["过渡更新任务：由其他因素引起的任务，导致无法在视图上看到效果的任务，如请求接口数据，需要一个 ",(0,i.jsx)(e.code,{children:"loading..."})," 的状态。"]}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"这里的任务只是针对单一状态，同一操作可能会有多种任务发生。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"为了更好的理解，我们先来看这样一个例子。"}),"\n",(0,i.jsxs)(e.p,{children:["假设我们有一个\xa0",(0,i.jsx)(e.code,{children:"input"}),"\xa0输入框，这个输入框的值要维护一个很大列表（假设列表有 2w 条数据），比如说过滤、搜索等情况，这时有两种变化："]}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"input 框内的变化；"}),"\n",(0,i.jsx)(e.li,{children:"根据 input 的值，1w 条数据的变化。"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["input 框内的变化是实时获取的，也就是受控的，此时的行为就是",(0,i.jsx)(e.strong,{children:"紧急更新任务"}),"。"]}),"\n",(0,i.jsxs)(e.p,{children:["而这 2w 条数据的变化，就会有过滤、重新渲染的情况，此时这种行为被称为",(0,i.jsx)(e.strong,{children:"过渡更新任务"}),"。　"]}),"\n",(0,i.jsx)(e.p,{children:"了解完紧急更新任务和过渡更新任务后，正式来看看 useTransition 究竟是如何处理大数据的。"}),"\n",(0,i.jsxs)(e.h1,{id:"15源码篇深入探究-usetransition-和-usedeferredvalue",children:["15.源码篇｜深入探究 useTransition 和 useDeferredValue",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#15源码篇深入探究-usetransition-和-usedeferredvalue",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"在介绍并发的时候提及到 useTransition 内更新的事件会采取 Concurrent 模式，而 Concurrent 模式可以中断，让优先级高的任务先进行渲染，让用户有更好的体验。"}),"\n",(0,i.jsxs)(e.p,{children:["换言之，useTransition 是用于一些",(0,i.jsx)(e.strong,{children:"不是很急迫的更新上"}),"，同时解决并发渲染的问题而诞生的。"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"值得注意的是：useTransition 一定是处理数据量大的数据。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"接下来我们模拟一下上述的场景，具体来看看效果。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"模拟案例："})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:'// utils \nexport const count = 20000; // 渲染次数\n\nimport { useState } from "react";\nimport { Input } from "antd";\nimport { count } from "./utils";\n\n// 正常情况\nconst Index: React.FC<any> = () => {\n  const [list, setList] = useState<string[]>([]);\n\n  return (\n    <>\n      <Input\n        onChange={(e) => {\n          const res: string[] = [];\n          for (let i = 0; i < count; i++) {\n            res.push(e.target.value);\n          }\n          setList(res);\n        }}\n      />\n      {list.map((item, index) => (\n        <div key={index}>{item}</div>\n      ))}\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,i.jsx)(e.p,{children:"在案例中，我们有一个输入框，输入内容时会在下方输出 2w 数据。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"正常模式下的效果："})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,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",alt:"img.gif"})}),"\n",(0,i.jsx)(e.p,{children:"在正常情况下，输入内容，页面会异常的卡顿，这种体验明显非常不好。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"useTransition 模式下的效果："})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,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",alt:"img2.gif"})}),"\n",(0,i.jsx)(e.p,{children:"在 useTransition 中，可以看出在输入数字时，input 框内会正常显示，而列表会滞后，同时 useTransition 提供 isPending 来处理更新是否完成。这种效果明显给用户带来了极好的体验。"}),"\n",(0,i.jsxs)(e.h2,{id:"对比防抖节流定时器",children:["对比防抖、节流、定时器",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#对比防抖节流定时器",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"可能有小伙伴会问，这不就是防抖和节流嘛，为什么要多出一个 useTransition 呢？是不是有点多此一举？"}),"\n",(0,i.jsx)(e.p,{children:"的确，在 React v18 之前，我们都用防抖、节流去解决，接下来我们先分别看下两种方式的效果。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"防抖模式下的效果："})}),"\n",(0,i.jsx)(e.p,{children:"防抖 (Debouncing) ：指在一定时间内，多次触发同一个事件，只执行最后一次操作。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,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",alt:"img3.gif"})}),"\n",(0,i.jsx)(e.p,{children:"在防抖的示例中，我们发现交互效果得到了明显的改善，因为用户在连续输入时，只在最后一次才做处理，在此之前，浏览器的渲染引擎并没有被阻塞，所以可以看到输入框的内容。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"节流模式下的效果："})}),"\n",(0,i.jsx)(e.p,{children:"节流（Throttling）：指在一定时间内，多次触发同一个事件，只执行第一次操作。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,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",alt:"img4.gif"})}),"\n",(0,i.jsx)(e.p,{children:"在节流的示例中，虽然用户可以看到输入的内容，也能较快地看到对应的结果列表，但在第一次渲染的时候有明显的卡顿，实际上防抖也会在第一次渲染后有卡顿的效果。"}),"\n",(0,i.jsx)(e.p,{children:"我们知道，防抖和节流本质上都是定时器，那么我们现在只用 setTimeout 来进行测试，一起来看看效果："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,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",alt:"img5.gif"})}),"\n",(0,i.jsx)(e.p,{children:"在定时器的示例中，效果跟节流的效果类似。但相比于正常情况下的效果要好一些。"}),"\n",(0,i.jsxs)(e.h2,{id:"usetransition-与定时器的异同",children:["useTransition 与定时器的异同",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usetransition-与定时器的异同",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"我们先看看防抖、节流、setTimeout 存在的问题。"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"防抖：延迟 React 更新操作，换言之，快速长时间输入，列表依旧等不到响应，但列表得到响应后，渲染引擎依旧会出现阻塞，导致页面卡顿。"}),"\n",(0,i.jsx)(e.li,{children:"节流：节流在一段时间内开始处理，渲染引擎也会出现阻塞，页面会卡顿，而节流的时间需要手动配置。"}),"\n",(0,i.jsx)(e.li,{children:"setTimeout：setTimeout 也是同理，依旧会出现阻塞、卡顿，所以依然会阻止页面交互。"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["我们知道，防抖和节流的本质都是",(0,i.jsx)(e.strong,{children:"定时器"}),"，虽然能在一定的程度上改善交互效果，但依旧不能解决卡顿或卡死的情况。因为 ",(0,i.jsx)(e.strong,{children:"React 的更新不可中断，导致 JS 引擎长时间占据浏览器的主线程，使得渲染引擎被长时间阻塞。"})]}),"\n",(0,i.jsx)(e.p,{children:"针对这个问题， React v18 推出 useTransition 来解决这个问题，那么它与定时器有何作用："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"使用 useTransition 会触发 Concurrent 模式，所以渲染进程不会长时间被阻塞，使得其他操作得到及时响应，从而使用户体验得到了极大的提升；"}),"\n",(0,i.jsxs)(e.li,{children:["其次，定时器的本质是",(0,i.jsx)(e.strong,{children:"异步延时执行"}),"，而 useTransition 属于",(0,i.jsx)(e.strong,{children:"同步执行"}),"，通过标记 transition 来决定是否完成此次更新。所以 useTransition 要比定时器更新得要早，整体的效果要好很多；"]}),"\n",(0,i.jsx)(e.li,{children:"对于防抖、节流、setTimeout 来说，相当于合并渲染的次数，简单地说，就是控制了 render 的渲染次数，而 useTransition 并没有减少渲染的次数，这点要切记。"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"问：减少 render 的渲染次数不是很好吗？为什么还要用 useTransition 呢？"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"答：在上面的示例中，我们发现无论是防抖还是节流都会出现轻微卡顿的现象，但要特别注意，我们渲染的数据是写死的 2w 条，在真实的环境下，我们无法确定实际的数量。"}),"\n",(0,i.jsxs)(e.p,{children:["换言之，我们并不好控制防抖和节流的",(0,i.jsx)(e.strong,{children:"延时时间"}),"，如果时间过长，导致一种滞后的感觉，如果时间过短，就会出现卡顿的效果。"]}),"\n",(0,i.jsx)(e.p,{children:"而 useTransition 并不需要考虑这些因素，通过中断渲染，让浏览器在空闲时间下执行，达到更佳的效果。"}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"设备性能影响",children:["设备性能影响",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#设备性能影响",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["关于渲染，也与本身的机器有关，关于具体的影响可参考：",(0,i.jsx)(e.a,{href:"https://github.com/reactwg/react-18/discussions/65",target:"_blank",rel:"noopener noreferrer",children:"Real world example: adding startTransition for slow renders"}),"。"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"注：useTransition 用于函数组件，在类中使用 startTransition。但要注意，startTransition 也可以用在函数组件中。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"我们直接来看看效果，注意滑块："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"正常情况下："}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:c,alt:"img6.gif"})}),"\n",(0,i.jsxs)(e.ol,{start:"2",children:["\n",(0,i.jsx)(e.li,{children:"定时器效果下："}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:o,alt:"img7.gif"})}),"\n",(0,i.jsxs)(e.ol,{start:"3",children:["\n",(0,i.jsx)(e.li,{children:"useTransition 效果下："}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:d,alt:"img9.gif"})}),"\n",(0,i.jsxs)(e.h1,{id:"usetransition-源码",children:["useTransition 源码",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usetransition-源码",children:"#"})]}),"\n",(0,i.jsxs)(e.h2,{id:"mounttransition初始化",children:["mountTransition（初始化）",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#mounttransition初始化",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["文件位置：",(0,i.jsx)(e.code,{children:"packages/react-reconciler/src/ReactFiberHooks.js"}),"。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"function mountTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const [isPending, setPending] = mountState(false);\n  const start = startTransition.bind(null, setPending);\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"在 mountTransition 中，首先由 isPending 来定义状态，然后会走 startTransition 方法，返回的 start 会保存在 memoizedState 中，那么我们一起看看 startTransition 做了哪些事。"}),"\n",(0,i.jsxs)(e.h3,{id:"starttransition",children:["startTransition",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#starttransition",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"function startTransition(\n  setPending: boolean => void,\n  callback: () => void,\n  options?: StartTransitionOptions,\n): void {\n\n  // 获取优先级\n  const previousPriority = getCurrentUpdatePriority();\n  \n  // 将当前任务重新设置优先级，并且等级要低于 ContinuousEventPriority\n  setCurrentUpdatePriority(\n    higherEventPriority(previousPriority, ContinuousEventPriority),\n  );\n\n  setPending(true);\n\n  // 标记一个过渡位\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  ReactCurrentBatchConfig.transition = ({}: BatchConfigTransition);\n  const currentTransition = ReactCurrentBatchConfig.transition;\n\n  if (enableTransitionTracing) {\n    if (options !== undefined && options.name !== undefined) {\n      ReactCurrentBatchConfig.transition.name = options.name;\n      ReactCurrentBatchConfig.transition.startTime = now();\n    }\n  }\n\n \n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig.transition = prevTransition;\n\n  }\n}\n\n// higherEventPriority\nexport function higherEventPriority(\n  a: EventPriority,\n  b: EventPriority,\n): EventPriority {\n  return a !== 0 && a < b ? a : b;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"在 startTransition 中的流程为："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"首先通过 getCurrentUpdatePriority 获取优先级，通过 higherEventPriority 方法重新给 ContinuousEventPriority（连续事件优先级）设置优先级，如果该任务的优先级低于 ContinuousEventPriority，则继续使用该任务的优先级。"}),"\n",(0,i.jsxs)(e.li,{children:["之后通过 setPending 将 isPending 设置为 true， 然后会设置一个标记位，此时更新会",(0,i.jsx)(e.strong,{children:"优先处理"}),"。"]}),"\n",(0,i.jsx)(e.li,{children:"然后再将 isPending 改为 false，并在 callback 中触发定义的更新，此过程会触发 setPending， 最终设置回原来的优先级。"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"ispending-工作原理",children:["isPending 工作原理",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#ispending-工作原理",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"首先我们要知道，mountTransition 中用 mountState 定义的 isPending 就是 useTransition 中的第一个参数，也就是中间状态。"}),"\n",(0,i.jsx)(e.p,{children:"但在 startTransition 中连续调用了三次 setPending，换言之，调用了三次 useState，而在实际的效果中，只触发了两次 React 更新呢？"}),"\n",(0,i.jsx)(e.p,{children:"我们很容易想到， useState 具有批量更新的机制，但应该将三次触发更新合并成一次更新，为什么是两次呢？"}),"\n",(0,i.jsx)(e.p,{children:"实际原因是："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"ReactCurrentBatchConfig.transition = ({}: BatchConfigTransition);\n"})}),"\n",(0,i.jsx)(e.p,{children:"将 transition 设置为空，使得前后逻辑中的上下文不一致，导致采用的模式不同，分别采用 legacy（同步阻塞）模式和 concurrent（并发）模式。 而后面的两次更新会触发批量更新，合并为一次。所以，一共会触发两次更新。"}),"\n",(0,i.jsxs)(e.h2,{id:"updatetransition更新",children:["updateTransition（更新）",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#updatetransition更新",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"function updateTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const [isPending] = updateState(false);\n  const hook = updateWorkInProgressHook();\n  const start = hook.memoizedState;\n  return [isPending, start];\n}\n"})}),"\n",(0,i.jsxs)(e.p,{children:["可以看出，useTransition 在更新过程中并没有什么特殊的逻辑，只是调用 ",(0,i.jsx)(e.code,{children:"updateState"})," 去更新 isPending 的状态。"]}),"\n",(0,i.jsxs)(e.h2,{id:"对比-starttransition",children:["对比 startTransition",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#对比-starttransition",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"对比 Hooks 中的 useTransition，我们顺便看看类中的 startTransition，两者有何区别。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:a,alt:"img10.gif"})}),"\n",(0,i.jsx)(e.p,{children:"在 startTransition 中，当用户连续输入时，会出现轻微的卡顿，可以看出 startTransition 并没有防抖的效果，具体原因下文介绍，我们先来看看对应的源码："}),"\n",(0,i.jsxs)(e.p,{children:["文件位置：",(0,i.jsx)(e.code,{children:"packages/react/src/ReactStartTransition.js"}),"。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"export function startTransition(\n  scope: () => void,\n  options?: StartTransitionOptions,\n) {\n  const prevTransition = ReactCurrentBatchConfig.transition;\n  \n  // 设置状态\n  ReactCurrentBatchConfig.transition = ({}: BatchConfigTransition);\n\n  try {\n    // 执行更新\n    scope();\n  } finally {\n    // 恢复原来的状态\n    ReactCurrentBatchConfig.transition = prevTransition;\n  }\n}\n\n"})}),"\n",(0,i.jsx)(e.p,{children:"在 startTransition 源码中，我们发现并没有 isPending 的逻辑，这是直接导致 startTransition 不具备防抖效果的原因。"}),"\n",(0,i.jsxs)(e.p,{children:["要知道，在 Concurrent 模式下，",(0,i.jsx)(e.strong,{children:"低优先级更新会被高优先级中断，此时，低优先级更新已经开始的协调会被清除，并且会被重置为未开始的状态。"})]}),"\n",(0,i.jsx)(e.p,{children:"当被重置后，导致 transition 更新只有在用户停止输入（或超过 5s）时才会得到有效的处理。"}),"\n",(0,i.jsx)(e.p,{children:"通过设置 isPending 为 true 时可以形成中断，形成类似防抖的作用；而 startTransition 本身并没有中断，连续的输入并不会重置 transition 更新，然后开始浏览器渲染过程，因此没有防抖的作用。"}),"\n",(0,i.jsx)(e.p,{children:"通过源码的阅读，我们发现 useTransition 实际上是 useState + startTransition 的结合体，而 isPending 的状态通过 ReactCurrentBatchConfig.transition 的变化进行更新，以此来捕获过渡时间。"}),"\n",(0,i.jsxs)(e.h1,{id:"usedeferredvalue",children:["useDeferredValue",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usedeferredvalue",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"当我们介绍完 useTransition 后，我们再一起看看它的“兄弟”：useDeferredValue。"}),"\n",(0,i.jsx)(e.p,{children:"之所以称为“兄弟”，是因为这两个 Hooks 极为相似，有点类似于 useMemo 和 useCallback 的关系，useTransition 用来处理更新函数，而 useDeferredValue 用来处理数据本身。"}),"\n",(0,i.jsxs)(e.p,{children:["useDeferredValue 可以让",(0,i.jsx)(e.strong,{children:"状态滞后派生"}),"，推迟屏幕优先级不高的部分。"]}),"\n",(0,i.jsxs)(e.h2,{id:"使用示例",children:["使用示例",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#使用示例",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"useDeferredValue 是趋向于值的维护，当我们存在批量查找的时候，它会是一个好帮手，举个例子："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:'import { useState, useDeferredValue } from "react";\nimport { Input } from "antd";\n\nconst getList = (key: any) => {\n  const arr = [];\n  for (let i = 0; i < 20000; i++) {\n    if (String(i).includes(key)) {\n      arr.push(<li key={i}>{i}</li>);\n    }\n  }\n  return arr;\n};\n\nconst Index: React.FC<any> = () => {\n  const [input, setInput] = useState("");\n  const deferredValue = useDeferredValue(input);\n\n  return (\n    <>\n      <div>寻找2w以内匹配的数据：</div>\n      <Input value={input} onChange={(e: any) => setInput(e.target.value)} />\n      <div>\n        <ul>{deferredValue ? getList(deferredValue) : null}</ul>\n      </div>\n    </>\n  );\n};\n\nexport default Index;\n'})}),"\n",(0,i.jsx)(e.p,{children:"效果："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:t,alt:"img.gif"})}),"\n",(0,i.jsx)(e.p,{children:"在案例中，我们通过  useDeferredValue 去维护 Input 中的值，从两万条数据中去查询包含的值，然后输出到列表中。"}),"\n",(0,i.jsx)(e.p,{children:"了解完 useDeferredValue 的使用，再来看看它的源码，同样分为：mountDeferredValue（初始化）和 updateDeferredValue（更新）两个步骤。"}),"\n",(0,i.jsxs)(e.h2,{id:"mountdeferredvalue初始化",children:["mountDeferredValue（初始化）",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#mountdeferredvalue初始化",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["文件位置：",(0,i.jsx)(e.code,{children:"packages/react-reconciler/src/ReactFiberHooks.js"}),"。"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"function mountDeferredValue<T>(value: T): T {\n  const hook = mountWorkInProgressHook();\n  hook.memoizedState = value;\n  return value;\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"mountDeferredValue 的功能很简单，只是进行了一个初始化 hook，将值保存在 memoizedState 中。"}),"\n",(0,i.jsxs)(e.h2,{id:"updatedeferredvalue更新",children:["updateDeferredValue（更新）",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#updatedeferredvalue更新",children:"#"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"function updateDeferredValue<T>(value: T): T {\n  const hook = updateWorkInProgressHook();\n  const resolvedCurrentHook: Hook = (currentHook: any);\n  const prevValue: T = resolvedCurrentHook.memoizedState;\n  return updateDeferredValueImpl(hook, prevValue, value);\n}\n\nfunction updateDeferredValueImpl<T>(hook: Hook, prevValue: T, value: T): T {\n  const shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes); // 对比优先级\n  \n  if (shouldDeferValue) {\n    if (!is(value, prevValue)) {\n      // 设置优先级\n      currentlyRenderingFiber.lanes = mergeLanes(\n        currentlyRenderingFiber.lanes,\n        deferredLane,\n      );\n      markSkippedUpdateLanes(deferredLane);\n      hook.baseState = true;\n    }\n\n    return prevValue;\n  } else {\n    // 如果 baseState 存在，则会触发更新流程\n    if (hook.baseState) {\n      hook.baseState = false;\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = value;\n    return value;\n  }\n}\n"})}),"\n",(0,i.jsx)(e.p,{children:"在 updateDeferredValue 中，首先拿到上一次记录的值（prevValue），然后走向 updateDeferredValueImpl 函数。"}),"\n",(0,i.jsx)(e.p,{children:"updateDeferredValueImpl 函数首先会对比优先级，如果优先级高于当前优先级，shouldDeferValue 则为 true，通过 is 去比较新值（value）与旧值（prevValue）是否相等，如果不相等，则更新优先级，并且将 baseState 设置为 true，用作后续是否更新视图的依据。"}),"\n",(0,i.jsx)(e.p,{children:"此时，baseState 为 true 代表新值与旧值不同，则会触发 markWorkInProgressReceivedUpdate() 函数（与 useState 的  updateReducer 一致），触发更新渲染流程，最终返回最新值。"}),"\n",(0,i.jsxs)(e.h1,{id:"usetransition-与-usedeferredvalue-的使用场景",children:["useTransition 与 useDeferredValue 的使用场景",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#usetransition-与-usedeferredvalue-的使用场景",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["通过上面的源码，我们发现 useTransition 和 useDeferredValue 都是将包裹的任务标记成",(0,i.jsx)(e.strong,{children:"过渡更新任务"}),"。换言之，它们包裹的数据都属于",(0,i.jsx)(e.strong,{children:"优先级比较低"}),"的，所以在渲染的时候会有一定的滞后性，从而用更多的资源去渲染优先级更高的更新。"]}),"\n",(0,i.jsxs)(e.p,{children:["同时，它们都适合",(0,i.jsx)(e.strong,{children:"大数据"}),"处理的优化，如案例中 2w 条数据的处理、百度输入框、散点图等，除此之外，一般的场景没有必要去使用这两个 hooks，因为它们本身会带来一定的性能损耗，\n只有处理",(0,i.jsx)(e.strong,{children:"数据量大的数据"}),"时，才去考虑去使用它们。"]}),"\n",(0,i.jsx)(e.p,{children:"最后，对同一个资源优化时，只需要用它们两个的其中一个即可，因为它们优化的效果一致，如果两个都使用，肯定会带来一定的损耗，所以两者并不建议同时使用。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"问：既然 useTransition 与 useDeferredValue 这么相似，那我们如何更好地区分它们呢？"}),"\n"]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"答：能使用 useTransition 的时候就使用 useTransition，除非不能用 useTransition，才去考虑 useDeferredValue。"}),"\n",(0,i.jsx)(e.p,{children:"因为 useTransition 用来处理函数，也就是说它可以一次性处理几个更新函数，并且在大多数场景下 useTransition 要比 useDeferredValue 的性能更好，所以这里更加推荐 useTransition。"}),"\n",(0,i.jsx)(e.p,{children:"但我们使用一些三方库的时候，比如 ahooks，它的更新函数并没有直接暴露给我们，只返回对应的值给我们，这种情况下可使用 useDeferredValue 来做优化。"}),"\n"]}),"\n",(0,i.jsxs)(e.h1,{id:"小结",children:["小结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["通过本章的阅读，我们了解了 useTransition 和  useDeferredValue 的使用方法和对应的源码，通过它们可实现",(0,i.jsx)(e.strong,{children:"中断"}),"，使优先级更高的事件优先执行，同时学习了两者的关联和使用场景。"]}),"\n",(0,i.jsx)(e.p,{children:"并且通过案例详细分析 useTransition 与防抖、节流、定时器的区别，然后对比 startTransition 来说明 useTransition 的优势， 总而言之，useTransition 的效果更佳，极大地提升用户体验。"}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"注：startTransition 在函数组件和类组件中都能使用，而 useTransition 只能用在函数组件。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"除此之外，我们要特别铭记不同的更新上下文，导致的模式不同。用 useTransition、useDeferredValue 包裹的更新才会走 Concurent 模式，一般情况依旧会走 legacy 模式。"}),"\n",(0,i.jsx)(e.p,{children:"最后，关于源码篇的章节就此结束，接下来，我们通过具体的实践，来帮助我们在工作中更好地去应用这些 Hooks。"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(u,{...n})}):u(n)}let A=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F15.%E6%BA%90%E7%A0%81%E7%AF%87%EF%BD%9C%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%20useTransition%20%E5%92%8C%20useDeferredValue.md"]={toc:[{text:"对比防抖、节流、定时器",id:"对比防抖节流定时器",depth:2},{text:"useTransition 与定时器的异同",id:"usetransition-与定时器的异同",depth:2},{text:"设备性能影响",id:"设备性能影响",depth:2},{text:"mountTransition（初始化）",id:"mounttransition初始化",depth:2},{text:"startTransition",id:"starttransition",depth:3},{text:"isPending 工作原理",id:"ispending-工作原理",depth:3},{text:"updateTransition（更新）",id:"updatetransition更新",depth:2},{text:"对比 startTransition",id:"对比-starttransition",depth:2},{text:"使用示例",id:"使用示例",depth:2},{text:"mountDeferredValue（初始化）",id:"mountdeferredvalue初始化",depth:2},{text:"updateDeferredValue（更新）",id:"updatedeferredvalue更新",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);