"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["44581"],{46308:function(n,e,r){r.r(e),r.d(e,{default:()=>o});var i=r(552676),t=r(740453);let s=r.p+"static/image/65f59f2969b395439d7b79b4653db6bd.4ff1d28f.webp";function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",h3:"h3",img:"img",strong:"strong",code:"code",pre:"pre",blockquote:"blockquote",br:"br"},(0,t.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"第25章并发一go语言并发初探",children:["第25章—并发一｜Go语言并发初探",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第25章并发一go语言并发初探",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"\uFEFF如果去网上搜索：“Go 语言为 而生”，很大概率会看到“并发”、“云”等等关联词。没错，Go 语言的出发点即是瞄准大数据云计算时代背景下的高并发、分布式应用场景的。"}),"\n",(0,i.jsx)(e.p,{children:"目前服务端的发展趋势集中在容器化、分布式和微服务方面，Go 语言在这些领域已经大显身手。容器领域中，Docker 和 Kubernets（K8S）是由 Go 语言实现的；分布式领域中，Etcd、Fleet、InfluxDB 这类新型分布式数据库也是由 Go 语言编写的；微服务方面，字节跳动旗下的今日头条产品使用 Go 语言构建了超过 100 个微服务。据统计，其高峰 QPS 超过 700 万，日处理请求量超过 3000 亿。"}),"\n",(0,i.jsx)(e.p,{children:"从本讲开始，我将详细介绍 Go 语言中的并发。都说 Go 语言的并发简单易学，本讲就来带着大家一起体会其中的奥秘，具体内容包括："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"基本概念"}),"\n",(0,i.jsx)(e.li,{children:"并发任务的启动；"}),"\n",(0,i.jsx)(e.li,{children:"使用并发的注意事项。"}),"\n"]}),"\n",(0,i.jsxs)(e.h2,{id:"基本概念",children:["基本概念",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#基本概念",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"我们先从一些基本的概念谈起。"}),"\n",(0,i.jsxs)(e.h3,{id:"并发与并行",children:["并发与并行",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#并发与并行",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"提到并发，就不得不说说并行。很多人搞不清它们是什么，甚至将其混为一谈，是完全错误的。"}),"\n",(0,i.jsx)(e.p,{children:"想象这样一个场景：我们同时执行 4 个任务，假设这些任务运行在配备了 4 核 CPU 的电脑上。现在，用图表来描述计算机的运行情况，横轴表示时间，纵轴表示每个 CPU 核心，不同颜色的色块表示不同的任务在执行。具体如下："}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)("img",{src:s,alt:"并发VS并行"})}),"\n",(0,i.jsxs)(e.p,{children:["从图中可以看出，",(0,i.jsx)(e.strong,{children:"并发是针对某个 CPU 核心而言的，利用切换 CPU 的时间片来实现多个程序同时运行"}),"。切换时间片的过程通常非常迅速，我们是无法察觉的。"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"并行则是将 4 个任务真正地分配给 4 个CPU核心执行"}),"。这就是并发和并行的区别，二者虽有关系，但",(0,i.jsx)(e.strong,{children:"调度机制完全不同"}),"。",(0,i.jsx)(e.strong,{children:"并发更关注单核心的能力，并行更关注同时做的事情"}),"。"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.code,{children:"❗️ 注意：从图上看，并行似乎比并发效率更高。在某些情况下确实如此，但如果遇到任务间相互通信、彼此依赖的情况就不一定了。所以用并行还是并发，要看代码的具体逻辑而定。"})}),"\n",(0,i.jsxs)(e.h3,{id:"协程与线程",children:["协程与线程",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#协程与线程",children:"#"})]}),"\n",(0,i.jsxs)(e.p,{children:["相信大家对“线程”一词更为熟悉，尤其是具有 Java 基础的朋友。在 Java 中，若要创建一个线程需要斟酌再三。这是因为",(0,i.jsx)(e.strong,{children:"线程是操作系统的资源，它的创建、切换、停止等等都属于操作系统操作，比较“重”"})," 。"]}),"\n",(0,i.jsxs)(e.p,{children:["协程看上去和线程类似，但",(0,i.jsx)(e.strong,{children:"协程是在用户层面的，它的创建、切换、停止等等由用户操作，更“轻”"})," 。"]}),"\n",(0,i.jsx)(e.p,{children:"线程能充分发挥多核 CPU 的优势，可以做到并行执行多任务。协程则不然，协程是为并发而生的，一个线程上可以跑多个协程。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Go 语言中的并发是靠协程来实现的。在后端服务器软件开发中，有大量的 IO 密集操作，这正是协程最适合的场景。这也正是 Go 语言更适合高并发场景的原因。"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.code,{children:"\uD83D\uDCA1 提示： Go 语言的任务调度模型被称为 GPM，我将在下一讲详述GPM模型架构及原理。"})}),"\n",(0,i.jsxs)(e.h2,{id:"并发任务的启动",children:["并发任务的启动",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#并发任务的启动",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"在 Go 语言中启动并发任务非常简单，只需要在相应的语句前面加上 go 即可。来看下面这段代码："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   // 并发调用testFunc()\r\n   go testFunc()\r\n   time.Sleep(time.Second * 5)\r\n   fmt.Println("程序运行结束")\r\n}\r\n// 并发测试函数\r\nfunc testFunc() {\r\n   for i := 1; i <= 3; i++ {\r\n      fmt.Printf("第%d次运行\\n", i)\r\n      time.Sleep(time.Second)\r\n   }\r\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:["在 testFunc() 函数中调用了 time.Sleep() 函数，",(0,i.jsx)(e.strong,{children:"time.Sleep() 的作用是让当前协程暂停特定的时间"}),"。所以整个testFunc() 函数的目的就是每隔1秒执行1次循环体中的代码，总共执行 3 次，共计耗时 3 秒。main() 函数中在调用 testFunc() 函数时前面加了 “go ”，表示创建一个 Goroutine，在另一个协程中执行 testFunc()。程序运行结果为："]}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"第 1 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 2 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 3 次运行"}),"\n",(0,i.jsx)(e.p,{children:"程序运行结束"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"为什么 main() 函数中要等待 5 秒呢？这是因为 testFunc() 函数需要至少 3 秒才能完成，由于 testFunc() 在另一个协程中，并不会影响 main() 函数体中后续代码的执行。因此main() 函数将迅速完成，整个程序便宣告终止了。"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"一旦程序终止，所有在 main() 函数中启动的 Goroutine 也会随之终止"}),"，我们便看不到其它协程中的输出了。所以要给 testFunc() 预留足够多的时长，等待它完成执行。这是使用并发时特别需要注意的一点。"]}),"\n",(0,i.jsx)(e.p,{children:"然而，在实际开发中，我们通常无法确切地得知一个协程的准确执行时长。况且像上述代码中，过长的等待时间将会导致程序运行效率的降低。Go 语言提供了一种特别方便的方式确保执行协程任务的完整性，它来自 sync 包。下面的代码演示了它的使用方法："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'var goRoutineWait sync.WaitGroup\r\nfunc main() {\r\n   goRoutineWait.Add(1)\r\n   // 并发调用testFunc()\r\n   go testFunc()\r\n   goRoutineWait.Wait()\r\n   fmt.Println("程序运行结束")\r\n}\r\n// 并发测试函数\r\nfunc testFunc() {\r\n   defer goRoutineWait.Done()\r\n   for i := 1; i <= 3; i++ {\r\n      fmt.Printf("第%d次运行\\n", i)\r\n      time.Sleep(time.Second)\r\n   }\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"这段代码中，声明了 sync.WaitGroup 类型的变量goRoutineWait。main() 函数体一上来调用了goRoutineWait.Add() 方法，并向其中传入 1。表示即将开启 1 个 Goroutine。紧接着便是启动 Goroutine 了。最后执行了 goRoutineWait.Wait() 方法，该方法将告知程序在此处等待协程任务的完成。在 testFunc() 函数体中，末尾调用了goRoutineWait.Done() 方法，表示协程任务执行完成。"}),"\n",(0,i.jsx)(e.p,{children:"运行这段代码，控制台将得到同样的输出，但不会傻傻地等待 5 秒了。"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.code,{children:"\uD83D\uDCA1 提示：从源码中，有一个 Goroutine 计数器。每次调用 goRoutineWait.Add() 方法时，传入的参数便作为累加值使用；调用 goRoutineWait.Done() 方法时相当于让计数器自减 1。当计数器归 0 时，goRoutineWait.Wait() 方法才会结束。"})}),"\n",(0,i.jsx)(e.p,{children:"接下来上升一点难度，如果要连续并发两次 testFunc() 任务，该如何修改上述代码呢？"}),"\n",(0,i.jsx)(e.p,{children:"答案是："}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'var goRoutineWait sync.WaitGroup\r\nfunc main() {\r\n   // Goroutine计数器增2\r\n   goRoutineWait.Add(2)\r\n   // 第一次并发调用testFunc()\r\n   go testFunc()\r\n   // 第二次并发调用testFunc()\r\n   go testFunc()\r\n   goRoutineWait.Wait()\r\n   fmt.Println("程序运行结束")\r\n}\r\n// 并发测试函数\r\nfunc testFunc() {\r\n   defer goRoutineWait.Done()\r\n   for i := 1; i <= 3; i++ {\r\n      fmt.Printf("第%d次运行\\n", i)\r\n      time.Sleep(time.Second)\r\n   }\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"由于并发两次，所以要向 goRoutineWait.Add() 方法传入 2。程序运行结果为："}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"第 1 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 1 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 2 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 2 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 3 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 3 次运行"}),"\n",(0,i.jsx)(e.p,{children:"程序运行结束"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["在 Go 语言中开启 Goroutine，还可以",(0,i.jsx)(e.strong,{children:"通过匿名函数的方式，当代码中只发生一次调用时特别方便"}),"。比如："]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-go",children:'func main() {\r\n   goRoutineWait.Add(1)\r\n   go func() {\r\n      defer goRoutineWait.Done()\r\n      for i := 1; i <= 3; i++ {\r\n         fmt.Printf("第%d次运行\\n", i)\r\n         time.Sleep(time.Second)\r\n      }\r\n   }()\r\n   goRoutineWait.Wait()\r\n   fmt.Println("程序运行结束")\r\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"这段代码依然会输出："}),"\n",(0,i.jsxs)(e.blockquote,{children:["\n",(0,i.jsx)(e.p,{children:"第 1 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 2 次运行"}),"\n",(0,i.jsx)(e.p,{children:"第 3 次运行"}),"\n",(0,i.jsx)(e.p,{children:"程序运行结束"}),"\n"]}),"\n",(0,i.jsxs)(e.p,{children:["细心的朋友会发现，在 testFunc() 函数体中，",(0,i.jsx)(e.strong,{children:"使用 defer 执行 goRoutineWait.Done()。如此是为了保证即使在执行函数体时发生错误，goRoutineWait.Done() 方法也依然会被调用，从而保证main() 函数的正常运行。"})," 在某种角度上说，这是一种“舍车保帅”的做法。这一点在使用并发时同样需要注意。"]}),"\n",(0,i.jsx)(e.p,{children:"作为“初探”，本讲内容就先介绍到这里，是不是感觉在 Go 语言中调度任务非常简单呢？"}),"\n",(0,i.jsxs)(e.h2,{id:"小结",children:["小结",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,i.jsx)(e.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,i.jsxs)(e.p,{children:["1.基本概念；",(0,i.jsx)(e.br,{}),"\n","2.并发任务的启动；",(0,i.jsx)(e.br,{}),"\n","3.使用并发的注意事项。"]}),"\n",(0,i.jsx)(e.p,{children:"本讲首先回顾了四个易混淆的概念，包括并发、并行、协程、线程。简单地说，并发和并行都和执行多任务有关，前者采用切换 CPU 时间片的形式，后者利用多核心 CPU 的形式，二者各有优势。协程是轻量级的线程，协程是用户层面的，线程是操作系统层面的。一个线程可以承载多个协程任务。"}),"\n",(0,i.jsx)(e.p,{children:"使用 Go 语言开启 Goroutine（即协程任务）非常简单，只需在语句前添加 “go ” 即可。同时，为了确保协程任务执行的完整性，可使用 sync.WaitGroup，在某个需要等待地方等候协程任务的完成。此外，执行协程任务时，最好采用断言（defer）来调用goRoutineWait.Done() 方法，确保协程任务的错误不会影响到整个线程的正常运行。"}),"\n",(0,i.jsx)(e.p,{children:"➡️ 在下次课程中，我们会介绍如下内容："}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Go 语言中高并发原理解密——GPM模型"}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}let o=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC25%E7%AB%A0%E2%80%94%E5%B9%B6%E5%8F%91%E4%B8%80%EF%BD%9CGo%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E5%88%9D%E6%8E%A2.md"]={toc:[{text:"基本概念",id:"基本概念",depth:2},{text:"并发与并行",id:"并发与并行",depth:3},{text:"协程与线程",id:"协程与线程",depth:3},{text:"并发任务的启动",id:"并发任务的启动",depth:2},{text:"小结",id:"小结",depth:2}],title:"第25章—并发一｜Go语言并发初探",headingTitle:"第25章—并发一｜Go语言并发初探",frontmatter:{}}}}]);