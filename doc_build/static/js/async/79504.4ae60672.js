"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["79504"],{451804:function(e,n,i){i.r(n),i.d(n,{default:()=>b});var o=i(552676),r=i(740453);let s=i.p+"static/image/72f947af3171fc0bd786d7f087a0f72f.9e7d3ee7.png",t=i.p+"static/image/acd3dc243b285f43628eeec1826c27be.2addf09d.png",c=i.p+"static/image/1427b1ca3786ac48e0b5f271a298f53d.3efd6b8c.png",a=i.p+"static/image/049e63ea7403dfb15b7786842dc914e2.0f70abb6.png",p=i.p+"static/image/767ec78f32ae4b9c6edc59b29c87d4f4.23719c32.png",m=i.p+"static/image/b8d691b441f1005ae4479990ec3c355d.0b33449d.png",l=i.p+"static/image/ccfae58c99e6ed4f40cc2d41eb36dde5.7a0787f8.png",h=i.p+"static/image/16e0e9a259f38b1471b8b484441cf0e4.00f8942b.png",d=i.p+"static/image/0dca44b09ac719dbcc86c195cbb92e5d.aafbd2d8.png",j=i.p+"static/image/9ab553f3ee8e454f6180398742ff41bb.ad1f8d15.png",x=i.p+"static/image/09f508d9bf87a1e4ab18c9e63db94916.f78b3c07.png",g=i.p+"static/image/e80dc9784968e23eea54fd40a9f8ea6e.74c0c2c1.png",f=i.p+"static/image/09a16366c8bcd6a5732cd68e928960ae.ebd756f1.png";function k(e){let n=Object.assign({p:"p",blockquote:"blockquote",strong:"strong",img:"img",pre:"pre",code:"code",a:"a",h2:"h2",ul:"ul",li:"li"},(0,r.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"在之前的课程中，我们重点讲解了 iframe、NPM、动态 Script 以及 Web Components 方案的微应用集成方式，本课程以 iframe 方案为例，重点讲解 iframe 中的 Cookie 数据在跨域和跨站中的表现情况，从而指导大家更加深入的了解微前端 iframe 中的 Cookie 处理。"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"温馨提示：本课程不会讲解如何实现微应用的 SSO 免登和 CSRF 防御等处理，只提供解决上述问题所需要的最基础的浏览器和服务端知识。感兴趣的同学需要自行了解实现主子应用免登的方案。"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["在",(0,o.jsx)(n.strong,{children:"方案了解：iframe 方案"}),"中，我们重点讲解了跨站和跨域的区别，在使用 iframe 进行主子应用集成时，很可能存在如下几种情况，接下来我们重点观察这些情况在浏览器中的 Cookie 表现："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"温馨提示：在微前端方案的设计中，如果没有纯三方应用的集成，大多数 iframe 应用可以设计成和主应用同域的业务场景，从而简化设计方案。出于安全考虑，浏览器中的 LocalStorage 在跨域情况下无法共享，但是面试官可能会给你挖个坑，询问 Cookie 在跨域情况下是否可以共享？阅读本课程可以很好的解答该问题。"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"iframe 测试 Cookie 的目录结构如下所示："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"├── same-origin/                 # 主子应用同域\n├── same-site/                   # 主子应用跨域同站\n├── cross-site/                  # 主子应用跨站\n├── public/                      # 前端静态页面\n├── config/                      # 服务端配置：端口、IP 等\n└── package.json    \n"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,o.jsx)(n.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/iframe-cookie",target:"_blank",rel:"noopener noreferrer",children:"demo/iframe-cookie"})," 分支获取。"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"public"})," 目录主要存放 Web 前端的静态页面，如下所示："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-html",children:'\x3c!-- 主应用 HTML：main.html --\x3e\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>主应用</title>\n  </head>\n  <body>\n    <h1>主应用</h1>\n    <button onclick="handleConsoleCookie()">主应用 - 打印 cookie</button>\n    <button onclick="handleLoadIframe()">加载 iframe 微应用</button>\n    <br />\n    <br />\n  </body>\n\n  <script>\n    function handleConsoleCookie() {\n      console.log("[主应用 - 打印 cookie]: ", document.cookie);\n    }\n\n    function handleLoadIframe() {\n      const iframe = document.createElement(\'iframe\');\n      // ejs 模版 micro 变量填充: 指向微应用的打开地址\n      iframe.src = "<%= micro %>";\n      document.body.appendChild(iframe);\n    }\n  <\/script>\n</html>\n\n\n\x3c!-- 微应用 HTML：micro.html --\x3e\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>iframe 微应用</title>\n  </head>\n  <body>\n    <h1>iframe 微应用</h1>\n    <button onclick="handleConsoleCookie()">微应用 - 打印 cookie</button>\n  </body>\n\n  <script>\n    function handleConsoleCookie() {\n      console.log("[微应用 - 打印 cookie] micro-app cookie: ", document.cookie);\n    }\n  <\/script>\n</html>\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"config.js"})," 是服务端所有示例的公共配置项，如下所示："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// config.js\n// https://github.com/indutny/node-ip\nimport ip from \'ip\';\nimport path from "path";\nimport { fileURLToPath } from "url";\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport default {\n  port: {\n    main: 4000,\n    micro: 3000,\n  },\n\n  // 获取本机的 IP 地址\n  host: ip.address(),\n\n  __dirname\n};\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"package.json"})," 中设置了各个示例启动服务的脚本："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'  "scripts": {\n    // 启动同域服务\n    "same-origin": "node same-origin/main-server.js",\n    // 启动跨域同站的两个服务(注意 & 和 && 的区别)\n    "same-site": "node same-site/main-server.js & node same-site/micro-server.js",\n    // 启动跨站的两个服务\n    "cross-site": "node cross-site/main-server.js & node cross-site/micro-server.js"\n  },\n'})}),"\n",(0,o.jsxs)(n.h2,{id:"主子应用同域",children:["主子应用同域",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主子应用同域",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"首先设计一个同域的微前端方案，查看同域情况下主应用和 iframe 微应用的 Cookie 表现，服务端设计如下所示："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// same-origin/main-server.js\nimport path from "path";\n// express：https://github.com/expressjs/express\nimport express from "express";\n// ejs 中文网站: https://ejs.bootcss.com/#promo\n// ejs express 示例: https://github.com/expressjs/express/blob/master/examples/ejs/index.js\nimport ejs from "ejs";\n\nimport config from "../config.js";\nconst { port, host, __dirname } = config;\nconst app = express();\n\napp.engine(".html", ejs.__express);\napp.set("views", path.join(__dirname, "public"));\napp.set("view engine", "html");\n\napp.get("/", function (req, res) {\n  // 设置主应用的 cookie 标识\n  res.cookie("main-app", "true");\n  // 使用 ejs 模版引擎填充主应用 public/main.html 中的 micro 变量，并将其渲染到浏览器\n  res.render("main", {\n    // micro 指向微应用的打开地址\n    micro: `http://${host}:${port.main}/micro`,\n  });\n});\n\n// 微应用和主应用同域，只是服务路由不同\napp.get("/micro", function (req, res) {\n  // 设置 iframe 微应用的 cookie 标识，顺便观察能否覆盖主应用的 cookie 标识\n  res.cookie("micro-app", "true").cookie("main-app", "false");\n  // 渲染 views/micro.html\n  res.render("micro");\n});\n\n// 启动 Node 服务\napp.listen(port.main, host);\nconsole.log(`server start at http://${host}:${port.main}/`);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["使用 ",(0,o.jsx)(n.code,{children:"npm run same-origin"})," 启动服务后，可以操作按钮来打印 Cookie 信息，如下所示："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:g,alt:""})}),"\n",(0,o.jsxs)(n.p,{children:["从上图可以发现，一开始只加载主应用的 HTML 时打印 ",(0,o.jsx)(n.code,{children:"main-app=true"}),"，动态加载 iframe 微应用后由于微应用将 ",(0,o.jsx)(n.code,{children:"main-app"})," 设置为 ",(0,o.jsx)(n.code,{children:"false"}),"，发现主应用同名属性的 Cookie 值被覆盖。因此在同域的方案下，主子应用可以共享 Cookie 数据，但是存在同名属性值被覆盖的风险。"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"温馨提示：主子应用同域可以通过共享 Cookie 来解决登录态的问题，是非常常用的一种微前端方案。"}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"主子应用跨域同站",children:["主子应用跨域同站",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主子应用跨域同站",children:"#"})]}),"\n",(0,o.jsxs)(n.p,{children:["在 iframe 方案中，我们已经讲解了同站的条件，两个应用的 eTLD + 1 相同则是同站。这里可以设计两个应用地址分别为 ",(0,o.jsx)(n.code,{children:"http://ziyi.example.com"})," 和 ",(0,o.jsx)(n.code,{children:"http://example.com"}),"，其中 ",(0,o.jsx)(n.code,{children:"com"})," 是一个有效顶级域名，因此 eTLD + 1 相同。为了模拟上述域名地址，可以使用 ",(0,o.jsx)(n.a,{href:"https://github.com/toolinbox/iHosts",target:"_blank",rel:"noopener noreferrer",children:"iHosts"})," 进行域名映射，主要实现如下功能："]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["在主应用中使用 iHosts 进行域名映射，将 ",(0,o.jsx)(n.code,{children:"example.com"})," 映射到本地 IP 地址"]}),"\n",(0,o.jsxs)(n.li,{children:["在子应用中使用 iHosts 进行域名映射，将 ",(0,o.jsx)(n.code,{children:"ziyi.example.com"})," 映射到本地 IP 地址"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:x,alt:""})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"温馨提示：iHosts 工具本质上是更改了本地系统的 hosts 文件，从而起到域名和 IP 的匹配映射。这里可以额外了解本地 hosts 匹配和 DNS 服务解析的差异。"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"在 iHosts 中同一个 IP 地址可以指向不同的域名，配置如下所示："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:j,alt:""})}),"\n",(0,o.jsx)(n.p,{children:"服务代码如下所示："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// same-site/main-server.js\n// 主应用服务代码\nimport path from "path";\nimport express from "express";\nimport ejs from "ejs";\n\nimport config from "../config.js";\nconst { port, host, __dirname } = config;\nconst app = express();\n\napp.engine(".html", ejs.__express);\napp.set("views", path.join(__dirname, "public"));\napp.set("view engine", "html");\n\n// 使用 iHosts 配置 example.com 指向本机的 ip 地址\n// 主应用访问地址：http://example.com:4000\napp.get("/", function (req, res) {\n  res.cookie("main-app", "true");\n  // 为了使同站的微应用可以共享主应用的 Cookie\n  // 在设置 Cookie 时，可以使用 Domain 和 Path 来标记作用域\n  // 默认不指定的情况下，Domain 属性为当前应用的 host，由于 ziyi.example.com 和 example.com 不同\n  // 因此默认情况下两者不能共享 Cookie，可以通过设置 Domain 使其为子域设置 Cookie，例如 Domain=example.com，则 Cookie 也包含在子域 ziyi.example.com 中\n  res.cookie("main-app-share", "true", { domain: "example.com" });\n  res.render("main", {\n    // 使用 iHosts 配置 ziyi.example.com 指向本机的 ip 地址\n    // 子应用访问地址： http://ziyi.example.com:3000\n    micro: `http://ziyi.example.com:${port.micro}` \n  });\n});\n\n// 启动 Node 服务\napp.listen(port.main, host);\nconsole.log(`main app start at http://${host}:${port.main}/`);\n\n// same-site/micro-server.js\n// 微应用服务代码\nimport path from "path";\nimport express from "express";\nimport ejs from "ejs";\nimport config from "../config.js";\n\nconst { host, port, __dirname } = config;\nconst app = express();\n\napp.engine(".html", ejs.__express);\napp.set("views", path.join(__dirname, "public"));\napp.set("view engine", "html");\n\n// 浏览器访问 http://${host}:${port.micro}/ 时会渲染 public/micro.html\n// 端口不同，主应用和微应用跨域但是不跨站\napp.get("/", function (req, res) {\n  // 设置 iframe 微应用的 cookie 标识，顺便观察能否覆盖主应用的 cookie 标识\n  res.cookie("micro-app", "true").cookie("main-app", "false");\n  res.render("micro");\n});\n\n// 启动 Node 服务\napp.listen(port.micro, host);\nconsole.log(`server start at http://${host}:${port.micro}/`);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["使用 ",(0,o.jsx)(n.code,{children:"npm run same-site"})," 可以同时启动主应用和子应用的服务，操作按钮来打印 Cookie 信息，如下所示："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:d,alt:""})}),"\n",(0,o.jsxs)(n.p,{children:["从上图可以发现，在 host 不同的情况下，主应用的 ",(0,o.jsx)(n.code,{children:"main-app"})," 字段不会被子应用进行覆盖，主应用和子应用无法共享 Cookie。但是如果主应用和子应用同站，那么可以通过设置 Domain 使得两个应用可以共享彼此的 Cookie，例如上图中的 ",(0,o.jsx)(n.code,{children:"main-app-share"})," 字段，通过设置 Domain 为 ",(0,o.jsx)(n.code,{children:"example.com"})," 后可以被子应用进行共享。因此在同站的某些特殊情况下，Cookie 是可以在不同的应用中产生共享的。"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"温馨提示：如果两个应用同站，那么在哪些情况下尽管设置了 Domain 仍然无法共享 Cookie 呢？"}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"主子应用跨站",children:["主子应用跨站",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主子应用跨站",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"跨站的实现方式也非常简单，只需要更改原有的 iHosts 配置即可，如下所示："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:h,alt:""})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["在主应用中使用 iHosts 进行域名映射，将 ",(0,o.jsx)(n.code,{children:"ziyi.com"})," 映射到本地 IP 地址"]}),"\n",(0,o.jsxs)(n.li,{children:["在子应用中使用 iHosts 进行域名映射，将 ",(0,o.jsx)(n.code,{children:"ziyi.example.com"})," 映射到本地 IP 地址"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:l,alt:""})}),"\n",(0,o.jsxs)(n.p,{children:["此时主子应用因为 eTLD + 1 不同形成跨站（",(0,o.jsx)(n.code,{children:"com"})," 是一个有效顶级域名），由于 iHosts 映射的 IP 地址不变，因此不需要将将主子应用的 Node 服务断开，重新在浏览器中通过 ",(0,o.jsx)(n.code,{children:"ziyi.com:4000"})," 进行访问，如下所示："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:m,alt:""})}),"\n",(0,o.jsx)(n.p,{children:"从上述浏览器的测试信息可以看出："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["在主应用中设置的 ",(0,o.jsx)(n.code,{children:"main-app-share"})," Cookie 值失效，因为主应用不在 ",(0,o.jsx)(n.code,{children:"example.com"})," 下"]}),"\n",(0,o.jsxs)(n.li,{children:["在子应用中设置的 ",(0,o.jsx)(n.code,{children:"micro-app"})," 和 ",(0,o.jsx)(n.code,{children:"main-app"})," 的 Cookie 值失效"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"从打印的信息可以发现子应用在跨站的情况下无法设置 Cookie，重点可以查看一下 iframe 微应用 Cookie 设置失效的原因："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:p,alt:""})}),"\n",(0,o.jsxs)(n.p,{children:["从警告信息可以看出，如果主应用和内部的 iframe 子应用（非顶级浏览上下文）跨站，那么 iframe 应用的 Cookie 设置会被阻止。查看 ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite",target:"_blank",rel:"noopener noreferrer",children:"SameSite cookies"})," 发现 Chrome 浏览器 80 版本将 SameSite 的默认值设置为 Lax，用于解决 iframe 应用产生 CSRF 跨站请求伪造的安全问题（防止跨站携带 Cookie）。此时解决方案是将 SameSite 设置为 None 并使用 Secure 属性（必须使用 HTTPS 协议）。为了实现 HTTPS 协议，这里采用 ",(0,o.jsx)(n.a,{href:"https://github.com/bubenshchykov/ngrok#readme",target:"_blank",rel:"noopener noreferrer",children:"Ngrok"})," 进行反向代理，如下所示："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:a,alt:""})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"在主应用中使用 Ngrok 进行反向代理，建立 HTTPS 连接"}),"\n",(0,o.jsx)(n.li,{children:"在子应用中使用 Ngrok 进行反向代理，建立 HTTPS 连接，形成主子应用跨站"}),"\n"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["温馨提示：通过查看 ",(0,o.jsx)(n.a,{href:"https://publicsuffix.org/list/public_suffix_list.dat",target:"_blank",rel:"noopener noreferrer",children:"publicsuffix/list"})," 可以发现 ngrok-free.app 是顶级有效域名，因此上述主应用和子应用跨站。"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"警告 ⚠️"}),"：这里为了建立 HTTPS 连接使用了 Ngrok 进行反向代理，但是这种方式切忌在公司内网尝试，本质上会将本地的网络暴露到公网进行内网穿透，存在安全风险。如果你是在公司内部网络，那么可以尝试下一个课程 Web Components 持久化示例中的 Nginx 配置方案建立 HTTPS 连接。课程中使用 Ngrok 是为了提供大家一种创建 HTTPS 连接的简单示例。"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"为了实现上述功能，可以借助 Node 的 Ngrok 客户端建立反向代理，修改服务代码："}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'// cross-site/main-server.js\n// 主应用服务代码\nimport path from "path";\nimport express from "express";\nimport ngrok from "ngrok";\nimport ejs from "ejs";\n\nimport config from "../config.js";\nconst { port, host, authtoken, __dirname } = config;\nconst app = express();\n\n// 内网穿透（主应用反向代理）\n// ngrok: https://github.com/bubenshchykov/ngrok#readme\n// authtoken 需要进行免费注册获取：https://github.com/bubenshchykov/ngrok#auth-token\n// 本课程通过 ngrok 全局 CLI 设置了 authtoken，因此不需要传递 authtoken 参数\n// https://ngrok.com/docs/getting-started/#step-3-connect-your-agent-to-your-ngrok-account\n// ngrok config add-authtoken TOKEN\nconst main = await ngrok.connect({\n  proto: "http",\n  // authtoken,\n  addr: `http://${host}:${port.main}`,\n  // 使用 https 协议\n  bind_tls: true,\n});\n\nconsole.log("main app ngrok url: ", main);\n\n// 内网穿透（微应用反向代理）\nconst micro = await ngrok.connect({\n  proto: "http",\n  // authtoken,\n  addr: `http://${host}:${port.micro}`,\n  bind_tls: true,\n});\n\nconsole.log("micro app ngrok url: ", micro);\n\napp.engine(".html", ejs.__express);\napp.set("views", path.join(__dirname, "public"));\napp.set("view engine", "html");\n\napp.get("/", function (req, res) {\n  res.cookie("main-app", "true");\n  res.render("main", {\n    micro,\n  });\n});\n\n// 启动 Node 服务\napp.listen(port.main, host);\nconsole.log(`server start at http://${host}:${port.main}/`);\n\n// cross-site/micro-server.js\n// 微应用服务代码\nimport path from "path";\nimport express from "express";\nimport ejs from "ejs";\nimport config from "../config.js";\n\nconst { host, port, __dirname } = config;\nconst app = express();\n\napp.engine(".html", ejs.__express);\napp.set("views", path.join(__dirname, "public"));\napp.set("view engine", "html");\n\napp.get("/", function (req, res) {\n  // 增加 SameSite 和 Secure 属性，从而使浏览器支持 iframe 子应用的跨站携带 Cookie\n  // 注意 Secure 需要 HTTPS 协议的支持\n  const cookieOptions = { sameSite: "none", secure: true };\n  res\n    .cookie("micro-app", "true", cookieOptions)\n    // 设置 iframe 微应用的 cookie 标识，顺便观察能否覆盖主应用的 cookie 标识\n    .cookie("main-app", "false", cookieOptions);\n  res.render("micro");\n});\n\n// 启动 Node 服务\napp.listen(port.micro, host);\nconsole.log(`server start at http://${host}:${port.micro}/`);\n'})}),"\n",(0,o.jsxs)(n.p,{children:["使用 ",(0,o.jsx)(n.code,{children:"npm run cross-site"})," 可以同时启动主应用和子应用的服务，如下所示："]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# 8.方案了解：iframe Cookie\nnpm run cross-site\n\n# 打印\n> micro-framework@1.0.0 cross-site\n> node cross-site/main-server.js & node cross-site/micro-server.js\n\nserver start at http://30.120.112.54:3000/\nmain app ngrok url:  https://3c88-42-120-103-150.ngrok-free.app\nmicro app ngrok url:  https://64f6-42-120-103-150.ngrok-free.app\nserver start at http://30.120.112.54:4000/\n"})}),"\n",(0,o.jsx)(n.p,{children:"默认情况下打开 Ngrok 代理地址会产生警告信息，这些信息会提示你切忌使用敏感数据："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:c,alt:""})}),"\n",(0,o.jsxs)(n.p,{children:["为了去除警告页从而直接访问本地应用，需要在请求时加上请求头 ",(0,o.jsx)(n.code,{children:"ngrok-skip-browser-warning"}),"，可以使用 Chrome 的 ",(0,o.jsx)(n.a,{href:"https://chrome.google.com/webstore/detail/header-editor/eningockdidmgiojffjmkdblpjocbhgh?hl=zh-CN",target:"_blank",rel:"noopener noreferrer",children:" Header Editor "}),"插件进行设置，如下所示："]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:t,alt:""})}),"\n",(0,o.jsx)(n.p,{children:"打开应用后，可以进行 iframe 子应用跨站携带 Cookie 测试，如下所示："}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)("img",{src:s,alt:""})}),"\n",(0,o.jsx)(n.p,{children:"通过该示例可以得出两个结论："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"采用 iframe 进行微前端设计时，Chrome 浏览器中主子应用跨站的情况下，默认 iframe 子应用无法携带 Cookie，需要使用 HTTPS 协议和并设置服务端 Cookie 属性 SameSite 和 Secure 才行"}),"\n",(0,o.jsx)(n.li,{children:"跨站的情况下，主子应用无法进行 Cookie 共享"}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"小结",children:["小结",(0,o.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,o.jsx)(n.p,{children:"在 iframe 微前端方案的示例测试中，我们可以发现："}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"主子应用同域：可以携带和共享 Cookie，存在同名属性值被微应用覆盖的风险"}),"\n",(0,o.jsx)(n.li,{children:"主子应用跨域同站：默认主子应用无法共享 Cookie，可以通过设置 Domain 使得主子应用进行 Cookie 共享"}),"\n",(0,o.jsx)(n.li,{children:"主子应用跨站：子应用默认无法携带 Cookie（防止 CSRF 攻击），需要使用 HTTPS 协议并设置服务端 Cookie 的 SameSite 和 Secure 设置才行，并且子应用无法和主应用形成 Cookie 共享"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"了解上述几种 Cookie 的携带情况可以帮助我们更好的进行微前端业务方案的设计，Cookie 是 SSO 免登设计中非常重要的凭证数据。"})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(k,{...e})}):k(e)}let b=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F8.%E6%96%B9%E6%A1%88%E4%BA%86%E8%A7%A3%EF%BC%9Aiframe%20Cookie.md"]={toc:[{text:"主子应用同域",id:"主子应用同域",depth:2},{text:"主子应用跨域同站",id:"主子应用跨域同站",depth:2},{text:"主子应用跨站",id:"主子应用跨站",depth:2},{text:"小结",id:"小结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);