"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["51445"],{51487:function(e,n,s){s.r(n),s.d(n,{default:()=>h});var r=s(552676),c=s(740453);let d=s.p+"static/image/91bfcc28ee93f890c8921ecc8740c12d.dddff116.webp",l=s.p+"static/image/56dae9a831a42e18b5ca5304883a9535.1f1d68fc.webp",i=s.p+"static/image/27248d9413d7383495379e0e67e21e20.76ee413c.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",code:"code",pre:"pre",blockquote:"blockquote",img:"img",ol:"ol"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"7使用-webpack-构建-npm-library-的正确方式",children:["7.使用 Webpack 构建 NPM Library 的正确方式",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7使用-webpack-构建-npm-library-的正确方式",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"虽然 Webpack 多数情况下被用于构建 Web 应用，但与 Rollup、Snowpack 等工具类似，Webpack 同样具有完备的构建 NPM 库的能力。与一般场景相比，构建 NPM 库时需要注意："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"正确导出模块内容；"}),"\n",(0,r.jsx)(n.li,{children:"不要将第三方包打包进产物中，以免与业务方环境发生冲突；"}),"\n",(0,r.jsx)(n.li,{children:"将 CSS 抽离为独立文件，以方便用户自行决定实际用法；"}),"\n",(0,r.jsx)(n.li,{children:"始终生成 Sourcemap 文件，方便用户调试。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"本文将从最基础的 NPM 库构建需求开始，逐步叠加上述特性，最终搭建出一套能满足多数应用场景、功能完备的 NPM 库构建环境。"}),"\n",(0,r.jsxs)(n.h2,{id:"开发一个-npm-库",children:["开发一个 NPM 库",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#开发一个-npm-库",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["为方便讲解，假定我们正在开发一个全新的 NPM 库，暂且叫它 ",(0,r.jsx)(n.code,{children:"test-lib"})," 吧，首先需要创建并初始化项目："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"mkdir test-lib && cd test-lib\nnpm init -y\n"})}),"\n",(0,r.jsx)(n.p,{children:"虽然有很多构建工具能够满足 NPM 库的开发需求，但现在暂且选择 Webpack，所以需要先装好基础依赖："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"yarn add -D webpack webpack-cli\n"})}),"\n",(0,r.jsx)(n.p,{children:"接下来，可以开始写一些代码了，首先创建代码文件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"mkdir src\ntouch src/index.js\n"})}),"\n",(0,r.jsxs)(n.p,{children:["之后，在 ",(0,r.jsx)(n.code,{children:"test-lib/src/index.js"})," 文件中随便实现一些功能，比如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// test-lib/src/index.js\nexport const add = (a, b) => a + b\n"})}),"\n",(0,r.jsx)(n.p,{children:"至此，项目搭建完毕，目录如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"├─ test-lib\n│  ├─ package.json\n│  ├─ src\n│  │  ├─ index.js\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["提示：本文代码均已上传到 ",(0,r.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/tree/main/6-1_test-lib",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"使用-webpack-构建-npm-库",children:["使用 Webpack 构建 NPM 库",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-webpack-构建-npm-库",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["接下来，我们需要将上例 ",(0,r.jsx)(n.code,{children:"test-lib"})," 构建为适合分发的产物形态。虽然 NPM 库与普通 Web 应用在形态上有些区别，但大体的编译需求趋同，因此可以复用前面章节介绍过的大多数知识点。例如 ",(0,r.jsx)(n.code,{children:"test-lib"})," 所需要的基础编译配置如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// webpack.config.js\nconst path = require("path");\n\nmodule.exports = {\n  mode: "development",\n  entry: "./src/index.js",\n  output: {\n    filename: "[name].js",\n    path: path.join(__dirname, "./dist"),\n  }\n};\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["提示：我们还可以在上例基础上叠加任意 Loader、Plugin，例如： ",(0,r.jsx)(n.code,{children:"babel-loader"}),"、",(0,r.jsx)(n.code,{children:"eslint-loader"}),"、",(0,r.jsx)(n.code,{children:"ts-loader"})," 等。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["上述配置会将代码编译成一个 IIFE 函数，但这并不适用于 NPM 库，我们需要修改 ",(0,r.jsx)(n.code,{children:"output.library"})," 配置，以适当方式导出模块内容："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  // ...\n  output: {\n    filename: "[name].js",\n    path: path.join(__dirname, "./dist"),\n+   library: {\n+     name: "_",\n+     type: "umd",\n+   },\n  },\n  // ...\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"这里用到了两个新配置项："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputlibraryname",target:"_blank",rel:"noopener noreferrer",children:"output.library.name"}),"：用于定义模块名称，在浏览器环境下使用 ",(0,r.jsx)(n.code,{children:"script"})," 加载该库时，可直接使用这个名字调用模块，例如："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'<!DOCTYPE html>\n<html lang="en">\n...\n<body>\n    <script src="https://examples.com/dist/main.js"><\/script>\n    <script>\n        // Webpack 会将模块直接挂载到全局对象上\n        window._.add(1, 2)\n    <\/script>\n</body>\n\n</html>\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#outputlibrarytype",target:"_blank",rel:"noopener noreferrer",children:"output.library.type"}),"：用于编译产物的模块化方案，可选值有：",(0,r.jsx)(n.code,{children:"commonjs"}),"、",(0,r.jsx)(n.code,{children:"umd"}),"、",(0,r.jsx)(n.code,{children:"module"}),"、",(0,r.jsx)(n.code,{children:"jsonp"})," 等，通常选用兼容性更强的 ",(0,r.jsx)(n.code,{children:"umd"})," 方案即可。"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"提示：JavaScript 最开始并没有模块化方案，这就导致早期 Web 开发需要将许多代码写进同一文件，极度影响开发效率。后来，随着 Web 应用复杂度逐步增高，社区陆陆续续推出了许多适用于不同场景的模块化规范，包括：CommonJS、UMD、CMD、AMD，以及 ES6 推出的 ES Module 方案，不同方案各有侧重点与适用场景，NPM 库作者需要根据预期的使用场景选择适当方案。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"修改前后对应的产物内容如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到，修改前(对应上图左半部分)代码会被包装成一个 IIFE ；而使用 ",(0,r.jsx)(n.code,{children:"output.library"})," 后，代码被包装成 UMD(Universal Module Definition) 模式："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"(function webpackUniversalModuleDefinition(root, factory) {\n    if(typeof exports === 'object' && typeof module === 'object')\n        module.exports = factory();\n    else if(typeof define === 'function' && define.amd)\n        define([], factory);\n    else if(typeof exports === 'object')\n        exports[\"_\"] = factory();\n    else\n        root[\"_\"] = factory();\n})(self, function() {\n // ...\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这种形态会在 NPM 库启动时判断运行环境，自动选择当前适用的模块化方案，此后我们就能在各种场景下使用 ",(0,r.jsx)(n.code,{children:"test-lib"})," 库，例如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// ES Module\nimport {add} from 'test-lib';\n\n// CommonJS\nconst {add} = require('test-lib');\n\n// HTML\n<script src=\"https://examples.com/dist/main.js\"><\/script>\n<script>\n    // Webpack 会将模块直接挂载到全局对象上\n    window._.add(1, 2)\n<\/script>\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"正确使用第三方包",children:["正确使用第三方包",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正确使用第三方包",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["接下来，假设我们需要在 ",(0,r.jsx)(n.code,{children:"test-lib"})," 中使用其它 NPM 包，例如 ",(0,r.jsx)(n.code,{children:"lodash"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// src/index.js\nimport _ from "lodash";\n\nexport const add = (a, b) => a + b;\n\nexport const max = _.max;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["此时执行编译命令 ",(0,r.jsx)(n.code,{children:"npx webpack"}),"，我们会发现产物文件的体积非常大："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["这是因为 Webpack 默认会将所有第三方依赖都打包进产物中，这种逻辑能满足 Web 应用资源合并需求，但在开发 NPM 库时则很可能导致代码冗余。以 ",(0,r.jsx)(n.code,{children:"test-lib"})," 为例，若使用者在业务项目中已经安装并使用了 ",(0,r.jsx)(n.code,{children:"lodash"}),"，那么最终产物必然会包含两份 ",(0,r.jsx)(n.code,{children:"lodash"})," 代码！"]}),"\n",(0,r.jsxs)(n.p,{children:["为解决这一问题，我们需要使用 ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/externals/",target:"_blank",rel:"noopener noreferrer",children:"externals"})," 配置项，将第三方依赖排除在打包系统之外："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// webpack.config.js\nmodule.exports = {\n  // ...\n+  externals: {\n+   lodash: {\n+     commonjs: "lodash",\n+     commonjs2: "lodash",\n+     amd: "lodash",\n+     root: "_",\n+   },\n+ },\n  // ...\n};\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["提示：\nWebpack 编译过程会跳过 ",(0,r.jsx)(n.a,{href:"https://webpack.js.org/configuration/externals/",target:"_blank",rel:"noopener noreferrer",children:"externals"})," 所声明的库，并假定消费场景已经安装了相关依赖，常用于 NPM 库开发场景；在 Web 应用场景下则常被用于优化性能。"]}),"\n",(0,r.jsxs)(n.p,{children:["例如，我们可以将 React 声明为外部依赖，并在页面中通过 ",(0,r.jsx)(n.code,{children:"<script>"})," 标签方式引入 React 库，之后 Webpack 就可以跳过 React 代码，提升编译性能。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["改造后，再次执行 ",(0,r.jsx)(n.code,{children:"npx webpack"}),"，编译结果如下："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"改造后，主要发生了两个变化："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["产物仅包含 ",(0,r.jsx)(n.code,{children:"test-lib"})," 库代码，体积相比修改前大幅降低；"]}),"\n",(0,r.jsxs)(n.li,{children:["UMD 模板通过 ",(0,r.jsx)(n.code,{children:"require"}),"、",(0,r.jsx)(n.code,{children:"define"})," 函数中引入 ",(0,r.jsx)(n.code,{children:"lodash"})," 依赖并传递到 ",(0,r.jsx)(n.code,{children:"factory"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["至此，Webpack 不再打包 ",(0,r.jsx)(n.code,{children:"lodash"})," 代码，我们可以顺手将 ",(0,r.jsx)(n.code,{children:"lodash"})," 声明为 ",(0,r.jsx)(n.code,{children:"peerDependencies"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "name": "6-1_test-lib",\n  // ...\n+ "peerDependencies": {\n+   "lodash": "^4.17.21"\n+ }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["实践中，多数第三方框架都可以沿用上例方式处理，包括 React、Vue、Angular、Axios、Lodash 等，方便起见，可以直接使用 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/webpack-node-externals",target:"_blank",rel:"noopener noreferrer",children:"webpack-node-externals"})," 排除所有 ",(0,r.jsx)(n.code,{children:"node_modules"})," 模块，使用方法："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nconst nodeExternals = require('webpack-node-externals');\n\nmodule.exports = {\n  // ...\n+  externals: [nodeExternals()]\n  // ...\n};\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"抽离-css-代码",children:["抽离 CSS 代码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#抽离-css-代码",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["假设我们开发的 NPM 库中包含了 CSS 代码 —— 这在组件库中特别常见，我们通常需要使用 ",(0,r.jsx)(n.code,{children:"mini-css-extract-plugin"})," 插件将样式抽离成单独文件，由用户自行引入。"]}),"\n",(0,r.jsxs)(n.p,{children:["这是因为 Webpack 处理 CSS 的方式有很多，例如使用 ",(0,r.jsx)(n.code,{children:"style-loader"})," 将样式注入页面的 ",(0,r.jsx)(n.code,{children:"<head>"})," 标签；使用 ",(0,r.jsx)(n.code,{children:"mini-css-extract-plugin"})," 抽离样式文件。作为 NPM 库开发者，如果我们粗暴地将 CSS 代码打包进产物中，有可能与用户设定的方式冲突。"]}),"\n",(0,r.jsx)(n.p,{children:"为此，需要在前文基础上添加如下配置："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'module.exports = {  \n  // ...\n+ module: {\n+   rules: [\n+     {\n+       test: /\\.css$/,\n+       use: [MiniCssExtractPlugin.loader, "css-loader"],\n+     },\n+   ],\n+ },\n+ plugins: [new MiniCssExtractPlugin()],\n};\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["提示：关于 CSS 构建的更多规则，可参考《",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7116186197730263054",target:"_blank",rel:"noopener noreferrer",children:"如何借助预处理器、PostCSS 等构建现代 CSS 工程环境？"}),"》章节。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"生成-sourcemap",children:["生成 Sourcemap",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#生成-sourcemap",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Sourcemap 是一种代码映射协议，它能够将经过压缩、混淆、合并的代码还原回未打包状态，帮助开发者在生产环境中精确定位问题发生的行列位置，所以一个成熟的 NPM 库除了提供兼容性足够好的编译包外，通常还需要提供 Sourcemap 文件。"}),"\n",(0,r.jsxs)(n.p,{children:["接入方法很简单，只需要添加适当的 ",(0,r.jsx)(n.code,{children:"devtool"})," 配置："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nmodule.exports = {  \n  // ...\n+ devtool: 'source-map'\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["再次执行 ",(0,r.jsx)(n.code,{children:"npx webpack"})," 就可以看到 ",(0,r.jsx)(n.code,{children:".map"})," 后缀的映射文件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-markdown",children:"├─ test-lib\n│  ├─ package.json\n│  ├─ webpack.config.js\n│  ├─ src\n│  │  ├─ index.css\n│  │  ├─ index.js\n│  ├─ dist\n│  │  ├─ main.js\n│  │  ├─ main.js.map\n│  │  ├─ main.css\n│  │  ├─ main.css.map\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此后，业务方只需使用 ",(0,r.jsx)(n.code,{children:"source-map-loader"})," 就可以将这段 Sourcemap 信息加载到自己的业务系统中，实现框架级别的源码调试能力。关于 Sourcemap 的更多信息，可查阅："]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["提示：示例代码已上传到 ",(0,r.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/tree/main/6-2_use-test-lib",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"其它-npm-配置",children:["其它 NPM 配置",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其它-npm-配置",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["至此，开发 NPM 库所需的 Webpack 配置就算是介绍完毕了，接下来我们还可以用一些小技巧优化 ",(0,r.jsx)(n.code,{children:"test-lib"})," 的项目配置，提升开发效率，包括："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["使用 ",(0,r.jsx)(n.code,{children:".npmignore"})," 文件忽略不需要发布到 NPM 的文件；"]}),"\n",(0,r.jsxs)(n.li,{children:["在 ",(0,r.jsx)(n.code,{children:"package.json"})," 文件中，使用 ",(0,r.jsx)(n.code,{children:"prepublishOnly"})," 指令，在发布前自动执行编译命令，例如："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'// package.json\n{\n  "name": "test-lib",\n  // ...\n  "scripts": {\n    "prepublishOnly": "webpack --mode=production"\n  },\n  // ...\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["在 ",(0,r.jsx)(n.code,{children:"package.json"})," 文件中，使用 ",(0,r.jsx)(n.code,{children:"main"})," 指定项目入口，同时使用 ",(0,r.jsx)(n.code,{children:"module"})," 指定 ES Module 模式下的入口，以允许用户直接使用源码版本，例如："]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "name": "6-1_test-lib",\n  // ...\n  "main": "dist/main.js",\n  "module": "src/index.js",\n  "scripts": {\n    "prepublishOnly": "webpack --mode=production"\n  },\n  // ...\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"这部分内容与小册主题无关，这里只做简单介绍，感兴趣的同学可自行搜索相关资料。"}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"站在 Webpack 角度，构建 Web 应用于构建 NPM 库的差异并不大，开发时注意："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["使用 ",(0,r.jsx)(n.code,{children:"output.library"})," 配置项，正确导出模块内容；"]}),"\n",(0,r.jsxs)(n.li,{children:["使用 ",(0,r.jsx)(n.code,{children:"externals"})," 配置项，忽略第三方库；"]}),"\n",(0,r.jsxs)(n.li,{children:["使用 ",(0,r.jsx)(n.code,{children:"mini-css-extract-plugin"})," 单独打包 CSS 样式代码；"]}),"\n",(0,r.jsxs)(n.li,{children:["使用 ",(0,r.jsx)(n.code,{children:"devtool"})," 配置项生成 Sourcemap 文件，这里推荐使用 ",(0,r.jsx)(n.code,{children:"devtool = 'source-map'"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["遵循上述规则，基本上就能满足开发一个 NPM 库所需的大部分需求。另外，文章代码均已上传到 ",(0,r.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/tree/main/6-1_test-lib",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"，建议大家 Clone 阅读。"]}),"\n",(0,r.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"有许多工具能被构建 NPM 库，例如 Webpack、Snowpack、Vite、Rollup 等，这些工具各有什么特点？你更倾向于使用哪种工具？"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let h=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F7.%E4%BD%BF%E7%94%A8%20Webpack%20%E6%9E%84%E5%BB%BA%20NPM%20Library%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F.md"]={toc:[{text:"开发一个 NPM 库",id:"开发一个-npm-库",depth:2},{text:"使用 Webpack 构建 NPM 库",id:"使用-webpack-构建-npm-库",depth:2},{text:"正确使用第三方包",id:"正确使用第三方包",depth:2},{text:"抽离 CSS 代码",id:"抽离-css-代码",depth:2},{text:"生成 Sourcemap",id:"生成-sourcemap",depth:2},{text:"其它 NPM 配置",id:"其它-npm-配置",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"7.使用 Webpack 构建 NPM Library 的正确方式",headingTitle:"7.使用 Webpack 构建 NPM Library 的正确方式",frontmatter:{}}}}]);