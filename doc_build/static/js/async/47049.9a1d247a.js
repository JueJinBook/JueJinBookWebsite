"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["47049"],{471980:function(n,e,t){n.exports=t.p+"static/image/76b01480388835de0da694a1a2bb5b1a.54dd3dc3.png"},224096:function(n,e,t){t.r(e),t.d(e,{default:()=>m});var r=t(552676),s=t(740453);let o=t.p+"static/image/cc0493d2d2aa8b4c60db823623f133c7.122b968a.png",i=t.p+"static/image/2f823c906ddda09ab71721f4c76f96d2.c89af5f6.png",c=t.p+"static/image/8ee170628842f4c9a6dcebfba831a632.9094a054.png",a=t.p+"static/image/a2d922952bf71158ac691911eab8ee0a.522811b4.png",p=t.p+"static/image/1adc1f87569714effb23942a3386234a.24e798e5.png";var l=t(471980);let d=t.p+"static/image/4f94423687f7c02774226af5dd9e5029.fd3691e3.png";function u(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",strong:"strong",pre:"pre",code:"code",ul:"ul",li:"li",blockquote:"blockquote",img:"img",h3:"h3"},(0,s.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"24框架解析qiankun-使用示例",children:["24.框架解析：qiankun 使用示例",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#24框架解析qiankun-使用示例",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在之前的课程中，我们重点讲解了\xa0single-spa\xa0的使用示例以及源码剖析，本课程主要讲解\xa0qiankun\xa0的使用示例。\xa0qiankun\xa0和\xa0single-spa\xa0都是实现微前端的\xa0JavaScript\xa0框架，只不过\xa0qiankun\xa0是对\xa0single-spa\xa0的二次封装，在\xa0single-spa\xa0的基础上提供了更加简单的\xa0API\xa0和配置项，使得开发者能更容易的实现微前端。本课程接下来将通过几个示例循序渐进的讲解\xa0qiankun\xa0的使用，从而帮助大家更好的理解它和\xa0single-spa\xa0的区别。"}),"\n",(0,r.jsxs)(e.h2,{id:"codesplitting示例-single-spa改造",children:["Code\xa0Splitting\xa0示例\xa0-\xa0single-spa\xa0改造",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#codesplitting示例-single-spa改造",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在\xa0",(0,r.jsx)(e.strong,{children:"single-spa\xa0的\xa0Code\xa0Splitting\xa0示例"}),"中，我们了解了\xa0Code\xa0Splitting\xa0的功能、如何通过\xa0Webpack\xa0配置\xa0Code\xa0Splitting、Code\xa0Splitting\xa0的\xa0Webpack\xa0运行时原理以及\xa0single-spa\xa0的实现示例，其中实现示例大致如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// 菜单信息，这里用于 Mock 后端数据\n// 真实业务可能是一个树状的带权限的菜单信息\nexport const mockMicroApps: IMicroApp[] = [\n  {\n    // 应用标识\n    name: "react",\n    // 菜单名称\n    title: "React Micro App",\n    // 应用地址\n    // 注意这里因为使用了代码分割，所以存在分割的 chunk 文件\n    // 注意由于遍历执行 entry 中的脚本，需要和 HTML 中 <script> 标签的放置顺序保持一致\n    // 分离出来的 chunk 文件需要优先于主文件执行\n    entry: [\n      "http://localhost:3000/vendors.js",\n      "http://localhost:3000/main.js",\n    ],\n    // 激活路由\n    router: MICRO_APP_ROUTER.REACT,\n  },\n  {\n    name: "vue",\n    title: "Vue Micro App",\n    entry: [\n      "http://localhost:8080/js/chunk-vendors.js",\n      "http://localhost:8080/js/app.js",\n    ],\n    router: MICRO_APP_ROUTER.VUE,\n  },\n];\n\n// 对 single-spa 的注册 API 进行了二次封装，支持传入数组进行批量注册\nregisterMicroApps(\n  // 根据后端提供的动态数据批量注册微应用\n  mockMicroApps.map((item) => ({\n    name: item.name,\n    app: () => {\n      // 通过 Fetch 请求方式获取\n      return fetchApp(item.entry);\n    },\n    activeWhen: item.router,\n    customProps: {\n      // 向微应用传递需要挂载的容器元素 ID\n      container: MICRO_APP_CONTAINER_ID,\n    },\n  }))\n);\n\n\n// 对 single-spa 的 registerApplication 进行二次封装，使其可以接收一个数组，批量注册子应用\nexport function registerMicroApps(apps: RegisterApplicationConfig[]) {\n  // @ts-ignore\n  // 如果不开启 __DEV__，single-spa 的源码无法正常运行\n  window.__DEV__ = true;\n  apps.forEach(registerApplication);\n  start();\n}\n\nexport async function fetchApp(urls: string[]) {\n  // 在上一个 Fetch 示例中没有进行代码分割，只需要请求单个 Bundle 文件进行执行\n  // 而在本示例中因为进行了代码分离，因此需要遍历执行微应用的所有脚本\n  // 这里需要先执行分离的 chunk 文件，后执行主文件\n  for (let url of urls) {\n    const res = await window.fetch(url);\n    const text = await res.text();\n    // 使用 eval 执行\n    (0, eval)(text);\n  }\n\n  // 执行微应用的代码后立即获取对应的生命周期函数\n  return getAppLifeCycles();\n}\n\nexport function getAppLifeCycles() {\n  // 使用 UMD 进行子应用的构建，挂载全局变量的动作是在内部微应用的代码执行完毕后\n  // 例如 root["myLibrary"] = factory(), 这里的 factory 包含了内部微应用代码的执行\n  // 因此这里通过遍历全局对象的属性顺序拿到子应用的生命周期函数\n\n  // Object.keys 可以获取到对象的属性\n  // 对象自身属性的返回顺序查看 ECMAScript 2015 标准：\n  // https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys\n\n  // 按照这个规范，Object.keys() 的返回顺序如下：\n\n  // 数字键（整数索引），按照升序排列。\n  // 字符串键，按照它们被添加到对象的顺序。\n  // 符号键，按照它们被添加到对象的顺序。\n  // 由于 Object.keys() 只返回字符串键，因此只需要关心数字键和字符串键。\n  // 数字键会被视为数组索引并按照数值升序排列，而字符串键则会按照它们创建时的顺序排列。\n  // 符号键不会被 Object.keys() 返回，但如果要获取它们，可以使用 Object.getOwnPropertySymbols()。\n\n  // 注意，这里的“数字键”指的是那些可被转换为32位无符号整数的字符串键，它们属于数组索引的范围，即在0到2^32-1之间的整数。\n  // 对于这些数字键，即使它们是作为对象的属性添加的，它们也会被当作数组索引并按照数值排序。其他非数字的字符串键则按照它们添加到对象的顺序进行枚举。\n\n  // 需要注意和 for...in 的区别，for...in 还能遍历原型链上的属性\n\n  // for...in\n  // https://262.ecma-international.org/6.0/?_gl=1*1tycd0l*_ga*NDQ5NTkxOTguMTcwMTc0MzUwMg..*_ga_TDCK4DWEPP*MTcwMTc0MzUwMS4xLjEuMTcwMTc0MzcxMy4wLjAuMA..&_ga=2.173157030.426159955.1701743502-44959198.1701743502#sec-for-in-and-for-of-statements-static-semantics-early-errors\n\n  const keys = Object.keys(window);\n  const lifeCycles = window[keys[keys.length - 1]];\n  console.info(\n    "%c当前 window 对象的最后一个属性是：%c" + keys[keys.length - 1],\n    "color: blue; font-weight: bold; font-size: 20px;",\n    "color: red; font-weight: bold; font-size: 20px;"\n  );\n  return lifeCycles as LifeCycles;\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"从上述 single-spa 示例中，我们会发现："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["需要手动实现\xa0single-spa\xa0的注册参数\xa0",(0,r.jsx)(e.code,{children:"app"}),"，实现自定义加载逻辑\xa0",(0,r.jsx)(e.code,{children:"fetchApp"})]}),"\n",(0,r.jsxs)(e.li,{children:["需要手动按顺序遍历并执行\xa0",(0,r.jsx)(e.code,{children:"fetch"}),"\xa0请求获取代码分割后的 JS 脚本文本"]}),"\n",(0,r.jsx)(e.li,{children:"需要手动识别微应用导出的生命周期函数"}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：为了能够识别微应用导出的生命周期函数，在课程\xa0single-spa\xa0的\xa0Fetch\xa0示例中我们讲解了\xa0Webpack\xa0的配置，包括\xa0",(0,r.jsx)(e.code,{children:"output.library"}),"、",(0,r.jsx)(e.code,{children:"output.libraryTarget"}),"以及\xa0",(0,r.jsx)(e.code,{children:"output.chunkLoadingGlobal"}),"等。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"如果我们保持微应用的\xa0Webpack\xa0配置不变，在主应用中将\xa0single-spa\xa0的微前端框架采用\xa0qiankun\xa0进行设计，那么上述三个步骤完全不用手动实现，qiankun\xa0内部已经实现了这些功能。接下来我们将原有的 single-spa 项目示例进行 qiankun 改造，示例的目录结构如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"├── packages  \n│   ├── main-app/                # 主应用\n│   ├── react-app/               # React 微应用\n│   └── vue-app/                 # Vue 微应用\n└── lerna.json                   # Lerna 配置\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：在之前的课程中，我们引入了 single-spa 的源码，这里将 single-spa 的源码去除，后续会加入 qiankun 的源码，用于剖析 qiankun 的原理。在本课程的示例中，主应用 main-app 会安装 qiankun 依赖。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["qainkun\xa0方案示例的实现流程如下所示，当主应用切换路由时会先失活没有匹配路由的微应用，执行相应的\xa0",(0,r.jsx)(e.code,{children:"unmount"}),"\xa0函数卸载微应用，然后会激活匹配路由的微应用，qiankun\xa0内部会自动请求获取微应用的脚本文本并动态执行脚本代码，然后自动识别和获取微应用生命周期函数，最后执行\xa0",(0,r.jsx)(e.code,{children:"mount"}),"\xa0函数挂载应用，最终实现监听路由切换微应用的功能：\n",(0,r.jsx)("img",{src:d,alt:"yuque_diagram (49).jpg"}),"\n这里可以重新回顾一下\xa0single-spa\xa0的示例，如下所示："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:l,alt:"yuque_diagram (2).jpg"})}),"\n",(0,r.jsx)(e.p,{children:"接下来我们重点关注一下两者注册微应用的差异。在\xa0single-spa\xa0的\xa0Fetch\xa0示例中，注册\xa0API\xa0时需要自行设计微应用的加载和执行逻辑，注册过程如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import { registerApplication } from "single-spa";\n\nfunction async fetchApp(urls: string[]) {\n  for (let url of urls) {\n    const res = await window.fetch(url);\n    const text = await res.text();\n    // 使用 eval 执行\n    (0, eval)(text);\n  }\n  \n  // 执行微应用的代码后立即获取对应的生命周期函数\n  const keys = Object.keys(window);\n  const lifeCycles = window[keys[keys.length - 1]];\n  return lifeCycles;\n}\n\n// 注册 React 微应用\nregisterApplication({\n  name: \'react\',\n  // app 参数如果是函数，则必须返回 Promise 对象\n  app: () => {\n    return fetchApp([\n      "http://localhost:3000/vendors.js",\n      "http://localhost:3000/main.js",\n    ])\n  },\n  // react 路由可以激活 React 微应用，\n  // 从而执行 app 参数进行微应用的加载和执行\n  activeWhen: \'react\',\n  customProps: {\n    container: "micro-app-container"\n  }\n});\n\n// 注册 Vue 微应用\nregisterApplication({\n  name: \'vue\',\n  app: () => {\n    return fetchApp([\n      "http://localhost:8080/js/chunk-vendors.js",\n      "http://localhost:8080/js/app.js", \n    ])\n  },\n  // vue 路由可以激活 Vue 微应用，从而执行 app 参数进行微应用的加载和执行\n  activeWhen: \'vue\',\n  customProps: {\n    container: "micro-app-container"\n  }\n});\n\nstart();\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在\xa0qiankun\xa0中注册微应用时除了需要提供\xa0",(0,r.jsx)(e.code,{children:"name"}),"、",(0,r.jsx)(e.code,{children:"activeWhen"}),"和\xa0",(0,r.jsx)(e.code,{children:"customProps"}),"\xa0之外，和\xa0single-spa\xa0最大的区别是通过提供\xa0",(0,r.jsx)(e.code,{children:"entry"}),"\xa0和\xa0",(0,r.jsx)(e.code,{children:"container"}),"\xa0两个参数来代替\xa0single-spa\xa0的\xa0",(0,r.jsx)(e.code,{children:"app"}),"参数，开发者不需要关注如何加载微应用并识别微应用的生命周期函数，qiankun\xa0内部会实现这些逻辑，从而简化注册流程，我们将\xa0single-spa\xa0的注册过程转化成\xa0qiankun\xa0注册的过程，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import { registerMicroApps } from "qiankun";\n\n// single-spa 通过 registerApplication 进行单个注册\n// qiankun 提供 registerMicroApps 进行批量注册\nregisterMicroApps([\n  {\n    name: "react",\n    title: "React Micro App",\n    // qiankun 新增的 entry 参数，用于替换 single-spa 中的 app 参数\n    entry: {\n      scripts: [\n        "http://localhost:3000/vendors.js",\n        "http://localhost:3000/main.js",\n      ],\n      // 由于没有抽离 CSS 样式，因此不需要配置该参数\n      // styles: []\n      // 微应用挂载 DOM 内容的容器元素\n      html: `<div id="${MICRO_APP_ROUTER.REACT}"></div>`,\n    },\n    // qiankun 新增的 container 参数，用于配合 entry 参数替换 app 参数\n    container: `#${MICRO_APP_CONTAINER_ID}`,\n    // 对应 single-spa 的 activeWhen\n    activeRule: MICRO_APP_ROUTER.REACT,\n    // 对应 single-spa 的 customProps\n    props: {\n      microContainer: MICRO_APP_ROUTER.REACT,\n    },\n  },\n  {\n    name: "vue",\n    title: "Vue Micro App",\n    entry: {\n      scripts: [\n        "http://localhost:8080/js/chunk-vendors.js",\n        "http://localhost:8080/js/app.js",\n      ],\n      html: `<div id="${MICRO_APP_ROUTER.VUE}"></div>`,\n    },\n    container: `#${MICRO_APP_CONTAINER_ID}`,\n    activeRule: MICRO_APP_ROUTER.VUE,\n    props: {\n      microContainer: MICRO_APP_ROUTER.VUE,\n    },\n  },\n])\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在注册过程中\xa0",(0,r.jsx)(e.code,{children:"entry"}),"\xa0包含\xa0",(0,r.jsx)(e.code,{children:"scripts"}),"、",(0,r.jsx)(e.code,{children:"styles"}),"以及\xa0",(0,r.jsx)(e.code,{children:"html"}),"三个配置，其中\xa0",(0,r.jsx)(e.code,{children:"scripts"}),"和\xa0",(0,r.jsx)(e.code,{children:"styles"}),"\xa0参数用于提供微应用的\xa0JS\xa0和\xa0CSS\xa0资源地址，而\xa0",(0,r.jsx)(e.code,{children:"html"}),"\xa0参数则是提供微应用内容挂载的容器元素（例如\xa0React\xa0应用中的\xa0",(0,r.jsx)(e.code,{children:"#root"})," 节点和\xa0Vue\xa0应用中的\xa0",(0,r.jsx)(e.code,{children:"#app"})," 节点）。\xa0当然微应用真正在渲染时除了需要一个容器元素来挂载自身的内容，还需要填充样式\xa0",(0,r.jsx)(e.code,{children:"<style>"}),"，因此需要一个更大的容器元素来包裹微应用的 HTML 内容，所以\xa0qiankun\xa0又提供了一个\xa0",(0,r.jsx)(e.code,{children:"container"})," 参数。qiankun\xa0注册并渲染微应用后，整体的 DOM 结构如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-html",children:'    \x3c!-- 主应用中提供的挂载微应用的容器元素，在微应用注册时需要提供 container 配置 --\x3e\n    <div id=`${container}`>\n      \x3c!-- qiankun 生成的 div 元素，在注册时需要提供 name 配置 --\x3e\n      <div id=`__qiankun_microapp_wrapper_for_${name}` data-name=`${name}` data-version="2.10.16" data-sandbox-cfg="true">\n        <qiankun-header>\n          \x3c!-- 微应用自身的内联样式或者微应用 JS 脚本动态生成的内联样式 --\x3e\n          <style></style>\n          <style></style>\n        </qiankun-header>\n        \x3c!-- 微应用注册时 entry.styles 的样式会被请求，请求后会在此处被处理成内联样式 --\x3e\n        <style></style>\n        \x3c!-- 微应用注册时需要提供 entry.html 配置，用于挂载微应用的内容  --\x3e\n        <div id=`${MICRO_APP_ROUTER.VUE}`></div>\n        \x3c!-- 微应用注册时需要提供 entry.scripts 配置，配置的脚本被请求后，会通过 (0, eval) 进行动态执行，这里会展示注释表明 JS 资源已经被加载和执行  --\x3e\n        \x3c!--   script http://localhost:8080/js/chunk-vendors.js replaced by import-html-entry --\x3e\n        \x3c!--   script http://localhost:8080/js/app.js replaced by import-html-entry --\x3e\n      </div>\n    </div>\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"主应用设计",children:["主应用设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#主应用设计",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"首先来看下\xa0qiankun\xa0示例的实现效果，如下所示，点击左侧的导航切换路由，qiankun 会监听路由的变化切换微应用："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:"屏幕录制2024-05-13 21.21.36.gif"})}),"\n",(0,r.jsx)(e.p,{children:"主应用的目录结构如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"    ├── src                  \n    │   ├── index.tsx           # 入口文件，包含了 single-spa 的注册和 React 路由             \n    │   ├── App.tsx             # 主应用布局，包含了导航和内容区的布局设计           \n    │   └── utils/              # 工具方法\n    │        ├── micros.ts      # 微应用数据信息（Mock 后端数据结构）   \n    │        └── qiankun.ts     # qiankun 的注册 API 封装 （新增的 qiankun 示例）\n"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示: 示例源码可以从 micro-framework 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/qiankun",target:"_blank",rel:"noopener noreferrer",children:"demo/qiankun"})," 分支获取。在示例代码的 ",(0,r.jsx)(e.code,{children:"README.md"})," 中已经详细讲解了如何启动微应用和主应用，注意严格按照文档的操作顺序启动。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在\xa0",(0,r.jsx)(e.code,{children:"src/utils/micros.js"}),"\xa0中定义了微应用列表的数据结构（在真实业务场景中这个数据会更复杂，并且可以从服务端进行动态加载），该数据主要用于注册\xa0qiankun\xa0的微应用、生成\xa0React\xa0路由和主应用导航，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:' // 微应用容器元素的 ID\nexport const MICRO_APP_CONTAINER_ID = "micro-app-container";\n\nexport const MICRO_APP_ROUTER = {\n  REACT: "react",\n  VUE: "vue",\n};\n\n// // single-spa 微应用数据\n// // 菜单信息，这里用于 Mock 后端数据\n// // 真实业务可能是一个树状的带权限的菜单信息\n// export const mockMicroApps: IMicroApp[] = [\n//   {\n//     // 应用标识\n//     name: "react",\n//     // 菜单名称\n//     title: "React Micro App",\n//     // 应用地址\n//     entry: [\n//       "http://localhost:3000/vendors.js",\n//       "http://localhost:3000/main.js",\n//     ],\n//     // 激活路由\n//     activeWhen: MICRO_APP_ROUTER.REACT,\n//     customProps: {\n//       // 向微应用传递需要挂载的容器元素 ID\n//       container: MICRO_APP_CONTAINER_ID,\n//     },\n//   },\n//   {\n//     name: "vue",\n//     title: "Vue Micro App",\n//     entry: [\n//       "http://localhost:8080/js/chunk-vendors.js",\n//       "http://localhost:8080/js/app.js",\n//     ],\n//     activeWhen: MICRO_APP_ROUTER.VUE,\n//     customProps: {\n//       // 向微应用传递需要挂载的容器元素 ID\n//       container: MICRO_APP_CONTAINER_ID,\n//     },\n//   },\n// ];\n\n// qiankun 微应用数据\n// 菜单信息，这里用于 Mock 后端数据\n// 真实业务可能是一个树状的带权限的菜单信息\nexport const mockMicroApps = [\n  {\n    // 应用标识\n    name: "react",\n    // 菜单名称\n    title: "React Micro App",\n    // 应用地址\n    entry: {\n      scripts: [\n        "http://localhost:3000/vendors.js",\n        "http://localhost:3000/main.js",\n      ],\n      html: `<div id="${MICRO_APP_ROUTER.REACT}"></div>`,\n    },\n    // 对应 single-spa 的 activeWhen\n    // 激活路由\n    activeRule: MICRO_APP_ROUTER.REACT,\n    container: `#${MICRO_APP_CONTAINER_ID}`,\n    // 对应 single-spa 的 customProps\n    props: {\n      microContainer: MICRO_APP_ROUTER.REACT,\n    },\n  },\n  {\n    name: "vue",\n    title: "Vue Micro App",\n    entry: {\n      scripts: [\n        "http://localhost:8080/js/chunk-vendors.js",\n        "http://localhost:8080/js/app.js",\n      ],\n      html: `<div id="${MICRO_APP_ROUTER.VUE}"></div>`,\n    },\n    activeRule: MICRO_APP_ROUTER.VUE,\n    container: `#${MICRO_APP_CONTAINER_ID}`,\n    props: {\n      microContainer: MICRO_APP_ROUTER.VUE,\n    },\n  },\n];\n'})}),"\n",(0,r.jsx)(e.p,{children:"主应用在初始化时需要消费微应用数据，在初始化时使用\xa0qiankun\xa0注册微应用并生成对应的\xa0React\xa0路由："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'    // src/index.tsx\n    import React from "react";\n    import ReactDOM from "react-dom/client";\n    import "./index.css";\n    import App from "./App.tsx";\n    import reportWebVitals from "./reportWebVitals.js";\n    import { createBrowserRouter, RouterProvider } from "react-router-dom";\n    // single-spa 注册和启动\n    // import { registerMicroApps, fetchApp } from "./utils/single-spa.ts";\n    // qiankun 注册和启动\n    import { registerQiankunMicroApps } from "./utils/qiankun.ts";\n    import { MICRO_APP_CONTAINER_ID, mockMicroApps } from "./utils/micros.ts";\n\n    // // single-spa 的使用方式\n    // // 对 single-spa 的注册 API 进行了二次封装，支持传入数组进行批量注册\n    // registerMicroApps(\n    //   // 根据后端提供的动态数据批量注册微应用\n    //   mockMicroApps.map((item) => ({\n    //     name: item.name,\n    //     app: () => {\n    //       // 通过 Fetch 请求方式获取\n    //       return fetchApp(item.entry);\n    //     },\n    //     activeWhen: item.activeWhen,\n    //     customProps: item.customProps,\n    //   }))\n    // );\n\n    // qiankun 的使用方式\n    // 不需要像 single-spa 设计 app 参数，手动实现微应用资源的加载、执行并识别出生命周期函数\n    // 不需要设计 fetchApp 手动加载逻辑，qiankun 内部会自动请求和执行微应用的脚本，并制动识别出微应用的生命周期函数\n    registerQiankunMicroApps(mockMicroApps);\n\n    const router = createBrowserRouter([\n      {\n        path: "/",\n        // <App /> 中提供了左侧导航栏和右侧内容区域的布局结构\n        element: <App />,\n        // children 中的元素会被渲染到 <App /> 的 <Outlet /> 中\n        // <Outlet> 是 react-router-dom 提供的一个组件，用于渲染子路由：https://reactrouter.com/en/main/components/outlet\n\n        // 遍历迭代 mockMicroApps 中的数据，生成对应的路由配置\n        // 这里的路由配置和微应用注册 API 中的 activeWhen 一致\n        children: mockMicroApps.map((item) => ({\n          path: item.activeRule,\n          // 微应用的容器元素，用于渲染微应用\n          // 在 qiankun 的注册中提供的 container 参数配置\n          element: <div id={MICRO_APP_CONTAINER_ID}></div>,\n        })),\n      },\n    ]);\n\n    const root = ReactDOM.createRoot(document.getElementById("root")!);\n    root.render(<RouterProvider router={router} />);\n\n    // If you want to start measuring performance in your app, pass a function\n    // to log results (for example: reportWebVitals(console.log))\n    // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n    reportWebVitals();\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在\xa0",(0,r.jsx)(e.code,{children:"src/utils/qiankun.ts"}),"\xa0中只需要调用\xa0",(0,r.jsx)(e.code,{children:"registerMicroApps"}),"\xa0批量注册微应用即可："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'import { start, registerMicroApps, RegistrableApp } from "qiankun";\n\nexport function registerQiankunMicroApps(\n  microApps: RegistrableApp<{ microContainer: string }>[]\n) {\n  registerMicroApps(microApps);\n  start();\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["最后在\xa0",(0,r.jsx)(e.code,{children:"<App>"}),"\xa0中对主应用进行布局设计，将左侧设计成能够切换路由的导航，导航的信息来源于微应用数据，右侧设计成用于渲染微应用的内容区："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/App.tsx\n\nimport React from "react";\nimport { Outlet, Link } from "react-router-dom";\nimport "./App.css";\nimport { mockMicroApps } from "./utils/micros.ts";\n\nfunction App() {\n  return (\n    <div className="app">\n      <div className="app-nav">\n        <p>Micro App List</p>\n        <nav>\n          <ul>\n            {/* 遍历微应用的数据列表生成导航路由信息 */}\n            {mockMicroApps.map((item) => (\n              <li key={item.name}>\n                <Link to={item.activeRule}>{item.title}</Link>\n              </li>\n            ))}\n          </ul>\n        </nav>\n      </div>\n      <div className="app-content">\n        {/* 这里的 <Outlet /> 会被 <RouterProvider router={router} /> 中 router 提供的 children 进行替换 */}\n        <Outlet />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"微应用设计",children:["微应用设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#微应用设计",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["微应用的\xa0Webpack\xa0配置和 ",(0,r.jsx)(e.strong,{children:"single-spa\xa0的\xa0Code\xa0Splitting\xa0示例"}),"的微应用保持一致。除此之外，由于\xa0qiankun\xa0的注册\xa0API\xa0中使用\xa0",(0,r.jsx)(e.code,{children:"container"}),"\xa0来填充微应用，需要将微应用的\xa0DOM\xa0内容挂载到\xa0",(0,r.jsx)(e.code,{children:"entry.html"}),"\xa0所在的容器元素上，因此传递了\xa0",(0,r.jsx)(e.code,{children:"props.microContainer"}),"\xa0数据，微应用需要将\xa0DOM\xa0内容挂载到\xa0",(0,r.jsx)(e.code,{children:"props.microContainer"}),"\xa0上，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// packages/vue-app/src/main.js\nimport { createApp } from "vue";\nimport App from "./App.vue";\nlet app;\n\nimport(/* webpackChunkName: "about" */ "./about.js").then((res) => {\n  console.log(res);\n});\n\n// 判断是否在 qiankun 的环境中运行\n// 如果不是，那么说明不在微前端的环境中，可以独立启动\nif (!window.__POWERED_BY_QIANKUN__) {\n  app = createApp(App);\n  app.mount("#app");\n}\n\n// 注意这里的每一个生命周期函数必须是 async 函数\nexport async function bootstrap() {\n  console.log("[Vue 子应用] bootstrap excuted");\n}\n\nexport async function mount(props) {\n  console.log("[Vue 子应用] mount excuted, props: ", props);\n  app = createApp(App);\n  // qiankun 在注册 vue 子应用时会通过 props 传递 microContainer 微应用 DOM 容器元素 ID\n  app.mount(`#${props.microContainer}`);\n}\n\nexport async function unmount(props) {\n  console.log("[Vue 子应用] unmount excuted, props: ", props);\n  app && app.unmount();\n}\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// packages/react-app/src/index.js\nimport React from "react";\nimport ReactDOM from "react-dom/client";\nimport "./index.css";\nimport App from "./App";\n// import reportWebVitals from \'./reportWebVitals\';\n\nlet root;\n\nimport(/* webpackChunkName: "about" */ "./about.js").then((res) => {\n  console.log(res);\n});\n\n// 判断是否在 qiankun 的环境中运行\n// 如果不是，那么说明不在微前端的环境中，可以独立启动\nif (!window.__POWERED_BY_QIANKUN__) {\n  root = ReactDOM.createRoot(document.getElementById("root"));\n  root.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n}\n\n/**\n * bootstrap 只会在微应用首次激活时调用一次\n * 微应用重新激活时会直接调用 mount 周期函数，不会再重复触发 bootstrap。\n * 通常情况下这里不需要进行任何处理，初始化的代码可以放在当前入口文件的顶层处理\n * 除非会执行微应用的 unload 动作，然后需要再次执行 bootstrap，可能需要在此做一些必要的初始化动作\n * 注意这里的周期函数不是 async 函数，在主应用中引入该周期函数后需要进行 async 处理\n */\n\n// 注意这里的每一个生命周期函数必须是 async 函数\nexport async function bootstrap() {\n  console.log("[React 子应用] bootstrap excuted");\n}\n\n/**\n * 微应用每次激活时都会调用 mount 周期函数，通常在这里执行微应用的渲染\n */\nexport async function mount(props) {\n  console.log("[React 子应用] mount excuted, props: ", props);\n  // qiankun 在注册 react 子应用时会通过 props 传递 microContainer 微应用 DOM 容器元素 ID\n  root = ReactDOM.createRoot(document.getElementById(props.microContainer));\n  root.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n}\n\n/**\n * 微应用每次失活时会调用 unmount 周期函数，通常在这里执行微应用的卸载\n */\nexport async function unmount(props) {\n  console.log("[React 子应用] unmount excuted, props: ", props);\n  root && root.unmount();\n}\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n'})}),"\n",(0,r.jsx)(e.p,{children:"微应用渲染后，可以重点查看一下微应用的网络请求和\xa0DOM\xa0结构，可以发现\xa0qiankun\xa0使用\xa0Fetch\xa0来请求微应用的静态资源（要求微应用的资源支持跨域），如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(e.p,{children:"我们可以看下微应用渲染后的页面结构，如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:"image (1).png"})}),"\n",(0,r.jsxs)(e.h2,{id:"codesplitting示例-抽离css样式",children:["Code\xa0Splitting\xa0示例\xa0-\xa0抽离\xa0CSS\xa0样式",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#codesplitting示例-抽离css样式",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在\xa0single-spa\xa0的课程中，我们没有提供\xa0CSS\xa0样式抽离的示例，因为如果要实现\xa0CSS\xa0样式抽离，需要在注册的\xa0",(0,r.jsx)(e.code,{children:"app"}),"\xa0参数中手动加载样式。\xa0qiankun\xa0则自动提供了\xa0CSS\xa0的加载参数，只需要在上一个示例的基础上将微应用的\xa0CSS\xa0抽离出来，然后在\xa0qiankun\xa0注册\xa0API\xa0时配置\xa0",(0,r.jsx)(e.code,{children:"entry.styles"})," 即可。在这里我们可以更改 Vue 微应用的配置："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'    // vue.config.js\n    const { defineConfig } = require("@vue/cli-service");\n    const { name } = require("./package.json");\n    const { v4: uuidv4 } = require("uuid");\n\n    const port = 8080;\n    const appKey = `${name}_${uuidv4()}`;\n\n    module.exports = defineConfig({\n      transpileDependencies: true,\n      // 将 CSS 样式抽离出来\n      css: { extract: true },\n      filenameHashing: false,\n\n      publicPath: `//localhost:${port}/`,\n\n      configureWebpack: {\n        optimization: {\n          splitChunks: {\n            chunks: "all",\n          },\n        },\n        output: {\n          library: appKey,\n          libraryTarget: "umd",\n          chunkLoadingGlobal: `webpackJsonp_${appKey}`,\n        },\n      },\n      devServer: {\n        port: port,\n        headers: {\n          "Access-Control-Allow-Origin": "*",\n        },\n      },\n    });\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["示例源码可以从 micro-framework 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/qiankun-extract-css",target:"_blank",rel:"noopener noreferrer",children:"demo/qiankun-extract-css"})," 分支获取。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在主应用的\xa0",(0,r.jsx)(e.code,{children:"src/utils/micros.js"}),"\xa0中添加\xa0",(0,r.jsx)(e.code,{children:"entry.styles"}),"\xa0配置，如下所示："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'    // src/utils/micros.js\n    import { RegistrableApp } from "qiankun";\n\n    export const MICRO_APP_CONTAINER_ID = "micro-app-container";\n\n    export const MICRO_APP_ROUTER = {\n      REACT: "react",\n      VUE: "vue",\n    };\n\n    export const mockMicroApps: RegistrableApp[] = [\n      {\n        name: "react",\n        title: "React Micro App",\n        entry: {\n          scripts: [\n            "http://localhost:3000/vendors.js",\n            "http://localhost:3000/main.js",\n          ],\n          html: `<div id="${MICRO_APP_ROUTER.REACT}"></div>`,\n        },\n        activeRule: MICRO_APP_ROUTER.REACT,\n        container: `#${MICRO_APP_CONTAINER_ID}`,\n        props: {\n          microContainer: MICRO_APP_ROUTER.REACT,\n        },\n      },\n      {\n        name: "vue",\n        title: "Vue Micro App",\n        entry: {\n          scripts: [\n            "http://localhost:8080/js/chunk-vendors.js",\n            "http://localhost:8080/js/app.js",\n          ],\n          // 新增抽离的 styles 样式\n          styles: ["http://localhost:8080/css/app.css"],\n          html: `<div id="${MICRO_APP_ROUTER.VUE}"></div>`,\n        },\n        activeRule: MICRO_APP_ROUTER.VUE,\n        container: `#${MICRO_APP_CONTAINER_ID}`,\n        props: {\n          microContainer: MICRO_APP_ROUTER.VUE,\n        },\n      },\n    ];\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"温馨提示：这里可以观察抽离\xa0CSS\xa0样式后\xa0Vue\xa0微应用的\xa0DOM\xa0结构和没有抽离\xa0CSS\xa0样式之前\xa0DOM\xa0结构的区别。"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"codesplitting示例-请求html",children:["Code\xa0Splitting\xa0示例\xa0-\xa0请求\xa0HTML",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#codesplitting示例-请求html",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在之前的示例中，我们都是请求\xa0JS\xa0和\xa0CSS\xa0的地址来实现微应用的加载，但是在现实的业务开发中往往需要生成带\xa0hash\xa0的资源地址，如果采用固定地址的方式请求，则每次构建后都需要变更请求的地址。为了解决\xa0hash\xa0地址引入的变更问题，qiankun\xa0提供了\xa0HTML\xa0地址的配置方式，从而使得开发者不需要感知\xa0JS\xa0和\xa0CSS\xa0的地址、数量和加载顺序。我们可以对之前的示例进行更改，如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// src/utils/micros.js\nimport { RegistrableApp } from "qiankun";\n\nexport const MICRO_APP_CONTAINER_ID = "micro-app-container";\n\nexport const MICRO_APP_ROUTER = {\n  REACT: "react",\n  VUE: "vue",\n};\n\nexport const mockMicroApps: RegistrableApp[] = [\n  {\n    name: "react",\n    title: "React Micro App",\n    // entry 配置成微应用 HTML 的访问地址（注意该 HTML 地址必须支持跨域请求）\n    entry: "http://localhost:3000",\n    activeRule: MICRO_APP_ROUTER.REACT,\n    // 将请求到的微应用 HTML 内容挂载到 container 元素上\n    container: `#${MICRO_APP_CONTAINER_ID}`,\n    // 由于微应用 HTML 中自带了可以挂载微应用的 DOM 元素，因此这里不再需要 props 提供微应用挂载的容器元素\n    // props: {\n    //   microContainer: MICRO_APP_ROUTER.VUE,\n    // },\n  },\n  {\n    name: "vue",\n    title: "Vue Micro App",\n    entry: "http://localhost:8080",\n    activeRule: MICRO_APP_ROUTER.VUE,\n    container: `#${MICRO_APP_CONTAINER_ID}`,\n  },\n];\n'})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：示例源码可以从 micro-framework 的 ",(0,r.jsx)(e.a,{href:"https://github.com/ziyi2/micro-framework/tree/demo/qiankun-html",target:"_blank",rel:"noopener noreferrer",children:"demo/qiankun-html"})," 分支获取。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"在微应用中需要更改\xa0DOM\xa0挂载的容器元素，由于微应用自带了\xa0HTML\xa0内容，因此只需要将应用挂载到自身\xa0HTML\xa0所在的\xa0DOM\xa0节点即可，如下所示："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// packages/vue-app/src/main.js\nimport { createApp } from "vue";\nimport App from "./App.vue";\nlet app;\n\nimport(/* webpackChunkName: "about" */ "./about.js").then((res) => {\n  console.log(res);\n});\n\nif (!window.__POWERED_BY_QIANKUN__) {\n  app = createApp(App);\n  app.mount("#app");\n}\n\nexport async function bootstrap() {\n  console.log("[Vue 子应用] bootstrap excuted");\n}\n\nexport async function mount(props) {\n  console.log("[Vue 子应用] mount excuted, props: ", props);\n  app = createApp(App);\n  // qiankun 在注册 vue 子应用时会通过 props 传递 container\n  // Vue CLI 生成的项目中应用的挂载节点是 #app（可以查看 public/index.html）\n  // 由于微应用的 HTML 内容会挂载在 container 上\n  // 因此可以从 container 中获取到 #app 节点挂载 Vue 应用\n  app.mount(props.container.querySelector("#app"));\n}\n\nexport async function unmount(props) {\n  console.log("[Vue 子应用] unmount excuted, props: ", props);\n  app && app.unmount();\n}\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// packages/react-app/src/index.js\nimport React from "react";\nimport ReactDOM from "react-dom/client";\nimport "./index.css";\nimport App from "./App";\n\nlet root;\n\nimport(/* webpackChunkName: "about" */ "./about.js").then((res) => {\n  console.log(res);\n});\n\nif (!window.__POWERED_BY_QIANKUN__) {\n  root = ReactDOM.createRoot(document.getElementById("root"));\n  root.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n}\n\nexport async function bootstrap() {\n  console.log("[React 子应用] bootstrap excuted");\n}\n\nexport async function mount(props) {\n  console.log("[React 子应用] mount excuted, props: ", props);\n  // qiankun 在注册 react 子应用时会通过 props 传递 container\n  // Creact React App 自带的 HTML 模版的挂载节点是 #root（可以查看 public/index.html）\n  // 由于微应用的 HTML 内容会挂载在 container 上\n  // 因此可以从 container 中获取到 #root 节点挂载 react 应用\n  root = ReactDOM.createRoot(props.container.querySelector("#root"));\n  root.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>\n  );\n}\n\nexport async function unmount(props) {\n  console.log("[React 子应用] unmount excuted, props: ", props);\n  root && root.unmount();\n} \n'})}),"\n",(0,r.jsxs)(e.p,{children:["配置 ",(0,r.jsx)(e.code,{children:"entry"})," 为 HTML 地址后，qiankun 会通过 Fetch 请求 HTML 的文本内容，然后解析出内部的所有 DOM 信息，如果遇到需要加载的 CSS 地址和 JS 地址，则会继续发起 Fetch 请求获取对应的内容，最终处理完所有的 HTML 内容后进行 DOM 的渲染和微应用脚本的执行处理。"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：官方推荐使用\xa0",(0,r.jsx)(e.code,{children:"entry"}),"\xa0配置\xa0HTML\xa0地址的注册方式，有点类似于在\xa0iframe\xa0标签上设置\xa0",(0,r.jsx)(e.code,{children:"src"}),"，非常方便简单。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"我们可以看下页面的请求情况，可以发现除了请求\xa0CSS\xa0和\xa0JS\xa0资源外，各自还会请求微应用\xa0HTML\xa0的内容，说明配置\xa0HTML\xa0地址会多产生一次 Fetch 请求，如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:"image (2).png"})}),"\n",(0,r.jsx)(e.p,{children:"我们可以看下微应用渲染后的页面结构，如下所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:"image (3).png"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["温馨提示：这里可以对比一下使用\xa0",(0,r.jsx)(e.code,{children:"entry.scripts"}),"和\xa0",(0,r.jsx)(e.code,{children:"entry.styles"}),"注册微应用和\xa0HTML\xa0地址注册时\xa0DOM\xa0结构的差异。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["本课程主要讲解了 qiankun 的使用示例，首先讲解了如何将 single-spa 的示例改造成 qiankun 示例以及两者注册微应用的能力差异，其次讲解了 CSS 样式抽离的 qiankun 示例，最后讲解了配置 HTML 地址进行加载的 qiankun 示例。在配置 HTML 地址注册微应用时，qiankun 内部引用了 ",(0,r.jsx)(e.a,{href:"https://github.com/kuitos/import-html-entry",target:"_blank",rel:"noopener noreferrer",children:"import-html-entry"})," 对 HTML 进行解析处理，在下一个课程中我们会讲解该库包的解析原理，这是解析 qiankun 内部原理的一个重要前提。"]})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}let m=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F24.%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90%EF%BC%9Aqiankun%20%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.md"]={toc:[{text:"Code\xa0Splitting\xa0示例\xa0-\xa0single-spa\xa0改造",id:"codesplitting示例-single-spa改造",depth:2},{text:"主应用设计",id:"主应用设计",depth:3},{text:"微应用设计",id:"微应用设计",depth:3},{text:"Code\xa0Splitting\xa0示例\xa0-\xa0抽离\xa0CSS\xa0样式",id:"codesplitting示例-抽离css样式",depth:2},{text:"Code\xa0Splitting\xa0示例\xa0-\xa0请求\xa0HTML",id:"codesplitting示例-请求html",depth:2},{text:"小结",id:"小结",depth:2}],title:"24.框架解析：qiankun 使用示例",headingTitle:"24.框架解析：qiankun 使用示例",frontmatter:{}}}}]);