"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["56844"],{20835:function(e,n,s){s.r(n),s.d(n,{default:()=>v});var r=s(552676),a=s(740453);let c=s.p+"static/image/627c1847546fcf3a8231616705554ab1.628a3d67.webp",i=s.p+"static/image/9656067a0bd2225f99ac350a8722346a.1106bdc9.webp",t=s.p+"static/image/6b25bc090f589b151ff5d40ee7341edd.af07024d.webp",l=s.p+"static/image/8537bc8607589482cfcb627d390f0c33.7b9d3ad6.webp",d=s.p+"static/image/7a356824737b3ebed27b6f3a410668cd.baed938d.webp",o=s.p+"static/image/211432a32ed7d7d9bb05c2e6cf9128d1.94a1c8fd.webp",h=s.p+"static/image/68ef9e93a7ba109f10f07c84bfe5f015.24255dd9.webp",x=s.p+"static/image/cb4d7737ce5da707f958e696dd7bd24e.88bc07c3.webp",p=s.p+"static/image/71fb56e4eaa0be06a04c0fc7858a76cc.f656c3d1.webp",j=s.p+"static/image/ceb423b60769aa659bd09eb5a1d12c50.5c8aabb2.webp",m=s.p+"static/image/ba1164fc3e037708bf75fd22a1d6d6bf.1f6bf66f.webp",u=s.p+"static/image/af0f4f069bbf88602c13d57c01218cb1.876015f9.webp";function g(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",h4:"h4",ul:"ul",li:"li",code:"code",pre:"pre",blockquote:"blockquote"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"20前端实战个人中心",children:["20.前端实战：个人中心",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#20前端实战个人中心",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"行文至此，万里长征已经快要走到头了。本章节带同学们来编写最后一个模块 —— 个人中心。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"个人中心模块分几个功能点，首先是头部的用户信息展示，包括头像、用户昵称、个人签名。其次是一些账号相关的操作，如用户信息修改、密码重置等。最后是退出登录，将其放置于页面底部，并且设置二次确认弹窗，避免误触。"}),"\n",(0,r.jsxs)(n.h4,{id:"知识点",children:["知识点",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"图片资源上传格式处理。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["原生表单插件 ",(0,r.jsx)(n.code,{children:"rc-form"})," 的使用。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"底部导航栏定位。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"正文",children:["正文",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正文",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"头部信息展示",children:["头部信息展示",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#头部信息展示",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"container/User/index.jsx"})," 代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React from 'react';\n\nimport s from './style.module.less';\n\nconst User = () => {\n  return <div className={s.user}>\n    <div className={s.head}>\n      <div className={s.info}>\n        <span>昵称：测试</span>\n        <span>\n          <img style={{ width: 30, height: 30, verticalAlign: '-10px' }} src=\"//s.yezgea02.com/1615973630132/geqian.png\" alt=\"\" />\n          <b>个性签名</b>\n        </span>\n      </div>\n      <img className={s.avatar} style={{ width: 60, height: 60, borderRadius: 8 }} src={'//s.yezgea02.com/1624959897466/avatar.jpeg'} alt=\"\" />\n   </div>\n  </div>\n}\n\nexport default User\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["这里给 ",(0,r.jsx)(n.code,{children:".head"})," 一个背景图片，介绍一下顶部的布局思路，如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:".head"})," 内通过 ",(0,r.jsx)(n.code,{children:"flex"})," 实现左右布局，在 ",(0,r.jsx)(n.code,{children:".info"})," 内通过 ",(0,r.jsx)(n.code,{children:"flex"})," 的 ",(0,r.jsx)(n.code,{children:"flex-direction"})," 设置为 ",(0,r.jsx)(n.code,{children:"column"})," 实现上下布局。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:".head"})," 底部留出的位置，用于放置后续的操作。"]}),"\n",(0,r.jsxs)(n.p,{children:["完成布局之后，将数据填上，通过 ",(0,r.jsx)(n.code,{children:"/api/user/get_userinfo"})," 接口，获取用户信息，添加代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React, { useState, useEffect } from 'react';\nimport { get } from '@/utils';\n\nimport s from './style.module.less';\n\nconst User = () => {\n  const [user, setUser] = useState({});\n  \n  useEffect(() => {\n    getUserInfo();\n  }, []);\n\n  // 获取用户信息\n  const getUserInfo = async () => {\n    const { data } = await get('/api/user/get_userinfo');\n    setUser(data);\n    setAvatar(data.avatar)\n  };\n\n  return <div className={s.user}>\n    <div className={s.head}>\n      <div className={s.info}>\n        <span>昵称：{user.username || '--'}</span>\n        <span>\n          <img style={{ width: 30, height: 30, verticalAlign: '-10px' }} src=\"//s.yezgea02.com/1615973630132/geqian.png\" alt=\"\" />\n          <b>{user.signature || '暂无个签'}</b>\n        </span>\n      </div>\n      <img className={s.avatar} style={{ width: 60, height: 60, borderRadius: 8 }} src={user.avatar || ''} alt=\"\" />\n   </div>\n  </div>\n}\n\nexport default User\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"/api/user/get_userinfo"})," 接口返回字段分析："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["avatar：头像地址，这里要注意，我目前采用的线上接口，如果是本地开发的情况，需要修改你的 ",(0,r.jsx)(n.code,{children:"host"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"signature：个性签名。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"username：用户登录名称。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"浏览器展示如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsxs)(n.h4,{id:"用户信息相关操作",children:["用户信息相关操作",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用户信息相关操作",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"紧接着，我们需要布局用户相关操作的内容，在上述基础上添加如下代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'... \nimport { useNavigate } from \'react-router-dom\';\nimport { Cell,  } from \'zarm\';\n\nconst User = () => {\n  ...\n  const navigateTo = useNavigate();\n\n  return <div className={s.user}>\n    ... \n    <div className={s.content}>\n      <Cell\n        hasArrow\n        title="用户信息修改"\n        onClick={() => navigateTo(\'/userinfo\')}\n        icon={<img style={{ width: 20, verticalAlign: \'-7px\' }} src="//s.yezgea02.com/1615974766264/gxqm.png" alt="" />}\n      />\n      <Cell\n        hasArrow\n        title="重制密码"\n        onClick={() => navigateTo(\'/account\')}\n        icon={<img style={{ width: 20, verticalAlign: \'-7px\' }} src="//s.yezgea02.com/1615974766264/zhaq.png" alt="" />}\n      />\n      <Cell\n        hasArrow\n        title="关于我们"\n        onClick={() => navigateTo(\'/about\')}\n        icon={<img style={{ width: 20, verticalAlign: \'-7px\' }} src="//s.yezgea02.com/1615975178434/lianxi.png" alt="" />}\n      />\n    </div>\n  </div>\n};\n'})}),"\n",(0,r.jsx)(n.p,{children:"添加样式："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:"...\n.content {\n  width: 90%;\n  position: absolute;\n  top: 120px;\n  left: 50%;\n  transform: translateX(-50%);\n  box-shadow: 3px 2px 20px 10px rgba(0, 0, 0, .1);\n  border-radius: 10px;\n  overflow: hidden;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["代码部分，直接采用 ",(0,r.jsx)(n.code,{children:"Zarm"})," 组件库提供的 ",(0,r.jsx)(n.code,{children:"Cell"})," 组件，它适用于列表布局，",(0,r.jsx)(n.a,{href:"https://zarm.gitee.io/#/components/cell",target:"_blank",rel:"noopener noreferrer",children:"官方文档"}),"提供了很多列表布局的例子，可以直接在内部拷贝代码进行二次加工。能不用自己写样式，尽量就不要写。用组件库的目的，就是减少工作量，提高布局的效率。"]}),"\n",(0,r.jsx)(n.p,{children:"浏览器展示效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["这里有三个列表跳转项，分别是 ",(0,r.jsx)(n.code,{children:"userinfo"}),"、",(0,r.jsx)(n.code,{children:"account"}),"、",(0,r.jsx)(n.code,{children:"about"}),"。我们逐一击破。"]}),"\n",(0,r.jsxs)(n.p,{children:["首先我们在 ",(0,r.jsx)(n.code,{children:"container"})," 目录下新建一个 ",(0,r.jsx)(n.code,{children:"UserInfo"})," 目录，如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["添加 ",(0,r.jsx)(n.code,{children:"index.js"})," 和 ",(0,r.jsx)(n.code,{children:"style.module.less"}),"，并且在 ",(0,r.jsx)(n.code,{children:"router/index.js"})," 内添加相对应的路由配置项。"]}),"\n",(0,r.jsx)(n.p,{children:"于是我们尝试点击「修改用户信息」，如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["成功之后，我们便可在 ",(0,r.jsx)(n.code,{children:"UserInfo"})," 中编写编辑用户相关信息的操作，在编写正式代码之前，我们先对 ",(0,r.jsx)(n.code,{children:"Zarm"})," 的上传组件进行分析，我们尝试编写如下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React from 'react';\nimport { FilePicker, Button } from 'zarm';\n\nimport s from './style.module.less';\n\nconst UserInfo = () => {\n\n  const handleSelect = (file) => {\n    console.log('file', file)\n  }\n  return <div className={s.userinfo}>\n    <FilePicker onChange={handleSelect} accept=\"image/*\">\n      <Button theme='primary' size='xs'>点击上传</Button>\n    </FilePicker>\n  </div>\n};\n\nexport default UserInfo;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["点击按钮，上传一张图片，我们查看回调函数 ",(0,r.jsx)(n.code,{children:"handleSelect"})," 的执行结果："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["此时，我们需要的是上传资源的原始文件，在上述返回对象中，",(0,r.jsx)(n.code,{children:"file"})," 属性为 ",(0,r.jsx)(n.code,{children:"File"})," 文件类型，它是浏览器返回的原生对象，我们需要通过下列代码，将其改造成一个 ",(0,r.jsx)(n.code,{children:"form-data"})," 对象："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const handleSelect = (file) => {\n  console.log('file', file)\n  let formData = new FormData()\n  formData.append('file', file.file)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["再将 ",(0,r.jsx)(n.code,{children:"formData"})," 通过 ",(0,r.jsx)(n.code,{children:"axios"})," 上传到服务器，服务端通过 ",(0,r.jsx)(n.code,{children:"ctx.request.files[0]"})," 获取到前端上传的\n文件原始对象，并将其读取，存入服务器内部。这样就完成了一套前端上传资源，服务端存储并返回路径的一个过程。"]}),"\n",(0,r.jsx)(n.p,{children:"接下来进行完整代码的编写，如下所示："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState } from 'react';\nimport { Button, FilePicker, Input, Toast } from 'zarm';\nimport { useNavigate } from 'react-router-dom';\nimport Header from '@/components/Header'; // 由于是内页，使用到公用头部\nimport axios from 'axios'; // // 由于采用 form-data 传递参数，所以直接只用 axios 进行请求\nimport { get, post } from '@/utils';\nimport { baseUrl } from 'config';  // 由于直接使用 axios 进行请求，统一封装了请求 baseUrl\nimport s from './style.module.less';\n\nconst UserInfo = () => {\n  const navigateTo = useNavigate(); // 路由实例\n  const [user, setUser] = useState({}); // 用户\n  const [avatar, setAvatar] = useState(''); // 头像\n  const [signature, setSignature] = useState(''); // 个签\n  const token = localStorage.getItem('token'); // 登录令牌\n\n  useEffect(() => {\n    getUserInfo(); // 初始化请求\n  }, []);\n\n  // 获取用户信息\n  const getUserInfo = async () => {\n    const { data } = await get('/api/user/get_userinfo');\n    setUser(data);\n    setAvatar(data.avatar)\n    setSignature(data.signature)\n  };\n\n  // 获取图片回调 \n  const handleSelect = (file) => {\n    console.log('file.file', file.file)\n    if (file && file.file.size > 200 * 1024) {\n      Toast.show('上传头像不得超过 200 KB！！')\n      return\n    }\n    let formData = new FormData()\n    // 生成 form-data 数据类型\n    formData.append('file', file.file)\n    // 通过 axios 设置  'Content-Type': 'multipart/form-data', 进行文件上传\n    axios({\n      method: 'post',\n      url: `${baseUrl}/upload`,\n      data: formData,\n      headers: {\n        'Content-Type': 'multipart/form-data',\n        'Authorization': token\n      }\n    }).then(res => {\n      // 返回图片地址\n      setAvatar(res.data)\n    })\n  }\n\n  // 编辑用户信息方法\n  const save = async () => {\n    const { data } = await post('/api/user/edit_userinfo', {\n      signature,\n      avatar\n    });\n\n    Toast.show('修改成功')\n    // 成功后回到个人中心页面\n    navigateTo(-1)\n  }\n\n  return <>\n    <Header title='用户信息' />\n    <div className={s.userinfo}>\n      <h1>个人资料</h1>\n      <div className={s.item}>\n        <div className={s.title}>头像</div>\n        <div className={s.avatar}>\n          <img className={s.avatarUrl} src={avatar} alt=\"\"/>\n          <div className={s.desc}>\n            <span>支持 jpg、png、jpeg 格式大小 200KB 以内的图片</span>\n            <FilePicker className={s.filePicker} onChange={handleSelect} accept=\"image/*\">\n              <Button className={s.upload} theme='primary' size='xs'>点击上传</Button>\n            </FilePicker>\n          </div>\n        </div>\n      </div>\n      <div className={s.item}>\n        <div className={s.title}>个性签名</div>\n        <div className={s.signature}>\n          <Input\n            clearable\n            type=\"text\"\n            value={signature}\n            placeholder=\"请输入个性签名\"\n            onChange={(value) => setSignature(value)}\n          />\n        </div>\n      </div>\n      <Button onClick={save} style={{ marginTop: 50 }} block theme='primary'>保存</Button>\n    </div>\n  </>\n};\n\nexport default UserInfo;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["详细的注释信息，已经在上述代码中表明，需要注意的是，本次请求直接使用了 ",(0,r.jsx)(n.code,{children:"axios"})," 方法，所以我们需要将 ",(0,r.jsx)(n.code,{children:"baseUrl"})," 单独封装到一个配置文件中，便于后续使用，在 ",(0,r.jsx)(n.code,{children:"src"})," 目录下新建 ",(0,r.jsx)(n.code,{children:"config/index.js"}),"，添加如下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MODE = import.meta.env.MODE // 环境变量\n\nexport const baseUrl = MODE == 'development' ? '/api' : 'http://api.chennick.wang';\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"MODE"})," 作为 ",(0,r.jsx)(n.code,{children:"vite"})," 运行时的环境变量，可以通过它来配置开发环境和生成环境的一些变量差异。"]}),"\n",(0,r.jsxs)(n.p,{children:["然后需要在 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 中修改如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'), // src 路径\n      'utils': path.resolve(__dirname, 'src/utils'), // src 路径\n      'config': path.resolve(__dirname, 'src/config') // src 路径\n    }\n  },\n"})}),"\n",(0,r.jsxs)(n.p,{children:["配置好 ",(0,r.jsx)(n.code,{children:"config"})," ，便可以直接在代码中通过："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { baseUrl } from 'config';\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上述形式来获取 ",(0,r.jsx)(n.code,{children:"config"})," 中的变量信息。"]}),"\n",(0,r.jsx)(n.p,{children:"重启项目，浏览器展示效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["通过请求，得到的路径是这样的，因为我们在服务端返回的地址就是一个相对路径，所以我们需要给路径加上 ",(0,r.jsx)(n.code,{children:"host"}),"，要注意如果你是本地启动的服务端代码，这里的 ",(0,r.jsx)(n.code,{children:"host"})," 就是你的服务端代码启动的 ",(0,r.jsx)(n.code,{children:"host"}),"，如 ",(0,r.jsx)(n.code,{children:"locahost:7001"}),"，而我目前使用的是在线接口，所以我们在 ",(0,r.jsx)(n.code,{children:"utils/index.js"})," 下新增一个图片地址转换的方法，如下所示："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// utils/index.js\nimport { baseUrl } from 'config'\nconst MODE = import.meta.env.MODE // 环境变量\n...\nexport const imgUrlTrans = (url) => {\n  if (url && url.startsWith('http')) {\n    return url\n  } else {\n    url = `${MODE == 'development' ? 'http://api.chennick.wang' : baseUrl}${url}`\n    return url\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后在 ",(0,r.jsx)(n.code,{children:"UserInfo/index.jsx"})," 中引入 ",(0,r.jsx)(n.code,{children:"imgUrlTrans"})," 并如下使用："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 获取用户信息\nconst getUserInfo = async () => {\n  const { data } = await get('/api/user/get_userinfo');\n  setUser(data);\n  setAvatar(imgUrlTrans(data.avatar))\n  setSignature(data.signature)\n};\n\n... \n\n// 返回图片地址\nsetAvatar(imgUrlTrans(res.data))\n"})}),"\n",(0,r.jsx)(n.p,{children:"再次打开浏览器，点击选择图片如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"保存后，数据成功修改，我们如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsxs)(n.h4,{id:"重置密码",children:["重置密码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重置密码",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["完成用户信息编辑之后，接下来实现重置密码部分，我们在 ",(0,r.jsx)(n.code,{children:"container"})," 目录下新建 ",(0,r.jsx)(n.code,{children:"Account"})," 目录，在内部分别新建 ",(0,r.jsx)(n.code,{children:"index.jsx"})," 和 ",(0,r.jsx)(n.code,{children:"style.module.less"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["首先我们需要安装 ",(0,r.jsx)(n.code,{children:"rc-form"})," 作为本次页面的表单组件，因为 ",(0,r.jsx)(n.code,{children:"Zarm"})," 没有提供表单组件，包括 ",(0,r.jsx)(n.code,{children:"Antd Mobile"})," 这样的组件，也没有提供表单相关的组件，所以这里我们需要使用 ",(0,r.jsx)(n.code,{children:"rc-form"})," 自己编写表单相关验证方法，它也是 ",(0,r.jsx)(n.code,{children:"antd"})," 官方使用的表单组件。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i rc-form -S\n"})}),"\n",(0,r.jsxs)(n.p,{children:["我们为 ",(0,r.jsx)(n.code,{children:"Account/index.jsx"})," 添加如下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Account/index.jsx\nimport React from 'react';\nimport { Cell, Input, Button, Toast } from 'zarm';\nimport { createForm  } from 'rc-form';\nimport Header from '@/components/Header'\nimport { post } from '@/utils'\n\nimport s from './style.module.less'\n\nconst Account = (props) => {\n  // Account 通过 createForm 高阶组件包裹之后，可以在 props 中获取到 form 属性\n  const { getFieldProps, getFieldError } = props.form;\n\n  // 提交修改方法\n  const submit = () => {\n    // validateFields 获取表单属性元素\n    props.form.validateFields(async (error, value) => {\n      // error 表单验证全部通过，为 false，否则为 true\n      if (!error) {\n        console.log(value)\n        if (value.newpass != value.newpass2) {\n          Toast.show('新密码输入不一致');\n          return\n        }\n        await post('/api/user/modify_pass', {\n          old_pass: value.oldpass,\n          new_pass: value.newpass,\n          new_pass2: value.newpass2\n        })\n        Toast.show('修改成功')\n      }\n    });\n  }\n\n  return <>\n    <Header title=\"重制密码\" />\n    <div className={s.account}>\n      <div className={s.form}>\n        <Cell title=\"原密码\">\n          <Input\n            clearable\n            type=\"text\"\n            placeholder=\"请输入原密码\"\n            {...getFieldProps('oldpass', { rules: [{ required: true }] })}\n          />\n        </Cell>\n        <Cell title=\"新密码\">\n          <Input\n            clearable\n            type=\"text\"\n            placeholder=\"请输入新密码\"\n            {...getFieldProps('newpass', { rules: [{ required: true }] })}\n          />\n        </Cell>\n        <Cell title=\"确认密码\">\n          <Input\n            clearable\n            type=\"text\"\n            placeholder=\"请再此输入新密码确认\"\n            {...getFieldProps('newpass2', { rules: [{ required: true }] })}\n          />\n        </Cell>\n      </div>\n      <Button className={s.btn} block theme=\"primary\" onClick={submit}>提交</Button>\n    </div>\n  </>\n};\n\nexport default createForm()(Account);\n"})}),"\n",(0,r.jsx)(n.p,{children:"样式代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:".account {\n  padding: 0 12px;\n  .form {\n    :global {\n      .za-cell:after {\n        left: unset;\n        border-top: unset;\n        border-bottom: 1PX solid #e9e9e9;\n      }\n    }\n  }\n  .btn {\n    margin-top: 50px;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里要注意，",(0,r.jsx)(n.code,{children:"Account"})," 在抛出去的时候，需要用 ",(0,r.jsx)(n.code,{children:"createForm()"})," 高阶组件进行包裹，这样在 ",(0,r.jsx)(n.code,{children:"Account"})," 的内部能接收到 ",(0,r.jsx)(n.code,{children:"form"})," 属性，它的内部提供了 ",(0,r.jsx)(n.code,{children:"getFieldProps"})," 方法，对 ",(0,r.jsx)(n.code,{children:"Input"})," 组件进行表单设置，",(0,r.jsx)(n.code,{children:"Input"})," 的 ",(0,r.jsx)(n.code,{children:"onChange"})," 方法会被代理，最终可以通过 ",(0,r.jsx)(n.code,{children:"form.validateFields"})," 以回到函数的形式拿到 ",(0,r.jsx)(n.code,{children:"Input"})," 内的值，并且可以加以验证。"]}),"\n",(0,r.jsx)(n.p,{children:"别忘记在路由配置项中添加相应的路由："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// router/index.js \n... \nimport Account from '@/container/Account'\n\n... \n{\n  path: \"/account\",\n  component: Account\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"页面展示如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["这里为了方便查看效果，输入框就不以密码的形式隐藏输入了，点击「提交」按钮之后，接口调用成功，但是我为 ",(0,r.jsx)(n.code,{children:"admin"})," 账户在服务端设置了不能修改密码的权限，这里方便大家测试页面方便，不能随意修改密码。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"测试账号：admin，密码：111111"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"退出登录",children:["退出登录",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#退出登录",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["退出登录操作，我的处理方式是将本地的 ",(0,r.jsx)(n.code,{children:"token"})," 清除，并且回到登录页面，简单粗暴了一些，但也不失为一个解决方案。"]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"User/index.jsx"})," 下添加代码如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const User = () => {\n  // 退出登录\n  const logout = async () => {\n    localStorage.removeItem('token');\n    navigateTo('/login');\n  };\n\n  return <div className={s.user}>\n    ... \n    <Button className={s.logout} block theme=\"danger\" onClick={logout}>退出登录</Button>\n  </div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"样式如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:".logout {\n  width: 90%;\n  position: absolute;\n  bottom: 70px;\n  left: 50%;\n  transform: translateX(-50%);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"通过绝对定位将按钮定位在底部，我们尝试点击它，如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["再次点击登录，发现没有自动前往首页，我们这里对登录页面进行修改，打开 ",(0,r.jsx)(n.code,{children:"Login/index.jsx"}),"，做如下修改："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const { data } = await post('/api/user/login', {\n  username,\n  password\n});\nconsole.log('data', data)\nlocalStorage.setItem('token', data.token);\nwindow.location.href = '/'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这里之所以用 ",(0,r.jsx)(n.code,{children:"window.location.href"})," 的原因是，",(0,r.jsx)(n.code,{children:"utils/axios.js"})," 内部需要再次被执行，才能通过 ",(0,r.jsx)(n.code,{children:"localStorage.getItem"})," 拿到最新的 ",(0,r.jsx)(n.code,{children:"token"}),"。如果只是用 ",(0,r.jsx)(n.code,{children:"navigateTo"})," 跳转页面的话，页面是不会被刷新，那么 ",(0,r.jsx)(n.code,{children:"axios.js"})," 的 ",(0,r.jsx)(n.code,{children:"token"})," 就无法设置。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"实战部分到此结束，同学们若是在实战中遇到了问题，请前往课程的官方交流群，群里有与你志同道合的同学，以及本人也会在群里为大家排忧解难。"})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}let v=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F20.%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E4%B8%AA%E4%BA%BA%E4%B8%AD%E5%BF%83.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"知识点",id:"知识点",depth:4},{text:"正文",id:"正文",depth:2},{text:"头部信息展示",id:"头部信息展示",depth:4},{text:"用户信息相关操作",id:"用户信息相关操作",depth:4},{text:"重置密码",id:"重置密码",depth:4},{text:"退出登录",id:"退出登录",depth:4},{text:"总结",id:"总结",depth:2}],title:"20.前端实战：个人中心",headingTitle:"20.前端实战：个人中心",frontmatter:{}}}}]);