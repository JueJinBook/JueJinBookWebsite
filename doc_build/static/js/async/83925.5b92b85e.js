"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["83925"],{539166:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var a=r(552676),t=r(740453);let i=r.p+"static/image/20472e61df1039b125cb8b486aa39be4.46b255ef.webp",s=r.p+"static/image/b6282abfe72fe2279e5e1cc7e7aa12c4.c75894a9.webp",h=r.p+"static/image/8c4e2638ac4e56c29c279988ac2272ac.704ab536.webp",c=r.p+"static/image/585cae22bb3bc4019b18921efda05360.387c5412.webp",d=r.p+"static/image/435f9f1b097143a41293329ae068a346.c2ba09fe.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",h2:"h2",code:"code",h3:"h3",ul:"ul",li:"li",img:"img",h4:"h4",br:"br",pre:"pre"},(0,t.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"21中级进阶-----坐标系变换观察空间变换到裁剪空间",children:["21.中级进阶 --- 坐标系变换：观察空间变换到裁剪空间",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21中级进阶-----坐标系变换观察空间变换到裁剪空间",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"上节介绍了世界空间到观察空间（相机空间）的视图变换，本节介绍下一个转换步骤：观察空间到裁剪空间的投影变换。"}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"观察空间也称为相机空间。"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"投影变换，顾名思义，就是将 3D 坐标投影到 2D 平面的过程。上节我们讲到，观察空间也沿用了右手坐标系，即 Z轴正向朝向屏幕外侧，但是裁剪坐标系是左手坐标系，即 Z 轴正向朝向屏幕内侧，那么在投影变换阶段，我们除了要将 3D 坐标投影到 2D 平面，还要将右手坐标系变换成左手坐标系。"}),"\n",(0,a.jsxs)(n.h2,{id:"投影分类",children:["投影分类",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#投影分类",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["业界有两种常用的投影方式：",(0,a.jsx)(n.code,{children:"正交投影"}),"、",(0,a.jsx)(n.code,{children:"透视投影"}),"。"]}),"\n",(0,a.jsxs)(n.h3,{id:"正交投影",children:["正交投影",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正交投影",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"正交投影，又名平行投影，常用在机械制图、施工图纸领域，投影后的比例和投影前的比例一致。"}),"\n",(0,a.jsxs)(n.h3,{id:"透视投影",children:["透视投影",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#透视投影",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"透视投影多用在成像领域，比如人看世界、相机拍照等场景，这个场景有一个特点就是投影后能够实现近大远小的效果。"}),"\n",(0,a.jsxs)(n.h2,{id:"投影原理",children:["投影原理",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#投影原理",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"正交投影和透视投影的原理大体相同，基本过程如下："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"首先指定可视范围，即什么范围内的物体能投影。此过程通过指定近平面和远平面来圈定范围。"}),"\n",(0,a.jsx)(n.li,{children:"将可视范围内的所有物体坐标投影到近平面上，投影后的坐标根据相似三角形原理求得，比较简单。"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"不同之处："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"正交投影的投影线是平行线，可视范围是一个立方体盒子。"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"透视投影的投影线是相交线，可视范围是一个棱锥体盒子，这样经过投影后才能达到近大远小的效果。"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"如下图所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"上面两种投影坐标系原点均位于投影盒正中心位置，因为是左手坐标系，所以，Z轴朝向屏幕内侧。"}),"\n",(0,a.jsxs)(n.h2,{id:"投影算法推导",children:["投影算法推导",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#投影算法推导",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"接下来，我们推导一下投影变换算法。假设模型中有一点 P，且P的坐标为 （x,y,z），那么投影到近平面后的坐标P' = （x',y',z'）。那么 P'和P 之间的关系是什么呢？"}),"\n",(0,a.jsx)(n.p,{children:"我们已知的条件有以下几个："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"近平面的 z 值 zNear。"}),"\n",(0,a.jsx)(n.li,{children:"近平面的宽度 width 和高度 height。"}),"\n",(0,a.jsx)(n.li,{children:"远平面的 z 值 zFar。"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"zFar 和 zNear 是相机坐标系中的Z轴坐标，由于相机坐标系是右手坐标系，Z轴朝向屏幕外侧，所以 zNear 是大于 zFar 的，这点在做坐标转换时需要注意。"}),"\n",(0,a.jsx)(n.p,{children:"接下来分析一下如何根据这些已知条件推导出 P'坐标，当推导出 P' 坐标之后，也就有了相应地投影矩阵。"}),"\n",(0,a.jsxs)(n.h3,{id:"正交投影-1",children:["正交投影",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正交投影-1",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"通过上面的示意图，我们能看到，正交投影盒中的一点 P(x, y, z)，其中："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"x坐标在【-width/2, width / 2】之间，通常我们不指定width，而是指定相机坐标系下的投影盒的左右两侧坐标，left和right。"}),"\n",(0,a.jsx)(n.li,{children:"y坐标在【-height/2， height/2】之间，通常我们不指定height，而是指定相机坐标系下的投影盒的左右两侧坐标，top和bottom。"}),"\n",(0,a.jsx)(n.li,{children:"z坐标在【zNear，zFar】之间。"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"投影后的点 P'（x',y',z'），其中："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"x' 在【-1，1】之间"}),"\n",(0,a.jsx)(n.li,{children:"y' 在【-1，1】之间"}),"\n",(0,a.jsx)(n.li,{children:"z' 在【-1，1】之间"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"我们最终需要一个矩阵M，使用该矩阵左乘顶点向量 P，即可得到P'。"}),"\n",(0,a.jsx)(n.p,{children:"按照惯例，我们还是找出P'和P之间的关系："}),"\n",(0,a.jsxs)(n.h4,{id:"x-和-x-的关系",children:["x' 和 x 的关系：",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#x-和-x-的关系",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nx'&= \\frac{x - (left + right)/2} {(right - left)/2} \\",(0,a.jsx)(n.br,{}),"\n","&= \\frac{2x}{right - left}  - \\frac{right + left}{right - left}\n\\end{aligned}\n$"]}),"\n",(0,a.jsxs)(n.h4,{id:"y和y的关系",children:["y'和y的关系",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#y和y的关系",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\ny'&= \\frac{y - (top + bottom)/2} {(top - bottom)/2} \\",(0,a.jsx)(n.br,{}),"\n","&= \\frac{2y}{top - bottom}  - \\frac{top + bottom}{top - bottom}\n\\end{aligned}\n$"]}),"\n",(0,a.jsxs)(n.h4,{id:"z-和-z-的关系",children:["z' 和 z 的关系",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#z-和-z-的关系",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nz'&= \\frac{z - (zFar + zNear)/2} {(zNear - zFar)/2} \\",(0,a.jsx)(n.br,{}),"\n","&= \\frac{2z}{zNear - zFar}  - \\frac{zFar + zNear}{zNear - zFar}\n\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"找出 P'和P之间的关系之后，我们就能够将这个关系用矩阵表示出来，还记得我们的矩阵生成公式吗？"}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nM = \\begin{pmatrix}\nx'_x & y'_x & z'_x & t_x' \\",(0,a.jsx)(n.br,{}),"\n","x'_y & y'_y & z'_y & t_y' \\",(0,a.jsx)(n.br,{}),"\n","x'_z & y'_z & z'_z & t_z' \\",(0,a.jsx)(n.br,{}),"\n","0 & 0 & 0 & 1\n\\end{pmatrix}\n\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"将上面的 x'、y'、z'代入上式，即可求出正交投影矩阵："}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nM = \\begin{pmatrix}\n\\frac{2}{right - left} & 0 & 0 & \\frac{right + left}{left - right} \\",(0,a.jsx)(n.br,{}),"\n","0 & \\frac{2}{top - bottom} & 0 & \\frac{top + bottom}{bottom - top} \\",(0,a.jsx)(n.br,{}),"\n","0 & 0 & \\frac{2}{zNear - zFar} & \\frac{zFar + zNear}{zNear - zFar}  \\",(0,a.jsx)(n.br,{}),"\n","0 & 0 & 0 & 1 \\",(0,a.jsx)(n.br,{}),"\n","\\end{pmatrix}\n\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"以上就是正交投影变换矩阵的推导过程，很简单。"}),"\n",(0,a.jsx)(n.p,{children:"那么，有了矩阵表示方式，正交投影算法就能够实现了。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function ortho(left, right, bottom, top, near, far, target){\n  target = target || new Float32Array(16);\n\n  target[0] = 2 / (right - left);\n  target[1] = 0;\n  target[2] = 0;\n  target[3] = 0;\n  target[4] = 0;\n  target[5] = 2 / (top - bottom);\n  target[6] = 0;\n  target[7] = 0;\n  target[8] = 0;\n  target[9] = 0;\n  target[10] = 2 / (near - far);\n  target[11] = 0;\n  target[12] = (left + right) / (left - right);\n  target[13] = (bottom + top) / (bottom - top);\n  target[14] = (near + far) / (near - far);\n  target[15] = 1;\n\n  return target;\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"实践",children:["实践",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实践",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"我们用一个立方体来演示一下，你会发现，无论远平面距离多远，立方体的大小是不会变的。"}),"\n",(0,a.jsx)(n.p,{children:"我们将摄像机放在 Z 轴正向 20 个单位处，Y轴正向为上方，看向坐标系原点，同时将\n投影盒设置为一个上下左右边界坐标在【 -5，5】之间，近平面坐标为 20， 远平面坐标为 -20 的立方体。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"var cube = createCube(3, 3, 3);\nvar cameraPosition = {x: 0, y: 0, z: 20};\nvar target ={x: 0, y: 0, z: 0};\nvar up = {x: 0, y: 1, z: 0};\nvar cameraMatrix = matrix.lookAt(cameraPosition, target, up);\nvar viewMatrix = matrix.inverse(cameraMatrix);\nvar projectionMatrix = matrix.ortho(-5, 5, -5, 5, -20，20);\n...略\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，无论我们将镜头移到多远，物体投影后的大小始终不变。"}),"\n",(0,a.jsx)(n.p,{children:"那么什么会影响物体投影后的大小呢？有的同学已经猜到了，投影盒的宽度和高度。"}),"\n",(0,a.jsx)(n.p,{children:"我们试一下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:s,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"可以看到，将宽度和高度增大之后，物体投影后变小了。"}),"\n",(0,a.jsxs)(n.h3,{id:"透视投影-1",children:["透视投影",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#透视投影-1",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"透视投影是我们比较常用的投影方式，它能够实现现实生活中人眼看向世界产生的近大远小的效果。接下来我们推导一下透视算法。"}),"\n",(0,a.jsx)(n.p,{children:"和正交投影类似，透视投影也接收近平面和远平面参数，不同的是，透视投影的投影盒是一个棱锥体。正因为如此，透视投影才可以实现近大远小的效果。"}),"\n",(0,a.jsx)(n.p,{children:"通过上面透视投影示例图，根据相似三角形原理，我们可以知道如下关系："}),"\n",(0,a.jsx)(n.p,{children:"$\n\\frac{zNear}{z} = \\frac{y_1}{y} = \\frac{x_1}{x}\n$"}),"\n",(0,a.jsxs)(n.p,{children:["所以有\n$\n\\begin{aligned}\nx_1 = \\frac{zNear * x}{z} \\",(0,a.jsx)(n.br,{}),"\n","y_1 = \\frac{zNear * y}{z}\n\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"其中 $x_1$和$y_1$是相机坐标系坐标经过视线看向物体后在近平面上的交点坐标，此时 $x_1$和$y_1$还是相机坐标系下坐标，并没有变换到裁剪坐标系，我们还要将$x_1$和$y_1$变换到【-1，1】之间。"}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nx' = \\frac{x_1}  {z * width /2} = \\frac{zNear * x}  {z * width /2} \\",(0,a.jsx)(n.br,{}),"\n","\\",(0,a.jsx)(n.br,{}),"\n","y' = \\frac{y_1}  {z * height /2} = \\frac{zNear * y}  {z * height /2} \\",(0,a.jsx)(n.br,{}),"\n","\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"又由于投影坐标系和相机坐标系 Z 轴相反，所以需要对Z轴坐标取反。"}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nx' = - \\frac{zNear * x}  {z * width /2} \\",(0,a.jsx)(n.br,{}),"\n","\\",(0,a.jsx)(n.br,{}),"\n","y' = - \\frac{zNear * y}  {z * height /2} \\",(0,a.jsx)(n.br,{}),"\n","\\end{aligned}\n$\n看到这里，你会发现，x' 和 y' 不仅和投影面的宽度和高度有关系，还和 z 轴坐标有关系，z 轴坐标越大，x'和 y' 越小，也就产生了近大远小的效果，我们将齐次坐标 w 分量设置为 z，此时 x' 和 y' 的值为"]}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nx' = - \\frac{zNear * x}  {width /2} \\",(0,a.jsx)(n.br,{}),"\n","\\",(0,a.jsx)(n.br,{}),"\n","y' = - \\frac{zNear * y}  {height /2} \\",(0,a.jsx)(n.br,{}),"\n","\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"接下来，我们看下 z' 和 z 之间的关系，因为是线性关系，所以：\n$\nz' = az + b;\n$"}),"\n",(0,a.jsx)(n.p,{children:"又因为齐次坐标w分量为 z，所以有\n$\nz' = a + b / z\n$\n其中 a和b 是常量，待求。"}),"\n",(0,a.jsx)(n.p,{children:"我们还知道当 z 为 zNear 时，裁剪空间 z 轴坐标为 -1，当 z 为 zFar 时，z轴坐标为 1，所以有如下两个等式：\n$\na + \\frac {b} { zNear} = -1\n$"}),"\n",(0,a.jsx)(n.p,{children:"$\na + \\frac {b}  {zFar} = 1\n$"}),"\n",(0,a.jsx)(n.p,{children:"解这两个方程，可以求出 a 和 b 的值："}),"\n",(0,a.jsx)(n.p,{children:"$\na = \\frac{zFar + zNear}{zFar - zNear}\n$"}),"\n",(0,a.jsx)(n.p,{children:"$\nb = \\frac{2 \\times zFar \\times zNear}{zFar - zNear}\n$"}),"\n",(0,a.jsx)(n.p,{children:"依然按照正交投影的参数，width 由 left和right决定，height 由top和bottom决定，\n根据上述推导过程，我们可以得出透视投影的变换矩阵 M"}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nM = \\begin{pmatrix}\n\\frac{2 \\times zNear}{right - left} & 0 & 0 & \\frac{right + left}{left - right} \\",(0,a.jsx)(n.br,{}),"\n","0 & \\frac{2 \\times zNear}{top - bottom} & 0 & \\frac{top + bottom}{bottom - top} \\",(0,a.jsx)(n.br,{}),"\n","0 & 0 & \\frac{2(zFar + zNear)}{zNear - zFar} & \\frac{2 \\times zFar \\times zNear}{zNear - zFar}  \\",(0,a.jsx)(n.br,{}),"\n","0 & 0 & -1 & 0\n\\end{pmatrix}\n\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"有了推导公式，算法的实现水到渠成："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function makePerspective(left, right, top, bottom, zNear, zFar, target){\n  target = target || new Float32Array(16);\n  var a = (2 * near) / (right - left);\n  var b = (2 * near) / (top - bottom);\n\n  var c = (right + left) / (right - left);\n  var d = (top + bottom) / (top - bottom);\n  var e = (zFar + zNear) / (zNear - zFar);\n  var f = (2 * zFar * zNear) / (zNear - zFar);\n\n  target[0] = a;\n  target[1] = 0;\n  target[2] = 0;\n  target[3] = 0;\n  \n  target[4] = 0;\n  target[5] = b;\n  target[6] = 0;\n  target[7] = 0;\n  \n  target[8] = c;\n  target[9] = d;\n  target[10] = e;\n  target[11] = -1;\n  \n  target[12] = 0;\n  target[13] = 0;\n  target[14] = f;\n  target[15] = 0;\n\n  return target;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["除了传递以left 、right、top、bottom 方式传递近平面参数以外，为了方便，业界往往用视角",(0,a.jsx)(n.code,{children:"fovy"})," 和宽高比 ",(0,a.jsx)(n.code,{children:"aspect"})," 的方式代替它们，推导过程和上面几乎一样，只不过我们以aspect 和 fovy角度 θ 来代替 x' 和 y'"]}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nx' &= \\frac {2 \\times zNear} {width}\\",(0,a.jsx)(n.br,{}),"\n","&=\\frac{1}{aspect \\times tan(\\theta/2)}\n\\end{aligned}\n$"]}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\ny' &= \\frac {2 \\times zNear} {height}\\",(0,a.jsx)(n.br,{}),"\n","&=\\frac{1}{tan(\\theta/2)}\n\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"所以这种方式下的透视投影矩阵为："}),"\n",(0,a.jsxs)(n.p,{children:["$\n\\begin{aligned}\nM = \\begin{pmatrix}\n\\frac{2 \\times zNear}{right - left} & 0 & 0 & \\frac{right + left}{left - right} \\",(0,a.jsx)(n.br,{}),"\n","0 & \\frac{2 \\times zNear}{top - bottom} & 0 & \\frac{top + bottom}{bottom - top} \\",(0,a.jsx)(n.br,{}),"\n","0 & 0 & \\frac{2(zFar + zNear)}{zNear - zFar} & \\frac{2 \\times zFar \\times zNear}{zNear - zFar}  \\",(0,a.jsx)(n.br,{}),"\n","0 & 0 & -1 & 0 \\",(0,a.jsx)(n.br,{}),"\n","\\end{pmatrix}\n\\end{aligned}\n$"]}),"\n",(0,a.jsx)(n.p,{children:"算法实现："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"function perspective(fovy, aspect, zNear, zFar, target){\n  var top = zNear * Math.tan((Math.PI / 180) * 0.5 * fovy),\n    height = 2 * top,\n    width = aspect * height,\n    left = -0.5 * width;\n  return perspective2(left, left + width, top, top - height, zNear, zFar, target);\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"实战演练",children:["实战演练",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实战演练",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"接下来，我们试试写的算法能不能正常工作。"}),"\n",(0,a.jsx)(n.p,{children:"首先，将摄像机放在 z 轴正向 20 单位处，然后采用透视投影，视角为 60 度，宽高比设置为屏幕宽高比。"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"var aspect = canvas.width / canvas.height;\nvar projectionMatrix = matrix.perspective(60, aspect, 1, 1000);\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsxs)(n.p,{children:["大家可以点击",(0,a.jsx)(n.a,{href:"/",children:"这里"}),"查看演示。"]}),"\n",(0,a.jsx)(n.p,{children:"可以看到，影响投影的因素有如下几个："}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"摄像机所在位置，距离越远，投影越小，反之，投影越大。"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"投影盒宽高比会影响显示比例。"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"视角会影响显示大小，视角越大，投影越小，反之，投影越大。"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.h4,{id:"css3-中的-perspective",children:["CSS3 中的 perspective",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css3-中的-perspective",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["不知道大家有没有发现，",(0,a.jsx)(n.code,{children:"perspective"})," 这个名词在 CSS3 中出现过，perspective 代表摄像机距离近平面的距离，增加了此属性，就能实现近大远小的透视效果。"]}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"其实它们的底层实现大体也是基于上面的算法。"}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"回顾",children:["回顾",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"以上就是投影矩阵的推导过程以及算法实现，建议大家拿笔在纸上推导一下，做到真正掌握，以后碰到一些坐标变换场合就能做到灵活运用。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F21.%E4%B8%AD%E7%BA%A7%E8%BF%9B%E9%98%B6%20---%20%E5%9D%90%E6%A0%87%E7%B3%BB%E5%8F%98%E6%8D%A2%EF%BC%9A%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2%E5%88%B0%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4.md"]={toc:[{text:"投影分类",id:"投影分类",depth:2},{text:"正交投影",id:"正交投影",depth:3},{text:"透视投影",id:"透视投影",depth:3},{text:"投影原理",id:"投影原理",depth:2},{text:"投影算法推导",id:"投影算法推导",depth:2},{text:"正交投影",id:"正交投影-1",depth:3},{text:"x' 和 x 的关系：",id:"x-和-x-的关系",depth:4},{text:"y'和y的关系",id:"y和y的关系",depth:4},{text:"z' 和 z 的关系",id:"z-和-z-的关系",depth:4},{text:"实践",id:"实践",depth:4},{text:"透视投影",id:"透视投影-1",depth:3},{text:"实战演练",id:"实战演练",depth:4},{text:"CSS3 中的 perspective",id:"css3-中的-perspective",depth:4},{text:"回顾",id:"回顾",depth:2}],title:"21.中级进阶 --- 坐标系变换：观察空间变换到裁剪空间",headingTitle:"21.中级进阶 --- 坐标系变换：观察空间变换到裁剪空间",frontmatter:{}}}}]);