"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["52357"],{596875:function(e,n,t){t.r(n),t.d(n,{default:()=>G});var s=t(552676),a=t(740453);let c=t.p+"static/image/838935772fce1aaae557fe5f4e686fb5.ef4b5656.webp",i=t.p+"static/image/50ee0ece60b3ae2be1aa7eeefa0851f4.b71c0a70.webp",r=t.p+"static/image/c159d5546db42bf6260b184c826bfd37.321a61d0.webp",l=t.p+"static/image/3f3596a03e976b0bc09f55be2c22907d.729c37e6.webp",d=t.p+"static/image/7962c58a066435c190070d88417611bf.4097fef9.webp",p=t.p+"static/image/7180c0ee3b62534912f15ac36a8ee011.28aa6a75.webp",m=t.p+"static/image/5063b99b8e4266cba470e56ee7f82c67.14c7a85c.webp",j=t.p+"static/image/a7cb19a10c4950d53ce4de362ac8fc77.c1005d1f.webp",x=t.p+"static/image/e165d8efe47f8ce34e7e400bb3253ead.c2f51b9c.webp",h=t.p+"static/image/946d3284e0d4244de9bc7dd55b5c209f.87e8f8cd.webp",b=t.p+"static/image/56950e37ec58093a52beaf1b90e2eeb0.419c33f5.webp",o=t.p+"static/image/f11fa671b09a70eaa04c906114199f6d.88815ce9.webp",u=t.p+"static/image/d305c16cdf08508342c4c1dcc7abc5a1.4e89fb5e.webp",g=t.p+"static/image/8a4fd85821225523b1a724bc86a79152.64aec3fc.webp",f=t.p+"static/image/74ef72760b1b1516173b4d83fe1ea422.0c126c47.webp",S=t.p+"static/image/4332d984ed34fc1ce8d958affecd6f12.6f6ae831.webp",w=t.p+"static/image/44232be5664e7a9bac736784b2be61a7.4f92961d.webp",E=t.p+"static/image/60ccdb04aa826713f406073b445a8cbb.75128c00.webp",y=t.p+"static/image/25953cd535b7288d6765f87906b9ebdc.9a769612.webp",k=t.p+"static/image/bcf07b737201e91a79933a381331cb25.d8959149.webp",I=t.p+"static/image/7c822a2de5414c872368611d25c9e01d.2bce5026.webp",J=t.p+"static/image/c800ef6f82655eb17ed7d16ac6ec40fd.ee49f6ae.webp",C=t.p+"static/image/bcaf900c6fbda5e6228ca398c180e4f4.deb93c31.webp",P=t.p+"static/image/6268ff6b5d38ca19ec36afe904e809b7.ef1d1ce8.webp",v=t.p+"static/image/6dac6c7de62df87eea5c8b6845331690.a09925ae.webp",R=t.p+"static/image/6ca77b73a029dfe43c031e78cc2da614.d8a27edc.webp",_=t.p+"static/image/21ec85b084ba7c54c52747405f7a697e.c68aa4d7.webp",A=t.p+"static/image/28c93642d2a1d56506718e6ef95d0c87.e3a513b7.webp",N=t.p+"static/image/4c3462b6b2547e8a58cc00fb3cc290cb.5d031d1a.webp",M=t.p+"static/image/4a5db9163f390e1e9d97a16e84785bfc.196dd9b8.webp",F=t.p+"static/image/79f43d0160eaad453eecd0f6a13ed584.252c59c8.webp",T=t.p+"static/image/4b1082be39efb3d882a54e7841927ef0.41833e4d.webp",D=t.p+"static/image/1ca25b99e02ee1798f00b31033a9dbf8.93ec54dd.webp",B=t.p+"static/image/b7ab3ae99d30c8c050ff8adce7f3b3ca.d8cdcaac.webp";function O(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",ul:"ul",li:"li",strong:"strong",h2:"h2"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"第42章数据不可变immutable和immer",children:["第42章—数据不可变：immutable和immer",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第42章数据不可变immutable和immer",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"\uFEFF假设 React 组件有这样一个状态："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"this.state = {\n    a: {\n        b: 1\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们这样修改了它的状态："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"this.state.a.b = 2;\nthis.setState(this.state);\n"})}),"\n",(0,s.jsx)(n.p,{children:"你觉得组件会重新渲染么？"}),"\n",(0,s.jsx)(n.p,{children:"我们先在 class 组件里试一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Component } from 'react';\n\nclass Dong extends Component {\n    constructor() {\n        super();\n\n        this.state = {\n            a: {\n                b: 1\n            }\n        }\n    }\n\n    componentDidMount() {\n        setTimeout(() => {\n            this.state.a.b = 2;\n            this.setState(this.state);\n        }, 2000);\n    }\n    render() {\n        return <div>{this.state.a.b}</div>\n    }\n}\n\nexport default Dong;\n"})}),"\n",(0,s.jsx)(n.p,{children:"渲染 state.a.b 的值，两秒以后修改 state。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你发现它重新渲染了，因为普通的 class 组件只要 setState 就会渲染。"}),"\n",(0,s.jsx)(n.p,{children:"但很多情况下我们需要做性能优化，只有 props 和 state 变了才需要渲染，这时候会继承 PureComponent，它和 memo 作用一样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"但这时候你就会发现组件不再重新渲染了。"}),"\n",(0,s.jsx)(n.p,{children:"说明这种情况下不能这样写 setState："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"先不着急探究原因，我们再在 function 组件里试一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from 'react';\n\nfunction Dong() {\n    const [state, setState] = useState({\n        a: {\n            b: 1\n        }\n    });\n\n    useEffect(() => {\n        setTimeout(() => {\n            state.a.b = 2;\n            setState(state)\n        }, 2000);\n    }, [])\n    return <div>{state.a.b}</div>\n}\n\nexport default Dong;\n"})}),"\n",(0,s.jsx)(n.p,{children:"这时候你觉得组件会重新渲染么？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:F,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"结果是不会重新渲染。"}),"\n",(0,s.jsx)(n.p,{children:"这说明 React 内部肯定对 function 组件还有继承 PureComponent 的 class 组件做了相应的处理。"}),"\n",(0,s.jsx)(n.p,{children:"那 React 都做了什么处理呢？"}),"\n",(0,s.jsx)(n.p,{children:"我们从源码看一下："}),"\n",(0,s.jsx)(n.p,{children:"首先是继承 PureComponent 的 class 组件："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你会发现 React 在更新 class 组件的时候，会判断如果是 PureComponent，那么会浅比较 props 和 state，如果变了才会渲染。"}),"\n",(0,s.jsx)(n.p,{children:"怎么浅比较的呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你会发现它先对比了两个值是否相等，如果不相等的话，再取出 key 来，对比每个 key 的值是否相等。"}),"\n",(0,s.jsx)(n.p,{children:"所以说，我们 setState 的时候传入 this.state 就不行了，第一个判断都过不去。"}),"\n",(0,s.jsx)(n.p,{children:"而且就算创建了新对象，如果每个 key 的值没有变，那依然也是不会渲染的。"}),"\n",(0,s.jsx)(n.p,{children:"这就是 React 对 PureComponent 做的优化处理。"}),"\n",(0,s.jsx)(n.p,{children:"再来看下 function 组件的，React 是怎么对它做的处理呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你会看到调用 useState 的 setXxx 时，React 会判断上次的 state 和这次的 state，如果一样，那就不会渲染，直接 return 了。"}),"\n",(0,s.jsx)(n.p,{children:"这是为什么 function 组件里 setState 上次的 state 不行的原因。"}),"\n",(0,s.jsx)(n.p,{children:"这两种情况还是有区别的，PureComponent 的处理里如果 state 变了，还会依次对比每个 key 的值，如果有某个值变了才会去渲染，但 function 组件里只对比了 state。"}),"\n",(0,s.jsx)(n.p,{children:"我们测试一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"用上图的方式 setState，整个 state 变了，但是 key 对应的值没有变。"}),"\n",(0,s.jsx)(n.p,{children:"在 PureComponent 的 class 组件里，按照我们的分析应该不会再渲染，只会打印一次 render："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"确实是这样，虽然 state 对象变了，但是 key 的值没变，不会重新渲染。"}),"\n",(0,s.jsx)(n.p,{children:"然后在 function 组件里试一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你会发现它打印了两次 render："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"综上，我们可以总结一下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"普通的 class 组件，setState 就会重新渲染"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"继承 PureComponent 的 class 组件，setState 时会对比 props 和 state 本身变没变，还会对比 state 的每个 key 的值变没变，变了才会重新渲染"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"function 组件在用 useState 的 setXxx 时，会对比 state 本身变没变，变了就会重新渲染"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"为什么 function 组件里只对比了 state 没有对比每个 key 的值也很容易理解，因为本来每个 state就是用 useState 单独声明的了，不像 class 组件的 state 都在一起。"}),"\n",(0,s.jsx)(n.p,{children:"知道了这个结论，我们也就知道了 setState 该怎么写了："}),"\n",(0,s.jsx)(n.p,{children:"class 组件要这么写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"state 的每个要修改的 key 的值，如果是个对象，那要创建一个新的对象才行。"}),"\n",(0,s.jsx)(n.p,{children:"function 组件里也是，要这么写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:J,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["综上，",(0,s.jsx)(n.strong,{children:"不管是 class 组件，还是 function 组件，setState 时都要创建新的 state，并且对应的 key 的值的时候，如果是对象，要创建新的对象（虽然普通 class 组件里可以不这么写，但还是建议统一用这种写法，不然容易引起困惑）。"})]}),"\n",(0,s.jsx)(n.p,{children:"但这样又有了一个新的问题："}),"\n",(0,s.jsx)(n.p,{children:"如果 state 的内容很多呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:I,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而你只想修改其中的一部分，要把整个对象复制一次："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"是不是很麻烦？"}),"\n",(0,s.jsx)(n.p,{children:"能不能我修改了对象的值，立马给我返回一个新的对象呢？"}),"\n",(0,s.jsx)(n.p,{children:"就是最开头的时候，我们的那种写法改造一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const newState = this.state.set('a.b', 2);\n\nthis.setState(newState);\n"})}),"\n",(0,s.jsx)(n.p,{children:"这么一个明显的痛点需求，自然就有相应的库了，也就是 immutable，这个是 facebook 官方出的，说是花了三年写的。"}),"\n",(0,s.jsx)(n.p,{children:"它有这么几个 api：fromJS、toJS、set、setIn、get、getIn。"}),"\n",(0,s.jsx)(n.p,{children:"我们试一下就知道了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const immutableObj = fromJS({\n    a: {\n        b: 1\n    }\n});\nconst newObj = immutableObj.get('a').set('b', 2);\n"})}),"\n",(0,s.jsx)(n.p,{children:"用 fromJS 把 JS 对象转成 immutable 内部的数据结构，然后 get a，再 set b 的值。"}),"\n",(0,s.jsx)(n.p,{children:"这样返回的是 immutable 的数据结构，并且对 b 做了修改："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"你和之前的 a 属性的值对比下，发现也不一样了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是它的作用，修改值以后返回新的 immutable 数据结构。"}),"\n",(0,s.jsx)(n.p,{children:"那如果像修改一个层数比较深的值，但希望返回的值是整个对象的新的 immutable 结构呢？"}),"\n",(0,s.jsx)(n.p,{children:"可以用 setIn："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样修改了任意属性之后，都能拿到最新的对象，这不就完美解决了我们的痛点问题么？"}),"\n",(0,s.jsx)(n.p,{children:"你还可以用 toJS 再把 immutable 数据结构转成 JS 对象："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"再来回顾下 immutable 的 api： fromJS、toJS、set、get、setIn、getIn 这些都很容易理解。再就是 immutable 内部的数据结构 Map、Set 等。（注意这里的 Map、Set 不是 JS 里的那个，而是 immutable 实现的）"}),"\n",(0,s.jsx)(n.p,{children:"这些 immutable 数据结构一般不大需要手动创建，直接用 fromJS 让 immutable 去创建就行。"}),"\n",(0,s.jsx)(n.p,{children:"然后我们在 React 组件里用一下试试："}),"\n",(0,s.jsx)(n.p,{children:"先在 class 组件里用用："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"a 的值是个对象，我们用 fromJS 转成 immutable 的数据结构，之后修改调用 set 或 setIn 来修改。"}),"\n",(0,s.jsx)(n.p,{children:"不过，渲染的时候也得用 get、getIn 的 api 来取了。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样也解决了 setState 需要创建新对象的问题，而且更优雅。"}),"\n",(0,s.jsx)(n.p,{children:"有的同学可能会问，为什么要 sate.a 用 fromJS 转成 immutable，而不是整个 state 呢？"}),"\n",(0,s.jsx)(n.p,{children:"因为 react 内部也会用到这个 state 呀，就比如上面那个浅比较那里："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["react 需要把每个 key 的值取出来对比下变没变，而 immutable 对象只能用 get、getIn 来取，所以",(0,s.jsx)(n.strong,{children:"class 组件里不能把整个 state 变为 immutable，只能把某个 key 值的对象变为 immutable"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"再在 function 组件里用下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"function 组件里就可以这样写了，把整个 state 用 fromJS 变为 immutable 的，然后后面修改用 setIn，获取用 getIn。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"也同样解决了 setState 要创建新对象的问题。"}),"\n",(0,s.jsx)(n.p,{children:"为啥 function 组件里就可以把整个 state 变为 immutable 的了呢？"}),"\n",(0,s.jsx)(n.p,{children:"因为只有组件内部会用呀，我们自己写的代码是知道用 setIn、getIn 来操作的，但是 class 组件的话 react 还会对 PureComponent 做一些优化，会在组件外把 state 取出来处理，所以那个就只能把某些 key 变为 immutable 了。"}),"\n",(0,s.jsx)(n.p,{children:"immutable 介绍完了，大家觉得怎么样？"}),"\n",(0,s.jsx)(n.p,{children:"immutable 确实解决了创建新对象的复杂度的问题，而且性能也好，因为它创建了一套自己的数据结构。"}),"\n",(0,s.jsx)(n.p,{children:"但也相应的，导致使用的时候必须要用 getIn、setIn 的 api 才行，有一些心智负担。"}),"\n",(0,s.jsx)(n.p,{children:"这种心智负担是不可避免的吧？"}),"\n",(0,s.jsx)(n.p,{children:"还真可以，这几年又出了一个新的 immutable 库，叫做 immer（MobX 作者写的）。它就覆盖了 immutable 的功能的同时，还没有心智负担。"}),"\n",(0,s.jsx)(n.p,{children:"没有心智负担？怎么可能？"}),"\n",(0,s.jsx)(n.p,{children:"我们试一下就知道了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { produce } from 'immer';\n\nconst obj = {\n    a: {\n        b: 1\n    }\n};\n\nconst obj2 = produce(obj, draft => {\n    draft.a.b = 2 \n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"obj 是原对象，调用 produce 传入该对象和要对它做的修改，返回值就是新对象："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"后面就是普通 JS 对象的用法，也不用啥 getIn、setIn 啥的。"}),"\n",(0,s.jsx)(n.p,{children:"我们在 class 组件里用一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"setState 的时候调用 produce，传入原来的 state 和修改函数，这样返回的就是新的 state。"}),"\n",(0,s.jsx)(n.p,{children:"用 state 的时候依然是普通 JS 对象的用法。是不是简单的一批，心智负担基本为 0？"}),"\n",(0,s.jsx)(n.p,{children:"我们再在 function 组件里用一下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"同样简单的一批，只要 setState 的时候调用下 produce 来产生新对象就行。"}),"\n",(0,s.jsx)(n.p,{children:"又学完了 immer，我们来对比下 immutable 和 immer："}),"\n",(0,s.jsx)(n.p,{children:"直接看图吧："}),"\n",(0,s.jsx)(n.p,{children:"class 组件里，immutable 这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"immer 这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"function 组件里，immutable 这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"immer 这样写："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"没有对比就没有伤害，从使用体验上，immer 完胜。"}),"\n",(0,s.jsx)(n.p,{children:"这么说，我们只用 immer 不就行了？"}),"\n",(0,s.jsx)(n.p,{children:"也不全是，90% 的场景下用 immer 就行，但 immutable 也有它独特的优点："}),"\n",(0,s.jsx)(n.p,{children:"immutable 有自己的数据结构，修改数据的时候会创建新的节点连接之前的节点组成新的数据结构。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而 immer 没有自己的数据结构，它只是通过 Proxy 实现了代理，内部自动创建新的对象："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"只不过是把手动创建新对象的过程通过代理给自动化了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"所以从性能上来说，如果有特别大的 state 的话，immutable 会好一些，因为他用的是专用数据结构，做了专门的优化，除此以外，immer 更好一些。"}),"\n",(0,s.jsx)(n.p,{children:"综上，90% 的 React 应用，用 immer 比 immutable 更好一些，代码写起来简单，也更容易维护。有大 state 的，可以考虑 immutable。"}),"\n",(0,s.jsx)(n.p,{children:"此外，immutable 在 redux 里也很有用的："}),"\n",(0,s.jsx)(n.p,{children:"用 immutable 的话是这样写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const initialState = fromJS({})\n\nfunction reducer(state = initialState, action) {\n  switch (action.type) {\n    case SET_NAME:\n      return state.set('name', 'guang')\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"取 store 的 state 要用 getIn 或 get："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function mapStateToProps(state) {\n    return {\n      xxxx: state.getIn(['guangguang', 'guang']),\n      yyyy: state.getIn(['dongdong', 'dong'])\n    }\n  }\n"})}),"\n",(0,s.jsx)(n.p,{children:"而 immer 是这样写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const reducer = produce((state = initialState, action) => {\n  switch (action.type) {\n    case SET_NAME:\n      state.name = 'guang';\n      break;\n    default:\n      return state\n  }\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"用 store 的 state 是普通对象的用法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function mapStateToProps(state) {\n    return {\n      xxxx: state.guangguang,\n      yyyy: state.dongdong\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"从结合 redux 的角度来看，也是 immer 在体验上完胜。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 React 组件里 setState 是要创建新的 state 对象的，在继承 PureComponent 的 class 组件、function 组件都是这样。"}),"\n",(0,s.jsx)(n.p,{children:"继承 PureComponent 的 class 组件会浅对比 props 和 state，如果 state 变了，并且 state 的 key 的某个值变了，才会渲染。"}),"\n",(0,s.jsx)(n.p,{children:"function 组件的 state 对象变了就会重新渲染。"}),"\n",(0,s.jsx)(n.p,{children:"虽然在普通 class 组件里，不需要创建新的 state，但我们还是建议统一，所有的组件里的 setState 都创建新的对象。"}),"\n",(0,s.jsx)(n.p,{children:"但是创建对象是件比较麻烦的事情，要一层层 ...，所以我们会结合 immutable 的库。"}),"\n",(0,s.jsx)(n.p,{children:"主流的 immutable 库有两个， facebook 的 immutable 和 MobX 作者写的 immer。"}),"\n",(0,s.jsx)(n.p,{children:"immutable 有自己的数据结构，Map、Set 等，有 fromJS、toJS 的 api 用来转换 immutable 数据结构和普通 JS 对象，操作数据需要用 set、setIn、get、getIn。"}),"\n",(0,s.jsx)(n.p,{children:"immer 只有一个 produce api，传入原对象和修改函数，返回的就是新对象，使用新对象就是普通 JS 对象的用法。"}),"\n",(0,s.jsx)(n.p,{children:"要注意在 class 组件里，只能 state 的某个 key 的值变为 immutable，而不能整体变为 immtable，因为 React 内部会用到。"}),"\n",(0,s.jsx)(n.p,{children:"从使用体验上来说，不管是和 react 的 setState 结合还是和 redux 的 reducer 结合，都是 immer 完胜，但是 immutable 因为有专用数据结构的原因，在有大 state 对象的时候，性能会好一些。"}),"\n",(0,s.jsx)(n.p,{children:"90% 的情况下，immer 能完胜 immutable。"})]})}function X(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(O,{...e})}):O(e)}let G=X;X.__RSPRESS_PAGE_META={},X.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC42%E7%AB%A0%E2%80%94%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%9Aimmutable%E5%92%8Cimmer.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第42章—数据不可变：immutable和immer",headingTitle:"第42章—数据不可变：immutable和immer",frontmatter:{}}}}]);