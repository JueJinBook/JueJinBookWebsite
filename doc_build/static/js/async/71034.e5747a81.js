"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["71034"],{761315:function(e,n,s){s.r(n),s.d(n,{default:()=>p});var i=s(552676),r=s(740453);let a=s.p+"static/image/76c9c86c97392155f34e860904b2bfd6.9814c3b9.webp",c=s.p+"static/image/c00f12c78f38c3b740f268813e8f2bb3.80d47f5e.webp",t=s.p+"static/image/d3b29ab2a65d4a19c583a10e264a8a39.7e7048aa.webp",o=s.p+"static/image/f94cea60586c2b79de740a623dccb5f3.cc3bde47.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",img:"img",h2:"h2",strong:"strong",pre:"pre",ol:"ol",li:"li"},(0,r.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"12具体实现整理分析数据",children:["12.具体实现：整理分析数据",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12具体实现整理分析数据",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["经过前面章节的学习，我们已经掌握了分析范式中 ",(0,i.jsx)(n.code,{children:"step2-6"})," 的实现原理，这一小节主要讲解 ",(0,i.jsx)(n.code,{children:"step7"})," 的具体实现，我们将学习如何标记黑名单 API，如何对代码调用进行评分，以及如何打包最终分析结果。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:""})}),"\n",(0,i.jsxs)(n.h2,{id:"codeanalysis-实例",children:["codeAnalysis 实例",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#codeanalysis-实例",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"codeAnalysis 实例作为代码分析流程的抽象表述，会贯穿 step2-7 整个执行生命周期，代码分析过程中涉及的配置信息、内部状态、原始分析数据等都以属性的形式挂载在上面。这些属性大致可分为三类："}),"\n",(0,i.jsxs)(n.p,{children:["第一类是",(0,i.jsx)(n.strong,{children:"私有属性"}),"，是代码分析过程中需要用到的配置信息等私有属性；"]}),"\n",(0,i.jsxs)(n.p,{children:["第二类是",(0,i.jsx)(n.strong,{children:"公共属性"}),"，是分析结束后可用于对外提供原始分析数据的属性；"]}),"\n",(0,i.jsxs)(n.p,{children:["第三类是",(0,i.jsx)(n.strong,{children:"插件属性"}),"，是安装插件时挂载，用于记录 API 调用数据的属性。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class CodeAnalysis {\n    constructor(options) {\n        // 私有属性\n        this._scanSource = options.scanSource;                 // 扫描源配置信息       \n        this._analysisTarget = options.analysisTarget;         // 要分析的目标依赖配置           \n        this._blackList = options.blackList || [];             // 需要标记的黑名单API配置        \n        this._browserApis = options.browserApis || [];         // 需要分析的BrowserApi配置         \n        this._isScanVue = options.isScanVue || false;          // 是否扫描Vue配置    \n        this._scorePlugin = options.scorePlugin || null;       // 代码评分插件配置\n        this._analysisPlugins = options.analysisPlugins || []; // 代码分析插件配置\n        // 公共属性\n        this.pluginsQueue = [];                         // Targer分析插件队列\n        this.browserQueue = [];                         // Browser分析插件队列\n        this.importItemMap = {};                        // importItem统计Map    \n        this.parseErrorInfos = [];                      // 解析异常信息\n        this.diagnosisInfos = [];                       // 诊断日志信息           \n        this.scoreMap = {};                             // 评分及建议Map         \n        // 插件属性\n        this.apiMap = {};                            // 未分类API统计Map            \n        this.typeMap = {};                           // 类型API统计Map\n        this.methodMap = {};                         // 方法API统计Map               \n        this.browserMap = {};                        // BrowserAPI统计Map\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["代码分析的目的是让依赖双方开发者了解依赖关系并加以管控，分析结束后，",(0,i.jsx)(n.code,{children:"codeAnalysis"})," 实例的公共属性及插件属性返回的大多是统计型数据，这些数据能够帮助开发者了解 API 的调用及分布信息，但想要实现代码评分、代码告警、脏调用检测等分析目的，我们还需要对原始数据进行二次处理。"]}),"\n",(0,i.jsxs)(n.h2,{id:"脏调用检测",children:["脏调用“检测”",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#脏调用检测",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"“脏调用”检测就是在原始统计结果中找到黑名单 API 并标记，目的是为了在最终的分析结果中将它们与其它 API 区分开来，当然标记是一个很宽泛的概念，使用者可以根据自己的用途去处理被标记的 API，并不只限于检测“脏调用”。"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"codeAnalysis"}),"实例上通过分析插件记录的原始统计数据都是以 API 为 key 的 Map 结构，我们可以实现一个名叫 ",(0,i.jsx)(n.code,{children:"_blackTag"})," 的函数，它会遍历检测相关 Map 中的 key 是否命中 ",(0,i.jsx)(n.code,{children:"blackList"})," 配置项中的 API，命中则为 Map 结构中的 API 添加 ",(0,i.jsx)(n.code,{children:"isBlack"})," 属性表示已标记。"]}),"\n",(0,i.jsxs)(n.p,{children:["简化代码如下，完整代码实现请参考 ",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/analysis.js",target:"_blank",rel:"noopener noreferrer",children:"lib/analysis.js"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class CodeAnalysis {\n    constructor(options) {\n        ......\n        // 私有属性         \n        this._blackList = options.blackList || [];   // 需要标记的API配置        \n        // 公共属性\n        this.pluginsQueue = [];                      // Targer分析插件队列\n        this.browserQueue = [];                      // Browser分析插件队列\n        // 插件属性\n        this.apiMap = {};                            // 未分类API统计Map            \n        this.typeMap = {};                           // 类型API统计Map\n        this.methodMap = {};                         // 方法API统计Map               \n        this.browserMap = {};                        // BrowserAPI统计Map\n        ......\n    }\n    \n    // API黑名单标记\n    _blackTag(queue) {\n        if(queue.length>0){\n          queue.forEach((item)=>{\n            Object.keys(this[item.mapName]).forEach((apiName)=>{  // 遍历相关插件属性Map\n              if(this._blackList.length>0 && this._blackList.includes(apiName)){\n                this[item.mapName][apiName].isBlack = true;       // 标记\n              }\n            })\n          })\n        }\n    }\n    \n    // 入口函数\n    analysis() {\n        ......\n        // 黑名单标记\n        this._blackTag(this.pluginsQueue);\n        this._blackTag(this.browserQueue);\n        ......\n    }  \n}\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"代码评分-优化建议",children:["代码评分& 优化建议",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码评分-优化建议",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"实现原理：将扣分规则及逻辑抽象成一个 f(x) 函数，该函数会以 codeAnalysis 实例做为入参，对原始统计数据进行遍历分析，如果有 API 命中了扣分规则，就执行扣分逻辑并记录对应的优化建议，遍历结束后返回代码评分及优化建议结果。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:c,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"函数式方案的优点就在于，使用者可以通过实现 f(x) 达到自定义评分规则的目的。"}),"\n",(0,i.jsxs)(n.p,{children:["分析工具有一个默认兜底的评分函数，相关源码在 ",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/score.js",target:"_blank",rel:"noopener noreferrer",children:"lib/score.js"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// 默认评分插件\nexports.defaultScorePlugin = function (analysisContext){\n    // console.log(analysisContext);\n    const { pluginsQueue, browserQueue, importItemMap, parseErrorInfos } = analysisContext;\n    const mapNames = pluginsQueue.map(item=>item.mapName).concat(browserQueue.map(item=>item.mapName));\n    \n    let score = 100;            // 初始分数\n    let message =[];            // 代码建议\n\n    // 黑名单API扣分处理\n    if(mapNames.length>0){\n        mapNames.forEach((item)=>{\n            Object.keys(analysisContext[item]).forEach((sitem)=>{\n                if(analysisContext[item][sitem].isBlack){\n                    score = score - 5;\n                    message.push(sitem + ' 属于黑名单api，请勿使用');\n                }\n            })\n        })\n    }\n    // ImportItem扣分处理\n    Object.keys(importItemMap).forEach((item)=>{\n        if(importItemMap[item].callOrigin =='*'){\n            score = score - 2;\n            message.push('import * as ' + item + ' 属于非建议导入方式，建议修改');\n        }\n    })\n    // BrowserAPI扣分处理\n    if(mapNames.includes('browserMap')){\n        // browserapi使用建议\n        Object.keys(analysisContext['browserMap']).forEach((item)=>{\n            let keyName = '';\n            if(item.split('.').length>0){\n                keyName = item.split('.')[0];\n            }else{\n                keyName = item;\n            }\n            if(keyName ==='window'){\n                message.push(item + ' 属于全局类型api，建议请评估影响慎重使用');\n            }\n            if(keyName ==='document'){\n                message.push(item + ' 属于Dom类型操作api，建议评估影响慎重使用');\n            }\n            if(keyName ==='history'){\n                score = score - 2;\n                message.push(item + ' 属于路由类操作，请使用框架提供的Router API代替');\n            }\n            if(keyName ==='location'){\n                score = score - 2;\n                message.push(item + ' 属于路由类操作，请使用框架提供的Router API代替');\n            }\n        })\n    }\n    // 解析AST失败或执行分析触发异常的扣分处理\n    if(parseErrorInfos.length >0){\n        score = score - 3*parseErrorInfos.length;\n        let tempMessage ='';\n        tempMessage = parseErrorInfos.length + ' 个文件解析&分析AST时发生错误，请修复';\n        message.push(tempMessage);\n    }\n\n    // 最低0分\n    if(score <0)score =0;\n\n    return {\n        score: score,\n        message: message\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["代码评分函数的具体实现并没有任何限制，只需要返回一个包含 ",(0,i.jsx)(n.code,{children:"score"}),"，",(0,i.jsx)(n.code,{children:"message"})," 属性的 JS 对象即可（score 是 number 类型，message 是一个 string 类型的数组）。"]}),"\n",(0,i.jsx)(n.p,{children:"codeAnalysis 基础类中关于代码评分 & 优化建议的简化版实现如下："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const { defaultScorePlugin } = require(path.join(__dirname, './score'));   // 评分模块\n\nclass CodeAnalysis {\n    constructor(options) {\n        ......\n        // 私有属性         \n        this._scorePlugin = options.scorePlugin || null;  // 代码评分插件配置       \n        // 公共属性\n        this.scoreMap = {};                          // 评分及建议Map\n        ......\n    }\n    \n    // 入口函数\n    analysis() {\n        ......\n        // 代码评分\n        if(this._scorePlugin){\n          if(typeof(this._scorePlugin) ==='function'){\n            this.scoreMap = this._scorePlugin(this);\n          }\n          if(this._scorePlugin ==='default'){\n            this.scoreMap = defaultScorePlugin(this);\n          }\n        }else{\n          this.scoreMap = null;\n        }\n        ......\n    }  \n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["开发者可以在配置文件中通过 ",(0,i.jsx)(n.code,{children:"scorePlugin"})," 配置项来配置自定义评分函数，代码评分及优化建议相关的数据会记录在 ",(0,i.jsx)(n.code,{children:"codeAnalysis"})," 实例的 ",(0,i.jsx)(n.code,{children:"scoreMap"})," 属性中，有关自定义评分函数的配置与使用，大家可以参考 ",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})," 项目中的示例。"]}),"\n",(0,i.jsxs)(n.h2,{id:"打包分析结果",children:["打包分析结果",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#打包分析结果",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"codeAnalysis"})," 实例是代码分析流程的抽象表述，但分析结果并不需要返回整个 codeAnalysis 实例，通常只需要提取其中部分数据并加以打包即可。"]}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"CLI / API"})," 与 ",(0,i.jsx)(n.code,{children:"codeAnalysis"})," 基础类中间我们设计了 ",(0,i.jsx)(n.code,{children:"index"})," 这一层，目的在于 ",(0,i.jsx)(n.code,{children:"链接"})," 使用入口与基础抽象类，",(0,i.jsx)(n.code,{children:"index"})," 模块封装了实例化 codeAnalysis，执行代码分析、打包分析结果等相关逻辑，保证使用者不管使用哪个入口，都可以返回相同的分析结果。"]}),"\n",(0,i.jsxs)(n.p,{children:["具体实现代码在 ",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-ts/blob/main/lib/index.js",target:"_blank",rel:"noopener noreferrer",children:"lib/index.js"})," 中："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const path = require('path');                                                       // 路径管理\nconst moment = require('moment');                                                   // 时间格式化\nconst ora = require('ora');                                                         // 命令行状态\nconst chalk = require('chalk');                                                     // 美化输出\nconst { REPORTTITLE, TIMEFORMAT } = require(path.join(__dirname, './constant'));    // 常量模块\nconst CodeAnalysis = require(path.join(__dirname, './analysis'));                   // 核心分析类\n\nconst codeAnalysis = function (config) {\n  return new Promise((resolve, reject)=>{\n    var spinner = ora(chalk.green('analysis start')).start();\n    try {\n      // 新建分析实例\n      const coderTask = new CodeAnalysis(config);\n      // 执行代码分析\n      coderTask.analysis();\n      // 打包分析结果\n      const mapNames = coderTask.pluginsQueue.map(item=>item.mapName).concat(coderTask.browserQueue.map(item=>item.mapName));\n      const report = {\n        importItemMap: coderTask.importItemMap,\n        parseErrorInfos: coderTask.parseErrorInfos,            // 解析异常信息\n        scoreMap: coderTask.scoreMap,                          // 代码评分及建议信息\n        reportTitle: config.reportTitle || REPORTTITLE,\n        analysisTime: moment(Date.now()).format(TIMEFORMAT),\n        mapNames: mapNames\n      };\n      if(mapNames.length>0){\n        mapNames.forEach(item => {\n          report[item] = coderTask[item];\n        });\n      }\n      // 返回分析结果\n      resolve({                                                \n        report: report,                                        // 分析报告内容\n        diagnosisInfos: coderTask.diagnosisInfos               // 诊断报告内容\n      });\n      spinner.succeed(chalk.green('analysis success'));\n    } catch (e) {\n      reject(e);\n      spinner.fail(chalk.red('analysis fail'));\n    }\n  })\n};\n\nmodule.exports = codeAnalysis;\n"})}),"\n",(0,i.jsxs)(n.p,{children:["上述代码中使用到了 ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/moment",target:"_blank",rel:"noopener noreferrer",children:"moment"})," 这个工具包来处理时间格式，还用到了 ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/ora",target:"_blank",rel:"noopener noreferrer",children:"ora"}),"、",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/chalk",target:"_blank",rel:"noopener noreferrer",children:"chalk"})," 这两个工具包来美化输出。"]}),"\n",(0,i.jsx)(n.p,{children:"打包后最终的分析结果包含 2 部分："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["代码分析报告 ",(0,i.jsx)(n.code,{children:"report"}),"，用于帮助开发者了解并管控依赖关系。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["工具诊断报告 ",(0,i.jsx)(n.code,{children:"diagnosisInfos"}),"，用于辅助插件开发者开发/调试分析插件。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"代码分析报告内容示例："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n    "importItemMap": {\n        "domain": {\n            "callOrigin": null,\n            "callFiles": [\n                "Order&src/api/index.ts"\n            ]\n        },\n        "api": {\n            "callOrigin": null,\n            "callFiles": [\n                "Order&src/api/index.ts",\n                "Order&code/test/coding.ts"\n            ]\n        },\n        "responseType": {\n            "callOrigin": null,\n            "callFiles": [\n                "Order&src/api/people.ts"\n            ]\n        }\n    },\n    "parseErrorInfos": [\n        {\n            "projectName": "Order",\n            "httpRepo": "",\n            "file": "src/pages/setting.vue",\n            "stack": "SyntaxError: Element is missing end tag.\\n    at createCompilerError (/Users/xinliang/code/github/code-analysis-ts/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js:16:19)\\n    at emitError (/Users/xinliang/code/github/code-analysis-ts/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js:1187:29)\\n    at parseElement (/Users/xinliang/code/github/code-analysis-ts/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js:824:9)\\n    at parseChildren (/Users/xinliang/code/github/code-analysis-ts/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js:650:28)\\n    at parseElement (/Users/xinliang/code/github/code-analysis-ts/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js:816:22)\\n    at parseChildren (/Users/xinliang/code/github/code-analysis-ts/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js:650:28)\\n    at Object.baseParse (/Users/xinliang/code/github/code-analysis-ts/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js:570:23)\\n    at Object.parse (/Users/xinliang/code/github/code-analysis-ts/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js:3049:25)\\n    at exports.parseVue (/Users/xinliang/code/github/code-analysis-ts/lib/parse.js:13:32)\\n    at parseFiles.forEach (/Users/xinliang/code/github/code-analysis-ts/lib/analysis.js:306:50)"\n        }\n    ],\n    "reportTitle": "Order代码分析报告",\n    "analysisTime": "2023.01.25 11:29:15",\n    "mapNames": [\n        "methodMap",\n        "typeMap",\n        "apiMap",\n        "browserMap"\n    ],\n    "methodMap": {\n        "api.thirdRequest.get": {\n            "callNum": 2,\n            "callOrigin": null,\n            "callFiles": {\n                "Order&src/api/index.ts": {\n                    "projectName": "Order",\n                    "httpRepo": "",\n                    "lines": [\n                        6,\n                        10\n                    ]\n                }\n            }\n        }\n    },\n    "typeMap": {\n        "responseType": {\n            "callNum": 1,\n            "callOrigin": null,\n            "callFiles": {\n                "Order&src/api/people.ts": {\n                    "projectName": "Order",\n                    "httpRepo": "",\n                    "lines": [\n                        23\n                    ]\n                }\n            }\n        }\n    },\n    "apiMap": {\n        "domain.getDate": {\n            "callNum": 1,\n            "callOrigin": null,\n            "callFiles": {\n                "Order&src/api/index.ts": {\n                    "projectName": "Order",\n                    "httpRepo": "",\n                    "lines": [\n                        13\n                    ]\n                }\n            }\n        }\n    },\n    "browserMap": {\n        "document.getElementById": {\n            "callNum": 1,\n            "callOrigin": null,\n            "callFiles": {\n                "Order&src/components/scrollBar/index.vue": {\n                    "projectName": "Order",\n                    "httpRepo": "",\n                    "lines": [\n                        32\n                    ]\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"工具诊断报告内容示例："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'[\n    {\n            "projectName": "xxx",\n            "matchImportItem": {\n                "origin": null,\n                "symbolPos": 73,\n                "symbolEnd": 77,\n                "identifierPos": 73,\n                "identifierEnd": 77\n            },\n            "apiName": "app.localStorage.set",\n            "httpRepo": "",\n            "file": "src/pages/BasicSettings.vue",\n            "line": 129,\n            "stack": "TypeError: Cannot read property \'name\' of null\\n    at isMethodCheck (/Users/xinliang/code/github/code-analysis-ts/plugins/methodPlugin.js:13:87)\\n    at CodeAnalysis._runAnalysisPlugins (/Users/xinliang/code/github/code-analysis-ts/lib/analysis.js:87:12)\\n    at walk (/Users/xinliang/code/github/code-analysis-ts/lib/analysis.js:231:22)\\n    at visitNode (/Users/xinliang/code/github/code-analysis-ts/node_modules/typescript/lib/typescript.js:30663:24)\\n    at Object.forEachChild (/Users/xinliang/code/github/code-analysis-ts/node_modules/typescript/lib/typescript.js:30890:24)\\n    at walk (/Users/xinliang/code/github/code-analysis-ts/lib/analysis.js:216:18)\\n    at visitNode (/Users/xinliang/code/github/code-analysis-ts/node_modules/typescript/lib/typescript.js:30663:24)\\n    at Object.forEachChild (/Users/xinliang/code/github/code-analysis-ts/node_modules/typescript/lib/typescript.js:30890:24)\\n    at walk (/Users/xinliang/code/github/code-analysis-ts/lib/analysis.js:216:18)\\n    at visitNode (/Users/xinliang/code/github/code-analysis-ts/node_modules/typescript/lib/typescript.js:30663:24)"\n    }\n]\n'})}),"\n",(0,i.jsxs)(n.p,{children:["至此，分析范式中 ",(0,i.jsx)(n.code,{children:"step2-7"})," 相关的知识及实现原理就都讲完了。"]}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这一小节我们学习了如何整理分析数据，需要大家掌握以下知识点："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"codeAnalysis"})," 实例作为代码分析流程的抽象表述，共有三种类型的属性。公共属性及插件属性返回的大多是统计型数据，我们需要对原始数据进行二次处理。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"API 标记"}),"是一个很宽泛的概念，目的是为了将某些 API 与其它 API 区分开来，使用者可以按自己的用途去处理被标记的 API，并不只限于检测“脏调用”。"]}),"\n",(0,i.jsx)(n.li,{children:"代码评分函数的优点就在于使用者可以通过实现 f(x) 达到自定义评分规则的目的。"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"index"})," 这一层设计目的在于 ",(0,i.jsx)(n.code,{children:"链接"})," 使用入口与基础抽象类，它封装了实例化 codeAnalysis，执行代码分析、打包分析结果等相关逻辑，保证不同的使用入口可以返回相同的分析结果。"]}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}let p=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F12.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%95%B4%E7%90%86%E5%88%86%E6%9E%90%E6%95%B0%E6%8D%AE.md"]={toc:[{text:"codeAnalysis 实例",id:"codeanalysis-实例",depth:2},{text:"脏调用“检测”",id:"脏调用检测",depth:2},{text:"代码评分& 优化建议",id:"代码评分-优化建议",depth:2},{text:"打包分析结果",id:"打包分析结果",depth:2},{text:"小结",id:"小结",depth:2}],title:"12.具体实现：整理分析数据",headingTitle:"12.具体实现：整理分析数据",frontmatter:{}}}}]);