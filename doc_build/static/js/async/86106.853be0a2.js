"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["86106"],{365414:function(n,e,c){c.r(e),c.d(e,{default:()=>f});var r=c(552676),l=c(740453);let s=c.p+"static/image/3066b515d35e742053b87d1ab40890d1.c6b5fc9f.webp",d=c.p+"static/image/6718b2e55200a3e328a09a38d073fa02.65593f84.webp",i=c.p+"static/image/f231d34acb86998f14db8257bd205148.a5191ec8.webp",o=c.p+"static/image/3f4ad464724e711eccf91e160ae797e8.ea3f3209.webp",a=c.p+"static/image/01adb6d2467a74f43632987df51ef95f.e7de4648.webp",h=c.p+"static/image/f90fbf0e0a88e1c38c5090229c1b3d85.39ffeed1.webp",t=c.p+"static/image/298a1b0a507e6f2451fe9ae9abb5c035.5ec98cd1.webp",p=c.p+"static/image/b959834518d29cb1b121a5a688b53d06.34347688.webp",x=c.p+"static/image/4a8c416a8bbc0aac50a648f777d08477.592cc811.webp",j=c.p+"static/image/e823ef642c24f9d0cf35507be8f9f14b.59212cfd.webp",g=c.p+"static/image/4c36554f97ac4504af821025ad51e87d.473d22d9.webp",S=c.p+"static/image/78c4e4d2013e295acc8d2f84f4bcbdfa.f61bc7f2.webp",u=c.p+"static/image/12e8ec67af906caa435261244f71099c.be58a5e6.webp";function m(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li",h3:"h3",img:"img",blockquote:"blockquote",h4:"h4",strong:"strong"},(0,l.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"第34章css的嵌套和作用域和scope",children:["第34章—CSS的嵌套和作用域：&和@scope",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#第34章css的嵌套和作用域和scope",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"\uFEFF嵌套是 CSS 处理器（例如 Sass）的核心功能之一，每一位 Web 开发者都希望 CSS 中能有嵌套的功能。因为它可以节省 Web 开发人员一遍又一遍地编写相同选择器的时间。它可以使 CSS 代码更清晰，更容易理解和更易于维护。现在，你现在可以不再依赖 CSS 处理器，直接在 CSS 中使用嵌套的功能。"}),"\n",(0,r.jsx)(e.p,{children:"CSS 除了增加了嵌套的功能之外，还增加了 CSS 作用域的功能。可以说，CSS 作用域的功能就像 CSS 的嵌套功能一样，是 Web 开发者一直期待的功能之一。它可以允许你更好的操作 CSS 的级联，也可以根据 DOM 中的接近程度覆盖另一组样式。可以说，它的出现能更好的帮助你管理 CSS 级联，避免样式的冲突。"}),"\n",(0,r.jsx)(e.p,{children:"在这节课中，我们主要一起来探讨 CSS 的嵌套和作用域功能。"}),"\n",(0,r.jsxs)(e.h2,{id:"css-的嵌套",children:["CSS 的嵌套",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#css-的嵌套",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们先从 CSS 的嵌套开始吧！"}),"\n",(0,r.jsx)(e.p,{children:"还没有嵌套功能之间，Web 开发者不得一遍又一遍地编写相同的选择器。这就导致了代码的重复，样式表的臃肿和代码分散等。例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo {\n \xa0 \xa0color: hotpink;\n}\n​\n.foo > .bar {\n \xa0 \xa0color: rebeccapurple;\n}\n​\n.foo .bar .baz {\n \xa0 \xa0color: deeppink;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"如果你正在使用像 Sass 这样的 CSS 处理器，你可能会使用它的嵌套功能，将上面代码改成下面这样："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-SCSS",children:"/* 使用 Sass 的嵌套功能 */\n.foo {\n \xa0 \xa0color: hotpink;\n \xa0 \xa0\n \xa0  > .bar {\n \xa0 \xa0 \xa0 \xa0color: rebeccapurple;\n \xa0  }\n \xa0 \xa0\n \xa0 \xa0.bar {\n \xa0 \xa0 \xa0 \xa0.baz {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: deeppink;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"现在，你可以直接在 CSS 中像 Sass 那样使用嵌套的功能："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"/* CSS 的嵌套功能 */\n.foo {\n \xa0 \xa0color: hotpink;\n \xa0 \xa0\n \xa0  > .bar {\n \xa0 \xa0 \xa0 \xa0color: rebeccapurple;\n \xa0  }\n \xa0 \xa0\n \xa0 \xa0.bar {\n \xa0 \xa0 \xa0 \xa0.baz {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: deeppink;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["正如上面代码所示，嵌套可以帮助 Web 开发人员减少编写重复的选择器，同时还可以将与之相关的样式规则分组在其中。它还可以帮助样式匹配它们的目标 HTML。如果从项目中删除示例中的 ",(0,r.jsx)(e.code,{children:".foo"})," 代码块，则可以删除整个组，而不是在文件中搜索相关的选择器实例。"]}),"\n",(0,r.jsx)(e.p,{children:"简单地说，CSS 嵌套可以帮助 Web 开发者："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"更好组织 CSS 代码"}),"\n",(0,r.jsx)(e.li,{children:"减少 CSS 文件大小"}),"\n",(0,r.jsx)(e.li,{children:"更好重构 CSS"}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"开始使用-css-的嵌套",children:["开始使用 CSS 的嵌套",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#开始使用-css-的嵌套",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们通过具体的实例来向大家展示 CSS 嵌套的使用。基于下面这个 HTML 结构，通过选择各种形状、大小和颜色，你可以快速掌握 CSS 嵌套语法规则，并且视觉化展示嵌套所起的作用。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="demo">\n \xa0 \xa0<div class="lg triangle pink"></div>\n \xa0 \xa0<div class="sm triangle pink"></div>\n \xa0 \xa0<div class="sm triangle purple"></div>\n \xa0 \xa0<div class="sm triangle blue"></div>\n \xa0 \xa0<div class="triangle blue"></div>\n \xa0 \n \xa0 \xa0\n \xa0 \xa0<div class="sm square pink"></div>\n \xa0 \xa0<div class="sm square blue"></div>\n \xa0 \xa0<div class="sm square purple"></div>\n \xa0 \xa0<div class="sm square pink"></div>\n \xa0 \xa0<div class="sm square pink"></div>\n \xa0 \xa0<div class="sm square purple"></div>\n \xa0 \xa0<div class="sm square pink"></div>\n \xa0 \xa0<div class="sm square purple"></div>\n \xa0 \xa0<div class="square blue"></div>\n \xa0 \xa0<div class="square purple"></div>\n \xa0 \xa0<div class="square pink"></div>\n \xa0 \xa0\n \xa0\n \xa0 \xa0\n \xa0 \xa0<div class="sm circle blue"></div>\n \xa0 \xa0<div class="sm circle pink"></div>\n \xa0 \xa0<div class="sm circle blue"></div>\n \xa0 \xa0<div class="sm circle pink"></div>\n \xa0 \xa0<div class="sm circle blue"></div>\n \xa0 \xa0<div class="sm circle blue"></div> \n \xa0 \xa0<div class="circle pink"></div>\n \xa0 \xa0<div class="lg circle purple"></div>\n</div>\n'})}),"\n",(0,r.jsx)(e.p,{children:"示例初始化样式："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@layer reset, base, demo, nesting;\n​\n@layer nesting {\n \xa0 \xa0/* CSS 嵌套示例 */\n}\n​\n@layer demo {\n \xa0 \xa0.demo {\n \xa0 \xa0 \xa0 \xa0--size: 5rem;\n \xa0 \xa0 \xa0 \xa0display: grid;\n \xa0 \xa0 \xa0 \xa0grid-template-columns: repeat(auto-fit, minmax(5rem, 1fr));\n \xa0 \xa0 \xa0 \xa0grid-auto-rows: 5rem;\n \xa0 \xa0 \xa0 \xa0place-items: center;\n \xa0 \xa0 \xa0 \xa0gap: 1rem;\n \xa0 \xa0 \xa0 \xa0max-inline-size: 60ch;\n \xa0  }\n \xa0\n \xa0 \xa0.demo > * {\n \xa0 \xa0 \xa0 \xa0transition: all .5s cubic-bezier(.25,0,.2,1);\n \xa0  }\n}\n​\n@layer demo.shapes {\n \xa0 \xa0.square {\n \xa0 \xa0 \xa0 \xa0background: var(--color);\n \xa0 \xa0 \xa0 \xa0aspect-ratio: 1;\n \xa0 \xa0 \xa0 \xa0inline-size: var(--size);\n \xa0  } \n \xa0\n \xa0 \xa0.circle {\n \xa0 \xa0 \xa0 \xa0background: var(--color);\n \xa0 \xa0 \xa0 \xa0aspect-ratio: 1;\n \xa0 \xa0 \xa0 \xa0border-radius: 50%;\n \xa0 \xa0 \xa0 \xa0inline-size: var(--size);\n \xa0  } \n \xa0\n \xa0 \xa0.triangle {\n \xa0 \xa0 \xa0 \xa0aspect-ratio: 1; \n \xa0 \xa0 \xa0 \xa0border-inline: calc(var(--size) / 2) solid transparent;\n \xa0 \xa0 \xa0 \xa0border-block-end: calc(var(--size) / 1.25) solid var(--color);\n \xa0  } \n}\n​\n@layer demo.sizes {\n \xa0 \xa0.sm { \n \xa0 \xa0 \xa0 \xa0--size: 1.75rem \n \xa0  }\n \xa0\n \xa0 \xa0.lg { \n \xa0 \xa0 \xa0 \xa0--size: 20rem; \n \xa0 \xa0 \xa0 \xa0z-index: -1; \n \xa0  }\n}\n​\n@layer demo.colors {\n \xa0 \xa0.blue { \n \xa0 \xa0 \xa0 \xa0--color: cyan; \n \xa0  } \n \xa0\n \xa0 \xa0.pink { \n \xa0 \xa0 \xa0 \xa0--color: magenta; \n \xa0  } \n \xa0 \xa0\n \xa0 \xa0.purple { \n \xa0 \xa0 \xa0 \xa0--color: rebeccapurple; \n \xa0  } \n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:u,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/wvQRBqK",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/wvQRBqK"})]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们基于上面这个示例，开始使用 CSS 的嵌套来改变图形样式规则。"}),"\n",(0,r.jsxs)(e.h4,{id:"选择所有圆形",children:["选择所有圆形",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#选择所有圆形",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在还没有 CSS 嵌套之前，我们可以像下面这样来选中所有圆形："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo .circle {\n \xa0 \xa0border: 2px solid #000;\n \xa0 \xa0opacity: .25;\n \xa0 \xa0filter: blur(2px);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"要是使用 CSS 嵌套，我们可以这样编写 CSS，同样可以选中所有圆形："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0 \xa0.circle {\n \xa0 \xa0 \xa0 \xa0border: 2px solid #000;\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:S,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/oNQJgdm",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/oNQJgdm"})]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"除此之外，还可以使用第二种方式："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0  & .circle {\n \xa0 \xa0 \xa0 \xa0border: 2px solid #000;\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["代码中的 ",(0,r.jsx)(e.code,{children:"&"})," 符号被称为“",(0,r.jsx)(e.strong,{children:"嵌套选择器"}),"”，表示你可以从父规则中引用选择器。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"&"})," 符号在 CSS 的嵌套中非常有用。假设你有一段未嵌套的 CSS 代码："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"ul {\n \xa0 \xa0padding-left: 1em;\n}\n.component ul {\n \xa0 \xa0padding-left: 0;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["示例中的 ",(0,r.jsx)(e.code,{children:".component ul"})," 选择器表示的是选中 ",(0,r.jsx)(e.code,{children:".component"})," 中的所有 ",(0,r.jsx)(e.code,{children:"ul"})," 。就该示例而言，如果我们使用 CSS 的嵌套，可以这样写："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"ul {\n \xa0 \xa0padding-left: 1em;\n \xa0 \xa0\n \xa0 \xa0.component & {\n \xa0 \xa0 \xa0 \xa0padding-left: 0;\n \xa0  }\n} \n"})}),"\n",(0,r.jsxs)(e.p,{children:["再一次， ",(0,r.jsx)(e.code,{children:"&"})," 给了你一种方式来说明“这就是我想要嵌套选择器的位置”。"]}),"\n",(0,r.jsxs)(e.p,{children:["当你不希望选择器之间有空格时，",(0,r.jsx)(e.code,{children:"&"})," 也很方便。例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:'a {\n    color: blue;\n    \n    &::before {\n        content:"\uD83D\uDC48\uD83C\uDFFB"；\n    }\n    \n    &::after {\n        content:"\uD83D\uDC49\uD83C\uDFFB";\n    }\n    \n    &:hover {\n        color: lightblue;\n    }\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"上在代码等同于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:'a {\n \xa0 \xa0color: blue;\n}\n​\na::before {\n \xa0 \xa0content:"\uD83D\uDC48\uD83C\uDFFB"；\n}\n​\na::after {\n \xa0 \xa0content:"\uD83D\uDC49\uD83C\uDFFB";\n}\n​\na:hover {\n \xa0 \xa0color: lightblue;\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:["但要是没有 ",(0,r.jsx)(e.code,{children:"&"})," 符号，",(0,r.jsx)(e.code,{children:"a"})," 和 ",(0,r.jsx)(e.code,{children:":hover"})," 、",(0,r.jsx)(e.code,{children:"::before"})," 和 ",(0,r.jsx)(e.code,{children:"::after"})," 之间会有一个空格："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:'/* 无效 CSS */\na :hover { /* 注意 a 和 :hover 之间有一个空格 */\n \xa0 \xa0color: lightblue;\n}\n​\na ::before { /* 注意 a 和 ::before 之间有一个空格 */\n \xa0 \xa0content:"\uD83D\uDC48\uD83C\uDFFB"；\n}\n​\na ::after { /* 注意 a 和 ::after 之间有一个空格 */\n \xa0 \xa0content:"\uD83D\uDC49\uD83C\uDFFB";\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"另外，在以下样式规则中："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo,\n.foo::before,\n.foo::after {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0  &:hover {\n \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["代码中的 ",(0,r.jsx)(e.code,{children:"&"})," 符号只会与 ",(0,r.jsx)(e.code,{children:".foo"})," 选择器匹配。换句话说，上面的代码相当于："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo,\n.foo::before,\n.foo::after {\n    color: red;\n}\n\n.foo:hover {\n    color: blue;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"但是，如果有这些未嵌套的 CSS 代码呢？"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"ul {\n    padding-left: 1em;\n}\n\narticle ul {\n    padding-left: 0;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"你不希望像这样编写 CSS 嵌套代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"ul {\n    padding-left: 1em;\n    \n    & article & {\n        padding-left: 0;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"为什么不呢？因为它等同于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"ul {\n \xa0 \xa0padding-left: 1em;\n}\n​\nul article ul {\n \xa0 \xa0padding-left: 0;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这并不是我们想要的。"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"&"})," 符号在 CSS 中还可以单独使用。在单独使用的时候，相当于将样式合并到一个选择器中。例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0  & {\n \xa0 \xa0 \xa0 \xa0border: 1px solid green;\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"上面的代码等同于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo {\n \xa0 \xa0color: red;\n}\n​\n.foo {\n \xa0 \xa0border: 1px solid green;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"也相当于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo {\n \xa0 \xa0color: red;\n \xa0 \xa0border: 1px solid green;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["我们还可以在嵌套中使用双 ",(0,r.jsx)(e.code,{children:"&"})," 符（即 ",(0,r.jsx)(e.code,{children:"&&"}),"），例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0  && {\n \xa0 \xa0 \xa0 \xa0border: 1px solid red;\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"它等同于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo {\n \xa0 \xa0color: red;\n}\n​\n.foo.foo {\n \xa0 \xa0border: 1px solid red;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"只不过这样做有点愚蠢，甚至说它毫无意义。因为我们很少会在同一个元素上设置相同的类名，即："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="foo foo">Foo</div>\n'})}),"\n",(0,r.jsxs)(e.p,{children:["连字符 ",(0,r.jsx)(e.code,{children:"&"})," 同样也可以运用于 CSS 处理器（例如 Sass）中的嵌套，它允许 Web 开发者构建一个简单的选择器。比如，使用 ",(0,r.jsx)(e.code,{children:"&"})," 与 BEM 命名模式一起使用，来减少文件中的重复使用。例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-SCSS",children:"// SCSS 与 BEM 一起使用 \n.card {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0  &__title {\n \xa0 \xa0 \xa0 \xa0color: green;\n \xa0  }\n}\n​\n// 等同于\n.card {\n \xa0 \xa0color: red;\n}\n​\n.card__title {\n \xa0 \xa0color: green;\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"不幸的是，要是你在 CSS 嵌套中这样使用，它的结果和你预期的有所不同。例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"/* CSS 嵌套*/\n.card {\n    color: red;\n    \n    &__title {\n        color: green;\n    }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"它等同于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".card {\n    color: red;\n}\n__title.card {\n    color: green;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["其中 ",(0,r.jsx)(e.code,{children:"__title.card"})," 是一个无效的 CSS 选择器。"]}),"\n",(0,r.jsxs)(e.h4,{id:"同时选择所有正方形和三角形",children:["同时选择所有正方形和三角形",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#同时选择所有正方形和三角形",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们暂时搁置 ",(0,r.jsx)(e.code,{children:"&"})," 连字符在嵌套中的使用，回到最初的图形示例中来。假设我们同时要选择所有正方形和三角形。就该任务而言，如果不使用 CSS 嵌套，我们可以使用组合选择器来达到目的："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo .square,\n.demo .triangle {\n    opacity: .25;\n    filter: blur(2px);\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["或者",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7223230325122400288/section/7226251495069450278",target:"_blank",rel:"noopener noreferrer",children:"使用 :is() 选择器"}),"来优化上面的代码："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo :is(.square, .triangle) {\n \xa0 \xa0opacity: .25;\n \xa0 \xa0filter: blur(2px);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"我们可以使用不同的嵌套方式来改造上面的代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0  & .triangle,\n \xa0  & .square {\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"或者："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0 \xa0.triangle, .square {\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"或者："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0  :is(.triangle,.square) {\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0  } \n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:g,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/oNQJjVE",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/oNQJjVE"})]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在 CSS 中，任何选择器都可以使用 ",(0,r.jsx)(e.code,{children:":is()"})," 伪类选择器来包裹，并保持相同的权重（当它是括号内唯一的选择器时）。在 ",(0,r.jsx)(e.code,{children:":is()"})," 选择器中放入一个元素选择器，就会得到一个以 CSS 嵌套的符号开头的选择器。"]}),"\n",(0,r.jsxs)(e.p,{children:["前面我们有一个示例，使用 ",(0,r.jsx)(e.code,{children:"&"})," 符号并不能达到我们所预期的效果。例如，我们期望的是下面这样的效果："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"ul {\n \xa0 \xa0padding-left: 1em;\n}\n​\narticle ul {\n \xa0 \xa0padding-left: 0;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["如果我们像下面这样使用 ",(0,r.jsx)(e.code,{children:"&"})," 连字符，它是一个无效的嵌套规则："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"/* 无效的嵌套规则 */\nul {\n \xa0 \xa0padding-left: 1em;\n \xa0 \xa0\n \xa0 \xa0article & {\n \xa0 \xa0 \xa0 \xa0padding-left: 0;\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这是 CSS 嵌套规则所决定的，具本原因稍后阐述。"}),"\n",(0,r.jsxs)(e.p,{children:["就该示例而言，我们在 ",(0,r.jsx)(e.code,{children:"article"})," 选择器使用 ",(0,r.jsx)(e.code,{children:"&"})," 符也将不能达到预期："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"ul {\n \xa0 \xa0padding-left: 1em;\n \xa0 \xa0\n \xa0  & article & {\n \xa0 \xa0 \xa0 \xa0padding-left: 0;\n \xa0  }\n}\n​\n/* 等同于 */\nul {\n \xa0 \xa0padding-left: 1em;\n}\n​\nul article ul {\n \xa0 \xa0padding-left: 0;\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这个时候，我们使用 ",(0,r.jsx)(e.code,{children:":is()"})," 选择器来包裹 ",(0,r.jsx)(e.code,{children:"article"})," 选择器就可以达到预期的效果："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"ul {\n \xa0 \xa0padding-left: 1em;\n \xa0 \xa0\n \xa0  :is(article) & {\n \xa0 \xa0 \xa0 \xa0padding-left: 0; \n \xa0  }\n}\n​\n/* 等同于 */\nul {\n \xa0 \xa0padding-left: 1em;\n}\n​\narticle ul {\n \xa0 \xa0padding-left: 0;\n}\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"选择大的三角形和圆形",children:["选择大的三角形和圆形",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#选择大的三角形和圆形",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们可以使用 CSS 的复合选择器来选择大的三角形和圆形："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo .lg.triangle,\n.demo .lg.square {\n \xa0 \xa0opacity: .25;\n \xa0 \xa0filter: blur(2px);\n}\n​\n/* 或者 */\n.demo .lg:is(.triangle, .circle) {\n \xa0 \xa0opacity: .25;\n \xa0 \xa0filter: blur(2px);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"要使该选择器生效，那么元素必须同时具有两个类才能被选择，例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="demo">\n \xa0 \xa0<div class="triangle">\x3c!-- 未选中，缺少 lg 类名 --\x3e\n \xa0 \xa0<div class="lg">\x3c!-- 未选中，缺少 triangle 类名 --\x3e\n \xa0 \xa0<div class="lg triangle">\x3c!-- 选中，同时具有 lg 和 triangle 两个类名 --\x3e</div>\n</div>\n'})}),"\n",(0,r.jsx)(e.p,{children:"我们可以使用 CSS 嵌套，将上面代码改成下面这样："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0 \xa0.lg.triangle,\n \xa0 \xa0.lg.circle {\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(25px);\n \xa0  }\n}\n​\n/* 或者 */\n.demo {\n \xa0 \xa0.lg {\n \xa0 \xa0 \xa0  &.triangle,\n \xa0 \xa0 \xa0  &.circle {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0filter: blur(25px);\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n​\n/* 或者 */\n.demo {\n \xa0 \xa0.lg {\n \xa0 \xa0 \xa0  :is(&.triangle, &.circle) {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:j,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/eYQbJqK",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/eYQbJqK"})]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["在这个示例中，",(0,r.jsx)(e.code,{children:"&"})," 符号很重要，如果没有 ",(0,r.jsx)(e.code,{children:"&"})," 符号，CSS 的嵌套也是有效的，但最终的结果并不是你所预期的。这一点在前面有介绍过，在没有 ",(0,r.jsx)(e.code,{children:"&"})," 符号时，它们对应的就不是复合选择器，而是后代选择器。例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0 \xa0.lg {\n \xa0 \xa0 \xa0 \xa0.triangle,\n \xa0 \xa0 \xa0 \xa0.circle {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n​\n/* 等同于 */\n.demo .lg .triangle,\n.demo .lg .circle {\n \xa0 \xa0opacity: .25;\n \xa0 \xa0filter: blur(2px);\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["正如你所看到的，",(0,r.jsx)(e.strong,{children:"没有"})," ",(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"&"})})," ",(0,r.jsx)(e.strong,{children:"符号的嵌套类，总是会产生后代选择器"}),"。"]}),"\n",(0,r.jsxs)(e.h4,{id:"选择除粉红色之外的所有图形",children:["选择除粉红色之外的所有图形",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#选择除粉红色之外的所有图形",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们可以使用 ",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7223230325122400288/section/7226251495276609569",target:"_blank",rel:"noopener noreferrer",children:"CSS 的 :not() 选择器"}),"来选中除 ",(0,r.jsx)(e.code,{children:".pink"})," 类之外的所有元素，这样就达到了我们的诉求，即除粉红色之外的所有图形："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo :not(.pink) {\n \xa0 \xa0opacity: .25;\n \xa0 \xa0filter: blur(2px);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"我们可以使用 CSS 的嵌套来修改上面的代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0  :not(.pink) {\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0  }\n}\n​\n/* 或者 */\n.demo {\n \xa0  & :not(.pink) {\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:x,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/vYQvGyL",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/vYQvGyL"})]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["注意，示例代码中 ",(0,r.jsx)(e.code,{children:"&"})," 和 ",(0,r.jsx)(e.code,{children:":not()"})," 之间有一个空格，如果没有空格（即 ",(0,r.jsx)(e.code,{children:"&:not()"}),"），那么将会和 ",(0,r.jsx)(e.code,{children:".demo"})," 合成在一起，即 ",(0,r.jsx)(e.code,{children:".demo:not(.pink)"})," ："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".demo {\n \xa0  &:not(.pink) { /* & 和 :not() 之间没有任何空格 */\n \xa0 \xa0 \xa0 \xa0opacity: .25;\n \xa0 \xa0 \xa0 \xa0filter: blur(2px);\n \xa0  }\n}\n​\n/* 等同于 */\n.demo:not(.pink) {\n \xa0 \xa0opacity: .25;\n \xa0 \xa0filter: blur(2px);\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"这对于嵌套伪类选择器和伪元素非常有用。例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"a {\n \xa0  &:hover {\n \xa0 \xa0\n \xa0  }\n \xa0 \xa0\n \xa0  &:focus-visible {\n \xa0 \xa0\n \xa0  }\n \xa0 \xa0\n \xa0  &::before {\n \xa0 \xa0\n \xa0  }\n \xa0 \xa0\n \xa0  &::after {\n \xa0 \xa0\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["另外，",(0,r.jsx)(e.code,{children:"&"})," 还可以当作 ",(0,r.jsx)(e.code,{children:":not()"})," 选择器的参数，会将父选择器当作 ",(0,r.jsx)(e.code,{children:":not()"})," 选择器的参数，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0  :not(&) {\n \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0  }\n}\n​\n/* 等同于 */\n.foo {\n \xa0 \xa0color: red;\n}\n​\n:not(.foo) {\n \xa0 \xa0color: blue;\n}\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"css-的条件嵌套",children:["CSS 的条件嵌套",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#css-的条件嵌套",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["CSS 的条件嵌套指的是 CSS 嵌套与 CSS 的 ",(0,r.jsx)(e.code,{children:"@"})," 规则（例如 ",(0,r.jsx)(e.code,{children:"@media"})," 、",(0,r.jsx)(e.code,{children:"@container"})," 、",(0,r.jsx)(e.code,{children:"@supports"})," 、",(0,r.jsx)(e.code,{children:"@layer"})," 和 ",(0,r.jsx)(e.code,{children:"@scope"})," 等）组合。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们构建响应式 Web 布局时，会使用 ",(0,r.jsx)(e.code,{children:"@media"})," 根据视窗尺寸来调整页面布局，会使用 ",(0,r.jsx)(e.code,{children:"@container"})," 根据查询容器尺寸来调整 Web 组件的布局或 UI。在还没有 CSS 嵌套功能之前，构建响应式 Web 布局的样式代码会因媒体查询或容器查询条件变得非常分散。这种干扰随着将条件嵌套在上下文中的能力而消失。"]}),"\n",(0,r.jsx)(e.p,{children:"拿媒体查询为例，为了语法方便，如果嵌套的媒体查询只修改当前选择器上下文的样式，那么可以这样编写 CSS 的嵌套："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".card {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0 \xa0@media only screen and (width > 1024px) {\n \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["当然，你也可以显式地使用 ",(0,r.jsx)(e.code,{children:"&"})," 符号："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".card {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0 \xa0@media only screen and (width > 1024px) {\n \xa0 \xa0 \xa0  & {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"上面的代码等同于："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".card {\n \xa0 \xa0color: red;\n}\n​\n@media only screen and (width > 1024px) {\n \xa0 \xa0.card {\n \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["其他 ",(0,r.jsx)(e.code,{children:"@"})," 规则的嵌套与 ",(0,r.jsx)(e.code,{children:"@media"})," 是相似的，例如 ",(0,r.jsx)(e.a,{href:"https://www.w3.org/TR/css-nesting-1/#conditionals",target:"_blank",rel:"noopener noreferrer",children:"W3C 规范上所提供的一些示例"}),"："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"/* 级联层的嵌套 */\n@layer base {\n \xa0 \xa0html {\n \xa0 \xa0 \xa0 \xa0block-size: 100%;\n​\n \xa0 \xa0 \xa0  & body {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0min-block-size: 100%;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n​\n/* 等同于 */\n@layer base {\n \xa0 \xa0html {\n \xa0 \xa0 \xa0 \xa0block-size: 100%;\n \xa0  }\n \xa0 \xa0\n \xa0 \xa0html body {\n \xa0 \xa0 \xa0 \xa0min-block-size: 100%;\n \xa0  }\n}\n​\n/* 作用域的嵌套 */\n.card {\n \xa0 \xa0inline-size: 40ch;\n \xa0 \xa0aspect-ratio: 3/4;\n \xa0 \xa0\n \xa0 \xa0@scope (&) {\n \xa0 \xa0 \xa0  :scope {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0border: 1px solid white;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n​\n/* 等同于 */\n.card { \n \xa0 \xa0inline-size: 40ch; \n \xa0 \xa0aspect-ratio: 3/4; \n} \xa0\n​\n@scope (.card) { \xa0 \xa0\n \xa0  :scope { \n \xa0 \xa0 \xa0 \xa0border-block-end: 1px solid white; \n \xa0  } \xa0\n}\n​\n.parent {\n \xa0 \xa0color: blue;\n \xa0 \xa0\n \xa0 \xa0@scope (& > .scope) to (& .limit) {\n \xa0 \xa0 \xa0  & .content {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: red;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n​\n/* 等同于 */\n.parent { \n \xa0 \xa0color: blue; \n}\n​\n@scope (.parent > .scope) to (.parent > .scope .limit) {\n \xa0 \xa0.parent > .scope .content {\n \xa0 \xa0 \xa0 \xa0color: red;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["除此之外，条件还可以进一步的嵌套，就是 ",(0,r.jsx)(e.code,{children:"@"})," 规则中再嵌套 ",(0,r.jsx)(e.code,{children:"@"})," 规则，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:".foo {\n \xa0 \xa0display: grid;\n \xa0 \xa0\n \xa0 \xa0@media (orientation: landscape) {\n \xa0 \xa0 \xa0 \xa0grid-auto-flow: column;\n \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0@media (min-width > 1024px) {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0max-inline-size: 1024px;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n​\n/* 等同于 */ \xa0\n.foo { \n \xa0 \xa0display: grid; \n} \xa0\n​\n@media (orientation: landscape) { \xa0 \xa0\n \xa0 \xa0.foo { \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0grid-auto-flow: column; \xa0 \xa0\n \xa0  } \xa0\n} \xa0\n​\n@media (orientation: landscape) and (min-width > 1024px) { \xa0 \xa0\n \xa0 \xa0.foo { \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0max-inline-size: 1024px; \xa0 \xa0\n \xa0  } \xa0\n}\n​\nhtml {\n \xa0 \xa0@layer base {\n \xa0 \xa0 \xa0 \xa0block-size: 100%;\n \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0@layer support {\n \xa0 \xa0 \xa0 \xa0 \xa0  & body {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0min-block-size: 100%;\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n​\n/* 等同于 */ \xa0\n@layer base { \xa0 \xa0\n \xa0 \xa0html { \n \xa0 \xa0 \xa0 \xa0block-size: 100%; \n \xa0  } \xa0\n} \xa0\n​\n@layer base.support { \xa0 \xa0\n \xa0 \xa0html body { \n \xa0 \xa0 \xa0 \xa0min-block-size: 100%; \n \xa0  } \xa0\n}\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"理解-css-嵌套的解析器",children:["理解 CSS 嵌套的解析器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#理解-css-嵌套的解析器",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"接下来，我们来简单地了解一下 CSS 嵌套的解析器，这样我们就可以知道 CSS 解析器是如何处理嵌套的。有了这些知识，你就可以自信地使用 CSS 的嵌套，而不必经常查询相关的规则。"}),"\n",(0,r.jsx)(e.p,{children:"在介绍 CSS 嵌套的解析器之前，我们来看一个无效的 CSS 嵌套："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"main {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0 \xa0article {\n \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["注意，上面示例中的 ",(0,r.jsx)(e.code,{children:"article"})," 并没有生效。"]}),"\n",(0,r.jsxs)(e.p,{children:["造成这种现象，是 CSS 的嵌套规则决定的：“",(0,r.jsxs)(e.strong,{children:["CSS 的任何选择器都可以嵌套到另一个选择器中，但它必须以 ",(0,r.jsx)(e.code,{children:"&"})," 、",(0,r.jsx)(e.code,{children:"."}),"（类名）、",(0,r.jsx)(e.code,{children:"#"}),"（ID）、",(0,r.jsx)(e.code,{children:"@"}),"（",(0,r.jsx)(e.code,{children:"@"}),"规则）、",(0,r.jsx)(e.code,{children:":"}),"、",(0,r.jsx)(e.code,{children:"::"}),"、",(0,r.jsx)(e.code,{children:"*"}),"、",(0,r.jsx)(e.code,{children:"+"}),"、",(0,r.jsx)(e.code,{children:"~"}),"、",(0,r.jsx)(e.code,{children:">"})," 或 ",(0,r.jsx)(e.code,{children:"["}),"符号开头。"]})," ” 这些符号是一些识别符号，它会向解析器发出信号，表示它正在使用嵌套样式。"]}),"\n",(0,r.jsx)(e.p,{children:"换句话说，如果解析器找到的嵌套选择器并且没有以这些符号之一开始（比如，直接嵌套一个 HTML 元素选择器），那么嵌套就将失败，并错误地使用你的样式。"}),"\n",(0,r.jsxs)(e.p,{children:["根据嵌套的规则，我们可以在元素选择器 ",(0,r.jsx)(e.code,{children:"article"})," 前添加一个 ",(0,r.jsx)(e.code,{children:"&"})," 符号来使嵌套生效："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"main {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0  & article {\n \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["除此之外，我们还可以将元素选择器 ",(0,r.jsx)(e.code,{children:"article"})," 当作 ",(0,r.jsx)(e.code,{children:":is()"})," 或 ",(0,r.jsx)(e.code,{children:":where()"})," 选择器的参数，使嵌套生效："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"main {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0  :is(article) {\n \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0  }\n}\n​\n/* 或者 */\nmain {\n \xa0 \xa0color: red;\n \xa0 \xa0\n \xa0  :where(article) {\n \xa0 \xa0 \xa0 \xa0color: blue;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"css-作用域scope",children:["CSS 作用域：@scope",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#css-作用域scope",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["曾经 HTML 有一个 ",(0,r.jsx)(e.code,{children:"scoped"})," 属性，但它被弃用了。它在 CSS 中被 ",(0,r.jsx)(e.code,{children:"@scope"})," 所取代。这也是 Web 开发者一直期待的 CSS 功能之一，即 ",(0,r.jsx)(e.strong,{children:"CSS 作用域"}),"。"]}),"\n",(0,r.jsxs)(e.p,{children:["CSS 作用域 ",(0,r.jsx)(e.code,{children:"@scope"})," 主要有两个卖点：",(0,r.jsx)(e.strong,{children:"基于接近度的样式"}),"和",(0,r.jsx)(e.strong,{children:"为选择器设置下限"}),"。换句话说，作用域给 CSS 带来了两个关键的东西："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"一组样式可以根据在 DOM 中的接近程度覆盖另一组样式"}),"\n",(0,r.jsx)(e.li,{children:"更多地控制选择器针对哪些元素（即更好地操作 CSS 的级联）"}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"如何使用-css-的作用域",children:["如何使用 CSS 的作用域",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#如何使用-css-的作用域",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"我们将围绕着 CSS 作用域的两个卖点来展开，告诉大家如何使用 CSS 的作用域，从而使得大家明白它的工作原理。先从“基于接近度的样式”开始。"}),"\n",(0,r.jsxs)(e.h4,{id:"基于接近度的样式",children:["基于接近度的样式",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#基于接近度的样式",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"熟悉 CSS 的同学都应该知道，在 CSS 中一直以来都是依赖于源的顺序和选择器权重来覆盖样式。现在，CSS 有了作用域的功能，我们还可以根据接近程度来覆盖样式，而不是仅仅依赖于源的顺序和选择器权重来覆盖样式。例如，我们现在有两段不同的 HTML 结构："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'\x3c!-- 案例一 --\x3e\n<div class="red"> \xa0 \xa0\n \xa0 \xa0<div class="green"> \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0<div class="blue"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<button>Click</button> \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0</div> \xa0 \xa0\n \xa0 \xa0</div>\n</div>\n​\n\x3c!-- 案例二 --\x3e\n<div class="blue"> \xa0 \xa0\n \xa0 \xa0<div class="green"> \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0<div class="red"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<button>Click</button> \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0</div> \xa0 \xa0\n \xa0 \xa0</div>\n</div>\n'})}),"\n",(0,r.jsxs)(e.p,{children:["案例一中的 ",(0,r.jsx)(e.code,{children:"button"})," 离 ",(0,r.jsx)(e.code,{children:".blue"})," 更近，离 ",(0,r.jsx)(e.code,{children:".red"})," 更远；而案例二中的 ",(0,r.jsx)(e.code,{children:"button"})," 却离 ",(0,r.jsx)(e.code,{children:".red"})," 更近，离 ",(0,r.jsx)(e.code,{children:".blue"})," 更远。"]}),"\n",(0,r.jsxs)(e.p,{children:["现在，假设你使用 ",(0,r.jsx)(e.code,{children:"@scope"})," 写了下面这样的 CSS 代码："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@scope (.blue) { \xa0 \xa0\n \xa0 \xa0button { \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0background-color: blue; \xa0 \xa0\n \xa0  }\n} \xa0 \xa0\n​\n@scope (.green) { \xa0 \xa0\n \xa0 \xa0button { \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0background-color: green; \xa0 \xa0\n \xa0  }\n} \xa0 \xa0\n​\n@scope (.red) { \xa0 \xa0\n \xa0 \xa0button { \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0background-color: red; \xa0 \xa0\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["你猜，案例一和案例二中的按钮（",(0,r.jsx)(e.code,{children:"button"}),"）背景颜色分别是什么？只要看看按钮（",(0,r.jsx)(e.code,{children:"button"}),"）离得最近的祖先元素就知道了。案例一中的 ",(0,r.jsx)(e.code,{children:"button"})," 离 ",(0,r.jsx)(e.code,{children:".blue"})," 更近，离 ",(0,r.jsx)(e.code,{children:".red"})," 更远，所以按钮的背景颜色是蓝色（",(0,r.jsx)(e.code,{children:"blue"}),"）；而案例二中的 ",(0,r.jsx)(e.code,{children:"button"})," 却离 ",(0,r.jsx)(e.code,{children:".red"})," 更近，离 ",(0,r.jsx)(e.code,{children:".blue"})," 更远，所以按钮的背景颜色是红色："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:p,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/dyQwdZo",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/dyQwdZo"}),"（请使用 Chrome Canary 查看）"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["把上面示例的 HTML 结构稍微调整一下，例如，在每个 ",(0,r.jsx)(e.code,{children:"div"})," 中都嵌套一个 ",(0,r.jsx)(e.code,{children:"button"})," 元素："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'\x3c!-- 案例一 --\x3e\n<div class="red"> \xa0\n \xa0 \xa0<button>Button(外)</button> \xa0\n \xa0 \xa0<div class="green"> \xa0\n \xa0 \xa0 \xa0 \xa0<button>Button(中)</button> \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0<div class="blue"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<button>Button(内)</button> \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0</div> \xa0 \xa0\n \xa0 \xa0</div>\n</div>\n​\n\x3c!-- 案例二 --\x3e\n<div class="blue"> \xa0 \n \xa0 \xa0<button>Button(外)</button> \n \xa0 \xa0<div class="green">\n \xa0 \xa0 \xa0 \xa0<button>Button(中)</button> \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0<div class="red"> \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<button>Button(内)</button> \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0</div> \xa0 \xa0\n \xa0 \xa0</div>\n</div>\n'})}),"\n",(0,r.jsx)(e.p,{children:"在使用相同 CSS 样式代码情况之下，你能猜到示例中的每个按钮背景颜色？"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:t,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/Jjewpzd",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/Jjewpzd"})," （请使用 Chrome Canary 查看）"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["正如你所看到的，",(0,r.jsx)(e.strong,{children:"距离优先，来自内部作用域的样式将覆盖来自外部作用域的样式"}),"。这个示例所呈现的都是没有内部作用域限制，所有 ",(0,r.jsx)(e.code,{children:"button"})," 选择器都针对内部的 ",(0,r.jsx)(e.code,{children:"<button>"})," 元素。在这种情况下，内部作用域总是优先。"]}),"\n",(0,r.jsx)(e.p,{children:"上面两个示例所呈现的是，多个作用域针对同一个元素时，你可以控制哪个优先。当然，你也可以调整选择器权重，让具有更高权重的选择器优先，而不管它属于哪个作用域。例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@scope (.blue) {\n \xa0 \xa0button {\n \xa0 \xa0 \xa0 \xa0background-color: blue;\n \xa0  }\n}\n​\n@scope (.green) {\n \xa0 \xa0/* 使用 :is() 选择器增加了选择器权重 */\n \xa0  :is(button,#increase#specificity) {\n \xa0 \xa0 \xa0 \xa0background-color: green;\n \xa0  }\n}\n​\n@scope (.red) {\n \xa0 \xa0button {\n \xa0 \xa0 \xa0 \xa0background-color: red;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["上面代码中，使用 ",(0,r.jsx)(e.code,{children:":is()"})," 选择器增加了 ",(0,r.jsx)(e.code,{children:"button"})," 选择器权重。就该示例而言，最里面作用域是的 ",(0,r.jsx)(e.code,{children:"button"})," 将会受到中间作用域中选择器权重的影响。最终，除了最外的 ",(0,r.jsx)(e.code,{children:"button"})," 之外，其他的 ",(0,r.jsx)(e.code,{children:"button"})," 背景颜色都变成了绿色（",(0,r.jsx)(e.code,{children:"green"}),"）："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/zYMyWZv",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/zYMyWZv"})," （请使用 Chrome Canary 查看）"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["当你不想要这种行为时，你有一些方法可以用来防止它。你可以使用 ",(0,r.jsx)(e.a,{href:"https://juejin.cn/book/7223230325122400288/section/7259563116462080037",target:"_blank",rel:"noopener noreferrer",children:"CSS 的级联层"}),"（",(0,r.jsx)(e.code,{children:"@layer"}),"）来赋予一个组件优先于另一个组件。或者，你可以将内部作用域绑定到外部作用域，以防止这种情况发生。"]}),"\n",(0,r.jsxs)(e.p,{children:["我们来看一个真实的用例，即主题的切换。注意，这里主题切换不是根据用户偏好改变的亮色和暗色主题（Dark Mode），而是用特定的配色方案为页面提供不同的主题风格。这也是 Web 中常见的设计方式。例如，为了确保足够的颜色对比，便于用户阅读，链接（",(0,r.jsx)(e.code,{children:"<a>"}),"）文本在浅色背景上的颜色为深蓝色，反之在深色背景上链接的颜色为浅蓝色。以往，Web 开发者会在页面最外部的容器上（例如 ",(0,r.jsx)(e.code,{children:"<html>"})," 元素）添加类名来区分主题之间的差异。例如："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["浅色主题时，",(0,r.jsx)(e.code,{children:"html"})," 元素添加一个 ",(0,r.jsx)(e.code,{children:"theme-light"})," 的类名"]}),"\n",(0,r.jsxs)(e.li,{children:["深色主题时，",(0,r.jsx)(e.code,{children:"html"})," 元素添加一个 ",(0,r.jsx)(e.code,{children:"theme-dark"})," 的类名"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"如此一来，我们就可以像下面这样编写 CSS："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"/* 浅色主题 */\n@layer theme.light {\n \xa0 \xa0.theme--light { \xa0\n \xa0 \xa0 \xa0 \xa0background-color: white; \xa0\n \xa0 \xa0 \xa0 \xa0color: black; \xa0\n \xa0 \xa0 }\n \n \xa0 \xa0.theme--light a { \xa0\n \xa0 \xa0 \xa0 \xa0color: #00528a;\n \xa0  }\n}\n​\n/* 暗色主题 */\n@layer theme.dark {\n \xa0 \xa0.theme--dark { \xa0\n \xa0 \xa0 \xa0 \xa0background-color: black; \xa0\n \xa0 \xa0 \xa0 \xa0color: white;\n \xa0  }\n​\n \xa0 \xa0.theme--dark a { \xa0\n \xa0 \xa0 \xa0 \xa0color: #35adce;\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:a,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/Jjewvgw",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/Jjewvgw"})]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["看上去是符合我们的预期，但有一个问题：DOM 结构的嵌套。CSS 不会去查看最近 HTML 祖先来应用哪一个样式，CSS 只会根据 CSS 样式表（CSS 文件）中的源顺序（出现的先后顺序）来决定应用哪一个样式。假设类名 ",(0,r.jsx)(e.code,{children:".theme--light"})," 和 ",(0,r.jsx)(e.code,{children:".theme--dark"})," 不是在 ",(0,r.jsx)(e.code,{children:"html"})," 元素上设置，而是出现相互嵌套的现象，例如，",(0,r.jsx)(e.code,{children:".theme--light"})," 中嵌套了 ",(0,r.jsx)(e.code,{children:".theme--dark"})," ，或者 ",(0,r.jsx)(e.code,{children:".theme--dark"})," 中嵌套了 ",(0,r.jsx)(e.code,{children:".theme--light"})," ，此时，链接的文本颜色就有可能不符合预期："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="theme--light">\n \xa0 \xa0<a href="">链接颜色是深蓝色（符合预期）</a>\n</div>\n​\n<div class="theme--dark">\n \xa0 \xa0<a href="">链接颜色是浅蓝色（符合预期）</a>\n \xa0 \xa0\n \xa0 \xa0<div class="theme--light">\n \xa0 \xa0 \xa0 \xa0<a href="">链接颜色是浅蓝色（不符合预期）</a>\n \xa0 \xa0</div>\n</div>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:o,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/JjewZWq",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/JjewZWq"})]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["就上例这种现象而言，在 ",(0,r.jsx)(e.code,{children:"@scope"})," 出现之前，确实没有解决这个问题的好方法。"]}),"\n",(0,r.jsxs)(e.p,{children:["也就是说，现在我们可以使用 ",(0,r.jsx)(e.code,{children:"@scope"})," 来解决上面这个问题："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@layer reset, base, theme, scope;\n​\n@layer scope {\n \xa0 \xa0@scope (.theme--light) {\n \xa0 \xa0 \xa0 \xa0a {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: #00528a;\n \xa0 \xa0 \xa0  }\n \xa0  }\n​\n \xa0 \xa0@scope (.theme--dark) {\n \xa0 \xa0 \xa0 \xa0a {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: #35adce;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n​\n@layer theme.light {\n \xa0 \xa0/* 浅色主题 */\n \xa0 \xa0.theme--light {\n \xa0 \xa0 \xa0 \xa0background-color: white;\n \xa0 \xa0 \xa0 \xa0color: black;\n \xa0  }\n}\n​\n@layer theme.dark {\n \xa0 \xa0/* 暗色主题 */\n \xa0 \xa0.theme--dark {\n \xa0 \xa0 \xa0 \xa0background-color: black;\n \xa0 \xa0 \xa0 \xa0color: white;\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/vYQvrzX",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/vYQvrzX"})," （请使用 Chrome Canary 查看）"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["现在，当链接在白色背景上时，它就会变成深蓝色（",(0,r.jsx)(e.code,{children:"#00528a"}),"）；当它在黑色背景上时，它就会变成浅的蓝色（",(0,r.jsx)(e.code,{children:"#35adce"}),"）。"]}),"\n",(0,r.jsxs)(e.p,{children:["在 CSS 中，我们还可以使用 ",(0,r.jsx)(e.code,{children:":scope"})," 伪类来引用当前作用域的根。比如，我们使用 ",(0,r.jsx)(e.code,{children:":scope"})," 来重写前面的 CSS："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@layer scope {\n \xa0 \xa0@scope (.theme--light) {\n \xa0 \xa0 \xa0  :scope {/* 将选择任何具有 .theme--light 类的元素 */\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0background-color: white;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: black;\n \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0a {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: #00528a;\n \xa0 \xa0 \xa0  }\n \xa0  }\n​\n \xa0 \xa0@scope (.theme--dark) {\n \xa0 \xa0 \xa0  :scope {/* 将选择任何具有 .theme--dark 类的元素 */\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0background-color: black;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: white;\n \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0a {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: #35adce;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["注意，",(0,r.jsx)(e.code,{children:":scope"})," 不是一个新的伪类选择器，它在浏览器中已经存在很多年了，但是以前在样式表中使用它毫无意义，因为在 ",(0,r.jsx)(e.code,{children:"@scope"})," 规则之外，它的含义等同于 ",(0,r.jsx)(e.code,{children:":root"})," （选择文档的根元素，例如 ",(0,r.jsx)(e.code,{children:"html"})," 元素）。"]}),"\n",(0,r.jsxs)(e.h4,{id:"为选择器设置下限",children:["为选择器设置下限",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为选择器设置下限",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["有时，你只是希望对组件进行样式设计，而不想对嵌套在组件中的某些东西进行样式设计。例如，有一个 ",(0,r.jsx)(e.code,{children:"Accordion"})," 组件（手风琴组件） 放在 ",(0,r.jsx)(e.code,{children:"Card"})," 组件（卡片组件）中，并且这两个组件都有一个命名为 ",(0,r.jsx)(e.code,{children:".title"})," 的类名。它的 HTML 结构看起来可能像这样："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="card">\n \xa0 \xa0<h3 class="title">Card Title</h3>\n \xa0 \xa0<div class="slot">\n \xa0 \xa0 \xa0 \xa0<div class="accordion">\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<h3 class="title">Accordion Title</h3>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<div class="slot">\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\x3c!-- Accordion 组件内容 --\x3e\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0</div>\n</div> \n'})}),"\n",(0,r.jsxs)(e.p,{children:["在没有 CSS 作用域之前，直接使用 ",(0,r.jsx)(e.code,{children:".title"})," 选择器的话，将会同时修改卡片组件和手风琴组件的标题，这并不是我们想要的结果（我们只想修改卡片组件自身标题的样式）。"]}),"\n",(0,r.jsx)(e.p,{children:"现在，使用 CSS 作用域可以很容易做到。简单地说，你可以在作用域上为选择器设置一个下限，或者说在作用域上设置一个内边界。例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@scope (.card) to (.slot) {\n \xa0 \xa0/* 作用域样式只针对 .card 内，但不在 .slot 内 */\n \xa0  :scope {\n \xa0 \xa0 \xa0 \xa0padding: 1rem;\n \xa0 \xa0 \xa0 \xa0background-color: white;\n \xa0  }\n \xa0 \xa0\n \xa0 \xa0.title {\n \xa0 \xa0 \xa0 \xa0font-size: 1.2rem;\n \xa0 \xa0 \xa0 \xa0font-family: Georgia, serif;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["把这里的 ",(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"to"})})," 关键词想象成“直到”：这个作用域定义为从 ",(0,r.jsx)(e.code,{children:".card"})," 到 ",(0,r.jsx)(e.code,{children:".slot"})," 。现在，在这个作用域的任何选择器不会对卡片组件的 ",(0,r.jsx)(e.code,{children:".slot"})," 内元素中的任何内容起作用。"]}),"\n",(0,r.jsx)(e.p,{children:"把上面的示例简化一下，例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="component">\n \xa0 \xa0<p>在作用域内</p>\n \xa0 \xa0<div class="content">\n \xa0 \xa0 \xa0 \xa0<p>在作用域外</p>\n \xa0 \xa0</div>\n</div>\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@scope (.component) to (.content) {\n \xa0  :scope {\n \xa0 \xa0 \xa0 \xa0border: 1px dashed #fff;\n \xa0 \xa0 \xa0 \xa0padding: 1rem;\n \xa0  }\n \xa0 \xa0\n \xa0 \xa0p {\n \xa0 \xa0 \xa0 \xa0color: #09f;\n \xa0 \xa0 \xa0 \xa0padding-bottom: .2em;\n \xa0 \xa0 \xa0 \xa0border-bottom: 3px double;\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/JjewBvW",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/JjewBvW"})," （请使用 Chrome Canary 查看）"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["正如你所看到的，该作用域中的 ",(0,r.jsx)(e.code,{children:"p"})," 选择器并没有选中位于 ",(0,r.jsx)(e.code,{children:".content"})," 中的 ",(0,r.jsx)(e.code,{children:"p"})," 元素。你也可以把示例中的 ",(0,r.jsx)(e.code,{children:".content"})," 想象成前面示例中的 ",(0,r.jsx)(e.code,{children:".slot"})," 。或者说，在一个组件中，可以有很多个插槽，用来嵌套其他的组件，例如："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="component">\n \xa0 \xa0<p>Component</p>\n \xa0 \xa0<div class="slot--1">\x3c!-- 插槽一 --\x3e</div>\n \xa0 \xa0<div class="slot--2">\x3c!-- 插槽二 --\x3e</div>\n \xa0 \xa0\x3c!-- 其他插槽 --\x3e\n</div>\n'})}),"\n",(0,r.jsxs)(e.p,{children:["如果你想作用域的选择器同时对 ",(0,r.jsx)(e.code,{children:".slot--1"})," 和 ",(0,r.jsx)(e.code,{children:".slot--2"})," 不起作用的话，可以像下面这样使用 ",(0,r.jsx)(e.code,{children:"@scope"})," ："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@scope (.component) to (.slot--1, .slot--2) {\n \xa0 \xa0p {\n \xa0 \xa0 \xa0 \xa0color: red;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这种方式的意思是 ",(0,r.jsx)(e.code,{children:"@scope"})," 可以有任意多的“插槽”。"]}),"\n",(0,r.jsxs)(e.p,{children:["回到 ",(0,r.jsx)(e.code,{children:"Card"})," 组件嵌套 ",(0,r.jsx)(e.code,{children:"Accordion"})," 组件的示例中来："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="card">\n \xa0 \xa0<h3 class="title">Card Title</h3>\n \xa0 \xa0<div class="slot">\n \xa0 \xa0 \xa0 \xa0<div class="accordion">\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<h3 class="title">Accordion Title</h3>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<div class="slot">\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0\x3c!-- Accordion 组件内容 --\x3e\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0 \xa0 \xa0</div>\n \xa0 \xa0</div>\n</div> \n'})}),"\n",(0,r.jsxs)(e.p,{children:["假设你要给两个组件的标题运用不同的样式，那么你就可以嵌套两个作用域，并且每个作用域都可以使用相同的类名 ",(0,r.jsx)(e.code,{children:".title"})," 对标题样式化，还不会发生任何冲突。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@scope (.card) to (.slot) {\n \xa0 \xa0.title {\n \xa0 \xa0 \xa0 \xa0font-size: 1.2rem;\n \xa0 \xa0 \xa0 \xa0font-family: Georgia, serif;\n \xa0  }\n}\n​\n@scope (.accordion) to (.slot) {\n \xa0 \xa0.title {\n \xa0 \xa0 \xa0 \xa0font-family: Helvetica, sans-serif;\n \xa0 \xa0 \xa0 \xa0text-transform: uppercase;\n \xa0 \xa0 \xa0 \xa0letter-spacing: 0.01em;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["事实上，你甚至可能不再需要类名了，可以直接使用标签元素，比如示例中的 ",(0,r.jsx)(e.code,{children:"h3"})," ："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@scope (.card) to (.slot) {\n \xa0 \xa0h3 {\n \xa0 \xa0 \xa0 \xa0font-size: 1.2rem;\n \xa0 \xa0 \xa0 \xa0font-family: Georgia, serif;\n \xa0  }\n}\n​\n@scope (.accordion) to (.slot) {\n \xa0 \xa0h3 {\n \xa0 \xa0 \xa0 \xa0font-family: Helvetica, sans-serif;\n \xa0 \xa0 \xa0 \xa0text-transform: uppercase;\n \xa0 \xa0 \xa0 \xa0letter-spacing: 0.01em;\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"综合案例",children:["综合案例",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#综合案例",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"最后，将以下面这个案例来结合这节课。在下面这个示例中，使用了 CSS 的级联层、嵌套和作用域三个主要功能来编写和管理 CSS 的代码。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:s,alt:"img"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["Demo 地址：",(0,r.jsx)(e.a,{href:"https://codepen.io/airen/full/gOQZdOZ",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/gOQZdOZ"})," （请使用 Chrome Canary 查看）"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"先上 HTML 代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-HTML",children:'<div class="card">\n \xa0 \xa0<header>\n \xa0 \xa0 \xa0 \xa0<h2>Epic title</h2>\n \xa0 \xa0 \xa0 \xa0<p>Lorem ipsum dolor sit amet</p>\n \xa0 \xa0</header>\n \xa0 \xa0\n \xa0 \xa0<figure class="responsive-image">\n \xa0 \xa0 \xa0 \xa0<img height="640" width="640" src="https://assets.codepen.io/2585/uszetlo5l6591.webp" alt="cyberpunk raining day in tokyo with purple and cyan lights">\n \xa0 \xa0 \xa0 \xa0<figcaption>\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0<a href="#">Source</a>\n \xa0 \xa0 \xa0 \xa0</figcaption>\n \xa0 \xa0</figure>\n \xa0 \xa0\n \xa0 \xa0<article>\n \xa0 \xa0 \xa0 \xa0<p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Odio asperiores voluptates officiis totam, est sequi iure libero rem nobis veniam consectetur commodi voluptatibus maxime labore cumque, dolore, quam eveniet magnam.</p>\n \xa0 \xa0</article>\n \xa0 \xa0\n \xa0 \xa0<footer>\n \xa0 \xa0 \xa0 \xa0<button>Like</button>\n \xa0 \xa0 \xa0 \xa0<button>Share</button>\n \xa0 \xa0</footer>\n</div>\n'})}),"\n",(0,r.jsxs)(e.p,{children:["首先使用 ",(0,r.jsxs)(e.a,{href:"https://juejin.cn/book/7223230325122400288/section/7259563116462080037",target:"_blank",rel:"noopener noreferrer",children:["CSS 的 ",(0,r.jsx)(e.code,{children:"@layer"})," 来管理 CSS 的级联层"]}),"。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@layer demo, images, cards;\n​\n@layer cards {\n \xa0 \xa0/* CSS */\n}\n​\n@layer images {\n \xa0 \xa0/* CSS */\n}\n​\n@layer demo {\n \xa0 \xa0/* CSS */\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["其中 ",(0,r.jsx)(e.code,{children:"@layer images"})," 主要是用来样式化卡片中图片的："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@layer images {\n \xa0 \xa0.responsive-image {\n \xa0 \xa0 \xa0 \xa0max-inline-size: 50ch;\n \xa0 \xa0 \xa0 \xa0aspect-ratio: 16/9;\n \xa0 \xa0\n \xa0 \xa0 \xa0  & img {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0max-inline-size: 100%;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0block-size: 100%;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0object-fit: cover;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0object-position: bottom;\n \xa0 \xa0 \xa0  }\n \xa0 \xa0\n \xa0 \xa0 \xa0  & figcaption {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0text-align: center;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0padding-block: 1ch;\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n"})}),"\n",(0,r.jsx)(e.p,{children:"你可能已经发现了，上面的代码使用了嵌套来编写和管理 CSS 代码。"}),"\n",(0,r.jsxs)(e.p,{children:["就我们这个示例而言，更多的样式是放在 ",(0,r.jsx)(e.code,{children:"@layer cards"})," 级联层："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-CSS",children:"@layer cards {\n \xa0 \xa0@scope (.card) to (> header > *, > figure > *, > footer > *) {\n \xa0 \xa0 \xa0  :scope {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0display: grid;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0background: oklch(50% none none / 20%);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0border-radius: 10px;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0border: 1px solid oklch(50% none none / 20%);\n \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0@media (prefers-color-scheme: light) {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0background: white;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0box-shadow: 0 30px 10px -20px oklch(0% none none / 25%);\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0  & header {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0display: grid;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0gap: 0.5ch;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0padding: 2ch;\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0  & article {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0max-inline-size: 50ch;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0line-height: 1.5;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0padding: 2ch 2ch 1ch;\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0  & footer {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0display: flex;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0justify-content: flex-end;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0padding: 1ch 2ch;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0gap: 1ch;\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0  }\n \xa0  }\n​\n \xa0 \xa0@scope (footer) {\n \xa0 \xa0 \xa0 \xa0button {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0min-width: 110px;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0background-color: #e5e5e5;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0padding: 1rem 2rem;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: #c71e7e;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0display: flex;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0transition: all 0.2s ease-in-out;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0border: none;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0border-radius: 4px;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0box-shadow: 0 0 0.125em 0.0125em rgb(0 0 0 / 0.25);\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0cursor: pointer;\n \xa0 \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0  &:hover {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: #fff;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0background-color: #c71e7e;\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0  &:focus-visible {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0box-shadow: 0 0 0.125em 0.0125em currentColor;\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0  &:last-of-type {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: #286ED6;\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0 \xa0 \xa0\n \xa0 \xa0 \xa0 \xa0 \xa0  &:last-of-type:hover {\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0background-color: \xa0#286ED6;\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0color: #fff;\n \xa0 \xa0 \xa0 \xa0 \xa0  }\n \xa0 \xa0 \xa0  }\n \xa0  }\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"@layer cards"})," 级联层中，除了使用了 CSS 的嵌套之外，还使用了 CSS 作用域。在这里就不对代码做过多的阐述了。"]}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在这节课中，我们主要介绍了 CSS 的两个最新特性，而且这两个最新特性都是大家一直期待的。就 CSS 的嵌套来说，Web 开发者不会感到陌生，毕竟它和 CSS 处理器中的嵌套基本相似，唯一不同的是，CSS 的嵌套，",(0,r.jsxs)(e.strong,{children:["它必须以",(0,r.jsx)(e.code,{children:"&"}),"、",(0,r.jsx)(e.code,{children:"."}),"（类名）、",(0,r.jsx)(e.code,{children:"#"}),"（ID）、",(0,r.jsx)(e.code,{children:"@"}),"（",(0,r.jsx)(e.code,{children:"@"}),"规则）、",(0,r.jsx)(e.code,{children:":"}),"、",(0,r.jsx)(e.code,{children:"::"}),"、",(0,r.jsx)(e.code,{children:"*"}),"、",(0,r.jsx)(e.code,{children:"+"}),"、",(0,r.jsx)(e.code,{children:"~"}),"、",(0,r.jsx)(e.code,{children:">"}),"或",(0,r.jsx)(e.code,{children:"["}),"符号开头。"]})," 否则，CSS 解析器将会视其无效。另外，在使用 CSS 的嵌套时，也和 CSS 处理器嵌套一样，最好不要超过三层。"]}),"\n",(0,r.jsxs)(e.p,{children:["CSS 的作用 ",(0,r.jsx)(e.code,{children:"@scope"})," 可以更好让我们管理 CSS 的级联层，也能更好的帮助我们覆盖样式。"]}),"\n",(0,r.jsxs)(e.p,{children:["也就是说，到目前为止，现代 CSS 中，你至少可以使用级联层（",(0,r.jsx)(e.code,{children:"@layer"})," ）、嵌套和作用域（",(0,r.jsx)(e.code,{children:"@scope"}),"）来编写和管理 CSS 代码。这些功能解决了 CSS 中最为头痛的两个问题，一个是权重，另一个是作用域。它们的组合除增强了 CSS 功能之外，还将改变 Web 开发者编写、管理和维护代码的方式。"]})]})}function b(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(m,{...n})}):m(n)}let f=b;b.__RSPRESS_PAGE_META={},b.__RSPRESS_PAGE_META["%E7%8E%B0%E4%BB%A3CSS%2F%E7%AC%AC34%E7%AB%A0%E2%80%94CSS%E7%9A%84%E5%B5%8C%E5%A5%97%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9A%26%E5%92%8C%40scope.md"]={toc:[{text:"CSS 的嵌套",id:"css-的嵌套",depth:2},{text:"开始使用 CSS 的嵌套",id:"开始使用-css-的嵌套",depth:3},{text:"选择所有圆形",id:"选择所有圆形",depth:4},{text:"同时选择所有正方形和三角形",id:"同时选择所有正方形和三角形",depth:4},{text:"选择大的三角形和圆形",id:"选择大的三角形和圆形",depth:4},{text:"选择除粉红色之外的所有图形",id:"选择除粉红色之外的所有图形",depth:4},{text:"CSS 的条件嵌套",id:"css-的条件嵌套",depth:3},{text:"理解 CSS 嵌套的解析器",id:"理解-css-嵌套的解析器",depth:3},{text:"CSS 作用域：@scope",id:"css-作用域scope",depth:2},{text:"如何使用 CSS 的作用域",id:"如何使用-css-的作用域",depth:3},{text:"基于接近度的样式",id:"基于接近度的样式",depth:4},{text:"为选择器设置下限",id:"为选择器设置下限",depth:4},{text:"综合案例",id:"综合案例",depth:2},{text:"小结",id:"小结",depth:2}],title:"第34章—CSS的嵌套和作用域：&和@scope",headingTitle:"第34章—CSS的嵌套和作用域：&和@scope",frontmatter:{}}}}]);