"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["69066"],{413195:function(n,e,s){s.r(e),s.d(e,{default:()=>o});var c=s(552676),i=s(740453);let r=s.p+"static/image/cc6968dc2ea626efa9cc44c741976c8e.0dbf2d47.png";function a(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",pre:"pre",code:"code",img:"img"},(0,i.ah)(),n.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(e.h1,{id:"33手写-babel-cli篇",children:["33.手写 Babel： cli篇",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#33手写-babel-cli篇",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"上节我们实现了完整的编译流程，支持了插件，可以通过引入模块的方式使用，这一节我们实现下命令行的方式。"}),"\n",(0,c.jsx)(e.p,{children:"我们会实现以下功能："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"支持命令行指定参数，指定要编译的文件、输出目录、是否 watch 等"}),"\n",(0,c.jsx)(e.li,{children:"支持配置文件"}),"\n",(0,c.jsx)(e.li,{children:"编译文件的路径支持 glob，可以模糊匹配"}),"\n",(0,c.jsx)(e.li,{children:"生成 sourcemap，自动添加 sourceMapUrl 到文件内容中"}),"\n",(0,c.jsx)(e.li,{children:"支持 watch，文件变动立即重新编译"}),"\n"]}),"\n",(0,c.jsxs)(e.h2,{id:"思路分析",children:["思路分析",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路分析",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"命令行工具就是通过命令行启动的，要支持命令行启动需要在 js 文件开头加上"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"#!/usr/bin/env node\n"})}),"\n",(0,c.jsxs)(e.p,{children:["命令行参数的解析可以使用 ",(0,c.jsx)(e.a,{href:"https://www.npmjs.com/package/commander",target:"_blank",rel:"noopener noreferrer",children:"commander"}),"，它可以解析命令行参数，然后可以直接拿到 parse 之后的结果。"]}),"\n",(0,c.jsxs)(e.p,{children:["配置文件的指定可以使用 ",(0,c.jsx)(e.a,{href:"https://www.npmjs.com/package/cosmiconfig",target:"_blank",rel:"noopener noreferrer",children:"cosmiconfig"}),"，它支持如下的查找方式："]}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"package.json"})," 的属性"]}),"\n",(0,c.jsx)(e.li,{children:"扩展名为 rc 的 JSON 或者 YAML"}),"\n",(0,c.jsxs)(e.li,{children:["扩展名为 ",(0,c.jsx)(e.code,{children:".json"}),"、\xa0",(0,c.jsx)(e.code,{children:".yaml"}),"、\xa0",(0,c.jsx)(e.code,{children:".yml"}),"、\xa0",(0,c.jsx)(e.code,{children:".js"}),"、",(0,c.jsx)(e.code,{children:".cjs"})," 、",(0,c.jsx)(e.code,{children:".config.js"}),"、",(0,c.jsx)(e.code,{children:".config.cjs"})," 的 rc 文件"]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:".config.js"}),"\xa0或者 ",(0,c.jsx)(e.code,{children:".config.cjs"})," 的 commonjs 模块"]}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"这种配置文件查找机制在 eslint、babel 等很多工具中都有应用，我们也采用这种方式。"}),"\n",(0,c.jsxs)(e.p,{children:["文件模糊匹配使用 ",(0,c.jsx)(e.a,{href:"https://www.npmjs.com/package/glob",target:"_blank",rel:"noopener noreferrer",children:"glob"})," 来匹配，它会返回匹配后的文件路径。"]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'glob("**/*.js", options, function (er, files) {})\n'})}),"\n",(0,c.jsxs)(e.p,{children:["watch 的实现使用 ",(0,c.jsx)(e.a,{href:"https://www.npmjs.com/package/chokidar",target:"_blank",rel:"noopener noreferrer",children:"chokidar"}),"，它会监听文件的变动，包括文件增加、删除、修改、重命名，目录增加、删除等，然后把变动的文件路径传入回调函数。监听的文件也支持通过 glob 字符串来指定。"]}),"\n",(0,c.jsx)(e.p,{children:"知道了 watch、命令行参数解析、配置文件查找、文件模糊匹配都怎么做之后，我们来串联下整体流程："}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"通过 commander 解析命令行参数，拿到 outDir（输出目录）、watch（是否监听）以及 glob 字符串"}),"\n",(0,c.jsx)(e.li,{children:"解析 glob 字符串，拿到要编译的文件路径"}),"\n",(0,c.jsx)(e.li,{children:"查找配置文件，拿到配置信息"}),"\n",(0,c.jsx)(e.li,{children:"依次编译每一个文件，传入配置信息，输出到 outDir 目录，并且添加 sourcemap 的关联"}),"\n",(0,c.jsx)(e.li,{children:"如果开启了 watch，则监听文件变动，每次变动都重新编译该文件"}),"\n"]}),"\n",(0,c.jsx)(e.p,{children:"之后还需要在 package.json 中配置下 bin 属性，这样才可以作为命令行工具来注册。"}),"\n",(0,c.jsx)(e.p,{children:"下面我们实现一下："}),"\n",(0,c.jsxs)(e.h2,{id:"代码实现",children:["代码实现：",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"引入 commander，声明 outDir、watch 等参数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"const commander = require('commander');\n\ncommander.option('--out-dir <outDir>', '输出目录');\ncommander.option('--watch', '监听文件变动');\n\ncommander.parse(process.argv);\n"})}),"\n",(0,c.jsx)(e.p,{children:"对传入的参数 process.argv 做 parse 之后就可以拿到具体的值："}),"\n",(0,c.jsx)(e.p,{children:"比如我们传入："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-shell",children:"my-babel ./input/*.js --out-dir ./dist --watch\n"})}),"\n",(0,c.jsx)(e.p,{children:"在代码里就可以拿到"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"const cliOpts = commander.opts();\n\ncliOptions.outDir;// ./dist\ncliOptions.watch // true\ncommander.args[0] // ./input/*.js\n"})}),"\n",(0,c.jsx)(e.p,{children:"我们要对输入的参数做下校验，然后打印提示信息："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"if (process.argv.length <=2 ) {\n    commander.outputHelp();\n    process.exit(0);\n}\n\nconst cliOpts = commander.opts();\n\nif (!commander.args[0]) {\n    console.error('没有指定待编译文件');\n    commander.outputHelp();\n    process.exit(1);\n}\n\nif(!cliOpts.outDir) {\n    console.error('没有指定输出目录');\n    commander.outputHelp();\n    process.exit(1);\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"这样，我们就完成了对命令行参数的处理。"}),"\n",(0,c.jsx)(e.p,{children:"接下来，我们对 glob 字符串做解析，拿到具体的文件路径："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"const filenames = glob.sync(commander.args[0]);\n"})}),"\n",(0,c.jsx)(e.p,{children:"然后查找配置文件："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"const explorerSync = cosmiconfigSync('myBabel');\nconst searchResult = explorerSync.search();\n"})}),"\n",(0,c.jsx)(e.p,{children:"我们通过 options 来集中存放命令行参数和解析后的配置文件的参数："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"const options = {\n    babelOptions: searchResult.config,\n    cliOptions:  {\n        ...cliOpts,\n        filenames\n    }\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"之后，就可以开始编译了。我们定义一个 compile 方法，传入文件路径的数组，然后，对每个文件的内容进行读取，然后进行编译，之后输出到目标目录。"}),"\n",(0,c.jsx)(e.p,{children:"这里要注意的是，如果 outDir 不存在，需要先创建。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"function compile(fileNames) {\n    fileNames.forEach(async filename => {\n        const fileContent = await fsPromises.readFile(filename, 'utf-8');\n        const baseFileName = path.basename(filename);\n        const sourceMapFileName = baseFileName + '.map.json';\n\n        // 编译的过程，后面补充\n        \n        //如果目录不存在则创建\n         try {\n            await fsPromises.access(options.cliOptions.outDir);\n         } catch(e) {\n            await fsPromises.mkdir(options.cliOptions.outDir);\n         }\n         // 拼接输出的路径\n         const distFilePath = path.join(options.cliOptions.outDir, baseFileName);\n         const distSourceMapPath = path.join(options.cliOptions.outDir, baseFileName + '.map.json');\n \n         await fsPromises.writeFile(distFilePath, generatedFile);\n         await fsPromises.writeFile(distSourceMapPath, res.map);\n     })\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"编译就是使用我们之前实现的 babel core，把生成的 sourcemap 关联到目标代码。"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"const res = myBabel.transformSync(fileContent, {\n    ...options.babelOptions,\n    fileName: baseFileName\n });\n const generatedFile = res.code + '\\n' + '//# sourceMappingURL='\\n' + sourceMapFileName;\n"})}),"\n",(0,c.jsx)(e.p,{children:"之后，如果指定了 watch，也需要重新编译一次："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"\nif(cliOpts.watch) {\n    const chokidar = require('chokidar');\n\n    chokidar.watch(commander.args[0]).on('all', (event, path) => {\n        console.log('检测到文件变动，编译：' + path);\n        compile([path]);\n    });\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"这样，我们就实现了命令行参数的解析，编译多个文件，watch 文件变动增量编译的功能。"}),"\n",(0,c.jsx)(e.p,{children:"下面我们来测试一下："}),"\n",(0,c.jsxs)(e.h2,{id:"测试",children:["测试",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#测试",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"我们在 test 目录下新建一个配置文件 myBabel.config.js:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"function plugin2(api, options) {\n    return {\n        visitor: {\n            Program(path) {\n                Object.entries(path.scope.bindings).forEach(([id, binding]) => {\n                    if (!binding.referenced) {\n                        binding.path.remove();\n                    }\n                });\n            },\n            FunctionDeclaration(path) {\n                Object.entries(path.scope.bindings).forEach(([id, binding]) => {\n                    if (!binding.referenced) {\n                        binding.path.remove();\n                    }\n                });\n            }\n        }\n    }\n}\n\nmodule.exports = {\n    parserOpts: {\n        plugins: ['literal', 'guangKeyword']\n    },\n    plugins: [\n        [\n            plugin2\n        ]\n    ]\n}\n"})}),"\n",(0,c.jsx)(e.p,{children:"然后添加一个 input 目录，里面放上两个文件："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"// input1.js\nconst c = 1;\nconst d = 2;\nconst e = 4;\n\nfunction add(a, b) {\n    const tmp = 1;\n    return a + b;\n}\n\nadd(c, d);\n"})}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"// input2.js\nfunction minus(a, b) {\n    return a - b;\n}\n\nminus(3, 4);\n"})}),"\n",(0,c.jsx)(e.p,{children:"之后我们可以通过下面的方式来测试："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"node ../src/cli/index.js ./input/*.js --out-dir ./dist --watch\n"})}),"\n",(0,c.jsx)(e.p,{children:"也可以用 vscode 的 debugger 来跑，这样能打断点调试，在 .vscode/launch.json 中添加如下配置："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-json",children:'{\n    "name": "测试 babel cli",\n    "program": "${workspaceFolder}/exercize-babel/src/cli/index.js",//运行的代码\n    "request": "launch",\n    "type": "node",\n    "args": [\n        "./input/*.js", "--out-dir", "./dist",\n        "--watch",\n    ],//命令行参数\n    "cwd": "${workspaceFolder}/exercize-babel/test"//运行的目录\n},\n'})}),"\n",(0,c.jsx)(e.p,{children:"然后点击 debug 按钮就可以跑了。\n但是这样测试需要指定路径，我们还可以把这个命令注册到本地的全局目录："}),"\n",(0,c.jsx)(e.p,{children:"在 cli/index.js 文件开头加上:"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:"#!/usr/bin/env node\n"})}),"\n",(0,c.jsx)(e.p,{children:"在 package.json 中注册："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-javascript",children:'"bin": {\n    "my-babel": "./src/cli/index.js"\n}\n'})}),"\n",(0,c.jsx)(e.p,{children:"然后执行 npm link，注册到全局，之后就可以直接这样使用了："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"myBabel ./input/*.js --out-dir ./dist --watch\n"})}),"\n",(0,c.jsx)(e.p,{children:"效果如下："}),"\n",(0,c.jsx)(e.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsx)(e.p,{children:"当然，如果是正式的命令行工具，需要发布到 npm 仓库，然后 npm install 的方式来安装和使用。"}),"\n",(0,c.jsx)(e.p,{children:"如果 npm link 之后还是找不到 my-babel 的命令，那么可能是你没有把全局bin 的位置添加到环境变量的 PATH 中，可以这样做："}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{children:"export PATH = $PATH:`npm get prefix`/bin\n"})}),"\n",(0,c.jsx)(e.p,{children:"把这行命令添加到 ~/.bashrc 下，然后 source ~/.bashrc 就可以了。"}),"\n",(0,c.jsx)(e.p,{children:"npm get prefix 是查看本地 npm 的全局路径，而 bin 就是命令的路径，添加到 PATH 中就可以查找到了。"}),"\n",(0,c.jsxs)(e.h2,{id:"总结",children:["总结",(0,c.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(e.p,{children:"我们实现了 babel cli 的命令行参数的解析（commander），模糊匹配文件（glob）、配置文件查找（cosmiconfig）、监听文件变动（chokidar）等功能。之后在 package.json 中的 bin 来注册就可以使用了。"}),"\n",(0,c.jsx)(e.p,{children:"本地测试的时候可以 link 到全局目录，当然全局目录需要在 PATH 中，如果不在的话，需要 npm get prefix 看一下全局 npm 路径，然后添加到 PATH。"}),"\n",(0,c.jsxs)(e.p,{children:["（代码在",(0,c.jsx)(e.a,{href:"https://github.com/QuarkGluonPlasma/babel-plugin-exercize",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"，建议 git clone 下来通过 node 跑一下）"]})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(a,{...n})}):a(n)}let o=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F33.%E6%89%8B%E5%86%99%20Babel%EF%BC%9A%20cli%E7%AF%87.md"]={toc:[{text:"思路分析",id:"思路分析",depth:2},{text:"代码实现：",id:"代码实现",depth:2},{text:"测试",id:"测试",depth:2},{text:"总结",id:"总结",depth:2}],title:"33.手写 Babel： cli篇",headingTitle:"33.手写 Babel： cli篇",frontmatter:{}}}}]);