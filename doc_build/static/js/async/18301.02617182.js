"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["18301"],{975187:function(e,n,t){t.r(n),t.d(n,{default:()=>u});var r=t(552676),s=t(740453);let a=t.p+"static/image/d82887e27b6c0112c9613b6ce25f15f3.12c8d7a5.webp",i=t.p+"static/image/30903cd9a203eaa042d59b4c505795e5.bedfbc54.webp",c=t.p+"static/image/c7be983d6d23636906f50621b65e4389.37e504a5.webp",o=t.p+"static/image/27c690568603bf53bf4aad4d6f67915c.d9c984f7.webp",l=t.p+"static/image/6de4dab8b40eb3468fc68f8d044b0279.8fca9937.webp",d=t.p+"static/image/bde8b89f6f3d4890e03bac055e8fa213.35d72f85.webp",m=t.p+"static/image/6760fef04a868edd86a461c07abade24.2c377a52.webp",h=t.p+"static/image/6846bb4959e4d11c283f09fadd27b741.1861942e.webp";function p(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",code:"code",pre:"pre",strong:"strong",ul:"ul",li:"li",blockquote:"blockquote",img:"img"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"18业务篇-思考并补全遗漏的功能细节整体优化代码让应用更健壮",children:["18.业务篇-思考并补全遗漏的功能细节，整体优化代码，让应用更健壮",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18业务篇-思考并补全遗漏的功能细节整体优化代码让应用更健壮",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前边文章以功能需求开发为主，但回过头看，貌似每个功能点都相对“割裂”，接下来让我们补全所遗漏的功能交互点，让整个应用更加健壮可用。如果你对本章节内容兴趣不大，可以快速阅读或跳过。"}),"\n",(0,r.jsxs)(n.h2,{id:"功能一空模版模版不可预览异常处理",children:["功能一：空模版/模版不可预览异常处理",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能一空模版模版不可预览异常处理",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6950646725295996940/section/6962940426999300109",target:"_blank",rel:"noopener noreferrer",children:"第十五章"}),"我们实现了简历模版功能，并且添加了侧边栏的拉伸收起效果，但对于空模版或模版不可预览的异常并未进行处理。废话不多说，整起！"]}),"\n",(0,r.jsxs)(n.h3,{id:"11-点击模版存入-redux",children:["1.1 点击模版，存入 Redux",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-点击模版存入-redux",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["前往 ",(0,r.jsx)(n.code,{children:"/renderer/container/templateList/Navigation"}),"，我们修改 ",(0,r.jsx)(n.code,{children:"index.tsx"})," 代码"]}),"\n",(0,r.jsx)(n.p,{children:"下面是伪代码，部分代码进行省略，建议大家直接看线上代码"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// /renderer/container/templateList/Navigation/index.tsx\n\nimport { useDispatch, useSelector } from \'react-redux\';\n\nfunction Navigation() {\n  const dispatch = useDispatch();\n\n  // \uD83D\uDC47 选中模版，存入Redux\n  const onSelect = (template: TSTemplate.Item) => {\n    dispatch({\n      type: \'templateModel/setStore\',\n      payload: {\n        key: \'selectTemplate\',\n        values: template,\n      },\n    });\n  };\n\n  return (\n    <div styleName="navigation">\n      <MyScrollBox maxHeight={height - HEADER_HEIGHT}>\n        {templateList &&\n          templateList.length > 0 &&\n          templateList.map((template: TSTemplate.Item) => {\n            return (\n              <div styleName="template" key={template?.templateId}>\n                {/* \uD83D\uDC47 部分代码忽略，为预览模版按钮注册点击事件 */}\n                {selectTemplate?.templateId !== template?.templateId && (\n                  <MyButton size="middle" className="view-btn" onClick={() =>  onSelect(template)}>\n                    预览模版\n                  </MyButton>\n                )}\n              </div>\n            );\n          })}\n      </MyScrollBox>\n    </div>\n  );\n}\n\nexport default Navigation;\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"12-添加空缺省组件",children:["1.2 添加空缺省组件",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-添加空缺省组件",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们切换模版，将当前模版存入 Redux 中，接下来需要在“内容”区域，根据选中的模版进行条件判断，存在模版则展示出来，不存在则显示缺省组件。在此之前，我们先简单实现一下空缺省组件。"}),"\n",(0,r.jsxs)(n.p,{children:["前往 ",(0,r.jsx)(n.code,{children:"renderer/common/components"}),"，我们在公共组件下，新增一个名为 ",(0,r.jsx)(n.code,{children:"MyEmpty"})," 的文件夹，主要是空数据状态时的说明，效果为",(0,r.jsx)(n.code,{children:"一张图 + 一句话"}),"，让我们来写一下代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// renderer/common/components/MyEmpty/index.tsx\n\nimport React from 'react';\nimport './index.less';\nexport type SizeType = 'small' | 'big';\n\ninterface IEmptyProps {\n  imgSrc: string;\n  size?: SizeType;\n  label?: string;\n  style?: React.CSSProperties;\n}\n\nfunction MyEmpty({ imgSrc, size = 'small', style, label }: IEmptyProps) {\n  return (\n    <div styleName=\"empty\">\n      <img src={imgSrc} style={style} styleName={`img-${size}`} />\n      {label && <p styleName=\"label\">{label}</p>}\n    </div>\n  );\n}\n\nexport default MyEmpty;\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"13-遇到问题",children:["1.3 遇到问题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-遇到问题",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这里有一个很蛋疼的问题：",(0,r.jsx)(n.strong,{children:"如何保证模版组件和模版封面是一一对应关系"}),"？举个例子:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["在 ",(0,r.jsx)(n.code,{children:"assets"})," 静态资源文件夹下，有一个模版封面 ",(0,r.jsx)(n.code,{children:"template1.png"})]}),"\n",(0,r.jsxs)(n.li,{children:["在 ",(0,r.jsx)(n.code,{children:"renderer/container/templates"})," 模版仓库中，有一个模版组件 ",(0,r.jsx)(n.code,{children:"<TemplateOne />"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["这时候如何保证 ",(0,r.jsx)(n.code,{children:"template1.png"})," 对应的就是 ",(0,r.jsx)(n.code,{children:"<TemplateOne />"})," ？ 我们能在主观意识上，清楚知道，模版封面 1 对应模版组件 1，但计算机并不知道，代码该如何写？"]}),"\n",(0,r.jsxs)(n.p,{children:["假设我将 ",(0,r.jsx)(n.code,{children:"template1.png"})," 改成 ",(0,r.jsx)(n.code,{children:"template2.png"}),"，是否意味着，这张模版封面对应",(0,r.jsx)(n.code,{children:"<TemplateTwo />"}),"呢？答案很显然：并不是！"]}),"\n",(0,r.jsx)(n.p,{children:"这个问题貌似很难被解决，举个场景，现在存在 10 张模版封面，对应 10 个模版组件，在应用加载时，我们通过读取静态资源文件，假设以有序的形式展示我们的封面，伪代码为："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"fileAction.readDir(assetPath).then((files) => {\n  console.log(files);\n  // ['template1.png', 'template2.png', 'template3.png', 'template4.png', ...]\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们可以通过“投机取巧”的方式，将读到的模版封面的文件索引存入到 redux 中"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"fileAction.readDir(assetPath).then((files) => {\n  if (files.length > 0) {\n    let templateList = files.map((fileName, index) => {\n      const base64URL = await fileAction.read(`${appPath}assets/template/${fileName}`, 'base64');\n      return {\n        templateName: fileName,\n        templateId: createUID(),\n        // \uD83D\uDC47 这里记录索引，将其顺带存入到 Redux 中\n        templateIndex: index + 1,\n        templateCover: `data:image/png;base64,${base64URL}`,\n      };\n    });\n\n    // \uD83D\uDC47 存入 Redux 的逻辑，这里就不展示了\n  }\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"之后我们可以通过索引对应到模版组件"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"{selectTemplate?.templateIndex === 1 && <TemplateOne />}\n{selectTemplate?.templateIndex === 2 && <TemplateTwo />}\n{selectTemplate?.templateIndex === 3 && <TemplateThree />}\n{selectTemplate?.templateIndex === 4 && <TemplateFour />}\n"})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"这种方式纯属于投机取巧，这要求我们的模版封面必须是按照顺序进行命名，并且每次新增一个模版封面，还需要去添加对应的模版组件，以及渲染的条件语句"}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"如果中途我们将模版封面的命名打乱，显而易见的后果就是：模版与封面对应不上。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"老实说，该问题我还未有较好的解决方案，目前有个小思路，但还需要经过验证可行性。为此我们先将其放一放，继续往下开发。"})}),"\n",(0,r.jsxs)(n.h3,{id:"14-暂时缓缓继续开发",children:["1.4 暂时缓缓，继续开发",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14-暂时缓缓继续开发",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如何实现封面与模版的对应关系？暂时以上边所说的索引进行简单实现，前往 ",(0,r.jsx)(n.code,{children:"renderer/hooks"})," 找到 ",(0,r.jsx)(n.code,{children:"useReadDirAssetsTemplateHooks.ts"})," 文件，进行修改，不要忘记了，对于类型声明也需要对应修改"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// renderer/hooks/useReadDirAssetsTemplateHooks.ts\n\n// 找到这段代码\nif (files.length > 0) {\n  let templateList: TSTemplate.Item[] = [];\n  for (let idx = 0; idx < files.length; idx++) {\n    const base64URL = await fileAction.read(`${appPath}assets/template/${files[idx]}`, 'base64');\n    templateList.push({\n      templateName: files[idx],\n      // \uD83D\uDC47 添加索引\n      templateIndex: idx,\n      templateId: createUID(),\n      templateCover: `data:image/png;base64,${base64URL}`,\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// renderer/common/types/template.d.ts\n\ndeclare namespace TSTemplate {\n  export interface Item {\n    // \uD83D\uDC47 添加此类型说明\n    /**\n     * @description 模版下标\n     */\n    templateIndex: number;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["紧接着，前往 ",(0,r.jsx)(n.code,{children:"renderer/container/templateList/StaticResume"})," 组件，我们在这里需要做模版不存在或无法预览时的异常处理了。我们来修改一下代码，大家记得看注释"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import React from 'react';\nimport './index.less';\nimport { shell } from 'electron';\nimport * as TemplateList from '@src/container/templates';\nimport Footer from '../Footer';\nimport MyScrollBox from '@common/components/MyScrollBox';\nimport { useSelector } from 'react-redux';\nimport MyEmpty from '@common/components/MyEmpty';\nimport EmptyPng from '@assets/icon/empty.png';\nimport MyButton from '@common/components/MyButton';\n\n// \uD83D\uDC47 1. 合法且存在的简历模版，因为我们存在两个模版封面，但只有一个模版组件\nconst VALID_TEMPLATE = [0];\n\nfunction StaticResume() {\n  const HEADER_HEIGHT = 76; // 距离头部距离\n  const height = document.body.clientHeight;\n  const selectTemplate: TSTemplate.Item = useSelector((state: any) => state.templateModel.selectTemplate);\n\n  // \uD83D\uDC47 2. 下面判断该模版是否合法且存在组件模版\n  const isIncludeTemplate = VALID_TEMPLATE.includes(selectTemplate.templateIndex);\n  const isValidTemplate = selectTemplate.templateId && selectTemplate.templateIndex !== -1;\n\n  return (\n    <div styleName=\"container\">\n      <MyScrollBox maxHeight={height - HEADER_HEIGHT}>\n        {isValidTemplate && isIncludeTemplate && (\n          <>\n            {selectTemplate.templateIndex === 0 && <TemplateList.TemplateOne />}\n            <Footer />\n          </>\n        )}\n        {/* \uD83D\uDC47 3. 缺省页说明 */}\n        {isValidTemplate && !isIncludeTemplate && (\n          <LackDesc label=\"暂未开发此模版，欢迎点击下方按钮进行模版贡献\" />\n        )}\n        {!isValidTemplate && (\n          <LackDesc label=\"暂无模版数据，欢迎点击下方按钮进行模版贡献\" />\n        )}\n      </MyScrollBox>\n    </div>\n  );\n}\n\nexport default StaticResume;\n\nconst LackDesc = React.memo(({ label }: { label: string }) => {\n  return (\n    <div styleName=\"empty\">\n      <MyEmpty imgSrc={EmptyPng} label={label} />\n      <div styleName=\"footer\">\n        <MyButton\n          size=\"middle\"\n          className=\"use-btn\"\n          onClick={() => {\n            shell.openExternal('https://github.com/PDKSophia/visResumeMook/issues/4');\n          }}\n        >\n          贡献模版\n        </MyButton>\n      </div>\n    </div>\n  );\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["最终效果如图所示，\uD83D\uDC49 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/18a763e54be2b859147adcf7cc6e08147816aa8d",target:"_blank",rel:"noopener noreferrer",children:"点击查看功能一 commit 代码"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h2,{id:"功能二从模版列表跳转至简历制作",children:["功能二：从模版列表跳转至简历制作",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能二从模版列表跳转至简历制作",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"上边实现了预览模版功能，但也仅仅只是预览而已，接下来我们实现从预览模版到简历制作。"}),"\n",(0,r.jsx)(n.p,{children:"我们先来看一下，简历制作的入口有哪些？"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"从首页进入"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"从模版列表页面点击模版制作进入"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"会有不同的入口，并且会以不同的模版进行制作，那么我们在简历制作页面，就得知道：当前的入口来源、当前的模版信息"}),"\n",(0,r.jsxs)(n.h3,{id:"21-路由改写",children:["2.1 路由改写",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-路由改写",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如何让简历制作页面获取到上述的两个关键信息呢？"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Redux 响应式"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"在跳转前，将所需要的信息存到 Redux 中，进入到最终页面时再将数据取出"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Router 路由式"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们可以将一些关键信息携带到路由中，进入到最终页面时解析路由，获取数据。"}),"\n",(0,r.jsxs)(n.p,{children:["经过对比，第一种方案不太推荐，它需要我们在 Redux 中维护一些数据，为此我们采用第二种方案解决。但写路由又是一门学问，比如说写成 ",(0,r.jsx)(n.code,{children:"/resume?id=1&idx=1"})," 还是写成 ",(0,r.jsx)(n.code,{children:"/resume/:id/:idx"})]}),"\n",(0,r.jsxs)(n.p,{children:["前者需要我们自行实现路由参数的拼接与解析，后者有现成的库使用，想必大家都写过这样的路由 ",(0,r.jsx)(n.code,{children:"/resume/:id/:idx"}),"，本质是通过 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/path-to-regexp",target:"_blank",rel:"noopener noreferrer",children:"path-to-regexp"})," 库实现，接下来我将在项目中引入该库，修改我们的路由。我们先来安装"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install path-to-regexp --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["前往 ",(0,r.jsx)(n.code,{children:"renderer/common/utils"})," 中修改 ",(0,r.jsx)(n.code,{children:"router.ts"})," 文件，我们新增一个方法，用于合并参数"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// renderer/common/utils/router.ts\n\nimport { compile } from 'path-to-regexp';\n\nexport function compilePath(route: string, params?: { [key: string]: any }) {\n  const toPath = compile(route, { encode: encodeURIComponent });\n  return toPath(params);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["接着我们将所有的路由都进行修改，在 ",(0,r.jsx)(n.code,{children:"renderer"})," 文件夹下全局查找所有通过 ",(0,r.jsx)(n.code,{children:"history.push(route)"})," 都改成 ",(0,r.jsx)(n.code,{children:"history.push(compilePath(route))"})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"所有的改写就不一一展示，大家可自行修改。"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"22-首页跳转处修改",children:["2.2 首页跳转处修改",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-首页跳转处修改",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["前往 ",(0,r.jsx)(n.code,{children:"app/renderer/common/constants"})," 修改路由参数定义"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// renderer/common/constants/router.ts\n\nconst ROUTER = {\n  root: '/',\n  // \uD83D\uDC47 这里我们改一下简历制作的路由，规则：/来源/模版ID/模版索引\n  resume: '/resume/:fromPath/:templateId/:templateIndex',\n  template: '/template',\n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["接着进入 ",(0,r.jsx)(n.code,{children:"renderer/container/root"})," 首页，找到入口文件 ",(0,r.jsx)(n.code,{children:"index.tsx"}),"，我们修改跳转逻辑代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const onRouterToLink = (router: TSRouter.Item) => {\n  if (isHttpOrHttpsUrl(router.url)) {\n    shell.openExternal(router.url);\n  } else {\n    if (router.key !== ROUTER_KEY.resume) {\n      history.push(compilePath(router.url));\n    } else {\n      // \uD83D\uDC47 跳转路由的修改\n      history.push(\n        compilePath(router.url, {\n          fromPath: ROUTER_KEY.root,\n          templateId: selectTemplate?.templateId,\n          templateIndex: selectTemplate?.templateIndex,\n        })\n      );\n    }\n  }\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h3,{id:"23-简历模版跳转处修改",children:["2.3 简历模版跳转处修改",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-简历模版跳转处修改",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["前往 ",(0,r.jsx)(n.code,{children:"renderer/container/templateList/Footer"})," 首页模块，找到入口文件 ",(0,r.jsx)(n.code,{children:"index.tsx"}),"，我们修改一下跳转逻辑代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// app/renderer/container/templateList/Footer/index.tsx\n\nimport React from 'react';\nimport './index.less';\nimport { useHistory } from 'react-router';\nimport { useSelector } from 'react-redux';\nimport { ROUTER_KEY } from '@common/constants/router';\nimport { compilePath } from '@common/utils/router';\nimport MyButton from '@common/components/MyButton';\nimport ROUTER from '@common/constants/router';\n\nfunction Footer() {\n  const history = useHistory();\n  const selectTemplate = useSelector((state: any) => state.templateModel.selectTemplate);\n\n  const onMadeResume = (router: TSRouter.Item) => {\n    // \uD83D\uDC47 跳转路由的修改\n    history.push(\n      compilePath(ROUTER.resume, {\n        fromPath: ROUTER_KEY.templateList,\n        templateId: selectTemplate?.templateId,\n        templateIndex: selectTemplate?.templateIndex,\n      })\n    );\n  };\n  return (\n    <div styleName=\"footer\">\n      <MyButton size=\"middle\" className=\"use-btn\" onClick={onMadeResume}>\n        以此模版前往制作简历\n      </MyButton>\n    </div>\n  );\n}\n\nexport default Footer;\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.h3,{id:"24-简历制作处的路由参数获取正确返回",children:["2.4 简历制作处的路由参数获取，正确返回",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-简历制作处的路由参数获取正确返回",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["由于我们的入口来源不同，所以在“返回”时，也需做对应的处理。我们可以通过 ",(0,r.jsx)(n.code,{children:"useParams"})," 这个 hooks，得到路由中的数据，根据数据的 ",(0,r.jsx)(n.code,{children:"fromPath"})," 不同，进行对应的处理。"]}),"\n",(0,r.jsxs)(n.p,{children:["前往 ",(0,r.jsx)(n.code,{children:"/renderer/container/resume/components/ResumeActions"})," ，找到入口文件 ",(0,r.jsx)(n.code,{children:"index.tsx"}),"，进行修改，下面是伪代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// renderer/container/resume/components/ResumeActions/index.tsx\n\nimport { useHistory, useParams } from 'react-router';\nimport { compilePath } from '@common/utils/router';\nimport ROUTER, { ROUTER_KEY } from '@common/constants/router';\n\nfunction ResumeAction() {\n  const history = useHistory();\n  // \uD83D\uDC47 定义参数类型\n  const routerParams = useParams<{\n    fromPath: string;\n    templateId: string;\n    templateIndex: string;\n  }>();\n\n  // 返回首页\n  const onBack = () => {\n    if (routerParams?.fromPath === ROUTER_KEY.root) {\n      history.push(compilePath(ROUTER.root));\n    } else if (routerParams?.fromPath === ROUTER_KEY.templateList) {\n      history.push(compilePath(ROUTER.templateList));\n    } else {\n      console.log('here');\n    }\n  };\n\n  return (\n    <div styleName=\"actions\">\n      <div styleName=\"back\" onClick={onBack}>返回</div>\n    </div>\n  );\n}\n\nexport default ResumeAction;\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"25-简历制作处的路由参数获取正确显示模版",children:["2.5 简历制作处的路由参数获取，正确显示模版",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-简历制作处的路由参数获取正确显示模版",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["如上所示，我们从 ",(0,r.jsx)(n.code,{children:"useParams"})," 这个 hooks，得到路由中的数据，根据模版 ID 和模版索引，进而加载展示正确的模版，如果你认真看了上边的功能一，想必此问题对你来说也并非难事，这里就不进行多余讲解。"]}),"\n",(0,r.jsx)(n.p,{children:"也算是一个小测试，小伙伴们可自行实现。"}),"\n",(0,r.jsxs)(n.p,{children:["\uD83D\uDC49 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/3ef20a15f621bda325236c13c739cceb34bbce94",target:"_blank",rel:"noopener noreferrer",children:"点击查看功能二 commit 代码"})]}),"\n",(0,r.jsxs)(n.h2,{id:"功能三实现-keepalive-效果",children:["功能三：实现 KeepAlive 效果",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能三实现-keepalive-效果",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"想必小伙伴们现在会有一个很蛋疼的事情，那就是没有页面缓存的效果，记得以前写 Vue 时，页面缓存就很方便，只需要这么写，就能实现效果"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'// 这里以 vue2 为例\n\n\x3c!-- 失活的组件将会被缓存！--\x3e\n<keep-alive>\n  <component v-bind:is="currentTabComponent"></component>\n</keep-alive>\n'})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"页面缓存的原理，我猜想应该是通过 display:none 的方式实现，感兴趣的可以私下去了解，或者评论区发表你的观点"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["那我们在 React 中，如何实现页面缓存呢？有一个 ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/react-router-cache-route",target:"_blank",rel:"noopener noreferrer",children:"react-router-cache-route"})," 库，可以替我们实现，使用也极其简单，让我们先来安装一下"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm install react-router-cache-route --save-dev\n"})}),"\n",(0,r.jsxs)(n.p,{children:["前往 ",(0,r.jsx)(n.code,{children:"/renderer/router.tsx"})," 修改一下路由组件"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// renderer/router.tsx\n\nimport React, { useEffect } from 'react';\n// \uD83D\uDC47 引入，实现页面缓存\nimport CacheRoute, { CacheSwitch } from 'react-router-cache-route';\nimport { HashRouter, Redirect } from 'react-router-dom';\nimport Root from '@src/container/root';\nimport Resume from '@src/container/resume';\nimport TemplateList from '@src/container/templateList';\nimport ROUTER from '@common/constants/router';\nimport useThemeActionHooks from './hooks/useThemeActionHooks';\nimport useReadDirAssetsTemplateHooks from './hooks/useReadDirAssetsTemplateHooks';\n\nfunction Router() {\n  const readDirAssetsTemplateHooks = useReadDirAssetsTemplateHooks();\n  const initThemeConfig = useThemeActionHooks.useInitThemeConfig();\n  useEffect(() => {\n    initThemeConfig();\n    readDirAssetsTemplateHooks();\n  }, []);\n\n  return (\n    <HashRouter>\n      <CacheSwitch>\n        <CacheRoute path={ROUTER.root} exact component={Root} />\n        <CacheRoute path={ROUTER.resume} exact component={Resume} />\n        <CacheRoute path={ROUTER.templateList} exact component={TemplateList} />\n        <Redirect from={ROUTER.root} exact to={ROUTER.root} />\n      </CacheSwitch>\n    </HashRouter>\n  );\n}\nexport default Router;\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样就实现了页面缓存，你可以做个尝试，任意进入一个路由，在该路由下刷新页面，看看是否会停留在此页面下（之前是会回到首页）"}),"\n",(0,r.jsxs)(n.p,{children:["\uD83D\uDC49 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/43af928da7e467874705419c52202621f41602c0",target:"_blank",rel:"noopener noreferrer",children:"点击查看功能三 commit 代码"})]}),"\n",(0,r.jsxs)(n.h3,{id:"功能四简历制作内容高度有误",children:["功能四：简历制作内容高度有误",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#功能四简历制作内容高度有误",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"当我们实现了上述的三个功能之后，就会引出此问题，如何复现呢？"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"复现步骤：首页 -> 进入简历制作页 -> 在简历制作页下刷新 -> 高度错误"}),"，下面是一张异常图片"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["不对劲，为什么简历的显示高度会出现异常，这与我们期望不符。我们来排查一下，进入到 ",(0,r.jsx)(n.code,{children:"renderer/container/resume/ResumeContent"})," 中，打印一下我们的高度"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// renderer/container/resume/ResumeContent/index.tsx\n\nfunction ResumeContent() {\n  const HEADER_ACTION_HEIGHT = 92;\n  const height = document.body.clientHeight;\n\n  // \uD83D\uDC47 打印一下，看看高度是多少\n  console.log('body: ', document.body);\n  console.log('clientHeight: ', document.body.clientHeight);\n\n  return (\n    <MyScrollBox maxHeight={height - HEADER_ACTION_HEIGHT}>\n      {/* 组件内容 */}\n    </MyScrollBox>\n  );\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["从上边代码可以看到，我们简历的显示高度是与 ",(0,r.jsx)(n.code,{children:"document.body.clientHeight"})," 密切相关，想要搞清楚为什么高度错误，就得打印 ",(0,r.jsx)(n.code,{children:"clientHeight"}),"，看看是否与我们的所期望的一致"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"clientHeight"})," 居然是 0 ！我们再看看，打印的 body 元素的高度是多少"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"为什么会这样呢？小伙伴们可以思考一下～"}),"\n",(0,r.jsx)(n.p,{children:"那如何解决呢？最简单粗暴的方式，把 height 放在 state 中"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"function ResumeContent() {\n  const HEADER_ACTION_HEIGHT = 92;\n  const [height, setHeight] = useState(0);\n\n  useEffect(() => {\n    if (document.body && document.body.clientHeight > 0)\n      setHeight(document.body.clientHeight);\n  }, [document.body]);\n\n  return (\n    <MyScrollBox maxHeight={height - HEADER_ACTION_HEIGHT}>\n      {/* 组件内容 */}\n    </MyScrollBox>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"此问题最重要的不在于如何解决，最重要的是知道为什么会出现这种情况。这里留个小提问，小伙伴们动动小奶袋瓜，想一想～然后在评论区留言。"}),"\n",(0,r.jsxs)(n.p,{children:["\uD83D\uDC49 ",(0,r.jsx)(n.a,{href:"https://github.com/PDKSophia/visResumeMook/commit/dd4aab6c6e0cdfe436eb08d7e7fadab04f282bbc",target:"_blank",rel:"noopener noreferrer",children:"点击查看功能四 commit 代码"})]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"本章主要是对细节方面的做了些小小优化，虽说使用的都是第三方库，但我希望小伙伴们能不给自己设限，不要停留在使用状态，而是能去了解该库背后的实现，不要求精通读完源码，但能对背后的实现原理略知一二，我想，这一定比此章节更重要。如果有疑问，可以在评论区指出。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}let u=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Electron%20%2B%20React%20%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8E%86%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%2F18.%E4%B8%9A%E5%8A%A1%E7%AF%87-%E6%80%9D%E8%80%83%E5%B9%B6%E8%A1%A5%E5%85%A8%E9%81%97%E6%BC%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%86%E8%8A%82%EF%BC%8C%E6%95%B4%E4%BD%93%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%AE%A9%E5%BA%94%E7%94%A8%E6%9B%B4%E5%81%A5%E5%A3%AE.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"功能一：空模版/模版不可预览异常处理",id:"功能一空模版模版不可预览异常处理",depth:2},{text:"1.1 点击模版，存入 Redux",id:"11-点击模版存入-redux",depth:3},{text:"1.2 添加空缺省组件",id:"12-添加空缺省组件",depth:3},{text:"1.3 遇到问题",id:"13-遇到问题",depth:3},{text:"1.4 暂时缓缓，继续开发",id:"14-暂时缓缓继续开发",depth:3},{text:"功能二：从模版列表跳转至简历制作",id:"功能二从模版列表跳转至简历制作",depth:2},{text:"2.1 路由改写",id:"21-路由改写",depth:3},{text:"2.2 首页跳转处修改",id:"22-首页跳转处修改",depth:3},{text:"2.3 简历模版跳转处修改",id:"23-简历模版跳转处修改",depth:3},{text:"2.4 简历制作处的路由参数获取，正确返回",id:"24-简历制作处的路由参数获取正确返回",depth:3},{text:"2.5 简历制作处的路由参数获取，正确显示模版",id:"25-简历制作处的路由参数获取正确显示模版",depth:3},{text:"功能三：实现 KeepAlive 效果",id:"功能三实现-keepalive-效果",depth:2},{text:"功能四：简历制作内容高度有误",id:"功能四简历制作内容高度有误",depth:3},{text:"总结",id:"总结",depth:2}],title:"18.业务篇-思考并补全遗漏的功能细节，整体优化代码，让应用更健壮",headingTitle:"18.业务篇-思考并补全遗漏的功能细节，整体优化代码，让应用更健壮",frontmatter:{}}}}]);