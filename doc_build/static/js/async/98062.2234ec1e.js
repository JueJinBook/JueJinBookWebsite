"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["98062"],{899579:function(e,n,s){s.r(n),s.d(n,{default:()=>j});var a=s(552676),t=s(740453);let i=s.p+"static/image/67b596330bf9efd6af72df5a514689a6.1f1e114c.webp",d=s.p+"static/image/3cf867501e76966506bbde2f5b3a1835.5a65dfad.webp",r=s.p+"static/image/c1be7448795eddea1c6e5b388c753263.0e45127d.webp",c=s.p+"static/image/2f4183f7165423f3ee10a41223c9dc79.04b865c1.webp",l=s.p+"static/image/97cf9ed6c29b970f9e19f673095b83aa.94b68ac5.webp",o=s.p+"static/image/4cd55f6b22d5e134ef455a0773e0abca.ddb1a93f.webp",p=s.p+"static/image/a48ef3ca10c1ad1983071fdee15bfc85.cb739cdc.webp",h=s.p+"static/image/f885aa5c9a6e2ab16aa3c9291e669152.b6775cb3.webp";function m(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",code:"code",h4:"h4",ul:"ul",li:"li",pre:"pre",strong:"strong",blockquote:"blockquote"},(0,t.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"18前端实战账单详情页",children:["18.前端实战：账单详情页",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18前端实战账单详情页",children:"#"})]}),"\n",(0,a.jsxs)(n.h2,{id:"前言",children:["前言",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"账单模块还剩最后一个小节，账单详情。账单详情页要做的事情有两个，一个是编辑当前账单操作，另一个是删除当前账单操作，我们先来观察完成后页面结构，如下所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:h,alt:""})}),"\n",(0,a.jsxs)(n.p,{children:["这里是第一次涉及内页，所以我们需要制作一个公用的头部 ",(0,a.jsx)(n.code,{children:"Header"}),"，支持传参接收 ",(0,a.jsx)(n.code,{children:"title"})," 信息。我们在上一章节提取的「添加账单弹窗组件」，在这里派上了用场，新增和编辑是一家，唯一的差别就是编辑的时候，需要传入当前账单的 ",(0,a.jsx)(n.code,{children:"id"})," 给「添加账单组件」，组件内通过账单详情接口，获取账单详情，并将获取的参数用于各个字段初始化值，这就实现了组件的复用。"]}),"\n",(0,a.jsxs)(n.h4,{id:"知识点",children:["知识点",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点",children:"#"})]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"封装公用头部组件"}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"复用添加账单弹窗组件"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"正文开始",children:["正文开始",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正文开始",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"公用头部",children:["公用头部",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#公用头部",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["在 ",(0,a.jsx)(n.code,{children:"components"})," 目录下新建 ",(0,a.jsx)(n.code,{children:"Header"})," 目录，老规矩，添加两个文件 ",(0,a.jsx)(n.code,{children:"index.jsx"})," 和 ",(0,a.jsx)(n.code,{children:"style.module.less"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:["为 ",(0,a.jsx)(n.code,{children:"Header/index.jsx"})," 添加代码如下："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import React from 'react';\nimport PropTypes from 'prop-types';\nimport { useNavigate } from 'react-router-dom'\nimport { NavBar, Icon } from 'zarm';\n\nimport s from './style.module.less'\n\nconst Header = ({ title = '' }) => {\n  const navigateTo = useNavigate()\n  return <div className={s.headerWarp}>\n    <div className={s.block}>\n      <NavBar\n        className={s.header}\n        left={<Icon type=\"arrow-left\" theme=\"primary\" onClick={() => navigateTo(-1)} />}\n        title={title}\n      />\n    </div>\n  </div>\n};\n\nHeader.propTypes = {\n  title: PropTypes.string, // 标题\n};\n\nexport default Header;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["我们采用 ",(0,a.jsx)(n.code,{children:"Zarm"})," 组件库为我们提供的 ",(0,a.jsx)(n.code,{children:"NavBar"})," 组件，实现头部的组件布局。为左边的返回箭头添加一个事件，",(0,a.jsx)(n.code,{children:"navigateTo(-1)"})," 的作用是路由返回事件，它不会触发浏览器的刷新，而是改变浏览器的地址栏，让组件匹配地址栏对应的地址组件。"]}),"\n",(0,a.jsxs)(n.p,{children:["还有一点要提醒大家，写公用组件一定要写 ",(0,a.jsx)(n.code,{children:"PropTypes"}),"，这是让其他使用该组件的同事知道，你这个组件接受的参数有哪些，以及每个参数的作用是什么，都要注释清楚，这才是一个好的公用组件。我见过很多同事写公用组件都不写 ",(0,a.jsx)(n.code,{children:"PropTypes"}),"，这让使用者非常头大。"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"CSS 样式代码"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-css",children:".header-warp {\n  border-bottom: 1px solid #e9e9e9;\n  .block {\n    width: 100%;\n    height: 46px;\n    :global {\n      .za-nav-bar__title {\n        font-size: 14px;\n        color: rgba(0, 0, 0, 0.9);\n      }\n      .za-icon--arrow-left {\n        font-size: 20px;\n      }\n    }\n  }\n  .header {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    .more {\n      font-size: 20px;\n    }\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["完成上述代码之后，我们需要在 ",(0,a.jsx)(n.code,{children:"container/Detail/index.jsx"})," 下引入这个公用头部，代码如下："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import React from 'react';\nimport Header from '@/components/Header';\n\nimport s from './style.module.less';\n\nconst Detail = () => {\n  return <div className={s.detail}>\n    <Header title='账单详情' />\n  </div>\n}\n\nexport default Detail\n"})}),"\n",(0,a.jsx)(n.p,{children:"效果如下所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:p,alt:""})}),"\n",(0,a.jsxs)(n.h4,{id:"账单明细",children:["账单明细",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#账单明细",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"接下来，我们通过列表页传入的浏览器查询字符串，通俗的将就是浏览器地址栏上的参数，来获取该笔账单的详情，如下所示："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"// container/Detail/index.jsx\nimport React, { useEffect, useState } from 'react';\nimport { useLocation } from 'react-router-dom';\nimport qs from 'query-string';\nimport Header from '@/components/Header';\nimport { get } from '@/utils';\n\nimport s from './style.module.less';\n\nconst Detail = () => {\n  const location = useLocation(); // 获取 locaton 实例，我们可以通过打印查看内部都有些什么内容。\n  const { id } = qs.parse(location.search);\n\n  const [detail, setDetail] = useState({});\n\n  console.log('location', location);\n\n  useEffect(() => {\n    getDetail()\n  }, []);\n\n  const getDetail = async () => {\n    const { data } = await get(`/api/bill/detail?id=${id}`);\n    setDetail(data);\n  }\n  return <div className={s.detail}>\n    <Header title='账单详情' />\n  </div>\n}\n\nexport default Detail\n"})}),"\n",(0,a.jsxs)(n.p,{children:["我们先来看看，浏览器控制台打印出的 ",(0,a.jsx)(n.code,{children:"location"})," 如下所示："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:o,alt:""})}),"\n",(0,a.jsxs)(n.p,{children:["可以看到，我们想要的参数在 ",(0,a.jsx)(n.code,{children:"search"})," 属性中，我想把 ",(0,a.jsx)(n.code,{children:"?id=917"})," 转换成 ",(0,a.jsx)(n.code,{children:"json"})," 键值对的形式，如："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:"{\n  id: 917\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["所以我通过 ",(0,a.jsx)(n.code,{children:"npm install query-string"})," 引入了查询字符串解析的一个插件，通过如下方式："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"qs.parse(location.search)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["可以将浏览器查询参数变成一个对象形式，所以我们在代码中可以通过 ",(0,a.jsx)(n.code,{children:"const"})," 的解构，将 ",(0,a.jsx)(n.code,{children:"id"})," 取出。最后通过 ",(0,a.jsx)(n.code,{children:"get"})," 方法请求详情接口："]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:l,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"接下来，我们给账单明细部分布局，并且将数据接入，代码如下所示："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState } from 'react';\nimport { useLocation } from 'react-router-dom';\nimport qs from 'query-string';\nimport dayjs from 'dayjs';\nimport cx from 'classnames';\nimport Header from '@/components/Header';\nimport CustomIcon from '@/components/CustomIcon';\nimport { get, typeMap } from '@/utils';\n\n\nimport s from './style.module.less';\n\nconst Detail = () => {\n  const location = useLocation(); // 路由 location 实例\n  const { id } = qs.parse(location.search); // 查询字符串反序列化\n\n  const [detail, setDetail] = useState({}); // 订单详情数据\n\n  useEffect(() => {\n    getDetail()\n  }, []);\n\n  const getDetail = async () => {\n    const { data } = await get(`/api/bill/detail?id=${id}`);\n    setDetail(data);\n  }\n  return <div className={s.detail}>\n    <Header title='账单详情' />\n    <div className={s.card}>\n      <div className={s.type}>\n        {/* 通过 pay_type 属性，判断是收入或指出，给出不同的颜色*/}\n        <span className={cx({ [s.expense]: detail.pay_type == 1, [s.income]: detail.pay_type == 2 })}>\n          {/* typeMap 是我们事先约定好的 icon 列表 */}\n          <CustomIcon className={s.iconfont} type={detail.type_id ? typeMap[detail.type_id].icon : 1} />\n        </span>\n        <span>{ detail.type_name || '' }</span>\n      </div>\n      {\n        detail.pay_type == 1\n          ? <div className={cx(s.amount, s.expense)}>-{ detail.amount }</div>\n          : <div className={cx(s.amount, s.incom)}>+{ detail.amount }</div>\n      }\n      <div className={s.info}>\n        <div className={s.time}>\n          <span>记录时间</span>\n          <span>{dayjs(Number(detail.date)).format('YYYY-MM-DD HH:mm')}</span>\n        </div>\n        <div className={s.remark}>\n          <span>备注</span>\n          <span>{ detail.remark || '-' }</span>\n        </div>\n      </div>\n      <div className={s.operation}>\n        <span><CustomIcon type='shanchu' />删除</span>\n        <span><CustomIcon type='tianjia' />编辑</span>\n      </div>\n    </div>\n  </div>\n}\n\nexport default Detail\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"文末已为同学们提供下本章节 demo 代码，样式部分不再详细说明。"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["布局部分我都已经在代码中给了注释，还有不明白的同学可以在群里提问，再次强调一点，",(0,a.jsx)(n.code,{children:"flex"})," 布局请务必要掌握熟练，在日后的开发过程中，无论是小册还是公司的项目，都会大量的运用到它。甚至 ",(0,a.jsx)(n.code,{children:"Flutter"})," 的布局也借鉴了 ",(0,a.jsx)(n.code,{children:"flex"})," 的原理。"]}),"\n",(0,a.jsx)(n.p,{children:"浏览器展示效果如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(n.p,{children:"我们还需为底部的两个按钮添加事件。首先，为删除按钮添加删除事件："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import { useLocation, useNavigate } from 'react-router-dom';\nimport { get, post, typeMap } from '@/utils';\nimport { Modal, Toast } from 'zarm';\n... \n\nconst navigateTo = useNavigate();\n\n// 删除方法\nconst deleteDetail = () => {\n  Modal.confirm({\n    title: '删除',\n    content: '确认删除账单？',\n    onOk: async () => {\n      const { data } = await post('/api/bill/delete', { id })\n      Toast.show('删除成功')\n      navigateTo(-1)\n    },\n  });\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["这里我们利用 ",(0,a.jsx)(n.code,{children:"Zarm"})," 组件提供的 ",(0,a.jsx)(n.code,{children:"Modal"})," 组件，该组件提供了调用方法的形式唤起弹窗，我们利用这个属性\n为「删除」加一个二次确认的形式，避免误触按钮。"]}),"\n",(0,a.jsx)(n.p,{children:"效果如下所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:r,alt:""})}),"\n",(0,a.jsxs)(n.p,{children:["最麻烦的编辑事件处理，我们先来明确一下思路。在点击「编辑」按钮之后，我们会唤起之前写好的「添加账单天窗」，然后将账单 ",(0,a.jsx)(n.code,{children:"detail"})," 参数通过 ",(0,a.jsx)(n.code,{children:"props"})," 传递给弹窗组件，组件在接收到 ",(0,a.jsx)(n.code,{children:"detail"})," 时，将信息初始化给弹窗给的相应参数。"]}),"\n",(0,a.jsxs)(n.p,{children:["我们来看代码的实现，首先在 ",(0,a.jsx)(n.code,{children:"Detail/index.jsx"})," 内添加代码："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState, useRef } from 'react';\nimport PopupAddBill from '@/components/PopupAddBill';\n...\n\nconst editRef = useRef();\n...\n<div className={s.operation}>\n  <span onClick={deleteDetail}><CustomIcon type='shanchu' />删除</span>\n  <span onClick={() => editRef.current && editRef.current.show()}><CustomIcon type='tianjia' />编辑</span>\n</div>\n...\n<PopupAddBill ref={editRef} detail={detail} onReload={getDetail} />\n"})}),"\n",(0,a.jsx)(n.p,{children:"尝试点击编辑按钮："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:""})}),"\n",(0,a.jsxs)(n.p,{children:["紧接着，我们修改 ",(0,a.jsx)(n.code,{children:"PopupAddBill"})," 组件，如下所示："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const PopupAddBill = forwardRef(({ detail = {}, onReload }, ref) => {\n  ...\n  const id = detail && detail.id // 外部传进来的账单详情 id\n\n  useEffect(() => {\n    if (detail.id) {\n      setPayType(detail.pay_type == 1 ? 'expense' : 'income')\n      setCurrentType({\n        id: detail.type_id,\n        name: detail.type_name\n      })\n      setRemark(detail.remark)\n      setAmount(detail.amount)\n      setDate(dayjs(Number(detail.date)).$d)\n    }\n  }, [detail])\n\n  ... \n\n  useEffect(async () => {\n    const { data: { list } } = await get('/api/type/list');\n    const _expense = list.filter(i => i.type == 1); // 支出类型\n    const _income = list.filter(i => i.type == 2); // 收入类型\n    setExpense(_expense);\n    setIncome(_income);\n      // 没有 id 的情况下，说明是新建账单。\n    if (!id) {\n      setCurrentType(_expense[0]);\n    };\n  }, []);\n\n  ... \n  \n  // 添加账单\n  const addBill = async () => {\n    if (!amount) {\n      Toast.show('请输入具体金额')\n      return\n    }\n    const params = {\n      amount: Number(amount).toFixed(2),\n      type_id: currentType.id,\n      type_name: currentType.name,\n      date: dayjs(date).unix() * 1000,\n      pay_type: payType == 'expense' ? 1 : 2,\n      remark: remark || ''\n    }\n    if (id) {\n      params.id = id;\n      // 如果有 id 需要调用详情更新接口\n      const result = await post('/api/bill/update', params);\n      Toast.show('修改成功');\n    } else {\n      const result = await post('/api/bill/add', params);\n      setAmount('');\n      setPayType('expense');\n      setCurrentType(expense[0]);\n      setDate(new Date());\n      setRemark('');\n      Toast.show('添加成功');\n    }\n    setShow(false);\n    if (onReload) onReload();\n  }\n})\n"})}),"\n",(0,a.jsxs)(n.p,{children:["首先，通过 ",(0,a.jsx)(n.code,{children:"setXXX"})," 将 ",(0,a.jsx)(n.code,{children:"detail"})," 的数据依次设置初始值；其次，账单种类需要判断是否是编辑或是新建；最后，修改添加账单按钮，如果是「编辑」操作，给 ",(0,a.jsx)(n.code,{children:"params"})," 参数添加一个 ",(0,a.jsx)(n.code,{children:"id"}),"，并且调用的接口变成 ",(0,a.jsx)(n.code,{children:"/api/bill/update"}),"。"]}),"\n",(0,a.jsx)(n.p,{children:"完成上述操作之后，我们查看浏览器操作情况如下所示："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsxs)(n.h2,{id:"总结",children:["总结",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"本小节我们学习了如何封装内页的头部组件，以及如何将之前的「新增」复用给「编辑」操作，可以以这个为一个思考点，用发散的思维去复制这样的模式，是否其他的新增和编辑操作，也可以这么实现。"}),"\n",(0,a.jsxs)(n.h4,{id:"本章节源码",children:["本章节源码",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章节源码",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://s.yezgea02.com/1624515959785/react-vite-h5.zip",target:"_blank",rel:"noopener noreferrer",children:"点击下载"})})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(m,{...e})}):m(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F18.%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E8%B4%A6%E5%8D%95%E8%AF%A6%E6%83%85%E9%A1%B5.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"知识点",id:"知识点",depth:4},{text:"正文开始",id:"正文开始",depth:2},{text:"公用头部",id:"公用头部",depth:4},{text:"账单明细",id:"账单明细",depth:4},{text:"总结",id:"总结",depth:2},{text:"本章节源码",id:"本章节源码",depth:4}],title:"18.前端实战：账单详情页",headingTitle:"18.前端实战：账单详情页",frontmatter:{}}}}]);