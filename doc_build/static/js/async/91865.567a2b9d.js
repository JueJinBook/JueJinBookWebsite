"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["91865"],{584930:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var s=r(552676),c=r(740453);let d=r.p+"static/image/6a2a44d70a864760dd7e49ede602f9ce.0a3c85b1.webp",i=r.p+"static/image/6327de042da438045f6444984ebcd14c.6f48e336.webp",a=r.p+"static/image/e59b30160da2112275aaff428fcf98a0.6dfe4ae4.webp",t=r.p+"static/image/f31c684e5bf700bbfea16d35d41140ee.d0af1855.webp",l=r.p+"static/image/2795b66d0ecb8d982982a05f70859603.9223d6c4.webp",o=r.p+"static/image/10fbcda11a41d998b971d81e9afe46ff.e65d8bcb.webp",h=r.p+"static/image/fd987e8b341025fa951328ba3cc11987.1d245c84.webp";function p(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h4:"h4",ul:"ul",li:"li",pre:"pre",img:"img",blockquote:"blockquote"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"7后端实战后端实战用户信息相关接口实现修改个签修改密码上传头像",children:["7.后端实战：后端实战：用户信息相关接口实现（修改个签、修改密码、上传头像）",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7后端实战后端实战用户信息相关接口实现修改个签修改密码上传头像",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上一章节带大家实现了登录注册接口，鉴权的相关工作基本完成。本章节带大家实现用户信息的相关接口，如获取用户信息、修改个性签名、重置用户密码、上传用户头像。"}),"\n",(0,s.jsxs)(n.p,{children:["文件资源的上传和获取，是本章节的主要目的，无论是什么项目，服务端都需要处理文件资源，如 ",(0,s.jsx)(n.code,{children:"Excel"}),"、",(0,s.jsx)(n.code,{children:"Word"}),"、音频、视频、图片、",(0,s.jsx)(n.code,{children:"pdf"})," 等。我们以最常见的图片资源为例，通过这个例子的分析和学习，同学们可以拓展思维，将其应用到其他的文件资源形式上。"]}),"\n",(0,s.jsxs)(n.h4,{id:"知识点",children:["知识点",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"数据库的资源获取"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["数据库的 ",(0,s.jsx)(n.code,{children:"update"})," 更新"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Egg"})," 文件资源处理"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"获取用户信息",children:["获取用户信息",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#获取用户信息",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["话不多说，我们直接进入正题。首先我们打开 ",(0,s.jsx)(n.code,{children:"/app/controller/user.js"}),"，添加 ",(0,s.jsx)(n.code,{children:"getUserInfo"})," 方法，代码如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 获取用户信息\nasync getUserInfo() {\n  const { ctx, app } = this;\n  const token = ctx.request.header.authorization;\n  // 通过 app.jwt.verify 方法，解析出 token 内的用户信息\n  const decode = await app.jwt.verify(token, app.config.jwt.secret);\n  // 通过 getUserByName 方法，以用户名 decode.username 为参数，从数据库获取到该用户名下的相关信息\n  const userInfo = await ctx.service.user.getUserByName(decode.username)\n  // userInfo 中应该有密码信息，所以我们指定下面四项返回给客户端\n  ctx.body = {\n    code: 200,\n    msg: '请求成功',\n    data: {\n      id: userInfo.id,\n      username: userInfo.username,\n      signature: userInfo.signature || '',\n      avatar: userInfo.avatar || defaultAvatar\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"代码中已经添加详细的注释信息，我就不再赘述了。"}),"\n",(0,s.jsx)(n.p,{children:"接着我们将接口抛出，并且添加鉴权中间件，如下所示："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"'use strict';\n\n/**\n * @param {Egg.Application} app - egg application\n */\nmodule.exports = app => {\n  const { router, controller, middleware } = app;\n  const _jwt = middleware.jwtErr(app.config.jwt.secret); // 传入加密字符串\n  router.post('/api/user/register', controller.user.register);\n  router.post('/api/user/login', controller.user.login);\n  router.get('/api/user/get_userinfo', _jwt, controller.user.getUserInfo); // 获取用户信息\n  router.get('/api/user/test', _jwt, controller.user.test);\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们直接通过 ",(0,s.jsx)(n.code,{children:"Postman"})," 验证结构是否可行，如下所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注意，需要给 ",(0,s.jsx)(n.code,{children:"Headers"})," 添加 ",(0,s.jsx)(n.code,{children:"authorization"})," 属性，值为之前登录接口返回的 ",(0,s.jsx)(n.code,{children:"token"})," 信息。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"修改个性签名",children:["修改个性签名",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#修改个性签名",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["为了兼容后续的修改用户头像，我们将接口名称定义的宽一些，我们在 ",(0,s.jsx)(n.code,{children:"/controller/user.js"})," 下，新建 ",(0,s.jsx)(n.code,{children:"editUserInfo"})," 方法，添加如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 修改用户信息\nasync editUserInfo () {\n  const { ctx, app } = this;\n  // 通过 post 请求，在请求体中获取签名字段 signature\n  const { signature = '' } = ctx.request.body\n\n  try {\n    let user_id\n    const token = ctx.request.header.authorization;\n    // 解密 token 中的用户名称\n    const decode = await app.jwt.verify(token, app.config.jwt.secret);\n    if (!decode) return\n    user_id = decode.id\n    // 通过 username 查找 userInfo 完整信息\n    const userInfo = await ctx.service.user.getUserByName(decode.username)\n    // 通过 service 方法 editUserInfo 修改 signature 信息。\n    const result = await ctx.service.user.editUserInfo({\n      ...userInfo,\n      signature\n    });\n\n    ctx.body = {\n      code: 200,\n      msg: '请求成功',\n      data: {\n        id: user_id,\n        signature,\n        username: userInfo.username\n      }\n    }\n  } catch (error) {\n    \n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此时我们还需要打开 ",(0,s.jsx)(n.code,{children:"/service/user.js"}),"，新建一个 ",(0,s.jsx)(n.code,{children:"editUserInfo"})," 用于修改数据库中的用户信息，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 修改用户信息\nasync editUserInfo(params) {\n  const { ctx, app } = this;\n  try {\n    // 通过 app.mysql.update 方法，指定 user 表，\n    let result = await app.mysql.update('user', {\n        ...params // 要修改的参数体，直接通过 ... 扩展操作符展开\n    }, {\n        id: params.id // 筛选出 id 等于 params.id 的用户\n    });\n    return result;\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此时，我们在 ",(0,s.jsx)(n.code,{children:"router.js"})," 脚本中，将修改接口抛出："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"router.post('/api/user/edit_userinfo', _jwt, controller.user.editUserInfo); // 修改用户个性签名\n"})}),"\n",(0,s.jsxs)(n.p,{children:["打开 ",(0,s.jsx)(n.code,{children:"Postman"})," 验证接口是否正确："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"数据库也相应的修改成功："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"修改用户头像",children:["修改用户头像",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#修改用户头像",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"说到修改用户头像，正常情况下， 我们在前端是这样操作的。首先，点击用户头像；其次，弹出弹窗或进入手机相册，选择一张自己喜欢的头像，然后上传头像，最后将自己的头像替换成修改后的头像。"}),"\n",(0,s.jsxs)(n.p,{children:["上述流程涉及到一个步骤，那就是「上传图片」。所以在编写修改头像信息接口之前，我们需要先实现一个「上传图片」的接口。上传图片的作用是比较宽泛的，不光是头像需要上传图片，其他很多操作也都需要用到，如朋友圈、商品图片等等。所以我们在 ",(0,s.jsx)(n.code,{children:"controller"})," 文件夹下新建一个脚本，名为 ",(0,s.jsx)(n.code,{children:"upload.js"}),"，如下："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"接下来，先分析一波图片上传到服务器的逻辑。"}),"\n",(0,s.jsx)(n.p,{children:"1、首先我们需要在前端调用上传接口，并将图片参数带上，具体怎么带，后面代码部分会讲解。"}),"\n",(0,s.jsxs)(n.p,{children:["2、在服务端接收前端传进来的图片信息，信息中含有图片路径信息，我们在服务端通过 ",(0,s.jsx)(n.code,{children:"fs.readFileSync"})," 方法，来读取图片内容，并存放在变量中。"]}),"\n",(0,s.jsxs)(n.p,{children:["3、找个存放图片的公共位置，一般情况下，都会存放至 ",(0,s.jsx)(n.code,{children:"app/public/upload"}),"，上传的资源都存在此处。"]}),"\n",(0,s.jsxs)(n.p,{children:["4、通过 ",(0,s.jsx)(n.code,{children:"fs.writeFileSync"})," 方法，将图片内容写入第 3 步新建的文件夹中。"]}),"\n",(0,s.jsxs)(n.p,{children:["5、最后返回图片地址，基本上图片地址的结构是 ",(0,s.jsx)(n.code,{children:"host + IP + 图片名称 + 后缀"}),"，后续代码中会为大家详细讲解返回的路径。"]}),"\n",(0,s.jsxs)(n.p,{children:["目前我们没有前端项目可以上传图片，所以这里我们先用",(0,s.jsx)(n.code,{children:"HTML"})," 简单写一个上传页面，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>图片上传</title>\n</head>\n<body>\n    <input type=\"file\" id='upload' />\n    <script>\n      // 获取 input 标签的 dom\n      var input = document.getElementById('upload')\n      // 监听它的变化\n      input.addEventListener('change', function(e) {\n        // 获取到上传的 file 对象\n        var file = input.files[0]\n        // 声明 FormData 实例 formData\n        let formData = new FormData()\n        // 添加实例属性 file\n        formData.append('file', file)\n        console.log('formData', formData)\n        // 调用服务端上传接口。\n        fetch('http://localhost:7001/api/upload', {\n          method: 'POST',\n          body: formData\n        }).then(res => {\n          if(res.ok) {\n            console.log('success')\n            return res.json();\n          } else {\n            console.log('error')\n          }\n        }).then(res => {\n          console.log('res is', res);\n        })\n      })\n    <\/script>\n</body>\n</html>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述 ",(0,s.jsx)(n.code,{children:"HTML"})," 的功能很简单，就是将上传的资源经过 ",(0,s.jsx)(n.code,{children:"FormData"})," 实例封装之后，传给服务端。接下来，我们前往服务端接收数据，打开 ",(0,s.jsx)(n.code,{children:"upload.js"}),"，添加如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"'use strict';\n\nconst fs = require('fs')\nconst moment = require('moment')\nconst mkdirp = require('mkdirp')\nconst path = require('path')\n\nconst Controller = require('egg').Controller;\n\nclass UploadController extends Controller {\n  async upload() {\n    const { ctx } = this\n    // 需要前往 config/config.default.js 设置 config.multipart 的 mode 属性为 file\n    let file = ctx.request.files[0]\n  \n    // 声明存放资源的路径\n    let uploadDir = ''\n  \n    try {\n      // ctx.request.files[0] 表示获取第一个文件，若前端上传多个文件则可以遍历这个数组对象\n      let f = fs.readFileSync(file.filepath)\n      // 1.获取当前日期\n      let day = moment(new Date()).format('YYYYMMDD')\n      // 2.创建图片保存的路径\n      let dir = path.join(this.config.uploadDir, day);\n      let date = Date.now(); // 毫秒数\n      await mkdirp(dir); // 不存在就创建目录\n      // 返回图片保存的路径\n      uploadDir = path.join(dir, date + path.extname(file.filename));\n      // 写入文件夹\n      fs.writeFileSync(uploadDir, f)\n    } finally {\n      // 清除临时文件\n      ctx.cleanupRequestFiles();\n    }\n  \n    ctx.body = {\n      code: 200,\n      msg: '上传成功',\n      data: uploadDir.replace(/app/g, ''),\n    }\n  }\n}\n\nmodule.exports = UploadController;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们从头到位分析资源上传接口逻辑。首先我们需要安装 ",(0,s.jsx)(n.code,{children:"moment"})," 和 ",(0,s.jsx)(n.code,{children:"mkdirp"}),"，分别用于时间戳的转换和新建文件夹。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm i moment mkdirp -S\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其次，",(0,s.jsx)(n.code,{children:"egg"})," 提供两种文件接收模式，1 是 ",(0,s.jsx)(n.code,{children:"file"})," 直接读取，2 是 ",(0,s.jsx)(n.code,{children:"stream"})," 流的方式。我们采用比较熟悉的 ",(0,s.jsx)(n.code,{children:"file"})," 形式。所以需要前往 ",(0,s.jsx)(n.code,{children:"config/config.default.js"})," 配置好接收形式："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"config.multipart = {\n  mode: 'file'\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"multipart"})," 配置项有很多选项，比如 ",(0,s.jsx)(n.code,{children:"whitelist"})," 上传格式的定制，",(0,s.jsx)(n.code,{children:"fileSize"})," 文件大小的限制，这些都可以在",(0,s.jsx)(n.a,{href:"https://eggjs.github.io/zh/guide/upload.html",target:"_blank",rel:"noopener noreferrer",children:"文档"}),"中查找到。"]}),"\n",(0,s.jsxs)(n.p,{children:["配置完成之后，我们才能通过 ",(0,s.jsx)(n.code,{children:"ctx.request.files"})," 的形式，获取到前端上传的文件资源。"]}),"\n",(0,s.jsxs)(n.p,{children:["通过 ",(0,s.jsx)(n.code,{children:"fs.readFileSync(file.filepath)"})," 读取文件，保存在 ",(0,s.jsx)(n.code,{children:"f"})," 变量中，后续使用。"]}),"\n",(0,s.jsx)(n.p,{children:"创建一个图片保存的文件路径："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let dir = path.join(this.config.uploadDir, day);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"this.config.uploadDir"}),"  需要全局声明，便于后续通用，在 ",(0,s.jsx)(n.code,{children:"config/config.default.js"})," 中声明如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// add your user config here\nconst userConfig = {\n  // myAppName: 'egg',\n  uploadDir: 'app/public/upload'\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["通过 ",(0,s.jsx)(n.code,{children:"await mkdirp(dir)"})," 创建目录，如果已经存在，这里是不会再重新创建的，",(0,s.jsx)(n.code,{children:"mkdirp"})," 方法内部已经实现。"]}),"\n",(0,s.jsx)(n.p,{children:"构建好文件的路径，如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"uploadDir = path.join(dir, date + path.extname(file.filename));\n"})}),"\n",(0,s.jsx)(n.p,{children:"最后，我们将文件内容写入上述路径，如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"fs.writeFileSync(uploadDir, f)\n"})}),"\n",(0,s.jsx)(n.p,{children:"成功之后返回路径："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"ctx.body = {\n  code: 200,\n  msg: '上传成功',\n  data: uploadDir.replace(/app/g, ''),\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里要注意的是，需要将 ",(0,s.jsx)(n.code,{children:"app"})," 去除，因为我们在前端访问路径的时候，是不需要 ",(0,s.jsx)(n.code,{children:"app"})," 这个路径的，比如我们项目启动的是 7001 端口，最后我们访问的文件路径是这样的 ",(0,s.jsx)(n.code,{children:"http://localhost:7001/public/upload/20210521/1621564997310.jpeg"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["完成上述操作之后，我们还需要在做最后一步操作，解决跨域。首先安装 ",(0,s.jsx)(n.code,{children:"egg-cors"})," 插件 ",(0,s.jsx)(n.code,{children:"npm i egg-cors"}),"，安装好之后，前往 ",(0,s.jsx)(n.code,{children:"config/plugins.js"})," 下添加属性："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"cors: {\n  enable: true,\n  package: 'egg-cors',\n},\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后在 ",(0,s.jsx)(n.code,{children:"config.default.js"})," 配置如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"config.cors = {\n  origin: '*', // 允许所有跨域访问\n  credentials: true, // 允许 Cookie 跨域跨域\n  allowMethods: 'GET,HEAD,PUT,POST,DELETE,PATCH'\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"上述逻辑完成之后，我们打开之前写好的前端页面，点击上传图片，如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["拿到这样一串路径，我们可以查看服务端项目 ",(0,s.jsx)(n.code,{children:"app/public"})," 文件夹下，是否存入了图片资源："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"在通过浏览器访问图片路径，如下代表图片成功上传至服务器："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["此时我们拿到了服务器返回的图片地址，便可以将其提交至 ",(0,s.jsx)(n.code,{children:"editUserInfo"})," 方法。我们为 ",(0,s.jsx)(n.code,{children:"editUserInfo"})," 方法添加如下参数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 修改用户信息\nasync editUserInfo () {\n  const { ctx, app } = this;\n  // 通过 post 请求，在请求体中获取签名字段 signature\n  const { signature = '', avatar = '' } = ctx.request.body\n\n  try {\n    let user_id\n    const token = ctx.request.header.authorization;\n    const decode = await app.jwt.verify(token, app.config.jwt.secret);\n    if (!decode) return\n    user_id = decode.id\n\n    const userInfo = await ctx.service.user.getUserByName(decode.username)\n    const result = await ctx.service.user.editUserInfo({\n      ...userInfo,\n      signature,\n      avatar\n    });\n\n    ctx.body = {\n      code: 200,\n      msg: '修改成功',\n      data: {\n        id: user_id,\n        signature,\n        username: userInfo.username,\n        avatar\n      }\n    }\n  } catch (error) {\n    \n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述代码，在传参中添加了 ",(0,s.jsx)(n.code,{children:"avatar"})," 参数，并且传入 ",(0,s.jsx)(n.code,{children:"ctx.service.user.editUserInfo"})," 方法保存。"]}),"\n",(0,s.jsxs)(n.h4,{id:"上传资源知识拓展",children:["上传资源知识拓展",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#上传资源知识拓展",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上述方法是我们没有 ",(0,s.jsx)(n.code,{children:"OSS"})," 服务的情况下使用的，目前市面上更多的方式，是购买 ",(0,s.jsx)(n.code,{children:"OSS"})," 服务，将图片等静态资源上传至 ",(0,s.jsx)(n.code,{children:"CDN"}),"，通过内容分发的形式，让使用的用户就近获取在线资源。这属于网站性能优化的一种方式，减少主域名下的资源请求数量，以此来降低网页加载的延迟。"]}),"\n",(0,s.jsxs)(n.p,{children:["七牛云免费提供了 10GB 的存储空间，如果有域名并且备案过的同学，可以利用它实现一个 ",(0,s.jsx)(n.code,{children:"CDN"})," 的服务，将文件资源存到七牛云内，这样可以降低自己服务器的存储压力。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"此时我们又完成了三个接口的编写，你会觉得，写服务端比写前端轻松多了。"}),"\n",(0,s.jsx)(n.p,{children:"其实不是这样的，每一个工种都有各自的难点。前端更多的是面向浏览器，而浏览器和用户是一对一的关系，前端更多的是注重视觉和交互方面的体验，让用户以最简单易用的方式去完成自己的诉求。"}),"\n",(0,s.jsx)(n.p,{children:"反观服务端，则是一份服务端代码，为多个终端服务，所以服务端更多是一对多的关系。这就很考验服务端的代码，以及数据库的工作效率。在流量峰值能否很好的响应每个用户发起的请求，极端情况就是天猫双十一这种请求量级，服务端的压力是难以想象的。"}),"\n",(0,s.jsx)(n.p,{children:"所以每个工种，只要做得精，都能发光发热。"}),"\n",(0,s.jsxs)(n.h4,{id:"本章节源代码",children:["本章节源代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本章节源代码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://s.yezgea02.com/1621577800080/juejue-server.zip",target:"_blank",rel:"noopener noreferrer",children:"点击下载"})})]})}function j(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}let x=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F7.%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BF%AE%E6%94%B9%E4%B8%AA%E7%AD%BE%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E3%80%81%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%EF%BC%89.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"知识点",id:"知识点",depth:4},{text:"获取用户信息",id:"获取用户信息",depth:2},{text:"修改个性签名",id:"修改个性签名",depth:4},{text:"修改用户头像",id:"修改用户头像",depth:2},{text:"上传资源知识拓展",id:"上传资源知识拓展",depth:4},{text:"总结",id:"总结",depth:2},{text:"本章节源代码",id:"本章节源代码",depth:4}],title:"7.后端实战：后端实战：用户信息相关接口实现（修改个签、修改密码、上传头像）",headingTitle:"7.后端实战：后端实战：用户信息相关接口实现（修改个签、修改密码、上传头像）",frontmatter:{}}}}]);