"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["54800"],{541645:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var s=r(552676),o=r(740453);let i=r.p+"static/image/5d9be6dbd73d7dac8d148c3ea91921a3.241c0683.webp",l=r.p+"static/image/01cc708b1d0e0f5093854fe751ec6fe1.a587f9ca.webp";function c(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",h2:"h2",blockquote:"blockquote",pre:"pre",img:"img",ol:"ol",strong:"strong"},(0,o.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"22插件开发进阶如何提升插件健壮性",children:["22.插件开发进阶：如何提升插件健壮性？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22插件开发进阶如何提升插件健壮性",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在上一章节中，我们详细介绍了 Webpack 插件的开发方式与基本架构逻辑，并结合若干开源项目剖析插件中如何与 Webpack 上下文交互，从而修改构建逻辑，实现插件功能需求。本文将继续介绍 Webpack 插件开发方法，总结一些较为常用，有助于提升插件可用性、健壮性的开发技巧，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如何正确处理插件日志；"}),"\n",(0,s.jsx)(n.li,{children:"如何上报统计信息，帮助用户更好了解插件的运行情况；"}),"\n",(0,s.jsxs)(n.li,{children:["如何借助 ",(0,s.jsx)(n.code,{children:"schema-utils"})," 校验配置参数；"]}),"\n",(0,s.jsx)(n.li,{children:"如何搭建自动测试环境。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"日志处理",children:["日志处理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#日志处理",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"与 Loader 相似，开发插件时我们也可以复用 Webpack 一系列日志基础设施，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["通过 ",(0,s.jsx)(n.code,{children:"compilation.getLogger"})," 获取分级日志管理器；"]}),"\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"compilation.errors/wraning"})," 处理异常信息。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"下面我们逐一展开介绍。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"使用分级日志基础设施"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["在前面 《",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035404715556879",target:"_blank",rel:"noopener noreferrer",children:"Loader 开发基础"}),"》一文中，我们已经详细介绍了 Webpack 内置的日志接口： ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/other-options/#infrastructurelogging",target:"_blank",rel:"noopener noreferrer",children:"infrastructureLogging"}),"，与 ",(0,s.jsx)(n.a,{href:"https://github.com/log4js-node/log4js-node",target:"_blank",rel:"noopener noreferrer",children:"log4js"}),"、",(0,s.jsx)(n.a,{href:"https://github.com/winstonjs/winston",target:"_blank",rel:"noopener noreferrer",children:"winston"})," 等日志工具类似，借助这一能力我们能实现日志分级筛选能力，适用于处理一些执行过程的日志信息。"]}),"\n",(0,s.jsx)(n.p,{children:"开发插件时，我们也能使用这一接口管理日志输出，只是用法稍有不同，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const PLUGIN_NAME = "FooPlugin";\n\nclass FooPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {\n      // 获取日志对象\n      const logger = compilation.getLogger(PLUGIN_NAME);\n      // 调用分级日志接口\n      logger.log(\'Logging from FooPlugin\')\n      logger.error("Error from FooPlugin");\n    });\n  }\n}\n\nmodule.exports = FooPlugin;\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：此外，还可以通过 ",(0,s.jsx)(n.code,{children:"compiler.getInfrastructureLogger"})," 获取日志对象。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["上述代码需要调用 ",(0,s.jsx)(n.code,{children:"compilation.getLogger"})," 获取日志对象 ",(0,s.jsx)(n.code,{children:"logger"}),"，",(0,s.jsx)(n.code,{children:"logger"})," 的用法与 Loader 场景相似，同样支持 ",(0,s.jsx)(n.code,{children:"verbose/log/info/warn/error"})," 五种日志分级，此处不再赘述。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"正确处理异常信息"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"在 Webpack 插件中，可以通过如下方式提交错误信息。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"logger.error/warning"})," 接口，这种方法同样不会中断构建流程，且能够复用 Webpack 的分级日志体系，由最终用户决定是否输出对应等级日志。"]}),"\n",(0,s.jsxs)(n.li,{children:["借助 ",(0,s.jsx)(n.code,{children:"compilation.errors/warnings"})," 数组，如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const PLUGIN_NAME = "FooPlugin";\n\nclass FooPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {\n      compilation.errors.push(new Error("Emit Error From FooPlugin"));\n      compilation.warnings.push("Emit Warning From FooPlugin");\n    });\n  }\n}\n\nmodule.exports = FooPlugin;\n'})}),"\n",(0,s.jsx)(n.p,{children:"执行效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:["这种方法仅记录异常日志，不影响构建流程，构建正常结束后 Webpack 还会将错误信息汇总到 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/stats/",target:"_blank",rel:"noopener noreferrer",children:"stats"})," 统计对象，方便后续二次处理，使用率极高。例如 ",(0,s.jsx)(n.a,{href:"https://github1s.com/webpack-contrib/eslint-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"eslint-webpack-plugin"})," 就是通过这种方式输出 ESLint 检查出来的代码风格问题。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 Hook Callback，这种方式可将错误信息传递到 Hook 下一个流程，由 Hook 触发者根据错误内容决定后续处理措施(中断、忽略、记录日志等)，如 ",(0,s.jsx)(n.code,{children:"imagemin-webpack-plugin"})," 中："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default class ImageminPlugin {\n  apply (compiler) {\n    const onEmit = async (compilation, callback) => {\n      try {\n        await Promise.all([\n          ...this.optimizeWebpackImages(throttle, compilation),\n          ...this.optimizeExternalImages(throttle)\n        ])\n\n        callback()\n      } catch (err) {\n        // if at any point we hit a snag, pass the error on to webpack\n        callback(err)\n      }\n    }\n    compiler.hooks.emit.tapAsync(this.constructor.name, onEmit)\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上例第 13 行，在 ",(0,s.jsx)(n.code,{children:"catch"})," 块中通过 ",(0,s.jsx)(n.code,{children:"callback"})," 函数传递错误信息。不过，并不是所有 Hook 都会传递 ",(0,s.jsx)(n.code,{children:"callback"})," 函数，实际开发时建议参考相关用例。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"直接抛出异常，如："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const PLUGIN_NAME = "FooPlugin";\n\nclass FooPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {\n      throw new Error("Throw Error Directly")\n    });\n  }\n}\n\nmodule.exports = FooPlugin;\n'})}),"\n",(0,s.jsx)(n.p,{children:"这种方式会导致 Webpack 进程奔溃，多用于插件遇到严重错误，不得不提前中断构建工作的场景。"}),"\n",(0,s.jsx)(n.p,{children:"总的来说，这些方式各自有适用场景，我个人会按如下规则择优选用："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["多数情况下使用 ",(0,s.jsx)(n.code,{children:"compilation.errors/warnings"}),"，柔和地抛出错误信息；"]}),"\n",(0,s.jsx)(n.li,{children:"特殊场景，需要提前结束构建时，则直接抛出异常；"}),"\n",(0,s.jsxs)(n.li,{children:["拿捏不准的时候，使用 ",(0,s.jsx)(n.code,{children:"callback"})," 透传错误信息，交由上游调用者自行判断处理措施。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"上报统计信息",children:["上报统计信息",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#上报统计信息",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["有时候我们需要在插件中执行一些特别耗时的操作，例如：抽取 CSS 代码（如 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/mini-css-extract-plugin",target:"_blank",rel:"noopener noreferrer",children:"mini-css-extract-plugin"}),"）、压缩图片（如 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/image-minimizer-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"image-minimizer-webpack-plugin"}),"）、代码混淆（如 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/terser-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"terser-webpack-plugin"}),"），这些操作会延长 Webpack 构建的整体耗时，更糟糕的是会阻塞构建主流程，最终用户会感觉到明显卡顿。"]}),"\n",(0,s.jsx)(n.p,{children:"针对这种情况，我们可以在插件中上报一些统计信息，帮助用户理解插件的运行进度与性能情况，有两种上报方式："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/plugins/progress-plugin",target:"_blank",rel:"noopener noreferrer",children:"ProgressPlugin"})," 插件的 ",(0,s.jsx)(n.code,{children:"reportProgress"})," 接口上报执行进度；"]}),"\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/stats/",target:"_blank",rel:"noopener noreferrer",children:"stats"})," 接口汇总插件运行的统计数据。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"reportProgress"})," 接口"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/plugins/progress-plugin",target:"_blank",rel:"noopener noreferrer",children:"ProgressPlugin"})," 是 Webpack 内置用于展示构建进度的插件，有两种用法："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["简化版，执行构建命令时带上 ",(0,s.jsx)(n.code,{children:"--progress"})," 参数，如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx webpack --progress\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"也可以在 Webpack 配置文件中添加插件实例，如："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const { ProgressPlugin } = require("webpack");\n\nmodule.exports = {\n  //...\n  plugins: [\n    new ProgressPlugin({\n      activeModules: false,\n      entries: true,\n      handler(percentage, message, ...args) {\n        // custom logic\n      },\n      //...\n    }),\n  ],\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:["开发插件时，我们可以使用 ",(0,s.jsx)(n.code,{children:"ProgressPlugin"})," 插件的 ",(0,s.jsx)(n.code,{children:"Reporter"})," 方法提交自定义插件的运行进度，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const { ProgressPlugin } = require("webpack");\nconst PLUGIN_NAME = "BlockPlugin";\nconst wait = (misec) => new Promise((r) => setTimeout(r, misec));\nconst noop = () => ({});\n\nclass BlockPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {\n      compilation.hooks.processAssets.tapAsync(\n        PLUGIN_NAME,\n        async (assets, callback) => {\n          const reportProgress = ProgressPlugin.getReporter(compiler) || noop;\n          const len = 100;\n          for (let i = 0; i < len; i++) {\n            await wait(50);\n            reportProgress(i / 100, `Our plugin is working ${i}%`);\n          }\n          reportProgress(1, "Done work!");\n          await wait(1000);\n          callback();\n        }\n      );\n    });\n  }\n}\n\nmodule.exports = BlockPlugin;\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：示例代码已上传到小册 ",(0,s.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/blob/main/plugin-progress/package.json",target:"_blank",rel:"noopener noreferrer",children:"仓库"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["示例中，最关键的代码在于第 12 行，即调用 ",(0,s.jsx)(n.code,{children:"ProgressPlugin.getReporter"})," 方法获取 Reporter 函数，之后再用这个函数提交执行进度："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const reportProgress = ProgressPlugin.getReporter(compiler) || noop;\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注意：若最终用户没有使用 ",(0,s.jsx)(n.code,{children:"ProgressPlugin"})," 插件，则这个函数会返回 Undefined，所以需要增加 ",(0,s.jsx)(n.code,{children:"|| noop"})," 兜底。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"reportProgress"})," 接受如下参数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"reportProgress(percentage, ...args);\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"percentage"}),"：当前执行进度百分比，但这个参数实际并不生效， ",(0,s.jsx)(n.code,{children:"ProgressPlugin"})," 底层会根据当前处于那个 Hook 计算一个固定的 Progress 百分比值，在自定义插件中无法改变，所以目前来看这个参数值随便填就好；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"...args"}),"：任意数量字符串参数，这些字符串会被拼接到 Progress 输出的信息。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"最终执行效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"3f291b39-e4cd-498c-b1e8-819d964982ab.gif"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["通过 ",(0,s.jsx)(n.code,{children:"stats"})," 添加统计信息"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://webpack.js.org/api/stats/",target:"_blank",rel:"noopener noreferrer",children:"stats"})," 是 Webpack 内置的数据统计机制，专门用于收集模块构建耗时、模块依赖关系、产物组成等过程信息，我们可以借此分析、优化应用构建性能（后面章节会展开细讲）。在开发插件时，我们可以借用 ",(0,s.jsx)(n.code,{children:"stats"})," 机制，向用户输出插件各种维度的统计信息，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'const PLUGIN_NAME = "FooPlugin";\n\nclass FooPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation) => {\n      const statsMap = new Map();\n      // buildModule 钩子将在开始处理模块时触发\n      compilation.hooks.buildModule.tap(PLUGIN_NAME, (module) => {\n        const ident = module.identifier();\n        const startTime = Date.now();\n        // 模拟复杂耗时操作\n        // ...\n        // ...\n        const endTime = Date.now();\n        // 记录处理耗时\n        statsMap.set(ident, endTime - startTime);\n      });\n\n      compilation.hooks.statsFactory.tap(PLUGIN_NAME, (factory) => {\n        factory.hooks.result\n          .for("module")\n          .tap(PLUGIN_NAME, (module, context) => {\n            const { identifier } = module;\n            const duration = statsMap.get(identifier);\n            // 添加统计信息\n            module.fooDuration = duration || 0;\n          });\n      });\n    });\n  }\n}\n\nmodule.exports = FooPlugin;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["再次执行 Webpack 构建命令，将产出如下 ",(0,s.jsx)(n.code,{children:"stats"})," 统计信息："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "hash": "0a17278b49620a86b126",\n  "version": "5.73.0",\n  // ...\n  "modules": [\n    {\n      "type": "module",\n      "identifier": "/Users/tecvan/studio/webpack-book-samples/target-sample/src/index.js",\n      "fooDuration": 124,\n      /*...*/\n    },\n    /*...*/\n    /*...*/\n    /*...*/\n  ], \n  "assets": [/*...*/],\n  "chunks": [/*...*/],\n  "entrypoints": {/*...*/},\n  "namedChunkGroups": {/*...*/},\n  "errors": [/*...*/],\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"这种方式有许多优点："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["用户可以直接通过 ",(0,s.jsx)(n.code,{children:"stats"})," 了解插件的运行情况，不需要重复学习其它方式；"]}),"\n",(0,s.jsxs)(n.li,{children:["支持按需执行，用户可通过 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/stats/",target:"_blank",rel:"noopener noreferrer",children:"stats"})," 配置项控制；"]}),"\n",(0,s.jsx)(n.li,{children:"支持导出为 JSON 或其它文件格式，方便后续接入自动化分析流程。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"因此，若明确插件将执行非常重的计算任务，需要消耗比较长的构建时间时，可以通过这种方式上报关键性能数据，帮助用户做好性能分析。"}),"\n",(0,s.jsxs)(n.h2,{id:"校验配置参数",children:["校验配置参数",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#校验配置参数",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在《",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035564862472233",target:"_blank",rel:"noopener noreferrer",children:"Loader 开发进阶"}),"》一文中，我们已经详细介绍了 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/schema-utils",target:"_blank",rel:"noopener noreferrer",children:"schema-utils"})," 校验工具的使用方法，开发插件时也使用这一工具校验配置参数，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const { validate } = require("schema-utils");\nconst schema = {\n  /*...*/\n};\n\nclass FooPlugin {\n  constructor(options) {\n    validate(schema, options);\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["详细用法可自行回顾《",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035564862472233",target:"_blank",rel:"noopener noreferrer",children:"Loader 开发进阶"}),"》章节，此处不再赘述。"]}),"\n",(0,s.jsxs)(n.h2,{id:"搭建自动测试环境",children:["搭建自动测试环境",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#搭建自动测试环境",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"为 Webpack Loader 编写单元测试收益非常高，一方面对开发者来说，不用重复搭建测试环境、编写测试 demo；一方面对于最终用户来说，带有一定测试覆盖率的项目通常意味着更高、更稳定的质量。插件测试用例开发有两个关键技术点："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"如何搭建自动运行 Webpack，并能够读取构建结果的测试环境？"}),"\n",(0,s.jsx)(n.li,{children:"如何分析构建结果，确定插件逻辑符合预期？"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"搭建测试环境"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Webpack 虽然功能非常复杂，但本质上还是一个 Node 程序，所以我们可以使用一些 Node 测试工具搭建自动测试环境，例如 Jest、Karma 等。以 Jest 为例："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["安装依赖，考虑到我们即将用 ES6 编写测试用例，这里额外添加了 ",(0,s.jsx)(n.a,{href:"https://jestjs.io/docs/getting-started#using-babel",target:"_blank",rel:"noopener noreferrer",children:"babel-jest"})," 等包："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"yarn add -D jest babel-jest @babel/core @babel/preset-env\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"添加 Babel 配置，如："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// babel.config.js\nmodule.exports = {\n  presets: [['@babel/preset-env', {targets: {node: 'current'}}]],\n};\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"添加 Jest 配置文件，如："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// jest.config.js\nmodule.exports = {\n  testEnvironment: "node",\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"到这里，基础环境设置完毕，我们可以开始编写测试用例了。首先需要在测试代码中运行 Webpack，方法很简单，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import webpack from 'webpack';\n\nwebpack(config).run();\n"})}),"\n",(0,s.jsx)(n.p,{children:"这部分逻辑比较通用，许多开源仓库都会将其提取为工具函数，类似于："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import path from "path";\nimport webpack from "webpack";\nimport { merge } from "webpack-merge";\nimport { createFsFromVolume, Volume } from "memfs";\n\nexport function runCompile(options) {\n  const opt = merge(\n    {\n      mode: "development",\n      devtool: false,\n      // Mock 项目入口文件\n      entry: path.join(__dirname, "./enter.js"),\n      output: { path: path.resolve(__dirname, "../dist") },\n    },\n    options\n  );\n\n  const compiler = webpack(opt);\n  // 使用内存文件系统，节省磁盘 IO 开支\n  compiler.outputFileSystem = createFsFromVolume(new Volume());\n\n  return new Promise((resolve, reject) => {\n    compiler.run((error, stats) => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve({ stats, compiler });\n    });\n  });\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：示例代码已上传到小册 ",(0,s.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/blob/main/plugin-testing/test/helpers/index.js",target:"_blank",rel:"noopener noreferrer",children:"仓库"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"有了测试所需的基础环境，以及运行 Webpack 实例的能力之后，我们可以正式开始编写测试用例了。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"编写测试用例"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Webpack 插件测试的基本逻辑是：在测试框架中运行 Webpack，之后对比分析构建结果、状态等是否符合预期，对比的内容通常有："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["分析 ",(0,s.jsx)(n.code,{children:"compilation.error/warn"})," 数组是否包含或不包含特定错误、异常信息，通常用于判断 Webpack 是否运行成功；"]}),"\n",(0,s.jsxs)(n.li,{children:["分析构建产物，判断是否符合预期，例如：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"image-minimizer-webpack-plugin"})," 单测中会 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/image-minimizer-webpack-plugin/blob/master/test/ImageminPlugin.test.js",target:"_blank",rel:"noopener noreferrer",children:"判断"})," 最终产物图片有没有经过压缩；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"copy-webpack-plugn"})," 单测中会 ",(0,s.jsx)(n.a,{href:"https://github1s.com/webpack-contrib/copy-webpack-plugin/blob/HEAD/test/CopyPlugin.test.js",target:"_blank",rel:"noopener noreferrer",children:"判断"})," 文件有没有被复制到产物文件；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"mini-css-extract-plugin"})," 单测中会 ",(0,s.jsx)(n.a,{href:"https://github1s.com/webpack-contrib/mini-css-extract-plugin/blob/HEAD/test/TestCases.test.js",target:"_blank",rel:"noopener noreferrer",children:"判断"})," CSS 文件有没有被正确抽取出来。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"沿着这个思路，我们构造一个简单的测试用例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import path from "path";\nimport { promisify } from "util";\nimport { runCompile } from "./helpers";\nimport FooPlugin from "../src/FooPlugin";\n\ndescribe("foo plugin", () => {\n  it("should inject foo banner", async () => {\n    const {\n      stats: { compilation },\n      compiler,\n    } = await runCompile({\n      plugins: [new FooPlugin()],\n    });\n    const { warnings, errors, assets } = compilation;\n\n    // 判断 warnings、errors 是否报出异常信息\n    expect(warnings).toHaveLength(0);\n    expect(errors).toHaveLength(0);\n\n    const { path: outputPath } = compilation.options.output;\n    // 遍历 assets，判断经过插件处理后，产物内容是否符合预期\n    await Promise.all(\n      Object.keys(assets).map(async (name) => {\n        const pathToEmitted = path.join(outputPath, name);\n        const result = await promisify(compiler.outputFileSystem.readFile)(\n          pathToEmitted,\n          { encoding: "UTF-8" }\n        );\n        expect(result.startsWith("// Inject By 范文杰")).toBeTruthy();\n      })\n    );\n  });\n});\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：示例代码已上传到小册 ",(0,s.jsx)(n.a,{href:"https://github.com/Tecvan-fe/webpack-book-samples/blob/main/plugin-testing/test/helpers/index.js",target:"_blank",rel:"noopener noreferrer",children:"仓库"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["示例中，17、18 行通过 ",(0,s.jsx)(n.code,{children:"errors/warnings"})," 判断运行过程是否出现异常；25 行读入产物文件，之后判断内容是否满足要求。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本文主要介绍 Webpack 插件可用性与健壮性层面的开发技巧，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"我们应该尽量复用 Webpack Infrastructure Logging 接口记录插件运行日志；"}),"\n",(0,s.jsxs)(n.li,{children:["若插件运行耗时较大，应该通过 ",(0,s.jsx)(n.code,{children:"reportProgress"})," 接口上报执行进度，供用户了解运行状态；"]}),"\n",(0,s.jsxs)(n.li,{children:["应该尽可能使用 ",(0,s.jsx)(n.code,{children:"schema-utils"})," 工具校验插件参数，确保输入参数的合法性；"]}),"\n",(0,s.jsxs)(n.li,{children:["可以借助 Node 测试工具，如 Jest、Karma 等搭建插件自动测试环境，之后在测试框架中运行 Webpack，分析比对构建结果、状态(产物文件、",(0,s.jsx)(n.code,{children:"warning/errors"})," 数组等)，确定插件是否正常运行。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这些技巧与插件主功能无关，但有助于提升插件质量，还可以让用户更了解插件的运行状态、运行性能等，让插件本身更可靠，更容易被用户选择。"}),"\n",(0,s.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["综合全文，思考一下 Logger 的 ",(0,s.jsx)(n.code,{children:"warn/error"})," 接口与 ",(0,s.jsx)(n.code,{children:"compilation"})," 对象的 ",(0,s.jsx)(n.code,{children:"errors/warnings"})," 数组有什么区别？分别适用于什么场景？哪种方式更利于自动化测试？"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F22.%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E6%8F%92%E4%BB%B6%E5%81%A5%E5%A3%AE%E6%80%A7%EF%BC%9F.md"]={toc:[{text:"日志处理",id:"日志处理",depth:2},{text:"上报统计信息",id:"上报统计信息",depth:2},{text:"校验配置参数",id:"校验配置参数",depth:2},{text:"搭建自动测试环境",id:"搭建自动测试环境",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"22.插件开发进阶：如何提升插件健壮性？",headingTitle:"22.插件开发进阶：如何提升插件健壮性？",frontmatter:{}}}}]);