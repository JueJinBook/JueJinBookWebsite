"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["81100"],{995178:function(e,n,t){t.r(n),t.d(n,{default:()=>x});var r=t(552676),c=t(740453);let i=t.p+"static/image/f38434de9883c70673e4d92fd806499b.f4fc171f.webp",s=t.p+"static/image/b9b5f7789bdf12cdd3390d57cb525d0b.0261a8de.webp",a=t.p+"static/image/b91d4e65071d11bf5552a007ce99723d.6fa3212b.webp",l=t.p+"static/image/92ba16c2e501c0ac72e7a6b03b2d284a.da131d35.webp",o=t.p+"static/image/021561aaddf65e762085ee1e2032341b.7e6e2301.webp";function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",pre:"pre",code:"code",img:"img",blockquote:"blockquote"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"32-实战使用-web-bluetooth-api-操作智能设备",children:["32 实战：使用 Web Bluetooth API 操作智能设备",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-实战使用-web-bluetooth-api-操作智能设备",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在上一节课中，我们做了一些准备工作，创建了项目目录，安装了一些依赖。不过在这一节课，我们先不继续在项目里添加代码，因为还有一些准备工作要做。"}),"\n",(0,r.jsx)(n.p,{children:"前面说过，对于 GATT 协议的蓝牙设备，我们将使用 Web Bluetooth API 来进行通信，而 Web Bluetooth API 已经被 Chrome 浏览器支持了，所以我们可以先通过一些简单的代码来熟悉这个 API。"}),"\n",(0,r.jsxs)(n.h2,{id:"选择智能设备",children:["选择智能设备",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#选择智能设备",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在国内厂商的蓝牙智能设备里，选择支持通用的 GATT 协议的设备并不容易，大部分设备都是基于自己的协议来实现的，所以我们这里选择了一个国外的设备，它叫 ",(0,r.jsx)(n.a,{href:"https://www.mipow.com/products/playbulb-candle",target:"_blank",rel:"noopener noreferrer",children:"Mipow PlayBlub Candel"}),"，是一款蓝牙智能 LED 灯，它支持 GATT 协议，我们可以通过它来学习 Web Bluetooth API。"]}),"\n",(0,r.jsx)(n.p,{children:"这个设备在国内卖的不多，但如果你不想海淘，也可以在淘宝或者闲鱼上购买到，或者购买 Mipow 的其他智能 LED 设备也可以。"}),"\n",(0,r.jsx)(n.p,{children:"有了设备，我们再来看看使用 Web Bluetooth API 操作这个设备需要做哪些准备工作。"}),"\n",(0,r.jsxs)(n.h3,{id:"连接设备",children:["连接设备",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#连接设备",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先，如何通过 Web Bluetooth API 来查找设备？这里我们使用的是 Chrome 浏览器，因为它是唯一支持 Web Bluetooth API 的浏览器。"}),"\n",(0,r.jsx)(n.p,{children:"我们先写一个简单的 HTML 页面："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<meta charset="UTF-8">\n<button id="connector">连接设备</button>\n<button id="switcher">开关</button>\n​\n<script>\nlet service = null;\n​\nconnector.onclick = async () => {\n \xa0const device = await navigator.bluetooth.requestDevice({\n \xa0 \xa0filters: [{namePrefix: \'PLAYBULB\'}],\n \xa0 \xa0optionalServices: [0xff00, 0xff02, 0xff0f],\n  });\n​\n \xa0const server = await device.gatt.connect();\n​\n \xa0service = (await server.getPrimaryServices())[0];\n​\n \xa0console.log(\'connected!\', service);\n};\n<\/script>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在上面的代码中，我们使用了",(0,r.jsx)(n.code,{children:"navigator.bluetooth.requestDevice"}),"方法查找设备，这个方法接收一个对象作为参数，而这个对象里有两个属性，分别是",(0,r.jsx)(n.code,{children:"filters"}),"和",(0,r.jsx)(n.code,{children:"optionalServices"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"filters"}),"属性是一个数组，它里面可以包含多个对象，每个对象都是一个过滤器，这些过滤器都是",(0,r.jsx)(n.code,{children:"AND"}),"关系。也就是说，只有同时满足所有过滤器的设备才会被查找到。"]}),"\n",(0,r.jsxs)(n.p,{children:["这里我们只有一个过滤器，它的",(0,r.jsx)(n.code,{children:"namePrefix"}),"属性是",(0,r.jsx)(n.code,{children:"PLAYBULB"}),"。这个属性的意思是，设备的名称必须以",(0,r.jsx)(n.code,{children:"PLAYBULB"}),"开头，这样我们就可以找到我们的设备了。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"optionalServices"}),"属性是一个数组，它里面可以包含多个数字，这些数字都是设备的服务 UUID。这里我们列出了三个服务，分别是",(0,r.jsx)(n.code,{children:"0xff00"}),"、",(0,r.jsx)(n.code,{children:"0xff02"}),"和",(0,r.jsx)(n.code,{children:"0xff0f"}),"。它们是我们设备的服务，被用来操作设备。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"0xff00"}),"、",(0,r.jsx)(n.code,{children:"0xff02"}),"和",(0,r.jsx)(n.code,{children:"0xff0f"}),"都有可能是控制 LED 灯的服务，但我们不知道哪个服务才是真正控制 LED 灯的服务，所以都列出来了，我们可以在连接后返回所有支持服务的列表，然后从中选取我们需要的服务。"]}),"\n",(0,r.jsxs)(n.p,{children:["注意到我们将",(0,r.jsx)(n.code,{children:"navigator.bluetooth.requestDevice"}),"方法调用写在了按钮被点击的事件里，这样只有用户主动点击按钮才会触发寻找可连接设备的操作。这是",(0,r.jsx)(n.code,{children:"Web Bluetooth API"}),"的一个限制，考虑到安全性，它不允许在非用户主动操作的情况下自动寻找设备，以避免用户隐私泄露。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"navigator.bluetooth.requestDevice"}),"方法会尝试寻找匹配的设备，如果找到了，它会询问用户是否建立连接，用户点击确定后返回一个",(0,r.jsx)(n.code,{children:"BluetoothDevice"}),"对象，这个对象就是我们要找的设备，我们可以通过它来获得设备。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,r.jsxs)(n.p,{children:["获得设备后，我们可以通过",(0,r.jsx)(n.code,{children:"device.gatt.connect"}),"方法来建立连接，这也是一个异步方法，成功后返回对应的连接服务实例。"]}),"\n",(0,r.jsxs)(n.p,{children:["接着我们可以通过服务实例获取服务，",(0,r.jsx)(n.code,{children:"await server.getPrimaryServices()"}),"异步返回所有支持的服务列表，这里我们只需要第一个服务，所以我们使用了",(0,r.jsx)(n.code,{children:"[0]"}),"来获取第一个服务，这个服务就是我们要找的服务，我们将它保存在",(0,r.jsx)(n.code,{children:"service"}),"变量里。"]}),"\n",(0,r.jsx)(n.p,{children:"这样我们获取服务的操作就完成了，我们可以在控制台里看到我们的服务实例了。"}),"\n",(0,r.jsxs)(n.h3,{id:"通过服务操作设备",children:["通过服务操作设备",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#通过服务操作设备",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"接下来，我们可以操作设备。我们修改上面的代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<meta charset="UTF-8">\n<button id="connector">连接设备</button>\n<button id="switcher">开关</button>\n​\n<script>\nlet service = null;\n​\nconnector.onclick = async () => {\n \xa0const device = await navigator.bluetooth.requestDevice({\n \xa0 \xa0filters: [{namePrefix: \'PLAYBULB\'}],\n \xa0 \xa0optionalServices: [0xff00, 0xff02, 0xff0f],\n  });\n​\n \xa0const server = await device.gatt.connect();\n​\n \xa0service = (await server.getPrimaryServices())[0];\n};\n​\nlet lightOn = false;\nswitcher.onclick = async() => {\n \xa0const characteristic = await service.getCharacteristic(0xfffc);\n \xa0lightOn = !lightOn;\n \xa0const color = lightOn ? [0xff, 0xff, 0xff] : [0, 0, 0];\n \xa0characteristic.writeValue(new Uint8Array([0x00, ...color]));\n};\n<\/script>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["上面的代码，我们在",(0,r.jsx)(n.code,{children:"switcher"}),"按钮的点击事件里，通过",(0,r.jsx)(n.code,{children:"service.getCharacteristic"}),"方法来获取一个设备的特性对象，这个方法接收一个数字作为参数，这个数字是特性对象的 UUID，这里我们使用的是",(0,r.jsx)(n.code,{children:"0xfffc"}),"，这个特性是我们设备的 LED 用来控制颜色的，一般根据规范，这个特性的 UUID 是",(0,r.jsx)(n.code,{children:"0xfffc"}),"。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"如果你拿到一个陌生的设备，不知道这个设备的服务和特性，你可以在手机上安装一个蓝牙设备调试工具，通过调试工具可以看到所有该设备支持的服务和对应的特性。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)("img",{src:l,alt:"image.png"})," 查看完设备的服务和特性之后，记得断开连接，以便设备能被浏览器发现。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["获取到特性对象后，我们可以通过它来操作设备，我们在",(0,r.jsx)(n.code,{children:"switcher"}),"按钮的点击事件里，通过",(0,r.jsx)(n.code,{children:"characteristic.writeValue"}),"方法来写入数据，这个方法接收一个",(0,r.jsx)(n.code,{children:"ArrayBuffer"}),"对象作为参数，这个对象就是我们要写入设备的数据。"]}),"\n",(0,r.jsx)(n.p,{children:"Playbulb 系列设备使用一个四位的 uint8 数组来表示颜色，这是一种叫做 WRGB 的颜色表示法，和 RGBA 类似，只不过第一位不是表示透明度，而是表示白光的强度。"}),"\n",(0,r.jsxs)(n.p,{children:["在这里，我们通过一个",(0,r.jsx)(n.code,{children:"lightOn"}),"变量来表示灯的开关状态，每次点击按钮时，我们将",(0,r.jsx)(n.code,{children:"lightOn"}),"变量取反，然后根据",(0,r.jsx)(n.code,{children:"lightOn"}),"变量的值来决定写入的颜色，如果",(0,r.jsx)(n.code,{children:"lightOn"}),"为",(0,r.jsx)(n.code,{children:"true"}),"，我们就写入白色，否则就写入黑色。这样就实现了开灯关灯的控制效果。"]}),"\n",(0,r.jsx)(n.p,{children:"最终效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:"Mar-07-2023 23-24-26.gif"})}),"\n",(0,r.jsxs)(n.h2,{id:"更加复杂的控制",children:["更加复杂的控制",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更加复杂的控制",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们可以对 Playbulb 设备进行更加复杂的控制，比如，我们可以通过一个滑块来控制灯的亮度，通过一个颜色选择器来控制灯的颜色。"}),"\n",(0,r.jsx)(n.p,{children:"我们修改上面的代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<meta charset="UTF-8">\n<button id="connector">连接设备</button>\n<button id="switcher">开关</button>\n<input type="color" id="palette" value="#ffffff"/>\n<input type="range" id="brightness" value="0" min="0" max="100" step="1"/>\n​\n<script>\nlet service = null;\n​\nfunction parseColorString(colorStr) {\n \xa0const rgb = colorStr.match(/[0-9a-f]{2}/ig).map((c) => parseInt(c, 16));\n \xa0return new Uint8Array(rgb);\n}\n​\nlet color = parseColorString(palette.value);\nlet lightOn = false;\nlet characteristic = null;\nlet bright = 0;\n​\npalette.addEventListener(\'change\', ({target}) => {\n \xa0color = parseColorString(target.value);\n \xa0if(lightOn) characteristic.writeValue(new Uint8Array([bright, ...color]));\n});\n​\nbrightness.addEventListener(\'change\', ({target}) => {\n \xa0bright = parseInt(target.value);\n \xa0if(lightOn) characteristic.writeValue(new Uint8Array([bright, ...color]));\n});\n​\nconnector.onclick = async () => {\n \xa0const device = await navigator.bluetooth.requestDevice({\n \xa0 \xa0filters: [{namePrefix: \'PLAYBULB\'}],\n \xa0 \xa0optionalServices: [0xff00, 0xff02, 0xff0f],\n  });\n​\n \xa0const server = await device.gatt.connect();\n​\n \xa0service = (await server.getPrimaryServices())[0];\n​\n \xa0characteristic = await service.getCharacteristic(0xfffc);\n \xa0characteristic.writeValue(new Uint8Array([0, 0, 0, 0]));\n​\n \xa0switcher.onclick = async() => {\n \xa0 \xa0lightOn = !lightOn;\n \xa0 \xa0characteristic.writeValue(new Uint8Array(lightOn ? [bright, ...color] : [0, 0, 0, 0]));\n  };\n};\n<\/script>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["首先，我们增加了一个",(0,r.jsx)(n.code,{children:"parseColorString"}),"函数，这个函数接收一个颜色字符串作为参数，返回一个",(0,r.jsx)(n.code,{children:"Uint8Array"}),"对象，这个对象就是我们要写入设备的颜色数据。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们通过",(0,r.jsx)(n.code,{children:"palette"}),"和",(0,r.jsx)(n.code,{children:"brightness"}),"两个滑块来控制灯的颜色和亮度，我们在",(0,r.jsx)(n.code,{children:"palette"}),"的",(0,r.jsx)(n.code,{children:"change"}),"事件里，通过",(0,r.jsx)(n.code,{children:"parseColorString"}),"函数来获取颜色数据，然后将颜色数据写入设备，我们在",(0,r.jsx)(n.code,{children:"brightness"}),"的",(0,r.jsx)(n.code,{children:"change"}),"事件里，通过",(0,r.jsx)(n.code,{children:"parseInt"}),"函数来获取亮度数据，然后将亮度数据写入设备。"]}),"\n",(0,r.jsx)(n.p,{children:"在设备开关的时候，我们传入当前的颜色和亮度数据，这样就实现了灯的颜色和亮度的控制。"}),"\n",(0,r.jsx)(n.p,{children:"最终的效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:"Mar-07-2023 23-46-46.gif"})}),"\n",(0,r.jsxs)(n.h2,{id:"特殊效果",children:["特殊效果",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#特殊效果",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Playbulb 设备还支持一些特殊的效果，比如，我们可以通过设备的特性来控制设备的呼吸灯效果、闪烁效果和跑马灯效果。"}),"\n",(0,r.jsx)(n.p,{children:"我们继续修改代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'<meta charset="UTF-8">\n<button id="connector">连接设备</button>\n<button id="switcher">开关</button>\n<select id="effect">\n \xa0<option value="none">无特效</option>\n \xa0<option value="0x00">闪烁</option>\n \xa0<option value="0x01">呼吸</option>\n \xa0<option value="0x03">彩虹</option>\n</select>\n<input type="color" id="palette" value="#ffffff"></input>\n<input type="range" id="brightness" value="0" min="0" max="100" step="1"></input>\n​\n<script>\nlet service = null;\n​\nfunction parseColorString(colorStr) {\n \xa0const rgb = colorStr.match(/[0-9a-f]{2}/ig).map((c) => parseInt(c, 16));\n \xa0return new Uint8Array(rgb);\n}\n​\nlet color = parseColorString(palette.value);\nlet lightOn = false;\nlet characteristic = null;\nlet effectCharacteristic = null;\nlet bright = 0;\nlet colorEffect = \'none\';\n​\nconst speedMap = {\n \xa0\'0x00\': 0x1f,\n \xa0\'0x01\': 0x03,\n \xa0\'0x03\': 0x1f,\n}\n​\nasync function updateColorEffect() {\n \xa0if(!characteristic || !effectCharacteristic) return;\n \xa0if(!lightOn) {\n \xa0 \xa0characteristic.writeValue(new Uint8Array([0, 0, 0, 0]));\n  } else if(colorEffect === \'none\') {\n \xa0 \xa0characteristic.writeValue(new Uint8Array([bright, ...color]));\n  } else {\n \xa0 \xa0const speed = speedMap[colorEffect];\n \xa0 \xa0effectCharacteristic.writeValue(new Uint8Array([\n \xa0 \xa0 \xa0bright, ...color,\n \xa0 \xa0 \xa0parseInt(colorEffect, 16), 0x00, speed, 0x00,\n \xa0  ]));\n  }\n}\n​\neffect.addEventListener(\'change\', ({target}) => {\n \xa0colorEffect = target.value;\n \xa0updateColorEffect();\n});\n​\npalette.addEventListener(\'change\', ({target}) => {\n \xa0color = parseColorString(target.value);\n \xa0updateColorEffect();\n});\n​\nbrightness.addEventListener(\'change\', ({target}) => {\n \xa0bright = parseInt(target.value);\n \xa0updateColorEffect();\n});\n​\nconnector.onclick = async () => {\n \xa0const device = await navigator.bluetooth.requestDevice({\n \xa0 \xa0filters: [{namePrefix: \'PLAYBULB\'}],\n \xa0 \xa0optionalServices: [0xff00, 0xff02, 0xff0f],\n  });\n​\n \xa0const server = await device.gatt.connect();\n​\n \xa0service = (await server.getPrimaryServices())[0];\n​\n \xa0characteristic = await service.getCharacteristic(0xfffc);\n \xa0effectCharacteristic = await service.getCharacteristic(0xfffb);\n​\n \xa0updateColorEffect();\n​\n \xa0switcher.onclick = async() => {\n \xa0 \xa0lightOn = !lightOn;\n \xa0 \xa0updateColorEffect();\n  };\n};\n<\/script>\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在上面的代码里，我们添加了",(0,r.jsx)(n.code,{children:"effect"}),"选择，通过",(0,r.jsx)(n.code,{children:"effectCharacteristic"}),"特性来控制设备的特效，它的 UUID 是",(0,r.jsx)(n.code,{children:"0xfffb"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["我在代码中调整了细节，现在灯有三种状态：关闭状态、开启状态和开启状态下的特效状态。我们通过",(0,r.jsx)(n.code,{children:"updateColorEffect"}),"函数来控制灯的状态，这个函数会根据当前的状态来决定写入设备的哪个特性，以及写入什么样的值。"]}),"\n",(0,r.jsxs)(n.p,{children:["在",(0,r.jsx)(n.code,{children:"effect"}),"选择的",(0,r.jsx)(n.code,{children:"change"}),"事件里，我们通过",(0,r.jsx)(n.code,{children:"speedMap"}),"对象来获取特效的速度，这里我们固定了特效的默认速度，然后将特效的速度和颜色数据写入设备。"]}),"\n",(0,r.jsx)(n.p,{children:"最终的效果如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"Mar-08-2023 00-17-51.gif"})}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在这节课中，我们通过实际操作一个智能 LED 灯学习了如何使用 Web Bluetooth API 控制蓝牙设备。"}),"\n",(0,r.jsx)(n.p,{children:"实际上 Web Bluetooth API 非常简单，上面的示例已经演示了足够多的功能，你可以通过这个 API 来控制任何支持 GATT 协议的低功耗蓝牙设备，只要你能找到设备的特性和特性的 UUID，你就可以用 JavaScript 来写程序让这些设备实现你的意图。"}),"\n",(0,r.jsx)(n.p,{children:"这一节课是动手实践的课程，只有自己写一遍代码才会理解更加深入。也许你看到这里的时候手边还没有一个合适的设备，为了后续的课程，我建议你入手一个类似的智能 LED 设备，这样能更好地体会和掌握这一节课以及后续课程的内容。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}let x=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F32%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BD%BF%E7%94%A8%20Web%20Bluetooth%20API%20%E6%93%8D%E4%BD%9C%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87.md"]={toc:[{text:"选择智能设备",id:"选择智能设备",depth:2},{text:"连接设备",id:"连接设备",depth:3},{text:"通过服务操作设备",id:"通过服务操作设备",depth:3},{text:"更加复杂的控制",id:"更加复杂的控制",depth:2},{text:"特殊效果",id:"特殊效果",depth:2},{text:"小结",id:"小结",depth:2}],title:"32 实战：使用 Web Bluetooth API 操作智能设备",headingTitle:"32 实战：使用 Web Bluetooth API 操作智能设备",frontmatter:{}}}}]);