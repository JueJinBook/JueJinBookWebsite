"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["19191"],{814486:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var t=s(552676),r=s(740453);let c=s.p+"static/image/6ad4b9036fcd83c7679cefc488cc8657.318fe447.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",img:"img",strong:"strong",pre:"pre",code:"code",ul:"ul",li:"li",ol:"ol"},(0,r.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"8基础篇常用自定义-hooks-开发",children:["8.基础篇｜常用自定义 Hooks 开发",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8基础篇常用自定义-hooks-开发",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在之前的小节中，我们已经完全掌握如何开发一个自定义 Hooks，以及相关的单元测试，接下来我们介绍一下在面试中、工作中常用的 Hooks，以此来帮助我们更好地了解 Hooks、完善 Hooks 的体系。"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"为了更好地展示自定义 Hooks，之后就不将 Hooks 效果代码展现出来了，但还是会贴张效果图，展示效果，如果好奇如何使用的代码，可以去 GitHub 上查看对应的代码。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"常用Hooks.png"})}),"\n",(0,t.jsxs)(n.h1,{id:"1-usedebouncefn",children:["1. useDebounceFn",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-usedebouncefn",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useDebounceFn"}),"：用来处理防抖函数的 Hooks，我们主要通过 ",(0,t.jsx)(n.a,{href:"https://www.lodashjs.com/",target:"_blank",rel:"noopener noreferrer",children:"Lodash"})," 来处理",(0,t.jsx)(n.a,{href:"https://www.lodashjs.com/docs/lodash.debounce",target:"_blank",rel:"noopener noreferrer",children:"防抖"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"确定出入参"}),"：参考 ",(0,t.jsx)(n.strong,{children:"Lodash"})," 中的防抖函数中的 ",(0,t.jsx)(n.strong,{children:"debounce"}),"。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:" `_.debounce(func, [wait=0], [options=])`\n"})}),"\n",(0,t.jsxs)(n.p,{children:["可以确定入参共有 5 个，分别是：",(0,t.jsx)(n.strong,{children:"func（防抖函数）"}),"、",(0,t.jsx)(n.strong,{children:"wait（超时时间/s）"}),"、",(0,t.jsx)(n.strong,{children:"leading（是否延迟开始前调用的函数）"}),"、",(0,t.jsx)(n.strong,{children:"trailing（是否在延迟开始后调用函数）"}),"、",(0,t.jsx)(n.strong,{children:"maxWait（最大等待时间）"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:["其中，",(0,t.jsx)(n.strong,{children:"func（防抖函数）"})," 是最主要的，所以把它单独拆开，其他的放在一起。"]}),"\n",(0,t.jsx)(n.p,{children:"出参：触发防抖的函数，官方提供的 cancel（取消延迟）和 flush（立即调用），这里只返回了触发防抖的函数即可。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"优化方案："})," 使用 useLatest 处理对应的 func，保持函数最新值，利用 useCreation 优化整个 debounce 即可，另外，需要 useUnmount 在卸载的时候调用 cancel 方法卸载组件。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"代码展示"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { useLatest, useUnmount, useCreation } from "..";\nimport debounce from "lodash/debounce";\n\ntype noop = (...args: any[]) => any;\n\ninterface DebounceOptions {\n  wait?: number;\n  leading?: boolean;\n  trailing?: boolean;\n  maxWait?: number;\n}\n\nconst useDebounceFn = <T extends noop>(fn: T, options?: DebounceOptions) => {\n  const fnRef = useLatest(fn);\n\n  const debounced = useCreation(\n    () =>\n      debounce(\n        (...args: Parameters<T>): ReturnType<T> => fnRef.current(...args),\n        options?.wait ?? 1000,\n        options\n      ),\n    []\n  );\n\n  useUnmount(() => {\n    debounced.cancel();\n  });\n\n  return debounced;\n};\n\nexport default useDebounceFn;\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"问：在 debounce 中使用 options?.wait ?? 1000 中的 ”??“ 是什么？"}),"\n"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["答：?? 是 ES11 的新语法：",(0,t.jsx)(n.strong,{children:"空值合并运算符"}),"，只会在左边的值严格等于\xa0null\xa0或\xa0undefined\xa0时起作用，一起来看看与 || 的区别："]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const a = 0\nconst b = a || 7 //b = 7\nconst c = a ?? 7 // c = 0\n"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"也就是说 ?? 可以处理值为 0 的情况，在这里我们如果用 || ，没有办法处理 wait 为 0 的情况，但实际上这种情况是存在，所以使用 ??。"}),"\n",(0,t.jsx)(n.p,{children:"有许多小伙伴可能觉得更新的新特点很多都是鸡肋，但实际上有些特性非常好，我们不管能否运用到，至少要知道，提升思维，是非常有必要的。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const run = useDebounceFn(\n    fn:(...args: any[]) => any,\n    options?: Options\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsxs)(n.h1,{id:"2-usedebounce",children:["2. useDebounce",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-usedebounce",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useDebounce"}),"：用来处理防抖值的 Hooks，既然学了处理函数的防抖，那么处理值的防抖就简单多了，我们只需要利用 useDebounceFn 即可。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"代码演示："})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { useDebounceFn, useSafeState, useCreation } from "..";\n\nimport type { DebounceOptions } from "../useDebounceFn";\n\nconst useDebounce = <T,>(value: T, options?: DebounceOptions) => {\n  const [debounced, setDebounced] = useSafeState(value);\n\n  const run = useDebounceFn(() => {\n    setDebounced(value);\n  }, options);\n\n  useCreation(() => {\n    run();\n  }, [value]);\n\n  return debounced;\n};\n\nexport default useDebounce;\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const debouncedValue = useDebounce(\n  value: any,\n  options?: Options\n);\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsxs)(n.h1,{id:"3-usethrottlefn",children:["3. useThrottleFn",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-usethrottlefn",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useThrottleFn"}),"：用来处理节流函数的 Hooks，同样的，我们使用 ",(0,t.jsx)(n.a,{href:"https://www.lodashjs.com/",target:"_blank",rel:"noopener noreferrer",children:"Lodash"})," 中的 ",(0,t.jsx)(n.a,{href:"https://www.lodashjs.com/docs/lodash.throttle",target:"_blank",rel:"noopener noreferrer",children:"节流"}),"来处理。"]}),"\n",(0,t.jsx)(n.p,{children:"节流与防抖基本一致，只不过缺少 maxWait（最大等待时间）字段，其余的都一样，所以代码就不过多赘述了，直接看看效果即可："}),"\n",(0,t.jsxs)(n.h1,{id:"4-usethrottle",children:["4. useThrottle",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-usethrottle",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useThrottle"}),"：用来处理节流值的 Hooks，跟 useDebounce 同理。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"效果"}),"："]}),"\n",(0,t.jsxs)(n.h1,{id:"5uselockfn",children:["5.useLockFn",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5uselockfn",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useLockFn"}),"：竞态锁，防止异步函数并发执行。"]}),"\n",(0,t.jsx)(n.p,{children:"我们在表单中或者各种按钮中，都需要与后端进行交互，这个钩子的作用是防止用户重复点击，重复调取接口（特别是订单的提交），所以这个钩子适用场景非常多，也很重要。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"确定出入参"}),"：入参应该是执行函数的效果，出参则是何时执行的函数。"]}),"\n",(0,t.jsx)(n.p,{children:"既然 useLockFn 是防止异步函数并发执行，那么我们所接受的 fn 必然返回 Promise 形式，同时，接口也会有各种各样的情况，必须通过 try catch 包一层。"}),"\n",(0,t.jsx)(n.p,{children:"那么我们只需要一个状态来判定是否执行对应的函数即可，由于处理的是函数，直接使用 useCallback 包裹即可。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"代码演示："})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import { useRef, useCallback } from "react";\n\nconst useLockFn = <P extends any[] = any[], V extends any = any>(\n  fn: (...args: P) => Promise<V>\n) => {\n  const lockRef = useRef(false);\n\n  return useCallback(\n    async (...args: P) => {\n      if (lockRef.current) return;\n      lockRef.current = true;\n      try {\n        const ret = await fn(...args);\n        lockRef.current = false;\n        return ret;\n      } catch (e) {\n        lockRef.current = false;\n        throw e;\n      }\n    },\n    [fn]\n  );\n};\n\nexport default useLockFn;\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const run = useLockFn<P extends any[] = any[], V extends any = any>(\n   fn: (...args: P) => Promise<V>\n): (...args: P) => Promise<V | undefined>\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"效果："})," 可配合 loading 处理按钮的效果。"]}),"\n",(0,t.jsxs)(n.h1,{id:"6-usefullscreen",children:["6. useFullscreen",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-usefullscreen",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useFullscreen"}),"：设置 DOM 元素是否全屏，有的时候，页面信息过多，我们希望去除无关的模块，更好展示所需的模块，就可以使用这个钩子。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"确定出入参"}),"：这里我们使用 ",(0,t.jsx)(n.a,{href:"https://github.com/sindresorhus/screenfull",target:"_blank",rel:"noopener noreferrer",children:"screenfull"})," 库进行封装。"]}),"\n",(0,t.jsx)(n.p,{children:"参数首先为：target（目标 DOM 元素），其次是进入全屏所触发的方法和退出全屏的方法。"}),"\n",(0,t.jsx)(n.p,{children:"返参提供：当前是否全屏的状态（ isFullscreen ），进入（ enterFullscreen ）/ 退出（ exitFullscreen ）触发的函数，以及是否可全屏的状态（ isEnabled ）即可。"}),"\n",(0,t.jsx)(n.p,{children:"优化手段使用：useLatest 和 useCallback 即可。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"getTarget"}),"：获取 DOM 目标。在 React 中，除了使用 document.getElementById 等，还可以通过 ",(0,t.jsx)(n.strong,{children:"useRef"})," 获取节点信息，所以我们做个兼容："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import type BasicTarget from "./BasicTarget";\ntype TargetType = HTMLElement | Element | Window | Document;\n\nconst getTarget = <T extends TargetType>(target: BasicTarget<T>) => {\n  let targetElement: any;\n\n  if (!target) {\n    targetElement = window;\n  } else if ("current" in target) {\n    targetElement = target.current;\n  } else {\n    targetElement = target;\n  }\n\n  return targetElement;\n};\nexport default getTarget;\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"代码展示："})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import screenfull from "screenfull";\nimport { useLatest, useSafeState } from "..";\nimport { getTarget } from "../utils";\nimport type { BasicTarget } from "../utils";\nimport { useCallback } from "react";\n\ninterface Options {\n  onEnter?: () => void;\n  onExit?: () => void;\n}\n\nconst useFullscreen = (target: BasicTarget, options?: Options) => {\n  const { onEnter, onExit } = options || {};\n\n  const [isFullscreen, setIsFullscreen] = useSafeState(false);\n\n  const onExitRef = useLatest(onExit);\n  const onEnterRef = useLatest(onEnter);\n\n  const onChange = () => {\n    if (screenfull.isEnabled) {\n      const ele = getTarget(target);\n      if (!screenfull.element) {\n        onExitRef.current?.();\n        setIsFullscreen(false);\n        screenfull.off("change", onChange);\n      } else {\n        const isFullscreen = screenfull.element === ele;\n        if (isFullscreen) {\n          onEnterRef.current?.();\n        } else {\n          onExitRef.current?.();\n        }\n        setIsFullscreen(isFullscreen);\n      }\n    }\n  };\n\n  const enterFullscreen = useCallback(() => {\n    const ele = getTarget(target);\n    if (!ele) return;\n    if (screenfull.isEnabled) {\n      screenfull.request(ele);\n      screenfull.on("change", onChange);\n    }\n  }, []);\n\n  const exitFullscreen = useCallback(() => {\n    const ele = getTarget(target);\n    if (screenfull.isEnabled && screenfull.element === ele) {\n      screenfull.exit();\n    }\n  }, []);\n\n  return {\n    isFullscreen,\n    isEnabled: screenfull.isEnabled,\n    enterFullscreen,\n    exitFullscreen,\n  };\n};\n\nexport default useFullscreen;\n'})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"注：这里要注意一点，有些浏览器在点击全屏后，背景会是黑色，而非白色，这是因为浏览器默认全屏没有背景色，所以是黑色，所以此时需要在整个项目下设置颜色，如："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"*:-webkit-full-screen { background: #fff; }"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const { \n    isFullscreen,\n    isEnabled,\n    enterFullscreen,\n    exitFullscreen } = useFullscreen(target, {\n       onEnter?: () => void,\n       onExit?: () => void\n    });\n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsxs)(n.h1,{id:"7-usecopy",children:["7. useCopy",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-usecopy",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useCopy"}),"：用于复制信息，在平常的开发中，为了用户操作方便，会设置复制按钮，将复制好的数据自动回传到选项的值，或是粘贴板，此时这个钩子就派上了用场。"]}),"\n",(0,t.jsxs)(n.p,{children:["使用：",(0,t.jsx)(n.a,{href:"https://github.com/sudodoki/copy-to-clipboard",target:"_blank",rel:"noopener noreferrer",children:"copy-to-clipboard 库"}),"。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"确定出入参"}),"：很明显，这个钩子并不需要入参，出参是复制后的文字，以及触发复制的方法。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"代码演示："})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'    import writeText from "copy-to-clipboard";\n    import { useSafeState } from "..";\n    import { useCallback } from "react";\n\n    type copyTextProps = string | undefined;\n    type CopyFn = (text: string) => void; // Return success\n\n    const useCopy = (): [copyTextProps, CopyFn] => {\n      const [copyText, setCopyText] = useSafeState<copyTextProps>(undefined);\n\n      const copy = useCallback((value?: string | number) => {\n        if (!value) return setCopyText("");\n        try {\n          writeText(value.toString());\n          setCopyText(value.toString());\n        } catch (err) {\n          setCopyText("");\n        }\n      }, []);\n\n      return [copyText, copy];\n    };\n\n    export default useCopy;\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"    const [copyText, copy] = useCopy();\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsxs)(n.h1,{id:"8-usetextselection",children:["8. useTextSelection",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-usetextselection",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useTextSelection"}),"：实时获取用户当前选取的文本内容及位置。当我们要实时获取用户所选择的文字、位置等，这个钩子会有很好的效果。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"确定出入参"}),"："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"入参："})," 选取文本的范围，可以是指定节点下的文字，当没有指定的节点，应该监听全局的，也就是 document。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"出参："})," 首先是选取的文字，以及文字距离屏幕的间距，除此之外，还有文字本身的宽度和高度。这里推荐使用 window.getSelection() 方法。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"getSelection()：表示用户选择的文本范围或光标的当前位置。"}),"\n",(0,t.jsx)(n.p,{children:"如果有值的话，getSelection() 返回的值进行 toString() 则是选取的值，否则为空。"}),"\n",(0,t.jsx)(n.p,{children:"然后使用 selection.getRangeAt(index) 来获取 Range 对象，主要包含选取文本的开始索引（startOffset）和结束索引（endOffset）。"}),"\n",(0,t.jsx)(n.p,{children:"最后通过 Range 的 getBoundingClientRect() 方法获取对应的宽、高、屏幕的距离等信息。"}),"\n",(0,t.jsx)(n.p,{children:"至于监听事件，我们可以利用 useEventListener 去监听对应的鼠标事件：mousedown（鼠标按下）、mouseup（鼠标松开）去完成。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"代码演示："})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import useEventListener from "../useEventListener";\nimport useSafeState from "../useSafeState";\nimport useLatest from "../useLatest";\nimport type { BasicTarget } from "../utils";\n\ninterface RectProps {\n  top: number;\n  left: number;\n  bottom: number;\n  right: number;\n  height: number;\n  width: number;\n}\n\ninterface StateProps extends RectProps {\n  text: string;\n}\n\nconst initRect: RectProps = {\n  top: NaN,\n  left: NaN,\n  bottom: NaN,\n  right: NaN,\n  height: NaN,\n  width: NaN,\n};\n\nconst initState: StateProps = {\n  text: "",\n  ...initRect,\n};\n\nconst getRectSelection = (selection: Selection | null): RectProps | {} => {\n  const range = selection?.getRangeAt(0);\n  if (range) {\n    const { height, width, top, left, right, bottom } =\n      range.getBoundingClientRect();\n    return { height, width, top, left, right, bottom };\n  }\n  return {};\n};\n\nconst useTextSelection = (\n  target: BasicTarget | Document = document\n): StateProps => {\n  const [state, setState] = useSafeState(initState);\n  const lastRef = useLatest(state);\n\n  useEventListener(\n    "mouseup",\n    () => {\n      if (!window.getSelection) return;\n      const select = window.getSelection();\n      const text = select?.toString() || "";\n      if (text) setState({ ...state, text, ...getRectSelection(select) });\n    },\n    target\n  );\n\n  useEventListener(\n    "mousedown",\n    () => {\n      if (!window.getSelection) return;\n      if (lastRef.current.text) setState({ ...initState });\n      const select = window.getSelection();\n      select?.removeAllRanges();\n    },\n    target\n  );\n\n  return state;\n};\n\nexport default useTextSelection;\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:" const state = useTextSelection(target?)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"除此之外，useTextSelection 可配合 Popover 做划词翻译的效果。"}),"\n"]}),"\n",(0,t.jsxs)(n.h1,{id:"9-useresponsive",children:["9. useResponsive",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#9-useresponsive",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useResponsive："})," 获取相应式信息，当屏幕尺寸发生改变时，返回的尺寸信息不同，换言之，useResponsive 可以获取浏览器窗口的响应式信息。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"确定出入参"}),"："]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"入参："})," 设定屏幕的尺寸范围，这里我们使用栅格布局（bootstrap）的范围，如："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"xs：0px，最小尺寸；"}),"\n",(0,t.jsx)(n.li,{children:"sm：576px，设备：平板；"}),"\n",(0,t.jsx)(n.li,{children:"md：768px，设备：桌面显示屏；"}),"\n",(0,t.jsx)(n.li,{children:"lg：992px，设备：大桌面显示器；"}),"\n",(0,t.jsx)(n.li,{children:"xl：1200px 超大屏幕显示器"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"出参："})," 尺寸范围是否符合条件，如果符合则为 true，否则为 false。"]}),"\n",(0,t.jsx)(n.p,{children:"但这里要注意下，我们默认的入参是栅格的范围，但在真实情况下，入参是允许改变，而出参根据入参的范围而来，所以我们并不知道 useResponsive 具体参数，但可以确定出入参的类型，所以我们需要 Record 的帮助。如："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// 入参\ntype ResponsiveConfig = Record<string, number>;\n\n// 出参\ntype ResponsiveInfo = Record<string, boolean>;\n"})}),"\n",(0,t.jsx)(n.p,{children:"解决了 ts 问题后，再来看看另一个问题，对于整个系统而言，所有的布局应该相同，如果把入参放入 useResponsive 中，那么每次调用 useResponsive 都要进行配置，那样会很麻烦，所以我们把入参提取出来，再额外封装个方法，用来设置 responsiveConfig。"}),"\n",(0,t.jsx)(n.p,{children:"最后，我们用 useEventListener 来监听尺寸即可。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"代码演示："})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import useSafeState from "../useSafeState";\nimport useEventListener from "../useEventListener";\nimport isBrowser from "../utils/isBrowser";\n\ntype ResponsiveConfig = Record<string, number>;\ntype ResponsiveInfo = Record<string, boolean>;\n\n// bootstrap 对应的四种尺寸\nlet responsiveConfig: ResponsiveConfig = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n};\n\nlet info: ResponsiveInfo = {};\n\nexport const configResponsive = (config: ResponsiveConfig) => {\n  responsiveConfig = config;\n};\n\nconst clac = () => {\n  const width = window.innerWidth;\n  const newInfo = {} as ResponsiveInfo;\n  let shouldUpdate = false;\n  for (const key of Object.keys(responsiveConfig)) {\n    newInfo[key] = width >= responsiveConfig[key];\n    // 如果发生改变，则出发更新\n    if (newInfo[key] !== info[key]) {\n      shouldUpdate = true;\n    }\n  }\n  if (shouldUpdate) {\n    info = newInfo;\n  }\n  return {\n    shouldUpdate,\n    info,\n  };\n};\n\nconst useResponsive = () => {\n  if (isBrowser) {\n    clac();\n  }\n\n  const [state, setState] = useSafeState<ResponsiveInfo>(() => clac().info);\n\n  useEventListener("resize", () => {\n    const res = clac();\n    if (res.shouldUpdate) setState(res.info);\n  });\n\n  return state;\n};\n\nexport default useResponsive;\n'})}),"\n",(0,t.jsx)(n.p,{children:"在这里我们简单做个处理，用 shouldUpdate 来判断是否更新 info，如果 newInfo 和 info 不等，则证明需要更新视图，防止视图不断刷新。"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:" // 配置\n configResponsive({\n   small: 0,\n   middle: 800,\n   large: 1200,\n });\n\n // 使用\n const responsive = useResponsive();\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsxs)(n.h1,{id:"10-usetrackedeffect",children:["10. useTrackedEffect",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10-usetrackedeffect",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"useTrackedEffect："})," 可监听 useEffect 中的 deps 中的那个发生变化，用法与 useEffect 基本一致。"]}),"\n",(0,t.jsx)(n.p,{children:"我们都知道， useEffect 可以监听 deps 的变化，而触发对应的函数，但如果变量值存在多个值时， useEffect 并无法监听是哪个 deps 发生了改变。"}),"\n",(0,t.jsxs)(n.p,{children:["如：useEffect 同时监听了 A 和 B，我们想要的效果是 A 改变触发对应的函数，B 改变触发对应的函数，A 和 B 共同触发一个函数，针对这种情况，使用  useEffect 就会变得很麻烦，而 useTrackedEffect 可以完美地解决这个问题，并且还会",(0,t.jsx)(n.strong,{children:"记录上次的值"}),"，方便我们更好地操作。"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"确定出入参"}),"：useTrackedEffect 的结构应该与 useEffect 的结构保持一致，所以并不存在出参，只需要涉及入参即可。"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"入参参数："})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"effect：对应 useEffect 的第一个参数，执行函数；"}),"\n",(0,t.jsx)(n.li,{children:"deps：对应 useEffect 的第二个参数，发生改变的函数依赖；"}),"\n",(0,t.jsx)(n.li,{children:"type_list：增加第三个参数，对应 deps 的名称，注意，要和 deps 一一对应，否则结果会有所差异。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"确定完入参，那么 useTrackedEffect 中的第一个参数 effect 应该返回哪些信息呢，一起来看看："}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"changes：改变对应 deps 的索引，通过索引去判断哪个 deps 发生改变；"}),"\n",(0,t.jsx)(n.li,{children:"previousDeps：上一次改变的 deps 值；"}),"\n",(0,t.jsx)(n.li,{children:"currentDeps：改变后的 deps 值；"}),"\n",(0,t.jsx)(n.li,{children:"type_changes：改变对应 deps 的索引，不过对应于中文，而非索引。"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"除此之外，我们需要记录上一次的值，需要利用 useRef 的特性来帮助我们完成。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"代码演示："})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'import type { DependencyList } from "react";\nimport { useEffect, useRef } from "react";\n\ntype Effect = (\n  changes?: number[], // 改变的 deps 参数\n  previousDeps?: DependencyList, // 上一次的 deps 集合\n  currentDeps?: DependencyList, // 本次最新的 deps 集合\n  type_changes?: string[] // 返回匹配的字段名\n) => void | (() => void);\n\n// 判断改变的effect\nconst onChangeEffect = (deps1?: DependencyList, deps2?: DependencyList) => {\n  if (deps1) {\n    return deps1\n      .map((_, index) =>\n        !Object.is(deps1[index], deps2?.[index]) ? index : -1\n      )\n      .filter((v) => v !== -1);\n  } else if (deps2) {\n    return deps2.map((_, index) => index);\n  } else return [];\n};\n\nconst useTrackedEffect = (\n  effect: Effect,\n  deps?: DependencyList,\n  type_list?: string[]\n) => {\n  const previousDepsRef = useRef<DependencyList>();\n\n  useEffect(() => {\n    const changes = onChangeEffect(previousDepsRef.current, deps);\n    const previousDeps = previousDepsRef.current;\n    previousDepsRef.current = deps;\n    const type_changes = (type_list || []).filter((_, index) =>\n      changes.includes(index)\n    );\n    return effect(changes, previousDeps, deps, type_changes);\n  }, deps);\n};\n\nexport default useTrackedEffect;\n'})}),"\n",(0,t.jsx)(n.p,{children:"这里有个关键点是：onChangeEffect 函数，用来判断哪一个 deps 发生改变，deps1 为旧的 deps， deps2 为新的 deps，但要注意，deps1 和 deps2 应该一一对应，总共分为三种情况。"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"dep1 不存在：第一次，改变的应该是 deps2，所以改动点为 deps2 的索引；"}),"\n",(0,t.jsx)(n.li,{children:"dep1 存在：说明存在旧值，然后依次比较 dep1 和 deps2 的值，如果不想等，则更新最新值的索引，想等的话，则返回 -1， 之后再整体过滤一遍不等于 -1 的值，所得到的就是更新的索引；"}),"\n",(0,t.jsx)(n.li,{children:"特别要注意，useEffect 存在为空数组的情况，说明 dep1 、dep2 都不存在。"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"使用方式"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"useTrackedEffect(\n  effect: (changes: [], previousDeps: [], currentDeps: [], type_changes: [) => (void | (() => void | undefined)),\n  deps?: deps,\n  type_list?: string[]\n)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"效果："})}),"\n",(0,t.jsx)(n.p,{children:"在入参的时候，多加入了一个 type_list，其实这个加不加并没有多大的必要，毕竟我们可以通过索引去判断，没有必要再多设置一个参数去维护。"}),"\n",(0,t.jsx)(n.p,{children:"假设我们不加入 type_list，但我获取的时候仍然想要字段，而不是索引，此时该如何做？"}),"\n",(0,t.jsx)(n.p,{children:"以上述的案例来说，我们可不可以这样更改："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:" useTrackedEffect(() => {           useTrackedEffect(() => {\n     ...                      =>     ...\n },[count, count1],                 },[{count}, {count1}], \n"})}),"\n",(0,t.jsx)(n.p,{children:"我们把 deps 变成对象，这样我们就可以拿到对应的名称和值，也不需要再去维护一个字段了。"}),"\n",(0,t.jsx)(n.p,{children:"实际上，这种方式确实可以，但这种方式却打破了 useEffect 常用的规则，因为 useTrackedEffect 本来就是 useEffect 的扩展，使用上应该尽量保持一致，对使用者来说并不友好。"}),"\n",(0,t.jsx)(n.p,{children:"其次，我们改变结构，也就意味着 useTrackedEffect 的内部也要将结构转化，而转化的目的仅仅是为了更好的区分，这种行为非常“多此一举”。所以这种行为的价值不大。"}),"\n",(0,t.jsxs)(n.h1,{id:"思考",children:["思考",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在 useTrackedEffect 中，我们谈及到将 deps 的数组结构改成对象结构，那么我们顺便思考一下，useEffect 中的 deps 每一项的类型是否有区别？也就是基本类型和引用类型的效果是否一样？举个例子："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"\nconst [count, setCount] = useState(0)\nconst [count1, setCount1] = useState([0])\n\n// 第一种\nuseEffect(() => {...}, [count])\n\n// 第二种\nuseEffect(() => {...}, [count1])\n\n// 执行\nsetCount(0)\nsetCount([0])\n"})}),"\n",(0,t.jsx)(n.p,{children:"当我们执行时就会发现第一个 useEffect 不会执行，但第二个 useEffect 还是会执行，其实原理非常简单，useTrackedEffect 的实现也给出了答案，感兴趣小伙伴可以自行思考下（在源码篇中进行详细讲解）。"}),"\n",(0,t.jsxs)(n.h1,{id:"小结",children:["小结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"本小节我们共学习了 10 个自定义 Hooks，这些 Hooks 都是在工作中常用的，希望各位小伙伴能够亲自去实现一遍，以此来更好地了解 Hooks。"}),"\n",(0,t.jsx)(n.p,{children:"同时，这也是我们基础篇的最后一篇，下节我们正式学习有关 Hooks 的源码，从根本上去知悉 Hooks，让它成为工作中得力助手！"})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F8.%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BD%9C%E5%B8%B8%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%20Hooks%20%E5%BC%80%E5%8F%91.md"]={toc:[],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);