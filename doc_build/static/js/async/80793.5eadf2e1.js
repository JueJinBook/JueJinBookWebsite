"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["80793"],{280696:function(n,e,t){t.r(e),t.d(e,{default:()=>u});var s=t(552676),r=t(740453);let o=t.p+"static/image/3df42ef26a3abca02be9a8ff6e7314f7.5cee2afb.webp",i=t.p+"static/image/a067127c39f9af19df54fe4bbb740a23.2b85e3f4.webp",a=t.p+"static/image/1a4cb0b9a8f8254f98131a8164ffa568.cd830c27.webp",c=t.p+"static/image/2752de09f0d482b245f30491a91b9c54.b39d138d.webp",d=t.p+"static/image/8cbe47c4febae2303f530d09b3fddf7d.16f03ee5.webp",l=t.p+"static/image/8892d47eeefd72a326b5f67231a96dc9.63a67a6d.webp",p=t.p+"static/image/c368462fe6e5ef8b2219ccdba4b88175.13555ad7.webp";function m(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",pre:"pre",code:"code",img:"img"},(0,r.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"14自定义组件_-如何实现一个动画弹窗组件",children:["14.自定义组件_ 如何实现一个动画弹窗组件？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#14自定义组件_-如何实现一个动画弹窗组件",children:"#"})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["仓库地址： ",(0,s.jsx)(e.a,{href:"https://github.com/czm1290433700/nextjs-demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/nextjs-demo"})]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"到现在我们已经学习了包括主题化、帧动画、多媒体适配、Strapi 进阶在内的知识，通过结合实际的业务需求场景，相信大家已经可以应对官网开发的大部分常见需求了。"}),"\n",(0,s.jsx)(e.p,{children:"通常在官网等项目开发中，都会使用组件库等来协助我们进行页面的静态开发，对于不符合业务场景的组件，我们可以使用样式覆盖的方式来为业务场景适配，比如前几节课我们使用的分页组件。但是这并不代表我们不再需要自己开发组件，针对需要自定义动画的组件，很难通过样式覆盖的方式去定义，这时候就需要我们自行开发。"}),"\n",(0,s.jsx)(e.p,{children:"弹窗组件就是这类组件中最典型的一种，因为不同的业务场景可能需要不同的渐入渐出动画，平常组件库的弹窗组件并不容易在原有基础上覆盖自定义动画。所以作为需求进阶篇的最后一节课，我们将来学习如何来开发一个自定义动画弹窗组件。"}),"\n",(0,s.jsxs)(e.h2,{id:"静态样式",children:["静态样式",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#静态样式",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"对于弹窗组件，很多同学的第一印象可能是它很容易，但是其中有不少的细节，我们这节课会更详细地讲解每行的代码和样式，同学们可以根据步骤和思路自己手写一下，然后对比和实际的方案有哪些不同。"}),"\n",(0,s.jsxs)(e.p,{children:["首先我们先来写一下弹窗组件的静态样式，与平常组件不同，弹窗组件至少需要暴露一个 open 方法给外部进行调用，所以我们需要用到 ",(0,s.jsx)(e.a,{href:"https://reactjs.org/docs/forwarding-refs.html",target:"_blank",rel:"noopener noreferrer",children:"forwardRef"}),"，它可以将 ref 中的方法暴露给外部进行相关的调用，例如 Semi 中我们常常使用的 form 组件就是通过这个来实现的。"]}),"\n",(0,s.jsx)(e.p,{children:"我们创建一个 popup组件，然后写一下它的静态样式，其中 IPopupRef 是弹窗暴露的 ref 类型，而 IProps 是组件本身的类型，useImperativeHandle 是组件 ref 暴露给外部调用的方法定义，暴露回去的回调方法类型需要和 ref 类型相同。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./components/popup/index.tsx\nimport React, {\n  forwardRef,\n  useState,\n  useImperativeHandle,\n} from "react";\nimport styles from "./styles.module.scss";\nimport cName from "classnames";\n\nexport interface IPopupRef {\n  open: () => void;\n}\n\ninterface IProps {\n  children: JSX.Element;\n}\n\nexport const Popup = forwardRef<IPopupRef, IProps>(({ children }, ref) => {\n  const [visible, setVisible] = useState(false);\n\n  useImperativeHandle(ref, () => ({\n    open: (): void => {\n      setVisible(true);\n    },\n  }));\n\n  const renderDom = visible ? (\n    <div\n      className={cName({\n        [styles.popup]: true,\n      })}\n    >\n      <div className={styles.mask} />\n      <div className={styles.popupContent}>\n        <div\n          className={styles.closeBtn}\n          onClick={(): void => {\n            setVisible(false);\n          }}\n        />\n        {children}\n      </div>\n    </div>\n  ) : (\n    <></>\n  );\n\n  return renderDom;\n});\n'})}),"\n",(0,s.jsx)(e.p,{children:"然后我们为它写一下静态的样式，相关的全局主题化变量我们也定义一下。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./components/popup/styles.module.scss\n@import "../../pages/media.scss";\n\n.popup {\n  width: 100%;\n  height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 10000;\n\n  .mask {\n    width: inherit;\n    height: inherit;\n    position: fixed;\n    background-color: #000;\n    opacity: 0.5;\n    top: 0;\n    left: 0;\n    z-index: 10;\n  }\n\n  .popupContent {\n    position: relative;\n    border-radius: 0.25rem;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    background-color: var(--popup-content-background-color);\n    z-index: 20;\n    min-width: 25rem;\n    min-height: 25rem;\n\n    .closeBtn {\n      width: 2.125rem;\n      height: 2.125rem;\n      background-color: inherit;\n      background-image: var(--popup-close-icon);\n      background-position: center;\n      background-size: 1rem 1rem;\n      background-repeat: no-repeat;\n      position: absolute;\n      top: 1.1875rem;\n      right: 1.1875rem;\n      cursor: pointer;\n      z-index: 100;\n    }\n\n    .closeBtn:hover {\n      background-color: var(--popup-close-hover-background-color);\n    }\n  }\n}\n\n@include media-mobile {\n  .popup {\n    .dialogContent {\n      .closeBtn {\n        width: 0.6875rem;\n        height: 0.6875rem;\n        top: 1.3125rem;\n        right: 0.875rem;\n      }\n    }\n  }\n}\n\n@include media-ipad {\n  .dialog {\n    .dialogContent {\n      .titleArea {\n        padding: 1.5rem 1.5625rem;\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./pages/global.scss\nhtml[data-theme="dark"] {\n  --popup-close-icon: url("../public/close.png");\n  --popup-close-hover-background-color: #353535;\n  --popup-content-background-color: #1f1f1f;\n}\n\nhtml[data-theme="light"] {\n  --popup-close-icon: url("../public/close_light.png");\n  --popup-close-hover-background-color: #f5f5f5;\n  --popup-content-background-color: #f4f5f5;\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"到这里基础样式就定义好了，我们可以在 navbar 加一个入口试试看。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./components/navbar/index.tsx\nimport { FC, useContext, useRef } from "react";\nimport styles from "./styles.module.scss";\nimport { ThemeContext } from "@/stores/theme";\nimport { UserAgentContext } from "@/stores/userAgent";\nimport { Themes, Environment } from "@/constants/enum";\nimport { Popup, IPopupRef } from "../popup";\n\nexport interface INavBarProps {}\n\nexport const NavBar: FC<INavBarProps> = ({}) => {\n  const { setTheme } = useContext(ThemeContext);\n  const { userAgent } = useContext(UserAgentContext);\n  const popupRef = useRef<IPopupRef>(null);\n\n  return (\n    <div className={styles.navBar}>\n      <a href="http://localhost:3000/">\n        <div className={styles.logoIcon}></div>\n      </a>\n      <div className={styles.themeArea}>\n        <div\n          className={styles.popupText}\n          onClick={(): void => {\n            popupRef.current?.open();\n          }}\n        >\n          弹窗示范\n        </div>\n        {userAgent === Environment.pc && (\n          <span className={styles.text}>当前是pc端样式</span>\n        )}\n        {userAgent === Environment.ipad && (\n          <span className={styles.text}>当前是Ipad端样式</span>\n        )}\n        {userAgent === Environment.mobile && (\n          <span className={styles.text}>当前是移动端样式</span>\n        )}\n        <div\n          className={styles.themeIcon}\n          onClick={(): void => {\n            if (localStorage.getItem("theme") === Themes.light) {\n              setTheme(Themes.dark);\n            } else {\n              setTheme(Themes.light);\n            }\n          }}\n        ></div>\n      </div>\n      <Popup ref={popupRef}>\n        <div>这是一个弹窗</div>\n      </Popup>\n    </div>\n  );\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:"我们来看看效果。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,s.jsxs)(e.h2,{id:"遮罩层的滚动穿透",children:["遮罩层的滚动穿透",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#遮罩层的滚动穿透",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"这时候存在一个问题，我们发现有遮罩层的时候，最外层仍然是可以滚动的，这个我们往往称作为滚动穿透的现象，其实也很好理解，最外层的区域（body) 仍然是可以产生滚动的，我们仅仅是给了 100vh 的遮罩层，所以并不能阻止滚动的产生。"}),"\n",(0,s.jsx)(e.p,{children:"解决方案也很简单，我们只需要在遮罩层的时候，在 body 手动加上一个类来限制它的高度即可 。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./components/popup/index.tsx\n// ...\nuseEffect(() => {\n    document.body.className = visible ? "forbidScroll" : "";\n  }, [visible]);\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"// ./pages/global.scss\n.forbidScroll {\n  height: 100vh;\n  overflow: hidden;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"现在可以发现已经不会再滚动了。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,s.jsxs)(e.h2,{id:"指定渲染位置",children:["指定渲染位置",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#指定渲染位置",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"同学们可以打开控制台的 Elements，通过选取元素选中我们的弹窗，可以看到渲染的位置是在对应组件调用的 dom 下的。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"这样其实会存在一个问题，因为被嵌套在别的dom 下， 包括样式、事件在内的很多情况，弹窗组件可能都会受到影响，通常作为一个通用的组件，我们是不希望弹窗的展现因为外界的情况而有所变化的，所以不应该把它渲染在父级区域下。"}),"\n",(0,s.jsx)(e.p,{children:"在 React 16，有提供一个 api， ReactDom.createPortal， 它提供了将子节点渲染到存在于父组件以外的 DOM 节点的能力，通过这个 api， 我们可以将我们的弹窗组件渲染到 body 下，这样就可以有效解决这个问题，因为需要使用到 BOM 的问题，所以需要进行判空，前面的课程我们也反复提及到了 SSR 的这个问题，大家注意一下。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./components/popup/index.tsx\n// ...\nreturn typeof document !== "undefined"\n    ? ReactDom.createPortal(renderDom, document.body)\n    : renderDom;\n'})}),"\n",(0,s.jsx)(e.p,{children:"现在我们再来看一下控制台，可以看到已经渲染到最外层了。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(e.h2,{id:"动画的实现",children:["动画的实现",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#动画的实现",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"现在大部分的功能我们都有了，到最关键的地方了，我们应该怎么为弹窗实现动画呢？渐入渐出的动画关键在于类的切换，在切换过程中，我们需要对下一个状态的类进行异步切换，因为 react state 是对最终结果进行切换的，这样没办法起到类型变化的效果。现在我们来实现这个效果，动画的效果我们就实现一个普通的渐入渐出就可以了。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./components/popup/index.tsx\nimport React, {\n  forwardRef,\n  useState,\n  useEffect,\n  useImperativeHandle,\n  useContext,\n  useMemo,\n} from "react";\nimport styles from "./styles.module.scss";\nimport ReactDom from "react-dom";\nimport { UserAgentContext } from "@/stores/userAgent";\nimport { Environment } from "@/constants/enum";\nimport cName from "classnames";\n\nexport interface IPopupRef {\n  open: () => void;\n}\n\ninterface IProps {\n  children: JSX.Element;\n}\n\nexport const Popup = forwardRef<IPopupRef, IProps>(({ children }, ref) => {\n  const [visible, setVisible] = useState(false);\n  const [enter, setEnter] = useState(false);\n  const [leave, setLeave] = useState(false);\n\n  useEffect(() => {\n    document.body.className = visible ? "forbidScroll" : ""\n    let timeout;\n    if (visible) {\n      setEnter(true);\n      timeout = setTimeout((): void => {\n        setEnter(false);\n      }, 300);\n    } else {\n      setLeave(true);\n      timeout = setTimeout((): void => {\n        setLeave(false);\n      }, 300);\n    }\n    return (): void => {\n      timeout = null;\n    };\n  }, [visible]);\n\n  useImperativeHandle(ref, () => ({\n    open: (): void => {\n      setEnter(true);\n      setVisible(true);\n      setTimeout((): void => {\n        setEnter(false);\n      }, 300);\n    },\n  }));\n\n  const renderDom = visible ? (\n    <div\n      className={cName({\n        [styles.popup]: true,\n        [styles.enter]: enter,\n        [styles.leave]: leave,\n      })}\n    >\n      <div className={styles.mask} />\n      <div className={styles.popupContent}>\n        <div\n          className={styles.closeBtn}\n          onClick={(): void => {\n            setLeave(true);\n            setTimeout((): void => {\n              setLeave(false);\n            }, 300);\n            setVisible(false);\n          }}\n        />\n        {children}\n      </div>\n    </div>\n  ) : (\n    <></>\n  );\n\n  return typeof document !== "undefined"\n    ? ReactDom.createPortal(renderDom, document.body)\n    : renderDom;\n});\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./components/popup/styles.module.scss\n@import "../../pages/media.scss";\n\n.popup {\n  width: 100%;\n  height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 10000;\n\n  .mask {\n    width: inherit;\n    height: inherit;\n    position: fixed;\n    background-color: #000;\n    opacity: 0.5;\n    top: 0;\n    left: 0;\n    z-index: 10;\n  }\n\n  .popupContent {\n    position: relative;\n    border-radius: 0.25rem;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    background-color: var(--popup-content-background-color);\n    z-index: 20;\n    min-width: 25rem;\n    min-height: 25rem;\n\n    .closeBtn {\n      width: 2.125rem;\n      height: 2.125rem;\n      background-color: inherit;\n      background-image: var(--popup-close-icon);\n      background-position: center;\n      background-size: 1rem 1rem;\n      background-repeat: no-repeat;\n      position: absolute;\n      top: 1.1875rem;\n      right: 1.1875rem;\n      cursor: pointer;\n      z-index: 100;\n    }\n\n    .closeBtn:hover {\n      background-color: var(--popup-close-hover-background-color);\n    }\n  }\n}\n\n.enter {\n  .mask {\n    animation: maskFadeIn 0.2s;\n  }\n\n  .popupContent {\n    animation: fadeIn 0.2s;\n  }\n}\n\n.leave {\n  .mask {\n    animation: maskFadeOut 0.2s;\n    opacity: 0;\n  }\n\n  .popupContent {\n    animation: fadeOut 0.2s;\n    transform: scale(0);\n  }\n}\n\n@keyframes fadeIn {\n  0% {\n    transform: scale(0);\n    opacity: 0;\n  }\n\n  100% {\n    transform: scale(1);\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  0% {\n    transform: scale(1);\n    opacity: 1;\n  }\n\n  100% {\n    transform: scale(0);\n    opacity: 0;\n  }\n}\n\n@keyframes maskFadeIn {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 0.5;\n  }\n}\n\n@keyframes maskFadeOut {\n  0% {\n    opacity: 0.5;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n\n@include media-mobile {\n  .popup {\n    .popupContent {\n      min-width: 18.75rem;\n      min-height: 18.75rem;\n      .closeBtn {\n        width: 0.6875rem;\n        height: 0.6875rem;\n        top: 1.3125rem;\n        right: 0.875rem;\n      }\n    }\n  }\n}\n\n@include media-ipad {\n  .popup {\n    .popupContent {\n      .titleArea {\n        padding: 1.5rem 1.5625rem;\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"我们来看看最终效果，可以看到已经可以了。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:"5790fa3a-cc4b-4d1c-b623-5e5fbf01089e.gif"})}),"\n",(0,s.jsxs)(e.h2,{id:"pc-端遮罩层滚动栏丢失问题的解决",children:["PC 端遮罩层滚动栏丢失问题的解决",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#pc-端遮罩层滚动栏丢失问题的解决",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"现在功能我们都已经实现了，但是还存在一个小问题，当我们弹窗的时候，滚动栏会消失，这就导致有个屏幕闪烁的效果，这个问题我们应该怎么解决呢？我们来参考一下京东 O2Lab 团队官网的方案。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:i,alt:"3360509d-920e-4ee7-bcd1-2cf2324547fb.gif"})}),"\n",(0,s.jsx)(e.p,{children:"可以看到，京东用了一个比较 hack 的方法，在弹窗的时候给右边腾出了一块区域来代替滚动栏，从而减少这部分视觉差，我们也来实现一下。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'// ./components/popup/index.tsx\nimport React, {\n  forwardRef,\n  useState,\n  useEffect,\n  useImperativeHandle,\n  useContext,\n  useMemo,\n} from "react";\nimport styles from "./styles.module.scss";\nimport ReactDom from "react-dom";\nimport { UserAgentContext } from "@/stores/userAgent";\nimport { Environment } from "@/constants/enum";\nimport cName from "classnames";\n\nexport interface IPopupRef {\n  open: () => void;\n}\n\ninterface IProps {\n  children: JSX.Element;\n}\n\nexport const Popup = forwardRef<IPopupRef, IProps>(({ children }, ref) => {\n  const [visible, setVisible] = useState(false);\n  const [enter, setEnter] = useState(false);\n  const [leave, setLeave] = useState(false);\n  const { userAgent } = useContext(UserAgentContext);\n\n  const maskClass = useMemo(() => {\n    return userAgent === Environment.mobile ? "forbidScroll" : "pcForbidScroll";\n  }, [userAgent]);\n\n  useEffect(() => {\n    document.body.className = visible ? maskClass : "";\n    let timeout;\n    if (visible) {\n      setEnter(true);\n      timeout = setTimeout((): void => {\n        setEnter(false);\n      }, 300);\n    } else {\n      setLeave(true);\n      timeout = setTimeout((): void => {\n        setLeave(false);\n      }, 300);\n    }\n    return (): void => {\n      timeout = null;\n    };\n  }, [visible]);\n\n  useImperativeHandle(ref, () => ({\n    open: (): void => {\n      setEnter(true);\n      setVisible(true);\n      setTimeout((): void => {\n        setEnter(false);\n      }, 300);\n    },\n  }));\n\n  const renderDom = visible ? (\n    <div\n      className={cName({\n        [styles.popup]: true,\n        [styles.enter]: enter,\n        [styles.leave]: leave,\n      })}\n    >\n      <div className={styles.mask} />\n      <div className={styles.popupContent}>\n        <div\n          className={styles.closeBtn}\n          onClick={(): void => {\n            setLeave(true);\n            setTimeout((): void => {\n              setLeave(false);\n            }, 300);\n            setVisible(false);\n          }}\n        />\n        {children}\n      </div>\n    </div>\n  ) : (\n    <></>\n  );\n\n  return typeof document !== "undefined"\n    ? ReactDom.createPortal(renderDom, document.body)\n    : renderDom;\n});\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"// ./pages/global.scss\n// 移动端遮罩层\n.forbidScroll {\n  height: 100vh;\n  overflow: hidden;\n}\n\n// pc端遮罩层\n.pcForbidScroll {\n  width: calc(100% - 1rem); // 滚动栏假区域\n  height: 100vh;\n  overflow: hidden;\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"这边区分了移动端和 PC 端的遮罩层，因为移动端的遮罩层默认的宽度是很窄的，所以我们不需要对它进行区域空格。现在我们来看一下效果，可以看到现在效果已经不错了。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:"3e12cadd-8a4d-4a62-b208-4b5df849e9f6.gif"})}),"\n",(0,s.jsxs)(e.h2,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"这节课是我们需求进阶篇的最后一节课，我们学习了怎么实现一个自定义的动画组件，除了基本的样式，我们还学习了什么是滚动穿透，通过增加全局类的方式解决了这个问题。"}),"\n",(0,s.jsx)(e.p,{children:"同时作为一个通用组件，弹窗组件往往不随父组件位置渲染，在 body 下渲染可以避免父级区域样式和事件的污染。至于动画的实现，渐入渐出我们采用类切换的方式，因为 react state 最后统一切换的关系，我们采用异步来切换最后一个状态类，达到动画的效果。"}),"\n",(0,s.jsxs)(e.p,{children:["最后我们还遇到一个 PC 端遮罩层滚动栏丢失的问题，我们参考了京东的方案，为弹窗状态下的类空出了一部分区域，来解决弹窗时候视差的问题，不过，其实除了这个方案，还有更好的实现方式，京东的方案还是很 hack 的，不过这边我们卖个关子，在",(0,s.jsx)(e.a,{href:"https://juejin.cn/book/7137945369635192836/section/7141557501173956619",target:"_blank",rel:"noopener noreferrer",children:"16 | 设备兼容：IOS 300ms delay & 橡皮筋问题解决方案"})," 我们再来学习这个方案，这个在兼容 IOS 相关问题时，会一并优化~"]}),"\n",(0,s.jsx)(e.p,{children:"C 端站点中常常会用到一些大图，大图的资源请求时间长，站区域面积较大，在低网速情况下，请求时间过长，会导致页面长时间大区域留白，从下一节课开始，我们将开始性能优化篇的学习，我们来一起探讨一下如何针对大图低网速加载场景进行首屏优化。"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(m,{...n})}):m(n)}let u=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["SSR%20%E5%AE%9E%E6%88%98%EF%BC%9A%E5%AE%98%E7%BD%91%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F14.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6_%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%A8%E7%94%BB%E5%BC%B9%E7%AA%97%E7%BB%84%E4%BB%B6%EF%BC%9F.md"]={toc:[{text:"静态样式",id:"静态样式",depth:2},{text:"遮罩层的滚动穿透",id:"遮罩层的滚动穿透",depth:2},{text:"指定渲染位置",id:"指定渲染位置",depth:2},{text:"动画的实现",id:"动画的实现",depth:2},{text:"PC 端遮罩层滚动栏丢失问题的解决",id:"pc-端遮罩层滚动栏丢失问题的解决",depth:2},{text:"小结",id:"小结",depth:2}],title:"14.自定义组件_ 如何实现一个动画弹窗组件？",headingTitle:"14.自定义组件_ 如何实现一个动画弹窗组件？",frontmatter:{}}}}]);