"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["80118"],{310143:function(e,n,r){r.r(n),r.d(n,{default:()=>j});var s=r(552676),t=r(740453);let c=r.p+"static/image/e47f1c1536c47dcf98ee8d511db85d4c.05d0838d.webp",d=r.p+"static/image/5dfb7f73a412c97d53b12e3d5edef928.c41dcf37.webp",i=r.p+"static/image/3f57bc21b841ad54f068a06c1c7ba2a9.dfd7db37.webp",a=r.p+"static/image/74d32eeabe6c35360500ae5e97aefbfb.92efe1b8.webp",o=r.p+"static/image/6c7399e41afee0cedf1663edc81ce020.de710244.webp",l=r.p+"static/image/eaba4ca92a29245f1b854e8bd9c4c920.b8571a6f.webp",p=r.p+"static/image/459c6c1690e5c41110bb35373ed2ad71.cc5a4960.webp",h=r.p+"static/image/fc4dfa2169eb7bfef84b5eb282d763b1.a72cc2a1.webp";function u(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",h3:"h3",img:"img",ul:"ul",li:"li",code:"code",h4:"h4",pre:"pre",blockquote:"blockquote"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"23生态篇-react-redux",children:["23.生态篇-React-redux",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23生态篇-react-redux",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["状态管理是单页面应用解决组件状态共享，复杂组件通信的技术方案。接下来的两个章节，我们将详细介绍 React 应用中常见的两种状态管理方式- ",(0,s.jsx)(n.strong,{children:"React-Redux"})," 和 ",(0,s.jsx)(n.strong,{children:"React-Mobx"})," 。"]}),"\n",(0,s.jsx)(n.p,{children:"本章节主要讲 React-Redux，包括Redux 设计思想、中间件原理，以及 React-Redux 的用法和原理。"}),"\n",(0,s.jsxs)(n.h3,{id:"1-状态管理应用场景",children:["1 状态管理应用场景",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-状态管理应用场景",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"状态管理工具为什么受到开发者的欢迎呢？我认为首先应该想想状态管理适用于什么场景。解决了什么问题。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"① 组件之间共用数据，如何处理?"})}),"\n",(0,s.jsx)(n.p,{children:"设想一种场景，就是一些通过 ajax 向服务器请求的重要数据，比如用户信息，权限列表，可能会被多个组件需要，那么如果每个组件初始化都请求一遍数据显然是不合理的。这时候常用的一种解决方案是，应用初始化时候，只请求一次数据，然后通过状态管理把数据存起来，需要数据的组件只需要从状态管理中‘拿’就可以了。"}),"\n",(0,s.jsx)(n.p,{children:"效果图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"3.jpg"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"② 复杂组件之间如何通信？"})}),"\n",(0,s.jsx)(n.p,{children:"还有一种场景就是对于 spa 单页面应用一切皆组件，对于嵌套比较深的组件，组件通信成了一个棘手的问题。比如如下的场景， B 组件向 H 组件传递某些信息，那么常规的通信方式似乎难以实现。"}),"\n",(0,s.jsx)(n.p,{children:"这个时候状态管理就派上用场了，可以把 B 组件的信息传递给状态管理层，H 组件连接状态管理层，再由状态管理层通知 H 组件，这样就本质解决了组件通信问题。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"4.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-react-reduxreduxreact三者关系",children:["2 React-Redux,Redux,React三者关系",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-react-reduxreduxreact三者关系",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在深入研究 React-Redux 之前，应该先弄明白 React-Redux ，Redux ， React 三者到底是什么关系。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Redux"}),"： 首先 Redux 是一个应用状态管理js库，它本身和 React 是没有关系的，换句话说，Redux 可以应用于其他框架构建的前端应用，甚至也可以应用于 Vue 中。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"React-Redux"}),"：React-Redux 是连接 React 应用和 Redux 状态管理的桥梁。React-redux 主要专注两件事，一是如何向 React 应用中注入 redux 中的 Store ，二是如何根据 Store 的改变，把消息派发给应用中需要状态的每一个组件。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"React"}),"：这个就不必多说了。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"三者的关系图如下所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"3.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-温习-redux",children:["3 温习 Redux",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-温习-redux",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"彻底弄明白 React-Redux 之前，就必须要搞懂 Redux 在 React 中扮演的角色。Redux 的设计满足以下三个原则："}),"\n",(0,s.jsxs)(n.h4,{id:"三大原则",children:["①三大原则",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三大原则",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"1 单向数据流：整个 redux ，数据流向都是单向的，我用一张官网的图片描述整个数据流动的流程。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"redux.gif"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"2 state 只读：在 Redux 中不能通过直接改变 state ，来让状态发生变化，如果想要改变 state ，那就必须触发一次 action ，通过 action 执行每个 reducer 。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"3 纯函数执行：每一个 reducer 都是一个纯函数，里面不要执行任何副作用，返回的值作为新的 state ，state 改变会触发 store 中的 subscribe 。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"发布订阅思想",children:["②发布订阅思想",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布订阅思想",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"redux 可以作为发布订阅模式的一个具体实现。redux 都会创建一个 store ，里面保存了状态信息，改变 store 的方法 dispatch ，以及订阅 store 变化的方法 subscribe 。"}),"\n",(0,s.jsxs)(n.h4,{id:"中间件思想",children:["③中间件思想",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#中间件思想",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["redux 应用了前端领域为数不多的中间件 ",(0,s.jsx)(n.code,{children:"compose"})," ，那么 redux 的中间件是用来做什么的？ 答案只有一个： 那就是",(0,s.jsx)(n.strong,{children:"强化 dispatch"})," ， Redux 提供了中间件机制，使用者可以根据需要来强化 dispatch 函数，传统的 dispatch 是不支持异步的，但是可以针对 Redux 做强化，于是有了 ",(0,s.jsx)(n.code,{children:"redux-thunk"}),"，",(0,s.jsx)(n.code,{children:"redux-actions"})," 等中间件，包括 dvajs 中，也写了一个 redux 支持 promise 的中间件。"]}),"\n",(0,s.jsx)(n.p,{children:"一起来看一下 compose 是如何实现的："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const compose = (...funcs) => {\n  return funcs.reduce((f, g) => (x) => f(g(x)));\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"funcs 为中间件组成的数组，compose 通过数组的 reduce 方法，实现执行每一个中间件，强化 dispatch 。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"核心api",children:["④核心api",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#核心api",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"对于内部原理，我这里就不多说了，毕竟这节主要讲的是 React-Redux ，主要先来看一下 redux 几个比较核心的 api:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"createStore"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"createStore"})," redux中通过 createStore 可以创建一个 Store ，使用者可以将这个 Store 保存传递给 React 应用，具体怎么传递那就是 React-Redux 做的事了。首先看一下 createStore 的使用："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const Store = createStore(rootReducer,initialState,middleware)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"参数一 reducers ： redux 的 reducer ，如果有多个那么可以调用 combineReducers 合并。"}),"\n",(0,s.jsx)(n.li,{children:"参数二 initialState ：初始化的 state 。"}),"\n",(0,s.jsx)(n.li,{children:"参数三 middleware ：如果有中间件，那么存放 redux 中间件。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"combineReducers"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/* 将 number 和 PersonalInfo 两个reducer合并   */\nconst rootReducer = combineReducers({ number:numberReducer,info:InfoReducer })\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"正常状态可以会有多个 reducer ，combineReducers 可以合并多个reducer。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"applyMiddleware"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const middleware = applyMiddleware(logMiddleware)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"applyMiddleware 用于注册中间件，支持多个参数，每一个参数都是一个中间件。每次触发 action ，中间件依次执行。"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"-实战-redux基本用法",children:["⑤ 实战-redux基本用法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#-实战-redux基本用法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第一步：编写reducer"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/* number Reducer */\nfunction numberReducer(state=1,action){\n  switch (action.type){\n    case 'ADD':\n      return state + 1\n    case 'DEL':\n      return state - 1\n    default:\n      return state\n  } \n}\n/* 用户信息reducer */\nfunction InfoReducer(state={},action){\n  const { payload = {} } = action\n   switch (action.type){\n     case 'SET':\n       return {\n         ...state,\n         ...payload\n       }\n     default:\n       return state\n   }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"编写了两个 reducer ，一个管理变量 number ，一个保存信息 info 。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第二步：注册中间件"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/* 打印中间件 */\n/* 第一层在 compose 中被执行 */\nfunction logMiddleware(){\n    /* 第二层在reduce中被执行 */ \n    return (next) => {\n      /* 返回增强后的dispatch */\n      return (action)=>{\n        const { type } = action\n        console.log('发生一次action:', type )\n        return next(action)\n      }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"在重点看一下 redux 的中间件的编写方式，本质上应用了函数柯里化。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第三步：生成Store"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/* 注册中间件  */\nconst rootMiddleware = applyMiddleware(logMiddleware)\n/* 注册reducer */\nconst rootReducer = combineReducers({ number:numberReducer,info:InfoReducer  })\n/* 合成Store */\nconst Store = createStore(rootReducer,{ number:1 , info:{ name:null } } ,rootMiddleware) \n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"这一步没什么好说的，直接注册就可以了。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"第四步：试用redux"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function Index(){\n  const [ state , changeState  ] = useState(Store.getState())\n  useEffect(()=>{\n    /* 订阅state */\n    const unSubscribe = Store.subscribe(()=>{\n         changeState(Store.getState())\n     })\n    /* 解除订阅 */\n     return () => unSubscribe()\n  },[])\n  return <div > \n          <p>  { state.info.name ? `hello, my name is ${ state.info.name}` : 'what is your name' } ,\n           { state.info.mes ? state.info.mes  : ' what do you say? '  } </p>\n         《React进阶实践指南》 { state.number } \uD83D\uDC4D <br/>\n        <button onClick={()=>{ Store.dispatch({ type:'ADD' })  }} >点赞</button>\n        <button onClick={()=>{ Store.dispatch({ type:'SET',payload:{ name:'alien' , mes:'let us learn React!'  } }) }} >修改标题</button>\n     </div>\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"为了让大家直观看到效果，可以直接把 redux 和 react 直接结合起来使用，在 useEffect 中进行订阅和解除订阅，通过 useState 改变视图层。"}),"\n",(0,s.jsx)(n.li,{children:"store.getState 可以获取 redux 最新的 state 。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"1.gif"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"总结："})}),"\n",(0,s.jsx)(n.p,{children:"上述demo中，没有用到 react-redux ，但是明显暴露了很多问题。我来做一下总结："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1 首先想要的状态是共用的，上述 demo 无法满足状态共用的情况。"}),"\n",(0,s.jsx)(n.li,{children:"2 正常情况不可能将每一个需要状态的组件都用 subscribe / unSubscribe 来进行订阅"}),"\n",(0,s.jsx)(n.li,{children:"3 比如 A 组件需要状态 a，B 组件需要状态 b ，那么改变 a，只希望 A 组件更新，不希望 B 组件更新，显然上述是不能满足的。"}),"\n",(0,s.jsx)(n.li,{children:"4 ..."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"所以为了解决上述诸多问题，react-redux 就应运而生了。"}),"\n",(0,s.jsxs)(n.h2,{id:"二-react-redux用法",children:["二 React-Redux用法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二-react-redux用法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上述讲到 React-Redux 是沟通 React 和 Redux 的桥梁，它主要功能体现在如下两个方面："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1 接受 Redux 的 Store，并把它合理分配到所需要的组件中。"}),"\n",(0,s.jsx)(n.li,{children:"2 订阅 Store 中 state 的改变，促使消费对应的 state 的组件更新。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-用法简介",children:["1 用法简介",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-用法简介",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"provider",children:["Provider",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#provider",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"由于 redux 数据层，可能被很多组件消费，所以 react-redux 中提供了一个 Provider 组件，可以全局注入 redux 中的 store ，所以使用者需要把 Provider 注册到根部组件中。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provider 作用就是保存 redux 中的 store ，分配给所有需要 state 的子孙组件。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"例子\uD83C\uDF30："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default function Root(){\n  return <Provider store={Store} >\n      <Index />\n  </Provider>\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"connect",children:["connect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#connect",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"既然已经全局注入了 Store ，那么需要 Store 中的状态或者想要改变Store的状态，那么如何处理呢，React-Redux 提供了一个高阶组件connect，被 connect 包装后组件将获得如下功能："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1 能够从 props 中获取改变 state 的方法 Store.dispatch 。"}),"\n",(0,s.jsx)(n.li,{children:"2 如果 connect 有第一个参数，那么会将 redux state 中的数据，映射到当前组件的 props 中，子组件可以使用消费。"}),"\n",(0,s.jsx)(n.li,{children:"3 当需要的 state ，有变化的时候，会通知当前组件更新，重新渲染视图。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"开发者可以利用 connect 提供的功能，做数据获取，数据通信，状态派发等操作。首先来看看 connect 用法。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"①mapStateToProps"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const mapStateToProps = state => ({ number: state.number })\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"组件依赖 redux 的 state，映射到业务组件的 props 中，state 改变触发，业务组件 props 改变，触发业务组件更新视图。当这个参数没有的时候，当前组件不会订阅 store 的改变。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"②mapDispatchToProps"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const mapDispatchToProps = dispatch => {\n  return {\n    numberAdd: () => dispatch({ type: 'ADD' }),\n    setInfo: () => dispatch({ type: 'SET' }),\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"将 redux 中的 dispatch 方法，映射到业务组件的 props 中。比如将如上 demo 中的两个方法映射到 props ，变成了 numberAdd ， setInfo 方法。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"③mergeProps"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/*\n* stateProps , state 映射到 props 中的内容\n* dispatchProps， dispatch 映射到 props 中的内容。\n* ownProps 组件本身的 props\n*/\n(stateProps, dispatchProps, ownProps) => Object\n"})}),"\n",(0,s.jsx)(n.p,{children:"正常情况下，如果没有这个参数，会按照如下方式进行合并，返回的对象可以是，可以自定义的合并规则，还可以附加一些属性。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{ ...ownProps, ...stateProps, ...dispatchProps }\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"④options"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"{\n  context?: Object,   // 自定义上下文\n  pure?: boolean, // 默认为 true , 当为 true 的时候 ，除了 mapStateToProps 和 props ,其他输入或者state 改变，均不会更新组件。\n  areStatesEqual?: Function, // 当pure true , 比较引进store 中state值 是否和之前相等。 (next: Object, prev: Object) => boolean\n  areOwnPropsEqual?: Function, // 当pure true , 比较 props 值, 是否和之前相等。 (next: Object, prev: Object) => boolean\n  areStatePropsEqual?: Function, // 当pure true , 比较 mapStateToProps 后的值 是否和之前相等。  (next: Object, prev: Object) => boolean\n  areMergedPropsEqual?: Function, // 当 pure 为 true 时， 比较 经过 mergeProps 合并后的值 ， 是否与之前等  (next: Object, prev: Object) => boolean\n  forwardRef?: boolean, //当为true 时候,可以通过ref 获取被connect包裹的组件实例。\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如上标注了 options 属性每一个的含义。并且讲解了 react-redux 的基本用法，接下来简单实现 react-redux 的两个功能。"}),"\n",(0,s.jsxs)(n.h3,{id:"2-实践一react-redux实现状态共享",children:["2 实践一：React-Redux实现状态共享",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-实践一react-redux实现状态共享",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default function Root(){\n  React.useEffect(()=>{\n    Store.dispatch({ type:'ADD'})\n    Store.dispatch({ type:'SET',payload:{ name:'alien' , mes:'let us learn React!'  } })\n  },[])\n  return <Provider store={Store} >\n      <Index />\n  </Provider>\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"通过在根组件中注入 store ，并在 useEffect 中改变 state 内容。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"然后在整个应用中在想要获取数据的组件里，获取 state 中的内容。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { connect } from 'react-redux'\n\n\nclass Index extends React.Component {\n    componentDidMount() { }\n    render() {\n         const { info , number }:any = this.props  \n        return <div >\n            <p>  {info.name ? `hello, my name is ${info.name}` : 'what is your name'} ,\n          {info.mes ? info.mes : ' what do you say? '} </p>\n        《React进阶实践指南》 {number} \uD83D\uDC4D <br />\n        </div>\n    }\n}\n\nconst mapStateToProps = state => ({ number: state.number, info: state.info })\n\nexport default connect(mapStateToProps)(Index)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"通过 mapStateToProps 获取指定 state 中的内容，然后渲染视图。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:"5.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"3-实践二react-redux实现组件通信",children:["3 实践二：React-Redux实现组件通信",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-实践二react-redux实现组件通信",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来可以用 React-Redux 模拟一个，组件通信的场景。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"组件A"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function ComponentA({ toCompB, compBsay }) { /* 组件A */\n  const [CompAsay, setCompAsay] = useState('')\n  return <div className=\"box\" >\n    <p>我是组件A</p>\n    <div> B组件对我说：{compBsay} </div>\n        我对B组件说：<input placeholder=\"CompAsay\" onChange={(e) => setCompAsay(e.target.value)} />\n    <button onClick={() => toCompB(CompAsay)} >确定</button>\n  </div>\n}\n/* 映射state中CompBsay  */\nconst CompAMapStateToProps = state => ({ compBsay: state.info.compBsay })\n/* 映射toCompB方法到props中 */\nconst CompAmapDispatchToProps = dispatch => ({ toCompB: (mes) => dispatch({ type: 'SET', payload: { compAsay: mes } }) })\n/* connect包装组件A */\nexport const CompA = connect(CompAMapStateToProps, CompAmapDispatchToProps)(ComponentA)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"组件 A 通过 mapStateToProps，mapDispatchToProps，分别将state 中的 compBsay 属性，和改变 state 的 compAsay 方法，映射到 props 中。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"组件B"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class ComponentB extends React.Component { /* B组件 */\n  state={ compBsay:'' }\n  handleToA=()=>{\n     this.props.dispatch({ type: 'SET', payload: { compBsay: this.state.compBsay } })\n  }\n  render() {\n    return <div className=\"box\" >\n      <p>我是组件B</p>\n      <div> A组件对我说：{ this.props.compAsay } </div>\n       我对A组件说：<input placeholder=\"CompBsay\" onChange={(e)=> this.setState({ compBsay: e.target.value  }) }  />\n      <button  onClick={ this.handleToA } >确定</button>\n    </div>\n  }\n}\n/* 映射state中 CompAsay  */\nconst CompBMapStateToProps = state => ({ compAsay: state.info.compAsay })\nexport const CompB =  connect(CompBMapStateToProps)(ComponentB)\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"B 组件和 A 组件差不多，通过触发 dispatch 向组件 A 传递信息，同时接受 B 组件的信息。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"效果："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"2.gif"})}),"\n",(0,s.jsxs)(n.h2,{id:"三-react-redux原理",children:["三 React-Redux原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-react-redux原理",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"对于 React-Redux 原理，我按照功能组成，大致分为三部分，接下来将按照这三部分逐一击破："}),"\n",(0,s.jsxs)(n.h3,{id:"第一部分-provider注入store",children:["第一部分： Provider注入Store",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第一部分-provider注入store",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-redux/src/components/Provider.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const ReactReduxContext =  React.createContext(null)\nfunction Provider({ store, context, children }) {\n   /* 利用useMemo，跟据store变化创建出一个contextValue 包含一个根元素订阅器和当前store  */ \n  const contextValue = useMemo(() => {\n      /* 创建了一个根级 Subscription 订阅器 */\n    const subscription = new Subscription(store)\n    return {\n      store,\n      subscription\n    } /* store 改变创建新的contextValue */\n  }, [store])\n  useEffect(() => {\n    const { subscription } = contextValue\n    /* 触发trySubscribe方法执行，创建listens */\n    subscription.trySubscribe() // 发起订阅\n    return () => {\n      subscription.tryUnsubscribe()  // 卸载订阅\n    } \n  }, [contextValue])  /*  contextValue state 改变出发新的 effect */\n  const Context = ReactReduxContext\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里保留了核心的代码。从这段代码，从中可以分析出 Provider 做了哪些事。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"1 首先知道 React-Redux 是通过 context 上下文来保存传递 Store 的，但是上下文 value 保存的除了 Store 还有 subscription 。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"2 subscription 可以理解为订阅器，在 React-redux 中一方面用来订阅来自 state 变化，另一方面通知对应的组件更新。在 Provider 中的订阅器 subscription 为根订阅器，"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"3 在 Provider 的 useEffect 中，进行真正的绑定订阅功能，其原理内部调用了 store.subscribe ，只有根订阅器才会触发store.subscribe，至于为什么，马上就会讲到。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"第二部分-subscription订阅器",children:["第二部分： Subscription订阅器",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第二部分-subscription订阅器",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-redux/src/utils/Subscription.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/* 发布订阅者模式 */\nexport default class Subscription {\n  constructor(store, parentSub) {\n  //....\n  }\n  /* 负责检测是否该组件订阅，然后添加订阅者也就是listener */\n  addNestedSub(listener) {\n    this.trySubscribe()\n    return this.listeners.subscribe(listener)\n  }\n  /* 向listeners发布通知 */\n  notifyNestedSubs() {\n    this.listeners.notify()\n  }\n  /* 开启订阅模式 首先判断当前订阅器有没有父级订阅器 ， 如果有父级订阅器(就是父级Subscription)，把自己的handleChangeWrapper放入到监听者链表中 */\n  trySubscribe() {\n    /*\n    parentSub  即是provide value 里面的 Subscription 这里可以理解为 父级元素的 Subscription\n    */\n    if (!this.unsubscribe) {\n      this.unsubscribe = this.parentSub\n        ? this.parentSub.addNestedSub(this.handleChangeWrapper)\n        /* provider的Subscription是不存在parentSub，所以此时trySubscribe 就会调用 store.subscribe   */\n        : this.store.subscribe(this.handleChangeWrapper)\n      this.listeners = createListenerCollection()\n    }\n  }\n  /* 取消订阅 */\n  tryUnsubscribe() {\n     //....\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["整个订阅器的核心，我浓缩提炼成8个字：",(0,s.jsx)(n.strong,{children:"层层订阅，上订下发"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"层层订阅"}),"：React-Redux 采用了层层订阅的思想，上述内容讲到 Provider 里面有一个 Subscription ，提前透露一下，每一个用 connect 包装的组件，内部也有一个 Subscription ，而且这些订阅器一层层建立起关联，Provider中的订阅器是最根部的订阅器，可以通过 trySubscribe 和 addNestedSub 方法可以看到。还有一个注意的点就是，如果父组件是一个 connect ，子孙组件也有 connect ，那么父子 connect 的 Subscription 也会建立起父子关系。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"上订下发"}),"：在调用 trySubscribe 的时候，能够看到订阅器会和上一级的订阅器通过 addNestedSub 建立起关联，当 store 中 state 发生改变，会触发 store.subscribe ，但是只会通知给 Provider 中的根Subscription，根 Subscription 也不会直接派发更新，而是会下发给子代订阅器（ connect 中的 Subscription ），再由子代订阅器，决定是否更新组件，层层下发。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"｜--------问与答--------｜"}),"\n问：为什么 React-Redux 会采用 subscription 订阅器进行订阅，而不是直接采用 store.subscribe 呢 ？"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"1 首先 state 的改变，Provider 是不能直接下发更新的，如果下发更新，那么这个更新是整个应用层级上的，还有一点，如果需要 state 的组件，做一些性能优化的策略，那么该更新的组件不会被更新，不该更新的组件反而会更新了。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"2 父 Subscription -> 子 Subscription 这种模式，可以逐层管理 connect 的状态派发，不会因为 state 的改变而导致更新的混乱。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"｜--------END--------｜"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"层层订阅模型："})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"6.jpg"})}),"\n",(0,s.jsxs)(n.h3,{id:"第三部分-connect控制更新",children:["第三部分： connect控制更新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第三部分-connect控制更新",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"由于connect中的代码过于复杂，我这里只保留核心的流程，而且对代码进行简化处理。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-redux/src/components/connectAdvanced.js"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function connect(mapStateToProps,mapDispatchToProps){\n    const Context = ReactReduxContext\n    /* WrappedComponent 为connect 包裹的组件本身  */   \n    return function wrapWithConnect(WrappedComponent){\n        function createChildSelector(store) {\n          /* 选择器  合并函数 mergeprops */\n          return selectorFactory(store.dispatch, { mapStateToProps,mapDispatchToProps })\n        }\n        /* 负责更新组件的容器 */\n        function ConnectFunction(props){\n          /* 获取 context内容 里面含有 redux中store 和父级subscription */\n          const contextValue = useContext(ContextToUse)\n          /* 创建子选择器,用于提取state中的状态和dispatch映射，合并到props中 */\n          const childPropsSelector = createChildSelector(contextValue.store)\n          const [subscription, notifyNestedSubs] = useMemo(() => {\n            /* 创建一个子代Subscription，并和父级subscription建立起关系 */\n            const subscription = new Subscription(\n              store,\n              didStoreComeFromProps ? null : contextValue.subscription // 父级subscription，通过这个和父级订阅器建立起关联。\n            )\n             return [subscription, subscription.notifyNestedSubs]\n            }, [store, didStoreComeFromProps, contextValue])\n            \n            /* 合成的真正的props */\n            const actualChildProps = childPropsSelector(store.getState(), wrapperProps)\n            const lastChildProps = useRef()\n            /* 更新函数 */\n            const [ forceUpdate, ] = useState(0)\n            useEffect(()=>{\n                const checkForUpdates =()=>{\n                   newChildProps = childPropsSelector()\n                  if (newChildProps === lastChildProps.current) { \n                      /* 订阅的state没有发生变化，那么该组件不需要更新，通知子代订阅器 */\n                      notifyNestedSubs() \n                  }else{\n                     /* 这个才是真正的触发组件更新的函数 */\n                     forceUpdate(state=>state+1)\n                     lastChildProps.current = newChildProps /* 保存上一次的props */\n                  }\n                }\n                subscription.onStateChange = checkForUpdates\n                //开启订阅者 ，当前是被connect 包转的情况 会把 当前的 checkForceUpdate 放在存入 父元素的addNestedSub中 ，一点点向上级传递 最后传到 provide \n                subscription.trySubscribe()\n                /* 先检查一遍，反正初始化state就变了 */\n                checkForUpdates()\n            },[store, subscription, childPropsSelector])\n\n             /* 利用 Provider 特性逐层传递新的 subscription */\n            return  <ContextToUse.Provider value={{  ...contextValue, subscription}}>\n                 <WrappedComponent  {...actualChildProps}  />\n            </ContextToUse.Provider>  \n          }\n          /* memo 优化处理 */\n          const Connect = React.memo(ConnectFunction) \n        return hoistStatics(Connect, WrappedComponent)  /* 继承静态属性 */\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"connect 的逻辑还是比较复杂的，我总结一下核心流程。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"1  connect 中有一个 selector 的概念，selector 有什么用？就是通过 mapStateToProps ，mapDispatchToProps ，把 redux 中 state 状态合并到 props 中，得到最新的 props 。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"2 上述讲到过，每一个 connect 都会产生一个新的 Subscription ，和父级订阅器建立起关联，这样父级会触发子代的 Subscription 来实现逐层的状态派发。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"3 有一点很重要，就是 Subscription 通知的是 checkForUpdates 函数，checkForUpdates 会形成新的 props ，与之前缓存的 props 进行浅比较，如果不想等，那么说明 state 已经变化了，直接触发一个useReducer 来更新组件，上述代码片段中，我用 useState 代替 useReducer 了，如果相等，那么当前组件不需要更新，直接通知子代 Subscription ，检查子代 Subscription 是否更新，完成整个流程。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"四-实现异步",children:["四 实现异步",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-实现异步",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["基于 redux 异步的库有很多，最简单的 ",(0,s.jsx)(n.code,{children:"redux-thunk"})," ，代码量少，只有几行，其中大量的逻辑需要开发者实现，还有比较复杂的 ",(0,s.jsx)(n.code,{children:"redux-saga"})," ，基于 ",(0,s.jsx)(n.code,{children:"generator"})," 实现，用起来稍微繁琐。"]}),"\n",(0,s.jsxs)(n.p,{children:["对于完整的状态管理生态，大家可以尝试一下 ",(0,s.jsx)(n.code,{children:"dvajs"})," ，它是基于 redux-saga 基础上，实现的异步的状态管理工具。dvajs 处理 reducers 也比较精妙，感兴趣的同学可以研究一下。"]}),"\n",(0,s.jsxs)(n.h2,{id:"五-总结",children:["五 总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过本章节的学习，应该已经掌握一下内容："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"1 Redux 的基本概念和常用 API 。"}),"\n",(0,s.jsx)(n.li,{children:"2 react-redux 基本用法，以及两种常用场景的实践 demo 。"}),"\n",(0,s.jsx)(n.li,{children:"3 react-redux 原理实现。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"下一节将学习 React 状态管理的另外一种方式 Mobx 。"})]})}function x(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F23.%E7%94%9F%E6%80%81%E7%AF%87-React-redux.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"1 状态管理应用场景",id:"1-状态管理应用场景",depth:3},{text:"2 React-Redux,Redux,React三者关系",id:"2-react-reduxreduxreact三者关系",depth:3},{text:"3 温习 Redux",id:"3-温习-redux",depth:3},{text:"①三大原则",id:"三大原则",depth:4},{text:"②发布订阅思想",id:"发布订阅思想",depth:4},{text:"③中间件思想",id:"中间件思想",depth:4},{text:"④核心api",id:"核心api",depth:4},{text:"⑤ 实战-redux基本用法",id:"-实战-redux基本用法",depth:4},{text:"二 React-Redux用法",id:"二-react-redux用法",depth:2},{text:"1 用法简介",id:"1-用法简介",depth:3},{text:"Provider",id:"provider",depth:4},{text:"connect",id:"connect",depth:4},{text:"2 实践一：React-Redux实现状态共享",id:"2-实践一react-redux实现状态共享",depth:3},{text:"3 实践二：React-Redux实现组件通信",id:"3-实践二react-redux实现组件通信",depth:3},{text:"三 React-Redux原理",id:"三-react-redux原理",depth:2},{text:"第一部分： Provider注入Store",id:"第一部分-provider注入store",depth:3},{text:"第二部分： Subscription订阅器",id:"第二部分-subscription订阅器",depth:3},{text:"第三部分： connect控制更新",id:"第三部分-connect控制更新",depth:3},{text:"四 实现异步",id:"四-实现异步",depth:2},{text:"五 总结",id:"五-总结",depth:2}],title:"23.生态篇-React-redux",headingTitle:"23.生态篇-React-redux",frontmatter:{}}}}]);