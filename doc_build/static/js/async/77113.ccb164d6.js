"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["77113"],{557301:function(e,n,c){c.r(n),c.d(n,{default:()=>I});var i=c(552676),d=c(740453);let s=c.p+"static/image/4de2db8b84fc66200aeec3fbbe2f08c2.1d14ecc1.webp",r=c.p+"static/image/d01d173fdfdfc2deaa086c30618b2a94.afea1e6e.webp",l=c.p+"static/image/4af0e759da8cc8b7217a960f25a6826a.3ff4c42d.webp",h=c.p+"static/image/ba246e64edcc314ed976a7a4c02d629e.0d2dbf06.webp",o=c.p+"static/image/51b7a1b0fe229c8c121e071f83564095.dc0352c7.webp",x=c.p+"static/image/52dc90bad58aa58e2a6acb2e715e5741.765aac4c.webp",a=c.p+"static/image/6bbe7cc776bcdf930e005551fe2ce0fa.fcc222cd.webp",j=c.p+"static/image/d76c19f8e6af09d8fdd047e3153f6208.fcf2f998.webp",t=c.p+"static/image/6d9e6b3e5ef21d3779c3c486fa99e1cf.962dc2a4.webp",p=c.p+"static/image/b5e0ceefefb41e566e293e93a13a329f.74bce229.webp",m=c.p+"static/image/49240f916d821dc8b8a5748577566428.a55ddd3d.webp",f=c.p+"static/image/3b4e66e644376d577009e9e5324034a1.04fbce56.webp",g=c.p+"static/image/8672daf13854ec849814dc4e8d28bfe7.ee9640a2.webp",b=c.p+"static/image/65e2d9e73ee02279c4e9b222ed7b3525.7460a98f.webp",v=c.p+"static/image/e07cb360af7dbd337781af78a91dc414.b0141056.webp",u=c.p+"static/image/41f2e1ee7d76b78cb9f44493979a98df.740143f2.webp",w=c.p+"static/image/4e6f2ce2259888cdbec76426bab45aa3.dd955d5e.webp",S=c.p+"static/image/de02740f86379d3557b96b4848c5ab0c.1153b050.webp",C=c.p+"static/image/6a3e4c6d6250b819b796fb4f872b0e81.2a253a59.webp",A=c.p+"static/image/51abde7d225f4421ba602713e5ebc345.b73dccc2.webp",z=c.p+"static/image/d6f774c7b97be64b4c448e01a80f524a.d5364749.webp",q=c.p+"static/image/367400cb047a3dc66d43ae10dc848cd1.088c0791.webp",M=c.p+"static/image/ad544190a8ac2b6d2fe3dfd2ce691cd5.ffe5eef5.webp",L=c.p+"static/image/8e17ae6d8e02bdf8e9aa7a43c81b59e1.59c706d1.webp",k=c.p+"static/image/39aa745c68119545ca14865b3975b8c1.fc7755fa.webp",Y=c.p+"static/image/1c7043e27ad22e8e6f3949b7e0c47292.f9f9c78f.webp",N=c.p+"static/image/098496e9d04c7ad617978256375d710b.4e17f341.webp",F=c.p+"static/image/1a5434b97e607d1789b55b82873826dd.71d1aac9.webp",E=c.p+"static/image/9dcb0e70f1ae2b00b0e9ba8f2b5af2f7.4f5f8841.webp",B=c.p+"static/image/6dc7ca40bf100ab6570fb21d787da9da.8a5b2398.webp",y=c.p+"static/image/cc67e4c7a83569b1d7d5cdd5d8461d21.46bfb14e.webp",Q=c.p+"static/image/34390f3576f5ddce7e4c6d2520b6cfd1.63319020.webp",J=c.p+"static/image/38024c77f5173cb6ca400136a64f79e0.05004ca3.webp",O=c.p+"static/image/a18e34ba08675c4771093ded172c8323.fd268899.webp",P=c.p+"static/image/33577dfe21c504b5b7a3d37018c977b0.a3c0d6d0.webp",U=c.p+"static/image/2bfacbc7d3bffe1c4eaa460b9457b9f7.629891db.webp",W=c.p+"static/image/7b6b011250261a7029c807e2c4f5c011.717e64f2.webp",T=c.p+"static/image/e4d54a84c33e7ee936d4be924720294b.cf03ef96.webp";function D(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",strong:"strong",ul:"ul",li:"li",img:"img",blockquote:"blockquote",pre:"pre",h3:"h3"},(0,d.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"第26章现代css中的相对单位",children:["第26章—现代CSS中的相对单位",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第26章现代css中的相对单位",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["\uFEFF时至今日，CSS 中已经有五十多种不同类型的单位，而且这个数量可能还会增加，其中有很多单位是相对的。例如我们熟悉的 ",(0,i.jsx)(n.code,{children:"em"})," 、",(0,i.jsx)(n.code,{children:"rem"})," 、",(0,i.jsx)(n.code,{children:"vw"})," 和 ",(0,i.jsx)(n.code,{children:"vh"})," 等单位都是相对单位。在 Web 开发的过程中，使用相对单位对于 Web 开发者而言是有益的。尤其是我们在构建一个响应式 Web 应用或网站时，它们显得更为灵活和有益。换句话说，作为 Web 开发人员，我们应该用动态的方法构建 Web 的布局。"]}),"\n",(0,i.jsx)(n.p,{children:"在这节课中，我们主要一起来探讨 CSS 单位中的相对单位。我们将从这节课中了解到 CSS 的相对单位有哪些，我们又是如何通过 CSS 相对单位来调整组件的大小。"}),"\n",(0,i.jsxs)(n.h2,{id:"相对单位简介",children:["相对单位简介",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#相对单位简介",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在 CSS 中，单位类型主要有两种：绝对单位和相对单位。它们又分别称为绝对长度单位和相对长度单位。其中相对长度单位是相对于其他一些东西，比如父元素的字体大小，或者浏览器视窗的大小，或者元素容器的大小。简单地说，相对长度单位是相对于另一个长度的长度。"}),"\n",(0,i.jsx)(n.p,{children:"使用相对单位的好处是，经过一些仔细的规划，你可以使用文本或其他元素的大小与页面上的其他内容相对应。即可以更容易地从一个输出环境扩展到另一个输出环境。"}),"\n",(0,i.jsxs)(n.p,{children:["到目前为止，CSS 相对长度单位主要分为",(0,i.jsx)(n.strong,{children:"字体相对长度单位"}),"、",(0,i.jsx)(n.strong,{children:"视窗相对长度单位"}),"和",(0,i.jsx)(n.strong,{children:"容器查询相对长度单位"}),"三种："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"字体相对长度单位"}),"：指的是使用它们的元素（用于本地字体相对长度）或根元素（用于根字体相对长度）的字体度量"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"视窗相对长度单位"}),"：相对于浏览器视窗的尺寸的长度，例如 ",(0,i.jsx)(n.code,{children:"vw"})," 和 ",(0,i.jsx)(n.code,{children:"vh"})," 等"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"容器查询相对长度单位"}),"：相对于查询容器的尺寸的长度，例如 ",(0,i.jsx)(n.code,{children:"cqw"})," 和 ",(0,i.jsx)(n.code,{children:"cqh"})," 等"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:T,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["下面这个示例向你展示了所有相对长度单位运用于 ",(0,i.jsx)(n.code,{children:"font-size"})," 的效果："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:W,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/JjerJyM",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/JjerJyM"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"css-视窗单位",children:["CSS 视窗单位",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-视窗单位",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"CSS 视窗单位已经存在很多年了，随着时间的推移，越来越多的 Web 开发者在项目中使用它们。它们的好处在于Web 开发者不需要依赖任何 JavaScript 脚本，就可以相对于浏览器视窗尺寸来设置元素的大小，而且这个大小是动态的，会随着浏览器视窗大小自动调整。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:U,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["最早在 CSS 中，只有四个视窗单位，即 ",(0,i.jsx)(n.code,{children:"vw"})," 、",(0,i.jsx)(n.code,{children:"vh"})," 、",(0,i.jsx)(n.code,{children:"vmin"})," 和 ",(0,i.jsx)(n.code,{children:"vmax"})," :"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"vw"})})," ：表示根元素（",(0,i.jsx)(n.code,{children:"html"}),"）宽度的百分比，",(0,i.jsx)(n.code,{children:"1vw"})," 等于浏览器视窗宽度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"vh"})})," ：表示根元素（",(0,i.jsx)(n.code,{children:"html"}),"）高度的百分比，",(0,i.jsx)(n.code,{children:"1vh"})," 等于浏览器视窗高度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"vmin"})})," ：表示浏览器视窗宽度和高度的最小值，如果浏览器视窗宽度大于其高度，则该值将根据浏览器视窗的高度计算，反之则根据浏览器视窗宽度计算。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"vmax"})})," ：表示浏览器视窗宽度和高度的最大值，如果浏览器视窗宽度大于其高度，则该值将根据浏览器视窗的宽度计算，反之则根据浏览器视窗高度计算"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"它们的大小都和浏览器视窗的宽高有着直接关系，例如："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0width: 50vw; \n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["代码中的 ",(0,i.jsx)(n.code,{children:"50vw"})," 相当于 ",(0,i.jsx)(n.code,{children:"html"})," 元素宽度的 ",(0,i.jsx)(n.code,{children:"50%"})," ，也相当于浏览器视窗宽度的 ",(0,i.jsx)(n.code,{children:"50%"})," 。假设浏览器视窗宽度是 ",(0,i.jsx)(n.code,{children:"1200px"})," ，那么 ",(0,i.jsx)(n.code,{children:"50vw"})," 则等于 ",(0,i.jsx)(n.code,{children:"600px"})," ："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:P,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["如果你给元素的高度设置为 ",(0,i.jsx)(n.code,{children:"50vh"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0height: 50vh;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["那么元素的高度相当于根元素 ",(0,i.jsx)(n.code,{children:"html"})," 高度的 ",(0,i.jsx)(n.code,{children:"50%"})," ，也相当于浏览器视窗高度的 ",(0,i.jsx)(n.code,{children:"50%"})," 。假设浏览器视窗高度是 ",(0,i.jsx)(n.code,{children:"768px"})," ，那么 ",(0,i.jsx)(n.code,{children:"50vh"})," 则等于 ",(0,i.jsx)(n.code,{children:"384px"})," ："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:O,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"vmin"})," 和 ",(0,i.jsx)(n.code,{children:"vmax"})," 与 ",(0,i.jsx)(n.code,{children:"vw"})," 和 ",(0,i.jsx)(n.code,{children:"vh"})," 略有不同，其中："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"vmin"})," 等于 ",(0,i.jsx)(n.code,{children:"vw"})," 或 ",(0,i.jsx)(n.code,{children:"vh"})," 中较小一个"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"vmax"})," 等于 ",(0,i.jsx)(n.code,{children:"vw"})," 或 ",(0,i.jsx)(n.code,{children:"vh"})," 中较大一个"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["假设你给一个元素设置了宽度为 ",(0,i.jsx)(n.code,{children:"10vmin"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0width: 10vmin;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["当浏览器视窗宽度小于高度时（例如移动手机竖屏模式时），则 ",(0,i.jsx)(n.code,{children:"1vmin"})," 等于视窗宽度的 ",(0,i.jsx)(n.code,{children:"1%"})," ；当浏览器视窗宽度大于高度时（例如移动手机横屏模式时），则 ",(0,i.jsx)(n.code,{children:"1vmin"})," 等于视窗高度的 ",(0,i.jsx)(n.code,{children:"1%"})," ："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:J,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"vmax"})," 和 ",(0,i.jsx)(n.code,{children:"vmin"})," 刚好相反。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0width: 10vmax;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["当浏览器视窗宽度大于高度时（例如移动手机横屏模式时），则 ",(0,i.jsx)(n.code,{children:"1vmax"})," 等于视窗宽度的 ",(0,i.jsx)(n.code,{children:"1%"})," ；当浏览器视窗宽度小于高度时（例如移动手机竖屏模式时），则 ",(0,i.jsx)(n.code,{children:"1vmax"})," 等于视窗高度的 ",(0,i.jsx)(n.code,{children:"1%"})," ："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:Q,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"你可以尝试在下面示例中调整视窗单位："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/MWzEqJO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/MWzEqJO"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["随着 CSS 逻辑属性的出现，视窗单位新增了 ",(0,i.jsx)(n.code,{children:"vi"})," 和 ",(0,i.jsx)(n.code,{children:"vb"})," ："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"vi"})})," ：指浏览器视窗内联轴尺寸（",(0,i.jsx)(n.code,{children:"inline-size"}),"）的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"vb"})})," ：指浏览器视窗块轴尺寸（",(0,i.jsx)(n.code,{children:"block-size"}),"）的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["有了视窗单位之后，我们可以使用 ",(0,i.jsx)(n.code,{children:"100vw"})," 和 ",(0,i.jsx)(n.code,{children:"100vh"})," 就轻易实现和浏览器视窗一样的尺寸大小，而且还能自动随着浏览器尺寸变化而变化："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".element {\n \xa0 \xa0width: 100vw;\n \xa0 \xa0height: 100vh;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:y,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/qBQPMjg",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/qBQPMjg"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["事实上，Web 开发人员今天面临一个常见的问题，那就是准确和一致的全视窗大小。比如上面这个全屏的示例，它在某些情况之下并不是全屏的。即使我们设置了元素的高度为 ",(0,i.jsx)(n.code,{children:"100vh"})," ，希望元素高度和浏览器视窗高度相等（",(0,i.jsx)(n.code,{children:"100%"})," 的浏览器视窗高度），但 ",(0,i.jsx)(n.code,{children:"vh"})," 单位并没有考虑到移动设备上的导航条收缩等因素，所以在垂直方向会出现滚动条。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:B,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["过去，大多是使用 ",(0,i.jsx)(n.a,{href:"https://www.bram.us/2016/09/12/making-viewport-units-work-properly-in-mobile-safari/",target:"_blank",rel:"noopener noreferrer",children:"Viewport Units Buggyfill"})," 或 ",(0,i.jsx)(n.a,{href:"https://css-tricks.com/the-trick-to-viewport-units-on-mobile/",target:"_blank",rel:"noopener noreferrer",children:"@Louis Hoebregts 的 CSS 自定义属性 Hack "}),"来修复此行为。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-JavaScript",children:"const setVh = () => {\n \xa0 \xa0const vh = window.innerHeight * 0.01;\n \xa0 \xa0document.documentElement.style.setProperty('--vh', `${vh}px`);\n};\n​\nwindow.addEventListener('load', setVh);\nwindow.addEventListener('resize', setVh);\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0height: 100vh;\n \xa0 \xa0height: calc(var(--vh, 1vh) * 100);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["我很高兴看到 ",(0,i.jsx)(n.a,{href:"https://twitter.com/AllThingsSmitty/status/1254151507412496384",target:"_blank",rel:"noopener noreferrer",children:"@Matt Smith 最近找到了一种使用 CSS 让 Mobile Safari 将元素设置为 100vh 的方法"}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"body {\n \xa0 \xa0height: 100vh;\n}\n​\n@supports (-webkit-touch-callout: none) {\n \xa0 \xa0body {\n \xa0 \xa0 \xa0 \xa0height: -webkit-fill-available;\n \xa0  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["但这不是最佳的方案，因为使用 ",(0,i.jsx)(n.code,{children:"-webkit-fill-available"})," 仅适用于实现 ",(0,i.jsx)(n.code,{children:"100vh"}),"。例如，如果你想要实现完美的 ",(0,i.jsx)(n.code,{children:"50vh"}),"，",(0,i.jsx)(n.code,{children:"-webkit-fill-available"})," 将无法使用在 ",(0,i.jsx)(n.code,{children:"calc()"})," 中。例如 ",(0,i.jsx)(n.code,{children:"height:calc(-webkit-fill-available * 0.5)"})," 就是无效的 CSS。即使有一天允许这样做，如果目标元素在 DOM 树的深层嵌套中，并且其中一个父元素已经设置了高度，则它将无效。"]}),"\n",(0,i.jsxs)(n.p,{children:["同样的，设置 ",(0,i.jsx)(n.code,{children:"100vw"})," 同样会存在类似的问题。如果你是 Mac OS 用户，当使用 ",(0,i.jsx)(n.code,{children:"100vw"})," 设置元素宽度与浏览器视窗宽度相等时，效果可能会很好，因为垂直滚动条默认是隐藏的。结果，滚动条宽度被添加到总宽度中。"]}),"\n",(0,i.jsxs)(n.p,{children:["但是，在 Windows 机器上，你会发现页面出现水平滚动条，因为滚动条的宽度被添加到宽度中。例如上面示例，设置了元素 ",(0,i.jsx)(n.code,{children:".element"})," 的宽度（",(0,i.jsx)(n.code,{children:"width"}),"）为 ",(0,i.jsx)(n.code,{children:"100vw"})," 。此时，在窗口中，",(0,i.jsx)(n.code,{children:".element"})," 的计算宽度为 ",(0,i.jsx)(n.code,{children:"100vw + 8.5px"})," ，其中 ",(0,i.jsx)(n.code,{children:"8.5px"})," 是垂直滚动条的宽度。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:E,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"因此，我们需要新的视窗单位来避免这些现象。庆幸的是，CSS 工作组指定了视窗的各种状态："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"大视窗（Large Viewport）"})," ：假设任何 UA 接口都是收缩的，例如浏览器工具栏、标签栏和地址栏都是不可见的状态"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"小视窗（Small Viewport）"})," ：假设任何 UA 接口都是扩展的，例如浏览器工具栏、标签栏和地址栏都是可见的状态"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:F,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["在 CSS 中使用 ",(0,i.jsx)(n.code,{children:"lv"})," 前缀来定义大视窗的单位，其包含了 ",(0,i.jsx)(n.code,{children:"lvw"})," 、",(0,i.jsx)(n.code,{children:"lvh"})," 、",(0,i.jsx)(n.code,{children:"lvi"})," 、",(0,i.jsx)(n.code,{children:"lvb"})," 、",(0,i.jsx)(n.code,{children:"lvmin"})," 和 ",(0,i.jsx)(n.code,{children:"lvmax"})," 等单位。另外使用 ",(0,i.jsx)(n.code,{children:"sv"})," 前缀来定义小视窗的单位，其包含了 ",(0,i.jsx)(n.code,{children:"svw"})," 、",(0,i.jsx)(n.code,{children:"svh"})," 、",(0,i.jsx)(n.code,{children:"svi"})," 、",(0,i.jsx)(n.code,{children:"svb"})," 、",(0,i.jsx)(n.code,{children:"svmin"})," 和 ",(0,i.jsx)(n.code,{children:"svmax"})," 等单位。"]}),"\n",(0,i.jsxs)(n.p,{children:["它们的定义和 ",(0,i.jsx)(n.code,{children:"vw"})," 、",(0,i.jsx)(n.code,{children:"vh"})," 、",(0,i.jsx)(n.code,{children:"vi"})," 、",(0,i.jsx)(n.code,{children:"vb"})," 、",(0,i.jsx)(n.code,{children:"vmin"})," 和 ",(0,i.jsx)(n.code,{children:"vmax"})," 是相似的："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lvw"})," 等于浏览器视窗大尺寸的宽度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lvh"})," 等于浏览器视窗大尺寸的高度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lvi"})," 等于浏览器视窗大尺寸的内联轴尺寸（",(0,i.jsx)(n.code,{children:"inline-size"}),"）的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lvb"})," 等于浏览器视窗大尺寸的块轴尺寸（",(0,i.jsx)(n.code,{children:"block-size"}),"）的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lvmin"})," 等于浏览器视窗大尺寸的宽度或高度中的较小值，即 ",(0,i.jsx)(n.code,{children:"lvw"})," 或 ",(0,i.jsx)(n.code,{children:"lvh"})," 较小的那个值"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"lvmax"})," 等于浏览器视窗大尺寸的宽度或高度中的较大值，即 ",(0,i.jsx)(n.code,{children:"lvw"})," 或 ",(0,i.jsx)(n.code,{children:"lvh"})," 较大的那个值"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"svw"})," 等于浏览器视窗小尺寸的宽度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"svh"})," 等于浏览器视窗小尺寸的高度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"svi"})," 等于浏览器视窗小尺寸内联轴尺寸（",(0,i.jsx)(n.code,{children:"inline-size"}),"）的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"svb"})," 等于浏览器视窗小尺寸块轴尺寸（",(0,i.jsx)(n.code,{children:"block-size"}),"）的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"svmin"})," 等于浏览器视窗小尺寸的宽度或高度中的较小值，即 ",(0,i.jsx)(n.code,{children:"svw"})," 或 ",(0,i.jsx)(n.code,{children:"svh"})," 较小的那个值"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"svmax"})," 等于浏览器视窗小尺寸的宽度或高度中的较大值，即 ",(0,i.jsx)(n.code,{children:"svw"})," 或 ",(0,i.jsx)(n.code,{children:"svh"})," 较大的那个值"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"这些视窗相对单位的大小是固定的（因此是稳定的），除非视口本身被调整大小。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:N,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"除了大小视窗之外，还有一个动态视窗，它有动态考虑的 UA UI:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"当动态工具栏展开时，动态视口等于小视窗的大小。"}),"\n",(0,i.jsx)(n.li,{children:"当动态工具栏收缩时，动态视口等于大视窗的大小。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["动态视窗单位以 ",(0,i.jsx)(n.code,{children:"dv"})," 前缀定义，其中包括 ",(0,i.jsx)(n.code,{children:"dvw"})," 、",(0,i.jsx)(n.code,{children:"dvh"})," 、",(0,i.jsx)(n.code,{children:"dvi"})," 、",(0,i.jsx)(n.code,{children:"dvb"})," 、",(0,i.jsx)(n.code,{children:"dvmin"})," 和 ",(0,i.jsx)(n.code,{children:"dvmax"})," 。"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dvw"})," 表示动态视窗宽度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dvh"})," 表示动态视窗高度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dvi"})," 表示动态视窗内联轴尺寸的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dvb"})," 表示动态视窗块轴尺寸的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dvmin"})," 表示动态视窗宽度或高度中的较小值，即 ",(0,i.jsx)(n.code,{children:"dvw"})," 或 ",(0,i.jsx)(n.code,{children:"dvh"})," 中较小的那个值"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"dvmax"})," 表示动态视窗宽度或高度中的较大值，即 ",(0,i.jsx)(n.code,{children:"dvw"})," 或 ",(0,i.jsx)(n.code,{children:"dvh"})," 中较大的那个值"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["而且 ",(0,i.jsx)(n.code,{children:"dv*"})," 相关的动态视窗单位的尺寸夹在 ",(0,i.jsx)(n.code,{children:"lv*"})," 大视窗单位尺寸和 ",(0,i.jsx)(n.code,{children:"sv*"})," 小视窗单位尺寸之间。也就是说，当附加的动态浏览器工具栏(如顶部的地址或底部的选项卡栏)可见或不可见时，动态视口单元的值会发生变化。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:Y,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["需要注意的是，",(0,i.jsx)(n.code,{children:"*vi"})," 和 ",(0,i.jsx)(n.code,{children:"*vb"})," 等视窗单位由 ",(0,i.jsx)(n.code,{children:"writing-mode"})," 属性的初始值来确定它们对应哪个轴（内联轴尺寸或块轴尺寸）。"]}),"\n",(0,i.jsxs)(n.h2,{id:"css-容器查询单位",children:["CSS 容器查询单位",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#css-容器查询单位",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"现在我们知道了，CSS 视窗单位是以一种响应浏览器视窗大小（宽度或高度）的方式工作。这很棒，但我们并不总是希望使用与浏览器视窗大小相关的单位。如果我们想查询容器的宽度呢？这就是 CSS 容器查询单位的作用。"}),"\n",(0,i.jsx)(n.p,{children:"为了更清楚地说明这一点，我想用下图来描述视窗单位和容器查询单位之间的区别："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:k,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["上图左侧的卡片组件标题的字号（",(0,i.jsx)(n.code,{children:"font-size"}),"）是由 ",(0,i.jsx)(n.code,{children:"rem"})," 和 ",(0,i.jsx)(n.code,{children:"vw"})," 控制，这将相对于浏览器视窗宽度计算。在某些情况下，这可能会起作用，但它可能会导致意想不到的问题，因为它是相对于浏览器视窗宽度计算的。"]}),"\n",(0,i.jsxs)(n.p,{children:["在处理组件（比如上图中卡片组件的标题）的字体大小（",(0,i.jsx)(n.code,{children:"font-size"}),"）时，容器查询单位可以节省我们不少精力和时间。我们可以使用容器查询单位来代替手动增加字体大小。"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/css-contain-3/#container-lengths",target:"_blank",rel:"noopener noreferrer",children:"CSS 规范"}),"目前主要定义了以下几种容器查询单位："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"cqw"})})," ：查询宽度，相对于查询容器宽度计算，即 ",(0,i.jsx)(n.code,{children:"1cqw"})," 等于查询容器宽度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"cqh"})})," ：查询高度，相寻于查询容器高度计算，即 ",(0,i.jsx)(n.code,{children:"1cqh"})," 等于查询容器高度的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"cqi"})})," ：查询内联轴尺寸，相对于查询容器内联轴尺寸计算，即 ",(0,i.jsx)(n.code,{children:"1cqi"})," 等于查询容器内联轴尺寸的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"cqb"})})," ：查询块轴尺寸，相对于查询容器块轴尺寸计算，即 ",(0,i.jsx)(n.code,{children:"1cqb"})," 等于查询容器块轴尺寸的 ",(0,i.jsx)(n.code,{children:"1%"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"cqmin"})})," ：查询最小值，是查询内联轴尺寸 ",(0,i.jsx)(n.code,{children:"cqi"})," 或查询块轴尺寸 ",(0,i.jsx)(n.code,{children:"cqb"})," 中较小的那个值"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"cqmax"})})," ：查询最大值，是查询内联轴尺寸 ",(0,i.jsx)(n.code,{children:"cqi"})," 或查询块轴尺寸 ",(0,i.jsx)(n.code,{children:"cqb"})," 中较大的那个值"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"字体相对长度单位",children:["字体相对长度单位",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#字体相对长度单位",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["字体相对长度指的是使用它们的元素（用于本地字体相对长度）或根元素（用于根字体相对长度）的字体度量。在表现形式上有一个很好的区别，即相对于根元素（用于根字体相对长度）的单位都是以 ",(0,i.jsx)(n.code,{children:"r"})," 前缀开头的单位。其中："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["用于本地字体相对长度的单位有 ",(0,i.jsx)(n.code,{children:"em"})," 、",(0,i.jsx)(n.code,{children:"ex"})," 、",(0,i.jsx)(n.code,{children:"cap"})," 、",(0,i.jsx)(n.code,{children:"ch"})," 、",(0,i.jsx)(n.code,{children:"ic"})," 和 ",(0,i.jsx)(n.code,{children:"lh"})]}),"\n",(0,i.jsxs)(n.li,{children:["用于根字体相对长度的单位有 ",(0,i.jsx)(n.code,{children:"rem"})," 、",(0,i.jsx)(n.code,{children:"rex"})," 、",(0,i.jsx)(n.code,{children:"rcap"})," 、",(0,i.jsx)(n.code,{children:"rch"})," 、",(0,i.jsx)(n.code,{children:"ric"})," 和 ",(0,i.jsx)(n.code,{children:"rlh"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:L,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"它们具体含义如下："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"em"})})," ：如果在元素的 ",(0,i.jsx)(n.code,{children:"font-size"})," 属性中使用 ",(0,i.jsx)(n.code,{children:"em"})," 单位，则相对于元素父元素的 ",(0,i.jsx)(n.code,{children:"font-size"})," 计算，如果在元素的其他属性（非 ",(0,i.jsx)(n.code,{children:"font-size"}),"）中使用 ",(0,i.jsx)(n.code,{children:"em"})," 单位，则相对于元素自身的 ",(0,i.jsx)(n.code,{children:"font-size"})," 计算，例如 ",(0,i.jsx)(n.code,{children:"width"})," 属性"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"rem"})})," ：相对于根元素的 ",(0,i.jsx)(n.code,{children:"font-size"})," 计算"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ex"})})," ：等于第一个可用字体的 ",(0,i.jsx)(n.code,{children:"x-height"})," ，即小写字符 ",(0,i.jsx)(n.code,{children:"x"})," 的高度"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"rex"})})," ：相对于根元素上的 ",(0,i.jsx)(n.code,{children:"ex"})," 单位的值计算"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ch"})})," ：数字 ",(0,i.jsx)(n.code,{children:"0"})," （",(0,i.jsx)(n.code,{children:"U+0030"}),"）的宽度"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"rch"})})," ：相对于根元素上的 ",(0,i.jsx)(n.code,{children:"ch"})," 单位的值计算"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"cap"})})," ：等于第一个可用字体的使用帽高度（cap-height），它大约等于大写拉丁字母的高度"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"rcap"})})," ：相对于根元素上的 ",(0,i.jsx)(n.code,{children:"cap"})," 单位的值计算"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"lh"})})," ：等于元素的行高（",(0,i.jsx)(n.code,{children:"line-height"})," ）"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"rlh"})})," ：相对于根元素上的 ",(0,i.jsx)(n.code,{children:"lh"})," 单位的值计算，当用于根元素的 ",(0,i.jsx)(n.code,{children:"font-size"})," 或 ",(0,i.jsx)(n.code,{children:"line-height"})," 属性时，它指的是这些属性的初始值"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ic"})})," ：是 ",(0,i.jsx)(n.code,{children:"ch"})," 的东方版本。它是 CJK （中文、日文和韩文）表意文字 ",(0,i.jsx)(n.code,{children:"水"})," （",(0,i.jsx)(n.code,{children:"U+6C34"}),"）的大小，因此可以粗略地解释为“表意文字计数”。在不可能或不实际确定表意文字的大小情况下，必须假定为 ",(0,i.jsx)(n.code,{children:"1em"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"ric"})})," ：相对于根元素上的 ",(0,i.jsx)(n.code,{children:"ic"})," 单位的值计算"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"使用-css-相对单位构建可调整大小的组件",children:["使用 CSS 相对单位构建可调整大小的组件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-css-相对单位构建可调整大小的组件",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"Web 开发者往往将构建一个可调整大小的组件作为终极目标，这样做的主要目的是，Web 组件更具灵活性和适配性，可以很好的用于更多不同的使用场景。Web 开发者使用 CSS 相对单位构建可调整大小的组件有极大的便利和优势。接下来，我们来通过一些实际的案例来向大家展示，CSS 相对单位是如何使组件调整大小更便利。"}),"\n",(0,i.jsxs)(n.h3,{id:"响应式排版",children:["响应式排版",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#响应式排版",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在响应式排版中使用视窗单位已经变得非常流行，Web 开发者可以根据当前浏览器视窗的大小来设置字体大小。它能使字体大小随着浏览器视窗大小而增大或缩小。"}),"\n",(0,i.jsxs)(n.p,{children:["例如，我们可以像下面给一个标题设置 ",(0,i.jsx)(n.code,{children:"font-size"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".title {\n \xa0 \xa0font-size: 5vw;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["标题的字体大小（",(0,i.jsx)(n.code,{children:"font-size"}),"）将根据浏览器视窗宽度变大或变小。这就相当于将当前浏览器视窗宽度的 ",(0,i.jsx)(n.code,{children:"5%"})," 大小用于 ",(0,i.jsx)(n.code,{children:"font-size"})," 。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:M,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/yLQPBJR",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/yLQPBJR"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["对 ",(0,i.jsx)(n.code,{children:"font-size"})," 使用简单的视窗单位有一个有趣（危险）的效果。正如你所看到的，字体的缩放速度非常快，字体大小在移动设备中变得非常小，这不利于可访问性和用户体验。据我所知，移动设备上的最小字体大小不应该小于 ",(0,i.jsx)(n.code,{children:"14px"}),"。在 GIF 中，字体大小低于 ",(0,i.jsx)(n.code,{children:"10px"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["为了解决这个问题，我们需要给标题一个最小的字体大小，字体大小不能低于它。这个时候 ，CSS 的 ",(0,i.jsx)(n.code,{children:"calc()"})," 函数就起作用了。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".title {\n \xa0 \xa0font-size: calc(14px + 2vw);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["我们将 ",(0,i.jsx)(n.code,{children:"14px"})," 作为 ",(0,i.jsx)(n.code,{children:"font-size"})," 的基本尺寸，并在此基础添加 ",(0,i.jsx)(n.code,{children:"2vw"})," 。有了它，字体大小的值就不会变得太小。"]}),"\n",(0,i.jsxs)(n.p,{children:["另一个需要考虑的重要问题是字体大小在大屏幕上的表现，比如 ",(0,i.jsx)(n.code,{children:"27"})," 英寸的 iMac。会发生什么?嗯，你猜对了。字体大小约为 ",(0,i.jsx)(n.code,{children:"95px"}),"，这是一个很大的值。为了防止这种情况，我们应该在某些断点处使用媒体查询并更改字体大小。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"@media only screen and (width > 1800px) {\n \xa0 \xa0.title {\n \xa0 \xa0 \xa0 \xa0font-size: 40px;\n \xa0 \xa0 }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"通过重置字体大小，我们可以确保大小不会太大。"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:q,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/RwqjboK",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/RwqjboK"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"效果看上去已经好很多了，但你可能需要根据你的项目上下文在代码中添加多个媒体查询。这是 Web 开发者不想要的。"}),"\n",(0,i.jsxs)(n.p,{children:["庆幸的是，我们可以使用 CSS 的比较函数 ",(0,i.jsx)(n.code,{children:"clamp()"})," 来替代上面示例中的 ",(0,i.jsx)(n.code,{children:"calc()"})," 函数。使用 ",(0,i.jsx)(n.code,{children:"clamp()"})," 函数有一个最大优势，它可以接受三个值：最小值、理想值和最大值。响应式排版的核心思想是“理想”值使用一个视窗单位（例如 ",(0,i.jsx)(n.code,{children:"vw"}),"），以便在最小值和最大值之间进行插值。这有效地允许字体大小沿着首选范围调整大小。例如："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".title {\n \xa0 \xa0font-size: clamp(1rem, 4vw + 1rem, 3rem);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["上面的代码将会告诉浏览器，标题 ",(0,i.jsx)(n.code,{children:".title"})," 的 ",(0,i.jsx)(n.code,{children:"font-size"})," 的最小值是 ",(0,i.jsx)(n.code,{children:"1rem"})," ，最大值是 ",(0,i.jsx)(n.code,{children:"3rem"})," ，其中 ",(0,i.jsx)(n.code,{children:"4vw"})," 允许沿着范围内（",(0,i.jsx)(n.code,{children:"1rem ~ 3rem"}),"）插值。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:z,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/QWJOLdx",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/QWJOLdx"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["至于在 ",(0,i.jsx)(n.code,{children:"clamp()"})," 函数的首选值中为什么要使用 ",(0,i.jsx)(n.code,{children:"4vw + 1rem"})," ，在这里就不详细阐述了，如果你对这方面知识感兴趣，可以回过头阅读小册的《",(0,i.jsx)(n.a,{href:"https://juejin.cn/book/7223230325122400288/section/7241401565653762108",target:"_blank",rel:"noopener noreferrer",children:"16 | CSS 的比较函数：min() 、max() 和 clamp()"}),"》。"]}),"\n",(0,i.jsxs)(n.p,{children:["正如你所看到的，使用视窗单位是相对于浏览器视窗来计算的。不过很多时候，我们希望字体大小与书写模式的内联轴尺寸能相关联起来。要实现这样的效果，我们就需要将视窗单位升级到容器查询单位。例如，我们可以将上面示例中的 ",(0,i.jsx)(n.code,{children:"vw"})," 单位替换成 ",(0,i.jsx)(n.code,{children:"cqi"})," 单位："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".title {\n \xa0 \xa0font-size: clamp(1rem, 4cqi + 1rem, 3rem);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:A,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/PoxOYmJ",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/PoxOYmJ"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"你可能已经发现了，上面这个示例它的响应还是基于浏览器视窗大小的。这是怎么回事呢？"}),"\n",(0,i.jsxs)(n.p,{children:["容器查询规范包括一项规定，即每个元素默认为样式容器，这就是为什么使用 ",(0,i.jsx)(n.code,{children:"cqi"})," 已经可以灵活调整大小。但是，由于我们没有为示例定义查询容器，因此测量仍然针对应用了包含的最接近的祖先。这意味着对于我们查询“内联”轴的规则，浏览器的视窗宽度被用作度量。"]}),"\n",(0,i.jsx)(n.p,{children:"为了达到我们真正想要的效果，也就是让字体大小响应父容器，我们需要一个查询容器。例如："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-HTML",children:'<div class="container">\n \xa0 \xa0<h1 class="title">Using CSS Container Query Units For Font Sizing</h1>\n</div>\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".container {\n \xa0 \xa0container-type: inline-size;\n}\n​\n.title {\n \xa0 \xa0font-size: clamp(1rem, 4cqi + 1rem, 3rem);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:C,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/OJaOLgO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/OJaOLgO"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["如此一来，我们就可以使用 CSS 容器查询单位和 ",(0,i.jsx)(n.code,{children:"clamp()"})," 或 ",(0,i.jsx)(n.code,{children:"calc()"})," 实现动态范围的字体大小设置、基于基本字体大小的扩展和使用字体比例来设置字体大小。具体代码如下："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"/* 使用 clamp() 实现动态范围字体大小设置 */\n:root {\n \xa0 \xa0--headline-1: 2.75rem;\n \xa0 \xa0--headline-2: 2.35rem;\n \xa0 \xa0--headline-3: 1.5rem;\n \xa0 \xa0--headline-4: 1.15rem;\n}\n​\nh1,\n.h1 {\n \xa0 \xa0--font-size: var(--headline-1);\n \xa0 \xa0font-size: var(--headline-1);\n}\n​\nh2,\n.h2 {\n \xa0 \xa0--font-size: var(--headline-2);\n \xa0 \xa0--font-size-fluid: 4.5cqi;\n \xa0 \xa0font-size: var(--headline-2);\n}\n​\nh3,\n.h3 {\n \xa0 \xa0--font-size: var(--headline-3);\n \xa0 \xa0--font-size-fluid: 4.25cqi;\n \xa0 \xa0--font-size-diff: 0.2;\n \xa0 \xa0font-size: var(--headline-3);\n}\n​\nh4,\n.h4 {\n \xa0 \xa0--font-size: var(--headline-4);\n \xa0 \xa0--font-size-fluid: 4cqi;\n \xa0 \xa0--font-size-diff: 0.2;\n \xa0 \xa0font-size: var(--headline-4);\n}\n​\n@supports (font-size: 1cqi) {\n \xa0  :is(h1, .h1, h2, .h2, h3, .h3, h4, .h4, .fluid-type) {\n \xa0 \xa0 \xa0 \xa0font-size: clamp(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0max(1rem, var(--font-size) - var(--font-size) * var(--font-size-diff, 0.3)),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0var(--font-size-fluid, 5cqi),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0var(--font-size)\n \xa0 \xa0 \xa0 \xa0 );\n \xa0 \xa0 }\n}\n​\n/* 使用 calc() 从基本字体大小扩展 */\n:root {\n \xa0 \xa0--h1-base: 1.75rem;\n \xa0 \xa0--h2-base: 1.5rem;\n \xa0 \xa0--h3-base: 1.35rem;\n \xa0 \xa0--h4-base: 1.15rem;\n}\n​\nh1,\n.h1 {\n \xa0 \xa0--font-size-base: var(--h1-base);\n \xa0 \xa0font-size: var(--h1-base);\n}\n​\nh2,\n.h2 {\n \xa0 \xa0--font-size-base: var(--h2-base);\n \xa0 \xa0--font-size-fluid: 2.5cqi;\n \xa0 \xa0font-size: var(--h2-base);\n}\n​\nh3,\n.h3 {\n \xa0 \xa0--font-size-base: var(--h3-base);\n \xa0 \xa0--font-size-fluid: 2.25cqi;\n \xa0 \xa0font-size: var(--h3-base);\n}\n​\nh4,\n.h4 {\n \xa0 \xa0--font-size-base: var(--h4-base);\n \xa0 \xa0--font-size-fluid: 2cqi;\n \xa0 \xa0font-size: var(--h4-base);\n}\n​\n@supports (font-size: 1cqi) {\n \xa0  :is(h1, .h1, h2, .h2, h3, .h3, h4, .h4, .fluid-type) {\n \xa0 \xa0 \xa0 \xa0font-size: calc(var(--font-size-base) + var(--font-size-fluid, 3cqi));\n \xa0 \xa0 }\n}\n​\n/* 使用字体比例设置字体大小 */\n:root {\n \xa0 \xa0--type-ratio: 1.33;\n \xa0 \xa0--body-font-size: 1rem;\n \xa0 \xa0--font-size-4: calc(var(--body-font-size) * var(--type-ratio));\n \xa0 \xa0--font-size-3: calc(var(--font-size-4) * var(--type-ratio));\n \xa0 \xa0--font-size-2: calc(var(--font-size-3) * var(--type-ratio));\n \xa0 \xa0--font-size-1: calc(var(--font-size-2) * var(--type-ratio));\n}\n​\nh1,\n.h1 {\n \xa0 \xa0--font-size: var(--font-size-1);\n \xa0 \xa0font-size: var(--font-size);\n}\n​\nh2,\n.h2 {\n \xa0 \xa0--font-size: var(--font-size-2);\n \xa0 \xa0font-size: var(--font-size);\n}\n​\nh3,\n.h3 {\n \xa0 \xa0--font-size: var(--font-size-3);\n \xa0 \xa0font-size: var(--font-size);\n}\n​\nh4,\n.h4 {\n \xa0 \xa0--font-size: var(--font-size-4);\n \xa0 \xa0font-size: var(--font-size);\n}\n​\n@supports (font-size: 1cqi) {\n \xa0  :is(h1, .h1, h2, .h2, h3, .h3, h4, .h4, .fluid-type) {\n \xa0 \xa0 \xa0 \xa0--_font-min: var(--font-size) - var(--font-size) * var(--font-size-diff, 0.3);\n \xa0 \xa0 \xa0 \xa0font-size: clamp(\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0max(var(--body-font-size), var(--_font-min)),\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0var(--_font-min) + 1cqi,\n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0var(--font-size)\n \xa0 \xa0 \xa0  );\n \xa0  }\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"全高布局",children:["全高布局",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#全高布局",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在构建 Web 布局时，有的时候希望页面高度和屏幕高度是一样的。在以往我们一般使用 ",(0,i.jsx)(n.code,{children:"100vh"})," 来实现，例如："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"section {\n    height: 100vh;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["但由于 ",(0,i.jsx)(n.code,{children:"100vh"})," 在移动端上存在一定的缺陷，为了避免该现象，建议使用新增的视窗单位 ",(0,i.jsx)(n.code,{children:"dvh"})," 来替代 ",(0,i.jsx)(n.code,{children:"vh"})," 。这样不管浏览器的工具栏、状态栏、地址栏是否收缩都能使元素高度与屏幕高度相等："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"section {\n \xa0 \xa0height: 100dvh;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:S,alt:"img"})}),"\n",(0,i.jsxs)(n.h3,{id:"sticky-footer",children:["Sticky Footer",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#sticky-footer",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Sticky Footer 是 Web 经典布局之一，我曾在现代 ",(0,i.jsx)(n.a,{href:"https://s.juejin.cn/ds/iSqLf6D/",target:"_blank",rel:"noopener noreferrer",children:"Web 布局"}),"中介绍了如何使用 ",(0,i.jsx)(n.a,{href:"https://juejin.cn/book/7161370789680250917/section/7161623855054716935",target:"_blank",rel:"noopener noreferrer",children:"Flexbox"})," 和 ",(0,i.jsx)(n.a,{href:"https://juejin.cn/book/7161370789680250917/section/7161624078397210638",target:"_blank",rel:"noopener noreferrer",children:"Grid"})," 来实现 Sticky Footer 布局效果。在这里我将介绍另一种方案，即使用视窗单位实现 Sticky Footer 布局效果。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-HTML",children:"<body>\n \xa0 \xa0<header>Header Section</header>\n \xa0 \xa0<main>Main Section</main>\n \xa0 \xa0<footer>Footer Section</footer>\n</body>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["假设页面的 ",(0,i.jsx)(n.code,{children:"header"})," 和 ",(0,i.jsx)(n.code,{children:"footer"})," 内容所占高度都是 ",(0,i.jsx)(n.code,{children:"120px"})," ，那么可以使用 ",(0,i.jsx)(n.code,{children:"calc()"})," 计算出 ",(0,i.jsx)(n.code,{children:"main"})," 的高度："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"main 高度 = 100vh - 120px - 120px\n"})}),"\n",(0,i.jsx)(n.p,{children:"CSS 可以这样写："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"header,\nfooter {\n \xa0 \xa0height: 120px;\n}\n​\nmain {\n \xa0 \xa0min-height: calc(100vh - 120px * 2);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:w,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/bGQYbMK",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/bGQYbMK"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"带有粘性头部和脚部的模态框",children:["带有粘性头部和脚部的模态框",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#带有粘性头部和脚部的模态框",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:u,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"这是一个带有粘性页头和页脚的模态框。如果内容足够长，中间部分是可以滚动的。你往往会像下面这样设置模态框的 CSS 样式:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".modal {\n \xa0 \xa0position: fixed;\n \xa0 \xa0top: 0;\n \xa0 \xa0left: 0;\n \xa0 \xa0right: 0;\n \xa0 \xa0height: 100vh;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["代码中使用了 ",(0,i.jsx)(n.code,{children:"100vh"})," 来设置模态框的高度，但它将使得模态框的底部（页脚）不可见，这将破坏用户体验。以下是 iOS 上传统（",(0,i.jsx)(n.code,{children:"vh"}),"）和新型视窗单位（",(0,i.jsx)(n.code,{children:"dvh"}),"）的表现："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:v,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"再加上 Android 上的 Chrome 和 Firefox："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:b,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["和全高布局类似，我们可以使用 ",(0,i.jsx)(n.code,{children:"svh"})," 或 ",(0,i.jsx)(n.code,{children:"dvh"})," 来解决这个问题，个人更建议使用 ",(0,i.jsx)(n.code,{children:"dvh"})," 来替代 ",(0,i.jsx)(n.code,{children:"vh"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".modal {\n \xa0 \xa0position: fixed;\n \xa0 \xa0top: 0;\n \xa0 \xa0left: 0;\n \xa0 \xa0right: 0;\n \xa0 \xa0height: 100dvh;\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"英雄区hero-section",children:["英雄区（Hero Section）",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#英雄区hero-section",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:g,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"通常情况下，我们需要让英雄区域（Hero Section）的高度等于整个视窗的高度减去页头的高度，即："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"height = 100vh - header-height\n"})}),"\n",(0,i.jsx)(n.p,{children:"即："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:":root {\n \xa0 \xa0--header-height: 60px;\n}\n​\nheader {\n \xa0 \xa0position: sticky;\n \xa0 \xa0top: 0;\n \xa0 \xa0min-height: var(--header-height, initial);\n}\n​\n.hero {\n \xa0 \xa0min-height: calc(100vh - var(--header-height));\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在这种情况下，使用传统的 ",(0,i.jsx)(n.code,{children:"vh"})," 将无法在 iOS Safari、Firefox 和 Android Chrome 等浏览器中运行，即滚动收缩浏览器地址栏。你发现装饰元素（上图中紫色部分）根本不可见。事实上，如果你仔细观察，它在 iOS Safari 的地址栏下面是模糊的，在 Android 浏览器中是裁剪的。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:f,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["在这个示例中，我们可以使用 ",(0,i.jsx)(n.code,{children:"svh"})," 来解决这个问题："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".hero {\n    min-height: calc(100svh - var(--header-height));\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:m,alt:"img"})}),"\n",(0,i.jsxs)(n.p,{children:["虽然动态视窗单位（例如 ",(0,i.jsx)(n.code,{children:"dvh"}),"）可以帮助我们解决一些 ",(0,i.jsx)(n.code,{children:"100vh"})," 的问题，但我们在使用的时候还是要小心使用 ",(0,i.jsx)(n.code,{children:"dvh"})," 视窗单位。因为动态视窗单位可能会影响 Web 页面性能，使用动态单位时，浏览器会重新计算用户向上或向下滚动的样式，这个成本是昂贵的。"]}),"\n",(0,i.jsxs)(n.h3,{id:"流式宽高比",children:["流式宽高比",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#流式宽高比",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["现在，我们在 CSS 中可以使用 ",(0,i.jsx)(n.code,{children:"aspect-ratio"})," 属性给元素设置一个宽高比，这对于嵌入内容（如视频）尤其有用。在过去，",(0,i.jsx)(n.code,{children:"aspect-ratio"})," 还没有得到主流浏览器支持的时候，我们会在容器元素使用 ",(0,i.jsx)(n.code,{children:"padding-bottom"})," 或 ",(0,i.jsx)(n.code,{children:"padding-top"})," 的百分比来实现类似 ",(0,i.jsx)(n.code,{children:"aspect-ratio"})," 属性的特性，但这是一种 Hack 手段。"]}),"\n",(0,i.jsxs)(n.p,{children:["现在我们可以使用视窗单位来实现 ",(0,i.jsx)(n.code,{children:"aspect-ratio"})," 属性的特性，可以说是另一种 Hack 手段，只不过这种 Hack 手段相比于 ",(0,i.jsx)(n.code,{children:"padding-top"})," 或 ",(0,i.jsx)(n.code,{children:"padding-bottom"})," 来说，无需增加额外的 HTML 标签元素。假设，我们希望视频是全屏的，我们可以设置相对于整个视窗宽度的高度："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"video {\n    width: 100vw;\n    height: calc(100vw * (9 / 16)); /* full-width * aspect-ratio */\n}\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/xxQPKeO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/xxQPKeO"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"打破容器限制",children:["打破容器限制",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#打破容器限制",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:p,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"多年来，将约束文本与全宽背景混合使用一直很流行。这样的布局和你的 HTML 结构有着紧密关系，但在一些系统上你控制 HTML 标记成本会比较高（例如 CMS 系统），那么实现这样的布局就变得很困难。有了视窗单位之后，实现该类布局，就显得没那么困难了，只需要几行代码就可以完成："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".full-width {\n \xa0 \xa0margin-left: calc(50% - 50vw);\n \xa0 \xa0margin-right: calc(50% - 50vw);\n}\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址： ",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/mdQqbYX",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/mdQqbYX"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"或者使用下面这种方式也是可以的："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".break-out {\n \xa0 \xa0width: 100vw;\n \xa0 \xa0position: relative;\n \xa0 \xa0left: 50%;\n \xa0 \xa0right: 50%;\n \xa0 \xa0margin-left: -50vw;\n \xa0 \xa0margin-right: -50vw;\n}\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/VwVrZJz",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/VwVrZJz"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"根据重要性调整字体大小",children:["根据重要性调整字体大小",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#根据重要性调整字体大小",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在 Web 布局中，有的时候为了突显某个元素的重要性时，往往会把字体大小设置的更大。比如，同一个组件放置在 Web 页面的侧边栏（",(0,i.jsx)(n.code,{children:"aside"}),"）和主内容区域（",(0,i.jsx)(n.code,{children:"main"}),"），其中主内容区域的标题比侧边栏要大："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"正如上图所示，我们使用 CSS 的容器查询单位，可以很容易地实现。"}),"\n",(0,i.jsxs)(n.p,{children:["首先，我们需要将 ",(0,i.jsx)(n.code,{children:"aside"})," 和 ",(0,i.jsx)(n.code,{children:"main"})," 定义为一个查询容器："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"aside,\nmain {\n \xa0 \xa0container: inline-size;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"然后，我们将容器查询单位运用于组件的标题中："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".section__title {\n    font-size: clamp(1.25rem, 3cqw, 2rem);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:j,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/PoxOoJV",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/PoxOoJV"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"动态间距",children:["动态间距",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#动态间距",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["我们一直在 CSS 网格布局中使用视窗单位 ",(0,i.jsx)(n.code,{children:"vw"})," 来创建间距。就像："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".container {\n    gap: calc(14px + 1vh) calc(14px + 0.5vw);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/abQVbYy",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/abQVbYy"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"你可能发现了，网格轨道之间的间距是相对于浏览器视窗宽高计算的。看上去已经很不错了，但是在特定的容器中的组件呢？使用视窗单位就行不通了。在此情况之下就需要使用容器查询单位："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:x,alt:"img"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".container {\n \xa0 \xa0container-type: inline-size;\n}\n​\n.card {\n \xa0 \xa0display: flex;\n \xa0 \xa0flex-direction: column;\n \xa0 \xa0gap: calc(0.5rem + 1cqmin);\n}\n​\n@container (width > 320px) {\n \xa0 \xa0.card {\n \xa0 \xa0 \xa0 \xa0flex-direction: row;\n \xa0  }\n \xa0\n \xa0 \xa0.card img {\n \xa0 \xa0 \xa0 \xa0max-width: 35cqw;\n \xa0  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/Rwqjwdv",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/Rwqjwdv"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"使用-em-调整-web-组件尺寸大小",children:["使用 em 调整 Web 组件尺寸大小",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-em-调整-web-组件尺寸大小",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["前面向大家所展示的示例都是使用视窗单位或容器查询单位来调整 Web 组件的尺寸。事实上，我们在 Web 开发过程中，也可以使用 CSS 的字体相对单位（例如 ",(0,i.jsx)(n.code,{children:"%"})," 、",(0,i.jsx)(n.code,{children:"rem"})," 或 ",(0,i.jsx)(n.code,{children:"em"}),"）来调整组件的大小。不仅仅是字体大小，还有组件中的所有 UI。就拿 ",(0,i.jsx)(n.code,{children:"em"})," 单位为例，我们调整组件 ",(0,i.jsx)(n.code,{children:"font-size"})," 时，组件所有 UI 尺寸都会随之变化："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:"img"})}),"\n",(0,i.jsx)(n.p,{children:"来看一个简单的示例，比如上图中的按钮组件："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".button {\n \xa0 \xa0font-size: 1em;\n \xa0 \xa0padding: 0.625em 1em;\n \xa0 \xa0border-radius: 0.25em;\n}\n​\n.button--2x {\n \xa0 \xa0font-size: 150%;\n}\n​\n.button--3x {\n \xa0 \xa0font-size: 200%;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/poQdvje",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/poQdvje"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"使用-lh-实现首字下沉",children:["使用 lh 实现首字下沉",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-lh-实现首字下沉",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在《",(0,i.jsx)(n.a,{href:"https://juejin.cn/book/7223230325122400288/section/7246991031319658557",target:"_blank",rel:"noopener noreferrer",children:"22 | 首字母下沉：initial-letter"}),"》一节课中，我们介绍了如何使用 ",(0,i.jsx)(n.code,{children:"initial-letter"})," 实现首字母下沉的效果。在以往（",(0,i.jsx)(n.code,{children:"initial-letter"})," 还没有得到主流浏览器支持的情况下），我们一般都是使用浮动来实现首字母下沉的效果，但在这个过程中却很难控制下沉的行数，即达到 ",(0,i.jsx)(n.code,{children:"initial-letter"})," 的效果。"]}),"\n",(0,i.jsxs)(n.p,{children:["如今，我们使用 ",(0,i.jsx)(n.code,{children:"lh"})," 单位，就容易得多了："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:"p::first-letter {\n \xa0 \xa0color: hsl(20 94% 51%);\n \xa0 \xa0font-weight: bold;\n \xa0 \xa0font-size: 3lh;\n \xa0 \xa0float: left;\n \xa0 \xa0line-height: 1;\n \xa0 \xa0margin-right: 0.1lh;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:r,alt:"img"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Demo 地址：",(0,i.jsx)(n.a,{href:"https://codepen.io/airen/full/NWEwPbr",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/NWEwPbr"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["而且在个别情况之下，使用 ",(0,i.jsx)(n.code,{children:"lh"})," 单位也要比其他单位灵活的多，比如实现列表标记与文本垂直居中的效果，使用 ",(0,i.jsx)(n.code,{children:"lh"})," 单位就要比 ",(0,i.jsx)(n.code,{children:"em"})," 效果好些："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-CSS",children:".inline--icon {\n \xa0 \xa0display: inline-block;\n \xa0 \xa0width: 1lh;\n \xa0 \xa0height: 1lh;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:s,alt:"img"})}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"时至今日，在 CSS 中有近 43 个相对长度单位，它们分别被纳入到字体相对长度单位、视窗相对长度单位和容器查询相对长度单位。它们分别运用于不同的场景。"}),"\n",(0,i.jsxs)(n.p,{children:["理解相对长度单位是流式布局或响应式 Web 布局的关键，它使用 CSS 能够应对几乎无限的视窗大小和 DPI。基于字体的单位一开始可能会觉得奇怪，但在获得一些经验之后，你就会认识到它们比绝对单位有更多的好处。视窗单位是有用的，但重要的是要了解何时使用它们，何时百分比 ",(0,i.jsx)(n.code,{children:"%"})," 单位。容器查询单位的出现，使我们设置组件的大小更为方便，我们可以基于组件容器来调整组件自身的大小。"]}),"\n",(0,i.jsx)(n.p,{children:"我们也需要知道的，在开发一个 Web 应用或网站时，经常被忽视的方面是使用它们易于访问。就其本质而言，这些相对单位尊重用户特定的字体大小和缩放设置。"}),"\n",(0,i.jsx)(n.p,{children:"虽然目前这些相对单位已经足够多了，但我相信，随着未来技术的革新，还会有更多的相对单位出现，并且得到主流浏览器的支持。值得庆幸的是，我们已经能很好的将现有的相对长度单位结合在一起使用，构建出适配性，灵活性更强的 Web 组件。"})]})}function R(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(D,{...e})}):D(e)}let I=R;R.__RSPRESS_PAGE_META={},R.__RSPRESS_PAGE_META["%E7%8E%B0%E4%BB%A3CSS%2F%E7%AC%AC26%E7%AB%A0%E2%80%94%E7%8E%B0%E4%BB%A3CSS%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%AF%B9%E5%8D%95%E4%BD%8D.md"]={toc:[{text:"相对单位简介",id:"相对单位简介",depth:2},{text:"CSS 视窗单位",id:"css-视窗单位",depth:2},{text:"CSS 容器查询单位",id:"css-容器查询单位",depth:2},{text:"字体相对长度单位",id:"字体相对长度单位",depth:2},{text:"使用 CSS 相对单位构建可调整大小的组件",id:"使用-css-相对单位构建可调整大小的组件",depth:2},{text:"响应式排版",id:"响应式排版",depth:3},{text:"全高布局",id:"全高布局",depth:3},{text:"Sticky Footer",id:"sticky-footer",depth:3},{text:"带有粘性头部和脚部的模态框",id:"带有粘性头部和脚部的模态框",depth:3},{text:"英雄区（Hero Section）",id:"英雄区hero-section",depth:3},{text:"流式宽高比",id:"流式宽高比",depth:3},{text:"打破容器限制",id:"打破容器限制",depth:3},{text:"根据重要性调整字体大小",id:"根据重要性调整字体大小",depth:3},{text:"动态间距",id:"动态间距",depth:3},{text:"使用 em 调整 Web 组件尺寸大小",id:"使用-em-调整-web-组件尺寸大小",depth:3},{text:"使用 lh 实现首字下沉",id:"使用-lh-实现首字下沉",depth:3},{text:"小结",id:"小结",depth:2}],title:"第26章—现代CSS中的相对单位",headingTitle:"第26章—现代CSS中的相对单位",frontmatter:{}}}}]);