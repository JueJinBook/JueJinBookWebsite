"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12237"],{494726:function(e,s,n){n.r(s),n.d(s,{default:()=>f});var c=n(552676),t=n(740453);let a=n.p+"static/image/62c7aa49a70f2e3029a6b27eba65c8b8.071ff483.webp",r=n.p+"static/image/9251101630d864995184bcdd89ac05a2.e86a4d58.webp",i=n.p+"static/image/6a7e85b1b3107f941c3ae22a1d865014.cdda26ee.webp",d=n.p+"static/image/0e7f118165f2235ab8e0dc519aff2a8d.89f7700d.webp",l=n.p+"static/image/107225b91ab4c5ffc1c6d2a8a24bbad0.c0c52b3b.webp",j=n.p+"static/image/fcbcfa07fe9bb96c6b9aa347402509d8.8747d9cf.webp",h=n.p+"static/image/e1682cc63eea196fcb099051a592513a.5875cad9.webp",p=n.p+"static/image/3efac669cb13b7a9c448ff21f15b4f45.ed566727.webp",x=n.p+"static/image/aec113b1f1e40fc5137837f187cf285a.6895bb47.webp",m=n.p+"static/image/0702330af778d643a96a70282cc6d228.50222b71.webp";function o(e){let s=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",img:"img",pre:"pre",code:"code"},(0,t.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(s.h1,{id:"13深入原理jest-是怎么实现整个单元测试系统的",children:["13.深入原理：Jest 是怎么实现整个单元测试系统的？",(0,c.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#13深入原理jest-是怎么实现整个单元测试系统的",children:"#"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["代码仓库：",(0,c.jsx)(s.a,{href:"https://github.com/czm1290433700/test_demo",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/czm1290433700/test_demo"})]}),"\n"]}),"\n",(0,c.jsx)(s.p,{children:"上节课我们学习了怎么通过快照测试来保证 UI 的完整，相比查询元素进行断言，快照测试更加简洁粗暴，可以帮助我们快速检测整个模块是否和上次的快照结果匹配。"}),"\n",(0,c.jsx)(s.p,{children:"在快照的设计中，我们讲究不”大“不“小”，一方面不生成大快照，使得组件频繁变动，带动快照也一起更新；另一方面，不生成小快照，因为过小的快照完全可以通过一两句断言解决，就丧失了快照的意义，尽可能在保证组件不变的前提下，将快照的粒度放大才是更加合适的做法。"}),"\n",(0,c.jsx)(s.p,{children:"到这里相信大家对单元测试如何实现已经了然于心了，不过现在 Jest 做的事情还是比较黑盒的，我们只知道它帮我们开展测试，但是我们并不知道它在这个过程中发生了什么，我们为什么需要配置这个配置那个，所以这一节课，我们就专门来学习一下这其中的原理，一起来看看 Jest 是怎么实现整个单元测试系统的。"}),"\n",(0,c.jsxs)(s.h2,{id:"小彩蛋",children:["小彩蛋",(0,c.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#小彩蛋",children:"#"})]}),"\n",(0,c.jsx)(s.p,{children:"在开始这节课的学习前，先同步一个小问题，今天我在执行用例的时候，发现有下面的报错："}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:m,alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"这个是因为不能编译依赖中的 css 导致的，解决方法也很简单，只需要加一个 css 的 mock 去替代就好，原先我一直以为 react-scripts 有帮我们完成这一步，遇到这个问题的同学可以参照下面的步骤修复："}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:'// ./package.json\n"jest": {\n \xa0 \xa0"transformIgnorePatterns": [\n \xa0 \xa0 \xa0"node_modules/(?!axios)"\n \xa0  ],\n \xa0 \xa0"moduleNameMapper": {\n \xa0 \xa0 \xa0"\\.(css|scss)$": "<rootDir>/styleMock.js"\n \xa0  }\n  }\n'})}),"\n",(0,c.jsx)(s.p,{children:"加上 moduleNameMapper ，如果有更多的样式类型，可以自行补充到前面的正则中，styleMock.js 中的内容就一行，将导入改成空即可，如下："}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"module.exports = {};\n"})}),"\n",(0,c.jsx)(s.p,{children:"然后我们再执行所有的用例试试，默认的 test 只会执行最近 commit 相关的用例，我们可以加一则命令用于执行所有的用例，现在可以看到所有的用例都可以通过了。"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:'"test:all": "react-scripts test --watchAll",\n'})}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:x,alt:"img"})}),"\n",(0,c.jsxs)(s.h2,{id:"jest-系统实现",children:["Jest 系统实现",(0,c.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#jest-系统实现",children:"#"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:p,alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"为了方便大家理解，我画了上面的架构图。一起来看看从配置到用例的执行这个过程究竟发生了什么？首先，所有事情的起点是 jest, 准确的说是 jest-cli ，这是我们单测的开始，初始化所有的配置。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:h,alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"紧接着我们来到第二步，也就是我们之前常常配置到的 jest-config，在这里我们可以配置一些全局或者针对目前项目的配置，在获取到这部分配置后，进入到第三步。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:j,alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"在第三步中，我们直接交互的部分是 jest-haste-map，这部分是一个虚拟的文件系统，它会在我们第一次执行用例的时候，去遍历一遍项目的文件目录，形成一个 Map ，其中存储着我们文件之间的依赖和上下级关系，在后续的热更新操作中，它将会直接获取之前的 Map 缓存而不再遍历文件系统。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:l,alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"再往下就是比较重要的一步了，jest-worker，它的底层基于 watchman 来实现。有一个读者问我 jest 每次热更新会执行全部用例吗？答案当然是不会的，jest-worker 会监听变化的文件，来保证每次热更新重新执行的是最近变更部分的用例，而不是全部。"}),"\n",(0,c.jsx)(s.p,{children:"我们想象一下，如果咱们的用例很多，没有这样一步的话，每次 change 都要等待所有的用例执行完，那真的就是一个很痛苦的事情了。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"在上一步完成后，我们已经拿到了我们的配置和文件系统。接下来会通过 searchsource 的集成类来找寻我们需要运行的用例。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:d,alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"获取到用例后，我们会经过 test sequencer，这是一个测试排序器，在这一步中我们会来排序用例执行的优先级，优先级会按照过去失败过的用例 > 执行实现长的用例 > 文件 size 大的用例这样一个顺序来执行，来保证用户关注的内容可以被优先做完。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:"data:image/webp;base64,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",alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"到下一步仍然是调度，我们会经过 test schedule，不过与 test sequencer 不同，这一次不再是分优先级了，而是安排进程，会根据现在 CPU 的情况来把用例分配到合理的线程，也许会单线程，也许会安排多个线程来分开执行。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:i,alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"调度的部分完成以后，就要开始着手执行我们的用例了，其中比较核心的两个部分是 jest-runner 和 jest-jasmine，其中 jest-runner 负责直接执行，而 jest-jasmine 负责根据架构来拆分我们的用例，这里的架构指的就是我们的 describe 和 test。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:r,alt:"img"})}),"\n",(0,c.jsx)(s.p,{children:"在执行的过程中，我们可以分为两个部分，一个是运行环境，另一个就是转译。对于运行环境, 我们可以分为 jsdom 和 node，默认我们是选用 node 的，不过如果我们测试的是 web 应用程序，那就应该选用 jsdom，两者是不同的运行引擎。"}),"\n",(0,c.jsx)(s.p,{children:'对于转译，我们知道 nodejs 是 commonjs 的 "拥护者“，在直接的 node 环境里是不能识别 esm 的写法的，所以我们需要使用一些转译工具，比如 babel，来帮助我们转译成 commonjs，为我们的测试程序保驾护航。'}),"\n",(0,c.jsx)(s.p,{children:"到这里，咱们的 jest 用例就执行完成了，我们再回顾一遍。"}),"\n",(0,c.jsx)(s.p,{children:"首先是前置的工作，我们会拿到 jest 的配置并且会根据文件系统生成一组虚拟的文件映射，来保证后续热更新的效率；接下来会找寻我们文件中需要执行的用例，并且根据优先级和 CPU 的使用情况，将它们分给不同的线程按顺序执行；在执行的过程中，因为环境的原因，需要确定我们的执行引擎和文件转译，然后就会按照我们之前拆分的 decribe 和 test 分批执行我们的用例了。"}),"\n",(0,c.jsxs)(s.h2,{id:"额外的启发",children:["额外的启发",(0,c.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#额外的启发",children:"#"})]}),"\n",(0,c.jsx)(s.p,{children:"在了解完原理后，其中我们可以得到一点启发，除了 Jest 黑盒的部分，像转译的部分其实是由我们来控制的，在性能上，转译还有优化的空间，除 babel 和 ts-jest 外，业内还提供有 esbuild-jest 和 @swc/jest，以 esbuild-jest 为例，它是基于 esbuild 来实现的 jest 转译工具。"}),"\n",(0,c.jsx)(s.p,{children:"Esbuild 有些同学可能已经比较熟悉了，它是基于 Go 开发的打包工具，不同于 JavaScript，Go 可以直接被编译为本地代码，所以性能上有极大的提升，下面我们以 esbuild-jest 为例介绍一下怎么优化转译，首先来安装一下依赖。"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:"npm i esbuild-jest --save-dev\n"})}),"\n",(0,c.jsx)(s.p,{children:"然后我们补充一下对应的转译配置，非 CRA 的同学可以把对应的配置加到 jest.config.js 中。"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{children:'// ./package.json\n"transform": {\n \xa0 \xa0"^.+\\.(t|j)sx?$": "esbuild-jest"\n },\n'})}),"\n",(0,c.jsx)(s.p,{children:"我们来执行一下用例，对比之前的 13s 执行时间，我们优化了整整 30%，现在用例数尚且不多，如果更多的用例，这个会更加明显！不过缺陷就是相比 babel 和 ts-jest ，esbuild-jest 和 @swc/jest 的社区相对还比较年轻，所以遇到一些特殊的问题（比如一些老的不合规的依赖，并没有 esm 的写法）可以不能立刻找到解决的办法，不过这并不妨碍我们在新项目中体验~如果遇到不能兼容的问题，我们再换回来就好。"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)("img",{src:a,alt:"img"})}),"\n",(0,c.jsxs)(s.h2,{id:"小结",children:["小结",(0,c.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,c.jsx)(s.p,{children:"这一节我们学习了 Jest 系统是如何实现的，简单来说，首先我们会经过一个前置工作的阶段，拿到所有的配置，并且构造出一个虚拟的文件系统用于热更新的 diff，接下来我们会找寻所有需要执行的用例，根据优先级和 CPU 的情况分给不同线程按顺序执行，执行的过程中，我们会经过转译和环境引擎编译的步骤，最后按照我们 describe 的架构和分组完成指定的用例。"}),"\n",(0,c.jsx)(s.p,{children:"除此之外，我们还介绍了一种让单元测试跑得更快的方式，因为 Jest 运行的过程中，虽然大部分是黑盒不可控的，但是其中转译的部分我们还有可以优化的空间，如果我们不使用 babel 而是换用 esbuild 等方案，那么在性能上会有不错的提升。虽然社区还比较年轻，但是尝试一下还是可以的~大不了兼容不了咱再换回去就是haha……"}),"\n",(0,c.jsx)(s.p,{children:"到这里单元测试的部分就已经全部介绍完了，不过在我们的需求中，仍然有一些单元测试难以覆盖的场景，比如滚动、跳转等比较复杂的场景，这些是不好模拟的，这时候就需要借助端对端测试（E2E)的方案来协助我们完成了, 下节课我们就来详细介绍一下什么是端对端测试，我们应该怎么展开对应的测试。"})]})}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,t.ah)(),e.components);return s?(0,c.jsx)(s,{...e,children:(0,c.jsx)(o,{...e})}):o(e)}let f=b;b.__RSPRESS_PAGE_META={},b.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B2%BE%E8%AE%B2%2F13.%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86%EF%BC%9AJest%20%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%95%B4%E4%B8%AA%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%B3%BB%E7%BB%9F%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"小彩蛋",id:"小彩蛋",depth:2},{text:"Jest 系统实现",id:"jest-系统实现",depth:2},{text:"额外的启发",id:"额外的启发",depth:2},{text:"小结",id:"小结",depth:2}],title:"13.深入原理：Jest 是怎么实现整个单元测试系统的？",headingTitle:"13.深入原理：Jest 是怎么实现整个单元测试系统的？",frontmatter:{}}}}]);