"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11310"],{408499:function(e,n,c){c.r(n),c.d(n,{default:()=>k});var s=c(552676),t=c(740453);let a=c.p+"static/image/6463b4ffb79fde3c88626223ae5ee706.8365e609.webp",d=c.p+"static/image/091876601d50c43bed5b3bdba3e71098.76a5a233.webp",r=c.p+"static/image/a14b7c12d3f6fe1367805ca6757cdec6.da749ef6.webp",o=c.p+"static/image/965ebfdfcf04820d9ad66e607a33a6c9.f1dad349.webp",i=c.p+"static/image/e5699ef6b29eda2136a194f99f8f7c79.15dae5d4.webp",l=c.p+"static/image/020d4df3384dc887855a8f5bca441b05.dce06bc0.webp",h=c.p+"static/image/f7cc6b067ed7d7015ceb1db8d90b0c3b.d47d4bd8.webp",p=c.p+"static/image/766dc8d546f3c276f57f298421dc0dda.3e1ef411.webp",u=c.p+"static/image/bbd79b417149188d5e6cc774c79873e8.2f822371.webp",x=c.p+"static/image/344e12c98d1efb194d9c2ce2ac7a79c7.6eb031dc.webp",j=c.p+"static/image/b0c7fedc58287ff3c02928ac576d3c49.1e044964.webp",f=c.p+"static/image/7e7bd4381962f84fb91cbddce2df1ca5.de8e6921.webp",m=c.p+"static/image/b9cf39758963059f447ec5b74823b9f4.2d3c4155.webp",g=c.p+"static/image/d0912907d1452081dee12fe9d7d4d5f2.b866c660.webp";function b(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",pre:"pre",img:"img",h4:"h4",blockquote:"blockquote"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"React"})," 早期的写法以 ",(0,s.jsx)(n.code,{children:"Class"})," 类组件为主，附带一些纯用于展示的函数组件，但是函数组件是不能控制自身的状态的。"]}),"\n",(0,s.jsxs)(n.p,{children:["直到 16.8 版本出来之后，引入了全新的 ",(0,s.jsx)(n.code,{children:"Hooks"})," 写法，这让之前的类写法就显得 比较累赘，函数组件的写法开始流行起来。函数组件引入了多种钩子函数如 ",(0,s.jsx)(n.code,{children:"useEffect"}),"、",(0,s.jsx)(n.code,{children:"useState"}),"、",(0,s.jsx)(n.code,{children:"useRef"}),"、",(0,s.jsx)(n.code,{children:"useCallback"}),"、",(0,s.jsx)(n.code,{children:"useMemo"}),"、",(0,s.jsx)(n.code,{children:"useReducer"})," 等等，通过这些钩子函数来管理函数组件的各自状态。"]}),"\n",(0,s.jsxs)(n.h2,{id:"正文",children:["正文",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正文",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本章节我会通过一个请求，带大家入门整个 ",(0,s.jsx)(n.code,{children:"React Hook"})," 知识体系。首先我们需要创建一个空项目，由于本实验采用的是 ",(0,s.jsx)(n.code,{children:"Vite 2.0"})," 作为脚手架工具，所以我们的 ",(0,s.jsx)(n.code,{children:"Node"})," 版本必须要在 ",(0,s.jsx)(n.code,{children:"12.0.0"})," 以上，目前我的版本是 ",(0,s.jsx)(n.code,{children:"12.6.0"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"我们通过指令新建一个联手项目，如下所示："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 11.前端预备：从一个数据请求，入门 React Hooks\nnpm init @vitejs/app hooks-demo --template react\n\n# npm 7+, 需要额外的双横线：\nnpm init @vitejs/app hooks-demo -- --template react\n\n# yarn\nyarn create @vitejs/app hooks-demo --template react\n"})}),"\n",(0,s.jsx)(n.p,{children:"根据你的需求，选择上述三个其中一个。新建之后项目目录如下所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install\nnpm run dev\n"})}),"\n",(0,s.jsx)(n.p,{children:"如下所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"看到如上述所示代表项目已经启动成功了。"}),"\n",(0,s.jsxs)(n.h4,{id:"usestate",children:["useState",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usestate",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["接下来我们清空 ",(0,s.jsx)(n.code,{children:"App.jsx"}),"，添加如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useState } from 'react'\n\nfunction App() {\n  const [data, setData] = useState([1, 2, 3, 4, 5])\n  return (\n    <div className=\"App\">\n      {\n        data.map((item, index) => <div key={index}>{item}</div>)\n      }\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsxs)(n.p,{children:["函数内声明变量，可以通过 ",(0,s.jsx)(n.code,{children:"useState"})," 方法，它接受一个参数，可以为默认值，也可以为一个函数。上述我们先分析默认值的情况，默认给一个数组 ",(0,s.jsx)(n.code,{children:"[1, 2, 3, 4, 5]"}),"，",(0,s.jsx)(n.code,{children:"data"})," 参数便可以直接在 ",(0,s.jsx)(n.code,{children:"JSX"})," 模板中使用。"]}),"\n",(0,s.jsxs)(n.h4,{id:"useeffect",children:["useEffect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#useeffect",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["此时，我们通过 ",(0,s.jsx)(n.code,{children:"useEffect"})," 副作用，请求一个接口数据，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState } from 'react'\n// 模拟数据接口，3 秒钟返回数据。\nconst getList = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve([6, 7, 8, 9, 10])\n    }, 3000)\n  })\n}\n\nfunction App() {\n  const [data, setData] = useState([1, 2, 3, 4, 5])\n\n  useEffect(() => {\n    (async () => {\n      const data = await getList()\n      console.log('data', data)\n      setData(data)\n    })()\n  })\n  return (\n    <div className=\"App\">\n      {\n        data.map((item, index) => <span key={index}>{item}</span>)\n      }\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsxs)(n.p,{children:["函数组件默认进来之后，会执行 ",(0,s.jsx)(n.code,{children:"useEffect"})," 中的回调函数，但是当 ",(0,s.jsx)(n.code,{children:"setData"})," 执行之后，",(0,s.jsx)(n.code,{children:"App"})," 组件再次刷新，刷新之后会再次执行 ",(0,s.jsx)(n.code,{children:"useEffect"})," 的回调函数，这便会形成一个可怕的死循环，回调函数会一直被这样执行下去。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["所以这里引出 ",(0,s.jsx)(n.code,{children:"useEffect"})," 的第二个参数。它是一个数组，数组内接收回调函数内使用到的状态参数，一旦在组件内改变了状态参数，则会触发副作用 ",(0,s.jsx)(n.code,{children:"useEffect"})," 的回调函数执行。"]}),"\n",(0,s.jsxs)(n.p,{children:["所以我们如果传一个空数组 ",(0,s.jsx)(n.code,{children:"[]"}),"，则该副作用只会在组件渲染的时候，执行一次，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"useEffect(() => {\n  (async () => {\n    const data = await getList()\n    console.log('data', data)\n    setData(data)\n  })()\n}, [])\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"执行一次之后，副作用不再被触发。"}),"\n",(0,s.jsxs)(n.p,{children:["此时我们需要给请求一个 ",(0,s.jsx)(n.code,{children:"query"})," 参数，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState } from 'react'\n\nconst getList = (query) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('query', query)\n      resolve([6, 7, 8, 9, 10])\n    }, 3000)\n  })\n}\n\nfunction App() {\n  const [data, setData] = useState([1, 2, 3, 4, 5])\n  const [query, setQuery] = useState('')\n\n  useEffect(() => {\n    (async () => {\n      const data = await getList(query)\n      console.log('data', data)\n      setData(data)\n    })()\n  }, [query])\n  return (\n    <div className=\"App\">\n      {\n        data.map((item, index) => <span key={index}>{item}</span>)\n      }\n      <input onChange={(e) => setQuery(e.target.value)} type=\"text\" placeholder='请输入搜索值' />\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此时我们改变 ",(0,s.jsx)(n.code,{children:"query"})," 的值，副作用函数便会被执行，如下所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["所以，如果你的接口有查询参数，可以将参数设置在 ",(0,s.jsx)(n.code,{children:"useEffect"})," 的第二个参数的数组值中，这样改变查询变量的时候，副作用便会再次触发执行，相应的函数也会重新带着最新的参数，获取接口数据。"]}),"\n",(0,s.jsxs)(n.h4,{id:"自定义-hook",children:["自定义 Hook",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义-hook",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们可以将上述的请求，抽离成一个自定义 ",(0,s.jsx)(n.code,{children:"hook"}),"，方便在多个地方调用，新建 ",(0,s.jsx)(n.code,{children:"useApi.js"})," 如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState } from 'react'\n// 模拟请求\nconst getList = (query) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('query', query)\n      resolve([6, 7, 8, 9, 10])\n    }, 3000)\n  })\n}\n// 自定义 hook\nconst useApi = () => {\n  const [data, setData] = useState([1, 2, 3, 4, 5])\n  const [query, setQuery] = useState('')\n\n  useEffect(() => {\n    (async () => {\n      const data = await getList()\n      console.log('data', data)\n      setData(data)\n    })()\n  }, [query])\n\n  return [{ data }, setQuery];\n}\n\nexport default useApi\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上述所示，最终将 ",(0,s.jsx)(n.code,{children:"data"})," 数据，和设置请求参数的方法抛出，在 ",(0,s.jsx)(n.code,{children:"App.jsx"})," 中做如下改动："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React from 'react'\nimport useApi from './useApi'\n\nfunction App() {\n  const [{ data }, setQuery] = useApi()\n  return (\n    <div className=\"App\">\n      {\n        data.map((item, index) => <span key={index}>{item}</span>)\n      }\n      <input onChange={(e) => setQuery(e.target.value)} type=\"text\" placeholder='请输入搜索值' />\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们查看浏览器展示结果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["上述这类自定义 ",(0,s.jsx)(n.code,{children:"Hook"})," 的使用，在开发中也非常常见，比如有一个请求公共数据的接口，在多个页面中被重复使用，你便可通过自定义 ",(0,s.jsx)(n.code,{children:"Hook"})," 的形式，将请求逻辑提取出来公用，这也是之前 ",(0,s.jsx)(n.code,{children:"Class"})," 类组件所不能做到的。"]}),"\n",(0,s.jsxs)(n.h4,{id:"usememo",children:["useMemo",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usememo",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们修改 ",(0,s.jsx)(n.code,{children:"App.jsx"}),"，在内部新增一个子组件，子组件接收父组件传进来的一个对象，作为子组件的 ",(0,s.jsx)(n.code,{children:"useEffect"})," 的第二个依赖参数。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState } from 'react'\n\nfunction Child({ data }) {\n  useEffect(() => {\n    console.log('查询条件：', data)\n  }, [data])\n\n  return <div>子组件</div>\n}\n\n\nfunction App() {\n  const [name, setName] = useState('')\n  const [phone, setPhone] = useState('')\n  const [kw, setKw] = useState('')\n\n  const data = {\n    name,\n    phone\n  }\n\n  return (\n    <div className=\"App\">\n      <input onChange={(e) => setName(e.target.value)} type=\"text\" placeholder='请输入姓名' />\n      <input onChange={(e) => setPhone(e.target.value)} type=\"text\" placeholder='请输入电话' />\n      <input onChange={(e) => setKw(e.target.value)} type=\"text\" placeholder='请输入关键词' />\n      <Child data={data} />\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当我们修改姓名和电话的时候，观察子组件是否监听到依赖的变化，执行 ",(0,s.jsx)(n.code,{children:"useEffect"})," 内的回调函数。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["此时，上述的结果是我们预期的，我们只监听了 ",(0,s.jsx)(n.code,{children:"name"})," 和 ",(0,s.jsx)(n.code,{children:"phone"})," 两个参数，但是我们修改关键词输入框，会得到下面的结果。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["子组件并没有监听 ",(0,s.jsx)(n.code,{children:"kw"})," 的变化，但是结果却是子组件也被触发渲染了。原因其实是我们在父组件重新 ",(0,s.jsx)(n.code,{children:"setKw"})," 之后，",(0,s.jsx)(n.code,{children:"data"})," 值和未作修改 ",(0,s.jsx)(n.code,{children:"kw"})," 前的值已经不一样了。你可能会说，",(0,s.jsx)(n.code,{children:"data"})," 的值并没有变化，为什么说它已经不一样了呢？详细的分析我们放在后续部分，我们此时可以通过 ",(0,s.jsx)(n.code,{children:"useMemo"})," 将 ",(0,s.jsx)(n.code,{children:"data"})," 包装一下，告诉 ",(0,s.jsx)(n.code,{children:"data"})," 它需要监听的值。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState, useMemo } from 'react'\n\nfunction Child({ data }) {\n  useEffect(() => {\n    console.log('查询条件：', data)\n  }, [data])\n\n  return <div>子组件</div>\n}\n\n\nfunction App() {\n\n  const [name, setName] = useState('')\n  const [phone, setPhone] = useState('')\n  const [kw, setKw] = useState('')\n\n  const data = useMemo(() => ({\n    name,\n    phone\n  }), [name, phone])\n\n  return (\n    <div className=\"App\">\n      <input onChange={(e) => setName(e.target.value)} type=\"text\" placeholder='请输入姓名' />\n      <input onChange={(e) => setPhone(e.target.value)} type=\"text\" placeholder='请输入电话' />\n      <input onChange={(e) => setKw(e.target.value)} type=\"text\" placeholder='请输入关键词' />\n      <Child data={data} />\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsx)(n.p,{children:"效果如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["这便是 ",(0,s.jsx)(n.code,{children:"useMemo"})," 的作用，它相当于把父组件需要传递的参数做了一个标记，无论父组件其他状态更新任何值，都不会影响要传递给子组件的对象。"]}),"\n",(0,s.jsxs)(n.h4,{id:"usecallback",children:["useCallback",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#usecallback",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["同理，",(0,s.jsx)(n.code,{children:"useCallback"})," 也是和 ",(0,s.jsx)(n.code,{children:"useMemo"})," 有类似的功能，比如我们传递一个函数给子组件，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState, useCallback } from 'react'\n\nfunction Child({ callback }) {\n  useEffect(() => {\n    callback()\n  }, [callback])\n\n  return <div>子组件</div>\n}\n\n\nfunction App() {\n\n  const [name, setName] = useState('')\n  const [phone, setPhone] = useState('')\n  const [kw, setKw] = useState('')\n\n  const callback = () => {\n    console.log('我是callback')\n  }\n\n  return (\n    <div className=\"App\">\n      <input onChange={(e) => setName(e.target.value)} type=\"text\" placeholder='请输入姓名' />\n      <input onChange={(e) => setPhone(e.target.value)} type=\"text\" placeholder='请输入电话' />\n      <input onChange={(e) => setKw(e.target.value)} type=\"text\" placeholder='请输入关键词' />\n      <Child callback={callback} />\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsxs)(n.p,{children:["当我们修改任何状态值，都会触发子组件的回调函数执行，但是 ",(0,s.jsx)(n.code,{children:"callback"})," 没有作任何变化。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["此时，我们给要传递的函数，包裹一层 ",(0,s.jsx)(n.code,{children:"useCallback"}),"，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const callback = useCallback(() => {\n  console.log('我是callback')\n}, [])\n"})}),"\n",(0,s.jsx)(n.p,{children:"无论修改其他任何属性，都不会触发子组件的副作用："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["useCallback 的第二个参数同 ",(0,s.jsx)(n.code,{children:"useEffect"})," 和 ",(0,s.jsx)(n.code,{children:"useMemo"})," 的第二个参数，它是用于监听你需要监听的变量，如在数组内添加 ",(0,s.jsx)(n.code,{children:"name"}),"、",(0,s.jsx)(n.code,{children:"phone"}),"、",(0,s.jsx)(n.code,{children:"kw"})," 等参数，当改变其中有个，都会触发子组件副作用的执行。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["所以，",(0,s.jsx)(n.code,{children:"useMemo"})," 和 ",(0,s.jsx)(n.code,{children:"useCallback"}),"，都能为「重复渲染」这个问题，提供很好的帮助。"]}),"\n",(0,s.jsxs)(n.h2,{id:"重新认识-useeffect",children:["重新认识 useEffect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重新认识-useeffect",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上述很多现象，都是因为你没有很好地去理解 ",(0,s.jsx)(n.code,{children:"React Hooks"})," 函数组件写法的渲染机制。通过一个小例子，我们来重新认识 ",(0,s.jsx)(n.code,{children:"useEffect"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们将上述 ",(0,s.jsx)(n.code,{children:"App.jsx"})," 作如下修改："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState } from 'react'\n\nfunction App() {\n  const [count, setCount] = useState(0)\n  \n  const handleClick = () => {\n    setTimeout(() => {\n      console.log('点击次数: ' + count);\n    }, 3000);\n  }\n\n  return (\n    <div className=\"App\">\n      <button onClick={() => setCount(count + 1)}>点击{count}次</button>\n      <button onClick={handleClick}>展示点击次数</button>\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们作下列几个动作："}),"\n",(0,s.jsxs)(n.p,{children:["1、点击增加按钮两次，将 ",(0,s.jsx)(n.code,{children:"count"})," 增加到 2。"]}),"\n",(0,s.jsx)(n.p,{children:"2、点击「展示点击次数」。"}),"\n",(0,s.jsxs)(n.p,{children:["3、在 ",(0,s.jsx)(n.code,{children:"console.log"})," 执行之前，也就是 3 秒内，再次点击新增按钮 2 次，将 ",(0,s.jsx)(n.code,{children:"count"})," 增加到 4。"]}),"\n",(0,s.jsxs)(n.p,{children:["按照正常的思路，浏览器应该打印出 ",(0,s.jsx)(n.code,{children:"点击次数: 4"}),"，我们来查看浏览器的展示效果："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["点击「展示点击次数」按钮，3 秒后，我们看到的结果是 ",(0,s.jsx)(n.code,{children:"点击次数: 2"}),"，这与我们的预期有出入。"]}),"\n",(0,s.jsxs)(n.p,{children:["函数组件 ",(0,s.jsx)(n.code,{children:"App"}),"，在每一次渲染都会被调用，而每一次调用都会形成一个独立的上下文，可以理解成一个快照。每一次渲染形成的快照，都是互相独立的。"]}),"\n",(0,s.jsxs)(n.p,{children:["默认进来的时候，形成一个快照，此时 ",(0,s.jsx)(n.code,{children:"count"})," 为 0；当我们点击新增按钮第一次，执行 ",(0,s.jsx)(n.code,{children:"setCount"}),"，函数组件被刷新一次，此时的快照中，",(0,s.jsx)(n.code,{children:"count"})," 为 1；再次点击按钮，再次生成快照，此时的 ",(0,s.jsx)(n.code,{children:"count"})," 为 2，此时点击 「展示点击次数」按钮，在这份快照中，我们的 ",(0,s.jsx)(n.code,{children:"count"})," 参数就是 2。所以我们后面无论怎么新增 ",(0,s.jsx)(n.code,{children:"count"}),"，最终输出的结果 ",(0,s.jsx)(n.code,{children:"count"})," 就是 2。"]}),"\n",(0,s.jsx)(n.p,{children:"我们用一份伪代码来解释，大致如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 默认初始化\nfunction App() {\n  const count = 0; // useState 返回默认值\n  // ...\n  function handleClick() {\n    setTimeout(() => {\n      console.log('点击次数: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// 第一次点击\nfunction App() {\n  const count = 1; // useState 返回值\n  // ...\n  function handleClick() {\n    setTimeout(() => {\n      console.log('点击次数: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n\n// 第二次点击\nfunction App() {\n  const count = 2; // useState 返回值\n  // ...\n  function handleAlertClick() {\n    setTimeout(() => {\n      console.log('点击次数: ' + count);\n    }, 3000);\n  }\n  // ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述代码中，第二次点击的快照中，",(0,s.jsx)(n.code,{children:"console.log('点击次数: ' + count);"})," 取的便是 ",(0,s.jsx)(n.code,{children:"const count = 2"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["同理，我们可以直到，每次渲染函数组件时，",(0,s.jsx)(n.code,{children:"useEffect"})," 都是新的，都是不一样的。我们对上面的写法稍作改动。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React, { useEffect, useState } from 'react'\n\nfunction App() {\n  const [count, setCount] = useState(0)\n  \n  useEffect(() => {\n    setTimeout(() => {\n      console.log('点击次数: ' + count);\n    }, 3000);\n  })\n\n  return (\n    <div className=\"App\">\n      <button onClick={() => setCount(count + 1)}>点击{count}次</button>\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["每一次点击，都会重新执行 ",(0,s.jsx)(n.code,{children:"useEffect"})," 内的回调，并且 ",(0,s.jsx)(n.code,{children:"count"})," 值也是当时的快照的一个常量值。"]}),"\n",(0,s.jsx)(n.p,{children:"这和之前的类组件是不同的，我们改成类组件的实现形式如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import React from 'react'\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      count: 0\n    }\n  }\n  componentDidUpdate() {\n    setTimeout(() => {\n      console.log('点击次数: ' + this.state.count);\n    }, 3000);\n  }\n\n  render() {\n    return <button onClick={() => this.setState({ count: this.state.count + 1 })}>点击{this.state.count}次</button>\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["类组件，声明之后，会在内部生成一个实例 ",(0,s.jsx)(n.code,{children:"instance"}),"，所有的数据都会存在类的上下文中，所以 ",(0,s.jsx)(n.code,{children:"this.state.count"})," 会一直指向最新的 ",(0,s.jsx)(n.code,{children:"count"})," 值。"]}),"\n",(0,s.jsxs)(n.p,{children:["说到这里，大家应该对 ",(0,s.jsx)(n.code,{children:"React Hooks"})," 的函数组件写法有了新的认识。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["行文至此，希望让同学们能好好地阅读和学习本章节的内容，以及课后对 ",(0,s.jsx)(n.code,{children:"React Hooks"})," 的拓展。更好的理解它，有助于写出可维护、可拓展的代码，技术本身是服务于业务需求的，但是你不能很好的利用技术的特点，那业务也很难达到做满意的效果。"]})]})}function E(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}let k=E;E.__RSPRESS_PAGE_META={},E.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F11.%E5%89%8D%E7%AB%AF%E9%A2%84%E5%A4%87%EF%BC%9A%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%85%A5%E9%97%A8%20React%20Hooks.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"正文",id:"正文",depth:2},{text:"useState",id:"usestate",depth:4},{text:"useEffect",id:"useeffect",depth:4},{text:"自定义 Hook",id:"自定义-hook",depth:4},{text:"useMemo",id:"usememo",depth:4},{text:"useCallback",id:"usecallback",depth:4},{text:"重新认识 useEffect",id:"重新认识-useeffect",depth:2},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);