"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["1292"],{363227:function(e,n,r){r.r(n),r.d(n,{default:()=>u});var t=r(552676),a=r(740453);let s=r.p+"static/image/c01f3667338b32759aef46f3334fd32a.85da04a0.webp",c=r.p+"static/image/64dacc1b4453039afbb5e1343c1c6ee2.7ce40c33.webp",i=r.p+"static/image/3656351947bf1773fe2a4ce8cd9708fd.1eea4365.webp",o=r.p+"static/image/e3df5e1a07234b0953df47e59e356a62.83813917.webp",d=r.p+"static/image/ad9f10f08fe52abae803ba1cbf7b1932.f9dfeacf.webp",l=r.p+"static/image/e0a5e0f95e7a45c0aeb069bd96fcce3f.a3a3b3b3.webp",m=r.p+"static/image/c74fa34e61a3cc569342c30f3bb707ae.d9a2b30e.webp",h=r.p+"static/image/359461dc41acccda02191f255dbe16db.b6912a5f.webp",p=r.p+"static/image/cad824cdb0cc0d9c5f595959347716cb.5d026b6c.webp",x=r.p+"static/image/9ab8d2eca4022b9e8bcb95d8cb3c837f.4376e952.webp",j=r.p+"static/image/824a2c19d4ab255f0dee4fbdb4ae9dcb.a96439dc.webp";function g(e){let n=Object.assign({h2:"h2",a:"a",p:"p",pre:"pre",code:"code",h3:"h3",img:"img",ul:"ul",li:"li",ol:"ol"},(0,a.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"前言",children:["前言",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。它通常用于在网站和博客上编写内容。比如当你这样书写："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-markdown",children:"**love** using [Next.js](https://nextjs.org/)\n"})}),"\n",(0,t.jsx)(n.p,{children:"对应输出为："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["而 ",(0,t.jsx)(n.a,{href:"https://mdxjs.com/",target:"_blank",rel:"noopener noreferrer",children:"MDX"})," 是 Markdown 的超集，不仅支持 Markdown 本身，还支持在 Markdown 文档中插入 JSX 代码，还可以导入（import）组件，添加交互内容。"]}),"\n",(0,t.jsx)(n.p,{children:"实际上，MDX 可以看作是一种融合了 markdown 和 JSX 的格式，就像下面这个示例："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-markdown",children:'# 30.配置篇 _ MDX\n\n<div className="note">\n  > Some notable things in a block quote!\n</div>\n'})}),"\n",(0,t.jsx)(n.p,{children:"在这个例子中，标题是 markdown 格式，而那些类似 HTML 的标签则是 JSX 格式。markdown 侧重于编写内容，JSX 侧重于组件添加交互性，看起来是不是很棒？"}),"\n",(0,t.jsx)(n.p,{children:"而 Next.js 既可以支持本地的 MDX 内容，也可以支持服务端动态获取 MDX 文件。Next.js 插件会将 markdown 和 React 组件转换为 HTML。"}),"\n",(0,t.jsx)(n.p,{children:"那就让我们赶紧看看该如何使用 MDX 吧！"}),"\n",(0,t.jsxs)(n.h2,{id:"1-本地-mdx",children:["1. 本地 MDX",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-本地-mdx",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["本地使用  MDX 需要借助 ",(0,t.jsx)(n.code,{children:"@next/mdx"}),"这个包，它从本地文件中获取数据，能够处理 markdown 和 MDX。你需要在 ",(0,t.jsx)(n.code,{children:"/pages"})," 或者",(0,t.jsx)(n.code,{children:"/app"})," 目录下创建一个以 ",(0,t.jsx)(n.code,{children:".mdx"}),"为扩展名的页面文件。具体的配置和用法如下："]}),"\n",(0,t.jsxs)(n.h3,{id:"11-开始配置",children:["1.1. 开始配置",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-开始配置",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"安装渲染 MDX 相关的包："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在应用根目录（",(0,t.jsx)(n.code,{children:"app/"})," 和 ",(0,t.jsx)(n.code,{children:"src/"})," 的父级）创建一个名为 ",(0,t.jsx)(n.code,{children:"mdx-components.js"})," 的文件，这个文件是在 App Router 中使用 MDX 必须要用到的，没有这个文件会无法正常工作。文件的代码为："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// mdx-components.js\nexport function useMDXComponents(components) {\n  return {\n    ...components,\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后更新 ",(0,t.jsx)(n.code,{children:"next.config.js"}),"文件："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nconst withMDX = require('@next/mdx')()\n \n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx']\n}\n \nmodule.exports = withMDX(nextConfig)\n"})}),"\n",(0,t.jsx)(n.p,{children:"基本配置就完毕了。"}),"\n",(0,t.jsxs)(n.h3,{id:"12-基本用法",children:["1.2. 基本用法",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-基本用法",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["现在在 ",(0,t.jsx)(n.code,{children:"/app"})," 目录下创建一个 MDX 页面："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  your-project\n  ├── app\n  │   └── my-mdx-page\n  │       └── page.mdx\n  └── package.json\n"})}),"\n",(0,t.jsx)(n.p,{children:"现在你可以在 MDX 页面使用 markdown 和导入 React 组件："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import ComponentA from '../components/a'\n \n# Welcome to my MDX page!\n \nThis is some **bold** and _italics_ text.\n \nThis is a list in markdown:\n \n- One\n- Two\n- Three\n \nCheckout my React component:\n \n<ComponentA />\n"})}),"\n",(0,t.jsxs)(n.p,{children:["打开 ",(0,t.jsx)(n.code,{children:"/my-mdx-page"})," 查看渲染的结果："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h2,{id:"2-远程-mdx",children:["2. 远程 MDX",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-远程-mdx",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"如果你的 markdown 或者 MDX 文件位于其他位置，你可以在服务端动态获取它，有两个常用的社区包用于获取 MDX 内容："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/hashicorp/next-mdx-remote#react-server-components-rsc--nextjs-app-directory-support",target:"_blank",rel:"noopener noreferrer",children:"next-mdx-remote"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.contentlayer.dev/",target:"_blank",rel:"noopener noreferrer",children:"contentlayer"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"使用外部内容的时候要注意，因为 MDX 会编译成 JavaScript，并且在服务端执行。所以你应该从信任的地方获取 MDX 内容，否则可能导致“远程代码执行”（remote code execution，简写：RCE，让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统）"}),"\n",(0,t.jsxs)(n.p,{children:["下面的例子中使用了 ",(0,t.jsx)(n.code,{children:"next-mdx-remote"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// app/my-mdx-page-remote/page.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\n// app/page.js\nexport default function Home() {\n  return (\n    <MDXRemote\n      source={`# Hello World\n\n      This is from Server Components!\n      `}\n    />\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["当然这个例子中，没有远程获取，而是直接使用了 mdx 文本，打开 ",(0,t.jsx)(n.code,{children:"/my-mdx-page-remote"})," 查看渲染的 MDX："]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)("img",{src:x,alt:"image.png"}),"\n结合远程获取的示例代码为："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// app/my-mdx-page-remote/page.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n \nexport default async function RemoteMdxPage() {\n  // MDX 文本\n  const res = await fetch('https://...')\n  const markdown = await res.text()\n  return <MDXRemote source={markdown} />\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"那你可能要问，组件呢？组件怎么传进去？一个示例代码如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// app/my-mdx-page-remote/page.js\nimport { MDXRemote } from 'next-mdx-remote/rsc'\n\nimport ComponentA from '../components/a'\n\nconst components = { ComponentA }\n\nexport default function Home(props) {\n  return (\n    <MDXRemote\n      source={`Some **mdx** text, with a component <ComponentA />`}\n      components={components}\n    />\n  )\n}\n\n"})}),"\n",(0,t.jsx)(n.p,{children:"ComponentA 的组件代码很简单："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// app/components/a.js\nexport default function Page() {\n  return <span>Hello World!</span>\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["打开 ",(0,t.jsx)(n.code,{children:"/my-mdx-page-remote"})," 查看渲染的 MDX："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h2,{id:"3-共享布局",children:["3. 共享布局",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-共享布局",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"要在 MDX 页面之间共享布局，你可以使用 App Router 内置的布局功能："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// app/my-mdx-page/layout.js\nexport default function MdxLayout({ children }) {\n  return <div style={{ color: 'blue' }}>{children}</div>\n}\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"4-使用插件拓展功能",children:["4. 使用插件拓展功能",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-使用插件拓展功能",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"如果 MDX 样式和功能并不能满足你的要求，那你可能就需要自定义使用和开发插件了。为了帮助你了解如何使用和开发插件，你需要先了解下 MDX 的原理。"}),"\n",(0,t.jsx)(n.p,{children:"简单的来说，MDX 的编译分为两步，一步处理 Markdown，一步处理 HTML。处理的伪代码如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { unified } from 'unified'\nimport remarkParse from 'remark-parse'\nimport remarkRehype from 'remark-rehype'\nimport rehypeSanitize from 'rehype-sanitize'\nimport rehypeStringify from 'rehype-stringify'\n \nmain()\n \nasync function main() {\n  const file = await unified()\n    .use(remarkParse) // 将 markdown 转换为 markdown AST\n    .use(remarkRehype) // 转换为 HTML AST\n    .use(rehypeSanitize) // HTML 消毒，处理不安全的内容，防止 XSS 攻击\n    .use(rehypeStringify) // 将 AST 转换为 HTML\n    .process('Hello, Next.js!')\n \n  console.log(String(file)) // <p>Hello, Next.js!</p>\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["处理 Markdown 的这部分工具体系统称为 ",(0,t.jsx)(n.a,{href:"https://github.com/remarkjs/remark",target:"_blank",rel:"noopener noreferrer",children:"Remark"}),"，处理 HTML 的这部分工具体系统称为 ",(0,t.jsx)(n.a,{href:"https://github.com/rehypejs/rehype",target:"_blank",rel:"noopener noreferrer",children:"Rehype"}),"。Remark 和 Rehype 目前已经有不少的生态插件，比如",(0,t.jsx)(n.a,{href:"https://github.com/atomiks/rehype-pretty-code",target:"_blank",rel:"noopener noreferrer",children:"语法高亮（rehype-pretty-code）"}),"、",(0,t.jsx)(n.a,{href:"https://github.com/rehypejs/rehype-autolink-headings",target:"_blank",rel:"noopener noreferrer",children:"标题自动链接（rehype-autolink-headings）"}),"、",(0,t.jsx)(n.a,{href:"https://github.com/remarkjs/remark-toc",target:"_blank",rel:"noopener noreferrer",children:"生成目录（remark-toc）"}),"等。"]}),"\n",(0,t.jsxs)(n.p,{children:["如果你想直接使用这些插件，就比如支持 ",(0,t.jsx)(n.a,{href:"https://github.github.com/gfm/",target:"_blank",rel:"noopener noreferrer",children:"GFM"}),"（GitHub Flavored Markdown，目前最流行的 Markdown 扩展语法，它提供了包括表格、任务列表、删除线、围栏代码、Emoji 等在内的标记语法），对应插件是 ",(0,t.jsx)(n.a,{href:"https://github.com/remarkjs/remark-gfm",target:"_blank",rel:"noopener noreferrer",children:"remark-gfm"}),"，可以通过修改 ",(0,t.jsx)(n.code,{children:"next.config.js"})," 来加载插件。"]}),"\n",(0,t.jsxs)(n.p,{children:["不过因为 remark 和 rehype 都是 ESM（ECMAScript modules），你需要使用 ",(0,t.jsx)(n.code,{children:"next.config.mjs"})," 作为配置文件："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// next.config.mjs\nimport remarkGfm from 'remark-gfm'\nimport createMDX from '@next/mdx'\n \n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],\n}\n \nconst withMDX = createMDX({\n  // 添加 markdown 插件\n  options: {\n    remarkPlugins: [remarkGfm],\n    rehypePlugins: [],\n  },\n})\n\nexport default withMDX(nextConfig)\n"})}),"\n",(0,t.jsx)(n.p,{children:"GFM 新增了删除线语法："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-markdown",children:"~~这是一段删除文字~~\n"})}),"\n",(0,t.jsx)(n.p,{children:"如果不使用 GFM 插件，无法渲染成删除线："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"使用后则会正常渲染："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h2,{id:"5-自定义元素",children:["5. 自定义元素",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-自定义元素",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"正常我们书写 markdown，比如写个标题："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-markdown",children:"# header\n"})}),"\n",(0,t.jsx)(n.p,{children:"对应 HTML 输出为："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<h1>header</h1>\n"})}),"\n",(0,t.jsx)(n.p,{children:"如果我们希望自定义这个输出的结果以及样式，该怎么实现呢？"}),"\n",(0,t.jsxs)(n.p,{children:["为了实现这个功能，打开应用根目录定义的 ",(0,t.jsx)(n.code,{children:"mdx-components.js"}),"文件，然后添加自定义元素："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// mdx-components.js\nimport Image from 'next/image'\n \nexport function useMDXComponents(components) {\n  return {\n    h1: ({ children }) => <h1 style={{ fontSize: '30px' }}>{children}</h1>,\n    ...components,\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"此时的效果为："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["那么问题来了，我怎么知道 markdown 语法都对应的什么标签呢？又可以修改哪些标签呢？这个可以查看 MDX 的文档：",(0,t.jsx)(n.a,{href:"https://mdxjs.com/table-of-components/",target:"_blank",rel:"noopener noreferrer",children:"https://mdxjs.com/table-of-components/"})]}),"\n",(0,t.jsxs)(n.p,{children:["这里要注意的是当使用 img 的时候，如果直接使用 ",(0,t.jsx)(n.code,{children:"![]()"}),"语法，加载本地图片，并不会成功："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["为了加载成功，需要使用 ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/remark-mdx-images",target:"_blank",rel:"noopener noreferrer",children:"remark-mdx-images"})," 这个插件，安装插件后，修改 ",(0,t.jsx)(n.code,{children:"next.config.mjs"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// next.config.mjs\nimport remarkGfm from 'remark-gfm'\nimport createMDX from '@next/mdx'\nimport remarkMdxImages from \"remark-mdx-images\";\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],\n}\n \nconst withMDX = createMDX({\n  // 添加 markdown 插件\n  options: {\n    remarkPlugins: [remarkGfm, remarkMdxImages],\n    rehypePlugins: [],\n  },\n})\n\nexport default withMDX(nextConfig)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["再修改 ",(0,t.jsx)(n.code,{children:"mdx-components.js"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// mdx-components.js\nimport Image from 'next/image'\n \nexport function useMDXComponents(components) {\n  return {\n    h1: ({ children }) => <h1 style={{ fontSize: '30px' }}>{children}</h1>,\n    img: (props) => (\n      <Image\n        sizes=\"100vw\"\n        style={{ width: '100%', height: 'auto' }}\n        {...props}\n      />\n    ),\n    ...components,\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"此时图片即可正常加载："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,t.jsxs)(n.h2,{id:"6-frontmatter",children:["6. Frontmatter",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-frontmatter",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"Frontmatter 是一个类似于 YAML 的键值对结构，用于储存页面相关的数据。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-markdown",children:"---\ntitle: 你好世界\ncreated: 2023-11-18\n---\nHello World!\n"})}),"\n",(0,t.jsxs)(n.p,{children:["默认情况下，",(0,t.jsx)(n.code,{children:"@next/mdx"}),"并不支持 frontmatter，但社区有很多解决方案，比如："]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/remarkjs/remark-frontmatter",target:"_blank",rel:"noopener noreferrer",children:"remark-frontmatter"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/jonschlinkert/gray-matter",target:"_blank",rel:"noopener noreferrer",children:"gray-matter"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["我们以 ",(0,t.jsx)(n.a,{href:"https://github.com/remarkjs/remark-frontmatter",target:"_blank",rel:"noopener noreferrer",children:"remark-frontmatter"})," 为例进行讲解，当搭配 MDX 的时候，还需要使用 ",(0,t.jsx)(n.a,{href:"https://github.com/remcohaszing/remark-mdx-frontmatter",target:"_blank",rel:"noopener noreferrer",children:"remark-mdx-frontmatter"}),"。"]}),"\n",(0,t.jsx)(n.p,{children:"首先安装依赖："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install remark-frontmatter remark-mdx-frontmatter\n"})}),"\n",(0,t.jsxs)(n.p,{children:["然后修改 ",(0,t.jsx)(n.code,{children:"next.config.mjs"}),"："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import remarkGfm from 'remark-gfm'\nimport createMDX from '@next/mdx'\nimport remarkMdxImages from \"remark-mdx-images\";\nimport remarkFrontmatter from 'remark-frontmatter'\nimport remarkMdxFrontmatter from 'remark-mdx-frontmatter'\n\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],\n}\n \nconst withMDX = createMDX({\n  // 添加 markdown 插件\n  options: {\n    remarkPlugins: [\n      remarkGfm, \n      remarkMdxImages,\n      [remarkFrontmatter],\n      [remarkMdxFrontmatter]\n    ],\n    rehypePlugins: [],\n  },\n})\n\nexport default withMDX(nextConfig)\n"})}),"\n",(0,t.jsx)(n.p,{children:"基本配置就完成了，但是要注意，这两个插件的效果并不是像我们写 VuePress 中的 md 文档一样，可以用 frontmatter 中的数据定义页面的标题等数据，我们现在建立一个 mdx 文档："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-markdown",children:"---\ntitle: 这是文章标题\nauthor: 冴羽\n---\n\n# header1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["页面不会有什么变化，页面的标题不会变成 frontmatter 中设置的这个标题，也不会输出 ",(0,t.jsx)(n.code,{children:'<meta name="author" content="冴羽">'}),"这种 HTML 标签，这两个插件的作用就是储存元数据，用转换后的 JS 描述就是："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export const frontmatter = {\n  title: '这是文章标题'，\n  author: '冴羽'\n}\n\nexport default function MDXContent() {\n  return <h1>header1</h1>\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["也就是说，使用这两个插件后，如果导入这个 MDX 文档，会有一个 frontmatter 导出对象，让你能够获取到在 MDX 文档中通过 frontmatter 格式设置的值，仅此而已。我们新建一个 ",(0,t.jsx)(n.code,{children:"page.js"}),"验证一下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import {frontmatter} from '../my-mdx-page/page.mdx'\n\nexport default function Page() {\n  console.log(frontmatter)\n  return  <h1>Hello World!</h1>\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"可以看命令行中看到输出："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"那你可能想，这有什么用呢？"}),"\n",(0,t.jsxs)(n.p,{children:["这可以为我们的开发提供很多便利。试想我们开发一个博客功能，在 ",(0,t.jsx)(n.code,{children:"contents"})," 文件夹下建立多个 MDX 文档，作为我们的博客内容。当我们访问比如 ",(0,t.jsx)(n.code,{children:"article/1"}),"的时候，导入对应 id 的 MDX 文档，然后获取其中的元数据，渲染通用的一些展示内容，比如标题、作者、更新时间、标签等，这不就是一个很实用的功能嘛~"]}),"\n",(0,t.jsx)(n.p,{children:"当然这样说有些抽象，我们简单写个 demo，文件目录结构如下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  your-project\n  ├── app\n  │   └── content\n  │       └── 1.mdx\n  │   └── article\n  │       └── [id]\n	│       		└── page.js\n  └── package.json\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"app/content/1.mdx"}),"的内容如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-markdown",children:"---\ntitle: Next.js 小册\nauthor: 冴羽\n---\n\n# 一级标题\n\n这是正文内容\n"})}),"\n",(0,t.jsxs)(n.p,{children:["这是我们要获取的文章具体内容。",(0,t.jsx)(n.code,{children:"article/[id]/page.js"}),"的代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// article/[id]/page.js\nexport default async function Page({ params: {id} }) {\n  const articleModule = await import(`../../content/${id}.mdx`);\n  const { default: Component, frontmatter: {title, author} } = articleModule;\n\n  return (\n    <main>\n       <div>文章标题：{title}</div>\n       <div>文章作者：{author}</div>\n       <Component /> \n    </main>\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["在这个例子中，我们通过 import() 获取到了模块内容，然后解构出了 frontmatter 对象和页面内容组件。打开 ",(0,t.jsx)(n.code,{children:"http://localhost:3000/article/1"}),"，渲染的结果为："]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,t.jsxs)(n.p,{children:["当然了，如果你对 frontmatter 没有那么热爱，其实你也可以直接在",(0,t.jsx)(n.code,{children:".mdx"})," 文件导出一个 meta 对象，示例代码如下："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export const meta = {\n  title: 'Next.js 小册',\n  author: '冴羽'\n}\n\n# 一级标题\n\n这是正文内容\n"})}),"\n",(0,t.jsxs)(n.p,{children:["修改下 ",(0,t.jsx)(n.code,{children:"article/[id]/page.js"}),"的代码（将 frontmatter 替换为 meta）："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"export default async function Page({ params: {id} }) {\n  const articleModule = await import(`../../content/${id}.mdx`);\n  const { default: Component, meta: {title, author} } = articleModule;\n\n  return (\n    <main>\n       <div>文章标题：{title}</div>\n       <div>文章作者：{author}</div>\n       <Component /> \n    </main>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"也可以正常渲染："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"所以就看你是否想要使用 Frontmatter 这种格式。"}),"\n",(0,t.jsxs)(n.h2,{id:"7-使用基于-rust-的-mdx-编译器",children:["7. 使用基于 Rust 的 MDX 编译器",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-使用基于-rust-的-mdx-编译器",children:"#"})]}),"\n",(0,t.jsxs)(n.p,{children:["Next.js 支持一个用 Rust 编写的 MDX 编译器。目前这个编译器还在实验中，不建议生产环境中使用。但如果你想要尝试这个新编译器，在",(0,t.jsx)(n.code,{children:"next.config.js"}),"中开启配置："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// next.config.js\nmodule.exports = withMDX({\n  experimental: {\n    mdxRs: true,\n  },\n})\n"})}),"\n",(0,t.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/altano/alan.norbauer.com/blob/main/next.config.mjs",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/altano/alan.norbauer.com/blob/main/next.config.mjs"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://nextjs.org/docs/pages/building-your-application/configuring/mdx",target:"_blank",rel:"noopener noreferrer",children:"Configuring: MDX | Next.js"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/remarkjs/remark-frontmatter",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/remarkjs/remark-frontmatter"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://mdxjs.com/",target:"_blank",rel:"noopener noreferrer",children:"https://mdxjs.com/"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/@next/mdx",target:"_blank",rel:"noopener noreferrer",children:"https://www.npmjs.com/package/@next/mdx"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/remarkjs/remark",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/remarkjs/remark"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/rehypejs/rehype",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/rehypejs/rehype"})}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}let u=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F30.%E9%85%8D%E7%BD%AE%E7%AF%87%20_%20MDX.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. 本地 MDX",id:"1-本地-mdx",depth:2},{text:"1.1. 开始配置",id:"11-开始配置",depth:3},{text:"1.2. 基本用法",id:"12-基本用法",depth:3},{text:"2. 远程 MDX",id:"2-远程-mdx",depth:2},{text:"3. 共享布局",id:"3-共享布局",depth:2},{text:"4. 使用插件拓展功能",id:"4-使用插件拓展功能",depth:2},{text:"5. 自定义元素",id:"5-自定义元素",depth:2},{text:"6. Frontmatter",id:"6-frontmatter",depth:2},{text:"7. 使用基于 Rust 的 MDX 编译器",id:"7-使用基于-rust-的-mdx-编译器",depth:2},{text:"参考链接",id:"参考链接",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);