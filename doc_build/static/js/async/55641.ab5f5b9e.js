"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55641"],{250854:function(e,n,c){c.r(n),c.d(n,{default:()=>f});var s=c(552676),t=c(740453);let r=c.p+"static/image/afc9c4ea6c3352e684ccc69754673c15.d4d375e5.webp",d=c.p+"static/image/3755aa41322d07c361e288201041379a.f0a21bbd.webp",a=c.p+"static/image/b02af8ce82f04099a7961a999b9ead91.aae83cec.webp",i=c.p+"static/image/761fd45923b292f806692b188d16c582.da60e11e.webp",l=c.p+"static/image/737255ffee5d5b505b2dd8edd4b05453.ad2d231a.webp",h=c.p+"static/image/138cb3a5569b485c8e21d8415718ca40.41b657a5.webp",o=c.p+"static/image/d79503fc72c98275f0cd908265e999fb.0d0fbd5f.webp",x=c.p+"static/image/3d689c65c26c991d78195bac56f546cd.1cd9a821.webp",j=c.p+"static/image/9247d8615a6967e4d19131184f40d5b6.f4d95e84.webp",p=c.p+"static/image/8202f9dc0f5b026e2c5d98a17b4772e5.1aa55a96.webp";function m(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h4:"h4",pre:"pre",img:"img",blockquote:"blockquote"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"7vue3-之响应式系统-api",children:["7.Vue3 之响应式系统 API",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7vue3-之响应式系统-api",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"前言",children:["前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["响应式系统 API，顾名思义，就是指在新的特性中是如何去实现 ",(0,s.jsx)(n.code,{children:"Vue"})," 的响应式功能。我们通过简单实例的形式讲解分析 ",(0,s.jsx)(n.code,{children:"reactive"}),"、",(0,s.jsx)(n.code,{children:"ref"}),"、",(0,s.jsx)(n.code,{children:"computed"}),"、",(0,s.jsx)(n.code,{children:"readonly"}),"、",(0,s.jsx)(n.code,{children:"watchEffect"}),"、",(0,s.jsx)(n.code,{children:"watch"})," 六个响应式 API 的使用方法。"]}),"\n",(0,s.jsxs)(n.h2,{id:"reactive",children:["reactive",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reactive",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"reactive"})," 是 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 中提供的实现响应式数据的方法。在 ",(0,s.jsx)(n.code,{children:"Vue 2"})," 中实现响应式数据是通过 ",(0,s.jsx)(n.code,{children:"Object"})," 的 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",target:"_blank",rel:"noopener noreferrer",children:"defineProPerty"})," 属性来实现的，而在 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 中的响应式是通过 ",(0,s.jsx)(n.code,{children:"ES2015"})," 的 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy",target:"_blank",rel:"noopener noreferrer",children:"Proxy"})," 来实现。"]}),"\n",(0,s.jsx)(n.p,{children:"那么在业务开发使用中，我们需要注意几个要点，下面我们来进一步分析。"}),"\n",(0,s.jsxs)(n.h4,{id:"reactive-参数必须是对象",children:["reactive 参数必须是对象",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#reactive-参数必须是对象",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"reactive"})," 方法接受一个对象（json 或 Array）。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"\x3c!--App.vue--\x3e\n<template>\n  <p>{{ state.title }}</p>\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\nconst state = reactive({\n  title: 'json'\n})\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["尝试着修改上面的 ",(0,s.jsx)(n.code,{children:"reactive"})," 参数为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ state }}</p>\n</template>\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const state = reactive(['arr1', 'arr2', 'arr3'])\n"})}),"\n",(0,s.jsx)(n.p,{children:"你会在浏览器上看到如下所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"同学们可能会有疑问，为什么数组也可以直接渲染呢。这里你可以把数组理解为特殊的对象。我们平时常用的普通对象如下所示："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const obj = { a: '1', b: '2' }\n"})}),"\n",(0,s.jsx)(n.p,{children:"数组作为特殊的对象，如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const arr = ['a', 'b']\n"})}),"\n",(0,s.jsx)(n.p,{children:"此时你可以把它看作："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const arr = { 0: 'a', 1: 'b' }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["所以我们同样可以使用键值对的形式获取值，如 ",(0,s.jsx)(n.code,{children:"arr[0]"}),"。所以这就解释了为什么 ",(0,s.jsx)(n.code,{children:"reactive"})," 还可以接受数组的原因。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"reactive"})," 包裹的对象，已经通过 ",(0,s.jsx)(n.code,{children:"Proxy"})," 进行响应式赋能，所以我们可以通过如下形式修改值，会直接体现在 ",(0,s.jsx)(n.code,{children:"template"})," 模板上。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ state.title }}</p>\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\nconst state = reactive({\n  title: '十三'\n})\n\nsetTimeout(() => {\n  state.title= '十六'\n}, 2000)\n<\/script>\n"})}),"\n",(0,s.jsx)(n.p,{children:"2 秒后你将会在浏览器上看到“十三”变成了“十六”。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["响应式转换是“深层的”，会影响对象内部所有嵌套的属性。基于 ",(0,s.jsx)(n.code,{children:"ES2015"})," 的 ",(0,s.jsx)(n.code,{children:"Proxy"})," 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["上述是官方文档描述 ",(0,s.jsx)(n.code,{children:"reactive"})," 返回的代理后的对象，内部的二级三级属性，都会被赋予响应式的能力，所以官方建议，使用 ",(0,s.jsx)(n.code,{children:"reactive"})," 返回的值，而不要去使用原始值。"]}),"\n",(0,s.jsxs)(n.h2,{id:"ref",children:["ref",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ref",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ref"})," 和 ",(0,s.jsx)(n.code,{children:"reactive"})," 一样，同样是实现响应式数据的方法。在业务开发中，我们可以使用它来定义一些简单数据，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ count }}</p>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nconst count = ref(0)\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["修改数据，可以通过 ",(0,s.jsx)(n.code,{children:"count.value = 1"})," 类似这样的语法去修改。但是为什么它需要这样去修改变量，而 ",(0,s.jsx)(n.code,{children:"reactive"})," 返回的对象可以直接修改如 ",(0,s.jsx)(n.code,{children:"state.count = 1"})," 。"]}),"\n",(0,s.jsxs)(n.p,{children:["原因是 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 内部将 ",(0,s.jsx)(n.code,{children:"ref"})," 悄悄的转化为 ",(0,s.jsx)(n.code,{children:"reactive"}),"，如上述代码会被这样转换："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"ref(0) => reactive({ value: 0 })\n"})}),"\n",(0,s.jsxs)(n.p,{children:["所以 ",(0,s.jsx)(n.code,{children:"count"})," 相当于 ",(0,s.jsx)(n.code,{children:"reactive"})," 返回的一个值，根据 ",(0,s.jsx)(n.code,{children:"reactive"})," 修改值的方式，就可以理解为什么 ",(0,s.jsx)(n.code,{children:"ref"})," 返回的值是通过 ",(0,s.jsx)(n.code,{children:".value"})," 的形式修改值了。"]}),"\n",(0,s.jsxs)(n.p,{children:["还有一点需要注意，当 ",(0,s.jsx)(n.code,{children:"ref"})," 作为渲染上下文的属性返回（即在 ",(0,s.jsx)(n.code,{children:"setup()"})," 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 ",(0,s.jsx)(n.code,{children:".value"}),"。之所以会自动解套，是因为 ",(0,s.jsx)(n.code,{children:"template"})," 模板在被解析的时候，",(0,s.jsx)(n.code,{children:"Vue3"})," 内部通过判断模板内的变量是否是 ",(0,s.jsx)(n.code,{children:"ref"})," 类型。如果是，那就加上 ",(0,s.jsx)(n.code,{children:".value"}),"，如果不是则为 ",(0,s.jsx)(n.code,{children:"reactive"})," 创建的响应集代理数据。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们不妨打印一下 ",(0,s.jsx)(n.code,{children:"ref"})," 创建的对象 ",(0,s.jsx)(n.code,{children:"console.log(count)"}),"，浏览器控制台如下图所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["没错，就是通过上图 ",(0,s.jsx)(n.code,{children:"__v_isRef"})," 变量去判断，模板内的变量是否为 ",(0,s.jsx)(n.code,{children:"ref"})," 类型。判断类型也可以通过 ",(0,s.jsx)(n.code,{children:"isRef"})," 方法，如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ count }}</p>\n</template>\n\n<script setup>\nimport { ref, isRef } from 'vue'\nconst count = ref(0)\nconsole.log(isRef(count)) // true\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"Vue 2"})," 中，我们可以通过给元素添加 ",(0,s.jsx)(n.code,{children:'ref="xxx"'})," 属性，然后在逻辑代码中通过 ",(0,s.jsx)(n.code,{children:"this.$refs.xxx"})," 获取到对应的元素。"]}),"\n",(0,s.jsxs)(n.p,{children:["到了 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 后，",(0,s.jsx)(n.code,{children:"setup"})," 函数内没有 ",(0,s.jsx)(n.code,{children:"this"})," 上下文，因此我们可以通过 ",(0,s.jsx)(n.code,{children:"ref"})," 方法去获取，并且还需要在页面挂载以后才能拿到元素。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <div ref='shisanRef'>十三</div>\n</template>\n<script setup>\nimport { ref, onMounted } from 'vue'\nconst shisanRef = ref(null)\nonMounted(() => {\n  console.log(shisanRef)\n})\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如图所示：\n",(0,s.jsx)("img",{src:x,alt:""})]}),"\n",(0,s.jsxs)(n.h2,{id:"computed",children:["computed",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#computed",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Vue 2"})," 时代，",(0,s.jsx)(n.code,{children:"computed"})," 作为选项出现在页面中，而到了 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 时代，它将会以钩子函数的形式出现。我们先来修改 ",(0,s.jsx)(n.code,{children:"App.vue"})," 下的代码，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ text }}</p>\n</template>\n\n<script setup>\nimport { reactive, computed } from 'vue'\nconst state = reactive({\n  name: '十三',\n  desc: '你好'\n})\n\nconst text = computed(() => {\n  console.log('11')\n  return state.name + state.desc\n})\n\nsetTimeout(() => {\n  state.name = '十六'\n}, 2000)\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述代码通过 ",(0,s.jsx)(n.code,{children:"computed"})," 函数将 ",(0,s.jsx)(n.code,{children:"name"})," 和 ",(0,s.jsx)(n.code,{children:"desc"})," 变量拼接，返回 ",(0,s.jsx)(n.code,{children:"text"})," 渲染在模板上。"]}),"\n",(0,s.jsxs)(n.p,{children:["这里要注意的是 2 秒后，",(0,s.jsx)(n.code,{children:"name"})," 变量将会被重新赋值，那么 ",(0,s.jsx)(n.code,{children:"computed"})," 函数内带有 ",(0,s.jsx)(n.code,{children:"state.name"}),"，所以会被动态计算，重新返回 ",(0,s.jsx)(n.code,{children:"text"})," 值，浏览器会有如下变化："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["若是将 ",(0,s.jsx)(n.code,{children:"computed"})," 方法内的函数做如下改动："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"...\nconst text = computed(() => {\n  console.log('11')\n  return state.desc\n})\n...\n"})}),"\n",(0,s.jsxs)(n.p,{children:["少了 ",(0,s.jsx)(n.code,{children:"state.name"}),"，2 秒后，你将不会看到控制台打印 ",(0,s.jsx)(n.code,{children:"11"}),"，因为函数内不会被检测执行。"]}),"\n",(0,s.jsxs)(n.p,{children:["上述形式 ",(0,s.jsx)(n.code,{children:"computed"})," 返回的值是不可修改的，通过 ",(0,s.jsx)(n.code,{children:"get"})," 和 ",(0,s.jsx)(n.code,{children:"set"})," 的形式返回的值是可修改的，不过这种情况的使用场景不多，这里不作深究。"]}),"\n",(0,s.jsxs)(n.h2,{id:"readonly",children:["readonly",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#readonly",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"readonly"})," 顾名思义，用于创建一个只读的数据，并且所有的内容都是只读，不可修改。我们看如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <p>{{ state.name }}</p>\n  <p>{{ state.desc }}</p>\n  <button @click=\"fn\">修改</button>\n</template>\n\n<script setup>\nimport { reactive, computed, readonly } from 'vue'\nconst state = readonly({\n  name: '十三',\n  desc: '你好'\n})\n\nconst fn = () => {\n  state.name = '十六'\n  state.desc = '他好'\n  console.log('state', state)\n}\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们用 ",(0,s.jsx)(n.code,{children:"readonly"})," 创建一个数据，将其渲染在 ",(0,s.jsx)(n.code,{children:"template"})," 模板下，并且通过 ",(0,s.jsx)(n.code,{children:"fn"})," 函数，修改这个数据，看看浏览器会有什么反馈。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["点击按钮之后，如上图所示，控制台报警告了，并且 ",(0,s.jsx)(n.code,{children:"state"})," 打印出来之后，内部数据也没有变化。"]}),"\n",(0,s.jsxs)(n.h2,{id:"watcheffect",children:["watchEffect",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#watcheffect",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["首先 ",(0,s.jsx)(n.code,{children:"watchEffect"})," 会追踪响应式数据的变化，并且还会在第一次渲染的时候立即执行，我们来看看下面的例子："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>\n    <h1>{{ state.search }}</h1>\n    <button @click=\"handleSearch\">改变查询字段</button>\n  </div>\n\n</template>\n\n<script setup>\nimport { reactive, watchEffect } from 'vue'\nlet state = reactive({\n  search: Date.now()\n})\nwatchEffect(() => {\n  console.log(`监听查询字段${state.search}`)\n})\n\nconst handleSearch = () => {\n  state.search = Date.now()\n}\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"watchEffect"})," 接受一个回调函数作为参数，并且该回调函数内如果有响应式变量，那么当我执行 ",(0,s.jsx)(n.code,{children:"handleSearch"})," 方法改变 ",(0,s.jsx)(n.code,{children:"search"})," 变量时，回调函数也会被执行，如下所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"watchEffect"})," 函数返回一个新的函数，我们可以通过执行这个函数或者当组件被卸载的时候，来停止监听行为。来看下面代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let timer = null\nlet state = reactive({\n  search: Date.now()\n})\n\n// 返回停止函数\nconst stop = watchEffect((onInvalidate) => {\n  console.log(`监听查询字段${state.search}`)\n})\n\nconst handleSearch = () => {\n  state.search = Date.now()\n}\n\nsetTimeout(() => {\n  console.log('执行 stop 停止监听')\n  stop() // 2 秒后停止监听行为\n}, 2000)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们一直点击按钮，控制台会一直打印改变的数据。当 2 秒是 ",(0,s.jsx)(n.code,{children:"stop"})," 方法被执行，停止监听后，控制台不再打印数据。如下图所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"watchEffect"})," 的回调方法内有一个很重要的方法，用于清除副作用。它接受的回调函数也接受一个函数 ",(0,s.jsx)(n.code,{children:"onInvalidate"}),"。名字不重要，重要的是它将会在 ",(0,s.jsx)(n.code,{children:"watchEffect"})," 监听的变量改变之前被调用一次，具体执行顺序我们通过代码来解释："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>\n    <h1>{{ state.search }}</h1>\n    <button @click=\"handleSearch\">改变查询字段</button>\n  </div>\n</template>\n\n<script setup>\nimport { reactive, watchEffect } from 'vue'\nlet state = reactive({\n  search: Date.now()\n})\nconst stop = watchEffect((onInvalidate) => {\n  console.log(`监听查询字段${state.search}`)\n  onInvalidate(() => {\n    console.log('执行 onInvalidate')\n  })\n})\n\nconst handleSearch = () => {\n  state.search = Date.now()\n}\n<\/script>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["每当我点击按钮，改变 ",(0,s.jsx)(n.code,{children:"search"})," 值时，",(0,s.jsx)(n.code,{children:"onInvalidate"})," 会在监听打印之前被执行一次。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么要它何用呢？用处非常大。举个例子，我们需要监听 ",(0,s.jsx)(n.code,{children:"search"})," 的变化，去请求接口数据，此时接口是异步返回的，每当我改变 ",(0,s.jsx)(n.code,{children:"search"})," 都会去请求一次接口，那么有可能 ",(0,s.jsx)(n.code,{children:"search"})," 改变的很频繁，那就会频繁的去请求接口，导致服务端压力倍增。我们可以通过这个特性去降低服务端的压力，具体逻辑如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>\n    <h1>{{ state.search }}</h1>\n    <button @click=\"handleSearch\">改变查询字段</button>\n  </div>\n\n</template>\n\n<script setup>\nimport { reactive, watchEffect } from 'vue'\nlet timer = null\nlet state = reactive({\n  search: Date.now()\n})\nwatchEffect((onInvalidate) => {\n  console.log(`监听查询字段${state.search}`)\n  timer = setTimeout(() => {\n    console.log('模拟接口异步请求，3 秒之后返回详情信息')\n  }, 3000)\n  onInvalidate(() => {\n    console.log('清除');\n    clearInterval(timer);\n  })\n})\n\nconst handleSearch = () => {\n  state.search = Date.now()\n}\n<\/script>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"watchEffect"})," 回调函数内，我用 ",(0,s.jsx)(n.code,{children:"setTimeout"})," 的形式去模拟响应时间为 3 秒的异步请求，上面代码可以理解为 3 秒之内如果你不去改变 ",(0,s.jsx)(n.code,{children:"search"})," 变量，那么页面就成功返回接口数据，如果在 3 秒之内你再次点击按钮改变了 ",(0,s.jsx)(n.code,{children:"search"})," 变量，",(0,s.jsx)(n.code,{children:"onInvalidate"})," 将会被触发，从而清理掉上一次的接口请求，然后根据新的 ",(0,s.jsx)(n.code,{children:"search"})," 变量去执行新的请求。我们来看浏览器的表现："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"watch",children:["watch",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#watch",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"watch"})," 的功能和之前的 ",(0,s.jsx)(n.code,{children:"Vue 2"})," 的 ",(0,s.jsx)(n.code,{children:"watch"})," 是一样的。和 ",(0,s.jsx)(n.code,{children:"watchEffect"})," 相比较，区别在 ",(0,s.jsx)(n.code,{children:"watch"})," 必须指定一个特定的变量，并且不会默认执行回调函数，而是等到监听的变量改变了，才会执行。并且你可以拿到改变前和改变后的值，代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<template>\n  <div>\n    <h1>{{ state.search }}</h1>\n    <button @click=\"handleSearch\">改变查询字段</button>\n  </div>\n\n</template>\n\n<script setup>\nimport { reactive, watch } from 'vue'\nlet timer = null\nlet state = reactive({\n  search: Date.now()\n})\nwatch(() => {\n  return state.search\n}, (nextData, preData) => {\n  console.log('preData', preData)\n  console.log('nextData', nextData)\n})\n\nconst handleSearch = () => {\n  state.search = Date.now()\n}\n<\/script>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上述这六个响应式系统 ",(0,s.jsx)(n.code,{children:"API"})," 会是你日后使用频率最高的几个。细心阅读每一个响应式 ",(0,s.jsx)(n.code,{children:"API"}),"，这将会对后面的实战项目很有帮助。将这些 ",(0,s.jsx)(n.code,{children:"API"})," 灵活的运用于项目中，可以让代码变得更加优雅，增加代码的可读性。"]}),"\n",(0,s.jsxs)(n.p,{children:["理解了这些知识点，对于掌握整个 ",(0,s.jsx)(n.code,{children:"Vue 3"})," 具有举足轻重的意义。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"文档最近更新时间：2022 年 9 月 20 日。"}),"\n"]})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}let f=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F7.Vue3%20%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%20API.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"reactive",id:"reactive",depth:2},{text:"reactive 参数必须是对象",id:"reactive-参数必须是对象",depth:4},{text:"ref",id:"ref",depth:2},{text:"computed",id:"computed",depth:2},{text:"readonly",id:"readonly",depth:2},{text:"watchEffect",id:"watcheffect",depth:2},{text:"watch",id:"watch",depth:2},{text:"总结",id:"总结",depth:2}],title:"7.Vue3 之响应式系统 API",headingTitle:"7.Vue3 之响应式系统 API",frontmatter:{}}}}]);