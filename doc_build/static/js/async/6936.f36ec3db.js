"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["6936"],{738435:function(e,c,n){n.r(c),n.d(c,{default:()=>i});var d=n(552676),h=n(740453);function r(e){let c=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",img:"img"},(0,h.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(c.h1,{id:"7批量异步更新策略及-nexttick-原理",children:["7.批量异步更新策略及 nextTick 原理",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#7批量异步更新策略及-nexttick-原理",children:"#"})]}),"\n",(0,d.jsxs)(c.h2,{id:"为什么要异步更新",children:["为什么要异步更新",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么要异步更新",children:"#"})]}),"\n",(0,d.jsxs)(c.p,{children:["通过前面几个章节我们介绍，相信大家已经明白了 Vue.js 是如何在我们修改 ",(0,d.jsx)(c.code,{children:"data"})," 中的数据后修改视图了。简单回顾一下，这里面其实就是一个“",(0,d.jsx)(c.code,{children:"setter -> Dep -> Watcher -> patch -> 视图"}),"”的过程。"]}),"\n",(0,d.jsx)(c.p,{children:"假设我们有如下这么一种情况。"}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-html",children:'<template>\n  <div>\n    <div>{{number}}</div>\n    <div @click="handleClick">click</div>\n  </div>\n</template>\n'})}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-javascript",children:"export default {\n    data () {\n        return {\n            number: 0\n        };\n    },\n    methods: {\n        handleClick () {\n            for(let i = 0; i < 1000; i++) {\n                this.number++;\n            }\n        }\n    }\n}\n"})}),"\n",(0,d.jsxs)(c.p,{children:["当我们按下 click 按钮的时候，",(0,d.jsx)(c.code,{children:"number"})," 会被循环增加1000次。"]}),"\n",(0,d.jsxs)(c.p,{children:["那么按照之前的理解，每次 ",(0,d.jsx)(c.code,{children:"number"})," 被 +1 的时候，都会触发 ",(0,d.jsx)(c.code,{children:"number"})," 的 ",(0,d.jsx)(c.code,{children:"setter"})," 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！太可怕了。"]}),"\n",(0,d.jsxs)(c.p,{children:["Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 ",(0,d.jsx)(c.code,{children:"setter"})," 方法后，对应的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象其实会被 ",(0,d.jsx)(c.code,{children:"push"})," 进一个队列 ",(0,d.jsx)(c.code,{children:"queue"})," 中，在下一个 tick 的时候将这个队列 ",(0,d.jsx)(c.code,{children:"queue"})," 全部拿出来 ",(0,d.jsx)(c.code,{children:"run"}),"（ ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象的一个方法，用来触发 ",(0,d.jsx)(c.code,{children:"patch"})," 操作） 一遍。"]}),"\n",(0,d.jsx)(c.p,{children:(0,d.jsx)("img",{src:"data:image/webp;base64,UklGRhYPAABXRUJQVlA4IAoPAADQXgCdASpeAZQBPp1Mn00lpCKiInR5QLATiWdu/HyZq+sb3zM+4+b5cX8JtL5LOzfP1/o/1L93P6A9gD9Y/Om9Vv7M+oD9m/VU/0X6j+6L9bPYA/Zb1ev9V7F/7KewL+sXpYfuT8HX9k/137l/Ab+2H//6wD//9cv1E/uPbd/lfDXxcevpMbdZmk+1v6/+q+e/ePwAvYW6x63/pvQC7p/rb4xGop4H9gD+Y/2H/n8Z95p+iPwD/zz/BegB9Qegn9C/2PsMdMATw0Qtw3PqAcGpw0Qtw3PqAcGpw0Qtlu3EDjOGiFuG59QDgznUx6pPFESuOduVS1mbDYjQ2s94rhciG++79RUIB33a5AroIW4bqS8/VG6eZILneK+PvtPnsOpiMLCNypcjYxg22DYb2/qAeeBOlFArLGKA0V0ELcNz6hyFwgY0KzHNAlYBohbhufUAmtSHzhXS73hcmtRAcGpwgUNR/3KNtXAl3upORKSiA4NThohbLoFZyuBir6HRCyU3EUnSJIapuW4bn1AKVBqcNCq9umtRAcEJ75eDX9Y9yMU15q4O3o98PX8L2butyzJmqAU6KLHY++vwLcNz6ag7H4Dp9l9281c8Gy63vLNhf144GXq/pWPzl7HCZGAcGpwy9uXOwNyMRcGpw0QMOTzWmFb2abT0mpYhTZKIDg1NnPDAtVhoQWsf7eHrkIDg1OEUAcgxbQ5YlWa7zOc8QCg+6TP37f/KRqQcTCBdv2pit8AmcDSSIASTny8oX46jTqn6gHBqbOhKRqn453rkIDg1OD3U7js/gPmPelxP4D5jS3fKiu5zROvfUMughbhnqmv/U4aEvCfw3PqAcEJ72go/fwjhfu47ny8Pf7Ch/mmod1zDKENv8cfuPUv5aczRC3Dc+Uyd9PE0NdZqt9JQpTYIAQWqOwVyZJ4bV6HiGlRlic/UA4NThFBvq4bgmdDLoIW4BbY/Qu8QlE2npOd/C5NaiA4NThohbhufUA4NThohbhufUA4NThohbhufUA4M0AD+/6t0AD36J+AEjU7zSXJY+Kh7a69BNQ+YeExvtwChCqZeT99DouM8Z/q+U631NACOMYrIn+fD+xsfUAPHTqbE+MuufGph9U4BBxc0eTE8hbEOApXYvl+sV/uDwHCdxLEmMSIatyMn/EbK4mtrLfkrXlhucRMXDB90sCsT9hfP8AQhb7Pg81pP/+p1tJb/DzzlpqSpAh63LlldwNdG6jLjtUBoDgdksFpO8IZkX+nnDiWxyKxZD8yCC9hzzXDL+Q3rlPdJijVaZFNAPb07CAKI+4RAV7l8wDVrMJixWg9mZkCVnEp3iOnur1u3z7l+85dYbkUvypGVqDZXa4Rh0iQ7lCqUN44CYj/990Wdlw0aEZkFPXN1nq/3+F7nkQWkqTqrOi9C8U1g2gTMTk8mhoQuE/VwWMCyp0IOmkirbPDHRcnG4w8+saK/R+Z3lHxs97qVfH7L+cQhKeee+UrChr1WGdmaMTRLNKBt40eLBr2rXiZ19SM6bt471tHTz/Ye/IkxG/+Q7/UL1iy1F78UtOdKIAHVXubJDAhVL5kGYYvV/41PL2vjJImgiQR7prqZb/az+rUjN6wa6KHVMKZqJMLVRJeWfDeJxG5LyUTLvHvaaWbRXH2qo7sspzyh+9xYbkC7+DAb43oX8nn5ZkeUAluZcO1c409Gcv4RN6Uahwy/ZQ2Pskxc6f7ADUbWDdPTSqVMlFq7mPwephvv88I1VNUz2DuOq7dpTGA8Y6D7/ugpyhIDCq6vQYF43OuojSTW3SnI5VIx0YU4XvBIKEKyZ+2hdku/zfG1pz5pU6LsfXhJL3oIPbW8E8CzfAMxTUNv9hnFoB582TOfD1iglLzEEg+zXwZL0xozA+kxrotSWc+TFpncYXNv1wqKsAMZpLWQulFbHcSymiET3weisi0iPDLry04WxeXQcUNDY6szrUPG5BdmgPjXGcPaiNi7dkKXDi+HiUH6Pe9uWBS9iTjcYgyBXGacu3SHGdnrfYHVYFttw/6gXMAdoivKR3QxGPCrjkApDO5/yg5tOVxzGBVMsbqrg5qGT9nWhcupxIwjO4DwqLk5lOI/OOvJ+U7c2bhxY/ZdkKk8r/J7YOOr8Dl83p3cv8BKpDyQJ28DpQg14NAoRdmWkXl1JBUufFL5g0IAALhV+TVQsBJQzf8n0M9HQIBJ/0K8oaCR9lNvLT4he8o77SyK+uWni2ipkDNydwuttUUr9oRTt6sZc5oJUSjETyyaXkzrc/LbkgK5LozMIXQqG5VPppXXudtR/hjzoJAUhYh2EmuBpf+RNd9WpvpejsnJGqYFf5LB3/1LLC63+7YjGRw4ON7XXEropAGOFgcQHRteD9/IPFrZIAJ5d3Ct2/xJ6ayjAvrF+1RBncGQv5mlThVJ096KooQQESERy9wCHSzbXP1G3+lrDkmpVtpDlAWZp424TO6mFjNbddpLf3ENuhz2Y4eXK4/Zl+EalhXqn7MmHFeyuY4y8m37H8Siij+HwvtYnx8LUE3JDJCB9j+ncAZct6y1egxojgr5MnnoT7QgUC/QJYGFqVsmUSdRAnNpCsfW9mJ3xzaestL3zHJcM70ASpkiLPsC45QXy/jNnpdKC3P1rY9Mt+tk522aN352xayr09Qgp0kXiecFXWgzmpldEeUdzjMei33W1Y5DVCSVIQBnB67owbeLnmppZRM1mgdidaKhbAfmop7652JXwTncr0MH2G4obAfeCD3LVik3rXfIdw5Z/fWlUIXcakeGuaPy6a6V52h6qdY44TNFE7SX3iX/b2qpXskwx8jImG6mr96jY4djf5QN7uy6X5YxsBGTahekeKp6kuA1cE30sJL3ok7iWIK6/H/NRmjdsYvlTC/D6mb4eYqI643KCMTWG33VDuWHls3Qj70d2GINXm5pgsYcIe4JqwamhrZF2xjALjBEr+PSK5HoAv+3XEXrUzzIjMmX74BDQ5Q6fAzASw+WpMTyBnaEqTMVLgzXUj+1UfZW+tjX+T5nKXmfcM6FFGf5P5CnvizOxsMyuD+JlQ+ghrkam8GYKTVugcLPQe67XTxQY1oip8TSbRCZc0HHhFkx8XMhU1+BHeNM7vevf+zqHi+kggW5/4hapQCRgqJ97y4D3pImj9OgItY3anXKDYzmiO8m34fHGSPmVBsvHZX1RlSLtG69L+Uzrxnsm3dLdC0R+eZzBlZ3uAnhRgufeeWF2ztha6Jf2lib2AlYmbFdHk7yEffkDYtERt8EFMKADew0xH70A3+7A9iXEuqo9f8TlFKePNnN6/Wm82tgFYdEnwdZvNS4GcVP6m3W/6qAHkVq7veUyhPmJrvIeFhMj+7x3WTJZQAXaDH1BbTy7MVmiggAp0Uv+pw9TtAT/ueoPx5WG1Wxh8/r9Xq8N4DVMNLnbt+3ZnEKfzrvi21aKOBh+iIrNXhN487fTkMW8J5Gx3VeQPuQWkZLE73vVlQ+HHtofSEzMXuGFN5ZzwL3UKnk/L5zsnY6gZJfBUK5CZJEJkqBHvB+yw7owOu+Aa6HlIgBu6Y7n3jx3WfzqzZR3+f3GYHuD/lEsm63Jh+3h5ExabXeK+2AauFfHysl0c1yXJx5VjEY55LRbhr0vre5Z1yC2no0mgIlXdT8hlRcm2vUfL11X17A8bnnfF6VeHunudcIVePz48VdQE8FyVIwcFdfpFEEOjbbFukdxdJx9Lv9x13o6azIADhEvk29/tgUqFslJqKQM5EcDTGgl5pGLtW/OM+U0J1Gw0rnfqRLRAxz3govw3TDIZa6f1RRsmIy2fGc7mAyjl40MIolWicjIfiQw0PE9JCZXHw+Yn70CdsrhOZD/oBSXNtuRUOOU9Rlr/Zoa6jQ0zfvX0BFUW0UpU6FkmgmdPDc4IkZRUkymkEoMRv1czZySiaYeXG/EHkd6kgtTC66tWDlkj1BErT5y+1w+N4xUJQxsmHHrfzdfP54sy3adD4gqKErFIpwUGeK9d9S6vLs80uPOI7GpWHXcEzcupv0BvOKHaT00vlDeNKJquEORASiLZxvMB4U8BNw3l6olhvckYtsqpi2EsRJs0W5t6azIFjitPNN6iNqYbQ5ijAwlg2goJCTuafjnWt1RWBjfT9bOUMlFas+L6BG8vmfvUYcvC4Lz6xiF6PvATX3fDFKtglyhdKAuB2lAAAHoMPAM0t6gwSCOqnJ1sYIHABGSDahOw51Eu8gBGaAlL61WKT55U7MZNidnr2v4GKD4pPD0n1BsFuk2jPyVLuDL0O6v59tobomOv8gepujoM9lflBWrxEgMehQAep+Q5D8gAlYcHvQDxa9LeQUUu60ZqofsvtsdyLAdTkZJJDX+2eADzXN974F3aEgCBq3MKu3hVmSB5z0FRoXrn4BjD+qau/5pJnIG18KGjC2SnZeKZEWW7+/VKybh2Pm+Brvl7pSSzbWuPOYrPhtoxEkhCXRRrOCRcx7okJP1dd524ZG2N9cDYjH1nNqRMapMLbeEGDuPwjTsURCk2NsG+JWUXGFlCuXALeOslYQWu/y37T/dnGfMpJ/HqjAKxSqQBy3xmsf1kGZX2s26qyMC4MbKHRjY/a8dvdlA6dPBI40028tY6TG0vBW/ernrPE9Zn/JY/+U15K3AmHo36JQNBZJYKYTviRdvTlOFWMzIGcaK2teKk57TpGm7MXP6g+iL6zxKUeb/kIy7e5Oh6XzOyQ62EDixIjyp6hwc/Ddf2FsUxPWlHXsq4OenaYxpVEW+6+tnHJw9N9QnOM5J4ggueBxSP7EpOLs8imKsfTqATx3WH9N67AO3L0elXek49hfqpPxB+tb6bUjv/PfkKhFnrOzacU7g1uc3kaUn6VjbNyAhSxC5YN2bXbaqRogO+hynF76p/x7kEn7G905XXgawOPoSZ1jE1WRsmE8wRLJ1SklQAZ3Y6BeUj+6YzikeOgGUyFfBx4iGbMReUACj+be0Of8gZ8YYAvhraBp6beE4jJ1cXiHRUickf/0+9FTHNhW26LbirNDaaVAme4lQ8UmUlp/CA8eRnvQArMN9Rk/IINT18lANIp97u+aY7RL70j5chpO5y7HzgHk7w1gnD5YzqkqjjKpR6GRCgA2z0Vpg/wuuX/39UpevaADoAAAAAAA",alt:""})}),"\n",(0,d.jsx)(c.p,{children:"那么什么是下一个 tick 呢？"}),"\n",(0,d.jsxs)(c.h2,{id:"nexttick",children:["nextTick",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#nexttick",children:"#"})]}),"\n",(0,d.jsxs)(c.p,{children:["Vue.js 实现了一个 ",(0,d.jsx)(c.code,{children:"nextTick"})," 函数，传入一个 ",(0,d.jsx)(c.code,{children:"cb"})," ，这个 ",(0,d.jsx)(c.code,{children:"cb"})," 会被存储到一个队列中，在下一个 tick 时触发队列中的所有 ",(0,d.jsx)(c.code,{children:"cb"})," 事件。"]}),"\n",(0,d.jsxs)(c.p,{children:["因为目前浏览器平台并没有实现 ",(0,d.jsx)(c.code,{children:"nextTick"})," 方法，所以 Vue.js 源码中分别用 ",(0,d.jsx)(c.code,{children:"Promise"}),"、",(0,d.jsx)(c.code,{children:"setTimeout"}),"、",(0,d.jsx)(c.code,{children:"setImmediate"})," 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。"]}),"\n",(0,d.jsxs)(c.p,{children:["笔者用 ",(0,d.jsx)(c.code,{children:"setTimeout"})," 来模拟这个方法，当然，真实的源码中会更加复杂，笔者在小册中只讲原理，有兴趣了解源码中 ",(0,d.jsx)(c.code,{children:"nextTick"})," 的具体实现的同学可以参考",(0,d.jsx)(c.a,{href:"https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js#L90",target:"_blank",rel:"noopener noreferrer",children:"next-tick"}),"。"]}),"\n",(0,d.jsxs)(c.p,{children:["首先定义一个 ",(0,d.jsx)(c.code,{children:"callbacks"})," 数组用来存储 ",(0,d.jsx)(c.code,{children:"nextTick"}),"，在下一个 tick 处理这些回调函数之前，所有的 ",(0,d.jsx)(c.code,{children:"cb"})," 都会被存在这个 ",(0,d.jsx)(c.code,{children:"callbacks"})," 数组中。",(0,d.jsx)(c.code,{children:"pending"})," 是一个标记位，代表一个等待的状态。"]}),"\n",(0,d.jsxs)(c.p,{children:[(0,d.jsx)(c.code,{children:"setTimeout"})," 会在 task 中创建一个事件 ",(0,d.jsx)(c.code,{children:"flushCallbacks"})," ，",(0,d.jsx)(c.code,{children:"flushCallbacks"})," 则会在执行时将 ",(0,d.jsx)(c.code,{children:"callbacks"})," 中的所有 ",(0,d.jsx)(c.code,{children:"cb"})," 依次执行。"]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-javascript",children:"let callbacks = [];\nlet pending = false;\n\nfunction nextTick (cb) {\n    callbacks.push(cb);\n\n    if (!pending) {\n        pending = true;\n        setTimeout(flushCallbacks, 0);\n    }\n}\n\nfunction flushCallbacks () {\n    pending = false;\n    const copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (let i = 0; i < copies.length; i++) {\n        copies[i]();\n    }\n}\n"})}),"\n",(0,d.jsxs)(c.h2,{id:"再写-watcher",children:["再写 Watcher",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#再写-watcher",children:"#"})]}),"\n",(0,d.jsxs)(c.p,{children:["第一个例子中，当我们将 ",(0,d.jsx)(c.code,{children:"number"})," 增加 1000 次时，先将对应的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象给 ",(0,d.jsx)(c.code,{children:"push"})," 进一个队列 ",(0,d.jsx)(c.code,{children:"queue"})," 中去，等下一个 tick 的时候再去执行，这样做是对的。但是有没有发现，另一个问题出现了？"]}),"\n",(0,d.jsxs)(c.p,{children:["因为 ",(0,d.jsx)(c.code,{children:"number"})," 执行 ++ 操作以后对应的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象都是同一个，我们并不需要在下一个 tick 的时候执行 1000 个同样的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象去修改界面，而是只需要执行一个 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象，使其将界面上的 0 变成 1000 即可。"]}),"\n",(0,d.jsxs)(c.p,{children:["那么，我们就需要执行一个过滤的操作，同一个的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 在同一个 tick 的时候应该只被执行一次，也就是说队列 ",(0,d.jsx)(c.code,{children:"queue"})," 中不应该出现重复的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象。"]}),"\n",(0,d.jsxs)(c.p,{children:["那么我们给 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象起个名字吧～用 ",(0,d.jsx)(c.code,{children:"id"})," 来标记每一个 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象，让他们看起来“不太一样”。"]}),"\n",(0,d.jsxs)(c.p,{children:["实现 ",(0,d.jsx)(c.code,{children:"update"})," 方法，在修改数据后由 ",(0,d.jsx)(c.code,{children:"Dep"})," 来调用， 而 ",(0,d.jsx)(c.code,{children:"run"})," 方法才是真正的触发 ",(0,d.jsx)(c.code,{children:"patch"})," 更新视图的方法。"]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-javascript",children:"let uid = 0;\n\nclass Watcher {\n    constructor () {\n        this.id = ++uid;\n    }\n\n    update () {\n        console.log('watch' + this.id + ' update');\n        queueWatcher(this);\n    }\n\n    run () {\n        console.log('watch' + this.id + '视图更新啦～');\n    }\n}\n"})}),"\n",(0,d.jsxs)(c.h2,{id:"queuewatcher",children:["queueWatcher",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#queuewatcher",children:"#"})]}),"\n",(0,d.jsxs)(c.p,{children:["不知道大家注意到了没有？笔者已经将 ",(0,d.jsx)(c.code,{children:"Watcher"})," 的 ",(0,d.jsx)(c.code,{children:"update"})," 中的实现改成了"]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-javascript",children:"queueWatcher(this);\n"})}),"\n",(0,d.jsxs)(c.p,{children:["将 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象自身传递给 ",(0,d.jsx)(c.code,{children:"queueWatcher"})," 方法。"]}),"\n",(0,d.jsxs)(c.p,{children:["我们来实现一下 ",(0,d.jsx)(c.code,{children:"queueWatcher"})," 方法。"]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-javascript",children:"let has = {};\nlet queue = [];\nlet waiting = false;\n\nfunction queueWatcher(watcher) {\n    const id = watcher.id;\n    if (has[id] == null) {\n        has[id] = true;\n        queue.push(watcher);\n\n        if (!waiting) {\n            waiting = true;\n            nextTick(flushSchedulerQueue);\n        }\n    }\n}\n"})}),"\n",(0,d.jsxs)(c.p,{children:["我们使用一个叫做 ",(0,d.jsx)(c.code,{children:"has"})," 的 map，里面存放 id -> true ( false ) 的形式，用来判断是否已经存在相同的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象 （这样比每次都去遍历 ",(0,d.jsx)(c.code,{children:"queue"})," 效率上会高很多）。"]}),"\n",(0,d.jsxs)(c.p,{children:["如果目前队列 ",(0,d.jsx)(c.code,{children:"queue"})," 中还没有这个 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象，则该对象会被 ",(0,d.jsx)(c.code,{children:"push"})," 进队列 ",(0,d.jsx)(c.code,{children:"queue"})," 中去。"]}),"\n",(0,d.jsxs)(c.p,{children:[(0,d.jsx)(c.code,{children:"waiting"})," 是一个标记位，标记是否已经向 ",(0,d.jsx)(c.code,{children:"nextTick"})," 传递了 ",(0,d.jsx)(c.code,{children:"flushSchedulerQueue"})," 方法，在下一个 tick 的时候执行 ",(0,d.jsx)(c.code,{children:"flushSchedulerQueue"})," 方法来 flush 队列 ",(0,d.jsx)(c.code,{children:"queue"}),"，执行它里面的所有 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象的 ",(0,d.jsx)(c.code,{children:"run"})," 方法。"]}),"\n",(0,d.jsxs)(c.h2,{id:"flushschedulerqueue",children:["flushSchedulerQueue",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#flushschedulerqueue",children:"#"})]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-javascript",children:"function flushSchedulerQueue () {\n    let watcher, id;\n\n    for (index = 0; index < queue.length; index++) {\n        watcher = queue[index];\n        id = watcher.id;\n        has[id] = null;\n        watcher.run();\n    }\n\n    waiting  = false;\n}\n"})}),"\n",(0,d.jsxs)(c.h2,{id:"举个例子",children:["举个例子",(0,d.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#举个例子",children:"#"})]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-javascript",children:"let watch1 = new Watcher();\nlet watch2 = new Watcher();\n\nwatch1.update();\nwatch1.update();\nwatch2.update();\n"})}),"\n",(0,d.jsxs)(c.p,{children:["我们现在 new 了两个 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象，因为修改了 ",(0,d.jsx)(c.code,{children:"data"})," 的数据，所以我们模拟触发了两次 ",(0,d.jsx)(c.code,{children:"watch1"})," 的 ",(0,d.jsx)(c.code,{children:"update"})," 以及 一次 ",(0,d.jsx)(c.code,{children:"watch2"})," 的 ",(0,d.jsx)(c.code,{children:"update"}),"。"]}),"\n",(0,d.jsxs)(c.p,{children:["假设没有批量异步更新策略的话，理论上应该执行 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象的 ",(0,d.jsx)(c.code,{children:"run"}),"，那么会打印。"]}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-console",children:"watch1 update\nwatch1视图更新啦～\nwatch1 update\nwatch1视图更新啦～\nwatch2 update\nwatch2视图更新啦～\n"})}),"\n",(0,d.jsx)(c.p,{children:"实际上则执行"}),"\n",(0,d.jsx)(c.pre,{children:(0,d.jsx)(c.code,{className:"language-console",children:"watch1 update\nwatch1 update\nwatch2 update\nwatch1视图更新啦～\nwatch2视图更新啦～\n"})}),"\n",(0,d.jsxs)(c.p,{children:["这就是异步更新策略的效果，相同的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象会在这个过程中被剔除，在下一个 tick 的时候去更新视图，从而达到对我们第一个例子的优化。"]}),"\n",(0,d.jsxs)(c.p,{children:["我们再回过头聊一下第一个例子， ",(0,d.jsx)(c.code,{children:"number"})," 会被不停地进行 ",(0,d.jsx)(c.code,{children:"++"})," 操作，不断地触发它对应的 ",(0,d.jsx)(c.code,{children:"Dep"})," 中的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象的 ",(0,d.jsx)(c.code,{children:"update"})," 方法。然后最终 ",(0,d.jsx)(c.code,{children:"queue"})," 中因为对相同 ",(0,d.jsx)(c.code,{children:"id"})," 的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象进行了筛选，从而 ",(0,d.jsx)(c.code,{children:"queue"})," 中实际上只会存在一个 ",(0,d.jsx)(c.code,{children:"number"})," 对应的 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象。在下一个 tick 的时候（此时 ",(0,d.jsx)(c.code,{children:"number"})," 已经变成了 1000），触发 ",(0,d.jsx)(c.code,{children:"Watcher"})," 对象的 ",(0,d.jsx)(c.code,{children:"run"})," 方法来更新视图，将视图上的 ",(0,d.jsx)(c.code,{children:"number"})," 从 0 直接变成 1000。"]}),"\n",(0,d.jsx)(c.p,{children:"到这里，批量异步更新策略及 nextTick 原理已经讲完了，接下来让我们学习一下 Vuex 状态管理的工作原理。"}),"\n",(0,d.jsxs)(c.p,{children:["注：本节代码参考",(0,d.jsx)(c.a,{href:"https://github.com/answershuto/VueDemo/blob/master/%E3%80%8A%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A%20nextTick%20%E5%8E%9F%E7%90%86%E3%80%8B.js",target:"_blank",rel:"noopener noreferrer",children:"《批量异步更新策略及 nextTick 原理》"}),"。"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,h.ah)(),e.components);return c?(0,d.jsx)(c,{...e,children:(0,d.jsx)(r,{...e})}):r(e)}let i=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["%E5%89%96%E6%9E%90%20Vue.js%20%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F7.%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A%20nextTick%20%E5%8E%9F%E7%90%86.md"]={toc:[{text:"为什么要异步更新",id:"为什么要异步更新",depth:2},{text:"nextTick",id:"nexttick",depth:2},{text:"再写 Watcher",id:"再写-watcher",depth:2},{text:"queueWatcher",id:"queuewatcher",depth:2},{text:"flushSchedulerQueue",id:"flushschedulerqueue",depth:2},{text:"举个例子",id:"举个例子",depth:2}],title:"7.批量异步更新策略及 nextTick 原理",headingTitle:"7.批量异步更新策略及 nextTick 原理",frontmatter:{}}}}]);