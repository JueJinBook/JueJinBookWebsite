"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["37521"],{414203:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var s=r(552676),l=r(740453);let i=r.p+"static/image/b6bacf6cb7aebfdc657501bfac73677a.785aeb44.webp",c=r.p+"static/image/2e73b4c0bdcf012652166d1f01b9f2af.8e7664d0.webp";function t(e){let n=Object.assign({p:"p",h2:"h2",a:"a",code:"code",pre:"pre",blockquote:"blockquote",ol:"ol",li:"li",ul:"ul",img:"img",strong:"strong"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"上一节我们聊到如何用结构化思维理解 Webpack 核心配置项，按惯例很多教程接下来会开始罗列各个配置项的作用，但这种方式记忆成本比较高，学习效率偏低。为此，接下来几章我会换一种思维模式，场景化介绍 Webpack 处理各种代码资源的工具与方法。"}),"\n",(0,s.jsx)(n.p,{children:"本章我们先来聊聊 Webpack 场景下处理 JavaScript 的三种常用工具：Babel、TypeScript、ESLint 的历史背景、功能以及接入 Webpack 的步骤，借助这些工具，我们能构建出更健壮、优雅的 JavaScript 应用。"}),"\n",(0,s.jsxs)(n.h2,{id:"使用-babel",children:["使用 Babel",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-babel",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["ECMAScript 6.0(简称 ES6) 版本补充了大量提升 JavaScript 开发效率的新特性，包括 ",(0,s.jsx)(n.code,{children:"class"})," 关键字、块级作用域、ES Module 方案、代理与反射等，使得 JavaScript 可以真正被用于编写复杂的大型应用程序，但直到现在浏览器、Node 等 JavaScript 引擎都或多或少存在兼容性问题。为此，现代 Web 开发流程中通常会引入 Babel 等转译工具。"]}),"\n",(0,s.jsx)(n.p,{children:"Babel 是一个开源 JavaScript 转编译器，它能将高版本 —— 如 ES6 代码等价转译为向后兼容，能直接在旧版 JavaScript 引擎运行的低版本代码，例如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 使用 Babel 转译前\narr.map(item => item + 1)\n\n// 转译后\narr.map(function (item){\n  return item + 1;\n})\n"})}),"\n",(0,s.jsxs)(n.p,{children:["示例中高版本的箭头函数语法经过 Babel 处理后被转译为低版本 ",(0,s.jsx)(n.code,{children:"function"})," 语法，从而能在不支持箭头函数的 JavaScript 引擎中正确执行。借助 Babel 我们既可以始终使用最新版本 ECMAScript 语法编写 Web 应用，又能确保产物在各种环境下正常运行。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：Babel 还提供了一个在线版的 REPL 页面，读者可在 ",(0,s.jsx)(n.a,{href:"https://babeljs.io/repl",target:"_blank",rel:"noopener noreferrer",children:"https://babeljs.io/repl"})," 实时体验功能效果。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 场景下，只需使用 ",(0,s.jsx)(n.code,{children:"babel-loader"})," 即可接入 Babel 转译功能："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装依赖"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm i -D @babel/core @babel/preset-env babel-loader\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"添加模块处理规则"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: ['babel-loader'],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["示例中，",(0,s.jsx)(n.code,{children:"module"})," 属性用于声明模块处理规则，",(0,s.jsx)(n.code,{children:"module.rules"})," 子属性则用于定义针对什么类型的文件使用哪些 Loader 处理器，上例可解读为："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"test: /\\.js$/"}),"：用于声明该规则的过滤条件，只有路径名命中该正则的文件才会应用这条规则，示例中的 ",(0,s.jsx)(n.code,{children:"/\\.js$/"})," 表示对所有 ",(0,s.jsx)(n.code,{children:".js"})," 后缀的文件生效"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"use"}),"：用于声明这条规则的 Loader 处理器序列，所有命中该规则的文件都会被传入 Loader 序列做转译处理"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:"执行编译命令"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx webpack\n"})}),"\n",(0,s.jsxs)(n.p,{children:["接入后，可以使用 ",(0,s.jsx)(n.code,{children:".babelrc"})," 文件或 ",(0,s.jsx)(n.code,{children:"rule.options"})," 属性配置 Babel 功能逻辑，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 预先安装 @babel/preset-env\n// npm i -D @babel/preset-env\nmodule.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'babel-loader',\n            options: {\n              presets: ['@babel/preset-env'],\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["特别提一下，示例中的 ",(0,s.jsx)(n.code,{children:"@babel/preset-env"})," 是一种 Babel 预设规则集 —— Preset，这种设计能按需将一系列复杂、数量庞大的配置、插件、Polyfill 等打包成一个单一的资源包，从而简化 Babel 的应用、学习成本。Preset 是 Babel 的主要应用方式之一，社区已经针对不同应用场景打包了各种 Preset 资源，例如："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/babel-preset-react",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"babel-preset-react"})}),"：包含 React 常用插件的规则集，支持 ",(0,s.jsx)(n.code,{children:"preset-flow"}),"、",(0,s.jsx)(n.code,{children:"syntax-jsx"}),"、",(0,s.jsx)(n.code,{children:"transform-react-jsx"})," 等；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://babeljs.io/docs/en/babel-preset-typescript",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"@babel/preset-typescript"})}),"：用于转译 TypeScript 代码的规则集"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://babeljs.io/docs/en/babel-preset-flow/",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"@babel/preset-flow"})}),"：用于转译 ",(0,s.jsx)(n.a,{href:"https://flow.org/en/docs/getting-started/",target:"_blank",rel:"noopener noreferrer",children:"Flow"})," 代码的规则集"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：关于 Babel 的功能、用法、原理还有非常大的学习空间，感兴趣的同学可以前往阅读官方文档：",(0,s.jsx)(n.a,{href:"https://babeljs.io/docs/en/",target:"_blank",rel:"noopener noreferrer",children:"https://babeljs.io/docs/en/"})," ，这里点到为止，把注意力放回 Webpack + Babel 协作上。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-typescript",children:["使用 TypeScript",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-typescript",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"从 1999年 ECMAScript 发布第二个版本到 2015年发布 ES6 之间十余年时间内，JavaScript 语言本身并没有发生太大变化，语言本身许多老旧特性、不合理设计、功能缺失已经很难满足日益复杂的 Web 应用场景。为了解决这一问题，社区陆续推出了一些 JavaScript 超集方言，例如 TypeScript、CoffeeScript、Flow。"}),"\n",(0,s.jsx)(n.p,{children:"其中，TypeScript 借鉴 C# 语言，在 JavaScript 基础上提供了一系列类型约束特性，例如："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["示例中，用一个数字类型的变量 ",(0,s.jsx)(n.code,{children:"num"})," 减去字符串类型的变量 ",(0,s.jsx)(n.code,{children:"str"}),"，这在 TypeScript 的代码编译过程就能提前发现问题，而 JavaScript 环境下则需要到启动运行后才报错。这种类型检查特性虽然一定程度上损失了语言本身的灵活性，但能够让问题在编译阶段提前暴露，确保运行阶段的类型安全性，",(0,s.jsx)(n.strong,{children:"特别适合用于构建多人协作的大型 JavaScript 项目"}),"，也因此，时至今日 TypeScript 依然是一项应用广泛的 JavaScript 超集语言。"]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 有很多种接入 TypeScript 的方法，包括 ",(0,s.jsx)(n.code,{children:"ts-loader"}),"、",(0,s.jsx)(n.code,{children:"awesome-ts-loader"}),"、 ",(0,s.jsx)(n.code,{children:"babel-loader"}),"。通常可使用 ",(0,s.jsx)(n.code,{children:"ts-loader"})," 构建 TypeScript 代码："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装依赖"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm i -D typescript ts-loader\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"配置 Webpack"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const path = require('path');\n\nmodule.exports = {\n  /* xxx */\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        use: 'ts-loader'\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.ts', '.js'],\n  }\n};\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"module.rules"})," 声明对所有符合 ",(0,s.jsx)(n.code,{children:"/\\.ts$/"})," 正则 —— 即 ",(0,s.jsx)(n.code,{children:".ts"})," 结尾的文件应用 ",(0,s.jsx)(n.code,{children:"ts-loader"})," 加载器"]}),"\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.code,{children:"resolve.extensions"})," 声明自动解析 ",(0,s.jsx)(n.code,{children:".ts"})," 后缀文件，这意味着代码如 ",(0,s.jsx)(n.code,{children:'import "./a.ts"'})," 可以忽略后缀声明，简化为 ",(0,s.jsx)(n.code,{children:'import "./a"'})," 文件"]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["创建 ",(0,s.jsx)(n.code,{children:"tsconfig.json"})," 配置文件，并补充 TypeScript 配置信息"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// tsconfig.json\n{\n  "compilerOptions": {\n    "noImplicitAny": true,\n    "moduleResolution": "node"\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"执行编译命令"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx webpack\n"})}),"\n",(0,s.jsxs)(n.p,{children:["注意，如果项目中已经使用 ",(0,s.jsx)(n.code,{children:"babel-loader"}),"，你也可以选择使用 ",(0,s.jsx)(n.a,{href:"https://babeljs.io/docs/en/babel-preset-typescript",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"@babel/preset-typescript"})})," 规则集，借助 ",(0,s.jsx)(n.code,{children:"babel-loader"})," 完成 JavaScript 与 TypeScript 的转码工作："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装依赖"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm i -D @babel/preset-typescript\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"配置 Webpack"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 预先安装 @babel/preset-env\n// npm i -D @babel/preset-env\nmodule.exports = {\n  /* ... */\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          {\n            loader: 'babel-loader',\n            options: {\n              presets: ['@babel/preset-typescript'],\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["不过，",(0,s.jsx)(n.code,{children:"@babel/preset-typescript"})," 只是简单完成代码转换，并未做类似 ",(0,s.jsx)(n.code,{children:"ts-loader"})," 的类型检查工作，大家需要根据实际场景选择适当工具。"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-eslint",children:["使用 ESLint",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-eslint",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"JavaScript 被设计成一种高度灵活的动态、弱类型脚本语言，这使得语言本身的上手成本极低，开发者只需要经过短暂学习就可以开始构建简单应用。但与其它编译语言相比，JavaScript 很难在编译过程发现语法、类型，或其它可能影响稳定性的错误，特别在多人协作的复杂项目下，语言本身的弱约束可能会开发效率与质量产生不小的影响，ESLint 的出现正是为了解决这一问题。"}),"\n",(0,s.jsx)(n.p,{children:"ESLint 是一种扩展性极佳的 JavaScript 代码风格检查工具，它能够自动识别违反风格规则的代码并予以修复，例如对于下面的示例："}),"\n",(0,s.jsxs)(n.p,{children:["这里先忽略 ESLint 配置的具体规则，样例源码存在诸多风格不统一的地方，例如 1、2 行以 ",(0,s.jsx)(n.code,{children:";"})," 结尾，而第 3 行没有 ",(0,s.jsx)(n.code,{children:";"}),"；第一行变量以 ",(0,s.jsx)(n.code,{children:"const"})," 声明，第二行变量以 ",(0,s.jsx)(n.code,{children:"let"})," 声明，等等。ESLint 会找出这些风格不一致的地方，并予以告警，甚至自动修复，生成如上表右上角的代码。"]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 下，可以使用 ",(0,s.jsx)(n.code,{children:"eslint-webpack-plugin"})," 接入 ESLint 工具，步骤："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装依赖"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# 3.如何借助 Babel+TS+ESLint 构建现代 JS 工程环境？\nyarn add -D webpack webpack-cli\n\n# 安装 eslint \nyarn add -D eslint eslint-webpack-plugin\n\n# 简单起见，这里直接使用 standard 规范\nyarn add -D eslint-config-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node eslint-plugin-n\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["在项目根目录添加 ",(0,s.jsx)(n.code,{children:".eslintrc"})," 配置文件，内容："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// .eslintrc\n{\n  "extends": "standard"\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：关于 ESLint 配置项的更多信息，可参考：",(0,s.jsx)(n.a,{href:"https://eslint.org/docs/user-guide/configuring/",target:"_blank",rel:"noopener noreferrer",children:"https://eslint.org/docs/user-guide/configuring/"})]}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["添加 ",(0,s.jsx)(n.code,{children:"webpack.config.js"})," 配置文件，补充 ",(0,s.jsx)(n.code,{children:"eslint-webpack-plugin"})," 配置："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// webpack.config.js\nconst path = require('path')\nconst ESLintPlugin = require('eslint-webpack-plugin')\n\nmodule.exports = {\n  entry: './src/index',\n  mode: 'development',\n  devtool: false,\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  // 添加 eslint-webpack-plugin 插件实例\n  plugins: [new ESLintPlugin()]\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsx)(n.li,{children:"执行编译命令"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx webpack\n"})}),"\n",(0,s.jsx)(n.p,{children:"配置完毕后，就可以在 Webpack 编译过程实时看到代码风格错误提示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"除常规 JavaScript 代码风格检查外，我们还可以使用适当的 ESLint 插件、配置集实现更丰富的检查、格式化功能，这里推荐几种使用率较高第三方扩展，建议读者跟进学习："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"eslint-config-airbnb"})}),"：Airbnb 提供的代码风格规则集，算得上 ESLint 生态第一个成名的规则集合"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/standard/eslint-config-standard",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"eslint-config-standard"})}),"：",(0,s.jsx)(n.a,{href:"https://standardjs.com/",target:"_blank",rel:"noopener noreferrer",children:"Standard.js"})," 代码风格规则集，史上最便捷的统一代码风格的方式"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://eslint.vuejs.org/",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"eslint-plugin-vue"})}),"：实现对 Vue SFC 文件的代码风格检查"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/eslint-plugin-react",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"eslint-plugin-react"})}),"：实现对 React 代码风格检查"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://typescript-eslint.io/docs/development/architecture/packages/",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"@typescript-eslint/eslint-plugin"})}),"：实现对 TypeScript 代码风格检查"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/SonarSource/eslint-plugin-sonarjs",target:"_blank",rel:"noopener noreferrer",children:(0,s.jsx)(n.code,{children:"eslint-plugin-sonarjs"})}),"：基于 ",(0,s.jsx)(n.code,{children:"Sonar"})," 的代码质量检查工具，提供圈复杂度、代码重复率等检测功能"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"综合示例",children:["综合示例",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#综合示例",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"最后，我们再串联上述三种工具，构建一套功能完备的 JavaScript 应用开发环境，步骤："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装基础依赖："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm i -D webpack webpack-cli \\\n    # babel 依赖\n    @babel/core @babel/cli @babel/preset-env babel-loader \\\n    # TypeScript 依赖\n    typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin \\\n    @babel/preset-typescript \\\n    # ESLint 依赖\n    eslint eslint-webpack-plugin\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["创建 ",(0,s.jsx)(n.code,{children:"webpack.config.js"})," 配置文件并输入："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const path = require('path')\nconst ESLintPlugin = require('eslint-webpack-plugin')\n\nmodule.exports = {\n  entry: './src/index.ts',\n  mode: 'development',\n  devtool: false,\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, 'dist')\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        use: {\n          loader: 'babel-loader',\n          options: { presets: ['@babel/preset-typescript'] }\n        }\n      }\n    ]\n  },\n  plugins: [new ESLintPlugin({ extensions: ['.js', '.ts'] })]\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["注意，此处使用 ",(0,s.jsx)(n.code,{children:"@babel/preset-typescript"})," 插件转译 TypeScript 代码。"]}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["创建 ",(0,s.jsx)(n.code,{children:".eslintrc"})," 文件并输入："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "parser": "@typescript-eslint/parser",\n  "plugins": ["@typescript-eslint"],\n  "extends": ["plugin:@typescript-eslint/recommended"]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["之后只需执行 ",(0,s.jsx)(n.code,{children:"npx webpack"})," 命令即可完成编译操作，例如："]}),"\n",(0,s.jsx)(n.p,{children:"至此，我们就搭建了一个支持 Babel + TypeScript + ESLint 的开发环境，读者可在此基础上修改各项工具配置，定制适合自己项目的开发环境。"}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本文介绍了 ESLint、TypeScript、Babel 三类工程化工具的历史背景、功能，以及在 Webpack 中接入这些工具的具体步骤。这三种工具各自补齐了 JavaScript 语言某些薄弱环节："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Babel 提供的语言转译能力，能在确保产物兼容性的同时，让我们大胆使用各种新的 ECMAScript 语言特性；"}),"\n",(0,s.jsx)(n.li,{children:"TypeScript 提供的类型检查能力，能有效提升应用代码的健壮性；"}),"\n",(0,s.jsx)(n.li,{children:"ESLint 提供的风格检查能力，能确保多人协作时的代码一致性。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"它们已成为构建现代 JavaScript 应用的基础设施，建议读者遵循文章提及的学习建议，扩展学习各个工具的功能细节。"}),"\n",(0,s.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"ESLint、TypeScript、Babel 三种工具都分别提供了独立 CLI 形态的使用方法，为何还需要被接入到 Webpack 工作流程中？这种做法有什么收益？"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F3.%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%20Babel%2BTS%2BESLint%20%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%20JS%20%E5%B7%A5%E7%A8%8B%E7%8E%AF%E5%A2%83%EF%BC%9F.md"]={toc:[{text:"使用 Babel",id:"使用-babel",depth:2},{text:"使用 TypeScript",id:"使用-typescript",depth:2},{text:"使用 ESLint",id:"使用-eslint",depth:2},{text:"综合示例",id:"综合示例",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);