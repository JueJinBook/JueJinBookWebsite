"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["59875"],{825385:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var i=r(552676),c=r(740453);function s(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",ul:"ul",li:"li",blockquote:"blockquote",p:"p",strong:"strong",code:"code",pre:"pre",ol:"ol",img:"img"},(0,c.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"5基础-2配置文件读取",children:["5基础 2：配置文件读取",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5基础-2配置文件读取",children:"#"})]}),"\n",(0,i.jsxs)(n.h2,{id:"本节核心内容",children:["本节核心内容",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#本节核心内容",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"介绍 apiserver 所采用的配置解决方案"}),"\n",(0,i.jsx)(n.li,{children:"介绍如何配置 apiserver 并读取其配置，以及配置的高级用法"}),"\n"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["本小节源码下载路径：",(0,i.jsx)(n.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo02",target:"_blank",rel:"noopener noreferrer",children:"demo02"})]}),"\n",(0,i.jsx)(n.p,{children:"可先下载源码到本地，结合源码理解后续内容，边学边练。"}),"\n",(0,i.jsxs)(n.p,{children:["本小节的代码是基于 ",(0,i.jsx)(n.a,{href:"https://github.com/lexkong/apiserver_demos/tree/master/demo01",target:"_blank",rel:"noopener noreferrer",children:"demo01"})," 来开发的。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"viper-简介",children:["Viper 简介",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#viper-简介",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/spf13/viper",target:"_blank",rel:"noopener noreferrer",children:"Viper"})," 是国外大神 ",(0,i.jsx)(n.strong,{children:"spf13"})," 编写的开源配置解决方案，具有如下特性:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"设置默认值"}),"\n",(0,i.jsx)(n.li,{children:"可以读取如下格式的配置文件：JSON、TOML、YAML、HCL"}),"\n",(0,i.jsx)(n.li,{children:"监控配置文件改动，并热加载配置文件"}),"\n",(0,i.jsx)(n.li,{children:"从环境变量读取配置"}),"\n",(0,i.jsx)(n.li,{children:"从远程配置中心读取配置（etcd/consul），并监控变动"}),"\n",(0,i.jsx)(n.li,{children:"从命令行 flag 读取配置"}),"\n",(0,i.jsx)(n.li,{children:"从缓存中读取配置"}),"\n",(0,i.jsx)(n.li,{children:"支持直接设置配置项的值"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Viper 配置读取顺序："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"viper.Set()"})," 所设置的值"]}),"\n",(0,i.jsx)(n.li,{children:"命令行 flag"}),"\n",(0,i.jsx)(n.li,{children:"环境变量"}),"\n",(0,i.jsx)(n.li,{children:"配置文件"}),"\n",(0,i.jsx)(n.li,{children:"配置中心：etcd/consul"}),"\n",(0,i.jsx)(n.li,{children:"默认值"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["从上面这些特性来看，Viper 毫无疑问是非常强大的，而且 Viper 用起来也很方便，在初始化配置文件后，读取配置只需要调用 ",(0,i.jsx)(n.code,{children:"viper.GetString()"}),"、",(0,i.jsx)(n.code,{children:"viper.GetInt()"})," 和 ",(0,i.jsx)(n.code,{children:"viper.GetBool()"})," 等函数即可。"]}),"\n",(0,i.jsx)(n.p,{children:"Viper 也可以非常方便地读取多个层级的配置，比如这样一个 YAML 格式的配置："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"common:\n  database:\n    name: test\n    host: 127.0.0.1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["如果要读取 host 配置，执行 ",(0,i.jsx)(n.code,{children:'viper.GetString("common.database.host")'})," 即可。"]}),"\n",(0,i.jsx)(n.p,{children:"apiserver 采用 YAML 格式的配置文件，采用 YAML 格式，是因为 YAML 表达的格式更丰富，可读性更强。"}),"\n",(0,i.jsxs)(n.h2,{id:"初始化配置",children:["初始化配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化配置",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"主函数中增加配置初始化入口"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n	"errors"\n	"log"\n	"net/http"\n	"time"\n\n	"apiserver/config"\n	\n	 ...\n	\n	"github.com/spf13/pflag"\n)\n\nvar (\n	cfg = pflag.StringP("config", "c", "", "apiserver config file path.")\n)\n\nfunc main() {\n	pflag.Parse()\n\n	// init config\n	if err := config.Init(*cfg); err != nil {\n		panic(err)\n	}\n\n	// Create the Gin engine.\n	g := gin.New()\n\n	...\n}\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"main"})," 函数中增加了 ",(0,i.jsx)(n.code,{children:"config.Init(*cfg)"})," 调用，用来初始化配置，",(0,i.jsx)(n.code,{children:"cfg"})," 变量值从命令行 flag 传入，可以传值，比如 ",(0,i.jsx)(n.code,{children:"./apiserver -c config.yaml"}),"，也可以为空，如果为空会默认读取 ",(0,i.jsx)(n.code,{children:"conf/config.yaml"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"解析配置"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"main"})," 函数通过 ",(0,i.jsx)(n.code,{children:"config.Init"})," 函数来解析并 watch 配置文件（函数路径：",(0,i.jsx)(n.code,{children:"config/config.go"}),"），config.go 源码为："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package config\n\nimport (\n	"log"\n	"strings"\n\n	"github.com/fsnotify/fsnotify"\n	"github.com/spf13/viper"\n)\n\ntype Config struct {\n	Name string\n}\n\nfunc Init(cfg string) error {\n	c := Config {\n		Name: cfg,\n	}\n\n	// 初始化配置文件\n	if err := c.initConfig(); err != nil {\n		return err\n	}\n\n	// 监控配置文件变化并热加载程序\n	c.watchConfig()\n\n	return nil\n}\n\nfunc (c *Config) initConfig() error {\n	if c.Name != "" {\n		viper.SetConfigFile(c.Name) // 如果指定了配置文件，则解析指定的配置文件\n	} else {\n		viper.AddConfigPath("conf") // 如果没有指定配置文件，则解析默认的配置文件\n		viper.SetConfigName("config")\n	}\n	viper.SetConfigType("yaml") // 设置配置文件格式为YAML\n	viper.AutomaticEnv() // 读取匹配的环境变量\n	viper.SetEnvPrefix("APISERVER") // 读取环境变量的前缀为APISERVER\n	replacer := strings.NewReplacer(".", "_") \n	viper.SetEnvKeyReplacer(replacer)\n	if err := viper.ReadInConfig(); err != nil { // viper解析配置文件\n		return err\n	}\n\n	return nil\n}\n\n// 监控配置文件变化并热加载程序\nfunc (c *Config) watchConfig() {\n	viper.WatchConfig()\n	viper.OnConfigChange(func(e fsnotify.Event) {\n		log.Printf("Config file changed: %s", e.Name)\n	})\n}\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"config.Init()"})," 通过 ",(0,i.jsx)(n.code,{children:"initConfig()"})," 函数来解析配置文件，通过 ",(0,i.jsx)(n.code,{children:"watchConfig()"})," 函数来 watch 配置文件，两个函数解析如下："]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"func (c *Config) initConfig() error"})}),"\n",(0,i.jsxs)(n.p,{children:["设置并解析配置文件。如果指定了配置文件 ",(0,i.jsx)(n.code,{children:"*cfg"})," 不为空，则解析指定的配置文件，否则解析默认的配置文件 ",(0,i.jsx)(n.code,{children:"conf/config.yaml"}),"。通过指定配置文件可以很方便地连接不同的环境（开发环境、测试环境）并加载不同的配置，方便开发和测试。"]}),"\n",(0,i.jsx)(n.p,{children:"通过如下设置"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'viper.AutomaticEnv() \nviper.SetEnvPrefix("APISERVER")\nreplacer := strings.NewReplacer(".", "_")\n'})}),"\n",(0,i.jsx)(n.p,{children:"可以使程序读取环境变量，具体效果稍后会演示。"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"config.Init"})," 函数中的 ",(0,i.jsx)(n.code,{children:"viper.ReadInConfig()"})," 函数最终会调用 Viper 解析配置文件。"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"func (c *Config) watchConfig()"})}),"\n",(0,i.jsx)(n.p,{children:"通过该函数的 viper 设置，可以使 viper 监控配置文件变更，如有变更则热更新程序。所谓热更新是指：可以不重启 API 进程，使 API 加载最新配置项的值。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"配置并读取配置",children:["配置并读取配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置并读取配置",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["API 服务器端口号可能经常需要变更，API 服务器启动时间可能会变长，自检程序超时时间需要是可配的（通过设置次数），另外 API 需要根据不同的开发模式（开发、生产、测试）来匹配不同的行为。开发模式也需要是可配置的，这些都可以在配置文件中配置，新建配置文件 ",(0,i.jsx)(n.code,{children:"conf/config.yaml"}),"（默认配置文件名字固定为 ",(0,i.jsx)(n.code,{children:"config.yaml"}),"），",(0,i.jsx)(n.code,{children:"config.yaml"})," 的内容为："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"runmode: debug               # 开发模式, debug, release, test\naddr: :6663                  # HTTP绑定端口\nname: apiserver              # API Server的名字\nurl: http://127.0.0.1:6663   # pingServer函数请求的API服务器的ip:port\nmax_ping_count: 10           # pingServer函数尝试的次数\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"main"})," 函数中将相应的配置改成从配置文件读取，需要替换的配置见下图中红框部分。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/5/30/163b187c103c8d6a?w=2124&h=1188&f=jpeg&s=199767",alt:""})}),"\n",(0,i.jsx)(n.p,{children:"替换后，代码为："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/5/30/163b186688700fb1?w=2290&h=1177&f=jpeg&s=225497",alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["另外根据配置文件的 ",(0,i.jsx)(n.code,{children:"runmode"})," 调用 ",(0,i.jsx)(n.code,{children:"gin.SetMode"})," 来设置 gin 的运行模式："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func main() { \n    pflag.Parse()\n                 \n    // init config\n    if err := config.Init(*cfg); err != nil {\n        panic(err)\n    }            \n                 \n    // Set gin mode.\n    gin.SetMode(viper.GetString("runmode"))\n                 \n    ....\n                 \n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"gin 有 3 种运行模式：debug、release 和 test，其中 debug 模式会打印很多 debug 信息。"}),"\n",(0,i.jsxs)(n.h2,{id:"编译并运行",children:["编译并运行",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编译并运行",children:"#"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"下载 apiserver_demos 源码包（如前面已经下载过，请忽略此步骤）"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ git clone https://github.com/lexkong/apiserver_demos\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsxs)(n.li,{children:["将 ",(0,i.jsx)(n.code,{children:"apiserver_demos/demo02"})," 复制为 ",(0,i.jsx)(n.code,{children:"$GOPATH/src/apiserver"})]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ cp -a apiserver_demos/demo02/ $GOPATH/src/apiserver\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"在 apiserver 目录下编译源码"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"$ cd $GOPATH/src/apiserver\n$ gofmt -w .\n$ go tool vet .\n$ go build -v .\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"4",children:["\n",(0,i.jsxs)(n.li,{children:["修改 ",(0,i.jsx)(n.code,{children:"conf/config.yaml"})," 将端口修改为 ",(0,i.jsx)(n.code,{children:"8888"}),"，并启动 apiserver"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"修改后配置文件为："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"runmode: debug               # 开发模式, debug, release, test\naddr: :8888                  # HTTP绑定端口\nname: apiserver              # API Server的名字\nurl: http://127.0.0.1:8888   # pingServer函数请求的API服务器的ip:port\nmax_ping_count: 10           # pingServer函数try的次数\n"})}),"\n",(0,i.jsx)(n.p,{children:"修改后启动 apiserver："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/5/30/163b196425b26f4c?w=2096&h=450&f=jpeg&s=123918",alt:""})}),"\n",(0,i.jsx)(n.p,{children:"可以看到，启动 apiserver 后端口为配置文件中指定的端口。"}),"\n",(0,i.jsxs)(n.h2,{id:"viper-高级用法",children:["Viper 高级用法",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#viper-高级用法",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"从环境变量读取配置"})}),"\n",(0,i.jsx)(n.p,{children:"在本节第一部分介绍过，Viper 可以从环境变量读取配置，这是个非常有用的功能。现在越来越多的程序是运行在 Kubernetes 容器集群中的，在 API 服务器迁移到容器集群时，可以直接通过 Kubernetes 来设置环境变量，然后程序读取设置的环境变量来配置 API 服务器。读者不需要了解如何通过 Kubernetes 设置环境变量，只需要知道 Viper 可以直接读取环境变量即可。"}),"\n",(0,i.jsx)(n.p,{children:"例如，通过环境变量来设置 API Server 端口："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'$ export APISERVER_ADDR=:7777\n$ export APISERVER_URL=http://127.0.0.1:7777\n$ ./apiserver \n[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.\n - using env:	export GIN_MODE=release\n - using code:	gin.SetMode(gin.ReleaseMode)\n\n[GIN-debug] GET    /sd/health                --\x3e apiserver/handler/sd.HealthCheck (5 handlers)\n[GIN-debug] GET    /sd/disk                  --\x3e apiserver/handler/sd.DiskCheck (5 handlers)\n[GIN-debug] GET    /sd/cpu                   --\x3e apiserver/handler/sd.CPUCheck (5 handlers)\n[GIN-debug] GET    /sd/ram                   --\x3e apiserver/handler/sd.RAMCheck (5 handlers)\nStart to listening the incoming requests on http address: :7777\nThe router has been deployed successfully.\n'})}),"\n",(0,i.jsxs)(n.p,{children:["从输出可以看到，设置 ",(0,i.jsx)(n.code,{children:"APISERVER_ADDR=:7777"})," 和 ",(0,i.jsx)(n.code,{children:"APISERVER_URL=http://127.0.0.1:7777"})," 后，启动 apiserver，API 服务器的端口变为 ",(0,i.jsx)(n.code,{children:"7777"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["环境变量名格式为 ",(0,i.jsx)(n.code,{children:"config/config.go"})," 文件中 ",(0,i.jsx)(n.code,{children:'viper.SetEnvPrefix("APISERVER")'})," 所设置的前缀和配置名称大写，二者用 ",(0,i.jsx)(n.code,{children:"_"})," 连接，比如 ",(0,i.jsx)(n.code,{children:"APISERVER_RUNMODE"}),"。如果配置项是嵌套的，情况可类推，比如"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"....\nmax_ping_count: 10           # pingServer函数try的次数\ndb:                    \n  name: db_apiserver\n"})}),"\n",(0,i.jsxs)(n.p,{children:["对应的环境变量名为 ",(0,i.jsx)(n.code,{children:"APISERVER_DB_NAME"}),"。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"热更新"})}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:"main"})," 函数中添加如下测试代码（",(0,i.jsx)(n.code,{children:"for {}"})," 部分，循环打印 ",(0,i.jsx)(n.code,{children:"runmode"})," 的值）："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'import (\n    "fmt"\n    ....\n)\n\nvar (\n    cfg = pflag.StringP("config", "c", "", "apiserver config file path.")\n)\n\nfunc main() {\n    pflag.Parse()\n\n    // init config\n    	if err := config.Init(*cfg); err != nil {\n    	panic(err)\n    }\n\n    for {\n        fmt.Println(viper.GetString("runmode"))\n        time.Sleep(4*time.Second)\n    }\n    ....\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["编译并启动 ",(0,i.jsx)(n.code,{children:"apiserver"})," 后，修改配置文件中 ",(0,i.jsx)(n.code,{children:"runmode"})," 为 ",(0,i.jsx)(n.code,{children:"test"}),"，可以看到 ",(0,i.jsx)(n.code,{children:"runmode"})," 的值从 ",(0,i.jsx)(n.code,{children:"debug"})," 变为 ",(0,i.jsx)(n.code,{children:"test"}),"："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://user-gold-cdn.xitu.io/2018/5/30/163b1badcd31585c?w=1626&h=236&f=jpeg&s=46035",alt:""})}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"本小节展示了如何用强大的配置管理工具 Viper 来解析配置文件并读取配置，还演示了 Viper 的高级用法。"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(s,{...e})}):s(e)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["%E5%9F%BA%E4%BA%8E%20Go%20%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9A%84%20RESTful%20API%20%E6%9C%8D%E5%8A%A1%2F5%E5%9F%BA%E7%A1%80%202%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96.md"]={toc:[{text:"本节核心内容",id:"本节核心内容",depth:2},{text:"Viper 简介",id:"viper-简介",depth:2},{text:"初始化配置",id:"初始化配置",depth:2},{text:"配置并读取配置",id:"配置并读取配置",depth:2},{text:"编译并运行",id:"编译并运行",depth:2},{text:"Viper 高级用法",id:"viper-高级用法",depth:2},{text:"小结",id:"小结",depth:2}],title:"5基础 2：配置文件读取",headingTitle:"5基础 2：配置文件读取",frontmatter:{}}}}]);