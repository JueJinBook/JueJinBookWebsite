"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["15241"],{432200:function(n,r,i){i.r(r),i.d(r,{default:()=>h});var e=i(552676),l=i(740453);let s=i.p+"static/image/4d0d29222801956cc9961032e1afb82a.178256af.webp",c=i.p+"static/image/bf55ea851d62e7c5fd4d97ac521490b0.d8af1365.webp";function d(n){let r=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",h2:"h2",img:"img",code:"code",ul:"ul",pre:"pre",strong:"strong",blockquote:"blockquote",br:"br"},(0,l.ah)(),n.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(r.h1,{id:"第07章流程控制使用循环结构等完成重复性工作",children:["第07章—流程控制｜使用循环结构等完成重复性工作",(0,e.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#第07章流程控制使用循环结构等完成重复性工作",children:"#"})]}),"\n",(0,e.jsx)(r.p,{children:"\uFEFF本节介绍Go语言中的程序流程控制结构，具体包括以下内容："}),"\n",(0,e.jsxs)(r.ol,{children:["\n",(0,e.jsx)(r.li,{children:"循环结构"}),"\n",(0,e.jsx)(r.li,{children:"流程控制语句"}),"\n",(0,e.jsx)(r.li,{children:"条件分支结构"}),"\n"]}),"\n",(0,e.jsx)(r.p,{children:"经过前面两个小节的学习，我们初步掌握了Go语言的语法知识。本小节将介绍循环和条件分支，从而使用少量代码完成大量重复性的操作，就像标准化作业一样。为了便于理解，本小节将使用3个示例来讲述具体的知识点。"}),"\n",(0,e.jsxs)(r.h2,{id:"循环结构",children:["循环结构",(0,e.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#循环结构",children:"#"})]}),"\n",(0,e.jsx)(r.p,{children:"先来看这样一段输出："}),"\n",(0,e.jsx)(r.p,{children:(0,e.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,e.jsx)(r.p,{children:"可以看到，这是个由星号 * 组成的实心菱形，总共有13行。如何实现这样的效果呢？该不会是手写13行输出语句吧？当然不是！"}),"\n",(0,e.jsx)(r.p,{children:(0,e.jsx)(r.code,{children:"\uD83D\uDCA1 提示： 在实际开发中，产品的需求千变万化。面对复杂的功能，通常的做法是“拆分”。即把一个复杂的需求分解为多个简单的需求，然后逐个实现。"})}),"\n",(0,e.jsx)(r.p,{children:"仔细观察上图中的输出内容可以发现，其实："}),"\n",(0,e.jsxs)(r.ul,{children:["\n",(0,e.jsx)(r.li,{children:"菱形就是由若干行（总共13行）组成的；"}),"\n",(0,e.jsx)(r.li,{children:"菱形是上下轴对称图形，以第7行为轴。"}),"\n"]}),"\n",(0,e.jsx)(r.p,{children:"将菱形拆分为上下两个三角形，可以发现："}),"\n",(0,e.jsxs)(r.ul,{children:["\n",(0,e.jsx)(r.li,{children:"每行都是由若干空格和若干星号构成；"}),"\n",(0,e.jsxs)(r.li,{children:["对于上半部分（i从1开始）：","\n",(0,e.jsxs)(r.ul,{children:["\n",(0,e.jsx)(r.li,{children:"第i行的星号数是2*i-1个；"}),"\n",(0,e.jsx)(r.li,{children:"第i行的空格数是7-i个。"}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(r.li,{children:["对于下半部分（i从1开始）：","\n",(0,e.jsxs)(r.ul,{children:["\n",(0,e.jsx)(r.li,{children:"第i行的空格数是i个；"}),"\n",(0,e.jsx)(r.li,{children:"第i行的星号数是2*7-1-(i*2)个。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,e.jsx)(r.p,{children:"到此，我们不仅做完了拆分，还摸透了规律。接下来，只要按规律编写代码即可。在Go语言中，像这种重复地执行相似逻辑，可以使用循环结构实现。循环结构的格式如下："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:"for init; condition; post {\r\n    //循环体代码块\r\n}\n"})}),"\n",(0,e.jsx)(r.p,{children:"其中，for表明接下来的代码是for循环结构；init是初始化语句；condition是关系或逻辑表达式，值为true时则会停止循环；post是每次循环结束后执行的语句；循环体代码块就是要重复执行的代码了。"}),"\n",(0,e.jsx)(r.p,{children:"接下来，我们用这个循环结构实现上半部分的三角形："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:'func main() {\r\n   n := 7\r\n   for i := 1; i <= n; i++ {\r\n      for j := 0; j < n-i; j++ {\r\n         fmt.Print(" ")\r\n      }\r\n      for k := 0; k < 2*i-1; k++ {\r\n         fmt.Print("*")\r\n      }\r\n      fmt.Println()\r\n   }\r\n}\n'})}),"\n",(0,e.jsx)(r.p,{children:"执行结果为："}),"\n",(0,e.jsx)(r.p,{children:(0,e.jsx)("img",{src:s,alt:"image.png"})}),"\n",(0,e.jsx)(r.p,{children:"我们逐行理解上述代码。"}),"\n",(0,e.jsxs)(r.ol,{children:["\n",(0,e.jsx)(r.li,{children:"声明变量n，并赋初值为7，表示上半部分由7行构成（包含对称轴）。"}),"\n",(0,e.jsxs)(r.li,{children:["接下来是for循环结构，",(0,e.jsx)(r.strong,{children:"初始化条件是变量i为1"}),"，i表示总行数；判断",(0,e.jsx)(r.strong,{children:"退出循环的条件是变量i小于或等于n"}),"，即输出7行后退出；每次循环即完成单行输出，因此在",(0,e.jsx)(r.strong,{children:"循环后i自增1"}),"。如此，便构成了总共循环7次的for循环结构。"]}),"\n",(0,e.jsxs)(r.li,{children:["在for循环内部，有两个for循环，分别用于",(0,e.jsx)(r.strong,{children:"输出空格"}),"和",(0,e.jsx)(r.strong,{children:"星号"}),"，另外在两个循环执行完毕后，输出了",(0,e.jsx)(r.strong,{children:"换行"}),"，用于折行。"]}),"\n",(0,e.jsxs)(r.li,{children:["用于输出空格的for循环结构，",(0,e.jsx)(r.strong,{children:"初始化条件是变量j为0"}),"，j表示输出的空格数；判断",(0,e.jsx)(r.strong,{children:"退出循环的条件是变量j小于n-i"}),"，即总共输出n-i个空格；每次循环完成所有空格的输出，因此",(0,e.jsx)(r.strong,{children:"循环后j自增1"}),"。如此，便实现了单行空格的输出。"]}),"\n",(0,e.jsxs)(r.li,{children:["用于输出星号的for循环结构，",(0,e.jsx)(r.strong,{children:"初始化条件是变量k为0"}),"，k表示输出的星号数；判断",(0,e.jsx)(r.strong,{children:"退出循环的条件是变量k小于2*i-1"}),"，即总共输出2*i-1个星号；每次循环完成所有星号的输出，因此",(0,e.jsx)(r.strong,{children:"循环后k自增1"}),"。如此，便实现了单行星号的输出。"]}),"\n"]}),"\n",(0,e.jsx)(r.p,{children:"好了，如果各位理解了上半部分的实现原理，不妨亲自动手尝试实现下半部分。"}),"\n",(0,e.jsx)(r.p,{children:(0,e.jsx)(r.code,{children:"❗️ 注意： 使用循环时，务必确保有明确的可退出循环的条件，否则程序将陷入死循环，无法终止。在开发时，若不慎执行了死循环，可点击GoLand工具栏中的“Stop”按钮（接近红色，有点像音乐播放器的停止播放按钮）强行停止。"})}),"\n",(0,e.jsx)(r.p,{children:"输出菱形的完整代码如下："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:'func main() {\r\n    n := 7\r\n    for i := 1; i <= n; i++ {\r\n	for j := 0; j < n-i; j++ {\r\n		fmt.Print(" ")\r\n	}\r\n	for k := 0; k < 2*i-1; k++ {\r\n		fmt.Print("*")\r\n	}\r\n	fmt.Println()\r\n    }\r\n    for i := 1; i < n; i++ {\r\n	for j := 0; j < i; j++ {\r\n            fmt.Print(" ")\r\n	}\r\n	for k := 0; k < 2*n-1-2*i; k++ {\r\n            fmt.Print("*")\r\n	}\r\n            fmt.Println()\r\n    }\r\n}\n'})}),"\n",(0,e.jsxs)(r.h2,{id:"条件分支结构",children:["条件分支结构",(0,e.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#条件分支结构",children:"#"})]}),"\n",(0,e.jsx)(r.p,{children:"接下来，输出菱形的题目要“升级了”！"}),"\n",(0,e.jsx)(r.p,{children:"单纯地输出菱形未免太单调了些，我们希望通过不同的文字来输出不同的样式。当文字为“上”的时候，输出上半截7行三角形；当文字为“下”时，输出下半截6行三角形；当文字为“全”是，输出13行菱形。"}),"\n",(0,e.jsx)(r.p,{children:"显然，这个题目升级需要进行“条件判断”，不同的条件执行不同的逻辑。如果Go语言能有“如果……那么……”这种结构就好了！Go语言恰恰有这种结构——条件分支。"}),"\n",(0,e.jsx)(r.p,{children:"Go语言中的条件分支结构如下："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:"if condition {\r\n    //条件成立时要执行的语句\r\n}else{\r\n    //条件不成立时要执行的语句\r\n}\n"})}),"\n",(0,e.jsx)(r.p,{children:"其中，condition是关系或逻辑表达式。另外，如无必要，else是可以省略的："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:"if condition {\r\n    //条件成立时要执行的语句\r\n}\n"})}),"\n",(0,e.jsx)(r.p,{children:"如有必要，还可追加更多的判断条件："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:"if condition1 {\r\n    //条件condition1成立时要执行的语句\r\n}else if condition2 {\r\n    //条件condition2成立时要执行的语句\r\n}else if condition3 {\r\n    //条件condition3成立时要执行的语句\r\n}else{\r\n    //以上三种条件都不成立时要执行的语句\r\n}\n"})}),"\n",(0,e.jsx)(r.p,{children:"如此，解答“升级”后的题目就容易多了。参考条件分支的结构，思路如下："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:"if 文字是“上”或“全”{\r\n    输出菱形前7行\r\n}\r\nif 文字是“下”或“全”{\r\n    输出菱形后6行\r\n}\n"})}),"\n",(0,e.jsx)(r.p,{children:"之前我们已经完成了输出菱形，只需将新的代码逻辑与之结合即可，完整代码如下："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:'func main() {\r\n   outputMode := "全"\r\n\r\n   n := 7\r\n   if outputMode == "上" || outputMode == "全" {\r\n      for i := 1; i <= n; i++ {\r\n         for j := 0; j < n-i; j++ {\r\n            fmt.Print(" ")\r\n         }\r\n         for k := 0; k < 2*i-1; k++ {\r\n            fmt.Print("*")\r\n         }\r\n         fmt.Println()\r\n      }\r\n   }\r\n   if outputMode == "下" || outputMode == "全" {\r\n      for i := 1; i < n; i++ {\r\n         for j := 0; j < i; j++ {\r\n            fmt.Print(" ")\r\n         }\r\n         for k := 0; k < 2*n-1-2*i; k++ {\r\n            fmt.Print("*")\r\n         }\r\n         fmt.Println()\r\n      }\r\n   }\r\n}\n'})}),"\n",(0,e.jsx)(r.p,{children:"我们可以通过改变outputMode的值来控制输出的文字形状。"}),"\n",(0,e.jsxs)(r.h2,{id:"流程控制语句",children:["流程控制语句",(0,e.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#流程控制语句",children:"#"})]}),"\n",(0,e.jsx)(r.p,{children:"流程控制语句多用于管理循环结构的运行。考虑这样一个需求：编程实现查找1-10以内的素数。"}),"\n",(0,e.jsx)(r.p,{children:(0,e.jsx)(r.code,{children:"\uD83D\uDCA1 提示： 素数又称质数，是指在大于1的自然数中，除了1和它本身以外不能被其它整数整除的自然数，2是最小的素数。"})}),"\n",(0,e.jsx)(r.p,{children:"这一次，我们需要在已有的代码上增加，但不改变原有的代码。先来看看现有代码："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:"func main() {\r\n    for i := 2; i > 0; i++ {\r\n	if i == 2 {\r\n            fmt.Println(i)\r\n	}\r\n	//假定i为素数\r\n	flag := true\r\n	for j := 2; j < i; j++ {\r\n            if i%j == 0 {\r\n		//当i能被某个整数整除时，不是素数\r\n		flag = false\r\n            }\r\n	}\r\n	//如果依旧为true，则i为素数\r\n	if flag {\r\n            fmt.Println(i)\r\n	}\r\n    }\r\n}\n"})}),"\n",(0,e.jsx)(r.p,{children:"通过阅读上述代码可以发现："}),"\n",(0,e.jsxs)(r.ul,{children:["\n",(0,e.jsx)(r.li,{children:"代码整体由一个for循环构成，初始化语句声明了变量i，从2开始（2是最小的素数），循环结束的条件是i大于0，每次循环结束后i自增1；"}),"\n",(0,e.jsx)(r.li,{children:"循环体内，首先判断了i是否等于2，如果是的话直接输出了i的值；"}),"\n",(0,e.jsx)(r.li,{children:"然后，声明了布尔类型变量flag，表明是否为素数，用于后续判断是否输出i的值；"}),"\n",(0,e.jsx)(r.li,{children:"接下来，使用循环结构判断i是否为素数。初始化时声明了变量j，从2开始，跳出循环的条件时j小于i，判断i是否为素数只需从2开始尝试做除法，直到i-1为止。若余数为0，则表示能被整除，此时，flag应改为false。每次循环结束后j自增1；"}),"\n",(0,e.jsx)(r.li,{children:"最后，判断flag的值，若flag为true，则表示i是素数，输出i，反之则不是素数。"}),"\n"]}),"\n",(0,e.jsx)(r.p,{children:"代码运行后，控制台输出："}),"\n",(0,e.jsxs)(r.blockquote,{children:["\n",(0,e.jsxs)(r.p,{children:["2",(0,e.jsx)(r.br,{}),"\n","2",(0,e.jsx)(r.br,{}),"\n","3",(0,e.jsx)(r.br,{}),"\n","5",(0,e.jsx)(r.br,{}),"\n","7",(0,e.jsx)(r.br,{}),"\n","11",(0,e.jsx)(r.br,{}),"\n","13",(0,e.jsx)(r.br,{}),"\n","..."]}),"\n"]}),"\n",(0,e.jsx)(r.p,{children:"明明是查找10以内的素数，为何不停地输出这么多结果呢？请大家来找茬，看看这段代码中有哪些问题？"}),"\n",(0,e.jsxs)(r.ol,{children:["\n",(0,e.jsx)(r.li,{children:"最外层的for循环，终止条件是i大于0，但i始终是大于0的，程序一旦开始，便无法结束，陷入死循环；"}),"\n",(0,e.jsx)(r.li,{children:"当i等于2时，输出了一次i的值。然而在内层的循环体中，还将再次输出。最终将输出两次2；"}),"\n",(0,e.jsx)(r.li,{children:"在内层循环中，一旦i与j取余结果为0，则表明i不是素数，内层for循环结构无需再执行剩下的循环了。"}),"\n"]}),"\n",(0,e.jsxs)(r.p,{children:["解决了这3个问题，便能实现查找1-10以内的素数的需求了。要解决它们，就需要请出Go语言中的流程控制语句来“救场”了。在Go语言中，较为常用的流程控制语句有",(0,e.jsx)(r.strong,{children:"continue"}),"和",(0,e.jsx)(r.strong,{children:"break"}),"。前者的意义是立即结束本次循环，执行下一个循环；后者的意义是终止循环。"]}),"\n",(0,e.jsx)(r.p,{children:"显然，解决问题1和3，只需使用break语句打断相应循环的执行即可；解决问题2，只需使用continue语句提前终止本次循环，直接执行下一次循环即可。因此，将代码改为："}),"\n",(0,e.jsx)(r.pre,{children:(0,e.jsx)(r.code,{className:"language-go",children:"func main() {\r\n    for i := 2; i > 0; i++ {\r\n        //当i大于10s\r\n        if i > 10 {\r\n            break\r\n	}\r\n	if i == 2 {\r\n            fmt.Println(i)\r\n            continue\r\n	}\r\n	//假定i为素数\r\n	flag := true\r\n	for j := 2; j < i; j++ {\r\n            if i%j == 0 {\r\n                //当i能被某个整数整除时，不是素数\r\n		flag = false\r\n		break\r\n            }\r\n	}\r\n	//如果依旧为true，则i为素数\r\n	if flag {\r\n            fmt.Println(i)\r\n	}\r\n    }\r\n}\n"})}),"\n",(0,e.jsx)(r.p,{children:"运行结果为："}),"\n",(0,e.jsxs)(r.blockquote,{children:["\n",(0,e.jsxs)(r.p,{children:["2",(0,e.jsx)(r.br,{}),"\n","3",(0,e.jsx)(r.br,{}),"\n","5",(0,e.jsx)(r.br,{}),"\n","7"]}),"\n"]}),"\n",(0,e.jsxs)(r.h2,{id:"小结",children:["小结",(0,e.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,e.jsx)(r.p,{children:"\uD83C\uDF89 恭喜，您完成了本次课程的学习！"}),"\n",(0,e.jsx)(r.p,{children:"\uD83D\uDCCC 以下是本次课程的重点内容总结："}),"\n",(0,e.jsxs)(r.ol,{children:["\n",(0,e.jsx)(r.li,{children:"循环结构"}),"\n",(0,e.jsx)(r.li,{children:"流程控制语句"}),"\n",(0,e.jsx)(r.li,{children:"条件分支结构"}),"\n"]}),"\n",(0,e.jsxs)(r.p,{children:["在实际开发中，代码流程控制可以帮助我们使用较少的代码完成大量重复性的工作。除了本讲中提及的常用流程控制结构外，还有用于条件分支的",(0,e.jsx)(r.a,{href:"http://c.biancheng.net/view/48.html",target:"_blank",rel:"noopener noreferrer",children:"Switch...case...结构"}),"、用于流程控制的",(0,e.jsx)(r.a,{href:"http://c.biancheng.net/view/49.html",target:"_blank",rel:"noopener noreferrer",children:"goto语句"}),"，感兴趣的朋友可以当作扩展阅读。"]}),"\n",(0,e.jsx)(r.p,{children:"➡️ 在下次课程中，我会介绍如下内容："}),"\n",(0,e.jsxs)(r.ul,{children:["\n",(0,e.jsx)(r.li,{children:"Go语言中的数组、切片和集合的声明和赋值"}),"\n"]})]})}function j(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,l.ah)(),n.components);return r?(0,e.jsx)(r,{...n,children:(0,e.jsx)(d,{...n})}):d(n)}let h=j;j.__RSPRESS_PAGE_META={},j.__RSPRESS_PAGE_META["%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3Go%E8%AF%AD%E8%A8%80%2F%E7%AC%AC07%E7%AB%A0%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BD%9C%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E7%AD%89%E5%AE%8C%E6%88%90%E9%87%8D%E5%A4%8D%E6%80%A7%E5%B7%A5%E4%BD%9C.md"]={toc:[{text:"循环结构",id:"循环结构",depth:2},{text:"条件分支结构",id:"条件分支结构",depth:2},{text:"流程控制语句",id:"流程控制语句",depth:2},{text:"小结",id:"小结",depth:2}],title:"第07章—流程控制｜使用循环结构等完成重复性工作",headingTitle:"第07章—流程控制｜使用循环结构等完成重复性工作",frontmatter:{}}}}]);