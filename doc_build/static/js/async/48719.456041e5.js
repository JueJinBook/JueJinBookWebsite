"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["48719"],{508082:function(e,n,r){r.r(n),r.d(n,{default:()=>g});var s=r(552676),i=r(740453);let d=r.p+"static/image/c47fe5dfab2972e1a4ccbc744a9a5cd5.55bb806d.webp",c=r.p+"static/image/5518589f231a7a433a3e746d2675c7e9.9dcc9a87.webp",l=r.p+"static/image/6fe697d844f1bfb1172a2e4bbf5a4b58.382750a9.webp",o=r.p+"static/image/f6731dd1bfa192a03a09498330df9937.5b9cff33.webp",t=r.p+"static/image/e9ac705c88cc23d6f9373c5170c24bb2.26695da1.webp",h=r.p+"static/image/450bef536a3fdc3e8ebef7279604bd29.41beab95.webp",a=r.p+"static/image/f42731cc1dc9374113b62e72b8dd231f.ceec894d.webp",x=r.p+"static/image/f9ffe5b4468a22b47f7e4c61baa878fd.e1926a72.webp",j=r.p+"static/image/1838852daf6f1ac1e9d67bf026f968b3.8caec17d.webp",p=r.p+"static/image/4eeb456e5687d3377ca1248a87fdb8eb.9e79fd6a.webp",u=r.p+"static/image/e9c9c45fb8702a22f754e0294a3fc202.f9d6d413.webp";function b(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",code:"code",h3:"h3",strong:"strong",pre:"pre",blockquote:"blockquote",img:"img"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"32原理篇-beginwork和render全流程",children:["32.原理篇-beginWork和render全流程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32原理篇-beginwork和render全流程",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"一-前言",children:["一 前言",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一-前言",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 fiber 章节介绍过，当组件更新，本质上是从 fiberRoot 开始深度调和 fiber 树。那么本章节将继续围绕 React 调和流程。介绍一下调和流程，首先思考几个问题："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["组件 A 触发 ",(0,s.jsx)(n.code,{children:"setState"})," 或者 ",(0,s.jsx)(n.code,{children:"useState"})," 更新视图，既然 ",(0,s.jsx)(n.code,{children:"fiber"})," 是从 root 开始更新，那么如何找到对应的 A 并 rerender 的呢？"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["组件类型 fiber 进行 ",(0,s.jsx)(n.code,{children:"beginWork"})," 就一定会进行 ",(0,s.jsx)(n.code,{children:"render"})," 吗？"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"二--state-更新源泉",children:["二  state 更新源泉",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二--state-更新源泉",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"1-更新的最小单元",children:["1 更新的最小单元",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-更新的最小单元",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["虽然在 ReactV18 引入订阅外部数据源的 ",(0,s.jsx)(n.code,{children:"useMutableSource"}),"。但在当前版本的 React 中，视图的更新基本都来源于内部 state 的改变。如果有一个组件 A ，如果想要它更新，那么场景有如下情况："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["组件本身改变 ",(0,s.jsx)(n.code,{children:"state"})," 。函数 ",(0,s.jsx)(n.code,{children:"useState"})," | ",(0,s.jsx)(n.code,{children:"useReducer"})," ，类组件 ",(0,s.jsx)(n.code,{children:"setState"})," | ",(0,s.jsx)(n.code,{children:"forceUpdate"}),"。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"props"})," 改变，由组件更新带来的子组件的更新。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"context"}),"更新，并且该组件消费了当前 ",(0,s.jsx)(n.code,{children:"context"})," 。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"无论是上面哪种方式，本质上都是 state 的变化。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"props 改变来源于父级组件的 state 变化。"}),"\n",(0,s.jsxs)(n.li,{children:["context 变化来源于 ",(0,s.jsx)(n.code,{children:"Provider"})," 中 value 变化，而 value 一般情况下也是 state 或者是 state 衍生产物。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"state"})," 改变是在组件对应的 fiber 单位上的，之前的 fiber 章节讲到了在 React 的世界里会存在多种多样的 fiber 类型， 而开发者平时使用的组件 ",(0,s.jsx)(n.code,{children:"function Component"})," 或者 ",(0,s.jsx)(n.code,{children:"Class Component"})," 也是两种不同的 fiber 类型。而且 React 底层对它们的处理逻辑也不相同。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["比如更新类组件用的是 ",(0,s.jsx)(n.code,{children:"updateClassComponent"}),"，它做的事情是初始化时候实例化类组件，更新的话那么直接调用 render 得到新的 ",(0,s.jsx)(n.code,{children:"children"})," ；"]}),"\n",(0,s.jsxs)(n.li,{children:["更新函数组件用的是 ",(0,s.jsx)(n.code,{children:"updateFunctionComponent"}),"，里面调用 ",(0,s.jsx)(n.code,{children:"renderWithHooks"})," 执行函数组件并依次调用 ",(0,s.jsx)(n.code,{children:"hooks"}),"。这里细节问题不需要拘泥。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["那么在整个 ",(0,s.jsx)(n.code,{children:"React"})," 系统中，能够更新 state 的基本都在组件层面上，换句话说只有组件才能出发更新，比如 ",(0,s.jsx)(n.code,{children:"div"})," 元素  hostComponent 类型的 fiber，它是无法独立的自我更新的，只能依赖于父类的组件更新 state ，但是在调和阶段，它也会作为一个任务单元进入到 workLoop 中 ；综上所述，可以这么理解"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"fiber是调和过程中的最小单元，每一个需要调和的 fiber 都会进入 workLoop 中。"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"而组件是最小的更新单元，React 的更新源于数据层 state 的变化。"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-beginwork-更新源泉",children:["2 beginWork 更新源泉",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-beginwork-更新源泉",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["那么我们今天的主角就是组件类型的 fiber 。深入研究一下组件类型的 fiber 调和流程。类组件在 render 阶段的一个重要作用就是产生新的 children ，也就是我们常说的 ",(0,s.jsx)(n.code,{children:"rerender"}),"。只有产生新的 children ，接下来才能深度遍历 children ，改变视图。每一个需要调和的 fiber 都要经历一个过程叫做 ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"beginWork"})})," ，在 beginWork 流程中将执行上述各种 fiber 的更新函数。"]}),"\n",(0,s.jsxs)(n.p,{children:["那么对于组件类型 fiber 说，进入到 workLoop 中，那么一定会 ",(0,s.jsx)(n.code,{children:"rerender"})," 吗？ 答案是否定的，解析来看几种情况。"]}),"\n",(0,s.jsx)(n.p,{children:"主要看一下如下 demo ："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"\n/* 子组件2 */\nfunction Child2(){\n    return <div>子组件 2</div>\n}\n/* 子组件1 */\nfunction Child1(){\n    const [ num , setNumber ] = React.useState(0)\n    return <div>\n        子组件 {num}\n        <button onClick={() => setNumber(num+1)} >按钮1</button>\n     </div>\n}\n/* 父组件 */\nexport default function Index(){\n    const [ num , setNumber ] = React.useState(0)\n    return <div>\n        <p>父组件 {num} </p>\n        <Child1 />\n        <Child2 />\n        <button onClick={()=> setNumber(num+1)} >按钮2</button>\n    </div>\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"场景一"}),"：如上 demo 中，当点击 ",(0,s.jsx)(n.code,{children:"Child1"})," 的 ",(0,s.jsx)(n.strong,{children:"按钮1"})," 的时候，Child1 会渲染，那么 Child1 自然会进入到 ",(0,s.jsx)(n.code,{children:"beginWork"})," 流程中，那么疑问来了："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["问题一：父组件 ",(0,s.jsx)(n.code,{children:"Index"})," 没有更新，会 rerender 吗？那么有会进入 ",(0,s.jsx)(n.code,{children:"beginWork"})," 流程吗 ？"]}),"\n",(0,s.jsxs)(n.li,{children:["问题二：",(0,s.jsx)(n.code,{children:"Child2"})," 会进入 ",(0,s.jsx)(n.code,{children:"beginWork"}),"流程吗 ？"]}),"\n",(0,s.jsxs)(n.li,{children:["问题三：如果 ",(0,s.jsx)(n.code,{children:"Index"})," 会 ",(0,s.jsx)(n.code,{children:"beginWork"}),"，那么 React 从 Root fiber 开始调和的时候，是如何找到更新的事发点 Index 的呢？"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"场景二"}),"：在如上 demo 中，当点击 Index 中的 ",(0,s.jsx)(n.strong,{children:"按钮2"})," 的时候："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["问题四：",(0,s.jsx)(n.code,{children:"Index"})," 因为本身的 ",(0,s.jsx)(n.code,{children:"state"})," 改变会更新，那么 ",(0,s.jsx)(n.code,{children:"Child1"})," 和 ",(0,s.jsx)(n.code,{children:"Child2"})," 为什么会跟着更新。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们开始以一次更新开始，分析调和过程中 beginWork 流程。"}),"\n",(0,s.jsx)(n.p,{children:"在正式流程分析之前，先来看一下 v17 引出的新的概念，在 v16 版本，任务的优先级用 expirationTime 表示，在 v17 版本被 lane 取缔。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"lane"})," ： 更新优先级。（在一次更新任务中，将赋予给更新的 fiber 的一个更新优先级 lane。）"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"childLanes"}),"：",(0,s.jsx)(n.code,{children:"children"})," 中更新优先级。（如果当前 fiber 的 child 中有高优先级任务，那么当前 fiber 的 childLanes 等于当前优先级）。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"记住这两个概念对于下面流程分析很有帮助。接下来带着上面的四个问题，开始往下分析。"}),"\n",(0,s.jsxs)(n.h2,{id:"三-起源-从-state-改变到-scheduleupdateonfiber",children:["三 起源: 从 state 改变到 scheduleUpdateOnFiber",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三-起源-从-state-改变到-scheduleupdateonfiber",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["下面以前面的点击按钮触发一次更新为例子\uD83C\uDF30，深入探讨一下更新的始末源头。首先上述讲到过更新是以",(0,s.jsx)(n.strong,{children:"组件"}),"为粒度，那么调用 ",(0,s.jsx)(n.code,{children:"useState"})," 或者是 ",(0,s.jsx)(n.code,{children:"setState"})," 接下来会发生什么呢？"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"类组件 setState 更新"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberClassComponent.new.js  -> classComponentUpdater"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"enqueueSetState(inst, payload, callback){\n     const fiber = getInstance(inst);       \n     const lane = requestUpdateLane(fiber);\n     scheduleUpdateOnFiber(fiber, lane, eventTime);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"函数组件 useState 更新"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberHooks.new.js -> dispatchReducerAction"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function dispatchReducerAction(fiber,queue,action){\n    const lane = requestUpdateLane(fiber);\n    scheduleUpdateOnFiber(fiber, lane, eventTime);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"如上代码都是精简后，保留的最核心的流程。可以明确看到，无论是组件更新的本质就是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"创建一个任务优先级 lane。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["然后进行 ",(0,s.jsx)(n.strong,{children:"scheduleUpdateOnFiber"}),"。 那么这个 scheduleUpdateOnFiber 应该就是整个 React 更新任务的开始。那么这个函数到底做了些什么呢 ？"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-scheduleupdateonfiber-开始更新-fiber",children:["1 scheduleUpdateOnFiber 开始更新 fiber",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-scheduleupdateonfiber-开始更新-fiber",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.new.js  -> scheduleUpdateOnFiber"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function scheduleUpdateOnFiber(fiber,lane){\n    /* 递归向上标记更新优先级 */\n    const root = markUpdateLaneFromFiberToRoot(fiber, lane);\n    if(root === null) return null\n    /* 如果当前 root 确定更新，那么会执行 ensureRootIsScheduled */\n    ensureRootIsScheduled(root, eventTime);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"scheduleUpdateOnFiber 主要做了两件事："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第一个就是通过当前的更新优先级 lane ，把当前 fiber  到 rootFiber 的父级链表上的所有优先级都给更新了。"}),"\n",(0,s.jsx)(n.li,{children:"如果当前 fiber 确定更新，那么会调用 ensureRootIsScheduled ，"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"那么 markUpdateLaneFromFiberToRoot 如何标记的优先级？ 这个很重要！"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.new.js  -> markUpdateLaneFromFiberToRoot"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * @param {*} sourceFiber 发生 state 变化的fiber ，比如组件 A 触发了 useState ，那么组件 A 对应的 fiber 就是 sourceFiber\n * @param {*} lane        产生的更新优先级\n */\nfunction markUpdateLaneFromFiberToRoot(sourceFiber,lane){\n    /* 更新当前 fiber 上 */\n    sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n    /* 更新缓存树上的 lanes */\n    let alternate = sourceFiber.alternate;\n    if (alternate !== null) alternate.lanes = mergeLanes(alternate.lanes, lane);\n    /* 当前更新的 fiber */\n    let node = sourceFiber;\n    /* 找到返回父级 */\n    let parent = sourceFiber.return;\n    while(parent !== null){\n        /* TODO: 更新 childLanes 字段 */\n        parent.childLanes = mergeLanes(parent.childLanes, lane);\n        if (alternate !== null) {  alternate.childLanes = mergeLanes(alternate.childLanes, lane); }\n        /* 递归遍历更新 */\n        node = parent;\n        parent = parent.return;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"markUpdateLaneFromFiberToRoot 做的事很重要。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["首先会更新当前 fiber 上的更新优先级。在 fiber 章节我们讲过，fiber 架构采用 ‘连体婴’形式的双缓冲树，所有还要更新当前 fiber 的缓冲树 ",(0,s.jsx)(n.code,{children:"alternate"})," 上的优先级。"]}),"\n",(0,s.jsx)(n.li,{children:"然后会递归向上把父级连上的 childLanes 都更新，更新成当前的任务优先级。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"重点想一想为什么向上递归更新父级的 childLanes ？"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"首先通过 fiber 章节我们知道，所有的 fiber 是通过一颗 fiber 树关联到一起的，如果组件 A 发生一次更新，React 是从 root 开始深度遍历更新 fiber 树。"}),"\n",(0,s.jsx)(n.li,{children:"那么更新过程中需要深度遍历整个 fiber 树吗？，当然也不是，那么只有一个组件更新，所有的 fiber 节点都调和无疑是性能上的浪费。"}),"\n",(0,s.jsxs)(n.li,{children:["既然要从头更新，又不想调和整个 fiber 树，那么如何找到更新的组件 A 呢？这个时候 ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"childLanes"})})," 就派上用场了，如果 A 发生了更新，那么先向上递归更新父级链的 ",(0,s.jsx)(n.code,{children:"childLanes"}),"，接下来从 Root Fiber 向下调和的时候，发现 childLanes 等于当前更新优先级，那么说明它的 child 链上有新的更新任务，则会继续向下调和，反之退出调和流程。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这样就解决了上面问题3 ",(0,s.jsx)(n.code,{children:"如果 "}),"Index",(0,s.jsx)(n.code,{children:" 会 "}),"beginWork",(0,s.jsx)(n.code,{children:"，那么 React 从 Root fiber 开始调和的时候，是如何找到更新的事发点 Index 的呢？"}),"，",(0,s.jsx)(n.strong,{children:"Root Fiber 是通过 childLanes 逐渐向下调和找到需要更新的组件的。"})]}),"\n",(0,s.jsx)(n.p,{children:"为了更清晰的了解流程这里画了一个流程图。如下："}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)("img",{src:u,alt:"1.jpg"}),"\n上面描述了整个 fiber 树调和流程。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["第一阶段是发生更新，那么产生一个更新优先级 ",(0,s.jsx)(n.code,{children:"lane"})," 。"]}),"\n",(0,s.jsx)(n.li,{children:"第二阶段向上标记 childLanes 过程。"}),"\n",(0,s.jsx)(n.li,{children:"第三阶段是向下调和过程，有的同学会问，为什么 A 会被调和，原因是 A 和 B 是同级，如果父级元素调和，并且向下调和，那么父级的第一级子链上的 fiber 都会进入调和流程。从 fiber 关系上看，Root 先调和的是 child 指针上的 A ，然后 A 会退出向下调和，接下来才是 sibling B，接下来 B 会向下调和，通过 childLanes 找到当事人 F，然后 F 会触发 render 更新。这也就解决问题2，Child2 的调和问题。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["通过上述我们知道了如何找到 F 并执行 render 的，那么还有一个问题，就是 B，E 会向下调和，如果它们是组件，那么会 render 么，答案是否定的，要记住的是",(0,s.jsx)(n.strong,{children:"调和过程并非 render 过程"}),"，调和过程有可能会触发 render 函数，也有可能只是继续向下调和，而本身不会执行 render 。这就解释了上述的问题1。"]}),"\n",(0,s.jsxs)(n.p,{children:["既然知道了如何去更新 childLanes ，以及更新 childLanes 的意义，我们接着向下分析流程。在 scheduleUpdateOnFiber 中，最后会调用 ",(0,s.jsx)(n.code,{children:"ensureRootIsScheduled"})," ，那么它的作用又是什么呢？"]}),"\n",(0,s.jsx)(n.p,{children:"由于 ensureRootIsScheduled 源码比较繁琐，这里就不占篇幅了，它的作用就是根据任务的类型，发起异步调度任务，在调度章节已经讲了调度流程。接下来会走调度的流程。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["对于 ",(0,s.jsx)(n.code,{children:"legacy sync"})," 模式最后的更新任务是 ",(0,s.jsx)(n.code,{children:"performSyncWorkOnRoot"})," 。"]}),"\n",(0,s.jsxs)(n.li,{children:["对于 ",(0,s.jsx)(n.code,{children:"Concurrent"})," 模式最后的更新任务是 ",(0,s.jsx)(n.code,{children:"performConcurrentWorkOnRoot"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"我们今天主要讲的是组件 beginWork 更新流程，所以这里主要以 legacy 模式为主，所以跟着 performSyncWorkOnRoot 流程往下看："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.new.js  -> performSyncWorkOnRoot"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function performSyncWorkOnRoot(root) {\n    /* render 阶段 */\n    let exitStatus = renderRootSync(root, lanes);\n    /* commit 阶段 */\n    commitRoot(root);\n    /* 如果有其他的等待中的任务，那么继续更新 */\n    ensureRootIsScheduled(root, now());\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["之前的章节中介绍了调和的两大阶段 ",(0,s.jsx)(n.code,{children:"render"})," 和 ",(0,s.jsx)(n.code,{children:"commit"})," 都在这个函数中执行。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"renderRootSync"})," 代表 render 阶段。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"commitRoot"})," 代表 commit 阶段。"]}),"\n",(0,s.jsx)(n.li,{children:"当 render 和 commit 阶段执行之后，如果有其他的等待中的任务，那么继续执行调度任务。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"到此为止，一次更新调度任务的初始化工作完成。开始正式进入调和阶段。我对前戏阶段做一下总结，流程图如下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:"2.jpg"})}),"\n",(0,s.jsxs)(n.h2,{id:"四-探索从-workloop-到-beginwork",children:["四 探索：从 workLoop 到 beginWork",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四-探索从-workloop-到-beginwork",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["上述讲到了 performSyncWorkOnRoot 正式进入了 fiber 的调和流程。因为本章节主要讲 beginWork 和组件更新流程，这些主要都发生在 ",(0,s.jsx)(n.code,{children:"render"})," 阶段，所以下面将围绕 ",(0,s.jsx)(n.code,{children:"renderRootSync"})," 展开。首先看一下 renderRootSync 做了什么？"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.new.js  -> renderRootSync"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function renderRootSync(root,lanes){\n    workLoopSync();\n    /* workLoop完毕后，证明所有节点都遍历完毕，那么重置状态，进入 commit 阶段 */\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"renderRootSync 核心功能："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["执行 ",(0,s.jsx)(n.code,{children:"workLoopSync"}),"。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"workLoop"})," 完毕后，证明所有节点都遍历完毕，那么重置状态，进入 ",(0,s.jsx)(n.code,{children:"commit"})," 阶段。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"workLoopSync"})," 在整个 render 流程中充当的角色非常重要，可以把 ",(0,s.jsx)(n.code,{children:"workLoopSync"})," 当作一个循环运作的加工器，每一个需要调和的 fiber 可以当作一个零件，每一个零件都需要进入加工器，如果没有待加工的零件，那么加工器才停止运转。下面就是加工器的具体实现。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.new.js -> workLoopSync"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function workLoopSync() {\n  /* 循环执行 performUnitOfWork ，一直到 workInProgress 为空 */\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["如上只要 ",(0,s.jsx)(n.code,{children:"workInProgress"})," 不为 ",(0,s.jsx)(n.code,{children:"null"}),"（还有需要调和的 fiber），那么 workLoopSync 会循环调用 performUnitOfWork。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["在调度章节讲到过，当 Concurrent 模式下会通过 ",(0,s.jsx)(n.code,{children:"shouldYield"})," ，来判断有没有过期的任务，有过期任务，会中断 workLoop ，那么也就是说明了",(0,s.jsx)(n.strong,{children:"render阶段是可以被打断的。"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"while (workInProgress !== null && !shouldYield()) {\n  performUnitOfWork(workInProgress);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["回到 workLoopSync 流程上来，通过 fiber 章节，讲到 fiber 树是深度优先遍历得到的，在遍历完父节点，那么接下来就会遍历子节点。在这其中，每一个调和的 fiber 都将作为 ",(0,s.jsx)(n.code,{children:"workInProgress"})," 进行调和更新。"]}),"\n",(0,s.jsx)(n.p,{children:"无论什么模式，workLoop 的执行单元都是 fiber 。而且更新单元的函数叫做 performUnitOfWork 。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberWorkLoop.new.js -> performUnitOfWork"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function performUnitOfWork(unitOfWork){\n    const current = unitOfWork.alternate;\n    let  next = beginWork(current, unitOfWork, subtreeRenderLanes);\n    unitOfWork.memoizedProps = unitOfWork.pendingProps;\n    if (next === null) {\n       completeUnitOfWork(unitOfWork);\n    } else {\n      workInProgress = next;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 fiber 章节讲到过, beginWork 是向下调和流程，completeUnitOfWork 是向上归并的流程。那么以组件更新流程为目的，我们接下来重点研究 beginWork 流程。"}),"\n",(0,s.jsx)(n.p,{children:"在介绍 beginWork 之前先来看几个场景："}),"\n",(0,s.jsx)(n.p,{children:"假设有一个组件 fiber 链。我们在这个 fiber 链上暂且无视其他类型的 fiber，只保留组件类型的 fiber。结构如下："}),"\n",(0,s.jsx)(n.p,{children:"root Fiber --child--\x3e A组件 --child--\x3e B组件 --child--\x3e C组件。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:"4.jpg"})}),"\n",(0,s.jsxs)(n.p,{children:["而主角就是",(0,s.jsx)(n.strong,{children:"组件B"}),"，以组件B 为参考。来看一下 React 如何调和的。那么一次更新就有可能有三种场景："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["场景一：",(0,s.jsx)(n.strong,{children:"更新 A 组件 state"}),"，那么 A 触发更新，那么如果 B,C 没有做渲染控制处理（比如 memo PureComponent），那么更新会波动到 B ， C，那么 A，B，C 都会 rerender。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:"5.jpg"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["场景二：",(0,s.jsx)(n.strong,{children:"当更新 B 组件"}),"，那么组件 A fiber 会被标记，然后 A 会调和，但是不会 rerender；组件 B 是当事人，既会进入调和，也会 rerender；组件 C 受到父组件 B 的影响，会 rerender。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:"6.jpg"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["场景三；",(0,s.jsx)(n.strong,{children:"当更新 C组件"}),"，那么 A，B 会进入调和流程，但是不会 rerender，C 是当事人，会调和并 rerender。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:"7.jpg"})}),"\n",(0,s.jsxs)(n.p,{children:["那么如上的场景本质上都在 ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"beginWork"})})," 中进行的，这个 beginWork 是如何处理这些逻辑的。"]}),"\n",(0,s.jsxs)(n.h2,{id:"五-揭秘从-beginwork-到组件更新全流程",children:["五 揭秘：从 beginWork 到组件更新全流程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五-揭秘从-beginwork-到组件更新全流程",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来从 beginWork 开始，重点研究一下流程。"}),"\n",(0,s.jsxs)(n.h3,{id:"1-beginwork-更新的调度站",children:["1 beginWork 更新的调度站",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-beginwork-更新的调度站",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberBeginWork.new.js  -> beginWork"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"/**\n * @param {*} current         current 树 fiber \n * @param {*} workInProgress  workInProgress 树 fiber \n * @param {*} renderLanes     当前的 render 优先级\n * @returns \n */\nfunction beginWork(current,workInProgress,renderLanes){\n    /* -------------------第一部分-------------------- */\n    if(current !== null){ \n        /* 更新流程 */\n        /* current 树上上一次渲染后的 props */\n        const oldProps = current.memoizedProps;\n        /* workInProgress 树上这一次更新的 props  */\n        const newProps = workInProgress.pendingProps;\n        \n        if(oldProps !== newProps ||  hasLegacyContextChanged()){\n          didReceiveUpdate = true;\n        }else{\n          /* props 和 context 没有发生变化，检查是否更新来自自身或者 context 改变 */\n          const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current,renderLanes)\n          if(!hasScheduledUpdateOrContext){\n              didReceiveUpdate = false;\n              return  attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes)\n          }\n          /* 这里省略了一些判断逻辑 */\n          didReceiveUpdate = false;\n        }\n\n    }else{\n      didReceiveUpdate = false\n    }\n    /* -------------------第二部分-------------------- */\n    /* TODO: 走到这里流程会被调和 | 更新，比如函数执行会执行，类组件会执行 render 。 */\n    switch(workInProgress.tag){\n        /* 函数组件的情况 */\n        case FunctionComponent: {\n           return updateFunctionComponent( current, workInProgress, Component, resolvedProps, renderLanes )\n        }\n        /* 类组件的情况 */\n        case ClassComponent:{\n          return updateClassComponent(current,workInProgress,Component,resolvedProps,renderLanes)\n        }\n        /* 元素类型 fiber <div>, <span>  */\n        case HostComponent:{\n          return updateHostComponent(current, workInProgress, renderLanes)\n        }\n        /* 其他 fiber 情况 */ \n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["如上就是 ",(0,s.jsx)(n.code,{children:"beginWork"})," 的全流程，我们可以看到整个流程分为两个阶段。"]}),"\n",(0,s.jsxs)(n.h3,{id:"2-第一阶段",children:["2 第一阶段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-第一阶段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["第一部分，这部分非常重要就是判断更新情况的，上面的三种场景都可以在第一阶段进行判断处理。先来分析一下第一阶段做了哪些事。正式讲解之前先来看一个变量的意义，那就是 ",(0,s.jsx)(n.code,{children:"didReceiveUpdate"})," 。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["didReceiveUpdate ：这个变量主要证明当前更新是否来源于父级的更新，那么自身并没有更新。比如更新 B 组件，那么 C组件也会跟着更新，这个情况下 ",(0,s.jsx)(n.code,{children:"didReceiveUpdate = true"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["首先通过 ",(0,s.jsx)(n.code,{children:"current!== null"})," 来判断当前 fiber 是否创建过，如果第一次 mounted ， 那么 current 为 null，而第一阶段主要针对更新的情况。如果初始化，那么直接跳过第一阶段，",(0,s.jsx)(n.strong,{children:"到第二阶段。"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"如果是更新流程。那么判断 oldProps === newProps（源码中还判断了老版本 context 是否变化），那么两者相等。一般会有以下几种情况："}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"情况一"}),"：还是回到上面场景上来，如果 C 组件更新，那么 B 组件被标记 ChildLanes 会进入到 beginWork 调和阶段，但是 B 组件本身 props 不会发生变化。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"情况二"}),"：通过 useMemo 等方式缓存了 React element 元素，在渲染控制章节讲到过。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"情况三"}),"：就是更新发生在当前组件本身，比如 B 组件发生更新，但是 B 组件的 props 并没有发生变化，所以也会走到这个流程上来。"]}),"\n",(0,s.jsxs)(n.p,{children:["反之如果两者不想等，证明父级 fiber 重新 rerender 导致了 props 改变，此时 didReceiveUpdate = true ，那么第一阶段完成，",(0,s.jsx)(n.strong,{children:"进入到第二阶段。"})]}),"\n",(0,s.jsxs)(n.p,{children:["刚才讲到如果",(0,s.jsx)(n.strong,{children:"新老 props 相等"}),"，会有一些处理逻辑。那么如果处理的呢？第一个就是调用 ",(0,s.jsx)(n.code,{children:"checkScheduledUpdateOrContext"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"checkScheduledUpdateOrContext"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberBeginWork.new.js  -> checkScheduledUpdateOrContext"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function checkScheduledUpdateOrContext(current,renderLanes){\n    const updateLanes = current.lanes;\n    /* 这种情况说明当前更新 */\n    if (includesSomeLane(updateLanes, renderLanes)) {\n      return true;\n    }\n     /* 如果该 fiber 消费了 context ，并且 context 发生了改变。 */\n    if (enableLazyContextPropagation) {\n      const dependencies = current.dependencies;\n      if (dependencies !== null && checkIfContextChanged(dependencies)) {\n        return true;\n      }\n    }\n  return false;\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["当新老 props 相等情况，首先会检查当前 fiber 的 ",(0,s.jsx)(n.code,{children:"lane"})," 是否等于当前的更新优先级，如果相等，那么证明更新来源当前 fiber，比如 B 组件发生更新，那么会走这里（情况三）。当然期间也会判断是否有消费 ",(0,s.jsx)(n.code,{children:"context"})," 并发生了变化。最后返回状态 hasScheduledUpdateOrContext 。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如果 ",(0,s.jsx)(n.code,{children:"hasScheduledUpdateOrContext"})," 为 false，证明当前组件没有更新，也没有 context 上的变化，那么还有一种情况就是 child 可能有更新，但是当前 fiber 不需要更新（情况一）。那么会直接返回 ",(0,s.jsx)(n.code,{children:"attemptEarlyBailoutIfNoScheduledUpdate"})," ，",(0,s.jsx)(n.strong,{children:"退出第二阶段"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["attemptEarlyBailoutIfNoScheduledUpdate 这个函数会处理部分 Context 逻辑，但是最重要的是调用了 ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"bailoutOnAlreadyFinishedWork"})})," 。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"react-reconciler/src/ReactFiberBeginWork.new.js -> bailoutOnAlreadyFinishedWork"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){\n     /* 如果 children 没有高优先级的任务，说明所有的 child 都没有更新，那么直接 返回，child 也不会被调和  */\n    if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n      /* 这里做了流程简化 */\n      return null \n    }\n    /* 当前fiber没有更新。但是它的children 需要更新。  */\n    cloneChildFibers(current, workInProgress);\n    return workInProgress.child;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"bailoutOnAlreadyFinishedWork 流程非常重要。它主要做了两件事。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"首先通过 includesSomeLane 判断 childLanes 是否是高优先级任务，如果不是，那么所有子孙 fiber 都不需要调和 ，那么直接返回 null，child 也不会被调和。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["如果 childLanes 优先级高，那么证明 child 需要被调和，但是当前组件不需要，所以会克隆一下 children，返回 children ，那么本身不会 ",(0,s.jsx)(n.code,{children:"rerender"}),"。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"到这里第一阶段完成了，完成了组件更新流程的所有情况。第一阶段完成会进入到更新的第二阶段。"}),"\n",(0,s.jsxs)(n.h3,{id:"3-第二阶段",children:["3 第二阶段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-第二阶段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["从 beginWork 的源码中可以看到，第二阶段就是更新 fiber，比如是函数组件，就会调用 ",(0,s.jsx)(n.code,{children:"updateFunctionComponent"}),"，类组件就调用 ",(0,s.jsx)(n.code,{children:"updateClassComponent"}),"，然后进行 rerender 了。"]}),"\n",(0,s.jsxs)(n.h3,{id:"4-流程总结",children:["4 流程总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-流程总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["接下来以上述中的",(0,s.jsx)(n.strong,{children:"组件B"}),"为例子，在强化一下更新流程。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"场景一"}),"：当更新 A 时候，那么 A 组件的 fiber 会进入调和流程，会执行 render 形成新的组件 B 对应的 element 元素，接下来调和 B ，因为 B 的 newProps 不等于 oldProps，所以会 didReceiveUpdate = true ，然后更新组件，也会触发 render。（这里都是默认没有渲染控制的场景，比如 memo PureComponent 等 ），这样也就解决了文章开头的问题四。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:"8.jpg"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"场景二"}),"：当更新 B 时候，那么 A 组件会标记 childLanes，所以 A 会被调和，但是不会 render，然后到了主角 B ，B 由于新老 props 相等，所以会 ",(0,s.jsx)(n.code,{children:"checkScheduledUpdateOrContext"})," 流程，判断 lane 等于 renderLanes ，检查到 lane 等于 renderLane，所以会执行更新，触发 render。 C 组件也就跟着更新。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"9.jpg"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"场景三"}),"：当更新 C 时候，那么 A 和 B 组件会标记 childLanes，所以 A 和 B 会被调和，但是不会更新，然后到 C ，C 会走正常流程。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:"10.jpg"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"场景四"}),"：还有一种情况，什么时候 B 会跳出调和流程呢。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"11.jpg"})}),"\n",(0,s.jsx)(n.p,{children:"到此为止完成了整个更新流程。"}),"\n",(0,s.jsxs)(n.h3,{id:"5-beginwork-流程图",children:["5 beginWork 流程图",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-beginwork-流程图",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"3.jpg"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"通过本章节的学习，我们应该掌握的知识点如下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"组件更新和调和过程。rerender 一定会调和，但是调和并不一定 rerender，也有可能找到待更新的子元素。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"组件类型的更新的几种情况。"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"从出发更新到 beginWork 全流程。"}),"\n"]}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}let g=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["React%20%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F32.%E5%8E%9F%E7%90%86%E7%AF%87-beginWork%E5%92%8Crender%E5%85%A8%E6%B5%81%E7%A8%8B.md"]={toc:[{text:"一 前言",id:"一-前言",depth:2},{text:"二  state 更新源泉",id:"二--state-更新源泉",depth:2},{text:"1 更新的最小单元",id:"1-更新的最小单元",depth:3},{text:"2 beginWork 更新源泉",id:"2-beginwork-更新源泉",depth:3},{text:"三 起源: 从 state 改变到 scheduleUpdateOnFiber",id:"三-起源-从-state-改变到-scheduleupdateonfiber",depth:2},{text:"1 scheduleUpdateOnFiber 开始更新 fiber",id:"1-scheduleupdateonfiber-开始更新-fiber",depth:3},{text:"四 探索：从 workLoop 到 beginWork",id:"四-探索从-workloop-到-beginwork",depth:2},{text:"五 揭秘：从 beginWork 到组件更新全流程",id:"五-揭秘从-beginwork-到组件更新全流程",depth:2},{text:"1 beginWork 更新的调度站",id:"1-beginwork-更新的调度站",depth:3},{text:"2 第一阶段",id:"2-第一阶段",depth:3},{text:"3 第二阶段",id:"3-第二阶段",depth:3},{text:"4 流程总结",id:"4-流程总结",depth:3},{text:"5 beginWork 流程图",id:"5-beginwork-流程图",depth:3},{text:"总结",id:"总结",depth:2}],title:"32.原理篇-beginWork和render全流程",headingTitle:"32.原理篇-beginWork和render全流程",frontmatter:{}}}}]);