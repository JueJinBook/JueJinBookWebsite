"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["86020"],{540536:function(e,n,r){r.r(n),r.d(n,{default:()=>K});var s=r(552676),i=r(740453);let l=r.p+"static/image/e7a9a530f2affe5c0a484f80f8be4ba6.962c35df.gif",c=r.p+"static/image/553e31ba06165c5f941744615a54a54c.8de79557.gif",a=r.p+"static/image/1dc800264176bc6fa73155da6372f7fc.e0945429.gif",d=r.p+"static/image/22ae14b1881763b811ea8844affa5a90.13e5cf19.gif",o=r.p+"static/image/6938dae743e54115ce579423ef56986d.91610a87.gif",t=r.p+"static/image/710bcd0419de4e2d9158058e417697c4.13e5cf19.gif",h=r.p+"static/image/2add7e68519c4322b85d5df467011a9a.bcaba02e.gif",p=r.p+"static/image/2ad20c49536b5b4c78d0356358e05d3c.4a05c670.gif",x=r.p+"static/image/a063ec7fa0d0e28873a48d6d796c0213.d423ed26.gif",j=r.p+"static/image/308c7ab26818cf6caa4eb5f20f5757e0.afe4d22f.gif",f=r.p+"static/image/65bcb6e135906f49c2526d4cc576cba0.2f211441.gif",g=r.p+"static/image/da01ba6c68818d387fed80e70d0e8da5.4c8683c0.gif",b=r.p+"static/image/e183b4bdc2b307e82ff4e471b8869c9d.4c6c0ef3.gif",u=r.p+"static/image/cd6edf773a704ea0bd2f87695c1c2ebd.afe46534.webp",m=r.p+"static/image/07a1d271d26a472d401940e11fbc6ba6.90e4d9df.webp",_=r.p+"static/image/63a00d61a7a301491f154d7cfd314d1b.f9835053.webp",v=r.p+"static/image/cc5e6eb0efae252f8c49d7e1e25e0cf8.47a9db10.gif",O=r.p+"static/image/932e0153b2edfcf1865e07827f1a6a7d.9f5e31b4.gif",k=r.p+"static/image/e54071812c9b61b833b43fed759defe4.51425451.gif",G=r.p+"static/image/5f827b9ea0c7bb3805bb9f66bd71e95d.9a0d76ed.gif",S=r.p+"static/image/7d7906a5b3f888dc91864bbc3640c518.efcbef02.gif",C=r.p+"static/image/a168c784ef228fbdda5c3c9a1033edee.e2138438.gif",y=r.p+"static/image/61b338fef4543c66ce1c694daa053d3a.a78af7be.gif",B=r.p+"static/image/c19fceb27620b339c9aaf4ceac570d7d.f1b09ae6.webp",E=r.p+"static/image/916414e41111c004eb0e337a6a2e8d10.c03fefab.webp",L=r.p+"static/image/daf1a7be146a450e6c9914889c26f7cd.db55258e.gif",R=r.p+"static/image/f8fe600b4a84aeb8a0f5c6cc48a897bf.8fbc32aa.gif",Y=r.p+"static/image/b7154e9767eef51b45cc4dd8cdd0c1fa.43ab0ec3.gif",N=r.p+"static/image/ae18da6c16ed7ac3352dbdded60ee01e.948077f2.gif",w=r.p+"static/image/36368da5063962a157ad6ca70b339189.fe2b0214.gif",M=r.p+"static/image/f99d24f8afeca5eec4ce698937ca2879.c1e2be4f.gif",q=r.p+"static/image/167d3a31c9b08f01ab13d0b2ca2564bc.1faf5994.gif",D=r.p+"static/image/1a4543828844d4e9f9b0ff5373940fc5.9243b874.gif",W=r.p+"static/image/6c54c153a5823e04b73e45f8b2eb1d89.fd74f21d.gif",V=r.p+"static/image/9df8962e70a70ff91238aae67ce3e292.0d7894bb.gif",z=r.p+"static/image/b14723e5c817fa632ca03aa94077c48f.481f5b0f.gif",A=r.p+"static/image/f5fd34b13725489c6adb8c3e1e30014c.cbdea06c.gif",Q=r.p+"static/image/f2f36a7a1b3f5f18719fb9fdcc92f356.aa9aae4d.gif",U=r.p+"static/image/b29b059c5657f6cb1dfa51b4c4ecc828.294f74eb.gif",J=r.p+"static/image/6b1f506848199c40e3bd5dc4a5893a2f.c8433eca.gif",T=r.p+"static/image/454ec485691ca011c8e4b111b5443dba.fc5cf7a4.gif",Z=r.p+"static/image/5e8f03473399c2cd928bf52bf66d37ac.edcb408c.gif",X=r.p+"static/image/32b678c5cb3d154189bbf5514acb2ebb.22e24839.webp",H=r.p+"static/image/221efce910dfff8a79217916e5ee3810.f5bd4a74.webp";function P(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",strong:"strong",h2:"h2",h3:"h3",blockquote:"blockquote",code:"code",pre:"pre",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"43-高级篇svg-滤镜的进阶之黏糊效果",children:["43-高级篇：SVG 滤镜的进阶之黏糊效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-高级篇svg-滤镜的进阶之黏糊效果",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:H,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["在现代 Web 设计中，",(0,s.jsx)(n.strong,{children:"黏糊效果（Gooey Effect）"})," 作为一种引人注目的视觉效果，正变得越来越受欢迎。这种效果通过柔和、流动的动画，使界面元素看起来仿佛被一种黏性物质连接在一起，为用户体验带来了独特的动态感和互动性。无论是按钮、加载动画还是背景装饰，黏糊效果都能为页面增添独特的魅力和生动的表现力。"]}),"\n",(0,s.jsx)(n.p,{children:"在这节课中，我们将通过一些常见的案例，如带有黏糊效果的按钮、导航菜单和背景装饰，向大家介绍使用SVG滤镜实现黏糊效果的核心技术与细节。你将学习到如何通过实际代码示例，逐步掌握这些技术，并将它们灵活应用到你的设计项目中。"}),"\n",(0,s.jsx)(n.p,{children:"通过这节课的学习，你将全面掌握在Web上实现黏糊效果的技能，能够自如地将这种富有创意和动感的效果融入到你的设计中。让我们一起踏上这段充满探索和创新的旅程，利用黏糊效果为你的 Web 设计注入新的活力和吸引力！"}),"\n",(0,s.jsxs)(n.h2,{id:"黏糊效果简介",children:["黏糊效果简介",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#黏糊效果简介",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:X,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"想象一下雨滴在玻璃上流动的样子。雨滴会沿着玻璃表面滑动，并且在碰到其他雨滴时会合并在一起，形成更大的液滴。这种自然的流动和融合现象非常类似于黏糊效果在 Web 上的表现。"}),"\n",(0,s.jsx)(n.p,{children:"Web 上的黏糊效果（Gooey Effect）是一种视觉效果。它的主要特点在于其流畅、连贯的动画表现。元素之间的连接就像液体一般，具有柔和的边缘和自然的过渡。这种效果不仅增加了界面的视觉吸引力，还能增强用户的互动体验，使操作更加直观有和有趣。"}),"\n",(0,s.jsxs)(n.h2,{id:"黏糊效果在-web-上的应用",children:["黏糊效果在 Web 上的应用",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#黏糊效果在-web-上的应用",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在实际应用中，黏糊效果广泛出现在按钮、加载动画、导航菜单和背景装饰等各种 Web 元素上。"}),"\n",(0,s.jsxs)(n.h3,{id:"按钮",children:["按钮",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#按钮",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 Web 设计中，一个常见的黏糊效果应用场景是按钮。当用户将鼠标悬停在按钮上时，按钮的边缘会产生流动的动画效果，仿佛按钮正在融化或扩散。这种效果不仅美观，还能提供即时的视觉反馈，提升用户体验："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:Z,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/architechnium/full/wpYgGY",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/architechnium/full/wpYgGY"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:T,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/jakewhiteleydev/details/ymoWZo",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/jakewhiteleydev/details/ymoWZo"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"加载动画",children:["加载动画",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载动画",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"加载动画是另一个常见的应用场景。当 Web 页面正在加载内容时，使用黏糊效果的动画可以让等待过程变得更有趣和富有吸引力。通过模拟液滴的流动或黏液的移动，加载动画不仅美观，还能减少用户的等待焦虑。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:J,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/marknotton/full/dyPrrMd",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/marknotton/full/dyPrrMd"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"导航菜单",children:["导航菜单",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#导航菜单",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在导航菜单中，黏糊效果可以用于菜单项的切换和悬停效果。当用户在不同的菜单项之间移动时，菜单项之间可以产生柔和的流动效果，仿佛菜单项之间被黏液连接。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:U,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/simeydotme/full/LYLxJqV",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/simeydotme/full/LYLxJqV"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:Q,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/onediv/full/WNOdMWw",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/onediv/full/WNOdMWw"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"图像悬停效果",children:["图像悬停效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图像悬停效果",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"图像悬停效果是黏糊效果的另一个应用场景。当用户将鼠标悬停在图片上时，图片会产生柔和的流动效果，使图片看起来更生动、吸引人。这种效果可以增强用户与图片之间的互动性。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/iremlopsum/full/VQOvOW",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/iremlopsum/full/VQOvOW"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"表单元素",children:["表单元素",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#表单元素",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"表单元素在获得焦点或输入时，通过黏糊效果提供视觉反馈，提升用户体验。当用户点击或输入信息时，输入框的边缘会产生柔和的流动效果，使表单填写过程更加流畅和愉快。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:z,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/ainalem/full/EbdZrx",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/ainalem/full/EbdZrx"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:V,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/ainalem/full/dZwyBo",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/ainalem/full/dZwyBo"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:W,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/nicolasjesenberger/full/xxmbvxL",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/nicolasjesenberger/full/xxmbvxL"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://tympanus.net/Development/CreativeGooeyEffects/index.html",target:"_blank",rel:"noopener noreferrer",children:"https://tympanus.net/Development/CreativeGooeyEffects/index.html"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"内容切换动画",children:["内容切换动画",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内容切换动画",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在内容切换动画中，黏糊效果可以使内容之间的过渡更加自然和流畅。当用户切换内容或页面时，内容区域的边缘会产生柔和的流动效果，增强视觉连贯性。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:q,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/ainalem/full/NWxYBRq",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/ainalem/full/NWxYBRq"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:M,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/team/keyframers/full/YbGbOd",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/team/keyframers/full/YbGbOd"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/cobra_winfrey/details/dKMpzO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/cobra_winfrey/details/dKMpzO"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/PointC/full/oqeJbo",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/PointC/full/oqeJbo"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:Y,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/chrisgannon/full/GZNgLw",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/chrisgannon/full/GZNgLw"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"背景装饰",children:["背景装饰",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#背景装饰",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"背景装饰中使用黏糊效果可以增强页面的视觉吸引力，使背景看起来更加动态和有趣。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/victor-cervantes/full/WNzoQXM",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/victor-cervantes/full/WNzoQXM"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:L,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://tympanus.net/Development/CreativeGooeyEffects/player.html",target:"_blank",rel:"noopener noreferrer",children:"https://tympanus.net/Development/CreativeGooeyEffects/player.html"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这里所列举的只是黏糊效果在 Web 常见场景，事实上还有很多黏糊效果的应用，这里就不一一列举了！"}),"\n",(0,s.jsx)(n.p,{children:"通过以上这些应用场景，我们可以看到黏糊效果在提升 Web 互动性和视觉吸引力方面具有广泛的应用前景。掌握这些应用场景和实现技术，可以让 Web 开发者在自己的项目中创造出更加引人注目的效果，提升用户体验。"}),"\n",(0,s.jsxs)(n.h2,{id:"制作黏糊效果的核心技术",children:["制作黏糊效果的核心技术",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#制作黏糊效果的核心技术",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"看到上面展示的黏糊效果，是不是有一种冲动，想在自己的项目中也加类似的效果，但内心又有一种恐惧，甚至是无从下手。如果是的话，接下来的内容将能帮你解惑！"}),"\n",(0,s.jsx)(n.p,{children:"时至今日，制作黏糊效果主要有两种主流技术，一种是纯 CSS 技术，另一种就是 CSS 与 SVG 滤镜结合的技术。我们从简单的 CSS 技术聊起。从易到难，使你更好的掌握该项技术。"}),"\n",(0,s.jsxs)(n.h3,{id:"纯-css-制作黏糊效果",children:["纯 CSS 制作黏糊效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#纯-css-制作黏糊效果",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这个技巧相当简单，使用 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7223230325122400288/section/7259669043622690853#heading-1",target:"_blank",rel:"noopener noreferrer",children:"CSS 的滤镜属性 filter"})," 同时对元素添加模糊（",(0,s.jsx)(n.code,{children:"blur()"}),"）和对比度（",(0,s.jsx)(n.code,{children:"contrast()"}),"）。",(0,s.jsx)(n.code,{children:"blur()"})," 会使元素变得模糊，而 ",(0,s.jsx)(n.code,{children:"contrast()"})," 则与 ",(0,s.jsx)(n.code,{children:"blur()"})," 对抗，更倾向于显著的颜色变化。如果对比度足够高，你会得到一个（相对）清晰的形状。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"奇妙之处在于，当两个模糊（但被迫看起来不模糊）的元素彼此靠近时，它们潜在的模糊会产生足够的颜色对比，使这些形状看起来实际上连接在一起的。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTML",children:'<div class="blobs">\n    <div class="blob"></div>\n    <div class="blob"></div>\n</div>\n<div class="blobs blobs--contrast">\n    <div class="blob"></div>\n    <div class="blob"></div>\n</div>\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:".blobs {\n    background-color: #fff; /* 为了 blob 的对比度，这个必须设置 */\n    display: flex;\n    align-items: center;\n    padding: 4rem; /* 尽量让 blob 不要与边缘相接触，不然会有很奇怪的事情发生 */\n    gap: 6px;\n\n    .blob {\n      width: 100px;\n      aspect-ratio: 1;\n      border-radius: 50%;\n      background: #000; /* 与 blobs 背景颜色有要鲜明的对比度，否则无效 */\n      filter: blur(15px);\n    }\n}\n\n.blobs--contrast {\n    filter: contrast(20);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我发现如果你先模糊形状（例如示例中 ",(0,s.jsx)(n.code,{children:".blob"})," 设置 ",(0,s.jsx)(n.code,{children:"blur(15px)"}),"），然后对整个区域添加对比度（例如示例中的 ",(0,s.jsx)(n.code,{children:".blobs"})," 设置 ",(0,s.jsx)(n.code,{children:"contrast(20)"}),"），会更容易实现这种效果。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/GRaQyJQ",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/GRaQyJQ"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"当你给这些元素添加动画，让它们四处移动时，效果会变得有趣起来。下面是一个可以调整数值的演示，包括亮度，它会影响模糊效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/zYQRRzR",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/zYQRRzR"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"正如你所看到的，使用 CSS 制作黏糊效果，有几个关键要素："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"元素颜色需要具有足够高的对比度"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["利用 CSS 的 ",(0,s.jsx)(n.code,{children:"filter"})," 的 ",(0,s.jsx)(n.code,{children:"blur()"})," 和 ",(0,s.jsx)(n.code,{children:"contrast()"})," 产生黏糊效果"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"使用 CSS 动画给元素添加动画效果，产生动画化的粘稠效果"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["上面展示的是 ",(0,s.jsx)(n.code,{children:"blur()"})," 和 ",(0,s.jsx)(n.code,{children:"contrast()"})," 分别应用于不同的元素上，其实它们同时应用于父容器上，效果会更会佳。例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTML",children:'<div class="blobs">\n    <div class="blob"></div>\n    <div class="blob"></div>\n</div>\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:"@layer demo {\n    .blobs {\n        --size: 25vmin;\n        display: grid;\n        width: calc(var(--size) * 5);\n        height: calc(var(--size) * 1.5);\n        place-content: center;\n        pointer-events: none;\n        background-color: #000; /* 这个很重要 */\n        padding: 1rem;\n        filter: blur(20px) contrast(30); /* 顺序很重要  */\n    \n        > * {\n            grid-area: 1 / 1 / -1 / -1;\n        }\n    \n        .blob {\n            translate: 0 0;\n            background: #fff; /* 这个很重要 */\n            width: var(--size);\n            aspect-ratio: 1;\n            border-radius: 50%;\n            \n            &:first-of-type {\n                animation: slide 4s infinite alternate ease-in-out;\n            }\n        }\n    }\n\n    @keyframes slide {\n        0% {\n            translate: -150% 0;\n        }\n        100% {\n            translate: 150% 0;\n        }\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["注意，在这个示例中，我们把 ",(0,s.jsx)(n.code,{children:"blur()"})," 和 ",(0,s.jsx)(n.code,{children:"contrast()"})," 都应用在 ",(0,s.jsx)(n.code,{children:".blobs"})," 上，最终呈现的效果也是我们所期望的。除了与之前示例一样，颜色要有较高的对比度之外，还要注意应用于 ",(0,s.jsx)(n.code,{children:".blobs"})," 的 ",(0,s.jsx)(n.code,{children:"filter"})," 滤镜的顺序，",(0,s.jsx)(n.code,{children:"blur()"})," 必须出现在 ",(0,s.jsx)(n.code,{children:"contrast()"})," 前面，否则将达不到你期望的黏糊效果："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:C,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/abrqYoX",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/abrqYoX"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如果你感兴趣，可以尝试着调整 ",(0,s.jsx)(n.code,{children:".blob"})," 元素的 ",(0,s.jsx)(n.code,{children:"background"})," 值，甚至加上混合模式（",(0,s.jsx)(n.code,{children:"mix-blend-mode"}),"），可能会给你带来意外的惊喜："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["我想，你现在应该知道如何使用 CSS 的 ",(0,s.jsx)(n.code,{children:"filter"})," 来实现黏糊效果。我们来看一个简单的案例，这个案例可以用于翻页的进度指示器上："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTML",children:'<ul class="pagination">\n    <li class="dot select">1</li>\n    <li class="dot">2</li>      \n</ul>\n'})}),"\n",(0,s.jsx)(n.p,{children:"关键的 CSS："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:"@layer demo {\n    .pagination {\n        list-style-type: none;\n        background: black;\n        filter: blur(5px) contrast(10);\n        padding: 20px;\n        position: relative;\n        display: flex;\n        align-items: center;\n        gap: 1.5rem;\n    }\n    .dot {\n        border-radius: 100%;\n        width: 30px;\n        aspect-ratio: 1;\n        background: white;\n        cursor: pointer;\n        color: white;\n        position: relative;\n        z-index: 2;\n    }\n    .select {\n        width: 40px;\n        position: absolute;\n        z-index: 3;\n        top: 15px;\n        left: 0px;\n        pointer-events: none;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:G,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/WNBMMaR",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/WNBMMaR"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["注意，示例的交互效果是通过 ",(0,s.jsx)(n.a,{href:"https://gsap.com/",target:"_blank",rel:"noopener noreferrer",children:"GSAP"})," 来实现的，具体的代码就不在这里展示了，感兴趣的可以阅读案例源码。"]}),"\n",(0,s.jsxs)(n.p,{children:["上面所呈现的都是一些简单的用例，但这并不意味着你不能使用这种技术来创建复杂的效果。例如，下面这个由 ",(0,s.jsx)(n.a,{href:"https://codepen.io/Chokcoco/full/vYExwvm",target:"_blank",rel:"noopener noreferrer",children:"@Chokcoco 提供的案例"}),"，使用相似的技术，模拟了“华为手机允电”的动画效果："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/Chokcoco/full/vYExwvm",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/Chokcoco/full/vYExwvm"})," （来源于 @Chokcoco ）"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"正如你所看到的，CSS 制作黏糊效果，虽然可以带来一些非常酷炫的视觉效果，但也存在一些局限性："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"容器需要一个背景色，因此没有透明度"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"难以使黑白以外的颜色"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"将内容模糊在一起，使其不可见"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"总的来说，这使得黏糊效果大打折扣，甚至不怎么实用。但是，使用 SVG 滤镜，我们可以做到一些纯 CSS 滤镜无法做到的事情。这意味着，使用 SVG 滤镜制作的黏糊效果，实用性更强。接下来，我们进入 SVG 滤镜的世界，看看 SVG 滤镜又是如何实现黏糊效果的。"}),"\n",(0,s.jsxs)(n.h3,{id:"使用-svg-滤镜制作黏糊效果",children:["使用 SVG 滤镜制作黏糊效果",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-svg-滤镜制作黏糊效果",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"之前提到过，使用 SVG 滤镜可以做到一些 CSS 滤镜无法做到的事情。例如："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"只增强透明度对比度"}),"：我们可以只增加透明度（Alpha 通道）的对比度，而不改变颜色。这样，我们可以让元素的边缘更清晰，而保持其颜色不变"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"显示原始内容"}),"：通过使用 ",(0,s.jsx)(n.code,{children:"SourceGraphic"})," 关键字，我们可以使滤镜处理后的内容显示出来。这意味着我们可以同时看到处理前和处理后的效果"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"透明背景的需求"}),"：由于我们处理的是透明度通道，背景必须是透明的，否则效果不会如预期显示。所以使用时要确保背景是透明的"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"具体来说，使用 SVG 滤镜制作黏糊效果的核心技术主要依赖以下几个滤镜："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<feGaussianBlur>"})," 滤镜基元，使元素变得模糊，这是黏糊效果的基础"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<feColorMatrix>"})," 滤镜基元，调整图像颜色和透明度，通过增加对比度来强化模糊效果，从而产生黏糊效果"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"<feComposite>"})," 滤镜基元，将处理后的图像与原始图像进行复合，确保最终显示的是原始颜色与透明度效果叠加的结果"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["注意，",(0,s.jsx)(n.code,{children:"<feComposite>"})," 滤镜基元也可以替换成 ",(0,s.jsx)(n.code,{children:"<feBlend>"})," 或 ",(0,s.jsx)(n.code,{children:"<feMerge>"})," 滤镜基元，但这两者的使用方式和效果有所不同。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="goo1" color-interpolation-filters="linearRGB" x="-10%" y="-10%" width="120%" height="120%">\n            <feGaussianBlur  result="GOOEY__BLUR__10" in="SourceGraphic" stdDeviation="10" />\n            <feColorMatrix values="\n                1 0 0 0 0                                      \n                0 1 0 0 0\n                0 0 1 0 0\n                0 0 0 18 -7" type="matrix" result="GOOEY__COLOR__10" in="GOOEY__BLUR__10"  />\n            <feComposite result="GOOEY__COLOR__10" in="GOOEY__BLUR__10" operator="atop" />\n        </filter>\n        \n        <filter id="goo2" color-interpolation-filters="linearRGB" x="-10%" y="-10%" width="120%" height="120%">\n            <feGaussianBlur  result="GOOEY__BLUR__20" in="SourceGraphic" stdDeviation="10" />\n            <feColorMatrix  values="\n                1 0 0 0 0                                      \n                0 1 0 0 0\n                0 0 1 0 0\n                0 0 0 18 -7" type="matrix" result="GOOEY__COLOR__20" in="GOOEY__BLUR__20"/>\n            <feBlend in="SourceGraphic" in2="GOOEY__COLOR__20" />\n        </filter>\n        \n        <filter id="goo3" color-interpolation-filters="linearRGB" x="-10%" y="-10%" width="120%" height="120%">\n            <feGaussianBlur  result="GOOEY__BLUR__30" in="SourceGraphic" stdDeviation="10" />\n            <feColorMatrix  values="\n                1 0 0 0 0                                      \n                0 1 0 0 0\n                0 0 1 0 0\n                0 0 0 18 -7" type="matrix" result="GOOEY__COLOR__30" in="GOOEY__BLUR__30"/>\n            <feMerge>\n                <feMergeNode in="GOOEY__COLOR__30" />\n                <feMergeNode in="SourceGraphic" />\n            </feMerge>\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:O,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/jOoZxLj",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/jOoZxLj"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们以 ",(0,s.jsx)(n.code,{children:"#goo1"})," 为例："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<filter id="goo1" color-interpolation-filters="linearRGB" x="-10%" y="-10%" width="120%" height="120%">\n    <feGaussianBlur  result="GOOEY__BLUR__10" in="SourceGraphic" stdDeviation="10" />\n    <feColorMatrix values="\n        1 0 0 0 0                                      \n        0 1 0 0 0\n        0 0 1 0 0\n        0 0 0 18 -7" type="matrix" result="GOOEY__COLOR__10" in="GOOEY__BLUR__10"  />\n    <feComposite result="GOOEY__COLOR__10" in="GOOEY__BLUR__10" operator="atop" />\n</filter>\n'})}),"\n",(0,s.jsx)(n.p,{children:"代码很简短，让我们拆解一下："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["首先，使用 ",(0,s.jsx)(n.code,{children:"<feGaussianBlur>"})," 滤镜对 ",(0,s.jsx)(n.code,{children:"SourceGraphic"})," 应用了一个 ",(0,s.jsx)(n.code,{children:"10px"})," 的模糊，并将该结果命名为 ",(0,s.jsx)(n.code,{children:"GOOEY__BLUR__10"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["然后，使用 ",(0,s.jsx)(n.code,{children:"<feColorMatrix>"})," 滤镜调整前一个结果（",(0,s.jsx)(n.code,{children:"GOOEY__BLUR__10"}),"）的颜色和透明度，以增加 Alpha 通道的对比度。也给结果命名，比如 ",(0,s.jsx)(n.code,{children:"GOOEY__COLOR__10"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["最后，使用 ",(0,s.jsx)(n.code,{children:"<feComposite>"})," 滤镜将前两个滤镜的结果（",(0,s.jsx)(n.code,{children:"GOOEY__BLUR__10"})," 和 ",(0,s.jsx)(n.code,{children:"GOOEY__COLOR__10"}),"）进行合成操作。在这里，我们可以使用带有 ",(0,s.jsx)(n.code,{children:"atop"})," 操作符的 ",(0,s.jsx)(n.code,{children:"<feComposite>"})," 滤镜来遮罩粘液外的任何内容"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["就这三个滤镜基础元而言，其中 ",(0,s.jsx)(n.code,{children:"<feGaussianBlur>"})," 和 ",(0,s.jsx)(n.code,{children:"<feComposite>"})," （以及 ",(0,s.jsx)(n.code,{children:"<feBlend>"})," 和 ",(0,s.jsx)(n.code,{children:"<feMerge>"}),"）相对比较简单，最为复杂的是 ",(0,s.jsx)(n.code,{children:"<feColorMatrix>"})," 滤镜基础。之前我们专门有一节课《",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7341630791099383835/section/7368318058076569638",target:"_blank",rel:"noopener noreferrer",children:"SVG 滤镜的进阶之高阶颜色矩阵"}),"》详细阐述了 ",(0,s.jsx)(n.code,{children:"<feColorMatrix>"})," 滤镜。"]}),"\n",(0,s.jsxs)(n.p,{children:["简单的回顾一下 ",(0,s.jsx)(n.code,{children:"<feColorMatrix>"})," 滤镜，它其实就是一个“四行五列”（",(0,s.jsx)(n.code,{children:"4 x 5"}),"）的颜色矩阵，如下图所示："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这是一个标准颜色矩阵。你可以将其理解为：基于 RGBA 输入，输出的 RGBA 应该是什么？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["每个 RGBA 列中的数字作为乘数。上面的矩阵对图像没有任何影响。这是因为红色输入进来时，我们将其乘以",(0,s.jsx)(n.code,{children:"1"})," 得到红色输出。因此，图像中的红色数量不会改变。对于绿色输入值，绿色行中的乘数 ",(0,s.jsx)(n.code,{children:"1"})," 使其输出相同的值，蓝色和Alpha 通道同理。最后一列被添加到输出中，可以使输出的值增加或减少，这意味着那里有一个数字会将其值乘以 ",(0,s.jsx)(n.code,{children:"255"})," 后加到其通道。"]}),"\n",(0,s.jsxs)(n.p,{children:["回到上面示例中的 ",(0,s.jsx)(n.code,{children:"<feColorMatrix>"})," 滤镜："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<feColorMatrix \n    values="\n        1 0 0 0 0                                      \n        0 1 0 0 0\n        0 0 1 0 0\n        0 0 0 18 -7" \n    type="matrix" \n    result="GOOEY__COLOR__10" \n    in="GOOEY__BLUR__10"  />\n'})}),"\n",(0,s.jsxs)(n.p,{children:["该矩阵使用了 ",(0,s.jsx)(n.code,{children:"<feGaussianBlur>"})," 滤镜的输出结果（",(0,s.jsx)(n.code,{children:"GOOEY__BLUR__10"}),"）来进行修改。除了Alpha通道外，其他所有内容都保持不变。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["这使得 RGB 通道保持不变，将 Alpha 通道的值乘以 ",(0,s.jsx)(n.code,{children:"18"}),"，然后从该值中减去 ",(0,s.jsx)(n.code,{children:"7 x 255"}),"，有效地仅增加透明度的对比度。这里的 ",(0,s.jsx)(n.code,{children:"18"})," 和 ",(0,s.jsx)(n.code,{children:"-7"})," 是通过经验得出的数值，用于增强对比度，这些值可以根据需要进行调整。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/NWVyBJz",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/NWVyBJz"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"案例",children:["案例",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#案例",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我想，你现在已经知道如何使用 CSS 和 SVG 技术来创建黏糊效果了。接下来，我们来看一些实际的案例，希望通过些案例能帮助大家更好的将黏糊效果应用到自己的项目中。"}),"\n",(0,s.jsx)(n.p,{children:"注意，在接下来的示例中，如果无特殊声明，都将采用下面这个黏糊滤镜效果："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="goo" color-interpolation-filters="linearRGB" x="-10%" y="-10%" width="120%" height="120%">\n            <feGaussianBlur  result="GOOEY__BLUR__10" in="SourceGraphic" stdDeviation="10" />\n            <feColorMatrix values="\n                1 0 0 0 0                                      \n                0 1 0 0 0\n                0 0 1 0 0\n                0 0 0 18 -7" type="matrix" result="GOOEY__COLOR__10" in="GOOEY__BLUR__10"  />\n          <feComposite in="SourceGraphic" in2="GOOEY__COLOR__10" operator="atop"/>\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"导航菜单-1",children:["导航菜单",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#导航菜单-1",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们先从 Web 上最常见的导航菜单开始。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/JjqpaMN",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/JjqpaMN"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这个示例中菜单项对应的 HTML 结构如下所示："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTML",children:'<div class="blobs">\n    <div class="blob blob--button" style="--index: 0;">\n        <svg class="icon--plus">\n            <use href="#plus" />\n        </svg>\n    </div>\n    <div class="blob" style="--index: 1;">\n        <svg class="icon--paper-plane">\n            <use href="#paper-plane" />\n        </svg>\n    </div>\n    <div class="blob" style="--index: 2;">\n        <svg class="icon--save">\n            <use href="#save" />\n        </svg>\n    </div>\n    <div class="blob" style="--index: 3;">\n        <svg class="icon--image">\n            <use href="#image" />\n        </svg>\n    </div>\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:"使用 CSS 对导航项进行美化和布局："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:'.blobs {\n    filter: url("#goo");\n    position: absolute;\n    bottom: 20px;\n    right: 20px;\n    width: 60px;\n}\n\n.blob {\n    --nums: 4; /* blobs*/\n    --z-index: calc(var(--nums) - var(--index));\n    --translateY: 80px;\n    width: 60px;\n    aspect-ratio: 1;\n    background: #f50057;\n    border-radius: 50px;\n    color: #fff;\n    display: grid;\n    place-content: center;\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    cursor: pointer;\n    z-index: var(--z-index);\n\n    &:nth-child(2) {\n        transition: all ease 0.3s;\n    }\n\n    &:nth-child(3) {\n        transition: all ease 0.35s;\n    }\n\n    &:nth-child(4) {\n        transition: all ease 0.4s;\n    }\n\n    svg {\n        display: block;\n        width: 45%;\n        aspect-ratio: 1;\n        color: #fff;\n        fill: currentColor;\n        place-self: center;\n        transition: all 0.2s linear;\n    }\n}\n\n.blobs.open {\n    .icon--plus {\n        rotate: 45deg;\n    }\n\n    .blob {\n        translate: 0 calc(-1 * var(--index) * var(--translateY));\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["整个导航定位在窗口的右下角，菜单展开时，每个选项通过 ",(0,s.jsx)(n.code,{children:"translate"})," 沿着 ",(0,s.jsx)(n.code,{children:"Y"})," 轴向上移，这个位置根据需要来定义。我在示例中，通过 CSS 的自定义属性 ",(0,s.jsx)(n.code,{children:"--index"})," 和 ",(0,s.jsx)(n.code,{children:"--translateY"})," 来计算每个菜单选项在 ",(0,s.jsx)(n.code,{children:"Y"})," 轴的偏移量。这样做的好处是，你随时增加菜单项都不会影响布局，它会自动完成。"]}),"\n",(0,s.jsxs)(n.p,{children:["另外，每个菜单选项的 ",(0,s.jsx)(n.code,{children:"z"})," 轴层级也是通过 ",(0,s.jsx)(n.code,{children:"--index"})," 自动计算，在 HTML 中越早出现的菜单选项，其 ",(0,s.jsx)(n.code,{children:"z"})," 轴的层级越高。"]}),"\n",(0,s.jsxs)(n.p,{children:["最为关键的是，我们需要在 ",(0,s.jsx)(n.code,{children:".blobs"})," 上设置 ",(0,s.jsx)(n.code,{children:"filter"})," 属性的值为 ",(0,s.jsx)(n.code,{children:"url(#goo)"})," ，这样才能使导航菜单具有黏糊效果。你需要将前面定义黏糊效果的 SVG 代码内联到你的 HTML 中。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:'.blobs {\n    filter: url("#goo");\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"就这样！一个具有黏糊效果的导航菜单就完成了。"}),"\n",(0,s.jsx)(n.p,{children:"其实，在这个导航菜单的基础上，你只需要改变图标的内容和调整导航菜单项的布局，你将演变出很多种具有黏糊效果的导航菜单。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/VwOQEEO",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/VwOQEEO"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["注意，这是一个圆形导航菜单，每个菜单项在圆周上的位置是通过 CSS 的三角函数计算出来的，如果你从未接触过这方面的知识，请移步阅读《",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7223230325122400288/section/7242216512176521277",target:"_blank",rel:"noopener noreferrer",children:"CSS 的三角函数"}),"》！"]}),"\n",(0,s.jsx)(n.p,{children:"在上面的示例基础上，稍微调整圆的半径，你将得到一个新的导航菜单效果："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/QWRQJGa",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/QWRQJGa"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["我们再来看一个",(0,s.jsx)(n.a,{href:"https://codepen.io/simeydotme/full/LYLxJqV",target:"_blank",rel:"noopener noreferrer",children:"由 @Simon Goellner 提供的导航菜单案例"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/simeydotme/full/LYLxJqV",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/simeydotme/full/LYLxJqV"})," （来源于 @Simon Goellner ）"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这个案例与之前的几个导航菜单在实现上略有不同。最大的不同之处，应用之前定义的 ",(0,s.jsx)(n.code,{children:"#goo"})," 滤镜效果（黏糊效果）会使所有 SVG 图标在视觉上丢失。因此， @Simon Goellner 在 HTML 的结构上做了一些调整，并且重新定义了 ",(0,s.jsx)(n.code,{children:"#goo"})," 滤镜效果："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTML",children:'<nav>\n    \x3c!-- 黏糊导航菜单背景 --\x3e\n    <aside class="goo">\n        <ul>\n            <li></li>\n            \x3c!-- 省略其他几个，需要与 menu 的列表项数量相等 --\x3e\n        </ul>\n    </aside>\n    \x3c!-- 实际导航菜单，不应用黏糊滤镜  --\x3e\n    <ul class="menu">\n        <li>\n            <a href="#"><svg viewBox="0 0 24 24"><use href="#home" /></svg></a>\n        </li>\n        \x3c!-- 省略其他导航菜单项 --\x3e\n    </ul>\n</nav>\n\n<svg viewBox="0 0 24 24">\n    \x3c!-- 黏糊滤镜效果 --\x3e\n    <filter id="schlurp">\n        <feGaussianBlur id="SourceGraphic" stdDeviation="10" />\n        <feColorMatrix values="\n           1 0 0 0   0\n           0 1 0 0   0\n           0 0 1 0   0 \n           0 0 0 20  -10\n        " />\n    </filter>\n</svg>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["你可能已经发现了，这个示例只使用了 ",(0,s.jsx)(n.code,{children:"<feGaussianBlur>"})," 和 ",(0,s.jsx)(n.code,{children:"<feColorMatrix>"})," 滤镜定义黏糊效果。然后在 ",(0,s.jsx)(n.code,{children:".goo"})," 和 ",(0,s.jsx)(n.code,{children:".goo ul"})," 上引用黏糊滤镜："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:'.goo,\n.goo ul {\n    background: inherit;\n    filter: url("#schlurp"); \n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["其他相关的样式，这里就不展示了，感兴趣的同学可以阅读案例源码。有的同学可能会对导航菜单的弹跳动画感兴趣，这个动画是一个 CSS 过渡动画，在鼠标悬浮状态改变了导航菜单项的 ",(0,s.jsx)(n.code,{children:"translateY"})," 的值。最为关键的是，缓动函数应用的是 ",(0,s.jsx)(n.code,{children:"linear()"})," 函数，模拟的是一个弹簧效果。如果你想更深入的了解这方面的知识，请移步阅读《",(0,s.jsx)(n.a,{href:"https://s.juejin.cn/ds/ijos2qQa/",target:"_blank",rel:"noopener noreferrer",children:"Web 动画之旅"}),"》中的 《",(0,s.jsxs)(n.a,{href:"https://juejin.cn/book/7288940354408022074/section/7301665456824254515",target:"_blank",rel:"noopener noreferrer",children:["使用 ",(0,s.jsx)(n.code,{children:"linear()"})," 函数创建令人惊叹的动画曲线"]}),"》！"]}),"\n",(0,s.jsx)(n.p,{children:"我在研究这个案例效果的时候，也非常好奇！我尝试着使用我所掌握的知识，对该导航菜单的效果做了一些尝试性的调整，虽然在视觉效果上与原案例略有差异，但在结构上比之前的要简洁一些："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTML",children:'<nav>\n    <ul class="menu">\n        <li>\n            <a href="#"><svg class="icon icon--home"><use href="#home" /></svg></a>\n        </li>\n        \x3c!-- 省略其他的导航菜单项 --\x3e\n    </ul>\n</nav>\n'})}),"\n",(0,s.jsx)(n.p,{children:"与此同时，我使用下面的 SVG 来创建黏糊滤镜效果："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="goo" color-interpolation-filters="linearRGB" x="0%" y="0%" width="100%" height="100%">\n            <feGaussianBlur  result="GOOEY__BLUR__10" in="SourceGraphic" stdDeviation="10" />\n            <feColorMatrix values="\n                1 0 0 0 0                                      \n                0 1 0 0 0\n                0 0 1 0 0\n                0 0 0 18 -7" type="matrix" result="GOOEY__COLOR__10" in="GOOEY__BLUR__10"  />\n            \x3c!-- <feComposite in="SourceGraphic" in2="GOOEY__COLOR__10" operator="atop"/> --\x3e\n            <feBlend in="SourceGraphic" in2="GOOEY__COLOR__10" />\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["请注意，我使用 ",(0,s.jsx)(n.code,{children:"<feBlend>"})," 滤镜替代了之前的 ",(0,s.jsx)(n.code,{children:"<feComposite>"})," 滤镜。然后在 ",(0,s.jsx)(n.code,{children:"nav"})," 和 ",(0,s.jsx)(n.code,{children:".menu"})," 上应用已定义的 ",(0,s.jsx)(n.code,{children:"#goo"})," 滤镜："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:"nav, menu {\n    filter: url(#goo);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["与之前案例还有一个不同之处是，在 ",(0,s.jsx)(n.code,{children:"li"})," 元素上添加一个伪元素，并且设置与导航菜单相同的背景颜色，这是为了使导航项弹出时，它与导航背景黏糊在一起："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:'.menu {\n    position: absolute;\n    z-index: 1;\n    text-align: center;\n\n    li {\n        background: transparent;\n        display: flex;\n        align-items: flex-start;\n        justify-content: center;\n        transition: all 0.85s ease;\n        height: calc(var(--size) * 2);\n\n        &::before {\n            content: "";\n            width: 100%;\n            height: 50%;\n            position: absolute;\n            left: 0;\n            bottom: 10px;\n            border-radius: 100%;\n            background: inherit;\n            transition: all 0.85s ease;\n            translate: 0 0 0;\n            will-change: transform;\n            backface-visibility: hidden;\n            z-index: -1;\n        }\n\n        &:hover {\n            transition: all calc(var(--duration) - 0.2s) var(--spring-easing);\n            translate: 0 var(--distance) 0;\n            color: white;\n    \n            &::before {\n                transition: all var(--duration) var(--spring-easing);\n                translate: 0 var(--distance) 0;\n                background: var(--default);\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/MWdQzXZ",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/MWdQzXZ"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["你可能已经发现了，鼠标悬停在导航菜单项上时，其背景颜色（",(0,s.jsx)(n.code,{children:"li::before"}),"）与导航菜单的背景颜色融合的不是很完美，这是 ",(0,s.jsx)(n.code,{children:"<feBlend>"})," 滤镜所产生的效果。另外，这个效果有一个明显的不足之处，不能像原案例那样为悬停菜单项设置不同的颜色。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsxs)(n.h3,{id:"表单控件",children:["表单控件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#表单控件",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"现在，在制作表单控件时，你只需要在原有的基础上添加一段具有黏糊效果的 SVG 代码，然后在需要应用黏糊效果的表单控件中引用该滤镜，就使你的表单控件在交互上立即与众不同。例如下面这几个示例。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/LYoQKeE",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/LYoQKeE"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这是一个很常见的 ",(0,s.jsx)(n.code,{children:"Switch"})," 切换按钮（类似单选按钮）。现如今，我们仅使用 CSS 就能实现具有交互效果的 ",(0,s.jsx)(n.code,{children:"Switch"})," ："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-HTML",children:'<div class="form">\n    <input type="checkbox" class="sr-only" id="goo" name="goo" />\n    <span>OFF</span>\n    <label for="goo" class="goo"></label>\n    <span>ON</span>\n</div>\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:'@layer demo {\n    .form {\n        display: flex;\n        align-items: center;\n        font-size: 1.5rem;\n        font-weight: 900;\n    \n        span:nth-of-type(1) {\n            translate: -70px 0;\n            transition: all 0.2s;\n        }\n        span:nth-of-type(2) {\n            translate: 35px 0;\n            transition: all 0.2s;\n        }\n    }\n    \n    .goo {\n        display: flex;\n        cursor: pointer;\n        position: relative;\n        scale: 2;\n    \n        &::before,\n        &::after {\n            content: "";\n            display: block;\n            background: #fff;\n            transition: 300ms all ease;\n        }\n    \n        &::before {\n            width: 60px;\n            height: 6px;\n        }\n    \n        &::after {\n            width: 30px;\n            aspect-ratio: 1;\n            border-radius: 50%;\n            position: absolute;\n            left: 0;\n            top: 50%;\n            translate: -15px -50% 0;\n        }\n    }\n\n    @keyframes switchOn {\n        0% {\n            scale: 1 1 1;\n            translate: -15px -50% 0;\n            transform-origin: left center;\n        }\n        40% {\n            scale: 1.4 0.7 0;\n            translate: 25px -50% 0;\n            transform-origin: right center;\n        }\n        70% {\n            scale: 0.9 1.15 1;\n            translate: 35px -50% 0;\n        }\n        100% {\n            scale: 1 1 1;\n            translate: 45px -50% 0;\n        }\n    }\n  \n    @keyframes switchOff {\n        0% {\n            scale: 1 1 1;\n            translate: 45px -50% 0;\n            transform-origin: right center;\n        }\n        40% {\n            scale: 1.4 0.7 0;\n            translate: 35px -50% 0;\n            transform-origin: right center;\n        }\n        70% {\n            scale: 0.9 1.15 1;\n            translate: 0 -50% 0;\n        }\n        100% {\n            scale: 1 1 1;\n            translate: -15px -50% 0;\n        }\n    }\n\n    #goo {\n        &:checked {\n            ~ .goo {\n                &::before {\n                    background: oklch(0.76 0.18 80.24);\n                }\n                &::after {\n                    background: oklch(0.76 0.18 80.24);\n                    animation: switchOn 250ms linear forwards;\n                }\n            }\n    \n            ~ span {\n                &:nth-of-type(1) {\n                    translate: -35px 0;\n                }\n                &:nth-of-type(2) {\n                    translate: 70px 0;\n                    color: oklch(0.76 0.18 80.24);\n                }\n            }\n        }\n        \n        &:not(:checked) {\n            ~ .goo::after {\n                animation: switchOff 250ms linear forwards;\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"通常未使用滤镜时的效果如下所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["现在，你只需要在上面的代码的基础上，在 ",(0,s.jsx)(n.code,{children:".goo"})," 元素上应用 SVG 定义的黏糊滤镜："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:'.goo {\n    filter: url("#gooey");\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"效果立马就与众不同："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"现在整个效果看上去像是在吹气球，是不是更具趣味性了！你可以使用类似的方式将黏糊效果应用于单选按钮、复选框和输入框和按钮等表单控件上。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/airen/full/WNBMVNg",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/airen/full/WNBMVNg"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/Markshall/full/PoZJRve",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/Markshall/full/PoZJRve"})," （来源于 @Markshall ）"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Demo 地址：",(0,s.jsx)(n.a,{href:"https://codepen.io/n3r4zzurr0/full/NWyBRpQ",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/n3r4zzurr0/full/NWyBRpQ"})," （来源于 @Utkarsh Verma ）"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"有关于黏糊效果的制作我们就聊到这里了。你可能已经发现了，使用 SVG 滤镜制作黏糊效果并没有我们当初想象的那么复杂。简单地说，我们就使用了三个滤镜基元创建了黏糊效果："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-XML",children:'<svg class="sr-only">\n    <defs>\n        <filter id="goo" color-interpolation-filters="linearRGB" x="-10%" y="-10%" width="120%" height="120%">\n            <feGaussianBlur  result="GOOEY__BLUR__10" in="SourceGraphic" stdDeviation="10" />\n            <feColorMatrix values="\n                1 0 0 0 0                                      \n                0 1 0 0 0\n                0 0 1 0 0\n                0 0 0 18 -7" type="matrix" result="GOOEY__COLOR__10" in="GOOEY__BLUR__10"  />\n          <feComposite in="SourceGraphic" in2="GOOEY__COLOR__10" operator="atop"/>\n        </filter>\n    </defs>\n</svg>\n'})}),"\n",(0,s.jsx)(n.p,{children:"只要你愿意，上面这个黏糊效果可以应用于任何 Web 元素上。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-CSS",children:".goo {\n    filter: url(#goo);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"另外，结合 CSS 和一些动画技术，你将制作出更具吸引人的黏糊效果。有关于这方面更多的案例就不在这里阐述了，我非常期待着你能分享出你制作的一些案例！"})]})}function F(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(P,{...e})}):P(e)}let K=F;F.__RSPRESS_PAGE_META={},F.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20SVG%2F43-%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%9ASVG%20%E6%BB%A4%E9%95%9C%E7%9A%84%E8%BF%9B%E9%98%B6%E4%B9%8B%E9%BB%8F%E7%B3%8A%E6%95%88%E6%9E%9C.md"]={toc:[{text:"黏糊效果简介",id:"黏糊效果简介",depth:2},{text:"黏糊效果在 Web 上的应用",id:"黏糊效果在-web-上的应用",depth:2},{text:"按钮",id:"按钮",depth:3},{text:"加载动画",id:"加载动画",depth:3},{text:"导航菜单",id:"导航菜单",depth:3},{text:"图像悬停效果",id:"图像悬停效果",depth:3},{text:"表单元素",id:"表单元素",depth:3},{text:"内容切换动画",id:"内容切换动画",depth:3},{text:"背景装饰",id:"背景装饰",depth:3},{text:"制作黏糊效果的核心技术",id:"制作黏糊效果的核心技术",depth:2},{text:"纯 CSS 制作黏糊效果",id:"纯-css-制作黏糊效果",depth:3},{text:"使用 SVG 滤镜制作黏糊效果",id:"使用-svg-滤镜制作黏糊效果",depth:3},{text:"案例",id:"案例",depth:2},{text:"导航菜单",id:"导航菜单-1",depth:3},{text:"表单控件",id:"表单控件",depth:3},{text:"小结",id:"小结",depth:2}],title:"43-高级篇：SVG 滤镜的进阶之黏糊效果",headingTitle:"43-高级篇：SVG 滤镜的进阶之黏糊效果",frontmatter:{}}}}]);