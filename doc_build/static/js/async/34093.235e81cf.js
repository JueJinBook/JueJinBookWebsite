"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["34093"],{894181:function(n,e,r){r.r(e),r.d(e,{default:()=>d});var a=r(552676),t=r(740453);let i=r.p+"static/image/327abb41f5f3dc97202c7772afdfe3d1.d5c43292.webp",c=r.p+"static/image/3f4ee36763dd2a09321ecf26e08fb7f8.46cc96a5.webp";function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ul:"ul",li:"li",h3:"h3",img:"img",pre:"pre",h4:"h4",h5:"h5",br:"br"},(0,t.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"16中级进阶------通用数学库的-javascript-实现",children:["16.中级进阶 ---  通用数学库的 JavaScript 实现。",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#16中级进阶------通用数学库的-javascript-实现",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"上一节我们介绍了图形学涉及到的数学知识，并介绍了了它们的各种运算规则，掌握这些规则对我们开发 3D 应用有着至关重要的作用。本节我们看一下如何将这些运算规则表示出来。"}),"\n",(0,a.jsxs)(e.p,{children:["业界已经有一些有名的数学库，比如基于 JavaScript 的",(0,a.jsx)(e.code,{children:"Threejs"}),"框架中就内置了 ",(0,a.jsx)(e.code,{children:"matrix"})," 和 ",(0,a.jsx)(e.code,{children:"vector"})," 的操作类，还有基于 C++ 语言进行实现的 ",(0,a.jsx)(e.code,{children:"GLM"}),"。"]}),"\n",(0,a.jsx)(e.p,{children:"由于我们是 WebGL 开发，所以我将带大家使用 JavaScript 实现这些数学算法。"}),"\n",(0,a.jsxs)(e.h2,{id:"需要实现哪些功能",children:["需要实现哪些功能？",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#需要实现哪些功能",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"那么，我们即将编写的数学库要能够实现哪些功能呢？"}),"\n",(0,a.jsxs)(e.p,{children:["上一节已经讲了，主要是",(0,a.jsx)(e.code,{children:"向量"}),"和",(0,a.jsx)(e.code,{children:"矩阵"}),"的表示、运算。"]}),"\n",(0,a.jsx)(e.p,{children:"在此罗列一下："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["向量","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"初始化向量"}),"\n",(0,a.jsx)(e.li,{children:"归一化向量"}),"\n",(0,a.jsx)(e.li,{children:"向量相加"}),"\n",(0,a.jsx)(e.li,{children:"向量相减"}),"\n",(0,a.jsx)(e.li,{children:"向量与标量相乘"}),"\n",(0,a.jsx)(e.li,{children:"向量与标量相除"}),"\n",(0,a.jsx)(e.li,{children:"向量与向量相乘"}),"\n",(0,a.jsx)(e.li,{children:"点积"}),"\n",(0,a.jsx)(e.li,{children:"叉积"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["矩阵","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"初始化矩阵"}),"\n",(0,a.jsx)(e.li,{children:"创建单位矩阵"}),"\n",(0,a.jsx)(e.li,{children:"矩阵与矩阵相乘"}),"\n",(0,a.jsx)(e.li,{children:"矩阵相加"}),"\n",(0,a.jsx)(e.li,{children:"矩阵相减"}),"\n",(0,a.jsx)(e.li,{children:"求转置矩阵"}),"\n",(0,a.jsx)(e.li,{children:"求逆矩阵"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.h2,{id:"矩阵在-glsl-中的存储特点",children:["矩阵在 GLSL 中的存储特点。",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#矩阵在-glsl-中的存储特点",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"在用 JavaScript 实现数学库之前，我们必须先想清楚如何使用开发出来的库。大家应该都知道，WebGL 应用中的数据一般是从 CPU 传入 GPU 的，语言层面从 JavaScript 传入 GLSL。假如我们要把在 JavaScript 中生成的矩阵传入到 GLSL 中，那么就得保证生成的矩阵能够被 GLSL 所理解，换句话说，JavaScript 矩阵和 GPU 中的矩阵要有相同的表示形式，避免不必要的转换过程。\n那么 GPU 中向量和矩阵是如何存储的呢？"}),"\n",(0,a.jsxs)(e.p,{children:["在前面章节的初级练习中，我们已经频繁接触了 GLSL 中的向量",(0,a.jsx)(e.code,{children:"vec"}),"和矩阵",(0,a.jsx)(e.code,{children:"mat"}),"，GLSL遵循的是线性代数的标准，也就是上一节我们所讲的内容，只是在存储方式上有所不同。"]}),"\n",(0,a.jsxs)(e.h3,{id:"行主序和列主序",children:["行主序和列主序",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#行主序和列主序",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"存储顺序说明了线性代数中的矩阵如何在线性的内存数组中存储，按照存储方式分为行主序和列主序。"}),"\n",(0,a.jsx)(e.p,{children:"行主序是按照行向量的方式组织矩阵。列主序是按照列向量的方式组织矩阵，为了便于理解，我们看下图示。"}),"\n",(0,a.jsx)(e.p,{children:"假设有一个 3 阶方阵 M："}),"\n",(0,a.jsx)(e.p,{children:"$\n\\begin{aligned}\nM = \\begin{pmatrix}\n1 & 2 & 3 \\\n4 & 5 & 6 \\\n7 & 8 & 9\n\\end{pmatrix}\n\\end{aligned}\n$"}),"\n",(0,a.jsx)(e.p,{children:"那么它在内存中的排布方式如下："}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:c,alt:""})}),"\n",(0,a.jsx)(e.p,{children:"观察上面的图，就能够一目了然地看出行主序和列主序的区别了。"}),"\n",(0,a.jsx)(e.p,{children:"请务必谨记，D3D 中矩阵采用的是行主序的存储方式，GLSL 中采用的是列主序。"}),"\n",(0,a.jsxs)(e.h2,{id:"实现javascript数学库",children:["实现JavaScript数学库",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现javascript数学库",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"那么，既然 GLSL 采用的是列主序存储，为了保持一致，我们在JavaScript中最好也采用列主序的方式存储，和 GLSL 保持一致。"}),"\n",(0,a.jsxs)(e.h3,{id:"javascript中-用什么数据结构来表示矩阵",children:["JavaScript中 用什么数据结构来表示矩阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript中-用什么数据结构来表示矩阵",children:"#"})]}),"\n",(0,a.jsxs)(e.p,{children:["我们用",(0,a.jsx)(e.code,{children:"数组"}),"来表示矩阵，但由于 JavaScript 数组是弱类型的，并没有严格按照内存位置进行排布，而 GLSL 中的矩阵元素是严格按照内存地址顺序排列的，所以我们需要将弱类型数组转化成二进制形式，通常我们使用 Float32Array 把弱类型数组转化成强类型数组。"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"let M = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nM = new Float32Array(M);\n"})}),"\n",(0,a.jsxs)(e.h3,{id:"实现数学库中的方法",children:["实现数学库中的方法",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实现数学库中的方法",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"图形学中多用方阵来表示变换，因为我们要在 3D 坐标系中变换，所以我们要用 4 阶方阵，所以关于矩阵的运算，我们主要以 4 阶矩阵为基础。"}),"\n",(0,a.jsxs)(e.h4,{id:"3维向量初始化",children:["3维向量初始化",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3维向量初始化",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"图形学编程中用的比较多的是 3 维、4 维向量，3 维向量多用来表示笛卡尔坐标系中的顶点坐标(X, Y, Z)，4维向量通常表示齐次坐标，如(X, Y, Z, W)，以及颜色信息(R, G, B, A)。\n我们需要初始化向量的方法，默认值为 0。"}),"\n",(0,a.jsx)(e.p,{children:"下面以 3 维向量为例进行实现， 4 维向量和 3维类似。"}),"\n",(0,a.jsxs)(e.h5,{id:"3-维向量初始化",children:["3 维向量初始化",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-维向量初始化",children:"#"})]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"输入参数 source 是 JavaScript 弱类型数组（Array），包含3个元素，比如[0, 0, 1]。"}),"\n",(0,a.jsx)(e.li,{children:"返回结果是强类型数组，包含 3 个元素[0, 0, 1]。"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function Vector3(x, y, z){\n   this.x = x || 0;\n   this.y = y || 0;\n   this.z = z || 0;\n}\n"})}),"\n",(0,a.jsxs)(e.h5,{id:"设置各个分量",children:["设置各个分量",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#设置各个分量",children:"#"})]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Vector3.prototype.setX = function(x) {\n    this.x = x || 0;\n    return this;\n}\nVector3.prototype.setY = function(y) {\n    this.y = y || 0;\n    return this;\n}\nVector3.prototype.setZ = function(z) {\n    this.z = z || 0;\n    return this;\n}\n\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"归一化向量",children:["归一化向量",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#归一化向量",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"归一化向量比较简单，首先求出向量的长度（模），然后将各个分量除以模即可。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Vector3.prototype.normalize = function() {\n    var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    if(length > 0.00001){\n        return new Vector3(this.x / length, this.y / length, this.z / length);\n    }\n    return new Vector3();\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"向量与向量相加",children:["向量与向量相加",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#向量与向量相加",children:"#"})]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Vector3.prototype.addVectors = function(vec1, vec2){\n    this.x = vec1.x + vec2.x;\n    this.y = vec1.y + vec2.y;\n    this.z = vec1.z + vec2.z;\n    return this;\n}\n"})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Vector3.prototype.add = function(vec1, vec2){\n    if(vec2){\n       return this.addVector(vec1, vec2);\n    }\n    this.x += vec1.x;\n    this.y += vec1.y;\n    this.z += vec1.z;\n    return this;\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"向量与向量相减",children:["向量与向量相减",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#向量与向量相减",children:"#"})]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Vector3.prototype.sub = function(vec1, vec2){\n    if(vec2){\n       return this.addVector(vec1, -vec2);\n    }\n    this.x -= vec1.x;\n    this.y -= vec1.y;\n    this.z -= vec1.z;\n    return this;\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"向量与标量相乘",children:["向量与标量相乘",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#向量与标量相乘",children:"#"})]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Vector3.prototype.multiplyScalar = function(scalar){\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"向量与向量相乘",children:["向量与向量相乘",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#向量与向量相乘",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"其实数学中是没有向量和向量相乘这一说法的，只是为了更方便的计算两个向量各个分量的乘积，所以增加这个计算，在GLSL 中 vec4 和 vec4 相乘返回的新向量就是将各个分量相乘，在计算光照时经常用到。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Vector3.prototype.multiplyVector = function(vec1, vec2){\n    this.x = vec1.x * vec2.x;\n    this.y = vec1.y * vec2.y;\n    this.z = vec1.z * vec2.z;\n    return this;\n}\nVector3.prototype.multiply = function(vec1, vec2){\n    if(vec2){\n        return this.multiplyVector(vec1, vec2);\n    }\n    this.x *= vec1.x;\n    this.y *= vec1.y;\n    this.z *= vec1.z;\n    return this;\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"点乘",children:["点乘",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#点乘",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"上一节讲过了，点乘就是将向量的各个分量相乘然后再相加，返回的结果是一个标量。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function dot(vec1, vec2){\n    return vec1.x * vec2.x + vec1.y *vec2.y + vec1.z * vec2.z;\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"叉乘",children:["叉乘",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#叉乘",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"叉乘的计算方法也比较简单，上一节我们讲了计算公式："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function cross(vec1, vec2){\n    var x = vec1.y * vec2.z - vec2.y * vec1.z;\n    var y = vec2.x * vec1.z - vec1.x * vec2.z;\n    var z = vec1.x * vec2.y - vec1.y * vec2.x;\n    return new Vector3(x, y, z);\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"初始化-4-阶单位矩阵",children:["初始化 4 阶单位矩阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化-4-阶单位矩阵",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"我们需要一个方法能够自动生成一个单位矩阵："}),"\n",(0,a.jsx)(e.p,{children:"$\n\\begin{pmatrix}\n1 &  0 &  0 & 0 \\\n0 & 1 & 0 & 0 \\\n0 & 0 & 1 & 0 \\\n0 & 0 & 0 & 1 \\\n\\end{pmatrix}\n$"}),"\n",(0,a.jsx)(e.p,{children:"4 阶矩阵包含 16 个元素，所以我们要初始化 16 个元素的类型化数组，处于性能考虑，我们需要支持对一个矩阵进行单位化。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function identity(target) {\n    target = target || new Float32Array(16);\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"默认各个元素值都是 0 ，我们要将该数组中各个元素的值与数学中的单位矩阵对应上，又由于矩阵以列主序存储，所以每四个数字代表一列："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function identity(target) {\n    target = target || new Float32Array(16);\n    // 第一列\n    target[0] = 1;\n    target[1] = 0;\n    target[2] = 0;\n    target[3] = 0;\n    // 第二列\n    target[4] = 0;\n    target[5] = 1;\n    target[6] = 0;\n    target[7] = 0;\n    // 第三列\n    target[8] = 0;\n    target[9] = 0;\n    target[10] = 1;\n    target[11] = 0;\n    // 第四列\n    target[12] = 0;\n    target[13] = 0;\n    target[14] = 0;\n    target[15] = 1;\n    \n    return target;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"初始化单位矩阵的方法就算完成了，我们还可以用另一种方式来生成，先用 JavaScrpt 数组存储矩阵各个元素，然后用 Float32Array 转化成强类型数组。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function identity(){\n    var m = \n        [\n            1, 0, 0, 0, // 第一列\n            0, 1, 0, 0, // 第二列\n            0, 0, 1, 0, // 第三列\n            0, 0, 0, 1  // 第四列\n        ]\n    return new Float32Array(m);\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"这两种方法用哪种方法都可以，我们使用第一种方法。"}),"\n",(0,a.jsxs)(e.h4,{id:"初始化-4-阶方阵",children:["初始化 4 阶方阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化-4-阶方阵",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"有时我们需要根据一个列主序的弱类型数组初始化成矩阵。"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["输入参数","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"source：源数组，包含16个元素。"}),"\n",(0,a.jsx)(e.li,{children:"target：目标数组，将目标数组初始化成source对应的元素。"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["返回结果","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"如果source 不为空，返回该数组对应的强类型数组矩阵。"}),"\n",(0,a.jsx)(e.li,{children:"如果 source 为空，返回单位矩阵"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function initialize(source, target) {\n    if(source){\n        if(target){\n            for(var i = 0;i < source.length; i++){\n                target[i] = source[i];\n            }\n            return target;\n        }\n        return new Float32Array(source);\n    }\n    return identity(target);\n}\n\n//使用方法\ninitialize([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"矩阵和矩阵相加减",children:["矩阵和矩阵相加减",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#矩阵和矩阵相加减",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"虽然矩阵和矩阵相加减的场景很少，但我们仍然要支持它们。实现比较简单，但有一个前提：相加减的两个矩阵的行列必须相同。"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["输入参数","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"m1，操作符左边矩阵。"}),"\n",(0,a.jsx)(e.li,{children:"m2，操作符右边矩阵。"}),"\n",(0,a.jsx)(e.li,{children:"target，将结果存入 target 数组。"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["返回结果","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"返回相加、减后的新矩阵。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"// m1 + m2\nfunction addMatrix(m1, m2, target){\n    target = target || new Float32Array(16);\n    for(var i = 0; i < m1.length; i++){\n        target[i] = m1[i] + m2[i]\n    }\n    return target;\n}\n\n// m1 - m2\nfunction subtractMatrix(m1, m2, target){\n    target = target || new Float32Array(16);\n    for(var i = 0; i < m1.length; i++){\n        target[i] = m1[i] - m2[i]\n    }\n    return target;\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"矩阵和矩阵相乘",children:["矩阵和矩阵相乘",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#矩阵和矩阵相乘",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"矩阵相乘是最经常用到的运算，我们看下如何用 JavaScript 实现。"}),"\n",(0,a.jsx)(e.p,{children:"假设有两个 4 阶方阵 M 和 N，其中："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"M = \n    [\n        a00, a01, a02, a03, //第一列\n        a10, a11, a12, a13, //第二列\n        a20, a21, a22, a23, //第三列\n        a30, a31, a32, a33, //第四列\n    ] \nN = \n    [\n        b00, b01, b02, b03, //第一列\n        b10, b11, b12, b13, //第二列\n        b20, b21, b22, b23, //第三列\n        b30, b31, b32, b33, //第四列\n    ]\n"})}),"\n",(0,a.jsx)(e.p,{children:"参考上一节的矩阵乘法， $N \\times M $的算法表示如下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"// 此处的 prev 代表 M，next 代表 N\nfunction multiply(next, prev, target){\n   target = target || new Float32Array(16);\n   // 第一列\n   var p00 = prev[0];\n   var p10 = prev[1];\n   var p20 = prev[2];\n   var p30 = prev[3];\n   // 第二列\n   var p01 = prev[4];\n   var p11 = prev[5];\n   var p21 = prev[6];\n   var p31 = prev[7];\n   // 第三列\n   var p02 = prev[8];\n   var p12 = prev[9];\n   var p22 = prev[10];\n   var p32 = prev[11];\n\n   // 第四列\n   var p03 = prev[12];\n   var p13 = prev[13];\n   var p23 = prev[14];\n   var p33 = prev[15];\n\n   // 第一行\n   var n00 = next[0];\n   var n01 = next[4];\n   var n02 = next[8];\n   var n03 = next[12];\n   // 第二行\n   var n10 = next[1];\n   var n11 = next[5];\n   var n12 = next[9];\n   var n13 = next[13];\n   // 第三行\n   var n20 = next[2];\n   var n21 = next[6];\n   var n22 = next[10];\n   var n23 = next[14];\n\n   // 第四行\n   var n30 = next[3];\n   var n31 = next[7];\n   var n32 = next[11];\n   var n33 = next[15];\n\n   target[0] = p00 * n00 + p10 * n01 + p20 * n02 + p30 * n03;\n   target[1] = p00 * n10 + p10 * n11 + p20 * n12 + p30 * n13;\n   target[2] = p00 * n20 + p10 * n21 + p20 * n22 + p30 * n23;\n   target[3] = p00 * n30 + p10 * n31 + p20 * n32 + p30 * n33;\n\n   target[4] = p01 * n00 + p11 * n01 + p21 * n02 + p31 * n03;\n   target[5] = p01 * n10 + p11 * n11 + p21 * n12 + p31 * n13;\n   target[6] = p01 * n20 + p11 * n21 + p21 * n22 + p31 * n23;\n   target[7] = p01 * n30 + p11 * n31 + p21 * n32 + p31 * n33;\n\n   target[8] = p02 * n00 + p12 * n01 + p22 * n02 + p32 * n03;\n   target[9] = p02 * n10 + p12 * n11 + p22 * n12 + p32 * n13;\n   target[10] = p02 * n20 + p12 * n21 + p22 * n22 + p32 * n23;\n   target[11] = p02 * n30 + p12 * n31 + p22 * n32 + p32 * n33;\n\n   target[12] = p03 * n00 + p13 * n01 + p23 * n02 + p33 * n03;\n   target[13] = p03 * n10 + p13 * n11 + p23 * n12 + p33 * n13;\n   target[14] = p03 * n20 + p13 * n21 + p23 * n22 + p33 * n23;\n   target[15] = p03 * n30 + p13 * n31 + p23 * n32 + p33 * n33;\n\n   return target;\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"我们一共要计算 16 个元素，可以看出计算步骤很繁琐，但都没有难度，都是简单的基本运算，我们只要保证好顺序正确就可以。"}),"\n",(0,a.jsxs)(e.h4,{id:"矩阵和标量相乘",children:["矩阵和标量相乘",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#矩阵和标量相乘",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"矩阵和标量相乘比较简单，各个位置的元素分别乘以标量就可以了。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function multiplyScalar(m, scalar){\n    if(scalar === undefined || scalar === null){\n        return m;\n    }\n    for(var i = 0; i < m.length; i++){\n        m[i] *= scalar;\n    }\n    return m;\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"转置矩阵",children:["转置矩阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#转置矩阵",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"转置矩阵其实就是将原矩阵的行变成列。\n有一个矩阵 M ："}),"\n",(0,a.jsxs)(e.p,{children:["$\n\\begin{pmatrix}\n1 & 2 & 3 & 4 \\",(0,a.jsx)(e.br,{}),"\n","5 & 6 & 7 & 8 \\",(0,a.jsx)(e.br,{}),"\n","9 & 10 & 11 & 12 \\",(0,a.jsx)(e.br,{}),"\n","13 & 14 & 15 & 16\n\\end{pmatrix}\n$"]}),"\n",(0,a.jsxs)(e.p,{children:["M 的转置矩阵：\n$\n\\begin{pmatrix}\n1 & 5 & 9 & 13 \\",(0,a.jsx)(e.br,{}),"\n","2 & 6 & 10 & 14 \\",(0,a.jsx)(e.br,{}),"\n","3 & 7 & 11 & 15 \\",(0,a.jsx)(e.br,{}),"\n","4 & 8 & 12 & 16\n\\end{pmatrix}\n$"]}),"\n",(0,a.jsx)(e.p,{children:"我们转置函数接收一个输入参数，表示待转置的矩阵，用m 表示："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["输入参数：","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"m，原矩阵"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(e.li,{children:["输出结果","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"target，转置矩阵。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function transpose(m, target){\n    target  = target || new Float32Array(16);\n    //转置矩阵的第一列\n    target[0] = m[0];\n    target[1] = m[4];\n    target[2] = m[8];\n    target[3] = m[12];\n    //转置矩阵的第二列\n    target[4] = m[1];\n    target[5] = m[5];\n    target[6] = m[9];\n    target[7] = m[13];\n    //转置矩阵的第三列\n    target[8] = m[2];\n    target[9] = m[6];\n    target[10] = m[10];\n    target[11] = m[14];\n    //转置矩阵的第四列\n    target[12] = m[3];\n    target[13] = m[7];\n    target[14] = m[11];\n    target[15] = m[15];\n    \n    return target;\n}\n"})}),"\n",(0,a.jsxs)(e.h4,{id:"计算逆矩阵",children:["计算逆矩阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#计算逆矩阵",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"逆矩阵的计算是最复杂的计算，很容易把人绕晕，如果大家感兴趣，按照上一节讲的逆矩阵求解步骤，可以自己写一下这个算法。"}),"\n",(0,a.jsx)(e.p,{children:"回忆一下，逆矩阵的计算分为 4 步："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"求出余子式矩阵。"}),"\n",(0,a.jsx)(e.li,{children:"为余子式矩阵增加符号。"}),"\n",(0,a.jsx)(e.li,{children:"转置第二步的矩阵。"}),"\n",(0,a.jsx)(e.li,{children:"将第三步得出的矩阵乘以 1/行列式。"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"完成以上四步，最后得出的矩阵就是逆矩阵了。\n我们实现一下该算法："}),"\n",(0,a.jsxs)(e.h5,{id:"1求出余子式矩阵",children:["1、求出余子式矩阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1求出余子式矩阵",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"假设矩阵M，$m_{ij}$来表示各个位置的元素，i 表示第几行，j 表示第几列。"}),"\n",(0,a.jsx)(e.p,{children:"例如m00，就代表处于第一行第一列的元素。"}),"\n",(0,a.jsxs)(e.p,{children:["$\n\\begin{pmatrix}\nm00 & m01 & m02 & m03 \\",(0,a.jsx)(e.br,{}),"\n","m10 & m11 & m12 & m13 \\",(0,a.jsx)(e.br,{}),"\n","m20 & m21 & m22 & m23 \\",(0,a.jsx)(e.br,{}),"\n","m30 & m31 & m32 & m33\n\\end{pmatrix}\n$"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function inverse(m){\n    //第一列\n    var m00 = m[0];\n    var m10 = m[1];\n    var m20 = m[2];\n    var m30 = m[3];\n    // 第二列\n    var m01 = m[4];\n    var m11 = m[5];\n    var m21 = m[6];\n    var m31 = m[7];\n    // 第三列\n    var m02 = m[8];\n    var m12 = m[9];\n    var m22 = m[10];\n    var m32 = m[11];\n    // 第四列\n    var m03 = m[12];\n    var m13 = m[13];\n    var m23 = m[14];\n    var m33 = m[15];\n}\n\n"})}),"\n",(0,a.jsx)(e.p,{children:"矩阵的行列式："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"  var tmp_22_33 = m22 * m33;\n  var tmp_32_23 = m32 * m23;\n  var tmp_21_33 = m21 * m33;\n  var tmp_31_23 = m31 * m23;\n  var tmp_12_23 = m12 * m23;\n  var tmp_22_13 = m22 * m13;\n  var tmp_10_23 = m10 * m23;\n  var tmp_20_13 = m20 * m13;\n  var tmp_11_23 = m11 * m23;\n  var tmp_21_13 = m21 * m13;\n  var tmp_20_32 = m20 * m32;\n  var tmp_10_22 = m10 * m22;\n  var tmp_20_12 = m20 * m12;\n  var tmp_10_21 = m10 * m21;\n  var tmp_20_11 = m20 * m11;\n  var tmp_31_22 = m31 * m22;\n  var tmp_30_23 = m30 * m23;\n  var tmp_30_22 = m30 * m22;\n  var tmp_20_33 = m20 * m33;\n  var tmp_20_31 = m20 * m31;\n  var tmp_30_21 = m30 * m21;\n  var tmp_21_32 = m21 * m32;\n  var tmp_12_33 = m12 * m33;\n  var tmp_32_13 = m32 * m13;\n  var tmp_11_32 = m11 * m32;\n  var tmp_31_12 = m31 * m12;\n  var tmp_11_33 = m11 * m33;\n  var tmp_31_13 = m31 * m13;\n  var tmp_10_33 = m10 * m33;\n  var tmp_30_13 = m30 * m13;\n  var tmp_10_32 = m10 * m32;\n  var tmp_30_12 = m30 * m12;\n  var tmp_10_31 = m10 * m31;\n  var tmp_30_11 = m30 * m11;\n  var tmp_11_22 = m11 * m22;\n  var tmp_21_12 = m21 * m12;\n\n  var t00 =\n    m11 * (tmp_22_33 - tmp_32_23) -\n    m12 * (tmp_21_33 - tmp_31_23) +\n    m13 * (tmp_21_32 - tmp_31_22);\n  var t01 =\n    m10 * (tmp_22_33 - tmp_32_23) -\n    m12 * (tmp_20_33 - tmp_30_23) +\n    m13 * (tmp_20_32 - tmp_30_22);\n  var t02 =\n    m10 * (tmp_21_33 - tmp_31_23) -\n    m11 * (tmp_20_33 - tmp_30_23) +\n    m13 * (tmp_20_31 - tmp_30_21);\n  var t03 =\n    m10 * (tmp_21_32 - tmp_31_22) -\n    m11 * (tmp_20_32 - tmp_30_22) +\n    m12 * (tmp_20_31 - tmp_30_21);\n\n  // 矩阵的行列式\n  var determinant = m00 * t00 - m01 * t01 + m02 * t02 - m03 * t03;\n"})}),"\n",(0,a.jsxs)(e.h5,{id:"余子式矩阵",children:["余子式矩阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#余子式矩阵",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"余子式矩阵是将原矩阵各个位置的行列式求解出来放在对应位置，生成的一个新矩阵。"}),"\n",(0,a.jsx)(e.p,{children:"求解行列式是一个很繁琐但是很简单的过程，因为它涉及到的只是简单的算术运算。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"// 第一行\n  var n00 = t00;\n  var n01 = t01;\n  var n02 = t02;\n  var n03 = t03;\n\n  // 第二行\n  var n10 =\n    m01 * (tmp_22_33 - tmp_32_23) -\n    m02 * (tmp_21_33 - tmp_31_23) +\n    m03 * (tmp_21_32 - tmp_31_22);\n  var n11 =\n    m00 * (tmp_22_33 - tmp_32_23) -\n    m02 * (tmp_20_33 - tmp_30_23) +\n    m03 * (tmp_20_32 - tmp_30_22);\n  var n12 =\n    m00 * (tmp_21_33 - tmp_31_23) -\n    m01 * (tmp_20_33 - tmp_30_23) +\n    m03 * (tmp_20_31 - tmp_30_21);\n  var n13 =\n    m00 * (tmp_21_32 - tmp_31_22) -\n    m01 * (tmp_20_32 - tmp_30_22) +\n    m02 * (tmp_20_31 - tmp_30_21);\n\n  // 第三行\n  var n20 =\n    m01 * (tmp_12_33 - tmp_32_13) -\n    m02 * (tmp_11_33 - tmp_31_13) +\n    m03 * (tmp_11_32 - tmp_31_12);\n  var n21 =\n    m00 * (tmp_12_33 - tmp_32_13) -\n    m02 * (tmp_10_33 - tmp_30_13) +\n    m03 * (tmp_10_32 - tmp_30_12);\n  var n22 =\n    m00 * (tmp_11_33 - tmp_31_13) -\n    m01 * (tmp_10_33 - tmp_30_13) +\n    m03 * (tmp_10_31 - tmp_30_11);\n  var n23 =\n    m00 * (tmp_11_32 - tmp_31_12) -\n    m01 * (tmp_10_32 - tmp_30_12) +\n    m02 * (tmp_10_31 - tmp_30_11);\n\n  // 第四行\n  var n30 =\n    m01 * (tmp_12_23 - tmp_22_13) -\n    m02 * (tmp_21_33 - tmp_31_23) +\n    m03 * (tmp_11_22 - tmp_21_12);\n  var n31 =\n    m00 * (tmp_12_23 - tmp_22_13) -\n    m02 * (tmp_10_23 - tmp_20_13) +\n    m03 * (tmp_10_22 - tmp_20_12);\n  var n32 =\n    m00 * (tmp_11_23 - tmp_21_13) -\n    m01 * (tmp_10_23 - tmp_20_13) +\n    m03 * (tmp_10_21 - tmp_20_11);\n  var n33 =\n    m00 * (tmp_11_22 - tmp_21_12) -\n    m01 * (tmp_10_22 - tmp_20_12) +\n    m02 * (tmp_10_21 - tmp_20_11);\n\n"})}),"\n",(0,a.jsxs)(e.h5,{id:"代数余子式矩阵",children:["代数余子式矩阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代数余子式矩阵",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:'把"纵横交错"排列的正负号放在"余子式矩阵"上。换句话说，我们需要每隔一个格改变正负号，像这样：'}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)("img",{src:i,alt:""})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"n01 = -n01;\nn03 = -n03;\nn10 = -n10;\nn12 = -n12;\nn21 = -n21;\nn23 = -n23;\nn30 = -n30;\nn32 = -n32;\n"})}),"\n",(0,a.jsxs)(e.h5,{id:"转置代数余子式矩阵",children:["转置代数余子式矩阵",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#转置代数余子式矩阵",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"将上面经过转换符号的余子式矩阵转置。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"target = target || new Float32Array(16);\ntarget[0] = n00;\ntarget[1] = n01;\ntarget[2] = n02;\ntarget[3] = n03;\ntarget[4] = n10;\ntarget[5] = n11;\ntarget[6] = n12;\ntarget[7] = n13;\ntarget[8] = n20;\ntarget[9] = n21;\ntarget[10] = n22;\ntarget[11] = n23;\ntarget[12] = n30;\ntarget[13] = n31;\ntarget[14] = n32;\ntarget[15] = n33;\n"})}),"\n",(0,a.jsxs)(e.h5,{id:"乘以-1原矩阵的行列式",children:["乘以 1/原矩阵的行列式",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#乘以-1原矩阵的行列式",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"最后一步，我们将上面得到的转置矩阵乘以 1/原矩阵的行列式，得出的新矩阵就是所求逆矩阵。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"for(var i = 0; i< result.length; i++){\n    target[i] = target[i] * 1 / determinant;\n}\n\nreturn target;\n"})}),"\n",(0,a.jsx)(e.p,{children:"哇哦，历尽九九八十一难，我们终于求出了逆矩阵。"}),"\n",(0,a.jsx)(e.p,{children:"大家可以看到，数学库所做的就是将数学中的矩阵、向量以及它们之间的运算表示出来，步骤很繁琐，但是都不难。这些函数我们只要会用，知道它们所适用的场景就可以了。"}),"\n",(0,a.jsxs)(e.h2,{id:"回顾",children:["回顾",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"本节主要实现了图形学涉及到数学中的向量和矩阵的基本运算，除此以外，我们还有一些3D 开发中经常用到的方法没有实现，比如顶点旋转、平移、缩放等变换矩阵。"}),"\n",(0,a.jsx)(e.p,{children:"但在这之前，我们要先学习为什么需要这些变换，具体需要哪些变换。"}),"\n",(0,a.jsx)(e.p,{children:"这些东西在下一节揭晓，下一节主要涉及到 WebGL  中的常见坐标系以及坐标系之间的变换，让我们拭目以待吧~"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(s,{...n})}):s(n)}let d=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F16.%E4%B8%AD%E7%BA%A7%E8%BF%9B%E9%98%B6%20---%20%20%E9%80%9A%E7%94%A8%E6%95%B0%E5%AD%A6%E5%BA%93%E7%9A%84%20JavaScript%20%E5%AE%9E%E7%8E%B0%E3%80%82.md"]={toc:[{text:"需要实现哪些功能？",id:"需要实现哪些功能",depth:2},{text:"矩阵在 GLSL 中的存储特点。",id:"矩阵在-glsl-中的存储特点",depth:2},{text:"行主序和列主序",id:"行主序和列主序",depth:3},{text:"实现JavaScript数学库",id:"实现javascript数学库",depth:2},{text:"JavaScript中 用什么数据结构来表示矩阵",id:"javascript中-用什么数据结构来表示矩阵",depth:3},{text:"实现数学库中的方法",id:"实现数学库中的方法",depth:3},{text:"3维向量初始化",id:"3维向量初始化",depth:4},{text:"归一化向量",id:"归一化向量",depth:4},{text:"向量与向量相加",id:"向量与向量相加",depth:4},{text:"向量与向量相减",id:"向量与向量相减",depth:4},{text:"向量与标量相乘",id:"向量与标量相乘",depth:4},{text:"向量与向量相乘",id:"向量与向量相乘",depth:4},{text:"点乘",id:"点乘",depth:4},{text:"叉乘",id:"叉乘",depth:4},{text:"初始化 4 阶单位矩阵",id:"初始化-4-阶单位矩阵",depth:4},{text:"初始化 4 阶方阵",id:"初始化-4-阶方阵",depth:4},{text:"矩阵和矩阵相加减",id:"矩阵和矩阵相加减",depth:4},{text:"矩阵和矩阵相乘",id:"矩阵和矩阵相乘",depth:4},{text:"矩阵和标量相乘",id:"矩阵和标量相乘",depth:4},{text:"转置矩阵",id:"转置矩阵",depth:4},{text:"计算逆矩阵",id:"计算逆矩阵",depth:4},{text:"回顾",id:"回顾",depth:2}],title:"16.中级进阶 ---  通用数学库的 JavaScript 实现。",headingTitle:"16.中级进阶 ---  通用数学库的 JavaScript 实现。",frontmatter:{}}}}]);