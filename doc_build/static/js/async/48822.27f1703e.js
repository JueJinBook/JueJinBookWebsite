"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["48822"],{813107:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var a=r(552676),s=r(740453);let d=r.p+"static/image/de990471d94dbc40abd784c551dc3035.77a990bc.gif",c=r.p+"static/image/fc2658f1a85fe7c027925acdeed67107.131d6508.webp";function t(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ol:"ol",li:"li",h3:"h3",code:"code",pre:"pre",ul:"ul",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h4:"h4",img:"img"},(0,s.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"36api-篇-_-常用函数与方法下",children:["36.API 篇 _ 常用函数与方法（下）",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36api-篇-_-常用函数与方法下",children:"#"})]}),"\n",(0,a.jsxs)(n.h2,{id:"前言",children:["前言",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"本篇我们讲解请求相关的常用方法，有："}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-1",target:"_blank",rel:"noopener noreferrer",children:"generateStaticParams"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-5",target:"_blank",rel:"noopener noreferrer",children:"generateViewport"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-12",target:"_blank",rel:"noopener noreferrer",children:"revalidatePath"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-23",target:"_blank",rel:"noopener noreferrer",children:"revalidateTag"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-30",target:"_blank",rel:"noopener noreferrer",children:"unstable_cache"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-34",target:"_blank",rel:"noopener noreferrer",children:"unstable_noStore"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-37",target:"_blank",rel:"noopener noreferrer",children:"useSelectedLayoutSegment"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-41",target:"_blank",rel:"noopener noreferrer",children:"useSelectedLayoutSegments"})}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"用到的时候到此篇查看具体的语法即可。"}),"\n",(0,a.jsxs)(n.h2,{id:"1-generatestaticparams",children:["1. generateStaticParams",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-generatestaticparams",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"11-介绍",children:["1.1. 介绍",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-介绍",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"generateStaticParams"}),"和动态路由一起使用，用于在构建时静态生成路由："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/product/[id]/page.js\nexport function generateStaticParams() {\n  return [{ id: '1' }, { id: '2' }, { id: '3' }]\n}\n \n// 对应会生成 3 个静态路由：\n// - /product/1\n// - /product/2\n// - /product/3\nexport default function Page({ params }) {\n  const { id } = params\n  // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["可以在 ",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 使用 fetch 请求，这个例子更贴近实际的开发场景："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/blog/[slug]/page.js\nexport async function generateStaticParams() {\n  const posts = await fetch('https://.../posts').then((res) => res.json())\n \n  return posts.map((post) => ({\n    slug: post.slug,\n  }))\n}\n \nexport default function Page({ params }) {\n  const { slug } = params\n  // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["关于 ",(0,a.jsx)(n.code,{children:"generateStaticParams"}),"："]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["你可以使用 ",(0,a.jsx)(n.code,{children:"dynamicParams"})," 路由段配置控制当访问不是由 ",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 生成的动态段时发生的情况"]}),"\n",(0,a.jsxs)(n.li,{children:["在 ",(0,a.jsx)(n.code,{children:"next dev"}),"的时候，当你导航到路由时，",(0,a.jsx)(n.code,{children:"generateStaticParams"}),"才会被调用"]}),"\n",(0,a.jsxs)(n.li,{children:["在 ",(0,a.jsx)(n.code,{children:"next build"}),"的时候，",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 会在对应的布局或页面生成之前运行"]}),"\n",(0,a.jsxs)(n.li,{children:["在 重新验证（ISR）的时候，",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 不会再次被调用"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"generateStaticParams"})," 替代了 Pages Router 下的 ",(0,a.jsx)(n.code,{children:"getStaticPaths"})," 函数的功能"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["上面这个例子是处理单个动态段，",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 也可以处理多个动态段："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/products/[category]/[product]/page.js\nexport function generateStaticParams() {\n  return [\n    { category: 'a', product: '1' },\n    { category: 'b', product: '2' },\n    { category: 'c', product: '3' },\n  ]\n}\n \n// 对应会生成 3 个静态路由：\n// - /products/a/1\n// - /products/b/2\n// - /products/c/3\nexport default function Page({ params }) {\n  const { category, product } = params\n  // ...\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"也可以处理 Catch-all 动态段："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/product/[...slug]/page.js\nexport function generateStaticParams() {\n  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]\n}\n \n// 对应会生成 3 个静态路由：\n// - /product/a/1\n// - /product/b/2\n// - /product/c/3\nexport default function Page({ params }) {\n  const { slug } = params\n  // ...\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"12-参数",children:["1.2. 参数",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-参数",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"generateStaticParams"})," 支持传入一个可选 ",(0,a.jsx)(n.code,{children:"options.params"})," 参数。如果一个路由中的多个动态段都使用了 ",(0,a.jsx)(n.code,{children:"generateStaticParams"}),"，子 ",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 函数会为每一个父 ",(0,a.jsx)(n.code,{children:"generateStaticParams"}),"生成的 ",(0,a.jsx)(n.code,{children:"params"})," 执行一次。"]}),"\n",(0,a.jsxs)(n.p,{children:["这句话是什么意思呢？举个例子，现在我们有这样一个 ",(0,a.jsx)(n.code,{children:"/products/[category]/[product]"}),"路由地址，这个路由里有两个动态段 ",(0,a.jsx)(n.code,{children:"[category]"}),"和 ",(0,a.jsx)(n.code,{children:"[product]"}),"，",(0,a.jsx)(n.code,{children:"[product]"})," 依赖于 ",(0,a.jsx)(n.code,{children:"[category]"}),"，毕竟要先知道类目才能该类目下知道有哪些产品。为了解决这个问题："]}),"\n",(0,a.jsx)(n.p,{children:"首先生成父段："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/products/[category]/layout.js\nexport async function generateStaticParams() {\n  const products = await fetch('https://.../products').then((res) => res.json())\n \n  return products.map((product) => ({\n    category: product.category.slug,\n  }))\n}\n \nexport default function Layout({ params }) {\n  // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["然后子 ",(0,a.jsx)(n.code,{children:"generateStaticParams"}),"函数就可以使用父 ",(0,a.jsx)(n.code,{children:"generateStaticParams"}),"函数返回的 ",(0,a.jsx)(n.code,{children:"params"})," 参数动态生成自己的段："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/products/[category]/[product]/page.js\nexport async function generateStaticParams({ params: { category } }) {\n  const products = await fetch(\n    `https://.../products?category=${category}`\n  ).then((res) => res.json())\n \n  return products.map((product) => ({\n    product: product.id,\n  }))\n}\n \nexport default function Page({ params }) {\n  // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["在这个例子中，",(0,a.jsx)(n.code,{children:"params"})," 对象就包含了从父 ",(0,a.jsx)(n.code,{children:"generateStaticParams"}),"生成的 ",(0,a.jsx)(n.code,{children:"params"}),"，可以用此生成子段的 ",(0,a.jsx)(n.code,{children:"params"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:["这种填充动态段的方式被称为“",(0,a.jsx)(n.strong,{children:"自上而下生成参数"}),"”，子段依赖于父段的数据。但如果不依赖，就比如提供一个接口，直接返回所有的产品和对应的目录信息，完全可以直接生成，示例代码如下："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/products/[category]/[product]/page.js\nexport async function generateStaticParams() {\n  const products = await fetch('https://.../products').then((res) => res.json())\n \n  return products.map((product) => ({\n    category: product.category.slug,\n    product: product.id,\n  }))\n}\n \nexport default function Page({ params }) {\n  // ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["不需要再写父 ",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 函数，直接一步到位，这种填充动态段的方式被称为“",(0,a.jsx)(n.strong,{children:"自下而上生成参数"}),"”。"]}),"\n",(0,a.jsxs)(n.h3,{id:"13-返回值",children:["1.3. 返回值",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-返回值",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"generateStaticParams"})," 应该返回一个对象数组，其中每个对象表示单个路由的填充动态段："]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"对象的每个属性都是路由要填充的动态段"}),"\n",(0,a.jsx)(n.li,{children:"属性名就是段名，属性值就是该段应该填写的内容"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"直接描述反而有些复杂，其实很简单，比如："}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"/product/[id]"}),"这种动态路由，",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 应该返回一个类似于 ",(0,a.jsx)(n.code,{children:"[{id: xxx}, {id: xxx}, ...]"})," 的对象。"]}),"\n",(0,a.jsxs)(n.p,{children:["对于 ",(0,a.jsx)(n.code,{children:"/products/[category]/[product]"}),"这种动态路由，",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 应该返回一个类似于 ",(0,a.jsx)(n.code,{children:"[{category: xxx, product: xxx}, {category: xxx, product: xxx}, ...]"})," 的对象。"]}),"\n",(0,a.jsxs)(n.p,{children:["对于 ",(0,a.jsx)(n.code,{children:"/products/[...slug]"}),"这种动态路由，",(0,a.jsx)(n.code,{children:"generateStaticParams"})," 应该返回一个类似于",(0,a.jsx)(n.code,{children:"[{slug: [xxx, xxx, ...]}, {slug: [xxx, xxx, ...]}, ...]"})," 的对象。"]}),"\n",(0,a.jsx)(n.p,{children:"返回类型描述如下："}),"\n",(0,a.jsxs)(n.table,{children:["\n",(0,a.jsxs)(n.thead,{children:["\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.th,{children:(0,a.jsx)(n.strong,{children:"示例路由"})}),"\n",(0,a.jsx)(n.th,{children:(0,a.jsx)(n.strong,{children:"generateStaticParams 返回类型"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.tbody,{children:["\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/product/[id]"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"{ id: string }[]"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/products/[category]/[product]"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"{ category: string, product: string }[]"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/products/[...slug]"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"{ slug: string[] }[]"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"2-generateviewport",children:["2. generateViewport",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-generateviewport",children:"#"})]}),"\n",(0,a.jsx)(n.p,{children:"你可以自定义页面的初始 viewport，有两种方法："}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["使用静态的 ",(0,a.jsx)(n.code,{children:"viewport"})," 对象"]}),"\n",(0,a.jsxs)(n.li,{children:["使用动态的 ",(0,a.jsx)(n.code,{children:"generateViewport"})," 函数"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"使用的时候要注意："}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"viewport"})," 对象和 ",(0,a.jsx)(n.code,{children:"generateViewport"})," 函数",(0,a.jsx)(n.strong,{children:"仅支持在服务端组件中导出"})]}),"\n",(0,a.jsxs)(n.li,{children:["不能在同一路由段中同时导出  ",(0,a.jsx)(n.code,{children:"viewport"})," 对象和 ",(0,a.jsx)(n.code,{children:"generateViewport"})," 函数"]}),"\n",(0,a.jsxs)(n.li,{children:["如果视口不依赖运行时的一些信息，尽可能使用 ",(0,a.jsx)(n.code,{children:"viewport"})," 对象的方式进行定义"]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"21-viewport-对象",children:["2.1. viewport 对象",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-viewport-对象",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["从 ",(0,a.jsx)(n.code,{children:"layout.js"})," 或者 ",(0,a.jsx)(n.code,{children:"page.js"})," 中导出一个名为 ",(0,a.jsx)(n.code,{children:"viewport"})," 的对象："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// layout.js | page.js \nexport const viewport = {\n  themeColor: 'black',\n}\n \nexport default function Page() {}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"22-generateviewport",children:["2.2. generateViewport",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-generateviewport",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["从 ",(0,a.jsx)(n.code,{children:"layout.js"})," 或者 ",(0,a.jsx)(n.code,{children:"page.js"})," 中导出一个名为 ",(0,a.jsx)(n.code,{children:"generateViewport"})," 的函数，该函数返回包含一个或者多个viewport 字段的 Viewport 对象："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"export function generateViewport({ params }) {\n  return {\n    themeColor: '...',\n  }\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"23-viewport-字段",children:["2.3. Viewport 字段",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-viewport-字段",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"themecolor",children:["themeColor",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#themecolor",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name/theme-color",target:"_blank",rel:"noopener noreferrer",children:"theme-color"}),"，用户的浏览器将根据所设定的建议颜色来改变用户界面，比如在 Android 上的 Chrome 设定颜色后："]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)("img",{src:c,alt:"image.png"}),"\n支持简单的主题颜色设置："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// layout.js | page.js\nexport const viewport = {\n  themeColor: 'black',\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"对应输出为："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-html",children:'<meta name="theme-color" content="black" />\n'})}),"\n",(0,a.jsx)(n.p,{children:"也支持带 media 属性的主题颜色设置："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"export const viewport = {\n  themeColor: [\n    { media: '(prefers-color-scheme: light)', color: 'cyan' },\n    { media: '(prefers-color-scheme: dark)', color: 'black' },\n  ],\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"对应输出为："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'<meta name="theme-color" media="(prefers-color-scheme: light)" content="cyan" />\n<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black" />\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"width-initialscale-和-maximumscale",children:[(0,a.jsx)(n.code,{children:"width"}),", ",(0,a.jsx)(n.code,{children:"initialScale"}),", 和 ",(0,a.jsx)(n.code,{children:"maximumScale"}),(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#width-initialscale-和-maximumscale",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["这其实是 ",(0,a.jsx)(n.code,{children:"viewport"}),"元标签的默认设置值，通常不需要手动设置："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// layout.js | page.js\nexport const viewport = {\n  width: 'device-width',\n  initialScale: 1,\n  maximumScale: 1,\n  // 也支持\n  // interactiveWidget: 'resizes-visual',\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"对应输出为："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'<meta\n  name="viewport"\n  content="width=device-width, initial-scale=1, maximum-scale=1"\n/>\n'})}),"\n",(0,a.jsxs)(n.h4,{id:"colorscheme",children:["colorScheme",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#colorscheme",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name",target:"_blank",rel:"noopener noreferrer",children:"colorScheme"}),"，指定与当前文档兼容的一种或多种配色方案。 浏览器将优先采用此元数据的值，然后再使用用户的浏览器或设备设置，来确定页面上的各种默认颜色和元素外观，例如背景色、前景色、窗体控件和滚动条。"," 的主要用途是指示当前页面与浅色模式和深色模式的兼容性，以及选用这两种模式时的优先顺序。它的值有 ",(0,a.jsx)(n.code,{children:"normal"}),"、",(0,a.jsx)(n.code,{children:"light"}),"、",(0,a.jsx)(n.code,{children:"dark"}),"、",(0,a.jsx)(n.code,{children:"only light"}),"。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// layout.js | page.js\nexport const viewport = {\n  colorScheme: 'dark',\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'<meta name="color-scheme" content="dark" />\n'})}),"\n",(0,a.jsxs)(n.h2,{id:"3-revalidatepath",children:["3. revalidatePath",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-revalidatepath",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"31-介绍",children:["3.1. 介绍",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-介绍",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"revalidatePath"})," 用于按需清除特定路径上的缓存数据，可用于 Node.js 和 Edge Runtimes。"]}),"\n",(0,a.jsxs)(n.p,{children:["使用 ",(0,a.jsx)(n.code,{children:"revalidatePath"})," 的时候要知道，在 Next.js 中，清除数据缓存并重新获取最新数据的过程就叫做重新验证（Revalidation），即便在动态路由段中调用了多次 ",(0,a.jsx)(n.code,{children:"revalidatePath"}),"，也不会立即触发多次重新验证，只有当下次访问的时候才会重新获取数据并更新缓存。"]}),"\n",(0,a.jsxs)(n.h3,{id:"32-参数",children:["3.2. 参数",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-参数",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"revalidatePath(path: string, type?: 'page' | 'layout'): void;\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"path"})," 可以是路由字符串（如 ",(0,a.jsx)(n.code,{children:"/product/123"}),"），也可以是文件系统地址字符串（如 ",(0,a.jsx)(n.code,{children:"/product/[slug]/page"}),"），必须少于 1024 个字符"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"type"}),"可选参数，要重新验证的地址类型，值为 ",(0,a.jsx)(n.code,{children:"page"}),"或 ",(0,a.jsx)(n.code,{children:"layout"})]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"33-返回值",children:["3.3. 返回值",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33-返回值",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"revalidatePath"})," 不返回任何值"]}),"\n",(0,a.jsxs)(n.h3,{id:"34-示例",children:["3.4. 示例",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34-示例",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"重新验证特定-url",children:["重新验证特定 URL",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重新验证特定-url",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/post-1')\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"重新验证页面路径",children:["重新验证页面路径",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重新验证页面路径",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/[slug]', 'page')\n// 带路由组也可以\nrevalidatePath('/(main)/post/[slug]', 'page')\n"})}),"\n",(0,a.jsxs)(n.p,{children:["注意在这个例子中，仅重新验证与所提供的 page 文件对应的 URL，也就是说，不会重新验证在这之下的页面，比如 /",(0,a.jsx)(n.code,{children:"blog/[slug]"})," 不会让 ",(0,a.jsx)(n.code,{children:"/blog/[slug]/[author]"})," 也失效"]}),"\n",(0,a.jsxs)(n.h4,{id:"重新验证布局路径",children:["重新验证布局路径",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重新验证布局路径",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { revalidatePath } from 'next/cache'\nrevalidatePath('/blog/[slug]', 'layout')\n// 带路由组也可以\nrevalidatePath('/(main)/post/[slug]', 'layout')\n"})}),"\n",(0,a.jsxs)(n.p,{children:["在这个例子中，这会何重新验证任何使用这个布局的页面，也就是说， /",(0,a.jsx)(n.code,{children:"blog/[slug]"}),"也会让 ",(0,a.jsx)(n.code,{children:"/blog/[slug]/[author]"})," 失效"]}),"\n",(0,a.jsxs)(n.h4,{id:"重新验证所有数据",children:["重新验证所有数据",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#重新验证所有数据",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { revalidatePath } from 'next/cache'\n \nrevalidatePath('/', 'layout')\n"})}),"\n",(0,a.jsx)(n.p,{children:"这会清除客户端路由缓存，并在下次访问时重新验证数据缓存。"}),"\n",(0,a.jsxs)(n.h4,{id:"server-action",children:["Server Action",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#server-action",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"'use server'\n// app/actions.js\nimport { revalidatePath } from 'next/cache'\n \nexport default async function submit() {\n  await submitForm()\n  revalidatePath('/')\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"路由处理程序",children:["路由处理程序",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由处理程序",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/api/revalidate/route.js\nimport { revalidatePath } from 'next/cache'\n \nexport async function GET(request) {\n  const path = request.nextUrl.searchParams.get('path')\n \n  if (path) {\n    revalidatePath(path)\n    return Response.json({ revalidated: true, now: Date.now() })\n  }\n \n  return Response.json({\n    revalidated: false,\n    now: Date.now(),\n    message: 'Missing path to revalidate',\n  })\n}\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"4-revalidatetag",children:["4. revalidateTag",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-revalidatetag",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"41-介绍",children:["4.1. 介绍",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#41-介绍",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"revalidateTag"})," 用于按需清除特定标签的缓存数据，可用于 Node.js 和 Edge Runtimes。"]}),"\n",(0,a.jsxs)(n.p,{children:["使用 ",(0,a.jsx)(n.code,{children:"revalidateTag"})," 的时候要知道，在 Next.js 中，清除数据缓存并重新获取最新数据的过程就叫做重新验证（Revalidation），即便在动态路由段中调用了多次 ",(0,a.jsx)(n.code,{children:"revalidateTag"}),"，也不会立即触发多次重新验证，只有当下次访问的时候才会重新获取数据并更新缓存。"]}),"\n",(0,a.jsxs)(n.h3,{id:"42-参数",children:["4.2. 参数",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#42-参数",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"revalidateTag(tag: string): void;\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"tag 表示要重新验证的标签，必须小于或等于 256 个字符。"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"添加标签的方式："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"fetch(url, { next: { tags: [...] } });\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"43-返回值",children:["4.3. 返回值",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#43-返回值",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"revalidateTag"})," 不返回任何值"]}),"\n",(0,a.jsxs)(n.h3,{id:"44-示例",children:["4.4. 示例",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#44-示例",children:"#"})]}),"\n",(0,a.jsxs)(n.h4,{id:"server-action-1",children:["Server Action",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#server-action-1",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/actions.js\nimport { revalidateTag } from 'next/cache'\n \nexport async function GET(request) {\n  const tag = request.nextUrl.searchParams.get('tag')\n  revalidateTag(tag)\n  return Response.json({ revalidated: true, now: Date.now() })\n}\n"})}),"\n",(0,a.jsxs)(n.h4,{id:"路由处理程序-1",children:["路由处理程序",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由处理程序-1",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/api/revalidate/route.js\nimport { revalidateTag } from 'next/cache'\n \nexport async function GET(request) {\n  const tag = request.nextUrl.searchParams.get('tag')\n  revalidateTag(tag)\n  return Response.json({ revalidated: true, now: Date.now() })\n}\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"5-unstable_cache",children:["5. unstable_cache",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-unstable_cache",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"51-介绍",children:["5.1. 介绍",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#51-介绍",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"unstable_cache"})," 用于缓存昂贵操作的结果（如数据库查询）并在之后的请求中复用结果，使用示例如下："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { getUser } from './data';\nimport { unstable_cache } from 'next/cache';\n \nconst getCachedUser = unstable_cache(\n  async (id) => getUser(id),\n  ['my-app-user']\n);\n \nexport default async function Component({ userID }) {\n  const user = await getCachedUser(userID);\n  ...\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"52-参数",children:["5.2. 参数",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#52-参数",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const data = unstable_cache(fetchData, keyParts, options)()\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"fetchData"}),"：获取要缓存数据的异步函数，该函数返回一个 Promise"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"keyParts"}),"：用于标识缓存键名的数组，必须包含全局唯一的值"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"options"}),"：用于控制缓存行为，具体包含：","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"tags"}),": 用于控制缓存失效的标签数组"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"revalidate"}),"：缓存需要重新验证的秒数"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"53-返回值",children:["5.3. 返回值",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#53-返回值",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"unstable_cache"})," 返回一个函数，该函数调用时会返回一个解析为缓存数据的 Promise。如果数据不在缓存中，则会调用提供的函数，将结果缓存并返回。"]}),"\n",(0,a.jsxs)(n.h2,{id:"6-unstable_nostore",children:["6. unstable_noStore",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-unstable_nostore",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"61-介绍",children:["6.1. 介绍",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#61-介绍",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"unstable_noStore"}),"用于声明退出静态渲染和表明该组件不应缓存，使用示例如下："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { unstable_noStore as noStore } from 'next/cache';\n \nexport default async function Component() {\n  noStore();\n  const result = await db.query(...);\n  ...\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"unstable_noStore"}),"相当于在 ",(0,a.jsx)(n.code,{children:"fetch"})," 上添加了 ",(0,a.jsx)(n.code,{children:"cache: 'no-store'"}),"。",(0,a.jsx)(n.code,{children:"unstable_noStore"})," 比 ",(0,a.jsx)(n.code,{children:"export const dynamic = 'force-dynamic'"}),"更好的一点是它更细粒度，可以在每个组件的基础上使用。"]}),"\n",(0,a.jsxs)(n.h3,{id:"62-示例",children:["6.2. 示例",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#62-示例",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["如果你不想向 ",(0,a.jsx)(n.code,{children:"fetch"})," 传递额外的选项如 ",(0,a.jsx)(n.code,{children:"cache: 'no-store'"})," 或 ",(0,a.jsx)(n.code,{children:"next: { revalidate: 0 }"}),"，你可以使用 ",(0,a.jsx)(n.code,{children:"noStore()"}),"作为替代。"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import { unstable_noStore as noStore } from 'next/cache';\n \nexport default async function Component() {\n  noStore();\n  const result = await db.query(...);\n  ...\n}\n"})}),"\n",(0,a.jsxs)(n.h2,{id:"7-useselectedlayoutsegment",children:["7. useSelectedLayoutSegment",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-useselectedlayoutsegment",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"71-介绍",children:["7.1. 介绍",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#71-介绍",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useSelectedLayoutSegment"}),"是一个客户端组件 hook，用于读取比调用该方法所在的布局低一级的激活路由段。这个功能对于导航 UI 非常有用，比如父布局中的选项卡，需要根据当前所处的路由段来更改样式，基础使用示例代码如下："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"'use client'\n// app/example-client-component.js\nimport { useSelectedLayoutSegment } from 'next/navigation'\n \nexport default function ExampleClientComponent() {\n  const segment = useSelectedLayoutSegment()\n \n  return <p>Active segment: {segment}</p>\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"为了解释这个 hook 的作用和用法，我们来写一个 demo，demo 效果如下："}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)("img",{src:d,alt:"1115.gif"})}),"\n",(0,a.jsx)(n.p,{children:"这个 demo 模拟的是侧边栏点击切换当前文章，你可以看到，随着路由的切换，对应链接的样式也发生了变化。代码如下："}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/blog/layout.js\nimport BlogNavLink from './blog-nav-link'\nimport getFeaturedPosts from './get-featured-posts'\n \nexport default async function Layout({ children }) {\n  const featuredPosts = await getFeaturedPosts()\n  return (\n    <div>\n      {featuredPosts.map((post) => (\n        <div key={post.id}>\n          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>\n        </div>\n      ))}\n      <div>{children}</div>\n    </div>\n  )\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"'use client'\n// app/blog/blog-nav-link.js\nimport Link from 'next/link'\nimport { useSelectedLayoutSegment } from 'next/navigation'\n \nexport default function BlogNavLink({ slug, children }) {\n  const segment = useSelectedLayoutSegment()\n  const isActive = slug === segment\n \n  return (\n    <Link\n      href={`/blog/${slug}`}\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    >\n      {children}\n    </Link>\n  )\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/blog/get-featured-posts.js\nexport default async function getFeaturedPosts() {\n  await new Promise((resolve) => setTimeout(resolve, 3000))\n  return [\n    { id: '1', slug: 'article1', title: '文章 1'},\n    { id: '2', slug: 'article2', title: '文章 2'},\n    { id: '3', slug: 'article3', title: '文章 3'}\n  ]\n}\n"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"// app/blog/[slug]/page.js\nexport default function Page({ params }) {\n  return <div>当前 slug: {params.slug}</div>\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["在这个例子中，",(0,a.jsx)(n.code,{children:"useSelectedLayoutSegment"})," 是在 ",(0,a.jsx)(n.code,{children:"app/blog/layout.js"}),"这个布局中调用的，所以访问 ",(0,a.jsx)(n.code,{children:"/blog/article1"})," 的时候，返回的是比这个布局低一级的路由段，也就是会返回 ",(0,a.jsx)(n.code,{children:"article1"}),"，然后我们在 ",(0,a.jsx)(n.code,{children:"blog-nav-link.js"})," 中根据该返回值和当前 slug 进行判断，从而实现了当前所处链接加粗功能。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useSelectedLayoutSegment"}),"返回比调用该方法所在的布局低一级的激活路由段，也就是说，即使你访问 ",(0,a.jsx)(n.code,{children:"blog/article1/about"}),"，因为调用该方法的布局依然是 ",(0,a.jsx)(n.code,{children:"app/blog/layout.js"}),"，所以返回的值依然是 ",(0,a.jsx)(n.code,{children:"article1"}),"。"]}),"\n",(0,a.jsxs)(n.h3,{id:"72-参数",children:["7.2 参数",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#72-参数",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const segment = useSelectedLayoutSegment(parallelRoutesKey?: string)\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useSelectedLayoutSegment"})," 接收一个可选的 parallelRoutesKey 参数，用于读取平行路由中的激活路由段。"]}),"\n",(0,a.jsxs)(n.h3,{id:"73-返回值",children:["7.3 返回值",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#73-返回值",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["如果不存在，会返回 ",(0,a.jsx)(n.code,{children:"null"}),"，让我们再看几个例子："]}),"\n",(0,a.jsxs)(n.table,{children:["\n",(0,a.jsxs)(n.thead,{children:["\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.th,{children:(0,a.jsx)(n.strong,{children:"Layout"})}),"\n",(0,a.jsx)(n.th,{children:(0,a.jsx)(n.strong,{children:"访问 URL"})}),"\n",(0,a.jsx)(n.th,{children:(0,a.jsx)(n.strong,{children:"返回值"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.tbody,{children:["\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"null"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"'dashboard'"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/dashboard/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"null"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/dashboard/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard/settings"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"'settings'"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/dashboard/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard/analytics"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"'analytics'"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/dashboard/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard/analytics/monthly"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"'analytics'"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"8-useselectedlayoutsegments",children:["8. useSelectedLayoutSegments",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-useselectedlayoutsegments",children:"#"})]}),"\n",(0,a.jsxs)(n.h3,{id:"81-介绍",children:["8.1. 介绍",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#81-介绍",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useSelectedLayoutSegments"})," 是一个客户端组件 hook，用于读取调用该方法所在的布局以下所有的激活路由段。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useSelectedLayoutSegments"})," 与 ",(0,a.jsx)(n.code,{children:"useSelectedLayoutSegment"})," 的区别是："]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"useSelectedLayoutSegment"})," 返回的是布局下一级的激活路由段"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"useSelectedLayoutSegments"})," 返回的是布局下所有的激活路由段"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["以上节的 demo 为例，当在 ",(0,a.jsx)(n.code,{children:"app/blog/layout.js"}),"布局中调用这两个方法："]}),"\n",(0,a.jsxs)(n.p,{children:["访问 ",(0,a.jsx)(n.code,{children:"/blog/article1"}),"，",(0,a.jsx)(n.code,{children:"useSelectedLayoutSegment"})," 返回",(0,a.jsx)(n.code,{children:"'article1'"}),"，",(0,a.jsx)(n.code,{children:"useSelectedLayoutSegments"}),"返回",(0,a.jsx)(n.code,{children:" "}),"['article1']``。"]}),"\n",(0,a.jsxs)(n.p,{children:["访问 ",(0,a.jsx)(n.code,{children:"/blog/article1/about"}),"，",(0,a.jsx)(n.code,{children:"useSelectedLayoutSegment"}),"返回 ",(0,a.jsx)(n.code,{children:"'article1'"}),"，",(0,a.jsx)(n.code,{children:"useSelectedLayoutSegments"}),"返回 ",(0,a.jsx)(n.code,{children:"['article1', 'about']"}),"。"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useSelectedLayoutSegments"}),"可以用于实现如面包屑功能，基础使用示例代码如下："]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"'use client'\n// app/example-client-component.js\nimport { useSelectedLayoutSegments } from 'next/navigation'\n \nexport default function ExampleClientComponent() {\n  const segments = useSelectedLayoutSegments()\n \n  return (\n    <ul>\n      {segments.map((segment, index) => (\n        <li key={index}>{segment}</li>\n      ))}\n    </ul>\n  )\n}\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"82-参数",children:["8.2. 参数",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#82-参数",children:"#"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"const segments = useSelectedLayoutSegments(parallelRoutesKey?: string)\n"})}),"\n",(0,a.jsxs)(n.h3,{id:"83-返回值",children:["8.3. 返回值",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#83-返回值",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["以数组形式返回，如果没有，返回空数组。注意如果使用了路由组，也会返回，所以可以再用一个 ",(0,a.jsx)(n.code,{children:"filter()"})," 排除掉以括号为开头的条目。让我们再看几个例子："]}),"\n",(0,a.jsxs)(n.table,{children:["\n",(0,a.jsxs)(n.thead,{children:["\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.th,{children:(0,a.jsx)(n.strong,{children:"Layout"})}),"\n",(0,a.jsx)(n.th,{children:(0,a.jsx)(n.strong,{children:"访问 URL"})}),"\n",(0,a.jsx)(n.th,{children:(0,a.jsx)(n.strong,{children:"返回值"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.tbody,{children:["\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"[]"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"['dashboard']"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard/settings"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"['dashboard', 'settings']"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/dashboard/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"[]"})}),"\n"]}),"\n",(0,a.jsxs)(n.tr,{children:["\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"app/dashboard/layout.js"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"/dashboard/settings"})}),"\n",(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"['settings']"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"参考链接",children:["参考链接",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考链接",children:"#"})]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/functions",target:"_blank",rel:"noopener noreferrer",children:(0,a.jsx)(n.a,{href:"https://nextjs.org/docs/app/api-reference/functions",target:"_blank",rel:"noopener noreferrer",children:"https://nextjs.org/docs/app/api-reference/functions"})})}),"\n"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(t,{...e})}):t(e)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["Next.js%20%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F36.API%20%E7%AF%87%20_%20%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"1. generateStaticParams",id:"1-generatestaticparams",depth:2},{text:"1.1. 介绍",id:"11-介绍",depth:3},{text:"1.2. 参数",id:"12-参数",depth:3},{text:"1.3. 返回值",id:"13-返回值",depth:3},{text:"2. generateViewport",id:"2-generateviewport",depth:2},{text:"2.1. viewport 对象",id:"21-viewport-对象",depth:3},{text:"2.2. generateViewport",id:"22-generateviewport",depth:3},{text:"2.3. Viewport 字段",id:"23-viewport-字段",depth:3},{text:"themeColor",id:"themecolor",depth:4},{text:"`width`, `initialScale`, 和 `maximumScale`",id:"width-initialscale-和-maximumscale",depth:4},{text:"colorScheme",id:"colorscheme",depth:4},{text:"3. revalidatePath",id:"3-revalidatepath",depth:2},{text:"3.1. 介绍",id:"31-介绍",depth:3},{text:"3.2. 参数",id:"32-参数",depth:3},{text:"3.3. 返回值",id:"33-返回值",depth:3},{text:"3.4. 示例",id:"34-示例",depth:3},{text:"重新验证特定 URL",id:"重新验证特定-url",depth:4},{text:"重新验证页面路径",id:"重新验证页面路径",depth:4},{text:"重新验证布局路径",id:"重新验证布局路径",depth:4},{text:"重新验证所有数据",id:"重新验证所有数据",depth:4},{text:"Server Action",id:"server-action",depth:4},{text:"路由处理程序",id:"路由处理程序",depth:4},{text:"4. revalidateTag",id:"4-revalidatetag",depth:2},{text:"4.1. 介绍",id:"41-介绍",depth:3},{text:"4.2. 参数",id:"42-参数",depth:3},{text:"4.3. 返回值",id:"43-返回值",depth:3},{text:"4.4. 示例",id:"44-示例",depth:3},{text:"Server Action",id:"server-action-1",depth:4},{text:"路由处理程序",id:"路由处理程序-1",depth:4},{text:"5. unstable_cache",id:"5-unstable_cache",depth:2},{text:"5.1. 介绍",id:"51-介绍",depth:3},{text:"5.2. 参数",id:"52-参数",depth:3},{text:"5.3. 返回值",id:"53-返回值",depth:3},{text:"6. unstable_noStore",id:"6-unstable_nostore",depth:2},{text:"6.1. 介绍",id:"61-介绍",depth:3},{text:"6.2. 示例",id:"62-示例",depth:3},{text:"7. useSelectedLayoutSegment",id:"7-useselectedlayoutsegment",depth:2},{text:"7.1. 介绍",id:"71-介绍",depth:3},{text:"7.2 参数",id:"72-参数",depth:3},{text:"7.3 返回值",id:"73-返回值",depth:3},{text:"8. useSelectedLayoutSegments",id:"8-useselectedlayoutsegments",depth:2},{text:"8.1. 介绍",id:"81-介绍",depth:3},{text:"8.2. 参数",id:"82-参数",depth:3},{text:"8.3. 返回值",id:"83-返回值",depth:3},{text:"参考链接",id:"参考链接",depth:2}],title:"36.API 篇 _ 常用函数与方法（下）",headingTitle:"36.API 篇 _ 常用函数与方法（下）",frontmatter:{}}}}]);