"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["13380"],{511931:function(e,n,i){e.exports=i.p+"static/image/e6d9dfa370fddd621e6fc74543644c0c.6347f2c9.gif"},62375:function(e,n,i){i.r(n),i.d(n,{default:()=>L});var t=i(552676),c=i(740453);let l=i.p+"static/image/4bb94e0d44b82bab95894948e3aaf7df.c4f596c1.gif",x=i.p+"static/image/a2a0b8e309b77f8b0674a04c248b949b.beacb21a.webp",s=i.p+"static/image/b9dda52dad57fe334f87680d58882cdf.1fb87d2a.webp",p=i.p+"static/image/e97c7f1619fe2cf722344f76e570ff69.f333e8fc.webp",r=i.p+"static/image/8f223912bd7795b6d6efd365bff6cd32.dfcf7d0e.webp",o=i.p+"static/image/2271da0a396d7df809a4aa90599ad3c2.bd324eee.webp",d=i.p+"static/image/525ff6460d8a9ff345430e38b3607c46.ef9dc09d.webp",a=i.p+"static/image/76eb9e84ce448bb3ddde04ecd71b1015.92726881.webp",f=i.p+"static/image/6e67fb07e6c1ab2e1402fe112fc3f5f8.e539c5aa.webp",h=i.p+"static/image/98d85ff78051248b8311e54a2468bd52.620f5a61.webp",g=i.p+"static/image/a05e34c4a5f356d098e49ef1457a80a2.f86984ec.webp",j=i.p+"static/image/5844f84db7148ed4c1519118e64c4d33.2a5f008e.webp",m=i.p+"static/image/37344dae72f64ceae050da4028650e83.0579c526.webp",b=i.p+"static/image/38fc463d2536e113886994d4c4e0f03e.362009e7.gif",u=i.p+"static/image/745c0f366aedd2d363cc90fa8eebb38b.8dac734d.webp",w=i.p+"static/image/7748f793c91fe2d49c73681cc6124549.0a2f787a.webp",v=i.p+"static/image/65ae3904d332b6e799e3d561b2aeff27.6616a79e.webp",E=i.p+"static/image/e3280443a69594a18df41a962ae49283.9cb85923.webp",T=i.p+"static/image/964b3446d8ea661a4f01144698df38d8.39dc27d1.webp",H=i.p+"static/image/94a2460bb13324343ccf173f7fce8abf.d605e9b2.webp",Y=i.p+"static/image/70ede803f067cb4180d7b167f67e6895.c2b848d1.webp",A=i.p+"static/image/bebb1f3ae747506142a3ae704204578e.533e39de.webp",k=i.p+"static/image/a7bedc94c7519a1d7160bdd57a535c58.d274bd03.webp",B=i.p+"static/image/887b0d5ef17c9e1cd6ff9edc69fa1702.6d67749d.webp",M=i.p+"static/image/4214a1be55d14ea28b9e54bd10a71323.ba205384.webp",C=i.p+"static/image/29bfe392248558a5b9820601a727d2eb.d3eaa60b.webp",O=i.p+"static/image/40a14da171e897e8db552e684a35941e.74860cd4.webp",Q=i.p+"static/image/4b3afe63a78b2f96a03237cb0034abc7.7ceb2cdc.webp",y=i.p+"static/image/7706f2a926c356f9ca4d323dc0b04b38.d08bbf47.webp",N=i.p+"static/image/ef1efe74dbbe678a7dce40a223f9ef4b.c2f51b55.webp";var R=i(511931);function D(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li"},(0,c.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"第20章图解网页的各种距离",children:["第20章—图解网页的各种距离",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第20章图解网页的各种距离",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"\uFEFF网页开发中，我们经常要计算各种距离。"}),"\n",(0,t.jsx)(n.p,{children:"比如 OnBoarding 组件，我们要拿到每一步的高亮元素的位置、宽高："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:R,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"比如 Popover 组件，需要拿到每个元素的位置，然后确定浮层位置："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:N,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"比如滚动到页面底部，触发列表的加载，这需要拿到滚动的距离和页面的高度。"}),"\n",(0,t.jsx)(n.p,{children:"类似这样，需要计算距离、宽高等的场景有很多。"}),"\n",(0,t.jsx)(n.p,{children:"而浏览器里与距离、宽高有关的属性也有不少。"}),"\n",(0,t.jsx)(n.p,{children:"今天我们来整体过一遍。"}),"\n",(0,t.jsx)(n.p,{children:"首先，页面一般都是超过一屏的，右边会出现滚动条，代表当前可视区域的位置："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:y,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这里窗口的部分是可视区域，也叫做视口 viewport。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:Q,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"如果我们点击了可视区域内的一个元素，如何拿到位置信息呢？"}),"\n",(0,t.jsx)(n.p,{children:"我们只看 y 轴方向好了，x 轴也是一样的。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:O,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"事件对象可以拿到 pageY、clientY、offsetY，分别代表到点击的位置到文档顶部，到可视区域顶部，到触发事件的元素顶部的距离。"}),"\n",(0,t.jsx)(n.p,{children:"还有个 screenY，是拿到到屏幕顶部的距离。"}),"\n",(0,t.jsx)(n.p,{children:"我们试一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npx create-vite\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:C,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"去掉 main.tsx 的里 index.css 和 StrictMode："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:M,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后改下 App.tsx"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { MouseEventHandler, useEffect, useRef } from 'react'\n\nfunction App() {\n  const ref = useRef<HTMLDivElement>(null);\n\n  const clickHandler: MouseEventHandler<HTMLDivElement> = (e) => {\n    console.log('box pageY', e.pageY);\n    console.log('box clientY', e.clientY)\n    console.log('box offsetY', e.offsetY);\n    console.log('box screenY', e.screenY);\n  }\n\n  useEffect(() => {\n    document.getElementById('box')!.addEventListener('click', (e) => {\n      console.log('box2 pageY', e.pageY);\n      console.log('box2 clientY', e.clientY)\n      console.log('box2 offsetY', e.offsetY);\n      console.log('box2 screenY', e.screenY);\n    });\n  }, []);\n\n  return (\n    <div>\n      <div id=\"box\" ref={ref} style={{\n        marginTop: '800px',\n        width: '100px',\n        height: '100px',\n        background: 'blue'\n      }} onClick={clickHandler}></div>\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"为什么要用两种方式添加点击事件呢？"}),"\n",(0,t.jsx)(n.p,{children:"因为这里要介绍一个 react 事件的坑点："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:B,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"react 事件是合成事件，所以它少了一些原生事件的属性，比如这里的 offsetY，也就是点击的位置距离触发事件的元素顶部的距离。"}),"\n",(0,t.jsx)(n.p,{children:"你写代码的时候 ts 就报错了："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:k,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"那咋办呢？"}),"\n",(0,t.jsx)(n.p,{children:"react-use 提供的 useMouse 的 hook 就解决了这个问题："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:A,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"它是用 e.pageY 减去 getBoundingClientRect().top 减去 window.pageYOffset 算出来的。"}),"\n",(0,t.jsx)(n.p,{children:"这里的 getBoundingClientRect 是返回元素距离可以可视区域的距离和宽高的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:Y,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"而 window.pageYOffset 也叫 window.scrollY，顾名思义就是窗口滚动的距离。"}),"\n",(0,t.jsx)(n.p,{children:"想一下，pageY 去了 window.scrollY，去了 getBoundingClientRect().top，剩下的可不就是 offsetY 么："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:H,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:"data:image/webp;base64,UklGRh4GAABXRUJQVlA4IBIGAACwLQCdASpoAcQAPp1MoU0lpCOiIZSZqLATiWVu4XEw75fS5ffH5dPE/mLv7emHbheYnzT/RnvMW83/3vJcbWCpp3K4vV7uF5gQjawhFsgSVTEfCNvys56ZwpLzbUyB5Kr+QG6QKrW4DZQHjVLlXFNCBMjyQbpAdyWqvzse3KvnJb1qrt5dPsxQ2tETEa+TNxxHk/InHEV3US/KwMSE+Q+MbkQxjn3zEa6Cd1QbhDVHOrES5gK0kPUag2VgZP/SAjEkJvq1vi0mHaKsd3JIto7v1MNk18khn+PZv5S9Iv6jas1TmWfOWe0AJGXEyKM0lOTYT9Qx1YbV+XBETsOmUTlVCJiVdbii4N/lJiduVfOS4bjfTp5Ksa0PMl72Y7vTxHtVhxthG1hNf2rUxjn3zEa+TOFJecKSF0rWDuhjNOS84Ul5OHQ9qc2HY/fOx++dEx1iPonlDmE82MnDOElQiW4KrgH752P3zsQX0+l4c7CmNbo7ZlyzoAD+/gJAqd/2hv8Qb778jkA1ELyexAia/E8wN2gzm3xam2C8iAvvmFqS/3aeMiMkhyXaAclYv+mj5vkl7sBm9B8GTzh6CuXLly3oHBDuB0PKpqOaWdOUcPjFpp4vePwgtyNwTVBrqOfLNlceGE8GTe6FTFzsJTudsY95a6LTfVyUnah+jr7S+0b29dDKw8mky2cJoCX2P3SERSfXqyEXv/b070oXK1cEF0cXWpOcAxwQoI77ShPEzpN1HjgU+KPsUbytjgpM9+ZMhi3WPEnXKk4PxlqJ3+EKwRv5rauif6hKvsX4azlTG7Vkwv1XFHpKQchEcUUgZspOC07sr96/pv1szFwYQRpi7qKpQvU45nmjCdJ8yRYxkU0HGDTD7xK+PAE+BFxy7R/eyzHzprktkOM6331g9tHPCgYjhZXxpaXt8kpQ/FXenlzp16CUrHONQarE2K0Zs2HNiw3y6lwsy88omWSoVGkMnibC8DIGXvUKkirgG9gdkCbNDUwZ/u+nrmmWm17v8Rqzwf0zIAk10NlX8XPZhwLaSsrXAOdLQuNF17B4AMfsqUxwKI/xkyBp6JgZzamMl1YV5F1QoNDh1dtlIlq0OrIEqmmWlT4AdKzShbyJPMIEJEz3DS1mz3SkKx2KT8oTyBN0XOHdV9Gy6HrDk21pAdoaQstvJ694tsQf7hLqfQ+vj7iZ9KaiWUvdawCR3ijk/owRhL14tgX6zbw9egkL173bLHQ7BGQk5oBm7uJ3DEhQD4uthcWBKWV7fCINT+bOplVxHGP8bI/6kFuZn+6HNkQl0xFsLyzoTx2TwI4orDZA8fYybk+sDFxJLZuN1/yjvwzeZShlIK4rfZjOW+8dLEFGRxRoj1/vGWol5tvLnMwKW6zN78Uw/yfvmjC7HQ5jNqF/cVcJ/ZCaJQPPA7B2ZhZor8/rxOl/C8NVWQn63bQDcwPRIpL1iaXDInKVq+2ASUqPyAui3lnocvCqkyQzvKEU2RSIadAAAhPaTZCQX6eDVqwwAwFMbbB/BlgCnu/wX/Adiiy28mPBBE0rIV29mMzZSAW1jv/f55GvltD2Vr0DyAUFr5Mx4ewiQ/WMh/ccuNffQ9PDSHgUE2PGW5YKxyje5gsxPkWTl2GYYfJ+9iCD3XqNIlu9No1j869INwO1alT8ozpVimBZv0AWhQqaUyMOeBpSuVQbzWASdAmVgdmyhIFsfM4JN/MWW3fxWY8o1cAwRbIYGKcCKlm+vR/38C/Tg+oHhwr8BuaFIIq2a/mnTuvB0WJwrwHcqLQsyIAGefHbJ5dLk94Cj+3OWiipKQko1Hz6fbx5yiq33YD4NNlShkXH02jIYRb2BkjfN988gbfjKDna8C04RFwAvNvVOuTWLENfEgvX8L7Gi22COvP5LQ3m1jqNSUI9AADebbXYwGE1/NOgJ5are4AIEQHf5ljo7tQBtM1kvcqR7nqib+FctagGOtXP5Q5lxQ6q4ox4OYJdrT4tFL0kt4w9cs+mR7QpQp3sXesIwwVFMyYaPxYElNDyJTWeZSbkzP1FgDDSIxgHryx9YCuDBcNukOSazmzBEQAAAAA=",alt:""})}),"\n",(0,t.jsx)(n.p,{children:"试一下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const clickHandler: MouseEventHandler<HTMLDivElement> = (e) => {\n    const top = document.getElementById('box')!.getBoundingClientRect().top;\n\n    console.log('box pageY', e.pageY);\n    console.log('box clientY', e.clientY)\n    console.log('box offsetY', e.pageY - top - window.pageYOffset);\n    console.log('box screenY', e.screenY);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:T,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"因为 getBoundingClientRect 返回的数值是更精确的小数，所以算出来的也是小数。"}),"\n",(0,t.jsx)(n.p,{children:"还有，这里的 window.pageYOffset 过时了，简易换成 window.scrollY，是一样的："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:E,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:v,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:w,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"当然，你也可以访问原生事件对象，拿到 offsetY 属性："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"此外，窗口的滚动距离用 window.scrollY 获取，那元素也有滚动条呢？"}),"\n",(0,t.jsx)(n.p,{children:"元素内容的滚动距离用 element.scrollTop 获取。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { MouseEventHandler, useEffect, useRef } from 'react'\n\nfunction App() {\n  const ref = useRef<HTMLDivElement>(null);\n\n  const clickHandler: MouseEventHandler<HTMLDivElement> = (e) => {\n    console.log(ref.current?.scrollTop);\n  }\n\n  return (\n    <div>\n      <div id=\"box\" ref={ref} style={{\n        marginTop: '800px',\n        width: '100px',\n        height: '100px',\n        background: 'ping',\n        overflow: 'auto'\n      }} onClick={clickHandler}>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n      </div>\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"给 box 加一些内容，设置 overflow:auto。"}),"\n",(0,t.jsx)(n.p,{children:"试一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这就是元素的 scrollTop。"}),"\n",(0,t.jsx)(n.p,{children:"此外，元素还有 offsetTop 和 clientTop 属性："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef } from 'react'\n\nfunction App() {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    console.log('offsetTop', ref.current?.offsetTop);\n    console.log('clientTop', ref.current?.clientTop);\n  }, []);\n\n  return (\n    <div>\n      <div style={\n        {\n          position: 'relative',\n          margin: '100px',\n          padding: '200px',\n          border: '1px solid blue'\n        }\n      }>\n        <div id=\"box\" ref={ref} style={{\n          border: '20px solid #000',\n          width: '100px',\n          height: '100px',\n          background: 'pink',\n        }}>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"box 外层添加一个 div，margin 为 100px，padding 为 200px。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，clientTop 也就是上边框的高度 20px。"}),"\n",(0,t.jsx)(n.p,{children:"offsetTop 是距离最近的有 position 属性（relative 或 absolute 或 fixed）的元素的距离。"}),"\n",(0,t.jsx)(n.p,{children:"所以是 200px。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"注释掉就是 301px 了，这时候就是相对于文档顶部，所以是 200px padding+ 1px border + 100px margin。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:g,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"offsetTop 相对于哪个元素，那个元素就是 offsetParent。"}),"\n",(0,t.jsx)(n.p,{children:"还可以递归累加到 offsetParent 的 offsetTop，直到 offsetParent 为 null，也就是到了根元素，这时候算出来的就是元素到根元素的 offsetTop："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef } from 'react'\n\nfunction App() {\n  const ref = useRef<HTMLDivElement>(null);\n\n  function getTotalOffsetTop(element: HTMLElement) {\n    let totalOffsetTop =0;\n    while (element) {\n      totalOffsetTop += element.offsetTop;\n      element = element.offsetParent as HTMLElement;\n    }\n    return totalOffsetTop;\n  }\n\n  useEffect(() => {\n    console.log('offsetTop', ref.current?.offsetTop);\n    console.log('clientTop', ref.current?.clientTop);\n\n    console.log('totol offsetTop', getTotalOffsetTop(ref.current!))\n      \n  }, []);\n\n  return (\n    <div>\n      <div style={\n        {\n          position: 'relative',\n          margin: '100px',\n          padding: '200px',\n          border: '1px solid blue'\n        }\n      }>\n        <div id=\"box\" ref={ref} style={{\n          border: '20px solid #000',\n          width: '100px',\n          height: '100px',\n          background: 'pink',\n        }}>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"但是你会发现它少计算了 border 的宽度："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"因为 offsetTop 元素顶部到 offsetParent 内容部分的距离，不包括 border。"}),"\n",(0,t.jsx)(n.p,{children:"这时候加上 clientTop 就可以了，它就是上边框的高度。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function getTotalOffsetTop(element: HTMLElement) {\n    let totalOffsetTop = 0;\n    while (element) {\n      if(totalOffsetTop > 0) {\n        totalOffsetTop += element.clientTop;\n      }\n      totalOffsetTop += element.offsetTop;\n      element = element.offsetParent as HTMLElement;\n    }\n    return totalOffsetTop;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:a,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这里有两个 clientTop，当前元素的 clientTop 不用加："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"综上，当鼠标事件触发时，可以通过 pageY、clientY、screenY、offsetY 来计算位置，也可以通过元素的 getBoundingClientRect 和 scrollTop、offsetTop、clientTop 等来算，结合 window.scrollY。"}),"\n",(0,t.jsx)(n.p,{children:"这里 clientY 和 getBoundingClientRect().top 也要区分下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"一个是元素距离可视区域顶部的距离，一个是鼠标事件触发位置到可视区域顶部的距离。"}),"\n",(0,t.jsx)(n.p,{children:"比如页面是否滚动到底部，就可以通过 document.documentElement.scrollTop + window.innerHeihgt 和 document.documentElement.scrollHeight 对比。"}),"\n",(0,t.jsx)(n.p,{children:"这里有涉及到了几个新的属性。"}),"\n",(0,t.jsx)(n.p,{children:"根元素 documentElement 的 scrollTop 就是 window.scrollY："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后 window.innerHeight、window.innerWidth 是窗口的宽高，也就是可视区域的宽高。"}),"\n",(0,t.jsx)(n.p,{children:"至于 scrollHeight，这是元素的包含滚动区域的高度。"}),"\n",(0,t.jsx)(n.p,{children:"类似的有 clientHeight、offsetHeight、getBoundingClient().height 这几个高度要区分下："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { MouseEventHandler, useEffect, useRef } from 'react'\n\nfunction App() {\n  const ref = useRef<HTMLDivElement>(null);\n\n  const clickHandler: MouseEventHandler<HTMLDivElement> = (e) => {\n    console.log('clentHeight', ref.current?.clientHeight);\n    console.log('scrollHeight', ref.current?.scrollHeight);\n    console.log('offsetHeight', ref.current?.offsetHeight);\n    console.log('clent rect height', ref.current?.getBoundingClientRect().height);\n  }\n\n  return (\n    <div>\n      <div id=\"box\" ref={ref} style={{\n        border: '10px solid #000',\n        marginTop: '300px',\n        width: '100px',\n        height: '100px',\n        background: 'pink',\n        overflow: 'auto'\n      }} onClick={clickHandler}>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n      </div>\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:"试一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"clientHeight 是内容区域的高度，不包括 border。"}),"\n",(0,t.jsx)(n.p,{children:"offsetHeight 包括 border。"}),"\n",(0,t.jsx)(n.p,{children:"scrollHeight 是滚动区域的总高度，不包括 border。"}),"\n",(0,t.jsx)(n.p,{children:"那看起来 getBoundingClientRect().height 和 offsetHeight 一模一样？"}),"\n",(0,t.jsx)(n.p,{children:"绝大多数情况下是的。"}),"\n",(0,t.jsx)(n.p,{children:"但你旋转一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"就不一样了："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"getBoundingClientRect 拿到的包围盒的高度，而 offsetHeight 是元素本来的高度。"}),"\n",(0,t.jsx)(n.p,{children:"所以，对于滚动到页面底部的判断，就可以用 window.scrollY + window.innerHeight 和 document.documentElement.scrollHeight 对比。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useRef } from 'react'\n\nfunction App() {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    window.addEventListener('scroll', () => {\n      console.log(window.scrollY + window.innerHeight, document.documentElement.scrollHeight);\n    })\n  }, []);\n\n  return (\n    <div>\n      <div id=\"box\" ref={ref} style={{\n        border: '10px solid #000',\n        marginTop: '800px',\n        width: '100px',\n        height: '100px',\n        background: 'pink',\n        overflow: 'auto',\n        transform: 'rotate(45deg)'\n      }}>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n        <p>xxxxx</p>\n      </div>\n    </div>\n  )\n}\n\nexport default App\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这样，浏览器里的各种距离和宽高我们就过了一遍。"}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"浏览器里计算位置、宽高、判断一些交互，都需要用到距离、宽高的属性。"}),"\n",(0,t.jsx)(n.p,{children:"这类属性比较多，我们整体过了一遍："}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"e.pageY：鼠标距离文档顶部的距离"}),"\n",(0,t.jsx)(n.li,{children:"e.clientY：鼠标距离可视区域顶部的距离"}),"\n",(0,t.jsx)(n.li,{children:"e.offsetY：鼠标距离触发事件元素顶部的距离"}),"\n",(0,t.jsx)(n.li,{children:"e.screenY：鼠标距离屏幕顶部的距离"}),"\n",(0,t.jsx)(n.li,{children:"winwodw.scrollY：页面滚动的距离，也叫 window.pageYOffset，等同于 document.documentElement.scrollTop"}),"\n",(0,t.jsx)(n.li,{children:"element.scrollTop：元素滚动的距离"}),"\n",(0,t.jsx)(n.li,{children:"element.clientTop：上边框高度"}),"\n",(0,t.jsx)(n.li,{children:"element.offsetTop：相对有 position 的父元素的内容顶部的距离，可以递归累加，加上 clientTop，算出到文档顶部的距离"}),"\n",(0,t.jsx)(n.li,{children:"clientHeight：内容高度，不包括边框"}),"\n",(0,t.jsx)(n.li,{children:"offsetHeight：包含边框的高度"}),"\n",(0,t.jsx)(n.li,{children:"scrollHeight：滚动区域的高度，不包括边框"}),"\n",(0,t.jsx)(n.li,{children:"window.innerHeight：窗口的高度"}),"\n",(0,t.jsx)(n.li,{children:"element.getBoundingClientRect：拿到 width、height、top、left 属性，其中 top、left 是元素距离可视区域的距离，width、height 绝大多数情况下等同 offsetHeight、offsetWidth，但旋转之后就不一样了，拿到的是包围盒的宽高"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"其中，还要注意 react 的合成事件没有 offsetY 属性，可以自己算，react-use 的 useMouse 的 hook 就是自己算的，也可以用 e.nativeEvent.offsetY 来拿到。"}),"\n",(0,t.jsx)(n.p,{children:"掌握这些宽高、距离属性，就足够处理各种需要计算位置、宽高的需求了。"})]})}function P(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(D,{...e})}):D(e)}let L=P;P.__RSPRESS_PAGE_META={},P.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC20%E7%AB%A0%E2%80%94%E5%9B%BE%E8%A7%A3%E7%BD%91%E9%A1%B5%E7%9A%84%E5%90%84%E7%A7%8D%E8%B7%9D%E7%A6%BB.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第20章—图解网页的各种距离",headingTitle:"第20章—图解网页的各种距离",frontmatter:{}}}}]);