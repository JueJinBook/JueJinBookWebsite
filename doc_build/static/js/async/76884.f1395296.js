"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["76884"],{199621:function(e,n,s){s.r(n),s.d(n,{default:()=>f});var r=s(552676),c=s(740453);let d=s.p+"static/image/6121e8da88f5082e202694ab5b9a0efe.a260bdb0.webp",i=s.p+"static/image/c37c2dd014a9e91950b306b918ad4c3a.976b39f4.webp",a=s.p+"static/image/70f83e2026d1f70790223ddaab64794c.07231ad4.webp",t=s.p+"static/image/6829bbd3503d4ef995714df681ccef3c.6c7308b5.webp",o=s.p+"static/image/d477d0a69124bac39d4ce7ac8483fa5d.dbb8d463.webp",l=s.p+"static/image/a2edc6e2b0c5e2945f84a1349b677a0a.badfb4b1.webp",h=s.p+"static/image/9dba866d723432c9c12513a6f56096cb.5892fc51.webp",x=s.p+"static/image/c1de4e7b4f6730829701b5f64a9a716f.8b238f9e.webp",j=s.p+"static/image/10cc9cbea97ce0aa017d99154a3e8d7f.ede3bdbf.webp",p=s.p+"static/image/ea426a896b51fb61c85d2fb9912e9369.e1253a68.webp";function m(e){let n=Object.assign({h2:"h2",a:"a",p:"p",code:"code",h4:"h4",ul:"ul",li:"li",pre:"pre",img:"img",strong:"strong"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h2,{id:"前言",children:["前言",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"React"})," 技术栈的 ",(0,r.jsx)(n.code,{children:"UI"})," 组件库相比 ",(0,r.jsx)(n.code,{children:"Vue"}),"，会少一些。我们耳熟能详的便是 ",(0,r.jsx)(n.code,{children:"Antd"}),"，但是它针对的是 ",(0,r.jsx)(n.code,{children:"PC"})," 端的，我们的项目目前是一个 ",(0,r.jsx)(n.code,{children:"H5"})," 的网页（不排除后期做一个 PC 端）。所以我选择了 ",(0,r.jsx)(n.a,{href:"/https:https://zarm.gitee.io/#/",children:"Zarm"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["这里再次强调，不是 ",(0,r.jsx)(n.code,{children:"Zarm"})," 就比别的移动端组件库好，只是目前我开发的这款记账本项目，",(0,r.jsx)(n.code,{children:"Zarm"})," 比较适合。"]}),"\n",(0,r.jsxs)(n.h4,{id:"知识点",children:["知识点",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#知识点",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["构架工具 ",(0,r.jsx)(n.code,{children:"Vite"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["前端框架 ",(0,r.jsx)(n.code,{children:"React"})," 和路由 ",(0,r.jsx)(n.code,{children:"react-router-dom"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"CSS"})," 预加载器 ",(0,r.jsx)(n.code,{children:"Less"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"HTTP"})," 请求库 ",(0,r.jsx)(n.code,{children:"axios"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["移动端分辨率适配 ",(0,r.jsx)(n.code,{children:"flexible"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"跨域代理。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"初始化-vite--react-项目",children:["初始化 Vite + React 项目",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化-vite--react-项目",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Vite"})," 官方提供两种初始化项目的方式，一种是如下所示，可以自由选择需要的前端框架。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm init @vitejs/app\n"})}),"\n",(0,r.jsx)(n.p,{children:"另一种则是直接用官方提供的模板，一键生成项目："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# 13.前端实战：Vite 2.0 + React + ZarmUI 搭建前端 H5 开发环境\nnpm init @vitejs/app react-vite-h5 --template react\n\n# npm 7+, 需要额外的双横线：\nnpm init @vitejs/app react-vite-h5 -- --template react\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们使用第二种方式初始化项目，如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["安装完 ",(0,r.jsx)(n.code,{children:"node_modules"})," 之后，通过 ",(0,r.jsx)(n.code,{children:"npm run dev"})," 启动项目，如下所示代表成功了："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"引入路由插件-react-router-dom",children:["引入路由插件 react-router-dom",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#引入路由插件-react-router-dom",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"没有路由的项目，那就不是一个完整项目，而是一个页面而已。真实项目都是存在各种模块之间的切换，各个模块的功能组合在一起才能叫做一个项目。"}),"\n",(0,r.jsxs)(n.p,{children:["首选安装 ",(0,r.jsx)(n.code,{children:"react-router-dom"}),"，指令如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i react-router-dom -S\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在项目 ",(0,r.jsx)(n.code,{children:"src"})," 目录下新增 ",(0,r.jsx)(n.code,{children:"container"})," 目录用于放置页面组件，再在 ",(0,r.jsx)(n.code,{children:"container"})," 下新增两个目录分别是 ",(0,r.jsx)(n.code,{children:"Index"})," 和 ",(0,r.jsx)(n.code,{children:"About"})," ，添加如下内容："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Index/index.jsx\nimport React from 'react'\n\nexport default function Index() {\n  return <div>\n    Index\n  </div>\n}\n\n// About/index.jsx\nimport React from 'react'\n\nexport default function About() {\n  return <div>\n    About\n  </div>\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["再来新建 ",(0,r.jsx)(n.code,{children:"src/router/index.js"})," 配置路由数组，添加如下内容："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// router/index.js\nimport Index from '../container/Index'\nimport About from '../container/About'\n\nconst routes = [\n  {\n    path: \"/\",\n    component: Index\n  },\n  {\n    path: \"/about\",\n    component: About\n  }\n];\n\nexport default routes\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"App.jsx"})," 引入路由配置，实现切换浏览器路径，显示相应的组件："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// App.jsx\nimport React, { useState } from 'react'\nimport {\n  BrowserRouter as Router,\n  Routes,\n  Route\n} from \"react-router-dom\"\nimport routes from '../src/router'\nfunction App() {\n  return <>\n     <Routes>\n      {routes.map(route => <Route exact key={route.path} path={route.path} element={<route.component />} />)}\n     </Routes>\n   </>\n}\n\nexport default App\n"})}),"\n",(0,r.jsxs)(n.p,{children:["启动项目 ",(0,r.jsx)(n.code,{children:"npm run dev"}),"，如下图所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"引入-zarm-ui-组件库",children:["引入 Zarm UI 组件库",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#引入-zarm-ui-组件库",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"首先通过如下指令安装它："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm install zarm -S\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"App.jsx"})," 的代码，全局引入样式和中文包："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React, { useState } from 'react'\nimport {\n  BrowserRouter as Router,\n  Routes,\n  Route\n} from \"react-router-dom\"\n\nimport { ConfigProvider } from 'zarm'\nimport zhCN from 'zarm/lib/config-provider/locale/zh_CN'\nimport 'zarm/dist/zarm.css'\n\nimport routes from '../src/router'\nfunction App() {\n  return <Router>\n    <ConfigProvider primaryColor={'#007fff'} locale={zhCN}>\n      <>\n       <Routes>\n        {routes.map(route => <Route exact key={route.path} path={route.path} element={<route.component />} />)}\n       </Routes>\n      </>\n    </ConfigProvider>\n  </Router>\n}\n\nexport default App\n"})}),"\n",(0,r.jsxs)(n.p,{children:["此时 ",(0,r.jsx)(n.code,{children:"zarm"})," 的样式，已经全局引入了，我们先查看在 ",(0,r.jsx)(n.code,{children:"/container/Index/index.jsx"})," 添加一个按钮是否生效："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Index/index.jsx\nimport React from 'react'\nimport { Button } from 'zarm'\n\nexport default function Index() {\n  return <div>\n    Index\n    <Button theme='primary'>按钮</Button>\n  </div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"重启项目，如下所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"此时恭喜你\uD83C\uDF89，你已经成功将组件引入项目中。"}),"\n",(0,r.jsxs)(n.h4,{id:"小优化",children:["小优化",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小优化",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"组件虽然引入成功了，但是有一个问题，我不希望所有的组件样式都被一次性的引入，因为这样代码会比较冗余，我只需要引入我使用到的组件样式，实现「按需引入」。"}),"\n",(0,r.jsxs)(n.p,{children:["我们先看看，就目前现在这个情况，打完包之后，静态资源有多大。运行指令 ",(0,r.jsx)(n.code,{children:"npm run build"})," ，如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["腚眼一看，全局引入样式的形式，直接打完包， ",(0,r.jsx)(n.code,{children:"css"})," 静态资源就 ",(0,r.jsx)(n.code,{children:"168.22kb"})," 了，我们尝试配置「按需引入」。"]}),"\n",(0,r.jsx)(n.p,{children:"首先我们安装一个插件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i vite-plugin-style-import -D\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后在 ",(0,r.jsx)(n.code,{children:"vite.config.js"})," 配置文件内添加如下内容："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["打完包之后，肉眼可见，",(0,r.jsx)(n.code,{children:"css"})," 提及从 ",(0,r.jsx)(n.code,{children:"168.22kb"})," -> ",(0,r.jsx)(n.code,{children:"35.22kb"}),"。这种方式也是前端性能优化的其中一种。"]}),"\n",(0,r.jsxs)(n.h2,{id:"配置-css-预处理器-less",children:["配置 CSS 预处理器 Less",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#配置-css-预处理器-less",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["项目中采用的 ",(0,r.jsx)(n.code,{children:"Less"})," 作为 ",(0,r.jsx)(n.code,{children:"CSS"})," 预处理器，它能设置变量以及一些嵌套逻辑，便于项目的样式编写。"]}),"\n",(0,r.jsxs)(n.p,{children:["安装 ",(0,r.jsx)(n.code,{children:"less"})," 插件包，",(0,r.jsx)(n.code,{children:"npm i less -D"}),"，因为上述配置我们使用的是 ",(0,r.jsx)(n.code,{children:"less"}),"，并且我们需要配置 ",(0,r.jsx)(n.code,{children:"javascriptEnabled 为 true"}),"，支持 ",(0,r.jsx)(n.code,{children:"less"})," 内联 ",(0,r.jsx)(n.code,{children:"JS"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"vite.config.js"}),"，如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"{\n  plugins: [...]\n  css: {\n    modules: {\n      localsConvention: 'dashesOnly'\n    },\n    preprocessorOptions: {\n      less: {\n        // 支持内联 JavaScript\n        javascriptEnabled: true,\n      }\n    }\n  },\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["并且添加了 ",(0,r.jsx)(n.code,{children:"css modules"})," 配置，这样我们就不用担心在项目中，自定义的样式重名的风险，我们尝试在 ",(0,r.jsx)(n.code,{children:"/container/Index"})," 目录下添加样式文件 ",(0,r.jsx)(n.code,{children:"style.module.less"}),"，并且在 ",(0,r.jsx)(n.code,{children:"/container/Index/index.jsx"})," 中引入它，如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:".index {\n  span {\n    color: red;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// Index/index.jsx\nimport React from 'react'\nimport { Button } from 'zarm'\n\nimport s from './style.module.less'\n\nexport default function Index() {\n  return <div className={s.index}>\n    <span>样式</span>\n    <Button theme='primary'>按钮</Button>\n  </div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["此时我只能再次恭喜你，",(0,r.jsx)(n.code,{children:"Less"})," 成功被引入。"]}),"\n",(0,r.jsxs)(n.h2,{id:"移动端项目适配-rem",children:["移动端项目适配 rem",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#移动端项目适配-rem",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"移动端项目，肯定是需要适配各种分辨率屏幕的，就比如你 10px 的宽度，在每个屏幕上的占比都是不一样的，我们这里不对分辨率做深入的探讨，我们目前的首要目的是完成项目移动端的分辨率适配。"}),"\n",(0,r.jsxs)(n.p,{children:["首先我们需要安装 ",(0,r.jsx)(n.code,{children:"lib-flexible"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i lib-flexible -S\n"})}),"\n",(0,r.jsxs)(n.p,{children:["并在 ",(0,r.jsx)(n.code,{children:"main.jsx"})," 中引入它："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import React from 'react'\nimport ReactDOM from 'react-dom'\nimport 'lib-flexible/flexible'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["然后再安装一个 ",(0,r.jsx)(n.code,{children:"postcss-pxtorem"}),"，它的作用是在你编写完 ",(0,r.jsx)(n.code,{children:"css"})," 后，将你的单位自动转化为 ",(0,r.jsx)(n.code,{children:"rem"})," 单位。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"npm i postcss-pxtorem\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在项目根目录新建 ",(0,r.jsx)(n.code,{children:"postcss.config.js"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// postcss.config.js\n// 用 vite 创建项目，配置 postcss 需要使用 post.config.js，之前使用的 .postcssrc.js 已经被抛弃\n// 具体配置可以去 postcss-pxtorem 仓库看看文档\nmodule.exports = {\n  \"plugins\": [\n    require(\"postcss-pxtorem\")({\n      rootValue: 37.5,\n      propList: ['*'],\n      selectorBlackList: ['.norem'] // 过滤掉.norem-开头的class，不进行rem转换\n    })\n  ]\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["修改 ",(0,r.jsx)(n.code,{children:"Index/style.module.less"}),"："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:".index {\n  width: 200px;\n  height: 200px;\n  background: green;\n  span {\n    color: red;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["重启项目 ",(0,r.jsx)(n.code,{children:"npm run dev"}),"，如下所示："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到，",(0,r.jsx)(n.code,{children:"200px"})," 已经被转化为 ",(0,r.jsx)(n.code,{children:"5.3333rem"}),"，我们设置的 ",(0,r.jsx)(n.code,{children:"rootValue"})," 是 ",(0,r.jsx)(n.code,{children:"37.5"}),"，你可以换算一下 ",(0,r.jsx)(n.code,{children:"5.33333 * 37.5 = 200"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["我们目前把浏览器调整成的是 ",(0,r.jsx)(n.code,{children:"iphone 6"}),"，",(0,r.jsx)(n.code,{children:"html"})," 的 ",(0,r.jsx)(n.code,{children:"font-size"})," 为 ",(0,r.jsx)(n.code,{children:"37.5px"}),"，当我们手机变成其他尺寸的时候，这个 ",(0,r.jsx)(n.code,{children:"font-size"})," 的值也会变化，这是 ",(0,r.jsx)(n.code,{children:"flexible"})," 起到的作用，动态的变化 ",(0,r.jsx)(n.code,{children:"html"})," 的 ",(0,r.jsx)(n.code,{children:"font-size"})," 的值，从而让 ",(0,r.jsx)(n.code,{children:"1rem"})," 所对应的  ",(0,r.jsx)(n.code,{children:"px"})," 值一直都是动态适应变化的。"]}),"\n",(0,r.jsxs)(n.p,{children:["当我切换成 ",(0,r.jsx)(n.code,{children:"iphone 6 plus"})," 时："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["变成了 ",(0,r.jsx)(n.code,{children:"41.4px"}),"，而相应的，我们 ",(0,r.jsx)(n.code,{children:"div"})," 还是 ",(0,r.jsx)(n.code,{children:"5.33333rem"}),"，所以此时 ",(0,r.jsx)(n.code,{children:"div"})," 宽度就变大了，但是手机的屏幕宽度也变大了，这就不会影响视觉上的比例误差太大。"]}),"\n",(0,r.jsxs)(n.h2,{id:"二次封装-axios",children:["二次封装 axios",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二次封装-axios",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["说到这里，那就要涉及到项目的服务端 ",(0,r.jsx)(n.code,{children:"API"})," 接口，我们在前面的章节里，已经完成了服务端的代码编写，但是此时我们的服务端项目是跑在 ",(0,r.jsx)(n.code,{children:"http://127.0.0.1/7001"})," 端口上的。"]}),"\n",(0,r.jsxs)(n.p,{children:["此时你是可以在后续的请求中，使用 ",(0,r.jsx)(n.code,{children:"http://127.0.0.1/7001"})," 作为项目的 ",(0,r.jsx)(n.code,{children:"baseURL"}),"。但是照顾到有些同学没有启动服务端项目，直奔前端项目来的。这里我已经将接口提前部署到了线上环境，供大家使用。接口地址是 ",(0,r.jsx)(n.code,{children:"http://api.chennick.wang"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"所以在后续的封装过程中，我会提醒大家两种使用。"}),"\n",(0,r.jsxs)(n.p,{children:["首先我们安装 ",(0,r.jsx)(n.code,{children:"npm i axios -S"}),"，在 ",(0,r.jsx)(n.code,{children:"src"})," 目录下新建 ",(0,r.jsx)(n.code,{children:"utils"})," 目录，并新建 ",(0,r.jsx)(n.code,{children:"axios.js"})," 脚本："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// src/utils/axios.js\nimport axios from 'axios'\nimport { Toast } from 'zarm'\n\nconst MODE = import.meta.env.MODE // 环境变量\n\naxios.defaults.baseURL = MODE == 'development' ? '/api' : 'http://api.chennick.wang'\naxios.defaults.withCredentials = true\naxios.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'\naxios.defaults.headers['Authorization'] = `${localStorage.getItem('token') || null}`\naxios.defaults.headers.post['Content-Type'] = 'application/json'\n\naxios.interceptors.response.use(res => {\n  if (typeof res.data !== 'object') {\n    Toast.show('服务端异常！')\n    return Promise.reject(res)\n  }\n  if (res.data.code != 200) {\n    if (res.data.msg) Toast.show(res.data.msg)\n    if (res.data.code == 401) {\n      window.location.href = '/login'\n    }\n    return Promise.reject(res.data)\n  }\n\n  return res.data\n})\n\nexport default axios\n"})}),"\n",(0,r.jsx)(n.p,{children:"我逐行为大家分析上述代码的情况情况。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const MODE = import.meta.env.MODE\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"MODE"})," 是一个环境变量，通过 ",(0,r.jsx)(n.code,{children:"Vite"})," 构建的项目中，环境变量在项目中，可以通过 ",(0,r.jsx)(n.code,{children:"import.meta.env.MODE"})," 获取，环境变量的作用就是判断当前代码运行在开发环境还是生产环境。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"axios.defaults.baseURL = 'development' ? '/api' : 'http://api.chennick.wang'\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"baseURL"})," 是 ",(0,r.jsx)(n.code,{children:"axios"})," 的配置项，它的作用就是设置请求的基础路径，后续我们会在项目实战中有所体现。配置基础路径的好处就是，当请求地址修改的时候，可以在此统一配置。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"axios.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'\naxios.defaults.headers['Authorization'] = `${localStorage.getItem('token') || null}`\naxios.defaults.headers.post['Content-Type'] = 'application/json'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["上述三个配置是用于请求头的设置，",(0,r.jsx)(n.code,{children:"Authorization"})," 是我们在服务端鉴权的时候用到的，我们在前端设置好 ",(0,r.jsx)(n.code,{children:"token"}),"，服务端通过获取请求头中的  ",(0,r.jsx)(n.code,{children:"token"})," 去验证每一次请求是否合法。"]}),"\n",(0,r.jsxs)(n.p,{children:["最后一行是配置 ",(0,r.jsx)(n.code,{children:"post"})," 请求是，使用的请求体，这里默认设置成 ",(0,r.jsx)(n.code,{children:"application/json"})," 的形式。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"axios.interceptors.response.use(res => {\n  if (typeof res.data !== 'object') {\n    Toast.show('服务端异常！')\n    return Promise.reject(res)\n  }\n  if (res.data.code != 200) {\n    if (res.data.msg) Toast.show(res.data.msg)\n    if (res.data.code == 401) {\n      window.location.href = '/login'\n    }\n    return Promise.reject(res.data)\n  }\n\n  return res.data\n})\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"interceptors"})," 为拦截器，拦截器的作用是帮你拦截每一次请求，你可以在回调函数中做一些“手脚”，再将数据 ",(0,r.jsx)(n.code,{children:"return"})," 回去。上述代码就是拦截了响应内容，统一判断请求内容，如果非 200，则提示错误信息，",(0,r.jsx)(n.code,{children:"401"})," 的话，就是没有登录的用户，默认跳到 ",(0,r.jsx)(n.code,{children:"/login"})," 页面。如果是正常的响应，则 ",(0,r.jsx)(n.code,{children:"retrun res.data"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["最后我们将这个 ",(0,r.jsx)(n.code,{children:"axios"})," 抛出，供页面组件请求使用。"]}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"utils"})," 下新建一个 ",(0,r.jsx)(n.code,{children:"index.js"}),"，内容如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import axios from './axios'\n\nexport const get = axios.get\n\nexport const post = axios.post\n"})}),"\n",(0,r.jsx)(n.p,{children:"这样获取的时候，能少写几行代码，能少写点就少写点。"}),"\n",(0,r.jsxs)(n.h2,{id:"代理配置",children:["代理配置",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代理配置",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"baseURL"})," 为什么在 ",(0,r.jsx)(n.code,{children:"development"})," 环境下，用 ",(0,r.jsx)(n.code,{children:"/api"})," 这样的请求地址。其实它就是为了代理请求而配置的。"]}),"\n",(0,r.jsx)(n.p,{children:"这样配置完后，在请求接口的时候，请求地址大概长这样："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/api/userInfo\n"})}),"\n",(0,r.jsxs)(n.p,{children:["于是我们需要去配置代理，打开 ",(0,r.jsx)(n.code,{children:"vite.config.js"}),"，添加如下代码："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"server: {\n  proxy: {\n    '/api': {\n      // 当遇到 /api 路径时，将其转换成 target 的值\n      target: 'http://api.chennick.wang/api/',\n      changeOrigin: true,\n      rewrite: path => path.replace(/^\\/api/, '') // 将 /api 重写为空\n    }\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["这样配置完之后，开发环境下，",(0,r.jsx)(n.code,{children:"/api/userInfo"})," -> ",(0,r.jsx)(n.code,{children:"http://api.chennick.wang/api/userInfo"}),"。这样就解决了大家老大难的跨域问题。"]}),"\n",(0,r.jsx)(n.p,{children:"但是其实服务端只要设置好白名单，就不会有这样那样的跨域问题。"}),"\n",(0,r.jsxs)(n.h2,{id:"resolvealias-别名设置",children:["resolve.alias 别名设置",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#resolvealias-别名设置",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["这里我们必须得设置好别名，否则在页面中，你会写出很长一串类似这样的代码 ",(0,r.jsx)(n.code,{children:"../../../"}),"。"]}),"\n",(0,r.jsxs)(n.p,{children:["打开 ",(0,r.jsx)(n.code,{children:"vite.config.js"}),"，添加配置如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"...\nimport path from 'path'\n\nexport default defineConfig({\n  ...\n  resolve: {\n    alias: {\n      '@': path.resolve(__dirname, 'src'), // src 路径\n      'utils': path.resolve(__dirname, 'src/utils') // src 路径\n    }\n  },\n})\n"})}),"\n",(0,r.jsx)(n.p,{children:"此时我们便可以修改之前的代码如下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"router/index.js"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import Index from '@/container/Index'\nimport About from '@/container/About'\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"App.jsx"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import routes from '@/router'\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["行文至此，我们的基础开发环境已经搭建完毕，涉及构建工具、前端框架、",(0,r.jsx)(n.code,{children:"UI"})," 组件库、",(0,r.jsx)(n.code,{children:"HTTP"})," 请求库、",(0,r.jsx)(n.code,{children:"CSS"})," 预加载器、跨域代理、移动端分辨率适配，这些知识都是一个合格的前端工程师应该具备的，所以请大家加油，将他们都通通拿下。"]})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}let f=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["Node%20%2B%20React%20%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E%200%20%E5%88%B0%201%20%E5%AE%9E%E7%8E%B0%E8%AE%B0%E8%B4%A6%E6%9C%AC%2F13.%E5%89%8D%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9AVite%202.0%20%2B%20React%20%2B%20ZarmUI%20%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%20H5%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"知识点",id:"知识点",depth:4},{text:"初始化 Vite + React 项目",id:"初始化-vite--react-项目",depth:2},{text:"引入路由插件 react-router-dom",id:"引入路由插件-react-router-dom",depth:2},{text:"引入 Zarm UI 组件库",id:"引入-zarm-ui-组件库",depth:2},{text:"小优化",id:"小优化",depth:4},{text:"配置 CSS 预处理器 Less",id:"配置-css-预处理器-less",depth:2},{text:"移动端项目适配 rem",id:"移动端项目适配-rem",depth:2},{text:"二次封装 axios",id:"二次封装-axios",depth:2},{text:"代理配置",id:"代理配置",depth:2},{text:"resolve.alias 别名设置",id:"resolvealias-别名设置",depth:2},{text:"总结",id:"总结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);