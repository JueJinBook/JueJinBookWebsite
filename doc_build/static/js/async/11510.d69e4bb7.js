"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["11510"],{836291:function(n,e,c){c.r(e),c.d(e,{default:()=>x});var l=c(552676),s=c(740453);let o=c.p+"static/image/b7f856628f8c60c0fd3698cb0e9b2dde.3a4483c9.webp",r=c.p+"static/image/aa685b52353b7755e5f73408a59d1a83.12ad9749.webp",a=c.p+"static/image/6c32ff25844103b50a411aae3ed71c76.78a3637c.webp",i=c.p+"static/image/ee5462c2ab4ab94ebfff7e45a8a68264.c3c1b663.webp",d=c.p+"static/image/4cfe670f1f66ad8c6f31115e5737ea05.c3744c0b.webp",t=c.p+"static/image/cd4438825544b1fe7e7152f6ce568714.b9155e0b.webp";function h(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",code:"code",pre:"pre",img:"img",blockquote:"blockquote",ol:"ol",strong:"strong"},(0,s.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.h1,{id:"23插件架构hook-体系是如何影响-webpack-架构的",children:["23.插件架构：Hook 体系是如何影响 Webpack 架构的？",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#23插件架构hook-体系是如何影响-webpack-架构的",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"Webpack 之所以能够应对 Web 场景下极度复杂、多样的构建需求，关键就在于其健壮、扩展性极强的插件架构，而插件架构的精髓又在于其灵活多变的 Hook 体系，可以说，只有真正掌握 Hook 底层设计与实现逻辑，深入理解不同 Hook 的运行特性与用法，才能灵活处理各种问题，更快更好地编写出 Webpack 插件。"}),"\n",(0,l.jsx)(e.p,{children:"本文将聚焦在 Webpack Hook 底层的 Tapable 框架，详细枚举了 Tapable 提供的钩子及各类型钩子的特点、运行逻辑、实现原理，并进一步讨论 Tapable 框架在 Webpack 的作用，进而揭示 Webpack 插件架构的核心逻辑。阅读本文，你将："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"深入了解 Hook 类型，以及不同类型的特点、运行特性；"}),"\n",(0,l.jsx)(e.li,{children:"理解如何识别 Webpack 特定钩子类型，正确调用处理。"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"tapable-全解析",children:["Tapable 全解析",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#tapable-全解析",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"网上不少资料将 Webpack 的插件架构归类为“事件/订阅”模式，我认为这种归纳有失偏颇。订阅模式是一种松耦合架构，发布器只是在特定时机发布事件消息，订阅者并不或者很少与事件直接发生交互，举例来说，我们平常在使用 HTML 事件的时候很多时候只是在这个时机触发业务逻辑，很少调用上下文操作。"}),"\n",(0,l.jsxs)(e.p,{children:["而 Webpack 的插件体系是一种基于 ",(0,l.jsx)(e.a,{href:"https://github.com/webpack/tapable",target:"_blank",rel:"noopener noreferrer",children:"Tapable"})," 实现的强耦合架构，它在特定时机触发钩子时会附带上足够的上下文信息，插件定义的钩子回调中，能也只能与这些上下文背后的数据结构、接口交互产生 side effect，进而影响到编译状态和后续流程。"]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.a,{href:"https://github.com/webpack/tapable",target:"_blank",rel:"noopener noreferrer",children:"Tapable"})," 是 Webpack 插件架构的核心支架，但它的代码量其实很少，本质上就是围绕着 ",(0,l.jsx)(e.code,{children:"订阅/发布"})," 模式叠加各种特化逻辑，适配 Webpack 体系下复杂的事件源-处理器之间交互需求，比如："]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"有些场景需要支持将前一个处理器的结果传入下一个回调处理器；"}),"\n",(0,l.jsx)(e.li,{children:"有些场景需要支持异步并行调用这些回调处理器。"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"先简单看看 Tapable 的用法："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { SyncHook } = require("tapable");\n\n// 1. 创建钩子实例\nconst sleep = new SyncHook();\n\n// 2. 调用订阅接口注册回调\nsleep.tap("test", () => {\n  console.log("callback A");\n});\n\n// 3. 调用发布接口触发回调\nsleep.call();\n\n// 运行结果：\n// callback A\n'})}),"\n",(0,l.jsx)(e.p,{children:"使用 Tapable 时通常需要经历三个步骤："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"创建钩子实例，如上例第 4 行；"}),"\n",(0,l.jsxs)(e.li,{children:["调用订阅接口注册回调，包括：",(0,l.jsx)(e.code,{children:"tap"}),"、",(0,l.jsx)(e.code,{children:"tapAsync"}),"、",(0,l.jsx)(e.code,{children:"tapPromise"}),"，如上例第 7 行；"]}),"\n",(0,l.jsxs)(e.li,{children:["调用发布接口触发回调，包括：",(0,l.jsx)(e.code,{children:"call"}),"、",(0,l.jsx)(e.code,{children:"callAsync"}),"、",(0,l.jsx)(e.code,{children:"promise"}),"，如上例第 12 行。"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["Webpack 内部的钩子大体上都遵循上面三个步骤，只是在某些钩子中还可以使用异步风格的 ",(0,l.jsx)(e.code,{children:"tapAsync/callAsync"}),"、promise 风格 ",(0,l.jsx)(e.code,{children:"tapPromise/promise"}),"，具体使用哪一类函数与钩子类型有关。"]}),"\n",(0,l.jsxs)(e.h2,{id:"hook-类型汇总",children:["Hook 类型汇总",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#hook-类型汇总",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"Tabable 提供如下类型的钩子："}),"\n",(0,l.jsx)(e.p,{children:"类型虽多，但整体遵循两种分类规则："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["按回调逻辑，分为：","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["基本类型，名称不带 ",(0,l.jsx)(e.code,{children:"Waterfall/Bail/Loop"})," 关键字：与通常 ",(0,l.jsx)(e.code,{children:"订阅/回调"})," 模式相似，按钩子注册顺序，逐次调用回调；"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"waterfall"})," 类型：前一个回调的返回值会被带入下一个回调；"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"bail"})," 类型：逐次调用回调，若有任何一个回调返回非 ",(0,l.jsx)(e.code,{children:"undefined"})," 值，则终止后续调用；"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"loop"})," 类型：逐次、循环调用，直到所有回调函数都返回 ",(0,l.jsx)(e.code,{children:"undefined"})," 。"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["按执行回调的并行方式，分为：","\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"sync"})," ：同步执行，启动后会按次序逐个执行回调，支持 ",(0,l.jsx)(e.code,{children:"call/tap"})," 调用语句；"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"async"})," ：异步执行，支持传入 callback 或 promise 风格的异步回调函数，支持 ",(0,l.jsx)(e.code,{children:"callAsync/tapAsync"})," 、",(0,l.jsx)(e.code,{children:"promise/tapPromise"})," 两种调用语句。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["所有钩子都可以按名称套进这两条规则里面，对插件开发者来说不同类型的钩子会直接影响到回调函数的写法，以及插件与其他插件的互通关系，但是有一些基本能力、概念是通用的：",(0,l.jsx)(e.code,{children:"tap/call"}),"、",(0,l.jsx)(e.code,{children:"intercept"}),"、",(0,l.jsx)(e.code,{children:"context"}),"、动态编译等。"]}),"\n",(0,l.jsx)(e.p,{children:"接下来展开详细介绍每种钩子的特点与执行逻辑。"}),"\n",(0,l.jsxs)(e.h2,{id:"synchook-钩子",children:[(0,l.jsx)(e.code,{children:"SyncHook"})," 钩子",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#synchook-钩子",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"SyncHook"})," 算的上是简单的钩子了，触发后会按照注册的顺序逐个调用回调，且不关心这些回调的返回值，底层逻辑大致如下述代码："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function syncCall() {\n  const callbacks = [fn1, fn2, fn3];\n  for (let i = 0; i < callbacks.length; i++) {\n    const cb = callbacks[i];\n    cb();\n  }\n}\n"})}),"\n",(0,l.jsx)(e.p,{children:"举个例子："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { SyncHook } = require("tapable");\n\nclass Somebody {\n  constructor() {\n    this.hooks = {\n      sleep: new SyncHook(),\n    };\n  }\n  sleep() {\n    //   触发回调\n    this.hooks.sleep.call();\n  }\n}\n\nconst person = new Somebody();\n\n// 注册回调\nperson.hooks.sleep.tap("test", () => {\n  console.log("callback A");\n});\nperson.hooks.sleep.tap("test", () => {\n  console.log("callback B");\n});\nperson.hooks.sleep.tap("test", () => {\n  console.log("callback C");\n});\n\nperson.sleep();\n// 输出结果：\n// callback A\n// callback B\n// callback C\n'})}),"\n",(0,l.jsxs)(e.p,{children:["示例中，",(0,l.jsx)(e.code,{children:"Somebody"})," 初始化时声明了一个 ",(0,l.jsx)(e.code,{children:"sleep"})," 钩子，并在后续调用 ",(0,l.jsx)(e.code,{children:"sleep.tap"})," 函数连续注册三次回调，在调用 ",(0,l.jsx)(e.code,{children:"person.sleep()"})," 语句触发 ",(0,l.jsx)(e.code,{children:"sleep.call"})," 之后，tapable 会按照注册的先后按序执行三个回调。"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,l.jsxs)(e.p,{children:["上述示例中，触发回调时用到了钩子的 ",(0,l.jsx)(e.code,{children:"call"})," 函数，我们也可以选择异步风格的 ",(0,l.jsx)(e.code,{children:"callAsync"})," ，选用 ",(0,l.jsx)(e.code,{children:"call"})," 或 ",(0,l.jsx)(e.code,{children:"callAsync"})," 并不会影响回调的执行逻辑：按注册顺序依次执行 + 忽略回调执行结果，两者唯一的区别是 ",(0,l.jsx)(e.code,{children:"callAsync"})," 需要传入 ",(0,l.jsx)(e.code,{children:"callback"})," 函数，用于处理回调队列可能抛出的异常："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"// call 风格\ntry {\n  this.hooks.sleep.call();\n} catch (e) {\n    // 错误处理逻辑\n}\n// callAsync 风格\nthis.hooks.sleep.callAsync((err) => {\n  if (err) {\n    // 错误处理逻辑\n  }\n});\n"})}),"\n",(0,l.jsxs)(e.p,{children:["由于调用方式不会 Hook 本身的规则，所以对使用者来说，无需关心底层到底用的是 ",(0,l.jsx)(e.code,{children:"call"})," 还是 ",(0,l.jsx)(e.code,{children:"callAsync"}),"，上面的例子只需要做简单的修改就可以适配 ",(0,l.jsx)(e.code,{children:"callAsync"})," 场景："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { SyncHook } = require("tapable");\n\nclass Somebody {\n  constructor() {\n    this.hooks = {\n      sleep: new SyncHook(),\n    };\n  }\n  sleep() {\n    //   触发回调\n    this.hooks.sleep.callAsync((err) => {\n      if (err) {\n        console.log(`interrupt with "${err.message}"`);\n      }\n    });\n  }\n}\n\nconst person = new Somebody();\n\n// 注册回调\nperson.hooks.sleep.tap("test", (cb) => {\n  console.log("callback A");\n  throw new Error("我就是要报错");\n});\n// 第一个回调出错后，后续回调不会执行\nperson.hooks.sleep.tap("test", () => {\n  console.log("callback B");\n});\n\nperson.sleep();\n\n// 输出结果：\n// callback A\n// interrupt with "我就是要报错"\n'})}),"\n",(0,l.jsxs)(e.h2,{id:"syncbailhook-钩子",children:[(0,l.jsx)(e.code,{children:"SyncBailHook"})," 钩子",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#syncbailhook-钩子",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"bail"})," 单词有熔断的意思，而 ",(0,l.jsx)(e.code,{children:"bail"})," 类型钩子的特点是在回调队列中，若任一回调返回了非 ",(0,l.jsx)(e.code,{children:"undefined"})," 的值，则中断后续处理，直接返回该值，用一段伪代码来表示："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function bailCall() {\n  const callbacks = [fn1, fn2, fn3];\n  for (let i in callbacks) {\n    const cb = callbacks[i];\n    const result = cb(lastResult);\n    // 如果有任意一个回调返回结果，则停止调用剩下的回调\n    if (result !== undefined) {\n      // 熔断\n      return result;\n    }\n  }\n  return undefined;\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"SyncBailHook"})," 的调用顺序与规则都跟 ",(0,l.jsx)(e.code,{children:"SyncHook"})," 相似，主要区别一是 ",(0,l.jsx)(e.code,{children:"SyncBailHook"})," 增加了熔断逻辑，例如："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { SyncBailHook } = require("tapable");\n\nclass Somebody {\n  constructor() {\n    this.hooks = {\n      sleep: new SyncBailHook(),\n    };\n  }\n  sleep() {\n    return this.hooks.sleep.call();\n  }\n}\n\nconst person = new Somebody();\n\n// 注册回调\nperson.hooks.sleep.tap("test", () => {\n  console.log("callback A");\n  // 熔断点\n  // 返回非 undefined 的任意值都会中断回调队列\n  return \'返回值：tecvan\'\n});\nperson.hooks.sleep.tap("test", () => {\n  console.log("callback B");\n});\n\nconsole.log(person.sleep());\n\n// 运行结果：\n// callback A\n// 返回值：tecvan\n'})}),"\n",(0,l.jsxs)(e.p,{children:["其次，相比于 ",(0,l.jsx)(e.code,{children:"SyncHook"})," ，",(0,l.jsx)(e.code,{children:"SyncBailHook"})," 运行结束后，会将熔断值返回给call函数，例如上例第20行， ",(0,l.jsx)(e.code,{children:"callback A"})," 返回的 ",(0,l.jsx)(e.code,{children:"返回值：tecvan"})," 会成为 ",(0,l.jsx)(e.code,{children:"this.hooks.sleep.call"})," 的调用结果。"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"在 Webpack 中被如何使用"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"SyncBailHook"})," 通常用在发布者需要关心订阅回调运行结果的场景， Webpack 内部有接近 100 个地方用到这种钩子，举个例子： ",(0,l.jsx)(e.code,{children:"compiler.hooks.shouldEmit"}),"，对应的 call 语句："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"class Compiler {\n  run(callback) {\n    //   ...\n\n    const onCompiled = (err, compilation) => {\n      if (this.hooks.shouldEmit.call(compilation) === false) {\n        // ...\n      }\n    };\n  }\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:["此处 Webpack 会根据 ",(0,l.jsx)(e.code,{children:"shouldEmit"})," 钩子的运行结果确定是否执行后续的操作，其它场景也有相似逻辑，如："]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"NormalModuleFactory.hooks.createModule"})," ：预期返回新建的 Module 对象；"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"Compilation.hooks.needAdditionalSeal"})," ：预期返回 bool 值，判定是否进入 ",(0,l.jsx)(e.code,{children:"unseal"})," 状态；"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"Compilation.hooks.optimizeModules"})," ：预期返回 bool 值，用于判定是否继续执行优化操作。"]}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"syncwaterfallhook-钩子",children:[(0,l.jsx)(e.code,{children:"SyncWaterfallHook"})," 钩子",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#syncwaterfallhook-钩子",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"waterfall"})," 钩子的执行逻辑跟 lodash 的 ",(0,l.jsx)(e.code,{children:"flow"})," 函数有点像，大致上就是将前一个函数的返回值作为参数传入下一个函数，逻辑如下："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function waterfallCall(arg) {\n  const callbacks = [fn1, fn2, fn3];\n  let lastResult = arg;\n  for (let i in callbacks) {\n    const cb = callbacks[i];\n    // 上次执行结果作为参数传入下一个函数\n    lastResult = cb(lastResult);\n  }\n  return lastResult;\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:["理解上述逻辑后，",(0,l.jsx)(e.code,{children:"SyncWaterfallHook"})," 的特点也就很明确了："]}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"上一个函数的结果会被带入下一个函数；"}),"\n",(0,l.jsxs)(e.li,{children:["最后一个回调的结果会作为 ",(0,l.jsx)(e.code,{children:"call"})," 调用的结果返回。"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"例如："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { SyncWaterfallHook } = require("tapable");\n\nclass Somebody {\n  constructor() {\n    this.hooks = {\n      sleep: new SyncWaterfallHook(["msg"]),\n    };\n  }\n  sleep() {\n    return this.hooks.sleep.call("hello");\n  }\n}\n\nconst person = new Somebody();\n\n// 注册回调\nperson.hooks.sleep.tap("test", (arg) => {\n  console.log(`call 调用传入： ${arg}`);\n  return "tecvan";\n});\n\nperson.hooks.sleep.tap("test", (arg) => {\n  console.log(`A 回调返回： ${arg}`);\n  return "world";\n});\n\nconsole.log("最终结果：" + person.sleep());\n// 运行结果：\n// call 调用传入： hello\n// A 回调返回： tecvan\n// 最终结果：world\n'})}),"\n",(0,l.jsxs)(e.p,{children:["示例中，",(0,l.jsx)(e.code,{children:"sleep"})," 钩子为 ",(0,l.jsx)(e.code,{children:"SyncWaterfallHook"})," 类型，之后注册了两个回调，从处理结果可以看到，第一个回调收到的 ",(0,l.jsx)(e.code,{children:"arg = hello"})," ，即第10行 call 调用时传入的参数；第二个回调收到的是第一个回调返回的结果 ",(0,l.jsx)(e.code,{children:"tecvan"}),"；之后 ",(0,l.jsx)(e.code,{children:"call"})," 调用返回的是第二个回调的结果 ",(0,l.jsx)(e.code,{children:"world"})," 。"]}),"\n",(0,l.jsxs)(e.p,{children:["使用时，",(0,l.jsx)(e.code,{children:"SyncWaterfallHook"})," 钩子有一些注意事项："]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["初始化时必须提供参数，例如上例 ",(0,l.jsx)(e.code,{children:'new SyncWaterfallHook(["msg"])'})," 构造函数中，必须传入参数 ",(0,l.jsx)(e.code,{children:'["msg"]'})," ，用于动态编译 ",(0,l.jsx)(e.code,{children:"call"})," 的参数依赖，后面我们会讲到 ",(0,l.jsx)(e.strong,{children:"动态编译"})," 的细节；"]}),"\n",(0,l.jsxs)(e.li,{children:["发布调用 ",(0,l.jsx)(e.code,{children:"call"})," 时，需要传入初始参数。"]}),"\n"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"在 Webpack 中被如何使用"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"SyncWaterfallHook"})," 在 Webpack 中总共出现了 50+次，其中比较有代表性的例子是 ",(0,l.jsx)(e.code,{children:"NormalModuleFactory.hooks.factory"})," ，在 Webpack 内部实现中，会在这个钩子内根据资源类型 ",(0,l.jsx)(e.code,{children:"resolve"})," 出对应的 ",(0,l.jsx)(e.code,{children:"module"})," 对象："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'class NormalModuleFactory {\n  constructor() {\n    this.hooks = {\n      factory: new SyncWaterfallHook(["filename", "data"]),\n    };\n\n    this.hooks.factory.tap("NormalModuleFactory", () => (result, callback) => {\n      let resolver = this.hooks.resolver.call(null);\n\n      if (!resolver) return callback();\n\n      resolver(result, (err, data) => {\n        if (err) return callback(err);\n\n        // direct module\n        if (typeof data.source === "function") return callback(null, data);\n\n        // ...\n      });\n    });\n  }\n\n  create(data, callback) {\n    //   ...\n    const factory = this.hooks.factory.call(null);\n    // ...\n  }\n}\n'})}),"\n",(0,l.jsxs)(e.p,{children:["大致上就是在创建模块，通过 ",(0,l.jsx)(e.code,{children:"factory"})," 钩子将 ",(0,l.jsx)(e.code,{children:"module"})," 的创建过程外包出去，在钩子回调队列中依据 ",(0,l.jsx)(e.code,{children:"waterfall"})," 的特性逐步推断出最终的 ",(0,l.jsx)(e.code,{children:"module"})," 对象。"]}),"\n",(0,l.jsxs)(e.h2,{id:"syncloophook-钩子",children:[(0,l.jsx)(e.code,{children:"SyncLoopHook"})," 钩子",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#syncloophook-钩子",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"loop"})," 型钩子的特点是循环执行，直到所有回调都返回 ",(0,l.jsx)(e.code,{children:"undefined"})," ，不过这里循环的维度是单个回调函数，例如有回调队列 ",(0,l.jsx)(e.code,{children:"[fn1, fn2, fn3]"})," ，",(0,l.jsx)(e.code,{children:"loop"})," 钩子先执行 ",(0,l.jsx)(e.code,{children:"fn1"})," ，如果此时 ",(0,l.jsx)(e.code,{children:"fn1"})," 返回了非 ",(0,l.jsx)(e.code,{children:"undefined"})," 值，则继续执行 ",(0,l.jsx)(e.code,{children:"fn1"})," 直到返回 ",(0,l.jsx)(e.code,{children:"undefined"})," 后，才向前推进执行 ",(0,l.jsx)(e.code,{children:"fn2"})," 。伪代码："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function loopCall() {\n  const callbacks = [fn1, fn2, fn3];\n  for (let i in callbacks) {\n    const cb = callbacks[i];\n    // 重复执行\n    while (cb() !== undefined) {}\n  }\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:["由于 ",(0,l.jsx)(e.code,{children:"loop"})," 钩子循环执行的特性，使用时务必十分注意，避免陷入死循环。示例："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { SyncLoopHook } = require("tapable");\n\nclass Somebody {\n  constructor() {\n    this.hooks = {\n      sleep: new SyncLoopHook(),\n    };\n  }\n  sleep() {\n    return this.hooks.sleep.call();\n  }\n}\n\nconst person = new Somebody();\nlet times = 0;\n\n// 注册回调\nperson.hooks.sleep.tap("test", (arg) => {\n  ++times;\n  console.log(`第 ${times} 次执行回调A`);\n  if (times < 4) {\n    return times;\n  }\n});\n\nperson.hooks.sleep.tap("test", (arg) => {\n  console.log(`执行回调B`);\n});\n\nperson.sleep();\n// 运行结果\n// 第 1 次执行回调A\n// 第 2 次执行回调A\n// 第 3 次执行回调A\n// 第 4 次执行回调A\n// 执行回调B\n'})}),"\n",(0,l.jsxs)(e.p,{children:["可以看到示例中一直在执行回调 A，直到满足判定条件 ",(0,l.jsx)(e.code,{children:"times >= 4"})," ，A 返回 ",(0,l.jsx)(e.code,{children:"undefined"})," 后，才开始执行回调B。"]}),"\n",(0,l.jsxs)(e.p,{children:["虽然 Tapable 提供了 ",(0,l.jsx)(e.code,{children:"SyncLoopHook"})," 钩子，但 Webpack 源码中并没有使用到，所以大家理解用法就行，不用深究。"]}),"\n",(0,l.jsxs)(e.h2,{id:"asyncserieshook-钩子",children:[(0,l.jsx)(e.code,{children:"AsyncSeriesHook"})," 钩子",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#asyncserieshook-钩子",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["前面这些以 ",(0,l.jsx)(e.code,{children:"Sync"})," 开头的都是同步风格的钩子，执行逻辑相对简单，但不支持异步回调，所以 Tapable 还提供了一系列 ",(0,l.jsx)(e.code,{children:"Async"})," 开头的异步钩子，支持在回调函数中执行异步操作，执行逻辑比较复杂。"]}),"\n",(0,l.jsxs)(e.p,{children:["例如 ",(0,l.jsx)(e.code,{children:"AsyncSeriesHook"}),"，它有这样一些特点："]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["支持异步回调，可以在回调函数中写 ",(0,l.jsx)(e.code,{children:"callback"})," 或 ",(0,l.jsx)(e.code,{children:"promise"})," 风格的异步操作；"]}),"\n",(0,l.jsx)(e.li,{children:"回调队列依次执行，前一个执行结束后，才会开始执行下一个；"}),"\n",(0,l.jsxs)(e.li,{children:["与 ",(0,l.jsx)(e.code,{children:"SyncHook"})," 一样，不关心回调的执行结果。"]}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"用一段伪代码来表示："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function asyncSeriesCall(callback) {\n  const callbacks = [fn1, fn2, fn3];\n  //   执行回调 1\n  fn1((err1) => {\n    if (err1) {\n      callback(err1);\n    } else {\n      //   执行回调 2\n      fn2((err2) => {\n        if (err2) {\n          callback(err2);\n        } else {\n          //   执行回调 3\n          fn3((err3) => {\n            if (err3) {\n              callback(err2);\n            }\n          });\n        }\n      });\n    }\n  });\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:["先来看一个 ",(0,l.jsx)(e.code,{children:"callback"})," 风格的示例："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { AsyncSeriesHook } = require("tapable");\n\nconst hook = new AsyncSeriesHook();\n\n// 注册回调\nhook.tapAsync("test", (cb) => {\n  console.log("callback A");\n  setTimeout(() => {\n    console.log("callback A 异步操作结束");\n    // 回调结束时，调用 cb 通知 tapable 当前回调已结束\n    cb();\n  }, 100);\n});\n\nhook.tapAsync("test", () => {\n  console.log("callback B");\n});\n\nhook.callAsync();\n// 运行结果：\n// callback A\n// callback A 异步操作结束\n// callback B\n'})}),"\n",(0,l.jsxs)(e.p,{children:["从代码输出结果可以看出，A 回调内部的 ",(0,l.jsx)(e.code,{children:"setTimeout"})," 执行完毕调用 ",(0,l.jsx)(e.code,{children:"cb"})," 函数，",(0,l.jsx)(e.code,{children:"tapable"})," 才认为当前回调执行完毕，开始执行 B 回调。"]}),"\n",(0,l.jsxs)(e.p,{children:["除了 ",(0,l.jsx)(e.code,{children:"callback"})," 风格外，也可以使用 promise 风格调用 ",(0,l.jsx)(e.code,{children:"tap/call"})," 函数，改造上例："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { AsyncSeriesHook } = require("tapable");\n\nconst hook = new AsyncSeriesHook();\n\n// 注册回调\nhook.tapPromise("test", () => {\n  console.log("callback A");\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      console.log("callback A 异步操作结束");\n      resolve();\n    }, 100);\n  });\n});\n\nhook.tapPromise("test", () => {\n  console.log("callback B");\n  return Promise.resolve();\n});\n\nhook.promise();\n// 运行结果：\n// callback A\n// callback A 异步操作结束\n// callback B\n'})}),"\n",(0,l.jsx)(e.p,{children:"有三个改动点："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["将 ",(0,l.jsx)(e.code,{children:"tapAsync"})," 更改为 ",(0,l.jsx)(e.code,{children:"tapPromise"}),"；"]}),"\n",(0,l.jsx)(e.li,{children:"Tap 回调需要返回 promise 对象，如上例第 8 行；"}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"callAsync"})," 调用更改为 ",(0,l.jsx)(e.code,{children:"promise"}),"。"]}),"\n"]}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"在 Webpack 中被如何使用"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"AsyncSeriesHook"})," 钩子在 Webpack 中总共出现了 30+ 次，相对来说都是一些比较容易理解的时机，比如在构建完毕后触发 ",(0,l.jsx)(e.code,{children:"compiler.hooks.done"})," 钩子，用于通知单次构建已经结束："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"class Compiler {\n  run(callback) {\n    if (err) return finalCallback(err);\n\n    this.emitAssets(compilation, (err) => {\n      if (err) return finalCallback(err);\n\n      if (compilation.hooks.needAdditionalPass.call()) {\n        // ...\n        this.hooks.done.callAsync(stats, (err) => {\n          if (err) return finalCallback(err);\n\n          this.hooks.additionalPass.callAsync((err) => {\n            if (err) return finalCallback(err);\n            this.compile(onCompiled);\n          });\n        });\n        return;\n      }\n\n      this.emitRecords((err) => {\n        if (err) return finalCallback(err);\n\n        // ...\n        this.hooks.done.callAsync(stats, (err) => {\n          if (err) return finalCallback(err);\n          return finalCallback(null, stats);\n        });\n      });\n    });\n  }\n}\n"})}),"\n",(0,l.jsxs)(e.h2,{id:"asyncparallelhook-钩子",children:[(0,l.jsx)(e.code,{children:"AsyncParallelHook"})," 钩子",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#asyncparallelhook-钩子",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["与 ",(0,l.jsx)(e.code,{children:"AsyncSeriesHook"})," 类似，",(0,l.jsx)(e.code,{children:"AsyncParallelHook"})," 也支持异步风格的回调，不过 ",(0,l.jsx)(e.code,{children:"AsyncParallelHook"})," 是以并行方式，同时执行回调队列里面的所有回调，逻辑上近似于："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"function asyncParallelCall(callback) {\n  const callbacks = [fn1, fn2];\n  // 内部维护了一个计数器\n  var _counter = 2;\n\n  var _done = function() {\n    _callback();\n  };\n  if (_counter <= 0) return;\n  // 按序执行回调\n  var _fn0 = callbacks[0];\n  _fn0(function(_err0) {\n    if (_err0) {\n      if (_counter > 0) {\n        // 出错时，忽略后续回调，直接退出\n        _callback(_err0);\n        _counter = 0;\n      }\n    } else {\n      if (--_counter === 0) _done();\n    }\n  });\n  if (_counter <= 0) return;\n  // 不需要等待前面回调结束，直接开始执行下一个回调\n  var _fn1 = callbacks[1];\n  _fn1(function(_err1) {\n    if (_err1) {\n      if (_counter > 0) {\n        _callback(_err1);\n        _counter = 0;\n      }\n    } else {\n      if (--_counter === 0) _done();\n    }\n  });\n}\n"})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"AsyncParallelHook"})," 钩子的特点："]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"支持异步风格；"}),"\n",(0,l.jsx)(e.li,{children:"并行执行回调队列，不需要做任何等待；"}),"\n",(0,l.jsxs)(e.li,{children:["与 ",(0,l.jsx)(e.code,{children:"SyncHook"})," 一样，不关心回调的执行结果。"]}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"实践应用",children:["实践应用",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实践应用",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"综上，Tapable 合计提供了 10 种钩子，支持同步、异步、熔断、循环、waterfall 等功能特性，以此支撑起 Webpack 复杂的构建需求。虽然多数情况下我们不需要手动调用 Tapable，但编写插件时可以借助这些知识，识别 Hook 类型与执行特性后，正确地调用，正确地实现交互。"}),"\n",(0,l.jsxs)(e.p,{children:["例如：对于 ",(0,l.jsx)(e.a,{href:"https://webpack.js.org/api/compiler-hooks/#done",target:"_blank",rel:"noopener noreferrer",children:"compiler.hooks.done"})," 钩子，官网介绍："]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,l.jsxs)(e.p,{children:["这是一个 ",(0,l.jsx)(e.code,{children:"AsyncSeriesHook"})," 钩子，意味着："]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["支持异步语法，我们可以用 ",(0,l.jsx)(e.code,{children:"tap/tapAsync/tapPromise"})," 方式注册回调；"]}),"\n",(0,l.jsx)(e.li,{children:"Webpack 会按照注册顺序串行执行回调；"}),"\n",(0,l.jsxs)(e.li,{children:["Webpack 不关心回调的返回值，但可以通过 ",(0,l.jsx)(e.code,{children:"callback"})," 函数传递 Error 信息。"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["又或者，对于 ",(0,l.jsx)(e.a,{href:"https://webpack.js.org/api/compilation-hooks/#optimizemodules",target:"_blank",rel:"noopener noreferrer",children:"compilation.hooks.optimizeChunkModules"})," 钩子，官网介绍："]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,l.jsxs)(e.p,{children:["这是一个 ",(0,l.jsx)(e.code,{children:"SyncBailHook"})," 钩子，因此："]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["不支持异步语法，我们只能用 ",(0,l.jsx)(e.code,{children:"tap"})," 注册回调；"]}),"\n",(0,l.jsx)(e.li,{children:"若任意回调有返回值，则中断 Hook 流程，后面回调不再执行，所以使用时需要谨慎。"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"其它 Hook 也能用类似方法，参照分析出钩子的应用技巧。"}),"\n",(0,l.jsxs)(e.blockquote,{children:["\n",(0,l.jsx)(e.p,{children:"提示：Webpack 官方文档并没有覆盖介绍所有钩子，必要时建议读者直接翻阅 Webpack 源码，分析钩子类型。"}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"hook-动态编译",children:["Hook 动态编译",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#hook-动态编译",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"至此，Webpack 中用到的 Hook 子类都已介绍完毕，不同 Hook 适用于不同场景，解决不同问题，而它们底层都基于 Tapable 的“动态编译”实现，可以说，理解了动态编译，也就掌握了 Tapable 的核心实现逻辑。"}),"\n",(0,l.jsxs)(e.p,{children:["动态编译是一个非常大胆的设计，不同 Hook 所谓的同步、异步、bail、waterfall、loop 等回调规则都是 Tapable 根据 Hook 类型、参数、回调队列等参数，调用 ",(0,l.jsx)(e.code,{children:"new Function"})," 语句动态拼装出一段控制执行流程的 JavaScript 代码实现控制的。例如："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { SyncHook } = require("tapable");\n\nconst sleep = new SyncHook();\n\nsleep.tap("test", () => {\n  console.log("callback A");\n});\nsleep.call();\n'})}),"\n",(0,l.jsxs)(e.p,{children:["调用 ",(0,l.jsx)(e.code,{children:"sleep.call"})," 时，Tapable 内部处理流程大致为："]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:a,alt:"image.png"})}),"\n",(0,l.jsx)(e.p,{children:"编译过程主要涉及三个实体："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"tapable/lib/SyncHook.js"})," ：定义 ",(0,l.jsx)(e.code,{children:"SyncHook"})," 的入口文件；"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"tapable/lib/Hook.js"})," ：",(0,l.jsx)(e.code,{children:"SyncHook"})," 只是一个代理接口，内部实际上调用了 ",(0,l.jsx)(e.code,{children:"Hook"})," 类，由 ",(0,l.jsx)(e.code,{children:"Hook"})," 负责实现钩子的逻辑（其它钩子也是一样的套路）；"]}),"\n",(0,l.jsxs)(e.li,{children:[(0,l.jsx)(e.code,{children:"tapable/lib/HookCodeFactory.js"})," ：动态编译出 ",(0,l.jsx)(e.code,{children:"call"}),"、",(0,l.jsx)(e.code,{children:"callAsync"}),"、",(0,l.jsx)(e.code,{children:"promise"})," 函数内容的工厂类，注意，其他钩子也都会用到 ",(0,l.jsx)(e.code,{children:"HookCodeFactory"})," 工厂函数。"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"SyncHook"})," （其他钩子类似)）调用 ",(0,l.jsx)(e.code,{children:"call"})," 后，",(0,l.jsx)(e.code,{children:"Hook"})," 基类收集上下文信息并调用 ",(0,l.jsx)(e.code,{children:"createCall"})," 及子类传入的 ",(0,l.jsx)(e.code,{children:"compiler"})," 函数；",(0,l.jsx)(e.code,{children:"compiler"})," 调用 ",(0,l.jsx)(e.code,{children:"HookCodeFactory"})," 进而使用 ",(0,l.jsx)(e.code,{children:"new Function"})," 方法动态拼接出回调执行函数。上面例子对应的生成函数："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'(function anonymous(\n) {\n"use strict";\nvar _context;\nvar _x = this._x;\nvar _fn0 = _x[0];\n_fn0();\n\n})\n'})}),"\n",(0,l.jsxs)(e.p,{children:["那么问题来了，通过 ",(0,l.jsx)(e.code,{children:"new Function"}),"、",(0,l.jsx)(e.code,{children:"eval"})," 等方式实现的动态编译，存在诸如性能、安全性等方面的问题，所以社区很少见到类似的设计，真的有必要用这种方式实现 Hook 吗？"]}),"\n",(0,l.jsxs)(e.p,{children:["这放在 ",(0,l.jsx)(e.code,{children:"SyncHook"})," 这种简单场景确实大可不必，但若是更复杂的 Hook，如 ",(0,l.jsx)(e.code,{children:"AsyncSeriesWaterfallHook"}),"："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { AsyncSeriesWaterfallHook } = require("tapable");\n\nconst sleep = new AsyncSeriesWaterfallHook(["name"]);\n\nsleep.tapAsync("test1", (name, cb) => {\n  console.log(`执行 A 回调： 参数 name=${name}`);\n  setTimeout(() => {\n    cb(undefined, "tecvan2");\n  }, 100);\n});\n\nsleep.tapAsync("test", (name, cb) => {\n  console.log(`执行 B 回调： 参数 name=${name}`);\n  setTimeout(() => {\n    cb(undefined, "tecvan3");\n  }, 100);\n});\n\nsleep.tapAsync("test", (name, cb) => {\n  console.log(`执行 C 回调： 参数 name=${name}`);\n  setTimeout(() => {\n    cb(undefined, "tecvan4");\n  }, 100);\n});\n\nsleep.callAsync("tecvan", (err, name) => {\n  console.log(`回调结束， name=${name}`);\n});\n\n// 运行结果：\n// 执行 A 回调： 参数 name=tecvan\n// 执行 B 回调： 参数 name=tecvan2\n// 执行 C 回调： 参数 name=tecvan3\n// 回调结束， name=tecvan4\n'})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"AsyncSeriesWaterfallHook"})," 的特点是异步 + 串行 + 前一个回调的返回值会传入下一个回调，对应生成函数："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'(function anonymous(name, _callback) {\n  "use strict";\n  var _context;\n  var _x = this._x;\n  function _next1() {\n    var _fn2 = _x[2];\n    _fn2(name, function(_err2, _result2) {\n      if (_err2) {\n        _callback(_err2);\n      } else {\n        if (_result2 !== undefined) {\n          name = _result2;\n        }\n        _callback(null, name);\n      }\n    });\n  }\n  function _next0() {\n    var _fn1 = _x[1];\n    _fn1(name, function(_err1, _result1) {\n      if (_err1) {\n        _callback(_err1);\n      } else {\n        if (_result1 !== undefined) {\n          name = _result1;\n        }\n        _next1();\n      }\n    });\n  }\n  var _fn0 = _x[0];\n  _fn0(name, function(_err0, _result0) {\n    if (_err0) {\n      _callback(_err0);\n    } else {\n      if (_result0 !== undefined) {\n        name = _result0;\n      }\n      _next0();\n    }\n  });\n});\n'})}),"\n",(0,l.jsx)(e.p,{children:"核心逻辑："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["生成函数将回调队列各个项封装为 ",(0,l.jsx)(e.code,{children:"_next0/_next1"})," 函数，这些 ",(0,l.jsx)(e.code,{children:"next"})," 函数内在逻辑高度相似；"]}),"\n",(0,l.jsx)(e.li,{children:"按回调定义的顺序，逐次执行，上一个回调结束后，才调用下一个回调，例如生成代码中的第39行、27行。"}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["相比于用递归、循环之类的手段实现 ",(0,l.jsx)(e.code,{children:"AsyncSeriesWaterfallHook"}),"，这段动态生成的函数逻辑确实会更清晰，更容易理解，这种场景下用动态编译，确实是一个不错的选择。"]}),"\n",(0,l.jsxs)(e.p,{children:["Tapable 提供的大多数特性都是基于 ",(0,l.jsx)(e.code,{children:"Hook + HookCodeFactory"})," 实现的，如果大家对此有兴趣，可以在 ",(0,l.jsx)(e.a,{href:"https://github1s.com/webpack/tapable/blob/master/lib/Hook.js#L12",target:"_blank",rel:"noopener noreferrer",children:"tapable/lib/Hook.js"})," 的 ",(0,l.jsx)(e.code,{children:"CALL_DELEGATE/CALL_ASYNC_DELEGATE/PROMISE_DELEGATE"})," 几个函数打断点："]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:r,alt:"image.png"})}),"\n",(0,l.jsxs)(e.p,{children:["之后，使用 ",(0,l.jsx)(e.a,{href:"https://github.com/GoogleChromeLabs/ndb",target:"_blank",rel:"noopener noreferrer",children:"ndb"})," 命令断点调试，查看动态编译出的代码："]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,l.jsxs)(e.h2,{id:"高级特性intercept",children:["高级特性：Intercept",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#高级特性intercept",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["除了通常的 ",(0,l.jsx)(e.code,{children:"tap/call"})," 之外，tapable 还提供了简易的中间件机制 —— ",(0,l.jsx)(e.code,{children:"intercept"})," 接口，例如"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const sleep = new SyncHook();\n\nsleep.intercept({\n  name: "test",\n  context: true,\n  call() {\n    console.log("before call");\n  },\n  loop(){\n    console.log("before loop");\n  },\n  tap() {\n    console.log("before each callback");\n  },\n  register() {\n    console.log("every time call tap");\n  },\n});\n'})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"intercept"})," 支持注册如下类型的中间件："]}),"\n",(0,l.jsxs)(e.p,{children:["其中 ",(0,l.jsx)(e.code,{children:"register"})," 在每次调用 ",(0,l.jsx)(e.code,{children:"tap"})," 时被调用；其他三种中间件的触发时机大致如下："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:"  var _context;\n  const callbacks = [fn1, fn2];\n  var _interceptors = this.interceptors;\n  // 调用 call 函数，立即触发\n  _interceptors.forEach((intercept) => intercept.call(_context));\n  var _loop;\n  var cursor = 0;\n  do {\n    _loop = false;\n    // 每次循环开始时触发 `loop`\n    _interceptors.forEach((intercept) => intercept.loop(_context));\n    // 触发 `tap`\n    var _fn0 = callbacks[0];\n    _interceptors.forEach((intercept) => intercept.tap(_context, _fn0));\n    var _result0 = _fn0();\n    if (_result0 !== undefined) {\n      _loop = true;\n    } else {\n      var _fn1 = callbacks[1];\n      // 再次触发 `tap`\n      _interceptors.forEach((intercept) => intercept.tap(_context, _fn1));\n      var _result1 = _fn1();\n      if (_result1 !== undefined) {\n        _loop = true;\n      }\n    }\n  } while (_loop);\n"})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"intercept"})," 特性在 Webpack 内主要被用作进度提示，如 ",(0,l.jsx)(e.code,{children:"Webpack/lib/ProgressPlugin.js"})," 插件中，分别对 ",(0,l.jsx)(e.code,{children:"compiler.hooks.emit"})," 、",(0,l.jsx)(e.code,{children:"compiler.hooks.afterEmit"})," 钩子应用了记录进度的中间件函数。其他类型的插件应用较少。"]}),"\n",(0,l.jsxs)(e.h2,{id:"高级特性hookmap",children:["高级特性：HookMap",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#高级特性hookmap",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["Tapable 还有一个值得注意的特性 —— ",(0,l.jsx)(e.code,{children:"HookMap"}),"，它提供了一种集合操作能力，能够降低创建与使用的复杂度，用法比较简单："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'const { SyncHook, HookMap } = require("tapable");\n\nconst sleep = new HookMap(() => new SyncHook());\n\n// 通过 for 函数过滤集合中的特定钩子\nsleep.for("statement").tap("test", () => {\n  console.log("callback for statement");\n});\n\n// 触发 statement 类型的钩子\nsleep.get("statement").call();\n'})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"HookMap"})," 能够用于实现的动态获取钩子功能，例如在 Webpack 的 ",(0,l.jsx)(e.code,{children:"lib/parser.js"})," 文件中，",(0,l.jsx)(e.code,{children:"parser"})," 文件主要完成将资源内容解析为 AST 集合，之后遍历 AST 并以 ",(0,l.jsx)(e.code,{children:"HookMap"})," 方式对外通知遍历到的内容。"]}),"\n",(0,l.jsxs)(e.p,{children:["例如，遇到表达式的时候触发 ",(0,l.jsx)(e.code,{children:"Parser.hooks.expression"})," 钩子，问题是 AST 结构和内容都很复杂，如果所有情景都以独立的钩子实现，那代码量会急剧膨胀。这种场景就很适合用 ",(0,l.jsx)(e.code,{children:"HookMap"})," 解决，以 ",(0,l.jsx)(e.code,{children:"expression"})," 为例："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'class Parser {\n  constructor() {\n    this.hooks = {\n      // 定义钩子\n      // 这里用到 HookMap ，所以不需要提前遍历枚举所有 expression 场景\n      expression: new HookMap(() => new SyncBailHook(["expression"])),\n    };\n  }\n\n  //   不同场景下触发钩子\n  walkMemberExpression(expression) {\n    const exprName = this.getNameForExpression(expression);\n    if (exprName && exprName.free) {\n      // 触发特定类型的钩子\n      const expressionHook = this.hooks.expression.get(exprName.name);\n      if (expressionHook !== undefined) {\n        const result = expressionHook.call(expression);\n        if (result === true) return;\n      }\n    }\n    // ...\n  }\n\n  walkThisExpression(expression) {\n    const expressionHook = this.hooks.expression.get("this");\n    if (expressionHook !== undefined) {\n      expressionHook.call(expression);\n    }\n  }\n}\n'})}),"\n",(0,l.jsxs)(e.p,{children:["上例代码第 15、25 行都通过 ",(0,l.jsx)(e.code,{children:"this.hooks.expression.get(xxx)"})," 语句动态获取对应钩子实例，之后再调用 ",(0,l.jsx)(e.code,{children:"call"})," 触发。HookMap 的消费逻辑与普通 Hook 类似，只需要增加 ",(0,l.jsx)(e.code,{children:"for"})," 函数过滤出你实际监听的 Hook 实例即可，如："]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-js",children:'// 钩子消费逻辑\n// 选取 CommonJsStuffPlugin 仅起示例作用\nclass CommonJsStuffPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\n      "CommonJsStuffPlugin",\n      (compilation, { normalModuleFactory }) => {\n        const handler = (parser, parserOptions) => {\n          // 通过 for 精确消费钩子\n          parser.hooks.expression\n            .for("require.main.require")\n            .tap(\n              "CommonJsStuffPlugin",\n              ParserHelpers.expressionIsUnsupported(\n                parser,\n                "require.main.require is not supported by Webpack."\n              )\n            );\n          parser.hooks.expression\n            .for("module.parent.require")\n            .tap(\n              "CommonJsStuffPlugin",\n              ParserHelpers.expressionIsUnsupported(\n                parser,\n                "module.parent.require is not supported by Webpack."\n              )\n            );\n          parser.hooks.expression\n            .for("require.main")\n            .tap(\n              "CommonJsStuffPlugin",\n              ParserHelpers.toConstantDependencyWithWebpackRequire(\n                parser,\n                "__Webpack_require__.c[__Webpack_require__.s]"\n              )\n            );\n          // ...\n        };\n      }\n    );\n  }\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"借助这种能力我们就不需要为每一种情况都单独创建 Hook，只需要在使用时动态创建、获取对应实例即可，能有效降低开发与维护成本。"}),"\n",(0,l.jsxs)(e.h2,{id:"总结",children:["总结",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"为了应对构建场景下各种复杂需求，Webpack 内部使用了多种类型的 Hook，分别用于实现同步、异步、熔断、串行、并行的流程逻辑，开发插件时需要注意识别 Hook 类型，据此做出正确的调用与交互逻辑。"}),"\n",(0,l.jsxs)(e.h2,{id:"思考题",children:["思考题",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,l.jsxs)(e.p,{children:["为什么 Webpack 内部需要这些不同类型的流程逻辑？比如，为什么需要 ",(0,l.jsx)(e.code,{children:"SyncBailHook"})," 这种具有熔断特性的钩子？适用于怎么样的场景？在我们日常业务开发中，能否复用这一类流程控制能力？"]})]})}function p(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(h,{...n})}):h(n)}let x=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F23.%E6%8F%92%E4%BB%B6%E6%9E%B6%E6%9E%84%EF%BC%9AHook%20%E4%BD%93%E7%B3%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%20Webpack%20%E6%9E%B6%E6%9E%84%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"Tapable 全解析",id:"tapable-全解析",depth:2},{text:"Hook 类型汇总",id:"hook-类型汇总",depth:2},{text:"`SyncHook` 钩子",id:"synchook-钩子",depth:2},{text:"`SyncBailHook` 钩子",id:"syncbailhook-钩子",depth:2},{text:"`SyncWaterfallHook` 钩子",id:"syncwaterfallhook-钩子",depth:2},{text:"`SyncLoopHook` 钩子",id:"syncloophook-钩子",depth:2},{text:"`AsyncSeriesHook` 钩子",id:"asyncserieshook-钩子",depth:2},{text:"`AsyncParallelHook` 钩子",id:"asyncparallelhook-钩子",depth:2},{text:"实践应用",id:"实践应用",depth:2},{text:"Hook 动态编译",id:"hook-动态编译",depth:2},{text:"高级特性：Intercept",id:"高级特性intercept",depth:2},{text:"高级特性：HookMap",id:"高级特性hookmap",depth:2},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"23.插件架构：Hook 体系是如何影响 Webpack 架构的？",headingTitle:"23.插件架构：Hook 体系是如何影响 Webpack 架构的？",frontmatter:{}}}}]);