"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55207"],{383478:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var t=r(552676),s=r(740453);let i=r.p+"static/image/3fe8d5d413dcf6776de7802940e51105.76c9a178.webp";function l(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",ul:"ul",li:"li",pre:"pre",code:"code",img:"img",strong:"strong"},(0,s.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"23全链路-typescript-工具库找到适合你的工具",children:["23.全链路 TypeScript 工具库，找到适合你的工具",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23全链路-typescript-工具库找到适合你的工具",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"在前面两节，我们了解了 TypeScript 在 React 与 ESLint 中的集成，而在实际项目开发时，我们还会接触许多与 TypeScript 相关的工具。如果按照作用场景来进行划分，这些工具大致可以划分为开发、校验、构建、类型四类。在这一节我们将介绍一批 TypeScript 工具库，讲解它们的基本使用，你可以在这里查找是否有符合你需求的工具。"}),"\n",(0,t.jsx)(n.p,{children:"本节的定位类似于 GitHub 上的 awesome-xxx 系列，我们更多是在简单介绍工具的作用与使用场景，不会有深入的讲解与分析。同时，本节的内容会持续更新，如果你还使用过其他好用的工具库，欢迎在评论区留言，我会随着更新不断收录更多的工具库。"}),"\n",(0,t.jsxs)(n.h2,{id:"开发阶段",children:["开发阶段",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#开发阶段",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这一部分的工具主要在项目开发阶段使用。"}),"\n",(0,t.jsxs)(n.h3,{id:"项目开发",children:["项目开发",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#项目开发",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/TypeStrong/ts-node",target:"_blank",rel:"noopener noreferrer",children:"ts-node"})," 与 ",(0,t.jsx)(n.a,{href:"https://github.com/wclr/ts-node-dev",target:"_blank",rel:"noopener noreferrer",children:"ts-node-dev"}),"：我们在环境搭建一节中已经介绍过，用于直接执行 .ts 文件。其中 ts-node-dev 基于 ts-node 和 node-dev（类似于 nodemon）封装，能够实现监听文件改动并重新执行文件的能力。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/gilamran/tsc-watch",target:"_blank",rel:"noopener noreferrer",children:"tsc-watch"}),"：它类似于 ts-node-dev，主要功能也是监听文件变化然后重新执行，但 tsc-watch 的编译过程更明显，也需要自己执行编译后的文件。你也可以通过 onSuccess 与 onFailure 参数，来在编译过程成功与失效时执行不同的逻辑。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'## 启动 tsc --watch，然后在成功时执行编译产物\ntsc-watch --onSuccess "node ./dist/server.js"\n\n## 在失败时执行\ntsc-watch --onFailure "echo \'Beep! Compilation Failed\'"\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/esbuild-kit/esno",target:"_blank",rel:"noopener noreferrer",children:"esno"}),"，antfu 的作品。核心能力同样是执行 .ts 文件，但底层是 ESBuild 而非 tsc，因此速度上会明显更快。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/typed-install",target:"_blank",rel:"noopener noreferrer",children:"typed-install"}),"，我们知道有些 npm 包的类型定义是单独的 ",(0,t.jsx)(n.code,{children:"@types/"})," 包，但我们并没办法分辨一个包需不需要额外的类型定义，有时安装了才发现没有还要再安装一次类型也挺烦躁的。typed-install 的功能就是在安装包时自动去判断这个包是否有额外的类型定义包，并为你自动地进行安装。其实我也写过一个类似的：",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/install-with-typing",target:"_blank",rel:"noopener noreferrer",children:"install-with-typing"}),"。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/kawamataryo/suppress-ts-errors",target:"_blank",rel:"noopener noreferrer",children:"suppress-ts-error"}),"，自动为项目中所有的类型报错添加 ",(0,t.jsx)(n.code,{children:"@ts-expect-error"})," 或 ",(0,t.jsx)(n.code,{children:"@ts-ignore"})," 注释，重构项目时很有帮助。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/mattpocock/ts-error-translator",target:"_blank",rel:"noopener noreferrer",children:"ts-error-translator"}),"，将 TS 报错翻译成更接地气的版本，并且会根据代码所在的上下文来详细说明报错原因，目前只有英文版本，中文版本感觉遥遥无期，因为 TS 的报错实在太多了……"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:i,alt:"image.png"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"代码生成",children:["代码生成",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码生成",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/JoshuaKGoldberg/TypeStat",target:"_blank",rel:"noopener noreferrer",children:"TypeStat"}),"，能够将 JavaScript 文件转化为 TypeScript 文件，并在这个过程中去尝试提取类型。同时它也能够修正 TypeScript 中的 ",(0,t.jsx)(n.code,{children:"--noImplicitAny"})," 以及 ",(0,t.jsx)(n.code,{children:"--noImplicitThis"})," 错误。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/usabilityhub/ts-auto-guard",target:"_blank",rel:"noopener noreferrer",children:"ts-auto-guard"}),"，还记得我们在类型工具中学习的，基于 is 的类型守卫吗？有时候手动编写能够匹配运行时值类型的类型守卫会比较累人，你可以使用这个工具来自动基于接口生成类型守卫："]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// my-project/Person.guard.ts\n\nimport { Person } from './Person'\n\nexport function isPerson(obj: unknown): obj is Person {\n  const typedObj = obj as Person\n  return (\n    typeof typedObj === 'object' &&\n    typeof typedObj['name'] === 'string' &&\n    (typeof typedObj['age'] === 'undefined' ||\n      typeof typedObj['age'] === 'number') &&\n    Array.isArray(typedObj['children']) &&\n    typedObj['children'].every(e => isPerson(e))\n  )\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/YousefED/typescript-json-schema",target:"_blank",rel:"noopener noreferrer",children:"typescript-json-schema"}),"，从 TypeScript 代码生成 JSON Schema，如以下代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export interface Shape {\n    /**\n     * The size of the shape.\n     *\n     * @minimum 0\n     * @TJS-type integer\n     */\n    size: number;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"会生成以下的 JSON Schema："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "$ref": "#/definitions/Shape",\n  "$schema": "http://json-schema.org/draft-07/schema#",\n  "definitions": {\n    "Shape": {\n      "properties": {\n        "size": {\n          "description": "The size of the shape.",\n          "minimum": 0,\n          "type": "integer"\n        }\n      },\n      "type": "object"\n    }\n  }\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/bcherny/json-schema-to-typescript",target:"_blank",rel:"noopener noreferrer",children:"json-schema-to-typescript"}),"，和上面那位反过来，从 JSON Schema 生成 TypeScript 代码："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "title": "Example Schema",\n  "type": "object",\n  "properties": {\n    "firstName": {\n      "type": "string"\n    },\n    "lastName": {\n      "type": "string"\n    },\n    "age": {\n      "description": "Age in years",\n      "type": "integer",\n      "minimum": 0\n    },\n    "hairColor": {\n      "enum": ["black", "brown", "blue"],\n      "type": "string"\n    }\n  },\n  "additionalProperties": false,\n  "required": ["firstName", "lastName"]\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export interface ExampleSchema {\n  firstName: string;\n  lastName: string;\n  /**\n   * Age in years\n   */\n  age?: number;\n  hairColor?: "black" | "brown" | "blue";\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["需要注意的是，JSON Schema 并不是我们常见到的。描述实际值的 JSON，它更像是 TS 类型那样的",(0,t.jsx)(n.strong,{children:"结构定义"}),"，存在着值类型、可选值、访问性等相关信息的描述，如 required、type、description 等字段，因此它才能够与 TypeScript 之间进行转换。"]}),"\n",(0,t.jsxs)(n.h2,{id:"类型相关",children:["类型相关",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型相关",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"以下工具库主要针对类型，包括提供通用工具类型与对工具类型进行测试。"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/sindresorhus/type-fest",target:"_blank",rel:"noopener noreferrer",children:"type-fest"}),"，不用多介绍了，目前 star 最多下载量最高的工具类型库，Sindre Sorhus 的作品，同时也是个人认为最接地气的一个工具类型库。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/piotrwitek/utility-types",target:"_blank",rel:"noopener noreferrer",children:"utility-types"}),"，包含的类型较少，但这个库是我类型编程的启蒙课，我们此前对 FunctionKeys、RequiredKeys 等工具类型的实现就来自于这个库。"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/ts-essentials",target:"_blank",rel:"noopener noreferrer",children:"ts-essentials"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/pelotom/type-zoo",target:"_blank",rel:"noopener noreferrer",children:"type-zoo"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/millsp/ts-toolbelt",target:"_blank",rel:"noopener noreferrer",children:"ts-toolbelt"}),"，目前包含工具类型数量最多的一位，基本上能满足你的所有需要。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/tsd",target:"_blank",rel:"noopener noreferrer",children:"tsd"}),"，用于进行类型层面的单元测试，即验证工具类型计算结果是否是符合预期的类型，也是 Sindre Sorhus 的作品，同时 type-fest 中工具类型的单元测试就是基于它。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/dsherret/conditional-type-checks",target:"_blank",rel:"noopener noreferrer",children:"conditional-type-checks"}),"，类似于 tsd，也是用于对类型进行单元测试。"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"校验阶段",children:["校验阶段",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#校验阶段",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"以下这些工具通常用于在项目逻辑中进行具有实际逻辑的校验（而不同于 tsd 仅在类型层面）。"}),"\n",(0,t.jsxs)(n.h3,{id:"逻辑校验",children:["逻辑校验",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑校验",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/colinhacks/zod",target:"_blank",rel:"noopener noreferrer",children:"zod"}),"，核心优势在于与 TypeScript 的集成，如能从 Schema 中直接提取出类型："]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { z } from "zod";\n\nconst User = z.object({\n  username: z.string(),\n});\n\nUser.parse({ username: "Ludwig" });\n\n// extract the inferred type\ntype User = z.infer<typeof User>;\n// { username: string }\n'})}),"\n",(0,t.jsxs)(n.p,{children:["我个人比较看好的一个库，在 tRPC、Blitz 等前后端一体交互的框架中能同时提供类型保障和 Schema 校验，同时和 Prisma 这一类库也有着很好地集成。最重要的是社区生态非常丰富，有许多自动生成的工具（",(0,t.jsx)(n.a,{href:"https://github.com/rsinohara/json-to-zod",target:"_blank",rel:"noopener noreferrer",children:"json-to-zod"}),"、",(0,t.jsx)(n.a,{href:"https://github.com/kbkk/abitia/tree/master/packages/zod-dto",target:"_blank",rel:"noopener noreferrer",children:"zod-nest-dto"})," 等）。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/typestack/class-validator",target:"_blank",rel:"noopener noreferrer",children:"class-validator"}),"，TypeStack 的作品，基于装饰器来进行校验，我们会在后面的装饰器一节了解如何基于装饰器进行校验。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export class Post {\n  @Length(10, 20)\n  title: string;\n\n  @Contains('hello')\n  text: string;\n\n  @IsInt()\n  @Min(0)\n  @Max(10)\n  rating: number;\n\n  @IsEmail()\n  email: string;\n}\n\nlet post = new Post();\npost.title = 'Hello'; // 错误\npost.text = 'this is a great post about hell world'; // 错误\npost.rating = 11; // 错误\npost.email = 'google.com'; // 错误\n\nvalidate(post).then(errors => {\n  // 查看是否返回了错误\n  if (errors.length > 0) {\n    console.log('校验失败，错误信息: ', errors);\n  } else {\n    console.log('校验通过！');\n  }\n});\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/ianstormtaylor/superstruct",target:"_blank",rel:"noopener noreferrer",children:"superstruct"}),"，功能与使用方式类似于 zod，更老牌一些。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/sindresorhus/ow",target:"_blank",rel:"noopener noreferrer",children:"ow"}),"，用于函数参数的校验，我通常在 CLI 工具里大量使用。"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import ow from 'ow';\n\nconst unicorn = input => {\n	ow(input, ow.string.minLength(5));\n\n	// …\n};\n\nunicorn(3);\n//=> ArgumentError: Expected `input` to be of type `string` but received type `number`\n\nunicorn('yo');\n//=> ArgumentError: Expected string `input` to have a minimum length of `5`, got `yo`\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/pelotom/runtypes",target:"_blank",rel:"noopener noreferrer",children:"runtypes"}),"，类似于 Zod，也是运行时的类型与 Schema 校验。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"类型覆盖检查",children:["类型覆盖检查",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型覆盖检查",children:"#"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/alexcanessa/typescript-coverage-report",target:"_blank",rel:"noopener noreferrer",children:"typescript-coverage-report"}),"，检查你的项目中类型的覆盖率，如果你希望项目的代码质量更高，可以使用这个工具来检查类型的覆盖程度，从我个人使用经验来看，大概 95% 左右就是一个比较平衡的程度了。类似于 Lint 工具，如果使用这一工具来约束项目代码质量，也可以放在 pre-commit 中进行。"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/plantain-00/type-coverage",target:"_blank",rel:"noopener noreferrer",children:"type-coverage"}),"，前者的底层依赖，可以用来定制更复杂的场景。"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"构建阶段",children:["构建阶段",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#构建阶段",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"以下工具主要在构建阶段起作用。"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://esbuild.github.io/",target:"_blank",rel:"noopener noreferrer",children:"ESBuild"}),"，应该无需过多介绍。需要注意的是 ESBuild 和 TypeScript Compiler 还是存在一些构建层面的差异，比如 ESBuild 无法编译装饰器（但可以使用插件，对含有装饰器的文件回退到 tsc 编译）。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://swc.rs/",target:"_blank",rel:"noopener noreferrer",children:"swc"}),"，也无需过多介绍。SWC 的目的是替代 Babel，因此它是可以直接支持装饰器等特性的。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/fork-ts-checker-webpack-plugin",target:"_blank",rel:"noopener noreferrer",children:"fork-ts-checker-webpack-plugin"}),"，Webpack 插件，使用额外的子进程来进行 TypeScript 的类型检查（需要禁用掉 ts-loader 自带的类型检查）。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/privatenumber/esbuild-loader",target:"_blank",rel:"noopener noreferrer",children:"esbuild-loader"}),"，基于 ESBuild 的 Webpack Loader，放在这里是因为它基本可以完全替代 ts-loader 来编译 ts 文件。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://www.npmjs.com/package/rollup-plugin-dts",target:"_blank",rel:"noopener noreferrer",children:"rollup-plugin-dts"}),"，能够将你项目内定义与编译生成的类型声明文件重新进行打包。"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://parceljs.org/",target:"_blank",rel:"noopener noreferrer",children:"Parcel"}),"，一个 Bundler，与 Webpack、Rollup 的核心差异是零配置，不需要任何 loader 或者 plugin 配置就能对常见基本所有的样式方案、语言方案、框架方案进行打包。我在之前搭过一个基于 Parcel 的项目起手式：",(0,t.jsx)(n.a,{href:"https://github.com/LinbuduLab/Parcel-Tsx-Template",target:"_blank",rel:"noopener noreferrer",children:"Parcel-Tsx-Template"}),"，可以来感受一下",(0,t.jsx)(n.strong,{children:"零配置"}),"是什么体验。"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结与预告",children:["总结与预告",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结与预告",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这一节我们汇总了各个场景下的 TypeScript 工具库，就像开头所说，本节的内容会持续更新，如果你还使用过其它让你赞不绝口的工具库，欢迎在评论区或答疑群提交给我。"}),"\n",(0,t.jsx)(n.p,{children:"下一节，我们会来了解一个对你来说可能熟悉又陌生的名词：ECMAScript，包括它到底代表了什么，和 TypeScript 的关系如何，TypeScript 中的 ECMAScript 语法如何使用，以及未来的 ECMAScript 怎么样。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}let c=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["TypeScript%20%E5%85%A8%E9%9D%A2%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%2F23.%E5%85%A8%E9%93%BE%E8%B7%AF%20TypeScript%20%E5%B7%A5%E5%85%B7%E5%BA%93%EF%BC%8C%E6%89%BE%E5%88%B0%E9%80%82%E5%90%88%E4%BD%A0%E7%9A%84%E5%B7%A5%E5%85%B7.md"]={toc:[{text:"开发阶段",id:"开发阶段",depth:2},{text:"项目开发",id:"项目开发",depth:3},{text:"代码生成",id:"代码生成",depth:3},{text:"类型相关",id:"类型相关",depth:2},{text:"校验阶段",id:"校验阶段",depth:2},{text:"逻辑校验",id:"逻辑校验",depth:3},{text:"类型覆盖检查",id:"类型覆盖检查",depth:3},{text:"构建阶段",id:"构建阶段",depth:2},{text:"总结与预告",id:"总结与预告",depth:2}],title:"23.全链路 TypeScript 工具库，找到适合你的工具",headingTitle:"23.全链路 TypeScript 工具库，找到适合你的工具",frontmatter:{}}}}]);