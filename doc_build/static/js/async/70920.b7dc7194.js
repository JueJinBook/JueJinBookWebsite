"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["70920"],{948864:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var s=r(552676),i=r(740453);function t(e){let n=Object.assign({h3:"h3",a:"a",h1:"h1",pre:"pre",code:"code",p:"p",h5:"h5",ul:"ul",li:"li"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h3,{id:"",children:(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#",children:"#"})}),"\n",(0,s.jsxs)(n.h1,{id:"6案例五-实现一个音乐播放器-node-的事件机制---eventemitter",children:["6案例五： [实现一个音乐播放器] Node 的事件机制 - EventEmitter",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6案例五-实现一个音乐播放器-node-的事件机制---eventemitter",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-!",children:"本节目标：【实现一个音乐播放器】一生二再生万物，一切皆事件，Node 最野性的魅力就来自于对于事件队列的精妙处理。\n"})}),"\n",(0,s.jsx)(n.p,{children:"事件，是用户与浏览器互动过程中，最高频的一种交互机制，用户无论是鼠标点击，滚动，拖拽，还是一个表单文件上传行为，都通过事件的形式来与应用运行环境互动。事件有它的触发者，也有它的接收者或者处理者，连接这两者以及赋能二者能力的就是事件机制。"}),"\n",(0,s.jsx)(n.p,{children:"对于一个异步行为，浏览器不知道用户什么时候点击网页按钮，用户同样不知道点击按钮后浏览器什么时候给予回应，有了事件机制，这件事情就变得很容易，比如监听一个按钮的点击行为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"var btn = document.getElementById('btn')\n\nbtn.addEventListener('click', function (e) {\n  // 按钮点击事件被监听到，开始处理事务\n}, false)\n"})}),"\n",(0,s.jsx)(n.p,{children:"事件如何处理不仅在浏览器需要考虑，服务器也有类似的场景，服务器既不知道一个请求什么时候会到来，请求处理程序也不知道背后的数据库查询行为什么时候成功返回，那么这些异步场景就需要一种机制来连接和通知彼此，在 Node 里面，很多操作都会触发事件，例如 net.Server 会在每一次有客户端连接到它时触发事件，又如 fs.readStream 会在文件打开时触发事件，所有具备触发事件能力的接口对象都是 events 的实例，在 Node 里面，事件能跑起来需要两个关键组成，分别就是 EventEmitter 和回调函数，前者负责生成实例，而后者负责执行特定任务。"}),"\n",(0,s.jsxs)(n.h5,{id:"回调函数与事件驱动",children:["回调函数与事件驱动",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#回调函数与事件驱动",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在聊 EventEmitter 之前，我们先看下回调，回调是异步编程模型里面最常见的一种方法，在 Node 里面也是如此，可以将后续逻辑封装在回调函数中作为当前函数的参数，逐层嵌套，逐层执行，最终让程序按照我们期望的方式走完流程，那么一个回调函数长什么样子呢？"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function doSomeThing (thing) {\n  console.log(thing)\n}\n\nfunction comeTo (place, cb) {\n  const thing = '到 ' + place + ' 学习 Node'\n  cb(thing)\n}\n\ncomeTo('Juejin', doSomeThing)\n// 到 Juejin 学习 Node\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以发现回调在 JS 里面，本质上是控制权的后移，把一个提前声明好的函数以参数的形式交给当前函数，当前函数在某个时刻再调用传入这个函数，同时对这个函数可以传入一些新的参数数据，那么这个函数 cb 就是我们所说的回调函数，这个回调函数不会马上执行。如果这个回调函数结合事件来执行，当某个事件发生的时候再调用回调函数，这种函数执行的方式叫做事件驱动，所以我们常看到 Node 的一大卖点就是事件驱动（event-driven），它起一个服务器的代码，请求的接收与响应本身也是回调函数来实现："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"require('http').createServer((req, res) => {\n  res.write('Hi')\n  res.end()\n}).listen(3333, '127.0.0.1', () => {})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"eventemitter-的基本用法",children:["EventEmitter 的基本用法",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#eventemitter-的基本用法",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 Node 里面，events 模块提供了 EventEmitter 的 Class 类，可以直接创建一个事件实例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// events 是 Node 的 built-in 模块，它提供了 EventEmitter 类\nconst EventEmitter = require('events')\n// 创建 EventEmitter 的事件实例\nconst ee = new EventEmitter()\n\n// 为实例增加 open 事件的监听以及注册回调函数，事件名甚至可以是中文\nee.on('open', (error, result) => {\n console.log('事件发生了，第一个监听回调函数执行')\n})\n\n// 为实例再增加一个 增加 open 事件的监听器\nee.on('open', (error, result) => {\n console.log('事件发生了，第二个监听回调函数执行')\n})\n\n// 通过 emit 来发出事件，所有该事件队列里的回调函数都会顺序执行\nee.emit('open')\nconsole.log('触发后，隔一秒再触发一次')\nsetTimeout(() => {\n ee.emit('open')\n}, 1000)\n// 事件发生了，第一个监听回调函数执行\n// 事件发生了，第二个监听回调函数执行\n// 触发后，隔一秒再触发一次\n// 事件发生了，第一个监听回调函数执行\n// 事件发生了，第二个监听回调函数执行\n"})}),"\n",(0,s.jsx)(n.p,{children:"一个事件实例上有如下的属性和方法："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"addListener(event, listener): 向事件队列后面再增加一个监听器"}),"\n",(0,s.jsx)(n.li,{children:"emit(event, [arg1], [arg2], […]):  向事件队列触发一个事件，同时可以对该事件传过去更多的数据"}),"\n",(0,s.jsx)(n.li,{children:"listeners(event): 返回事件队列中特定的事件监听对象"}),"\n",(0,s.jsx)(n.li,{children:"on(event, listener): 针对一个特定的事件注册监听器，该监听器就是一个回调函数"}),"\n",(0,s.jsx)(n.li,{children:"once(event, listener): 与 on 一样，只不过它只会执行一次，只生效一次"}),"\n",(0,s.jsx)(n.li,{children:"removeAllListeners([event]): 移除所有指定事件的监听器，不指定的话，移除所有监听器，也就是清空事件队列"}),"\n",(0,s.jsx)(n.li,{children:"removeListener(event, listener): 只移除特定事件监听器"}),"\n",(0,s.jsx)(n.li,{children:"setMaxListeners(n): 设置监听器数组的最大数量，默认是 10，超过 10 个会收到 Node 的警告"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"定制自己的-events",children:["定制自己的 events",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#定制自己的-events",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"如果我们在设计一款游戏，来监听一个玩家每一局干掉敌人，比如僵尸的个数，不同的个数会有不同的奖励机制，我们的代码可能会这样写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// 声明一个玩家类\nclass Player {\n  // 给他初始的名字和分数\n  constructor (name) {\n    this.name = name\n    this.score = 0\n  }\n\n  // 每一局打完，统计干掉游戏目标个数，来奖励分值\n  killed (target, number) {\n    if (target !== 'zombie') return\n    if (number < 10) {\n      this.score += 10 * number\n    } else if (number < 20) {\n      this.score += 8 * number\n    } else if (number < 30) {\n      this.score += 5 * number\n    }\n\n    console.log(`${this.name} 成功击杀 ${number} 个 ${target}，总得分 ${this.score}`)\n  }\n}\n// 创建一个玩家人物\nlet player = new Player('Nil')\n\n// 玩了 3 局，每一局都有收获\nplayer.killed('zombie', 5)\nplayer.killed('zombie', 12)\nplayer.killed('zombie', 22)\n// Nil 成功击杀 5 个 zombie，总得分 50\n// Nil 成功击杀 12 个 zombie，总得分 146\n// Nil 成功击杀 22 个 zombie，总得分 256\n"})}),"\n",(0,s.jsx)(n.p,{children:"这样的代码简单易懂，逻辑都控制在 killed 方法里面，但是扩展性不是很好，比如我想要在 killed 的时候，多做一些其他事情，我不得不去重写或者覆盖这个 killed 方法，定制程度更弱一些，如果游戏目标除了僵尸，还有吸血鬼、灵兽、虫子等等，他们的激励策略都不相同，通过几个方法来定制加分策略会更硬编码一些，那如果我们换用 events 的事件来简单实现下呢："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const EventEmitter = require('events')\n\n// 声明玩家类，让它继承 EventEmitter\nclass Player extends EventEmitter {\n  constructor (name) {\n    super()\n    this.name = name\n    this.score = 0\n  }\n}\n\nlet player = new Player('Nil')\n\n// 每一个创建的玩家实例，都可以添加监听器\n// 也可以定义需要触发事件的名称，为其注册回调\nplayer.on('zombie', function (number) {\n  if (number < 10) {\n    this.score += 10 * number\n  } else if (number < 20) {\n    this.score += 8 * number\n  } else if (number < 30) {\n    this.score += 5 * number\n  }\n\n  console.log(`${this.name} 成功击杀 ${number} 个 zombie，总得分 ${this.score}`)\n})\n\n// 可以触发不同的事件类型\nplayer.emit('zombie', 5)\nplayer.emit('zombie', 12)\nplayer.emit('zombie', 22)\n// Nil 成功击杀 5 个 zombie，总得分 50\n// Nil 成功击杀 12 个 zombie，总得分 146\n// Nil 成功击杀 22 个 zombie，总得分 256\n"})}),"\n",(0,s.jsx)(n.p,{children:"通过 Node 内建的 events，我们可以通过继承它来实现更灵活的类控制，给予类实例更多的控制颗粒度，即便是游戏规则变更，从代码的耦合度和维护性上看，后面这一种实现都会更轻量更灵活。"}),"\n",(0,s.jsxs)(n.h3,{id:"编程练习---命令行搜歌播放工具",children:["编程练习 - 命令行搜歌播放工具",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#编程练习---命令行搜歌播放工具",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"能动手就不吵吵，Events 看着比较简单，我们应用到案例中感受一下，现在我们一起来开发一个工具，可以在命令行窗口中搜歌和播放歌曲，依然按照第六节的 NPM 发包流程，来创建这个项目，它的结构如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"~ tree -L 2\n.\n├── README.md\n├── bin\n│\xa0\xa0 └── souge\n├── index.js\n├── lib\n│\xa0\xa0 ├── choose.js\n│\xa0\xa0 ├── find.js\n│\xa0\xa0 ├── names.js\n│\xa0\xa0 ├── play.js\n│\xa0\xa0 ├── request.js\n│\xa0\xa0 └── search.js\n├── package-lock.json\n└── package.json\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 package.json 中，我们增加执行的脚本路径："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'"bin": {\n  "souge": "./bin/souge"\n},\n'})}),"\n",(0,s.jsxs)(n.p,{children:["然后在 ",(0,s.jsx)(n.code,{children:"/bin/souge"})," 里面，增加如下脚本代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"#!/usr/bin/env node\n\nconst pkg = require('../package')\nconst emitter = require('..')\n\nfunction printVersion() {\n  console.log('souge ' + pkg.version)\n  process.exit()\n}\n\nfunction printHelp(code) {\n  const lines = [\n    '',\n    '  Usage:',\n    '    souge [songName]',\n    '',\n    '  Options:',\n    '    -v, --version    print the version of vc',\n    '    -h, --help       display this message',\n    '',\n    '  Examples:',\n    '    $ souge Hello',\n    ''\n  ]\n\n  console.log(lines.join('\\n'))\n  process.exit(code || 0)\n}\n\nconst main = async (argv) => {\n  if (!argv || !argv.length) {\n    printHelp(1)\n  }\n\n  let arg = argv[0]\n\n  switch(arg) {\n    case '-v':\n    case '-V':\n    case '--version':\n      printVersion()\n\n      break\n    case '-h':\n    case '-H':\n    case '--help':\n      printHelp()\n\n      break\n    default:\n      # 启动搜索逻辑，同时传入参数\n      emitter.emit('search', arg)\n      break\n  }\n}\n\nmain(process.argv.slice(2))\nmodule.exports = main\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们只需要关注 ",(0,s.jsx)(n.code,{children:"main"})," 函数就可以了，当通过 ",(0,s.jsx)(n.code,{children:"souge hello"})," 类似这样执行时，会把 hello 这个参数带进去，没有匹配到既有的其他参数标识，就会通过 emitter 来触发一个搜索事件，而 emitter 实例我们是从外层的 index.js 里面拿到的，所以在 index.js 里面这样写，大家跟着我的注释来看代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// names 是拼接歌曲名称的一个方法\nconst names = require('./lib/names')\nconst EventEmitter = require('events')\n// 声明一个继承 EventEmitter 的事件类\nclass Emitter extends EventEmitter {}\n// 实例化一个事件实例\nconst emitter = new Emitter()\n\n;[\n  'search',\n  'choose',\n  'find',\n  'play'\n].forEach(key => {\n  // 加载 search/choose/find/play 四个模块方法\n  const fn = require(`./lib/${key}`)\n  // 为 emitter 增加 4 个事件监听，key 就是模块名\n  emitter.on(key, async function (...args) {\n    // 在事件回调里面，调用模块方法，无脑传入事件入参\n    const res = await fn(...args)\n    // 执行模块方法后，再触发一个新事件 hanlder\n    // 同时把多个参数，如 key/res 继续丢过去\n    this.emit('handler', key, res, ...args)\n  })\n})\n\n// 搜索后触发 afterSearch，它回调里面继续触发 choose 事件\nemitter.on('afterSearch', function (data, q) {\n  if (!data || !data.result || !data.result.songs) {\n    console.log(`没搜索到 ${q} 的相关结果`)\n    return process.exit(1)\n  }\n  const songs = data.result.songs\n  this.emit('choose', songs)\n})\n\n// 在歌曲被选中后，它回调里面继续触发 find 事件\nemitter.on('afterChoose', function (answers, songs) {\n  const arr = songs.filter((song, i) => (\n    names(song, i) === answers.song\n  ))\n\n  if (arr[0] && arr[0].id) {\n    this.emit('find', arr[0].id)\n  }\n})\n\n// 在歌曲被找到后，它回调里面触发 play 播放事件\nemitter.on('afterFind', function (songs) {\n  if (songs[0] && songs[0].url) {\n    this.emit('play', songs[0].url)\n  }\n})\n\n// 监听播放，并对播放结束后继续触发 playEnd\nemitter.on('playing', function (player) {\n  player.on('playend', (item) => {\n    this.emit('playEnd')\n  })\n})\n\n// 收到播放结束，退出程序\nemitter.on('playEnd', function (player) {\n  console.log('播放结束!')\n  process.exit()\n})\n\n// 这里的 handler 精简了多个事件的判断\n// 为不同的事件增加了不同的触发回调\nemitter.on('handler', function (key, res, ...args) {\n  switch (key) {\n    case 'search':\n      return this.emit('afterSearch', res, args[0])\n    case 'choose':\n      return this.emit('afterChoose', res, args[0])\n    case 'find':\n      return this.emit('afterFind', res)\n    case 'play':\n      return this.emit('playing', res)\n  }\n})\n\nmodule.exports = emitter\n"})}),"\n",(0,s.jsxs)(n.p,{children:["歌曲的搜索播放主逻辑有了后，我们就可以各个击破了，首先是搜索逻辑，在 ",(0,s.jsx)(n.code,{children:"/lib/search.js"})," 里面发一个请求，把歌曲名字带过去，开始搜索，这里借用了 ",(0,s.jsx)(n.a,{href:"https://api.imjad.cn/cloudmusic.md",target:"_blank",rel:"noopener noreferrer",children:"imjad.cn"})," 的搜歌 API，大家如果自己学习，也可以自行搭建其他歌曲 API 服务，有很多开源的项目可以参考："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const request = require('./request')\n\nmodule.exports = (name) => {\n  const url = 'https://api.imjad.cn/cloudmusic/?type=search&search_type=1&s=' + name\n\n  return request(url)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里请求模块，也就是 ",(0,s.jsx)(n.code,{children:"/lib/request.js"})," 代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const https = require('https')\n\nmodule.exports = (url) => new Promise((resolve, reject) => {\n  https.get(url, (req, res) => {\n    let data = []\n\n    req.on('data', chunk => {\n      data.push(chunk)\n    })\n    req.on('end', () => {\n      let body\n      try {\n        body = JSON.parse(data.join(''))\n      } catch (err) {\n        console.log('<== API 服务器可能挂了，稍后重试！==>')\n      }\n\n      resolve(body)\n    })\n  })\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里的代码就很简单了，一个普通的 HTTP 请求，把收到的 Buffer 数据最终拼接后返回，在返回后，又会一路触发 afterSearch 和 choose 事件，在 choose 时候，会显示一个歌曲列表，代码也很简单："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const inquirer = require('inquirer')\nconst names = require('./names')\n\nmodule.exports = (songs) => inquirer.prompt([{\n  type: 'list',\n  name: 'song',\n  message: '共有 ' + songs.length + ' 个结果, 按下回车播放',\n  choices: songs.map((i, index) => names(i, index))\n}])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["拼接歌曲名称的代码 ",(0,s.jsx)(n.code,{children:"/lib/names.js"})," 只有一句："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"module.exports = (item, index) =>\n  `${index + 1} ${item.name} ${item.ar[0].name} ${item.al.name}`\n"})}),"\n",(0,s.jsxs)(n.p,{children:["而 inquirer 是一个三方模块，赋予我们跟命令行窗口更友好的交互方式，通过 ",(0,s.jsx)(n.code,{children:"inquirer.prompt"})," 我们了解到是哪一首歌曲被选中了，最后当歌曲被选中时，一路就触发 afterChoose 和 find 事件，在 find 时候，就用到了 ",(0,s.jsx)(n.code,{children:"/lib/find.js"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const request= require('./request')\n\nmodule.exports = async (id) => {\n  const url = 'https://api.imjad.cn/cloudmusic/?type=song&br=128000&id=' + id\n  const { data } = await request(url)\n  return data\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里依然是个简单的请求，获取到音乐文件流数据，最后在 ",(0,s.jsx)(n.code,{children:"afterFind"})," 里面，触发 ",(0,s.jsx)(n.code,{children:"play"})," 事件，播放音乐文件，播放代码在 ",(0,s.jsx)(n.code,{children:"/lib/play.js"})," 里面："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const Player = require('player')\n\nmodule.exports = (url) => {\n  return new Promise((resolve, reject) => {\n    // 实例化一个播放器，立刻启动播放\n    const player = new Player(url)\n    player.play()\n    \n    // 播放时候，触发 playing\n    player.on('playing', function (item) {\n      console.log('播放中!')\n      resolve(player)\n    })\n\n    player.on('error', function (err) {\n      // when error occurs\n      console.log('播放出错!')\n      reject(err)\n    })\n  })\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里封装了一个 Promise，包裹了 Player 的创建和播放过程，直到最终播放结束事件触发，整个过程完成，所以事件的整体触发顺序是："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"search 搜索启动"}),"\n",(0,s.jsx)(n.li,{children:"afterSearch 搜索完成"}),"\n",(0,s.jsx)(n.li,{children:"choose 歌曲选单"}),"\n",(0,s.jsx)(n.li,{children:"afterChoose 选中动作触发"}),"\n",(0,s.jsx)(n.li,{children:"find 去找寻对应歌曲"}),"\n",(0,s.jsx)(n.li,{children:"afterFind 歌曲文件数据拿到"}),"\n",(0,s.jsx)(n.li,{children:"play 开始播放"}),"\n",(0,s.jsx)(n.li,{children:"playing 正在播放"}),"\n",(0,s.jsx)(n.li,{children:"playEnd 播放结束"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这样通过事件，我们就非常方便的管理了整个流程的多个状态，如果我们想要集成其他的事件，只要处理好事件触发顺序，就变得易如反掌了。"}),"\n",(0,s.jsxs)(n.p,{children:["最后，我们可以把这个模块发布到 npm，大家也可以 ",(0,s.jsx)(n.code,{children:"npm i souge -g"})," 来体验这个工具，最原始的代码在 ",(0,s.jsx)(n.a,{href:"https://github.com/4liang/souge",target:"_blank",rel:"noopener noreferrer",children:"4liang/souge"}),"，考虑到学习，未对代码做过多优化，大家可以基于此修改后，来提 PR。"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let a=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B%E6%8E%8C%E6%8F%A1%20NodeJS%20%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F6%E6%A1%88%E4%BE%8B%E4%BA%94%EF%BC%9A%20%5B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%5D%20Node%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%20-%20EventEmitter.md"]={toc:[{text:"",id:"",depth:3},{text:"EventEmitter 的基本用法",id:"eventemitter-的基本用法",depth:3},{text:"定制自己的 events",id:"定制自己的-events",depth:3},{text:"编程练习 - 命令行搜歌播放工具",id:"编程练习---命令行搜歌播放工具",depth:3}],title:"6案例五： [实现一个音乐播放器] Node 的事件机制 - EventEmitter",headingTitle:"6案例五： [实现一个音乐播放器] Node 的事件机制 - EventEmitter",frontmatter:{}}}}]);