"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["40632"],{801494:function(e,n,s){s.r(n),s.d(n,{default:()=>L});var i=s(552676),a=s(740453);let t=s.p+"static/image/17452147516156140418adfa0517e6ca.6add8461.png",r=s.p+"static/image/9a3e177af8e92fd9b2cd080c3676785b.7e217780.png",l=s.p+"static/image/a21a5360923a00a442ea35608c101520.3eb2a40b.png",h=s.p+"static/image/400535d3b0eb18845ec0580a88f93adf.5628ee87.png",o=s.p+"static/image/a993dab177161d07434f7938b82f75e7.e0b5f427.png",c=s.p+"static/image/cf241ad16041cac145b8965facd7ce8c.2615ce85.png",g=s.p+"static/image/c96af8250d26c815661a8e1473e46eb9.98d4ea3c.png",d=s.p+"static/image/a36574c04293c372fe628de36ce3d2ef.37040b2e.png",m=s.p+"static/image/c72aad6bb37345dc2070d1ef96689163.d6b9e6c1.png",p=s.p+"static/image/521f73075a369a97e658a461d9db1eec.eb840f2e.png",u=s.p+"static/image/f59b2a86fb0c3e9b438594af039afcb1.01e875b8.png",f=s.p+"static/image/f962666746dcc85e21f300b7c9f6ec77.499a6bdf.png",b=s.p+"static/image/f2a5a0a0978db62455bbb9858849ba63.49110957.png",x=s.p+"static/image/c380751d88e0a6681a1e387dc15db9e9.10faea14.png",z=s.p+"static/image/79768acd7008446879dd24394cc680fa.4f83ed2a.png",y=s.p+"static/image/b4df6f3a96cfb547b463f45f69b4766f.bcfe8552.png",j=s.p+"static/image/b4bcce45f3ae4ce2ab8bebbc02f57316.a5d62e40.png",_=s.p+"static/image/2c77e804875eb3768cb9e42f16aa8154.1b87e70c.png",$=s.p+"static/image/51a3e526d165a45fa872761dc1b21606.39d52421.png",w=s.p+"static/image/cc8e63ac99c185a27cb415c3a83335c2.05353082.png",S=s.p+"static/image/e16b0e14aa663289be1b57dab328fbcd.f7f2ff3b.png",k=s.p+"static/image/297e60a10731625493994fda82e5a7ac.c77e509b.png",E=s.p+"static/image/0e242dd2439683542df273f6e390d9f1.b3129c71.png",v=s.p+"static/image/2e7769eea548bd5a6f6d914b86f88639.b785802d.png",M=s.p+"static/image/fb63e2cb38fe5d064e78cb4f2d2123f1.bad3ca4d.png",T=s.p+"static/image/348e4f1e85f867b64149ccfb9aa05b72.dcfb19f5.png",O=s.p+"static/image/5c2bb4a98451c958a3c3895659f02010.e2fc5bac.png",C=s.p+"static/image/9e28ec7d2a30f667719d91d1479267ee.9296ab44.png",H=s.p+"static/image/3c6519b90420cc07e3277a0ef6c60d3a.9dc1931f.png",Z=s.p+"static/image/e1026fa196935dfc12643236b484474d.a72b148f.png",A=s.p+"static/image/6b6f0ed0fea8a2e2b086a1d54b216038.68948a0b.png";function N(e){let n=Object.assign({p:"p",h2:"h2",a:"a",img:"img",blockquote:"blockquote",h3:"h3",code:"code",ul:"ul",li:"li",pre:"pre",strong:"strong",h4:"h4"},(0,a.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"前端开发会频繁的在终端中使用 Shell 命令，本课程主要分享一些常用的终端和 Shell 配置。"}),"\n",(0,i.jsxs)(n.h2,{id:"默认终端",children:["默认终端",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#默认终端",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Mac 系统默认的 Terminal 界面自定义设置功能较弱，无法进行分屏和会话管理，如下所示：\n",(0,i.jsx)("img",{src:A,alt:"image.png"}),"\n我们希望能够拥有一款强大的终端应用程序，可以在字体、背景和窗口上支持更多的定制选项，为此我们可以选择使用其它终端应用程序来代替 Mac 系统的 Terminal。"]}),"\n",(0,i.jsxs)(n.h2,{id:"iterm2",children:["iTerm2",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#iterm2",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://iterm2.com/index.html",target:"_blank",rel:"noopener noreferrer",children:"iTerm2"})," 是一款免费的终端应用程序，它不仅支持分屏，而且支持丰富的自定义设置（背景、字体、主题色和窗口透明度等），以下是本课程的配置效果：\n",(0,i.jsx)("img",{src:Z,alt:"image.png"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：Mac 上的终端应用程序很多，包括 ",(0,i.jsx)(n.a,{href:"https://hyper.is/",target:"_blank",rel:"noopener noreferrer",children:"Hyper"}),"、",(0,i.jsx)(n.a,{href:"https://www.warp.dev/",target:"_blank",rel:"noopener noreferrer",children:"Wrap"}),"、",(0,i.jsx)(n.a,{href:"https://github.com/alacritty/alacritty",target:"_blank",rel:"noopener noreferrer",children:"Alacritty"}),"、",(0,i.jsx)(n.a,{href:"https://tabby.sh/",target:"_blank",rel:"noopener noreferrer",children:"Tabby"}),"、",(0,i.jsx)(n.a,{href:"https://raphamorim.io/rio/",target:"_blank",rel:"noopener noreferrer",children:"Rio"})," 等，如果不喜欢复杂的配置，那么可以从这些各具特色的终端应用程序中选择一款。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"iterm2-profiles",children:["iTerm2 Profiles",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#iterm2-profiles",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["首次下载安装后的 iTerm2 如下所示，看起来几乎和 Mac 系统默认的 Terminal 没有差异：\n",(0,i.jsx)("img",{src:H,alt:"image.png"}),"\n我们可以通过 Profile 来进行自定义配置窗体的透明度、字体、主题颜色以及背景图等，让窗体变得更加舒适。首先我们可以通过 Profiles / Window 来设置窗体的透明度，其次我们可以通过 Profiles / Text 来调整字体大小，从而快速达到我们对于终端的基础体验诉求："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:C,alt:"屏幕录制2023-11-15 21.00.29.gif"})}),"\n",(0,i.jsx)(n.p,{children:"也可以通过 Profiles / Window 设置窗体的背景图："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:O,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["除此之外，在 Profile 中我们可以通过 Colors 来配置 Iterm2 终端的主题色，但是手动配置效率较低：\n",(0,i.jsx)("img",{src:T,alt:"image.png"}),"\n我们知道在 VS Code 中可以通过安装主题插件来一键配置主题，在 iTerm2 中我们也可以使用社区提供的主题配色方案 ",(0,i.jsx)(n.a,{href:"https://github.com/mbadolato/iTerm2-Color-Schemes",target:"_blank",rel:"noopener noreferrer",children:"iTerm2-Color-Schemes"}),"，进入 ",(0,i.jsx)(n.a,{href:"https://iterm2colorschemes.com/",target:"_blank",rel:"noopener noreferrer",children:"Iterm2-color-schemes 官网"})," 下载主题包："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:M,alt:"image.png"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"温馨提示：也可以通过 git 克隆仓库进行下载。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["通过文档中说明的步骤进行主题包导入，解压下载的文件后找到 ",(0,i.jsx)(n.code,{children:"schemes"})," 目录，进入后会发现各种主题的文件（所有主题文件都是 ",(0,i.jsx)(n.code,{children:".itermcolors"})," 后缀），这里可以全选导入也可以根据自己的喜好选择相应的主题进行导入："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:v,alt:"屏幕录制2023-11-16 20.36.47.gif"})}),"\n",(0,i.jsx)(n.p,{children:"导入成功后可以进行主题选择和设置："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:E,alt:"屏幕录制2023-11-16 20.48.55.gif"})}),"\n",(0,i.jsxs)(n.h3,{id:"iterm2-window-arrangement",children:["iTerm2 Window Arrangement",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#iterm2-window-arrangement",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"对于 Iterm2 而言，最核心的功能就是窗口分屏。由于窗口分屏需要更大的窗口空间，我们可以先通过 Profile / Window 设置默认打开的窗口大小："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:k,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"接下来我们可以使用快捷键对终端进行水平（⇧⌘D）和垂直（⌘D）切分，从而可以更高效的进行多任务操作，如下所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:S,alt:"录屏2023-11-19 10.24.30.gif"})}),"\n",(0,i.jsx)(n.p,{children:"当然，如果我们希望打开的时候默认已经进行水平和垂直切分，从而可以更高效的进行多任务操作，那么可以对 iTerm2 进行 Window Arrangement 设置："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'首先将当前切分好的窗口保存为新的 Arrangement，在菜单栏中选择 "Window" -> "Save Window Arrangement"（⇧⌘S）'}),"\n",(0,i.jsx)(n.li,{children:"在 General / Startup 中设置窗口启动时使用默认的 Arrangement（可以在 Arrangements 中新建多个，并设置默认的 Arrangement）"}),"\n",(0,i.jsx)(n.li,{children:"新开窗口打开默认的 Arrangement 需要使用 ⇧⌘R(Restore) 快捷键"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:w,alt:"录屏2023-11-19 10.36.04.gif"})}),"\n",(0,i.jsxs)(n.h2,{id:"zshz-shell",children:["zsh（Z Shell）",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#zshz-shell",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"大家都知道 Shell 是命令行解释器，提供了用户和操作系统的交互界面。用户在 Shell 中输入命令，Shell 会解释这些命令并将它们传递给操作系统执行。实现 Shell 的工具有很多，我们可以在 Mac 中输入以下命令查看 Mac 系统支持哪些 Shell 实现，刚兴趣的同学可以了解一下这些 Shell 工具的特点："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 54.番外篇：如何提高效率（终端篇）\ncat /etc/shells\n\n# 打印\n# List of acceptable shells for chpass(1).\n# Ftpd will not allow users to connect who are not using\n# one of these shells.\n\n/bin/bash\n/bin/csh\n/bin/dash\n/bin/ksh\n/bin/sh\n/bin/tcsh\n/bin/zsh\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"温馨提示：为什么 Mac 系统上会有这么多的 Shell 实现呢？早期的计算机没有图形界面，采用命令行来控制计算机，因此 Shell 是高度封装操作系统 API 的命令行工具，本质上和图形化应用程序调用系统 API 实现的功能是一样的，都是为了让用户可以操作系统运行。因此，可以将不同的 Shell 实现看做不同的应用程序。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Mac 使用 zsh 或 bash 作为默认的 Shell，",(0,i.jsx)(n.a,{href:"https://support.apple.com/zh-cn/HT208050",target:"_blank",rel:"noopener noreferrer",children:"从 macOS Catalina 开始 Mac 使用 zsh 作为默认登录 Shell 和交互式 Shell"}),"，可以通过以下命令查看当前系统使用的 Shell："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 执行\necho $SHELL\n# 打印\n/bin/zsh\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://zsh.sourceforge.io/",target:"_blank",rel:"noopener noreferrer",children:"zsh (Z shell)"})," 将 bash、ksh 以及 tcsh 等 Shell 工具的优势集成一体，提供了许多选项和插件，允许用户定制自己的 Shell 环境配置。zsh 还实现了 ",(0,i.jsx)(n.a,{href:"https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html",target:"_blank",rel:"noopener noreferrer",children:"POSIX Shell"})," 标准，可以很好的兼容其它实现了 POSIX Shell 标准的 Shell 工具，例如 bash。除此之外，zsh 提供了强大的命令行编辑功能，例如拼写检查、智能提示、自定义提示符和自动补全等。"]}),"\n",(0,i.jsx)(n.p,{children:"尽管 iTerm2 能在终端的窗体和字体上进行一些配置，但是无法提供更深层次的 Shell 配置，因此我们可以对 zsh 进行额外的配置，从而提升开发者对于 Shell 命令行的使用效率。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：如果你不喜欢做一些复杂的配置，可以了解一下 ",(0,i.jsx)(n.a,{href:"https://fishshell.com/",target:"_blank",rel:"noopener noreferrer",children:"Fish Shell"}),"，它对新手非常友好，语法简单且易于理解，具备强大的补全功能，并且拥有美观的界面，默认提供了输入和输出的信息高亮。需要注意的是，它不完全兼容 POSIX Shell 标准。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"oh-my-zsh-配置框架",children:["Oh My Zsh 配置框架",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#oh-my-zsh-配置框架",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["zsh 功能强大的同时也提供了相对复杂的配置，这对于新手而言并不是特别友好。为此，社区出现了一个管理 zsh 配置的开源框架 ",(0,i.jsx)(n.a,{href:"https://github.com/ohmyzsh/ohmyzsh",target:"_blank",rel:"noopener noreferrer",children:"Oh My Zsh"}),"，它提供了一套易于使用的配置以及大量的插件和主题，可以帮助新手更加友好的使用和定制 zsh。首先，我们可以根据官方的文档",(0,i.jsx)(n.a,{href:"https://github.com/ohmyzsh/ohmyzsh#basic-installation",target:"_blank",rel:"noopener noreferrer",children:"进行安装"}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# sh -c "echo Hello"，其中 -c 后面的字符串被视为要执行的 Shell 命令\n\n# $(curl -fsSL https://xxx.sh)\xa0是一个命令替换\n# 它会先执行括号中的\xa0curl\xa0命令下载指定 URL 的 Shell 脚本内容，然后将下载的内容替换到原位置\n\n# curl -fsSL https://xxx.sh\xa0用来下载指定 URL 的内容\n# -fsSL\xa0参数是\xa0curl 命令的选项\n# -f(fail) 代表失败时不输出 HTTP 错误\n# -s(silent) 代表静默模式\n# -S(show-error) 代表在需要时显示错误\n# -L(location) 代表如果服务器报告该页面已经移动到其他位置，则重新定向到新的位置\n\n# 使用 curl 下载 install.sh，下载完成后使用 sh 执行下载的内容\nsh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["执行成功的打印信息如下所示：\n",(0,i.jsx)("img",{src:$,alt:"image.png"})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：安装过程中可能会遇到 xcode-select 出问题，可以重新安装官方的 ",(0,i.jsx)(n.a,{href:"https://developer.apple.com/download/all/?q=XCode",target:"_blank",rel:"noopener noreferrer",children:"Command Line Tools for Xcode"})," （需要登录 Apple ID） 或者安装 ",(0,i.jsx)(n.a,{href:"https://brew.sh/",target:"_blank",rel:"noopener noreferrer",children:"Homebrew"})," 包管理器（会间接安装 Command Line Tools）。"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"我们再来回顾一下安装之前的 iTerm2 界面："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:_,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"Oh My Zsh 安装成功后的 iTerm2 界面："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:j,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"可以发现安装 Oh My Zsh 之后命令提示符变得更加简洁，不会占据大量的窗口位置，打印的信息也能够做到简单的高亮区分。"}),"\n",(0,i.jsxs)(n.h3,{id:"oh-my-zsh-配置文件",children:["Oh My Zsh 配置文件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#oh-my-zsh-配置文件",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在安装 Oh My Zsh 的过程中，我们可以重点关注一下几个打印信息，如下所示："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 寻找已经存在的 zsh 配置文件\nLooking for an existing zsh config...\n# 使用 Oh My Zsh 的模板文件进行 $HOME/.zshrc 的配置\nUsing the Oh My Zsh template file and adding it to /Users/zhuxiankang/.zshrc.\n# 提示检查 .zshrc 配置文件进行插件、主题和其它选项配置\nBefore you scream Oh My Zsh! look over the `.zshrc` file to select plugins, themes, and options.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["可以配合安装 Oh My Zsh 时执行的 ",(0,i.jsx)(n.a,{href:"https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh",target:"_blank",rel:"noopener noreferrer",children:"install.sh"})," 查看打印逻辑："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"setup_ohmyzsh()"}),"：克隆 Oh My Zsh 仓库的 master 分支到 $HOME/.oh-my-zsh 中"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"setup_zshrc()"}),"：恢复或者生成 $HOME/.zshrc 配置文件"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"setup_shell()"}),"：更改默认的登录 Shell 为 zsh"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:'setup_ohmyzsh() {\n  # Prevent the cloned repository from having insecure permissions. Failing to do\n  # so causes compinit() calls to fail with "command not found: compdef" errors\n  # for users with insecure umasks (e.g., "002", allowing group writability). Note\n  # that this will be ignored under Cygwin by default, as Windows ACLs take\n  # precedence over umasks except for filesystems mounted with option "noacl".\n  umask g-w,o-w\n  # 使用蓝色打印 Cloning Oh My Zsh...，结合安装 Oh My Zsh 的打印信息查看\n  echo "${FMT_BLUE}Cloning Oh My Zsh...${FMT_RESET}"\n\n  command_exists git || {\n    fmt_error "git is not installed"\n    exit 1\n  }\n\n  ostype=$(uname)\n  if [ -z "${ostype%CYGWIN*}" ] && git --version | grep -Eq \'msysgit|windows\'; then\n    fmt_error "Windows/MSYS Git is not supported on Cygwin"\n    fmt_error "Make sure the Cygwin git package is installed and is first on the $PATH"\n    exit 1\n  fi\n\n  # Manual clone with git config options to support git < v1.7.2\n  # 可以从完整的 install.sh 中查看 $ZSH 的值，一般情况下在 $HOME/.oh-my-zsh 中\n  # $HOME 是系统的根目录，可以使用 echo $HOME 打印路径信息\n  # 这里的 $REMOTE = https://github.com/ohmyzsh/ohmyzsh\n  # $BRANCH = master\n  \n  # setup_ohmyzsh 的主要作用是将 oh-my-zsh 仓库的 master 分支克隆到 $HOME/.oh-my-zsh 中\n  git init --quiet "$ZSH" && cd "$ZSH" \\\n  && git config core.eol lf \\\n  && git config core.autocrlf false \\\n  && git config fsck.zeroPaddedFilemode ignore \\\n  && git config fetch.fsck.zeroPaddedFilemode ignore \\\n  && git config receive.fsck.zeroPaddedFilemode ignore \\\n  && git config oh-my-zsh.remote origin \\\n  && git config oh-my-zsh.branch "$BRANCH" \\\n  && git remote add origin "$REMOTE" \\\n  && git fetch --depth=1 origin \\\n  && git checkout -b "$BRANCH" "origin/$BRANCH" || {\n    [ ! -d "$ZSH" ] || {\n      cd -\n      rm -rf "$ZSH" 2>/dev/null\n    }\n    fmt_error "git clone of oh-my-zsh repo failed"\n    exit 1\n  }\n  # Exit installation directory\n  cd -\n\n  echo\n}\n\nsetup_zshrc() {\n  # Keep most recent old .zshrc at .zshrc.pre-oh-my-zsh, and older ones\n  # with datestamp of installation that moved them aside, so we never actually\n  # destroy a user\'s original zshrc\n  echo "${FMT_BLUE}Looking for an existing zsh config...${FMT_RESET}"\n   \n  # 检查是否存在旧的\xa0.zshrc\xa0文件。如果存在，并且用户选择保留，则跳过后续步骤\n  # 如果存在\xa0.zshrc.pre-oh-my-zsh\xa0文件（即之前备份的\xa0.zshrc\xa0文件），则将其重命名并添加时间戳，以避免覆盖\n  # 将现有的\xa0.zshrc\xa0文件备份为\xa0.zshrc.pre-oh-my-zsh\n  # Must use this exact name so uninstall.sh can find it\n  OLD_ZSHRC="$zdot/.zshrc.pre-oh-my-zsh"\n  if [ -f "$zdot/.zshrc" ] || [ -h "$zdot/.zshrc" ]; then\n    # Skip this if the user doesn\'t want to replace an existing .zshrc\n    if [ "$KEEP_ZSHRC" = yes ]; then\n      echo "${FMT_YELLOW}Found ${zdot}/.zshrc.${FMT_RESET} ${FMT_GREEN}Keeping...${FMT_RESET}"\n      return\n    fi\n    if [ -e "$OLD_ZSHRC" ]; then\n      OLD_OLD_ZSHRC="${OLD_ZSHRC}-$(date +%Y-%m-%d_%H-%M-%S)"\n      if [ -e "$OLD_OLD_ZSHRC" ]; then\n        fmt_error "$OLD_OLD_ZSHRC exists. Can\'t back up ${OLD_ZSHRC}"\n        fmt_error "re-run the installer again in a couple of seconds"\n        exit 1\n      fi\n      mv "$OLD_ZSHRC" "${OLD_OLD_ZSHRC}"\n\n      echo "${FMT_YELLOW}Found old .zshrc.pre-oh-my-zsh." \\\n        "${FMT_GREEN}Backing up to ${OLD_OLD_ZSHRC}${FMT_RESET}"\n    fi\n    echo "${FMT_YELLOW}Found ${zdot}/.zshrc.${FMT_RESET} ${FMT_GREEN}Backing up to ${OLD_ZSHRC}${FMT_RESET}"\n    mv "$zdot/.zshrc" "$OLD_ZSHRC"\n  fi\n  \n  # 如果不存在旧的 .zshrc 配置文件，则使用 Oh My Zsh 的模板配置\n  echo "${FMT_GREEN}Using the Oh My Zsh template file and adding it to $zdot/.zshrc.${FMT_RESET}"\n\n  # Modify $ZSH variable in .zshrc directory to use the literal $ZDOTDIR or $HOME\n  omz="$ZSH"\n  if [ -n "$ZDOTDIR" ] && [ "$ZDOTDIR" != "$HOME" ]; then\n    omz=$(echo "$omz" | sed "s|^$ZDOTDIR/|$ZDOTDIR/|")\n  fi\n  omz=$(echo "$omz" | sed "s|^$HOME/|$HOME/|")\n\n  # 使用\xa0sed 工具修改了\xa0zshrc.zsh-template\xa0文件（文件路径在 $HOME/.oh-my-zsh/templates/zshrc.zsh-template）\n  # 查找以\xa0export ZSH=\xa0开始的行，并将这些行的内容替换为\xa0export ZSH="${omz}"\n  # 并将 sed 命令的输出重定向到一个临时文件\xa0.zshrc-omztem\n  # 将临时文件\xa0.zshrc-omztemp\xa0重命名为\xa0.zshrc，强制覆盖原来的\xa0.zshrc\xa0文件\n  sed "s|^export ZSH=.*$|export ZSH="${omz}"|" "$ZSH/templates/zshrc.zsh-template" > "$zdot/.zshrc-omztemp"\n  mv -f "$zdot/.zshrc-omztemp" "$zdot/.zshrc"\n\n  echo\n}\n\n# 如果默认使用的登录 Shell 不是 zsh，则更改默认的 Shell 为 zsh\nsetup_shell() {\n  # Skip setup if the user wants or stdin is closed (not running interactively).\n  if [ "$CHSH" = no ]; then\n    return\n  fi\n\n  # If this user\'s login shell is already "zsh", do not attempt to switch.\n  if [ "$(basename -- "$SHELL")" = "zsh" ]; then\n    return\n  fi\n\n  # If this platform doesn\'t provide a "chsh" command, bail out.\n  if ! command_exists chsh; then\n    cat <<EOF\nI can\'t change your shell automatically because this system does not have chsh.\n${FMT_BLUE}Please manually change your default shell to zsh${FMT_RESET}\nEOF\n    return\n  fi\n\n  echo "${FMT_BLUE}Time to change your default shell to zsh:${FMT_RESET}"\n\n  # Prompt for user choice on changing the default login shell\n  printf \'%sDo you want to change your default shell to zsh? [Y/n]%s \' \\\n    "$FMT_YELLOW" "$FMT_RESET"\n  read -r opt\n  case $opt in\n    y*|Y*|"") ;;\n    n*|N*) echo "Shell change skipped."; return ;;\n    *) echo "Invalid choice. Shell change skipped."; return ;;\n  esac\n\n  # Check if we\'re running on Termux\n  case "$PREFIX" in\n    *com.termux*) termux=true; zsh=zsh ;;\n    *) termux=false ;;\n  esac\n\n  if [ "$termux" != true ]; then\n    # Test for the right location of the "shells" file\n    if [ -f /etc/shells ]; then\n      shells_file=/etc/shells\n    elif [ -f /usr/share/defaults/etc/shells ]; then # Solus OS\n      shells_file=/usr/share/defaults/etc/shells\n    else\n      fmt_error "could not find /etc/shells file. Change your default shell manually."\n      return\n    fi\n\n    # Get the path to the right zsh binary\n    # 1. Use the most preceding one based on $PATH, then check that it\'s in the shells file\n    # 2. If that fails, get a zsh path from the shells file, then check it actually exists\n    if ! zsh=$(command -v zsh) || ! grep -qx "$zsh" "$shells_file"; then\n      if ! zsh=$(grep \'^/.*/zsh$\' "$shells_file" | tail -n 1) || [ ! -f "$zsh" ]; then\n        fmt_error "no zsh binary found or not present in \'$shells_file\'"\n        fmt_error "change your default shell manually."\n        return\n      fi\n    fi\n  fi\n\n  # We\'re going to change the default shell, so back up the current one\n  if [ -n "$SHELL" ]; then\n    echo "$SHELL" > "$zdot/.shell.pre-oh-my-zsh"\n  else\n    grep "^$USER:" /etc/passwd | awk -F: \'{print $7}\' > "$zdot/.shell.pre-oh-my-zsh"\n  fi\n\n  echo "Changing your shell to $zsh..."\n\n  # Check if user has sudo privileges to run `chsh` with or without `sudo`\n  #\n  # This allows the call to succeed without password on systems where the\n  # user does not have a password but does have sudo privileges, like in\n  # Google Cloud Shell.\n  #\n  # On systems that don\'t have a user with passwordless sudo, the user will\n  # be prompted for the password either way, so this shouldn\'t cause any issues.\n  #\n  if user_can_sudo; then\n    sudo -k chsh -s "$zsh" "$USER"  # -k forces the password prompt\n  else\n    chsh -s "$zsh" "$USER"          # run chsh normally\n  fi\n\n  # Check if the shell change was successful\n  if [ $? -ne 0 ]; then\n    fmt_error "chsh command unsuccessful. Change your default shell manually."\n  else\n    export SHELL="$zsh"\n    echo "${FMT_GREEN}Shell successfully changed to \'$zsh\'.${FMT_RESET}"\n  fi\n\n  echo\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["了解了 Oh My Zsh 安装的过程之后，我们可以重点来看下 ",(0,i.jsx)(n.code,{children:".zshrc"})," 配置文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cd ~\n\n# 如果 VS Code 配置了 code 命令\n# 可以使用 code ~/.zshrc 命令在 VS Code 中打开配置文件进行高亮修改\n\n# 使用默认的文本编辑器打开配置文件\nopen .zshrc\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：配置 VS Code 的 ",(0,i.jsx)(n.code,{children:"code"})," 命令可以在终端中使用 VS Code 打开任何目录的文件，例如使用 ",(0,i.jsx)(n.code,{children:"code ~/.zshrc"})," 命令，可以使我们对配置文件进行编辑器的高亮展示。为了生成 Shell 环境的 ",(0,i.jsx)(n.code,{children:"code"})," 命令，首先需要在 VS Code 中使用 ",(0,i.jsx)(n.strong,{children:"⇧⌘P"})," 打开命令面板，输入 ",(0,i.jsx)(n.code,{children:"code"})," 进行搜索，找到选项 ",(0,i.jsx)(n.strong,{children:"\"Shell 命令：在 PATH 中安装 'code' 命令\""}),"，点击进行安装即可。"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"打开以后的配置文件如下所示："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# If you come from bash you might have to change your $PATH.\n# export PATH=$HOME/bin:/usr/local/bin:$PATH\n\n# Path to your oh-my-zsh installation.\nexport ZSH="$HOME/.oh-my-zsh"\n\n# Set name of the theme to load --- if set to "random", it will\n# load a random theme each time oh-my-zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\nZSH_THEME="robbyrussell"\n\n# Set list of themes to pick from when loading at random\n# Setting this variable when ZSH_THEME=random will cause zsh to load\n# a theme from this variable instead of looking in $ZSH/themes/\n# If set to an empty array, this variable will have no effect.\n# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )\n\n# Uncomment the following line to use case-sensitive completion.\n# CASE_SENSITIVE="true"\n\n# Uncomment the following line to use hyphen-insensitive completion.\n# Case-sensitive completion must be off. _ and - will be interchangeable.\n# HYPHEN_INSENSITIVE="true"\n\n# Uncomment one of the following lines to change the auto-update behavior\n# zstyle \':omz:update\' mode disabled  # disable automatic updates\n# zstyle \':omz:update\' mode auto      # update automatically without asking\n# zstyle \':omz:update\' mode reminder  # just remind me to update when it\'s time\n\n# Uncomment the following line to change how often to auto-update (in days).\n# zstyle \':omz:update\' frequency 13\n\n# Uncomment the following line if pasting URLs and other text is messed up.\n# DISABLE_MAGIC_FUNCTIONS="true"\n\n# Uncomment the following line to disable colors in ls.\n# DISABLE_LS_COLORS="true"\n\n# Uncomment the following line to disable auto-setting terminal title.\n# DISABLE_AUTO_TITLE="true"\n\n# Uncomment the following line to enable command auto-correction.\n# ENABLE_CORRECTION="true"\n\n# Uncomment the following line to display red dots whilst waiting for completion.\n# You can also set it to another string to have that shown instead of the default red dots.\n# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"\n# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)\n# COMPLETION_WAITING_DOTS="true"\n\n# Uncomment the following line if you want to disable marking untracked files\n# under VCS as dirty. This makes repository status check for large repositories\n# much, much faster.\n# DISABLE_UNTRACKED_FILES_DIRTY="true"\n\n# Uncomment the following line if you want to change the command execution time\n# stamp shown in the history command output.\n# You can set one of the optional three formats:\n# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"\n# or set a custom format using the strftime function format specifications,\n# see \'man strftime\' for details.\n# HIST_STAMPS="mm/dd/yyyy"\n\n# Would you like to use another custom folder than $ZSH/custom?\n# ZSH_CUSTOM=/path/to/new-custom-folder\n\n# Which plugins would you like to load?\n# Standard plugins can be found in $ZSH/plugins/\n# Custom plugins may be added to $ZSH_CUSTOM/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git)\n\nsource $ZSH/oh-my-zsh.sh\n\n# User configuration\n\n# export MANPATH="/usr/local/man:$MANPATH"\n\n# You may need to manually set your language environment\n# export LANG=en_US.UTF-8\n\n# Preferred editor for local and remote sessions\n# if [[ -n $SSH_CONNECTION ]]; then\n#   export EDITOR=\'vim\'\n# else\n#   export EDITOR=\'mvim\'\n# fi\n\n# Compilation flags\n# export ARCHFLAGS="-arch x86_64"\n\n# Set personal aliases, overriding those provided by oh-my-zsh libs,\n# plugins, and themes. Aliases can be placed here, though oh-my-zsh\n# users are encouraged to define aliases within the ZSH_CUSTOM folder.\n# For a full list of active aliases, run `alias`.\n#\n# Example aliases\n# alias zshconfig="mate ~/.zshrc"\n# alias ohmyzsh="mate ~/.oh-my-zsh"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["在安装的过程中提供了 ",(0,i.jsx)(n.code,{children:"~/.oh-my-zsh/templates/zshrc.zsh-template"})," 配置模板文件，该文件和最终生成的 ",(0,i.jsx)(n.code,{children:".zshrc"})," 文件一致。因此如果 Mac 电脑默认使用 zsh 作为登录 Shell，而 Oh My Zsh 默认的安装命令执行失败，那么可以通过如下命令手动安装："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 类似于手动执行 setup_ohmyzsh()\ngit clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh\n# 将末班文件拷贝后 ~/.zshrc 中生成 .zshrc 配置文件\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\n# 查看默认的登录 Shell 是不是 zsh\necho $SHELL\n# 如果默认的登录 Shell 不是 zsh，则修改默认的登录 Shell\nchsh -s /bin/zsh\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"oh-my-zsh-插件配置",children:["Oh My Zsh 插件配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#oh-my-zsh-插件配置",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在 ",(0,i.jsx)(n.code,{children:".zshrc"})," 配置文件中可以看到插件的配置参数，默认加入了 git 插件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# ZSH 变量指代 $HOME/.oh-my-zsh 路径\n# Path to your oh-my-zsh installation.\nexport ZSH="$HOME/.oh-my-zsh"\n# Which plugins would you like to load?\n# 在 $HOME/.oh-my-zsh/plugins 中 Oh My Zsh 提供了一些默认的插件\n# Standard plugins can be found in $ZSH/plugins/\n# Custom plugins may be added to $ZSH_CUSTOM/plugins/\n# 插件的配置示例：plugins=(rails git textmate ruby lighthouse)\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# 添加的插件数量过多会导致 Shell 启动速度变慢\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["根据注释可以发现 Oh My Zsh 默认提供的插件在 ",(0,i.jsx)(n.code,{children:"$HOME/.oh-my-zsh/plugins"})," 中，进入查看可以发现 Oh My Zsh 默认提供了很多可使用的插件：\n",(0,i.jsx)("img",{src:y,alt:"image.png"})]}),"\n",(0,i.jsxs)(n.h4,{id:"git-插件",children:["git 插件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#git-插件",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"我们进入 Oh My Zsh 默认配置的 git 插件查看一下插件的内容信息："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Git version checking\nautoload -Uz is-at-least\ngit_version=\"${${(As: :)$(git version 2>/dev/null)}[3]}\"\n\n#\n# Functions Current\n# (sorted alphabetically by function name)\n# (order should follow README)\n#\n\n# The name of the current branch\n# Back-compatibility wrapper for when this function was defined here in\n# the plugin, before being pulled in to core lib/git.zsh as git_current_branch()\n# to fix the core -> git plugin dependency.\nfunction current_branch() {\n  git_current_branch\n}\n\n# Check for develop and similarly named branches\nfunction git_develop_branch() {\n  command git rev-parse --git-dir &>/dev/null || return\n  local branch\n  for branch in dev devel develop development; do\n    if command git show-ref -q --verify refs/heads/$branch; then\n      echo $branch\n      return 0\n    fi\n  done\n\n  echo develop\n  return 1\n}\n\n# Check if main exists and use instead of master\nfunction git_main_branch() {\n  command git rev-parse --git-dir &>/dev/null || return\n  local ref\n  for ref in refs/{heads,remotes/{origin,upstream}}/{main,trunk,mainline,default,master}; do\n    if command git show-ref -q --verify $ref; then\n      echo ${ref:t}\n      return 0\n    fi\n  done\n\n  # If no main branch was found, fall back to master but return error\n  echo master\n  return 1\n}\n\nfunction grename() {\n  if [[ -z \"$1\" || -z \"$2\" ]]; then\n    echo \"Usage: $0 old_branch new_branch\"\n    return 1\n  fi\n\n  # Rename branch locally\n  git branch -m \"$1\" \"$2\"\n  # Rename branch in origin remote\n  if git push origin :\"$1\"; then\n    git push --set-upstream origin \"$2\"\n  fi\n}\n\n#\n# Functions Work in Progress (WIP)\n# (sorted alphabetically by function name)\n# (order should follow README)\n#\n\n# Similar to `gunwip` but recursive \"Unwips\" all recent `--wip--` commits not just the last one\nfunction gunwipall() {\n  local _commit=$(git log --grep='--wip--' --invert-grep --max-count=1 --format=format:%H)\n\n  # Check if a commit without \"--wip--\" was found and it's not the same as HEAD\n  if [[ \"$_commit\" != \"$(git rev-parse HEAD)\" ]]; then\n    git reset $_commit || return 1\n  fi\n}\n\n# Warn if the current branch is a WIP\nfunction work_in_progress() {\n  command git -c log.showSignature=false log -n 1 2>/dev/null | grep -q -- \"--wip--\" && echo \"WIP!!\"\n}\n\n#\n# Aliases\n# (sorted alphabetically by command)\n# (order should follow README)\n# (in some cases force the alisas order to match README, like for example gke and gk)\n#\n\nalias grt='cd \"$(git rev-parse --show-toplevel || echo .)\"'\n\nfunction ggpnp() {\n  if [[ \"$#\" == 0 ]]; then\n    ggl && ggp\n  else\n    ggl \"${*}\" && ggp \"${*}\"\n  fi\n}\ncompdef _git ggpnp=git-checkout\n\nalias ggpur='ggu'\nalias g='git'\nalias ga='git add'\nalias gaa='git add --all'\nalias gapa='git add --patch'\nalias gau='git add --update'\nalias gav='git add --verbose'\nalias gwip='git add -A; git rm $(git ls-files --deleted) 2> /dev/null; git commit --no-verify --no-gpg-sign --message \"--wip-- [skip ci]\"'\nalias gam='git am'\nalias gama='git am --abort'\nalias gamc='git am --continue'\nalias gamscp='git am --show-current-patch'\nalias gams='git am --skip'\nalias gap='git apply'\nalias gapt='git apply --3way'\nalias gbs='git bisect'\nalias gbsb='git bisect bad'\nalias gbsg='git bisect good'\nalias gbsn='git bisect new'\nalias gbso='git bisect old'\nalias gbsr='git bisect reset'\nalias gbss='git bisect start'\nalias gbl='git blame -w'\nalias gb='git branch'\nalias gba='git branch --all'\nalias gbd='git branch --delete'\nalias gbD='git branch --delete --force'\n\nfunction gbda() {\n  git branch --no-color --merged | command grep -vE \"^([+*]|\\s*($(git_main_branch)|$(git_develop_branch))\\s*$)\" | command xargs git branch --delete 2>/dev/null\n}\n\n# Copied and modified from James Roeder (jmaroeder) under MIT License\n# https://github.com/jmaroeder/plugin-git/blob/216723ef4f9e8dde399661c39c80bdf73f4076c4/functions/gbda.fish\nfunction gbds() {\n  local default_branch=$(git_main_branch)\n  (( ! $? )) || default_branch=$(git_develop_branch)\n\n  git for-each-ref refs/heads/ \"--format=%(refname:short)\" | \\\n    while read branch; do\n      local merge_base=$(git merge-base $default_branch $branch)\n      if [[ $(git cherry $default_branch $(git commit-tree $(git rev-parse $branch\\^{tree}) -p $merge_base -m _)) = -* ]]; then\n        git branch -D $branch\n      fi\n    done\n}\n\nalias gbgd='LANG=C git branch --no-color -vv | grep \": gone\\]\" | awk '\"'\"'{print $1}'\"'\"' | xargs git branch -d'\nalias gbgD='LANG=C git branch --no-color -vv | grep \": gone\\]\" | awk '\"'\"'{print $1}'\"'\"' | xargs git branch -D'\nalias gbm='git branch --move'\nalias gbnm='git branch --no-merged'\nalias gbr='git branch --remote'\nalias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'\nalias gbg='LANG=C git branch -vv | grep \": gone\\]\"'\nalias gco='git checkout'\nalias gcor='git checkout --recurse-submodules'\nalias gcb='git checkout -b'\nalias gcd='git checkout $(git_develop_branch)'\nalias gcm='git checkout $(git_main_branch)'\nalias gcp='git cherry-pick'\nalias gcpa='git cherry-pick --abort'\nalias gcpc='git cherry-pick --continue'\nalias gclean='git clean --interactive -d'\nalias gcl='git clone --recurse-submodules'\n\nfunction gccd() {\n  setopt localoptions extendedglob\n\n  # get repo URI from args based on valid formats: https://git-scm.com/docs/git-clone#URLS\n  local repo=\"${${@[(r)(ssh://*|git://*|ftp(s)#://*|http(s)#://*|*@*)(.git/#)#]}:-$_}\"\n\n  # clone repository and exit if it fails\n  command git clone --recurse-submodules \"$@\" || return\n\n  # if last arg passed was a directory, that's where the repo was cloned\n  # otherwise parse the repo URI and use the last part as the directory\n  [[ -d \"$_\" ]] && cd \"$_\" || cd \"${${repo:t}%.git/#}\"\n}\ncompdef _git gccd=git-clone\n\nalias gcam='git commit --all --message'\nalias gcas='git commit --all --signoff'\nalias gcasm='git commit --all --signoff --message'\nalias gcs='git commit --gpg-sign'\nalias gcss='git commit --gpg-sign --signoff'\nalias gcssm='git commit --gpg-sign --signoff --message'\nalias gcmsg='git commit --message'\nalias gcsm='git commit --signoff --message'\nalias gc='git commit --verbose'\nalias gca='git commit --verbose --all'\nalias gca!='git commit --verbose --all --amend'\nalias gcan!='git commit --verbose --all --no-edit --amend'\nalias gcans!='git commit --verbose --all --signoff --no-edit --amend'\nalias gc!='git commit --verbose --amend'\nalias gcn!='git commit --verbose --no-edit --amend'\nalias gcf='git config --list'\nalias gdct='git describe --tags $(git rev-list --tags --max-count=1)'\nalias gd='git diff'\nalias gdca='git diff --cached'\nalias gdcw='git diff --cached --word-diff'\nalias gds='git diff --staged'\nalias gdw='git diff --word-diff'\n\nfunction gdv() { git diff -w \"$@\" | view - }\ncompdef _git gdv=git-diff\n\nalias gdup='git diff @{upstream}'\n\nfunction gdnolock() {\n  git diff \"$@\" \":(exclude)package-lock.json\" \":(exclude)*.lock\"\n}\ncompdef _git gdnolock=git-diff\n\nalias gdt='git diff-tree --no-commit-id --name-only -r'\nalias gf='git fetch'\n# --jobs=<n> was added in git 2.8\nis-at-least 2.8 \"$git_version\" \\\n  && alias gfa='git fetch --all --prune --jobs=10' \\\n  || alias gfa='git fetch --all --prune'\nalias gfo='git fetch origin'\nalias gg='git gui citool'\nalias gga='git gui citool --amend'\nalias ghh='git help'\nalias glgg='git log --graph'\nalias glgga='git log --graph --decorate --all'\nalias glgm='git log --graph --max-count=10'\nalias glods='git log --graph --pretty=\"%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset\" --date=short'\nalias glod='git log --graph --pretty=\"%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ad) %C(bold blue)<%an>%Creset\"'\nalias glola='git log --graph --pretty=\"%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset\" --all'\nalias glols='git log --graph --pretty=\"%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset\" --stat'\nalias glol='git log --graph --pretty=\"%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%ar) %C(bold blue)<%an>%Creset\"'\nalias glo='git log --oneline --decorate'\nalias glog='git log --oneline --decorate --graph'\nalias gloga='git log --oneline --decorate --graph --all'\n\n# Pretty log messages\nfunction _git_log_prettily(){\n  if ! [ -z $1 ]; then\n    git log --pretty=$1\n  fi\n}\ncompdef _git _git_log_prettily=git-log\n\nalias glp='_git_log_prettily'\nalias glg='git log --stat'\nalias glgp='git log --stat --patch'\nalias gignored='git ls-files -v | grep \"^[[:lower:]]\"'\nalias gfg='git ls-files | grep'\nalias gm='git merge'\nalias gma='git merge --abort'\nalias gms=\"git merge --squash\"\nalias gmom='git merge origin/$(git_main_branch)'\nalias gmum='git merge upstream/$(git_main_branch)'\nalias gmtl='git mergetool --no-prompt'\nalias gmtlvim='git mergetool --no-prompt --tool=vimdiff'\n\nalias gl='git pull'\nalias gpr='git pull --rebase'\nalias gprv='git pull --rebase -v'\nalias gpra='git pull --rebase --autostash'\nalias gprav='git pull --rebase --autostash -v'\n\nfunction ggu() {\n  [[ \"$#\" != 1 ]] && local b=\"$(git_current_branch)\"\n  git pull --rebase origin \"${b:=$1}\"\n}\ncompdef _git ggu=git-checkout\n\nalias gprom='git pull --rebase origin $(git_main_branch)'\nalias gpromi='git pull --rebase=interactive origin $(git_main_branch)'\nalias ggpull='git pull origin \"$(git_current_branch)\"'\n\nfunction ggl() {\n  if [[ \"$#\" != 0 ]] && [[ \"$#\" != 1 ]]; then\n    git pull origin \"${*}\"\n  else\n    [[ \"$#\" == 0 ]] && local b=\"$(git_current_branch)\"\n    git pull origin \"${b:=$1}\"\n  fi\n}\ncompdef _git ggl=git-checkout\n\nalias gluc='git pull upstream $(git_current_branch)'\nalias glum='git pull upstream $(git_main_branch)'\nalias gp='git push'\nalias gpd='git push --dry-run'\n\nfunction ggf() {\n  [[ \"$#\" != 1 ]] && local b=\"$(git_current_branch)\"\n  git push --force origin \"${b:=$1}\"\n}\ncompdef _git ggf=git-checkout\n\nalias gpf!='git push --force'\nis-at-least 2.30 \"$git_version\" \\\n  && alias gpf='git push --force-with-lease --force-if-includes' \\\n  || alias gpf='git push --force-with-lease'\n\nfunction ggfl() {\n  [[ \"$#\" != 1 ]] && local b=\"$(git_current_branch)\"\n  git push --force-with-lease origin \"${b:=$1}\"\n}\ncompdef _git ggfl=git-checkout\n\nalias gpsup='git push --set-upstream origin $(git_current_branch)'\nis-at-least 2.30 \"$git_version\" \\\n  && alias gpsupf='git push --set-upstream origin $(git_current_branch) --force-with-lease --force-if-includes' \\\n  || alias gpsupf='git push --set-upstream origin $(git_current_branch) --force-with-lease'\nalias gpv='git push --verbose'\nalias gpoat='git push origin --all && git push origin --tags'\nalias gpod='git push origin --delete'\nalias ggpush='git push origin \"$(git_current_branch)\"'\n\nfunction ggp() {\n  if [[ \"$#\" != 0 ]] && [[ \"$#\" != 1 ]]; then\n    git push origin \"${*}\"\n  else\n    [[ \"$#\" == 0 ]] && local b=\"$(git_current_branch)\"\n    git push origin \"${b:=$1}\"\n  fi\n}\ncompdef _git ggp=git-checkout\n\nalias gpu='git push upstream'\nalias grb='git rebase'\nalias grba='git rebase --abort'\nalias grbc='git rebase --continue'\nalias grbi='git rebase --interactive'\nalias grbo='git rebase --onto'\nalias grbs='git rebase --skip'\nalias grbd='git rebase $(git_develop_branch)'\nalias grbm='git rebase $(git_main_branch)'\nalias grbom='git rebase origin/$(git_main_branch)'\nalias gr='git remote'\nalias grv='git remote --verbose'\nalias gra='git remote add'\nalias grrm='git remote remove'\nalias grmv='git remote rename'\nalias grset='git remote set-url'\nalias grup='git remote update'\nalias grh='git reset'\nalias gru='git reset --'\nalias grhh='git reset --hard'\nalias grhk='git reset --keep'\nalias grhs='git reset --soft'\nalias gpristine='git reset --hard && git clean --force -dfx'\nalias groh='git reset origin/$(git_current_branch) --hard'\nalias grs='git restore'\nalias grss='git restore --source'\nalias grst='git restore --staged'\nalias gunwip='git rev-list --max-count=1 --format=\"%s\" HEAD | grep -q \"\\--wip--\" && git reset HEAD~1'\nalias grev='git revert'\nalias grm='git rm'\nalias grmc='git rm --cached'\nalias gcount='git shortlog --summary --numbered'\nalias gsh='git show'\nalias gsps='git show --pretty=short --show-signature'\nalias gstall='git stash --all'\nalias gstaa='git stash apply'\nalias gstc='git stash clear'\nalias gstd='git stash drop'\nalias gstl='git stash list'\nalias gstp='git stash pop'\n# use the default stash push on git 2.13 and newer\nis-at-least 2.13 \"$git_version\" \\\n  && alias gsta='git stash push' \\\n  || alias gsta='git stash save'\nalias gsts='git stash show --patch'\nalias gst='git status'\nalias gss='git status --short'\nalias gsb='git status --short --branch'\nalias gsi='git submodule init'\nalias gsu='git submodule update'\nalias gsd='git svn dcommit'\nalias git-svn-dcommit-push='git svn dcommit && git push github $(git_main_branch):svntrunk'\nalias gsr='git svn rebase'\nalias gsw='git switch'\nalias gswc='git switch --create'\nalias gswd='git switch $(git_develop_branch)'\nalias gswm='git switch $(git_main_branch)'\nalias gta='git tag --annotate'\nalias gts='git tag --sign'\nalias gtv='git tag | sort -V'\nalias gignore='git update-index --assume-unchanged'\nalias gunignore='git update-index --no-assume-unchanged'\nalias gwch='git whatchanged -p --abbrev-commit --pretty=medium'\nalias gwt='git worktree'\nalias gwta='git worktree add'\nalias gwtls='git worktree list'\nalias gwtmv='git worktree move'\nalias gwtrm='git worktree remove'\nalias gstu='gsta --include-untracked'\nalias gtl='gtl(){ git tag --sort=-v:refname -n --list \"${1}*\" }; noglob gtl'\nalias gk='\\gitk --all --branches &!'\nalias gke='\\gitk --all $(git log --walk-reflogs --pretty=%h) &!'\n\nunset git_version\n\n# Logic for adding warnings on deprecated aliases\nlocal old_alias new_alias\nfor old_alias new_alias (\n  # TODO(2023-10-19): remove deprecated `git pull --rebase` aliases\n  gup     gpr\n  gupv    gprv\n  gupa    gpra\n  gupav   gprav\n  gupom   gprom\n  gupomi  gpromi\n); do\n  aliases[$old_alias]=\"\n    print -Pu2 \\\"%F{yellow}[oh-my-zsh] '%F{red}${old_alias}%F{yellow}' is a deprecated alias, using '%F{green}${new_alias}%F{yellow}' instead.%f\\\"\n    $new_alias\"\ndone\nunset old_alias new_alias\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：如果你对阅读 Shell 脚本没有兴趣，那么可以只查看同级目录下的 ",(0,i.jsx)(n.code,{children:"README.md"})," 了解用法。"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"可以发现在 git 插件里提供了很多命令的别名，可以选择自己的常用命令进行强化记忆和使用，例如："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# gst = git status\n# gaa = git add --all\n# gcmsg = git commit --message\n# ggpush = git push origin \"$(git_current_branch)\" \n# gco = git checkout\n➜  git git:(master) gst\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nnothing to commit, working tree clean\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：如果你希望使用 ",(0,i.jsx)(n.code,{children:"npmS"})," 代替 ",(0,i.jsx)(n.code,{children:"npm i -S"}),"，那么可以配置 npm 插件。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"alias-finder-插件",children:["alias-finder 插件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#alias-finder-插件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["尽管 git 插件提供了很多别名，但是那么多别名一个个记忆实在太痛苦了，对于那些实在记不住的 alias 如果有一个实时提示的记忆工具就好了。alias-finder 插件为此而生，它可以在每一次执行命令后提示该命令的 alias，打开它的 ",(0,i.jsx)(n.code,{children:"README.md"})," 查看配置说明："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-md",children:"# alias-finder plugin\n\nThis plugin searches the defined aliases and outputs any that match the command inputted. This makes learning new aliases easier.\n\n## Usage\n\nTo use it, add `alias-finder` to the `plugins` array of your zshrc file:\n\nplugins=(... alias-finder)\n\nTo enable it for every single command, set zstyle in your `~/.zshrc`.\n\nzstyle ':omz:plugins:alias-finder' autoload yes # disabled by default\nzstyle ':omz:plugins:alias-finder' longer yes # disabled by default\nzstyle ':omz:plugins:alias-finder' exact yes # disabled by default\nzstyle ':omz:plugins:alias-finder' cheaper yes # disabled by default\n\nAs you can see, options are also available with zstyle.\n\n### Options\n\n> In order to clarify, let's say `alias a=abc` has source 'abc' and destination 'a'.\n\n- Use `--longer` or `-l` to include aliases where the source is longer than the input (in other words, the source could contain the whole input).\n- Use `--exact` or `-e` to avoid aliases where the source is shorter than the input (in other words, the source must be the same with the input).\n- Use `--cheaper` or `-c` to avoid aliases where the destination is longer than the input (in other words, the destination must be the shorter than the input).\n"})}),"\n",(0,i.jsxs)(n.p,{children:["为此我们可以配置 ",(0,i.jsx)(n.code,{children:".zshrc"})," 文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 新增 alias-finder 插件\nplugins=(git alias-finder)\n\nzstyle ':omz:plugins:alias-finder' autoload yes # 默认是禁用的\nzstyle ':omz:plugins:alias-finder' longer yes # 默认是禁用的\nzstyle ':omz:plugins:alias-finder' exact yes # 默认是禁用的\nzstyle ':omz:plugins:alias-finder' cheaper yes # 默认是禁用的\n"})}),"\n",(0,i.jsxs)(n.p,{children:["需要注意修改 ",(0,i.jsx)(n.code,{children:".zshrc"})," 的配置默认并不会立即生效，因为它本身是一个 Shell 脚本，需要被执行后才能生效。为了可以使它生效，你可以关闭 iTerm2 然后重新打开，此时 zsh 会按照设定的初始化过程自动查找并执行 ",(0,i.jsx)(n.code,{children:"~/.zshrc"})," 配置文件，这也是为什么 Oh My Zsh 插件设置过多后会影响 zsh 启动速度的原因。当然，如果你不想关闭当前终端来生效 ",(0,i.jsx)(n.code,{children:".zshrc"})," 配置文件，那么只需要在当前环境使用 ",(0,i.jsx)(n.code,{children:"."})," 或者 ",(0,i.jsx)(n.code,{children:"source"})," 执行 ",(0,i.jsx)(n.code,{children:".zshrc"})," 即可，如下所示："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 执行 . ~/.zshrc 是一样的功能效果\n# . 命令和 source 命令相同，表示不产生新的 shell，在当前 shell 下执行命令，可以共享同一个 shell 上下文\n# 在 huksy 中 pre-commit 钩子中也是使用 . 来执行 shell 命令\nsource ~/.zshrc\n"})}),"\n",(0,i.jsx)(n.p,{children:"配置生效后，我们可以测试一下 alias-finder 插件的作用："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 执行\ngit status\n# 打印（提示了执行命令相关的 alias 命令）\ngsb='git status --short --branch'\ngss='git status --short'\ngst='git status'\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n	modified:   plugins/git/README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\n# 执行\ngit push origin\n# 打印（提示了执行命令相关的 alias 命令）\nggpush='git push origin \"$(git_current_branch)\"'\ngpoat='git push origin --all && git push origin --tags'\ngpod='git push origin --delete'\nremote: Permission to ohmyzsh/ohmyzsh.git denied to ziyi2.\n"})}),"\n",(0,i.jsxs)(n.h4,{id:"z-插件",children:["z 插件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#z-插件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在实际开发项目的过程中，我们会频繁使用 ",(0,i.jsx)(n.code,{children:"cd"})," 和 ",(0,i.jsx)(n.code,{children:"ls"})," 进出和查看文件目录，如果目录层级较深，那么进入目录的效率会非常低下，",(0,i.jsx)(n.a,{href:"https://github.com/agkozak/zsh-z",target:"_blank",rel:"noopener noreferrer",children:"z 插件"}),"可以帮我们快速进入之前访问过的目录，从而加速目录的访问效率，打开 z 插件的 ",(0,i.jsx)(n.code,{children:"README.md"})," 查看配置说明："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-md",children:"# z - jump around\n\nThis plugin defines the [z command](https://github.com/agkozak/zsh-z) that tracks your most visited directories and allows you to access them with very few keystrokes.\n\n### Example\n\nAssume that you have previously visited directory `~/.oh-my-zsh/plugins`. From any folder in your command line, you can quickly access it by using a regex match to this folder:\n\n/usr/bin$ z plug  # Even 'z p' might suffice\n~/.oh-my-zsh/plugins$\n\n### Setup\n\nTo enable z, add `z` to your `plugins` array in your zshrc file:\n\nplugins=(... z)\n\n### Further reading\n\nFor advanced usage and details of z, see [MANUAL](./MANUAL.md) (copied from [agkozak/zsh-z](https://github.com/agkozak/zsh-z)).\n"})}),"\n",(0,i.jsxs)(n.p,{children:["我们重新配置 ",(0,i.jsx)(n.code,{children:".zshrc"})," 增加 z 插件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"plugins=(git alias-finder z)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["执行 ",(0,i.jsx)(n.code,{children:"source ~/.zshrc"})," 使配置生效，测试 z 插件的功能："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"➜  Desktop cd ~/.oh-my-zsh\n➜  .oh-my-zsh git:(master) ✗ cd plugins\n➜  plugins git:(master) ✗ cd ~\n➜  ~ z p\n➜  Desktop z plug\n➜  plugins git:(master) ✗ z oh\n➜  .oh-my-zsh git:(master) ✗\n"})}),"\n",(0,i.jsx)(n.p,{children:"可以发现 z 插件可以通过模糊匹配快速跳转到之前访问过的目录。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：",(0,i.jsx)(n.a,{href:"https://github.com/wting/autojump",target:"_blank",rel:"noopener noreferrer",children:"autojump"})," 是一款和 z 相似的快速跳转工具，它会根据你访问目录的频率对目录进行加权。如果你想要使用 autojump，那么需要额外对它进行",(0,i.jsx)(n.a,{href:"https://github.com/wting/autojump#installation",target:"_blank",rel:"noopener noreferrer",children:"安装"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"zsh-autosuggestions-插件",children:["zsh-autosuggestions 插件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#zsh-autosuggestions-插件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["之前介绍的 git、alias-finder 和 z 都是 Oh My Zsh 默认自带的标准插件，因此不需要任何安装处理。除此之外，社区还提供了很多三方自定义的插件，这些插件需要额外的安装处理。 在了解自定义插件之前，我们重新查看 ",(0,i.jsx)(n.code,{children:".zshrc"})," 的插件配置说明："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Which plugins would you like to load?\n# Oh My Zsh 默认自带的标准插件被放置在目录 $ZSH/plugins（$HOME/.oh-my-zsh/plugins) 中\n# Standard plugins can be found in $ZSH/plugins/\n# 三方自定义插件需要安装到 $ZSH_CUSTOM/plugins（$HOME/.oh-my-zsh/custom/plugins）中\n# Custom plugins may be added to $ZSH_CUSTOM/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git alias-finder z)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["从插件的注释说明可以发现，如果是自定义插件需要安装到 ",(0,i.jsx)(n.code,{children:"$HOME/.oh-my-zsh/custom/plugins"})," 目录中，这样可以将三方插件和标准插件区分开，一旦 Oh My Zsh 需要更新，通常只会更新标准插件目录中的插件，不会覆盖三方插件所在的目录。"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"温馨提示：Oh My Zsh 允许配置三方插件所在的目录文件。除此之外，所有的三方插件放在单独的目录中可以使得备份、迁移和共享更加便捷，你完全可以把自定义插件和 Oh My Zsh 的配置拷贝给别人或者迁移到新的电脑上，不需要重新对所有插件进行安装处理。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://github.com/zsh-users/zsh-autosuggestions/tree/master",target:"_blank",rel:"noopener noreferrer",children:"zsh-autosuggestions"})," 是一个能够自动提示命令的插件，它会根据用户的历史命令来预测用户想要输入的完整命令，从而智能的给出命令补全提示，如果用户接受提示，则只需要使用特定的快捷键快速补全命令即可，这样可以大大减少输入完整命令的时间，从而提升开发效率。我们首先需要安装 zsh-autosuggestions 插件，根据官方的 ",(0,i.jsx)(n.a,{href:"https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md#oh-my-zsh",target:"_blank",rel:"noopener noreferrer",children:"Oh My Zsh 安装文档"})," 进行安装："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 首先克隆 zsh-autosuggestions 仓库到 $ZSH_CUSTOM/plugins 目录下\n# $ZSH_CUSTOM/plugins = $HOME/.oh-my-zsh/custom/plugins\n\n# ${ZSH_CUSTOM:-~/.oh-my-zsh/custom} 是一个参数替换表达式\n# 如果环境变量 ZSH_CUSTOM 已设置，那么使用 ZSH_CUSTOM\n# 否则使用 ~/.oh-my-zsh/custom 作为默认值（这里的 ~ 就是 $HOME）\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n\n# 克隆成功后可以进入目录查看一下\n# 使用 z 快速匹配最近访问的 $HOME/.oh-my-zsh/custom/plugins 目录\n➜  ~ z plug\n➜  plugins git:(master) ✗ ls\nexample             zsh-autosuggestions\n"})}),"\n",(0,i.jsxs)(n.p,{children:["在自定义的 ",(0,i.jsx)(n.code,{children:"plugins"})," 目录下存放了 zsh-autosuggestions 插件之后，接下来可以配置 ",(0,i.jsx)(n.code,{children:"~/.zshrc"})," 文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 新增 zsh-autosuggestions 插件配置\nplugins=(git alias-finder z zsh-autosuggestions)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["配置完成后执行 ",(0,i.jsx)(n.code,{children:"source ~/.zshrc"})," 使得当前 Shell 环境的 Oh My Zsh 配置生效，接下来使用命令时 zsh-autosuggestions 会根据历史命令进行智能补全，如果灰色部分的智能提示是我们需要的补全命令，那么只需要使用快捷键 ",(0,i.jsx)(n.strong,{children:"→"})," 进行快速补全："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:z,alt:"录屏2023-11-24 09.27.44.gif"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：如果你对命令的自动补全感兴趣，可以查看 ",(0,i.jsx)(n.a,{href:"https://github.com/zsh-users/zsh-completions",target:"_blank",rel:"noopener noreferrer",children:"zsh-completions"})," 插件。注意，zsh-autosuggestions 是根据用户输入的历史命令进行补全提示，而 zsh-completions 用于补全命令和选项。除此之外，Zsh 默认已经具备了补全功能，包括命令、文件名（例如输入 ",(0,i.jsx)(n.code,{children:"ls"})," + 空格然后按 ",(0,i.jsx)(n.code,{children:"Tab"})," 键进行文件名补全提示）、变量名和其他类型的参数补全，zsh-completions 是对 Zsh 默认补全功能的额外补充。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"zsh-syntax-highlighting-插件",children:["zsh-syntax-highlighting 插件",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#zsh-syntax-highlighting-插件",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://fishshell.com/",target:"_blank",rel:"noopener noreferrer",children:"Fish Shell"})," 默认提供了输入信息的高亮展示，如下所示："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"Zsh 默认并没有输入的高亮能力，如下所示："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:b,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["如果想要实现类似于 Fish Shell 的输入高亮，可以使用 ",(0,i.jsx)(n.a,{href:"https://github.com/zsh-users/zsh-syntax-highlighting",target:"_blank",rel:"noopener noreferrer",children:"zsh-syntax-highlighting"})," 插件，当输入命令时，zsh-syntax-highlighting\xa0插件可以实时地对输入进行语法高亮，而且还可以帮助发现输入错误，例如拼写错误或者语法错误。它和 zsh-autosuggestions 插件的安装过程类似，我们需要根据官方的\xa0",(0,i.jsx)(n.a,{href:"https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh",target:"_blank",rel:"noopener noreferrer",children:"Oh My Zsh 安装文档"}),"\xa0进行安装："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 首先克隆 zsh-autosuggestions 仓库到 $ZSH_CUSTOM/plugins 目录下\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n"})}),"\n",(0,i.jsxs)(n.p,{children:["接下来可以配置 ",(0,i.jsx)(n.code,{children:"~/.zshrc"})," 文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 新增 zsh-syntax-highlighting 插件配置\nplugins=(git alias-finder z zsh-autosuggestions zsh-syntax-highlighting)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["配置完成后执行 ",(0,i.jsx)(n.code,{children:"source ~/.zshrc"})," 使得当前 Shell 环境的 Oh My Zsh 配置生效，接下来我们输入命令就可以进行语法高亮了："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:f,alt:"image.png"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["温馨提示：如果想要了解更多三方插件，可以查看 ",(0,i.jsx)(n.a,{href:"https://github.com/unixorn/awesome-zsh-plugins",target:"_blank",rel:"noopener noreferrer",children:"awesome-zsh-plugins"}),"。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"oh-my-zsh-主题配置",children:["Oh My Zsh 主题配置",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#oh-my-zsh-主题配置",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Oh My Zsh 除了提供了标准插件和三方插件之外，还提供了非常多的",(0,i.jsx)(n.a,{href:"https://github.com/ohmyzsh/ohmyzsh/wiki/Themes",target:"_blank",rel:"noopener noreferrer",children:"默认主题"}),"（点击链接可以查看各种主题效果）。打开 ",(0,i.jsx)(n.code,{children:"~/.zshrc"})," 找到主题配置："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# 配置主题的名字，如果设置为 random，那么每次打开会随机使用一个内置的主题\n# Set name of the theme to load --- if set to "random", it will\n# load a random theme each time oh-my-zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes\nZSH_THEME="robbyrussell"\n\n# 可以设置一系列需要随机的主题\n# Set list of themes to pick from when loading at random\n# Setting this variable when ZSH_THEME=random will cause zsh to load\n# a theme from this variable instead of looking in $ZSH/themes/\n# If set to an empty array, this variable will have no effect.\n# ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )\n'})}),"\n",(0,i.jsxs)(n.p,{children:["主题和标准插件类似，主要存放在 ",(0,i.jsx)(n.code,{children:"~/.oh-my-zsh/themes"}),"（插件在同级的 ",(0,i.jsx)(n.code,{children:"plugins"}),"） 目录下：\n",(0,i.jsx)("img",{src:u,alt:"image.png"})]}),"\n",(0,i.jsxs)(n.h4,{id:"agnoster-主题",children:["agnoster 主题",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#agnoster-主题",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["我们可以根据官方提供的主题效果示例来配置一个主题，例如 ",(0,i.jsx)(n.a,{href:"https://gist.github.com/agnoster/3712874",target:"_blank",rel:"noopener noreferrer",children:"agnoster"}),"："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["将 ",(0,i.jsx)(n.code,{children:"~/.zshrc"})," 的主题更改为 agnoster，执行 ",(0,i.jsx)(n.code,{children:"source ~/.zshrc"})," 使其生效："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:m,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["根据 ",(0,i.jsx)(n.a,{href:"https://gist.github.com/agnoster/3712874",target:"_blank",rel:"noopener noreferrer",children:"agnoster"})," 的说明，使用该主题可能需要安装额外的字体，可以通过输入命令 ",(0,i.jsx)(n.code,{children:'echo "\\ue0b0 \\u00b1 \\ue0a0 \\u27a6 \\u2718 \\u26a1 \\u2699"'})," 测试是否支持主题需要的字体图标，例如作者的电脑默认不支持部分图标，所以会展示一些带 ? 号的图标："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,i.jsxs)(n.p,{children:["默认支持的情况如下所示：\n",(0,i.jsx)("img",{src:g,alt:"image.png"})]}),"\n",(0,i.jsxs)(n.p,{children:["除此之外，如果你想去除 ",(0,i.jsx)(n.code,{children:"user@hostname"})," 提示，那么可以直接通过命令 ",(0,i.jsx)(n.code,{children:"code ~/.oh-my-zsh/themes/agnoster.zsh-theme"})," 编辑主题："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Context: user@hostname (who am I and where am I)\nprompt_context() {\n  if [[ "$USERNAME" != "$DEFAULT_USER" || -n "$SSH_CLIENT" ]]; then\n    prompt_segment black default "%(!.%{%F{yellow}%}.)%n@%m"\n  fi\n}\n\n## Main prompt\nbuild_prompt() {\n  RETVAL=$?\n  prompt_status\n  prompt_virtualenv\n  prompt_aws\n  # 注释掉此功能\n  # prompt_context\n  prompt_dir\n  prompt_git\n  prompt_bzr\n  prompt_hg\n  prompt_end\n}\n\nPROMPT=\'%{%f%b%k%}$(build_prompt) \'\n'})}),"\n",(0,i.jsxs)(n.p,{children:["再次执行 ",(0,i.jsx)(n.code,{children:"source ~/.zshrc"})," 后，主题的命令提示符就被更改了：\n",(0,i.jsx)("img",{src:c,alt:"image.png"})]}),"\n",(0,i.jsxs)(n.h4,{id:"powerlevel10k-主题",children:["powerlevel10k 主题",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#powerlevel10k-主题",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Oh My Zsh 不仅在插件方面可以通过三方进行定制，主题也可以通过三方进行安装配置。如果觉得默认的主题不够简洁美观，那么推荐安装 ",(0,i.jsx)(n.a,{href:"https://github.com/romkatv/powerlevel10k",target:"_blank",rel:"noopener noreferrer",children:"powerlevel10k"})," 主题，它是一个非常流行且高度可定制的 Zsh 主题，提供了强大的提示符支持，包括 Git 分支状态、命令执行时间、背景作业数以及许多其它实用功能。同时，它还提供了一个配置向导，帮助用户轻松设置和自定义他们的提示符外观。"]}),"\n",(0,i.jsx)(n.p,{children:"Oh My Zsh 主题的安装和插件的安装流程类似，如下所示："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# 克隆仓库到 $ZSH_CUSTOM/themes 目录下（三方定制的插件在同级的 plugins 目录下）\ngit clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\n"})}),"\n",(0,i.jsxs)(n.p,{children:["配置 ",(0,i.jsx)(n.code,{children:".zshrc"})," 文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# 配置主题为三方的自定义主题\nZSH_THEME="powerlevel10k/powerlevel10k"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["配置完成后执行 ",(0,i.jsx)(n.code,{children:"source ~/.zshrc"})," 使得主题生效，生效后 powerlevel10k 会自动开启配置向导，如下所示：\n",(0,i.jsx)("img",{src:o,alt:"image.png"})]}),"\n",(0,i.jsxs)(n.p,{children:["在 iTerm2 的终端环境中，powerlevel10k 的配置向导首先会提示是否需要安装 Meslo Nerd Font 字体（详见 ",(0,i.jsx)(n.a,{href:"https://github.com/romkatv/powerlevel10k#automatic-font-installation",target:"_blank",rel:"noopener noreferrer",children:"Meslo Nerd Font patched for Powerlevel10k / Automatic font installation"}),"），我们回答 yes 进行安装即可。安装完成后会提示我们需要重启 iTerm2：\n",(0,i.jsx)("img",{src:h,alt:"image.png"}),"\n重新启动后仍然会自动进入 iTerm2 的配置向导，此时我们只需要根据提示一步步进行配置即可：\n",(0,i.jsx)("img",{src:l,alt:"image.png"}),"\n例如作者配置完成后的效果如下所示：\n",(0,i.jsx)("img",{src:r,alt:"image.png"}),"\n打开 VS Code 查看终端的效果：\n",(0,i.jsx)("img",{src:t,alt:"image.png"}),"\n如果对配置的结果不满意，可以输入 ",(0,i.jsx)(n.code,{children:"p10k configure"})," 命令进入配置向导进行配置。"]}),"\n",(0,i.jsxs)(n.h3,{id:"zplug-插件管理器",children:["Zplug 插件管理器",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#zplug-插件管理器",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["Zsh 的开源配置框架有很多，除了 Oh My Zsh 也可以使用其它的开源配置框架，例如 ",(0,i.jsx)(n.a,{href:"https://github.com/zplug/zplug",target:"_blank",rel:"noopener noreferrer",children:"Zplug"})," ，它是一个强大的插件管理器，支持并行安装插件，从而具备较快的启动速度。如果希望插件配置可以在新电脑上进行快速迁移，那么 Zplug 只需要拷贝 ",(0,i.jsx)(n.code,{children:"~/.zshrc"})," 文件即可，启动新环境的终端时，它会检插件是否安装，如果未安装会自动进行安装。Oh My Zsh 如果想要迁移三方插件，除了拷贝 ",(0,i.jsx)(n.code,{children:"~/.zshrc"})," 文件之外，还需要额外拷贝已经安装的三方插件文件。除此之外，Zplug 还提供了 ",(0,i.jsx)(n.code,{children:"update"})," 命令，具备一键更新插件版本的能力。如果不在乎 Zsh 的启动速度，那么可以使用 Oh My Zsh 来配置主题和默认插件，使用 Zplug 来管理三方插件。"]}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"本课程讲解了如何使用 iTerm2 配置终端的分屏效果，从而可以并行执行多个终端任务。除此之外，还讲解了 Oh My Zsh 开源配置框架以及如何基于配置框架进行插件和主题的配置。通过使用 Zsh 的插件和主题，可以快速提升终端命令的操作效率。"})]})}function R(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(N,{...e})}):N(e)}let L=R;R.__RSPRESS_PAGE_META={},R.__RSPRESS_PAGE_META["%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%BE%AE%E5%89%8D%E7%AB%AF%2F54.%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%88%E7%BB%88%E7%AB%AF%E7%AF%87%EF%BC%89.md"]={toc:[{text:"默认终端",id:"默认终端",depth:2},{text:"iTerm2",id:"iterm2",depth:2},{text:"iTerm2 Profiles",id:"iterm2-profiles",depth:3},{text:"iTerm2 Window Arrangement",id:"iterm2-window-arrangement",depth:3},{text:"zsh（Z Shell）",id:"zshz-shell",depth:2},{text:"Oh My Zsh 配置框架",id:"oh-my-zsh-配置框架",depth:3},{text:"Oh My Zsh 配置文件",id:"oh-my-zsh-配置文件",depth:3},{text:"Oh My Zsh 插件配置",id:"oh-my-zsh-插件配置",depth:3},{text:"git 插件",id:"git-插件",depth:4},{text:"alias-finder 插件",id:"alias-finder-插件",depth:4},{text:"z 插件",id:"z-插件",depth:4},{text:"zsh-autosuggestions 插件",id:"zsh-autosuggestions-插件",depth:4},{text:"zsh-syntax-highlighting 插件",id:"zsh-syntax-highlighting-插件",depth:4},{text:"Oh My Zsh 主题配置",id:"oh-my-zsh-主题配置",depth:3},{text:"agnoster 主题",id:"agnoster-主题",depth:4},{text:"powerlevel10k 主题",id:"powerlevel10k-主题",depth:4},{text:"Zplug 插件管理器",id:"zplug-插件管理器",depth:3},{text:"小结",id:"小结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);