"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["75770"],{504069:function(e,n,s){s.r(n),s.d(n,{default:()=>t});var r=s(552676),c=s(740453);let i=s.p+"static/image/e4bc257d862d5e0924620981100d8ed8.35230101.webp";function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",br:"br",ul:"ul",li:"li",strong:"strong",img:"img",pre:"pre",code:"code"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"10渲染篇-4千方百计event-loop-与异步更新策略",children:["10.渲染篇 4：千方百计——Event Loop 与异步更新策略",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#10渲染篇-4千方百计event-loop-与异步更新策略",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Vue 和 React 都实现了异步更新策略。虽然实现的方式不尽相同，但都达到了减少 DOM 操作、避免过度渲染的目的。通过研究框架的运行机制，其设计思路将深化我们对 DOM 优化的理解，其实现手法将拓宽我们对 DOM 实践的认知。"}),"\n",(0,r.jsx)(n.p,{children:"本节我们将基于 Event Loop 机制，对 Vue 的异步更新策略作探讨。"}),"\n",(0,r.jsxs)(n.h2,{id:"前置知识event-loop-中的渲染时机",children:["前置知识：Event Loop 中的“渲染时机”",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前置知识event-loop-中的渲染时机",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"搞懂 Event Loop，是理解 Vue 对 DOM 操作优化的第一步。"}),"\n",(0,r.jsxs)(n.h3,{id:"micro-task-与-macro-task",children:["Micro-Task 与 Macro-Task",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#micro-task-与-macro-task",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。"}),"\n",(0,r.jsxs)(n.p,{children:["常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。",(0,r.jsx)(n.br,{}),"\n","常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。"]}),"\n",(0,r.jsxs)(n.h3,{id:"event-loop-过程解析",children:["Event Loop 过程解析",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#event-loop-过程解析",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"基于对 micro 和 macro 的认知，我们来走一遍完整的事件循环过程。"}),"\n",(0,r.jsx)(n.p,{children:"一个完整的 Event Loop 过程，可以概括为以下阶段："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，",(0,r.jsx)(n.strong,{children:"这个过程本质上是队列的 macro-task 的执行和出队的过程"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是",(0,r.jsx)(n.strong,{children:"一个一个"}),"执行的；而 micro-task 出队时，任务是",(0,r.jsx)(n.strong,{children:"一队一队"}),"执行的（如下图所示）。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"执行渲染操作，更新界面"}),"（敲黑板划重点）。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"检查是否存在 Web worker 任务，如果有，则对其进行处理 。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"（上述过程循环往复，直到两个队列都清空）"}),"\n",(0,r.jsx)(n.p,{children:"我们总结一下，每一次循环都是一个这样的过程："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsxs)(n.h3,{id:"渲染的时机",children:["渲染的时机",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#渲染的时机",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"大家现在思考一个这样的问题：假如我想要在异步任务里进行DOM更新，我该把它包装成 micro 还是 macro 呢？"}),"\n",(0,r.jsx)(n.p,{children:"我们先假设它是一个 macro 任务，比如我在 script 脚本中用 setTimeout 来处理它："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// task是一个用于修改DOM的回调\nsetTimeout(task, 0)\n"})}),"\n",(0,r.jsx)(n.p,{children:"现在 task 被推入的 macro 队列。但因为 script 脚本本身是一个 macro 任务，所以本次执行完 script 脚本之后，下一个步骤就要去处理 micro 队列了，再往下就去执行了一次 render，对不对？"}),"\n",(0,r.jsx)(n.p,{children:"但本次render我的目标task其实并没有执行，想要修改的DOM也没有修改，因此这一次的render其实是一次无效的render。"}),"\n",(0,r.jsx)(n.p,{children:"macro 不 ok，我们转向 micro 试试看。我用 Promise 来把 task 包装成是一个 micro 任务："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"Promise.resolve().then(task)\n"})}),"\n",(0,r.jsx)(n.p,{children:"那么我们结束了对 script 脚本的执行，是不是紧接着就去处理 micro-task 队列了？micro-task 处理完，DOM 修改好了，紧接着就可以走 render 流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。"}),"\n",(0,r.jsxs)(n.p,{children:["因此，我们更新 DOM 的时间点，应该尽可能靠近渲染的时机。",(0,r.jsx)(n.strong,{children:"当我们需要在异步任务中实现 DOM 修改时，把它包装成 micro 任务是相对明智的选择"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"生产实践异步更新策略以-vue-为例",children:["生产实践：异步更新策略——以 Vue 为例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#生产实践异步更新策略以-vue-为例",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"什么是异步更新？"}),"\n",(0,r.jsxs)(n.p,{children:["当我们使用 Vue 或 React 提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。待到适当的时机，队列中的更新任务会被",(0,r.jsx)(n.strong,{children:"批量触发"}),"。这就是异步更新。"]}),"\n",(0,r.jsx)(n.p,{children:"异步更新可以帮助我们避免过度渲染，是我们上节提到的“让 JS 为 DOM 分压”的典范之一。"}),"\n",(0,r.jsxs)(n.h3,{id:"异步更新的优越性",children:["异步更新的优越性",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步更新的优越性",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["异步更新的特性在于它",(0,r.jsx)(n.strong,{children:"只看结果"}),"，因此渲染引擎",(0,r.jsx)(n.strong,{children:"不需要为过程买单"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:"最典型的例子，比如有时我们会遇到这样的情况："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 任务一\nthis.content = '第一次测试'\n// 任务二\nthis.content = '第二次测试'\n// 任务三\nthis.content = '第三次测试'\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们在三个更新任务中对同一个状态修改了三次，如果我们采取传统的同步更新策略，那么就要操作三次 DOM。但本质上需要呈现给用户的目标内容其实只是第三次的结果，也就是说只有第三次的操作是有意义的——我们白白浪费了两次计算。"}),"\n",(0,r.jsxs)(n.p,{children:["但如果我们把这三个任务塞进异步更新队列里，它们会先在 JS 的层面上被",(0,r.jsx)(n.strong,{children:"批量执行完毕"}),"。当流程走到渲染这一步时，它仅仅需要针对有意义的计算结果操作一次 DOM——这就是异步更新的妙处。"]}),"\n",(0,r.jsxs)(n.h3,{id:"vue状态更新手法nexttick",children:["Vue状态更新手法：nextTick",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue状态更新手法nexttick",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Vue 每次想要更新一个状态的时候，会先把它这个更新操作给包装成一个异步操作派发出去。这件事情，在源码中是由一个叫做 nextTick 的函数来完成的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"export function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  // 检查上一个异步任务队列（即名为callbacks的任务数组）是否派发和执行完毕了。pending此处相当于一个锁\n  if (!pending) {\n    // 若上一个异步任务队列已经执行完毕，则将pending设定为true（把锁锁上）\n    pending = true\n    // 是否要求一定要派发为macro任务\n    if (useMacroTask) {\n      macroTimerFunc()\n    } else {\n      // 如果不说明一定要macro 你们就全都是micro\n      microTimerFunc()\n    }\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们看到，Vue 的异步任务默认情况下都是用 Promise 来包装的，也就是是说它们都是 micro-task。这一点和我们“前置知识”中的渲染时机的分析不谋而合。"}),"\n",(0,r.jsx)(n.p,{children:"为了带大家熟悉一下常见的 macro 和 micro 派发方式、加深对 Event Loop 的理解，我们继续细化解析一下 macroTimeFunc() 和 microTimeFunc() 两个方法。"}),"\n",(0,r.jsx)(n.p,{children:"macroTimeFunc() 是这么实现的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// macro首选setImmediate 这个兼容性最差\nif (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  macroTimerFunc = () => {\n    setImmediate(flushCallbacks)\n  }\n} else if (typeof MessageChannel !== 'undefined' && (\n    isNative(MessageChannel) ||\n    // PhantomJS\n    MessageChannel.toString() === '[object MessageChannelConstructor]'\n  )) {\n  const channel = new MessageChannel()\n  const port = channel.port2\n  channel.port1.onmessage = flushCallbacks\n  macroTimerFunc = () => {\n    port.postMessage(1)\n  }\n} else {\n  // 兼容性最好的派发方式是setTimeout\n  macroTimerFunc = () => {\n    setTimeout(flushCallbacks, 0)\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"microTimeFunc() 是这么实现的："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"// 简单粗暴 不是ios全都给我去Promise 如果不兼容promise 那么你只能将就一下变成macro了\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  const p = Promise.resolve()\n  microTimerFunc = () => {\n    p.then(flushCallbacks)\n    // in problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) setTimeout(noop)\n  }\n} else {\n  // 如果无法派发micro，就退而求其次派发为macro\n  microTimerFunc = macroTimerFunc\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们注意到，无论是派发 macro 任务还是派发 micro 任务，派发的任务对象都是一个叫做 flushCallbacks 的东西，这个东西做了什么呢？"}),"\n",(0,r.jsx)(n.p,{children:"flushCallbacks 源码如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"function flushCallbacks () {\n  pending = false\n  // callbacks在nextick中出现过 它是任务数组（队列）\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  // 将callbacks中的任务逐个取出执行\n  for (let i = 0; i < copies.length; i++) {\n    copies[i]()\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"现在我们理清楚了：Vue 中每产生一个状态更新任务，它就会被塞进一个叫 callbacks 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 micro 或 macro 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 pending 锁是开着的（false），就把它设置为锁上（true），然后对当前 callbacks 数组的任务进行派发（丢进 micro 或 macro 队列）和执行。设置 pending 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。"}),"\n",(0,r.jsxs)(n.p,{children:["本小节我们从性能优化的角度出发，通过解析Vue源码，对异步更新这一高效的 DOM 优化手段有了感性的认知。同时帮助大家进一步熟悉了 micro 与 macro 在生产中的应用，加深了对 Event Loop 的理解。事实上，Vue 源码中还有许多值得称道的生产实践，其设计模式与编码细节都值得我们去细细品味。对这个话题感兴趣的同学，课后不妨移步 ",(0,r.jsx)(n.a,{href:"https://juejin.cn/book/6844733705089449991",target:"_blank",rel:"noopener noreferrer",children:"Vue运行机制解析"})," 进行探索。"]}),"\n",(0,r.jsxs)(n.h2,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"至此，我们的 DOM 优化之路才走完了一半。"}),"\n",(0,r.jsx)(n.p,{children:"以上我们都在讨论“如何减少 DOM 操作”的话题。这个话题比较宏观——DOM 操作也分很多种，它们带来的变化各不相同。有的操作只触发重绘，这时我们的性能损耗就小一些；有的操作会触发回流，这时我们更“肉疼”一些。那么如何理解回流与重绘，如何借助这些理解去提升页面渲染效率呢？"}),"\n",(0,r.jsx)(n.p,{children:"结束了 JS 的征程，我们下面就走进 CSS 的世界一窥究竟。"}),"\n",(0,r.jsx)(n.p,{children:"（阅读过程中有任何想法或疑问，或者单纯希望和笔者交个朋友啥的，欢迎大家添加我的微信xyalinode与我交流哈~）"})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}let t=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F10.%E6%B8%B2%E6%9F%93%E7%AF%87%204%EF%BC%9A%E5%8D%83%E6%96%B9%E7%99%BE%E8%AE%A1%E2%80%94%E2%80%94Event%20Loop%20%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5.md"]={toc:[{text:"前置知识：Event Loop 中的“渲染时机”",id:"前置知识event-loop-中的渲染时机",depth:2},{text:"Micro-Task 与 Macro-Task",id:"micro-task-与-macro-task",depth:3},{text:"Event Loop 过程解析",id:"event-loop-过程解析",depth:3},{text:"渲染的时机",id:"渲染的时机",depth:3},{text:"生产实践：异步更新策略——以 Vue 为例",id:"生产实践异步更新策略以-vue-为例",depth:2},{text:"异步更新的优越性",id:"异步更新的优越性",depth:3},{text:"Vue状态更新手法：nextTick",id:"vue状态更新手法nexttick",depth:3},{text:"小结",id:"小结",depth:2}],title:"10.渲染篇 4：千方百计——Event Loop 与异步更新策略",headingTitle:"10.渲染篇 4：千方百计——Event Loop 与异步更新策略",frontmatter:{}}}}]);