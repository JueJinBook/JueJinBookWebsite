"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55166"],{283720:function(e,n,a){a.r(n),a.d(n,{default:()=>d});var s=a(552676),l=a(740453);let i=a.p+"static/image/e91e85183f30fece276ae09cf1dcc927.194372c5.webp",c=a.p+"static/image/b4434d71ef1788c5744c90519315b967.d46b2c28.webp",t=a.p+"static/image/5fa9e7d3f3d82adb7905539876bd65d7.6d2999db.webp",r=a.p+"static/image/704a5b4889a4bc9ec760ffad862b43a5.7b6148a6.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ol:"ol",li:"li",strong:"strong",pre:"pre",img:"img"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"14具体实现开发自定义分析插件",children:["14.具体实现：开发自定义分析插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#14具体实现开发自定义分析插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在第 9 小节我们学习了如何通过插件方案来解决工具在代码结构上的问题，同时为分析工具内置了 ",(0,s.jsx)(n.code,{children:"defaultPlugin"}),"、",(0,s.jsx)(n.code,{children:"typePlugin"}),"、",(0,s.jsx)(n.code,{children:"methodPlugin"}),"、",(0,s.jsx)(n.code,{children:"browserPlugin"})," 4 个基础分析插件。"]}),"\n",(0,s.jsxs)(n.p,{children:["如果分析工具只能支持 ",(0,s.jsx)(n.code,{children:"属性"}),"、",(0,s.jsx)(n.code,{children:"方法"}),"、",(0,s.jsx)(n.code,{children:"类型"})," 等用途检测的分析指标，那它是毫无生命力的，因为不同业务场景肯定有不同的分析目的，自定义插件就是分析工具提供给开发者拓展分析指标的方案，这节课我们会以代码实操的方式来讲解如何开发 / 调试 / 贡献自定义分析插件。"]}),"\n",(0,s.jsxs)(n.p,{children:["这一小节讲解的内容，代码，示例都在 ",(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})," 中，建议大家 clone 到本地对照学习。"]}),"\n",(0,s.jsxs)(n.h2,{id:"分析插件开发流程",children:["分析插件开发流程",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#分析插件开发流程",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["我们先来回顾一下开发 ",(0,s.jsx)(n.code,{children:"methodPlugin"})," 的过程，大致可以归纳为 5 个阶段："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"根据分析指标观察 AST 节点特征："})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Method API 调用的主要特征是基准节点位于 CallExpression 类型节点下，",(0,s.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/JYWwDg9gTgLgBAbzgGwgQwCYFMoBo5phhwC+cAZlBCHAOSVohYDu0A1rQNwBQ3qmOABS0ArgGcctAJQ9CYAHSoAxmmQBlGNDQBzLPIkxhYzVCy18tYEqwg0AO2k8gA",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { app } from 'framework';\napp.localStorage.set('store', 'iceman');\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"抽象判定逻辑："})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"判断 baseNode 基准节点的父级节点是否为 CallExpression 类型。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"if(node.parent && tsCompiler.isCallExpression(node.parent)){\n    // 判定通过\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"开发调试插件代码："})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"开发"}),"：根据分析插件规范实现一个函数，内部声明挂载的副作用 Map，实现检测函数 checkFun，并根据插件是否互斥来返回 Boolean 类型的执行结果。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"调试"}),"：实现插件后，以 ",(0,s.jsx)(n.code,{children:"API 模式"}),"运行，入参需要注册该插件，主程序会在 ",(0,s.jsx)(n.code,{children:"_dealAST"})," 中调用已注册插件对象的检测方法（","ps：methodPlugin 为内置插件，所以不需要在配置中显示声明，自定义插件需要","）。"]}),"\n",(0,s.jsxs)(n.ol,{start:"4",children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"诊断日志定位缺陷报错（如有）"})," ："]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["分析程序执行结束后，根据 ",(0,s.jsx)(n.code,{children:"diagnosis.json"})," 文件中 ",(0,s.jsx)(n.code,{children:"methodPlugin"})," 执行的错误栈信息定位并修复缺陷。"]}),"\n",(0,s.jsxs)(n.ol,{start:"5",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"验证结果并完善逻辑："})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"打印分析结果，发现结果不符合预期，原因是没有排除 API 作为函数参数的调用场景："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { app } from 'framework';\n\napp.localStorage.set('store', 'iceman');    // 正确调用\ngetUserInfo(app.info);                      // 需要排除这种调用\n"})}),"\n",(0,s.jsx)(n.p,{children:"完善 checkFun 排除干扰后，再次验证分析结果是否符合预期，符合则结束流程。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// 存在于函数调用表达式中\nif(node.parent && tsCompiler.isCallExpression(node.parent)){\n    // 命中函数名method检测，而非参数名\n    if(node.parent.expression.pos == node.pos && node.parent.expression.end == node.end){\n        // 判定通过  \n    }\n}\n\n"})}),"\n",(0,s.jsx)(n.p,{children:"了解完分析插件的开发流程后，接下来我们亲自动手来实现一个分析插件。"}),"\n",(0,s.jsxs)(n.h2,{id:"class-api-分析插件",children:["Class API 分析插件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#class-api-分析插件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["虽然大部分导出的 API 用途是",(0,s.jsx)(n.code,{children:"属性"}),"、",(0,s.jsx)(n.code,{children:"方法"}),"、",(0,s.jsx)(n.code,{children:"类型"}),"，但也存在",(0,s.jsx)(n.strong,{children:"依赖提供方"}),"对外提供",(0,s.jsx)(n.code,{children:"类"}),"的场景，接下来我们开发一个识别 ",(0,s.jsx)(n.code,{children:"Class API"})," 调用的自定义分析插件。"]}),"\n",(0,s.jsxs)(n.p,{children:["先来观察一下 ",(0,s.jsx)(n.code,{children:"Class API"})," 被调用时的 AST 结构及特征，以下面这段代码为例："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Car } from 'framework';\n\nfunction deal() {\n    const name = 'iceman'\n    const car = new Car(name);\n    return car;\n}\n\ndeal();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["把代码放入",(0,s.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/JYWwDg9gTgLgBAbzgYQIZTgXzgMyhEOAcj1RAFMB3aAayIG4AoRnAVwDsBjGYCduACblUAGwAUASkSMAkJz4BneOzLk4AXmLBO5EKnZFZ89krid0GuOyop0YlRQlMZUcjFZR+5qE0zMhopL0QA",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"}),"："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["我们发现 ",(0,s.jsx)(n.code,{children:"Class API"})," 调用最主要的特征就是基准节点位于 ",(0,s.jsx)(n.code,{children:"NewExpression"})," 类型节点下，或者说在 NewExpression 表达式内，通过判断基准节点的父级节点是否为 NewExpression 类型是第一步筛选。但需要注意的是，因为它的父级节点也是一个表达式，与 ",(0,s.jsx)(n.code,{children:"method API"})," 类似，也需要排除 ",(0,s.jsx)(n.code,{children:"Car"})," 节点出现在 ",(0,s.jsx)(n.code,{children:"arguments"})," 中即作为参数被调用的干扰场景。"]}),"\n",(0,s.jsxs)(n.p,{children:["梳理清楚判定逻辑后，我们来实现一下 ",(0,s.jsx)(n.code,{children:"classPlugin"}),"："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"exports.classPlugin = function (analysisContext) {\n    const mapName = 'classMap';\n    // 在分析实例上下文挂载副作用\n    analysisContext[mapName] = {};\n\n    function isClassCheck (context, tsCompiler, node, depth, apiName, matchImportItem, filePath, projectName, httpRepo, line) {\n        try{\n            if(node.parent && tsCompiler.isNewExpression(node.parent)){ // 存在于New调用表达式中                                  \n                // 命中关键词检测\n                if(node.parent.expression.pos == node.pos && node.parent.expression.end == node.end){\n                    if (!context[mapName][apiName]) {\n                        context[mapName][apiName] = {};\n                        context[mapName][apiName].callNum = 1;\n                        context[mapName][apiName].callOrigin = matchImportItem.origin;\n                        context[mapName][apiName].callFiles = {};\n                        context[mapName][apiName].callFiles[filePath] = {};\n                        context[mapName][apiName].callFiles[filePath].projectName = projectName;\n                        context[mapName][apiName].callFiles[filePath].httpRepo = httpRepo;\n                        context[mapName][apiName].callFiles[filePath].lines = [];\n                        context[mapName][apiName].callFiles[filePath].lines.push(line);\n                    } else {\n                        context[mapName][apiName].callNum++;\n                        if (!Object.keys(context[mapName][apiName].callFiles).includes(filePath)) {\n                            context[mapName][apiName].callFiles[filePath] = {};\n                            context[mapName][apiName].callFiles[filePath].projectName = projectName;\n                            context[mapName][apiName].callFiles[filePath].httpRepo = httpRepo;\n                            context[mapName][apiName].callFiles[filePath].lines = [];\n                            context[mapName][apiName].callFiles[filePath].lines.push(line);\n                        }else{\n                            context[mapName][apiName].callFiles[filePath].lines.push(line);\n                        }\n                    }\n                    return true;             // true: 命中规则, 终止执行后序插件\n                }           \n            }\n            return false;                   // false: 未命中检测逻辑, 继续执行后序插件\n        }catch(e){\n            // console.log(e);\n            const info = {\n                projectName: projectName,\n                matchImportItem: matchImportItem,\n                apiName: apiName,\n                httpRepo: httpRepo + filePath.split('&')[1] + '#L' + line,\n                file: filePath.split('&')[1],\n                line: line,\n                stack: e.stack\n            };\n            context.addDiagnosisInfo(info);\n            return false;                   // false: 插件执行报错, 继续执行后序插件\n        }\n    }\n\n    // 返回分析Node节点的函数\n    return {\n        mapName : mapName,\n        checkFun: isClassCheck,\n        afterHook: null\n    };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["写完代码后，我们以 API 模式来运行调试插件，",(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})," 项目中的 ",(0,s.jsx)(n.code,{children:"apiMode.js"})," 演示了如何配置插件，建议大家 clone ",(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})," 项目到本地，安装依赖后执行 ",(0,s.jsx)(n.code,{children:"npm run analysis:api"})," 即可体验如何调试插件代码。"]}),"\n",(0,s.jsx)(n.p,{children:"apiMode.js 代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const analysis = require('code-analysis-ts');                         // 代码依赖分析工具\nconst { classPlugin } = require('./classPlugin');                     // class API 分析插件\n// const { classPlugin } = require('code-analysis-plugins');          // class API 分析插件\nconst { execSync } = require('child_process');                        // 子进程操作\nconst DefaultBranch = 'main';                                         // 默认分支常量\nfunction getGitBranch() {                                             // 获取当前分支\n    try{\n        const branchName = execSync('git symbolic-ref --short -q HEAD', {\n            encoding: 'utf8'\n        }).trim();\n        // console.log(branchName);\n        return branchName;\n    }catch(e){\n        return DefaultBranch;\n    }\n}\n\nasync function scan() {\n    try{\n        const { report, diagnosisInfos } = await analysis({\n            scanSource: [{                                                          // 必须，待扫描源码的配置信息\n                name: 'Code-Demo',                                                                // 必填，项目名称\n                path: ['src'],                                                                    // 必填，需要扫描的文件路径（基准路径为配置文件所在路径）\n                packageFile: 'package.json',                                                      // 可选，package.json 文件路径配置，用于收集依赖的版本信息\n                format: null,                                                                     // 可选, 文件路径格式化函数,默认为null,一般不需要配置\n                httpRepo: `https://github.com/liangxin199045/code-demo/blob/${getGitBranch()}/`   // 可选，项目gitlab/github url的访问前缀，用于点击行信息跳转，不填则不跳转\n            }],                                                                 \n            analysisTarget: 'framework',                                            // 必须，要分析的目标依赖名\n            analysisPlugins: [classPlugin],                                         // 可选，自定义分析插件，默认为空数组，一般不需要配置\n            blackList: ['app.localStorage.set', 'location.href'],                   // 可选，需要标记的黑名单api，默认为空数组\n            browserApis: ['window','document','history','location'],                // 可选，要分析的BrowserApi，默认为空数组\n            reportDir: 'docs',                                                      // 可选，生成代码分析报告的目录，默认为'report',不支持多级目录配置\n            reportTitle: 'Code-Demo代码分析报告',                                    // 可选，代码分析报告标题，默认为'代码依赖分析报告'\n            isScanVue: true,                                                        // 可选，是否要扫描分析vue中的ts代码，默认为false\n            scorePlugin: 'default'                                                  // 可选，评分插件: Function|'default'|null, default表示运行默认插件，默认为null表示不评分\n        });                                                                          \n        console.log(report.classMap);  // 这里为了验证结果，只打印classMap数据\n    }catch(e){\n        console.log(e);\n    }\n};\n\nscan();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["程序执行结束后，我们通过打印出来的 classMap 来验证一下分析插件的准确性（截图中的打印结果是 ",(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})," 项目中执行 ",(0,s.jsx)(n.code,{children:"npm run analysis:api"})," 后分析的结果）："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,s.jsxs)(n.p,{children:["乍一看结果好像是符合预期的，我们成功找到了 ",(0,s.jsx)(n.code,{children:"Class API"})," 及相关调用信息，但我们再仔细思考一下，Class API 除了被 new 表达式实例化这一种调用方式以外，还有什么调用场景呢?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["对，",(0,s.jsx)(n.strong,{children:"被继承"}),"，"]})," 我们还需要考虑 ",(0,s.jsx)(n.code,{children:"Class API"})," 被继承的场景："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Car } from 'framework';\n\nclass BaoMa extends Car {\n    constructor() {\n        super();\n        this.brand = 'baoma'\n    }\n    \n    run() {\n        super.run();\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["同理，将上述示例代码放入",(0,s.jsx)(n.a,{href:"https://ts-ast-viewer.com/#code/JYWwDg9gTgLgBAbzgYQIZTgXzgMyhEOAcj1RAFMB3aAayIG4AoRgYwBtUBnTuAIVQgBZVHHIAPGOQB2AEx5oMCRgEgWEKZxhQArixjQAFAEpEjOOYvnO2sOSjGmlyzAAWwTgDoARlFSy4ALzEXgIgqERmFpgqKjpSxqbKyta2UB5xDirRmEA",target:"_blank",rel:"noopener noreferrer",children:"TypeScript AST Viewer"}),"，观察一下 ",(0,s.jsx)(n.code,{children:"Class API"})," 被继承场景 AST 的结构及特征："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Class API"})," 被继承最主要的特征是基准节点位于 ",(0,s.jsx)(n.code,{children:"HeritageClause"})," 类型节点中孙子节点的位置，并且基准节点的父级节点类型为 ",(0,s.jsx)(n.code,{children:"ExpressionWithTypeArguments"}),"，所以我们可以通过判断基准节点父级节点、爷爷节点的类型来判断调用逻辑，完善一下我们的插件代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"exports.classPlugin = function (analysisContext) {\n    const mapName = 'classMap';\n    // 在分析实例上下文挂载副作用\n    analysisContext[mapName] = {};\n\n    function isClassCheck (context, tsCompiler, node, depth, apiName, matchImportItem, filePath, projectName, httpRepo, line) {\n        try{\n            if(node.parent && tsCompiler.isNewExpression(node.parent)){                                    // 存在于New调用表达式中\n                if(node.parent.expression.pos == node.pos && node.parent.expression.end == node.end){    // 命中关键词检测\n                    if (!context[mapName][apiName]) {\n                        context[mapName][apiName] = {};\n                        context[mapName][apiName].callNum = 1;\n                        context[mapName][apiName].callOrigin = matchImportItem.origin;\n                        context[mapName][apiName].callFiles = {};\n                        context[mapName][apiName].callFiles[filePath] = {};\n                        context[mapName][apiName].callFiles[filePath].projectName = projectName;\n                        context[mapName][apiName].callFiles[filePath].httpRepo = httpRepo;\n                        context[mapName][apiName].callFiles[filePath].lines = [];\n                        context[mapName][apiName].callFiles[filePath].lines.push(line);\n                    } else {\n                        context[mapName][apiName].callNum++;\n                        if (!Object.keys(context[mapName][apiName].callFiles).includes(filePath)) {\n                            context[mapName][apiName].callFiles[filePath] = {};\n                            context[mapName][apiName].callFiles[filePath].projectName = projectName;\n                            context[mapName][apiName].callFiles[filePath].httpRepo = httpRepo;\n                            context[mapName][apiName].callFiles[filePath].lines = [];\n                            context[mapName][apiName].callFiles[filePath].lines.push(line);\n                        }else{\n                            context[mapName][apiName].callFiles[filePath].lines.push(line);\n                        }\n                    }\n                    return true;             // true: 命中规则, 终止执行后序插件\n                }           \n            }else if(node.parent && tsCompiler.isExpressionWithTypeArguments(node.parent) && tsCompiler.isHeritageClause(node.parent.parent)){  // 被继承表达式中\n                if (!context[mapName][apiName]) {\n                    context[mapName][apiName] = {};\n                    context[mapName][apiName].callNum = 1;\n                    context[mapName][apiName].callOrigin = matchImportItem.origin;\n                    context[mapName][apiName].callFiles = {};\n                    context[mapName][apiName].callFiles[filePath] = {};\n                    context[mapName][apiName].callFiles[filePath].projectName = projectName;\n                    context[mapName][apiName].callFiles[filePath].httpRepo = httpRepo;\n                    context[mapName][apiName].callFiles[filePath].lines = [];\n                    context[mapName][apiName].callFiles[filePath].lines.push(line);\n                } else {\n                    context[mapName][apiName].callNum++;\n                    if (!Object.keys(context[mapName][apiName].callFiles).includes(filePath)) {\n                        context[mapName][apiName].callFiles[filePath] = {};\n                        context[mapName][apiName].callFiles[filePath].projectName = projectName;\n                        context[mapName][apiName].callFiles[filePath].httpRepo = httpRepo;\n                        context[mapName][apiName].callFiles[filePath].lines = [];\n                        context[mapName][apiName].callFiles[filePath].lines.push(line);\n                    }else{\n                        context[mapName][apiName].callFiles[filePath].lines.push(line);\n                    }\n                }\n                return true;             // true: 命中规则, 终止执行后序插件\n            }\n            return false;                   // false: 未命中检测逻辑, 继续执行后序插件\n        }catch(e){\n            // console.log(e);\n            const info = {\n                projectName: projectName,\n                matchImportItem: matchImportItem,\n                apiName: apiName,\n                httpRepo: httpRepo + filePath.split('&')[1] + '#L' + line,\n                file: filePath.split('&')[1],\n                line: line,\n                stack: e.stack\n            };\n            context.addDiagnosisInfo(info);\n            return false;                   // false: 插件执行报错, 继续执行后序插件\n        }\n    }\n\n    // 返回分析Node节点的函数\n    return {\n        mapName : mapName,\n        checkFun: isClassCheck,\n        afterHook: null\n    };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["再次执行后，分析结果是符合预期的，我们找到了 Class API 被继承调用的场景（截图中的打印结果是 ",(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})," 项目中执行 ",(0,s.jsx)(n.code,{children:"npm run analysis:api"})," 后分析的结果）："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"至此，Class API 调用检测的分析插件开发完成。"}),"\n",(0,s.jsxs)(n.h2,{id:"贡献插件代码",children:["贡献插件代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#贡献插件代码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"随着代码分析工具的普及，很多开发团队都会需要 classPlugin 这样的自定义分析插件，很显然大家没有必要都去实现一个 classPlugin，插件体系的优点就在于可以结合社区的力量去完善各种分析指标，从而提升工具生命力。"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-plugins",target:"_blank",rel:"noopener noreferrer",children:"code-analysis-plugins"})," 是针对 code-analysis-ts 分析工具的共享插件库，开发者可以通过提交 PR 的形式将自己开发的分析插件提交到该仓库。有了插件库以后，实际开发中我们先去插件库中找相关的分析插件，安装 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/code-analysis-plugins",target:"_blank",rel:"noopener noreferrer",children:"npm"})," 包后直接引入即可，通过插件库引入分析插件的示例同样可以参考 ",(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"这一小节我们学习了如何开发自定义分析插件，需要大家掌握以下知识点："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["分析插件的开发流程可以归纳为 ",(0,s.jsx)(n.code,{children:"5"})," 个阶段：",(0,s.jsx)(n.strong,{children:"观察 AST 节点特征"})," ",(0,s.jsx)(n.strong,{children:"，"})," ",(0,s.jsx)(n.strong,{children:"抽象判定逻辑"})," ",(0,s.jsx)(n.strong,{children:"，"})," ",(0,s.jsx)(n.strong,{children:"开发调试插件代码，通过诊断日志定位缺陷（如有），验证结果并完善逻辑。"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Class API"})," 除了通过 new 表达式实例化这一种调用方式外，还有被继承的调用场景，开发 classPlugin 的时候这两种情况都需要考虑。"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://github.com/liangxin199045/code-analysis-plugins",target:"_blank",rel:"noopener noreferrer",children:"code-analysis-plugins"})," 是针对 code-analysis-ts 分析工具的共享插件库，开发者可以通过它贡献自定义插件。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"通过自定义插件，我们可以逐步丰富化代码分析工具的分析指标，这里我布置一个小作业：同学们可以尝试开发一个识别 API 是否被 Hack 的自定义分析插件。"})]})}function p(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}let d=p;p.__RSPRESS_PAGE_META={},p.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F14.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%BC%80%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E6%9E%90%E6%8F%92%E4%BB%B6.md"]={toc:[{text:"分析插件开发流程",id:"分析插件开发流程",depth:2},{text:"Class API 分析插件",id:"class-api-分析插件",depth:2},{text:"贡献插件代码",id:"贡献插件代码",depth:2},{text:"小结",id:"小结",depth:2}],title:"14.具体实现：开发自定义分析插件",headingTitle:"14.具体实现：开发自定义分析插件",frontmatter:{}}}}]);