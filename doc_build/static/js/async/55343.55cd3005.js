"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["55343"],{221471:function(n,e,r){n.exports=r.p+"static/image/03998bde9d15a10cc3e414d23f309a98.667bee74.webp"},672953:function(n,e,r){n.exports=r.p+"static/image/4086e0e3213bbd3c0e188b837b01e337.4244d3c6.webp"},956928:function(n,e,r){n.exports=r.p+"static/image/4683398bf21ad766fcce66755c0c9cd5.4aea2981.webp"},459265:function(n,e,r){n.exports=r.p+"static/image/6ce5412b6eee17644ab5135a0d0acf7f.e9974420.webp"},689858:function(n,e,r){n.exports=r.p+"static/image/aff01d67868b60c6a18e162bb826ce33.0e51a215.webp"},857563:function(n,e,r){n.exports=r.p+"static/image/d111300818786657d7b81f2b06d45860.624623c1.webp"},877363:function(n,e,r){n.exports=r.p+"static/image/e380171f5018954b83242113baef33ff.cdd6cb51.webp"},463584:function(n,e,r){n.exports=r.p+"static/image/ebc7240ab9d5abc127c1b77ed8289b1a.0858e1db.webp"},569979:function(n,e,r){n.exports=r.p+"static/image/efe2a877ac8667be36bc4535cfa82026.bf0d49e4.webp"},911349:function(n,e,r){r.r(e),r.d(e,{default:()=>u});var s=r(552676),i=r(740453),t=r(463584),c=r(221471),l=r(672953),d=r(857563),o=r(956928),a=r(459265),h=r(569979),p=r(689858),x=r(877363);function j(n){let e=Object.assign({p:"p",strong:"strong",h3:"h3",a:"a",blockquote:"blockquote",code:"code",img:"img",pre:"pre",ul:"ul",li:"li",h2:"h2"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"在之前的章节里，我们主要对客户端的设计知识与背景做了一些了解。"}),"\n",(0,s.jsx)(e.p,{children:"从本章开始，我们将进入到客户端项目的开发阶段了。"}),"\n",(0,s.jsxs)(e.p,{children:["在本章节我们主要的目的就是来初始化我们项目的基础结构，完成整个 ",(0,s.jsx)(e.strong,{children:"Monorepo"})," 的项目结构创建。"]}),"\n",(0,s.jsxs)(e.h3,{id:"创建仓库",children:["创建仓库",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#创建仓库",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["第一步，我在代码托管平台中创建了远程的原始仓库，在这里首选是 ",(0,s.jsx)(e.strong,{children:"GitHub"}),"，如果没有梯子的用户可以使用 ",(0,s.jsx)(e.strong,{children:"Gitee"}),"。有特殊爱好也可以选用 ",(0,s.jsx)(e.strong,{children:"Coding"}),"、 ",(0,s.jsx)(e.strong,{children:"GitLab"})," 等代码托管平台。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["本项目是使用",(0,s.jsx)(e.code,{children:"GitHub"}),"来进行代码托管的，目前所有的代码地址都是在 ",(0,s.jsx)(e.a,{href:"https://github.com/Ignition-Space",target:"_blank",rel:"noopener noreferrer",children:"Ignition-Space"})," 当中。感兴趣可以点一个 ",(0,s.jsx)(e.strong,{children:"Star"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["如下图所示，在平台上创建对应的项目，填写好相关信息后，项目仓库就创建完成了，项目的名字是 ",(0,s.jsx)(e.a,{href:"https://github.com/Ignition-Space/Ignition-web",target:"_blank",rel:"noopener noreferrer",children:"Ignition-web"}),"，点击可以直接到达。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:x,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["接下来，通过 ",(0,s.jsx)(e.strong,{children:"Git"})," 将仓库克隆到本地后，就可以进入到项目开发阶段了。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Git shell 的方式"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",children:"# 20.客户端实战：初始化项目\n\ngit clone https://github.com/Ignition-Space/Ignition-web.git\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Source Tree"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:p,alt:"image.png"})}),"\n",(0,s.jsxs)(e.h3,{id:"初始化项目",children:["初始化项目",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化项目",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["当仓库与本地建立好联系之后，我们就可以来初始化项目结构了。前端所有的包和应用都在一个项目仓库当中，项目使用 ",(0,s.jsx)(e.a,{href:"https://pnpm.io/",target:"_blank",rel:"noopener noreferrer",children:"pnpm"})," 作为主要的包管理工具。我也非常建议使用它来管理我们日常开发当中的依赖包，它的优点与缺点可以看这篇文档",(0,s.jsx)(e.a,{href:"https://juejin.cn/post/6932046455733485575",target:"_blank",rel:"noopener noreferrer",children:"关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?"})]}),"\n",(0,s.jsxs)(e.p,{children:["首先，通过 ",(0,s.jsx)(e.code,{children:"pnpm init"})," 来初始化前端项目，本质上和 ",(0,s.jsx)(e.code,{children:"npm init"})," 一致。命令执行后会如下图一样，填写项目的初始化信息，把自己要做的项目相关名称、作者、描述等填写好即可。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",children:"# 初始化\npnpm init\n"})}),"\n",(0,s.jsxs)(e.p,{children:["当看到项目根目录中出现 ",(0,s.jsx)(e.strong,{children:"package.json"})," 文件就代表项目初始化成功了。"]}),"\n",(0,s.jsxs)(e.h3,{id:"monorepo",children:["Monorepo",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#monorepo",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["对于搭建平台来说，大部分都是通用型的功能，考虑到多项目复用的情况下通常会将其单独封装\uD83D\uDCE6成为 ",(0,s.jsx)(e.strong,{children:"sdk"}),"，比如负责渲染的渲染器，管理通用物料的组件库，定义接口模型的请求模块等等，这些都会单独的作为 ",(0,s.jsx)(e.strong,{children:"npm"})," 包发布。\n除此之外，也有物料管理平台、编辑器平台、文档等等应用仓库。为了更好的维护它们，常规条件下有两种方式可以选择，一种是多仓库分组，另一种就是 ",(0,s.jsx)(e.code,{children:"monorepo"})," 了。"]}),"\n",(0,s.jsxs)(e.p,{children:["作为一个示例项目来说，太多仓库不管是对学习者还是维护者都是一个比较头疼的问题。所以我选择了单一仓库的 ",(0,s.jsx)(e.code,{children:"monorepo"})," 的方式来管理项目的应用和子包。接下来，我就带大家使用 ",(0,s.jsx)(e.code,{children:"pnpm workspace"})," 来初始化整个项目的工程架构。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"首先"}),"：在项目目录下分别创建 ",(0,s.jsx)(e.code,{children:"app"})," 和 ",(0,s.jsx)(e.code,{children:"package"})," 目录，用于存放应用与类库。然后在创建 ",(0,s.jsx)(e.code,{children:"pnpm-workspace"})," 配置文件，用来定义 ",(0,s.jsx)(e.code,{children:"monorepo"})," 的工作区间。目录结构如下所示："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"lgnition-web            \n+  app \n+  packages  \n+  LICENSE\n+  README.md\n+  package.json\n+  pnpm-lock.yaml\n+  pnpm-workspace.yaml\n"})}),"\n",(0,s.jsxs)(e.p,{children:["创建好目录文件后，在 ",(0,s.jsx)(e.code,{children:"pnpm-workspace.yaml"})," 中声明 ",(0,s.jsx)(e.code,{children:"app"})," 和 ",(0,s.jsx)(e.code,{children:"packages"})," 的工作区。确保它们能够正常的被当作工作区间识别："]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"app"}),"：放置项目的应用和子应用工程，比如接口服务，搭建平台",(0,s.jsx)(e.strong,{children:"web客户端"}),"。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"packages"}),"：放置项目中创建的npm子包，如编辑器组件，物料库，核心实现等",(0,s.jsx)(e.strong,{children:"npm包"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-yaml",children:"packages:\n  - 'app/**'\n  - 'packages/**'\n"})}),"\n",(0,s.jsxs)(e.p,{children:["如下图所示，整个低代码平台项目划分为服务端和客户端，服务端的话已经单独摘出去做一个独立的仓库维护，客户端相关的存放目前考虑用微前端来做挂载，后续通过主工程将所有微应用进行收敛。剩下的就是为低代码平台提供支撑的底层逻辑 ",(0,s.jsx)(e.strong,{children:"SDK"}),"，在客户端接入尽可能的快速便捷，无明显心智负担。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:h,alt:"工程样板.drawio (1).png"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:a,alt:"Untitled (2).png"})}),"\n",(0,s.jsxs)(e.p,{children:["接下来就是创建一些包的资源 ",(0,s.jsx)(e.strong,{children:"Diff"})," 通过它们来理解当前的文件目录变更。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"lgnition-web           \n├─ app                                           \n+     main                                   \n+     editor     \n+     ...\n├─ package                                     \n+     core                            \n+     materials                                   \n+     render   \n+     ...\n├─ LICENSE\n├─ README.md\n├─ package.json\n├─ pnpm-lock.yaml\n└─ pnpm-workspace.yaml\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"eslint",children:["ESLint",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#eslint",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["对于现在开发项目来说，",(0,s.jsx)(e.strong,{children:"ESLint"})," 规范已经成为必不可少的一个环节。减少了不同开发者代码差异化以及一些常规的错误语法校验。"]}),"\n",(0,s.jsxs)(e.p,{children:["对于 ",(0,s.jsx)(e.strong,{children:"Monorepo"})," 的仓库来说，可以在主仓库中创建 ",(0,s.jsx)(e.strong,{children:"ESLint"})," 的检查规则，然后作用于所有子项目。"]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:["在传统的 ",(0,s.jsx)(e.strong,{children:"Multirepos"})," 仓库中，我们需要为每一个项目都创建 ",(0,s.jsx)(e.strong,{children:"ESLint"}),"，这很明显是一个冗余的事情。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["下面，我就来带大家一步一步安装 ",(0,s.jsx)(e.strong,{children:"ESLint"}),"，并配置好对应的规则检查。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"首先"}),"：给全局安装 ",(0,s.jsx)(e.strong,{children:"ESLint"})," 和 ",(0,s.jsx)(e.strong,{children:"TypeScript"}),"。通过 ",(0,s.jsx)(e.strong,{children:"pnpm"})," 使用下面的命令进行安装："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-csharp",children:"# -D 运行时依赖\n# -w 标识全局安装 @\npnpm add eslint typescript -Dw\n"})}),"\n",(0,s.jsx)(e.p,{children:"当出现如下信息说明安装完成了。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"devDependencies:\n+ typescript 4.6.3\n+ eslint 8.12.0\n"})}),"\n",(0,s.jsxs)(e.p,{children:["使用 ",(0,s.jsx)(e.code,{children:"eslint --init"})," 可以初始化项目的相关 ",(0,s.jsx)(e.strong,{children:"ESLint"})," 配置，并生成 eslintrc.js 文件。执行命令后如下图，会提示选择一些相关的项目信息。可以查阅官方文档：",(0,s.jsx)(e.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Feslint.org%2Fdocs%2Fuser-guide%2Fconfiguring%2F",target:"_blank",rel:"noopener noreferrer",children:"查看配置"}),"。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsx)(e.p,{children:"项目根目录下，会自动创建如下两个文件。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"  lgnition-web           \n├─ app                                           \n+     main                                   \n+     editor     \n+     ...\n├─ package                                     \n+     core                            \n+     materials                                   \n+     render   \n+     ...\n├─ LICENSE\n+ .eslintignore\n+ .eslintrc.js\n├─ README.md\n├─ package.json\n├─ pnpm-lock.yaml\n└─ pnpm-workspace.yaml\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"此时"}),"：我们项目的 ",(0,s.jsx)(e.strong,{children:"ESLint"})," 就创建好了，下面就可以选择一个用户群体较为广泛规范化的库作为基础，然后根据自己的习惯进行额外的配置。"]}),"\n",(0,s.jsxs)(e.p,{children:["我个人比较喜欢 ",(0,s.jsx)(e.strong,{children:"standard"})," 这个库，下面就以 ",(0,s.jsx)(e.strong,{children:"standard"})," 做为使用教程来安装如下依赖："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-shell",children:"pnpm install @typescript-eslint/parser eslint-config-standard eslint-config-standard-jsx eslint-plugin-import eslint-plugin-node eslint-plugin-promise -D -w\n"})}),"\n",(0,s.jsxs)(e.p,{children:["安装完成后，修改 ",(0,s.jsx)(e.code,{children:".eslintrc.js"})," 加载规则配置。我的配置看起来是下面这样的，将 ",(0,s.jsx)(e.strong,{children:"parser"})," 更换为 ",(0,s.jsx)(e.strong,{children:"@typescript-eslint/parser"})," 来支持 ",(0,s.jsx)(e.strong,{children:"TypeScript"}),"。通过 ",(0,s.jsx)(e.strong,{children:"extends"})," 继承 ",(0,s.jsx)(e.strong,{children:"standard standard-jsx"})," 来支持 ",(0,s.jsx)(e.strong,{children:"JS & JSX"})," 模式。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"module.exports = {\n  env: {\n    node: true,\n    es2021: true,\n    browser: true\n  },\n  extends: [\n+    'standard',\n+    'standard-jsx'\n  ],\n+  parser: '@typescript-eslint/parser',\n  rules: {\n     // 自定义规则\n+    'no-unused-vars': 'off',\n+    'no-useless-constructor': 'off'\n  }\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"VSCode"})," 的 ",(0,s.jsx)(e.strong,{children:"ESLint"})," 插件此时已经识别到了我们项目中的不规范代码，会出现波浪线提示纠正。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsxs)(e.p,{children:["通过执行 ",(0,s.jsx)(e.code,{children:"eslint --ext .js,.jsx,.ts,.tsx"})," ，来试试看命令行的不规范代码检查是否是能够使用的，可以正常检测的话，将命令添加到根目录 ",(0,s.jsx)(e.strong,{children:"package.json"})," 执行脚本当中："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:'"script": {\n+    "lint:js": "eslint --ext .js,.jsx,.ts,.tsx ./",\n+    "lint:fix": "eslint --fix --cache --ext .js,.jsx,.ts,.tsx ./"\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["执行 ",(0,s.jsx)(e.strong,{children:"lint"})," 脚本后，会将 ",(0,s.jsx)(e.strong,{children:"Error"})," 和 ",(0,s.jsx)(e.strong,{children:"Warning"})," 都输出在控制台。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsxs)(e.p,{children:["此时，我们的全局",(0,s.jsx)(e.strong,{children:"ESLint"}),"规则就配置完毕了，后续在子项目当中开发时，就不需要再重新配置一遍规则检查，会直接使用全局的规范提示。此时，",(0,s.jsx)(e.strong,{children:"Lint"})," 会对整个项目都进行规则扫描，包括下面的子应用和子包都能享受到对应的规则检查。"]}),"\n",(0,s.jsxs)(e.h3,{id:"子包subpackage构建",children:["子包(SubPackage)构建",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#子包subpackage构建",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["在项目开发中，需要构建我们的一些 ",(0,s.jsx)(e.strong,{children:"Npm"})," 包。对于我们来说，",(0,s.jsx)(e.strong,{children:"Webpack"}),"、",(0,s.jsx)(e.strong,{children:"Rollup"})," 这些打包工具配置无疑是繁琐的。因此，我们需要一个开箱即用的打包构建工具。"]}),"\n",(0,s.jsxs)(e.p,{children:["基于这些因素，我选择了 ",(0,s.jsx)(e.strong,{children:"Microbundle"}),"、",(0,s.jsx)(e.strong,{children:"Tsdx"}),"、",(0,s.jsx)(e.strong,{children:"Vite"})," 这几个比较方便的构建库。通过 ",(0,s.jsx)(e.a,{href:"https://npmtrends.com/microbundle-vs-tsdx-vs-vite",target:"_blank",rel:"noopener noreferrer",children:"npm trends"})," 将它们进行比对后都是基于 ",(0,s.jsx)(e.strong,{children:"Rollup"})," 的模式，可以通过低配置的方式快速产出 ",(0,s.jsx)(e.strong,{children:"UMD"}),"、",(0,s.jsx)(e.strong,{children:"ESM"})," 等模块产物。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["最终，我拟定了 ",(0,s.jsx)(e.strong,{children:"Vite"})," 作为依赖库的构建工具，原因有以下几个方面："]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["都是通过预置 ",(0,s.jsx)(e.strong,{children:"Rollup"})," 配置作为构建工具，",(0,s.jsx)(e.strong,{children:"Vite"})," 不仅仅支持类库的打包，同时还可以作为 ",(0,s.jsx)(e.strong,{children:"Bundless"})," 构建器，后续快速移动 ",(0,s.jsx)(e.strong,{children:"Demo"})," 服务，有利于调试；"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Vite"})," 社区生态好，维护力度大，插件维护也可观，方便后续进行集成扩展。"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["下面，我将 ",(0,s.jsx)(e.strong,{children:"Vite"})," 使用过程中会碰到的问题做一个汇总，并构建我们的第一个依赖库。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"首先"}),"，使用 ",(0,s.jsx)(e.code,{children:"pnpm create"})," 快速选择创建需要的模板项目。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"pnpm create vite core --template react-ts\n"})}),"\n",(0,s.jsx)(e.p,{children:"初始化后，整体的目录结构非常的简单，如下所示："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"core\n+  src\n+  package.json                         \n+  tsconfig.json\n+  vite.config.ts\n"})}),"\n",(0,s.jsx)(e.p,{children:"接下来就是配置相关的构建信息了："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["在 ",(0,s.jsx)(e.strong,{children:"build"})," 中声明好入口文件和出口文件，也就是 ",(0,s.jsx)(e.strong,{children:"lib"})," 当中的信息；"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"TypeScript"})," 支持，使用 ",(0,s.jsx)(e.strong,{children:"vite-plugin-dts"})," 插件进行一些类型的打包输出；"]}),"\n",(0,s.jsxs)(e.li,{children:["对于一些公用模块，如 ",(0,s.jsx)(e.strong,{children:"React"}),"，需要使用 ",(0,s.jsx)(e.strong,{children:"external"})," 将其排除，避免后续产生的重复的模块依赖代码没有被 ",(0,s.jsx)(e.strong,{children:"tracking"})," 掉；"]}),"\n",(0,s.jsxs)(e.li,{children:["定义好全局 ",(0,s.jsx)(e.strong,{children:"UMD"})," 的关键信息，避免因为环境缺少相关依赖而出现问题。"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-diff",children:"import react from \"@vitejs/plugin-react\";\nimport dts from 'vite-plugin-dts'\n\nexport default {\n  plugins: [\n+    react(),\n+    dts()],\n  build: {\n    lib: {\n+      entry: 'src/index.ts',\n+      fileName: (format) => `index.${format}.js`\n    },\n+    rollupOptions: {\n      // 排除 React 和 React DOM，因为这些库应该由使用你的库的项目来提供\n+      external: ['react', 'react-dom'],\n+      output: {\n+        // 配置 UMD 格式，使你的组件库可以在不同的环境中使用\n+       globals: {\n+          react: 'React',\n+          'react-dom': 'ReactDOM'\n+        },\n+        // 配置 minify 选项，使输出文件更小\n+        minifyInternalExports: true\n      }\n    }\n  }\n};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["通过以上的简单配置，基本上能够完成 ",(0,s.jsx)(e.strong,{children:"80%"})," 的类库构建支持，剩下的类似 ",(0,s.jsx)(e.strong,{children:"StoryBook"})," 和 ",(0,s.jsx)(e.strong,{children:"TailwindCss"})," 等都是可以通过插件来快速初始化集成。"]}),"\n",(0,s.jsxs)(e.h2,{id:"构建",children:["构建",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#构建",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["由于我们是一个 ",(0,s.jsx)(e.strong,{children:"MonoRepo"})," 的项目，必不可少的就是子包与子包之间的相互依赖，子包与应用之间的相互依赖，所以为了更好的流程化构建项目，对整个工程需要一个好的工具来管理工作区和任务，标准杯构建的工作流程。"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Turborepo"})," 是一个针对 ",(0,s.jsx)(e.strong,{children:"JavaScript"})," 和 ",(0,s.jsx)(e.strong,{children:"TypeScript"})," 代码库优化的智能构建系统。如下官方图所示，通过它可以快速组织项目工程中的 ",(0,s.jsx)(e.strong,{children:"build"}),"、",(0,s.jsx)(e.strong,{children:"lint"}),"、",(0,s.jsx)(e.strong,{children:"test"})," 等 ",(0,s.jsx)(e.strong,{children:"CI"})," 流程阶段需要做的事情。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,s.jsxs)(e.p,{children:["那么，如何在已有的 ",(0,s.jsx)(e.strong,{children:"Monorepo"})," 项目中添加 ",(0,s.jsx)(e.strong,{children:"Tubro"})," 呢？可以参考《",(0,s.jsx)(e.a,{href:"https://turbo.build/repo/docs/getting-started/existing-monorepo",target:"_blank",rel:"noopener noreferrer",children:"Add Turborepo to your existing monorepo"}),"》安装相应的依赖包。安装完成后，在本地创建 **turbo.json ** 配置文件。"]}),"\n",(0,s.jsxs)(e.p,{children:["如下是工程中的基本内容配置，主要是用于构建 ",(0,s.jsx)(e.strong,{children:"CI"})," 使用。在工程 ",(0,s.jsx)(e.strong,{children:"package"})," 中执行 ",(0,s.jsx)(e.code,{children:"turbo run build --filter @lgnition-web/editor"})," 即可完成构建编辑器应用的相关任务。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",children:'{\n  "pipeline": {\n    "build": {\n      "dependsOn": [\n        "^build"\n      ],\n      "outputs": [\n        "dist/**",\n        ".next/**"\n      ]\n    },\n    "test": {\n      "dependsOn": ["build"],\n      "inputs": ["test/**/*.ts", "test/**/*.tsx"]\n    },\n    "lint": {\n      "outputs": []\n    },\n    "dev": {\n      "cache": false\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:["总结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["通过以上的项目操作与配置，基本上完成了项目的初始化。我们创建了自己的远程仓库，将项目应用与依赖包分别存放在 ",(0,s.jsx)(e.strong,{children:"app"})," 与 ",(0,s.jsx)(e.strong,{children:"package"})," 下管理，最后通过全局配置 ",(0,s.jsx)(e.strong,{children:"ESLint"})," 来做统一的规则检查。"]}),"\n",(0,s.jsxs)(e.p,{children:["针对需要构建的依赖项目，我在后面的项目中都会使用 ",(0,s.jsx)(e.strong,{children:"tsdx"})," 来初始化构建项目，避免我们重复性的创建复杂的 ",(0,s.jsx)(e.strong,{children:"Rollup"})," 工程，可以更好地投入到真实编码当中去。"]}),"\n",(0,s.jsxs)(e.p,{children:["现如今，越来越多火热的项目都在使用 ",(0,s.jsx)(e.strong,{children:"Monorepo"})," 来管理自身的相关拆分代码包。如 ",(0,s.jsx)(e.strong,{children:"Babel"}),"、",(0,s.jsx)(e.strong,{children:"Vue"})," 等知名的开源项目。很多同学以前并没有使用过 ",(0,s.jsx)(e.strong,{children:"pnpm"})," 和 ",(0,s.jsx)(e.strong,{children:"Monorepo"}),"，那么在开始准备跟做这个项目的同时，也可以尝试使用它。我相信你一定会有惊喜和收获。"]}),"\n",(0,s.jsxs)(e.p,{children:["学习完本章节后，我想你一定会对多仓库的 ",(0,s.jsx)(e.strong,{children:"Monpopo"})," 有更加深刻的认识，工作中也能产生更多的思考。"]}),"\n",(0,s.jsxs)(e.h2,{id:"资源推荐",children:["资源推荐",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#资源推荐",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fpnpm.io%2F",target:"_blank",rel:"noopener noreferrer",children:"pnpm"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://juejin.cn/post/6932046455733485575",target:"_blank",rel:"noopener noreferrer",children:"关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?"})}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Feslint.org%2Fdocs",target:"_blank",rel:"noopener noreferrer",children:"ESLint"}),"。"]}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://vitejs.dev/guide/",target:"_blank",rel:"noopener noreferrer",children:"vitejs"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FMonorepo",target:"_blank",rel:"noopener noreferrer",children:"Monorepo"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://turbo.build/repo/docs/core-concepts/monorepos/running-tasks",target:"_blank",rel:"noopener noreferrer",children:"turborepo"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"https://turbo.build/repo/docs/getting-started/existing-monorepo",target:"_blank",rel:"noopener noreferrer",children:"将 Turborepo 添加到您现有的 monorepo"})}),"\n"]})]})}function g(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(j,{...n})}):j(n)}let u=g;g.__RSPRESS_PAGE_META={},g.__RSPRESS_PAGE_META["%E4%BB%8E%200%20%E6%89%93%E9%80%A0%E9%80%9A%E7%94%A8%E5%9E%8B%E4%BD%8E%E4%BB%A3%E7%A0%81%E4%BA%A7%E5%93%81%2F20.%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E6%88%98%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE.md"]={toc:[{text:"创建仓库",id:"创建仓库",depth:3},{text:"初始化项目",id:"初始化项目",depth:3},{text:"Monorepo",id:"monorepo",depth:3},{text:"ESLint",id:"eslint",depth:2},{text:"子包(SubPackage)构建",id:"子包subpackage构建",depth:3},{text:"构建",id:"构建",depth:2},{text:"总结",id:"总结",depth:2},{text:"资源推荐",id:"资源推荐",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);