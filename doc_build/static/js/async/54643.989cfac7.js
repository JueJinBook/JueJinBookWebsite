"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["54643"],{576660:function(e,n,s){s.r(n),s.d(n,{default:()=>k});var i=s(552676),c=s(740453);let r=s.p+"static/image/0a913ee5d11f747b43dcb2f7207c72bd.ef0e6393.webp",d=s.p+"static/image/057105e9ccfeebddcc78c876d6c9322b.f16701c5.webp",l=s.p+"static/image/61f09a5ec4aaa48d10f36f8a8d9f4f35.448832db.webp",a=s.p+"static/image/f49282547bb3db1458ec3534fb0e8c82.4c436293.webp",o=s.p+"static/image/5193c67be9b3c29c3c582fc4009940b9.e4dba806.webp",t=s.p+"static/image/9b5a244bf1104e5eda0505c147b4224a.62ee7b8b.webp",h=s.p+"static/image/eacf5f66c3a275e030bf11924a4cbe56.227e4f0d.webp",p=s.p+"static/image/e0f26deb86767fa75bea13d962d88044.77ba722d.webp",x=s.p+"static/image/a70956783e99f9b57dee3ce00b7e134b.a12814c6.webp",j=s.p+"static/image/dfc40a8a448eb1c062d73933df028a83.970234c7.webp",m=s.p+"static/image/7e449b6106907e15c0f92fb898108fd8.7195a14a.webp",g=s.p+"static/image/8728992508d184ac74de0713346cf303.487c2776.webp";function b(e){let n=Object.assign({p:"p",code:"code",strong:"strong",a:"a",img:"img",h2:"h2",h3:"h3",pre:"pre",ol:"ol",li:"li"},(0,c.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["代码分析工具的应用场景有很多，这一节课我们主要从 ",(0,i.jsx)(n.code,{children:"依赖调用方"})," 角度出发，学习如何实现 ",(0,i.jsx)(n.strong,{children:"“脏调用”拦截"})," 和 ",(0,i.jsx)(n.strong,{children:"CI自动化分析，"})," 本节课讲解的的代码示例都在 ",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})," 下，建议 clone 到本地对照学习。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:g,alt:""})}),"\n",(0,i.jsxs)(n.h2,{id:"脏调用拦截",children:["“脏调用”拦截",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#脏调用拦截",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["第 1 节课程中我们定义了“脏调用”，即 ",(0,i.jsx)(n.code,{children:"依赖调用方"})," 代码中有问题的 API 调用，分析工具可以帮助开发者对“脏调用”进行管控，阻止有问题的代码被提交 / 合入，既然要拦截，让我们先来了解下 ",(0,i.jsx)(n.code,{children:"依赖调用方"})," 业务开发的 Workflow。"]}),"\n",(0,i.jsxs)(n.h3,{id:"workflow",children:["Workflow",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#workflow",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"工作流并不只是前端开发需要掌握的技能，而是程序员的必备技能，它是从项目管理角度根据项目实际情况而制定的开发流程。明确的标准可以避免代码在开发/合并时出现问题，将事故风险降到最低，在迭代过程中，也容易对之前的代码进行回溯。"}),"\n",(0,i.jsx)(n.p,{children:"以下图简化版的 Workflow 为例："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:m,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"release 分支"}),"：项目的发布版本代码，该分支只接受 meger request，通过打 tag 触发 web hook 的方式通知部署平台部署 live 环境，每个 tag 可以理解成 live 发布过的代码版本。"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"master 分支"}),"：是项目的主干代码，代码合并以它为基准，只接受 merge request，禁止直接 push 操作，该分支是 feature 分支合并以及进行集成测试的基准分支。"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"feature 分支"}),"：需求的开发分支，一般从 release 分支拉出，开发测试通过以后，提交 MR 请求合入 master 分支。"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"hotfix 分支"}),"：修复线上 Bug 的临时分支，一般从 release 分支拉出，开发测试通过以后，提交 MR 请求合入 master 分支。"]}),"\n",(0,i.jsxs)(n.p,{children:["上面的 Workflow 展示了 ",(0,i.jsx)(n.code,{children:"feature/hotfix"})," 分支上的代码是如何一步步集成并部署到 live 的。试想一下，如果某个 ",(0,i.jsx)(n.code,{children:"feature"})," 分支中存在“脏调用”代码，",(0,i.jsx)(n.code,{children:"commit"})," 操作会影响自己，",(0,i.jsx)(n.code,{children:"push"})," 操作会影响远端分支，后续的 ",(0,i.jsx)(n.code,{children:"merge"})," 操作则会影响到 ",(0,i.jsx)(n.code,{children:"master"}),"、",(0,i.jsx)(n.code,{children:"release"})," 等重要分支，",(0,i.jsx)(n.code,{children:"tag"})," 操作更是会影响到 live 生产环境部署。"]}),"\n",(0,i.jsxs)(n.p,{children:["可见越往后影响便越大，我们应该在 ",(0,i.jsx)(n.code,{children:"2-5"})," 阶段对",(0,i.jsx)(n.code,{children:"“脏调研”"}),"进行拦截，尽可能将有问题的代码拦截在早期阶段。那么如何在这些阶段通过代码分析工具检测脏调用并进行拦截呢？"]}),"\n",(0,i.jsxs)(n.h3,{id:"git-hook",children:["git hook",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#git-hook",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["git hook 是 git 在执行特定事件如 ",(0,i.jsx)(n.code,{children:"commit"}),"、 ",(0,i.jsx)(n.code,{children:"push"}),"时触发运行的脚本，类似“钩子函数”，在项目",(0,i.jsx)(n.code,{children:".git/hooks"})," 目录中，有一些以 ",(0,i.jsx)(n.code,{children:".sample"})," 结尾的钩子示例脚本，如果想启用对应钩子，只需手动删除后缀即可，默认是不启用的，举个例子：代码分析工具可以结合 ",(0,i.jsx)(n.code,{children:"pre-commit hook"})," 检查“脏”调用，没有通过检测则不允许提交。"]}),"\n",(0,i.jsxs)(n.p,{children:["我们一般不会手动去改 ",(0,i.jsx)(n.code,{children:".git/hooks"})," 里面的文件，可以通过工具来完成这些操作，比如 ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/pre-commit",target:"_blank",rel:"noopener noreferrer",children:"pre-commit"}),"、 ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/husky",target:"_blank",rel:"noopener noreferrer",children:"husky"}),"、 ",(0,i.jsx)(n.a,{href:"https://www.npmjs.com/package/git-scripts",target:"_blank",rel:"noopener noreferrer",children:"git-scripts"})," 等工具都可以帮助开发者添加 git hook，这里我们以 pre-commit 为例："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "code-analysis-code-demo",\n  "version": "0.1.0",\n  "scripts": {\n    "analysis": "ca analysis",\n    "analysis:api": "node ./apiMode.js"\n  },\n  "pre-commit": [\n    "analysis"\n  ],\n  "devDependencies": {\n    "code-analysis-ts": "^1.3.8"\n  },\n  "license": "MIT",\n  "engines": {\n    "node": ">= 14.0.0",\n    "npm": ">= 4.0.0"\n  },\n  "dependencies": {\n    "pre-commit": "^1.2.2"\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["上面的 package.json 信息来自 ",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo",target:"_blank",rel:"noopener noreferrer",children:"code-demo"})," 项目，执行 npm install 就会安装相应的 ",(0,i.jsx)(n.code,{children:"git hook"}),"，然后提交更改会触发下图的 ",(0,i.jsx)(n.code,{children:"hook"})," 拦截效果："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:j,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["PS：如果执行 ",(0,i.jsx)(n.code,{children:"git commit"})," 后没有触发检查，要检查下是否正常安装了 hook，可以到",(0,i.jsx)(n.code,{children:".git/hooks"})," 目录下查看是否有类似 ",(0,i.jsx)(n.code,{children:"pre-commit"})," 的脚本文件，没有的话可以尝试重新安装 pre-commit。如果有脚本文件但是没执行，可以尝试删除 hooks 文件夹后重新安装，注意如果有提前设置好的其他钩子，请谨慎删除 ",(0,i.jsx)(n.code,{children:"hooks"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["仅仅通过 ",(0,i.jsx)(n.code,{children:"pre-commit"})," 这样的 hook 来拦截代码有一个问题：开发者可以在 git commit 时添加 ",(0,i.jsx)(n.code,{children:"--no-verify"})," 来跳过 hook 从而躲避检查。"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// 跳过hook\ngit commit -m 'feat: add commit' --no-verify\n"})}),"\n",(0,i.jsxs)(n.p,{children:["也就是说，虽然在 ",(0,i.jsx)(n.code,{children:"commit"})," 时拦截是最佳的阶段，但存在被绕过的可能性，这样就导致",(0,i.jsx)(n.code,{children:"“脏调用”"}),"代码流入了下一阶段，所以 Workflow ",(0,i.jsx)(n.code,{children:"2-5"})," 阶段也应该做拦截检查，不能漏过任意环节。但是本地分支代码在 push 到远端后，后续集成都发生在 GitLab Server 了，如何进行后续拦截呢？"]}),"\n",(0,i.jsxs)(n.h3,{id:"gitlab-ci",children:["GitLab CI",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#gitlab-ci",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"持续集成（Continuous Integration）"}),"， 即在源代码变更后可以自动触发检测、单元测试、构建等任务的自动化过程，目标是快速确保开发人员新提交的代码是好的（少 Bug）。"]}),"\n",(0,i.jsxs)(n.p,{children:["很多公司部署了 ",(0,i.jsx)(n.code,{children:"GitLab"})," 来管理代码仓库，而 ",(0,i.jsx)(n.code,{children:"GitLab"})," 本身便集成了 CI 能力，当 ",(0,i.jsx)(n.code,{children:"push"})," 代码或者发起 ",(0,i.jsx)(n.code,{children:"PR"})," 时，",(0,i.jsx)(n.code,{children:"GitLab"})," 会扫描仓库根目录查看是否存在 ",(0,i.jsx)(n.strong,{children:".gitlab-ci.yml"})," 文件，并对其进行语法分析，将文件中用户自定义的脚本提取出来，发送到 ",(0,i.jsx)(n.code,{children:"GitLab-runner"})," 服务器进行执行，之后将执行的结果反馈到 ",(0,i.jsx)(n.code,{children:"GitLab"})," 网页端，这样一个自动触发执行脚本的机制被称为流水线 ",(0,i.jsx)(n.code,{children:"pipeline"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["对于 GitLab CI 还不熟悉的同学推荐先看下这篇文章： ",(0,i.jsx)(n.a,{href:"https://juejin.cn/post/6844904045581172744",target:"_blank",rel:"noopener noreferrer",children:"GitLab-CI 使用教程"})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:".gitlab-ci.yml："})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# 15.应用场景：“脏调用”拦截 & CI 自动化分析\nimage: node:14\n               \n# 流水线有1个阶段，名叫analysis\nstages:\n  - analysis\n\n# 在每个任务开始之前需要执行的命令\nbefore_script:\n  - npm install\n\n# 执行代码分析\nwork:                                # job name\n  stage: analysis                    # 归属于analysis阶段\n  only:                              \n    - master                         # master分支发生变化时触发Pipeline\n    - release                        # release分支发生变化时触发Pipeline\n    - tags                           # 打tag时触发Pipeline\n  script:\n    - npm run analysis               # 执行代码分析脚本\n"})}),"\n",(0,i.jsxs)(n.p,{children:["上面的 ",(0,i.jsx)(n.strong,{children:".gitlab-ci.yml"})," 文件表示在 ",(0,i.jsx)(n.code,{children:"master"}),"、",(0,i.jsx)(n.code,{children:"release"})," 分支代码发生变化或者打 ",(0,i.jsx)(n.code,{children:"tag"})," 时，会触发一个流水线 ",(0,i.jsx)(n.code,{children:"pipeline"}),"，流水线会经历 1 个名叫 ",(0,i.jsx)(n.code,{children:"analysis"})," 的阶段，而 ",(0,i.jsx)(n.code,{children:"analysis"})," 阶段包含 1 个名叫 ",(0,i.jsx)(n.code,{children:"work"})," 的 job，每个任务在执行前，需要先执行脚本命令 ",(0,i.jsx)(n.code,{children:"npm install"}),"，在执行 ",(0,i.jsx)(n.code,{children:"work"})," 这个任务时，会执行脚本 ",(0,i.jsx)(n.code,{children:"npm run analysis"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["下图是触发 ",(0,i.jsx)(n.code,{children:"pipeline"})," 后 web 页面的截图："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:x,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["从 CI 流水线任务执行的结果来看，",(0,i.jsx)(n.code,{children:"work"})," 任务失败了，可以点击下面的 ",(0,i.jsx)(n.code,{children:"work"})," 任务查看任务流水日志："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:p,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["从执行日志可以看到，因为代码中存在黑名单调用，导致代码评分低于配置阈值，分析进程主动抛出异常，阻止了代码合入操作，成功拦截了",(0,i.jsx)(n.code,{children:"“脏调用”"}),"合入。"]}),"\n",(0,i.jsxs)(n.h2,{id:"自动化分析",children:["自动化分析",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自动化分析",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["下图展示的是 ",(0,i.jsx)(n.code,{children:"GitLab CI"})," 触发 ",(0,i.jsx)(n.code,{children:"Pipeline"})," 的几种方式，除了代码变更、手动执行等方式，我们还可以通过创建定时任务来触发 ",(0,i.jsx)(n.code,{children:"pipeline"}),"，进而实现自动化分析。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:h,alt:""})}),"\n",(0,i.jsxs)(n.h3,{id:"gitlab-pages",children:["GitLab Pages",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#gitlab-pages",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"GitLab"})," 本身提供了搭建静态站点的功能 ",(0,i.jsx)(n.code,{children:"GitLab Pages"}),"，通过它可以部署指定目录下的静态资源，比如我们的代码分析报告 html。"]}),"\n",(0,i.jsxs)(n.p,{children:["需要注意的一点是，",(0,i.jsx)(n.code,{children:"GitLab"})," 配置 Pages 时的 ",(0,i.jsx)(n.code,{children:"job"})," 名称必须为 ",(0,i.jsx)(n.code,{children:"pages"}),"，放置静态资源的目录名必须为 ",(0,i.jsx)(n.code,{children:"public"}),"，不然不会生效，下面是 ",(0,i.jsx)(n.strong,{children:".gitlab-ci.yml"})," 的配置 demo："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# 任务指定镜像\nimage: node:14\n\n# 流水线有2个阶段，先执行analysis阶段的任务，然后执行depoly阶段的任务\nstages:\n  - analysis\n  - deploy\n\n# 在每个任务开始之前需要执行的命令\nbefore_script:\n  - npm install\n\n# 执行代码分析\nwork:                            # job name\n  stage: analysis                # 归属于analysis阶段\n  only:\n    - master                     # master分支发生变化时触发Pipeline\n  script:\n    - npm run analysis           # 任务执行脚本\n  artifacts:                     \n    paths:                       # 缓存文件夹，可以在CI流水线任务 UI 界面中下载\n      - docs                     # 代码分析报告生成目录，与analysis.config.js配置保持一致\n\n# 部署pages\npages:                           # job name\n  stage: deploy                  # 归属于deploy阶段\n  only:\n    - master                     # master分支发生变化时触发Pipeline\n  when: on_success               # 前一阶段所有任务成功时才执行\n  script:\n    - mkdir -p public            # 执行脚本创建public目录\n    - mv docs/* public           # 执行脚本将docs目录下的代码分析报告相关静态文件复制到public目录\n  dependencies:                 \n    - work                       # 依赖work job\n  artifacts:            \n    paths:\n      - public                   # 声明gitlab Pages静态资源目录\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Pages 的查看方式可以在 ",(0,i.jsx)(n.code,{children:"Settings >> Pages"})," 中，蓝色网址就是部署后代码分析报告的 URL 地址。"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:t,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["（ps：图上所示网址只是一个例子，code-demo 的分析报告可以看 ",(0,i.jsx)(n.a,{href:"https://liangxin199045.github.io/code-demo/",target:"_blank",rel:"noopener noreferrer",children:"这里"}),"）"]}),"\n",(0,i.jsxs)(n.h3,{id:"推送报告--告警",children:["推送报告 / 告警",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#推送报告--告警",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["代码分析任务结束后，如果发现",(0,i.jsx)(n.code,{children:"“脏调用”"}),"，我们希望可以向开发者推送告警消息，如果分析结果没问题，则向开发者推送查阅分析报告的 URL 地址。那么如何实现消息推送呢？"]}),"\n",(0,i.jsx)(n.p,{children:"企业内部的即时通讯软件（如：企业微信、飞书、钉钉，或者其它自研）基本都支持 Bot 机器人功能，即暴露一个 API 接口给应用，开发者只需按照固定参数调用这个 API 接口，即可让机器人给群，或者个人发消息，我们可以把消息推送的操作封装成 shell 脚本。"}),"\n",(0,i.jsxs)(n.p,{children:["推送报告的 shell 脚本示例，",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo/blob/main/notification.sh",target:"_blank",rel:"noopener noreferrer",children:"notification.sh"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'#!/bin/bash\n\ncurl \'https://iceman.com/webhook/group/xxxxxxxxxx1nWVtDQ\' \\\n     -H \'Content-Type: application/json\' \\                        \n     -d \'                        \n     {                                        \n         "tag": "text",                                        \n         "text": {                                                        \n              "content": "\\n分析项目: Code-Demo\\n分析报告: https://iceman.com/code-demo/",\n              "at_all": true                                        \n         }                        \n     }\'\n'})}),"\n",(0,i.jsxs)(n.p,{children:["代码告警的 shell 脚本示例，",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo/blob/main/alert.sh",target:"_blank",rel:"noopener noreferrer",children:"alert.sh"})," ："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'#!/bin/bash\n\ncurl \'https://iceman.com/webhook/group/xxxxxxxxxx1nWVtDQ\' \\\n     -H \'Content-Type: application/json\' \\                        \n     -d \'                        \n     {                                        \n         "tag": "text",                                        \n         "text": {                                                        \n              "content": "\\n代码告警: Code-Demo\\n流水日志: https://iceman.com/code-demo/-/jobs/20051072",\n              "at_all": true                                        \n         }                        \n     }\'\n'})}),"\n",(0,i.jsxs)(n.p,{children:["然后我们完善一下 ",(0,i.jsx)(n.a,{href:"https://github.com/liangxin199045/code-demo/blob/main/.gitlab-ci.yml",target:"_blank",rel:"noopener noreferrer",children:".gitlab-ci.yml"})," 文件："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"# 任务指定镜像\nimage: node:14\n\n# 流水线有2个阶段，先执行analysis阶段的任务，然后执行depoly阶段的任务\nstages:\n  - analysis\n  - deploy\n\n# 在每个任务开始之前需要执行的命令\nbefore_script:\n  - npm install\n\n# 执行代码分析\nwork:                            # job name\n  stage: analysis                # 归属于analysis阶段\n  only:\n    - master                     # master分支发生变化时触发Pipeline\n  script:\n    - npm run analysis           # 任务执行脚本\n  artifacts:                     \n    paths:                       # 缓存文件夹，可以在CI流水线任务 UI 界面中下载\n      - docs                     # 代码分析报告生成目录，与analysis.config.js配置保持一致\n\n# 部署pages\npages:                           # job name\n  stage: deploy                  # 归属于deploy阶段\n  only:\n    - master                     # master分支发生变化时触发Pipeline\n  when: on_success               # 前一阶段所有任务成功时才执行\n  script:\n    - mkdir -p public            # 执行脚本创建public目录\n    - mv docs/* public           # 执行脚本将docs目录下的代码分析报告相关静态文件复制到public目录\n    - bash ./notification.sh     # 推送代码分析报告消息\n  dependencies:                 \n    - work                       # 依赖work job\n  artifacts:            \n    paths:\n      - public                   # 声明gitlab Pages静态资源目录\n\n# 代码告警\nalert:\n  stage: deploy                  # 归属于deploy阶段\n  only:\n    - master                     # master分支发生变化时触发Pipeline\n  when: on_fail                  # 前一阶段所有任务成功时才执行\n  script:\n    - bash ./alert.sh            # 推送代码分析报告消息\n  dependencies:                 \n    - work                       # 依赖work job\n"})}),"\n",(0,i.jsx)(n.p,{children:"完成文件配置后，我们在项目中创建一个 CI 定时任务："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:o,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"定时任务触发后的任务页面演示（示例）："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:a,alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["分析任务顺利完成，会推送包含报告URL的消息，点击地址就可以查看 ",(0,i.jsx)(n.a,{href:"https://liangxin199045.github.io/code-demo/",target:"_blank",rel:"noopener noreferrer",children:"在线报告"})," 了（示例）："]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:l,alt:""})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:d,alt:""})}),"\n",(0,i.jsx)(n.p,{children:"如果分析时触发代码告警，则推送告警消息，开发者点击URL可以打开任务流水日志定位问题（示例）："}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)("img",{src:r,alt:""})}),"\n",(0,i.jsxs)(n.h2,{id:"小结",children:["小结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这一小节我们学习了如何通过代码分析工具实现“脏调用”拦截 & CI 自动化分析，需要大家掌握以下知识点："}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["可以通过 ",(0,i.jsx)(n.code,{children:"git hook"})," 在 ",(0,i.jsx)(n.code,{children:"commit"})," 阶段对存在",(0,i.jsx)(n.code,{children:"“脏调用”"}),"的代码进行拦截，防止其提交，但这种方式可以被绕过，因此我们需要在 Workflow 各个阶段都进行拦截。"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"gitLab Pages"})," 功能可以部署指定目录下的静态资源，这样代码分析报告 html 就能以域名 URL 的方式被访问了。"]}),"\n",(0,i.jsxs)(n.li,{children:["通过创建定时任务来触发 ",(0,i.jsx)(n.code,{children:"gitLab CI"})," 的 ",(0,i.jsx)(n.code,{children:"pipeline"}),"，可以实现 CI 自动化分析。"]}),"\n",(0,i.jsxs)(n.li,{children:["需要熟练掌握配置 ",(0,i.jsx)(n.strong,{children:".gitlab-ci.yml"})," 文件，它是驱动 ",(0,i.jsx)(n.code,{children:"gitLab CI"})," 工作的基础。"]}),"\n"]})]})}function f(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(b,{...e})}):b(e)}let k=f;f.__RSPRESS_PAGE_META={},f.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E6%B2%BB%E7%90%86%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F15.%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A%E2%80%9C%E8%84%8F%E8%B0%83%E7%94%A8%E2%80%9D%E6%8B%A6%E6%88%AA%20%26%20CI%20%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90.md"]={toc:[{text:"“脏调用”拦截",id:"脏调用拦截",depth:2},{text:"Workflow",id:"workflow",depth:3},{text:"git hook",id:"git-hook",depth:3},{text:"GitLab CI",id:"gitlab-ci",depth:3},{text:"自动化分析",id:"自动化分析",depth:2},{text:"GitLab Pages",id:"gitlab-pages",depth:3},{text:"推送报告 / 告警",id:"推送报告--告警",depth:3},{text:"小结",id:"小结",depth:2}],title:"",headingTitle:"",frontmatter:{}}}}]);