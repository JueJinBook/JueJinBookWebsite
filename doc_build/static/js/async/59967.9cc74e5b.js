"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["59967"],{466901:function(e,n,r){r.r(n),r.d(n,{default:()=>v});var c=r(552676),t=r(740453);let s=r.p+"static/image/af6ad41ed4934974880841150040888c.87d3a33b.webp",d=r.p+"static/image/24cec1ee4200265e5c4be96c056772fd.821b4383.webp",i=r.p+"static/image/0f7639eb246856cb5c592708045ff241.e94e2a03.webp",a=r.p+"static/image/71d16e99161120a6d6b6e68a6d264e8e.bf897a07.webp",o=r.p+"static/image/ecf849906696b349bfa00757568abfca.eb765cbb.webp",l=r.p+"static/image/7789ad4d1d531da62543c798aa47d03b.c8992ff1.webp",h=r.p+"static/image/a84fa996c666a44ee44f688cd1572eb4.6b4ee4e2.webp",p=r.p+"static/image/ce4939380eedb23b695aadcdca34235f.97271f00.webp",u=r.p+"static/image/d6bf0a077082feb30947b83612c08cc8.f80c7243.webp",x=r.p+"static/image/435d0223349101a684871dac8bc4615e.7271e92b.webp",j=r.p+"static/image/7c195249df0007e75a23e19cd3d9cd00.3faeb949.webp",m=r.p+"static/image/700a272d42fa824e902781dd0ca8c924.9332806b.webp",g=r.p+"static/image/a56a55e3e4a1aa9cdd03a83a808faaac.a09aa4da.webp";function f(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",img:"img",h4:"h4",strong:"strong",ul:"ul",li:"li",blockquote:"blockquote"},(0,t.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"11vue-router4-新旧路由方法对比",children:["11.Vue-Router4 新旧路由方法对比",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11vue-router4-新旧路由方法对比",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"前言",children:["前言",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在平时的业务开发中，",(0,c.jsx)(n.code,{children:"Vue-Router"})," 是必不可少的插件，它的作用也很明确，就是通过路径匹配出响应的组件，单页面有了它，才算是如虎添翼，否则就是一只 ",(0,c.jsx)(n.code,{children:"Hello Kitty"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"接下通过实例讲解和原理分析，把路由这块知识吃透。"}),"\n",(0,c.jsxs)(n.h2,{id:"初始化",children:["初始化",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["通过 ",(0,c.jsx)(n.code,{children:"Vite"})," 初始化一个空项目，运行指令："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"npm init @vitejs/app vue3-vite --template vue\n"})}),"\n",(0,c.jsxs)(n.p,{children:["创建两个页面，用于路由切换，在 ",(0,c.jsx)(n.code,{children:"src"})," 目录下新建 ",(0,c.jsx)(n.code,{children:"views"})," 目录，添加 ",(0,c.jsx)(n.code,{children:"Home.vue"})," 和 ",(0,c.jsx)(n.code,{children:"About.vue"})," 文件，如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--Home.vue--\x3e\n<template>\n  Home\n</template>\n\n<script>\nexport default {\n  name: 'Home'\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--About.vue--\x3e\n<template>\n  About\n</template>\n\n<script>\nexport default {\n  name: 'About'\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["然后通过 ",(0,c.jsx)(n.code,{children:"npm install vue-router@next"})," 下载最新的路由插件。成功之后，在 ",(0,c.jsx)(n.code,{children:"src"})," 目录下新建 ",(0,c.jsx)(n.code,{children:"router/index.js"}),"，添加如下代码："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import { createRouter, createWebHashHistory } from 'vue-router'\n\nimport Home from '../views/Home.vue'\nimport About from '../views/About.vue'\n\nconst router = createRouter({\n  history: createWebHashHistory(), // createWebHashHistory 为哈希模式的路由，如果需要选择 histiry 模式，可以用 createWebHistory 方法。\n  routes: [ // routes 属性和 vue-router 3 的配置一样，通过数组对象的形式，配置路径对应展示的组件。\n    {\n      path: '/',\n      name: '/',\n      component: Home\n    },\n    {\n      path: '/about',\n      name: 'about',\n      component: About\n    }\n  ]\n})\n\nexport default router\n"})}),"\n",(0,c.jsxs)(n.p,{children:["完成上述操作之后，我们来到 ",(0,c.jsx)(n.code,{children:"main.js"})," 把上述通过 ",(0,c.jsx)(n.code,{children:"export default router"})," 抛出的路由实例引入 ",(0,c.jsx)(n.code,{children:"Vue"})," 生成的实例，代码如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"import { createApp } from 'vue'\nimport App from './App.vue'\nimport router from '../src/router'\n\n// 生成 app 实例。\nconst app = createApp(App)\n// 通过 use 引入 路由实例。\napp.use(router)\n// 将实例挂载到 #app 节点上。\napp.mount('#app')\n"})}),"\n",(0,c.jsxs)(n.p,{children:["通过指令 ",(0,c.jsx)(n.code,{children:"npm run dev"})," 运行项目，浏览器展示如下所示表示成功："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["如上图所示，",(0,c.jsx)(n.code,{children:"/"})," 匹配到了 ",(0,c.jsx)(n.code,{children:"Home"})," 组件；",(0,c.jsx)(n.code,{children:"/about"})," 匹配到了 ",(0,c.jsx)(n.code,{children:"About"})," 组件。"]}),"\n",(0,c.jsxs)(n.h2,{id:"路由之间的跳转",children:["路由之间的跳转",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由之间的跳转",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"组件之间必定需要通过跳转的形式关联起来，形成一个整体。"}),"\n",(0,c.jsxs)(n.h4,{id:"组件形式跳转",children:["组件形式跳转",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#组件形式跳转",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们可以使用 ",(0,c.jsx)(n.code,{children:"vue-router"})," 为我们提供的全局组件 ",(0,c.jsx)(n.code,{children:"router-link"}),"。修改 ",(0,c.jsx)(n.code,{children:"Home.vue"})," 如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:"<template>\n  <router-link to='/about'>Home</router-link>\n</template>\n\n<script>\nexport default {\n  name: 'Home'\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"浏览器展示如下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"注意上图，浏览器并没有因为点击跳转而刷新页面，这就是路由带来的单页面切换组件能力，在不刷新页面的情况下，改变可视区域的组件。"}),"\n",(0,c.jsxs)(n.p,{children:["假如我们将 ",(0,c.jsx)(n.code,{children:"router-link"})," 换成普通的 ",(0,c.jsx)(n.code,{children:"a"})," 标签 ",(0,c.jsx)(n.code,{children:"href"})," 跳转，也能实现页面组件之间的切换，但是这样就会导致浏览器页面的刷新，这并不是我们的初衷，如下图所示："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsxs)(n.h4,{id:"方法形式跳转",children:["方法形式跳转",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方法形式跳转",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["我们也可以通过调用方法的形式，实现路由的跳转，修改 ",(0,c.jsx)(n.code,{children:"Home.vue"})," 如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <button @click=\"linkTo\">Home</button>\n</template>\n\n<script>\nimport { useRouter } from 'vue-router'\nexport default {\n  name: 'Home',\n  setup() {\n    const router = useRouter()\n    const linkTo = () => {\n      router.push({\n        path: '/about'\n      })\n    }\n\n    return {\n      linkTo\n    }\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["通过 ",(0,c.jsx)(n.code,{children:"useRouter"})," 生成路由实例 ",(0,c.jsx)(n.code,{children:"router"}),"，其内部都是路由相关的方法，如跳转方法、路由守卫、返回方法等等。可以通过打印 ",(0,c.jsx)(n.code,{children:"router"})," 查看内部的一些属性方法。"]}),"\n",(0,c.jsxs)(n.p,{children:["上述代码通过 ",(0,c.jsx)(n.code,{children:"push"})," 方法跳转路由，浏览器如下所示："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"参数传递",children:["参数传递",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参数传递",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["路由参数传递有两种方式，一种是通过浏览器查询字符串的形式，另外一种是通过 ",(0,c.jsx)(n.code,{children:"params"})," 形式传递，我们来逐一分析："]}),"\n",(0,c.jsxs)(n.h4,{id:"浏览器查询字符串-query",children:["浏览器查询字符串 query",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器查询字符串-query",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"router-link"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--Home.vue--\x3e\n<template>\n  <router-link :to=\"{ path: '/about', query: { id: 1 } }\">Home</router-link>\n</template>\n\n<script>\nexport default {\n  name: 'Home'\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"router.push"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <button @click=\"linkTo\">Home</button>\n</template>\n\n<script>\nimport { useRouter } from 'vue-router'\nexport default {\n  name: 'Home',\n  setup() {\n    const router = useRouter()\n    console.log('router', router)\n    const linkTo = () => {\n      router.push({\n        path: '/about',\n        query: {\n          id: 1\n        }\n      })\n    }\n\n    return {\n      linkTo\n    }\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["接收参数的话，我们修改 ",(0,c.jsx)(n.code,{children:"About.vue"})," 如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  About\n</template>\n\n<script>\nimport { useRoute } from 'vue-router'\nexport default {\n  name: 'Abput',\n  setup() {\n    const route = useRoute()\n    const { id } = route.query\n    console.log('id=', id)\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"上述两种形式效果如下图所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsxs)(n.h4,{id:"params-形式",children:["params 形式",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#params-形式",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["如果我们不想污染浏览器查询字符串，但又想通过路由传参，",(0,c.jsx)(n.code,{children:"params"})," 是最好的选择。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"router-link"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"\x3c!--Home.vue--\x3e\n<template>\n  <router-link :to=\"{ name: 'about', params: { id: 1 } }\">Home</router-link>\n</template>\n\n<script>\nexport default {\n  name: 'Home'\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"router.push"}),"："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <button @click=\"linkTo\">Home</button>\n</template>\n\n<script>\nimport { useRouter } from 'vue-router'\nexport default {\n  name: 'Home',\n  setup() {\n    const router = useRouter()\n    const linkTo = () => {\n      router.push({\n        name: 'about',\n        params: {\n          id: 1\n        }\n      })\n    }\n\n    return {\n      linkTo\n    }\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsxs)(n.p,{children:["这里要注意，通过 ",(0,c.jsx)(n.code,{children:"params"})," 穿插，跳转的属性要通过 ",(0,c.jsx)(n.code,{children:"name"})," 来控制，否则是拿不到传递的变量的。"]}),"\n",(0,c.jsxs)(n.p,{children:["接收组件 ",(0,c.jsx)(n.code,{children:"About.vue"})," 修改如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  About\n</template>\n\n<script>\nimport { useRoute } from 'vue-router'\nexport default {\n  name: 'About',\n  setup() {\n    const route = useRoute()\n    const { id } = route.params\n    console.log('id=', id)\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"浏览器展示如下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["这里提醒大家，如果使用 ",(0,c.jsx)(n.code,{children:"params"})," 的形式传参，在目标页面 ",(0,c.jsx)(n.code,{children:"About.vue"})," 手动刷新的话，就拿不到 ",(0,c.jsx)(n.code,{children:"params"})," 参数了，所以我个人使用 ",(0,c.jsx)(n.code,{children:"query"})," 居多。"]}),"\n",(0,c.jsxs)(n.h2,{id:"路由守卫",children:["路由守卫",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由守卫",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["很多时候你需要监听路由的变化，从而来实现一个业务逻辑，那么在全新的 ",(0,c.jsx)(n.code,{children:"Vue-Router 4"})," 中是如何实现路由守卫的呢？"]}),"\n",(0,c.jsxs)(n.h4,{id:"beforeeach-和-aftereach",children:["beforeEach 和 afterEach",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#beforeeach-和-aftereach",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"beforeEach"})," 和 ",(0,c.jsx)(n.code,{children:"afterEach"})," 方法接收一个回调函数，回调函数内可以通过 ",(0,c.jsx)(n.code,{children:"router.currentRoute"}),"拿到当前的路径参数，所以在这里可以监听到路由的变化，我们通过修改 ",(0,c.jsx)(n.code,{children:"App.vue"})," 如下所示："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<template>\n  <router-view></router-view>\n</template>\n\n<script>\nimport { useRouter } from 'vue-router'\nexport default {\n  name: 'App',\n  setup() {\n    const router = useRouter()\n    router.afterEach(() => {\n      console.log('path::', router.currentRoute.value.path)\n    })\n  }\n}\n<\/script>\n"})}),"\n",(0,c.jsx)(n.p,{children:"浏览器表现如下所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"路由原理浅析",children:["路由原理浅析",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#路由原理浅析",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"我们带着三个问题来阅读后续的文章。"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"为什么会出现前端路由？"}),"\n",(0,c.jsx)(n.li,{children:"前端路由解决了什么问题？"}),"\n",(0,c.jsx)(n.li,{children:"前端路由实现的原理是什么？"}),"\n"]}),"\n",(0,c.jsxs)(n.h4,{id:"传统页面",children:["传统页面",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#传统页面",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["这里不纠结叫法，凡是整个项目都是 ",(0,c.jsx)(n.code,{children:"DOM"})," 直出的页面，我们都称它为“传统页面”（",(0,c.jsx)(n.code,{children:"SSR"})," 属于首屏直出，这里我不认为是传统页面的范畴）。那么什么是 ",(0,c.jsx)(n.code,{children:"DOM"}),"\xa0直出呢？简单说就是在浏览器输入网址后发起请求，返回来的 ",(0,c.jsx)(n.code,{children:"HTML"}),"\xa0页面是最终呈现的效果，那就是 ",(0,c.jsx)(n.code,{children:"DOM\xa0"}),"直出。并且每次点击页面跳转，都会重新请求 ",(0,c.jsx)(n.code,{children:"HTML"}),"\xa0资源。耳听为虚，眼见为实。我们以这个地址为例，验证一下上述说法。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://www.cnblogs.com/han-1034683568/p/14126727.html#4773138",target:"_blank",rel:"noopener noreferrer",children:"https://www.cnblogs.com/han-1034683568/p/14126727.html#4773138"})}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["腚眼一看，就能明白上图在描述什么。没错，博客园就是一个传统页面搭建而成的网站，每次加载页面，都会返回 ",(0,c.jsx)(n.code,{children:"HTML"})," 资源以及里面的 ",(0,c.jsx)(n.code,{children:"CSS"})," 等静态资源，组合成一个新的页面。"]}),"\n",(0,c.jsx)(n.p,{children:"“瞎了”的同学，我再教一个方法，就是在浏览器页面右键，点击“显示网页源代码”，打开后如下所示："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["网页上能看到什么图片或文字，你能在上述图片中找到相应的 ",(0,c.jsx)(n.code,{children:"HTML"})," 结构，那也属于传统页面，也就是 ",(0,c.jsx)(n.code,{children:"DOM"})," 直出。"]}),"\n",(0,c.jsxs)(n.h4,{id:"单页面",children:["单页面",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#单页面",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["时代在进步，科技在发展，面对日益增长的网页需求，网页开始走向模块化、组件化的道路。随之而来的是代码的难以维护、不可控、迭代艰难等现象。面临这种情况，催生出不少优秀的现代前端框架，首当其冲的便是 ",(0,c.jsx)(n.code,{children:"React"}),"\xa0、 ",(0,c.jsx)(n.code,{children:"Vue"}),"\xa0、 ",(0,c.jsx)(n.code,{children:"Angular"}),"\xa0等著名单页面应用框架。而这些框架有一个共同的特点，便是“通过 ",(0,c.jsx)(n.code,{children:"JS"})," 渲染页面”。"]}),"\n",(0,c.jsxs)(n.p,{children:["举个例子，以前我们直出 ",(0,c.jsx)(n.code,{children:"DOM"})," ，而现在运用这些单页面框架之后， ",(0,c.jsx)(n.code,{children:"HTML"})," 页面基本上只有一个 ",(0,c.jsx)(n.code,{children:"DOM"})," 入口，大致如下所示："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["所有的页面组件，都是通过运行上图底部的 ",(0,c.jsx)(n.code,{children:"app.js"})," 脚本，挂载到 ",(0,c.jsx)(n.code,{children:'<div id="root"></div>'})," 这个节点下面。用一个极其简单的 ",(0,c.jsx)(n.code,{children:"JS"})," 展示挂载这一个步骤："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<body>\n  <div id=\"root\"></div>\n  <script>\n    const root = document.getElementById('root') // 获取根节点\n    const divNode = document.createElement('div') // 创建 div 节点\n    divNode.innerText = '你妈贵姓？' // 插入内容\n    root.appendChild(divNode) // 插入根节点\n  <\/script>\n</body>\n"})}),"\n",(0,c.jsx)(n.p,{children:"既然单页面是这样渲染的，那如果我有十几个页面要互相跳转切换，咋整！！？？这时候 前端路由 应运而生，它的出现就是为了解决单页面网站，通过切换浏览器地址路径，来匹配相对应的页面组件。我们通过一张丑陋的图片来理解这个过程："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:i,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["前端路由\xa0会根据浏览器地址栏 ",(0,c.jsx)(n.code,{children:"pathname"}),"\xa0的变化，去匹配相应的页面组件。然后将其通过创建 ",(0,c.jsx)(n.code,{children:"DOM"}),"\xa0节点的形式，塞入根节点 ",(0,c.jsx)(n.code,{children:'<div id="root"></div>'}),"\xa0。这就达到了无刷新页面切换的效果，从侧面也能说明正因为无刷新，所以 ",(0,c.jsx)(n.code,{children:"React"}),"、",(0,c.jsx)(n.code,{children:"Vue"}),"、",(0,c.jsx)(n.code,{children:"Angular"}),"\xa0等现代框架在创建页面组件的时候，每个组件都有自己的 生命周期\xa0。"]}),"\n",(0,c.jsxs)(n.h4,{id:"原理",children:["原理",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原理",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["前端路由 插件比较火的俩框架对应的就是 ",(0,c.jsx)(n.code,{children:"Vue-Router"})," 和 ",(0,c.jsx)(n.code,{children:"React-Router"})," ,但是它们的逻辑，归根结底还是一样的，用殊途同归四个字，再合适不过。"]}),"\n",(0,c.jsx)(n.p,{children:"通过分析哈希模式和历史模式的实现原理，让大家对前端路由的原理有一个更深刻的理解。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"哈希模式"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"a"})," 标签锚点大家应该不陌生，而浏览器地址上 ",(0,c.jsx)(n.code,{children:"#"})," 后面的变化，是可以被监听的，浏览器为我们提供了原生监听事件 ",(0,c.jsx)(n.code,{children:"hashchange"}),"，它可以监听到如下的变化："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"点击 a 标签，改变了浏览器地址。"}),"\n",(0,c.jsx)(n.li,{children:"浏览器的前进后退行为。"}),"\n",(0,c.jsxs)(n.li,{children:["通过 ",(0,c.jsx)(n.code,{children:"window.location"})," 方法，改变浏览器地址。"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["接下来我们利用这些特点，去实现一个 ",(0,c.jsx)(n.code,{children:"hash"})," 模式的简易路由： ",(0,c.jsx)(n.a,{href:"https://codepen.io/nick930826/pen/BaLGprx",target:"_blank",rel:"noopener noreferrer",children:"在线运行"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Hash 模式</title>\n</head>\n  <body>\n    <div>\n      <ul>\n        <li><a href=\"#/page1\">page1</a></li>\n        <li><a href=\"#/page2\">page2</a></li>\n      </ul>\n      \x3c!--渲染对应组件的地方--\x3e\n      <div id=\"route-view\"></div>\n    </div>\n  <script type=\"text/javascript\">\n    // 第一次加载的时候，不会执行 hashchange 监听事件，默认执行一次\n    // DOMContentLoaded 为浏览器 DOM 加载完成时触发\n    window.addEventListener('DOMContentLoaded', Load)\n    window.addEventListener('hashchange', HashChange)\n    // 展示页面组件的节点\n    var routeView = null\n    function Load() {\n      routeView = document.getElementById('route-view')\n      HashChange()\n    }\n    function HashChange() {\n      // 每次触发 hashchange 事件，通过 location.hash 拿到当前浏览器地址的 hash 值\n      // 根据不同的路径展示不同的内容\n      switch(location.hash) {\n      case '#/page1':\n        routeView.innerHTML = 'page1'\n        return\n      case '#/page2':\n        routeView.innerHTML = 'page2'\n        return\n      default:\n        routeView.innerHTML = 'page1'\n        return\n      }\n    }\n  <\/script>\n  </body>\n</html>\n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"当然，这是很简单的实现，真正的 hash 模式，还要考虑到很多复杂的情况，大家有兴趣就去看看源码。"}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:"浏览器展示效果如下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"历史模式"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"history"})," 模式会比 ",(0,c.jsx)(n.code,{children:"hash"})," 模式稍麻烦一些，因为 ",(0,c.jsx)(n.code,{children:"history"})," 模式依赖的是原生事件 ",(0,c.jsx)(n.code,{children:"popstate"})," ，下面是来自 ",(0,c.jsx)(n.code,{children:"MDN"})," 的解释："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"小知识：pushState 和 replaceState 都是 HTML5 的新 API，他们的作用很强大，可以做到改变浏览器地址却不刷新页面。这是实现改变地址栏却不刷新页面的重要方法。"}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["包括 ",(0,c.jsx)(n.code,{children:"a"})," 标签的点击事件也是不会被 ",(0,c.jsx)(n.code,{children:"popstate"})," 监听。我们需要想个办法解决这个问题，才能实现 ",(0,c.jsx)(n.code,{children:"history"})," 模式。"]}),"\n",(0,c.jsx)(n.p,{children:"解决思路："}),"\n",(0,c.jsxs)(n.p,{children:["我们可以通过遍历页面上的所有 ",(0,c.jsx)(n.code,{children:"a"})," 标签，阻止 ",(0,c.jsx)(n.code,{children:"a"}),"\xa0标签的默认事件的同时，加上点击事件的回调函数，在回调函数内获取 ",(0,c.jsx)(n.code,{children:"a"})," 标签的 ",(0,c.jsx)(n.code,{children:"href"}),"\xa0属性值，再通过 ",(0,c.jsx)(n.code,{children:"pushState"})," 去改变浏览器的 ",(0,c.jsx)(n.code,{children:"location.pathname"})," 属性值。然后手动执行 ",(0,c.jsx)(n.code,{children:"popstate"})," 事件的回调函数，去匹配相应的路由。逻辑上可能有些饶，我们用代码来解释一下：",(0,c.jsx)(n.a,{href:"https://codepen.io/nick930826/pen/BaLGprx",target:"_blank",rel:"noopener noreferrer",children:"在线地址"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>History 模式</title>\n</head>\n<body>\n  <div>\n    <ul>\n      <li><a href=\"/page1\">page1</a></li>\n      <li><a href=\"/page2\">page2</a></li>\n    </ul>\n    <div id=\"route-view\"></div>\n  </div>\n  <script type=\"text/javascript\">\n    window.addEventListener('DOMContentLoaded', Load)\n    window.addEventListener('popstate', PopChange)\n    var routeView = null\n    function Load() {\n      routeView = document.getElementById('route-view')\n      // 默认执行一次 popstate 的回调函数，匹配一次页面组件\n      PopChange()\n      // 获取所有带 href 属性的 a 标签节点\n      var aList = document.querySelectorAll('a[href]')\n      // 遍历 a 标签节点数组，阻止默认事件，添加点击事件回调函数\n      aList.forEach(aNode => aNode.addEventListener('click', function(e) {\n        e.preventDefault() //阻止a标签的默认事件\n        var href = aNode.getAttribute('href')\n        //  手动修改浏览器的地址栏\n        history.pushState(null, '', href)\n        // 通过 history.pushState 手动修改地址栏，\n        // popstate 是监听不到地址栏的变化，所以此处需要手动执行回调函数 PopChange\n        PopChange()\n      }))\n    }\n    function PopChange() {\n      console.log('location', location)\n      switch(location.pathname) {\n      case '/page1':\n        routeView.innerHTML = 'page1'\n        return\n      case '/page2':\n        routeView.innerHTML = 'page2'\n        return\n      default:\n        routeView.innerHTML = 'page1'\n        return\n      }\n    }\n  <\/script>\n</body>\n</html>\n"})}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"这里注意，不能在浏览器直接打开静态文件，本地直接打开 html 文件用的是 file 协议，\npopstate 监听的是 HTTP 协议，需要通过 web 服务，启动端口去浏览网址。"}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["本章节主要知识点集中在前端路由这块，能完全看完，并且把实现原理捋一遍，我想你应该对现代前端框架会有一个新的理解。包括对 ",(0,c.jsx)(n.code,{children:"Vue-Router 4"})," 的使用也有了初步的了解。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"文档最近更新时间：2022 年 9 月 20 日。"}),"\n"]})]})}function b(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(f,{...e})}):f(e)}let v=b;b.__RSPRESS_PAGE_META={},b.__RSPRESS_PAGE_META["Vue3%20%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F11.Vue-Router4%20%E6%96%B0%E6%97%A7%E8%B7%AF%E7%94%B1%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"初始化",id:"初始化",depth:2},{text:"路由之间的跳转",id:"路由之间的跳转",depth:2},{text:"组件形式跳转",id:"组件形式跳转",depth:4},{text:"方法形式跳转",id:"方法形式跳转",depth:4},{text:"参数传递",id:"参数传递",depth:2},{text:"浏览器查询字符串 query",id:"浏览器查询字符串-query",depth:4},{text:"params 形式",id:"params-形式",depth:4},{text:"路由守卫",id:"路由守卫",depth:2},{text:"beforeEach 和 afterEach",id:"beforeeach-和-aftereach",depth:4},{text:"路由原理浅析",id:"路由原理浅析",depth:2},{text:"传统页面",id:"传统页面",depth:4},{text:"单页面",id:"单页面",depth:4},{text:"原理",id:"原理",depth:4},{text:"总结",id:"总结",depth:2}],title:"11.Vue-Router4 新旧路由方法对比",headingTitle:"11.Vue-Router4 新旧路由方法对比",frontmatter:{}}}}]);