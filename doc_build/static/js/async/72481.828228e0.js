"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["72481"],{753627:function(n,e,d){d.r(e),d.d(e,{default:()=>l});var r=d(552676),s=d(740453);function c(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",code:"code",h3:"h3",h4:"h4",pre:"pre",blockquote:"blockquote",strong:"strong",h5:"h5",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,s.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"13-中级进阶-----深入理解-glsl-语法",children:["13. 中级进阶 --- 深入理解 GLSL 语法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13-中级进阶-----深入理解-glsl-语法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"经过前面几个章节的学习，相信大家对 GLSL 的部分语法已经熟稔于心了，但我们终究没有对 GLSL 有系统的认知，所以开辟一小节对 GLSL 的常用语法做一个详细介绍。"}),"\n",(0,r.jsxs)(e.h2,{id:"你能学到什么",children:["你能学到什么？",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#你能学到什么",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"GLSL 中的数据类型"}),"\n",(0,r.jsx)(e.li,{children:"GLSL 中的内置变量"}),"\n",(0,r.jsx)(e.li,{children:"向量、矩阵的表示与运算。"}),"\n",(0,r.jsx)(e.li,{children:"GLSL 中的内置函数"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"GLSL 属于 GPU 层面的编程语言，因此它必须有能力支持图形相关的操作。除了绘制 API，还要支持各种数学运算，主要体现在向量和矩阵。"}),"\n",(0,r.jsxs)(e.p,{children:["GLSL 主要是在 C 语言的基础上新增了一些",(0,r.jsx)(e.code,{children:"内置变量"}),"、",(0,r.jsx)(e.code,{children:"数据类型"}),"和",(0,r.jsx)(e.code,{children:"数学函数"}),"，因为是基于 C 语言的拓展，所以在语法规则上和 C 语言基本相同。"]}),"\n",(0,r.jsxs)(e.h2,{id:"变量命名",children:["变量命名",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#变量命名",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"GLSL 的语法和 C 语言类似，因此 GLSL 的变量命名方式和 C 语言基本一致。但由于 GLSL 新增了一些数据类型、内置属性和保留前缀，所以变量命名除了满足 C 语言的命名规则之外，还要满足 GLSL 的特殊规则："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["不能以 ",(0,r.jsx)(e.code,{children:"gl_"})," 作为前缀，gl_ 开头的变量被用于定义 GLSL 的内部变量，这是 GLSL 保留的命名前缀。"]}),"\n",(0,r.jsxs)(e.li,{children:["GLSL 的一些保留名称也不能作为变量名称，比如 ",(0,r.jsx)(e.code,{children:"attribute"}),"、",(0,r.jsx)(e.code,{children:"uniform"}),"、",(0,r.jsx)(e.code,{children:"varying"})," 等。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"数据类型",children:["数据类型",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#数据类型",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["GLSL 最突出的部分是新增了向量和矩阵相关的数据类型，比如存储向量的容器 ",(0,r.jsx)(e.code,{children:"vec{n}"}),"，存储四阶矩阵的容器",(0,r.jsx)(e.code,{children:"mat4"}),"，2D纹理采样器 ",(0,r.jsx)(e.code,{children:"sampler2D"}),"，3D纹理采样器",(0,r.jsx)(e.code,{children:"samplerCube"}),"等等。下面我们着重介绍向量和矩阵在 GLSL 中的用法。"]}),"\n",(0,r.jsxs)(e.h3,{id:"向量",children:["向量",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#向量",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["向量是 GLSL 中很重要的一种数据类型，着色器程序的很多地方都需要用到向量，用来储存包含多个分量的数据，比如",(0,r.jsx)(e.code,{children:"颜色信息"}),"、",(0,r.jsx)(e.code,{children:"齐次坐标"}),"、",(0,r.jsx)(e.code,{children:"法向量"}),"等。"]}),"\n",(0,r.jsxs)(e.p,{children:["向量按照维度分为",(0,r.jsx)(e.code,{children:"2维"}),"、",(0,r.jsx)(e.code,{children:"3维"}),"、",(0,r.jsx)(e.code,{children:"4维"}),"，按照存储的数据类型分为浮点向量",(0,r.jsx)(e.code,{children:"vec{n}"}),"，整型向量",(0,r.jsx)(e.code,{children:"ivec{n}"}),"，布尔向量",(0,r.jsx)(e.code,{children:"bvec{n}"}),"。"]}),"\n",(0,r.jsxs)(e.h4,{id:"浮点向量",children:["浮点向量",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#浮点向量",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"vec2：存储2个浮点数。"}),"\n",(0,r.jsx)(e.li,{children:"vec3：存储3个浮点数。"}),"\n",(0,r.jsx)(e.li,{children:"vec4：存储4个浮点数。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"浮点向量的赋值相对浮点数宽松一些，比如在为一个浮点变量赋值的时候，我们必须这样写："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"正确"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"float size = 10.0;\n"})}),"\n",(0,r.jsxs)(e.p,{children:["像下面这样赋值就会报错，因为类型不匹配，size 是浮点变量，10 是一个整数，",(0,r.jsx)(e.code,{children:"变量类型"}),"和",(0,r.jsx)(e.code,{children:"要赋值的类型"}),"不匹配。"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"错误"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"float size = 10;\n"})}),"\n",(0,r.jsx)(e.p,{children:"但是在为向量赋值时，就会宽松一些，比如我们构建一个2维浮点向量，分量都是 1。"}),"\n",(0,r.jsx)(e.p,{children:"我们可以这样写："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"正确"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"vec2 texcoords = vec2(1.0, 1.0);\n"})}),"\n",(0,r.jsx)(e.p,{children:"也可以这样写："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"vec2 texcoords = vec2(1, 1);\n"})}),"\n",(0,r.jsx)(e.p,{children:"vec 向量类型会自动对元素做类型转换。"}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"之所以讲这些细节，有一个原因是 GLSL 程序的调试有一定局限性，没有特别好用的调试器能够让我们逐行逐变量地进行调试，所以我们只能减少低级失误。"}),"\n"]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"怎样才能减少低级失误？只有夯实基础。但减少失误并不意味着消除，即使我们万般小心，也仍然会出现问题导致编译或者运行异常，这时只能用肉眼排查问题。拥有好的基础，也会促使你很快地找到问题产生的原因。"}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"整型向量",children:["整型向量",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#整型向量",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"ivec2：存储2个整数。"}),"\n",(0,r.jsx)(e.li,{children:"ivec3：存储3个整数。"}),"\n",(0,r.jsx)(e.li,{children:"ivec4：存储4个整数。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"整型向量和浮点向量类似，向量的各个元素都是整型数字，此处不做重复讲解。"}),"\n",(0,r.jsxs)(e.h4,{id:"布尔向量",children:["布尔向量",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#布尔向量",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"bvec2：存储2个布尔值。"}),"\n",(0,r.jsx)(e.li,{children:"bvec3：存储3个布尔值。"}),"\n",(0,r.jsx)(e.li,{children:"bvec4：存储4个布尔值。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["布尔向量的各个元素都是布尔值",(0,r.jsx)(e.code,{children:"true"}),"或者",(0,r.jsx)(e.code,{children:"false"}),"，此处也不做重复讲解。"]}),"\n",(0,r.jsxs)(e.h3,{id:"向量的使用技巧",children:["向量的使用技巧",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#向量的使用技巧",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["每个向量我们都可以用 ",(0,r.jsx)(e.code,{children:"{s、t、p、q}"}),",",(0,r.jsx)(e.code,{children:"{r、g、b、a}"}),",",(0,r.jsx)(e.code,{children:"{x、y、z、w}"}),"来表示。获取各个位置的元素，我们可以使用",(0,r.jsx)(e.code,{children:"."}),"操作符。"]}),"\n",(0,r.jsx)(e.p,{children:"比如一个 4 维向量："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"vec4 v = vec(1, 2, 3, 4);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["那么",(0,r.jsx)(e.code,{children:"v.s"}),"、",(0,r.jsx)(e.code,{children:"v.r"}),"、",(0,r.jsx)(e.code,{children:"v.x"}),"、",(0,r.jsx)(e.code,{children:"v[0]"}),"表示的是该向量第 1 个位置的元素。"]}),"\n",(0,r.jsx)(e.p,{children:"同理："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"v.t"}),"、",(0,r.jsx)(e.code,{children:"v.g"}),"、",(0,r.jsx)(e.code,{children:"v.y"}),"、",(0,r.jsx)(e.code,{children:"v[1]"}),"表示的是该向量第 2 个位置的元素。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"v.p"}),"、",(0,r.jsx)(e.code,{children:"v.b"}),"、",(0,r.jsx)(e.code,{children:"v.z"}),"、",(0,r.jsx)(e.code,{children:"v[2]"}),"表示的是该向量第 3个位置的元素。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"v.q"}),"、",(0,r.jsx)(e.code,{children:"v.a"}),"、",(0,r.jsx)(e.code,{children:"v.w"}),"、",(0,r.jsx)(e.code,{children:"v[3]"}),"表示的是该向量第 4 个位置的元素。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"除此之外，我们还可以使用这种方式对低维向量赋值，假设我们有一个 4 维向量 v，现在想以 v 的前两个元素创建一个 2 维向量 v1，那么我们可以这样赋值："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"vec4 v = vec4(1, 2, 3, 4);\n\n// xyzw 方式赋值\nvec2 v1 = v.xy;\n// stpq 赋值\nvec2 v1 = v.st;\n// rgba 赋值\nvec2 v1 = v.rg;\n\n// 构造函数式\nvec2 v1 = vec2(v.x, v.y);\nvec2 v1 = vec2(v.s, v.t);\nvec2 v1 = vec2(v.r, v.g);\n"})}),"\n",(0,r.jsx)(e.p,{children:"还可以这样使用："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"vec4 v = vec4(1, 2, 3, 4)\nvec2 v1 = vec2(v.xx);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["通过 ",(0,r.jsx)(e.code,{children:"v.xx"})," 的方式将 ",(0,r.jsx)(e.code,{children:"v1"})," 的两个元素设置成 ",(0,r.jsx)(e.code,{children:"v"})," 的第一个元素值，变成 ",(0,r.jsx)(e.code,{children:"(1, 1)"}),"。"]}),"\n",(0,r.jsxs)(e.h4,{id:"向量的运算规则",children:["向量的运算规则",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#向量的运算规则",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"GLSL 中关于向量的另一个重要部分就是运算规则，向量的运算对象分为如下几类："}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"向量和基础数字类型的运算"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"向量和基础数字类型之间的运算比较简单，规则是将数字和向量的各个分量进行运算，并返回新的向量。"}),"\n",(0,r.jsxs)(e.p,{children:["假设有一个 4 维向量 ",(0,r.jsx)(e.code,{children:"v(x, y, z, w)"}),"，浮点数 ",(0,r.jsx)(e.code,{children:"f"}),"。"]}),"\n",(0,r.jsx)(e.p,{children:"向量 v 和 f 之间的加减乘除运算，GLSL 会将各个分量分别和数字 f 进行加减乘除，并返回新的向量 v1。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"// 加法\nvec4 v1 = v + f = (x + f, y + f, z + f, w + f);\n// 减法\nvec4 v1 = v - f = (x - f, y - f, z - f, w - f);\n// 乘法\nvec4 v1 = v * f = (x * f, y * f, z * f, w * f);\n// 除法\nvec4 v1 = v / f = (x / f, y / f, z / f, w / f);\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"向量和向量之间的运算"})}),"\n",(0,r.jsx)(e.p,{children:"向量和向量之间也可以进行运算，返回一个新的向量，前提是两个向量之间的维度必须相同。"}),"\n",(0,r.jsx)(e.p,{children:"运算规则是两个向量对应位置的元素分别进行运算。"}),"\n",(0,r.jsx)(e.p,{children:"假设向量 v1 (x1, y1, z1, w1)，向量 v2（x2, y2, z2, w2），那么有："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"// 加法\nvec4 v3 = v1 + v2 = (x1 + x2, y1 + y2, z1 + z2, w1 + w2);\n// 减法\nvec4 v3 = v1 - v2 = (x1 - x2, y1 - y2, z1 - z2, w1 - w2);\n\n// 乘法\nvec4 v3 = v1 * v2 = (v1 * v2, y1 * y2, z1 * z2, w1 * w2);\n// 减法\nvec4 v3 = v1 / v2 = (x1 / x2, y1 / y2, z1 / z2, w1 / w2);\n"})}),"\n",(0,r.jsx)(e.p,{children:"看起来很简单，但是有一点需要注意，向量之间乘法有三种，上面的 * 号乘法规则是为了使用方便。"}),"\n",(0,r.jsxs)(e.p,{children:["在数学领域，向量之间还有两种乘法",(0,r.jsx)(e.code,{children:"点乘"}),"和",(0,r.jsx)(e.code,{children:"叉乘"}),"，具体区别我们在",(0,r.jsx)(e.a,{href:"/",children:"中级进阶 --- 数学：点、向量、矩阵"}),"章节详细介绍。"]}),"\n",(0,r.jsxs)(e.p,{children:["GLSL 中增加了两种内置函数，用来实现",(0,r.jsx)(e.code,{children:"点乘"}),"和",(0,r.jsx)(e.code,{children:"叉乘"}),"运算，它们分别是 ",(0,r.jsx)(e.code,{children:"dot"}),"和",(0,r.jsx)(e.code,{children:"cross"}),"，使用起来也很简单："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"// 点乘\nfloat v3 = dot(v1, v2);\n\n// 叉乘\nvec3 v3 = cross(v1, v2);\n"})}),"\n",(0,r.jsx)(e.p,{children:"在计算光照效果时，会经常使用这两个函数。"}),"\n",(0,r.jsx)(e.p,{children:"以上就是向量相关内容，大多数运算规则和线性代数一致。"}),"\n",(0,r.jsxs)(e.h3,{id:"矩阵",children:["矩阵",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#矩阵",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"矩阵是 GLSL 中和数学相关的另一块重要内容，在着色器程序中，我们会经常使用矩阵来完成各种变换，比如坐标转换、计算光照时的法向量转换等。"}),"\n",(0,r.jsxs)(e.h4,{id:"矩阵分类",children:["矩阵分类",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#矩阵分类",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"矩阵按照维度分为二阶、三阶、四阶，其中三阶和四阶矩阵用的较多，我们下面主要讲解四阶矩阵。"}),"\n",(0,r.jsxs)(e.h5,{id:"四阶矩阵",children:["四阶矩阵",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#四阶矩阵",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"四阶矩阵，包含 4 行 4 列共 16 个浮点数，在着色器程序中初始化一个四阶矩阵有很多种方式。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"用 16 个浮点数构造矩阵。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"这是最简单最直观的构造方式："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"mat4 m = mat4(\n    1, 2, 3, 4,  //第一列\n    5, 6, 7, 8,  //第二列\n    9, 10, 11, 12, //第三列\n    13, 14, 15,16 // 第四列\n);\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"用 1 个浮点数构造对角线矩阵。"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"mat4 a = mat4(1.0);\n"})}),"\n",(0,r.jsx)(e.p,{children:"mat4 传入一个浮点数构造出的矩阵，对角线上的值都是 1.0:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"[  \n    1.0, 0, 0, 0,\n    0, 1.0, 0, 0,\n    0, 0, 1.0, 0,\n    0, 0, 0, 1.0\n]\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"利用列向量构造"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"四阶矩阵可以理解为四个列向量组合而成，所以 GLSL 提供了利用向量构造矩阵的方法。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"//第一列\nvec4 c0 = vec4(1, 2, 3, 4);\n//第二列\nvec4 c1 = vec4(5, 6, 7, 8);\n//第三列\nvec4 c2 = vec4(1, 2, 3, 4);\n//第四列\nvec4 c3 = vec4(5, 6, 7, 8);\n\nmat4 m = mat4(c0, c1, c2, c4);\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"向量与浮点数混合构造。\n当然除了纯数字构造、纯向量构造，GLSL 也允许向量和数字混合构造："}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"vec4 c0 = vec4(1, 2, 3, 4);\nvec4 c1 = vec4(5, 6, 7, 8);\nvec4 c2 = vec4(1, 2, 3, 4);\n\nmat4 m = mat4(c0, c1, c2, 5, 6, 7, 8);\n"})}),"\n",(0,r.jsx)(e.p,{children:"观察上面的构造方式，我们发现，mat4构造函数 中传入的数字只要满足 16 个就可以构造成四阶矩阵。"}),"\n",(0,r.jsx)(e.p,{children:"所以，大家还可以想到利用二维、三维向量进行构造的方式。"}),"\n",(0,r.jsxs)(e.p,{children:["总之，GLSL 为矩阵提供的构造方式很灵活，毕竟，在 GLSL 中我们用的最多的除了",(0,r.jsx)(e.code,{children:"向量"}),"就是",(0,r.jsx)(e.code,{children:"矩阵"}),"了。"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"矩阵运算"}),"\n"]}),"\n",(0,r.jsxs)(e.h5,{id:"乘法运算",children:["乘法运算",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#乘法运算",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["我们用的最多的就是乘法运算了，在GLSL 中，矩阵乘法用 ",(0,r.jsx)(e.code,{children:"*"})," 来表示，但大家要记住，由于 GLSL 中矩阵采用的是",(0,r.jsx)(e.code,{children:"列主序"}),"，所以，矩阵和向量相乘时，要置在乘号左侧，如下："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"mat4 m = mat4(1.0);\nvec4 v1 = m * vec4(1, 2, 3, 4);\n"})}),"\n",(0,r.jsxs)(e.p,{children:["还有一些其他的矩阵运算方法，比如",(0,r.jsx)(e.code,{children:"转置"}),"、",(0,r.jsx)(e.code,{children:"求逆"}),"等："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-glsl",children:"mat4 m0 = mat4(1.0);\n// 转置\nmat4 m1 = transpose(m0);\n// 求逆\nmat4 m2 = inverse(m0)\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"内置变量",children:["内置变量",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#内置变量",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["内置属性在前面章节中已经学过一些了，比如大家很熟悉的 ",(0,r.jsx)(e.code,{children:"gl_Position"}),"、",(0,r.jsx)(e.code,{children:"gl_FragColor"})," 等，除此之外，还有一些不常用的属性。"]}),"\n",(0,r.jsxs)(e.h3,{id:"顶点着色器",children:["顶点着色器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#顶点着色器",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"gl_Position：顶点坐标。"}),"\n",(0,r.jsx)(e.li,{children:"gl_PointSize：点的尺寸。"}),"\n",(0,r.jsx)(e.li,{children:"gl_Normal：顶点法线。"}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"片元着色器",children:["片元着色器",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#片元着色器",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"gl_FragColor，当前片元的颜色，类型 vec4。"}),"\n",(0,r.jsx)(e.li,{children:"gl_FragCoord，屏幕像素的x，y，z，1 / w。"}),"\n",(0,r.jsxs)(e.li,{children:["gl_FragDepth，片元的最终深度值，在后面的深度测试用到，在片元着色器中我们无法修改",(0,r.jsx)(e.code,{children:"x, y"}),"值，但是可以修改",(0,r.jsx)(e.code,{children:"z"}),"值。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"内置函数",children:["内置函数",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#内置函数",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"GLSL 内置了很多数学函数，下面列举一些经常用到的。"}),"\n",(0,r.jsxs)(e.h3,{id:"向量函数",children:["向量函数",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#向量函数",children:"#"})]}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{children:"函数"}),"\n",(0,r.jsx)(e.th,{children:"作用"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"cross"}),"\n",(0,r.jsx)(e.td,{children:"计算两个向量的叉积"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"dot"}),"\n",(0,r.jsx)(e.td,{children:"计算向量的点积。"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"normalize"}),"\n",(0,r.jsx)(e.td,{children:"归一化向量，返回一个和原向量方向相同，但是长度为1的单位向量。"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"reflect"}),"\n",(0,r.jsx)(e.td,{children:"根据入射向量和法线向量，计算出反射向量。"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"length"}),"\n",(0,r.jsx)(e.td,{children:"计算向量的长度"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"distance"}),"\n",(0,r.jsx)(e.td,{children:"计算两个向量之间的距离。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"常用数学函数",children:["常用数学函数",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#常用数学函数",children:"#"})]}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{children:"函数"}),"\n",(0,r.jsx)(e.th,{children:"作用"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"abs"}),"\n",(0,r.jsx)(e.td,{children:"将某个数的绝对值"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"floor"}),"\n",(0,r.jsx)(e.td,{children:"返回不大于某个数的最大整数。"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"round"}),"\n",(0,r.jsx)(e.td,{children:"四舍五入值"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"ceil"}),"\n",(0,r.jsx)(e.td,{children:"返回大于某个数的最小整数。"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"fract"}),"\n",(0,r.jsx)(e.td,{children:"返回浮点数的小数部分"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"mod"}),"\n",(0,r.jsx)(e.td,{children:"取模"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"min"}),"\n",(0,r.jsx)(e.td,{children:"返回两个数中比较小的数"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"max"}),"\n",(0,r.jsx)(e.td,{children:"返回两个数中比较大的数"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"三角函数",children:["三角函数",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#三角函数",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"GLSL 提供了很多三角函数，方便我们进行角度求值："}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{children:"函数"}),"\n",(0,r.jsx)(e.th,{children:"作用"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"radians"}),"\n",(0,r.jsx)(e.td,{children:"将角度（如90度）转化为弧度（PI/2）。"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"degrees"}),"\n",(0,r.jsx)(e.td,{children:"将弧度（如PI / 2）转化为角度（90 度）。"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"sin"}),"\n",(0,r.jsx)(e.td,{children:"求弧度的正弦"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"cos"}),"\n",(0,r.jsx)(e.td,{children:"求弧度的余弦"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"tan"}),"\n",(0,r.jsx)(e.td,{children:"求弧度的正切"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"asin"}),"\n",(0,r.jsx)(e.td,{children:"根据正弦值求对应的弧度"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"acos"}),"\n",(0,r.jsx)(e.td,{children:"根据余弦值求对应的弧度"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"atan"}),"\n",(0,r.jsx)(e.td,{children:"根据正切值求对应的弧度"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"以上就是常用的三角函数，GLSL 还提供了一些更复杂但是不常用的函数，此处不一一列举了，大家感兴趣的话可以查查 GLSL 语法规范。"}),"\n",(0,r.jsxs)(e.h2,{id:"限定符",children:["限定符",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#限定符",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"限定符在之前章节也已经陆续讲过了，再次做个总结。"}),"\n",(0,r.jsxs)(e.h3,{id:"attribute",children:["attribute",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#attribute",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["attribute 变量只能定义在",(0,r.jsx)(e.code,{children:"顶点着色器"}),"中，它的作用是接收 JavaScript 程序传递过来的与",(0,r.jsx)(e.code,{children:"顶点"}),"有关的数据，比如在之前程序中定义的",(0,r.jsx)(e.code,{children:"顶点颜色"}),"、",(0,r.jsx)(e.code,{children:"法线"}),"、",(0,r.jsx)(e.code,{children:"坐标"}),"等，它们是顶点的属性。"]}),"\n",(0,r.jsx)(e.p,{children:"也就是说，如果有一类数据，它是跟随顶点而存在的，每个顶点所对应的数据不尽相同，那么我们就需要用 attribute 限定符定义变量。"}),"\n",(0,r.jsxs)(e.h3,{id:"uniform",children:["uniform",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#uniform",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"uniform 用来修饰全局变量，它既可以在顶点着色器中定义，也可以在片元着色器中定义，用来接收与顶点无关的数据。"}),"\n",(0,r.jsxs)(e.p,{children:["比如，在之前程序中，我们定义了一个 uniform 变量 ",(0,r.jsx)(e.code,{children:"u_Matrix"}),"，它用来接收 JavaScript 中传递过来的 模型视图投影矩阵，该数据与顶点无关，也就是每个顶点共用变换矩阵，所以我们应该用 uniform 修饰该变量。"]}),"\n",(0,r.jsxs)(e.h3,{id:"varying",children:["varying",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#varying",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"varying变量一般是成对定义的，即在顶点着色器中定义，在片元着色器中使用。它所修饰的变量在传递给片元着色器之前会进行插值化处理。"}),"\n",(0,r.jsxs)(e.h2,{id:"回顾",children:["回顾",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"以上是对常用 GLSL 语法的一个总结，事实上还有一些比较罕见的函数我们没有列举，大家在用到的时候可以查阅 WebGL 官方文档。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.khronos.org/registry/webgl/specs/latest/2.0/",target:"_blank",rel:"noopener noreferrer",children:"WebGL 规范"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.khronos.org/files/opengles_shading_language.pdf",target:"_blank",rel:"noopener noreferrer",children:"OpenGL ES 规范"})}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"接下来的章节我们开始 3D 数学知识的学习，因涉及到一些推导，建议线性代数基础不好的同学准备好纸笔。"})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F13.%20%E4%B8%AD%E7%BA%A7%E8%BF%9B%E9%98%B6%20---%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20GLSL%20%E8%AF%AD%E6%B3%95.md"]={toc:[{text:"你能学到什么？",id:"你能学到什么",depth:2},{text:"变量命名",id:"变量命名",depth:2},{text:"数据类型",id:"数据类型",depth:2},{text:"向量",id:"向量",depth:3},{text:"浮点向量",id:"浮点向量",depth:4},{text:"整型向量",id:"整型向量",depth:4},{text:"布尔向量",id:"布尔向量",depth:4},{text:"向量的使用技巧",id:"向量的使用技巧",depth:3},{text:"向量的运算规则",id:"向量的运算规则",depth:4},{text:"矩阵",id:"矩阵",depth:3},{text:"矩阵分类",id:"矩阵分类",depth:4},{text:"内置变量",id:"内置变量",depth:2},{text:"顶点着色器",id:"顶点着色器",depth:3},{text:"片元着色器",id:"片元着色器",depth:3},{text:"内置函数",id:"内置函数",depth:2},{text:"向量函数",id:"向量函数",depth:3},{text:"常用数学函数",id:"常用数学函数",depth:3},{text:"三角函数",id:"三角函数",depth:3},{text:"限定符",id:"限定符",depth:2},{text:"attribute",id:"attribute",depth:3},{text:"uniform",id:"uniform",depth:3},{text:"varying",id:"varying",depth:3},{text:"回顾",id:"回顾",depth:2}],title:"13. 中级进阶 --- 深入理解 GLSL 语法",headingTitle:"13. 中级进阶 --- 深入理解 GLSL 语法",frontmatter:{}}}}]);