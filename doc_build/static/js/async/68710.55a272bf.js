"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["68710"],{402576:function(e,n,t){t.r(n),t.d(n,{default:()=>y});var c=t(552676),i=t(740453);let s=t.p+"static/image/f8820b518438ff464d4a1b548b8542ed.17ea6834.gif",a=t.p+"static/image/69bc3c1d44b6de6e9ef9acf20935be49.25e377b4.webp",r=t.p+"static/image/e43555f5d8c4739d070f77bf251ba073.60b0d4ad.gif",p=t.p+"static/image/e50ff3d39a7f03c717b27d3cdce7c9a5.0808d7e3.webp",l=t.p+"static/image/fbb855ef9577aa0fe2ddd8df4dd8e53f.c84b0d25.webp",d=t.p+"static/image/6dd49f93d516fe3ea3fb4a4d27f6c00e.d02161cb.webp",o=t.p+"static/image/0e7841af02f34ac0c1ba64787da3c20d.faac2999.webp",h=t.p+"static/image/1c08b354840b98ea4f4a05bb632b520a.cb7e78e1.webp",x=t.p+"static/image/6c370d17514510e54b01abca735e6d60.453cf209.webp",j=t.p+"static/image/962045709bcdbbcc0dc731bf8e5157f5.c8aebc68.webp",u=t.p+"static/image/d18206476d6c133465ac072c29a55168.2cd0d27a.webp",m=t.p+"static/image/401a803a42e2596d9d63344df3828f1a.82d432d0.webp",b=t.p+"static/image/0316d2d893d5b25313146c51045afe92.ac37f38e.webp",f=t.p+"static/image/46393531b6e5328128e9426bd7defe0d.a45d5ec5.webp",g=t.p+"static/image/928cf9a51f6decd34aab79dd8f2cac62.31ff80a5.gif",k=t.p+"static/image/d7fec8f1a7d617f30d86e8555b909f86.fbc8e46b.gif",v=t.p+"static/image/9205a6f552206e507ced91c05a68b701.58407dd8.webp",E=t.p+"static/image/56d2bec09e2225cf2072e274dc557e8f.bae61ac5.webp",P=t.p+"static/image/d22df533e6f3c3789b57ea148e26ad7d.d6de3863.webp",A=t.p+"static/image/edeea93ff4d43c6ca7146425f6b217de.678ac3a9.webp",C=t.p+"static/image/9e4a8f3ae04b53b81a064602fe12d1a4.48a99756.webp";function R(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",strong:"strong",h2:"h2"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"第43章基于reactrouter实现keepalive",children:["第43章—基于ReactRouter实现keepalive",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第43章基于reactrouter实现keepalive",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"\uFEFF当路由切换的时候，react router 会销毁之前路由的组件，然后渲染新的路由对应的组件。"}),"\n",(0,c.jsx)(n.p,{children:"在一些场景下，这样是有问题的。"}),"\n",(0,c.jsx)(n.p,{children:"比如移动端很多长列表，用户划了很久之后，点击某个列表项跳到详情页，之后又跳回来，但是这时候列表页的组件销毁重新创建，又回到了最上面。"}),"\n",(0,c.jsx)(n.p,{children:"比如移动端填写了某个表单，有的表单需要跳到别的页面获取数据，然后跳回来，跳回来发现组件销毁重新创建，之前填的都没了。"}),"\n",(0,c.jsx)(n.p,{children:"类似这种场景，就需要路由切换的时候不销毁组件，也就是 keepalive。"}),"\n",(0,c.jsx)(n.p,{children:"我们先复现下这个场景："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npx create-vite\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:C,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"进入项目，安装依赖，把开发服务跑起来："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm install\nnpm run dev\n"})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:A,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"安装 react-router："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"npm i --save react-router-dom\n"})}),"\n",(0,c.jsx)(n.p,{children:"在 App.tsx 写下路由："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import { useState } from 'react';\nimport {  Link, useLocation, RouterProvider, createBrowserRouter, Outlet } from 'react-router-dom';\n\nconst Layout = () => {\n    const { pathname } = useLocation();\n\n    return (\n        <div>\n            <div>当前路由: {pathname}</div>\n            <Outlet/>\n        </div>\n    )\n}\n\nconst Aaa = () => {\n    const [count, setCount] = useState(0);\n\n    return <div>\n      <p>{count}</p>\n      <p>\n        <button onClick={() => setCount(count => count + 1)}>加一</button>\n      </p>\n      <Link to='/bbb'>去 Bbb 页面</Link><br/>\n      <Link to='/ccc'>去 Ccc 页面</Link>\n    </div>\n};\n\nconst Bbb = () => {\n    const [count, setCount] = useState(0);\n\n    return <div>\n      <p>{count}</p>\n      <p><button onClick={() => setCount(count => count + 1)}>加一</button></p>\n      <Link to='/'>去首页</Link>\n    </div>\n};\n\nconst Ccc = () => {\n    return <div>\n      <p>ccc</p>\n      <Link to='/'>去首面</Link>\n    </div>\n};\n\nconst routes = [\n  {\n    path: \"/\",\n    element: <Layout></Layout>,\n    children: [\n      {\n        path: \"/\",\n        element: <Aaa></Aaa>,\n      },\n      {\n        path: \"/bbb\",\n        element: <Bbb></Bbb>\n      },\n      {\n        path: \"/ccc\",\n        element: <Ccc></Ccc>\n      }\n    ]\n  }\n];\n\nexport const router = createBrowserRouter(routes);\n\nconst App = () => {\n    return <RouterProvider router={router}/>\n}\n\nexport default App;\n"})}),"\n",(0,c.jsx)(n.p,{children:"这里有 /、/bbb、/ccc 这三个路由。"}),"\n",(0,c.jsx)(n.p,{children:"一级路由渲染 Layout 组件，里面通过 Outlet 指定渲染二级路由的地方。"}),"\n",(0,c.jsx)(n.p,{children:"二级路由 / 渲染 Aaa 组件，/bbb 渲染 Bbb 组件，/ccc 渲染 Ccc 组件。"}),"\n",(0,c.jsx)(n.p,{children:"这里的 Outlet 组件，也可以换成 useOutlet，效果一样："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:P,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:E,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"注释掉 index.css 还有 StrictMode："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:v,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"在浏览器看一下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:k,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"默认路由切换，对应的组件就会销毁："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"我们有时候不希望切换路由时销毁页面组件，也就是希望能实现 keepalive。"}),"\n",(0,c.jsx)(n.p,{children:"怎么做呢？"}),"\n",(0,c.jsx)(n.p,{children:"其实很容易想到，我们把所有需要 keepalive 的组件保存到一个全局对象。"}),"\n",(0,c.jsx)(n.p,{children:"然后渲染的时候把它们都渲染出来，路由切换只是改变显示隐藏。"}),"\n",(0,c.jsx)(n.p,{children:"按照这个思路来写一下："}),"\n",(0,c.jsx)(n.p,{children:"新建 keepalive.tsx"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-javascript",children:"import React, { createContext, useContext } from 'react';\nimport { useOutlet, useLocation, matchPath } from 'react-router-dom'\nimport type { FC, PropsWithChildren, ReactNode } from 'react';\n\ninterface KeepAliveLayoutProps extends PropsWithChildren{\n    keepPaths: Array<string | RegExp>;\n    keepElements?: Record<string, ReactNode>;\n    dropByPath?: (path: string) => void;\n}\n\ntype KeepAliveContextType = Omit<Required<KeepAliveLayoutProps>, 'children'>;\n\nconst keepElements: KeepAliveContextType['keepElements'] = {};\n\nexport const KeepAliveContext = createContext<KeepAliveContextType>({\n    keepPaths: [],\n    keepElements,\n    dropByPath(path: string) {\n        keepElements[path] = null;\n    }\n});\n\nconst isKeepPath = (keepPaths: Array<string | RegExp>, path: string) => {\n    let isKeep = false;\n    for(let i = 0; i< keepPaths.length; i++) {\n        let item = keepPaths[i];\n        if (item === path) {\n            isKeep = true;\n        }\n        if (item instanceof RegExp && item.test(path)) {\n            isKeep = true;\n        }\n        if (typeof item === 'string' && item.toLowerCase() === path) {\n            isKeep = true;\n        }\n    }\n    return isKeep;\n}\n\nexport function useKeepOutlet() {\n    const location = useLocation();\n    const element = useOutlet();\n\n    const { keepElements, keepPaths } = useContext(KeepAliveContext);\n    const isKeep = isKeepPath(keepPaths, location.pathname);\n\n    if (isKeep) {\n        keepElements![location.pathname] = element;\n    }\n\n    return <>\n        {\n            Object.entries(keepElements).map(([pathname, element]) => (\n                <div \n                    key={pathname}\n                    style={{ height: '100%', width: '100%', position: 'relative', overflow: 'hidden auto' }}\n                    className=\"keep-alive-page\"\n                    hidden={!matchPath(location.pathname, pathname)}\n                >\n                    {element}\n                </div>\n            ))\n        }\n        {!isKeep && element}\n    </>\n}\n\nconst KeepAliveLayout: FC<KeepAliveLayoutProps> = (props) => {\n    const { keepPaths, ...other } = props;\n\n    const { keepElements, dropByPath } = useContext(KeepAliveContext);\n\n    return (\n        <KeepAliveContext.Provider value={{ keepPaths, keepElements, dropByPath }} {...other} />\n    )\n}\n\nexport default KeepAliveLayout;\n"})}),"\n",(0,c.jsx)(n.p,{children:"代码比较多，从上到下来看。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"首先，我们创建一个 context。"}),"\n",(0,c.jsx)(n.p,{children:"keepPaths 是要 keepalive 的页面路径，可以是 string 也可以是正则。"}),"\n",(0,c.jsx)(n.p,{children:"keepElements 是页面路径和组件的键值对，用来保存 keepalive 的组件。"}),"\n",(0,c.jsx)(n.p,{children:"dropByPath 是根据页面路径删除 keepElement 中的对应组件。"}),"\n",(0,c.jsx)(n.p,{children:"这里用到几个 TS 的内置类型："}),"\n",(0,c.jsx)(n.p,{children:"Record 是创建一个 key value 的对象类型："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"Requried 是去掉可选 -?"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"Omit 是删掉其中的部分属性："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"KeepAliveLayoutProps 类型处理后就是这样的："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["ts 类型编程部分的知识可以看我的 ",(0,c.jsx)(n.a,{href:"https://juejin.cn/book/7047524421182947366",target:"_blank",rel:"noopener noreferrer",children:"TS 类型体操小册"})]}),"\n",(0,c.jsx)(n.p,{children:"继续往下看："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"暴露出一个组件，里面用 context.Provider 修改 context 中的值，主要是设置 keepPaths，其余的都用 useContext 从 context 中取。"}),"\n",(0,c.jsx)(n.p,{children:"然后暴露一个 useKeepOutlet 的 hook："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"用 useLocation 拿到当前路由，用 useOutlet 拿到对应的组件。"}),"\n",(0,c.jsx)(n.p,{children:"判断下当前路由是否在需要 keepalive 的路由内，是的话就保存到 keepElements。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"然后渲染所有的 keepElements，如果不匹配就隐藏。"}),"\n",(0,c.jsx)(n.p,{children:"并且如果当前路由不在 keepPaths 内，就直接渲染对应的组件。"}),"\n",(0,c.jsx)(n.p,{children:"isKeepPath 就比较简单了，根据是 string 还是 RegExp 分别做处理，判断路由是否在 keepPaths 内："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["其实原理比较容易看懂：",(0,c.jsx)(n.strong,{children:"在 context 中保存所有需要 keepalive 的组件，全部渲染出来，通过路由是否匹配来切换对应组件的显示隐藏。"})]}),"\n",(0,c.jsx)(n.p,{children:"在 App.tsx 里引入测试下："}),"\n",(0,c.jsx)(n.p,{children:"在外面包一层 KeepAliveLayout 组件："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"然后把 useOutlet 换成 useKeepOutlet："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"测试下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"可以看到，/bbb 路由的组件实现了 keepalive，而 / 路由的 组件没有。"}),"\n",(0,c.jsx)(n.p,{children:"我们配置下："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"现在两个路由的组件就都 keepalive 了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:s,alt:""})}),"\n",(0,c.jsxs)(n.p,{children:["案例代码上传了",(0,c.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/router-keepalive",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"})]}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"路由切换会销毁对应的组件，但很多场景我们希望路由切换组件不销毁，也就是 keepalive。"}),"\n",(0,c.jsx)(n.p,{children:"react router 并没有实现这个功能，需要我们自己做。"}),"\n",(0,c.jsx)(n.p,{children:"我们在 context 中保存所有需要 keepalive 的组件，然后渲染的时候全部渲染出来，通过路由是否匹配来切换显示隐藏。"}),"\n",(0,c.jsx)(n.p,{children:"这样实现了 keepalive。"}),"\n",(0,c.jsx)(n.p,{children:"这个功能是依赖 React Router 的 useLocation、useOutlet、matchPath 等 api 实现的，和路由功能密不可分。"})]})}function K(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(R,{...e})}):R(e)}let y=K;K.__RSPRESS_PAGE_META={},K.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC43%E7%AB%A0%E2%80%94%E5%9F%BA%E4%BA%8EReactRouter%E5%AE%9E%E7%8E%B0keepalive.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第43章—基于ReactRouter实现keepalive",headingTitle:"第43章—基于ReactRouter实现keepalive",frontmatter:{}}}}]);