"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["29936"],{12016:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var s=r(552676),l=r(740453);let o=r.p+"static/image/2742d54aa2c2c38afa67e491012204a4.2cbf195e.webp",d=r.p+"static/image/d8b28e872a137741731c8055f1875028.8538e838.webp",c=r.p+"static/image/0d92e511d35c8f4c4c9fd8e17cf6ae6e.295cc1c1.webp";function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",h2:"h2",strong:"strong",ol:"ol",pre:"pre",blockquote:"blockquote",img:"img",h3:"h3"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"20loader-开发进阶如何用好-loader-扩展开发工具",children:["20.Loader 开发进阶：如何用好 Loader 扩展开发工具？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#20loader-开发进阶如何用好-loader-扩展开发工具",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在上一篇文章中，我们已经详细了解了开发 Webpack Loader 需要用到的基本技能，包括：Loader 基本形态、如何构建测试环境、如何使用 Loader Context 接口等。接下来我们继续拓展学习一些 Loader 辅助工具，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["了解 ",(0,s.jsx)(n.code,{children:"loader-utils"}),"，并使用 ",(0,s.jsx)(n.code,{children:"loader-utils"})," 拼接文件名；"]}),"\n",(0,s.jsxs)(n.li,{children:["了解 ",(0,s.jsx)(n.code,{children:"schema-tiles"}),"，以及其背后的 ",(0,s.jsx)(n.code,{children:"ajv"})," 库与 JSON-Schema 协议，学习使用 ",(0,s.jsx)(n.code,{children:"schema-utils"})," 实现参数校验。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["文章最后还会深入剖析 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 组件源码，通过实战方式帮助大家更深入理解：如何开发一个成熟 Loader。"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-schema-utils",children:["使用 ",(0,s.jsx)(n.code,{children:"schema-utils"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-schema-utils",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack，以及 Webpack 生态下的诸多 Loader、Plugin 基本上都会提供若干“",(0,s.jsx)(n.strong,{children:"配置项"}),"”，供用户调整组件的运行逻辑，这些组件内部通常都会使用 ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/schema-utils",target:"_blank",rel:"noopener noreferrer",children:"schema-utils"})," 工具库校验用户传入的配置是否满足要求。"]}),"\n",(0,s.jsx)(n.p,{children:"因此，若我们开发的 Loader 需要对外暴露配置项，建议也尽量使用这一工具，基本用法："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"安装依赖："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"yarn add -D schema-utils\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"编写配置对象的 Schema 描述，例如："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'// options.json\n{\n  "type": "object",\n  "properties": {\n    "name": {\n      "type": "boolean"\n    }\n  },\n  "required": ["name"],\n  "additionalProperties": false\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsxs)(n.li,{children:["在 Loader 中调用 ",(0,s.jsx)(n.code,{children:"schema-utils"})," 校验配置对象："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { validate } from "schema-utils";\nimport schema from "./options.json";\n\n// 调用 schema-utils 完成校验\nexport default function loader(source) {\n  const options = this.getOptions();\n  validate(schema, options);\n\n  return source;\n}\n\n// Webpack5 之后还可以借助 Loader Context 的 `getOptions` 接口完成校验\nexport default function loader(source) {\n  const options = this.getOptions(schema);\n\n  return source;\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：示例代码已上传到小册 ",(0,s.jsx)(n.a,{href:"https://github1s.com/Tecvan-fe/webpack-book-samples/blob/main/loader-validate/package.json",target:"_blank",rel:"noopener noreferrer",children:"仓库"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"之后，若用户传入不符合 Schema 描述的参数对象，会报类似下面这种错误提示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:"image.png"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"schema-utils"})," 的校验能力很强，能够完美支撑起 Webpack 生态下非常复杂的参数校验需求，但官方文档非常语焉不详，翻阅源码后发现，它底层主要依赖于 ",(0,s.jsx)(n.a,{href:"https://ajv.js.org/guide/getting-started.html",target:"_blank",rel:"noopener noreferrer",children:"ajv"})," ，这是一个应用广泛、功能强大且性能优异的校验工具："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:"image.png"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：",(0,s.jsx)(n.code,{children:"ajv"})," 在对象校验、JSON 序列化/反序列化方面的性能表现非常突出，许多知名",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/browse/depended/ajv",target:"_blank",rel:"noopener noreferrer",children:"开源框架"})," 如：ESLint、fast-json-stringify、middy、swagger、tailwind 等底层都依赖于 ",(0,s.jsx)(n.code,{children:"ajv"}),"，值得我们学习、复用到业务项目中。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ajv"})," 功能非常完备，基本上已经覆盖了“使用 JSON 描述对象约束”的所有场景，我们不可能在一篇文章里介绍所有细节，所以我下面只摘要介绍一些比较重要的能力与实例，更多信息建议参考 ",(0,s.jsx)(n.a,{href:"https://ajv.js.org/guide/why-ajv.html",target:"_blank",rel:"noopener noreferrer",children:"官网"}),"。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ajv"})," 数据描述格式基础知识："]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"schema-utils"})," 内部使用 ",(0,s.jsx)(n.code,{children:"ajv"})," 的 ",(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html",target:"_blank",rel:"noopener noreferrer",children:"JSON-Schema"})," 模式实现参数校验，而 JSON-Schema 是一种以 JSON 格式描述数据结构的 ",(0,s.jsx)(n.a,{href:"https://json-schema.org/specification.html",target:"_blank",rel:"noopener noreferrer",children:"公共规范"}),"，使用时至少需要提供 ",(0,s.jsx)(n.code,{children:"type"})," 参数，如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'{\n  "type": "number"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ajv"})," 默认支持七种基本数据类型。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#keywords-for-numbers",target:"_blank",rel:"noopener noreferrer",children:"number"}),"：数值型，支持整数、浮点数，支持如下校验规则：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maximum"}),"、",(0,s.jsx)(n.code,{children:"minimum"}),"：属性值必须大于等于 ",(0,s.jsx)(n.code,{children:"minimum"})," ，且小于等于 ",(0,s.jsx)(n.code,{children:"maximum"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exclusiveMaximum"}),"、",(0,s.jsx)(n.code,{children:"exclusiveMinimum"}),"：属性值必须大于 ",(0,s.jsx)(n.code,{children:"exclusiveMinimum"})," ，且小于 ",(0,s.jsx)(n.code,{children:"exclusiveMinimum"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"multipleOf"}),"：属性值必须为 ",(0,s.jsx)(n.code,{children:"multipleOf"})," 的整数倍，例如对于 ",(0,s.jsx)(n.code,{children:"multipleOf = 5"}),"，则 ",(0,s.jsx)(n.code,{children:"10/20/5"})," 均符合预期，但 ",(0,s.jsx)(n.code,{children:"8/9/1"})," 等不符合预期。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"interger"}),"：整数型，与 ",(0,s.jsx)(n.code,{children:"number"})," 类似，也支持上面介绍的 ",(0,s.jsx)(n.code,{children:"maximum"})," 等校验规则；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#keywords-for-strings",target:"_blank",rel:"noopener noreferrer",children:"string"}),"：字符串型，支持如下校验规则：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxLength"}),"、",(0,s.jsx)(n.code,{children:"minLength"}),"：限定字符串的最大长度、最小长度；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pattern"}),"：以正则表达式方式限定字符串内容；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"format"}),"：声明字符串内容格式，",(0,s.jsx)(n.code,{children:"schema-utils"})," 底层调用了 ",(0,s.jsx)(n.code,{children:"[ajv-formats](https://github.com/ajv-validator/ajv-formats)"})," 插件，开箱支持 ",(0,s.jsx)(n.code,{children:"date/ipv4/regex/uuid"})," 等格式。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"boolean"}),"：bool 值；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#keywords-for-arrays",target:"_blank",rel:"noopener noreferrer",children:"array"}),"：数组型，支持如下校验属性：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxItems"}),"、",(0,s.jsx)(n.code,{children:"minItems"}),"：限定数组的最多、最少的元素数量；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"uniqueItems"}),"：限定数组元素是否必须唯一，不可重复；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"items"}),"：声明数组项的 Schema 描述，数组项内可复用 JSON-Schema 的任意规则，从而形成嵌套定义结构；"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"null"}),"：空值，常用于复合 ",(0,s.jsx)(n.code,{children:"type"})," 类型，如 ",(0,s.jsx)(n.code,{children:"type = ['object', 'null']"})," 支持传入对象结构或 ",(0,s.jsx)(n.code,{children:"null"})," 值；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#keywords-for-objects",target:"_blank",rel:"noopener noreferrer",children:"object"}),"：对象结构，这是一个比较负责的结构，支持如下校验属性：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxProperties"})," / ",(0,s.jsx)(n.code,{children:"minProperties"}),"：限定对象支持的最多、最少属性数量；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"required"}),"：声明哪些属性不可为空，例如 ",(0,s.jsx)(n.code,{children:"required = ['name', 'age']"})," 时，传入的值必须至少提供 ",(0,s.jsx)(n.code,{children:"name/age"})," 属性；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"properties"}),"：定义特定属性的 Schema 描述，与 ",(0,s.jsx)(n.code,{children:"array"})," 的 ",(0,s.jsx)(n.code,{children:"items"})," 属性类似，支持嵌套规则，例如："]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  type: "object",\n  properties: {\n    foo: {type: "string"},\n    bar: {\n      type: "number",\n      minimum: 2\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"patternProperties"}),"：同样用于定义对象属性的 Schema，但属性名支持正则表达式形式，例如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  type: "object",\n  patternProperties: {\n    "^fo.*$": {type: "string"},\n    "^ba.*$": {type: "number"}\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"additionalProperties"}),"：限定对象是否可以提供除 ",(0,s.jsx)(n.code,{children:"properties"}),"、",(0,s.jsx)(n.code,{children:"patternProperties"})," 之外的属性；"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"除此之外，Schema 节点还支持一些通用的规则字段，包括："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"enum"}),"：枚举数组，属性值必须完全等于(Deep equal)这些值之一，例如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// JSON-Schema\n{\n  "type": "string",\n  "enum": [\n    "fanwenjie",\n    "tecvan"\n  ]\n}\n\n// 有效值：\n"fanwenjie"/"tecvan"\n// 无效值，如：\n"foo bar" 等\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"const"}),"：静态数值，属性值必须完全等于 ",(0,s.jsx)(n.code,{children:"const"})," 定义，单独看 ",(0,s.jsx)(n.code,{children:"const"})," 似乎作用不大，但配合 ",(0,s.jsx)(n.a,{href:"https://ajv.js.org/guide/combining-schemas.html#data-reference",target:"_blank",rel:"noopener noreferrer",children:"$data"})," 指令的 ",(0,s.jsx)(n.a,{href:"https://datatracker.ietf.org/doc/rfc6901/",target:"_blank",rel:"noopener noreferrer",children:"JSON-Pointer"})," 能力，可以实现关联相等的效果，例如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// JSON-Schema\n{\n  type: "object",\n  properties: {\n    foo: {type: "string"},\n    bar: {const: {$data: "1/foo"}}\n  }\n}\n\n// bar 必须等于 foo，如：\n{\n  "foo": "fanwenjie",\n  "bar": "fanwenjie"\n}\n// 否则无效：\n{\n  "foo": "fanwenjie",\n  "bar": "tecvan"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这些基础数据类型与校验规则奠定了 ",(0,s.jsx)(n.code,{children:"ajv"})," 的基础校验能力，我们使用 ",(0,s.jsx)(n.code,{children:"schema-utils"})," 时大部分时间都需要与之打交道，建议同学们多加学习掌握。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"ajv"})," 复合条件指令"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["除上述介绍的基本类型与基础校验规则外，",(0,s.jsx)(n.code,{children:"ajv"})," 还提供了若干",(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#compound-keywords",target:"_blank",rel:"noopener noreferrer",children:"复合校验指令"}),"："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#not",target:"_blank",rel:"noopener noreferrer",children:"not"}),"：数值必须不符合该条件，例如：",(0,s.jsx)(n.code,{children:'{type: "number", not: {minimum: 3}}'})," 时，传入数值必须小于 3；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#anyof",target:"_blank",rel:"noopener noreferrer",children:"anyof"}),"：数值必须满足 ",(0,s.jsx)(n.code,{children:"anyof"})," 条件之一，这是一个非常实用的指令，例如在 ",(0,s.jsx)(n.code,{children:"css-loader"})," 中："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// css-loader/src/options.json\n{\n  "additionalProperties": false,\n  "properties": {\n    "url": {\n      "description": "Enables/Disables \'url\'/\'image-set\' functions handling (https://github.com/webpack-contrib/css-loader#url).",\n      "anyOf": [\n        {\n          "type": "boolean"\n        },\n        {\n          "instanceof": "Function"\n        }\n      ]\n    },\n    // more properties\n  },\n  "type": "object"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这意味着 ",(0,s.jsx)(n.code,{children:"css-loader"})," 的 ",(0,s.jsx)(n.code,{children:"url"})," 配置项只接受 Bool 或函数值。"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#oneof",target:"_blank",rel:"noopener noreferrer",children:"oneof"}),"：数值必须满足且只能满足 ",(0,s.jsx)(n.code,{children:"oneof"})," 条件之一，例如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  type: "number",\n  oneOf: [{maximum: 3}, {type: "integer"}]\n}\n// 下述数值符合要求：\n1.1、2.1、4、5 等\n\n// 下述数值不符合要求：\n3.5、2、1 等\n'})}),"\n",(0,s.jsx)(n.p,{children:"数值要么是小于等于3的浮点数，要么是大于3的整数，不在此区间的数值如“3.5/2” 等均不符合要求。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ajv.js.org/json-schema.html#allof",target:"_blank",rel:"noopener noreferrer",children:"allof"}),"：数值必须满足 ",(0,s.jsx)(n.code,{children:"allof"})," 指定的所有条件，例如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  type: "number",\n  allOf: [{maximum: 3}, {type: "integer"}]\n}\n// 下述数值符合要求：\n1、2、3 等\n\n// 下述数值不符合要求：\n1.1、4、5 等\n'})}),"\n",(0,s.jsx)(n.p,{children:"这要求传入的数值必须小于 3，且必须为整型。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"if/then/else"}),"：这是一个稍显复杂的三元组复合条件，大致逻辑为：若传入的数值满足 ",(0,s.jsx)(n.code,{children:"if"})," 条件，则必须同时满足 ",(0,s.jsx)(n.code,{children:"then"})," 条件；若不满足 ",(0,s.jsx)(n.code,{children:"if"})," 则必须同时满足 ",(0,s.jsx)(n.code,{children:"else"}),"，其中 ",(0,s.jsx)(n.code,{children:"else"})," 可选。例如："]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  type: "object",\n  if: {properties: {foo: {minimum: 10}}},\n  then: {required: ["bar"]},\n  else: {required: ["baz"]}\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["这意味着，若传入的 ",(0,s.jsx)(n.code,{children:"foo"})," 属性值大于等于 10 时，则必须同时提供 ",(0,s.jsx)(n.code,{children:"then"})," 所要求的 ",(0,s.jsx)(n.code,{children:"bar"})," 属性；否则必须同时提供 ",(0,s.jsx)(n.code,{children:"else"})," 所要求的 ",(0,s.jsx)(n.code,{children:"baz"})," 属性。"]}),"\n",(0,s.jsxs)(n.p,{children:["总结一下，Webpack 官方选择 ",(0,s.jsx)(n.code,{children:"ajv"})," 作用配置参数的校验工具，并将其二次封装为 ",(0,s.jsx)(n.code,{children:"schema-utils"})," 库，供 Webpack 生态下的诸多 Loader、Plugin 使用。"]}),"\n",(0,s.jsxs)(n.p,{children:["而上面介绍的基础类型、类型校验、复合校验规则等内容是 ",(0,s.jsx)(n.code,{children:"ajv"})," 非常基础且重要的知识点，三者协作组成 ",(0,s.jsx)(n.code,{children:"ajv"})," 校验 ",(0,s.jsx)(n.code,{children:"schema"})," 的框架结构，除此之外还有许多增强 Schema 表述能力的增强指令，包括：",(0,s.jsx)(n.code,{children:"$data"}),"、",(0,s.jsx)(n.code,{children:"$ref"}),"、",(0,s.jsx)(n.code,{children:"definitions"})," 等，篇幅关系这里不一一列举。同学们也可以参考 Webpack 官方编写的 ",(0,s.jsx)(n.a,{href:"https://github1s.com/webpack/webpack/blob/HEAD/schemas/WebpackOptions.json",target:"_blank",rel:"noopener noreferrer",children:"Schema 文件"}),"，学习各种校验规则的写法。"]}),"\n",(0,s.jsxs)(n.h2,{id:"使用-loader-utils",children:["使用 ",(0,s.jsx)(n.code,{children:"loader-utils"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用-loader-utils",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 Webpack5 之前，",(0,s.jsx)(n.a,{href:"https://github.com/webpack/loader-utils",target:"_blank",rel:"noopener noreferrer",children:"loader-utils"})," 是一个非常重要的 Loader 开发辅助工具，为开发者提供了诸如 ",(0,s.jsx)(n.code,{children:"getOptions/getCurrentRequest/parseQuery"})," 等核心接口，这些接口被诸多 Loader 广泛使用，到 Webpack5 之后干脆将这部分能力迁移到 Loader Context，致使 ",(0,s.jsx)(n.code,{children:"loader-utils"})," 被大幅裁减简化。"]}),"\n",(0,s.jsxs)(n.p,{children:["被裁减后的 ",(0,s.jsx)(n.code,{children:"loader-utils"})," 仅保留了四个接口："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"urlToRequest"}),"：用于将模块路径转换为文件路径的工具函数；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"isUrlRequest"}),"：用于判定字符串是否为模块请求路径；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"getHashDigest"}),"：用于计算内容 Hash 值；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"interpolateName"}),"：用于拼接文件名的模板工具；"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["翻阅大量 Loader 源码后发现，前三个接口使用率极低，实用性不大，因此本文直接跳过，仅侧重介绍 ",(0,s.jsx)(n.code,{children:"interpolateName"})," 接口。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["使用 ",(0,s.jsx)(n.code,{children:"interpolateName"})," 拼接文件名"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Webpack 支持以类似 ",(0,s.jsx)(n.code,{children:"[path]/[name]-[hash].js"})," 方式设定 ",(0,s.jsx)(n.code,{children:"output.filename"})," 即输出文件的命名，这一层规则通常不需要关注，但在编写类似 ",(0,s.jsx)(n.a,{href:"https://github.com/webpack-contrib/file-loader",target:"_blank",rel:"noopener noreferrer",children:"webpack-contrib/file-loader"})," 这种自行输出产物文件的 Loader 时，需要由开发者自行处理产物路径逻辑。"]}),"\n",(0,s.jsxs)(n.p,{children:["此时可以使用 ",(0,s.jsx)(n.code,{children:"loader-utils"})," 提供的 ",(0,s.jsx)(n.code,{children:"interpolateName"})," 方法在 Loader 中以类似 Webpack 的 ",(0,s.jsx)(n.code,{children:"output.filename"})," 规则拼接资源路径及名称，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// file-loader/src/index.js\nimport { interpolateName } from 'loader-utils';\n\nexport default function loader(content) {\n  const context = options.context || this.rootContext;\n  const name = options.name || '[contenthash].[ext]';\n\n  // 拼接最终输出的名称\n  const url = interpolateName(this, name, {\n    context,\n    content,\n    regExp: options.regExp,\n  });\n\n  let outputPath = url;\n  // ...\n\n  let publicPath = `__webpack_public_path__ + ${JSON.stringify(outputPath)}`;\n  // ...\n\n  if (typeof options.emitFile === 'undefined' || options.emitFile) {\n    // ...\n\n    // 提交、写出文件\n    this.emitFile(outputPath, content, null, assetInfo);\n  }\n  // ...\n\n  const esModule =\n    typeof options.esModule !== 'undefined' ? options.esModule : true;\n\n  // 返回模块化内容\n  return `${esModule ? 'export default' : 'module.exports ='} ${publicPath};`;\n}\n\nexport const raw = true;\n"})}),"\n",(0,s.jsx)(n.p,{children:"代码的核心逻辑："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["根据 Loader 配置，调用 ",(0,s.jsx)(n.code,{children:"interpolateName"})," 方法拼接目标文件的完整路径；"]}),"\n",(0,s.jsxs)(n.li,{children:["调用上下文 ",(0,s.jsx)(n.code,{children:"this.emitFile"})," 接口，写出文件；"]}),"\n",(0,s.jsxs)(n.li,{children:["返回 ",(0,s.jsx)(n.code,{children:"module.exports = ${publicPath}"})," ，其它模块可以引用到该文件路径。"]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["提示：除 ",(0,s.jsx)(n.code,{children:"file-loader"})," 外，",(0,s.jsx)(n.code,{children:"css-loader"}),"、",(0,s.jsx)(n.code,{children:"eslint-loader"})," 都有用到该接口，感兴趣的同学请自行前往查阅源码。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"interpolateName"})," 功能稍弱于 Webpack 的 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/output/#template-strings",target:"_blank",rel:"noopener noreferrer",children:"Template String"})," 规则，仅支持如下占位符："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[ext]"}),"：原始资源文件的扩展名，如 ",(0,s.jsx)(n.code,{children:".js"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[name]"}),"：原始文件名；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[path]"}),"：原始文件相对 ",(0,s.jsx)(n.code,{children:"context"})," 参数的路径；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[hash]"}),"：原始文件的内容 Hash 值，与 ",(0,s.jsx)(n.code,{children:"output.file"})," 类似同样支持 ",(0,s.jsx)(n.code,{children:"[hash:length]"})," 指定 Hash 字符串的长度；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"[contenthash]"}),"：作用、用法都与上述 ",(0,s.jsx)(n.code,{children:"[hash]"})," 一模一样。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"综合示例vue-loader",children:["综合示例：Vue-loader",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#综合示例vue-loader",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["接下来，我们再结合 ",(0,s.jsx)(n.a,{href:"https://vue-loader.vuejs.org/",target:"_blank",rel:"noopener noreferrer",children:"vue-loader"})," 源码进一步学习 Loader 开发的进阶技巧。",(0,s.jsx)(n.code,{children:"vue-loader"})," 是一个综合性很强的示例，它借助 Webpack 与组件的一系列特性巧妙地解决了：如何区分 Vue SFC 不同代码块，并复用其它 Loader 处理不同区块的内容？"]}),"\n",(0,s.jsxs)(n.p,{children:["先从结构说起，",(0,s.jsx)(n.code,{children:"vue-loader"})," 内部实际上包含了三个组件："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lib/index.js"})," 定义的 Normal Loader，负责将 Vue SFC 不同区块转化为 JavaScript ",(0,s.jsx)(n.code,{children:"import"})," 语句，具体逻辑下面细讲；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lib/loaders/pitcher.js"})," 定义的 Pitch Loader，负责遍历的 ",(0,s.jsx)(n.code,{children:"rules"})," 数组，拼接出完整的行内引用路径；"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lib/plugin.js"})," 定义的插件，负责初始化编译环境，如复制原始 ",(0,s.jsx)(n.code,{children:"rules"})," 配置等；"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"三者协作共同完成对 SFC 的处理，使用时需要用户同时注册 Normal Loader 和 Plugin，如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'const VueLoaderPlugin = require("vue-loader/lib/plugin");\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /.vue$/,\n        use: [{ loader: "vue-loader" }],\n      }\n    ],\n  },\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"vue-loader"})," 运行过程大致上可以划分为两个阶段："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["预处理阶段：动态修改 Webpack 配置，注入 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 专用的一系列 ",(0,s.jsx)(n.code,{children:"module.rules"}),"；"]}),"\n",(0,s.jsx)(n.li,{children:"内容处理阶段：Normal Loader 配合 Pitch Loader 完成文件内容转译。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"预处理阶段",children:["预处理阶段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#预处理阶段",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"vue-loader"})," 插件会在 ",(0,s.jsx)(n.code,{children:"apply"})," 函数中动态修改 Webpack 配置，核心代码如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class VueLoaderPlugin {\n  apply (compiler) {\n    // ...\n\n    const rules = compiler.options.module.rules\n    // ...\n\n    const clonedRules = rules\n      .filter(r => r !== rawVueRules)\n      .map((rawRule) => cloneRule(rawRule, refs))\n\n    // ...\n\n    // global pitcher (responsible for injecting template compiler loader & CSS\n    // post loader)\n    const pitcher = {\n      loader: require.resolve('./loaders/pitcher'),\n      resourceQuery: query => {\n        if (!query) { return false }\n        const parsed = qs.parse(query.slice(1))\n        return parsed.vue != null\n      }\n      // ...\n    }\n\n    // replace original rules\n    compiler.options.module.rules = [\n      pitcher,\n      ...clonedRules,\n      ...rules\n    ]\n  }\n}\n\nfunction cloneRule (rawRule, refs) {\n    // ...\n}\n\nmodule.exports = VueLoaderPlugin\n"})}),"\n",(0,s.jsx)(n.p,{children:"拆开来看，插件主要完成两个任务："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["初始化并注册 Pitch Loader：代码第16行，定义pitcher对象，指定loader路径为 ",(0,s.jsx)(n.code,{children:"require.resolve('./loaders/pitcher')"})," ，并将pitcher注入到 ",(0,s.jsx)(n.code,{children:"rules"})," 数组首位。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"这种动态注入的好处是用户不用关注 —— 不去看源码根本不知道还有一个pitcher loader，而且能保证pitcher能在其他rule之前执行，确保运行顺序。"}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["复制 ",(0,s.jsx)(n.code,{children:"rules"})," 配置：代码第8行遍历 ",(0,s.jsx)(n.code,{children:"compiler.options.module.rules"})," 数组，也就是用户提供的 Webpack 配置中的 ",(0,s.jsx)(n.code,{children:"module.rules"})," 项，对每个rule执行 ",(0,s.jsx)(n.code,{children:"cloneRule"})," 方法复制规则对象。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["之后，将 Webpack 配置修改为 ",(0,s.jsx)(n.code,{children:"[pitcher, ...clonedRules, ...rules]"})," 。感受一下实际效果，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        test: /.vue$/i,\n        use: [{ loader: "vue-loader" }],\n      },\n      {\n        test: /\\.css$/i,\n        use: [MiniCssExtractPlugin.loader, "css-loader"],\n      },\n      {\n        test: /\\.js$/i,\n        exclude: /node_modules/,\n        use: {\n          loader: "babel-loader",\n          options: {\n            presets: [["@babel/preset-env", { targets: "defaults" }]],\n          },\n        },\n      },\n    ],\n  },\n  plugins: [\n    new VueLoaderPlugin(),\n    new MiniCssExtractPlugin({ filename: "[name].css" }),\n  ],\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"这里定义了三个 rule，分别对应 vue、js、css 文件。经过 plugin 转换之后的结果大概为："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'module.exports = {\n  module: {\n    rules: [\n      {\n        loader: "/node_modules/vue-loader/lib/loaders/pitcher.js",\n        resourceQuery: () => {},\n        options: {},\n      },\n      {\n        resource: () => {},\n        resourceQuery: () => {},\n        use: [\n          {\n            loader: "/node_modules/mini-css-extract-plugin/dist/loader.js",\n          },\n          { loader: "css-loader" },\n        ],\n      },\n      {\n        resource: () => {},\n        resourceQuery: () => {},\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: "babel-loader",\n            options: {\n              presets: [["@babel/preset-env", { targets: "defaults" }]],\n            },\n            ident: "clonedRuleSet-2[0].rules[0].use",\n          },\n        ],\n      },\n      {\n        test: /\\.vue$/i,\n        use: [\n          { loader: "vue-loader", options: {}, ident: "vue-loader-options" },\n        ],\n      },\n      {\n        test: /\\.css$/i,\n        use: [\n          {\n            loader: "/node_modules/mini-css-extract-plugin/dist/loader.js",\n          },\n          { loader: "css-loader" },\n        ],\n      },\n      {\n        test: /\\.vue$/i,\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: "babel-loader",\n            options: {\n              presets: [["@babel/preset-env", { targets: "defaults" }]],\n            },\n            ident: "clonedRuleSet-2[0].rules[0].use",\n          },\n        ],\n      },\n    ],\n  },\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"转换之后生成6个rule，按定义的顺序分别为："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["针对 ",(0,s.jsx)(n.code,{children:"xx.vue&vue"})," 格式路径生效的规则，只用了 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 的 Pitch 作为 Loader；"]}),"\n",(0,s.jsxs)(n.li,{children:["被复制的 CSS 处理规则，",(0,s.jsx)(n.code,{children:"use"})," 数组与开发者定义的规则相同；"]}),"\n",(0,s.jsxs)(n.li,{children:["被复制的 JS 处理规则，",(0,s.jsx)(n.code,{children:"use"})," 数组也跟开发者定义的规则相同；"]}),"\n",(0,s.jsxs)(n.li,{children:["开发者定义的 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 规则，内容及配置都不变；"]}),"\n",(0,s.jsxs)(n.li,{children:["开发者定义的css规则，用到 ",(0,s.jsx)(n.code,{children:"css-loader"}),"、",(0,s.jsx)(n.code,{children:"mini-css-extract-plugin loader"}),"；"]}),"\n",(0,s.jsxs)(n.li,{children:["开发者定义的js规则，用到 ",(0,s.jsx)(n.code,{children:"babel-loader"}),"。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["可以看到，第2、3项是从开发者提供的配置中复制过来的，内容相似，只是 ",(0,s.jsx)(n.code,{children:"cloneRule"})," 在复制过程会给这些规则重新定义 ",(0,s.jsx)(n.code,{children:"resourceQuery"})," 函数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function cloneRule (rawRule, refs) {\n    const rules = ruleSetCompiler.compileRules(`clonedRuleSet-${++uid}`, [{\n      rules: [rawRule]\n    }], refs)\n  \n    const conditions = rules[0].rules\n      .map(rule => rule.conditions)\n      // shallow flat\n      .reduce((prev, next) => prev.concat(next), [])\n\n    // ...\n  \n    const res = Object.assign({}, rawRule, {\n      resource: resources => {\n        currentResource = resources\n        return true\n      },\n      resourceQuery: query => {\n        if (!query) { return false }\n        const parsed = qs.parse(query.slice(1))\n        if (parsed.vue == null) {\n          return false\n        }\n        if (!conditions) {\n          return false\n        }\n        // 用import路径的lang参数测试是否适用于当前rule\n        const fakeResourcePath = `${currentResource}.${parsed.lang}`\n        for (const condition of conditions) {\n          // add support for resourceQuery\n          const request = condition.property === 'resourceQuery' ? query : fakeResourcePath\n          if (condition && !condition.fn(request)) {\n            return false\n          }\n        }\n        return true\n      }\n    })\n    // ...\n  \n    return res\n  }\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"cloneRule"})," 内部定义的 ",(0,s.jsx)(n.code,{children:"resourceQuery"})," 函数对应 ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/module/#ruleresourcequery",target:"_blank",rel:"noopener noreferrer",children:"module.rules.resourceQuery"})," 配置项，与我们经常用的 ",(0,s.jsx)(n.code,{children:"test"})," 差不多，都用于判断资源路径是否适用这个rule。这里 ",(0,s.jsx)(n.code,{children:"resourceQuery"})," 核心逻辑就是取出路径中的lang参数，伪造一个以 ",(0,s.jsx)(n.code,{children:"lang"})," 结尾的路径，传入rule的condition中测试路径名对该rule是否生效，例如下面这种会命中 ",(0,s.jsx)(n.code,{children:"/\\.js$/i"})," 规则："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import script from "./index.vue?vue&type=script&lang=js&"\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"vue-loader"})," 正是基于这一规则，为不同内容块 (css/js/template) 匹配、复用用户所提供的 rule 设置。"]}),"\n",(0,s.jsxs)(n.h3,{id:"内容处理阶段",children:["内容处理阶段",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内容处理阶段",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"插件处理完配置，webpack 运行起来之后，Vue SFC 文件会被多次传入不同的 Loader，经历多次中间形态变换之后才产出最终的 js 结果，大致上可以分为如下步骤："}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["路径命中 ",(0,s.jsx)(n.code,{children:"/\\.vue$/i"})," 规则，调用 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 生成中间结果 A；"]}),"\n",(0,s.jsxs)(n.li,{children:["结果 A 命中 ",(0,s.jsx)(n.code,{children:"xx.vue?vue"})," 规则，调用 ",(0,s.jsx)(n.code,{children:"vue-loader"})," Pitch Loader 生成中间结果 B；"]}),"\n",(0,s.jsx)(n.li,{children:"结果 B 命中具体 Loader，直接调用 Loader 做处理。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"过程大致为："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:"image.png"})}),"\n",(0,s.jsx)(n.p,{children:"举个转换过程的例子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// 原始代码\nimport xx from \'./index.vue\';\n// 第一步，命中 vue-loader，转换为：\nimport { render, staticRenderFns } from "./index.vue?vue&type=template&id=2964abc9&scoped=true&"\nimport script from "./index.vue?vue&type=script&lang=js&"\nexport * from "./index.vue?vue&type=script&lang=js&"\nimport style0 from "./index.vue?vue&type=style&index=0&id=2964abc9&scoped=true&lang=css&"\n\n// 第二步，命中 pitcher，转换为：\nexport * from "-!../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=template&id=2964abc9&scoped=true&"\nimport mod from "-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&"; \nexport default mod; export * from "-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&"\nexport * from "-!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/dist/cjs.js!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=style&index=0&id=2964abc9&scoped=true&lang=css&"\n\n// 第三步，根据行内路径规则按序调用loader\n'})}),"\n",(0,s.jsx)(n.p,{children:"每一步的细节，请继续往下看。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"第一次执行 vue-loader"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["在运行阶段，根据配置规则， Webpack 首先将原始的 SFC 内容传入 ",(0,s.jsx)(n.code,{children:"vue-loader"}),"，例如对于下面的代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// main.js\nimport xx from \'index.vue\';\n\n// index.vue 代码\n<template>\n  <div class="root">hello world</div>\n</template>\n\n<script>\nexport default {\n  data() {},\n  mounted() {\n    console.log("hello world");\n  },\n};\n<\/script>\n\n<style scoped>\n.root {\n  font-size: 12px;\n}\n</style>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["此时",(0,s.jsx)(n.strong,{children:"第一次"}),"执行 vue-loader ，执行如下逻辑："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"@vue/component-compiler-utils"})," 包的parse函数，将SFC 文本解析为AST对象；"]}),"\n",(0,s.jsx)(n.li,{children:"遍历 AST 对象属性，转换为特殊的引用路径；"}),"\n",(0,s.jsx)(n.li,{children:"返回转换结果。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["对于上述 ",(0,s.jsx)(n.code,{children:"index.vue"})," 内容，转换结果为："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import { render, staticRenderFns } from "./index.vue?vue&type=template&id=2964abc9&scoped=true&"\nimport script from "./index.vue?vue&type=script&lang=js&"\nexport * from "./index.vue?vue&type=script&lang=js&"\nimport style0 from "./index.vue?vue&type=style&index=0&id=2964abc9&scoped=true&lang=css&"\n\n\n/* normalize component */\nimport normalizer from "!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "2964abc9",\n  null\n  \n)\n\n...\nexport default component.exports\n'})}),"\n",(0,s.jsx)(n.p,{children:"注意，这里并没有真的处理 block 里面的内容，而是简单地针对不同类型的内容块生成 import 语句："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Script：",(0,s.jsx)(n.code,{children:'"./index.vue?vue&type=script&lang=js&"'})]}),"\n",(0,s.jsxs)(n.li,{children:["Template: ",(0,s.jsx)(n.code,{children:'"./index.vue?vue&type=template&id=2964abc9&scoped=true&"'})]}),"\n",(0,s.jsxs)(n.li,{children:["Style: ",(0,s.jsx)(n.code,{children:'"./index.vue?vue&type=style&index=0&id=2964abc9&scoped=true&lang=css&"'})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这些路径都对应原始的 ",(0,s.jsx)(n.code,{children:".vue"})," 路径基础上增加了 ",(0,s.jsx)(n.code,{children:"vue"})," 标志符及 type、lang 等参数。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"执行 Pitch Loader"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如前所述，",(0,s.jsx)(n.code,{children:"vue-loader"})," 插件会在预处理阶段插入带 ",(0,s.jsx)(n.code,{children:"resourceQuery"})," 函数的 Pitch Loader："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const pitcher = {\n  loader: require.resolve('./loaders/pitcher'),\n  resourceQuery: query => {\n    if (!query) { return false }\n    const parsed = qs.parse(query.slice(1))\n    return parsed.vue != null\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["其中， ",(0,s.jsx)(n.code,{children:"resourceQuery"})," 函数命中 ",(0,s.jsx)(n.code,{children:"xx.vue?vue"})," 格式的路径，也就是说上面 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 转换后的 import 路径会被 Pitch Loader 命中，做进一步处理。Pitch Loader 的逻辑比较简单，做的事情也只是转换 import 路径："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const qs = require('querystring')\n...\n\nconst dedupeESLintLoader = loaders => {...}\n\nconst shouldIgnoreCustomBlock = loaders => {...}\n\n// 正常的loader阶段，直接返回结果\nmodule.exports = code => code\n\nmodule.exports.pitch = function (remainingRequest) {\n  const options = loaderUtils.getOptions(this)\n  const { cacheDirectory, cacheIdentifier } = options\n  // 关注点1： 通过解析 resourceQuery 获取loader参数\n  const query = qs.parse(this.resourceQuery.slice(1))\n\n  let loaders = this.loaders\n\n  // if this is a language block request, eslint-loader may get matched\n  // multiple times\n  if (query.type) {\n    // if this is an inline block, since the whole file itself is being linted,\n    // remove eslint-loader to avoid duplicate linting.\n    if (/\\.vue$/.test(this.resourcePath)) {\n      loaders = loaders.filter(l => !isESLintLoader(l))\n    } else {\n      // This is a src import. Just make sure there's not more than 1 instance\n      // of eslint present.\n      loaders = dedupeESLintLoader(loaders)\n    }\n  }\n\n  // remove self\n  loaders = loaders.filter(isPitcher)\n\n  // do not inject if user uses null-loader to void the type (#1239)\n  if (loaders.some(isNullLoader)) {\n    return\n  }\n\n  const genRequest = loaders => {\n    ... \n  }\n\n  // Inject style-post-loader before css-loader for scoped CSS and trimming\n  if (query.type === `style`) {\n    const cssLoaderIndex = loaders.findIndex(isCSSLoader)\n    if (cssLoaderIndex > -1) {\n      ...\n      return query.module\n        ? `export { default } from  ${request}; export * from ${request}`\n        : `export * from ${request}`\n    }\n  }\n\n  // for templates: inject the template compiler & optional cache\n  if (query.type === `template`) {\n    .​..\n    // console.log(request)\n    // the template compiler uses esm exports\n    return `export * from ${request}`\n  }\n\n  // if a custom block has no other matching loader other than vue-loader itself\n  // or cache-loader, we should ignore it\n  if (query.type === `custom` && shouldIgnoreCustomBlock(loaders)) {\n    return ``\n  }\n\n  const request = genRequest(loaders)\n  return `import mod from ${request}; export default mod; export * from ${request}`\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"核心功能是遍历用户定义的rule数组，拼接出完整的行内引用路径，例如："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// 开发代码：\nimport xx from \'index.vue\'\n// 第一步，通过vue-loader转换成带参数的路径\nimport script from "./index.vue?vue&type=script&lang=js&"\n// 第二步，在 pitcher 中解读loader数组的配置，并将路径转换成完整的行内路径格式\nimport mod from "-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&";\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"第二次执行vue-loader"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["通过上面 ",(0,s.jsx)(n.code,{children:"vue-loader"})," -> Pitch Loader 处理后，会得到一个新的行内路径，例如："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'import mod from "-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-2[0].rules[0].use!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./index.vue?vue&type=script&lang=js&";\n'})}),"\n",(0,s.jsx)(n.p,{children:"以这个 import 语句为例，之后 Webpack 会按照下述逻辑运行："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 处理 ",(0,s.jsx)(n.code,{children:"index.js"})," 文件；"]}),"\n",(0,s.jsxs)(n.li,{children:["调用 ",(0,s.jsx)(n.code,{children:"babel-loader"})," 处理上一步返回的内容。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["这就给了 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 第二次执行的机会，再回过头来看看 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 的代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'module.exports = function (source) {\n  // ...\n\n  const {\n    target,\n    request,\n    minimize,\n    sourceMap,\n    rootContext,\n    resourcePath,\n    resourceQuery = "",\n  } = loaderContext;\n  // ...\n\n  const descriptor = parse({\n    source,\n    compiler: options.compiler || loadTemplateCompiler(loaderContext),\n    filename,\n    sourceRoot,\n    needMap: sourceMap,\n  });\n\n  // if the query has a type field, this is a language block request\n  // e.g. foo.vue?type=template&id=xxxxx\n  // and we will return early\n  if (incomingQuery.type) {\n    return selectBlock(\n      descriptor,\n      loaderContext,\n      incomingQuery,\n      !!options.appendExtension\n    );\n  }\n  //...\n  return code;\n};\n\nmodule.exports.VueLoaderPlugin = plugin;\n'})}),"\n",(0,s.jsxs)(n.p,{children:["第二次运行时由于路径已经带上了 ",(0,s.jsx)(n.code,{children:"type"})," 参数，会命中上面第26行的判断语句，进入 ",(0,s.jsx)(n.code,{children:"selectBlock"})," 函数，这个函数的逻辑很简单："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = function selectBlock (\n  descriptor,\n  loaderContext,\n  query,\n  appendExtension\n) {\n  // template\n  if (query.type === `template`) {\n    if (appendExtension) {\n      loaderContext.resourcePath += '.' + (descriptor.template.lang || 'html')\n    }\n    loaderContext.callback(\n      null,\n      descriptor.template.content,\n      descriptor.template.map\n    )\n    return\n  }\n\n  // script\n  if (query.type === `script`) {\n    if (appendExtension) {\n      loaderContext.resourcePath += '.' + (descriptor.script.lang || 'js')\n    }\n    loaderContext.callback(\n      null,\n      descriptor.script.content,\n      descriptor.script.map\n    )\n    return\n  }\n\n  // styles\n  if (query.type === `style` && query.index != null) {\n    const style = descriptor.styles[query.index]\n    if (appendExtension) {\n      loaderContext.resourcePath += '.' + (style.lang || 'css')\n    }\n    loaderContext.callback(\n      null,\n      style.content,\n      style.map\n    )\n    return\n  }\n\n  // custom\n  if (query.type === 'custom' && query.index != null) {\n    const block = descriptor.customBlocks[query.index]\n    loaderContext.callback(\n      null,\n      block.content,\n      block.map\n    )\n    return\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"至此，就可以完成从 Vue SFC 文件中抽取特定 Block 内容，并复用用户定义的其它 Loader 加载这些 Block。"}),"\n",(0,s.jsxs)(n.h3,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["综上，我们可以将 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 的核心逻辑总结为："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["首先给原始文件路径增加不同的参数，后续配合 ",(0,s.jsx)(n.code,{children:"resourceQuery"})," 参数就可以分开处理这些内容，这样的实现相比于一次性处理，逻辑更清晰简洁，更容易理解；"]}),"\n",(0,s.jsxs)(n.li,{children:["经过 Normal Loader、Pitch Loader 两个阶段后，SFC 内容会被转化为 ",(0,s.jsx)(n.code,{children:"import xxx from '!-babel-loader!vue-loader?xxx'"})," 格式的引用路径，以此复用用户配置。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["本文主要介绍如何使用 ",(0,s.jsx)(n.code,{children:"schema-utils"})," 与 ",(0,s.jsx)(n.code,{children:"loader-utils"})," 工具实现更多 Loader 进阶特性，并进一步剖析 ",(0,s.jsx)(n.code,{children:"vue-loader"})," 源码，讲解如何构建一个成熟的 Webpack Loader 组件。结合《",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7115598540721618944/section/7119035404715556879",target:"_blank",rel:"noopener noreferrer",children:"Loader 开发基础：从开源项目学到的 Loader 开发技巧"}),"》一文，我们可以总结一些常用的开发方法论，包括："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Loader 主要负责将资源内容转译为 Webpack 能够理解、处理的标准 JavaScript 形式，所以通常需要做 Loader 内通过 ",(0,s.jsx)(n.code,{children:"return"}),"/",(0,s.jsx)(n.code,{children:"this.callback"})," 方式返回翻译结果；"]}),"\n",(0,s.jsxs)(n.li,{children:["Loader Context 提供了许多实用接口，我们可以借助这些接口读取上下文信息，或改变 Webpack 运行状态(相当于产生 Side Effect，例如通过 ",(0,s.jsx)(n.code,{children:"emitFile"})," 接口)；"]}),"\n",(0,s.jsxs)(n.li,{children:["假若我们开发的 Loader 需要对外提供配置选项，建议使用 ",(0,s.jsx)(n.code,{children:"schema-utils"})," 校验配置参数是否合法；"]}),"\n",(0,s.jsxs)(n.li,{children:["假若 Loader 需要生成额外的资源文件，建议使用 ",(0,s.jsx)(n.code,{children:"loader-utils"})," 拼接产物路径；"]}),"\n",(0,s.jsxs)(n.li,{children:["执行时，Webpack 会按照 ",(0,s.jsx)(n.code,{children:"use"})," 定义的顺序从前到后执行 Pitch Loader，从后到前执行 Normal Loader，我们可以将一些预处理逻辑放在 Pitch 中(如 ",(0,s.jsx)(n.code,{children:"vue-loader"}),")；"]}),"\n",(0,s.jsx)(n.li,{children:"等等。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"最后，建议你同步翻阅一些知名 Loader 的源码(如：css-loader/babel-loader/file-loader 等)，结合这两篇文章介绍的知识点与方法论，透彻理解 Webpack Loader 的开发方式。"}),"\n",(0,s.jsxs)(n.h2,{id:"思考题",children:["思考题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#思考题",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["总结一下，",(0,s.jsx)(n.code,{children:"vue-loader"})," 中的 Pitch Loader 与 Normal Loader 分别做了什么事情？两者是怎么串联协作起来的？"]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["Webpack5%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5%2F20.Loader%20%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%A5%BD%20Loader%20%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%EF%BC%9F.md"]={toc:[{text:"使用 `schema-utils`",id:"使用-schema-utils",depth:2},{text:"使用 `loader-utils`",id:"使用-loader-utils",depth:2},{text:"综合示例：Vue-loader",id:"综合示例vue-loader",depth:2},{text:"预处理阶段",id:"预处理阶段",depth:3},{text:"内容处理阶段",id:"内容处理阶段",depth:3},{text:"小结",id:"小结",depth:3},{text:"总结",id:"总结",depth:2},{text:"思考题",id:"思考题",depth:2}],title:"20.Loader 开发进阶：如何用好 Loader 扩展开发工具？",headingTitle:"20.Loader 开发进阶：如何用好 Loader 扩展开发工具？",frontmatter:{}}}}]);