"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["96096"],{547611:function(e,r,n){n.r(r),n.d(r,{default:()=>A});var s=n(552676),l=n(740453);let a=n.p+"static/image/fa783928aa6b975bfa0f71e09970b300.68b815ad.png",i=n.p+"static/image/44bfff3d404eed3811b87e36156f91ef.6defc5e0.png",t=n.p+"static/image/264d1f62a5ae04793f61ccd346fe208a.92ba4327.png",c=n.p+"static/image/8e2280a01ffa2b64f278858c63cc249b.0fc09da3.png",p=n.p+"static/image/44d2f0166bd4b922279c44b1e2ff4d70.abbc42f3.png",o=n.p+"static/image/d2d9b4c73779b17a06042bfeacad68de.92fc4200.png",d=n.p+"static/image/210d63355b7be1ef37bb2fdec06f1d25.cdb858f4.png",h=n.p+"static/image/55766de7e7ad10b3cd911a8dc53e8991.5da47b54.png",b=n.p+"static/image/6037386ab20bf807093394561d70455f.0991b779.png",m=n.p+"static/image/8a2b924c0436ece1731c9637bb48f90c.9772c56a.png",j=n.p+"static/image/15e58e295d6c3a4bd1b0199137c7bc1f.0412c206.png",x=n.p+"static/image/8bcf34e6df46bb6e8556e6665c8bd753.09523556.png",g=n.p+"static/image/d6023381af0242c1f218a14b808922e3.af52d5d1.png",u=n.p+"static/image/13ee018b5be03557dc79fcdf24c87030.b3df177a.png",f=n.p+"static/image/4cd8f3b7fa05c73bd38f297fe71cd386.dd50e39c.png",y=n.p+"static/image/99000597d0c6b077f8da9fed18fa59c9.e45af31b.png",v=n.p+"static/image/14776eccb60f14752af6e6a698878e0a.b48ff1aa.png",B=n.p+"static/image/d592af037e1a909e7f60a306f9b066de.6aee303f.png",w=n.p+"static/image/3448de9935f9630402a5bf3a602d9333.3b15a35d.png",E=n.p+"static/image/46187dbec939975d49eb6e2ab93e5d10.c05ac8ce.png",_=n.p+"static/image/94dfaca57d94c06aa7b6660b54a31e27.3fe15f03.png";function k(e){let r=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",h5:"h5",code:"code",pre:"pre",ul:"ul",li:"li",h4:"h4",h3:"h3"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"13babel-的内置功能下",children:["13.Babel 的内置功能（下）",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#13babel-的内置功能下",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"上一节我们学习了 babel 插件的分类、babel 的 preset、helper、runtime。babel 的功能基本都建立在这些之上。"}),"\n",(0,s.jsx)(r.p,{children:"我们通过插件完成了各种代码（es next、proposal、typescript/flow/jsx...）到 es5 的转换，然后把不同的转换插件封装到不同的 preset （preset-env、preset-typescript、preset-react...）里，而且还把插件内部的公共逻辑抽成 helper 来复用，并且提供了 runtime 包用于注入运行时的 api。这样已经能够达到不同语法的代码转 es5 同时对 api 进行 polyfill 的目标了。"}),"\n",(0,s.jsx)(r.p,{children:"平时我们使用 babel 并不需要了解 runtime、helper 都是什么，plugin 怎么写，只需要会用 preset 就行了。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:_,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"由 preset 引入一系列 plugin，我们只需要选择不同的 preset 即可。"}),"\n",(0,s.jsx)(r.p,{children:"那 babel 的 preset 都是怎么设计的呢？"}),"\n",(0,s.jsxs)(r.h2,{id:"preset-es20xx-到-preset-env",children:["preset-es20xx 到 preset-env",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#preset-es20xx-到-preset-env",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"babel6 支持的 preset 是 preset-es2015、preset-es2016、preset-stage-x 等。"}),"\n",(0,s.jsx)(r.p,{children:"也就是根据目标语言版本来指定一系列插件。"}),"\n",(0,s.jsx)(r.p,{children:"但是这样的 preset 设计有个问题："}),"\n",(0,s.jsx)(r.p,{children:"指定了目标环境支持 es5，但如果目标环境支持了部分 es6（es2015）、es7（es2016）等，那岂不是做了很多没必要的转换？"}),"\n",(0,s.jsx)(r.p,{children:"还有，reset-es2015、preset-es2016、preset-stage-x 这种 preset 跟随版本走的，那岂不是经常变，得经常改这些 preset 的内容 （当某个提案从 stage 0 进入到 stage 1 就得改下），这样多麻烦啊，而且用户也得经常改配置，stage-x 用到了啥对用户来说也是黑盒。"}),"\n",(0,s.jsx)(r.p,{children:"怎么解决这些问题呢？"}),"\n",(0,s.jsx)(r.p,{children:"babel6 到 babel7 的变化给出了答案："}),"\n",(0,s.jsx)(r.p,{children:"babel7 废弃了 stage-x 和 es20xx 的 preset，改成 preset-env 和 plugin-proposal-xx 的方式。"}),"\n",(0,s.jsxs)(r.p,{children:["这样就不需要指定用的是 es 几了，默认会全部支持，包含",(0,s.jsx)(r.a,{href:"https://github.com/babel/babel/blob/master/packages/babel-compat-data/scripts/data/plugin-features.js",target:"_blank",rel:"noopener noreferrer",children:"所有的已经是语言标准特性的 transform plugin"}),"。"]}),"\n",(0,s.jsx)(r.p,{children:"而且 stage-x 有哪些不再是黑盒，用户想用啥 proposal 的特性直接显示引入对应的 proposal plugin。"}),"\n",(0,s.jsx)(r.p,{children:"做了很多无用的转换的问题通过指定目标环境来解决。"}),"\n",(0,s.jsx)(r.p,{children:"但是目标环境那么多，浏览器版本、node 版本、electron 版本每年都在变，怎么做到精准？"}),"\n",(0,s.jsxs)(r.h5,{id:"compat-table",children:["compat-table",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#compat-table",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"答案是 compat-table 的数据，compat-table 提供了每个特性在不同环境中的支持版本。"}),"\n",(0,s.jsxs)(r.p,{children:["比如",(0,s.jsx)(r.a,{href:"https://github.com/kangax/compat-table/blob/gh-pages/data-es6.js#L1864-L1904",target:"_blank",rel:"noopener noreferrer",children:"默认参数"}),"这个 es2015 的特性，可以查到在 babel6 且 corejs2 以上支持，在 chrome 中是 49 以上支持，chrome48 中还是实验特性，在 node6 以上支持，等等。"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"光是这些数据还不够，electron 有自己的版本，要支持 electron 得需要 electron 版本和它用的 chromuim 的版本的对应关系。"}),"\n",(0,s.jsxs)(r.p,{children:["万幸有 electron-to-chromium 这个项目，它维护了 ",(0,s.jsx)(r.a,{href:"https://github.com/Kilian/electron-to-chromium/blob/master/full-versions.js",target:"_blank",rel:"noopener noreferrer",children:"electron 版本到 chromium 版本的映射关系"}),"。"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsxs)(r.p,{children:["也可以反过来查询 ",(0,s.jsx)(r.a,{href:"https://github.com/Kilian/electron-to-chromium/blob/master/full-chromium-versions.js",target:"_blank",rel:"noopener noreferrer",children:"chromium 版本在哪些 electron 版本中使用"}),"。"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"有了这些数据，我们就能知道每一个特性在哪些环境的什么版本支持。"}),"\n",(0,s.jsxs)(r.p,{children:["babel7 在 @babel/compat-data 这个包里面维护了这种特性到环境支持版本的映射关系，包括 ",(0,s.jsx)(r.a,{href:"https://github.com/babel/babel/blob/main/packages/babel-compat-data/data/plugins.json",target:"_blank",rel:"noopener noreferrer",children:"plugin 实现的特性的版本支持情况"}),"（包括 transform 和 proposal ），也包括 ",(0,s.jsx)(r.a,{href:"https://github.com/babel/babel/blob/main/packages/babel-compat-data/data/corejs2-built-ins.json",target:"_blank",rel:"noopener noreferrer",children:"corejs 所 polyfill 的特性的版本支持情况"}),"。"]}),"\n",(0,s.jsx)(r.p,{children:"比如："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"这样我们就知道每一个特性是在什么环境中支持的了，接下来只要用户指定一个环境，我们就能做到按需转换！"}),"\n",(0,s.jsxs)(r.h5,{id:"browserslist",children:["browserslist",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#browserslist",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"那开发者怎么指定环境呢？"}),"\n",(0,s.jsx)(r.p,{children:"让开发者写每个环境的版本是啥肯定不靠谱，这时候就要借助 browerslist 了，它提供了一个从 query （查询表达式） 到对应环境版本的转换。"}),"\n",(0,s.jsx)(r.p,{children:"比如我们可以通过 last 1 version 来查询最新的各环境的版本"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"也可以通过 supports es6-module 查询所有支持 es module 的环境版本"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsxs)(r.p,{children:["具体查询的语法有很多，可以去 ",(0,s.jsx)(r.a,{href:"https://github.com/browserslist/browserslist#queries",target:"_blank",rel:"noopener noreferrer",children:"browserslist 的 query 文档"}),"中学习，这里就不展开了。"]}),"\n",(0,s.jsxs)(r.h5,{id:"babelpreset-env",children:["@babel/preset-env",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#babelpreset-env",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"现在有了什么特性在什么环境版本中支持，有了可以通过 query 指定目标环境版本的工具，那么就可以上手改了，从都转成 es5 到根据目标环境确定不支持的特性，只转换这部分特性，这就是 @babel/preset-env 做的事情。"}),"\n",(0,s.jsxs)(r.p,{children:["有了 @babel/compat-data 的数据，那么只要用户指定他的目标环境是啥就可以了，这时候可以用 browserslist 的 query 来写，比如 ",(0,s.jsx)(r.code,{children:"last 1 version, > 1%"})," 这种字符串，babel 会使用 brwoserslist 来把它们转成目标环境具体版本的数据。"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"有了不同特性支持的环境的最低版本的数据，有了具体的版本，那么过滤出来的就是目标环境不支持的特性，然后引入它们对应的插件即可。这就是 preset-env 做的事情(按照目标环境按需引入插件)。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"配置方式比如："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'{\n    "presets": [["@babel/preset-env", { "targets": "> 0.25%, not dead" }]]\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"这样就通过 preset-env 解决了多转换了目标环境已经支持的特性的问题。"}),"\n",(0,s.jsx)(r.p,{children:"其实 polyfill 也可以通过 targets 来过滤。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"不再手动引入 polyfill，那么怎么引入？ 当然是用 preset-env 自动引入了。但是不是默认就会启用这个功能，需要配置。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'{\n    "presets": [["@babel/preset-env", { \n        "targets": "> 0.25%, not dead",\n        "useBuiltIns": "usage",// or "entry" or "false"\n        "corejs": 3\n    }]]\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"配置下 corejs 和 useBuiltIns。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"corejs 就是 babel 7 所用的 polyfill，需要指定下版本，corejs 3 才支持实例方法（比如 Array.prototype.fill ）的 polyfill。"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"useBuiltIns 就是使用 polyfill （corejs）的方式，是在入口处全部引入（entry），还是每个文件引入用到的（usage），或者不引入（false）。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"配置了这两个 option 就可以自动引入 polyfill 了。"}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsxs)(r.h4,{id:"babelpreset-env-的配置",children:["@babel/preset-env 的配置",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#babelpreset-env-的配置",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"这个包的配置比较多，首先我们要指定的是 targets，也就是 browserslist 的 query，这个同样可以在 .browserslistrc 的配置文件中指定（别的工具也可能用到）。"}),"\n",(0,s.jsxs)(r.p,{children:["具体有啥配置可以看 ",(0,s.jsx)(r.a,{href:"https://www.babeljs.cn/docs/babel-preset-env",target:"_blank",rel:"noopener noreferrer",children:"@babel/preset-env 的文档"}),"，这里简单讲几个："]}),"\n",(0,s.jsxs)(r.h5,{id:"targets",children:["targets",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#targets",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"targets 是指定编译的目标环境的，可以配 query 或者直接指定环境版本（query 的结果也是环境版本）。"}),"\n",(0,s.jsx)(r.p,{children:"环境有这些："}),"\n",(0,s.jsx)(r.p,{children:"chrome, opera, edge, firefox, safari, ie, ios, android, node, electron"}),"\n",(0,s.jsx)(r.p,{children:"可以指定 query："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'{\n  "targets": "> 0.25%, not dead"\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"也可以直接指定环境版本；"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'{\n  "targets": {\n    "chrome": "58",\n    "ie": "11"\n  }\n}\n'})}),"\n",(0,s.jsxs)(r.h5,{id:"include--exclude",children:["include & exclude",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#include--exclude",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["通过 targets 的指定，babel 会自动引入",(0,s.jsx)(r.a,{href:"https://github.com/babel/babel/blob/master/packages/babel-compat-data/scripts/data/plugin-features.js",target:"_blank",rel:"noopener noreferrer",children:"一些插件"}),"，但如果觉得自动引入的不大对，也可以手动指定。"]}),"\n",(0,s.jsx)(r.p,{children:"当需要手动指定要 include 或者 exclude 什么插件的时候可以使用这个 option。"}),"\n",(0,s.jsx)(r.p,{children:"不过这个只是针对 transform plugin，对于 proposal plugin，要在 plugins 的 option 单独引入。"}),"\n",(0,s.jsx)(r.p,{children:"一般情况下用 preset-env 自动引入的就可以了。"}),"\n",(0,s.jsxs)(r.h5,{id:"modules",children:["modules",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#modules",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"babel 转换代码自然会涉及到模块语法的转换。"}),"\n",(0,s.jsx)(r.p,{children:"modules 就是指定目标模块规范的，取值有 amd、umd、systemjs、commonjs (cjs)、auto、false。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"amd、umd、systemjs、commonjs (cjs) 这四个分别指定不同的目标模块规范"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"false 是不转换模块规范"}),"\n"]}),"\n",(0,s.jsxs)(r.li,{children:["\n",(0,s.jsx)(r.p,{children:"auto 则是自动探测，默认值也是这个。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"其实一般这个 option 都是 bundler 来设置的，因为 bundler 负责模块转换，自然知道要转换成什么模块规范。我们平时就用默认值 auto 即可。"}),"\n",(0,s.jsx)(r.p,{children:"auto 会根据探测到的目标环境支持的模块规范来做转换。依据是在 transform 的时候传入的 caller 数据。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:'babel.transformFileSync("example.js", {\n  caller: {\n    name: "my-custom-tool",\n    supportsStaticESM: true,\n  },\n});\n'})}),"\n",(0,s.jsx)(r.p,{children:"比如在调用 transformFile 的 api 的时候传入了 caller 是支持 esm 的，那么在 targets 的 modules 就会自动设置为 esm。"}),"\n",(0,s.jsxs)(r.h5,{id:"debug",children:["debug",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#debug",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"我们知道 preset-env 会根据 targets 支持的特性来引入一系列插件。"}),"\n",(0,s.jsx)(r.p,{children:"想知道最终使用了啥插件，那就可以把 debug 设为 true，这样在控制台打印这些数据。"}),"\n",(0,s.jsx)(r.p,{children:"比如"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"const sourceCode = `\n  import \"core-js\";\n  new Array(5).fill('111');\n`;\n\nconst { code, map } = babel.transformSync(sourceCode, {\n    filename: 'a.mjs',\n    targets: {\n        browsers: 'Chrome 45',\n    },\n    presets: [\n        ['@babel/env', {\n            debug: true,\n            useBuiltIns: 'usage',\n            corejs: 3\n        }]\n    ]\n});\n\n"})}),"\n",(0,s.jsx)(r.p,{children:"设置 debug 为 true，会打印 targets 和根据 tragets 过滤出的的 plugin 和 preset："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:'@babel/preset-env: `DEBUG` option\n\nUsing targets:\n{\n  "chrome": "45"\n}\n\nUsing modules transform: auto\n\nUsing plugins:\n  proposal-numeric-separator { chrome < 75 }\n  proposal-logical-assignment-operators { chrome < 85 }\n  proposal-nullish-coalescing-operator { chrome < 80 }\n  proposal-optional-chaining { chrome }\n  proposal-json-strings { chrome < 66 }\n  proposal-optional-catch-binding { chrome < 66 }\n  transform-parameters { chrome < 49 }\n  proposal-async-generator-functions { chrome < 63 }\n  proposal-object-rest-spread { chrome < 60 }\n  transform-dotall-regex { chrome < 62 }\n  proposal-unicode-property-regex { chrome < 64 }\n  transform-named-capturing-groups-regex { chrome < 64 }\n  transform-async-to-generator { chrome < 55 }\n  transform-exponentiation-operator { chrome < 52 }\n  transform-function-name { chrome < 51 }\n  transform-arrow-functions { chrome < 47 }\n  transform-classes { chrome < 46 }\n  transform-object-super { chrome < 46 }\n  transform-for-of { chrome < 51 }\n  transform-sticky-regex { chrome < 49 }\n  transform-unicode-regex { chrome < 50 }\n  transform-spread { chrome < 46 }\n  transform-destructuring { chrome < 51 }\n  transform-block-scoping { chrome < 49 }\n  transform-new-target { chrome < 46 }\n  transform-regenerator { chrome < 50 }\n  proposal-export-namespace-from { chrome < 72 }\n  transform-modules-commonjs\n  proposal-dynamic-import\ncorejs3: `DEBUG` option\n\nUsing targets: {\n  "chrome": "45"\n}\n\nUsing polyfills with `usage-global` method:\nregenerator: `DEBUG` option\n\nUsing targets: {\n  "chrome": "45"\n}\n\nUsing polyfills with `usage-global` method:\n\n  When setting `useBuiltIns: \'usage\'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `core-js` or use `useBuiltIns: \'entry\'` instead.\n\n[/Users/zhaixuguang/code/research/babel/a.mjs]\nBased on your code and targets, the corejs3 polyfill did not add any polyfill.\n\n[/Users/zhaixuguang/code/research/babel/a.mjs]\nBased on your code and targets, the regenerator polyfill did not add any polyfill.\n\n'})}),"\n",(0,s.jsx)(r.p,{children:"用到了哪些插件一目了然，开发时可以开启这个配置项。"}),"\n",(0,s.jsx)(r.p,{children:"我们知道了 preset-env 能够根据目标环境引入对应的插件，最终会注入 helper 到代码里，但这样还是有问题的："}),"\n",(0,s.jsxs)(r.h2,{id:"从-helper-到-runtime",children:["从 helper 到 runtime",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#从-helper-到-runtime",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"preset-env 会在使用到新特性的地方注入 helper 到 AST 中，并且会引入用到的特性的 polyfill （corejs + regenerator），这样会导致两个问题："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"重复注入 helper 的实现，导致代码冗余"}),"\n",(0,s.jsx)(r.li,{children:"polyfill 污染全局环境"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"解决这两个问题的思路就是抽离出来，然后作为模块引入，这样多个模块复用同一份代码就不会冗余了，而且 polyfill 是模块化引入的也不会污染全局环境。"}),"\n",(0,s.jsx)(r.p,{children:"使用 transform-runtime 之前："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"使用 transform-runtime 之后："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"这个逻辑是在 @babel/plugin-transform-runtime 包里实现的。它可以把直接注入全局的方式改成模块化引入。"}),"\n",(0,s.jsx)(r.p,{children:"比如使用 preset-env 的时候是全局引入的："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"当引入 @babel/plugin-transform-runtime 就可以模块化引入："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"这样就不再污染全局环境了。"}),"\n",(0,s.jsx)(r.p,{children:"babel7 通过 preset-env 实现了按需编译和 polyfill，还可以用 plugin-transform-runtime 来变成从 @babel/runtime 包引入的方式。"}),"\n",(0,s.jsx)(r.p,{children:"但这也不是完美的，还有一些问题："}),"\n",(0,s.jsxs)(r.h3,{id:"babel7-的问题",children:["babel7 的问题",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#babel7-的问题",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"我们先来试验一下："}),"\n",(0,s.jsx)(r.p,{children:"看一下 Array.prototype.fill 的环境支持情况："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"可以看到在 Chrome 45 及以上支持这个特性，而在 Chrome 44 就不支持了。"}),"\n",(0,s.jsx)(r.p,{children:"我们先单独试一下 preset-env："}),"\n",(0,s.jsx)(r.p,{children:"当指定 targets 为 Chrome 44 时，应该自动引入polyfill："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"当指定 targets 为 Chrome 45 时，不需要引入polyfill："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"结果都符合预期，44 引入，45 不引入。"}),"\n",(0,s.jsx)(r.p,{children:"我们再来试试 @babel/plugin-transform-runtime："}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"是不是发现问题了，Chrome 45 不是支持 Array.prototype.fill 方法么，为啥还是引入了 polyfill。"}),"\n",(0,s.jsx)(r.p,{children:"因为 babel 中插件的应用顺序是：先 plugin 再 preset，plugin 从左到右，preset 从右到左，这样 plugin-transform-runtime 是在 preset-env 前面的。等 @babel/plugin-transform-runtime 转完了之后，再交给 preset-env 这时候已经做了无用的转换了。而 @babel/plugin-transform-runtime 并不支持 targets 的配置，就会做一些多余的转换和 polyfill。"}),"\n",(0,s.jsx)(r.p,{children:"这个问题在即将到来的 babel8 中得到了解决。"}),"\n",(0,s.jsxs)(r.h3,{id:"babel8",children:["babel8",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#babel8",children:"#"})]}),"\n",(0,s.jsxs)(r.p,{children:["babel8 提供了 ",(0,s.jsx)(r.a,{href:"https://github.com/babel/babel-polyfills",target:"_blank",rel:"noopener noreferrer",children:"一系列 babel polyfill 的包 "}),"  ，解决了 babel7 的 @babel/plugin-transform-runtime 的遗留问题，可以通过 targets 来按需精准引入 polyfill。"]}),"\n",(0,s.jsx)(r.p,{children:"babel8 支持配置一个 polyfill provider，也就是说你可以指定 corejs2、corejs3、es-shims 等 polyfill，还可以自定义 polyfil。"}),"\n",(0,s.jsx)(r.p,{children:"有了 polyfill 源之后，使用 polyfill 的方式也把之前 transform-runtime 做的事情内置了，从之前的 useBuiltIns: entry、 useBuiltIns: usage 的两种，变成了 3 种："}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"entry-global: 这个和之前的 useBuiltIns: entry 对标，就是全局引入 polyfill。"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"usage-entry: 这个和 useBuiltIns: usage 对标，就是具体模块引入用到的 polyfill。"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"usage-pure：这个就是之前需要 transform-runtime 插件做的事情，使用不污染全局变量的 pure 的方式引入具体模块用到的 polyfill."}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(r.p,{children:"其实这三种方式 babel 7 也支持，但是 babel8 不再需要 transform-runtime 插件了，而且还支持了 polyfill provider 的配置。"}),"\n",(0,s.jsx)(r.p,{children:"babel 的功能都是通过插件完成的，但是直接指定插件太过麻烦，所以设计出了 preset，我们学习 babel 的内置功能基本等价于学习 preset 的使用。主要是 preset-env、preset-typescript 这些。"}),"\n",(0,s.jsx)(r.p,{children:"但是一些 proposal 的插件需要单独引入，并且 @babel/plugin-transform-runtime也要单独引入。"}),"\n",(0,s.jsx)(r.p,{children:"学习内置功能的话 preset 是重点，但是最终完成功能的还是通过插件。"}),"\n",(0,s.jsxs)(r.h2,{id:"总结",children:["总结",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"上一节我们基于 plugin 和 preset 已经能够完成 esnext 等代码转目标环境 js 代码的功能，但是还不完美。"}),"\n",(0,s.jsx)(r.p,{children:"这一节我们介绍了 @babel/preset-env，它基于每种特性的在不同环境的最低支持版本的数据和配置的 targets 来过滤插件，这样能减少很多没必要的转换和 polyfill。"}),"\n",(0,s.jsx)(r.p,{children:"如果希望把一些公共的 helper、core-js、regenerator 等注入的 runtime 函数抽离出来，并且以模块化的方式引入，那么需要用 @babel/plugin-transform-runtime 这个包。"}),"\n",(0,s.jsx)(r.p,{children:"@babel/plugin-transform-runtime 不支持根据 targets 的过滤，和 @babel/preset-env 配合时有问题，这个在 babel8 中得到了解决。babel8 提供了很多 babel polyfill 包，支持了 polyfill provider 的配置，而且还可以选择注入方式。不再需要 @babel/plugin-transform-runtime 插件了。"}),"\n",(0,s.jsx)(r.p,{children:"学完这一节，我们知道了 babel 如何基于 targets 的配置做到精准的转换，我们平时开发主要是使用 preset，了解下 preset 设计和演变还是很有意义的。"})]})}function N(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,l.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(k,{...e})}):k(e)}let A=N;N.__RSPRESS_PAGE_META={},N.__RSPRESS_PAGE_META["Babel%20%E6%8F%92%E4%BB%B6%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F13.Babel%20%E7%9A%84%E5%86%85%E7%BD%AE%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89.md"]={toc:[{text:"preset-es20xx 到 preset-env",id:"preset-es20xx-到-preset-env",depth:2},{text:"@babel/preset-env 的配置",id:"babelpreset-env-的配置",depth:4},{text:"从 helper 到 runtime",id:"从-helper-到-runtime",depth:2},{text:"babel7 的问题",id:"babel7-的问题",depth:3},{text:"babel8",id:"babel8",depth:3},{text:"总结",id:"总结",depth:2}],title:"13.Babel 的内置功能（下）",headingTitle:"13.Babel 的内置功能（下）",frontmatter:{}}}}]);