"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["85148"],{847747:function(e,n,r){r.r(n),r.d(n,{default:()=>g});var s=r(552676),c=r(740453);let a=r.p+"static/image/725d3b5f7768e6080ece83d2dcffd040.e3993d70.webp",t=r.p+"static/image/c625c3de25525896060a0cfff6af07c1.e920f471.webp",i=r.p+"static/image/7de038ac25f0452f0b9777d04e3b53d0.1922886e.webp",l=r.p+"static/image/23208490852673e1d75daa80654b7ca2.a321988b.webp",o=r.p+"static/image/72e712074c9cb9133bdd76fc14a40b11.a6003db1.webp",d=r.p+"static/image/0243c01bcc7962c80a08cbb418edbc63.95a54c6a.webp",h=r.p+"static/image/6dd6f7017479562f6830038a7c18f9eb.72af6380.webp",p=r.p+"static/image/4e7f52323e1092b7a81bc52ec34caac3.5ef388b8.webp",j=r.p+"static/image/a5531aa5ba1bfcc00e696cccc3c92064.15860557.webp";function x(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",img:"img",strong:"strong"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"28如何用-performance-工具分析并优化性能",children:["28.如何用 Performance 工具分析并优化性能",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#28如何用-performance-工具分析并优化性能",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Chrome DevTools 的 Performance 工具是性能分析和优化的利器，因为它可以记录每一段代码的耗时，进而分析出性能瓶颈，然后做针对性的优化。"}),"\n",(0,s.jsx)(n.p,{children:"这么强大的工具肯定是要好好掌握的，今天我们就来做一个性能优化的案例来快速上手 Performance 吧。"}),"\n",(0,s.jsxs)(n.h2,{id:"性能分析",children:["性能分析",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能分析",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"首先，我们准备这样一段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>worker performance optimization</title>\n</head>\n<body>\n    <script>\n        function a() {\n           b();\n        }\n        function b() {\n            let total = 0;\n            for(let i = 0; i< 10*10000*10000; i++) {\n                total += i;\n            }\n            console.log('b:', total);\n        }\n\n        a();\n    <\/script>\n    <script>\n        function c() {\n            d();\n        }\n        function d() {\n            let total = 0;\n            for(let i = 0; i< 1*10000*10000; i++) {\n                total += i;\n            }\n            console.log('c:', total);\n        }\n        c();\n    <\/script>\n</body>\n</html>\n"})}),"\n",(0,s.jsx)(n.p,{children:"很明显，两个 script 标签是两个宏任务，第一个宏任务的调用栈是 a、b，第二个宏任务的调用栈是 c、d。"}),"\n",(0,s.jsx)(n.p,{children:"我们用 Performance 来看一下是不是这样："}),"\n",(0,s.jsx)(n.p,{children:"首先用无痕模式打开 chrome，无痕模式下没有插件，分析性能不会受插件影响。"}),"\n",(0,s.jsx)(n.p,{children:"打开 chrome devtools 的 Performance 面板，点击 reload 按钮，会重新加载页面并开始记录耗时："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"过几秒点击结束。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这时候界面就会展示出记录的信息："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"图中标出的 Main 就是主线程。其余的 Frames、Network 等是浏览器的其他线程。"}),"\n",(0,s.jsx)(n.p,{children:"主线程是不断执行 Event Loop 的，可以看到有两个 Task（宏任务），调用栈分别是 a、b 和 c、d，和我们分析的对上了。（当然，还有一些浏览器内部的函数，比如 parseHtml、evaluateScript 等，这些可以忽略）"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Performance 工具最重要的是分析主线程的 Event Loop，分析每个 Task 的耗时、调用栈等信息。"})}),"\n",(0,s.jsx)(n.p,{children:"当你点击某个宏任务的时候，在下面的面板会显示调用栈的详情（选择 bottom-up 是列表展示， call tree 是树形展示）"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"每个函数的耗时也都显示在左侧，右侧有源码地址，点击就可以跳到 Sources 对应的代码。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"直接展示了每行代码的耗时，太方便了！"}),"\n",(0,s.jsx)(n.p,{children:"工具介绍完了，我们来分析下代码哪里有性能问题。"}),"\n",(0,s.jsx)(n.p,{children:"很明显， b 和 d 两个函数的循环累加耗时太高了。"}),"\n",(0,s.jsx)(n.p,{children:"在 Performance 中也可以看到 Task 被标红了，下面的 summary 面板也显示了 long task 的警告。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"有同学可能会问：为什么要优化 long task 呢？"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"因为渲染和 JS 执行都在主线程，在一个 Event Loop 中，会相互阻塞，如果 JS 有长时间执行的 Task，就会阻塞渲染，导致页面卡顿。所以，性能分析主要的目的是找到 long task，之后消除它。"})}),"\n",(0,s.jsx)(n.p,{children:"找到了要优化的代码，也知道了优化的目标（消除 long task），那么就开始优化吧。"}),"\n",(0,s.jsxs)(n.h2,{id:"性能优化",children:["性能优化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能优化",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"我们优化的目标是把两个 long task 中的耗时逻辑（循环累加）给去掉或者拆分成多个 task。"}),"\n",(0,s.jsx)(n.p,{children:"关于拆分 task 这点，可以参考 React 从递归渲染 vdom 转为链表的可打断的渲染 vdom 的优化，也就是 fiber 的架构，它的目的也是为了拆分 long task。"}),"\n",(0,s.jsx)(n.p,{children:"但明显我们这里的逻辑没啥好拆分的，它就是一个大循环。"}),"\n",(0,s.jsx)(n.p,{children:"那么能不能不放在主线程跑，放到其他线程跑呢？浏览器的 web worker 好像就是做耗时计算的性能优化的。"}),"\n",(0,s.jsx)(n.p,{children:"我们来试一下："}),"\n",(0,s.jsx)(n.p,{children:"封装这样一个函数，传入 url 和数字，函数会创建一个 worker 线程，通过 postMessage 传递 num 过去，并且监听 message 事件来接收返回的数据。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function runWorker(url, num) {\n    return new Promise((resolve, reject) => {\n        const worker = new Worker(url);\n        worker.postMessage(num);\n        worker.addEventListener('message', function (evt) {\n            resolve(evt.data);\n        });\n        worker.onerror = reject;\n    });\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后 b 和 c 函数就可以改成这样了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function b() {\n    runWorker('./worker.js', 10*10000*10000).then(res => {\n        console.log('b:', res);\n    });\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"耗时逻辑移到了 worker 线程："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"addEventListener('message', function(evt) {\n    let total = 0;\n    let num = evt.data;\n    for(let i = 0; i< num; i++) {\n        total += i;\n    }\n    postMessage(total);\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"完美。我们再跑一下试试："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"哇，long task 一个都没有了！"}),"\n",(0,s.jsx)(n.p,{children:"然后你还会发现 Main 线程下面多了两个 Worker 线程："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"虽然 Worker 还有 long task，但是不重要，毕竟计算量在那，只要主线程没有 long task 就行。"}),"\n",(0,s.jsx)(n.p,{children:"这样，我们通过把计算量拆分到 worker 线程，充分利用了多核 cpu 的能力，解决了主线程的 long task 问题，界面交互会很流畅。"}),"\n",(0,s.jsx)(n.p,{children:"我们再看下 Sources 面板："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"对比下之前的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这优化力度，肉眼可见！"}),"\n",(0,s.jsx)(n.p,{children:"就这样，我们一起完成了一次网页的性能优化，通过 Peformance 分析出 long task，定位到耗时代码，然后通过 worker 拆分计算量进行优化，成功消除了主线程的 long task。"}),"\n",(0,s.jsxs)(n.p,{children:["代码在",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/fe-debug-exercize/",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"里。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"Chrome DevTools 的 Performance 工具是网页性能分析的利器，它可以记录一段时间内的代码执行情况，比如 Main 线程的 Event Loop、每个 Event loop 的 Task，每个 Task 的调用栈，每个函数的耗时等，还可以定位到 Sources 中的源码位置。"}),"\n",(0,s.jsx)(n.p,{children:"性能优化的目标就是找到 Task 中的 long task，然后消除它。因为网页的渲染是一个宏任务，和 JS 的宏任务在同一个 Event Loop 中，是相互阻塞的。"}),"\n",(0,s.jsx)(n.p,{children:"我们做了一个真实的优化案例，通过 Performance 分析出了代码中的耗时部分，发现是计算量大导致的，所以我们把计算逻辑拆分到了 worker 线程以充分利用多核 cpu 的并行处理能力，消除了主线程的 long task。"}),"\n",(0,s.jsx)(n.p,{children:"做完这个性能优化的案例之后，是不是觉得 Peformance 工具用起来也不难呢？"}),"\n",(0,s.jsx)(n.p,{children:"其实会分析主线程的 Event Loop，会分析 Task 和 Task 的调用栈，找出 long task，并能定位到耗时的代码，Performance 工具就算是掌握了大部分了，常用的功能也就是这些。"})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}let g=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F28.%E5%A6%82%E4%BD%95%E7%94%A8%20Performance%20%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90%E5%B9%B6%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD.md"]={toc:[{text:"性能分析",id:"性能分析",depth:2},{text:"性能优化",id:"性能优化",depth:2},{text:"总结",id:"总结",depth:2}],title:"28.如何用 Performance 工具分析并优化性能",headingTitle:"28.如何用 Performance 工具分析并优化性能",frontmatter:{}}}}]);