"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["80106"],{516734:function(e,n,i){i.r(n),i.d(n,{default:()=>U});var t=i(552676),a=i(740453);let s=i.p+"static/image/e95f56ac0b60dd564d657b138474f887.65694955.webp",r=i.p+"static/image/607269b171a4054203e8a7ca2d582b91.969172a5.webp",c=i.p+"static/image/162b89658ce55a22b258869d4c59b552.8bebe7d7.webp",d=i.p+"static/image/4010a3ad3a2b78096a824cece7a1a38c.1c0e2d10.webp",p=i.p+"static/image/f15f21f213b30164cfb243d02713ff80.f6d9ac85.webp",l=i.p+"static/image/0a31d2102752c507af2e0b316f5ec1c0.29b92a12.webp",h=i.p+"static/image/766bec11a41be691d0e63d630ec14636.134cdf1e.webp",j=i.p+"static/image/5f4e4c9a2a4a3c75b602d9d4ac092979.2a4542e4.webp",x=i.p+"static/image/1cead031def5f0be7304b91c01adde75.49340de2.webp",o=i.p+"static/image/afec0a6c609beb970b269e6ebd0053e4.d7bf26aa.webp",m=i.p+"static/image/22175a86e1f1807fa7a48fd2360720d2.864c2cb8.webp",y=i.p+"static/image/f6acb1102baa65763122eef550849466.bff853f3.webp",g=i.p+"static/image/f6a264fa3e785fa4f9dd36a90e600d60.8f7ae969.webp",b=i.p+"static/image/890e84504c3efd1e83316399b1e1a9f8.5b65df57.webp",f=i.p+"static/image/39c5725e14f28c7144e83da48d90d1ac.dba5b84e.webp",u=i.p+"static/image/924b043709cf189d10b6367ed92697e6.dc3d985a.webp",w=i.p+"static/image/9940992181ecbe567915b5fa6f85a567.959bd813.webp",C=i.p+"static/image/cdee408404e5f83cb3eb4953fe71dd01.8de0ce0a.webp",T=i.p+"static/image/b96d1799925d291027101cf99111c72e.116438ee.webp",M=i.p+"static/image/89c565dda29a17b87d59bd7a4aaf2bad.ab7ba21d.webp",A=i.p+"static/image/bf2dc5c77d619663121f116e626b405e.b0714a61.webp",E=i.p+"static/image/0ec3c902b25e723d8562d6160e1e4cda.84073c03.webp",v=i.p+"static/image/c746f7c9eefd64ef510365083dd8837d.12648b54.webp",R=i.p+"static/image/ce6bee4f10818ca6cab398643f3c05a1.9de82e2d.webp",D=i.p+"static/image/f17a337e719f2c1896aa83b6a354b291.6ae4b879.webp",O=i.p+"static/image/25b17160363e52a9760170351f85ef04.c29f23fa.webp",_=i.p+"static/image/fd36f4901119359b6e8ba92e315b8374.169c1465.webp",B=i.p+"static/image/85308868f5c12d12ffe99486f5b86bd7.f52eec71.webp",N=i.p+"static/image/55c99466b8bf943354e103fa6a0aed8a.2891dcf0.webp",P=i.p+"static/image/23e9b12b5704dc99c721a2de52fb9c7e.98bdc681.webp",k=i.p+"static/image/131537d21c0c23d8a6962f649f5d67d0.65fd4f26.webp",S=i.p+"static/image/937090147bd6c786d16c48c4994c339f.24d5a948.webp",q=i.p+"static/image/586546405b0507c853b39577eeb28339.0db97884.webp",z=i.p+"static/image/3baa32eed9f783eb45c80ce52bd57c34.d5e48695.webp",F=i.p+"static/image/d88c0392eab4b53ba31284108f714978.2460d8c3.webp";function G(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,a.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"59-typeorm-如何保存任意层级的关系",children:["59. TypeORM 如何保存任意层级的关系？",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#59-typeorm-如何保存任意层级的关系",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"我们经常会见到一些多级分类的场景："}),"\n",(0,t.jsx)(n.p,{children:"比如京东的商品分类："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:F,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"新闻网站的新闻分类："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:z,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这种多层级的数据怎么存储呢？"}),"\n",(0,t.jsx)(n.p,{children:"有同学会说，很简单啊，这不就是一对多么，二级分类就用两个表，三级分类就用三个表。"}),"\n",(0,t.jsx)(n.p,{children:"这样是可以，但是都是分类，表结构是一样的，分到多个表里是不是有点冗余。"}),"\n",(0,t.jsx)(n.p,{children:"更重要的是，如果层级关系经常调整呢？"}),"\n",(0,t.jsx)(n.p,{children:"比如有的时候会变成二级分类，有的时候会更多级分类呢？"}),"\n",(0,t.jsx)(n.p,{children:"这时候用普通的多表之间的一对多就不行了。"}),"\n",(0,t.jsx)(n.p,{children:"一般这种多级分类的业务，我们都会在一个表里存储，然后通过 parentId 进行子关联来实现。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:q,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"在 TypeORM 里也对这种场景做了支持。"}),"\n",(0,t.jsx)(n.p,{children:"我们新建个项目："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"nest new typeorm-tree-entity-test\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:S,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"进入项目目录，创建一个 CRUD 模块："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"nest g resource city --no-spec\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:k,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"然后安装 TypeORM 的包："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install --save @nestjs/typeorm typeorm mysql2\n"})}),"\n",(0,t.jsx)(n.p,{children:"在 app.module.ts 引入下 TypeOrmModule："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { CityModule } from './city/city.module';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\n@Module({\n  imports: [\n    CityModule,\n    TypeOrmModule.forRoot({\n      type: \"mysql\",\n      host: \"localhost\",\n      port: 3306,\n      username: \"root\",\n      password: \"guang\",\n      database: \"tree_test\",\n      synchronize: true,\n      logging: true,\n      entities: [City],\n      poolSize: 10,\n      connectorPackage: 'mysql2',\n      extra: {\n          authPlugin: 'sha256_password',\n      }\n    })\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n"})}),"\n",(0,t.jsx)(n.p,{children:"在 mysql workbench 里创建这个 database："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:P,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"指定字符集为 utf8mb4，点击 apply。"}),"\n",(0,t.jsx)(n.p,{children:"然后改下 city.entity.ts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, Tree, TreeChildren, TreeParent, UpdateDateColumn } from \"typeorm\";\n\n@Entity()\n@Tree('closure-table')\nexport class City {\n    @PrimaryGeneratedColumn()\n    id: number;\n\n    @Column({ default: 0 })\n    status: number;\n\n    @CreateDateColumn()\n    createDate: Date;\n\n    @UpdateDateColumn()\n    updateDate: Date;\n    \n    @Column()\n    name: string;\n\n    @TreeChildren()\n    children: City[];\n\n    @TreeParent()\n    parent: City;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"把服务跑起来："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"npm run start:dev\n"})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，自动创建了 2 个表："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:N,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们在 mysql workbench 里看下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:B,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:_,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到 parentId 引用了自身的 id。"}),"\n",(0,t.jsx)(n.p,{children:"并且还有个 city_closure 表："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:O,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:D,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:R,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"两个外键都引用了 city 表的 id。"}),"\n",(0,t.jsx)(n.p,{children:"先不着急解释为什么是这样的，我们插入一些数据试试："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:v,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"在 CityService 的 findAll 方法里插入数据，然后再查出来。"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"@InjectEntityManager()\nentityManager: EntityManager;\n\nasync findAll() {\n    const city = new City();\n    city.name = '华北';\n    await this.entityManager.save(city);\n\n    const cityChild = new City()\n    cityChild.name = '山东'\n    const parent = await this.entityManager.findOne(City, {\n      where: {\n        name: '华北'\n      }\n    });\n    if(parent){\n      cityChild.parent = parent\n    }\n    await this.entityManager.save(City, cityChild)\n\n    return this.entityManager.getTreeRepository(City).findTrees();\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"这里创建了两个 city 的 entity，第二个的 parent 指定为第一个。"}),"\n",(0,t.jsx)(n.p,{children:"用 save 保存。"}),"\n",(0,t.jsx)(n.p,{children:"然后再 getTreeRepository 调用 findTrees 把数据查出来。"}),"\n",(0,t.jsx)(n.p,{children:"浏览器访问下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:E,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到数据插入成功了，并且返回了树形结构的结果。"}),"\n",(0,t.jsx)(n.p,{children:"在 mysql workbench 里看下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:A,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"在 city 表里保存着 city 记录之间的父子关系，通过 parentId 关联。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:M,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"在 city_closure 表里记录了也记录了父子关系。"}),"\n",(0,t.jsx)(n.p,{children:"把插入数据的代码注释掉："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:T,alt:"image.png"})}),"\n",(0,t.jsx)(n.p,{children:"重新插入数据："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async findAll() {\n    const city = new City();\n    city.name = '华南';\n    await this.entityManager.save(city);\n\n    const cityChild1 = new City()\n    cityChild1.name = '云南'\n    const parent = await this.entityManager.findOne(City, {\n      where: {\n        name: '华南'\n      }\n    });\n    if(parent){\n      cityChild1.parent = parent\n    }\n    await this.entityManager.save(City, cityChild1)\n\n    const cityChild2 = new City()\n    cityChild2.name = '昆明'\n\n    const parent2 = await this.entityManager.findOne(City, {\n      where: {\n        name: '云南'\n      }\n    });\n    if(parent){\n      cityChild2.parent = parent2\n    }\n    await this.entityManager.save(City, cityChild2)\n\nreturn this.entityManager.getTreeRepository(City).findTrees();\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"跑一下："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:C,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，二层和三层的关系都可以正常的存储和查询。"}),"\n",(0,t.jsx)(n.p,{children:"把插入数据的代码注释掉，我们测试下其他方法："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:w,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"findRoots 查询的是所有根节点："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async findAll() {\n    return this.entityManager.getTreeRepository(City).findRoots()\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:u,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async findAll() {\n    const parent = await this.entityManager.findOne(City, {\n      where: {\n        name: '云南'\n      }\n    });\n    return this.entityManager.getTreeRepository(City).findDescendantsTree(parent)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"findDescendantsTree 是查询某个节点的所有后代节点。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:f,alt:""})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async findAll() {\n    const parent = await this.entityManager.findOne(City, {\n      where: {\n        name: '云南'\n      }\n    });\n    return this.entityManager.getTreeRepository(City).findAncestorsTree(parent)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"findAncestorsTree 是查询某个节点的所有祖先节点。"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:b,alt:""})}),"\n",(0,t.jsxs)(n.p,{children:["这里换成 findAncestors、findDescendants 就是用扁平结构返回：\n",(0,t.jsx)("img",{src:g,alt:""})]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:y,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"把 findTrees 换成 find 也是会返回扁平的结构："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:m,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"还可以调用 countAncestors 和 countDescendants 来计数："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async findAll() {\n    const parent = await this.entityManager.findOne(City, {\n      where: {\n        name: '云南'\n      }\n    });\n    return this.entityManager.getTreeRepository(City).countAncestors(parent)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:o,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"这些 api 都是很实用的。"}),"\n",(0,t.jsx)(n.p,{children:"回过头来，再看下 @Tree 的 entity："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:x,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"通过 @TreeChildren 声明的属性里存储着它的 children 节点，通过 @TreeParent 声明的属性里存储着它的 parent 节点。"}),"\n",(0,t.jsx)(n.p,{children:"并且这个 entity 要用 @Tree 声明。"}),"\n",(0,t.jsx)(n.p,{children:"参数可以指定 4 中存储模式："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:j,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"我们一般都是用 closure-table，或者 materialized-path。"}),"\n",(0,t.jsx)(n.p,{children:"其余两种有点问题："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:h,alt:""})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:l,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"把两个表删掉："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:p,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"改成 materialized-path 重新跑："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:d,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，现在只生成了一个表："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:c,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"只是这个表多了一个 mpath 字段。"}),"\n",(0,t.jsx)(n.p,{children:"我们添加点数据："}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async findAll() {\n    const city = new City();\n    city.name = '华北';\n    await this.entityManager.save(city);\n\n    const cityChild = new City()\n    cityChild.name = '山东'\n    const parent = await this.entityManager.findOne(City, {\n      where: {\n        name: '华北'\n      }\n    });\n    if(parent){\n      cityChild.parent = parent\n    }\n    await this.entityManager.save(City, cityChild)\n\n    return this.entityManager.getTreeRepository(City).findTrees();\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:r,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"可以看到，它通过 mpath 路径存储了当前节点的访问路径，从而实现了父子关系的记录："}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)("img",{src:s,alt:""})}),"\n",(0,t.jsx)(n.p,{children:"其实这些存储细节我们不用关心，不管是 closure-table 用两个表存储也好，或者 materialized-path 用一个表多加一个 mpath 字段存储也好，都能完成同样的功能。"}),"\n",(0,t.jsxs)(n.p,{children:["案例代码在",(0,t.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-tree-entity-test",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,t.jsxs)(n.h2,{id:"总结",children:["总结",(0,t.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsx)(n.p,{children:"这节我们基于 TyepORM 实现了任意层级的关系的存储。"}),"\n",(0,t.jsx)(n.p,{children:"在 entity 上使用 @Tree 标识，然后通过 @TreeParent 和 @TreeChildren 标识存储父子节点的属性。"}),"\n",(0,t.jsx)(n.p,{children:"之后可以用 getTreeRepository 的 find、findTrees、findRoots、findAncestorsTree、findAncestors、findDescendantsTree、findDescendants、countDescendants、countAncestors 等 api 来实现各种关系的查询。"}),"\n",(0,t.jsx)(n.p,{children:"存储方式可以指定 closure-table 或者 materialized-path，这两种方式一个用单表存储，一个用两个表，但实现的效果是一样的。"}),"\n",(0,t.jsx)(n.p,{children:"以后遇到任意层级的数据的存储，就是用 Tree Entity 吧。"})]})}function I(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(G,{...e})}):G(e)}let U=I;I.__RSPRESS_PAGE_META={},I.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F59.%20TypeORM%20%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E4%BB%BB%E6%84%8F%E5%B1%82%E7%BA%A7%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"59. TypeORM 如何保存任意层级的关系？",headingTitle:"59. TypeORM 如何保存任意层级的关系？",frontmatter:{}}}}]);