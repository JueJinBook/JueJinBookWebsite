"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["22970"],{62583:function(e,r,n){n.r(r),n.d(r,{default:()=>c});var l=n(552676),i=n(740453);function d(e){let r=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",code:"code",h3:"h3",pre:"pre",ul:"ul",li:"li",img:"img",h4:"h4"},(0,i.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(r.h1,{id:"30深入研究-----帧缓冲",children:["30.深入研究 --- 帧缓冲",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#30深入研究-----帧缓冲",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"在之前的章节中，我们已经接触过缓冲的概念了，比如顶点的坐标、颜色、法向量、纹理坐标等，今天我们学习一个新的缓冲概念：帧缓冲。"}),"\n",(0,l.jsxs)(r.h2,{id:"概念",children:["概念",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#概念",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"顾名思义，帧缓冲（Frame Buffer Object）也是一个缓冲对象，不同于之前的缓冲，它相当于一个存在于内存中的不可见画布，我们可以先将即将绘制的内容绘制到帧缓冲中，然后对其做一些处理，之后，再将其绘制到画布上，这种方式让我们能够针对场景进行后处理，实现一些场景特效。"}),"\n",(0,l.jsx)(r.p,{children:"在之前的绘制过程中，渲染操作也是有帧缓冲的，只不过使用的是系统默认的帧缓冲。"}),"\n",(0,l.jsxs)(r.p,{children:["显然，帧缓冲既然也是一块画布，那么它经常要和颜色打交道。因此，帧缓冲通常至少包含一个颜色缓冲区，除此之外，我们还需要一个图像载体，将图像绘制到载体上，载体分为两种，",(0,l.jsx)(r.code,{children:"纹理"}),"和",(0,l.jsx)(r.code,{children:"渲染缓冲对象"}),"。"]}),"\n",(0,l.jsx)(r.p,{children:"纹理的优势是，我们可以在着色器中使用这个纹理，然后对其像素做后期处理。"}),"\n",(0,l.jsx)(r.p,{children:"渲染缓冲对象不能在着色器中使用，但是它有纹理不支持的特性，最大优点就是渲染缓冲所包含的各种数据是已经优化过的。"}),"\n",(0,l.jsx)(r.p,{children:"简单来说，帧缓冲就像提供给我们一个渲染前的画板，我们先在该画板上画好要显示的图像，满意之后再将它输出到屏幕上。"}),"\n",(0,l.jsxs)(r.h2,{id:"实战",children:["实战",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#实战",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"我们将一幅图像用 2D 纹理渲染到自定义帧缓冲，同时将该自定义缓冲渲染到一个2D纹理，接下来再将帧缓冲对象绑定到默认帧缓冲，在默认帧缓冲上将上一步的纹理映射到一个立方体上，并在屏幕显示出来。"}),"\n",(0,l.jsxs)(r.h3,{id:"创建帧缓冲对象",children:["创建帧缓冲对象",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#创建帧缓冲对象",children:"#"})]}),"\n",(0,l.jsxs)(r.p,{children:["首先创建帧缓冲对象，然后将该对象设置为绑定到",(0,l.jsx)(r.code,{children:"帧缓冲绑定点"}),"。"]}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-javascript",children:"let frameBuffer = gl.createFrameBuffer();\ngl.bindFrameBuffer(gl.FRAMEBUFFER, frameBuffer);\n"})}),"\n",(0,l.jsxs)(r.h3,{id:"创建帧缓冲图像的写入纹理",children:["创建帧缓冲图像的写入纹理",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#创建帧缓冲图像的写入纹理",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"接下来，我们创建一个纹理对象，并设置帧缓冲向纹理写入数据时的参数，最后将帧缓冲和纹理进行关联。"}),"\n",(0,l.jsx)(r.p,{children:"创建帧缓冲纹理"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-javascript",children:"let frameTexture = gl.createTexture();\ngl.bindTexture(gl.TEXTURE_2D, frameTexture);\n"})}),"\n",(0,l.jsx)(r.p,{children:"设置帧缓冲向纹理写入数据时的参数："}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-javascript",children:"// 绑定到第一个颜色附加区。\nlet attachmentPoint = gl.COLOR_ATTACHMENT0;\n// 写入数据，注意初始化时应为 null。\nlet data = null;\n// 绑定帧缓冲纹理作为当前纹理操作对象。\ngl.bindTexture(gl.TEXTURE_2D, frameTexture);\n// 设置写入参数，256 代表纹理的宽和高。\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n// 设置放大或者缩小时的算法\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n// 设置超出边界时的算法\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n// 将纹理和帧缓冲绑定。\ngl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);\n"})}),"\n",(0,l.jsx)(r.p,{children:"做完这几步，当我们执行完drawArrays等渲染操作之后，帧缓冲中的数据就渲染到该纹理对象上了。"}),"\n",(0,l.jsxs)(r.h3,{id:"绘制帧缓冲",children:["绘制帧缓冲",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#绘制帧缓冲",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"接下来，我们创建一个专门向帧缓冲纹理进行绘制的方法，该方法将向自定义缓冲渲染两个立方体。"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-javascript",children:"function drawFrame(){\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.clearColor(1,1,0,1);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.viewport(0, 0, 256, 256);\n    ...绘制立方体，此处略。\n}\n"})}),"\n",(0,l.jsx)(r.p,{children:"你会发现，我们的每一个操作步骤都是有目的的："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsx)(r.li,{children:"首先将自定义帧缓冲对象绑定到帧缓冲绑定点上。"}),"\n",(0,l.jsx)(r.li,{children:"之后设置清屏颜色，进行颜色和深度信息的清除处理，主要是为了和画布的绘制进行区分。"}),"\n",(0,l.jsx)(r.li,{children:"最后还需要重新设置绘图区域大小，这步也很关键，不然你会发现渲染到纹理上的图像和我们期待的不一样。"}),"\n"]}),"\n",(0,l.jsxs)(r.h3,{id:"绘制到画布",children:["绘制到画布",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#绘制到画布",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"我们在默认缓冲绘制一个立方体，立方体每个面使用的纹理采用自定义缓冲渲染到的纹理。"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-javascript",children:" gl.bindFramebuffer(gl.FRAMEBUFFER,null);\ngl.bindTexture(gl.TEXTURE_2D, frameTexture);\ngl.uniform1i(useTexture, true);\ngl.clearColor(1, 1, 0, 1); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        \ngl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        \ngl.uniform1i(u_Skybox, 0);\n...绘制立方体，此处略\n"})}),"\n",(0,l.jsx)(r.p,{children:"你会发现，我们的步骤和渲染到纹理步骤有所区别："}),"\n",(0,l.jsxs)(r.ul,{children:["\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"首先将帧缓冲绑定到默认缓冲上。"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"其次绑定纹理对象为帧缓冲纹理，因为我们要将自定义帧缓冲渲染到立方体的每一个面上。"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"接着设置常量useTexture 为true，设置它为true是时才使用纹理。"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"设置清屏颜色，并进行清屏。"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"重新设置绘图区域。"}),"\n"]}),"\n",(0,l.jsxs)(r.li,{children:["\n",(0,l.jsx)(r.p,{children:"将零号纹理传到着色器里。"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(r.h3,{id:"效果",children:["效果",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#效果",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:"data:image/webp;base64,UklGRmwEAABXRUJQVlA4IGAEAACwRQCdASoGAx8BPp1OpU2lpKOiIfCoELATiWdu4XYBCAKv5AcHpcb+HPDu9s/mEz8vZrF/9H7Av8/6qNvH5gP4B/RP2k94P8Zvc7vI/8U9SuyiAcflcxcYe46zK5i4w9x1mVzFxh7jrMrmLjD3HWZXMXGHuOsyuYuMPcdZlcxcYe46zK5i4w9x1mVzFxh7jrMrmLjD3HWZXMXGHt+TLhGjgF+nuwbsveF7V8wHEsnzNJFg20uMPcdZlcxcYe46zK5i4wPorgIerbTe/PcF1NQBVzFxh7jrMrmLjD1vR4tM7qWzYv3HWZXMXGHuOsyuYuMPcdLNi/cdZk3CNaq5i4w9x1mVzFxh7jrMrj7U66BkRgAuOKZFf1XF570GujxaZ3U1AFXMXGHuOsyuYuMD6PFlfJLd/zOVYRrVXMXGHuOsyuYuMPcdZlcfanXQuRz1v+utMv0dB2ZXMXGHuOsyuYuMPcdZlZh0HYTggRmpgNXa23r1vqYn2x9qddbaZ3U1AFXMXGHuOsyuYp2p12UPzEWAMrzFxh7jrMrmLjD3HWZXMW6AyvMXGHOor5GHuOsyuYuMPcdZlcxcYc6ivkYe41dHi0zupqAKuYuMPcdZlcxcYGJ8m6vCuClDZhzrTda4Q1TZPnWm65mtJCoermLjD3HWZXMXGHuOsyuYuNAJzWMg+Stp5XMXGHuOsyuYuMPcdZlcxcYe46zK5i4w9x1mVzFxh7jrMrmLjD3HWZXMXGHuOsyuYuMOYAD+/fHfuNMf5pPvbKE7Bsbw7MDCENmBhCGzAwhDZgYQhswMIQ2YGEIbMDCENmBhCGzAwhDZgYQhswMIQ2SIoAAAAJgoAAKIogrkiin1vnnQbk6cAE8/VFU1USoHDkukcWQlwQlxoJZvN05ytKDod8a5NhEqlT8uTXUy1XUEJJIN2Rfu89oas/qAVs5Pg0PmAvTCZrVrA2PqiiQObKJbWuoVbRJJ/Q1g8wL0wpMgIG6ESxR0qXquwPw5cXpvbIgIbRB51JudlWVQ53+07gl8JAjylPY1aI6E4N9JH89xhWgAr58fYMVkAr+4ykS8y7x9Zv2Za9Mkrs/PQmiQpAbrBe66+zE0cHJuaZdf+ko7wik6v+cX4KQ37TeBnrX7oRWaJ8iLyBemCmKOlS+VPZfjJDZSOg+u6OBhfmoaJYLyaI6UnZZYMrjhQgyjo4wS18DhN4qfySaEWuFO7i7WpLZ310aKthbclQki5zhNlCDKOlS9yU40A9/Y5UTHbL0yqLZEoZ+XNIJu1DJH284jyfut750/v/83C8Z4HPp9iQt6X4Y2KfOweEqZ6WI3B1bPJ2zrDfSMmPugwzsxoe8yOGiYlplmgDHMFMUdKl6vY4aJiWmWcWKEGUULTj+lQ5HY5o8QYbMrfVtKy8cA4m8F73GUlNWAnhDfTqkAJT5XmFps9IKg6sLcqd9Ys6Qxs1ELUS89AQU4QkXnBrb+UCiKAAAAAiCgAAoigAAAAAAA",alt:""})}),"\n",(0,l.jsx)(r.p,{children:"这就是最终渲染的效果，立方体的每个面上被自定义帧缓冲上的对象所填充。"}),"\n",(0,l.jsxs)(r.h3,{id:"加入深度缓冲",children:["加入深度缓冲",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#加入深度缓冲",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"上面的例子，我们只为帧缓冲附加了颜色缓冲信息，事实上，帧缓冲还可以附加深度缓冲、模板缓冲。接下来，我们为帧缓冲加入深度缓冲信息。\n我们用渲染缓冲对象保存深度缓冲信息，那么首先要创建渲染缓冲对象。"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-javascript",children:"// 创建一个深度缓冲\nconst renderBuffer = gl.createRenderbuffer();\ngl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);\n"})}),"\n",(0,l.jsx)(r.p,{children:"接下来，设置渲染缓冲对象的大小，这里和前面创建的纹理大小保持一致。"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-javascript",children:"// 设置深度缓冲的大小和帧缓冲纹理一致。\ngl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 256, 256);\n\n"})}),"\n",(0,l.jsx)(r.p,{children:"最后，将渲染缓冲对象和帧缓冲对象进行关联。"}),"\n",(0,l.jsx)(r.pre,{children:(0,l.jsx)(r.code,{className:"language-javascript",children:"gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderBuffer);\n"})}),"\n",(0,l.jsxs)(r.h4,{id:"效果-1",children:["效果",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#效果-1",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:(0,l.jsx)("img",{src:"data:image/webp;base64,UklGRnIEAABXRUJQVlA4IGYEAAAwRQCdASoGAx8BPp1OpU0lpKOiIjx4CLATiWdu4XZBArc2QPyA4O/qP7R+OnDH642Gv6LmT0sHsi2738v9AH6d/sz74XoA5272HfQA6afIewfGYxC431NQBXiFxvqagCvELjfU1AFeIXG+pqAK8QuN9TUAV4hcb6moArxC431NQBXiFxvqagCvELjfU1AFeIXG+pqAK8QuN9S0Z48wB/25iqB2EntRq2RHcPDsYd7O3jTkb6moArxC431NQBXiFxviixm6FfuGZFbxF0b6moArxC431NQBXiFxfKafU1ADvbxF0b6moArxC431NQBXiFxfKafU1ADvbxF0b6moArxC431NQBXiFxfKgKuKzOrzfaFRyIFfWVQOujfU1AFeIXG+pqAK8QuNxxqMAg/9cUh0ydlWy/u3iLo31NQBXiFxvqagCvELi+VATeUeqQF+YfGhgFAK8QuN9TUAV4hcb6moArweer2xy+VH/RfRFCmHbnayDz+b6moArxC431NQBXiFxvpvGoyutui+U0+pqAK8QuN9TUAV4hcb6mi2bYVeIW628N9TUAV4hcb6moArxC431LYDHXmMQpzz+b6moArxC431NQBXiFxvpsUsPipBuVM32iVrlqNCy6imI2YA/7cxiA8jglzGIXG+pqAK8QuN9TUAV4hcb9oo8aCZqArMvELjfU1AFeIXG+pqAK8QuN9TUAV4hcb6moArxC431NQBXiFxvqagCvELjfU1AFeIXF4AAP79zn/V4/qVRBt8Gvp+lcqCIAKqlgQAAAABH34ZIVFZbBd75RtrNiU/fxRKZcTxMCLy/rr0PH9YZlzYn6cXwC2SxCR012jS9Kr2cVO4AL6MZBCchd8gAJddYACtX83i6BoVI3B8ujSWIIES+Td+HCGQMEZQrmvSxioGj1HvgFhjplNdemAcJcZks4t+P7/4G5Ur6DQHD5v3q6LYCJXvDdbBtoEEE7CBW4AACCFi4AGQ+JTlCAERKpiUC0Yn3ystf7kei6XxGYV7/F//OvHO219rm8YeDlIwS3y4Shbn4ntrs9cfhm3UHRIEgjG5ANKQB3SuD97Olrv8R/zieWdT8iUv/4OPN+jX8YvpOA6m/G9u43w9wEeGQxqLmZKT7VhXLU5ZLi/7IgEVbjaiABrysn94bpZlrPkrAPo8bYbkw6dglGQtzl5N8fNgNDEg5TXwAhe7Ouoc2Hm1AzB+YTODJWf3T/hqjCxvcSMEsz3L2QAOKUWxbFP+niDFc96fSP6fFw5XsIiU4QAGrMQYL0JKBbJOoe4aEgTTosIu6KFUB1kudkEWDG94KgmMqsuoAVEoQACGlCASMoQBnWCfj5IffgePQcW34hJCQeJOE6lT7AEKtq8Vg7FkUdBPoPoocZ2vBpZbtVbVaCDjvB50wpnTKFIN2mrjmOf5IPl0YeRLtzVBSZZ3LE9lEyx2RGCzFgQlC9q56W4yLjT+zW4ixQr8dL0q/PrPn+UC7ugAAAAAAAAAAAAA",alt:""})}),"\n",(0,l.jsx)(r.p,{children:"可以看到，两个立方体的深度信息显现出来了。"}),"\n",(0,l.jsxs)(r.h2,{id:"应用",children:["应用",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#应用",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"那么，帧缓冲有什么好处呢？做了这个例子，大家心里也许已经有一些想法了。"}),"\n",(0,l.jsx)(r.p,{children:"在做一些赛车游戏时，如果玩家想从反光镜中看车后面的景色，这时候，帧缓冲就派上用场了。"}),"\n",(0,l.jsx)(r.p,{children:"再有，当我们需要对场景进行后期处理时，我们就可以 用帧缓冲渲染到纹理的方式，对纹理像素进行处理，实现某些特效，比如反向、模糊、黑白处理等。"}),"\n",(0,l.jsxs)(r.h2,{id:"回顾",children:["回顾",(0,l.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#回顾",children:"#"})]}),"\n",(0,l.jsx)(r.p,{children:"以上就是帧缓冲的内容，概念有些抽象，但是大家可以通过一些例子来感受它的存在。"}),"\n",(0,l.jsx)(r.p,{children:"至此，小册内容就结束了，下一节，我会对所学内容做一个总结。"})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.ah)(),e.components);return r?(0,l.jsx)(r,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}let c=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["WebGL%20%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%2F30.%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%20---%20%E5%B8%A7%E7%BC%93%E5%86%B2.md"]={toc:[{text:"概念",id:"概念",depth:2},{text:"实战",id:"实战",depth:2},{text:"创建帧缓冲对象",id:"创建帧缓冲对象",depth:3},{text:"创建帧缓冲图像的写入纹理",id:"创建帧缓冲图像的写入纹理",depth:3},{text:"绘制帧缓冲",id:"绘制帧缓冲",depth:3},{text:"绘制到画布",id:"绘制到画布",depth:3},{text:"效果",id:"效果",depth:3},{text:"加入深度缓冲",id:"加入深度缓冲",depth:3},{text:"效果",id:"效果-1",depth:4},{text:"应用",id:"应用",depth:2},{text:"回顾",id:"回顾",depth:2}],title:"30.深入研究 --- 帧缓冲",headingTitle:"30.深入研究 --- 帧缓冲",frontmatter:{}}}}]);