"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["84498"],{311214:function(e,n,r){r.r(n),r.d(n,{default:()=>i});var s=r(552676),c=r(740453);function d(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",ul:"ul",li:"li",h2:"h2",blockquote:"blockquote",h3:"h3",pre:"pre",code:"code"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"25-函数式思想在前端状态管理中的实践上react--redux-篇",children:["25 函数式思想在前端状态管理中的实践（上）：React & Redux 篇",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-函数式思想在前端状态管理中的实践上react--redux-篇",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["时下流行的前端状态管理解决方案有很多，这里我想和大家探讨的是几个最具代表性的",(0,s.jsx)(n.strong,{children:"函数式状态管理解法"}),"，它们分别是："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"React"})," 状态管理中的“不可变数据”"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Redux"})," 设计&实践中的函数式要素"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"纯函数"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"不可变值"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"高阶函数&柯里化"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"函数组合"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"RxJS"})," 对响应式编程与“盒子模式”的实践"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如何理解“响应式编程”"}),"\n",(0,s.jsx)(n.li,{children:"如何把副作用放进“盒子”"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"react-状态管理中的不可变数据",children:["React 状态管理中的“不可变数据”",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#react-状态管理中的不可变数据",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"众所周知，“不可变值/不可变数据”是 React 强烈推荐开发者遵循的一个原则。这个原则在 React 中被应用于 React 组件的状态（state）和属性（props），这些数据一旦被创建，就不能被修改，只能通过创建新的数据来实现更新。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["“不可变数据”的内涵我们在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175421412025303100",target:"_blank",rel:"noopener noreferrer",children:"第 6 节"}),"-",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422876495904827",target:"_blank",rel:"noopener noreferrer",children:"第 10 节"}),"已经有过非常深入的探讨，此处不再赘述。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"表象不可变数据确保-react-视图能够正常更新",children:["表象：“不可变数据”确保 React 视图能够正常更新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#表象不可变数据确保-react-视图能够正常更新",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 React 中，如果不遵循不可变数据的原则，可能会导致组件无法正常更新或出现一些不可预期的问题。下面是一个使用可变数据的 React 组件示例："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React, { useState } from 'react'\n\nfunction MutableComponent() {\n  const [items, setItems] = useState(['apple', 'banana', 'orange'])\n\n  const handleRemove = (index) => {\n    // 直接修改了原数组，违背了不可变原则\n    items.splice(index, 1) \n    setItems(items)\n  }\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n      <li key={index}>\n        {item}\n        <button onClick={() => handleRemove(index)}>remove</button>\n      </li>\n    ))}\n    </ul>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在这段代码中，",(0,s.jsx)(n.code,{children:"handleRemove"})," 函数直接修改了原始数组 ",(0,s.jsx)(n.code,{children:"items"}),"，然后又针对这个原始数组进行了一次新的",(0,s.jsx)(n.code,{children:"setState"}),"操作（代码中对应 ",(0,s.jsx)(n.code,{children:"setItems"}),"函数）。这就违背了不可变数据的原则——在不可变原则下，React 预期我们针对新的状态创建一个全新的数组，以此来确保新老数据的不可变性。"]}),"\n",(0,s.jsx)(n.p,{children:"这段实践了“可变数据”的代码会导致组件无法正常更新——我们的初衷是通过点击 remove 按钮来实现列表项的删除，但楼上这段代码呈现出的效果则是：无论我们点击多少次 remove 按钮，整个列表都不会发生任何的改变。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"为了避免这类问题出现，我们应该始终使用不可变数据。"})}),"\n",(0,s.jsxs)(n.p,{children:["实现不可变数据的思路有很多，对于这个例子来说，最直接的一个思路就是在执行 ",(0,s.jsx)(n.code,{children:"Array.prototype.splice()"}),"方法之前，先对原始数组做一次拷贝，如代码所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React, { useState } from 'react'\n\nfunction ImmutableComponent() {\n  const [items, setItems] = useState(['apple', 'banana', 'cherry'])\n\n  const handleRemove = (index) => {\n    // 基于原始数组，创建一个新数组\n    const newItems = [...items]  \n    newItems.splice(index, 1) \n    setItems(newItems)\n  }\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index}>\n          {item}\n          <button onClick={() => handleRemove(index)}>remove</button>\n        </li>\n      ))}\n    </ul>\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在上面的代码中，",(0,s.jsx)(n.code,{children:"handleRemove"})," 函数基于不可变数据的原则，创建了一个新的数组 ",(0,s.jsx)(n.code,{children:"newItems"}),"，确保了新老状态的不可变性。",(0,s.jsx)(n.strong,{children:"在"}),(0,s.jsx)(n.code,{children:"setState"}),(0,s.jsx)(n.strong,{children:"前后，新老状态相互独立、各有各的引用，这就是 React 所期待的“状态不可变”"})," 。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注：除了会导致视图更新失败之外，不遵循不可变数据原则还可能导致一些性能问题——因为 React 的性能优化依赖于对数据的比较，如果使用可变数据，React 就需要对每个可变数据进行深度比较，这样会消耗更多的时间和内存。因此，在",(0,s.jsx)(n.a,{href:"https://zh-hans.reactjs.org/docs/optimizing-performance.html#the-power-of-not-mutating-data",target:"_blank",rel:"noopener noreferrer",children:" React 官方的性能优化建议"}),"中，也给不可变数据记下了浓墨重彩的一笔。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["表象咱们看到了，那深层的原因又是什么呢？具体来说，",(0,s.jsx)(n.strong,{children:"为什么 React 就认准了不可变数据不撒手呢"}),"？"]}),"\n",(0,s.jsxs)(n.h3,{id:"内核数据-视图间高度确定的函数式映射关系",children:["内核：“数据-视图”间高度确定的函数式映射关系",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内核数据-视图间高度确定的函数式映射关系",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["通过",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175423125817917495",target:"_blank",rel:"noopener noreferrer",children:"第 23 节"}),"的学习，我们已经知道，",(0,s.jsx)(n.strong,{children:"React 组件是一个吃进数据、吐出 UI 的【纯函数】。"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"纯函数"}),"意味着",(0,s.jsx)(n.strong,{children:"确定性"}),"，意味着严格的一对一映射关系，意味着",(0,s.jsx)(n.strong,{children:"对于相同的数据输入，必须有相同的视图输出"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["在这个映射关系的支撑下，对于同一个函数（React 组件）、同一套入参（React 状态）来说，组件所计算出的视图内容必定是一致的。也就是说，",(0,s.jsx)(n.strong,{children:"在数据没有发生变化的情况下，React 是有权不去做【重计算】的"}),"。这也是我们可以借助",(0,s.jsx)(n.code,{children:"Pure Component"})," 和 ",(0,s.jsx)(n.code,{children:"React.memo()"})," 等技术缓存 React 组件的根本原因。"]}),"\n",(0,s.jsxs)(n.p,{children:["React 之所以以“不可变数据”作为状态更新的核心原则，根源就在于它的",(0,s.jsx)(n.strong,{children:"函数式内核"}),"，在于它追求的是",(0,s.jsx)(n.strong,{children:"数据（输入）和视图（输出）之间的高度确定的映射关系"}),"——如果数据可变（注意，“可变”指的是引用不变，但数据内容变了），就会导致数据和 UI 之间的映射关系不确定，从而使得 React 无法确定“有没有必要进行重计算”，最终导致渲染层面的异常。"]}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，",(0,s.jsx)(n.strong,{children:"React 组件的纯函数特性和不可变数据原则是相互支持、相互依赖的"}),"，它们的本质目的都是为了确保 React 的渲染过程高度确定、高度可预测，从而提高应用的性能和可维护性。"]}),"\n",(0,s.jsxs)(n.h2,{id:"redux",children:["Redux",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#redux",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["和 React 一样，Redux 在前端社区中也扮演了一个推广函数式编程的重要角色。从设计、实现到实践原则，Redux 由内而外地堆满了函数式编程的各种 buff，接下来我们要探讨的就是其中最核心的 5 个 buff：",(0,s.jsx)(n.strong,{children:"纯函数、不可变数据、高阶函数、柯里化和函数组合"}),"。"]}),"\n",(0,s.jsxs)(n.h3,{id:"纯函数",children:["纯函数",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#纯函数",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["在 Redux 中，所有的状态变化都是由纯函数（称为 ",(0,s.jsx)(n.code,{children:"reducer"}),"）来处理的，这些函数接收当前的状态（",(0,s.jsx)(n.code,{children:"state"}),"）和一个 ",(0,s.jsx)(n.code,{children:"action"})," 对象，返回一个新的状态。"]}),"\n",(0,s.jsx)(n.p,{children:"下面是一个简单的示例，展示了 Redux 如何使用纯函数来更新状态："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// 定义初始状态\nconst initialState = {\n  count: 0,\n};\n\n// 定义 reducer 函数，接收当前状态和动作对象，返回新状态\nfunction counterReducer(state = initialState, action) {\n  switch (action.type) {\n    case "increment":\n      return { ...state, count: state.count + 1 }\n    case "decrement":\n      return { ...state, count: state.count - 1 }\n    default:\n      return state;\n  }\n}\n\n// 创建 store，将 reducer 函数传入\nconst store = Redux.createStore(counterReducer)\n\n\n// 分发动作对象，触发状态变化\nstore.dispatch({ type: "increment" })\nstore.dispatch({ type: "decrement" })\n'})}),"\n",(0,s.jsxs)(n.p,{children:["在上面的示例中，",(0,s.jsx)(n.code,{children:"counterReducer"})," 函数就是一个 ",(0,s.jsx)(n.code,{children:"reducer"}),"，它接收当前 ",(0,s.jsx)(n.code,{children:"state"}),"和一个 ",(0,s.jsx)(n.code,{children:"action"}),"对象作为入参，返回一个新的 ",(0,s.jsx)(n.code,{children:"state"}),"作为计算结果——Redux 的设计原则要求整个",(0,s.jsx)(n.code,{children:"reducer"}),"的函数体",(0,s.jsx)(n.strong,{children:"除了计算、啥也不干"}),"，因此 ",(0,s.jsx)(n.code,{children:"reducer"}),"是标准的纯函数。"]}),"\n",(0,s.jsxs)(n.p,{children:["由于纯函数要求我们保持外部数据的不可变性，这里我们在更新 ",(0,s.jsx)(n.code,{children:"count"})," 属性时，使用了扩展运算符来拷贝当前状态。这就又引出了我们喜闻乐见的“不可变数据”原则。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"注：由此可见，纯函数和不可变数据真的是一对好基友，它们总是相互支持、相互成就的。"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"不可变数据",children:["不可变数据",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#不可变数据",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["Redux 的不可变数据原则体现在它的 ",(0,s.jsx)(n.code,{children:"state"})," 数据结构上。"]}),"\n",(0,s.jsxs)(n.p,{children:["Redux 要求我们在修改 ",(0,s.jsx)(n.code,{children:"state"})," 时使用不可变数据——也就是创建一个新的 ",(0,s.jsx)(n.code,{children:"state"})," 对象，而不是在原有的 state 上进行修改。这一点在楼上的示例中已经充分体现，此处不多赘述。"]}),"\n",(0,s.jsxs)(n.h3,{id:"高阶函数柯里化",children:["高阶函数&柯里化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#高阶函数柯里化",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 Redux 中，高阶函数的应用非常广泛。在这里，我想重点展开来讲的是“Redux 中间件”这个东西，它不仅应用了高阶函数和柯里化的思想，同时和函数组合也有密不可分的关系。"}),"\n",(0,s.jsxs)(n.p,{children:["在 Redux 中，中间件是一个函数，它【",(0,s.jsx)(n.strong,{children:"嵌套地"}),"】接收三个入参：",(0,s.jsx)(n.code,{children:"store"}),"、",(0,s.jsx)(n.code,{children:"next"}),"和",(0,s.jsx)(n.code,{children:"action"}),"。其中，",(0,s.jsx)(n.code,{children:"store"}),"是 Redux 唯一的状态树，",(0,s.jsx)(n.code,{children:"next"}),"是一个函数，用于将当前 ",(0,s.jsx)(n.code,{children:"action"}),"传递给下一个中间件或者传递给 ",(0,s.jsx)(n.code,{children:"reducer"}),"，而 ",(0,s.jsx)(n.code,{children:"action"}),"则是当前需要处理的行为信息对象。"]}),"\n",(0,s.jsx)(n.p,{children:"下面我实现了一个简单的 Redux 中间件，用来在状态更新的前后输出两行 log："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const loggerMiddleware = (store) => (next) => (action) => {\n  console.log('dispatching the action:', action)\n  const result = next(action)\n  console.log('dispatched and new state is', store.getState())\n  return result\n}\n\nconst store = createStore(reducer, applyMiddleware(loggerMiddleware))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在这个例子中，我们定义了一个名为 ",(0,s.jsx)(n.code,{children:"loggerMiddleware"})," 的中间件。它接收一个",(0,s.jsx)(n.code,{children:"store"}),"对象，返回一个结果函数 A，A 函数接收一个 ",(0,s.jsx)(n.code,{children:"next"}),"函数，返回一个新的结果函数 B。这个结果函数 B 会接收一个 action 对象，最终执行完整个中间件逻辑，并返回执行结果。"]}),"\n",(0,s.jsxs)(n.p,{children:["通过观察 ",(0,s.jsx)(n.code,{children:"loggerMiddleware"}),"，我们注意到，它是 3 个相互嵌套的一元函数所构成的",(0,s.jsx)(n.strong,{children:"高阶函数"}),"，是一个被",(0,s.jsx)(n.strong,{children:"柯里化"}),"过的函数。"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注：柯里化是把 ",(0,s.jsx)(n.strong,{children:"1 个 n 元函数"}),"改造为 ",(0,s.jsx)(n.strong,{children:"n 个相互嵌套的一元函数"}),"的过程，它是高阶函数的一种应用，详见小册",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175423003319074876",target:"_blank",rel:"noopener noreferrer",children:" 15 节"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"通过柯里化，Redux 中间件可以将参数相同的多次调用转化为单次调用，提高了代码复用性和可维护性，也为“延迟执行”（即在当前上下文先传递部分参数，等到后面确实需要执行的时候再传递剩余参数）提供了可能性。"}),"\n",(0,s.jsxs)(n.h3,{id:"函数组合",children:["函数组合",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数组合",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"当我们需要组合多个中间件的能力时，就用上函数组合了。"}),"\n",(0,s.jsx)(n.p,{children:"以下是 Redux 中组合不同中间件的示例代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import { createStore, applyMiddleware, compose } from 'redux'\nimport thunk from 'redux-thunk'\nimport logger from 'redux-logger'\n\nconst middleware = [thunk, logger, errorReport]\n\nconst store = createStore(\n  reducer,\n  compose(\n    applyMiddleware(...middleware),\n    window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n  )\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["上述代码中，我们将",(0,s.jsx)(n.code,{children:"thunk"}),"、",(0,s.jsx)(n.code,{children:"logger"}),"和",(0,s.jsx)(n.code,{children:"errorReport"}),"这三个中间件函数通过 ",(0,s.jsx)(n.code,{children:"compose"})," 函数组合起来，并使用",(0,s.jsx)(n.code,{children:"applyMiddleware"}),"函数将这些中间件函数应用到Redux的",(0,s.jsx)(n.code,{children:"store"}),"中。"]}),"\n",(0,s.jsxs)(n.p,{children:["值得注意的是，这段代码中的 ",(0,s.jsx)(n.code,{children:"compose"}),"是从 ",(0,s.jsx)(n.code,{children:"redux"}),"内部引入的，也就是说，",(0,s.jsx)(n.code,{children:"redux"}),"没有借助外部的函数式编程库，而是自己写了一个 ",(0,s.jsx)(n.code,{children:"compose"}),"函数来用。这就让人很难不好奇它自有的这个 ",(0,s.jsx)(n.code,{children:"compose"}),"长啥样："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export default function compose(...funcs) {\n  // 对函数个数为0的情况特判\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n  // 对函数个数为1的情况特判\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  // 最后这行和我们 22 节实现的 pipe 是一样的\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我们来看最关键的一行，也就是最后一行，这行代码和我们 ",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175422922192846907",target:"_blank",rel:"noopener noreferrer",children:"第 14 节"})," 实现的版本不同，但和我们",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175423078837518396",target:"_blank",rel:"noopener noreferrer",children:"第 22 节"}),"实现的 ",(0,s.jsx)(n.code,{children:"pipe"}),"函数可是亲兄弟呀："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 第 22 节实现的 pipe 函数\nconst pipe  = (...funcs) => funcs.reduce(\n  // 和 14 节的 pipe 一样是基于 reduce 实现，主要的区别在于对组合链入参的处理不同\n  (f, g) => (...args) => g(f(...args))\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这种写法的 ",(0,s.jsx)(n.code,{children:"pipe/compose"})," 最大的特点在于对组合链入参的处理——",(0,s.jsx)(n.code,{children:"...args"}),"中扩展运算符的存在，使得这类 ",(0,s.jsx)(n.code,{children:"pipe/compose"}),"组合出的函数能够消化多个入参，像这样："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"pipe(\n  likeLessons,\n  registerLessons,\n  emptyUserLiked,\n  isVIP,\n  // 这两个参数都会被传递给组合链中的第一个函数\n)(user, myLessons)\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["注：楼上这段代码，在",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175423078837518396",target:"_blank",rel:"noopener noreferrer",children:" 22 节"})," 有完整的示例，跳读至此的同学可以狠狠",(0,s.jsx)(n.a,{href:"https://juejin.cn/book/7173591403639865377/section/7175423078837518396",target:"_blank",rel:"noopener noreferrer",children:"点这里"}),"补全阅读上下文。）"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"小结",children:["小结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本节我们通过分析大家相对熟悉的 React & Redux 技术点，对前面学过的纯函数、不可变数据、高阶函数、柯里化、函数组合等关键知识点进行了整合和串联。通过本节的学习，相信大家能够对已经学过的知识有更深刻的理解和认同。"}),"\n",(0,s.jsx)(n.p,{children:"其实，除了这些“典中典”的函数式编程特性在前端领域有广泛的实践以外，还有像“盒子模式”这样相对冷门的编程方法，它也是可以在生产级别的项目中大放异彩的。下一节，我们就将以 RxJS 为例，探讨盒子模式在前端状态管理中的实践。"})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let i=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["JavaScript%20%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F25%20%E5%87%BD%E6%95%B0%E5%BC%8F%E6%80%9D%E6%83%B3%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9AReact%20%26%20Redux%20%E7%AF%87.md"]={toc:[{text:"React 状态管理中的“不可变数据”",id:"react-状态管理中的不可变数据",depth:2},{text:"表象：“不可变数据”确保 React 视图能够正常更新",id:"表象不可变数据确保-react-视图能够正常更新",depth:3},{text:"内核：“数据-视图”间高度确定的函数式映射关系",id:"内核数据-视图间高度确定的函数式映射关系",depth:3},{text:"Redux",id:"redux",depth:2},{text:"纯函数",id:"纯函数",depth:3},{text:"不可变数据",id:"不可变数据",depth:3},{text:"高阶函数&柯里化",id:"高阶函数柯里化",depth:3},{text:"函数组合",id:"函数组合",depth:3},{text:"小结",id:"小结",depth:2}],title:"25 函数式思想在前端状态管理中的实践（上）：React & Redux 篇",headingTitle:"25 函数式思想在前端状态管理中的实践（上）：React & Redux 篇",frontmatter:{}}}}]);