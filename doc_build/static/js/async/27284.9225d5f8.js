"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["27284"],{902869:function(e,n,s){s.r(n),s.d(n,{default:()=>I});var r=s(552676),i=s(740453);let c=s.p+"static/image/5360b838979fd8d24597176b1c827952.23b8b6b5.webp",l=s.p+"static/image/030ea32cc5284278c444ee6aea127c9a.8050c84a.webp",d=s.p+"static/image/305fb1f7b68c42361014f501ce55c9f2.4040d04a.webp",a=s.p+"static/image/2a297de76a3481817d0eed44e56e23e4.4120d9c7.webp",t=s.p+"static/image/fd58826608140db11c0da98579e8b03b.96bb433d.webp",o=s.p+"static/image/52c56600e89154b5f2c7d409940e20cb.ad99f9c5.webp",p=s.p+"static/image/b26302cb85326b766a6028edabc7803c.b4e5c82c.webp",x=s.p+"static/image/d969f5f98881adf38932a2306104560f.67850807.webp",j=s.p+"static/image/4f11bcf4a2bfe72d2afd2bb5449b56b2.50b3d757.webp",b=s.p+"static/image/f0ffd1e699b617a8734caac97e42cfaa.36215122.webp",h=s.p+"static/image/adf24dcf8a6647cc499b2328584f5845.d4c442d8.webp",m=s.p+"static/image/bbcf847f907a17bb83346d2c38d5e239.3c58eced.webp",f=s.p+"static/image/32573b1d4b3ac37ed9eae00c436d0e78.8921bd08.webp",g=s.p+"static/image/25a0b481c8c4107fa7820a10311f99d5.1adf1573.webp",u=s.p+"static/image/3926fe111733b9a7bbf8b34be4d9e204.e9b12b79.webp",M=s.p+"static/image/757795fc62f530c8ba25570fb17a728c.dea14ebe.webp",w=s.p+"static/image/ed891103d4ad9d4f2e2d47ef4514ef6e.3220e863.webp",C=s.p+"static/image/e23bb62442e54d9e1f4b5b25b426a2e3.be6e813a.webp",E=s.p+"static/image/77df22d83ae99c8ea06bba4ccb3d5e50.2aaa6fa6.webp",O=s.p+"static/image/e313e2728fd11ea7a3868db7d74ac8b4.156b1f7b.webp",_=s.p+"static/image/a5ab1d4937cf62a2e5043961b834e892.c9cae286.webp",A=s.p+"static/image/0630582d01d1c7e22c8c1d1ccb7a6061.0c516308.webp",B=s.p+"static/image/6ab4460d83ca41537a15b4e26476b5e8.7617c6b3.webp",y=s.p+"static/image/79396dd8785759e8dfc67fe777c9a6a1.2469578e.webp",N=s.p+"static/image/ff6acad0d5d1c78677acf54ffd248eaa.cf2537d4.webp",v=s.p+"static/image/b1388deefb3a59ffd1a192dc40e0572a.db6cac0e.webp",R=s.p+"static/image/bc211eda0be0faccc4ecb68bb0500768.160f69c3.webp",F=s.p+"static/image/a1e01eba7de8a85a432fda0b00ebeaa6.3565917a.webp",S=s.p+"static/image/4eca202c63c672e3fb1b0e619a295b28.392674d4.webp",T=s.p+"static/image/74868c498027e1f654ef25c98c29cf65.50a52e6d.webp",D=s.p+"static/image/99fade18ce521f5b3feb70fdb7fa7b48.59743f90.webp",P=s.p+"static/image/8128db96fff8e628680eda77bc4f08f0.3e9382ca.webp";function k(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",ul:"ul",li:"li",h2:"h2"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"16-如何创建动态模块",children:["16. 如何创建动态模块",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#16-如何创建动态模块",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"前面讲过，Provider 是可以通过 useFactory 动态产生的，那 Module 可不可以呢？"}),"\n",(0,r.jsx)(n.p,{children:"自然是可以的，这节我们就来学下动态模块 Dynamic Module。"}),"\n",(0,r.jsx)(n.p,{children:"我们新建一个项目："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest new dynamic-module -p npm\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:P,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"执行"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g resource bbb\n"})}),"\n",(0,r.jsx)(n.p,{children:"创建一个实现了 CRUD 的模块："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:D,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"然后执行："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"npm run start:dev\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器访问下，可以看到 bbb 模块生效了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:T,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这个模块是静态的，也就是它的内容是固定不变的，每次 import 都是一样："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:S,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:F,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"有的时候我们希望 import 的时候给这个模块传一些参数，动态生成模块的内容，怎么办呢？"}),"\n",(0,r.jsx)(n.p,{children:"这时候就需要 Dynamic Module 了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { DynamicModule, Module } from '@nestjs/common';\nimport { BbbService } from './bbb.service';\nimport { BbbController } from './bbb.controller';\n\n@Module({})\nexport class BbbModule {\n\n  static register(options: Record<string, any>): DynamicModule {\n    return {\n      module: BbbModule,\n      controllers: [BbbController],\n      providers: [\n        {\n          provide: 'CONFIG_OPTIONS',\n          useValue: options,\n        },\n        BbbService,\n      ],\n      exports: []\n    };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"我们给 BbbModule 加一个 register 的静态方法，返回模块定义的对象。"}),"\n",(0,r.jsx)(n.p,{children:"和在装饰器里定义的时候的区别，只是多了一个 module 属性："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:R,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:v,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而且我们还可以把参数传入的 options 对象作为一个新的 provider。"}),"\n",(0,r.jsx)(n.p,{children:"import 的时候就得这样用了，通过 register 方法传入参数，返回值就是模块定义："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:N,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"改成这样之后，再跑一下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:y,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"依然是正常的。"}),"\n",(0,r.jsx)(n.p,{children:"而且这时候我们把传入的 options 通过 useValue 创建了个 provider，这样模块内部就可以注入它了。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:B,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"我在 BbbController 里面通过 token 注入这个 provider，打印下它的值。"}),"\n",(0,r.jsx)(n.p,{children:"改一下 register 的参数："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:A,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"浏览器再访问下，可以看到控制台打印了 config 对象："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:_,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样我们就可以在 import 一个模块的时候，传入参数，然后动态生成模块的内容。"}),"\n",(0,r.jsx)(n.p,{children:"这就是 Dynamic Module。"}),"\n",(0,r.jsx)(n.p,{children:"这里的 register 方法其实叫啥都行，但 nest 约定了 3 种方法名："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"register"}),"\n",(0,r.jsx)(n.li,{children:"forRoot"}),"\n",(0,r.jsx)(n.li,{children:"forFeature"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"我们约定它们分别用来做不同的事情："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"register：用一次模块传一次配置，比如这次调用是 BbbModule.register({aaa:1})，下一次就是 BbbModule.register({aaa:2}) 了"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"forRoot：配置一次模块用多次，比如 XxxModule.forRoot({}) 一次，之后就一直用这个 Module，一般在 AppModule 里 import"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"forFeature：用了 forRoot 固定了整体模块，用于局部的时候，可能需要再传一些配置，比如用 forRoot 指定了数据库链接信息，再用 forFeature 指定某个模块访问哪个数据库和表。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"光这么说可能不够直观，我们看一个真实的动态模块就懂了。"}),"\n",(0,r.jsx)(n.p,{children:"比如 @nestjs/typeorm 的动态模块："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:O,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"forRoot 传入配置，动态产生 provider 和 exports，返回模块定义。"}),"\n",(0,r.jsx)(n.p,{children:"而且还有 forRootAsync："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:E,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"区别就是可以用 async 的 useFactory 动态产生 provider，比如异步请求别的服务拿到配置返回，作为 options。"}),"\n",(0,r.jsx)(n.p,{children:"forFeature 则是传入局部的一些配置，来动态产生局部用的模块："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:C,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"typeorm 的模块用起来是这样的："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:w,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:M,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在 AppModule 里 import 通过 forRoot 动态产生的模块，在具体的业务 Module 里，通过 forFeature 传入具体实体类的配置。"}),"\n",(0,r.jsx)(n.p,{children:"其实 forRoot、forFeature、register 有区别么？"}),"\n",(0,r.jsx)(n.p,{children:"本质上没区别，只是我们约定了它们使用上的一些区别。"}),"\n",(0,r.jsx)(n.p,{children:"此外，Nest 还提供了另一种方式来创建动态模块："}),"\n",(0,r.jsx)(n.p,{children:"我们再生成一个新模块："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g module ccc\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后生成个 controller："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"nest g controller ccc --no-spec\n"})}),"\n",(0,r.jsx)(n.p,{children:"这次我们不手动写 register、registerAsync 等方法了，用 builder 来生成。"}),"\n",(0,r.jsx)(n.p,{children:"新建一个 ccc.module-definition.ts 文件："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'import { ConfigurableModuleBuilder } from "@nestjs/common";\n\nexport interface CccModuleOptions {\n    aaa: number;\n    bbb: string;\n}\n\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<CccModuleOptions>().build();\n'})}),"\n",(0,r.jsx)(n.p,{children:"用 ConfigurableModuleBuilder 生成一个 class，这个 class 里就带了 register、registerAsync 方法。"}),"\n",(0,r.jsx)(n.p,{children:"返回的 ConfigurableModuleClass、MODULE_OPTIONS_TOKEN 分别是生成的 class 、options 对象的 token。"}),"\n",(0,r.jsx)(n.p,{children:"然后 Module 继承它："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:u,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样这个 CccModule 就已经有了 register 和 registerAsync 方法了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:g,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"不用自己定义了，省事了不少。"}),"\n",(0,r.jsx)(n.p,{children:"传入 options："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:f,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"那现在如何在 Module 内注入这个 options 呢？"}),"\n",(0,r.jsx)(n.p,{children:"记得 build class 的时候返回了一个 token 么？"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:m,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"就用这个注入："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { Controller, Get, Inject } from '@nestjs/common';\nimport { MODULE_OPTIONS_TOKEN, CccModuleOptions } from './ccc.module-definition';\n\n@Controller('ccc')\nexport class CccController {\n\n    @Inject(MODULE_OPTIONS_TOKEN)\n    private options: CccModuleOptions;\n\n    @Get('')\n    hello() {\n        return this.options;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"浏览器访问下："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:b,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"可以看到拿到了 options 对象。"}),"\n",(0,r.jsx)(n.p,{children:"当然，options 对象不是这么用的，一般是用来做配置，内部的 provider 基于它来做一些设置，这里只是演示。"}),"\n",(0,r.jsx)(n.p,{children:"你还可以用 registerAsync 方法，用 useFactory 动态创建 options 对象："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"前面我们不是说还可以用 forRoot、forFeature 这样的方法么？"}),"\n",(0,r.jsx)(n.p,{children:"那用 builder 的方式如何生成这样的 class 呢？"}),"\n",(0,r.jsx)(n.p,{children:"调用 setClassMethodName 设置下就好了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:p,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"如果我还想根据传入的参数决定是否设置为全局模块呢？"}),"\n",(0,r.jsx)(n.p,{children:"那就要这样写了："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"import { ConfigurableModuleBuilder } from \"@nestjs/common\";\n\nexport interface CccModuleOptions {\n    aaa: number;\n    bbb: string;\n}\n\nexport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n  new ConfigurableModuleBuilder<CccModuleOptions>().setClassMethodName('register').setExtras({\n    isGlobal: true\n  }, (definition, extras) => ({\n    ...definition,\n    global: extras.isGlobal,\n  })).build();\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"setExtras 第一个参数是给 options 扩展啥 extras 属性，第二个参数是收到 extras 属性之后如何修改模块定义。"}),"\n",(0,r.jsx)(n.p,{children:"我们定义了 isGlobal 的 option，收到它之后给模块定义加上个 global。"}),"\n",(0,r.jsx)(n.p,{children:"这时候你就会发现 register 的 options 多了 isGlobal："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样创建的就是全局的模块。"}),"\n",(0,r.jsx)(n.p,{children:"不过这样还有个问题："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"options 那里多了 isGlobal 属性，但是类型定义这里还没有呀。"}),"\n",(0,r.jsx)(n.p,{children:"因为我们用的是这个类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"最好是用 builder 返回的类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这样就有了："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"而这个 ASYNC_OPTIONS_TYPE 是 async 方式创建模块的 otpion 类型："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"回过头来看一下这个 ConfigurableModuleBuilder，它只是对我们定义 register、registerAsync 的过程做了封装，传参数就可以生成对应的 class，简便了不少。"}),"\n",(0,r.jsx)(n.p,{children:"如果你觉得这种 builder 的方式更麻烦，那直接用第一种方式也可以。"}),"\n",(0,r.jsxs)(n.p,{children:["案例代码在",(0,r.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/dynamic-module",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Module 可以传入 options 动态产生，这叫做动态 Module，你还可以把传入的 options 作为 provider 注入到别的对象里。"}),"\n",(0,r.jsx)(n.p,{children:"建议的动态产生 Module 的方法名有 register、forRoot、forFeature 3种。"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"register：用一次注册一次"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"forRoot：只注册一次，用多次，一般在 AppModule 引入"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"forFeature：用了 forRoot 之后，用 forFeature 传入局部配置，一般在具体模块里 imports"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"并且这些方法都可以写 xxxAsync 版本，也就是传入 useFactory 等 option，内部注册异步 provider。"}),"\n",(0,r.jsx)(n.p,{children:"这个过程也可以用 ConfigurableModuleBuilder 来生成。通过 setClassMethodName 设置方法名，通过 setExtras 设置额外的 options 处理逻辑。"}),"\n",(0,r.jsx)(n.p,{children:"并且返回的 class 都有 xxxAsync 的版本。"}),"\n",(0,r.jsx)(n.p,{children:"这就是动态模块的定义方式，后面用到 typeorm、mongoose 等模块会大量见到这种模块。"})]})}function G(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(k,{...e})}):k(e)}let I=G;G.__RSPRESS_PAGE_META={},G.__RSPRESS_PAGE_META["Nest%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%20%20%E6%9C%80%E6%96%B0200%E7%AB%A0%2F16.%20%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"16. 如何创建动态模块",headingTitle:"16. 如何创建动态模块",frontmatter:{}}}}]);