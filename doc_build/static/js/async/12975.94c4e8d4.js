"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["12975"],{431686:function(n,e,s){s.r(e),s.d(e,{default:()=>a});var o=s(552676),r=s(740453);let i=s.p+"static/image/b826c7f0c0794d868381d87b97fd5fe7.79c6884e.webp";function l(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",ol:"ol",li:"li",strong:"strong",h3:"h3",img:"img"},(0,r.ah)(),n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.h1,{id:"16内置组件transition-是如何实现的",children:["16.内置组件：Transition 是如何实现的？",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#16内置组件transition-是如何实现的",children:"#"})]}),"\n",(0,o.jsxs)(e.h2,{id:"前言",children:["前言",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#前言",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:"Vue"})," 内置了 ",(0,o.jsx)(e.code,{children:"Trasition"})," 组件可以帮助我们快速简单的实现基于状态变换的动画效果。该组件支持了 ",(0,o.jsx)(e.code,{children:"CSS 过渡动画"}),"、",(0,o.jsx)(e.code,{children:"CSS 动画"}),"、",(0,o.jsx)(e.code,{children:"Javascript 钩子"})," 几种模式，接下来我们将逐步介绍这几种模式的实现原理。"]}),"\n",(0,o.jsxs)(e.h2,{id:"基于-css-的过渡效果",children:["基于 CSS 的过渡效果",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#基于-css-的过渡效果",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["我们先来看官网上一个简单的关于 ",(0,o.jsx)(e.code,{children:"CSS Transiton"})," 过渡动画的示例：\n以下是最基本用法的示例："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-html",children:'<template>\n  <button @click="show = !show">Toggle</button>\n  <Transition>\n    <p v-if="show">hello</p>\n  </Transition>\n</template>\n\n<style>\n  .v-enter-active,\n  .v-leave-active {\n    transition: opacity 0.5s ease;\n  }\n\n  .v-enter-from,\n  .v-leave-to {\n    opacity: 0;\n  }\n</style>\n'})}),"\n",(0,o.jsx)(e.p,{children:"然后再来看看官网上对于这些类名的实现定义："}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"v-enter-from"}),"：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"v-enter-active"}),"：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 ",(0,o.jsx)(e.code,{children:"class"})," 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"v-enter-to"}),"：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是\xa0",(0,o.jsx)(e.code,{children:"v-enter-from"}),"\xa0被移除的同时)，在过渡或动画完成之后移除。"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"v-leave-from"}),"：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"v-leave-active"}),"：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.code,{children:"v-leave-to"}),"：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是\xa0",(0,o.jsx)(e.code,{children:"v-leave-from"}),"\xa0被移除的同时)，在过渡或动画完成之后移除。"]}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["抛开源码不谈，如果在一个普通的 ",(0,o.jsx)(e.code,{children:"Vue"})," 组件中，我们如何实现一个上述功能的过渡状态的 ",(0,o.jsx)(e.code,{children:"CSS"})," 动画效果呢？按照官网上的定义，我们一起来尝试一下："]}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.a,{href:"https://code.juejin.cn/pen/7167177061931417630",target:"_blank",rel:"noopener noreferrer",children:"代码片段"})}),"\n",(0,o.jsxs)(e.p,{children:["可以看到，我们参考官网的描述，也可以简单的实现一个基于 ",(0,o.jsx)(e.code,{children:"css"})," 的过渡动画，但这里存在了几个问题："]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["硬编码了 ",(0,o.jsx)(e.code,{children:"transiton"})," 动画，没有实现 ",(0,o.jsx)(e.code,{children:"animate"})," 动画。"]}),"\n",(0,o.jsx)(e.li,{children:"不够抽象，难以复用到后续组件。"}),"\n"]}),"\n",(0,o.jsxs)(e.p,{children:["接下来我们一起来看看 ",(0,o.jsx)(e.code,{children:"Vue"})," 源码是如何实现的，首先找到关于 ",(0,o.jsx)(e.code,{children:"Transition"})," 组件的定义："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"export const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)\n\nTransition.displayName = 'Transition'\n"})}),"\n",(0,o.jsxs)(e.p,{children:["代码很简单，",(0,o.jsx)(e.code,{children:"Transition"})," 组件是一个函数式组件，本身就是一个渲染函数。还记得我们之前说过吗，",(0,o.jsx)(e.code,{children:"Vue"})," 组件分为了有状态组件和函数组件，有状态组件内部会存储组件的状态，而函数组件不会。"]}),"\n",(0,o.jsxs)(e.p,{children:["我们知道 ",(0,o.jsx)(e.code,{children:"Vue"})," 对 ",(0,o.jsx)(e.code,{children:"Transtion"})," 内置组件的功能定义就是只是一个",(0,o.jsx)(e.strong,{children:"容器"}),"，一个搬运工，需要渲染 ",(0,o.jsx)(e.code,{children:"DOM"}),"，那就不需要 ",(0,o.jsx)(e.code,{children:"template"}),"，本身不需要维护任何状态。所以这里直接通过一个函数式组件定义了 ",(0,o.jsx)(e.code,{children:"Transition"})," 组件。"]}),"\n",(0,o.jsxs)(e.p,{children:["接着，我们看到了该组件核心功能就是一个渲染 ",(0,o.jsx)(e.code,{children:"BaseTransition"})," 组件，并为期传入",(0,o.jsxs)(e.strong,{children:["处理好的 ",(0,o.jsx)(e.code,{children:"props"})]})," 和内部挂载的 ",(0,o.jsx)(e.code,{children:"slot"}),"。先来看看 ",(0,o.jsx)(e.code,{children:"BaseTransition"})," 组件，这里我们只关心与 ",(0,o.jsx)(e.code,{children:"CSS"})," 动画相关的逻辑。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"const BaseTransitionImpl = {\n  name: `BaseTransition`,\n\n  props: {\n    // ...\n  },\n\n  setup(props, { slots }) {\n    // 当前渲染的组价实例\n    const instance = getCurrentInstance()!\n    const state = useTransitionState()\n    return () => {\n      /**\n       * 这里都是进入状态需要定义的内容\n       */\n      // 获取子节点\n      const children =\n        slots.default && getTransitionRawChildren(slots.default(), true)\n      if (!children || !children.length) {\n        return\n      }\n\n      let child = children[0]\n      \n      // 这里 props 不需要响应式追踪，为了更好的性能，去除响应式\n      const rawProps = toRaw(props)\n      const { mode } = rawProps\n      \n      // 获取当前的容器节点\n      const innerChild = getKeepAliveChild(child)\n      if (!innerChild) {\n        return emptyPlaceholder(child)\n      }\n\n      // 获取进入状态的调用函数\n      const enterHooks = resolveTransitionHooks(\n        innerChild,\n        rawProps,\n        state,\n        instance\n      )\n      \n      // 为子节点添加进入 hooks 属性\n      setTransitionHooks(innerChild, enterHooks)\n  \n      /**\n       * 下面都是离开状态需要定义的内容\n       */\n      // 离开状态中，之前的节点就是旧节点了\n      const oldChild = instance.subTree\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild)\n\n      let transitionKeyChanged = false\n     \n      if (\n        oldInnerChild &&\n        oldInnerChild.type !== Comment &&\n        (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)\n      ) {\n        // 获取离开状态的调用函数\n        const leavingHooks = resolveTransitionHooks(\n          oldInnerChild,\n          rawProps,\n          state,\n          instance\n        )\n        // 为子节点添加离开 hooks 属性\n        setTransitionHooks(oldInnerChild, leavingHooks)\n        // out-in 模式状态切换\n        if (mode === 'out-in') {\n          state.isLeaving = true\n          // 返回空的占位符节点，当离开过渡结束后，重新渲染组件\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false\n            // 当 active = false 时，被卸载状态不需要更新\n            if (instance.update.active !== false) {\n              instance.update()\n            }\n            instance.update()\n          }\n          return emptyPlaceholder(child)\n        } else if (mode === 'in-out' && innerChild.type !== Comment) {\n          // in-out 模式状态切换，延迟移除\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            // 先缓存需要移除的节点\n            const leavingVNodesCache = getLeavingNodesForType(\n              state,\n              oldInnerChild\n            )\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild\n            el._leaveCb = () => {\n              earlyRemove()\n              el._leaveCb = undefined\n              delete enterHooks.delayedLeave\n            }\n            enterHooks.delayedLeave = delayedLeave\n          }\n        }\n      }\n      // 返回子节点\n      return child\n    }\n  }\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["可以看到 ",(0,o.jsx)(e.code,{children:"BaseTransitionImpl"})," 的 ",(0,o.jsx)(e.code,{children:"setup"})," 函数，核心就干了三件事儿："]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Step 1:"})," 为 ",(0,o.jsx)(e.code,{children:"Transition"})," 下的子节点添加 ",(0,o.jsx)(e.code,{children:"enterHooks"}),"。"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Step 2:"})," 为 ",(0,o.jsx)(e.code,{children:"Transition"})," 下的子节点添加 ",(0,o.jsx)(e.code,{children:"leavingHooks"}),"。"]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Step 3:"})," 处理完成后直接返回子节点作为渲染内容。"]}),"\n",(0,o.jsxs)(e.p,{children:["那么，这些 ",(0,o.jsx)(e.code,{children:"hooks"})," 到底做了些什么？以及这些 ",(0,o.jsx)(e.code,{children:"hooks"})," 是在什么时候被执行的呢？我们一个个来看。"]}),"\n",(0,o.jsxs)(e.h3,{id:"1-hooks-到底做了些什么",children:["1. ",(0,o.jsx)(e.code,{children:"hooks"})," 到底做了些什么？",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-hooks-到底做了些什么",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["要回答这些 ",(0,o.jsx)(e.code,{children:"hooks"})," 到底做了什么？首先需要了解这些 ",(0,o.jsx)(e.code,{children:"hooks"})," 是从哪里来的。再回到上述源码，我们知道 ",(0,o.jsx)(e.code,{children:"hooks"})," 是通过："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"const leavingHooks = resolveTransitionHooks(\n  oldInnerChild,\n  rawProps,\n  state,\n  instance\n)\n"})}),"\n",(0,o.jsxs)(e.p,{children:["这样的函数调用产生的，现在我们先不讨论这个函数的具体实现，先看看该函数的入参，有一个 ",(0,o.jsx)(e.code,{children:"rawProps"})," 的参数，这个就是上文所说的 ",(0,o.jsx)(e.code,{children:"Transition"})," 组件 ",(0,o.jsx)(e.code,{children:"render"})," 函数中传入的 ",(0,o.jsx)(e.code,{children:"props"})," 参数。"]}),"\n",(0,o.jsxs)(e.p,{children:["接下来就需要分析 ",(0,o.jsx)(e.code,{children:"props"})," 中有些什么东西："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"function resolveTransitionProps(rawProps) {\n  const baseProps = {}\n  // ...\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key]\n    }\n  }\n  const {\n    name = 'v',\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps\n  // ...\n  return extend(baseProps, {\n    onEnter: makeEnterHook(false),\n    onLeave: () => {},\n    // ....\n  })\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["根据我们前面了解到的，",(0,o.jsx)(e.code,{children:"Vue"})," 会在特定阶段为节点增加或删除特定 ",(0,o.jsx)(e.code,{children:"class"}),"。而这个 ",(0,o.jsx)(e.code,{children:"props"})," 正式为了所谓的 ",(0,o.jsx)(e.strong,{children:"特定的阶段"})," 量身打造的 ",(0,o.jsx)(e.strong,{children:"钩子"})," 函数。举个例子，我们需要实现进入节点的 ",(0,o.jsx)(e.code,{children:"v-enter-from、v-enter-active、v-enter-to"})," 类名的添加，我们只需要在 ",(0,o.jsx)(e.code,{children:"onEnter"})," 进入钩子内实现逻辑："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"const makeEnterHook = (isAppear) => {\n  return (el, done) => {\n    // 移除 v-enter-to、v-enter-active 类名\n    const resolve = () => finishEnter(el, isAppear, done)\n    // 下一帧渲染时\n    nextFrame(() => {\n      // 删除 v-enter-from 类名\n      removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass)\n      // 添加 v-enter-to 类名\n      addTransitionClass(el, isAppear ? appearToClass : enterToClass)\n      // 动画结束时，执行 resolve 函数，即删除 v-enter-to、v-enter-active 类名\n      if (!hasExplicitCallback(hook)) {\n        whenTransitionEnds(el, type, enterDuration, resolve)\n      }\n    })\n  }\n}\n"})}),"\n",(0,o.jsx)(e.p,{children:"这里的流程是不是跟上面的描述一毛一样！"}),"\n",(0,o.jsxs)(e.h3,{id:"2-hooks-何时执行",children:["2. hooks 何时执行？",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-hooks-何时执行",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["前面我们提到 ",(0,o.jsx)(e.code,{children:"hooks"})," 将会在特定时间执行，用来对 ",(0,o.jsx)(e.code,{children:"class"})," 进行增加或删除。比如 ",(0,o.jsx)(e.code,{children:"enter-from"})," 至 ",(0,o.jsx)(e.code,{children:"enter-to"})," 阶段的过渡或者动画效果的 ",(0,o.jsx)(e.code,{children:"class"})," 被添加到",(0,o.jsx)(e.code,{children:"DOM"})," 元素上。考虑到 ",(0,o.jsx)(e.code,{children:"Vue"})," 在 ",(0,o.jsx)(e.code,{children:"patch"})," 阶段已经有生成对应的 ",(0,o.jsx)(e.code,{children:"DOM"})," （只不过还没有被真实的挂载到页面上而已）。所以我们只需要在 ",(0,o.jsx)(e.code,{children:"patch"})," 阶段做对应的 ",(0,o.jsx)(e.code,{children:"class"})," 增删即可。"]}),"\n",(0,o.jsxs)(e.p,{children:["比如进入阶段的钩子函数，将会在 ",(0,o.jsx)(e.code,{children:"mountElement"})," 中被调用："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// 挂载元素节点\nconst mountElement = (vnode,...args) => {\n  let el;\n  let vnodeHook;\n  const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;\n  // ...\n  if (needCallTransitionHooks*) {\n    // 执行 beforeEnter 钩子\n    transition.beforeEnter(el);\n  }\n  // ...\n  if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      // post 各种钩子 至后置执行任务池\n      queuePostRenderEffect(() => { \n        // 执行 enter 钩子\n        needCallTransitionHooks && transition.enter(el); \n      }, parentSuspense);\n  }\n};\n"})}),"\n",(0,o.jsxs)(e.p,{children:["离开阶段的钩子函数，在 ",(0,o.jsx)(e.code,{children:"remove"})," 节点的时候被调用："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// 移除 Vnode\nconst remove = vnode => {\n  const { type, el, anchor, transition } = vnode;\n  // ...\n\n  const performRemove = () => {\n    hostRemove(el);\n    if (transition && !transition.persisted && transition.afterLeave) {\n      // 执行 afterLeave 钩子\n      transition.afterLeave();\n    }\n  };\n\n  if (vnode.shapeFlag & 1 ShapeFlags.ELEMENT && transition && !transition.persisted) {\n    const { leave, delayLeave } = transition;\n    // 执行 leave 钩子\n    const performLeave = () => leave(el, performRemove);\n    if (delayLeave) {\n       // 执行 delayLeave 钩子\n      delayLeave(vnode.el, performRemove, performLeave);\n    }\n    else {\n      performLeave();\n    }\n  }\n};\n"})}),"\n",(0,o.jsx)(e.p,{children:"为了更加清晰的看懂这个流程，我画了个状态流转图，可以简单看一下，方便理解："}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)("img",{src:i,alt:"image.png"})}),"\n",(0,o.jsxs)(e.h2,{id:"javascript-钩子",children:["JavaScript 钩子",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-钩子",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:"<Transition>"}),"\xa0组件在动画过渡的各个阶段定义了很多钩子函数，我们可以通过在钩子函数内部自定义实现各种动画效果。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-html",children:'<Transition\n  @before-enter="onBeforeEnter"\n  @enter="onEnter"\n  @after-enter="onAfterEnter"\n  @enter-cancelled="onEnterCancelled"\n  @before-leave="onBeforeLeave"\n  @leave="onLeave"\n  @after-leave="onAfterLeave"\n  @leave-cancelled="onLeaveCancelled"\n>\n  \x3c!-- ... --\x3e\n</Transition>\n'})}),"\n",(0,o.jsxs)(e.p,{children:["前面其实已经稍微提及到了部分钩子函数，比如 ",(0,o.jsx)(e.code,{children:"onEnter"}),"，这些钩子函数在源码中会被合并到 ",(0,o.jsx)(e.code,{children:"Transiton"})," 下子节点的 ",(0,o.jsx)(e.code,{children:"transition"})," 属性上。这块的实现主要是通过 ",(0,o.jsx)(e.code,{children:"setTransitionHooks"})," 函数来实现的："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"const BaseTransitionImpl = {\n  name: `BaseTransition`,\n\n  props: {\n    // ...\n  },\n\n  setup(props, { slots }) {\n    return () => {\n      // 获取进入状态的调用函数\n      const enterHooks = resolveTransitionHooks(\n        innerChild,\n        rawProps,\n        state,\n        instance\n      )\n      \n      // 为子节点添加进入 hooks 属性\n      setTransitionHooks(innerChild, enterHooks)\n  \n      // ...\n      // 返回子节点\n      return child\n    }\n  }\n}\n\n// 为 vnode 添加 transition 属性\nfunction setTransitionHooks(vnode, hooks) {\n  // ...\n  vnode.transition = hooks\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["其中 ",(0,o.jsx)(e.code,{children:"hooks"})," 包含了哪些内容呢？",(0,o.jsx)(e.code,{children:"hooks"})," 其实是通过 ",(0,o.jsx)(e.code,{children:"resolveTransitionHooks"})," 函数调用生成的："]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"export function resolveTransitionHooks(vnode, props, state, instance) {\n  // 传入的各个钩子函数\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props\n  \n  // 定义调用钩子函数的方法\n  const callHook = (hook, args) => {\n    hook &&\n      callWithAsyncErrorHandling(\n        hook,\n        instance,\n        ErrorCodes.TRANSITION_HOOK,\n        args\n      )\n  }\n  // 钩子函数定义\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter\n      // ...\n      // 执行 onBeforeEnter\n      callHook(hook, [el])\n    },\n\n    enter(el) {\n      let hook = onEnter\n      // ...\n      // 执行 onEnter\n      callAsyncHook(hook, [el, done])\n    },\n\n    leave(el, remove) {\n      // ...\n      // 执行 onBeforeLeave\n      callHook(onBeforeLeave, [el])\n      const done = (el._leaveCb = (cancelled?) => {\n        // ...\n        // 执行 onLeave\n        callAsyncHook(onLeave, [el, done])\n      })\n    },\n\n    clone(vnode) {\n      return resolveTransitionHooks(vnode, props, state, instance)\n    }\n  }\n\n  return hooks\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["一个最基础的 ",(0,o.jsx)(e.code,{children:"hooks"})," 主要包含 ",(0,o.jsx)(e.code,{children:"beforeEnter"}),"、",(0,o.jsx)(e.code,{children:"enter"}),"、",(0,o.jsx)(e.code,{children:"leave"})," 这几个阶段，将会在 ",(0,o.jsx)(e.code,{children:"patch"})," 的环节中被执行，执行的逻辑就是 ",(0,o.jsx)(e.code,{children:"Vue"})," 官网上描述的逻辑。"]}),"\n",(0,o.jsxs)(e.p,{children:["另外，值得注意的是，除了这几个关键阶段之外，",(0,o.jsx)(e.code,{children:"Transiton"})," 还支持一个 ",(0,o.jsx)(e.code,{children:"mode"})," 来指定动画的过渡时机，举个例子，如果 ",(0,o.jsx)(e.code,{children:"mode === 'out-in'"}),"，先执行离开动画，然后在其完成",(0,o.jsx)(e.strong,{children:"之后"}),"再执行元素的进入动画。那么这个时候就需要",(0,o.jsx)(e.strong,{children:"延迟渲染进入动画"}),"，则会为 ",(0,o.jsx)(e.code,{children:"leavingHooks"})," 额外添加一个新的钩子：",(0,o.jsx)(e.code,{children:"afterLeave"}),"，该钩子将会在离开后执行，表示着离开后再更新 ",(0,o.jsx)(e.code,{children:"DOM"}),"。"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"\nconst BaseTransitionImpl = {\n  setup() {\n    // ...\n    if (mode === 'out-in') {\n      state.isLeaving = true\n      // 返回空的占位符节点，当离开过渡结束后，重新渲染组件\n      leavingHooks.afterLeave = () => {\n        state.isLeaving = false\n        instance.update()\n      }\n      return emptyPlaceholder(child)\n    }\n  }\n}\n"})}),"\n",(0,o.jsxs)(e.h2,{id:"总结",children:["总结",(0,o.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,o.jsxs)(e.p,{children:["本小节我们核心介绍了 ",(0,o.jsx)(e.code,{children:"Transition"})," 内置组件的实现原理："]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:"Transition"})," 组件本身是一个无状态组件，内部本身不渲染任何额外的 ",(0,o.jsx)(e.code,{children:"DOM"})," 元素，",(0,o.jsx)(e.code,{children:"Transition"})," 渲染的是组件嵌套的第一个子元素节点。"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["如果子元素是应用了 ",(0,o.jsx)(e.code,{children:"CSS"})," 过渡或动画，",(0,o.jsx)(e.code,{children:"Transition"})," 组件会在子元素节点渲染适当时机，动态为子元素节点增加或删除对应的 ",(0,o.jsx)(e.code,{children:"class"}),"。"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["如果有为 ",(0,o.jsx)(e.code,{children:"Transition"})," 定义一些钩子函数，那么这些钩子函数会被合入到子节点的关键生命周期 ",(0,o.jsx)(e.code,{children:"beforeEnter"}),"、",(0,o.jsx)(e.code,{children:"enter"}),"、",(0,o.jsx)(e.code,{children:"leave"})," 中调用执行，通过 ",(0,o.jsx)(e.code,{children:"setTransitionHooks"})," 被设置到子节点的 ",(0,o.jsx)(e.code,{children:"transition"})," 属性中。"]}),"\n"]}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["Vue%203%20%E6%8A%80%E6%9C%AF%E6%8F%AD%E7%A7%98%2F16.%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%EF%BC%9ATransition%20%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F.md"]={toc:[{text:"前言",id:"前言",depth:2},{text:"基于 CSS 的过渡效果",id:"基于-css-的过渡效果",depth:2},{text:"1. `hooks` 到底做了些什么？",id:"1-hooks-到底做了些什么",depth:3},{text:"2. hooks 何时执行？",id:"2-hooks-何时执行",depth:3},{text:"JavaScript 钩子",id:"javascript-钩子",depth:2},{text:"总结",id:"总结",depth:2}],title:"16.内置组件：Transition 是如何实现的？",headingTitle:"16.内置组件：Transition 是如何实现的？",frontmatter:{}}}}]);