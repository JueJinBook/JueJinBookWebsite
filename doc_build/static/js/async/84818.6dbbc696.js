"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["84818"],{135073:function(e,c,a){e.exports=a.p+"static/image/0c38d680ab0c69bf9acb4fbe360605e0.00484b77.webp"},746341:function(e,c,a){e.exports=a.p+"static/image/1e0309c5ad61943648a2e43791744978.c1df9187.webp"},688634:function(e,c,a){e.exports=a.p+"static/image/87aa5fb542fd4473d2d6e35ce3723e2a.ee3dda94.webp"},567755:function(e,c,a){e.exports=a.p+"static/image/ad576f2b5d1f43e8cbf04f10dfac6d21.cc6ba228.webp"},234684:function(e,c,a){e.exports=a.p+"static/image/be23631286693935a179bad5468db147.6f57c6a4.webp"},124315:function(e,c,a){e.exports=a.p+"static/image/be4bd2a92acbd8bc868f680005a56475.eab4fec1.webp"},856226:function(e,c,a){a.r(c),a.d(c,{default:()=>ea});var n=a(552676),i=a(740453);let s=a.p+"static/image/daad5967d7d15ce4015ff60ab05ae88b.7d5a3f94.webp",r=a.p+"static/image/ed64c2508f80b394027460d35be6e9d2.167a77f9.webp",t=a.p+"static/image/a5526efe8c0dd25abad2651df6b546f0.f96c7b9d.webp",d=a.p+"static/image/45b35ce84669358e5fddf088598b10bf.17634f7a.webp",p=a.p+"static/image/614c3c98baf013b564797d3db04205a4.6360af61.webp";var l=a(688634);let x=a.p+"static/image/bee098e15bcf5ae9a87c49b5c61387f5.f6d9d2c9.webp",j=a.p+"static/image/cca7c1ed1c5f4677001310c0656814c3.ac0b8519.webp",b=a.p+"static/image/638aff63fcc0bf6fa53058d9bb145933.3085ffd1.webp",h=a.p+"static/image/a0ed380ce3bd06f3623412f3c359482e.480a8265.webp";var m=a(135073);let f=a.p+"static/image/b2ce0fccf1d219bf152633b511236b49.46eece52.webp",o=a.p+"static/image/f3012de0fae0bf907c45afd75b9a7326.c5aa14c1.webp",g=a.p+"static/image/6194e580f308090fb8abdea867a5f533.31bcc343.webp",u=a.p+"static/image/66e4f208fb48e2506b892da739ef39a1.36c3b058.webp",w=a.p+"static/image/e60ff0372ac16f6553d200fab2f0266e.739f4c35.webp",k=a.p+"static/image/393ba2995a7002c644df90e8d682044e.277038e7.webp",E=a.p+"static/image/8eb0be30369f4a243beb4eb7ee1c54ec.7c26e278.webp",C=a.p+"static/image/b484bfa5d5e93821789556a4a7c9af4e.6a247972.webp",R=a.p+"static/image/e56d7d8ae852c02bb96584f33d9f1db2.ba20354c.webp",A=a.p+"static/image/dc1b280717931828c6c7dc5ddd053c44.aeb0d70e.webp",_=a.p+"static/image/a7657f1010308b0ae16582b3bcd74052.451fa66a.webp",W=a.p+"static/image/2fa1692d0cab0bf102b3db76b3acf1a1.1826065e.webp",F=a.p+"static/image/c78c0ea4f1bb5a6da8da21cfa21f85d5.7741d2c5.webp",S=a.p+"static/image/bdab74640757baa98d462c6a656df07c.c9651073.webp";var v=a(746341);let B=a.p+"static/image/2fae969f2168600bfae8b3880c202624.63d89a6c.webp",M=a.p+"static/image/ea675bfc497124b85e653580f393aebf.437dc868.webp",y=a.p+"static/image/4975db5f510ef8697adade67d910391d.9b130dbc.webp",N=a.p+"static/image/4ee7004c884726bc4313734bca5f3b42.3a41dc03.webp",P=a.p+"static/image/a124baa0e4c16918d3d6ca3346560403.0faea5d5.webp";var q=a(567755);let z=a.p+"static/image/5aa31d20ffbee657600beacc27c2f2a5.239eedd1.webp",D=a.p+"static/image/b0168a8169145c08565d2eee5f2e4b44.9ac7ba67.webp",H=a.p+"static/image/d83e4a9e51d9c0c0b3204294c3129e72.1a8a0dc1.gif",I=a.p+"static/image/83e2a232ae4362f90c41d9df5d4e4d40.36821c1a.webp",T=a.p+"static/image/0349fe3f75ab75da9ed5df9fca2b3354.91940de5.webp";var G=a(124315);let L=a.p+"static/image/92a1bcc1757c17596cf4152c71e02316.d6bdc3fe.webp",O=a.p+"static/image/c8d5520847e4d553acb7e0c9948b3cde.77395709.webp",V=a.p+"static/image/2607b83c1632c8304e614aa348217ab9.e7ea48a0.webp";var $=a(234684);let J=a.p+"static/image/d006dc25109ca826374cd94523976086.49ef88fc.gif",K=a.p+"static/image/236b9119d515f6f586259105ad6a53a6.34c0595e.webp",Q=a.p+"static/image/a88d5caf3a47b595695d57e07960fcc9.6fc7f7e6.webp",U=a.p+"static/image/046db4271c59f89201f618fbd5bf99db.2a53b970.webp",X=a.p+"static/image/d9b4da314d7f908f5ec22f705cfd664e.35a468cd.webp",Y=a.p+"static/image/f7f4b851c900c238247912a109a3d92e.44e0b6c3.webp",Z=a.p+"static/image/568e352801082a60b9795f7a88997026.8093b997.webp";function ee(e){let c=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,i.ah)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(c.h1,{id:"第64章手写minireact和真实react源码的对比",children:["第64章—手写MiniReact：和真实React源码的对比",(0,n.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#第64章手写minireact和真实react源码的对比",children:"#"})]}),"\n",(0,n.jsx)(c.p,{children:"\uFEFF上节我们写了 mini react。"}),"\n",(0,n.jsx)(c.p,{children:"它和真实的 react 渲染流程是否一样呢？"}),"\n",(0,n.jsx)(c.p,{children:"这节我们就调试下 react 源码，对比下两者的差别。"}),"\n",(0,n.jsx)(c.p,{children:"用 cra 创建个 react 项目："}),"\n",(0,n.jsx)(c.pre,{children:(0,n.jsx)(c.code,{children:"npx create-react-app --template=typescript react-source-debug\n"})}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:Z,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"把开发服务跑起来："}),"\n",(0,n.jsx)(c.pre,{children:(0,n.jsx)(c.code,{children:"npm run start\n"})}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:Y,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"浏览器访问下："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:X,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"没啥问题。"}),"\n",(0,n.jsx)(c.p,{children:"点击 create a launch.json file 创建个调试配置："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:U,alt:""})}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:Q,alt:""})}),"\n",(0,n.jsx)(c.pre,{children:(0,n.jsx)(c.code,{className:"language-json",children:'{\n    "type": "chrome",\n    "request": "launch",\n    "name": "Launch Chrome against localhost",\n    "url": "http://localhost:3000",\n    "webRoot": "${workspaceFolder}"\n}\n'})}),"\n",(0,n.jsx)(c.p,{children:"在 App.tsx 打个断点："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:K,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"点击调试启动："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:J,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"代码会在这里断住。"}),"\n",(0,n.jsx)(c.p,{children:"前面讲过，jsx 会编译成 render function，然后执行后产生 React Element："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:$,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"关掉 sorucemap 重新调试："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:V,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"可以看到这个 jsxDEV 就是 render function："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:O,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"它是从 react 包引入的："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:L,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"和我们在 babel playground 里看到的结果一样："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:G,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"在这里打个断点："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:T,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"然后点击跳断点执行和进入函数内部："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:I,alt:""})}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:H,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"在返回值这里打个断点："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:D,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"可以看到，render function 返回的是一个 React Element，有 type、props 等属性。"}),"\n",(0,n.jsx)(c.p,{children:"我们的 mini react 里也实现了 render function："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:z,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"接下来再看 schedule 和 reconcile 部分："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:q,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"打开 sourcemap，重新跑调试："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:P,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"在调用栈可以看到 workLoop："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:N,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"这个是 schduler 包里的，这个包是 react 实现的类似 requestIdleCallback 的功能。"}),"\n",(0,n.jsx)(c.p,{children:"可以看到，每次取一个任务的回调来跑："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:y,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"然后回调里会判断是否要用时间分片："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:M,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"时间分片前面讲过，就是把 reconcile 过程分散到多个宏任务中跑："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:v,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"在 scheduler 里搜一下，可以看到，这个时间分片是 5ms："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:B,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"也就是说，如果超过 5ms，就会放到下个任务里跑。"}),"\n",(0,n.jsx)(c.p,{children:"这就是为啥 performance 看到的 event loop 是这样的："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:v,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"react 并发渲染的时候，就通过时间片是否到了来判断是否继续 reconcile："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:S,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"当然，我们实现的时候没有自己实现 schduler 的时间分片，而是直接用的浏览器的 requestIdleCallback 的 api，效果一样："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:F,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"接下来看下 reconcile 的过程："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:W,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"在 react 源码里，处理每个 fiber 节点的时候，会先调用 beginWork 处理，等 fiber 节点全部处理完，也就是没有 next 的 fiber 节点时，再调用 completeWork 处理。"}),"\n",(0,n.jsx)(c.p,{children:"那 beginWork 和 completeWork 里都做了啥呢？"}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:_,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"可以看到，根据 fiber 节点的类型来走了不同的分支，我们只处理了 FunctionComponent 和 HostComponent 类型。"}),"\n",(0,n.jsx)(c.p,{children:"看下 FunctionComponent 的处理："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:A,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"也是调用函数组件，拿到 children 之后继续 reconcileChildren。"}),"\n",(0,n.jsx)(c.p,{children:"reconcileChildren 里要对比新旧 fiber，做下 diff，打上增删改的标记："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:R,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"diff 之后，会分别打上 Place、ChildDeletion 等标记："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:C,alt:""})}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:E,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"这部分和我们 mini react 实现的 reconcile 逻辑差不多。"}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:k,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"那 completeWork 是干啥的呢？"}),"\n",(0,n.jsx)(c.p,{children:"看下 HostComponent 的 reconcile 逻辑，你会发现它并没有创建 dom："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:w,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"而我们的 mini react 里是创建了 dom 的。"}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:u,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"其实不是没有创建，而是这部分逻辑在 completeWork 里。"}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:g,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"completeWork 里处理到 HostComponent 就会创建对应的 dom，保存在 fiber.stateNode 属性上："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:o,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"为什么要分为 beginWork 和 completeWork 两个阶段呢？"}),"\n",(0,n.jsx)(c.p,{children:"其实也很容易搞懂，比如创建 dom 这件事，需要先把所有子节点的 dom 都创建好，然后 appendChild 才行。"}),"\n",(0,n.jsx)(c.p,{children:"所以就需要 beginWork 处理完所有 fiber 之后，再递归从下往上处理。"}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:f,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"然后是 commit 阶段，在 react 源码里可以看到，这个阶段分为了 before mutation、mutation、layout 这三个小阶段："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:m,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"mutation 阶段就是更新 dom 的："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:h,alt:""})}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:b,alt:""})}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:j,alt:""})}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:x,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"可以看到，mutation 阶段会把 reconcile 阶段创建好的 dom 更新到 dom 树。"}),"\n",(0,n.jsx)(c.p,{children:"那啥时候执行的 effect呢？"}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:l,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"刚进入 commitRoot 的时候，就会调度所有的 useEffect 的回调异步执行。"}),"\n",(0,n.jsx)(c.p,{children:"还有，useState、useEffect 等 hook 在 react 源码里是怎么实现的呢？"}),"\n",(0,n.jsx)(c.p,{children:"添加几个 hook："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:p,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"在 return 那里打个断点，可以看到现在的 fiber 是这样的："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:d,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"在 fiber 上有个 memoizedState 的链表，每个节点保存一个 hook 的信息。"}),"\n",(0,n.jsx)(c.p,{children:"调用 useState、useRef、useEffect 等 hook 的时候，会往对应的链表节点上存取内容。"}),"\n",(0,n.jsx)(c.p,{children:"hook 链表的创建分为 mount、update 两个阶段，第一次创建链表节点，第二次更新链表节点。"}),"\n",(0,n.jsx)(c.p,{children:"比如 useRef 就是在对应 hook 节点的 momoizedState 属性保存一个有 current 属性的对象，第二次调用返回这个对象："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:t,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"比如 useCallback 就是在对应 hook 节点的 momoizedState 属性保存一个数组，再次调用判断下 deps 是否一样，一样的话就返回之前的数组的第一个元素，否则更新："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:r,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"useMemo 和 useCallback 实现差不多，只不过保存的是函数的值："}),"\n",(0,n.jsx)(c.p,{children:(0,n.jsx)("img",{src:s,alt:""})}),"\n",(0,n.jsx)(c.p,{children:"这样，和 mini react 对应的 react 源码里的实现就理清了。"}),"\n",(0,n.jsxs)(c.h2,{id:"总结",children:["总结",(0,n.jsx)(c.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,n.jsx)(c.p,{children:"我们调试了下 react 源码，和前面写的 mini react 对比了下。"}),"\n",(0,n.jsx)(c.p,{children:"实现 render function 返回 React Element。"}),"\n",(0,n.jsx)(c.p,{children:"React Element 树经过 reconcile 变成 fiber 树，reconcile 的时候根据不同类型做不同处理，然后 commit 阶段执行 dom 增删改和 effect 等。"}),"\n",(0,n.jsx)(c.p,{children:"这些都差不多。"}),"\n",(0,n.jsx)(c.p,{children:"只不过 react 源码里 render 阶段 reconcile 分成了 beginWork、completeWork 两个小阶段，dom 的创建和组装是在 completeWork 里做的。"}),"\n",(0,n.jsx)(c.p,{children:"commit 阶段分成了 before mutation、mutation、layout 这三个小阶段。"}),"\n",(0,n.jsx)(c.p,{children:"react 的调度也是用自己实现的 schduler 做的，实现了时间分片，而我们用的 requestIdleCallback 做的调度。"}),"\n",(0,n.jsx)(c.p,{children:"react 的 hook 的值是存放在 fiber.memoizedState 链表上的，每个 hook 对应一个节点，在其中存取值，而我们是用的别的属性。"}),"\n",(0,n.jsx)(c.p,{children:"包括保存 dom 的节点，在 react 里是用 fiber.stateNode 属性保存。"}),"\n",(0,n.jsx)(c.p,{children:"但总体来说，流程上是差不多的，通过学习 mini react，能够很好的帮你理解 react 的实现原理。"})]})}function ec(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:c}=Object.assign({},(0,i.ah)(),e.components);return c?(0,n.jsx)(c,{...e,children:(0,n.jsx)(ee,{...e})}):ee(e)}let ea=ec;ec.__RSPRESS_PAGE_META={},ec.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC64%E7%AB%A0%E2%80%94%E6%89%8B%E5%86%99MiniReact%EF%BC%9A%E5%92%8C%E7%9C%9F%E5%AE%9EReact%E6%BA%90%E7%A0%81%E7%9A%84%E5%AF%B9%E6%AF%94.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第64章—手写MiniReact：和真实React源码的对比",headingTitle:"第64章—手写MiniReact：和真实React源码的对比",frontmatter:{}}}}]);