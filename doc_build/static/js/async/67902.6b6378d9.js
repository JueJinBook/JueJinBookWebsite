"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["67902"],{725623:function(e,n,s){s.r(n),s.d(n,{default:()=>m});var r=s(552676),a=s(740453);let i=s.p+"static/image/965e1f7242e1394a848984f88aab0dca.fea1058b.webp",t=s.p+"static/image/bd0d6f2de6ac4c6f3dea6a27ef0ab2f0.52b8ed66.webp",l=s.p+"static/image/28f1a531e38c316a95b71a1e7ae2ac5e.a991524d.webp",d=s.p+"static/image/848611bab6e0e8943fee4ee19527ae30.9adbe650.webp",c=s.p+"static/image/7de8540c403b62e50c1f46d73c7096b1.5a3c1419.webp",o=s.p+"static/image/5d90889beb010d11b4d03235b9962383.0cd53b67.webp";function h(e){let n=Object.assign({p:"p",ul:"ul",li:"li",h1:"h1",a:"a",pre:"pre",code:"code",strong:"strong",img:"img",ol:"ol",blockquote:"blockquote",h2:"h2"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"上一节中，主要学习了表单的数据流向，明确了整个组件的核心 FormStore，接下来我们继续完善表单的剩下功能，将会学到以下知识点："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Form 表单的校验设计和编写；"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"如何暴露 FormStore 中的实例方法。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h1,{id:"18实践篇表单组件设计下表单的规则与验证",children:["18.实践篇｜表单组件设计（下）：表单的规则与验证",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#18实践篇表单组件设计下表单的规则与验证",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"表单校验是表单组件中最常见、最核心的功能之一，对整个数据流向有着至关重要的作用。在此之前，我们先来看看 Ant Design 中的表单验证："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// AntDForm\nconst Index: React.FC = () => {\n  return (\n    <>\n     \n      <Form\n        ...\n        onFinish={(data: any) => {\n          console.log("表单数据:", data);\n        }}\n        onFinishFailed={(errorInfo: any) => {\n          console.log("Failed:", errorInfo);\n        }}\n      >\n        ...\n        <Form.Item\n          label="必填"\n          name="rules"\n          rules={[{ required: true, message: "请输入规则" }]}\n        >\n          <Input placeholder="请输入作者" />\n        </Form.Item>\n\n        <Form.Item\n          rules={[{ required: true, message: "请输入必填" }]}\n          label="选择框必填"\n          name="select"\n        >\n          <Select\n            style={{ width: 120 }}\n            allowClear\n            options={[\n              { value: "React", label: "React" },\n              { value: "Vue", label: "Vue" },\n              { value: "Hooks", label: "Hooks" },\n            ]}\n          />\n        </Form.Item>\n        ...\n    </>\n  );\n};\n\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"演示效果："})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"在演示的效果中，我们发现校验的场景共有三处，分别是："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"表单提交。"})," 点击提交按钮，对所有表单控件进行校验，校验失败后，框的状态变红，下方出现提示语，触发 onFinishFailed，而不会触发 onFinish 事件。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"表单控件修改。"})," 当 onChange 发生变化时，触发单个控件校验。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"重置表单。"})," 点击重置按钮，将所有表单控件的状态还原成初始化。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"很显然，每个表单控件拥有三个状态，通过这些状态来判断对应的模式，不同的状态对应不同的模式、产生不同的效果："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"pen："})," 等待状态，控件初始化状态，或重置表单时，就给控件为 pen 状态；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"res："})," 成功状态，表单校验成功后，给予此状态，当所有表单控件状态校验成功后，触发 onFinish；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"rej："})," 失败状态，表单校验失败后，给予此状态，对应的表单控件边框变红，下方出现错误提示语。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"再来看看校验的规则（rules）格式："}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:'rules=[{ required: true, message: "请输入规则" }]'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"显然，rules 的结构是数组，required 是必填字段，message 是错误信息字段，除了必填字段之外，还具备正则校验、自定义校验等。"}),"\n",(0,r.jsx)(n.p,{children:"那么，我们可以这样定义 rules 的字段："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"rules => validateRuleProps = {\n  required?: boolean => 是否必填\n  message?: string => 错误提示的提示语\n  rule?: RegExp | ((value: any) => boolean) => 正则、自定以校验\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["其中，必填字段与其他校验有所不同，因为 required 需要控制 label 前面的样式 ",(0,r.jsx)(n.code,{children:"*"}),"，并且与其他规则是",(0,r.jsx)(n.strong,{children:"共存"}),"的关系，所以必填应该与其他校验分开来存储。"]}),"\n",(0,r.jsx)(n.p,{children:"在 FormStore 中的校验结构："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"validateRule = {\n    [name] => validateRule = {\n       required: boolean  => 是否必填\n       requiredMessage?: string => 必填错误的提示语\n       message: string => 具体的错误提示语\n       status: pen ｜ res ｜ rej => 状态控制\n       rules: rulesProps => 规则数据 => {\n           rule: RegExp | ((value: any) => boolean) => 正则、自定义校验\n           message：string => 对应的校验提示语\n       }\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"validateRule"}),"：校验表单的规则结构；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"name"}),"：Form.Item 中的 name，每个 Form.Item 中的 name 应该是唯一值；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"required、message、status"}),"：每个表单控件的状态，并且是控制当前 Form.Item 的单一字段；"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"rules"}),"：对应 rules 的数组（过滤 required 的规则）。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"整体来看校验的内部流程图："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.h2,{id:"1-注册卸载校验",children:["1. 注册、卸载校验",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-注册卸载校验",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在校验的过程中，每个 Form.Item 都应该具备 rules 字段，并且每个 Form.Item 中的 rules 不同，故 rules 应放入 updateChange 中，同时在 FormStore 中进行注册。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"注册："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// formItem\nconst FormItem = (props: FormItemProps) => {\n  ...\n  const updateChange: updateProps = useCreation(() => {\n    return {\n      message: props?.message || `请填写${props?.label}字段`,\n      required: props?.required,\n      rules: props?.rules,\n      updateValue: () => update(),\n    };\n  }, [contextValue, name]);\n\n  useEffect(() => {\n    // 注册\n    name && registerField(name, updateChange);\n    return () => {\n      //卸载\n      name && unRegisterField(name);\n    };\n  }, [updateChange]);\n  \n  ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在必填校验中，具备两种状态，分别是 required 和 rules 中的 required， 所以在 updateChange 设置 ",(0,r.jsx)(n.code,{children:"rules"}),"、",(0,r.jsx)(n.code,{children:"required"}),"、",(0,r.jsx)(n.code,{children:"message"})," 三个字段。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"创建一个验证模块："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// FormStore\nclass FormStore {\n  ...\n  validateRule: validateRule = {}; // 校验表单的规则\n  \n  // 注册表单方法\n  registerField = (name: NameProps, updateChange: updateProps) => {\n    ...\n    this.validateRule[name] = this.createValidate(name, updateChange);\n  };\n\n  // 创建一个验证模块\n  createValidate(\n    name: NameProps,\n    updateChange: updateProps\n  ): validateRuleListProps | null {\n    const { rules = [], required = false, message = "" } = updateChange;\n    if (rules.length === 0 && !required) return null;\n\n    // 抽离出必填项\n    const requiredFlag = required || rules.find((v) => v?.required)?.required;\n\n    // 如果存在必填则更新对应表单\n    if (requiredFlag) this.updateStoreField(name);\n\n    return {\n      message,\n      requiredMessage: message,\n      required: requiredFlag || false,\n      status: "pen", // 设置为等待状态\n      rules: rules.filter((v) => v?.rule), // 过滤掉有required的项\n    };\n  }\n  \n  ...\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"在验证模块中，rules 和 required 不存在时，则直接赋予 null。如果存在，抽离出必填项，然后将其赋予到 validateRule 中。"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注：validateRule 中的 message 并不是 updateChange 中的 message，而是校验失败后的 message，由于 required 是单独处理，需要单独记录对应的错误提示，所以会存在 requiredMessage 这个字段。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"卸载："})}),"\n",(0,r.jsx)(n.p,{children:"卸载表单控件后，同时卸载对应的规则。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"class FormStore {\n  ...\n  \n  // 卸载表单方法\n  unRegisterField = (name: NameProps) => {\n    ...\n    delete this.validateRule[name];\n  };\n  \n  ...\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"2-提交校验",children:["2. 提交校验",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-提交校验",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["当点击提交按钮时，对整个表单控件（validateRule）进行校验，如果所有的表单控件通过校验，则触发 onFinish，表单校验成功；反之，校验失败，状态为 ",(0,r.jsx)(n.code,{children:"rej"})," 的表单控件",(0,r.jsx)(n.strong,{children:"更新视图"}),"。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"验证表单："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'// FormStore\nclass FormStore {\n  ...\n  // 用于表单提交\n  submit = () => {\n    const status = this.validateField();\n    const { onFinish } = this.configWays;\n    \n    status && onFinish && onFinish(this.store);\n  };\n  \n  // 用于集中表单验证\n  validateField = () => {\n    let flag = true;\n    Object.keys(this.validateRule).forEach((name) => {\n      const status = this.validateFieldValue(name);\n      if (status === "rej") flag = false;\n    });\n    return flag;\n  };\n  \n  // 用于单个验证表单\n  validateFieldValue = (name: NameProps) => {\n    const data = this.validateRule[name];\n    if (!data) return null;\n    const value = this.store[name];\n    const last_status = data.status;\n    const last_message = data.message;\n    let status: validateStatusProps = "res";\n    if (data.required && !value) {\n      status = "rej";\n      data.message = data?.requiredMessage || "";\n    }\n\n    data.rules.map((v) => {\n      if (status !== "rej" && value && v.rule) {\n        if (v.rule instanceof RegExp && !v.rule.test(value)) {\n          status = "rej";\n          data.message = v?.message || "";\n        }\n\n        if (typeof v.rule === "function" && !v.rule(value)) {\n          status = "rej";\n          data.message = v?.message || "";\n        }\n      }\n    });\n\n    // 如果状态或错误提示不一致，则进行更新\n    if (last_status !== status || last_message !== data.message)\n      this.updateStoreField(name);\n\n    data.status = status;\n    return status;\n  };\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"this.validateField()："})," 集中校验表单控件，如果返回的状态为 true，则校验成功，触发 onFinish。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"this.validateFieldValue()："})," 校验单个表单控件，如果校验失败，status 的状态为 ",(0,r.jsx)(n.code,{children:"rej"}),"。其中规则校验分为",(0,r.jsx)(n.code,{children:"必填"}),"、",(0,r.jsx)(n.code,{children:"正则"}),"、",(0,r.jsx)(n.code,{children:"自定义校验"}),"三种，message 则是对应规则的 message。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"this.updateStoreField()："})," 更新对应的表单控件。"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"注：在校验过程中，无论是 status 的改变，还是 message 的改变，都无法引起视图的更新，所以需要通过 useUpdate 来刷新视图。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"3-异步校验",children:["3. 异步校验",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-异步校验",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在 validateFieldValue 中，我们通过比较每个表单控件的 status、message 来判断是否触发更新校验，但对于表单而言，校验本身步骤并不影响主流程，所以校验的功能通常采取",(0,r.jsx)(n.strong,{children:"异步"}),"完成。此时，我们可以借助 Promise 来帮助我们。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Promise 异步校验："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  //FormStore\n  class FormStore {\n    ...\n    validateQueue: any[] = []; // 校验队列\n    \n    ...\n    // 用于单个验证表单\n    validateFieldValue = (name: NameProps) => {\n      ...\n    \n      // 如果状态或错误提示不一致，则进行更新\n      if (last_status !== status || last_message !== data.message) {\n        const validateUpdate = this.updateStoreField.bind(this, name);\n        this.validateQueue.push(validateUpdate);\n      }\n\n      this.promiseValidate();\n      ...\n    };\n\n    // 异步校验队列\n    promiseValidate = () => {\n      if (this.validateQueue.length === 0) return null;\n         Promise.resolve().then(() => {\n           do {\n             let validateUpdate = this.validateQueue.shift();\n             validateUpdate && validateUpdate(); /* 触发更新 */\n           } while (this.validateQueue.length > 0);\n         });\n      };\n    }\n"})}),"\n",(0,r.jsx)(n.p,{children:"其中，validateQueue 是校验队列，如果 validateQueue 为空，则不进行校验，否则通过 Promise 来触发校验。"}),"\n",(0,r.jsxs)(n.h2,{id:"4-更新视图",children:["4. 更新视图",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-更新视图",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["视图的更新存在两个部分，分别是",(0,r.jsx)(n.strong,{children:"红框"}),"、",(0,r.jsx)(n.strong,{children:"错误提示语"}),"两个部分，其中红框可以利用 Ant Desgin 中的 status 属性。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"获取表单的验证值："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  // FormStore\n  class FormStore {\n    ..\n  \n    // 用于暴露方法\n    public getDetail = (): FormInstance => ({\n      ...\n      getFieldValidate: this.getFieldValidate,\n    });\n    \n    // 获取表单的验证值\n    getFieldValidate = (name: NameProps) => {\n      return this.validateRule[name];\n    };\n    \n    ....\n  }\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"红框效果："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  // formItem\n  const FormItem = (props: FormItemProps) => {\n     const { getFieldValidate } = contextValue;\n     ...\n     if (isValidElement(children) && name) {\n       childrenPro = cloneElement(children as React.ReactElement, {\n          ...\n          status: getFieldValidate(name)?.status === "rej" ? "error" : undefined,\n          });\n     }\n     return (\n        <Layout {...props} {...getFieldValidate(name)}>\n          {childrenPro}\n        </Layout>\n     );\n  }\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"提示语："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  // Layout\n  const Index = ({ children, status, message }) => {\n     const classRule = useCss({\n        color: "red",\n        fontSize: 12,\n        lineHeight: "22px",\n        padding: "0 6px",\n      });\n      \n      return (\n    <>\n      <Row gutter={8}>\n        ...\n        <Col span={9}>\n          <div>{children}</div>\n          {status === "rej" && <div className={classRule}>{message}</div>}\n        </Col>\n      </Row>\n    </>\n  }\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"其中，第一个和第二个是必填的两种模式，第三个的规则是正则，第四个的规则是自定义校验，第五个是：必填 + 正则 + 自定义。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"5-更新校验",children:["5. 更新校验",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-更新校验",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["更新的逻辑是在表单控件的",(0,r.jsx)(n.strong,{children:"值"}),"改变时触发，所以我们直接在 FormItem 中 onChange 触发校验即可。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  // FormItem\n  dispatch({\n    type: "validateField",\n    name,\n  });\n\n // FormStore\n class FormStore {\n   ...\n   dispatch = (action: ReducerAction) => {\n      switch (action.type) {\n        ...\n        // 触发检验\n        case "validateField": {\n          const { name } = action;\n          this.validateFieldValue(name); // 触发单个更新\n          break;\n        }\n        default:\n      }\n   };\n }\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"6-表单控件元素",children:["6. 表单控件元素",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-表单控件元素",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"这里演示的表单控件是 Input， 但不同的表单控件 onChange 的返回可能不同，所以我们只需要将值处理后给 value 即可（这里多加入 Select ）。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  // formItem\n  onChange: (v: any) => {\n    // 判断属于那种控件\n    const value = v?.target?.localName === "input" ? v?.target?.value : v;\n    \n    ...\n  }\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"效果"}),"："]}),"\n",(0,r.jsxs)(n.h2,{id:"7-失败校验onfinishfailed",children:["7. 失败校验（onFinishFailed）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-失败校验onfinishfailed",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["数据校验失败后，需要把对应的错误类型和当前的表单值传入到 onFinishFailed 中，也就是 ",(0,r.jsx)(n.code,{children:'status === "rej"'})," 的情况，如："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  // FormStore\n  class FormStore {\n    ...\n    \n    // 用于表单提交\n    submit = () => {\n      const status = this.validateField();\n\n      const { onFinish, onFinishFailed } = this.configWays;\n\n      if (!status) {\n        const errorFields = this.errorValidateFields();\n        onFinishFailed &&\n          onFinishFailed({\n            errorFields,\n            values: this.store,\n          });\n      } else {\n        onFinish && onFinish(this.store);\n      }\n    };\n\n    // 错误收集\n    errorValidateFields = () => {\n      let errorList: any = [];\n      Object.keys(this.validateRule).forEach((name) => {\n        const data = this.validateRule[name];\n        if (data && data.status === "rej") {\n          errorList = [...errorList, { name, errors: data.message }];\n        }\n      });\n      return errorList;\n    };\n    ...\n  }\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:d,alt:"img3.gif"})}),"\n",(0,r.jsxs)(n.h2,{id:"8-取消校验重置按钮",children:["8. 取消校验（重置按钮）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-取消校验重置按钮",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["所有的表单控件都通过 ",(0,r.jsx)(n.code,{children:'status === "rej"'})," 来控制，所以只需要将 status 的状态改为 ",(0,r.jsx)(n.code,{children:"pen"})," 即可，同时状态为 ",(0,r.jsx)(n.code,{children:"rej"})," 更改为 ",(0,r.jsx)(n.code,{children:"pen"}),"，需要刷新视图。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  // FormStore\n  class  FormStore {\n    ...\n    \n    // 重置表单\n    resetFields = () => {\n      ...\n\n      Object.keys(this.validateRule).forEach((key) => {\n        const data = this.validateRule[key];\n        if (data) {\n          if (data.status === "rej") this.updateStoreField(key);\n          data.status = "pen";\n        }\n      });\n     \n      ...\n    };\n  }\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"效果："})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:"img4.gif"})}),"\n",(0,r.jsxs)(n.h1,{id:"暴露实例方法",children:["暴露实例方法",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#暴露实例方法",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"之所以使用 useForm，是为了更好管理 Form 表单的数据流，通过 useForm 去暴露对应的方法实例，Form 的 props 去管理表单数据，同时还能直接通过实例去管理整个数据流，从而加强整个组件的灵活性。"}),"\n",(0,r.jsxs)(n.h2,{id:"转发-ref",children:["转发 ref",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#转发-ref",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["要想拿到对应的实例，就需要 Form 组件被 ref 标记，通过 ref 拿到 useForm（FormStore）的核心方法。但 ref 本身并不能作为 props 传入组件内部，所以需要 ",(0,r.jsx)(n.code,{children:"forwardRef"})," 和 ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})," 来转发 ref，通过 ref 标记 Form，来获取 formRef（即 FormStore 的 getDetail 方法）。"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"forwardRef：用于转发 ref。"}),"\n",(0,r.jsx)(n.p,{children:"useImperativeHandle：可以通过 forwardRef 暴露给父组件的实例值，所谓的实例值是指值和函数。"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'  //Form\n  import { forwardRef, useImperativeHandle } from "react";\n    const Index = (props: FormProps, ref: any) => {\n    ...\n    const [formRef] = useForm(initialValues);\n\n    /* Form 能够被 ref 标记，并操作实例。 */\n    useImperativeHandle(ref, () => formRef, []);\n\n    ...\n };\n\n export default forwardRef(Index);\n'})}),"\n",(0,r.jsx)(n.p,{children:"此时就通过 ref 来获取实例方法，如："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:"image.png"})}),"\n",(0,r.jsx)(n.p,{children:"但这里拿到了整个 FormStore 暴露的方法，对于外部开发者而言，并非所有的方法都需要，比如：registerField（注册表单方法）、unRegisterField（卸载表单方法）、dispatch（方法派发）、setConfigWays（设置方法区间），它们只适用于组件内部，并不适用于外部开发者，所以我们需要剔除这些方法。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"剔除不需要暴露的方法："})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  // 用于剔除方法，不提供给外部使用\n  const {\n    registerField,\n    unRegisterField,\n    dispatch,\n    setConfigWays,\n    ...formRefInstance\n  } = formRef;\n\n  /* Form 能够被 ref 标记，并操作实例。 */\n  useImperativeHandle(ref, () => formRefInstance, []);\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"实例方法",children:["实例方法",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实例方法",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"如果存在实例方法，则直接去使用。如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  // Form\n  const Index = (props: FormProps, ref: any) => {\n    const { form, ...} = props;\n    \n    const [formRef] = useForm(initialValues, form);\n    ...\n  }\n  \n  // useForm\n  const useForm = (initialValues: DataProps, formInstance?: FormInstance) => {\n    const formRef = useRef<FormInstance | null>();\n\n    if (!formRef.current) {\n      // 如果存在实例，则直接使用\n      if (formInstance) {\n        formRef.current = formInstance;\n      } else {\n        // 创建一个实例，帮我们获取对应的方法，而 getDetail 是暴露的方法集合\n        formRef.current = new FormStore(initialValues).getDetail();\n      }\n   }\n\n   return [formRef.current];\n };\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"方法优化",children:["方法优化",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方法优化",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"因为我们可以直接获取 ref 的实例，所以我们可以直接通过实例去完成一些操作，比如：获取表单数据、提交、重置等功能，但也要再对应的方法处理兼容问题，使实例可以正常运行，如："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"  // FormStore\n  class FormStore {\n    ...\n    \n    // 获取对应的值\n    getFieldValue = (name?: NameProps) => {\n      if (name) return this.store[name];\n      return this.store;\n    };\n  \n    // 用于表单提交\n    submit = (cb?: any) => {\n      const status = this.validateField();\n\n      const { onFinish, onFinishFailed } = this.configWays;\n\n      if (!status) {\n        const errorFields = this.errorValidateFields();\n\n        cb &&\n          cb({\n            errorFields,\n            values: this.store,\n          });\n\n        onFinishFailed &&\n          onFinishFailed({\n            errorFields,\n            values: this.store,\n          });\n      } else {\n        onFinish && onFinish(this.store);\n        cb && cb(this.store);\n      }\n    };\n    \n    ...\n  }\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"效果",children:["效果",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#效果",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:i,alt:"img5.gif"})}),"\n",(0,r.jsxs)(n.h1,{id:"小结",children:["小结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"通过这两节的阅读，相信大家对表单有了一定的认识，在所有的组件中，Form 组件是非常重要且有必要学习的组件之一，掌握它的原理十分重要。"}),"\n",(0,r.jsx)(n.p,{children:"Ant Design 的 From 表单主要有两个版本：v3（高阶组件）和 v4（Hooks），其思想非常重要，建议大家都去看看，亲自实现一番，肯定会受益良多。"}),"\n",(0,r.jsx)(n.p,{children:"这两节主要参考 rc-form 来实现 Form 组件，介绍数据通信、表单校验、暴露实例等写法，接下来进行 CheckCard （多选卡片） 组件的学习。"})]})}function u(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}let m=u;u.__RSPRESS_PAGE_META={},u.__RSPRESS_PAGE_META["%E7%8E%A9%E8%BD%AC%20React%20Hooks%2F18.%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BD%9C%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E8%A1%A8%E5%8D%95%E7%9A%84%E8%A7%84%E5%88%99%E4%B8%8E%E9%AA%8C%E8%AF%81.md"]={toc:[{text:"1. 注册、卸载校验",id:"1-注册卸载校验",depth:2},{text:"2. 提交校验",id:"2-提交校验",depth:2},{text:"3. 异步校验",id:"3-异步校验",depth:2},{text:"4. 更新视图",id:"4-更新视图",depth:2},{text:"5. 更新校验",id:"5-更新校验",depth:2},{text:"6. 表单控件元素",id:"6-表单控件元素",depth:2},{text:"7. 失败校验（onFinishFailed）",id:"7-失败校验onfinishfailed",depth:2},{text:"8. 取消校验（重置按钮）",id:"8-取消校验重置按钮",depth:2},{text:"转发 ref",id:"转发-ref",depth:2},{text:"实例方法",id:"实例方法",depth:2},{text:"方法优化",id:"方法优化",depth:2},{text:"效果",id:"效果",depth:2}],title:"小结",headingTitle:"小结",frontmatter:{}}}}]);