"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["81966"],{783270:function(e,n,c){c.r(n),c.d(n,{default:()=>d});var s=c(552676),i=c(740453);let r=c.p+"static/image/52b6147343b04198d7cc61d68241af18.43acdb33.webp",t=c.p+"static/image/0aed3f8105713fda16ef4f197a34a13a.bbbcf0ef.webp";function o(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",code:"code",pre:"pre",h2:"h2",ul:"ul",li:"li",img:"img"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"8-文章生成器如何用-fs-模块保存文件",children:["8 文章生成器：如何用 fs 模块保存文件？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#8-文章生成器如何用-fs-模块保存文件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这一节课我们要做两件事情，一是",(0,s.jsx)(n.strong,{children:"实现文章生成的模块"}),"，二是",(0,s.jsx)(n.strong,{children:"使用 fs 模块将生成的文章保存成文件"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["我们把生成文章模块命名为",(0,s.jsx)(n.code,{children:"generator.js"}),"，它导出 API —— ",(0,s.jsx)(n.code,{children:"generate"}),"函数，这个函数根据传入的 title（文章主题）和语料库以及配置信息来生成文章内容。它的函数签名如下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function generate(title, {corpus, min = 6000, max = 10000}) {\n  ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["参数 corpus 是语料库 JSON 文件，即我们上一节课从",(0,s.jsx)(n.code,{children:"corpus/data.json"}),"文件中读取的内容，min 是文章最少字数，max 是文章最多字数，默认值设为 6000 和 10000。"]}),"\n",(0,s.jsxs)(n.h2,{id:"生成句子",children:["生成句子",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#生成句子",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"接下来我们要定义句子生成的规则。先来回顾一下我们的 corpus 的结构："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "title": [\n    "一天掉多少根头发",\n    "中午吃什么",\n    ...\n  ],\n  "famous":[\n    "爱迪生{{said}}，天才是百分之一的勤奋加百分之九十九的汗水。{{conclude}}",\n    "查尔斯\xb7史{{said}}，一个人几乎可以在任何他怀有无限热忱的事情上成功。{{conclude}}",\n    "培根说过，深窥自己的心，而后发觉一切的奇迹在你自己。{{conclude}}",\n    ...\n  ],\n  "bosh_before": [\n    "既然如此，",\n    "那么，",\n    "我认为，",\n    ...\n  ],\n  "bosh":[\n    "{{title}}的发生，到底需要如何做到，不{{title}}的发生，又会如何产生。 ",\n    "而这些并不是完全重要，更加重要的问题是，",\n    "{{title}}，到底应该如何实现。 ",\n    ...\n  ],\n  "conclude":[\n    "这不禁令我深思。 ",\n    "带着这句话，我们还要更加慎重的审视这个问题: ",\n    "这启发了我。",\n    ...\n  ],\n  "said":[\n    "曾经说过",\n    "在不经意间这样说过",\n    "说过一句著名的话",\n    ...\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["文章中的句子有两种类型，名人名言定义在 corpus 对象的",(0,s.jsx)(n.code,{children:"famous"}),"字段中；废话定义在corpus对象的",(0,s.jsx)(n.code,{children:"bosh"}),"字段中。剩下的几个字段",(0,s.jsx)(n.code,{children:"bosh_before"}),"、",(0,s.jsx)(n.code,{children:"said"}),"和",(0,s.jsx)(n.code,{children:"conclude"}),"是用来修饰和替换",(0,s.jsx)(n.code,{children:"famous"}),"以及",(0,s.jsx)(n.code,{children:"bosh"}),"里面的内容的。"]}),"\n",(0,s.jsx)(n.p,{children:"现在，我们利用上一节课实现的随机模块的 API，将句子中的内容从 famous、bosh 以及其他字段的数组中随机取出一条："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const pickFamous = createRandomPicker(corpus.famous);\nconst pickBosh = createRandomPicker(corpus.bosh);\n\npickFamous(); // 随机取出一条名人名言\n\npickBosh(); // 随机取出一条废话\n"})}),"\n",(0,s.jsx)(n.p,{children:"语料库中名人名言和废话的内容都是模板，形式类似于下面这样："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'"歌德曾经{{said}}，流水在碰到底处时才会释放活力。{{conclude}}" // 名人名言\n\n"{{title}}的发生，到底需要如何做到，不{{title}}的发生，又会如何产生。 " // 废话\n'})}),"\n",(0,s.jsxs)(n.p,{children:["因此，我们要将占位符",(0,s.jsx)(n.code,{children:"{{said}}"}),"用",(0,s.jsx)(n.code,{children:"corpus.said"}),"中随机取的内容替换，将占位符",(0,s.jsx)(n.code,{children:"{{conclude}}"}),"用",(0,s.jsx)(n.code,{children:"corpus.conclude"}),"中随机取的替换，将",(0,s.jsx)(n.code,{children:"{{title}}"}),"用传入的title字符串替换。"]}),"\n",(0,s.jsx)(n.p,{children:"我们可以实现一个替换句子的通用方法："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function sentence(pick, replacer) {\n  let ret = pick(); // 返回一个句子文本\n  for(const key in replacer) { // replacer是一个对象，存放替换占位符的规则\n    // 如果 replacer[key] 是一个 pick 函数，那么执行它随机取一条替换占位符，否则将它直接替换占位符\n    ret = ret.replace(new RegExp(`{{${key}}}`, 'g'),\n      typeof replacer[key] === 'function' ? replacer[key]() : replacer[key]);\n  }\n  return ret;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["sentence 函数接受两个参数：",(0,s.jsx)(n.code,{children:"pick"}),"和",(0,s.jsx)(n.code,{children:"replacer"}),"。",(0,s.jsx)(n.code,{children:"pick"}),"表示随机获取数组内容（比如 famous、bosh 等）的函数。",(0,s.jsx)(n.code,{children:"replacer"}),"是一个存放替换占位符的对象，如果 ",(0,s.jsx)(n.code,{children:"replacer[key]"})," 是一个 pick 函数，那么执行它随机取一条替换占位符，否则将它直接替换占位符。"]}),"\n",(0,s.jsx)(n.p,{children:"然后，我们就可以随便生成句子了："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const {famous, bosh_before, bosh, said, conclude} = corpus;\n\nconst [pickFamous, pickBoshBefore, pickBosh, pickSaid, pickConclude] = [famous, bosh_before, bosh, said, conclude].map((item) => {\n  return createRandomPicker(item);\n});\n\nsentence(pickFamous, {said: pickSaid, conclude: pickConclude}); // 生成一条名人名言\n\nsentence(pickBosh, {title});  // 生成一条废话\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"生成文章",children:["生成文章",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#生成文章",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"句子生成了之后，它们该如何组成段落和文章呢？我们知道，段落由句子组成，文章又由段落组成，所以可以进行如下假设："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"规定每个段落的字数在 200~500 字之间。每个段落包含 20%的名人名言（famous），80% 的废话（bosh)。其中，废话里带前置从句（bosh_before）的废话占文章句子的 30%，不带前置从句的废话占文章句子的 50%；"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"规定文章的字数在用户设置的最小字数到最大字数之间。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"按照上述的规则，我们来生成文章。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const articleLength = randomInt(min, max);\n\nwhile(totalLength < articleLength) {\n  // 如果文章内容的字数未超过文章总字数 继续生成段落\n  let section = ''; // 添加段落\n  const sectionLength = randomInt(200, 500); // 将段落长度设为200到500字之间\n  // 如果当前段落字数小于段落长度，或者当前段落不是以句号。和问号？结尾\n  while(section.length < sectionLength || !/[。？]$/.test(section)) {\n    // 取一个 0~100 的随机数\n    const n = randomInt(0, 100);\n    if(n < 20) { \n      添加名人名言\n    } else if(n < 50) {\n      添加带前置从句的废话\n    } else {\n      添加不带前置从句的废话\n    }\n  }\n  // 段落结束，更新总长度\n  totalLength += section.length;\n  // 将段落存放到文章列表中\n  article.push(section);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"这里面有一个细节，因为我们语料库中有一些句子不是以句号或问号结尾，比如结论（conclude）中有这样以冒号结尾的句子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'"带着这句话，我们还要更加慎重的审视这个问题： ",\n'})}),"\n",(0,s.jsx)(n.p,{children:"这样的句子，放在段落末尾不合适，因此段落结束除了要判断字数大于段落字数外，还要判断当前结尾处是问号或句号，才能结束当前段落另起一段。这样我们就实现了 generate 函数，它的完整代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"export function generate(title, {\n  corpus,\n  min = 6000, // 文章最少字数\n  max = 10000, // 文章最多字数\n} = {}) {\n  // 将文章长度设置为 min 到 max之间的随机数\n  const articleLength = randomInt(min, max);\n\n  const {famous, bosh_before, bosh, said, conclude} = corpus;\n  const [pickFamous, pickBoshBefore, pickBosh, pickSaid, pickConclude] = [famous, bosh_before, bosh, said, conclude].map((item) => {\n    return createRandomPicker(item);\n});\n\nconst article = [];\nlet totalLength = 0;\n\nwhile(totalLength < articleLength) {\n  // 如果文章内容的字数未超过文章总字数\n  let section = ''; // 添加段落\n  const sectionLength = randomInt(200, 500); // 将段落长度设为200到500字之间\n  // 如果当前段落字数小于段落长度，或者当前段落不是以句号。和问号？结尾\n  while(section.length < sectionLength || !/[。？]$/.test(section)) {\n    // 取一个 0~100 的随机数\n    const n = randomInt(0, 100);\n    if(n < 20) { // 如果 n 小于 20，生成一条名人名言，也就是文章中有百分之二十的句子是名人名言\n      section += sentence(pickFamous, {said: pickSaid, conclude: pickConclude});\n    } else if(n < 50) {\n      // 如果 n 小于 50，生成一个带有前置从句的废话\n      section += sentence(pickBoshBefore, {title}) + sentence(pickBosh, {title});\n    } else {\n      // 否则生成一个不带有前置从句的废话\n      section += sentence(pickBosh, {title});\n    }\n  }\n  // 段落结束，更新总长度\n  totalLength += section.length;\n  // 将段落存放到文章列表中\n  article.push(section);\n}\n\n// 将文章返回，文章是段落数组形式\nreturn article;\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"将文章输出",children:["将文章输出",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#将文章输出",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"实现了生成文章的 generate 函数，我们就可以将它输出到控制台，同时也可以保存成文件。我们先来看一下如何将它输出到控制台。我们改写一下 index.js 文件，把它变成下面这个样子："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"import {readFileSync} from 'fs';\nimport {fileURLToPath} from 'url';\nimport {dirname, resolve} from 'path';\n\nimport {generate} from './lib/generator.js';\nimport {createRandomPicker} from './lib/random.js';\n\nconst __dirname = dirname(fileURLToPath(import.meta.url));\n\nfunction loadCorpus(src) {\n  const path = resolve(__dirname, src);\n  const data = readFileSync(path, {encoding: 'utf-8'});\n  return JSON.parse(data);\n}\n\nconst corpus = loadCorpus('corpus/data.json');\n\nconst pickTitle = createRandomPicker(corpus.title);\nconst title = pickTitle();\n\nconst article = generate(title, {corpus});\nconsole.log(`${title}\\n\\n    ${article.join('\\n    ')}`);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["和第 6 节课相比，文件内容改动并不大。我们只是将读取 JSON 文件的代码封装成了一个函数",(0,s.jsx)(n.code,{children:"loadCorpus"}),"，然后通过",(0,s.jsx)(n.code,{children:"pickTitle"}),"随机选择一个 title，接着调用",(0,s.jsx)(n.code,{children:".lib/generator.js"}),"模块的 generator 方法拿到 article 数组，再通过字符串的 join 方法将数组里面的段落内容拼成文章，最后用",(0,s.jsx)(n.code,{children:"console.log"}),"输出。"]}),"\n",(0,s.jsx)(n.p,{children:"控制台输出的内容如下图："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样我们就将内容输出到控制台了。"}),"\n",(0,s.jsxs)(n.h2,{id:"用-fs-保存文件",children:["用 fs 保存文件",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用-fs-保存文件",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["如果我们想要将生成的文章保存下来，我们可以继续用第 6 节课学过的 fs 模块。fs 的",(0,s.jsx)(n.code,{children:"writeFile/writeFileSync"}),"正好和",(0,s.jsx)(n.code,{children:"readFile/readFileSync"}),"对应。我们可以直接使用",(0,s.jsx)(n.code,{children:"writeFileSync"}),"。先封装一个保存文件的函数："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function saveCorpus(title, article) {\n  const outputDir = resolve(__dirname, 'output');\n  const outputFile = resolve(outputDir, `${title}.txt`);\n\n  // 检查outputDir是否存在，没有则创建一个\n  if(!existsSync(outputDir)) {\n    mkdirSync(outputDir);\n  }\n\n  const text = `${title}\\n\\n    ${article.join('\\n    ')}`;\n  writeFileSync(outputFile, text); // 将text写入outputFile文件中\n\n  return outputFile;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这里我们除了使用",(0,s.jsx)(n.code,{children:"writeFileSync"}),"外，还使用了",(0,s.jsx)(n.code,{children:"existsSync"}),"和",(0,s.jsx)(n.code,{children:"mkdirSync"}),"，其中",(0,s.jsx)(n.code,{children:"existsSync"}),"判断当前文件目录下是否有 output 子目录，如果没有的话，则通过",(0,s.jsx)(n.code,{children:"mkdirSync"}),"创建它。然后通过",(0,s.jsx)(n.code,{children:"writeFileSync"}),"将文章内容写入对应的文件。这样我们在项目下执行 ",(0,s.jsx)(n.code,{children:"node index.js"}),"，就能够在 output 目录中找到生成的文章了。"]}),"\n",(0,s.jsxs)(n.h2,{id:"增加文件时间戳",children:["增加文件时间戳",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#增加文件时间戳",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"现在生成文章到 output 目录有一个问题，如果我们两次生成同一个主题的文章，新的文章就会将旧的文章给覆盖掉。一个比较好的解决办法是，我们在保存文件的时候，在文件名后面加上文件生成的时间。"}),"\n",(0,s.jsxs)(n.p,{children:["还记得我们在前面课程中介绍过的第三方库",(0,s.jsx)(n.code,{children:"moment.js"}),"吗？我们先通过 npm 安装这个模块："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ npm install moment --save\n"})}),"\n",(0,s.jsxs)(n.p,{children:["然后我们将",(0,s.jsx)(n.code,{children:"saveCorpus"}),"函数修改一下："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function saveCorpus(title, article) {\n  const outputDir = resolve(__dirname, 'output');\n  const time = moment().format('|YYYY-MM-DD|HH:mm:ss');\n  const outputFile = resolve(outputDir, `${title}${time}.txt`);\n\n  if(!existsSync(outputDir)) {\n    mkdirSync(outputDir);\n  }\n\n  const text = `${title}\\n\\n    ${article.join('\\n    ')}`;\n  writeFileSync(outputFile, text);\n\n  return outputFile;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这样我们就在文件名后面增加了时间戳，避免了覆盖相同主题的文件。下图是使用了",(0,s.jsx)(n.code,{children:"moment.js"}),"后生成并保存到",(0,s.jsx)(n.code,{children:"output"}),"目录中的文件。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:r,alt:""})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["这一节课，我们利用自己创建的随机模块，随机生成了文章的内容，并通过 fs 的",(0,s.jsx)(n.code,{children:"existsSync"}),"、",(0,s.jsx)(n.code,{children:"mkdirSync"}),"和",(0,s.jsx)(n.code,{children:"writeFileSync"}),"方法将它保存成了文件。"]}),"\n",(0,s.jsxs)(n.p,{children:["为了避免同名的文件覆盖，我们还安装了",(0,s.jsx)(n.code,{children:"moment.js"}),"库，使用了",(0,s.jsx)(n.code,{children:"moment().format"}),"将日期时间格式化，作为文件名的一部分保存，避免了文件的冲突。",(0,s.jsx)(n.code,{children:"moment.js"}),"是一个处理日期时间非常好用的开源库，如果你有兴趣可以访问",(0,s.jsx)(n.code,{children:"moment.js"}),"的",(0,s.jsx)(n.a,{href:"https://github.com/moment/moment",target:"_blank",rel:"noopener noreferrer",children:"GitHub仓库"}),"了解更多的用法。"]}),"\n",(0,s.jsxs)(n.p,{children:["现在我们可以通过 Node.js 命令生成随机的文章并输出了，但还不能自己指定标题，也不能设置最大字数和最小字数。在下一节课里，我们将通过",(0,s.jsx)(n.code,{children:"process"}),"模块来实现与 Node.js 命令交互，让我们可以方便地指定文章标题、最大字数和最小字数。"]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}let d=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["%E4%BB%8E%E5%89%8D%E7%AB%AF%E5%88%B0%E5%85%A8%E6%A0%88%2F8%20%E6%96%87%E7%AB%A0%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%20fs%20%E6%A8%A1%E5%9D%97%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6%EF%BC%9F.md"]={toc:[{text:"生成句子",id:"生成句子",depth:2},{text:"生成文章",id:"生成文章",depth:2},{text:"将文章输出",id:"将文章输出",depth:2},{text:"用 fs 保存文件",id:"用-fs-保存文件",depth:2},{text:"增加文件时间戳",id:"增加文件时间戳",depth:2},{text:"总结",id:"总结",depth:2}],title:"8 文章生成器：如何用 fs 模块保存文件？",headingTitle:"8 文章生成器：如何用 fs 模块保存文件？",frontmatter:{}}}}]);