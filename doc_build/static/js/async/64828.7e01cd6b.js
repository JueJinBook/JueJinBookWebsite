"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["64828"],{385629:function(e,n,s){s.r(n),s.d(n,{default:()=>S});var c=s(552676),i=s(740453);let r=s.p+"static/image/d739474b429a39d9e748e073e0450f27.b6dc925f.webp",t=s.p+"static/image/4eee95b5f0073156551de67e30a36b1b.a8ec32f7.webp",a=s.p+"static/image/14ca93f7eb8dae9f369a8e6a23cf880b.10a94f62.webp",p=s.p+"static/image/1fda8bd58494d957f917086c3d23cd40.e4d337d7.webp",d=s.p+"static/image/2f2f0660fee684175883f8b851180b7d.db4cd472.webp",l=s.p+"static/image/23acd14cb0a8f34f718be771cdc3d4f2.2580eb45.webp",h=s.p+"static/image/bd94e05d95817b7f75aa5d868aa1c24f.63dbf008.webp",j=s.p+"static/image/9b444ed59544964e485d45ffd2a42606.b820742e.webp",x=s.p+"static/image/f8b1e492e44943f1e13691ab23403e6e.fee5f6d1.webp",o=s.p+"static/image/3befce0610513f35f3f3bf939b13a3cf.991ab82c.webp",b=s.p+"static/image/01cf7ca986a9c1cb0b1c9b5b56a2d38c.837cc982.webp",g=s.p+"static/image/0bce28f940fdcfa8a8a69cb0ee583f37.d0c2aca9.webp",m=s.p+"static/image/df99ff58964b044528526d2212ece0fa.ce575017.webp",f=s.p+"static/image/cd407ed1a8de36ac7cf1a94d157b1aba.4bfbb297.webp",y=s.p+"static/image/f87356a3578b0d0119d90d5cef89482b.a9e9e35e.webp",u=s.p+"static/image/133376191d8a72387984b3e6bca65d23.5dd5ec2c.webp",T=s.p+"static/image/4702b72e276524d46e09b5cfc02aa8f1.e8e031e9.webp",E=s.p+"static/image/1d4f17d9d85212e02045b517ed3598e8.dc33b950.webp";function w(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,i.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"22实战案例调试-typescript-源码",children:["22.实战案例：调试 TypeScript 源码",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22实战案例调试-typescript-源码",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"不知道大家对 ts 是否熟悉，你觉得下面这段 ts 代码，res 类型是什么？"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:"type Test<T> = T extends number ? 1 : 2;\n\ntype res = Test<any>;\n"})}),"\n",(0,c.jsx)(n.p,{children:"结果是 1 | 2 的联合类型："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"很多同学会感到迷惑，为什么是这样呢？"}),"\n",(0,c.jsx)(n.p,{children:"这就要从源码找答案了，今天我们就来调试下 ts 源码来探究上面这个类型的求值过程。"}),"\n",(0,c.jsx)(n.p,{children:"首先，我们要把 ts 源码下载下来（加个 depth=1 可以下载单 commit，速度比较快）"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"git clone --depth=1 git@github.com:microsoft/TypeScript.git\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后可以看到 lib 目录下有 tsc.js 和 typescript.js，这两个分别是 ts 的命令行和 api 的入口。"}),"\n",(0,c.jsx)(n.p,{children:"但是，这些是编译以后的 js 代码，源码在 src 下，是用 ts 写的。"}),"\n",(0,c.jsx)(n.p,{children:"怎么把编译后的 js 代码和 ts 源码关联起来呢？ sourcemap！"}),"\n",(0,c.jsx)(n.p,{children:"编译源码："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{children:"yarn \nyarn run build:compiler\n"})}),"\n",(0,c.jsx)(n.p,{children:"然后就可以看到多了一个 built 目录，下面有 tsc.js、typescript.js 这两个入口文件，而且也有了 sourcemap："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:E,alt:""})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:T,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"接下来就可以直接调试 ts 源码，而不是编译后的 js 代码了。"}),"\n",(0,c.jsx)(n.p,{children:"我们来试试："}),"\n",(0,c.jsx)(n.p,{children:"添加一个 node 调试配置："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:u,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n    "name": "调试 ts 源码",\n    "program": "${workspaceFolder}/built/local/tsc.js",\n    "request": "launch",\n    "skipFiles": [\n        "<node_internals>/**"\n    ],\n    "console": "integratedTerminal",\n    "args": [\n        "./input.ts"\n    ],\n    "type": "node"\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"入口是 tsc，我们找到 src/tsc/tsc.ts 打个断点："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:y,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"然后 debug 启动，就会发现它断住了："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:f,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这就是命令行的入口。"}),"\n",(0,c.jsx)(n.p,{children:"而且我们是直接调试 ts 源码的，在 ts 源码里打的断点，这就是 sourcemap 的作用。"}),"\n",(0,c.jsx)(n.p,{children:"但是你会发现 ts 代码太多了，不知道哪些是解析类型的逻辑，在哪里打断点比较好。"}),"\n",(0,c.jsx)(n.p,{children:"这种情况还是用 api 的方式调试比较好。"}),"\n",(0,c.jsx)(n.p,{children:"我们创建一个 test.js，输入这样的代码："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-typescript",children:'const ts = require("./built/local/typescript");\n\nconst filename = "./input.ts";\nconst program = ts.createProgram([filename], {\n    allowJs: false,\n    strictNullChecks: true\n});\n\nconst sourceFile = program.getSourceFile(filename);\nconst typeChecker = program.getTypeChecker();\n\nfunction visitNode(node) {\n    if (node.kind === ts.SyntaxKind.TypeAliasDeclaration && node.name.escapedText === \'res\')  {\n        const type = typeChecker.getTypeFromTypeNode(node.name);\n\n        console.log(type);\n    }\n\n    node.forEachChild(child =>\n        visitNode(child)\n    );\n}\n\nvisitNode(sourceFile);\n'})}),"\n",(0,c.jsx)(n.p,{children:"ts.createProgram 就是 ts 的 api 入口，通过 program.getSourceFile 拿到的是 AST，通过 program.getTypeChecker 拿到的是实现类型检查的 type cheker。"}),"\n",(0,c.jsx)(n.p,{children:"遍历 AST，找到 AST 类型为类型别名，并且名字是 res 的节点，然后调用 typeCheker.getTypeFromTypenode 进行类型检查。"}),"\n",(0,c.jsxs)(n.p,{children:["想知道代码哪部分是什么 AST 可以通过 ",(0,c.jsx)(n.a,{href:"https://astexplorer.net/#/gist/3a718a7f5072cdaad804c0ebec076526/5baa661cc653c9846479de3f012f6fbd8dbe1fd3",target:"_blank",rel:"noopener noreferrer",children:"astexplorer.net"})," 来查看："]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:m,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这样我们就完成了用 ts 对 res 的节点进行类型检查的逻辑。"}),"\n",(0,c.jsx)(n.p,{children:"接下来开始调试。"}),"\n",(0,c.jsx)(n.p,{children:"创建这样的调试配置："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:g,alt:""})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n    "name": "调试 ts 源码",\n    "program": "${workspaceFolder}/test.js",\n    "request": "launch",\n    "skipFiles": [\n        "<node_internals>/**"\n    ],\n    "console": "integratedTerminal",\n    "args": [\n    ],\n    "type": "node"\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"在类型检查这行打个断点："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:b,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"启动调试，你会发现断住的地方就是我们在 astexplorer.net 里看到的那个 AST 节点："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:o,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"点击 step into 进入函数内部，然后单步执行，你会走到这样的代码："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:x,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"这个就是根据不同的 node.type 来进行不同的类型检查过程的枢纽："}),"\n",(0,c.jsx)(n.p,{children:"当然它中间会进行很多节点的类型检查过程，而我们只关心 ? : 的部分，也就是 Conditional Type 的部分："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:j,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"所以在这一行打个断点："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:h,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"断住之后，step into 进入内部："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:l,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"发现这里调用了个 getConditionalType 的方法。"}),"\n",(0,c.jsx)(n.p,{children:"我们只是想看下条件类型里 any 是怎么处理的，在 getConditionalType 方法的开始处搜索下 any 就可以找到这一行代码："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:d,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"看注释 Return union of trueType and falseType for 'any' since it matches anything 的意思就是如果左边是 any，那就返回 trueType 和 falseType 的联合类型。"}),"\n",(0,c.jsx)(n.p,{children:"checkType、extendsType、trueType、falseType 也可以在 AST 里找到："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:p,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"我们定位到条件类型里处理 any 的地方里，在这里打个断点："}),"\n",(0,c.jsx)(n.p,{children:"会发现代码确实走到了这里："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:a,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"最后在打印的地方打个断点就可以看到返回的是  trueType 和 falseType 的联合类型。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:t,alt:""})}),"\n",(0,c.jsx)(n.p,{children:"至此，我们通过源码理清了条件类型左边为 any 的时候，为什么会返回这样的结果："}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)("img",{src:r,alt:""})}),"\n",(0,c.jsxs)(n.h2,{id:"总结",children:["总结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"ts 里很多类型的解释需要从源码找答案，我们调试了下 ts 的源码："}),"\n",(0,c.jsx)(n.p,{children:"通过 sourcemap 关联到了 src 下的代码，然后在源码里打断点。"}),"\n",(0,c.jsx)(n.p,{children:"api 的方式比命令行的方式更精准一些，我们可以直接调用 api 对目标 AST 进行类型检查，然后进入源码内部探究原因。"}),"\n",(0,c.jsx)(n.p,{children:"定位到处理条件类型的方法，然后搜索了下处理 any 的地方，打了个断点来验证，最终找到了条件类型为 any 的时候，返回的是一个联合类型的原因。"}),"\n",(0,c.jsx)(n.p,{children:"ts 源码的调试确实很复杂，但是我们通过 sourcemap 定位到源码、通过 api 调试、结合搜索来打断点，还是能读懂一些类型的处理流程的。"})]})}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(w,{...e})}):w(e)}let S=A;A.__RSPRESS_PAGE_META={},A.__RSPRESS_PAGE_META["%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F22.%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E8%B0%83%E8%AF%95%20TypeScript%20%E6%BA%90%E7%A0%81.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"22.实战案例：调试 TypeScript 源码",headingTitle:"22.实战案例：调试 TypeScript 源码",frontmatter:{}}}}]);