"use strict";(self.webpackChunkjue_jin_book_press=self.webpackChunkjue_jin_book_press||[]).push([["94765"],{440214:function(e,n,r){r.r(n),r.d(n,{default:()=>z});var s=r(552676),a=r(740453);let c=r.p+"static/image/facb871c75eaf16f237bca7fb8ef6c1b.cea216d3.webp",t=r.p+"static/image/9cac311ae5632b3aa85d7cb36a4a1d47.75fb8978.webp",i=r.p+"static/image/1a7142dbe3b6529e96c5858d39005948.0812d31e.webp",p=r.p+"static/image/33b8ae0e0ffb4273a53aab53421beb1c.afbe1a0b.webp",d=r.p+"static/image/48c57e79044a4a1dca2b0d723965ed95.7ba1eb5b.gif",o=r.p+"static/image/e5b54f7b807f857a152a72ae6922b945.a5f435a5.webp",l=r.p+"static/image/8c7f23ef96741a21620a92e86787f172.da4665d8.webp",h=r.p+"static/image/cf0fd912b93dd38a1d4d13e523187336.46909d17.webp",j=r.p+"static/image/e06f45e03cb494d3533ca1810623ee02.07e9fc38.webp",u=r.p+"static/image/1cdf81d69b5b96f17f03f3996b434137.f55d7b5f.gif",x=r.p+"static/image/c198796850fe0c04e97fa1ffa86aaeda.56e21b46.webp",m=r.p+"static/image/632b594de54edc0d0fa9f201cd2b063e.19b0dde8.webp",f=r.p+"static/image/2fe35d7efbef03e37d9512ea6be78040.3aef1ef1.webp",b=r.p+"static/image/1a1435b6305e8bb1ab6a0a7daa62cb45.b4870e55.webp",g=r.p+"static/image/caabe038f8a9ec76590dcbd63ebbeefc.41b7617e.webp",A=r.p+"static/image/c0721cb9b2f5a0c46f18f6eb12f39243.309e3cff.webp",v=r.p+"static/image/ee7cd1122e3ffc2743654b22e6e0bb08.d5fae10f.webp",w=r.p+"static/image/774c6739b13cdba7727fad831628ece0.af7e21a5.webp",E=r.p+"static/image/5bb79beea45b20336ee31c9a7b397d1c.c9cc1045.webp",S=r.p+"static/image/23f8350dabf0383b2c289b47b3fac588.2ef0977f.webp",B=r.p+"static/image/96d2410a3e223241c51b7af5b1ce9442.1980468e.webp",y=r.p+"static/image/dc8601b817fcecc6c393b394cd3c7b21.3825c33b.webp",k=r.p+"static/image/575567ca445bd6224d2062a97fba6e3d.a8e1ba48.gif",R=r.p+"static/image/7aa1b9236d4dd753bfefb60d7de7ce47.9c2fdf94.webp",I=r.p+"static/image/797429c66a44757ac8efdd8899fd3806.e6d84777.webp",D=r.p+"static/image/cf36e3b5a00f096461bc60faa35470b2.9dc222b4.webp",X=r.p+"static/image/0e797065dcb177233f81ae43708aa1c0.ba65150a.webp",P=r.p+"static/image/ad74b8a3fb567933a9eadd748e6b41d7.d7f328bd.gif",N=r.p+"static/image/f6ed7336152147886de5502e748e6836.72a97b0a.webp";function C(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",img:"img",h2:"h2"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"第12章深入理解suspense和errorboundary",children:["第12章—深入理解Suspense和ErrorBoundary",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#第12章深入理解suspense和errorboundary",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"\uFEFFReact 里有两种组件，看似没啥关系，但在实现原理上却是很接近。"}),"\n",(0,s.jsx)(n.p,{children:"它们就是 Suspense 和 ErrorBoundary。"}),"\n",(0,s.jsx)(n.p,{children:"新建个项目："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npx create-react-app --template=typescript suspense-error-boundary\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:N,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"先来看下 Suspense 组件："}),"\n",(0,s.jsx)(n.p,{children:"Suspense 组件是和 React.lazy 结合用，用来加载一些异步组件。"}),"\n",(0,s.jsx)(n.p,{children:"新建一个组件 Aaa.tsx："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// src/Aaa.jsx\nexport default function Aaa() {\n    return <div>aaa</div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"在 App.tsx 里加载用 lazy + Suspense 异步加载它："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import React, { Suspense } from 'react';\n\nconst LazyAaa = React.lazy(() => import('./Aaa'));\n\nexport default function App() {\n  return <div>\n    <Suspense fallback={'loading...'}>\n      <LazyAaa></LazyAaa>\n    </Suspense>\n  </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"fallback 参数指定在过程中显示的内容，加载完成后，显示懒加载的组件内容。"}),"\n",(0,s.jsx)(n.p,{children:"把开发服务跑起来："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm run start\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后就可以在浏览器里看到异步加载组件的过程："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:P,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"当然，因为本地加载比较快，你可以用 chrome devtools 改成慢速网络再刷新看看："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:X,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:D,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这里的 import 是 webpack 提供的用来异步加载模块的 api，它会动态下载模块所在的 chunk，然后从中解析出该模块，拿到 export 的值："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:I,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"后台管理系统用这个挺多的，因为不可能一下子把所有路由的组件都下载下来，所以会用 lazy + Suspense 的方式异步加载暂时用不到的路由对应的组件。"}),"\n",(0,s.jsx)(n.p,{children:"大多数场景下，Suspense 就专门和 lazy 搭配使用的。"}),"\n",(0,s.jsx)(n.p,{children:"但有的时候，你会发现 Suspense 不搭配 lazy 也可以。"}),"\n",(0,s.jsx)(n.p,{children:"比如 jotai 这个状态管理库，它就号称支持了 Suspense。"}),"\n",(0,s.jsx)(n.p,{children:"我们安装下 jotai："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install jotai\n"})}),"\n",(0,s.jsx)(n.p,{children:"然后写下 App2.tsx"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Suspense } from 'react'\nimport { atom, useAtom } from 'jotai'\n\nconst userAtom = atom(async (get) => {\n  const userId = 1;\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/users/${userId}?_delay=2000`\n  )\n  return response.json()\n})\n\nconst UserName = () => {\n  const [user] = useAtom(userAtom)\n  return <div>User name: {user.name}</div>\n}\n\nexport default function App() {\n  return <Suspense fallback=\"Loading...\">\n    <UserName />\n  </Suspense>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"渲染下这个组件："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:R,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"浏览器访问下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:k,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，Suspense 依然是生效的。"}),"\n",(0,s.jsx)(n.p,{children:"现在并不是用 lazy 异步加载组件呀，怎么触发的 Suspense 呢？"}),"\n",(0,s.jsx)(n.p,{children:"这个问题稍后回答，我们先转过头来看下 ErrorBoundary。"}),"\n",(0,s.jsx)(n.p,{children:"前面讲过，现在 react 官网都推荐用 function 组件而不是 class 组件了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:y,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"绝大多数情况我们用 function 组件就好了，没必要用 class 组件。"}),"\n",(0,s.jsx)(n.p,{children:"但是有一个特性是只有 class 组件才有的，就是 ErrorBoundary。"}),"\n",(0,s.jsx)(n.p,{children:"这样写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { Component } from "react";\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, message: error.message };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>出错了： {this.state.message}</div>;\n    }\n    return this.props.children;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"当子组件报错的时候，会把错误传递给它的 getDerivedStateFromError 和 componentDidCatch 方法。"}),"\n",(0,s.jsx)(n.p,{children:"getDerivedStateFromError 接收 error，返回一个新的 state，会触发重新渲染来显示错误对应的 UI。"}),"\n",(0,s.jsx)(n.p,{children:"componentDidCatch 接收 error 和堆栈 info，可以用来打印错误日志。"}),"\n",(0,s.jsx)(n.p,{children:"我们写个 App3.jsx 试一下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { Component } from "react";\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      hasError: false\n    };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, message: error.message };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    console.log(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <div>出错了： {this.state.message}</div>;\n    }\n    return this.props.children;\n  }\n}\n\nfunction Bbb() {\n    const b = window.a.b;\n\n    return <div>{b}</div>\n}\n\nexport default function App() {\n    return <ErrorBoundary>\n        <Bbb></Bbb>\n    </ErrorBoundary>\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"注意，这里是 jsx，因为不想处理 class 组件的类型。"}),"\n",(0,s.jsx)(n.p,{children:"用 ErrorBoundary 组件包裹 Bbb 组件，Bbb 组件里会报错，因为 window.a.b 不存在。"}),"\n",(0,s.jsx)(n.p,{children:"正常情况下报错后会页面白屏。"}),"\n",(0,s.jsx)(n.p,{children:"我们渲染下这个组件："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:B,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"现在有 ErrorBoundary 是这样的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:S,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"把 ErrorBoundary 去掉后，可以看到，页面直接白屏了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:E,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这就是 ErrorBoundary 的作用，捕获子组件抛出的错误，显示对应的 UI。"}),"\n",(0,s.jsx)(n.p,{children:"回过头来看下这两个方法："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:w,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"getDerivedStateFromError 修改 state 触发重新渲染，渲染出错误对应的 UI。"}),"\n",(0,s.jsx)(n.p,{children:"componentDidCatch 拿到错误信息，打印日志。"}),"\n",(0,s.jsx)(n.p,{children:"这样，就对组件抛错的情况做了兜底。"}),"\n",(0,s.jsx)(n.p,{children:"这个特性只有 class 组件有，function 组件没有："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:v,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"不过一般也不用自己写这种 ErrorBoundary 组件，直接用 react-error-boundary 这个包就行："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"npm install --save react-error-boundary\n"})}),"\n",(0,s.jsx)(n.p,{children:"创建 App4.tsx"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { ErrorBoundary } from \"react-error-boundary\";\n\nfunction Bbb() {\n    useEffect(() => {\n        throw new Error('xxx');\n    }, [])\n    return <div>bbb</div>\n}\n\nexport default function App() {\n  return <ErrorBoundary fallbackRender={({ error }) => {\n        return <div>\n        <p>出错了：</p>\n        <div>{error.message}</div>\n    </div>\n  }}>\n    <Bbb></Bbb>\n  </ErrorBoundary>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"渲染下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:A,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，ErrorBoundary 生效了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:g,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而且并不一定是 ErrorBoundary 的 children，任意层级的子组件都可以："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'import { useEffect } from "react";\nimport { ErrorBoundary } from "react-error-boundary";\n\nfunction Bbb() {\n    useEffect(() => {\n        throw new Error(\'xxx\');\n    }, [])\n    return <div>bbb</div>\n}\n\nfunction Aaa() {\n    return <Bbb></Bbb>\n}\n\nexport default function App() {\n    return <ErrorBoundary fallbackRender={({ error }) => {\n            return <div>\n                <p>出错了：</p>\n                <div>{error.message}</div>\n            </div>\n    }}>\n        <Aaa></Aaa>\n    </ErrorBoundary>\n}\n\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,s.jsx)(n.p,{children:"也就是说组件抛错的时候，会向上寻找最近的 ErrorBoundary 组件。"}),"\n",(0,s.jsx)(n.p,{children:"这也是 boundary 的含义。"}),"\n",(0,s.jsx)(n.p,{children:"话说回来，为什么讲 Suspense 要扯到 ErrorBoundary 呢？"}),"\n",(0,s.jsx)(n.p,{children:"这俩有啥关系？"}),"\n",(0,s.jsx)(n.p,{children:"其实 Suspense 也是用 throw error 的方式实现的。"}),"\n",(0,s.jsx)(n.p,{children:"创建 App5.jsx："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Suspense } from \"react\";\n\nlet data, promise;\nfunction fetchData() {\n  if (data) return data;\n  promise = new Promise(resolve => {\n    setTimeout(() => {\n      data = '取到的数据'\n      resolve()\n    }, 2000)\n  })\n  throw promise;\n}\n\nfunction Content() {\n  const data = fetchData();\n  return <p>{data}</p>\n}\n\nexport default function App() {\n  return (\n    <Suspense fallback={'loading data'}>\n      <Content />\n    </Suspense>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"渲染下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:b,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"可以看到，触发了 Suspense："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"也就是说，只要 throw 一个 promise，就会被最近的 Suspense 捕获。"}),"\n",(0,s.jsx)(n.p,{children:"promise 初始状态展示 fallback，promise 改变状态后展示子组件。"}),"\n",(0,s.jsx)(n.p,{children:"那 React.lazy 是不是也是基于这个实现的呢？"}),"\n",(0,s.jsx)(n.p,{children:"看下源码，发现确实是这样："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:f,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"React.lazy 包裹之后，也会 throw 一个 promise 来触发 Suspense。"}),"\n",(0,s.jsx)(n.p,{children:"当 promise 改变状态后，再返回拿到的值。"}),"\n",(0,s.jsx)(n.p,{children:"这样为什么 jotai 可以支持 Suspense 我们也就知道了："}),"\n",(0,s.jsx)(n.p,{children:"也是这样实现的："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:m,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"有的同学可能会问了：ErrorBoundary 是捕获组件 throw 的错误，而 Suspense 是捕获组件 throw 的 promise，这俩会冲突么？"}),"\n",(0,s.jsx)(n.p,{children:"试一下就知道了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:x,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"const fallbackRender = ({ error }) => {\n  return <div>\n      <p>出错了：</p>\n      <div>{error.message}</div>\n  </div>\n}\n\nexport default function App() {\n  return (\n    <Suspense fallback={'loading data'}>\n      <ErrorBoundary fallbackRender={fallbackRender}>\n        <Content />\n      </ErrorBoundary>\n    </Suspense>\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"包裹一层 ErrorBoundary，你会发现 throw promise 没有触发它："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:u,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"而 throw 一个 error 的时候："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:j,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"ErrorBoundary 就触发了："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/webp;base64,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",alt:""})}),"\n",(0,s.jsx)(n.p,{children:"也就是说，ErrorBoundary 和 Suspense 虽然都是捕获组件 throw 出的东西，但这俩互不相干，一个捕获 error，一个捕获 promise。"}),"\n",(0,s.jsx)(n.p,{children:"大概看下源码的处理："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:h,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"首先会全部 catch，然后内部再区分两种情况："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如果 throw 的是 error，就是 error boundary 的处理逻辑，找最近的一个 ErrorBoundary 组件来处理。"}),"\n",(0,s.jsx)(n.p,{children:"如果 throw 的是 promise，则是 suspense boundary 的处理逻辑，找最近的 Suspense 组件来处理。"}),"\n",(0,s.jsx)(n.p,{children:"两者互不相干。"}),"\n",(0,s.jsx)(n.p,{children:"但业务代码我们不用 Suspense 来写这种 loading。"}),"\n",(0,s.jsx)(n.p,{children:"大家都这么写："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { useEffect, useState } from \"react\";\n\nfunction fetchData(): Promise<{name: string}> {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        name: 'guang'\n      });\n    }, 2000)\n  })\n}\n\nexport default function App() {\n  const [loading, setLoading] = useState(false);\n  const [data, setData] = useState<{name?: string}>({});\n\n\n  async function load() {\n    setLoading(true);\n    const data = await fetchData();\n    setData(data);\n    setLoading(false);\n  }\n\n  useEffect(() => {\n    load();\n  }, []);\n\n  return <div>\n    { loading ? 'loding...' : data.name }\n  </div>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"渲染下："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:o,alt:""})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:d,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"就是加一个 state 来记录 loading 状态就行了。"}),"\n",(0,s.jsx)(n.p,{children:"要是用 Suspense，需要 throw 一个 promise 才行，那可太费劲了，而且代码也不好维护。"}),"\n",(0,s.jsx)(n.p,{children:"不过如果你用了一些支持 Suspense 的框架，比如 jotai、next.js 等，那也可以用 Suspense。"}),"\n",(0,s.jsx)(n.p,{children:"框架内部给你做了 throw promise 的事情。"}),"\n",(0,s.jsx)(n.p,{children:"比如我们前面用的 jotai 就做了支持："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { Suspense } from 'react'\nimport { atom, useAtom } from 'jotai'\n\nconst userAtom = atom(async (get) => {\n  const userId = 1;\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/users/${userId}?_delay=2000`\n  )\n  return response.json()\n})\n\nconst UserName = () => {\n  const [user] = useAtom(userAtom)\n  return <div>User name: {user.name}</div>\n}\n\nexport default function App() {\n  return <Suspense fallback=\"Loading...\">\n    <UserName />\n  </Suspense>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"本来 Suspense 就是用来做这个的，结果现在只有 lazy 加载异步组件的时候才能用。"}),"\n",(0,s.jsx)(n.p,{children:"react 团队也在想办法解决这个问题，所以出了一个  use 的 hook："}),"\n",(0,s.jsx)(n.p,{children:"这样用："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:p,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"它的参数是 promise。"}),"\n",(0,s.jsx)(n.p,{children:"当 promise 在 pending 的时候，展示 suspense 的 fallback。"}),"\n",(0,s.jsx)(n.p,{children:"当 promise 是 resolve 的时候，展示 Suspense 的子组件。"}),"\n",(0,s.jsx)(n.p,{children:"当 promise 是 reject 的时候，展示 ErrorBoundary 的 fallback。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"这样就不用自己 throw promise 了，业务代码就可以用 Suspense 来 loading 了。"}),"\n",(0,s.jsx)(n.p,{children:"不过别高兴太早，这个 use 的 hook 还在实验阶段，还没正式发布。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://react.dev/reference/react/use",target:"_blank",rel:"noopener noreferrer",children:"文档的传送门"})}),"\n",(0,s.jsx)(n.p,{children:"我们刚才用的 jotai 就自己实现了一下 use："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:t,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"就是 pending 的时候 throw promise，reject 的时候 throw error，否则 return 数据。"}),"\n",(0,s.jsx)(n.p,{children:"等 use 这个 hook 正式发布了，大家就可以告别自己写个 state 标识 loading 状态这种方式了，直接用 Suspense。"}),"\n",(0,s.jsx)(n.p,{children:"这就是文档里写的触发 Suspense 的 3 种方式："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:c,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"一种是用支持 Suspense 的框架，比如 next.js 或者 jotai。"}),"\n",(0,s.jsx)(n.p,{children:"一种是 lazy 异步加载组件。"}),"\n",(0,s.jsx)(n.p,{children:"再一种就是还在实验阶段的 use 了。"}),"\n",(0,s.jsx)(n.p,{children:"这些不同的方式底层都是 throw promise。"}),"\n",(0,s.jsxs)(n.p,{children:["案例代码上传了",(0,s.jsx)(n.a,{href:"https://github.com/QuarkGluonPlasma/react-course-code/tree/main/suspense-error-boundary",target:"_blank",rel:"noopener noreferrer",children:"小册仓库"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"大多数人用 Suspense 都是结合 React.lazy 异步加载组件的时候用，其实它也可以独立用。"}),"\n",(0,s.jsx)(n.p,{children:"它的底层原理就是 throw 一个 promise，然后 React 会捕获这个 promise，交给最近的 Suspense 组件来处理。"}),"\n",(0,s.jsx)(n.p,{children:"类似的，ErrorBoundary 也是这种处理方式，只不过捕获的是 throw 的 error。"}),"\n",(0,s.jsx)(n.p,{children:"ErrorBoundary 只能是 class 组件的形式，通过 getDerivedStateFromError 方法来接收错误修改 state，以及 componentDidCatch 来打印错误日志。"}),"\n",(0,s.jsx)(n.p,{children:"自己写 throw promise 来触发 Suspense 还是很麻烦的，一般我们都不用这个，而是自己写个 loading 的 state 来标识。"}),"\n",(0,s.jsx)(n.p,{children:"不过当你用 next.js、jotai 等框架的时候，因为内部做了 throw promise 的封装，就可以直接用 Suspense 了。"}),"\n",(0,s.jsx)(n.p,{children:"此外，react 有一个 use 的 hook，可以接收 promise，在 pending 的时候触发 Suspense，在 reject 的时候触发 ErrorBoundary，底层原理就是 throw error 和 promise。"}),"\n",(0,s.jsx)(n.p,{children:"这个 hook 还在实验阶段，等正式发布之后，估计代码里就会有大量 Suspense 了。"}),"\n",(0,s.jsx)(n.p,{children:"Suspense 和 ErrorBoundary 看似是两种不同的东西，但其实不管是用法还是实现原理，都是很类似的。"})]})}function H(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(C,{...e})}):C(e)}let z=H;H.__RSPRESS_PAGE_META={},H.__RSPRESS_PAGE_META["React%20%E9%80%9A%E5%85%B3%E7%A7%98%E7%B1%8D%2F%E7%AC%AC12%E7%AB%A0%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Suspense%E5%92%8CErrorBoundary.md"]={toc:[{text:"总结",id:"总结",depth:2}],title:"第12章—深入理解Suspense和ErrorBoundary",headingTitle:"第12章—深入理解Suspense和ErrorBoundary",frontmatter:{}}}}]);